From 5fd50f4d3e2ff929ec86c1a82bb2ac2d719a02cd Mon Sep 17 00:00:00 2001
From: hongbo zhong <hongbo.zhong@windriver.com>
Date: Thu, 26 Aug 2010 16:08:24 +0800
Subject: [v4 PATCH 1/5] Add Topcliff PHUB support

Add intel Topcliff PHUB support.

[Original code taken from http://sourceforge.net/
projects/generalembedded/files/]

Signed-off-by: Masayuki Ohtake <masa-korg@dsn.okisemi.com>
Integrated-by: Zhong hongbo <Hongbo.Zhong@windriver.com>
---
 drivers/char/Kconfig                 |    7 +
 drivers/char/Makefile                |    2 +
 drivers/char/pch_phub/Makefile       |    9 +
 drivers/char/pch_phub/pch_common.h   |  147 +++++++++
 drivers/char/pch_phub/pch_debug.h    |   58 ++++
 drivers/char/pch_phub/pch_phub.c     |  360 ++++++++++++++++++++++
 drivers/char/pch_phub/pch_phub.h     |  193 ++++++++++++
 drivers/char/pch_phub/pch_phub_hal.c |  544 ++++++++++++++++++++++++++++++++++
 drivers/char/pch_phub/pch_phub_hal.h |  124 ++++++++
 drivers/char/pch_phub/pch_phub_pci.c |  494 ++++++++++++++++++++++++++++++
 10 files changed, 1938 insertions(+), 0 deletions(-)
 create mode 100644 drivers/char/pch_phub/Makefile
 create mode 100644 drivers/char/pch_phub/pch_common.h
 create mode 100644 drivers/char/pch_phub/pch_debug.h
 create mode 100644 drivers/char/pch_phub/pch_phub.c
 create mode 100644 drivers/char/pch_phub/pch_phub.h
 create mode 100644 drivers/char/pch_phub/pch_phub_hal.c
 create mode 100644 drivers/char/pch_phub/pch_phub_hal.h
 create mode 100644 drivers/char/pch_phub/pch_phub_pci.c

diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index 3141dd3..2cfa460 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -4,6 +4,13 @@
 
 menu "Character devices"
 
+config PCH_PHUB
+        tristate "PCH PHUB"
+        depends on PCI
+        help
+          If you say yes to this option, support will be included for the
+          PCH Packet Hub Host controller.
+
 config VT
 	bool "Virtual terminal" if EMBEDDED
 	depends on !S390
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index f957edf..617c983 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -111,6 +111,8 @@ obj-$(CONFIG_PS3_FLASH)		+= ps3flash.o
 obj-$(CONFIG_JS_RTC)		+= js-rtc.o
 js-rtc-y = rtc.o
 
+obj-$(CONFIG_PCH_PHUB) += pch_phub/
+
 # Files generated that shall be removed upon make clean
 clean-files := consolemap_deftbl.c defkeymap.c
 
diff --git a/drivers/char/pch_phub/Makefile b/drivers/char/pch_phub/Makefile
new file mode 100644
index 0000000..51d94dd
--- /dev/null
+++ b/drivers/char/pch_phub/Makefile
@@ -0,0 +1,9 @@
+ifeq ($(CONFIG_PHUB_DEBUG),y)
+EXTRA_CFLAGS += -DDEBUG
+endif
+
+obj-$(CONFIG_PCH_PHUB) += pch_phub_drv.o
+#to set CAN clock to 50Mhz
+EXTRA_CFLAGS+=-DIOH_CAN_PCLK_50MHZ
+
+pch_phub_drv-objs := pch_phub.o pch_phub_pci.o pch_phub_hal.o
diff --git a/drivers/char/pch_phub/pch_common.h b/drivers/char/pch_phub/pch_common.h
new file mode 100644
index 0000000..07f75b0
--- /dev/null
+++ b/drivers/char/pch_phub/pch_common.h
@@ -0,0 +1,147 @@
+/*!
+ * @file pch_common.h
+ * @brief Provides the macro definitions used by all files.
+ * @version 1.0.0.0
+ * @section
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*
+ * History:
+ * Copyright (C) 2010 OKI SEMICONDUCTOR Co., LTD.
+ *
+ * created:
+ * OKI SEMICONDUCTOR 04/14/2010
+ * modified:
+ *
+ */
+
+#ifndef __PCH_COMMON_H__
+#define __PCH_COMMON_H__
+
+/*! @ingroup Global
+@def      PCH_WRITE8
+@brief   Macro for writing 8 bit data to an io/mem address
+*/
+#define PCH_WRITE8(val, addr)   iowrite8((val), (void __iomem *)(addr))
+/*! @ingroup Global
+@def      PCH_LOG
+@brief   Macro for writing 16 bit data to an io/mem address
+*/
+#define PCH_WRITE16(val, addr)  iowrite16((val), (void __iomem *)(addr))
+/*! @ingroup Global
+@def      PCH_LOG
+@brief   Macro for writing 32 bit data to an io/mem address
+*/
+#define PCH_WRITE32(val, addr)  iowrite32((val), (void __iomem *)(addr))
+
+/*! @ingroup Global
+@def      PCH_READ8
+@brief   Macro for reading 8 bit data from an io/mem address
+*/
+#define PCH_READ8(addr)   ioread8((void __iomem *)(addr))
+/*! @ingroup Global
+@def      PCH_READ16
+@brief   Macro for reading 16 bit data from an io/mem address
+*/
+#define PCH_READ16(addr)  ioread16((void __iomem *)(addr))
+/*! @ingroup Global
+@def      PCH_READ32
+@brief   Macro for reading 32 bit data from an io/mem address
+*/
+#define PCH_READ32(addr)  ioread32((void __iomem *)(addr))
+/*! @ingroup Global
+@def      PCH_WRITE32_F
+@brief   Macro for writing 32 bit data to an io/mem address
+*/
+#define PCH_WRITE32_F(val, addr) \
+do { \
+	PCH_WRITE32((val), (addr)); \
+	(void)PCH_READ32((addr)); \
+} while (0);
+
+/*! @ingroup Global
+@def      PCH_WRITE_BYTE
+@brief   Macro for writing 1 byte data to an io/mem address
+*/
+#define PCH_WRITE_BYTE PCH_WRITE8
+/*! @ingroup Global
+@def      PCH_WRITE_WORD
+@brief   Macro for writing 1 word data to an io/mem address
+*/
+#define PCH_WRITE_WORD PCH_WRITE16
+/*! @ingroup Global
+@def      PCH_WRITE_LONG
+@brief   Macro for writing long data to an io/mem address
+*/
+#define PCH_WRITE_LONG PCH_WRITE32
+
+/*! @ingroup Global
+@def      PCH_READ_BYTE
+@brief   Macro for reading 1 byte data from an io/mem address
+*/
+#define PCH_READ_BYTE  PCH_READ8
+/*! @ingroup Global
+@def      PCH_READ_WORD
+@brief   Macro for reading 1 word data from an io/mem address
+*/
+#define PCH_READ_WORD  PCH_READ16
+/*! @ingroup Global
+@def      PCH_READ_LONG
+@brief   Macro for reading long data from an io/mem address
+*/
+#define PCH_READ_LONG  PCH_READ32
+
+/* Bit Manipulation Macros */
+
+/*! @ingroup Global
+@def      PCH_READ_LONG
+@brief   macro to set a specified bit(mask) at the
+   specified address
+*/
+#define PCH_SET_ADDR_BIT(addr, bitmask) PCH_WRITE_LONG((PCH_READ_LONG(addr) |\
+	(bitmask)), (addr))
+
+/*! @ingroup Global
+@def     PCH_READ_LONG
+@brief  macro to clear a specified bit(mask) at the specified address
+*/
+#define PCH_CLR_ADDR_BIT(addr, bitmask) PCH_WRITE_LONG((PCH_READ_LONG(addr) &\
+	~(bitmask)), (addr))
+
+/*! @ingroup Global
+@def      PCH_READ_LONG
+@brief   macro to set a specified bitmask for a variable
+*/
+#define PCH_SET_BITMSK(var, bitmask) ((var) |= (bitmask))
+
+/*! @ingroup Global
+@def      PCH_READ_LONG
+@brief   macro to clear a specified bitmask for a variable
+*/
+#define PCH_CLR_BITMSK(var, bitmask) ((var) &= (~(bitmask)))
+
+/*! @ingroup Global
+@def      PCH_READ_LONG
+@brief   macro to set a specified bit for a variable
+*/
+#define PCH_SET_BIT(var, bit) ((var) |= (1<<(bit)))
+
+/*! @ingroup Global
+@def      PCH_READ_LONG
+@brief   macro to clear a specified bit for a variable
+*/
+#define PCH_CLR_BIT(var, bit) ((var) &= ~(1<<(bit)))
+
+#endif
diff --git a/drivers/char/pch_phub/pch_debug.h b/drivers/char/pch_phub/pch_debug.h
new file mode 100644
index 0000000..c3d5e11
--- /dev/null
+++ b/drivers/char/pch_phub/pch_debug.h
@@ -0,0 +1,58 @@
+/*!
+ * @file pch_debug.h
+ * @brief Provides the macro definitions used for debugging.
+ * @version 1.0.0.0
+ * @section
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*
+ * History:
+ * Copyright (C) 2010 OKI SEMICONDUCTOR Co., LTD.
+ *
+ * created:
+ * OKI SEMICONDUCTOR 04/14/2010
+ * modified:
+ *
+ */
+
+#ifndef __PCH_DEBUG_H__
+#define __PCH_DEBUG_H__
+
+#ifdef MODULE
+#define PCH_LOG(level, fmt, args...) printk(level "%s:" fmt "\n",\
+       THIS_MODULE->name, ##args)
+#else
+#define PCH_LOG(level, fmt, args...) printk(level "%s:" fmt "\n" ,\
+	__FILE__, ##args)
+#endif
+
+
+#ifdef DEBUG
+ #define PCH_DEBUG(fmt, args...) PCH_LOG(KERN_DEBUG, fmt, ##args)
+#else
+ #define PCH_DEBUG(fmt, args...)
+#endif
+
+#ifdef PCH_TRACE_ENABLED
+ #define PCH_TRACE PCH_DEBUG
+#else
+ #define PCH_TRACE(fmt, args...)
+#endif
+
+#define PCH_TRACE_ENTER PCH_TRACE("Enter %s", __func__)
+#define PCH_TRACE_EXIT  PCH_TRACE("Exit %s", __func__)
+
+
+#endif
diff --git a/drivers/char/pch_phub/pch_phub.c b/drivers/char/pch_phub/pch_phub.c
new file mode 100644
index 0000000..0924c22
--- /dev/null
+++ b/drivers/char/pch_phub/pch_phub.c
@@ -0,0 +1,360 @@
+/*!
+ * @file pch_phub.c
+ * @brief Provides all the implementation of the interfaces pertaining to
+ *  the Packet Hub module.
+ * @version 1.0.0.0
+ * @section
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*
+ * History:
+ * Copyright (C) 2010 OKI SEMICONDUCTOR Co., LTD.
+ *
+ * created:
+ * OKI SEMICONDUCTOR 04/14/2010
+ * modified:
+ *
+ */
+
+/* includes */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/string.h>
+
+#include "pch_common.h"
+#include "pch_debug.h"
+#include "pch_phub.h"
+#include "pch_phub_hal.h"
+
+#define MODULE_NAME "pch_phub"
+
+/* global variables */
+s32 pch_phub_opencount; /* check whether opened or not */
+
+DEFINE_SPINLOCK(pch_phub_lock); /* for spin lock */
+
+/**
+ * file_operations structure initialization
+ */
+const struct file_operations pch_phub_fops = {
+ .owner = THIS_MODULE,
+ .open = pch_phub_open,
+ .release = pch_phub_release,
+ .ioctl = pch_phub_ioctl,
+};
+
+/*function implementations*/
+
+/*! @ingroup PHUB_InterfaceLayerAPI
+  @fn  int pch_phub_open( struct inode *inode,struct file *file)
+  @remarks  Implements the Initializing and opening of the Packet Hub module.
+  @param  inode  [@ref INOUT] Contains the reference of the inode structure
+  @param  file  [@ref INOUT] Contains the reference of the file structure
+  @retval returnvalue [@ref OUT] contains the result for the concerned attempt.
+  The result would generally comprise of success code or failure code.
+  The failure code will indicate reason for failure.
+  @see
+  EBUSY
+  */
+int pch_phub_open(struct inode *inode, struct file *file)
+{
+ int ret;
+
+ spin_lock(&pch_phub_lock);
+ PCH_DEBUG("pch_phub_open : open count value = %d",
+	pch_phub_opencount);
+ if (pch_phub_opencount) {
+	PCH_LOG(KERN_ERR, "pch_phub_open :  device already opened\n");
+  ret = -EBUSY;
+ } else {
+  pch_phub_opencount++;
+  ret = PCH_PHUB_SUCCESS;
+ }
+ spin_unlock(&pch_phub_lock);
+
+ PCH_DEBUG("pch_phub_open returns=%d\n", ret);
+ return ret;
+}
+
+/*! @ingroup PHUB_InterfaceLayerAPI
+  @fn  int pch_phub_release(struct inode *inode,struct file *file)
+  @remarks  Implements the release functionality of the Packet Hub module.
+  @param  inode  [@ref INOUT] Contains the reference of the inode structure
+  @param  file   [@ref INOUT] Contains the reference of the file structure
+  @retval returnvalue  [@ref OUT] contains the result for the concerned attempt.
+  The result would generally comprise of success code
+  or failure code. The failure code will indicate reason for
+  failure.
+  @see
+  SUCCESS
+  */
+int pch_phub_release(struct inode *inode, struct file *file)
+{
+ spin_lock(&pch_phub_lock);
+
+ if (pch_phub_opencount > 0)
+	pch_phub_opencount--;
+ spin_unlock(&pch_phub_lock);
+
+ PCH_DEBUG("pch_phub_release : pch_phub_opencount =%d\n",
+   pch_phub_opencount);
+
+ PCH_DEBUG("pch_phub_release returning=%d\n", PCH_PHUB_SUCCESS);
+ return PCH_PHUB_SUCCESS;
+}
+
+/*! @ingroup PHUB_InterfaceLayerAPI
+  @fn  int pch_phub_ioctl(struct inode * inode,struct file * file,
+      unsigned int cmd,unsigned long arg)
+  @remarks  Implements the various ioctl functionalities of
+  the Packet Hub module.
+  @param  inode [@ref INOUT] Contains the reference of the inode structure
+  @param  file  [@ref INOUT] Contains the reference of the file structure
+  @param  cmd  [@ref IN] Contains the command value
+  @param  arg  [@ref IN] Contains the command argument value
+  @retval returnvalue  [@ref OUT] contains the result for the concerned attempt.
+  The result would generally comprise of success code
+  or failure code. The failure code will indicate reason for
+  failure.
+  @see
+  EINVAL
+  EFAULT
+  */
+int pch_phub_ioctl(struct inode *inode, struct file *file,
+	unsigned int cmd, unsigned long arg)
+{
+
+ int ret_value = PCH_PHUB_SUCCESS;
+ struct pch_phub_reqt *p_pch_phub_reqt;
+ unsigned long addr_offset;
+ unsigned long data;
+ unsigned long mask;
+
+ do {
+	if (pch_phub_suspended == true) {
+	PCH_LOG(KERN_ERR, "pch_phub_ioctl : "
+	"suspend initiated returning =%d\n",
+	PCH_PHUB_FAIL);
+   ret_value = PCH_PHUB_FAIL;
+   break;
+  }
+
+  p_pch_phub_reqt = (struct pch_phub_reqt *)arg;
+  ret_value =
+	copy_from_user((void *)&addr_offset,
+	(void *)&p_pch_phub_reqt->addr_offset,
+	sizeof(addr_offset));
+  if (ret_value) {
+   PCH_LOG(KERN_ERR, "pch_phub_ioctl : "
+	"copy_from_user fail returning =%d\n",
+	-EFAULT);
+   ret_value = -EFAULT;
+   break;
+  }
+  PCH_DEBUG("pch_phub_ioctl  : copy_from_user returns =%d\n",
+    ret_value);
+
+  switch (cmd) {
+  case IOCTL_PHUB_READ_REG:
+   {
+
+    pch_phub_read_reg(addr_offset, &data);
+    PCH_DEBUG("pch_phub_ioctl  : Invoked "
+     "pch_phub_read_reg successfully\n");
+
+    ret_value =
+	copy_to_user((void *)&p_pch_phub_reqt->data,
+	 (void *)&data, sizeof(data));
+    if (ret_value) {
+	PCH_LOG(KERN_ERR, "pch_phub_ioctl : "
+	"copy_to_user fail returning =%d\n",
+	-EFAULT);
+     ret_value = -EFAULT;
+     break;
+    }
+    break;
+   }
+
+  case IOCTL_PHUB_WRITE_REG:
+   {
+
+    ret_value =
+	copy_from_user((void *)&data,
+	(void *)&p_pch_phub_reqt->data, sizeof(data));
+    if (ret_value) {
+	PCH_LOG(KERN_ERR, "pch_phub_ioctl : "
+	"copy_from_user fail returning =%d\n", -EFAULT);
+     ret_value = -EFAULT;
+     break;
+    }
+    pch_phub_write_reg(addr_offset, data);
+    PCH_DEBUG("pch_phub_ioctl  : Invoked "
+	"pch_phub_write_reg successfully\n");
+    break;
+   }
+
+  case IOCTL_PHUB_READ_MODIFY_WRITE_REG:
+   {
+
+    ret_value =
+	copy_from_user((void *)&data,
+	(void *)&p_pch_phub_reqt->data, sizeof(data));
+    if (ret_value) {
+     PCH_LOG(KERN_ERR, "pch_phub_ioctl : "
+	"copy_from_user fail "
+	"returning =%d\n", -EFAULT);
+     ret_value = -EFAULT;
+     break;
+    }
+    ret_value =
+	copy_from_user((void *)&mask,
+	(void *)&p_pch_phub_reqt->mask, sizeof(mask));
+    if (ret_value) {
+     PCH_LOG(KERN_ERR, "pch_phub_ioctl : "
+      "copy_from_user fail "
+      "returning =%d\n", -EFAULT);
+     ret_value = -EFAULT;
+     break;
+    }
+    pch_phub_read_modify_write_reg(addr_offset,
+	data, mask);
+    PCH_DEBUG("pch_phub_ioctl  : Invoked "
+     "pch_phub_read_modify_write_reg "
+     "successfully\n");
+    break;
+   }
+
+  case IOCTL_PHUB_READ_OROM:
+   {
+
+    ret_value =
+	pch_phub_read_serial_rom(addr_offset,
+       (unsigned char *)&data);
+    if (ret_value) {
+     PCH_LOG(KERN_ERR,
+      "pch_phub_ioctl : Invoked "
+      "pch_phub_read_serial_rom "
+      "=%d\n", -EFAULT);
+     ret_value = -EFAULT;
+     break;
+    } else {
+     PCH_DEBUG("pch_phub_ioctl : Invoked "
+      "pch_phub_read_serial_rom "
+      "successfully\n");
+    }
+
+    ret_value =
+	copy_to_user((void *)&p_pch_phub_reqt->data,
+		(void *)&data, sizeof(data));
+    if (ret_value) {
+     PCH_LOG(KERN_ERR, "pch_phub_ioctl : "
+	"copy_to_user fail returning "
+	"=%d\n", -EFAULT);
+     ret_value = -EFAULT;
+     break;
+    }
+    break;
+   }
+
+  case IOCTL_PHUB_WRITE_OROM:
+   {
+
+    ret_value =
+	copy_from_user((void *)&data,
+	(void *)&p_pch_phub_reqt->data, sizeof(data));
+    if (ret_value) {
+     PCH_LOG(KERN_ERR, "pch_phub_ioctl : "
+	"copy_from_user fail returning "
+	"=%d\n", -EFAULT);
+     ret_value = -EFAULT;
+     break;
+    }
+    ret_value =
+	pch_phub_write_serial_rom(addr_offset, data);
+    if (ret_value) {
+     PCH_LOG(KERN_ERR,
+	"pch_phub_ioctl : Invoked "
+	"pch_phub_write_serial_rom "
+	"=%d\n", -EFAULT);
+     ret_value = -EFAULT;
+     break;
+    } else {
+     PCH_DEBUG("pch_phub_ioctl : Invoked "
+	"pch_phub_write_serial_rom "
+	"successfully\n");
+    }
+    break;
+   }
+
+  case IOCTL_PHUB_READ_MAC_ADDR:
+   {
+
+    pch_phub_read_gbe_mac_addr(addr_offset,
+	(unsigned char *)&data);
+    PCH_DEBUG("pch_phub_ioctl : Invoked "
+	"pch_phub_read_gbe_mac_addr "
+	"successfully\n");
+
+    ret_value =
+	copy_to_user((void *)&p_pch_phub_reqt->data,
+	(void *)&data, sizeof(data));
+    if (ret_value) {
+     PCH_LOG(KERN_ERR, "pch_phub_ioctl : "
+	"copy_to_user fail "
+	"returning =%d\n", -EFAULT);
+     ret_value = -EFAULT;
+     break;
+    }
+    break;
+   }
+
+  case IOCTL_PHUB_WRITE_MAC_ADDR:
+   {
+
+    ret_value =
+	copy_from_user((void *)&data,
+	(void *)&p_pch_phub_reqt->data, sizeof(data));
+    if (ret_value) {
+     PCH_LOG(KERN_ERR, "pch_phub_ioctl : "
+	"copy_from_user fail "
+	"returning =%d\n", -EFAULT);
+     ret_value = -EFAULT;
+     break;
+    }
+    pch_phub_write_gbe_mac_addr(addr_offset, data);
+    PCH_DEBUG("pch_phub_ioctl : Invoked "
+     "pch_phub_write_gbe_mac_addr "
+     "successfully\n");
+    break;
+   }
+
+  default:
+   {
+    PCH_LOG(KERN_ERR, "pch_write_ioctl invalid "
+     "command returning=%d\n", -EINVAL);
+    ret_value = -EINVAL;
+    break;
+   }
+  }
+  break;
+
+ } while (0);
+ PCH_LOG(KERN_ERR, "pch_write_ioctl returns=%d\n", ret_value);
+ return ret_value;
+}
diff --git a/drivers/char/pch_phub/pch_phub.h b/drivers/char/pch_phub/pch_phub.h
new file mode 100644
index 0000000..e21c20d
--- /dev/null
+++ b/drivers/char/pch_phub/pch_phub.h
@@ -0,0 +1,193 @@
+#ifndef __PCH_PHUB_H__
+#define __PCH_PHUB_H__
+/*!
+ * @file pch_phub.h
+ * @brief Provides all the interfaces pertaining to the Packet Hub module.
+ * @version 1.0.0.0
+ * @section
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*
+ * History:
+ * Copyright (C) 2010 OKI SEMICONDUCTOR Co., LTD.
+ *
+ * created:
+ * OKI SEMICONDUCTOR 04/14/2010
+ * modified:
+ *
+ */
+
+/*! @defgroup PHUB */
+/*! @defgroup PHUB_Global      Global
+  @ingroup PHUB */
+/*! @defgroup PHUB_GlobalGeneral   General
+  @ingroup PHUB_Global */
+/*! @defgroup PHUB_GlobalResultCodes   StatusCodes
+  @ingroup PHUB_Global */
+/*! @defgroup PHUB_InterfaceLayer   InterfaceLayer
+  @ingroup PHUB */
+/*! @defgroup PHUB_InterfaceLayerAPI    Providers
+  @ingroup PHUB_InterfaceLayer
+  */
+/*! @defgroup PHUB_InterfaceLayerNotifyRoutines   Notifiers
+  @ingroup PHUB_InterfaceLayer
+  */
+/*! @defgroup PHUB_PCILayer    PCILayer
+  @ingroup PHUB */
+/*! @defgroup PHUB_PCILayerAPI     Providers
+  @ingroup PHUB_PCILayer
+  */
+/*! @defgroup PHUB_PCILayerFacilitators    Facilitators
+  @ingroup PHUB_PCILayer
+  */
+/*! @defgroup PHUB_HALLayer    HALLayer
+  @ingroup PHUB */
+/*! @defgroup PHUB_HALLayerAPI     Providers
+  @ingroup PHUB_HALLayer
+  */
+/*! @defgroup PHUB_HALLayerFacilitators    Facilitators
+  @ingroup PHUB_HALLayer
+  */
+/*! @defgroup PHUB_Utilities    Utilities
+  @ingroup PHUB */
+/*! @defgroup PHUB_UtilitiesAPI     Providers
+  @ingroup PHUB_Utilities
+  */
+
+/*! @ingroup PHUB_InterfaceLayer
+  @def PHUB_IOCTL_MAGIC
+  @brief Outlines the ioctl magic.
+  */
+#define PHUB_IOCTL_MAGIC   (0xf7)
+
+/*! @ingroup PHUB_InterfaceLayer
+  @def IOCTL_PHUB_READ_REG
+  @brief Outlines the read register function signature.
+  */
+#define IOCTL_PHUB_READ_REG (_IOW(PHUB_IOCTL_MAGIC, 1, unsigned long))
+
+/*! @ingroup PHUB_InterfaceLayer
+  @def IOCTL_PHUB_WRITE_REG
+  @brief Outlines the write register function signature.
+  */
+#define IOCTL_PHUB_WRITE_REG (_IOW(PHUB_IOCTL_MAGIC, 2, unsigned long))
+
+/*! @ingroup PHUB_InterfaceLayer
+  @def IOCTL_PHUB_READ_MODIFY_WRITE_REG
+  @brief Outlines the read, modify and write register function signature.
+  */
+#define IOCTL_PHUB_READ_MODIFY_WRITE_REG (_IOW(PHUB_IOCTL_MAGIC, 3,\
+	unsigned long))
+
+/*! @ingroup PHUB_InterfaceLayer
+  @def IOCTL_PHUB_READ_OROM
+  @brief Outlines the read option rom function signature.
+  */
+#define IOCTL_PHUB_READ_OROM (_IOW(PHUB_IOCTL_MAGIC, 4, unsigned long))
+
+/*! @ingroup PHUB_InterfaceLayer
+  @def IOCTL_PHUB_WRITE_OROM
+  @brief Outlines the write option rom function signature.
+  */
+#define IOCTL_PHUB_WRITE_OROM (_IOW(PHUB_IOCTL_MAGIC, 5, unsigned long))
+
+/*! @ingroup PHUB_InterfaceLayer
+  @def IOCTL_PHUB_READ_MAC_ADDR
+  @brief Outlines the read mac address function signature.
+  */
+#define IOCTL_PHUB_READ_MAC_ADDR (_IOW(PHUB_IOCTL_MAGIC, 6,\
+	unsigned long))
+
+/*! @ingroup PHUB_InterfaceLayer
+  @def IOCTL_PHUB_WRITE_MAC_ADDR
+  @brief Outlines the write mac address function signature.
+  */
+#define IOCTL_PHUB_WRITE_MAC_ADDR (_IOW(PHUB_IOCTL_MAGIC, 7,\
+	unsigned long))
+
+/*! @ingroup PHUB_InterfaceLayer
+  @def PHUB STATUS CODE
+  @brief Outlines PHUB SUCCESS STATUS CODE
+  */
+#define PCH_PHUB_SUCCESS  (0)
+
+/*! @ingroup PHUB_InterfaceLayer
+  @def PHUB STATUS CODE
+  @brief Outlines PHUB ERROR STATUS CODE
+  */
+#define PCH_PHUB_FAIL   (-1)
+
+/* Registers address offset */
+#define PCH_PHUB_PHUB_ID_REG   (0x0000)
+#define PCH_PHUB_QUEUE_PRI_VAL_REG  (0x0004)
+#define PCH_PHUB_RC_QUEUE_MAXSIZE_REG (0x0008)
+#define PCH_PHUB_BRI_QUEUE_MAXSIZE_REG (0x000C)
+#define PCH_PHUB_COMP_RESP_TIMEOUT_REG (0x0010)
+#define PCH_PHUB_BUS_SLAVE_CONTROL_REG (0x0014)
+#define PCH_PHUB_DEADLOCK_AVOID_TYPE_REG (0x0018)
+#define PCH_PHUB_INTPIN_REG_WPERMIT_REG0 (0x0020)
+#define PCH_PHUB_INTPIN_REG_WPERMIT_REG1 (0x0024)
+#define PCH_PHUB_INTPIN_REG_WPERMIT_REG2 (0x0028)
+#define PCH_PHUB_INTPIN_REG_WPERMIT_REG3 (0x002C)
+#define PCH_PHUB_INT_REDUCE_CONTROL_REG_BASE (0x0040)
+#define CLKCFG_REG_OFFSET             (0x500)
+
+/*structures*/
+/*! @ingroup PHUB_InterfaceLayer
+  @struct pch_phub_reqt
+  @brief It is a structure used for perserving information related to the
+  Packet Hub request.
+  @note
+  The concerned details should be provided during the read register,
+   write register and read / modify / write register.
+  @see
+  pch_phub_ioctl
+  */
+struct pch_phub_reqt {
+ unsigned long addr_offset; /*specifies the register address offset */
+ unsigned long data; /*specifies the data */
+ unsigned long mask; /*specifies the mask */
+};
+
+/* exported function prototypes */
+/*! @ingroup PHUB_InterfaceLayerAPI
+  @fn nt pch_phub_open( struct inode *inode,struct file *file )
+  @brief  Provides the functionality of initialization of the module
+  */
+int pch_phub_open(struct inode *inode, struct file *file);
+
+/*! @ingroup PHUB_InterfaceLayerAPI
+  @fn int pch_phub_release(struct inode *inode,struct file *file)
+  @brief  Provides the functionality of releasing the module
+  */
+int pch_phub_release(struct inode *inode, struct file *file);
+
+/*! @ingroup PHUB_InterfaceLayerAPI
+  @fn int pch_phub_ioctl(struct inode * inode,struct file * file,
+	unsigned int cmd, unsigned long arg)
+  @brief  Provides the functionality of invoking various functionalities of
+	the Packet Hub.
+  */
+int pch_phub_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+	unsigned long arg);
+
+/**global variables*/
+extern u32 pch_phub_base_address; /* base address */
+extern s32 pch_phub_suspended; /* suspend status */
+
+extern s32 pch_phub_opencount;
+extern spinlock_t pch_phub_lock;
+extern const struct file_operations pch_phub_fops;
+#endif
diff --git a/drivers/char/pch_phub/pch_phub_hal.c b/drivers/char/pch_phub/pch_phub_hal.c
new file mode 100644
index 0000000..bcd700e
--- /dev/null
+++ b/drivers/char/pch_phub/pch_phub_hal.c
@@ -0,0 +1,544 @@
+/*!
+ * @file pch_phub_hal.c
+ * @brief Provides all the implementation of the interfaces pertaining to the
+ *           HAL.
+ * @version 1.0.0.0
+ * @section
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*
+ * History:
+ * Copyright (C) 2010 OKI SEMICONDUCTOR Co., LTD.
+ *
+ * created:
+ * OKI SEMICONDUCTOR 04/14/2010
+ * modified:
+ *
+ */
+
+/*includes*/
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include "pch_common.h"
+#include "pch_debug.h"
+#include "pch_phub.h"
+#include "pch_phub_hal.h"
+
+/* Status Register offset */
+#define PHUB_STATUS (0x00)
+
+/* Control Register offset */
+#define PHUB_CONTROL (0x04)
+
+/* Time out value for Status Register */
+#define PHUB_TIMEOUT (0x05)
+
+/* Enabling for writing ROM */
+#define PCH_PHUB_ROM_WRITE_ENABLE (0x01)
+
+/* Disabling for writing ROM */
+#define PCH_PHUB_ROM_WRITE_DISABLE (0x00)
+
+/* ROM data area start address offset */
+#define PCH_PHUB_ROM_START_ADDR (0x14)
+
+/* MAX number of INT_REDUCE_CONTROL registers */
+#define MAX_NUM_INT_REDUCE_CONTROL_REG (128)
+
+/* global variables */
+struct pch_phub_reg {
+ u32 phub_id_reg; /* PHUB_ID register val */
+ u32 q_pri_val_reg; /* QUEUE_PRI_VAL register val */
+ u32 rc_q_maxsize_reg; /* RC_QUEUE_MAXSIZE register val */
+ u32 bri_q_maxsize_reg; /* BRI_QUEUE_MAXSIZE register val */
+ u32 comp_resp_timeout_reg; /* COMP_RESP_TIMEOUT register val */
+ u32 bus_slave_control_reg; /* BUS_SLAVE_CONTROL_REG register val */
+ u32 deadlock_avoid_type_reg; /* DEADLOCK_AVOID_TYPE register val */
+ u32 intpin_reg_wpermit_reg0; /* INTPIN_REG_WPERMIT register 0 val */
+ u32 intpin_reg_wpermit_reg1; /* INTPIN_REG_WPERMIT register 1 val */
+ u32 intpin_reg_wpermit_reg2; /* INTPIN_REG_WPERMIT register 2 val */
+ u32 intpin_reg_wpermit_reg3; /* INTPIN_REG_WPERMIT register 3 val */
+ /* INT_REDUCE_CONTROL registers val */
+ u32 int_reduce_control_reg[MAX_NUM_INT_REDUCE_CONTROL_REG];
+#ifdef PCH_CAN_PCLK_50MHZ
+ u32 clkcfg_reg;  /* CLK CFG register val */
+#endif
+} g_pch_phub_reg;
+
+/*functions implementations*/
+/*! @ingroup PHUB_HALLayerAPI
+  @fn  void pch_phub_read_reg(unsigned long reg_addr_offset,
+	unsigned long *data)
+  @remarks  Implements the functionality of reading register.
+  @param  reg_addr_offset [@ref IN] Contains the register offset address value
+  @param  *data           [@ref INOUT] Contains the register value
+  @retval NONE
+  @see
+  */
+void pch_phub_read_reg(unsigned long reg_addr_offset, unsigned long *data)
+{
+ unsigned long reg_addr = pch_phub_base_address + reg_addr_offset;
+ *data = PCH_READ32(reg_addr);
+
+ return;
+}
+
+/*! @ingroup PHUB_HALLayerAPI
+  @fn  void pch_phub_write_reg(unsigned long reg_addr_offset,
+	unsigned long data)
+  @remarks  Implements the functionality of writing register.
+  @param  reg_addr_offset [@ref IN] Contains the register offset address value
+  @param  data            [@ref IN] Contains the writing value
+  @retval NONE
+  @see
+  */
+void pch_phub_write_reg(unsigned long reg_addr_offset, unsigned long data)
+{
+ unsigned long reg_addr = pch_phub_base_address + reg_addr_offset;
+ PCH_WRITE32(data, reg_addr);
+
+ return;
+}
+
+/*! @ingroup PHUB_HALLayerAPI
+  @fn  void pch_phub_read_modify_write_reg(unsigned long reg_addr_offset,
+      unsigned long data, unsigned long mask)
+  @remarks  Implements the functionality of reading, modifying and writing
+	register.
+  @param  reg_addr_offset [@ref IN] Contains the register offset address value
+  @param  data            [@ref IN] Contains the writing value
+  @param  mask            [@ref IN] Contains the mask value
+  @retval NONE
+  @see
+  */
+void pch_phub_read_modify_write_reg(unsigned long reg_addr_offset,
+	unsigned long data, unsigned long mask)
+{
+ unsigned long reg_addr = pch_phub_base_address + reg_addr_offset;
+ PCH_WRITE32(((PCH_READ32(reg_addr) & ~mask)) | data, reg_addr);
+
+ return;
+}
+
+/*! @ingroup PHUB_HALLayerAPI
+  @fn int pch_phub_read_gbe_mac_addr(unsigned long offset_address,
+	unsigned char *data)
+  @param  unsigned long offset_address
+ [@ref IN] Contains the Gigabit Ethernet MAC address offset value
+  @param  *data [@ref INOUT] Contains the Gigabit Ethernet MAC address value
+  @retval return value [@ref OUT] contains the result
+    for the reading Gigabit Ethernet MAC address attempt
+  @see
+  */
+int pch_phub_read_gbe_mac_addr(unsigned long offset_address,
+	unsigned char *data)
+{
+ int retval = PCH_PHUB_SUCCESS;
+
+ retval = pch_phub_read_serial_rom_val(offset_address, data);
+
+ return retval;
+}
+EXPORT_SYMBOL(pch_phub_read_gbe_mac_addr);
+
+/*! @ingroup PHUB_HALLayerAPI
+  @fn int pch_phub_write_gbe_mac_addr(unsigned long offset_address,
+	unsigned char data)
+  @param  unsigned long offset_address
+ [@ref IN] Contains the Gigabit Ethernet MAC address offset value
+  @param  data [@ref IN] Contains the Gigabit Ethernet MAC address value
+  @retval return value [@ref OUT] contains the result for the
+     writing Gigabit Ethernet MAC address attempt
+  @see
+  */
+int pch_phub_write_gbe_mac_addr(unsigned long offset_address,
+	unsigned char data)
+{
+ int retval = PCH_PHUB_SUCCESS;
+
+ retval = pch_phub_gbe_serial_rom_conf();
+ retval |= pch_phub_write_serial_rom_val(offset_address, data);
+
+ return retval;
+}
+EXPORT_SYMBOL(pch_phub_write_gbe_mac_addr);
+
+/*! @ingroup PHUB_HALLayerAPI
+  @fn  void pch_phub_save_reg_conf(void)
+  @remarks  saves register configuration
+  @param NONE
+  @retval  NONE
+  @see
+  pch_phub_suspend
+  */
+void pch_phub_save_reg_conf(void)
+{
+ u32 base_addr = pch_phub_base_address;
+ u32 i = 0;
+
+ PCH_DEBUG("pch_phub_save_reg_conf ENTRY\n");
+ /* to store contents of PHUB_ID register */
+ g_pch_phub_reg.phub_id_reg =
+     PCH_READ32(base_addr + PCH_PHUB_PHUB_ID_REG);
+ /* to store contents of QUEUE_PRI_VAL register */
+ g_pch_phub_reg.q_pri_val_reg =
+     PCH_READ32(base_addr + PCH_PHUB_QUEUE_PRI_VAL_REG);
+ /* to store contents of RC_QUEUE_MAXSIZE register */
+ g_pch_phub_reg.rc_q_maxsize_reg =
+     PCH_READ32(base_addr + PCH_PHUB_RC_QUEUE_MAXSIZE_REG);
+ /* to store contents of BRI_QUEUE_MAXSIZE register */
+ g_pch_phub_reg.bri_q_maxsize_reg =
+     PCH_READ32(base_addr + PCH_PHUB_BRI_QUEUE_MAXSIZE_REG);
+ /* to store contents of COMP_RESP_TIMEOUT register */
+ g_pch_phub_reg.comp_resp_timeout_reg =
+     PCH_READ32(base_addr + PCH_PHUB_COMP_RESP_TIMEOUT_REG);
+ /* to store contents of BUS_SLAVE_CONTROL_REG register */
+ g_pch_phub_reg.bus_slave_control_reg =
+     PCH_READ32(base_addr + PCH_PHUB_BUS_SLAVE_CONTROL_REG);
+ /* to store contents of DEADLOCK_AVOID_TYPE register */
+ g_pch_phub_reg.deadlock_avoid_type_reg =
+     PCH_READ32(base_addr + PCH_PHUB_DEADLOCK_AVOID_TYPE_REG);
+ /* to store contents of INTPIN_REG_WPERMIT register 0 */
+ g_pch_phub_reg.intpin_reg_wpermit_reg0 =
+     PCH_READ32(base_addr + PCH_PHUB_INTPIN_REG_WPERMIT_REG0);
+ /* to store contents of INTPIN_REG_WPERMIT register 1 */
+ g_pch_phub_reg.intpin_reg_wpermit_reg1 =
+     PCH_READ32(base_addr + PCH_PHUB_INTPIN_REG_WPERMIT_REG1);
+ /* to store contents of INTPIN_REG_WPERMIT register 2 */
+ g_pch_phub_reg.intpin_reg_wpermit_reg2 =
+     PCH_READ32(base_addr + PCH_PHUB_INTPIN_REG_WPERMIT_REG2);
+ /* to store contents of INTPIN_REG_WPERMIT register 3 */
+ g_pch_phub_reg.intpin_reg_wpermit_reg3 =
+     PCH_READ32(base_addr + PCH_PHUB_INTPIN_REG_WPERMIT_REG3);
+ PCH_DEBUG("pch_phub_save_reg_conf : "
+  "g_pch_phub_reg.phub_id_reg=%x, "
+  "g_pch_phub_reg.q_pri_val_reg=%x, "
+  "g_pch_phub_reg.rc_q_maxsize_reg=%x, "
+  "g_pch_phub_reg.bri_q_maxsize_reg=%x, "
+  "g_pch_phub_reg.comp_resp_timeout_reg=%x, "
+  "g_pch_phub_reg.bus_slave_control_reg=%x, "
+  "g_pch_phub_reg.deadlock_avoid_type_reg=%x, "
+  "g_pch_phub_reg.intpin_reg_wpermit_reg0=%x, "
+  "g_pch_phub_reg.intpin_reg_wpermit_reg1=%x, "
+  "g_pch_phub_reg.intpin_reg_wpermit_reg2=%x, "
+  "g_pch_phub_reg.intpin_reg_wpermit_reg3=%x\n",
+  g_pch_phub_reg.phub_id_reg,
+  g_pch_phub_reg.q_pri_val_reg,
+  g_pch_phub_reg.rc_q_maxsize_reg,
+  g_pch_phub_reg.bri_q_maxsize_reg,
+  g_pch_phub_reg.comp_resp_timeout_reg,
+  g_pch_phub_reg.bus_slave_control_reg,
+  g_pch_phub_reg.deadlock_avoid_type_reg,
+  g_pch_phub_reg.intpin_reg_wpermit_reg0,
+  g_pch_phub_reg.intpin_reg_wpermit_reg1,
+  g_pch_phub_reg.intpin_reg_wpermit_reg2,
+  g_pch_phub_reg.intpin_reg_wpermit_reg3);
+ /* to store contents of INT_REDUCE_CONTROL registers */
+ for (i = 0; i < MAX_NUM_INT_REDUCE_CONTROL_REG; i++) {
+  g_pch_phub_reg.int_reduce_control_reg[i] =
+	PCH_READ32(base_addr +
+	PCH_PHUB_INT_REDUCE_CONTROL_REG_BASE + 4 * i);
+  PCH_DEBUG("pch_phub_save_reg_conf : "
+   "g_pch_phub_reg.int_reduce_control_reg[%d]=%x\n",
+   i, g_pch_phub_reg.int_reduce_control_reg[i]);
+ }
+#ifdef PCH_CAN_PCLK_50MHZ
+ /* save clk cfg register */
+ g_pch_phub_reg.clkcfg_reg =
+     PCH_READ32(base_addr + CLKCFG_REG_OFFSET);
+#endif
+ return;
+}
+
+/*! @ingroup PHUB_HALLayerAPI
+  @fn  void pch_phub_restore_reg_conf(void)
+  @remarks  restore register configuration
+  @param NONE
+  @retval  NONE
+  @see
+  pch_phub_resume
+  */
+void pch_phub_restore_reg_conf(void)
+{
+ u32 base_addr = pch_phub_base_address;
+ u32 i = 0;
+
+ PCH_DEBUG("pch_phub_restore_reg_conf ENTRY\n");
+ /* to store contents of PHUB_ID register */
+ PCH_WRITE32(g_pch_phub_reg.phub_id_reg,
+      base_addr + PCH_PHUB_PHUB_ID_REG);
+ /* to store contents of QUEUE_PRI_VAL register */
+ PCH_WRITE32(g_pch_phub_reg.q_pri_val_reg,
+      base_addr + PCH_PHUB_QUEUE_PRI_VAL_REG);
+ /* to store contents of RC_QUEUE_MAXSIZE register */
+ PCH_WRITE32(g_pch_phub_reg.rc_q_maxsize_reg,
+      base_addr + PCH_PHUB_RC_QUEUE_MAXSIZE_REG);
+ /* to store contents of BRI_QUEUE_MAXSIZE register */
+ PCH_WRITE32(g_pch_phub_reg.bri_q_maxsize_reg,
+      base_addr + PCH_PHUB_BRI_QUEUE_MAXSIZE_REG);
+ /* to store contents of COMP_RESP_TIMEOUT register */
+ PCH_WRITE32(g_pch_phub_reg.comp_resp_timeout_reg,
+      base_addr + PCH_PHUB_COMP_RESP_TIMEOUT_REG);
+ /* to store contents of BUS_SLAVE_CONTROL_REG register */
+ PCH_WRITE32(g_pch_phub_reg.bus_slave_control_reg,
+      base_addr + PCH_PHUB_BUS_SLAVE_CONTROL_REG);
+ /* to store contents of DEADLOCK_AVOID_TYPE register */
+ PCH_WRITE32(g_pch_phub_reg.deadlock_avoid_type_reg,
+      base_addr + PCH_PHUB_DEADLOCK_AVOID_TYPE_REG);
+ /* to store contents of INTPIN_REG_WPERMIT register 0 */
+ PCH_WRITE32(g_pch_phub_reg.intpin_reg_wpermit_reg0,
+      base_addr + PCH_PHUB_INTPIN_REG_WPERMIT_REG0);
+ /* to store contents of INTPIN_REG_WPERMIT register 1 */
+ PCH_WRITE32(g_pch_phub_reg.intpin_reg_wpermit_reg1,
+      base_addr + PCH_PHUB_INTPIN_REG_WPERMIT_REG1);
+ /* to store contents of INTPIN_REG_WPERMIT register 2 */
+ PCH_WRITE32(g_pch_phub_reg.intpin_reg_wpermit_reg2,
+      base_addr + PCH_PHUB_INTPIN_REG_WPERMIT_REG2);
+ /* to store contents of INTPIN_REG_WPERMIT register 3 */
+ PCH_WRITE32(g_pch_phub_reg.intpin_reg_wpermit_reg3,
+      base_addr + PCH_PHUB_INTPIN_REG_WPERMIT_REG3);
+ PCH_DEBUG("pch_phub_save_reg_conf : "
+  "g_pch_phub_reg.phub_id_reg=%x, "
+  "g_pch_phub_reg.q_pri_val_reg=%x, "
+  "g_pch_phub_reg.rc_q_maxsize_reg=%x, "
+  "g_pch_phub_reg.bri_q_maxsize_reg=%x, "
+  "g_pch_phub_reg.comp_resp_timeout_reg=%x, "
+  "g_pch_phub_reg.bus_slave_control_reg=%x, "
+  "g_pch_phub_reg.deadlock_avoid_type_reg=%x, "
+  "g_pch_phub_reg.intpin_reg_wpermit_reg0=%x, "
+  "g_pch_phub_reg.intpin_reg_wpermit_reg1=%x, "
+  "g_pch_phub_reg.intpin_reg_wpermit_reg2=%x, "
+  "g_pch_phub_reg.intpin_reg_wpermit_reg3=%x\n",
+  g_pch_phub_reg.phub_id_reg,
+  g_pch_phub_reg.q_pri_val_reg,
+  g_pch_phub_reg.rc_q_maxsize_reg,
+  g_pch_phub_reg.bri_q_maxsize_reg,
+  g_pch_phub_reg.comp_resp_timeout_reg,
+  g_pch_phub_reg.bus_slave_control_reg,
+  g_pch_phub_reg.deadlock_avoid_type_reg,
+  g_pch_phub_reg.intpin_reg_wpermit_reg0,
+  g_pch_phub_reg.intpin_reg_wpermit_reg1,
+  g_pch_phub_reg.intpin_reg_wpermit_reg2,
+  g_pch_phub_reg.intpin_reg_wpermit_reg3);
+ /* to store contents of INT_REDUCE_CONTROL register */
+ for (i = 0; i < MAX_NUM_INT_REDUCE_CONTROL_REG; i++) {
+  PCH_WRITE32(g_pch_phub_reg.int_reduce_control_reg[i],
+	base_addr +
+	PCH_PHUB_INT_REDUCE_CONTROL_REG_BASE + 4 * i);
+  PCH_DEBUG("pch_phub_save_reg_conf : "
+   "g_pch_phub_reg.int_reduce_control_reg[%d]=%x\n",
+   i, g_pch_phub_reg.int_reduce_control_reg[i]);
+ }
+
+#ifdef PCH_CAN_PCLK_50MHZ
+ /*restore the clock config reg */
+ PCH_WRITE32(g_pch_phub_reg.clkcfg_reg,
+      base_addr + CLKCFG_REG_OFFSET);
+#endif
+
+ return;
+}
+
+/*! @ingroup PHUB_HALLayerAPI
+  @fn  void pch_phub_read_serial_rom
+  (unsigned long offset_address, unsigned char *data)
+  @remarks  Implements the functionality of reading Serial ROM.
+  @param  unsigned long offset_address
+  [@ref IN] Contains the Serial ROM address offset value
+  @param  *data [@ref INOUT] Contains the Serial ROM value
+  @retval returnvalue
+ [@ref OUT] contains the result for the reading Serial ROM attempt
+  @see
+  */
+int pch_phub_read_serial_rom(unsigned long offset_address,
+    unsigned char *data)
+{
+ unsigned long mem_addr =
+     pch_phub_extrom_base_address + offset_address;
+
+ PCH_DEBUG("pch_phub_read_serial_rom:mem_addr=0x%08x\n", mem_addr);
+ *data = PCH_READ8(mem_addr);
+
+ return PCH_PHUB_SUCCESS;
+}
+
+/*! @ingroup PHUB_HALLayerAPI
+  @fn  void pch_phub_write_serial_rom(unsigned long offset_address,
+	unsigned char data)
+  @remarks  Implements the functionality of writing Serial ROM.
+  @param  unsigned long offset_address
+ [@ref IN] Contains the Serial ROM address offset value
+  @param  data  [@ref IN] Contains the Serial ROM value
+  @retval returnvalue
+ [@ref OUT] contains the result for the writing Serial ROM attempt
+  @see
+  */
+int pch_phub_write_serial_rom(unsigned long offset_address,
+     unsigned char data)
+{
+ int retval = PCH_PHUB_SUCCESS;
+ unsigned long mem_addr =
+     pch_phub_extrom_base_address + offset_address;
+ int i = 0;
+ unsigned long word_data = 0;
+
+ PCH_DEBUG("pch_phub_write_serial_rom:mem_addr=0x%08x\n", mem_addr);
+ PCH_WRITE32(PCH_PHUB_ROM_WRITE_ENABLE,
+      pch_phub_extrom_base_address + PHUB_CONTROL);
+
+ word_data = PCH_READ32((mem_addr & 0xFFFFFFFC));
+ PCH_DEBUG("word_data=0x%08x\n", word_data);
+ PCH_DEBUG("data=0x%02x\n", data);
+ switch (mem_addr % 4) {
+ case 0:
+  {
+   word_data &= 0xFFFFFF00;
+   PCH_WRITE32((word_data | (unsigned long)data),
+	(mem_addr & 0xFFFFFFFC));
+  } break;
+ case 1:
+  {
+   word_data &= 0xFFFF00FF;
+   PCH_WRITE32((word_data | ((unsigned long)data << 8)),
+	(mem_addr & 0xFFFFFFFC));
+  } break;
+ case 2:
+  {
+   word_data &= 0xFF00FFFF;
+   PCH_WRITE32((word_data | ((unsigned long)data << 16)),
+	(mem_addr & 0xFFFFFFFC));
+  } break;
+ case 3:
+  {
+   word_data &= 0x00FFFFFF;
+   PCH_WRITE32((word_data | ((unsigned long)data << 24)),
+	(mem_addr & 0xFFFFFFFC));
+  } break;
+ }
+ while (0x00 !=
+	PCH_READ8(pch_phub_extrom_base_address + PHUB_STATUS)) {
+  msleep(1);
+  if (PHUB_TIMEOUT == i) {
+   retval = PCH_PHUB_FAIL;
+   break;
+  }
+  i++;
+ }
+
+ PCH_WRITE32(PCH_PHUB_ROM_WRITE_DISABLE,
+      pch_phub_extrom_base_address + PHUB_CONTROL);
+
+ return retval;
+}
+
+/*! @ingroup PHUB_HALLayerAPI
+  @fn  void pch_phub_read_serial_rom_val(unsigned long offset_address,
+	unsigned char *data)
+  @remarks  Implements the functionality of reading Serial ROM value.
+  @param  unsigned long offset_address
+ [@ref IN] Contains the Serial ROM address offset value
+  @param  *data [@ref INOUT] Contains the Serial ROM value
+  @retval returnvalue
+ [@ref OUT] contains the result for the reading Serial ROM attempt
+  @see
+  */
+int pch_phub_read_serial_rom_val(unsigned long offset_address,
+	unsigned char *data)
+{
+ int retval = PCH_PHUB_SUCCESS;
+ unsigned long mem_addr;
+
+ mem_addr =
+     (offset_address / 4 * 8) + 3 - (offset_address % 4) +
+     PCH_PHUB_ROM_START_ADDR;
+ retval = pch_phub_read_serial_rom(mem_addr, data);
+
+ return retval;
+}
+
+/*! @ingroup PHUB_HALLayerAPI
+  @fn  void pch_phub_write_serial_rom_val(unsigned long offset_address,
+	unsigned char data)
+  @remarks  Implements the functionality of writing Serial ROM value.
+  @param  unsigned long offset_address
+ [@ref IN] Contains the Serial ROM address offset value
+  @param  data [@ref IN] Contains the Serial ROM value
+  @retval returnvalue
+ [@ref OUT] contains the result for the writing Serial ROM attempt
+  @see
+  */
+int pch_phub_write_serial_rom_val(unsigned long offset_address,
+	unsigned char data)
+{
+ int retval = PCH_PHUB_SUCCESS;
+ unsigned long mem_addr;
+
+ mem_addr =
+     (offset_address / 4 * 8) + 3 - (offset_address % 4) +
+     PCH_PHUB_ROM_START_ADDR;
+ retval = pch_phub_write_serial_rom(mem_addr, data);
+
+ return retval;
+}
+
+/*! @ingroup PHUB_HALLayerAPI
+  @fn int pch_phub_gbe_serial_rom_conf(void)
+  @remarks makes Serial ROM header format configuration
+  for Gigabit Ethernet MAC address
+  @param NONE
+  @retval returnvalue
+ [@ref OUT] contains the result for the writing Serial ROM attempt
+  @see
+  */
+int pch_phub_gbe_serial_rom_conf(void)
+{
+ int retval = PCH_PHUB_SUCCESS;
+
+ retval |= pch_phub_write_serial_rom(0x0b, 0xbc);
+ retval |= pch_phub_write_serial_rom(0x0a, 0x10);
+ retval |= pch_phub_write_serial_rom(0x09, 0x01);
+ retval |= pch_phub_write_serial_rom(0x08, 0x02);
+
+ retval |= pch_phub_write_serial_rom(0x0f, 0x00);
+ retval |= pch_phub_write_serial_rom(0x0e, 0x00);
+ retval |= pch_phub_write_serial_rom(0x0d, 0x00);
+ retval |= pch_phub_write_serial_rom(0x0c, 0x80);
+
+ retval |= pch_phub_write_serial_rom(0x13, 0xbc);
+ retval |= pch_phub_write_serial_rom(0x12, 0x10);
+ retval |= pch_phub_write_serial_rom(0x11, 0x01);
+ retval |= pch_phub_write_serial_rom(0x10, 0x18);
+
+ retval |= pch_phub_write_serial_rom(0x1b, 0xbc);
+ retval |= pch_phub_write_serial_rom(0x1a, 0x10);
+ retval |= pch_phub_write_serial_rom(0x19, 0x01);
+ retval |= pch_phub_write_serial_rom(0x18, 0x19);
+
+ retval |= pch_phub_write_serial_rom(0x23, 0xbc);
+ retval |= pch_phub_write_serial_rom(0x22, 0x10);
+ retval |= pch_phub_write_serial_rom(0x21, 0x01);
+ retval |= pch_phub_write_serial_rom(0x20, 0x3a);
+
+ retval |= pch_phub_write_serial_rom(0x27, 0x01);
+ retval |= pch_phub_write_serial_rom(0x26, 0x00);
+ retval |= pch_phub_write_serial_rom(0x25, 0x00);
+ retval |= pch_phub_write_serial_rom(0x24, 0x00);
+
+ return retval;
+}
+
diff --git a/drivers/char/pch_phub/pch_phub_hal.h b/drivers/char/pch_phub/pch_phub_hal.h
new file mode 100644
index 0000000..f13204c
--- /dev/null
+++ b/drivers/char/pch_phub/pch_phub_hal.h
@@ -0,0 +1,124 @@
+#ifndef __PCH_PHUB_HAL_H__
+#define __PCH_PHUB_HAL_H__
+/*!
+ * @file pch_phub_hal.h
+ * @brief Provides all the interfaces pertaining to the HAL.
+ * @version 1.0.0.0
+ * @section
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*
+ * History:
+ * Copyright (C) 2010 OKI SEMICONDUCTOR Co., LTD.
+ *
+ * created:
+ * OKI SEMICONDUCTOR 04/14/2010
+ * modified:
+ *
+ */
+
+/* exported function prototypes */
+/*! @ingroup PHUB_HALLayerAPI
+  @fn void pch_phub_read_reg(unsigned long reg_addr_offset,
+	unsigned long *data)
+  @brief  Provides the functionality of reading register
+  */
+void pch_phub_read_reg(unsigned long reg_addr_offset, unsigned long *data);
+
+/*! @ingroup PHUB_HALLayerAPI
+  @fn pch_phub_write_reg(unsigned long reg_addr_offset, unsigned long data)
+  @brief  Provides the functionality of writing register
+  */
+void pch_phub_write_reg(unsigned long reg_addr_offset, unsigned long data);
+
+/*! @ingroup PHUB_HALLayerAPI
+  @fn pch_phub_read_modify_write_reg(unsigned long reg_addr_offset,
+      unsigned long data, unsigned long mask)
+  @brief  Provides the functionality of reading, modifying and writing register
+  */
+void pch_phub_read_modify_write_reg(unsigned long reg_addr_offset,
+	unsigned long data, unsigned long mask);
+
+/*! @ingroup PHUB_HALLayerAPI
+  @fn int pch_phub_read_gbe_mac_addr(unsigned long offset_address,
+	unsigned char *data)
+  @brief  Provides the functionality of reading Gigabit Ethernet MAC address
+  */
+int pch_phub_read_gbe_mac_addr(unsigned long offset_address,
+	unsigned char *data);
+
+/*! @ingroup PHUB_HALLayerAPI
+  @fn int pch_phub_write_gbe_mac_addr(unsigned long offset_address,
+	unsigned char data)
+  @brief  Provides the functionality of writing Gigabit Ethernet MAC address
+  */
+int pch_phub_write_gbe_mac_addr(unsigned long offset_address,
+	unsigned char data);
+
+/*! @ingroup PHUB_HALLayerAPI
+  @fn void pch_phub_save_reg_conf(void)
+  @brief  saves register configuration
+  */
+void pch_phub_save_reg_conf(void);
+
+/*! @ingroup PHUB_HALLayerAPI
+  @fn void pch_phub_restore_reg_conf(void)
+  @brief  restores register configuration
+  */
+void pch_phub_restore_reg_conf(void);
+
+/*! @ingroup PHUB_HALLayerAPI
+  @fn int pch_phub_read_serial_rom(unsigned long offset_address,
+	unsigned char *data)
+  @brief  Provides the functionality of reading Serial ROM
+  */
+int pch_phub_read_serial_rom(unsigned long offset_address,
+	unsigned char *data);
+
+/*! @ingroup PHUB_HALLayerAPI
+  @fn int pch_phub_write_serial_rom(unsigned long offset_address,
+	unsigned char data)
+  @brief  Provides the functionality of writing Serial ROM
+  */
+int pch_phub_write_serial_rom(unsigned long offset_address,
+	unsigned char data);
+
+/*! @ingroup PHUB_HALLayerAPI
+  @fn int pch_phub_read_serial_rom_val(unsigned long offset_address,
+	unsigned char *data)
+  @brief  Provides the functionality of reading Serial ROM value
+  */
+int pch_phub_read_serial_rom_val(unsigned long offset_address,
+	unsigned char *data);
+
+/*! @ingroup PHUB_HALLayerAPI
+  @fn int pch_phub_write_serial_rom_val(unsigned long offset_address,
+	unsigned char data)
+  @brief  Provides the functionality of writing Serial ROM value
+  */
+int pch_phub_write_serial_rom_val(unsigned long offset_address,
+	unsigned char data);
+
+/*! @ingroup PHUB_HALLayerAPI
+  @fn int pch_phub_gbe_serial_rom_conf(void)
+  @brief  makes Serial ROM data format configuration for Gigabit Ethernet
+	MAC address
+  */
+int pch_phub_gbe_serial_rom_conf(void);
+
+/* global variables */
+extern u32 pch_phub_base_address;
+extern u32 pch_phub_extrom_base_address;
+#endif
diff --git a/drivers/char/pch_phub/pch_phub_pci.c b/drivers/char/pch_phub/pch_phub_pci.c
new file mode 100644
index 0000000..4a69d1a
--- /dev/null
+++ b/drivers/char/pch_phub/pch_phub_pci.c
@@ -0,0 +1,494 @@
+/*!
+ * @file pch_phub_pci.c
+ * @brief Provides all the implementation of the interfaces pertaining to the
+ *        pci and gpic registrations.
+ * @version 1.0.0.0
+ * @section
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*
+ * History:
+ * Copyright (C) 2010 OKI SEMICONDUCTOR Co., LTD.
+ *
+ * created:
+ * OKI SEMICONDUCTOR 04/14/2010
+ * modified:
+ *
+ */
+/*includes*/
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/string.h>
+
+#include "pch_common.h"
+#include "pch_debug.h"
+#include "pch_phub.h"
+#include "pch_phub_hal.h"
+
+/*macros*/
+
+/*! @ingroup PHUB_PCILayer
+  @def PCI_DEVICE_ID_PCH1_PHUB
+  @brief Outlines the PCI Device ID.
+  */
+#define PCI_DEVICE_ID_PCH1_PHUB (0x8801)
+
+/*! @ingroup PHUB_PCILayer
+  @def PCH_MINOR_NOS
+  @brief Outlines the Packet Hub minor numbers limit.
+  */
+#define PCH_MINOR_NOS (1)
+
+/*values for configuring CLKCFG reg
+ * for CAN clock of 50Mhz*/
+
+/*! @ingroup PHUB_PCILayer
+  @def CLKCFG_CAN_50MHZ
+  @brief CLKCFG register setting for CAN clock of 50Mhz.
+  */
+#define CLKCFG_CAN_50MHZ (0x12000000)
+
+/*! @ingroup PHUB_PCILayer
+  @def CLKCFG_CANCLK_MASK
+  @brief Bit mask for bit fields in CLKCFG register
+      to set CAN clock to 50Mhz.
+  */
+#define CLKCFG_CANCLK_MASK (0xFF000000)
+
+/**global variables*/
+u32 pch_phub_base_address;
+u32 pch_phub_extrom_base_address;
+s32 pch_phub_suspended;
+
+/* ToDo: major number allocation via module parameter */
+static dev_t pch_phub_dev_no;
+static int pch_phub_major_no;
+
+static struct cdev pch_phub_dev;
+
+/*! @ingroup PHUB_PCILayerAPI
+  @fn static int __devinit pch_phub_probe(struct pci_dev* pch_pci_dev,
+      const struct pci_device_id* pci_id)
+  @brief  Provides the functionality of probing the module
+  */
+static int __devinit pch_phub_probe(struct pci_dev *pdev, const
+	struct pci_device_id *id);
+
+/*! @ingroup PHUB_PCILayerAPI
+  @fn static void __devexit pch_phub_remove(struct pci_dev * pch_pci_dev)
+  @brief  Provides the functionality of removing the module
+  */
+static void __devexit pch_phub_remove(struct pci_dev *pdev);
+
+/*! @ingroup PHUB_PCILayerAPI
+  @fn static int pch_phub_suspend(struct pci_dev* pDev,pm_message_t state)
+  @brief  Provides the functionality of suspending the module
+  */
+static int pch_phub_suspend(struct pci_dev *pdev, pm_message_t state);
+
+/*! @ingroup PHUB_PCILayerAPI
+  @fn static int pch_phub_resume(struct pci_dev* pDev)
+  @brief  Provides the functionality of resuming the module
+  */
+static int pch_phub_resume(struct pci_dev *pdev);
+
+/*structures*/
+/*! @ingroup PHUB_PCILayerFacilitators
+  @static struct pci_device_id
+  @brief It is a structure used for perserving information related to the
+  device id.
+  @note
+  The concerned details should be provided as a reference in the pci driver
+  structure.
+  */
+static struct pci_device_id pch_phub_pcidev_id[] = {
+
+ {PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_PCH1_PHUB)},
+ {0,}
+};
+
+/*! @ingroup PHUB_PCILayerFacilitators
+  @static struct pch_phub_driver
+  @brief It is a structure used for perserving information related to
+  the Packet Hub device and preserves function signatures to
+  manipulate the device.
+  @note  The structure contains the various interfaces aspects
+  provided to the pci layer.
+  @see
+  pch_phub_probe
+  pch_phub_suspend
+  pch_phub_resume
+  pch_phub_remove
+  */
+static struct pci_driver pch_phub_driver = {
+ .name = "pch_phub",
+ .id_table = pch_phub_pcidev_id,
+ .probe = pch_phub_probe,
+ .remove = __devexit_p(pch_phub_remove),
+#ifdef CONFIG_PM
+ .suspend = pch_phub_suspend,
+ .resume = pch_phub_resume
+#endif
+};
+
+/*! @ingroup PHUB_PCILayerAPI
+ * @fn static int __init pch_phub_pci_init(void)
+ * @brief  Provides the functionality of initializing the module
+ * */
+static int __init pch_phub_pci_init(void);
+/*! @ingroup PHUB_PCILayerAPI
+ * @fn static void __exit pch_phub_pci_exit(void)
+ * @brief  Provides the functionality of exiting the module
+ * */
+static void __exit pch_phub_pci_exit(void);
+
+MODULE_DESCRIPTION("PCH PACKET HUB PCI Driver");
+MODULE_LICENSE("GPL");
+module_init(pch_phub_pci_init);
+module_exit(pch_phub_pci_exit);
+module_param(pch_phub_major_no, int, S_IRUSR | S_IWUSR);
+
+/*function implementations*/
+
+/*! @ingroup PHUB_PCILayerAPI
+  @fn  static int __init pch_phub_pci_init(void)
+  @remarks  Implements the initialization functionality of the module.
+  @param  NONE
+  @retval returnvalue [@ref OUT] contains the result for the concerned attempt.
+   The result would generally comprise of success code
+   or failure code. The failure code will indicate reason for
+   failure.
+  @see
+   pch_phub_pci_exit
+  */
+static int __init pch_phub_pci_init(void)
+{
+ s32 ret;
+ ret = pci_register_driver(&pch_phub_driver);
+ PCH_DEBUG("pch_phub_pci_init : "
+   "Invoked pci_register_driver successfully\n");
+ PCH_DEBUG("pch_phub_pci_init returns %d\n", ret);
+ return ret;
+}
+
+/*! @ingroup PHUB_PCILayerAPI
+  @fn  static void __exit pch_phub_pci_exit(void)
+  @remarks  Implements the exit functionality of the module.
+  @param  NONE
+  @retval returnvalue  [@ref OUT] contains the result for the concerned attempt.
+   The result would generally comprise of success code
+   or failure code. The failure code will indicate reason for
+   failure.
+  @see
+   pch_phub_pci_init
+  */
+static void __exit pch_phub_pci_exit(void)
+{
+ pci_unregister_driver(&pch_phub_driver);
+ PCH_DEBUG("pch_phub_pci_exit : "
+   "Invoked pci_unregister_driver successfully\n");
+}
+
+/*! @ingroup PHUB_PCILayerAPI
+  @fn  static int __devinit pch_phub_probe(struct pci_dev* pdev,
+       const struct pci_device_id* id)
+  @remarks  Implements the probe functionality of the module.
+  @param  pdev [@ref INOUT] Contains the reference of the pci_dev structure
+  @param  id [@ref INOUT] Contains the reference of the pci_device_id structure
+  @retval returnvalue [@ref OUT] contains the result for the concerned attempt.
+   The result would generally comprise of success code
+   or failure code. The failure code will indicate reason for
+   failure.
+  @see
+   pch_phub_pci_init
+  */
+static int __devinit pch_phub_probe(struct pci_dev *pdev,
+	const struct pci_device_id *id)
+{
+
+ char *DRIVER_NAME = "pch_phub";
+ int ret;
+ unsigned int rom_size;
+
+ pch_phub_major_no = (pch_phub_major_no < 0
+    || pch_phub_major_no >
+    254) ? 0 : pch_phub_major_no;
+
+ do {
+  ret = pci_enable_device(pdev);
+  if (ret) {
+   PCH_LOG(KERN_ERR, "\npch_phub_probe : "
+    "pci_enable_device FAILED");
+   break;
+  }
+  PCH_DEBUG("pch_phub_probe : "
+    "pci_enable_device returns %d\n", ret);
+
+  ret = pci_request_regions(pdev, DRIVER_NAME);
+  if (ret) {
+   PCH_LOG(KERN_ERR, "pch_phub_probe : "
+	"pci_request_regions FAILED");
+	pci_disable_device(pdev);
+   break;
+  }
+  PCH_DEBUG("pch_phub_probe : "
+	"pci_request_regions returns %d\n", ret);
+
+  pch_phub_base_address = (unsigned long)pci_iomap(pdev, 1, 0);
+
+  if (pch_phub_base_address == 0) {
+   PCH_LOG(KERN_ERR,
+    "pch_phub_probe : pci_iomap FAILED");
+   pci_release_regions(pdev);
+   pci_disable_device(pdev);
+   ret = -ENOMEM;
+   break;
+  }
+  PCH_DEBUG("pch_phub_probe : "
+   "pci_iomap SUCCESS and value "
+   "in pch_phub_base_address variable is 0x%08x\n",
+   pch_phub_base_address);
+
+  pch_phub_extrom_base_address =
+      (unsigned long)pci_map_rom(pdev, &rom_size);
+  if (pch_phub_extrom_base_address == 0) {
+   PCH_LOG(KERN_ERR,
+    "pch_phub_probe : pci_map_rom FAILED");
+   pci_iounmap(pdev, (void *)pch_phub_base_address);
+   pci_release_regions(pdev);
+   pci_disable_device(pdev);
+   ret = -ENOMEM;
+   break;
+  }
+  PCH_DEBUG("pch_phub_probe : "
+   "pci_map_rom SUCCESS and value in "
+   "pch_phub_extrom_base_address variable is 0x%08x\n",
+   pch_phub_extrom_base_address);
+
+  if (pch_phub_major_no) {
+   pch_phub_dev_no = MKDEV(pch_phub_major_no, 0);
+   ret =
+	register_chrdev_region(pch_phub_dev_no,
+	PCH_MINOR_NOS, DRIVER_NAME);
+   if (ret) {
+    PCH_LOG(KERN_ERR, "pch_phub_probe : "
+	"register_chrdev_region FAILED");
+    pci_unmap_rom(pdev,
+	(void *)pch_phub_extrom_base_address);
+    pci_iounmap(pdev,
+	(void *)pch_phub_base_address);
+    pci_release_regions(pdev);
+    pci_disable_device(pdev);
+    break;
+   }
+   PCH_DEBUG("pch_phub_probe : "
+	"register_chrdev_region returns %d\n", ret);
+  } else {
+   ret =
+	alloc_chrdev_region(&pch_phub_dev_no, 0,
+	PCH_MINOR_NOS, DRIVER_NAME);
+   if (ret) {
+    PCH_LOG(KERN_ERR, "pch_phub_probe : "
+	"alloc_chrdev_region FAILED");
+    pci_unmap_rom(pdev,
+	(void *)pch_phub_extrom_base_address);
+    pci_iounmap(pdev,
+	(void *)pch_phub_base_address);
+    pci_release_regions(pdev);
+    pci_disable_device(pdev);
+    break;
+   }
+   PCH_DEBUG("pch_phub_probe : "
+	"alloc_chrdev_region returns %d\n", ret);
+  }
+
+  cdev_init(&pch_phub_dev, &pch_phub_fops);
+  PCH_DEBUG
+	("pch_phub_probe :  cdev_init invoked successfully\n");
+
+  pch_phub_dev.owner = THIS_MODULE;
+  pch_phub_dev.ops = &pch_phub_fops;
+
+  ret =
+	cdev_add(&pch_phub_dev, pch_phub_dev_no,
+	PCH_MINOR_NOS);
+  if (ret) {
+   PCH_LOG(KERN_ERR,
+	"pch_phub_probe :  cdev_add FAILED");
+   unregister_chrdev_region(pch_phub_dev_no,
+	PCH_MINOR_NOS);
+   pci_unmap_rom(pdev,
+	(void *)pch_phub_extrom_base_address);
+   pci_iounmap(pdev, (void *)pch_phub_base_address);
+   pci_release_regions(pdev);
+   pci_disable_device(pdev);
+   break;
+  }
+  PCH_DEBUG("pch_phub_probe :  cdev_add returns %d\n", ret);
+
+#ifdef PCH_CAN_PCLK_50MHZ
+  /*set the clock config reg if CAN clock is 50Mhz */
+  PCH_DEBUG("pch_phub_probe : invoking "
+	"pch_phub_read_modify_write_reg "
+	"to set CLKCFG reg for CAN clk 50Mhz\n");
+  pch_phub_read_modify_write_reg(CLKCFG_REG_OFFSET,
+	CLKCFG_CAN_50MHZ, CLKCFG_CANCLK_MASK);
+#endif
+  /* set the prefech value */
+  pch_phub_write_reg(0x14, 0x000ffffa);
+  /* set the interrupt delay value */
+  pch_phub_write_reg(0x44, 0x25);
+  return PCH_PHUB_SUCCESS;
+ } while (0);
+ PCH_DEBUG("pch_phub_probe returns %d\n", ret);
+ return ret;
+}
+
+/*! @ingroup PHUB_PCILayerAPI
+  @fn  static void __devexit pch_phub_remove(struct pci_dev * pdev)
+  @remarks  Implements the remove functionality of the module.
+  @param  pdev [@ref INOUT] Contains the reference of the pci_dev structure
+  @retval returnvalue [@ref OUT] contains the result for the concerned attempt.
+   The result would generally comprise of success code
+   or failure code. The failure code will indicate reason for failure.
+  @see
+   pch_phub_pci_init
+  */
+static void __devexit pch_phub_remove(struct pci_dev *pdev)
+{
+
+ cdev_del(&pch_phub_dev);
+ PCH_DEBUG("pch_phub_remove - cdev_del Invoked successfully\n");
+
+ unregister_chrdev_region(pch_phub_dev_no, PCH_MINOR_NOS);
+ PCH_DEBUG("pch_phub_remove - "
+  "unregister_chrdev_region Invoked successfully\n");
+
+ pci_unmap_rom(pdev, (void *)pch_phub_extrom_base_address);
+
+ pci_iounmap(pdev, (void *)pch_phub_base_address);
+
+ PCH_DEBUG("pch_phub_remove - pci_iounmap Invoked successfully\n");
+
+ pci_release_regions(pdev);
+ PCH_DEBUG
+     ("pch_phub_remove - pci_release_regions Invoked successfully\n");
+
+ pci_disable_device(pdev);
+ PCH_DEBUG
+     ("pch_phub_remove - pci_disable_device Invoked successfully\n");
+
+}
+
+#ifdef CONFIG_PM
+
+/*! @ingroup PHUB_PCILayerAPI
+  @fn static int pch_phub_suspend(struct pci_dev* pdev,pm_message_t state)
+  @remarks  Implements the suspend functionality of the module.
+  @param  pdev [@ref INOUT] Contains the reference of the pci_dev structure
+  @param  state [@ref INOUT] Contains the reference of the pm_message_t
+	structure
+  @retval returnvalue [@ref OUT] contains the result for the concerned attempt.
+   The result would generally comprise of success code
+   or failure code. The failure code will indicate reason for failure.
+  @see
+   pch_phub_pci_init
+   pch_phub_resume
+  */
+static int pch_phub_suspend(struct pci_dev *pdev, pm_message_t state)
+{
+ int ret;
+
+ pch_phub_suspended = true; /* For blocking further IOCTLs */
+
+ pch_phub_save_reg_conf();
+ PCH_DEBUG("pch_phub_suspend - "
+	"pch_phub_save_reg_conf Invoked successfully\n");
+
+ ret = pci_save_state(pdev);
+ if (ret) {
+  PCH_LOG(KERN_ERR, " pch_phub_suspend -pci_save_state returns-%d\n",
+	ret);
+  return ret;
+ }
+
+ pci_enable_wake(pdev, PCI_D3hot, 0);
+ PCH_DEBUG("pch_phub_suspend - "
+   "pci_enable_wake Invoked successfully\n");
+ PCH_DEBUG("pch_phub_suspend - pci_save_state returns %d\n", ret);
+
+ pci_disable_device(pdev);
+ PCH_DEBUG("pch_phub_suspend - "
+	"pci_disable_device Invoked successfully\n");
+
+ pci_set_power_state(pdev, pci_choose_state(pdev, state));
+ PCH_DEBUG("pch_phub_suspend - "
+	"pci_set_power_state Invoked successfully\n");
+ PCH_DEBUG("pch_phub_suspend - return %d\n", PCH_PHUB_SUCCESS);
+
+ return PCH_PHUB_SUCCESS;
+}
+
+/*! @ingroup PHUB_PCILayerAPI
+  @fn static int pch_phub_resume(struct pci_dev* pdev)
+  @remarks  Implements the resume functionality of the module.
+  @param  pdev [@ref INOUT] Contains the reference of the pci_dev structure
+  @retval returnvalue [@ref OUT] contains the result for the concerned attempt.
+   The result would generally comprise of success code
+   or failure code. The failure code will indicate reason for failure.
+  @see
+   pch_phub_pci_init
+   pch_phub_suspend
+  */
+static int pch_phub_resume(struct pci_dev *pdev)
+{
+
+ int ret;
+
+ pci_set_power_state(pdev, PCI_D0);
+ PCH_DEBUG("pch_phub_resume - "
+	"pci_set_power_state Invoked successfully\n");
+
+ pci_restore_state(pdev);
+ PCH_DEBUG("pch_phub_resume - "
+	"pci_restore_state Invoked successfully\n");
+
+ ret = pci_enable_device(pdev);
+ if (ret) {
+  PCH_LOG(KERN_ERR,
+	"pch_phub_resume-pci_enable_device failed ");
+  return ret;
+ }
+
+ PCH_DEBUG("pch_phub_resume - pci_enable_device returns -%d\n", ret);
+
+ pci_enable_wake(pdev, PCI_D3hot, 0);
+ PCH_DEBUG("pch_phub_resume - "
+	"pci_enable_wake Invoked successfully\n");
+
+ pch_phub_restore_reg_conf();
+ PCH_DEBUG("pch_phub_resume - "
+	"pch_phub_restore_reg_conf Invoked successfully\n");
+
+ pch_phub_suspended = false;
+
+ PCH_DEBUG("pch_phub_resume  returns- %d\n", PCH_PHUB_SUCCESS);
+ return PCH_PHUB_SUCCESS;
+}
+
+#endif
-- 
1.6.3.3

