From 80f6eda42637099efd2f055b33279a11481f1f96 Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Tue, 5 Jul 2011 10:47:01 +0800
Subject: [PATCH 13/13] TI816x preempt_rt: no need to protect ti816x_interrupt with raw_spin_lock_irqsave/raw_spin_unlock_irqrestore

ti816x_interrupt can be call with enable preempt, and to avoid latency
issue, we should remove raw_spin_lock_irqsave/raw_spin_unlock_irqrestore
in ti816x_interrupt since this ISR is invoked frequently.

Signed-off-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 drivers/usb/musb/ti816x.c |    7 -------
 1 files changed, 0 insertions(+), 7 deletions(-)

diff --git a/drivers/usb/musb/ti816x.c b/drivers/usb/musb/ti816x.c
index ef4fa2d..7e626b0 100644
--- a/drivers/usb/musb/ti816x.c
+++ b/drivers/usb/musb/ti816x.c
@@ -909,13 +909,10 @@ static irqreturn_t ti816x_interrupt(int irq, void *hci)
 {
 	struct musb  *musb = hci;
 	void __iomem *reg_base = musb->ctrl_base;
-	unsigned long flags;
 	irqreturn_t ret = IRQ_NONE;
 	u32 pend1 = 0, pend2 = 0;
 	u32 epintr, usbintr;
 
-	raw_spin_lock_irqsave(&musb->lock, flags);
-
 	/*
 	 * NOTE: AM3517/ti816x shadows the Mentor IRQs.  Don't manage them
 	 * through the Mentor registers (except for setup), use the TI ones
@@ -1005,9 +1002,7 @@ static irqreturn_t ti816x_interrupt(int irq, void *hci)
 
 	if (musb->int_tx || musb->int_rx || musb->int_usb) {
 		irqreturn_t mret;
-		raw_spin_unlock_irqrestore(&musb->lock, flags);
 		mret = musb_interrupt(musb);
-		raw_spin_lock_irqsave(&musb->lock, flags);
 		if (mret == IRQ_HANDLED)
 			ret = IRQ_HANDLED;
 	}
@@ -1025,8 +1020,6 @@ static irqreturn_t ti816x_interrupt(int irq, void *hci)
 	if (is_otg_enabled(musb) && musb->xceiv->state == OTG_STATE_B_IDLE)
 		mod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);
 
-	raw_spin_unlock_irqrestore(&musb->lock, flags);
-
 	if (ret != IRQ_HANDLED) {
 		if (epintr || usbintr)
 			/*
-- 
1.7.0.4

