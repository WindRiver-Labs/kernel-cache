From 1a054e275e31982530f8498b9698494fe4f2b7e4 Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Tue, 5 Jul 2011 11:46:48 +0800
Subject: [PATCH 09/13] TI816x preempt_rt: no need to protect musb_urb_dequeue with raw_spin_lock_irqsave/raw_spin_unlock_irqrestore

musb_urb_dequeue can be call with enable preempt, and to avoid latency
issue, we should remove raw_spin_lock_irqsave/raw_spin_unlock_irqrestore
in musb_urb_dequeue since it is a long path between the lock.

Signed-off-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 drivers/usb/musb/musb_host.c |    3 ---
 1 files changed, 0 insertions(+), 3 deletions(-)

diff --git a/drivers/usb/musb/musb_host.c b/drivers/usb/musb/musb_host.c
index 31f12dc..76509d3 100644
--- a/drivers/usb/musb/musb_host.c
+++ b/drivers/usb/musb/musb_host.c
@@ -2213,7 +2213,6 @@ static int musb_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
 	struct musb		*musb = hcd_to_musb(hcd);
 	struct musb_qh		*qh;
-	unsigned long		flags;
 	int			is_in  = usb_pipein(urb->pipe);
 	int			ret;
 
@@ -2222,7 +2221,6 @@ static int musb_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 			usb_pipeendpoint(urb->pipe),
 			is_in ? "in" : "out");
 
-	raw_spin_lock_irqsave(&musb->lock, flags);
 	ret = usb_hcd_check_unlink_urb(hcd, urb, status);
 	if (ret)
 		goto done;
@@ -2263,7 +2261,6 @@ static int musb_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 	} else
 		ret = musb_cleanup_urb(urb, qh);
 done:
-	raw_spin_unlock_irqrestore(&musb->lock, flags);
 	return ret;
 }
 
-- 
1.7.0.4

