From 1ee160f33d4e950fb12675e3e882ac54bef812ab Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Mon, 4 Jul 2011 16:47:16 +0800
Subject: [PATCH 01/13] TI816x preempt_rt: make the lock in musb to be raw

1. change the definition of lock to raw lock.
2. replace all the spin_lock*/unlock* to raw_spin_lock*/unlock*

Signed-off-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 drivers/usb/musb/musb_core.c    |   34 +++++++++++++++++-----------------
 drivers/usb/musb/musb_core.h    |    2 +-
 drivers/usb/musb/musb_host.c    |   28 ++++++++++++++--------------
 drivers/usb/musb/musb_virthub.c |    6 +++---
 drivers/usb/musb/ti816x.c       |   12 ++++++------
 5 files changed, 41 insertions(+), 41 deletions(-)

diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c
index 25ae738..3338261 100644
--- a/drivers/usb/musb/musb_core.c
+++ b/drivers/usb/musb/musb_core.c
@@ -322,7 +322,7 @@ void musb_otg_timer_func(unsigned long data)
 	struct musb	*musb = (struct musb *)data;
 	unsigned long	flags;
 
-	spin_lock_irqsave(&musb->lock, flags);
+	raw_spin_lock_irqsave(&musb->lock, flags);
 	switch (musb->xceiv->state) {
 	case OTG_STATE_B_WAIT_ACON:
 		DBG(1, "HNP: b_wait_acon timeout; back to b_peripheral\n");
@@ -338,7 +338,7 @@ void musb_otg_timer_func(unsigned long data)
 		DBG(1, "HNP: Unhandled mode %s\n", otg_state_string(musb));
 	}
 	musb->ignore_disconnect = 0;
-	spin_unlock_irqrestore(&musb->lock, flags);
+	raw_spin_unlock_irqrestore(&musb->lock, flags);
 }
 
 /*
@@ -1086,12 +1086,12 @@ static void musb_shutdown(struct platform_device *pdev)
 	struct musb	*musb = dev_to_musb(&pdev->dev);
 	unsigned long	flags;
 
-	spin_lock_irqsave(&musb->lock, flags);
+	raw_spin_lock_irqsave(&musb->lock, flags);
 	musb_platform_disable(musb);
 	musb_generic_disable(musb);
 	if (musb->clock)
 		clk_put(musb->clock);
-	spin_unlock_irqrestore(&musb->lock, flags);
+	raw_spin_unlock_irqrestore(&musb->lock, flags);
 
 	/* FIXME power down */
 }
@@ -1593,7 +1593,7 @@ static irqreturn_t generic_interrupt(int irq, void *__hci)
 	irqreturn_t	retval = IRQ_NONE;
 	struct musb	*musb = __hci;
 
-	spin_lock_irqsave(&musb->lock, flags);
+	raw_spin_lock_irqsave(&musb->lock, flags);
 
 	musb->int_usb = musb_readb(musb->mregs, MUSB_INTRUSB);
 	musb->int_tx = musb_readw(musb->mregs, MUSB_INTRTX);
@@ -1602,7 +1602,7 @@ static irqreturn_t generic_interrupt(int irq, void *__hci)
 	if (musb->int_usb || musb->int_tx || musb->int_rx)
 		retval = musb_interrupt(musb);
 
-	spin_unlock_irqrestore(&musb->lock, flags);
+	raw_spin_unlock_irqrestore(&musb->lock, flags);
 
 	return retval;
 }
@@ -1770,9 +1770,9 @@ musb_mode_show(struct device *dev, struct device_attribute *attr, char *buf)
 	unsigned long flags;
 	int ret = -EINVAL;
 
-	spin_lock_irqsave(&musb->lock, flags);
+	raw_spin_lock_irqsave(&musb->lock, flags);
 	ret = sprintf(buf, "%s\n", otg_state_string(musb));
-	spin_unlock_irqrestore(&musb->lock, flags);
+	raw_spin_unlock_irqrestore(&musb->lock, flags);
 
 	return ret;
 }
@@ -1785,7 +1785,7 @@ musb_mode_store(struct device *dev, struct device_attribute *attr,
 	unsigned long	flags;
 	int		status;
 
-	spin_lock_irqsave(&musb->lock, flags);
+	raw_spin_lock_irqsave(&musb->lock, flags);
 	if (sysfs_streq(buf, "host"))
 		status = musb_platform_set_mode(musb, MUSB_HOST);
 	else if (sysfs_streq(buf, "peripheral"))
@@ -1794,7 +1794,7 @@ musb_mode_store(struct device *dev, struct device_attribute *attr,
 		status = musb_platform_set_mode(musb, MUSB_OTG);
 	else
 		status = -EINVAL;
-	spin_unlock_irqrestore(&musb->lock, flags);
+	raw_spin_unlock_irqrestore(&musb->lock, flags);
 
 	return (status == 0) ? n : status;
 }
@@ -1813,13 +1813,13 @@ musb_vbus_store(struct device *dev, struct device_attribute *attr,
 		return -EINVAL;
 	}
 
-	spin_lock_irqsave(&musb->lock, flags);
+	raw_spin_lock_irqsave(&musb->lock, flags);
 	/* force T(a_wait_bcon) to be zero/unlimited *OR* valid */
 	musb->a_wait_bcon = val ? max_t(int, val, OTG_TIME_A_WAIT_BCON) : 0 ;
 	if (musb->xceiv->state == OTG_STATE_A_WAIT_BCON)
 		musb->is_active = 0;
 	musb_platform_try_idle(musb, jiffies + msecs_to_jiffies(val));
-	spin_unlock_irqrestore(&musb->lock, flags);
+	raw_spin_unlock_irqrestore(&musb->lock, flags);
 
 	return n;
 }
@@ -1832,13 +1832,13 @@ musb_vbus_show(struct device *dev, struct device_attribute *attr, char *buf)
 	unsigned long	val;
 	int		vbus;
 
-	spin_lock_irqsave(&musb->lock, flags);
+	raw_spin_lock_irqsave(&musb->lock, flags);
 	val = musb->a_wait_bcon;
 	/* FIXME get_vbus_status() is normally #defined as false...
 	 * and is effectively TUSB-specific.
 	 */
 	vbus = musb_platform_get_vbus_status(musb);
-	spin_unlock_irqrestore(&musb->lock, flags);
+	raw_spin_unlock_irqrestore(&musb->lock, flags);
 
 	return sprintf(buf, "Vbus %s, timeout %lu msec\n",
 			vbus ? "on" : "off", val);
@@ -2058,7 +2058,7 @@ bad_config:
 		goto fail0;
 	}
 
-	spin_lock_init(&musb->lock);
+	raw_spin_lock_init(&musb->lock);
 #ifndef CONFIG_ARCH_TI816X
 	musb->ctrl_phys_base = ctrl_phys_addr;
 #endif
@@ -2504,7 +2504,7 @@ static int musb_suspend(struct device *dev)
 	if (!musb->clock)
 		return 0;
 
-	spin_lock_irqsave(&musb->lock, flags);
+	raw_spin_lock_irqsave(&musb->lock, flags);
 
 	if (is_peripheral_active(musb)) {
 		/* FIXME force disconnect unless we know USB will wake
@@ -2522,7 +2522,7 @@ static int musb_suspend(struct device *dev)
 		musb->set_clock(musb->clock, 0);
 	else
 		clk_disable(musb->clock);
-	spin_unlock_irqrestore(&musb->lock, flags);
+	raw_spin_unlock_irqrestore(&musb->lock, flags);
 	return 0;
 }
 
diff --git a/drivers/usb/musb/musb_core.h b/drivers/usb/musb/musb_core.h
index 9086e69..beec2be 100644
--- a/drivers/usb/musb/musb_core.h
+++ b/drivers/usb/musb/musb_core.h
@@ -342,7 +342,7 @@ struct queue {
  */
 struct musb {
 	/* device lock */
-	spinlock_t		lock;
+	raw_spinlock_t		lock;
 	struct clk		*clock;
 	irqreturn_t		(*isr)(int, void *);
 	struct work_struct	irq_work;
diff --git a/drivers/usb/musb/musb_host.c b/drivers/usb/musb/musb_host.c
index 9d3ba70..6d49549 100644
--- a/drivers/usb/musb/musb_host.c
+++ b/drivers/usb/musb/musb_host.c
@@ -360,9 +360,9 @@ __acquires(musb->lock)
 			);
 
 	usb_hcd_unlink_urb_from_ep(musb_to_hcd(musb), urb);
-	spin_unlock(&musb->lock);
+	raw_spin_unlock(&musb->lock);
 	usb_hcd_giveback_urb(musb_to_hcd(musb), urb, status);
-	spin_lock(&musb->lock);
+	raw_spin_lock(&musb->lock);
 }
 
 void free_queue(struct musb *musb)
@@ -1983,12 +1983,12 @@ static int musb_urb_enqueue(
 	if (!is_host_active(musb) || !musb->is_active)
 		return -ENODEV;
 
-	spin_lock_irqsave(&musb->lock, flags);
+	raw_spin_lock_irqsave(&musb->lock, flags);
 	ret = usb_hcd_link_urb_to_ep(hcd, urb);
 	qh = ret ? NULL : hep->hcpriv;
 	if (qh)
 		urb->hcpriv = qh;
-	spin_unlock_irqrestore(&musb->lock, flags);
+	raw_spin_unlock_irqrestore(&musb->lock, flags);
 
 	/* DMA mapping was already done, if needed, and this urb is on
 	 * hep->urb_list now ... so we're done, unless hep wasn't yet
@@ -2009,9 +2009,9 @@ static int musb_urb_enqueue(
 	 */
 	qh = kzalloc(sizeof *qh, mem_flags);
 	if (!qh) {
-		spin_lock_irqsave(&musb->lock, flags);
+		raw_spin_lock_irqsave(&musb->lock, flags);
 		usb_hcd_unlink_urb_from_ep(hcd, urb);
-		spin_unlock_irqrestore(&musb->lock, flags);
+		raw_spin_unlock_irqrestore(&musb->lock, flags);
 		return -ENOMEM;
 	}
 
@@ -2118,7 +2118,7 @@ static int musb_urb_enqueue(
 	 * until we get real dma queues (with an entry for each urb/buffer),
 	 * we only have work to do in the former case.
 	 */
-	spin_lock_irqsave(&musb->lock, flags);
+	raw_spin_lock_irqsave(&musb->lock, flags);
 	if (hep->hcpriv) {
 		/* some concurrent activity submitted another urb to hep...
 		 * odd, rare, error prone, but legal.
@@ -2136,13 +2136,13 @@ static int musb_urb_enqueue(
 		 * musb_start_urb(), but otherwise only konicawc cares ...
 		 */
 	}
-	spin_unlock_irqrestore(&musb->lock, flags);
+	raw_spin_unlock_irqrestore(&musb->lock, flags);
 
 done:
 	if (ret != 0) {
-		spin_lock_irqsave(&musb->lock, flags);
+		raw_spin_lock_irqsave(&musb->lock, flags);
 		usb_hcd_unlink_urb_from_ep(hcd, urb);
-		spin_unlock_irqrestore(&musb->lock, flags);
+		raw_spin_unlock_irqrestore(&musb->lock, flags);
 		kfree(qh);
 	}
 	return ret;
@@ -2224,7 +2224,7 @@ static int musb_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 			usb_pipeendpoint(urb->pipe),
 			is_in ? "in" : "out");
 
-	spin_lock_irqsave(&musb->lock, flags);
+	raw_spin_lock_irqsave(&musb->lock, flags);
 	ret = usb_hcd_check_unlink_urb(hcd, urb, status);
 	if (ret)
 		goto done;
@@ -2265,7 +2265,7 @@ static int musb_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 	} else
 		ret = musb_cleanup_urb(urb, qh);
 done:
-	spin_unlock_irqrestore(&musb->lock, flags);
+	raw_spin_unlock_irqrestore(&musb->lock, flags);
 	return ret;
 }
 
@@ -2279,7 +2279,7 @@ musb_h_disable(struct usb_hcd *hcd, struct usb_host_endpoint *hep)
 	struct musb_qh		*qh;
 	struct urb		*urb;
 
-	spin_lock_irqsave(&musb->lock, flags);
+	raw_spin_lock_irqsave(&musb->lock, flags);
 
 	qh = hep->hcpriv;
 	if (qh == NULL)
@@ -2320,7 +2320,7 @@ musb_h_disable(struct usb_hcd *hcd, struct usb_host_endpoint *hep)
 		kfree(qh);
 	}
 exit:
-	spin_unlock_irqrestore(&musb->lock, flags);
+	raw_spin_unlock_irqrestore(&musb->lock, flags);
 }
 
 static int musb_h_get_frame_number(struct usb_hcd *hcd)
diff --git a/drivers/usb/musb/musb_virthub.c b/drivers/usb/musb/musb_virthub.c
index 57571b2..f1be381 100644
--- a/drivers/usb/musb/musb_virthub.c
+++ b/drivers/usb/musb/musb_virthub.c
@@ -229,10 +229,10 @@ int musb_hub_control(
 	int		retval = 0;
 	unsigned long	flags;
 
-	spin_lock_irqsave(&musb->lock, flags);
+	raw_spin_lock_irqsave(&musb->lock, flags);
 
 	if (unlikely(!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags))) {
-		spin_unlock_irqrestore(&musb->lock, flags);
+		raw_spin_unlock_irqrestore(&musb->lock, flags);
 		return -ESHUTDOWN;
 	}
 
@@ -419,6 +419,6 @@ error:
 		/* "protocol stall" on error */
 		retval = -EPIPE;
 	}
-	spin_unlock_irqrestore(&musb->lock, flags);
+	raw_spin_unlock_irqrestore(&musb->lock, flags);
 	return retval;
 }
diff --git a/drivers/usb/musb/ti816x.c b/drivers/usb/musb/ti816x.c
index 16b0012..14a6b83 100644
--- a/drivers/usb/musb/ti816x.c
+++ b/drivers/usb/musb/ti816x.c
@@ -750,7 +750,7 @@ static void otg_timer(unsigned long _musb)
 	devctl = musb_readb(mregs, MUSB_DEVCTL);
 	DBG(7, "Poll devctl %02x (%s)\n", devctl, otg_state_string(musb));
 
-	spin_lock_irqsave(&musb->lock, flags);
+	raw_spin_lock_irqsave(&musb->lock, flags);
 	switch (musb->xceiv->state) {
 	case OTG_STATE_A_WAIT_BCON:
 		devctl &= ~MUSB_DEVCTL_SESSION;
@@ -805,7 +805,7 @@ static void otg_timer(unsigned long _musb)
 	default:
 		break;
 	}
-	spin_unlock_irqrestore(&musb->lock, flags);
+	raw_spin_unlock_irqrestore(&musb->lock, flags);
 }
 
 void musb_platform_try_idle_x(struct musb *musb, unsigned long timeout)
@@ -851,7 +851,7 @@ static irqreturn_t cppi41dma_Interrupt(int irq, void *hci)
 	unsigned long flags;
 
 	musb = hci;
-	spin_lock_irqsave(&musb->lock, flags);
+	raw_spin_lock_irqsave(&musb->lock, flags);
 	/*
 	 * CPPI 4.1 interrupts share the same IRQ and the EOI register but
 	 * don't get reflected in the interrupt source/mask registers.
@@ -904,7 +904,7 @@ static irqreturn_t cppi41dma_Interrupt(int irq, void *hci)
 		}
 		usbss_write(USBSS_IRQ_EOI, 0);
 	}
-	spin_unlock_irqrestore(&musb->lock, flags);
+	raw_spin_unlock_irqrestore(&musb->lock, flags);
 	return ret;
 }
 #endif
@@ -917,7 +917,7 @@ static irqreturn_t ti816x_interrupt(int irq, void *hci)
 	u32 pend1 = 0, pend2 = 0;
 	u32 epintr, usbintr;
 
-	spin_lock_irqsave(&musb->lock, flags);
+	raw_spin_lock_irqsave(&musb->lock, flags);
 
 	/*
 	 * NOTE: AM3517/ti816x shadows the Mentor IRQs.  Don't manage them
@@ -1026,7 +1026,7 @@ static irqreturn_t ti816x_interrupt(int irq, void *hci)
 	if (is_otg_enabled(musb) && musb->xceiv->state == OTG_STATE_B_IDLE)
 		mod_timer(&otg_workaround, jiffies + POLL_SECONDS * HZ);
 
-	spin_unlock_irqrestore(&musb->lock, flags);
+	raw_spin_unlock_irqrestore(&musb->lock, flags);
 
 	if (ret != IRQ_HANDLED) {
 		if (epintr || usbintr)
-- 
1.7.0.4

