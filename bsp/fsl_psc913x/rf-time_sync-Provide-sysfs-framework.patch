From 591d2482f0125812164a64fc1ea93562cd367d49 Mon Sep 17 00:00:00 2001
From: bhaskar upadhaya <Bhaskar.Upadhaya@freescale.com>
Date: Thu, 1 Dec 2011 11:45:29 +0000
Subject: [PATCH 53/92] rf: time_sync - Provide sysfs framework

Extracted from 913x_WUSDK_REL_0.9.tar.gz vendor drop.

Provides sysfs interface for time-sync utility to show following
parameters
1. blackout period
2. lte delay
3. time correction source

Signed-off-by: Bhaskar Upadhaya <bhaskar.upadhaya@freescale.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/net/time_sync.c |  166 +++++++++++++++++++++++++++++++++++++++++++++++
 drivers/net/time_sync.h |    5 ++
 2 files changed, 171 insertions(+), 0 deletions(-)

diff --git a/drivers/net/time_sync.c b/drivers/net/time_sync.c
index 32e7bbe..98c65e8 100644
--- a/drivers/net/time_sync.c
+++ b/drivers/net/time_sync.c
@@ -25,8 +25,65 @@
 #include "gianfar.h"
 
 static int time_sync_priv(struct time_sync_priv *time_sync_priv);
+static void time_sync_sysfs_exit(struct kobject *time_sync_kobj);
+static int time_sync_sysfs_init(struct gfar_private *priv);
+static int register_1588_interrupt(struct net_device *dev);
 static void time_sync_free(struct gfar_private *priv);
 static void time_sync_config_fiper(struct gfar_private *priv);
+
+static struct time_sync_sysfs attr1 = {
+	.attr.name = "black_out_duration",
+	.attr.mode = 0444,
+	.cmd_type = BLACK_OUT_DURATION,
+};
+
+static struct time_sync_sysfs attr2 = {
+	.attr.name = "time_sync_source",
+	.attr.mode = 0444,
+	.cmd_type = TIME_SYNC_SOURCE,
+};
+
+static struct time_sync_sysfs attr3 = {
+	.attr.name = "lte_delay",
+	.attr.mode = 0444,
+	.cmd_type = LTE_DELAY,
+};
+
+static struct time_sync_sysfs attr4 = {
+	.attr.name = "last_black_out_occurence",
+	.attr.mode = 0444,
+	.cmd_type = LAST_BLACKOUT_OCCURENCE,
+};
+
+static struct time_sync_sysfs attr5 = {
+	.attr.name = "new_mode_after_blackout",
+	.attr.mode = 0444,
+	.cmd_type = NEW_MODE_AFTER_BLACKOUT,
+};
+
+static struct time_sync_sysfs attr6 = {
+	.attr.name = "correction_mode",
+	.attr.mode = 0444,
+	.cmd_type = CORRECTION_MODE,
+};
+
+static struct time_sync_sysfs attr7 = {
+	.attr.name = "stats",
+	.attr.mode = 0444,
+	.cmd_type = STATS,
+};
+
+static struct attribute *time_sync_attr[] = {
+	&attr1.attr,
+	&attr2.attr,
+	&attr3.attr,
+	&attr4.attr,
+	&attr5.attr,
+	&attr6.attr,
+	&attr7.attr,
+	NULL
+};
+
 struct time_sync_lock sync_lock;
 
 static void time_sync_free(struct gfar_private *priv)
@@ -209,7 +266,116 @@ err:
 }
 
 
+static ssize_t time_sync_show_sysfs(struct kobject *kobj,
+				struct attribute *attr, char *buf)
+{
+	struct time_sync_sysfs *a = container_of(attr,
+				struct time_sync_sysfs, attr);
+	struct time_sync_priv priv;
+	int retval = 0;
+
+	memset(&priv, 0, sizeof(struct time_sync_priv));
+
+	retval = time_sync_priv(&priv);
+	if (retval != 0) {
+		printk(KERN_ERR "Unable to found time_sync priv\n");
+		return -EINVAL;
+	}
+
+	switch (a->cmd_type) {
+	case BLACK_OUT_DURATION:
+		return scnprintf(buf, BUFFER_SIZE, "%d %s\n",
+				priv.time_sync->black_out_duration, "seconds");
+	case TIME_SYNC_SOURCE:
+		switch (priv.time_sync->sync_source) {
+		case PPS_SRC_GPS:
+			return scnprintf(buf, BUFFER_SIZE,
+					"%s\n", GPS_SYNC_SRC);
+		case PPS_SRC_RAW_GPS:
+			return scnprintf(buf, BUFFER_SIZE,
+					"%s\n", RAW_GPS);
+		case PPS_SRC_PTP:
+			return scnprintf(buf, BUFFER_SIZE,
+					"%s\n", PTP_SYNC_SRC);
+		default:
+			return -EINVAL;
+		}
+	case CORRECTION_MODE:
+		return scnprintf(buf, BUFFER_SIZE, "%d\n",
+				priv.time_sync->correction_mode);
+	case LTE_DELAY:
+		return scnprintf(buf, BUFFER_SIZE, "%d %s\n",
+				priv.time_sync->lte_delay, "seconds");
+	case LAST_BLACKOUT_OCCURENCE:
+		return scnprintf(buf, BUFFER_SIZE, "%lu %s %lu %s\n",
+			(unsigned long)priv.blackout_time.tv_sec, "secs",
+			(unsigned long)priv.blackout_time.tv_nsec / 1000,
+					"usec");
+	case NEW_MODE_AFTER_BLACKOUT:
+		/*TBD*/
+		break;
+	case STATS:
+		return scnprintf(buf, BUFFER_SIZE,
+				"%s = %d\n%s = %d\n%s = %d\n%s = %d\n",
+				"gps_cnt", priv.stats.gps_cnt, "fiper1_cnt",
+				priv.stats.fiper1_cnt, "alarm1_cnt",
+				priv.stats.alarm1_cnt, "alarm2_cnt",
+				priv.stats.alarm2_cnt);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return retval;
+}
+
+static ssize_t time_sync_show_store(struct kobject *kobj,
+			struct attribute *attr, const char *buf, size_t len)
+{
+	struct time_sync_sysfs *a = container_of(attr,
+			struct time_sync_sysfs, attr);
+	int bytes_written;
+
+	bytes_written = snprintf(a->data, BUFFER_SIZE, "%s", buf);
+	return bytes_written;
+}
+
+static struct sysfs_ops time_sync_ops = {
+	.show = time_sync_show_sysfs,
+	.store = time_sync_show_store,
+};
+
+static struct kobj_type time_sync_type = {
+	.sysfs_ops = &time_sync_ops,
+	.default_attrs = time_sync_attr,
+};
 
+static int time_sync_sysfs_init(struct gfar_private *priv)
+{
+	struct kobject *time_sync_kobj;
+	int err = -1;
+
+	time_sync_kobj = kzalloc(sizeof(*time_sync_kobj), GFP_KERNEL);
+	if (time_sync_kobj) {
+		kobject_init(time_sync_kobj, &time_sync_type);
+		if (kobject_add(time_sync_kobj, NULL, "%s", "time_sync")) {
+			err = -1;
+			printk(KERN_ERR "Sysfs creation failed\n");
+			kobject_put(time_sync_kobj);
+			time_sync_kobj = NULL;
+		}
+		err = 0;
+	}
+	priv->time_sync_priv->time_sync_kobj = time_sync_kobj;
+	return err;
+}
+
+static void time_sync_sysfs_exit(struct kobject *time_sync_kobj)
+{
+	if (time_sync_kobj) {
+		kobject_put(time_sync_kobj);
+		kfree(time_sync_kobj);
+	}
+}
 
 int time_sync_priv(struct time_sync_priv *time_sync_priv)
 {
diff --git a/drivers/net/time_sync.h b/drivers/net/time_sync.h
index 28d5078..1d05761 100644
--- a/drivers/net/time_sync.h
+++ b/drivers/net/time_sync.h
@@ -130,6 +130,11 @@ struct time_sync_data {
 	struct time_info time_info;
 };
 
+struct time_sync_sysfs {
+	struct attribute attr;
+	char data[BUFFER_SIZE];
+	u32 cmd_type;
+};
 
 struct time_sync_lock {
 	struct mutex lock;
-- 
1.7.0

