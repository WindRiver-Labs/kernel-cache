From 87463a20d196bf602230a2fae9301e281afc3c7f Mon Sep 17 00:00:00 2001
From: b16502 <naveenburmi@freescale.com>
Date: Wed, 14 Sep 2011 11:39:34 +0000
Subject: [PATCH 36/92] crypto: caam - Supoort added for CAAM Software Reset.

Extracted from 913x_WUSDK_REL_0.9.tar.gz vendor drop.

This patch enables the CAAM driver to initiate the software reset of the CAAM block.
It also enhances the UIO interface that enables the user space application to trigger
the reset of CAAM block.

Signed-off-by: Naveen Burmi <NaveenBurmi@freescale.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/crypto/caam/caamuio.c |    5 ++++
 drivers/crypto/caam/caamuio.h |    3 ++
 drivers/crypto/caam/ctrl.c    |   51 +++++++++++++++++++++++++++++++++++++++++
 drivers/crypto/caam/intern.h  |    6 +++++
 drivers/crypto/caam/jr.c      |   49 ++++++++++++++++++++++++++++++++-------
 5 files changed, 105 insertions(+), 9 deletions(-)

diff --git a/drivers/crypto/caam/caamuio.c b/drivers/crypto/caam/caamuio.c
index e1064e7..0ce167c 100644
--- a/drivers/crypto/caam/caamuio.c
+++ b/drivers/crypto/caam/caamuio.c
@@ -74,6 +74,11 @@ static int caam_uio_irq_control(struct uio_info *info, s32 irq_control)
 		setbits32(&caamuiodev->rregs->rconfig_lo, JRCFG_IMSK);
 		return 0;
 
+	case SEC_UIO_RESET_SEC_ENGINE_CMD:
+		/* Reset SEC Engine */
+		caam_reset(caamuiodev->ctrlpriv);
+		return 0;
+
 	default:
 		return 0;
 	}
diff --git a/drivers/crypto/caam/caamuio.h b/drivers/crypto/caam/caamuio.h
index 95dd009..d4fa9e6 100644
--- a/drivers/crypto/caam/caamuio.h
+++ b/drivers/crypto/caam/caamuio.h
@@ -22,5 +22,8 @@
 /** UIO command used by user-space driver to request SEC kernel driver
  *  to simulate that an IRQ is generated on a certain job ring */
 #define SEC_UIO_SIMULATE_IRQ_CMD        2
+/** UIO command used by user-space driver to request SEC kernel driver
+ *  to reset SEC engine device. */
+#define SEC_UIO_RESET_SEC_ENGINE_CMD    3
 
 #endif /* CAAMUIO_H */
diff --git a/drivers/crypto/caam/ctrl.c b/drivers/crypto/caam/ctrl.c
index d5a4860..f28a44b 100644
--- a/drivers/crypto/caam/ctrl.c
+++ b/drivers/crypto/caam/ctrl.c
@@ -10,6 +10,57 @@
 #include "intern.h"
 #include "jr.h"
 
+static int caam_soft_reset(struct caam_drv_private *ctrlpriv)
+{
+	unsigned int timeout = 100000;
+
+	setbits32(&ctrlpriv->ctrl->mcr, MCFGR_SWRESET);
+
+	while ((in_be32(&ctrlpriv->ctrl->mcr) & MCFGR_SWRESET)
+	       && --timeout)
+		cpu_relax();
+
+	if (timeout == 0) {
+		dev_err(&ctrlpriv->ofdev->dev,
+			"Soft reset of CAAM device Failed\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+int caam_reset(struct caam_drv_private *ctrlpriv)
+{
+	int ring;
+	int nr_kernel_jrs;
+
+	/* check if, reset is in progress */
+	if (ctrlpriv->reset_flag) {
+		dev_info(&ctrlpriv->ofdev->dev, "CAAM reset in progress\n");
+		return -EINPROGRESS;
+	}
+
+	/* set the reset flag so to stop enqueuing of new jobs */
+	ctrlpriv->reset_flag = 1;
+
+	/* Reset kernel mode job rings */
+	nr_kernel_jrs = ctrlpriv->total_jobrs - ctrlpriv->nr_uio_jrs;
+	for (ring = 0; ring < nr_kernel_jrs; ring++)
+		caam_reset_hw_jr(ctrlpriv->jrdev[ring]);
+
+	/* Reset CAAM engine */
+	caam_soft_reset(ctrlpriv);
+
+	/* Re-Init job ring regs */
+	for (ring = 0; ring < nr_kernel_jrs; ring++)
+		caam_jr_reinit(ctrlpriv->jrdev[ring]);
+
+	/* clear the reset-flag */
+	ctrlpriv->reset_flag = 0;
+
+	return 0;
+}
+
 static int caam_remove(struct of_device *ofdev)
 {
 	struct device *ctrldev;
diff --git a/drivers/crypto/caam/intern.h b/drivers/crypto/caam/intern.h
index 7f00e96..7ca0870 100644
--- a/drivers/crypto/caam/intern.h
+++ b/drivers/crypto/caam/intern.h
@@ -57,10 +57,12 @@ struct caam_drv_private_jr {
 	int inp_ring_write_index;	/* Input index "tail" */
 	int head;			/* entinfo (s/w ring) head index */
 	dma_addr_t *inpring;	/* Base of input ring, alloc DMA-safe */
+	dma_addr_t inpbusaddr;		/* Input ring bus address */
 	spinlock_t outlock ____cacheline_aligned; /* Output ring index lock */
 	int out_ring_read_index;	/* Output index "tail" */
 	int tail;			/* entinfo (s/w ring) tail index */
 	struct jr_outentry *outring;	/* Base of output ring, DMA-safe */
+	dma_addr_t outbusaddr;		/* Output ring bus address */
 };
 
 /*
@@ -77,6 +79,7 @@ struct caam_drv_private {
 	/* Non-OF-specific defs */
 #endif
 
+	u8 reset_flag;
 	struct uio_info **uiodev;	/* Array for user space job rings */
 	u8 nr_uio_jrs;			/* Total user space job rings */
 
@@ -118,6 +121,9 @@ struct caam_drv_private {
 #endif
 };
 
+int caam_jr_reinit(struct device *dev);
+int caam_reset_hw_jr(struct device *dev);
 void caam_jr_algapi_init(struct device *dev);
 void caam_jr_algapi_remove(struct device *dev);
+int caam_reset(struct caam_drv_private *ctrlpriv);
 #endif /* INTERN_H */
diff --git a/drivers/crypto/caam/jr.c b/drivers/crypto/caam/jr.c
index 4cf6837..3780c0e 100644
--- a/drivers/crypto/caam/jr.c
+++ b/drivers/crypto/caam/jr.c
@@ -240,11 +240,15 @@ int caam_jr_enqueue(struct device *dev, u32 *desc,
 		    void *areq)
 {
 	struct caam_drv_private_jr *jrp = dev_get_drvdata(dev);
+	struct caam_drv_private *ctrlpriv = dev_get_drvdata(jrp->parentdev);
 	struct caam_jrentry_info *head_entry;
 	unsigned long flags;
 	int head, tail, desc_size;
 	dma_addr_t desc_dma;
 
+	if (ctrlpriv->reset_flag)
+		return -EBUSY;
+
 	desc_size = (*desc & HDR_JD_LENGTH_MASK) * sizeof(u32);
 	desc_dma = dma_map_single(dev, desc, desc_size, DMA_TO_DEVICE);
 	if (dma_mapping_error(dev, desc_dma)) {
@@ -289,7 +293,7 @@ int caam_jr_enqueue(struct device *dev, u32 *desc,
 }
 EXPORT_SYMBOL(caam_jr_enqueue);
 
-static int caam_reset_hw_jr(struct device *dev)
+int caam_reset_hw_jr(struct device *dev)
 {
 	struct caam_drv_private_jr *jrp = dev_get_drvdata(dev);
 	unsigned int timeout = 100000;
@@ -329,13 +333,40 @@ static int caam_reset_hw_jr(struct device *dev)
 	return 0;
 }
 
+int caam_jr_reinit(struct device *dev)
+{
+	struct caam_drv_private_jr *jrp;
+	int i;
+
+	jrp = dev_get_drvdata(dev);
+
+	for (i = 0; i < JOBR_DEPTH; i++)
+		jrp->entinfo[i].desc_addr_dma = !0;
+
+	jrp->inp_ring_write_index = 0;
+	jrp->out_ring_read_index = 0;
+	jrp->head = 0;
+	jrp->tail = 0;
+
+	wr_reg64(&jrp->rregs->inpring_base, jrp->inpbusaddr);
+	wr_reg64(&jrp->rregs->outring_base, jrp->outbusaddr);
+	wr_reg32(&jrp->rregs->inpring_size, JOBR_DEPTH);
+	wr_reg32(&jrp->rregs->outring_size, JOBR_DEPTH);
+
+	/* Select interrupt coalescing parameters */
+	setbits32(&jrp->rregs->rconfig_lo, JOBR_INTC |
+		  (JOBR_INTC_COUNT_THLD << JRCFG_ICDCT_SHIFT) |
+		  (JOBR_INTC_TIME_THLD << JRCFG_ICTT_SHIFT));
+
+	return 0;
+}
+
 /*
  * Init JobR independent of platform property detection
  */
 static int caam_jr_init(struct device *dev)
 {
 	struct caam_drv_private_jr *jrp;
-	dma_addr_t inpbusaddr, outbusaddr;
 	int i, error;
 
 	jrp = dev_get_drvdata(dev);
@@ -378,10 +409,10 @@ static int caam_jr_init(struct device *dev)
 		jrp->entinfo[i].desc_addr_dma = !0;
 
 	/* Setup rings */
-	inpbusaddr = dma_map_single(dev, jrp->inpring,
+	jrp->inpbusaddr = dma_map_single(dev, jrp->inpring,
 				    sizeof(u32 *) * JOBR_DEPTH,
 				    DMA_BIDIRECTIONAL);
-	if (dma_mapping_error(dev, inpbusaddr)) {
+	if (dma_mapping_error(dev, jrp->inpbusaddr)) {
 		dev_err(dev, "caam_jr_init(): can't map input ring\n");
 		kfree(jrp->inpring);
 		kfree(jrp->outring);
@@ -389,12 +420,12 @@ static int caam_jr_init(struct device *dev)
 		return -EIO;
 	}
 
-	outbusaddr = dma_map_single(dev, jrp->outring,
+	jrp->outbusaddr = dma_map_single(dev, jrp->outring,
 				    sizeof(struct jr_outentry) * JOBR_DEPTH,
 				    DMA_BIDIRECTIONAL);
-	if (dma_mapping_error(dev, outbusaddr)) {
+	if (dma_mapping_error(dev, jrp->outbusaddr)) {
 		dev_err(dev, "caam_jr_init(): can't map output ring\n");
-			dma_unmap_single(dev, inpbusaddr,
+			dma_unmap_single(dev, jrp->inpbusaddr,
 					 sizeof(u32 *) * JOBR_DEPTH,
 					 DMA_BIDIRECTIONAL);
 		kfree(jrp->inpring);
@@ -408,8 +439,8 @@ static int caam_jr_init(struct device *dev)
 	jrp->head = 0;
 	jrp->tail = 0;
 
-	wr_reg64(&jrp->rregs->inpring_base, inpbusaddr);
-	wr_reg64(&jrp->rregs->outring_base, outbusaddr);
+	wr_reg64(&jrp->rregs->inpring_base, jrp->inpbusaddr);
+	wr_reg64(&jrp->rregs->outring_base, jrp->outbusaddr);
 	wr_reg32(&jrp->rregs->inpring_size, JOBR_DEPTH);
 	wr_reg32(&jrp->rregs->outring_size, JOBR_DEPTH);
 
-- 
1.7.0

