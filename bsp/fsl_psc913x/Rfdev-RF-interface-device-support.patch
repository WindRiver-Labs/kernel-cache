From 5c3c7ab0e50f5f2340e603d6548c990f5cc62734 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Tue, 15 Nov 2011 16:44:26 +0800
Subject: [PATCH 20/92] Rfdev: RF interface device support

Extracted from 913x_WUSDK_REL_0.4.tar.gz vendor drop.

rfdev is a device representing Radio interface on a LTE/CDMA
system. In a system supporting LTE/CDMA, one rfdev represents
a combination of radio interface controller and Radio phy (RFIC)
connected to that controller and it is exposed to user space
as 'rf<x>' (x: 0, 1, 2, etc). In a multimode system there can be
multiple rfdev devices, depending on number of radios connected.

This framework is independent of rf controller device and RFIC.
rf controller and RFIC drivers register their respective devices
with this framework. This framework does binding of RFIC device with
RF controller device and exposes the combination as a logical
rfdev to user space.

For configuration of rfdev interface from user space, rfutils
package is required.

Signed-off-by: Pankaj Chauhan <pankaj.chauhan@freescale.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/Kconfig             |    2 +
 drivers/Makefile            |    1 +
 drivers/rf/Kconfig          |   40 +++
 drivers/rf/Makefile         |    7 +
 drivers/rf/core/Makefile    |    2 +
 drivers/rf/core/rfdev.c     |  549 +++++++++++++++++++++++++++++++++++++++++++
 include/linux/rfdev.h       |  113 +++++++++
 include/linux/rfdev_ioctl.h |  113 +++++++++
 8 files changed, 827 insertions(+), 0 deletions(-)
 create mode 100644 drivers/rf/Kconfig
 create mode 100644 drivers/rf/Makefile
 create mode 100644 drivers/rf/core/Makefile
 create mode 100644 drivers/rf/core/rfdev.c
 create mode 100644 include/linux/rfdev.h
 create mode 100644 include/linux/rfdev_ioctl.h

diff --git a/drivers/Kconfig b/drivers/Kconfig
index ed3b4ac..2f5915a 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -112,6 +112,8 @@ source "drivers/staging/Kconfig"
 
 source "drivers/platform/Kconfig"
 
+source "drivers/rf/Kconfig"
+
 source "drivers/tdm/Kconfig"
 
 source "drivers/wrhv/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index 29ed61d..3936bf6 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -113,5 +113,6 @@ obj-$(CONFIG_VLYNQ)		+= vlynq/
 obj-$(CONFIG_STAGING)		+= staging/
 obj-y				+= platform/
 obj-y				+= ieee802154/
+obj-$(CONFIG_RFDEVICES)		+= rf/
 obj-y				+= tdm/
 obj-y				+= wrhv/
diff --git a/drivers/rf/Kconfig b/drivers/rf/Kconfig
new file mode 100644
index 0000000..cf5535c
--- /dev/null
+++ b/drivers/rf/Kconfig
@@ -0,0 +1,40 @@
+
+# RF (radio frequency) device configuration
+#
+
+menuconfig RFDEVICES
+	default n
+	bool "RF interface device support"
+	---help---
+	Support for RF interface devices for LTE/CDMA.
+	In a system supporting LTE/CDMA, different radios (RF PHYs) are
+	connected depending on required radio technology. Higher layer
+	stacks need to configure the radio according to required network mode.
+	Adding this support will export different radios connected in system
+	(in case of multi mode system)as RF interface deivces 'rf0', 'rf1' etc.
+	Higher layer stacks (running in user space)can use rfX device to
+	talk to a specific radio.
+
+	radio interface controller driver (Antenna controller) and RF PHY driver
+	connected to system must also be chosen.
+
+if RFDEVICES
+
+config RFDEV_CORE
+	default y
+	bool
+config FSL_AIC
+	default y
+	bool "Freescale Antenna Interface Controller (AIC)"
+	---help---
+	Freescale AIC controller (Antenna Interface Controller) is found
+	in psc913x family of SOCs. AIC has six RF lanes and maximum four
+	RF PHYs can be connected and operated simultaneously.
+
+config ADI9361
+	default y
+	bool "ADI 9361 RF PHY"
+	---help---
+	ADI9361 RF phy driver.
+
+endif
diff --git a/drivers/rf/Makefile b/drivers/rf/Makefile
new file mode 100644
index 0000000..61a0e7c
--- /dev/null
+++ b/drivers/rf/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for the RF interface drivers.
+#
+
+obj-$(CONFIG_RFDEVICES)		+= core/
+obj-$(CONFIG_RFDEVICES)		+= controllers/
+obj-$(CONFIG_RFDEVICES)		+= phy/
diff --git a/drivers/rf/core/Makefile b/drivers/rf/core/Makefile
new file mode 100644
index 0000000..4cb7ec4
--- /dev/null
+++ b/drivers/rf/core/Makefile
@@ -0,0 +1,2 @@
+
+obj-$(CONFIG_RFDEVICES)		+= rfdev.o
diff --git a/drivers/rf/core/rfdev.c b/drivers/rf/core/rfdev.c
new file mode 100644
index 0000000..accb018
--- /dev/null
+++ b/drivers/rf/core/rfdev.c
@@ -0,0 +1,549 @@
+/*
+ * drivers/rf/core.c
+ * RF device framework
+ *
+ * Radio interface device framework exposes the combination of a RF interface
+ * controller and RFIC as a RF device (eg. rf0, rf1) to user space for
+ * configuration. This interface is for RF PHYs for LTE/CDMA systems. RF
+ * interface controller driver and RFIC driver registers respective devices
+ * with this framework, and thier combination is exposed to user space as
+ * a unified rfdev interface 'rf0'.
+ *
+ * Author: pankaj chauhan <pankaj.chauhan@freescale.com>
+ *
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/bitops.h>
+#include <linux/fs.h>
+#include <linux/wait.h>
+#include <linux/rfdev.h>
+#include <linux/cdev.h>
+#include <linux/uaccess.h>
+#include <linux/rfdev_ioctl.h>
+#include <linux/slab.h>
+
+struct rf_priv {
+	struct list_head ctrl_list;
+	struct list_head phy_list;
+	spinlock_t phy_lock;
+	spinlock_t ctrl_lock;
+	unsigned long	name_idx_bitmap;
+	struct cdev cdev;
+	dev_t	dev;
+};
+
+static struct rf_priv *rf_priv;
+static int rf_change_state(struct rf_ctrl_dev *rf_dev, unsigned int state);
+static int rf_attach_phy(struct rf_ctrl_dev *rf_dev, struct rf_phy_dev *phy);
+static int rf_open(struct inode *inode, struct file *filep);
+static int rf_release(struct inode *inode, struct file *filep);
+static ssize_t rf_read(struct file *, char __user *, size_t, loff_t *);
+static int rf_ioctl(struct inode *, struct file *, unsigned int,
+		unsigned long);
+
+const static struct file_operations rf_fops = {
+	.open 	= rf_open,
+	.release = rf_release,
+	.read 	= rf_read,
+	.ioctl 	= rf_ioctl,
+};
+
+struct rf_ctrl_dev *allocate_rf_ctrl_dev(size_t priv_size,
+		unsigned long flags)
+{
+	struct rf_ctrl_dev *rf_dev;
+	size_t size;
+
+	size = sizeof(struct rf_ctrl_dev) + priv_size;
+	rf_dev = kzalloc(size, flags);
+
+	if (!rf_dev)
+		return rf_dev;
+
+	atomic_set(&rf_dev->ref, 1);
+	mutex_init(&rf_dev->lock);
+	init_waitqueue_head(&rf_dev->wait_q);
+	rf_dev->priv = (unsigned char *) rf_dev + sizeof(struct rf_ctrl_dev);
+	rf_dev->dev_idx = ~0;
+
+	return rf_dev;
+}
+EXPORT_SYMBOL(allocate_rf_ctrl_dev);
+
+int free_rf_ctrl_dev(struct rf_ctrl_dev *rf_dev)
+{
+	if (!atomic_dec_and_test(&rf_dev->ref))
+		return -EBUSY;
+	kfree(rf_dev);
+
+	return 0;
+}
+EXPORT_SYMBOL(free_rf_ctrl_dev);
+
+int register_rf_ctrl_dev(struct rf_ctrl_dev *rf_dev)
+{
+	struct rf_ctrl_ops *ctrl_ops;
+	unsigned int dev_idx;
+	unsigned long *devid_map;
+	int rc = 0;
+
+	ctrl_ops = rf_dev->ops;
+	if (!ctrl_ops || !ctrl_ops->init
+		|| !ctrl_ops->start || !ctrl_ops->stop)
+		return -EINVAL;
+
+	rf_dev->state = RF_INIT;
+	spin_lock(&rf_priv->ctrl_lock);
+
+	devid_map = (unsigned long *)&rf_priv->name_idx_bitmap;
+	dev_idx = find_first_zero_bit(devid_map, 32);
+
+	set_bit(dev_idx, devid_map);
+	list_add_tail(&rf_dev->list, &rf_priv->ctrl_list);
+
+	spin_unlock(&rf_priv->ctrl_lock);
+	sprintf(&rf_dev->name[0], "rf%d", dev_idx);
+	rf_dev->dev_idx = dev_idx;
+	if (rf_attach_phy(rf_dev, NULL))
+		rc = rf_change_state(rf_dev, RF_PHY_ATTACHED);
+
+	return rc;
+}
+EXPORT_SYMBOL(register_rf_ctrl_dev);
+
+int unregister_rf_ctrl_dev(struct rf_ctrl_dev *rf_dev)
+{
+	struct rf_phy_dev *phy;
+	int rc = 0;
+
+	/* Notify PHY that we are going down */
+	phy = rf_dev->phy;
+
+	if (phy->ops->stop) {
+		rc = phy->ops->stop(phy);
+		if (rc) {
+			pr_debug("%s: unregister failed, phy busy\n",
+					rf_dev->name);
+			return -EBUSY;
+		}
+	}
+	rf_change_state(rf_dev, RF_DOWN);
+
+	spin_lock(&rf_priv->ctrl_lock);
+
+	clear_bit(rf_dev->dev_idx, &rf_priv->name_idx_bitmap);
+	list_del(&rf_dev->list);
+
+	spin_unlock(&rf_priv->ctrl_lock);
+
+	return rc;
+}
+EXPORT_SYMBOL(unregister_rf_ctrl_dev);
+
+struct rf_phy_dev *allocate_rf_phy_dev(size_t priv_size, unsigned long flags)
+{
+	struct rf_phy_dev *phy;
+	size_t size;
+
+	size = sizeof(struct rf_phy_dev) + priv_size;
+	phy = kzalloc(size, flags);
+	if (!phy)
+		return NULL;
+
+	phy->priv = ((unsigned char *) phy) + sizeof(struct rf_phy_dev);
+
+	return phy;
+}
+EXPORT_SYMBOL(allocate_rf_phy_dev);
+
+int free_rf_phy_dev(struct rf_phy_dev *phy)
+{
+	kfree(phy);
+
+	return 0;
+}
+EXPORT_SYMBOL(free_rf_phy_dev);
+
+int register_rf_phy_dev(struct rf_phy_dev *phy)
+{
+	struct rf_ctrl_dev *rf_ctrl_dev;
+	struct rf_phy_ops *phy_ops;
+
+	phy_ops = phy->ops;
+	if (!phy_ops || !phy_ops->init
+		|| !phy_ops->start || !phy_ops->stop)
+		return -EINVAL;
+
+	spin_lock(&rf_priv->phy_lock);
+
+	list_add_tail(&phy->list, &rf_priv->phy_list);
+
+	spin_unlock(&rf_priv->phy_lock);
+
+	if (rf_attach_phy(NULL, phy)) {
+		rf_ctrl_dev = phy->ctrl_dev;
+		rf_change_state(rf_ctrl_dev, RF_PHY_ATTACHED);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(register_rf_phy_dev);
+
+int unregister_rf_phy_dev(struct rf_phy_dev *phy)
+{
+	struct rf_ctrl_dev *rf_dev;
+	int rc;
+
+	rf_dev = phy->ctrl_dev;
+	if (rf_dev->ops->phy_detach) {
+		rc = rf_dev->ops->phy_detach(rf_dev);
+		if (rc)
+			return -EBUSY;
+		rf_dev->phy = NULL;
+		rf_change_state(rf_dev, RF_DOWN);
+	}
+	spin_lock(&rf_priv->phy_lock);
+
+	list_del(&phy->list);
+
+	spin_unlock(&rf_priv->phy_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(unregister_rf_phy_dev);
+
+int rf_change_state(struct rf_ctrl_dev *rf_dev, unsigned int state)
+{
+	/*
+	 *For now state assignment as it is. Gradually
+	 *this function will become intelligent to handle
+	 *state machine if required.
+	 */
+	rf_dev->state = state;
+
+	return 0;
+}
+
+int rf_attach_phy(struct rf_ctrl_dev *rf_dev, struct rf_phy_dev *phy)
+{
+	int match = 0;
+
+	/* Search for a phy for given rf ctrl dev */
+	if (rf_dev) {
+		spin_lock(&rf_priv->phy_lock);
+
+		list_for_each_entry(phy, &rf_priv->phy_list, list) {
+			if (rf_dev->phy_id == phy->phy_id) {
+				match = 1;
+				break;
+			}
+		}
+
+		spin_unlock(&rf_priv->phy_lock);
+	} else if (phy) {
+	/* Search for a rf ctrl dev for a given phy */
+		spin_lock(&rf_priv->ctrl_lock);
+
+		list_for_each_entry(rf_dev, &rf_priv->ctrl_list, list) {
+			if (phy->phy_id == rf_dev->phy_id) {
+				match = 1;
+				break;
+			}
+		}
+
+		spin_unlock(&rf_priv->ctrl_lock);
+	}
+
+	if (match) {
+		rf_dev->phy = phy;
+		phy->ctrl_dev = rf_dev;
+	}
+
+	return match;
+}
+
+int rf_notify_dl_tti(struct rf_ctrl_dev *rf_dev)
+{
+	struct rf_stats *stats;
+
+	stats = &rf_dev->stats;
+	stats->tti_count++;
+	wake_up_all(&rf_dev->wait_q);
+
+	return 0;
+}
+
+static int rf_open(struct inode *inode, struct file *filep)
+{
+	int minor, match = 0;
+	struct rf_ctrl_dev *rf_dev = NULL;
+
+	minor = iminor(inode);
+	spin_lock(&rf_priv->ctrl_lock);
+
+	list_for_each_entry(rf_dev, &rf_priv->ctrl_list, list) {
+		if (rf_dev->dev_idx == minor) {
+			match = 1;
+			break;
+		}
+	}
+
+	spin_unlock(&rf_priv->ctrl_lock);
+	if (!match) {
+		return -ENODEV;
+	} else {
+		filep->private_data = rf_dev;
+		atomic_inc(&rf_dev->ref);
+	}
+
+	return 0;
+}
+
+int rf_release(struct inode *inode, struct file *filep)
+{
+	struct rf_ctrl_dev *rf_dev;
+
+	rf_dev = filep->private_data;
+	atomic_dec(&rf_dev->ref);
+
+	return 0;
+}
+static ssize_t rf_read(struct file *filep, char __user *buf, size_t size,
+			loff_t *offset)
+{
+	struct rf_ctrl_dev *rf_dev;
+	struct rf_stats *stats;
+	wait_queue_t 	wait;
+
+	rf_dev = filep->private_data;
+	stats = &rf_dev->stats;
+	init_waitqueue_entry(&wait, current);
+	add_wait_queue(&rf_dev->wait_q, &wait);
+	set_current_state(TASK_INTERRUPTIBLE);
+	/*Now wait here, tti notificaion will wake us up*/
+	schedule();
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&rf_dev->wait_q, &wait);
+
+	return put_user(stats->tti_count, (int *)buf);
+}
+
+int rf_fill_dev_info(struct rf_ctrl_dev *rf_dev, struct rf_dev_info *dev_info)
+{
+	struct rf_phy_dev *phy;
+
+	strncpy(dev_info->controller, rf_dev->name, RIF_NAME_SIZE);
+	dev_info->state = rf_dev->state;
+	if (rf_dev->state >= RF_PHY_ATTACHED) {
+		phy = rf_dev->phy;
+		strncpy(dev_info->phy, phy->name, RIF_NAME_SIZE);
+	}
+
+	return 0;
+}
+static int rf_ioctl(struct inode *inode, struct file *filep,
+		unsigned int cmd, unsigned long arg)
+{
+	struct rf_ctrl_dev *rf_dev;
+	struct rf_phy_dev *phy;
+	struct rf_init_params init_params;
+	struct rif_phy_cmd_set cmd_set;
+	struct rif_reg_buf reg_buf;
+	struct rf_dev_info dev_info;
+	u32	*buf;
+	u32 u32arg;
+	int rc = -ENOSYS, size;
+
+	rf_dev = filep->private_data;
+	phy = rf_dev->phy;
+
+	mutex_lock_interruptible(&rf_dev->lock);
+	switch (cmd) {
+
+	case RIF_DEV_INIT:
+
+		if (copy_from_user(&init_params,
+			(struct rf_init_params *)arg, sizeof(init_params))) {
+			rc = -EFAULT;
+			goto out;
+		}
+		if (phy) {
+			rc = phy->ops->init(phy, &init_params);
+			if (rc)
+				goto out;
+		}
+
+		rc = rf_dev->ops->init(rf_dev, &init_params);
+		break;
+
+	case RIF_SET_TIMER_SOURCE:
+		if (!get_user(u32arg, (int *)arg))
+			rc = rf_dev->ops->set_timing_source(rf_dev, u32arg);
+		else
+			rc = -EFAULT;
+		break;
+
+	case RIF_SET_TIMER_CORRECTION:
+		if (!get_user(u32arg, (int *)arg)) {
+			if (phy && phy->ops->set_timer_correction)
+				rc = phy->ops->set_timer_correction(phy,
+							u32arg);
+		} else {
+			rc = -EFAULT;
+		}
+		break;
+
+	case RIF_RUN_PHY_CMDS:
+
+		if (!phy || !phy->ops->run_cmds)
+			goto out;
+
+		rc = -EFAULT;
+		if (!copy_from_user(&cmd_set, (struct rif_phy_cmd_set *)arg,
+			sizeof(struct rif_phy_cmd_set))) {
+
+			size = sizeof(struct rif_phy_cmd) * cmd_set.count;
+			buf = kzalloc(size, GFP_KERNEL);
+			if (buf) {
+				if (!copy_from_user(buf,
+						(u32 *) cmd_set.cmds, size))
+					rc = phy->ops->run_cmds(phy,
+						(struct rif_phy_cmd *)buf,
+						cmd_set.count);
+				kfree(buf);
+			} else {
+				rc = -ENOMEM;
+			}
+		}
+		break;
+
+	case RIF_READ_RSSI:
+
+		if (phy && phy->ops->read_rssi) {
+			u32arg = phy->ops->read_rssi(phy);
+			if (put_user(u32arg, (int *)arg))
+				rc = -EFAULT;
+		}
+		break;
+
+	case RIF_READ_PHY_REGS:
+	case RIF_READ_CTRL_REGS:
+
+		if (!copy_from_user(&reg_buf, (struct rif_reg_buf *)arg,
+			sizeof(struct rif_reg_buf))) {
+
+			size = 4 * reg_buf.count;
+			buf = kzalloc(size, GFP_KERNEL);
+			if (!buf) {
+				rc = -ENOMEM;
+				goto out;
+			}
+			if (cmd == RIF_READ_PHY_REGS) {
+
+				if (phy && phy->ops->read_regs) {
+					rc = phy->ops->read_regs(phy,
+						reg_buf.addr,
+						reg_buf.count, buf);
+				}
+			} else if (cmd == RIF_READ_CTRL_REGS) {
+
+				if (rf_dev->ops->read_regs) {
+					rc = rf_dev->ops->read_regs(rf_dev,
+						reg_buf.addr,
+						reg_buf.count, buf);
+				}
+			}
+			if (copy_to_user((u32 *)reg_buf.buf,
+					buf, size))
+				rc = -EFAULT;
+			kfree(buf);
+		} else {
+			rc = -EFAULT;
+		}
+		break;
+
+	case RIF_START:
+		if (phy) {
+			rc = phy->ops->start(phy);
+			if (rc)
+				goto out;
+		}
+		rc = rf_dev->ops->start(rf_dev);
+		if (!rc)
+			rf_change_state(rf_dev, RF_READY);
+		break;
+
+	case RIF_STOP:
+
+		if (phy) {
+			rc = phy->ops->stop(phy);
+			if (rc)
+				goto out;
+		}
+		rc = rf_dev->ops->stop(rf_dev);
+		if (!rc)
+			rf_change_state(rf_dev, RF_STOPPED);
+		break;
+
+	case RIF_GET_DEV_INFO:
+		rc = rf_fill_dev_info(rf_dev, &dev_info);
+		if (copy_to_user((struct rf_dev_info *)arg,
+					&dev_info, sizeof(dev_info)))
+			rc = -EFAULT;
+		break;
+
+	default:
+		rc = -ENOSYS;
+	}
+
+out:
+	mutex_unlock(&rf_dev->lock);
+	return rc;
+}
+
+static int __init rf_init(void)
+{
+	int rc;
+
+	rf_priv = kzalloc(sizeof(struct rf_priv), GFP_KERNEL);
+	if (!rf_priv) {
+		pr_debug("rfdev: Unable to allocate rf_priv\n");
+		return -ENOMEM;
+	}
+
+	rc = alloc_chrdev_region(&rf_priv->dev, 0, RF_MAX_DEVS, "rfdev");
+	if (rc) {
+		pr_debug("rfdev:Failed to register rf chardev,err %d\n",
+				rc);
+		return rc;
+	}
+
+	cdev_init(&rf_priv->cdev, &rf_fops);
+	cdev_add(&rf_priv->cdev, rf_priv->dev, RF_MAX_DEVS);
+	INIT_LIST_HEAD(&rf_priv->phy_list);
+	INIT_LIST_HEAD(&rf_priv->ctrl_list);
+
+	return 0;
+}
+
+static void __exit rf_cleanup(void)
+{
+	if (rf_priv) {
+		cdev_del(&rf_priv->cdev);
+		unregister_chrdev_region(rf_priv->dev, RF_MAX_DEVS);
+		kfree(rf_priv);
+	}
+}
+
+MODULE_LICENSE("GPL v2");
+module_init(rf_init);
+module_exit(rf_cleanup);
diff --git a/include/linux/rfdev.h b/include/linux/rfdev.h
new file mode 100644
index 0000000..5a1f0c0
--- /dev/null
+++ b/include/linux/rfdev.h
@@ -0,0 +1,113 @@
+/*
+ * RF device framework
+ *
+ * Author: pankaj chauhan <pankaj.chauhan@freescale.com>
+ *
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __RFDEV_H__
+#define __RFDEV_H__
+
+#include <linux/time.h>
+#include <linux/rfdev_ioctl.h>
+#include <linux/list.h>
+#include <asm/atomic.h>
+
+#define TTI_LOG_SIZE	10
+
+struct rf_stats {
+	unsigned int tti_count;
+	struct timeval tti_ts[TTI_LOG_SIZE];
+};
+
+struct rf_dev_params {
+	unsigned int ants;
+	unsigned int symbol_len;
+	unsigned int cp0_len;
+	unsigned int cp1_len;
+	/*Frame structure*/
+	unsigned int subfrm_per_frm;
+	unsigned int slots_per_subfrm;
+	unsigned int chips_per_slot;
+	unsigned int symbols_per_slot;
+};
+
+struct rf_ctrl_dev {
+	char			name[RIF_NAME_SIZE];
+	enum rf_state		state;
+	struct rf_dev_params	dev_params;
+	int			dev_idx;
+	u32			phy_id;
+	void 			*priv;
+	struct rf_ctrl_ops	*ops;
+	struct rf_phy_dev	*phy;
+	atomic_t		ref;
+	wait_queue_head_t	wait_q;
+	struct list_head	list;
+	struct mutex		lock;
+	struct rf_stats		stats;
+};
+
+struct rf_phy_dev {
+	char	name[RIF_NAME_SIZE];
+	void	*priv;
+	u32	phy_id;
+	struct	rf_phy_ops *ops;
+	struct  rf_ctrl_dev *ctrl_dev;
+	struct	list_head list;
+};
+
+struct rf_phy_ops {
+	int	(*init)(struct rf_phy_dev *phy,
+				struct rf_init_params *params);
+
+	int	(*set_timer_correction)(struct rf_phy_dev *phy,
+			 u32 correction); /*XXX: API is not final*/
+
+	int	(*run_cmds)(struct rf_phy_dev *phy,
+				struct rif_phy_cmd *cmds, int count);
+
+	int	(*read_regs)(struct rf_phy_dev *phy, u32 start,
+				u32 count, u32 *buff);
+
+	u32	(*read_rssi)(struct rf_phy_dev *phy);
+	int	(*start)(struct rf_phy_dev *phy);
+	int	(*stop)(struct rf_phy_dev *phy);
+
+};
+
+struct rf_ctrl_ops {
+
+	int	(*init)(struct rf_ctrl_dev *ctrl_dev,
+				struct rf_init_params *params);
+
+	int	(*set_timing_source)(struct rf_ctrl_dev *ctrl_dev,
+			unsigned int pps_src);
+
+	int	(*read_regs)(struct rf_ctrl_dev *ctrl_dev, u32 start,
+				u32 count, u32 *buff);
+
+	int	(*phy_detach)(struct rf_ctrl_dev *ctrl_dev);
+	int	(*start)(struct rf_ctrl_dev *ctrl_dev);
+	int	(*stop)(struct rf_ctrl_dev *ctrl_dev);
+};
+
+struct	rf_ctrl_dev *allocate_rf_ctrl_dev(size_t priv_size,
+			unsigned long flags);
+int 	free_rf_ctrl_dev(struct rf_ctrl_dev *rf_dev);
+int	register_rf_ctrl_dev(struct rf_ctrl_dev *rf_dev);
+int	unregister_rf_ctrl_dev(struct rf_ctrl_dev *rf_dev);
+
+struct  rf_phy_dev *allocate_rf_phy_dev(size_t priv_size,
+		unsigned long flags);
+int	free_rf_phy_dev(struct rf_phy_dev *phy);
+int	register_rf_phy_dev(struct rf_phy_dev *phy_dev);
+int	unregister_rf_phy_dev(struct rf_phy_dev *phy_dev);
+int	rf_notify_dl_tti(struct rf_ctrl_dev *rf_dev);
+#endif
diff --git a/include/linux/rfdev_ioctl.h b/include/linux/rfdev_ioctl.h
new file mode 100644
index 0000000..aa7706d
--- /dev/null
+++ b/include/linux/rfdev_ioctl.h
@@ -0,0 +1,113 @@
+/*
+ * RF device framework
+ *
+ * Author: pankaj chauhan <pankaj.chauhan@freescale.com>
+ *
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __RFDEV_IOCTL_H__
+#define __RFDEV_IOCTL_H__
+
+#include <linux/ioctl.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+#define RIF_NAME_SIZE	20
+#define RF_MAX_DEVS	6
+
+enum rf_network_mode {
+	LTE_TDD,
+	LTE_FDD
+};
+
+enum rf_txrxmode {
+	TXRX_1T1R,
+	TXRX_1T2R,
+	TXRX_2T2R
+};
+
+enum rf_band_width {
+	BW_05_MHZ,
+	BW_10_MHZ,
+	BW_15_MHZ,
+	BW_20_MHZ
+};
+enum rf_state {
+	RF_DOWN,
+	RF_INIT,
+	RF_PHY_ATTACHED,
+	RF_STOPPED,
+	RF_READY,
+	RF_TIMER_SYNC_AWAITED,
+	RF_TIMER_SYNC_FAILED
+};
+
+struct rf_init_params {
+	enum rf_network_mode mode;
+	enum rf_txrxmode tx_rxmode;
+	enum rf_band_width bw;
+	unsigned int long_cp;
+	unsigned int ants;
+};
+
+struct rf_dev_info {
+	char controller[RIF_NAME_SIZE];
+	char phy[RIF_NAME_SIZE];
+	enum rf_state state;
+	enum rf_network_mode net_mode;
+	enum rf_txrxmode txrx_mode;
+	enum rf_band_width bw;
+	/*Frame structure*/
+	unsigned int subfrm_per_frm;
+	unsigned int slots_per_subfrm;
+	unsigned int chips_per_slot;
+	unsigned int symbols_per_slot;
+	unsigned int ants;
+};
+
+struct rif_phy_cmd {
+	__u32	cmd;
+	__u32	param1;
+	__u32	param2;
+	__u32	param3;
+};
+
+struct rif_phy_cmd_set {
+	struct rif_phy_cmd *cmds;
+	unsigned int count;
+};
+
+struct rif_reg_buf {
+	__u32 addr;
+	void *buf;
+	unsigned int count;
+};
+
+enum rf_timer_src {
+	RF_PPS_SRC_GPS,
+	RF_PPS_SRC_RAW_GPS,
+	RF_PPS_SRC_PTP,
+	RF_PPS_SRC_NLM
+};
+
+
+#define RF_MAGIC 'R'
+#define RIF_DEV_INIT		_IOWR(RF_MAGIC, 1, struct rf_init_params*)
+#define RIF_SET_TIMER_SOURCE	_IOW(RF_MAGIC, 2, unsigned int)
+#define RIF_GET_STATE		_IOR(RF_MAGIC, 3, unsigned int)
+#define RIF_SET_TIMER_CORRECTION _IOW(RF_MAGIC, 4, unsigned int)
+#define	RIF_RUN_PHY_CMDS	_IOW(RF_MAGIC, 5, struct rif_phy_cmd_set *)
+#define RIF_READ_RSSI		_IOR(RF_MAGIC, 6, __u32)
+#define RIF_READ_PHY_REGS	_IOR(RF_MAGIC, 7, struct rif_reg_buf *)
+#define RIF_READ_CTRL_REGS	_IOR(RF_MAGIC, 8, struct rif_reg_buf *)
+#define RIF_START		_IO(RF_MAGIC, 9)
+#define RIF_STOP		_IO(RF_MAGIC, 10)
+#define RIF_GET_DEV_INFO	_IOWR(RF_MAGIC, 11, struct rf_dev_info *)
+
+#endif
-- 
1.7.0

