From 448c91f40522cbb00442bd65f5d3ac7201598ba4 Mon Sep 17 00:00:00 2001
From: bhaskar upadhaya <Bhaskar.Upadhaya@freescale.com>
Date: Wed, 4 Jan 2012 16:19:23 +0000
Subject: [PATCH 68/92] rf: Add ptp_pps sync-source in time_sync framework

Extracted from 913x_WUSDK_REL_0.9.tar.gz vendor drop.

Provides the following features:
1. add ptp_pps as sync source, already existing sync sources are
   gps_pps, raw_gps
2. add support for displaying correction_mode in time_sync sysfs
   interface

Signed-off-by: Bhaskar Upadhaya <bhaskar.upadhaya@freescale.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/net/gianfar_1588.c       |    2 +-
 drivers/net/time_sync.c          |   89 +++++++++++++++++++++++++++----------
 drivers/net/time_sync.h          |    8 ---
 drivers/rf/controllers/fsl_aic.c |    5 +-
 drivers/rf/core/rfdev.c          |    1 +
 include/linux/rfdev_ioctl.h      |   28 +++++++++---
 6 files changed, 90 insertions(+), 43 deletions(-)

diff --git a/drivers/net/gianfar_1588.c b/drivers/net/gianfar_1588.c
index 4d725d3..b831068 100644
--- a/drivers/net/gianfar_1588.c
+++ b/drivers/net/gianfar_1588.c
@@ -692,7 +692,7 @@ u32 nominal_frequency(u32 sysclock_freq)
 
 int gfar_ptp_cal_attr(struct gfar_ptp_attr_t *ptp_attr)
 {
-	u32 *sysclock_freq, nominal_freq, tclk_period, *cksel = 0;
+	u32 *sysclock_freq, nominal_freq, tclk_period = 0, *cksel = 0;
 	struct device_node *np;
 
 	np = of_find_compatible_node(NULL, NULL, "fsl,gianfar-ptp-timer");
diff --git a/drivers/net/time_sync.c b/drivers/net/time_sync.c
index 65895a2..d25bebc 100644
--- a/drivers/net/time_sync.c
+++ b/drivers/net/time_sync.c
@@ -192,7 +192,7 @@ int do_time_sync_ioctl(struct net_device *dev, struct ifreq *ifr)
 	case TIMING_SYNC_INIT:
 		if (time_sync_priv) {
 			printk(KERN_INFO "time sync already"
-						" initialized !!!\r\n");
+						" initialized \r\n");
 			retval = -EEXIST;
 			goto err;
 		}
@@ -213,6 +213,7 @@ int do_time_sync_ioctl(struct net_device *dev, struct ifreq *ifr)
 			kfree(time_sync_priv);
 			goto err;
 		}
+		time_sync_data.lte_delay += 1000000;
 		memcpy(time_sync_priv->time_sync, &time_sync_data,
 					sizeof(struct time_sync_data));
 		priv->time_sync_priv = time_sync_priv;
@@ -236,7 +237,7 @@ int do_time_sync_ioctl(struct net_device *dev, struct ifreq *ifr)
 		break;
 	case TIMING_SYNC_STOP:
 		if (!time_sync_priv) {
-			printk(KERN_DEBUG "time sync not initialized !!!\r\n");
+			printk(KERN_DEBUG "time sync not initialized \r\n");
 			retval = -EINVAL;
 			goto err;
 		}
@@ -254,12 +255,15 @@ int do_time_sync_ioctl(struct net_device *dev, struct ifreq *ifr)
 			if (copy_to_user(ifr->ifr_data, &time_sync_data,
 					sizeof(struct time_sync_data)) > 0)
 				printk(KERN_ERR "Unable to copy time to user\r\n");
-			printk(KERN_DEBUG "time sync not initialized !!!\r\n");
+			printk(KERN_DEBUG "time sync not initialized \r\n");
 			retval = -EINVAL;
 			goto err;
 		}
 
 		sync_lock.condition = 0;
+		time_sync_priv->time_sync->time_info.state = GPS_NOT_COMMING;
+		time_sync_priv->time_sync->correction_mode =
+					time_sync_data.correction_mode;
 		wait_event_interruptible_timeout(time_sync_priv->wait_h,
 					sync_lock.condition, TIMEOUT * HZ);
 		schedule();
@@ -279,16 +283,39 @@ int do_time_sync_ioctl(struct net_device *dev, struct ifreq *ifr)
 		break;
 	case TIMING_SYNC_START:
 		time_sync = time_sync_priv->time_sync;
-		gfar_write(&(priv->ptimer->tmr_temask), TMR_TEMASK_ETS1 |
-			TMR_TEMASK_ALM1 |
-			TMR_TEMASK_ALM2 |
-			TMR_TEMASK_PP1);
-		time_sync_config_alarm(priv, &(priv->ptimer->tmr_alarm2_l),
-			&(priv->ptimer->tmr_alarm2_h),
-			time_sync_priv->time_sync->black_out_duration);
-		gfar_write(&priv->ptimer->tmr_ctrl,
-			gfar_read(&priv->ptimer->tmr_ctrl)
+		switch (time_sync->sync_source) {
+		case PPS_SRC_GPS:
+			gfar_write(&(priv->ptimer->tmr_temask),
+				TMR_TEMASK_ETS1 |
+				TMR_TEMASK_ALM1 |
+				TMR_TEMASK_ALM2 |
+				TMR_TEMASK_PP1);
+			time_sync_config_alarm(priv,
+				&(priv->ptimer->tmr_alarm2_l),
+				&(priv->ptimer->tmr_alarm2_h),
+				time_sync_priv->time_sync->black_out_duration);
+			gfar_write(&priv->ptimer->tmr_ctrl,
+					gfar_read(&priv->ptimer->tmr_ctrl)
+					| TMR_CTRL_ENABLE);
+			break;
+		case PPS_SRC_PTP:
+			gfar_write(&(priv->ptimer->tmr_temask),
+				TMR_TEMASK_ALM1 |
+				TMR_TEMASK_PP1);
+			time_sync_config_fiper(priv);
+			time_sync_config_alarm(priv,
+				&(priv->ptimer->tmr_alarm1_l),
+				&(priv->ptimer->tmr_alarm1_h),
+				time_sync_priv->time_sync->lte_delay / 1000000);
+			gfar_write(&priv->ptimer->tmr_ctrl,
+				gfar_read(&priv->ptimer->tmr_ctrl)
 				| TMR_CTRL_ENABLE);
+			break;
+		default:
+			printk(KERN_ERR "Invalid sync-source selected by user,"
+				" option is %d\n", time_sync->sync_source);
+			retval = -EINVAL;
+		}
 		break;
 	default:
 		printk(KERN_ERR "Invalid ioctl option selected by user,"
@@ -305,16 +332,15 @@ static irqreturn_t time_sync_isr(int irq, void *arg)
 	struct gfar_private *priv = (struct gfar_private *)arg;
 	struct time_sync_priv *time_sync_priv = priv->time_sync_priv;
 	struct timespec blackout_time;
-
-	if ((priv->ptimer->tmr_tevent & TMR_TEVENT_ETS1) ||
-	    (priv->ptimer->tmr_tevent & TMR_TEVENT_ETS2)) {
+	if ((priv->ptimer->tmr_tevent & TMR_TEVENT_ETS1) &&
+			(priv->ptimer->tmr_temask & TMR_TEMASK_ETS1)) {
 		gfar_write(&(priv->ptimer->tmr_tevent), TMR_TEVENT_ETS1);
 		if (time_sync_priv->first_gps == TRUE) {
 			time_sync_config_fiper(priv);
 			time_sync_config_alarm(priv,
 				&(priv->ptimer->tmr_alarm1_l),
 				&(priv->ptimer->tmr_alarm1_h),
-				time_sync_priv->time_sync->lte_delay);
+				time_sync_priv->time_sync->lte_delay / 1000000);
 			time_sync_priv->first_gps = FALSE;
 		}
 		time_sync_config_alarm(priv, &(priv->ptimer->tmr_alarm2_l),
@@ -329,7 +355,8 @@ static irqreturn_t time_sync_isr(int irq, void *arg)
 		time_sync_priv->stats.gps_cnt++;
 		sync_lock.condition = 1;
 		wake_up_all(&time_sync_priv->wait_h);
-	} else if (priv->ptimer->tmr_tevent & TMR_TEVENT_ALM2) {
+	} else if ((priv->ptimer->tmr_tevent & TMR_TEVENT_ALM2) &&
+			(priv->ptimer->tmr_temask & TMR_TEMASK_ALM2)) {
 		gfar_write(&(priv->ptimer->tmr_tevent), TMR_TEVENT_ALM2);
 		time_sync_priv->time_sync->time_info.state = GPS_PPS_BLACKOUT;
 		time_sync_priv->stats.alarm2_cnt++;
@@ -337,12 +364,14 @@ static irqreturn_t time_sync_isr(int irq, void *arg)
 		memcpy(&time_sync_priv->blackout_time, &blackout_time,
 						sizeof(struct timespec));
 		wake_up_all(&time_sync_priv->wait_h);
-	} else if (priv->ptimer->tmr_tevent & TMR_TEVENT_ALM1) {
+	} else if ((priv->ptimer->tmr_tevent & TMR_TEVENT_ALM1) &&
+			(priv->ptimer->tmr_temask & TMR_TEMASK_ALM1)) {
 		gfar_write(&(priv->ptimer->tmr_tevent), TMR_TEVENT_ALM1);
 		time_sync_priv->stats.alarm1_cnt++;
 	}
 
-	if (priv->ptimer->tmr_tevent & TMR_TEVENT_PP1) {
+	if ((priv->ptimer->tmr_tevent & TMR_TEVENT_PP1) &&
+			(priv->ptimer->tmr_temask & TMR_TEMASK_PP1)) {
 		gfar_write(&(priv->ptimer->tmr_tevent), TMR_TEVENT_PP1);
 		time_sync_priv->stats.fiper1_cnt++;
 		if (sync_lock.g_gps_cnt == time_sync_priv->stats.gps_cnt)
@@ -377,22 +406,34 @@ static ssize_t time_sync_show_sysfs(struct kobject *kobj,
 		switch (priv.time_sync->sync_source) {
 		case PPS_SRC_GPS:
 			return scnprintf(buf, BUFFER_SIZE,
-					"%s\n", GPS_SYNC_SRC);
+					"%s\n", GPS_PPS);
 		case PPS_SRC_RAW_GPS:
 			return scnprintf(buf, BUFFER_SIZE,
 					"%s\n", RAW_GPS);
 		case PPS_SRC_PTP:
 			return scnprintf(buf, BUFFER_SIZE,
-					"%s\n", PTP_SYNC_SRC);
+					"%s\n", PTP_PPS);
 		default:
 			return -EINVAL;
 		}
 	case CORRECTION_MODE:
-		return scnprintf(buf, BUFFER_SIZE, "%d\n",
-				priv.time_sync->correction_mode);
+		if (priv.time_sync->correction_mode & DAC) {
+			return scnprintf(buf, BUFFER_SIZE, "%s\n",
+						DAC_CORRECTION);
+			}
+		else if (priv.time_sync->correction_mode & ADDEND)
+			return scnprintf(buf, BUFFER_SIZE, "%s\n",
+						ADDEND_CORRECTION);
+		else if (priv.time_sync->correction_mode & DAC_ADDEND)
+			return scnprintf(buf, BUFFER_SIZE, "%s\n",
+						DAC_ADDEND_CORRECTION);
+		else
+			return scnprintf(buf, BUFFER_SIZE, "%s\n",
+						"undefined mode");
 	case LTE_DELAY:
 		return scnprintf(buf, BUFFER_SIZE, "%d %s\n",
-				priv.time_sync->lte_delay, "seconds");
+				priv.time_sync->lte_delay % 1000000,
+				"micro seconds");
 	case LAST_BLACKOUT_OCCURENCE:
 		return scnprintf(buf, BUFFER_SIZE, "%lu %s %lu %s\n",
 			(unsigned long)priv.blackout_time.tv_sec, "secs",
diff --git a/drivers/net/time_sync.h b/drivers/net/time_sync.h
index 9063a41..ad6ffb2 100644
--- a/drivers/net/time_sync.h
+++ b/drivers/net/time_sync.h
@@ -17,9 +17,6 @@
 typedef unsigned long long UInteger64;
 typedef unsigned int UInteger32;
 
-#define ADDEND_CORRECTION	0x01
-#define DAC_CORRECTION 		0x02
-#define ADDEND_DAC_CORRECTION	0x04
 #define TIMEOUT			4
 #define FIRST_GPS_PULSE		0x01
 
@@ -44,11 +41,6 @@ typedef unsigned int UInteger32;
 #define MAX_32_REG_LIMIT 0xffffffff
 #define OVERFLOW_LIMIT 223
 
-
-#define GPS_SYNC_SRC "gps_pps_refclk_in"
-#define RAW_GPS "raw_gps"
-#define PTP_SYNC_SRC "ptp synchronization"
-
 #define NSEC	((UInteger64)1000000000)
 #define	BOARD_TIME_TO_SEC(board_time)	((UInteger32)(board_time/NSEC))
 
diff --git a/drivers/rf/controllers/fsl_aic.c b/drivers/rf/controllers/fsl_aic.c
index 5903f1f..fad930a 100644
--- a/drivers/rf/controllers/fsl_aic.c
+++ b/drivers/rf/controllers/fsl_aic.c
@@ -78,7 +78,8 @@ static int aic_start(struct rf_ctrl_dev *rf_dev)
 	temp = SYNC_EN;
 
 	if ((rf_dev->timing_src == RF_PPS_SRC_GPS) ||
-		(rf_dev->timing_src == RF_PPS_SRC_RAW_GPS)) {
+		(rf_dev->timing_src == RF_PPS_SRC_RAW_GPS) ||
+		(rf_dev->timing_src == RF_PPS_SRC_PTP)) {
 		val |= GPS_EN;
 		temp |= GPS_EN;
 	}
@@ -191,8 +192,6 @@ static int aic_timing_source(struct rf_ctrl_dev *rf_dev, unsigned int src)
 	val = in_be32(&regs->aic_netw_conf1);
 	switch (src) {
 	case RF_PPS_SRC_GPS:
-		val |= PPS_TRIG_PPS;
-		break;
 	case RF_PPS_SRC_PTP:
 		val |= PPS_TRIG_PTP;
 		break;
diff --git a/drivers/rf/core/rfdev.c b/drivers/rf/core/rfdev.c
index 8737ef7..ca34add 100644
--- a/drivers/rf/core/rfdev.c
+++ b/drivers/rf/core/rfdev.c
@@ -424,6 +424,7 @@ int rf_fill_dev_info(struct rf_ctrl_dev *rf_dev, struct rf_dev_info *dev_info)
 	dev_info->net_mode = rf_dev->net_mode;
 	dev_info->tx_rxmode = rf_dev->tx_rxmode;
 	dev_info->bw = rf_dev->bw;
+	dev_info->timing_src = rf_dev->timing_src;
 
 	dev_info->ants = dev_params->ants;
 	dev_info->symbol_len = dev_params->symbol_len;
diff --git a/include/linux/rfdev_ioctl.h b/include/linux/rfdev_ioctl.h
index 8effcfa..440288e 100644
--- a/include/linux/rfdev_ioctl.h
+++ b/include/linux/rfdev_ioctl.h
@@ -48,6 +48,14 @@ enum rf_band_width {
 	BW_20_MHZ,
 	BW_END
 };
+
+enum rf_timer_src {
+	RF_PPS_SRC_GPS = 1,
+	RF_PPS_SRC_RAW_GPS,
+	RF_PPS_SRC_PTP,
+	RF_PPS_SRC_NLM
+};
+
 enum rf_state {
 	RF_CREATED,
 	RF_PHY_ATTACHED,
@@ -79,6 +87,7 @@ struct rf_dev_info {
 	enum rf_network_mode net_mode;
 	enum rf_txrxmode tx_rxmode;
 	enum rf_band_width bw;
+	enum rf_timer_src timing_src;
 	unsigned int ants;
 	unsigned int symbol_len;
 	unsigned int long_cp;
@@ -161,18 +170,23 @@ struct rf_rx_gain {
 	int gain_db;
 };
 
-enum rf_timer_src {
-	RF_PPS_SRC_GPS = 1,
-	RF_PPS_SRC_RAW_GPS,
-	RF_PPS_SRC_PTP,
-	RF_PPS_SRC_NLM
-};
-
 enum dac_correction_type {
 	FINE_CORRECTION = 1,
 	COARSE_CORRECTION,
 };
 
+#define DAC	0x00000001
+#define ADDEND  0x00000002
+#define DAC_ADDEND 0x00000004
+
+#define RAW_GPS "raw_gps"
+#define GPS_PPS "gps_pps"
+#define PTP_PPS "ptp_pps"
+
+#define DAC_CORRECTION "dac"
+#define ADDEND_CORRECTION "addend"
+#define DAC_ADDEND_CORRECTION "dac_addend"
+
 #define TIMING_SYNC_INIT	0x00000001
 #define TIMING_SYNC_START	0x00000002
 #define TIMING_SYNC_STOP	0x00000004
-- 
1.7.0

