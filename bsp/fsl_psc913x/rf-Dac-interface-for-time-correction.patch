From c7c039094e2502d875c63fdade31144150fbf676 Mon Sep 17 00:00:00 2001
From: bhaskar upadhaya <Bhaskar.Upadhaya@freescale.com>
Date: Thu, 1 Dec 2011 20:21:03 +0000
Subject: [PATCH 57/92] rf: Dac interface for time correction

Extracted from 913x_WUSDK_REL_0.9.tar.gz vendor drop.

provide the following features:
1. DAC interface for timing correction
2. interface to read the dac values

Signed-off-by: Bhaskar Upadhaya <bhaskar.upadhaya@freescale.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/net/time_sync.c     |    9 +++--
 drivers/net/time_sync.h     |   25 ----------------
 drivers/rf/core/rfdev.c     |   34 ++++++++++++++++++++--
 drivers/rf/phy/ad_phy.c     |   67 ++++++++++++++++++++++++++++++++++++++++++-
 drivers/rf/phy/ad_phy.h     |    7 ++++
 include/linux/rfdev.h       |    5 ++-
 include/linux/rfdev_ioctl.h |   44 +++++++++++++++++++++++++++-
 7 files changed, 155 insertions(+), 36 deletions(-)

diff --git a/drivers/net/time_sync.c b/drivers/net/time_sync.c
index 0590929..65895a2 100644
--- a/drivers/net/time_sync.c
+++ b/drivers/net/time_sync.c
@@ -21,6 +21,7 @@
 #include <linux/wait.h>
 #include <linux/of.h>
 #include <linux/of_platform.h>
+#include <linux/rfdev_ioctl.h>
 #include "time_sync.h"
 #include "gianfar.h"
 
@@ -188,7 +189,7 @@ int do_time_sync_ioctl(struct net_device *dev, struct ifreq *ifr)
 	}
 
 	switch (time_sync_data.ioctl_cmd) {
-	case TIME_SYNC_INIT:
+	case TIMING_SYNC_INIT:
 		if (time_sync_priv) {
 			printk(KERN_INFO "time sync already"
 						" initialized !!!\r\n");
@@ -233,7 +234,7 @@ int do_time_sync_ioctl(struct net_device *dev, struct ifreq *ifr)
 			goto err;
 		}
 		break;
-	case TIME_SYNC_STOP:
+	case TIMING_SYNC_STOP:
 		if (!time_sync_priv) {
 			printk(KERN_DEBUG "time sync not initialized !!!\r\n");
 			retval = -EINVAL;
@@ -247,7 +248,7 @@ int do_time_sync_ioctl(struct net_device *dev, struct ifreq *ifr)
 		time_sync_sysfs_exit(priv->time_sync_priv->time_sync_kobj);
 		time_sync_free(priv);
 		break;
-	case TIME_SYNC_GET_TIME:
+	case TIMING_SYNC_GET_TIME:
 		if (!time_sync_priv) {
 			time_sync_data.time_info.state = TIME_SYNC_NOT_STARTED;
 			if (copy_to_user(ifr->ifr_data, &time_sync_data,
@@ -276,7 +277,7 @@ int do_time_sync_ioctl(struct net_device *dev, struct ifreq *ifr)
 			goto err;
 		}
 		break;
-	case TIME_SYNC_START:
+	case TIMING_SYNC_START:
 		time_sync = time_sync_priv->time_sync;
 		gfar_write(&(priv->ptimer->tmr_temask), TMR_TEMASK_ETS1 |
 			TMR_TEMASK_ALM1 |
diff --git a/drivers/net/time_sync.h b/drivers/net/time_sync.h
index 1d05761..9063a41 100644
--- a/drivers/net/time_sync.h
+++ b/drivers/net/time_sync.h
@@ -23,11 +23,6 @@ typedef unsigned int UInteger32;
 #define TIMEOUT			4
 #define FIRST_GPS_PULSE		0x01
 
-#define TIME_SYNC_INIT		0x00000001
-#define TIME_SYNC_START		0x00000002
-#define TIME_SYNC_STOP		0x00000004
-#define TIME_SYNC_GET_TIME	0x00000010
-
 #define TMR_TEVENT_ETS2		0x02000000
 #define TMR_TEVENT_ETS1		0x01000000
 #define TMR_TEVENT_ALM2		0x00020000
@@ -110,26 +105,6 @@ struct time_sync_priv {
 	struct timespec blackout_time;
 };
 
-struct time_sync_1588_cnt {
-	u32 high;
-	u32 low;
-};
-
-struct time_info {
-	struct time_sync_1588_cnt time_cnt;
-	u64 board_time;
-	u32 state;
-};
-
-struct time_sync_data {
-	u8 correction_mode;
-	u8 sync_source;
-	u32 lte_delay;
-	u32 ioctl_cmd;
-	u32 black_out_duration;
-	struct time_info time_info;
-};
-
 struct time_sync_sysfs {
 	struct attribute attr;
 	char data[BUFFER_SIZE];
diff --git a/drivers/rf/core/rfdev.c b/drivers/rf/core/rfdev.c
index b55a486..8cf2e46 100644
--- a/drivers/rf/core/rfdev.c
+++ b/drivers/rf/core/rfdev.c
@@ -394,6 +394,8 @@ static int rf_ioctl(struct inode *inode, struct file *filep,
 	struct rif_phy_cmd_set cmd_set;
 	struct rif_reg_buf reg_buf;
 	struct rif_write_reg_buf write_phy_buf;
+	struct rif_dac_params dac_params;
+	struct rif_dac_buf dac_buff;
 	struct rf_dev_info dev_info;
 	u32	*buf;
 	u32 u32arg;
@@ -448,13 +450,39 @@ static int rf_ioctl(struct inode *inode, struct file *filep,
 			goto out;
 		}
 
-		if (!get_user(u32arg, (int *)arg)) {
-			if (phy && phy->ops->set_timer_correction)
+		if (!copy_from_user(&dac_params, (struct rif_dac_params *)arg,
+			sizeof(struct rif_dac_params))) {
+
+			if (phy && phy->ops->set_timer_correction) {
 				rc = phy->ops->set_timer_correction(phy,
-							u32arg);
+						&dac_params);
+			}
+		} else {
+			rc = -EFAULT;
+		}
+
+		break;
+
+	case RIF_GET_DAC_VALUE:
+
+		if (rf_dev->state < RF_PHY_ATTACHED) {
+			rc = -EAGAIN;
+			goto out;
+		}
+
+		if (!copy_from_user(&dac_buff, (struct rif_dac_buf *)arg,
+			sizeof(struct rif_dac_buf))) {
+
+			if (phy && phy->ops->read_dac_value) {
+				rc = phy->ops->read_dac_value(phy,
+					dac_buff.correction_type, &u32arg);
+			}
+			if (copy_to_user(dac_buff.buf, &u32arg, sizeof(u32arg)))
+				rc = -EFAULT;
 		} else {
 			rc = -EFAULT;
 		}
+
 		break;
 
 	case RIF_RUN_PHY_CMDS:
diff --git a/drivers/rf/phy/ad_phy.c b/drivers/rf/phy/ad_phy.c
index 6c1523f..827c882 100644
--- a/drivers/rf/phy/ad_phy.c
+++ b/drivers/rf/phy/ad_phy.c
@@ -56,13 +56,18 @@ static int ad_phy_run_cmds(struct rf_phy_dev *ad_phy, struct rif_phy_cmd *cmds,
 static int ad_phy_read(struct rf_phy_dev *ad_phy, u32 start, u32 count,
 		u32 *buff);
 static int ad_phy_write(struct rf_phy_dev *ad_phy, u32 reg, u32 data);
+static int ad_phy_dac_correction(struct rf_phy_dev *ad_phy,
+					struct rif_dac_params *params);
+static int ad_phy_get_dac_value(struct rf_phy_dev *ad_phy,
+					u32 correction_type, u32 *buff);
 static int ad_phy_start(struct rf_phy_dev *ad_phy);
 static int ad_init(struct rf_phy_dev *phy, struct rf_init_params *params);
 static int ad_phy_stop(struct rf_phy_dev *phy);
 
 static struct rf_phy_ops ad_phy_ops = {
 	.init = ad_init,
-	.set_timer_correction = NULL,
+	.set_timer_correction = ad_phy_dac_correction,
+	.read_dac_value = ad_phy_get_dac_value,
 	.run_cmds = ad_phy_run_cmds,
 	.read_regs = ad_phy_read,
 	.write_reg = ad_phy_write,
@@ -343,6 +348,66 @@ int ad_phy_write(struct rf_phy_dev *ad_phy, u32 reg,
 	return 0;
 }
 
+int ad_phy_get_dac_value(struct rf_phy_dev *ad_phy,
+			u32 correction_type , u32 *buff)
+{
+	u32 cmd = 0, reg = 0;
+	u8 data_rcvd;
+	u32 data;
+	int i = 0;
+	struct ad_dev_info *phy_info = ad_phy->priv;
+	struct device *dev = &phy_info->ad_spi->dev;
+
+	dev_dbg(dev, "DAC's register read call.\n");
+	switch (correction_type) {
+	case COARSE_CORRECTION:
+		reg = DAC1_CONFIG;
+		break;
+	case FINE_CORRECTION:
+		reg = DAC1_WORD;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	cmd = create_ad_phy_cmd((unsigned long)reg, SPI_READ, 1);
+	cmd = (cmd << 16) & COMMAND_MASK;
+	data_rcvd = spi_read_transaction(ad_phy, (u8 *)&cmd,
+			TRANSACTION_BYTES);
+	dev_dbg(dev, "Read from reg: %x\n", reg);
+	data = data_rcvd;
+	buff[i] = data;
+
+	return 0;
+}
+
+int ad_phy_dac_correction(struct rf_phy_dev *ad_phy,
+			struct rif_dac_params *dac_params)
+{
+	u32 cmd = 0, reg = 0;
+	struct ad_dev_info *phy_info = ad_phy->priv;
+	struct device *dev = &phy_info->ad_spi->dev;
+
+	dev_dbg(dev, "DAC's register write call.\n");
+	switch (dac_params->correction_type) {
+	case COARSE_CORRECTION:
+		reg = DAC1_CONFIG;
+		break;
+	case FINE_CORRECTION:
+		reg = DAC1_WORD;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	cmd = create_ad_phy_cmd((unsigned long)reg, SPI_WRITE, 1);
+	cmd = (cmd << 16) & COMMAND_MASK;
+	cmd = cmd | (dac_params->correction_value << 8);
+	spi_write_transaction(ad_phy, (u8 *)&cmd, TRANSACTION_BYTES);
+
+	return 0;
+}
+
 static int ad_phy_remove(struct spi_device *spi)
 {
 	int ret = 0;
diff --git a/drivers/rf/phy/ad_phy.h b/drivers/rf/phy/ad_phy.h
index 6cdb493..2dcf264 100644
--- a/drivers/rf/phy/ad_phy.h
+++ b/drivers/rf/phy/ad_phy.h
@@ -34,6 +34,13 @@
 #define REV0 0x08
 #define REV2 0x0a
 
+/*
+ * 24 = 0x18 which is the AuxDAC1 word address
+ * 26 = 0x1A which is the AuxDAC1 config address
+ */
+#define DAC1_WORD 	24
+#define DAC1_CONFIG  	26
+
 struct ad_dev_info {
 	struct spi_device *ad_spi;
 	u8 rx_buf[10];
diff --git a/include/linux/rfdev.h b/include/linux/rfdev.h
index 693fbfb..f9f1171 100644
--- a/include/linux/rfdev.h
+++ b/include/linux/rfdev.h
@@ -74,7 +74,10 @@ struct rf_phy_ops {
 				struct rf_init_params *params);
 
 	int	(*set_timer_correction)(struct rf_phy_dev *phy,
-			 u32 correction); /*XXX: API is not final*/
+			 struct rif_dac_params *params);
+
+	int	(*read_dac_value)(struct rf_phy_dev *phy,
+				u32 correction_type, u32 *buf);
 
 	int	(*run_cmds)(struct rf_phy_dev *phy,
 				struct rif_phy_cmd *cmds, int count);
diff --git a/include/linux/rfdev_ioctl.h b/include/linux/rfdev_ioctl.h
index f2e2de1..3060281 100644
--- a/include/linux/rfdev_ioctl.h
+++ b/include/linux/rfdev_ioctl.h
@@ -106,20 +106,58 @@ struct rif_write_reg_buf {
 	__u32 data;
 };
 
+struct time_sync_1588_cnt {
+	__u32 high;
+	__u32 low;
+};
+
+struct time_info {
+	struct time_sync_1588_cnt time_cnt;
+	__u64 board_time;
+	__u32 state;
+};
+
+struct time_sync_data {
+	__u8 correction_mode;
+	__u8 sync_source;
+	__u32 lte_delay;
+	__u32 ioctl_cmd;
+	__u32 black_out_duration;
+	struct time_info time_info;
+};
+
+struct rif_dac_params {
+	__u32	correction_type;
+	__u32	correction_value;
+};
+
+struct rif_dac_buf {
+	__u32 correction_type;
+	__u32 *buf;
+};
 
 enum rf_timer_src {
-	RF_PPS_SRC_GPS,
+	RF_PPS_SRC_GPS = 1,
 	RF_PPS_SRC_RAW_GPS,
 	RF_PPS_SRC_PTP,
 	RF_PPS_SRC_NLM
 };
 
+enum dac_correction_type {
+	FINE_CORRECTION = 1,
+	COARSE_CORRECTION,
+};
+
+#define TIMING_SYNC_INIT	0x00000001
+#define TIMING_SYNC_START	0x00000002
+#define TIMING_SYNC_STOP	0x00000004
+#define TIMING_SYNC_GET_TIME	0x00000010
 
 #define RF_MAGIC 'R'
 #define RIF_DEV_INIT		_IOWR(RF_MAGIC, 1, struct rf_init_params*)
 #define RIF_SET_TIMER_SOURCE	_IOW(RF_MAGIC, 2, unsigned int)
 #define RIF_GET_STATE		_IOR(RF_MAGIC, 3, unsigned int)
-#define RIF_SET_TIMER_CORRECTION _IOW(RF_MAGIC, 4, unsigned int)
+#define RIF_SET_TIMER_CORRECTION _IOW(RF_MAGIC, 4, struct rif_dac_params *)
 #define	RIF_RUN_PHY_CMDS	_IOW(RF_MAGIC, 5, struct rif_phy_cmd_set *)
 #define RIF_READ_RSSI		_IOR(RF_MAGIC, 6, __u32)
 #define RIF_READ_PHY_REGS	_IOR(RF_MAGIC, 7, struct rif_reg_buf *)
@@ -128,6 +166,8 @@ enum rf_timer_src {
 #define RIF_STOP		_IO(RF_MAGIC, 10)
 #define RIF_GET_DEV_INFO	_IOWR(RF_MAGIC, 11, struct rf_dev_info *)
 #define RIF_WRITE_PHY_REGS _IOR(RF_MAGIC, 12, struct rif_write_reg_buf *)
+#define RIF_GET_DAC_VALUE	_IOR(RF_MAGIC, 13, struct rif_dac_buf *)
+
 
 
 #endif
-- 
1.7.0

