From 26fa6479b8af45907cee5fdb5336a44b58db9396 Mon Sep 17 00:00:00 2001
From: Shaveta Leekha <shaveta@freescale.com>
Date: Wed, 19 Oct 2011 15:04:11 +0000
Subject: [PATCH 49/92] rf: Add support for setting/resetting GPIOs from driver

Extracted from 913x_WUSDK_REL_0.9.tar.gz vendor drop.

1)GPIO2 is being toggled to reset the AD9361 device.
2)GPIO17 & 18 are set to value 0/1 based on the frequency band
  passed by user, for AD9361 device to work as intended.

Signed-off-by: Shaveta Leekha <shaveta@freescale.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/rf/phy/ad_phy.c     |  128 +++++++++++++++++++++++++++++++++----------
 drivers/rf/phy/ad_phy.h     |    2 +
 include/linux/rfdev_ioctl.h |    6 ++
 3 files changed, 106 insertions(+), 30 deletions(-)

diff --git a/drivers/rf/phy/ad_phy.c b/drivers/rf/phy/ad_phy.c
index b593286..36edd7f 100644
--- a/drivers/rf/phy/ad_phy.c
+++ b/drivers/rf/phy/ad_phy.c
@@ -34,6 +34,8 @@
 #include <linux/delay.h>
 #include <linux/of.h>
 #include <linux/io.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio.h>
 #include <linux/rfdev.h>
 #include <linux/string.h>
 #include "ad_phy.h"
@@ -42,6 +44,10 @@
 #define DRV_NAME "ad9361_phy"
 #define DEBUG
 
+/* To check where reset gpio has been toggled to
+ * reset AD PHY device or not. */
+bool reset_status;
+
 MODULE_LICENSE("GPL v2");
 MODULE_DESCRIPTION(DRV_DESC);
 
@@ -66,11 +72,6 @@ static struct rf_phy_ops ad_phy_ops = {
 };
 
 
-/*
- * Function to create AD9361 instruction/command word.
- * AD9361 controller take command of 16 bits followed by
- * data. This command would be send to AD9361 via SPI.
- */
 u16 create_ad_phy_cmd(u16 reg, int opcode)
 {
 	u16 cmd_word;
@@ -95,10 +96,6 @@ u16 create_ad_phy_cmd(u16 reg, int opcode)
 	return cmd_word;
 }
 
-/*
- * Function to execute write operation on device
- * using SPI interface to write into some ad9361 register
- */
 static int spi_write_transaction(struct rf_phy_dev *ad_phy, u8 *buf, int len)
 {
 	u8 *tx_buf;
@@ -126,10 +123,6 @@ static int spi_write_transaction(struct rf_phy_dev *ad_phy, u8 *buf, int len)
 	return 0;
 }
 
-/*
- * Function to execute read operation of device
- * using SPI interface to read ad9361 register.
- */
 static u8 spi_read_transaction(struct rf_phy_dev *ad_phy, u8 *buf, int len)
 {
 	struct ad_dev_info *phy_info = ad_phy->priv;
@@ -160,10 +153,6 @@ static u8 spi_read_transaction(struct rf_phy_dev *ad_phy, u8 *buf, int len)
 	return data;
 }
 
-/*
- * This function checks the BBPLL locked status, as that is required
- * for device to work properly.
- */
 static int check_bbpll_lock(struct rf_phy_dev *ad_phy)
 {
 	struct ad_dev_info *phy_info = ad_phy->priv;
@@ -251,6 +240,27 @@ int ad_phy_run_cmds(struct rf_phy_dev *ad_phy,
 int ad_init(struct rf_phy_dev *ad_phy,
 		struct rf_init_params *params)
 {
+	struct ad_dev_info *phy_info = ad_phy->priv;
+
+	if (phy_info->gpio_count) {
+		switch (params->fq_band) {
+		case LTE_BAND1:
+			/*Setting GPIO17 and 18 to 0 for HB.*/
+			gpio_set_value(phy_info->gpios[1], 0);
+			gpio_set_value(phy_info->gpios[2], 0);
+			break;
+
+		case LTE_BAND13:
+			/*Setting GPIO17 and 18 to 1 for LB.*/
+			gpio_set_value(phy_info->gpios[1], 1);
+			gpio_set_value(phy_info->gpios[2], 1);
+			break;
+
+		default:
+			return -EINVAL;
+		}
+	}
+
 	return 0;
 }
 
@@ -259,12 +269,6 @@ int ad_phy_stop(struct rf_phy_dev *ad_phy)
 	return 0;
 }
 
-/*
- * This is called as a start routine of PHY device.
- * It internally checks whenever phy device is functional or not,
- * by checking the BBPLL locked status, as that is required
- * for device to start properly
- */
 int ad_phy_start(struct rf_phy_dev *ad_phy)
 {
 	struct ad_dev_info *phy_info = ad_phy->priv;
@@ -275,9 +279,6 @@ int ad_phy_start(struct rf_phy_dev *ad_phy)
 	return check_bbpll_lock(ad_phy);
 }
 
-/*
- * This is called whenever a process attempts to read from the device
- */
 int ad_phy_read(struct rf_phy_dev *ad_phy, u32 start,
 		u32 count, u32 *buff)
 {
@@ -306,9 +307,6 @@ int ad_phy_read(struct rf_phy_dev *ad_phy, u32 start,
 	return 0;
 }
 
-/*
- * This is called whenever a process attempts to write to the device
- */
 int ad_phy_write(struct rf_phy_dev *ad_phy, u32 reg,
 		u32 data)
 {
@@ -329,11 +327,18 @@ int ad_phy_write(struct rf_phy_dev *ad_phy, u32 reg,
 static int ad_phy_remove(struct spi_device *spi)
 {
 	int ret = 0;
+	int i;
 	struct device *dev = &spi->dev;
 	struct rf_phy_dev *ad_phy = dev_get_drvdata(&spi->dev);
+	struct ad_dev_info *phy_info = ad_phy->priv;
 
 	dev_dbg(dev, "AD9361 PHY module uninstalled\n");
 
+	for (i = 0; i < phy_info->gpio_count; i++)
+		gpio_free(phy_info->gpios[i]);
+
+	kfree(phy_info->gpios);
+
 	ret = unregister_rf_phy_dev(ad_phy);
 	if (ret < 0) {
 		dev_dbg(dev, "unregister_rf_phy_dev failed.\n");
@@ -366,8 +371,9 @@ static u8 read_revision_code(struct rf_phy_dev *ad_phy)
 
 static int ad_phy_probe(struct spi_device *spi)
 {
-	int ret = 0;
+	int i, ret = 0;
 	u8 rev;
+	int gpio, gpio_num;
 	static struct rf_phy_dev *ad_phy;
 	struct device *dev = &spi->dev;
 	struct ad_dev_info *phy_info;
@@ -389,6 +395,61 @@ static int ad_phy_probe(struct spi_device *spi)
 	strncpy(&ad_phy->name[0], "ad9361", sizeof(ad_phy->name));
 	ad_phy->phy_id = (u32) np;
 
+	gpio_num = of_gpio_count(np);
+
+	if (gpio_num > 0) {
+		phy_info->gpio_count = gpio_num;
+		phy_info->gpios = (int *)kmalloc(gpio_num * sizeof(int),
+					GFP_KERNEL);
+		if (!phy_info->gpios) {
+			dev_dbg(dev, "Failed to allocate memory for gpios.\n");
+			ret = -ENOMEM;
+			goto out;
+		}
+
+		for (i = 0; i < gpio_num; i++) {
+			gpio = of_get_gpio(np, i);
+			dev_dbg(dev, "of_get_gpio returns:%d\n", gpio);
+
+			if (gpio < 0) {
+				dev_dbg(dev, "could not parse the gpio field "
+					"in ad_phy node of tree\n");
+				ret = gpio;
+				/* gpio contains the actual
+				   errno returned by of_get_gpio.*/
+				goto err_gpio;
+			}
+
+			ret = gpio_request(gpio, dev_name(dev));
+			if (ret) {
+				dev_dbg(dev, "can't request spi cs gpio #%d "
+					"on gpio line %d\n", i, gpio);
+				goto err_gpio;
+			}
+
+			ret = gpio_direction_output(gpio, 0);
+			if (ret) {
+				dev_dbg(dev,
+					"gpio_direction_output failed"
+					"for gpio:%d\n", gpio);
+				goto err_gpio;
+			}
+
+			phy_info->gpios[i] = gpio;
+		}
+	} else {
+		dev_dbg(dev, "No gpio found, cannot reset AD phy device.\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	if (!reset_status) {
+		/* Toggle GPIO34 to reset AD9361 device.*/
+		gpio_set_value(phy_info->gpios[0], 0);
+		gpio_set_value(phy_info->gpios[0], 1);
+		reset_status = true;
+	}
+
 	dev_set_drvdata(&spi->dev, ad_phy);
 
 	/* Read and check Revision Code of the device */
@@ -407,6 +468,13 @@ static int ad_phy_probe(struct spi_device *spi)
 	}
 
 	return ret;
+
+err_gpio:
+	while (i-- > 0)
+		gpio_free(phy_info->gpios[i]);
+
+	kfree(phy_info->gpios);
+
 out:
 	free_rf_phy_dev(ad_phy);
 	return ret;
diff --git a/drivers/rf/phy/ad_phy.h b/drivers/rf/phy/ad_phy.h
index b4af33f..a94bed2 100644
--- a/drivers/rf/phy/ad_phy.h
+++ b/drivers/rf/phy/ad_phy.h
@@ -37,6 +37,8 @@
 struct ad_dev_info {
 	struct spi_device *ad_spi;
 	u8 rx_buf[4];
+	int gpio_count;
+	int *gpios;
 };
 
 #endif /* AD_PHY_H */
diff --git a/include/linux/rfdev_ioctl.h b/include/linux/rfdev_ioctl.h
index ab87dd5..f2e2de1 100644
--- a/include/linux/rfdev_ioctl.h
+++ b/include/linux/rfdev_ioctl.h
@@ -21,6 +21,11 @@
 #define RIF_NAME_SIZE	20
 #define RF_MAX_DEVS	6
 
+enum rf_phy_band {
+	LTE_BAND1,
+	LTE_BAND13
+};
+
 enum rf_network_mode {
 	LTE_TDD,
 	LTE_FDD,
@@ -58,6 +63,7 @@ struct rf_init_params {
 	enum rf_network_mode mode;
 	enum rf_txrxmode tx_rxmode;
 	enum rf_band_width bw;
+	enum rf_phy_band fq_band;
 	unsigned int long_cp;
 	unsigned int ants;
 };
-- 
1.7.0

