From 1c03608e7f556cb2450872d0f5ae07270e008ac0 Mon Sep 17 00:00:00 2001
From: Jiang Bin <bin.jiang@windriver.com>
Date: Sun, 29 Jan 2012 17:37:47 +0800
Subject: [PATCH 52/92] rf: time_sync - Add ioctl callback routines

Extracted from 913x_WUSDK_REL_0.9.tar.gz vendor drop.

time sync utility provides an interface to the user-space application to
configure eTSEC 1588 block for following features
 1.start/stop time sync utility
 2.configure fiper
 3.1588 enable interface
 4.configure alarm

Signed-off-by: Bhaskar Upadhaya <bhaskar.upadhaya@freescale.com>

[Remove TRUE/FALSE enum which have been defined]

Signed-off-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/net/gianfar.c      |    3 +-
 drivers/net/gianfar.h      |   17 +++-
 drivers/net/gianfar_1588.c |    5 +-
 drivers/net/time_sync.c    |  242 ++++++++++++++++++++++++++++++++++++++++++++
 drivers/net/time_sync.h    |  141 +++++++++++++++++++++++++
 5 files changed, 405 insertions(+), 3 deletions(-)
 create mode 100644 drivers/net/time_sync.c
 create mode 100644 drivers/net/time_sync.h

diff --git a/drivers/net/gianfar.c b/drivers/net/gianfar.c
index 7930a01..86e49f2 100644
--- a/drivers/net/gianfar.c
+++ b/drivers/net/gianfar.c
@@ -1002,7 +1002,7 @@ static int gfar_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 		return -ENODEV;
 
 	if ((cmd >= PTP_GET_RX_TIMESTAMP_SYNC) &&
-			(cmd <= PTP_CLEANUP_TIMESTAMP_BUFFERS)) {
+			(cmd <= PTP_TIMESYNC_IOCTL)) {
 		if (priv->ptimer_present)
 			retVal = gfar_ioctl_1588(dev, rq, cmd);
 		else
@@ -4525,6 +4525,7 @@ static struct of_platform_driver gfar_driver = {
 static int __init gfar_init(void)
 {
 	gfar_1588_node_init(gfar_match, sizeof(gfar_match));
+	gfar_1588_time_sync_init();
 	return of_register_platform_driver(&gfar_driver);
 }
 
diff --git a/drivers/net/gianfar.h b/drivers/net/gianfar.h
index 2c2bbcb..aff3c53 100644
--- a/drivers/net/gianfar.h
+++ b/drivers/net/gianfar.h
@@ -157,6 +157,7 @@ static inline int devfp_register_tx_hook(devfp_hook_t hook)
 #define PTP_GET_RX_TIMESTAMP_PDELAY_REQ	(SIOCDEVPRIVATE + 11)
 #define PTP_GET_RX_TIMESTAMP_PDELAY_RESP	(SIOCDEVPRIVATE + 12)
 #define PTP_CLEANUP_TIMESTAMP_BUFFERS	(SIOCDEVPRIVATE + 13)
+#define PTP_TIMESYNC_IOCTL		(SIOCDEVPRIVATE + 14)
 #define DEFAULT_PTP_RX_BUF_SZ		2000
 #define GFAR_PTP_CTRL_SYNC		0x0
 #define GFAR_PTP_CTRL_DEL_REQ		0x1
@@ -638,11 +639,15 @@ static inline int devfp_register_tx_hook(devfp_hook_t hook)
 /* 1588 Module Registers bits */
 #define TMR_CTRL_ENABLE		0x00000004
 #define TMR_ADD_VAL		CONFIG_GFAR_PTP_TMR_ADD
+#define TMR_CTRL_EXT_CLK	0x00000001
+#define TMR_CTRL_SYS_CLK	0x00000000
+#define TMR_CTRL_ETEP1		0x00000100
+#define TMR_CTRL_ETEP2		0x00000200
 #define TMR_CTRL_TCLK_MASK	0x03ff0000
 #define TMR_PTPD_MAX_FREQ	0x80000
 #define TMR_CTRL_FIPER_START	0x10000000
 #define PPS_1588	1
-#define ONE_GIGA	1000000000
+#define ONE_GIGA	1000000000u
 #define GFAR_1588_PROCFS_MAX_SIZE         12
 #define GFAR_1588_PROCFS_NAME           "ptp_1588"
 
@@ -1339,6 +1344,7 @@ struct gfar_private {
 	struct gfar_regs_1588 __iomem *ptimer;
 	struct resource timer_resource;
 	uint32_t ptimer_present;
+	struct time_sync_priv *time_sync_priv;
 #ifdef CONFIG_GIANFAR_L2SRAM
 	int bd_in_ram;
 #endif
@@ -1364,6 +1370,13 @@ struct gfar_node_info_t {
 	int match_cnt;
 };
 
+enum {
+	EXTERNAL_SRC,
+	ETSEC_SYS_CLK,
+	ETSEC1_TX_CLK,
+	RTC_CLK
+};
+
 extern unsigned int ftp_rqfpr[MAX_FILER_IDX + 1];
 extern unsigned int ftp_rqfcr[MAX_FILER_IDX + 1];
 
@@ -1429,8 +1442,10 @@ extern void gfar_configure_rx_coalescing(struct gfar_private *priv,
 					long unsigned int rx_mask);
 void gfar_init_sysfs(struct net_device *dev);
 
+extern int gfar_ptp_cal_attr(struct gfar_ptp_attr_t *ptp_attr);
 extern void gfar_1588_node_init(struct of_device_id *dev_id, int cnt);
 extern void gfar_1588_proc_init(void);
+extern void gfar_1588_time_sync_init(void);
 extern void gfar_1588_proc_exit(void);
 extern const struct ethtool_ops gfar_ethtool_ops;
 
diff --git a/drivers/net/gianfar_1588.c b/drivers/net/gianfar_1588.c
index c5cb5c1..6b329b1 100644
--- a/drivers/net/gianfar_1588.c
+++ b/drivers/net/gianfar_1588.c
@@ -19,6 +19,7 @@
 #include <linux/vmalloc.h>
 #include <linux/of.h>
 #include "gianfar.h"
+#include "time_sync.h"
 #include <linux/of_platform.h>
 
 #if defined(CONFIG_1588_MUX_eTSEC1) || defined(CONFIG_1588_MUX_eTSEC2)
@@ -40,7 +41,6 @@ static int gfar_ptp_insert(struct gfar_ptp_circular_t *buf,
 static int gfar_ptp_find_and_remove(struct gfar_ptp_circular_t *buf,
 			int key, struct gfar_ptp_data_t *data);
 static u32 nominal_frequency(u32 sysclock_freq);
-static int gfar_ptp_cal_attr(struct gfar_ptp_attr_t *ptp_attr);
 
 static DECLARE_WAIT_QUEUE_HEAD(ptp_rx_ts_wait);
 #define PTP_GET_RX_TIMEOUT	(HZ/10)
@@ -128,6 +128,7 @@ int gfar_ptp_init(struct gfar_private *priv)
 			gfar_ptp_init_circ(&(priv->rx_time_pdel_req)) ||
 			gfar_ptp_init_circ(&(priv->rx_time_pdel_resp)))
 		return 1;
+	priv->time_sync_priv = NULL;
 	return 0;
 }
 
@@ -532,6 +533,8 @@ int gfar_ioctl_1588(struct net_device *dev, struct ifreq *ifr, int cmd)
 		priv->rx_time_pdel_resp.end = 0;
 		priv->rx_time_pdel_resp.size = (DEFAULT_PTP_RX_BUF_SZ + 1);
 		break;
+	case PTP_TIMESYNC_IOCTL:
+		return do_time_sync_ioctl(dev, ifr);
 	default:
 		return -EINVAL;
 	}
diff --git a/drivers/net/time_sync.c b/drivers/net/time_sync.c
new file mode 100644
index 0000000..32e7bbe
--- /dev/null
+++ b/drivers/net/time_sync.c
@@ -0,0 +1,242 @@
+/*
+ * drivers/net/time_sync.c
+ * Freescale time-sync utility
+ *
+ * Time sync utility provides an interface to correct and synchronize the
+ * clock source for an SoC with an atomic clock like GPS, PTP master
+ * and NTP server.
+ *
+ * Author: bhaskar upadhaya <bhaskar.upadhaya@freescale.com>
+ *
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/skbuff.h>
+#include <net/sock.h>
+#include <linux/wait.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include "time_sync.h"
+#include "gianfar.h"
+
+static int time_sync_priv(struct time_sync_priv *time_sync_priv);
+static void time_sync_free(struct gfar_private *priv);
+static void time_sync_config_fiper(struct gfar_private *priv);
+struct time_sync_lock sync_lock;
+
+static void time_sync_free(struct gfar_private *priv)
+{
+	if (priv->time_sync_priv->time_sync)
+		kfree(priv->time_sync_priv->time_sync);
+	if (priv->time_sync_priv)
+		kfree(priv->time_sync_priv);
+	priv->time_sync_priv = NULL;
+}
+
+static void time_sync_config_fiper(struct gfar_private *priv)
+{
+	struct gfar_ptp_attr_t ptp_attr;
+	struct device_node *np;
+	u32 *tmr_prsc = 0;
+
+	memset(&ptp_attr, 0, sizeof(struct gfar_ptp_attr_t));
+
+	if (gfar_ptp_cal_attr(&ptp_attr))
+		return;
+
+	gfar_write(&priv->ptimer->tmr_ctrl,
+			gfar_read(&priv->ptimer->tmr_ctrl)
+			& ~TMR_CTRL_ENABLE);
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,gianfar-ptp-timer");
+	if (np == NULL)	{
+		printk(KERN_ERR "1588: Cannot find"
+				" gianfar-ptp-timer node\n");
+		return;
+	}
+
+	tmr_prsc = (u32 *)of_get_property(np, "tmr-prsc", NULL);
+	if (tmr_prsc == NULL) {
+		printk(KERN_ERR "1588: Cannot find tmr-prsc property\n");
+		return;
+	}
+
+	gfar_write(&(priv->ptimer->tmr_prsc), *tmr_prsc);
+	gfar_write(&(priv->ptimer->tmr_fiper1), EXTERNAL_CLK_FREQ
+		 - (ptp_attr.tclk_period>>16));
+
+	/* Need to mask the TCLK bits as they are initialized with 1 */
+	gfar_write(&(priv->ptimer->tmr_ctrl),
+		(gfar_read(&(priv->ptimer->tmr_ctrl))
+			 & ~TMR_CTRL_TCLK_MASK) | (ptp_attr.tclk_period));
+	gfar_write(&(priv->ptimer->tmr_ctrl),
+		gfar_read(&(priv->ptimer->tmr_ctrl)) |
+		TMR_CTRL_ENABLE | TMR_CTRL_FIPER_START |
+		TMR_CTRL_BYPASS_ADDEND);
+}
+
+int do_time_sync_ioctl(struct net_device *dev, struct ifreq *ifr)
+{
+	struct time_sync_data *time_sync;
+	struct time_sync_data time_sync_data;
+	struct gfar_private *priv = netdev_priv(dev);
+	struct time_sync_priv *time_sync_priv = priv->time_sync_priv;
+	int retval = 0;
+
+	memset(&time_sync_data, 0, sizeof(struct time_sync_data));
+	mutex_lock_interruptible(&sync_lock.lock);
+	if (0 != copy_from_user(&time_sync_data, ifr->ifr_data,
+				sizeof(struct time_sync_data))) {
+		retval = -EFAULT;
+		goto err;
+	}
+
+	switch (time_sync_data.ioctl_cmd) {
+	case TIME_SYNC_INIT:
+		if (time_sync_priv) {
+			printk(KERN_INFO "time sync already"
+						" initialized !!!\r\n");
+			retval = -EEXIST;
+			goto err;
+		}
+		time_sync_priv = kzalloc(sizeof(struct
+					time_sync_priv), GFP_KERNEL);
+		if (!time_sync_priv) {
+			printk(KERN_ERR "Unable to allocate time_sync_priv\n");
+			retval = -ENOMEM;
+			goto err;
+		}
+		init_waitqueue_head(&time_sync_priv->wait_h);
+		time_sync_priv->first_gps = TRUE;
+		time_sync_priv->time_sync = kzalloc(sizeof(struct
+					time_sync_data), GFP_KERNEL);
+		if (!time_sync_priv->time_sync) {
+			printk(KERN_ERR "Unable to allocate time_sync\n");
+			retval = -ENOMEM;
+			kfree(time_sync_priv);
+			goto err;
+		}
+		memcpy(time_sync_priv->time_sync, &time_sync_data,
+					sizeof(struct time_sync_data));
+		priv->time_sync_priv = time_sync_priv;
+		gfar_write(&priv->ptimer->tmr_ctrl,
+				gfar_read(&priv->ptimer->tmr_ctrl)
+				& ~TMR_CTRL_ENABLE);
+
+		if (register_1588_interrupt(dev) != TRUE) {
+			printk(KERN_ERR "1588: Cannot register"
+						" 1588 interrupt handler\n");
+			retval = -EINVAL;
+			time_sync_free(priv);
+			goto err;
+		}
+		if (time_sync_sysfs_init(priv) != TRUE) {
+			printk(KERN_ERR "Unable to initialize sysfs for time-sync\n");
+			retval = -EINVAL;
+			time_sync_free(priv);
+			goto err;
+		}
+		break;
+	case TIME_SYNC_STOP:
+		if (!time_sync_priv) {
+			printk(KERN_DEBUG "time sync not initialized !!!\r\n");
+			retval = -EINVAL;
+			goto err;
+		}
+		gfar_write(&priv->ptimer->tmr_ctrl,
+				gfar_read(&priv->ptimer->tmr_ctrl)
+				& ~TMR_CTRL_ENABLE);
+
+		free_irq(time_sync_priv->irq, priv);
+		time_sync_sysfs_exit(priv->time_sync_priv->time_sync_kobj);
+		time_sync_free(priv);
+		break;
+	case TIME_SYNC_GET_TIME:
+		if (!time_sync_priv) {
+			time_sync_data.time_info.state = TIME_SYNC_NOT_STARTED;
+			if (copy_to_user(ifr->ifr_data, &time_sync_data,
+					sizeof(struct time_sync_data)) > 0)
+				printk(KERN_ERR "Unable to copy time to user\r\n");
+			printk(KERN_DEBUG "time sync not initialized !!!\r\n");
+			retval = -EINVAL;
+			goto err;
+		}
+
+		sync_lock.condition = 0;
+		wait_event_interruptible_timeout(time_sync_priv->wait_h,
+					sync_lock.condition, TIMEOUT * HZ);
+		schedule();
+		set_current_state(TASK_RUNNING);
+		sync_lock.condition = 0;
+		time_sync_data.time_info.state =
+			time_sync_priv->time_sync->time_info.state;
+		time_sync_data.time_info.time_cnt.high =
+			time_sync_priv->time_sync->time_info.time_cnt.high;
+		time_sync_data.time_info.time_cnt.low =
+			time_sync_priv->time_sync->time_info.time_cnt.low;
+		if (copy_to_user(ifr->ifr_data, &time_sync_data,
+					sizeof(struct time_sync_data)) > 0) {
+			retval = -EFAULT;
+			goto err;
+		}
+		break;
+	case TIME_SYNC_START:
+		time_sync = time_sync_priv->time_sync;
+		gfar_write(&(priv->ptimer->tmr_temask), TMR_TEMASK_ETS1 |
+			TMR_TEMASK_ALM1 |
+			TMR_TEMASK_ALM2 |
+			TMR_TEMASK_PP1);
+		time_sync_config_alarm(priv, &(priv->ptimer->tmr_alarm2_l),
+			&(priv->ptimer->tmr_alarm2_h),
+			time_sync_priv->time_sync->black_out_duration);
+		gfar_write(&priv->ptimer->tmr_ctrl,
+			gfar_read(&priv->ptimer->tmr_ctrl)
+				| TMR_CTRL_ENABLE);
+		break;
+	default:
+		printk(KERN_ERR "Invalid ioctl option selected by user,"
+				" option is %d\n", time_sync_data.ioctl_cmd);
+		retval = -EINVAL;
+	}
+err:
+	mutex_unlock(&sync_lock.lock);
+	return retval;
+}
+
+
+
+
+int time_sync_priv(struct time_sync_priv *time_sync_priv)
+{
+	struct gfar_private *priv;
+	struct of_device *ofdev;
+	struct device_node *np = NULL;
+	struct time_sync_priv *time_sync;
+
+	while (1) {
+		np = of_find_compatible_node(NULL, NULL, ETSEC_NODE);
+		if (np == NULL)	{
+			printk(KERN_ERR "1588: Cannot find eTSEC. Check"
+				" eTSEC node in dts \r\n");
+			return -EINVAL;
+		}
+		ofdev = of_find_device_by_node(np);
+		priv = dev_get_drvdata(&ofdev->dev);
+		time_sync = priv->time_sync_priv;
+		if (time_sync)
+			break;
+	}
+	memcpy(time_sync_priv, time_sync, sizeof(struct time_sync_priv));
+	return 0;
+}
+
+
+void gfar_1588_time_sync_init()
+{
+	mutex_init(&sync_lock.lock);
+}
diff --git a/drivers/net/time_sync.h b/drivers/net/time_sync.h
new file mode 100644
index 0000000..28d5078
--- /dev/null
+++ b/drivers/net/time_sync.h
@@ -0,0 +1,141 @@
+/*
+ * timesync framework
+ *
+ * Author: bhaskar upadhaya <bhaskar.upadhaya@freescale.com>
+ *
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef __TIME_SYNC_H__
+#define __TIME_SYNC_H__
+
+typedef unsigned long long UInteger64;
+typedef unsigned int UInteger32;
+
+#define ADDEND_CORRECTION	0x01
+#define DAC_CORRECTION 		0x02
+#define ADDEND_DAC_CORRECTION	0x04
+#define TIMEOUT			4
+#define FIRST_GPS_PULSE		0x01
+
+#define TIME_SYNC_INIT		0x00000001
+#define TIME_SYNC_START		0x00000002
+#define TIME_SYNC_STOP		0x00000004
+#define TIME_SYNC_GET_TIME	0x00000010
+
+#define TMR_TEVENT_ETS2		0x02000000
+#define TMR_TEVENT_ETS1		0x01000000
+#define TMR_TEVENT_ALM2		0x00020000
+#define TMR_TEVENT_ALM1		0x00010000
+#define TMR_TEVENT_PP1		0x00000080
+#define TMR_TEVENT_PP2		0x00000040
+#define TMR_TEVENT_PP3		0x00000020
+
+#define TMR_TEMASK_ETS2		0x02000000
+#define TMR_TEMASK_ETS1		0x01000000
+#define TMR_TEMASK_ALM2		0x00020000
+#define TMR_TEMASK_ALM1		0x00010000
+#define TMR_TEMASK_PP1		0x00000080
+#define TMR_TEMASK_PP2		0x00000040
+
+#define TMR_CTRL_BYPASS_ADDEND	0x00000008
+
+#define EXTERNAL_CLK_FREQ 19200000
+#define MAX_32_REG_LIMIT 0xffffffff
+#define OVERFLOW_LIMIT 223
+
+
+#define GPS_SYNC_SRC "gps_pps_refclk_in"
+#define RAW_GPS "raw_gps"
+#define PTP_SYNC_SRC "ptp synchronization"
+
+#define NSEC	((UInteger64)1000000000)
+#define	BOARD_TIME_TO_SEC(board_time)	((UInteger32)(board_time/NSEC))
+
+#define BOARD_TIME_TO_NSEC(board_time, board_time_sec)\
+	((UInteger32)(board_time - (((UInteger64)board_time_sec) * NSEC)))
+
+#define BUFFER_SIZE 200
+
+#define ETSEC_NODE "fsl,etsec2"
+
+enum {
+	GPS_PPS_INPROGRESS = 1,
+	GPS_PPS_BLACKOUT,
+	GPS_NOT_COMMING,
+	TIME_SYNC_NOT_STARTED,
+	CORRECTION_STARTED
+};
+
+enum time_sync_events {
+	BLACK_OUT_DURATION,
+	TIME_SYNC_SOURCE,
+	LTE_DELAY,
+	LAST_BLACKOUT_OCCURENCE,
+	NEW_MODE_AFTER_BLACKOUT,
+	STATS,
+	CORRECTION_MODE
+};
+
+enum time_sync_src {
+	PPS_SRC_GPS = 1,
+	PPS_SRC_RAW_GPS,
+	PPS_SRC_PTP
+};
+
+struct time_sync_stats {
+	u32 gps_cnt;
+	u32 fiper1_cnt;
+	u32 alarm1_cnt;
+	u32 alarm2_cnt;
+};
+struct time_sync_priv {
+	/* two states are possible
+	 *	1. GPS_PPS_INPROGRESS
+	 *	2. GPS_PPS_BLACKOUT
+	 */
+	u32 state;
+	u8 first_gps;
+	u8 first_blackout;
+	wait_queue_head_t wait_h;
+	struct kobject *time_sync_kobj;
+	unsigned int irq;
+	struct time_sync_data *time_sync;
+	struct time_sync_stats stats;
+	struct timespec blackout_time;
+};
+
+struct time_sync_1588_cnt {
+	u32 high;
+	u32 low;
+};
+
+struct time_info {
+	struct time_sync_1588_cnt time_cnt;
+	u64 board_time;
+	u32 state;
+};
+
+struct time_sync_data {
+	u8 correction_mode;
+	u8 sync_source;
+	u32 lte_delay;
+	u32 ioctl_cmd;
+	u32 black_out_duration;
+	struct time_info time_info;
+};
+
+
+struct time_sync_lock {
+	struct mutex lock;
+	u8 condition;
+	u32 g_gps_cnt;
+};
+
+int do_time_sync_ioctl(struct net_device *dev, struct ifreq *ifr);
+#endif
-- 
1.7.0

