From e5bf7edf71fbc1223de46ec7b2ff8a58d76f60a1 Mon Sep 17 00:00:00 2001
From: b16502 <naveenburmi@freescale.com>
Date: Wed, 19 Oct 2011 11:58:09 +0000
Subject: [PATCH 79/92] shm: Support added for Managing memory area of specific size.

Extracted from 913x_WUSDK_REL_0.9.tar.gz vendor drop.

Earlier Shared Memory Manager manages the complete HUGE PAGE for
allocation/de-alloaction of memory. But now it manages a specified
amount of memory, only.

Signed-off-by: Naveen Burmi <NaveenBurmi@freescale.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/misc/fsl_shm.c |   12 ++++++------
 1 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/drivers/misc/fsl_shm.c b/drivers/misc/fsl_shm.c
index b88a821..15f19b3 100644
--- a/drivers/misc/fsl_shm.c
+++ b/drivers/misc/fsl_shm.c
@@ -46,8 +46,6 @@
 #define ADDRESS_MASK			(~(MIN_FREE_SIZE_LIST - 1))
 #define LIST_INDEX_FROM_ADDRESS(addr)	((addr & ADDRESS_MASK)/MIN_ADDRESS_LIST)
 
-#define HUGE_PAGE_256M		0x10000000
-
 static int fsl_shm_major;
 static spinlock_t mm_lock;
 static void *psa;
@@ -533,7 +531,7 @@ static void *__memalign(unsigned long size, unsigned long align)
 				return (void *)(allocated_node->address);
 			}
 
-			head = (char *)head + sizeof(free_node);
+			head = head + 1;
 			index =
 			    ((unsigned long)head -
 			     (unsigned long)&free_area_lists) /
@@ -622,7 +620,7 @@ static int fsl_shm_get_paddr(shm_seg_t *mem)
 	if (ret > 0) {
 		npages = ret;
 		pg = &pages[0];
-		mem->paddr = page_to_phys(pg);
+		mem->paddr = (void *)page_to_phys(pg);
 		put_page(pg);
 	}
 
@@ -635,6 +633,7 @@ static int fsl_shm_ioctl(struct inode *inode, struct file *file,
 	shm_seg_t seg;
 	alloc_req_t mem;
 	memalign_req_t memalign;
+	unsigned long addr;
 	static int initialized = -1;
 
 	switch (cmd) {
@@ -645,7 +644,7 @@ static int fsl_shm_ioctl(struct inode *inode, struct file *file,
 		spin_lock(&mm_lock);
 		if (initialized) {
 			initialized++;
-			initialize((unsigned long)seg.paddr, HUGE_PAGE_256M);
+			initialize((unsigned long)seg.paddr, seg.size);
 		}
 		spin_unlock(&mm_lock);
 
@@ -669,7 +668,8 @@ static int fsl_shm_ioctl(struct inode *inode, struct file *file,
 		break;
 
 	case IOCTL_FSL_SHM_FREE:
-		fsl_shm_free((void *)arg);
+		copy_from_user(&addr, (void *)arg, sizeof(addr));
+		fsl_shm_free((void *)addr);
 		break;
 
 	default:
-- 
1.7.0

