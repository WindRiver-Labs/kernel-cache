From 84f8f19a8ca43bdebbf095e62c9f39567da71ba3 Mon Sep 17 00:00:00 2001
From: Pankaj chauhan <pankaj.chauhan@freescale.com>
Date: Wed, 30 Nov 2011 11:33:09 +0000
Subject: [PATCH 51/92] rf: Refactor RF timer programming

Extracted from 913x_WUSDK_REL_0.9.tar.gz vendor drop.

Refactor Programming of RF timers. Now SYNC_EN and GPS_EN
are programmed in context of aic_start, which gives a better
control over whether GPS_EN should be used or not.

Signed-off-by: Pankaj Chauhan <pankaj.chauhan@freescale.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/rf/controllers/fsl_aic.c |   56 +++++++++++++++++++++++--------------
 include/linux/rfdev.h            |    1 +
 2 files changed, 36 insertions(+), 21 deletions(-)

diff --git a/drivers/rf/controllers/fsl_aic.c b/drivers/rf/controllers/fsl_aic.c
index 69edf2a..ee18a66 100644
--- a/drivers/rf/controllers/fsl_aic.c
+++ b/drivers/rf/controllers/fsl_aic.c
@@ -60,11 +60,42 @@ static int aic_start(struct rf_ctrl_dev *rf_dev)
 	struct aic_lane_regs *lane_regs;
 	struct aic_lane *lane = rf_dev->priv;
 	struct aic_common_regs *common_regs;
-	u32 val;
+	struct device *dev = lane->aic->dev;
+	u32 val, temp;
+	int i;
 
 	common_regs = lane->aic->regs;
 	lane_regs = lane->regs;
 
+	val = in_be32(&lane_regs->aic_lane_tmctrl);
+	val |= SYNC_EN;
+
+	if ((rf_dev->net_mode == LTE_TDD) || (rf_dev->net_mode == LTE_FDD))
+		val |= LTE_EN;
+
+	temp = SYNC_EN;
+
+	if ((rf_dev->timing_src == RF_PPS_SRC_GPS) ||
+		(rf_dev->timing_src == RF_PPS_SRC_RAW_GPS)) {
+		val |= GPS_EN;
+		temp |= GPS_EN;
+	}
+
+	out_be32(&lane_regs->aic_lane_tmctrl, val);
+
+	for (i = 0; i < SYNC_WAIT; i++) {
+		val = in_be32(&lane_regs->aic_lane_tmctrl);
+		if (!(val & (temp))) {
+			dev_info(dev, "%s:sync cleared %x\n",
+					rf_dev->name, val);
+			break;
+		}
+		mdelay(100);
+	}
+
+	if (val & (temp))
+		dev_info(dev, "%s:sync did not clr %x\n", rf_dev->name, val);
+
 	val = in_be32(&common_regs->ppc_interrupt_ctrl_reg);
 	val |= (ADILANE0_DL_TTI << (lane->id * ADILANE_DL_TTI_SHIFT));
 	out_be32(&common_regs->ppc_interrupt_ctrl_reg, val);
@@ -143,6 +174,8 @@ static int aic_timing_source(struct rf_ctrl_dev *rf_dev, unsigned int src)
 	default:
 		rc = -EINVAL;
 	}
+
+	rf_dev->timing_src = src;
 	out_be32(&regs->aic_netw_conf1, val);
 
 	return rc;
@@ -287,7 +320,7 @@ static int aic_init(struct rf_ctrl_dev *rf_dev,
 	struct aic_lane_regs *regs;
 	struct device *dev = lane->aic->dev;
 	u32 val, temp, sym0_len, rest_syms_len;
-	int rc = 0, i;
+	int rc = 0;
 
 	rc = aic_get_dev_params(rf_dev, init_params);
 	if (rc)
@@ -304,25 +337,6 @@ static int aic_init(struct rf_ctrl_dev *rf_dev,
 	 *after calibration
 	 */
 	out_be32(&regs->aic_dlul_delay, 0x15dc15dc);
-	val = in_be32(&regs->aic_lane_tmctrl);
-	val |= SYNC_EN;
-
-	if ((init_params->mode == LTE_TDD) || (init_params->mode == LTE_FDD))
-		val |= LTE_EN;
-
-	out_be32(&regs->aic_lane_tmctrl, val);
-
-	for (i = 0; i < SYNC_WAIT; i++) {
-		val = in_be32(&regs->aic_lane_tmctrl);
-		if (!(val & (SYNC_EN))) {
-			dev_info(dev, "%s:sync cleared %x\n",
-					rf_dev->name, val);
-			break;
-		}
-		mdelay(10);
-	}
-	if (val & (SYNC_EN))
-		dev_info(dev, "%s:sync did not clr %x\n", rf_dev->name, val);
 
 	rc = aic_adilane_init(lane, init_params);
 	if (rc)
diff --git a/include/linux/rfdev.h b/include/linux/rfdev.h
index 3266a52..693fbfb 100644
--- a/include/linux/rfdev.h
+++ b/include/linux/rfdev.h
@@ -44,6 +44,7 @@ struct rf_ctrl_dev {
 	enum rf_state		state;
 	enum rf_network_mode 	net_mode;
 	enum rf_txrxmode 	tx_rxmode;
+	enum rf_timer_src	timing_src;
 	enum rf_band_width 	bw;
 	struct rf_dev_params	dev_params;
 	int			dev_idx;
-- 
1.7.0

