From 1a813a7708a0b9a3974fe4dd91f4da038f654a8c Mon Sep 17 00:00:00 2001
From: Pankaj chauhan <pankaj.chauhan@freescale.com>
Date: Thu, 1 Dec 2011 16:13:27 +0000
Subject: [PATCH 48/92] rf: Add rfdev state checks in rfdev operations

Extracted from 913x_WUSDK_REL_0.9.tar.gz vendor drop.

Add checks to validate whether an operation on rfdev
is permitted or not for a given rfdev state. These checks
will make sure that any rftool command will not hang even
if :

1. RF daughter card is not plugged on board.
2. RF PHY is not intialized.

Also these checks will make sure that operations like running
RF init script are performed only on rfdev which have RF phy
attached to them.

Signed-off-by: Pankaj Chauhan <pankaj.chauhan@freescale.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/rf/core/rfdev.c     |   41 +++++++++++++++++++++++++++++++++++++++++
 include/linux/rfdev_ioctl.h |    1 +
 2 files changed, 42 insertions(+), 0 deletions(-)

diff --git a/drivers/rf/core/rfdev.c b/drivers/rf/core/rfdev.c
index b1ae99e..b55a486 100644
--- a/drivers/rf/core/rfdev.c
+++ b/drivers/rf/core/rfdev.c
@@ -407,11 +407,16 @@ static int rf_ioctl(struct inode *inode, struct file *filep,
 
 	case RIF_DEV_INIT:
 
+		if (rf_dev->state < RF_PHY_INITIALIZED) {
+			rc = -EAGAIN;
+			goto out;
+		}
 		if (copy_from_user(&init_params,
 			(struct rf_init_params *)arg, sizeof(init_params))) {
 			rc = -EFAULT;
 			goto out;
 		}
+
 		if (phy) {
 			rc = phy->ops->init(phy, &init_params);
 			if (rc)
@@ -424,6 +429,12 @@ static int rf_ioctl(struct inode *inode, struct file *filep,
 		break;
 
 	case RIF_SET_TIMER_SOURCE:
+
+		if (rf_dev->state < RF_PHY_INITIALIZED) {
+			rc = -EAGAIN;
+			goto out;
+		}
+
 		if (!get_user(u32arg, (int *)arg))
 			rc = rf_dev->ops->set_timing_source(rf_dev, u32arg);
 		else
@@ -431,6 +442,12 @@ static int rf_ioctl(struct inode *inode, struct file *filep,
 		break;
 
 	case RIF_SET_TIMER_CORRECTION:
+
+		if (rf_dev->state < RF_PHY_ATTACHED) {
+			rc = -EAGAIN;
+			goto out;
+		}
+
 		if (!get_user(u32arg, (int *)arg)) {
 			if (phy && phy->ops->set_timer_correction)
 				rc = phy->ops->set_timer_correction(phy,
@@ -442,6 +459,11 @@ static int rf_ioctl(struct inode *inode, struct file *filep,
 
 	case RIF_RUN_PHY_CMDS:
 
+		if (rf_dev->state < RF_PHY_ATTACHED) {
+			rc = -EAGAIN;
+			goto out;
+		}
+
 		if (!phy || !phy->ops->run_cmds)
 			goto out;
 
@@ -457,6 +479,10 @@ static int rf_ioctl(struct inode *inode, struct file *filep,
 					rc = phy->ops->run_cmds(phy,
 						(struct rif_phy_cmd *)buf,
 						cmd_set.count);
+					if (!rc) {
+						rf_change_state(rf_dev,
+							RF_PHY_INITIALIZED);
+					}
 				kfree(buf);
 			} else {
 				rc = -ENOMEM;
@@ -466,6 +492,11 @@ static int rf_ioctl(struct inode *inode, struct file *filep,
 
 	case RIF_READ_RSSI:
 
+		if (rf_dev->state < RF_PHY_ATTACHED) {
+			rc = -EAGAIN;
+			goto out;
+		}
+
 		if (phy && phy->ops->read_rssi) {
 			u32arg = phy->ops->read_rssi(phy);
 			if (put_user(u32arg, (int *)arg))
@@ -476,6 +507,11 @@ static int rf_ioctl(struct inode *inode, struct file *filep,
 	case RIF_READ_PHY_REGS:
 	case RIF_READ_CTRL_REGS:
 
+		if (rf_dev->state < RF_PHY_ATTACHED) {
+			rc = -EAGAIN;
+			goto out;
+		}
+
 		if (!copy_from_user(&reg_buf, (struct rif_reg_buf *)arg,
 			sizeof(struct rif_reg_buf))) {
 
@@ -511,6 +547,11 @@ static int rf_ioctl(struct inode *inode, struct file *filep,
 
 	case RIF_WRITE_PHY_REGS:
 
+		if (rf_dev->state < RF_PHY_ATTACHED) {
+			rc = -EAGAIN;
+			goto out;
+		}
+
 		if (!copy_from_user(&write_phy_buf, (struct rif_write_reg_buf *)arg,
 			sizeof(struct rif_write_reg_buf))) {
 
diff --git a/include/linux/rfdev_ioctl.h b/include/linux/rfdev_ioctl.h
index d6f055b..ab87dd5 100644
--- a/include/linux/rfdev_ioctl.h
+++ b/include/linux/rfdev_ioctl.h
@@ -44,6 +44,7 @@ enum rf_band_width {
 enum rf_state {
 	RF_CREATED,
 	RF_PHY_ATTACHED,
+	RF_PHY_INITIALIZED,
 	RF_INITIALIZED,
 	RF_TIMER_SYNC_AWAITED,
 	RF_TIMER_SYNC_FAILED,
-- 
1.7.0

