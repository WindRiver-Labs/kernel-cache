From d43f88680df9633c1ad9f21e2e0b39ffbb6ee238 Mon Sep 17 00:00:00 2001
From: Pankaj chauhan <pankaj.chauhan@freescale.com>
Date: Wed, 7 Dec 2011 12:03:43 +0000
Subject: [PATCH 58/92] rf: Maintain Rfdev state machine in rf_change_state

Extracted from 913x_WUSDK_REL_0.9.tar.gz vendor drop.

Consolidated All state change validations in rf_change_state()
function. This function will allow state changes only in
a predefined sequence, and deny all other state changes.

Signed-off-by: Pankaj Chauhan <pankaj.chauhan@freescale.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/rf/core/rfdev.c |   86 +++++++++++++++++++++++++++++++++++------------
 include/linux/rfdev.h   |    1 +
 2 files changed, 65 insertions(+), 22 deletions(-)

diff --git a/drivers/rf/core/rfdev.c b/drivers/rf/core/rfdev.c
index 8cf2e46..accf742 100644
--- a/drivers/rf/core/rfdev.c
+++ b/drivers/rf/core/rfdev.c
@@ -221,16 +221,61 @@ int unregister_rf_phy_dev(struct rf_phy_dev *phy)
 }
 EXPORT_SYMBOL(unregister_rf_phy_dev);
 
-int rf_change_state(struct rf_ctrl_dev *rf_dev, unsigned int state)
+int rf_change_state(struct rf_ctrl_dev *rf_dev, unsigned int new_state)
 {
-	/*
-	 *For now state assignment as it is. Gradually
-	 *this function will become intelligent to handle
-	 *state machine if required.
+	int err = 0;
+
+	/* Save old state, so that if any operation during
+	 * state change fails then we can go back to previous
+	 * state
 	 */
-	rf_dev->state = state;
+	rf_dev->old_state = rf_dev->state;
 
-	return 0;
+	switch (new_state) {
+
+	case RF_PHY_ATTACHED:
+		if (rf_dev->state != RF_CREATED) {
+			err = -EINVAL;
+			goto out;
+		}
+		break;
+
+	case RF_PHY_INITIALIZED:
+		if (rf_dev->state < RF_PHY_ATTACHED) {
+			err = -EINVAL;
+			goto out;
+		}
+		break;
+
+	case RF_INITIALIZED:
+		if (rf_dev->state < RF_PHY_INITIALIZED) {
+			err = -EINVAL;
+			goto out;
+		}
+		break;
+
+	case RF_READY:
+		if ((rf_dev->state < RF_INITIALIZED) ||
+			(rf_dev->state == RF_READY)) {
+			err = -EINVAL;
+			goto out;
+		}
+		break;
+
+	/* By default all other state changes are allowed */
+	case RF_CREATED:
+	case RF_TIMER_SYNC_AWAITED:
+	case RF_TIMER_SYNC_FAILED:
+	case RF_STOPPED:
+	case RF_DOWN:
+			/*Fall through*/
+	default:
+		break;
+	}
+
+	rf_dev->state = new_state;
+out:
+	return err;
 }
 
 int rf_attach_phy(struct rf_ctrl_dev *rf_dev, struct rf_phy_dev *phy)
@@ -409,7 +454,7 @@ static int rf_ioctl(struct inode *inode, struct file *filep,
 
 	case RIF_DEV_INIT:
 
-		if (rf_dev->state < RF_PHY_INITIALIZED) {
+		if (rf_change_state(rf_dev, RF_INITIALIZED)) {
 			rc = -EAGAIN;
 			goto out;
 		}
@@ -426,8 +471,6 @@ static int rf_ioctl(struct inode *inode, struct file *filep,
 		}
 
 		rc = rf_dev->ops->init(rf_dev, &init_params);
-		if (!rc)
-			rf_change_state(rf_dev, RF_INITIALIZED);
 		break;
 
 	case RIF_SET_TIMER_SOURCE:
@@ -487,7 +530,7 @@ static int rf_ioctl(struct inode *inode, struct file *filep,
 
 	case RIF_RUN_PHY_CMDS:
 
-		if (rf_dev->state < RF_PHY_ATTACHED) {
+		if (rf_change_state(rf_dev, RF_PHY_INITIALIZED)) {
 			rc = -EAGAIN;
 			goto out;
 		}
@@ -507,10 +550,6 @@ static int rf_ioctl(struct inode *inode, struct file *filep,
 					rc = phy->ops->run_cmds(phy,
 						(struct rif_phy_cmd *)buf,
 						cmd_set.count);
-					if (!rc) {
-						rf_change_state(rf_dev,
-							RF_PHY_INITIALIZED);
-					}
 				kfree(buf);
 			} else {
 				rc = -ENOMEM;
@@ -535,7 +574,7 @@ static int rf_ioctl(struct inode *inode, struct file *filep,
 	case RIF_READ_PHY_REGS:
 	case RIF_READ_CTRL_REGS:
 
-		if (rf_dev->state < RF_PHY_ATTACHED) {
+		if (rf_dev->state < RF_PHY_INITIALIZED) {
 			rc = -EAGAIN;
 			goto out;
 		}
@@ -595,8 +634,7 @@ static int rf_ioctl(struct inode *inode, struct file *filep,
 		break;
 
 	case RIF_START:
-
-		if (rf_dev->state < RF_INITIALIZED) {
+		if (rf_change_state(rf_dev, RF_READY)) {
 			rc = -EAGAIN;
 			goto out;
 		}
@@ -606,20 +644,21 @@ static int rf_ioctl(struct inode *inode, struct file *filep,
 				goto out;
 		}
 		rc = rf_dev->ops->start(rf_dev);
-		if (!rc)
-			rf_change_state(rf_dev, RF_READY);
 		break;
 
 	case RIF_STOP:
 
+		if (rf_change_state(rf_dev, RF_STOPPED)) {
+			rc = -EAGAIN;
+			goto out;
+		}
+
 		if (phy) {
 			rc = phy->ops->stop(phy);
 			if (rc)
 				goto out;
 		}
 		rc = rf_dev->ops->stop(rf_dev);
-		if (!rc)
-			rf_change_state(rf_dev, RF_STOPPED);
 		break;
 
 	case RIF_GET_DEV_INFO:
@@ -633,7 +672,10 @@ static int rf_ioctl(struct inode *inode, struct file *filep,
 		rc = -ENOSYS;
 	}
 
+	rf_dev->old_state = rf_dev->state;
 out:
+	if (rc)
+		rf_dev->state = rf_dev->old_state;
 	mutex_unlock(&rf_dev->lock);
 	return rc;
 }
diff --git a/include/linux/rfdev.h b/include/linux/rfdev.h
index f9f1171..0a96f4c 100644
--- a/include/linux/rfdev.h
+++ b/include/linux/rfdev.h
@@ -42,6 +42,7 @@ struct rf_dev_params {
 struct rf_ctrl_dev {
 	char			name[RIF_NAME_SIZE];
 	enum rf_state		state;
+	enum rf_state		old_state;
 	enum rf_network_mode 	net_mode;
 	enum rf_txrxmode 	tx_rxmode;
 	enum rf_timer_src	timing_src;
-- 
1.7.0

