From 448df35d536f73fdc9721decaca50dbd92813d17 Mon Sep 17 00:00:00 2001
From: bhaskar upadhaya <Bhaskar.Upadhaya@freescale.com>
Date: Thu, 1 Dec 2011 11:45:49 +0000
Subject: [PATCH 54/92] rf: time_sync - Interrupt handing for GPS

Extracted from 913x_WUSDK_REL_0.9.tar.gz vendor drop.

provides Interrupt handling mechanism for GPS events on 9131.

Signed-off-by: Bhaskar Upadhaya <bhaskar.upadhaya@freescale.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/net/time_sync.c |   84 +++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 84 insertions(+), 0 deletions(-)

diff --git a/drivers/net/time_sync.c b/drivers/net/time_sync.c
index 98c65e8..38beb48 100644
--- a/drivers/net/time_sync.c
+++ b/drivers/net/time_sync.c
@@ -24,6 +24,7 @@
 #include "time_sync.h"
 #include "gianfar.h"
 
+static irqreturn_t time_sync_isr(int irq, void *arg);
 static int time_sync_priv(struct time_sync_priv *time_sync_priv);
 static void time_sync_sysfs_exit(struct kobject *time_sync_kobj);
 static int time_sync_sysfs_init(struct gfar_private *priv);
@@ -137,6 +138,37 @@ static void time_sync_config_fiper(struct gfar_private *priv)
 		TMR_CTRL_BYPASS_ADDEND);
 }
 
+static int register_1588_interrupt(struct net_device *dev)
+{
+	struct device_node *np;
+	struct gfar_private *priv = netdev_priv(dev);
+	int retval = TRUE;
+
+	np = of_find_compatible_node(NULL, NULL,
+				"fsl,gianfar-ptp-timer");
+	if (np == NULL) {
+		printk(KERN_ERR "unable to find"
+				" \"fsl,gianfar-ptp-timer \"\n");
+		goto err;
+	}
+
+	priv->time_sync_priv->irq = irq_of_parse_and_map(np, 0);
+	if (priv->time_sync_priv->irq == NO_IRQ) {
+		printk(KERN_ERR "unable to find irq for"
+				" fsl,gianfar-ptp-timer\n");
+		goto err;
+	}
+	retval = request_irq(priv->time_sync_priv->irq, time_sync_isr,
+				0, "time-sync-1588", priv);
+	if (retval < 0) {
+		printk(KERN_ERR "unable to register irq handler for 1588\n");
+		goto err;
+	}
+	return retval;
+err:
+	return -EINVAL;
+}
+
 int do_time_sync_ioctl(struct net_device *dev, struct ifreq *ifr)
 {
 	struct time_sync_data *time_sync;
@@ -265,6 +297,58 @@ err:
 	return retval;
 }
 
+static irqreturn_t time_sync_isr(int irq, void *arg)
+{
+	struct gfar_private *priv = (struct gfar_private *)arg;
+	struct time_sync_priv *time_sync_priv = priv->time_sync_priv;
+	struct timespec blackout_time;
+
+	if ((priv->ptimer->tmr_tevent & TMR_TEVENT_ETS1) ||
+	    (priv->ptimer->tmr_tevent & TMR_TEVENT_ETS2)) {
+		gfar_write(&(priv->ptimer->tmr_tevent), TMR_TEVENT_ETS1);
+		if (time_sync_priv->first_gps == TRUE) {
+			time_sync_config_fiper(priv);
+			time_sync_config_alarm(priv,
+				&(priv->ptimer->tmr_alarm1_l),
+				&(priv->ptimer->tmr_alarm1_h),
+				time_sync_priv->time_sync->lte_delay);
+			time_sync_priv->first_gps = FALSE;
+		}
+		time_sync_config_alarm(priv, &(priv->ptimer->tmr_alarm2_l),
+				&(priv->ptimer->tmr_alarm2_h),
+				time_sync_priv->time_sync->black_out_duration);
+		time_sync_priv->time_sync->time_info.time_cnt.low =
+				gfar_read(&(priv->ptimer->tmr_etts1_l));
+		time_sync_priv->time_sync->time_info.time_cnt.high =
+				gfar_read(&(priv->ptimer->tmr_etts1_h));
+		time_sync_priv->time_sync->time_info.state =
+						GPS_PPS_INPROGRESS;
+		time_sync_priv->stats.gps_cnt++;
+		sync_lock.condition = 1;
+		wake_up_all(&time_sync_priv->wait_h);
+	} else if (priv->ptimer->tmr_tevent & TMR_TEVENT_ALM2) {
+		gfar_write(&(priv->ptimer->tmr_tevent), TMR_TEVENT_ALM2);
+		time_sync_priv->time_sync->time_info.state = GPS_PPS_BLACKOUT;
+		time_sync_priv->stats.alarm2_cnt++;
+		getnstimeofday(&blackout_time);
+		memcpy(&time_sync_priv->blackout_time, &blackout_time,
+						sizeof(struct timespec));
+		wake_up_all(&time_sync_priv->wait_h);
+	} else if (priv->ptimer->tmr_tevent & TMR_TEVENT_ALM1) {
+		gfar_write(&(priv->ptimer->tmr_tevent), TMR_TEVENT_ALM1);
+		time_sync_priv->stats.alarm1_cnt++;
+	}
+
+	if (priv->ptimer->tmr_tevent & TMR_TEVENT_PP1) {
+		gfar_write(&(priv->ptimer->tmr_tevent), TMR_TEVENT_PP1);
+		time_sync_priv->stats.fiper1_cnt++;
+		if (sync_lock.g_gps_cnt == time_sync_priv->stats.gps_cnt)
+			time_sync_priv->time_sync->time_info.state =
+					GPS_NOT_COMMING;
+		sync_lock.g_gps_cnt = time_sync_priv->stats.gps_cnt;
+	}
+	return IRQ_HANDLED;
+}
 
 static ssize_t time_sync_show_sysfs(struct kobject *kobj,
 				struct attribute *attr, char *buf)
-- 
1.7.0

