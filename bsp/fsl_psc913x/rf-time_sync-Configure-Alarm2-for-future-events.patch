From 927c18fd82c99fa29188fac29847e43541882752 Mon Sep 17 00:00:00 2001
From: bhaskar upadhaya <Bhaskar.Upadhaya@freescale.com>
Date: Thu, 1 Dec 2011 11:46:04 +0000
Subject: [PATCH 55/92] rf: time_sync - Configure Alarm2 for future events

Extracted from 913x_WUSDK_REL_0.9.tar.gz vendor drop.

provides a method to configure alarm2 of 1588 for desired time period.

Signed-off-by: Bhaskar Upadhaya <bhaskar.upadhaya@freescale.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/net/time_sync.c |   36 ++++++++++++++++++++++++++++++++++++
 1 files changed, 36 insertions(+), 0 deletions(-)

diff --git a/drivers/net/time_sync.c b/drivers/net/time_sync.c
index 38beb48..0590929 100644
--- a/drivers/net/time_sync.c
+++ b/drivers/net/time_sync.c
@@ -31,6 +31,8 @@ static int time_sync_sysfs_init(struct gfar_private *priv);
 static int register_1588_interrupt(struct net_device *dev);
 static void time_sync_free(struct gfar_private *priv);
 static void time_sync_config_fiper(struct gfar_private *priv);
+static void time_sync_config_alarm(struct gfar_private *priv,
+			u32 *alarm_l, u32 *alarm_h, u32 timeout);
 
 static struct time_sync_sysfs attr1 = {
 	.attr.name = "black_out_duration",
@@ -485,6 +487,40 @@ int time_sync_priv(struct time_sync_priv *time_sync_priv)
 	return 0;
 }
 
+void time_sync_config_alarm(struct gfar_private *priv,
+				u32 *alarm_l, u32 *alarm_h, u32 timeout)
+{
+	u32 space_left = 0, seconds = 0, delay = timeout, remaining_seconds = 0;
+	u32 quotient = 0, remainder = 0, high = 0;
+
+	space_left = MAX_32_REG_LIMIT - gfar_read(&(priv->ptimer->tmr_cnt_l));
+	seconds = space_left/EXTERNAL_CLK_FREQ;
+	if (seconds > delay) {
+		gfar_write(alarm_l, gfar_read(&(priv->ptimer->tmr_cnt_l))
+						+ delay * EXTERNAL_CLK_FREQ);
+		gfar_write(alarm_h, gfar_read(&(priv->ptimer->tmr_cnt_h)));
+	} else {
+		remaining_seconds = delay - seconds;
+		if (remaining_seconds <= OVERFLOW_LIMIT) {
+			gfar_write(alarm_l,
+				gfar_read(&(priv->ptimer->tmr_cnt_l))
+					+ delay * EXTERNAL_CLK_FREQ);
+			gfar_write(alarm_h,
+				gfar_read(&(priv->ptimer->tmr_cnt_h)) + 1);
+		} else {
+			quotient  = remaining_seconds / OVERFLOW_LIMIT;
+			remainder = remaining_seconds % OVERFLOW_LIMIT;
+				if (remainder != 0)
+					quotient = quotient + 1;
+			high =  quotient;
+			gfar_write(alarm_l,
+				gfar_read(&(priv->ptimer->tmr_cnt_l))
+					+ (delay * EXTERNAL_CLK_FREQ));
+			gfar_write(alarm_h,
+				gfar_read(&(priv->ptimer->tmr_cnt_h)) + high);
+		}
+	}
+}
 
 void gfar_1588_time_sync_init()
 {
-- 
1.7.0

