From ab5e67c923d3411034becbd5a412203f866c424d Mon Sep 17 00:00:00 2001
From: Pankaj chauhan <pankaj.chauhan@freescale.com>
Date: Thu, 13 Oct 2011 15:22:45 +0000
Subject: [PATCH 43/92] rf: Use raw_spin lock to protect TTI wait queue

Extracted from 913x_WUSDK_REL_0.9.tar.gz vendor drop.

rfdev->wait_q is used to park processes waiting for TTI events.
And the waiting processes are woken up from a interrupt handler.
wait queue APIs use spin lock to protect the wait queue. With PREEMPT_RT
enabled, this causes problem when wake_up is called from IRQ context.

To fix this  *_locked() APIs of wait queue are used
which assume that caller already has lock to protect the queue
and along with this we use a seperate raw spin lock to protect
the queue.

Signed-off-by: Pankaj Chauhan <pankaj.chauhan@freescale.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/rf/core/rfdev.c |   22 ++++++++++++++++++++--
 include/linux/rfdev.h   |    1 +
 2 files changed, 21 insertions(+), 2 deletions(-)

diff --git a/drivers/rf/core/rfdev.c b/drivers/rf/core/rfdev.c
index faabf66..fc6de45 100644
--- a/drivers/rf/core/rfdev.c
+++ b/drivers/rf/core/rfdev.c
@@ -277,7 +277,9 @@ int rf_notify_dl_tti(struct rf_ctrl_dev *rf_dev)
 
 	stats = &rf_dev->stats;
 	stats->tti_count++;
-	wake_up_all(&rf_dev->wait_q);
+	raw_spin_lock(&rf_dev->wait_q_lock);
+	wake_up_locked(&rf_dev->wait_q);
+	raw_spin_unlock(&rf_dev->wait_q_lock);
 
 	return 0;
 }
@@ -323,16 +325,32 @@ static ssize_t rf_read(struct file *filep, char __user *buf, size_t size,
 	struct rf_ctrl_dev *rf_dev;
 	struct rf_stats *stats;
 	wait_queue_t 	wait;
+	unsigned long flags;
 
 	rf_dev = filep->private_data;
 	stats = &rf_dev->stats;
 	init_waitqueue_entry(&wait, current);
-	add_wait_queue(&rf_dev->wait_q, &wait);
+
+	/*
+	 * Spin_locks are changed to mutexes if PREEMPT_RT is enabled,
+	 * i.e they can sleep. This fact is problem for us because
+	 * add_wait_queue()/wake_up_all() takes wait queue spin lock.
+	 * Since spin lock can sleep with PREEMPT_RT, wake_up_all() can not be
+	 * called from rf_notify_dl_tti (which is called in interrupt context).
+	 * As a workaround, wait_q_lock is used for protecting the wait_q and
+	 * add_wait_queue_locked()/ wake_up_locked() functions of wait queues
+	 * are used.
+	 */
+	raw_spin_lock_irqsave(&rf_dev->wait_q_lock, flags);
+	add_wait_queue_exclusive_locked(&rf_dev->wait_q, &wait);
+	raw_spin_unlock_irqrestore(&rf_dev->wait_q_lock, flags);
 	set_current_state(TASK_INTERRUPTIBLE);
 	/*Now wait here, tti notificaion will wake us up*/
 	schedule();
 	set_current_state(TASK_RUNNING);
+	raw_spin_lock_irqsave(&rf_dev->wait_q_lock, flags);
 	remove_wait_queue(&rf_dev->wait_q, &wait);
+	raw_spin_unlock_irqrestore(&rf_dev->wait_q_lock, flags);
 
 	return put_user(stats->tti_count, (int *)buf);
 }
diff --git a/include/linux/rfdev.h b/include/linux/rfdev.h
index 6468855..cd5dfb3 100644
--- a/include/linux/rfdev.h
+++ b/include/linux/rfdev.h
@@ -48,6 +48,7 @@ struct rf_ctrl_dev {
 	struct rf_ctrl_ops	*ops;
 	struct rf_phy_dev	*phy;
 	atomic_t		ref;
+	raw_spinlock_t		wait_q_lock;
 	wait_queue_head_t	wait_q;
 	struct list_head	list;
 	struct mutex		lock;
-- 
1.7.0

