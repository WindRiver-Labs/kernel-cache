From d27441aea456fd3b3bc627e674ea863d8aa2ca14 Mon Sep 17 00:00:00 2001
From: Jiang Bin <bin.jiang@windriver.com>
Date: Tue, 6 Dec 2011 16:59:57 +0800
Subject: [PATCH 56/92] rf: time_sync - Add External clock source for 1588

Extracted from 913x_WUSDK_REL_0.9.tar.gz vendor drop.

Add support for utilizing the external clock src instead of eTSEC
system clock for 1588.

Signed-off-by: Bhaskar Upadhaya <bhaskar.upadhaya@freescale.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/net/Makefile       |    1 +
 drivers/net/gianfar_1588.c |   37 ++++++++++++++++++++++++++++++++-----
 2 files changed, 33 insertions(+), 5 deletions(-)

diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 4066345..52d44b2 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -41,6 +41,7 @@ obj-$(CONFIG_VMXNET3) += vmxnet3/
 gianfar_driver-objs := gianfar.o \
 		gianfar_ethtool.o \
 		gianfar_sysfs.o \
+		time_sync.o \
 		gianfar_1588.o
 
 obj-$(CONFIG_UCC_GETH) += ucc_geth_driver.o
diff --git a/drivers/net/gianfar_1588.c b/drivers/net/gianfar_1588.c
index 6b329b1..4d725d3 100644
--- a/drivers/net/gianfar_1588.c
+++ b/drivers/net/gianfar_1588.c
@@ -587,10 +587,18 @@ void gfar_1588_start(struct net_device *dev)
 		printk(KERN_ERR "1588: Cannot find cksel property \r\n");
 		return;
 	}
+	if (EXTERNAL_SRC == *cksel)
+		gfar_write(&(priv->ptimer->tmr_ctrl),
+			gfar_read(&(priv->ptimer->tmr_ctrl))
+				& (~TMR_CTRL_EXT_CLK));
+	else if (ETSEC_SYS_CLK == *cksel)
+		gfar_write(&(priv->ptimer->tmr_ctrl),
+			gfar_read(&(priv->ptimer->tmr_ctrl))
+			| TMR_CTRL_SYS_CLK);
 
 	gfar_write(&(priv->ptimer->tmr_ctrl),
 		gfar_read(&(priv->ptimer->tmr_ctrl)) |
-		TMR_CTRL_ENABLE | *cksel | TMR_CTRL_FIPER_START);
+		TMR_CTRL_ENABLE | TMR_CTRL_FIPER_START);
 }
 
 /* Cleanup routine for 1588 module.
@@ -684,7 +692,7 @@ u32 nominal_frequency(u32 sysclock_freq)
 
 int gfar_ptp_cal_attr(struct gfar_ptp_attr_t *ptp_attr)
 {
-	u32 *sysclock_freq, nominal_freq, tclk_period;
+	u32 *sysclock_freq, nominal_freq, tclk_period, *cksel = 0;
 	struct device_node *np;
 
 	np = of_find_compatible_node(NULL, NULL, "fsl,gianfar-ptp-timer");
@@ -700,15 +708,34 @@ int gfar_ptp_cal_attr(struct gfar_ptp_attr_t *ptp_attr)
 	printk(KERN_DEBUG "1588 is running at system-clock"
 			" frequency (%u) \r\n", *sysclock_freq);
 
+	cksel = (u32 *)of_get_property(np, "cksel", NULL);
+	if (cksel == NULL) {
+		printk(KERN_ERR "1588: Cannot find cksel property \r\n");
+		return 1;
+	}
+
 	nominal_freq = nominal_frequency(DIV_ROUND(*sysclock_freq, 1000) \
 							/ 1000);
 
 	/* TCLK_PERIOD = 10^9/Nominal_Frequency in MHZ */
-	tclk_period = 1000/nominal_freq;
+	/* The timer clock counter will increment by TCLK_PERIOD every time the
+	 * accumulator register overflows. This clock period must be larger
+	 * than the clock period of the timer reference clock. For applications
+	 * where user does not want the clock period to be added, they can
+	 * program this field to 1 to count the clock ticks.
+	 * This field defaulted to 1 to count overflow ticks.
+	 */
+	if (EXTERNAL_SRC == *cksel)
+		tclk_period = 1;
+	else if (ETSEC_SYS_CLK == *cksel)
+		tclk_period = 1000/nominal_freq;
 
-	/* FIPER = (10^9 / (Required PPS * TCLK_PERIOD)) - TCLK_PERIOD*/
 	ptp_attr->tmr_fiper1 = (ONE_GIGA / (PPS_1588 * tclk_period)) \
-						- tclk_period;
+
+	/*
+	 * left shifting by 16 is done to meet the requirement
+	 * of TMR_CTRL[TCLK_PERIOD]
+	 */						- tclk_period;
 	tclk_period <<= 16;
 	ptp_attr->tclk_period = tclk_period;
 	ptp_attr->nominal_freq = nominal_freq;
-- 
1.7.0

