From 8350fd44f669ac5c25297572baafb9e69b8e73d8 Mon Sep 17 00:00:00 2001
From: Pankaj chauhan <pankaj.chauhan@freescale.com>
Date: Tue, 3 Jan 2012 19:28:36 +0000
Subject: [PATCH 67/92] rf: Add support for reading Rx gain

Extracted from 913x_WUSDK_REL_0.9.tar.gz vendor drop.

Added support for readin Rx gain. It is applicable only for MGC mode,
and not supported in AGC mode.

Signed-off-by: Pankaj Chauhan <pankaj.chauhan@freescale.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/rf/core/rfdev.c     |   22 +++++++
 drivers/rf/phy/ad_phy.c     |  134 +++++++++++++++++++++++++++++++++++++++++++
 drivers/rf/phy/ad_phy.h     |   45 ++++++++++++++
 include/linux/rfdev.h       |    2 +
 include/linux/rfdev_ioctl.h |    6 ++
 5 files changed, 209 insertions(+), 0 deletions(-)

diff --git a/drivers/rf/core/rfdev.c b/drivers/rf/core/rfdev.c
index d994447..8737ef7 100644
--- a/drivers/rf/core/rfdev.c
+++ b/drivers/rf/core/rfdev.c
@@ -448,6 +448,7 @@ static int rf_ioctl(struct inode *inode, struct file *filep,
 	struct rf_tx_buf tx_buf;
 	struct rf_tx_en_dis tx_en_dis;
 	struct rf_rssi rssi, rssi_buf;
+	struct rf_rx_gain rx_gain;
 	u32	*buf;
 	u32 u32arg;
 	int rc = -ENOSYS, size;
@@ -740,6 +741,27 @@ static int rf_ioctl(struct inode *inode, struct file *filep,
 		}
 		break;
 
+	case RIF_READ_RX_GAIN:
+
+		if (rf_dev->state < RF_INITIALIZED) {
+			rc = -EAGAIN;
+			goto out;
+		}
+		if (!copy_from_user(&rx_gain, (struct rf_rx_gain *)arg,
+			sizeof(struct rf_rx_gain))) {
+
+			if (phy && phy->ops->get_rx_gain)
+				rc = phy->ops->get_rx_gain(phy, &rx_gain);
+
+			if (!rc && copy_to_user((struct rf_rx_gain *)arg,
+						&rx_gain,
+						sizeof(struct rf_rx_gain)))
+				rc = -EFAULT;
+		} else {
+			rc = -EFAULT;
+		}
+		break;
+
 	default:
 		rc = -ENOSYS;
 	}
diff --git a/drivers/rf/phy/ad_phy.c b/drivers/rf/phy/ad_phy.c
index acc241c..0d1de42 100644
--- a/drivers/rf/phy/ad_phy.c
+++ b/drivers/rf/phy/ad_phy.c
@@ -67,6 +67,8 @@ static int ad_phy_get_dac_value(struct rf_phy_dev *ad_phy,
 static int ad_phy_start(struct rf_phy_dev *ad_phy);
 static int ad_init(struct rf_phy_dev *phy, struct rf_init_params *params);
 static int ad_phy_stop(struct rf_phy_dev *phy);
+static int ad_get_rx_gain(struct rf_phy_dev *ad_phy,
+		struct rf_rx_gain *rx_gain);
 
 static struct rf_phy_ops ad_phy_ops = {
 	.init = ad_init,
@@ -80,6 +82,7 @@ static struct rf_phy_ops ad_phy_ops = {
 	.read_rssi = ad_read_rssi,
 	.start = ad_phy_start,
 	.stop = ad_phy_stop,
+	.get_rx_gain = ad_get_rx_gain,
 };
 
 
@@ -261,6 +264,130 @@ int ad_phy_run_cmds(struct rf_phy_dev *ad_phy,
 	return 0;
 }
 
+static int ad_get_rx_gain(struct rf_phy_dev *ad_phy,
+		struct rf_rx_gain *rx_gain)
+{
+	struct ad_dev_info *phy_info = ad_phy->priv;
+	struct device *dev = &phy_info->ad_spi->dev;
+	enum rx_gain_table_name tbl;
+	struct rx_gain_info *gain_info;
+	u32 val, idx_reg;
+	u8 mask, shift;
+	int rc = 0, rx_gain_db;
+
+	if ((rx_gain->ant != 1) && (rx_gain->ant != 2)) {
+		dev_dbg(dev, "Unkown Rx path %d\n", rx_gain->ant);
+		rc = -EINVAL;
+		goto out;
+	}
+
+	if (rx_gain->ant == 1) {
+		mask = RX1_GAIN_CTL_MASK;
+		shift = RX1_GAIN_CTL_SHIFT;
+		idx_reg = REG_RX1_MG_FULL_TBL_IDX;
+	} else {
+		mask = RX2_GAIN_CTL_MASK;
+		shift = RX2_GAIN_CTL_SHIFT;
+		idx_reg = REG_RX2_MG_FULL_TBL_IDX;
+	}
+
+	rc = ad_phy_read(ad_phy, REG_AGC_CONF1, 1, &val);
+	if (rc) {
+		dev_dbg(dev, "Unable to read AGC_CONF1 %d\n", REG_AGC_CONF1);
+		goto out;
+	}
+
+	val = (val & mask) >> shift;
+
+	if (val != GAIN_CTL_MGC) {
+		dev_dbg(dev, "Rx gain Read is supported only for MGC, \
+				curr gain ctl mode %d\n", val);
+		rc = -ENOSYS;
+		goto out;
+	}
+
+	rc = ad_phy_read(ad_phy, REG_AGC_CONF2, 1, &val);
+	if (rc) {
+		dev_dbg(dev, "Unable to read AGC_CONF2 %d\n", REG_AGC_CONF2);
+		goto out;
+	}
+
+	if (!(val & FULL_GAIN_TBL)) {
+		dev_dbg(dev, "RX gain read for AGC not supported\n");
+		rc = -ENOSYS;
+		goto out;
+	}
+
+	switch (phy_info->freq_band) {
+	case LTE_BAND1:
+		tbl = FULL_TBL_1300_4000_MHZ;
+		break;
+	case LTE_BAND13:
+		tbl = FULL_TBL_200_1300_MHZ;
+		break;
+	default:
+		dev_dbg(dev, "unkown band for rx gain read, %d\n",
+			phy_info->freq_band);
+		rc = -EINVAL;
+		goto out;
+	}
+
+	rc = ad_phy_read(ad_phy, idx_reg, 1, &val);
+	if (rc) {
+		dev_dbg(dev, "Unable to gain tbl idx reg: %d\n", idx_reg);
+		goto out;
+	}
+
+	val = val & MG_FULL_TBL_IDX_MASK;
+	gain_info = &phy_info->rx_gain[tbl];
+	if (val > gain_info->idx_step_offset) {
+		val = val - gain_info->idx_step_offset;
+		rx_gain_db = gain_info->starting_gain_db +
+			((val) * gain_info->gain_step_db);
+	} else {
+		rx_gain_db = gain_info->starting_gain_db;
+	}
+
+	rx_gain->gain_db = rx_gain_db;
+out:
+	return rc;
+}
+
+void ad_init_gain_info(struct rx_gain_info *rx_gain,
+	enum rx_gain_table_type type, int starting_gain, int gain_step,
+	int max_idx, int idx_offset)
+{
+	rx_gain->tbl_type = type;
+	rx_gain->starting_gain_db = starting_gain;
+	rx_gain->gain_step_db = gain_step;
+	rx_gain->max_idx = max_idx;
+	rx_gain->idx_step_offset = idx_offset;
+}
+
+int ad_init_gain_tables(struct rf_phy_dev *ad_phy)
+{
+	struct rx_gain_info *rx_gain;
+	struct ad_dev_info *phy_info = ad_phy->priv;
+
+	/* Intialize Meta data according to default gain tables
+	 * of AD9631. Changing/Writing of gain tables is not
+	 * supported yet.
+	 */
+	rx_gain = &phy_info->rx_gain[FULL_TBL_200_1300_MHZ];
+	ad_init_gain_info(rx_gain, RXGAIN_FULL_TBL, 1, 1,
+		RXGAIN_FULL_TBL_MAX_IDX, 0);
+
+	rx_gain = &phy_info->rx_gain[FULL_TBL_1300_4000_MHZ];
+	ad_init_gain_info(rx_gain, RXGAIN_FULL_TBL, -4, 1,
+		RXGAIN_FULL_TBL_MAX_IDX, 1);
+
+	rx_gain = &phy_info->rx_gain[FULL_TBL_4000_6000_MHZ];
+	ad_init_gain_info(rx_gain, RXGAIN_FULL_TBL, -10, 1,
+		RXGAIN_FULL_TBL_MAX_IDX, 4);
+
+	return 0;
+}
+
 int ad_init(struct rf_phy_dev *ad_phy,
 		struct rf_init_params *params)
 {
@@ -286,6 +413,8 @@ int ad_init(struct rf_phy_dev *ad_phy,
 		}
 	}
 
+	phy_info->freq_band = params->fq_band;
+
 	return 0;
 }
 
@@ -635,6 +764,11 @@ static int ad_phy_probe(struct spi_device *spi)
 		goto out;
 	}
 
+	ret = ad_init_gain_tables(ad_phy);
+	if (ret) {
+		dev_dbg(dev, "Failed to init rx gain table metadata\n");
+		goto out;
+	}
 	/* If revision code is correct, Registering phy as a rf phy device. */
 	ret = register_rf_phy_dev(ad_phy);
 	if (ret) {
diff --git a/drivers/rf/phy/ad_phy.h b/drivers/rf/phy/ad_phy.h
index a1bc802..bebaafe 100644
--- a/drivers/rf/phy/ad_phy.h
+++ b/drivers/rf/phy/ad_phy.h
@@ -69,9 +69,54 @@
 #define RSSI_LSB_MASK1	0x01
 #define RSSI_LSB_MASK2	0x02
 
+
+#define REG_RX1_MG_FULL_TBL_IDX		0x109
+#define REG_RX2_MG_FULL_TBL_IDX		0x10C
+#define MG_FULL_TBL_IDX_MASK		0x7f
+
+#define REG_AGC_CONF1			0x0FA
+
+#define RX1_GAIN_CTL_MASK		0x0c
+#define RX1_GAIN_CTL_SHIFT		2
+#define RX2_GAIN_CTL_MASK		0x03
+#define RX2_GAIN_CTL_SHIFT		0
+
+#define GAIN_CTL_MGC			0x00
+#define GAIN_CTL_AGC_SLOW_ATK		0x01
+#define GAIN_CTL_AGC_FAST_ATK		0x02
+#define GAIN_CTL_AGC_SLOW_ATK_HYBD	0x03
+
+#define REG_AGC_CONF2			0x0FB
+#define FULL_GAIN_TBL			0x08
+
+#define RXGAIN_FULL_TBL_MAX_IDX		90
+#define RXGAIN_SPLIT_TBL_MAX_IDX	40
+
+enum rx_gain_table_type {
+	RXGAIN_FULL_TBL,
+	RXGAIN_SPLIT_TBL,
+};
+
+enum rx_gain_table_name {
+	FULL_TBL_200_1300_MHZ,
+	FULL_TBL_1300_4000_MHZ,
+	FULL_TBL_4000_6000_MHZ,
+	RXGAIN_TBLS_END,
+};
+
+struct rx_gain_info {
+	enum rx_gain_table_type tbl_type;
+	int starting_gain_db;
+	int gain_step_db;
+	int max_idx;
+	int idx_step_offset;
+};
+
 struct ad_dev_info {
 	struct spi_device *ad_spi;
 	u8 rx_buf[10];
+	enum rf_phy_band freq_band;
+	struct rx_gain_info rx_gain[RXGAIN_TBLS_END];
 	int gpio_count;
 	int *gpios;
 };
diff --git a/include/linux/rfdev.h b/include/linux/rfdev.h
index 5688d9c..f5085e6 100644
--- a/include/linux/rfdev.h
+++ b/include/linux/rfdev.h
@@ -92,6 +92,8 @@ struct rf_phy_ops {
 	int	(*en_dis_tx)(struct rf_phy_dev *phy, u32 tx_if, u32 cmd);
 	int	(*read_rssi)(struct rf_phy_dev *phy, u32 ant,
 			struct rf_rssi *rssi_buf);
+	int	(*get_rx_gain)(struct rf_phy_dev *phy,
+			struct rf_rx_gain *rx_gain);
 	int	(*start)(struct rf_phy_dev *phy);
 	int	(*stop)(struct rf_phy_dev *phy);
 
diff --git a/include/linux/rfdev_ioctl.h b/include/linux/rfdev_ioctl.h
index 2293627..8effcfa 100644
--- a/include/linux/rfdev_ioctl.h
+++ b/include/linux/rfdev_ioctl.h
@@ -156,6 +156,11 @@ struct rf_rssi {
 	__u32 preamble;
 };
 
+struct rf_rx_gain {
+	int ant;
+	int gain_db;
+};
+
 enum rf_timer_src {
 	RF_PPS_SRC_GPS = 1,
 	RF_PPS_SRC_RAW_GPS,
@@ -190,6 +195,7 @@ enum dac_correction_type {
 #define RIF_SET_TX_ATTEN	_IOW(RF_MAGIC, 14, struct rf_tx_buf *)
 #define RIF_EN_DIS_TX		_IOW(RF_MAGIC, 15, struct rf_tx_en_dis *)
 #define RIF_WRITE_CTRL_REGS 	_IOW(RF_MAGIC, 16, struct rif_write_reg_buf *)
+#define RIF_READ_RX_GAIN 	_IOWR(RF_MAGIC, 17, struct rf_rx_gain *)
 
 
 #endif
-- 
1.7.0

