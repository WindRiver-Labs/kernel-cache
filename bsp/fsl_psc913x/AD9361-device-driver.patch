From ddd9ef24784d67cddce08f054270214ce9076733 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Tue, 15 Nov 2011 16:50:13 +0800
Subject: [PATCH 25/92] AD9361 device driver.

Extracted from 913x_WUSDK_REL_0.4.tar.gz vendor drop.

Control path of AD9361 is through SPI interface whereas data path
is through AIC.
Driver configures the ad phy device using SPI interface,
it also binds itself to one of AIC lane using RF framework.
The combination of AIC lane and PHY connected to it works as one RF device.

Signed-off-by: Shaveta Leekha <shaveta@freescale.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/of/base.c       |    1 +
 drivers/rf/phy/Makefile |    2 +
 drivers/rf/phy/ad_phy.c |  447 +++++++++++++++++++++++++++++++++++++++++++++++
 drivers/rf/phy/ad_phy.h |   42 +++++
 4 files changed, 492 insertions(+), 0 deletions(-)
 create mode 100644 drivers/rf/phy/Makefile
 create mode 100644 drivers/rf/phy/ad_phy.c
 create mode 100644 drivers/rf/phy/ad_phy.h

diff --git a/drivers/of/base.c b/drivers/of/base.c
index ddb251e..3fcbd23 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -572,6 +572,7 @@ static struct of_modalias_table of_modalias_table[] = {
 	{ "mmc-spi-slot", "mmc_spi" },
 	{ "fsl,espi-flash", "fsl_m25p80"},
 	{ "fsl,espi-slic", "legerity"},
+ 	{ "fsl,espi-ad_phy", "ad9361_phy"},
 };
 
 /**
diff --git a/drivers/rf/phy/Makefile b/drivers/rf/phy/Makefile
new file mode 100644
index 0000000..b9a7340
--- /dev/null
+++ b/drivers/rf/phy/Makefile
@@ -0,0 +1,2 @@
+
+obj-$(CONFIG_ADI9361)		+= ad_phy.o
diff --git a/drivers/rf/phy/ad_phy.c b/drivers/rf/phy/ad_phy.c
new file mode 100644
index 0000000..b593286
--- /dev/null
+++ b/drivers/rf/phy/ad_phy.c
@@ -0,0 +1,447 @@
+/*
+ *
+ * File: drivers/rf/phy/ad_phy.c
+ *
+ * Freescale AD9361 Phy driver.
+ * AD9361 is a RF phy device connected to one of the AIC lane.
+ * Control path of AD9361 is through SPI interface whereas data path
+ * is through AIC. Its driver register it as a spi driver for the configuration
+ * of ad device via spi and also registers itself as rf_phy_dev that binds
+ * phy device to AIC lane, for data path(UL/DL).
+ *
+ * Author: Shaveta Leekha <shaveta@freescale.com>
+ *
+ * Copyright (C) 2011 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/spi/spi.h>
+#include <linux/param.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/io.h>
+#include <linux/rfdev.h>
+#include <linux/string.h>
+#include "ad_phy.h"
+
+#define DRV_DESC "FREESCALE DEVELOPED AD9361 PHY DRIVER"
+#define DRV_NAME "ad9361_phy"
+#define DEBUG
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION(DRV_DESC);
+
+static int ad_phy_run_cmds(struct rf_phy_dev *ad_phy, struct rif_phy_cmd *cmds,
+		int count);
+static int ad_phy_read(struct rf_phy_dev *ad_phy, u32 start, u32 count,
+		u32 *buff);
+static int ad_phy_write(struct rf_phy_dev *ad_phy, u32 reg, u32 data);
+static int ad_phy_start(struct rf_phy_dev *ad_phy);
+static int ad_init(struct rf_phy_dev *phy, struct rf_init_params *params);
+static int ad_phy_stop(struct rf_phy_dev *phy);
+
+static struct rf_phy_ops ad_phy_ops = {
+	.init = ad_init,
+	.set_timer_correction = NULL,
+	.run_cmds = ad_phy_run_cmds,
+	.read_regs = ad_phy_read,
+	.write_reg = ad_phy_write,
+	.read_rssi = NULL,
+	.start = ad_phy_start,
+	.stop = ad_phy_stop,
+};
+
+
+/*
+ * Function to create AD9361 instruction/command word.
+ * AD9361 controller take command of 16 bits followed by
+ * data. This command would be send to AD9361 via SPI.
+ */
+u16 create_ad_phy_cmd(u16 reg, int opcode)
+{
+	u16 cmd_word;
+
+	switch (opcode) {
+	case SPI_WRITE:
+		cmd_word = OPCODE_WRITE
+			|(((BYTES_TRANSFER - 1) << SHIFT_BYTES_TRANSFER)
+						& (BYTES_TRANSFER_MASK))
+			| (reg & REG_ADDRESS_MASK);
+		break;
+
+	case SPI_READ:
+		cmd_word = OPCODE_READ
+			|(((BYTES_TRANSFER - 1) << SHIFT_BYTES_TRANSFER)
+						& (BYTES_TRANSFER_MASK))
+			| (reg & REG_ADDRESS_MASK);
+		break;
+
+	}
+
+	return cmd_word;
+}
+
+/*
+ * Function to execute write operation on device
+ * using SPI interface to write into some ad9361 register
+ */
+static int spi_write_transaction(struct rf_phy_dev *ad_phy, u8 *buf, int len)
+{
+	u8 *tx_buf;
+	int status;
+	struct spi_message spi_msg;
+	struct spi_transfer ad_tx;
+	struct ad_dev_info *phy_info = ad_phy->priv;
+	struct device *dev = &phy_info->ad_spi->dev;
+
+	spi_message_init(&spi_msg);
+	memset(&ad_tx, 0, sizeof(ad_tx));
+
+	tx_buf = buf;
+	ad_tx.len = len;
+	ad_tx.tx_buf = &tx_buf[0];
+	ad_tx.rx_buf = &(phy_info->rx_buf[0]);
+
+	spi_message_add_tail(&ad_tx, &spi_msg);
+	status = spi_sync(phy_info->ad_spi, &spi_msg);
+	if (status < 0) {
+		dev_dbg(dev, "error in spi write operation\n");
+		return status;
+	}
+
+	return 0;
+}
+
+/*
+ * Function to execute read operation of device
+ * using SPI interface to read ad9361 register.
+ */
+static u8 spi_read_transaction(struct rf_phy_dev *ad_phy, u8 *buf, int len)
+{
+	struct ad_dev_info *phy_info = ad_phy->priv;
+	struct device *dev = &phy_info->ad_spi->dev;
+	u8 *tx_buf, data;
+	struct spi_message spi_msg;
+	struct spi_transfer ad_tx;
+	int status;
+
+	spi_message_init(&spi_msg);
+	memset(&ad_tx, 0, sizeof(ad_tx));
+
+	tx_buf = buf;
+	ad_tx.len = len;
+	ad_tx.tx_buf = &tx_buf[0];
+	ad_tx.rx_buf = &(phy_info->rx_buf[0]);
+
+	spi_message_add_tail(&ad_tx, &spi_msg);
+	status = spi_sync(phy_info->ad_spi, &spi_msg);
+	if (status < 0) {
+		dev_dbg(dev, "error in spi read operation\n");
+		return status;
+	}
+
+	data = phy_info->rx_buf[2];
+	dev_dbg(dev, "Data Read: %x\n", data);
+
+	return data;
+}
+
+/*
+ * This function checks the BBPLL locked status, as that is required
+ * for device to work properly.
+ */
+static int check_bbpll_lock(struct rf_phy_dev *ad_phy)
+{
+	struct ad_dev_info *phy_info = ad_phy->priv;
+	struct device *dev = &phy_info->ad_spi->dev;
+	unsigned long temp_tx;
+	u32 cmd = 0;
+	u8 data_rcvd;
+
+	temp_tx = OVERFLOW_REG;
+
+	cmd = create_ad_phy_cmd((unsigned long)temp_tx, SPI_READ);
+	cmd = (cmd << 16) & COMMAND_MASK;
+
+	data_rcvd = spi_read_transaction(ad_phy, (u8 *)&cmd, TRANSACTION_BYTES);
+
+	if (!(data_rcvd & BBPLL_LOCK_MASK)) {
+		dev_dbg(dev, "BBPLL not locked.\n");
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+int ad_phy_run_cmds(struct rf_phy_dev *ad_phy,
+		struct rif_phy_cmd *cmds, int count)
+{
+	struct ad_dev_info *phy_info = ad_phy->priv;
+	struct device *dev = &phy_info->ad_spi->dev;
+	int i, status;
+	u8 data_rcvd = 0;
+	u32 cmd = 0;
+
+	for (i = 0; i < count; i++) {
+		switch (cmds[i].cmd) {
+		case SPI_WRITE:
+			cmd = create_ad_phy_cmd(cmds[i].param1,
+					cmds[i].cmd);
+			cmd = (cmd << 16) & COMMAND_MASK;
+			cmd = cmd | (cmds[i].param2 << 8);
+			spi_write_transaction(ad_phy, (u8 *)&cmd,
+					TRANSACTION_BYTES);
+
+			dev_dbg(dev, "Write: %x %x\n", cmds[i].param1,
+							cmds[i].param2);
+			break;
+
+		case SPI_READ:
+			cmd = create_ad_phy_cmd(cmds[i].param1,
+					cmds[i].cmd);
+			cmd = (cmd << 16) & COMMAND_MASK;
+			data_rcvd = spi_read_transaction(ad_phy, (u8 *)&cmd,
+					TRANSACTION_BYTES);
+			dev_dbg(dev, "Read from reg: %x\n", cmds[i].param1);
+			break;
+
+		case SPI_WAIT:
+			msleep_interruptible(cmds[i].param3);
+			break;
+
+		case SPI_WAIT_CALDONE:
+			dev_dbg(dev, "Waiting on CALDONE.\n");
+			msleep_interruptible(cmds[i].param3);
+			break;
+
+		case SPI_WAIT_CALDONE_BBPLL:
+			dev_dbg(dev, "Waiting for BBPLL to get locked.\n");
+			msleep_interruptible(cmds[i].param3);
+			status = check_bbpll_lock(ad_phy);
+			if (status) {
+				dev_dbg(dev, "BBPLL has not been locked in"
+						"specified time.\n");
+				return status;
+			}
+			break;
+
+		default:
+			dev_dbg(dev, "Not a valid AD_PHY command\n");
+			return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+int ad_init(struct rf_phy_dev *ad_phy,
+		struct rf_init_params *params)
+{
+	return 0;
+}
+
+int ad_phy_stop(struct rf_phy_dev *ad_phy)
+{
+	return 0;
+}
+
+/*
+ * This is called as a start routine of PHY device.
+ * It internally checks whenever phy device is functional or not,
+ * by checking the BBPLL locked status, as that is required
+ * for device to start properly
+ */
+int ad_phy_start(struct rf_phy_dev *ad_phy)
+{
+	struct ad_dev_info *phy_info = ad_phy->priv;
+	struct device *dev = &phy_info->ad_spi->dev;
+
+	dev_dbg(dev, "Reading BBPLL locked status.\n");
+
+	return check_bbpll_lock(ad_phy);
+}
+
+/*
+ * This is called whenever a process attempts to read from the device
+ */
+int ad_phy_read(struct rf_phy_dev *ad_phy, u32 start,
+		u32 count, u32 *buff)
+{
+	u32 cmd = 0;
+	u8 data_rcvd;
+	u32 data;
+	int i = 0;
+	struct ad_dev_info *phy_info = ad_phy->priv;
+	struct device *dev = &phy_info->ad_spi->dev;
+
+	dev_dbg(dev, "AD's register read call.\n");
+
+	while (count) {
+		cmd = create_ad_phy_cmd((unsigned long)start, SPI_READ);
+		cmd = (cmd << 16) & COMMAND_MASK;
+		data_rcvd = spi_read_transaction(ad_phy, (u8 *)&cmd,
+				TRANSACTION_BYTES);
+		dev_dbg(dev, "Read from reg: %x\n", start);
+		data = data_rcvd;
+		buff[i] = data;
+		i++;
+		count--;
+		start++;
+	}
+
+	return 0;
+}
+
+/*
+ * This is called whenever a process attempts to write to the device
+ */
+int ad_phy_write(struct rf_phy_dev *ad_phy, u32 reg,
+		u32 data)
+{
+	u32 cmd = 0;
+	struct ad_dev_info *phy_info = ad_phy->priv;
+	struct device *dev = &phy_info->ad_spi->dev;
+
+	dev_dbg(dev, "AD's register write call.\n");
+
+	cmd = create_ad_phy_cmd((unsigned long)reg, SPI_WRITE);
+	cmd = (cmd << 16) & COMMAND_MASK;
+	cmd = cmd | (data << 8);
+	spi_write_transaction(ad_phy, (u8 *)&cmd, TRANSACTION_BYTES);
+
+	return 0;
+}
+
+static int ad_phy_remove(struct spi_device *spi)
+{
+	int ret = 0;
+	struct device *dev = &spi->dev;
+	struct rf_phy_dev *ad_phy = dev_get_drvdata(&spi->dev);
+
+	dev_dbg(dev, "AD9361 PHY module uninstalled\n");
+
+	ret = unregister_rf_phy_dev(ad_phy);
+	if (ret < 0) {
+		dev_dbg(dev, "unregister_rf_phy_dev failed.\n");
+		return ret;
+	}
+
+	ret = free_rf_phy_dev(ad_phy);
+
+	return ret;
+}
+
+static u8 read_revision_code(struct rf_phy_dev *ad_phy)
+{
+	u8 data_rcvd, temp_tx;
+	u32 cmd = 0;
+	struct ad_dev_info *phy_info = ad_phy->priv;
+	struct device *dev = &(phy_info->ad_spi->dev);
+
+	dev_dbg(dev, "Reading revision code.\n");
+
+	temp_tx = PRODUCT_CODE_REG;
+
+	cmd = create_ad_phy_cmd((unsigned long)temp_tx, SPI_READ);
+	cmd = (cmd << 16) & COMMAND_MASK;
+
+	data_rcvd = spi_read_transaction(ad_phy, (u8 *)&cmd, TRANSACTION_BYTES);
+
+	return data_rcvd;
+}
+
+static int ad_phy_probe(struct spi_device *spi)
+{
+	int ret = 0;
+	u8 rev;
+	static struct rf_phy_dev *ad_phy;
+	struct device *dev = &spi->dev;
+	struct ad_dev_info *phy_info;
+	struct device_node *np = spi->dev.archdata.of_node;
+
+	ad_phy = allocate_rf_phy_dev(sizeof(struct ad_dev_info), GFP_KERNEL);
+	if (!ad_phy) {
+		dev_dbg(dev, "Failed to allocate rf_phy_dev\n");
+		return -ENOMEM;
+	}
+
+	phy_info = (struct ad_dev_info *) ad_phy->priv;
+
+	phy_info->ad_spi = spi;
+	spi->bits_per_word = 8;
+
+	ad_phy->ops = &ad_phy_ops;
+
+	strncpy(&ad_phy->name[0], "ad9361", sizeof(ad_phy->name));
+	ad_phy->phy_id = (u32) np;
+
+	dev_set_drvdata(&spi->dev, ad_phy);
+
+	/* Read and check Revision Code of the device */
+	rev = read_revision_code(ad_phy);
+	if (!(rev == REV0 || rev == REV2)) {
+		dev_dbg(dev, "Not valid revision code.\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	/* If revision code is correct, Registering phy as a rf phy device. */
+	ret = register_rf_phy_dev(ad_phy);
+	if (ret) {
+		dev_dbg(dev, "register_rf_phy_dev failed.\n");
+		goto out;
+	}
+
+	return ret;
+out:
+	free_rf_phy_dev(ad_phy);
+	return ret;
+}
+
+static struct spi_driver ad_phy_driver = {
+	.driver = {
+		.name = DRV_NAME,
+		.bus = &spi_bus_type,
+		.owner = THIS_MODULE,
+		},
+	.probe = ad_phy_probe,
+	.remove = __devexit_p(ad_phy_remove),
+
+};
+
+static int __init ad_phy_init(void)
+{
+	int ret;
+
+	pr_info("AD_PHY: " DRV_DESC "\n");
+
+	ret = spi_register_driver(&ad_phy_driver);
+	if (ret != 0) {
+		pr_err("%s spi_register_driver failed with err %x\n",
+			__func__, ret);
+	}
+
+	return ret;
+}
+
+static void __exit ad_phy_exit(void)
+{
+	spi_unregister_driver(&ad_phy_driver);
+}
+
+module_init(ad_phy_init);
+module_exit(ad_phy_exit);
diff --git a/drivers/rf/phy/ad_phy.h b/drivers/rf/phy/ad_phy.h
new file mode 100644
index 0000000..b4af33f
--- /dev/null
+++ b/drivers/rf/phy/ad_phy.h
@@ -0,0 +1,42 @@
+/*
+ * drivers/rf/phy/ad_phy.h
+ *
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ *
+ */
+
+#ifndef AD_PHY_H
+#define AD_PHY_H
+
+/* For creating instruction word/command */
+#define OPCODE_WRITE 0x8000
+#define OPCODE_READ 0x0000
+#define BYTES_TRANSFER 1
+#define BYTES_TRANSFER_MASK 0x7000
+#define SHIFT_BYTES_TRANSFER 12
+#define REG_ADDRESS_MASK 0x03FF
+#define COMMAND_MASK 0xFFFF0000
+
+/* SPI instructions Opcode */
+#define SPI_WRITE 1
+#define SPI_READ 2
+#define SPI_WAIT 3
+#define SPI_WAIT_CALDONE 4
+#define SPI_WAIT_CALDONE_BBPLL 5
+
+#define TRANSACTION_BYTES 3
+
+#define BBPLL_LOCK_MASK 0x80
+#define PRODUCT_CODE_REG 0x37
+#define OVERFLOW_REG 0x5E
+
+/* Revision code for AD device. */
+#define REV0 0x08
+#define REV2 0x0a
+
+struct ad_dev_info {
+	struct spi_device *ad_spi;
+	u8 rx_buf[4];
+};
+
+#endif /* AD_PHY_H */
-- 
1.7.0

