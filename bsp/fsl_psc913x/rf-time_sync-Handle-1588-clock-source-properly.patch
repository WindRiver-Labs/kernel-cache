From f0f3ff7a6dfc1aa776833fad1e54731153fe0287 Mon Sep 17 00:00:00 2001
From: Jiang Bin <bin.jiang@windriver.com>
Date: Fri, 13 Jan 2012 11:34:01 +0800
Subject: [PATCH 70/92] rf: time_sync - Handle 1588 clock source properly

Extracted from 913x_WUSDK_REL_0.9.tar.gz vendor drop.

When 1588 selects the clock-source as external, and that clock source
is not detected, switch to system clock source otherwise proceed with
the external clock source.

Signed-off-by: Rajan Srivastava <rajan.srivastava@freescale.com>
Signed-off-by: Bhaskar Upadhaya <bhaskar.upadhaya@freescale.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/net/gianfar.h      |    4 ++++
 drivers/net/gianfar_1588.c |   41 +++++++++++++++++++++++++++++++++++++++++
 drivers/net/time_sync.c    |   13 +++++++------
 3 files changed, 52 insertions(+), 6 deletions(-)

diff --git a/drivers/net/gianfar.h b/drivers/net/gianfar.h
index aff3c53..dfd8deb 100644
--- a/drivers/net/gianfar.h
+++ b/drivers/net/gianfar.h
@@ -646,6 +646,9 @@ static inline int devfp_register_tx_hook(devfp_hook_t hook)
 #define TMR_CTRL_TCLK_MASK	0x03ff0000
 #define TMR_PTPD_MAX_FREQ	0x80000
 #define TMR_CTRL_FIPER_START	0x10000000
+#define TMR_STAT_CLK_RCD 	0x80000000
+#define RETRY_CNT		100000
+#define MHz			1000000
 #define PPS_1588	1
 #define ONE_GIGA	1000000000u
 #define GFAR_1588_PROCFS_MAX_SIZE         12
@@ -1344,6 +1347,7 @@ struct gfar_private {
 	struct gfar_regs_1588 __iomem *ptimer;
 	struct resource timer_resource;
 	uint32_t ptimer_present;
+	u32 ieee_1588_refclk_freq;
 	struct time_sync_priv *time_sync_priv;
 #ifdef CONFIG_GIANFAR_L2SRAM
 	int bd_in_ram;
diff --git a/drivers/net/gianfar_1588.c b/drivers/net/gianfar_1588.c
index b831068..066bd05 100644
--- a/drivers/net/gianfar_1588.c
+++ b/drivers/net/gianfar_1588.c
@@ -41,6 +41,7 @@ static int gfar_ptp_insert(struct gfar_ptp_circular_t *buf,
 static int gfar_ptp_find_and_remove(struct gfar_ptp_circular_t *buf,
 			int key, struct gfar_ptp_data_t *data);
 static u32 nominal_frequency(u32 sysclock_freq);
+static u8 gfar_1588_refclk_detected(struct gfar_private *priv);
 
 static DECLARE_WAIT_QUEUE_HEAD(ptp_rx_ts_wait);
 #define PTP_GET_RX_TIMEOUT	(HZ/10)
@@ -548,6 +549,7 @@ void gfar_1588_start(struct net_device *dev)
 	struct gfar_ptp_attr_t ptp_attr;
 	u32 *tmr_prsc, *cksel;
 	struct device_node *np;
+	u32 tmr_ctrl;
 
 	memset(&ptp_attr, 0, sizeof(struct gfar_ptp_attr_t));
 	np = of_find_compatible_node(NULL, NULL, "fsl,gianfar-ptp-timer");
@@ -599,6 +601,28 @@ void gfar_1588_start(struct net_device *dev)
 	gfar_write(&(priv->ptimer->tmr_ctrl),
 		gfar_read(&(priv->ptimer->tmr_ctrl)) |
 		TMR_CTRL_ENABLE | TMR_CTRL_FIPER_START);
+
+	if (EXTERNAL_SRC == *cksel) {
+		if (FALSE == gfar_1588_refclk_detected(priv)) {
+			printk(KERN_ERR "\nIEEE1588: External reference clock"
+				" not detected. You may want to"
+				" review \n\tthe board's jumper/switch"
+				" settings; however, driver will try to"
+				" \n\tswitch to system-clock.\n");
+			tmr_ctrl = gfar_read(&(priv->ptimer->tmr_ctrl));
+			gfar_write(&(priv->ptimer->tmr_ctrl),
+					gfar_read(&(priv->ptimer->tmr_ctrl)) |
+					TMR_CTRL_ENABLE | 1);
+			priv->ieee_1588_refclk_freq =
+					ptp_attr.sysclock_freq * MHz;
+			if (FALSE == gfar_1588_refclk_detected(priv))
+				printk(KERN_ERR "IEEE1588: Even system clock is"
+					" not detected. The Etsec/1588"
+					" \n\tmodule may not work correctly");
+		} else {
+			priv->ieee_1588_refclk_freq = EXTERNAL_CLK_FREQ;
+		}
+	}
 }
 
 /* Cleanup routine for 1588 module.
@@ -876,3 +900,20 @@ void gfar_1588_proc_exit()
 	remove_proc_entry(GFAR_1588_PROCFS_NAME, NULL);
 	printk(KERN_INFO "/proc/%s removed \r\n", GFAR_1588_PROCFS_NAME);
 }
+
+u8 gfar_1588_refclk_detected(struct gfar_private *priv)
+{
+	u32 tmr_stat;
+	u32 cnt = 0;
+
+	tmr_stat = gfar_read(&(priv->ptimer->tmr_stat));
+	while ((cnt < RETRY_CNT) &&
+			((tmr_stat & TMR_STAT_CLK_RCD) == 0)) {
+		tmr_stat = gfar_read(&(priv->ptimer->tmr_stat));
+		cnt++;
+	}
+	if (tmr_stat & TMR_STAT_CLK_RCD)
+		return TRUE;
+	else
+		return FALSE;
+}
diff --git a/drivers/net/time_sync.c b/drivers/net/time_sync.c
index d25bebc..b4615d1 100644
--- a/drivers/net/time_sync.c
+++ b/drivers/net/time_sync.c
@@ -128,7 +128,7 @@ static void time_sync_config_fiper(struct gfar_private *priv)
 	}
 
 	gfar_write(&(priv->ptimer->tmr_prsc), *tmr_prsc);
-	gfar_write(&(priv->ptimer->tmr_fiper1), EXTERNAL_CLK_FREQ
+	gfar_write(&(priv->ptimer->tmr_fiper1), priv->ieee_1588_refclk_freq
 		 - (ptp_attr.tclk_period>>16));
 
 	/* Need to mask the TCLK bits as they are initialized with 1 */
@@ -334,6 +334,7 @@ static irqreturn_t time_sync_isr(int irq, void *arg)
 	struct timespec blackout_time;
 	if ((priv->ptimer->tmr_tevent & TMR_TEVENT_ETS1) &&
 			(priv->ptimer->tmr_temask & TMR_TEMASK_ETS1)) {
+
 		gfar_write(&(priv->ptimer->tmr_tevent), TMR_TEVENT_ETS1);
 		if (time_sync_priv->first_gps == TRUE) {
 			time_sync_config_fiper(priv);
@@ -536,17 +537,17 @@ void time_sync_config_alarm(struct gfar_private *priv,
 	u32 quotient = 0, remainder = 0, high = 0;
 
 	space_left = MAX_32_REG_LIMIT - gfar_read(&(priv->ptimer->tmr_cnt_l));
-	seconds = space_left/EXTERNAL_CLK_FREQ;
+	seconds = space_left / priv->ieee_1588_refclk_freq;
 	if (seconds > delay) {
 		gfar_write(alarm_l, gfar_read(&(priv->ptimer->tmr_cnt_l))
-						+ delay * EXTERNAL_CLK_FREQ);
+					+ delay * priv->ieee_1588_refclk_freq);
 		gfar_write(alarm_h, gfar_read(&(priv->ptimer->tmr_cnt_h)));
 	} else {
 		remaining_seconds = delay - seconds;
 		if (remaining_seconds <= OVERFLOW_LIMIT) {
 			gfar_write(alarm_l,
 				gfar_read(&(priv->ptimer->tmr_cnt_l))
-					+ delay * EXTERNAL_CLK_FREQ);
+					+ delay * priv->ieee_1588_refclk_freq);
 			gfar_write(alarm_h,
 				gfar_read(&(priv->ptimer->tmr_cnt_h)) + 1);
 		} else {
@@ -556,8 +557,8 @@ void time_sync_config_alarm(struct gfar_private *priv,
 					quotient = quotient + 1;
 			high =  quotient;
 			gfar_write(alarm_l,
-				gfar_read(&(priv->ptimer->tmr_cnt_l))
-					+ (delay * EXTERNAL_CLK_FREQ));
+				gfar_read(&(priv->ptimer->tmr_cnt_l)) +
+					(delay * priv->ieee_1588_refclk_freq));
 			gfar_write(alarm_h,
 				gfar_read(&(priv->ptimer->tmr_cnt_h)) + high);
 		}
-- 
1.7.0

