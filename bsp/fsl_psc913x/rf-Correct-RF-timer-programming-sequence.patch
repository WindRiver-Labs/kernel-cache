From f45c0657d037043e87d689946fdd2133c8d560ac Mon Sep 17 00:00:00 2001
From: Pankaj Chauhan <pankaj.chauhan@freescale.com>
Date: Fri, 6 Jan 2012 18:08:07 +0000
Subject: [PATCH 69/92] rf: Correct RF timer programming sequence

Extracted from 913x_WUSDK_REL_0.9.tar.gz vendor drop.

Correct sequence of RF timer block intialization is:
1. Set GPS_EN, wait for it to get cleared.
2. Set SYN_EN, wait for it to get cleared.
3. Set LTE enable.

In current code we were writing all three bits in one register write,
because of which data path wasn't working if GPS_EN is set.

Signed-off-by: Pankaj Chauhan <pankaj.chauhan@freescale.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/rf/controllers/fsl_aic.c |   47 +++++++++++++++++++++++++++++---------
 1 files changed, 36 insertions(+), 11 deletions(-)

diff --git a/drivers/rf/controllers/fsl_aic.c b/drivers/rf/controllers/fsl_aic.c
index fad930a..542c0b8 100644
--- a/drivers/rf/controllers/fsl_aic.c
+++ b/drivers/rf/controllers/fsl_aic.c
@@ -64,28 +64,44 @@ static int aic_start(struct rf_ctrl_dev *rf_dev)
 	struct aic_common_regs *common_regs;
 	struct device *dev = lane->aic->dev;
 	u32 val, temp;
-	int i;
+	int i, rc = 0;
 
 	common_regs = lane->aic->regs;
 	lane_regs = lane->regs;
 
 	val = in_be32(&lane_regs->aic_lane_tmctrl);
-	val |= SYNC_EN;
-
-	if ((rf_dev->net_mode == LTE_TDD) || (rf_dev->net_mode == LTE_FDD))
-		val |= LTE_EN;
-
-	temp = SYNC_EN;
 
 	if ((rf_dev->timing_src == RF_PPS_SRC_GPS) ||
 		(rf_dev->timing_src == RF_PPS_SRC_RAW_GPS) ||
 		(rf_dev->timing_src == RF_PPS_SRC_PTP)) {
+
 		val |= GPS_EN;
-		temp |= GPS_EN;
+		temp = val;
+
+		out_be32(&lane_regs->aic_lane_tmctrl, val);
+
+		for (i = 0; i < SYNC_WAIT; i++) {
+			val = in_be32(&lane_regs->aic_lane_tmctrl);
+			if (!(val & (temp))) {
+				dev_info(dev, "%s:GPS_EN cleared %x\n",
+						rf_dev->name, val);
+				break;
+			}
+			mdelay(100);
+		}
+
+		if (val & (temp)) {
+			dev_info(dev, "%s:GPS_EN did not clr %x\n",
+					rf_dev->name, val);
+			rc = -EAGAIN;
+			goto out;
+		}
 	}
 
-	out_be32(&lane_regs->aic_lane_tmctrl, val);
+	val |= SYNC_EN;
+	temp = val;
 
+	out_be32(&lane_regs->aic_lane_tmctrl, val);
 	for (i = 0; i < SYNC_WAIT; i++) {
 		val = in_be32(&lane_regs->aic_lane_tmctrl);
 		if (!(val & (temp))) {
@@ -96,14 +112,23 @@ static int aic_start(struct rf_ctrl_dev *rf_dev)
 		mdelay(100);
 	}
 
-	if (val & (temp))
+	if (val & (temp)) {
 		dev_info(dev, "%s:sync did not clr %x\n", rf_dev->name, val);
+		rc = -EAGAIN;
+		goto out;
+	}
+
+	if ((rf_dev->net_mode == LTE_TDD) || (rf_dev->net_mode == LTE_FDD))
+		val |= LTE_EN;
+
+	out_be32(&lane_regs->aic_lane_tmctrl, val);
 
 	val = in_be32(&common_regs->ppc_interrupt_ctrl_reg);
 	val |= (ADILANE0_DL_TTI << (lane->id * ADILANE_DL_TTI_SHIFT));
 	out_be32(&common_regs->ppc_interrupt_ctrl_reg, val);
 
-	return 0;
+out:
+	return rc;
 }
 
 static int aic_stop(struct rf_ctrl_dev *rf_dev)
-- 
1.7.0

