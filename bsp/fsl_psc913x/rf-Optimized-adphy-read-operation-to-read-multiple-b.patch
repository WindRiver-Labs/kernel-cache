From 78588b074e6d4d4e998b58e5f4c98344d1df1723 Mon Sep 17 00:00:00 2001
From: Shaveta Leekha <shaveta@freescale.com>
Date: Wed, 9 Nov 2011 11:11:43 +0000
Subject: [PATCH 50/92] rf: Optimized adphy read operation to read multiple bytes at a time

Extracted from 913x_WUSDK_REL_0.9.tar.gz vendor drop.

AD9361 supports multi-byte data transfer(max 8 bytes in one transfer).
Read from AD9361 device is therefore optimized to read 8 bytes at a time
in single transfer.

Signed-off-by: Shaveta Leekha <shaveta@freescale.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/rf/phy/ad_phy.c |   63 ++++++++++++++++++++++++++++++----------------
 drivers/rf/phy/ad_phy.h |    4 +-
 2 files changed, 43 insertions(+), 24 deletions(-)

diff --git a/drivers/rf/phy/ad_phy.c b/drivers/rf/phy/ad_phy.c
index 36edd7f..6c1523f 100644
--- a/drivers/rf/phy/ad_phy.c
+++ b/drivers/rf/phy/ad_phy.c
@@ -72,21 +72,21 @@ static struct rf_phy_ops ad_phy_ops = {
 };
 
 
-u16 create_ad_phy_cmd(u16 reg, int opcode)
+u16 create_ad_phy_cmd(u16 reg, int opcode, int bytes_transfer)
 {
-	u16 cmd_word;
+	u16 cmd_word = 0;
 
 	switch (opcode) {
 	case SPI_WRITE:
 		cmd_word = OPCODE_WRITE
-			|(((BYTES_TRANSFER - 1) << SHIFT_BYTES_TRANSFER)
+			|(((bytes_transfer - 1) << SHIFT_BYTES_TRANSFER)
 						& (BYTES_TRANSFER_MASK))
 			| (reg & REG_ADDRESS_MASK);
 		break;
 
 	case SPI_READ:
 		cmd_word = OPCODE_READ
-			|(((BYTES_TRANSFER - 1) << SHIFT_BYTES_TRANSFER)
+			|(((bytes_transfer - 1) << SHIFT_BYTES_TRANSFER)
 						& (BYTES_TRANSFER_MASK))
 			| (reg & REG_ADDRESS_MASK);
 		break;
@@ -163,7 +163,7 @@ static int check_bbpll_lock(struct rf_phy_dev *ad_phy)
 
 	temp_tx = OVERFLOW_REG;
 
-	cmd = create_ad_phy_cmd((unsigned long)temp_tx, SPI_READ);
+	cmd = create_ad_phy_cmd((unsigned long)temp_tx, SPI_READ, 1);
 	cmd = (cmd << 16) & COMMAND_MASK;
 
 	data_rcvd = spi_read_transaction(ad_phy, (u8 *)&cmd, TRANSACTION_BYTES);
@@ -189,7 +189,7 @@ int ad_phy_run_cmds(struct rf_phy_dev *ad_phy,
 		switch (cmds[i].cmd) {
 		case SPI_WRITE:
 			cmd = create_ad_phy_cmd(cmds[i].param1,
-					cmds[i].cmd);
+					cmds[i].cmd, 1);
 			cmd = (cmd << 16) & COMMAND_MASK;
 			cmd = cmd | (cmds[i].param2 << 8);
 			spi_write_transaction(ad_phy, (u8 *)&cmd,
@@ -201,7 +201,7 @@ int ad_phy_run_cmds(struct rf_phy_dev *ad_phy,
 
 		case SPI_READ:
 			cmd = create_ad_phy_cmd(cmds[i].param1,
-					cmds[i].cmd);
+					cmds[i].cmd, 1);
 			cmd = (cmd << 16) & COMMAND_MASK;
 			data_rcvd = spi_read_transaction(ad_phy, (u8 *)&cmd,
 					TRANSACTION_BYTES);
@@ -282,26 +282,45 @@ int ad_phy_start(struct rf_phy_dev *ad_phy)
 int ad_phy_read(struct rf_phy_dev *ad_phy, u32 start,
 		u32 count, u32 *buff)
 {
-	u32 cmd = 0;
-	u8 data_rcvd;
+	u32 cnt = 0;
+	u32 read_addr;
 	u32 data;
 	int i = 0;
+	int j = 0;
+	u16 rx_cmd;
+
 	struct ad_dev_info *phy_info = ad_phy->priv;
 	struct device *dev = &phy_info->ad_spi->dev;
 
 	dev_dbg(dev, "AD's register read call.\n");
 
-	while (count) {
-		cmd = create_ad_phy_cmd((unsigned long)start, SPI_READ);
-		cmd = (cmd << 16) & COMMAND_MASK;
-		data_rcvd = spi_read_transaction(ad_phy, (u8 *)&cmd,
-				TRANSACTION_BYTES);
-		dev_dbg(dev, "Read from reg: %x\n", start);
-		data = data_rcvd;
-		buff[i] = data;
-		i++;
-		count--;
-		start++;
+	read_addr = start + count - 1;
+	j = count - 1;
+	cnt = count / 8;
+	count = count - (cnt * 8);
+
+	while (cnt) {
+		rx_cmd = create_ad_phy_cmd((unsigned long)read_addr,
+							SPI_READ, 8);
+
+		spi_read_transaction(ad_phy, (u8 *)&rx_cmd, 10);
+
+		for (i = COMMAND_LEN; i < 10 ; i++) {
+			data = phy_info->rx_buf[i];
+			buff[j--] = data;
+		}
+
+		cnt--;
+		read_addr = read_addr - 8;
+	}
+
+	rx_cmd = create_ad_phy_cmd((unsigned long)read_addr, SPI_READ, count);
+
+	spi_read_transaction(ad_phy, (u8 *)&rx_cmd, (COMMAND_LEN + count));
+
+	for (i = COMMAND_LEN; i < (COMMAND_LEN + count) ; i++) {
+		data = phy_info->rx_buf[i];
+		buff[j--] = data;
 	}
 
 	return 0;
@@ -316,7 +335,7 @@ int ad_phy_write(struct rf_phy_dev *ad_phy, u32 reg,
 
 	dev_dbg(dev, "AD's register write call.\n");
 
-	cmd = create_ad_phy_cmd((unsigned long)reg, SPI_WRITE);
+	cmd = create_ad_phy_cmd((unsigned long)reg, SPI_WRITE, 1);
 	cmd = (cmd << 16) & COMMAND_MASK;
 	cmd = cmd | (data << 8);
 	spi_write_transaction(ad_phy, (u8 *)&cmd, TRANSACTION_BYTES);
@@ -361,7 +380,7 @@ static u8 read_revision_code(struct rf_phy_dev *ad_phy)
 
 	temp_tx = PRODUCT_CODE_REG;
 
-	cmd = create_ad_phy_cmd((unsigned long)temp_tx, SPI_READ);
+	cmd = create_ad_phy_cmd((unsigned long)temp_tx, SPI_READ, 1);
 	cmd = (cmd << 16) & COMMAND_MASK;
 
 	data_rcvd = spi_read_transaction(ad_phy, (u8 *)&cmd, TRANSACTION_BYTES);
diff --git a/drivers/rf/phy/ad_phy.h b/drivers/rf/phy/ad_phy.h
index a94bed2..6cdb493 100644
--- a/drivers/rf/phy/ad_phy.h
+++ b/drivers/rf/phy/ad_phy.h
@@ -11,11 +11,11 @@
 /* For creating instruction word/command */
 #define OPCODE_WRITE 0x8000
 #define OPCODE_READ 0x0000
-#define BYTES_TRANSFER 1
 #define BYTES_TRANSFER_MASK 0x7000
 #define SHIFT_BYTES_TRANSFER 12
 #define REG_ADDRESS_MASK 0x03FF
 #define COMMAND_MASK 0xFFFF0000
+#define COMMAND_LEN 2
 
 /* SPI instructions Opcode */
 #define SPI_WRITE 1
@@ -36,7 +36,7 @@
 
 struct ad_dev_info {
 	struct spi_device *ad_spi;
-	u8 rx_buf[4];
+	u8 rx_buf[10];
 	int gpio_count;
 	int *gpios;
 };
-- 
1.7.0

