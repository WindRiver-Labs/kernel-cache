From dc0d571ca83efa77f25377ad4ac484ceb0ad9196 Mon Sep 17 00:00:00 2001
From: b16502 <naveenburmi@freescale.com>
Date: Fri, 19 Aug 2011 12:09:12 +0000
Subject: [PATCH 35/92] crypto: caam - Added UIO support in CAAM driver.

Extracted from 913x_WUSDK_REL_0.9.tar.gz vendor drop.

This patch enables the user space application to directly access the CAAM
Engine from user space.

Signed-off-by: Naveen Burmi <NaveenBurmi@freescale.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/crypto/caam/Kconfig   |   12 ++
 drivers/crypto/caam/Makefile  |    1 +
 drivers/crypto/caam/caamalg.c |   11 ++-
 drivers/crypto/caam/caamuio.c |  232 +++++++++++++++++++++++++++++++++++++++++
 drivers/crypto/caam/caamuio.h |   26 +++++
 drivers/crypto/caam/ctrl.c    |   35 +++++--
 drivers/crypto/caam/intern.h  |    6 +
 drivers/crypto/caam/jr.c      |    5 +-
 8 files changed, 315 insertions(+), 13 deletions(-)
 create mode 100644 drivers/crypto/caam/caamuio.c
 create mode 100644 drivers/crypto/caam/caamuio.h

diff --git a/drivers/crypto/caam/Kconfig b/drivers/crypto/caam/Kconfig
index 2d876bb..a258b88 100644
--- a/drivers/crypto/caam/Kconfig
+++ b/drivers/crypto/caam/Kconfig
@@ -70,3 +70,15 @@ config CRYPTO_DEV_FSL_CAAM_CRYPTO_API
 
 	  To compile this as a module, choose M here: the module
 	  will be called caamalg.
+
+config CRYPTO_DEV_FSL_CAAM_UIO
+	tristate "CAAM UIO Support"
+	depends on CRYPTO_DEV_FSL_CAAM
+	default y
+	select UIO
+	help
+	  Selecting this will enable the user space applications to
+	  directly access CAAM Job Rings from user space.
+
+	  To compile this as a module, choose M here: the module
+	  will be called caamuio.
diff --git a/drivers/crypto/caam/Makefile b/drivers/crypto/caam/Makefile
index ef39011..78a0f01 100644
--- a/drivers/crypto/caam/Makefile
+++ b/drivers/crypto/caam/Makefile
@@ -4,5 +4,6 @@
 
 obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM) += caam.o
 obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_CRYPTO_API) += caamalg.o
+obj-$(CONFIG_CRYPTO_DEV_FSL_CAAM_UIO) += caamuio.o
 
 caam-objs := ctrl.o jr.o error.o
diff --git a/drivers/crypto/caam/caamalg.c b/drivers/crypto/caam/caamalg.c
index b8a50fa..8d47e2e 100644
--- a/drivers/crypto/caam/caamalg.c
+++ b/drivers/crypto/caam/caamalg.c
@@ -1106,6 +1106,7 @@ static int __init caam_algapi_init(void)
 	struct device *ctrldev, **jrdev;
 	struct caam_drv_private *priv;
 	int i = 0, err = 0;
+	u8 nr_kernel_jrs;
 
 	dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec-v4.0");
 	if (!dev_node)
@@ -1121,11 +1122,17 @@ static int __init caam_algapi_init(void)
 
 	INIT_LIST_HEAD(&priv->alg_list);
 
-	jrdev = kmalloc(sizeof(*jrdev) * priv->total_jobrs, GFP_KERNEL);
+	nr_kernel_jrs = priv->total_jobrs - priv->nr_uio_jrs;
+	if (!nr_kernel_jrs) {
+		dev_info(ctrldev, "No Job Ring configured for kernel space\n");
+		return -ENODEV;
+	}
+
+	jrdev = kmalloc(sizeof(*jrdev) * nr_kernel_jrs, GFP_KERNEL);
 	if (!jrdev)
 		return -ENOMEM;
 
-	for (i = 0; i < priv->total_jobrs; i++) {
+	for (i = 0; i < nr_kernel_jrs; i++) {
 		err = caam_jr_register(ctrldev, &jrdev[i]);
 		if (err < 0)
 			break;
diff --git a/drivers/crypto/caam/caamuio.c b/drivers/crypto/caam/caamuio.c
new file mode 100644
index 0000000..e1064e7
--- /dev/null
+++ b/drivers/crypto/caam/caamuio.c
@@ -0,0 +1,232 @@
+/*
+ * caam - Freescale Integrated Security Engine (SEC) device driver
+ * Support for accessing CAAM block from user space using UIO.
+ *
+ * Copyright 2011 Freescale Semiconductor, Inc
+ */
+
+#include <linux/uio_driver.h>
+
+#include "compat.h"
+#include "regs.h"
+#include "intern.h"
+#include "error.h"
+#include "caamuio.h"
+
+#define UIODEV_NAMELEN	20
+
+struct caam_uio_device {
+	/* UIO Device Name */
+	char uio_dev_name[UIODEV_NAMELEN];
+
+	struct uio_info uio_info;
+
+	/* pointer to controller dev */
+	struct caam_drv_private *ctrlpriv;
+
+	/* JobR's register space */
+	struct caam_job_ring __iomem *rregs;
+
+	/* Ring id - corresponding to location of job ring node in dts */
+	int uio_rid;
+};
+
+/* Main user space ring interrupt handler */
+static irqreturn_t caam_uio_jr_interrupt(int irq, struct uio_info *dev_info)
+{
+	struct caam_uio_device *caamuiodev = dev_info->priv;
+	struct device *dev = &caamuiodev->ctrlpriv->ofdev->dev;
+	u32 irqstate;
+
+	irqstate = rd_reg32(&caamuiodev->rregs->jrintstatus);
+	if (!irqstate)
+		return IRQ_NONE;
+
+	if (irqstate & JRINT_JR_ERROR)
+		dev_info(dev, "uio job ring %d error - irqstate: %08x\n",
+			 caamuiodev->uio_rid, irqstate);
+
+	/*mask valid interrupts */
+	setbits32(&caamuiodev->rregs->rconfig_lo, JRCFG_IMSK);
+
+	/* Have valid interrupt at this point, just ACK and trigger */
+	wr_reg32(&caamuiodev->rregs->jrintstatus, irqstate);
+
+	return IRQ_HANDLED;
+}
+
+static int caam_uio_irq_control(struct uio_info *info, s32 irq_control)
+{
+	struct caam_uio_device *caamuiodev = info->priv;
+
+	switch (irq_control) {
+	case SEC_UIO_SIMULATE_IRQ_CMD:
+		uio_event_notify(info);
+		return 0;
+
+	case SEC_UIO_ENABLE_IRQ_CMD:
+		/* Enable Job Ring interrupt */
+		clrbits32(&caamuiodev->rregs->rconfig_lo, JRCFG_IMSK);
+		return 0;
+
+	case SEC_UIO_DISABLE_IRQ_CMD:
+		/* Disable Job Ring interrupt */
+		setbits32(&caamuiodev->rregs->rconfig_lo, JRCFG_IMSK);
+		return 0;
+
+	default:
+		return 0;
+	}
+
+	return 0;
+}
+
+static int caam_uio_init_jr(struct of_device *ofdev,
+			    struct device_node *np, int ridx, int rid)
+{
+	u32 *jroffset;
+	struct resource res;
+	struct caam_uio_device *caamuiodev;
+	struct device *dev;
+	int ret;
+
+	dev = &ofdev->dev;
+	jroffset = (u32 *) of_get_property(np, "reg", NULL);
+	ret = of_address_to_resource(ofdev->node, 0, &res);
+	if (ret) {
+		dev_err(dev, "Failed reading reg property from DTS!\n");
+		return ret;
+	}
+
+	caamuiodev = kzalloc(sizeof(struct caam_uio_device), GFP_KERNEL);
+	if (!caamuiodev) {
+		dev_err(dev,
+			"Failed to allocate memory for caam uio job ring %d\n",
+			rid);
+		return -ENOMEM;
+	}
+
+	snprintf(caamuiodev->uio_dev_name, UIODEV_NAMELEN, "%s%d",
+		 SEC_UIO_DEVICE_NAME, rid);
+	caamuiodev->uio_info.name = caamuiodev->uio_dev_name;
+
+	caamuiodev->uio_info.mem[0].addr = res.start + jroffset[0];
+	caamuiodev->uio_info.mem[0].size = jroffset[1];
+	caamuiodev->uio_info.mem[0].memtype = UIO_MEM_PHYS;
+
+	caamuiodev->uio_info.version = SEC_UIO_VERSION;
+	caamuiodev->uio_info.priv = caamuiodev;
+
+	caamuiodev->uio_info.irq = of_irq_to_resource(np, 0, NULL);
+	caamuiodev->uio_info.irq_flags = IRQF_SHARED;
+	caamuiodev->uio_info.handler = caam_uio_jr_interrupt;
+	caamuiodev->uio_info.irqcontrol = caam_uio_irq_control;
+
+	caamuiodev->uio_info.mmap = NULL;
+	caamuiodev->uio_info.open = NULL;
+	caamuiodev->uio_info.release = NULL;
+
+	caamuiodev->uio_rid = rid;
+	caamuiodev->ctrlpriv = dev_get_drvdata(dev);
+	caamuiodev->rregs =
+	    (struct caam_job_ring __iomem *)((void *)caamuiodev->ctrlpriv->
+					     ctrl + jroffset[0]);
+
+	ret = uio_register_device(dev, &caamuiodev->uio_info);
+	if (ret) {
+		dev_err(dev, "uio_register_device() failed for Job Ring %d\n",
+			rid);
+		kfree(caamuiodev);
+		return ret;
+	}
+
+	caamuiodev->ctrlpriv->uiodev[ridx] = &caamuiodev->uio_info;
+
+	return 0;
+}
+
+static int __init caam_uio_init(void)
+{
+	struct device_node *dev_node, *np;
+	struct of_device *ofdev;
+	struct device *ctrldev;
+	struct caam_drv_private *ctrlpriv;
+	int ridx, rid;
+
+	dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec-v4.0");
+	if (!dev_node)
+		return -ENODEV;
+
+	ofdev = of_find_device_by_node(dev_node);
+	if (!ofdev)
+		return -ENODEV;
+
+	ctrldev = &ofdev->dev;
+	ctrlpriv = dev_get_drvdata(ctrldev);
+	of_node_put(dev_node);
+
+	if (ctrlpriv->nr_uio_jrs) {
+		ctrlpriv->uiodev =
+		    kzalloc(sizeof(struct uio_info *) * ctrlpriv->nr_uio_jrs,
+			    GFP_KERNEL);
+		if (ctrlpriv->uiodev == NULL)
+			return -ENOMEM;
+		dev_info(ctrldev, "Job Rings configured for user space = %d\n",
+			 ctrlpriv->nr_uio_jrs);
+	} else {
+		dev_err(ctrldev, "No Job Ring configured for user space\n");
+		return -ENODEV;
+	}
+
+	ridx = 0;
+	rid = 0;
+	for_each_compatible_node(np, NULL, "fsl,sec-v4.0-job-ring") {
+		if (of_get_property(np, "user-space-ring", NULL)) {
+			caam_uio_init_jr(ofdev, np, ridx, rid);
+			ridx++;
+		}
+
+		rid++;
+	}
+
+	return 0;
+}
+
+static void __exit caam_uio_exit(void)
+{
+	struct device_node *dev_node;
+	struct of_device *ofdev;
+	struct device *ctrldev;
+	struct caam_drv_private *ctrlpriv;
+	struct caam_uio_device *caamuiodev;
+	struct uio_info *info;
+	int i;
+
+	dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec-v4.0");
+	if (!dev_node)
+		return;
+
+	ofdev = of_find_device_by_node(dev_node);
+	if (!ofdev)
+		return;
+
+	ctrldev = &ofdev->dev;
+	ctrlpriv = dev_get_drvdata(ctrldev);
+	of_node_put(dev_node);
+
+	for (i = 0; i < ctrlpriv->nr_uio_jrs; i++) {
+		info = ctrlpriv->uiodev[i];
+		caamuiodev = info->priv;
+		uio_unregister_device(info);
+		kfree(caamuiodev);
+	}
+
+	kfree(ctrlpriv->uiodev);
+}
+
+module_init(caam_uio_init);
+module_exit(caam_uio_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("FSL CAAM UIO support");
+MODULE_AUTHOR("Freescale Semiconductor - NMG/IDC");
diff --git a/drivers/crypto/caam/caamuio.h b/drivers/crypto/caam/caamuio.h
new file mode 100644
index 0000000..95dd009
--- /dev/null
+++ b/drivers/crypto/caam/caamuio.h
@@ -0,0 +1,26 @@
+/*
+ * CAAM UIO support header.
+ * Definitions for enabling CAAM block to be accessed directly from user space
+ *
+ * Copyright 2011 Freescale Semiconductor, Inc
+ */
+
+#ifndef CAAMUIO_H
+#define CAAMUIO_H
+
+/** Name of UIO device*/
+#define SEC_UIO_DEVICE_NAME "sec-job-ring"
+/** UIO char driver version */
+#define SEC_UIO_VERSION     "1.0"
+
+/** UIO command used by user-space driver to request
+ *  disabling IRQs on a certain job ring */
+#define SEC_UIO_DISABLE_IRQ_CMD         0
+/** UIO command used by user-space driver to request
+ *  enabling IRQs on a certain job ring */
+#define SEC_UIO_ENABLE_IRQ_CMD          1
+/** UIO command used by user-space driver to request SEC kernel driver
+ *  to simulate that an IRQ is generated on a certain job ring */
+#define SEC_UIO_SIMULATE_IRQ_CMD        2
+
+#endif /* CAAMUIO_H */
diff --git a/drivers/crypto/caam/ctrl.c b/drivers/crypto/caam/ctrl.c
index 48fa36c..d5a4860 100644
--- a/drivers/crypto/caam/ctrl.c
+++ b/drivers/crypto/caam/ctrl.c
@@ -17,13 +17,15 @@ static int caam_remove(struct of_device *ofdev)
 	struct caam_drv_private_jr *jrpriv;
 	struct caam_full __iomem *topregs;
 	int ring, ret = 0;
+	int nr_kernel_jrs;
 
 	ctrldev = &ofdev->dev;
 	ctrlpriv = dev_get_drvdata(ctrldev);
 	topregs = (struct caam_full __iomem *)ctrlpriv->ctrl;
 
+	nr_kernel_jrs = ctrlpriv->total_jobrs - ctrlpriv->nr_uio_jrs;
 	/* shut down JobRs */
-	for (ring = 0; ring < ctrlpriv->total_jobrs; ring++) {
+	for (ring = 0; ring < nr_kernel_jrs; ring++) {
 		ret |= caam_jr_shutdown(ctrlpriv->jrdev[ring]);
 		jrpriv = dev_get_drvdata(ctrlpriv->jrdev[ring]);
 		irq_dispose_mapping(jrpriv->irq);
@@ -47,7 +49,7 @@ static int caam_remove(struct of_device *ofdev)
 static int caam_probe(struct of_device *ofdev,
 		      const struct of_device_id *devmatch)
 {
-	int d, ring, rspec;
+	int d, ring, rspec, uspec;
 	struct device *dev;
 	struct device_node *nprop, *np;
 	struct caam_ctrl __iomem *ctrl;
@@ -108,20 +110,33 @@ static int caam_probe(struct of_device *ofdev,
 	 * for all, then go probe each one.
 	 */
 	rspec = 0;
-	for_each_compatible_node(np, NULL, "fsl,sec-v4.0-job-ring")
-		rspec++;
-	ctrlpriv->jrdev = kzalloc(sizeof(struct device *) * rspec, GFP_KERNEL);
-	if (ctrlpriv->jrdev == NULL) {
-		iounmap(&topregs->ctrl);
-		return -ENOMEM;
+	uspec = 0;
+	for_each_compatible_node(np, NULL, "fsl,sec-v4.0-job-ring") {
+		if (of_get_property(np, "user-space-ring", NULL))
+			uspec++;
+		else
+			rspec++;
 	}
 
+	if (rspec) {
+		ctrlpriv->jrdev = kzalloc(sizeof(struct device *) * rspec,
+					  GFP_KERNEL);
+		if (ctrlpriv->jrdev == NULL) {
+			iounmap(&topregs->ctrl);
+			return -ENOMEM;
+		}
+	}
+
+	ctrlpriv->nr_uio_jrs = uspec;
 	ring = 0;
 	ctrlpriv->total_jobrs = 0;
 	for_each_compatible_node(np, NULL, "fsl,sec-v4.0-job-ring") {
-		caam_jr_probe(ofdev, np, ring);
+		if (!of_get_property(np, "user-space-ring", NULL)) {
+			caam_jr_probe(ofdev, np, ring);
+			ring++;
+		}
+
 		ctrlpriv->total_jobrs++;
-		ring++;
 	}
 
 	/* Check to see if QI present. If so, enable */
diff --git a/drivers/crypto/caam/intern.h b/drivers/crypto/caam/intern.h
index 116e663..7f00e96 100644
--- a/drivers/crypto/caam/intern.h
+++ b/drivers/crypto/caam/intern.h
@@ -26,6 +26,9 @@
 #define JOBR_INTC_COUNT_THLD 0
 #endif
 
+#include <linux/uio_driver.h>
+
+
 /*
  * Storage for tracking each in-process entry moving across a ring
  * Each entry on an output ring needs one of these
@@ -74,6 +77,9 @@ struct caam_drv_private {
 	/* Non-OF-specific defs */
 #endif
 
+	struct uio_info **uiodev;	/* Array for user space job rings */
+	u8 nr_uio_jrs;			/* Total user space job rings */
+
 	/* Physical-presence section */
 	struct caam_ctrl *ctrl; /* controller region */
 	struct caam_deco **deco; /* DECO/CCB views */
diff --git a/drivers/crypto/caam/jr.c b/drivers/crypto/caam/jr.c
index eb2b858..4cf6837 100644
--- a/drivers/crypto/caam/jr.c
+++ b/drivers/crypto/caam/jr.c
@@ -150,10 +150,13 @@ int caam_jr_register(struct device *ctrldev, struct device **rdev)
 	struct caam_drv_private_jr *jrpriv = NULL;
 	unsigned long flags;
 	int ring;
+	u8 nr_kernel_jrs;
+
+	nr_kernel_jrs = ctrlpriv->total_jobrs - ctrlpriv->nr_uio_jrs;
 
 	/* Lock, if free ring - assign, unlock */
 	spin_lock_irqsave(&ctrlpriv->jr_alloc_lock, flags);
-	for (ring = 0; ring < ctrlpriv->total_jobrs; ring++) {
+	for (ring = 0; ring < nr_kernel_jrs; ring++) {
 		jrpriv = dev_get_drvdata(ctrlpriv->jrdev[ring]);
 		if (jrpriv->assign == JOBR_UNASSIGNED) {
 			jrpriv->assign = JOBR_ASSIGNED;
-- 
1.7.0

