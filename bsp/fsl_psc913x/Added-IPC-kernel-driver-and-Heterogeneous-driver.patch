From 76247a8e5d02bc5e4a88e4ab3ee0d72796b3518c Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Tue, 15 Nov 2011 16:39:39 +0800
Subject: [PATCH 18/92] Added IPC kernel driver and Heterogeneous driver

Extracted from 913x_WUSDK_REL_0.4.tar.gz vendor drop.

Added IPC kernel driver and Heterogeneous driver.

Signed-off-by: Harninder Rai <harninder.rai@freescale.com>
Signed-off-by: Manish Jaggi  <manish.jaggi@freescale.com>

[ Merge 0471-Added-IPC-kernel-driver-and-Heterogeneous-driver.patch and
  0501-IPC-Checkpatch-error-correction-and-code-cleanup.patch.
  Remove PSC9131QDS information.]

Signed-off-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/misc/Kconfig              |    8 +
 drivers/misc/Makefile             |    2 +
 drivers/misc/fsl_het_mgr.h        |   36 ++++
 drivers/misc/fsl_ipc_kmod.h       |   41 +++++
 drivers/misc/fsl_psc913x_hetmgr.c |  352 +++++++++++++++++++++++++++++++++++++
 drivers/misc/fsl_psc913x_ipc.c    |  317 +++++++++++++++++++++++++++++++++
 drivers/misc/fsl_types.h          |   72 ++++++++
 7 files changed, 828 insertions(+), 0 deletions(-)
 create mode 100644 drivers/misc/fsl_het_mgr.h
 create mode 100644 drivers/misc/fsl_ipc_kmod.h
 create mode 100644 drivers/misc/fsl_psc913x_hetmgr.c
 create mode 100644 drivers/misc/fsl_psc913x_ipc.c
 create mode 100644 drivers/misc/fsl_types.h

diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index a98566d..a878ba8 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -425,4 +425,12 @@ config RAM_CONSOLE_EARLY_SIZE
         default 0
         depends on RAM_CONSOLE_EARLY_INIT
 
+config PSC9131_HET_IPC
+	tristate "Freescale PSC9131 Heterogeneous IPC driver"
+	depends on PSC9131_RDB || PSC9131_HET_MGR
+
+config PSC9131_HET_MGR
+	tristate "Freescale PSC9131 Heterogeneous Manager driver"
+	depends on PSC9131_RDB
+
 endif # MISC_DEVICES
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index b9f6c4e..f9ab51f 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -28,6 +28,8 @@ obj-$(CONFIG_DS1682)		+= ds1682.o
 obj-$(CONFIG_TI_DAC7512)	+= ti_dac7512.o
 obj-$(CONFIG_C2PORT)		+= c2port/
 obj-$(CONFIG_IWMC3200TOP)      += iwmc3200top/
+obj-$(CONFIG_PSC9131_HET_IPC)	+= fsl_psc913x_ipc.o
+obj-$(CONFIG_PSC9131_HET_MGR)	+= fsl_psc913x_hetmgr.o
 obj-y				+= eeprom/
 obj-y				+= cb710/
 obj-$(CONFIG_VMWARE_BALLOON)	+= vmware_balloon.o
diff --git a/drivers/misc/fsl_het_mgr.h b/drivers/misc/fsl_het_mgr.h
new file mode 100644
index 0000000..e88a319
--- /dev/null
+++ b/drivers/misc/fsl_het_mgr.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _FSL_HET_MGR_H
+#define _FSL_HET_MGR_H
+
+#include <linux/ioctl.h>
+
+#include "fsl_types.h"
+#define HET_MGR_MAGIC	'S'
+#define IOCTL_HET_MGR_GET_SYS_MAP	_IOR(HET_MGR_MAGIC, 1, sys_map_t *)
+#define IOCTL_HET_MGR_V2P		_IOR(HET_MGR_MAGIC, 2, range_t *)
+#define IOCTL_HET_MGR_SET_SHMID		_IOW(HET_MGR_MAGIC, 3, uint32_t)
+#define IOCTL_HET_MGR_GET_SHMID		_IOR(HET_MGR_MAGIC, 4, uint32_t *)
+#define IOCTL_HET_MGR_SET_SHARED_AREA	_IOW(HET_MGR_MAGIC, 5, shared_area_t*)
+#define IOCTL_HET_MGR_SET_INITIALIZED	_IOW(HET_MGR_MAGIC, 6, uint32_t)
+#define	IOCTL_HW_SEM_GET_VALUE 		_IOR(HET_MGR_MAGIC, 7, hw_sem_t*)
+#define	IOCTL_HW_SEM_SET_VALUE 		_IOW(HET_MGR_MAGIC, 8, hw_sem_t*)
+#define IOCTL_HW_SEM_GET_UVALUE 	_IOR(HET_MGR_MAGIC, 9, hw_sem_info_t*)
+
+#endif
diff --git a/drivers/misc/fsl_ipc_kmod.h b/drivers/misc/fsl_ipc_kmod.h
new file mode 100644
index 0000000..3d17926
--- /dev/null
+++ b/drivers/misc/fsl_ipc_kmod.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef IPC_KERN_MOD_H
+#define IPC_KERN_MOD_H
+
+#include "fsl_types.h"
+#include <linux/ioctl.h>
+
+#define MAX_SC_PA_CHANNELS	32
+
+typedef struct {
+	uint32_t	max_channels;
+	uint32_t	max_depth;
+} ipc_bootargs_info_t;
+
+typedef struct {
+	uint32_t	channel_id;
+	uint32_t	signal;
+} ipc_rc_t;
+
+#define IPC_MAGIC	'S'
+#define	IOCTL_IPC_GET_PARAMS _IOR(IPC_MAGIC, 1, ipc_bootargs_info_t *)
+#define	IOCTL_IPC_REGISTER_SIGNAL _IOR(IPC_MAGIC, 2, ipc_rc_t *)
+
+#endif
diff --git a/drivers/misc/fsl_psc913x_hetmgr.c b/drivers/misc/fsl_psc913x_hetmgr.c
new file mode 100644
index 0000000..32b5a53
--- /dev/null
+++ b/drivers/misc/fsl_psc913x_hetmgr.c
@@ -0,0 +1,352 @@
+/*
+ *  @ fsl_psc913x_ipc_kern_mod.c
+ *
+ * Copyright (c) 2011, Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Freescale Semiconductor Inc nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *      Author: Manish Jaggi <manish.jaggi@freescale.com>
+ */
+#include "fsl_types.h"
+#include "fsl_het_mgr.h"
+#include <linux/mm.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <asm/uaccess.h>
+#include "psc913x_heterogeneous.h"
+/*
+ *
+ */
+
+#define HW_SEM_OFFSET	0x17100
+
+int devno;
+dev_t dev;
+struct cdev cdev;
+uint32_t het_mgr_major;
+uint32_t het_mgr_minor;
+sys_map_t sys_map;
+
+int shmid;
+volatile void	*sem;
+shared_area_t shared_area;
+phys_addr_t sh_ctrl_area_mark;
+volatile os_het_control_t	*ctrl;
+
+static int het_mgr_open(struct inode *inode, struct file *filep);
+static int het_mgr_release(struct inode *inode, struct file *filep);
+static int het_mgr_ioctl(struct inode *inode, struct file *filp,
+		unsigned int cmd, unsigned long arg);
+
+int init_sh_ctrl_area(void)
+{
+	int ctr = 0;
+	uint32_t tmp;
+
+	pr_info("Initializing Shared control area\n");
+	pr_info("Shared Control area start address = %x\n",
+			sys_map.sh_ctrl_area.phys_addr);
+
+	ctrl = (volatile os_het_control_t *)ioremap(
+		sys_map.sh_ctrl_area.phys_addr, sys_map.sh_ctrl_area.size);
+	memset((void *)ctrl, 0, 0x4000);
+
+	/* zeroize the structure */
+	ctr += sizeof(os_het_control_t);
+
+	ctrl->shared_ctrl_size = 0x4000; /* 16k */
+	/* set the physical adress for ipc */
+	/* casting is done just to avoid compilation errors */
+	ctrl->ipc =  (os_het_ipc_t *)(sys_map.sh_ctrl_area.phys_addr + ctr);
+	pr_info("IPC structure start address = %x\n",
+			sys_map.sh_ctrl_area.phys_addr + ctr);
+	ctr += sizeof(os_het_ipc_t);
+
+	tmp = sys_map.sh_ctrl_area.phys_addr + ctr;
+
+	memcpy((void *)&ctrl->smartdsp_debug, &tmp, sizeof(uint32_t));
+	pr_info("Smart DSP Debug start address = %x\n", tmp);
+
+	ctr += sizeof(os_het_smartdsp_log_t) * 2;
+	sh_ctrl_area_mark = sys_map.sh_ctrl_area.phys_addr + ctr;
+
+	pr_info("Free Area starts from %x\n", sh_ctrl_area_mark);
+
+	return 0;
+}
+
+int init_hw_sem(void)
+{
+	sem = ioremap(sys_map.dsp_ccsrbar.phys_addr + HW_SEM_OFFSET, 0x100);
+	if (sem == (void *)0xffffffff) {
+		pr_err("Error in ioremap %x\n", (uint32_t)sem);
+		return -1;
+	}
+
+	pr_info("virt addr = %x\n", (uint32_t)sem);
+
+	return 0;
+}
+
+int hugev2p(range_t *r)
+{
+	int ret = 0;
+	struct task_struct *tsk;
+	struct mm_struct *mm;
+	unsigned long start;
+	int len;
+	int write;
+	int force;
+	struct page *pages = NULL;
+	struct vm_area_struct *vmas = NULL;
+	int npages;
+
+	tsk = current;
+	mm = current->mm;
+	start = (unsigned long)r->vaddr;
+	len = 1;
+	write = 0;
+	force = 0;
+
+	down_read(&current->mm->mmap_sem);
+	ret = get_user_pages(tsk, mm, start, len, write, force, &pages, &vmas);
+	up_read(&current->mm->mmap_sem);
+	if (ret > 0) {
+		npages = ret;
+		struct page *pg = &pages[0];
+		pr_info("%x Addr\n", page_to_phys(pg));
+		r->phys_addr = page_to_phys(pg);
+		put_page(pg);
+	}
+
+	return 0;
+}
+/*
+Temp function:
+this would be removed when the same is provided from 9131plat file
+*/
+int get_het_sys_map(sys_map_t *sysmap)
+{
+	sysmap->pa_ccsrbar.phys_addr = 0xff700000;
+	sysmap->pa_ccsrbar.size = 0x100000;
+
+	sysmap->dsp_ccsrbar.phys_addr = 0xff600000;
+	sysmap->dsp_ccsrbar.size = 0x100000;
+
+	sysmap->linux_priv_area.phys_addr = 0x0;
+	sysmap->linux_priv_area.size = 0x28000000;
+
+	sysmap->smart_dsp_os_priv_area.phys_addr = 0x28000000;
+	sysmap->smart_dsp_os_priv_area.size = 0x10000000;
+
+	sysmap->sh_ctrl_area.phys_addr = 0x38000000;
+	sysmap->sh_ctrl_area.size = 0x8000000;
+
+	sysmap->dsp_core0_m2.phys_addr = 0xb0000000;
+	sysmap->dsp_core0_m2.size = 0x80000;
+
+	return 0;
+}
+
+int get_hetmgr_ipc_addr(range_t *r)
+{
+	r->phys_addr = (phys_addr_t)ctrl->ipc;
+	r->vaddr = (void *)ctrl + ((uint32_t)ctrl->ipc -
+			sys_map.sh_ctrl_area.phys_addr);
+	r->size = sizeof(os_het_ipc_t);
+
+	return 0;
+}
+EXPORT_SYMBOL(get_hetmgr_ipc_addr);
+
+int get_hetmgr_mem(range_t *r)
+{
+	r->phys_addr = sh_ctrl_area_mark;
+	r->vaddr = (void *)ctrl + (sh_ctrl_area_mark -
+			sys_map.sh_ctrl_area.phys_addr);
+	sh_ctrl_area_mark += r->size;
+
+	return 0;
+}
+EXPORT_SYMBOL(get_hetmgr_mem);
+
+static int het_mgr_open(struct inode *inode, struct file *filep)
+{
+	return 0;
+}
+
+static int het_mgr_release(struct inode *inode, struct file *filep)
+{
+	return 0;
+}
+
+static int het_mgr_ioctl(struct inode *inode, struct file *filp,
+		unsigned int cmd, unsigned long arg)
+{
+	int ret = 0;
+	sys_map_t *tmp_sys_map;
+	range_t	*tmp;
+	range_t r;
+	hw_sem_info_t	hinfo;
+	hw_sem_t	hwsem;
+
+	switch (cmd) {
+	case IOCTL_HET_MGR_GET_SYS_MAP:
+		tmp_sys_map = (sys_map_t *)arg;
+		copy_to_user(tmp_sys_map, &sys_map, sizeof(sys_map_t));
+		break;
+
+	case IOCTL_HET_MGR_V2P:
+		tmp = (range_t *)arg;
+		copy_from_user(&r, tmp, sizeof(range_t));
+		pr_info("Virt Address=%x Size=%x\n", (uint32_t)r.vaddr, r.size);
+		ret = hugev2p(&r);
+		copy_to_user(tmp, &r, sizeof(range_t));
+		break;
+
+	case IOCTL_HET_MGR_SET_SHMID:
+		copy_from_user(&shmid, (uint32_t *)arg, sizeof(uint32_t));
+		break;
+
+	case IOCTL_HET_MGR_GET_SHMID:
+		copy_to_user((uint32_t *)arg, &shmid, sizeof(uint32_t));
+		break;
+
+	case IOCTL_HET_MGR_SET_SHARED_AREA:
+		copy_from_user(&shared_area, (shared_area_t *)arg,
+				sizeof(shared_area_t));
+		ctrl->pa_shared_mem.start_addr =
+			shared_area.pa_ipc_shared.phys_addr;
+		ctrl->pa_shared_mem.size = shared_area.pa_ipc_shared.size;
+
+		ctrl->sc_shared_mem.start_addr =
+			shared_area.dsp_ipc_shared.phys_addr;
+		ctrl->sc_shared_mem.size = shared_area.dsp_ipc_shared.size;
+		break;
+
+	case IOCTL_HET_MGR_SET_INITIALIZED:
+		ctrl->initialized.pa_initialized = OS_HET_INITIALIZED;
+		ctrl->initialized.sc_initialized = OS_HET_UNINITIALIZED;
+		break;
+
+	case IOCTL_HW_SEM_GET_UVALUE:
+		hinfo.pa_uniq_val = OS_HET_PA_SEMAPHORE_VAL;
+		hinfo.dsp_uniq_val = OS_HET_SC_SEMAPHORE_VAL;
+		copy_to_user((void *)arg, &hinfo, sizeof(hw_sem_info_t));
+		break;
+
+	case IOCTL_HW_SEM_SET_VALUE:
+		copy_from_user(&hwsem, (void *)arg, sizeof(hw_sem_t));
+		*(uint32_t *)(sem + hwsem.sem_no*0x8) = hwsem.value ;
+		break;
+
+	case IOCTL_HW_SEM_GET_VALUE:
+		copy_from_user(&hwsem, (void *)arg, sizeof(hw_sem_t));
+		pr_info("\n Addr %x Val %x\n", (uint32_t)(sem +
+			hwsem.sem_no*0x8), *(uint32_t *)(sem +
+			hwsem.sem_no*0x8));
+		hwsem.value = *(uint32_t *)(sem + hwsem.sem_no*0x8) ;
+		copy_to_user((void *)arg, &hwsem, sizeof(hw_sem_t));
+		break;
+
+	default:
+		return -ENOTTY;
+	}
+
+	return ret;
+}
+/*
+file operations data structure
+*/
+static const struct file_operations het_mgr_fops = {
+	.owner	= THIS_MODULE,
+	.open = 	het_mgr_open,
+	.release =	het_mgr_release,
+	.ioctl =  	het_mgr_ioctl,
+};
+
+int het_mgr_init(void)
+{
+	int ret;
+	het_mgr_major = 0;
+	het_mgr_minor = 0;
+	dev = 0;
+	/*register /dev/het_mgr character driver */
+	if (het_mgr_major) {
+		dev = MKDEV(het_mgr_major, het_mgr_minor);
+		ret = register_chrdev_region(dev, 1, "/dev/het_mgr");
+
+	} else {
+		ret = alloc_chrdev_region(&dev, het_mgr_minor,
+				1, "/dev/het_mgr");
+		het_mgr_major = MAJOR(dev);
+	}
+
+	if (ret < 0) {
+		pr_err("het_mgr_dev: can't get major %d\n", het_mgr_major);
+		return ret;
+	}
+
+	devno = MKDEV(het_mgr_major, het_mgr_minor);
+	pr_info("Het Mgr %d %d\n", het_mgr_major, het_mgr_minor);
+	cdev_init(&cdev, &het_mgr_fops);
+	cdev.owner = THIS_MODULE;
+	cdev.ops = &het_mgr_fops;
+	ret = cdev_add (&cdev, devno, 1);
+
+	/* Fail gracefully if need be */
+	if (ret) {
+		pr_err("Error %d adding Heterogeneous System Manager", ret);
+		return ret;
+	}
+
+	ret = get_het_sys_map(&sys_map);
+	if (ret)
+		goto end;
+
+	ret = init_sh_ctrl_area();
+	if (ret)
+		goto end;
+
+	ret = init_hw_sem();
+	if (ret)
+		goto end;
+
+end:
+	return ret;
+}
+
+void het_mgr_exit(void)
+{
+	cdev_del(&cdev);
+	unregister_chrdev_region(dev, 1);
+}
+
+MODULE_AUTHOR("manish.jaggi@freescale.com");
+MODULE_DESCRIPTION("Heterogeneous System Manager driver");
+MODULE_LICENSE("GPL");
+
+module_init(het_mgr_init);
+module_exit(het_mgr_exit);
diff --git a/drivers/misc/fsl_psc913x_ipc.c b/drivers/misc/fsl_psc913x_ipc.c
new file mode 100644
index 0000000..c730566
--- /dev/null
+++ b/drivers/misc/fsl_psc913x_ipc.c
@@ -0,0 +1,317 @@
+/*
+ *  @ fsl_psc913x_ipc_kern_mod.c
+ *
+ * Copyright (c) 2011, Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of Freescale Semiconductor Inc nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *      Author: Manish Jaggi <manish.jaggi@freescale.com>
+ */
+#include "fsl_types.h"
+#include "fsl_het_mgr.h"
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <linux/cdev.h>
+#include <asm/fsl_msg.h>
+#include "psc913x_heterogeneous.h"
+#include "psc913x_heterogeneous_ipc.h"
+#include "fsl_ipc_kmod.h"
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/dma-mapping.h>
+#include <linux/sched.h>
+#include <linux/fcntl.h>
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#define MAX_IPC_CHANNELS 64
+#define MAX_MSG_IRQ	4
+
+/*
+Data Structure to store the callback handlers for channels
+*/
+typedef struct {
+	int 		sig;
+	spinlock_t	lock;
+	struct	pid	*pid;
+	struct	siginfo siginfo;
+} user_irq_t;
+
+/* IRQ - MSG related */
+int msg_irq_cnt;
+user_irq_t	uirq[MAX_MSG_IRQ];
+user_irq_t user_irq_arr[MAX_SC_PA_CHANNELS];
+struct fsl_msg_unit *ipc_msg_intr[MAX_MSG_IRQ];
+
+int devno;
+dev_t dev;
+struct cdev cdev;
+uint32_t het_ipc_major;
+uint32_t het_ipc_minor;
+
+/*IPC */
+os_het_ipc_channel_t *ch;
+os_het_ipc_t *ipc;
+
+/* From bootargs */
+int num_channels, channel_depth;
+
+int get_hetmgr_ipc_addr(range_t *);
+int get_hetmgr_mem(range_t *);
+void open_channel_zero(void);
+extern struct fsl_msg_unit *fsl_get_msg_unit(void);
+
+static long get_max_num_ipc_channels(void)
+{
+	return 64;
+}
+
+static long get_max_channel_depth(void)
+{
+	return 16;
+}
+
+/*******************************
+ * Interrupt Handlers
+ ******************************/
+static irqreturn_t msg_intr(int irq, void *dev_id)
+{
+	int i;
+	struct task_struct *dst_tsk;
+	pr_info("Recvd %x intr\n", irq);
+	for (i = 0; i < MAX_MSG_IRQ; i++) {
+		if (ipc_msg_intr[i]->irq == irq) {
+			fsl_clear_msg(ipc_msg_intr[i]);
+			/* push the signal */
+			dst_tsk = pid_task(uirq[i].pid, PIDTYPE_PID);
+			if (dst_tsk) {
+				send_sig_info(uirq[i].siginfo.si_signo,
+					&uirq[i].siginfo, dst_tsk);
+			}
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+void register_msg_intr(void)
+{
+	int err, i;
+	struct fsl_msg_unit *msg;
+
+	for (i = 0; i < MAX_MSG_IRQ; i++) {
+		msg = fsl_get_msg_unit();
+		if (msg) {
+			pr_info("msg irq %x msg num %x\n", msg->irq,
+				msg->msg_num);
+			fsl_enable_msg(msg);
+			ipc_msg_intr[i] = msg;
+#if defined(CONFIG_PREEMPT_HARDIRQS)
+			err = request_irq(msg->irq, msg_intr, IRQF_NODELAY,
+				"IPC_MSG", NULL);
+#else
+			err = request_irq(msg->irq, msg_intr, 0, "IPC_MSG",
+				 NULL);
+#endif
+			pr_info("request_irq err = %x\n", err);
+		}
+	}
+}
+/*
+ * @fsl_913xipc_init
+ *
+ *This method is called by het_ipc to initialize ipc ptr channels
+ *It is assumed that the caller (het_ipc) has mapped ipc structre
+ *already at this address
+*/
+int fsl_913xipc_init(void)
+{
+	int ret = 0;
+	int i = 0;
+	range_t r, r1;
+	phys_addr_t phys_addr, phys_addr1;
+
+	ret = get_hetmgr_ipc_addr(&r);
+	if (ret)
+		goto end;
+	ipc = r.vaddr;
+	pr_err("os_het_ipc_t phys=%x vaddr=%x \n", (uint32_t)r.phys_addr,
+			(uint32_t)r.vaddr);
+
+	num_channels = get_max_num_ipc_channels();
+	channel_depth = get_max_channel_depth();
+
+	r1.size = sizeof(os_het_ipc_channel_t)*num_channels +
+		/* array to hold channel pointers */
+		sizeof(os_het_ipc_bd_t)*num_channels*channel_depth;
+		/* ptr channel ring buffer */
+
+	ret = get_hetmgr_mem(&r1);
+	if (ret)
+		goto end;
+
+	memcpy(&ipc->ipc_channels, &r1.phys_addr, sizeof(phys_addr_t));
+	ipc->num_ipc_channels = num_channels;
+	ipc->ipc_max_bd_size = channel_depth;
+	phys_addr = r1.phys_addr;
+	ch = (os_het_ipc_channel_t *)(r1.vaddr);
+	phys_addr1 = phys_addr + sizeof(os_het_ipc_channel_t)*num_channels;
+
+	/*
+		In a loop of num_channels, set the ptr of channel structures
+		in ipc->channels
+	*/
+
+	for (i = 0; i < num_channels; i++) {
+		ch[i].ipc_ind = OS_HET_NO_INT;
+		ch[i].id = i;
+		memcpy(&ch[i].bd_base, &phys_addr1, sizeof(phys_addr_t));
+		phys_addr1 += sizeof(os_het_ipc_bd_t)*channel_depth;
+	}
+	register_msg_intr();
+	open_channel_zero();
+end:
+	return ret;
+}
+
+void open_channel_zero(void)
+{
+	ch[0].consumer_initialized = OS_HET_INITIALIZED;
+	ch[0].id = 0;
+	ch[0].bd_ring_size = channel_depth;
+	ch[0].ch_type = OS_HET_IPC_POINTER_CH;
+}
+
+int het_ipc_ioctl(struct inode *inode, struct file *filp,
+		unsigned int cmd, unsigned long arg)
+{
+	unsigned long flags;
+	int ret = 0;
+	ipc_rc_t r;
+	switch (cmd) {
+	case IOCTL_IPC_REGISTER_SIGNAL:
+		copy_from_user(&r, (void *)arg, sizeof(ipc_rc_t));
+		if (msg_irq_cnt < MAX_MSG_IRQ) {
+			spin_lock_irqsave(&uirq[msg_irq_cnt].lock, flags);
+
+			uirq[msg_irq_cnt].pid = task_pid(current);
+			uirq[msg_irq_cnt].siginfo.si_signo = r.signal;
+			uirq[msg_irq_cnt].siginfo.si_errno = 0;
+			uirq[msg_irq_cnt].siginfo.si_code = SI_QUEUE;
+
+			spin_unlock_irqrestore(&uirq[msg_irq_cnt].lock, flags);
+
+			/* update channel structure with msg */
+			ch[r.channel_id].ipc_ind = OS_HET_PA_MPIC;
+			ch[r.channel_id].ind_offset = msg_irq_cnt;
+			ch[r.channel_id].ind_value = 0x12345678;
+
+			msg_irq_cnt++;
+		}
+		break;
+
+	default:  /* redundant, as cmd was checked against MAXNR */
+		return -ENOTTY;
+	}
+
+	return ret;
+}
+
+static int het_ipc_open(struct inode *inode, struct file *filep)
+{
+	return 0;
+}
+
+static int het_ipc_release(struct inode *inode, struct file *filep)
+{
+	return 0;
+}
+
+/*
+file operations data structure
+*/
+static const struct file_operations het_ipc_fops = {
+	.owner	= THIS_MODULE,
+	.open = 	het_ipc_open,
+	.release =	het_ipc_release,
+	.ioctl = 	het_ipc_ioctl,
+};
+
+
+int ipc_driver_init(void)
+{
+	int ret;
+	het_ipc_major = 0;
+	het_ipc_minor = 0;
+	dev = 0;
+	/*register /dev/het_ipc character driver */
+	if (het_ipc_major) {
+		dev = MKDEV(het_ipc_major, het_ipc_minor);
+		ret = register_chrdev_region(dev, 1, "/dev/het_ipc");
+
+	} else {
+		ret = alloc_chrdev_region(&dev, het_ipc_minor, 1,
+				"/dev/het_ipc");
+		het_ipc_major = MAJOR(dev);
+	}
+
+	if (ret < 0) {
+		pr_err("het_ipc_dev: can't get major %d\n", het_ipc_major);
+		return ret;
+	}
+
+	devno = MKDEV(het_ipc_major, het_ipc_minor);
+	pr_info("Het Ipc %d %d\n", het_ipc_major, het_ipc_minor);
+	cdev_init(&cdev, &het_ipc_fops);
+	cdev.owner = THIS_MODULE;
+	cdev.ops = &het_ipc_fops;
+	ret = cdev_add (&cdev, devno, 1);
+
+	/* Fail gracefully if need be */
+	if (ret)
+		pr_err("Error %d adding Heterogeneous System Manager", ret);
+
+	fsl_913xipc_init();
+
+	return 0;
+}
+
+void ipc_driver_exit(void)
+{
+	cdev_del(&cdev);
+	unregister_chrdev_region(dev, 1);
+}
+
+MODULE_AUTHOR("manish.jaggi@freescale.com");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("IPC kernel mode helper driver");
+
+module_init(ipc_driver_init);
+module_exit(ipc_driver_exit);
diff --git a/drivers/misc/fsl_types.h b/drivers/misc/fsl_types.h
new file mode 100644
index 0000000..742e8aa
--- /dev/null
+++ b/drivers/misc/fsl_types.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _FSL_TYPES_H
+#define _FSL_TYPES_H
+#ifdef __KERNEL__
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/fcntl.h>
+#include <linux/types.h>
+#else
+typedef unsigned long phys_addr_t;
+#endif
+typedef struct {
+	phys_addr_t	phys_addr;
+	uint32_t	size;
+} mem_t;
+
+typedef struct {
+	phys_addr_t phys_addr;
+	void    *vaddr;
+	uint32_t size;
+} range_t;
+
+
+typedef struct {
+	mem_t		pa_ccsrbar;
+	mem_t		dsp_ccsrbar;
+	mem_t		linux_priv_area;
+	mem_t		smart_dsp_os_priv_area;
+	mem_t		sh_ctrl_area;
+	mem_t		dsp_core0_m2;
+	mem_t		dsp_core1_m2;
+	mem_t		dsp_m3;
+	mem_t		dbg_area;
+} sys_map_t;
+
+typedef struct {
+	mem_t 	pa_ipc_shared;
+	mem_t	dsp_ipc_shared;
+	mem_t	pa_dbgprint_shared;
+	mem_t	dsp_dbgprint_shared;
+} shared_area_t;
+
+typedef struct {
+	uint32_t 	sem_no;
+	uint32_t	value;
+} hw_sem_t;
+
+typedef struct {
+	uint32_t	pa_uniq_val;
+	uint32_t	dsp_uniq_val;
+} hw_sem_info_t;
+
+
+#endif
-- 
1.7.0

