From a909b61968a69c334eaf5d47aa4b443c8727d34b Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Tue, 10 Jan 2017 21:38:53 +0800
Subject: [PATCH 36/56] edac: thunderx: Add EDAC driver for Cavium ThunderX

This patch adds EDAC driver for Cavium ThunderX SoCs for the Memory
controller and the Cache Coherent Processor Interconnect controller.

It comes from Cavium online SDK OCTEONTX-SDK-6.1.0-PR.

Signed-off-by: Sergey Temerkhanov <sergey.temerkhanov@auriga.com>
Signed-off-by: Radha Mohan Chintakuntla <rchintakuntla@cavium.com>
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/edac/Kconfig         |   10 +
 drivers/edac/Makefile        |    1 +
 drivers/edac/thunderx_edac.c | 1538 ++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 1549 insertions(+)
 create mode 100644 drivers/edac/thunderx_edac.c

diff --git a/drivers/edac/Kconfig b/drivers/edac/Kconfig
index b7e887c..b0127a8 100644
--- a/drivers/edac/Kconfig
+++ b/drivers/edac/Kconfig
@@ -385,6 +385,16 @@ config EDAC_OCTEON_PCI
 	  Support for error detection and correction on the
 	  Cavium Octeon family of SOCs.
 
+config EDAC_THUNDERX
+	tristate "Cavium ThunderX EDAC"
+	depends on EDAC_MM_EDAC
+	depends on ARM64
+	depends on PCI
+	help
+	  Support for error detection and correction on the Cavium
+	  ThunderX Memory Controller and Cache Coherent Processor
+	  Interconnect units.
+
 config EDAC_ALTERA
 	bool "Altera SOCFPGA ECC"
 	depends on EDAC_MM_EDAC=y && ARCH_SOCFPGA
diff --git a/drivers/edac/Makefile b/drivers/edac/Makefile
index da117ee..c075efc 100644
--- a/drivers/edac/Makefile
+++ b/drivers/edac/Makefile
@@ -68,6 +68,7 @@ obj-$(CONFIG_EDAC_OCTEON_PC)		+= octeon_edac-pc.o
 obj-$(CONFIG_EDAC_OCTEON_L2C)		+= octeon_edac-l2c.o
 obj-$(CONFIG_EDAC_OCTEON_LMC)		+= octeon_edac-lmc.o
 obj-$(CONFIG_EDAC_OCTEON_PCI)		+= octeon_edac-pci.o
+obj-$(CONFIG_EDAC_THUNDERX)		+= thunderx_edac.o
 
 obj-$(CONFIG_EDAC_ALTERA)		+= altera_edac.o
 obj-$(CONFIG_EDAC_SYNOPSYS)		+= synopsys_edac.o
diff --git a/drivers/edac/thunderx_edac.c b/drivers/edac/thunderx_edac.c
new file mode 100644
index 0000000..894c506
--- /dev/null
+++ b/drivers/edac/thunderx_edac.c
@@ -0,0 +1,1538 @@
+/*
+ * Cavium ThunderX memory controller kernel module
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright Cavium, Inc. (C) 2015. All rights reserved.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/edac.h>
+#include <linux/interrupt.h>
+#include <linux/string.h>
+#include <linux/stop_machine.h>
+#include <linux/delay.h>
+
+#include <asm/page.h>
+#include <asm/atomic.h>
+
+#include "edac_core.h"
+#include "edac_module.h"
+
+
+#define PCI_DEVICE_ID_THUNDER_LMC 0xa022
+
+#define LMC_FADR		0x20
+#define LMC_FADR_FDIMM(x)	((x >> 37) & 0x1)
+#define LMC_FADR_FBUNK(x)	((x >> 36) & 0x1)
+#define LMC_FADR_FBANK(x)	((x >> 32) & 0xf)
+#define LMC_FADR_FROW(x)	((x >> 17) & 0xfffe)
+#define LMC_FADR_FCOL(x)	((x >> 0) & 0x1fff)
+
+#define LMC_NXM_FADR		0x28
+#define LMC_ECC_SYND		0x38
+
+#define LMC_ECC_PARITY_TEST	0x108
+
+#define LMC_INT_W1S		0x150
+
+#define LMC_INT_ENA_W1C		0x158
+#define LMC_INT_ENA_W1S		0x160
+
+#define LMC_INT			0x1F0
+
+#define LMC_INT_MACRAM_DED_ERR	BIT(13)
+#define LMC_INT_MACRAM_SEC_ERR	BIT(12)
+#define LMC_INT_DDR_ERR		BIT(11)
+#define LMC_INT_DLCRAM_DED_ERR	BIT(10)
+#define LMC_INT_DLCRAM_SEC_ERR	BIT(9)
+#define LMC_INT_DED_ERR		(0xf << 5)
+#define LMC_INT_SEC_ERR		(0xf << 1)
+#define LMC_INT_NXM_WR_MASK	BIT(0)
+
+#define LMC_INT_UNCORR		(LMC_INT_MACRAM_DED_ERR | LMC_INT_DDR_ERR | \
+				 LMC_INT_DLCRAM_DED_ERR | LMC_INT_DED_ERR)
+
+#define LMC_INT_CORR		(LMC_INT_MACRAM_SEC_ERR | \
+				 LMC_INT_DLCRAM_SEC_ERR | LMC_INT_SEC_ERR)
+
+#define LMC_INT_UNKNOWN		(~0ULL - (LMC_INT_UNCORR | LMC_INT_CORR))
+
+#define LMC_INT_EN		0x1E8
+
+#define LMC_INT_EN_DDR_ERROR_ALERT_ENA	BIT(5)
+#define LMC_INT_EN_DLCRAM_DED_ERR	BIT(4)
+#define LMC_INT_EN_DLCRAM_SEC_ERR	BIT(3)
+#define LMC_INT_INTR_DED_ENA		BIT(2)
+#define LMC_INT_INTR_SEC_ENA		BIT(1)
+#define LMC_INT_INTR_NXM_WR_ENA		BIT(0)
+
+#define LMC_INT_EN_ALL			(BIT(14) - 1)
+#define LMC_INT_ENA_ALL			(BIT(14) - 1)
+
+#define LMC_DDR_PLL_CTL		0x258
+#define LMC_DDR_PLL_CTL_DDR4	BIT(29)
+
+#define LMC_CONTROL		0x190
+#define LMC_CONTROL_RDIMM	BIT(0)
+
+#define LMC_SCRAM_FADR		0x330
+
+#define LMC_CHAR_MASK0		0x228
+#define LMC_CHAR_MASK2		0x238
+
+struct debugfs_entry {
+	const char *name;
+	umode_t mode;
+	const struct file_operations fops;
+};
+
+#define to_mci(k) container_of(k, struct mem_ctl_info, dev)
+
+static ssize_t thunderx_mc_node_show(struct device *dev,
+				     struct device_attribute *mattr,
+				     char *data)
+{
+	struct mem_ctl_info *mci = to_mci(dev);
+	struct pci_dev *pdev = to_pci_dev(mci->pdev);
+	u64 node = (pci_resource_start(pdev, 0) >> 44) & 0x3;
+
+	return sprintf(data, "%u\n", (unsigned)node);
+}
+
+static ssize_t thunderx_mc_func_show(struct device *dev,
+				     struct device_attribute *mattr,
+				     char *data)
+{
+	struct mem_ctl_info *mci = to_mci(dev);
+	struct pci_dev *pdev = to_pci_dev(mci->pdev);
+	u64 func = PCI_FUNC(pdev->devfn);
+
+	return sprintf(data, "%u\n", (unsigned)func);
+}
+
+
+DEVICE_ATTR(node, S_IRUGO, thunderx_mc_node_show, NULL);
+DEVICE_ATTR(func, S_IRUGO, thunderx_mc_func_show, NULL);
+
+static struct attribute *thunderx_mc_attrs[] = {
+	&dev_attr_node.attr,
+	&dev_attr_func.attr,
+	NULL,
+};
+
+ATTRIBUTE_GROUPS(thunderx_mc);
+
+
+struct thunderx_lmc {
+	void __iomem *regs;
+	struct pci_dev *pdev;
+	struct msix_entry msix_ent;
+
+	struct dentry *debugfs;
+	atomic_t ecc_int;
+
+	u64 mask0;
+	u64 mask2;
+	u64 parity_test;
+	u64 node;
+	struct page *mem;
+	char buf[64];
+	char msg[64];
+	char other[64];
+};
+
+#define DEBUGFS_STRUCT(_name, _mode, _write, _read)			    \
+struct debugfs_entry debugfs_##_name = {				    \
+	.name = __stringify(_name),					    \
+	.mode = VERIFY_OCTAL_PERMISSIONS(_mode),			    \
+	.fops = {							    \
+		.open = simple_open,					    \
+		.write = _write,					    \
+		.read  = _read,						    \
+		.llseek = generic_file_llseek,				    \
+	},								    \
+};
+
+#define LMC_DEBUGFS_ENT(_field)						    \
+static ssize_t thunderx_lmc_##_field##_read(struct file *file,		    \
+					    char __user *data,		    \
+					    size_t count, loff_t *ppos)	    \
+{									    \
+	struct thunderx_lmc *lmc = file->private_data;			    \
+									    \
+	snprintf(lmc->buf, count, "0x%016llx", lmc->_field);		    \
+	return simple_read_from_buffer(data, count, ppos,		    \
+				       lmc->buf, sizeof(lmc->buf));	    \
+}									    \
+									    \
+static ssize_t thunderx_lmc_##_field##_write(struct file *file,		    \
+					     const char __user *data,	    \
+					     size_t count, loff_t *ppos)    \
+{									    \
+	struct thunderx_lmc *lmc = file->private_data;			    \
+	int res;							    \
+									    \
+	simple_write_to_buffer(lmc->buf, sizeof(lmc->buf), ppos,	    \
+			       data, count);				    \
+	lmc->buf[count] = '\0';						    \
+	res = kstrtoull(lmc->buf, 0, &lmc->_field);			    \
+									    \
+	return res ? res : count;					    \
+}									    \
+									    \
+DEBUGFS_STRUCT(_field, S_IWUSR | S_IRUSR,				    \
+		   thunderx_lmc_##_field##_write,			    \
+		   thunderx_lmc_##_field##_read);			    \
+
+/*
+ * To get an ECC error injected, the following steps are needed:
+ * - Setup the ECC injection by writing the appropriate parameters:
+ *	echo <bit mask value> > /sys/kernel/debug/<device number>/ecc_mask0
+ *	echo <bit mask value> > /sys/kernel/debug/<device number>/ecc_mask2
+ *	echo 0x802 > /sys/kernel/debug/<device number>/ecc_parity_test
+ * - Do the actual injection:
+ *	echo 1 > /sys/kernel/debug/<device number>/inject_ecc
+ */
+
+static ssize_t thunderx_lmc_inject_int_write(struct file *file,
+					     const char __user *data,
+					     size_t count, loff_t *ppos)
+{
+	struct thunderx_lmc *lmc = file->private_data;
+	u64 val;
+	int res;
+
+	simple_write_to_buffer(lmc->buf, sizeof(lmc->buf), ppos,
+			       data, count);
+	lmc->buf[count] = '\0';
+	res = kstrtoull(lmc->buf, 0, &val);
+
+	if (!res) {
+		/* Trigger the interrupt */
+		writeq(val, lmc->regs + LMC_INT_W1S);
+		res = count;
+	}
+
+	return res;
+}
+
+static ssize_t thunderx_lmc_int_read(struct file *file,
+				     char __user *data,
+				     size_t count, loff_t *ppos)
+{
+	struct thunderx_lmc *lmc = file->private_data;
+	u64 lmc_int = readq(lmc->regs + LMC_INT);
+
+	snprintf(lmc->buf, count, "0x%016llx", lmc_int);
+	return simple_read_from_buffer(data, count, ppos,
+				       lmc->buf, sizeof(lmc->buf));
+}
+
+
+#define TEST_PATTERN 0xa5
+
+int inject_ecc_fn(void *arg)
+{
+	struct thunderx_lmc *lmc = arg;
+	uintptr_t addr, phys;
+	unsigned int cline_size = cache_line_size();
+	const unsigned int lines = PAGE_SIZE / cline_size;
+	unsigned int i, cl_idx;
+
+	addr = (uintptr_t)page_address(lmc->mem);
+	phys = (uintptr_t)page_to_phys(lmc->mem);
+
+	cl_idx = (phys & 0x7f) >> 4;
+	lmc->parity_test &= ~(7ULL << 8);
+	lmc->parity_test |= (cl_idx << 8);
+
+	writeq(lmc->mask0, lmc->regs + LMC_CHAR_MASK0);
+	writeq(lmc->mask2, lmc->regs + LMC_CHAR_MASK2);
+	writeq(lmc->parity_test, lmc->regs + LMC_ECC_PARITY_TEST);
+
+	readq(lmc->regs + LMC_CHAR_MASK0);
+	readq(lmc->regs + LMC_CHAR_MASK2);
+	readq(lmc->regs + LMC_ECC_PARITY_TEST);
+
+	memset((void *)addr, TEST_PATTERN, PAGE_SIZE);
+
+	for (i = 0; i < lines; i++) {
+
+		/*
+		 * Do a cacheline PoC flush followed by invalidation
+		 * This should cause a DRAM write. Next load should
+		 * generate an error interrupt.
+		 */
+		asm volatile("dc civac, %0\n"
+			     "dsb sy\n"
+			     : : "r"(addr + i * cline_size));
+	}
+
+	for (i = 0; i < lines; i++) {
+		__asm__ volatile("sys #0,c11,C1,#2, %0\n"
+				 : : "r"(phys + i * cline_size));
+	}
+
+	for (i = 0; i < lines; i++) {
+		__asm__ volatile("sys #0,c11,C1,#1, %0"
+				 : : "r"(phys + i * cline_size));
+	}
+
+	for (i = 0; i < lines; i++) {
+		/* 
+		 * Do a cacheline PoC flush followed by invalidation
+		 * This should cause a DRAM write. Next load should
+		 * generate an error interrupt.
+		 */
+		asm volatile("dc ivac, %0\n"
+			     "dsb sy\n"
+			     : : "r"(addr + i * cline_size));
+	}
+
+	return 0;
+}
+
+static ssize_t thunderx_lmc_inject_ecc_write(struct file *file,
+					     const char __user *data,
+					     size_t count, loff_t *ppos)
+{
+	struct thunderx_lmc *lmc = file->private_data;
+
+	unsigned int cline_size = cache_line_size();
+
+	u8 tmp[cline_size];
+	void __iomem *addr;
+	unsigned int offs, timeout = 100000;
+
+	atomic_set(&lmc->ecc_int, 0);
+
+	lmc->mem = alloc_pages_node(lmc->node, GFP_KERNEL, 0);
+
+	if (!lmc->mem)
+		return -ENOMEM;
+
+	addr = page_address(lmc->mem);
+
+	while (!atomic_read(&lmc->ecc_int) && timeout--) {
+		stop_machine(inject_ecc_fn, lmc, NULL);
+
+		for (offs = 0; offs < PAGE_SIZE; offs += sizeof(tmp)) {
+			/* 
+			 * Do a load from the previously rigged location
+			 * This should generate an error interrupt.
+			 */
+			memcpy(tmp, addr + offs, cline_size);
+			asm volatile("dsb ld\n");
+		}
+	}
+
+	__free_pages(lmc->mem, 0);
+
+	return count;
+}
+
+LMC_DEBUGFS_ENT(mask0);
+LMC_DEBUGFS_ENT(mask2);
+LMC_DEBUGFS_ENT(parity_test);
+
+DEBUGFS_STRUCT(inject_int, S_IWUSR, thunderx_lmc_inject_int_write, NULL);
+DEBUGFS_STRUCT(inject_ecc, S_IWUSR, thunderx_lmc_inject_ecc_write, NULL);
+DEBUGFS_STRUCT(int_w1c, S_IRUSR, NULL, thunderx_lmc_int_read);
+
+struct debugfs_entry *lmc_dfs_attr[] = {
+	&debugfs_mask0,
+	&debugfs_mask2,
+	&debugfs_parity_test,
+	&debugfs_inject_ecc,
+	&debugfs_inject_int,
+	&debugfs_int_w1c,
+};
+
+static void thunderx_create_debugfs_nodes(struct dentry *parent,
+					  struct debugfs_entry *attrs[],
+					  void *data,
+					  size_t num)
+{
+	int i;
+
+	if (!IS_ENABLED(CONFIG_EDAC_DEBUG))
+		return;
+
+	if (!parent)
+		return;
+
+	for (i = 0; i < num; i++) {
+		debugfs_create_file(attrs[i]->name, attrs[i]->mode,
+					 parent, data, &attrs[i]->fops);
+	}
+}
+
+static irqreturn_t thunderx_lmc_err_isr(int irq, void *dev_id)
+{
+	struct mem_ctl_info *mci = dev_id;
+	struct thunderx_lmc *lmc = mci->pvt_info;
+	char msg[64], other[64];
+
+	u64 lmc_int, lmc_fadr, lmc_nxm_fadr,
+	    lmc_scram_fadr, lmc_ecc_synd;
+
+	writeq(0, lmc->regs + LMC_CHAR_MASK0);
+	writeq(0, lmc->regs + LMC_CHAR_MASK2);
+	writeq(0x2, lmc->regs + LMC_ECC_PARITY_TEST);
+
+	lmc_int = readq(lmc->regs + LMC_INT);
+	lmc_fadr = readq(lmc->regs + LMC_FADR);
+	lmc_nxm_fadr = readq(lmc->regs + LMC_NXM_FADR);
+	lmc_scram_fadr = readq(lmc->regs + LMC_SCRAM_FADR);
+	lmc_ecc_synd = readq(lmc->regs + LMC_ECC_SYND);
+
+	/* Clear the interrupt */
+	writeq(lmc_int, lmc->regs + LMC_INT);
+
+	atomic_set(&lmc->ecc_int, 1);
+
+	dev_dbg(&lmc->pdev->dev, "LMC_INT: %016llx\n", lmc_int);
+	dev_dbg(&lmc->pdev->dev, "LMC_FADR: %016llx\n", lmc_fadr);
+	dev_dbg(&lmc->pdev->dev, "LMC_NXM_FADR: %016llx\n", lmc_nxm_fadr);
+	dev_dbg(&lmc->pdev->dev, "LMC_SCRAM_FADR: %016llx\n", lmc_scram_fadr);
+	dev_dbg(&lmc->pdev->dev, "LMC_ECC_SYND: %016llx\n", lmc_ecc_synd);
+
+	snprintf(msg, sizeof(msg),
+		 "DIMM %lld rank %lld bank %lld row %lld col %lld",
+		 LMC_FADR_FDIMM(lmc_fadr), LMC_FADR_FBUNK(lmc_fadr),
+		 LMC_FADR_FBANK(lmc_fadr), LMC_FADR_FROW(lmc_fadr),
+		 LMC_FADR_FCOL(lmc_fadr));
+
+	snprintf(other, sizeof(other),
+		 "%s%s%s%s",
+		 lmc_int & (LMC_INT_DLCRAM_DED_ERR | LMC_INT_DLCRAM_SEC_ERR) ?
+			"DLC " : "",
+		 lmc_int & (LMC_INT_MACRAM_DED_ERR | LMC_INT_MACRAM_SEC_ERR) ?
+			"MAC " : "",
+		 lmc_int & (LMC_INT_DDR_ERR) ?
+			"DDR " : "",
+		 lmc_int & (LMC_INT_UNKNOWN) ?
+			"Unknown" : "");
+
+	if (lmc_int & LMC_INT_CORR)
+		edac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, 1, 0, 0, 0,
+				     -1, -1, -1, msg, other);
+
+	if (lmc_int & LMC_INT_UNCORR)
+		edac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, 1, 0, 0, 0,
+				     -1, -1, -1, msg, other);
+
+	if (lmc_int & LMC_INT_UNKNOWN)
+		edac_mc_handle_error(HW_EVENT_ERR_INFO, mci, 1, 0, 0, 0,
+				     -1, -1, -1, msg, other);
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_PM
+static int thunderx_lmc_suspend(struct pci_dev *pdev, pm_message_t state)
+{
+	pci_save_state(pdev);
+	pci_disable_device(pdev);
+
+	pci_set_power_state(pdev, pci_choose_state(pdev, state));
+
+	return 0;
+}
+
+static int thunderx_lmc_resume(struct pci_dev *pdev)
+{
+	pci_set_power_state(pdev, PCI_D0);
+	pci_enable_wake(pdev, PCI_D0, 0);
+	pci_restore_state(pdev);
+
+	return 0;
+}
+#endif
+
+static const struct pci_device_id thunderx_lmc_pci_tbl[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVICE_ID_THUNDER_LMC) },
+	{ 0, },
+};
+
+/*
+ * Per domain mappings (up to 4 domains):
+ *
+ *  domain 1: 0..3
+ *  domain 4: 4..7
+ */
+#define pci_dev_to_mc_idx(dev)	\
+	((pci_domain_nr((dev)->bus) & 6) | PCI_FUNC((dev)->devfn))
+
+static int thunderx_lmc_probe(struct pci_dev *pdev,
+				const struct pci_device_id *id)
+{
+	struct thunderx_lmc *lmc;
+	struct edac_mc_layer layer;
+	struct mem_ctl_info *mci;
+	u64 lmc_control, lmc_ddr_pll_ctl;
+	int err;
+	u64 lmc_int;
+
+	layer.type = EDAC_MC_LAYER_SLOT;
+	layer.size = 2;
+	layer.is_virt_csrow = false;
+
+	mci = edac_mc_alloc(pci_dev_to_mc_idx(pdev), 1, &layer,
+			    sizeof(struct thunderx_lmc));
+	if (!mci)
+		return -ENOMEM;
+
+	mci->pdev = &pdev->dev;
+	lmc = mci->pvt_info;
+
+	pci_set_drvdata(pdev, mci);
+
+	err = pcim_enable_device(pdev);
+	if (err) {
+		dev_err(&pdev->dev, "Cannot enable PCI device: %d\n", err);
+		goto err_kfree;
+	}
+
+	err = pcim_iomap_regions(pdev, 1 << 0, "thunderx_lmc");
+	if (err) {
+		dev_err(&pdev->dev, "Cannot map PCI resources: %d\n", err);
+		goto err_kfree;
+	}
+
+	lmc->regs = pcim_iomap_table(pdev)[0];
+
+	lmc_control = readq(lmc->regs + LMC_CONTROL);
+	lmc_ddr_pll_ctl = readq(lmc->regs + LMC_DDR_PLL_CTL);
+
+	if (lmc_control & LMC_CONTROL_RDIMM) {
+		mci->mtype_cap = lmc_ddr_pll_ctl & LMC_DDR_PLL_CTL_DDR4 ?
+				MEM_RDDR4 : MEM_RDDR3;
+	} else {
+		mci->mtype_cap = lmc_ddr_pll_ctl & LMC_DDR_PLL_CTL_DDR4 ?
+				MEM_DDR4 : MEM_DDR3;
+	}
+
+	mci->edac_ctl_cap = EDAC_FLAG_NONE | EDAC_FLAG_SECDED;
+	mci->edac_cap = EDAC_FLAG_SECDED;
+
+	mci->mod_name = "thunderx-lmc";
+	mci->mod_ver = "1";
+	mci->ctl_name = "thunderx-lmc-err";
+	mci->dev_name = dev_name(&pdev->dev);
+	mci->scrub_mode = SCRUB_NONE;
+
+	err = edac_mc_add_mc_with_groups(mci, thunderx_mc_groups);
+	if (err) {
+		dev_err(&pdev->dev, "Cannot add the MC: %d\n", err);
+		goto err_kfree;
+	}
+
+	lmc->pdev = pdev;
+	lmc->msix_ent.entry = 0;
+
+	err = pci_enable_msix_exact(pdev, &lmc->msix_ent, 1);
+	if (err) {
+		dev_err(&pdev->dev, "Cannot enable interrupt: %d\n", err);
+		goto err_del_mc;
+	}
+
+	err = devm_request_irq(&pdev->dev, lmc->msix_ent.vector,
+			       thunderx_lmc_err_isr, 0,
+			       "[EDAC] ThunderX LMC", mci);
+	if (err) {
+		dev_err(&pdev->dev, "Cannot set ISR: %d\n", err);
+		goto err_del_mc;
+	}
+
+	lmc_int = readq(lmc->regs + LMC_INT);
+	writeq(lmc_int, lmc->regs + LMC_INT);
+
+	writeq(LMC_INT_EN_ALL, lmc->regs + LMC_INT_EN);
+	writeq(LMC_INT_ENA_ALL, lmc->regs + LMC_INT_ENA_W1S);
+
+	lmc->node = (pci_resource_start(pdev, 0) >> 44) & 0x3;
+
+	if (IS_ENABLED(CONFIG_EDAC_DEBUG)) {
+		lmc->debugfs = debugfs_create_dir(pdev->dev.kobj.name, NULL);
+	}
+
+	thunderx_create_debugfs_nodes(lmc->debugfs, lmc_dfs_attr,
+				      lmc, ARRAY_SIZE(lmc_dfs_attr));
+
+	return 0;
+
+err_del_mc:
+	edac_mc_del_mc(mci->pdev);
+err_kfree:
+	kfree(mci);
+
+	return err;
+}
+
+static void thunderx_lmc_remove(struct pci_dev *pdev)
+{
+	struct mem_ctl_info *mci = pci_get_drvdata(pdev);
+	struct thunderx_lmc *lmc = mci->pvt_info;
+
+	writeq(0, lmc->regs + LMC_INT_EN);
+	writeq(LMC_INT_ENA_ALL, lmc->regs + LMC_INT_ENA_W1C);
+
+	if (lmc->debugfs)
+		debugfs_remove_recursive(lmc->debugfs);
+
+	edac_mc_del_mc(&pdev->dev);
+	edac_mc_free(mci);
+}
+
+MODULE_DEVICE_TABLE(pci, thunderx_lmc_pci_tbl);
+
+static struct pci_driver thunderx_lmc_driver = {
+	.name     = "thunderx_lmc_edac",
+	.probe    = thunderx_lmc_probe,
+	.remove   = thunderx_lmc_remove,
+#ifdef CONFIG_PM
+	.suspend  = thunderx_lmc_suspend,
+	.resume   = thunderx_lmc_resume,
+#endif
+	.id_table = thunderx_lmc_pci_tbl,
+};
+
+
+static ssize_t thunderx_ctl_node_show(struct edac_device_ctl_info *ctl,
+				  char *data)
+{
+	struct pci_dev *pdev = to_pci_dev(ctl->dev);
+	u64 node = (pci_resource_start(pdev, 0) >> 44) & 0x3;
+
+	return sprintf(data, "%u\n", (unsigned)node);
+}
+
+static ssize_t thunderx_ctl_func_show(struct edac_device_ctl_info *ctl,
+				  char *data)
+{
+	struct pci_dev *pdev = to_pci_dev(ctl->dev);
+	u64 func = PCI_FUNC(pdev->devfn);
+
+	return sprintf(data, "%u\n", (unsigned)func);
+}
+
+static struct edac_dev_sysfs_attribute thunderx_ctl_attrs[] = {
+	{
+		.attr = {
+			.name = "node",
+			.mode = S_IRUSR,
+		},
+		.show = thunderx_ctl_node_show,
+		.store = NULL,
+	},
+	{
+		.attr = {
+			.name = "func",
+			.mode = S_IRUSR,
+		},
+		.show = thunderx_ctl_func_show,
+		.store = NULL,
+	},
+	{
+		.attr = {.name = NULL},
+	}
+};
+
+
+/*---------------------- CCPI driver ---------------------------------*/
+
+#define PCI_DEVICE_ID_THUNDER_OCX 0xa013
+
+#define OCX_LINK_INTS		3
+#define OCX_INTS		(OCX_LINK_INTS + 1)
+#define OCX_RX_LANES		24
+#define OCX_RX_LANE_STATS	15
+
+#define OCX_COM_INT		0x100
+#define OCX_COM_INT_W1S		0x108
+#define OCX_COM_INT_ENA_W1S	0x110
+#define OCX_COM_INT_ENA_W1C	0x118
+
+#define OCX_COM_LINKX_INT(x)		(0x120 + (x) * 8)
+#define OCX_COM_LINKX_INT_W1S(x)	(0x140 + (x) * 8)
+#define OCX_COM_LINKX_INT_ENA_W1S(x)	(0x160 + (x) * 8)
+#define OCX_COM_LINKX_INT_ENA_W1C(x)	(0x180 + (x) * 8)
+
+#define OCX_LNE_INT(x)			(0x8018 + (x) * 0x100)
+#define OCX_LNE_INT_EN(x)		(0x8020 + (x) * 0x100)
+#define OCX_LNE_BAD_CNT(x)		(0x8028 + (x) * 0x100)
+#define OCX_LNE_CFG(x)			(0x8000 + (x) * 0x100)
+#define OCX_LNE_STAT(x, y)		(0x8040 + (x) * 0x100 + (y) * 8)
+
+#define OCX_LNE_CFG_RX_BDRY_LOCK_DIS	BIT(8)
+#define OCX_LNE_CFG_RX_STAT_WRAP_DIS	BIT(2)
+#define OCX_LNE_CFG_RX_STAT_RDCLR	BIT(1)
+#define OCX_LNE_CFG_RX_STAT_ENA		BIT(0)
+
+#define OCX_LNE_INT_ENA_ALL		(0x3ff - (1 << 7))
+#define OCX_COM_INT_ENA_ALL		((0x1fULL << 50) | 0xffffff)
+#define OCX_COM_LINKX_INT_ENA_ALL	((3 << 12) | (7 << 7) | (0x3f))
+
+#define OCX_TLKX_ECC_CTL(x)		(0x10018 + (x) * 0x2000)
+#define OCX_RLKX_ECC_CTL(x)		(0x18018 + (x) * 0x2000)
+
+struct thunderx_ocx {
+	void __iomem *regs;
+	int com_link;
+	struct pci_dev *pdev;
+	struct edac_device_ctl_info *edac_dev;
+
+	struct dentry *debugfs;
+
+	char buf[80*25];
+	char tmp[64];
+
+	struct msix_entry msix_ent[OCX_INTS];
+};
+
+static irqreturn_t thunderx_ocx_com_isr(int irq, void *irq_id)
+{
+	struct msix_entry *msix = irq_id;
+	struct thunderx_ocx *ocx = container_of(msix, struct thunderx_ocx,
+						msix_ent[msix->entry]);
+
+	u64 ocx_com_int = readq(ocx->regs + OCX_COM_INT);
+	u64 ocx_lane_int, ocx_lane_stat11;
+	int lane;
+
+	snprintf(ocx->buf, sizeof(ocx->buf),
+		 "%s: OCX_COM_INT: %016llx",
+		 ocx->edac_dev->ctl_name,
+		 ocx_com_int);
+
+	for (lane = 0; lane < OCX_RX_LANES; lane++)
+		if (ocx_com_int & BIT(lane)) {
+			ocx_lane_int = readq(ocx->regs + OCX_LNE_INT(lane));
+			writeq(ocx_lane_int, ocx->regs + OCX_LNE_INT(lane));
+
+			ocx_lane_stat11 = readq(ocx->regs + OCX_LNE_STAT(lane, 11));
+			snprintf(ocx->tmp, sizeof(ocx->tmp),
+				 "\n\tOCX_LNE_INT[%02d]: %016llx"
+				 " OCX_LNE_STAT11[%02d]: %016llx",
+				 lane, ocx_lane_int, lane, ocx_lane_stat11);
+			strcat(ocx->buf, ocx->tmp);
+		}
+
+	writeq(ocx_com_int, ocx->regs + OCX_COM_INT);
+
+	edac_device_handle_ue(ocx->edac_dev, 0, 0, ocx->buf);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t thunderx_ocx_lnk_isr(int irq, void *irq_id)
+{
+	struct msix_entry *msix = irq_id;
+	struct thunderx_ocx *ocx = container_of(msix, struct thunderx_ocx,
+						msix_ent[msix->entry]);
+
+	u64 ocx_com_link_int = readq(ocx->regs +
+				     OCX_COM_LINKX_INT(msix->entry));
+
+	snprintf(ocx->buf, sizeof(ocx->buf),
+		 "%s: OCX_COM_LINK_INT[%d]: %016llx",
+		 ocx->edac_dev->ctl_name,
+		 msix->entry,
+		 ocx_com_link_int);
+
+	writeq(ocx_com_link_int, ocx->regs +
+	       OCX_COM_LINKX_INT(msix->entry));
+
+	edac_device_handle_ue(ocx->edac_dev, 0, 0, ocx->buf);
+
+	return IRQ_HANDLED;
+}
+
+#define OCX_DEBUGFS_ATTR(_name, _reg)					    \
+static ssize_t thunderx_ocx_##_name##_read(struct file *file,		    \
+					   char __user *data,		    \
+					   size_t count, loff_t *ppos)      \
+{									    \
+	struct thunderx_ocx *ocx = file->private_data;			    \
+									    \
+	return sprintf(ocx->buf, "0x%016llx",				    \
+		       readq(ocx->regs + _reg));			    \
+	return simple_read_from_buffer(data, count, ppos,		    \
+				       ocx->buf, sizeof(ocx->buf));	    \
+}									    \
+									    \
+static ssize_t thunderx_ocx_##_name##_write(struct file *file,		    \
+					    const char __user *data,	    \
+					    size_t count, loff_t *ppos)     \
+{									    \
+	struct thunderx_ocx *ocx = file->private_data;			    \
+	u64 val;							    \
+	int res;							    \
+									    \
+	simple_write_to_buffer(ocx->buf, sizeof(ocx->buf), ppos,	    \
+			       data, count);				    \
+	ocx->buf[count] = '\0';						    \
+									    \
+	res = kstrtoull(ocx->buf, 0, &val);				    \
+									    \
+	if (!res) {							    \
+		writeq(val, ocx->regs + _reg);				    \
+		res = count;						    \
+	}								    \
+									    \
+	return res;							    \
+}									    \
+									    \
+DEBUGFS_STRUCT(_name, S_IRUGO | S_IWUSR,				    \
+	       thunderx_ocx_##_name##_write, thunderx_ocx_##_name##_read)
+
+OCX_DEBUGFS_ATTR(tlk0_ecc_ctl, OCX_TLKX_ECC_CTL(0));
+OCX_DEBUGFS_ATTR(tlk1_ecc_ctl, OCX_TLKX_ECC_CTL(1));
+OCX_DEBUGFS_ATTR(tlk2_ecc_ctl, OCX_TLKX_ECC_CTL(2));
+
+OCX_DEBUGFS_ATTR(rlk0_ecc_ctl, OCX_RLKX_ECC_CTL(0));
+OCX_DEBUGFS_ATTR(rlk1_ecc_ctl, OCX_RLKX_ECC_CTL(1));
+OCX_DEBUGFS_ATTR(rlk2_ecc_ctl, OCX_RLKX_ECC_CTL(2));
+
+OCX_DEBUGFS_ATTR(com_link0_int, OCX_COM_LINKX_INT_W1S(0));
+OCX_DEBUGFS_ATTR(com_link1_int, OCX_COM_LINKX_INT_W1S(1));
+OCX_DEBUGFS_ATTR(com_link2_int, OCX_COM_LINKX_INT_W1S(2));
+
+OCX_DEBUGFS_ATTR(lne00_badcnt, OCX_LNE_BAD_CNT(0));
+OCX_DEBUGFS_ATTR(lne01_badcnt, OCX_LNE_BAD_CNT(1));
+OCX_DEBUGFS_ATTR(lne02_badcnt, OCX_LNE_BAD_CNT(2));
+OCX_DEBUGFS_ATTR(lne03_badcnt, OCX_LNE_BAD_CNT(3));
+OCX_DEBUGFS_ATTR(lne04_badcnt, OCX_LNE_BAD_CNT(4));
+OCX_DEBUGFS_ATTR(lne05_badcnt, OCX_LNE_BAD_CNT(5));
+OCX_DEBUGFS_ATTR(lne06_badcnt, OCX_LNE_BAD_CNT(6));
+OCX_DEBUGFS_ATTR(lne07_badcnt, OCX_LNE_BAD_CNT(7));
+
+OCX_DEBUGFS_ATTR(lne08_badcnt, OCX_LNE_BAD_CNT(8));
+OCX_DEBUGFS_ATTR(lne09_badcnt, OCX_LNE_BAD_CNT(9));
+OCX_DEBUGFS_ATTR(lne10_badcnt, OCX_LNE_BAD_CNT(10));
+OCX_DEBUGFS_ATTR(lne11_badcnt, OCX_LNE_BAD_CNT(11));
+OCX_DEBUGFS_ATTR(lne12_badcnt, OCX_LNE_BAD_CNT(12));
+OCX_DEBUGFS_ATTR(lne13_badcnt, OCX_LNE_BAD_CNT(13));
+OCX_DEBUGFS_ATTR(lne14_badcnt, OCX_LNE_BAD_CNT(14));
+OCX_DEBUGFS_ATTR(lne15_badcnt, OCX_LNE_BAD_CNT(15));
+
+OCX_DEBUGFS_ATTR(lne16_badcnt, OCX_LNE_BAD_CNT(16));
+OCX_DEBUGFS_ATTR(lne17_badcnt, OCX_LNE_BAD_CNT(17));
+OCX_DEBUGFS_ATTR(lne18_badcnt, OCX_LNE_BAD_CNT(18));
+OCX_DEBUGFS_ATTR(lne19_badcnt, OCX_LNE_BAD_CNT(19));
+OCX_DEBUGFS_ATTR(lne20_badcnt, OCX_LNE_BAD_CNT(20));
+OCX_DEBUGFS_ATTR(lne21_badcnt, OCX_LNE_BAD_CNT(21));
+OCX_DEBUGFS_ATTR(lne22_badcnt, OCX_LNE_BAD_CNT(22));
+OCX_DEBUGFS_ATTR(lne23_badcnt, OCX_LNE_BAD_CNT(23));
+
+
+OCX_DEBUGFS_ATTR(com_int, OCX_COM_INT_W1S);
+
+struct debugfs_entry *ocx_devattr[] = {
+	&debugfs_tlk0_ecc_ctl,
+	&debugfs_tlk1_ecc_ctl,
+	&debugfs_tlk2_ecc_ctl,
+
+	&debugfs_rlk0_ecc_ctl,
+	&debugfs_rlk1_ecc_ctl,
+	&debugfs_rlk2_ecc_ctl,
+
+	&debugfs_com_link0_int,
+	&debugfs_com_link1_int,
+	&debugfs_com_link2_int,
+
+	&debugfs_lne00_badcnt,
+	&debugfs_lne01_badcnt,
+	&debugfs_lne02_badcnt,
+	&debugfs_lne03_badcnt,
+	&debugfs_lne04_badcnt,
+	&debugfs_lne05_badcnt,
+	&debugfs_lne06_badcnt,
+	&debugfs_lne07_badcnt,
+	&debugfs_lne08_badcnt,
+	&debugfs_lne09_badcnt,
+	&debugfs_lne10_badcnt,
+	&debugfs_lne11_badcnt,
+	&debugfs_lne12_badcnt,
+	&debugfs_lne13_badcnt,
+	&debugfs_lne14_badcnt,
+	&debugfs_lne15_badcnt,
+	&debugfs_lne16_badcnt,
+	&debugfs_lne17_badcnt,
+	&debugfs_lne18_badcnt,
+	&debugfs_lne19_badcnt,
+	&debugfs_lne20_badcnt,
+
+	&debugfs_com_int,
+};
+
+static const struct pci_device_id thunderx_ocx_pci_tbl[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVICE_ID_THUNDER_OCX) },
+	{ 0, },
+};
+
+static void thunderx_ocx_clearstats(struct thunderx_ocx *ocx)
+{
+	int lane, stat, cfg;
+
+	for (lane = 0; lane < OCX_RX_LANES; lane++) {
+		cfg = readq(ocx->regs + OCX_LNE_CFG(lane));
+		cfg |= OCX_LNE_CFG_RX_STAT_RDCLR;
+		cfg &= ~OCX_LNE_CFG_RX_STAT_ENA;
+		writeq(cfg, ocx->regs +OCX_LNE_CFG(lane));
+
+		for (stat = 0; stat < OCX_RX_LANE_STATS; stat++) {
+			readq(ocx->regs + OCX_LNE_STAT(lane, stat));
+		}
+	}
+}
+
+
+static int thunderx_ocx_probe(struct pci_dev *pdev,
+			      const struct pci_device_id *id)
+{
+	struct thunderx_ocx *ocx;
+	struct edac_device_ctl_info *edac_dev;
+	char name[32];
+	int idx;
+	int i;
+	int err = -ENOMEM;
+	u64 reg;
+
+	idx = edac_device_alloc_index();
+	snprintf(name, sizeof(name), "OCX%d", idx);
+	edac_dev = edac_device_alloc_ctl_info(sizeof(struct thunderx_ocx),
+					name, 1, "CCPI", 1, 0, NULL, 0, idx);
+	if (!edac_dev) {
+		dev_err(&pdev->dev, "Cannot allocate EDAC device: %d\n", err);
+		return err;
+	}
+
+	err = pcim_enable_device(pdev);
+	if (err) {
+		dev_err(&pdev->dev, "Cannot enable PCI device: %d\n", err);
+		goto err_kfree;
+	}
+
+	err = pcim_iomap_regions(pdev, 1 << 0, "thunderx_ocx");
+	if (err) {
+		dev_err(&pdev->dev, "Cannot map PCI resources: %d\n", err);
+		goto err_kfree;
+	}
+
+	ocx = edac_dev->pvt_info;
+	ocx->edac_dev = edac_dev;
+
+	ocx->regs = pcim_iomap_table(pdev)[0];
+	if (!ocx->regs) {
+		dev_err(&pdev->dev, "Cannot map PCI resources: %d\n", err);
+		err = -ENODEV;
+		goto err_kfree;
+	}
+
+	ocx->pdev = pdev;
+
+	for (i = 0; i < OCX_INTS; i++) {
+		ocx->msix_ent[i].entry = i;
+		ocx->msix_ent[i].vector = 0;
+	}
+
+	err = pci_enable_msix_exact(pdev, ocx->msix_ent, OCX_INTS);
+	if (err) {
+		dev_err(&pdev->dev, "Cannot enable interrupt: %d\n", err);
+		goto err_kfree;
+	}
+
+	for (i = 0; i < OCX_INTS; i++) {
+		err = devm_request_irq(&pdev->dev, ocx->msix_ent[i].vector,
+				       (i == 3) ? thunderx_ocx_com_isr :
+						  thunderx_ocx_lnk_isr,
+				       0, "[EDAC] ThunderX OCX",
+				       &ocx->msix_ent[i]);
+		if (err)
+			goto err_kfree;
+	}
+
+	edac_dev->dev = &pdev->dev;
+	edac_dev->dev_name = dev_name(&pdev->dev);
+	edac_dev->mod_name = "thunderx-ocx";
+	edac_dev->ctl_name = "thunderx-ocx-err";
+	edac_dev->sysfs_attributes = thunderx_ctl_attrs;
+
+	err = edac_device_add_device(edac_dev);
+	if (err) {
+		dev_err(&pdev->dev, "Cannot add EDAC device: %d\n", err);
+		goto err_kfree;
+	}
+
+	if (IS_ENABLED(CONFIG_EDAC_DEBUG))
+		ocx->debugfs = debugfs_create_dir(pdev->dev.kobj.name, NULL);
+
+	thunderx_create_debugfs_nodes(ocx->debugfs, ocx_devattr,
+				      ocx, ARRAY_SIZE(ocx_devattr));
+
+	pci_set_drvdata(pdev, edac_dev);
+
+	thunderx_ocx_clearstats(ocx);
+
+	for (i = 0; i < OCX_RX_LANES; i++) {
+		writeq(OCX_LNE_INT_ENA_ALL,
+		       ocx->regs + OCX_LNE_INT_EN(i));
+
+		reg = readq(ocx->regs + OCX_LNE_INT(i));
+		writeq(reg, ocx->regs + OCX_LNE_INT(i));
+
+	}
+
+	for (i = 0; i < OCX_LINK_INTS; i++) {
+		reg = readq(ocx->regs + OCX_COM_LINKX_INT(i));
+		writeq(reg, ocx->regs + OCX_COM_LINKX_INT(i));
+
+		writeq(OCX_COM_LINKX_INT_ENA_ALL,
+		       ocx->regs + OCX_COM_LINKX_INT_ENA_W1S(i));
+	}
+
+	reg = readq(ocx->regs + OCX_COM_INT);
+	writeq(reg, ocx->regs + OCX_COM_INT);
+
+	writeq(OCX_COM_INT_ENA_ALL, ocx->regs + OCX_COM_INT_ENA_W1S);
+
+	return 0;
+
+err_kfree:
+	edac_device_free_ctl_info(edac_dev);
+
+	return err;
+}
+
+
+static void thunderx_ocx_remove(struct pci_dev *pdev)
+{
+	struct edac_device_ctl_info *edac_dev = pci_get_drvdata(pdev);
+	struct thunderx_ocx *ocx = edac_dev->pvt_info;
+	int i;
+
+	writeq(OCX_COM_INT_ENA_ALL, ocx->regs + OCX_COM_INT_ENA_W1C);
+
+	for (i = 0; i < OCX_INTS; i++) {
+		writeq(OCX_COM_LINKX_INT_ENA_ALL,
+		       ocx->regs + OCX_COM_LINKX_INT_ENA_W1C(i));
+	}
+
+	if (ocx->debugfs)
+		debugfs_remove_recursive(ocx->debugfs);
+
+	edac_device_del_device(&pdev->dev);
+	edac_device_free_ctl_info(edac_dev);
+}
+
+MODULE_DEVICE_TABLE(pci, thunderx_ocx_pci_tbl);
+
+static struct pci_driver thunderx_ocx_driver = {
+	.name     = "thunderx_ocx_edac",
+	.probe    = thunderx_ocx_probe,
+	.remove   = thunderx_ocx_remove,
+	.id_table = thunderx_ocx_pci_tbl,
+};
+
+
+/*---------------------- L2C driver ---------------------------------*/
+
+#define PCI_DEVICE_ID_THUNDER_L2C_TAD 0xa02e
+#define PCI_DEVICE_ID_THUNDER_L2C_CBC 0xa02f
+#define PCI_DEVICE_ID_THUNDER_L2C_MCI 0xa030
+
+#define L2C_TAD_INT_W1C		0x40000
+#define L2C_TAD_INT_W1S		0x40008
+
+#define L2C_TAD_INT_ENA_W1C	0x40020
+#define L2C_TAD_INT_ENA_W1S	0x40028
+
+#define L2C_TAD_INT_L2DSBE	 BIT(0)
+#define L2C_TAD_INT_L2DDBE	 BIT(1)
+#define L2C_TAD_INT_SBFSBE	 BIT(2)
+#define L2C_TAD_INT_SBFDBE	 BIT(3)
+#define L2C_TAD_INT_FBFSBE	 BIT(4)
+#define L2C_TAD_INT_FBFDBE	 BIT(5)
+#define L2C_TAD_INT_TAGSBE	 BIT(8)
+#define L2C_TAD_INT_TAGDBE	 BIT(9)
+#define L2C_TAD_INT_WRNXM	 BIT(13)
+#define L2C_TAD_INT_RDNXM	 BIT(14)
+#define L2C_TAD_INT_RDDISLMC	 BIT(15)
+#define L2C_TAD_INT_WRDISLMC	 BIT(16)
+#define L2C_TAD_INT_LFBTO	 BIT(17)
+#define L2C_TAD_INT_RTGSBE	 BIT(32)
+#define L2C_TAD_INT_RTGDBE	 BIT(33)
+#define L2C_TAD_INT_RDISOCI	 BIT(34)
+#define L2C_TAD_INT_WRISOCI	 BIT(35)
+
+#define L2C_TAD_INT_ECC		(L2C_TAD_INT_L2DSBE | L2C_TAD_INT_L2DDBE | \
+				 L2C_TAD_INT_SBFSBE | L2C_TAD_INT_SBFDBE | \
+				 L2C_TAD_INT_FBFSBE | L2C_TAD_INT_FBFDBE)
+
+#define L2C_TAD_INT_CE		(L2C_TAD_INT_L2DSBE | L2C_TAD_INT_SBFSBE | \
+				 L2C_TAD_INT_FBFSBE | L2C_TAD_INT_TAGSBE | \
+				 L2C_TAD_INT_RTGSBE)
+
+#define L2C_TAD_INT_UE		(L2C_TAD_INT_L2DDBE | L2C_TAD_INT_SBFDBE | \
+				 L2C_TAD_INT_FBFDBE | L2C_TAD_INT_TAGDBE | \
+				 L2C_TAD_INT_RTGDBE)
+
+#define L2C_TAD_INT_TAG		(L2C_TAD_INT_TAGSBE | L2C_TAD_INT_TAGDBE)
+
+#define L2C_TAD_INT_RTG		(L2C_TAD_INT_RTGSBE | L2C_TAD_INT_RTGDBE)
+
+#define L2C_TAD_INT_NXM		(L2C_TAD_INT_WRNXM | L2C_TAD_INT_RDNXM)
+
+#define L2C_TAD_INT_DISLMC	(L2C_TAD_INT_WRDISLMC | L2C_TAD_INT_RDDISLMC)
+
+#define L2C_TAD_INT_ISOCI	(L2C_TAD_INT_WRISOCI | L2C_TAD_INT_RDISOCI)
+
+#define L2C_TAD_INT_ENA_ALL	(L2C_TAD_INT_ECC | L2C_TAD_INT_TAG | \
+				 L2C_TAD_INT_RTG | L2C_TAD_INT_NXM | \
+				 L2C_TAD_INT_DISLMC | L2C_TAD_INT_ISOCI | \
+				 L2C_TAD_INT_LFBTO)
+
+#define L2C_TAD_TIMETWO		0x50000
+#define L2C_TAD_TIMEOUT		0x50100
+#define L2C_TAD_ERR		0x60000
+#define L2C_TAD_TQD_ERR		0x60100
+#define L2C_TAD_TTG_ERR		0x60200
+
+
+#define L2C_CBC_INT_W1C		0x60000
+
+#define L2C_CBC_INT_RSDSBE	 BIT(0)
+#define L2C_CBC_INT_RSDDBE	 BIT(1)
+
+#define L2C_CBC_INT_RSD		 (L2C_CBC_INT_RSDSBE | L2C_CBC_INT_RSDDBE)
+
+#define L2C_CBC_INT_MIBSBE	 BIT(4)
+#define L2C_CBC_INT_MIBDBE	 BIT(5)
+
+#define L2C_CBC_INT_MIB		 (L2C_CBC_INT_MIBSBE | L2C_CBC_INT_MIBDBE)
+
+#define L2C_CBC_INT_IORDDISOCI	 BIT(6)
+#define L2C_CBC_INT_IOWRDISOCI	 BIT(7)
+
+#define L2C_CBC_INT_IODISOCI	 (L2C_CBC_INT_IORDDISOCI | L2C_CBC_INT_IOWRDISOCI)
+
+#define L2C_CBC_INT_CE		 (L2C_CBC_INT_RSDSBE | L2C_CBC_INT_MIBSBE)
+#define L2C_CBC_INT_UE		 (L2C_CBC_INT_RSDDBE | L2C_CBC_INT_MIBDBE)
+
+#define L2C_CBC_INT_W1S		0x60008
+#define L2C_CBC_INT_ENA_W1C	0x60020
+
+#define L2C_CBC_INT_ENA_ALL	 (L2C_CBC_INT_RSD | L2C_CBC_INT_MIB | \
+				  L2C_CBC_INT_IODISOCI)
+
+#define L2C_CBC_INT_ENA_W1S	0x60028
+
+#define L2C_CBC_IODISOCIERR	0x80008
+#define L2C_CBC_IOCERR		0x80010
+#define L2C_CBC_RSDERR		0x80018
+#define L2C_CBC_MIBERR		0x80020
+
+
+#define L2C_MCI_INT_W1C		0x0
+
+#define L2C_MCI_INT_VBFSBE	 BIT(0)
+#define L2C_MCI_INT_VBFDBE	 BIT(1)
+
+#define L2C_MCI_INT_W1S		0x8
+#define L2C_MCI_INT_ENA_W1C	0x20
+
+#define L2C_MCI_INT_ENA_ALL	 (L2C_MCI_INT_VBFSBE | L2C_MCI_INT_VBFDBE)
+
+#define L2C_MCI_INT_ENA_W1S	0x28
+
+#define L2C_MCI_ERR		0x10000
+
+struct thunderx_l2c {
+	void __iomem *regs;
+	struct pci_dev *pdev;
+	struct edac_device_ctl_info *edac_dev;
+
+	struct dentry *debugfs;
+
+	char buf[80];
+	int index;
+
+	struct msix_entry msix_ent;
+};
+
+static irqreturn_t thunderx_l2c_tad_isr(int irq, void *irq_id)
+{
+	struct msix_entry *msix = irq_id;
+	struct thunderx_l2c *tad = container_of(msix, struct thunderx_l2c,
+						msix_ent);
+
+	u64 tad_int = readq(tad->regs + L2C_TAD_INT_W1C);
+	const char *ext_reg = "Status";
+	u64 ext_val = 0;
+
+	if (tad_int & L2C_TAD_INT_ECC) {
+		ext_reg = "TQD_ERR";
+		ext_val = readq(tad->regs + L2C_TAD_TQD_ERR);
+	} else if (tad_int & L2C_TAD_INT_TAG) {
+		ext_reg = "TTG_ERR";
+		ext_val = readq(tad->regs + L2C_TAD_TTG_ERR);
+	} else if (tad_int & L2C_TAD_INT_NXM) {
+		ext_reg = "ERR";
+		ext_val = readq(tad->regs + L2C_TAD_ERR);
+	} else if (tad_int & L2C_TAD_INT_LFBTO) {
+		ext_reg = "TIMEOUT";
+		ext_val = readq(tad->regs + L2C_TAD_TIMEOUT);
+	} else if (tad_int & L2C_TAD_INT_ISOCI) {
+		ext_reg = "ERR";
+		ext_val = readq(tad->regs + L2C_TAD_ERR);
+	}
+
+	snprintf(tad->buf, sizeof(tad->buf),
+		 "%s: L2C_TAD_INT: %016llx, %s: %016llx",
+		 tad->edac_dev->ctl_name,
+		 tad_int, ext_reg, ext_val);
+
+	writeq(tad_int, tad->regs + L2C_TAD_INT_W1C);
+
+	if (tad_int & L2C_TAD_INT_UE)
+		edac_device_handle_ue(tad->edac_dev, 0, 0, tad->buf);
+	else
+		edac_device_handle_ce(tad->edac_dev, 0, 0, tad->buf);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t thunderx_l2c_cbc_isr(int irq, void *irq_id)
+{
+	struct msix_entry *msix = irq_id;
+	struct thunderx_l2c *cbc = container_of(msix, struct thunderx_l2c,
+						msix_ent);
+
+	u64 cbc_int = readq(cbc->regs + L2C_CBC_INT_W1C);
+	const char *ext_reg = "Status";
+	u64 ext_val = 0;
+
+	if (cbc_int & L2C_CBC_INT_RSD) {
+		ext_reg = "RSDERR";
+		ext_val = readq(cbc->regs + L2C_CBC_RSDERR);
+	} else if (cbc_int & L2C_CBC_INT_MIB) {
+		ext_reg = "MIBERR";
+		ext_val = readq(cbc->regs + L2C_CBC_MIBERR);
+	} else if (cbc_int & L2C_CBC_INT_IODISOCI) {
+		ext_reg = "IODISOCIERR";
+		ext_val = readq(cbc->regs + L2C_CBC_IODISOCIERR);
+	}
+
+	snprintf(cbc->buf, sizeof(cbc->buf),
+		 "%s: L2C_CBC_INT: %016llx, %s: %016llx",
+		 cbc->edac_dev->ctl_name,
+		 cbc_int, ext_reg, ext_val);
+
+	writeq(cbc_int, cbc->regs + L2C_CBC_INT_W1C);
+
+	if (cbc_int & L2C_CBC_INT_UE)
+		edac_device_handle_ue(cbc->edac_dev, 0, 0, cbc->buf);
+	else
+		edac_device_handle_ce(cbc->edac_dev, 0, 0, cbc->buf);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t thunderx_l2c_mci_isr(int irq, void *irq_id)
+{
+	struct msix_entry *msix = irq_id;
+	struct thunderx_l2c *mci = container_of(msix, struct thunderx_l2c,
+						msix_ent);
+
+	u64 mci_int = readq(mci->regs + L2C_MCI_INT_W1C);
+	u64 ext_val = readq(mci->regs + L2C_MCI_ERR);
+
+	snprintf(mci->buf, sizeof(mci->buf),
+		 "%s: L2C_MCI_INT: %016llx, ERR: %016llx",
+		 mci->edac_dev->ctl_name,
+		 mci_int, ext_val);
+
+	writeq(mci_int, mci->regs + L2C_MCI_INT_W1C);
+
+	if (mci_int & L2C_MCI_INT_VBFSBE)
+		edac_device_handle_ce(mci->edac_dev, 0, 0, mci->buf);
+	else
+		edac_device_handle_ue(mci->edac_dev, 0, 0, mci->buf);
+
+	return IRQ_HANDLED;
+}
+
+#define L2C_DEBUGFS_ATTR(_name, _reg)					    \
+static ssize_t thunderx_l2c_##_name##_read(struct file *file,		    \
+					   char __user *data,		    \
+					   size_t count, loff_t *ppos)      \
+{									    \
+	struct thunderx_l2c *l2c = file->private_data;			    \
+									    \
+	return sprintf(l2c->buf, "0x%016llx",				    \
+		       readq(l2c->regs + _reg));			    \
+	return simple_read_from_buffer(data, count, ppos,		    \
+				       l2c->buf, sizeof(l2c->buf));	    \
+}									    \
+									    \
+static ssize_t thunderx_l2c_##_name##_write(struct file *file,		    \
+					    const char __user *data,	    \
+					    size_t count, loff_t *ppos)     \
+{									    \
+	struct thunderx_l2c *l2c = file->private_data;			    \
+	u64 val;							    \
+	int res;							    \
+									    \
+	simple_write_to_buffer(l2c->buf, sizeof(l2c->buf), ppos,	    \
+			       data, count);				    \
+	l2c->buf[count] = '\0';						    \
+									    \
+	res = kstrtoull(l2c->buf, 0, &val);				    \
+									    \
+	if (!res) {							    \
+		writeq(val, l2c->regs + _reg);				    \
+		res = count;						    \
+	}								    \
+									    \
+	return res;							    \
+}									    \
+									    \
+DEBUGFS_STRUCT(l2c_##_name, S_IRUGO | S_IWUSR,				    \
+	       thunderx_l2c_##_name##_write, thunderx_l2c_##_name##_read)
+
+L2C_DEBUGFS_ATTR(tad_int, L2C_TAD_INT_W1S);
+
+struct debugfs_entry *l2c_tad_devattr[] = {
+	&debugfs_l2c_tad_int,
+};
+
+L2C_DEBUGFS_ATTR(cbc_int, L2C_CBC_INT_W1S);
+
+struct debugfs_entry *l2c_cbc_devattr[] = {
+	&debugfs_l2c_cbc_int,
+};
+
+L2C_DEBUGFS_ATTR(mci_int, L2C_MCI_INT_W1S);
+
+struct debugfs_entry *l2c_mci_devattr[] = {
+	&debugfs_l2c_mci_int,
+};
+
+
+static const struct pci_device_id thunderx_l2c_pci_tbl[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVICE_ID_THUNDER_L2C_TAD), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVICE_ID_THUNDER_L2C_CBC), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, PCI_DEVICE_ID_THUNDER_L2C_MCI), },
+	{ 0, },
+};
+
+static int thunderx_l2c_probe(struct pci_dev *pdev,
+			      const struct pci_device_id *id)
+{
+	struct thunderx_l2c *l2c;
+	struct edac_device_ctl_info *edac_dev;
+	struct debugfs_entry **l2c_devattr;
+	size_t dfs_entries;
+	irqreturn_t (*thunderx_l2c_isr)(int, void *) = NULL;
+	char name[32];
+	const char *fmt;
+	int idx;
+	int err = -ENOMEM;
+
+	idx = edac_device_alloc_index();
+	switch (pdev->device) {
+	case PCI_DEVICE_ID_THUNDER_L2C_TAD:
+		thunderx_l2c_isr = thunderx_l2c_tad_isr;
+		l2c_devattr = l2c_tad_devattr;
+		dfs_entries = ARRAY_SIZE(l2c_tad_devattr);
+		fmt = "L2C-TAD%d";
+		break;
+	case PCI_DEVICE_ID_THUNDER_L2C_CBC:
+		thunderx_l2c_isr = thunderx_l2c_cbc_isr;
+		l2c_devattr = l2c_cbc_devattr;
+		dfs_entries = ARRAY_SIZE(l2c_cbc_devattr);
+		fmt = "L2C-CBC%d";
+		break;
+	case PCI_DEVICE_ID_THUNDER_L2C_MCI:
+		thunderx_l2c_isr = thunderx_l2c_mci_isr;
+		l2c_devattr = l2c_mci_devattr;
+		dfs_entries = ARRAY_SIZE(l2c_mci_devattr);
+		fmt = "L2C-MCI%d";
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	snprintf(name, sizeof(name), fmt, idx);
+	edac_dev = edac_device_alloc_ctl_info(sizeof(struct thunderx_l2c),
+					      name, 1, "L2C", 1, 0,
+					      NULL, 0, idx);
+	if (!edac_dev) {
+		dev_err(&pdev->dev, "Cannot allocate EDAC device: %d\n", err);
+		return err;
+	}
+
+	err = pcim_enable_device(pdev);
+	if (err) {
+		dev_err(&pdev->dev, "Cannot enable PCI device: %d\n", err);
+		goto err_kfree;
+	}
+
+	err = pcim_iomap_regions(pdev, 1 << 0, "thunderx_l2c");
+	if (err) {
+		dev_err(&pdev->dev, "Cannot map PCI resources: %d\n", err);
+		goto err_kfree;
+	}
+
+	l2c = edac_dev->pvt_info;
+	l2c->edac_dev = edac_dev;
+
+	l2c->regs = pcim_iomap_table(pdev)[0];
+	if (!l2c->regs) {
+		dev_err(&pdev->dev, "Cannot map PCI resources: %d\n", err);
+		err = -ENODEV;
+		goto err_kfree;
+	}
+
+	l2c->pdev = pdev;
+
+	l2c->msix_ent.entry = 0;
+	l2c->msix_ent.vector = 0;
+
+	err = pci_enable_msix_exact(pdev, &l2c->msix_ent, 1);
+	if (err) {
+		dev_err(&pdev->dev, "Cannot enable interrupt: %d\n", err);
+		goto err_kfree;
+	}
+
+	err = devm_request_irq(&pdev->dev, l2c->msix_ent.vector,
+			       thunderx_l2c_isr, 0,
+			       "[EDAC] ThunderX L2C",
+			       &l2c->msix_ent);
+	if (err)
+		goto err_kfree;
+
+
+	edac_dev->dev = &pdev->dev;
+	edac_dev->dev_name = dev_name(&pdev->dev);
+	edac_dev->mod_name = "thunderx-l2c";
+	edac_dev->ctl_name = "thunderx-l2c-err";
+	edac_dev->sysfs_attributes = thunderx_ctl_attrs;
+
+	err = edac_device_add_device(edac_dev);
+	if (err) {
+		dev_err(&pdev->dev, "Cannot add EDAC device: %d\n", err);
+		goto err_kfree;
+	}
+
+	if (IS_ENABLED(CONFIG_EDAC_DEBUG))
+		l2c->debugfs = debugfs_create_dir(pdev->dev.kobj.name, NULL);
+
+	thunderx_create_debugfs_nodes(l2c->debugfs, l2c_devattr,
+				      l2c, dfs_entries);
+
+	pci_set_drvdata(pdev, edac_dev);
+
+	switch (pdev->device) {
+	case PCI_DEVICE_ID_THUNDER_L2C_TAD:
+		writeq(L2C_TAD_INT_ENA_ALL, l2c->regs + L2C_TAD_INT_ENA_W1S);
+		break;
+	case PCI_DEVICE_ID_THUNDER_L2C_CBC:
+		writeq(L2C_CBC_INT_ENA_ALL, l2c->regs + L2C_CBC_INT_ENA_W1S);
+		break;
+	case PCI_DEVICE_ID_THUNDER_L2C_MCI:
+		writeq(L2C_MCI_INT_ENA_ALL, l2c->regs + L2C_MCI_INT_ENA_W1S);
+		break;
+	}
+
+	return 0;
+
+err_kfree:
+	edac_device_free_ctl_info(edac_dev);
+
+	return err;
+}
+
+
+static void thunderx_l2c_remove(struct pci_dev *pdev)
+{
+	struct edac_device_ctl_info *edac_dev = pci_get_drvdata(pdev);
+	struct thunderx_l2c *l2c = edac_dev->pvt_info;
+
+	switch (pdev->device) {
+	case PCI_DEVICE_ID_THUNDER_L2C_TAD:
+		writeq(L2C_TAD_INT_ENA_ALL, l2c->regs + L2C_TAD_INT_ENA_W1C);
+		break;
+	case PCI_DEVICE_ID_THUNDER_L2C_CBC:
+		writeq(L2C_CBC_INT_ENA_ALL, l2c->regs + L2C_CBC_INT_ENA_W1C);
+		break;
+	case PCI_DEVICE_ID_THUNDER_L2C_MCI:
+		writeq(L2C_CBC_INT_ENA_ALL, l2c->regs + L2C_MCI_INT_ENA_W1C);
+		break;
+	}
+
+	if (l2c->debugfs)
+		debugfs_remove_recursive(l2c->debugfs);
+
+	edac_device_del_device(&pdev->dev);
+	edac_device_free_ctl_info(edac_dev);
+}
+
+MODULE_DEVICE_TABLE(pci, thunderx_l2c_pci_tbl);
+
+static struct pci_driver thunderx_l2c_driver = {
+	.name     = "thunderx_l2c_edac",
+	.probe    = thunderx_l2c_probe,
+	.remove   = thunderx_l2c_remove,
+	.id_table = thunderx_l2c_pci_tbl,
+};
+
+static int __init thunderx_edac_init(void)
+{
+	int rc = 0;
+
+	rc = pci_register_driver(&thunderx_lmc_driver);
+
+	if (rc)
+		return rc;
+
+	rc = pci_register_driver(&thunderx_ocx_driver);
+
+	if (rc)
+		goto err_lmc;
+
+	rc = pci_register_driver(&thunderx_l2c_driver);
+
+	if (rc)
+		goto err_ocx;
+
+	return rc;
+err_ocx:
+	pci_unregister_driver(&thunderx_ocx_driver);
+err_lmc:
+	pci_unregister_driver(&thunderx_lmc_driver);
+
+	return rc;
+}
+
+static void __exit thunderx_edac_exit(void)
+{
+	pci_unregister_driver(&thunderx_l2c_driver);
+	pci_unregister_driver(&thunderx_ocx_driver);
+	pci_unregister_driver(&thunderx_lmc_driver);
+
+}
+
+module_init(thunderx_edac_init);
+module_exit(thunderx_edac_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Cavium, Inc.");
+MODULE_DESCRIPTION("EDAC Driver for Cavium ThunderX");
-- 
2.0.2

