From 9bd8ef36f807b2ba7780efc0003948764eddeda8 Mon Sep 17 00:00:00 2001
From: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
Date: Tue, 28 Apr 2009 14:00:55 +0900
Subject: [PATCH] MIPS: SS1000: instruction hazard barrier on eret

SS1000 core has a restriction on instruction fetch over the eret insn.
We need to make sure that the prediction address FIFO has been cleared
before processing any further instruction fetch.

This could be achieved with the branch insn as follows:
- The branch instruction must be a branch likely, AND
- The branch must be not taken.

Signed-off-by: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
---
 arch/mips/kernel/genex.S      |   12 ++++++++++++
 arch/mips/mm/tlbex.c          |    8 ++++++++
 include/asm-mips/stackframe.h |   13 +++++++++++++
 3 files changed, 33 insertions(+), 0 deletions(-)

diff --git a/arch/mips/kernel/genex.S b/arch/mips/kernel/genex.S
index 01dcbe3..7bbf2c4 100644
--- a/arch/mips/kernel/genex.S
+++ b/arch/mips/kernel/genex.S
@@ -191,6 +191,10 @@ NESTED(handle_int, PT_SIZE, sp)
 	bnez	k0, 1f
 
 	eret
+#ifdef CONFIG_CPU_SS1000
+3:	bnezl	zero, 3b			# instruction hazard barrier
+	 nop
+#endif
 #endif
 1:
 	.set pop
@@ -368,6 +372,10 @@ NESTED(nmi_handler, PT_SIZE, sp)
 	RESTORE_ALL
 	.set	mips3
 	eret
+#ifdef CONFIG_CPU_SS1000
+	.set	mips0
+3:	bnezl	zero, 3b			# instruction hazard barrier
+#endif
 	.set	pop
 	END(nmi_handler)
 
@@ -523,6 +531,10 @@ NESTED(nmi_handler, PT_SIZE, sp)
 	.set	mips3
 	eret
 	.set	mips0
+#ifdef CONFIG_CPU_SS1000
+3:	bnezl	zero, 3b			# instruction hazard barrier
+	 nop
+#endif
 #endif
 	.set	pop
 	END(handle_ri_rdhwr)
diff --git a/arch/mips/mm/tlbex.c b/arch/mips/mm/tlbex.c
index cacf37a..de2d8d3 100644
--- a/arch/mips/mm/tlbex.c
+++ b/arch/mips/mm/tlbex.c
@@ -702,6 +702,10 @@ static void __cpuinit build_r4000_tlb_refill_handler(void)
 	build_tlb_write_entry(&p, &l, &r, tlb_random);
 	uasm_l_leave(&l, p);
 	uasm_i_eret(&p); /* return from trap */
+#ifdef CONFIG_CPU_SS1000
+	uasm_i_bnezl(&p, 0, -4); /* instruction hazard barrier */
+	uasm_i_nop(&p);
+#endif
 
 #ifdef CONFIG_64BIT
 	build_get_pgd_vmalloc64(&p, &l, &r, K0, K1);
@@ -1129,6 +1133,10 @@ build_r4000_tlbchange_handler_tail(u32 **p, struct uasm_label **l,
 	build_tlb_write_entry(p, l, r, tlb_indexed);
 	uasm_l_leave(l, *p);
 	uasm_i_eret(p); /* return from trap */
+#ifdef CONFIG_CPU_SS1000
+	uasm_i_bnezl(p, 0, -4); /* instruction hazard barrier */
+	uasm_i_nop(p);
+#endif
 
 #ifdef CONFIG_64BIT
 	build_get_pgd_vmalloc64(p, l, r, tmp, ptr);
diff --git a/include/asm-mips/stackframe.h b/include/asm-mips/stackframe.h
index 4c37c4e..172f6c0 100644
--- a/include/asm-mips/stackframe.h
+++ b/include/asm-mips/stackframe.h
@@ -411,6 +411,19 @@
 		.set	mips3
 		eret
 		.set	mips0
+#ifdef CONFIG_CPU_SS1000
+		/*
+		 * Workaround: SS1000 core has a restrictin on instruction
+		 * fetch over the eret insn.  We need to make sure that the
+		 * prediction address FIFO has been cleared before processing
+		 * any further instruction fetch.
+		 *
+		 * This could be achieved with the branch insn as follows:
+		 * - The branch instruction must be a branch likely, AND
+		 * - The branch must be not taken.
+		 */
+3:		bnezl	$0, 3b
+#endif
 		.endm
 
 #endif
-- 
1.6.0.4

