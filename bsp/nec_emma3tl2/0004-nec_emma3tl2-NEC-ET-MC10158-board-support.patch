From 890d954c6264ce18a946d03604de387df0acce71 Mon Sep 17 00:00:00 2001
From: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
Date: Mon, 7 Sep 2009 09:33:56 +0900
Subject: [PATCH 4/4] nec_emma3tl2: NEC ET-MC10158 board support

ET-MC10158 is EMMA3TL2 evaluation board manufactured by NEC Electronics.
This patch adds support for a few of the system peripherals, I2C, UART,
USB HCs, and ethernet MAC.  On-board NOR flash device is also available.

Signed-off-by: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
---
 arch/mips/Kconfig                 |    6 +
 arch/mips/Makefile                |    6 +
 arch/mips/emma/et10158/Makefile   |   11 ++
 arch/mips/emma/et10158/init.c     |   38 ++++++
 arch/mips/emma/et10158/irq.c      |  101 +++++++++++++++
 arch/mips/emma/et10158/platform.c |  247 +++++++++++++++++++++++++++++++++++++
 arch/mips/emma/et10158/setup.c    |  145 ++++++++++++++++++++++
 7 files changed, 554 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/emma/et10158/Makefile
 create mode 100644 arch/mips/emma/et10158/init.c
 create mode 100644 arch/mips/emma/et10158/irq.c
 create mode 100644 arch/mips/emma/et10158/platform.c
 create mode 100644 arch/mips/emma/et10158/setup.c

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 061c298..c935420 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -257,6 +257,12 @@ config MARKEINS
 	  This enables support for the R5432-based NEC Mark-eins
 	  boards with R5500 CPU.
 
+config NEC_ET10158
+	bool "NEC EMMA3TL2 ET-MC10158 board"
+	select SOC_EMMA3TL2
+	help
+	  This enables support for the NEC Electronics ET-MC10158 board.
+
 config MACH_VR41XX
 	bool "NEC VR4100 series based machines"
 	select CEVT_R4K
diff --git a/arch/mips/Makefile b/arch/mips/Makefile
index 9ee1d32..978a50a 100644
--- a/arch/mips/Makefile
+++ b/arch/mips/Makefile
@@ -417,6 +417,12 @@ core-$(CONFIG_MARKEINS)         += arch/mips/emma2rh/markeins/
 load-$(CONFIG_MARKEINS)         += 0xffffffff88100000
 
 #
+# NEC EMMA3TL2 ET-MC10158
+#
+core-$(CONFIG_NEC_ET10158)	+= arch/mips/emma/et10158/
+load-$(CONFIG_NEC_ET10158)	+= 0xffffffff8d000000
+
+#
 # SGI IP22 (Indy/Indigo2)
 #
 # Set the load address to >= 0xffffffff88069000 if you want to leave space for
diff --git a/arch/mips/emma/et10158/Makefile b/arch/mips/emma/et10158/Makefile
new file mode 100644
index 0000000..48e84ae
--- /dev/null
+++ b/arch/mips/emma/et10158/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for NEC EMMA3TL2 ET-MC10158 evaluation board.
+#
+# Copyright (C) 2009  NEC Electronics Corporation
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+#
+
+obj-y		:= init.o irq.o platform.o setup.o
diff --git a/arch/mips/emma/et10158/init.c b/arch/mips/emma/et10158/init.c
new file mode 100644
index 0000000..e06c164
--- /dev/null
+++ b/arch/mips/emma/et10158/init.c
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2009  NEC Electronics Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * (version 2) as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/init.h>
+
+#include <asm/bootinfo.h>
+#include <asm/emma/emmaxxx.h>
+#include <asm/emma/prom.h>
+
+const char *get_system_type(void)
+{
+	return "NEC EMMA3TL2 ET-MC10158";
+}
+
+void __init prom_init(void)
+{
+	prom_argc = (int)fw_arg0;
+	prom_argv = (char **)fw_arg1;
+	prom_envp = (char **)fw_arg2;
+
+	prom_init_cmdline();
+
+	add_memory_region(EMMA_RAM_BASE, EMMA_RAM_SIZE, BOOT_MEM_RAM);
+}
diff --git a/arch/mips/emma/et10158/irq.c b/arch/mips/emma/et10158/irq.c
new file mode 100644
index 0000000..f4cd91f
--- /dev/null
+++ b/arch/mips/emma/et10158/irq.c
@@ -0,0 +1,101 @@
+/*
+ * This file defines the irq handler for EMMA3TL2 ET-MC10158.
+ *
+ * Copyright (C) 2009  NEC Electronics Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * (version 2) as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include <asm/mipsregs.h>
+#include <asm/irq_cpu.h>
+#include <asm/emma/emmaxxx.h>
+#include <asm/emma/irq.h>
+#include <asm/emma/bhif.h>
+
+void emma_irq_dispatch(void)
+{
+	u32 status;
+	u32 bitmask;
+	u32 i;
+
+	status = emma_in32(EMMA_BHIF_INT_ST_0) &
+		 emma_in32(EMMA_BHIF_INT_EN_0);
+#ifdef EMMA_SW_CASCADE
+	if (status & (1UL << ((EMMA_SW_CASCADE - EMMA_IRQ_BASE) % 32))) {
+		u32 sw_int_status;
+
+		sw_int_status = emma_in32(EMMA_BHIF_SW_INT) &
+				emma_in32(EMMA_BHIF_SW_INT_EN);
+		for (i = 0, bitmask = 1UL; i < 32; i++, bitmask <<= 1) {
+			if (sw_int_status & bitmask) {
+				do_IRQ(EMMA_SW_IRQ_BASE + i);
+				return;
+			}
+		}
+	}
+	/* ignoring SW interrupt */
+	status &= ~(1UL << (EMMA_SW_CASCADE - EMMA_IRQ_BASE));
+#endif
+	for (i = 0, bitmask = 1UL; i < 32; i++, bitmask <<= 1) {
+		if (status & bitmask) {
+			do_IRQ(EMMA_IRQ_BASE + i);
+			return;
+		}
+	}
+
+	status = emma_in32(EMMA_BHIF_INT_ST_1) &
+		 emma_in32(EMMA_BHIF_INT_EN_1);
+	for (i = 32, bitmask = 1UL; i < 64; i++, bitmask <<= 1) {
+		if (status & bitmask) {
+			do_IRQ(EMMA_IRQ_BASE + i);
+			return;
+		}
+	}
+
+	status = emma_in32(EMMA_BHIF_INT_ST_2) &
+		 emma_in32(EMMA_BHIF_INT_EN_2);
+	for (i = 64, bitmask = 1UL; i < 96; i++, bitmask <<= 1) {
+		if (status & bitmask) {
+			do_IRQ(EMMA_IRQ_BASE + i);
+			return;
+		}
+	}
+}
+
+void __init arch_init_irq(void)
+{
+	/* by default, interrupts are disabled. */
+	emma_out32(EMMA_BHIF_INT_EN_0, 0);
+	emma_out32(EMMA_BHIF_INT_EN_1, 0);
+	emma_out32(EMMA_BHIF_INT_EN_2, 0);
+	emma_out32(EMMA_BHIF_INT1_EN_0, 0);
+	emma_out32(EMMA_BHIF_INT1_EN_1, 0);
+	emma_out32(EMMA_BHIF_INT1_EN_2, 0);
+	emma_out32(EMMA_BHIF_SW_INT_EN, 0);
+
+	clear_c0_status(0xff00);
+	set_c0_status(0x0400);
+
+	/* init all controllers */
+	mips_cpu_irq_init();
+	bhif_irq_init();
+	bhif_sw_irq_init();
+
+	/* setup cascade interrupts */
+	setup_irq(MIPS_CPU_IRQ_BASE + 2, &irq_cascade);
+	setup_irq(EMMA_SW_CASCADE, &irq_cascade);
+}
diff --git a/arch/mips/emma/et10158/platform.c b/arch/mips/emma/et10158/platform.c
new file mode 100644
index 0000000..6b49bf2
--- /dev/null
+++ b/arch/mips/emma/et10158/platform.c
@@ -0,0 +1,247 @@
+/*
+ * Platform devices for EMMA3TL2 ET-MC10158
+ *
+ * Copyright (C) 2009  NEC Electronics Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * (version 2) as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/irq.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/addrspace.h>
+#include <asm/emma/emmaxxx.h>
+#include <asm/emma/prom.h>
+#include <linux/nec_candy_pd.h>
+
+#define I2C_EMMA	"emma-iic" /* must be in sync with IIC driver */
+
+static struct resource i2c_emma_resources_0[] = {
+	{
+		.start	= EMMA_IRQ_PIIC0,
+		.end	= EMMA_IRQ_PIIC0,
+		.flags	= IORESOURCE_IRQ
+	}, {
+		.start	= CKSEG1ADDR(EMMA_PIIC0_BASE),
+		.end	= CKSEG1ADDR(EMMA_PIIC0_BASE + 0x1000 - 1),
+	}, {
+		.start	= CKSEG1ADDR(EMMA_PBRD_BASE),
+		.end	= CKSEG1ADDR(EMMA_PBRD_BASE + 0x1000 - 1),
+		.name	= "pbrd",
+	}
+};
+
+static struct resource i2c_emma_resources_1[] = {
+	{
+		.start	= EMMA_IRQ_PIIC1,
+		.end	= EMMA_IRQ_PIIC1,
+		.flags	= IORESOURCE_IRQ
+	}, {
+		.start	= CKSEG1ADDR(EMMA_PIIC1_BASE),
+		.end	= CKSEG1ADDR(EMMA_PIIC1_BASE + 0x1000 - 1),
+	}, {
+		.start	= CKSEG1ADDR(EMMA_PBRD_BASE),
+		.end	= CKSEG1ADDR(EMMA_PBRD_BASE + 0x1000 - 1),
+		.name	= "pbrd",
+	}
+};
+
+static struct resource i2c_emma_resources_2[] = {
+	{
+		.start	= EMMA_IRQ_PIIC2,
+		.end	= EMMA_IRQ_PIIC2,
+		.flags	= IORESOURCE_IRQ
+	}, {
+		.start	= CKSEG1ADDR(EMMA_PIIC2_BASE),
+		.end	= CKSEG1ADDR(EMMA_PIIC2_BASE + 0x1000 - 1),
+	}, {
+		.start	= CKSEG1ADDR(EMMA_PBRD_BASE),
+		.end	= CKSEG1ADDR(EMMA_PBRD_BASE + 0x1000 - 1),
+		.name	= "pbrd",
+	}
+};
+
+struct platform_device i2c_emma_devices[] = {
+	[0] = {
+		.name		= I2C_EMMA,
+		.id		= 0,
+		.resource	= i2c_emma_resources_0,
+		.num_resources	= ARRAY_SIZE(i2c_emma_resources_0),
+	},
+	[1] = {
+		.name           = I2C_EMMA,
+		.id		= 1,
+		.resource	= i2c_emma_resources_1,
+		.num_resources	= ARRAY_SIZE(i2c_emma_resources_1),
+	},
+	[2] = {
+		.name           = I2C_EMMA,
+		.id		= 2,
+		.resource	= i2c_emma_resources_2,
+		.num_resources	= ARRAY_SIZE(i2c_emma_resources_2),
+	},
+};
+
+static struct nec_candy_platform_data nec_candy_pdata = {
+	.pmd_addr	= 0x1f,
+	.rmii		= 1,
+	.clks		= MIIC_CLKS166,
+};
+
+static struct platform_device nec_candy_device = {
+	.name			= "nec_candy",
+	.id			= 0,
+	.dev.platform_data	= &nec_candy_pdata,
+	.num_resources		= 2,
+	.resource = (struct resource[]) {
+		{
+			.name	= "nec_candy_regs",
+			.start	= EMMA_ETHER_BASE,
+			.end	= EMMA_ETHER_BASE + 0x400 - 1,
+			.flags	= IORESOURCE_MEM,
+		},
+		{
+			.name	= "nec_candy_irq",
+			.start	= EMMA_IRQ_ETHER,
+			.end	= EMMA_IRQ_ETHER,
+			.flags	= IORESOURCE_IRQ,
+		},
+	},
+};
+
+static u64 ohci_dmamask = DMA_BIT_MASK(32);
+
+static struct platform_device emma_ohci = {
+	.name = "emma-ohci",
+	.id = 0,
+	.dev = {
+		.dma_mask		= &ohci_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+	},
+	.num_resources = 3,
+	.resource = (struct resource[]) {
+		{
+			.start	= EMMA_OHCI_BASE,
+			.end	= EMMA_OHCI_BASE + 0xff,
+			.flags	= IORESOURCE_MEM,
+		},
+		{
+			.start	= EMMA_IRQ_USB,
+			.end	= EMMA_IRQ_USB,
+			.flags	= IORESOURCE_IRQ,
+		},
+		{
+			.start	= EMMA_OHCI_CONFIG_BASE,
+			.end	= EMMA_OHCI_CONFIG_BASE + 0xff,
+			.flags	= IORESOURCE_MEM,
+		},
+	},
+};
+
+static u64 ehci_dmamask = DMA_BIT_MASK(32);
+
+static struct platform_device emma_ehci = {
+	.name = "emma-ehci",
+	.id = 0,
+	.dev = {
+		.dma_mask		= &ehci_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+	},
+	.num_resources = 3,
+	.resource = (struct resource[]) {
+		{
+			.start	= EMMA_EHCI_BASE,
+			.end	= EMMA_EHCI_BASE + 0xff,
+			.flags	= IORESOURCE_MEM,
+		},
+		{
+			.start	= EMMA_IRQ_USB,
+			.end	= EMMA_IRQ_USB,
+			.flags	= IORESOURCE_IRQ,
+		},
+		{
+			.start	= EMMA_EHCI_CONFIG_BASE,
+			.end	= EMMA_EHCI_CONFIG_BASE + 0xff,
+			.flags	= IORESOURCE_MEM,
+		},
+	},
+};
+
+static struct platform_device *devices[] = {
+	&i2c_emma_devices[0],
+	&i2c_emma_devices[1],
+	&i2c_emma_devices[2],
+	&emma_ohci,
+	&emma_ehci,
+	&nec_candy_device,
+};
+
+#ifdef CONFIG_MTD_CFI
+static struct mtd_partition et10158_parts[] = {
+	[0] = {
+		.name	= "Root FS",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= 0x01500000,
+	},
+	[1] = {
+		.name	= "kernel image",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= 0x00700000,
+	},
+	[2] = {
+		.name	= "boot code area",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= 0x00200000,
+	},
+	[3] = {
+		.name	= "boot env area",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= 0x00040000,
+		.mask_flags = MTD_WRITEABLE,  /* force read-only */
+	},
+	[4] = {
+		.name	= "Free Area",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= 0x001C0000,
+	},
+};
+#endif
+
+#define EMMA_MAC_FLASH	0xbfe20000
+
+static int __init platform_devices_setup(void)
+{
+#ifdef CONFIG_MTD_CFI
+	physmap_set_partitions(et10158_parts, ARRAY_SIZE(et10158_parts));
+#endif
+
+	if (get_ethernet_addr(nec_candy_pdata.mac_addr)) {
+		/*
+		 * No 'ethaddr' string found in the environment variables.
+		 * Then finally try to copy bytes from the flash device
+		 * to maintain backward compatibility with earlier releases.
+		 */
+		memcpy(nec_candy_pdata.mac_addr, (void *)EMMA_MAC_FLASH, 6);
+	}
+
+	return platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+arch_initcall(platform_devices_setup);
diff --git a/arch/mips/emma/et10158/setup.c b/arch/mips/emma/et10158/setup.c
new file mode 100644
index 0000000..361e060
--- /dev/null
+++ b/arch/mips/emma/et10158/setup.c
@@ -0,0 +1,145 @@
+/*
+ * This file is setup for EMMA3TL2 ET-MC10158 evaluation board.
+ *
+ * Copyright (C) 2009  NEC Electronics Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * (version 2) as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/serial_8250.h>
+#include <linux/kgdb.h>
+
+#include <asm/addrspace.h>
+#include <asm/io.h>
+#include <asm/time.h>
+#include <asm/reboot.h>
+
+#include <asm/emma/emmaxxx.h>
+#include <asm/emma/flip.h>
+
+static int bus_frequency;
+
+static void et10158_machine_restart(char *command)
+{
+	static void (*back_to_prom) (void) = (void (*)(void))0xbfc00000;
+
+	printk(KERN_INFO "EMMA3TL2 ET10158 restart.\n");
+	back_to_prom();
+}
+
+static void et10158_machine_halt(void)
+{
+	printk(KERN_INFO "EMMA3TL2 ET10158 halted.\n");
+	while (1)
+		;
+}
+
+static void et10158_machine_power_off(void)
+{
+	printk(KERN_INFO "EMMA3TL2 ET10158 halted. Please turn off the power.\n");
+	while (1)
+		;
+}
+
+static unsigned long emma_clock[2] = { 327680000, 262144000 };
+
+static unsigned int __init detect_bus_frequency(void)
+{
+	u32 reg;
+
+	/* detect from boot strap */
+	reg = emma_in32(EMMA_BHIF_STRAP_0);
+	reg = (reg >> 4) & 0x1;	/* CPUCLK_SEL */
+
+	return emma_clock[reg];
+}
+
+void __init plat_time_init(void)
+{
+	if (bus_frequency == 0)
+		bus_frequency = detect_bus_frequency();
+
+	mips_hpt_frequency = bus_frequency / 2;
+}
+
+static void __init et10158_sio_setup(void)
+{
+	struct uart_port up;
+#ifdef CONFIG_KGDB
+	int emma_uart;
+#endif
+
+	memset(&up, 0, sizeof(up));
+
+	up.flags	= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST;
+	up.iotype	= UPIO_DWAPB;
+	up.regshift	= 2;
+	up.uartclk	= 24000000;
+
+	up.line		= 0;
+	up.mapbase	= EMMA_PUART0_BASE + 3;
+	up.membase	= ioremap_nocache(up.mapbase, 0x40 << up.regshift);
+	up.irq		= EMMA_IRQ_PUART0;
+	up.private_data	= (void *)(up.membase + (0x1F << up.regshift));
+
+	early_serial_setup(&up);
+
+#ifdef CONFIG_KGDB
+	emma_uart	= 1;
+	up.line		= emma_uart;
+	up.mapbase	= EMMA_PUART0_BASE + 0x1000 * emma_uart + 3;
+	up.membase	= ioremap_nocache(up.mapbase, 0x40 << up.regshift);
+	up.irq		= EMMA_IRQ_PUART0 + emma_uart;
+	up.private_data	= (void *)(up.membase + (0x1F << up.regshift));
+
+	early_serial_setup(&up);
+#endif
+}
+
+static void __init flip_init(void)
+{
+	struct flip_regs *flip;
+
+	flip = ioremap(EMMA_FLIP_BASE + 0x100, sizeof(struct flip_regs));
+
+	/* For USB HCs */
+	emma_out(flip->m_ctr[0], SWAP1_BYTE);
+	emma_out(flip->usb_ctr,
+		 PPON2_EN | PPON1_EN | OCI2_EN | OCI1_EN |
+		 PPON2 | PPON1 | OCI2 | OCI1 | INTB_EN | INTA_EN);
+	emma_sync();
+
+	iounmap((void __iomem *)flip);
+}
+
+void __init plat_mem_setup(void)
+{
+	set_io_port_base(CKSEG1);
+
+	_machine_restart = et10158_machine_restart;
+	_machine_halt = et10158_machine_halt;
+	pm_power_off = et10158_machine_power_off;
+
+	/* setup resource limits */
+	ioport_resource.end = ~0;
+
+	/* Reboot on panic */
+	panic_timeout = 50;
+
+	et10158_sio_setup();
+	flip_init();
+}
-- 
1.6.3.3

