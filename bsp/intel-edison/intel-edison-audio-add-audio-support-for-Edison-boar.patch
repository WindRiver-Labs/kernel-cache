From 9a021c7a81ef83692ea4dc35f62bffba89d0d49b Mon Sep 17 00:00:00 2001
From: Liwei Song <liwei.song@windriver.com>
Date: Sun, 24 Apr 2016 22:42:55 -0400
Subject: [PATCH] intel-edison/audio: add audio support for Edison board

This patch is from yocto Intel Edison support:
http://downloadmirror.intel.com/25028/eng/edison-src-ww25.5-15.tgz

Enable Audio support for Edison board. Driver name: intel_sst_driver

Signed-off-by: Liwei Song <liwei.song@windriver.com>
---
 arch/x86/include/asm/intel_sst_mrfld.h             |   44 +
 arch/x86/include/asm/platform_byt_audio.h          |   49 +
 arch/x86/include/asm/platform_sst.h                |  132 ++
 arch/x86/include/asm/platform_sst_audio.h          |  161 ++
 arch/x86/platform/intel-mid/device_libs/Makefile   |    9 +-
 .../intel-mid/device_libs/pci/platform_sst_pci.c   |  229 +++
 .../intel-mid/device_libs/platform_mrfld_audio.c   |  151 ++
 .../intel-mid/device_libs/platform_sst_audio.c     |  152 ++
 drivers/usb/dwc3/dwc3-host-intel.c                 |    2 +-
 include/linux/mfd/wm8994/pdata.h                   |   14 +
 include/sound/compress_driver.h                    |    7 +
 include/sound/core.h                               |    5 +
 include/sound/effect_driver.h                      |   63 +
 include/sound/intel_sst_ioctl.h                    |   63 +
 include/sound/pcm.h                                |    1 +
 include/sound/soc-dai.h                            |    4 +-
 include/sound/soc.h                                |   34 +
 include/uapi/sound/effect_offload.h                |   62 +
 sound/core/Kconfig                                 |    3 +
 sound/core/Makefile                                |    2 +
 sound/core/compress_offload.c                      |   71 +-
 sound/core/effects_offload.c                       |  307 +++
 sound/soc/codecs/sn95031.c                         |    2 +-
 sound/soc/codecs/wm8994.c                          |  305 +++-
 sound/soc/codecs/wm8994.h                          |   11 +
 sound/soc/codecs/wm_hubs.c                         |   19 +-
 sound/soc/intel/Kconfig                            |   47 +-
 sound/soc/intel/Makefile                           |   18 +-
 sound/soc/intel/board/Makefile                     |   14 +
 sound/soc/intel/board/merr_dpcm_dummy.c            |  201 ++
 sound/soc/intel/board/merr_dpcm_wm8958.c           |  931 +++++++++
 sound/soc/intel/board/merr_saltbay_wm8958.c        |  887 +++++++++
 sound/soc/intel/compress.c                         |  254 +++
 sound/soc/intel/effects.c                          |  405 ++++
 sound/soc/intel/pcm.c                              | 1021 ++++++++++
 sound/soc/intel/platform-libs/controls_v1.c        |  184 ++
 sound/soc/intel/platform-libs/controls_v2.c        | 1768 +++++++++++++++++
 sound/soc/intel/platform-libs/controls_v2.h        |  708 +++++++
 sound/soc/intel/platform-libs/controls_v2_dpcm.c   | 1801 ++++++++++++++++++
 sound/soc/intel/platform-libs/ipc_lib.h            |   33 +
 sound/soc/intel/platform-libs/ipc_lib_v2.c         |  109 ++
 sound/soc/intel/platform-libs/sst_widgets.h        |  337 ++++
 sound/soc/intel/platform_ipc_v2.h                  |  693 +++++++
 sound/soc/intel/ssp/Makefile                       |    5 +
 sound/soc/intel/ssp/mid_ssp.c                      | 1436 ++++++++++++++
 sound/soc/intel/ssp/mid_ssp.h                      |  124 ++
 sound/soc/intel/sst/Makefile                       |   13 +
 sound/soc/intel/sst/sst.c                          | 1255 ++++++++++++
 sound/soc/intel/sst/sst.h                          |  932 +++++++++
 sound/soc/intel/sst/sst_acpi.c                     |  661 +++++++
 sound/soc/intel/sst/sst_app_compat_interface.c     |   85 +
 sound/soc/intel/sst/sst_app_interface.c            |  342 ++++
 sound/soc/intel/sst/sst_debug.c                    | 1328 +++++++++++++
 sound/soc/intel/sst/sst_drv_interface.c            | 1111 +++++++++++
 sound/soc/intel/sst/sst_dsp.c                      | 1992 ++++++++++++++++++++
 sound/soc/intel/sst/sst_ipc.c                      |  768 ++++++++
 sound/soc/intel/sst/sst_pvt.c                      |  577 ++++++
 sound/soc/intel/sst/sst_stream.c                   |  831 ++++++++
 sound/soc/intel/sst/sst_trace.h                    |  147 ++
 sound/soc/intel/sst_platform.c                     |  725 -------
 sound/soc/intel/sst_platform.h                     |  136 +-
 sound/soc/intel/sst_platform_pvt.h                 |  127 ++
 sound/soc/soc-compress.c                           |   82 +-
 sound/soc/soc-core.c                               |   18 +
 sound/soc/soc-jack.c                               |    7 +-
 sound/soc/soc-pcm.c                                |   17 +-
 sound/soc/soc-utils.c                              |   28 +-
 67 files changed, 23134 insertions(+), 926 deletions(-)
 create mode 100644 arch/x86/include/asm/intel_sst_mrfld.h
 create mode 100644 arch/x86/include/asm/platform_byt_audio.h
 create mode 100644 arch/x86/include/asm/platform_sst.h
 create mode 100644 arch/x86/include/asm/platform_sst_audio.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/pci/platform_sst_pci.c
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_mrfld_audio.c
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_sst_audio.c
 create mode 100644 include/sound/effect_driver.h
 create mode 100644 include/sound/intel_sst_ioctl.h
 create mode 100644 include/uapi/sound/effect_offload.h
 create mode 100644 sound/core/effects_offload.c
 create mode 100644 sound/soc/intel/board/Makefile
 create mode 100644 sound/soc/intel/board/merr_dpcm_dummy.c
 create mode 100644 sound/soc/intel/board/merr_dpcm_wm8958.c
 create mode 100644 sound/soc/intel/board/merr_saltbay_wm8958.c
 create mode 100644 sound/soc/intel/compress.c
 create mode 100644 sound/soc/intel/effects.c
 create mode 100644 sound/soc/intel/pcm.c
 create mode 100644 sound/soc/intel/platform-libs/controls_v1.c
 create mode 100644 sound/soc/intel/platform-libs/controls_v2.c
 create mode 100644 sound/soc/intel/platform-libs/controls_v2.h
 create mode 100644 sound/soc/intel/platform-libs/controls_v2_dpcm.c
 create mode 100644 sound/soc/intel/platform-libs/ipc_lib.h
 create mode 100644 sound/soc/intel/platform-libs/ipc_lib_v2.c
 create mode 100644 sound/soc/intel/platform-libs/sst_widgets.h
 create mode 100644 sound/soc/intel/platform_ipc_v2.h
 create mode 100644 sound/soc/intel/ssp/Makefile
 create mode 100644 sound/soc/intel/ssp/mid_ssp.c
 create mode 100644 sound/soc/intel/ssp/mid_ssp.h
 create mode 100644 sound/soc/intel/sst/Makefile
 create mode 100644 sound/soc/intel/sst/sst.c
 create mode 100644 sound/soc/intel/sst/sst.h
 create mode 100644 sound/soc/intel/sst/sst_acpi.c
 create mode 100644 sound/soc/intel/sst/sst_app_compat_interface.c
 create mode 100644 sound/soc/intel/sst/sst_app_interface.c
 create mode 100644 sound/soc/intel/sst/sst_debug.c
 create mode 100644 sound/soc/intel/sst/sst_drv_interface.c
 create mode 100644 sound/soc/intel/sst/sst_dsp.c
 create mode 100644 sound/soc/intel/sst/sst_ipc.c
 create mode 100644 sound/soc/intel/sst/sst_pvt.c
 create mode 100644 sound/soc/intel/sst/sst_stream.c
 create mode 100644 sound/soc/intel/sst/sst_trace.h
 delete mode 100644 sound/soc/intel/sst_platform.c
 create mode 100644 sound/soc/intel/sst_platform_pvt.h

diff --git a/arch/x86/include/asm/intel_sst_mrfld.h b/arch/x86/include/asm/intel_sst_mrfld.h
new file mode 100644
index 0000000..041ff85
--- /dev/null
+++ b/arch/x86/include/asm/intel_sst_mrfld.h
@@ -0,0 +1,44 @@
+/* intel_sst_mrlfd.h - Common enum of the Merrifield platform
+ *
+ *  Copyright (C) 2013 Intel Corp
+ *  Author: Samreen Nilofer <samreen.nilofer@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+#ifndef _INTEL_SST_MRFLD_H
+#define _INTEL_SST_MRFLD_H
+
+enum {
+	MERR_SALTBAY_AUDIO = 0,
+	MERR_SALTBAY_COMPR,
+	MERR_SALTBAY_VOIP,
+	MERR_SALTBAY_PROBE,
+	MERR_SALTBAY_AWARE,
+	MERR_SALTBAY_VAD,
+	MERR_SALTBAY_POWER,
+};
+
+enum {
+	MERR_DPCM_AUDIO = 0,
+	MERR_DPCM_DB,
+	MERR_DPCM_LL,
+	MERR_DPCM_COMPR,
+	MERR_DPCM_VOIP,
+	MERR_DPCM_PROBE,
+};
+
+#endif
diff --git a/arch/x86/include/asm/platform_byt_audio.h b/arch/x86/include/asm/platform_byt_audio.h
new file mode 100644
index 0000000..fed2b1b
--- /dev/null
+++ b/arch/x86/include/asm/platform_byt_audio.h
@@ -0,0 +1,49 @@
+/*
+ * platform_byt_audio.h: Baytrail audio platform data header file
+ *
+ * (C) Copyright 2013 Intel Corporation
+ * Author: Omair Md Abdullah <omair.m.abdullah@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_BYT_AUDIO_H_
+#define _PLATFORM_BYT_AUDIO_H_
+
+enum {
+	BYT_AUD_AIF1 = 0,
+	BYT_AUD_AIF2,
+	BYT_AUD_COMPR_DEV,
+#ifdef CONFIG_SND_SOC_COMMS_SSP
+	BYT_COMMS_BT,
+	BYT_COMMS_MODEM,
+#endif /* CONFIG_SND_SOC_COMMS_SSP */
+	BYT_AUD_PROBE_DEV,
+};
+
+enum {
+	BYT_CR_AUD_AIF1 = 0,
+	BYT_CR_AUD_COMPR_DEV,
+	BYT_CR_COMMS_BT,
+};
+/* LPE viewpoint addresses */
+/* TODO: move to DSDT */
+#define SST_BYT_IRAM_PHY_START	0xff2c0000
+#define SST_BYT_IRAM_PHY_END	0xff2d4000
+#define SST_BYT_DRAM_PHY_START	0xff300000
+#define SST_BYT_DRAM_PHY_END	0xff320000
+#define SST_BYT_IMR_VIRT_START	0xc0000000 /* virtual addr in LPE */
+#define SST_BYT_IMR_VIRT_END	0xc01fffff
+#define SST_BYT_SHIM_PHY_ADDR	0xff340000
+#define SST_BYT_MBOX_PHY_ADDR	0xff344000
+#define SST_BYT_DMA0_PHY_ADDR	0xff298000
+#define SST_BYT_DMA1_PHY_ADDR	0xff29c000
+#define SST_BYT_SSP0_PHY_ADDR	0xff2a0000
+#define SST_BYT_SSP2_PHY_ADDR	0xff2a2000
+
+#define BYT_FW_MOD_TABLE_OFFSET 0x80000
+#define BYT_FW_MOD_TABLE_SIZE   0x100
+
+#endif
diff --git a/arch/x86/include/asm/platform_sst.h b/arch/x86/include/asm/platform_sst.h
new file mode 100644
index 0000000..e752ed9
--- /dev/null
+++ b/arch/x86/include/asm/platform_sst.h
@@ -0,0 +1,132 @@
+
+/*
+ * platform_sst.h:  sst audio platform data header file
+ *
+ * Copyright (C) 2013 Intel Corporation
+ * Author: Dharageswari R <dharageswari.r@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#ifndef _PLATFORM_SST_H_
+#define _PLATFORM_SST_H_
+
+#include <linux/sfi.h>
+
+#define MAX_NUM_STREAMS_CTP	5
+#define MAX_NUM_STREAMS_MRFLD	25
+#define MAX_NUM_STREAMS	MAX_NUM_STREAMS_MRFLD
+
+#define SST_MAX_SSP_PORTS 4
+#define SST_MAX_DMA 2
+
+enum {
+	SST_SSP_AUDIO = 0,
+	SST_SSP_MODEM,
+	SST_SSP_BT,
+	SST_SSP_FM,
+};
+
+struct sst_gpio_config {
+	u32 i2s_rx_alt;
+	u32 i2s_tx_alt;
+	u32 i2s_frame;
+	u32 i2s_clock;
+	u32 alt_function;
+};
+
+struct sst_ssp_info {
+	u32 base_add;
+	struct sst_gpio_config gpio;
+	bool gpio_in_use;
+};
+
+struct sst_info {
+	u32 iram_start;
+	u32 iram_end;
+	bool iram_use;
+	u32 dram_start;
+	u32 dram_end;
+	bool dram_use;
+	u32 imr_start;
+	u32 imr_end;
+	bool imr_use;
+	u32 mailbox_start;
+	bool use_elf;
+	bool lpe_viewpt_rqd;
+	unsigned int max_streams;
+	u32 dma_max_len;
+	u8 num_probes;
+};
+
+struct sst_ssp_platform_cfg {
+	u8 ssp_cfg_sst;
+	u8 port_number;
+	u8 is_master;
+	u8 pack_mode;
+	u8 num_slots_per_frame;
+	u8 num_bits_per_slot;
+	u8 active_tx_map;
+	u8 active_rx_map;
+	u8 ssp_frame_format;
+	u8 frame_polarity;
+	u8 serial_bitrate_clk_mode;
+	u8 frame_sync_width;
+	u8 dma_handshake_interface_tx;
+	u8 dma_handshake_interface_rx;
+	u8 network_mode;
+	u8 start_delay;
+	u32 ssp_base_add;
+} __packed;
+
+struct sst_board_config_data {
+	struct sst_ssp_platform_cfg ssp_platform_data[SST_MAX_SSP_PORTS];
+	u8 active_ssp_ports;
+	u8 platform_id;
+	u8 board_id;
+	u8 ihf_num_chan;
+	u32 osc_clk_freq;
+} __packed;
+
+struct sst_platform_config_data {
+	u32 sst_sram_buff_base;
+	u32 sst_dma_base[SST_MAX_DMA];
+} __packed;
+
+struct sst_platform_debugfs_data {
+	u32 ssp_reg_size;
+	u32 dma_reg_size;
+	u32 checkpoint_offset;
+	u32 checkpoint_size;
+	u8 num_ssp;
+	u8 num_dma;
+};
+
+struct sst_ipc_info {
+	int ipc_offset;
+	bool use_32bit_ops;
+	unsigned int mbox_recv_off;
+};
+
+struct sst_lib_dnld_info {
+	unsigned int mod_base;
+	unsigned int mod_end;
+	unsigned int mod_table_offset;
+	unsigned int mod_table_size;
+	bool mod_ddr_dnld;
+};
+
+struct sst_platform_info {
+	const struct sst_info *probe_data;
+	const struct sst_ssp_info *ssp_data;
+	const struct sst_board_config_data *bdata;
+	const struct sst_platform_config_data *pdata;
+	const struct sst_ipc_info *ipc_info;
+	const struct sst_platform_debugfs_data *debugfs_data;
+	const struct sst_lib_dnld_info *lib_info;
+};
+
+#endif
diff --git a/arch/x86/include/asm/platform_sst_audio.h b/arch/x86/include/asm/platform_sst_audio.h
new file mode 100644
index 0000000..6333631
--- /dev/null
+++ b/arch/x86/include/asm/platform_sst_audio.h
@@ -0,0 +1,161 @@
+/*
+ * platform_sst_audio.h:  sst audio platform data header file
+ *
+ * Copyright (C) 2012 Intel Corporation
+ * Author: Jeeja KP <jeeja.kp@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_SST_AUDIO_H_
+#define _PLATFORM_SST_AUDIO_H_
+
+#include <linux/sfi.h>
+
+/* The stream map status is used to dynamically assign
+ * device-id to a device, for example probe device. If
+ * a stream map entry is free for a device then the device-id
+ * for that device will be popluated when the device is
+ * opened and then the status set to IN_USE. When device
+ * is closed, the strm map status is set to FREE again.
+ */
+enum sst_strm_map_status {
+	SST_DEV_MAP_FREE = 0,
+	SST_DEV_MAP_IN_USE,
+};
+
+/* Device IDs for CTP are same as stream IDs */
+enum sst_audio_device_id_ctp {
+	SST_PCM_OUT0 = 1,
+	SST_PCM_OUT1 = 2,
+	SST_COMPRESSED_OUT = 3,
+	SST_CAPTURE_IN = 4,
+	SST_PROBE_IN = 5,
+};
+
+enum sst_audio_task_id_mrfld {
+	SST_TASK_ID_NONE = 0,
+	SST_TASK_ID_SBA = 1,
+	SST_TASK_ID_FBA_UL = 2,
+	SST_TASK_ID_MEDIA = 3,
+	SST_TASK_ID_AWARE = 4,
+	SST_TASK_ID_FBA_DL = 5,
+	SST_TASK_ID_MAX = SST_TASK_ID_FBA_DL,
+};
+
+/* Device IDs for Merrifield are Pipe IDs,
+ * ref: LPE DSP command interface spec v0.75 */
+enum sst_audio_device_id_mrfld {
+	/* Output pipeline IDs */
+	PIPE_ID_OUT_START = 0x0,
+	PIPE_MODEM_OUT = 0x0,
+	PIPE_BT_OUT = 0x1,
+	PIPE_CODEC_OUT0 = 0x2,
+	PIPE_CODEC_OUT1 = 0x3,
+	PIPE_SPROT_LOOP_OUT = 0x4,
+	PIPE_MEDIA_LOOP1_OUT = 0x5,
+	PIPE_MEDIA_LOOP2_OUT = 0x6,
+	PIPE_PROBE_OUT = 0x7,
+	PIPE_HF_SNS_OUT = 0x8, /* VOCIE_UPLINK_REF2 */
+	PIPE_HF_OUT = 0x9, /* VOICE_UPLINK_REF1 */
+	PIPE_SPEECH_OUT = 0xA, /* VOICE UPLINK */
+	PIPE_RxSPEECH_OUT = 0xB, /* VOICE_DOWNLINK */
+	PIPE_VOIP_OUT = 0xC,
+	PIPE_PCM0_OUT = 0xD,
+	PIPE_PCM1_OUT = 0xE,
+	PIPE_PCM2_OUT = 0xF,
+	PIPE_AWARE_OUT = 0x10,
+	PIPE_VAD_OUT = 0x11,
+	PIPE_MEDIA0_OUT = 0x12,
+	PIPE_MEDIA1_OUT = 0x13,
+	PIPE_FM_OUT = 0x14,
+	PIPE_PROBE1_OUT = 0x15,
+	PIPE_PROBE2_OUT = 0x16,
+	PIPE_PROBE3_OUT = 0x17,
+	PIPE_PROBE4_OUT = 0x18,
+	PIPE_PROBE5_OUT = 0x19,
+	PIPE_PROBE6_OUT = 0x1A,
+	PIPE_PROBE7_OUT = 0x1B,
+	PIPE_PROBE8_OUT = 0x1C,
+/* Input Pipeline IDs */
+	PIPE_ID_IN_START = 0x80,
+	PIPE_MODEM_IN = 0x80,
+	PIPE_BT_IN = 0x81,
+	PIPE_CODEC_IN0 = 0x82,
+	PIPE_CODEC_IN1 = 0x83,
+	PIPE_SPROT_LOOP_IN = 0x84,
+	PIPE_MEDIA_LOOP1_IN = 0x85,
+	PIPE_MEDIA_LOOP2_IN = 0x86,
+	PIPE_PROBE_IN = 0x87,
+	PIPE_SIDETONE_IN = 0x88,
+	PIPE_TxSPEECH_IN = 0x89,
+	PIPE_SPEECH_IN = 0x8A,
+	PIPE_TONE_IN = 0x8B,
+	PIPE_VOIP_IN = 0x8C,
+	PIPE_PCM0_IN = 0x8D,
+	PIPE_PCM1_IN = 0x8E,
+	PIPE_MEDIA0_IN = 0x8F,
+	PIPE_MEDIA1_IN = 0x90,
+	PIPE_MEDIA2_IN = 0x91,
+	PIPE_FM_IN = 0x92,
+	PIPE_PROBE1_IN = 0x93,
+	PIPE_PROBE2_IN = 0x94,
+	PIPE_PROBE3_IN = 0x95,
+	PIPE_PROBE4_IN = 0x96,
+	PIPE_PROBE5_IN = 0x97,
+	PIPE_PROBE6_IN = 0x98,
+	PIPE_PROBE7_IN = 0x99,
+	PIPE_PROBE8_IN = 0x9A,
+	PIPE_MEDIA3_IN = 0x9C,
+	PIPE_LOW_PCM0_IN = 0x9D,
+	PIPE_RSVD = 0xFF,
+};
+
+/* The stream map for each platform consists of an array of the below
+ * stream map structure. The array index is used as the static stream-id
+ * associated with a device and (dev_num,subdev_num,direction) tuple match
+ * gives the device_id for the device.
+ */
+struct sst_dev_stream_map {
+	u8 dev_num;
+	u8 subdev_num;
+	u8 direction;
+	u8 device_id;
+	u8 task_id;
+	u8 status;
+};
+
+#define MAX_DESCRIPTOR_SIZE 172
+
+struct sst_dev_effects_map {
+	char	uuid[16];
+	u16	algo_id;
+	char	descriptor[MAX_DESCRIPTOR_SIZE];
+};
+
+struct sst_dev_effects_resource_map {
+	char  uuid[16];
+	unsigned int flags;
+	u16 cpuLoad;
+	u16 memoryUsage;
+};
+
+struct sst_dev_effects {
+	struct sst_dev_effects_map *effs_map;
+	struct sst_dev_effects_resource_map *effs_res_map;
+	unsigned int effs_num_map;
+};
+
+struct sst_platform_data {
+	/* Intel software platform id*/
+	const struct soft_platform_id *spid;
+	struct sst_dev_stream_map *pdev_strm_map;
+	struct sst_dev_effects pdev_effs;
+	unsigned int strm_map_size;
+};
+
+int add_sst_platform_device(void);
+#endif
+
diff --git a/arch/x86/platform/intel-mid/device_libs/Makefile b/arch/x86/platform/intel-mid/device_libs/Makefile
index be2a8c1..3584e25 100644
--- a/arch/x86/platform/intel-mid/device_libs/Makefile
+++ b/arch/x86/platform/intel-mid/device_libs/Makefile
@@ -1,12 +1,16 @@
 # IPC Devices
+obj-y += platform_sst_audio.o
 obj-y += platform_ipc.o
 obj-y += platform_mrfl_regulator.o
 obj-y += platform_soc_thermal.o
+obj-$(subst m,y,$(CONFIG_SND_BYT_MACHINE)) += platform_byt_audio.o
+obj-$(subst m,y,$(CONFIG_SND_MRFLD_MACHINE)) += platform_mrfld_audio.o
+obj-$(subst m,y,$(CONFIG_SND_CTP_MACHINE)) += platform_ctp_audio.o
+obj-y += platform_msic.o
+obj-y += platform_msic_audio.o
 obj-y += platform_msic_gpio.o
 obj-y += platform_msic_ocd.o
 obj-y += platform_tc35876x.o
-obj-$(subst m,y,$(CONFIG_MFD_INTEL_MSIC)) += platform_msic.o
-obj-$(subst m,y,$(CONFIG_SND_MFLD_MACHINE)) += platform_msic_audio.o
 obj-$(subst m,y,$(CONFIG_MFD_INTEL_MSIC)) += platform_msic_battery.o
 obj-$(subst m,y,$(CONFIG_INTEL_MFLD_THERMAL)) += platform_msic_thermal.o
 obj-y += pci/
@@ -24,6 +28,7 @@ obj-$(subst m,y,$(CONFIG_INPUT_BMA150)) += platform_bma023.o
 obj-$(subst m,y,$(CONFIG_GPIO_PCA953X)) += platform_tca6416.o
 obj-$(subst m,y,$(CONFIG_BQ24261_CHARGER)) += platform_bq24261.o
 obj-$(subst m,y,$(CONFIG_GPIO_PCA953X)) += platform_pcal9555a.o
+obj-$(subst m,y,$(CONFIG_SND_SOC_WM8994)) += platform_wm8994.o
 obj-$(subst m,y,$(CONFIG_I2C_DESIGNWARE_CORE_FORK)) += platform_dw_i2c.o
 # SPI Devices
 obj-$(subst m,y,$(CONFIG_SERIAL_MRST_MAX3110)) += platform_max3111.o
diff --git a/arch/x86/platform/intel-mid/device_libs/pci/platform_sst_pci.c b/arch/x86/platform/intel-mid/device_libs/pci/platform_sst_pci.c
new file mode 100644
index 0000000..8721c3a
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/pci/platform_sst_pci.c
@@ -0,0 +1,229 @@
+/*
+ * platform_sst_pci.c: SST platform data initilization file
+ *
+ * (C) Copyright 2013 Intel Corporation
+ * Author:  Dharageswari R <dharageswari.r@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/gpio.h>
+#include <linux/lnw_gpio.h>
+#include <linux/delay.h>
+#include <linux/intel_mid_dma.h>
+#include <asm/intel-mid.h>
+#include <asm/platform_sst.h>
+
+#define CTP_SSP_BASE 0xffa23000
+#define CTP_DMA_BASE 0xffaf8000
+#define MRFLD_SSP_BASE 0xff2a0000
+#define MRFLD_DMA_BASE 0xff298000
+#define CTP_MAX_CONFIG_SIZE 500
+
+#define SST_CTP_IRAM_START	0
+#define SST_CTP_IRAM_END	0x80000
+#define SST_CTP_DRAM_START	0x400000
+#define SST_CTP_DRAM_END	0x480000
+#define SSP_SIZE 0x1000
+#define DMA_SIZE_CTP 0x1000
+#define DMA_SIZE_MRFLD 0x4000
+#define SST_CHECKPOINT_OFFSET 0x1C00
+#define SST_CHECKPOINT_OFFSET_MRFLD 0x0C00
+#define CHECKPOINT_DUMP_SZ 256
+
+#define SST_V1_MAILBOX_RECV	0x800
+#define SST_V2_MAILBOX_RECV	0x400
+
+#define MRFLD_FW_LSP_DDR_BASE 0xC5E00000
+#define MRFLD_FW_MOD_END (MRFLD_FW_LSP_DDR_BASE + 0x1FFFFF)
+#define MRFLD_FW_MOD_TABLE_OFFSET 0x80000
+#define MRFLD_FW_MOD_TABLE_SIZE 0x100
+
+struct sst_platform_info sst_data;
+
+static struct sst_ssp_info ssp_inf_ctp = {
+	.base_add = CTP_SSP_BASE,
+	.gpio = {
+		.alt_function = LNW_ALT_2,
+	},
+	.gpio_in_use = true,
+};
+
+static struct sst_ssp_info ssp_inf_mrfld = {
+	.base_add = MRFLD_SSP_BASE,
+	.gpio_in_use = false,
+};
+
+static const struct sst_platform_config_data sst_ctp_pdata = {
+	.sst_sram_buff_base = 0xfffc0000,
+	.sst_dma_base[0] = CTP_DMA_BASE,
+	.sst_dma_base[1] = 0x0,
+};
+
+static struct sst_platform_config_data sst_mrfld_pdata = {
+	.sst_dma_base[0] = MRFLD_DMA_BASE,
+	.sst_dma_base[1] = 0x0,
+};
+
+static const struct sst_board_config_data sst_ctp_bdata = {
+	.active_ssp_ports = 4,
+	.platform_id = 2,/*FIXME: Once the firmware fix is available*/
+	.board_id = 1,/*FIXME: Once the firmware fix is available*/
+	.ihf_num_chan = 2,
+	.osc_clk_freq = 19200000,
+	.ssp_platform_data = {
+		[SST_SSP_AUDIO] = {
+				.ssp_cfg_sst = 1,
+				.port_number = 3,
+				.is_master = 1,
+				.pack_mode = 1,
+				.num_slots_per_frame = 2,
+				.num_bits_per_slot = 25,
+				.active_tx_map = 3,
+				.active_rx_map = 3,
+				.ssp_frame_format = 3,
+				.frame_polarity = 0,
+				.serial_bitrate_clk_mode = 0,
+				.frame_sync_width = 24,
+				.dma_handshake_interface_tx = 5,
+				.dma_handshake_interface_rx = 4,
+				.ssp_base_add = 0xFFA23000,
+		},
+		[SST_SSP_MODEM] = {0},
+		[SST_SSP_BT] = {0},
+		[SST_SSP_FM] = {0},
+	},
+};
+
+static const struct sst_info ctp_sst_info = {
+	.iram_start = SST_CTP_IRAM_START,
+	.iram_end = SST_CTP_IRAM_END,
+	.iram_use = true,
+	.dram_start = SST_CTP_DRAM_START,
+	.dram_end = SST_CTP_DRAM_END,
+	.dram_use = true,
+	.imr_start = 0,
+	.imr_end = 0,
+	.imr_use = false,
+	.mailbox_start = 0,
+	.lpe_viewpt_rqd = false,
+	.use_elf = false,
+	.max_streams = MAX_NUM_STREAMS_CTP,
+	.dma_max_len = (SST_MAX_DMA_LEN * 4),
+	.num_probes = 1,
+};
+
+static const struct sst_ipc_info ctp_ipc_info = {
+	.use_32bit_ops = true,
+	.ipc_offset = 0,
+	.mbox_recv_off = SST_V1_MAILBOX_RECV,
+};
+
+static const struct sst_info mrfld_sst_info = {
+	.iram_start = 0,
+	.iram_end = 0,
+	.iram_use = false,
+	.dram_start = 0,
+	.dram_end = 0,
+	.dram_use = false,
+	.imr_start = 0,
+	.imr_end = 0,
+	.imr_use = false,
+	.mailbox_start = 0,
+	.use_elf = true,
+	.lpe_viewpt_rqd = false,
+	.max_streams = MAX_NUM_STREAMS_MRFLD,
+	.dma_max_len = SST_MAX_DMA_LEN_MRFLD,
+	.num_probes = 16,
+};
+
+static struct sst_platform_debugfs_data ctp_debugfs_data = {
+	.ssp_reg_size = SSP_SIZE,
+	.dma_reg_size = DMA_SIZE_CTP,
+	.num_ssp = 1,
+	.num_dma = 1,
+	.checkpoint_offset = SST_CHECKPOINT_OFFSET,
+	.checkpoint_size = CHECKPOINT_DUMP_SZ,
+};
+
+static struct sst_platform_debugfs_data mrfld_debugfs_data = {
+	.ssp_reg_size = SSP_SIZE,
+	.dma_reg_size = DMA_SIZE_MRFLD,
+	.num_ssp = 3,
+	.num_dma = 2,
+	.checkpoint_offset = SST_CHECKPOINT_OFFSET_MRFLD,
+	.checkpoint_size = CHECKPOINT_DUMP_SZ,
+};
+
+static const struct sst_ipc_info mrfld_ipc_info = {
+	.use_32bit_ops = false,
+	.ipc_offset = 0,
+	.mbox_recv_off = SST_V2_MAILBOX_RECV,
+};
+
+static const struct sst_lib_dnld_info  mrfld_lib_dnld_info = {
+	.mod_base           = MRFLD_FW_LSP_DDR_BASE,
+	.mod_end            = MRFLD_FW_MOD_END,
+	.mod_table_offset   = MRFLD_FW_MOD_TABLE_OFFSET,
+	.mod_table_size     = MRFLD_FW_MOD_TABLE_SIZE,
+	.mod_ddr_dnld       = true,
+};
+
+static int set_ctp_sst_config(struct sst_platform_info *sst_info)
+{
+	unsigned int conf_len;
+
+	ssp_inf_ctp.gpio.i2s_rx_alt = get_gpio_by_name("gpio_i2s3_rx");
+	ssp_inf_ctp.gpio.i2s_tx_alt = get_gpio_by_name("gpio_i2s3_rx");
+	ssp_inf_ctp.gpio.i2s_frame = get_gpio_by_name("gpio_i2s3_fs");
+	ssp_inf_ctp.gpio.i2s_clock = get_gpio_by_name("gpio_i2s3_clk");
+
+	sst_info->ssp_data = &ssp_inf_ctp;
+	conf_len = sizeof(sst_ctp_pdata) + sizeof(sst_ctp_bdata);
+	if (conf_len > CTP_MAX_CONFIG_SIZE)
+		return -EINVAL;
+	sst_info->pdata = &sst_ctp_pdata;
+	sst_info->bdata = &sst_ctp_bdata;
+	sst_info->probe_data = &ctp_sst_info;
+	sst_info->ipc_info = &ctp_ipc_info;
+	sst_info->debugfs_data = &ctp_debugfs_data;
+	sst_info->lib_info = NULL;
+
+	return 0;
+}
+
+static void set_mrfld_sst_config(struct sst_platform_info *sst_info)
+{
+	sst_info->ssp_data = &ssp_inf_mrfld;
+	sst_info->pdata = &sst_mrfld_pdata;
+	sst_info->bdata = NULL;
+	sst_info->probe_data = &mrfld_sst_info;
+	sst_info->ipc_info = &mrfld_ipc_info;
+	sst_info->debugfs_data = &mrfld_debugfs_data;
+	sst_info->lib_info = &mrfld_lib_dnld_info;
+
+	return ;
+
+}
+
+static struct sst_platform_info *get_sst_platform_data(struct pci_dev *pdev)
+{
+	struct sst_platform_info *sst_pinfo = NULL;
+
+	set_mrfld_sst_config(&sst_data);
+	sst_pinfo = &sst_data;
+
+	return sst_pinfo;
+}
+
+static void sst_pci_early_quirks(struct pci_dev *pci_dev)
+{
+	pci_dev->dev.platform_data = get_sst_platform_data(pci_dev);
+}
+
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_SST_MRFLD,
+							sst_pci_early_quirks);
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_mrfld_audio.c b/arch/x86/platform/intel-mid/device_libs/platform_mrfld_audio.c
new file mode 100644
index 0000000..0e8738b
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_mrfld_audio.c
@@ -0,0 +1,151 @@
+/*
+ * platform_mrfld_audio.c: MRFLD audio platform data initilization file
+ *
+ * (C) Copyright 2012 Intel Corporation
+ * Author: Dharageswari R <dharageswari.r@intel.com>
+ *	Vinod Koul <vinod.koul@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/interrupt.h>
+#include <linux/scatterlist.h>
+#include <linux/init.h>
+#include <linux/sfi.h>
+#include <linux/platform_device.h>
+#include <asm/intel-mid.h>
+#include <linux/platform_data/intel_mid_remoteproc.h>
+#include <asm/platform_sst_audio.h>
+#include "platform_mrfld_audio.h"
+#include "platform_msic.h"
+#include "platform_wm8994.h"
+
+static char* audio_codec = "dummy";
+module_param(audio_codec, charp, S_IRUSR);
+MODULE_PARM_DESC(audio_codec, "Hardware codec's name in use");
+
+static struct mrfld_audio_platform_data mrfld_audio_pdata;
+
+void *merfld_audio_platform_data(void *info)
+{
+	struct platform_device *pdev;
+	int ret;
+
+	pr_debug("in %s\n", __func__);
+
+	ret = add_sst_platform_device();
+	if (ret < 0) {
+		pr_err("%s failed to sst_platform device\n", __func__);
+		return NULL;
+	}
+
+	pdev = platform_device_alloc("hdmi-audio", -1);
+	if (!pdev) {
+		pr_err("failed to allocate hdmi-audio platform device\n");
+		return NULL;
+	}
+
+	ret = platform_device_add(pdev);
+	if (ret) {
+		pr_err("failed to add hdmi-audio platform device\n");
+		platform_device_put(pdev);
+		return NULL;
+	}
+
+	/* request the gpios for audio */
+	mrfld_audio_pdata.codec_gpio = get_gpio_by_name("audiocodec_int");
+	mrfld_audio_pdata.codec_rst = get_gpio_by_name("audiocodec_rst");
+
+	pdev = platform_device_alloc("mrfld_lm49453", -1);
+	if (!pdev) {
+		pr_err("failed to allocate mrfld_lm49453 platform device\n");
+		return NULL;
+	}
+
+	ret = platform_device_add(pdev);
+	if (ret) {
+		pr_err("failed to add mrfld_lm49453 platform device\n");
+		platform_device_put(pdev);
+		return NULL;
+	}
+	if (platform_device_add_data(pdev, &mrfld_audio_pdata,
+				     sizeof(mrfld_audio_pdata))) {
+		pr_err("failed to add mrfld_lm49453 platform data\n");
+		platform_device_put(pdev);
+		return NULL;
+	}
+
+	register_rpmsg_service("rpmsg_msic_mrfld_audio", RPROC_SCU,
+				RP_MSIC_MRFLD_AUDIO);
+
+	return NULL;
+}
+
+void *mrfld_sst_audio_platform_data(void *info)
+{
+	struct platform_device *pdev;
+	int ret;
+
+	ret = add_sst_platform_device();
+	if (ret < 0) {
+		pr_err("%s failed to sst_platform device\n", __func__);
+		return NULL;
+	}
+
+	if(!audio_codec || !strcmp(audio_codec, "dummy")) {
+		pdev = platform_device_register_simple("merr_dpcm_dummy",
+					0, NULL, 0);
+		if (!pdev) {
+			pr_err("failed to register merr_dpcm_dummy platform device\n");
+			return NULL;
+		}
+	} else if (!strcmp(audio_codec, "wm8958")) {
+		/* Register i2c audio codec wm8958 */
+		wm8958_platform_data(NULL);
+
+		pdev = platform_device_alloc("mrfld_wm8958", -1);
+		if (!pdev) {
+			pr_err("failed to allocate mrfld_wm8958 platform device\n");
+			return NULL;
+		}
+
+		ret = platform_device_add(pdev);
+		if (ret) {
+			pr_err("failed to add mrfld_wm8958 platform device\n");
+			platform_device_put(pdev);
+			return NULL;
+		}
+		if (platform_device_add_data(pdev, &mrfld_audio_pdata,
+						 sizeof(mrfld_audio_pdata))) {
+			pr_err("failed to add mrfld_wm8958 platform data\n");
+			platform_device_put(pdev);
+			return NULL;
+		}
+
+		register_rpmsg_service("rpmsg_mrfld_wm8958_audio", RPROC_SCU,
+					RP_MSIC_MRFLD_AUDIO);
+	}
+	/*
+	 * To add a new codec, add a "else if" statement with
+	 * its name and its specific implementation.
+	 */
+	else {
+		pr_info("Codec %s is not implemented."
+				"Dummy codec selected...\n", audio_codec);
+
+		pdev = platform_device_register_simple("merr_dpcm_dummy",
+							0, NULL, 0);
+		if (!pdev) {
+			pr_err("failed to register merr_dpcm_dummy platform device\n");
+			return NULL;
+		}
+	}
+
+	return NULL;
+}
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_sst_audio.c b/arch/x86/platform/intel-mid/device_libs/platform_sst_audio.c
new file mode 100644
index 0000000..7270162
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_sst_audio.c
@@ -0,0 +1,152 @@
+/*
+ * platform_sst_libs.c: SST platform  data initilization file
+ *
+ * Copyright (C) 2012 Intel Corporation
+ * Author: Jeeja KP <jeeja.kp@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/sfi.h>
+#include <linux/platform_device.h>
+#include <asm/platform_sst_audio.h>
+#include <asm/intel-mid.h>
+#include <asm/intel_sst_mrfld.h>
+#include <sound/asound.h>
+
+static struct sst_platform_data sst_platform_pdata;
+
+#if IS_BUILTIN(CONFIG_SST_MRFLD_DPCM)
+static struct sst_dev_stream_map mrfld_strm_map[] = {
+	{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, /* Reserved, not in use */
+	{MERR_DPCM_AUDIO, 0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_MEDIA1_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_DB,    0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_MEDIA3_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_LL,    0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_LOW_PCM0_IN, SST_TASK_ID_SBA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_COMPR, 0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_MEDIA0_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_VOIP,  0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_VOIP_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_PROBE1_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 1, SNDRV_PCM_STREAM_PLAYBACK, PIPE_PROBE2_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 2, SNDRV_PCM_STREAM_PLAYBACK, PIPE_PROBE3_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 3, SNDRV_PCM_STREAM_PLAYBACK, PIPE_PROBE4_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 4, SNDRV_PCM_STREAM_PLAYBACK, PIPE_PROBE5_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 5, SNDRV_PCM_STREAM_PLAYBACK, PIPE_PROBE6_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 6, SNDRV_PCM_STREAM_PLAYBACK, PIPE_PROBE7_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 7, SNDRV_PCM_STREAM_PLAYBACK, PIPE_PROBE8_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_AUDIO, 0, SNDRV_PCM_STREAM_CAPTURE, PIPE_PCM1_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_VOIP,  0, SNDRV_PCM_STREAM_CAPTURE, PIPE_VOIP_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 0, SNDRV_PCM_STREAM_CAPTURE, PIPE_PROBE1_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 1, SNDRV_PCM_STREAM_CAPTURE, PIPE_PROBE2_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 2, SNDRV_PCM_STREAM_CAPTURE, PIPE_PROBE3_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 3, SNDRV_PCM_STREAM_CAPTURE, PIPE_PROBE4_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 4, SNDRV_PCM_STREAM_CAPTURE, PIPE_PROBE5_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 5, SNDRV_PCM_STREAM_CAPTURE, PIPE_PROBE6_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 6, SNDRV_PCM_STREAM_CAPTURE, PIPE_PROBE7_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_DPCM_PROBE, 7, SNDRV_PCM_STREAM_CAPTURE, PIPE_PROBE8_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+};
+#else
+static struct sst_dev_stream_map mrfld_strm_map[] = {
+	{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}, /* Reserved, not in use */
+	{MERR_SALTBAY_AUDIO, 0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_AUDIO, 1, SNDRV_PCM_STREAM_PLAYBACK, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_AUDIO, 2, SNDRV_PCM_STREAM_PLAYBACK, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_COMPR, 0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_MEDIA0_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_SALTBAY_VOIP, 0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_VOIP_IN, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_SALTBAY_AUDIO, 0, SNDRV_PCM_STREAM_CAPTURE, PIPE_PCM1_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_SALTBAY_VOIP, 0, SNDRV_PCM_STREAM_CAPTURE, PIPE_VOIP_OUT, SST_TASK_ID_MEDIA, SST_DEV_MAP_IN_USE},
+	{MERR_SALTBAY_PROBE, 0, SNDRV_PCM_STREAM_CAPTURE, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 1, SNDRV_PCM_STREAM_CAPTURE, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 2, SNDRV_PCM_STREAM_CAPTURE, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 3, SNDRV_PCM_STREAM_CAPTURE, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 4, SNDRV_PCM_STREAM_CAPTURE, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 5, SNDRV_PCM_STREAM_CAPTURE, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 6, SNDRV_PCM_STREAM_CAPTURE, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 7, SNDRV_PCM_STREAM_CAPTURE, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 0, SNDRV_PCM_STREAM_PLAYBACK, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 1, SNDRV_PCM_STREAM_PLAYBACK, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 2, SNDRV_PCM_STREAM_PLAYBACK, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 3, SNDRV_PCM_STREAM_PLAYBACK, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 4, SNDRV_PCM_STREAM_PLAYBACK, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 5, SNDRV_PCM_STREAM_PLAYBACK, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 6, SNDRV_PCM_STREAM_PLAYBACK, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_PROBE, 7, SNDRV_PCM_STREAM_PLAYBACK, PIPE_RSVD, SST_TASK_ID_MEDIA, SST_DEV_MAP_FREE},
+	{MERR_SALTBAY_AWARE, 0, SNDRV_PCM_STREAM_CAPTURE, PIPE_AWARE_OUT, SST_TASK_ID_AWARE, SST_DEV_MAP_IN_USE},
+	{MERR_SALTBAY_VAD, 0, SNDRV_PCM_STREAM_CAPTURE, PIPE_VAD_OUT, SST_TASK_ID_AWARE, SST_DEV_MAP_IN_USE},
+};
+#endif
+
+#define EQ_EFFECT_ALGO_ID 0x99
+static struct sst_dev_effects_map mrfld_effs_map[] = {
+	{
+	  {0xc1, 0x47, 0xa2, 0xf7, 0x7b, 0x1a, 0xe0, 0x11, 0x0d, 0xbb, 0x2a, 0x30, 0xdf, 0xd7, 0x20, 0x45},/* uuid */
+	   EQ_EFFECT_ALGO_ID,										   /* algo id */
+	  {0x00, 0x43, 0xed, 0x0b, 0xd6, 0xdd, 0xdb, 0x11, 0x34, 0x8f, 0x00, 0x02, 0xa5, 0xd5, 0xc5, 0x1b, /* descriptor */
+	   0xc1, 0x47, 0xa2, 0xf7, 0x7b, 0x1a, 0xe0, 0x11, 0x0d, 0xbb, 0x2a, 0x30, 0xdf, 0xd7, 0x20, 0x45,
+	   0x12, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x45, 0x71, 0x75, 0x61,
+	   0x6c, 0x69, 0x7a, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x6e, 0x74, 0x65,
+	   0x6c, 0x20, 0x43, 0x6f, 0x72, 0x70, 0x6f, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00,
+	   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+	  },
+	}
+};
+
+static struct sst_dev_effects_resource_map mrfld_effs_res_map[] = {
+	{
+	 {0xc1, 0x47, 0xa2, 0xf7, 0x7b, 0x1a, 0xe0, 0x11, 0x0d, 0xbb, 0x2a, 0x30, 0xdf, 0xd7, 0x20, 0x45}, /* uuid */
+	  0x50, /* Flags */
+	  0x00, /* Cpu load */
+	  0x01, /* Memory Usage */
+	 }
+};
+
+static void set_mrfld_platform_config(void)
+{
+	sst_platform_pdata.pdev_strm_map = mrfld_strm_map;
+	sst_platform_pdata.strm_map_size = ARRAY_SIZE(mrfld_strm_map);
+	sst_platform_pdata.pdev_effs.effs_map = mrfld_effs_map;
+	sst_platform_pdata.pdev_effs.effs_res_map = mrfld_effs_res_map;
+	sst_platform_pdata.pdev_effs.effs_num_map = ARRAY_SIZE(mrfld_effs_map);
+}
+
+static void  populate_platform_data(void)
+{
+	set_mrfld_platform_config();
+}
+
+int add_sst_platform_device(void)
+{
+	struct platform_device *pdev = NULL;
+	int ret;
+
+	populate_platform_data();
+
+	pdev = platform_device_alloc("sst-platform", -1);
+	if (!pdev) {
+		pr_err("failed to allocate audio platform device\n");
+		return -EINVAL;
+	}
+
+	ret = platform_device_add_data(pdev, &sst_platform_pdata,
+					sizeof(sst_platform_pdata));
+	if (ret) {
+		pr_err("failed to add sst platform data\n");
+		platform_device_put(pdev);
+		return  -EINVAL;
+	}
+	ret = platform_device_add(pdev);
+	if (ret) {
+		pr_err("failed to add audio platform device\n");
+		platform_device_put(pdev);
+		return  -EINVAL;
+	}
+	return ret;
+}
diff --git a/drivers/usb/dwc3/dwc3-host-intel.c b/drivers/usb/dwc3/dwc3-host-intel.c
index 05ef0aa..8f55a1c 100644
--- a/drivers/usb/dwc3/dwc3-host-intel.c
+++ b/drivers/usb/dwc3/dwc3-host-intel.c
@@ -583,7 +583,7 @@ static int dwc_hcd_suspend_common(struct device *dev)
 			data |= GCTL_GBL_HIBERNATION_EN;
 			writel(data, hcd->regs + GCTL);
 			dev_dbg(hcd->self.controller, "set xhci hibernation enable!\n");
-			retval = xhci_suspend(xhci, device_may_wakeup(dev));
+			retval = xhci_suspend(xhci, true);
 		}
 
 		/* Check again in case wakeup raced with pci_suspend */
diff --git a/include/linux/mfd/wm8994/pdata.h b/include/linux/mfd/wm8994/pdata.h
index 90c6052..79fed68 100644
--- a/include/linux/mfd/wm8994/pdata.h
+++ b/include/linux/mfd/wm8994/pdata.h
@@ -130,6 +130,12 @@ struct wm8958_micd_rate {
 	int rate;
 };
 
+struct wm8958_custom_config {
+	int format;
+	int rate;
+	int channels;
+};
+
 struct wm8994_pdata {
 	int gpio_base;
 
@@ -187,6 +193,11 @@ struct wm8994_pdata {
 	 */
 	int mic_id_delay;
 
+	/* Keep MICBIAS2 high for micb_en_delay, during jack insertion
+	 * removal
+	 */
+	int micb_en_delay;
+
 	/* IRQ for microphone detection if brought out directly as a
 	 * signal.
 	 */
@@ -229,6 +240,9 @@ struct wm8994_pdata {
 	 */
 	int max_channels_clocked[WM8994_NUM_AIF];
 
+	/* custom config for overriding the hw params */
+	struct wm8958_custom_config *custom_cfg;
+
 	/**
 	 * GPIO for the IRQ pin if host only supports edge triggering
 	 */
diff --git a/include/sound/compress_driver.h b/include/sound/compress_driver.h
index ae6c3b8..2a7f612 100644
--- a/include/sound/compress_driver.h
+++ b/include/sound/compress_driver.h
@@ -32,6 +32,7 @@
 #include <sound/pcm.h>
 
 struct snd_compr_ops;
+struct snd_pcm_substream;
 
 /**
  * struct snd_compr_runtime: runtime stream description
@@ -48,6 +49,8 @@ struct snd_compr_ops;
  *	the ring buffer
  * @total_bytes_transferred: cumulative bytes transferred by offload DSP
  * @sleep: poll sleep
+ * @wait: drain wait queue
+ * @drain_wake: condition for drain wake
  */
 struct snd_compr_runtime {
 	snd_pcm_state_t state;
@@ -59,6 +62,9 @@ struct snd_compr_runtime {
 	u64 total_bytes_available;
 	u64 total_bytes_transferred;
 	wait_queue_head_t sleep;
+	wait_queue_head_t wait;
+	unsigned int drain_wake;
+	struct snd_pcm_substream *fe_substream;
 	void *private_data;
 };
 
@@ -157,6 +163,7 @@ int snd_compress_register(struct snd_compr *device);
 int snd_compress_deregister(struct snd_compr *device);
 int snd_compress_new(struct snd_card *card, int device,
 			int type, struct snd_compr *compr);
+int snd_compr_stop(struct snd_compr_stream *stream);
 
 /* dsp driver callback apis
  * For playback: driver should call snd_compress_fragment_elapsed() to let the
diff --git a/include/sound/core.h b/include/sound/core.h
index d6bc961..a2d9ad9 100644
--- a/include/sound/core.h
+++ b/include/sound/core.h
@@ -149,6 +149,11 @@ struct snd_card {
 	struct snd_mixer_oss *mixer_oss;
 	int mixer_oss_change_count;
 #endif
+
+#if IS_ENABLED(CONFIG_SND_EFFECTS_OFFLOAD)
+	struct snd_effect_ops *effect_ops;
+	struct mutex effect_lock;	/* effect lock */
+#endif
 };
 
 #ifdef CONFIG_PM
diff --git a/include/sound/effect_driver.h b/include/sound/effect_driver.h
new file mode 100644
index 0000000..410e5f9
--- /dev/null
+++ b/include/sound/effect_driver.h
@@ -0,0 +1,63 @@
+/*
+ *  effect_driver.h - effect offload driver APIs
+ *
+ *  Copyright (C) 2013 Intel Corporation
+ *  Authors:	Vinod Koul <vinod.koul@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+#ifndef __EFFECT_DRIVER_H
+#define __EFFECT_DRIVER_H
+
+#include <sound/effect_offload.h>
+
+struct snd_effect_ops {
+	int (*create)(struct snd_card *card, struct snd_effect *effect);
+	int (*destroy)(struct snd_card *card, struct snd_effect *effect);
+	int (*set_params)(struct snd_card *card,
+				struct snd_effect_params *params);
+	int (*get_params)(struct snd_card *card,
+				struct snd_effect_params *params);
+	int (*query_num_effects)(struct snd_card *card);
+	int (*query_effect_caps)(struct snd_card *card,
+					struct snd_effect_caps *caps);
+};
+
+#if IS_ENABLED(CONFIG_SND_EFFECTS_OFFLOAD)
+int snd_effect_register(struct snd_card *card, struct snd_effect_ops *ops);
+int snd_effect_deregister(struct snd_card *card);
+#else
+static inline int snd_effect_register(struct snd_card *card,
+					struct snd_effect_ops *ops)
+{
+	return -ENODEV;
+}
+static inline int snd_effect_deregister(struct snd_card *card)
+{
+	return -ENODEV;
+}
+#endif
+
+/* IOCTL fns */
+int snd_ctl_effect_create(struct snd_card *card, void *arg);
+int snd_ctl_effect_destroy(struct snd_card *card, void *arg);
+int snd_ctl_effect_set_params(struct snd_card *card, void *arg);
+int snd_ctl_effect_get_params(struct snd_card *card, void *arg);
+int snd_ctl_effect_query_num_effects(struct snd_card *card, void *arg);
+int snd_ctl_effect_query_effect_caps(struct snd_card *card, void *arg);
+#endif
diff --git a/include/sound/intel_sst_ioctl.h b/include/sound/intel_sst_ioctl.h
new file mode 100644
index 0000000..6025ef9
--- /dev/null
+++ b/include/sound/intel_sst_ioctl.h
@@ -0,0 +1,63 @@
+#ifndef __INTEL_SST_IOCTL_H__
+#define __INTEL_SST_IOCTL_H__
+/*
+ *  intel_sst_ioctl.h - Intel SST Driver for audio engine
+ *
+ *  Copyright (C) 2008-10 Intel Corporation
+ *  Authors:	Vinod Koul <vinod.koul@intel.com>
+ *		Harsha Priya <priya.harsha@intel.com>
+ *		Dharageswari R <dharageswari.r@intel.com>
+ *		KP Jeeja <jeeja.kp@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This file defines all sst ioctls
+ */
+
+/* codec and post/pre processing related info */
+
+#include <linux/types.h>
+
+/* Pre and post processing params structure */
+struct snd_ppp_params {
+	__u8			algo_id;/* Post/Pre processing algorithm ID  */
+	__u8			str_id;	/*Only 5 bits used 0 - 31 are valid*/
+	__u8			enable;	/* 0= disable, 1= enable*/
+	__u8			operation; /* 0 = set_algo, 1 = get_algo */
+	__u32			size;	/*Size of parameters for all blocks*/
+	void			*params;
+} __packed;
+
+struct snd_sst_driver_info {
+	__u32 max_streams;
+};
+
+struct snd_sst_tuning_params {
+	__u8 type;
+	__u8 str_id;
+	__u8 size;
+	__u8 rsvd;
+	__u64 addr;
+} __packed;
+
+/*IOCTL defined here */
+/*SST common ioctls */
+#define SNDRV_SST_DRIVER_INFO	_IOR('L', 0x10, struct snd_sst_driver_info)
+#define SNDRV_SST_SET_ALGO	_IOW('L', 0x30,  struct snd_ppp_params)
+#define SNDRV_SST_GET_ALGO	_IOWR('L', 0x31,  struct snd_ppp_params)
+#define SNDRV_SST_TUNING_PARAMS	_IOW('L', 0x32,  struct snd_sst_tuning_params)
+#endif /* __INTEL_SST_IOCTL_H__ */
diff --git a/include/sound/pcm.h b/include/sound/pcm.h
index 4883499..b6468ba 100644
--- a/include/sound/pcm.h
+++ b/include/sound/pcm.h
@@ -285,6 +285,7 @@ struct snd_pcm_runtime {
 	unsigned long hw_ptr_jiffies;	/* Time when hw_ptr is updated */
 	unsigned long hw_ptr_buffer_jiffies; /* buffer time in jiffies */
 	snd_pcm_sframes_t delay;	/* extra delay; typically FIFO size */
+	snd_pcm_sframes_t soc_delay;    /* extra delay; typically delay incurred in soc */
 	u64 hw_ptr_wrap;                /* offset for hw_ptr due to boundary wrap-around */
 
 	/* -- HW params -- */
diff --git a/include/sound/soc-dai.h b/include/sound/soc-dai.h
index d86e0fc..22f5071 100644
--- a/include/sound/soc-dai.h
+++ b/include/sound/soc-dai.h
@@ -247,8 +247,8 @@ struct snd_soc_dai {
 	struct snd_soc_dai_driver *driver;
 
 	/* DAI runtime info */
-	unsigned int capture_active:1;		/* stream is in use */
-	unsigned int playback_active:1;		/* stream is in use */
+	unsigned int capture_active;		/* cap streams is in use */
+	unsigned int playback_active;		/* pb streams is in use */
 	unsigned int symmetric_rates:1;
 	unsigned int symmetric_channels:1;
 	unsigned int symmetric_samplebits:1;
diff --git a/include/sound/soc.h b/include/sound/soc.h
index 27bb5ab..4356ab2 100644
--- a/include/sound/soc.h
+++ b/include/sound/soc.h
@@ -27,6 +27,7 @@
 #include <sound/compress_driver.h>
 #include <sound/control.h>
 #include <sound/ac97_codec.h>
+#include <sound/effect_driver.h>
 
 /*
  * Convenience kcontrol builders
@@ -93,6 +94,12 @@
 		{.reg = xreg, .rreg = xreg, .shift = xshift, \
 		 .rshift = xshift, .min = xmin, .max = xmax, \
 		 .platform_max = xmax, .invert = xinvert} }
+#define SND_SOC_BYTES_EXT(xname, xcount, xhandler_get, xhandler_put) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_bytes_ext, \
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value = (unsigned long)&(struct soc_bytes_ext) \
+		{.max = xcount} }
 #define SOC_DOUBLE(xname, reg, shift_left, shift_right, max, invert) \
 {	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = (xname),\
 	.info = snd_soc_info_volsw, .get = snd_soc_get_volsw, \
@@ -412,6 +419,21 @@ struct snd_pcm_substream *snd_soc_get_dai_substream(struct snd_soc_card *card,
 		const char *dai_link, int stream);
 struct snd_soc_pcm_runtime *snd_soc_get_pcm_runtime(struct snd_soc_card *card,
 		const char *dai_link);
+#if IS_ENABLED(CONFIG_SND_EFFECTS_OFFLOAD)
+int snd_soc_register_effect(struct snd_soc_card *card,
+				struct snd_effect_ops *ops);
+int snd_soc_unregister_effect(struct snd_soc_card *card);
+#else
+static inline int snd_soc_register_effect(struct snd_soc_card *card,
+					struct snd_effect_ops *ops)
+{
+	return -ENODEV;
+}
+static inline int snd_soc_unregister_effect(struct snd_soc_card *card)
+{
+	return -ENODEV;
+}
+#endif
 
 /* Utility functions to get clock rates from various things */
 int snd_soc_calc_frame_size(int sample_size, int channels, int tdm_slots);
@@ -543,6 +565,8 @@ int snd_soc_get_strobe(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol);
 int snd_soc_put_strobe(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol);
+int snd_soc_info_bytes_ext(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *ucontrol);
 
 /**
  * struct snd_soc_jack_pin - Describes a pin to update based on jack detection
@@ -583,6 +607,7 @@ struct snd_soc_jack_zone {
  * @name:         gpio name
  * @report:       value to report when jack detected
  * @invert:       report presence in low state
+ * @irq_flag:	  Interrupt flags for GPIO-Irq line
  * @debouce_time: debouce time in ms
  * @wake:	  enable as wake source
  * @jack_status_check: callback function which overrides the detection
@@ -596,6 +621,7 @@ struct snd_soc_jack_gpio {
 	int invert;
 	int debounce_time;
 	bool wake;
+	unsigned long irq_flags;
 
 	struct snd_soc_jack *jack;
 	struct delayed_work work;
@@ -913,6 +939,10 @@ struct snd_soc_dai_link {
 	const struct snd_soc_ops *ops;
 	const struct snd_soc_compr_ops *compr_ops;
 
+	/*no of substreams */
+	unsigned int playback_count;
+	unsigned int capture_count;
+
 	/* For unidirectional dai links */
 	bool playback_only;
 	bool capture_only;
@@ -1083,6 +1113,10 @@ struct soc_mreg_control {
 	unsigned int regbase, regcount, nbits, invert;
 };
 
+struct soc_bytes_ext {
+	int max;
+};
+
 /* enumerated kcontrol */
 struct soc_enum {
 	unsigned short reg;
diff --git a/include/uapi/sound/effect_offload.h b/include/uapi/sound/effect_offload.h
new file mode 100644
index 0000000..9c30031
--- /dev/null
+++ b/include/uapi/sound/effect_offload.h
@@ -0,0 +1,62 @@
+/*
+ *  effect_offload.h - effect offload header definations
+ *
+ *  Copyright (C) 2013 Intel Corporation
+ *  Authors:	Vinod Koul <vinod.koul@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+#ifndef __EFFECT_OFFLOAD_H
+#define __EFFECT_OFFLOAD_H
+
+#include <linux/types.h>
+
+#define SNDRV_EFFECT_VERSION SNDRV_PROTOCOL_VERSION(0, 1, 0)
+
+struct snd_effect {
+	char uuid[16];  /* effect UUID */
+	int device;	/* streaming interface for effect insertion */
+	int pos;	/* position of effect to be placed in effect chain */
+	int mode;	/* Backend for Global device (Headset/Speaker) */
+};
+
+struct snd_effect_params {
+	char uuid[16];
+	int device;
+	u32 size;	/* size of parameter blob */
+	char *buffer;
+};
+
+struct snd_effect_caps {
+	u32 size;	/* size of buffer to read effect descriptors */
+	char *buffer;
+};
+
+#define SNDRV_CTL_IOCTL_EFFECT_VERSION		_IOR('E', 0x00, int)
+#define SNDRV_CTL_IOCTL_EFFECT_CREATE		_IOW('E', 0x01,\
+						struct snd_effect *)
+#define SNDRV_CTL_IOCTL_EFFECT_DESTROY		_IOW('E', 0x02,\
+						struct snd_effect *)
+#define SNDRV_CTL_IOCTL_EFFECT_SET_PARAMS	_IOW('E', 0x03,\
+						struct snd_effect_params *)
+#define SNDRV_CTL_IOCTL_EFFECT_GET_PARAMS	_IOWR('E', 0x04,\
+						struct snd_effect_params *)
+#define SNDRV_CTL_IOCTL_EFFECT_QUERY_NUM	_IOR('E', 0x05, int)
+#define SNDRV_CTL_IOCTL_EFFECT_QUERY_CAPS	_IOWR('E', 0x06,\
+						struct snd_effect_caps *)
+#endif
diff --git a/sound/core/Kconfig b/sound/core/Kconfig
index 313f22e..8a290f8 100644
--- a/sound/core/Kconfig
+++ b/sound/core/Kconfig
@@ -18,6 +18,9 @@ config SND_RAWMIDI
 config SND_COMPRESS_OFFLOAD
 	tristate
 
+config SND_EFFECTS_OFFLOAD
+	tristate
+
 # To be effective this also requires INPUT - users should say:
 #    select SND_JACK if INPUT=y || INPUT=SND
 # to avoid having to force INPUT on.
diff --git a/sound/core/Makefile b/sound/core/Makefile
index 394a389..1a85590 100644
--- a/sound/core/Makefile
+++ b/sound/core/Makefile
@@ -23,6 +23,7 @@ snd-rtctimer-objs := rtctimer.o
 snd-hwdep-objs    := hwdep.o
 
 snd-compress-objs := compress_offload.o
+snd-effects-objs := effects_offload.o
 
 obj-$(CONFIG_SND) 		+= snd.o
 obj-$(CONFIG_SND_HWDEP)		+= snd-hwdep.o
@@ -37,3 +38,4 @@ obj-$(CONFIG_SND_OSSEMUL)	+= oss/
 obj-$(CONFIG_SND_SEQUENCER)	+= seq/
 
 obj-$(CONFIG_SND_COMPRESS_OFFLOAD)	+= snd-compress.o
+obj-$(CONFIG_SND_EFFECTS_OFFLOAD)	+= snd-effects.o
diff --git a/sound/core/compress_offload.c b/sound/core/compress_offload.c
index 7403f34..06ee2e5 100644
--- a/sound/core/compress_offload.c
+++ b/sound/core/compress_offload.c
@@ -268,16 +268,25 @@ static ssize_t snd_compr_write(struct file *f, const char __user *buf,
 	struct snd_compr_file *data = f->private_data;
 	struct snd_compr_stream *stream;
 	size_t avail;
-	int retval;
+	int retval = 0;
 
 	if (snd_BUG_ON(!data))
 		return -EFAULT;
 
 	stream = &data->stream;
 	mutex_lock(&stream->device->lock);
-	/* write is allowed when stream is running or has been steup */
+	 /*
+	 * if the stream is in paused state, return the
+	 * number of bytes consumed as 0
+	 */
+	if (stream->runtime->state == SNDRV_PCM_STATE_PAUSED) {
+		mutex_unlock(&stream->device->lock);
+		return retval;
+	}
+	/* write is allowed when stream is running or prepared or in setup */
 	if (stream->runtime->state != SNDRV_PCM_STATE_SETUP &&
-			stream->runtime->state != SNDRV_PCM_STATE_RUNNING) {
+			stream->runtime->state != SNDRV_PCM_STATE_RUNNING &&
+			stream->runtime->state != SNDRV_PCM_STATE_PREPARED) {
 		mutex_unlock(&stream->device->lock);
 		return -EBADFD;
 	}
@@ -408,6 +417,7 @@ static unsigned int snd_compr_poll(struct file *f, poll_table *wait)
 			retval = snd_compr_get_poll(stream);
 		break;
 	default:
+		pr_err("poll returns err!...\n");
 		if (stream->direction == SND_COMPRESS_PLAYBACK)
 			retval = POLLOUT | POLLWRNORM | POLLERR;
 		else
@@ -635,7 +645,8 @@ static int snd_compr_pause(struct snd_compr_stream *stream)
 {
 	int retval;
 
-	if (stream->runtime->state != SNDRV_PCM_STATE_RUNNING)
+	if ((stream->runtime->state != SNDRV_PCM_STATE_RUNNING) &&
+		(stream->runtime->state != SNDRV_PCM_STATE_DRAINING))
 		return -EPERM;
 	retval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_PAUSE_PUSH);
 	if (!retval)
@@ -650,8 +661,10 @@ static int snd_compr_resume(struct snd_compr_stream *stream)
 	if (stream->runtime->state != SNDRV_PCM_STATE_PAUSED)
 		return -EPERM;
 	retval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_PAUSE_RELEASE);
-	if (!retval)
+	if (!retval) {
 		stream->runtime->state = SNDRV_PCM_STATE_RUNNING;
+		wake_up(&stream->runtime->sleep);
+	}
 	return retval;
 }
 
@@ -667,21 +680,23 @@ static int snd_compr_start(struct snd_compr_stream *stream)
 	return retval;
 }
 
-static int snd_compr_stop(struct snd_compr_stream *stream)
+int snd_compr_stop(struct snd_compr_stream *stream)
 {
-	int retval;
+	int retval = 0;
 
-	if (stream->runtime->state == SNDRV_PCM_STATE_PREPARED ||
-			stream->runtime->state == SNDRV_PCM_STATE_SETUP)
+	if (stream->runtime->state == SNDRV_PCM_STATE_SETUP)
 		return -EPERM;
-	retval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_STOP);
+	if (stream->runtime->state != SNDRV_PCM_STATE_PREPARED)
+		retval = stream->ops->trigger(stream, SNDRV_PCM_TRIGGER_STOP);
 	if (!retval) {
 		snd_compr_drain_notify(stream);
+		snd_compr_drain_notify(stream);
 		stream->runtime->total_bytes_available = 0;
 		stream->runtime->total_bytes_transferred = 0;
 	}
 	return retval;
 }
+EXPORT_SYMBOL(snd_compr_stop);
 
 static int snd_compress_wait_for_drain(struct snd_compr_stream *stream)
 {
@@ -722,17 +737,25 @@ static int snd_compr_drain(struct snd_compr_stream *stream)
 {
 	int retval;
 
-	if (stream->runtime->state == SNDRV_PCM_STATE_PREPARED ||
-			stream->runtime->state == SNDRV_PCM_STATE_SETUP)
+	if (stream->runtime->state == SNDRV_PCM_STATE_SETUP)
 		return -EPERM;
 
-	retval = stream->ops->trigger(stream, SND_COMPR_TRIGGER_DRAIN);
+	/* this is hackish for our tree but for now lets carry it while we fix
+	 * usermode behaviour
+	 */
+	if (stream->runtime->state != SNDRV_PCM_STATE_PREPARED)
+		retval = stream->ops->trigger(stream, SND_COMPR_TRIGGER_DRAIN);
+	else
+		return 0;
+
 	if (retval) {
+		pr_err("SND_COMPR_TRIGGER_DRAIN failed %d\n", retval);
 		pr_debug("SND_COMPR_TRIGGER_DRAIN failed %d\n", retval);
 		wake_up(&stream->runtime->sleep);
 		return retval;
 	}
 
+	stream->runtime->state = SNDRV_PCM_STATE_SETUP;
 	return snd_compress_wait_for_drain(stream);
 }
 
@@ -760,22 +783,29 @@ static int snd_compr_next_track(struct snd_compr_stream *stream)
 
 static int snd_compr_partial_drain(struct snd_compr_stream *stream)
 {
-	int retval;
-	if (stream->runtime->state == SNDRV_PCM_STATE_PREPARED ||
-			stream->runtime->state == SNDRV_PCM_STATE_SETUP)
+	int retval = 0;
+
+	/* agaain hackish  changes */
+	if (stream->runtime->state == SNDRV_PCM_STATE_SETUP)
 		return -EPERM;
 	/* stream can be drained only when next track has been signalled */
 	if (stream->next_track == false)
 		return -EPERM;
 
-	retval = stream->ops->trigger(stream, SND_COMPR_TRIGGER_PARTIAL_DRAIN);
+	if (stream->runtime->state != SNDRV_PCM_STATE_PREPARED)
+		retval = stream->ops->trigger(stream, SND_COMPR_TRIGGER_PARTIAL_DRAIN);
+	else
+		return 0;
+
 	if (retval) {
-		pr_debug("Partial drain returned failure\n");
+		pr_err("Partial drain returned failure\n");
 		wake_up(&stream->runtime->sleep);
 		return retval;
 	}
 
 	stream->next_track = false;
+	retval = snd_compress_wait_for_drain(stream);
+	stream->runtime->state = SNDRV_PCM_STATE_SETUP;
 	return snd_compress_wait_for_drain(stream);
 }
 
@@ -854,6 +884,9 @@ static const struct file_operations snd_compr_file_ops = {
 		.write =	snd_compr_write,
 		.read =		snd_compr_read,
 		.unlocked_ioctl = snd_compr_ioctl,
+#ifdef CONFIG_COMPAT
+		.compat_ioctl =	snd_compr_ioctl,
+#endif
 		.mmap =		snd_compr_mmap,
 		.poll =		snd_compr_poll,
 };
@@ -868,7 +901,7 @@ static int snd_compress_dev_register(struct snd_device *device)
 		return -EBADFD;
 	compr = device->device_data;
 
-	sprintf(str, "comprC%iD%i", compr->card->number, compr->device);
+	snprintf(str, sizeof(str), "comprC%iD%i", compr->card->number, compr->device);
 	pr_debug("reg %s for device %s, direction %d\n", str, compr->name,
 			compr->direction);
 	/* register compressed device */
diff --git a/sound/core/effects_offload.c b/sound/core/effects_offload.c
new file mode 100644
index 0000000..def0a89
--- /dev/null
+++ b/sound/core/effects_offload.c
@@ -0,0 +1,307 @@
+/*
+ *  effect_offload.c - effects offload core
+ *
+ *  Copyright (C) 2013 Intel Corporation
+ *  Authors:	Lakshmi N Vinnakota <lakshmi.n.vinnakota@intel.com>
+ *		Vinod Koul <vinod.koul@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+#define FORMAT(fmt) "%s: %d: " fmt, __func__, __LINE__
+#define pr_fmt(fmt) KBUILD_MODNAME ": " FORMAT(fmt)
+
+#include <linux/module.h>
+#include <linux/uio.h>
+#include <linux/uaccess.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/effect_offload.h>
+#include <sound/effect_driver.h>
+
+static DEFINE_MUTEX(effect_mutex);
+
+int snd_ctl_effect_create(struct snd_card *card, void *arg)
+{
+	int retval = 0;
+	struct snd_effect *effect;
+
+	effect = kmalloc(sizeof(*effect), GFP_KERNEL);
+	if (!effect)
+		return -ENOMEM;
+	if (copy_from_user(effect, (void __user *)arg, sizeof(*effect))) {
+		retval = -EFAULT;
+		goto out;
+	}
+	pr_debug("effect_offload: device %d, pos %d, mode%d\n",
+			effect->device, effect->pos, effect->mode);
+
+	mutex_lock(&card->effect_lock);
+	retval = card->effect_ops->create(card, effect);
+	mutex_unlock(&card->effect_lock);
+out:
+	kfree(effect);
+	return retval;
+}
+EXPORT_SYMBOL_GPL(snd_ctl_effect_create);
+
+int snd_ctl_effect_destroy(struct snd_card *card, void *arg)
+{
+	int retval = 0;
+	struct snd_effect *effect;
+
+	effect = kmalloc(sizeof(*effect), GFP_KERNEL);
+	if (!effect)
+		return -ENOMEM;
+	if (copy_from_user(effect, (void __user *)arg, sizeof(*effect))) {
+		retval = -EFAULT;
+		goto out;
+	}
+	mutex_lock(&card->effect_lock);
+	retval = card->effect_ops->destroy(card, effect);
+	mutex_unlock(&card->effect_lock);
+out:
+	kfree(effect);
+	return retval;
+}
+EXPORT_SYMBOL_GPL(snd_ctl_effect_destroy);
+
+int snd_ctl_effect_set_params(struct snd_card *card, void *arg)
+{
+	int retval = 0;
+	struct snd_effect_params *params;
+	char __user *argp = (char __user *)arg;
+	char __user *bufp;
+
+	params = kmalloc(sizeof(*params), GFP_KERNEL);
+	if (!params)
+		return -ENOMEM;
+
+	if (copy_from_user(params, argp, sizeof(*params))) {
+		retval = -EFAULT;
+		goto out;
+	}
+	bufp = params->buffer;
+	params->buffer = kmalloc(params->size, GFP_KERNEL);
+	if (!params->buffer) {
+		retval = -ENOMEM;
+		goto out;
+	}
+
+	if (copy_from_user((void *)params->buffer, bufp, params->size)) {
+		retval = -EFAULT;
+		goto free_buf;
+	}
+
+	mutex_lock(&card->effect_lock);
+	retval = card->effect_ops->set_params(card, params);
+	mutex_unlock(&card->effect_lock);
+free_buf:
+	kfree(params->buffer);
+out:
+	kfree(params);
+	return retval;
+}
+EXPORT_SYMBOL_GPL(snd_ctl_effect_set_params);
+
+int snd_ctl_effect_get_params(struct snd_card *card, void *arg)
+{
+	int retval = 0;
+	struct snd_effect_params inparams;
+	struct snd_effect_params *outparams;
+	unsigned int offset;
+	char __user *argp = (char __user *)arg;
+
+	if (copy_from_user((void *)&inparams, argp, sizeof(inparams)))
+		retval = -EFAULT;
+
+	outparams = kmalloc(sizeof(*outparams), GFP_KERNEL);
+	if (!outparams)
+		return -ENOMEM;
+
+	memcpy(outparams, &inparams, sizeof(inparams));
+	outparams->buffer = kmalloc(inparams.size, GFP_KERNEL);
+	if (!outparams->buffer) {
+		retval = -ENOMEM;
+		goto free_out;
+	}
+
+	if (copy_from_user((void *)outparams->buffer, inparams.buffer,
+							inparams.size)) {
+		retval = -EFAULT;
+		goto free_buf;
+	}
+
+	mutex_lock(&card->effect_lock);
+	retval = card->effect_ops->get_params(card, outparams);
+	mutex_unlock(&card->effect_lock);
+
+	if (retval)
+		goto free_buf;
+
+	if (!outparams->size)
+		goto free_buf;
+
+	if (outparams->size > inparams.size) {
+		pr_err("mem insufficient to copy\n");
+		retval = -EMSGSIZE;
+		goto free_buf;
+	} else {
+		offset = offsetof(struct snd_effect_params, size);
+		if (copy_to_user((argp + offset), (void *)&outparams->size,
+								sizeof(u32)))
+			retval = -EFAULT;
+
+		if (copy_to_user(inparams.buffer, outparams->buffer,
+							outparams->size))
+			retval = -EFAULT;
+	}
+free_buf:
+	kfree(outparams->buffer);
+free_out:
+	kfree(outparams);
+	return retval;
+}
+EXPORT_SYMBOL_GPL(snd_ctl_effect_get_params);
+
+int snd_ctl_effect_query_num_effects(struct snd_card *card, void *arg)
+{
+	int retval = 0;
+	int __user *ip = arg;
+
+	mutex_lock(&card->effect_lock);
+	retval = card->effect_ops->query_num_effects(card);
+	mutex_unlock(&card->effect_lock);
+
+	if (retval < 0)
+		goto out;
+	retval = put_user(retval, ip) ? -EFAULT : 0;
+out:
+	return retval;
+}
+EXPORT_SYMBOL_GPL(snd_ctl_effect_query_num_effects);
+
+int snd_ctl_effect_query_effect_caps(struct snd_card *card, void *arg)
+{
+	int retval = 0;
+	struct snd_effect_caps *caps;
+	unsigned int offset, insize;
+	char __user *argp = (char __user *)arg;
+	char __user *bufp;
+
+	caps = kmalloc(sizeof(*caps), GFP_KERNEL);
+	if (!caps)
+		return -ENOMEM;
+
+	if (copy_from_user(caps, argp, sizeof(*caps))) {
+		retval = -EFAULT;
+		goto out;
+	}
+	bufp = caps->buffer;
+	insize = caps->size;
+	caps->buffer = kmalloc(caps->size, GFP_KERNEL);
+	if (!caps->buffer) {
+		retval = -ENOMEM;
+		goto out;
+	}
+
+	mutex_lock(&card->effect_lock);
+	retval = card->effect_ops->query_effect_caps(card, caps);
+	mutex_unlock(&card->effect_lock);
+
+	if (retval)
+		goto free_buf;
+
+	if (insize < caps->size) {
+		pr_err("mem insufficient to copy\n");
+		retval = -EMSGSIZE;
+		goto free_buf;
+	}
+
+	offset = offsetof(struct snd_effect_caps, size);
+	if (copy_to_user((argp + offset), (void *)&caps->size, sizeof(u32))) {
+		retval = -EFAULT;
+		goto free_buf;
+	}
+
+	if (copy_to_user(bufp, caps->buffer, caps->size))
+		retval = -EFAULT;
+
+free_buf:
+	kfree(caps->buffer);
+out:
+	kfree(caps);
+	return retval;
+}
+EXPORT_SYMBOL_GPL(snd_ctl_effect_query_effect_caps);
+
+/**
+ * snd_effect_register - register compressed device
+ *
+ * @card : snd card to which the effect is registered
+ * @ops : effect_ops to register
+ */
+int snd_effect_register(struct snd_card *card, struct snd_effect_ops *ops)
+{
+
+	if (card == NULL || ops == NULL)
+		return -EINVAL;
+
+	if (snd_BUG_ON(!ops->create))
+		return -EINVAL;
+	if (snd_BUG_ON(!ops->destroy))
+		return -EINVAL;
+	if (snd_BUG_ON(!ops->set_params))
+		return -EINVAL;
+
+	mutex_init(&card->effect_lock);
+
+	pr_debug("Registering Effects to card %s\n", card->shortname);
+	/* register the effect ops with the card */
+	mutex_lock(&effect_mutex);
+	card->effect_ops = ops;
+	mutex_unlock(&effect_mutex);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_effect_register);
+
+int snd_effect_deregister(struct snd_card *card)
+{
+	pr_debug("Removing effects for card %s\n", card->shortname);
+	mutex_lock(&effect_mutex);
+	card->effect_ops = NULL;
+	mutex_unlock(&effect_mutex);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_effect_deregister);
+
+static int __init snd_effect_init(void)
+{
+	return 0;
+}
+
+static void __exit snd_effect_exit(void)
+{
+}
+
+module_init(snd_effect_init);
+module_exit(snd_effect_exit);
+
+MODULE_DESCRIPTION("ALSA Effect offload framework");
+MODULE_AUTHOR("Lakshmi N Vinnakota <lakshmi.n.vinnakota@intel.com>");
+MODULE_AUTHOR("Vinod Koul <vinod.koul@intel.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/codecs/sn95031.c b/sound/soc/codecs/sn95031.c
index 13045f2..d58f1e0a 100644
--- a/sound/soc/codecs/sn95031.c
+++ b/sound/soc/codecs/sn95031.c
@@ -30,7 +30,7 @@
 #include <linux/slab.h>
 #include <linux/module.h>
 
-#include <asm/intel_scu_ipc.h>
+#include <asm/intel_scu_pmic.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
diff --git a/sound/soc/codecs/wm8994.c b/sound/soc/codecs/wm8994.c
index d98e52f..172f880 100644
--- a/sound/soc/codecs/wm8994.c
+++ b/sound/soc/codecs/wm8994.c
@@ -94,9 +94,9 @@ static int wm8994_retune_mobile_base[] = {
 
 static const struct wm8958_micd_rate micdet_rates[] = {
 	{ 32768,       true,  1, 4 },
-	{ 32768,       false, 1, 1 },
+	{ 32768,       false, 1, 0 },
 	{ 44100 * 256, true,  7, 10 },
-	{ 44100 * 256, false, 7, 10 },
+	{ 44100 * 256, false, 7, 9 },
 };
 
 static const struct wm8958_micd_rate jackdet_rates[] = {
@@ -538,13 +538,13 @@ static SOC_ENUM_SINGLE_DECL(adc_osr,
 static const struct snd_kcontrol_new wm8994_snd_controls[] = {
 SOC_DOUBLE_R_TLV("AIF1ADC1 Volume", WM8994_AIF1_ADC1_LEFT_VOLUME,
 		 WM8994_AIF1_ADC1_RIGHT_VOLUME,
-		 1, 119, 0, digital_tlv),
+		 1, 120, 0, digital_tlv),
 SOC_DOUBLE_R_TLV("AIF1ADC2 Volume", WM8994_AIF1_ADC2_LEFT_VOLUME,
 		 WM8994_AIF1_ADC2_RIGHT_VOLUME,
-		 1, 119, 0, digital_tlv),
+		 1, 120, 0, digital_tlv),
 SOC_DOUBLE_R_TLV("AIF2ADC Volume", WM8994_AIF2_ADC_LEFT_VOLUME,
 		 WM8994_AIF2_ADC_RIGHT_VOLUME,
-		 1, 119, 0, digital_tlv),
+		 1, 120, 0, digital_tlv),
 
 SOC_ENUM("AIF1ADCL Source", aif1adcl_src),
 SOC_ENUM("AIF1ADCR Source", aif1adcr_src),
@@ -606,12 +606,12 @@ SOC_ENUM("ADC OSR", adc_osr),
 SOC_ENUM("DAC OSR", dac_osr),
 
 SOC_DOUBLE_R_TLV("DAC1 Volume", WM8994_DAC1_LEFT_VOLUME,
-		 WM8994_DAC1_RIGHT_VOLUME, 1, 96, 0, digital_tlv),
+		 WM8994_DAC1_RIGHT_VOLUME, 1, 112, 0, digital_tlv),
 SOC_DOUBLE_R("DAC1 Switch", WM8994_DAC1_LEFT_VOLUME,
 	     WM8994_DAC1_RIGHT_VOLUME, 9, 1, 1),
 
 SOC_DOUBLE_R_TLV("DAC2 Volume", WM8994_DAC2_LEFT_VOLUME,
-		 WM8994_DAC2_RIGHT_VOLUME, 1, 96, 0, digital_tlv),
+		 WM8994_DAC2_RIGHT_VOLUME, 1, 112, 0, digital_tlv),
 SOC_DOUBLE_R("DAC2 Switch", WM8994_DAC2_LEFT_VOLUME,
 	     WM8994_DAC2_RIGHT_VOLUME, 9, 1, 1),
 
@@ -637,6 +637,11 @@ SOC_SINGLE_TLV("AIF2DAC 3D Stereo Volume", WM8994_AIF2_DAC_FILTERS_2,
 	       10, 15, 0, wm8994_3d_tlv),
 SOC_SINGLE("AIF2DAC 3D Stereo Switch", WM8994_AIF2_DAC_FILTERS_2,
 	   8, 1, 0),
+
+SOC_SINGLE_TLV("MIXINL MIXOUTL Volume", WM8994_INPUT_MIXER_3, 0, 7, 0,
+	       mixin_boost_tlv),
+SOC_SINGLE_TLV("MIXINR MIXOUTR Volume", WM8994_INPUT_MIXER_4, 0, 7, 0,
+	       mixin_boost_tlv),
 };
 
 static const struct snd_kcontrol_new wm8994_eq_controls[] = {
@@ -869,7 +874,7 @@ static void vmid_reference(struct snd_soc_codec *codec)
 					    WM8994_BIAS_SRC |
 					    WM8994_STARTUP_BIAS_ENA |
 					    WM8994_VMID_BUF_ENA |
-					    (0x2 << WM8994_VMID_RAMP_SHIFT));
+					    (0x3 << WM8994_VMID_RAMP_SHIFT));
 
 			/* Main bias enable, VMID=2x40k */
 			snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_1,
@@ -877,7 +882,14 @@ static void vmid_reference(struct snd_soc_codec *codec)
 					    WM8994_VMID_SEL_MASK,
 					    WM8994_BIAS_ENA | 0x2);
 
-			msleep(300);
+			/* The delay of 300ms was recommended to support pop
+			 * free startup of the line output driver, as we don't use
+			 * that feature reducing the delay to 50ms as recommended in
+			 * the spec, Also changing VMID_RAMP to soft fast start
+			 * accordingly Also applies for VMID_FORCE and
+			 * vmid_dereference.
+			 */
+			msleep(50);
 
 			snd_soc_update_bits(codec, WM8994_ANTIPOP_2,
 					    WM8994_VMID_RAMP_MASK |
@@ -896,15 +908,14 @@ static void vmid_reference(struct snd_soc_codec *codec)
 					    WM8994_BIAS_SRC |
 					    WM8994_STARTUP_BIAS_ENA |
 					    WM8994_VMID_BUF_ENA |
-					    (0x2 << WM8994_VMID_RAMP_SHIFT));
+					    (0x3 << WM8994_VMID_RAMP_SHIFT));
 
 			/* Main bias enable, VMID=2x40k */
 			snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_1,
 					    WM8994_BIAS_ENA |
 					    WM8994_VMID_SEL_MASK,
 					    WM8994_BIAS_ENA | 0x2);
-
-			msleep(400);
+			msleep(50);
 
 			snd_soc_update_bits(codec, WM8994_ANTIPOP_2,
 					    WM8994_VMID_RAMP_MASK |
@@ -949,7 +960,7 @@ static void vmid_dereference(struct snd_soc_codec *codec)
 		snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_1,
 				    WM8994_VMID_SEL_MASK, 0);
 
-		msleep(400);
+		msleep(50);
 
 		/* Active discharge */
 		snd_soc_update_bits(codec, WM8994_ANTIPOP_1,
@@ -972,7 +983,7 @@ static void vmid_dereference(struct snd_soc_codec *codec)
 				    WM8994_VMID_RAMP_MASK, 0);
 
 		snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_1,
-				    WM8994_VMID_SEL_MASK, 0);
+				    WM8994_BIAS_ENA | WM8994_VMID_SEL_MASK, 0);
 	}
 
 	pm_runtime_put(codec->dev);
@@ -1058,7 +1069,7 @@ static int aif1clk_ev(struct snd_soc_dapm_widget *w,
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:
 		/* Don't enable timeslot 2 if not in use */
-		if (wm8994->channels[0] <= 2)
+		if ((wm8994->channels[0] <= 2) && (wm8994->slots <= 2))
 			mask &= ~(WM8994_AIF1DAC2L_ENA | WM8994_AIF1DAC2R_ENA);
 
 		val = snd_soc_read(codec, WM8994_AIF1_CONTROL_1);
@@ -1334,6 +1345,26 @@ static int dac_ev(struct snd_soc_dapm_widget *w,
 	struct snd_soc_codec *codec = w->codec;
 	unsigned int mask = 1 << w->shift;
 
+	/* Don't propagate FIFO errors unless the DAC is running */
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		/* Clear FIFO error status */
+		snd_soc_update_bits(codec, WM8994_INTERRUPT_STATUS_2,
+				    WM8994_FIFOS_ERR_EINT_MASK,
+				    1 << WM8994_FIFOS_ERR_EINT_SHIFT);
+		/* Unmask FIFO error interrupts */
+		snd_soc_update_bits(codec, WM8994_INTERRUPT_STATUS_2_MASK,
+				    WM8994_IM_FIFOS_ERR_EINT_MASK,
+				    0 << WM8994_IM_FIFOS_ERR_EINT_SHIFT);
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		/* Mask FIFO error interrupts */
+		snd_soc_update_bits(codec, WM8994_INTERRUPT_STATUS_2_MASK,
+				    WM8994_IM_FIFOS_ERR_EINT_MASK,
+				    1 << WM8994_IM_FIFOS_ERR_EINT_SHIFT);
+		break;
+	}
+
 	snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_5,
 			    mask, mask);
 	return 0;
@@ -1635,13 +1666,17 @@ SND_SOC_DAPM_MUX("Right Headphone Mux", SND_SOC_NOPM, 0, 0, &wm_hubs_hpr_mux),
 
 static const struct snd_soc_dapm_widget wm8994_dac_revd_widgets[] = {
 SND_SOC_DAPM_DAC_E("DAC2L", NULL, SND_SOC_NOPM, 3, 0,
-	dac_ev, SND_SOC_DAPM_PRE_PMU),
+	dac_ev, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
+	SND_SOC_DAPM_PRE_PMD),
 SND_SOC_DAPM_DAC_E("DAC2R", NULL, SND_SOC_NOPM, 2, 0,
-	dac_ev, SND_SOC_DAPM_PRE_PMU),
+	dac_ev, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
+	SND_SOC_DAPM_PRE_PMD),
 SND_SOC_DAPM_DAC_E("DAC1L", NULL, SND_SOC_NOPM, 1, 0,
-	dac_ev, SND_SOC_DAPM_PRE_PMU),
+	dac_ev, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
+	SND_SOC_DAPM_PRE_PMD),
 SND_SOC_DAPM_DAC_E("DAC1R", NULL, SND_SOC_NOPM, 0, 0,
-	dac_ev, SND_SOC_DAPM_PRE_PMU),
+	dac_ev, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
+	SND_SOC_DAPM_PRE_PMD),
 };
 
 static const struct snd_soc_dapm_widget wm8994_dac_widgets[] = {
@@ -1652,15 +1687,15 @@ SND_SOC_DAPM_DAC("DAC1R", NULL, WM8994_POWER_MANAGEMENT_5, 0, 0),
 };
 
 static const struct snd_soc_dapm_widget wm8994_adc_revd_widgets[] = {
-SND_SOC_DAPM_VIRT_MUX_E("ADCL Mux", WM8994_POWER_MANAGEMENT_4, 1, 0, &adcl_mux,
+SND_SOC_DAPM_VIRT_MUX_E("ADCL Mux", SND_SOC_NOPM, 1, 0, &adcl_mux,
 			adc_mux_ev, SND_SOC_DAPM_PRE_PMU),
-SND_SOC_DAPM_VIRT_MUX_E("ADCR Mux", WM8994_POWER_MANAGEMENT_4, 0, 0, &adcr_mux,
+SND_SOC_DAPM_VIRT_MUX_E("ADCR Mux", SND_SOC_NOPM, 0, 0, &adcr_mux,
 			adc_mux_ev, SND_SOC_DAPM_PRE_PMU),
 };
 
 static const struct snd_soc_dapm_widget wm8994_adc_widgets[] = {
-SND_SOC_DAPM_VIRT_MUX("ADCL Mux", WM8994_POWER_MANAGEMENT_4, 1, 0, &adcl_mux),
-SND_SOC_DAPM_VIRT_MUX("ADCR Mux", WM8994_POWER_MANAGEMENT_4, 0, 0, &adcr_mux),
+SND_SOC_DAPM_VIRT_MUX("ADCL Mux", SND_SOC_NOPM, 1, 0, &adcl_mux),
+SND_SOC_DAPM_VIRT_MUX("ADCR Mux", SND_SOC_NOPM, 0, 0, &adcr_mux),
 };
 
 static const struct snd_soc_dapm_widget wm8994_dapm_widgets[] = {
@@ -1756,12 +1791,8 @@ SND_SOC_DAPM_ADC("DMIC2R", NULL, WM8994_POWER_MANAGEMENT_4, 4, 0),
 SND_SOC_DAPM_ADC("DMIC1L", NULL, WM8994_POWER_MANAGEMENT_4, 3, 0),
 SND_SOC_DAPM_ADC("DMIC1R", NULL, WM8994_POWER_MANAGEMENT_4, 2, 0),
 
-/* Power is done with the muxes since the ADC power also controls the
- * downsampling chain, the chip will automatically manage the analogue
- * specific portions.
- */
-SND_SOC_DAPM_ADC("ADCL", NULL, SND_SOC_NOPM, 1, 0),
-SND_SOC_DAPM_ADC("ADCR", NULL, SND_SOC_NOPM, 0, 0),
+SND_SOC_DAPM_ADC("ADCL", NULL, WM8994_POWER_MANAGEMENT_4, 1, 0),
+SND_SOC_DAPM_ADC("ADCR", NULL, WM8994_POWER_MANAGEMENT_4, 0, 0),
 
 SND_SOC_DAPM_MUX("AIF1 Loopback", SND_SOC_NOPM, 0, 0, &aif1_loopback),
 SND_SOC_DAPM_MUX("AIF2 Loopback", SND_SOC_NOPM, 0, 0, &aif2_loopback),
@@ -2323,7 +2354,8 @@ out:
 	 * If SYSCLK will be less than 50kHz adjust AIFnCLK dividers
 	 * for detection.
 	 */
-	if (max(wm8994->aifclk[0], wm8994->aifclk[1]) < 50000) {
+	if (max(wm8994->aifclk[0], wm8994->aifclk[1]) < 50000 &&
+		!wm8994->aifdiv[0]) {
 		dev_dbg(codec->dev, "Configuring AIFs for 128fs\n");
 
 		wm8994->aifdiv[0] = snd_soc_read(codec, WM8994_AIF1_RATE)
@@ -2772,9 +2804,40 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 	int lrclk = 0;
 	int rate_val = 0;
 	int id = dai->id - 1;
+	struct snd_pcm_hw_params hw_params;
 
 	int i, cur_val, best_val, bclk_rate, best;
 
+	if (params)
+		memcpy(&hw_params, params, sizeof(*params));
+	else
+		return -EINVAL;
+
+	/* If custom params are there, override to custom params */
+	if (pdata->custom_cfg) {
+
+		dev_dbg(codec->dev, "%s: Overriding to custom params....\n",
+							__func__);
+
+		snd_mask_none(hw_param_mask(&hw_params,
+					SNDRV_PCM_HW_PARAM_FORMAT));
+		snd_mask_set(hw_param_mask(&hw_params,
+					SNDRV_PCM_HW_PARAM_FORMAT),
+					pdata->custom_cfg->format);
+
+		hw_param_interval(&hw_params, SNDRV_PCM_HW_PARAM_RATE)->min =
+						pdata->custom_cfg->rate;
+		hw_param_interval(&hw_params, SNDRV_PCM_HW_PARAM_RATE)->max =
+						pdata->custom_cfg->rate;
+
+		hw_param_interval(&hw_params,
+					SNDRV_PCM_HW_PARAM_CHANNELS)->min =
+						pdata->custom_cfg->channels;
+		hw_param_interval(&hw_params,
+					SNDRV_PCM_HW_PARAM_CHANNELS)->max =
+						pdata->custom_cfg->channels;
+	}
+
 	switch (dai->id) {
 	case 1:
 		aif1_reg = WM8994_AIF1_CONTROL_1;
@@ -2806,8 +2869,9 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 		return -EINVAL;
 	}
 
-	bclk_rate = params_rate(params);
-	switch (params_format(params)) {
+	bclk_rate = params_rate(&hw_params);
+
+	switch (params_format(&hw_params)) {
 	case SNDRV_PCM_FORMAT_S16_LE:
 		bclk_rate *= 16;
 		break;
@@ -2827,7 +2891,7 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 		return -EINVAL;
 	}
 
-	wm8994->channels[id] = params_channels(params);
+	wm8994->channels[id] = params_channels(&hw_params);
 	if (pdata->max_channels_clocked[id] &&
 	    wm8994->channels[id] > pdata->max_channels_clocked[id]) {
 		dev_dbg(dai->dev, "Constraining channels to %d from %d\n",
@@ -2847,7 +2911,7 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 
 	/* Try to find an appropriate sample rate; look for an exact match. */
 	for (i = 0; i < ARRAY_SIZE(srs); i++)
-		if (srs[i].rate == params_rate(params))
+		if (srs[i].rate == params_rate(&hw_params))
 			break;
 	if (i == ARRAY_SIZE(srs))
 		return -EINVAL;
@@ -2868,10 +2932,10 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 
 	/* AIFCLK/fs ratio; look for a close match in either direction */
 	best = 0;
-	best_val = abs((fs_ratios[0] * params_rate(params))
+	best_val = abs((fs_ratios[0] * params_rate(&hw_params))
 		       - wm8994->aifclk[id]);
 	for (i = 1; i < ARRAY_SIZE(fs_ratios); i++) {
-		cur_val = abs((fs_ratios[i] * params_rate(params))
+		cur_val = abs((fs_ratios[i] * params_rate(&hw_params))
 			      - wm8994->aifclk[id]);
 		if (cur_val >= best_val)
 			continue;
@@ -2899,7 +2963,7 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 		bclk_divs[best], bclk_rate);
 	bclk |= best << WM8994_AIF1_BCLK_DIV_SHIFT;
 
-	lrclk = bclk_rate / params_rate(params);
+	lrclk = bclk_rate / params_rate(&hw_params);
 	if (!lrclk) {
 		dev_err(dai->dev, "Unable to generate LRCLK from %dHz BCLK\n",
 			bclk_rate);
@@ -2919,12 +2983,12 @@ static int wm8994_hw_params(struct snd_pcm_substream *substream,
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		switch (dai->id) {
 		case 1:
-			wm8994->dac_rates[0] = params_rate(params);
+			wm8994->dac_rates[0] = params_rate(&hw_params);
 			wm8994_set_retune_mobile(codec, 0);
 			wm8994_set_retune_mobile(codec, 1);
 			break;
 		case 2:
-			wm8994->dac_rates[1] = params_rate(params);
+			wm8994->dac_rates[1] = params_rate(&hw_params);
 			wm8994_set_retune_mobile(codec, 2);
 			break;
 		}
@@ -2977,6 +3041,13 @@ static int wm8994_aif3_hw_params(struct snd_pcm_substream *substream,
 	return snd_soc_update_bits(codec, aif1_reg, WM8994_AIF1_WL_MASK, aif1);
 }
 
+#if IS_ENABLED(CONFIG_SND_MRFLD_MACHINE) || \
+	IS_ENABLED(CONFIG_SND_MOOR_MACHINE)
+static int wm8994_aif_mute(struct snd_soc_dai *codec_dai, int mute)
+{
+	return 0;
+}
+#else
 static int wm8994_aif_mute(struct snd_soc_dai *codec_dai, int mute)
 {
 	struct snd_soc_codec *codec = codec_dai->codec;
@@ -3003,6 +3074,7 @@ static int wm8994_aif_mute(struct snd_soc_dai *codec_dai, int mute)
 
 	return 0;
 }
+#endif
 
 static int wm8994_set_tristate(struct snd_soc_dai *codec_dai, int tristate)
 {
@@ -3030,6 +3102,25 @@ static int wm8994_set_tristate(struct snd_soc_dai *codec_dai, int tristate)
 	return snd_soc_update_bits(codec, reg, mask, val);
 }
 
+static int wm8994_set_tdm_slots(struct snd_soc_dai *dai,
+	unsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
+	struct wm8994 *control = wm8994->wm8994;
+
+	switch (control->type) {
+	case WM8958:
+		wm8994->slots = slots;
+		break;
+	default:
+		pr_err("we dont support tdm for non 8958!");
+		return -EINVAL;
+		break;
+	}
+	return 0;
+}
+
 static int wm8994_aif2_probe(struct snd_soc_dai *dai)
 {
 	struct snd_soc_codec *codec = dai->codec;
@@ -3057,6 +3148,7 @@ static const struct snd_soc_dai_ops wm8994_aif1_dai_ops = {
 	.digital_mute	= wm8994_aif_mute,
 	.set_pll	= wm8994_set_fll,
 	.set_tristate	= wm8994_set_tristate,
+	.set_tdm_slot	= wm8994_set_tdm_slots,
 };
 
 static const struct snd_soc_dai_ops wm8994_aif2_dai_ops = {
@@ -3557,6 +3649,7 @@ static void wm8958_open_circuit_work(struct work_struct *work)
 
 	wm8994->jack_mic = false;
 	wm8994->mic_detecting = true;
+	wm8994->headphone_detected = false;
 
 	wm8958_micd_set_rate(wm8994->hubs.codec);
 
@@ -3634,10 +3727,8 @@ static void wm1811_mic_work(struct work_struct *work)
 
 	dev_dbg(codec->dev, "Starting mic detection\n");
 
-	/* Use a user-supplied callback if we have one */
-	if (wm8994->micd_cb) {
-		wm8994->micd_cb(wm8994->micd_cb_data);
-	} else {
+	/* If there's a callback it'll be called out of the lock */
+	if (!wm8994->micd_cb) {
 		/*
 		 * Start off measument of microphone impedence to find out
 		 * what's actually there.
@@ -3651,6 +3742,10 @@ static void wm1811_mic_work(struct work_struct *work)
 
 	mutex_unlock(&wm8994->accdet_lock);
 
+	/* Custom callbacks may reasonably wish to take the same locks */
+	if (wm8994->micd_cb)
+		wm8994->micd_cb(wm8994->micd_cb_data);
+
 	pm_runtime_put(codec->dev);
 }
 
@@ -3662,6 +3757,8 @@ static irqreturn_t wm1811_jackdet_irq(int irq, void *data)
 	int reg, delay;
 	bool present;
 
+	cancel_delayed_work_sync(&wm8994->mic_work);
+
 	pm_runtime_get_sync(codec->dev);
 
 	cancel_delayed_work_sync(&wm8994->mic_complete_work);
@@ -3699,8 +3796,6 @@ static irqreturn_t wm1811_jackdet_irq(int irq, void *data)
 	} else {
 		dev_dbg(codec->dev, "Jack not detected\n");
 
-		cancel_delayed_work_sync(&wm8994->mic_work);
-
 		snd_soc_update_bits(codec, WM8958_MICBIAS2,
 				    WM8958_MICB2_DISCH, WM8958_MICB2_DISCH);
 
@@ -3789,6 +3884,7 @@ int wm8958_mic_detect(struct snd_soc_codec *codec, struct snd_soc_jack *jack,
 		} else {
 			wm8994->mic_detecting = true;
 			wm8994->jack_mic = false;
+			wm8994->headphone_detected = false;
 		}
 
 		if (id_cb) {
@@ -3849,6 +3945,21 @@ int wm8958_mic_detect(struct snd_soc_codec *codec, struct snd_soc_jack *jack,
 }
 EXPORT_SYMBOL_GPL(wm8958_mic_detect);
 
+int wm8958_micd_set_custom_rate(struct snd_soc_codec *codec,
+		wm8958_micd_set_custom_rate_cb micd_custom_rate_cb,
+		void *micd_custom_rate_cb_data)
+{
+	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
+
+	if (micd_custom_rate_cb) {
+		wm8994->micd_custom_rate_cb = micd_custom_rate_cb;
+		wm8994->micd_custom_rate_cb_data = micd_custom_rate_cb_data;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(wm8958_micd_set_custom_rate);
+
 static void wm8958_mic_work(struct work_struct *work)
 {
 	struct wm8994_priv *wm8994 = container_of(work,
@@ -3856,6 +3967,8 @@ static void wm8958_mic_work(struct work_struct *work)
 						  mic_complete_work.work);
 	struct snd_soc_codec *codec = wm8994->hubs.codec;
 
+	dev_crit(codec->dev, "MIC WORK %x\n", wm8994->mic_status);
+
 	pm_runtime_get_sync(codec->dev);
 
 	mutex_lock(&wm8994->accdet_lock);
@@ -3865,12 +3978,36 @@ static void wm8958_mic_work(struct work_struct *work)
 	mutex_unlock(&wm8994->accdet_lock);
 
 	pm_runtime_put(codec->dev);
+
+	dev_crit(codec->dev, "MIC WORK %x DONE\n", wm8994->mic_status);
+}
+
+static void wm8958_micd_set_custom_rate_work(struct work_struct *work)
+{
+	struct wm8994_priv *wm8994 = container_of(work,
+						  struct wm8994_priv,
+						  micd_set_custom_rate_work.work);
+	struct snd_soc_codec *codec = wm8994->hubs.codec;
+
+	dev_dbg(codec->dev, "%s: Set custom rates\n", __func__);
+
+	pm_runtime_get_sync(codec->dev);
+
+	mutex_lock(&wm8994->accdet_lock);
+
+	wm8994->micd_custom_rate_cb(wm8994->micd_custom_rate_cb_data);
+
+	mutex_unlock(&wm8994->accdet_lock);
+
+	pm_runtime_put(codec->dev);
+
 }
 
 static irqreturn_t wm8958_mic_irq(int irq, void *data)
 {
 	struct wm8994_priv *wm8994 = data;
 	struct snd_soc_codec *codec = wm8994->hubs.codec;
+	struct wm8994 *control = wm8994->wm8994;
 	int reg, count, ret, id_delay;
 
 	/*
@@ -3932,6 +4069,8 @@ static irqreturn_t wm8958_mic_irq(int irq, void *data)
 		snd_soc_jack_report(wm8994->micdet[0].jack, 0,
 				    SND_JACK_MECHANICAL | SND_JACK_HEADSET |
 				    wm8994->btn_mask);
+		wm8994->jack_mic = false;
+		wm8994->headphone_detected = false;
 		wm8994->mic_detecting = true;
 		goto out;
 	}
@@ -3939,10 +4078,20 @@ static irqreturn_t wm8958_mic_irq(int irq, void *data)
 	wm8994->mic_status = reg;
 	id_delay = wm8994->wm8994->pdata.mic_id_delay;
 
-	if (wm8994->mic_detecting)
+	if (wm8994->mic_detecting){
+		if (control->type == WM8958) {
+			/* Set mic-bias high during detection phase (micb_en_delay) */
+			/* 0 == Continuous */
+			dev_dbg(codec->dev, "Set MICBIAS High, for micb_en_delay time\n");
+			snd_soc_update_bits(codec, WM8958_MIC_DETECT_1,
+				    WM8958_MICD_BIAS_STARTTIME_MASK |
+				    WM8958_MICD_RATE_MASK, 0);
+		}
+
 		queue_delayed_work(system_power_efficient_wq,
 				   &wm8994->mic_complete_work,
 				   msecs_to_jiffies(id_delay));
+	}
 	else
 		wm8958_button_det(codec, reg);
 
@@ -3983,6 +4132,7 @@ static int wm8994_codec_probe(struct snd_soc_codec *codec)
 	struct wm8994 *control = dev_get_drvdata(codec->dev->parent);
 	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
 	struct snd_soc_dapm_context *dapm = &codec->dapm;
+	unsigned int dcs_done_irq;
 	unsigned int reg;
 	int ret, i;
 
@@ -4004,6 +4154,10 @@ static int wm8994_codec_probe(struct snd_soc_codec *codec)
 	case WM1811:
 		INIT_DELAYED_WORK(&wm8994->mic_work, wm1811_mic_work);
 		break;
+	case WM8958:
+		INIT_DELAYED_WORK(&wm8994->micd_set_custom_rate_work,
+					wm8958_micd_set_custom_rate_work);
+		break;
 	default:
 		break;
 	}
@@ -4079,6 +4233,9 @@ static int wm8994_codec_probe(struct snd_soc_codec *codec)
 	wm8994_request_irq(wm8994->wm8994, WM8994_IRQ_TEMP_SHUT,
 			   wm8994_temp_shut, "Thermal shutdown", codec);
 
+	dcs_done_irq = regmap_irq_get_virq(wm8994->wm8994->irq_data,
+					   WM8994_IRQ_DCS_DONE);
+	irq_set_status_flags(dcs_done_irq, IRQ_NOAUTOEN);
 	switch (control->type) {
 	case WM8994:
 		if (wm8994->micdet_irq) {
@@ -4179,7 +4336,6 @@ static int wm8994_codec_probe(struct snd_soc_codec *codec)
 	}
 	if ((reg & WM8994_GPN_FN_MASK) != WM8994_GP_FN_PIN_SPECIFIC) {
 		wm8994->lrclk_shared[0] = 1;
-		wm8994_dai[0].symmetric_rates = 1;
 	} else {
 		wm8994->lrclk_shared[0] = 0;
 	}
@@ -4314,6 +4470,7 @@ static int wm8994_codec_probe(struct snd_soc_codec *codec)
 				 &wm8994->hubs);
 	if (ret == 0)
 		wm8994->hubs.dcs_done_irq = true;
+	enable_irq(dcs_done_irq);
 	snd_soc_dapm_add_routes(dapm, intercon, ARRAY_SIZE(intercon));
 
 	switch (control->type) {
@@ -4356,6 +4513,11 @@ static int wm8994_codec_probe(struct snd_soc_codec *codec)
 		break;
 	}
 
+	/* Make sure FIFO errors are masked */
+	snd_soc_update_bits(codec, WM8994_INTERRUPT_STATUS_2_MASK,
+			    WM8994_IM_FIFOS_ERR_EINT_MASK,
+			    1 << WM8994_IM_FIFOS_ERR_EINT_SHIFT);
+
 	return 0;
 
 err_irq:
@@ -4463,6 +4625,11 @@ static int wm8994_remove(struct platform_device *pdev)
 static int wm8994_suspend(struct device *dev)
 {
 	struct wm8994_priv *wm8994 = dev_get_drvdata(dev);
+	struct wm8994 *control = wm8994->wm8994;
+	struct snd_soc_codec *codec = wm8994->hubs.codec;
+	unsigned int reg;
+	int ret;
+
 
 	/* Drop down to power saving mode when system is suspended */
 	if (wm8994->jackdet && !wm8994->active_refcount)
@@ -4470,18 +4637,62 @@ static int wm8994_suspend(struct device *dev)
 				   WM1811_JACKDET_MODE_MASK,
 				   wm8994->jackdet_mode);
 
+	/* Disable the MIC Detection when suspended */
+	if ((control->type == WM8958) && wm8994->mic_id_cb) {
+
+		reg = snd_soc_read(codec, WM8958_MIC_DETECT_3);
+
+		dev_dbg(codec->dev, "%s: WM8958_MIC_DETECT_3 0x%x\n", __func__, reg);
+		dev_dbg(codec->dev, "mic_detect %d jack_mic %d headphone %d\n",
+					wm8994->mic_detecting, wm8994->jack_mic,
+					wm8994->headphone_detected);
+
+		if (!(wm8994->jack_mic) && !(wm8994->headphone_detected)) {
+
+			dev_dbg(codec->dev, "Jack not connected..Mask interrupt\n");
+			snd_soc_write(codec, WM8994_INTERRUPT_CONTROL, 0x01);
+
+			ret = regcache_sync_region(wm8994->wm8994->regmap,
+					WM8994_INTERRUPT_CONTROL,
+					WM8994_INTERRUPT_CONTROL);
+			if (ret != 0)
+				dev_err(dev, "Failed to sync register: %d\n", ret);
+			synchronize_irq(control->irq);
+
+			dev_dbg(codec->dev, "Disable MIC Detection!!!\n");
+			snd_soc_update_bits(codec, WM8958_MIC_DETECT_1,
+						WM8958_MICD_ENA, 0);
+
+			snd_soc_dapm_disable_pin(&codec->dapm, "CLK_SYS");
+			snd_soc_dapm_sync(&codec->dapm);
+		}
+	}
+
 	return 0;
 }
 
 static int wm8994_resume(struct device *dev)
 {
 	struct wm8994_priv *wm8994 = dev_get_drvdata(dev);
+	struct wm8994 *control = wm8994->wm8994;
+	struct snd_soc_codec *codec = wm8994->hubs.codec;
 
 	if (wm8994->jackdet && wm8994->jackdet_mode)
 		regmap_update_bits(wm8994->wm8994->regmap, WM8994_ANTIPOP_2,
 				   WM1811_JACKDET_MODE_MASK,
 				   WM1811_JACKDET_MODE_AUDIO);
 
+	/* Enable the MIC Detection when resumed */
+	if ((control->type == WM8958) && wm8994->mic_id_cb) {
+		dev_dbg(codec->dev, "Enable MIC Detection!!!\n");
+		snd_soc_dapm_force_enable_pin(&codec->dapm, "CLK_SYS");
+		snd_soc_dapm_sync(&codec->dapm);
+
+		snd_soc_update_bits(codec, WM8958_MIC_DETECT_1,
+					WM8958_MICD_ENA, WM8958_MICD_ENA);
+		snd_soc_write(codec, WM8994_INTERRUPT_CONTROL, 0x00);
+	}
+
 	return 0;
 }
 #endif
diff --git a/sound/soc/codecs/wm8994.h b/sound/soc/codecs/wm8994.h
index 6536f8d..0a834df 100644
--- a/sound/soc/codecs/wm8994.h
+++ b/sound/soc/codecs/wm8994.h
@@ -41,6 +41,7 @@ enum wm8994_vmid_mode {
 
 typedef void (*wm1811_micdet_cb)(void *data);
 typedef void (*wm1811_mic_id_cb)(void *data, u16 status);
+typedef void (*wm8958_micd_set_custom_rate_cb)(struct snd_soc_codec *codec);
 
 int wm8994_mic_detect(struct snd_soc_codec *codec, struct snd_soc_jack *jack,
 		      int micbias);
@@ -55,6 +56,10 @@ int wm8958_aif_ev(struct snd_soc_dapm_widget *w,
 
 void wm8958_dsp2_init(struct snd_soc_codec *codec);
 
+int wm8958_micd_set_custom_rate(struct snd_soc_codec *codec,
+			wm8958_micd_set_custom_rate_cb micd_custom_rate_cb,
+			void *micd_custom_rate_cb_data);
+
 struct wm8994_micdet {
 	struct snd_soc_jack *jack;
 	bool detecting;
@@ -86,6 +91,7 @@ struct wm8994_priv {
 	bool fll_locked_irq;
 	bool fll_byp;
 	bool clk_has_run;
+	int slots;
 
 	int vmid_refcount;
 	int active_refcount;
@@ -136,9 +142,12 @@ struct wm8994_priv {
 	struct delayed_work mic_work;
 	struct delayed_work open_circuit_work;
 	struct delayed_work mic_complete_work;
+	struct delayed_work micd_set_custom_rate_work;
+
 	u16 mic_status;
 	bool mic_detecting;
 	bool jack_mic;
+	bool headphone_detected;
 	int btn_mask;
 	bool jackdet;
 	int jackdet_mode;
@@ -149,6 +158,8 @@ struct wm8994_priv {
 	void *micd_cb_data;
 	wm1811_mic_id_cb mic_id_cb;
 	void *mic_id_cb_data;
+	wm8958_micd_set_custom_rate_cb micd_custom_rate_cb;
+	void *micd_custom_rate_cb_data;
 
 	unsigned int aif1clk_enable:1;
 	unsigned int aif2clk_enable:1;
diff --git a/sound/soc/codecs/wm_hubs.c b/sound/soc/codecs/wm_hubs.c
index b371066..71432e1 100644
--- a/sound/soc/codecs/wm_hubs.c
+++ b/sound/soc/codecs/wm_hubs.c
@@ -1217,11 +1217,6 @@ int wm_hubs_handle_analogue_pdata(struct snd_soc_codec *codec,
 				    WM8993_LINEOUT2_MODE,
 				    WM8993_LINEOUT2_MODE);
 
-	if (!lineout1_diff && !lineout2_diff)
-		snd_soc_update_bits(codec, WM8993_ANTIPOP1,
-				    WM8993_LINEOUT_VMID_BUF_ENA,
-				    WM8993_LINEOUT_VMID_BUF_ENA);
-
 	if (lineout1fb)
 		snd_soc_update_bits(codec, WM8993_ADDITIONAL_CONTROL,
 				    WM8993_LINEOUT1_FB, WM8993_LINEOUT1_FB);
@@ -1247,6 +1242,13 @@ void wm_hubs_vmid_ena(struct snd_soc_codec *codec)
 	struct wm_hubs_data *hubs = snd_soc_codec_get_drvdata(codec);
 	int val = 0;
 
+	if ((hubs->lineout1_se && hubs->lineout2_se) &&
+			(hubs->lineout1n_ena  || hubs->lineout1p_ena ||
+			hubs->lineout2n_ena || hubs->lineout2p_ena))
+		snd_soc_update_bits(codec, WM8993_ANTIPOP1,
+			WM8993_LINEOUT_VMID_BUF_ENA,
+			WM8993_LINEOUT_VMID_BUF_ENA);
+
 	if (hubs->lineout1_se)
 		val |= WM8993_LINEOUT1N_ENA | WM8993_LINEOUT1P_ENA;
 
@@ -1276,6 +1278,13 @@ void wm_hubs_set_bias_level(struct snd_soc_codec *codec,
 		val = 0;
 		mask = 0;
 
+		if ((hubs->lineout1_se && hubs->lineout2_se) &&
+				(hubs->lineout1n_ena  || hubs->lineout1p_ena ||
+				hubs->lineout2n_ena || hubs->lineout2p_ena))
+			snd_soc_update_bits(codec, WM8993_ANTIPOP1,
+				WM8993_LINEOUT_VMID_BUF_ENA,
+				WM8993_LINEOUT_VMID_BUF_ENA);
+
 		if (hubs->lineout1_se)
 			mask |= WM8993_LINEOUT1N_ENA | WM8993_LINEOUT1P_ENA;
 
diff --git a/sound/soc/intel/Kconfig b/sound/soc/intel/Kconfig
index 61c10bf..b6efaac 100644
--- a/sound/soc/intel/Kconfig
+++ b/sound/soc/intel/Kconfig
@@ -1,13 +1,58 @@
 config SND_MFLD_MACHINE
 	tristate "SOC Machine Audio driver for Intel Medfield MID platform"
-	depends on INTEL_SCU_IPC
+	depends on INTEL_SCU_IPC && INTEL_SCU_IPC_UTIL && X86 && GPIO_LANGWELL
+	depends on MSIC_GPADC
 	select SND_SOC_SN95031
 	select SND_SST_PLATFORM
+	select SND_SST_MACHINE
+	select SND_INTEL_SST
+	default n
 	help
           This adds support for ASoC machine driver for Intel(R) MID Medfield platform
+          used as alsa device in audio subsystem in Intel(R) MID devices
+          Say Y if you have such a device
+	  If unsure select "N".
+
+config SND_MRFLD_MACHINE
+	tristate "SOC Machine Audio driver for Intel Merrifield MID platform"
+	depends on INTEL_SCU_IPC && X86
+	select SND_SOC_LM49453
+	select SND_SOC_WM8994
+	select MFD_CORE
+	select MFD_WM8994
+	select REGULATOR_WM8994
+	select SND_SST_PLATFORM
+	select SND_SST_MACHINE
+	select SND_INTEL_SST
+	select SND_EFFECTS_OFFLOAD
+	default n
+	help
+	  This adds support for ASoC machine driver for Intel(R) MID Merrifield platform
           used as alsa device in audio substem in Intel(R) MID devices
           Say Y if you have such a device
           If unsure select "N".
 
+config SND_INTEL_SST
+       tristate
+
 config SND_SST_PLATFORM
 	tristate
+
+config SND_SOC_COMMS_SSP
+	depends on SND_INTEL_MID_I2S
+	tristate "Use ASOC framework to drive AudioComms SSP BT and Modem"
+	help
+	  Sound SOC cards usually used for BT VOIP and MODEM MIXING use cases.
+	  This will add devices for these uses cases in the list of alsa cards.
+	  Say Y if you need these sound cards (BT chipset or Modem present).
+	  Requires to enable the INTEL_MID_I2S low level SSP I2S driver.
+
+config SST_MRFLD_DPCM
+	bool "Use DPCM based Merrifield Machine Audio driver"
+	default n
+	help
+	  This adds an option to enable the DPCM based MRFLD machine driver
+
+config SND_SST_MACHINE
+	tristate
+
diff --git a/sound/soc/intel/Makefile b/sound/soc/intel/Makefile
index 6398833..88c67d1 100644
--- a/sound/soc/intel/Makefile
+++ b/sound/soc/intel/Makefile
@@ -1,5 +1,19 @@
-snd-soc-sst-platform-objs := sst_platform.o
 snd-soc-mfld-machine-objs := mfld_machine.o
 
-obj-$(CONFIG_SND_SST_PLATFORM) += snd-soc-sst-platform.o
 obj-$(CONFIG_SND_MFLD_MACHINE) += snd-soc-mfld-machine.o
+
+# SST Platform Driver
+PLATFORM_LIBS = platform-libs/controls_v1.o platform-libs/controls_v2.o platform-libs/controls_v2_dpcm.o \
+		platform-libs/ipc_lib_v2.o
+
+snd-soc-sst-platform-objs := pcm.o compress.o effects.o $(PLATFORM_LIBS)
+obj-$(CONFIG_SND_SST_PLATFORM) += snd-soc-sst-platform.o
+
+# Relevant Machine driver
+obj-$(CONFIG_SND_SST_MACHINE) += board/
+
+# DSP driver
+obj-$(CONFIG_SND_INTEL_SST) += sst/
+
+# Audio Comms
+obj-$(CONFIG_SND_SOC_COMMS_SSP) += ssp/
diff --git a/sound/soc/intel/board/Makefile b/sound/soc/intel/board/Makefile
new file mode 100644
index 0000000..3581ae1
--- /dev/null
+++ b/sound/soc/intel/board/Makefile
@@ -0,0 +1,14 @@
+#EXTRA CFLAGS
+ccflags-y += -Werror
+
+# Merrifield board
+snd-merr-saltbay-wm8958-objs := merr_saltbay_wm8958.o
+snd-merr-dpcm-wm8958-objs := merr_dpcm_wm8958.o
+snd-merr-dpcm-dummy-objs := merr_dpcm_dummy.o
+
+ifdef CONFIG_SST_MRFLD_DPCM
+	obj-$(CONFIG_SND_MRFLD_MACHINE) += snd-merr-dpcm-wm8958.o
+	obj-$(CONFIG_SND_MRFLD_MACHINE) += snd-merr-dpcm-dummy.o
+else
+	obj-$(CONFIG_SND_MRFLD_MACHINE) += snd-merr-saltbay-wm8958.o
+endif
diff --git a/sound/soc/intel/board/merr_dpcm_dummy.c b/sound/soc/intel/board/merr_dpcm_dummy.c
new file mode 100644
index 0000000..5603b21
--- /dev/null
+++ b/sound/soc/intel/board/merr_dpcm_dummy.c
@@ -0,0 +1,201 @@
+/*
+ *  ASoc Dummy DPCM Machine driver for Intel Edison MID platform
+ *
+ *  Copyright (C) 2014 Intel Corp
+ *  Author: Michael Soares <michaelx.soares@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <asm/intel_scu_pmic.h>
+#include <asm/intel_sst_mrfld.h>
+#include <sound/soc.h>
+#include <sound/pcm_params.h>
+
+#ifdef CONFIG_PM_SLEEP
+static int snd_merr_dpcm_prepare(struct device *dev)
+{
+	pr_debug("In %s device name\n", __func__);
+	snd_soc_suspend(dev);
+	return 0;
+}
+
+static void snd_merr_dpcm_complete(struct device *dev)
+{
+	pr_debug("In %s\n", __func__);
+	snd_soc_resume(dev);
+	return;
+}
+
+static int snd_merr_dpcm_poweroff(struct device *dev)
+{
+	pr_debug("In %s\n", __func__);
+	snd_soc_poweroff(dev);
+	return 0;
+}
+#else
+#define snd_merr_dpcm_prepare NULL
+#define snd_merr_dpcm_complete NULL
+#define snd_merr_dpcm_poweroff NULL
+#endif
+
+static unsigned int rates_48000[] = {
+	48000,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_48000 = {
+	.count = ARRAY_SIZE(rates_48000),
+	.list  = rates_48000,
+};
+
+static int merr_dummy_startup(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_hw_constraint_list(substream->runtime, 0,
+			SNDRV_PCM_HW_PARAM_RATE,
+			&constraints_48000);
+}
+
+static struct snd_soc_ops merr_dummy_ops = {
+		.startup = merr_dummy_startup,
+};
+
+static int merr_codec_fixup(struct snd_soc_pcm_runtime *rtd,
+		struct snd_pcm_hw_params *params)
+{
+	struct snd_interval *rate = hw_param_interval(params,
+			SNDRV_PCM_HW_PARAM_RATE);
+	struct snd_interval *channels = hw_param_interval(params,
+			SNDRV_PCM_HW_PARAM_CHANNELS);
+
+	pr_debug("Invoked %s for dailink %s\n", __func__, rtd->dai_link->name);
+
+	/* The DSP will convert the FE rate to 48k, stereo, 24bits */
+	rate->min = rate->max = 48000;
+	channels->min = channels->max = 2;
+
+	/* set SSP2 to 24-bit */
+	snd_mask_set(&params->masks[SNDRV_PCM_HW_PARAM_FORMAT -
+				SNDRV_PCM_HW_PARAM_FIRST_MASK],
+				SNDRV_PCM_FORMAT_S24_LE);
+	return 0;
+}
+
+struct snd_soc_dai_link merr_msic_dailink[] = {
+	[MERR_DPCM_AUDIO] = {
+		.name = "Media Audio Port",
+		.stream_name = "Edison Audio",
+		.cpu_dai_name = "Headset-cpu-dai",
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.platform_name = "sst-platform",
+		.ignore_suspend = 1,
+		.dynamic = 1,
+		.ops = &merr_dummy_ops,
+	},
+	/* back ends */
+	{
+		.name = "SSP2-Codec",
+		.be_id = 1,
+		.cpu_dai_name = "ssp2-codec",
+		.platform_name = "sst-platform",
+		.no_pcm = 1,
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.be_hw_params_fixup = merr_codec_fixup,
+		.ignore_suspend = 1,
+	},
+	{
+		.name = "SSP1-BT",
+		.be_id = 2,
+		.cpu_dai_name = "snd-soc-dummy-dai",
+		.platform_name = "snd-soc-dummy",
+		.no_pcm = 1,
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.ignore_suspend = 1,
+	},
+
+};
+
+static const struct snd_soc_dapm_route map[] = {
+	{ "Dummy Playback", NULL, "codec_out0"  },
+	{ "Dummy Playback", NULL, "codec_out1"  },
+	{ "codec_in0", NULL, "Dummy Capture" },
+	{ "codec_in1", NULL, "Dummy Capture" },
+};
+
+/* SoC card */
+static struct snd_soc_card snd_soc_card_merr = {
+	.name = "dummy-audio",
+	.dai_link = merr_msic_dailink,
+	.num_links = ARRAY_SIZE(merr_msic_dailink),
+	.dapm_routes = map,
+	.num_dapm_routes = ARRAY_SIZE(map),
+};
+
+static int snd_merr_dpcm_probe(struct platform_device *pdev)
+{
+	int ret_val = 0;
+	pr_debug("%s enter\n", __func__);
+
+	/* register the soc card */
+	snd_soc_card_merr.dev = &pdev->dev;
+	ret_val = snd_soc_register_card(&snd_soc_card_merr);
+	if (ret_val) {
+		pr_err("snd_soc_register_card failed %d\n", ret_val);
+		return ret_val;
+	}
+	platform_set_drvdata(pdev, &snd_soc_card_merr);
+	pr_info("%s successful\n", __func__);
+	return ret_val;
+}
+
+static int snd_merr_dpcm_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *soc_card = platform_get_drvdata(pdev);
+	pr_err("snd_merr_dpcm_remove");
+	snd_soc_unregister_card(soc_card);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+const struct dev_pm_ops snd_merr_dpcm_mc_pm_ops = {
+	.prepare = snd_merr_dpcm_prepare,
+	.complete = snd_merr_dpcm_complete,
+	.poweroff = snd_merr_dpcm_poweroff,
+};
+
+static struct platform_driver snd_merr_dpcm_drv = {
+	.driver = {
+			.owner = THIS_MODULE,
+			.name = "merr_dpcm_dummy",
+			.pm = &snd_merr_dpcm_mc_pm_ops,
+	},
+	.probe = snd_merr_dpcm_probe,
+	.remove = snd_merr_dpcm_remove,
+};
+
+module_platform_driver(snd_merr_dpcm_drv);
+
+MODULE_DESCRIPTION("ASoC Intel(R) Edison dummy MID Machine driver");
+MODULE_AUTHOR("Michael Soares <michaelx.soares@intel.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:merr_dpcm_dummy");
+
diff --git a/sound/soc/intel/board/merr_dpcm_wm8958.c b/sound/soc/intel/board/merr_dpcm_wm8958.c
new file mode 100644
index 0000000..3b89a82
--- /dev/null
+++ b/sound/soc/intel/board/merr_dpcm_wm8958.c
@@ -0,0 +1,931 @@
+/*
+ *  merr_dpcm_wm8958.c - ASoc DPCM Machine driver for Intel Merrfield MID platform
+ *
+ *  Copyright (C) 2013 Intel Corp
+ *  Author: Vinod Koul <vinod.koul@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/async.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <asm/intel_scu_pmic.h>
+#include <asm/intel_mid_rpmsg.h>
+#include <asm/intel_sst_mrfld.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/jack.h>
+#include <linux/input.h>
+
+#include <linux/mfd/wm8994/core.h>
+#include <linux/mfd/wm8994/registers.h>
+#include <linux/mfd/wm8994/pdata.h>
+#include "../../codecs/wm8994.h"
+
+/* Codec PLL output clk rate */
+#define CODEC_SYSCLK_RATE			24576000
+/* Input clock to codec at MCLK1 PIN */
+#define CODEC_IN_MCLK1_RATE			19200000
+/* Input clock to codec at MCLK2 PIN */
+#define CODEC_IN_MCLK2_RATE			32768
+/*  define to select between MCLK1 and MCLK2 input to codec as its clock */
+#define CODEC_IN_MCLK1				1
+#define CODEC_IN_MCLK2				2
+
+/* Register address for OSC Clock */
+#define MERR_OSC_CLKOUT_CTRL0_REG_ADDR  0xFF00BC04
+/* Size of osc clock register */
+#define MERR_OSC_CLKOUT_CTRL0_REG_SIZE  4
+
+struct mrfld_8958_mc_private {
+	struct snd_soc_jack jack;
+	int jack_retry;
+	u8 pmic_id;
+	void __iomem    *osc_clk0_reg;
+};
+
+
+/* set_osc_clk0-	enable/disables the osc clock0
+ * addr:		address of the register to write to
+ * enable:		bool to enable or disable the clock
+ */
+static inline void set_soc_osc_clk0(void __iomem *addr, bool enable)
+{
+	u32 osc_clk_ctrl;
+
+	osc_clk_ctrl = readl(addr);
+	if (enable)
+		osc_clk_ctrl |= BIT(31);
+	else
+		osc_clk_ctrl &= ~(BIT(31));
+
+	pr_debug("%s: enable:%d val 0x%x\n", __func__, enable, osc_clk_ctrl);
+
+	writel(osc_clk_ctrl, addr);
+}
+
+static inline struct snd_soc_codec *mrfld_8958_get_codec(struct snd_soc_card *card)
+{
+	bool found = false;
+	struct snd_soc_codec *codec;
+
+	list_for_each_entry(codec, &card->codec_dev_list, card_list) {
+		if (!strstr(codec->name, "wm8994-codec")) {
+			pr_debug("codec was %s", codec->name);
+			continue;
+		} else {
+			found = true;
+			break;
+		}
+	}
+	if (found == false) {
+		pr_warn("%s: cant find codec", __func__);
+		return NULL;
+	}
+	return codec;
+}
+
+/* TODO: find better way of doing this */
+static struct snd_soc_dai *find_codec_dai(struct snd_soc_card *card, const char *dai_name)
+{
+	int i;
+	for (i = 0; i < card->num_rtd; i++) {
+		if (!strcmp(card->rtd[i].codec_dai->name, dai_name))
+			return card->rtd[i].codec_dai;
+	}
+	pr_err("%s: unable to find codec dai\n", __func__);
+	/* this should never occur */
+	WARN_ON(1);
+	return NULL;
+}
+
+/* Function to switch the input clock for codec,  When audio is in
+ * progress input clock to codec will be through MCLK1 which is 19.2MHz
+ * while in off state input clock to codec will be through 32KHz through
+ * MCLK2
+ * card	: Sound card structure
+ * src	: Input clock source to codec
+ */
+static int mrfld_8958_set_codec_clk(struct snd_soc_card *card, int src)
+{
+	struct snd_soc_dai *aif1_dai = find_codec_dai(card, "wm8994-aif1");
+	int ret;
+
+	if (!aif1_dai)
+		return -ENODEV;
+
+	switch (src) {
+	case CODEC_IN_MCLK1:
+		/* Turn ON the PLL to generate required sysclk rate
+		 * from MCLK1 */
+		ret = snd_soc_dai_set_pll(aif1_dai,
+			WM8994_FLL1, WM8994_FLL_SRC_MCLK1,
+			CODEC_IN_MCLK1_RATE, CODEC_SYSCLK_RATE);
+		if (ret < 0) {
+			pr_err("Failed to start FLL: %d\n", ret);
+			return ret;
+		}
+		/* Switch to MCLK1 input */
+		ret = snd_soc_dai_set_sysclk(aif1_dai, WM8994_SYSCLK_FLL1,
+				CODEC_SYSCLK_RATE, SND_SOC_CLOCK_IN);
+		if (ret < 0) {
+			pr_err("Failed to set codec sysclk configuration %d\n",
+				 ret);
+			return ret;
+		}
+		break;
+	case CODEC_IN_MCLK2:
+		/* Switch to MCLK2 */
+		ret = snd_soc_dai_set_sysclk(aif1_dai, WM8994_SYSCLK_MCLK2,
+				32768, SND_SOC_CLOCK_IN);
+		if (ret < 0) {
+			pr_err("Failed to switch to MCLK2: %d", ret);
+			return ret;
+		}
+		/* Turn off PLL for MCLK1 */
+		ret = snd_soc_dai_set_pll(aif1_dai, WM8994_FLL1, 0, 0, 0);
+		if (ret < 0) {
+			pr_err("Failed to stop the FLL: %d", ret);
+			return ret;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int mrfld_wm8958_set_clk_fmt(struct snd_soc_dai *codec_dai)
+{
+	unsigned int fmt;
+	int ret = 0;
+	struct snd_soc_card *card = codec_dai->card;
+	struct mrfld_8958_mc_private *ctx = snd_soc_card_get_drvdata(card);
+
+	/* Enable the osc clock at start so that it gets settling time */
+	set_soc_osc_clk0(ctx->osc_clk0_reg, true);
+
+	pr_err("setting snd_soc_dai_set_tdm_slot\n");
+	ret = snd_soc_dai_set_tdm_slot(codec_dai, 0, 0, 4, SNDRV_PCM_FORMAT_S24_LE);
+	if (ret < 0) {
+		pr_err("can't set codec pcm format %d\n", ret);
+		return ret;
+	}
+
+	/* WM8958 slave Mode */
+	fmt =   SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF
+		| SND_SOC_DAIFMT_CBS_CFS;
+	ret = snd_soc_dai_set_fmt(codec_dai, fmt);
+	if (ret < 0) {
+		pr_err("can't set codec DAI configuration %d\n", ret);
+		return ret;
+	}
+
+	/* FIXME: move this to SYS_CLOCK event handler when codec driver
+	 * dependency is clean.
+	 */
+	/* Switch to 19.2MHz MCLK1 input clock for codec */
+	ret = mrfld_8958_set_codec_clk(card, CODEC_IN_MCLK1);
+
+	return ret;
+}
+
+static int mrfld_8958_hw_params(struct snd_pcm_substream *substream,
+			   struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+
+	if (!strcmp(codec_dai->name, "wm8994-aif1"))
+		return mrfld_wm8958_set_clk_fmt(codec_dai);
+	return 0;
+}
+
+static int mrfld_wm8958_compr_set_params(struct snd_compr_stream *cstream)
+{
+	return 0;
+}
+
+static const struct snd_soc_pcm_stream mrfld_wm8958_dai_params = {
+	.formats = SNDRV_PCM_FMTBIT_S24_LE,
+	.rate_min = 48000,
+	.rate_max = 48000,
+	.channels_min = 2,
+	.channels_max = 2,
+};
+
+static int merr_codec_fixup(struct snd_soc_pcm_runtime *rtd,
+			    struct snd_pcm_hw_params *params)
+{
+	struct snd_interval *rate = hw_param_interval(params,
+			SNDRV_PCM_HW_PARAM_RATE);
+	struct snd_interval *channels = hw_param_interval(params,
+						SNDRV_PCM_HW_PARAM_CHANNELS);
+
+	pr_debug("Invoked %s for dailink %s\n", __func__, rtd->dai_link->name);
+
+	/* The DSP will covert the FE rate to 48k, stereo, 24bits */
+	rate->min = rate->max = 48000;
+	channels->min = channels->max = 2;
+
+	/* set SSP2 to 24-bit */
+	snd_mask_set(&params->masks[SNDRV_PCM_HW_PARAM_FORMAT -
+				    SNDRV_PCM_HW_PARAM_FIRST_MASK],
+				    SNDRV_PCM_FORMAT_S24_LE);
+	return 0;
+}
+
+static int mrfld_8958_set_bias_level(struct snd_soc_card *card,
+				struct snd_soc_dapm_context *dapm,
+				enum snd_soc_bias_level level)
+{
+	struct snd_soc_dai *aif1_dai = find_codec_dai(card, "wm8994-aif1");
+	int ret = 0;
+
+	if (!aif1_dai)
+		return -ENODEV;
+
+	if (dapm->dev != aif1_dai->dev)
+		return 0;
+	switch (level) {
+	case SND_SOC_BIAS_PREPARE:
+		if (card->dapm.bias_level == SND_SOC_BIAS_STANDBY)
+
+			ret = mrfld_wm8958_set_clk_fmt(aif1_dai);
+		break;
+	default:
+		break;
+	}
+	pr_debug("%s card(%s)->bias_level %u\n", __func__, card->name,
+			card->dapm.bias_level);
+	return ret;
+}
+
+static int mrfld_8958_set_bias_level_post(struct snd_soc_card *card,
+		 struct snd_soc_dapm_context *dapm,
+		 enum snd_soc_bias_level level)
+{
+	struct snd_soc_dai *aif1_dai = find_codec_dai(card, "wm8994-aif1");
+	struct mrfld_8958_mc_private *ctx = snd_soc_card_get_drvdata(card);
+	int ret = 0;
+
+	if (!aif1_dai)
+		return -ENODEV;
+
+	if (dapm->dev != aif1_dai->dev)
+		return 0;
+
+	switch (level) {
+	case SND_SOC_BIAS_STANDBY:
+		/* We are in stabdba down so */
+		/* Switch to 32KHz MCLK2 input clock for codec
+		 */
+		ret = mrfld_8958_set_codec_clk(card, CODEC_IN_MCLK2);
+		/* Turn off 19.2MHz soc osc clock */
+		set_soc_osc_clk0(ctx->osc_clk0_reg, false);
+		break;
+	default:
+		break;
+	}
+	card->dapm.bias_level = level;
+	pr_debug("%s card(%s)->bias_level %u\n", __func__, card->name,
+			card->dapm.bias_level);
+	return ret;
+}
+
+#define PMIC_ID_ADDR		0x00
+#define PMIC_CHIP_ID_A0_VAL	0xC0
+
+static int mrfld_8958_set_vflex_vsel(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+#define VFLEXCNT		0xAB
+#define VFLEXVSEL_5V		0x01
+#define VFLEXVSEL_B0_VSYS_PT	0x80	/* B0: Vsys pass-through */
+#define VFLEXVSEL_A0_4P5V	0x41	/* A0: 4.5V */
+
+	struct snd_soc_dapm_context *dapm = w->dapm;
+	struct snd_soc_card *card = dapm->card;
+	struct mrfld_8958_mc_private *ctx = snd_soc_card_get_drvdata(card);
+
+	u8 vflexvsel, pmic_id = ctx->pmic_id;
+	int retval = 0;
+
+	pr_debug("%s: ON? %d\n", __func__, SND_SOC_DAPM_EVENT_ON(event));
+
+	vflexvsel = (pmic_id == PMIC_CHIP_ID_A0_VAL) ? VFLEXVSEL_A0_4P5V : VFLEXVSEL_B0_VSYS_PT;
+	pr_debug("pmic_id %#x vflexvsel %#x\n", pmic_id,
+		SND_SOC_DAPM_EVENT_ON(event) ? VFLEXVSEL_5V : vflexvsel);
+
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		retval = intel_scu_ipc_iowrite8(VFLEXCNT, VFLEXVSEL_5V);
+	else if (SND_SOC_DAPM_EVENT_OFF(event))
+		retval = intel_scu_ipc_iowrite8(VFLEXCNT, vflexvsel);
+	if (retval)
+		pr_err("Error writing to VFLEXCNT register\n");
+
+	return retval;
+}
+
+static const struct snd_soc_dapm_widget widgets[] = {
+	SND_SOC_DAPM_HP("Headphones", NULL),
+	SND_SOC_DAPM_MIC("AMIC", NULL),
+	SND_SOC_DAPM_MIC("DMIC", NULL),
+	SND_SOC_DAPM_SUPPLY("VFLEXCNT", SND_SOC_NOPM, 0, 0,
+			mrfld_8958_set_vflex_vsel,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+};
+
+static const struct snd_soc_dapm_route map[] = {
+	{ "Headphones", NULL, "HPOUT1L" },
+	{ "Headphones", NULL, "HPOUT1R" },
+
+	/* saltbay uses 2 DMICs, other configs may use more so change below
+	 * accordingly
+	 */
+	{ "DMIC1DAT", NULL, "DMIC" },
+	{ "DMIC2DAT", NULL, "DMIC" },
+	/*{ "DMIC3DAT", NULL, "DMIC" },*/
+	/*{ "DMIC4DAT", NULL, "DMIC" },*/
+
+	/* MICBIAS2 is connected as Bias for AMIC so we link it
+	 * here. Also AMIC wires up to IN1LP pin.
+	 * DMIC is externally connected to 1.8V rail, so no link rqd.
+	 */
+	{ "AMIC", NULL, "MICBIAS2" },
+	{ "IN1LP", NULL, "AMIC" },
+
+	/* SWM map link the SWM outs to codec AIF */
+	{ "AIF1 Playback", NULL, "codec_out0"  },
+	{ "AIF1 Playback", NULL, "codec_out1"  },
+	{ "codec_in0", NULL, "AIF1 Capture" },
+	{ "codec_in1", NULL, "AIF1 Capture" },
+
+	{ "AIF1 Playback", NULL, "VFLEXCNT" },
+	{ "AIF1 Capture", NULL, "VFLEXCNT" },
+};
+
+static const struct wm8958_micd_rate micdet_rates[] = {
+	{ 32768,       true,  1, 4 },
+	{ 32768,       false, 1, 1 },
+	{ 44100 * 256, true,  7, 10 },
+	{ 44100 * 256, false, 7, 10 },
+};
+
+static void wm8958_custom_micd_set_rate(struct snd_soc_codec *codec)
+{
+	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
+	struct wm8994 *control = dev_get_drvdata(codec->dev->parent);
+	int best, i, sysclk, val;
+	bool idle;
+	const struct wm8958_micd_rate *rates;
+	int num_rates;
+
+	idle = !wm8994->jack_mic;
+
+	sysclk = snd_soc_read(codec, WM8994_CLOCKING_1);
+	if (sysclk & WM8994_SYSCLK_SRC)
+		sysclk = wm8994->aifclk[1];
+	else
+		sysclk = wm8994->aifclk[0];
+
+	if (control->pdata.micd_rates) {
+		rates = control->pdata.micd_rates;
+		num_rates = control->pdata.num_micd_rates;
+	} else {
+		rates = micdet_rates;
+		num_rates = ARRAY_SIZE(micdet_rates);
+	}
+
+	best = 0;
+	for (i = 0; i < num_rates; i++) {
+		if (rates[i].idle != idle)
+			continue;
+		if (abs(rates[i].sysclk - sysclk) <
+		    abs(rates[best].sysclk - sysclk))
+			best = i;
+		else if (rates[best].idle != idle)
+			best = i;
+	}
+
+	val = rates[best].start << WM8958_MICD_BIAS_STARTTIME_SHIFT
+		| rates[best].rate << WM8958_MICD_RATE_SHIFT;
+
+	dev_dbg(codec->dev, "MICD rate %d,%d for %dHz %s\n",
+		rates[best].start, rates[best].rate, sysclk,
+		idle ? "idle" : "active");
+
+	snd_soc_update_bits(codec, WM8958_MIC_DETECT_1,
+			    WM8958_MICD_BIAS_STARTTIME_MASK |
+			    WM8958_MICD_RATE_MASK, val);
+}
+
+static void wm8958_custom_mic_id(void *data, u16 status)
+{
+	struct snd_soc_codec *codec = data;
+	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
+
+	dev_dbg(codec->dev, "wm8958 custom mic id called with status %x\n",
+		status);
+
+	/* Either nothing present or just starting detection */
+	if (!(status & WM8958_MICD_STS)) {
+		/* If nothing present then clear our statuses */
+		dev_dbg(codec->dev, "Detected open circuit\n");
+
+		schedule_delayed_work(&wm8994->open_circuit_work,
+				      msecs_to_jiffies(2500));
+		return;
+	}
+
+	schedule_delayed_work(&wm8994->micd_set_custom_rate_work,
+		msecs_to_jiffies(wm8994->wm8994->pdata.micb_en_delay));
+
+	/* If the measurement is showing a high impedence we've got a
+	 * microphone.
+	 */
+	if (status & 0x600) {
+		dev_dbg(codec->dev, "Detected microphone\n");
+
+		wm8994->mic_detecting = false;
+		wm8994->jack_mic = true;
+
+		snd_soc_jack_report(wm8994->micdet[0].jack, SND_JACK_HEADSET,
+				    SND_JACK_HEADSET);
+	}
+
+
+	if (status & 0xfc) {
+		dev_dbg(codec->dev, "Detected headphone\n");
+
+		/* Partial inserts of headsets with complete insert
+		 * after an indeterminate amount of time require
+		 * continouous micdetect enabled (until open circuit
+		 * or headset is detected)
+		 * */
+		wm8994->mic_detecting = true;
+
+		snd_soc_jack_report(wm8994->micdet[0].jack, SND_JACK_HEADPHONE,
+				    SND_JACK_HEADSET);
+	}
+}
+
+static int mrfld_8958_init(struct snd_soc_pcm_runtime *runtime)
+{
+	int ret;
+	unsigned int fmt;
+	struct snd_soc_codec *codec;
+	struct snd_soc_card *card = runtime->card;
+	struct snd_soc_dai *aif1_dai = find_codec_dai(card, "wm8994-aif1");
+	struct mrfld_8958_mc_private *ctx = snd_soc_card_get_drvdata(card);
+
+	if (!aif1_dai)
+		return -ENODEV;
+
+	pr_debug("Entry %s\n", __func__);
+
+	ret = snd_soc_dai_set_tdm_slot(aif1_dai, 0, 0, 4, SNDRV_PCM_FORMAT_S24_LE);
+	if (ret < 0) {
+		pr_err("can't set codec pcm format %d\n", ret);
+		return ret;
+	}
+
+	/* WM8958 slave Mode */
+	fmt =   SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF
+		| SND_SOC_DAIFMT_CBS_CFS;
+	ret = snd_soc_dai_set_fmt(aif1_dai, fmt);
+	if (ret < 0) {
+		pr_err("can't set codec DAI configuration %d\n", ret);
+		return ret;
+	}
+
+	mrfld_8958_set_bias_level(card, &card->dapm, SND_SOC_BIAS_OFF);
+	card->dapm.idle_bias_off = true;
+
+	/* these pins are not used in SB config so mark as nc
+	 *
+	 * LINEOUT1, 2
+	 * IN1R
+	 * DMICDAT2
+	 */
+	snd_soc_dapm_nc_pin(&card->dapm, "DMIC2DAT");
+	snd_soc_dapm_nc_pin(&card->dapm, "LINEOUT1P");
+	snd_soc_dapm_nc_pin(&card->dapm, "LINEOUT1N");
+	snd_soc_dapm_nc_pin(&card->dapm, "LINEOUT2P");
+	snd_soc_dapm_nc_pin(&card->dapm, "LINEOUT2N");
+	snd_soc_dapm_nc_pin(&card->dapm, "IN1RN");
+	snd_soc_dapm_nc_pin(&card->dapm, "IN1RP");
+
+	snd_soc_dapm_sync(&card->dapm);
+
+	codec = mrfld_8958_get_codec(card);
+	if (!codec) {
+		pr_err("%s: we didnt find the codec pointer!\n", __func__);
+		return 0;
+	}
+
+	ctx->jack_retry = 0;
+	ret = snd_soc_jack_new(codec, "Intel MID Audio Jack",
+			       SND_JACK_HEADSET | SND_JACK_HEADPHONE |
+				SND_JACK_BTN_0 | SND_JACK_BTN_1,
+				&ctx->jack);
+	if (ret) {
+		pr_err("jack creation failed\n");
+		return ret;
+	}
+
+	snd_jack_set_key(ctx->jack.jack, SND_JACK_BTN_1, KEY_MEDIA);
+	snd_jack_set_key(ctx->jack.jack, SND_JACK_BTN_0, KEY_MEDIA);
+
+	wm8958_mic_detect(codec, &ctx->jack, NULL, NULL,
+			  wm8958_custom_mic_id, codec);
+
+	wm8958_micd_set_custom_rate(codec, wm8958_custom_micd_set_rate, codec);
+
+	snd_soc_update_bits(codec, WM8994_AIF1_DAC1_FILTERS_1, WM8994_AIF1DAC1_MUTE, 0);
+	snd_soc_update_bits(codec, WM8994_AIF1_DAC2_FILTERS_1, WM8994_AIF1DAC2_MUTE, 0);
+
+	/* Micbias1 is always off, so for pm optimizations make sure the micbias1
+	 * discharge bit is set to floating to avoid discharge in disable state
+	 */
+	snd_soc_update_bits(codec, WM8958_MICBIAS1, WM8958_MICB1_DISCH, 0);
+
+	return 0;
+}
+
+static unsigned int rates_8000_16000[] = {
+	8000,
+	16000,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_8000_16000 = {
+	.count = ARRAY_SIZE(rates_8000_16000),
+	.list  = rates_8000_16000,
+};
+static unsigned int rates_48000[] = {
+	48000,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_48000 = {
+	.count = ARRAY_SIZE(rates_48000),
+	.list  = rates_48000,
+};
+static int mrfld_8958_startup(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_hw_constraint_list(substream->runtime, 0,
+			SNDRV_PCM_HW_PARAM_RATE,
+			&constraints_48000);
+}
+
+static struct snd_soc_ops mrfld_8958_ops = {
+	.startup = mrfld_8958_startup,
+};
+static int mrfld_8958_8k_16k_startup(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_hw_constraint_list(substream->runtime, 0,
+			SNDRV_PCM_HW_PARAM_RATE,
+			&constraints_8000_16000);
+}
+
+static struct snd_soc_ops mrfld_8958_8k_16k_ops = {
+	.startup = mrfld_8958_8k_16k_startup,
+	.hw_params = mrfld_8958_hw_params,
+};
+
+static struct snd_soc_ops mrfld_8958_be_ssp2_ops = {
+	.hw_params = mrfld_8958_hw_params,
+};
+static struct snd_soc_compr_ops mrfld_compr_ops = {
+	.set_params = mrfld_wm8958_compr_set_params,
+};
+
+struct snd_soc_dai_link mrfld_8958_msic_dailink[] = {
+	[MERR_DPCM_AUDIO] = {
+		.name = "Merrifield Audio Port",
+		.stream_name = "Saltbay Audio",
+		.cpu_dai_name = "Headset-cpu-dai",
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.platform_name = "sst-platform",
+		.init = mrfld_8958_init,
+		.ignore_suspend = 1,
+		.dynamic = 1,
+		.ops = &mrfld_8958_ops,
+	},
+	[MERR_DPCM_DB] = {
+		.name = "Merrifield DB Audio Port",
+		.stream_name = "Deep Buffer Audio",
+		.cpu_dai_name = "Deepbuffer-cpu-dai",
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.platform_name = "sst-platform",
+		.init = mrfld_8958_init,
+		.ignore_suspend = 1,
+		.dynamic = 1,
+		.ops = &mrfld_8958_ops,
+	},
+	[MERR_DPCM_LL] = {
+		.name = "Merrifield LL Audio Port",
+		.stream_name = "Low Latency Audio",
+		.cpu_dai_name = "Lowlatency-cpu-dai",
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.platform_name = "sst-platform",
+		.init = mrfld_8958_init,
+		.ignore_suspend = 1,
+		.dynamic = 1,
+		.ops = &mrfld_8958_ops,
+	},
+	[MERR_DPCM_COMPR] = {
+		.name = "Merrifield Compress Port",
+		.stream_name = "Saltbay Compress",
+		.platform_name = "sst-platform",
+		.cpu_dai_name = "Compress-cpu-dai",
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.dynamic = 1,
+		.init = mrfld_8958_init,
+		.compr_ops = &mrfld_compr_ops,
+	},
+	[MERR_DPCM_VOIP] = {
+		.name = "Merrifield VOIP Port",
+		.stream_name = "Saltbay Voip",
+		.cpu_dai_name = "Voip-cpu-dai",
+		.platform_name = "sst-platform",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.init = NULL,
+		.ignore_suspend = 1,
+		.ops = &mrfld_8958_8k_16k_ops,
+		.dynamic = 1,
+	},
+	[MERR_DPCM_PROBE] = {
+		.name = "Merrifield Probe Port",
+		.stream_name = "Saltbay Probe",
+		.cpu_dai_name = "Probe-cpu-dai",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.platform_name = "sst-platform",
+		.playback_count = 8,
+		.capture_count = 8,
+	},
+	/* CODEC<->CODEC link */
+	{
+		.name = "Merrifield Codec-Loop Port",
+		.stream_name = "Saltbay Codec-Loop",
+		.cpu_dai_name = "snd-soc-dummy-dai",
+		.codec_dai_name = "wm8994-aif1",
+		.codec_name = "wm8994-codec",
+		.dai_fmt = SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF
+						| SND_SOC_DAIFMT_CBS_CFS,
+		.params = &mrfld_wm8958_dai_params,
+	},
+
+	/* back ends */
+	{
+		.name = "SSP2-Codec",
+		.be_id = 1,
+		.cpu_dai_name = "ssp2-codec",
+		.platform_name = "sst-platform",
+		.no_pcm = 1,
+		.codec_dai_name = "wm8994-aif1",
+		.codec_name = "wm8994-codec",
+		.be_hw_params_fixup = merr_codec_fixup,
+		.ignore_suspend = 1,
+		.ops = &mrfld_8958_be_ssp2_ops,
+	},
+	{
+		.name = "SSP1-BTFM",
+		.be_id = 2,
+		.cpu_dai_name = "snd-soc-dummy-dai",
+		.platform_name = "snd-soc-dummy",
+		.no_pcm = 1,
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.ignore_suspend = 1,
+	},
+	{
+		.name = "SSP0-Modem",
+		.be_id = 3,
+		.cpu_dai_name = "snd-soc-dummy-dai",
+		.platform_name = "snd-soc-dummy",
+		.no_pcm = 1,
+		.codec_name = "snd-soc-dummy",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.ignore_suspend = 1,
+	},
+};
+
+#ifdef CONFIG_PM_SLEEP
+static int snd_mrfld_8958_prepare(struct device *dev)
+{
+	pr_debug("In %s device name\n", __func__);
+	snd_soc_suspend(dev);
+	return 0;
+}
+
+static void snd_mrfld_8958_complete(struct device *dev)
+{
+	pr_debug("In %s\n", __func__);
+	snd_soc_resume(dev);
+	return;
+}
+
+static int snd_mrfld_8958_poweroff(struct device *dev)
+{
+	pr_debug("In %s\n", __func__);
+	snd_soc_poweroff(dev);
+	return 0;
+}
+#else
+#define snd_mrfld_8958_prepare NULL
+#define snd_mrfld_8958_complete NULL
+#define snd_mrfld_8958_poweroff NULL
+#endif
+
+/* SoC card */
+static struct snd_soc_card snd_soc_card_mrfld = {
+	.name = "wm8958-audio",
+	.dai_link = mrfld_8958_msic_dailink,
+	.num_links = ARRAY_SIZE(mrfld_8958_msic_dailink),
+	.set_bias_level = mrfld_8958_set_bias_level,
+	.set_bias_level_post = mrfld_8958_set_bias_level_post,
+	.dapm_widgets = widgets,
+	.num_dapm_widgets = ARRAY_SIZE(widgets),
+	.dapm_routes = map,
+	.num_dapm_routes = ARRAY_SIZE(map),
+};
+
+static int snd_mrfld_8958_mc_probe(struct platform_device *pdev)
+{
+	int ret_val = 0;
+	struct mrfld_8958_mc_private *drv;
+
+	pr_debug("Entry %s\n", __func__);
+
+	drv = kzalloc(sizeof(*drv), GFP_ATOMIC);
+	if (!drv) {
+		pr_err("allocation failed\n");
+		return -ENOMEM;
+	}
+
+	/* ioremap the register */
+	drv->osc_clk0_reg = devm_ioremap_nocache(&pdev->dev,
+					MERR_OSC_CLKOUT_CTRL0_REG_ADDR,
+					MERR_OSC_CLKOUT_CTRL0_REG_SIZE);
+	if (!drv->osc_clk0_reg) {
+		pr_err("osc clk0 ctrl ioremap failed\n");
+		ret_val = -1;
+		goto unalloc;
+	}
+
+	ret_val = intel_scu_ipc_ioread8(PMIC_ID_ADDR, &drv->pmic_id);
+	if (ret_val) {
+		pr_err("Error reading PMIC ID register\n");
+		goto unalloc;
+	}
+
+	/* register the soc card */
+	snd_soc_card_mrfld.dev = &pdev->dev;
+	snd_soc_card_set_drvdata(&snd_soc_card_mrfld, drv);
+	ret_val = snd_soc_register_card(&snd_soc_card_mrfld);
+	if (ret_val) {
+		pr_err("snd_soc_register_card failed %d\n", ret_val);
+		goto unalloc;
+	}
+	platform_set_drvdata(pdev, &snd_soc_card_mrfld);
+	pr_info("%s successful\n", __func__);
+	return ret_val;
+
+unalloc:
+	kfree(drv);
+	return ret_val;
+}
+
+static int snd_mrfld_8958_mc_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *soc_card = platform_get_drvdata(pdev);
+	struct mrfld_8958_mc_private *drv = snd_soc_card_get_drvdata(soc_card);
+
+	pr_debug("In %s\n", __func__);
+	kfree(drv);
+	snd_soc_card_set_drvdata(soc_card, NULL);
+	snd_soc_unregister_card(soc_card);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+const struct dev_pm_ops snd_mrfld_8958_mc_pm_ops = {
+	.prepare = snd_mrfld_8958_prepare,
+	.complete = snd_mrfld_8958_complete,
+	.poweroff = snd_mrfld_8958_poweroff,
+};
+
+static struct platform_driver snd_mrfld_8958_mc_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "mrfld_wm8958",
+		.pm = &snd_mrfld_8958_mc_pm_ops,
+	},
+	.probe = snd_mrfld_8958_mc_probe,
+	.remove = snd_mrfld_8958_mc_remove,
+};
+
+static int snd_mrfld_8958_driver_init(void)
+{
+	pr_info("Merrifield Machine Driver mrfld_wm8958 registerd\n");
+	return platform_driver_register(&snd_mrfld_8958_mc_driver);
+}
+
+static void snd_mrfld_8958_driver_exit(void)
+{
+	pr_debug("In %s\n", __func__);
+	platform_driver_unregister(&snd_mrfld_8958_mc_driver);
+}
+
+static int snd_mrfld_8958_rpmsg_probe(struct rpmsg_channel *rpdev)
+{
+	int ret = 0;
+
+	if (rpdev == NULL) {
+		pr_err("rpmsg channel not created\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	dev_info(&rpdev->dev, "Probed snd_mrfld wm8958 rpmsg device\n");
+
+	ret = snd_mrfld_8958_driver_init();
+
+out:
+	return ret;
+}
+
+static void snd_mrfld_8958_rpmsg_remove(struct rpmsg_channel *rpdev)
+{
+	snd_mrfld_8958_driver_exit();
+	dev_info(&rpdev->dev, "Removed snd_mrfld wm8958 rpmsg device\n");
+}
+
+static void snd_mrfld_8958_rpmsg_cb(struct rpmsg_channel *rpdev, void *data,
+				int len, void *priv, u32 src)
+{
+	dev_warn(&rpdev->dev, "unexpected, message\n");
+
+	print_hex_dump(KERN_DEBUG, __func__, DUMP_PREFIX_NONE, 16, 1,
+			data, len,  true);
+}
+
+static struct rpmsg_device_id snd_mrfld_8958_rpmsg_id_table[] = {
+	{ .name = "rpmsg_mrfld_wm8958_audio" },
+	{ },
+};
+MODULE_DEVICE_TABLE(rpmsg, snd_mrfld_8958_rpmsg_id_table);
+
+static struct rpmsg_driver snd_mrfld_8958_rpmsg = {
+	.drv.name	= KBUILD_MODNAME,
+	.drv.owner	= THIS_MODULE,
+	.id_table	= snd_mrfld_8958_rpmsg_id_table,
+	.probe		= snd_mrfld_8958_rpmsg_probe,
+	.callback	= snd_mrfld_8958_rpmsg_cb,
+	.remove		= snd_mrfld_8958_rpmsg_remove,
+};
+
+static int __init snd_mrfld_8958_rpmsg_init(void)
+{
+	return register_rpmsg_driver(&snd_mrfld_8958_rpmsg);
+}
+late_initcall(snd_mrfld_8958_rpmsg_init);
+
+static void __exit snd_mrfld_8958_rpmsg_exit(void)
+{
+	return unregister_rpmsg_driver(&snd_mrfld_8958_rpmsg);
+}
+module_exit(snd_mrfld_8958_rpmsg_exit);
+
+MODULE_DESCRIPTION("ASoC Intel(R) Merrifield MID Machine driver");
+MODULE_AUTHOR("Vinod Koul <vinod.koul@linux.intel.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:mrfld_wm8958");
diff --git a/sound/soc/intel/board/merr_saltbay_wm8958.c b/sound/soc/intel/board/merr_saltbay_wm8958.c
new file mode 100644
index 0000000..ef63154
--- /dev/null
+++ b/sound/soc/intel/board/merr_saltbay_wm8958.c
@@ -0,0 +1,887 @@
+/*
+ *  merr_saltbay_wm8958.c - ASoc Machine driver for Intel Merrfield MID platform
+ *
+ *  Copyright (C) 2013 Intel Corp
+ *  Author: Vinod Koul <vinod.koul@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/async.h>
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <asm/intel_scu_pmic.h>
+#include <asm/intel_mid_rpmsg.h>
+#include <asm/platform_mrfld_audio.h>
+#include <asm/intel_sst_mrfld.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/jack.h>
+#include <linux/input.h>
+#include <asm/intel-mid.h>
+
+#include <linux/mfd/wm8994/core.h>
+#include <linux/mfd/wm8994/registers.h>
+#include <linux/mfd/wm8994/pdata.h>
+#include "../../codecs/wm8994.h"
+
+/* Codec PLL output clk rate */
+#define CODEC_SYSCLK_RATE			24576000
+/* Input clock to codec at MCLK1 PIN */
+#define CODEC_IN_MCLK1_RATE			19200000
+/* Input clock to codec at MCLK2 PIN */
+#define CODEC_IN_MCLK2_RATE			32768
+/*  define to select between MCLK1 and MCLK2 input to codec as its clock */
+#define CODEC_IN_MCLK1				1
+#define CODEC_IN_MCLK2				2
+
+/* Register address for OSC Clock */
+#define MERR_OSC_CLKOUT_CTRL0_REG_ADDR  0xFF00BC04
+/* Size of osc clock register */
+#define MERR_OSC_CLKOUT_CTRL0_REG_SIZE  4
+
+struct mrfld_8958_mc_private {
+	struct snd_soc_jack jack;
+	int jack_retry;
+	u8 pmic_id;
+	void __iomem    *osc_clk0_reg;
+};
+
+
+/* set_osc_clk0-	enable/disables the osc clock0
+ * addr:		address of the register to write to
+ * enable:		bool to enable or disable the clock
+ */
+static inline void set_soc_osc_clk0(void __iomem *addr, bool enable)
+{
+	u32 osc_clk_ctrl;
+
+	osc_clk_ctrl = readl(addr);
+	if (enable)
+		osc_clk_ctrl |= BIT(31);
+	else
+		osc_clk_ctrl &= ~(BIT(31));
+
+	pr_debug("%s: enable:%d val 0x%x\n", __func__, enable, osc_clk_ctrl);
+
+	writel(osc_clk_ctrl, addr);
+}
+
+
+static inline struct snd_soc_codec *mrfld_8958_get_codec(struct snd_soc_card *card)
+{
+	bool found = false;
+	struct snd_soc_codec *codec;
+
+	list_for_each_entry(codec, &card->codec_dev_list, card_list) {
+		if (!strstr(codec->name, "wm8994-codec")) {
+			pr_debug("codec was %s", codec->name);
+			continue;
+		} else {
+			found = true;
+			break;
+		}
+	}
+	if (found == false) {
+		pr_err("%s: cant find codec", __func__);
+		return NULL;
+	}
+	return codec;
+}
+
+/* Function to switch the input clock for codec,  When audio is in
+ * progress input clock to codec will be through MCLK1 which is 19.2MHz
+ * while in off state input clock to codec will be through 32KHz through
+ * MCLK2
+ * card	: Sound card structure
+ * src	: Input clock source to codec
+ */
+static int mrfld_8958_set_codec_clk(struct snd_soc_card *card, int src)
+{
+	struct snd_soc_dai *aif1_dai = card->rtd[0].codec_dai;
+	int ret;
+
+	switch (src) {
+	case CODEC_IN_MCLK1:
+		/* Turn ON the PLL to generate required sysclk rate
+		 * from MCLK1 */
+		ret = snd_soc_dai_set_pll(aif1_dai,
+			WM8994_FLL1, WM8994_FLL_SRC_MCLK1,
+			CODEC_IN_MCLK1_RATE, CODEC_SYSCLK_RATE);
+		if (ret < 0) {
+			pr_err("Failed to start FLL: %d\n", ret);
+			return ret;
+		}
+		/* Switch to MCLK1 input */
+		ret = snd_soc_dai_set_sysclk(aif1_dai, WM8994_SYSCLK_FLL1,
+				CODEC_SYSCLK_RATE, SND_SOC_CLOCK_IN);
+		if (ret < 0) {
+			pr_err("Failed to set codec sysclk configuration %d\n",
+				 ret);
+			return ret;
+		}
+		break;
+	case CODEC_IN_MCLK2:
+		/* Switch to MCLK2 */
+		ret = snd_soc_dai_set_sysclk(aif1_dai, WM8994_SYSCLK_MCLK2,
+				32768, SND_SOC_CLOCK_IN);
+		if (ret < 0) {
+			pr_err("Failed to switch to MCLK2: %d", ret);
+			return ret;
+		}
+		/* Turn off PLL for MCLK1 */
+		ret = snd_soc_dai_set_pll(aif1_dai, WM8994_FLL1, 0, 0, 0);
+		if (ret < 0) {
+			pr_err("Failed to stop the FLL: %d", ret);
+			return ret;
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int mrfld_wm8958_set_clk_fmt(struct snd_soc_dai *codec_dai)
+{
+	unsigned int fmt;
+	int ret = 0;
+	struct snd_soc_card *card = codec_dai->card;
+	struct mrfld_8958_mc_private *ctx = snd_soc_card_get_drvdata(card);
+
+	/* Enable the osc clock at start so that it gets settling time */
+	set_soc_osc_clk0(ctx->osc_clk0_reg, true);
+
+	ret = snd_soc_dai_set_tdm_slot(codec_dai, 0, 0, 4, SNDRV_PCM_FORMAT_S24_LE);
+	if (ret < 0) {
+		pr_err("can't set codec pcm format %d\n", ret);
+		return ret;
+	}
+
+	/* WM8958 slave Mode */
+	fmt =   SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF
+		| SND_SOC_DAIFMT_CBS_CFS;
+	ret = snd_soc_dai_set_fmt(codec_dai, fmt);
+	if (ret < 0) {
+		pr_err("can't set codec DAI configuration %d\n", ret);
+		return ret;
+	}
+
+	/* FIXME: move this to SYS_CLOCK event handler when codec driver
+	 * dependency is clean.
+	 */
+	/* Switch to 19.2MHz MCLK1 input clock for codec */
+	ret = mrfld_8958_set_codec_clk(card, CODEC_IN_MCLK1);
+
+	return ret;
+}
+
+static int mrfld_8958_hw_params(struct snd_pcm_substream *substream,
+			   struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+
+	return mrfld_wm8958_set_clk_fmt(codec_dai);
+}
+
+static int mrfld_wm8958_compr_set_params(struct snd_compr_stream *cstream)
+{
+	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+
+	return mrfld_wm8958_set_clk_fmt(codec_dai);
+}
+static int mrfld_8958_set_bias_level(struct snd_soc_card *card,
+		struct snd_soc_dapm_context *dapm,
+		enum snd_soc_bias_level level)
+{
+	struct snd_soc_dai *aif1_dai = card->rtd[0].codec_dai;
+	int ret = 0;
+
+	if (dapm->dev != aif1_dai->dev)
+		return 0;
+	switch (level) {
+	case SND_SOC_BIAS_PREPARE:
+		if (card->dapm.bias_level == SND_SOC_BIAS_STANDBY)
+
+			ret = mrfld_wm8958_set_clk_fmt(aif1_dai);
+		break;
+	default:
+		break;
+	}
+	pr_debug("%s card(%s)->bias_level %u\n", __func__, card->name,
+			card->dapm.bias_level);
+	return ret;
+}
+static int mrfld_8958_set_bias_level_post(struct snd_soc_card *card,
+		 struct snd_soc_dapm_context *dapm,
+		 enum snd_soc_bias_level level)
+{
+	struct snd_soc_dai *aif1_dai = card->rtd[0].codec_dai;
+	struct mrfld_8958_mc_private *ctx = snd_soc_card_get_drvdata(card);
+	int ret = 0;
+
+	if (dapm->dev != aif1_dai->dev)
+		return 0;
+
+	switch (level) {
+	case SND_SOC_BIAS_STANDBY:
+		/* We are in stabdba down so */
+		/* Switch to 32KHz MCLK2 input clock for codec
+		 */
+		ret = mrfld_8958_set_codec_clk(card, CODEC_IN_MCLK2);
+		/* Turn off 19.2MHz soc osc clock */
+		set_soc_osc_clk0(ctx->osc_clk0_reg, false);
+		break;
+	default:
+		break;
+	}
+	card->dapm.bias_level = level;
+	pr_debug("%s card(%s)->bias_level %u\n", __func__, card->name,
+			card->dapm.bias_level);
+	return ret;
+}
+
+#define PMIC_ID_ADDR		0x00
+#define PMIC_CHIP_ID_A0_VAL	0xC0
+
+static int mrfld_8958_set_vflex_vsel(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+#define VFLEXCNT		0xAB
+#define VFLEXVSEL_5V		0x01
+#define VFLEXVSEL_B0_VSYS_PT	0x80	/* B0: Vsys pass-through */
+#define VFLEXVSEL_A0_4P5V	0x41	/* A0: 4.5V */
+
+	struct snd_soc_dapm_context *dapm = w->dapm;
+	struct snd_soc_card *card = dapm->card;
+	struct mrfld_8958_mc_private *ctx = snd_soc_card_get_drvdata(card);
+
+	u8 vflexvsel, pmic_id = ctx->pmic_id;
+	int retval = 0;
+
+	pr_debug("%s: ON? %d\n", __func__, SND_SOC_DAPM_EVENT_ON(event));
+
+	vflexvsel = (pmic_id == PMIC_CHIP_ID_A0_VAL) ? VFLEXVSEL_A0_4P5V : VFLEXVSEL_B0_VSYS_PT;
+	pr_debug("pmic_id %#x vflexvsel %#x\n", pmic_id,
+		SND_SOC_DAPM_EVENT_ON(event) ? VFLEXVSEL_5V : vflexvsel);
+
+	/*FIXME: seems to be issue with bypass mode in MOOR, for now
+		force the bias off volate as VFLEXVSEL_5V */
+	if ((INTEL_MID_BOARD(1, PHONE, MOFD)) ||
+			(INTEL_MID_BOARD(1, TABLET, MOFD)))
+		vflexvsel = VFLEXVSEL_5V;
+
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		retval = intel_scu_ipc_iowrite8(VFLEXCNT, VFLEXVSEL_5V);
+	else if (SND_SOC_DAPM_EVENT_OFF(event))
+		retval = intel_scu_ipc_iowrite8(VFLEXCNT, vflexvsel);
+	if (retval)
+		pr_err("Error writing to VFLEXCNT register\n");
+
+	return retval;
+}
+
+static const struct snd_soc_dapm_widget widgets[] = {
+	SND_SOC_DAPM_HP("Headphones", NULL),
+	SND_SOC_DAPM_MIC("AMIC", NULL),
+	SND_SOC_DAPM_MIC("DMIC", NULL),
+	SND_SOC_DAPM_SUPPLY("VFLEXCNT", SND_SOC_NOPM, 0, 0,
+			mrfld_8958_set_vflex_vsel,
+			SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+};
+
+static const struct snd_soc_dapm_route map[] = {
+	{ "Headphones", NULL, "HPOUT1L" },
+	{ "Headphones", NULL, "HPOUT1R" },
+
+	/* saltbay uses 2 DMICs, other configs may use more so change below
+	 * accordingly
+	 */
+	{ "DMIC1DAT", NULL, "DMIC" },
+	{ "DMIC2DAT", NULL, "DMIC" },
+	/*{ "DMIC3DAT", NULL, "DMIC" },*/
+	/*{ "DMIC4DAT", NULL, "DMIC" },*/
+
+	/* MICBIAS2 is connected as Bias for AMIC so we link it
+	 * here. Also AMIC wires up to IN1LP pin.
+	 * DMIC is externally connected to 1.8V rail, so no link rqd.
+	 */
+	{ "AMIC", NULL, "MICBIAS2" },
+	{ "IN1LP", NULL, "AMIC" },
+
+	/* SWM map link the SWM outs to codec AIF */
+	{ "AIF1DAC1L", NULL, "Codec OUT0"  },
+	{ "AIF1DAC1R", NULL, "Codec OUT0"  },
+	{ "AIF1DAC2L", NULL, "Codec OUT1"  },
+	{ "AIF1DAC2R", NULL, "Codec OUT1"  },
+	{ "Codec IN0", NULL, "AIF1ADC1L" },
+	{ "Codec IN0", NULL, "AIF1ADC1R" },
+	{ "Codec IN1", NULL, "AIF1ADC1L" },
+	{ "Codec IN1", NULL, "AIF1ADC1R" },
+
+	{ "AIF1DAC1L", NULL, "VFLEXCNT" },
+	{ "AIF1DAC1R", NULL, "VFLEXCNT" },
+	{ "AIF1DAC2L", NULL, "VFLEXCNT" },
+	{ "AIF1DAC2R", NULL, "VFLEXCNT" },
+
+	{ "AIF1ADC1L", NULL, "VFLEXCNT" },
+	{ "AIF1ADC1R", NULL, "VFLEXCNT" },
+
+};
+
+static const struct wm8958_micd_rate micdet_rates[] = {
+	{ 32768,       true,  1, 4 },
+	{ 32768,       false, 1, 1 },
+	{ 44100 * 256, true,  7, 10 },
+	{ 44100 * 256, false, 7, 10 },
+};
+
+static void wm8958_custom_micd_set_rate(struct snd_soc_codec *codec)
+{
+	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
+	struct wm8994 *control = dev_get_drvdata(codec->dev->parent);
+	int best, i, sysclk, val;
+	bool idle;
+	const struct wm8958_micd_rate *rates;
+	int num_rates;
+
+	idle = !wm8994->jack_mic;
+
+	sysclk = snd_soc_read(codec, WM8994_CLOCKING_1);
+	if (sysclk & WM8994_SYSCLK_SRC)
+		sysclk = wm8994->aifclk[1];
+	else
+		sysclk = wm8994->aifclk[0];
+
+	if (control->pdata.micd_rates) {
+		rates = control->pdata.micd_rates;
+		num_rates = control->pdata.num_micd_rates;
+	} else {
+		rates = micdet_rates;
+		num_rates = ARRAY_SIZE(micdet_rates);
+	}
+
+	best = 0;
+	for (i = 0; i < num_rates; i++) {
+		if (rates[i].idle != idle)
+			continue;
+		if (abs(rates[i].sysclk - sysclk) <
+		    abs(rates[best].sysclk - sysclk))
+			best = i;
+		else if (rates[best].idle != idle)
+			best = i;
+	}
+
+	val = rates[best].start << WM8958_MICD_BIAS_STARTTIME_SHIFT
+		| rates[best].rate << WM8958_MICD_RATE_SHIFT;
+
+	dev_dbg(codec->dev, "MICD rate %d,%d for %dHz %s\n",
+		rates[best].start, rates[best].rate, sysclk,
+		idle ? "idle" : "active");
+
+	snd_soc_update_bits(codec, WM8958_MIC_DETECT_1,
+			    WM8958_MICD_BIAS_STARTTIME_MASK |
+			    WM8958_MICD_RATE_MASK, val);
+}
+
+static void wm8958_custom_mic_id(void *data, u16 status)
+{
+	struct snd_soc_codec *codec = data;
+	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
+
+	dev_dbg(codec->dev, "wm8958 custom mic id called with status %x\n",
+		status);
+
+	/* Either nothing present or just starting detection */
+	if (!(status & WM8958_MICD_STS)) {
+		/* If nothing present then clear our statuses */
+		dev_dbg(codec->dev, "Detected open circuit\n");
+
+		schedule_delayed_work(&wm8994->open_circuit_work,
+				      msecs_to_jiffies(2500));
+		return;
+	}
+
+	schedule_delayed_work(&wm8994->micd_set_custom_rate_work,
+		msecs_to_jiffies(wm8994->wm8994->pdata.micb_en_delay));
+
+	/* If the measurement is showing a high impedence we've got a
+	 * microphone.
+	 */
+	if (status & 0x600) {
+		dev_dbg(codec->dev, "Detected microphone\n");
+
+		wm8994->mic_detecting = false;
+		wm8994->jack_mic = true;
+		wm8994->headphone_detected = false;
+
+		snd_soc_jack_report(wm8994->micdet[0].jack, SND_JACK_HEADSET,
+				    SND_JACK_HEADSET);
+	}
+
+
+	if (status & 0xfc) {
+		dev_dbg(codec->dev, "Detected headphone\n");
+
+		/* Partial inserts of headsets with complete insert
+		 * after an indeterminate amount of time require
+		 * continouous micdetect enabled (until open circuit
+		 * or headset is detected)
+		 * */
+		wm8994->mic_detecting = true;
+
+		wm8994->jack_mic = false;
+		wm8994->headphone_detected = true;
+
+		snd_soc_jack_report(wm8994->micdet[0].jack, SND_JACK_HEADPHONE,
+				    SND_JACK_HEADSET);
+	}
+}
+
+static int mrfld_8958_init(struct snd_soc_pcm_runtime *runtime)
+{
+	int ret;
+	unsigned int fmt;
+	struct snd_soc_codec *codec = runtime->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+	struct snd_soc_card *card = runtime->card;
+	struct snd_soc_dai *aif1_dai = card->rtd[0].codec_dai;
+	struct mrfld_8958_mc_private *ctx = snd_soc_card_get_drvdata(card);
+
+	pr_debug("Entry %s\n", __func__);
+
+	ret = snd_soc_dai_set_tdm_slot(aif1_dai, 0, 0, 4, SNDRV_PCM_FORMAT_S24_LE);
+	if (ret < 0) {
+		pr_err("can't set codec pcm format %d\n", ret);
+		return ret;
+	}
+
+	/* WM8958 slave Mode */
+	fmt =   SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_IB_NF
+		| SND_SOC_DAIFMT_CBS_CFS;
+	ret = snd_soc_dai_set_fmt(aif1_dai, fmt);
+	if (ret < 0) {
+		pr_err("can't set codec DAI configuration %d\n", ret);
+		return ret;
+	}
+
+	mrfld_8958_set_bias_level(card, dapm, SND_SOC_BIAS_OFF);
+	card->dapm.idle_bias_off = true;
+
+	/* these pins are not used in SB config so mark as nc
+	 *
+	 * LINEOUT1, 2
+	 * IN1R
+	 * DMICDAT2
+	 */
+	snd_soc_dapm_nc_pin(dapm, "DMIC2DAT");
+	snd_soc_dapm_nc_pin(dapm, "LINEOUT1P");
+	snd_soc_dapm_nc_pin(dapm, "LINEOUT1N");
+	snd_soc_dapm_nc_pin(dapm, "LINEOUT2P");
+	snd_soc_dapm_nc_pin(dapm, "LINEOUT2N");
+	snd_soc_dapm_nc_pin(dapm, "IN1RN");
+	snd_soc_dapm_nc_pin(dapm, "IN1RP");
+
+	/* Force enable VMID to avoid cold latency constraints */
+	snd_soc_dapm_force_enable_pin(dapm, "VMID");
+	snd_soc_dapm_sync(dapm);
+
+	ctx->jack_retry = 0;
+	ret = snd_soc_jack_new(codec, "Intel MID Audio Jack",
+			       SND_JACK_HEADSET | SND_JACK_HEADPHONE |
+				SND_JACK_BTN_0 | SND_JACK_BTN_1,
+				&ctx->jack);
+	if (ret) {
+		pr_err("jack creation failed\n");
+		return ret;
+	}
+
+	snd_jack_set_key(ctx->jack.jack, SND_JACK_BTN_1, KEY_MEDIA);
+	snd_jack_set_key(ctx->jack.jack, SND_JACK_BTN_0, KEY_MEDIA);
+
+	wm8958_mic_detect(codec, &ctx->jack, NULL, NULL,
+			  wm8958_custom_mic_id, codec);
+
+	wm8958_micd_set_custom_rate(codec, wm8958_custom_micd_set_rate, codec);
+
+	snd_soc_update_bits(codec, WM8994_AIF1_DAC1_FILTERS_1, WM8994_AIF1DAC1_MUTE, 0);
+	snd_soc_update_bits(codec, WM8994_AIF1_DAC2_FILTERS_1, WM8994_AIF1DAC2_MUTE, 0);
+
+	/* Micbias1 is always off, so for pm optimizations make sure the micbias1
+	 * discharge bit is set to floating to avoid discharge in disable state
+	 */
+	snd_soc_update_bits(codec, WM8958_MICBIAS1, WM8958_MICB1_DISCH, 0);
+
+	return 0;
+}
+
+static unsigned int rates_8000_16000[] = {
+	8000,
+	16000,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_8000_16000 = {
+	.count = ARRAY_SIZE(rates_8000_16000),
+	.list  = rates_8000_16000,
+};
+
+static unsigned int rates_48000[] = {
+	48000,
+};
+
+static struct snd_pcm_hw_constraint_list constraints_48000 = {
+	.count = ARRAY_SIZE(rates_48000),
+	.list  = rates_48000,
+};
+
+static int mrfld_8958_startup(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_hw_constraint_list(substream->runtime, 0,
+			SNDRV_PCM_HW_PARAM_RATE,
+			&constraints_48000);
+}
+
+static struct snd_soc_ops mrfld_8958_ops = {
+	.startup = mrfld_8958_startup,
+	.hw_params = mrfld_8958_hw_params,
+};
+
+static int mrfld_8958_8k_16k_startup(struct snd_pcm_substream *substream)
+{
+	return snd_pcm_hw_constraint_list(substream->runtime, 0,
+			SNDRV_PCM_HW_PARAM_RATE,
+			&constraints_8000_16000);
+}
+
+static struct snd_soc_ops mrfld_8958_8k_16k_ops = {
+	.startup = mrfld_8958_8k_16k_startup,
+	.hw_params = mrfld_8958_hw_params,
+};
+
+static struct snd_soc_compr_ops mrfld_compr_ops = {
+	.set_params = mrfld_wm8958_compr_set_params,
+};
+
+struct snd_soc_dai_link mrfld_8958_msic_dailink[] = {
+	[MERR_SALTBAY_AUDIO] = {
+		.name = "Merrifield Audio Port",
+		.stream_name = "Audio",
+		.cpu_dai_name = "Headset-cpu-dai",
+		.codec_dai_name = "wm8994-aif1",
+		.codec_name = "wm8994-codec",
+		.platform_name = "sst-platform",
+		.init = mrfld_8958_init,
+		.ignore_suspend = 1,
+		.ops = &mrfld_8958_ops,
+		.playback_count = 3,
+	},
+	[MERR_SALTBAY_COMPR] = {
+		.name = "Merrifield Compress Port",
+		.stream_name = "Compress",
+		.platform_name = "sst-platform",
+		.cpu_dai_name = "Compress-cpu-dai",
+		.codec_dai_name = "wm8994-aif1",
+		.codec_name = "wm8994-codec",
+		.compr_ops = &mrfld_compr_ops,
+	},
+	[MERR_SALTBAY_VOIP] = {
+		.name = "Merrifield VOIP Port",
+		.stream_name = "Voip",
+		.cpu_dai_name = "Voip-cpu-dai",
+		.codec_dai_name = "wm8994-aif1",
+		.codec_name = "wm8994-codec",
+		.platform_name = "sst-platform",
+		.init = NULL,
+		.ignore_suspend = 1,
+		.ops = &mrfld_8958_8k_16k_ops,
+	},
+	[MERR_SALTBAY_PROBE] = {
+		.name = "Merrifield Probe Port",
+		.stream_name = "Probe",
+		.cpu_dai_name = "Probe-cpu-dai",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+		.platform_name = "sst-platform",
+		.playback_count = 8,
+		.capture_count = 8,
+	},
+	[MERR_SALTBAY_AWARE] = {
+		.name = "Merrifield Aware Port",
+		.stream_name = "Aware",
+		.cpu_dai_name = "Loopback-cpu-dai",
+		.codec_dai_name = "wm8994-aif1",
+		.codec_name = "wm8994-codec",
+		.platform_name = "sst-platform",
+		.init = NULL,
+		.ignore_suspend = 1,
+		.ops = &mrfld_8958_8k_16k_ops,
+	},
+	[MERR_SALTBAY_VAD] = {
+		.name = "Merrifield VAD Port",
+		.stream_name = "Vad",
+		.cpu_dai_name = "Loopback-cpu-dai",
+		.codec_dai_name = "wm8994-aif1",
+		.codec_name = "wm8994-codec",
+		.platform_name = "sst-platform",
+		.init = NULL,
+		.ignore_suspend = 1,
+		.ops = &mrfld_8958_8k_16k_ops,
+	},
+	[MERR_SALTBAY_POWER] = {
+		.name = "Virtual Power Port",
+		.stream_name = "Power",
+		.cpu_dai_name = "Power-cpu-dai",
+		.platform_name = "sst-platform",
+		.codec_dai_name = "snd-soc-dummy-dai",
+		.codec_name = "snd-soc-dummy",
+	},
+};
+
+#ifdef CONFIG_PM_SLEEP
+static int snd_mrfld_8958_prepare(struct device *dev)
+{
+	struct snd_soc_card *card = dev_get_drvdata(dev);
+	struct snd_soc_codec *codec;
+	struct snd_soc_dapm_context *dapm;
+
+	pr_debug("In %s\n", __func__);
+
+	codec = mrfld_8958_get_codec(card);
+	if (!codec) {
+		pr_err("%s: couldn't find the codec pointer!\n", __func__);
+		return -EAGAIN;
+	}
+
+	pr_debug("found codec %s\n", codec->name);
+	dapm = &codec->dapm;
+
+	snd_soc_dapm_disable_pin(dapm, "VMID");
+	snd_soc_dapm_sync(dapm);
+
+	snd_soc_suspend(dev);
+	return 0;
+}
+
+static void snd_mrfld_8958_complete(struct device *dev)
+{
+	struct snd_soc_card *card = dev_get_drvdata(dev);
+	struct snd_soc_codec *codec;
+	struct snd_soc_dapm_context *dapm;
+
+	pr_debug("In %s\n", __func__);
+
+	codec = mrfld_8958_get_codec(card);
+	if (!codec) {
+		pr_err("%s: couldn't find the codec pointer!\n", __func__);
+		return;
+	}
+
+	pr_debug("found codec %s\n", codec->name);
+	dapm = &codec->dapm;
+
+	snd_soc_dapm_force_enable_pin(dapm, "VMID");
+	snd_soc_dapm_sync(dapm);
+
+	snd_soc_resume(dev);
+	return;
+}
+
+static int snd_mrfld_8958_poweroff(struct device *dev)
+{
+	pr_debug("In %s\n", __func__);
+	snd_soc_poweroff(dev);
+	return 0;
+}
+#else
+#define snd_mrfld_8958_prepare NULL
+#define snd_mrfld_8958_complete NULL
+#define snd_mrfld_8958_poweroff NULL
+#endif
+
+/* SoC card */
+static struct snd_soc_card snd_soc_card_mrfld = {
+	.name = "wm8958-audio",
+	.dai_link = mrfld_8958_msic_dailink,
+	.num_links = ARRAY_SIZE(mrfld_8958_msic_dailink),
+	.set_bias_level = mrfld_8958_set_bias_level,
+	.set_bias_level_post = mrfld_8958_set_bias_level_post,
+	.dapm_widgets = widgets,
+	.num_dapm_widgets = ARRAY_SIZE(widgets),
+	.dapm_routes = map,
+	.num_dapm_routes = ARRAY_SIZE(map),
+};
+
+static int snd_mrfld_8958_mc_probe(struct platform_device *pdev)
+{
+	int ret_val = 0;
+	struct mrfld_8958_mc_private *drv;
+
+	pr_debug("Entry %s\n", __func__);
+
+	drv = kzalloc(sizeof(*drv), GFP_ATOMIC);
+	if (!drv) {
+		pr_err("allocation failed\n");
+		return -ENOMEM;
+	}
+
+	/* ioremap the register */
+	drv->osc_clk0_reg = devm_ioremap_nocache(&pdev->dev,
+					MERR_OSC_CLKOUT_CTRL0_REG_ADDR,
+					MERR_OSC_CLKOUT_CTRL0_REG_SIZE);
+	if (!drv->osc_clk0_reg) {
+		pr_err("osc clk0 ctrl ioremap failed\n");
+		ret_val = -1;
+		goto unalloc;
+	}
+
+	ret_val = intel_scu_ipc_ioread8(PMIC_ID_ADDR, &drv->pmic_id);
+	if (ret_val) {
+		pr_err("Error reading PMIC ID register\n");
+		goto unalloc;
+	}
+
+	/* register the soc card */
+	snd_soc_card_mrfld.dev = &pdev->dev;
+	snd_soc_card_set_drvdata(&snd_soc_card_mrfld, drv);
+	ret_val = snd_soc_register_card(&snd_soc_card_mrfld);
+	if (ret_val) {
+		pr_err("snd_soc_register_card failed %d\n", ret_val);
+		goto unalloc;
+	}
+	platform_set_drvdata(pdev, &snd_soc_card_mrfld);
+	pr_info("%s successful\n", __func__);
+	return ret_val;
+
+unalloc:
+	kfree(drv);
+	return ret_val;
+}
+
+static int snd_mrfld_8958_mc_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *soc_card = platform_get_drvdata(pdev);
+	struct mrfld_8958_mc_private *drv = snd_soc_card_get_drvdata(soc_card);
+
+	pr_debug("In %s\n", __func__);
+	kfree(drv);
+	snd_soc_card_set_drvdata(soc_card, NULL);
+	snd_soc_unregister_card(soc_card);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+const struct dev_pm_ops snd_mrfld_8958_mc_pm_ops = {
+	.prepare = snd_mrfld_8958_prepare,
+	.complete = snd_mrfld_8958_complete,
+	.poweroff = snd_mrfld_8958_poweroff,
+};
+
+static struct platform_driver snd_mrfld_8958_mc_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "mrfld_wm8958",
+		.pm = &snd_mrfld_8958_mc_pm_ops,
+	},
+	.probe = snd_mrfld_8958_mc_probe,
+	.remove = snd_mrfld_8958_mc_remove,
+};
+
+static int snd_mrfld_8958_driver_init(void)
+{
+	pr_info("Merrifield Machine Driver mrfld_wm8958 registerd\n");
+	return platform_driver_register(&snd_mrfld_8958_mc_driver);
+}
+
+static void snd_mrfld_8958_driver_exit(void)
+{
+	pr_debug("In %s\n", __func__);
+	platform_driver_unregister(&snd_mrfld_8958_mc_driver);
+}
+
+static int snd_mrfld_8958_rpmsg_probe(struct rpmsg_channel *rpdev)
+{
+	int ret = 0;
+
+	if (rpdev == NULL) {
+		pr_err("rpmsg channel not created\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	dev_info(&rpdev->dev, "Probed snd_mrfld wm8958 rpmsg device\n");
+
+	ret = snd_mrfld_8958_driver_init();
+
+out:
+	return ret;
+}
+
+static void snd_mrfld_8958_rpmsg_remove(struct rpmsg_channel *rpdev)
+{
+	snd_mrfld_8958_driver_exit();
+	dev_info(&rpdev->dev, "Removed snd_mrfld wm8958 rpmsg device\n");
+}
+
+static void snd_mrfld_8958_rpmsg_cb(struct rpmsg_channel *rpdev, void *data,
+				int len, void *priv, u32 src)
+{
+	dev_warn(&rpdev->dev, "unexpected, message\n");
+
+	print_hex_dump(KERN_DEBUG, __func__, DUMP_PREFIX_NONE, 16, 1,
+			data, len,  true);
+}
+
+static struct rpmsg_device_id snd_mrfld_8958_rpmsg_id_table[] = {
+	{ .name = "rpmsg_mrfld_wm8958_audio" },
+	{ },
+};
+MODULE_DEVICE_TABLE(rpmsg, snd_mrfld_8958_rpmsg_id_table);
+
+static struct rpmsg_driver snd_mrfld_8958_rpmsg = {
+	.drv.name	= KBUILD_MODNAME,
+	.drv.owner	= THIS_MODULE,
+	.id_table	= snd_mrfld_8958_rpmsg_id_table,
+	.probe		= snd_mrfld_8958_rpmsg_probe,
+	.callback	= snd_mrfld_8958_rpmsg_cb,
+	.remove		= snd_mrfld_8958_rpmsg_remove,
+};
+
+static int __init snd_mrfld_8958_rpmsg_init(void)
+{
+	return register_rpmsg_driver(&snd_mrfld_8958_rpmsg);
+}
+late_initcall(snd_mrfld_8958_rpmsg_init);
+
+static void __exit snd_mrfld_8958_rpmsg_exit(void)
+{
+	return unregister_rpmsg_driver(&snd_mrfld_8958_rpmsg);
+}
+module_exit(snd_mrfld_8958_rpmsg_exit);
+
+MODULE_DESCRIPTION("ASoC Intel(R) Merrifield MID Machine driver");
+MODULE_AUTHOR("Vinod Koul <vinod.koul@linux.intel.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:mrfld_wm8958");
diff --git a/sound/soc/intel/compress.c b/sound/soc/intel/compress.c
new file mode 100644
index 0000000..f067468
--- /dev/null
+++ b/sound/soc/intel/compress.c
@@ -0,0 +1,254 @@
+/*
+ *  compress.c - Intel MID Platform driver for Compress stream operations
+ *
+ *  Copyright (C) 2010-2013 Intel Corp
+ *  Author: Vinod Koul <vinod.koul@intel.com>
+ *  Author: Harsha Priya <priya.harsha@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <sound/soc.h>
+#include <sound/intel_sst_ioctl.h>
+#include "platform_ipc_v2.h"
+#include "sst_platform.h"
+#include "sst_platform_pvt.h"
+
+static void sst_compr_fragment_elapsed(void *arg)
+{
+	struct snd_compr_stream *cstream = (struct snd_compr_stream *)arg;
+
+	pr_debug("fragment elapsed by driver\n");
+	if (cstream)
+		snd_compr_fragment_elapsed(cstream);
+}
+
+static void sst_drain_notify(void *arg)
+{
+	struct snd_compr_stream *cstream = (struct snd_compr_stream *)arg;
+
+	pr_debug("drain notify by driver\n");
+	if (cstream)
+		snd_compr_drain_notify(cstream);
+}
+
+static int sst_platform_compr_open(struct snd_compr_stream *cstream)
+{
+
+	int ret_val = 0;
+	struct snd_compr_runtime *runtime = cstream->runtime;
+	struct sst_runtime_stream *stream;
+	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
+	struct snd_soc_dai_link *dai_link = rtd->dai_link;
+
+	pr_debug("%s called:%s\n", __func__, dai_link->cpu_dai_name);
+
+	stream = kzalloc(sizeof(*stream), GFP_KERNEL);
+	if (!stream)
+		return -ENOMEM;
+
+	spin_lock_init(&stream->status_lock);
+
+	/* get the sst ops */
+	if (!sst_dsp || !try_module_get(sst_dsp->dev->driver->owner)) {
+		pr_err("no device available to run\n");
+		ret_val = -ENODEV;
+		goto out_ops;
+	}
+	stream->compr_ops = sst_dsp->compr_ops;
+
+	stream->id = 0;
+	sst_set_stream_status(stream, SST_PLATFORM_INIT);
+	runtime->private_data = stream;
+	return 0;
+out_ops:
+	kfree(stream);
+	return ret_val;
+}
+
+static int sst_platform_compr_free(struct snd_compr_stream *cstream)
+{
+	struct sst_runtime_stream *stream;
+	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
+	struct snd_soc_dai_link *dai_link = rtd->dai_link;
+	int ret_val = 0, str_id;
+
+	stream = cstream->runtime->private_data;
+	/*need to check*/
+	str_id = stream->id;
+	if (str_id)
+		ret_val = stream->compr_ops->close(str_id);
+	module_put(sst_dsp->dev->driver->owner);
+	kfree(stream);
+	pr_debug("%s called for dai %s: ret = %d\n", __func__,
+				dai_link->cpu_dai_name, ret_val);
+	return 0;
+}
+
+static int sst_platform_compr_set_params(struct snd_compr_stream *cstream,
+					struct snd_compr_params *params)
+{
+	struct sst_runtime_stream *stream;
+	int retval = 0;
+	struct snd_sst_params str_params;
+	struct sst_compress_cb cb;
+	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
+	struct snd_soc_platform *platform = rtd->platform;
+	struct sst_data *ctx = snd_soc_platform_get_drvdata(platform);
+
+	pr_debug("In function %s\n", __func__);
+	stream = cstream->runtime->private_data;
+	/* construct fw structure for this*/
+	memset(&str_params, 0, sizeof(str_params));
+
+	/* fill the device type and stream id to pass to SST driver */
+	retval = sst_fill_stream_params(cstream, ctx, &str_params, true);
+	pr_debug("compr_set_params: fill stream params ret_val = 0x%x\n", retval);
+	if (retval < 0)
+		return retval;
+
+	switch (params->codec.id) {
+	case SND_AUDIOCODEC_MP3: {
+		str_params.codec = SST_CODEC_TYPE_MP3;
+		str_params.sparams.uc.mp3_params.num_chan = params->codec.ch_in;
+		str_params.sparams.uc.mp3_params.pcm_wd_sz = 16;
+		break;
+	}
+
+	case SND_AUDIOCODEC_AAC: {
+		str_params.codec = SST_CODEC_TYPE_AAC;
+		str_params.sparams.uc.aac_params.num_chan = params->codec.ch_in;
+		str_params.sparams.uc.aac_params.pcm_wd_sz = 16;
+		if (params->codec.format == SND_AUDIOSTREAMFORMAT_MP4ADTS)
+			str_params.sparams.uc.aac_params.bs_format =
+							AAC_BIT_STREAM_ADTS;
+		else if (params->codec.format == SND_AUDIOSTREAMFORMAT_RAW)
+			str_params.sparams.uc.aac_params.bs_format =
+							AAC_BIT_STREAM_RAW;
+		else {
+			pr_err("Undefined format%d\n", params->codec.format);
+			return -EINVAL;
+		}
+		str_params.sparams.uc.aac_params.externalsr =
+						params->codec.sample_rate;
+		break;
+	}
+
+	default:
+		pr_err("codec not supported, id =%d\n", params->codec.id);
+		return -EINVAL;
+	}
+
+	str_params.aparams.ring_buf_info[0].addr  =
+					virt_to_phys(cstream->runtime->buffer);
+	str_params.aparams.ring_buf_info[0].size =
+					cstream->runtime->buffer_size;
+	str_params.aparams.sg_count = 1;
+	str_params.aparams.frag_size = cstream->runtime->fragment_size;
+
+	cb.param = cstream;
+	cb.compr_cb = sst_compr_fragment_elapsed;
+	cb.drain_cb_param = cstream;
+	cb.drain_notify = sst_drain_notify;
+
+	retval = stream->compr_ops->open(&str_params, &cb);
+	if (retval < 0) {
+		pr_err("stream allocation failed %d\n", retval);
+		return retval;
+	}
+
+	stream->id = retval;
+	return 0;
+}
+
+static int sst_platform_compr_trigger(struct snd_compr_stream *cstream, int cmd)
+{
+	struct sst_runtime_stream *stream =
+		cstream->runtime->private_data;
+
+	return stream->compr_ops->control(cmd, stream->id);
+}
+
+static int sst_platform_compr_pointer(struct snd_compr_stream *cstream,
+					struct snd_compr_tstamp *tstamp)
+{
+	struct sst_runtime_stream *stream;
+
+	stream  = cstream->runtime->private_data;
+	stream->compr_ops->tstamp(stream->id, tstamp);
+	tstamp->byte_offset = tstamp->copied_total %
+				 (u32)cstream->runtime->buffer_size;
+	pr_debug("calc bytes offset/copied bytes as %d\n", tstamp->byte_offset);
+	return 0;
+}
+
+static int sst_platform_compr_ack(struct snd_compr_stream *cstream,
+					size_t bytes)
+{
+	struct sst_runtime_stream *stream;
+
+	stream  = cstream->runtime->private_data;
+	stream->compr_ops->ack(stream->id, (unsigned long)bytes);
+	stream->bytes_written += bytes;
+
+	return 0;
+}
+
+static int sst_platform_compr_get_caps(struct snd_compr_stream *cstream,
+					struct snd_compr_caps *caps)
+{
+	struct sst_runtime_stream *stream =
+		cstream->runtime->private_data;
+
+	return stream->compr_ops->get_caps(caps);
+}
+
+static int sst_platform_compr_get_codec_caps(struct snd_compr_stream *cstream,
+					struct snd_compr_codec_caps *codec)
+{
+	struct sst_runtime_stream *stream =
+		cstream->runtime->private_data;
+
+	return stream->compr_ops->get_codec_caps(codec);
+}
+
+static int sst_platform_compr_set_metadata(struct snd_compr_stream *cstream,
+					struct snd_compr_metadata *metadata)
+{
+	struct sst_runtime_stream *stream  =
+		 cstream->runtime->private_data;
+
+	return stream->compr_ops->set_metadata(stream->id, metadata);
+}
+
+struct snd_compr_ops sst_platform_compr_ops = {
+
+	.open = sst_platform_compr_open,
+	.free = sst_platform_compr_free,
+	.set_params = sst_platform_compr_set_params,
+	.set_metadata = sst_platform_compr_set_metadata,
+	.trigger = sst_platform_compr_trigger,
+	.pointer = sst_platform_compr_pointer,
+	.ack = sst_platform_compr_ack,
+	.get_caps = sst_platform_compr_get_caps,
+	.get_codec_caps = sst_platform_compr_get_codec_caps,
+};
diff --git a/sound/soc/intel/effects.c b/sound/soc/intel/effects.c
new file mode 100644
index 0000000..6bb4199
--- /dev/null
+++ b/sound/soc/intel/effects.c
@@ -0,0 +1,405 @@
+/*
+ *  effects.c - platform file for effects interface
+ *
+ *  Copyright (C) 2013 Intel Corporation
+ *  Authors:	Samreen Nilofer <samreen.nilofer@intel.com>
+ *		Vinod Koul <vinod.koul@intel.com>
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+#include <linux/slab.h>
+#include <asm/platform_sst_audio.h>
+#include "platform_ipc_v2.h"
+#include "sst_platform.h"
+#include "sst_platform_pvt.h"
+
+extern struct sst_device *sst_dsp;
+extern struct device *sst_pdev;
+
+struct effect_uuid {
+	uint32_t timeLow;
+	uint16_t timeMid;
+	uint16_t timeHiAndVersion;
+	uint16_t clockSeq;
+	uint8_t node[6];
+};
+
+#define EFFECT_STRING_LEN_MAX 64
+
+enum sst_effect {
+	EFFECTS_CREATE = 0,
+	EFFECTS_DESTROY,
+	EFFECTS_SET_PARAMS,
+	EFFECTS_GET_PARAMS,
+};
+
+enum sst_mixer_output_mode {
+	SST_MEDIA0_OUT,
+	SST_MEDIA1_OUT,
+};
+
+static inline void sst_fill_byte_stream(struct snd_sst_bytes_v2 *bytes, u8 type,
+			u8 msg, u8 block, u8 task, u8 pipe_id, u16 len,
+			struct ipc_effect_payload *payload)
+{
+	u32 size = sizeof(struct ipc_effect_dsp_hdr);
+
+	bytes->type = type;
+	bytes->ipc_msg = msg;
+	bytes->block = block;
+	bytes->task_id = task;
+	bytes->pipe_id = pipe_id;
+	bytes->len = len;
+
+	/* Copy the ipc_effect_dsp_hdr followed by the data */
+	memcpy(bytes->bytes, payload, size);
+	memcpy(bytes->bytes + size, payload->data, len - size);
+}
+
+static int sst_send_effects(struct ipc_effect_payload *dsp_payload, int data_len,
+					enum sst_effect effect_type)
+{
+	struct snd_sst_bytes_v2 *bytes;
+	u32 len;
+	int ret;
+	u8 type, msg = IPC_INVALID, pipe, payload_len;
+	struct sst_data *sst;
+
+	if (!sst_pdev)
+		return -ENODEV;
+	sst =  dev_get_drvdata(sst_pdev);
+
+	len = sizeof(*bytes) + sizeof(struct ipc_effect_dsp_hdr) + data_len;
+
+	bytes = kzalloc(len, GFP_KERNEL);
+	if (!bytes) {
+		pr_err("kzalloc failed allocate bytes\n");
+		return -ENOMEM;
+	}
+
+	switch (effect_type) {
+	case EFFECTS_CREATE:
+	case EFFECTS_DESTROY:
+		type = SND_SST_BYTES_SET;
+		msg = IPC_CMD;
+		break;
+
+	case EFFECTS_SET_PARAMS:
+		type = SND_SST_BYTES_SET;
+		msg = IPC_SET_PARAMS;
+		break;
+
+	case EFFECTS_GET_PARAMS:
+		type = SND_SST_BYTES_GET;
+		msg =  IPC_GET_PARAMS;
+		break;
+	default:
+		pr_err("No such effect %#x", effect_type);
+		ret = -EINVAL;
+		goto free_bytes;
+	}
+
+	pipe = dsp_payload->dsp_hdr.pipe_id;
+	payload_len = sizeof(struct ipc_effect_dsp_hdr) + data_len;
+	sst_fill_byte_stream(bytes, type, msg, 1, SST_TASK_ID_MEDIA,
+				pipe, payload_len, dsp_payload);
+
+	mutex_lock(&sst->lock);
+	ret = sst_dsp->ops->set_generic_params(SST_SET_BYTE_STREAM, bytes);
+	mutex_unlock(&sst->lock);
+
+	if (ret) {
+		pr_err("byte_stream failed err %d pipe_id %#x\n", ret,
+				dsp_payload->dsp_hdr.pipe_id);
+		goto free_bytes;
+	}
+
+	/* Copy only the data - skip the dsp header */
+	if (msg == IPC_GET_PARAMS)
+		memcpy(dsp_payload->data, bytes->bytes, data_len);
+
+free_bytes:
+	kfree(bytes);
+	return ret;
+}
+
+static int sst_get_algo_id(const struct sst_dev_effects *pdev_effs,
+					char *uuid, u16 *algo_id)
+{
+	int i, len;
+
+	len = pdev_effs->effs_num_map;
+
+	for (i = 0; i < len; i++) {
+		if (!strncmp(pdev_effs->effs_map[i].uuid, uuid, sizeof(struct effect_uuid))) {
+			*algo_id = pdev_effs->effs_map[i].algo_id;
+			return 0;
+		}
+	}
+	pr_err("no such uuid\n");
+	return -EINVAL;
+}
+
+static int sst_fill_effects_info(const struct sst_dev_effects *pdev_effs,
+					char *uuid, u16 pos,
+					struct ipc_dsp_effects_info *effs_info, u16 cmd_id)
+{
+	int i, len;
+
+	len = pdev_effs->effs_num_map;
+
+	for (i = 0; i < len; i++) {
+		if (!strncmp(pdev_effs->effs_map[i].uuid, uuid, sizeof(struct effect_uuid))) {
+
+			effs_info->cmd_id = cmd_id;
+			effs_info->length = (sizeof(struct ipc_dsp_effects_info) -
+						offsetof(struct ipc_dsp_effects_info, sel_pos));
+			effs_info->sel_pos = pos;
+			effs_info->sel_algo_id = pdev_effs->effs_map[i].algo_id;
+			effs_info->cpu_load = pdev_effs->effs_res_map[i].cpuLoad;
+			effs_info->memory_usage = pdev_effs->effs_res_map[i].memoryUsage;
+			effs_info->flags = pdev_effs->effs_res_map[i].flags;
+
+			return 0;
+		}
+	}
+
+	pr_err("no such uuid\n");
+	return -EINVAL;
+}
+
+static inline void sst_fill_dsp_payload(struct ipc_effect_payload *dsp_payload,
+					u8 pipe_id, u16 mod_id, char *data)
+{
+	dsp_payload->dsp_hdr.mod_index_id = 0xFF;
+	dsp_payload->dsp_hdr.pipe_id = pipe_id;
+	dsp_payload->dsp_hdr.mod_id = mod_id;
+	dsp_payload->data = data;
+}
+
+static int sst_get_pipe_id(struct sst_dev_stream_map *map, int map_size,
+				int dev, int mode, u8 *pipe_id)
+{
+	int index;
+
+	if (map == NULL)
+		return -EINVAL;
+
+	/* In case of global effects, dev will be 0xff */
+	if (dev == 0xFF) {
+		*pipe_id = (mode == SST_MEDIA0_OUT) ? PIPE_MEDIA0_OUT : PIPE_MEDIA1_OUT;
+		return 0;
+	}
+
+	for (index = 1; index < map_size; index++) {
+		if (map[index].dev_num == dev) {
+			*pipe_id = map[index].device_id;
+			break;
+		}
+	}
+
+	if (index == map_size) {
+		pr_err("no such device %d\n", dev);
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static int sst_effects_create(struct snd_card *card, struct snd_effect *effect)
+{
+	int ret = 0;
+	u8 pipe_id;
+	struct ipc_effect_payload dsp_payload;
+	struct ipc_dsp_effects_info effects_info;
+	struct sst_data *sst;
+
+	if (!sst_pdev)
+		return -ENODEV;
+	sst =  dev_get_drvdata(sst_pdev);
+
+	ret = sst_fill_effects_info(&sst->pdata->pdev_effs, effect->uuid, effect->pos,
+				 &effects_info, IPC_EFFECTS_CREATE);
+	if (ret < 0)
+		return ret;
+
+	ret = sst_get_pipe_id(sst->pdata->pdev_strm_map,
+				sst->pdata->strm_map_size,
+				effect->device, effect->mode, &pipe_id);
+	if (ret < 0)
+		return ret;
+
+	sst_fill_dsp_payload(&dsp_payload, pipe_id, 0xFF, (char *)&effects_info);
+
+	ret = sst_send_effects(&dsp_payload, sizeof(effects_info), EFFECTS_CREATE);
+
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int sst_effects_destroy(struct snd_card *card, struct snd_effect *effect)
+{
+	int ret = 0;
+	u8 pipe_id;
+	struct ipc_effect_payload dsp_payload;
+	struct ipc_dsp_effects_info effects_info;
+	struct sst_data *sst;
+
+	if (!sst_pdev)
+		return -ENODEV;
+	sst =  dev_get_drvdata(sst_pdev);
+
+	ret = sst_fill_effects_info(&sst->pdata->pdev_effs, effect->uuid, effect->pos,
+				&effects_info, IPC_EFFECTS_DESTROY);
+	if (ret < 0)
+		return ret;
+
+	ret = sst_get_pipe_id(sst->pdata->pdev_strm_map,
+				sst->pdata->strm_map_size,
+				effect->device, effect->mode, &pipe_id);
+	if (ret < 0)
+		return ret;
+
+	sst_fill_dsp_payload(&dsp_payload, pipe_id, 0xFF, (char *)&effects_info);
+
+	ret = sst_send_effects(&dsp_payload, sizeof(effects_info), EFFECTS_DESTROY);
+
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int sst_effects_set_params(struct snd_card *card,
+					struct snd_effect_params *params)
+{
+	int ret = 0;
+	u8 pipe_id;
+	u16 algo_id;
+	struct ipc_effect_payload dsp_payload;
+	struct sst_data *sst;
+
+	if (!sst_pdev)
+		return -ENODEV;
+	sst =  dev_get_drvdata(sst_pdev);
+
+	ret = sst_get_algo_id(&sst->pdata->pdev_effs, params->uuid, &algo_id);
+	if (ret < 0)
+		return ret;
+
+	ret = sst_get_pipe_id(sst->pdata->pdev_strm_map,
+				sst->pdata->strm_map_size,
+				params->device, SST_MEDIA0_OUT, &pipe_id);
+	if (ret < 0)
+		return ret;
+
+	sst_fill_dsp_payload(&dsp_payload, pipe_id, algo_id, params->buffer);
+
+	ret = sst_send_effects(&dsp_payload, params->size, EFFECTS_SET_PARAMS);
+
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int sst_effects_get_params(struct snd_card *card,
+					struct snd_effect_params *params)
+{
+	int ret = 0;
+	u8 pipe_id;
+	u16 algo_id;
+	struct ipc_effect_payload dsp_payload;
+	struct sst_data *sst;
+
+	if (!sst_pdev)
+		return -ENODEV;
+	sst =  dev_get_drvdata(sst_pdev);
+
+	ret = sst_get_algo_id(&sst->pdata->pdev_effs, params->uuid, &algo_id);
+	if (ret < 0)
+		return ret;
+
+	ret = sst_get_pipe_id(sst->pdata->pdev_strm_map,
+				sst->pdata->strm_map_size,
+				params->device, SST_MEDIA0_OUT, &pipe_id);
+	if (ret < 0)
+		return ret;
+
+	sst_fill_dsp_payload(&dsp_payload, pipe_id, algo_id, params->buffer);
+
+	ret = sst_send_effects(&dsp_payload, params->size, EFFECTS_GET_PARAMS);
+
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int sst_query_num_effects(struct snd_card *card)
+{
+	struct sst_data *sst;
+
+	if (!sst_pdev)
+		return -ENODEV;
+	sst =  dev_get_drvdata(sst_pdev);
+
+	return sst->pdata->pdev_effs.effs_num_map;
+}
+
+static int sst_query_effects_caps(struct snd_card *card,
+					struct snd_effect_caps *caps)
+{
+	struct sst_data *sst;
+	struct sst_dev_effects_map *effs_map;
+	unsigned int num_effects, offset = 0;
+	char *dstn;
+	int i;
+
+	if (!sst_pdev)
+		return -ENODEV;
+	sst =  dev_get_drvdata(sst_pdev);
+
+	effs_map = sst->pdata->pdev_effs.effs_map;
+	num_effects = sst->pdata->pdev_effs.effs_num_map;
+
+	if (caps->size < (num_effects * MAX_DESCRIPTOR_SIZE)) {
+		pr_err("buffer size is insufficient\n");
+		return -ENOMEM;
+	}
+
+	dstn = caps->buffer;
+	for (i = 0; i < num_effects; i++) {
+		memcpy(dstn + offset, effs_map[i].descriptor, MAX_DESCRIPTOR_SIZE);
+		offset += MAX_DESCRIPTOR_SIZE;
+	}
+	caps->size = offset;
+
+	return 0;
+}
+
+struct snd_effect_ops effects_ops = {
+	.create = sst_effects_create,
+	.destroy = sst_effects_destroy,
+	.set_params = sst_effects_set_params,
+	.get_params = sst_effects_get_params,
+	.query_num_effects = sst_query_num_effects,
+	.query_effect_caps = sst_query_effects_caps,
+};
diff --git a/sound/soc/intel/pcm.c b/sound/soc/intel/pcm.c
new file mode 100644
index 0000000..8600147
--- /dev/null
+++ b/sound/soc/intel/pcm.c
@@ -0,0 +1,1021 @@
+/*
+ *  pcm.c - Intel MID Platform driver file implementing PCM functionality
+ *
+ *  Copyright (C) 2010-2013 Intel Corp
+ *  Author: Vinod Koul <vinod.koul@intel.com>
+ *  Author: Harsha Priya <priya.harsha@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/intel_sst_ioctl.h>
+#include <asm/platform_sst_audio.h>
+#include <asm/intel_sst_mrfld.h>
+#include <asm/intel-mid.h>
+#include "platform_ipc_v2.h"
+#include "sst_platform.h"
+#include "sst_platform_pvt.h"
+
+struct device *sst_pdev;
+struct sst_device *sst_dsp;
+extern struct snd_compr_ops sst_platform_compr_ops;
+extern struct snd_effect_ops effects_ops;
+
+static DEFINE_MUTEX(sst_dsp_lock);
+
+static struct snd_pcm_hardware sst_platform_pcm_hw = {
+	.info =	(SNDRV_PCM_INFO_INTERLEAVED |
+			SNDRV_PCM_INFO_DOUBLE |
+			SNDRV_PCM_INFO_PAUSE |
+			SNDRV_PCM_INFO_RESUME |
+			SNDRV_PCM_INFO_MMAP|
+			SNDRV_PCM_INFO_MMAP_VALID |
+			SNDRV_PCM_INFO_BLOCK_TRANSFER |
+			SNDRV_PCM_INFO_SYNC_START),
+	.formats = (SNDRV_PCM_FMTBIT_S16 | SNDRV_PCM_FMTBIT_U16 |
+			SNDRV_PCM_FMTBIT_S24 | SNDRV_PCM_FMTBIT_U24 |
+			SNDRV_PCM_FMTBIT_S32 | SNDRV_PCM_FMTBIT_U32),
+	.rates = (SNDRV_PCM_RATE_8000|
+			SNDRV_PCM_RATE_16000 |
+			SNDRV_PCM_RATE_44100 |
+			SNDRV_PCM_RATE_48000),
+	.rate_min = SST_MIN_RATE,
+	.rate_max = SST_MAX_RATE,
+	.channels_min =	SST_MIN_CHANNEL,
+	.channels_max =	SST_MAX_CHANNEL,
+	.buffer_bytes_max = SST_MAX_BUFFER,
+	.period_bytes_min = SST_MIN_PERIOD_BYTES,
+	.period_bytes_max = SST_MAX_PERIOD_BYTES,
+	.periods_min = SST_MIN_PERIODS,
+	.periods_max = SST_MAX_PERIODS,
+	.fifo_size = SST_FIFO_SIZE,
+};
+
+static int sst_platform_ihf_set_tdm_slot(struct snd_soc_dai *dai,
+			unsigned int tx_mask, unsigned int rx_mask,
+			int slots, int slot_width) {
+	struct snd_sst_runtime_params params_data;
+	int channels = slots;
+
+	/* registering with SST driver to get access to SST APIs to use */
+	if (!sst_dsp) {
+		pr_err("sst: DSP not registered\n");
+		return -EIO;
+	}
+	params_data.type = SST_SET_CHANNEL_INFO;
+	params_data.str_id = SND_SST_DEVICE_IHF;
+	params_data.size = sizeof(channels);
+	params_data.addr = &channels;
+	return sst_dsp->ops->set_generic_params(SST_SET_RUNTIME_PARAMS,
+							(void *)&params_data);
+}
+
+static int sst_media_digital_mute(struct snd_soc_dai *dai, int mute, int stream)
+{
+
+	pr_debug("%s: enter, mute=%d dai-name=%s dir=%d\n", __func__, mute, dai->name, stream);
+
+#if IS_BUILTIN(CONFIG_SST_MRFLD_DPCM)
+		sst_send_pipe_gains(dai, stream, mute);
+#endif
+
+	return 0;
+}
+
+/* helper functions */
+void sst_set_stream_status(struct sst_runtime_stream *stream,
+					int state)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&stream->status_lock, flags);
+	stream->stream_status = state;
+	spin_unlock_irqrestore(&stream->status_lock, flags);
+}
+
+static inline int sst_get_stream_status(struct sst_runtime_stream *stream)
+{
+	int state;
+	unsigned long flags;
+
+	spin_lock_irqsave(&stream->status_lock, flags);
+	state = stream->stream_status;
+	spin_unlock_irqrestore(&stream->status_lock, flags);
+	return state;
+}
+
+static void sst_fill_alloc_params(struct snd_pcm_substream *substream,
+				struct snd_sst_alloc_params_ext *alloc_param)
+{
+	unsigned int channels;
+	snd_pcm_uframes_t period_size;
+	ssize_t periodbytes;
+	ssize_t buffer_bytes = snd_pcm_lib_buffer_bytes(substream);
+	u32 buffer_addr = virt_to_phys(substream->dma_buffer.area);
+
+	channels = substream->runtime->channels;
+	period_size = substream->runtime->period_size;
+	periodbytes = samples_to_bytes(substream->runtime, period_size);
+	alloc_param->ring_buf_info[0].addr = buffer_addr;
+	alloc_param->ring_buf_info[0].size = buffer_bytes;
+	alloc_param->sg_count = 1;
+	alloc_param->reserved = 0;
+	alloc_param->frag_size = periodbytes * channels;
+
+	pr_debug("period_size = %d\n", alloc_param->frag_size);
+	pr_debug("ring_buf_addr = 0x%x\n", alloc_param->ring_buf_info[0].addr);
+}
+static void sst_fill_pcm_params(struct snd_pcm_substream *substream,
+				struct snd_sst_stream_params *param)
+{
+	param->uc.pcm_params.num_chan = (u8) substream->runtime->channels;
+	param->uc.pcm_params.pcm_wd_sz = substream->runtime->sample_bits;
+	param->uc.pcm_params.sfreq = substream->runtime->rate;
+
+	/* PCM stream via ALSA interface */
+	param->uc.pcm_params.use_offload_path = 0;
+	param->uc.pcm_params.reserved2 = 0;
+	memset(param->uc.pcm_params.channel_map, 0, sizeof(u8));
+	pr_debug("sfreq= %d, wd_sz = %d\n",
+	param->uc.pcm_params.sfreq, param->uc.pcm_params.pcm_wd_sz);
+
+}
+
+#define ASSIGN_PIPE_ID(periodtime, lowlatency, deepbuffer) \
+	((periodtime) <= (lowlatency) ? PIPE_LOW_PCM0_IN : \
+	((periodtime) >= (deepbuffer) ? PIPE_MEDIA3_IN : PIPE_MEDIA1_IN))
+
+static int sst_get_stream_mapping(int dev, int sdev, int dir,
+	struct sst_dev_stream_map *map, int size, u8 pipe_id,
+	const struct sst_lowlatency_deepbuff *ll_db)
+{
+	int index;
+	unsigned long pt = 0, ll = 0, db = 0;
+
+	if (map == NULL)
+		return -EINVAL;
+
+	pr_debug("dev %d sdev %d dir %d\n", dev, sdev, dir);
+
+	/* index 0 is not used in stream map */
+	for (index = 1; index < size; index++) {
+		if ((map[index].dev_num == dev) &&
+		    (map[index].subdev_num == sdev) &&
+		    (map[index].direction == dir)) {
+			/* device id for the probe is assigned dynamically */
+			if (map[index].status == SST_DEV_MAP_IN_USE) {
+				return index;
+			} else if (map[index].status == SST_DEV_MAP_FREE) {
+				map[index].status = SST_DEV_MAP_IN_USE;
+
+				if (map[index].dev_num == MERR_SALTBAY_PROBE) {
+					map[index].device_id = pipe_id;
+
+				} else if (map[index].dev_num == MERR_SALTBAY_AUDIO) {
+					if (!ll_db->low_latency || !ll_db->deep_buffer)
+						return -EINVAL;
+
+					pt = ll_db->period_time;
+					ll = *(ll_db->low_latency);
+					db = *(ll_db->deep_buffer);
+
+					pr_debug("PT %lu LL %lu DB %lu\n", pt, ll, db);
+
+					map[index].device_id = ASSIGN_PIPE_ID(pt,
+								ll, db);
+				}
+				pr_debug("%s: pipe_id 0%x index %d", __func__,
+						map[index].device_id, index);
+
+				return index;
+			}
+		}
+	}
+	return 0;
+}
+
+int sst_fill_stream_params(void *substream,
+	const struct sst_data *ctx, struct snd_sst_params *str_params, bool is_compress)
+{
+	int map_size;
+	int index;
+	struct sst_dev_stream_map *map;
+	struct snd_pcm_substream *pstream = NULL;
+	struct snd_compr_stream *cstream = NULL;
+
+	map = ctx->pdata->pdev_strm_map;
+	map_size = ctx->pdata->strm_map_size;
+
+	if (is_compress == true)
+		cstream = (struct snd_compr_stream *)substream;
+	else
+		pstream = (struct snd_pcm_substream *)substream;
+
+	str_params->stream_type = SST_STREAM_TYPE_MUSIC;
+
+	/* For pcm streams */
+	if (pstream) {
+		index = sst_get_stream_mapping(pstream->pcm->device,
+					  pstream->number, pstream->stream,
+					  map, map_size, ctx->pipe_id, &ctx->ll_db);
+		if (index <= 0)
+			return -EINVAL;
+
+		str_params->stream_id = index;
+		str_params->device_type = map[index].device_id;
+		str_params->task = map[index].task_id;
+
+		if (str_params->device_type == SST_PROBE_IN)
+			str_params->stream_type = SST_STREAM_TYPE_PROBE;
+
+		pr_debug("str_id = %d, device_type = 0x%x, task = %d",
+			 str_params->stream_id, str_params->device_type,
+			 str_params->task);
+
+		str_params->ops = (u8)pstream->stream;
+	}
+
+	if (cstream) {
+		/* FIXME: Add support for subdevice number in
+		 * snd_compr_stream */
+		index = sst_get_stream_mapping(cstream->device->device,
+					       0, cstream->direction,
+					       map, map_size, ctx->pipe_id, &ctx->ll_db);
+		if (index <= 0)
+			return -EINVAL;
+		str_params->stream_id = index;
+		str_params->device_type = map[index].device_id;
+		str_params->task = map[index].task_id;
+		pr_debug("compress str_id = %d, device_type = 0x%x, task = %d",
+			 str_params->stream_id, str_params->device_type,
+			 str_params->task);
+
+		str_params->ops = (u8)cstream->direction;
+	}
+	return 0;
+}
+
+#define CALC_PERIODTIME(period_size, rate) (((period_size) * 1000) / (rate))
+
+static int sst_platform_alloc_stream(struct snd_pcm_substream *substream,
+		struct snd_soc_platform *platform)
+{
+	struct sst_runtime_stream *stream =
+			substream->runtime->private_data;
+	struct snd_sst_stream_params param = {{{0,},},};
+	struct snd_sst_params str_params = {0};
+	struct snd_sst_alloc_params_ext alloc_params = {0};
+	int ret_val = 0;
+	struct sst_data *ctx = snd_soc_platform_get_drvdata(platform);
+
+	/* set codec params and inform SST driver the same */
+	sst_fill_pcm_params(substream, &param);
+	sst_fill_alloc_params(substream, &alloc_params);
+	substream->runtime->dma_area = substream->dma_buffer.area;
+	str_params.sparams = param;
+	str_params.aparams = alloc_params;
+	str_params.codec = SST_CODEC_TYPE_PCM;
+
+	ctx->ll_db.period_time = CALC_PERIODTIME(substream->runtime->period_size,
+					substream->runtime->rate);
+
+	/* fill the device type and stream id to pass to SST driver */
+	ret_val = sst_fill_stream_params(substream, ctx, &str_params, false);
+	pr_debug("platform prepare: fill stream params ret_val = 0x%x\n", ret_val);
+	if (ret_val < 0)
+		return ret_val;
+
+	stream->stream_info.str_id = str_params.stream_id;
+
+	ret_val = stream->ops->open(&str_params);
+	pr_debug("platform prepare: stream open ret_val = 0x%x\n", ret_val);
+	if (ret_val <= 0)
+		return ret_val;
+
+	pr_debug("platform allocated strid:  %d\n", stream->stream_info.str_id);
+
+	return ret_val;
+}
+
+static void sst_period_elapsed(void *mad_substream)
+{
+	struct snd_pcm_substream *substream = mad_substream;
+	struct sst_runtime_stream *stream;
+	int status;
+
+	if (!substream || !substream->runtime) {
+		pr_debug("In %s : Null Substream pointer\n", __func__);
+		return;
+	}
+	stream = substream->runtime->private_data;
+	if (!stream) {
+		pr_debug("In %s : Null Stream pointer\n", __func__);
+		return;
+	}
+	status = sst_get_stream_status(stream);
+	if (status != SST_PLATFORM_RUNNING) {
+		pr_debug("In %s : Stream Status=%d\n", __func__, status);
+		return;
+	}
+	snd_pcm_period_elapsed(substream);
+}
+
+static int sst_platform_init_stream(struct snd_pcm_substream *substream)
+{
+	struct sst_runtime_stream *stream =
+			substream->runtime->private_data;
+	int ret_val;
+
+	pr_debug("setting buffer ptr param\n");
+	sst_set_stream_status(stream, SST_PLATFORM_INIT);
+	stream->stream_info.period_elapsed = sst_period_elapsed;
+	stream->stream_info.mad_substream = substream;
+	stream->stream_info.buffer_ptr = 0;
+	stream->stream_info.sfreq = substream->runtime->rate;
+	pr_debug("pcm_substream %p, period_elapsed %p\n",
+			stream->stream_info.mad_substream, stream->stream_info.period_elapsed);
+	ret_val = stream->ops->device_control(
+			SST_SND_STREAM_INIT, &stream->stream_info);
+	if (ret_val)
+		pr_err("control_set ret error %d\n", ret_val);
+	return ret_val;
+
+}
+
+static inline int power_up_sst(struct sst_runtime_stream *sst)
+{
+	return sst->ops->power(true);
+}
+
+static inline int power_down_sst(struct sst_runtime_stream *sst)
+{
+	return sst->ops->power(false);
+}
+/* end -- helper functions */
+
+static int sst_media_open(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	int ret_val = 0;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sst_runtime_stream *stream;
+
+	stream = kzalloc(sizeof(*stream), GFP_KERNEL);
+	if (!stream)
+		return -ENOMEM;
+
+	spin_lock_init(&stream->status_lock);
+
+	/* get the sst ops */
+	mutex_lock(&sst_dsp_lock);
+	if (!sst_dsp ||
+	    !try_module_get(sst_dsp->dev->driver->owner)) {
+		pr_err("no device available to run\n");
+		ret_val = -ENODEV;
+		goto out_ops;
+	}
+	stream->ops = sst_dsp->ops;
+	mutex_unlock(&sst_dsp_lock);
+
+	stream->stream_info.str_id = 0;
+	sst_set_stream_status(stream, SST_PLATFORM_UNINIT);
+	stream->stream_info.mad_substream = substream;
+	runtime->private_data = stream;
+
+	if (strstr(dai->name, "Power-cpu-dai"))
+		return power_up_sst(stream);
+
+	/* Make sure, that the period size is always even */
+	snd_pcm_hw_constraint_step(substream->runtime, 0,
+			   SNDRV_PCM_HW_PARAM_PERIODS, 2);
+
+	pr_debug("buf_ptr %llu\n", stream->stream_info.buffer_ptr);
+	return snd_pcm_hw_constraint_integer(runtime,
+			 SNDRV_PCM_HW_PARAM_PERIODS);
+out_ops:
+	kfree(stream);
+	mutex_unlock(&sst_dsp_lock);
+	return ret_val;
+}
+
+static void sst_free_stream_in_use(struct sst_dev_stream_map *map, int str_id)
+{
+#if IS_BUILTIN(CONFIG_SST_MRFLD_DPCM)
+	return;
+#else
+	if ((map[str_id].dev_num == MERR_SALTBAY_AUDIO) ||
+	    (map[str_id].dev_num == MERR_SALTBAY_PROBE)) {
+
+		/* Do nothing in capture for audio device */
+		if ((map[str_id].dev_num == MERR_SALTBAY_AUDIO) &&
+		    (map[str_id].direction == SNDRV_PCM_STREAM_CAPTURE))
+			return;
+		if ((map[str_id].task_id == SST_TASK_ID_MEDIA) &&
+		    (map[str_id].status == SST_DEV_MAP_IN_USE)) {
+			pr_debug("str_id %d device_id 0x%x\n", str_id, map[str_id].device_id);
+			map[str_id].status = SST_DEV_MAP_FREE;
+			map[str_id].device_id = PIPE_RSVD;
+		}
+	}
+	return;
+#endif
+}
+
+static void sst_media_close(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct sst_runtime_stream *stream;
+	int ret_val = 0, str_id;
+	struct sst_data *ctx = snd_soc_platform_get_drvdata(dai->platform);
+
+	stream = substream->runtime->private_data;
+	if (strstr(dai->name, "Power-cpu-dai"))
+		ret_val = power_down_sst(stream);
+
+	str_id = stream->stream_info.str_id;
+	if (str_id)
+		ret_val = stream->ops->close(str_id);
+	sst_free_stream_in_use(ctx->pdata->pdev_strm_map, str_id);
+	module_put(sst_dsp->dev->driver->owner);
+	kfree(stream);
+	pr_debug("%s: %d\n", __func__, ret_val);
+}
+
+static int sst_dpcm_probe_cmd(struct snd_soc_platform *platform,
+		struct snd_pcm_substream *substream, u16 pipe_id, bool on)
+{
+	int ret = 0;
+#if IS_BUILTIN(CONFIG_SST_MRFLD_DPCM)
+	if (substream->pcm->device == MERR_DPCM_PROBE)
+		ret = sst_dpcm_probe_send(platform, pipe_id, substream->number,
+					      substream->stream, on);
+#endif
+	return ret;
+}
+
+static inline unsigned int get_current_pipe_id(struct snd_soc_platform *platform,
+					       struct snd_pcm_substream *substream)
+{
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	struct sst_dev_stream_map *map = sst->pdata->pdev_strm_map;
+	struct sst_runtime_stream *stream =
+			substream->runtime->private_data;
+	u32 str_id = stream->stream_info.str_id;
+	unsigned int pipe_id;
+	pipe_id = map[str_id].device_id;
+
+	pr_debug("%s: got pipe_id = %#x for str_id = %d\n",
+		 __func__, pipe_id, str_id);
+	return pipe_id;
+}
+
+static void sst_probe_close(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	u16 probe_pipe_id = get_current_pipe_id(dai->platform, substream);
+
+	sst_dpcm_probe_cmd(dai->platform, substream, probe_pipe_id, false);
+	sst_media_close(substream, dai);
+}
+
+static int sst_media_prepare(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct sst_runtime_stream *stream;
+	int ret_val = 0, str_id;
+
+	pr_debug("%s\n", __func__);
+
+	stream = substream->runtime->private_data;
+	str_id = stream->stream_info.str_id;
+	if (stream->stream_info.str_id)
+		return ret_val;
+
+	ret_val = sst_platform_alloc_stream(substream, dai->platform);
+	if (ret_val <= 0)
+		return ret_val;
+	snprintf(substream->pcm->id, sizeof(substream->pcm->id),
+			"%d", stream->stream_info.str_id);
+
+	ret_val = sst_platform_init_stream(substream);
+	if (ret_val)
+		return ret_val;
+	substream->runtime->hw.info = SNDRV_PCM_INFO_BLOCK_TRANSFER;
+
+	return ret_val;
+}
+
+static int sst_probe_prepare(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	u16 probe_pipe_id;
+
+	sst_media_prepare(substream, dai);
+	probe_pipe_id = get_current_pipe_id(dai->platform, substream);
+
+	return sst_dpcm_probe_cmd(dai->platform, substream, probe_pipe_id, true);
+}
+
+static int sst_media_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params,
+				struct snd_soc_dai *dai)
+{
+	pr_debug("%s\n", __func__);
+
+	snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
+	memset(substream->runtime->dma_area, 0, params_buffer_bytes(params));
+	return 0;
+}
+
+static int sst_media_hw_free(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	return snd_pcm_lib_free_pages(substream);
+}
+
+static struct snd_soc_dai_ops sst_media_dai_ops = {
+	.startup = sst_media_open,
+	.shutdown = sst_media_close,
+	.prepare = sst_media_prepare,
+	.hw_params = sst_media_hw_params,
+	.hw_free = sst_media_hw_free,
+	.set_tdm_slot = sst_platform_ihf_set_tdm_slot,
+	.mute_stream = sst_media_digital_mute,
+};
+
+static struct snd_soc_dai_ops sst_probe_dai_ops = {
+	.startup = sst_media_open,
+	.hw_params = sst_media_hw_params,
+	.hw_free = sst_media_hw_free,
+	.shutdown = sst_probe_close,
+	.prepare = sst_probe_prepare,
+};
+
+static struct snd_soc_dai_ops sst_loopback_dai_ops = {
+	.startup = sst_media_open,
+	.shutdown = sst_media_close,
+	.prepare = sst_media_prepare,
+};
+
+static struct snd_soc_dai_ops sst_compr_dai_ops = {
+	.mute_stream = sst_media_digital_mute,
+};
+
+static struct snd_soc_dai_driver sst_platform_dai[] = {
+{
+	.name = SST_HEADSET_DAI,
+	.ops = &sst_media_dai_ops,
+	.playback = {
+		.stream_name = "Headset Playback",
+		.channels_min = SST_STEREO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_44100|SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.capture = {
+		.stream_name = "Headset Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_44100|SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+{
+	.name = SST_DEEPBUFFER_DAI,
+	.ops = &sst_media_dai_ops,
+	.playback = {
+		.stream_name = "Deepbuffer Playback",
+		.channels_min = SST_STEREO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+{
+	.name = SST_LOWLATENCY_DAI,
+	.ops = &sst_media_dai_ops,
+	.playback = {
+		.stream_name = "Low Latency Playback",
+		.channels_min = SST_STEREO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+{
+	.name = SST_SPEAKER_DAI,
+	.ops = &sst_media_dai_ops,
+	.playback = {
+		.stream_name = "Speaker Playback",
+		.channels_min = SST_MONO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_44100|SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+{
+	.name = SST_VOICE_DAI,
+	.playback = {
+		.stream_name = "Voice Downlink",
+		.channels_min = SST_MONO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_16000|SNDRV_PCM_RATE_44100|SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.capture = {
+		.stream_name = "Voice Uplink",
+		.channels_min = SST_MONO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_16000|SNDRV_PCM_RATE_44100|SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+{
+	.name = SST_COMPRESS_DAI,
+	.compress_dai = 1,
+	.ops = &sst_compr_dai_ops,
+	.playback = {
+		.stream_name = "Compress Playback",
+		.channels_min = SST_STEREO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+{
+	.name = SST_VIRTUAL_DAI,
+	.playback = {
+		.stream_name = "Virtual Playback",
+		.channels_min = SST_STEREO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+{
+	.name = SST_POWER_DAI,
+	.ops = &sst_media_dai_ops,
+	.playback = {
+		.stream_name = "Dummy Power Stream",
+		.channels_min = SST_MONO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_8000_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
+	},
+},
+{
+	.name = SST_PROBE_DAI,
+	.ops = &sst_probe_dai_ops,
+	.playback = {
+		.stream_name = "Probe Playback",
+		.channels_min = SST_MONO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_8000 |
+				SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
+	},
+	.capture = {
+		.stream_name = "Probe Capture",
+		.channels_min = SST_MONO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_8000 |
+				SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE,
+	},
+},
+{
+	.name = SST_VOIP_DAI,
+	.ops = &sst_media_dai_ops,
+	.playback = {
+		.stream_name = "VOIP Playback",
+		.channels_min = SST_MONO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.capture = {
+		.stream_name = "VOIP Capture",
+		.channels_min = SST_MONO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+{
+	.name = SST_LOOPBACK_DAI,
+	.ops = &sst_loopback_dai_ops,
+	.capture = {
+		.stream_name = "Loopback Capture",
+		.channels_min = SST_MONO,
+		.channels_max = SST_MONO,
+		.rates = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+/*BE CPU  Dais */
+{
+	.name = "ssp2-codec",
+	.playback = {
+		.stream_name = "ssp2 playback",
+		.channels_min = SST_STEREO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.capture = {
+		.stream_name = "ssp2 Capture",
+		.channels_min = SST_STEREO,
+		.channels_max = SST_STEREO,
+		.rates = SNDRV_PCM_RATE_48000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+},
+};
+
+static int sst_platform_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai_link *dai_link = rtd->dai_link;
+
+	pr_debug("sst_platform_open called:%s\n", dai_link->cpu_dai_name);
+	if (substream->pcm->internal)
+		return 0;
+	runtime = substream->runtime;
+	runtime->hw = sst_platform_pcm_hw;
+	return 0;
+}
+
+static int sst_platform_close(struct snd_pcm_substream *substream)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai_link *dai_link = rtd->dai_link;
+	pr_debug("sst_platform_close called:%s\n", dai_link->cpu_dai_name);
+	return 0;
+}
+
+static int sst_platform_pcm_trigger(struct snd_pcm_substream *substream,
+					int cmd)
+{
+	int ret_val = 0, str_id;
+	struct sst_runtime_stream *stream;
+	int str_cmd, status, alsa_state;
+
+	if (substream->pcm->internal)
+		return 0;
+	pr_debug("sst_platform_pcm_trigger called\n");
+	stream = substream->runtime->private_data;
+	str_id = stream->stream_info.str_id;
+	alsa_state = substream->runtime->status->state;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		pr_debug("Trigger Start\n");
+		str_cmd = SST_SND_START;
+		status = SST_PLATFORM_RUNNING;
+		stream->stream_info.mad_substream = substream;
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		pr_debug("Trigger stop\n");
+		str_cmd = SST_SND_DROP;
+		status = SST_PLATFORM_DROPPED;
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		pr_debug("Trigger pause\n");
+		str_cmd = SST_SND_PAUSE;
+		status = SST_PLATFORM_PAUSED;
+		break;
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		pr_debug("Trigger pause release\n");
+		str_cmd = SST_SND_RESUME;
+		status = SST_PLATFORM_RUNNING;
+		break;
+	default:
+		return -EINVAL;
+	}
+	ret_val = stream->ops->device_control(str_cmd, &str_id);
+	if (!ret_val)
+		sst_set_stream_status(stream, status);
+
+	return ret_val;
+}
+
+
+static snd_pcm_uframes_t sst_platform_pcm_pointer
+			(struct snd_pcm_substream *substream)
+{
+	struct sst_runtime_stream *stream;
+	int ret_val, status;
+	struct pcm_stream_info *str_info;
+
+	stream = substream->runtime->private_data;
+	status = sst_get_stream_status(stream);
+	if (status == SST_PLATFORM_INIT)
+		return 0;
+	str_info = &stream->stream_info;
+	ret_val = stream->ops->device_control(
+				SST_SND_BUFFER_POINTER, str_info);
+	if (ret_val) {
+		pr_err("sst: error code = %d\n", ret_val);
+		return ret_val;
+	}
+	substream->runtime->soc_delay = str_info->pcm_delay;
+	return str_info->buffer_ptr;
+}
+
+static struct snd_pcm_ops sst_platform_ops = {
+	.open = sst_platform_open,
+	.close = sst_platform_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.trigger = sst_platform_pcm_trigger,
+	.pointer = sst_platform_pcm_pointer,
+};
+
+static void sst_pcm_free(struct snd_pcm *pcm)
+{
+	pr_debug("sst_pcm_free called\n");
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+}
+
+static int sst_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_dai *dai = rtd->cpu_dai;
+	struct snd_pcm *pcm = rtd->pcm;
+	int retval = 0;
+
+	pr_debug("sst_pcm_new called\n");
+	if (dai->driver->playback.channels_min ||
+			dai->driver->capture.channels_min) {
+		retval =  snd_pcm_lib_preallocate_pages_for_all(pcm,
+			SNDRV_DMA_TYPE_CONTINUOUS,
+			snd_dma_continuous_data(GFP_DMA),
+			SST_MAX_BUFFER, SST_MAX_BUFFER);
+		if (retval) {
+			pr_err("dma buffer allocationf fail\n");
+			return retval;
+		}
+	}
+	return retval;
+}
+
+static int sst_soc_probe(struct snd_soc_platform *platform)
+{
+	struct sst_data *ctx = snd_soc_platform_get_drvdata(platform);
+	struct soft_platform_id spid;
+	int ret = 0;
+
+	memcpy(&spid, ctx->pdata->spid, sizeof(spid));
+	pr_err("Enter:%s\n", __func__);
+
+#if IS_BUILTIN(CONFIG_SST_MRFLD_DPCM)
+    ret = sst_dsp_init_v2_dpcm(platform);
+#else
+    ret = sst_dsp_init(platform);
+#endif
+//    if (ret)
+//        return ret;
+//    ret = snd_soc_register_effect(platform->card, &effects_ops);
+
+	return ret;
+}
+
+static int sst_soc_remove(struct snd_soc_platform *platform)
+{
+	pr_debug("%s called\n", __func__);
+	return 0;
+}
+
+static struct snd_soc_platform_driver sst_soc_platform_drv  = {
+	.probe		= sst_soc_probe,
+	.remove		= sst_soc_remove,
+	.ops		= &sst_platform_ops,
+	.compr_ops	= &sst_platform_compr_ops,
+	.pcm_new	= sst_pcm_new,
+	.pcm_free	= sst_pcm_free,
+	.read		= sst_soc_read,
+	.write		= sst_soc_write,
+};
+
+int sst_register_dsp(struct sst_device *sst_dev)
+{
+	if (!sst_dev)
+		return -ENODEV;
+	mutex_lock(&sst_dsp_lock);
+	if (sst_dsp) {
+		pr_err("we already have a device %s\n", sst_dsp->name);
+		mutex_unlock(&sst_dsp_lock);
+		return -EEXIST;
+	}
+	pr_debug("registering device %s\n", sst_dev->name);
+
+	sst_dsp = sst_dev;
+	mutex_unlock(&sst_dsp_lock);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sst_register_dsp);
+
+int sst_unregister_dsp(struct sst_device *dev)
+{
+	if (dev != sst_dsp)
+		return -EINVAL;
+
+	mutex_lock(&sst_dsp_lock);
+	if (sst_dsp) {
+		pr_debug("unregister %s\n", sst_dsp->name);
+		mutex_unlock(&sst_dsp_lock);
+		return -EIO;
+	}
+
+	sst_dsp = NULL;
+	mutex_unlock(&sst_dsp_lock);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sst_unregister_dsp);
+
+static const struct snd_soc_component_driver pcm_component = {
+	.name           = "pcm",
+};
+
+static int sst_platform_probe(struct platform_device *pdev)
+{
+	struct sst_data *sst;
+	int ret;
+	struct sst_platform_data *pdata = pdev->dev.platform_data;
+
+	pr_debug("sst_platform_probe called\n");
+	sst = devm_kzalloc(&pdev->dev, sizeof(*sst), GFP_KERNEL);
+	if (sst == NULL) {
+		pr_err("kzalloc failed\n");
+		return -ENOMEM;
+	}
+
+	sst_pdev = &pdev->dev;
+	sst->pdata = pdata;
+	mutex_init(&sst->lock);
+	dev_set_drvdata(&pdev->dev, sst);
+
+	ret = snd_soc_register_platform(&pdev->dev,
+					 &sst_soc_platform_drv);
+	if (ret) {
+		pr_err("registering soc platform failed\n");
+		return ret;
+	}
+	ret = snd_soc_register_component(&pdev->dev, &pcm_component,
+				sst_platform_dai, ARRAY_SIZE(sst_platform_dai));
+	if (ret) {
+		pr_err("registering cpu dais failed\n");
+		snd_soc_unregister_platform(&pdev->dev);
+	}
+
+	return ret;
+}
+
+static int sst_platform_remove(struct platform_device *pdev)
+{
+
+	snd_soc_unregister_component(&pdev->dev);
+	snd_soc_unregister_platform(&pdev->dev);
+	pr_debug("sst_platform_remove success\n");
+	return 0;
+}
+
+static struct platform_driver sst_platform_driver = {
+	.driver		= {
+		.name		= "sst-platform",
+		.owner		= THIS_MODULE,
+	},
+	.probe		= sst_platform_probe,
+	.remove		= sst_platform_remove,
+};
+
+module_platform_driver(sst_platform_driver);
+
+MODULE_DESCRIPTION("ASoC Intel(R) MID Platform driver");
+MODULE_AUTHOR("Vinod Koul <vinod.koul@intel.com>");
+MODULE_AUTHOR("Harsha Priya <priya.harsha@intel.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:sst-platform");
diff --git a/sound/soc/intel/platform-libs/controls_v1.c b/sound/soc/intel/platform-libs/controls_v1.c
new file mode 100644
index 0000000..b6a5fa7
--- /dev/null
+++ b/sound/soc/intel/platform-libs/controls_v1.c
@@ -0,0 +1,184 @@
+/*
+ *  controls_v1.c - Intel MID Platform driver ALSA controls for CTP
+ *
+ *  Copyright (C) 2012 Intel Corp
+ *  Author: Jeeja KP <jeeja.kp@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+#include <linux/slab.h>
+#include <sound/intel_sst_ioctl.h>
+#include <sound/soc.h>
+#include "../sst_platform.h"
+#include "../sst_platform_pvt.h"
+
+
+static int sst_set_mixer_param(unsigned int device_input_mixer)
+{
+	if (!sst_dsp) {
+		pr_err("sst: DSP not registered\n");
+		return -ENODEV;
+	}
+
+	/*allocate memory for params*/
+	return sst_dsp->ops->set_generic_params(SST_SET_ALGO_PARAMS,
+						(void *)&device_input_mixer);
+}
+static int lpe_mixer_ihf_get(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+
+	ucontrol->value.integer.value[0] = sst->lpe_mixer_input_ihf;
+	return 0;
+}
+
+static int lpe_mixer_ihf_set(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	int device_input_mixer;
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+
+	switch (ucontrol->value.integer.value[0]) {
+	case 0:
+		pr_debug("input is None\n");
+		device_input_mixer = SST_STREAM_DEVICE_IHF
+					| SST_INPUT_STREAM_NONE;
+		break;
+	case 1:
+		pr_debug("input is PCM stream\n");
+		device_input_mixer = SST_STREAM_DEVICE_IHF
+					| SST_INPUT_STREAM_PCM;
+		break;
+	case 2:
+		pr_debug("input is Compress  stream\n");
+		device_input_mixer = SST_STREAM_DEVICE_IHF
+					| SST_INPUT_STREAM_COMPRESS;
+		break;
+	case 3:
+		pr_debug("input is Mixed stream\n");
+		device_input_mixer = SST_STREAM_DEVICE_IHF
+					| SST_INPUT_STREAM_MIXED;
+		break;
+	default:
+		pr_err("Invalid Input:%ld\n", ucontrol->value.integer.value[0]);
+		return -EINVAL;
+	}
+	sst->lpe_mixer_input_ihf  = ucontrol->value.integer.value[0];
+	return sst_set_mixer_param(device_input_mixer);
+}
+
+static int lpe_mixer_headset_get(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+
+	ucontrol->value.integer.value[0] = sst->lpe_mixer_input_hs;
+	return 0;
+}
+
+static int lpe_mixer_headset_set(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	int mixer_input_stream;
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+
+	switch (ucontrol->value.integer.value[0]) {
+	case 0:
+		pr_debug("input is None\n");
+		mixer_input_stream = SST_STREAM_DEVICE_HS
+					| SST_INPUT_STREAM_NONE;
+		break;
+	case 1:
+		pr_debug("input is PCM stream\n");
+		mixer_input_stream = SST_STREAM_DEVICE_HS
+					 | SST_INPUT_STREAM_PCM;
+		break;
+	case 2:
+		pr_debug("input is Compress  stream\n");
+		mixer_input_stream = SST_STREAM_DEVICE_HS
+					 | SST_INPUT_STREAM_COMPRESS;
+		break;
+	case 3:
+		pr_debug("input is Mixed stream\n");
+		mixer_input_stream = SST_STREAM_DEVICE_HS
+					 | SST_INPUT_STREAM_MIXED;
+		break;
+	default:
+		pr_err("Invalid Input:%ld\n", ucontrol->value.integer.value[0]);
+		return -EINVAL;
+	}
+	sst->lpe_mixer_input_hs  = ucontrol->value.integer.value[0];
+	return sst_set_mixer_param(mixer_input_stream);
+}
+
+static int sst_probe_byte_control_get(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+
+	if (!sst_dsp) {
+		pr_err("sst: DSP not registered\n");
+		return -ENODEV;
+	}
+
+	return sst_dsp->ops->set_generic_params(SST_GET_PROBE_BYTE_STREAM,
+				ucontrol->value.bytes.data);
+}
+
+static int sst_probe_byte_control_set(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+
+	if (!sst_dsp) {
+		pr_err("sst: DSP not registered\n");
+		return -ENODEV;
+	}
+
+	return sst_dsp->ops->set_generic_params(SST_SET_PROBE_BYTE_STREAM,
+				ucontrol->value.bytes.data);
+}
+
+static const char *lpe_mixer_text[] = {
+	"None", "PCM", "Compressed", "Mixed",
+};
+
+static const struct soc_enum lpe_mixer_enum =
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(lpe_mixer_text), lpe_mixer_text);
+
+static const struct snd_kcontrol_new sst_controls_clv[] = {
+	SOC_ENUM_EXT("LPE IHF mixer", lpe_mixer_enum,
+		lpe_mixer_ihf_get, lpe_mixer_ihf_set),
+	SOC_ENUM_EXT("LPE headset mixer", lpe_mixer_enum,
+		lpe_mixer_headset_get, lpe_mixer_headset_set),
+	SND_SOC_BYTES_EXT("SST Probe Byte Control", SST_MAX_BIN_BYTES,
+		sst_probe_byte_control_get,
+		sst_probe_byte_control_set),
+};
+
+int sst_platform_clv_init(struct snd_soc_platform *platform)
+{
+	struct sst_data *ctx = snd_soc_platform_get_drvdata(platform);
+	ctx->lpe_mixer_input_hs = 0;
+	ctx->lpe_mixer_input_ihf = 0;
+	snd_soc_add_platform_controls(platform, sst_controls_clv,
+						ARRAY_SIZE(sst_controls_clv));
+	return 0;
+}
diff --git a/sound/soc/intel/platform-libs/controls_v2.c b/sound/soc/intel/platform-libs/controls_v2.c
new file mode 100644
index 0000000..ab90b7e
--- /dev/null
+++ b/sound/soc/intel/platform-libs/controls_v2.c
@@ -0,0 +1,1768 @@
+/*
+ *  controls_v2.c - Intel MID Platform driver ALSA controls for Mrfld
+ *
+ *  Copyright (C) 2012 Intel Corp
+ *  Author: Vinod Koul <vinod.koul@ilinux.intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <sound/soc.h>
+#include <sound/asound.h>
+#include <asm/platform_sst_audio.h>
+#include "../platform_ipc_v2.h"
+#include "../sst_platform.h"
+#include "../sst_platform_pvt.h"
+#include "ipc_lib.h"
+#include "controls_v2.h"
+
+
+#define SST_ALGO_KCONTROL_INT(xname, xreg, xshift, xmax, xinvert,\
+	xhandler_get, xhandler_put, xmod, xpipe, xinstance, default_val) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = sst_algo_int_ctl_info, \
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value = (unsigned long)&(struct sst_algo_int_control_v2) \
+		{.mc.reg = xreg, .mc.rreg = xreg, .mc.shift = xshift, \
+		.mc.rshift = xshift, .mc.max = xmax, .mc.platform_max = xmax, \
+		.mc.invert = xinvert, .module_id = xmod, .pipe_id = xpipe, \
+		.instance_id = xinstance, .value = default_val } }
+/* Thresholds for Low Latency & Deep Buffer*/
+#define DEFAULT_LOW_LATENCY 10 /* In Ms */
+#define DEFAULT_DEEP_BUFFER 96
+
+unsigned long ll_threshold = DEFAULT_LOW_LATENCY;
+unsigned long db_threshold = DEFAULT_DEEP_BUFFER;
+
+int sst_algo_int_ctl_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo)
+{
+	struct sst_algo_int_control_v2 *amc = (void *)kcontrol->private_value;
+	struct soc_mixer_control *mc = &amc->mc;
+	int platform_max;
+
+	if (!mc->platform_max)
+		mc->platform_max = mc->max;
+	platform_max = mc->platform_max;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = platform_max;
+	return 0;
+}
+
+unsigned int sst_soc_read(struct snd_soc_platform *platform,
+			unsigned int reg)
+{
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+
+	pr_debug("%s for reg %d val=%d\n", __func__, reg, sst->widget[reg]);
+	BUG_ON(reg > (SST_NUM_WIDGETS - 1));
+	return sst->widget[reg];
+}
+
+int sst_soc_write(struct snd_soc_platform *platform,
+		  unsigned int reg, unsigned int val)
+{
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+
+	pr_debug("%s for reg %d val %d\n", __func__, reg, val);
+	BUG_ON(reg > (SST_NUM_WIDGETS - 1));
+	sst->widget[reg] = val;
+	return 0;
+}
+
+unsigned int sst_reg_read(struct sst_data *sst, unsigned int reg,
+			  unsigned int shift, unsigned int max)
+{
+	unsigned int mask = (1 << fls(max)) - 1;
+
+	return (sst->widget[reg] >> shift) & mask;
+}
+
+unsigned int sst_reg_write(struct sst_data *sst, unsigned int reg,
+			   unsigned int shift, unsigned int max, unsigned int val)
+{
+	unsigned int mask = (1 << fls(max)) - 1;
+
+	val &= mask;
+	val <<= shift;
+	sst->widget[reg] &= ~(mask << shift);
+	sst->widget[reg] |= val;
+	return val;
+}
+
+int sst_mix_put(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(widget->platform);
+	unsigned int mask = (1 << fls(mc->max)) - 1;
+	unsigned int val;
+	int connect;
+	struct snd_soc_dapm_update update;
+
+	pr_debug("%s called set %ld for %s\n", __func__,
+			ucontrol->value.integer.value[0], widget->name);
+	val = sst_reg_write(sst, mc->reg, mc->shift, mc->max, ucontrol->value.integer.value[0]);
+	connect = !!val;
+
+	update.kcontrol = kcontrol;
+	update.reg = mc->reg;
+	update.mask = mask;
+	update.val = val;
+
+	widget->dapm->card->update = &update;
+	snd_soc_dapm_mixer_update_power(widget->dapm, kcontrol, connect, &update);
+	widget->dapm->card->update = NULL;
+	return 0;
+}
+
+int sst_mix_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_dapm_widget *w = wlist->widgets[0];
+	struct soc_mixer_control *mc =
+		(struct soc_mixer_control *)kcontrol->private_value;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(w->platform);
+
+	pr_debug("%s called for %s\n", __func__, w->name);
+	ucontrol->value.integer.value[0] = !!sst_reg_read(sst, mc->reg, mc->shift, mc->max);
+	return 0;
+}
+
+static const struct snd_kcontrol_new sst_mix_modem_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_MODEM, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_MODEM, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_MODEM, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_MODEM, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_MODEM, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_MODEM, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_MODEM, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_MODEM, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_MODEM, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_MODEM, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_MODEM, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_MODEM, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_MODEM, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_MODEM, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_MODEM, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_MODEM, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_MODEM, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_MODEM, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_MODEM, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_codec0_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_CODEC0, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_CODEC0, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_CODEC0, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_CODEC0, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_CODEC0, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_CODEC0, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_CODEC0, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_CODEC0, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_CODEC0, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_CODEC0, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_CODEC0, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_CODEC0, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_CODEC0, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_CODEC0, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_CODEC0, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_CODEC0, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_CODEC0, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_CODEC0, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_CODEC0, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_codec1_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_CODEC1, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_CODEC1, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_CODEC1, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_CODEC1, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_CODEC1, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_CODEC1, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_CODEC1, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_CODEC1, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_CODEC1, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_CODEC1, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_CODEC1, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_CODEC1, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_CODEC1, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_CODEC1, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_CODEC1, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_CODEC1, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_CODEC1, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_CODEC1, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_CODEC1, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_sprot_l0_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_LOOP0, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_LOOP0, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_LOOP0, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_LOOP0, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_LOOP0, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_LOOP0, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_LOOP0, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_LOOP0, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_LOOP0, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_LOOP0, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_LOOP0, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_LOOP0, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_LOOP0, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_LOOP0, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_LOOP0, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_LOOP0, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_LOOP0, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_LOOP0, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_LOOP0, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_media_l1_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_LOOP1, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_LOOP1, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_LOOP1, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_LOOP1, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_LOOP1, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_LOOP1, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_LOOP1, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_LOOP1, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_LOOP1, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_LOOP1, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_LOOP1, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_LOOP1, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_LOOP1, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_LOOP1, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_LOOP1, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_LOOP1, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_LOOP1, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_LOOP1, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_LOOP1, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_media_l2_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_LOOP2, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_LOOP2, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_LOOP2, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_LOOP2, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_LOOP2, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_LOOP2, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_LOOP2, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_LOOP2, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_LOOP2, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_LOOP2, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_LOOP2, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_LOOP2, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_LOOP2, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_LOOP2, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_LOOP2, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_LOOP2, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_LOOP2, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_LOOP2, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_LOOP2, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_speech_tx_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_SPEECH, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_SPEECH, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_SPEECH, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_SPEECH, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_SPEECH, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_SPEECH, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_SPEECH, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_SPEECH, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_SPEECH, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_SPEECH, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_SPEECH, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_SPEECH, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_SPEECH, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_SPEECH, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_SPEECH, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_SPEECH, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_SPEECH, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_SPEECH, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_SPEECH, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_speech_rx_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_RXSPEECH, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_RXSPEECH, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_RXSPEECH, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_RXSPEECH, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_RXSPEECH, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_RXSPEECH, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_RXSPEECH, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_RXSPEECH, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_RXSPEECH, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_RXSPEECH, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_RXSPEECH, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_RXSPEECH, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_RXSPEECH, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_RXSPEECH, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_RXSPEECH, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_RXSPEECH, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_RXSPEECH, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_RXSPEECH, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_RXSPEECH, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_voip_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_VOIP, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_VOIP, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_VOIP, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_VOIP, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_VOIP, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_VOIP, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_VOIP, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_VOIP, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_VOIP, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_VOIP, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_VOIP, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_VOIP, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_VOIP, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_VOIP, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_VOIP, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_VOIP, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_VOIP, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_VOIP, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_VOIP, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_pcm0_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_PCM0, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_PCM0, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_PCM0, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_PCM0, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_PCM0, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_PCM0, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_PCM0, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_PCM0, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_PCM0, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_PCM0, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_PCM0, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_PCM0, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_PCM0, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_PCM0, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_PCM0, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_PCM0, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_PCM0, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_PCM0, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_PCM0, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_pcm1_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_PCM1, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_PCM1, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_PCM1, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_PCM1, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_PCM1, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_PCM1, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_PCM1, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_PCM1, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_PCM1, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_PCM1, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_PCM1, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_PCM1, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_PCM1, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_PCM1, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_PCM1, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_PCM1, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_PCM1, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_PCM1, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_PCM1, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_pcm2_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_PCM2, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_PCM2, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_PCM2, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_PCM2, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_PCM2, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_PCM2, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_PCM2, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_PCM2, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_PCM2, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_PCM2, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_PCM2, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_PCM2, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_PCM2, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_PCM2, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_PCM2, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_PCM2, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_PCM2, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_PCM2, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_PCM2, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_aware_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_AWARE, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_AWARE, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_AWARE, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_AWARE, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_AWARE, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_AWARE, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_AWARE, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_AWARE, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_AWARE, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_AWARE, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_AWARE, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_AWARE, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_AWARE, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_AWARE, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_AWARE, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_AWARE, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_AWARE, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_AWARE, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_AWARE, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_vad_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_VAD, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_VAD, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_VAD, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_VAD, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_VAD, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_VAD, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_VAD, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_VAD, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_VAD, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_VAD, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_VAD, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_VAD, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_VAD, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_VAD, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_VAD, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_VAD, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_VAD, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_VAD, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_VAD, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_media0_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_MEDIA0, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_MEDIA0, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_MEDIA0, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_MEDIA0, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_MEDIA0, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_MEDIA0, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_MEDIA0, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_MEDIA0, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_MEDIA0, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_MEDIA0, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_MEDIA0, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_MEDIA0, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_MEDIA0, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_MEDIA0, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_MEDIA0, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_MEDIA0, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_MEDIA0, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_MEDIA0, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_MEDIA0, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_media1_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_MEDIA1, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_MEDIA1, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_MEDIA1, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_MEDIA1, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_MEDIA1, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_MEDIA1, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_MEDIA1, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_MEDIA1, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_MEDIA1, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_MEDIA1, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_MEDIA1, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_MEDIA1, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_MEDIA1, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_MEDIA1, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_MEDIA1, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_MEDIA1, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_MEDIA1, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_MEDIA1, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_MEDIA1, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_fm_controls[] = {
+	SOC_SINGLE_EXT("Modem", SST_MIX_FM, 0, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("BT", SST_MIX_FM, 1, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec0", SST_MIX_FM, 2, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Codec1", SST_MIX_FM, 3, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sprot_L0", SST_MIX_FM, 4, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L1", SST_MIX_FM, 5, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media_L2", SST_MIX_FM, 6, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Probe", SST_MIX_FM, 7, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Sidetone", SST_MIX_FM, 8, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Tx", SST_MIX_FM, 9, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Speech_Rx", SST_MIX_FM, 10, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Tone", SST_MIX_FM, 11, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Voip", SST_MIX_FM, 12, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM0", SST_MIX_FM, 13, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("PCM1", SST_MIX_FM, 14, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media0", SST_MIX_FM, 15, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media1", SST_MIX_FM, 16, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("Media2", SST_MIX_FM, 17, 1, 0,
+		sst_mix_get, sst_mix_put),
+	SOC_SINGLE_EXT("FM", SST_MIX_FM, 18, 1, 0,
+		sst_mix_get, sst_mix_put),
+};
+
+static const struct snd_kcontrol_new sst_mix_sw_modem =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 0, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_codec0 =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 1, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_codec1 =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 2, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_sprot_l0 =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 3, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_media_l1 =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 4, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_media_l2 =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 5, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_speech_tx =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 6, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_speech_rx =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 7, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_voip =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 8, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_pcm0 =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 9, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_pcm1 =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 10, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_pcm2 =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 11, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_aware =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 12, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_vad =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 13, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_media0 =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 14, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_media1 =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 15, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_mix_sw_fm =
+	SOC_SINGLE_EXT("Switch", SST_MIX_SWITCH, 16, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_modem =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 0, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_codec0 =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 1, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_codec1 =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 2, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_speech_tx =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 6, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_speech_rx =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 7, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_voip =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 8, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_pcm0 =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 9, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_pcm1 =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 10, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_pcm2 =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 11, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_aware =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 12, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_vad =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 13, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_media0 =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 14, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_media1 =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 15, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_out_sw_fm =
+	SOC_SINGLE_EXT("Switch", SST_OUT_SWITCH, 16, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_modem =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 0, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_codec0 =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 1, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_codec1 =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 2, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_sidetone =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 3, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_speech_tx =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 4, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_speech_rx  =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 5, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_tone =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 6, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_voip =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 7, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_pcm0 =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 8, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_pcm1 =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 9, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_media0 =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 10, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_media1 =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 11, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_media2 =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 12, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_kcontrol_new sst_in_sw_fm =
+	SOC_SINGLE_EXT("Switch", SST_IN_SWITCH, 13, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const struct snd_soc_dapm_widget sst_dapm_widgets[] = {
+	SND_SOC_DAPM_INPUT("Modem IN"),
+	SND_SOC_DAPM_INPUT("Codec IN0"),
+	SND_SOC_DAPM_INPUT("Codec IN1"),
+	SND_SOC_DAPM_INPUT("Tone IN"),
+	SND_SOC_DAPM_INPUT("FM IN"),
+	SND_SOC_DAPM_OUTPUT("Modem OUT"),
+	SND_SOC_DAPM_OUTPUT("Codec OUT0"),
+	SND_SOC_DAPM_OUTPUT("Codec OUT1"),
+	SND_SOC_DAPM_OUTPUT("FM OUT"),
+	SND_SOC_DAPM_AIF_IN("Voip IN", "VoIP", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_IN("Media IN0", "Compress", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_IN("Media IN1", "PCM", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("Voip OUT", "VoIP", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("PCM1 OUT", "Capture", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("Aware OUT", "Aware", 0, SND_SOC_NOPM, 0, 0),
+	SND_SOC_DAPM_AIF_OUT("VAD OUT", "VAD", 0, SND_SOC_NOPM, 0, 0),
+
+	/* output mixers */
+	SND_SOC_DAPM_MIXER("MIX Modem", SND_SOC_NOPM, 0, 0,
+		sst_mix_modem_controls, ARRAY_SIZE(sst_mix_modem_controls)),
+	SND_SOC_DAPM_MIXER("MIX Codec0", SND_SOC_NOPM, 0, 0,
+		sst_mix_codec0_controls , ARRAY_SIZE(sst_mix_codec0_controls)),
+	SND_SOC_DAPM_MIXER("MIX Codec1", SND_SOC_NOPM, 0, 0,
+		sst_mix_codec1_controls, ARRAY_SIZE(sst_mix_codec1_controls)),
+	SND_SOC_DAPM_MIXER("MIX Sprot L0", SND_SOC_NOPM, 0, 0,
+		sst_mix_sprot_l0_controls, ARRAY_SIZE(sst_mix_sprot_l0_controls)),
+	SND_SOC_DAPM_MIXER("MIX Media L1", SND_SOC_NOPM, 0, 0,
+		sst_mix_media_l1_controls, ARRAY_SIZE(sst_mix_media_l1_controls)),
+	SND_SOC_DAPM_MIXER("MIX Media L2", SND_SOC_NOPM, 0, 0,
+		sst_mix_media_l2_controls, ARRAY_SIZE(sst_mix_media_l2_controls)),
+	SND_SOC_DAPM_MIXER("MIX Speech Tx", SND_SOC_NOPM, 0, 0,
+		sst_mix_speech_tx_controls, ARRAY_SIZE(sst_mix_speech_tx_controls)),
+	SND_SOC_DAPM_MIXER("MIX Speech Rx", SND_SOC_NOPM, 0, 0,
+		sst_mix_speech_rx_controls, ARRAY_SIZE(sst_mix_speech_rx_controls)),
+	SND_SOC_DAPM_MIXER("MIX Voip", SND_SOC_NOPM, 0, 0,
+		sst_mix_voip_controls, ARRAY_SIZE(sst_mix_voip_controls)),
+	SND_SOC_DAPM_MIXER("MIX PCM0", SND_SOC_NOPM, 0, 0,
+		sst_mix_pcm0_controls, ARRAY_SIZE(sst_mix_pcm0_controls)),
+	SND_SOC_DAPM_MIXER("MIX PCM1", SND_SOC_NOPM, 0, 0,
+		sst_mix_pcm1_controls, ARRAY_SIZE(sst_mix_pcm1_controls)),
+	SND_SOC_DAPM_MIXER("MIX PCM2", SND_SOC_NOPM, 0, 0,
+		sst_mix_pcm2_controls, ARRAY_SIZE(sst_mix_pcm2_controls)),
+	SND_SOC_DAPM_MIXER("MIX Aware", SND_SOC_NOPM, 0, 0,
+		sst_mix_aware_controls, ARRAY_SIZE(sst_mix_aware_controls)),
+	SND_SOC_DAPM_MIXER("MIX VAD", SND_SOC_NOPM, 0, 0,
+		sst_mix_vad_controls, ARRAY_SIZE(sst_mix_vad_controls)),
+	SND_SOC_DAPM_MIXER("MIX Media0", SND_SOC_NOPM, 0, 0,
+		sst_mix_media0_controls, ARRAY_SIZE(sst_mix_media0_controls)),
+	SND_SOC_DAPM_MIXER("MIX Media1", SND_SOC_NOPM, 0, 0,
+		sst_mix_media1_controls, ARRAY_SIZE(sst_mix_media1_controls)),
+	SND_SOC_DAPM_MIXER("MIX FM", SND_SOC_NOPM, 0, 0,
+		sst_mix_fm_controls, ARRAY_SIZE(sst_mix_fm_controls)),
+
+	/* switches for mixer outputs */
+	SND_SOC_DAPM_SWITCH("Mix Modem Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_modem),
+	SND_SOC_DAPM_SWITCH("Mix Codec0 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_codec0),
+	SND_SOC_DAPM_SWITCH("Mix Codec1 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_codec1),
+	SND_SOC_DAPM_SWITCH("Mix Sprot L0 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_sprot_l0),
+	SND_SOC_DAPM_SWITCH("Mix Media L1 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_media_l1),
+	SND_SOC_DAPM_SWITCH("Mix Media L2 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_media_l2),
+	SND_SOC_DAPM_SWITCH("Mix Speech Tx Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_speech_tx),
+	SND_SOC_DAPM_SWITCH("Mix Speech Rx Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_speech_rx),
+	SND_SOC_DAPM_SWITCH("Mix Voip Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_voip),
+	SND_SOC_DAPM_SWITCH("Mix PCM0 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_pcm0),
+	SND_SOC_DAPM_SWITCH("Mix PCM1 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_pcm1),
+	SND_SOC_DAPM_SWITCH("Mix PCM2 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_pcm2),
+	SND_SOC_DAPM_SWITCH("Mix Aware Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_aware),
+	SND_SOC_DAPM_SWITCH("Mix VAD Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_vad),
+	SND_SOC_DAPM_SWITCH("Mix Media0 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_media0),
+	SND_SOC_DAPM_SWITCH("Mix Media1 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_media1),
+	SND_SOC_DAPM_SWITCH("Mix FM Switch", SND_SOC_NOPM, 0, 0,
+			&sst_mix_sw_fm),
+
+	/* output pipeline switches */
+	SND_SOC_DAPM_SWITCH("Out Modem Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_modem),
+	SND_SOC_DAPM_SWITCH("Out Codec0 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_codec0),
+	SND_SOC_DAPM_SWITCH("Out Codec1 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_codec1),
+	SND_SOC_DAPM_SWITCH("Out Speech Tx Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_speech_tx),
+	SND_SOC_DAPM_SWITCH("Out Speech Rx Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_speech_rx),
+	SND_SOC_DAPM_SWITCH("Out Voip Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_voip),
+	SND_SOC_DAPM_SWITCH("Out PCM0 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_pcm0),
+	SND_SOC_DAPM_SWITCH("Out PCM1 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_pcm1),
+	SND_SOC_DAPM_SWITCH("Out PCM2 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_pcm2),
+	SND_SOC_DAPM_SWITCH("Out Aware Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_aware),
+	SND_SOC_DAPM_SWITCH("Out VAD Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_vad),
+	SND_SOC_DAPM_SWITCH("Out Media0 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_media0),
+	SND_SOC_DAPM_SWITCH("Out Media1 Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_media1),
+	SND_SOC_DAPM_SWITCH("Out FM Switch", SND_SOC_NOPM, 0, 0,
+			&sst_out_sw_fm),
+
+	/* Input pipeline switches */
+	SND_SOC_DAPM_SWITCH("In Modem Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_modem),
+	SND_SOC_DAPM_SWITCH("In Codec0 Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_codec0),
+	SND_SOC_DAPM_SWITCH("In Codec1 Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_codec1),
+	SND_SOC_DAPM_SWITCH("In Speech Tx Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_speech_tx),
+	SND_SOC_DAPM_SWITCH("In Speech Rx Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_speech_rx),
+	SND_SOC_DAPM_SWITCH("In Tone Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_tone),
+	SND_SOC_DAPM_SWITCH("In Voip Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_voip),
+	SND_SOC_DAPM_SWITCH("In PCM0 Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_pcm0),
+	SND_SOC_DAPM_SWITCH("In PCM1 Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_pcm1),
+	SND_SOC_DAPM_SWITCH("In Media0 Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_media0),
+	SND_SOC_DAPM_SWITCH("In Media1 Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_media1),
+	SND_SOC_DAPM_SWITCH("In Media2 Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_media2),
+	SND_SOC_DAPM_SWITCH("In FM Switch", SND_SOC_NOPM, 0, 0,
+		       &sst_in_sw_fm),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+	/* media mixer settings */
+	{ "In Media0 Switch", "Switch", "Media IN0"},
+	{ "In Media1 Switch", "Switch", "Media IN1"},
+	{ "MIX Media0", "Media0", "In Media0 Switch"},
+	{ "MIX Media0", "Media1", "In Media1 Switch"},
+	{ "MIX Media0", "Media2", "In Media2 Switch"},
+	{ "MIX Media1", "Media0", "In Media0 Switch"},
+	{ "MIX Media1", "Media1", "In Media1 Switch"},
+	{ "MIX Media1", "Media2", "In Media2 Switch"},
+
+	/* media to main mixer intercon */
+	/* two media paths from media to main */
+	{ "Mix Media0 Switch", "Switch", "MIX Media0"},
+	{ "Out Media0 Switch", "Switch", "Mix Media0 Switch"},
+	{ "In PCM0 Switch", "Switch", "Out Media0 Switch"},
+	{ "Mix Media1 Switch", "Switch", "MIX Media1"},
+	{ "Out Media1 Switch", "Switch", "Mix Media1 Switch"},
+	{ "In PCM1 Switch", "Switch", "Out Media1 Switch"},
+	/* one back from main to media */
+	{ "Mix PCM0 Switch", "Switch", "MIX PCM0"},
+	{ "Out PCM0 Switch", "Switch", "Mix PCM0 Switch"},
+	{ "In Media2 Switch", "Switch", "Out PCM0 Switch"},
+
+	/* main mixer inputs - all inputs connect to mixer */
+	{ "MIX Modem", "Modem", "In Modem Switch"},
+	{ "MIX Modem", "Codec0", "In Codec0 Switch"},
+	{ "MIX Modem", "Codec1", "In Codec1 Switch"},
+	{ "MIX Modem", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX Modem", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX Modem", "Tone", "In Tone Switch"},
+	{ "MIX Modem", "Voip", "In Voip Switch"},
+	{ "MIX Modem", "PCM0", "In PCM0 Switch"},
+	{ "MIX Modem", "PCM1", "In PCM1 Switch"},
+	{ "MIX Modem", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX Modem", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX Modem", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX Modem", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX Modem", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX Codec0", "Modem", "In Modem Switch"},
+	{ "MIX Codec0", "Codec0", "In Codec0 Switch"},
+	{ "MIX Codec0", "Codec1", "In Codec1 Switch"},
+	{ "MIX Codec0", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX Codec0", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX Codec0", "Tone", "In Tone Switch"},
+	{ "MIX Codec0", "Voip", "In Voip Switch"},
+	{ "MIX Codec0", "PCM0", "In PCM0 Switch"},
+	{ "MIX Codec0", "PCM1", "In PCM1 Switch"},
+	{ "MIX Codec0", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX Codec0", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX Codec0", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX Codec0", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX Codec0", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX Codec1", "Modem", "In Modem Switch"},
+	{ "MIX Codec1", "Codec0", "In Codec0 Switch"},
+	{ "MIX Codec1", "Codec1", "In Codec1 Switch"},
+	{ "MIX Codec1", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX Codec1", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX Codec1", "Tone", "In Tone Switch"},
+	{ "MIX Codec1", "Voip", "In Voip Switch"},
+	{ "MIX Codec1", "PCM0", "In PCM0 Switch"},
+	{ "MIX Codec1", "PCM1", "In PCM1 Switch"},
+	{ "MIX Codec1", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX Codec1", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX Codec1", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX Codec1", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX Codec1", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX Sprot L0", "Modem", "In Modem Switch"},
+	{ "MIX Sprot L0", "Codec0", "In Codec0 Switch"},
+	{ "MIX Sprot L0", "Codec1", "In Codec1 Switch"},
+	{ "MIX Sprot L0", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX Sprot L0", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX Sprot L0", "Tone", "In Tone Switch"},
+	{ "MIX Sprot L0", "Voip", "In Voip Switch"},
+	{ "MIX Sprot L0", "PCM0", "In PCM0 Switch"},
+	{ "MIX Sprot L0", "PCM1", "In PCM1 Switch"},
+	{ "MIX Sprot L0", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX Sprot L0", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX Sprot L0", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX Sprot L0", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX Sprot L0", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX Media L1", "Modem", "In Modem Switch"},
+	{ "MIX Media L1", "Codec0", "In Codec0 Switch"},
+	{ "MIX Media L1", "Codec1", "In Codec1 Switch"},
+	{ "MIX Media L1", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX Media L1", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX Media L1", "Tone", "In Tone Switch"},
+	{ "MIX Media L1", "Voip", "In Voip Switch"},
+	{ "MIX Media L1", "PCM0", "In PCM0 Switch"},
+	{ "MIX Media L1", "PCM1", "In PCM1 Switch"},
+	{ "MIX Media L1", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX Media L1", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX Media L1", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX Media L1", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX Media L1", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX Media L2", "Modem", "In Modem Switch"},
+	{ "MIX Media L2", "Codec0", "In Codec0 Switch"},
+	{ "MIX Media L2", "Codec1", "In Codec1 Switch"},
+	{ "MIX Media L2", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX Media L2", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX Media L2", "Tone", "In Tone Switch"},
+	{ "MIX Media L2", "Voip", "In Voip Switch"},
+	{ "MIX Media L2", "PCM0", "In PCM0 Switch"},
+	{ "MIX Media L2", "PCM1", "In PCM1 Switch"},
+	{ "MIX Media L2", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX Media L2", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX Media L2", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX Media L2", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX Media L2", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX Speech Rx", "Modem", "In Modem Switch"},
+	{ "MIX Speech Rx", "Codec0", "In Codec0 Switch"},
+	{ "MIX Speech Rx", "Codec1", "In Codec1 Switch"},
+	{ "MIX Speech Rx", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX Speech Rx", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX Speech Rx", "Tone", "In Tone Switch"},
+	{ "MIX Speech Rx", "Voip", "In Voip Switch"},
+	{ "MIX Speech Rx", "PCM0", "In PCM0 Switch"},
+	{ "MIX Speech Rx", "PCM1", "In PCM1 Switch"},
+	{ "MIX Speech Rx", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX Speech Rx", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX Speech Rx", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX Speech Rx", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX Speech Rx", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX Speech Tx", "Modem", "In Modem Switch"},
+	{ "MIX Speech Tx", "Codec0", "In Codec0 Switch"},
+	{ "MIX Speech Tx", "Codec1", "In Codec1 Switch"},
+	{ "MIX Speech Tx", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX Speech Tx", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX Speech Tx", "Tone", "In Tone Switch"},
+	{ "MIX Speech Tx", "Voip", "In Voip Switch"},
+	{ "MIX Speech Tx", "PCM0", "In PCM0 Switch"},
+	{ "MIX Speech Tx", "PCM1", "In PCM1 Switch"},
+	{ "MIX Speech Tx", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX Speech Tx", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX Speech Tx", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX Speech Tx", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX Speech Tx", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX Voip", "Modem", "In Modem Switch"},
+	{ "MIX Voip", "Codec0", "In Codec0 Switch"},
+	{ "MIX Voip", "Codec1", "In Codec1 Switch"},
+	{ "MIX Voip", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX Voip", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX Voip", "Tone", "In Tone Switch"},
+	{ "MIX Voip", "Voip", "In Voip Switch"},
+	{ "MIX Voip", "PCM0", "In PCM0 Switch"},
+	{ "MIX Voip", "PCM1", "In PCM1 Switch"},
+	{ "MIX Voip", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX Voip", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX Voip", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX Voip", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX Voip", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX PCM0", "Modem", "In Modem Switch"},
+	{ "MIX PCM0", "Codec0", "In Codec0 Switch"},
+	{ "MIX PCM0", "Codec1", "In Codec1 Switch"},
+	{ "MIX PCM0", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX PCM0", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX PCM0", "Tone", "In Tone Switch"},
+	{ "MIX PCM0", "Voip", "In Voip Switch"},
+	{ "MIX PCM0", "PCM0", "In PCM0 Switch"},
+	{ "MIX PCM0", "PCM1", "In PCM1 Switch"},
+	{ "MIX PCM0", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX PCM0", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX PCM0", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX PCM0", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX PCM0", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX PCM1", "Modem", "In Modem Switch"},
+	{ "MIX PCM1", "Codec0", "In Codec0 Switch"},
+	{ "MIX PCM1", "Codec1", "In Codec1 Switch"},
+	{ "MIX PCM1", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX PCM1", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX PCM1", "Tone", "In Tone Switch"},
+	{ "MIX PCM1", "Voip", "In Voip Switch"},
+	{ "MIX PCM1", "PCM0", "In PCM0 Switch"},
+	{ "MIX PCM1", "PCM1", "In PCM1 Switch"},
+	{ "MIX PCM1", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX PCM1", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX PCM1", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX PCM1", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX PCM1", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX PCM2", "Modem", "In Modem Switch"},
+	{ "MIX PCM2", "Codec0", "In Codec0 Switch"},
+	{ "MIX PCM2", "Codec1", "In Codec1 Switch"},
+	{ "MIX PCM2", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX PCM2", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX PCM2", "Tone", "In Tone Switch"},
+	{ "MIX PCM2", "Voip", "In Voip Switch"},
+	{ "MIX PCM2", "PCM0", "In PCM0 Switch"},
+	{ "MIX PCM2", "PCM1", "In PCM1 Switch"},
+	{ "MIX PCM2", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX PCM2", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX PCM2", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX PCM2", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX PCM2", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX Aware", "Modem", "In Modem Switch"},
+	{ "MIX Aware", "Codec0", "In Codec0 Switch"},
+	{ "MIX Aware", "Codec1", "In Codec1 Switch"},
+	{ "MIX Aware", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX Aware", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX Aware", "Tone", "In Tone Switch"},
+	{ "MIX Aware", "Voip", "In Voip Switch"},
+	{ "MIX Aware", "PCM0", "In PCM0 Switch"},
+	{ "MIX Aware", "PCM1", "In PCM1 Switch"},
+	{ "MIX Aware", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX Aware", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX Aware", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX Aware", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX Aware", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX VAD", "Modem", "In Modem Switch"},
+	{ "MIX VAD", "Codec0", "In Codec0 Switch"},
+	{ "MIX VAD", "Codec1", "In Codec1 Switch"},
+	{ "MIX VAD", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX VAD", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX VAD", "Tone", "In Tone Switch"},
+	{ "MIX VAD", "Voip", "In Voip Switch"},
+	{ "MIX VAD", "PCM0", "In PCM0 Switch"},
+	{ "MIX VAD", "PCM1", "In PCM1 Switch"},
+	{ "MIX VAD", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX VAD", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX VAD", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX VAD", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX VAD", "Sidetone", "Mix Speech Tx Switch"},
+
+	{ "MIX FM", "Modem", "In Modem Switch"},
+	{ "MIX FM", "Codec0", "In Codec0 Switch"},
+	{ "MIX FM", "Codec1", "In Codec1 Switch"},
+	{ "MIX FM", "Speech_Tx", "In Speech Tx Switch"},
+	{ "MIX FM", "Speech_Rx", "In Speech Rx Switch"},
+	{ "MIX FM", "Tone", "In Tone Switch"},
+	{ "MIX FM", "Voip", "In Voip Switch"},
+	{ "MIX FM", "PCM0", "In PCM0 Switch"},
+	{ "MIX FM", "PCM1", "In PCM1 Switch"},
+	{ "MIX FM", "FM", "In FM Switch"},
+	/* loops have output switches coming back to mixers */
+	{ "MIX FM", "Sprot_L0", "Mix Sprot L0 Switch"},
+	{ "MIX FM", "Media_L1", "Mix Media L1 Switch"},
+	{ "MIX FM", "Media_L2", "Mix Media L2 Switch"},
+	/* sidetone comes from speech out */
+	{ "MIX FM", "Sidetone", "Mix Speech Tx Switch"},
+
+	/* now connect the mixers to output switches */
+	{ "Mix Modem Switch", "Switch", "MIX Modem"},
+	{ "Out Modem Switch", "Switch", "Mix Modem Switch"},
+	{ "Mix Codec0 Switch", "Switch", "MIX Codec0"},
+	{ "Out Codec0 Switch", "Switch", "Mix Codec0 Switch"},
+	{ "Mix Codec1 Switch", "Switch", "MIX Codec1"},
+	{ "Out Codec1 Switch", "Switch", "Mix Codec1 Switch"},
+	{ "Mix Speech Tx Switch", "Switch", "MIX Speech Tx"},
+	{ "Out Speech Tx Switch", "Switch", "Mix Speech Tx Switch"},
+	{ "Mix Speech Rx Switch", "Switch", "MIX Speech Rx"},
+	{ "Out Speech Rx Switch", "Switch", "Mix Speech Rx Switch"},
+	{ "Mix Voip Switch", "Switch", "MIX Voip"},
+	{ "Out Voip Switch", "Switch", "Mix Voip Switch"},
+	{ "Mix Aware Switch", "Switch", "MIX Aware"},
+	{ "Out Aware Switch", "Switch", "Mix Aware Switch"},
+	{ "Mix VAD Switch", "Switch", "MIX VAD"},
+	{ "Out VAD Switch", "Switch", "Mix VAD Switch"},
+	{ "Mix FM Switch", "Switch", "MIX FM"},
+	{ "Out FM Switch", "Switch", "Mix FM Switch"},
+	{ "Mix PCM1 Switch", "Switch", "MIX PCM1"},
+	{ "Out PCM1 Switch", "Switch", "Mix PCM1 Switch"},
+	{ "Mix PCM2 Switch", "Switch", "MIX PCM2"},
+	{ "Out PCM2 Switch", "Switch", "Mix PCM2 Switch"},
+
+	/* the loops
+	 * media loops dont have i/p o/p switches, just mixer enable
+	 */
+	{ "Mix Sprot L0 Switch", "Switch", "MIX Sprot L0"},
+	{ "Mix Media L1 Switch", "Switch", "MIX Media L1"},
+	{ "Mix Media L2 Switch", "Switch", "MIX Media L2"},
+	/* so no need as mixer switches are
+	 * inputs to all mixers
+	 * need to connect speech loops here
+	 */
+	{ "In Speech Rx Switch", "Switch", "Out Speech Rx Switch"},
+	{ "In Speech Tx Switch", "Switch", "Out Speech Tx Switch"},
+	/* last one, connect the output switches to ip's
+	 * and op's. Also connect the AIFs
+	 */
+	{ "In Modem Switch", "Switch", "Modem IN"},
+	{ "In Codec0 Switch", "Switch", "Codec IN0"},
+	{ "In Codec1 Switch", "Switch", "Codec IN1"},
+	{ "In Tone Switch", "Switch", "Tone IN"},
+	{ "In FM Switch", "Switch", "FM IN"},
+
+	{ "Modem OUT", NULL, "Out Modem Switch"},
+	{ "Codec OUT0", NULL, "Out Codec0 Switch"},
+	{ "Codec OUT1", NULL, "Out Codec1 Switch"},
+	{ "FM OUT", NULL, "Out FM Switch"},
+
+	{ "In Voip Switch", "Switch", "Voip IN"},
+
+	{ "Voip OUT", NULL, "Out Voip Switch"},
+	{ "PCM1 OUT", NULL, "Out PCM1 Switch"},
+	{ "Aware OUT", NULL, "Out Aware Switch"},
+	{ "VAD OUT", NULL, "Out VAD Switch"},
+};
+
+int sst_byte_control_get(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+
+	pr_debug("in %s\n", __func__);
+	memcpy(ucontrol->value.bytes.data, sst->byte_stream, SST_MAX_BIN_BYTES);
+	print_hex_dump_bytes(__func__, DUMP_PREFIX_OFFSET,
+			     (const void *)sst->byte_stream, 32);
+	return 0;
+}
+
+static int sst_check_binary_input(char *stream)
+{
+	struct snd_sst_bytes_v2 *bytes = (struct snd_sst_bytes_v2 *)stream;
+
+	if (bytes->len == 0 || bytes->len > 1000) {
+		pr_err("length out of bounds %d\n", bytes->len);
+		return -EINVAL;
+	}
+	if (bytes->type == 0 || bytes->type > SND_SST_BYTES_GET) {
+		pr_err("type out of bounds: %d\n", bytes->type);
+		return -EINVAL;
+	}
+	if (bytes->block > 1) {
+		pr_err("block invalid %d\n", bytes->block);
+		return -EINVAL;
+	}
+	if (bytes->task_id == SST_TASK_ID_NONE || bytes->task_id > SST_TASK_ID_MAX) {
+		pr_err("taskid invalid %d\n", bytes->task_id);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int sst_byte_control_set(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	int ret = 0;
+
+	pr_debug("in %s\n", __func__);
+	mutex_lock(&sst->lock);
+	memcpy(sst->byte_stream, ucontrol->value.bytes.data, SST_MAX_BIN_BYTES);
+	if (0 != sst_check_binary_input(sst->byte_stream)) {
+		mutex_unlock(&sst->lock);
+		return -EINVAL;
+	}
+	print_hex_dump_bytes(__func__, DUMP_PREFIX_OFFSET,
+			     (const void *)sst->byte_stream, 32);
+	ret = sst_dsp->ops->set_generic_params(SST_SET_BYTE_STREAM, sst->byte_stream);
+	mutex_unlock(&sst->lock);
+
+	return ret;
+}
+
+static int sst_pipe_id_control_get(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	int ret = 0;
+
+	ucontrol->value.integer.value[0] = sst->pipe_id;
+
+	return ret;
+}
+
+static int sst_pipe_id_control_set(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	int ret = 0;
+
+	sst->pipe_id = ucontrol->value.integer.value[0];
+	pr_debug("%s: pipe_id %d", __func__, sst->pipe_id);
+
+	return ret;
+}
+
+/* dB range for mrfld compress volume is -144dB to +36dB.
+ * Gain library expects user input in terms of 0.1dB, for example,
+ * 60 (in decimal) represents 6dB.
+ * MW will pass 2's complement value for negative dB values.
+ */
+static int sst_compr_vol_get(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	struct sst_algo_int_control_v2 *amc = (void *)kcontrol->private_value;
+	u16 gain;
+	unsigned int gain_offset, ret;
+
+	sst_create_compr_vol_ipc(sst->byte_stream, SND_SST_BYTES_GET, amc);
+	mutex_lock(&sst->lock);
+	ret = sst_dsp->ops->set_generic_params(SST_SET_BYTE_STREAM,
+						sst->byte_stream);
+	mutex_unlock(&sst->lock);
+	if (ret) {
+		pr_err("failed to get compress vol from fw: %d\n", ret);
+		return ret;
+	}
+	gain_offset = sizeof(struct snd_sst_bytes_v2) +
+				sizeof(struct ipc_dsp_hdr);
+
+	/* Get params format for vol ctrl lib, size 6 bytes :
+	 * u16 left_gain, u16 right_gain, u16 ramp
+	 */
+	memcpy(&gain,
+		(unsigned int *)(sst->byte_stream + gain_offset),
+		sizeof(u16));
+	pr_debug("%s: cell_gain = %d\n", __func__, gain);
+	amc->value = gain;
+	ucontrol->value.integer.value[0] = gain;
+	return 0;
+}
+
+static int sst_compr_vol_set(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	struct sst_algo_int_control_v2 *amc = (void *)kcontrol->private_value;
+	int ret = 0;
+	unsigned int old_val;
+
+	pr_debug("%s: cell_gain = %ld\n", __func__,\
+				ucontrol->value.integer.value[0]);
+	old_val = amc->value;
+	amc->value = ucontrol->value.integer.value[0];
+	sst_create_compr_vol_ipc(sst->byte_stream, SND_SST_BYTES_SET,
+					amc);
+
+	mutex_lock(&sst->lock);
+	ret = sst_dsp->ops->set_generic_params(SST_SET_BYTE_STREAM,
+						sst->byte_stream);
+	mutex_unlock(&sst->lock);
+	if (ret) {
+		pr_err("failed to set compress vol in fw: %d\n", ret);
+		amc->value = old_val;
+		return ret;
+	}
+	return 0;
+}
+
+static int sst_vtsv_enroll_set(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	int ret = 0;
+
+	sst->vtsv_enroll = ucontrol->value.integer.value[0];
+	mutex_lock(&sst->lock);
+	if (sst->vtsv_enroll)
+		ret = sst_dsp->ops->set_generic_params(SST_SET_VTSV_INFO,
+					(void *)&sst->vtsv_enroll);
+	mutex_unlock(&sst->lock);
+	return ret;
+}
+
+static int sst_vtsv_enroll_get(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+
+	ucontrol->value.integer.value[0] = sst->vtsv_enroll;
+	return 0;
+}
+
+/* This value corresponds to two's complement value of -10 or -1dB */
+#define SST_COMPR_VOL_MAX_INTEG_GAIN 0xFFF6
+#define SST_COMPR_VOL_MUTE 0xFA60 /* 2's complement of -1440 or -144dB*/
+
+
+static const struct snd_kcontrol_new sst_mrfld_controls[] = {
+	SND_SOC_BYTES_EXT("SST Byte control", SST_MAX_BIN_BYTES,
+		       sst_byte_control_get, sst_byte_control_set),
+	SOC_SINGLE_EXT("SST Pipe_id control", SST_PIPE_CONTROL, 0, 0x9A, 0,
+		sst_pipe_id_control_get, sst_pipe_id_control_set),
+	SST_ALGO_KCONTROL_INT("Compress Volume", SST_COMPRESS_VOL,
+		0, SST_COMPR_VOL_MAX_INTEG_GAIN, 0,
+		sst_compr_vol_get, sst_compr_vol_set,
+		SST_ALGO_VOLUME_CONTROL, PIPE_MEDIA0_IN, 0,
+		SST_COMPR_VOL_MUTE),
+	SOC_SINGLE_BOOL_EXT("SST VTSV Enroll", 0, sst_vtsv_enroll_get,
+		       sst_vtsv_enroll_set),
+};
+
+static DEVICE_ULONG_ATTR(low_latency_threshold, 0644, ll_threshold);
+static DEVICE_ULONG_ATTR(deep_buffer_threshold, 0644, db_threshold);
+
+static struct attribute *device_sysfs_attrs[] = {
+	&dev_attr_low_latency_threshold.attr.attr,
+	&dev_attr_deep_buffer_threshold.attr.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group = {
+	.attrs = device_sysfs_attrs,
+};
+
+int sst_dsp_init(struct snd_soc_platform *platform)
+{
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	int error = 0;
+
+	sst->byte_stream = devm_kzalloc(platform->dev,
+			SST_MAX_BIN_BYTES, GFP_KERNEL);
+	if (sst->byte_stream == NULL) {
+		pr_err("kzalloc failed\n");
+		return -ENOMEM;
+	}
+
+	sst->widget = devm_kzalloc(platform->dev,
+				   SST_NUM_WIDGETS * sizeof(*sst->widget),
+				   GFP_KERNEL);
+	if (sst->widget == NULL) {
+		pr_err("kzalloc failed\n");
+		return -ENOMEM;
+	}
+
+	sst->vtsv_enroll = false;
+	/* Assign the pointer variables */
+	sst->ll_db.low_latency = &ll_threshold;
+	sst->ll_db.deep_buffer = &db_threshold;
+
+	pr_debug("Default ll thres %lu db thres %lu\n", ll_threshold, db_threshold);
+
+	snd_soc_dapm_new_controls(&platform->dapm, sst_dapm_widgets,
+			ARRAY_SIZE(sst_dapm_widgets));
+	snd_soc_dapm_add_routes(&platform->dapm, intercon,
+			ARRAY_SIZE(intercon));
+	snd_soc_dapm_new_widgets(platform->dapm.card);
+	snd_soc_add_platform_controls(platform, sst_mrfld_controls,
+			ARRAY_SIZE(sst_mrfld_controls));
+
+	error = sysfs_create_group(&platform->dev->kobj, &attr_group);
+	if (error)
+		pr_err("failed to create sysfs files  %d\n", error);
+
+	return error;
+}
diff --git a/sound/soc/intel/platform-libs/controls_v2.h b/sound/soc/intel/platform-libs/controls_v2.h
new file mode 100644
index 0000000..b54c947
--- /dev/null
+++ b/sound/soc/intel/platform-libs/controls_v2.h
@@ -0,0 +1,708 @@
+/*
+ *  controls_v2.h - Intel MID Platform driver header file
+ *
+ *  Copyright (C) 2013 Intel Corp
+ *  Author: Ramesh Babu <ramesh.babu.koul@intel.com>
+ *  Author: Omair M Abdullah <omair.m.abdullah@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+
+#ifndef __SST_CONTROLS_V2_H__
+#define __SST_CONTROLS_V2_H__
+
+/*
+ * This section defines the map for the mixer widgets.
+ *
+ * Each mixer will be represented by single value and that value will have each
+ * bit corresponding to one input
+ *
+ * Each out_id will correspond to one mixer and one path. Each input will be
+ * represented by single bit in the register.
+ */
+
+/* mixer register ids here */
+#define SST_MIX(x)		(x)
+
+#define SST_MIX_MODEM		SST_MIX(0)
+#define SST_MIX_BT		SST_MIX(1)
+#define SST_MIX_CODEC0		SST_MIX(2)
+#define SST_MIX_CODEC1		SST_MIX(3)
+#define SST_MIX_LOOP0		SST_MIX(4)
+#define SST_MIX_LOOP1		SST_MIX(5)
+#define SST_MIX_LOOP2		SST_MIX(6)
+#define SST_MIX_PROBE		SST_MIX(7)
+#define SST_MIX_HF_SNS		SST_MIX(8)
+#define SST_MIX_HF		SST_MIX(9)
+#define SST_MIX_SPEECH		SST_MIX(10)
+#define SST_MIX_RXSPEECH	SST_MIX(11)
+#define SST_MIX_VOIP		SST_MIX(12)
+#define SST_MIX_PCM0		SST_MIX(13)
+#define SST_MIX_PCM1		SST_MIX(14)
+#define SST_MIX_PCM2		SST_MIX(15)
+#define SST_MIX_AWARE		SST_MIX(16)
+#define SST_MIX_VAD		SST_MIX(17)
+#define SST_MIX_FM		SST_MIX(18)
+
+#define SST_MIX_MEDIA0		SST_MIX(19)
+#define SST_MIX_MEDIA1		SST_MIX(20)
+
+#define SST_NUM_MIX		(SST_MIX_MEDIA1 + 1)
+
+#define SST_MIX_SWITCH		(SST_NUM_MIX + 1)
+#define SST_OUT_SWITCH		(SST_NUM_MIX + 2)
+#define SST_IN_SWITCH		(SST_NUM_MIX + 3)
+#define SST_MUX_REG		(SST_NUM_MIX + 4)
+#define SST_REG_LAST		(SST_MUX_REG)
+
+/* last entry defines array size */
+#define SST_NUM_WIDGETS		(SST_REG_LAST + 1)
+
+#define SST_BT_FM_MUX_SHIFT	0
+#define SST_VOICE_MODE_SHIFT	1
+#define SST_BT_MODE_SHIFT	2
+
+/* in each mixer register we will define one bit for each input */
+#define SST_MIX_IP(x)		(x)
+
+#define SST_IP_MODEM		SST_MIX_IP(0)
+#define SST_IP_BT		SST_MIX_IP(1)
+#define SST_IP_CODEC0		SST_MIX_IP(2)
+#define SST_IP_CODEC1		SST_MIX_IP(3)
+#define SST_IP_LOOP0		SST_MIX_IP(4)
+#define SST_IP_LOOP1		SST_MIX_IP(5)
+#define SST_IP_LOOP2		SST_MIX_IP(6)
+#define SST_IP_PROBE		SST_MIX_IP(7)
+#define SST_IP_SIDETONE		SST_MIX_IP(8)
+#define SST_IP_TXSPEECH		SST_MIX_IP(9)
+#define SST_IP_SPEECH		SST_MIX_IP(10)
+#define SST_IP_TONE		SST_MIX_IP(11)
+#define SST_IP_VOIP		SST_MIX_IP(12)
+#define SST_IP_PCM0		SST_MIX_IP(13)
+#define SST_IP_PCM1		SST_MIX_IP(14)
+#define SST_IP_LOW_PCM0		SST_MIX_IP(15)
+#define SST_IP_FM		SST_MIX_IP(16)
+#define SST_IP_MEDIA0		SST_MIX_IP(17)
+#define SST_IP_MEDIA1		SST_MIX_IP(18)
+#define SST_IP_MEDIA2		SST_MIX_IP(19)
+#define SST_IP_MEDIA3		SST_MIX_IP(20)
+
+#define SST_IP_LAST		SST_IP_MEDIA3
+
+#define SST_SWM_INPUT_COUNT	(SST_IP_LAST + 1)
+#define SST_CMD_SWM_MAX_INPUTS	6
+
+#define SST_PATH_ID_SHIFT	8
+#define SST_DEFAULT_LOCATION_ID	0xFFFF
+#define SST_DEFAULT_CELL_NBR	0xFF
+#define SST_DEFAULT_MODULE_ID	0xFFFF
+
+/*
+ * Audio DSP Path Ids. Specified by the audio DSP FW
+ */
+enum sst_path_index {
+	SST_PATH_INDEX_MODEM_OUT                = (0x00 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_BT_OUT                   = (0x01 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_CODEC_OUT0               = (0x02 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_CODEC_OUT1               = (0x03 << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_SPROT_LOOP_OUT           = (0x04 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_MEDIA_LOOP1_OUT          = (0x05 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_MEDIA_LOOP2_OUT          = (0x06 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE_OUT                = (0x07 << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_HF_SNS_OUT               = (0x08 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_VOICE_UPLINK_REF2	= (0x08 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_HF_OUT                   = (0x09 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_VOICE_UPLINK_REF1	= (0x09 << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_SPEECH_OUT               = (0x0A << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_VOICE_UPLINK		= (0x0A << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_RX_SPEECH_OUT            = (0x0B << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_VOICE_DOWNLINK		= (0x0B << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_VOIP_OUT                 = (0x0C << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PCM0_OUT                 = (0x0D << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PCM1_OUT                 = (0x0E << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PCM2_OUT                 = (0x0F << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_AWARE_OUT                = (0x10 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_VAD_OUT                  = (0x11 << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_MEDIA0_OUT               = (0x12 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_MEDIA1_OUT               = (0x13 << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_FM_OUT                   = (0x14 << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_PROBE1_PIPE_OUT		= (0x15 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE2_PIPE_OUT		= (0x16 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE3_PIPE_OUT		= (0x17 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE4_PIPE_OUT		= (0x18 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE5_PIPE_OUT		= (0x19 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE6_PIPE_OUT		= (0x1A << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE7_PIPE_OUT		= (0x1B << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE8_PIPE_OUT		= (0x1C << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_SIDETONE_OUT		= (0x1D << SST_PATH_ID_SHIFT),
+
+	/* Start of input paths */
+	SST_PATH_INDEX_MODEM_IN                 = (0x80 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_BT_IN                    = (0x81 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_CODEC_IN0                = (0x82 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_CODEC_IN1                = (0x83 << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_SPROT_LOOP_IN            = (0x84 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_MEDIA_LOOP1_IN           = (0x85 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_MEDIA_LOOP2_IN           = (0x86 << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_PROBE_IN                 = (0x87 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_SIDETONE_IN              = (0x88 << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_TX_SPEECH_IN             = (0x89 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_SPEECH_IN                = (0x8A << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_TONE_IN                  = (0x8B << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_VOIP_IN                  = (0x8C << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_PCM0_IN                  = (0x8D << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PCM1_IN                  = (0x8E << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_MEDIA0_IN                = (0x8F << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_MEDIA1_IN                = (0x90 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_MEDIA2_IN                = (0x91 << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_FM_IN                    = (0x92 << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_PROBE1_PIPE_IN           = (0x93 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE2_PIPE_IN           = (0x94 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE3_PIPE_IN           = (0x95 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE4_PIPE_IN           = (0x96 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE5_PIPE_IN           = (0x97 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE6_PIPE_IN           = (0x98 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE7_PIPE_IN           = (0x99 << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_PROBE8_PIPE_IN           = (0x9A << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_MEDIA3_IN		= (0x9C << SST_PATH_ID_SHIFT),
+	SST_PATH_INDEX_LOW_PCM0_IN		= (0x9D << SST_PATH_ID_SHIFT),
+
+	SST_PATH_INDEX_RESERVED                 = (0xFF << SST_PATH_ID_SHIFT),
+};
+
+/*
+ * switch matrix input path IDs
+ */
+enum sst_swm_inputs {
+	SST_SWM_IN_MODEM	= (SST_PATH_INDEX_MODEM_IN	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_BT		= (SST_PATH_INDEX_BT_IN		  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_CODEC0	= (SST_PATH_INDEX_CODEC_IN0	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_CODEC1	= (SST_PATH_INDEX_CODEC_IN1	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_SPROT_LOOP	= (SST_PATH_INDEX_SPROT_LOOP_IN	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_MEDIA_LOOP1	= (SST_PATH_INDEX_MEDIA_LOOP1_IN  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_MEDIA_LOOP2	= (SST_PATH_INDEX_MEDIA_LOOP2_IN  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_PROBE	= (SST_PATH_INDEX_PROBE_IN	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_SIDETONE	= (SST_PATH_INDEX_SIDETONE_IN	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_TXSPEECH	= (SST_PATH_INDEX_TX_SPEECH_IN	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_SPEECH	= (SST_PATH_INDEX_SPEECH_IN	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_TONE		= (SST_PATH_INDEX_TONE_IN	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_VOIP		= (SST_PATH_INDEX_VOIP_IN	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_PCM0		= (SST_PATH_INDEX_PCM0_IN	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_PCM1		= (SST_PATH_INDEX_PCM1_IN	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_MEDIA0	= (SST_PATH_INDEX_MEDIA0_IN	  | SST_DEFAULT_CELL_NBR), /* Part of Media Mixer */
+	SST_SWM_IN_MEDIA1	= (SST_PATH_INDEX_MEDIA1_IN	  | SST_DEFAULT_CELL_NBR), /* Part of Media Mixer */
+	SST_SWM_IN_MEDIA2	= (SST_PATH_INDEX_MEDIA2_IN	  | SST_DEFAULT_CELL_NBR), /* Part of Media Mixer */
+	SST_SWM_IN_FM		= (SST_PATH_INDEX_FM_IN		  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_MEDIA3	= (SST_PATH_INDEX_MEDIA3_IN	  | SST_DEFAULT_CELL_NBR), /* Part of Media Mixer */
+	SST_SWM_IN_LOW_PCM0	= (SST_PATH_INDEX_LOW_PCM0_IN	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_IN_END		= (SST_PATH_INDEX_RESERVED	  | SST_DEFAULT_CELL_NBR)
+};
+
+/*
+ * switch matrix output path IDs
+ */
+enum sst_swm_outputs {
+	SST_SWM_OUT_MODEM	= (SST_PATH_INDEX_MODEM_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_BT		= (SST_PATH_INDEX_BT_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_CODEC0	= (SST_PATH_INDEX_CODEC_OUT0	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_CODEC1	= (SST_PATH_INDEX_CODEC_OUT1	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_SPROT_LOOP	= (SST_PATH_INDEX_SPROT_LOOP_OUT  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_MEDIA_LOOP1	= (SST_PATH_INDEX_MEDIA_LOOP1_OUT | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_MEDIA_LOOP2	= (SST_PATH_INDEX_MEDIA_LOOP2_OUT | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_PROBE	= (SST_PATH_INDEX_PROBE_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_HF_SNS	= (SST_PATH_INDEX_HF_SNS_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_HF		= (SST_PATH_INDEX_HF_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_SPEECH	= (SST_PATH_INDEX_SPEECH_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_RXSPEECH	= (SST_PATH_INDEX_RX_SPEECH_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_VOIP	= (SST_PATH_INDEX_VOIP_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_PCM0	= (SST_PATH_INDEX_PCM0_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_PCM1	= (SST_PATH_INDEX_PCM1_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_PCM2	= (SST_PATH_INDEX_PCM2_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_AWARE	= (SST_PATH_INDEX_AWARE_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_VAD		= (SST_PATH_INDEX_VAD_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_MEDIA0	= (SST_PATH_INDEX_MEDIA0_OUT	  | SST_DEFAULT_CELL_NBR), /* Part of Media Mixer */
+	SST_SWM_OUT_MEDIA1	= (SST_PATH_INDEX_MEDIA1_OUT	  | SST_DEFAULT_CELL_NBR), /* Part of Media Mixer */
+	SST_SWM_OUT_FM		= (SST_PATH_INDEX_FM_OUT	  | SST_DEFAULT_CELL_NBR),
+	SST_SWM_OUT_END		= (SST_PATH_INDEX_RESERVED	  | SST_DEFAULT_CELL_NBR),
+};
+
+enum sst_ipc_msg {
+	SST_IPC_IA_CMD = 1,
+	SST_IPC_IA_SET_PARAMS,
+	SST_IPC_IA_GET_PARAMS,
+};
+
+enum sst_cmd_type {
+	SST_CMD_BYTES_SET = 1,
+	SST_CMD_BYTES_GET = 2,
+};
+
+enum sst_task {
+	SST_TASK_SBA = 1,
+	SST_TASK_FBA_UL,
+	SST_TASK_MMX,
+	SST_TASK_AWARE,
+	SST_TASK_FBA_DL,
+};
+
+enum sst_type {
+	SST_TYPE_CMD = 1,
+	SST_TYPE_PARAMS,
+};
+
+enum sst_flag {
+	SST_FLAG_BLOCKED = 1,
+	SST_FLAG_NONBLOCK,
+};
+
+/*
+ * Enumeration for indexing the gain cells in VB_SET_GAIN DSP command
+ */
+enum sst_gain_index {
+	/* GAIN IDs for SB task start here */
+	SST_GAIN_INDEX_MODEM_OUT,
+	SST_GAIN_INDEX_MODEM_IN,
+	SST_GAIN_INDEX_BT_OUT,
+	SST_GAIN_INDEX_BT_IN,
+	SST_GAIN_INDEX_FM_OUT,
+
+	SST_GAIN_INDEX_FM_IN,
+	SST_GAIN_INDEX_CODEC_OUT0,
+	SST_GAIN_INDEX_CODEC_OUT1,
+	SST_GAIN_INDEX_CODEC_IN0,
+	SST_GAIN_INDEX_CODEC_IN1,
+
+	SST_GAIN_INDEX_SPROT_LOOP_OUT,
+	SST_GAIN_INDEX_MEDIA_LOOP1_OUT,
+	SST_GAIN_INDEX_MEDIA_LOOP2_OUT,
+	SST_GAIN_INDEX_RX_SPEECH_OUT,
+	SST_GAIN_INDEX_TX_SPEECH_IN,
+
+	SST_GAIN_INDEX_SPEECH_OUT,
+	SST_GAIN_INDEX_SPEECH_IN,
+	SST_GAIN_INDEX_HF_OUT,
+	SST_GAIN_INDEX_HF_SNS_OUT,
+	SST_GAIN_INDEX_TONE_IN,
+
+	SST_GAIN_INDEX_SIDETONE_IN,
+	SST_GAIN_INDEX_PROBE_OUT,
+	SST_GAIN_INDEX_PROBE_IN,
+	SST_GAIN_INDEX_PCM0_IN_LEFT,
+	SST_GAIN_INDEX_PCM0_IN_RIGHT,
+
+	SST_GAIN_INDEX_PCM1_OUT_LEFT,
+	SST_GAIN_INDEX_PCM1_OUT_RIGHT,
+	SST_GAIN_INDEX_PCM1_IN_LEFT,
+	SST_GAIN_INDEX_PCM1_IN_RIGHT,
+	SST_GAIN_INDEX_PCM2_OUT_LEFT,
+
+	SST_GAIN_INDEX_PCM2_OUT_RIGHT,
+	SST_GAIN_INDEX_VOIP_OUT,
+	SST_GAIN_INDEX_VOIP_IN,
+	SST_GAIN_INDEX_AWARE_OUT,
+	SST_GAIN_INDEX_VAD_OUT,
+
+	/* Gain IDs for FBA task start here */
+	SST_GAIN_INDEX_VOICE_UL,
+
+	/* Gain IDs for MMX task start here */
+	SST_GAIN_INDEX_MEDIA0_IN_LEFT,
+	SST_GAIN_INDEX_MEDIA0_IN_RIGHT,
+	SST_GAIN_INDEX_MEDIA1_IN_LEFT,
+	SST_GAIN_INDEX_MEDIA1_IN_RIGHT,
+
+	SST_GAIN_INDEX_MEDIA2_IN_LEFT,
+	SST_GAIN_INDEX_MEDIA2_IN_RIGHT,
+
+	SST_GAIN_INDEX_GAIN_END
+};
+
+/*
+ * Audio DSP module IDs specified by FW spec
+ * TODO: Update with all modules
+ */
+enum sst_module_id {
+	SST_MODULE_ID_GAIN_CELL		  = 0x0067,
+	SST_MODULE_ID_SPROT		  = 0x006D,
+	SST_MODULE_ID_NR		  = 0x0076,
+	SST_MODULE_ID_BWX		  = 0x0077,
+	SST_MODULE_ID_DRP		  = 0x0078,
+	SST_MODULE_ID_MDRP		  = 0x0079,
+
+	SST_MODULE_ID_ANA		  = 0x007A,
+	SST_MODULE_ID_AEC		  = 0x007B,
+	SST_MODULE_ID_NR_SNS		  = 0x007C,
+	SST_MODULE_ID_SER		  = 0x007D,
+	SST_MODULE_ID_AGC		  = 0x007E,
+
+	SST_MODULE_ID_CNI		  = 0x007F,
+	SST_MODULE_ID_CONTEXT_ALGO_AWARE  = 0x0080,
+	SST_MODULE_ID_FIR_24		  = 0x0081,
+	SST_MODULE_ID_IIR_24		  = 0x0082,
+	SST_MODULE_ID_FILT_DCR		  = 0x0082,
+
+	SST_MODULE_ID_ASRC		  = 0x0083,
+	SST_MODULE_ID_TONE_GEN		  = 0x0084,
+	SST_MODULE_ID_BMF		  = 0x0086,
+	SST_MODULE_ID_EDL		  = 0x0087,
+	SST_MODULE_ID_GLC		  = 0x0088,
+
+	SST_MODULE_ID_FIR_16		  = 0x0089,
+	SST_MODULE_ID_IIR_16		  = 0x008A,
+	SST_MODULE_ID_DNR		  = 0x008B,
+
+	SST_MODULE_ID_CNI_TX		  = 0x0090,
+	SST_MODULE_ID_REF_LINE		  = 0x0091,
+	SST_MODULE_ID_VOLUME		  = 0x0092,
+
+	SST_MODULE_ID_TASK		  = 0xFFFF
+};
+
+enum sst_cmd {
+	SBA_IDLE		= 14,
+	SBA_VB_SET_SPEECH_PATH	= 26,
+	MMX_SET_GAIN		= 33,
+	SBA_VB_SET_GAIN		= 33,
+	FBA_VB_RX_CNI		= 35,
+	MMX_SET_GAIN_TIMECONST	= 36,
+	SBA_VB_SET_TIMECONST	= 36,
+	FBA_VB_ANA		= 37,
+	FBA_VB_SET_FIR		= 38,
+	FBA_VB_SET_IIR		= 39,
+	FBA_VB_AEC		= 47,
+	FBA_VB_NR_UL		= 48,
+	FBA_VB_AGC		= 49,
+	FBA_VB_NR_DL		= 55,
+	SBA_PROBE		= 66,
+	MMX_PROBE		= 66,
+	FBA_VB_SET_BIQUAD_D_C	= 69,
+	FBA_VB_DUAL_BAND_COMP	= 70,
+	FBA_VB_SNS		= 72,
+	FBA_VB_SER		= 78,
+	FBA_VB_TX_CNI		= 80,
+	SBA_VB_START		= 85,
+	FBA_VB_SET_REF_LINE	= 94,
+	FBA_VB_SET_DELAY_LINE	= 95,
+	FBA_VB_BWX		= 104,
+	FBA_VB_GMM		= 105,
+	FBA_VB_GLC		= 107,
+	FBA_VB_BMF		= 111,
+	FBA_VB_DNR		= 113,
+	MMX_SET_SWM		= 114,
+	SBA_SET_SWM		= 114,
+	SBA_SET_MDRP            = 116,
+	SBA_HW_SET_SSP		= 117,
+	SBA_SET_MEDIA_LOOP_MAP	= 118,
+	SBA_SET_MEDIA_PATH	= 119,
+	MMX_SET_MEDIA_PATH	= 119,
+	SBA_VB_LPRO		= 126,
+	SBA_VB_SET_FIR          = 128,
+	SBA_VB_SET_IIR          = 129,
+	SBA_SET_SSP_SLOT_MAP	= 130,
+	AWARE_ENV_CLASS_PARAMS	= 130,
+};
+
+enum sst_dsp_switch {
+	SST_SWITCH_OFF = 0,
+	SST_SWITCH_ON = 3,
+};
+
+enum sst_path_switch {
+	SST_PATH_OFF = 0,
+	SST_PATH_ON = 1,
+};
+
+enum sst_swm_state {
+	SST_SWM_OFF = 0,
+	SST_SWM_ON = 3,
+};
+
+#define SST_FILL_LOCATION_IDS(dst, cell_idx, pipe_id)		do {	\
+		dst.location_id.p.cell_nbr_idx = (cell_idx);		\
+		dst.location_id.p.path_id = (pipe_id);			\
+	} while (0)
+#define SST_FILL_LOCATION_ID(dst, loc_id)				(\
+	dst.location_id.f = (loc_id))
+#define SST_FILL_MODULE_ID(dst, mod_id)					(\
+	dst.module_id = (mod_id))
+
+#define SST_FILL_DESTINATION1(dst, id)				do {	\
+		SST_FILL_LOCATION_ID(dst, (id) & 0xFFFF);		\
+		SST_FILL_MODULE_ID(dst, ((id) & 0xFFFF0000) >> 16);	\
+	} while (0)
+#define SST_FILL_DESTINATION2(dst, loc_id, mod_id)		do {	\
+		SST_FILL_LOCATION_ID(dst, loc_id);			\
+		SST_FILL_MODULE_ID(dst, mod_id);			\
+	} while (0)
+#define SST_FILL_DESTINATION3(dst, cell_idx, path_id, mod_id)	do {	\
+		SST_FILL_LOCATION_IDS(dst, cell_idx, path_id);		\
+		SST_FILL_MODULE_ID(dst, mod_id);			\
+	} while (0)
+
+#define SST_FILL_DESTINATION(level, dst, ...)				\
+	SST_FILL_DESTINATION##level(dst, __VA_ARGS__)
+#define SST_FILL_DEFAULT_DESTINATION(dst)				\
+	SST_FILL_DESTINATION(2, dst, SST_DEFAULT_LOCATION_ID, SST_DEFAULT_MODULE_ID)
+
+struct sst_destination_id {
+	union sst_location_id {
+		struct {
+			u8 cell_nbr_idx;	/* module index */
+			u8 path_id;		/* pipe_id */
+		} __packed	p;		/* part */
+		u16		f;		/* full */
+	} __packed location_id;
+	u16	   module_id;
+} __packed;
+
+struct sst_dsp_header {
+	struct sst_destination_id dst;
+	u16 command_id;
+	u16 length;
+} __packed;
+
+/*
+ *
+ * Common Commands
+ *
+ */
+struct sst_cmd_generic {
+	struct sst_dsp_header header;
+} __packed;
+
+struct swm_input_ids {
+	struct sst_destination_id input_id;
+} __packed;
+
+struct sst_cmd_set_swm {
+	struct sst_dsp_header header;
+	struct sst_destination_id output_id;
+	u16    switch_state;
+	u16    nb_inputs;
+	struct swm_input_ids input[SST_CMD_SWM_MAX_INPUTS];
+} __packed;
+
+struct sst_cmd_set_media_path {
+	struct sst_dsp_header header;
+	u16    switch_state;
+} __packed;
+
+struct sst_cmd_set_speech_path {
+	struct sst_dsp_header header;
+	u16    switch_state;
+	struct {
+		u16 rsvd:8;
+		u16 sample_length:2;
+		u16 rate:3;
+		u16 format:3;
+	} config;
+} __packed;
+
+struct gain_cell {
+	struct sst_destination_id dest;
+	s16 cell_gain_left;
+	s16 cell_gain_right;
+	u16 gain_time_constant;
+} __packed;
+
+#define NUM_GAIN_CELLS 1
+struct sst_cmd_set_gain_dual {
+	struct sst_dsp_header header;
+	u16    gain_cell_num;
+	struct gain_cell cell_gains[NUM_GAIN_CELLS];
+} __packed;
+
+struct sst_cmd_set_params {
+	struct sst_destination_id dst;
+	u16 command_id;
+	char params[0];
+} __packed;
+
+/*
+ *
+ * Media (MMX) commands
+ *
+ */
+
+/*
+ *
+ * SBA commands
+ *
+ */
+struct sst_cmd_sba_vb_start {
+	struct sst_dsp_header header;
+} __packed;
+
+union sba_media_loop_params {
+	struct {
+		u16 rsvd:8;
+		u16 sample_length:2;
+		u16 rate:3;
+		u16 format:3;
+	} part;
+	u16 full;
+} __packed;
+
+struct sst_cmd_sba_set_media_loop_map {
+	struct	sst_dsp_header header;
+	u16	switch_state;
+	union	sba_media_loop_params param;
+	u16	map;
+} __packed;
+
+enum sst_ssp_mode {
+	SSP_MODE_MASTER = 0,
+	SSP_MODE_SLAVE = 1,
+};
+
+enum sst_ssp_pcm_mode {
+	SSP_PCM_MODE_NORMAL = 0,
+	SSP_PCM_MODE_NETWORK = 1,
+};
+
+enum sst_ssp_duplex {
+	SSP_DUPLEX = 0,
+	SSP_RX = 1,
+	SSP_TX = 2,
+};
+
+enum sst_ssp_fs_frequency {
+	SSP_FS_8_KHZ = 0,
+	SSP_FS_16_KHZ = 1,
+	SSP_FS_44_1_KHZ = 2,
+	SSP_FS_48_KHZ = 3,
+};
+
+enum sst_ssp_fs_polarity {
+	SSP_FS_ACTIVE_LOW = 0,
+	SSP_FS_ACTIVE_HIGH = 1,
+};
+
+enum sst_ssp_protocol {
+	SSP_MODE_PCM = 0,
+	SSP_MODE_I2S = 1,
+};
+
+enum sst_ssp_port_id {
+	SSP_MODEM = 0,
+	SSP_BT = 1,
+	SSP_FM = 2,
+	SSP_CODEC = 3,
+};
+
+struct sst_cmd_sba_hw_set_ssp {
+	struct sst_dsp_header header;
+	u16 selection;			/* 0:SSP0(def), 1:SSP1, 2:SSP2 */
+
+	u16 switch_state;
+
+	u16 nb_bits_per_slots:6;        /* 0-32 bits, 24 (def) */
+	u16 nb_slots:4;			/* 0-8: slots per frame  */
+	u16 mode:3;			/* 0:Master, 1: Slave  */
+	u16 duplex:3;
+
+	u16 active_tx_slot_map:8;       /* Bit map, 0:off, 1:on */
+	u16 reserved1:8;
+
+	u16 active_rx_slot_map:8;       /* Bit map 0: Off, 1:On */
+	u16 reserved2:8;
+
+	u16 frame_sync_frequency;
+
+	u16 frame_sync_polarity:8;
+	u16 data_polarity:8;
+
+	u16 frame_sync_width;           /* 1 to N clocks */
+	u16 ssp_protocol:8;
+	u16 start_delay:8;		/* Start delay in terms of clock ticks */
+} __packed;
+
+#define SST_MAX_TDM_SLOTS 8
+
+struct sst_param_sba_ssp_slot_map {
+	struct sst_dsp_header header;
+
+	u16 param_id;
+	u16 param_len;
+	u16 ssp_index;
+
+	u8 rx_slot_map[SST_MAX_TDM_SLOTS];
+	u8 tx_slot_map[SST_MAX_TDM_SLOTS];
+} __packed;
+
+enum {
+	SST_PROBE_EXTRACTOR = 0,
+	SST_PROBE_INJECTOR = 1,
+};
+
+struct sst_cmd_probe {
+	struct sst_dsp_header header;
+
+	u16 switch_state;
+	struct sst_destination_id probe_dst;
+
+	u16 shared_mem:1;
+	u16 probe_in:1;
+	u16 probe_out:1;
+	u16 rsvd_1:13;
+
+	u16 rsvd_2:5;
+	u16 probe_mode:2;
+	u16 rsvd_3:1;
+	u16 sample_length:2;
+	u16 rate:3;
+	u16 format:3;
+
+	u16 sm_buf_id;
+
+	u16 gain[6];
+	u16 rsvd_4[9];
+} __packed;
+
+struct sst_probe_config {
+	const char *name;
+	u16 loc_id;
+	u16 mod_id;
+	u8 task_id;
+	struct pcm_cfg {
+		u8 s_length:2;
+		u8 rate:3;
+		u8 format:3;
+	} cfg;
+};
+
+int sst_mix_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol);
+int sst_mix_get(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol);
+#endif
diff --git a/sound/soc/intel/platform-libs/controls_v2_dpcm.c b/sound/soc/intel/platform-libs/controls_v2_dpcm.c
new file mode 100644
index 0000000..644b83c
--- /dev/null
+++ b/sound/soc/intel/platform-libs/controls_v2_dpcm.c
@@ -0,0 +1,1801 @@
+/*
+ *  controls_v2_dpcm.c - Intel MID Platform driver DPCM ALSA controls for Mrfld
+ *
+ *  Copyright (C) 2013 Intel Corp
+ *  Author: Omair Mohammed Abdullah <omair.m.abdullah@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/slab.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+#include "../platform_ipc_v2.h"
+#include "../sst_platform.h"
+#include "../sst_platform_pvt.h"
+#include "controls_v2.h"
+#include "sst_widgets.h"
+
+static inline void sst_fill_byte_control(char *param,
+					 u8 ipc_msg, u8 block,
+					 u8 task_id, u8 pipe_id,
+					 u16 len, void *cmd_data)
+{
+
+	struct snd_sst_bytes_v2 *byte_data = (struct snd_sst_bytes_v2 *)param;
+	byte_data->type = SST_CMD_BYTES_SET;
+	byte_data->ipc_msg = ipc_msg;
+	byte_data->block = block;
+	byte_data->task_id = task_id;
+	byte_data->pipe_id = pipe_id;
+
+	if (len > SST_MAX_BIN_BYTES - sizeof(*byte_data)) {
+		pr_err("%s: command length too big (%u)", __func__, len);
+		len = SST_MAX_BIN_BYTES - sizeof(*byte_data);
+		WARN_ON(1); /* this happens only if code is wrong */
+	}
+	byte_data->len = len;
+	memcpy(byte_data->bytes, cmd_data, len);
+	print_hex_dump_bytes("writing to lpe: ", DUMP_PREFIX_OFFSET,
+			     byte_data, len + sizeof(*byte_data));
+}
+
+static int sst_fill_and_send_cmd(struct sst_data *sst,
+				 u8 ipc_msg, u8 block, u8 task_id, u8 pipe_id,
+				 void *cmd_data, u16 len)
+{
+	int ret = 0;
+
+	mutex_lock(&sst->lock);
+	sst_fill_byte_control(sst->byte_stream, ipc_msg, block, task_id, pipe_id,
+			      len, cmd_data);
+	ret = sst_dsp->ops->set_generic_params(SST_SET_BYTE_STREAM,
+					       sst->byte_stream);
+	mutex_unlock(&sst->lock);
+
+	return ret;
+}
+
+static int sst_probe_get(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	struct sst_probe_value *v = (void *)kcontrol->private_value;
+
+	ucontrol->value.enumerated.item[0] = v->val;
+	return 0;
+}
+
+static int sst_probe_put(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol)
+{
+	struct sst_probe_value *v = (void *)kcontrol->private_value;
+	const struct soc_enum *e = v->p_enum;
+
+	if (ucontrol->value.enumerated.item[0] > e->max - 1)
+		return -EINVAL;
+	v->val = ucontrol->value.enumerated.item[0];
+	return 0;
+}
+
+int sst_probe_enum_info(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct sst_probe_value *v = (void *)kcontrol->private_value;
+	const struct soc_enum *e = v->p_enum;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = e->max;
+
+	if (uinfo->value.enumerated.item > e->max - 1)
+		uinfo->value.enumerated.item = e->max - 1;
+	strcpy(uinfo->value.enumerated.name,
+		e->texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+/*
+ * slot map value is a bitfield where each bit represents a FW channel
+ *
+ *			3 2 1 0		# 0 = codec0, 1 = codec1
+ *			RLRLRLRL	# 3, 4 = reserved
+ *
+ * e.g. slot 0 rx map =	00001100b -> data from slot 0 goes into codec_in1 L,R
+ */
+static u8 sst_ssp_slot_map[SST_MAX_TDM_SLOTS] = {
+	0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, /* default rx map */
+};
+
+/*
+ * channel map value is a bitfield where each bit represents a slot
+ *
+ *			  76543210	# 0 = slot 0, 1 = slot 1
+ *
+ * e.g. codec1_0 tx map = 00000101b -> data from codec_out1_0 goes into slot 0, 2
+ */
+static u8 sst_ssp_channel_map[SST_MAX_TDM_SLOTS] = {
+	0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, /* default tx map */
+};
+
+static int sst_slot_get(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_enum *e = (void *)kcontrol->private_value;
+	unsigned int ctl_no = e->reg;
+	unsigned int is_tx = e->reg2;
+	unsigned int val, mux;
+	u8 *map = is_tx ? sst_ssp_channel_map : sst_ssp_slot_map;
+
+	val = 1 << ctl_no;
+	/* search which slot/channel has this bit set - there should be only one */
+	for (mux = e->max; mux > 0;  mux--)
+		if (map[mux - 1] & val)
+			break;
+
+	ucontrol->value.enumerated.item[0] = mux;
+	pr_debug("%s: %s - %s map = %#x\n", __func__, is_tx ? "tx channel" : "rx slot",
+		 e->texts[mux], mux ? map[mux - 1] : -1);
+	return 0;
+}
+
+/*
+ * (de)interleaver controls are defined in opposite sense to be user-friendly
+ *
+ * Instead of the enum value being the value set to the register, it is the
+ * register address; and the kcontrol_no is the value written to the register.
+ *
+ * This means that whenever an enum is set, we need to clear the bit
+ * for that kcontrol_no for all the interleaver OR deinterleaver registers
+ */
+static int sst_slot_put(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct soc_enum *e = (void *)kcontrol->private_value;
+	int i;
+	unsigned int ctl_no = e->reg;
+	unsigned int is_tx = e->reg2;
+	unsigned int slot_channel_no;
+	unsigned int val, mux;
+	u8 *map = is_tx ? sst_ssp_channel_map : sst_ssp_slot_map;
+
+	val = 1 << ctl_no;
+	mux = ucontrol->value.enumerated.item[0];
+	if (mux > e->max - 1)
+		return -EINVAL;
+
+	/* first clear all registers of this bit */
+	for (i = 0; i < e->max; i++)
+		map[i] &= ~val;
+
+	if (mux == 0) /* kctl set to 'none' */
+		return 0;
+
+	/* offset by one to take "None" into account */
+	slot_channel_no = mux - 1;
+	map[slot_channel_no] |= val;
+
+	pr_debug("%s: %s %s map = %#x\n", __func__, is_tx ? "tx channel" : "rx slot",
+		 e->texts[mux], map[slot_channel_no]);
+	return 0;
+}
+
+/* assumes a boolean mux */
+static inline bool get_mux_state(struct sst_data *sst, unsigned int reg, unsigned int shift)
+{
+	return (sst_reg_read(sst, reg, shift, 1) == 1);
+}
+
+static int sst_mux_get(struct snd_kcontrol *kcontrol,
+		       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
+	struct sst_data *sst = snd_soc_platform_get_drvdata(widget->platform);
+	struct soc_enum *e = (void *)kcontrol->private_value;
+	unsigned int max = e->max - 1;
+
+	ucontrol->value.enumerated.item[0] = sst_reg_read(sst, e->reg, e->shift_l, max);
+	return 0;
+}
+
+static int sst_mux_put(struct snd_kcontrol *kcontrol,
+		       struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_dapm_widget_list *wlist = snd_kcontrol_chip(kcontrol);
+	struct snd_soc_dapm_widget *widget = wlist->widgets[0];
+	struct sst_data *sst = snd_soc_platform_get_drvdata(widget->platform);
+	struct soc_enum *e = (void *)kcontrol->private_value;
+	struct snd_soc_dapm_update update;
+	unsigned int max = e->max - 1;
+	unsigned int mask = (1 << fls(max)) - 1;
+	unsigned int mux, val;
+
+	if (ucontrol->value.enumerated.item[0] > e->max - 1)
+		return -EINVAL;
+
+	mux = ucontrol->value.enumerated.item[0];
+	val = sst_reg_write(sst, e->reg, e->shift_l, max, mux);
+
+	pr_debug("%s: reg[%d] = %#x\n", __func__, e->reg, val);
+
+	update.kcontrol = kcontrol;
+	update.reg = e->reg;
+	update.mask = mask;
+	update.val = val;
+
+	widget->dapm->card->update = &update;
+	snd_soc_dapm_mux_update_power(widget->dapm, kcontrol, mux, e, &update);
+	widget->dapm->card->update = NULL;
+	return 0;
+}
+
+static int sst_mode_get(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	struct soc_enum *e = (void *)kcontrol->private_value;
+	unsigned int max = e->max - 1;
+
+	ucontrol->value.enumerated.item[0] = sst_reg_read(sst, e->reg, e->shift_l, max);
+	return 0;
+}
+
+static int sst_mode_put(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	struct soc_enum *e = (void *)kcontrol->private_value;
+	unsigned int max = e->max - 1;
+	unsigned int val;
+
+	if (ucontrol->value.enumerated.item[0] > e->max - 1)
+		return -EINVAL;
+
+	val = sst_reg_write(sst, e->reg, e->shift_l, max, ucontrol->value.enumerated.item[0]);
+	pr_debug("%s: reg[%d] - %#x\n", __func__, e->reg, val);
+	return 0;
+}
+
+static void sst_send_algo_cmd(struct sst_data *sst,
+			      struct sst_algo_control *bc)
+{
+	int len;
+	struct sst_cmd_set_params *cmd;
+
+	if (bc->params == NULL)
+		return;
+
+	len = sizeof(cmd->dst) + sizeof(cmd->command_id) + bc->max;
+
+	cmd = kzalloc(len + bc->max, GFP_KERNEL);
+	if (cmd == NULL) {
+		pr_err("Failed to send cmd, kzalloc failed\n");
+		return;
+	}
+
+	SST_FILL_DESTINATION(2, cmd->dst, bc->pipe_id, bc->module_id);
+	cmd->command_id = bc->cmd_id;
+	memcpy(cmd->params, bc->params, bc->max);
+
+	sst_fill_and_send_cmd(sst, SST_IPC_IA_SET_PARAMS, SST_FLAG_BLOCKED,
+				bc->task_id, 0, cmd, len);
+	kfree(cmd);
+
+}
+
+static void sst_find_and_send_pipe_algo(struct snd_soc_platform *platform,
+					struct snd_soc_dapm_widget *w)
+{
+	struct sst_algo_control *bc;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	struct sst_ids *ids = w->priv;
+	struct module *algo = NULL;
+
+	pr_debug("Enter:%s, widget=%s\n", __func__, w->name);
+
+	list_for_each_entry(algo, &ids->algo_list, node) {
+			bc = (void *)algo->kctl->private_value;
+
+			pr_debug("Found algo control name =%s pipe=%s\n", algo->kctl->id.name,  w->name);
+			sst_send_algo_cmd(sst, bc);
+	}
+}
+
+int sst_algo_bytes_ctl_info(struct snd_kcontrol *kcontrol,
+			    struct snd_ctl_elem_info *uinfo)
+{
+	struct sst_algo_control *bc = (void *)kcontrol->private_value;
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
+	uinfo->count = bc->max;
+
+	if (bc->params == NULL) {
+		bc->params = devm_kzalloc(platform->dev, bc->max, GFP_KERNEL);
+		if (bc->params == NULL) {
+			pr_err("kzalloc failed\n");
+			return -ENOMEM;
+		}
+	}
+	return 0;
+}
+
+static int sst_algo_control_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct sst_algo_control *bc = (void *)kcontrol->private_value;
+
+	pr_debug("in %s\n", __func__);
+	switch (bc->type) {
+	case SST_ALGO_PARAMS:
+		if (bc->params)
+			memcpy(ucontrol->value.bytes.data, bc->params, bc->max);
+		break;
+	case SST_ALGO_BYPASS:
+		ucontrol->value.integer.value[0] = bc->bypass ? 1 : 0;
+		pr_debug("%s: bypass  %d\n", __func__, bc->bypass);
+		break;
+	default:
+		pr_err("Invalid Input- algo type:%d\n", bc->type);
+		return -EINVAL;
+
+	}
+	return 0;
+}
+
+static int sst_algo_control_set(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	struct sst_algo_control *bc = (void *)kcontrol->private_value;
+
+	pr_debug("in %s control_name=%s\n", __func__, kcontrol->id.name);
+	switch (bc->type) {
+	case SST_ALGO_PARAMS:
+		if (bc->params)
+			memcpy(bc->params, ucontrol->value.bytes.data, bc->max);
+		break;
+	case SST_ALGO_BYPASS:
+		bc->bypass = !!ucontrol->value.integer.value[0];
+		pr_debug("%s: Mute %d\n", __func__, bc->bypass);
+		break;
+	default:
+		pr_err("Invalid Input- algo type:%ld\n", ucontrol->value.integer.value[0]);
+		return -EINVAL;
+	}
+	/*if pipe is enabled, need to send the algo params from here */
+	if (bc->w && bc->w->power)
+		sst_send_algo_cmd(sst, bc);
+
+	return 0;
+}
+
+static int sst_gain_ctl_info(struct snd_kcontrol *kcontrol,
+	struct snd_ctl_elem_info *uinfo)
+{
+	struct sst_gain_mixer_control *mc = (void *)kcontrol->private_value;
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = mc->stereo ? 2 : 1;
+	uinfo->value.integer.min = mc->min;
+	uinfo->value.integer.max = mc->max;
+	return 0;
+}
+
+static void sst_send_gain_cmd(struct sst_data *sst, struct sst_gain_value *gv,
+			      u16 task_id, u16 loc_id, u16 module_id, int mute)
+{
+	struct sst_cmd_set_gain_dual cmd;
+	pr_debug("%s", __func__);
+
+	cmd.header.command_id = MMX_SET_GAIN;
+	SST_FILL_DEFAULT_DESTINATION(cmd.header.dst);
+	cmd.gain_cell_num = 1;
+
+	if (mute || gv->mute) {
+		cmd.cell_gains[0].cell_gain_left = SST_GAIN_MIN_VALUE;
+		cmd.cell_gains[0].cell_gain_right = SST_GAIN_MIN_VALUE;
+	} else {
+		cmd.cell_gains[0].cell_gain_left = gv->l_gain;
+		cmd.cell_gains[0].cell_gain_right = gv->r_gain;
+	}
+	SST_FILL_DESTINATION(2, cmd.cell_gains[0].dest,
+			     loc_id, module_id);
+	cmd.cell_gains[0].gain_time_constant = gv->ramp_duration;
+
+	cmd.header.length = sizeof(struct sst_cmd_set_gain_dual)
+				- sizeof(struct sst_dsp_header);
+
+	sst_fill_and_send_cmd(sst, SST_IPC_IA_SET_PARAMS, SST_FLAG_BLOCKED,
+			      task_id, 0, &cmd,
+			      sizeof(cmd.header) + cmd.header.length);
+}
+
+static int sst_gain_get(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct sst_gain_mixer_control *mc = (void *)kcontrol->private_value;
+	struct sst_gain_value *gv = mc->gain_val;
+
+	switch (mc->type) {
+	case SST_GAIN_TLV:
+		ucontrol->value.integer.value[0] = gv->l_gain;
+		ucontrol->value.integer.value[1] = gv->r_gain;
+		pr_debug("%s: Volume %d, %d\n", __func__, gv->l_gain, gv->r_gain);
+		break;
+	case SST_GAIN_MUTE:
+		ucontrol->value.integer.value[0] = gv->mute ? 1 : 0;
+		pr_debug("%s: Mute %d\n", __func__, gv->mute);
+		break;
+	case SST_GAIN_RAMP_DURATION:
+		ucontrol->value.integer.value[0] = gv->ramp_duration;
+		pr_debug("%s: RampDuration %d\n", __func__, gv->ramp_duration);
+		break;
+	default:
+		pr_err("Invalid Input- gain type:%d\n", mc->type);
+		return -EINVAL;
+	};
+	return 0;
+}
+
+static int sst_gain_put(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_platform *platform = snd_kcontrol_chip(kcontrol);
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	struct sst_gain_mixer_control *mc = (void *)kcontrol->private_value;
+	struct sst_gain_value *gv = mc->gain_val;
+
+	switch (mc->type) {
+	case SST_GAIN_TLV:
+		gv->l_gain = ucontrol->value.integer.value[0];
+		gv->r_gain = ucontrol->value.integer.value[1];
+		pr_debug("%s: Volume %d, %d\n", __func__, gv->l_gain, gv->r_gain);
+		break;
+	case SST_GAIN_MUTE:
+		gv->mute = !!ucontrol->value.integer.value[0];
+		pr_debug("%s: Mute %d\n", __func__, gv->mute);
+		break;
+	case SST_GAIN_RAMP_DURATION:
+		gv->ramp_duration = ucontrol->value.integer.value[0];
+		pr_debug("%s: RampDuration %d\n", __func__, gv->ramp_duration);
+		break;
+	default:
+		pr_err("Invalid Input- gain type:%d\n", mc->type);
+		return -EINVAL;
+	};
+
+	if (mc->w && mc->w->power)
+		sst_send_gain_cmd(sst, gv, mc->task_id,
+				mc->pipe_id | mc->instance_id, mc->module_id, 0);
+	return 0;
+}
+
+static const DECLARE_TLV_DB_SCALE(sst_gain_tlv_common, SST_GAIN_MIN_VALUE * 10, 10, 0);
+
+/* Look up table to convert MIXER SW bit regs to SWM inputs */
+static const uint swm_mixer_input_ids[SST_SWM_INPUT_COUNT] = {
+	[SST_IP_MODEM]		= SST_SWM_IN_MODEM,
+	[SST_IP_BT]		= SST_SWM_IN_BT,
+	[SST_IP_CODEC0]		= SST_SWM_IN_CODEC0,
+	[SST_IP_CODEC1]		= SST_SWM_IN_CODEC1,
+	[SST_IP_LOOP0]		= SST_SWM_IN_SPROT_LOOP,
+	[SST_IP_LOOP1]		= SST_SWM_IN_MEDIA_LOOP1,
+	[SST_IP_LOOP2]		= SST_SWM_IN_MEDIA_LOOP2,
+	[SST_IP_SIDETONE]	= SST_SWM_IN_SIDETONE,
+	[SST_IP_TXSPEECH]	= SST_SWM_IN_TXSPEECH,
+	[SST_IP_SPEECH]		= SST_SWM_IN_SPEECH,
+	[SST_IP_TONE]		= SST_SWM_IN_TONE,
+	[SST_IP_VOIP]		= SST_SWM_IN_VOIP,
+	[SST_IP_PCM0]		= SST_SWM_IN_PCM0,
+	[SST_IP_PCM1]		= SST_SWM_IN_PCM1,
+	[SST_IP_LOW_PCM0]	= SST_SWM_IN_LOW_PCM0,
+	[SST_IP_FM]		= SST_SWM_IN_FM,
+	[SST_IP_MEDIA0]		= SST_SWM_IN_MEDIA0,
+	[SST_IP_MEDIA1]		= SST_SWM_IN_MEDIA1,
+	[SST_IP_MEDIA2]		= SST_SWM_IN_MEDIA2,
+	[SST_IP_MEDIA3]		= SST_SWM_IN_MEDIA3,
+};
+
+static int fill_swm_input(struct swm_input_ids *swm_input, unsigned int reg)
+{
+	uint i, is_set, nb_inputs = 0;
+	u16 input_loc_id;
+
+	pr_debug("%s:reg value:%#x\n", __func__, reg);
+	for (i = 0; i < SST_SWM_INPUT_COUNT; i++) {
+		is_set = reg & BIT(i);
+		if (!is_set)
+			continue;
+
+		input_loc_id = swm_mixer_input_ids[i];
+		SST_FILL_DESTINATION(2, swm_input->input_id,
+				     input_loc_id, SST_DEFAULT_MODULE_ID);
+		nb_inputs++;
+		swm_input++;
+		pr_debug("input id:%#x, nb_inputs:%d\n", input_loc_id, nb_inputs);
+
+		if (nb_inputs == SST_CMD_SWM_MAX_INPUTS) {
+			pr_warn("%s: SET_SWM cmd max inputs reached", __func__);
+			break;
+		}
+	}
+	return nb_inputs;
+}
+
+static void sst_set_pipe_gain(struct sst_ids *ids, struct sst_data *sst, int mute)
+{
+	struct sst_gain_mixer_control *mc;
+	struct sst_gain_value *gv;
+	struct module *gain = NULL;
+
+	list_for_each_entry(gain, &ids->gain_list, node) {
+		struct snd_kcontrol *kctl = gain->kctl;
+
+		pr_debug("control name=%s", kctl->id.name);
+		mc = (void *)kctl->private_value;
+		gv = mc->gain_val;
+
+		sst_send_gain_cmd(sst, gv, mc->task_id,
+				mc->pipe_id | mc->instance_id, mc->module_id, mute);
+	}
+}
+
+static int sst_swm_mixer_event(struct snd_soc_dapm_widget *w,
+			struct snd_kcontrol *k, int event)
+{
+	struct sst_cmd_set_swm cmd;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(w->platform);
+	struct sst_ids *ids = w->priv;
+	bool set_mixer = false;
+	int val = sst->widget[ids->reg];
+
+	pr_debug("%s: widget=%s\n", __func__, w->name);
+	pr_debug("%s: reg[%d] = %#x\n", __func__, ids->reg, val);
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+	case SND_SOC_DAPM_POST_PMD:
+		set_mixer = true;
+		break;
+	case SND_SOC_DAPM_POST_REG:
+		if (w->power)
+			set_mixer = true;
+		break;
+	default:
+		set_mixer = false;
+	}
+
+	if (set_mixer == false)
+		return 0;
+
+	if (SND_SOC_DAPM_EVENT_ON(event) ||
+	    event == SND_SOC_DAPM_POST_REG)
+		cmd.switch_state = SST_SWM_ON;
+	else
+		cmd.switch_state = SST_SWM_OFF;
+
+	SST_FILL_DEFAULT_DESTINATION(cmd.header.dst);
+	/* MMX_SET_SWM == SBA_SET_SWM */
+	cmd.header.command_id = SBA_SET_SWM;
+
+	SST_FILL_DESTINATION(2, cmd.output_id,
+			     ids->location_id, SST_DEFAULT_MODULE_ID);
+	cmd.nb_inputs =	fill_swm_input(&cmd.input[0], val);
+	cmd.header.length = offsetof(struct sst_cmd_set_swm, input) - sizeof(struct sst_dsp_header)
+				+ (cmd.nb_inputs * sizeof(cmd.input[0]));
+
+	sst_fill_and_send_cmd(sst, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,
+			      ids->task_id, 0, &cmd,
+			      sizeof(cmd.header) + cmd.header.length);
+	return 0;
+}
+
+/* SBA mixers - 16 inputs */
+#define SST_SBA_DECLARE_MIX_CONTROLS(kctl_name, mixer_reg)			\
+	static const struct snd_kcontrol_new kctl_name[] = {			\
+		SOC_SINGLE_EXT("modem_in", mixer_reg, SST_IP_MODEM, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("bt_in", mixer_reg, SST_IP_BT, 1, 0,		\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("codec_in0", mixer_reg, SST_IP_CODEC0, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("codec_in1", mixer_reg, SST_IP_CODEC1, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("sprot_loop_in", mixer_reg, SST_IP_LOOP0, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("media_loop1_in", mixer_reg, SST_IP_LOOP1, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("media_loop2_in", mixer_reg, SST_IP_LOOP2, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("sidetone_in", mixer_reg, SST_IP_SIDETONE, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("txspeech_in", mixer_reg, SST_IP_TXSPEECH, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("speech_in", mixer_reg, SST_IP_SPEECH, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("tone_in", mixer_reg, SST_IP_TONE, 1, 0,		\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("voip_in", mixer_reg, SST_IP_VOIP, 1, 0,		\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("pcm0_in", mixer_reg, SST_IP_PCM0, 1, 0,		\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("pcm1_in", mixer_reg, SST_IP_PCM1, 1, 0,		\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("low_pcm0_in", mixer_reg, SST_IP_LOW_PCM0, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("fm_in", mixer_reg, SST_IP_FM, 1, 0,		\
+				sst_mix_get, sst_mix_put),			\
+	}
+
+#define SST_SBA_MIXER_GRAPH_MAP(mix_name)			\
+	{ mix_name, "modem_in",		"modem_in" },		\
+	{ mix_name, "bt_in",		"bt_in" },		\
+	{ mix_name, "codec_in0",	"codec_in0" },		\
+	{ mix_name, "codec_in1",	"codec_in1" },		\
+	{ mix_name, "sprot_loop_in",	"sprot_loop_in" },	\
+	{ mix_name, "media_loop1_in",	"media_loop1_in" },	\
+	{ mix_name, "media_loop2_in",	"media_loop2_in" },	\
+	{ mix_name, "sidetone_in",	"sidetone_in" },	\
+	{ mix_name, "txspeech_in",	"txspeech_in" },	\
+	{ mix_name, "speech_in",	"speech_in" },		\
+	{ mix_name, "tone_in",		"tone_in" },		\
+	{ mix_name, "voip_in",		"voip_in" },		\
+	{ mix_name, "pcm0_in",		"pcm0_in" },		\
+	{ mix_name, "pcm1_in",		"pcm1_in" },		\
+	{ mix_name, "low_pcm0_in",	"low_pcm0_in" },	\
+	{ mix_name, "fm_in",		"fm_in" }
+
+#define SST_MMX_DECLARE_MIX_CONTROLS(kctl_name, mixer_reg)			\
+	static const struct snd_kcontrol_new kctl_name[] = {			\
+		SOC_SINGLE_EXT("media0_in", mixer_reg, SST_IP_MEDIA0, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("media1_in", mixer_reg, SST_IP_MEDIA1, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("media2_in", mixer_reg, SST_IP_MEDIA2, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+		SOC_SINGLE_EXT("media3_in", mixer_reg, SST_IP_MEDIA3, 1, 0,	\
+				sst_mix_get, sst_mix_put),			\
+	}
+
+SST_MMX_DECLARE_MIX_CONTROLS(sst_mix_media0_controls, SST_MIX_MEDIA0);
+SST_MMX_DECLARE_MIX_CONTROLS(sst_mix_media1_controls, SST_MIX_MEDIA1);
+
+/* 18 SBA mixers */
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_pcm0_controls, SST_MIX_PCM0);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_pcm1_controls, SST_MIX_PCM1);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_pcm2_controls, SST_MIX_PCM2);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_sprot_l0_controls, SST_MIX_LOOP0);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_media_l1_controls, SST_MIX_LOOP1);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_media_l2_controls, SST_MIX_LOOP2);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_voip_controls, SST_MIX_VOIP);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_aware_controls, SST_MIX_AWARE);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_vad_controls, SST_MIX_VAD);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_hf_sns_controls, SST_MIX_HF_SNS);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_hf_controls, SST_MIX_HF);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_speech_controls, SST_MIX_SPEECH);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_rxspeech_controls, SST_MIX_RXSPEECH);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_codec0_controls, SST_MIX_CODEC0);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_codec1_controls, SST_MIX_CODEC1);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_bt_controls, SST_MIX_BT);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_fm_controls, SST_MIX_FM);
+SST_SBA_DECLARE_MIX_CONTROLS(sst_mix_modem_controls, SST_MIX_MODEM);
+
+static int sst_vb_trigger_event(struct snd_soc_dapm_widget *w,
+			struct snd_kcontrol *k, int event)
+{
+	struct sst_cmd_generic cmd;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(w->platform);
+
+	pr_debug("Enter:%s, widget=%s\n", __func__, w->name);
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		cmd.header.command_id = SBA_VB_START;
+	else
+		cmd.header.command_id = SBA_IDLE;
+
+	SST_FILL_DEFAULT_DESTINATION(cmd.header.dst);
+	cmd.header.length = 0;
+
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		sst_dsp->ops->power(true);
+
+	sst_fill_and_send_cmd(sst, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,
+			      SST_TASK_SBA, 0, &cmd,
+			      sizeof(cmd.header) + cmd.header.length);
+
+	if (!SND_SOC_DAPM_EVENT_ON(event))
+		sst_dsp->ops->power(false);
+	return 0;
+}
+
+static void sst_send_slot_map(struct sst_data *sst)
+{
+	struct sst_param_sba_ssp_slot_map cmd;
+
+	pr_debug("Enter: %s", __func__);
+
+	SST_FILL_DEFAULT_DESTINATION(cmd.header.dst);
+	cmd.header.command_id = SBA_SET_SSP_SLOT_MAP;
+	cmd.header.length = sizeof(struct sst_param_sba_ssp_slot_map)
+				- sizeof(struct sst_dsp_header);
+
+	cmd.param_id = SBA_SET_SSP_SLOT_MAP;
+	cmd.param_len = sizeof(cmd.rx_slot_map) + sizeof(cmd.tx_slot_map) + sizeof(cmd.ssp_index);
+	cmd.ssp_index = SSP_CODEC;
+
+	memcpy(cmd.rx_slot_map, &sst_ssp_slot_map[0], sizeof(cmd.rx_slot_map));
+	memcpy(cmd.tx_slot_map, &sst_ssp_channel_map[0], sizeof(cmd.tx_slot_map));
+
+	sst_fill_and_send_cmd(sst, SST_IPC_IA_SET_PARAMS, SST_FLAG_BLOCKED,
+			      SST_TASK_SBA, 0, &cmd,
+			      sizeof(cmd.header) + cmd.header.length);
+}
+
+static int sst_ssp_event(struct snd_soc_dapm_widget *w,
+			 struct snd_kcontrol *k, int event)
+{
+	struct sst_cmd_sba_hw_set_ssp cmd;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(w->platform);
+	struct sst_ids *ids = w->priv;
+	static int ssp_active[SST_NUM_SSPS];
+	unsigned int domain, mux;
+	unsigned int ssp_no = ids->ssp->ssp_number;
+	int domain_shift, mux_shift;
+	const struct sst_ssp_config *config;
+
+	pr_debug("Enter:%s, widget=%s\n", __func__, w->name);
+
+	SST_FILL_DEFAULT_DESTINATION(cmd.header.dst);
+	cmd.header.command_id = SBA_HW_SET_SSP;
+	cmd.header.length = sizeof(struct sst_cmd_sba_hw_set_ssp)
+				- sizeof(struct sst_dsp_header);
+	mux_shift = *ids->ssp->mux_shift;
+	mux = (mux_shift == -1) ? 0 : get_mux_state(sst, SST_MUX_REG, mux_shift);
+	domain_shift = (*ids->ssp->domain_shift)[mux];
+	domain = (domain_shift == -1) ? 0 : get_mux_state(sst, SST_MUX_REG, domain_shift);
+
+	config = &(*ids->ssp->ssp_config)[mux][domain];
+	pr_debug("%s: ssp_id: %u, mux: %d, domain: %d\n", __func__,
+		 config->ssp_id, mux, domain);
+
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		ssp_active[ssp_no]++;
+	else
+		ssp_active[ssp_no]--;
+
+	pr_debug("%s: ssp_no: %u ssp_active: %d", __func__, ssp_no, ssp_active[ssp_no]);
+	if (ssp_active[ssp_no])
+		cmd.switch_state = SST_SWITCH_ON;
+	else
+		cmd.switch_state = SST_SWITCH_OFF;
+
+	cmd.selection = config->ssp_id;
+	cmd.nb_bits_per_slots = config->bits_per_slot;
+	cmd.nb_slots = config->slots;
+	cmd.mode = config->ssp_mode | (config->pcm_mode << 1);
+	cmd.duplex = config->duplex;
+	cmd.active_tx_slot_map = config->active_slot_map;
+	cmd.active_rx_slot_map = config->active_slot_map;
+	cmd.frame_sync_frequency = config->fs_frequency;
+	cmd.frame_sync_polarity = SSP_FS_ACTIVE_HIGH;
+	cmd.data_polarity = 1;
+	cmd.frame_sync_width = config->fs_width;
+	cmd.ssp_protocol = config->ssp_protocol;
+	cmd.start_delay = config->start_delay;
+	cmd.reserved1 = cmd.reserved2 = 0xFF;
+
+	sst_fill_and_send_cmd(sst, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,
+			      SST_TASK_SBA, 0, &cmd,
+			      sizeof(cmd.header) + cmd.header.length);
+
+	if (SND_SOC_DAPM_EVENT_ON(event)) {
+		sst_find_and_send_pipe_algo(w->platform, w);
+		sst_send_slot_map(sst);
+		sst_set_pipe_gain(ids, sst, 0);
+	}
+	return 0;
+}
+
+static int sst_set_speech_path(struct snd_soc_dapm_widget *w,
+			       struct snd_kcontrol *k, int event)
+{
+	struct sst_cmd_set_speech_path cmd;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(w->platform);
+	struct sst_ids *ids = w->priv;
+	bool is_wideband;
+	static int speech_active;
+
+	pr_debug("%s: widget=%s\n", __func__, w->name);
+
+	if (SND_SOC_DAPM_EVENT_ON(event)) {
+		speech_active++;
+		cmd.switch_state = SST_SWITCH_ON;
+	} else {
+		speech_active--;
+		cmd.switch_state = SST_SWITCH_OFF;
+	}
+
+	SST_FILL_DEFAULT_DESTINATION(cmd.header.dst);
+
+	cmd.header.command_id = SBA_VB_SET_SPEECH_PATH;
+	cmd.header.length = sizeof(struct sst_cmd_set_speech_path)
+				- sizeof(struct sst_dsp_header);
+	cmd.config.sample_length = 0;
+	cmd.config.rate = 0;		/* 8 khz */
+	cmd.config.format = 0;
+
+	is_wideband = get_mux_state(sst, SST_MUX_REG, SST_VOICE_MODE_SHIFT);
+	if (is_wideband)
+		cmd.config.rate = 1;	/* 16 khz */
+
+	if ((SND_SOC_DAPM_EVENT_ON(event) && (speech_active == 1)) ||
+			(SND_SOC_DAPM_EVENT_OFF(event) && (speech_active == 0)))
+		sst_fill_and_send_cmd(sst, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,
+				SST_TASK_SBA, 0, &cmd,
+				sizeof(cmd.header) + cmd.header.length);
+
+	if (SND_SOC_DAPM_EVENT_ON(event)) {
+		sst_find_and_send_pipe_algo(w->platform, w);
+		sst_set_pipe_gain(ids, sst, 0);
+	}
+
+	return 0;
+
+}
+
+static int sst_set_media_path(struct snd_soc_dapm_widget *w,
+			      struct snd_kcontrol *k, int event)
+{
+	struct sst_cmd_set_media_path cmd;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(w->platform);
+	struct sst_ids *ids = w->priv;
+
+	pr_debug("%s: widget=%s\n", __func__, w->name);
+	pr_debug("%s: task=%u, location=%#x\n", __func__,
+				ids->task_id, ids->location_id);
+
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		cmd.switch_state = SST_PATH_ON;
+	else
+		cmd.switch_state = SST_PATH_OFF;
+
+	SST_FILL_DESTINATION(2, cmd.header.dst,
+			     ids->location_id, SST_DEFAULT_MODULE_ID);
+
+	/* MMX_SET_MEDIA_PATH == SBA_SET_MEDIA_PATH */
+	cmd.header.command_id = MMX_SET_MEDIA_PATH;
+	cmd.header.length = sizeof(struct sst_cmd_set_media_path)
+				- sizeof(struct sst_dsp_header);
+
+	sst_fill_and_send_cmd(sst, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,
+			      ids->task_id, 0, &cmd,
+			      sizeof(cmd.header) + cmd.header.length);
+
+	if (SND_SOC_DAPM_EVENT_ON(event)) {
+		sst_find_and_send_pipe_algo(w->platform, w);
+		sst_set_pipe_gain(ids, sst, 0);
+	}
+
+	return 0;
+}
+
+static int sst_set_media_loop(struct snd_soc_dapm_widget *w,
+			struct snd_kcontrol *k, int event)
+{
+	struct sst_cmd_sba_set_media_loop_map cmd;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(w->platform);
+	struct sst_ids *ids = w->priv;
+
+	pr_debug("Enter:%s, widget=%s\n", __func__, w->name);
+	if (SND_SOC_DAPM_EVENT_ON(event))
+		cmd.switch_state = SST_SWITCH_ON;
+	else
+		cmd.switch_state = SST_SWITCH_OFF;
+
+	SST_FILL_DESTINATION(2, cmd.header.dst,
+			     ids->location_id, SST_DEFAULT_MODULE_ID);
+
+	cmd.header.command_id = SBA_SET_MEDIA_LOOP_MAP;
+	cmd.header.length = sizeof(struct sst_cmd_sba_set_media_loop_map)
+				 - sizeof(struct sst_dsp_header);
+	cmd.param.part.rate = 2; /* 48khz */
+
+	cmd.param.part.format = ids->format; /* stereo/Mono */
+	cmd.param.part.sample_length = 1; /* 24bit left justified*/
+	cmd.map = 0; /* Algo sequence: Gain - DRP - FIR - IIR  */
+
+	sst_fill_and_send_cmd(sst, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,
+			      SST_TASK_SBA, 0, &cmd,
+			      sizeof(cmd.header) + cmd.header.length);
+	if (SND_SOC_DAPM_EVENT_ON(event)) {
+		sst_find_and_send_pipe_algo(w->platform, w);
+		sst_set_pipe_gain(ids, sst, 0);
+	}
+	return 0;
+}
+
+static int sst_send_probe_cmd(struct sst_data *sst, u16 probe_pipe_id,
+			      int mode, int switch_state,
+			      const struct sst_probe_config *probe_cfg)
+{
+	struct sst_cmd_probe cmd;
+
+	memset(&cmd, 0, sizeof(cmd));
+
+	SST_FILL_DESTINATION(3, cmd.header.dst, SST_DEFAULT_CELL_NBR,
+			     probe_pipe_id, SST_DEFAULT_MODULE_ID);
+	cmd.header.command_id = SBA_PROBE;
+	cmd.header.length = sizeof(struct sst_cmd_probe)
+				 - sizeof(struct sst_dsp_header);
+	cmd.switch_state = switch_state;
+
+	SST_FILL_DESTINATION(2, cmd.probe_dst,
+			     probe_cfg->loc_id, probe_cfg->mod_id);
+
+	cmd.shared_mem = 1;
+	cmd.probe_in = 0;
+	cmd.probe_out = 0;
+
+	cmd.probe_mode = mode;
+	cmd.sample_length = probe_cfg->cfg.s_length;
+	cmd.rate = probe_cfg->cfg.rate;
+	cmd.format = probe_cfg->cfg.format;
+	cmd.sm_buf_id = 1;
+
+	return sst_fill_and_send_cmd(sst, SST_IPC_IA_CMD, SST_FLAG_BLOCKED,
+				     probe_cfg->task_id, 0, &cmd,
+				     sizeof(cmd.header) + cmd.header.length);
+}
+
+static const struct snd_kcontrol_new sst_probe_controls[];
+static const struct sst_probe_config sst_probes[];
+
+#define SST_MAX_PROBE_STREAMS 8
+int sst_dpcm_probe_send(struct snd_soc_platform *platform, u16 probe_pipe_id,
+			int substream, int direction, bool on)
+{
+	int switch_state = on ? SST_SWITCH_ON : SST_SWITCH_OFF;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	const struct sst_probe_config *probe_cfg;
+	struct sst_probe_value *probe_val;
+	char *type;
+	int offset;
+	int mode;
+
+	if (direction == SNDRV_PCM_STREAM_CAPTURE) {
+		mode = SST_PROBE_EXTRACTOR;
+		offset = 0;
+		type = "extractor";
+	} else {
+		mode = SST_PROBE_INJECTOR;
+		offset = SST_MAX_PROBE_STREAMS;
+		type = "injector";
+	}
+	/* get the value of the probe connection kcontrol */
+	probe_val = (void *)sst_probe_controls[substream + offset].private_value;
+	probe_cfg = &sst_probes[probe_val->val];
+
+	pr_debug("%s: substream=%d, direction=%d\n", __func__, substream, direction);
+	pr_debug("%s: %s probe point at %s\n", __func__, type, probe_cfg->name);
+
+	return sst_send_probe_cmd(sst, probe_pipe_id, mode, switch_state, probe_cfg);
+}
+
+static const struct snd_kcontrol_new sst_mix_sw_aware =
+	SOC_SINGLE_EXT("switch", SST_MIX_SWITCH, 0, 1, 0,
+		sst_mix_get, sst_mix_put);
+
+static const char * const sst_bt_fm_texts[] = {
+	"fm", "bt",
+};
+
+static const struct snd_kcontrol_new sst_bt_fm_mux =
+	SST_SSP_MUX_CTL("ssp1_out", 0, SST_MUX_REG, SST_BT_FM_MUX_SHIFT, sst_bt_fm_texts,
+			sst_mux_get, sst_mux_put);
+
+#define SST_SSP_CODEC_MUX		0
+#define SST_SSP_CODEC_DOMAIN		0
+#define SST_SSP_MODEM_MUX		0
+#define SST_SSP_MODEM_DOMAIN		0
+#define SST_SSP_FM_MUX			0
+#define SST_SSP_FM_DOMAIN		0
+#define SST_SSP_BT_MUX			1
+#define SST_SSP_BT_NB_DOMAIN		0
+#define SST_SSP_BT_WB_DOMAIN		1
+
+static const int sst_ssp_mux_shift[SST_NUM_SSPS] = {
+	[SST_SSP0] = -1,			/* no register shift, i.e. single mux value */
+	[SST_SSP1] = SST_BT_FM_MUX_SHIFT,
+	[SST_SSP2] = -1,
+};
+
+static const int sst_ssp_domain_shift[SST_NUM_SSPS][SST_MAX_SSP_MUX] = {
+	[SST_SSP0][0] = -1,			/* no domain shift, i.e. single domain */
+	[SST_SSP1] = {
+		[SST_SSP_FM_MUX] = -1,
+		[SST_SSP_BT_MUX] = SST_BT_MODE_SHIFT,
+	},
+	[SST_SSP2][0] = -1,
+};
+
+static const struct sst_ssp_config
+sst_ssp_configs[SST_NUM_SSPS][SST_MAX_SSP_MUX][SST_MAX_SSP_DOMAINS] = {
+	[SST_SSP0] = {
+		[SST_SSP_MODEM_MUX] = {
+			[SST_SSP_MODEM_DOMAIN] = {
+				.ssp_id = SSP_MODEM,
+				.bits_per_slot = 16,
+				.slots = 1,
+				.ssp_mode = SSP_MODE_MASTER,
+				.pcm_mode = SSP_PCM_MODE_NETWORK,
+				.duplex = SSP_DUPLEX,
+				.ssp_protocol = SSP_MODE_PCM,
+				.fs_width = 1,
+				.fs_frequency = SSP_FS_48_KHZ,
+				.active_slot_map = 0x1,
+				.start_delay = 1,
+			},
+		},
+	},
+	[SST_SSP1] = {
+		[SST_SSP_FM_MUX] = {
+			[SST_SSP_FM_DOMAIN] = {
+				.ssp_id = SSP_FM,
+				.bits_per_slot = 16,
+				.slots = 2,
+				.ssp_mode = SSP_MODE_MASTER,
+				.pcm_mode = SSP_PCM_MODE_NORMAL,
+				.duplex = SSP_DUPLEX,
+				.ssp_protocol = SSP_MODE_I2S,
+				.fs_width = 32,
+				.fs_frequency = SSP_FS_48_KHZ,
+				.active_slot_map = 0x3,
+				.start_delay = 0,
+			},
+		},
+		[SST_SSP_BT_MUX] = {
+			[SST_SSP_BT_NB_DOMAIN] = {
+				.ssp_id = SSP_BT,
+				.bits_per_slot = 16,
+				.slots = 1,
+				.ssp_mode = SSP_MODE_MASTER,
+				.pcm_mode = SSP_PCM_MODE_NORMAL,
+				.duplex = SSP_DUPLEX,
+				.ssp_protocol = SSP_MODE_PCM,
+				.fs_width = 1,
+				.fs_frequency = SSP_FS_8_KHZ,
+				.active_slot_map = 0x1,
+				.start_delay = 1,
+			},
+			[SST_SSP_BT_WB_DOMAIN] = {
+				.ssp_id = SSP_BT,
+				.bits_per_slot = 16,
+				.slots = 1,
+				.ssp_mode = SSP_MODE_MASTER,
+				.pcm_mode = SSP_PCM_MODE_NORMAL,
+				.duplex = SSP_DUPLEX,
+				.ssp_protocol = SSP_MODE_PCM,
+				.fs_width = 1,
+				.fs_frequency = SSP_FS_16_KHZ,
+				.active_slot_map = 0x1,
+				.start_delay = 1,
+			},
+		},
+	},
+	[SST_SSP2] = {
+		[SST_SSP_CODEC_MUX] = {
+			[SST_SSP_CODEC_DOMAIN] = {
+				.ssp_id = SSP_CODEC,
+				.bits_per_slot = 24,
+				.slots = 4,
+				.ssp_mode = SSP_MODE_MASTER,
+				.pcm_mode = SSP_PCM_MODE_NETWORK,
+				.duplex = SSP_DUPLEX,
+				.ssp_protocol = SSP_MODE_PCM,
+				.fs_width = 1,
+				.fs_frequency = SSP_FS_48_KHZ,
+				.active_slot_map = 0xF,
+				.start_delay = 0,
+			},
+		},
+	},
+};
+
+#define SST_SSP_CFG(wssp_no)								\
+	(const struct sst_ssp_cfg){ .ssp_config = &sst_ssp_configs[wssp_no],		\
+				    .ssp_number = wssp_no,				\
+				    .mux_shift = &sst_ssp_mux_shift[wssp_no],		\
+				    .domain_shift = &sst_ssp_domain_shift[wssp_no], }
+
+static const struct snd_soc_dapm_widget sst_dapm_widgets[] = {
+	SND_SOC_DAPM_INPUT("tone"),
+	SND_SOC_DAPM_OUTPUT("aware"),
+	SND_SOC_DAPM_OUTPUT("vad"),
+	SST_SSP_INPUT("modem_in",  sst_ssp_event, SST_SSP_CFG(SST_SSP0)),
+	SST_SSP_AIF_IN("codec_in0", sst_ssp_event, SST_SSP_CFG(SST_SSP2)),
+	SST_SSP_AIF_IN("codec_in1", sst_ssp_event, SST_SSP_CFG(SST_SSP2)),
+	SST_SSP_INPUT("bt_fm_in", sst_ssp_event, SST_SSP_CFG(SST_SSP1)),
+	SST_SSP_OUTPUT("modem_out", sst_ssp_event, SST_SSP_CFG(SST_SSP0)),
+	SST_SSP_AIF_OUT("codec_out0", sst_ssp_event, SST_SSP_CFG(SST_SSP2)),
+	SST_SSP_AIF_OUT("codec_out1", sst_ssp_event, SST_SSP_CFG(SST_SSP2)),
+	SST_SSP_OUTPUT("bt_fm_out", sst_ssp_event, SST_SSP_CFG(SST_SSP1)),
+
+	/* Media Paths */
+	/* MediaX IN paths are set via ALLOC, so no SET_MEDIA_PATH command */
+	SST_PATH_INPUT("media0_in", SST_TASK_MMX, SST_SWM_IN_MEDIA0, NULL),
+	SST_PATH_INPUT("media1_in", SST_TASK_MMX, SST_SWM_IN_MEDIA1, NULL),
+	SST_PATH_INPUT("media2_in", SST_TASK_MMX, SST_SWM_IN_MEDIA2, sst_set_media_path),
+	SST_PATH_INPUT("media3_in", SST_TASK_MMX, SST_SWM_IN_MEDIA3, NULL),
+	SST_PATH_OUTPUT("media0_out", SST_TASK_MMX, SST_SWM_OUT_MEDIA0, sst_set_media_path),
+	SST_PATH_OUTPUT("media1_out", SST_TASK_MMX, SST_SWM_OUT_MEDIA1, sst_set_media_path),
+
+	/* SBA PCM Paths */
+	SST_PATH_INPUT("pcm0_in", SST_TASK_SBA, SST_SWM_IN_PCM0, sst_set_media_path),
+	SST_PATH_INPUT("pcm1_in", SST_TASK_SBA, SST_SWM_IN_PCM1, sst_set_media_path),
+	SST_PATH_OUTPUT("pcm0_out", SST_TASK_SBA, SST_SWM_OUT_PCM0, sst_set_media_path),
+	SST_PATH_OUTPUT("pcm1_out", SST_TASK_SBA, SST_SWM_OUT_PCM1, sst_set_media_path),
+	SST_PATH_OUTPUT("pcm2_out", SST_TASK_SBA, SST_SWM_OUT_PCM2, sst_set_media_path),
+	/* TODO: check if this needs SET_MEDIA_PATH command*/
+	SST_PATH_INPUT("low_pcm0_in", SST_TASK_SBA, SST_SWM_IN_LOW_PCM0, NULL),
+
+	SST_PATH_INPUT("voip_in", SST_TASK_SBA, SST_SWM_IN_VOIP, sst_set_media_path),
+	SST_PATH_OUTPUT("voip_out", SST_TASK_SBA, SST_SWM_OUT_VOIP, sst_set_media_path),
+	SST_PATH_OUTPUT("aware_out", SST_TASK_SBA, SST_SWM_OUT_AWARE, sst_set_media_path),
+	SST_PATH_OUTPUT("vad_out", SST_TASK_SBA, SST_SWM_OUT_VAD, sst_set_media_path),
+
+	/* SBA Loops */
+	SST_PATH_INPUT("sprot_loop_in", SST_TASK_SBA, SST_SWM_IN_SPROT_LOOP, NULL),
+	SST_PATH_INPUT("media_loop1_in", SST_TASK_SBA, SST_SWM_IN_MEDIA_LOOP1, NULL),
+	SST_PATH_INPUT("media_loop2_in", SST_TASK_SBA, SST_SWM_IN_MEDIA_LOOP2, NULL),
+	SST_PATH_MEDIA_LOOP_OUTPUT("sprot_loop_out", SST_TASK_SBA, SST_SWM_OUT_SPROT_LOOP, SST_FMT_MONO, sst_set_media_loop),
+	SST_PATH_MEDIA_LOOP_OUTPUT("media_loop1_out", SST_TASK_SBA, SST_SWM_OUT_MEDIA_LOOP1, SST_FMT_MONO, sst_set_media_loop),
+	SST_PATH_MEDIA_LOOP_OUTPUT("media_loop2_out", SST_TASK_SBA, SST_SWM_OUT_MEDIA_LOOP2, SST_FMT_STEREO, sst_set_media_loop),
+
+	/* TODO: need to send command */
+	SST_PATH_INPUT("sidetone_in", SST_TASK_SBA, SST_SWM_IN_SIDETONE, NULL),
+	SST_PATH_INPUT("tone_in", SST_TASK_SBA, SST_SWM_IN_TONE, NULL),
+	SST_PATH_INPUT("bt_in", SST_TASK_SBA, SST_SWM_IN_BT, NULL),
+	SST_PATH_INPUT("fm_in", SST_TASK_SBA, SST_SWM_IN_FM, NULL),
+	SST_PATH_OUTPUT("bt_out", SST_TASK_SBA, SST_SWM_OUT_BT, NULL),
+	SST_PATH_OUTPUT("fm_out", SST_TASK_SBA, SST_SWM_OUT_FM, NULL),
+
+	/* SBA Voice Paths */
+	SST_PATH_INPUT("speech_in", SST_TASK_SBA, SST_SWM_IN_SPEECH, sst_set_speech_path),
+	SST_PATH_INPUT("txspeech_in", SST_TASK_SBA, SST_SWM_IN_TXSPEECH, sst_set_speech_path),
+	SST_PATH_OUTPUT("hf_sns_out", SST_TASK_SBA, SST_SWM_OUT_HF_SNS, sst_set_speech_path),
+	SST_PATH_OUTPUT("hf_out", SST_TASK_SBA, SST_SWM_OUT_HF, sst_set_speech_path),
+	SST_PATH_OUTPUT("speech_out", SST_TASK_SBA, SST_SWM_OUT_SPEECH, sst_set_speech_path),
+	SST_PATH_OUTPUT("rxspeech_out", SST_TASK_SBA, SST_SWM_OUT_RXSPEECH, sst_set_speech_path),
+
+	/* Media Mixers */
+	SST_SWM_MIXER("media0_out mix 0", SST_MIX_MEDIA0, SST_TASK_MMX, SST_SWM_OUT_MEDIA0,
+		      sst_mix_media0_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("media1_out mix 0", SST_MIX_MEDIA1, SST_TASK_MMX, SST_SWM_OUT_MEDIA1,
+		      sst_mix_media1_controls, sst_swm_mixer_event),
+
+	/* SBA PCM mixers */
+	SST_SWM_MIXER("pcm0_out mix 0", SST_MIX_PCM0, SST_TASK_SBA, SST_SWM_OUT_PCM0,
+		      sst_mix_pcm0_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("pcm1_out mix 0", SST_MIX_PCM1, SST_TASK_SBA, SST_SWM_OUT_PCM1,
+		      sst_mix_pcm1_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("pcm2_out mix 0", SST_MIX_PCM2, SST_TASK_SBA, SST_SWM_OUT_PCM2,
+		      sst_mix_pcm2_controls, sst_swm_mixer_event),
+
+	/* SBA Loop mixers */
+	SST_SWM_MIXER("sprot_loop_out mix 0", SST_MIX_LOOP0, SST_TASK_SBA, SST_SWM_OUT_SPROT_LOOP,
+		      sst_mix_sprot_l0_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("media_loop1_out mix 0", SST_MIX_LOOP1, SST_TASK_SBA, SST_SWM_OUT_MEDIA_LOOP1,
+		      sst_mix_media_l1_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("media_loop2_out mix 0", SST_MIX_LOOP2, SST_TASK_SBA, SST_SWM_OUT_MEDIA_LOOP2,
+		      sst_mix_media_l2_controls, sst_swm_mixer_event),
+
+	SST_SWM_MIXER("voip_out mix 0", SST_MIX_VOIP, SST_TASK_SBA, SST_SWM_OUT_VOIP,
+		      sst_mix_voip_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("aware_out mix 0", SST_MIX_AWARE, SST_TASK_SBA, SST_SWM_OUT_AWARE,
+		      sst_mix_aware_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("vad_out mix 0", SST_MIX_VAD, SST_TASK_SBA, SST_SWM_OUT_VAD,
+		      sst_mix_vad_controls, sst_swm_mixer_event),
+
+	/* SBA Voice mixers */
+	SST_SWM_MIXER("hf_sns_out mix 0", SST_MIX_HF_SNS, SST_TASK_SBA, SST_SWM_OUT_HF_SNS,
+		      sst_mix_hf_sns_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("hf_out mix 0", SST_MIX_HF, SST_TASK_SBA, SST_SWM_OUT_HF,
+		      sst_mix_hf_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("speech_out mix 0", SST_MIX_SPEECH, SST_TASK_SBA, SST_SWM_OUT_SPEECH,
+		      sst_mix_speech_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("rxspeech_out mix 0", SST_MIX_RXSPEECH, SST_TASK_SBA, SST_SWM_OUT_RXSPEECH,
+		      sst_mix_rxspeech_controls, sst_swm_mixer_event),
+
+	/* SBA Backend mixers */
+	SST_SWM_MIXER("codec_out0 mix 0", SST_MIX_CODEC0, SST_TASK_SBA, SST_SWM_OUT_CODEC0,
+		      sst_mix_codec0_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("codec_out1 mix 0", SST_MIX_CODEC1, SST_TASK_SBA, SST_SWM_OUT_CODEC1,
+		      sst_mix_codec1_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("bt_out mix 0", SST_MIX_BT, SST_TASK_SBA, SST_SWM_OUT_BT,
+		      sst_mix_bt_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("fm_out mix 0", SST_MIX_FM, SST_TASK_SBA, SST_SWM_OUT_FM,
+		      sst_mix_fm_controls, sst_swm_mixer_event),
+	SST_SWM_MIXER("modem_out mix 0", SST_MIX_MODEM, SST_TASK_SBA, SST_SWM_OUT_MODEM,
+		      sst_mix_modem_controls, sst_swm_mixer_event),
+
+	SND_SOC_DAPM_SWITCH("aware_out aware 0", SND_SOC_NOPM, 0, 0, &sst_mix_sw_aware),
+	SND_SOC_DAPM_MUX("ssp1_out mux 0", SND_SOC_NOPM, 0, 0, &sst_bt_fm_mux),
+
+	SND_SOC_DAPM_SUPPLY("VBTimer", SND_SOC_NOPM, 0, 0,
+			    sst_vb_trigger_event,
+			    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+	{"media0_in", NULL, "Compress Playback"},
+	{"media1_in", NULL, "Headset Playback"},
+	{"media2_in", NULL, "pcm0_out"},
+	{"media3_in", NULL, "Deepbuffer Playback"},
+
+	{"media0_out mix 0", "media0_in", "media0_in"},
+	{"media0_out mix 0", "media1_in", "media1_in"},
+	{"media0_out mix 0", "media2_in", "media2_in"},
+	{"media0_out mix 0", "media3_in", "media3_in"},
+	{"media1_out mix 0", "media0_in", "media0_in"},
+	{"media1_out mix 0", "media1_in", "media1_in"},
+	{"media1_out mix 0", "media2_in", "media2_in"},
+	{"media1_out mix 0", "media3_in", "media3_in"},
+
+	{"media0_out", NULL, "media0_out mix 0"},
+	{"media1_out", NULL, "media1_out mix 0"},
+	{"pcm0_in", NULL, "media0_out"},
+	{"pcm1_in", NULL, "media1_out"},
+
+	{"Headset Capture", NULL, "pcm1_out"},
+	{"Headset Capture", NULL, "pcm2_out"},
+	{"pcm0_out", NULL, "pcm0_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("pcm0_out mix 0"),
+	{"pcm1_out", NULL, "pcm1_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("pcm1_out mix 0"),
+	{"pcm2_out", NULL, "pcm2_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("pcm2_out mix 0"),
+
+	{"media_loop1_in", NULL, "media_loop1_out"},
+	{"media_loop1_out", NULL, "media_loop1_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("media_loop1_out mix 0"),
+	{"media_loop2_in", NULL, "media_loop2_out"},
+	{"media_loop2_out", NULL, "media_loop2_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("media_loop2_out mix 0"),
+	{"sprot_loop_in", NULL, "sprot_loop_out"},
+	{"sprot_loop_out", NULL, "sprot_loop_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("sprot_loop_out mix 0"),
+
+	{"voip_in", NULL, "VOIP Playback"},
+	{"VOIP Capture", NULL, "voip_out"},
+	{"voip_out", NULL, "voip_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("voip_out mix 0"),
+
+	{"aware", NULL, "aware_out"},
+	{"aware_out", NULL, "aware_out aware 0"},
+	{"aware_out aware 0", "switch", "aware_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("aware_out mix 0"),
+	{"vad", NULL, "vad_out"},
+	{"vad_out", NULL, "vad_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("vad_out mix 0"),
+
+	{"codec_out0", NULL, "codec_out0 mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("codec_out0 mix 0"),
+	{"codec_out1", NULL, "codec_out1 mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("codec_out1 mix 0"),
+	{"modem_out", NULL, "modem_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("modem_out mix 0"),
+
+	{"bt_fm_out", NULL, "ssp1_out mux 0"},
+	{"ssp1_out mux 0", "bt", "bt_out"},
+	{"ssp1_out mux 0", "fm", "fm_out"},
+	{"bt_out", NULL, "bt_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("bt_out mix 0"),
+	{"fm_out", NULL, "fm_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("fm_out mix 0"),
+	{"bt_in", NULL, "bt_fm_in"},
+	{"fm_in", NULL, "bt_fm_in"},
+
+	/* Uplink processing */
+	{"txspeech_in", NULL, "hf_sns_out"},
+	{"txspeech_in", NULL, "hf_out"},
+	{"txspeech_in", NULL, "speech_out"},
+
+	{"hf_sns_out", NULL, "hf_sns_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("hf_sns_out mix 0"),
+	{"hf_out", NULL, "hf_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("hf_out mix 0"),
+	{"speech_out", NULL, "speech_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("speech_out mix 0"),
+
+	/* Downlink processing */
+	{"speech_in", NULL, "rxspeech_out"},
+	{"rxspeech_out", NULL, "rxspeech_out mix 0"},
+	SST_SBA_MIXER_GRAPH_MAP("rxspeech_out mix 0"),
+
+	/* TODO: add Tone inputs */
+	/* TODO: add Low Latency stream support */
+
+	{"Headset Capture", NULL, "VBTimer"},
+	{"Headset Playback", NULL, "VBTimer"},
+	{"Deepbuffer Playback", NULL, "VBTimer"},
+	{"Compress Playback", NULL, "VBTimer"},
+	{"VOIP Playback", NULL, "VBTimer"},
+	{"aware", NULL, "VBTimer"},
+	{"modem_in", NULL, "VBTimer"},
+	{"modem_out", NULL, "VBTimer"},
+	{"bt_fm_in", NULL, "VBTimer"},
+	{"bt_fm_out", NULL, "VBTimer"},
+};
+
+static const char * const sst_nb_wb_texts[] = {
+	"narrowband", "wideband",
+};
+
+static const struct snd_kcontrol_new sst_mux_controls[] = {
+	SST_SSP_MUX_CTL("domain voice mode", 0, SST_MUX_REG, SST_VOICE_MODE_SHIFT, sst_nb_wb_texts,
+			sst_mode_get, sst_mode_put),
+	SST_SSP_MUX_CTL("domain bt mode", 0, SST_MUX_REG, SST_BT_MODE_SHIFT, sst_nb_wb_texts,
+			sst_mode_get, sst_mode_put),
+};
+
+static const char * const slot_names[] = {
+	"none",
+	"slot 0", "slot 1", "slot 2", "slot 3",
+	"slot 4", "slot 5", "slot 6", "slot 7", /* not supported by FW */
+};
+
+static const char * const channel_names[] = {
+	"none",
+	"codec_out0_0", "codec_out0_1", "codec_out1_0", "codec_out1_1",
+	"codec_out2_0", "codec_out2_1", "codec_out3_0", "codec_out3_1", /* not supported by FW */
+};
+
+#define SST_INTERLEAVER(xpname, slot_name, slotno) \
+	SST_SSP_SLOT_CTL(xpname, "interleaver", slot_name, slotno, 1, \
+			 channel_names, sst_slot_get, sst_slot_put)
+
+#define SST_DEINTERLEAVER(xpname, channel_name, channel_no) \
+	SST_SSP_SLOT_CTL(xpname, "deinterleaver", channel_name, channel_no, 0, \
+			 slot_names, sst_slot_get, sst_slot_put)
+
+static const struct snd_kcontrol_new sst_slot_controls[] = {
+	SST_INTERLEAVER("codec_out", "slot 0", 0),
+	SST_INTERLEAVER("codec_out", "slot 1", 1),
+	SST_INTERLEAVER("codec_out", "slot 2", 2),
+	SST_INTERLEAVER("codec_out", "slot 3", 3),
+	SST_DEINTERLEAVER("codec_in", "codec_in0_0", 0),
+	SST_DEINTERLEAVER("codec_in", "codec_in0_1", 1),
+	SST_DEINTERLEAVER("codec_in", "codec_in1_0", 2),
+	SST_DEINTERLEAVER("codec_in", "codec_in1_1", 3),
+};
+
+#define SST_NUM_PROBE_CONNECTION_PTS 31
+static const struct sst_probe_config sst_probes[SST_NUM_PROBE_CONNECTION_PTS] = {
+	/* TODO: get this struct from FW config data */
+	/* TODO: only gain outputs supported currently */
+	{ "media0_in gain", SST_PATH_INDEX_MEDIA0_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media1_in gain", SST_PATH_INDEX_MEDIA1_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media2_in gain", SST_PATH_INDEX_MEDIA2_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "media3_in gain", SST_PATH_INDEX_MEDIA3_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_MMX, { 1, 2, 1 } },
+	{ "pcm0_in gain", SST_PATH_INDEX_PCM0_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "pcm1_in gain", SST_PATH_INDEX_PCM1_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "pcm1_out gain", SST_PATH_INDEX_PCM1_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "pcm2_out gain", SST_PATH_INDEX_PCM2_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "voip_in gain", SST_PATH_INDEX_VOIP_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "voip_out gain", SST_PATH_INDEX_VOIP_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "aware_out gain", SST_PATH_INDEX_AWARE_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "vad_out gain", SST_PATH_INDEX_VAD_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "hf_sns_out gain", SST_PATH_INDEX_HF_SNS_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "hf_out gain", SST_PATH_INDEX_HF_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "speech_out gain", SST_PATH_INDEX_SPEECH_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "txspeech_in gain", SST_PATH_INDEX_TX_SPEECH_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "rxspeech_out gain", SST_PATH_INDEX_RX_SPEECH_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "speech_in gain", SST_PATH_INDEX_SPEECH_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "media_loop1_out gain", SST_PATH_INDEX_MEDIA_LOOP1_OUT , SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "media_loop2_out gain", SST_PATH_INDEX_MEDIA_LOOP2_OUT , SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "tone_in gain", SST_PATH_INDEX_TONE_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "codec_out0 gain", SST_PATH_INDEX_CODEC_OUT0, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "codec_out1 gain", SST_PATH_INDEX_CODEC_OUT1, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "bt_out gain", SST_PATH_INDEX_BT_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "fm_out gain", SST_PATH_INDEX_FM_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "modem_out gain", SST_PATH_INDEX_MODEM_OUT, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "codec_in0 gain", SST_PATH_INDEX_CODEC_IN0, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "codec_in1 gain", SST_PATH_INDEX_CODEC_IN1, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "bt_in gain", SST_PATH_INDEX_BT_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "fm_in gain", SST_PATH_INDEX_FM_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+	{ "modem_in gain", SST_PATH_INDEX_MODEM_IN, SST_MODULE_ID_GAIN_CELL, SST_TASK_SBA, { 1, 2, 1 } },
+};
+
+/* initialized based on names in sst_probes array */
+static const char *sst_probe_enum_texts[SST_NUM_PROBE_CONNECTION_PTS];
+static const SOC_ENUM_SINGLE_EXT_DECL(sst_probe_enum, sst_probe_enum_texts);
+
+#define SST_PROBE_CTL(name, num)						\
+	SST_PROBE_ENUM(SST_PROBE_CTL_NAME(name, num, "connection"),		\
+		       sst_probe_enum, sst_probe_get, sst_probe_put)
+	/* TODO: implement probe gains
+	SOC_SINGLE_EXT_TLV(SST_PROBE_CTL_NAME(name, num, "gains"), xreg, xshift,
+		xmax, xinv, xget, xput, sst_gain_tlv_common)
+	*/
+
+static const struct snd_kcontrol_new sst_probe_controls[] = {
+	SST_PROBE_CTL("probe out", 0),
+	SST_PROBE_CTL("probe out", 1),
+	SST_PROBE_CTL("probe out", 2),
+	SST_PROBE_CTL("probe out", 3),
+	SST_PROBE_CTL("probe out", 4),
+	SST_PROBE_CTL("probe out", 5),
+	SST_PROBE_CTL("probe out", 6),
+	SST_PROBE_CTL("probe out", 7),
+	SST_PROBE_CTL("probe in", 0),
+	SST_PROBE_CTL("probe in", 1),
+	SST_PROBE_CTL("probe in", 2),
+	SST_PROBE_CTL("probe in", 3),
+	SST_PROBE_CTL("probe in", 4),
+	SST_PROBE_CTL("probe in", 5),
+	SST_PROBE_CTL("probe in", 6),
+	SST_PROBE_CTL("probe in", 7),
+};
+
+/* Gain helper with min/max set */
+#define SST_GAIN(name, path_id, task_id, instance, gain_var)				\
+	SST_GAIN_KCONTROLS(name, "gain", SST_GAIN_MIN_VALUE, SST_GAIN_MAX_VALUE,	\
+		SST_GAIN_TC_MIN, SST_GAIN_TC_MAX,					\
+		sst_gain_get, sst_gain_put,						\
+		SST_MODULE_ID_GAIN_CELL, path_id, instance, task_id,			\
+		sst_gain_tlv_common, gain_var)
+
+#define SST_VOLUME(name, path_id, task_id, instance, gain_var)				\
+	SST_GAIN_KCONTROLS(name, "volume", SST_GAIN_MIN_VALUE, SST_GAIN_MAX_VALUE,	\
+		SST_GAIN_TC_MIN, SST_GAIN_TC_MAX,					\
+		sst_gain_get, sst_gain_put,						\
+		SST_MODULE_ID_VOLUME, path_id, instance, task_id,			\
+		sst_gain_tlv_common, gain_var)
+
+#define SST_NUM_GAINS 36
+static struct sst_gain_value sst_gains[SST_NUM_GAINS];
+
+static const struct snd_kcontrol_new sst_gain_controls[] = {
+	SST_GAIN("media0_in", SST_PATH_INDEX_MEDIA0_IN, SST_TASK_MMX, 0, &sst_gains[0]),
+	SST_GAIN("media1_in", SST_PATH_INDEX_MEDIA1_IN, SST_TASK_MMX, 0, &sst_gains[1]),
+	SST_GAIN("media2_in", SST_PATH_INDEX_MEDIA2_IN, SST_TASK_MMX, 0, &sst_gains[2]),
+	SST_GAIN("media3_in", SST_PATH_INDEX_MEDIA3_IN, SST_TASK_MMX, 0, &sst_gains[3]),
+
+	SST_GAIN("pcm0_in", SST_PATH_INDEX_PCM0_IN, SST_TASK_SBA, 0, &sst_gains[4]),
+	SST_GAIN("pcm1_in", SST_PATH_INDEX_PCM1_IN, SST_TASK_SBA, 0, &sst_gains[5]),
+	SST_GAIN("low_pcm0_in", SST_PATH_INDEX_LOW_PCM0_IN, SST_TASK_SBA, 0, &sst_gains[6]),
+	SST_GAIN("pcm1_out", SST_PATH_INDEX_PCM1_OUT, SST_TASK_SBA, 0, &sst_gains[7]),
+	SST_GAIN("pcm2_out", SST_PATH_INDEX_PCM1_OUT, SST_TASK_SBA, 0, &sst_gains[8]),
+
+	SST_GAIN("voip_in", SST_PATH_INDEX_VOIP_IN, SST_TASK_SBA, 0, &sst_gains[9]),
+	SST_GAIN("voip_out", SST_PATH_INDEX_VOIP_OUT, SST_TASK_SBA, 0, &sst_gains[10]),
+	SST_GAIN("tone_in", SST_PATH_INDEX_TONE_IN, SST_TASK_SBA, 0, &sst_gains[11]),
+
+	SST_GAIN("aware_out", SST_PATH_INDEX_AWARE_OUT, SST_TASK_SBA, 0, &sst_gains[12]),
+	SST_GAIN("vad_out", SST_PATH_INDEX_VAD_OUT, SST_TASK_SBA, 0, &sst_gains[13]),
+
+	SST_GAIN("hf_sns_out", SST_PATH_INDEX_HF_SNS_OUT, SST_TASK_SBA, 0, &sst_gains[14]),
+	SST_GAIN("hf_out", SST_PATH_INDEX_HF_OUT, SST_TASK_SBA, 0, &sst_gains[15]),
+	SST_GAIN("speech_out", SST_PATH_INDEX_SPEECH_OUT, SST_TASK_SBA, 0, &sst_gains[16]),
+	SST_GAIN("txspeech_in", SST_PATH_INDEX_TX_SPEECH_IN, SST_TASK_SBA, 0, &sst_gains[17]),
+	SST_GAIN("rxspeech_out", SST_PATH_INDEX_RX_SPEECH_OUT, SST_TASK_SBA, 0, &sst_gains[18]),
+	SST_GAIN("speech_in", SST_PATH_INDEX_SPEECH_IN, SST_TASK_SBA, 0, &sst_gains[19]),
+
+	SST_GAIN("codec_in0", SST_PATH_INDEX_CODEC_IN0, SST_TASK_SBA, 0, &sst_gains[20]),
+	SST_GAIN("codec_in1", SST_PATH_INDEX_CODEC_IN1, SST_TASK_SBA, 0, &sst_gains[21]),
+	SST_GAIN("codec_out0", SST_PATH_INDEX_CODEC_OUT0, SST_TASK_SBA, 0, &sst_gains[22]),
+	SST_GAIN("codec_out1", SST_PATH_INDEX_CODEC_OUT1, SST_TASK_SBA, 0, &sst_gains[23]),
+	SST_GAIN("bt_out", SST_PATH_INDEX_BT_OUT, SST_TASK_SBA, 0, &sst_gains[24]),
+	SST_GAIN("fm_out", SST_PATH_INDEX_FM_OUT, SST_TASK_SBA, 0, &sst_gains[25]),
+	SST_GAIN("bt_in", SST_PATH_INDEX_BT_IN, SST_TASK_SBA, 0, &sst_gains[26]),
+	SST_GAIN("fm_in", SST_PATH_INDEX_FM_IN, SST_TASK_SBA, 0, &sst_gains[27]),
+	SST_GAIN("modem_in", SST_PATH_INDEX_MODEM_IN, SST_TASK_SBA, 0, &sst_gains[28]),
+	SST_GAIN("modem_out", SST_PATH_INDEX_MODEM_OUT, SST_TASK_SBA, 0, &sst_gains[29]),
+	SST_GAIN("media_loop1_out", SST_PATH_INDEX_MEDIA_LOOP1_OUT, SST_TASK_SBA, 0, &sst_gains[30]),
+	SST_GAIN("media_loop2_out", SST_PATH_INDEX_MEDIA_LOOP2_OUT, SST_TASK_SBA, 0, &sst_gains[31]),
+	SST_GAIN("sprot_loop_out", SST_PATH_INDEX_SPROT_LOOP_OUT, SST_TASK_SBA, 0, &sst_gains[32]),
+	SST_VOLUME("media0_in", SST_PATH_INDEX_MEDIA0_IN, SST_TASK_MMX, 0, &sst_gains[33]),
+	SST_GAIN("sidetone_in", SST_PATH_INDEX_SIDETONE_IN, SST_TASK_SBA, 0, &sst_gains[34]),
+	SST_GAIN("speech_out", SST_PATH_INDEX_SPEECH_OUT, SST_TASK_FBA_UL, 1, &sst_gains[35]),
+};
+
+static const struct snd_kcontrol_new sst_algo_controls[] = {
+	SST_ALGO_KCONTROL_BYTES("media_loop1_out", "fir", 138, SST_MODULE_ID_FIR_24,
+		 SST_PATH_INDEX_MEDIA_LOOP1_OUT, 0, SST_TASK_SBA, SBA_VB_SET_FIR),
+	SST_ALGO_KCONTROL_BYTES("media_loop1_out", "iir", 300, SST_MODULE_ID_IIR_24,
+		SST_PATH_INDEX_MEDIA_LOOP1_OUT, 0, SST_TASK_SBA, SBA_VB_SET_IIR),
+	SST_ALGO_KCONTROL_BYTES("media_loop1_out", "mdrp", 76, SST_MODULE_ID_MDRP,
+		SST_PATH_INDEX_MEDIA_LOOP1_OUT, 0, SST_TASK_SBA, SBA_SET_MDRP),
+	SST_ALGO_KCONTROL_BYTES("media_loop2_out", "fir", 272, SST_MODULE_ID_FIR_24,
+		SST_PATH_INDEX_MEDIA_LOOP2_OUT, 0, SST_TASK_SBA, SBA_VB_SET_FIR),
+	SST_ALGO_KCONTROL_BYTES("media_loop2_out", "iir", 300, SST_MODULE_ID_IIR_24,
+		SST_PATH_INDEX_MEDIA_LOOP2_OUT, 0, SST_TASK_SBA, SBA_VB_SET_IIR),
+	SST_ALGO_KCONTROL_BYTES("media_loop2_out", "mdrp", 76, SST_MODULE_ID_MDRP,
+		SST_PATH_INDEX_MEDIA_LOOP2_OUT, 0, SST_TASK_SBA, SBA_SET_MDRP),
+	SST_ALGO_KCONTROL_BYTES("aware_out", "fir", 272, SST_MODULE_ID_FIR_24,
+		SST_PATH_INDEX_AWARE_OUT, 0, SST_TASK_SBA, SBA_VB_SET_FIR),
+	SST_ALGO_KCONTROL_BYTES("aware_out", "iir", 300, SST_MODULE_ID_IIR_24,
+		SST_PATH_INDEX_AWARE_OUT, 0, SST_TASK_SBA, SBA_VB_SET_IIR),
+	SST_ALGO_KCONTROL_BYTES("aware_out", "aware", 48, SST_MODULE_ID_CONTEXT_ALGO_AWARE,
+		SST_PATH_INDEX_AWARE_OUT, 0, SST_TASK_AWARE, AWARE_ENV_CLASS_PARAMS),
+	SST_ALGO_KCONTROL_BYTES("vad_out", "fir", 272, SST_MODULE_ID_FIR_24,
+		SST_PATH_INDEX_VAD_OUT, 0, SST_TASK_SBA, SBA_VB_SET_FIR),
+	SST_ALGO_KCONTROL_BYTES("vad_out", "iir", 300, SST_MODULE_ID_IIR_24,
+		SST_PATH_INDEX_VAD_OUT, 0, SST_TASK_SBA, SBA_VB_SET_IIR),
+	SST_ALGO_KCONTROL_BYTES("sprot_loop_out", "lpro", 192, SST_MODULE_ID_SPROT,
+		SST_PATH_INDEX_SPROT_LOOP_OUT, 0, SST_TASK_SBA, SBA_VB_LPRO),
+	SST_ALGO_KCONTROL_BYTES("codec_in0", "dcr", 300, SST_MODULE_ID_FILT_DCR,
+		SST_PATH_INDEX_CODEC_IN0, 0, SST_TASK_SBA, SBA_VB_SET_IIR),
+	SST_ALGO_KCONTROL_BYTES("codec_in1", "dcr", 300, SST_MODULE_ID_FILT_DCR,
+		SST_PATH_INDEX_CODEC_IN1, 0, SST_TASK_SBA, SBA_VB_SET_IIR),
+	/* Uplink */
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "fir_speech", 136, SST_MODULE_ID_FIR_16,
+		SST_PATH_INDEX_SPEECH_OUT, 0, SST_TASK_FBA_UL, FBA_VB_SET_FIR),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "fir_hf_sns", 136, SST_MODULE_ID_FIR_16,
+		SST_PATH_INDEX_HF_SNS_OUT, 0, SST_TASK_FBA_UL, FBA_VB_SET_FIR),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "iir_speech", 48, SST_MODULE_ID_IIR_16,
+		SST_PATH_INDEX_SPEECH_OUT, 0, SST_TASK_FBA_UL, FBA_VB_SET_IIR),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "iir_hf_sns", 48, SST_MODULE_ID_IIR_16,
+		SST_PATH_INDEX_HF_SNS_OUT, 0, SST_TASK_FBA_UL, FBA_VB_SET_IIR),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "aec", 640, SST_MODULE_ID_AEC,
+		SST_PATH_INDEX_SPEECH_OUT, 0, SST_TASK_FBA_UL, FBA_VB_AEC),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "nr", 38, SST_MODULE_ID_NR,
+		SST_PATH_INDEX_SPEECH_OUT, 0, SST_TASK_FBA_UL, FBA_VB_NR_UL),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "agc", 58, SST_MODULE_ID_AGC,
+		SST_PATH_INDEX_SPEECH_OUT, 0, SST_TASK_FBA_UL, FBA_VB_AGC),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "biquad", 22, SST_MODULE_ID_DRP,
+		SST_PATH_INDEX_SPEECH_OUT, 0, SST_TASK_FBA_UL, FBA_VB_SET_BIQUAD_D_C),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "compr", 36, SST_MODULE_ID_DRP,
+		SST_PATH_INDEX_SPEECH_OUT, 0, SST_TASK_FBA_UL, FBA_VB_DUAL_BAND_COMP),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "sns", 324, SST_MODULE_ID_NR_SNS,
+		SST_PATH_INDEX_SPEECH_OUT, 0, SST_TASK_FBA_UL, FBA_VB_SNS),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "ser", 42, SST_MODULE_ID_SER,
+		SST_PATH_INDEX_SPEECH_OUT, 0, SST_TASK_FBA_UL, FBA_VB_SER),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "cni", 48, SST_MODULE_ID_CNI_TX,
+		SST_PATH_INDEX_SPEECH_OUT, 0, SST_TASK_FBA_UL, FBA_VB_TX_CNI),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "ref", 24, SST_MODULE_ID_REF_LINE,
+		SST_PATH_INDEX_HF_OUT, 0, SST_TASK_FBA_UL, FBA_VB_SET_REF_LINE),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "delay", 6, SST_MODULE_ID_EDL,
+		SST_PATH_INDEX_HF_OUT, 0, SST_TASK_FBA_UL, FBA_VB_SET_DELAY_LINE),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "bmf", 264, SST_MODULE_ID_BMF,
+		SST_PATH_INDEX_HF_SNS_OUT, 0, SST_TASK_FBA_UL, FBA_VB_BMF),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_out", "ul_module", "dnr", 18, SST_MODULE_ID_DNR,
+		SST_PATH_INDEX_SPEECH_OUT, 0, SST_TASK_FBA_UL, FBA_VB_DNR),
+	/* Downlink */
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_in", "dl_module", "ana", 52, SST_MODULE_ID_ANA,
+		SST_PATH_INDEX_SPEECH_IN, 0, SST_TASK_FBA_DL, FBA_VB_ANA),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_in", "dl_module", "fir", 136, SST_MODULE_ID_FIR_16,
+		SST_PATH_INDEX_SPEECH_IN, 0, SST_TASK_FBA_DL, FBA_VB_SET_FIR),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_in", "dl_module", "iir", 48, SST_MODULE_ID_IIR_16,
+		SST_PATH_INDEX_SPEECH_IN, 0, SST_TASK_FBA_DL, FBA_VB_SET_IIR),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_in", "dl_module", "nr", 38, SST_MODULE_ID_NR,
+		SST_PATH_INDEX_SPEECH_IN, 0, SST_TASK_FBA_DL, FBA_VB_NR_DL),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_in", "dl_module", "biquad", 22, SST_MODULE_ID_DRP,
+		SST_PATH_INDEX_SPEECH_IN, 0, SST_TASK_FBA_DL, FBA_VB_SET_BIQUAD_D_C),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_in", "dl_module", "compr", 36, SST_MODULE_ID_DRP,
+		SST_PATH_INDEX_SPEECH_IN, 0, SST_TASK_FBA_DL, FBA_VB_DUAL_BAND_COMP),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_in", "dl_module", "cni", 48, SST_MODULE_ID_CNI,
+		SST_PATH_INDEX_SPEECH_IN, 0, SST_TASK_FBA_DL, FBA_VB_RX_CNI),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_in", "dl_module", "bwx", 54, SST_MODULE_ID_BWX,
+		SST_PATH_INDEX_SPEECH_IN, 0, SST_TASK_FBA_DL, FBA_VB_BWX),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_in", "dl_module", "gmm", 586, SST_MODULE_ID_BWX,
+		SST_PATH_INDEX_SPEECH_IN, 0, SST_TASK_FBA_DL, FBA_VB_GMM),
+	SST_COMBO_ALGO_KCONTROL_BYTES("speech_in", "dl_module", "glc", 18, SST_MODULE_ID_GLC,
+		SST_PATH_INDEX_SPEECH_IN, 0, SST_TASK_FBA_DL, FBA_VB_GLC),
+};
+
+static const struct snd_kcontrol_new sst_debug_controls[] = {
+	SND_SOC_BYTES_EXT("sst debug byte control", SST_MAX_BIN_BYTES,
+		       sst_byte_control_get, sst_byte_control_set),
+};
+
+static inline bool is_sst_dapm_widget(struct snd_soc_dapm_widget *w)
+{
+	if ((w->id == snd_soc_dapm_pga) ||
+	    (w->id == snd_soc_dapm_aif_in) ||
+	    (w->id == snd_soc_dapm_aif_out) ||
+	    (w->id == snd_soc_dapm_input) ||
+	    (w->id == snd_soc_dapm_output) ||
+	    (w->id == snd_soc_dapm_mixer))
+		return true;
+	else
+		return false;
+}
+
+int sst_send_pipe_gains(struct snd_soc_dai *dai, int stream, int mute)
+{
+	struct snd_soc_platform *platform = dai->platform;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+	struct snd_soc_dapm_widget *w;
+	struct snd_soc_dapm_path *p = NULL;
+
+	pr_debug("%s: enter, dai-name=%s dir=%d\n", __func__, dai->name, stream);
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		pr_debug("Stream name=%s\n", dai->playback_widget->name);
+		w = dai->playback_widget;
+		list_for_each_entry(p, &w->sinks, list_source) {
+			if (p->connected && !p->connected(w, p->sink))
+				continue;
+
+			if (p->connect && p->sink->power && is_sst_dapm_widget(p->sink)) {
+				struct sst_ids *ids = p->sink->priv;
+
+				pr_debug("send gains for widget=%s\n", p->sink->name);
+				sst_set_pipe_gain(ids, sst, mute);
+			}
+		}
+	} else {
+		pr_debug("Stream name=%s\n", dai->capture_widget->name);
+		w = dai->capture_widget;
+		list_for_each_entry(p, &w->sources, list_sink) {
+			if (p->connected && !p->connected(w, p->sink))
+				continue;
+
+			if (p->connect &&  p->source->power && is_sst_dapm_widget(p->source)) {
+				struct sst_ids *ids = p->source->priv;
+
+				pr_debug("send gain for widget=%s\n", p->source->name);
+				sst_set_pipe_gain(ids, sst, mute);
+			}
+		}
+	}
+	return 0;
+}
+
+static int sst_fill_module_list(struct snd_kcontrol *kctl,
+	 struct snd_soc_dapm_widget *w, int type)
+{
+	struct module *module = NULL;
+	struct sst_ids *ids = w->priv;
+
+	module = devm_kzalloc(w->platform->dev, sizeof(*module), GFP_KERNEL);
+	if (!module) {
+		pr_err("kzalloc block failed\n");
+		return -ENOMEM;
+	}
+
+	if (type == SST_MODULE_GAIN) {
+		struct sst_gain_mixer_control *mc = (void *)kctl->private_value;
+
+		mc->w = w;
+		module->kctl = kctl;
+		list_add_tail(&module->node, &ids->gain_list);
+	} else if (type == SST_MODULE_ALGO) {
+		struct sst_algo_control *bc = (void *)kctl->private_value;
+
+		bc->w = w;
+		module->kctl = kctl;
+		list_add_tail(&module->node, &ids->algo_list);
+	}
+
+	return 0;
+}
+
+static int sst_fill_widget_module_info(struct snd_soc_dapm_widget *w,
+	struct snd_soc_platform *platform)
+{
+	struct snd_kcontrol *kctl;
+	int index, ret = 0;
+	struct snd_card *card = platform->card->snd_card;
+	char *idx;
+
+	down_read(&card->controls_rwsem);
+
+	list_for_each_entry(kctl, &card->controls, list) {
+		idx = strstr(kctl->id.name, " ");
+		if (idx == NULL)
+			continue;
+		index  = strlen(kctl->id.name) - strlen(idx);
+		if (strstr(kctl->id.name, "volume") &&
+		    !strncmp(kctl->id.name, w->name, index))
+			ret = sst_fill_module_list(kctl, w, SST_MODULE_GAIN);
+		else if (strstr(kctl->id.name, "params") &&
+			 !strncmp(kctl->id.name, w->name, index))
+			ret = sst_fill_module_list(kctl, w, SST_MODULE_ALGO);
+		else if (strstr(kctl->id.name, "mute") &&
+			 !strncmp(kctl->id.name, w->name, index)) {
+			struct sst_gain_mixer_control *mc = (void *)kctl->private_value;
+			mc->w = w;
+		}
+		if (ret < 0) {
+			up_read(&card->controls_rwsem);
+			return ret;
+		}
+	}
+	up_read(&card->controls_rwsem);
+	return 0;
+}
+
+static int sst_map_modules_to_pipe(struct snd_soc_platform *platform)
+{
+	struct snd_soc_dapm_widget *w;
+	struct snd_soc_dapm_context *dapm = &platform->dapm;
+	int ret = 0;
+
+	list_for_each_entry(w, &dapm->card->widgets, list) {
+		if (w->platform && is_sst_dapm_widget(w) && (w->priv)) {
+			struct sst_ids *ids = w->priv;
+
+			pr_debug("widget type=%d name=%s", w->id, w->name);
+			INIT_LIST_HEAD(&ids->algo_list);
+			INIT_LIST_HEAD(&ids->gain_list);
+			ret = sst_fill_widget_module_info(w, platform);
+			if (ret < 0)
+				return ret;
+		}
+	}
+	return 0;
+}
+
+int sst_dsp_init_v2_dpcm(struct snd_soc_platform *platform)
+{
+	int i, ret = 0;
+	struct sst_data *sst = snd_soc_platform_get_drvdata(platform);
+
+	sst->byte_stream = devm_kzalloc(platform->dev,
+					SST_MAX_BIN_BYTES, GFP_KERNEL);
+	if (!sst->byte_stream) {
+		pr_err("%s: kzalloc failed\n", __func__);
+		return -ENOMEM;
+	}
+	sst->widget = devm_kzalloc(platform->dev,
+				   SST_NUM_WIDGETS * sizeof(*sst->widget),
+				   GFP_KERNEL);
+	if (!sst->widget) {
+		pr_err("%s: kzalloc failed\n", __func__);
+		return -ENOMEM;
+	}
+
+	snd_soc_dapm_new_controls(&platform->dapm, sst_dapm_widgets,
+			ARRAY_SIZE(sst_dapm_widgets));
+	snd_soc_dapm_add_routes(&platform->dapm, intercon,
+			ARRAY_SIZE(intercon));
+	snd_soc_dapm_new_widgets(platform->dapm.card);
+
+	for (i = 0; i < SST_NUM_GAINS; i++) {
+		sst_gains[i].mute = SST_GAIN_MUTE_DEFAULT;
+		sst_gains[i].l_gain = SST_GAIN_VOLUME_DEFAULT;
+		sst_gains[i].r_gain = SST_GAIN_VOLUME_DEFAULT;
+		sst_gains[i].ramp_duration = SST_GAIN_RAMP_DURATION_DEFAULT;
+	}
+
+	snd_soc_add_platform_controls(platform, sst_gain_controls,
+			ARRAY_SIZE(sst_gain_controls));
+
+	snd_soc_add_platform_controls(platform, sst_algo_controls,
+			ARRAY_SIZE(sst_algo_controls));
+	snd_soc_add_platform_controls(platform, sst_slot_controls,
+			ARRAY_SIZE(sst_slot_controls));
+	snd_soc_add_platform_controls(platform, sst_mux_controls,
+			ARRAY_SIZE(sst_mux_controls));
+
+	/* initialize the names of the probe points */
+	for (i = 0; i < SST_NUM_PROBE_CONNECTION_PTS; i++)
+		sst_probe_enum_texts[i] = sst_probes[i].name;
+
+	snd_soc_add_platform_controls(platform, sst_probe_controls,
+			ARRAY_SIZE(sst_probe_controls));
+
+	ret = sst_map_modules_to_pipe(platform);
+
+	return ret;
+}
diff --git a/sound/soc/intel/platform-libs/ipc_lib.h b/sound/soc/intel/platform-libs/ipc_lib.h
new file mode 100644
index 0000000..6ba50c4
--- /dev/null
+++ b/sound/soc/intel/platform-libs/ipc_lib.h
@@ -0,0 +1,33 @@
+/*
+ *  ipc_lib.h - Intel MID Platform driver header file
+ *
+ *  Copyright (C) 2013 Intel Corp
+ *  Author: Lakshmi N Vinnakota <lakshmi.n.vinnakota@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *
+ */
+
+#ifndef __PLATFORMDRV_IPC_LIB_H__
+#define __PLATFORMDRV_IPC_LIB_H__
+
+struct sst_algo_int_control_v2;
+
+void sst_create_compr_vol_ipc(char *bytes, unsigned int type,
+		struct sst_algo_int_control_v2 *kdata);
+#endif
diff --git a/sound/soc/intel/platform-libs/ipc_lib_v2.c b/sound/soc/intel/platform-libs/ipc_lib_v2.c
new file mode 100644
index 0000000..105c756
--- /dev/null
+++ b/sound/soc/intel/platform-libs/ipc_lib_v2.c
@@ -0,0 +1,109 @@
+/*
+ *  ipc_lib_v2.c - Intel MID Platform Driver IPC wrappers for mrfld
+ *
+ *  Copyright (C) 2013 Intel Corp
+ *  Author: Lakshmi N Vinnakota <lakshmi.n.vinnakota@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *
+ */
+#include <sound/soc.h>
+#include <asm/platform_sst_audio.h>
+#include "../platform_ipc_v2.h"
+#include "../sst_platform.h"
+#include "../sst_platform_pvt.h"
+
+
+static inline void sst_fill_dsp_hdr(struct ipc_dsp_hdr *hdr, u8 index, u8 pipe,
+	u16 module, u16 cmd, u16 len)
+{
+	hdr->mod_index_id = index;
+	hdr->pipe_id = pipe;
+	hdr->mod_id = module;
+	hdr->cmd_id = cmd;
+	hdr->length = len;
+
+}
+
+static inline void sst_fill_byte_control_hdr(struct snd_sst_bytes_v2 *hdr,
+	u8 type, u8 msg, u8 block, u8 task, u8 pipe, u16 len)
+{
+	hdr->type = type;
+	hdr->ipc_msg = msg;
+	hdr->block = block;
+	hdr->task_id = task;
+	hdr->pipe_id = pipe;
+	hdr->rsvd = 0;
+	hdr->len = len;
+}
+
+#define SST_GAIN_V2_TIME_CONST 50
+
+void sst_create_compr_vol_ipc(char *bytes, unsigned int type,
+	struct sst_algo_int_control_v2 *kdata)
+{
+	struct snd_sst_gain_v2 gain1;
+	struct snd_sst_bytes_v2 byte_hdr;
+	struct ipc_dsp_hdr dsp_hdr;
+	char *tmp;
+	u16 len;
+	u8 ipc_msg;
+
+	/* Fill gain params */
+	gain1.gain_cell_num = 1;  /* num of gain cells to modify*/
+	gain1.cell_nbr_idx = kdata->instance_id; /* instance index */
+	gain1.cell_path_idx = kdata->pipe_id; /* pipe id */
+	gain1.module_id = kdata->module_id; /*module id */
+	gain1.left_cell_gain = kdata->value; /* left gain value in dB*/
+	gain1.right_cell_gain = kdata->value; /* same value as left in dB*/
+	/* set to default recommended value*/
+	gain1.gain_time_const = SST_GAIN_V2_TIME_CONST;
+
+	/* fill dsp header */
+	/* Get params format for vol ctrl lib, size 6 bytes :
+	 * u16 left_gain, u16 right_gain, u16 ramp
+	 */
+	memset(&dsp_hdr, 0, sizeof(dsp_hdr));
+	if (type == SND_SST_BYTES_GET) {
+		len = 6;
+		ipc_msg = IPC_GET_PARAMS;
+	} else {
+		len = sizeof(gain1);
+		ipc_msg = IPC_SET_PARAMS;
+	}
+
+	sst_fill_dsp_hdr(&dsp_hdr, 0, kdata->pipe_id, kdata->module_id,
+				IPC_IA_SET_GAIN_MRFLD, len);
+
+	/* fill byte control header */
+	memset(&byte_hdr, 0, sizeof(byte_hdr));
+	len = sizeof(dsp_hdr) + dsp_hdr.length;
+	sst_fill_byte_control_hdr(&byte_hdr, type, ipc_msg, 1,
+			SST_TASK_ID_MEDIA, kdata->pipe_id, len);
+
+	/* fill complete byte stream as ipc payload */
+	tmp = bytes;
+	memcpy(tmp, &byte_hdr, sizeof(byte_hdr));
+	memcpy((tmp + sizeof(byte_hdr)), &dsp_hdr, sizeof(dsp_hdr));
+	if (type != SND_SST_BYTES_GET)
+		memcpy((tmp + sizeof(byte_hdr) + sizeof(dsp_hdr)), &gain1,
+			sizeof(gain1));
+#ifdef DEBUG_HEX_DUMP_BYTES
+	print_hex_dump_bytes(__func__, DUMP_PREFIX_NONE, bytes, 32);
+#endif
+}
diff --git a/sound/soc/intel/platform-libs/sst_widgets.h b/sound/soc/intel/platform-libs/sst_widgets.h
new file mode 100644
index 0000000..721fdec
--- /dev/null
+++ b/sound/soc/intel/platform-libs/sst_widgets.h
@@ -0,0 +1,337 @@
+/*
+ *  sst_widgets.h - Intel helpers to generate FW widgets
+ *
+ *  Copyright (C) 2013 Intel Corp
+ *  Author: Omair Mohammed Abdullah <omair.m.abdullah@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#ifndef __SST_WIDGETS_H__
+#define __SST_WIDGETS_H__
+
+#include <sound/soc.h>
+#include <sound/tlv.h>
+
+#define SST_MODULE_GAIN 1
+#define SST_MODULE_ALGO 2
+
+#define SST_FMT_MONO 0
+#define SST_FMT_STEREO 3
+
+/* physical SSP numbers */
+enum {
+	SST_SSP0 = 0,
+	SST_SSP1,
+	SST_SSP2,
+	SST_SSP_LAST = SST_SSP2,
+};
+
+#define SST_NUM_SSPS		(SST_SSP_LAST + 1)	/* physical SSPs */
+#define SST_MAX_SSP_MUX		2			/* single SSP muxed between pipes */
+#define SST_MAX_SSP_DOMAINS	2			/* domains present in each pipe */
+
+struct module {
+	struct snd_kcontrol *kctl;
+	struct list_head node;
+};
+
+struct sst_ssp_config {
+	u8 ssp_id;
+	u8 bits_per_slot;
+	u8 slots;
+	u8 ssp_mode;
+	u8 pcm_mode;
+	u8 duplex;
+	u8 ssp_protocol;
+	u8 fs_frequency;
+	u8 active_slot_map;
+	u8 start_delay;
+	u16 fs_width;
+};
+
+struct sst_ssp_cfg {
+	const u8 ssp_number;
+	const int *mux_shift;
+	const int (*domain_shift)[SST_MAX_SSP_MUX];
+	const struct sst_ssp_config (*ssp_config)[SST_MAX_SSP_MUX][SST_MAX_SSP_DOMAINS];
+};
+
+struct sst_ids {
+	u16 location_id;
+	u16 module_id;
+	u8  task_id;
+	u8  format;
+	u8  reg;
+	struct list_head algo_list;
+	struct list_head gain_list;
+	const struct sst_ssp_cfg *ssp;
+};
+
+#define SST_SSP_AIF_IN(wname, wevent, wssp_cfg)						\
+{	.id = snd_soc_dapm_aif_in, .name = wname, .sname = NULL,			\
+	.reg = SND_SOC_NOPM, .shift = 0,					\
+	.event = wevent, .event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD,	\
+	.priv = (void *)&(struct sst_ids) { .ssp = &wssp_cfg, }				\
+}
+
+#define SST_SSP_AIF_OUT(wname, wevent, wssp_cfg)					\
+{	.id = snd_soc_dapm_aif_out, .name = wname, .sname = NULL,			\
+	.reg = SND_SOC_NOPM, .shift = 0,					\
+	.event = wevent, .event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD,	\
+	.priv = (void *)&(struct sst_ids) { .ssp = &wssp_cfg, }				\
+}
+
+#define SST_SSP_INPUT(wname, wevent, wssp_cfg)						\
+{	.id = snd_soc_dapm_input, .name = wname, .sname = NULL,				\
+	.reg = SND_SOC_NOPM, .shift = 0,					\
+	.event = wevent, .event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD,	\
+	.priv = (void *)&(struct sst_ids) { .ssp = &wssp_cfg, }				\
+}
+
+#define SST_SSP_OUTPUT(wname, wevent, wssp_cfg)						\
+{	.id = snd_soc_dapm_output, .name = wname, .sname = NULL,			\
+	.reg = SND_SOC_NOPM, .shift = 0,					\
+	.event = wevent, .event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD,	\
+	.priv = (void *)&(struct sst_ids) { .ssp = &wssp_cfg, }				\
+}
+
+#define SST_PATH(wname, wtask, wloc_id, wevent, wflags)					\
+{	.id = snd_soc_dapm_pga, .name = wname, .reg = SND_SOC_NOPM, .shift = 0,		\
+	.kcontrol_news = NULL, .num_kcontrols = 0,				\
+	.event = wevent, .event_flags = wflags,						\
+	.priv = (void *)&(struct sst_ids) { .task_id = wtask, .location_id = wloc_id, }	\
+}
+
+#define SST_PATH_MEDIA_LOOP(wname, wtask, wloc_id, wformat, wevent, wflags)             \
+{	.id = snd_soc_dapm_pga, .name = wname, .reg = SND_SOC_NOPM, .shift = 0,         \
+	.kcontrol_news = NULL, .num_kcontrols = 0,                         \
+	.event = wevent, .event_flags = wflags,                                         \
+	.priv = (void *)&(struct sst_ids) { .task_id = wtask, .location_id = wloc_id,	\
+					    .format = wformat,}				\
+}
+
+/* output is triggered before input */
+#define SST_PATH_INPUT(name, task_id, loc_id, event)					\
+	SST_PATH(name, task_id, loc_id, event, SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD)
+
+#define SST_PATH_OUTPUT(name, task_id, loc_id, event)					\
+	SST_PATH(name, task_id, loc_id, event, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD)
+
+#define SST_PATH_MEDIA_LOOP_OUTPUT(name, task_id, loc_id, format, event)		\
+	SST_PATH_MEDIA_LOOP(name, task_id, loc_id, format, event, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD)
+
+
+#define SST_SWM_MIXER(wname, wreg, wtask, wloc_id, wcontrols, wevent)			\
+{	.id = snd_soc_dapm_mixer, .name = wname, .reg = SND_SOC_NOPM, .shift = 0,	\
+	.kcontrol_news = wcontrols, .num_kcontrols = ARRAY_SIZE(wcontrols),\
+	.event = wevent, .event_flags = SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD |	\
+					SND_SOC_DAPM_POST_REG,				\
+	.priv = (void *)&(struct sst_ids) { .task_id = wtask, .location_id = wloc_id,	\
+					    .reg = wreg }				\
+}
+
+enum sst_gain_kcontrol_type {
+	SST_GAIN_TLV,
+	SST_GAIN_MUTE,
+	SST_GAIN_RAMP_DURATION,
+};
+
+struct sst_gain_mixer_control {
+	bool stereo;
+	enum sst_gain_kcontrol_type type;
+	struct sst_gain_value *gain_val;
+	int max;
+	int min;
+	u16 instance_id;
+	u16 module_id;
+	u16 pipe_id;
+	u16 task_id;
+	char pname[44];
+	struct snd_soc_dapm_widget *w;
+};
+
+struct sst_gain_value {
+	u16 ramp_duration;
+	s16 l_gain;
+	s16 r_gain;
+	bool mute;
+};
+
+#define SST_GAIN_VOLUME_DEFAULT		(-1440)
+#define SST_GAIN_RAMP_DURATION_DEFAULT	5 /* timeconstant */
+#define SST_GAIN_MUTE_DEFAULT		true
+
+#define SST_GAIN_KCONTROL_TLV(xname, xhandler_get, xhandler_put, \
+			      xmod, xpipe, xinstance, xtask, tlv_array, xgain_val, \
+			      xmin, xmax, xpname) \
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \
+		  SNDRV_CTL_ELEM_ACCESS_READWRITE, \
+	.tlv.p = (tlv_array), \
+	.info = sst_gain_ctl_info,\
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value = (unsigned long)&(struct sst_gain_mixer_control) \
+	{ .stereo = true, .max = xmax, .min = xmin, .type = SST_GAIN_TLV, \
+	  .module_id = xmod, .pipe_id = xpipe, .task_id = xtask,\
+	  .instance_id = xinstance, .gain_val = xgain_val, .pname = xpname}
+
+#define SST_GAIN_KCONTROL_INT(xname, xhandler_get, xhandler_put, \
+			      xmod, xpipe, xinstance, xtask, xtype, xgain_val, \
+			      xmin, xmax, xpname) \
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = sst_gain_ctl_info, \
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value = (unsigned long)&(struct sst_gain_mixer_control) \
+	{ .stereo = false, .max = xmax, .min = xmin, .type = xtype, \
+	  .module_id = xmod, .pipe_id = xpipe, .task_id = xtask,\
+	  .instance_id = xinstance, .gain_val = xgain_val, .pname =  xpname}
+
+#define SST_GAIN_KCONTROL_BOOL(xname, xhandler_get, xhandler_put,\
+			       xmod, xpipe, xinstance, xtask, xgain_val, xpname) \
+	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = snd_soc_info_bool_ext, \
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value = (unsigned long)&(struct sst_gain_mixer_control) \
+	{ .stereo = false, .type = SST_GAIN_MUTE, \
+	  .module_id = xmod, .pipe_id = xpipe, .task_id = xtask,\
+	  .instance_id = xinstance, .gain_val = xgain_val, .pname = xpname}
+
+#define SST_CONTROL_NAME(xpname, xmname, xinstance, xtype) \
+	xpname " " xmname " " #xinstance " " xtype
+
+#define SST_COMBO_CONTROL_NAME(xpname, xmname, xinstance, xtype, xsubmodule) \
+	xpname " " xmname " " #xinstance " " xtype " " xsubmodule
+
+/*
+ * 3 Controls for each Gain module
+ * e.g.	- pcm0_in gain 0 volume
+ *	- pcm0_in gain 0 rampduration
+ *	- pcm0_in gain 0 mute
+ */
+#define SST_GAIN_KCONTROLS(xpname, xmname, xmin_gain, xmax_gain, xmin_tc, xmax_tc, \
+			   xhandler_get, xhandler_put, \
+			   xmod, xpipe, xinstance, xtask, tlv_array, xgain_val) \
+	{ SST_GAIN_KCONTROL_INT(SST_CONTROL_NAME(xpname, xmname, xinstance, "rampduration"), \
+		xhandler_get, xhandler_put, xmod, xpipe, xinstance, xtask, SST_GAIN_RAMP_DURATION, \
+		xgain_val, xmin_tc, xmax_tc, xpname) }, \
+	{ SST_GAIN_KCONTROL_BOOL(SST_CONTROL_NAME(xpname, xmname, xinstance, "mute"), \
+		xhandler_get, xhandler_put, xmod, xpipe, xinstance, xtask, \
+		xgain_val, xpname) } ,\
+	{ SST_GAIN_KCONTROL_TLV(SST_CONTROL_NAME(xpname, xmname, xinstance, "volume"), \
+		xhandler_get, xhandler_put, xmod, xpipe, xinstance, xtask, tlv_array, \
+		xgain_val, xmin_gain, xmax_gain, xpname) }
+
+#define SST_GAIN_TC_MIN		5
+#define SST_GAIN_TC_MAX		5000
+#define SST_GAIN_MIN_VALUE	-1440 /* in 0.1 DB units */
+#define SST_GAIN_MAX_VALUE	360
+
+enum sst_algo_kcontrol_type {
+	SST_ALGO_PARAMS,
+	SST_ALGO_BYPASS,
+};
+
+struct sst_algo_control {
+	enum sst_algo_kcontrol_type type;
+	int max;
+	u16 module_id;
+	u16 pipe_id;
+	u16 instance_id;
+	u16 task_id;
+	u16 cmd_id;
+	bool bypass;
+	unsigned char *params;
+	char pname[44];
+	struct snd_soc_dapm_widget *w;
+};
+
+#define SST_ALGO_KCONTROL_BYTES(xpname, xmname, xcount, xmod, \
+				xpipe, xinstance, xtask, xcmd) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\
+	.name = SST_CONTROL_NAME(xpname, xmname, xinstance, "params"), \
+	.info = sst_algo_bytes_ctl_info, \
+	.get = sst_algo_control_get, .put = sst_algo_control_set, \
+	.private_value = (unsigned long)&(struct sst_algo_control) \
+	{.max = xcount, .type = SST_ALGO_PARAMS, .module_id = xmod, .pname = xpname, \
+	.pipe_id = xpipe, .instance_id = xinstance, .task_id = xtask, .cmd_id = xcmd} }
+
+#define SST_ALGO_KCONTROL_BOOL(xpname, xmname, xmod, xpipe, xinstance, xtask) \
+{      .iface = SNDRV_CTL_ELEM_IFACE_MIXER, \
+	.name = SST_CONTROL_NAME(xpname, xmname, xinstance, "bypass"), \
+	.info = snd_soc_info_bool_ext, \
+	.get = sst_algo_control_get, .put = sst_algo_control_set, \
+	.private_value = (unsigned long)&(struct sst_algo_control) \
+	{.type = SST_ALGO_BYPASS, .module_id = xmod, .pipe_id = xpipe, .pname = xpname, \
+	.task_id = xtask, .instance_id = xinstance, .bypass = 0 } }
+
+#define SST_ALGO_BYPASS_PARAMS(xpname, xmname, xcount, xmod, xpipe, \
+				xinstance, xtask, xcmd)  \
+	SST_ALGO_KCONTROL_BOOL(xpname, xmname, xmod, xpipe, xinstance, xtask), \
+	SST_ALGO_KCONTROL_BYTES(xpname, xmname, xcount, xmod, xpipe, xinstance, xtask, xcmd)
+
+#define SST_COMBO_ALGO_KCONTROL_BYTES(xpname, xmname, xsubmod, xcount, xmod, \
+				      xpipe, xinstance, xtask, xcmd) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\
+	.name = SST_COMBO_CONTROL_NAME(xpname, xmname, xinstance, "params", xsubmod), \
+	.info = sst_algo_bytes_ctl_info, \
+	.get = sst_algo_control_get, .put = sst_algo_control_set, \
+	.private_value = (unsigned long)&(struct sst_algo_control) \
+	{.max = xcount, .type = SST_ALGO_PARAMS, .module_id = xmod, .pname = xpname, \
+	.pipe_id = xpipe, .instance_id = xinstance, .task_id = xtask, .cmd_id = xcmd} }
+
+
+/* only 4 slots/channels supported atm */
+#define SST_SSP_SLOT_ENUM(s_ch_no, is_tx, xtexts) \
+	(struct soc_enum){ .reg = s_ch_no, .reg2 = is_tx, .max = 4+1, .texts = xtexts, }
+
+#define SST_SLOT_CTL_NAME(xpname, xmname, s_ch_name) \
+	xpname " " xmname " " s_ch_name
+
+#define SST_SSP_SLOT_CTL(xpname, xmname, s_ch_name, s_ch_no, is_tx, xtexts, xget, xput) \
+	SOC_DAPM_ENUM_EXT(SST_SLOT_CTL_NAME(xpname, xmname, s_ch_name), \
+			  SST_SSP_SLOT_ENUM(s_ch_no, is_tx, xtexts), \
+			  xget, xput)
+
+#define SST_MUX_CTL_NAME(xpname, xinstance) \
+	xpname " " #xinstance
+
+#define SST_SSP_MUX_ENUM(xreg, xshift, xtexts) \
+	(struct soc_enum){ .reg = xreg, .texts = xtexts, .shift_l = xshift, \
+			   .shift_r = xshift, .max = ARRAY_SIZE(xtexts), }
+
+#define SST_SSP_MUX_CTL(xpname, xinstance, xreg, xshift, xtexts, xget, xput) \
+	SOC_DAPM_ENUM_EXT(SST_MUX_CTL_NAME(xpname, xinstance), \
+			  SST_SSP_MUX_ENUM(xreg, xshift, xtexts), \
+			  xget, xput)
+
+struct sst_probe_value {
+	unsigned int val;
+	const struct soc_enum *p_enum;
+};
+
+#define SST_PROBE_CTL_NAME(dir, num, type) \
+	dir #num " " type
+
+#define SST_PROBE_ENUM(xname, xenum, xhandler_get, xhandler_put) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = sst_probe_enum_info, \
+	.get = xhandler_get, .put = xhandler_put, \
+	.private_value = (unsigned long)&(struct sst_probe_value) \
+	{ .val = 0, .p_enum = &xenum } }
+
+#endif
diff --git a/sound/soc/intel/platform_ipc_v2.h b/sound/soc/intel/platform_ipc_v2.h
new file mode 100644
index 0000000..a5db16b
--- /dev/null
+++ b/sound/soc/intel/platform_ipc_v2.h
@@ -0,0 +1,693 @@
+/*
+*  platform_ipc_v2.h - Intel MID Platform driver FW IPC definitions
+*
+*  Copyright (C) 2008-10 Intel Corporation
+*  Author:	Vinod Koul <vinod.koul@intel.com>
+*		Harsha Priya <priya.harsha@intel.com>
+*		Dharageswari R <dharageswari.r@intel.com>
+*		KP Jeeja <jeeja.kp@intel.com>
+*  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+*
+*  This program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; version 2 of the License.
+*
+*  This program is distributed in the hope that it will be useful, but
+*  WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+*  General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License along
+*  with this program; if not, write to the Free Software Foundation, Inc.,
+*  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+*
+* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+*
+*  This driver exposes the audio engine functionalities to the ALSA
+*	and middleware.
+*  This file has definitions shared between the firmware and driver
+*/
+#ifndef __PLATFORM_IPC_V2_H__
+#define __PLATFORM_IPC_V2_H__
+
+#define MAX_DBG_RW_BYTES 80
+#define MAX_NUM_SCATTER_BUFFERS 8
+#define MAX_LOOP_BACK_DWORDS 8
+/* IPC base address and mailbox, timestamp offsets */
+#define SST_MAILBOX_SIZE 0x0400
+#define SST_MAILBOX_SEND 0x0000
+#define SST_TIME_STAMP 0x1800
+#define SST_TIME_STAMP_MRFLD 0x680
+#define SST_TIME_STAMP_BYT 0x800
+#define SST_RESERVED_OFFSET 0x1A00
+#define SST_SCU_LPE_MAILBOX 0x1000
+#define SST_LPE_SCU_MAILBOX 0x1400
+#define SST_SCU_LPE_LOG_BUF (SST_SCU_LPE_MAILBOX+16)
+#define PROCESS_MSG 0x80
+
+/* Message ID's for IPC messages */
+/* Bits B7: SST or IA/SC ; B6-B4: Msg Category; B3-B0: Msg Type */
+
+/* I2L Firmware/Codec Download msgs */
+#define IPC_IA_PREP_LIB_DNLD 0x01
+#define IPC_IA_LIB_DNLD_CMPLT 0x02
+#define IPC_IA_GET_FW_VERSION 0x04
+#define IPC_IA_GET_FW_BUILD_INF 0x05
+#define IPC_IA_GET_FW_INFO 0x06
+#define IPC_IA_GET_FW_CTXT 0x07
+#define IPC_IA_SET_FW_CTXT 0x08
+#define IPC_IA_PREPARE_SHUTDOWN 0x31
+/* I2L Codec Config/control msgs */
+#define IPC_PREP_D3 0x10
+#define IPC_IA_SET_CODEC_PARAMS 0x10
+#define IPC_IA_GET_CODEC_PARAMS 0x11
+#define IPC_IA_SET_PPP_PARAMS 0x12
+#define IPC_IA_GET_PPP_PARAMS 0x13
+#define IPC_SST_PERIOD_ELAPSED_MRFLD 0xA
+#define IPC_IA_ALG_PARAMS 0x1A
+#define IPC_IA_TUNING_PARAMS 0x1B
+#define IPC_IA_SET_RUNTIME_PARAMS 0x1C
+#define IPC_IA_SET_PARAMS 0x1
+#define IPC_IA_GET_PARAMS 0x2
+
+#define IPC_EFFECTS_CREATE 0xE
+#define IPC_EFFECTS_DESTROY 0xF
+
+/* I2L Stream config/control msgs */
+#define IPC_IA_ALLOC_STREAM_MRFLD 0x2
+#define IPC_IA_ALLOC_STREAM 0x20 /* Allocate a stream ID */
+#define IPC_IA_FREE_STREAM_MRFLD 0x03
+#define IPC_IA_FREE_STREAM 0x21 /* Free the stream ID */
+#define IPC_IA_SET_STREAM_PARAMS 0x22
+#define IPC_IA_SET_STREAM_PARAMS_MRFLD 0x12
+#define IPC_IA_GET_STREAM_PARAMS 0x23
+#define IPC_IA_PAUSE_STREAM 0x24
+#define IPC_IA_PAUSE_STREAM_MRFLD 0x4
+#define IPC_IA_RESUME_STREAM 0x25
+#define IPC_IA_RESUME_STREAM_MRFLD 0x5
+#define IPC_IA_DROP_STREAM 0x26
+#define IPC_IA_DROP_STREAM_MRFLD 0x07
+#define IPC_IA_DRAIN_STREAM 0x27 /* Short msg with str_id */
+#define IPC_IA_DRAIN_STREAM_MRFLD 0x8
+#define IPC_IA_CONTROL_ROUTING 0x29
+#define IPC_IA_VTSV_UPDATE_MODULES 0x20
+#define IPC_IA_VTSV_DETECTED 0x21
+
+#define IPC_IA_START_STREAM_MRFLD 0X06
+#define IPC_IA_START_STREAM 0x30 /* Short msg with str_id */
+
+#define IPC_IA_SET_GAIN_MRFLD 0x21
+/* Debug msgs */
+#define IPC_IA_DBG_MEM_READ 0x40
+#define IPC_IA_DBG_MEM_WRITE 0x41
+#define IPC_IA_DBG_LOOP_BACK 0x42
+#define IPC_IA_DBG_LOG_ENABLE 0x45
+#define IPC_IA_DBG_SET_PROBE_PARAMS 0x47
+
+/* L2I Firmware/Codec Download msgs */
+#define IPC_IA_FW_INIT_CMPLT 0x81
+#define IPC_IA_FW_INIT_CMPLT_MRFLD 0x01
+#define IPC_IA_FW_ASYNC_ERR_MRFLD 0x11
+
+/* L2I Codec Config/control msgs */
+#define IPC_SST_FRAGMENT_ELPASED 0x90 /* Request IA more data */
+
+#define IPC_SST_BUF_UNDER_RUN 0x92 /* PB Under run and stopped */
+#define IPC_SST_BUF_OVER_RUN 0x93 /* CAP Under run and stopped */
+#define IPC_SST_DRAIN_END 0x94 /* PB Drain complete and stopped */
+#define IPC_SST_CHNGE_SSP_PARAMS 0x95 /* PB SSP parameters changed */
+#define IPC_SST_STREAM_PROCESS_FATAL_ERR 0x96/* error in processing a stream */
+#define IPC_SST_PERIOD_ELAPSED 0x97 /* period elapsed */
+
+#define IPC_SST_ERROR_EVENT 0x99 /* Buffer over run occurred */
+/* L2S messages */
+#define IPC_SC_DDR_LINK_UP 0xC0
+#define IPC_SC_DDR_LINK_DOWN 0xC1
+#define IPC_SC_SET_LPECLK_REQ 0xC2
+#define IPC_SC_SSP_BIT_BANG 0xC3
+
+/* L2I Error reporting msgs */
+#define IPC_IA_MEM_ALLOC_FAIL 0xE0
+#define IPC_IA_PROC_ERR 0xE1 /* error in processing a
+					stream can be used by playback and
+					capture modules */
+
+/* L2I Debug msgs */
+#define IPC_IA_PRINT_STRING 0xF0
+
+/* Buffer under-run */
+#define IPC_IA_BUF_UNDER_RUN_MRFLD 0x0B
+
+/* Mrfld specific defines:
+ * For asynchronous messages(INIT_CMPLT, PERIOD_ELAPSED, ASYNC_ERROR)
+ * received from FW, the format is:
+ *  - IPC High: pvt_id is set to zero. Always short message.
+ *  - msg_id is in lower 16-bits of IPC low payload.
+ *  - pipe_id is in higher 16-bits of IPC low payload for period_elapsed.
+ *  - error id is in higher 16-bits of IPC low payload for async errors.
+ */
+#define SST_ASYNC_DRV_ID 0
+
+/* Command Response or Acknowledge message to any IPC message will have
+ * same message ID and stream ID information which is sent.
+ * There is no specific Ack message ID. The data field is used as response
+ * meaning.
+ */
+
+/* SCU IPC for resetting & power gating the LPE through SCU */
+#define IPC_SCU_LPE_RESET 0xA3
+
+enum ackData {
+	IPC_ACK_SUCCESS = 0,
+	IPC_ACK_FAILURE,
+};
+
+enum ipc_ia_msg_id {
+	IPC_CMD = 1,		/*!< Task Control message ID */
+	IPC_SET_PARAMS = 2,/*!< Task Set param message ID */
+	IPC_GET_PARAMS = 3,	/*!< Task Get param message ID */
+	IPC_INVALID = 0xFF,	/*!<Task Get param message ID */
+};
+
+enum sst_codec_types {
+	/*  AUDIO/MUSIC	CODEC Type Definitions */
+	SST_CODEC_TYPE_UNKNOWN = 0,
+	SST_CODEC_TYPE_PCM,	/* Pass through Audio codec */
+	SST_CODEC_TYPE_MP3,
+	SST_CODEC_TYPE_MP24,
+	SST_CODEC_TYPE_AAC,
+	SST_CODEC_TYPE_AACP,
+	SST_CODEC_TYPE_eAACP,
+	SST_CODEC_TYPE_WMA9,
+	SST_CODEC_TYPE_WMA10,
+	SST_CODEC_TYPE_WMA10P,
+	SST_CODEC_TYPE_RA,
+	SST_CODEC_TYPE_DDAC3,
+	SST_CODEC_TYPE_STEREO_TRUE_HD,
+	SST_CODEC_TYPE_STEREO_HD_PLUS,
+
+	/*  VOICE CODEC Type Definitions */
+	SST_CODEC_TYPE_VOICE_PCM = 0x21, /* Pass through voice codec */
+};
+
+enum sst_algo_types {
+	SST_ALGO_SRC = 0x64,
+	SST_ALGO_MIXER = 0x65,
+	SST_ALGO_DOWN_MIXER = 0x66,
+	SST_ALGO_VTSV = 0x73,
+	SST_ALGO_AUDCLASSIFIER = 0x80,
+	SST_ALGO_VOLUME_CONTROL = 0x92,
+	SST_ALGO_GEQ = 0x99,
+};
+
+enum stream_type {
+	SST_STREAM_TYPE_NONE = 0,
+	SST_STREAM_TYPE_MUSIC = 1,
+	SST_STREAM_TYPE_NORMAL = 2,
+	SST_STREAM_TYPE_PROBE = 3,
+	SST_STREAM_TYPE_LONG_PB = 4,
+	SST_STREAM_TYPE_LOW_LATENCY = 5,
+};
+
+enum sst_error_codes {
+	/* Error code,response to msgId: Description */
+	/* Common error codes */
+	SST_SUCCESS = 0,	/* Success */
+	SST_ERR_INVALID_STREAM_ID = 1,
+	SST_ERR_INVALID_MSG_ID = 2,
+	SST_ERR_INVALID_STREAM_OP = 3,
+	SST_ERR_INVALID_PARAMS = 4,
+	SST_ERR_INVALID_CODEC = 5,
+	SST_ERR_INVALID_MEDIA_TYPE = 6,
+	SST_ERR_STREAM_ERR = 7,
+
+	/* IPC specific error codes */
+	SST_IPC_ERR_CALL_BACK_NOT_REGD = 8,
+	SST_IPC_ERR_STREAM_NOT_ALLOCATED = 9,
+	SST_IPC_ERR_STREAM_ALLOC_FAILED = 10,
+	SST_IPC_ERR_GET_STREAM_FAILED = 11,
+	SST_ERR_MOD_NOT_AVAIL = 12,
+	SST_ERR_MOD_DNLD_RQD = 13,
+	SST_ERR_STREAM_STOPPED = 14,
+	SST_ERR_STREAM_IN_USE = 15,
+
+	/* Capture specific error codes */
+	SST_CAP_ERR_INCMPLTE_CAPTURE_MSG = 16,
+	SST_CAP_ERR_CAPTURE_FAIL = 17,
+	SST_CAP_ERR_GET_DDR_NEW_SGLIST = 18,
+	SST_CAP_ERR_UNDER_RUN = 19,
+	SST_CAP_ERR_OVERFLOW = 20,
+
+	/* Playback specific error codes*/
+	SST_PB_ERR_INCMPLTE_PLAY_MSG = 21,
+	SST_PB_ERR_PLAY_FAIL = 22,
+	SST_PB_ERR_GET_DDR_NEW_SGLIST = 23,
+
+	/* Codec manager specific error codes */
+	SST_LIB_ERR_LIB_DNLD_REQUIRED = 24,
+	SST_LIB_ERR_LIB_NOT_SUPPORTED = 25,
+
+	/* Library manager specific error codes */
+	SST_SCC_ERR_PREP_DNLD_FAILED = 26,
+	SST_SCC_ERR_LIB_DNLD_RES_FAILED = 27,
+	/* Scheduler specific error codes */
+	SST_SCH_ERR_FAIL = 28,
+
+	/* DMA specific error codes */
+	SST_DMA_ERR_NO_CHNL_AVAILABLE = 29,
+	SST_DMA_ERR_INVALID_INPUT_PARAMS = 30,
+	SST_DMA_ERR_CHNL_ALREADY_SUSPENDED = 31,
+	SST_DMA_ERR_CHNL_ALREADY_STARTED = 32,
+	SST_DMA_ERR_CHNL_NOT_ENABLED = 33,
+	SST_DMA_ERR_TRANSFER_FAILED = 34,
+
+	SST_SSP_ERR_ALREADY_ENABLED = 35,
+	SST_SSP_ERR_ALREADY_DISABLED = 36,
+	SST_SSP_ERR_NOT_INITIALIZED = 37,
+	SST_SSP_ERR_SRAM_NO_DMA_DATA = 38,
+
+	/* Other error codes */
+	SST_ERR_MOD_INIT_FAIL = 39,
+
+	/* FW init error codes */
+	SST_RDR_ERR_IO_DEV_SEL_NOT_ALLOWED = 40,
+	SST_RDR_ERR_ROUTE_ALREADY_STARTED = 41,
+	SST_RDR_ERR_IO_DEV_SEL_FAILED = 42,
+	SST_RDR_PREP_CODEC_DNLD_FAILED = 43,
+
+	/* Memory debug error codes */
+	SST_ERR_DBG_MEM_READ_FAIL = 44,
+	SST_ERR_DBG_MEM_WRITE_FAIL = 45,
+	SST_ERR_INSUFFICIENT_INPUT_SG_LIST = 46,
+	SST_ERR_INSUFFICIENT_OUTPUT_SG_LIST = 47,
+
+	SST_ERR_BUFFER_NOT_AVAILABLE = 48,
+	SST_ERR_BUFFER_NOT_ALLOCATED = 49,
+	SST_ERR_INVALID_REGION_TYPE = 50,
+	SST_ERR_NULL_PTR = 51,
+	SST_ERR_INVALID_BUFFER_SIZE = 52,
+	SST_ERR_INVALID_BUFFER_INDEX = 53,
+
+	/*IIPC specific error codes */
+	SST_IIPC_QUEUE_FULL = 54,
+	SST_IIPC_ERR_MSG_SND_FAILED = 55,
+	SST_PB_ERR_UNDERRUN_OCCURED = 56,
+	SST_RDR_INSUFFICIENT_MIXER_BUFFER = 57,
+	SST_INVALID_TIME_SLOTS = 58,
+};
+
+enum dbg_mem_data_type {
+	/* Data type of debug read/write */
+	DATA_TYPE_U32,
+	DATA_TYPE_U16,
+	DATA_TYPE_U8,
+};
+
+enum dbg_type {
+	NO_DEBUG = 0,
+	SRAM_DEBUG,
+	PTI_DEBUG,
+};
+
+struct ipc_dsp_hdr {
+	u16 mod_index_id:8;		/*!< DSP Command ID specific to tasks */
+	u16 pipe_id:8;	/*!< instance of the module in the pipeline */
+	u16 mod_id;		/*!< Pipe_id */
+	u16 cmd_id;		/*!< Module ID = lpe_algo_types_t */
+	u16 length;		/*!< Length of the payload only */
+} __packed;
+
+struct ipc_dsp_effects_info {
+	u16	cmd_id;
+	u16	length;
+	u16	sel_pos;
+	u16	sel_algo_id;
+	u16	cpu_load;       /* CPU load indication */
+	u16	memory_usage;   /* Data Memory usage */
+	u32	flags;         /* effect engine caps/requirements flags */
+} __packed;
+
+struct ipc_effect_dsp_hdr {
+	u16 mod_index_id:8;             /*!< DSP Command ID specific to tasks */
+	u16 pipe_id:8;  /*!< instance of the module in the pipeline */
+	u16 mod_id;             /*!< Pipe_id */
+} __packed;
+
+struct ipc_effect_payload {
+	struct ipc_effect_dsp_hdr dsp_hdr;
+	char *data;
+};
+
+union ipc_header_high {
+	struct {
+		u32  msg_id:8;	    /* Message ID - Max 256 Message Types */
+		u32  task_id:4;	    /* Task ID associated with this comand */
+		u32  drv_id:4;    /* Identifier for the driver to track*/
+		u32  rsvd1:8;	    /* Reserved */
+		u32  result:4;	    /* Reserved */
+		u32  res_rqd:1;	    /* Response rqd */
+		u32  large:1;	    /* Large Message if large = 1 */
+		u32  done:1;	    /* bit 30 - Done bit */
+		u32  busy:1;	    /* bit 31 - busy bit*/
+	} part;
+	u32 full;
+} __packed;
+
+/* IPC header */
+union ipc_header_mrfld {
+	struct {
+		u32 header_low_payload;
+		union ipc_header_high header_high;
+	} p;
+	u64 full;
+} __packed;
+
+/* CAUTION NOTE: All IPC message body must be multiple of 32 bits.*/
+
+/* IPC Header */
+union ipc_header {
+	struct {
+		u32  msg_id:8; /* Message ID - Max 256 Message Types */
+		u32  str_id:5;
+		u32  large:1;	/* Large Message if large = 1 */
+		u32  reserved:2;	/* Reserved for future use */
+		u32  data:14;	/* Ack/Info for msg, size of msg in Mailbox */
+		u32  done:1; /* bit 30 */
+		u32  busy:1; /* bit 31 */
+	} part;
+	u32 full;
+} __packed;
+
+/* Firmware build info */
+struct sst_fw_build_info {
+	unsigned char  date[16]; /* Firmware build date */
+	unsigned char  time[16]; /* Firmware build time */
+} __packed;
+
+/* Firmware Version info */
+struct snd_sst_fw_version {
+	u8 build;	/* build number*/
+	u8 minor;	/* minor number*/
+	u8 major;	/* major number*/
+	u8 type;	/* build type */
+};
+
+struct ipc_header_fw_init {
+	struct snd_sst_fw_version fw_version;/* Firmware version details */
+	struct sst_fw_build_info build_info;
+	u16 result;	/* Fw init result */
+	u8 module_id; /* Module ID in case of error */
+	u8 debug_info; /* Debug info from Module ID in case of fail */
+} __packed;
+
+struct snd_sst_tstamp {
+	u64 ring_buffer_counter;	/* PB/CP: Bytes copied from/to DDR. */
+	u64 hardware_counter;	    /* PB/CP: Bytes DMAed to/from SSP. */
+	u64 frames_decoded;
+	u64 bytes_decoded;
+	u64 bytes_copied;
+	u32 sampling_frequency;
+	u32 channel_peak[8];
+} __packed;
+
+/* SST to IA memory read debug message  */
+struct ipc_sst_ia_dbg_mem_rw  {
+	u16  num_bytes;/* Maximum of MAX_DBG_RW_BYTES */
+	u16  data_type;/* enum: dbg_mem_data_type */
+	u32  address;	/* Memory address of data memory of data_type */
+	u8	rw_bytes[MAX_DBG_RW_BYTES];/* Maximum of 64 bytes can be RW */
+} __packed;
+
+struct ipc_sst_ia_dbg_loop_back {
+	u16 num_dwords; /* Maximum of MAX_DBG_RW_BYTES */
+	u16 increment_val;/* Increments dwords by this value, 0- no increment */
+	u32 lpbk_dwords[MAX_LOOP_BACK_DWORDS];/* Maximum of 8 dwords loopback */
+} __packed;
+
+/* Stream type params struture for Alloc stream */
+struct snd_sst_str_type {
+	u8 codec_type;		/* Codec type */
+	u8 str_type;		/* 1 = voice 2 = music */
+	u8 operation;		/* Playback or Capture */
+	u8 protected_str;	/* 0=Non DRM, 1=DRM */
+	u8 time_slots;
+	u8 reserved;		/* Reserved */
+	u16 result;		/* Result used for acknowledgment */
+} __packed;
+
+/* Library info structure */
+struct module_info {
+	u32 lib_version;
+	u32 lib_type;/*TBD- KLOCKWORK u8 lib_type;*/
+	u32 media_type;
+	u8  lib_name[12];
+	u32 lib_caps;
+	unsigned char  b_date[16]; /* Lib build date */
+	unsigned char  b_time[16]; /* Lib build time */
+} __packed;
+
+/* Library slot info */
+struct lib_slot_info {
+	u8  slot_num; /* 1 or 2 */
+	u8  reserved1;
+	u16 reserved2;
+	u32 iram_size; /* slot size in IRAM */
+	u32 dram_size; /* slot size in DRAM */
+	u32 iram_offset; /* starting offset of slot in IRAM */
+	u32 dram_offset; /* starting offset of slot in DRAM */
+} __packed;
+
+struct snd_ppp_mixer_params {
+	__u32			type; /*Type of the parameter */
+	__u32			size;
+	__u32			input_stream_bitmap; /*Input stream Bit Map*/
+} __packed;
+
+struct snd_sst_lib_download {
+	struct module_info lib_info; /* library info type, capabilities etc */
+	struct lib_slot_info slot_info; /* slot info to be downloaded */
+	u32 mod_entry_pt;
+};
+
+struct snd_sst_lib_download_info {
+	struct snd_sst_lib_download dload_lib;
+	u16 result;	/* Result used for acknowledgment */
+	u8 pvt_id; /* Private ID */
+	u8 reserved;  /* for alignment */
+};
+
+struct snd_pcm_params {
+	u8 num_chan;	/* 1=Mono, 2=Stereo */
+	u8 pcm_wd_sz;	/* 16/24 - bit*/
+	u8 use_offload_path;	/* 0-PCM using period elpased & ALSA interfaces
+				   1-PCM stream via compressed interface  */
+	u8 reserved2;
+	u32 sfreq;    /* Sampling rate in Hz */
+	u8 channel_map[8];
+} __packed;
+
+/* MP3 Music Parameters Message */
+struct snd_mp3_params {
+	u8  num_chan;	/* 1=Mono, 2=Stereo	*/
+	u8  pcm_wd_sz; /* 16/24 - bit*/
+	u8  crc_check; /* crc_check - disable (0) or enable (1) */
+	u8  reserved1; /* unused*/
+};
+
+#define AAC_BIT_STREAM_ADTS		0
+#define AAC_BIT_STREAM_ADIF		1
+#define AAC_BIT_STREAM_RAW		2
+
+/* AAC Music Parameters Message */
+struct snd_aac_params {
+	u8 num_chan; /* 1=Mono, 2=Stereo*/
+	u8 pcm_wd_sz; /* 16/24 - bit*/
+	u8 bdownsample; /*SBR downsampling 0 - disable 1 -enabled AAC+ only */
+	u8 bs_format; /* input bit stream format adts=0, adif=1, raw=2 */
+	u32 externalsr; /*sampling rate of basic AAC raw bit stream*/
+	u8 sbr_signalling;/*disable/enable/set automode the SBR tool.AAC+*/
+	u8 reser1;
+	u16  reser2;
+};
+
+/* WMA Music Parameters Message */
+struct snd_wma_params {
+	u8  num_chan;	/* 1=Mono, 2=Stereo */
+	u8  pcm_wd_sz;	/* 16/24 - bit*/
+	u16 reserved1;
+	u32 brate;	/* Use the hard coded value. */
+	u32 sfreq;	/* Sampling freq eg. 8000, 441000, 48000 */
+	u32 channel_mask;  /* Channel Mask */
+	u16 format_tag;	/* Format Tag */
+	u16 block_align;	/* packet size */
+	u16 wma_encode_opt;/* Encoder option */
+	u8 op_align;	/* op align 0- 16 bit, 1- MSB, 2 LSB */
+	u8 reserved;	/* reserved */
+};
+
+/* Codec params struture */
+union  snd_sst_codec_params {
+	struct snd_pcm_params pcm_params;
+	struct snd_mp3_params mp3_params;
+	struct snd_aac_params aac_params;
+	struct snd_wma_params wma_params;
+};
+
+/* Address and size info of a frame buffer in DDR */
+struct sst_address_info {
+	__u32 addr; /* Address at IA */
+	__u32 size; /* Size of the buffer */
+} __packed;
+
+/* Additional params for Alloc struct*/
+struct snd_sst_alloc_params_ext {
+	__u16 sg_count;
+	__u16 reserved;
+	__u32 frag_size;	/*Number of samples after which period elapsed
+				  message is sent valid only if path  = 0*/
+	struct sst_address_info  ring_buf_info[8];
+};
+
+struct snd_sst_stream_params {
+	union snd_sst_codec_params uc;
+} __packed;
+
+struct snd_sst_params {
+	u32 result;
+	u32 stream_id;
+	u8 codec;
+	u8 ops;
+	u8 stream_type;
+	u8 device_type;
+	u8 task;
+	struct snd_sst_stream_params sparams;
+	struct snd_sst_alloc_params_ext aparams;
+};
+
+struct snd_sst_alloc_mrfld {
+	u16 codec_type;
+	u8 operation;
+	u8 sg_count;
+	struct sst_address_info ring_buf_info[8];
+	u32 frag_size;
+	u32 ts;
+	struct snd_sst_stream_params codec_params;
+} __packed;
+
+/* Alloc stream params structure */
+struct snd_sst_alloc_params {
+	struct snd_sst_str_type str_type;
+	struct snd_sst_stream_params stream_params;
+	struct snd_sst_alloc_params_ext alloc_params;
+} __packed;
+
+/* Alloc stream response message */
+struct snd_sst_alloc_response {
+	struct snd_sst_str_type str_type; /* Stream type for allocation */
+	struct snd_sst_lib_download lib_dnld; /* Valid only for codec dnld */
+};
+
+/* Drop response */
+struct snd_sst_drop_response {
+	u32 result;
+	u32 bytes;
+};
+
+struct snd_sst_async_msg {
+	u32 msg_id; /* Async msg id */
+	u32 payload[0];
+};
+
+struct snd_sst_async_err_msg {
+	u32 fw_resp; /* Firmware Result */
+	u32 lib_resp; /*Library result */
+} __packed;
+
+struct snd_sst_vol {
+	u32	stream_id;
+	s32	volume;
+	u32	ramp_duration;
+	u32	ramp_type;		/* Ramp type, default=0 */
+};
+
+/* Gain library parameters for mrfld
+ * based on DSP command spec v0.82
+ */
+struct snd_sst_gain_v2 {
+	u16 gain_cell_num;  /* num of gain cells to modify*/
+	u8 cell_nbr_idx; /* instance index*/
+	u8 cell_path_idx; /* pipe-id */
+	u16 module_id; /*module id */
+	u16 left_cell_gain; /* left gain value in dB*/
+	u16 right_cell_gain; /* right gain value in dB*/
+	u16 gain_time_const; /* gain time constant*/
+} __packed;
+
+struct snd_sst_mute {
+	u32	stream_id;
+	u32	mute;
+};
+
+struct snd_sst_runtime_params {
+	u8 type;
+	u8 str_id;
+	u8 size;
+	u8 rsvd;
+	void *addr;
+} __packed;
+
+enum stream_param_type {
+	SST_SET_TIME_SLOT = 0,
+	SST_SET_CHANNEL_INFO = 1,
+	OTHERS = 2, /*reserved for future params*/
+};
+
+/* CSV Voice call routing structure */
+struct snd_sst_control_routing {
+	u8 control; /* 0=start, 1=Stop */
+	u8 reserved[3];	/* Reserved- for 32 bit alignment */
+};
+
+struct ipc_post {
+	struct list_head node;
+	union ipc_header header; /* driver specific */
+	bool is_large;
+	bool is_process_reply;
+	union ipc_header_mrfld mrfld_header;
+	char *mailbox_data;
+};
+
+struct snd_sst_ctxt_params {
+	u32 address; /* Physical Address in DDR where the context is stored */
+	u32 size; /* size of the context */
+};
+
+struct snd_sst_lpe_log_params {
+	u8 dbg_type;
+	u8 module_id;
+	u8 log_level;
+	u8 reserved;
+} __packed;
+
+enum snd_sst_bytes_type {
+	SND_SST_BYTES_SET = 0x1,
+	SND_SST_BYTES_GET = 0x2,
+};
+
+struct snd_sst_bytes_v2 {
+	u8 type;
+	u8 ipc_msg;
+	u8 block;
+	u8 task_id;
+	u8 pipe_id;
+	u8 rsvd;
+	u16 len;
+	char bytes[0];
+};
+
+#define MAX_VTSV_FILES 2
+struct snd_sst_vtsv_info {
+	struct sst_address_info vfiles[MAX_VTSV_FILES];
+} __packed;
+
+#endif /* __PLATFORMDRV_IPC_V2_H__ */
diff --git a/sound/soc/intel/ssp/Makefile b/sound/soc/intel/ssp/Makefile
new file mode 100644
index 0000000..b3935f5
--- /dev/null
+++ b/sound/soc/intel/ssp/Makefile
@@ -0,0 +1,5 @@
+#EXTRA CFLAGS
+ccflags-y += -Werror
+
+# Audio Comms
+obj-$(CONFIG_SND_SOC_COMMS_SSP) += mid_ssp.o
diff --git a/sound/soc/intel/ssp/mid_ssp.c b/sound/soc/intel/ssp/mid_ssp.c
new file mode 100644
index 0000000..3cd09d2
--- /dev/null
+++ b/sound/soc/intel/ssp/mid_ssp.c
@@ -0,0 +1,1436 @@
+/*
+ *	mid_ssp.c - ASoC CPU DAI driver for
+ *
+ *  Copyright (C) 2011-12 Intel Corp
+ *  Author: Selma Bensaid<selma.bensaid@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *
+ */
+
+#define FORMAT(fmt) "%s: " fmt, __func__
+#define pr_fmt(fmt) KBUILD_MODNAME ": " FORMAT(fmt)
+
+#include <linux/module.h>
+#include "mid_ssp.h"
+
+
+/*
+ * Default I2S configuration
+ */
+/*
+ * TO BE DONE: use mixer to make it more flexible
+ */
+const struct intel_mid_i2s_settings ssp_platform_i2s_config = {
+	.master_mode_clk_selection = SSP_MASTER_CLOCK_UNDEFINED,
+	.master_mode_standard_freq = 0xFFFF,
+	.tx_tristate_phase = TXD_TRISTATE_LAST_PHASE_OFF,
+	.slave_clk_free_running_status =
+			SLAVE_SSPCLK_ON_DURING_TRANSFER_ONLY,
+	.ssp_duplex_mode = RX_AND_TX_MODE,
+	.ssp_trailing_byte_mode = SSP_TRAILING_BYTE_HDL_BY_IA,
+	.ssp_tx_dma = SSP_TX_DMA_ENABLE,
+	.ssp_rx_dma = SSP_RX_DMA_ENABLE,
+	.rx_fifo_interrupt = SSP_RX_FIFO_OVER_INT_ENABLE,
+	.tx_fifo_interrupt = SSP_TX_FIFO_UNDER_INT_ENABLE,
+	.ssp_rx_timeout_interrupt_status = SSP_RX_TIMEOUT_INT_DISABLE,
+	.ssp_trailing_byte_interrupt_status =
+			SSP_TRAILING_BYTE_INT_ENABLE,
+	.ssp_loopback_mode_status = SSP_LOOPBACK_OFF,
+	.ssp_rx_fifo_threshold = MID_SSP_RX_FIFO_THRESHOLD,
+	.ssp_tx_fifo_threshold = MID_SSP_TX_FIFO_THRESHOLD,
+	.ssp_frmsync_pol_bit = SSP_FRMS_ACTIVE_HIGH,
+	.ssp_end_transfer_state =
+			SSP_END_DATA_TRANSFER_STATE_LOW,
+	.ssp_psp_T1 = 0,
+	.ssp_psp_T2 = 0,
+	.ssp_psp_T4 = 0,
+	.ssp_psp_T5 = 0,
+	.ssp_psp_T6 = 1,
+};
+
+/*
+ * SSP DAI Internal functions
+ */
+
+/**
+ * ssp_dma_req - This function programs a write or read request
+ * to the Intel I2S driver
+ *
+ * @param substream Pointer to stream structure
+ * return ret_val Status
+ */
+static int ssp_dma_req(struct snd_pcm_substream *substream)
+{
+
+	struct intel_alsa_ssp_stream_info *str_info;
+	struct intel_ssp_config *ssp_config;
+	struct snd_pcm_runtime *pl_runtime;
+	int ret;
+#ifdef _LLI_ENABLED_
+	struct intel_mid_i2s_lli *sg_table = NULL;
+	int i;
+#else
+	u32 *dma_addr;
+#endif /* _LLI_ENABLED_ */
+
+	WARN(!substream, "SSP DAI: "
+			"ERROR NULL substream\n");
+	if (!substream)
+		return -EINVAL;
+
+
+	pl_runtime = substream->runtime;
+
+	str_info = pl_runtime->private_data;
+
+	WARN(!str_info, "SSP DAI: "
+			"ERROR NULL str_info\n");
+	if (!str_info)
+		return -EINVAL;
+
+	ssp_config = str_info->ssp_config;
+
+	WARN(!ssp_config, "SSP DAI: "
+			"ERROR NULL ssp_config\n");
+	if (!ssp_config)
+		return -EINVAL;
+
+
+	WARN(!ssp_config->i2s_handle, "SSP DAI: "
+			"ERROR, trying to play a stream however "
+			"ssp_config->i2s_handle is NULL\n");
+
+	if (!ssp_config->i2s_handle)
+		return -EINVAL;
+
+#ifdef _LLI_ENABLED_
+	if (!test_bit(INTEL_ALSA_SSP_STREAM_STARTED,
+				&str_info->stream_status)) {
+		pr_err("%s: Stream has been stopped before SSP DMA request has been taken into account",
+			__func__);
+		return 0;
+	}
+
+	/* Will be executed once until next DAI shutdown */
+	if (!test_bit(INTEL_ALSA_SSP_STREAM_INIT,
+				  &str_info->stream_status)) {
+
+		str_info->length = frames_to_bytes(pl_runtime,
+						pl_runtime->period_size);
+
+		str_info->addr = substream->runtime->dma_area;
+
+		sg_table = kzalloc(sizeof(struct intel_mid_i2s_lli) *
+						   pl_runtime->periods,
+						   GFP_KERNEL);
+		if (sg_table == NULL) {
+			pr_err("sg_table allocation failed!");
+			return -EINVAL;
+		}
+
+		for (i = 0; i < pl_runtime->periods; i++) {
+			sg_table[i].addr = (u32 *) (str_info->addr +
+							str_info->length * i);
+			sg_table[i].leng = (u32) str_info->length;
+		}
+
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			ret = intel_mid_i2s_lli_wr_req(ssp_config->i2s_handle,
+							sg_table,
+							pl_runtime->periods,
+							I2S_CIRCULAR_MODE,
+							substream);
+		else
+			ret = intel_mid_i2s_lli_rd_req(ssp_config->i2s_handle,
+							sg_table,
+							pl_runtime->periods,
+							I2S_CIRCULAR_MODE,
+							substream);
+		kfree(sg_table);
+
+		if (ret != 0) {
+			pr_err("SSP DAI: %s request error",
+				(substream->stream ==
+				SNDRV_PCM_STREAM_PLAYBACK) ?
+					   "write" : "read");
+		}
+
+		set_bit(INTEL_ALSA_SSP_STREAM_INIT, &str_info->stream_status);
+
+		intel_mid_i2s_command(ssp_config->i2s_handle,
+					SSP_CMD_ENABLE_SSP, NULL);
+	}
+
+	/* Executed at each TRIGGER_START */
+	intel_mid_i2s_command(ssp_config->i2s_handle,
+			(substream->stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+			SSP_CMD_ENABLE_DMA_TX_INTR :
+			SSP_CMD_ENABLE_DMA_RX_INTR, NULL);
+
+	return 0;
+#else
+	str_info->length = frames_to_bytes(pl_runtime, pl_runtime->period_size);
+
+	str_info->addr = substream->runtime->dma_area;
+	pr_debug("SSP DAI: FCT %s substream->runtime->dma_area = %p",
+		 __func__, substream->runtime->dma_area);
+
+	dma_addr = (u32 *)(str_info->addr + str_info->length
+			   * str_info->period_req_index);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		ret = intel_mid_i2s_wr_req(ssp_config->i2s_handle, dma_addr,
+					   str_info->length, substream);
+	else
+		ret = intel_mid_i2s_rd_req(ssp_config->i2s_handle, dma_addr,
+					   str_info->length, substream);
+
+	if (ret == 0) {
+		intel_mid_i2s_command(ssp_config->i2s_handle,
+				      SSP_CMD_ENABLE_SSP, NULL);
+
+		if (test_and_set_bit(INTEL_ALSA_SSP_STREAM_RUNNING,
+				     &str_info->stream_status)) {
+			pr_err("SSP DAI: ERROR previous request not handled\n");
+			return -EBUSY;
+		}
+
+		if (++(str_info->period_req_index) >= pl_runtime->periods)
+			str_info->period_req_index = 0;
+		return 0;
+	} else {
+		pr_err("SSP DAI: FCT %s read/write req ERROR\n", __func__);
+		return -EINVAL;
+	}
+#endif /* _LLI_ENABLED_ */
+} /* ssp_dma_req */
+
+/**
+ * ssp_dma_complete - End of capture or playback callback
+ * called in DMA Complete Tasklet context
+ * This Callback has in charge of re-programming a new read or write
+ * request to Intel MID I2S Driver if the stream has not been Closed.
+ * It calls also the snd_pcm_period_elapsed if the stream is not
+ * PAUSED or SUSPENDED to inform ALSA Kernel that the Ring Buffer
+ * period has been sent or received properly
+ *
+ * @param param Pointer to a user data
+ * return status
+ */
+static int ssp_dma_complete(void *param)
+{
+	struct snd_pcm_substream *substream;
+	struct intel_alsa_ssp_stream_info *str_info;
+	struct snd_pcm_runtime *pl_runtime;
+#ifndef _LLI_ENABLED_
+	bool call_back = false;
+	bool reset_index = false;
+#endif /* _LLI_ENABLED_ */
+
+	substream = (struct snd_pcm_substream *)param;
+	pl_runtime = substream->runtime;
+	str_info = substream->runtime->private_data;
+
+	WARN(!str_info, "SSP DAI: ERROR NULL str_info\n");
+	if (str_info == NULL)
+		return -EINVAL;
+
+#ifdef _LLI_ENABLED_
+	if (!test_bit(INTEL_ALSA_SSP_STREAM_INIT,
+		      &str_info->stream_status)) {
+		pr_err("Stream already not initialized");
+		return 0;
+	}
+
+	if (++(str_info->period_cb_index) >= pl_runtime->periods)
+		str_info->period_cb_index = 0;
+
+	if (test_bit(INTEL_ALSA_SSP_STREAM_STARTED, &str_info->stream_status))
+		snd_pcm_period_elapsed(substream);
+	else
+		pr_debug("No call to snd_period_elapsed, stream is not started");
+#else
+	if (test_and_clear_bit(INTEL_ALSA_SSP_STREAM_RUNNING,
+			       &str_info->stream_status)) {
+		bool dropped = test_and_clear_bit(INTEL_ALSA_SSP_STREAM_DROPPED,
+						  &str_info->stream_status);
+		bool started = test_bit(INTEL_ALSA_SSP_STREAM_STARTED,
+					&str_info->stream_status);
+
+		if (started) {
+			/*
+			 * Whatever dropped or not,
+			 * the stream is on going
+			 */
+			call_back = true;
+		}
+		if (started && dropped) {
+			/*
+			 * the stream has been dropped and restarted
+			 * before the callback occurs
+			 * in this case the we have to reprogram the
+			 * requests to SSP driver
+			 * and reset the stream's indexes
+			 */
+			reset_index = true;
+		}
+		if (!started && !dropped) {
+			pr_err("SSP DAI: FCT %s neither started nor dropped",
+			       __func__);
+			return -EBUSY;
+		}
+	} else {
+		pr_err("SSP DAI: FCT %s called while not running ", __func__);
+		return -EBUSY;
+	}
+
+	if (call_back == true) {
+		pr_debug("SSP DAI: playback/capture (REQ=%d,CB=%d): DMA_REQ_COMPLETE\n",
+			 str_info->period_req_index,
+			 str_info->period_cb_index);
+
+		if (reset_index) {
+			str_info->period_cb_index = 0;
+			str_info->period_req_index = 0;
+		} else if (++(str_info->period_cb_index) >= pl_runtime->periods)
+			str_info->period_cb_index = 0;
+
+		/*
+		 * Launch the next Capture/Playback request if
+		 * no CLOSE has been requested
+		 */
+		ssp_dma_req(substream);
+
+		/*
+		 * Call the snd_pcm_period_elapsed to inform ALSA kernel
+		 * that a ringbuffer period has been played
+		 */
+		snd_pcm_period_elapsed(substream);
+	}
+#endif /* _LLI_ENABLED_ */
+
+	return 0;
+} /* ssp_dma_complete */
+
+/**
+ * intel_mid_ssp_transfer_data - send data buffers
+ *
+ * @param work Pointer to stream structure
+ * return void
+ */
+void intel_mid_ssp_transfer_data(struct work_struct *work)
+{
+	struct intel_alsa_ssp_stream_info *str_info;
+	struct snd_pcm_substream *substream;
+
+	BUG_ON(!work);
+
+	str_info = container_of(work, struct intel_alsa_ssp_stream_info,
+			ssp_ws);
+
+	BUG_ON(!str_info);
+
+	substream = str_info->substream;
+
+	BUG_ON(!substream);
+
+	ssp_dma_req(substream);
+
+} /* intel_mid_ssp_transfer_data */
+
+/*
+ * SSP PLATFORM
+ */
+
+/*
+ * SSP Platform functions
+ */
+static int ssp_platform_pcm_new(struct snd_soc_pcm_runtime *soc_runtime)
+{
+	int retval = 0;
+	struct snd_soc_dai *dai;
+	struct snd_pcm *pcm;
+
+	pr_debug("SSP DAI: FCT %s enters\n",
+			__func__);
+	/*
+	 * Do pre-allocation to all substreams of the given pcm for the
+	 * specified DMA type.
+	 *
+	 */
+	dai = soc_runtime->cpu_dai;
+	pcm = soc_runtime->pcm;
+
+	if (dai->driver->playback.channels_min ||
+			dai->driver->capture.channels_min) {
+		retval =  snd_pcm_lib_preallocate_pages_for_all(pcm,
+			SNDRV_DMA_TYPE_CONTINUOUS,
+			snd_dma_continuous_data(GFP_KERNEL),
+			SSP_MIN_BUFFER, SSP_MAX_BUFFER);
+
+		if (retval) {
+			pr_err("DMA buffer allocation fail\n");
+			return retval;
+		}
+	}
+	return retval;
+} /* ssp_platform_pcm_new */
+
+static void ssp_platform_pcm_free(struct snd_pcm *pcm)
+{
+	pr_debug("SSP DAI: FCT %s enter\n",
+			__func__);
+	/*
+	 * release all pre-allocated buffers on the pcm
+	 *
+	 */
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+
+} /* ssp_platform_pcm_free */
+
+/**
+ * ssp_platform_hw_params - Allocate memory for Ring Buffer according
+ * to hw_params.
+ * It's called in a non-atomic context
+ *
+ * @param substream Substream for which the stream function is called
+ * @param hw_params Stream command thats requested from upper layer
+ * return status 0 ==> OK
+ *
+ */
+static int ssp_platform_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *hw_params)
+{
+	int ret_val;
+
+	/*
+	 * Allocates the DMA buffer for the substream
+	 * This callback could be called several time
+	 * snd_pcm_lib_malloc_pages allows to avoid memory leak
+	 * as it release already allocated memory when already allocated
+	 */
+	ret_val = snd_pcm_lib_malloc_pages(substream,
+			params_buffer_bytes(hw_params));
+
+	if (ret_val < 0)
+		return ret_val;
+
+	memset(substream->runtime->dma_area, 0, params_buffer_bytes(hw_params));
+
+	return 0;
+} /* ssp_platform_hw_params */
+
+/*
+ * ssp_platform_pointer- to send the current buffer pointer
+ * processed by HW
+ * This function is called by ALSA framework to get the current HW buffer ptr
+ * to check the Ring Buffer Status
+ *
+ * @param substream Pointer to the substream for which the function
+ *		is called
+ *
+ * return pcm_pointer Indicates the number of samples played
+ *
+ */
+static
+snd_pcm_uframes_t ssp_platform_pointer(struct snd_pcm_substream *substream)
+{
+	struct intel_alsa_ssp_stream_info *str_info;
+	unsigned long pcm_pointer = 0;
+
+	str_info = substream->runtime->private_data;
+
+	WARN(!str_info, "SSP DAI: ERROR NULL str_info\n");
+	if (!str_info)
+		return -EINVAL;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		pcm_pointer = (unsigned long) (str_info->period_cb_index
+				* substream->runtime->period_size);
+	else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		pcm_pointer = (unsigned long) (str_info->period_cb_index
+				* substream->runtime->period_size);
+
+	pr_debug("SSP DAI: FCT %s Frame bits = %d, period_size = %d,  periods = %d\n",
+		 __func__,
+		 (int) substream->runtime->frame_bits,
+		 (int) substream->runtime->period_size,
+		 (int) substream->runtime->periods);
+
+	pr_debug("SSP DAI: FCT %s returns %ld\n",
+			__func__, pcm_pointer);
+
+	return pcm_pointer;
+} /* ssp_platform_pointer */
+
+static struct snd_pcm_ops ssp_platform_ops = {
+	.open = NULL,
+	.close = NULL,
+	.ioctl = snd_pcm_lib_ioctl,
+	.hw_params = ssp_platform_hw_params,
+	.hw_free = NULL,
+	.prepare = NULL,
+	.trigger = NULL,
+	.pointer = ssp_platform_pointer,
+};
+
+struct snd_soc_platform_driver soc_ssp_platform_drv = {
+	.ops		= &ssp_platform_ops,
+	.probe		= NULL,
+	.pcm_new	= ssp_platform_pcm_new,
+	.pcm_free	= ssp_platform_pcm_free,
+};
+
+/*
+ * SND SOC DAI OPs
+ */
+static int ssp_probe(struct snd_soc_dai *cpu_dai)
+{
+	struct intel_ssp_config *ssp_config;
+
+	pr_info("SSP DAI: FCT %s enters for CPU_DAI %d\n",
+			__func__, cpu_dai->id);
+
+	ssp_config = kzalloc(sizeof(struct intel_ssp_config), GFP_KERNEL);
+
+
+	if (ssp_config == NULL) {
+		pr_err("Unable to allocate ssp_config\n");
+		return -ENOMEM;
+	}
+
+#ifndef _LLI_ENABLED_
+	ssp_config->intel_mid_dma_alloc = false;
+#endif /* _LLI_ENABLED_ */
+	ssp_config->ssp_dai_tx_allocated = false;
+	ssp_config->ssp_dai_rx_allocated = false;
+
+	ssp_config->i2s_settings = ssp_platform_i2s_config;
+	pr_info("SSP DAI: FCT %s ssp_config %p\n",
+				__func__, ssp_config);
+
+	cpu_dai->playback_dma_data = cpu_dai->capture_dma_data = ssp_config;
+
+	return 0;
+
+} /* ssp_probe */
+
+static int ssp_remove(struct snd_soc_dai *cpu_dai)
+{
+	struct intel_ssp_config *ssp_config;
+
+	WARN(!cpu_dai, "SSP DAI: "
+			"ERROR NULL cpu_dai\n");
+	if (!cpu_dai)
+		return -EINVAL;
+
+	ssp_config = cpu_dai->playback_dma_data;
+
+	kfree(ssp_config);
+
+	return 0;
+} /* ssp_remove */
+
+static int ssp_dai_startup(struct snd_pcm_substream *substream,
+			   struct snd_soc_dai *cpu_dai)
+{
+	struct intel_ssp_config *ssp_config;
+	struct snd_pcm_runtime *pl_runtime;
+	struct intel_alsa_ssp_stream_info *str_info;
+	struct intel_ssp_info *ssp_info;
+	struct snd_soc_dai_driver *cpudai_drv = cpu_dai->driver;
+	unsigned int device;
+	int ret = 0;
+
+	WARN(!cpu_dai->driver, "SSP DAI: "
+			"FCT %s ERROR NULL cpu_dai->driver\n",
+			__func__);
+	if (!cpu_dai->driver)
+		return -EINVAL;
+
+	pr_info("SSP DAI: FCT %s enters for DAI Id = %d\n",
+			__func__, cpu_dai->driver->id);
+
+	ssp_info = dev_get_drvdata(cpu_dai->dev);
+
+	WARN(!ssp_info, "SSP DAI: ERROR NULL ssp_info\n");
+	if (!ssp_info)
+		return -EINVAL;
+
+	pl_runtime = substream->runtime;
+
+	ssp_config = snd_soc_dai_get_dma_data(cpu_dai, substream);
+
+	WARN(!ssp_config, "SSP DAI: "
+			"FCT %s ERROR NULL ssp_config\n",
+			__func__);
+	if (!ssp_config)
+		return -EINVAL;
+
+
+	device = cpu_dai->driver->id;
+
+	/*
+	 * setup the internal data structure stream pointers based on it being
+	 * playback or capture stream
+	 */
+	str_info = kzalloc(sizeof(*str_info), GFP_KERNEL);
+
+	if (!str_info) {
+		pr_err("SSP DAI: str_info alloc failure\n");
+		return -EINVAL;
+
+	}
+	str_info->substream = substream;
+	str_info->ssp_config = ssp_config;
+	str_info->stream_status = 0;
+
+	INIT_WORK(&str_info->ssp_ws, intel_mid_ssp_transfer_data);
+
+	/*
+	 * Initialize SSPx [x=0,1] driver
+	 * Store the Stream information
+	 */
+	pl_runtime->private_data = str_info;
+
+	pr_debug("SSP DAI: FCT %s enters cpu_dai->card->name = %s\n",
+			__func__, cpu_dai->card->name);
+
+	if (!cpu_dai->active) {
+		if (!strcmp(cpudai_drv->name, SSP_BT_DAI_NAME)) {
+			ssp_config->i2s_handle =
+				intel_mid_i2s_open(SSP_USAGE_BLUETOOTH_FM);
+			pr_debug("opening the CPU_DAI for "\
+					"SSP_USAGE_BLUETOOTH_FM, i2s_handle = %p\n",
+					ssp_config->i2s_handle);
+
+		} else if (!strcmp(cpudai_drv->name, SSP_MODEM_DAI_NAME)) {
+			ssp_config->i2s_handle =
+				intel_mid_i2s_open(SSP_USAGE_MODEM);
+			pr_debug("opening the CPU_DAI for "\
+					"SSP_USAGE_MODEM, i2s_handle = %p\n",
+					ssp_config->i2s_handle);
+
+		} else {
+			pr_err("non Valid SOC CARD\n");
+			return -EINVAL;
+		}
+
+		/* Set the Write Callback */
+		ret = intel_mid_i2s_set_wr_cb(ssp_config->i2s_handle,
+				ssp_dma_complete);
+		if (ret)
+			return ret;
+
+		/* Set the Default Read Callback */
+		ret = intel_mid_i2s_set_rd_cb(ssp_config->i2s_handle,
+				ssp_dma_complete);
+		if (ret)
+			return ret;
+
+	} else {
+		/*
+		 * do nothing because already Open by sibling substream
+		 */
+		pr_debug("SSP DAI: FCT %s Open DO NOTHING\n",
+				__func__);
+	}
+	return 0;
+} /* ssp_dai_startup */
+
+static void ssp_dai_shutdown(struct snd_pcm_substream *substream,
+			     struct snd_soc_dai *cpu_dai)
+{
+	struct intel_ssp_config *ssp_config;
+	struct intel_alsa_ssp_stream_info *str_info;
+	struct snd_pcm_runtime *runtime;
+	struct intel_ssp_info *ssp_info;
+
+	ssp_config = snd_soc_dai_get_dma_data(cpu_dai, substream);
+
+	BUG_ON(!ssp_config);
+
+	runtime = substream->runtime;
+	BUG_ON(!runtime->private_data);
+
+	str_info = runtime->private_data;
+	BUG_ON(!str_info);
+
+	ssp_info = dev_get_drvdata(cpu_dai->dev);
+	BUG_ON(!ssp_info);
+
+	/* Cancel pending work */
+	cancel_work_sync(&str_info->ssp_ws);
+
+	switch (substream->stream) {
+	case SNDRV_PCM_STREAM_PLAYBACK:
+		/*
+		 * Only Free Tx channel if no playback streams are active
+		 * Shutdown can be called right after a startup if something
+		 * failed (as a concurrency issue
+		 * so this case can happen
+		 */
+		if ((!cpu_dai->playback_active) &&
+			(ssp_config->i2s_settings.ssp_active_tx_slots_map)) {
+			intel_mid_i2s_command(ssp_config->i2s_handle,
+					SSP_CMD_FREE_TX, NULL);
+			pr_debug("SSP DAI: FCT %s TX DMA Channel released\n",
+					__func__);
+		}
+		ssp_config->ssp_dai_tx_allocated = false;
+		break;
+
+	case SNDRV_PCM_STREAM_CAPTURE:
+		/*
+		 * Only Free Rx channel if no capture streams are active
+		 */
+		if ((!cpu_dai->capture_active) &&
+			(ssp_config->i2s_settings.ssp_active_rx_slots_map)) {
+			intel_mid_i2s_command(ssp_config->i2s_handle,
+					SSP_CMD_FREE_RX, NULL);
+			pr_debug("SSP DAI: FCT %s RX DMA Channel released\n",
+					__func__);
+		}
+		ssp_config->ssp_dai_rx_allocated = false;
+		break;
+
+	default:
+		pr_err("SSP DAI: FCT %s Bad stream_dir: %d\n",
+				__func__, substream->stream);
+		break;
+	}
+
+#ifdef _LLI_ENABLED_
+	clear_bit(INTEL_ALSA_SSP_STREAM_INIT, &str_info->stream_status);
+#endif /* _LLI_ENABLED_ */
+
+	kfree(str_info);
+
+	if (!cpu_dai->active) {
+		pr_info("SSP DAI: FCT %s closing I2S\n",
+				__func__);
+		/*
+		 * Close the Intel MID I2S connection
+		 */
+		intel_mid_i2s_close(ssp_config->i2s_handle);
+
+		ssp_config->i2s_handle = NULL;
+#ifndef _LLI_ENABLED_
+		ssp_config->intel_mid_dma_alloc = false;
+#endif /* _LLI_ENABLED_ */
+	}
+
+} /* ssp_dai_shutdown */
+
+static int ssp_set_dai_fmt(struct snd_soc_dai *cpu_dai,
+		unsigned int fmt)
+{
+	struct intel_ssp_config *ssp_config;
+	struct intel_mid_i2s_settings *i2s_config;
+
+	ssp_config = cpu_dai->playback_dma_data;
+
+	WARN(!ssp_config, "SSP DAI: FCT %s ssp_config=NULL\n",
+			__func__);
+	if (!ssp_config)
+		return -EINVAL;
+
+	pr_debug("SSP DAI: FCT %s fmt = %d\n",
+			__func__, fmt);
+
+	i2s_config = &(ssp_config->i2s_settings);
+
+	/*
+	 * SSP CLK Direction
+	 * SSP FRMSYNC Direction
+	 */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		i2s_config->sspslclk_direction = SSPSCLK_MASTER_MODE;
+		i2s_config->sspsfrm_direction = SSPSCLK_MASTER_MODE;
+		/*
+		 * Mandatory to be able to perform only RX without TX
+		 * in SSP CLK Master Mode
+		 *
+		 */
+		i2s_config->ssp_duplex_mode = RX_WITHOUT_TX_MODE;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+		i2s_config->sspslclk_direction = SSPSCLK_MASTER_MODE;
+		i2s_config->sspsfrm_direction = SSPSCLK_SLAVE_MODE;
+		/*
+		 * Mandatory to be able to perform only RX without TX
+		 * in SSP CLK Master Mode
+		 *
+		 */
+		i2s_config->ssp_duplex_mode = RX_WITHOUT_TX_MODE;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		i2s_config->sspslclk_direction = SSPSCLK_SLAVE_MODE;
+		i2s_config->sspsfrm_direction = SSPSCLK_SLAVE_MODE;
+		i2s_config->ssp_duplex_mode = RX_AND_TX_MODE;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFM:
+		i2s_config->sspslclk_direction = SSPSCLK_SLAVE_MODE;
+		i2s_config->sspsfrm_direction = SSPSCLK_MASTER_MODE;
+		i2s_config->ssp_duplex_mode = RX_AND_TX_MODE;
+		break;
+	default:
+		pr_err("SSP DAI: %s Bad DAI CLK/FS Mode=%d\n",
+					__func__,
+					(fmt & SND_SOC_DAIFMT_MASTER_MASK));
+		return -EINVAL;
+	}
+	/*
+	 * SSP Sgnal Inversion Mode
+	 * Use clock gating bitfield for
+	 * Serial bit-rate Clock Mode
+	 */
+	switch (fmt & SND_SOC_DAIFMT_CLOCK_MASK) {
+	case SSP_DAI_SCMODE_0:
+		i2s_config->ssp_serial_clk_mode = SSP_CLK_MODE_0;
+		break;
+	case SSP_DAI_SCMODE_1:
+		i2s_config->ssp_serial_clk_mode = SSP_CLK_MODE_1;
+		break;
+	case SSP_DAI_SCMODE_2:
+		i2s_config->ssp_serial_clk_mode = SSP_CLK_MODE_2;
+		break;
+	case SSP_DAI_SCMODE_3:
+		i2s_config->ssp_serial_clk_mode = SSP_CLK_MODE_3;
+		break;
+	default:
+		pr_err("SSP DAI: %s Bad DAI Signal Inversion Mode=%d\n",
+				__func__,
+				(fmt & SND_SOC_DAIFMT_INV_MASK));
+		return -EINVAL;
+	}
+
+	/*
+	 * SSP FS Inversion Mode
+	 */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+	case SND_SOC_DAIFMT_IB_NF:
+		i2s_config->ssp_frmsync_pol_bit = SSP_FRMS_ACTIVE_HIGH;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+	case SND_SOC_DAIFMT_IB_IF:
+		i2s_config->ssp_frmsync_pol_bit = SSP_FRMS_ACTIVE_LOW;
+		break;
+	default:
+		pr_err("SSP DAI: %s Bad DAI FS Inversion Mode=%d\n",
+				__func__,
+				(fmt & SND_SOC_DAIFMT_INV_MASK));
+		return -EINVAL;
+	}
+
+	/*
+	 * SSP Format Mode
+	 */
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		i2s_config->frame_format = PSP_FORMAT;
+		break;
+
+	default:
+		pr_err("SSP DAI: %s Bad DAI format Mode=%d\n",
+				__func__,
+				(fmt & SND_SOC_DAIFMT_FORMAT_MASK));
+		return -EINVAL;
+	}
+	return 0;
+} /* ssp_set_dai_fmt */
+
+static int ssp_set_dai_tdm_slot(struct snd_soc_dai *cpu_dai,
+	unsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)
+{
+	struct intel_ssp_config *ssp_config;
+	struct intel_mid_i2s_settings *i2s_config;
+
+	ssp_config = cpu_dai->playback_dma_data;
+
+	WARN(!ssp_config, "SSP DAI: FCT %s ssp_config=NULL\n",
+			__func__);
+	if (!ssp_config)
+		return -EINVAL;
+
+
+	i2s_config = &(ssp_config->i2s_settings);
+
+	i2s_config->frame_rate_divider_control = slots;
+	i2s_config->data_size = slot_width;
+	i2s_config->mode = SSP_IN_NETWORK_MODE;
+	i2s_config->ssp_active_tx_slots_map = tx_mask;
+	i2s_config->ssp_active_rx_slots_map = rx_mask;
+
+	pr_debug("i2s_config->frame_rate_divider_control = %d\n",
+			i2s_config->frame_rate_divider_control);
+	pr_debug("i2s_config->data_size = %d\n",
+			i2s_config->data_size);
+	pr_debug("i2s_config->mode = %d\n",
+			i2s_config->mode);
+	pr_debug("i2s_config->ssp_active_tx_slots_map = %d\n",
+			i2s_config->ssp_active_tx_slots_map);
+	pr_debug("i2s_config->ssp_active_rx_slots_map = %d\n",
+			i2s_config->ssp_active_rx_slots_map);
+
+	return 0;
+}
+
+static int ssp_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
+	int clk_id, unsigned int freq, int dir)
+{
+	struct intel_ssp_config *ssp_config;
+	struct intel_mid_i2s_settings *i2s_config;
+
+	ssp_config = cpu_dai->playback_dma_data;
+
+	BUG_ON(!ssp_config);
+
+	i2s_config = &(ssp_config->i2s_settings);
+
+	pr_debug("SSP DAI: FCT %s clk_id = %d\n",
+			__func__, clk_id);
+
+	switch (clk_id) {
+	case SSP_CLK_ONCHIP:
+		i2s_config->master_mode_clk_selection = SSP_ONCHIP_CLOCK;
+		break;
+	case SSP_CLK_NET:
+		i2s_config->master_mode_clk_selection = SSP_NETWORK_CLOCK;
+		break;
+	case SSP_CLK_EXT:
+		i2s_config->master_mode_clk_selection = SSP_EXTERNAL_CLOCK;
+		break;
+	case SSP_CLK_AUDIO:
+		i2s_config->master_mode_clk_selection = SSP_ONCHIP_AUDIO_CLOCK;
+		break;
+	default:
+		i2s_config->master_mode_standard_freq =
+						SSP_MASTER_CLOCK_UNDEFINED;
+		pr_err("SSP DAI: %s Bad clk_id=%d\n",
+				__func__,
+				clk_id);
+		return -EINVAL;
+	}
+
+	pr_debug("SSP DAI:FCT %s freq = %d\n",
+				__func__, freq);
+
+	switch (freq) {
+	case 8000:
+		i2s_config->master_mode_standard_freq = SSP_FRM_FREQ_8_000;
+		i2s_config->ssp_psp_T1 = 0;
+		i2s_config->ssp_psp_T2 = 1;
+		i2s_config->ssp_psp_T4 = 0;
+		i2s_config->ssp_psp_T5 = 0;
+		i2s_config->ssp_psp_T6 = 1;
+		break;
+
+	case 11025:
+		i2s_config->master_mode_standard_freq = SSP_FRM_FREQ_11_025;
+		pr_err("SSP DAI: %s Bad freq_out=%d\n",
+						__func__,
+						freq);
+		return -EINVAL;
+
+	case 16000:
+		i2s_config->master_mode_standard_freq = SSP_FRM_FREQ_16_000;
+		i2s_config->ssp_psp_T1 = 6;
+		i2s_config->ssp_psp_T2 = 2;
+		i2s_config->ssp_psp_T4 = 0;
+		i2s_config->ssp_psp_T5 = 14;
+		i2s_config->ssp_psp_T6 = 16;
+		break;
+
+	case 22050:
+		i2s_config->master_mode_standard_freq = SSP_FRM_FREQ_22_050;
+		pr_err("SSP DAI: %s Bad freq_out=%d\n",
+						__func__,
+						freq);
+		return -EINVAL;
+
+	case 44100:
+		i2s_config->master_mode_standard_freq = SSP_FRM_FREQ_44_100;
+		pr_err("SSP DAI: %s Bad freq_out=%d\n",
+						__func__,
+						freq);
+		return -EINVAL;
+
+	case 48000:
+		i2s_config->master_mode_standard_freq = SSP_FRM_FREQ_48_000;
+		i2s_config->ssp_psp_T1 = 6;
+		i2s_config->ssp_psp_T2 = 2;
+		i2s_config->ssp_psp_T4 = 0;
+		i2s_config->ssp_psp_T5 = 14;
+		i2s_config->ssp_psp_T6 = 16;
+		break;
+
+	default:
+		i2s_config->master_mode_standard_freq = SSP_FRM_FREQ_UNDEFINED;
+		pr_err("SSP DAI: %s Bad freq_out=%d\n",
+				__func__,
+				freq);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int ssp_set_dai_tristate(struct snd_soc_dai *cpu_dai,
+	int tristate)
+{
+	struct intel_ssp_config *ssp_config;
+	struct intel_mid_i2s_settings *i2s_config;
+
+	ssp_config = cpu_dai->playback_dma_data;
+
+	BUG_ON(!ssp_config);
+
+	i2s_config = &(ssp_config->i2s_settings);
+
+	if (IS_TRISTATE_ENABLED(tristate))
+		i2s_config->tx_tristate_enable = TXD_TRISTATE_ON;
+	else
+		i2s_config->tx_tristate_enable = TXD_TRISTATE_OFF;
+
+	if (IS_NEXT_FRMS_ASSERTED_WITH_LSB_PREVIOUS_FRM(tristate))
+		i2s_config->ssp_frmsync_timing_bit =
+				NEXT_FRMS_ASS_WITH_LSB_PREVIOUS_FRM;
+	else
+		i2s_config->ssp_frmsync_timing_bit =
+				NEXT_FRMS_ASS_AFTER_END_OF_T4;
+
+	pr_debug("FCT %s tristate %x\n", __func__, tristate);
+
+	return 0;
+}
+
+/**
+ * ssp_dai_trigger- stream activities are handled here
+ * This function is called whenever a stream activity is invoked
+ * The Trigger function is called in an atomic context
+ *
+ * @param substream Substream for which the stream function is called
+ * @param cmd The stream command thats requested from upper layer
+ * return status 0 ==> OK
+ *
+ */
+static int ssp_dai_trigger(struct snd_pcm_substream *substream,
+		int cmd, struct snd_soc_dai *cpu_dai)
+{
+	int ret_val = 0;
+	struct intel_alsa_ssp_stream_info *str_info;
+	struct snd_pcm_runtime *pl_runtime;
+	struct intel_ssp_info *ssp_info;
+#ifdef _LLI_ENABLED_
+	struct intel_ssp_config *ssp_config;
+#endif /* _LLI_ENABLED_ */
+
+	bool trigger_start = true;
+	int stream = 0;
+
+	pr_debug("SSP DAI: FCT %s enters\n",
+			__func__);
+
+	stream = substream->stream;
+
+
+	pl_runtime = substream->runtime;
+
+	WARN(!pl_runtime->private_data, "SSP DAI: ERROR "
+			"NULL pl_runtime->private_data\n");
+	if (!pl_runtime->private_data)
+		return -EINVAL;
+
+	WARN(!cpu_dai, "SSP DAI: ERROR NULL cpu_dai\n");
+	if (!cpu_dai)
+		return -EINVAL;
+
+	WARN(!cpu_dai->dev, "SSP DAI: ERROR NULL cpu_dai->dev\n");
+	if (!cpu_dai->dev)
+		return -EINVAL;
+
+	ssp_info = dev_get_drvdata(cpu_dai->dev);
+
+
+	WARN(!ssp_info->ssp_dai_wq, "SSP DAI: ERROR NULL ssp_dai_wq\n");
+	if (!ssp_info->ssp_dai_wq)
+		return -EINVAL;
+
+	str_info = pl_runtime->private_data;
+
+#ifdef _LLI_ENABLED_
+	ssp_config = str_info->ssp_config;
+
+	WARN(!ssp_config, "SSP DAI: ERROR NULL ssp_config\n");
+	if (!ssp_config)
+		return -EINVAL;
+#endif /* _LLI_ENABLED_ */
+
+	pr_debug("SSP DAI: FCT %s CMD = 0x%04X\n",
+			__func__, cmd);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (!test_and_set_bit(INTEL_ALSA_SSP_STREAM_STARTED,
+				      &str_info->stream_status)) {
+#ifndef _LLI_ENABLED_
+			if (test_bit(INTEL_ALSA_SSP_STREAM_DROPPED,
+				     &str_info->stream_status)) {
+				pr_debug("SSP DAI: FCT %s do not restart the trigger stream running already\n",
+					 __func__);
+				trigger_start = false;
+			} else
+#endif /* _LLI_ENABLED_ */
+				trigger_start = true;
+		} else {
+			pr_err("SSP DAI: ERROR 2 consecutive TRIGGER_START\n");
+			return -EBUSY;
+		}
+
+		/* Store the substream locally */
+		if (trigger_start) {
+			if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+
+				pr_debug("SSP DAI: queue Playback Work\n");
+				queue_work(ssp_info->ssp_dai_wq,
+						&str_info->ssp_ws);
+			} else if (stream == SNDRV_PCM_STREAM_CAPTURE) {
+
+				pr_debug("SSP DAI: queue Capture Work\n");
+				queue_work(ssp_info->ssp_dai_wq,
+						&str_info->ssp_ws);
+			} else {
+				pr_err("SSP DAI: SNDRV_PCM_TRIGGER_START Bad Stream: %d\n",
+						substream->stream);
+				return -EINVAL;
+			}
+		}
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		if (test_and_clear_bit(INTEL_ALSA_SSP_STREAM_STARTED,
+				       &str_info->stream_status)) {
+#ifdef _LLI_ENABLED_
+			intel_mid_i2s_command(ssp_config->i2s_handle,
+					      (stream == SNDRV_PCM_STREAM_PLAYBACK) ?
+					      SSP_CMD_DISABLE_DMA_TX_INTR :
+					      SSP_CMD_DISABLE_DMA_RX_INTR,
+					      NULL);
+#else
+			set_bit(INTEL_ALSA_SSP_STREAM_DROPPED,
+				&str_info->stream_status);
+#endif /* _LLI_ENABLED_ */
+		} else {
+			pr_err("SSP DAI: trigger START/STOP mismatch\n");
+			return -EBUSY;
+		}
+		break;
+
+	default:
+		pr_err("SSP DAI: snd_i2s_alsa_pcm_trigger Bad Command\n");
+		return -EINVAL;
+	}
+	return ret_val;
+} /* ssp_dai_trigger */
+
+/**
+ * ssp_dai_hw_params - Allocate memory for Ring Buffer according
+ * to hw_params.
+ * It's called in a non-atomic context
+ *
+ * @param substream Substream for which the stream function is called
+ * @param hw_params Stream command thats requested from upper layer
+ * @param cpu_dai Pointer to the CPU DAI that is used
+ * return status 0 ==> OK
+ *
+ */
+static int ssp_dai_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *hw_params,
+		struct snd_soc_dai *cpu_dai)
+{
+
+	return 0;
+}
+
+static int ssp_dai_prepare(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *cpu_dai)
+{
+	struct intel_ssp_config *ssp_config;
+	struct intel_ssp_info *ssp_info;
+
+	pr_debug("SSP DAI: FCT %s enters\n",
+				__func__);
+
+	WARN(!cpu_dai, "SSP DAI: ERROR NULL cpu_dai\n");
+	if (!cpu_dai)
+		return -EINVAL;
+
+	ssp_info = dev_get_drvdata(cpu_dai->dev);
+	WARN(!ssp_info, "SSP DAI: ERROR NULL ssp_info\n");
+	if (!ssp_info)
+		return -EINVAL;
+
+	ssp_config = snd_soc_dai_get_dma_data(cpu_dai, substream);
+	pr_debug("SSP DAI: FCT %s ssp_dai_tx_allocated %d "\
+			"ssp_dai_rx_allocated %d\n",
+			__func__,
+			ssp_config->ssp_dai_tx_allocated,
+			ssp_config->ssp_dai_rx_allocated);
+
+	/*
+	 * The set HW Config is only once for a CPU DAI
+	 */
+
+	if (!ssp_config->ssp_dai_tx_allocated &&
+			!ssp_config->ssp_dai_rx_allocated) {
+		intel_mid_i2s_command(ssp_config->i2s_handle,
+						SSP_CMD_SET_HW_CONFIG,
+						&(ssp_config->i2s_settings));
+	}
+
+	switch (substream->stream) {
+	case SNDRV_PCM_STREAM_PLAYBACK:
+		if (!ssp_config->ssp_dai_tx_allocated) {
+			if (intel_mid_i2s_command(ssp_config->i2s_handle,
+					SSP_CMD_ALLOC_TX, NULL)) {
+				pr_err("can not alloc TX DMA Channel\n");
+				return -EBUSY;
+			}
+			ssp_config->ssp_dai_tx_allocated = true;
+		}
+		break;
+
+	case SNDRV_PCM_STREAM_CAPTURE:
+		if (!ssp_config->ssp_dai_rx_allocated) {
+			if (intel_mid_i2s_command(ssp_config->i2s_handle,
+					SSP_CMD_ALLOC_RX, NULL)) {
+				pr_err("can not alloc RX DMA Channel\n");
+				return -EBUSY;
+			}
+			ssp_config->ssp_dai_rx_allocated = true;
+		}
+		break;
+
+	default:
+		pr_err("SSP DAI: FCT %s Bad stream_dir: %d\n",
+				__func__, substream->stream);
+		return -EINVAL;
+	}
+
+#ifndef _LLI_ENABLED_
+	ssp_config->intel_mid_dma_alloc = true;
+#endif /* _LLI_ENABLED_ */
+
+	pr_debug("SSP DAI: FCT %s leaves\n",
+			__func__);
+
+	return 0;
+}
+
+
+
+/* BT/FM */
+static struct snd_soc_dai_ops ssp_dai_ops = {
+	.startup	= ssp_dai_startup,
+	.shutdown	= ssp_dai_shutdown,
+	.trigger	= ssp_dai_trigger,
+	.hw_params	= ssp_dai_hw_params,
+	.prepare    = ssp_dai_prepare,
+	.set_sysclk	= ssp_set_dai_sysclk,
+	.set_pll    = NULL,
+	.set_fmt	= ssp_set_dai_fmt,
+	.set_tdm_slot	= ssp_set_dai_tdm_slot,
+	.set_tristate	= ssp_set_dai_tristate,
+};
+
+#define SSP_SUPPORTED_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 | \
+			SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 | \
+			SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)
+
+#define SSP_SUPPORTED_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \
+			SNDRV_PCM_FMTBIT_U16_LE | \
+			SNDRV_PCM_FMTBIT_S8 | \
+			SNDRV_PCM_FMTBIT_U8)
+
+struct snd_soc_dai_driver intel_ssp_platform_dai[] = {
+{
+	.name = SSP_MODEM_DAI_NAME,
+	.id = 0,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 8,
+		.rates = SSP_SUPPORTED_RATES,
+		.formats = SSP_SUPPORTED_FORMATS,
+	},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 8,
+		.rates = SSP_SUPPORTED_RATES,
+		.formats = SSP_SUPPORTED_FORMATS,
+	},
+	.ops = &ssp_dai_ops,
+	.probe = ssp_probe,
+	.remove = ssp_remove,
+},
+{
+	.name = SSP_BT_DAI_NAME,
+	.id = 1,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 8,
+		.rates = SSP_SUPPORTED_RATES,
+		.formats = SSP_SUPPORTED_FORMATS,
+	},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 8,
+		.rates = SSP_SUPPORTED_RATES,
+		.formats = SSP_SUPPORTED_FORMATS,
+	},
+	.ops = &ssp_dai_ops,
+	.probe = ssp_probe,
+	.remove = ssp_remove,
+},
+};
+
+static const struct snd_soc_component_driver ssp_component = {
+	.name           = "ssp",
+};
+
+static int ssp_dai_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct intel_ssp_info *ssp_info;
+
+	pr_info("SSP DAI: FCT %s enters\n",
+			__func__);
+
+	ssp_info = kzalloc(sizeof(struct intel_ssp_info), GFP_KERNEL);
+
+	if (ssp_info == NULL) {
+		pr_err("Unable to allocate ssp_info\n");
+		return -ENOMEM;
+	}
+	pr_info("ssp_info address %p", ssp_info);
+
+	ret = snd_soc_register_platform(&pdev->dev,
+				&soc_ssp_platform_drv);
+	if (ret) {
+		pr_err("registering SSP PLATFORM failed\n");
+		snd_soc_unregister_component(&pdev->dev);
+		kfree(ssp_info);
+		return -EBUSY;
+	}
+
+	ret = snd_soc_register_component(&pdev->dev, &ssp_component,
+			intel_ssp_platform_dai,
+			ARRAY_SIZE(intel_ssp_platform_dai));
+
+	if (ret) {
+		pr_err("registering cpu DAIs failed\n");
+		snd_soc_unregister_component(&pdev->dev);
+		kfree(ssp_info);
+		return -EBUSY;
+	}
+
+	ssp_info->ssp_dai_wq = create_workqueue("ssp_transfer_data");
+
+	if (!ssp_info->ssp_dai_wq) {
+		pr_err("work queue failed\n");
+		snd_soc_unregister_component(&pdev->dev);
+		kfree(ssp_info);
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(pdev, ssp_info);
+
+	pr_info("SSP DAI: FCT %s leaves %d\n",
+			__func__, ret);
+
+	return ret;
+}
+
+static int ssp_dai_remove(struct platform_device *pdev)
+{
+	struct intel_ssp_info *ssp_info = platform_get_drvdata(pdev);
+
+	pr_debug("SSP DAI: FCT %s enters\n",
+			__func__);
+
+	if (ssp_info == NULL) {
+		pr_err("Unable to allocate ssp_info\n");
+		return -ENOMEM;
+	}
+	pr_info("ssp_info address %p", ssp_info);
+
+	flush_workqueue(ssp_info->ssp_dai_wq);
+
+	destroy_workqueue(ssp_info->ssp_dai_wq);
+
+	platform_set_drvdata(pdev, NULL);
+
+	snd_soc_unregister_component(&pdev->dev);
+
+	snd_soc_unregister_platform(&pdev->dev);
+
+	pr_debug("SSP DAI: FCT %s leaves\n",
+			__func__);
+
+	return 0;
+}
+
+static struct platform_driver intel_ssp_dai_driver = {
+	.driver		= {
+		.name		= "mid-ssp-dai",
+		.owner		= THIS_MODULE,
+	},
+	.probe		= ssp_dai_probe,
+	.remove		= ssp_dai_remove,
+};
+
+
+static int __init ssp_soc_dai_init(void)
+{
+	pr_info("SSP DAI: FCT %s called\n",
+			__func__);
+
+	return  platform_driver_register(&intel_ssp_dai_driver);
+}
+module_init(ssp_soc_dai_init);
+
+static void __exit ssp_soc_dai_exit(void)
+{
+	pr_debug("SSP DAI: FCT %s called\n",
+			__func__);
+
+	platform_driver_unregister(&intel_ssp_dai_driver);
+
+}
+module_exit(ssp_soc_dai_exit);
+
+MODULE_DESCRIPTION("ASoC Intel(R) MID Platform driver");
+MODULE_AUTHOR("Selma Bensaid");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:ssp-cpu-dai");
diff --git a/sound/soc/intel/ssp/mid_ssp.h b/sound/soc/intel/ssp/mid_ssp.h
new file mode 100644
index 0000000..4df4eac
--- /dev/null
+++ b/sound/soc/intel/ssp/mid_ssp.h
@@ -0,0 +1,124 @@
+/*
+ *	mfld_ssp.h - ASoC CPU DAI driver for
+ *
+ *  Copyright (C) 2011-12 Intel Corp
+ *  Authors:	Selma Bensaid <selma.bensaid@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+#ifndef MID_SSP_H_
+#define MID_SSP_H_
+
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/moduleparam.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <sound/core.h>
+#include <sound/control.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/info.h>
+#include <sound/soc.h>
+#include <sound/soc-dai.h>
+
+#include <linux/intel_mid_i2s_if.h>
+
+#define SSP_MODEM_DAI_NAME "ssp-modem-cpu-dai"
+#define SSP_BT_DAI_NAME "ssp-bt-cpu-dai"
+
+#define SSP_MAX_BUFFER		(640*1024)
+#define SSP_MIN_BUFFER		(640*1024)
+
+#define TRISTATE_BIT			0
+#define FRAME_SYNC_RELATIVE_TIMING_BIT	1
+#define DUMMY_START_ONE_PERIOD_OFFSET	2
+#define DUMMY_START_ONE_PERIOD_MASK     0x3
+
+#define IS_TRISTATE_ENABLED(x) (x & BIT(TRISTATE_BIT))
+#define IS_NEXT_FRMS_ASSERTED_WITH_LSB_PREVIOUS_FRM(x) \
+			((x & BIT(FRAME_SYNC_RELATIVE_TIMING_BIT)) \
+					>> FRAME_SYNC_RELATIVE_TIMING_BIT)
+#define IS_DUMMY_START_ONE_PERIOD_OFFSET(x) \
+			((x >> DUMMY_START_ONE_PERIOD_OFFSET) \
+					& DUMMY_START_ONE_PERIOD_MASK)
+
+#define MID_SSP_RX_FIFO_THRESHOLD 8
+#define MID_SSP_TX_FIFO_THRESHOLD 7
+
+
+/* data driven FALLING, data sampled RISING, idle LOW */
+#define SSP_DAI_SCMODE_0        (1 << 4)
+/* data driven RISING, data sampled FALLING, idle LOW */
+#define SSP_DAI_SCMODE_1		(2 << 4)
+/* data driven RISING, data sampled FALLING, idle HIGH */
+#define SSP_DAI_SCMODE_2		(3 << 4)
+/* data driven FALLING, data sampled RISING, idle HIGH */
+#define SSP_DAI_SCMODE_3		(4 << 4)
+
+
+/*
+ * Structures Definition
+ */
+
+
+struct intel_ssp_config {
+	struct intel_mid_i2s_hdl *i2s_handle;
+	struct intel_mid_i2s_settings i2s_settings;
+#ifndef _LLI_ENABLED_
+	bool intel_mid_dma_alloc;
+#endif /* _LLI_ENABLED_ */
+	bool ssp_dai_tx_allocated;
+	bool ssp_dai_rx_allocated;
+};
+
+struct intel_ssp_info {
+	struct workqueue_struct *ssp_dai_wq;
+};
+
+struct intel_alsa_ssp_stream_info {
+	struct snd_pcm_substream *substream;
+	struct work_struct ssp_ws;
+	struct intel_ssp_config *ssp_config;
+	unsigned long stream_status;
+	u32 period_req_index;
+	s32 period_cb_index;
+	u8 *addr;
+	int length;
+};
+
+
+/*
+ * Enum Definition
+ */
+
+enum intel_alsa_ssp_stream_status {
+	INTEL_ALSA_SSP_STREAM_INIT = 0,
+	INTEL_ALSA_SSP_STREAM_STARTED,
+	INTEL_ALSA_SSP_STREAM_RUNNING,
+	INTEL_ALSA_SSP_STREAM_PAUSED,
+	INTEL_ALSA_SSP_STREAM_DROPPED,
+};
+enum ssp_clk_def {
+	SSP_CLK_ONCHIP = 0x0,
+	SSP_CLK_NET,
+	SSP_CLK_EXT,
+	SSP_CLK_AUDIO
+};
+
+
+#endif /* MID_SSP_H_ */
diff --git a/sound/soc/intel/sst/Makefile b/sound/soc/intel/sst/Makefile
new file mode 100644
index 0000000..8b620d0
--- /dev/null
+++ b/sound/soc/intel/sst/Makefile
@@ -0,0 +1,13 @@
+# Makefile for SST Audio driver
+snd-intel-sst-objs := sst.o sst_ipc.o sst_stream.o sst_drv_interface.o sst_dsp.o sst_pvt.o sst_app_interface.o sst_acpi.o
+
+ifdef CONFIG_DEBUG_FS
+	snd-intel-sst-objs += sst_debug.o
+endif
+
+obj-$(CONFIG_SND_INTEL_SST) += snd-intel-sst.o
+
+
+CFLAGS_snd-intel-sst.o = -I$(src)
+
+ccflags-y += -DMRFLD_WORD_WA -Werror
diff --git a/sound/soc/intel/sst/sst.c b/sound/soc/intel/sst/sst.c
new file mode 100644
index 0000000..5d0eea1
--- /dev/null
+++ b/sound/soc/intel/sst/sst.c
@@ -0,0 +1,1255 @@
+/*
+ *  sst.c - Intel SST Driver for audio engine
+ *
+ *  Copyright (C) 2008-10	Intel Corp
+ *  Authors:	Vinod Koul <vinod.koul@intel.com>
+ *		Harsha Priya <priya.harsha@intel.com>
+ *		Dharageswari R <dharageswari.r@intel.com>
+ *		KP Jeeja <jeeja.kp@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This driver enumerates the SST audio engine as a PCI or ACPI device and
+ *  provides interface to the platform driver to interact with the SST audio
+ *  Firmware.
+ *
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/firmware.h>
+#include <linux/miscdevice.h>
+#include <linux/pm_runtime.h>
+#include <linux/pm_qos.h>
+#include <linux/async.h>
+#include <linux/lnw_gpio.h>
+#include <linux/delay.h>
+#include <linux/acpi.h>
+#include <asm/intel-mid.h>
+#include <asm/platform_sst_audio.h>
+#include <asm/platform_sst.h>
+#include "../sst_platform.h"
+#include "../platform_ipc_v2.h"
+#include "sst.h"
+
+#define CREATE_TRACE_POINTS
+#include "sst_trace.h"
+
+MODULE_AUTHOR("Vinod Koul <vinod.koul@intel.com>");
+MODULE_AUTHOR("Harsha Priya <priya.harsha@intel.com>");
+MODULE_AUTHOR("Dharageswari R <dharageswari.r@intel.com>");
+MODULE_AUTHOR("KP Jeeja <jeeja.kp@intel.com>");
+MODULE_DESCRIPTION("Intel (R) SST(R) Audio Engine Driver");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION(SST_DRIVER_VERSION);
+
+struct intel_sst_drv *sst_drv_ctx;
+static struct mutex drv_ctx_lock;
+
+/*
+ *  * ioctl32 compat
+ *   */
+#ifdef CONFIG_COMPAT
+#include "sst_app_compat_interface.c"
+#else
+#define intel_sst_ioctl_compat NULL
+#endif
+
+static const struct file_operations intel_sst_fops_cntrl = {
+	.owner = THIS_MODULE,
+	.open = intel_sst_open_cntrl,
+	.release = intel_sst_release_cntrl,
+	.unlocked_ioctl = intel_sst_ioctl,
+	.compat_ioctl = intel_sst_ioctl_compat,
+};
+
+struct miscdevice lpe_ctrl = {
+	.minor = MISC_DYNAMIC_MINOR,/* dynamic allocation */
+	.name = "intel_sst_ctrl",/* /dev/intel_sst_ctrl */
+	.fops = &intel_sst_fops_cntrl
+};
+
+static inline void set_imr_interrupts(struct intel_sst_drv *ctx, bool enable)
+{
+	union interrupt_reg imr;
+
+	spin_lock(&ctx->ipc_spin_lock);
+	imr.full = sst_shim_read(ctx->shim, SST_IMRX);
+	if (enable) {
+		imr.part.done_interrupt = 0;
+		imr.part.busy_interrupt = 0;
+	} else {
+		imr.part.done_interrupt = 1;
+		imr.part.busy_interrupt = 1;
+	}
+	sst_shim_write(ctx->shim, SST_IMRX, imr.full);
+	spin_unlock(&ctx->ipc_spin_lock);
+}
+
+#define SST_IS_PROCESS_REPLY(header) ((header & PROCESS_MSG) ? true : false)
+#define SST_VALIDATE_MAILBOX_SIZE(size) ((size <= SST_MAILBOX_SIZE) ? true : false)
+
+static irqreturn_t intel_sst_interrupt_mrfld(int irq, void *context)
+{
+	union interrupt_reg_mrfld isr;
+	union ipc_header_mrfld header;
+	union sst_imr_reg_mrfld imr;
+	struct ipc_post *msg = NULL;
+	unsigned int size = 0;
+	struct intel_sst_drv *drv = (struct intel_sst_drv *) context;
+	irqreturn_t retval = IRQ_HANDLED;
+
+	/* Interrupt arrived, check src */
+	isr.full = sst_shim_read64(drv->shim, SST_ISRX);
+	if (isr.part.done_interrupt) {
+		/* Clear done bit */
+		spin_lock(&drv->ipc_spin_lock);
+		header.full = sst_shim_read64(drv->shim,
+					drv->ipc_reg.ipcx);
+		header.p.header_high.part.done = 0;
+		sst_shim_write64(drv->shim, drv->ipc_reg.ipcx, header.full);
+		/* write 1 to clear status register */;
+		isr.part.done_interrupt = 1;
+		sst_shim_write64(drv->shim, SST_ISRX, isr.full);
+		spin_unlock(&drv->ipc_spin_lock);
+		trace_sst_ipc("ACK   <-", header.p.header_high.full,
+					  header.p.header_low_payload,
+					  header.p.header_high.part.drv_id);
+		queue_work(drv->post_msg_wq, &drv->ipc_post_msg.wq);
+		retval = IRQ_HANDLED;
+	}
+	if (isr.part.busy_interrupt) {
+		spin_lock(&drv->ipc_spin_lock);
+		imr.full = sst_shim_read64(drv->shim, SST_IMRX);
+		imr.part.busy_interrupt = 1;
+		sst_shim_write64(drv->shim, SST_IMRX, imr.full);
+		spin_unlock(&drv->ipc_spin_lock);
+		header.full =  sst_shim_read64(drv->shim, drv->ipc_reg.ipcd);
+		if (sst_create_ipc_msg(&msg, header.p.header_high.part.large)) {
+			pr_err("No memory available\n");
+			drv->ops->clear_interrupt();
+			return IRQ_HANDLED;
+		}
+		if (header.p.header_high.part.large) {
+			size = header.p.header_low_payload;
+			if (SST_VALIDATE_MAILBOX_SIZE(size)) {
+				memcpy_fromio(msg->mailbox_data,
+					drv->mailbox + drv->mailbox_recv_offset, size);
+			} else {
+				pr_err("Mailbox not copied, payload siz is: %u\n", size);
+				header.p.header_low_payload = 0;
+			}
+		}
+		msg->mrfld_header = header;
+		msg->is_process_reply =
+			SST_IS_PROCESS_REPLY(header.p.header_high.part.msg_id);
+		trace_sst_ipc("REPLY <-", msg->mrfld_header.p.header_high.full,
+					  msg->mrfld_header.p.header_low_payload,
+					  msg->mrfld_header.p.header_high.part.drv_id);
+		spin_lock(&drv->rx_msg_lock);
+		list_add_tail(&msg->node, &drv->rx_list);
+		spin_unlock(&drv->rx_msg_lock);
+		drv->ops->clear_interrupt();
+		retval = IRQ_WAKE_THREAD;
+	}
+	return retval;
+}
+
+static irqreturn_t intel_sst_irq_thread_mfld(int irq, void *context)
+{
+	struct intel_sst_drv *drv = (struct intel_sst_drv *) context;
+	struct ipc_post *__msg, *msg = NULL;
+	unsigned long irq_flags;
+
+	if (list_empty(&drv->rx_list))
+		return IRQ_HANDLED;
+
+	spin_lock_irqsave(&drv->rx_msg_lock, irq_flags);
+	list_for_each_entry_safe(msg, __msg, &drv->rx_list, node) {
+
+		list_del(&msg->node);
+		spin_unlock_irqrestore(&drv->rx_msg_lock, irq_flags);
+		if (msg->is_process_reply)
+			drv->ops->process_message(msg);
+		else
+			drv->ops->process_reply(msg);
+
+		if (msg->is_large)
+			kfree(msg->mailbox_data);
+		kfree(msg);
+		spin_lock_irqsave(&drv->rx_msg_lock, irq_flags);
+	}
+	spin_unlock_irqrestore(&drv->rx_msg_lock, irq_flags);
+	return IRQ_HANDLED;
+}
+/**
+* intel_sst_interrupt - Interrupt service routine for SST
+*
+* @irq:	irq number of interrupt
+* @context: pointer to device structre
+*
+* This function is called by OS when SST device raises
+* an interrupt. This will be result of write in IPC register
+* Source can be busy or done interrupt
+*/
+static irqreturn_t intel_sst_intr_mfld(int irq, void *context)
+{
+	union interrupt_reg isr;
+	union ipc_header header;
+	irqreturn_t retval = IRQ_HANDLED;
+	struct ipc_post *msg = NULL;
+	unsigned int size = 0;
+	struct intel_sst_drv *drv = (struct intel_sst_drv *) context;
+
+	/* Interrupt arrived, check src */
+	isr.full = sst_shim_read(drv->shim, SST_ISRX);
+	if (isr.part.done_interrupt) {
+		/* Mask all interrupts till this one is processsed */
+		set_imr_interrupts(drv, false);
+		/* Clear done bit */
+		spin_lock(&drv->ipc_spin_lock);
+		header.full = sst_shim_read(drv->shim, drv->ipc_reg.ipcx);
+		header.part.done = 0;
+		sst_shim_write(drv->shim, drv->ipc_reg.ipcx, header.full);
+		/* write 1 to clear status register */;
+		isr.part.done_interrupt = 1;
+		sst_shim_write(drv->shim, SST_ISRX, isr.full);
+		spin_unlock(&drv->ipc_spin_lock);
+		queue_work(drv->post_msg_wq, &sst_drv_ctx->ipc_post_msg.wq);
+
+		/* Un mask done and busy intr */
+		set_imr_interrupts(drv, true);
+		retval = IRQ_HANDLED;
+	}
+	if (isr.part.busy_interrupt) {
+		/* Mask all interrupts till we process it in bottom half */
+		set_imr_interrupts(drv, false);
+		header.full = sst_shim_read(drv->shim, drv->ipc_reg.ipcd);
+		if (sst_create_ipc_msg(&msg, header.part.large)) {
+			pr_err("No memory available\n");
+			drv->ops->clear_interrupt();
+			return IRQ_HANDLED;
+		}
+		if (header.part.large) {
+			size = header.part.data;
+			if (SST_VALIDATE_MAILBOX_SIZE(size)) {
+				memcpy_fromio(msg->mailbox_data,
+					drv->mailbox + drv->mailbox_recv_offset + 4, size);
+			} else {
+				pr_err("Mailbox not copied, payload siz is: %u\n", size);
+				header.part.data = 0;
+			}
+		}
+		msg->header = header;
+		msg->is_process_reply =
+				SST_IS_PROCESS_REPLY(msg->header.part.msg_id);
+		spin_lock(&drv->rx_msg_lock);
+		list_add_tail(&msg->node, &drv->rx_list);
+		spin_unlock(&drv->rx_msg_lock);
+		drv->ops->clear_interrupt();
+		retval = IRQ_WAKE_THREAD;
+	}
+	return retval;
+}
+
+static int sst_save_dsp_context_v2(struct intel_sst_drv *sst)
+{
+	unsigned int pvt_id;
+	struct ipc_post *msg = NULL;
+	struct ipc_dsp_hdr dsp_hdr;
+	struct sst_block *block;
+
+	/*send msg to fw*/
+	pvt_id = sst_assign_pvt_id(sst);
+	if (sst_create_block_and_ipc_msg(&msg, true, sst, &block,
+				IPC_CMD, pvt_id)) {
+		pr_err("msg/block alloc failed. Not proceeding with context save\n");
+		return 0;
+	}
+
+	sst_fill_header_mrfld(&msg->mrfld_header, IPC_CMD,
+			      SST_TASK_ID_MEDIA, 1, pvt_id);
+	msg->mrfld_header.p.header_low_payload = sizeof(dsp_hdr);
+	msg->mrfld_header.p.header_high.part.res_rqd = 1;
+	sst_fill_header_dsp(&dsp_hdr, IPC_PREP_D3, PIPE_RSVD, pvt_id);
+	memcpy(msg->mailbox_data, &dsp_hdr, sizeof(dsp_hdr));
+
+	sst_add_to_dispatch_list_and_post(sst, msg);
+	/*wait for reply*/
+	if (sst_wait_timeout(sst, block)) {
+		pr_err("sst: err fw context save timeout  ...\n");
+		pr_err("not suspending FW!!!");
+		sst_free_block(sst, block);
+		return -EIO;
+	}
+	if (block->ret_code) {
+		pr_err("fw responded w/ error %d", block->ret_code);
+		sst_free_block(sst, block);
+		return -EIO;
+	}
+
+	sst_free_block(sst, block);
+	return 0;
+}
+
+static int sst_save_dsp_context(struct intel_sst_drv *sst)
+{
+	struct snd_sst_ctxt_params fw_context;
+	unsigned int pvt_id;
+	struct ipc_post *msg = NULL;
+	struct sst_block *block;
+	pr_debug("%s: Enter\n", __func__);
+
+	/*send msg to fw*/
+	pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+	if (sst_create_block_and_ipc_msg(&msg, true, sst_drv_ctx, &block,
+				IPC_IA_GET_FW_CTXT, pvt_id)) {
+		pr_err("msg/block alloc failed. Not proceeding with context save\n");
+		return -ENOMEM;
+	}
+	sst_fill_header(&msg->header, IPC_IA_GET_FW_CTXT, 1, pvt_id);
+	msg->header.part.data = sizeof(fw_context) + sizeof(u32);
+	fw_context.address = virt_to_phys((void *)sst_drv_ctx->fw_cntx);
+	fw_context.size = FW_CONTEXT_MEM;
+	memcpy(msg->mailbox_data, &msg->header, sizeof(u32));
+	memcpy(msg->mailbox_data + sizeof(u32),
+				&fw_context, sizeof(fw_context));
+	sst_add_to_dispatch_list_and_post(sst, msg);
+	/*wait for reply*/
+	if (sst_wait_timeout(sst_drv_ctx, block))
+		pr_err("sst: err fw context save timeout  ...\n");
+	pr_debug("fw context saved  ...\n");
+	if (block->ret_code)
+		sst_drv_ctx->fw_cntx_size = 0;
+	else
+		sst_drv_ctx->fw_cntx_size = *sst_drv_ctx->fw_cntx;
+	pr_debug("fw copied data %x\n", sst_drv_ctx->fw_cntx_size);
+	sst_free_block(sst_drv_ctx, block);
+	return 0;
+}
+
+static struct intel_sst_ops mrfld_ops = {
+	.interrupt = intel_sst_interrupt_mrfld,
+	.irq_thread = intel_sst_irq_thread_mfld,
+	.clear_interrupt = intel_sst_clear_intr_mrfld,
+	.start = sst_start_mrfld,
+	.reset = intel_sst_reset_dsp_mrfld,
+	.post_message = sst_post_message_mrfld,
+	.sync_post_message = sst_sync_post_message_mrfld,
+	.process_message = sst_process_message_mrfld,
+	.process_reply = sst_process_reply_mrfld,
+	.save_dsp_context =  sst_save_dsp_context_v2,
+	.alloc_stream = sst_alloc_stream_mrfld,
+	.post_download = sst_post_download_mrfld,
+	.do_recovery = sst_do_recovery_mrfld,
+};
+
+static struct intel_sst_ops mrfld_32_ops = {
+	.interrupt = intel_sst_intr_mfld,
+	.irq_thread = intel_sst_irq_thread_mfld,
+	.clear_interrupt = intel_sst_clear_intr_mfld,
+	.start = sst_start_mrfld,
+	.reset = intel_sst_reset_dsp_mrfld,
+	.post_message = sst_post_message_mfld,
+	.sync_post_message = sst_sync_post_message_mfld,
+	.process_message = sst_process_message_mfld,
+	.process_reply = sst_process_reply_mfld,
+	.save_dsp_context =  sst_save_dsp_context,
+	.restore_dsp_context = sst_restore_fw_context,
+	.alloc_stream = sst_alloc_stream_ctp,
+	.post_download = sst_post_download_byt,
+	.do_recovery = sst_do_recovery,
+};
+
+static struct intel_sst_ops ctp_ops = {
+	.interrupt = intel_sst_intr_mfld,
+	.irq_thread = intel_sst_irq_thread_mfld,
+	.clear_interrupt = intel_sst_clear_intr_mfld,
+	.start = sst_start_mfld,
+	.reset = intel_sst_reset_dsp_mfld,
+	.post_message = sst_post_message_mfld,
+	.sync_post_message = sst_sync_post_message_mfld,
+	.process_message = sst_process_message_mfld,
+	.process_reply = sst_process_reply_mfld,
+	.set_bypass = intel_sst_set_bypass_mfld,
+	.save_dsp_context =  sst_save_dsp_context,
+	.restore_dsp_context = sst_restore_fw_context,
+	.alloc_stream = sst_alloc_stream_ctp,
+	.post_download = sst_post_download_ctp,
+	.do_recovery = sst_do_recovery,
+};
+
+int sst_driver_ops(struct intel_sst_drv *sst)
+{
+
+	switch (sst->pci_id) {
+	case SST_MRFLD_PCI_ID:
+		sst->tstamp = SST_TIME_STAMP_MRFLD;
+		sst->ops = &mrfld_ops;
+		return 0;
+	case SST_BYT_PCI_ID:
+		sst->tstamp = SST_TIME_STAMP_BYT;
+		sst->ops = &mrfld_32_ops;
+		return 0;
+	case SST_CLV_PCI_ID:
+		sst->tstamp =  SST_TIME_STAMP;
+		sst->ops = &ctp_ops;
+		return 0;
+	default:
+		pr_err("SST Driver capablities missing for pci_id: %x", sst->pci_id);
+		return -EINVAL;
+	};
+}
+
+int sst_alloc_drv_context(struct device *dev)
+{
+	struct intel_sst_drv *ctx;
+	mutex_lock(&drv_ctx_lock);
+	if (sst_drv_ctx) {
+		pr_err("Only one sst handle is supported\n");
+		mutex_unlock(&drv_ctx_lock);
+		return -EBUSY;
+	}
+	pr_debug("%s: %d", __func__, __LINE__);
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx) {
+		pr_err("malloc fail\n");
+		mutex_unlock(&drv_ctx_lock);
+		return -ENOMEM;
+	}
+	sst_drv_ctx = ctx;
+	mutex_unlock(&drv_ctx_lock);
+	return 0;
+}
+
+static ssize_t sst_sysfs_get_recovery(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", ctx->sst_state);
+}
+
+
+static ssize_t sst_sysfs_set_recovery(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t len)
+{
+	long val;
+	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
+
+	if (kstrtol(buf, 0, &val))
+		return -EINVAL;
+
+	if (val == 1) {
+		if (!atomic_read(&ctx->pm_usage_count)) {
+			pr_debug("%s: set sst state to uninit...\n", __func__);
+			sst_set_fw_state_locked(ctx, SST_UN_INIT);
+		} else {
+			pr_err("%s: not setting sst state... %d\n", __func__,
+					atomic_read(&ctx->pm_usage_count));
+			pr_err("Unrecoverable state....\n");
+			BUG();
+			return -EPERM;
+		}
+	}
+
+	return len;
+}
+
+static DEVICE_ATTR(audio_recovery, S_IRUGO | S_IWUSR,
+			sst_sysfs_get_recovery, sst_sysfs_set_recovery);
+
+int sst_request_firmware_async(struct intel_sst_drv *ctx)
+{
+	int ret = 0;
+
+	snprintf(ctx->firmware_name, sizeof(ctx->firmware_name),
+			"%s%04x%s", "fw_sst_",
+			ctx->pci_id, ".bin");
+	pr_debug("Requesting FW %s now...\n", ctx->firmware_name);
+
+	trace_sst_fw_download("Request firmware async", ctx->sst_state);
+
+	ret = request_firmware_nowait(THIS_MODULE, 1, ctx->firmware_name,
+			ctx->dev, GFP_KERNEL, ctx, sst_firmware_load_cb);
+	if (ret)
+		pr_err("could not load firmware %s error %d\n", ctx->firmware_name, ret);
+
+	return ret;
+}
+/*
+* intel_sst_probe - PCI probe function
+*
+* @pci:	PCI device structure
+* @pci_id: PCI device ID structure
+*
+* This function is called by OS when a device is found
+* This enables the device, interrupt etc
+*/
+static int intel_sst_probe(struct pci_dev *pci,
+			const struct pci_device_id *pci_id)
+{
+	int i, ret = 0;
+	struct intel_sst_ops *ops;
+	struct sst_platform_info *sst_pdata = pci->dev.platform_data;
+	int ddr_base;
+	u32 ssp_base_add;
+	u32 dma_base_add;
+	u32 len;
+
+
+
+	pr_debug("Probe for DID %x\n", pci->device);
+	ret = sst_alloc_drv_context(&pci->dev);
+	if (ret)
+		return ret;
+
+	sst_drv_ctx->dev = &pci->dev;
+	sst_drv_ctx->pci_id = pci->device;
+	if (!sst_pdata)
+		return -EINVAL;
+	sst_drv_ctx->pdata = sst_pdata;
+
+	if (!sst_drv_ctx->pdata->probe_data)
+		return -EINVAL;
+	memcpy(&sst_drv_ctx->info, sst_drv_ctx->pdata->probe_data,
+					sizeof(sst_drv_ctx->info));
+
+	sst_drv_ctx->use_32bit_ops = sst_drv_ctx->pdata->ipc_info->use_32bit_ops;
+	sst_drv_ctx->mailbox_recv_offset = sst_drv_ctx->pdata->ipc_info->mbox_recv_off;
+
+	if (0 != sst_driver_ops(sst_drv_ctx))
+		return -EINVAL;
+	ops = sst_drv_ctx->ops;
+	mutex_init(&sst_drv_ctx->stream_lock);
+	mutex_init(&sst_drv_ctx->sst_lock);
+	mutex_init(&sst_drv_ctx->mixer_ctrl_lock);
+	mutex_init(&sst_drv_ctx->csr_lock);
+
+	sst_drv_ctx->stream_cnt = 0;
+	sst_drv_ctx->fw_in_mem = NULL;
+	sst_drv_ctx->vcache.file1_in_mem = NULL;
+	sst_drv_ctx->vcache.file2_in_mem = NULL;
+	sst_drv_ctx->vcache.size1 = 0;
+	sst_drv_ctx->vcache.size2 = 0;
+
+	/* we don't use dma, so set to 0*/
+	sst_drv_ctx->use_dma = 0; //1;
+	sst_drv_ctx->use_lli = 1;
+
+	INIT_LIST_HEAD(&sst_drv_ctx->memcpy_list);
+	INIT_LIST_HEAD(&sst_drv_ctx->libmemcpy_list);
+
+	INIT_LIST_HEAD(&sst_drv_ctx->ipc_dispatch_list);
+	INIT_LIST_HEAD(&sst_drv_ctx->block_list);
+	INIT_LIST_HEAD(&sst_drv_ctx->rx_list);
+	INIT_WORK(&sst_drv_ctx->ipc_post_msg.wq, ops->post_message);
+	init_waitqueue_head(&sst_drv_ctx->wait_queue);
+
+	sst_drv_ctx->mad_wq = create_singlethread_workqueue("sst_mad_wq");
+	if (!sst_drv_ctx->mad_wq)
+		goto do_free_drv_ctx;
+	sst_drv_ctx->post_msg_wq =
+		create_singlethread_workqueue("sst_post_msg_wq");
+	if (!sst_drv_ctx->post_msg_wq)
+		goto free_mad_wq;
+
+	spin_lock_init(&sst_drv_ctx->ipc_spin_lock);
+	spin_lock_init(&sst_drv_ctx->block_lock);
+	spin_lock_init(&sst_drv_ctx->pvt_id_lock);
+	spin_lock_init(&sst_drv_ctx->rx_msg_lock);
+
+	sst_drv_ctx->ipc_reg.ipcx = SST_IPCX + sst_drv_ctx->pdata->ipc_info->ipc_offset;
+	sst_drv_ctx->ipc_reg.ipcd = SST_IPCD + sst_drv_ctx->pdata->ipc_info->ipc_offset;
+	pr_debug("ipcx 0x%x ipxd 0x%x", sst_drv_ctx->ipc_reg.ipcx,
+					sst_drv_ctx->ipc_reg.ipcd);
+
+	pr_info("Got drv data max stream %d\n",
+				sst_drv_ctx->info.max_streams);
+	for (i = 1; i <= sst_drv_ctx->info.max_streams; i++) {
+		struct stream_info *stream = &sst_drv_ctx->streams[i];
+		memset(stream, 0, sizeof(*stream));
+		stream->pipe_id = PIPE_RSVD;
+		mutex_init(&stream->lock);
+	}
+
+	ret = sst_request_firmware_async(sst_drv_ctx);
+	if (ret) {
+		pr_err("Firmware download failed:%d\n", ret);
+		goto do_free_mem;
+	}
+	/* Init the device */
+	ret = pci_enable_device(pci);
+	if (ret) {
+		pr_err("device can't be enabled\n");
+		goto do_free_mem;
+	}
+	sst_drv_ctx->pci = pci_dev_get(pci);
+	ret = pci_request_regions(pci, SST_DRV_NAME);
+	if (ret)
+		goto do_disable_device;
+	/* map registers */
+	/* SST Shim */
+
+	if (sst_drv_ctx->pci_id == SST_MRFLD_PCI_ID) {
+		sst_drv_ctx->ddr_base = pci_resource_start(pci, 0);
+		/*
+		* check that the relocated IMR base matches with FW Binary
+		* put temporary check till better soln is available for FW
+		*/
+		ddr_base = relocate_imr_addr_mrfld(sst_drv_ctx->ddr_base);
+		if (!sst_drv_ctx->pdata->lib_info) {
+			pr_err("%s:lib_info pointer NULL\n", __func__);
+			ret = -EINVAL;
+			goto do_release_regions;
+		}
+		if (ddr_base != sst_drv_ctx->pdata->lib_info->mod_base) {
+			pr_err("FW LSP DDR BASE does not match with IFWI\n");
+			ret = -EINVAL;
+			goto do_release_regions;
+		}
+		sst_drv_ctx->ddr_end = pci_resource_end(pci, 0);
+
+		sst_drv_ctx->ddr = pci_ioremap_bar(pci, 0);
+		if (!sst_drv_ctx->ddr)
+			goto do_unmap_ddr;
+		pr_debug("sst: DDR Ptr %p\n", sst_drv_ctx->ddr);
+	} else {
+		sst_drv_ctx->ddr = NULL;
+	}
+
+	/* SHIM */
+	sst_drv_ctx->shim_phy_add = pci_resource_start(pci, 1);
+	sst_drv_ctx->shim = pci_ioremap_bar(pci, 1);
+	if (!sst_drv_ctx->shim)
+		goto do_release_regions;
+	pr_debug("SST Shim Ptr %p\n", sst_drv_ctx->shim);
+
+	/* Shared SRAM */
+	sst_drv_ctx->mailbox_add = pci_resource_start(pci, 2);
+	sst_drv_ctx->mailbox = pci_ioremap_bar(pci, 2);
+	if (!sst_drv_ctx->mailbox)
+		goto do_unmap_shim;
+	pr_debug("SRAM Ptr %p\n", sst_drv_ctx->mailbox);
+
+	/* IRAM */
+	sst_drv_ctx->iram_end = pci_resource_end(pci, 3);
+	sst_drv_ctx->iram_base = pci_resource_start(pci, 3);
+	sst_drv_ctx->iram = pci_ioremap_bar(pci, 3);
+	if (!sst_drv_ctx->iram)
+		goto do_unmap_sram;
+	pr_debug("IRAM Ptr %p\n", sst_drv_ctx->iram);
+
+	/* DRAM */
+	sst_drv_ctx->dram_end = pci_resource_end(pci, 4);
+	sst_drv_ctx->dram_base = pci_resource_start(pci, 4);
+	sst_drv_ctx->dram = pci_ioremap_bar(pci, 4);
+	if (!sst_drv_ctx->dram)
+		goto do_unmap_iram;
+	pr_debug("DRAM Ptr %p\n", sst_drv_ctx->dram);
+
+	if ((sst_pdata->pdata != NULL) &&
+			(sst_pdata->debugfs_data != NULL)) {
+		if (sst_pdata->ssp_data != NULL) {
+			/* SSP Register */
+			ssp_base_add = sst_pdata->ssp_data->base_add;
+			len = sst_pdata->debugfs_data->ssp_reg_size;
+			for (i = 0; i < sst_pdata->debugfs_data->num_ssp; i++) {
+				sst_drv_ctx->debugfs.ssp[i] =
+					devm_ioremap(&pci->dev,
+						ssp_base_add + (len * i), len);
+				if (!sst_drv_ctx->debugfs.ssp[i]) {
+					pr_warn("ssp ioremap failed\n");
+					continue;
+				}
+
+				pr_debug("\n ssp io 0x%p ssp 0x%x size 0x%x",
+					sst_drv_ctx->debugfs.ssp[i],
+						ssp_base_add, len);
+			}
+		}
+
+		/* DMA Register */
+		dma_base_add = sst_pdata->pdata->sst_dma_base[0];
+		len = sst_pdata->debugfs_data->dma_reg_size;
+		for (i = 0; i < sst_pdata->debugfs_data->num_dma; i++) {
+			sst_drv_ctx->debugfs.dma_reg[i] =
+				devm_ioremap(&pci->dev,
+					dma_base_add + (len * i), len);
+			if (!sst_drv_ctx->debugfs.dma_reg[i]) {
+				pr_warn("dma ioremap failed\n");
+				continue;
+			}
+
+			pr_debug("\n dma io 0x%p ssp 0x%x size 0x%x",
+				sst_drv_ctx->debugfs.dma_reg[i],
+					dma_base_add, len);
+		}
+	}
+
+	/* Do not access iram/dram etc before LPE is reset */
+
+	sst_drv_ctx->dump_buf.iram_buf.size = pci_resource_len(pci, 3);
+	sst_drv_ctx->dump_buf.iram_buf.buf = kzalloc(sst_drv_ctx->dump_buf.iram_buf.size,
+						GFP_KERNEL);
+	if (!sst_drv_ctx->dump_buf.iram_buf.buf) {
+		pr_err("%s: no memory\n", __func__);
+		ret = -ENOMEM;
+		goto do_unmap_dram;
+	}
+
+	sst_drv_ctx->dump_buf.dram_buf.size = pci_resource_len(pci, 4);
+	sst_drv_ctx->dump_buf.dram_buf.buf = kzalloc(sst_drv_ctx->dump_buf.dram_buf.size,
+						GFP_KERNEL);
+	if (!sst_drv_ctx->dump_buf.dram_buf.buf) {
+		pr_err("%s: no memory\n", __func__);
+		ret = -ENOMEM;
+		goto do_free_iram_buf;
+	}
+
+	pr_debug("\niram len 0x%x dram len 0x%x",
+			sst_drv_ctx->dump_buf.iram_buf.size,
+			sst_drv_ctx->dump_buf.dram_buf.size);
+
+	if (sst_drv_ctx->pci_id == SST_CLV_PCI_ID) {
+		sst_drv_ctx->probe_bytes = kzalloc(SST_MAX_BIN_BYTES, GFP_KERNEL);
+		if (!sst_drv_ctx->probe_bytes) {
+			pr_err("%s: no memory\n", __func__);
+			ret = -ENOMEM;
+			goto do_free_dram_buf;
+		}
+	}
+
+	sst_set_fw_state_locked(sst_drv_ctx, SST_UN_INIT);
+	sst_drv_ctx->irq_num = pci->irq;
+	/* Register the ISR */
+	ret = request_threaded_irq(pci->irq, sst_drv_ctx->ops->interrupt,
+		sst_drv_ctx->ops->irq_thread, 0, SST_DRV_NAME,
+		sst_drv_ctx);
+	if (ret)
+		goto do_free_probe_bytes;
+	pr_debug("Registered IRQ 0x%x\n", pci->irq);
+
+	/*Register LPE Control as misc driver*/
+	ret = misc_register(&lpe_ctrl);
+	if (ret) {
+		pr_err("couldn't register control device\n");
+		goto do_free_irq;
+	}
+	/* default intr are unmasked so set this as masked */
+	if (sst_drv_ctx->pci_id == SST_MRFLD_PCI_ID)
+		sst_shim_write64(sst_drv_ctx->shim, SST_IMRX, 0xFFFF0038);
+
+	if (sst_drv_ctx->use_32bit_ops) {
+		pr_debug("allocate mem for context save/restore\n ");
+		/*allocate mem for fw context save during suspend*/
+		sst_drv_ctx->fw_cntx = kzalloc(FW_CONTEXT_MEM, GFP_KERNEL);
+		if (!sst_drv_ctx->fw_cntx) {
+			ret = -ENOMEM;
+			goto do_free_misc;
+		}
+		/*setting zero as that is valid mem to restore*/
+		sst_drv_ctx->fw_cntx_size = 0;
+	}
+	if (sst_drv_ctx->pci_id == SST_CLV_PCI_ID) {
+		u32 csr;
+		u32 csr2;
+		u32 clkctl;
+
+		/*set lpe start clock and ram size*/
+		csr = sst_shim_read(sst_drv_ctx->shim, SST_CSR);
+		csr |= 0x30000;
+		/*make sure clksel set to OSC for SSP0,1 (default)*/
+		csr &= 0xFFFFFFF3;
+		sst_shim_write(sst_drv_ctx->shim, SST_CSR, csr);
+
+		/*set clock output enable for SSP0,1,3*/
+		clkctl = sst_shim_read(sst_drv_ctx->shim, SST_CLKCTL);
+		if (sst_drv_ctx->pci_id == SST_CLV_PCI_ID)
+			clkctl |= (0x7 << 16);
+		else
+			clkctl |= ((1<<16)|(1<<17));
+		sst_shim_write(sst_drv_ctx->shim, SST_CLKCTL, clkctl);
+
+		/* set SSP0 & SSP1 disable DMA Finish*/
+		csr2 = sst_shim_read(sst_drv_ctx->shim, SST_CSR2);
+		/*set SSP3 disable DMA finsh for SSSP3 */
+		csr2 |= BIT(1)|BIT(2);
+		sst_shim_write(sst_drv_ctx->shim, SST_CSR2, csr2);
+	}
+	if (sst_drv_ctx->pdata->ssp_data) {
+		if (sst_drv_ctx->pdata->ssp_data->gpio_in_use)
+			sst_set_gpio_conf(&sst_drv_ctx->pdata->ssp_data->gpio);
+	}
+	pci_set_drvdata(pci, sst_drv_ctx);
+	pm_runtime_allow(sst_drv_ctx->dev);
+	pm_runtime_put_noidle(sst_drv_ctx->dev);
+	register_sst(sst_drv_ctx->dev);
+	sst_debugfs_init(sst_drv_ctx);
+	sst_drv_ctx->qos = kzalloc(sizeof(struct pm_qos_request),
+				GFP_KERNEL);
+	if (!sst_drv_ctx->qos)
+		goto do_free_misc;
+	pm_qos_add_request(sst_drv_ctx->qos, PM_QOS_CPU_DMA_LATENCY,
+				PM_QOS_DEFAULT_VALUE);
+
+	ret = device_create_file(sst_drv_ctx->dev, &dev_attr_audio_recovery);
+	if (ret) {
+		pr_err("could not create sysfs %s file\n",
+			dev_attr_audio_recovery.attr.name);
+		goto do_free_qos;
+	}
+
+	pr_info("%s successfully done!\n", __func__);
+	return ret;
+
+do_free_qos:
+	pm_qos_remove_request(sst_drv_ctx->qos);
+	kfree(sst_drv_ctx->qos);
+do_free_misc:
+	misc_deregister(&lpe_ctrl);
+do_free_irq:
+	free_irq(pci->irq, sst_drv_ctx);
+do_free_probe_bytes:
+	if (sst_drv_ctx->pci_id == SST_CLV_PCI_ID)
+		kfree(sst_drv_ctx->probe_bytes);
+do_free_dram_buf:
+#ifdef CONFIG_DEBUG_FS
+	if (sst_drv_ctx->pci_id == SST_CLV_PCI_ID)
+		kfree(sst_drv_ctx->dump_buf.dram_buf.buf);
+do_free_iram_buf:
+	if (sst_drv_ctx->pci_id == SST_CLV_PCI_ID)
+		kfree(sst_drv_ctx->dump_buf.iram_buf.buf);
+#endif
+do_unmap_dram:
+	iounmap(sst_drv_ctx->dram);
+do_unmap_iram:
+	iounmap(sst_drv_ctx->iram);
+do_unmap_sram:
+	iounmap(sst_drv_ctx->mailbox);
+do_unmap_shim:
+	iounmap(sst_drv_ctx->shim);
+
+do_unmap_ddr:
+	if (sst_drv_ctx->ddr)
+		iounmap(sst_drv_ctx->ddr);
+
+do_release_regions:
+	pci_release_regions(pci);
+do_disable_device:
+	pci_disable_device(pci);
+do_free_mem:
+	destroy_workqueue(sst_drv_ctx->post_msg_wq);
+free_mad_wq:
+	destroy_workqueue(sst_drv_ctx->mad_wq);
+do_free_drv_ctx:
+	sst_drv_ctx = NULL;
+	pr_err("Probe failed with %d\n", ret);
+	return ret;
+}
+
+/**
+* intel_sst_remove - PCI remove function
+*
+* @pci:	PCI device structure
+*
+* This function is called by OS when a device is unloaded
+* This frees the interrupt etc
+*/
+static void intel_sst_remove(struct pci_dev *pci)
+{
+	struct intel_sst_drv *sst_drv_ctx = pci_get_drvdata(pci);
+	sst_debugfs_exit(sst_drv_ctx);
+	pm_runtime_get_noresume(sst_drv_ctx->dev);
+	pm_runtime_forbid(sst_drv_ctx->dev);
+	unregister_sst(sst_drv_ctx->dev);
+	pci_dev_put(sst_drv_ctx->pci);
+	sst_set_fw_state_locked(sst_drv_ctx, SST_UN_INIT);
+	misc_deregister(&lpe_ctrl);
+	free_irq(pci->irq, sst_drv_ctx);
+
+	iounmap(sst_drv_ctx->dram);
+	iounmap(sst_drv_ctx->iram);
+	iounmap(sst_drv_ctx->mailbox);
+	iounmap(sst_drv_ctx->shim);
+#ifdef CONFIG_DEBUG_FS
+	if (sst_drv_ctx->pci_id == SST_CLV_PCI_ID) {
+		kfree(sst_drv_ctx->dump_buf.iram_buf.buf);
+		kfree(sst_drv_ctx->dump_buf.dram_buf.buf);
+	}
+#endif
+	if (sst_drv_ctx->pci_id == SST_CLV_PCI_ID)
+		kfree(sst_drv_ctx->probe_bytes);
+
+	device_remove_file(sst_drv_ctx->dev, &dev_attr_audio_recovery);
+	kfree(sst_drv_ctx->fw_cntx);
+	kfree(sst_drv_ctx->runtime_param.param.addr);
+	flush_scheduled_work();
+	destroy_workqueue(sst_drv_ctx->post_msg_wq);
+	destroy_workqueue(sst_drv_ctx->mad_wq);
+	pm_qos_remove_request(sst_drv_ctx->qos);
+	kfree(sst_drv_ctx->qos);
+	kfree(sst_drv_ctx->fw_sg_list.src);
+	kfree(sst_drv_ctx->fw_sg_list.dst);
+	sst_drv_ctx->fw_sg_list.list_len = 0;
+	kfree(sst_drv_ctx->fw_in_mem);
+	sst_drv_ctx->fw_in_mem = NULL;
+	sst_memcpy_free_resources();
+	sst_drv_ctx = NULL;
+	pci_release_regions(pci);
+	pci_disable_device(pci);
+	pci_set_drvdata(pci, NULL);
+}
+
+inline void sst_save_shim64(struct intel_sst_drv *ctx,
+			    void __iomem *shim,
+			    struct sst_shim_regs64 *shim_regs)
+{
+	unsigned long irq_flags;
+	spin_lock_irqsave(&ctx->ipc_spin_lock, irq_flags);
+
+	shim_regs->csr = sst_shim_read64(shim, SST_CSR),
+	shim_regs->pisr = sst_shim_read64(shim, SST_PISR),
+	shim_regs->pimr = sst_shim_read64(shim, SST_PIMR),
+	shim_regs->isrx = sst_shim_read64(shim, SST_ISRX),
+	shim_regs->isrd = sst_shim_read64(shim, SST_ISRD),
+	shim_regs->imrx = sst_shim_read64(shim, SST_IMRX),
+	shim_regs->imrd = sst_shim_read64(shim, SST_IMRD),
+	shim_regs->ipcx = sst_shim_read64(shim, ctx->ipc_reg.ipcx),
+	shim_regs->ipcd = sst_shim_read64(shim, ctx->ipc_reg.ipcd),
+	shim_regs->isrsc = sst_shim_read64(shim, SST_ISRSC),
+	shim_regs->isrlpesc = sst_shim_read64(shim, SST_ISRLPESC),
+	shim_regs->imrsc = sst_shim_read64(shim, SST_IMRSC),
+	shim_regs->imrlpesc = sst_shim_read64(shim, SST_IMRLPESC),
+	shim_regs->ipcsc = sst_shim_read64(shim, SST_IPCSC),
+	shim_regs->ipclpesc = sst_shim_read64(shim, SST_IPCLPESC),
+	shim_regs->clkctl = sst_shim_read64(shim, SST_CLKCTL),
+	shim_regs->csr2 = sst_shim_read64(shim, SST_CSR2);
+
+	spin_unlock_irqrestore(&ctx->ipc_spin_lock, irq_flags);
+}
+
+static inline void sst_restore_shim64(struct intel_sst_drv *ctx,
+				      void __iomem *shim,
+				      struct sst_shim_regs64 *shim_regs)
+{
+	unsigned long irq_flags;
+	spin_lock_irqsave(&ctx->ipc_spin_lock, irq_flags);
+	sst_shim_write64(shim, SST_IMRX, shim_regs->imrx);
+	spin_unlock_irqrestore(&ctx->ipc_spin_lock, irq_flags);
+}
+
+/*
+ * The runtime_suspend/resume is pretty much similar to the legacy
+ * suspend/resume with the noted exception below: The PCI core takes care of
+ * taking the system through D3hot and restoring it back to D0 and so there is
+ * no need to duplicate that here.
+ */
+static int intel_sst_runtime_suspend(struct device *dev)
+{
+	union config_status_reg csr;
+	int ret = 0;
+	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
+
+	pr_info("runtime_suspend called\n");
+	if (ctx->sst_state == SST_UN_INIT) {
+		pr_debug("LPE is already in UNINIT state, No action");
+		return 0;
+	}
+	/*save fw context*/
+	if (ctx->ops->save_dsp_context(ctx))
+		return -EBUSY;
+
+	if (ctx->pci_id == SST_CLV_PCI_ID) {
+		/*Assert RESET on LPE Processor*/
+		csr.full = sst_shim_read(ctx->shim, SST_CSR);
+		ctx->csr_value = csr.full;
+		csr.full = csr.full | 0x2;
+		sst_shim_write(ctx->shim, SST_CSR, csr.full);
+	}
+
+	/* Move the SST state to Suspended */
+	sst_set_fw_state_locked(ctx, SST_SUSPENDED);
+
+	flush_workqueue(ctx->post_msg_wq);
+	synchronize_irq(ctx->irq_num);
+
+	if (ctx->pci_id == SST_BYT_PCI_ID || ctx->pci_id == SST_CHT_PCI_ID) {
+		/* save the shim registers because PMC doesn't save state */
+		sst_save_shim64(ctx, ctx->shim, ctx->shim_regs64);
+	}
+	return ret;
+}
+
+static int intel_sst_runtime_resume(struct device *dev)
+{
+	u32 csr;
+	int ret = 0;
+	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
+
+	pr_info("runtime_resume called\n");
+
+	if (ctx->pci_id == SST_BYT_PCI_ID || ctx->pci_id == SST_CHT_PCI_ID) {
+		/* wait for device power up a/c to PCI spec */
+		usleep_range(10000, 11000);
+		sst_restore_shim64(ctx, ctx->shim, ctx->shim_regs64);
+	}
+
+	if (ctx->pci_id == SST_CLV_PCI_ID) {
+		csr = sst_shim_read(ctx->shim, SST_CSR);
+		/*
+		 * To restore the csr_value after S0ix and S3 states.
+		 * The value 0x30000 is to enable LPE dram high and low addresses.
+		 * Reference:
+		 * Penwell Audio Voice Module HAS 1.61 Section - 13.12.1 -
+		 * CSR - Configuration and Status Register.
+		 */
+		csr |= (ctx->csr_value | 0x30000);
+		sst_shim_write(ctx->shim, SST_CSR, csr);
+		if (sst_drv_ctx->pdata->ssp_data) {
+			if (ctx->pdata->ssp_data->gpio_in_use)
+				sst_set_gpio_conf(&ctx->pdata->ssp_data->gpio);
+		}
+	}
+	/* When fw_clear_cache is set, clear the cached firmware copy */
+	/* fw_clear_cache is set through debugfs support */
+	if (atomic_read(&ctx->fw_clear_cache) && ctx->fw_in_mem) {
+		pr_debug("Clearing the cached firmware\n");
+		kfree(ctx->fw_in_mem);
+		ctx->fw_in_mem = NULL;
+		atomic_set(&ctx->fw_clear_cache, 0);
+	}
+
+	sst_set_fw_state_locked(ctx, SST_UN_INIT);
+	return ret;
+}
+
+static int intel_sst_suspend(struct device *dev)
+{
+	int retval = 0, usage_count;
+	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
+
+	usage_count = atomic_read(&ctx->pm_usage_count);
+	if (usage_count) {
+		pr_err("Ret error for suspend:%d\n", usage_count);
+		return -EBUSY;
+	}
+	retval = intel_sst_runtime_suspend(dev);
+
+	return retval;
+}
+
+static int intel_sst_runtime_idle(struct device *dev)
+{
+	struct intel_sst_drv *ctx = dev_get_drvdata(dev);
+
+	pr_info("runtime_idle called\n");
+	if (ctx->sst_state != SST_UN_INIT) {
+		pm_schedule_suspend(dev, SST_SUSPEND_DELAY);
+		return -EBUSY;
+	} else {
+		return 0;
+	}
+	return -EBUSY;
+
+}
+
+static void sst_do_shutdown(struct intel_sst_drv *ctx)
+{
+	int retval = 0;
+	unsigned int pvt_id;
+	struct ipc_post *msg = NULL;
+	struct sst_block *block = NULL;
+
+	pr_debug(" %s called\n", __func__);
+	if (ctx->sst_state == SST_SUSPENDED ||
+			ctx->sst_state == SST_UN_INIT) {
+		sst_set_fw_state_locked(ctx, SST_SHUTDOWN);
+		pr_debug("sst is already in suspended/un-int state\n");
+		return;
+	}
+	if (!ctx->use_32bit_ops)
+		return;
+
+	sst_set_fw_state_locked(ctx, SST_SHUTDOWN);
+	flush_workqueue(ctx->post_msg_wq);
+	pvt_id = sst_assign_pvt_id(ctx);
+	retval = sst_create_block_and_ipc_msg(&msg, false,
+			ctx, &block,
+			IPC_IA_PREPARE_SHUTDOWN, pvt_id);
+	if (retval) {
+		pr_err("sst_create_block returned error!\n");
+		return;
+	}
+	sst_fill_header(&msg->header, IPC_IA_PREPARE_SHUTDOWN, 0, pvt_id);
+	sst_add_to_dispatch_list_and_post(ctx, msg);
+	sst_wait_timeout(ctx, block);
+	sst_free_block(ctx, block);
+}
+
+
+/**
+* sst_pci_shutdown - PCI shutdown function
+*
+* @pci:        PCI device structure
+*
+* This function is called by OS when a device is shutdown/reboot
+*
+*/
+
+static void sst_pci_shutdown(struct pci_dev *pci)
+{
+	struct intel_sst_drv *ctx = pci_get_drvdata(pci);
+
+	pr_debug(" %s called\n", __func__);
+
+	sst_do_shutdown(ctx);
+	disable_irq_nosync(pci->irq);
+}
+
+/**
+* sst_acpi_shutdown - platform shutdown function
+*
+* @pci:        Platform device structure
+*
+* This function is called by OS when a device is shutdown/reboot
+*
+*/
+static void sst_acpi_shutdown(struct platform_device *pdev)
+{
+	struct intel_sst_drv *ctx = platform_get_drvdata(pdev);
+	int irq = platform_get_irq(pdev, 0);
+
+	pr_debug(" %s called\n", __func__);
+
+	sst_do_shutdown(ctx);
+	disable_irq_nosync(irq);
+}
+
+static const struct dev_pm_ops intel_sst_pm = {
+	.suspend = intel_sst_suspend,
+	.resume = intel_sst_runtime_resume,
+	.runtime_suspend = intel_sst_runtime_suspend,
+	.runtime_resume = intel_sst_runtime_resume,
+	.runtime_idle = intel_sst_runtime_idle,
+};
+
+static const struct acpi_device_id sst_acpi_ids[];
+
+struct sst_platform_info *sst_get_acpi_driver_data(const char *hid)
+{
+	const struct acpi_device_id *id;
+
+	pr_debug("%s", __func__);
+	for (id = sst_acpi_ids; id->id[0]; id++)
+		if (!strncmp(id->id, hid, 16))
+			return (struct sst_platform_info *)id->driver_data;
+	return NULL;
+}
+
+/* PCI Routines */
+static DEFINE_PCI_DEVICE_TABLE(intel_sst_ids) = {
+	{ PCI_VDEVICE(INTEL, SST_CLV_PCI_ID), 0},
+	{ PCI_VDEVICE(INTEL, SST_MRFLD_PCI_ID), 0},
+	{ 0, }
+};
+MODULE_DEVICE_TABLE(pci, intel_sst_ids);
+
+static const struct acpi_device_id sst_acpi_ids[] = {
+	{ "LPE0F28",  (kernel_ulong_t) &byt_rvp_platform_data },
+	{ "LPE0F281", (kernel_ulong_t) &byt_ffrd8_platform_data },
+	{ "80860F28", (kernel_ulong_t) &byt_ffrd8_platform_data },
+	{ "808622A8", (kernel_ulong_t) &cht_platform_data },
+	{ },
+};
+MODULE_DEVICE_TABLE(acpi, sst_acpi_ids);
+
+static struct pci_driver driver = {
+	.name = SST_DRV_NAME,
+	.id_table = intel_sst_ids,
+	.probe = intel_sst_probe,
+	.remove = intel_sst_remove,
+	.shutdown = sst_pci_shutdown,
+#ifdef CONFIG_PM
+	.driver = {
+		.pm = &intel_sst_pm,
+	},
+#endif
+};
+
+static struct platform_driver sst_acpi_driver = {
+	.driver = {
+		.name			= "intel_sst_acpi",
+		.owner			= THIS_MODULE,
+		.acpi_match_table	= ACPI_PTR(sst_acpi_ids),
+		.pm			= &intel_sst_pm,
+	},
+	.probe	= sst_acpi_probe,
+	.remove	= sst_acpi_remove,
+	.shutdown = sst_acpi_shutdown,
+};
+
+
+/**
+* intel_sst_init - Module init function
+*
+* Registers with PCI
+* Registers with /dev
+* Init all data strutures
+*/
+static int __init intel_sst_init(void)
+{
+	/* Init all variables, data structure etc....*/
+	int ret = 0;
+	pr_info("INFO: ******** SST DRIVER loading.. Ver: %s\n",
+				       SST_DRIVER_VERSION);
+
+	mutex_init(&drv_ctx_lock);
+	/* Register with PCI */
+	ret = pci_register_driver(&driver);
+	if (ret)
+		pr_err("PCI register failed\n");
+
+	ret = platform_driver_register(&sst_acpi_driver);
+	if (ret)
+		pr_err("ACPI register failed\n");
+	return ret;
+}
+
+/**
+* intel_sst_exit - Module exit function
+*
+* Unregisters with PCI
+* Unregisters with /dev
+* Frees all data strutures
+*/
+static void __exit intel_sst_exit(void)
+{
+	pci_unregister_driver(&driver);
+	platform_driver_unregister(&sst_acpi_driver);
+
+	pr_debug("driver unloaded\n");
+	sst_drv_ctx = NULL;
+	return;
+}
+
+module_init(intel_sst_init);
+module_exit(intel_sst_exit);
diff --git a/sound/soc/intel/sst/sst.h b/sound/soc/intel/sst/sst.h
new file mode 100644
index 0000000..64f81c6
--- /dev/null
+++ b/sound/soc/intel/sst/sst.h
@@ -0,0 +1,932 @@
+/*
+ *  sst.h - Intel SST Driver for audio engine
+ *
+ *  Copyright (C) 2008-10 Intel Corporation
+ *  Authors:	Vinod Koul <vinod.koul@intel.com>
+ *		Harsha Priya <priya.harsha@intel.com>
+ *		Dharageswari R <dharageswari.r@intel.com>
+ *		KP Jeeja <jeeja.kp@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  Common private declarations for SST
+ */
+#ifndef __SST_H__
+#define __SST_H__
+
+#include <linux/dmaengine.h>
+#include <linux/pm_runtime.h>
+#include <linux/firmware.h>
+#include <linux/intel_mid_dma.h>
+#include <linux/lnw_gpio.h>
+#include <asm/platform_sst.h>
+#include <sound/intel_sst_ioctl.h>
+
+#define SST_DRIVER_VERSION "3.0.8"
+
+/* driver names */
+#define SST_DRV_NAME "intel_sst_driver"
+#define SST_CLV_PCI_ID	0x08E7
+#define SST_MRFLD_PCI_ID 0x119A
+#define SST_BYT_PCI_ID  0x0F28
+#define SST_CHT_PCI_ID 0x22A8
+
+#define SST_SUSPEND_DELAY 2000
+#define FW_CONTEXT_MEM (64*1024)
+#define SST_ICCM_BOUNDARY 4
+#define SST_CONFIG_SSP_SIGN 0x7ffe8001
+
+/* FIXME: All this info should come from platform data
+ * move this when the base framework is ready to pass
+ * platform data to SST driver
+ */
+#define MRFLD_FW_VIRTUAL_BASE 0xC0000000
+#define MRFLD_FW_DDR_BASE_OFFSET 0x0
+#define MRFLD_FW_FEATURE_BASE_OFFSET 0x4
+#define MRFLD_FW_BSS_RESET_BIT 0
+extern struct intel_sst_drv *sst_drv_ctx;
+enum sst_states {
+	SST_FW_LOADED = 1,
+	SST_FW_RUNNING,
+	SST_START_INIT,
+	SST_UN_INIT,
+	SST_ERROR,
+	SST_SUSPENDED,
+	SST_FW_CTXT_RESTORE,
+	SST_SHUTDOWN,
+	SST_FW_LIB_LOAD,
+};
+
+enum sst_algo_ops {
+	SST_SET_ALGO = 0,
+	SST_GET_ALGO = 1,
+};
+
+#define SST_BLOCK_TIMEOUT	1000
+
+/* SST register map */
+#define SST_CSR			0x00
+#define SST_PISR		0x08
+#define SST_PIMR		0x10
+#define SST_ISRX		0x18
+#define SST_ISRD		0x20
+#define SST_IMRX		0x28
+#define SST_IMRD		0x30
+#define SST_IPCX		0x38 /* IPC IA-SST */
+#define SST_IPCD		0x40 /* IPC SST-IA */
+#define SST_ISRSC		0x48
+#define SST_ISRLPESC		0x50
+#define SST_IMRSC		0x58
+#define SST_IMRLPESC		0x60
+#define SST_IPCSC		0x68
+#define SST_IPCLPESC		0x70
+#define SST_CLKCTL		0x78
+#define SST_CSR2		0x80
+
+#define SST_SHIM_BEGIN		SST_CSR
+#define SST_SHIM_END		SST_CSR2
+#define SST_SHIM_SIZE		0x88
+
+#define FW_SIGNATURE_SIZE	4
+
+/* stream states */
+enum sst_stream_states {
+	STREAM_UN_INIT	= 0,	/* Freed/Not used stream */
+	STREAM_RUNNING	= 1,	/* Running */
+	STREAM_PAUSED	= 2,	/* Paused stream */
+	STREAM_DECODE	= 3,	/* stream is in decoding only state */
+	STREAM_INIT	= 4,	/* stream init, waiting for data */
+	STREAM_RESET	= 5,	/* force reset on recovery */
+};
+
+enum sst_ram_type {
+	SST_IRAM	= 1,
+	SST_DRAM	= 2,
+};
+
+/* SST shim registers to structure mapping  */
+union config_status_reg {
+	struct {
+		u32 mfld_strb:1;
+		u32 sst_reset:1;
+		u32 clk_sel:3;
+		u32 sst_clk:2;
+		u32 bypass:3;
+		u32 run_stall:1;
+		u32 rsvd1:2;
+		u32 strb_cntr_rst:1;
+		u32 rsvd:18;
+	} part;
+	u32 full;
+};
+
+union interrupt_reg {
+	struct {
+		u64 done_interrupt:1;
+		u64 busy_interrupt:1;
+		u64 rsvd:62;
+	} part;
+	u64 full;
+};
+
+union sst_imr_reg {
+	struct {
+		u32 done_interrupt:1;
+		u32 busy_interrupt:1;
+		u32 rsvd:30;
+	} part;
+	u32 full;
+};
+
+union sst_pisr_reg {
+	struct {
+		u32 pssp0:1;
+		u32 pssp1:1;
+		u32 rsvd0:3;
+		u32 dmac:1;
+		u32 rsvd1:26;
+	} part;
+	u32 full;
+};
+
+union sst_pimr_reg {
+	struct {
+		u32 ssp0:1;
+		u32 ssp1:1;
+		u32 rsvd0:3;
+		u32 dmac:1;
+		u32 rsvd1:10;
+		u32 ssp0_sc:1;
+		u32 ssp1_sc:1;
+		u32 rsvd2:3;
+		u32 dmac_sc:1;
+		u32 rsvd3:10;
+	} part;
+	u32 full;
+};
+
+union config_status_reg_mrfld {
+	struct {
+		u64 lpe_reset:1;
+		u64 lpe_reset_vector:1;
+		u64 runstall:1;
+		u64 pwaitmode:1;
+		u64 clk_sel:3;
+		u64 rsvd2:1;
+		u64 sst_clk:3;
+		u64 xt_snoop:1;
+		u64 rsvd3:4;
+		u64 clk_sel1:6;
+		u64 clk_enable:3;
+		u64 rsvd4:6;
+		u64 slim0baseclk:1;
+		u64 rsvd:32;
+	} part;
+	u64 full;
+};
+
+union interrupt_reg_mrfld {
+	struct {
+		u64 done_interrupt:1;
+		u64 busy_interrupt:1;
+		u64 rsvd:62;
+	} part;
+	u64 full;
+};
+
+union sst_imr_reg_mrfld {
+	struct {
+		u64 done_interrupt:1;
+		u64 busy_interrupt:1;
+		u64 rsvd:62;
+	} part;
+	u64 full;
+};
+
+/*This structure is used to block a user/fw data call to another
+fw/user call
+*/
+struct sst_block {
+	bool	condition; /* condition for blocking check */
+	int	ret_code; /* ret code when block is released */
+	void	*data; /* data to be appsed for block if any */
+	u32     size;
+	bool	on;
+	u32     msg_id;  /*msg_id = msgid in mfld/ctp, mrfld = 0 */
+	u32     drv_id; /* = str_id in mfld/ctp, = drv_id in mrfld*/
+	struct list_head node;
+};
+
+/**
+ * struct stream_info - structure that holds the stream information
+ *
+ * @status : stream current state
+ * @prev : stream prev state
+ * @ops : stream operation pb/cp/drm...
+ * @bufs: stream buffer list
+ * @lock : stream mutex for protecting state
+ * @pcm_substream : PCM substream
+ * @period_elapsed : PCM period elapsed callback
+ * @sfreq : stream sampling freq
+ * @str_type : stream type
+ * @cumm_bytes : cummulative bytes decoded
+ * @str_type : stream type
+ * @src : stream source
+ * @device : output device type (medfield only)
+ */
+struct stream_info {
+	unsigned int		status;
+	unsigned int		prev;
+	unsigned int		ops;
+	struct mutex		lock; /* mutex */
+	void			*pcm_substream;
+	void (*period_elapsed)	(void *pcm_substream);
+	unsigned int		sfreq;
+	u32			cumm_bytes;
+	void			*compr_cb_param;
+	void (*compr_cb)	(void *compr_cb_param);
+	void			*drain_cb_param;
+	void (*drain_notify)	(void *drain_cb_param);
+
+	unsigned int		num_ch;
+	unsigned int		pipe_id;
+	unsigned int		str_id;
+	unsigned int		task_id;
+};
+
+#define SST_FW_SIGN "$SST"
+#define SST_FW_LIB_SIGN "$LIB"
+
+/*
+ * struct fw_header - FW file headers
+ *
+ * @signature : FW signature
+ * @modules : # of modules
+ * @file_format : version of header format
+ * @reserved : reserved fields
+ */
+struct fw_header {
+	unsigned char signature[FW_SIGNATURE_SIZE]; /* FW signature */
+	u32 file_size; /* size of fw minus this header */
+	u32 modules; /*  # of modules */
+	u32 file_format; /* version of header format */
+	u32 reserved[4];
+};
+
+struct fw_module_header {
+	unsigned char signature[FW_SIGNATURE_SIZE]; /* module signature */
+	u32 mod_size; /* size of module */
+	u32 blocks; /* # of blocks */
+	u32 type; /* codec type, pp lib */
+	u32 entry_point;
+};
+
+struct fw_block_info {
+	enum sst_ram_type	type;	/* IRAM/DRAM */
+	u32			size;	/* Bytes */
+	u32			ram_offset; /* Offset in I/DRAM */
+	u32			rsvd;	/* Reserved field */
+};
+
+struct sst_ipc_msg_wq {
+	union ipc_header_mrfld mrfld_header;
+	struct ipc_dsp_hdr dsp_hdr;
+	char mailbox[SST_MAILBOX_SIZE];
+	struct work_struct	wq;
+	union ipc_header header;
+};
+
+struct sst_dma {
+	struct dma_chan *ch;
+	struct intel_mid_dma_slave slave;
+	struct device *dev;
+};
+
+struct sst_runtime_param {
+	struct snd_sst_runtime_params param;
+};
+
+struct sst_sg_list {
+	struct scatterlist *src;
+	struct scatterlist *dst;
+	int list_len;
+	unsigned int sg_idx;
+};
+
+struct sst_memcpy_list {
+	struct list_head memcpylist;
+	void *dstn;
+	const void *src;
+	u32 size;
+	bool is_io;
+};
+
+struct sst_debugfs {
+#ifdef CONFIG_DEBUG_FS
+	struct dentry		*root;
+#endif
+	int			runtime_pm_status;
+	void __iomem            *ssp[SST_MAX_SSP_PORTS];
+	void __iomem            *dma_reg[SST_MAX_DMA];
+	unsigned char get_params_data[1024];
+	ssize_t get_params_len;
+};
+
+struct lpe_log_buf_hdr {
+	u32 base_addr;
+	u32 end_addr;
+	u32 rd_addr;
+	u32 wr_addr;
+};
+
+struct snd_ssp_config {
+	int size;
+	char bytes[0];
+};
+
+struct snd_sst_probe_bytes {
+	u16 len;
+	char bytes[0];
+};
+
+#define PCI_DMAC_CLV_ID 0x08F0
+#define PCI_DMAC_MRFLD_ID 0x119B
+
+struct sst_ram_buf {
+	u32 size;
+	char *buf;
+};
+
+/* Firmware Module Information*/
+
+enum sst_lib_dwnld_status {
+	SST_LIB_NOT_FOUND = 0,
+	SST_LIB_FOUND,
+	SST_LIB_DOWNLOADED,
+};
+
+struct sst_module_info {
+	const char *name; /* Library name */
+	u32	id; /* Module ID */
+	u32	entry_pt; /* Module entry point */
+	u8	status; /* module status*/
+	u8	rsvd1;
+	u16	rsvd2;
+};
+
+/* Structure for managing the Library Region(1.5MB)
+ * in DDR in Merrifield
+ */
+struct sst_mem_mgr {
+	phys_addr_t current_base;
+	int avail;
+	unsigned int count;
+};
+
+struct sst_dump_buf {
+	/* buffers for iram-dram dump crash */
+	struct sst_ram_buf iram_buf;
+	struct sst_ram_buf dram_buf;
+};
+
+struct sst_ipc_reg {
+	int ipcx;
+	int ipcd;
+};
+
+struct sst_shim_regs64 {
+	u64 csr;
+	u64 pisr;
+	u64 pimr;
+	u64 isrx;
+	u64 isrd;
+	u64 imrx;
+	u64 imrd;
+	u64 ipcx;
+	u64 ipcd;
+	u64 isrsc;
+	u64 isrlpesc;
+	u64 imrsc;
+	u64 imrlpesc;
+	u64 ipcsc;
+	u64 ipclpesc;
+	u64 clkctl;
+	u64 csr2;
+};
+
+struct sst_vtsv_cache {
+	void *file1_in_mem;
+	u32 size1;
+	void *file2_in_mem;
+	u32 size2;
+};
+
+/***
+ *
+ * struct intel_sst_drv - driver ops
+ *
+ * @sst_state : current sst device state
+ * @pci_id : PCI device id loaded
+ * @shim : SST shim pointer
+ * @mailbox : SST mailbox pointer
+ * @iram : SST IRAM pointer
+ * @dram : SST DRAM pointer
+ * @pdata : SST info passed as a part of pci platform data
+ * @shim_phy_add : SST shim phy addr
+ * @shim_regs64: Struct to save shim registers
+ * @ipc_dispatch_list : ipc messages dispatched
+ * @rx_list : to copy the process_reply/process_msg from DSP
+ * @ipc_post_msg_wq : wq to post IPC messages context
+ * @ipc_post_msg : wq to post reply from FW context
+ * @mad_ops : MAD driver operations registered
+ * @mad_wq : MAD driver wq
+ * @post_msg_wq : wq to post IPC messages
+ * @streams : sst stream contexts
+ * @list_lock : sst driver list lock (deprecated)
+ * @ipc_spin_lock : spin lock to handle audio shim access and ipc queue
+ * @rx_msg_lock : spin lock to handle the rx messages from the DSP
+ * @scard_ops : sst card ops
+ * @pci : sst pci device struture
+ * @dev : pointer to current device struct
+ * @sst_lock : sst device lock
+ * @stream_lock : sst stream lock
+ * @pvt_id : sst private id
+ * @stream_cnt : total sst active stream count
+ * @pb_streams : total active pb streams
+ * @cp_streams : total active cp streams
+ * @audio_start : audio status
+ * @qos		: PM Qos struct
+ * firmware_name : Firmware / Library name
+ */
+struct intel_sst_drv {
+	int			sst_state;
+	int			irq_num;
+	unsigned int		pci_id;
+	bool			use_32bit_ops;
+	void __iomem		*ddr;
+	void __iomem		*shim;
+	void __iomem		*mailbox;
+	void __iomem		*iram;
+	void __iomem		*dram;
+	unsigned int		mailbox_add;
+	unsigned int		iram_base;
+	unsigned int		dram_base;
+	unsigned int		shim_phy_add;
+	unsigned int		iram_end;
+	unsigned int		dram_end;
+	unsigned int		ddr_end;
+	unsigned int		ddr_base;
+	unsigned int		mailbox_recv_offset;
+	atomic_t		pm_usage_count;
+	struct sst_shim_regs64	*shim_regs64;
+	struct list_head        block_list;
+	struct list_head	ipc_dispatch_list;
+	struct sst_platform_info *pdata;
+	struct sst_ipc_msg_wq   ipc_post_msg;
+	struct list_head	rx_list;
+	struct work_struct      ipc_post_msg_wq;
+	wait_queue_head_t	wait_queue;
+	struct workqueue_struct *mad_wq;
+	struct workqueue_struct *post_msg_wq;
+	unsigned int		tstamp;
+	struct stream_info	streams[MAX_NUM_STREAMS+1]; /*str_id 0 is not used*/
+	spinlock_t		ipc_spin_lock; /* lock for Shim reg access and ipc queue */
+	spinlock_t              block_lock; /* lock for adding block to block_list */
+	spinlock_t              pvt_id_lock; /* lock for allocating private id */
+	spinlock_t		rx_msg_lock;
+	struct pci_dev		*pci;
+	struct device		*dev;
+	unsigned int		pvt_id;
+	struct mutex            sst_lock;
+	struct mutex		stream_lock;
+	unsigned int		stream_cnt;
+	unsigned int		*fw_cntx;
+	unsigned int		fw_cntx_size;
+	unsigned int		csr_value;
+	struct sst_dma		dma;
+	void			*fw_in_mem;
+	struct sst_runtime_param runtime_param;
+	unsigned int		device_input_mixer;
+	struct mutex		mixer_ctrl_lock;
+	struct dma_async_tx_descriptor *desc;
+	struct sst_sg_list	fw_sg_list, library_list;
+	struct intel_sst_ops	*ops;
+	struct sst_debugfs	debugfs;
+	struct pm_qos_request	*qos;
+	struct sst_info	info;
+	unsigned int		use_dma;
+	unsigned int		use_lli;
+	atomic_t		fw_clear_context;
+	atomic_t		fw_clear_cache;
+	bool			lib_dwnld_reqd;
+	/* list used during FW download in memcpy mode */
+	struct list_head	memcpy_list;
+	/* list used during LIB download in memcpy mode */
+	struct list_head	libmemcpy_list;
+	/* holds the stucts of iram/dram local buffers for dump*/
+	struct sst_dump_buf	dump_buf;
+	/* Lock for CSR register change */
+	struct mutex		csr_lock;
+	/* byte control to set the probe stream */
+	struct snd_sst_probe_bytes *probe_bytes;
+	/* contains the ipc registers */
+	struct sst_ipc_reg	ipc_reg;
+	/* IMR region Library space memory manager */
+	struct sst_mem_mgr      lib_mem_mgr;
+	/* Contains the cached vtsv files*/
+	struct sst_vtsv_cache	vcache;
+	/* Pointer to device ID, now for same PCI_ID, HID will be
+	 * will be different for FDK and EDK2. This will be used
+	 * for devices where PCI or ACPI id is same but HID is
+	 * different
+	 */
+	const char *hid;
+	/* Holder for firmware name. Due to async call it needs to be
+	 * persistent till worker thread gets called
+	 */
+	char firmware_name[20];
+};
+
+extern struct intel_sst_drv *sst_drv_ctx;
+extern struct sst_platform_info byt_rvp_platform_data;
+extern struct sst_platform_info byt_ffrd8_platform_data;
+extern struct sst_platform_info cht_platform_data;
+
+/* misc definitions */
+#define FW_DWNL_ID 0xFF
+
+struct sst_fill_config {
+	u32 sign;
+	struct sst_board_config_data sst_bdata;
+	struct sst_platform_config_data sst_pdata;
+	u32 shim_phy_add;
+	u32 mailbox_add;
+} __packed;
+
+struct intel_sst_ops {
+	irqreturn_t (*interrupt) (int, void *);
+	irqreturn_t (*irq_thread) (int, void *);
+	void (*clear_interrupt) (void);
+	int (*start) (void);
+	int (*reset) (void);
+	void (*process_reply) (struct ipc_post *msg);
+	void (*post_message) (struct work_struct *work);
+	int (*sync_post_message) (struct ipc_post *msg);
+	void (*process_message) (struct ipc_post *msg);
+	void (*set_bypass)(bool set);
+	int (*save_dsp_context) (struct intel_sst_drv *sst);
+	void (*restore_dsp_context) (void);
+	int (*alloc_stream) (char *params, struct sst_block *block);
+	void (*post_download)(struct intel_sst_drv *sst);
+	void (*do_recovery)(struct intel_sst_drv *sst);
+};
+
+int sst_alloc_stream(char *params, struct sst_block *block);
+int sst_pause_stream(int id);
+int sst_resume_stream(int id);
+int sst_drop_stream(int id);
+int sst_next_track(void);
+int sst_free_stream(int id);
+int sst_start_stream(int str_id);
+int sst_send_byte_stream_mrfld(void *sbytes);
+int sst_send_probe_bytes(struct intel_sst_drv *sst);
+int sst_set_stream_param(int str_id, struct snd_sst_params *str_param);
+int sst_set_metadata(int str_id, char *params);
+int sst_get_stream(struct snd_sst_params *str_param);
+int sst_get_stream_allocated(struct snd_sst_params *str_param,
+				struct snd_sst_lib_download **lib_dnld);
+int sst_drain_stream(int str_id, bool partial_drain);
+
+
+int sst_sync_post_message_mfld(struct ipc_post *msg);
+void sst_post_message_mfld(struct work_struct *work);
+void sst_process_message_mfld(struct ipc_post *msg);
+void sst_process_reply_mfld(struct ipc_post *msg);
+int sst_start_mfld(void);
+int intel_sst_reset_dsp_mfld(void);
+void intel_sst_clear_intr_mfld(void);
+void intel_sst_set_bypass_mfld(bool set);
+
+int sst_sync_post_message_mrfld(struct ipc_post *msg);
+void sst_post_message_mrfld(struct work_struct *work);
+void sst_process_message_mrfld(struct ipc_post *msg);
+void sst_process_reply_mrfld(struct ipc_post *msg);
+int sst_start_mrfld(void);
+int intel_sst_reset_dsp_mrfld(void);
+void intel_sst_clear_intr_mrfld(void);
+void sst_process_mad_ops(struct work_struct *work);
+
+long intel_sst_ioctl(struct file *file_ptr, unsigned int cmd,
+			unsigned long arg);
+int intel_sst_open_cntrl(struct inode *i_node, struct file *file_ptr);
+int intel_sst_release_cntrl(struct inode *i_node, struct file *file_ptr);
+
+int sst_load_fw(void);
+int sst_load_library(struct snd_sst_lib_download *lib, u8 ops);
+int sst_load_all_modules_elf(struct intel_sst_drv *ctx,
+		struct sst_module_info *mod_table, int mod_table_size);
+int sst_get_next_lib_mem(struct sst_mem_mgr *mgr, int size,
+			unsigned long *lib_base);
+void sst_post_download_ctp(struct intel_sst_drv *ctx);
+void sst_post_download_mrfld(struct intel_sst_drv *ctx);
+void sst_post_download_byt(struct intel_sst_drv *ctx);
+int sst_get_block_stream(struct intel_sst_drv *sst_drv_ctx);
+void sst_memcpy_free_resources(void);
+
+int sst_wait_interruptible(struct intel_sst_drv *sst_drv_ctx,
+				struct sst_block *block);
+int sst_wait_timeout(struct intel_sst_drv *sst_drv_ctx,
+			struct sst_block *block);
+int sst_create_ipc_msg(struct ipc_post **arg, bool large);
+int sst_download_fw(void);
+int free_stream_context(unsigned int str_id);
+void sst_clean_stream(struct stream_info *stream);
+int intel_sst_register_compress(struct intel_sst_drv *sst);
+int intel_sst_remove_compress(struct intel_sst_drv *sst);
+void sst_cdev_fragment_elapsed(int str_id);
+int sst_send_sync_msg(int ipc, int str_id);
+int sst_get_num_channel(struct snd_sst_params *str_param);
+int sst_get_sfreq(struct snd_sst_params *str_param);
+int intel_sst_check_device(void);
+int sst_alloc_stream_ctp(char *params, struct sst_block *block);
+int sst_alloc_stream_mrfld(char *params, struct sst_block *block);
+void sst_restore_fw_context(void);
+struct sst_block *sst_create_block(struct intel_sst_drv *ctx,
+				u32 msg_id, u32 drv_id);
+int sst_create_block_and_ipc_msg(struct ipc_post **arg, bool large,
+		struct intel_sst_drv *sst_drv_ctx, struct sst_block **block,
+		u32 msg_id, u32 drv_id);
+int sst_free_block(struct intel_sst_drv *ctx, struct sst_block *freed);
+int sst_wake_up_block(struct intel_sst_drv *ctx, int result,
+		u32 drv_id, u32 ipc, void *data, u32 size);
+int sst_alloc_drv_context(struct device *dev);
+int sst_request_firmware_async(struct intel_sst_drv *ctx);
+int sst_driver_ops(struct intel_sst_drv *sst);
+struct sst_platform_info *sst_get_acpi_driver_data(const char *hid);
+int sst_acpi_probe(struct platform_device *pdev);
+int sst_acpi_remove(struct platform_device *pdev);
+void sst_save_shim64(struct intel_sst_drv *ctx, void __iomem *shim,
+		     struct sst_shim_regs64 *shim_regs);
+void sst_firmware_load_cb(const struct firmware *fw, void *context);
+int sst_send_vtsv_data_to_fw(struct intel_sst_drv *ctx);
+
+void sst_do_recovery_mrfld(struct intel_sst_drv *sst);
+void sst_do_recovery(struct intel_sst_drv *sst);
+long intel_sst_ioctl_dsp(unsigned int cmd,
+		struct snd_ppp_params *algo_params, unsigned long arg);
+
+void sst_dump_to_buffer(const void *from, size_t from_len, char *buf);
+
+extern int intel_scu_ipc_simple_command(int, int);
+
+static inline int sst_pm_runtime_put(struct intel_sst_drv *sst_drv)
+{
+	int ret;
+
+	ret = pm_runtime_put_sync(sst_drv->dev);
+	if (ret < 0)
+		return ret;
+	atomic_dec(&sst_drv->pm_usage_count);
+
+	pr_debug("%s: count is %d now..\n", __func__,
+			atomic_read(&sst_drv->pm_usage_count));
+	return 0;
+}
+/*
+ * sst_fill_header - inline to fill sst header
+ *
+ * @header : ipc header
+ * @msg : IPC message to be sent
+ * @large : is ipc large msg
+ * @str_id : stream id
+ *
+ * this function is an inline function that sets the headers before
+ * sending a message
+ */
+static inline void sst_fill_header(union ipc_header *header,
+				int msg, int large, int str_id)
+{
+	header->part.msg_id = msg;
+	header->part.str_id = str_id;
+	header->part.large = large;
+	header->part.done = 0;
+	header->part.busy = 1;
+	header->part.data = 0;
+}
+
+
+static inline void sst_fill_header_mrfld(union ipc_header_mrfld *header,
+				int msg, int task_id, int large, int drv_id)
+{
+	header->full = 0;
+	header->p.header_high.part.msg_id = msg;
+	header->p.header_high.part.task_id = task_id;
+	header->p.header_high.part.large = large;
+	header->p.header_high.part.drv_id = drv_id;
+	header->p.header_high.part.done = 0;
+	header->p.header_high.part.busy = 1;
+	header->p.header_high.part.res_rqd = 1;
+}
+
+static inline void sst_fill_header_dsp(struct ipc_dsp_hdr *dsp, int msg,
+					int pipe_id, int len)
+{
+	dsp->cmd_id = msg;
+	dsp->mod_index_id = 0xff;
+	dsp->pipe_id = pipe_id;
+	dsp->length = len;
+	dsp->mod_id = 0;
+}
+
+#define MAX_BLOCKS 15
+/* sst_assign_pvt_id - assign a pvt id for stream
+ *
+ * @sst_drv_ctx : driver context
+ *
+ * this inline function assigns a private id for calls that dont have stream
+ * context yet, should be called with lock held
+ */
+static inline unsigned int sst_assign_pvt_id(struct intel_sst_drv *sst_drv_ctx)
+{
+	unsigned int local;
+
+	spin_lock(&sst_drv_ctx->pvt_id_lock);
+	sst_drv_ctx->pvt_id++;
+	if (sst_drv_ctx->pvt_id > MAX_BLOCKS)
+		sst_drv_ctx->pvt_id = 1;
+	local = sst_drv_ctx->pvt_id;
+	spin_unlock(&sst_drv_ctx->pvt_id_lock);
+	return local;
+}
+
+
+/*
+ * sst_init_stream - this function initialzes stream context
+ *
+ * @stream : stream struture
+ * @codec : codec for stream
+ * @sst_id : stream id
+ * @ops : stream operation
+ * @slot : stream pcm slot
+ * @device : device type
+ *
+ * this inline function initialzes stream context for allocated stream
+ */
+static inline void sst_init_stream(struct stream_info *stream,
+		int codec, int sst_id, int ops, u8 slot)
+{
+	stream->status = STREAM_INIT;
+	stream->prev = STREAM_UN_INIT;
+	stream->ops = ops;
+}
+
+static inline void sst_set_gpio_conf(const struct sst_gpio_config *gpio_conf)
+{
+	intel_mid_gpio_set_alt(gpio_conf->i2s_rx_alt, gpio_conf->alt_function);
+	intel_mid_gpio_set_alt(gpio_conf->i2s_tx_alt, gpio_conf->alt_function);
+	intel_mid_gpio_set_alt(gpio_conf->i2s_frame, gpio_conf->alt_function);
+	intel_mid_gpio_set_alt(gpio_conf->i2s_clock, gpio_conf->alt_function);
+}
+
+
+/*
+ * sst_validate_strid - this function validates the stream id
+ *
+ * @str_id : stream id to be validated
+ *
+ * returns 0 if valid stream
+ */
+static inline int sst_validate_strid(int str_id)
+{
+	if (str_id <= 0 || str_id > sst_drv_ctx->info.max_streams) {
+		pr_err("SST ERR: invalid stream id : %d, max %d\n",
+					str_id, sst_drv_ctx->info.max_streams);
+		return -EINVAL;
+	} else
+		return 0;
+}
+
+static inline int sst_shim_write(void __iomem *addr, int offset, int value)
+{
+	writel(value, addr + offset);
+	return 0;
+}
+
+static inline u32 sst_shim_read(void __iomem *addr, int offset)
+{
+
+	return readl(addr + offset);
+}
+
+static inline u32 sst_reg_read(void __iomem *addr, int offset)
+{
+
+	return readl(addr + offset);
+}
+
+static inline u64 sst_reg_read64(void __iomem *addr, int offset)
+{
+	u64 val = 0;
+
+	memcpy_fromio(&val, addr + offset, sizeof(val));
+
+	return val;
+}
+
+static inline int sst_shim_write64(void __iomem *addr, int offset, u64 value)
+{
+	memcpy_toio(addr + offset, &value, sizeof(value));
+	return 0;
+}
+
+static inline u64 sst_shim_read64(void __iomem *addr, int offset)
+{
+	u64 val = 0;
+
+	memcpy_fromio(&val, addr + offset, sizeof(val));
+	return val;
+}
+
+static inline void
+sst_set_fw_state_locked(struct intel_sst_drv *sst_drv_ctx, int sst_state)
+{
+	mutex_lock(&sst_drv_ctx->sst_lock);
+	sst_drv_ctx->sst_state = sst_state;
+	mutex_unlock(&sst_drv_ctx->sst_lock);
+}
+
+static inline struct stream_info *get_stream_info(int str_id)
+{
+	if (sst_validate_strid(str_id))
+		return NULL;
+	return &sst_drv_ctx->streams[str_id];
+}
+
+static inline int get_stream_id_mrfld(u32 pipe_id)
+{
+	int i;
+
+	for (i = 1; i <= sst_drv_ctx->info.max_streams; i++)
+		if (pipe_id == sst_drv_ctx->streams[i].pipe_id)
+			return i;
+
+	pr_debug("%s: no such pipe_id(%u)", __func__, pipe_id);
+	return -1;
+}
+
+int register_sst(struct device *);
+int unregister_sst(struct device *);
+
+#ifdef CONFIG_DEBUG_FS
+void sst_debugfs_init(struct intel_sst_drv *sst);
+void sst_debugfs_exit(struct intel_sst_drv *sst);
+#else
+static inline void sst_debugfs_init(struct intel_sst_drv *sst)
+{
+}
+
+static inline void sst_debugfs_exit(struct intel_sst_drv *sst)
+{
+}
+#endif /* CONFIG_DEBUG_FS */
+
+/*
+ * FW should use virtual address 0xC000_0000 to map to the DDR
+ * reserved 2MB region at 512MB boundary. Currently the address of
+ * DDR region allocated by IA FW is not 512MB aligned. So FW is
+ * statically linking the DDR region at 0xDF600000. So we need to
+ * use the translated address to identify the DDR regions in the FW
+ * ELF binary.
+ */
+static inline u32 relocate_imr_addr_mrfld(u32 base_addr)
+{
+	/* Get the difference from 512MB aligned base addr */
+	/* relocate the base */
+	base_addr = MRFLD_FW_VIRTUAL_BASE + (base_addr % (512 * 1024 * 1024));
+	return base_addr;
+}
+
+static inline void sst_add_to_dispatch_list_and_post(struct intel_sst_drv *sst,
+						struct ipc_post *msg)
+{
+	unsigned long irq_flags;
+	spin_lock_irqsave(&sst->ipc_spin_lock, irq_flags);
+	list_add_tail(&msg->node, &sst->ipc_dispatch_list);
+	spin_unlock_irqrestore(&sst->ipc_spin_lock, irq_flags);
+	sst->ops->post_message(&sst->ipc_post_msg_wq);
+}
+#endif
diff --git a/sound/soc/intel/sst/sst_acpi.c b/sound/soc/intel/sst/sst_acpi.c
new file mode 100644
index 0000000..c8c0ae9
--- /dev/null
+++ b/sound/soc/intel/sst/sst_acpi.c
@@ -0,0 +1,661 @@
+/* sst_acpi.c - SST (LPE) driver init file for ACPI enumeration.
+ *
+ * Copyright (c) 2013, Intel Corporation.
+ *
+ *  Authors:	Ramesh Babu K V <Ramesh.Babu@intel.com>
+ *  Authors:	Omair Mohammed Abdullah <omair.m.abdullah@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <linux/firmware.h>
+#include <linux/pm_runtime.h>
+#include <linux/pm_qos.h>
+#include <asm/platform_byt_audio.h>
+#include <asm/platform_sst.h>
+#include <acpi/acpi_bus.h>
+#include <sound/intel_sst_ioctl.h>
+#include "../sst_platform.h"
+#include "../platform_ipc_v2.h"
+#include "sst.h"
+#include <linux/acpi.h>
+
+extern struct miscdevice lpe_ctrl;
+
+static const struct sst_platform_config_data sst_byt_pdata = {
+	.sst_sram_buff_base	= 0xffffffff,
+	.sst_dma_base[0]	= SST_BYT_DMA0_PHY_ADDR,
+	.sst_dma_base[1]	= SST_BYT_DMA1_PHY_ADDR,
+};
+
+/* use array[0] for ssp_platform_data even though SSP2 is used */
+static const struct sst_board_config_data sst_byt_rvp_bdata = {
+	.active_ssp_ports = 1,
+	.platform_id = 3,
+	.board_id = 1,
+	.ihf_num_chan = 2,
+	.osc_clk_freq = 25000000,
+	.ssp_platform_data = {
+		[0] = {
+			.ssp_cfg_sst = 1,
+			.port_number = 2,
+			.is_master = 1,
+			.pack_mode = 1,
+			.num_slots_per_frame = 2,
+			.num_bits_per_slot = 24,
+			.active_tx_map = 3,
+			.active_rx_map = 3,
+			.ssp_frame_format = 3,
+			.frame_polarity = 1,
+			.serial_bitrate_clk_mode = 0,
+			.frame_sync_width = 24,
+			.dma_handshake_interface_tx = 5,
+			.dma_handshake_interface_rx = 4,
+			.network_mode = 0,
+			.start_delay = 1,
+			.ssp_base_add = SST_BYT_SSP2_PHY_ADDR,
+		},
+	},
+};
+
+static const struct sst_board_config_data sst_byt_ffrd8_bdata = {
+	.active_ssp_ports = 1,
+	.platform_id = 3,
+	.board_id = 1,
+	.ihf_num_chan = 2,
+	.osc_clk_freq = 25000000,
+	.ssp_platform_data = {
+		[0] = {
+			.ssp_cfg_sst = 1,
+			.port_number = 0,
+			.is_master = 1,
+			.pack_mode = 1,
+			.num_slots_per_frame = 2,
+			.num_bits_per_slot = 24,
+			.active_tx_map = 3,
+			.active_rx_map = 3,
+			.ssp_frame_format = 3,
+			.frame_polarity = 1,
+			.serial_bitrate_clk_mode = 0,
+			.frame_sync_width = 24,
+			.dma_handshake_interface_tx = 1,
+			.dma_handshake_interface_rx = 0,
+			.network_mode = 0,
+			.start_delay = 1,
+			.ssp_base_add = SST_BYT_SSP0_PHY_ADDR,
+		},
+	},
+};
+
+static const struct sst_board_config_data sst_byt_crv2_bdata = {
+	.active_ssp_ports = 1,
+	.platform_id = 3,
+	.board_id = 1,
+	.ihf_num_chan = 1,
+	.osc_clk_freq = 25000000,
+	.ssp_platform_data = {
+		[0] = {
+			.ssp_cfg_sst = 1,
+			.port_number = 0,
+			.is_master = 1,
+			.pack_mode = 1,
+			.num_slots_per_frame = 2,
+			.num_bits_per_slot = 24,
+			.active_tx_map = 3,
+			.active_rx_map = 3,
+			.ssp_frame_format = 3,
+			.frame_polarity = 1,
+			.serial_bitrate_clk_mode = 0,
+			.frame_sync_width = 24,
+			.dma_handshake_interface_tx = 1,
+			.dma_handshake_interface_rx = 0,
+			.network_mode = 0,
+			.start_delay = 1,
+			.ssp_base_add = SST_BYT_SSP0_PHY_ADDR,
+		},
+	},
+};
+
+static const struct sst_info byt_fwparse_info = {
+	.use_elf	= true,
+	.max_streams	= 4,
+	.dma_max_len	= SST_MAX_DMA_LEN_MRFLD,
+	.iram_start	= SST_BYT_IRAM_PHY_START,
+	.iram_end	= SST_BYT_IRAM_PHY_END,
+	.iram_use	= true,
+	.dram_start	= SST_BYT_DRAM_PHY_START,
+	.dram_end	= SST_BYT_DRAM_PHY_END,
+	.dram_use	= true,
+	.imr_start	= SST_BYT_IMR_VIRT_START,
+	.imr_end	= SST_BYT_IMR_VIRT_END,
+	.imr_use	= true,
+	.mailbox_start	= SST_BYT_MBOX_PHY_ADDR,
+	.num_probes	= 0,
+	.lpe_viewpt_rqd  = true,
+};
+
+
+static const struct sst_info cht_fwparse_info = {
+	.use_elf	= true,
+	.max_streams	= MAX_NUM_STREAMS_MRFLD,
+	.dma_max_len	= SST_MAX_DMA_LEN_MRFLD,
+	.iram_start	= SST_BYT_IRAM_PHY_START,
+	.iram_end	= SST_BYT_IRAM_PHY_END,
+	.iram_use	= true,
+	.dram_start	= SST_BYT_DRAM_PHY_START,
+	.dram_end	= SST_BYT_DRAM_PHY_END,
+	.dram_use	= true,
+	.imr_start	= SST_BYT_IMR_VIRT_START,
+	.imr_end	= SST_BYT_IMR_VIRT_END,
+	.imr_use	= true,
+	.mailbox_start	= SST_BYT_MBOX_PHY_ADDR,
+	.num_probes	= 0,
+	.lpe_viewpt_rqd = true,
+};
+
+static const struct sst_ipc_info byt_ipc_info = {
+	.use_32bit_ops = true,
+	.ipc_offset = 4,
+	.mbox_recv_off = 0x400,
+};
+
+static const struct sst_lib_dnld_info  byt_lib_dnld_info = {
+	.mod_base           = SST_BYT_IMR_VIRT_START,
+	.mod_end            = SST_BYT_IMR_VIRT_END,
+	.mod_table_offset   = BYT_FW_MOD_TABLE_OFFSET,
+	.mod_table_size     = BYT_FW_MOD_TABLE_SIZE,
+	.mod_ddr_dnld       = true,
+};
+
+static const struct sst_ipc_info cht_ipc_info = {
+	.use_32bit_ops = false,
+	.ipc_offset = 0,
+	.mbox_recv_off = 0x400,
+};
+
+struct sst_platform_info cht_platform_data = {
+	.probe_data = &cht_fwparse_info,
+	.ssp_data = NULL,
+	.bdata = NULL,
+	.pdata = NULL,
+	.ipc_info = &cht_ipc_info,
+	.lib_info = NULL,
+};
+
+struct sst_platform_info byt_rvp_platform_data = {
+	.probe_data = &byt_fwparse_info,
+	.ssp_data = NULL,
+	.bdata = &sst_byt_rvp_bdata,
+	.pdata = &sst_byt_pdata,
+	.ipc_info = &byt_ipc_info,
+	.lib_info = &byt_lib_dnld_info,
+};
+
+struct sst_platform_info byt_ffrd8_platform_data = {
+	.probe_data = &byt_fwparse_info,
+	.ssp_data = NULL,
+	.bdata = &sst_byt_ffrd8_bdata,
+	.pdata = &sst_byt_pdata,
+	.ipc_info = &byt_ipc_info,
+	.lib_info = &byt_lib_dnld_info,
+};
+
+int sst_workqueue_init(struct intel_sst_drv *ctx)
+{
+	pr_debug("%s", __func__);
+
+	INIT_LIST_HEAD(&ctx->memcpy_list);
+	INIT_LIST_HEAD(&ctx->libmemcpy_list);
+	INIT_LIST_HEAD(&sst_drv_ctx->rx_list);
+	INIT_LIST_HEAD(&ctx->ipc_dispatch_list);
+	INIT_LIST_HEAD(&ctx->block_list);
+	INIT_WORK(&ctx->ipc_post_msg.wq, ctx->ops->post_message);
+	init_waitqueue_head(&ctx->wait_queue);
+
+	ctx->mad_wq = create_singlethread_workqueue("sst_mad_wq");
+	if (!ctx->mad_wq)
+		goto err_wq;
+	ctx->post_msg_wq =
+		create_singlethread_workqueue("sst_post_msg_wq");
+	if (!ctx->post_msg_wq)
+		goto err_wq;
+	return 0;
+err_wq:
+	return -EBUSY;
+}
+
+void sst_init_locks(struct intel_sst_drv *ctx)
+{
+	mutex_init(&ctx->stream_lock);
+	mutex_init(&ctx->sst_lock);
+	mutex_init(&ctx->mixer_ctrl_lock);
+	mutex_init(&ctx->csr_lock);
+	spin_lock_init(&sst_drv_ctx->rx_msg_lock);
+	spin_lock_init(&ctx->ipc_spin_lock);
+	spin_lock_init(&ctx->block_lock);
+	spin_lock_init(&ctx->pvt_id_lock);
+}
+
+int sst_destroy_workqueue(struct intel_sst_drv *ctx)
+{
+	pr_debug("%s", __func__);
+	if (ctx->mad_wq)
+		destroy_workqueue(ctx->mad_wq);
+	if (ctx->post_msg_wq)
+		destroy_workqueue(ctx->post_msg_wq);
+	return 0;
+}
+
+#if IS_ENABLED(CONFIG_ACPI)
+static int sst_platform_get_resources_fdk(struct intel_sst_drv *ctx,
+				      struct platform_device *pdev)
+{
+	struct resource *rsrc;
+
+	pr_debug("%s", __func__);
+
+	/* All ACPI resource request here */
+	/* Get DDR addr from platform resource table */
+	rsrc = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!rsrc) {
+		pr_err("Invalid DDR base from IFWI");
+		return -EIO;
+	}
+	ctx->ddr_base = rsrc->start;
+	ctx->ddr_end = rsrc->end;
+	pr_debug("DDR base: %#x", ctx->ddr_base);
+	ctx->ddr = devm_ioremap_nocache(ctx->dev, ctx->ddr_base,
+					resource_size(rsrc));
+	if (!ctx->ddr) {
+		pr_err("unable to map DDR");
+		return -EIO;
+	}
+
+	/* Get Shim addr from platform resource table */
+	rsrc = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!rsrc) {
+		pr_err("Invalid SHIM base from IFWI");
+		return -EIO;
+	}
+	ctx->shim_phy_add = rsrc->start;
+	pr_debug("SHIM base: %#x", ctx->shim_phy_add);
+	ctx->shim = devm_ioremap_nocache(ctx->dev, ctx->shim_phy_add,
+					 resource_size(rsrc));
+	if (!ctx->shim) {
+		pr_err("unable to map SHIM");
+		return -EIO;
+	}
+	/* reassign physical address to LPE viewpoint address */
+	ctx->shim_phy_add = SST_BYT_SHIM_PHY_ADDR;
+
+	/* Get mailbox addr from platform resource table */
+	rsrc = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	if (!rsrc) {
+		pr_err("Invalid Mailbox base from IFWI");
+		return -EIO;
+	}
+	ctx->mailbox_add = rsrc->start;
+	pr_debug("Mailbox base: %#x", ctx->mailbox_add);
+	ctx->mailbox = devm_ioremap_nocache(ctx->dev, ctx->mailbox_add,
+					    resource_size(rsrc));
+	if (!ctx->mailbox) {
+		pr_err("unable to map mailbox");
+		return -EIO;
+	}
+	/* reassign physical address to LPE viewpoint address */
+	ctx->mailbox_add = sst_drv_ctx->info.mailbox_start;
+
+	/* Get iram/iccm addr from platform resource table */
+	rsrc = platform_get_resource(pdev, IORESOURCE_MEM, 3);
+	if (!rsrc) {
+		pr_err("Invalid IRAM base from IFWI");
+		return -EIO;
+	}
+	ctx->iram_base = rsrc->start;
+	ctx->iram_end =  rsrc->end;
+	pr_debug("IRAM base: %#x", ctx->iram_base);
+	ctx->iram = devm_ioremap_nocache(ctx->dev, ctx->iram_base,
+					 resource_size(rsrc));
+	if (!ctx->iram) {
+		pr_err("unable to map IRAM");
+		return -EIO;
+	}
+
+	/* Get dram/dccm addr from platform resource table */
+	rsrc = platform_get_resource(pdev, IORESOURCE_MEM, 4);
+	if (!rsrc) {
+		pr_err("Invalid DRAM base from IFWI");
+		return -EIO;
+	}
+	ctx->dram_base = rsrc->start;
+	ctx->dram_end = rsrc->end;
+	pr_debug("DRAM base: %#x", ctx->dram_base);
+	ctx->dram = devm_ioremap_nocache(ctx->dev, ctx->dram_base,
+					 resource_size(rsrc));
+	if (!ctx->dram) {
+		pr_err("unable to map DRAM");
+		return -EIO;
+	}
+
+	/* Register the ISR */
+	ctx->irq_num = platform_get_irq(pdev, 0);
+	pr_debug("irq from pdev is:%d", ctx->irq_num);
+	return 0;
+}
+
+#define LPE_IRAM_OFFSET 0x0C0000
+#define LPE_IRAM_SIZE 0x040000
+#define LPE_DRAM_OFFSET 0x100000
+#define LPE_DRAM_SIZE 0x040000
+#define LPE_SHIM_OFFSET 0x140000
+#define LPE_SHIM_SIZE 0x004000
+#define LPE_MBOX_OFFSET 0x144000
+#define LPE_MBOX_SIZE 0x004000
+
+static int sst_platform_get_resources_edk(struct intel_sst_drv *ctx,
+				      struct platform_device *pdev)
+{
+	struct resource *rsrc;
+
+	pr_debug("%s", __func__);
+
+	/* All ACPI resource request here */
+	/* Get Shim addr */
+	rsrc = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!rsrc) {
+		pr_err("Invalid SHIM base from IFWI");
+		return -EIO;
+	}
+	pr_debug("LPE base: %#x size:%#x", (unsigned int) rsrc->start,
+					(unsigned int)resource_size(rsrc));
+	ctx->iram_base = rsrc->start + LPE_IRAM_OFFSET;
+	ctx->iram_end =  ctx->iram_base + LPE_IRAM_SIZE - 1;
+	pr_debug("IRAM base: %#x", ctx->iram_base);
+	ctx->iram = devm_ioremap_nocache(ctx->dev, ctx->iram_base,
+					 LPE_IRAM_SIZE);
+	if (!ctx->iram) {
+		pr_err("unable to map IRAM");
+		return -EIO;
+	}
+
+	ctx->dram_base = rsrc->start + LPE_DRAM_OFFSET;
+	ctx->dram_end = ctx->dram_base + LPE_DRAM_SIZE - 1;
+	pr_debug("DRAM base: %#x", ctx->dram_base);
+	ctx->dram = devm_ioremap_nocache(ctx->dev, ctx->dram_base,
+					 LPE_DRAM_SIZE);
+	if (!ctx->dram) {
+		pr_err("unable to map DRAM");
+		return -EIO;
+	}
+
+	ctx->shim_phy_add = rsrc->start + LPE_SHIM_OFFSET;
+	pr_debug("SHIM base: %#x", ctx->shim_phy_add);
+	ctx->shim = devm_ioremap_nocache(ctx->dev, ctx->shim_phy_add,
+							LPE_SHIM_SIZE);
+	if (!ctx->shim) {
+		pr_err("unable to map SHIM");
+		return -EIO;
+	}
+	/* reassign physical address to LPE viewpoint address */
+	ctx->shim_phy_add = SST_BYT_SHIM_PHY_ADDR;
+
+	/* Get mailbox addr */
+	ctx->mailbox_add = rsrc->start + LPE_MBOX_OFFSET;
+	pr_debug("Mailbox base: %#x", ctx->mailbox_add);
+	ctx->mailbox = devm_ioremap_nocache(ctx->dev, ctx->mailbox_add,
+					    LPE_MBOX_SIZE);
+	if (!ctx->mailbox) {
+		pr_err("unable to map mailbox");
+		return -EIO;
+	}
+
+	/* reassign physical address to LPE viewpoint address */
+	ctx->mailbox_add = sst_drv_ctx->info.mailbox_start;
+
+	rsrc = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	if (!rsrc) {
+		pr_err("Invalid DDR base from IFWI");
+		return -EIO;
+	}
+	ctx->ddr_base = rsrc->start;
+	ctx->ddr_end = rsrc->end;
+	pr_debug("DDR base: %#x", ctx->ddr_base);
+	ctx->ddr = devm_ioremap_nocache(ctx->dev, ctx->ddr_base,
+					resource_size(rsrc));
+	if (!ctx->ddr) {
+		pr_err("unable to map DDR");
+		return -EIO;
+	}
+	/* Register the ISR */
+	if (!strncmp(ctx->hid, "80860F28", 8))
+		ctx->irq_num = platform_get_irq(pdev, 0);
+	else if (!strncmp(ctx->hid, "808622A8", 8)) {
+		/* FIXME: IRQ number will be moved to 0 once the BIOS fix is done */
+		ctx->irq_num = platform_get_irq(pdev, 5);
+	} else
+		return -EINVAL;
+	return 0;
+}
+
+static int sst_platform_get_resources(const char *hid,
+		struct intel_sst_drv *ctx, struct platform_device *pdev)
+{
+
+	pr_debug("%s", __func__);
+
+	if (!strncmp(hid, "LPE0F281", 8)) {
+		ctx->pci_id = SST_BYT_PCI_ID;
+		return sst_platform_get_resources_fdk(ctx, pdev);
+	}
+	if (!strncmp(hid, "808622A8", 8)) {
+		ctx->pci_id = SST_CHT_PCI_ID;
+		return sst_platform_get_resources_edk(ctx, pdev);
+	}
+	if (!strncmp(hid, "80860F28", 8)) {
+		ctx->pci_id = SST_BYT_PCI_ID;
+		return sst_platform_get_resources_edk(ctx, pdev);
+	} else if (!strncmp(hid, "LPE0F28", 7)) {
+		ctx->pci_id = SST_BYT_PCI_ID;
+		return sst_platform_get_resources_fdk(ctx, pdev);
+	} else {
+		pr_err("Invalid device\n");
+		return -EINVAL;
+	}
+}
+
+int sst_acpi_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	acpi_handle handle = ACPI_HANDLE(dev);
+	struct acpi_device *device;
+	const char *hid;
+	int i, ret = 0;
+	struct intel_sst_drv *ctx;
+
+	ret = acpi_bus_get_device(handle, &device);
+	if (ret) {
+		pr_err("%s: could not get acpi device - %d\n", __func__, ret);
+		return -ENODEV;
+	}
+
+	if (acpi_bus_get_status(device) || !device->status.present) {
+		pr_err("%s: device has invalid status", __func__);
+		return -ENODEV;
+	}
+
+	hid = acpi_device_hid(device);
+	pr_debug("%s for %s", __func__, hid);
+	ret = sst_alloc_drv_context(dev);
+	if (ret)
+		return ret;
+	ctx = sst_drv_ctx;
+	ctx->dev = dev;
+	ctx->hid = hid;
+
+	ret = sst_platform_get_resources(hid, ctx, pdev);
+	if (ret)
+		return ret;
+	/* need to save shim registers in BYT */
+	ctx->shim_regs64 = devm_kzalloc(dev, sizeof(*ctx->shim_regs64),
+					GFP_KERNEL);
+	if (!ctx->shim_regs64)
+		return -ENOMEM;
+
+	ret = sst_driver_ops(ctx);
+	if (ret != 0)
+		return -EINVAL;
+
+	sst_init_locks(ctx);
+
+	ctx->stream_cnt = 0;
+	ctx->fw_in_mem = NULL;
+	ctx->use_dma = 1;
+	ctx->use_lli = 1;
+
+	if (sst_workqueue_init(ctx))
+		goto do_free_wq;
+
+	ctx->pdata = sst_get_acpi_driver_data(hid);
+	if (!ctx->pdata)
+		return -EINVAL;
+
+	ctx->use_32bit_ops = ctx->pdata->ipc_info->use_32bit_ops;
+	ctx->mailbox_recv_offset = ctx->pdata->ipc_info->mbox_recv_off;
+
+	memcpy(&ctx->info, ctx->pdata->probe_data, sizeof(ctx->info));
+
+	ctx->ipc_reg.ipcx = SST_IPCX + ctx->pdata->ipc_info->ipc_offset;
+	ctx->ipc_reg.ipcd = SST_IPCD + ctx->pdata->ipc_info->ipc_offset;
+
+	pr_debug("Got drv data max stream %d\n",
+				ctx->info.max_streams);
+	for (i = 1; i <= ctx->info.max_streams; i++) {
+		struct stream_info *stream = &ctx->streams[i];
+		mutex_init(&stream->lock);
+	}
+	ret = sst_request_firmware_async(ctx);
+	if (ret) {
+		pr_err("Firmware download failed:%d\n", ret);
+		goto do_free_wq;
+	}
+
+	ret = devm_request_threaded_irq(ctx->dev, ctx->irq_num, ctx->ops->interrupt,
+					ctx->ops->irq_thread, 0, SST_DRV_NAME,
+					ctx);
+	if (ret)
+		return ret;
+	pr_debug("Registered IRQ %#x\n", ctx->irq_num);
+
+	/*Register LPE Control as misc driver*/
+	ret = misc_register(&lpe_ctrl);
+	if (ret) {
+		pr_err("couldn't register control device\n");
+		goto do_free_wq;
+	}
+	/* mask all SSP and DMA irq to IA - enabled in acpi kernel driver */
+	sst_shim_write64(ctx->shim, SST_IMRX, 0xFFFF0038);
+
+	if (ctx->use_32bit_ops) {
+		pr_debug("allocate mem for context save/restore\n ");
+		/*allocate mem for fw context save during suspend*/
+		ctx->fw_cntx = devm_kzalloc(ctx->dev, FW_CONTEXT_MEM, GFP_KERNEL);
+		if (!ctx->fw_cntx) {
+			ret = -ENOMEM;
+			goto do_free_misc;
+		}
+		/*setting zero as that is valid mem to restore*/
+		ctx->fw_cntx_size = 0;
+	}
+
+	platform_set_drvdata(pdev, ctx);
+	pm_runtime_set_active(dev);
+	pm_runtime_enable(dev);
+	register_sst(dev);
+	sst_debugfs_init(ctx);
+	sst_set_fw_state_locked(ctx, SST_UN_INIT);
+	sst_save_shim64(ctx, ctx->shim, ctx->shim_regs64);
+	pr_info("%s successfully done!\n", __func__);
+	return ret;
+
+do_free_misc:
+	misc_deregister(&lpe_ctrl);
+do_free_wq:
+	sst_destroy_workqueue(ctx);
+
+	sst_drv_ctx = NULL;
+	platform_set_drvdata(pdev, NULL);
+	pr_err("%s: failed with %d\n", __func__, ret);
+	return ret;
+}
+
+/**
+* intel_sst_remove - remove function
+*
+* @pdev:	platform device structure
+*
+* This function is called by OS when a device is unloaded
+* This frees the interrupt etc
+*/
+int sst_acpi_remove(struct platform_device *pdev)
+{
+	struct intel_sst_drv *ctx;
+
+	ctx = platform_get_drvdata(pdev);
+	sst_debugfs_exit(ctx);
+	pm_runtime_get_noresume(ctx->dev);
+	pm_runtime_disable(ctx->dev);
+	unregister_sst(ctx->dev);
+	sst_set_fw_state_locked(ctx, SST_UN_INIT);
+	misc_deregister(&lpe_ctrl);
+	kfree(ctx->runtime_param.param.addr);
+	flush_scheduled_work();
+	sst_destroy_workqueue(ctx);
+	kfree(ctx->fw_sg_list.src);
+	kfree(ctx->fw_sg_list.dst);
+	ctx->fw_sg_list.list_len = 0;
+	kfree(ctx->fw_in_mem);
+	ctx->fw_in_mem = NULL;
+	sst_memcpy_free_resources();
+	sst_drv_ctx = NULL;
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+#else
+int sst_acpi_probe(struct platform_device *pdev)
+{
+	return -EINVAL;
+}
+
+int sst_acpi_remove(struct platform_device *pdev)
+{
+	return -EINVAL;
+}
+#endif
+
+MODULE_DESCRIPTION("Intel (R) SST(R) Audio Engine ACPI Driver");
+MODULE_AUTHOR("Ramesh Babu K V");
+MODULE_AUTHOR("Omair Mohammed Abdullah");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("sst");
diff --git a/sound/soc/intel/sst/sst_app_compat_interface.c b/sound/soc/intel/sst/sst_app_compat_interface.c
new file mode 100644
index 0000000..4babd76
--- /dev/null
+++ b/sound/soc/intel/sst/sst_app_compat_interface.c
@@ -0,0 +1,85 @@
+
+/*
+ *  sst_app_compat_interface.c - Intel SST Driver for audio engine
+ *
+ *  Copyright (C) 2013-14 Intel Corp
+ *  Authors: Subhransu S. Prusty <subhransu.s.prusty@intel.com>
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *  This driver exposes the audio engine functionalities to the ALSA
+ *	and middleware.
+ */
+
+/* This file is included from sst.c */
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/compat.h>
+#include <linux/types.h>
+#include <sound/intel_sst_ioctl.h>
+#include "sst.h"
+
+struct snd_ppp_params32 {
+	__u8			algo_id;/* Post/Pre processing algorithm ID  */
+	__u8			str_id;	/*Only 5 bits used 0 - 31 are valid*/
+	__u8			enable;	/* 0= disable, 1= enable*/
+	__u8			operation;
+	__u32			size;	/*Size of parameters for all blocks*/
+	__u32			params;
+} __packed;
+
+enum {
+SNDRV_SST_SET_ALGO32 = _IOW('L', 0x30,  struct snd_ppp_params32),
+SNDRV_SST_GET_ALGO32 = _IOWR('L', 0x31,  struct snd_ppp_params32),
+};
+
+static long sst_algo_compat(unsigned int cmd,
+				struct snd_ppp_params32 __user *arg32)
+{
+	int retval = 0;
+	struct snd_ppp_params32 algo_params32;
+	struct snd_ppp_params algo_params;
+
+	if (copy_from_user(&algo_params32, arg32, sizeof(algo_params32))) {
+		pr_debug("%s: copy from user failed: %d\n", __func__, retval);
+		return -EINVAL;
+	}
+
+	memcpy(&algo_params, &algo_params32, sizeof(algo_params32)-sizeof(__u32));
+	algo_params.params = compat_ptr(algo_params32.params);
+	retval = intel_sst_ioctl_dsp(cmd, &algo_params, (unsigned long)arg32);
+	return retval;
+}
+
+static long intel_sst_ioctl_compat(struct file *file_ptr,
+				unsigned int cmd, unsigned long arg)
+{
+	void __user *argp = compat_ptr(arg);
+
+	switch (_IOC_NR(cmd)) {
+	case _IOC_NR(SNDRV_SST_DRIVER_INFO):
+	case _IOC_NR(SNDRV_SST_TUNING_PARAMS):
+		return intel_sst_ioctl(file_ptr, cmd, (unsigned long)argp);
+	case _IOC_NR(SNDRV_SST_SET_ALGO32):
+		return sst_algo_compat(SNDRV_SST_SET_ALGO, argp);
+	case _IOC_NR(SNDRV_SST_GET_ALGO32):
+		return sst_algo_compat(SNDRV_SST_GET_ALGO, argp);
+
+	default:
+		return -ENOTTY;
+	}
+	return 0;
+}
diff --git a/sound/soc/intel/sst/sst_app_interface.c b/sound/soc/intel/sst/sst_app_interface.c
new file mode 100644
index 0000000..cfbbf4f
--- /dev/null
+++ b/sound/soc/intel/sst/sst_app_interface.c
@@ -0,0 +1,342 @@
+/*
+ *  sst_app_interface.c - Intel SST Driver for audio engine
+ *
+ *  Copyright (C) 2008-10 Intel Corp
+ *  Authors:	Vinod Koul <vinod.koul@intel.com>
+ *  Harsha Priya <priya.harsha@intel.com>
+ *  Dharageswari R <dharageswari.r@intel.com>
+ *  Jeeja KP <jeeja.kp@intel.com>
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *  This driver exposes the audio engine functionalities to the ALSA
+ *	and middleware.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/pci.h>
+#include <linux/fs.h>
+#include <linux/uio.h>
+#include <linux/aio.h>
+#include <linux/uaccess.h>
+#include <linux/firmware.h>
+#include <linux/ioctl.h>
+#include <sound/intel_sst_ioctl.h>
+#include "../sst_platform.h"
+#include "../platform_ipc_v2.h"
+#include "sst.h"
+
+#define AM_MODULE 1
+
+/**
+ * intel_sst_open_cntrl - opens a handle to driver
+ *
+ * @i_node:	inode structure
+ * @file_ptr:pointer to file
+ *
+ * This function is called by OS when a user space component
+ * tries to get a driver handle to /dev/intel_sst_control.
+ * Only one handle at a time will be allowed
+ * This is for control operations only
+ */
+int intel_sst_open_cntrl(struct inode *i_node, struct file *file_ptr)
+{
+	unsigned int retval;
+
+	/* audio manager open */
+	mutex_lock(&sst_drv_ctx->stream_lock);
+	retval = intel_sst_check_device();
+	if (retval) {
+		mutex_unlock(&sst_drv_ctx->stream_lock);
+		return retval;
+	}
+	pr_debug("AM handle opened\n");
+
+	mutex_unlock(&sst_drv_ctx->stream_lock);
+	return retval;
+}
+
+
+int intel_sst_release_cntrl(struct inode *i_node, struct file *file_ptr)
+{
+	/* audio manager close */
+	mutex_lock(&sst_drv_ctx->stream_lock);
+	sst_pm_runtime_put(sst_drv_ctx);
+	mutex_unlock(&sst_drv_ctx->stream_lock);
+	pr_debug("AM handle closed\n");
+	return 0;
+}
+
+/**
+ * sst_get_max_streams - Function to populate the drv info structure
+ *				with the max streams
+ * @info: the out params that holds the drv info
+ *
+ * This function is called when max streams count is required
+**/
+void sst_get_max_streams(struct snd_sst_driver_info *info)
+{
+	pr_debug("info.max_streams %d num_probes %d\n", sst_drv_ctx->info.max_streams,
+					sst_drv_ctx->info.num_probes);
+	info->max_streams = sst_drv_ctx->info.max_streams - sst_drv_ctx->info.num_probes;
+}
+
+/**
+ * sst_create_algo_ipc - create ipc msg for algorithm parameters
+ *
+ * @algo_params: Algorithm parameters
+ * @msg: post msg pointer
+ * @pvt_id: Checked by wake_up_block
+ *
+ * This function is called to create ipc msg
+ * For copying the mailbox data the function returns offset in bytes to mailbox
+ * memory where the mailbox data should be copied after msg header
+ */
+static int sst_create_algo_ipc(struct snd_ppp_params *algo_params,
+					struct ipc_post **msg, int pvt_id)
+{
+	u32 header_size = 0;
+	u32 ipc_msg_size = sizeof(u32) + sizeof(*algo_params)
+			 - sizeof(algo_params->params) + algo_params->size;
+	u32 offset = 0;
+
+	if (ipc_msg_size > SST_MAILBOX_SIZE)
+		return -ENOMEM;
+	if (sst_create_ipc_msg(msg, true))
+		return -ENOMEM;
+	sst_fill_header(&(*msg)->header,
+			IPC_IA_ALG_PARAMS, 1, pvt_id);
+	(*msg)->header.part.data = ipc_msg_size;
+	memcpy((*msg)->mailbox_data, &(*msg)->header, sizeof(u32));
+	offset = sizeof(u32);
+	header_size = sizeof(*algo_params) - sizeof(algo_params->params);
+	memcpy((*msg)->mailbox_data + offset, algo_params, header_size);
+	offset += header_size;
+	return offset;
+}
+
+static long sst_send_algo(struct snd_ppp_params *algo_params,
+		struct sst_block *block, enum sst_algo_ops algo)
+{
+	struct ipc_post *msg;
+	int retval;
+	int offset;
+
+	pr_debug("Algo ID %d Str id %d Enable %d Size %d\n",
+		algo_params->algo_id, algo_params->str_id,
+		algo_params->enable, algo_params->size);
+
+	algo_params->operation = algo;
+
+	offset = sst_create_algo_ipc(algo_params, &msg, block->drv_id);
+	if (offset < 0)
+		return offset;
+
+	if (copy_from_user(msg->mailbox_data + offset,
+			algo_params->params, algo_params->size)) {
+		kfree(msg);
+		return -EFAULT;
+	}
+
+	sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+	retval = sst_wait_timeout(sst_drv_ctx, block);
+	if (retval) {
+		pr_debug("%s: failed for algo ops %s with retval %d\n",
+				__func__, algo ? "SST_GET_ALGO" : "SST_SET_ALGO", retval);
+		return -EIO;
+	}
+	return 0;
+}
+
+/**
+ * intel_sst_ioctl_dsp - receives the device ioctl's
+ *
+ * @cmd:Ioctl cmd
+ * @arg:data
+ *
+ * This function is called when a user space component
+ * sends a DSP Ioctl to SST driver
+ */
+long intel_sst_ioctl_dsp(unsigned int cmd,
+		struct snd_ppp_params *algo_params, unsigned long arg)
+{
+	int retval = 0;
+	struct snd_ppp_params *algo_params_copied;
+	struct sst_block *block;
+	int pvt_id;
+
+	pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+	block = sst_create_block(sst_drv_ctx, IPC_IA_ALG_PARAMS, pvt_id);
+	if (block == NULL)
+		return -ENOMEM;
+
+	switch (_IOC_NR(cmd)) {
+	case _IOC_NR(SNDRV_SST_SET_ALGO):
+		retval = sst_send_algo(algo_params, block, SST_SET_ALGO);
+		break;
+
+	case _IOC_NR(SNDRV_SST_GET_ALGO):
+		retval = sst_send_algo(algo_params, block, SST_GET_ALGO);
+		if (retval)
+			break;
+		algo_params_copied = (struct snd_ppp_params *)block->data;
+
+		if (algo_params_copied->size > algo_params->size) {
+			pr_debug("mem insufficient to copy\n");
+			retval = -EMSGSIZE;
+			break;
+		} else {
+			char __user *tmp;
+			struct snd_ppp_params *get_params;
+			char *pp;
+
+			tmp = (char __user *)arg + offsetof(
+					struct snd_ppp_params, size);
+			if (copy_to_user(tmp, &algo_params_copied->size,
+						 sizeof(u32))) {
+				retval = -EFAULT;
+				break;
+			}
+			tmp = (char __user *)arg + offsetof(
+					struct snd_ppp_params, enable);
+			if (copy_to_user(tmp, &algo_params_copied->enable,
+						 sizeof(u8))) {
+				retval = -EFAULT;
+				break;
+			}
+			if (algo_params_copied->size == 0)
+				break;
+
+			get_params = kmalloc(sizeof(*get_params), GFP_KERNEL);
+			if (!get_params) {
+				pr_err("sst: mem alloc failed\n");
+				break;
+			}
+			memcpy(get_params, algo_params_copied,
+							sizeof(*get_params));
+
+			get_params->params = kmalloc(get_params->size, GFP_KERNEL);
+			if (!get_params->params) {
+				pr_err("sst: mem alloc failed\n");
+				goto free_mem;
+			}
+			pp = (char *)algo_params_copied;
+			pp = pp + sizeof(*get_params) -
+						sizeof(get_params->params);
+			memcpy(get_params->params, pp, get_params->size);
+			if (copy_to_user(algo_params->params,
+					get_params->params,
+					get_params->size)) {
+				retval = -EFAULT;
+			}
+			kfree(get_params->params);
+
+free_mem:
+			kfree(get_params);
+
+		}
+		break;
+	}
+	sst_free_block(sst_drv_ctx, block);
+	pr_debug("ioctl dsp return = %d, for cmd = %x\n", retval, cmd);
+	return retval;
+}
+
+static long sst_ioctl_tuning_params(unsigned int cmd, unsigned long arg)
+{
+	struct snd_sst_tuning_params params;
+	struct ipc_post *msg;
+	unsigned long address;
+
+	if (copy_from_user(&params, (void __user *)arg, sizeof(params)))
+		return -EFAULT;
+	pr_debug("sst: Parameter %d, Stream %d, Size %d\n", params.type,
+			params.str_id, params.size);
+	if (sst_create_ipc_msg(&msg, true))
+		return -ENOMEM;
+	address = (unsigned long)params.addr;
+
+	switch (_IOC_NR(cmd)) {
+	case _IOC_NR(SNDRV_SST_TUNING_PARAMS):
+		sst_fill_header(&msg->header, IPC_IA_TUNING_PARAMS, 1,
+				params.str_id);
+		break;
+	}
+	msg->header.part.data = sizeof(u32) + sizeof(params) + params.size;
+	memcpy(msg->mailbox_data, &msg->header.full, sizeof(u32));
+	memcpy(msg->mailbox_data + sizeof(u32), &params, sizeof(params));
+	/* driver doesn't need to send address, so overwrite addr with data */
+	if (copy_from_user(msg->mailbox_data + sizeof(u32)
+				+ sizeof(params) - sizeof(params.addr),
+			(void __user *)address, params.size)) {
+		kfree(msg->mailbox_data);
+		kfree(msg);
+		return -EFAULT;
+	}
+
+	sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+	return 0;
+}
+/**
+ * intel_sst_ioctl - receives the device ioctl's
+ * @file_ptr:pointer to file
+ * @cmd:Ioctl cmd
+ * @arg:data
+ *
+ * This function is called by OS when a user space component
+ * sends an Ioctl to SST driver
+ */
+long intel_sst_ioctl(struct file *file_ptr, unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+	struct snd_ppp_params algo_params;
+
+	if (sst_drv_ctx->sst_state != SST_FW_RUNNING)
+		return -EBUSY;
+
+	switch (_IOC_NR(cmd)) {
+	case _IOC_NR(SNDRV_SST_DRIVER_INFO): {
+		struct snd_sst_driver_info info;
+
+		pr_debug("SNDRV_SST_DRIVER_INFO received\n");
+		sst_get_max_streams(&info);
+
+		if (copy_to_user((void __user *)arg, &info,
+				sizeof(info)))
+			retval = -EFAULT;
+		break;
+	}
+	case _IOC_NR(SNDRV_SST_GET_ALGO):
+	case _IOC_NR(SNDRV_SST_SET_ALGO):
+		if (copy_from_user(&algo_params, (void __user *)arg,
+						sizeof(algo_params))) {
+			return -EFAULT;
+		}
+		retval = intel_sst_ioctl_dsp(cmd, &algo_params, arg);
+		break;
+
+	case _IOC_NR(SNDRV_SST_TUNING_PARAMS):
+		retval = sst_ioctl_tuning_params(cmd, arg);
+		break;
+
+	default:
+		retval = -EINVAL;
+	}
+	pr_debug("intel_sst_ioctl:complete ret code = %d for command = %x\n", retval, cmd);
+	return retval;
+}
+
diff --git a/sound/soc/intel/sst/sst_debug.c b/sound/soc/intel/sst/sst_debug.c
new file mode 100644
index 0000000..ce771c5
--- /dev/null
+++ b/sound/soc/intel/sst/sst_debug.c
@@ -0,0 +1,1328 @@
+/*
+ *  sst_debug.c - Intel SST Driver debugfs support
+ *
+ *  Copyright (C) 2012	Intel Corp
+ *  Authors:	Vinod Koul <vinod.koul@intel.com>
+ *		Omair Mohammed Abdullah <omair.m.abdullah@linux.intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This file contains all debugfs functions
+ *  Support includes:
+ *   - Disabling/Enabling runtime PM for SST
+ *   - Reading/Writing SST SHIM registers
+ *   - Reading/Enabling Input OSC Clock
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": debugfs: " fmt
+
+#include <linux/fs.h>
+#include <linux/pci.h>
+#include <linux/ctype.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/pm_runtime.h>
+#include <linux/uaccess.h>
+#include <asm/intel_scu_pmic.h>
+#include <asm/intel_scu_ipcutil.h>
+#include "../sst_platform.h"
+#include "../platform_ipc_v2.h"
+#include "sst.h"
+
+#define DMA_NUM_CH	8
+#define DEBUGFS_SSP_BUF_SIZE	300  /* 22 chars * 12 reg*/
+#define DEBUGFS_DMA_BUF_SIZE	2500 /* 32 chars * 78 regs*/
+
+/* Register Offsets of SSP3 and LPE DMA */
+u32 ssp_reg_off[] = {0x0, 0x4, 0x8, 0xC, 0x10, 0x28, 0x2C, 0x30, 0x34, 0x38,
+			0x3C, 0x40};
+/* Excludes the channel registers */
+u32 dma_reg_off[] = {0x2C0, 0x2C8, 0x2D0, 0x2D8, 0x2E0, 0x2E8,
+		0x2F0, 0x2F8, 0x300, 0x308, 0x310, 0x318, 0x320, 0x328, 0x330,
+		0x338, 0x340, 0x348, 0x350, 0x358, 0x360, 0x368, 0x370, 0x378,
+		0x380, 0x388, 0x390, 0x398, 0x3A0, 0x3A8, 0x3B0, 0x3C8, 0x3D0,
+		0x3D8, 0x3E0, 0x3E8, 0x3F0, 0x3F8};
+
+static ssize_t sst_debug_shim_read(struct file *file, char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+	struct intel_sst_drv *drv = file->private_data;
+	unsigned long long val = 0;
+	unsigned int addr;
+	char buf[512];
+	char name[8];
+	int pos = 0;
+
+	buf[0] = 0;
+	if (drv->sst_state == SST_SUSPENDED) {
+		pr_err("FW suspended, cannot read SHIM registers\n");
+		return -EFAULT;
+	}
+
+	for (addr = SST_SHIM_BEGIN; addr <= SST_SHIM_END; addr += 8) {
+		switch (drv->pci_id) {
+		case SST_CLV_PCI_ID:
+			val = sst_shim_read(drv->shim, addr);
+			break;
+		case SST_MRFLD_PCI_ID:
+		case SST_BYT_PCI_ID:
+		case SST_CHT_PCI_ID:
+			val = sst_shim_read64(drv->shim, addr);
+			break;
+		}
+
+		name[0] = 0;
+		switch (addr) {
+		case SST_ISRX:
+			strcpy(name, "ISRX"); break;
+		case SST_ISRD:
+			strcpy(name, "ISRD"); break;
+		case SST_IPCX:
+			strcpy(name, "IPCX"); break;
+		case SST_IPCD:
+			strcpy(name, "IPCD"); break;
+		case SST_IMRX:
+			strcpy(name, "IMRX"); break;
+		case SST_IMRD:
+			strcpy(name, "IMRD"); break;
+		}
+		pos += sprintf(buf + pos, "0x%.2x: %.8llx  %s\n", addr, val, name);
+	}
+
+	return simple_read_from_buffer(user_buf, count, ppos,
+			buf, strlen(buf));
+}
+
+static ssize_t sst_debug_shim_write(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct intel_sst_drv *drv = file->private_data;
+	char buf[32];
+	char *start = buf, *end;
+	unsigned long long value;
+	unsigned long reg_addr;
+	int ret_val;
+	size_t buf_size = min(count, sizeof(buf)-1);
+
+	if (copy_from_user(buf, user_buf, buf_size))
+		return -EFAULT;
+	buf[buf_size] = 0;
+
+	if (drv->sst_state == SST_SUSPENDED) {
+		pr_err("FW suspended, cannot write SHIM registers\n");
+		return -EFAULT;
+	}
+
+	while (*start == ' ')
+		start++;
+	end = start;
+	while (isalnum(*end))
+		end++;
+	*end = 0;
+
+	ret_val = kstrtoul(start, 16, &reg_addr);
+	if (ret_val) {
+		pr_err("kstrtoul failed, ret_val = %d\n", ret_val);
+		return ret_val;
+	}
+	if (!(SST_SHIM_BEGIN < reg_addr && reg_addr < SST_SHIM_END)) {
+		pr_err("invalid shim address: 0x%lx\n", reg_addr);
+		return -EINVAL;
+	}
+
+	start = end + 1;
+	while (*start == ' ')
+		start++;
+
+	ret_val = kstrtoull(start, 16, &value);
+	if (ret_val) {
+		pr_err("kstrtoul failed, ret_val = %d\n", ret_val);
+		return ret_val;
+	}
+
+	pr_debug("writing shim: 0x%.2lx=0x%.8llx", reg_addr, value);
+
+	if (drv->pci_id == SST_CLV_PCI_ID)
+		sst_shim_write(drv->shim, reg_addr, (u32) value);
+	else if (drv->pci_id == SST_MRFLD_PCI_ID)
+		sst_shim_write64(drv->shim, reg_addr, (u64) value);
+
+	/* Userspace has been fiddling around behind the kernel's back */
+	add_taint(TAINT_USER, LOCKDEP_NOW_UNRELIABLE);
+	return buf_size;
+}
+
+static const struct file_operations sst_debug_shim_ops = {
+	.open = simple_open,
+	.read = sst_debug_shim_read,
+	.write = sst_debug_shim_write,
+	.llseek = default_llseek,
+};
+
+#define RESVD_DUMP_SZ		40
+#define IA_LPE_MAILBOX_DUMP_SZ	100
+#define LPE_IA_MAILBOX_DUMP_SZ	100
+#define SCU_LPE_MAILBOX_DUMP_SZ	256
+#define LPE_SCU_MAILBOX_DUMP_SZ	256
+
+static inline int is_fw_running(struct intel_sst_drv *drv)
+{
+	pm_runtime_get_sync(drv->dev);
+	atomic_inc(&drv->pm_usage_count);
+	if (drv->sst_state != SST_FW_RUNNING) {
+		pr_err("FW not running\n");
+		sst_pm_runtime_put(drv);
+		return -EFAULT;
+	}
+	return 0;
+}
+
+static inline int read_buffer_fromio(char *dest, unsigned int sz,
+				     const u32 __iomem *from,
+				     unsigned int num_dwords)
+{
+	int i;
+	const unsigned int rowsz = 16, groupsz = 4;
+	const unsigned int size = num_dwords * sizeof(u32);
+	unsigned int linelen, printed = 0, remaining = size;
+
+	u8 *tmp = kmalloc(size, GFP_KERNEL);
+	if (!tmp)
+		return -ENOMEM;
+	memcpy_fromio(tmp, from, size);
+	for (i = 0; i < size; i += rowsz) {
+		linelen = min(remaining, rowsz);
+		remaining -= rowsz;
+		hex_dump_to_buffer(tmp + i, linelen, rowsz, groupsz,
+				   dest + printed, sz - printed, false);
+		printed += linelen * 2 + linelen / groupsz - 1;
+		*(dest + printed++) = '\n';
+		*(dest + printed) = 0;
+	}
+	kfree(tmp);
+	return 0;
+}
+
+static inline int copy_sram_to_user_buffer(char __user *user_buf, size_t count, loff_t *ppos,
+					   unsigned int num_dwords, const u32 __iomem *from,
+					   u32 offset)
+{
+	ssize_t bytes_read;
+	char *buf;
+	int pos;
+	unsigned int bufsz = 48 + sizeof(u32) * num_dwords * (2 + 1) + 1;
+
+	buf = kmalloc(bufsz, GFP_KERNEL);
+	if (!buf) {
+		pr_err("%s: no memory\n", __func__);
+		return -ENOMEM;
+	}
+	*buf = 0;
+	pos = scnprintf(buf, 48, "Reading %u dwords from offset %#x\n",
+			num_dwords, offset);
+	read_buffer_fromio(buf + pos, bufsz - pos, from, num_dwords);
+	bytes_read = simple_read_from_buffer(user_buf, count, ppos,
+					     buf, strlen(buf));
+	kfree(buf);
+	return bytes_read;
+}
+
+static ssize_t sst_debug_sram_lpe_debug_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+
+	struct intel_sst_drv *drv = file->private_data;
+	int ret = 0;
+
+	ret = is_fw_running(drv);
+	if (ret)
+		return ret;
+
+	ret = copy_sram_to_user_buffer(user_buf, count, ppos, RESVD_DUMP_SZ,
+				       (u32 *)(drv->mailbox + SST_RESERVED_OFFSET),
+				       SST_RESERVED_OFFSET);
+	sst_pm_runtime_put(drv);
+	return ret;
+}
+
+static const struct file_operations sst_debug_sram_lpe_debug_ops = {
+	.open = simple_open,
+	.read = sst_debug_sram_lpe_debug_read,
+	.llseek = default_llseek,
+};
+
+static ssize_t sst_debug_sram_lpe_checkpoint_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+
+	struct intel_sst_drv *drv = file->private_data;
+	int ret = 0;
+	u32 offset;
+
+	ret = is_fw_running(drv);
+	if (ret)
+		return ret;
+
+	offset = sst_drv_ctx->pdata->debugfs_data->checkpoint_offset;
+
+	ret = copy_sram_to_user_buffer(user_buf, count, ppos,
+				sst_drv_ctx->pdata->debugfs_data->checkpoint_size,
+				(u32 *)(drv->mailbox + offset), offset);
+	sst_pm_runtime_put(drv);
+	return ret;
+}
+
+static const struct file_operations sst_debug_sram_lpe_checkpoint_ops = {
+	.open = simple_open,
+	.read = sst_debug_sram_lpe_checkpoint_read,
+	.llseek = default_llseek,
+};
+
+static ssize_t sst_debug_sram_ia_lpe_mbox_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+
+	struct intel_sst_drv *drv = file->private_data;
+	int ret = 0;
+
+	ret = is_fw_running(drv);
+	if (ret)
+		return ret;
+	ret = copy_sram_to_user_buffer(user_buf, count, ppos, IA_LPE_MAILBOX_DUMP_SZ,
+				       (u32 *)(drv->mailbox + SST_MAILBOX_SEND),
+				       SST_MAILBOX_SEND);
+	sst_pm_runtime_put(drv);
+	return ret;
+}
+
+static const struct file_operations sst_debug_sram_ia_lpe_mbox_ops = {
+	.open = simple_open,
+	.read = sst_debug_sram_ia_lpe_mbox_read,
+	.llseek = default_llseek,
+};
+
+static ssize_t sst_debug_sram_lpe_ia_mbox_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+
+	struct intel_sst_drv *drv = file->private_data;
+	int ret = 0;
+
+	ret = is_fw_running(drv);
+	if (ret)
+		return ret;
+
+	ret = copy_sram_to_user_buffer(user_buf, count, ppos, LPE_IA_MAILBOX_DUMP_SZ,
+				       (u32 *)(drv->mailbox + drv->mailbox_recv_offset),
+				       drv->mailbox_recv_offset);
+	sst_pm_runtime_put(drv);
+	return ret;
+}
+
+static const struct file_operations sst_debug_sram_lpe_ia_mbox_ops = {
+	.open = simple_open,
+	.read = sst_debug_sram_lpe_ia_mbox_read,
+	.llseek = default_llseek,
+};
+
+static ssize_t sst_debug_sram_lpe_scu_mbox_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct intel_sst_drv *drv = file->private_data;
+	int ret = 0;
+
+	ret = is_fw_running(drv);
+	if (ret)
+		return ret;
+	ret = copy_sram_to_user_buffer(user_buf, count, ppos, LPE_SCU_MAILBOX_DUMP_SZ,
+				       (u32 *)(drv->mailbox + SST_LPE_SCU_MAILBOX),
+				       SST_LPE_SCU_MAILBOX);
+	sst_pm_runtime_put(drv);
+	return ret;
+}
+
+static const struct file_operations sst_debug_sram_lpe_scu_mbox_ops = {
+	.open = simple_open,
+	.read = sst_debug_sram_lpe_scu_mbox_read,
+	.llseek = default_llseek,
+};
+
+static ssize_t sst_debug_sram_scu_lpe_mbox_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{	struct intel_sst_drv *drv = file->private_data;
+	int ret = 0;
+
+	ret = is_fw_running(drv);
+	if (ret)
+		return ret;
+	ret = copy_sram_to_user_buffer(user_buf, count, ppos, SCU_LPE_MAILBOX_DUMP_SZ,
+				       (u32 *)(drv->mailbox + SST_SCU_LPE_MAILBOX),
+				       SST_SCU_LPE_MAILBOX);
+	sst_pm_runtime_put(drv);
+	return ret;
+}
+
+static const struct file_operations sst_debug_sram_scu_lpe_mbox_ops = {
+	.open = simple_open,
+	.read = sst_debug_sram_scu_lpe_mbox_read,
+	.llseek = default_llseek,
+};
+
+static ssize_t sst_debug_lpe_log_enable_write(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct intel_sst_drv *drv = file->private_data;
+	struct ipc_post *msg = NULL;
+	char buf[32];
+	int str_id = 0;	/* DUMMY, required by post message */
+	struct snd_sst_lpe_log_params params;
+	int ret_val = 0;
+	char *start = buf, *end;
+	int i = 0;
+	u8 *addr;
+	unsigned long tmp;
+
+	size_t buf_size = min(count, sizeof(buf)-1);
+	memset(&params, 0, sizeof(params));
+
+	ret_val = is_fw_running(drv);
+	if (ret_val)
+		return ret_val;
+
+	if (copy_from_user(buf, user_buf, buf_size)) {
+		ret_val = -EFAULT;
+		goto put_pm_runtime;
+	}
+
+	buf[buf_size] = 0;
+
+	addr = &params.dbg_type;
+	for (i = 0; i < (sizeof(params) - sizeof(u8)); i++) {
+		while (*start == ' ')
+			start++;
+		end = start;
+		while (isalnum(*end))
+			end++;
+		*end = 0;
+		ret_val = kstrtoul(start, 16, &tmp);
+		if (ret_val) {
+			pr_err("kstrtoul failed, ret_val = %d\n", ret_val);
+			goto put_pm_runtime;
+		}
+		*addr++ = (u8)tmp;
+		start = end + 1;
+	}
+
+	pr_debug("dbg_type = %d module_id = %d log_level = %d\n",
+			params.dbg_type, params.module_id, params.log_level);
+
+	if (params.dbg_type < NO_DEBUG || params.dbg_type > PTI_DEBUG) {
+		ret_val = -EINVAL;
+		goto put_pm_runtime;
+	}
+
+	ret_val = sst_create_ipc_msg(&msg, true);
+	if (ret_val != 0)
+		goto put_pm_runtime;
+
+	if (sst_drv_ctx->pci_id != SST_MRFLD_PCI_ID) {
+		sst_fill_header(&msg->header, IPC_IA_DBG_LOG_ENABLE, 1,
+							str_id);
+		msg->header.part.data = sizeof(u32) + sizeof(params);
+		memcpy(msg->mailbox_data, &msg->header.full, sizeof(u32));
+		memcpy(msg->mailbox_data + sizeof(u32), &params,
+							sizeof(params));
+	}
+	drv->ops->sync_post_message(msg);
+	ret_val = buf_size;
+put_pm_runtime:
+	sst_pm_runtime_put(drv);
+	return ret_val;
+}
+
+/*
+ * Circular buffer hdr -> 0x1000
+ * log data starts at 0x1010
+ */
+static ssize_t sst_debug_lpe_log_enable_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct intel_sst_drv *drv = file->private_data;
+	struct lpe_log_buf_hdr buf_hdr;
+	size_t size1, size2, offset, bytes_read;
+	char *buf = NULL;
+	int ret;
+
+	ret = is_fw_running(drv);
+	if (ret)
+		return ret;
+
+	/* Get the sram lpe log buffer header */
+	memcpy_fromio(&buf_hdr, (u32 *)(drv->mailbox + SST_SCU_LPE_MAILBOX),
+							sizeof(buf_hdr));
+	if (buf_hdr.rd_addr == buf_hdr.wr_addr) {
+		pr_err("SRAM emptry\n");
+		ret = -ENODATA;
+		goto put_pm_runtime;
+	} else if (buf_hdr.rd_addr < buf_hdr.wr_addr) {
+		size1 = buf_hdr.wr_addr - buf_hdr.rd_addr;
+		offset = (buf_hdr.rd_addr - buf_hdr.base_addr)
+						+ SST_SCU_LPE_LOG_BUF;
+		pr_debug("Size = %zu, offset = %zx\n", size1, offset);
+		buf = vmalloc(size1);
+		if (buf == NULL) {
+			pr_err("Not enough memory to allocate\n");
+			ret = -ENOMEM;
+			goto put_pm_runtime;
+		}
+		memcpy_fromio(buf, (u32 *)(drv->mailbox + offset), size1);
+		bytes_read = simple_read_from_buffer(user_buf, count, ppos,
+							buf, size1);
+
+		buf_hdr.rd_addr = buf_hdr.rd_addr + bytes_read;
+
+	} else {
+		/* Read including the end address as well */
+		size1 = buf_hdr.end_addr - buf_hdr.rd_addr + 1;
+		offset = (buf_hdr.rd_addr - buf_hdr.base_addr)
+						+ SST_SCU_LPE_LOG_BUF;
+		pr_debug("Size = %zu, offset = %zx\n", size1, offset);
+		buf = vmalloc(size1);
+		if (buf == NULL) {
+			pr_err("Not enough memory to allocate\n");
+			ret = -ENOMEM;
+			goto put_pm_runtime;
+		}
+		memcpy_fromio(buf, (u32 *)(drv->mailbox + offset), size1);
+		bytes_read = simple_read_from_buffer(user_buf, count, ppos,
+							buf, size1);
+		if (bytes_read != size1) {
+			buf_hdr.rd_addr = buf_hdr.rd_addr + bytes_read;
+			goto update_rd_ptr;
+		}
+
+		/* Wrap around lpe log buffer here */
+		vfree(buf);
+		buf = NULL;
+		size2 = (buf_hdr.wr_addr - buf_hdr.base_addr);
+		offset = SST_SCU_LPE_LOG_BUF;
+		pr_debug("Size = %zu, offset = %zx\n", size2, offset);
+		buf = vmalloc(size2);
+		if (buf == NULL) {
+			pr_err("Not enough memory to allocate\n");
+			ret = -ENOMEM;
+			goto put_pm_runtime;
+		}
+		memcpy_fromio(buf, (u32 *)(drv->mailbox + offset), size2);
+		bytes_read += simple_read_from_buffer(user_buf,
+				(count - bytes_read), ppos, buf, size2);
+		buf_hdr.rd_addr = buf_hdr.base_addr + bytes_read - size1;
+
+	}
+update_rd_ptr:
+	if (bytes_read != 0) {
+		memcpy_toio((u32 *)(drv->mailbox + SST_SCU_LPE_MAILBOX +
+				2 * sizeof(u32)), &(buf_hdr.rd_addr), sizeof(u32));
+		pr_debug("read pointer restored\n");
+	}
+	vfree(buf);
+	buf = NULL;
+	ret = bytes_read;
+put_pm_runtime:
+	sst_pm_runtime_put(drv);
+	return ret;
+}
+
+static const struct file_operations sst_debug_lpe_log_enable_ops = {
+	.open = simple_open,
+	.write = sst_debug_lpe_log_enable_write,
+	.read = sst_debug_lpe_log_enable_read,
+	.llseek = default_llseek,
+};
+
+static ssize_t sst_debug_rtpm_read(struct file *file, char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+	struct intel_sst_drv *drv = file->private_data;
+	char *status;
+
+	int usage = atomic_read(&drv->pm_usage_count);
+
+	pr_debug("RTPM usage: %d\n", usage);
+	status = drv->debugfs.runtime_pm_status ? "enabled\n" : "disabled\n";
+	return simple_read_from_buffer(user_buf, count, ppos,
+			status, strlen(status));
+}
+
+static ssize_t sst_debug_rtpm_write(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct intel_sst_drv *drv = file->private_data;
+	char buf[16];
+	int sz = min(count, sizeof(buf)-1);
+
+	int usage = atomic_read(&drv->pm_usage_count);
+
+	pr_debug("RTPM Usage: %d\n", usage);
+	if (copy_from_user(buf, user_buf, sz))
+		return -EFAULT;
+	buf[sz] = 0;
+
+	if (!strncmp(buf, "enable\n", sz)) {
+		/* already enabled? */
+		if (drv->debugfs.runtime_pm_status)
+			return -EINVAL;
+		drv->debugfs.runtime_pm_status = 1;
+		pm_runtime_allow(drv->dev);
+		sz = 6; /* strlen("enable") */
+	} else if (!strncmp(buf, "disable\n", sz)) {
+		if (!drv->debugfs.runtime_pm_status)
+			return -EINVAL;
+		drv->debugfs.runtime_pm_status = 0;
+		pm_runtime_forbid(drv->dev);
+		sz = 7; /* strlen("disable") */
+	} else
+		return -EINVAL;
+	return sz;
+}
+
+static const struct file_operations sst_debug_rtpm_ops = {
+	.open = simple_open,
+	.read = sst_debug_rtpm_read,
+	.write = sst_debug_rtpm_write,
+	.llseek = default_llseek,
+};
+
+
+static ssize_t sst_debug_readme_read(struct file *file, char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+	const char *buf =
+		"\nAll files can be read using 'cat'\n"
+		"1. 'echo disable > runtime_pm' disables runtime PM and will prevent SST from suspending.\n"
+		"To enable runtime PM, echo 'enable' to runtime_pm. Dmesg will print the runtime pm usage\n"
+		"if logs are enabled.\n"
+		"2. Write to shim register using 'echo <addr> <value> > shim_dump'.\n"
+		"Valid address range is between 0x00 to 0x80 in increments of 8.\n"
+		"3. echo 1 > fw_clear_context , This sets the flag to skip the context restore\n"
+		"4. echo 1 > fw_clear_cache , This sets the flag to clear the cached copy of firmware\n"
+		"5. echo 1 > fw_reset_state ,This sets the fw state to uninit\n"
+		"6. echo memcpy > fw_dwnld_mode, This will set the firmware download mode to memcpy\n"
+		"   echo lli > fw_dwnld_mode, This will set the firmware download mode to\n"
+					"dma lli mode\n"
+		"   echo dma > fw_dwnld_mode, This will set the firmware download mode to\n"
+					"dma single block mode\n"
+		"7. iram_dump, dram_dump, interfaces provide mmap support to\n"
+		"get the iram and dram dump, these buffers will have data only\n"
+		"after the recovery is triggered\n";
+
+	const char *ctp_buf =
+		"8. Enable input clock by 'echo enable > osc_clk0'.\n"
+		"This prevents the input OSC clock from switching off till it is disabled by\n"
+		"'echo disable > osc_clk0'. The status of the clock indicated who are using it.\n"
+		"9. lpe_log_enable usage:\n"
+		"	echo <dbg_type> <module_id> <log_level> > lpe_log_enable.\n"
+		"10. cat fw_ssp_reg,This will dump the ssp register contents\n"
+		"11. cat fw_dma_reg,This will dump the dma register contents\n";
+
+	const char *mrfld_buf =
+		"8. lpe_log_enable usage:\n"
+		"	echo <dbg_type> <module_id> <log_level> > lpe_log_enable.\n"
+		"9. cat fw_ssp_reg,This will dump the ssp register contents\n"
+		"10. cat fw_dma_reg,This will dump the dma register contents\n"
+		"11. ddr_imr_dump interface provides mmap support to get the imr dump,\n"
+		"this buffer will have data only after the recovery is triggered\n"
+		"12. ipc usage:\n"
+		"\t ipc file works only in binary mode. The ipc format is <IPC hdr><dsp hdr><payload>.\n"
+		"\t drv_id in the ipc header will be overwritten with unique driver id in the driver\n";
+
+	char *readme = NULL;
+	const char *buf2 = NULL;
+	int size, ret = 0;
+
+	switch (sst_drv_ctx->pci_id) {
+	case SST_CLV_PCI_ID:
+		size = strlen(buf) + strlen(ctp_buf) + 2;
+		buf2 = ctp_buf;
+		break;
+	case SST_MRFLD_PCI_ID:
+		size = strlen(buf) + strlen(mrfld_buf) + 2;
+		buf2 = mrfld_buf;
+		break;
+	default:
+		size = strlen(buf) + 1;
+	};
+
+	readme = kmalloc(size, GFP_KERNEL);
+	if (readme == NULL) {
+		pr_err("%s: no memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	if (buf2)
+		sprintf(readme, "%s%s\n", buf, buf2);
+	else
+		sprintf(readme, "%s\n", buf);
+
+	ret = simple_read_from_buffer(user_buf, count, ppos,
+			readme, strlen(readme));
+	kfree(readme);
+	return ret;
+}
+
+static const struct file_operations sst_debug_readme_ops = {
+	.open = simple_open,
+	.read = sst_debug_readme_read,
+};
+
+static ssize_t sst_debug_osc_clk0_read(struct file *file, char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+	char status[16];
+	int mode = -1;
+#ifdef CONFIG_INTEL_SCU_IPC_UTIL
+	mode = intel_scu_ipc_set_osc_clk0(0, CLK0_QUERY);
+#endif
+
+	snprintf(status, 16, "0x%x\n", mode);
+	return simple_read_from_buffer(user_buf, count, ppos,
+			status, strlen(status));
+}
+
+static ssize_t sst_debug_osc_clk0_write(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char buf[16];
+	int sz = min(count, sizeof(buf)-1);
+
+	if (copy_from_user(buf, user_buf, sz))
+		return -EFAULT;
+	buf[sz] = 0;
+
+#ifdef CONFIG_INTEL_SCU_IPC_UTIL
+	if (!strncmp(buf, "enable\n", sz)) {
+		intel_scu_ipc_set_osc_clk0(true, CLK0_DEBUG);
+		sz = 6; /* strlen("enable") */
+	} else if (!strncmp(buf, "disable\n", sz)) {
+		intel_scu_ipc_set_osc_clk0(false, CLK0_DEBUG);
+		sz = 7; /* strlen("disable") */
+	} else
+		return -EINVAL;
+#endif
+	return sz;
+}
+
+static const struct file_operations sst_debug_osc_clk0_ops = {
+	.open = simple_open,
+	.read = sst_debug_osc_clk0_read,
+	.write = sst_debug_osc_clk0_write,
+};
+
+static ssize_t sst_debug_fw_clear_cntx_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char *status;
+
+	status = atomic_read(&sst_drv_ctx->fw_clear_context) ? \
+			"clear fw cntx\n" : "do not clear fw cntx\n";
+
+	return simple_read_from_buffer(user_buf, count, ppos,
+			status, strlen(status));
+
+}
+
+static ssize_t sst_debug_fw_clear_cntx_write(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+
+{
+	char buf[16];
+	int sz = min(count, sizeof(buf)-1);
+
+	if (copy_from_user(buf, user_buf, sz))
+		return -EFAULT;
+	buf[sz] = 0;
+
+	if (!strncmp(buf, "1\n", sz))
+		atomic_set(&sst_drv_ctx->fw_clear_context, 1);
+	else
+		atomic_set(&sst_drv_ctx->fw_clear_context, 0);
+
+	return sz;
+
+}
+
+static const struct file_operations sst_debug_fw_clear_cntx = {
+	.open = simple_open,
+	.read = sst_debug_fw_clear_cntx_read,
+	.write = sst_debug_fw_clear_cntx_write,
+};
+
+static ssize_t sst_debug_fw_clear_cache_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char *status;
+
+	status = atomic_read(&sst_drv_ctx->fw_clear_cache) ? \
+			"cache clear flag set\n" : "cache clear flag not set\n";
+
+	return simple_read_from_buffer(user_buf, count, ppos,
+			status, strlen(status));
+
+}
+
+static ssize_t sst_debug_fw_clear_cache_write(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+
+{
+	char buf[16];
+	int sz = min(count, sizeof(buf)-1);
+
+	if (copy_from_user(buf, user_buf, sz))
+		return -EFAULT;
+	buf[sz] = 0;
+
+	if (!strncmp(buf, "1\n", sz))
+		atomic_set(&sst_drv_ctx->fw_clear_cache, 1);
+	else
+		return -EINVAL;
+
+	return sz;
+}
+
+static const struct file_operations sst_debug_fw_clear_cache = {
+	.open = simple_open,
+	.read = sst_debug_fw_clear_cache_read,
+	.write = sst_debug_fw_clear_cache_write,
+};
+
+static ssize_t sst_debug_fw_reset_state_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char state[16];
+
+	sprintf(state, "%d\n", sst_drv_ctx->sst_state);
+
+	return simple_read_from_buffer(user_buf, count, ppos,
+			state, strlen(state));
+
+}
+
+static ssize_t sst_debug_fw_reset_state_write(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+
+{
+	char buf[16];
+	int sz = min(count, sizeof(buf)-1);
+
+	if (copy_from_user(buf, user_buf, sz))
+		return -EFAULT;
+	buf[sz] = 0;
+
+	if (!strncmp(buf, "1\n", sz))
+		sst_set_fw_state_locked(sst_drv_ctx, SST_UN_INIT);
+	else
+		return -EINVAL;
+
+	return sz;
+
+}
+
+static const struct file_operations sst_debug_fw_reset_state = {
+	.open = simple_open,
+	.read = sst_debug_fw_reset_state_read,
+	.write = sst_debug_fw_reset_state_write,
+};
+
+static ssize_t sst_debug_dwnld_mode_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char *state = "error\n";
+
+	if (sst_drv_ctx->use_dma == 0) {
+		state = "memcpy\n";
+	} else if (sst_drv_ctx->use_dma == 1) {
+		state = sst_drv_ctx->use_lli ? \
+				"lli\n" : "dma\n";
+
+	}
+
+	return simple_read_from_buffer(user_buf, count, ppos,
+			state, strlen(state));
+
+}
+
+static ssize_t sst_debug_dwnld_mode_write(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+
+{
+	char buf[16];
+	int sz = min(count, sizeof(buf)-1);
+
+	if (sst_drv_ctx->sst_state != SST_SUSPENDED &&
+	    sst_drv_ctx->sst_state != SST_UN_INIT) {
+		pr_err("FW should be in suspended/uninit state\n");
+		return -EFAULT;
+	}
+
+	if (copy_from_user(buf, user_buf, sz))
+		return -EFAULT;
+	buf[sz] = '\0';
+
+	/* Firmware needs to be downloaded again to populate the lists */
+	atomic_set(&sst_drv_ctx->fw_clear_cache, 1);
+
+	if (!strncmp(buf, "memcpy\n", sz)) {
+		sst_drv_ctx->use_dma = 0;
+	} else if (!strncmp(buf, "lli\n", sz)) {
+		sst_drv_ctx->use_dma = 1;
+		sst_drv_ctx->use_lli = 1;
+	} else if (!strncmp(buf, "dma\n", sz)) {
+		sst_drv_ctx->use_dma = 1;
+		sst_drv_ctx->use_lli = 0;
+	}
+	return sz;
+
+}
+
+static const struct file_operations sst_debug_dwnld_mode = {
+	.open = simple_open,
+	.read = sst_debug_dwnld_mode_read,
+	.write = sst_debug_dwnld_mode_write,
+};
+
+static int dump_ssp_port(void __iomem *ssp_base, char *buf, int pos)
+{
+	int index = 0;
+
+	while (index < ARRAY_SIZE(ssp_reg_off)) {
+		pos += sprintf(buf + pos, "Reg: 0x%x: 0x%x\n", ssp_reg_off[index],
+			sst_reg_read(ssp_base, ssp_reg_off[index]));
+		index++;
+	}
+	return pos;
+}
+
+static ssize_t sst_debug_ssp_reg_read(struct file *file,
+			char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char *buf;
+	int i, pos = 0, off = 0;
+	struct intel_sst_drv *drv = file->private_data;
+	int num_ssp, buf_size, ret;
+
+	num_ssp = sst_drv_ctx->pdata->debugfs_data->num_ssp;
+	buf_size = DEBUGFS_SSP_BUF_SIZE * num_ssp;
+
+	buf = kmalloc(buf_size, GFP_KERNEL);
+	if (!buf) {
+		pr_err("%s: no memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	ret = is_fw_running(drv);
+	if (ret)
+		goto err;
+
+	buf[0] = 0;
+
+	for (i = 0; i < num_ssp ; i++) {
+		if (!sst_drv_ctx->debugfs.ssp[i]) {
+			pr_err("ssp %d port not mapped\n", i);
+			continue;
+		}
+		off = sst_drv_ctx->pdata->debugfs_data->ssp_reg_size * i;
+		pos = dump_ssp_port((sst_drv_ctx->debugfs.ssp[i]), buf, pos);
+	}
+	sst_pm_runtime_put(drv);
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);
+err:
+	kfree(buf);
+	return ret;
+}
+
+static const struct file_operations sst_debug_ssp_reg = {
+		.open = simple_open,
+		.read = sst_debug_ssp_reg_read,
+};
+
+static int dump_dma_reg(char *buf, int pos, int dma)
+{
+	int i, index = 0;
+	int off = 0 ;
+	void __iomem *dma_reg;
+
+	if (!sst_drv_ctx->debugfs.dma_reg[dma]) {
+		pr_err("dma %d not mapped\n", dma);
+		return pos;
+	}
+
+	pos += sprintf(buf + pos, "\nDump DMA%d Reg\n\n", dma);
+
+	dma_reg = sst_drv_ctx->debugfs.dma_reg[dma];
+
+	/* Dump the DMA channel registers */
+	for (i = 0; i < DMA_NUM_CH; i++) {
+		pos += sprintf(buf + pos, "SAR%d: 0x%x: 0x%llx\n", i, off,
+			sst_reg_read64(dma_reg, off));
+		off += 8;
+
+		pos += sprintf(buf + pos, "DAR%d: 0x%x: 0x%llx\n", i, off,
+			sst_reg_read64(dma_reg, off));
+		off += 8;
+
+		pos += sprintf(buf + pos, "LLP%d: 0x%x: 0x%llx\n", i, off,
+			sst_reg_read64(dma_reg, off));
+		off += 8;
+
+		pos += sprintf(buf + pos, "CTL%d: 0x%x: 0x%llx\n", i, off,
+			sst_reg_read64(dma_reg, off));
+		off += 0x28;
+
+		pos += sprintf(buf + pos, "CFG%d: 0x%x: 0x%llx\n", i, off,
+			sst_reg_read64(dma_reg, off));
+		off += 0x18;
+	}
+
+	/* Dump the remaining DMA registers */
+	while (index < ARRAY_SIZE(dma_reg_off)) {
+		pos += sprintf(buf + pos, "Reg: 0x%x: 0x%llx\n", dma_reg_off[index],
+				sst_reg_read64(dma_reg, dma_reg_off[index]));
+		index++;
+	}
+	return pos;
+}
+
+static ssize_t sst_debug_dma_reg_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char *buf;
+	int pos = 0;
+	int ret, i;
+	struct intel_sst_drv *drv = file->private_data;
+	int num_dma, buf_size;
+
+	num_dma = sst_drv_ctx->pdata->debugfs_data->num_dma;
+	buf_size = DEBUGFS_DMA_BUF_SIZE * num_dma;
+
+	buf = kmalloc(buf_size, GFP_KERNEL);
+	if (!buf) {
+		pr_err("%s: no memory\n", __func__);
+		return -ENOMEM;
+	}
+
+	ret = is_fw_running(drv);
+	if (ret)
+		goto err;
+
+	buf[0] = 0;
+
+	for (i = 0; i < num_dma; i++)
+		pos = dump_dma_reg(buf, pos, i);
+
+	sst_pm_runtime_put(drv);
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, pos);
+err:
+	kfree(buf);
+	return ret;
+}
+
+static const struct file_operations sst_debug_dma_reg = {
+		.open = simple_open,
+		.read = sst_debug_dma_reg_read,
+};
+
+/**
+ * sst_debug_remap - function remaps the iram/dram buff to userspace
+ *
+ * @vma: vm_area_struct passed from userspace
+ * @buf: Physical addr of the pointer to be remapped
+ * @type: type of the buffer
+ *
+ * Remaps the kernel buffer to the userspace
+ */
+static int sst_debug_remap(struct vm_area_struct *vma, char *buf,
+					enum sst_ram_type type)
+{
+	int retval, length;
+	void *mem_area;
+
+	if (!buf)
+		return -EIO;
+
+	length = vma->vm_end - vma->vm_start;
+	pr_debug("iram length 0x%x\n", length);
+
+	/* round it up to the page bondary  */
+	mem_area = (void *)PAGE_ALIGN((unsigned long)buf);
+
+	/* map the whole physically contiguous area in one piece  */
+	retval = remap_pfn_range(vma,
+			vma->vm_start,
+			virt_to_phys((void *)mem_area) >> PAGE_SHIFT,
+			length,
+			vma->vm_page_prot);
+	if (retval)
+		pr_err("mapping failed %d ", retval);
+	return retval;
+}
+
+int sst_debug_iram_dump_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	int retval;
+	struct intel_sst_drv *sst = sst_drv_ctx;
+
+	retval = sst_debug_remap(vma, sst->dump_buf.iram_buf.buf, SST_IRAM);
+
+	return retval;
+}
+
+static const struct file_operations sst_debug_iram_dump = {
+	.open = simple_open,
+	.mmap = sst_debug_iram_dump_mmap,
+};
+
+int sst_debug_dram_dump_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	int retval;
+	struct intel_sst_drv *sst = sst_drv_ctx;
+
+	retval = sst_debug_remap(vma, sst->dump_buf.dram_buf.buf, SST_DRAM);
+
+	return retval;
+}
+
+static const struct file_operations sst_debug_dram_dump = {
+	.open = simple_open,
+	.mmap = sst_debug_dram_dump_mmap,
+};
+
+int sst_debug_ddr_imr_dump_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	int retval;
+	struct intel_sst_drv *sst = sst_drv_ctx;
+
+	retval = sst_debug_remap(vma, sst->ddr, 0);
+
+	return retval;
+}
+
+static const struct file_operations sst_debug_ddr_imr_dump = {
+	.open = simple_open,
+	.mmap = sst_debug_ddr_imr_dump_mmap,
+};
+
+static ssize_t sst_debug_ipc_write(struct file *file,
+		const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct intel_sst_drv *ctx = (struct intel_sst_drv *)file->private_data;
+	unsigned char *buf;
+	struct sst_block *block = NULL;
+	struct ipc_dsp_hdr *dsp_hdr;
+	struct ipc_post *msg = NULL;
+	int ret, res_rqd, msg_id, drv_id;
+	u32 low_payload;
+
+	if (count > 1024)
+		return -EINVAL;
+
+	ret = is_fw_running(ctx);
+	if (ret)
+		return ret;
+
+	buf = kzalloc((sizeof(unsigned char) * (count)), GFP_KERNEL);
+	if (!buf) {
+		ret = -ENOMEM;
+		goto put_pm_runtime;
+	}
+	if (copy_from_user(buf, user_buf, count)) {
+		ret = -EFAULT;
+		goto free_mem;
+	}
+
+	if (sst_create_ipc_msg(&msg, true)) {
+		ret = -ENOMEM;
+		goto free_mem;
+	}
+
+	msg->mrfld_header.full = *((u64 *)buf);
+	pr_debug("ipc hdr: %llx\n", msg->mrfld_header.full);
+
+	/* Override the drv id with unique drv id */
+	drv_id = sst_assign_pvt_id(ctx);
+	msg->mrfld_header.p.header_high.part.drv_id = drv_id;
+
+	res_rqd = msg->mrfld_header.p.header_high.part.res_rqd;
+	msg_id = msg->mrfld_header.p.header_high.part.msg_id;
+	pr_debug("res_rqd: %d, msg_id: %d, drv_id: %d\n",
+					res_rqd, msg_id, drv_id);
+	if (res_rqd) {
+		block = sst_create_block(ctx, msg_id, drv_id);
+		if (block == NULL) {
+			ret = -ENOMEM;
+			kfree(msg);
+			goto free_mem;
+		}
+	}
+
+	dsp_hdr = (struct ipc_dsp_hdr *)(buf + 8);
+	pr_debug("dsp hdr: %llx\n", *((u64 *)(dsp_hdr)));
+	low_payload = msg->mrfld_header.p.header_low_payload;
+	if (low_payload > (1024 - sizeof(union ipc_header_mrfld))) {
+		pr_err("Invalid low payload length: %x\n", low_payload);
+		ret = -EINVAL;
+		kfree(msg);
+		goto free_block;
+	}
+
+	memcpy(msg->mailbox_data, (buf+(sizeof(union ipc_header_mrfld))),
+			low_payload);
+	sst_add_to_dispatch_list_and_post(ctx, msg);
+	if (res_rqd) {
+		ret = sst_wait_timeout(ctx, block);
+		if (ret) {
+			pr_err("%s: fw returned err %d\n", __func__, ret);
+			goto free_block;
+		}
+
+		if (msg_id == IPC_GET_PARAMS) {
+			unsigned char *r = block->data;
+			memcpy(ctx->debugfs.get_params_data, r, dsp_hdr->length);
+			ctx->debugfs.get_params_len = dsp_hdr->length;
+		}
+
+	}
+	ret = count;
+free_block:
+	if (res_rqd)
+		sst_free_block(sst_drv_ctx, block);
+free_mem:
+	kfree(buf);
+put_pm_runtime:
+	sst_pm_runtime_put(ctx);
+	return ret;
+}
+
+static ssize_t sst_debug_ipc_read(struct file *file,
+		char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct intel_sst_drv *ctx = (struct intel_sst_drv *)file->private_data;
+	return simple_read_from_buffer(user_buf, count, ppos,
+			ctx->debugfs.get_params_data,
+			ctx->debugfs.get_params_len);
+}
+
+static const struct file_operations sst_debug_ipc_ops = {
+	.open = simple_open,
+	.write = sst_debug_ipc_write,
+	.read = sst_debug_ipc_read,
+};
+
+struct sst_debug {
+	const char *name;
+	const struct file_operations *fops;
+	umode_t mode;
+};
+
+static const struct sst_debug sst_common_dbg_entries[] = {
+	{"runtime_pm", &sst_debug_rtpm_ops, 0600},
+	{"shim_dump", &sst_debug_shim_ops, 0600},
+	{"fw_clear_context", &sst_debug_fw_clear_cntx, 0600},
+	{"fw_clear_cache", &sst_debug_fw_clear_cache, 0600},
+	{"fw_reset_state", &sst_debug_fw_reset_state, 0600},
+	{"fw_dwnld_mode", &sst_debug_dwnld_mode, 0600},
+	{"iram_dump", &sst_debug_iram_dump, 0400},
+	{"dram_dump", &sst_debug_dram_dump, 0400},
+	{"sram_ia_lpe_mailbox", &sst_debug_sram_ia_lpe_mbox_ops, 0400},
+	{"sram_lpe_ia_mailbox", &sst_debug_sram_lpe_ia_mbox_ops, 0400},
+	{"README", &sst_debug_readme_ops, 0400},
+};
+
+static const struct sst_debug ctp_dbg_entries[] = {
+	{"sram_lpe_debug", &sst_debug_sram_lpe_debug_ops, 0400},
+	{"sram_lpe_checkpoint", &sst_debug_sram_lpe_checkpoint_ops, 0400},
+	{"sram_lpe_scu_mailbox", &sst_debug_sram_lpe_scu_mbox_ops, 0400},
+	{"sram_scu_lpe_mailbox", &sst_debug_sram_scu_lpe_mbox_ops, 0400},
+	{"lpe_log_enable", &sst_debug_lpe_log_enable_ops, 0400},
+	{"fw_ssp_reg", &sst_debug_ssp_reg, 0400},
+	{"fw_dma_reg", &sst_debug_dma_reg, 0400},
+	{"osc_clk0", &sst_debug_osc_clk0_ops, 0600},
+};
+
+static const struct sst_debug mrfld_dbg_entries[] = {
+	{"sram_lpe_checkpoint", &sst_debug_sram_lpe_checkpoint_ops, 0400},
+	{"fw_ssp_reg", &sst_debug_ssp_reg, 0400},
+	{"fw_dma_reg", &sst_debug_dma_reg, 0400},
+	{"ddr_imr_dump", &sst_debug_ddr_imr_dump, 0400},
+	{"ipc", &sst_debug_ipc_ops, 0400},
+};
+
+void sst_debugfs_create_files(struct intel_sst_drv *sst,
+			const struct sst_debug *entries, int size)
+{
+	int i;
+
+	for (i = 0; i < size; i++) {
+		struct dentry *dentry;
+		const struct sst_debug *entry = &entries[i];
+
+		dentry = debugfs_create_file(entry->name, entry->mode,
+				sst->debugfs.root, sst, entry->fops);
+		if (dentry == NULL) {
+			pr_err("Failed to create %s file\n", entry->name);
+			return;
+		}
+	}
+}
+
+void sst_debugfs_init(struct intel_sst_drv *sst)
+{
+	int size = 0;
+	const struct sst_debug *debug = NULL;
+
+	sst->debugfs.root = debugfs_create_dir("sst", NULL);
+	if (IS_ERR(sst->debugfs.root) || !sst->debugfs.root) {
+		pr_err("Failed to create debugfs directory\n");
+		return;
+	}
+
+	sst_debugfs_create_files(sst, sst_common_dbg_entries,
+				ARRAY_SIZE(sst_common_dbg_entries));
+
+	/* Initial status is enabled */
+	sst->debugfs.runtime_pm_status = 1;
+
+	if (sst->pci_id == SST_MRFLD_PCI_ID) {
+		debug = mrfld_dbg_entries;
+		size = ARRAY_SIZE(mrfld_dbg_entries);
+	} else if (sst->pci_id == SST_CLV_PCI_ID) {
+		debug = ctp_dbg_entries;
+		size = ARRAY_SIZE(ctp_dbg_entries);
+	}
+
+	if (debug)
+		sst_debugfs_create_files(sst, debug, size);
+
+}
+
+void sst_debugfs_exit(struct intel_sst_drv *sst)
+{
+	if (sst->debugfs.runtime_pm_status)
+		pm_runtime_allow(sst->dev);
+	debugfs_remove_recursive(sst->debugfs.root);
+}
diff --git a/sound/soc/intel/sst/sst_drv_interface.c b/sound/soc/intel/sst/sst_drv_interface.c
new file mode 100644
index 0000000..97d4f26
--- /dev/null
+++ b/sound/soc/intel/sst/sst_drv_interface.c
@@ -0,0 +1,1111 @@
+/*
+ *  sst_drv_interface.c - Intel SST Driver for audio engine
+ *
+ *  Copyright (C) 2008-10 Intel Corp
+ *  Authors:	Vinod Koul <vinod.koul@intel.com>
+ *		Harsha Priya <priya.harsha@intel.com>
+ *		Dharageswari R <dharageswari.r@intel.com)
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * This file defines the interface  between the platform driver and the SST
+ * driver.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <linux/fs.h>
+#include <linux/firmware.h>
+#include <linux/pm_runtime.h>
+#include <linux/pm_qos.h>
+#include <linux/math64.h>
+#include <linux/intel_mid_pm.h>
+#include <sound/compress_offload.h>
+#include <sound/pcm.h>
+#include <sound/intel_sst_ioctl.h>
+#include "../sst_platform.h"
+#include "../platform_ipc_v2.h"
+#include "sst.h"
+
+#define NUM_CODEC 2
+#define MIN_FRAGMENT 2
+#define MAX_FRAGMENT 4
+#define MIN_FRAGMENT_SIZE (50 * 1024)
+#define MAX_FRAGMENT_SIZE (1024 * 1024)
+#define SST_GET_BYTES_PER_SAMPLE(pcm_wd_sz)  (((pcm_wd_sz + 15) >> 4) << 1)
+
+void sst_restore_fw_context(void)
+{
+	struct snd_sst_ctxt_params fw_context;
+	struct ipc_post *msg = NULL;
+	int retval = 0;
+	struct sst_block *block;
+
+	/* Skip the context restore, when fw_clear_context is set */
+	/* fw_clear_context set through debugfs support */
+	if (atomic_read(&sst_drv_ctx->fw_clear_context)) {
+		pr_debug("Skipping restore_fw_context\n");
+		atomic_set(&sst_drv_ctx->fw_clear_context, 0);
+		return;
+	}
+
+	pr_debug("restore_fw_context\n");
+	/*nothing to restore*/
+	if (!sst_drv_ctx->fw_cntx_size)
+		return;
+	pr_debug("restoring context......\n");
+	/*send msg to fw*/
+	retval = sst_create_block_and_ipc_msg(&msg, true, sst_drv_ctx, &block,
+			IPC_IA_SET_FW_CTXT, 0);
+	if (retval) {
+		pr_err("Can't allocate block/msg. No restore fw_context\n");
+		return;
+	}
+
+	sst_drv_ctx->sst_state = SST_FW_CTXT_RESTORE;
+	sst_fill_header(&msg->header, IPC_IA_SET_FW_CTXT, 1, 0);
+
+	msg->header.part.data = sizeof(fw_context) + sizeof(u32);
+	fw_context.address = virt_to_phys((void *)sst_drv_ctx->fw_cntx);
+	fw_context.size = sst_drv_ctx->fw_cntx_size;
+	memcpy(msg->mailbox_data, &msg->header, sizeof(u32));
+	memcpy(msg->mailbox_data + sizeof(u32),
+				&fw_context, sizeof(fw_context));
+	sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+	retval = sst_wait_timeout(sst_drv_ctx, block);
+	sst_free_block(sst_drv_ctx, block);
+	if (retval)
+		pr_err("sst_restore_fw_context..timeout!\n");
+	return;
+}
+
+/*
+ * sst_download_fw - download the audio firmware to DSP
+ *
+ * This function is called when the FW needs to be downloaded to SST DSP engine
+ */
+int sst_download_fw(void)
+{
+	int retval = 0;
+
+	retval = sst_load_fw();
+	if (retval)
+		return retval;
+	pr_debug("fw loaded successful!!!\n");
+
+	if (sst_drv_ctx->ops->restore_dsp_context)
+		sst_drv_ctx->ops->restore_dsp_context();
+	sst_drv_ctx->sst_state = SST_FW_RUNNING;
+	return retval;
+}
+
+int free_stream_context(unsigned int str_id)
+{
+	struct stream_info *stream;
+	int ret = 0;
+
+	stream = get_stream_info(str_id);
+	if (stream) {
+		/* str_id is valid, so stream is alloacted */
+		ret = sst_free_stream(str_id);
+		if (ret)
+			sst_clean_stream(&sst_drv_ctx->streams[str_id]);
+		return ret;
+	}
+	return ret;
+}
+
+/*
+ * sst_send_algo_param - send LPE Mixer param to SST
+ *
+ * this function sends the algo parameter to sst dsp engine
+ */
+static int sst_send_algo_param(struct snd_ppp_params *algo_params)
+{
+	u32 header_size = 0;
+	struct ipc_post *msg = NULL;
+	u32 ipc_msg_size = sizeof(u32) + sizeof(*algo_params)
+			 - sizeof(algo_params->params) + algo_params->size;
+	u32 offset = 0;
+
+	if (ipc_msg_size > SST_MAILBOX_SIZE)
+		return -ENOMEM;
+	if (sst_create_ipc_msg(&msg, true))
+		return -ENOMEM;
+	sst_fill_header(&msg->header,
+			IPC_IA_ALG_PARAMS, 1, algo_params->str_id);
+	msg->header.part.data = sizeof(u32) + sizeof(*algo_params)
+			 - sizeof(algo_params->params) + algo_params->size;
+	memcpy(msg->mailbox_data, &msg->header, sizeof(u32));
+	offset = sizeof(u32);
+	header_size = sizeof(*algo_params) - sizeof(algo_params->params);
+	memcpy(msg->mailbox_data + sizeof(u32), algo_params,
+		sizeof(*algo_params) - sizeof(algo_params->params));
+	offset += header_size;
+	memcpy(msg->mailbox_data + offset , algo_params->params,
+			algo_params->size);
+	sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+	return 0;
+}
+
+static int sst_send_lpe_mixer_algo_params(void)
+{
+	struct snd_ppp_params algo_param;
+	struct snd_ppp_mixer_params mixer_param;
+	unsigned int input_mixer, stream_device_id;
+	int retval = 0;
+
+	retval = intel_sst_check_device();
+	if (retval) {
+		pr_err("sst_check_device failed %d\n", retval);
+		return retval;
+	}
+
+	mutex_lock(&sst_drv_ctx->mixer_ctrl_lock);
+	input_mixer = (sst_drv_ctx->device_input_mixer)
+				& SST_INPUT_STREAM_MIXED;
+	pr_debug("Input Mixer settings %d", input_mixer);
+	stream_device_id = sst_drv_ctx->device_input_mixer - input_mixer;
+	algo_param.algo_id = SST_ALGO_MIXER;
+	algo_param.str_id = stream_device_id;
+	algo_param.enable = 1;
+	algo_param.operation = SST_SET_ALGO;
+	algo_param.size = sizeof(mixer_param);
+	mixer_param.type = SST_ALGO_PARAM_MIXER_STREAM_CFG;
+	mixer_param.input_stream_bitmap = input_mixer;
+	mixer_param.size = sizeof(input_mixer);
+	algo_param.params = &mixer_param;
+	mutex_unlock(&sst_drv_ctx->mixer_ctrl_lock);
+	pr_debug("setting pp param\n");
+	pr_debug("Algo ID %d Str id %d Enable %d Size %d\n",
+			algo_param.algo_id, algo_param.str_id,
+			algo_param.enable, algo_param.size);
+	sst_send_algo_param(&algo_param);
+	sst_pm_runtime_put(sst_drv_ctx);
+	return retval;
+}
+
+/*
+ * sst_get_stream_allocated - this function gets a stream allocated with
+ * the given params
+ *
+ * @str_param : stream params
+ * @lib_dnld : pointer to pointer of lib downlaod struct
+ *
+ * This creates new stream id for a stream, in case lib is to be downloaded to
+ * DSP, it downloads that
+ */
+int sst_get_stream_allocated(struct snd_sst_params *str_param,
+		struct snd_sst_lib_download **lib_dnld)
+{
+	int retval, str_id;
+	struct sst_block *block;
+	struct snd_sst_alloc_response *response;
+	struct stream_info *str_info;
+
+	pr_debug("In %s\n", __func__);
+	block = sst_create_block(sst_drv_ctx, 0, 0);
+	if (block == NULL)
+		return -ENOMEM;
+
+	retval = sst_drv_ctx->ops->alloc_stream((char *) str_param, block);
+	str_id = retval;
+	if (retval < 0) {
+		pr_err("sst_alloc_stream failed %d\n", retval);
+		goto free_block;
+	}
+	pr_debug("Stream allocated %d\n", retval);
+	str_info = get_stream_info(str_id);
+	if (str_info == NULL) {
+		pr_err("get stream info returned null\n");
+		str_id = -EINVAL;
+		goto free_block;
+	}
+
+	/* Block the call for reply */
+	retval = sst_wait_timeout(sst_drv_ctx, block);
+	if (block->data) {
+		response = (struct snd_sst_alloc_response *)block->data;
+		retval = response->str_type.result;
+		if (!retval)
+			goto free_block;
+
+		pr_err("sst: FW alloc failed retval %d\n", retval);
+		if (retval == SST_ERR_STREAM_IN_USE) {
+			pr_err("sst:FW not in clean state, send free for:%d\n",
+					str_id);
+			sst_free_stream(str_id);
+			*lib_dnld = NULL;
+		}
+		if (retval == SST_LIB_ERR_LIB_DNLD_REQUIRED) {
+			*lib_dnld = kzalloc(sizeof(**lib_dnld), GFP_KERNEL);
+			if (*lib_dnld == NULL) {
+				str_id = -ENOMEM;
+				goto free_block;
+			}
+			memcpy(*lib_dnld, &response->lib_dnld, sizeof(**lib_dnld));
+			sst_clean_stream(str_info);
+		} else {
+			*lib_dnld = NULL;
+		}
+		str_id = -retval;
+	} else if (retval != 0) {
+		pr_err("sst: FW alloc failed retval %d\n", retval);
+		/* alloc failed, so reset the state to uninit */
+		str_info->status = STREAM_UN_INIT;
+		str_id = retval;
+	}
+free_block:
+	sst_free_block(sst_drv_ctx, block);
+	return str_id; /*will ret either error (in above if) or correct str id*/
+}
+
+/*
+ * sst_get_sfreq - this function returns the frequency of the stream
+ *
+ * @str_param : stream params
+ */
+int sst_get_sfreq(struct snd_sst_params *str_param)
+{
+	switch (str_param->codec) {
+	case SST_CODEC_TYPE_PCM:
+		return str_param->sparams.uc.pcm_params.sfreq;
+	case SST_CODEC_TYPE_AAC:
+		return str_param->sparams.uc.aac_params.externalsr;
+	case SST_CODEC_TYPE_MP3:
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+/*
+ * sst_get_sfreq - this function returns the frequency of the stream
+ *
+ * @str_param : stream params
+ */
+int sst_get_num_channel(struct snd_sst_params *str_param)
+{
+	switch (str_param->codec) {
+	case SST_CODEC_TYPE_PCM:
+		return str_param->sparams.uc.pcm_params.num_chan;
+	case SST_CODEC_TYPE_MP3:
+		return str_param->sparams.uc.mp3_params.num_chan;
+	case SST_CODEC_TYPE_AAC:
+		return str_param->sparams.uc.aac_params.num_chan;
+	default:
+		return -EINVAL;
+	}
+}
+
+/*
+ * sst_get_stream - this function prepares for stream allocation
+ *
+ * @str_param : stream param
+ */
+int sst_get_stream(struct snd_sst_params *str_param)
+{
+	int retval;
+	struct stream_info *str_info;
+	struct snd_sst_lib_download *lib_dnld;
+
+	pr_debug("In %s\n", __func__);
+	/* stream is not allocated, we are allocating */
+	retval = sst_get_stream_allocated(str_param, &lib_dnld);
+
+	if (retval == -(SST_LIB_ERR_LIB_DNLD_REQUIRED)) {
+		/* codec download is required */
+
+		pr_debug("Codec is required.... trying that\n");
+		if (lib_dnld == NULL) {
+			pr_err("lib download null!!! abort\n");
+			return -EIO;
+		}
+
+		retval = sst_load_library(lib_dnld, str_param->ops);
+		kfree(lib_dnld);
+
+		if (!retval) {
+			pr_debug("codec was downloaded successfully\n");
+
+			retval = sst_get_stream_allocated(str_param, &lib_dnld);
+			if (retval <= 0) {
+				retval = -EIO;
+				goto err;
+			}
+
+			pr_debug("Alloc done stream id %d\n", retval);
+		} else {
+			pr_debug("codec download failed\n");
+			retval = -EIO;
+			goto err;
+		}
+	} else if  (retval <= 0) {
+		retval = -EIO;
+		goto err;
+	}
+	/* store sampling freq */
+	str_info = &sst_drv_ctx->streams[retval];
+	str_info->sfreq = sst_get_sfreq(str_param);
+
+err:
+	return retval;
+}
+
+/**
+* intel_sst_check_device - checks SST device
+*
+* This utility function checks the state of SST device and downlaods FW if
+* not done, or resumes the device if suspended
+*/
+int intel_sst_check_device(void)
+{
+	int retval = 0;
+
+	pr_debug("In %s\n", __func__);
+
+	pm_runtime_get_sync(sst_drv_ctx->dev);
+	atomic_inc(&sst_drv_ctx->pm_usage_count);
+
+	pr_debug("%s: count is %d now\n", __func__,
+				atomic_read(&sst_drv_ctx->pm_usage_count));
+
+	mutex_lock(&sst_drv_ctx->sst_lock);
+	if (sst_drv_ctx->sst_state == SST_UN_INIT)
+		sst_drv_ctx->sst_state = SST_START_INIT;
+
+	if (sst_drv_ctx->sst_state == SST_START_INIT ||
+		sst_drv_ctx->sst_state == SST_FW_LIB_LOAD) {
+
+		/* FW is not downloaded */
+		pr_debug("DSP Downloading FW now...\n");
+		retval = sst_download_fw();
+		if (retval) {
+			pr_err("FW download fail %x\n", retval);
+			sst_drv_ctx->sst_state = SST_UN_INIT;
+			mutex_unlock(&sst_drv_ctx->sst_lock);
+			sst_pm_runtime_put(sst_drv_ctx);
+			return retval;
+		}
+	}
+	mutex_unlock(&sst_drv_ctx->sst_lock);
+	return retval;
+}
+
+void sst_process_mad_ops(struct work_struct *work)
+{
+
+	struct mad_ops_wq *mad_ops =
+			container_of(work, struct mad_ops_wq, wq);
+	int retval = 0;
+
+	switch (mad_ops->control_op) {
+	case SST_SND_PAUSE:
+		retval = sst_pause_stream(mad_ops->stream_id);
+		break;
+	case SST_SND_RESUME:
+		retval = sst_resume_stream(mad_ops->stream_id);
+		break;
+	default:
+		pr_err(" wrong control_ops reported\n");
+	}
+	if (retval)
+		pr_err("%s(): op: %d, retval: %d\n",
+				__func__, mad_ops->control_op, retval);
+	kfree(mad_ops);
+	return;
+}
+
+static int sst_power_control(bool state)
+{
+	pr_debug("%s for %d", __func__, state);
+
+	/* should we do ref count here, or rely on pcm handle?? */
+	if (state == true)
+		return intel_sst_check_device();
+	else
+		return sst_pm_runtime_put(sst_drv_ctx);
+}
+/*
+ * sst_open_pcm_stream - Open PCM interface
+ *
+ * @str_param: parameters of pcm stream
+ *
+ * This function is called by MID sound card driver to open
+ * a new pcm interface
+ */
+static int sst_open_pcm_stream(struct snd_sst_params *str_param)
+{
+	int retval;
+
+	if (!str_param)
+		return -EINVAL;
+
+	pr_debug("%s: doing rtpm_get\n", __func__);
+
+	retval = intel_sst_check_device();
+
+	if (retval)
+		return retval;
+	retval = sst_get_stream(str_param);
+	if (retval > 0) {
+		sst_drv_ctx->stream_cnt++;
+	} else {
+		pr_err("sst_get_stream returned err %d\n", retval);
+		sst_pm_runtime_put(sst_drv_ctx);
+	}
+
+	return retval;
+}
+
+static int sst_cdev_open(struct snd_sst_params *str_params,
+		struct sst_compress_cb *cb)
+{
+	int str_id, retval;
+	struct stream_info *stream;
+
+	pr_debug("%s: doing rtpm_get\n", __func__);
+
+	retval = intel_sst_check_device();
+	if (retval)
+		return retval;
+
+	str_id = sst_get_stream(str_params);
+	if (str_id > 0) {
+		pr_debug("stream allocated in sst_cdev_open %d\n", str_id);
+		stream = &sst_drv_ctx->streams[str_id];
+		stream->compr_cb = cb->compr_cb;
+		stream->compr_cb_param = cb->param;
+		stream->drain_notify = cb->drain_notify;
+		stream->drain_cb_param = cb->drain_cb_param;
+	} else {
+		pr_err("stream encountered error during alloc %d\n", str_id);
+		str_id = -EINVAL;
+		sst_pm_runtime_put(sst_drv_ctx);
+	}
+	return str_id;
+}
+
+static int sst_cdev_close(unsigned int str_id)
+{
+	int retval;
+	struct stream_info *stream;
+
+	pr_debug("%s: Entry\n", __func__);
+	stream = get_stream_info(str_id);
+	if (!stream) {
+		pr_err("stream info is NULL for str %d!!!\n", str_id);
+		return -EINVAL;
+	}
+
+	if (stream->status == STREAM_RESET) {
+		/* silently fail here as we have cleaned the stream */
+		pr_debug("stream in reset state...\n");
+		stream->status = STREAM_UN_INIT;
+
+		retval = 0;
+		goto put;
+	}
+
+	retval = sst_free_stream(str_id);
+put:
+	stream->compr_cb_param = NULL;
+	stream->compr_cb = NULL;
+
+	/* The free_stream will return a error if there is no stream to free,
+	(i.e. the alloc failure case). And in this case the open does a put in
+	the error scenario, so skip in this case.
+		In the close we need to handle put in the success scenario and
+	the timeout error(EBUSY) scenario. */
+	if (!retval || (retval == -EBUSY))
+		sst_pm_runtime_put(sst_drv_ctx);
+	else
+		pr_err("%s: free stream returned err %d\n", __func__, retval);
+
+	pr_debug("%s: End\n", __func__);
+	return retval;
+
+}
+
+static int sst_cdev_ack(unsigned int str_id, unsigned long bytes)
+{
+	struct stream_info *stream;
+	struct snd_sst_tstamp fw_tstamp = {0,};
+	int offset;
+	void __iomem *addr;
+
+	pr_debug("sst:  ackfor %d\n", str_id);
+	stream = get_stream_info(str_id);
+	if (!stream)
+		return -EINVAL;
+
+	/* update bytes sent */
+	stream->cumm_bytes += bytes;
+	pr_debug("bytes copied %d inc by %ld\n", stream->cumm_bytes, bytes);
+
+	memcpy_fromio(&fw_tstamp,
+		((void *)(sst_drv_ctx->mailbox + sst_drv_ctx->tstamp)
+		+(str_id * sizeof(fw_tstamp))),
+		sizeof(fw_tstamp));
+
+	fw_tstamp.bytes_copied = stream->cumm_bytes;
+	pr_debug("bytes sent to fw %llu inc by %ld\n", fw_tstamp.bytes_copied,
+							 bytes);
+
+	addr =  ((void *)(sst_drv_ctx->mailbox + sst_drv_ctx->tstamp)) +
+			(str_id * sizeof(fw_tstamp));
+	offset =  offsetof(struct snd_sst_tstamp, bytes_copied);
+	sst_shim_write(addr, offset, fw_tstamp.bytes_copied);
+	return 0;
+
+}
+
+static int sst_cdev_set_metadata(unsigned int str_id,
+				struct snd_compr_metadata *metadata)
+{
+	int retval = 0, pvt_id, len;
+	struct ipc_post *msg = NULL;
+	struct stream_info *str_info;
+	struct ipc_dsp_hdr dsp_hdr;
+
+	pr_debug("set metadata for stream %d\n", str_id);
+
+	str_info = get_stream_info(str_id);
+	if (!str_info)
+		return -EINVAL;
+
+	if (sst_create_ipc_msg(&msg, 1))
+		return -ENOMEM;
+
+	if (!sst_drv_ctx->use_32bit_ops) {
+		pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+		pr_debug("pvt id = %d\n", pvt_id);
+		pr_debug("pipe id = %d\n", str_info->pipe_id);
+		sst_fill_header_mrfld(&msg->mrfld_header,
+			IPC_CMD, str_info->task_id, 1, pvt_id);
+
+		len = sizeof(*metadata) + sizeof(dsp_hdr);
+		msg->mrfld_header.p.header_low_payload = len;
+		sst_fill_header_dsp(&dsp_hdr, IPC_IA_SET_STREAM_PARAMS_MRFLD,
+				str_info->pipe_id, sizeof(*metadata));
+		memcpy(msg->mailbox_data, &dsp_hdr, sizeof(dsp_hdr));
+		memcpy(msg->mailbox_data + sizeof(dsp_hdr),
+				metadata, sizeof(*metadata));
+	} else {
+		sst_fill_header(&msg->header, IPC_IA_SET_STREAM_PARAMS,
+					1, str_id);
+		msg->header.part.data = sizeof(u32) + sizeof(*metadata);
+		memcpy(msg->mailbox_data, &msg->header, sizeof(u32));
+		memcpy(msg->mailbox_data + sizeof(u32),
+				metadata, sizeof(*metadata));
+	}
+
+	sst_drv_ctx->ops->sync_post_message(msg);
+	return retval;
+}
+
+static int sst_cdev_control(unsigned int cmd, unsigned int str_id)
+{
+	pr_debug("recieved cmd %d on stream %d\n", cmd, str_id);
+
+	if (sst_drv_ctx->sst_state == SST_UN_INIT)
+		return 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		return sst_pause_stream(str_id);
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		return sst_resume_stream(str_id);
+	case SNDRV_PCM_TRIGGER_START: {
+		struct stream_info *str_info;
+		str_info = get_stream_info(str_id);
+		if (!str_info)
+			return -EINVAL;
+		str_info->prev = str_info->status;
+		str_info->status = STREAM_RUNNING;
+		return sst_start_stream(str_id);
+	}
+	case SNDRV_PCM_TRIGGER_STOP:
+		return sst_drop_stream(str_id);
+	case SND_COMPR_TRIGGER_DRAIN:
+		return sst_drain_stream(str_id, false);
+	case SND_COMPR_TRIGGER_NEXT_TRACK:
+		return sst_next_track();
+	case SND_COMPR_TRIGGER_PARTIAL_DRAIN:
+		return sst_drain_stream(str_id, true);
+	default:
+		return -EINVAL;
+	}
+}
+
+static int sst_cdev_tstamp(unsigned int str_id, struct snd_compr_tstamp *tstamp)
+{
+	struct snd_sst_tstamp fw_tstamp = {0,};
+	struct stream_info *stream;
+
+	memcpy_fromio(&fw_tstamp,
+		((void *)(sst_drv_ctx->mailbox + sst_drv_ctx->tstamp)
+		+(str_id * sizeof(fw_tstamp))),
+		sizeof(fw_tstamp));
+
+	stream = get_stream_info(str_id);
+	if (!stream)
+		return -EINVAL;
+	pr_debug("rb_counter %llu in bytes\n", fw_tstamp.ring_buffer_counter);
+
+	tstamp->copied_total = fw_tstamp.ring_buffer_counter;
+	tstamp->pcm_frames = fw_tstamp.frames_decoded;
+	tstamp->pcm_io_frames = div_u64(fw_tstamp.hardware_counter,
+			(u64)((stream->num_ch) * SST_GET_BYTES_PER_SAMPLE(24)));
+	tstamp->sampling_rate = fw_tstamp.sampling_frequency;
+	pr_debug("PCM  = %u\n", tstamp->pcm_io_frames);
+	pr_debug("Pointer Query on strid = %d  copied_total %d, decodec %d\n",
+		str_id, tstamp->copied_total, tstamp->pcm_frames);
+	pr_debug("rendered %d\n", tstamp->pcm_io_frames);
+	return 0;
+}
+
+static int sst_cdev_caps(struct snd_compr_caps *caps)
+{
+	caps->num_codecs = NUM_CODEC;
+	caps->min_fragment_size = MIN_FRAGMENT_SIZE;  /* 50KB */
+	caps->max_fragment_size = MAX_FRAGMENT_SIZE;  /* 1024KB */
+	caps->min_fragments = MIN_FRAGMENT;
+	caps->max_fragments = MAX_FRAGMENT;
+	caps->codecs[0] = SND_AUDIOCODEC_MP3;
+	caps->codecs[1] = SND_AUDIOCODEC_AAC;
+	return 0;
+}
+
+static int sst_cdev_codec_caps(struct snd_compr_codec_caps *codec)
+{
+
+	if (codec->codec == SND_AUDIOCODEC_MP3) {
+		codec->num_descriptors = 2;
+		codec->descriptor[0].max_ch = 2;
+		codec->descriptor[0].sample_rates[0] = SNDRV_PCM_RATE_8000_48000;
+		codec->descriptor[0].bit_rate[0] = 320; /* 320kbps */
+		codec->descriptor[0].bit_rate[1] = 192;
+		codec->descriptor[0].num_bitrates = 2;
+		codec->descriptor[0].profiles = 0;
+		codec->descriptor[0].modes = SND_AUDIOCHANMODE_MP3_STEREO;
+		codec->descriptor[0].formats = 0;
+	} else if (codec->codec == SND_AUDIOCODEC_AAC) {
+		codec->num_descriptors = 2;
+		codec->descriptor[1].max_ch = 2;
+		codec->descriptor[1].sample_rates[0] = SNDRV_PCM_RATE_8000_48000;
+		codec->descriptor[1].bit_rate[0] = 320; /* 320kbps */
+		codec->descriptor[1].bit_rate[1] = 192;
+		codec->descriptor[1].num_bitrates = 2;
+		codec->descriptor[1].profiles = 0;
+		codec->descriptor[1].modes = 0;
+		codec->descriptor[1].formats =
+			(SND_AUDIOSTREAMFORMAT_MP4ADTS |
+				SND_AUDIOSTREAMFORMAT_RAW);
+	} else {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void sst_cdev_fragment_elapsed(int str_id)
+{
+	struct stream_info *stream;
+
+	pr_debug("fragment elapsed from firmware for str_id %d\n", str_id);
+	stream = &sst_drv_ctx->streams[str_id];
+	if (stream->compr_cb)
+		stream->compr_cb(stream->compr_cb_param);
+}
+
+/*
+ * sst_close_pcm_stream - Close PCM interface
+ *
+ * @str_id: stream id to be closed
+ *
+ * This function is called by MID sound card driver to close
+ * an existing pcm interface
+ */
+static int sst_close_pcm_stream(unsigned int str_id)
+{
+	struct stream_info *stream;
+	int retval = 0;
+
+	pr_debug("%s: Entry\n", __func__);
+	stream = get_stream_info(str_id);
+	if (!stream) {
+		pr_err("stream info is NULL for str %d!!!\n", str_id);
+		return -EINVAL;
+	}
+
+	if (stream->status == STREAM_RESET) {
+		/* silently fail here as we have cleaned the stream */
+		pr_debug("stream in reset state...\n");
+
+		retval = 0;
+		goto put;
+	}
+
+	retval = free_stream_context(str_id);
+put:
+	stream->pcm_substream = NULL;
+	stream->status = STREAM_UN_INIT;
+	stream->period_elapsed = NULL;
+	sst_drv_ctx->stream_cnt--;
+
+	/* The free_stream will return a error if there is no stream to free,
+	(i.e. the alloc failure case). And in this case the open does a put in
+	the error scenario, so skip in this case.
+		In the close we need to handle put in the success scenario and
+	the timeout error(EBUSY) scenario. */
+	if (!retval || (retval == -EBUSY))
+		sst_pm_runtime_put(sst_drv_ctx);
+	else
+		pr_err("%s: free stream returned err %d\n", __func__, retval);
+
+	pr_debug("%s: Exit\n", __func__);
+	return 0;
+}
+
+int sst_send_sync_msg(int ipc, int str_id)
+{
+	struct ipc_post *msg = NULL;
+
+	if (sst_create_ipc_msg(&msg, false))
+		return -ENOMEM;
+	sst_fill_header(&msg->header, ipc, 0, str_id);
+	return sst_drv_ctx->ops->sync_post_message(msg);
+}
+
+static inline int sst_calc_tstamp(struct pcm_stream_info *info,
+		struct snd_pcm_substream *substream,
+		struct snd_sst_tstamp *fw_tstamp)
+{
+	size_t delay_bytes, delay_frames;
+	size_t buffer_sz;
+	u32 pointer_bytes, pointer_samples;
+
+	pr_debug("mrfld ring_buffer_counter %llu in bytes\n",
+			fw_tstamp->ring_buffer_counter);
+	pr_debug("mrfld hardware_counter %llu in bytes\n",
+			 fw_tstamp->hardware_counter);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		delay_bytes = (size_t) (fw_tstamp->ring_buffer_counter -
+					fw_tstamp->hardware_counter);
+	else
+		delay_bytes = (size_t) (fw_tstamp->hardware_counter -
+					fw_tstamp->ring_buffer_counter);
+	delay_frames = bytes_to_frames(substream->runtime, delay_bytes);
+	buffer_sz = snd_pcm_lib_buffer_bytes(substream);
+	div_u64_rem(fw_tstamp->ring_buffer_counter, buffer_sz, &pointer_bytes);
+	pointer_samples = bytes_to_samples(substream->runtime, pointer_bytes);
+
+	pr_debug("pcm delay %zu in bytes\n", delay_bytes);
+
+	info->buffer_ptr = pointer_samples / substream->runtime->channels;
+
+	info->pcm_delay = delay_frames / substream->runtime->channels;
+	pr_debug("buffer ptr %llu pcm_delay rep: %llu\n",
+			info->buffer_ptr, info->pcm_delay);
+	return 0;
+}
+
+static int sst_read_timestamp(struct pcm_stream_info *info)
+{
+	struct stream_info *stream;
+	struct snd_pcm_substream *substream;
+	struct snd_sst_tstamp fw_tstamp;
+	unsigned int str_id;
+
+	str_id = info->str_id;
+	stream = get_stream_info(str_id);
+	if (!stream)
+		return -EINVAL;
+
+	if (!stream->pcm_substream)
+		return -EINVAL;
+	substream = stream->pcm_substream;
+
+	memcpy_fromio(&fw_tstamp,
+		((void *)(sst_drv_ctx->mailbox + sst_drv_ctx->tstamp)
+			+ (str_id * sizeof(fw_tstamp))),
+		sizeof(fw_tstamp));
+	return sst_calc_tstamp(info, substream, &fw_tstamp);
+}
+
+/*
+ * sst_device_control - Set Control params
+ *
+ * @cmd: control cmd to be set
+ * @arg: command argument
+ *
+ * This function is called by MID sound card driver to set
+ * SST/Sound card controls for an opened stream.
+ * This is registered with MID driver
+ */
+static int sst_device_control(int cmd, void *arg)
+{
+	int retval = 0, str_id = 0;
+
+	if (sst_drv_ctx->sst_state == SST_UN_INIT)
+		return 0;
+
+	switch (cmd) {
+	case SST_SND_PAUSE:
+	case SST_SND_RESUME: {
+		struct mad_ops_wq *work = kzalloc(sizeof(*work), GFP_ATOMIC);
+		if (!work)
+			return -ENOMEM;
+		INIT_WORK(&work->wq, sst_process_mad_ops);
+		work->control_op = cmd;
+		work->stream_id = *(int *)arg;
+		queue_work(sst_drv_ctx->mad_wq, &work->wq);
+		break;
+	}
+	case SST_SND_START: {
+		struct stream_info *str_info;
+		int ipc;
+		str_id = *(int *)arg;
+		str_info = get_stream_info(str_id);
+		if (!str_info)
+			return -EINVAL;
+		ipc = IPC_IA_START_STREAM;
+		str_info->prev = str_info->status;
+		str_info->status = STREAM_RUNNING;
+		sst_start_stream(str_id);
+		break;
+	}
+	case SST_SND_DROP: {
+		struct stream_info *str_info;
+		int ipc;
+		str_id = *(int *)arg;
+		str_info = get_stream_info(str_id);
+		if (!str_info)
+			return -EINVAL;
+		ipc = IPC_IA_DROP_STREAM;
+		str_info->prev = STREAM_UN_INIT;
+		str_info->status = STREAM_INIT;
+		if (sst_drv_ctx->use_32bit_ops)
+			retval = sst_send_sync_msg(ipc, str_id);
+		else
+			retval = sst_drop_stream(str_id);
+		break;
+	}
+	case SST_SND_STREAM_INIT: {
+		struct pcm_stream_info *str_info;
+		struct stream_info *stream;
+
+		pr_debug("stream init called\n");
+		str_info = (struct pcm_stream_info *)arg;
+		str_id = str_info->str_id;
+		stream = get_stream_info(str_id);
+		if (!stream) {
+			retval = -EINVAL;
+			break;
+		}
+		pr_debug("setting the period ptrs\n");
+		stream->pcm_substream = str_info->mad_substream;
+		stream->period_elapsed = str_info->period_elapsed;
+		stream->sfreq = str_info->sfreq;
+		stream->prev = stream->status;
+		stream->status = STREAM_INIT;
+		pr_debug("pcm_substream %p, period_elapsed %p, sfreq %d, status %d\n",
+				stream->pcm_substream, stream->period_elapsed, stream->sfreq, stream->status);
+		break;
+	}
+
+	case SST_SND_BUFFER_POINTER: {
+		struct pcm_stream_info *stream_info;
+
+		stream_info = (struct pcm_stream_info *)arg;
+		retval = sst_read_timestamp(stream_info);
+		pr_debug("pointer %llu, delay %llu\n",
+			stream_info->buffer_ptr, stream_info->pcm_delay);
+		break;
+	}
+	default:
+		/* Illegal case */
+		pr_warn("illegal req\n");
+		return -EINVAL;
+	}
+
+	return retval;
+}
+
+/*
+ * sst_copy_runtime_param - copy runtime params from src to dst
+ *				 structure.
+ *
+ *@dst: destination runtime structure
+ *@src: source runtime structure
+ *
+ * This helper function is called to copy the runtime parameter
+ * structure.
+*/
+static int sst_copy_runtime_param(struct snd_sst_runtime_params *dst,
+			struct snd_sst_runtime_params *src)
+{
+	dst->type = src->type;
+	dst->str_id = src->str_id;
+	dst->size = src->size;
+	if (dst->addr) {
+		pr_err("mem allocated in prev setting, use the same memory\n");
+		return -EINVAL;
+	}
+	dst->addr = kzalloc(dst->size, GFP_KERNEL);
+	if (!dst->addr)
+		return -ENOMEM;
+	memcpy(dst->addr, src->addr, dst->size);
+	return 0;
+}
+/*
+ * sst_set_generic_params - Set generic params
+ *
+ * @cmd: control cmd to be set
+ * @arg: command argument
+ *
+ * This function is called by MID sound card driver to configure
+ * SST runtime params.
+ */
+static int sst_set_generic_params(enum sst_controls cmd, void *arg)
+{
+	int ret_val = 0;
+	pr_debug("Enter:%s, cmd:%d\n", __func__, cmd);
+
+	if (NULL == arg)
+		return -EINVAL;
+
+	switch (cmd) {
+	case SST_SET_RUNTIME_PARAMS: {
+		struct snd_sst_runtime_params *src;
+		struct snd_sst_runtime_params *dst;
+
+		src = (struct snd_sst_runtime_params *)arg;
+		dst = &(sst_drv_ctx->runtime_param.param);
+		ret_val = sst_copy_runtime_param(dst, src);
+		break;
+		}
+	case SST_SET_ALGO_PARAMS: {
+		unsigned int device_input_mixer = *((unsigned int *)arg);
+		pr_debug("LPE mixer algo param set %x\n", device_input_mixer);
+		mutex_lock(&sst_drv_ctx->mixer_ctrl_lock);
+		sst_drv_ctx->device_input_mixer = device_input_mixer;
+		mutex_unlock(&sst_drv_ctx->mixer_ctrl_lock);
+		ret_val = sst_send_lpe_mixer_algo_params();
+		break;
+	}
+	case SST_SET_BYTE_STREAM: {
+		ret_val = intel_sst_check_device();
+		if (ret_val)
+			return ret_val;
+
+		ret_val = sst_send_byte_stream_mrfld(arg);
+		sst_pm_runtime_put(sst_drv_ctx);
+		break;
+	}
+	case SST_GET_PROBE_BYTE_STREAM: {
+		struct snd_sst_probe_bytes *prb_bytes = (struct snd_sst_probe_bytes *)arg;
+
+		if (sst_drv_ctx->probe_bytes) {
+			prb_bytes->len = sst_drv_ctx->probe_bytes->len;
+			memcpy(prb_bytes->bytes, &sst_drv_ctx->probe_bytes->bytes, prb_bytes->len);
+		}
+		break;
+	}
+	case SST_SET_PROBE_BYTE_STREAM: {
+		struct snd_sst_probe_bytes *prb_bytes = (struct snd_sst_probe_bytes *)arg;
+
+		if (sst_drv_ctx->probe_bytes) {
+			sst_drv_ctx->probe_bytes->len = prb_bytes->len;
+			memcpy(&sst_drv_ctx->probe_bytes->bytes, prb_bytes->bytes, prb_bytes->len);
+		}
+
+		ret_val = intel_sst_check_device();
+		if (ret_val)
+			return ret_val;
+
+		ret_val = sst_send_probe_bytes(sst_drv_ctx);
+		break;
+	}
+	case SST_SET_VTSV_INFO: {
+		ret_val = intel_sst_check_device();
+		if (ret_val)
+			return ret_val;
+
+		ret_val = sst_send_vtsv_data_to_fw(sst_drv_ctx);
+		if (ret_val)
+			pr_err("vtsv data send failed\n");
+		sst_pm_runtime_put(sst_drv_ctx);
+		break;
+	}
+	default:
+		pr_err("Invalid cmd request:%d\n", cmd);
+		ret_val = -EINVAL;
+	}
+	return ret_val;
+}
+
+static struct sst_ops pcm_ops = {
+	.open = sst_open_pcm_stream,
+	.device_control = sst_device_control,
+	.set_generic_params = sst_set_generic_params,
+	.close = sst_close_pcm_stream,
+	.power = sst_power_control,
+};
+
+static struct compress_sst_ops compr_ops = {
+	.open = sst_cdev_open,
+	.close = sst_cdev_close,
+	.control = sst_cdev_control,
+	.tstamp = sst_cdev_tstamp,
+	.ack = sst_cdev_ack,
+	.get_caps = sst_cdev_caps,
+	.get_codec_caps = sst_cdev_codec_caps,
+	.set_metadata = sst_cdev_set_metadata,
+};
+
+
+static struct sst_device sst_dsp_device = {
+	.name = "Intel(R) SST LPE",
+	.dev = NULL,
+	.ops = &pcm_ops,
+	.compr_ops = &compr_ops,
+};
+
+/*
+ * register_sst - function to register DSP
+ *
+ * This functions registers DSP with the platform driver
+ */
+int register_sst(struct device *dev)
+{
+	int ret_val;
+	sst_dsp_device.dev = dev;
+	ret_val = sst_register_dsp(&sst_dsp_device);
+	if (ret_val)
+		pr_err("Unable to register DSP with platform driver\n");
+
+	return ret_val;
+}
+
+int unregister_sst(struct device *dev)
+{
+	return sst_unregister_dsp(&sst_dsp_device);
+}
diff --git a/sound/soc/intel/sst/sst_dsp.c b/sound/soc/intel/sst/sst_dsp.c
new file mode 100644
index 0000000..29950f9
--- /dev/null
+++ b/sound/soc/intel/sst/sst_dsp.c
@@ -0,0 +1,1992 @@
+/*
+ *  sst_dsp.c - Intel SST Driver for audio engine
+ *
+ *  Copyright (C) 2008-10	Intel Corp
+ *  Authors:	Vinod Koul <vinod.koul@intel.com>
+ *		Harsha Priya <priya.harsha@intel.com>
+ *		Dharageswari R <dharageswari.r@intel.com>
+ *		KP Jeeja <jeeja.kp@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This file contains all dsp controlling functions like firmware download,
+ * setting/resetting dsp cores, etc
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/firmware.h>
+#include <linux/dmaengine.h>
+#include <linux/intel_mid_dma.h>
+#include <linux/pm_qos.h>
+#include <linux/intel_mid_pm.h>
+#include <linux/elf.h>
+#include "../sst_platform.h"
+#include "../platform_ipc_v2.h"
+#include "sst.h"
+#include "sst_trace.h"
+
+#ifndef CONFIG_X86_64
+#define MEMCPY_TOIO memcpy_toio
+#else
+#define MEMCPY_TOIO memcpy32_toio
+#endif
+
+/**
+ * Add here all the static librairies to be downloaded at bootup
+ */
+static struct sst_module_info sst_modules_mrfld[] = {};
+
+static struct sst_module_info sst_modules_byt[] = {
+	{"mp3_dec", SST_CODEC_TYPE_MP3, 0, SST_LIB_NOT_FOUND},
+	{"aac_dec", SST_CODEC_TYPE_AAC, 0, SST_LIB_NOT_FOUND},
+};
+
+/**
+ * memcpy32_toio: Copy using writel commands
+ *
+ * This is needed because the hardware does not support
+ * 64-bit moveq insructions while writing to PCI MMIO
+ */
+void memcpy32_toio(void *dst, const void *src, int count)
+{
+	int i;
+	const u32 *src_32 = src;
+	u32 *dst_32 = dst;
+
+	for (i = 0; i < count/sizeof(u32); i++)
+		writel(*src_32++, dst_32++);
+}
+
+/**
+ * intel_sst_reset_dsp_medfield - Resetting SST DSP
+ *
+ * This resets DSP in case of Medfield platfroms
+ */
+int intel_sst_reset_dsp_mfld(void)
+{
+	union config_status_reg csr;
+
+	pr_debug("Resetting the DSP in medfield\n");
+	mutex_lock(&sst_drv_ctx->csr_lock);
+	csr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);
+	csr.full |= 0x382;
+	csr.part.run_stall = 0x1;
+	sst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);
+	mutex_unlock(&sst_drv_ctx->csr_lock);
+
+	return 0;
+}
+
+/**
+ * sst_start_medfield - Start the SST DSP processor
+ *
+ * This starts the DSP in MRST platfroms
+ */
+int sst_start_mfld(void)
+{
+	union config_status_reg csr;
+
+	mutex_lock(&sst_drv_ctx->csr_lock);
+	csr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);
+	csr.part.bypass = 0;
+	sst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);
+	csr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);
+	csr.part.mfld_strb = 1;
+	sst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);
+	csr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);
+	csr.part.run_stall = 0;
+	csr.part.sst_reset = 0;
+	pr_debug("Starting the DSP_medfld %x\n", csr.full);
+	sst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);
+	pr_debug("Starting the DSP_medfld\n");
+	mutex_unlock(&sst_drv_ctx->csr_lock);
+
+	return 0;
+}
+/**
+ * intel_sst_reset_dsp_mrfld - Resetting SST DSP
+ *
+ * This resets DSP in case of MRFLD platfroms
+ */
+int intel_sst_reset_dsp_mrfld(void)
+{
+	union config_status_reg_mrfld csr;
+
+	pr_debug("sst: Resetting the DSP in mrfld\n");
+	mutex_lock(&sst_drv_ctx->csr_lock);
+	csr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);
+
+	pr_debug("value:0x%llx\n", csr.full);
+
+	csr.full |= 0x7;
+	sst_shim_write64(sst_drv_ctx->shim, SST_CSR, csr.full);
+	csr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);
+
+	pr_debug("value:0x%llx\n", csr.full);
+
+	csr.full &= ~(0x1);
+	sst_shim_write64(sst_drv_ctx->shim, SST_CSR, csr.full);
+
+	csr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);
+	pr_debug("value:0x%llx\n", csr.full);
+	mutex_unlock(&sst_drv_ctx->csr_lock);
+	return 0;
+}
+
+/**
+ * sst_start_merrifield - Start the SST DSP processor
+ *
+ * This starts the DSP in MERRIFIELD platfroms
+ */
+int sst_start_mrfld(void)
+{
+	union config_status_reg_mrfld csr;
+
+	pr_debug("sst: Starting the DSP in mrfld LALALALA\n");
+	mutex_lock(&sst_drv_ctx->csr_lock);
+	csr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);
+	pr_debug("value:0x%llx\n", csr.full);
+
+	csr.full |= 0x7;
+	sst_shim_write64(sst_drv_ctx->shim, SST_CSR, csr.full);
+
+	csr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);
+	pr_debug("value:0x%llx\n", csr.full);
+
+	csr.part.xt_snoop = 1;
+	csr.full &= ~(0x5);
+	sst_shim_write64(sst_drv_ctx->shim, SST_CSR, csr.full);
+
+	csr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);
+	pr_debug("sst: Starting the DSP_merrifield:%llx\n", csr.full);
+	mutex_unlock(&sst_drv_ctx->csr_lock);
+	return 0;
+}
+
+/**
+ * intel_sst_set_bypass - Sets/clears the bypass bits
+ *
+ * This sets/clears the bypass bits
+ */
+void intel_sst_set_bypass_mfld(bool set)
+{
+	union config_status_reg csr;
+
+	mutex_lock(&sst_drv_ctx->csr_lock);
+	csr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);
+	if (set == true)
+		csr.full |= 0x380;
+	else
+		csr.part.bypass = 0;
+	pr_debug("SetupByPass set %d Val 0x%x\n", set, csr.full);
+	sst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);
+	mutex_unlock(&sst_drv_ctx->csr_lock);
+
+}
+#define SST_CALC_DMA_DSTN(lpe_viewpt_rqd, ia_viewpt_addr, elf_paddr, \
+			lpe_viewpt_addr) ((lpe_viewpt_rqd) ? \
+		elf_paddr : (ia_viewpt_addr + elf_paddr - lpe_viewpt_addr))
+
+static int sst_fill_dstn(struct intel_sst_drv *sst, struct sst_info info,
+			Elf32_Phdr *pr, void **dstn, unsigned int *dstn_phys, int *mem_type)
+{
+#ifdef MRFLD_WORD_WA
+	/* work arnd-since only 4 byte align copying is only allowed for ICCM */
+	if ((pr->p_paddr >= info.iram_start) && (pr->p_paddr < info.iram_end)) {
+		size_t data_size = pr->p_filesz % SST_ICCM_BOUNDARY;
+
+		if (data_size)
+			pr->p_filesz += 4 - data_size;
+		*dstn = sst->iram + (pr->p_paddr - info.iram_start);
+		*dstn_phys = SST_CALC_DMA_DSTN(info.lpe_viewpt_rqd,
+				sst->iram_base, pr->p_paddr, info.iram_start);
+		*mem_type = 1;
+	}
+#else
+	if ((pr->p_paddr >= info.iram_start) &&
+	    (pr->p_paddr < info.iram_end)) {
+
+		*dstn = sst->iram + (pr->p_paddr - info.iram_start);
+		*dstn_phys = SST_CALC_DMA_DSTN(info.lpe_viewpt_rqd,
+				sst->iram_base, pr->p_paddr, info.iram_start);
+		*mem_type = 1;
+	}
+#endif
+	else if ((pr->p_paddr >= info.dram_start) &&
+		 (pr->p_paddr < info.dram_end)) {
+
+		*dstn = sst->dram + (pr->p_paddr - info.dram_start);
+		*dstn_phys = SST_CALC_DMA_DSTN(info.lpe_viewpt_rqd,
+				sst->dram_base, pr->p_paddr, info.dram_start);
+		*mem_type = 1;
+	} else if ((pr->p_paddr >= info.imr_start) &&
+		   (pr->p_paddr < info.imr_end)) {
+
+		*dstn = sst->ddr + (pr->p_paddr - info.imr_start);
+		*dstn_phys =  sst->ddr_base + pr->p_paddr - info.imr_start;
+		*mem_type = 0;
+	} else {
+	       return -EINVAL;
+	}
+	return 0;
+}
+
+static void sst_fill_info(struct intel_sst_drv *sst,
+			struct sst_info *info)
+{
+	/* first we setup addresses to be used for elf sections */
+	if (sst->info.iram_use) {
+		info->iram_start = sst->info.iram_start;
+		info->iram_end = sst->info.iram_end;
+	} else {
+		info->iram_start = sst->iram_base;
+		info->iram_end = sst->iram_end;
+	}
+	if (sst->info.dram_use) {
+		info->dram_start = sst->info.dram_start;
+		info->dram_end = sst->info.dram_end;
+	} else {
+		info->dram_start = sst->dram_base;
+		info->dram_end = sst->dram_end;
+	}
+	if (sst->info.imr_use) {
+		info->imr_start = sst->info.imr_start;
+		info->imr_end = sst->info.imr_end;
+	} else {
+		info->imr_start = relocate_imr_addr_mrfld(sst->ddr_base);
+		info->imr_end = relocate_imr_addr_mrfld(sst->ddr_end);
+	}
+
+	info->lpe_viewpt_rqd = sst->info.lpe_viewpt_rqd;
+	info->dma_max_len = sst->info.dma_max_len;
+	pr_debug("%s: dma_max_len 0x%x", __func__, info->dma_max_len);
+}
+
+static inline int sst_validate_elf(const struct firmware *sst_bin, bool dynamic)
+{
+	Elf32_Ehdr *elf;
+
+	BUG_ON(!sst_bin);
+
+	pr_debug("IN %s\n", __func__);
+
+	elf = (Elf32_Ehdr *)sst_bin->data;
+
+	if ((elf->e_ident[0] != 0x7F) || (elf->e_ident[1] != 'E') ||
+	    (elf->e_ident[2] != 'L') || (elf->e_ident[3] != 'F')) {
+		pr_debug("ELF Header Not found!%zu\n", sst_bin->size);
+		return -EINVAL;
+	}
+
+	if (dynamic == true) {
+		if (elf->e_type != ET_DYN) {
+			pr_err("Not a dynamic loadable library\n");
+			return -EINVAL;
+		}
+	}
+	pr_debug("Valid ELF Header...%zu\n", sst_bin->size);
+	return 0;
+}
+
+/**
+ * sst_validate_fw_image - validates the firmware signature
+ *
+ * @sst_fw_in_mem	: pointer to audio FW
+ * @size		: size of the firmware
+ * @module		: points to the FW modules
+ * @num_modules		: points to the num of modules
+ * This function validates the header signature in the FW image
+ */
+static int sst_validate_fw_image(const void *sst_fw_in_mem, unsigned long size,
+		struct fw_module_header **module, u32 *num_modules)
+{
+	struct fw_header *header;
+
+	pr_debug("%s\n", __func__);
+
+	/* Read the header information from the data pointer */
+	header = (struct fw_header *)sst_fw_in_mem;
+	pr_debug("header sign=%s size=%x modules=%x fmt=%x size=%zx\n",
+			header->signature, header->file_size, header->modules,
+			header->file_format, sizeof(*header));
+
+	/* verify FW */
+	if ((strncmp(header->signature, SST_FW_SIGN, 4) != 0) ||
+		(size != header->file_size + sizeof(*header))) {
+		/* Invalid FW signature */
+		pr_err("InvalidFW sign/filesize mismatch\n");
+		return -EINVAL;
+	}
+	*num_modules = header->modules;
+	*module = (void *)sst_fw_in_mem + sizeof(*header);
+
+	return 0;
+}
+
+/**
+ * sst_validate_library - validates the library signature
+ *
+ * @fw_lib			: pointer to FW library
+ * @slot			: pointer to the lib slot info
+ * @entry_point		: out param, which contains the module entry point
+ * This function is called before downloading the codec/postprocessing
+ * library
+ */
+static int sst_validate_library(const struct firmware *fw_lib,
+		struct lib_slot_info *slot,
+		u32 *entry_point)
+{
+	struct fw_header *header;
+	struct fw_module_header *module;
+	struct fw_block_info *block;
+	unsigned int n_blk, isize = 0, dsize = 0;
+	int err = 0;
+
+	header = (struct fw_header *)fw_lib->data;
+	if (header->modules != 1) {
+		pr_err("Module no mismatch found\n");
+		err = -EINVAL;
+		goto exit;
+	}
+	module = (void *)fw_lib->data + sizeof(*header);
+	*entry_point = module->entry_point;
+	pr_debug("Module entry point 0x%x\n", *entry_point);
+	pr_debug("Module Sign %s, Size 0x%x, Blocks 0x%x Type 0x%x\n",
+			module->signature, module->mod_size,
+			module->blocks, module->type);
+
+	block = (void *)module + sizeof(*module);
+	for (n_blk = 0; n_blk < module->blocks; n_blk++) {
+		switch (block->type) {
+		case SST_IRAM:
+			isize += block->size;
+			break;
+		case SST_DRAM:
+			dsize += block->size;
+			break;
+		default:
+			pr_err("Invalid block type for 0x%x\n", n_blk);
+			err = -EINVAL;
+			goto exit;
+		}
+		block = (void *)block + sizeof(*block) + block->size;
+	}
+	if (isize > slot->iram_size || dsize > slot->dram_size) {
+		pr_err("library exceeds size allocated\n");
+		err = -EINVAL;
+		goto exit;
+	} else
+		pr_debug("Library is safe for download...\n");
+
+	pr_debug("iram 0x%x, dram 0x%x, iram 0x%x, dram 0x%x\n",
+			isize, dsize, slot->iram_size, slot->dram_size);
+exit:
+	return err;
+
+}
+
+static bool chan_filter(struct dma_chan *chan, void *param)
+{
+	struct sst_dma *dma = (struct sst_dma *)param;
+
+	/* we only need MID_DMAC1 as that can access DSP RAMs*/
+	if (chan->device->dev == dma->dev)
+		return true;
+
+	return false;
+}
+
+static unsigned int
+sst_get_elf_sg_len(struct intel_sst_drv *sst, Elf32_Ehdr *elf, Elf32_Phdr *pr,
+		struct sst_info info)
+{
+	unsigned int i = 0, count = 0;
+
+	pr_debug("in %s: dma_max_len 0x%x\n", __func__, info.dma_max_len);
+
+	while (i < elf->e_phnum) {
+		if (pr[i].p_type == PT_LOAD) {
+
+			if ((pr[i].p_paddr >= info.iram_start) &&
+					(pr[i].p_paddr < info.iram_end &&
+						pr[i].p_filesz)) {
+				count += (pr[i].p_filesz) / info.dma_max_len;
+
+				if ((pr[i].p_filesz) % info.dma_max_len)
+					count++;
+
+			} else if ((pr[i].p_paddr >= info.dram_start) &&
+					(pr[i].p_paddr < info.dram_end &&
+						pr[i].p_filesz)) {
+				count += (pr[i].p_filesz) / info.dma_max_len;
+
+				if ((pr[i].p_filesz) % info.dma_max_len)
+					count++;
+
+			} else if ((pr[i].p_paddr >= info.imr_start) &&
+					(pr[i].p_paddr < info.imr_end &&
+						pr[i].p_filesz)) {
+				count += (pr[i].p_filesz) / info.dma_max_len;
+
+				if ((pr[i].p_filesz) % info.dma_max_len)
+					count++;
+			}
+		}
+		i++;
+	}
+
+	pr_debug("gotcha count %d\n", count);
+	return count;
+}
+
+static int
+sst_init_dma_sg_list(struct intel_sst_drv *sst, unsigned int len,
+		struct scatterlist **src, struct scatterlist **dstn)
+{
+	struct scatterlist *sg_src = NULL, *sg_dst = NULL;
+
+	sg_src = kzalloc(sizeof(*sg_src)*(len), GFP_KERNEL);
+	if (NULL == sg_src)
+		return -ENOMEM;
+	sg_init_table(sg_src, len);
+	sg_dst = kzalloc(sizeof(*sg_dst)*(len), GFP_KERNEL);
+	if (NULL == sg_dst) {
+		kfree(sg_src);
+		return -ENOMEM;
+	}
+	sg_init_table(sg_dst, len);
+	*src = sg_src;
+	*dstn = sg_dst;
+
+	return 0;
+}
+
+static int sst_alloc_dma_chan(struct sst_dma *dma)
+{
+	dma_cap_mask_t mask;
+	struct intel_mid_dma_slave *slave = &dma->slave;
+	int retval;
+	struct pci_dev *dmac = NULL;
+	const char *hid;
+
+	pr_debug("%s\n", __func__);
+	dma->dev = NULL;
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_MEMCPY, mask);
+
+	if (sst_drv_ctx->pci_id == SST_CLV_PCI_ID)
+		dmac = pci_get_device(PCI_VENDOR_ID_INTEL,
+				      PCI_DMAC_CLV_ID, NULL);
+	else if (sst_drv_ctx->pci_id == SST_MRFLD_PCI_ID)
+		dmac = pci_get_device(PCI_VENDOR_ID_INTEL,
+				      PCI_DMAC_MRFLD_ID, NULL);
+	else if (sst_drv_ctx->pci_id == SST_BYT_PCI_ID) {
+		hid = sst_drv_ctx->hid;
+		if (!strncmp(hid, "LPE0F281", 8))
+			dma->dev = intel_mid_get_acpi_dma("DMA0F28");
+		else if (!strncmp(hid, "80860F28", 8))
+			dma->dev = intel_mid_get_acpi_dma("ADMA0F28");
+		else if (!strncmp(hid, "808622A8", 8))
+			dma->dev = intel_mid_get_acpi_dma("ADMA22A8");
+		else if (!strncmp(hid, "LPE0F28", 7))
+			dma->dev = intel_mid_get_acpi_dma("DMA0F28");
+	}
+
+	if (!dmac && !dma->dev) {
+		pr_err("Can't find DMAC\n");
+		return -ENODEV;
+	}
+	if (dmac)
+		dma->dev = &dmac->dev;
+
+	dma->ch = dma_request_channel(mask, chan_filter, dma);
+	if (!dma->ch) {
+		pr_err("unable to request dma channel\n");
+		return -EIO;
+	}
+
+	slave->dma_slave.direction = DMA_MEM_TO_MEM;
+	slave->hs_mode = 0;
+	slave->cfg_mode = LNW_DMA_MEM_TO_MEM;
+	slave->dma_slave.src_addr_width = slave->dma_slave.dst_addr_width =
+						DMA_SLAVE_BUSWIDTH_4_BYTES;
+	slave->dma_slave.src_maxburst = slave->dma_slave.dst_maxburst =
+							LNW_DMA_MSIZE_16;
+
+	retval = dmaengine_slave_config(dma->ch, &slave->dma_slave);
+	if (retval) {
+		pr_err("unable to set slave config, err %d\n", retval);
+		dma_release_channel(dma->ch);
+		return -EIO;
+	}
+	return retval;
+}
+
+static void sst_dma_transfer_complete(void *arg)
+{
+	sst_drv_ctx  = (struct intel_sst_drv *)arg;
+	pr_debug(" sst_dma_transfer_complete\n");
+	sst_wake_up_block(sst_drv_ctx, 0, FW_DWNL_ID, FW_DWNL_ID, NULL, 0);
+}
+
+static inline int sst_dma_wait_for_completion(struct intel_sst_drv *sst)
+{
+	int ret = 0;
+	struct sst_block *block;
+	/* call prep and wait */
+	sst->desc->callback = sst_dma_transfer_complete;
+	sst->desc->callback_param = sst;
+
+	block = sst_create_block(sst, FW_DWNL_ID, FW_DWNL_ID);
+	if (block == NULL)
+		return -ENOMEM;
+
+	sst->desc->tx_submit(sst_drv_ctx->desc);
+	ret = sst_wait_timeout(sst, block);
+	if (ret)
+		dma_wait_for_async_tx(sst_drv_ctx->desc);
+	sst_free_block(sst, block);
+	return ret;
+}
+
+static int sst_dma_firmware(struct sst_dma *dma, struct sst_sg_list *sg_list)
+{
+	int retval = 0;
+	enum dma_ctrl_flags flag = DMA_CTRL_ACK;
+	struct scatterlist *sg_src_list, *sg_dst_list;
+	int length;
+	pr_debug("%s: use_lli %d\n", __func__, sst_drv_ctx->use_lli);
+
+	sg_src_list = sg_list->src;
+	sg_dst_list = sg_list->dst;
+	length = sg_list->list_len;
+
+	/* BY default PIMR is unsmasked
+	 * FW gets unmaksed dma intr too, so mask it for FW to execute on mrfld
+	 */
+	if (sst_drv_ctx->pci_id == SST_MRFLD_PCI_ID ||
+	    sst_drv_ctx->pci_id == SST_BYT_PCI_ID)
+		sst_shim_write(sst_drv_ctx->shim, SST_PIMR, 0xFFFF0034);
+
+	if (sst_drv_ctx->use_lli) {
+		sst_drv_ctx->desc = dma->ch->device->device_prep_dma_sg(dma->ch,
+					sg_dst_list, length,
+					sg_src_list, length, flag);
+		if (!sst_drv_ctx->desc)
+			return -EFAULT;
+		retval = sst_dma_wait_for_completion(sst_drv_ctx);
+		if (retval)
+			pr_err("sst_dma_firmware..timeout!\n");
+	} else {
+		struct scatterlist *sg;
+		dma_addr_t src_addr, dstn_addr;
+		int i = 0;
+
+		/* dma single block mode */
+		for_each_sg(sg_src_list, sg, length, i) {
+			pr_debug("dma desc %d, length %d\n", i, sg->length);
+			src_addr = sg_phys(sg);
+			dstn_addr = sg_phys(sg_dst_list);
+			if (sg_dst_list)
+				sg_dst_list = sg_next(sg_dst_list);
+			sst_drv_ctx->desc = dma->ch->device->device_prep_dma_memcpy(
+					dma->ch, dstn_addr, src_addr, sg->length, flag);
+			if (!sst_drv_ctx->desc)
+				return -EFAULT;
+			retval = sst_dma_wait_for_completion(sst_drv_ctx);
+			if (retval)
+				pr_err("sst_dma_firmware..timeout!\n");
+
+		}
+	}
+
+	return retval;
+}
+
+/*
+ * sst_fill_sglist - Fill the sg list
+ *
+ * @from: src address of the fw
+ * @to: virtual address of IRAM/DRAM
+ * @block_size: size of the block
+ * @sg_src: source scatterlist pointer
+ * @sg_dst: Destination scatterlist pointer
+ * @fw_sg_list: Pointer to the sg_list
+ * @dma_max_len: maximum len of the DMA block
+ *
+ * Parses modules that need to be placed in SST IRAM and DRAM
+ * and stores them in a sg list for transfer
+ * returns error or 0 if list creation fails or pass.
+  */
+static int sst_fill_sglist(unsigned long from, unsigned long to,
+		u32 block_size, struct scatterlist **sg_src, struct scatterlist **sg_dstn,
+		struct sst_sg_list *fw_sg_list, u32 dma_max_len)
+{
+	u32 offset = 0;
+	int len = 0;
+	unsigned long dstn, src;
+
+	pr_debug("%s entry", __func__);
+	if (!sg_src || !sg_dstn)
+		return -EINVAL;
+
+	do {
+		dstn = (unsigned long) (to + offset);
+		src = (unsigned long) (from + offset);
+
+		/* split blocks to dma_max_len */
+
+		len = block_size - offset;
+		pr_debug("DMA blk src %lx,dstn %lx,len %d,offset %d, size %d\n",
+			src, dstn, len, offset, block_size);
+		if (len > dma_max_len) {
+			pr_debug("block size exceeds %d\n", dma_max_len);
+			len = dma_max_len;
+			offset += len;
+		} else {
+			pr_debug("Node length less that %d\n", dma_max_len);
+			offset = 0;
+		}
+
+		if (!(*sg_src) || !(*sg_dstn))
+			return -ENOMEM;
+
+		sg_set_page(*sg_src, virt_to_page((void *) src), len,
+				offset_in_page((void *) src));
+		sg_set_page(*sg_dstn, virt_to_page((void *) dstn), len,
+				offset_in_page((void *) dstn));
+
+		*sg_src = sg_next(*sg_src);
+		*sg_dstn = sg_next(*sg_dstn);
+
+		/* TODO: is sg_idx required? */
+		if (sst_drv_ctx->info.use_elf == true)
+			fw_sg_list->sg_idx++;
+	} while (offset > 0);
+
+	return 0;
+}
+
+static int sst_parse_elf_module_dma(struct intel_sst_drv *sst, const void *fw,
+		 struct sst_info info, Elf32_Phdr *pr,
+		 struct scatterlist **sg_src, struct scatterlist **sg_dstn,
+		 struct sst_sg_list *fw_sg_list)
+{
+	unsigned long dstn, src;
+	unsigned int dstn_phys;
+	int ret_val = 0;
+	int mem_type;
+
+	ret_val = sst_fill_dstn(sst, info, pr, (void *)&dstn, &dstn_phys, &mem_type);
+	if (ret_val)
+		return ret_val;
+
+	dstn = (unsigned long) phys_to_virt(dstn_phys);
+	src = (unsigned long) (fw + pr->p_offset);
+
+	ret_val = sst_fill_sglist(src, dstn, pr->p_filesz,
+				sg_src, sg_dstn, fw_sg_list, sst->info.dma_max_len);
+
+	return ret_val;
+}
+
+static int
+sst_parse_elf_fw_dma(struct intel_sst_drv *sst, const void *fw_in_mem,
+			struct sst_sg_list *fw_sg_list)
+{
+	int i = 0, ret = 0;
+	Elf32_Ehdr *elf;
+	Elf32_Phdr *pr;
+	struct sst_info info;
+	struct scatterlist *sg_src = NULL, *sg_dst = NULL;
+	unsigned int sg_len;
+
+	BUG_ON(!fw_in_mem);
+
+	elf = (Elf32_Ehdr *)fw_in_mem;
+	pr = (Elf32_Phdr *) (fw_in_mem + elf->e_phoff);
+	pr_debug("%s entry\n", __func__);
+
+	sst_fill_info(sst, &info);
+
+	sg_len = sst_get_elf_sg_len(sst, elf, pr, info);
+	if (sg_len == 0) {
+		pr_err("we got NULL sz ELF, abort\n");
+		return -EIO;
+	}
+
+	if (sst_init_dma_sg_list(sst, sg_len, &sg_src, &sg_dst)) {
+		ret = -ENOMEM;
+		goto err1;
+	}
+
+	fw_sg_list->src = sg_src;
+	fw_sg_list->dst = sg_dst;
+	fw_sg_list->list_len = sg_len;
+	fw_sg_list->sg_idx = 0;
+
+	while (i < elf->e_phnum) {
+		if ((pr[i].p_type == PT_LOAD) && (pr[i].p_filesz)) {
+			ret = sst_parse_elf_module_dma(sst, fw_in_mem, info,
+					&pr[i], &sg_src, &sg_dst, fw_sg_list);
+			if (ret)
+				goto err;
+		}
+		i++;
+	}
+	return 0;
+err:
+	kfree(fw_sg_list->src);
+	kfree(fw_sg_list->dst);
+err1:
+	fw_sg_list->src = NULL;
+	fw_sg_list->dst = NULL;
+	fw_sg_list->list_len = 0;
+	fw_sg_list->sg_idx = 0;
+
+	return ret;
+}
+
+/**
+ * sst_parse_module_dma - Parse audio FW modules and populate the dma list
+ *
+ * @sst_ctx	: sst driver context
+ * @module	: FW module header
+ * @sg_list	: Pointer to the sg_list to be populated
+ * Count the length for scattergather list
+ * and create the scattergather list of same length
+ * returns error or 0 if module sizes are proper
+ */
+static int sst_parse_module_dma(struct intel_sst_drv *sst_ctx,
+				struct fw_module_header *module,
+				struct sst_sg_list *sg_list)
+{
+	struct fw_block_info *block;
+	u32 count;
+	unsigned long ram, src;
+	int retval, sg_len = 0;
+	struct scatterlist *sg_src, *sg_dst;
+
+	pr_debug("module sign %s size %x blocks %x type %x\n",
+			module->signature, module->mod_size,
+			module->blocks, module->type);
+	pr_debug("module entrypoint 0x%x\n", module->entry_point);
+
+	block = (void *)module + sizeof(*module);
+
+	for (count = 0; count < module->blocks; count++) {
+		sg_len += (block->size) / sst_drv_ctx->info.dma_max_len;
+
+		if (block->size % sst_drv_ctx->info.dma_max_len)
+			sg_len = sg_len + 1;
+		block = (void *)block + sizeof(*block) + block->size;
+	}
+
+	if (sst_init_dma_sg_list(sst_ctx, sg_len, &sg_src, &sg_dst)) {
+		retval = -ENOMEM;
+		goto err1;
+	}
+
+	sg_list->src = sg_src;
+	sg_list->dst = sg_dst;
+	sg_list->list_len = sg_len;
+
+	block = (void *)module + sizeof(*module);
+
+	for (count = 0; count < module->blocks; count++) {
+		if (block->size <= 0) {
+			pr_err("block size invalid\n");
+			retval = -EINVAL;
+			goto err;
+		}
+		switch (block->type) {
+		case SST_IRAM:
+			ram = sst_ctx->iram_base;
+			break;
+		case SST_DRAM:
+			ram = sst_ctx->dram_base;
+			break;
+		default:
+			pr_err("wrong ram type0x%x in block0x%x\n",
+					block->type, count);
+			retval = -EINVAL;
+			goto err;
+		}
+
+		/*converting from physical to virtual because
+		scattergather list works on virtual pointers*/
+		ram = (unsigned long) phys_to_virt(ram);
+		ram = (unsigned long)(ram + block->ram_offset);
+		src = (unsigned long) (void *)block + sizeof(*block);
+
+		retval = sst_fill_sglist(src, ram,
+				block->size, &sg_src, &sg_dst,
+				sg_list, sst_ctx->info.dma_max_len);
+		if (retval)
+			goto err;
+
+		block = (void *)block + sizeof(*block) + block->size;
+	}
+	return 0;
+err:
+	kfree(sg_list->src);
+	kfree(sg_list->dst);
+err1:
+	sg_list->src = NULL;
+	sg_list->dst = NULL;
+	sg_list->list_len = 0;
+
+	return retval;
+}
+
+/**
+ * sst_parse_fw_dma - parse the firmware image & populate the list for dma
+ *
+ * @sst_fw_in_mem	: pointer to audio fw
+ * @size		: size of the firmware
+ * @fw_list		: pointer to sst_sg_list to be populated
+ * This function parses the FW image and saves the parsed image in the list
+ * for dma
+ */
+static int sst_parse_fw_dma(const void *sst_fw_in_mem, unsigned long size,
+				struct sst_sg_list *fw_list)
+{
+	struct fw_module_header *module;
+	u32 count, num_modules;
+	int ret_val;
+
+	ret_val = sst_validate_fw_image(sst_fw_in_mem, size,
+				&module, &num_modules);
+	if (ret_val)
+		return ret_val;
+
+	for (count = 0; count < num_modules; count++) {
+		/* module */
+		ret_val = sst_parse_module_dma(sst_drv_ctx, module, fw_list);
+		if (ret_val)
+			return ret_val;
+		module = (void *)module + sizeof(*module) + module->mod_size ;
+	}
+
+	return 0;
+}
+
+static void sst_dma_free_resources(struct sst_dma *dma)
+{
+	pr_debug("entry:%s\n", __func__);
+
+	dma_release_channel(dma->ch);
+}
+
+void sst_fill_config(struct intel_sst_drv *sst_ctx, unsigned int offset)
+{
+	struct sst_fill_config sst_config;
+
+	 if (!(sst_ctx->pdata->bdata && sst_ctx->pdata->pdata))
+		return;
+
+	sst_config.sign = SST_CONFIG_SSP_SIGN;
+	memcpy(&sst_config.sst_bdata, sst_ctx->pdata->bdata, sizeof(struct sst_board_config_data));
+	memcpy(&sst_config.sst_pdata, sst_ctx->pdata->pdata, sizeof(struct sst_platform_config_data));
+	sst_config.shim_phy_add = sst_ctx->shim_phy_add;
+	sst_config.mailbox_add = sst_ctx->mailbox_add;
+	MEMCPY_TOIO(sst_ctx->dram + offset, &sst_config, sizeof(sst_config));
+
+}
+
+/**
+ * sst_do_dma - function allocs and initiates the DMA
+ *
+ * @sg_list: Pointer to dma list on which the dma needs to be initiated
+ *
+ * Triggers the DMA
+ */
+static int sst_do_dma(struct sst_sg_list *sg_list)
+{
+	int ret_val;
+
+	/* get a dmac channel */
+	ret_val = sst_alloc_dma_chan(&sst_drv_ctx->dma);
+	if (ret_val)
+		return ret_val;
+
+	/* allocate desc for transfer and submit */
+	ret_val = sst_dma_firmware(&sst_drv_ctx->dma, sg_list);
+
+	sst_dma_free_resources(&sst_drv_ctx->dma);
+
+	return ret_val;
+}
+
+/*
+ * sst_fill_memcpy_list - Fill the memcpy list
+ *
+ * @memcpy_list: List to be filled
+ * @destn: Destination addr to be filled in the list
+ * @src: Source addr to be filled in the list
+ * @size: Size to be filled in the list
+ *
+ * Adds the node to the list after required fields
+ * are populated in the node
+ */
+
+static int sst_fill_memcpy_list(struct list_head *memcpy_list,
+			void *destn, const void *src, u32 size, bool is_io)
+{
+	struct sst_memcpy_list *listnode;
+
+	listnode = kzalloc(sizeof(*listnode), GFP_KERNEL);
+	if (listnode == NULL)
+		return -ENOMEM;
+	listnode->dstn = destn;
+	listnode->src = src;
+	listnode->size = size;
+	listnode->is_io = is_io;
+	list_add_tail(&listnode->memcpylist, memcpy_list);
+
+	return 0;
+}
+
+static int sst_parse_elf_module_memcpy(struct intel_sst_drv *sst,
+		const void *fw, struct sst_info info, Elf32_Phdr *pr,
+		struct list_head *memcpy_list)
+{
+	void *dstn;
+	unsigned int dstn_phys;
+	int ret_val = 0;
+	int mem_type;
+
+	ret_val = sst_fill_dstn(sst, info, pr, &dstn, &dstn_phys, &mem_type);
+	if (ret_val)
+		return ret_val;
+
+	ret_val = sst_fill_memcpy_list(memcpy_list, dstn,
+			(void *)fw + pr->p_offset, pr->p_filesz, mem_type);
+	if (ret_val)
+		return ret_val;
+
+	return 0;
+}
+
+static int
+sst_parse_elf_fw_memcpy(struct intel_sst_drv *sst, const void *fw_in_mem,
+			struct list_head *memcpy_list)
+{
+	int i = 0;
+
+	Elf32_Ehdr *elf;
+	Elf32_Phdr *pr;
+	struct sst_info info;
+
+	BUG_ON(!fw_in_mem);
+
+	elf = (Elf32_Ehdr *)fw_in_mem;
+	pr = (Elf32_Phdr *) (fw_in_mem + elf->e_phoff);
+	pr_debug("%s entry\n", __func__);
+
+	sst_fill_info(sst, &info);
+
+	while (i < elf->e_phnum) {
+		if (pr[i].p_type == PT_LOAD)
+			sst_parse_elf_module_memcpy(sst, fw_in_mem, info,
+					&pr[i], memcpy_list);
+		i++;
+	}
+	return 0;
+}
+
+/**
+ * sst_parse_module_memcpy - Parse audio FW modules and populate the memcpy list
+ *
+ * @module		: FW module header
+ * @memcpy_list	: Pointer to the list to be populated
+ * Create the memcpy list as the number of block to be copied
+ * returns error or 0 if module sizes are proper
+ */
+static int sst_parse_module_memcpy(struct fw_module_header *module,
+				struct list_head *memcpy_list)
+{
+	struct fw_block_info *block;
+	u32 count;
+	int ret_val = 0;
+	void __iomem *ram_iomem;
+
+	pr_debug("module sign %s size %x blocks %x type %x\n",
+			module->signature, module->mod_size,
+			module->blocks, module->type);
+	pr_debug("module entrypoint 0x%x\n", module->entry_point);
+
+	block = (void *)module + sizeof(*module);
+
+	for (count = 0; count < module->blocks; count++) {
+		if (block->size <= 0) {
+			pr_err("block size invalid\n");
+			return -EINVAL;
+		}
+		switch (block->type) {
+		case SST_IRAM:
+			ram_iomem = sst_drv_ctx->iram;
+			break;
+		case SST_DRAM:
+			ram_iomem = sst_drv_ctx->dram;
+			break;
+		default:
+			pr_err("wrong ram type0x%x in block0x%x\n",
+					block->type, count);
+			return -EINVAL;
+		}
+
+		ret_val = sst_fill_memcpy_list(memcpy_list,
+				ram_iomem + block->ram_offset,
+				(void *)block + sizeof(*block), block->size, 1);
+		if (ret_val)
+			return ret_val;
+
+		block = (void *)block + sizeof(*block) + block->size;
+	}
+	return 0;
+}
+
+/**
+ * sst_parse_fw_memcpy - parse the firmware image & populate the list for memcpy
+ *
+ * @sst_fw_in_mem	: pointer to audio fw
+ * @size		: size of the firmware
+ * @fw_list		: pointer to list_head to be populated
+ * This function parses the FW image and saves the parsed image in the list
+ * for memcpy
+ */
+static int sst_parse_fw_memcpy(const void *sst_fw_in_mem, unsigned long size,
+				struct list_head *fw_list)
+{
+	struct fw_module_header *module;
+	u32 count, num_modules;
+	int ret_val;
+
+	ret_val = sst_validate_fw_image(sst_fw_in_mem, size,
+				&module, &num_modules);
+	if (ret_val)
+		return ret_val;
+
+	for (count = 0; count < num_modules; count++) {
+		/* module */
+		ret_val = sst_parse_module_memcpy(module, fw_list);
+		if (ret_val)
+			return ret_val;
+		module = (void *)module + sizeof(*module) + module->mod_size ;
+	}
+
+	return 0;
+}
+
+/**
+ * sst_do_memcpy - function initiates the memcpy
+ *
+ * @memcpy_list: Pter to memcpy list on which the memcpy needs to be initiated
+ *
+ * Triggers the memcpy
+ */
+static void sst_do_memcpy(struct list_head *memcpy_list)
+{
+	struct sst_memcpy_list *listnode;
+
+	list_for_each_entry(listnode, memcpy_list, memcpylist) {
+		if (listnode->is_io == true)
+			MEMCPY_TOIO((void __iomem *)listnode->dstn, listnode->src,
+							listnode->size);
+		else
+			memcpy(listnode->dstn, listnode->src, listnode->size);
+	}
+}
+
+static void sst_memcpy_free_lib_resources(void)
+{
+	struct sst_memcpy_list *listnode, *tmplistnode;
+
+	pr_debug("entry:%s\n", __func__);
+
+	/*Free the list*/
+	if (!list_empty(&sst_drv_ctx->libmemcpy_list)) {
+		list_for_each_entry_safe(listnode, tmplistnode,
+				&sst_drv_ctx->libmemcpy_list, memcpylist) {
+			list_del(&listnode->memcpylist);
+			kfree(listnode);
+		}
+	}
+}
+
+void sst_memcpy_free_resources(void)
+{
+	struct sst_memcpy_list *listnode, *tmplistnode;
+
+	pr_debug("entry:%s\n", __func__);
+
+	/*Free the list*/
+	if (!list_empty(&sst_drv_ctx->memcpy_list)) {
+		list_for_each_entry_safe(listnode, tmplistnode,
+				&sst_drv_ctx->memcpy_list, memcpylist) {
+			list_del(&listnode->memcpylist);
+			kfree(listnode);
+		}
+	}
+	sst_memcpy_free_lib_resources();
+}
+
+void sst_firmware_load_cb(const struct firmware *fw, void *context)
+{
+	struct intel_sst_drv *ctx = context;
+	int ret = 0;
+
+	pr_debug("In %s\n", __func__);
+
+	if (fw == NULL) {
+		pr_err("request fw failed\n");
+		goto out;
+	}
+
+	if (sst_drv_ctx->sst_state != SST_UN_INIT ||
+			ctx->fw_in_mem != NULL)
+		goto exit;
+
+	pr_debug("Request Fw completed\n");
+	trace_sst_fw_download("End of FW request", ctx->sst_state);
+
+	if (ctx->info.use_elf == true)
+		ret = sst_validate_elf(fw, false);
+
+	if (ret != 0) {
+		pr_err("FW image invalid...\n");
+		goto out;
+	}
+
+	ctx->fw_in_mem = kzalloc(fw->size, GFP_KERNEL);
+	if (!ctx->fw_in_mem) {
+		pr_err("%s unable to allocate memory\n", __func__);
+		goto out;
+	}
+
+	pr_debug("copied fw to %p", ctx->fw_in_mem);
+	pr_debug("phys: %lx", (unsigned long)virt_to_phys(ctx->fw_in_mem));
+	memcpy(ctx->fw_in_mem, fw->data, fw->size);
+
+	trace_sst_fw_download("Start FW parsing", ctx->sst_state);
+	if (ctx->use_dma) {
+		if (ctx->info.use_elf == true)
+			ret = sst_parse_elf_fw_dma(ctx, ctx->fw_in_mem,
+							&ctx->fw_sg_list);
+		else
+			ret = sst_parse_fw_dma(ctx->fw_in_mem, fw->size,
+							&ctx->fw_sg_list);
+	} else {
+		if (ctx->info.use_elf == true)
+			ret = sst_parse_elf_fw_memcpy(ctx, ctx->fw_in_mem,
+							&ctx->memcpy_list);
+		else
+			ret = sst_parse_fw_memcpy(ctx->fw_in_mem, fw->size,
+							&ctx->memcpy_list);
+	}
+	trace_sst_fw_download("End FW parsing", ctx->sst_state);
+	if (ret) {
+		kfree(ctx->fw_in_mem);
+		ctx->fw_in_mem = NULL;
+		goto out;
+	}
+
+	/* If static module download(download at boot time) is supported,
+	 * set the flag to indicate lib download is to be done
+	 */
+	if (ctx->pdata->lib_info)
+		if (ctx->pdata->lib_info->mod_ddr_dnld)
+			ctx->lib_dwnld_reqd = true;
+
+	sst_set_fw_state_locked(sst_drv_ctx, SST_FW_LIB_LOAD);
+	goto exit;
+out:
+	sst_set_fw_state_locked(sst_drv_ctx, SST_UN_INIT);
+exit:
+	if (fw != NULL)
+		release_firmware(fw);
+}
+
+/*
+ * sst_request_fw - requests audio fw from kernel and saves a copy
+ *
+ * This function requests the SST FW from the kernel, parses it and
+ * saves a copy in the driver context
+ */
+static int sst_request_fw(struct intel_sst_drv *sst)
+{
+	int retval = 0;
+	char name[20];
+	const struct firmware *fw;
+
+	snprintf(name, sizeof(name), "%s%04x%s", "fw_sst_",
+				sst->pci_id, ".bin");
+	pr_debug("Requesting FW %s now...\n", name);
+
+	retval = request_firmware(&fw, name, sst->dev);
+	if (fw == NULL) {
+		pr_err("fw is returning as null\n");
+		return -EINVAL;
+	}
+	if (retval) {
+		pr_err("request fw failed %d\n", retval);
+		return retval;
+	}
+	trace_sst_fw_download("End of FW request", sst->sst_state);
+	if (sst->info.use_elf == true)
+		retval = sst_validate_elf(fw, false);
+	if (retval != 0) {
+		pr_err("FW image invalid...\n");
+		goto end_release;
+	}
+	sst->fw_in_mem = kzalloc(fw->size, GFP_KERNEL);
+	if (!sst->fw_in_mem) {
+		pr_err("%s unable to allocate memory\n", __func__);
+		retval = -ENOMEM;
+		goto end_release;
+	}
+	pr_debug("copied fw to %p", sst->fw_in_mem);
+	pr_debug("phys: %lx", (unsigned long)virt_to_phys(sst->fw_in_mem));
+	memcpy(sst->fw_in_mem, fw->data, fw->size);
+	trace_sst_fw_download("Start FW parsing", sst->sst_state);
+	if (sst->use_dma) {
+		if (sst->info.use_elf == true)
+			retval = sst_parse_elf_fw_dma(sst, sst->fw_in_mem,
+							&sst->fw_sg_list);
+		else
+			retval = sst_parse_fw_dma(sst->fw_in_mem, fw->size,
+							&sst->fw_sg_list);
+	} else {
+		if (sst->info.use_elf == true)
+			retval = sst_parse_elf_fw_memcpy(sst, sst->fw_in_mem,
+							&sst->memcpy_list);
+		else
+			retval = sst_parse_fw_memcpy(sst->fw_in_mem, fw->size,
+							&sst->memcpy_list);
+	}
+	trace_sst_fw_download("End FW parsing", sst->sst_state);
+	if (retval) {
+		kfree(sst->fw_in_mem);
+		sst->fw_in_mem = NULL;
+	}
+
+	/* If static module download(download at boot time) is supported,
+	 * set the flag to indicate lib download is to be done
+	 */
+	if (sst->pdata->lib_info)
+		if (sst->pdata->lib_info->mod_ddr_dnld)
+			sst->lib_dwnld_reqd = true;
+end_release:
+	release_firmware(fw);
+	return retval;
+}
+
+static inline void print_lib_info(struct snd_sst_lib_download_info *resp)
+{
+	pr_debug("codec Type %d Ver %d Built %s: %s\n",
+		resp->dload_lib.lib_info.lib_type,
+		resp->dload_lib.lib_info.lib_version,
+		resp->dload_lib.lib_info.b_date,
+		resp->dload_lib.lib_info.b_time);
+}
+
+/* sst_download_library - This function is called when any
+ codec/post processing library needs to be downloaded */
+static int sst_download_library(const struct firmware *fw_lib,
+				struct snd_sst_lib_download_info *lib)
+{
+	int ret_val = 0;
+
+	/* send IPC message and wait */
+	u8 pvt_id;
+	struct ipc_post *msg = NULL;
+	union config_status_reg csr;
+	struct snd_sst_str_type str_type = {0};
+	int retval = 0;
+	void *codec_fw;
+	struct sst_block *block;
+
+	pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+	ret_val = sst_create_block_and_ipc_msg(&msg, true, sst_drv_ctx, &block,
+				IPC_IA_PREP_LIB_DNLD, pvt_id);
+	if (ret_val) {
+		pr_err("library download failed\n");
+		return ret_val;
+	}
+
+	sst_fill_header(&msg->header, IPC_IA_PREP_LIB_DNLD, 1, pvt_id);
+	msg->header.part.data = sizeof(u32) + sizeof(str_type);
+	str_type.codec_type = lib->dload_lib.lib_info.lib_type;
+	/*str_type.pvt_id = pvt_id;*/
+	memcpy(msg->mailbox_data, &msg->header, sizeof(u32));
+	memcpy(msg->mailbox_data + sizeof(u32), &str_type, sizeof(str_type));
+	sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+	retval = sst_wait_timeout(sst_drv_ctx, block);
+	if (block->data) {
+		struct snd_sst_str_type *str_type =
+			(struct snd_sst_str_type *)block->data;
+		if (str_type->result) {
+			/* error */
+			pr_err("Prep codec downloaded failed %d\n",
+					str_type->result);
+			retval = -EIO;
+			goto free_block;
+		}
+		kfree(block->data);
+	} else if (retval != 0) {
+		retval = -EIO;
+		goto free_block;
+	}
+	pr_debug("FW responded, ready for download now...\n");
+	codec_fw = kzalloc(fw_lib->size, GFP_KERNEL);
+	if (!codec_fw) {
+		memset(lib, 0, sizeof(*lib));
+		retval = -ENOMEM;
+		goto send_ipc;
+	}
+	memcpy(codec_fw, fw_lib->data, fw_lib->size);
+
+	if (sst_drv_ctx->use_dma)
+		retval = sst_parse_fw_dma(codec_fw, fw_lib->size,
+				 &sst_drv_ctx->library_list);
+	else
+		retval = sst_parse_fw_memcpy(codec_fw, fw_lib->size,
+				 &sst_drv_ctx->libmemcpy_list);
+
+	if (retval) {
+		memset(lib, 0, sizeof(*lib));
+		goto send_ipc;
+	}
+
+	/* downloading on success */
+	mutex_lock(&sst_drv_ctx->sst_lock);
+	sst_drv_ctx->sst_state = SST_FW_LOADED;
+	mutex_lock(&sst_drv_ctx->csr_lock);
+	csr.full = readl(sst_drv_ctx->shim + SST_CSR);
+	csr.part.run_stall = 1;
+	sst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);
+
+	csr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);
+	csr.part.bypass = 0x7;
+	sst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);
+	mutex_unlock(&sst_drv_ctx->csr_lock);
+
+	if (sst_drv_ctx->use_dma) {
+		ret_val = sst_do_dma(&sst_drv_ctx->library_list);
+		if (ret_val) {
+			pr_err("sst_do_dma failed, abort\n");
+			memset(lib, 0, sizeof(*lib));
+		}
+	} else
+		sst_do_memcpy(&sst_drv_ctx->libmemcpy_list);
+	/* set the FW to running again */
+	mutex_lock(&sst_drv_ctx->csr_lock);
+	csr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);
+	csr.part.bypass = 0x0;
+	sst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);
+
+	csr.full = sst_shim_read(sst_drv_ctx->shim, SST_CSR);
+	csr.part.run_stall = 0;
+	sst_shim_write(sst_drv_ctx->shim, SST_CSR, csr.full);
+	mutex_unlock(&sst_drv_ctx->csr_lock);
+send_ipc:
+	/* send download complete and wait */
+	if (sst_create_ipc_msg(&msg, true)) {
+		retval = -ENOMEM;
+		goto free_resources;
+	}
+
+	block->condition = false;
+	block->msg_id = IPC_IA_LIB_DNLD_CMPLT;
+	sst_fill_header(&msg->header, IPC_IA_LIB_DNLD_CMPLT, 1, pvt_id);
+	msg->header.part.data = sizeof(u32) + sizeof(*lib);
+	lib->pvt_id = pvt_id;
+	memcpy(msg->mailbox_data, &msg->header, sizeof(u32));
+	memcpy(msg->mailbox_data + sizeof(u32), lib, sizeof(*lib));
+	sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+	pr_debug("Waiting for FW response Download complete\n");
+	retval = sst_wait_timeout(sst_drv_ctx, block);
+	sst_drv_ctx->sst_state = SST_FW_RUNNING;
+	if (block->data) {
+		struct snd_sst_lib_download_info *resp = block->data;
+		retval = resp->result;
+		if (retval) {
+			pr_err("err in lib dload %x\n", resp->result);
+			goto free_resources;
+		} else {
+			pr_debug("Codec download complete...\n");
+			print_lib_info(resp);
+		}
+	} else if (retval) {
+		/* error */
+		retval = -EIO;
+		goto free_resources;
+	}
+
+	pr_debug("FW success on Download complete\n");
+
+free_resources:
+	if (sst_drv_ctx->use_dma) {
+		kfree(sst_drv_ctx->library_list.src);
+		kfree(sst_drv_ctx->library_list.dst);
+		sst_drv_ctx->library_list.list_len = 0;
+	}
+
+	kfree(codec_fw);
+	mutex_unlock(&sst_drv_ctx->sst_lock);
+free_block:
+	sst_free_block(sst_drv_ctx, block);
+	return retval;
+}
+
+/*
+ * Writing the DDR physical base to DCCM offset
+ * so that FW can use it to setup TLB
+ */
+static void sst_dccm_config_write(void __iomem *dram_base, unsigned int ddr_base)
+{
+	void __iomem *addr;
+	u32 bss_reset = 0;
+
+	addr = (void __iomem *)(dram_base + MRFLD_FW_DDR_BASE_OFFSET);
+	MEMCPY_TOIO(addr, (void *)&ddr_base, sizeof(u32));
+	bss_reset |= (1 << MRFLD_FW_BSS_RESET_BIT);
+	addr = (void __iomem *)(dram_base + MRFLD_FW_FEATURE_BASE_OFFSET);
+	MEMCPY_TOIO(addr, &bss_reset, sizeof(u32));
+	pr_debug("%s: config written to DCCM\n", __func__);
+}
+
+void sst_post_download_mrfld(struct intel_sst_drv *ctx)
+{
+	sst_dccm_config_write(ctx->dram, ctx->ddr_base);
+	/* For mrfld, download all libraries the first time fw is
+	 * downloaded */
+	pr_debug("%s: lib_dwnld = %u\n", __func__, ctx->lib_dwnld_reqd);
+	if (ctx->lib_dwnld_reqd) {
+		sst_load_all_modules_elf(ctx, sst_modules_mrfld, ARRAY_SIZE(sst_modules_mrfld));
+		ctx->lib_dwnld_reqd = false;
+	}
+}
+
+void sst_post_download_ctp(struct intel_sst_drv *ctx)
+{
+	sst_fill_config(ctx, 0);
+}
+
+void sst_post_download_byt(struct intel_sst_drv *ctx)
+{
+	sst_dccm_config_write(ctx->dram, ctx->ddr_base);
+	sst_fill_config(ctx, 2 * sizeof(u32));
+
+	pr_debug("%s: lib_dwnld = %u\n", __func__, ctx->lib_dwnld_reqd);
+	if (ctx->lib_dwnld_reqd) {
+		sst_load_all_modules_elf(ctx, sst_modules_byt,
+					ARRAY_SIZE(sst_modules_byt));
+		ctx->lib_dwnld_reqd = false;
+	}
+}
+
+static void sst_init_lib_mem_mgr(struct intel_sst_drv *ctx)
+{
+	struct sst_mem_mgr *mgr = &ctx->lib_mem_mgr;
+	const struct sst_lib_dnld_info *lib_info = ctx->pdata->lib_info;
+
+	memset(mgr, 0, sizeof(*mgr));
+	mgr->current_base = lib_info->mod_base + lib_info->mod_table_offset
+						+ lib_info->mod_table_size;
+	mgr->avail = lib_info->mod_end - mgr->current_base + 1;
+
+	pr_debug("current base = 0x%lx , avail = 0x%x\n",
+		(unsigned long)mgr->current_base, mgr->avail);
+}
+
+/**
+ * sst_load_fw - function to load FW into DSP
+ *
+ *
+ * Transfers the FW to DSP using dma/memcpy
+ */
+int sst_load_fw(void)
+{
+	int ret_val = 0;
+	struct sst_block *block;
+
+	pr_debug("sst_load_fw\n");
+
+	if ((sst_drv_ctx->sst_state !=  SST_START_INIT &&
+			sst_drv_ctx->sst_state !=  SST_FW_LIB_LOAD) ||
+			sst_drv_ctx->sst_state == SST_SHUTDOWN)
+		return -EAGAIN;
+
+	if (!sst_drv_ctx->fw_in_mem) {
+		if (sst_drv_ctx->sst_state != SST_START_INIT) {
+			/* even wake*/
+			pr_err("sst : wait for FW to be downloaded\n");
+			return -EBUSY;
+		} else {
+			trace_sst_fw_download("Req FW sent in check device",
+						sst_drv_ctx->sst_state);
+			pr_debug("sst: FW not in memory retry to download\n");
+			ret_val = sst_request_fw(sst_drv_ctx);
+			if (ret_val)
+				return ret_val;
+		}
+	}
+
+	BUG_ON(!sst_drv_ctx->fw_in_mem);
+	block = sst_create_block(sst_drv_ctx, 0, FW_DWNL_ID);
+	if (block == NULL)
+		return -ENOMEM;
+
+	/* Prevent C-states beyond C6 */
+	pm_qos_update_request(sst_drv_ctx->qos, CSTATE_EXIT_LATENCY_S0i1 - 1);
+
+	ret_val = sst_drv_ctx->ops->reset();
+	if (ret_val)
+		goto restore;
+
+	trace_sst_fw_download("Start FW copy", sst_drv_ctx->sst_state);
+	if (sst_drv_ctx->use_dma) {
+		ret_val = sst_do_dma(&sst_drv_ctx->fw_sg_list);
+		if (ret_val) {
+			pr_err("sst_do_dma failed, abort\n");
+			goto restore;
+		}
+	} else {
+		sst_do_memcpy(&sst_drv_ctx->memcpy_list);
+	}
+
+	trace_sst_fw_download("Post download for Lib start",
+			sst_drv_ctx->sst_state);
+	/* Write the DRAM/DCCM config before enabling FW */
+	if (sst_drv_ctx->ops->post_download)
+		sst_drv_ctx->ops->post_download(sst_drv_ctx);
+	trace_sst_fw_download("Post download for Lib end",
+			sst_drv_ctx->sst_state);
+	sst_drv_ctx->sst_state = SST_FW_LOADED;
+
+	/* bring sst out of reset */
+	ret_val = sst_drv_ctx->ops->start();
+	if (ret_val)
+		goto restore;
+	trace_sst_fw_download("DSP reset done",
+			sst_drv_ctx->sst_state);
+
+	ret_val = sst_wait_timeout(sst_drv_ctx, block);
+	if (ret_val) {
+		pr_err("fw download failed %d\n" , ret_val);
+		/* assume FW d/l failed due to timeout*/
+		ret_val = -EBUSY;
+
+	}
+
+restore:
+	/* Re-enable Deeper C-states beyond C6 */
+	pm_qos_update_request(sst_drv_ctx->qos, PM_QOS_DEFAULT_VALUE);
+	sst_free_block(sst_drv_ctx, block);
+
+	return ret_val;
+}
+
+/**
+ * sst_load_library - function to load FW into DSP
+ *
+ * @lib: Pointer to the lib download structure
+ * @ops: Contains the stream ops
+ * This function is called when FW requests for a particular library download
+ * This function prepares & downloads the library
+ */
+int sst_load_library(struct snd_sst_lib_download *lib, u8 ops)
+{
+	char buf[20];
+	const char *type, *dir;
+	int len = 0, error = 0;
+	u32 entry_point;
+	const struct firmware *fw_lib;
+	struct snd_sst_lib_download_info dload_info = {{{0},},};
+
+	memset(buf, 0, sizeof(buf));
+
+	pr_debug("Lib Type 0x%x, Slot 0x%x, ops 0x%x\n",
+			lib->lib_info.lib_type, lib->slot_info.slot_num, ops);
+	pr_debug("Version 0x%x, name %s, caps 0x%x media type 0x%x\n",
+		lib->lib_info.lib_version, lib->lib_info.lib_name,
+		lib->lib_info.lib_caps, lib->lib_info.media_type);
+
+	pr_debug("IRAM Size 0x%x, offset 0x%x\n",
+		lib->slot_info.iram_size, lib->slot_info.iram_offset);
+	pr_debug("DRAM Size 0x%x, offset 0x%x\n",
+		lib->slot_info.dram_size, lib->slot_info.dram_offset);
+
+	switch (lib->lib_info.lib_type) {
+	case SST_CODEC_TYPE_MP3:
+		type = "mp3_";
+		break;
+	case SST_CODEC_TYPE_AAC:
+		type = "aac_";
+		break;
+	case SST_CODEC_TYPE_AACP:
+		type = "aac_v1_";
+		break;
+	case SST_CODEC_TYPE_eAACP:
+		type = "aac_v2_";
+		break;
+	case SST_CODEC_TYPE_WMA9:
+		type = "wma9_";
+		break;
+	default:
+		pr_err("Invalid codec type\n");
+		error = -EINVAL;
+		goto wake;
+	}
+
+	if (ops == STREAM_OPS_CAPTURE)
+		dir = "enc_";
+	else
+		dir = "dec_";
+	len = strlen(type) + strlen(dir);
+	strncpy(buf, type, sizeof(buf)-1);
+	strncpy(buf + strlen(type), dir, sizeof(buf)-strlen(type)-1);
+	len += snprintf(buf + len, sizeof(buf) - len, "%d",
+			lib->slot_info.slot_num);
+	len += snprintf(buf + len, sizeof(buf) - len, ".bin");
+
+	pr_debug("Requesting %s\n", buf);
+
+	error = request_firmware(&fw_lib, buf, sst_drv_ctx->dev);
+	if (fw_lib == NULL) {
+		pr_err("fw_lib pointer is returning null\n");
+		return -EINVAL;
+	}
+	if (error) {
+		pr_err("library load failed %d\n", error);
+		goto wake;
+	}
+	error = sst_validate_library(fw_lib, &lib->slot_info, &entry_point);
+	if (error)
+		goto wake_free;
+
+	lib->mod_entry_pt = entry_point;
+	memcpy(&dload_info.dload_lib, lib, sizeof(*lib));
+	/* Prevent C-states beyond C6 */
+	pm_qos_update_request(sst_drv_ctx->qos, CSTATE_EXIT_LATENCY_S0i1 - 1);
+	error = sst_download_library(fw_lib, &dload_info);
+	/* Re-enable Deeper C-states beyond C6 */
+	pm_qos_update_request(sst_drv_ctx->qos, PM_QOS_DEFAULT_VALUE);
+	if (error)
+		goto wake_free;
+
+	/* lib is downloaded and init send alloc again */
+	pr_debug("Library is downloaded now...\n");
+wake_free:
+	/* sst_wake_up_alloc_block(sst_drv_ctx, pvt_id, error, NULL); */
+	release_firmware(fw_lib);
+wake:
+	return error;
+}
+
+/* In relocatable elf file, there can be  relocatable variables and functions.
+ * Variables are kept in Global Address Offset Table (GOT) and functions in
+ * Procedural Linkage Table (PLT). In current codec binaries only relocatable
+ * variables are seen. So we use the GOT table.
+ */
+static int sst_find_got_table(Elf32_Shdr *shdr, int nsec, char *in_elf,
+		Elf32_Rela **got, unsigned int *cnt)
+{
+	int i = 0;
+	while (i < nsec) {
+		if (shdr[i].sh_type == SHT_RELA) {
+			*got = (Elf32_Rela *)(in_elf + shdr[i].sh_offset);
+			*cnt = shdr[i].sh_size / sizeof(Elf32_Rela);
+			break;
+		}
+		i++;
+	}
+	if (i == nsec)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* For each entry in the GOT table, find the unrelocated offset. Then
+ * add the relocation base to the offset and write back the new address to the
+ * original variable location.
+ */
+static int sst_relocate_got_entries(Elf32_Rela *table, unsigned int size,
+	char *in_elf, int elf_size, u32 rel_base)
+{
+	int i;
+	Elf32_Rela *entry;
+	Elf32_Addr *target_addr, unreloc_addr;
+
+	for (i = 0; i < size; i++) {
+		entry = &table[i];
+		if (ELF32_R_SYM(entry->r_info) != 0) {
+			return -EINVAL;
+		} else {
+			if (entry->r_offset > elf_size) {
+				pr_err("GOT table target addr out of range\n");
+				return -EINVAL;
+			}
+			target_addr = (Elf32_Addr *)(in_elf + entry->r_offset);
+			unreloc_addr = *target_addr + entry->r_addend;
+			if (unreloc_addr > elf_size) {
+				pr_err("GOT table entry invalid\n");
+				continue;
+			}
+			*target_addr = unreloc_addr + rel_base;
+		}
+	}
+	return 0;
+}
+
+static int sst_relocate_elf(char *in_elf, int elf_size, phys_addr_t rel_base,
+		Elf32_Addr *entry_pt)
+{
+	int retval = 0;
+	Elf32_Ehdr *ehdr = (Elf32_Ehdr *)in_elf;
+	Elf32_Shdr *shdr = (Elf32_Shdr *) (in_elf + ehdr->e_shoff);
+	Elf32_Phdr *phdr = (Elf32_Phdr *) (in_elf + ehdr->e_phoff);
+	int i, num_sec;
+	Elf32_Rela *rel_table = NULL;
+	unsigned int rela_cnt = 0;
+	u32 rbase;
+
+	BUG_ON(rel_base > (u32)(-1));
+	rbase = (u32) (rel_base & (u32)(~0));
+
+	/* relocate the entry_pt */
+	*entry_pt = (Elf32_Addr)(ehdr->e_entry + rbase);
+	num_sec = ehdr->e_shnum;
+
+	/* Find the relocation(GOT) table through the section header */
+	retval = sst_find_got_table(shdr, num_sec, in_elf,
+					&rel_table, &rela_cnt);
+	if (retval < 0)
+		return retval;
+
+	/* Relocate all the entries in the GOT */
+	retval = sst_relocate_got_entries(rel_table, rela_cnt, in_elf,
+						elf_size, rbase);
+	if (retval < 0)
+		return retval;
+
+	pr_debug("GOT entries relocated\n");
+
+	/* Update the program headers in the ELF */
+	for (i = 0; i < ehdr->e_phnum; i++) {
+		if (phdr[i].p_type == PT_LOAD) {
+			phdr[i].p_vaddr += rbase;
+			phdr[i].p_paddr += rbase;
+		}
+	}
+	pr_debug("program header entries updated\n");
+
+	return retval;
+}
+
+#define ALIGN_256 0x100
+
+int sst_get_next_lib_mem(struct sst_mem_mgr *mgr, int size,
+			unsigned long *lib_base)
+{
+	int retval = 0;
+
+	pr_debug("library orig size = 0x%x", size);
+	if (size % ALIGN_256)
+		size += (ALIGN_256 - (size % ALIGN_256));
+	if (size > mgr->avail)
+		return -ENOMEM;
+
+	*lib_base = mgr->current_base;
+	mgr->current_base += size;
+	mgr->avail -= size;
+	mgr->count++;
+	pr_debug("library base = 0x%lx", *lib_base);
+	pr_debug("library aligned size = 0x%x", size);
+	pr_debug("lib count = %d\n", mgr->count);
+	return retval;
+
+}
+
+static int sst_download_lib_elf(struct intel_sst_drv *sst, const void *lib,
+		int size)
+{
+	int retval = 0;
+
+	pr_debug("In %s\n", __func__);
+
+	if (sst->use_dma) {
+		retval = sst_parse_elf_fw_dma(sst, lib,
+				 &sst->library_list);
+		if (retval)
+			goto free_dma_res;
+		retval = sst_do_dma(&sst->library_list);
+		if (retval)
+			pr_err("sst_do_dma failed, abort\n");
+free_dma_res:
+		kfree(sst->library_list.src);
+		kfree(sst->library_list.dst);
+		sst->library_list.list_len = 0;
+	} else {
+		retval = sst_parse_elf_fw_memcpy(sst, lib,
+				 &sst->libmemcpy_list);
+		if (retval)
+			return retval;
+		sst_do_memcpy(&sst->libmemcpy_list);
+		sst_memcpy_free_lib_resources();
+	}
+	pr_debug("download lib complete");
+	return retval;
+}
+
+static void sst_fill_fw_module_table(struct sst_module_info *mod_list,
+		int list_size, unsigned long ddr_base)
+{
+	int i;
+	u32 *write_ptr = (u32 *)ddr_base;
+
+	pr_debug("In %s\n", __func__);
+
+	for (i = 0; i < list_size; i++) {
+		if (mod_list[i].status == SST_LIB_DOWNLOADED) {
+			pr_debug("status dnwld for %d\n", i);
+			pr_debug("module id %d\n", mod_list[i].id);
+			pr_debug("entry pt 0x%x\n", mod_list[i].entry_pt);
+
+			*write_ptr++ = mod_list[i].id;
+			*write_ptr++ = mod_list[i].entry_pt;
+		}
+	}
+}
+
+static int sst_request_lib_elf(struct sst_module_info *mod_entry,
+	const struct firmware **fw_lib, int pci_id, struct device *dev)
+{
+	char name[25];
+	int retval = 0;
+
+	snprintf(name, sizeof(name), "%s%s%04x%s", mod_entry->name,
+			"_", pci_id, ".bin");
+	pr_debug("Requesting %s\n", name);
+
+	retval = request_firmware(fw_lib, name, dev);
+	if (retval) {
+		pr_err("%s library load failed %d\n", name, retval);
+		return retval;
+	}
+	pr_debug("got lib\n");
+	mod_entry->status = SST_LIB_FOUND;
+	return 0;
+}
+
+static int sst_allocate_lib_mem(const struct firmware *lib, int size,
+	struct sst_mem_mgr *mem_mgr, char **out_elf, unsigned long *lib_start)
+{
+	int retval = 0;
+
+	*out_elf = kzalloc(size, GFP_KERNEL);
+	if (!*out_elf) {
+		pr_err("cannot alloc mem for elf copy %d\n", retval);
+		goto mem_error;
+	}
+
+	memcpy(*out_elf, lib->data, size);
+	retval = sst_get_next_lib_mem(mem_mgr, size, lib_start);
+	if (retval < 0) {
+		pr_err("cannot alloc ddr mem for lib: %d\n", retval);
+		kfree(*out_elf);
+		goto mem_error;
+	}
+	return 0;
+
+mem_error:
+	release_firmware(lib);
+	return -ENOMEM;
+}
+
+int sst_load_all_modules_elf(struct intel_sst_drv *ctx, struct sst_module_info *mod_table,
+								int num_modules)
+{
+	int retval = 0;
+	int i;
+	const struct firmware *fw_lib;
+	struct sst_module_info *mod = NULL;
+	char *out_elf;
+	unsigned int lib_size = 0;
+	unsigned int mod_table_offset = ctx->pdata->lib_info->mod_table_offset;
+	unsigned long lib_base;
+
+	pr_debug("In %s", __func__);
+
+	sst_init_lib_mem_mgr(ctx);
+
+	for (i = 0; i < num_modules; i++) {
+		mod = &mod_table[i];
+		trace_sst_lib_download("Start of Request Lib", mod->name);
+		retval = sst_request_lib_elf(mod, &fw_lib,
+						ctx->pci_id, ctx->dev);
+		if (retval < 0)
+			continue;
+		lib_size = fw_lib->size;
+
+		trace_sst_lib_download("End of Request Lib", mod->name);
+		retval = sst_validate_elf(fw_lib, true);
+		if (retval < 0) {
+			pr_err("library is not valid elf %d\n", retval);
+			release_firmware(fw_lib);
+			continue;
+		}
+		pr_debug("elf validated\n");
+		retval = sst_allocate_lib_mem(fw_lib, lib_size,
+				&ctx->lib_mem_mgr, &out_elf, &lib_base);
+		if (retval < 0) {
+			pr_err("lib mem allocation failed: %d\n", retval);
+			continue;
+		}
+		pr_debug("lib space allocated\n");
+
+		/* relocate in place */
+		retval = sst_relocate_elf(out_elf, lib_size,
+						lib_base, &mod->entry_pt);
+		if (retval < 0) {
+			pr_err("lib elf relocation failed: %d\n", retval);
+			release_firmware(fw_lib);
+			kfree(out_elf);
+			continue;
+		}
+		pr_debug("relocation done\n");
+		release_firmware(fw_lib);
+		trace_sst_lib_download("Start of download Lib", mod->name);
+		/* write to ddr imr region,use memcpy method */
+		retval = sst_download_lib_elf(ctx, out_elf, lib_size);
+		trace_sst_lib_download("End of download Lib", mod->name);
+		mod->status = SST_LIB_DOWNLOADED;
+		kfree(out_elf);
+	}
+
+	/* write module table to DDR */
+	sst_fill_fw_module_table(mod_table, num_modules,
+			(unsigned long)(ctx->ddr + mod_table_offset));
+	return retval;
+}
diff --git a/sound/soc/intel/sst/sst_ipc.c b/sound/soc/intel/sst/sst_ipc.c
new file mode 100644
index 0000000..097c715
--- /dev/null
+++ b/sound/soc/intel/sst/sst_ipc.c
@@ -0,0 +1,768 @@
+/*
+ *  sst_ipc.c - Intel SST Driver for audio engine
+ *
+ *  Copyright (C) 2008-10 Intel Corporation
+ *  Authors:	Vinod Koul <vinod.koul@intel.com>
+ *		Harsha Priya <priya.harsha@intel.com>
+ *		Dharageswari R <dharageswari.r@intel.com>
+ *		KP Jeeja <jeeja.kp@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This file defines all ipc functions
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/pci.h>
+#include <linux/firmware.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <sound/intel_sst_ioctl.h>
+#include "../sst_platform.h"
+#include "../platform_ipc_v2.h"
+#include "sst.h"
+#include "sst_trace.h"
+
+void sst_dump_to_buffer(const void *from, size_t len, char *buf)
+{
+	int i, end;
+	const unsigned char *cmd = from;
+
+	if (len == 0) {
+		buf[0] = '\0';
+		return;
+	}
+
+	for (end = len - 1; end >= 0; end--)
+		if (cmd[end])
+			break;
+	end++;
+
+	buf += snprintf(buf, 3, "%02x", cmd[0]);
+	for (i = 1; i < len; i++) {
+		buf += snprintf(buf, 4, " %02x", cmd[i]);
+		if (i == end && end != len - 1) {
+			sprintf(buf, "...");
+			break;
+		}
+	}
+}
+
+struct sst_block *sst_create_block(struct intel_sst_drv *ctx,
+					u32 msg_id, u32 drv_id)
+{
+	struct sst_block *msg = NULL;
+
+	pr_debug("in %s\n", __func__);
+	msg = kzalloc(sizeof(*msg), GFP_KERNEL);
+	if (!msg) {
+		pr_err("kzalloc block failed\n");
+		return NULL;
+	}
+	msg->condition = false;
+	msg->on = true;
+	msg->msg_id = msg_id;
+	msg->drv_id = drv_id;
+	spin_lock_bh(&ctx->block_lock);
+	list_add_tail(&msg->node, &ctx->block_list);
+	spin_unlock_bh(&ctx->block_lock);
+
+	return msg;
+}
+
+int sst_wake_up_block(struct intel_sst_drv *ctx, int result,
+		u32 drv_id, u32 ipc, void *data, u32 size)
+{
+	struct sst_block *block = NULL;
+
+	pr_debug("in %s\n", __func__);
+	spin_lock_bh(&ctx->block_lock);
+	list_for_each_entry(block, &ctx->block_list, node) {
+		pr_debug("Block ipc %d, drv_id %d\n", block->msg_id,
+							block->drv_id);
+		if (block->msg_id == ipc && block->drv_id == drv_id) {
+			pr_debug("free up the block\n");
+			block->ret_code = result;
+			block->data = data;
+			block->size = size;
+			block->condition = true;
+			spin_unlock_bh(&ctx->block_lock);
+			wake_up(&ctx->wait_queue);
+			return 0;
+		}
+	}
+	spin_unlock_bh(&ctx->block_lock);
+	pr_debug("Block not found or a response is received for a short message for ipc %d, drv_id %d\n",
+			ipc, drv_id);
+	return -EINVAL;
+}
+
+int sst_free_block(struct intel_sst_drv *ctx, struct sst_block *freed)
+{
+	struct sst_block *block = NULL, *__block;
+
+	pr_debug("in %s\n", __func__);
+	spin_lock_bh(&ctx->block_lock);
+	list_for_each_entry_safe(block, __block, &ctx->block_list, node) {
+		if (block == freed) {
+			list_del(&freed->node);
+			kfree(freed->data);
+			freed->data = NULL;
+			kfree(freed);
+			spin_unlock_bh(&ctx->block_lock);
+			return 0;
+		}
+	}
+	spin_unlock_bh(&ctx->block_lock);
+	return -EINVAL;
+}
+
+/*
+ * sst_send_runtime_param - send runtime param to SST
+ *
+ * this function sends the runtime parameter to sst dsp engine
+ */
+static int sst_send_runtime_param(struct snd_sst_runtime_params *params)
+{
+	struct ipc_post *msg = NULL;
+	int ret_val;
+
+	pr_debug("Enter:%s\n", __func__);
+	ret_val = sst_create_ipc_msg(&msg, true);
+	if (ret_val)
+		return ret_val;
+	sst_fill_header(&msg->header, IPC_IA_SET_RUNTIME_PARAMS, 1,
+							params->str_id);
+	msg->header.part.data = sizeof(u32) + sizeof(*params) - sizeof(params->addr)
+				+ params->size;
+	memcpy(msg->mailbox_data, &msg->header.full, sizeof(u32));
+	memcpy(msg->mailbox_data + sizeof(u32), params, sizeof(*params)
+				- sizeof(params->addr));
+	/* driver doesn't need to send address, so overwrite addr with data */
+	memcpy(msg->mailbox_data + sizeof(u32) + sizeof(*params)
+			- sizeof(params->addr),
+			params->addr, params->size);
+	sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+	return 0;
+}
+
+void sst_post_message_mrfld(struct work_struct *work)
+{
+	struct ipc_post *msg;
+	union ipc_header_mrfld header;
+	unsigned long irq_flags;
+
+	pr_debug("Enter:%s\n", __func__);
+	spin_lock_irqsave(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+	/* check list */
+	if (list_empty(&sst_drv_ctx->ipc_dispatch_list)) {
+		/* queue is empty, nothing to send */
+		spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+		pr_debug("Empty msg queue... NO Action\n");
+		return;
+	}
+
+	/* check busy bit */
+	header.full = sst_shim_read64(sst_drv_ctx->shim, SST_IPCX);
+	if (header.p.header_high.part.busy) {
+		spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+		pr_debug("Busy not free... post later\n");
+		return;
+	}
+	/* copy msg from list */
+	msg = list_entry(sst_drv_ctx->ipc_dispatch_list.next,
+			struct ipc_post, node);
+	list_del(&msg->node);
+	pr_debug("sst: size: = %x\n", msg->mrfld_header.p.header_low_payload);
+	if (msg->mrfld_header.p.header_high.part.large)
+		memcpy_toio(sst_drv_ctx->mailbox + SST_MAILBOX_SEND,
+			    msg->mailbox_data, msg->mrfld_header.p.header_low_payload);
+
+	trace_sst_ipc("POST  ->", msg->mrfld_header.p.header_high.full,
+				  msg->mrfld_header.p.header_low_payload,
+				  msg->mrfld_header.p.header_high.part.drv_id);
+	trace_sst_ipc_mailbox(msg->mailbox_data, msg->mrfld_header.p.header_low_payload);
+	sst_shim_write64(sst_drv_ctx->shim, SST_IPCX, msg->mrfld_header.full);
+	spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+	pr_debug("sst: Post message: header = %x\n",
+					msg->mrfld_header.p.header_high.full);
+	kfree(msg->mailbox_data);
+	kfree(msg);
+	return;
+}
+
+/**
+* sst_post_message - Posts message to SST
+*
+* @work: Pointer to work structure
+*
+* This function is called by any component in driver which
+* wants to send an IPC message. This will post message only if
+* busy bit is free
+*/
+void sst_post_message_mfld(struct work_struct *work)
+{
+	struct ipc_post *msg;
+	union ipc_header header;
+	unsigned long irq_flags;
+
+	pr_debug("Enter:%s\n", __func__);
+
+	spin_lock_irqsave(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+	/* check list */
+	if (list_empty(&sst_drv_ctx->ipc_dispatch_list)) {
+		/* queue is empty, nothing to send */
+		spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+		pr_debug("Empty msg queue... NO Action\n");
+		return;
+	}
+
+	/* check busy bit */
+	header.full = sst_shim_read(sst_drv_ctx->shim, sst_drv_ctx->ipc_reg.ipcx);
+	if (header.part.busy) {
+		spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+		pr_debug("Busy not free... Post later\n");
+		return;
+	}
+	/* copy msg from list */
+	msg = list_entry(sst_drv_ctx->ipc_dispatch_list.next,
+			struct ipc_post, node);
+	list_del(&msg->node);
+	pr_debug("size: = %x\n", msg->header.part.data);
+	if (msg->header.part.large)
+		memcpy_toio(sst_drv_ctx->mailbox + SST_MAILBOX_SEND,
+			msg->mailbox_data, msg->header.part.data);
+
+	sst_shim_write(sst_drv_ctx->shim, sst_drv_ctx->ipc_reg.ipcx, msg->header.full);
+	spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+	pr_debug("Posted message: header = %x\n", msg->header.full);
+
+	kfree(msg->mailbox_data);
+	kfree(msg);
+	return;
+}
+
+int sst_sync_post_message_mrfld(struct ipc_post *msg)
+{
+	union ipc_header_mrfld header;
+	unsigned int loop_count = 0;
+	int retval = 0;
+	unsigned long irq_flags;
+
+	pr_debug("Enter:%s\n", __func__);
+	spin_lock_irqsave(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+
+	/* check busy bit */
+	header.full = sst_shim_read64(sst_drv_ctx->shim, SST_IPCX);
+	while (header.p.header_high.part.busy) {
+		if (loop_count > 10) {
+			pr_err("sst: Busy wait failed, cant send this msg\n");
+			retval = -EBUSY;
+			goto out;
+		}
+		udelay(500);
+		loop_count++;
+		header.full = sst_shim_read64(sst_drv_ctx->shim, SST_IPCX);
+	}
+	pr_debug("sst: Post message: header = %x\n",
+					msg->mrfld_header.p.header_high.full);
+	pr_debug("sst: size = 0x%x\n", msg->mrfld_header.p.header_low_payload);
+	if (msg->mrfld_header.p.header_high.part.large)
+		memcpy_toio(sst_drv_ctx->mailbox + SST_MAILBOX_SEND,
+			msg->mailbox_data, msg->mrfld_header.p.header_low_payload);
+
+	trace_sst_ipc("POST  ->", msg->mrfld_header.p.header_high.full,
+				  msg->mrfld_header.p.header_low_payload,
+				  msg->mrfld_header.p.header_high.part.drv_id);
+	trace_sst_ipc_mailbox(msg->mailbox_data, msg->mrfld_header.p.header_low_payload);
+	sst_shim_write64(sst_drv_ctx->shim, SST_IPCX, msg->mrfld_header.full);
+
+out:
+	spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+	kfree(msg->mailbox_data);
+	kfree(msg);
+	return retval;
+}
+
+/* use this for trigger ops to post syncronous msgs
+ */
+int sst_sync_post_message_mfld(struct ipc_post *msg)
+{
+	union ipc_header header;
+	unsigned int loop_count = 0;
+	int retval = 0;
+	unsigned long irq_flags;
+
+	pr_debug("Enter:%s\n", __func__);
+	spin_lock_irqsave(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+
+	/* check busy bit */
+	header.full = sst_shim_read(sst_drv_ctx->shim, sst_drv_ctx->ipc_reg.ipcx);
+	while (header.part.busy) {
+		if (loop_count > 10) {
+			pr_err("busy wait failed, cant send this msg\n");
+			retval = -EBUSY;
+			goto out;
+		}
+		udelay(500);
+		loop_count++;
+		header.full = sst_shim_read(sst_drv_ctx->shim, sst_drv_ctx->ipc_reg.ipcx);
+	}
+	pr_debug("sst: Post message: header = %x\n", msg->header.full);
+	if (msg->header.part.large)
+		memcpy_toio(sst_drv_ctx->mailbox + SST_MAILBOX_SEND,
+			msg->mailbox_data, msg->header.part.data);
+	sst_shim_write(sst_drv_ctx->shim, sst_drv_ctx->ipc_reg.ipcx, msg->header.full);
+
+out:
+	spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+	kfree(msg->mailbox_data);
+	kfree(msg);
+
+	return retval;
+}
+
+/*
+ * sst_clear_interrupt - clear the SST FW interrupt
+ *
+ * This function clears the interrupt register after the interrupt
+ * bottom half is complete allowing next interrupt to arrive
+ */
+void intel_sst_clear_intr_mfld(void)
+{
+	union interrupt_reg isr;
+	union interrupt_reg imr;
+	union ipc_header clear_ipc;
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+	imr.full = sst_shim_read(sst_drv_ctx->shim, SST_IMRX);
+	isr.full = sst_shim_read(sst_drv_ctx->shim, SST_ISRX);
+	/*  write 1 to clear  */;
+	isr.part.busy_interrupt = 1;
+	sst_shim_write(sst_drv_ctx->shim, SST_ISRX, isr.full);
+	/* Set IA done bit */
+	clear_ipc.full = sst_shim_read(sst_drv_ctx->shim, sst_drv_ctx->ipc_reg.ipcd);
+	clear_ipc.part.busy = 0;
+	clear_ipc.part.done = 1;
+	clear_ipc.part.data = IPC_ACK_SUCCESS;
+	sst_shim_write(sst_drv_ctx->shim, sst_drv_ctx->ipc_reg.ipcd, clear_ipc.full);
+	/* un mask busy interrupt */
+	imr.part.busy_interrupt = 0;
+	imr.part.done_interrupt = 0;
+	sst_shim_write(sst_drv_ctx->shim, SST_IMRX, imr.full);
+	spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+}
+
+
+void intel_sst_clear_intr_mrfld(void)
+{
+	union interrupt_reg_mrfld isr;
+	union interrupt_reg_mrfld imr;
+	union ipc_header_mrfld clear_ipc;
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+	imr.full = sst_shim_read64(sst_drv_ctx->shim, SST_IMRX);
+	isr.full = sst_shim_read64(sst_drv_ctx->shim, SST_ISRX);
+
+	/*  write 1 to clear  */
+	isr.part.busy_interrupt = 1;
+	sst_shim_write64(sst_drv_ctx->shim, SST_ISRX, isr.full);
+
+	/* Set IA done bit */
+	clear_ipc.full = sst_shim_read64(sst_drv_ctx->shim, SST_IPCD);
+
+	clear_ipc.p.header_high.part.busy = 0;
+	clear_ipc.p.header_high.part.done = 1;
+	clear_ipc.p.header_low_payload = IPC_ACK_SUCCESS;
+	sst_shim_write64(sst_drv_ctx->shim, SST_IPCD, clear_ipc.full);
+	/* un mask busy interrupt */
+	imr.part.busy_interrupt = 0;
+	sst_shim_write64(sst_drv_ctx->shim, SST_IMRX, imr.full);
+	spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+}
+
+
+/*
+ * process_fw_init - process the FW init msg
+ *
+ * @msg: IPC message mailbox data from FW
+ *
+ * This function processes the FW init msg from FW
+ * marks FW state and prints debug info of loaded FW
+ */
+static void process_fw_init(void *msg)
+{
+	struct ipc_header_fw_init *init =
+		(struct ipc_header_fw_init *)msg;
+	int retval = 0;
+
+	pr_debug("*** FW Init msg came***\n");
+	if (init->result) {
+		sst_drv_ctx->sst_state =  SST_ERROR;
+		pr_debug("FW Init failed, Error %x\n", init->result);
+		pr_err("FW Init failed, Error %x\n", init->result);
+		retval = init->result;
+		goto ret;
+	}
+	pr_info("FW Version %02x.%02x.%02x.%02x\n",
+		init->fw_version.type, init->fw_version.major,
+		init->fw_version.minor, init->fw_version.build);
+	pr_info("Build date %s Time %s\n",
+			init->build_info.date, init->build_info.time);
+
+	/* If there any runtime parameter to set, send it */
+	if (sst_drv_ctx->runtime_param.param.addr)
+		sst_send_runtime_param(&(sst_drv_ctx->runtime_param.param));
+
+ret:
+	sst_wake_up_block(sst_drv_ctx, retval, FW_DWNL_ID, 0 , NULL, 0);
+}
+/**
+* sst_process_message_mfld - Processes message from SST
+*
+* @work:	Pointer to work structure
+*
+* This function is scheduled by ISR
+* It take a msg from process_queue and does action based on msg
+*/
+void sst_process_message_mfld(struct ipc_post *msg)
+{
+	int str_id;
+	struct stream_info *stream;
+
+	str_id = msg->header.part.str_id;
+	pr_debug("IPC process for %x\n", msg->header.full);
+	/* based on msg in list call respective handler */
+	switch (msg->header.part.msg_id) {
+	case IPC_SST_PERIOD_ELAPSED:
+		if (sst_validate_strid(str_id)) {
+			pr_err("stream id %d invalid\n", str_id);
+			break;
+		}
+		stream = &sst_drv_ctx->streams[str_id];
+		if (stream->period_elapsed)
+			stream->period_elapsed(stream->pcm_substream);
+		break;
+	case IPC_SST_BUF_UNDER_RUN:
+	case IPC_SST_BUF_OVER_RUN:
+		if (sst_validate_strid(str_id)) {
+			pr_err("stream id %d invalid\n", str_id);
+			break;
+		}
+		pr_err("Buffer under/overrun for %d\n",
+				msg->header.part.str_id);
+		pr_err("Got Underrun & not to send data...ignore\n");
+		break;
+
+	case IPC_SST_FRAGMENT_ELPASED: {
+		pr_debug("IPC_SST_FRAGMENT_ELPASED for %d", str_id);
+		sst_cdev_fragment_elapsed(str_id);
+		break;
+	}
+
+	case IPC_IA_PRINT_STRING:
+		pr_debug("been asked to print something by fw\n");
+		/* TBD */
+		break;
+
+	case IPC_IA_FW_INIT_CMPLT: {
+		/* send next data to FW */
+		process_fw_init(msg->mailbox_data);
+		break;
+	}
+
+	case IPC_SST_STREAM_PROCESS_FATAL_ERR:
+		if (sst_validate_strid(str_id)) {
+			pr_err("stream id %d invalid\n", str_id);
+			break;
+		}
+		pr_err("codec fatal error %x stream %d...\n",
+				msg->header.full, msg->header.part.str_id);
+		pr_err("Dropping the stream\n");
+		sst_drop_stream(msg->header.part.str_id);
+		break;
+	default:
+		/* Illegal case */
+		pr_err("Unhandled msg %x header %x\n",
+		msg->header.part.msg_id, msg->header.full);
+	}
+	return;
+}
+
+/**
+* sst_process_message - Processes message from SST
+*
+* @work:	Pointer to work structure
+*
+* This function is scheduled by ISR
+* It take a msg from process_queue and does action based on msg
+*/
+
+void sst_process_message_mrfld(struct ipc_post *msg)
+{
+	int str_id;
+
+	str_id = msg->mrfld_header.p.header_high.part.drv_id;
+
+	pr_debug("IPC process message header %x payload %x\n",
+			msg->mrfld_header.p.header_high.full,
+			msg->mrfld_header.p.header_low_payload);
+
+	return;
+}
+
+#define VTSV_MAX_NUM_RESULTS 6
+#define VTSV_SIZE_PER_RESULT 7 /* 7 16 bit words */
+/* Max 6 results each of size 7 words + 1 num results word */
+#define VTSV_MAX_TOTAL_RESULT_SIZE \
+	(VTSV_MAX_NUM_RESULTS*VTSV_SIZE_PER_RESULT + 1)
+/* Each data word in the result is sent as a string in the format:
+DATAn=d, where n is the data word index varying from 0 to
+				VTSV_MAX_TOTAL_RESULT_SIZE-1
+d = string representation of data in decimal format;
+				unsigned 16bit data needs max 5 chars
+So total data string size = 4("DATA")+2("n")+1("=")
+				+5("d")+1(null)+5(reserved) = 18  */
+#define VTSV_DATA_STRING_SIZE 18
+
+static int send_vtsv_result_event(void *data, int size)
+{
+	char *envp[VTSV_MAX_TOTAL_RESULT_SIZE+3];
+	char res_size[30];
+	char ev_type[30];
+	char result[VTSV_MAX_TOTAL_RESULT_SIZE][VTSV_DATA_STRING_SIZE];
+	int offset = 0;
+	u16 *tmp;
+	int i;
+	int ret;
+
+	if (!data) {
+		pr_err("Data pointer Null into %s\n", __func__);
+		return -EINVAL;
+	}
+	size = size / (sizeof(u16)); /* Number of 16 bit data words*/
+	if (size > VTSV_MAX_TOTAL_RESULT_SIZE) {
+		pr_err("VTSV result size exceeds expected value, no uevent sent\n");
+		return -EINVAL;
+	}
+
+	snprintf(ev_type, sizeof(res_size), "EVENT_TYPE=SST_VTSV");
+	envp[offset++] = ev_type;
+	snprintf(res_size, sizeof(ev_type), "VTSV_RESULT_SIZE=%u", size);
+	envp[offset++] = res_size;
+	tmp = (u16 *)(data);
+	for (i = 0; i < size; i++) {
+		/* Driver assumes all data to be u16; The VTSV service
+		layer will type cast to u16 or s16 as appropriate for
+		a given data word*/
+		snprintf(result[i], VTSV_DATA_STRING_SIZE,
+				"DATA%u=%u", i, *tmp++);
+		envp[offset++] = result[i];
+	}
+	envp[offset] = NULL;
+	ret = kobject_uevent_env(&sst_drv_ctx->dev->kobj, KOBJ_CHANGE, envp);
+	if (ret)
+		pr_err("VTSV event send failed: ret = %d\n", ret);
+	return ret;
+}
+
+static void process_fw_async_msg(struct ipc_post *msg)
+{
+	u32 msg_id;
+	int str_id;
+	int res_size, ret;
+	u32 data_size, i;
+	void *data_offset;
+	struct stream_info *stream;
+	union ipc_header_high msg_high;
+	u32 msg_low, pipe_id;
+
+	msg_high = msg->mrfld_header.p.header_high;
+	msg_low = msg->mrfld_header.p.header_low_payload;
+	msg_id = ((struct ipc_dsp_hdr *)msg->mailbox_data)->cmd_id;
+	data_offset = (msg->mailbox_data + sizeof(struct ipc_dsp_hdr));
+	data_size =  msg_low - (sizeof(struct ipc_dsp_hdr));
+
+	switch (msg_id) {
+	case IPC_SST_PERIOD_ELAPSED_MRFLD:
+		pipe_id = ((struct ipc_dsp_hdr *)msg->mailbox_data)->pipe_id;
+		str_id = get_stream_id_mrfld(pipe_id);
+		if (str_id > 0) {
+			pr_debug("Period elapsed rcvd for pipe id 0x%x\n", pipe_id);
+			stream = &sst_drv_ctx->streams[str_id];
+			if (stream->period_elapsed)
+				stream->period_elapsed(stream->pcm_substream);
+			if (stream->compr_cb)
+				stream->compr_cb(stream->compr_cb_param);
+		}
+		break;
+
+	case IPC_IA_DRAIN_STREAM_MRFLD:
+		pipe_id = ((struct ipc_dsp_hdr *)msg->mailbox_data)->pipe_id;
+		str_id = get_stream_id_mrfld(pipe_id);
+		if (str_id > 0) {
+			stream = &sst_drv_ctx->streams[str_id];
+			if (stream->drain_notify)
+				stream->drain_notify(stream->drain_cb_param);
+		}
+		break;
+
+	case IPC_IA_FW_ASYNC_ERR_MRFLD:
+		pr_err("FW sent async error msg:\n");
+		for (i = 0; i < (data_size/4); i++)
+			pr_err("0x%x\n", (*((unsigned int *)data_offset + i)));
+		break;
+
+	case IPC_IA_VTSV_DETECTED:
+		res_size = data_size;
+		ret = send_vtsv_result_event(data_offset, res_size);
+		if (ret)
+			pr_err("VTSV uevent send failed: %d\n", ret);
+		else
+			pr_debug("VTSV uevent sent\n");
+		break;
+
+	case IPC_IA_FW_INIT_CMPLT_MRFLD:
+		process_fw_init(data_offset);
+		break;
+
+	case IPC_IA_BUF_UNDER_RUN_MRFLD:
+		pipe_id = ((struct ipc_dsp_hdr *)msg->mailbox_data)->pipe_id;
+		str_id = get_stream_id_mrfld(pipe_id);
+		if (str_id > 0)
+			pr_err("Buffer under-run for pipe:%#x str_id:%d\n",
+					pipe_id, str_id);
+		break;
+
+	default:
+		pr_err("Unrecognized async msg from FW msg_id %#x\n", msg_id);
+	}
+}
+
+void sst_process_reply_mrfld(struct ipc_post *msg)
+{
+	unsigned int drv_id;
+	void *data;
+	union ipc_header_high msg_high;
+	u32 msg_low;
+
+	msg_high = msg->mrfld_header.p.header_high;
+	msg_low = msg->mrfld_header.p.header_low_payload;
+
+	pr_debug("IPC process message header %x payload %x\n",
+			msg->mrfld_header.p.header_high.full,
+			msg->mrfld_header.p.header_low_payload);
+
+	drv_id = msg_high.part.drv_id;
+
+	/* Check for async messages */
+	if (drv_id == SST_ASYNC_DRV_ID) {
+		/* FW sent async large message */
+		process_fw_async_msg(msg);
+		goto end;
+	}
+
+	/* FW sent short error response for an IPC */
+	if (msg_high.part.result && drv_id && !msg_high.part.large) {
+		/* 32-bit FW error code in msg_low */
+		pr_err("FW sent error response 0x%x", msg_low);
+		sst_wake_up_block(sst_drv_ctx, msg_high.part.result,
+			msg_high.part.drv_id,
+			msg_high.part.msg_id, NULL, 0);
+		goto end;
+	}
+
+	/* Process all valid responses */
+	/* if it is a large message, the payload contains the size to
+	 * copy from mailbox */
+	if (msg_high.part.large) {
+		data = kzalloc(msg_low, GFP_KERNEL);
+		if (!data)
+			goto end;
+		memcpy(data, (void *) msg->mailbox_data, msg_low);
+		if (sst_wake_up_block(sst_drv_ctx, msg_high.part.result,
+				msg_high.part.drv_id,
+				msg_high.part.msg_id, data, msg_low))
+			kfree(data);
+	} else {
+		sst_wake_up_block(sst_drv_ctx, msg_high.part.result,
+				msg_high.part.drv_id,
+				msg_high.part.msg_id, NULL, 0);
+	}
+
+end:
+	return;
+}
+
+/**
+* sst_process_reply - Processes reply message from SST
+*
+* @work:	Pointer to work structure
+*
+* This function is scheduled by ISR
+* It take a reply msg from response_queue and
+* does action based on msg
+*/
+void sst_process_reply_mfld(struct ipc_post *msg)
+{
+	void *data;
+	int str_id;
+	struct stream_info *stream;
+
+
+	str_id = msg->header.part.str_id;
+
+	pr_debug("sst: IPC process reply for %x\n", msg->header.full);
+
+	/* handle drain notify first */
+	if (msg->header.part.msg_id == IPC_IA_DRAIN_STREAM) {
+		pr_debug("drain message notify\n");
+		if (str_id > 0) {
+			stream = &sst_drv_ctx->streams[str_id];
+			if (stream->drain_notify)
+				stream->drain_notify(stream->drain_cb_param);
+		}
+		return;
+	}
+
+
+	if (!msg->header.part.large) {
+		if (!msg->header.part.data)
+			pr_debug("Success\n");
+		else
+			pr_err("Error from firmware: %d\n", msg->header.part.data);
+		sst_wake_up_block(sst_drv_ctx, msg->header.part.data,
+				str_id, msg->header.part.msg_id, NULL, 0);
+	} else {
+		pr_debug("Allocating %d\n", msg->header.part.data);
+		data = kzalloc(msg->header.part.data, GFP_KERNEL);
+		if (!data) {
+			pr_err("sst: mem alloc failed\n");
+			return;
+		}
+
+		memcpy(data, (void *)msg->mailbox_data, msg->header.part.data);
+		if (sst_wake_up_block(sst_drv_ctx, 0, str_id,
+				msg->header.part.msg_id, data,
+				msg->header.part.data))
+			kfree(data);
+	}
+	return;
+}
diff --git a/sound/soc/intel/sst/sst_pvt.c b/sound/soc/intel/sst/sst_pvt.c
new file mode 100644
index 0000000..7638cb8
--- /dev/null
+++ b/sound/soc/intel/sst/sst_pvt.c
@@ -0,0 +1,577 @@
+/*
+ *  sst_pvt.c - Intel SST Driver for audio engine
+ *
+ *  Copyright (C) 2008-10	Intel Corp
+ *  Authors:	Vinod Koul <vinod.koul@intel.com>
+ *		Harsha Priya <priya.harsha@intel.com>
+ *		Dharageswari R <dharageswari.r@intel.com>
+ *		KP Jeeja <jeeja.kp@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This file contains all private functions
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/kobject.h>
+#include <linux/pci.h>
+#include <linux/fs.h>
+#include <linux/firmware.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <sound/asound.h>
+#include <sound/pcm.h>
+#include <sound/compress_offload.h>
+#include "../sst_platform.h"
+#include "../platform_ipc_v2.h"
+#include "sst.h"
+
+#define SST_EXCE_DUMP_BASE	0xFFFF2c00
+#define SST_EXCE_DUMP_WORD	4
+#define SST_EXCE_DUMP_LEN	32
+#define SST_EXCE_DUMP_SIZE	((SST_EXCE_DUMP_LEN)*(SST_EXCE_DUMP_WORD))
+#define SST_EXCE_DUMP_OFFSET	0xA00
+/*
+ * sst_wait_interruptible - wait on event
+ *
+ * @sst_drv_ctx: Driver context
+ * @block: Driver block to wait on
+ *
+ * This function waits without a timeout (and is interruptable) for a
+ * given block event
+ */
+int sst_wait_interruptible(struct intel_sst_drv *sst_drv_ctx,
+				struct sst_block *block)
+{
+	int retval = 0;
+
+	if (!wait_event_interruptible(sst_drv_ctx->wait_queue,
+				block->condition)) {
+		/* event wake */
+		if (block->ret_code < 0) {
+			pr_err("stream failed %d\n", block->ret_code);
+			retval = -EBUSY;
+		} else {
+			pr_debug("event up\n");
+			retval = 0;
+		}
+	} else {
+		pr_err("signal interrupted\n");
+		retval = -EINTR;
+	}
+	return retval;
+
+}
+
+unsigned long long read_shim_data(struct intel_sst_drv *sst, int addr)
+{
+	unsigned long long val = 0;
+
+	switch (sst->pci_id) {
+	case SST_CLV_PCI_ID:
+		val = sst_shim_read(sst->shim, addr);
+		break;
+	case SST_MRFLD_PCI_ID:
+	case SST_BYT_PCI_ID:
+		val = sst_shim_read64(sst->shim, addr);
+		break;
+	}
+	return val;
+}
+
+void write_shim_data(struct intel_sst_drv *sst, int addr,
+				unsigned long long data)
+{
+	switch (sst->pci_id) {
+	case SST_CLV_PCI_ID:
+		sst_shim_write(sst->shim, addr, (u32) data);
+		break;
+	case SST_MRFLD_PCI_ID:
+	case SST_BYT_PCI_ID:
+		sst_shim_write64(sst->shim, addr, (u64) data);
+		break;
+	}
+}
+
+
+void dump_sst_shim(struct intel_sst_drv *sst)
+{
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&sst->ipc_spin_lock, irq_flags);
+	pr_err("audio shim registers:\n"
+		"CSR: %.8llx\n"
+		"PISR: %.8llx\n"
+		"PIMR: %.8llx\n"
+		"ISRX: %.8llx\n"
+		"ISRD: %.8llx\n"
+		"IMRX: %.8llx\n"
+		"IMRD: %.8llx\n"
+		"IPCX: %.8llx\n"
+		"IPCD: %.8llx\n"
+		"ISRSC: %.8llx\n"
+		"ISRLPESC: %.8llx\n"
+		"IMRSC: %.8llx\n"
+		"IMRLPESC: %.8llx\n"
+		"IPCSC: %.8llx\n"
+		"IPCLPESC: %.8llx\n"
+		"CLKCTL: %.8llx\n"
+		"CSR2: %.8llx\n",
+		read_shim_data(sst, SST_CSR),
+		read_shim_data(sst, SST_PISR),
+		read_shim_data(sst, SST_PIMR),
+		read_shim_data(sst, SST_ISRX),
+		read_shim_data(sst, SST_ISRD),
+		read_shim_data(sst, SST_IMRX),
+		read_shim_data(sst, SST_IMRD),
+		read_shim_data(sst, sst->ipc_reg.ipcx),
+		read_shim_data(sst, sst->ipc_reg.ipcd),
+		read_shim_data(sst, SST_ISRSC),
+		read_shim_data(sst, SST_ISRLPESC),
+		read_shim_data(sst, SST_IMRSC),
+		read_shim_data(sst, SST_IMRLPESC),
+		read_shim_data(sst, SST_IPCSC),
+		read_shim_data(sst, SST_IPCLPESC),
+		read_shim_data(sst, SST_CLKCTL),
+		read_shim_data(sst, SST_CSR2));
+	spin_unlock_irqrestore(&sst->ipc_spin_lock, irq_flags);
+}
+
+void reset_sst_shim(struct intel_sst_drv *sst)
+{
+	union config_status_reg_mrfld csr;
+
+	pr_err("Resetting few Shim registers\n");
+	write_shim_data(sst, sst->ipc_reg.ipcx, 0x0);
+	write_shim_data(sst, sst->ipc_reg.ipcd, 0x0);
+	write_shim_data(sst, SST_ISRX, 0x0);
+	write_shim_data(sst, SST_ISRD, 0x0);
+	write_shim_data(sst, SST_IPCSC, 0x0);
+	write_shim_data(sst, SST_IPCLPESC, 0x0);
+	write_shim_data(sst, SST_ISRSC, 0x0);
+	write_shim_data(sst, SST_ISRLPESC, 0x0);
+	write_shim_data(sst, SST_PISR, 0x0);
+
+	/* Reset the CSR value to the default value. i.e 0x1e40001*/
+	csr.full = sst_shim_read64(sst_drv_ctx->shim, SST_CSR);
+	csr.part.xt_snoop = 0;
+	csr.full &= ~(0xf);
+	csr.full |= 0x01;
+	sst_shim_write64(sst_drv_ctx->shim, SST_CSR, csr.full);
+}
+
+static void dump_sst_crash_area(void)
+{
+	void __iomem *fw_dump_area;
+	u32 dump_word;
+	u8 i;
+
+	/* dump the firmware SRAM where the exception details are stored */
+	fw_dump_area = ioremap_nocache(SST_EXCE_DUMP_BASE, SST_EXCE_DUMP_SIZE);
+
+	pr_err("Firmware exception dump begins:\n");
+	pr_err("Exception start signature:%#x\n", readl(fw_dump_area + SST_EXCE_DUMP_WORD));
+	pr_err("EXCCAUSE:\t\t\t%#x\n", readl(fw_dump_area + SST_EXCE_DUMP_WORD*2));
+	pr_err("EXCVADDR:\t\t\t%#x\n", readl(fw_dump_area + (SST_EXCE_DUMP_WORD*3)));
+	pr_err("Firmware additional data:\n");
+
+	/* dump remaining FW debug data */
+	for (i = 1; i < (SST_EXCE_DUMP_LEN-4+1); i++) {
+		dump_word = readl(fw_dump_area + (SST_EXCE_DUMP_WORD*3)
+						+ (i*SST_EXCE_DUMP_WORD));
+		pr_err("Data[%d]=%#x\n", i, dump_word);
+	}
+	iounmap(fw_dump_area);
+	pr_err("Firmware exception dump ends\n");
+}
+
+/**
+ * dump_ram_area - dumps the iram/dram into a local buff
+ *
+ * @sst			: pointer to driver context
+ * @recovery		: pointer to the struct containing buffers
+ * @iram		: true if iram dump else false
+ * This function dumps the iram dram data into the respective buffers
+ */
+static void dump_ram_area(struct intel_sst_drv *sst,
+			struct sst_dump_buf *dump_buf, enum sst_ram_type type)
+{
+	if (type == SST_IRAM) {
+		pr_err("Iram dumped in buffer\n");
+		memcpy_fromio(dump_buf->iram_buf.buf, sst->iram,
+				dump_buf->iram_buf.size);
+	} else {
+		pr_err("Dram dumped in buffer\n");
+		memcpy_fromio(dump_buf->dram_buf.buf, sst->dram,
+				dump_buf->dram_buf.size);
+	}
+}
+
+/*FIXME Disabling IRAM/DRAM dump for timeout issues */
+static void sst_stream_recovery(struct intel_sst_drv *sst)
+{
+	struct stream_info *str_info;
+	u8 i;
+	for (i = 1; i <= sst->info.max_streams; i++) {
+		pr_err("Audio: Stream %d, state %d\n", i, sst->streams[i].status);
+		if (sst->streams[i].status != STREAM_UN_INIT) {
+			str_info = &sst_drv_ctx->streams[i];
+			if (str_info->pcm_substream)
+				snd_pcm_stop(str_info->pcm_substream, SNDRV_PCM_STATE_SETUP);
+			else if (str_info->compr_cb_param)
+				snd_compr_stop(str_info->compr_cb_param);
+			sst->streams[i].status = STREAM_RESET;
+		}
+	}
+}
+
+static void sst_dump_ipc_dispatch_lists(struct intel_sst_drv *sst)
+{
+	struct ipc_post *m, *_m;
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&sst->ipc_spin_lock, irq_flags);
+	if (list_empty(&sst->ipc_dispatch_list))
+		pr_err("ipc dispatch list is Empty\n");
+
+	list_for_each_entry_safe(m, _m, &sst->ipc_dispatch_list, node) {
+		pr_err("ipc-dispatch:pending msg header %#x\n", m->header.full);
+		list_del(&m->node);
+		kfree(m->mailbox_data);
+		kfree(m);
+	}
+	spin_unlock_irqrestore(&sst->ipc_spin_lock, irq_flags);
+}
+
+static void sst_dump_rx_lists(struct intel_sst_drv *sst)
+{
+	struct ipc_post *m, *_m;
+	unsigned long irq_flags;
+
+	spin_lock_irqsave(&sst->rx_msg_lock, irq_flags);
+	if (list_empty(&sst->rx_list))
+		pr_err("rx msg list is empty\n");
+
+	list_for_each_entry_safe(m, _m, &sst->rx_list, node) {
+		pr_err("rx: pending msg header %#x\n", m->header.full);
+		list_del(&m->node);
+		kfree(m->mailbox_data);
+		kfree(m);
+	}
+	spin_unlock_irqrestore(&sst->rx_msg_lock, irq_flags);
+}
+
+/* num_dwords: should be multiple of 4 */
+static void dump_buffer_fromio(void __iomem *from,
+				     unsigned int num_dwords)
+{
+	int i;
+	u32 val[4];
+
+	if (num_dwords % 4) {
+		pr_err("%s: num_dwords %d not multiple of 4\n",
+				__func__, num_dwords);
+		return;
+	}
+
+	pr_err("****** Start *******\n");
+	pr_err("Dump %d dwords, from location %p\n", num_dwords, from);
+
+	for (i = 0; i < num_dwords; ) {
+		val[0] = ioread32(from + (i++ * 4));
+		val[1] = ioread32(from + (i++ * 4));
+		val[2] = ioread32(from + (i++ * 4));
+		val[3] = ioread32(from + (i++ * 4));
+		pr_err("%.8x %.8x %.8x %.8x\n", val[0], val[1], val[2], val[3]);
+	}
+	pr_err("****** End *********\n\n\n");
+}
+
+static void sst_stall_lpe_n_wait(struct intel_sst_drv *sst)
+{
+	union config_status_reg_mrfld csr;
+	void __iomem *dma_reg0 = sst->debugfs.dma_reg[0];
+	void __iomem *dma_reg1 = sst->debugfs.dma_reg[1];
+	int offset = 0x3A0; /* ChEnReg of DMA */
+
+
+	pr_err("Before stall: DMA_0 Ch_EN %#llx DMA_1 Ch_EN %#llx\n",
+				sst_reg_read64(dma_reg0, offset),
+				sst_reg_read64(dma_reg1, offset));
+
+	/* Stall LPE */
+	csr.full = sst_shim_read64(sst->shim, SST_CSR);
+	csr.part.runstall  = 1;
+	sst_shim_write64(sst->shim, SST_CSR, csr.full);
+
+	/* A 5ms delay, before resetting the LPE */
+	usleep_range(5000, 5100);
+
+	pr_err("After stall: DMA_0 Ch_EN %#llx DMA_1 Ch_EN %#llx\n",
+				sst_reg_read64(dma_reg0, offset),
+				sst_reg_read64(dma_reg1, offset));
+}
+
+#if IS_ENABLED(CONFIG_INTEL_SCU_IPC)
+static void sst_send_scu_reset_ipc(struct intel_sst_drv *sst)
+{
+	int ret = 0;
+
+	/* Reset and power gate the LPE */
+	ret = intel_scu_ipc_simple_command(IPC_SCU_LPE_RESET, 0);
+	if (ret) {
+		pr_err("Power gating LPE failed %d\n", ret);
+		reset_sst_shim(sst);
+	} else {
+		pr_err("LPE reset via SCU is success!!\n");
+		pr_err("dump after LPE power cycle\n");
+		dump_sst_shim(sst);
+
+		/* Mask the DMA & SSP interrupts */
+		sst_shim_write64(sst->shim, SST_IMRX, 0xFFFF0038);
+	}
+}
+#else
+static void sst_send_scu_reset_ipc(struct intel_sst_drv *sst)
+{
+	pr_debug("%s: do nothing, just return\n", __func__);
+}
+#endif
+
+#define SRAM_OFFSET_MRFLD	0xc00
+#define NUM_DWORDS		256
+void sst_do_recovery_mrfld(struct intel_sst_drv *sst)
+{
+	char iram_event[30], dram_event[30], ddr_imr_event[65], event_type[30];
+	char *envp[5];
+	int env_offset = 0;
+
+	/*
+	 * setting firmware state as uninit so that the firmware will get
+	 * redownloaded on next request.This is because firmare not responding
+	 * for 1 sec is equalant to some unrecoverable error of FW.
+	 */
+	pr_err("Audio: Intel SST engine encountered an unrecoverable error\n");
+	pr_err("Audio: trying to reset the dsp now\n");
+
+	mutex_lock(&sst->sst_lock);
+	sst->sst_state = SST_UN_INIT;
+	sst_stream_recovery(sst);
+	mutex_unlock(&sst->sst_lock);
+
+	dump_stack();
+	dump_sst_shim(sst);
+
+	sst_stall_lpe_n_wait(sst);
+
+	/* dump mailbox and sram */
+	pr_err("Dumping Mailbox...\n");
+	dump_buffer_fromio(sst->mailbox, NUM_DWORDS);
+	pr_err("Dumping SRAM...\n");
+	dump_buffer_fromio(sst->mailbox + SRAM_OFFSET_MRFLD, NUM_DWORDS);
+
+	if (sst_drv_ctx->ops->set_bypass) {
+
+		sst_drv_ctx->ops->set_bypass(true);
+		dump_ram_area(sst, &(sst->dump_buf), SST_IRAM);
+		dump_ram_area(sst, &(sst->dump_buf), SST_DRAM);
+		sst_drv_ctx->ops->set_bypass(false);
+
+	}
+
+	snprintf(event_type, sizeof(event_type), "EVENT_TYPE=SST_RECOVERY");
+	envp[env_offset++] = event_type;
+	snprintf(iram_event, sizeof(iram_event), "IRAM_DUMP_SIZE=%d",
+					sst->dump_buf.iram_buf.size);
+	envp[env_offset++] = iram_event;
+	snprintf(dram_event, sizeof(dram_event), "DRAM_DUMP_SIZE=%d",
+					sst->dump_buf.dram_buf.size);
+	envp[env_offset++] = dram_event;
+
+	if (sst->ddr != NULL) {
+		snprintf(ddr_imr_event, sizeof(ddr_imr_event),
+		"DDR_IMR_DUMP_SIZE=%d DDR_IMR_ADDRESS=%p", (sst->ddr_end - sst->ddr_base), sst->ddr);
+		envp[env_offset++] = ddr_imr_event;
+	}
+	envp[env_offset] = NULL;
+	kobject_uevent_env(&sst->dev->kobj, KOBJ_CHANGE, envp);
+	pr_err("Recovery Uevent Sent!!\n");
+
+	/* Send IPC to SCU to power gate and reset the LPE */
+	sst_send_scu_reset_ipc(sst);
+
+	pr_err("reset the pvt id from val %d\n", sst_drv_ctx->pvt_id);
+	spin_lock(&sst_drv_ctx->pvt_id_lock);
+	sst_drv_ctx->pvt_id = 0;
+	spin_unlock(&sst_drv_ctx->pvt_id_lock);
+	sst_dump_ipc_dispatch_lists(sst_drv_ctx);
+	sst_dump_rx_lists(sst_drv_ctx);
+
+	if (sst_drv_ctx->fw_in_mem) {
+		pr_err("Clearing the cached FW copy...\n");
+		kfree(sst_drv_ctx->fw_in_mem);
+		sst_drv_ctx->fw_in_mem = NULL;
+	}
+}
+
+void sst_do_recovery(struct intel_sst_drv *sst)
+{
+	pr_err("Audio: Intel SST engine encountered an unrecoverable error\n");
+
+	dump_stack();
+	dump_sst_shim(sst);
+
+	if (sst->sst_state == SST_FW_RUNNING &&
+		sst_drv_ctx->pci_id == SST_CLV_PCI_ID)
+		dump_sst_crash_area();
+
+	sst_dump_ipc_dispatch_lists(sst_drv_ctx);
+
+}
+
+/*
+ * sst_wait_timeout - wait on event for timeout
+ *
+ * @sst_drv_ctx: Driver context
+ * @block: Driver block to wait on
+ *
+ * This function waits with a timeout value (and is not interruptible) on a
+ * given block event
+ */
+int sst_wait_timeout(struct intel_sst_drv *sst_drv_ctx, struct sst_block *block)
+{
+	int retval = 0;
+
+	/* NOTE:
+	Observed that FW processes the alloc msg and replies even
+	before the alloc thread has finished execution */
+	pr_debug("sst: waiting for condition %x ipc %d drv_id %d\n",
+		       block->condition, block->msg_id, block->drv_id);
+	if (wait_event_timeout(sst_drv_ctx->wait_queue,
+				block->condition,
+				msecs_to_jiffies(SST_BLOCK_TIMEOUT))) {
+		/* event wake */
+		pr_debug("sst: Event wake %x\n", block->condition);
+		pr_debug("sst: message ret: %d\n", block->ret_code);
+		retval = -block->ret_code;
+	} else {
+		block->on = false;
+		pr_err("sst: Wait timed-out condition:%#x, msg_id:%#x fw_state %#x\n",
+				block->condition, block->msg_id, sst_drv_ctx->sst_state);
+
+		if (sst_drv_ctx->sst_state == SST_FW_LOADED ||
+			sst_drv_ctx->sst_state ==  SST_START_INIT) {
+			pr_err("Can't recover as timedout while downloading the FW\n");
+			pr_err("reseting fw state to unint from %d ...\n", sst_drv_ctx->sst_state);
+			sst_drv_ctx->sst_state = SST_UN_INIT;
+
+			dump_sst_shim(sst_drv_ctx);
+
+			/* Reset & Power Off the LPE only for MRFLD */
+			if (sst_drv_ctx->pci_id == SST_MRFLD_PCI_ID) {
+				sst_stall_lpe_n_wait(sst_drv_ctx);
+
+				/* Send IPC to SCU to power gate and reset the LPE */
+				sst_send_scu_reset_ipc(sst_drv_ctx);
+			}
+
+		} else {
+			if (sst_drv_ctx->ops->do_recovery)
+				sst_drv_ctx->ops->do_recovery(sst_drv_ctx);
+		}
+
+		retval = -EBUSY;
+	}
+	return retval;
+}
+
+/*
+ * sst_create_ipc_msg - create a IPC message
+ *
+ * @arg: ipc message
+ * @large: large or short message
+ *
+ * this function allocates structures to send a large or short
+ * message to the firmware
+ */
+int sst_create_ipc_msg(struct ipc_post **arg, bool large)
+{
+	struct ipc_post *msg;
+
+	msg = kzalloc(sizeof(struct ipc_post), GFP_ATOMIC);
+	if (!msg) {
+		pr_err("kzalloc ipc msg failed\n");
+		return -ENOMEM;
+	}
+	if (large) {
+		msg->mailbox_data = kzalloc(SST_MAILBOX_SIZE, GFP_ATOMIC);
+		if (!msg->mailbox_data) {
+			kfree(msg);
+			pr_err("kzalloc mailbox_data failed");
+			return -ENOMEM;
+		}
+	} else {
+		msg->mailbox_data = NULL;
+	}
+	msg->is_large = large;
+	*arg = msg;
+	return 0;
+}
+
+/*
+ * sst_create_block_and_ipc_msg - Creates IPC message and sst block
+ * @arg: passed to sst_create_ipc_message API
+ * @large: large or short message
+ * @sst_drv_ctx: sst driver context
+ * @block: return block allocated
+ * @msg_id: IPC
+ * @drv_id: stream id or private id
+ */
+int sst_create_block_and_ipc_msg(struct ipc_post **arg, bool large,
+		struct intel_sst_drv *sst_drv_ctx, struct sst_block **block,
+		u32 msg_id, u32 drv_id)
+{
+	int retval = 0;
+	retval = sst_create_ipc_msg(arg, large);
+	if (retval)
+		return retval;
+	*block = sst_create_block(sst_drv_ctx, msg_id, drv_id);
+	if (*block == NULL) {
+		kfree(*arg);
+		return -ENOMEM;
+	}
+	return retval;
+}
+
+/*
+ * sst_clean_stream - clean the stream context
+ *
+ * @stream: stream structure
+ *
+ * this function resets the stream contexts
+ * should be called in free
+ */
+void sst_clean_stream(struct stream_info *stream)
+{
+	stream->status = STREAM_UN_INIT;
+	stream->prev = STREAM_UN_INIT;
+	mutex_lock(&stream->lock);
+	stream->cumm_bytes = 0;
+	mutex_unlock(&stream->lock);
+}
+
diff --git a/sound/soc/intel/sst/sst_stream.c b/sound/soc/intel/sst/sst_stream.c
new file mode 100644
index 0000000..9e71b44
--- /dev/null
+++ b/sound/soc/intel/sst/sst_stream.c
@@ -0,0 +1,831 @@
+/*
+ *  sst_stream.c - Intel SST Driver for audio engine
+ *
+ *  Copyright (C) 2008-10 Intel Corp
+ *  Authors:	Vinod Koul <vinod.koul@intel.com>
+ *		Harsha Priya <priya.harsha@intel.com>
+ *		Dharageswari R <dharageswari.r@intel.com>
+ *		KP Jeeja <jeeja.kp@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This file contains the stream operations of SST driver
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/pci.h>
+#include <linux/firmware.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/pm_runtime.h>
+#include <asm/platform_sst_audio.h>
+#include "../sst_platform.h"
+#include "../platform_ipc_v2.h"
+#include "sst.h"
+#include "sst_trace.h"
+
+/**
+ * sst_alloc_stream - Send msg for a new stream ID
+ *
+ * @params:	stream params
+ * @stream_ops:	operation of stream PB/capture
+ * @codec:	codec for stream
+ * @device:	device stream to be allocated for
+ *
+ * This function is called by any function which wants to start
+ * a new stream. This also check if a stream exists which is idle
+ * it initializes idle stream id to this request
+ */
+int sst_alloc_stream_ctp(char *params, struct sst_block *block)
+{
+	struct ipc_post *msg = NULL;
+	struct snd_sst_alloc_params alloc_param;
+	unsigned int pcm_slot = 0x03, num_ch;
+	int str_id;
+	struct snd_sst_params *str_params;
+	struct snd_sst_stream_params *sparams;
+	struct snd_sst_alloc_params_ext *aparams;
+	struct stream_info *str_info;
+	unsigned int stream_ops, device;
+	u8 codec;
+
+	pr_debug("In %s\n", __func__);
+
+	BUG_ON(!params);
+	str_params = (struct snd_sst_params *)params;
+	stream_ops = str_params->ops;
+	codec = str_params->codec;
+	device = str_params->device_type;
+	sparams = &str_params->sparams;
+	aparams = &str_params->aparams;
+	num_ch = sst_get_num_channel(str_params);
+
+	pr_debug("period_size = %d\n", aparams->frag_size);
+	pr_debug("ring_buf_addr = 0x%x\n", aparams->ring_buf_info[0].addr);
+	pr_debug("ring_buf_size = %d\n", aparams->ring_buf_info[0].size);
+	pr_debug("In alloc device_type=%d\n", str_params->device_type);
+	pr_debug("In alloc sg_count =%d\n", aparams->sg_count);
+
+	str_id = str_params->stream_id;
+	if (str_id <= 0)
+		return -EBUSY;
+
+	/*allocate device type context*/
+	sst_init_stream(&sst_drv_ctx->streams[str_id], codec,
+			str_id, stream_ops, pcm_slot);
+	/* send msg to FW to allocate a stream */
+	if (sst_create_ipc_msg(&msg, true))
+		return -ENOMEM;
+
+	alloc_param.str_type.codec_type = codec;
+	alloc_param.str_type.str_type = str_params->stream_type;
+	alloc_param.str_type.operation = stream_ops;
+	alloc_param.str_type.protected_str = 0; /* non drm */
+	alloc_param.str_type.time_slots = pcm_slot;
+	alloc_param.str_type.reserved = 0;
+	alloc_param.str_type.result = 0;
+	memcpy(&alloc_param.stream_params, sparams,
+			sizeof(struct snd_sst_stream_params));
+	memcpy(&alloc_param.alloc_params, aparams,
+			sizeof(struct snd_sst_alloc_params_ext));
+	block->drv_id = str_id;
+	block->msg_id = IPC_IA_ALLOC_STREAM;
+	sst_fill_header(&msg->header, IPC_IA_ALLOC_STREAM, 1, str_id);
+	msg->header.part.data = sizeof(alloc_param) + sizeof(u32);
+	memcpy(msg->mailbox_data, &msg->header, sizeof(u32));
+	memcpy(msg->mailbox_data + sizeof(u32), &alloc_param,
+			sizeof(alloc_param));
+	str_info = &sst_drv_ctx->streams[str_id];
+	str_info->num_ch = num_ch;
+	sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+	return str_id;
+}
+
+int sst_alloc_stream_mrfld(char *params, struct sst_block *block)
+{
+	struct ipc_post *msg = NULL;
+	struct snd_sst_alloc_mrfld alloc_param;
+	struct ipc_dsp_hdr dsp_hdr;
+	struct snd_sst_params *str_params;
+	struct snd_sst_tstamp fw_tstamp;
+	unsigned int str_id, pipe_id, pvt_id, task_id;
+	u32 len = 0;
+	struct stream_info *str_info;
+	int i, num_ch;
+
+	pr_debug("In %s\n", __func__);
+	BUG_ON(!params);
+
+	str_params = (struct snd_sst_params *)params;
+	memset(&alloc_param, 0, sizeof(alloc_param));
+	alloc_param.operation = str_params->ops;
+	alloc_param.codec_type = str_params->codec;
+	alloc_param.sg_count = str_params->aparams.sg_count;
+	alloc_param.ring_buf_info[0].addr = str_params->aparams.ring_buf_info[0].addr;
+	alloc_param.ring_buf_info[0].size = str_params->aparams.ring_buf_info[0].size;
+	alloc_param.frag_size = str_params->aparams.frag_size;
+
+	memcpy(&alloc_param.codec_params, &str_params->sparams,
+			sizeof(struct snd_sst_stream_params));
+
+	/* fill channel map params for multichannel support.
+	 * Ideally channel map should be received from upper layers
+	 * for multichannel support.
+	 * Currently hardcoding as per FW reqm.
+	 */
+	num_ch = sst_get_num_channel(str_params);
+	for (i = 0; i < 8; i++) {
+		if (i < num_ch)
+			alloc_param.codec_params.uc.pcm_params.channel_map[i] = i;
+		else
+			alloc_param.codec_params.uc.pcm_params.channel_map[i] = 0xFF;
+	}
+
+	str_id = str_params->stream_id;
+	pipe_id = str_params->device_type;
+	task_id = str_params->task;
+	sst_drv_ctx->streams[str_id].pipe_id = pipe_id;
+	sst_drv_ctx->streams[str_id].task_id = task_id;
+	sst_drv_ctx->streams[str_id].num_ch = num_ch;
+
+	pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+	if (sst_drv_ctx->info.lpe_viewpt_rqd)
+		alloc_param.ts = sst_drv_ctx->info.mailbox_start +
+			sst_drv_ctx->tstamp + (str_id * sizeof(fw_tstamp));
+	else
+		alloc_param.ts = sst_drv_ctx->mailbox_add +
+			sst_drv_ctx->tstamp + (str_id * sizeof(fw_tstamp));
+
+	pr_debug("alloc tstamp location = 0x%x\n", alloc_param.ts);
+	pr_debug("assigned pipe id 0x%x to task %d\n", pipe_id, task_id);
+
+	/*allocate device type context*/
+	sst_init_stream(&sst_drv_ctx->streams[str_id], alloc_param.codec_type,
+			str_id, alloc_param.operation, 0);
+	/* send msg to FW to allocate a stream */
+	if (sst_create_ipc_msg(&msg, true))
+		return -ENOMEM;
+
+	block->drv_id = pvt_id;
+	block->msg_id = IPC_CMD;
+
+	sst_fill_header_mrfld(&msg->mrfld_header, IPC_CMD,
+			      task_id, 1, pvt_id);
+	pr_debug("header:%x\n", msg->mrfld_header.p.header_high.full);
+	msg->mrfld_header.p.header_high.part.res_rqd = 1;
+
+	len = msg->mrfld_header.p.header_low_payload = sizeof(alloc_param) + sizeof(dsp_hdr);
+	sst_fill_header_dsp(&dsp_hdr, IPC_IA_ALLOC_STREAM_MRFLD, pipe_id, sizeof(alloc_param));
+	memcpy(msg->mailbox_data, &dsp_hdr, sizeof(dsp_hdr));
+	memcpy(msg->mailbox_data + sizeof(dsp_hdr), &alloc_param,
+			sizeof(alloc_param));
+	trace_sst_stream("ALLOC ->", str_id, pipe_id);
+	str_info = &sst_drv_ctx->streams[str_id];
+	pr_debug("header:%x\n", msg->mrfld_header.p.header_high.full);
+	pr_debug("response rqd: %x", msg->mrfld_header.p.header_high.part.res_rqd);
+	pr_debug("calling post_message\n");
+	pr_info("Alloc for str %d pipe %#x\n", str_id, pipe_id);
+
+	sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+	return str_id;
+}
+
+/**
+* sst_stream_stream - Send msg for a pausing stream
+* @str_id:	 stream ID
+*
+* This function is called by any function which wants to start
+* a stream.
+*/
+int sst_start_stream(int str_id)
+{
+	int retval = 0, pvt_id;
+	u32 len = 0;
+	struct ipc_post *msg = NULL;
+	struct ipc_dsp_hdr dsp_hdr;
+	struct stream_info *str_info;
+
+	pr_debug("sst_start_stream for %d\n", str_id);
+	str_info = get_stream_info(str_id);
+	if (!str_info)
+		return -EINVAL;
+	if (str_info->status != STREAM_RUNNING)
+		return -EBADRQC;
+
+	if (sst_create_ipc_msg(&msg, true))
+		return -ENOMEM;
+
+	if (!sst_drv_ctx->use_32bit_ops) {
+		pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+		pr_debug("pvt_id = %d, pipe id = %d, task = %d\n",
+			 pvt_id, str_info->pipe_id, str_info->task_id);
+		sst_fill_header_mrfld(&msg->mrfld_header, IPC_CMD,
+				      str_info->task_id, 1, pvt_id);
+
+		len = sizeof(u16) + sizeof(dsp_hdr);
+		msg->mrfld_header.p.header_low_payload = len;
+		sst_fill_header_dsp(&dsp_hdr, IPC_IA_START_STREAM_MRFLD,
+				str_info->pipe_id, sizeof(u16));
+		memcpy(msg->mailbox_data, &dsp_hdr, sizeof(dsp_hdr));
+		memset(msg->mailbox_data + sizeof(dsp_hdr), 0, sizeof(u16));
+		trace_sst_stream("START ->", str_id, str_info->pipe_id);
+		pr_info("Start for str %d pipe %#x\n", str_id, str_info->pipe_id);
+
+	} else {
+		pr_debug("fill START_STREAM for CTP\n");
+		sst_fill_header(&msg->header, IPC_IA_START_STREAM, 1, str_id);
+		msg->header.part.data =  sizeof(u32) + sizeof(u32);
+		memcpy(msg->mailbox_data, &msg->header, sizeof(u32));
+		memset(msg->mailbox_data + sizeof(u32), 0, sizeof(u32));
+	}
+	sst_drv_ctx->ops->sync_post_message(msg);
+	return retval;
+}
+
+int sst_send_byte_stream_mrfld(void *sbytes)
+{
+	struct ipc_post *msg = NULL;
+	struct snd_sst_bytes_v2 *bytes = (struct snd_sst_bytes_v2 *) sbytes;
+	u32 length;
+	int pvt_id, ret = 0;
+	struct sst_block *block = NULL;
+
+	pr_debug("%s: type:%u ipc_msg:%u block:%u task_id:%u pipe: %#x length:%#x\n",
+		__func__, bytes->type, bytes->ipc_msg,
+		bytes->block, bytes->task_id,
+		bytes->pipe_id, bytes->len);
+
+	/* need some err check as this is user data, perhpas move this to the
+	 * platform driver and pass the struct
+	 */
+	if (sst_create_ipc_msg(&msg, true))
+		return -ENOMEM;
+
+	pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+	sst_fill_header_mrfld(&msg->mrfld_header, bytes->ipc_msg, bytes->task_id,
+			      1, pvt_id);
+	msg->mrfld_header.p.header_high.part.res_rqd = bytes->block;
+	length = bytes->len;
+	msg->mrfld_header.p.header_low_payload = length;
+	pr_debug("length is %d\n", length);
+	memcpy(msg->mailbox_data, &bytes->bytes, bytes->len);
+	trace_sst_stream("BYTES ->", bytes->type, bytes->pipe_id);
+	if (bytes->block) {
+		block = sst_create_block(sst_drv_ctx, bytes->ipc_msg, pvt_id);
+		if (block == NULL) {
+			kfree(msg);
+			return -ENOMEM;
+		}
+	}
+	sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+	pr_debug("msg->mrfld_header.p.header_low_payload:%d", msg->mrfld_header.p.header_low_payload);
+	if (bytes->block) {
+		ret = sst_wait_timeout(sst_drv_ctx, block);
+		if (ret) {
+			pr_err("%s: fw returned err %d\n", __func__, ret);
+			sst_free_block(sst_drv_ctx, block);
+			return ret;
+		}
+	}
+	if (bytes->type == SND_SST_BYTES_GET) {
+		/* copy the reply and send back
+		 * we need to update only sz and payload
+		 */
+		if (bytes->block) {
+			unsigned char *r = block->data;
+			pr_debug("read back %d bytes", bytes->len);
+			memcpy(bytes->bytes, r, bytes->len);
+			trace_sst_stream("BYTES <-", bytes->type, bytes->pipe_id);
+		}
+	}
+	if (bytes->block)
+		sst_free_block(sst_drv_ctx, block);
+	return 0;
+}
+
+int sst_send_probe_bytes(struct intel_sst_drv *sst)
+{
+	struct ipc_post *msg = NULL;
+	struct sst_block *block;
+	int ret_val = 0;
+
+	ret_val = sst_create_block_and_ipc_msg(&msg, true, sst,
+			&block, IPC_IA_DBG_SET_PROBE_PARAMS, 0);
+	if (ret_val) {
+		pr_err("Can't allocate block/msg: Probe Byte Stream\n");
+		return ret_val;
+	}
+
+	sst_fill_header(&msg->header, IPC_IA_DBG_SET_PROBE_PARAMS, 1, 0);
+
+	msg->header.part.data = sizeof(u32) + sst->probe_bytes->len;
+	memcpy(msg->mailbox_data, &msg->header.full, sizeof(u32));
+	memcpy(msg->mailbox_data + sizeof(u32), sst->probe_bytes->bytes,
+				sst->probe_bytes->len);
+
+	sst_add_to_dispatch_list_and_post(sst, msg);
+	ret_val = sst_wait_timeout(sst, block);
+	sst_free_block(sst, block);
+	if (ret_val)
+		pr_err("set probe stream param..timeout!\n");
+	return ret_val;
+}
+
+/*
+ * sst_pause_stream - Send msg for a pausing stream
+ * @str_id:	 stream ID
+ *
+ * This function is called by any function which wants to pause
+ * an already running stream.
+ */
+int sst_pause_stream(int str_id)
+{
+	int retval = 0, pvt_id, len;
+	struct ipc_post *msg = NULL;
+	struct stream_info *str_info;
+	struct intel_sst_ops *ops;
+	struct sst_block *block;
+	struct ipc_dsp_hdr dsp_hdr;
+
+	pr_debug("SST DBG:sst_pause_stream for %d\n", str_id);
+	str_info = get_stream_info(str_id);
+	if (!str_info)
+		return -EINVAL;
+	ops = sst_drv_ctx->ops;
+	if (str_info->status == STREAM_PAUSED)
+		return 0;
+	if (str_info->status == STREAM_RUNNING ||
+		str_info->status == STREAM_INIT) {
+		if (str_info->prev == STREAM_UN_INIT)
+			return -EBADRQC;
+		if (!sst_drv_ctx->use_32bit_ops) {
+			pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+			retval = sst_create_block_and_ipc_msg(&msg, true,
+					sst_drv_ctx, &block, IPC_CMD, pvt_id);
+			if (retval)
+				return retval;
+			sst_fill_header_mrfld(&msg->mrfld_header, IPC_CMD,
+					str_info->task_id, 1, pvt_id);
+			msg->mrfld_header.p.header_high.part.res_rqd = 1;
+			len = sizeof(dsp_hdr);
+			msg->mrfld_header.p.header_low_payload = len;
+			sst_fill_header_dsp(&dsp_hdr, IPC_IA_PAUSE_STREAM_MRFLD,
+						str_info->pipe_id, 0);
+			memcpy(msg->mailbox_data, &dsp_hdr, sizeof(dsp_hdr));
+			trace_sst_stream("PAUSE ->", str_id, str_info->pipe_id);
+		} else {
+			retval = sst_create_block_and_ipc_msg(&msg, false,
+					sst_drv_ctx, &block,
+					IPC_IA_PAUSE_STREAM, str_id);
+			if (retval)
+				return retval;
+			sst_fill_header(&msg->header, IPC_IA_PAUSE_STREAM,
+								0, str_id);
+		}
+		sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+		retval = sst_wait_timeout(sst_drv_ctx, block);
+		sst_free_block(sst_drv_ctx, block);
+		if (retval == 0) {
+			str_info->prev = str_info->status;
+			str_info->status = STREAM_PAUSED;
+		} else if (retval == SST_ERR_INVALID_STREAM_ID) {
+			retval = -EINVAL;
+			mutex_lock(&sst_drv_ctx->stream_lock);
+			sst_clean_stream(str_info);
+			mutex_unlock(&sst_drv_ctx->stream_lock);
+		}
+	} else {
+		retval = -EBADRQC;
+		pr_debug("SST DBG:BADRQC for stream\n ");
+	}
+
+	return retval;
+}
+
+/**
+ * sst_resume_stream - Send msg for resuming stream
+ * @str_id:		stream ID
+ *
+ * This function is called by any function which wants to resume
+ * an already paused stream.
+ */
+int sst_resume_stream(int str_id)
+{
+	int retval = 0;
+	struct ipc_post *msg = NULL;
+	struct stream_info *str_info;
+	struct intel_sst_ops *ops;
+	struct sst_block *block = NULL;
+	int pvt_id, len;
+	struct ipc_dsp_hdr dsp_hdr;
+
+	pr_debug("SST DBG:sst_resume_stream for %d\n", str_id);
+	str_info = get_stream_info(str_id);
+	if (!str_info)
+		return -EINVAL;
+	ops = sst_drv_ctx->ops;
+	if (str_info->status == STREAM_RUNNING)
+			return 0;
+	if (str_info->status == STREAM_PAUSED) {
+		if (!sst_drv_ctx->use_32bit_ops) {
+			pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+			retval = sst_create_block_and_ipc_msg(&msg, true,
+					sst_drv_ctx, &block, IPC_CMD, pvt_id);
+			if (retval)
+				return retval;
+			sst_fill_header_mrfld(&msg->mrfld_header, IPC_CMD,
+					str_info->task_id, 1, pvt_id);
+			msg->mrfld_header.p.header_high.part.res_rqd = 1;
+			len = sizeof(dsp_hdr);
+			msg->mrfld_header.p.header_low_payload = len;
+			sst_fill_header_dsp(&dsp_hdr,
+						IPC_IA_RESUME_STREAM_MRFLD,
+						str_info->pipe_id, 0);
+			memcpy(msg->mailbox_data, &dsp_hdr, sizeof(dsp_hdr));
+			trace_sst_stream("RESUME->", str_id, str_info->pipe_id);
+		} else {
+			retval = sst_create_block_and_ipc_msg(&msg, false,
+					sst_drv_ctx, &block,
+					IPC_IA_RESUME_STREAM, str_id);
+			if (retval)
+				return retval;
+			sst_fill_header(&msg->header, IPC_IA_RESUME_STREAM,
+								0, str_id);
+		}
+		sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+		retval = sst_wait_timeout(sst_drv_ctx, block);
+		sst_free_block(sst_drv_ctx, block);
+		if (!retval) {
+			if (str_info->prev == STREAM_RUNNING)
+				str_info->status = STREAM_RUNNING;
+			else
+				str_info->status = STREAM_INIT;
+			str_info->prev = STREAM_PAUSED;
+		} else if (retval == -SST_ERR_INVALID_STREAM_ID) {
+			retval = -EINVAL;
+			mutex_lock(&sst_drv_ctx->stream_lock);
+			sst_clean_stream(str_info);
+			mutex_unlock(&sst_drv_ctx->stream_lock);
+		}
+	} else {
+		retval = -EBADRQC;
+		pr_err("SST ERR: BADQRC for stream\n");
+	}
+
+	return retval;
+}
+
+
+/**
+ * sst_drop_stream - Send msg for stopping stream
+ * @str_id:		stream ID
+ *
+ * This function is called by any function which wants to stop
+ * a stream.
+ */
+int sst_drop_stream(int str_id)
+{
+	int retval = 0, pvt_id;
+	struct stream_info *str_info;
+	struct ipc_post *msg = NULL;
+	struct ipc_dsp_hdr dsp_hdr;
+
+	pr_debug("SST DBG:sst_drop_stream for %d\n", str_id);
+	str_info = get_stream_info(str_id);
+	if (!str_info)
+		return -EINVAL;
+
+	if (str_info->status != STREAM_UN_INIT) {
+
+		if (sst_drv_ctx->use_32bit_ops == true) {
+			str_info->prev = STREAM_UN_INIT;
+			str_info->status = STREAM_INIT;
+			str_info->cumm_bytes = 0;
+			sst_send_sync_msg(IPC_IA_DROP_STREAM, str_id);
+		} else {
+			if (sst_create_ipc_msg(&msg, true))
+				return -ENOMEM;
+			str_info->prev = STREAM_UN_INIT;
+			str_info->status = STREAM_INIT;
+			str_info->cumm_bytes = 0;
+			pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+			sst_fill_header_mrfld(&msg->mrfld_header, IPC_CMD,
+					      str_info->task_id, 1, pvt_id);
+
+			msg->mrfld_header.p.header_low_payload = sizeof(dsp_hdr);
+			sst_fill_header_dsp(&dsp_hdr, IPC_IA_DROP_STREAM_MRFLD,
+					str_info->pipe_id, 0);
+			memcpy(msg->mailbox_data, &dsp_hdr, sizeof(dsp_hdr));
+			trace_sst_stream("STOP  ->", str_id, str_info->pipe_id);
+			pr_info("Stop for str %d pipe %#x\n", str_id, str_info->pipe_id);
+
+			sst_drv_ctx->ops->sync_post_message(msg);
+		}
+	} else {
+		retval = -EBADRQC;
+		pr_debug("BADQRC for stream, state %x\n", str_info->status);
+	}
+	return retval;
+}
+
+/**
+ * sst_next_track: notify next track
+ * @str_id:		stream ID
+ *
+ * This function is called by any function which wants to
+ * set next track. Current this is NOP as FW doest care
+ */
+int sst_next_track(void)
+{
+	pr_debug("SST DBG: next_track");
+	return 0;
+}
+
+/**
+* sst_drain_stream - Send msg for draining stream
+* @str_id:		stream ID
+*
+* This function is called by any function which wants to drain
+* a stream.
+*/
+int sst_drain_stream(int str_id, bool partial_drain)
+{
+	int retval = 0, pvt_id, len;
+	struct ipc_post *msg = NULL;
+	struct stream_info *str_info;
+	struct intel_sst_ops *ops;
+	struct sst_block *block = NULL;
+	struct ipc_dsp_hdr dsp_hdr;
+
+	pr_debug("SST DBG:sst_drain_stream for %d\n", str_id);
+	str_info = get_stream_info(str_id);
+	if (!str_info)
+		return -EINVAL;
+	ops = sst_drv_ctx->ops;
+	if (str_info->status != STREAM_RUNNING &&
+		str_info->status != STREAM_INIT &&
+		str_info->status != STREAM_PAUSED) {
+			pr_err("SST ERR: BADQRC for stream = %d\n",
+				       str_info->status);
+			return -EBADRQC;
+	}
+
+	if (!sst_drv_ctx->use_32bit_ops) {
+		pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+		retval = sst_create_block_and_ipc_msg(&msg, true,
+				sst_drv_ctx, &block, IPC_CMD, pvt_id);
+		if (retval)
+			return retval;
+		sst_fill_header_mrfld(&msg->mrfld_header, IPC_CMD,
+				str_info->task_id, 1, pvt_id);
+		pr_debug("header:%x\n",
+			(unsigned int)msg->mrfld_header.p.header_high.full);
+		msg->mrfld_header.p.header_high.part.res_rqd = 1;
+
+		len = sizeof(u8) + sizeof(dsp_hdr);
+		msg->mrfld_header.p.header_low_payload = len;
+		sst_fill_header_dsp(&dsp_hdr, IPC_IA_DRAIN_STREAM_MRFLD,
+					str_info->pipe_id, sizeof(u8));
+		memcpy(msg->mailbox_data, &dsp_hdr, sizeof(dsp_hdr));
+		memcpy(msg->mailbox_data + sizeof(dsp_hdr),
+				&partial_drain, sizeof(u8));
+		trace_sst_stream("DRAIN ->", str_id, str_info->pipe_id);
+	} else {
+		retval = sst_create_block_and_ipc_msg(&msg, false,
+				sst_drv_ctx, &block,
+				IPC_IA_DRAIN_STREAM, str_id);
+		if (retval)
+			return retval;
+		sst_fill_header(&msg->header, IPC_IA_DRAIN_STREAM, 0, str_id);
+		msg->header.part.data = partial_drain;
+	}
+	sst_add_to_dispatch_list_and_post(sst_drv_ctx, msg);
+	/* with new non blocked drain implementation in core we dont need to
+	 * wait for respsonse, and need to only invoke callback for drain
+	 * complete
+	 */
+
+	sst_free_block(sst_drv_ctx, block);
+	return retval;
+}
+
+/**
+ * sst_free_stream - Frees a stream
+ * @str_id:		stream ID
+ *
+ * This function is called by any function which wants to free
+ * a stream.
+ */
+int sst_free_stream(int str_id)
+{
+	int retval = 0;
+	unsigned int pvt_id;
+	struct ipc_post *msg = NULL;
+	struct stream_info *str_info;
+	struct intel_sst_ops *ops;
+	unsigned long irq_flags;
+	struct ipc_dsp_hdr dsp_hdr;
+	struct sst_block *block;
+
+	pr_debug("SST DBG:sst_free_stream for %d\n", str_id);
+
+	mutex_lock(&sst_drv_ctx->sst_lock);
+	if (sst_drv_ctx->sst_state == SST_UN_INIT) {
+		mutex_unlock(&sst_drv_ctx->sst_lock);
+		return -ENODEV;
+	}
+	mutex_unlock(&sst_drv_ctx->sst_lock);
+	str_info = get_stream_info(str_id);
+	if (!str_info)
+		return -EINVAL;
+	ops = sst_drv_ctx->ops;
+
+	mutex_lock(&str_info->lock);
+	if (str_info->status != STREAM_UN_INIT) {
+		str_info->prev =  str_info->status;
+		str_info->status = STREAM_UN_INIT;
+		mutex_unlock(&str_info->lock);
+
+		if (!sst_drv_ctx->use_32bit_ops) {
+			pvt_id = sst_assign_pvt_id(sst_drv_ctx);
+			retval = sst_create_block_and_ipc_msg(&msg, true,
+					sst_drv_ctx, &block, IPC_CMD, pvt_id);
+			if (retval)
+				return retval;
+
+			sst_fill_header_mrfld(&msg->mrfld_header, IPC_CMD,
+					      str_info->task_id, 1, pvt_id);
+			msg->mrfld_header.p.header_low_payload =
+							sizeof(dsp_hdr);
+			sst_fill_header_dsp(&dsp_hdr, IPC_IA_FREE_STREAM_MRFLD,
+						str_info->pipe_id,  0);
+			memcpy(msg->mailbox_data, &dsp_hdr, sizeof(dsp_hdr));
+			trace_sst_stream("FREE  ->", str_id, str_info->pipe_id);
+			pr_info("Free for str %d pipe %#x\n", str_id, str_info->pipe_id);
+
+		} else {
+			retval = sst_create_block_and_ipc_msg(&msg, false,
+						sst_drv_ctx, &block,
+						IPC_IA_FREE_STREAM, str_id);
+			if (retval)
+				return retval;
+			sst_fill_header(&msg->header, IPC_IA_FREE_STREAM,
+								 0, str_id);
+		}
+		spin_lock_irqsave(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+		list_add_tail(&msg->node, &sst_drv_ctx->ipc_dispatch_list);
+		spin_unlock_irqrestore(&sst_drv_ctx->ipc_spin_lock, irq_flags);
+		if (!sst_drv_ctx->use_32bit_ops) {
+			/*FIXME: do we need to wake up drain stream here,
+			 * how to get the pvt_id and msg_id
+			 */
+		} else {
+			sst_wake_up_block(sst_drv_ctx, 0, str_id,
+				IPC_IA_DRAIN_STREAM, NULL, 0);
+		}
+		ops->post_message(&sst_drv_ctx->ipc_post_msg_wq);
+		retval = sst_wait_timeout(sst_drv_ctx, block);
+		pr_debug("sst: wait for free returned %d\n", retval);
+		mutex_lock(&sst_drv_ctx->stream_lock);
+		sst_clean_stream(str_info);
+		mutex_unlock(&sst_drv_ctx->stream_lock);
+		pr_debug("SST DBG:Stream freed\n");
+		sst_free_block(sst_drv_ctx, block);
+	} else {
+		mutex_unlock(&str_info->lock);
+		retval = -EBADRQC;
+		pr_debug("SST DBG:BADQRC for stream\n");
+	}
+
+	return retval;
+}
+
+int sst_request_vtsv_file(char *fname, struct intel_sst_drv *ctx,
+		void **out_file, u32 *out_size)
+{
+	int retval = 0;
+	const struct firmware *file;
+	void *ddr_virt_addr;
+	unsigned long file_base;
+
+	if (!ctx->pdata->lib_info) {
+		pr_err("lib_info pointer NULL\n");
+		return -EINVAL;
+	}
+
+	pr_debug("Requesting VTSV file %s now...\n", fname);
+	retval = request_firmware(&file, fname, ctx->dev);
+	if (file == NULL) {
+		pr_err("VTSV file is returning as null\n");
+		return -EINVAL;
+	}
+	if (retval) {
+		pr_err("request fw failed %d\n", retval);
+		return retval;
+	}
+
+	if ((*out_file == NULL) || (*out_size < file->size)) {
+		retval = sst_get_next_lib_mem(&ctx->lib_mem_mgr, file->size,
+			&file_base);
+		*out_file = (void *)file_base;
+	}
+	ddr_virt_addr = (unsigned char *)ctx->ddr +
+		(unsigned long)(*out_file - ctx->pdata->lib_info->mod_base);
+	memcpy(ddr_virt_addr, file->data, file->size);
+
+	*out_size = file->size;
+	release_firmware(file);
+	return 0;
+}
+
+int sst_format_vtsv_message(struct intel_sst_drv *ctx,
+	struct ipc_post **msgptr, struct sst_block **block)
+{
+	int retval = 0, pvt_id, len;
+	struct ipc_dsp_hdr dsp_hdr;
+	struct snd_sst_vtsv_info vinfo;
+	struct ipc_post *msg;
+
+	BUG_ON((unsigned long)(ctx->vcache.file1_in_mem) & 0xffffffff00000000ULL);
+	BUG_ON((unsigned long)(ctx->vcache.file2_in_mem) & 0xffffffff00000000ULL);
+
+	vinfo.vfiles[0].addr = (u32)((unsigned long)ctx->vcache.file1_in_mem
+				& 0xffffffff);
+	vinfo.vfiles[0].size = ctx->vcache.size1;
+	vinfo.vfiles[1].addr = (u32)((unsigned long)ctx->vcache.file2_in_mem
+				& 0xffffffff);
+	vinfo.vfiles[1].size = ctx->vcache.size2;
+
+	/* Create the vtsv message */
+	pvt_id = sst_assign_pvt_id(ctx);
+	retval = sst_create_block_and_ipc_msg(msgptr, true,
+			ctx, block, IPC_CMD, pvt_id);
+	if (retval)
+		return retval;
+	msg = *msgptr;
+	sst_fill_header_mrfld(&msg->mrfld_header, IPC_CMD,
+			SST_TASK_ID_AWARE, 1, pvt_id);
+	pr_debug("header:%x\n",
+			(unsigned int)msg->mrfld_header.p.header_high.full);
+	msg->mrfld_header.p.header_high.part.res_rqd = 1;
+
+	len = sizeof(vinfo) + sizeof(dsp_hdr);
+	msg->mrfld_header.p.header_low_payload = len;
+	sst_fill_header_dsp(&dsp_hdr, IPC_IA_VTSV_UPDATE_MODULES,
+				PIPE_VAD_OUT, sizeof(u8));
+	dsp_hdr.mod_id = SST_ALGO_VTSV;
+	memcpy(msg->mailbox_data, &dsp_hdr, sizeof(dsp_hdr));
+	memcpy(msg->mailbox_data + sizeof(dsp_hdr),
+			&vinfo, sizeof(vinfo));
+	return 0;
+}
+
+int sst_send_vtsv_data_to_fw(struct intel_sst_drv *ctx)
+{
+	int retval = 0;
+	struct ipc_post *msg = NULL;
+	struct sst_block *block = NULL;
+
+	/* Download both the data files */
+	retval = sst_request_vtsv_file("vtsv_net.bin", ctx,
+			&ctx->vcache.file1_in_mem, &ctx->vcache.size1);
+	if (retval) {
+		pr_err("vtsv data file1 request failed %d\n", retval);
+		return retval;
+	}
+
+	retval = sst_request_vtsv_file("vtsv_grammar.bin", ctx,
+			&ctx->vcache.file2_in_mem, &ctx->vcache.size2);
+	if (retval) {
+		pr_err("vtsv data file2 request failed %d\n", retval);
+		return retval;
+	}
+
+	retval = sst_format_vtsv_message(ctx, &msg, &block);
+	if (retval) {
+		pr_err("vtsv msg format failed %d\n", retval);
+		return retval;
+	}
+	sst_add_to_dispatch_list_and_post(ctx, msg);
+	retval = sst_wait_timeout(ctx, block);
+	if (retval)
+		pr_err("vtsv msg send to fw failed %d\n", retval);
+
+	sst_free_block(ctx, block);
+	return retval;
+}
diff --git a/sound/soc/intel/sst/sst_trace.h b/sound/soc/intel/sst/sst_trace.h
new file mode 100644
index 0000000..574d9c6
--- /dev/null
+++ b/sound/soc/intel/sst/sst_trace.h
@@ -0,0 +1,147 @@
+/*
+ *  sst_trace.h - Intel SST Driver tracing support
+ *
+ *  Copyright (C) 2013	Intel Corp
+ *  Authors: Omair Mohammed Abdullah <omair.m.abdullah@linux.intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM sst
+
+#if !defined(_TRACE_SST_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_SST_H
+
+#include <linux/types.h>
+#include <linux/ktime.h>
+#include <linux/tracepoint.h>
+
+TRACE_EVENT(sst_ipc,
+
+	TP_PROTO(const char *msg, u32 header_high, u32 header_low, int pvt_id),
+
+	TP_ARGS(msg, header_high, header_low, pvt_id),
+
+	TP_STRUCT__entry(
+		__string(info_msg,	msg)
+		__field(unsigned int,	val_l)
+		__field(unsigned int,	val_h)
+		__field(unsigned int,	id)
+	),
+
+	TP_fast_assign(
+		__assign_str(info_msg, msg);
+		__entry->val_l = header_low;
+		__entry->val_h = header_high;
+		__entry->id = pvt_id;
+	),
+
+	TP_printk("\t%s\t [%2u] = %#8.8x:%.4x", __get_str(info_msg),
+		  (unsigned int)__entry->id,
+		  (unsigned int)__entry->val_h, (unsigned int)__entry->val_l)
+
+);
+
+TRACE_EVENT(sst_stream,
+
+	TP_PROTO(const char *msg, int str_id, int pipe_id),
+
+	TP_ARGS(msg, str_id, pipe_id),
+
+	TP_STRUCT__entry(
+		__string(info_msg,	msg)
+		__field(unsigned int,	str_id)
+		__field(unsigned int,	pipe_id)
+	),
+
+	TP_fast_assign(
+		__assign_str(info_msg, msg);
+		__entry->str_id = str_id;
+		__entry->pipe_id = pipe_id;
+	),
+
+	TP_printk("\t%s\t str  = %2u, pipe = %#x", __get_str(info_msg),
+		  (unsigned int)__entry->str_id, (unsigned int)__entry->pipe_id)
+);
+
+TRACE_EVENT(sst_ipc_mailbox,
+
+	TP_PROTO(const char *mailbox, int mbox_len),
+
+	TP_ARGS(mailbox, mbox_len),
+
+	TP_STRUCT__entry(
+		__dynamic_array(char,	mbox,	(3 * mbox_len))
+	),
+
+	TP_fast_assign(
+		sst_dump_to_buffer(mailbox, mbox_len,
+				   __get_dynamic_array(mbox));
+	),
+
+	TP_printk("  %s", __get_str(mbox))
+
+);
+
+TRACE_EVENT(sst_lib_download,
+
+	TP_PROTO(const char *msg, const char *lib_name),
+
+	TP_ARGS(msg, lib_name),
+
+	TP_STRUCT__entry(
+		__string(info_msg, msg)
+		__string(info_lib_name, lib_name)
+	),
+
+	TP_fast_assign(
+		__assign_str(info_msg, msg);
+		__assign_str(info_lib_name, lib_name);
+	),
+
+	TP_printk("\t%s %s", __get_str(info_msg),
+			__get_str(info_lib_name))
+);
+
+TRACE_EVENT(sst_fw_download,
+
+	TP_PROTO(const char *msg, int fw_state),
+
+	TP_ARGS(msg, fw_state),
+
+	TP_STRUCT__entry(
+		__string(info_msg, msg)
+		__field(unsigned int,   fw_state)
+	),
+
+	TP_fast_assign(
+		__assign_str(info_msg, msg);
+		__entry->fw_state = fw_state;
+	),
+
+	TP_printk("\t%s\tFW state = %d", __get_str(info_msg),
+				(unsigned int)__entry->fw_state)
+);
+
+#endif /* _TRACE_SST_H */
+
+/* This part must be outside protection */
+#undef TRACE_INCLUDE_PATH
+#define TRACE_INCLUDE_PATH ../../sound/soc/intel/sst
+#define TRACE_INCLUDE_FILE sst_trace
+#include <trace/define_trace.h>
diff --git a/sound/soc/intel/sst_platform.c b/sound/soc/intel/sst_platform.c
deleted file mode 100644
index f465a81..0000000
--- a/sound/soc/intel/sst_platform.c
+++ /dev/null
@@ -1,725 +0,0 @@
-/*
- *  sst_platform.c - Intel MID Platform driver
- *
- *  Copyright (C) 2010-2013 Intel Corp
- *  Author: Vinod Koul <vinod.koul@intel.com>
- *  Author: Harsha Priya <priya.harsha@intel.com>
- *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; version 2 of the License.
- *
- *  This program is distributed in the hope that it will be useful, but
- *  WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
- *
- * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- *
- *
- */
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
-#include <linux/slab.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <sound/core.h>
-#include <sound/pcm.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/compress_driver.h>
-#include "sst_platform.h"
-
-static struct sst_device *sst;
-static DEFINE_MUTEX(sst_lock);
-
-int sst_register_dsp(struct sst_device *dev)
-{
-	if (WARN_ON(!dev))
-		return -EINVAL;
-	if (!try_module_get(dev->dev->driver->owner))
-		return -ENODEV;
-	mutex_lock(&sst_lock);
-	if (sst) {
-		pr_err("we already have a device %s\n", sst->name);
-		module_put(dev->dev->driver->owner);
-		mutex_unlock(&sst_lock);
-		return -EEXIST;
-	}
-	pr_debug("registering device %s\n", dev->name);
-	sst = dev;
-	mutex_unlock(&sst_lock);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(sst_register_dsp);
-
-int sst_unregister_dsp(struct sst_device *dev)
-{
-	if (WARN_ON(!dev))
-		return -EINVAL;
-	if (dev != sst)
-		return -EINVAL;
-
-	mutex_lock(&sst_lock);
-
-	if (!sst) {
-		mutex_unlock(&sst_lock);
-		return -EIO;
-	}
-
-	module_put(sst->dev->driver->owner);
-	pr_debug("unreg %s\n", sst->name);
-	sst = NULL;
-	mutex_unlock(&sst_lock);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(sst_unregister_dsp);
-
-static struct snd_pcm_hardware sst_platform_pcm_hw = {
-	.info =	(SNDRV_PCM_INFO_INTERLEAVED |
-			SNDRV_PCM_INFO_DOUBLE |
-			SNDRV_PCM_INFO_PAUSE |
-			SNDRV_PCM_INFO_RESUME |
-			SNDRV_PCM_INFO_MMAP|
-			SNDRV_PCM_INFO_MMAP_VALID |
-			SNDRV_PCM_INFO_BLOCK_TRANSFER |
-			SNDRV_PCM_INFO_SYNC_START),
-	.buffer_bytes_max = SST_MAX_BUFFER,
-	.period_bytes_min = SST_MIN_PERIOD_BYTES,
-	.period_bytes_max = SST_MAX_PERIOD_BYTES,
-	.periods_min = SST_MIN_PERIODS,
-	.periods_max = SST_MAX_PERIODS,
-	.fifo_size = SST_FIFO_SIZE,
-};
-
-/* MFLD - MSIC */
-static struct snd_soc_dai_driver sst_platform_dai[] = {
-{
-	.name = "Headset-cpu-dai",
-	.id = 0,
-	.playback = {
-		.channels_min = SST_STEREO,
-		.channels_max = SST_STEREO,
-		.rates = SNDRV_PCM_RATE_48000,
-		.formats = SNDRV_PCM_FMTBIT_S24_LE,
-	},
-	.capture = {
-		.channels_min = 1,
-		.channels_max = 5,
-		.rates = SNDRV_PCM_RATE_48000,
-		.formats = SNDRV_PCM_FMTBIT_S24_LE,
-	},
-},
-{
-	.name = "Speaker-cpu-dai",
-	.id = 1,
-	.playback = {
-		.channels_min = SST_MONO,
-		.channels_max = SST_STEREO,
-		.rates = SNDRV_PCM_RATE_48000,
-		.formats = SNDRV_PCM_FMTBIT_S24_LE,
-	},
-},
-{
-	.name = "Vibra1-cpu-dai",
-	.id = 2,
-	.playback = {
-		.channels_min = SST_MONO,
-		.channels_max = SST_MONO,
-		.rates = SNDRV_PCM_RATE_48000,
-		.formats = SNDRV_PCM_FMTBIT_S24_LE,
-	},
-},
-{
-	.name = "Vibra2-cpu-dai",
-	.id = 3,
-	.playback = {
-		.channels_min = SST_MONO,
-		.channels_max = SST_STEREO,
-		.rates = SNDRV_PCM_RATE_48000,
-		.formats = SNDRV_PCM_FMTBIT_S24_LE,
-	},
-},
-{
-	.name = "Compress-cpu-dai",
-	.compress_dai = 1,
-	.playback = {
-		.channels_min = SST_STEREO,
-		.channels_max = SST_STEREO,
-		.rates = SNDRV_PCM_RATE_44100|SNDRV_PCM_RATE_48000,
-		.formats = SNDRV_PCM_FMTBIT_S16_LE,
-	},
-},
-};
-
-static const struct snd_soc_component_driver sst_component = {
-	.name		= "sst",
-};
-
-/* helper functions */
-static inline void sst_set_stream_status(struct sst_runtime_stream *stream,
-					int state)
-{
-	unsigned long flags;
-	spin_lock_irqsave(&stream->status_lock, flags);
-	stream->stream_status = state;
-	spin_unlock_irqrestore(&stream->status_lock, flags);
-}
-
-static inline int sst_get_stream_status(struct sst_runtime_stream *stream)
-{
-	int state;
-	unsigned long flags;
-
-	spin_lock_irqsave(&stream->status_lock, flags);
-	state = stream->stream_status;
-	spin_unlock_irqrestore(&stream->status_lock, flags);
-	return state;
-}
-
-static void sst_fill_pcm_params(struct snd_pcm_substream *substream,
-				struct sst_pcm_params *param)
-{
-
-	param->codec = SST_CODEC_TYPE_PCM;
-	param->num_chan = (u8) substream->runtime->channels;
-	param->pcm_wd_sz = substream->runtime->sample_bits;
-	param->reserved = 0;
-	param->sfreq = substream->runtime->rate;
-	param->ring_buffer_size = snd_pcm_lib_buffer_bytes(substream);
-	param->period_count = substream->runtime->period_size;
-	param->ring_buffer_addr = virt_to_phys(substream->dma_buffer.area);
-	pr_debug("period_cnt = %d\n", param->period_count);
-	pr_debug("sfreq= %d, wd_sz = %d\n", param->sfreq, param->pcm_wd_sz);
-}
-
-static int sst_platform_alloc_stream(struct snd_pcm_substream *substream)
-{
-	struct sst_runtime_stream *stream =
-			substream->runtime->private_data;
-	struct sst_pcm_params param = {0};
-	struct sst_stream_params str_params = {0};
-	int ret_val;
-
-	/* set codec params and inform SST driver the same */
-	sst_fill_pcm_params(substream, &param);
-	substream->runtime->dma_area = substream->dma_buffer.area;
-	str_params.sparams = param;
-	str_params.codec =  param.codec;
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		str_params.ops = STREAM_OPS_PLAYBACK;
-		str_params.device_type = substream->pcm->device + 1;
-		pr_debug("Playbck stream,Device %d\n",
-					substream->pcm->device);
-	} else {
-		str_params.ops = STREAM_OPS_CAPTURE;
-		str_params.device_type = SND_SST_DEVICE_CAPTURE;
-		pr_debug("Capture stream,Device %d\n",
-					substream->pcm->device);
-	}
-	ret_val = stream->ops->open(&str_params);
-	pr_debug("SST_SND_PLAY/CAPTURE ret_val = %x\n", ret_val);
-	if (ret_val < 0)
-		return ret_val;
-
-	stream->stream_info.str_id = ret_val;
-	pr_debug("str id :  %d\n", stream->stream_info.str_id);
-	return ret_val;
-}
-
-static void sst_period_elapsed(void *mad_substream)
-{
-	struct snd_pcm_substream *substream = mad_substream;
-	struct sst_runtime_stream *stream;
-	int status;
-
-	if (!substream || !substream->runtime)
-		return;
-	stream = substream->runtime->private_data;
-	if (!stream)
-		return;
-	status = sst_get_stream_status(stream);
-	if (status != SST_PLATFORM_RUNNING)
-		return;
-	snd_pcm_period_elapsed(substream);
-}
-
-static int sst_platform_init_stream(struct snd_pcm_substream *substream)
-{
-	struct sst_runtime_stream *stream =
-			substream->runtime->private_data;
-	int ret_val;
-
-	pr_debug("setting buffer ptr param\n");
-	sst_set_stream_status(stream, SST_PLATFORM_INIT);
-	stream->stream_info.period_elapsed = sst_period_elapsed;
-	stream->stream_info.mad_substream = substream;
-	stream->stream_info.buffer_ptr = 0;
-	stream->stream_info.sfreq = substream->runtime->rate;
-	ret_val = stream->ops->device_control(
-			SST_SND_STREAM_INIT, &stream->stream_info);
-	if (ret_val)
-		pr_err("control_set ret error %d\n", ret_val);
-	return ret_val;
-
-}
-/* end -- helper functions */
-
-static int sst_platform_open(struct snd_pcm_substream *substream)
-{
-	struct snd_pcm_runtime *runtime = substream->runtime;
-	struct sst_runtime_stream *stream;
-	int ret_val;
-
-	pr_debug("sst_platform_open called\n");
-
-	snd_soc_set_runtime_hwparams(substream, &sst_platform_pcm_hw);
-	ret_val = snd_pcm_hw_constraint_integer(runtime,
-						SNDRV_PCM_HW_PARAM_PERIODS);
-	if (ret_val < 0)
-		return ret_val;
-
-	stream = kzalloc(sizeof(*stream), GFP_KERNEL);
-	if (!stream)
-		return -ENOMEM;
-	spin_lock_init(&stream->status_lock);
-
-	/* get the sst ops */
-	mutex_lock(&sst_lock);
-	if (!sst) {
-		pr_err("no device available to run\n");
-		mutex_unlock(&sst_lock);
-		kfree(stream);
-		return -ENODEV;
-	}
-	if (!try_module_get(sst->dev->driver->owner)) {
-		mutex_unlock(&sst_lock);
-		kfree(stream);
-		return -ENODEV;
-	}
-	stream->ops = sst->ops;
-	mutex_unlock(&sst_lock);
-
-	stream->stream_info.str_id = 0;
-	sst_set_stream_status(stream, SST_PLATFORM_INIT);
-	stream->stream_info.mad_substream = substream;
-	/* allocate memory for SST API set */
-	runtime->private_data = stream;
-
-	return 0;
-}
-
-static int sst_platform_close(struct snd_pcm_substream *substream)
-{
-	struct sst_runtime_stream *stream;
-	int ret_val = 0, str_id;
-
-	pr_debug("sst_platform_close called\n");
-	stream = substream->runtime->private_data;
-	str_id = stream->stream_info.str_id;
-	if (str_id)
-		ret_val = stream->ops->close(str_id);
-	module_put(sst->dev->driver->owner);
-	kfree(stream);
-	return ret_val;
-}
-
-static int sst_platform_pcm_prepare(struct snd_pcm_substream *substream)
-{
-	struct sst_runtime_stream *stream;
-	int ret_val = 0, str_id;
-
-	pr_debug("sst_platform_pcm_prepare called\n");
-	stream = substream->runtime->private_data;
-	str_id = stream->stream_info.str_id;
-	if (stream->stream_info.str_id) {
-		ret_val = stream->ops->device_control(
-				SST_SND_DROP, &str_id);
-		return ret_val;
-	}
-
-	ret_val = sst_platform_alloc_stream(substream);
-	if (ret_val < 0)
-		return ret_val;
-	snprintf(substream->pcm->id, sizeof(substream->pcm->id),
-			"%d", stream->stream_info.str_id);
-
-	ret_val = sst_platform_init_stream(substream);
-	if (ret_val)
-		return ret_val;
-	substream->runtime->hw.info = SNDRV_PCM_INFO_BLOCK_TRANSFER;
-	return ret_val;
-}
-
-static int sst_platform_pcm_trigger(struct snd_pcm_substream *substream,
-					int cmd)
-{
-	int ret_val = 0, str_id;
-	struct sst_runtime_stream *stream;
-	int str_cmd, status;
-
-	pr_debug("sst_platform_pcm_trigger called\n");
-	stream = substream->runtime->private_data;
-	str_id = stream->stream_info.str_id;
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-		pr_debug("sst: Trigger Start\n");
-		str_cmd = SST_SND_START;
-		status = SST_PLATFORM_RUNNING;
-		stream->stream_info.mad_substream = substream;
-		break;
-	case SNDRV_PCM_TRIGGER_STOP:
-		pr_debug("sst: in stop\n");
-		str_cmd = SST_SND_DROP;
-		status = SST_PLATFORM_DROPPED;
-		break;
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		pr_debug("sst: in pause\n");
-		str_cmd = SST_SND_PAUSE;
-		status = SST_PLATFORM_PAUSED;
-		break;
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		pr_debug("sst: in pause release\n");
-		str_cmd = SST_SND_RESUME;
-		status = SST_PLATFORM_RUNNING;
-		break;
-	default:
-		return -EINVAL;
-	}
-	ret_val = stream->ops->device_control(str_cmd, &str_id);
-	if (!ret_val)
-		sst_set_stream_status(stream, status);
-
-	return ret_val;
-}
-
-
-static snd_pcm_uframes_t sst_platform_pcm_pointer
-			(struct snd_pcm_substream *substream)
-{
-	struct sst_runtime_stream *stream;
-	int ret_val, status;
-	struct pcm_stream_info *str_info;
-
-	stream = substream->runtime->private_data;
-	status = sst_get_stream_status(stream);
-	if (status == SST_PLATFORM_INIT)
-		return 0;
-	str_info = &stream->stream_info;
-	ret_val = stream->ops->device_control(
-				SST_SND_BUFFER_POINTER, str_info);
-	if (ret_val) {
-		pr_err("sst: error code = %d\n", ret_val);
-		return ret_val;
-	}
-	return stream->stream_info.buffer_ptr;
-}
-
-static int sst_platform_pcm_hw_params(struct snd_pcm_substream *substream,
-		struct snd_pcm_hw_params *params)
-{
-	snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
-	memset(substream->runtime->dma_area, 0, params_buffer_bytes(params));
-
-	return 0;
-}
-
-static int sst_platform_pcm_hw_free(struct snd_pcm_substream *substream)
-{
-	return snd_pcm_lib_free_pages(substream);
-}
-
-static struct snd_pcm_ops sst_platform_ops = {
-	.open = sst_platform_open,
-	.close = sst_platform_close,
-	.ioctl = snd_pcm_lib_ioctl,
-	.prepare = sst_platform_pcm_prepare,
-	.trigger = sst_platform_pcm_trigger,
-	.pointer = sst_platform_pcm_pointer,
-	.hw_params = sst_platform_pcm_hw_params,
-	.hw_free = sst_platform_pcm_hw_free,
-};
-
-static void sst_pcm_free(struct snd_pcm *pcm)
-{
-	pr_debug("sst_pcm_free called\n");
-	snd_pcm_lib_preallocate_free_for_all(pcm);
-}
-
-static int sst_pcm_new(struct snd_soc_pcm_runtime *rtd)
-{
-	struct snd_pcm *pcm = rtd->pcm;
-	int retval = 0;
-
-	pr_debug("sst_pcm_new called\n");
-	if (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream ||
-			pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {
-		retval =  snd_pcm_lib_preallocate_pages_for_all(pcm,
-			SNDRV_DMA_TYPE_CONTINUOUS,
-			snd_dma_continuous_data(GFP_KERNEL),
-			SST_MIN_BUFFER, SST_MAX_BUFFER);
-		if (retval) {
-			pr_err("dma buffer allocationf fail\n");
-			return retval;
-		}
-	}
-	return retval;
-}
-
-/* compress stream operations */
-static void sst_compr_fragment_elapsed(void *arg)
-{
-	struct snd_compr_stream *cstream = (struct snd_compr_stream *)arg;
-
-	pr_debug("fragment elapsed by driver\n");
-	if (cstream)
-		snd_compr_fragment_elapsed(cstream);
-}
-
-static int sst_platform_compr_open(struct snd_compr_stream *cstream)
-{
-
-	int ret_val = 0;
-	struct snd_compr_runtime *runtime = cstream->runtime;
-	struct sst_runtime_stream *stream;
-
-	stream = kzalloc(sizeof(*stream), GFP_KERNEL);
-	if (!stream)
-		return -ENOMEM;
-
-	spin_lock_init(&stream->status_lock);
-
-	/* get the sst ops */
-	if (!sst || !try_module_get(sst->dev->driver->owner)) {
-		pr_err("no device available to run\n");
-		ret_val = -ENODEV;
-		goto out_ops;
-	}
-	stream->compr_ops = sst->compr_ops;
-
-	stream->id = 0;
-	sst_set_stream_status(stream, SST_PLATFORM_INIT);
-	runtime->private_data = stream;
-	return 0;
-out_ops:
-	kfree(stream);
-	return ret_val;
-}
-
-static int sst_platform_compr_free(struct snd_compr_stream *cstream)
-{
-	struct sst_runtime_stream *stream;
-	int ret_val = 0, str_id;
-
-	stream = cstream->runtime->private_data;
-	/*need to check*/
-	str_id = stream->id;
-	if (str_id)
-		ret_val = stream->compr_ops->close(str_id);
-	module_put(sst->dev->driver->owner);
-	kfree(stream);
-	pr_debug("%s: %d\n", __func__, ret_val);
-	return 0;
-}
-
-static int sst_platform_compr_set_params(struct snd_compr_stream *cstream,
-					struct snd_compr_params *params)
-{
-	struct sst_runtime_stream *stream;
-	int retval;
-	struct snd_sst_params str_params;
-	struct sst_compress_cb cb;
-
-	stream = cstream->runtime->private_data;
-	/* construct fw structure for this*/
-	memset(&str_params, 0, sizeof(str_params));
-
-	str_params.ops = STREAM_OPS_PLAYBACK;
-	str_params.stream_type = SST_STREAM_TYPE_MUSIC;
-	str_params.device_type = SND_SST_DEVICE_COMPRESS;
-
-	switch (params->codec.id) {
-	case SND_AUDIOCODEC_MP3: {
-		str_params.codec = SST_CODEC_TYPE_MP3;
-		str_params.sparams.uc.mp3_params.codec = SST_CODEC_TYPE_MP3;
-		str_params.sparams.uc.mp3_params.num_chan = params->codec.ch_in;
-		str_params.sparams.uc.mp3_params.pcm_wd_sz = 16;
-		break;
-	}
-
-	case SND_AUDIOCODEC_AAC: {
-		str_params.codec = SST_CODEC_TYPE_AAC;
-		str_params.sparams.uc.aac_params.codec = SST_CODEC_TYPE_AAC;
-		str_params.sparams.uc.aac_params.num_chan = params->codec.ch_in;
-		str_params.sparams.uc.aac_params.pcm_wd_sz = 16;
-		if (params->codec.format == SND_AUDIOSTREAMFORMAT_MP4ADTS)
-			str_params.sparams.uc.aac_params.bs_format =
-							AAC_BIT_STREAM_ADTS;
-		else if (params->codec.format == SND_AUDIOSTREAMFORMAT_RAW)
-			str_params.sparams.uc.aac_params.bs_format =
-							AAC_BIT_STREAM_RAW;
-		else {
-			pr_err("Undefined format%d\n", params->codec.format);
-			return -EINVAL;
-		}
-		str_params.sparams.uc.aac_params.externalsr =
-						params->codec.sample_rate;
-		break;
-	}
-
-	default:
-		pr_err("codec not supported, id =%d\n", params->codec.id);
-		return -EINVAL;
-	}
-
-	str_params.aparams.ring_buf_info[0].addr  =
-					virt_to_phys(cstream->runtime->buffer);
-	str_params.aparams.ring_buf_info[0].size =
-					cstream->runtime->buffer_size;
-	str_params.aparams.sg_count = 1;
-	str_params.aparams.frag_size = cstream->runtime->fragment_size;
-
-	cb.param = cstream;
-	cb.compr_cb = sst_compr_fragment_elapsed;
-
-	retval = stream->compr_ops->open(&str_params, &cb);
-	if (retval < 0) {
-		pr_err("stream allocation failed %d\n", retval);
-		return retval;
-	}
-
-	stream->id = retval;
-	return 0;
-}
-
-static int sst_platform_compr_trigger(struct snd_compr_stream *cstream, int cmd)
-{
-	struct sst_runtime_stream *stream =
-		cstream->runtime->private_data;
-
-	return stream->compr_ops->control(cmd, stream->id);
-}
-
-static int sst_platform_compr_pointer(struct snd_compr_stream *cstream,
-					struct snd_compr_tstamp *tstamp)
-{
-	struct sst_runtime_stream *stream;
-
-	stream  = cstream->runtime->private_data;
-	stream->compr_ops->tstamp(stream->id, tstamp);
-	tstamp->byte_offset = tstamp->copied_total %
-				 (u32)cstream->runtime->buffer_size;
-	pr_debug("calc bytes offset/copied bytes as %d\n", tstamp->byte_offset);
-	return 0;
-}
-
-static int sst_platform_compr_ack(struct snd_compr_stream *cstream,
-					size_t bytes)
-{
-	struct sst_runtime_stream *stream;
-
-	stream  = cstream->runtime->private_data;
-	stream->compr_ops->ack(stream->id, (unsigned long)bytes);
-	stream->bytes_written += bytes;
-
-	return 0;
-}
-
-static int sst_platform_compr_get_caps(struct snd_compr_stream *cstream,
-					struct snd_compr_caps *caps)
-{
-	struct sst_runtime_stream *stream =
-		cstream->runtime->private_data;
-
-	return stream->compr_ops->get_caps(caps);
-}
-
-static int sst_platform_compr_get_codec_caps(struct snd_compr_stream *cstream,
-					struct snd_compr_codec_caps *codec)
-{
-	struct sst_runtime_stream *stream =
-		cstream->runtime->private_data;
-
-	return stream->compr_ops->get_codec_caps(codec);
-}
-
-static int sst_platform_compr_set_metadata(struct snd_compr_stream *cstream,
-					struct snd_compr_metadata *metadata)
-{
-	struct sst_runtime_stream *stream  =
-		 cstream->runtime->private_data;
-
-	return stream->compr_ops->set_metadata(stream->id, metadata);
-}
-
-static struct snd_compr_ops sst_platform_compr_ops = {
-
-	.open = sst_platform_compr_open,
-	.free = sst_platform_compr_free,
-	.set_params = sst_platform_compr_set_params,
-	.set_metadata = sst_platform_compr_set_metadata,
-	.trigger = sst_platform_compr_trigger,
-	.pointer = sst_platform_compr_pointer,
-	.ack = sst_platform_compr_ack,
-	.get_caps = sst_platform_compr_get_caps,
-	.get_codec_caps = sst_platform_compr_get_codec_caps,
-};
-
-static struct snd_soc_platform_driver sst_soc_platform_drv = {
-	.ops		= &sst_platform_ops,
-	.compr_ops	= &sst_platform_compr_ops,
-	.pcm_new	= sst_pcm_new,
-	.pcm_free	= sst_pcm_free,
-};
-
-static int sst_platform_probe(struct platform_device *pdev)
-{
-	int ret;
-
-	pr_debug("sst_platform_probe called\n");
-	sst = NULL;
-	ret = snd_soc_register_platform(&pdev->dev, &sst_soc_platform_drv);
-	if (ret) {
-		pr_err("registering soc platform failed\n");
-		return ret;
-	}
-
-	ret = snd_soc_register_component(&pdev->dev, &sst_component,
-				sst_platform_dai, ARRAY_SIZE(sst_platform_dai));
-	if (ret) {
-		pr_err("registering cpu dais failed\n");
-		snd_soc_unregister_platform(&pdev->dev);
-	}
-	return ret;
-}
-
-static int sst_platform_remove(struct platform_device *pdev)
-{
-
-	snd_soc_unregister_component(&pdev->dev);
-	snd_soc_unregister_platform(&pdev->dev);
-	pr_debug("sst_platform_remove success\n");
-	return 0;
-}
-
-static struct platform_driver sst_platform_driver = {
-	.driver		= {
-		.name		= "sst-platform",
-		.owner		= THIS_MODULE,
-	},
-	.probe		= sst_platform_probe,
-	.remove		= sst_platform_remove,
-};
-
-module_platform_driver(sst_platform_driver);
-
-MODULE_DESCRIPTION("ASoC Intel(R) MID Platform driver");
-MODULE_AUTHOR("Vinod Koul <vinod.koul@intel.com>");
-MODULE_AUTHOR("Harsha Priya <priya.harsha@intel.com>");
-MODULE_LICENSE("GPL v2");
-MODULE_ALIAS("platform:sst-platform");
diff --git a/sound/soc/intel/sst_platform.h b/sound/soc/intel/sst_platform.h
index bee64fb..5d231b5 100644
--- a/sound/soc/intel/sst_platform.h
+++ b/sound/soc/intel/sst_platform.h
@@ -24,55 +24,14 @@
  *
  */
 
-#ifndef __SST_PLATFORMDRV_H__
-#define __SST_PLATFORMDRV_H__
+#ifndef __SST_PLATFORM_H__
+#define __SST_PLATFORM_H__
 
-#include "sst_dsp.h"
+#include <sound/soc.h>
 
-#define SST_MONO		1
-#define SST_STEREO		2
-#define SST_MAX_CAP		5
+#define SST_MAX_BIN_BYTES 1024
 
-#define SST_MAX_BUFFER		(800*1024)
-#define SST_MIN_BUFFER		(800*1024)
-#define SST_MIN_PERIOD_BYTES	32
-#define SST_MAX_PERIOD_BYTES	SST_MAX_BUFFER
-#define SST_MIN_PERIODS		2
-#define SST_MAX_PERIODS		(1024*2)
-#define SST_FIFO_SIZE		0
-
-struct pcm_stream_info {
-	int str_id;
-	void *mad_substream;
-	void (*period_elapsed) (void *mad_substream);
-	unsigned long long buffer_ptr;
-	int sfreq;
-};
-
-enum sst_drv_status {
-	SST_PLATFORM_INIT = 1,
-	SST_PLATFORM_STARTED,
-	SST_PLATFORM_RUNNING,
-	SST_PLATFORM_PAUSED,
-	SST_PLATFORM_DROPPED,
-};
-
-enum sst_controls {
-	SST_SND_ALLOC =			0x00,
-	SST_SND_PAUSE =			0x01,
-	SST_SND_RESUME =		0x02,
-	SST_SND_DROP =			0x03,
-	SST_SND_FREE =			0x04,
-	SST_SND_BUFFER_POINTER =	0x05,
-	SST_SND_STREAM_INIT =		0x06,
-	SST_SND_START	 =		0x07,
-	SST_MAX_CONTROLS =		0x07,
-};
-
-enum sst_stream_ops {
-	STREAM_OPS_PLAYBACK = 0,
-	STREAM_OPS_CAPTURE,
-};
+struct sst_data;
 
 enum sst_audio_device_type {
 	SND_SST_DEVICE_HEADSET = 1,
@@ -83,33 +42,64 @@ enum sst_audio_device_type {
 	SND_SST_DEVICE_COMPRESS,
 };
 
-/* PCM Parameters */
-struct sst_pcm_params {
-	u16 codec;	/* codec type */
-	u8 num_chan;	/* 1=Mono, 2=Stereo */
-	u8 pcm_wd_sz;	/* 16/24 - bit*/
-	u32 reserved;	/* Bitrate in bits per second */
-	u32 sfreq;	/* Sampling rate in Hz */
-	u32 ring_buffer_size;
-	u32 period_count;	/* period elapsed in samples*/
-	u32 ring_buffer_addr;
+enum snd_sst_input_stream {
+	SST_INPUT_STREAM_NONE = 0x0,
+	SST_INPUT_STREAM_PCM = 0x6,
+	SST_INPUT_STREAM_COMPRESS = 0x8,
+	SST_INPUT_STREAM_MIXED = 0xE,
+};
+
+enum sst_stream_ops {
+	STREAM_OPS_PLAYBACK = 0,        /* Decode */
+	STREAM_OPS_CAPTURE,             /* Encode */
+	STREAM_OPS_COMPRESSED_PATH,     /* Offload playback/capture */
+
+};
+enum snd_sst_stream_type {
+	SST_STREAM_DEVICE_HS = 32,
+	SST_STREAM_DEVICE_IHF = 33,
+	SST_STREAM_DEVICE_MIC0 = 34,
+	SST_STREAM_DEVICE_MIC1 = 35,
 };
 
-struct sst_stream_params {
-	u32 result;
-	u32 stream_id;
-	u8 codec;
-	u8 ops;
-	u8 stream_type;
-	u8 device_type;
-	struct sst_pcm_params sparams;
+enum sst_controls {
+	SST_SND_ALLOC =			0x1000,
+	SST_SND_PAUSE =			0x1001,
+	SST_SND_RESUME =		0x1002,
+	SST_SND_DROP =			0x1003,
+	SST_SND_FREE =			0x1004,
+	SST_SND_BUFFER_POINTER =	0x1005,
+	SST_SND_STREAM_INIT =		0x1006,
+	SST_SND_START	 =		0x1007,
+	SST_SET_RUNTIME_PARAMS =	0x1008,
+	SST_SET_ALGO_PARAMS =		0x1009,
+	SST_SET_BYTE_STREAM =		0x100A,
+	SST_GET_BYTE_STREAM =		0x100B,
+	SST_SET_SSP_CONFIG =		0x100C,
+	SST_SET_PROBE_BYTE_STREAM =     0x100D,
+	SST_GET_PROBE_BYTE_STREAM =	0x100E,
+	SST_SET_VTSV_INFO =		0x100F,
+};
+
+struct pcm_stream_info {
+	int str_id;
+	void *mad_substream;
+	void (*period_elapsed) (void *mad_substream);
+	unsigned long long buffer_ptr;
+	unsigned long long pcm_delay;
+	int sfreq;
 };
 
 struct sst_compress_cb {
 	void *param;
 	void (*compr_cb)(void *param);
+	void *drain_cb_param;
+	void (*drain_notify)(void *param);
+
 };
 
+struct snd_sst_params;
+
 struct compress_sst_ops {
 	const char *name;
 	int (*open) (struct snd_sst_params *str_params,
@@ -120,15 +110,26 @@ struct compress_sst_ops {
 	int (*close) (unsigned int str_id);
 	int (*get_caps) (struct snd_compr_caps *caps);
 	int (*get_codec_caps) (struct snd_compr_codec_caps *codec);
-	int (*set_metadata) (unsigned int str_id,
-			struct snd_compr_metadata *mdata);
+	int (*set_metadata) (unsigned int str_id, struct snd_compr_metadata *metadata);
+
+};
+
+enum lpe_param_types_mixer {
+	SST_ALGO_PARAM_MIXER_STREAM_CFG = 0x801,
+};
 
+struct mad_ops_wq {
+	int stream_id;
+	enum sst_controls control_op;
+	struct work_struct wq;
 };
 
 struct sst_ops {
-	int (*open) (struct sst_stream_params *str_param);
+	int (*open) (struct snd_sst_params *str_param);
 	int (*device_control) (int cmd, void *arg);
+	int (*set_generic_params) (enum sst_controls cmd, void *arg);
 	int (*close) (unsigned int str_id);
+	int (*power) (bool state);
 };
 
 struct sst_runtime_stream {
@@ -145,6 +146,7 @@ struct sst_device {
 	char *name;
 	struct device *dev;
 	struct sst_ops *ops;
+	struct platform_device *pdev;
 	struct compress_sst_ops *compr_ops;
 };
 
diff --git a/sound/soc/intel/sst_platform_pvt.h b/sound/soc/intel/sst_platform_pvt.h
new file mode 100644
index 0000000..f74dd9c
--- /dev/null
+++ b/sound/soc/intel/sst_platform_pvt.h
@@ -0,0 +1,127 @@
+/*
+ *  sst_platform_pvt.h - Intel MID Platform driver header file
+ *
+ *  Copyright (C) 2010 Intel Corp
+ *  Author: Vinod Koul <vinod.koul@intel.com>
+ *  Author: Harsha Priya <priya.harsha@intel.com>
+ *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; version 2 of the License.
+ *
+ *  This program is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *
+ */
+
+#ifndef __SST_PLATFORM_PVT_H__
+#define __SST_PLATFORM_PVT_H__
+
+/* TODO rmv this global */
+extern struct sst_device *sst_dsp;
+
+#define SST_MONO		1
+#define SST_STEREO		2
+
+#define SST_MIN_RATE		8000
+#define SST_MAX_RATE		48000
+#define SST_MIN_CHANNEL		1
+#define SST_MAX_CHANNEL		2
+
+#define SST_MAX_BUFFER		96000 /*500ms@48K,16bit,2ch - CLV*/
+#define SST_MIN_PERIOD_BYTES	1536  /*24ms@16K,16bit,2ch - For VoIP on Mrfld*/
+#define SST_MAX_PERIOD_BYTES	48000 /*250ms@48K,16bit,2ch - CLV*/
+
+#define SST_MIN_PERIODS		2
+#define SST_MAX_PERIODS		50
+#define SST_FIFO_SIZE		0
+#define SST_CODEC_TYPE_PCM	1
+
+#define SST_HEADSET_DAI		"Headset-cpu-dai"
+#define SST_SPEAKER_DAI		"Speaker-cpu-dai"
+#define SST_VOICE_DAI		"Voice-cpu-dai"
+#define SST_VIRTUAL_DAI		"Virtual-cpu-dai"
+#define SST_LOOPBACK_DAI	"Loopback-cpu-dai"
+#define SST_POWER_DAI		"Power-cpu-dai"
+#define SST_COMPRESS_DAI	"Compress-cpu-dai"
+#define SST_PROBE_DAI		"Probe-cpu-dai"
+#define SST_VOIP_DAI		"Voip-cpu-dai"
+#define SST_DEEPBUFFER_DAI	"Deepbuffer-cpu-dai"
+#define SST_LOWLATENCY_DAI	"Lowlatency-cpu-dai"
+
+struct sst_device;
+
+enum sst_drv_status {
+	SST_PLATFORM_UNINIT,
+	SST_PLATFORM_INIT,
+	SST_PLATFORM_RUNNING,
+	SST_PLATFORM_PAUSED,
+	SST_PLATFORM_DROPPED,
+};
+
+#define SST_PIPE_CONTROL	0x0
+#define SST_COMPRESS_VOL	0x01
+
+int sst_platform_clv_init(struct snd_soc_platform *platform);
+int sst_dsp_init(struct snd_soc_platform *platform);
+int sst_dsp_init_v2_dpcm(struct snd_soc_platform *platform);
+int sst_send_pipe_gains(struct snd_soc_dai *dai, int stream, int mute);
+
+unsigned int sst_soc_read(struct snd_soc_platform *platform, unsigned int reg);
+int sst_soc_write(struct snd_soc_platform *platform, unsigned int reg, unsigned int val);
+unsigned int sst_reg_read(struct sst_data *sst, unsigned int reg,
+			  unsigned int shift, unsigned int max);
+unsigned int sst_reg_write(struct sst_data *sst, unsigned int reg,
+			   unsigned int shift, unsigned int max, unsigned int val);
+
+int sst_algo_int_ctl_info(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_info *uinfo);
+void sst_set_stream_status(struct sst_runtime_stream *stream, int state);
+int sst_fill_stream_params(void *substream, const struct sst_data *ctx,
+			   struct snd_sst_params *str_params, bool is_compress);
+int sst_dpcm_probe_send(struct snd_soc_platform *platform, u16 probe_pipe,
+			int substream, int direction, bool on);
+int sst_byte_control_get(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol);
+int sst_byte_control_set(struct snd_kcontrol *kcontrol,
+			 struct snd_ctl_elem_value *ucontrol);
+
+struct sst_algo_int_control_v2 {
+	struct soc_mixer_control mc;
+	u16 module_id; /* module identifieer */
+	u16 pipe_id; /* location info: pipe_id + instance_id */
+	u16 instance_id;
+	unsigned int value; /* Value received is stored here */
+};
+
+struct sst_lowlatency_deepbuff {
+	/* Thresholds for low latency & deep buffer */
+	unsigned long	*low_latency;
+	unsigned long	*deep_buffer;
+	unsigned long	period_time;
+};
+
+struct sst_data {
+	struct platform_device *pdev;
+	struct sst_platform_data *pdata;
+	unsigned int lpe_mixer_input_ihf;
+	unsigned int lpe_mixer_input_hs;
+	u32 *widget;
+	char *byte_stream;
+	struct mutex lock;
+	/* Pipe_id for probe_stream to be saved in stream map */
+	u8 pipe_id;
+	bool vtsv_enroll;
+	struct sst_lowlatency_deepbuff ll_db;
+};
+#endif
diff --git a/sound/soc/soc-compress.c b/sound/soc/soc-compress.c
index 4f98ff1..67131be 100644
--- a/sound/soc/soc-compress.c
+++ b/sound/soc/soc-compress.c
@@ -181,18 +181,17 @@ static void close_delayed_work(struct work_struct *work)
 
 	mutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);
 
-	dev_dbg(rtd->dev, "ASoC: pop wq checking: %s status: %s waiting: %s\n",
-		 codec_dai->driver->playback.stream_name,
-		 codec_dai->playback_active ? "active" : "inactive",
-		 rtd->pop_wait ? "yes" : "no");
+	dev_dbg (rtd->dev, "ASoC: pop wq checking: %s status: %s waiting: %s\n",
+			codec_dai->driver->playback.stream_name,
+			codec_dai->playback_active ? "active" : "inactive",
+			rtd->pop_wait ? "yes" : "no");
 
 	/* are we waiting on this codec DAI stream */
-	if (rtd->pop_wait == 1) {
+	if (rtd->pop_wait == 1 && !codec_dai->active) {
 		rtd->pop_wait = 0;
 		snd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_PLAYBACK,
 					  SND_SOC_DAPM_STREAM_STOP);
 	}
-
 	mutex_unlock(&rtd->pcm_mutex);
 }
 
@@ -213,8 +212,8 @@ static int soc_compr_free(struct snd_compr_stream *cstream)
 		cpu_dai->capture_active--;
 		codec_dai->capture_active--;
 	}
-
-	snd_soc_dai_digital_mute(codec_dai, 1, cstream->direction);
+	if (!codec_dai->playback_active)
+		snd_soc_dai_digital_mute(codec_dai, 1, cstream->direction);
 
 	cpu_dai->active--;
 	codec_dai->active--;
@@ -226,7 +225,6 @@ static int soc_compr_free(struct snd_compr_stream *cstream)
 	if (!codec_dai->active)
 		codec_dai->rate = 0;
 
-
 	if (rtd->dai_link->compr_ops && rtd->dai_link->compr_ops->shutdown)
 		rtd->dai_link->compr_ops->shutdown(cstream);
 
@@ -234,7 +232,8 @@ static int soc_compr_free(struct snd_compr_stream *cstream)
 		platform->driver->compr_ops->free(cstream);
 	cpu_dai->runtime = NULL;
 
-	if (cstream->direction == SND_COMPRESS_PLAYBACK) {
+	if (cstream->direction == SND_COMPRESS_PLAYBACK
+				&& !codec_dai->playback_active) {
 		if (!rtd->pmdown_time || codec->ignore_pmdown_time ||
 		    rtd->dai_link->ignore_pmdown_time) {
 			snd_soc_dapm_stream_event(rtd,
@@ -246,7 +245,8 @@ static int soc_compr_free(struct snd_compr_stream *cstream)
 					   &rtd->delayed_work,
 					   msecs_to_jiffies(rtd->pmdown_time));
 		}
-	} else {
+	} else if (cstream->direction == SND_COMPRESS_CAPTURE
+					&& !codec_dai->capture_active) {
 		/* capture streams can be powered down now */
 		snd_soc_dapm_stream_event(rtd,
 			SNDRV_PCM_STREAM_CAPTURE,
@@ -282,6 +282,8 @@ static int soc_compr_free_fe(struct snd_compr_stream *cstream)
 	codec_dai->active--;
 	fe->codec->active--;
 
+	snd_soc_dai_digital_mute(cpu_dai, 1, stream);
+
 	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;
 
 	ret = dpcm_be_dai_hw_free(fe, stream);
@@ -321,28 +323,15 @@ static int soc_compr_trigger(struct snd_compr_stream *cstream, int cmd)
 
 	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
 	struct snd_soc_platform *platform = rtd->platform;
-	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 	int ret = 0;
 
-	mutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);
-
 	if (platform->driver->compr_ops && platform->driver->compr_ops->trigger) {
 		ret = platform->driver->compr_ops->trigger(cstream, cmd);
 		if (ret < 0)
 			goto out;
 	}
 
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-		snd_soc_dai_digital_mute(codec_dai, 0, cstream->direction);
-		break;
-	case SNDRV_PCM_TRIGGER_STOP:
-		snd_soc_dai_digital_mute(codec_dai, 1, cstream->direction);
-		break;
-	}
-
 out:
-	mutex_unlock(&rtd->pcm_mutex);
 	return ret;
 }
 
@@ -426,21 +415,17 @@ static int soc_compr_set_params(struct snd_compr_stream *cstream,
 			goto err;
 	}
 
-	if (cstream->direction == SND_COMPRESS_PLAYBACK)
-		snd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_PLAYBACK,
-					SND_SOC_DAPM_STREAM_START);
-	else
-		snd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_CAPTURE,
-					SND_SOC_DAPM_STREAM_START);
-
 	/* cancel any delayed stream shutdown that is pending */
-	rtd->pop_wait = 0;
-	mutex_unlock(&rtd->pcm_mutex);
-
-	cancel_delayed_work_sync(&rtd->delayed_work);
+	if (cstream->direction == SND_COMPRESS_PLAYBACK
+				 && rtd->pop_wait) {
+		rtd->pop_wait = 0;
+		cancel_delayed_work(&rtd->delayed_work);
+	}
 
-	return ret;
+	snd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_PLAYBACK,
+					SND_SOC_DAPM_STREAM_START);
 
+	snd_soc_dai_digital_mute(rtd->codec_dai, 0, cstream->direction);
 err:
 	mutex_unlock(&rtd->pcm_mutex);
 	return ret;
@@ -452,6 +437,10 @@ static int soc_compr_set_params_fe(struct snd_compr_stream *cstream,
 	struct snd_soc_pcm_runtime *fe = cstream->private_data;
 	struct snd_pcm_substream *fe_substream = fe->pcm->streams[0].substream;
 	struct snd_soc_platform *platform = fe->platform;
+	struct snd_soc_dai *cpu_dai = fe->cpu_dai;
+	struct snd_soc_dai *codec_dai =  fe->codec_dai;
+
+	struct snd_pcm_hw_params *hw_params;
 	int ret = 0, stream;
 
 	if (cstream->direction == SND_COMPRESS_PLAYBACK)
@@ -459,8 +448,18 @@ static int soc_compr_set_params_fe(struct snd_compr_stream *cstream,
 	else
 		stream = SNDRV_PCM_STREAM_CAPTURE;
 
+	hw_params = kzalloc(sizeof(*hw_params), GFP_KERNEL);
+	if (hw_params == NULL)
+		return -ENOMEM;
+
 	mutex_lock_nested(&fe->card->mutex, SND_SOC_CARD_CLASS_RUNTIME);
 
+	/* first we call set_params for the platform driver
+	 * this should configure the soc side
+	 * if the machine has compressed ops then we call that as well
+	 * expectation is that platform and machine will configure everything
+	 * for this compress path, like configuring pcm port for codec
+	 */
 	if (platform->driver->compr_ops && platform->driver->compr_ops->set_params) {
 		ret = platform->driver->compr_ops->set_params(cstream, params);
 		if (ret < 0)
@@ -473,13 +472,8 @@ static int soc_compr_set_params_fe(struct snd_compr_stream *cstream,
 			goto out;
 	}
 
-	/*
-	 * Create an empty hw_params for the BE as the machine driver must
-	 * fix this up to match DSP decoder and ASRC configuration.
-	 * I.e. machine driver fixup for compressed BE is mandatory.
-	 */
-	memset(&fe->dpcm[fe_substream->stream].hw_params, 0,
-		sizeof(struct snd_pcm_hw_params));
+	memcpy(&fe->dpcm[fe_substream->stream].hw_params, params,
+			sizeof(struct snd_pcm_hw_params));
 
 	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_FE;
 
@@ -498,6 +492,8 @@ static int soc_compr_set_params_fe(struct snd_compr_stream *cstream,
 
 	fe->dpcm[stream].state = SND_SOC_DPCM_STATE_PREPARE;
 
+	snd_soc_dai_digital_mute(cpu_dai, 0, stream);
+
 out:
 	fe->dpcm[stream].runtime_update = SND_SOC_DPCM_UPDATE_NO;
 	mutex_unlock(&fe->card->mutex);
diff --git a/sound/soc/soc-core.c b/sound/soc/soc-core.c
index c75d008..dc87eed 100644
--- a/sound/soc/soc-core.c
+++ b/sound/soc/soc-core.c
@@ -1199,6 +1199,11 @@ static int soc_probe_platform(struct snd_soc_card *card,
 		if (dai->dev != platform->dev)
 			continue;
 
+		/* dummy platform doesn't have and DAIs, don't add dummy-codec
+		 * widgets here (since dev is the same)
+		 */
+		if (!strcmp(dai->name, "snd-soc-dummy-dai"))
+			continue;
 		snd_soc_dapm_new_dai_widgets(&platform->dapm, dai);
 	}
 
@@ -3287,6 +3292,19 @@ out:
 }
 EXPORT_SYMBOL_GPL(snd_soc_bytes_put);
 
+int snd_soc_info_bytes_ext(struct snd_kcontrol *kcontrol,
+			struct snd_ctl_elem_info *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct soc_bytes_ext *params = (void *)kcontrol->private_value;
+
+	ucontrol->type = SNDRV_CTL_ELEM_TYPE_BYTES;
+	ucontrol->count = params->max;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(snd_soc_info_bytes_ext);
+
 /**
  * snd_soc_info_xr_sx - signed multi register info callback
  * @kcontrol: mreg control
diff --git a/sound/soc/soc-jack.c b/sound/soc/soc-jack.c
index 23d43da..265453d 100644
--- a/sound/soc/soc-jack.c
+++ b/sound/soc/soc-jack.c
@@ -321,10 +321,13 @@ int snd_soc_jack_add_gpios(struct snd_soc_jack *jack, int count,
 		INIT_DELAYED_WORK(&gpios[i].work, gpio_work);
 		gpios[i].jack = jack;
 
+		if (!gpios[i].irq_flags)
+			gpios[i].irq_flags =
+				IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING;
+
 		ret = request_any_context_irq(gpio_to_irq(gpios[i].gpio),
 					      gpio_handler,
-					      IRQF_TRIGGER_RISING |
-					      IRQF_TRIGGER_FALLING,
+					      gpios[i].irq_flags,
 					      gpios[i].name,
 					      &gpios[i]);
 		if (ret < 0)
diff --git a/sound/soc/soc-pcm.c b/sound/soc/soc-pcm.c
index e28704e..d5d4bc9 100644
--- a/sound/soc/soc-pcm.c
+++ b/sound/soc/soc-pcm.c
@@ -439,7 +439,7 @@ static void close_delayed_work(struct work_struct *work)
 		 rtd->pop_wait ? "yes" : "no");
 
 	/* are we waiting on this codec DAI stream */
-	if (rtd->pop_wait == 1) {
+	if (rtd->pop_wait == 1 && !codec_dai->active) {
 		rtd->pop_wait = 0;
 		snd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_PLAYBACK,
 					  SND_SOC_DAPM_STREAM_STOP);
@@ -482,6 +482,10 @@ static int soc_pcm_close(struct snd_pcm_substream *substream)
 	if (!codec_dai->active)
 		codec_dai->rate = 0;
 
+	if (!codec_dai->playback_active)
+		snd_soc_dai_digital_mute(codec_dai, 1, substream->stream);
+
+	snd_soc_dai_digital_mute(cpu_dai, 1, substream->stream);
 	if (cpu_dai->driver->ops->shutdown)
 		cpu_dai->driver->ops->shutdown(substream, cpu_dai);
 
@@ -495,7 +499,8 @@ static int soc_pcm_close(struct snd_pcm_substream *substream)
 		platform->driver->ops->close(substream);
 	cpu_dai->runtime = NULL;
 
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK
+			&& !codec_dai->playback_active) {
 		if (!rtd->pmdown_time || codec->ignore_pmdown_time ||
 		    rtd->dai_link->ignore_pmdown_time) {
 			/* powered down playback stream now */
@@ -509,7 +514,8 @@ static int soc_pcm_close(struct snd_pcm_substream *substream)
 					   &rtd->delayed_work,
 					   msecs_to_jiffies(rtd->pmdown_time));
 		}
-	} else {
+	} else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE
+			&& !codec_dai->capture_active) {
 		/* capture streams can be powered down now */
 		snd_soc_dapm_stream_event(rtd, SNDRV_PCM_STREAM_CAPTURE,
 					  SND_SOC_DAPM_STREAM_STOP);
@@ -590,6 +596,7 @@ static int soc_pcm_prepare(struct snd_pcm_substream *substream)
 			SND_SOC_DAPM_STREAM_START);
 
 	snd_soc_dai_digital_mute(codec_dai, 0, substream->stream);
+	snd_soc_dai_digital_mute(cpu_dai, 0, substream->stream);
 
 out:
 	mutex_unlock(&rtd->pcm_mutex);
@@ -1305,7 +1312,6 @@ static int dpcm_fe_dai_startup(struct snd_pcm_substream *fe_substream)
 	}
 
 	fe->dpcm[stream].state = SND_SOC_DPCM_STATE_OPEN;
-
 	dpcm_set_fe_runtime(fe_substream);
 	snd_pcm_limit_hw_rates(runtime);
 
@@ -1551,7 +1557,7 @@ static int dpcm_fe_dai_hw_params(struct snd_pcm_substream *substream,
 	if (ret < 0) {
 		dev_err(fe->dev,"ASoC: hw_params FE failed %d\n", ret);
 		dpcm_be_dai_hw_free(fe, stream);
-	 } else
+	} else
 		fe->dpcm[stream].state = SND_SOC_DPCM_STATE_HW_PARAMS;
 
 out:
@@ -1667,7 +1673,6 @@ int dpcm_be_dai_trigger(struct snd_soc_pcm_runtime *fe, int stream,
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(dpcm_be_dai_trigger);
 
 static int dpcm_fe_dai_do_trigger(struct snd_pcm_substream *substream, int cmd)
 {
diff --git a/sound/soc/soc-utils.c b/sound/soc/soc-utils.c
index 7f22ca3..77dc5dd 100644
--- a/sound/soc/soc-utils.c
+++ b/sound/soc/soc-utils.c
@@ -89,7 +89,28 @@ static struct snd_soc_platform_driver dummy_platform = {
 	.ops = &dummy_dma_ops,
 };
 
-static struct snd_soc_codec_driver dummy_codec;
+static struct snd_soc_dapm_widget dapm_widgets[] = {
+	SND_SOC_DAPM_INPUT("Dummy Input"),
+	SND_SOC_DAPM_OUTPUT("Dummy Output"),
+};
+
+static struct snd_soc_dapm_route intercon[] = {
+	{ "Dummy Output", NULL, "Dummy Playback"},
+	{ "Dummy Capture", NULL, "Dummy Input"},
+};
+
+static int dummy_codec_probe(struct snd_soc_codec *codec)
+{
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+	snd_soc_dapm_new_controls(dapm, dapm_widgets,
+			ARRAY_SIZE(dapm_widgets));
+	snd_soc_dapm_add_routes(dapm, intercon, ARRAY_SIZE(intercon));
+	return 0;
+}
+
+static struct snd_soc_codec_driver dummy_codec = {
+	.probe = dummy_codec_probe,
+};
 
 #define STUB_RATES	SNDRV_PCM_RATE_8000_192000
 #define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S8 | \
@@ -101,17 +122,18 @@ static struct snd_soc_codec_driver dummy_codec;
 			SNDRV_PCM_FMTBIT_S32_LE | \
 			SNDRV_PCM_FMTBIT_U32_LE | \
 			SNDRV_PCM_FMTBIT_IEC958_SUBFRAME_LE)
+
 static struct snd_soc_dai_driver dummy_dai = {
 	.name = "snd-soc-dummy-dai",
 	.playback = {
-		.stream_name	= "Playback",
+		.stream_name	= "Dummy Playback",
 		.channels_min	= 1,
 		.channels_max	= 384,
 		.rates		= STUB_RATES,
 		.formats	= STUB_FORMATS,
 	},
 	.capture = {
-		.stream_name	= "Capture",
+		.stream_name	= "Dummy Capture",
 		.channels_min	= 1,
 		.channels_max	= 384,
 		.rates = STUB_RATES,
-- 
1.7.5.4

