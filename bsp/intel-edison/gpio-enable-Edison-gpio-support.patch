From fc61ac54adcf0e5daf4a975b283e51b9bbf24193 Mon Sep 17 00:00:00 2001
From: Liwei Song <liwei.song@windriver.com>
Date: Tue, 1 Mar 2016 19:45:11 -0500
Subject: [PATCH 06/11] gpio: enable Edison gpio support

This patch is from yocto Intel Edison support:
http://downloadmirror.intel.com/25028/eng/edison-src-ww25.5-15.tgz

Enable Intel Edison GPIO support. Driver name intel_mid_gpio.

Signed-off-by: Liwei Song <liwei.song@windriver.com>
---
 arch/x86/Kconfig                                   |   40 +
 arch/x86/include/asm/gpio.h                        |   23 +
 arch/x86/include/asm/intel_scu_ipc.h               |  104 ++-
 .../intel-mid/device_libs/pci/platform_sdhci_pci.c |    2 +-
 .../intel-mid/device_libs/platform_dw_i2c.c        |    8 +-
 .../intel-mid/device_libs/platform_gpio_keys.c     |    1 +
 .../intel-mid/device_libs/platform_gpio_keys.h     |   16 +
 .../intel-mid/device_libs/platform_msic_gpio.c     |   69 +-
 .../intel-mid/device_libs/platform_pmic_gpio.c     |    2 +-
 drivers/gpio/Kconfig                               |   11 +
 drivers/gpio/Makefile                              |    1 +
 drivers/gpio/gpio-intel-mid.c                      | 1063 +++++++++++++++++++-
 drivers/gpio/gpio-pca953x.c                        |  151 ++-
 drivers/gpio/gpiodebug.c                           |  540 ++++++++++
 drivers/gpio/gpiodebug.h                           |  108 ++
 drivers/gpio/gpiolib-sysfs.c                       |   58 ++
 drivers/i2c/busses/i2c-designware-core.c           |   20 +-
 drivers/i2c/busses/i2c-designware-core.h           |    2 +-
 drivers/i2c/busses/i2c-designware-pcidrv.c         |    6 +-
 drivers/i2c/busses/i2c-designware-platdrv.c        |   55 +-
 drivers/iio/adc/iio_basincove_gpadc.c              |    2 +-
 drivers/mfd/intel_msic.c                           |    1 +
 drivers/mmc/host/sdhci-pci.c                       |    1 -
 drivers/mmc/host/sdhci.c                           |    1 -
 drivers/platform/x86/Kconfig                       |    9 +
 drivers/platform/x86/Makefile                      |    1 +
 drivers/platform/x86/intel_pmic_gpio.c             |    2 +-
 drivers/platform/x86/intel_scu_flis.c              |  747 ++++++++++++++
 drivers/pwm/Kconfig                                |    9 +
 drivers/pwm/Makefile                               |    1 +
 drivers/pwm/pwm-intel-mid.c                        |  404 ++++++++
 drivers/tty/serial/mfd.h                           |    2 +-
 include/linux/gpio/driver.h                        |    3 +
 include/linux/lnw_gpio.h                           |    2 +-
 include/trace/mfd_trace.h                          |  197 ++++
 35 files changed, 3456 insertions(+), 206 deletions(-)
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_gpio_keys.h
 create mode 100644 drivers/gpio/gpiodebug.c
 create mode 100644 drivers/gpio/gpiodebug.h
 create mode 100644 drivers/platform/x86/intel_scu_flis.c
 create mode 100644 drivers/pwm/pwm-intel-mid.c
 create mode 100644 include/trace/mfd_trace.h

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 9d1c7c8..ce5aa02 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -448,6 +448,7 @@ config X86_INTEL_MID
 	depends on PCI_GOANY
 	depends on X86_IO_APIC
 	select SFI
+	select ARCH_HAVE_CUSTOM_GPIO_H
 	select I2C
 	select DW_APB_TIMER
 	select APB_TIMER
@@ -461,6 +462,35 @@ config X86_INTEL_MID
 	  Intel MID platforms are based on an Intel processor and chipset which
 	  consume less power than most of the x86 derivatives.
 
+config ATOM_SOC_POWER
+	bool "Select Atom SOC Power"
+
+choice
+	prompt "Select PMU support"
+	depends on ATOM_SOC_POWER
+	default REMOVEME_INTEL_ATOM_MDFLD_POWER
+
+config REMOVEME_INTEL_ATOM_MDFLD_POWER
+	bool "Medfield"
+
+config REMOVEME_INTEL_ATOM_CLV_POWER
+	bool "Clovertrail"
+
+config REMOVEME_INTEL_ATOM_MRFLD_POWER
+	bool "Merrifield"
+
+endchoice
+
+config INTEL_DEBUG_FEATURE
+       bool "Debug feature interface on Intel MID platform"
+       depends on X86_INTEL_MID
+       ---help---
+         Provides an interface to list the debug features
+	 that are enabled on an Intel MID platform. The
+	 enabling of the debug features depends on the mode
+	 the device is in (e.g. manufacturing, production,
+	 end user, etc...).
+
 config X86_INTEL_QUARK
 	bool "Intel Quark platform support"
 	depends on X86_32
@@ -752,6 +782,16 @@ config APB_TIMER
          as it is off-chip. APB timers are always running regardless of CPU
          C states, they are used as per CPU clockevent device when possible.
 
+config ARCH_NR_GPIO
+	int
+	depends on ARCH_HAVE_CUSTOM_GPIO_H
+	default 512 if X86_INTEL_MID
+	default 0
+	help
+	  Maximum number of GPIOs in the system.
+
+	  If unsure, leave the default value.
+
 # Mark as expert because too many people got it wrong.
 # The code disables itself when not needed.
 config DMI
diff --git a/arch/x86/include/asm/gpio.h b/arch/x86/include/asm/gpio.h
index b3799d8..131c96d 100644
--- a/arch/x86/include/asm/gpio.h
+++ b/arch/x86/include/asm/gpio.h
@@ -1,4 +1,27 @@
+#ifndef _ARCH_X86_GPIO_H
+#define _ARCH_X86_GPIO_H
+
+#if CONFIG_ARCH_HAVE_CUSTOM_GPIO_H
+
+#if CONFIG_ARCH_NR_GPIO > 0
+#define ARCH_NR_GPIOS CONFIG_ARCH_NR_GPIO
+#endif
+
+#include <asm-generic/gpio.h>
+
+/* The trivial gpiolib dispatchers */
+#define gpio_get_value	__gpio_get_value
+#define gpio_set_value	__gpio_set_value
+#define gpio_cansleep	__gpio_cansleep
+#define gpio_to_irq	__gpio_to_irq
+
+#else /* ! CONFIG_ARCH_HAVE_CUSTOM_GPIO_H */
+
 #ifndef __LINUX_GPIO_H
 #warning Include linux/gpio.h instead of asm/gpio.h
 #include <linux/gpio.h>
 #endif
+
+#endif /* ! CONFIG_ARCH_HAVE_CUSTOM_GPIO_H */
+
+#endif /* _ARCH_X86_GPIO_H */
diff --git a/arch/x86/include/asm/intel_scu_ipc.h b/arch/x86/include/asm/intel_scu_ipc.h
index 925b605..db21834 100644
--- a/arch/x86/include/asm/intel_scu_ipc.h
+++ b/arch/x86/include/asm/intel_scu_ipc.h
@@ -2,53 +2,91 @@
 #define  _ASM_X86_INTEL_SCU_IPC_H_
 
 #include <linux/notifier.h>
+#include <asm/intel-mid.h>
 
+/* IPC defines the following message types */
+#define IPCMSG_GET_HOBADDR	0xE5 /* OSHOB access. */
+#define IPCMSG_BATTERY          0xEF /* Coulomb Counter Accumulator */
+#define IPCMSG_MIP_ACCESS       0xEC /* IA MIP access */
+#define IPCMSG_PMDB_CMD		0xE0
 #define IPCMSG_WARM_RESET	0xF0
 #define IPCMSG_COLD_RESET	0xF1
 #define IPCMSG_SOFT_RESET	0xF2
 #define IPCMSG_COLD_BOOT	0xF3
-
+#define IPCMSG_COLD_OFF		0x80 /* for TNG only */
+#define IPCMSG_FW_REVISION      0xF4 /* Get firmware revision */
+#define IPCMSG_SHIM_CONFIG	0xF5 /* Configure SHIM */
+#define IPCMSG_WATCHDOG_TIMER   0xF8 /* Set Kernel Watchdog Threshold */
 #define IPCMSG_VRTC		0xFA	 /* Set vRTC device */
-	/* Command id associated with message IPCMSG_VRTC */
-	#define IPC_CMD_VRTC_SETTIME      1 /* Set time */
-	#define IPC_CMD_VRTC_SETALARM     2 /* Set alarm */
-
-/* Read single register */
-int intel_scu_ipc_ioread8(u16 addr, u8 *data);
-
-/* Read two sequential registers */
-int intel_scu_ipc_ioread16(u16 addr, u16 *data);
-
-/* Read four sequential registers */
-int intel_scu_ipc_ioread32(u16 addr, u32 *data);
+#define IPCMSG_FW_UPDATE        0xFE /* Firmware update */
+#define IPCMSG_PCNTRL           0xFF /* Power controller unit read/write */
+#define IPCMSG_OSC_CLK		0xE6 /* Turn on/off osc clock */
+#define IPCMSG_S0IX_COUNTER	0xEB /* Get S0ix residency */
+#define IPCMSG_CLEAR_FABERROR	0xE3 /* Clear fabric error log */
+#define IPCMSG_STORE_NV_DATA	0xCD /* Store the Non Volatile data to RAM */
+
+#define IPC_CMD_UMIP_RD     0
+#define IPC_CMD_UMIP_WR     1
+#define IPC_CMD_SMIP_RD     2
+
+/* Command id associated with message IPCMSG_PCNTRL */
+#define IPC_CMD_PCNTRL_W      0 /* Register write */
+#define IPC_CMD_PCNTRL_R      1 /* Register read */
+#define IPC_CMD_PCNTRL_M      2 /* Register read-modify-write */
+
+#define IPC_ERR_NONE			0
+#define IPC_ERR_CMD_NOT_SUPPORTED	1
+#define IPC_ERR_CMD_NOT_SERVICED	2
+#define IPC_ERR_UNABLE_TO_SERVICE	3
+#define IPC_ERR_CMD_INVALID		4
+#define IPC_ERR_CMD_FAILED		5
+#define IPC_ERR_EMSECURITY		6
+#define IPC_ERR_UNSIGNEDKERNEL		7
+
+#define MSIC_DEBUG_FILE "msic"
+#define MSIC_ALL_DEBUG_FILE "msic_all"
+#define MAX_MSIC_REG   0x3FF
+#define MIN_MSIC_REG   0x0
+
+
+
+/* Command id associated with message IPCMSG_VRTC */
+#define IPC_CMD_VRTC_SETTIME      1 /* Set time */
+#define IPC_CMD_VRTC_SETALARM     2 /* Set alarm */
+#define IPC_CMD_VRTC_SYNC_RTC     3 /* Sync MSIC/PMIC RTC to VRTC */
+
+/* Command id associated with message IPCMSG_SHIM_CONFIG */
+#define IPC_CMD_SHIM_RD		0 /* SHIM read */
+#define IPC_CMD_SHIM_WR		1 /* SHIM write */
+
+/* check ipc status */
+int intel_scu_ipc_check_status(void);
 
-/* Read a vector */
-int intel_scu_ipc_readv(u16 *addr, u8 *data, int len);
-
-/* Write single register */
-int intel_scu_ipc_iowrite8(u16 addr, u8 data);
-
-/* Write two sequential registers */
-int intel_scu_ipc_iowrite16(u16 addr, u16 data);
+/* I2C control api */
+int intel_scu_ipc_i2c_cntrl(u32 addr, u32 *data);
 
-/* Write four sequential registers */
-int intel_scu_ipc_iowrite32(u16 addr, u32 data);
+/* Update FW version */
+int intel_scu_ipc_fw_update(void);
+int intel_scu_ipc_mrstfw_update(u8 *buffer, u32 length);
+int intel_scu_ipc_medfw_prepare(void __user *arg);
 
-/* Write a vector */
-int intel_scu_ipc_writev(u16 *addr, u8 *data, int len);
+int intel_scu_ipc_read_mip(u8 *data, int len, int offset, int issigned);
+int intel_scu_ipc_write_umip(u8 *data, int len, int offset);
 
-/* Update single register based on the mask */
-int intel_scu_ipc_update_register(u16 addr, u8 data, u8 mask);
+/* NVRAM access */
+u32 intel_scu_ipc_get_nvram_size(void);
+u32 intel_scu_ipc_get_nvram_addr(void);
 
 /* Issue commands to the SCU with or without data */
 int intel_scu_ipc_simple_command(int cmd, int sub);
-int intel_scu_ipc_command(int cmd, int sub, u32 *in, int inlen,
-							u32 *out, int outlen);
-/* I2C control api */
-int intel_scu_ipc_i2c_cntrl(u32 addr, u32 *data);
 
-/* Update FW version */
-int intel_scu_ipc_fw_update(u8 *buffer, u32 length);
+/* Penwell has 4 osc clocks */
+#define OSC_CLK_AUDIO	0	/* Audio */
+#define OSC_CLK_CAM0	1	/* Primary camera */
+#define OSC_CLK_CAM1	2	/* Secondary camera */
+#define OSC_CLK_DISP	3	/* Display buffer */
+
+int intel_scu_ipc_osc_clk(u8 clk, unsigned int khz);
 
 extern struct blocking_notifier_head intel_scu_notifier;
 
diff --git a/arch/x86/platform/intel-mid/device_libs/pci/platform_sdhci_pci.c b/arch/x86/platform/intel-mid/device_libs/pci/platform_sdhci_pci.c
index fecc0be..89e0af2 100644
--- a/arch/x86/platform/intel-mid/device_libs/pci/platform_sdhci_pci.c
+++ b/arch/x86/platform/intel-mid/device_libs/pci/platform_sdhci_pci.c
@@ -321,7 +321,7 @@ static int mrfl_sd_setup(struct sdhci_pci_data *data)
 	 * But, anyway, just do it here in case IA firmware
 	 * forget to do so.
 	 */
-	/*lnw_gpio_set_alt(MRFLD_GPIO_SDIO_0_CD, 0);*/
+	intel_mid_gpio_set_alt(MRFLD_GPIO_SDIO_0_CD, 0);
 
 	err = intel_scu_ipc_ioread8(MRFLD_PMIC_VLDOCNT, &vldocnt);
 	if (err) {
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_dw_i2c.c b/arch/x86/platform/intel-mid/device_libs/platform_dw_i2c.c
index 9f1822d..c379d50 100644
--- a/arch/x86/platform/intel-mid/device_libs/platform_dw_i2c.c
+++ b/arch/x86/platform/intel-mid/device_libs/platform_dw_i2c.c
@@ -66,8 +66,8 @@ int intel_mid_dw_i2c_abort(int busnum)
 			busnum, pins->scl_gpio, pins->sda_gpio);
 	gpio_request(pins->scl_gpio, "scl");
 	gpio_request(pins->sda_gpio, "sda");
-	lnw_gpio_set_alt(pins->scl_gpio, LNW_GPIO);
-	lnw_gpio_set_alt(pins->sda_gpio, LNW_GPIO);
+	intel_mid_gpio_set_alt(pins->scl_gpio, LNW_GPIO);
+	intel_mid_gpio_set_alt(pins->sda_gpio, LNW_GPIO);
 	gpio_direction_input(pins->scl_gpio);
 	gpio_direction_input(pins->sda_gpio);
 	usleep_range(10, 10);
@@ -102,8 +102,8 @@ int intel_mid_dw_i2c_abort(int busnum)
 	gpio_set_value(pins->scl_gpio, 1);
 	usleep_range(10, 20);
 	gpio_set_value(pins->sda_gpio, 0);
-	lnw_gpio_set_alt(pins->scl_gpio, pins->scl_alt);
-	lnw_gpio_set_alt(pins->sda_gpio, pins->sda_alt);
+	intel_mid_gpio_set_alt(pins->scl_gpio, pins->scl_alt);
+	intel_mid_gpio_set_alt(pins->sda_gpio, pins->sda_alt);
 	usleep_range(10, 10);
 	gpio_free(pins->scl_gpio);
 	gpio_free(pins->sda_gpio);
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_gpio_keys.c b/arch/x86/platform/intel-mid/device_libs/platform_gpio_keys.c
index dccae6b..0ee3ba4 100644
--- a/arch/x86/platform/intel-mid/device_libs/platform_gpio_keys.c
+++ b/arch/x86/platform/intel-mid/device_libs/platform_gpio_keys.c
@@ -17,6 +17,7 @@
 #include <linux/gpio_keys.h>
 #include <linux/platform_device.h>
 #include <asm/intel-mid.h>
+#include "platform_gpio_keys.h"
 
 #define DEVICE_NAME "gpio-keys"
 
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_gpio_keys.h b/arch/x86/platform/intel-mid/device_libs/platform_gpio_keys.h
new file mode 100644
index 0000000..5095329
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_gpio_keys.h
@@ -0,0 +1,16 @@
+/*
+ * platform_gpio_keys.h: gpio_keys platform data header file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_GPIO_KEYS_H_
+#define _PLATFORM_GPIO_KEYS_H_
+
+#define DEVICE_NAME "gpio-keys"
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_msic_gpio.c b/arch/x86/platform/intel-mid/device_libs/platform_msic_gpio.c
index 2a4f7b1..1b11038 100644
--- a/arch/x86/platform/intel-mid/device_libs/platform_msic_gpio.c
+++ b/arch/x86/platform/intel-mid/device_libs/platform_msic_gpio.c
@@ -1,8 +1,8 @@
 /*
  * platform_msic_gpio.c: MSIC GPIO platform data initilization file
  *
- * (C) Copyright 2013 Intel Corporation
- * Author: Sathyanarayanan Kuppuswamy <sathyanarayanan.kuppuswamy@intel.com>
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -12,37 +12,68 @@
 
 #include <linux/kernel.h>
 #include <linux/interrupt.h>
-#include <linux/scatterlist.h>
-#include <linux/sfi.h>
 #include <linux/init.h>
 #include <linux/gpio.h>
 #include <linux/mfd/intel_msic.h>
 #include <asm/intel-mid.h>
-
+#include <linux/platform_data/intel_mid_remoteproc.h>
 #include "platform_msic.h"
-#include "platform_ipc.h"
+#include "platform_msic_gpio.h"
 
-static void __init *msic_gpio_platform_data(void *info)
+void __init *msic_gpio_platform_data(void *info)
 {
+	struct platform_device *pdev = NULL;
+	struct sfi_device_table_entry *entry = info;
 	static struct intel_msic_gpio_pdata msic_gpio_pdata;
+	int ret;
+	int gpio;
+	struct resource res;
+
+	pdev = platform_device_alloc(MSIC_GPIO_DEVICE_NAME, -1);
 
-	int gpio = get_gpio_by_name("msic_gpio_base");
+	if (!pdev) {
+		pr_err("out of memory for SFI platform dev %s\n",
+					MSIC_GPIO_DEVICE_NAME);
+		return NULL;
+	}
+
+	gpio = get_gpio_by_name("msic_gpio_base");
 
 	if (gpio < 0)
 		return NULL;
 
+	/* Basincove PMIC GPIO has total 8 GPIO pins,
+	 * GPIO[5:2,0] support 1.8V, GPIO[7:6,1] support 1.8V and 3.3V,
+	 * We group GPIO[5:2] to low voltage and GPIO[7:6] to
+	 * high voltage. Because the CTL registers are contiguous,
+	 * this grouping method doesn't affect the driver usage but
+	 * easy for the driver sharing among multiple platforms.
+	 */
+	msic_gpio_pdata.ngpio_lv = 6;
+	msic_gpio_pdata.ngpio_hv = 2;
+	msic_gpio_pdata.gpio0_lv_ctlo = 0x7E;
+	msic_gpio_pdata.gpio0_lv_ctli = 0x8E;
+	msic_gpio_pdata.gpio0_hv_ctlo = 0x84;
+	msic_gpio_pdata.gpio0_hv_ctli = 0x94;
+
+	msic_gpio_pdata.can_sleep = 1;
 	msic_gpio_pdata.gpio_base = gpio;
-	msic_pdata.gpio = &msic_gpio_pdata;
 
-	return msic_generic_platform_data(info, INTEL_MSIC_BLOCK_GPIO);
-}
+	pdev->dev.platform_data = &msic_gpio_pdata;
+
+	ret = platform_device_add(pdev);
+	if (ret) {
+		pr_err("failed to add msic gpio platform device\n");
+		platform_device_put(pdev);
+		return NULL;
+	}
 
-static const struct devs_id msic_gpio_dev_id __initconst = {
-	.name = "msic_gpio",
-	.type = SFI_DEV_TYPE_IPC,
-	.delay = 1,
-	.get_platform_data = &msic_gpio_platform_data,
-	.device_handler = &ipc_device_handler,
-};
+	res.name = "IRQ",
+	res.flags = IORESOURCE_IRQ,
+	res.start = entry->irq;
+	platform_device_add_resources(pdev, &res, 1);
 
-sfi_device(msic_gpio_dev_id);
+	register_rpmsg_service("rpmsg_msic_gpio", RPROC_SCU, RP_MSIC_GPIO);
+
+	return &msic_gpio_pdata;
+}
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_pmic_gpio.c b/arch/x86/platform/intel-mid/device_libs/platform_pmic_gpio.c
index 65c2a9a..b034716 100644
--- a/arch/x86/platform/intel-mid/device_libs/platform_pmic_gpio.c
+++ b/arch/x86/platform/intel-mid/device_libs/platform_pmic_gpio.c
@@ -21,7 +21,7 @@
 
 #include "platform_ipc.h"
 
-static void __init *pmic_gpio_platform_data(void *info)
+void __init *pmic_gpio_platform_data(void *info)
 {
 	static struct intel_pmic_gpio_platform_data pmic_gpio_pdata;
 	int gpio_base = get_gpio_by_name("pmic_gpio_base");
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index 3e72875..4b9c2a7 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -84,6 +84,17 @@ config GPIO_SYSFS
 	  Kernel drivers may also request that a particular GPIO be
 	  exported to userspace; this can be useful when debugging.
 
+config GPIODEBUG
+	tristate "GPIO Setting DEBUG"
+	depends on DEBUG_FS
+	help
+	  Say yes here to support GPIO/FLIS Setting Debug.
+
+	  This is mostly useful to dump and set gpio/flis conguration.
+
+	  Kernel drivers may also request that a particular GPIO be
+	  exported to userspace; this can be useful when debugging.
+
 config GPIO_GENERIC
 	tristate
 
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index f1d4b83..641a723 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -8,6 +8,7 @@ obj-$(CONFIG_GPIOLIB)		+= gpiolib-legacy.o
 obj-$(CONFIG_OF_GPIO)		+= gpiolib-of.o
 obj-$(CONFIG_GPIO_SYSFS)	+= gpiolib-sysfs.o
 obj-$(CONFIG_GPIO_ACPI)		+= gpiolib-acpi.o
+obj-$(CONFIG_GPIODEBUG)		+= gpiodebug.o
 
 # Device drivers. Generally keep list sorted alphabetically
 obj-$(CONFIG_GPIO_GENERIC)	+= gpio-generic.o
diff --git a/drivers/gpio/gpio-intel-mid.c b/drivers/gpio/gpio-intel-mid.c
index 4460083..88f7dc5 100644
--- a/drivers/gpio/gpio-intel-mid.c
+++ b/drivers/gpio/gpio-intel-mid.c
@@ -36,8 +36,18 @@
 #include <linux/io.h>
 #include <linux/gpio.h>
 #include <linux/slab.h>
+#include <linux/lnw_gpio.h>
 #include <linux/pm_runtime.h>
+#include <asm/intel-mid.h>
 #include <linux/irqdomain.h>
+#include <asm/intel_scu_flis.h>
+#include "gpiodebug.h"
+
+#define IRQ_TYPE_EDGE	(1 << 0)
+#define IRQ_TYPE_LEVEL	(1 << 1)
+
+#define TANGIER_I2C_FLIS_START	0x1D00
+#define TANGIER_I2C_FLIS_END	0x1D34
 
 #define INTEL_MID_IRQ_TYPE_EDGE		(1 << 0)
 #define INTEL_MID_IRQ_TYPE_LEVEL	(1 << 1)
@@ -65,6 +75,140 @@ enum GPIO_REG {
 	GFER,		/* falling edge detect */
 	GEDR,		/* edge detect result */
 	GAFR,		/* alt function */
+	GFBR = 9,	/* glitch filter bypas */
+	GPIT,		/* interrupt type */
+	GPIP = GFER,	/* level interrupt polarity */
+	GPIM = GRER,	/* level interrupt mask */
+
+	/* the following registers only exist on MRFLD */
+	GFBR_TNG = 6,
+	GIMR,		/* interrupt mask */
+	GISR,		/* interrupt source */
+	GITR = 32,	/* interrupt type */
+	GLPR = 33,	/* level-input polarity */
+};
+
+enum GPIO_CONTROLLERS {
+	LINCROFT_GPIO,
+	PENWELL_GPIO_AON,
+	PENWELL_GPIO_CORE,
+	CLOVERVIEW_GPIO_AON,
+	CLOVERVIEW_GPIO_CORE,
+	TANGIER_GPIO,
+};
+
+/* langwell gpio driver data */
+struct lnw_gpio_ddata_t {
+	u16 ngpio;		/* number of gpio pins */
+	u32 gplr_offset;	/* offset of first GPLR register from base */
+	u32 flis_base;		/* base address of FLIS registers */
+	u32 flis_len;		/* length of FLIS registers */
+	u32 (*get_flis_offset)(int gpio);
+	u32 chip_irq_type;	/* chip interrupt type */
+};
+
+struct gpio_flis_pair {
+	int gpio;	/* gpio number */
+	int offset;	/* register offset from FLIS base */
+};
+
+/*
+ * The following mapping table lists the pin and flis offset pair
+ * of some key gpio pins, the offset of other gpios can be calculated
+ * from the table.
+ */
+static struct gpio_flis_pair gpio_flis_mapping_table[] = {
+	{ 0,	0x2900 },
+	{ 12,	0x2544 },
+	{ 14,	0x0958 },
+	{ 16,	0x2D18 },
+	{ 17,	0x1D10 },
+	{ 19,	0x1D00 },
+	{ 23,	0x1D18 },
+	{ 31,	-EINVAL }, /* No GPIO 31 in pin list */
+	{ 32,	0x1508 },
+	{ 44,	0x3500 },
+	{ 64,	0x2534 },
+	{ 68,	0x2D1C },
+	{ 70,	0x1500 },
+	{ 72,	0x3D00 },
+	{ 77,	0x0D00 },
+	{ 97,	0x0954 },
+	{ 98,	-EINVAL }, /* No GPIO 98-101 in pin list */
+	{ 102,	0x1910 },
+	{ 120,	0x1900 },
+	{ 124,	0x2100 },
+	{ 136,	-EINVAL }, /* No GPIO 136 in pin list */
+	{ 137,	0x2D00 },
+	{ 143,	-EINVAL }, /* No GPIO 143-153 in pin list */
+	{ 154,	0x092C },
+	{ 164,	0x3900 },
+	{ 177,	0x2500 },
+	{ 190,	0x2D50 },
+};
+
+/*
+ * In new version of FW for Merrifield, I2C FLIS register can not
+ * be written directly but go though a IPC way which is sleepable,
+ * so we shouldn't use spin_lock_irq to protect the access when
+ * is_merr_i2c_flis() return true.
+ */
+static inline bool is_merr_i2c_flis(u32 offset)
+{
+	return ((offset >= TANGIER_I2C_FLIS_START)
+		&& (offset <= TANGIER_I2C_FLIS_END));
+}
+
+static u32 get_flis_offset_by_gpio(int gpio)
+{
+	int i;
+	int start;
+	u32 offset = -EINVAL;
+
+	for (i = 0; i < ARRAY_SIZE(gpio_flis_mapping_table) - 1; i++) {
+		if (gpio >= gpio_flis_mapping_table[i].gpio
+			&& gpio < gpio_flis_mapping_table[i + 1].gpio)
+			break;
+	}
+
+	start = gpio_flis_mapping_table[i].gpio;
+
+	if (gpio_flis_mapping_table[i].offset != -EINVAL) {
+		offset = gpio_flis_mapping_table[i].offset
+				+ (gpio - start) * 4;
+	}
+
+	return offset;
+}
+
+static struct lnw_gpio_ddata_t lnw_gpio_ddata[] = {
+	[LINCROFT_GPIO] = {
+		.ngpio = 64,
+	},
+	[PENWELL_GPIO_AON] = {
+		.ngpio = 96,
+		.chip_irq_type = IRQ_TYPE_EDGE,
+	},
+	[PENWELL_GPIO_CORE] = {
+		.ngpio = 96,
+		.chip_irq_type = IRQ_TYPE_EDGE,
+	},
+	[CLOVERVIEW_GPIO_AON] = {
+		.ngpio = 96,
+		.chip_irq_type = IRQ_TYPE_EDGE | IRQ_TYPE_LEVEL,
+	},
+	[CLOVERVIEW_GPIO_CORE] = {
+		.ngpio = 96,
+		.chip_irq_type = IRQ_TYPE_EDGE,
+	},
+	[TANGIER_GPIO] = {
+		.ngpio = 192,
+		.gplr_offset = 4,
+	        .flis_base = 0xff0c0000,
+	        .flis_len = 0x8000,
+		.get_flis_offset = get_flis_offset_by_gpio,
+		.chip_irq_type = IRQ_TYPE_EDGE | IRQ_TYPE_LEVEL,
+	},
 };
 
 /* intel_mid gpio driver data */
@@ -78,11 +222,16 @@ struct intel_mid_gpio_ddata {
 };
 
 struct intel_mid_gpio {
-	struct gpio_chip		chip;
 	void __iomem			*reg_base;
-	spinlock_t			lock;
-	struct pci_dev			*pdev;
-	struct irq_domain		*domain;
+	struct gpio_chip	chip;
+	void			*reg_gplr;
+	spinlock_t		lock;
+	struct pci_dev		*pdev;
+	struct irq_domain	*domain;
+	u32			(*get_flis_offset)(int gpio);
+	u32			chip_irq_type;
+	int			type;
+	struct gpio_debug	*debug;
 };
 
 #define to_intel_gpio_priv(chip) container_of(chip, struct intel_mid_gpio, chip)
@@ -93,8 +242,161 @@ static void __iomem *gpio_reg(struct gpio_chip *chip, unsigned offset,
 	struct intel_mid_gpio *priv = to_intel_gpio_priv(chip);
 	unsigned nreg = chip->ngpio / 32;
 	u8 reg = offset / 32;
+ 	void __iomem *ptr;
+	void *base;
+
+	/**
+	 * On TNG B0, GITR[0]'s address is 0xFF008300, while GPLR[0]'s address
+	 * is 0xFF008004. To count GITR[0]'s address, it's easier to count
+	 * from 0xFF008000. So for GITR,GLPR... we switch the base to reg_base.
+	 * This does not affect PNW/CLV, since the reg_gplr is the reg_base,
+	 * while on TNG, the reg_gplr has an offset of 0x4.
+	 */
+	base = reg_type < GITR ? priv->reg_gplr : priv->reg_base;
+	ptr = (void __iomem *)(base + reg_type * nreg * 4 + reg * 4);
+ 	return ptr;
+}
 
-	return priv->reg_base + reg_type * nreg * 4 + reg * 4;
+void intel_mid_gpio_set_alt(int gpio, int alt)
+{
+	struct intel_mid_gpio *lnw;
+	u32 __iomem *mem;
+	int reg;
+	int bit;
+	u32 offset;
+	u32 value;
+	unsigned long flags;
+
+	/* use this trick to get memio */
+	lnw = irq_get_chip_data(gpio_to_irq(gpio));
+	if (!lnw) {
+		pr_err("langwell_gpio: can not find pin %d\n", gpio);
+		return;
+	}
+	if (gpio < lnw->chip.base || gpio >= lnw->chip.base + lnw->chip.ngpio) {
+		dev_err(lnw->chip.dev, "langwell_gpio: wrong pin %d to config alt\n", gpio);
+		return;
+	}
+#if 0
+	if (lnw->irq_base + gpio - lnw->chip.base != gpio_to_irq(gpio)) {
+		dev_err(lnw->chip.dev, "langwell_gpio: wrong chip data for pin %d\n", gpio);
+		return;
+	}
+#endif
+	gpio -= lnw->chip.base;
+
+	if (lnw->type != TANGIER_GPIO) {
+		reg = gpio / 16;
+		bit = gpio % 16;
+
+		mem = gpio_reg(&lnw->chip, 0, GAFR);
+		spin_lock_irqsave(&lnw->lock, flags);
+		value = readl(mem + reg);
+		value &= ~(3 << (bit * 2));
+		value |= (alt & 3) << (bit * 2);
+		writel(value, mem + reg);
+		spin_unlock_irqrestore(&lnw->lock, flags);
+		dev_dbg(lnw->chip.dev, "ALT: writing 0x%x to %p\n",
+			value, mem + reg);
+	} else {
+		offset = lnw->get_flis_offset(gpio);
+		if (WARN(offset == -EINVAL, "invalid pin %d\n", gpio))
+			return;
+
+		if (!is_merr_i2c_flis(offset))
+			spin_lock_irqsave(&lnw->lock, flags);
+
+		value = get_flis_value(offset);
+		value &= ~7;
+		value |= (alt & 7);
+		set_flis_value(value, offset);
+
+		if (!is_merr_i2c_flis(offset))
+			spin_unlock_irqrestore(&lnw->lock, flags);
+	}
+}
+EXPORT_SYMBOL_GPL(intel_mid_gpio_set_alt);
+
+int gpio_get_alt(int gpio)
+{
+	struct intel_mid_gpio *lnw;
+	u32 __iomem *mem;
+	int reg;
+	int bit;
+	u32 value;
+	u32 offset;
+
+	 /* use this trick to get memio */
+	lnw = irq_get_chip_data(gpio_to_irq(gpio));
+	if (!lnw) {
+		pr_err("langwell_gpio: can not find pin %d\n", gpio);
+		return -1;
+	}
+	if (gpio < lnw->chip.base || gpio >= lnw->chip.base + lnw->chip.ngpio) {
+		dev_err(lnw->chip.dev,
+			"langwell_gpio: wrong pin %d to config alt\n", gpio);
+		return -1;
+	}
+#if 0
+	if (lnw->irq_base + gpio - lnw->chip.base != gpio_to_irq(gpio)) {
+		dev_err(lnw->chip.dev,
+			"langwell_gpio: wrong chip data for pin %d\n", gpio);
+		return -1;
+	}
+#endif
+	gpio -= lnw->chip.base;
+
+	if (lnw->type != TANGIER_GPIO) {
+		reg = gpio / 16;
+		bit = gpio % 16;
+
+		mem = gpio_reg(&lnw->chip, 0, GAFR);
+		value = readl(mem + reg);
+		value &= (3 << (bit * 2));
+		value >>= (bit * 2);
+	} else {
+		offset = lnw->get_flis_offset(gpio);
+		if (WARN(offset == -EINVAL, "invalid pin %d\n", gpio))
+			return -EINVAL;
+
+		value = get_flis_value(offset) & 7;
+	}
+
+	return value;
+}
+EXPORT_SYMBOL_GPL(gpio_get_alt);
+
+static int intel_mid_gpio_set_debounce(struct gpio_chip *chip, unsigned offset,
+				 unsigned debounce)
+{
+	struct intel_mid_gpio *lnw = to_intel_gpio_priv(chip);
+	void __iomem *gfbr;
+	unsigned long flags;
+	u32 value;
+	enum GPIO_REG reg_type;
+
+	reg_type = (lnw->type == TANGIER_GPIO) ? GFBR_TNG : GFBR;
+	gfbr = gpio_reg(chip, offset, reg_type);
+
+	if (lnw->pdev)
+		pm_runtime_get(&lnw->pdev->dev);
+
+	spin_lock_irqsave(&lnw->lock, flags);
+	value = readl(gfbr);
+	if (debounce) {
+		/* debounce bypass disable */
+		value &= ~BIT(offset % 32);
+	} else {
+		/* debounce bypass enable */
+		value |= BIT(offset % 32);
+	}
+	writel(value, gfbr);
+	spin_unlock_irqrestore(&lnw->lock, flags);
+
+	if (lnw->pdev)
+		pm_runtime_put(&lnw->pdev->dev);
+
+	return 0;
 }
 
 static void __iomem *gpio_reg_2bit(struct gpio_chip *chip, unsigned offset,
@@ -109,9 +411,18 @@ static void __iomem *gpio_reg_2bit(struct gpio_chip *chip, unsigned offset,
 
 static int intel_gpio_request(struct gpio_chip *chip, unsigned offset)
 {
-	void __iomem *gafr = gpio_reg_2bit(chip, offset, GAFR);
-	u32 value = readl(gafr);
-	int shift = (offset % 16) << 1, af = (value >> shift) & 3;
+	struct intel_mid_gpio *lnw = to_intel_gpio_priv(chip);
+	u32 value;
+	void __iomem *gafr;
+	int shift, af;
+
+	if (lnw->type > CLOVERVIEW_GPIO_CORE)
+		return 0;
+
+	gafr = gpio_reg_2bit(chip, offset, GAFR);
+	value = readl(gafr);
+	shift = (offset % 16) << 1;
+	af = (value >> shift) & 3;
 
 	if (af) {
 		value &= ~(3 << shift);
@@ -127,10 +438,50 @@ static int intel_gpio_get(struct gpio_chip *chip, unsigned offset)
 	return readl(gplr) & BIT(offset % 32);
 }
 
+#define PULLUP_ENABLE	(1 << 8)
+#define PULLDOWN_ENABLE	(1 << 9)
+#define PUPD_VAL_2K	(0 << 4)
+#define PUPD_VAL_20K	(1 << 4)
+#define PUPD_VAL_50K	(2 << 4)
+#define PUPD_VAL_910	(3 << 4)
+
+static int intel_mid_gpio_set_pull(struct gpio_chip *chip, unsigned gpio, int value)
+{
+	u32 flis_offset, flis_value;
+	struct intel_mid_gpio *lnw = to_intel_gpio_priv(chip);
+	unsigned long flags;
+
+	if (lnw->type != TANGIER_GPIO)
+		return 0;
+
+	flis_offset = lnw->get_flis_offset(gpio);
+	if (WARN(flis_offset == -EINVAL, "invalid pin %d\n", gpio))
+		return -EINVAL;
+	if (is_merr_i2c_flis(flis_offset))
+		return 0;
+
+	spin_lock_irqsave(&lnw->lock, flags);
+	flis_value = get_flis_value(flis_offset);
+	if (value) {
+		flis_value |= PULLUP_ENABLE;
+		flis_value &= ~PULLDOWN_ENABLE;
+	} else {
+		flis_value |= PULLDOWN_ENABLE;
+		flis_value &= ~PULLUP_ENABLE;
+	}
+	flis_value |= PUPD_VAL_50K;
+	set_flis_value(flis_value, flis_offset);
+	spin_unlock_irqrestore(&lnw->lock, flags);
+
+	return 0;
+}
+
 static void intel_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
 {
 	void __iomem *gpsr, *gpcr;
 
+	intel_mid_gpio_set_pull(chip, offset, value);
+
 	if (value) {
 		gpsr = gpio_reg(chip, offset, GPSR);
 		writel(BIT(offset % 32), gpsr);
@@ -198,8 +549,10 @@ static int intel_mid_irq_type(struct irq_data *d, unsigned type)
 	u32 gpio = irqd_to_hwirq(d);
 	unsigned long flags;
 	u32 value;
+	int ret = 0;
 	void __iomem *grer = gpio_reg(&priv->chip, gpio, GRER);
 	void __iomem *gfer = gpio_reg(&priv->chip, gpio, GFER);
+	void __iomem *gpit, *gpip;
 
 	if (gpio >= priv->chip.ngpio)
 		return -EINVAL;
@@ -207,34 +560,194 @@ static int intel_mid_irq_type(struct irq_data *d, unsigned type)
 	if (priv->pdev)
 		pm_runtime_get(&priv->pdev->dev);
 
-	spin_lock_irqsave(&priv->lock, flags);
-	if (type & IRQ_TYPE_EDGE_RISING)
-		value = readl(grer) | BIT(gpio % 32);
-	else
-		value = readl(grer) & (~BIT(gpio % 32));
-	writel(value, grer);
+	/* Chip that supports level interrupt has extra GPIT registers */
+	if (priv->chip_irq_type & IRQ_TYPE_LEVEL) {
+		switch (priv->type) {
+		case CLOVERVIEW_GPIO_AON:
+			gpit = gpio_reg(&priv->chip, gpio, GPIT);
+			gpip = gpio_reg(&priv->chip, gpio, GPIP);
+			break;
+		case TANGIER_GPIO:
+			gpit = gpio_reg(&priv->chip, gpio, GITR);
+			gpip = gpio_reg(&priv->chip, gpio, GLPR);
+			break;
+		default:
+			ret = -EINVAL;
+			goto out;
+		}
 
-	if (type & IRQ_TYPE_EDGE_FALLING)
-		value = readl(gfer) | BIT(gpio % 32);
-	else
-		value = readl(gfer) & (~BIT(gpio % 32));
-	writel(value, gfer);
-	spin_unlock_irqrestore(&priv->lock, flags);
+		spin_lock_irqsave(&priv->lock, flags);
+		if (type & IRQ_TYPE_LEVEL_MASK) {
+			/* To prevent glitches from triggering an unintended
+			 * level interrupt, configure GLPR register first
+			 * and then configure GITR.
+			 */
+			if (type & IRQ_TYPE_LEVEL_LOW)
+				value = readl(gpip) | BIT(gpio % 32);
+			else
+				value = readl(gpip) & (~BIT(gpio % 32));
+			writel(value, gpip);
+
+			value = readl(gpit) | BIT(gpio % 32);
+			writel(value, gpit);
+
+			__irq_set_handler_locked(d->irq, handle_level_irq);
+		} else if (type & IRQ_TYPE_EDGE_BOTH) {
+			value = readl(gpit) & (~BIT(gpio % 32));
+			writel(value, gpit);
+
+			if (type & IRQ_TYPE_EDGE_RISING)
+				value = readl(grer) | BIT(gpio % 32);
+			else
+				value = readl(grer) & (~BIT(gpio % 32));
+			writel(value, grer);
+
+			if (type & IRQ_TYPE_EDGE_FALLING)
+				value = readl(gfer) | BIT(gpio % 32);
+			else
+				value = readl(gfer) & (~BIT(gpio % 32));
+			writel(value, gfer);
+
+			__irq_set_handler_locked(d->irq, handle_edge_irq);
+		}
+		spin_unlock_irqrestore(&priv->lock, flags);
+	} else {
+		if (type & IRQ_TYPE_LEVEL_MASK) {
+			ret = -EINVAL;
+		} else if (type & IRQ_TYPE_EDGE_BOTH) {
+			spin_lock_irqsave(&priv->lock, flags);
+
+			if (type & IRQ_TYPE_EDGE_RISING)
+				value = readl(grer) | BIT(gpio % 32);
+			else
+				value = readl(grer) & (~BIT(gpio % 32));
+			writel(value, grer);
+
+			if (type & IRQ_TYPE_EDGE_FALLING)
+				value = readl(gfer) | BIT(gpio % 32);
+			else
+				value = readl(gfer) & (~BIT(gpio % 32));
+			writel(value, gfer);
+
+			spin_unlock_irqrestore(&priv->lock, flags);
+		}
+	}
+ 
+out:
 
 	if (priv->pdev)
 		pm_runtime_put(&priv->pdev->dev);
 
+	return ret;
+}
+
+static int lnw_set_maskunmask(struct irq_data *d, enum GPIO_REG reg_type,
+				unsigned unmask)
+{
+	struct intel_mid_gpio *lnw = irq_data_get_irq_chip_data(d);
+	u32 gpio = irqd_to_hwirq(d);
+	unsigned long flags;
+	u32 value;
+	void __iomem *gp_reg;
+
+	gp_reg = gpio_reg(&lnw->chip, gpio, reg_type);
+
+	spin_lock_irqsave(&lnw->lock, flags);
+
+	if (unmask) {
+		/* enable interrupt from GPIO input pin */
+		value = readl(gp_reg) | BIT(gpio % 32);
+	} else {
+		/* disable interrupt from GPIO input pin */
+		value = readl(gp_reg) & (~BIT(gpio % 32));
+	}
+
+	writel(value, gp_reg);
+
+	spin_unlock_irqrestore(&lnw->lock, flags);
+
 	return 0;
 }
 
 static void intel_mid_irq_unmask(struct irq_data *d)
 {
+	struct intel_mid_gpio *lnw = irq_data_get_irq_chip_data(d);
+	u32 gpio = irqd_to_hwirq(d);
+	void __iomem *gpit;
+
+	if (gpio >= lnw->chip.ngpio)
+		return;
+
+	switch (lnw->type) {
+	case CLOVERVIEW_GPIO_AON:
+		gpit = gpio_reg(&lnw->chip, gpio, GPIT);
+
+		/* if it's level trigger, unmask GPIM */
+		if (readl(gpit) & BIT(gpio % 32))
+			lnw_set_maskunmask(d, GPIM, 1);
+
+		break;
+	case TANGIER_GPIO:
+		lnw_set_maskunmask(d, GIMR, 1);
+		break;
+	default:
+		break;
+	}
 }
 
 static void intel_mid_irq_mask(struct irq_data *d)
 {
+	struct intel_mid_gpio *lnw = irq_data_get_irq_chip_data(d);
+	u32 gpio = irqd_to_hwirq(d);
+	void __iomem *gpit;
+
+	if (gpio >= lnw->chip.ngpio)
+		return;
+
+	switch (lnw->type) {
+	case CLOVERVIEW_GPIO_AON:
+		gpit = gpio_reg(&lnw->chip, gpio, GPIT);
+
+		/* if it's level trigger, mask GPIM */
+		if (readl(gpit) & BIT(gpio % 32))
+			lnw_set_maskunmask(d, GPIM, 0);
+
+		break;
+	case TANGIER_GPIO:
+		lnw_set_maskunmask(d, GIMR, 0);
+		break;
+	default:
+		break;
+	}
 }
 
+static int lwn_irq_set_wake(struct irq_data *d, unsigned on)
+{
+	return 0;
+}
+
+static void lnw_irq_ack(struct irq_data *d)
+{
+}
+
+static void lnw_irq_shutdown(struct irq_data *d)
+{
+	struct intel_mid_gpio *lnw = irq_data_get_irq_chip_data(d);
+	u32 gpio = irqd_to_hwirq(d);
+	unsigned long flags;
+	u32 value;
+	void __iomem *grer = gpio_reg(&lnw->chip, gpio, GRER);
+	void __iomem *gfer = gpio_reg(&lnw->chip, gpio, GFER);
+
+	spin_lock_irqsave(&lnw->lock, flags);
+	value = readl(grer) & (~BIT(gpio % 32));
+	writel(value, grer);
+	value = readl(gfer) & (~BIT(gpio % 32));
+	writel(value, gfer);
+	spin_unlock_irqrestore(&lnw->lock, flags);
+};
+
+
 static int intel_mid_irq_reqres(struct irq_data *d)
 {
 	struct intel_mid_gpio *priv = irq_data_get_irq_chip_data(d);
@@ -257,9 +770,13 @@ static void intel_mid_irq_relres(struct irq_data *d)
 
 static struct irq_chip intel_mid_irqchip = {
 	.name		= "INTEL_MID-GPIO",
+	.flags		= IRQCHIP_SET_TYPE_MASKED,
 	.irq_mask	= intel_mid_irq_mask,
 	.irq_unmask	= intel_mid_irq_unmask,
 	.irq_set_type	= intel_mid_irq_type,
+	.irq_set_wake	= lwn_irq_set_wake,
+	.irq_ack	= lnw_irq_ack,
+	.irq_shutdown	= lnw_irq_shutdown,
 	.irq_request_resources = intel_mid_irq_reqres,
 	.irq_release_resources = intel_mid_irq_relres,
 };
@@ -293,40 +810,41 @@ static const struct intel_mid_gpio_ddata gpio_tangier = {
 	.gplr_offset = 4,
 	.flis_base = 0xff0c0000,
 	.flis_len = 0x8000,
-	.get_flis_offset = NULL,
-	.chip_irq_type = INTEL_MID_IRQ_TYPE_EDGE,
+	.get_flis_offset = get_flis_offset_by_gpio,
+	.chip_irq_type = INTEL_MID_IRQ_TYPE_EDGE | INTEL_MID_IRQ_TYPE_LEVEL,
 };
 
 static const struct pci_device_id intel_gpio_ids[] = {
 	{
 		/* Lincroft */
 		PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x080f),
-		.driver_data = (kernel_ulong_t)&gpio_lincroft,
+		.driver_data = LINCROFT_GPIO,
 	},
 	{
 		/* Penwell AON */
 		PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x081f),
-		.driver_data = (kernel_ulong_t)&gpio_penwell_aon,
+		.driver_data = PENWELL_GPIO_AON,
 	},
 	{
 		/* Penwell Core */
 		PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x081a),
-		.driver_data = (kernel_ulong_t)&gpio_penwell_core,
+		.driver_data = PENWELL_GPIO_CORE,
 	},
 	{
 		/* Cloverview Aon */
 		PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x08eb),
-		.driver_data = (kernel_ulong_t)&gpio_cloverview_aon,
+		.driver_data = CLOVERVIEW_GPIO_AON,
 	},
 	{
 		/* Cloverview Core */
 		PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x08f7),
-		.driver_data = (kernel_ulong_t)&gpio_cloverview_core,
+		.driver_data = CLOVERVIEW_GPIO_CORE,
 	},
 	{
 		/* Tangier */
 		PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x1199),
-		.driver_data = (kernel_ulong_t)&gpio_tangier,
+		/*.driver_data = (kernel_ulong_t)&gpio_tangier,*/
+		.driver_data = TANGIER_GPIO,
 	},
 	{ 0 }
 };
@@ -337,26 +855,442 @@ static void intel_mid_irq_handler(unsigned irq, struct irq_desc *desc)
 	struct irq_data *data = irq_desc_get_irq_data(desc);
 	struct intel_mid_gpio *priv = irq_data_get_irq_handler_data(data);
 	struct irq_chip *chip = irq_data_get_irq_chip(data);
+	struct gpio_debug *debug;
 	u32 base, gpio, mask;
 	unsigned long pending;
-	void __iomem *gedr;
+	void __iomem *gp_reg;
+	enum GPIO_REG reg_type;
+	struct irq_desc *lnw_irq_desc;
+	unsigned int lnw_irq;
+
+	debug = priv->debug;
+
+	reg_type = (priv->type == TANGIER_GPIO) ? GISR : GEDR;
 
 	/* check GPIO controller to check which pin triggered the interrupt */
 	for (base = 0; base < priv->chip.ngpio; base += 32) {
-		gedr = gpio_reg(&priv->chip, base, GEDR);
-		while ((pending = readl(gedr))) {
+		gp_reg = gpio_reg(&priv->chip, base, reg_type);
+		while ((pending = (priv->type != TANGIER_GPIO) ?
+			readl(gp_reg) :
+			(readl(gp_reg) &
+			readl(gpio_reg(&priv->chip, base, GIMR))))) {
 			gpio = __ffs(pending);
+			DEFINE_DEBUG_IRQ_CONUNT_INCREASE(priv->chip.base +
+				base + gpio);
+			/* Mask irq if not requested in kernel */
+			lnw_irq = irq_find_mapping(priv->domain, base + gpio);
+			lnw_irq_desc = irq_to_desc(lnw_irq);
+			if (lnw_irq_desc && unlikely(!lnw_irq_desc->action)) {
+				intel_mid_irq_mask(&lnw_irq_desc->irq_data);
+				continue;
+			}
+
 			mask = BIT(gpio);
 			/* Clear before handling so we can't lose an edge */
-			writel(mask, gedr);
-			generic_handle_irq(irq_find_mapping(priv->domain,
-							    base + gpio));
+			writel(mask, gp_reg);
+			generic_handle_irq(lnw_irq);
 		}
 	}
 
 	chip->irq_eoi(data);
 }
 
+static char conf_reg_msg[] =
+	"\nGPIO configuration register:\n"
+	"\t[ 2: 0]\tpinmux\n"
+	"\t[ 6: 4]\tpull strength\n"
+	"\t[ 8: 8]\tpullup enable\n"
+	"\t[ 9: 9]\tpulldown enable\n"
+	"\t[10:10]\tslew A, B setting\n"
+	"\t[12:12]\toverride input enable\n"
+	"\t[13:13]\toverride input enable enable\n"
+	"\t[14:14]\toverride output enable\n"
+	"\t[15:15]\toverride output enable enable\n"
+	"\t[16:16]\toverride input value\n"
+	"\t[17:17]\tenable input data override\n"
+	"\t[18:18]\toverride output value\n"
+	"\t[19:19]\tenable output data override\n"
+	"\t[21:21]\topen drain enable\n"
+	"\t[22:22]\tenable OVR_IOSTBY_VAL\n"
+	"\t[23:23]\tOVR_IOSTBY_VAL\n"
+	"\t[24:24]\tSBY_OUTDATAOV_EN\n"
+	"\t[25:25]\tSBY_INDATAOV_EN\n"
+	"\t[26:26]\tSBY_OVOUTEN_EN\n"
+	"\t[27:27]\tSBY_OVINEN_EN\n"
+	"\t[29:28]\tstandby pullmode\n"
+	"\t[30:30]\tstandby open drain mode\n";
+
+static char *pinvalue[] = {"low", "high"};
+static char *pindirection[] = {"in", "out"};
+static char *irqtype[] = {"irq_none", "edge_rising", "edge_falling",
+			"edge_both"};
+static char *pinmux[] = {"mode0", "mode1", "mode2", "mode3", "mode4", "mode5",
+			"mode6", "mode7"};
+static char *pullmode[] = {"nopull", "pullup", "pulldown"};
+static char *pullstrength[] = {"2k", "20k", "50k", "910ohms"};
+static char *enable[] = {"disable", "enable"};
+static char *override_direction[] = {"no-override", "override-enable",
+			"override-disable"};
+static char *override_value[] = {"no-override", "override-high",
+			"override-low"};
+static char *standby_trigger[] = {"no-override", "override-trigger",
+			"override-notrigger"};
+static char *standby_pupd_state[] = {"keep", "pulldown", "pullup", "nopull"};
+
+static int gpio_get_pinvalue(struct gpio_control *control, void *private_data,
+		unsigned gpio)
+{
+	struct intel_mid_gpio *lnw = private_data;
+	u32 value;
+
+	value = intel_gpio_get(&lnw->chip, gpio);
+
+	return value ? 1 : 0;
+}
+
+static int gpio_set_pinvalue(struct gpio_control *control, void *private_data,
+		unsigned gpio, unsigned int num)
+{
+	struct intel_mid_gpio *lnw = private_data;
+
+	intel_gpio_set(&lnw->chip, gpio, num);
+	return 0;
+}
+
+static int gpio_get_normal(struct gpio_control *control, void *private_data,
+		unsigned gpio)
+{
+	struct intel_mid_gpio *lnw = private_data;
+	u32 __iomem *mem;
+	u32 value;
+
+	mem = gpio_reg(&lnw->chip, gpio, control->reg);
+
+	value = readl(mem);
+	value &= BIT(gpio % 32);
+
+	if (control->invert)
+		return value ? 0 : 1;
+	else
+		return value ? 1 : 0;
+}
+
+static int gpio_set_normal(struct gpio_control *control, void *private_data,
+		unsigned gpio, unsigned int num)
+{
+	struct intel_mid_gpio *lnw = private_data;
+	u32 __iomem *mem;
+	u32 value;
+	unsigned long flags;
+
+	mem = gpio_reg(&lnw->chip, gpio, control->reg);
+
+	spin_lock_irqsave(&lnw->lock, flags);
+	value = readl(mem);
+	value &= ~BIT(gpio % 32);
+	if (control->invert) {
+		if (num)
+			value &= ~BIT(gpio % 32);
+		else
+			value |= BIT(gpio % 32);
+	} else {
+		if (num)
+			value |= BIT(gpio % 32);
+		else
+			value &= ~BIT(gpio % 32);
+	}
+	writel(value, mem);
+	spin_unlock_irqrestore(&lnw->lock, flags);
+
+	return 0;
+}
+
+static int gpio_get_irqtype(struct gpio_control *control, void *private_data,
+		unsigned gpio)
+{
+	struct intel_mid_gpio *lnw = private_data;
+	void __iomem *grer = gpio_reg(&lnw->chip, gpio, GRER);
+	void __iomem *gfer = gpio_reg(&lnw->chip, gpio, GFER);
+	u32 value;
+	int num;
+
+	value = readl(grer) & BIT(gpio % 32);
+	num = value ? 1 : 0;
+	value = readl(gfer) & BIT(gpio % 32);
+	if (num)
+		num = value ? 3 : 1;
+	else
+		num = value ? 2 : 0;
+
+	return num;
+}
+
+static int flis_get_normal(struct gpio_control *control, void *private_data,
+		unsigned gpio)
+{
+	struct intel_mid_gpio *lnw = private_data;
+	u32 offset, value;
+	int num;
+
+	if (lnw->type == TANGIER_GPIO) {
+		offset = lnw->get_flis_offset(gpio);
+		if (WARN(offset == -EINVAL, "invalid pin %d\n", gpio))
+			return -1;
+
+		value = get_flis_value(offset);
+		num = (value >> control->shift) & control->mask;
+		if (num < control->num)
+			return num;
+	}
+
+	return -1;
+}
+
+static int flis_set_normal(struct gpio_control *control, void *private_data,
+		unsigned gpio, unsigned int num)
+{
+	struct intel_mid_gpio *lnw = private_data;
+	u32 shift = control->shift;
+	u32 mask = control->mask;
+	u32 offset, value;
+	unsigned long flags;
+
+	if (lnw->type == TANGIER_GPIO) {
+		offset = lnw->get_flis_offset(gpio);
+		if (WARN(offset == -EINVAL, "invalid pin %d\n", gpio))
+			return -1;
+
+		if (!is_merr_i2c_flis(offset))
+			spin_lock_irqsave(&lnw->lock, flags);
+		value = get_flis_value(offset);
+		value &= ~(mask << shift);
+		value |= ((num & mask) << shift);
+		set_flis_value(value, offset);
+		if (!is_merr_i2c_flis(offset))
+			spin_unlock_irqrestore(&lnw->lock, flags);
+		return 0;
+	}
+
+	return -1;
+}
+
+static int flis_get_override(struct gpio_control *control, void *private_data,
+		unsigned gpio)
+{
+	struct intel_mid_gpio *lnw = private_data;
+	u32 offset, value;
+	u32 val_bit, en_bit;
+	int num;
+
+	if (lnw->type == TANGIER_GPIO) {
+		offset = lnw->get_flis_offset(gpio);
+		if (WARN(offset == -EINVAL, "invalid pin %d\n", gpio))
+			return -1;
+
+		val_bit = 1 << control->shift;
+		en_bit = 1 << control->rshift;
+
+		value = get_flis_value(offset);
+
+		if (value & en_bit)
+			if (value & val_bit)
+				num = 1;
+			else
+				num = 2;
+		else
+			num = 0;
+
+		return num;
+	}
+
+	return -1;
+}
+
+static int flis_set_override(struct gpio_control *control, void *private_data,
+		unsigned gpio, unsigned int num)
+{
+	struct intel_mid_gpio *lnw = private_data;
+	u32 offset, value;
+	u32 val_bit, en_bit;
+	unsigned long flags;
+
+	if (lnw->type == TANGIER_GPIO) {
+		offset = lnw->get_flis_offset(gpio);
+		if (WARN(offset == -EINVAL, "invalid pin %d\n", gpio))
+			return -1;
+
+		val_bit = 1 << control->shift;
+		en_bit = 1 << control->rshift;
+
+		if (!is_merr_i2c_flis(offset))
+			spin_lock_irqsave(&lnw->lock, flags);
+		value = get_flis_value(offset);
+		switch (num) {
+		case 0:
+			value &= ~(en_bit | val_bit);
+			break;
+		case 1:
+			value |= (en_bit | val_bit);
+			break;
+		case 2:
+			value |= en_bit;
+			value &= ~val_bit;
+			break;
+		default:
+			break;
+		}
+		set_flis_value(value, offset);
+		if (!is_merr_i2c_flis(offset))
+			spin_unlock_irqrestore(&lnw->lock, flags);
+
+		return 0;
+	}
+
+	return -1;
+}
+
+#define GPIO_VALUE_CONTROL(xtype, xinfo, xnum) \
+{	.type = xtype, .pininfo = xinfo, .num = xnum, \
+	.get = gpio_get_pinvalue, .set = gpio_set_pinvalue}
+#define GPIO_NORMAL_CONTROL(xtype, xinfo, xnum, xreg, xinvert) \
+{	.type = xtype, .pininfo = xinfo, .num = xnum, .reg = xreg, \
+	.invert = xinvert, .get = gpio_get_normal, .set = gpio_set_normal}
+#define GPIO_IRQTYPE_CONTROL(xtype, xinfo, xnum) \
+{	.type = xtype, .pininfo = xinfo, .num = xnum, \
+	.get = gpio_get_irqtype, .set = NULL}
+#define FLIS_NORMAL_CONTROL(xtype, xinfo, xnum, xshift, xmask) \
+{	.type = xtype, .pininfo = xinfo, .num = xnum, .shift = xshift, \
+	.mask = xmask, .get = flis_get_normal, .set = flis_set_normal}
+#define FLIS_OVERRIDE_CONTROL(xtype, xinfo, xnum, xshift, xrshift) \
+{	.type = xtype, .pininfo = xinfo, .num = xnum, .shift = xshift, \
+	.rshift = xrshift, .get = flis_get_override, .set = flis_set_override}
+
+static struct gpio_control intel_mid_gpio_controls[] = {
+GPIO_VALUE_CONTROL(TYPE_PIN_VALUE, pinvalue, 2),
+GPIO_NORMAL_CONTROL(TYPE_DIRECTION, pindirection, 2, GPDR, 0),
+GPIO_IRQTYPE_CONTROL(TYPE_IRQ_TYPE, irqtype, 4),
+GPIO_NORMAL_CONTROL(TYPE_DEBOUNCE, enable, 2, GFBR_TNG, 1),
+FLIS_NORMAL_CONTROL(TYPE_PINMUX, pinmux, 8, 0, 0x7),
+FLIS_NORMAL_CONTROL(TYPE_PULLSTRENGTH, pullstrength, 4, 4, 0x7),
+FLIS_NORMAL_CONTROL(TYPE_PULLMODE, pullmode, 3, 8, 0x3),
+FLIS_NORMAL_CONTROL(TYPE_OPEN_DRAIN, enable, 2, 21, 0x1),
+FLIS_OVERRIDE_CONTROL(TYPE_OVERRIDE_INDIR, override_direction, 3, 12, 13),
+FLIS_OVERRIDE_CONTROL(TYPE_OVERRIDE_OUTDIR, override_direction, 3, 14, 15),
+FLIS_OVERRIDE_CONTROL(TYPE_OVERRIDE_INVAL, override_value, 3, 16, 17),
+FLIS_OVERRIDE_CONTROL(TYPE_OVERRIDE_OUTVAL, override_value, 3, 18, 19),
+FLIS_OVERRIDE_CONTROL(TYPE_SBY_OVR_IO, standby_trigger, 3, 23, 22),
+FLIS_OVERRIDE_CONTROL(TYPE_SBY_OVR_OUTVAL, override_value, 3, 18, 24),
+FLIS_OVERRIDE_CONTROL(TYPE_SBY_OVR_INVAL, override_value, 3, 16, 25),
+FLIS_OVERRIDE_CONTROL(TYPE_SBY_OVR_OUTDIR, override_direction, 3, 14, 26),
+FLIS_OVERRIDE_CONTROL(TYPE_SBY_OVR_INDIR, override_direction, 3, 12, 27),
+FLIS_NORMAL_CONTROL(TYPE_SBY_PUPD_STATE, standby_pupd_state, 4, 28, 0x3),
+FLIS_NORMAL_CONTROL(TYPE_SBY_OD_DIS, enable, 2, 30, 0x1),
+};
+
+static unsigned int lnw_get_conf_reg(struct gpio_debug *debug, unsigned gpio)
+{
+	struct intel_mid_gpio *lnw = debug->private_data;
+	u32 offset, value = 0;
+
+	if (lnw->type == TANGIER_GPIO) {
+		offset = lnw->get_flis_offset(gpio);
+		if (WARN(offset == -EINVAL, "invalid pin %d\n", gpio))
+			return -EINVAL;
+
+		value = get_flis_value(offset);
+	}
+
+	return value;
+}
+
+static void lnw_set_conf_reg(struct gpio_debug *debug, unsigned gpio,
+		unsigned int value)
+{
+	struct intel_mid_gpio *lnw = debug->private_data;
+	u32 offset;
+
+	if (lnw->type == TANGIER_GPIO) {
+		offset = lnw->get_flis_offset(gpio);
+		if (WARN(offset == -EINVAL, "invalid pin %d\n", gpio))
+			return;
+
+		set_flis_value(value, offset);
+	}
+
+	return;
+}
+
+static char **lnw_get_avl_pininfo(struct gpio_debug *debug, unsigned gpio,
+		unsigned int type, unsigned *num)
+{
+	struct gpio_control *control;
+
+	control = find_gpio_control(intel_mid_gpio_controls,
+			ARRAY_SIZE(intel_mid_gpio_controls), type);
+	if (control == NULL)
+		return NULL;
+
+	*num = control->num;
+
+	return control->pininfo;
+}
+
+static char *lnw_get_cul_pininfo(struct gpio_debug *debug, unsigned gpio,
+		unsigned int type)
+{
+	struct intel_mid_gpio *lnw = debug->private_data;
+	struct gpio_control *control;
+	int num;
+
+	control = find_gpio_control(intel_mid_gpio_controls,
+			ARRAY_SIZE(intel_mid_gpio_controls), type);
+	if (control == NULL)
+		return NULL;
+
+	num = control->get(control, lnw, gpio);
+	if (num == -1)
+		return NULL;
+
+	return *(control->pininfo + num);
+}
+
+static void lnw_set_pininfo(struct gpio_debug *debug, unsigned gpio,
+		unsigned int type, const char *info)
+{
+	struct intel_mid_gpio *lnw = debug->private_data;
+	struct gpio_control *control;
+	int num;
+
+	control = find_gpio_control(intel_mid_gpio_controls,
+			ARRAY_SIZE(intel_mid_gpio_controls), type);
+	if (control == NULL)
+		return;
+
+	num = find_pininfo_num(control, info);
+	if (num == -1)
+		return;
+
+	if (control->set)
+		control->set(control, lnw, gpio, num);
+}
+
+static int lnw_get_register_msg(char **buf, unsigned long *size)
+{
+	*buf = conf_reg_msg;
+	*size = strlen(conf_reg_msg);
+
+	return 0;
+}
+
+static struct gpio_debug_ops intel_mid_gpio_debug_ops = {
+	.get_conf_reg = lnw_get_conf_reg,
+	.set_conf_reg = lnw_set_conf_reg,
+	.get_avl_pininfo = lnw_get_avl_pininfo,
+	.get_cul_pininfo = lnw_get_cul_pininfo,
+	.set_pininfo = lnw_set_pininfo,
+	.get_register_msg = lnw_get_register_msg,
+};
+
 static void intel_mid_irq_init_hw(struct intel_mid_gpio *priv)
 {
 	void __iomem *reg;
@@ -392,6 +1326,16 @@ static const struct irq_domain_ops intel_gpio_irq_ops = {
 	.xlate = irq_domain_xlate_twocell,
 };
 
+static int intel_mid_gpio_runtime_resume(struct device *dev)
+{
+	return 0;
+}
+
+static int intel_mid_gpio_runtime_suspend(struct device *dev)
+{
+	return 0;
+}
+
 static int intel_gpio_runtime_idle(struct device *dev)
 {
 	int err = pm_schedule_suspend(dev, 500);
@@ -399,7 +1343,9 @@ static int intel_gpio_runtime_idle(struct device *dev)
 }
 
 static const struct dev_pm_ops intel_gpio_pm_ops = {
-	SET_RUNTIME_PM_OPS(NULL, NULL, intel_gpio_runtime_idle)
+	SET_RUNTIME_PM_OPS(intel_mid_gpio_runtime_suspend,
+			   intel_mid_gpio_runtime_resume,
+			   intel_gpio_runtime_idle)
 };
 
 static int intel_gpio_probe(struct pci_dev *pdev,
@@ -407,11 +1353,15 @@ static int intel_gpio_probe(struct pci_dev *pdev,
 {
 	void __iomem *base;
 	struct intel_mid_gpio *priv;
+	struct gpio_debug *debug;
 	u32 gpio_base;
 	u32 irq_base;
 	int retval;
-	struct intel_mid_gpio_ddata *ddata =
-				(struct intel_mid_gpio_ddata *)id->driver_data;
+	struct lnw_gpio_ddata_t *ddata;
+	int pid;
+
+	pid = id->driver_data;
+	ddata = &lnw_gpio_ddata[pid];
 
 	retval = pcim_enable_device(pdev);
 	if (retval)
@@ -437,18 +1387,26 @@ static int intel_gpio_probe(struct pci_dev *pdev,
 		return -ENOMEM;
 	}
 
+	priv->type = pid;
 	priv->reg_base = pcim_iomap_table(pdev)[0];
+	priv->reg_gplr = priv->reg_base + ddata->gplr_offset;
+	priv->get_flis_offset = ddata->get_flis_offset;
+	priv->chip_irq_type = ddata->chip_irq_type;
 	priv->chip.label = dev_name(&pdev->dev);
 	priv->chip.dev = &pdev->dev;
 	priv->chip.request = intel_gpio_request;
 	priv->chip.direction_input = intel_gpio_direction_input;
 	priv->chip.direction_output = intel_gpio_direction_output;
+	priv->chip.set_pinmux = intel_mid_gpio_set_alt;
+	priv->chip.get_pinmux = gpio_get_alt;
 	priv->chip.get = intel_gpio_get;
 	priv->chip.set = intel_gpio_set;
 	priv->chip.to_irq = intel_gpio_to_irq;
 	priv->chip.base = gpio_base;
 	priv->chip.ngpio = ddata->ngpio;
 	priv->chip.can_sleep = false;
+	priv->chip.set_debounce = intel_mid_gpio_set_debounce;
+	priv->chip.dev = &pdev->dev;
 	priv->pdev = pdev;
 
 	spin_lock_init(&priv->lock);
@@ -466,13 +1424,40 @@ static int intel_gpio_probe(struct pci_dev *pdev,
 	}
 
 	intel_mid_irq_init_hw(priv);
-
 	irq_set_handler_data(pdev->irq, priv);
 	irq_set_chained_handler(pdev->irq, intel_mid_irq_handler);
 
 	pm_runtime_put_noidle(&pdev->dev);
 	pm_runtime_allow(&pdev->dev);
 
+	/* add for gpiodebug */
+	debug = gpio_debug_alloc();
+	if (debug) {
+		__set_bit(TYPE_OVERRIDE_OUTDIR, debug->typebit);
+		__set_bit(TYPE_OVERRIDE_OUTVAL, debug->typebit);
+		__set_bit(TYPE_OVERRIDE_INDIR, debug->typebit);
+		__set_bit(TYPE_OVERRIDE_INVAL, debug->typebit);
+		__set_bit(TYPE_SBY_OVR_IO, debug->typebit);
+		__set_bit(TYPE_SBY_OVR_OUTVAL, debug->typebit);
+		__set_bit(TYPE_SBY_OVR_INVAL, debug->typebit);
+		__set_bit(TYPE_SBY_OVR_OUTDIR, debug->typebit);
+		__set_bit(TYPE_SBY_OVR_INDIR, debug->typebit);
+		__set_bit(TYPE_SBY_PUPD_STATE, debug->typebit);
+		__set_bit(TYPE_SBY_OD_DIS, debug->typebit);
+
+		debug->chip = &priv->chip;
+		debug->ops = &intel_mid_gpio_debug_ops;
+		debug->private_data = priv;
+		priv->debug = debug;
+
+		retval = gpio_debug_register(debug);
+		if (retval) {
+			dev_err(&pdev->dev, "langwell gpio_debug_register failed %d\n",
+				retval);
+			gpio_debug_remove(debug);
+		}
+	}
+
 	return 0;
 }
 
@@ -490,4 +1475,4 @@ static int __init intel_gpio_init(void)
 	return pci_register_driver(&intel_gpio_driver);
 }
 
-device_initcall(intel_gpio_init);
+fs_initcall(intel_gpio_init);
diff --git a/drivers/gpio/gpio-pca953x.c b/drivers/gpio/gpio-pca953x.c
index b438237..5a24c9e 100644
--- a/drivers/gpio/gpio-pca953x.c
+++ b/drivers/gpio/gpio-pca953x.c
@@ -29,6 +29,10 @@
 #define PCA953X_INVERT		2
 #define PCA953X_DIRECTION	3
 
+#define PCAL953X_IN_LATCH	34
+#define PCAL953X_INT_MASK	37
+#define PCAL953X_INT_STAT	38
+
 #define REG_ADDR_AI		0x80
 
 #define PCA957X_IN		0
@@ -44,30 +48,34 @@
 #define PCA_INT			0x0100
 #define PCA953X_TYPE		0x1000
 #define PCA957X_TYPE		0x2000
+#define PCAL953X_TYPE		0x4000
 
 static const struct i2c_device_id pca953x_id[] = {
-	{ "pca9505", 40 | PCA953X_TYPE | PCA_INT, },
-	{ "pca9534", 8  | PCA953X_TYPE | PCA_INT, },
-	{ "pca9535", 16 | PCA953X_TYPE | PCA_INT, },
-	{ "pca9536", 4  | PCA953X_TYPE, },
-	{ "pca9537", 4  | PCA953X_TYPE | PCA_INT, },
-	{ "pca9538", 8  | PCA953X_TYPE | PCA_INT, },
-	{ "pca9539", 16 | PCA953X_TYPE | PCA_INT, },
-	{ "pca9554", 8  | PCA953X_TYPE | PCA_INT, },
-	{ "pca9555", 16 | PCA953X_TYPE | PCA_INT, },
-	{ "pca9556", 8  | PCA953X_TYPE, },
-	{ "pca9557", 8  | PCA953X_TYPE, },
-	{ "pca9574", 8  | PCA957X_TYPE | PCA_INT, },
-	{ "pca9575", 16 | PCA957X_TYPE | PCA_INT, },
-
-	{ "max7310", 8  | PCA953X_TYPE, },
-	{ "max7312", 16 | PCA953X_TYPE | PCA_INT, },
-	{ "max7313", 16 | PCA953X_TYPE | PCA_INT, },
-	{ "max7315", 8  | PCA953X_TYPE | PCA_INT, },
-	{ "pca6107", 8  | PCA953X_TYPE | PCA_INT, },
-	{ "tca6408", 8  | PCA953X_TYPE | PCA_INT, },
-	{ "tca6416", 16 | PCA953X_TYPE | PCA_INT, },
-	{ "tca6424", 24 | PCA953X_TYPE | PCA_INT, },
+	{ "pca9505",   40 | PCA953X_TYPE | PCA_INT, },
+	{ "pca9534",   8  | PCA953X_TYPE | PCA_INT, },
+	{ "pca9535",   16 | PCA953X_TYPE | PCA_INT, },
+	{ "pca9536",   4  | PCA953X_TYPE, },
+	{ "pca9537",   4  | PCA953X_TYPE | PCA_INT, },
+	{ "pca9538",   8  | PCA953X_TYPE | PCA_INT, },
+	{ "pca9539",   16 | PCA953X_TYPE | PCA_INT, },
+	{ "pca9554",   8  | PCA953X_TYPE | PCA_INT, },
+	{ "pca9555",   16 | PCA953X_TYPE | PCA_INT, },
+	{ "pca9556",   8  | PCA953X_TYPE, },
+	{ "pca9557",   8  | PCA953X_TYPE, },
+	{ "pca9574",   8  | PCA957X_TYPE | PCA_INT, },
+	{ "pca9575",   16 | PCA957X_TYPE | PCA_INT, },
+
+	{ "pcal9535a", 16 | PCAL953X_TYPE | PCA_INT, },
+	{ "pcal9555a", 16 | PCAL953X_TYPE | PCA_INT, },
+
+	{ "max7310",   8  | PCA953X_TYPE, },
+	{ "max7312",   16 | PCA953X_TYPE | PCA_INT, },
+	{ "max7313",   16 | PCA953X_TYPE | PCA_INT, },
+	{ "max7315",   8  | PCA953X_TYPE | PCA_INT, },
+	{ "pca6107",   8  | PCA953X_TYPE | PCA_INT, },
+	{ "tca6408",   8  | PCA953X_TYPE | PCA_INT, },
+	{ "tca6416",   16 | PCA953X_TYPE | PCA_INT, },
+	{ "tca6424",   24 | PCA953X_TYPE | PCA_INT, },
 	{ }
 };
 MODULE_DEVICE_TABLE(i2c, pca953x_id);
@@ -148,6 +156,7 @@ static int pca953x_write_regs(struct pca953x_chip *chip, int reg, u8 *val)
 					NBANK(chip), val);
 	} else {
 		switch (chip->chip_type) {
+		case PCAL953X_TYPE:
 		case PCA953X_TYPE:
 			ret = i2c_smbus_write_word_data(chip->client,
 							reg << 1, (u16) *val);
@@ -210,6 +219,7 @@ static int pca953x_gpio_direction_input(struct gpio_chip *gc, unsigned off)
 	reg_val = chip->reg_direction[off / BANK_SZ] | (1u << (off % BANK_SZ));
 
 	switch (chip->chip_type) {
+	case PCAL953X_TYPE:
 	case PCA953X_TYPE:
 		offset = PCA953X_DIRECTION;
 		break;
@@ -247,6 +257,7 @@ static int pca953x_gpio_direction_output(struct gpio_chip *gc,
 			& ~(1u << (off % BANK_SZ));
 
 	switch (chip->chip_type) {
+	case PCAL953X_TYPE:
 	case PCA953X_TYPE:
 		offset = PCA953X_OUTPUT;
 		break;
@@ -263,6 +274,7 @@ static int pca953x_gpio_direction_output(struct gpio_chip *gc,
 	/* then direction */
 	reg_val = chip->reg_direction[off / BANK_SZ] & ~(1u << (off % BANK_SZ));
 	switch (chip->chip_type) {
+	case PCAL953X_TYPE:
 	case PCA953X_TYPE:
 		offset = PCA953X_DIRECTION;
 		break;
@@ -291,6 +303,7 @@ static int pca953x_gpio_get_value(struct gpio_chip *gc, unsigned off)
 
 	mutex_lock(&chip->i2c_lock);
 	switch (chip->chip_type) {
+	case PCAL953X_TYPE:
 	case PCA953X_TYPE:
 		offset = PCA953X_INPUT;
 		break;
@@ -328,6 +341,7 @@ static void pca953x_gpio_set_value(struct gpio_chip *gc, unsigned off, int val)
 			& ~(1u << (off % BANK_SZ));
 
 	switch (chip->chip_type) {
+	case PCAL953X_TYPE:
 	case PCA953X_TYPE:
 		offset = PCA953X_OUTPUT;
 		break;
@@ -411,6 +425,17 @@ static void pca953x_irq_bus_sync_unlock(struct irq_data *d)
 							level + (BANK_SZ * i));
 			new_irqs &= ~(1 << level);
 		}
+
+		if (chip->chip_type == PCAL953X_TYPE) {
+			/* Enable latch on interrupt-enabled inputs */
+			pca953x_write_single(chip, PCAL953X_IN_LATCH,
+						chip->irq_mask[i],
+						BANK_SZ * i);
+			/* Unmask enabled interrupts */
+			pca953x_write_single(chip, PCAL953X_INT_MASK,
+						~chip->irq_mask[i],
+						BANK_SZ * i);
+		}
 	}
 
 	mutex_unlock(&chip->irq_lock);
@@ -459,6 +484,7 @@ static u8 pca953x_irq_pending(struct pca953x_chip *chip, u8 *pending)
 	int ret, i, offset = 0;
 
 	switch (chip->chip_type) {
+	case PCAL953X_TYPE:
 	case PCA953X_TYPE:
 		offset = PCA953X_INPUT;
 		break;
@@ -496,14 +522,45 @@ static u8 pca953x_irq_pending(struct pca953x_chip *chip, u8 *pending)
 	return pendings;
 }
 
+static u32 pcal953x_irq_pending(struct pca953x_chip *chip, u8 *pending)
+{
+	u8 cur_stat[MAX_BANK];
+	int ret, i = 0;
+	u8 pendings = 0;
+
+	/* Read the current interrupt status from the device */
+	ret = pca953x_read_regs(chip, PCAL953X_INT_STAT, pending);
+	if (ret)
+		return 0;
+
+	/* Check latched inputs and clear interrupt status */
+	ret = pca953x_read_regs(chip, PCA953X_INPUT, cur_stat);
+	if (ret)
+		return 0;
+
+	/* Apply filter for rising/falling edge selection */
+	for (i = 0; i < NBANK(chip); i++) {
+		pending[i] &= (~cur_stat[i] & chip->irq_trig_fall[i]) |
+			(cur_stat[i] & chip->irq_trig_raise[i]);
+		pendings += pending[i];
+	}
+
+	return pendings;
+}
+
 static irqreturn_t pca953x_irq_handler(int irq, void *devid)
 {
 	struct pca953x_chip *chip = devid;
 	u8 pending[MAX_BANK];
 	u8 level;
-	int i;
+	int i, pendings;
 
-	if (!pca953x_irq_pending(chip, pending))
+	if (chip->chip_type == PCAL953X_TYPE)
+		pendings = pcal953x_irq_pending(chip, pending);
+	else
+		pendings = pca953x_irq_pending(chip, pending);
+
+	if (!pendings)
 		return IRQ_HANDLED;
 
 	for (i = 0; i < NBANK(chip); i++) {
@@ -549,25 +606,27 @@ static int pca953x_irq_setup(struct pca953x_chip *chip,
 	if (irq_base != -1
 			&& (id->driver_data & PCA_INT)) {
 
-		switch (chip->chip_type) {
-		case PCA953X_TYPE:
-			offset = PCA953X_INPUT;
-			break;
-		case PCA957X_TYPE:
-			offset = PCA957X_IN;
-			break;
+		if (chip->chip_type != PCAL953X_TYPE) {
+			switch (chip->chip_type) {
+			case PCA953X_TYPE:
+				offset = PCA953X_INPUT;
+				break;
+			case PCA957X_TYPE:
+				offset = PCA957X_IN;
+				break;
+			}
+			ret = pca953x_read_regs(chip, offset, chip->irq_stat);
+			if (ret)
+				return ret;
+
+			/*
+			 * There is no way to know which GPIO line generated the
+			 * interrupt.  We have to rely on the previous read for
+			 * this purpose.
+			 */
+			for (i = 0; i < NBANK(chip); i++)
+				chip->irq_stat[i] &= chip->reg_direction[i];
 		}
-		ret = pca953x_read_regs(chip, offset, chip->irq_stat);
-		if (ret)
-			return ret;
-
-		/*
-		 * There is no way to know which GPIO line generated the
-		 * interrupt.  We have to rely on the previous read for
-		 * this purpose.
-		 */
-		for (i = 0; i < NBANK(chip); i++)
-			chip->irq_stat[i] &= chip->reg_direction[i];
 		mutex_init(&chip->irq_lock);
 
 		chip->domain = irq_domain_add_simple(client->dev.of_node,
@@ -737,7 +796,8 @@ static int pca953x_probe(struct i2c_client *client,
 
 	chip->client = client;
 
-	chip->chip_type = id->driver_data & (PCA953X_TYPE | PCA957X_TYPE);
+	chip->chip_type = id->driver_data &
+		(PCAL953X_TYPE | PCA953X_TYPE | PCA957X_TYPE);
 
 	mutex_init(&chip->i2c_lock);
 
@@ -746,7 +806,7 @@ static int pca953x_probe(struct i2c_client *client,
 	 */
 	pca953x_setup_gpio(chip, id->driver_data & PCA_GPIO_MASK);
 
-	if (chip->chip_type == PCA953X_TYPE)
+	if (chip->chip_type & (PCA953X_TYPE | PCAL953X_TYPE))
 		ret = device_pca953x_init(chip, invert);
 	else
 		ret = device_pca957x_init(chip, invert);
@@ -808,6 +868,9 @@ static const struct of_device_id pca953x_dt_ids[] = {
 	{ .compatible = "nxp,pca9574", },
 	{ .compatible = "nxp,pca9575", },
 
+	{ .compatible = "nxp,pcal9535a", },
+	{ .compatible = "nxp,pcal9555a", },
+
 	{ .compatible = "maxim,max7310", },
 	{ .compatible = "maxim,max7312", },
 	{ .compatible = "maxim,max7313", },
diff --git a/drivers/gpio/gpiodebug.c b/drivers/gpio/gpiodebug.c
new file mode 100644
index 0000000..cc5159b
--- /dev/null
+++ b/drivers/gpio/gpiodebug.c
@@ -0,0 +1,540 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include<linux/slab.h>
+#include <linux/debugfs.h>
+#include <linux/uaccess.h>
+#include <linux/ctype.h>
+#include "gpiodebug.h"
+
+struct gpiodebug_data {
+	struct gpio_debug *debug;
+	int gpio;
+	unsigned int type;
+};
+
+enum {
+	REGISTER_FOPS = 0,
+	NORMAL_FOPS,
+	COUNT_FOPS,
+};
+
+static struct {
+	unsigned	fops_type;
+	unsigned	type;
+	char		*available_name;
+	char		*current_name;
+} global_array[] = {
+	{REGISTER_FOPS, TYPE_CONF_REG, "conf_reg", "conf_reg"},
+	{NORMAL_FOPS, TYPE_PIN_VALUE, "available_value",
+		"current_value"},
+	{NORMAL_FOPS, TYPE_DIRECTION, "available_direction",
+		"current_direction"},
+	{NORMAL_FOPS, TYPE_IRQ_TYPE, "available_irqtype",
+		"current_irqtype"},
+	{NORMAL_FOPS, TYPE_PINMUX, "available_pinmux",
+		"current_pinmux"},
+	{NORMAL_FOPS, TYPE_PULLMODE, "available_pullmode",
+		"current_pullmode"},
+	{NORMAL_FOPS, TYPE_PULLSTRENGTH, "available_pullstrength",
+		"current_pullstrength"},
+	{NORMAL_FOPS, TYPE_OPEN_DRAIN, "available_opendrain",
+		"current_opendrain"},
+	{COUNT_FOPS, TYPE_IRQ_COUNT, "irq_count", "irq_count"},
+	{NORMAL_FOPS, TYPE_WAKEUP, "available_wakeup", "current_wakeup"},
+	{COUNT_FOPS, TYPE_WAKEUP_COUNT, "wakeup_count", "wakeup_count"},
+	{NORMAL_FOPS, TYPE_DEBOUNCE, "available_debounce",
+		"current_debounce"},
+	{NORMAL_FOPS, TYPE_OVERRIDE_OUTDIR, "available_override_outdir",
+		"current_override_outdir"},
+	{NORMAL_FOPS, TYPE_OVERRIDE_OUTVAL, "available_override_outval",
+		"current_override_outval"},
+	{NORMAL_FOPS, TYPE_OVERRIDE_INDIR, "available_override_indir",
+		"current_override_indir"},
+	{NORMAL_FOPS, TYPE_OVERRIDE_INVAL, "available_override_inval",
+		"current_override_inval"},
+	{NORMAL_FOPS, TYPE_SBY_OVR_IO, "available_standby_trigger",
+		"current_standby_trigger"},
+	{NORMAL_FOPS, TYPE_SBY_OVR_OUTVAL, "available_standby_outval",
+		"current_standby_outval"},
+	{NORMAL_FOPS, TYPE_SBY_OVR_INVAL, "available_standby_inval",
+		"current_standby_inval"},
+	{NORMAL_FOPS, TYPE_SBY_OVR_OUTDIR, "available_standby_outdir",
+		"current_standby_outdir"},
+	{NORMAL_FOPS, TYPE_SBY_OVR_INDIR, "available_standby_indir",
+		"current_standby_indir"},
+	{NORMAL_FOPS, TYPE_SBY_PUPD_STATE, "available_standby_pullmode",
+		"current_standby_pullmode"},
+	{NORMAL_FOPS, TYPE_SBY_OD_DIS, "available_standby_opendrain",
+		"current_standby_opendrain"},
+
+};
+
+static struct dentry *gpio_root[ARCH_NR_GPIOS];
+static struct gpiodebug_data global_data[ARCH_NR_GPIOS][TYPE_MAX];
+
+static struct dentry *gpiodebug_debugfs_root;
+
+struct gpio_control *find_gpio_control(struct gpio_control *control, int num,
+			unsigned type)
+{
+	int i;
+
+	for (i = 0; i < num; i++) {
+		if ((control+i)->type == type)
+			break;
+	}
+
+	if (i < num)
+		return control+i;
+
+	return NULL;
+}
+
+int find_pininfo_num(struct gpio_control *control, const char *info)
+{
+	int num = 0;
+
+	while (num < control->num) {
+		if (!strcmp(*(control->pininfo+num), info))
+			break;
+		num++;
+	}
+
+	if (num < control->num)
+		return num;
+
+	return -1;
+}
+
+static struct dentry *gpiodebug_create_file(const char *name,
+			umode_t mode, struct dentry *parent,
+			void *data, const struct file_operations *fops)
+{
+	struct dentry *ret;
+
+	ret = debugfs_create_file(name, mode, parent, data, fops);
+	if (!ret)
+		pr_warn("Could not create debugfs '%s' entry\n", name);
+
+	return ret;
+}
+
+static int gpiodebug_open_file(struct inode *inode, struct file *filp)
+{
+	filp->private_data = inode->i_private;
+	return 0;
+}
+
+static const char readme_msg[] =
+	"\n GPIO Debug Tool-HOWTO (Example):\n\n"
+	"# mount -t debugfs nodev /sys/kernel/debug\n\n"
+	"# cat /sys/kernel/debug/gpio_debug/gpio0/available_pullmode\n"
+	"nopull	pullup	pulldown\n\n"
+	"# cat /sys/kernel/debug/gpio_debug/gpio0/current_pullmode\n"
+	"nopull\n"
+	"# echo pullup > /sys/kernel/debug/gpio_debug/gpio0/current_pullmode\n"
+	"# cat /sys/kernel/debug/gpio_debug/gpio0/current_pullmode\n"
+	"pullup\n\n"
+	"# cat conf_reg\n"
+	"0x00003120\n"
+	"# echo 0x00003121 > conf_reg\n"
+	"0x00003121\n\n"
+	"# cat irq_count\n"
+	"1\n";
+
+/* gpio_readme_fops */
+static ssize_t show_gpio_readme(struct file *filp, char __user *ubuf,
+		size_t cnt, loff_t *ppos)
+{
+	ssize_t ret = 0;
+
+	if (*ppos < 0 || !cnt)
+		return -EINVAL;
+
+	ret = simple_read_from_buffer(ubuf, cnt, ppos, readme_msg,
+		strlen(readme_msg));
+
+	return ret;
+}
+
+static const struct file_operations gpio_readme_fops = {
+	.open		= gpiodebug_open_file,
+	.read		= show_gpio_readme,
+	.llseek		= generic_file_llseek,
+};
+
+/* gpio_reginfo_fops */
+static ssize_t show_gpio_reginfo(struct file *filp, char __user *ubuf,
+		size_t cnt, loff_t *ppos)
+{
+	ssize_t ret = 0;
+	struct gpio_debug *debug = filp->private_data;
+	unsigned long size;
+	char *buf;
+
+	if (*ppos < 0 || !cnt)
+		return -EINVAL;
+
+	if (debug->ops->get_register_msg) {
+		debug->ops->get_register_msg(&buf, &size);
+		ret = simple_read_from_buffer(ubuf, cnt, ppos, buf, size);
+	}
+
+	return ret;
+}
+
+static const struct file_operations gpio_reginfo_fops = {
+	.open		= gpiodebug_open_file,
+	.read		= show_gpio_reginfo,
+	.llseek		= generic_file_llseek,
+};
+
+
+/* gpio_conf_fops */
+static ssize_t gpio_conf_read(struct file *filp, char __user *ubuf,
+		size_t cnt, loff_t *ppos)
+{
+	ssize_t ret = 0;
+	struct gpiodebug_data *data = filp->private_data;
+	struct gpio_debug *debug = data->debug;
+	int gpio = data->gpio;
+	char *buf;
+	unsigned int value = 0;
+
+	if (*ppos < 0 || !cnt)
+		return -EINVAL;
+
+	buf = kzalloc(cnt, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	if (debug->ops->get_conf_reg)
+		value = debug->ops->get_conf_reg(debug, gpio);
+
+	if (value == -EINVAL)
+		ret = sprintf(buf, "Invalid pin\n");
+	else
+		ret = sprintf(buf, "0x%08x\n", value);
+
+	ret = simple_read_from_buffer(ubuf, cnt, ppos, buf, ret);
+
+	kfree(buf);
+	return ret;
+}
+
+static ssize_t gpio_conf_write(struct file *filp, const char __user *ubuf,
+		size_t cnt, loff_t *ppos)
+{
+	ssize_t ret = 0;
+	struct gpiodebug_data *data = filp->private_data;
+	struct gpio_debug *debug = data->debug;
+	int i, gpio = data->gpio;
+	char *buf, *start;
+	unsigned int value;
+
+	ret = cnt;
+
+	if (*ppos < 0 || !cnt)
+		return -EINVAL;
+
+	buf = kzalloc(cnt, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	if (copy_from_user(buf, ubuf, cnt))
+		return -EFAULT;
+
+	start = buf;
+
+	while (*start == ' ')
+		start++;
+
+	/* strip ending whitespace. */
+	for (i = cnt - 1; i > 0 && isspace(buf[i]); i--)
+		buf[i] = 0;
+
+	kstrtoul(start, 16, &value);
+
+	if (debug->ops->set_conf_reg)
+		debug->ops->set_conf_reg(debug, gpio, value);
+
+	*ppos += ret;
+
+	return ret;
+}
+
+static const struct file_operations gpio_conf_fops = {
+	.open		= gpiodebug_open_file,
+	.read		= gpio_conf_read,
+	.write		= gpio_conf_write,
+	.llseek		= generic_file_llseek,
+};
+
+/* show_gpiodebug_fops */
+static ssize_t gpiodebug_show_read(struct file *filp, char __user *ubuf,
+		size_t cnt, loff_t *ppos)
+{
+	ssize_t ret = 0;
+	struct gpiodebug_data *data = filp->private_data;
+	struct gpio_debug *debug = data->debug;
+	unsigned int type = data->type;
+	int i, num = 0;
+	int gpio = data->gpio;
+	char *buf, **avl_buf = NULL;
+
+	if (*ppos < 0 || !cnt)
+		return -EINVAL;
+
+	buf = kzalloc(cnt, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	/* debug->ops->get_avl_info */
+	if (debug->ops->get_avl_pininfo) {
+		avl_buf = debug->ops->get_avl_pininfo(debug, gpio, type, &num);
+
+		for (i = 0; i < num; i++)
+			sprintf(buf, "%s%s\t", buf, *(avl_buf+i));
+	}
+
+	ret = sprintf(buf, "%s\n", buf);
+
+	ret = simple_read_from_buffer(ubuf, cnt, ppos, buf, ret);
+
+	kfree(buf);
+
+	return ret;
+}
+
+static const struct file_operations show_gpiodebug_fops = {
+	.open		= gpiodebug_open_file,
+	.read		= gpiodebug_show_read,
+	.llseek		= generic_file_llseek,
+};
+
+/* set_gpiodebug_fops */
+static ssize_t gpiodebug_set_gpio_read(struct file *filp, char __user *ubuf,
+		size_t cnt, loff_t *ppos)
+{
+	ssize_t ret = 0;
+	struct gpiodebug_data *data = filp->private_data;
+	struct gpio_debug *debug = data->debug;
+	unsigned int type = data->type;
+	int gpio = data->gpio;
+	char *buf, *cur_info = NULL;
+
+	if (*ppos < 0 || !cnt)
+		return -EINVAL;
+
+	buf = kzalloc(cnt, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	if (debug->ops->get_cul_pininfo)
+		cur_info = debug->ops->get_cul_pininfo(debug, gpio, type);
+
+	if (cur_info)
+		ret = sprintf(buf, "%s\n", cur_info);
+	else
+		ret = sprintf(buf, "\n");
+
+	ret = simple_read_from_buffer(ubuf, cnt, ppos, buf, ret);
+
+	kfree(buf);
+
+	return ret;
+}
+
+static ssize_t gpiodebug_set_gpio_write(struct file *filp,
+		const char __user *ubuf, size_t cnt, loff_t *ppos)
+{
+	ssize_t ret = 0;
+	struct gpiodebug_data *data = filp->private_data;
+	struct gpio_debug *debug = data->debug;
+	unsigned int type = data->type;
+	int i, gpio = data->gpio;
+	char *buf;
+
+	ret = cnt;
+
+	if (*ppos < 0 || !cnt)
+		return -EINVAL;
+
+	buf = kzalloc(cnt, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	if (copy_from_user(buf, ubuf, cnt))
+		return -EFAULT;
+
+	/* strip ending whitespace. */
+	for (i = cnt - 1; i > 0 && isspace(buf[i]); i--)
+		buf[i] = 0;
+
+	if (debug->ops->set_pininfo)
+		debug->ops->set_pininfo(debug, gpio, type, buf);
+
+	*ppos += ret;
+
+	return ret;
+}
+
+static const struct file_operations set_gpiodebug_fops = {
+	.open		= gpiodebug_open_file,
+	.read		= gpiodebug_set_gpio_read,
+	.write		= gpiodebug_set_gpio_write,
+	.llseek		= generic_file_llseek,
+};
+
+/* show_count_fops */
+static ssize_t show_count_read(struct file *filp, char __user *ubuf,
+		size_t cnt, loff_t *ppos)
+{
+	ssize_t ret = 0;
+	struct gpiodebug_data *data = filp->private_data;
+	struct gpio_debug *debug = data->debug;
+	unsigned int type = data->type;
+	unsigned long count = 0;
+	int gpio = data->gpio;
+	char *buf;
+
+	if (*ppos < 0 || !cnt)
+		return -EINVAL;
+
+	buf = kzalloc(cnt, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	if (type == TYPE_IRQ_COUNT)
+		count = debug->irq_count[gpio];
+	else if (type == TYPE_WAKEUP_COUNT)
+		count = debug->wakeup_count[gpio];
+
+	ret = sprintf(buf, "%ld\n", count);
+
+	ret = simple_read_from_buffer(ubuf, cnt, ppos, buf, ret);
+
+	kfree(buf);
+
+	return ret;
+}
+
+static const struct file_operations show_count_fops = {
+	.open		= gpiodebug_open_file,
+	.read		= show_count_read,
+	.llseek		= generic_file_llseek,
+};
+
+/******************************************************************************/
+struct gpio_debug *gpio_debug_alloc(void)
+{
+	struct gpio_debug *debug;
+
+	debug = kzalloc(sizeof(struct gpio_debug), GFP_KERNEL);
+	if (debug) {
+		__set_bit(TYPE_CONF_REG, debug->typebit);
+		__set_bit(TYPE_PIN_VALUE, debug->typebit);
+		__set_bit(TYPE_DIRECTION, debug->typebit);
+		__set_bit(TYPE_IRQ_TYPE, debug->typebit);
+		__set_bit(TYPE_PINMUX, debug->typebit);
+		__set_bit(TYPE_PULLMODE, debug->typebit);
+		__set_bit(TYPE_PULLSTRENGTH, debug->typebit);
+		__set_bit(TYPE_OPEN_DRAIN, debug->typebit);
+		__set_bit(TYPE_IRQ_COUNT, debug->typebit);
+		__set_bit(TYPE_DEBOUNCE, debug->typebit);
+	}
+
+	return debug;
+}
+
+void gpio_debug_remove(struct gpio_debug *debug)
+{
+	struct gpio_chip *chip = debug->chip;
+	int base = chip->base;
+	unsigned ngpio = chip->ngpio;
+	int i;
+
+	for (i = base; i < base+ngpio; i++)
+		debugfs_remove_recursive(gpio_root[i]);
+
+	kfree(debug);
+}
+
+int gpio_debug_register(struct gpio_debug *debug)
+{
+	struct gpio_chip *chip = debug->chip;
+	int base = chip->base;
+	unsigned ngpio = chip->ngpio;
+	int i, j;
+	char gpioname[32];
+
+	for (i = base; i < base+ngpio; i++) {
+		sprintf(gpioname, "gpio%d", i);
+		gpio_root[i] = debugfs_create_dir(gpioname,
+				gpiodebug_debugfs_root);
+		if (!gpio_root[i]) {
+			pr_warn("gpiodebug: Failed to create debugfs directory\n");
+			return -ENOMEM;
+		}
+
+		/* register info */
+		gpiodebug_create_file("register_info", 0444, gpio_root[i],
+			debug, &gpio_reginfo_fops);
+
+		for (j = 0; j < ARRAY_SIZE(global_array); j++) {
+			if (test_bit(global_array[j].type, debug->typebit)) {
+				global_data[i][j].gpio = i;
+				global_data[i][j].debug = debug;
+				global_data[i][j].type = global_array[j].type;
+
+				switch (global_array[j].fops_type) {
+				case REGISTER_FOPS:
+					gpiodebug_create_file(
+					  global_array[j].current_name, 0644,
+					  gpio_root[i], &global_data[i][j],
+					  &gpio_conf_fops);
+					break;
+				case NORMAL_FOPS:
+					gpiodebug_create_file(
+					  global_array[j].available_name, 0444,
+					  gpio_root[i], &global_data[i][j],
+					  &show_gpiodebug_fops);
+
+					gpiodebug_create_file(
+					  global_array[j].current_name, 0644,
+					  gpio_root[i], &global_data[i][j],
+					  &set_gpiodebug_fops);
+					break;
+				case COUNT_FOPS:
+					gpiodebug_create_file(
+					  global_array[j].current_name, 0444,
+					  gpio_root[i], &global_data[i][j],
+					  &show_count_fops);
+					break;
+				default:
+					break;
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int __init gpio_debug_init(void)
+{
+	gpiodebug_debugfs_root = debugfs_create_dir("gpio_debug", NULL);
+	if (IS_ERR(gpiodebug_debugfs_root) || !gpiodebug_debugfs_root) {
+		pr_warn("gpiodebug: Failed to create debugfs directory\n");
+		gpiodebug_debugfs_root = NULL;
+	}
+
+	/* readme */
+	gpiodebug_create_file("readme", 0444, gpiodebug_debugfs_root,
+		NULL, &gpio_readme_fops);
+
+	return 0;
+}
+
+subsys_initcall(gpio_debug_init);
diff --git a/drivers/gpio/gpiodebug.h b/drivers/gpio/gpiodebug.h
new file mode 100644
index 0000000..f1d58a5
--- /dev/null
+++ b/drivers/gpio/gpiodebug.h
@@ -0,0 +1,108 @@
+#ifndef __GPIO_DEBUG_H_
+#define __GPIO_DEBUG_H_
+
+#include <linux/gpio.h>
+
+struct gpio_debug;
+
+#define TYPE_CONF_REG			0x00
+#define TYPE_PIN_VALUE			0x01
+#define TYPE_DIRECTION			0x02
+#define TYPE_IRQ_TYPE			0x03
+#define TYPE_PINMUX			0x04
+#define TYPE_PULLMODE			0x05
+#define TYPE_PULLSTRENGTH		0x06
+#define TYPE_OPEN_DRAIN			0x07
+
+#define TYPE_IRQ_COUNT			0x08
+#define TYPE_WAKEUP			0x09
+#define TYPE_WAKEUP_COUNT		0x0A
+#define TYPE_OVERRIDE_OUTDIR		0x0B
+#define TYPE_OVERRIDE_OUTVAL		0x0C
+#define TYPE_OVERRIDE_INDIR		0x0D
+#define TYPE_OVERRIDE_INVAL		0x0E
+#define TYPE_DEBOUNCE			0x0F
+
+#define TYPE_SBY_OVR_IO			0x10
+#define TYPE_SBY_OVR_OUTVAL		0x11
+#define TYPE_SBY_OVR_INVAL		0x12
+#define TYPE_SBY_OVR_OUTDIR		0x13
+#define TYPE_SBY_OVR_INDIR		0x14
+#define TYPE_SBY_PUPD_STATE		0x15
+#define TYPE_SBY_OD_DIS			0x16
+#define TYPE_MAX			0x17
+
+struct gpio_control {
+	unsigned type, num;
+	char	 **pininfo;
+	u32	reg, invert;
+	u32 shift, rshift;
+	u32	mask;
+	int (*get)(struct gpio_control *control, void *private_data,
+		unsigned gpio);
+	int (*set)(struct gpio_control *control, void *private_data,
+		unsigned gpio, unsigned int num);
+};
+
+struct gpio_debug_ops {
+	unsigned int (*get_conf_reg)(struct gpio_debug *debug, unsigned gpio);
+	void	(*set_conf_reg)(struct gpio_debug *debug, unsigned gpio,
+			unsigned int value);
+	char	**(*get_avl_pininfo)(struct gpio_debug *debug, unsigned gpio,
+			unsigned int type, unsigned *num);
+	char	*(*get_cul_pininfo)(struct gpio_debug *debug, unsigned gpio,
+			unsigned int type);
+	void	(*set_pininfo)(struct gpio_debug *debug, unsigned gpio,
+			unsigned int type, const char *info);
+	int	(*get_register_msg)(char **buf, unsigned long *size);
+};
+
+struct gpio_debug {
+	unsigned long		typebit[BITS_TO_LONGS(TYPE_MAX)];
+	struct gpio_chip	*chip;
+	struct gpio_debug_ops	*ops;
+	unsigned long		irq_count[ARCH_NR_GPIOS];
+	unsigned long		wakeup_count[ARCH_NR_GPIOS];
+	void			*private_data;
+};
+
+#ifdef CONFIG_GPIODEBUG
+
+#define DEFINE_DEBUG_IRQ_CONUNT_INCREASE(gpio) (debug->irq_count[gpio]++)
+
+struct gpio_control *find_gpio_control(struct gpio_control *control, int num,
+			unsigned type);
+int find_pininfo_num(struct gpio_control *control, const char *info);
+
+struct gpio_debug *gpio_debug_alloc(void);
+void gpio_debug_remove(struct gpio_debug *debug);
+int gpio_debug_register(struct gpio_debug *debug);
+#else
+
+#define DEFINE_DEBUG_IRQ_CONUNT_INCREASE(gpio)
+
+static inline struct gpio_control *find_gpio_control(
+			struct gpio_control *control, int num, unsigned type)
+{
+	return NULL;
+}
+static inline int find_pininfo_num(struct gpio_control *control,
+			const char *info)
+{
+	return 0;
+}
+static inline struct gpio_debug *gpio_debug_alloc(void)
+{
+	return NULL;
+}
+
+static inline void gpio_debug_remove(struct gpio_debug *debug)
+{
+	return NULL;
+}
+static inline int gpio_debug_register(struct gpio_debug *debug)
+{
+	return 0;
+}
+#endif
+#endif
diff --git a/drivers/gpio/gpiolib-sysfs.c b/drivers/gpio/gpiolib-sysfs.c
index b2d2bc4..337c96e 100644
--- a/drivers/gpio/gpiolib-sysfs.c
+++ b/drivers/gpio/gpiolib-sysfs.c
@@ -2,6 +2,7 @@
 #include <linux/mutex.h>
 #include <linux/device.h>
 #include <linux/sysfs.h>
+#include <linux/gpio.h>
 #include <linux/gpio/consumer.h>
 #include <linux/gpio/driver.h>
 #include <linux/interrupt.h>
@@ -17,8 +18,13 @@ static DEFINE_IDR(dirent_idr);
  */
 static DEFINE_MUTEX(sysfs_lock);
 
+static struct gpio_desc gpio_desc[ARCH_NR_GPIOS];
+
 /*
  * /sys/class/gpio/gpioN... only for GPIOs that are exported
+ *   /pinmux
+ *      * configures GPIO or alternate function
+ *      * r/w as zero (normal GPIO) or alternate function number
  *   /direction
  *      * MAY BE OMITTED if kernel won't allow direction changes
  *      * is read/write as "in" or "out"
@@ -37,6 +43,54 @@ static DEFINE_MUTEX(sysfs_lock);
  *      * also affects existing and subsequent "falling" and "rising"
  *        /edge configuration
  */
+static ssize_t gpio_pinmux_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	const struct gpio_desc	*desc = dev_get_drvdata(dev);
+	unsigned		gpio = desc - gpio_desc;
+	struct gpio_chip	*chip;
+	ssize_t			status = -EINVAL;
+
+	mutex_lock(&sysfs_lock);
+
+	chip = desc->chip;
+
+	if (!test_bit(FLAG_EXPORT, &desc->flags))
+		status = -EIO;
+	else if (chip->get_pinmux != NULL)
+		status = sprintf(buf, "%d\n", chip->get_pinmux(gpio));
+
+	mutex_unlock(&sysfs_lock);
+	return status;
+}
+
+static ssize_t gpio_pinmux_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	const struct gpio_desc	*desc = dev_get_drvdata(dev);
+	unsigned		gpio = desc - gpio_desc;
+	ssize_t			status = -EINVAL;
+	struct gpio_chip	*chip;
+	long	mux;
+
+	mutex_lock(&sysfs_lock);
+
+	chip = desc->chip;
+
+	if (!test_bit(FLAG_EXPORT, &desc->flags))
+		status = -EIO;
+	else if (chip->set_pinmux != NULL) {
+		status = kstrtol(buf, 0, &mux);
+		if (status == 0)
+			chip->set_pinmux(gpio, mux);
+	}
+
+	mutex_unlock(&sysfs_lock);
+	return status ? : size;
+}
+
+static DEVICE_ATTR(pinmux, 0644,
+		gpio_pinmux_show, gpio_pinmux_store);
 
 static ssize_t gpio_direction_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
@@ -565,6 +619,10 @@ int gpiod_export(struct gpio_desc *desc, bool direction_may_change)
 					desc_to_gpio(desc));
 	if (IS_ERR(dev)) {
 		status = PTR_ERR(dev);
+			if (!status)
+				status = device_create_file(dev,
+						&dev_attr_pinmux);
+
 		goto fail_unlock;
 	}
 
diff --git a/drivers/i2c/busses/i2c-designware-core.c b/drivers/i2c/busses/i2c-designware-core.c
index 668ddcc..726e277 100644
--- a/drivers/i2c/busses/i2c-designware-core.c
+++ b/drivers/i2c/busses/i2c-designware-core.c
@@ -287,16 +287,6 @@ static struct  dw_controller  dw_controllers[] = {
 		.clk_khz      = 17000,
 		.scl_cfg = mfld_i2c_scl_cfg,
 	},
-	[baytrail] = {
-		.bus_num = -1,
-		.bus_cfg = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
-		.clk_khz = 100000,
-		.functionality = I2C_FUNC_10BIT_ADDR,
-		.scl_sda_cfg = &byt_config,
-	},
-
 	[cloverview_0] = {
 		.bus_num     = 0,
 		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
@@ -478,7 +468,17 @@ static struct  dw_controller  dw_controllers[] = {
 		.reset = vlv2_reset,
 		.share_irq = 1,
 		.acpi_name = "\\_SB.I2C7"
+	},
+	[baytrail] = {
+		.bus_num = -1,
+		.bus_cfg = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 32,
+		.rx_fifo_depth = 32,
+		.clk_khz = 100000,
+		.functionality = I2C_FUNC_10BIT_ADDR,
+		.scl_sda_cfg = &byt_config,
 	}
+
 };
 
 static struct i2c_algorithm i2c_dw_algo = {
diff --git a/drivers/i2c/busses/i2c-designware-core.h b/drivers/i2c/busses/i2c-designware-core.h
index 1c7180d..484a524 100644
--- a/drivers/i2c/busses/i2c-designware-core.h
+++ b/drivers/i2c/busses/i2c-designware-core.h
@@ -321,7 +321,6 @@ enum dw_ctl_id_t {
 	medfield_3,
 	medfield_4,
 	medfield_5,
-	baytrail,
 
 	cloverview_0,
 	cloverview_1,
@@ -353,6 +352,7 @@ enum dw_ctl_id_t {
 	cherryview_4 = valleyview_4,
 	cherryview_5 = valleyview_5,
 	cherryview_6 = valleyview_6,
+	baytrail,
 };
 
 extern int intel_mid_dw_i2c_abort(int busnum);
diff --git a/drivers/i2c/busses/i2c-designware-pcidrv.c b/drivers/i2c/busses/i2c-designware-pcidrv.c
index ea2811f..120897a 100644
--- a/drivers/i2c/busses/i2c-designware-pcidrv.c
+++ b/drivers/i2c/busses/i2c-designware-pcidrv.c
@@ -86,8 +86,6 @@ static int i2c_dw_pci_resume(struct device *dev)
 {
 	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
 	struct dw_i2c_dev *i2c = pci_get_drvdata(pdev);
-	int err;
-	u32 enabled;
 
 	dev_dbg(dev, "resume called\n");
 	return i2c_dw_resume(i2c, false);
@@ -127,10 +125,12 @@ const struct pci_device_id *id)
 	struct dw_i2c_dev *dev;
 	unsigned long start, len;
 	int r;
-	struct dw_scl_sda_cfg *cfg;
 	int bus_idx;
 	static int bus_num;
 
+	bus_idx = id->driver_data + bus_num;
+	bus_num++;
+
 	r = pci_enable_device(pdev);
 	if (r) {
 		dev_err(&pdev->dev, "Failed to enable I2C PCI device (%d)\n",
diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index c536af0..14ae3e6 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -135,16 +135,14 @@ static const struct dev_pm_ops dw_i2c_plat_pm_ops = {
 static int __init dw_i2c_probe(struct platform_device *pdev)
 {
 	struct dw_i2c_dev *dev;
-	struct dw_i2c_platform_data *pdata;
-	u32 clk_freq;
 	struct resource *mem, *ioarea;
-	const struct acpi_device_id *id;
 	unsigned long start, len;
 	int bus_idx = 0;
-	static int bus_num;
 	int irq;
-
 #ifdef CONFIG_ACPI
+	const struct acpi_device_id *id;
+	static int bus_num;
+
 	for (id = dw_i2c_acpi_ids; id->id[0]; id++)
 		if (!strncmp(id->id, dev_name(&pdev->dev), strlen(id->id))) {
 			bus_idx = id->driver_data + bus_num;
@@ -154,6 +152,12 @@ static int __init dw_i2c_probe(struct platform_device *pdev)
 	bus_idx = pdev->id;
 #endif
 
+	/* NOTE: driver uses the static register mapping */
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem) {
+		dev_err(&pdev->dev, "no mem resource?\n");
+		return -EINVAL;
+	}
 	start = mem->start;
 	len = resource_size(mem);
 
@@ -163,41 +167,6 @@ static int __init dw_i2c_probe(struct platform_device *pdev)
 		return irq; /* -ENXIO */
 	}
 
-	/* fast mode by default because of legacy reasons */
-	clk_freq = 400000;
-
-	if (pdev->dev.of_node) {
-		u32 ht = 0;
-		u32 ic_clk = dev->get_clk_rate_khz(dev);
-
-		of_property_read_u32(pdev->dev.of_node,
-					"i2c-sda-hold-time-ns", &ht);
-		dev->sda_hold_time = div_u64((u64)ic_clk * ht + 500000,
-					     1000000);
-
-		of_property_read_u32(pdev->dev.of_node,
-				     "i2c-sda-falling-time-ns",
-				     &dev->sda_falling_time);
-		of_property_read_u32(pdev->dev.of_node,
-				     "i2c-scl-falling-time-ns",
-				     &dev->scl_falling_time);
-
-		of_property_read_u32(pdev->dev.of_node, "clock-frequency",
-				     &clk_freq);
-
-		/* Only standard mode at 100kHz and fast mode at 400kHz
-		 * are supported.
-		 */
-		if (clk_freq != 100000 && clk_freq != 400000) {
-			dev_err(&pdev->dev, "Only 100kHz and 400kHz supported");
-			return -EINVAL;
-		}
-	} else {
-		pdata = dev_get_platdata(&pdev->dev);
-		if (pdata)
-			clk_freq = pdata->i2c_scl_freq;
-	}
-
 	ioarea = request_mem_region(mem->start, resource_size(mem),
 			pdev->name);
 	if (!ioarea) {
@@ -241,13 +210,10 @@ static int __exit dw_i2c_remove(struct platform_device *pdev)
 MODULE_ALIAS("platform:i2c_designware");
 
 static struct platform_driver dw_i2c_driver = {
-	.probe = dw_i2c_probe,
 	.remove = dw_i2c_remove,
 	.driver		= {
 		.name	= "i2c_designware",
 		.owner	= THIS_MODULE,
-		.of_match_table = of_match_ptr(dw_i2c_of_match),
-		.acpi_match_table = ACPI_PTR(dw_i2c_acpi_match),
 		.pm     = &dw_i2c_plat_pm_ops,
 #ifdef CONFIG_ACPI
 		.acpi_match_table = ACPI_PTR(dw_i2c_acpi_ids),
@@ -271,9 +237,8 @@ static int __init dw_i2c_init_driver(void)
 		return 0;
 	}
 
-	return platform_driver_register(&dw_i2c_driver);
+	return platform_driver_probe(&dw_i2c_driver, dw_i2c_probe);
 }
-subsys_initcall(dw_i2c_init_driver);
 module_init(dw_i2c_init_driver);
 
 static void __exit dw_i2c_exit_driver(void)
diff --git a/drivers/iio/adc/iio_basincove_gpadc.c b/drivers/iio/adc/iio_basincove_gpadc.c
index c20b61b..a9b0a81 100644
--- a/drivers/iio/adc/iio_basincove_gpadc.c
+++ b/drivers/iio/adc/iio_basincove_gpadc.c
@@ -38,12 +38,12 @@
 #include <asm/intel_scu_pmic.h>
 #include <asm/intel_basincove_gpadc.h>
 
+#include <linux/iio/consumer.h>
 #include <linux/iio/iio.h>
 #include <linux/iio/machine.h>
 #include <linux/iio/buffer.h>
 #include <linux/iio/driver.h>
 #include <linux/iio/types.h>
-#include <linux/iio/consumer.h>
 
 struct gpadc_info {
 	int initialized;
diff --git a/drivers/mfd/intel_msic.c b/drivers/mfd/intel_msic.c
index 049fd23..70fb6c5 100644
--- a/drivers/mfd/intel_msic.c
+++ b/drivers/mfd/intel_msic.c
@@ -19,6 +19,7 @@
 #include <linux/slab.h>
 
 #include <asm/intel_scu_ipc.h>
+#include <asm/intel_scu_pmic.h>
 
 #define MSIC_VENDOR(id)		((id >> 6) & 3)
 #define MSIC_VERSION(id)	(id & 0x3f)
diff --git a/drivers/mmc/host/sdhci-pci.c b/drivers/mmc/host/sdhci-pci.c
index b3143a6..487eaaa 100644
--- a/drivers/mmc/host/sdhci-pci.c
+++ b/drivers/mmc/host/sdhci-pci.c
@@ -636,7 +636,6 @@ static const struct sdhci_pci_fixes sdhci_intel_mrfl_mmc = {
 	.allow_runtime_pm = true,
 	.probe_slot	= intel_mrfl_mmc_probe_slot,
 	.remove_slot	= intel_mrfl_mmc_remove_slot,
-	.quirks2	= SDHCI_QUIRK2_PRESET_VALUE_BROKEN,
 };
 
 static int intel_moor_emmc_probe_slot(struct sdhci_pci_slot *slot)
diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c
index b7380e7..3fe39a2 100644
--- a/drivers/mmc/host/sdhci.c
+++ b/drivers/mmc/host/sdhci.c
@@ -3106,7 +3106,6 @@ static void sdhci_panic_send_cmd(struct sdhci_host *host,
 
 		sdhci_writew(host, mode, SDHCI_TRANSFER_MODE);
 	}
-	return 0;
 
 	sdhci_writel(host, cmd->arg, SDHCI_ARGUMENT);
 
diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig
index 71dbfb5..0c60a1f 100644
--- a/drivers/platform/x86/Kconfig
+++ b/drivers/platform/x86/Kconfig
@@ -844,6 +844,15 @@ config PVPANIC
 	  a paravirtualized device provided by QEMU; it lets a virtual machine
 	  (guest) communicate panic events to the host.
 
+config INTEL_SCU_FLIS
+	bool "scu flis driver config"
+	depends on INTEL_SCU_IPC
+	default y
+	help
+	  This driver builds the SCU Flis Access Sysfs Interfaces.
+	  We could read write the flis address and configure the
+	  pin pull up/down using these interfaces.
+
 config INTEL_BAYTRAIL_MBI
 	tristate
 	depends on PCI
diff --git a/drivers/platform/x86/Makefile b/drivers/platform/x86/Makefile
index 9b87cfc..303ab95 100644
--- a/drivers/platform/x86/Makefile
+++ b/drivers/platform/x86/Makefile
@@ -40,6 +40,7 @@ obj-$(CONFIG_TOSHIBA_BT_RFKILL)	+= toshiba_bluetooth.o
 obj-$(CONFIG_INTEL_SCU_IPC)	+= intel_scu_ipc.o
 obj-$(CONFIG_INTEL_SCU_IPC_UTIL) += intel_scu_ipcutil.o
 obj-$(CONFIG_INTEL_MFLD_THERMAL) += intel_mid_thermal.o
+obj-$(CONFIG_INTEL_SCU_FLIS)   += intel_scu_flis.o
 obj-$(CONFIG_INTEL_IPS)		+= intel_ips.o
 obj-$(CONFIG_GPIO_INTEL_PMIC)	+= intel_pmic_gpio.o
 obj-$(CONFIG_XO1_RFKILL)	+= xo1-rfkill.o
diff --git a/drivers/platform/x86/intel_pmic_gpio.c b/drivers/platform/x86/intel_pmic_gpio.c
index 478c3a5..6b45c40 100644
--- a/drivers/platform/x86/intel_pmic_gpio.c
+++ b/drivers/platform/x86/intel_pmic_gpio.c
@@ -31,7 +31,7 @@
 #include <linux/init.h>
 #include <linux/io.h>
 #include <linux/gpio.h>
-#include <asm/intel_scu_ipc.h>
+#include <asm/intel_scu_pmic.h>
 #include <linux/device.h>
 #include <linux/intel_pmic_gpio.h>
 #include <linux/platform_device.h>
diff --git a/drivers/platform/x86/intel_scu_flis.c b/drivers/platform/x86/intel_scu_flis.c
new file mode 100644
index 0000000..4dc3598
--- /dev/null
+++ b/drivers/platform/x86/intel_scu_flis.c
@@ -0,0 +1,747 @@
+/* intel_scu_flis.c SCU FLIS INTERFACES
+ *
+ * Copyright (c) 2012,  Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/rpmsg.h>
+#include <asm/intel-mid.h>
+#include <asm/intel_scu_ipc.h>
+#include <asm/intel_scu_flis.h>
+#include <asm/intel_mid_rpmsg.h>
+#include <asm/intel_mid_remoteproc.h>
+#include <linux/platform_data/intel_mid_remoteproc.h>
+
+static struct rpmsg_instance *flis_instance;
+
+static u32 shim_flis_addr;
+static u32 shim_offset;
+static u32 shim_data;
+static char shim_ops[OPS_STR_LEN];
+
+static u32 param_type;	/* flis param type: PULL/PIN DIRECTION/OPEN_DRAIN */
+static u32 param_value;	/* value of certain flis param */
+static unsigned int pin_name;
+static char ops[OPS_STR_LEN];
+
+struct intel_scu_flis_info {
+	struct pinstruct_t *pin_t;
+	struct pin_mmio_flis_t *mmio_flis_t;
+	int pin_num;
+	int initialized;
+	void *flis_base;
+	u32 flis_paddr;
+};
+
+static struct intel_scu_flis_info flis_info;
+
+static DEFINE_SPINLOCK(mmio_flis_lock);
+
+u32 get_flis_value(u32 offset)
+{
+	struct intel_scu_flis_info *isfi = &flis_info;
+	u32 __iomem *mem;
+
+	if (!isfi->initialized || !isfi->flis_base)
+		return -ENODEV;
+
+	mem = (void __iomem *)(isfi->flis_base + offset);
+
+	return readl(mem);
+}
+EXPORT_SYMBOL(get_flis_value);
+
+void set_flis_value(u32 value, u32 offset)
+{
+	struct intel_scu_flis_info *isfi = &flis_info;
+	u32 __iomem *mem;
+	unsigned long flags;
+
+	if (!isfi->initialized || !isfi->flis_base)
+		return;
+
+	/*
+	 * There is one security region for Merrifield FLIS, which
+	 * are read only to OS side. Use IPC when write access is needed.
+	 */
+	if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER
+			&& offset >= 0x1d00
+			&& offset <= 0x1d34) {
+		/* IPC call should not be called in atomic context */
+		might_sleep();
+		rpmsg_send_generic_raw_command(RP_INDIRECT_WRITE, 0,
+					(u8 *)&value, 4,
+					NULL, 0,
+					isfi->flis_paddr + offset, 0);
+
+	} else {
+		mem = (void __iomem *)(isfi->flis_base + offset);
+		spin_lock_irqsave(&mmio_flis_lock, flags);
+		writel(value, mem);
+		spin_unlock_irqrestore(&mmio_flis_lock, flags);
+	}
+}
+EXPORT_SYMBOL(set_flis_value);
+
+/* directly write to flis address */
+int intel_scu_ipc_write_shim(u32 data, u32 flis_addr, u32 offset)
+{
+	int ret;
+	u32 ipc_wbuf[3];
+
+	/* offset 0xff means the flis is reserved, just return 0*/
+	if (offset == 0xFF)
+		return 0;
+
+	ipc_wbuf[0] = flis_addr; /* wbuf[0]: flis address */
+	ipc_wbuf[1] = offset;	/* wbuf[1]: register offset */
+	ipc_wbuf[2] = data;	/* wbuf[2]: data */
+
+	ret = rpmsg_send_command(flis_instance,	IPCMSG_SHIM_CONFIG,
+				IPC_CMD_SHIM_WR, (u8 *)ipc_wbuf, NULL, 12, 0);
+	if (ret)
+		pr_err("%s: failed to write shim, flis addr: 0x%x, offset: 0x%x\n",
+			__func__, flis_addr, offset);
+
+	return ret;
+}
+EXPORT_SYMBOL(intel_scu_ipc_write_shim);
+
+/* directly read from flis address */
+int intel_scu_ipc_read_shim(u32 *data, u32 flis_addr, u32 offset)
+{
+	int ret;
+	u32 ipc_wbuf[2];
+
+	/* offset 0xff means the flis is reserved, just return 0 */
+	if (offset == 0xFF)
+		return 0;
+
+	ipc_wbuf[0] = flis_addr;
+	ipc_wbuf[1] = offset;
+
+	ret = rpmsg_send_command(flis_instance,	IPCMSG_SHIM_CONFIG,
+				IPC_CMD_SHIM_RD, (u8 *)ipc_wbuf, data, 8, 1);
+	if (ret)
+		pr_err("%s: failed to read shim, flis addr: 0x%x, offset: 0x%x\n",
+			__func__, flis_addr, offset);
+
+	return ret;
+}
+EXPORT_SYMBOL(intel_scu_ipc_read_shim);
+
+int intel_scu_ipc_update_shim(u32 data, u32 mask, u32 flis_addr, u32 offset)
+{
+	u32 tmp = 0;
+	int ret;
+
+	ret = intel_scu_ipc_read_shim(&tmp, flis_addr, offset);
+	if (ret) {
+		pr_err("read shim failed, addr = 0x%x, off = 0x%x\n",
+			flis_addr, offset);
+		return ret;
+	}
+
+	tmp &= ~mask;
+	tmp |= (data & mask);
+
+	ret = intel_scu_ipc_write_shim(tmp, flis_addr, offset);
+	if (ret) {
+		pr_err("write shim failed, addr = 0x%x, off = 0x%x\n",
+			flis_addr, offset);
+		return ret;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(intel_scu_ipc_update_shim);
+
+/**
+ * config_pin_flis -- configure pin mux,
+ *		      pull direction and strength and open-drain enable.
+ *
+ * @name: pin name
+ * @param: flis param
+ * @val: value to be set
+ *
+ * example:
+ * config pull up/down:
+ *	config_pin_flis(i2s_2_clk, PULL, UP_20K);
+ *	config_pin_flis(i2s_2_clk, PULL, DOWN_20K);
+ *
+ * config pin mux:
+ *	config_pin_flis(i2s_2_clk, MUX, MUX_EN_INPUT_EN);
+ *	config_pin_flis(i2s_2_clk, MUX, INPUT_EN);
+ *	config_pin_flis(i2s_2_clk, MUX, MUX_EN_OUTPUT_EN);
+ *	config_pin_flis(i2s_2_clk, MUX, OUTPUT_EN);
+ *
+ * config pin open-drain:
+ *	config_pin_flis(i2s_2_clk, OPEN_DRAIN, OD_ENABLE);
+ *	config_pin_flis(i2s_2_clk, OPEN_DRAIN, OD_DISABLE);
+ *
+ */
+int config_pin_flis(unsigned int name, enum flis_param_t param, u32 val)
+{
+	u32 flis_addr, off, data, mask;
+	int ret;
+	int pos;
+	struct intel_scu_flis_info *isfi = &flis_info;
+	struct pin_mmio_flis_t *mmft;
+	u32 old_val;
+
+	if (!isfi->initialized)
+		return -ENODEV;
+
+	if (name < 0 || name >= isfi->pin_num)
+		return -EINVAL;
+
+	if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_CLOVERVIEW) {
+		/* Check if the pin is configurable */
+		if (isfi->pin_t[name].valid == false)
+			return -EINVAL;
+
+		flis_addr = isfi->pin_t[name].bus_address;
+
+		switch (param) {
+		case PULL:
+			off = isfi->pin_t[name].pullup_offset;
+			pos = isfi->pin_t[name].pullup_lsb_pos;
+			mask = (PULL_MASK << pos);
+			break;
+		case MUX:
+			off = isfi->pin_t[name].direction_offset;
+			pos = isfi->pin_t[name].direction_lsb_pos;
+			mask = (MUX_MASK << pos);
+			break;
+		case OPEN_DRAIN:
+			off = isfi->pin_t[name].open_drain_offset;
+			pos = isfi->pin_t[name].open_drain_bit;
+			mask = (OPEN_DRAIN_MASK << pos);
+			break;
+		default:
+			pr_err("Please specify valid flis param\n");
+			return -EINVAL;
+		}
+
+		data = (val << pos);
+		pr_debug("addr = 0x%x, off = 0x%x, pos = %d, mask = 0x%x, data = 0x%x\n",
+				flis_addr, off, pos, mask, data);
+
+		ret = intel_scu_ipc_update_shim(data, mask, flis_addr, off);
+		if (ret) {
+			pr_err("update shim failed\n");
+			return ret;
+		}
+	} else if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER) {
+		mmft = isfi->mmio_flis_t;
+		off = mmft[name].offset;
+
+		/* Check if the FLIS is writable by mmio access */
+		if (!(mmft[name].access_ctrl & writable))
+			return -EINVAL;
+
+		old_val = get_flis_value(off);
+
+		switch (param) {
+		case PULL:
+			mask = PULL_MASK;
+			break;
+		case MUX:
+			mask = MUX_MASK;
+			break;
+		case OPEN_DRAIN:
+			mask = OPEN_DRAIN_MASK;
+			break;
+		default:
+			pr_err("Please specify valid flis param\n");
+			return -EINVAL;
+		}
+
+		set_flis_value((old_val & ~mask) | val, off);
+
+	} else
+		return -EINVAL;
+
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(config_pin_flis);
+
+int get_pin_flis(unsigned int name, enum flis_param_t param, u32 *val)
+{
+	u32 flis_addr, off;
+	u32 data = 0;
+	int ret;
+	int pos;
+	u32 mask;
+	struct intel_scu_flis_info *isfi = &flis_info;
+	struct pin_mmio_flis_t *mmft;
+	u32 old_val;
+
+	if (!isfi->initialized)
+		return -ENODEV;
+
+	if (name < 0 || name >= isfi->pin_num)
+		return -EINVAL;
+
+	if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_CLOVERVIEW) {
+		if (isfi->pin_t[name].valid == false)
+			return -EINVAL;
+
+		flis_addr = isfi->pin_t[name].bus_address;
+
+		switch (param) {
+		case PULL:
+			off = isfi->pin_t[name].pullup_offset;
+			pos = isfi->pin_t[name].pullup_lsb_pos;
+			mask = PULL_MASK;
+			break;
+		case MUX:
+			off = isfi->pin_t[name].direction_offset;
+			pos = isfi->pin_t[name].direction_lsb_pos;
+			mask = MUX_MASK;
+			break;
+		case OPEN_DRAIN:
+			off = isfi->pin_t[name].open_drain_offset;
+			pos = isfi->pin_t[name].open_drain_bit;
+			mask = OPEN_DRAIN_MASK;
+			break;
+		default:
+			pr_err("Please specify valid flis param\n");
+			return -EINVAL;
+		}
+
+		ret = intel_scu_ipc_read_shim(&data, flis_addr, off);
+		if (ret) {
+			pr_err("read shim failed, addr = 0x%x, off = 0x%x\n",
+				flis_addr, off);
+			return ret;
+		}
+
+		*val = (data >> pos) & mask;
+
+		pr_debug("read: data = 0x%x, val = 0x%x\n", data, *val);
+	} else if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER) {
+		mmft = isfi->mmio_flis_t;
+		off = mmft[name].offset;
+
+		old_val = get_flis_value(off);
+
+		switch (param) {
+		case PULL:
+			pos = 4;
+			mask = PULL_MASK;
+			break;
+		case MUX:
+			pos = 12;
+			mask = MUX_MASK;
+			break;
+		case OPEN_DRAIN:
+			pos = 21;
+			mask = OPEN_DRAIN_MASK;
+			break;
+		default:
+			pr_err("Please specify valid flis param\n");
+			return -EINVAL;
+		}
+
+		*val = (old_val & mask) >> pos;
+
+	} else
+		return -EINVAL;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(get_pin_flis);
+
+static void flis_generic_store(const char *buf, int type)
+{
+	u32 tmp;
+	int ret;
+
+	/* use decimal for pin number */
+	if (type == DBG_PIN_NAME)
+		ret = sscanf(buf, "%d", &tmp);
+	else
+		ret = sscanf(buf, "%x", &tmp);
+
+	if (ret != 1)
+		return;
+
+	switch (type) {
+	case DBG_SHIM_FLIS_ADDR:
+		shim_flis_addr = tmp;
+		break;
+	case DBG_SHIM_OFFSET:
+		shim_offset = tmp;
+		break;
+	case DBG_SHIM_DATA:
+		shim_data = tmp;
+		break;
+	case DBG_PARAM_VAL:
+		param_value = tmp;
+		break;
+	case DBG_PARAM_TYPE:
+		param_type = tmp;
+		break;
+	case DBG_PIN_NAME:
+		pin_name = tmp;
+		break;
+	default:
+		break;
+	}
+}
+
+static ssize_t shim_flis_addr_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	flis_generic_store(buf, DBG_SHIM_FLIS_ADDR);
+	return size;
+}
+
+static ssize_t shim_flis_addr_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "0x%x\n", shim_flis_addr);
+}
+
+static ssize_t shim_offset_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	flis_generic_store(buf, DBG_SHIM_OFFSET);
+	return size;
+}
+
+static ssize_t shim_offset_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "0x%x\n", shim_offset);
+}
+
+static ssize_t shim_data_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	flis_generic_store(buf, DBG_SHIM_DATA);
+	return size;
+}
+
+static ssize_t shim_data_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "0x%x\n", shim_data);
+}
+
+static ssize_t shim_ops_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int ret;
+
+	memset(shim_ops, 0, sizeof(shim_ops));
+
+	ret = sscanf(buf, "%9s", shim_ops);
+	if (ret != 1)
+		return -EINVAL;
+
+	if (!strncmp("read", shim_ops, OPS_STR_LEN)) {
+		ret = intel_scu_ipc_read_shim(&shim_data, shim_flis_addr,
+				shim_offset);
+	} else if (!strncmp("write", shim_ops, OPS_STR_LEN)) {
+		ret = intel_scu_ipc_write_shim(shim_data, shim_flis_addr,
+				shim_offset);
+	} else {
+		dev_err(dev, "Not supported ops\n");
+		ret = -EINVAL;
+	}
+
+	if (ret) {
+		dev_err(dev, "shim config met error\n");
+		return ret;
+	}
+
+	return size;
+}
+
+static ssize_t param_val_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "0x%x\n", param_value);
+}
+
+static ssize_t param_val_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	flis_generic_store(buf, DBG_PARAM_VAL);
+	return size;
+}
+
+static ssize_t flis_param_type_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", param_type);
+}
+
+static ssize_t flis_param_type_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	flis_generic_store(buf, DBG_PARAM_TYPE);
+	return size;
+}
+
+static ssize_t pinname_show(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", pin_name);
+}
+
+static ssize_t pinname_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	flis_generic_store(buf, DBG_PIN_NAME);
+	return size;
+}
+
+static ssize_t ops_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	int ret;
+
+	memset(ops, 0, sizeof(ops));
+
+	ret = sscanf(buf, "%9s", ops);
+	if (ret != 1) {
+		dev_err(dev, "input error\n");
+		return -EINVAL;
+	}
+
+	if (!strncmp("get", ops, OPS_STR_LEN))
+		ret = get_pin_flis(pin_name, param_type, &param_value);
+	else if (!strncmp("set", ops, OPS_STR_LEN))
+		ret = config_pin_flis(pin_name, param_type, param_value);
+	else {
+		dev_err(dev, "wrong ops\n");
+		ret = -EINVAL;
+	}
+
+	if (ret) {
+		dev_err(dev, "Access flis error, ret = %d\n", ret);
+		return ret;
+	}
+
+	return size;
+}
+
+static DEVICE_ATTR(flis_addr, S_IRUGO|S_IWUSR,
+		shim_flis_addr_show, shim_flis_addr_store);
+static DEVICE_ATTR(offset, S_IRUGO|S_IWUSR,
+		shim_offset_show, shim_offset_store);
+static DEVICE_ATTR(data, S_IRUGO|S_IWUSR, shim_data_show, shim_data_store);
+static DEVICE_ATTR(flis_ops, S_IWUSR, NULL, shim_ops_store);
+
+static struct attribute *flis_attrs[] = {
+	&dev_attr_flis_addr.attr,
+	&dev_attr_offset.attr,
+	&dev_attr_data.attr,
+	&dev_attr_flis_ops.attr,
+	NULL,
+};
+
+static struct attribute_group flis_attr_group = {
+	.name = "flis_debug",
+	.attrs = flis_attrs,
+};
+
+static DEVICE_ATTR(pin_name, S_IRUGO|S_IWUSR, pinname_show, pinname_store);
+static DEVICE_ATTR(flis_param, S_IRUGO|S_IWUSR, flis_param_type_show,
+						flis_param_type_store);
+static DEVICE_ATTR(val, S_IRUGO|S_IWUSR, param_val_show, param_val_store);
+static DEVICE_ATTR(ops, S_IWUSR, NULL, ops_store);
+
+static struct attribute *pin_config_attrs[] = {
+	&dev_attr_pin_name.attr,
+	&dev_attr_flis_param.attr,
+	&dev_attr_val.attr,
+	&dev_attr_ops.attr,
+	NULL,
+};
+
+static struct attribute_group pin_config_attr_group = {
+	.name = "pin_config_debug",
+	.attrs = pin_config_attrs,
+};
+
+static int scu_flis_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct intel_scu_flis_info *isfi = &flis_info;
+	struct intel_scu_flis_platform_data *pdata = pdev->dev.platform_data;
+
+	if (!pdata) {
+		dev_err(&pdev->dev, "No platform data\n");
+		ret = -EINVAL;
+		goto out;
+	}
+
+	isfi->pin_t = pdata->pin_t;
+	isfi->pin_num = pdata->pin_num;
+	isfi->mmio_flis_t = pdata->mmio_flis_t;
+	if (pdata->mmio_flis_t && pdata->flis_base) {
+		isfi->flis_paddr = pdata->flis_base;
+		isfi->flis_base = ioremap_nocache(pdata->flis_base,
+					pdata->flis_len);
+		if (!isfi->flis_base) {
+			dev_err(&pdev->dev, "error mapping flis base\n");
+			ret = -EFAULT;
+			goto out;
+		}
+	}
+
+	if ((isfi->pin_t || isfi->mmio_flis_t)&&isfi->pin_num)
+		isfi->initialized = 1;
+
+	ret = sysfs_create_group(&pdev->dev.kobj, &flis_attr_group);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to create flis sysfs interface\n");
+		goto err1;
+	}
+
+	ret = sysfs_create_group(&pdev->dev.kobj, &pin_config_attr_group);
+	if (ret) {
+		dev_err(&pdev->dev,
+				"Failed to create pin config sysfs interface\n");
+		goto err2;
+	}
+
+	dev_info(&pdev->dev, "scu flis probed\n");
+	return 0;
+
+err2:
+	sysfs_remove_group(&pdev->dev.kobj, &flis_attr_group);
+err1:
+	if (pdata->flis_base)
+		iounmap(isfi->flis_base);
+out:
+	isfi->initialized = 0;
+	return ret;
+}
+
+static int scu_flis_remove(struct platform_device *pdev)
+{
+	sysfs_remove_group(&pdev->dev.kobj, &pin_config_attr_group);
+	sysfs_remove_group(&pdev->dev.kobj, &flis_attr_group);
+
+	return 0;
+}
+
+static struct platform_driver scu_flis_driver = {
+	.driver = {
+		   .name = "intel_scu_flis",
+		   .owner = THIS_MODULE,
+		   },
+	.probe = scu_flis_probe,
+	.remove = scu_flis_remove,
+};
+
+static int scu_flis_module_init(void)
+{
+	return platform_driver_register(&scu_flis_driver);
+}
+
+static void scu_flis_module_exit(void)
+{
+	platform_driver_unregister(&scu_flis_driver);
+}
+
+static int flis_rpmsg_probe(struct rpmsg_channel *rpdev)
+{
+	int ret = 0;
+
+	if (rpdev == NULL) {
+		pr_err("rpmsg channel not created\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	dev_info(&rpdev->dev, "Probed flis rpmsg device\n");
+
+	/* Allocate rpmsg instance for flis*/
+	ret = alloc_rpmsg_instance(rpdev, &flis_instance);
+	if (!flis_instance) {
+		dev_err(&rpdev->dev, "kzalloc flis instance failed\n");
+		goto out;
+	}
+
+	/* Initialize rpmsg instance */
+	init_rpmsg_instance(flis_instance);
+
+	ret = scu_flis_module_init();
+	if (ret)
+		free_rpmsg_instance(rpdev, &flis_instance);
+
+out:
+	return ret;
+}
+
+static void flis_rpmsg_remove(struct rpmsg_channel *rpdev)
+{
+	scu_flis_module_exit();
+	free_rpmsg_instance(rpdev, &flis_instance);
+	dev_info(&rpdev->dev, "Removed flis rpmsg device\n");
+}
+
+static void flis_rpmsg_cb(struct rpmsg_channel *rpdev, void *data,
+					int len, void *priv, u32 src)
+{
+	dev_warn(&rpdev->dev, "unexpected, message\n");
+
+	print_hex_dump(KERN_DEBUG, __func__, DUMP_PREFIX_NONE, 16, 1,
+		       data, len,  true);
+}
+
+static struct rpmsg_device_id flis_rpmsg_id_table[] = {
+	{ .name	= "rpmsg_flis" },
+	{ },
+};
+MODULE_DEVICE_TABLE(rpmsg, flis_rpmsg_id_table);
+
+static struct rpmsg_driver flis_rpmsg = {
+	.drv.name	= KBUILD_MODNAME,
+	.drv.owner	= THIS_MODULE,
+	.id_table	= flis_rpmsg_id_table,
+	.probe		= flis_rpmsg_probe,
+	.callback	= flis_rpmsg_cb,
+	.remove		= flis_rpmsg_remove,
+};
+
+static int __init flis_rpmsg_init(void)
+{
+	return register_rpmsg_driver(&flis_rpmsg);
+}
+
+static void __exit flis_rpmsg_exit(void)
+{
+	return unregister_rpmsg_driver(&flis_rpmsg);
+}
+
+fs_initcall(flis_rpmsg_init);
+module_exit(flis_rpmsg_exit);
+
+MODULE_AUTHOR("Ning Li <ning.li@intel.com>");
+MODULE_DESCRIPTION("Intel FLIS Access Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/pwm/Kconfig b/drivers/pwm/Kconfig
index 77399f1..1546f4c 100644
--- a/drivers/pwm/Kconfig
+++ b/drivers/pwm/Kconfig
@@ -280,4 +280,13 @@ config PWM_VT8500
 	  To compile this driver as a module, choose M here: the module
 	  will be called pwm-vt8500.
 
+config PWM_INTEL_MID
+	tristate "Support for Intel MID PWM"
+	help
+	  This option enables support for Intel Mid PWM Driver. Say Y
+	  here if you want to enable the PWM functionality.
+
+	  To compile this driver as a module, choose M here. The module will
+	  be called pwm-intel-mid.
+
 endif
diff --git a/drivers/pwm/Makefile b/drivers/pwm/Makefile
index f1345f3..f40b97e 100644
--- a/drivers/pwm/Makefile
+++ b/drivers/pwm/Makefile
@@ -26,3 +26,4 @@ obj-$(CONFIG_PWM_TIPWMSS)	+= pwm-tipwmss.o
 obj-$(CONFIG_PWM_TWL)		+= pwm-twl.o
 obj-$(CONFIG_PWM_TWL_LED)	+= pwm-twl-led.o
 obj-$(CONFIG_PWM_VT8500)	+= pwm-vt8500.o
+obj-$(CONFIG_PWM_INTEL_MID)	+= pwm-intel-mid.o
diff --git a/drivers/pwm/pwm-intel-mid.c b/drivers/pwm/pwm-intel-mid.c
new file mode 100644
index 0000000..7897607
--- /dev/null
+++ b/drivers/pwm/pwm-intel-mid.c
@@ -0,0 +1,404 @@
+/*
+ * pwm-intel-mid.c: Driver for PWM on Intel MID platform
+ *
+ * (C) Copyright 2014 Intel Corporation
+ * Author: Nicolas Pernas Maradei <nicolas.pernas.maradei@emutex.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/pwm.h>
+#include <linux/pci.h>
+#include <linux/pm_runtime.h>
+
+#define PWM_INTEL_MID_DRIVER_NAME     "pwm-intel-mid"
+#define PCI_DEVICE_ID_INTEL_MID_MRFLD 0x11a5
+#define CLOCK_RATE                    19200000
+#define BASE_10                       10
+#define NSECS_PER_SEC                 1000000000UL
+#define PWM_PERIOD_NS_MAX             218453000 /* about 4.6 Hz */
+#define PWM_PERIOD_NS_MIN             104 /* about 9.6 MHz */
+#define PWM_ON_TIME_DIVISOR_BITS      8
+#define PWM_BASE_UNIT_FRAC_BITS       14
+#define PWM_BASE_UNIT_INT_BITS        8
+#define PWM_COMPARE_UNIT_SIZE         256UL
+#define PWM_DYNAMYC_RANGE_DEFAULT     100UL
+#define PWM_DYNAMYC_RANGE_THRESHOLD   13333
+#define PWM_DEFAULT_PERIOD            4950495 /* about 200 Hz */
+#define PWM_CONTROL_REGISTER_SIZE     0x400
+
+#define get_control_register(pwm, pwm_id) \
+	((u8 *)pwm->regs + (pwm_id * PWM_CONTROL_REGISTER_SIZE));
+
+union pwmctrl_reg {
+	struct {
+		u32 on_time_divisor:PWM_ON_TIME_DIVISOR_BITS;
+		u32 base_unit_frac:PWM_BASE_UNIT_FRAC_BITS;
+		u32 base_unit_int:PWM_BASE_UNIT_INT_BITS;
+		u32 sw_update:1;
+		u32 enable:1;
+	} part;
+	u32 full;
+};
+
+struct intel_mid_pwm_chip {
+	struct pwm_chip chip;
+	void __iomem *regs;
+	union pwmctrl_reg *pwmctrls;
+	int num_of_pwms;
+};
+
+static inline struct intel_mid_pwm_chip *
+to_pwm(struct pwm_chip *chip)
+{
+	return container_of(chip, struct intel_mid_pwm_chip, chip);
+}
+
+static inline void
+pwm_set_enable_bit(void __iomem *reg, union pwmctrl_reg *pwmctrl, u8 value)
+{
+	pwmctrl->full = readl(reg);
+	pwmctrl->part.enable = value;
+	writel(pwmctrl->full, reg);
+}
+
+static void
+intel_mid_pwm_on_time_divisor(void __iomem *reg, union pwmctrl_reg *pwmctrl,
+	const u32 period, const u32 duty_cycle)
+{
+	u64 on_time_divisor;
+
+	/* Calculate and set on time divisor */
+	on_time_divisor = duty_cycle * (u64)(PWM_COMPARE_UNIT_SIZE - 1UL);
+	do_div(on_time_divisor, period);
+	on_time_divisor = PWM_COMPARE_UNIT_SIZE - on_time_divisor - 1UL;
+
+	pwmctrl->full = readl(reg);
+	pwmctrl->part.on_time_divisor = on_time_divisor;
+	writel(pwmctrl->full, reg);
+}
+
+static int
+intel_mid_pwm_base_unit(void __iomem *reg, union pwmctrl_reg *pwmctrl,
+	const u32 period, const u32 clock_rate)
+{
+	u32 dynamic_range = PWM_DYNAMYC_RANGE_DEFAULT;
+	u64 rest;
+	u64 tmp;
+	u64 fraction = 0;
+	u64 numerator = 1;
+	u64 base_unit_integer;
+	u64 frequency = NSECS_PER_SEC;
+	u32 base_unit_fraction = 0;
+	int i;
+
+	/* The dynamic range multiplier is used to get more accurate
+	calculations when the frequency is small (less than 75 KHz) in the
+	fraction part of base unit. In some way when requesting low frequencies
+	all calculations are done using the period in nano-secs e-2. For high
+	frecuencies we use nano-secs only. */
+	if (period < PWM_DYNAMYC_RANGE_THRESHOLD)
+		dynamic_range = 1UL;
+	frequency *= dynamic_range;
+
+	/* calculate frequency: f (hz) = 1e9 (ns/ps) / p (ns/ps). Result is in
+	Hz depending on dynamic_range being 1. */
+	do_div(frequency, period);
+
+	/* base_unit is a 22 bits register composed of a fractional part (first
+	14 bits) and an integer part (next 8 bits). The integer part
+	calculation is trivial. Done in place by do_div() below. */
+	base_unit_integer = frequency * PWM_COMPARE_UNIT_SIZE;
+
+	rest = do_div(base_unit_integer, clock_rate * dynamic_range);
+
+	/* The fractional part of base_unit needs to be calculated and converted
+	to binary fixed point notation. Two steps will be needed to do the
+	calculation. First to calculate the fraction part in decimal and
+	secondly to convert it to binary fixed point. Due to lack of float
+	support in the kernel we'll use the rest of (frequency *
+	PWM_COMPARE_UNIT_SIZE / clock_speed) division to calculate it and then
+	following the standard division algorithm the rest will be multiplied
+	by 10 and divided by clock_rate several times until the desired level
+	of precision is reached. At the end it will look like this:
+	base_unit_fraction = fraction / numerator where numerator is a power
+	of 10.
+
+	E.g.:	base_unit = 1.123, base_unit_fraction = 0.123,
+			fraction = 123, numerator = 1000 */
+	for (i = 0; i < PWM_BASE_UNIT_FRAC_BITS; i++) {
+		tmp = rest * BASE_10;
+		rest = do_div(tmp, clock_rate * dynamic_range);
+		fraction += tmp;
+		fraction *= BASE_10;
+		numerator *= BASE_10;
+	}
+	do_div(fraction, BASE_10);
+
+	/* At this point we've got the fraction and numerator done following
+	the above description. The binary fixed point conversion is done by
+	repeated multiplications of the fraction (but using fractions (fra/num)
+	instead of floats). When the fraction is multipled by 2 and gets greater
+	or equal than 1 (or in our case frac/num >= 1 -> frac >= num) then we
+	know the next digit in the binary fixed point number will be a '1'.
+	Also this excess needs to be removed. In the original algorithm the
+	overflow digit is substracted. In our case we can substract the
+	numerator. */
+	for (i = 0; i < PWM_BASE_UNIT_FRAC_BITS; i++) {
+		/* Multiply fraction by 2 */
+		fraction <<= 1;
+		base_unit_fraction <<= 1;
+
+		/* frac / num >= 1 -> set next bit to '1' and remove "overflow
+		digit" */
+		if (fraction >= numerator) {
+			base_unit_fraction |= 1;
+			fraction -= numerator;
+		}
+	}
+	/* If both the values are 0, the output will be somehow not correct.
+	 * So if it happens, change the fraction to 1.
+	 */
+	if ((0 == base_unit_fraction) && (0 == base_unit_integer))
+		base_unit_fraction = 1UL;
+
+	pwmctrl->full = readl(reg);
+	pwmctrl->part.base_unit_int = (u32)base_unit_integer;
+	pwmctrl->part.base_unit_frac = base_unit_fraction;
+	writel(pwmctrl->full, reg);
+
+	return 0;
+}
+
+static int
+intel_mid_pwm_setup(void __iomem *reg, union pwmctrl_reg *pwmctrl,
+	int duty_ns, int period_ns)
+{
+	int ret;
+
+	/* Calculate and set base_unit */
+	ret = intel_mid_pwm_base_unit(reg, pwmctrl, period_ns, CLOCK_RATE);
+	if (ret)
+		return ret;
+
+	/* Calculate and set on time divisor */
+	intel_mid_pwm_on_time_divisor(reg, pwmctrl, period_ns, duty_ns);
+
+	/* Set software update bit */
+	pwmctrl->part.sw_update = 1UL;
+	writel(pwmctrl->full, reg);
+
+	return 0;
+}
+
+static int
+intel_mid_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm_dev,
+	int duty_ns, int period_ns)
+{
+	struct intel_mid_pwm_chip *pwm = to_pwm(chip);
+	union pwmctrl_reg *pwmctrl = &pwm->pwmctrls[pwm_dev->hwpwm];
+	void __iomem *reg = get_control_register(pwm, pwm_dev->hwpwm);
+
+	dev_dbg(chip->dev, "%s: period_ns %d, duty_ns %d\n", __func__,
+		period_ns, duty_ns);
+
+	/* Check the period is valid within HW capabilities */
+	if (period_ns < PWM_PERIOD_NS_MIN || period_ns > PWM_PERIOD_NS_MAX) {
+		dev_err(chip->dev, "Period (ns) must be in range %u:%u\n",
+			PWM_PERIOD_NS_MIN, PWM_PERIOD_NS_MAX);
+		return -EINVAL;
+	}
+
+	return intel_mid_pwm_setup(reg, pwmctrl, duty_ns, period_ns);
+}
+
+static int
+intel_mid_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm_dev)
+{
+	struct intel_mid_pwm_chip *pwm = to_pwm(chip);
+	union pwmctrl_reg *pwmctrl = &pwm->pwmctrls[pwm_dev->hwpwm];
+	int ret;
+	void __iomem *reg = get_control_register(pwm, pwm_dev->hwpwm);
+
+	pm_runtime_get_sync(chip->dev);
+
+	ret = intel_mid_pwm_setup(reg, pwmctrl, pwm_dev->duty_cycle,
+		pwm_dev->period);
+	if (ret)
+		return ret;
+
+	pwm_set_enable_bit(reg, pwmctrl, 1U);
+
+	dev_dbg(chip->dev, "%s: pwmctrl %#x\n", __func__, pwmctrl->full);
+
+	return 0;
+}
+
+static void
+intel_mid_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm_dev)
+{
+	struct intel_mid_pwm_chip *pwm = to_pwm(chip);
+	union pwmctrl_reg *pwmctrl = &pwm->pwmctrls[pwm_dev->hwpwm];
+	void __iomem *reg = get_control_register(pwm, pwm_dev->hwpwm);
+
+	pwm_set_enable_bit(reg, pwmctrl, 0);
+	pm_runtime_put(chip->dev);
+	dev_dbg(chip->dev, "%s: pwmctrl %#x\n", __func__, pwmctrl->full);
+}
+
+static const struct pwm_ops intel_mid_pwm_ops = {
+	.config = intel_mid_pwm_config,
+	.enable = intel_mid_pwm_enable,
+	.disable = intel_mid_pwm_disable,
+	.owner = THIS_MODULE,
+};
+
+static int
+intel_mid_pwm_probe(struct pci_dev *pci, const struct pci_device_id *pci_id)
+{
+	struct intel_mid_pwm_chip *pwm;
+	int ret, i;
+	resource_size_t resource_len;
+
+	pwm = devm_kzalloc(&pci->dev, sizeof(*pwm), GFP_KERNEL);
+	if (!pwm) {
+		dev_err(&pci->dev, "Can't allocate memory for pwm\n");
+		return -ENOMEM;
+	}
+
+	/* Init the device */
+	ret = pci_enable_device(pci);
+	if (ret) {
+		dev_err(&pci->dev, "Can't enable pci device\n");
+		return ret;
+	}
+
+	ret = pci_request_regions(pci, PWM_INTEL_MID_DRIVER_NAME);
+	if (ret) {
+		dev_err(&pci->dev, "Can't request regions\n");
+		goto do_disable_device;
+	}
+	pci_dev_get(pci);
+
+	pwm->regs = pci_ioremap_bar(pci, 0);
+	if (!pwm->regs) {
+		dev_err(&pci->dev, "ioremap failed\n");
+		ret = -EIO;
+		goto do_disable_device;
+	}
+
+	/* Calculate number of available pwm modules */
+	resource_len = pci_resource_len(pci, 0);
+	do_div(resource_len, PWM_CONTROL_REGISTER_SIZE);
+	pwm->num_of_pwms = resource_len;
+
+	/* allocate memory for PWM control register images */
+	pwm->pwmctrls = devm_kzalloc(&pci->dev,
+		sizeof(*pwm->pwmctrls) * pwm->num_of_pwms, GFP_KERNEL);
+	if (!pwm->pwmctrls) {
+		dev_err(&pci->dev, "Can't allocate memory for pwm pwmctrls\n");
+		ret = -ENOMEM;
+		goto do_unmap_regs;
+	}
+
+	/* register the driver with PWM framework */
+	pwm->chip.dev = &pci->dev;
+	pwm->chip.ops = &intel_mid_pwm_ops;
+	pwm->chip.base = -1;
+	pwm->chip.npwm = pwm->num_of_pwms;
+
+	ret = pwmchip_add(&pwm->chip);
+	if (ret) {
+		dev_err(&pci->dev, "Failed to add PWM chip: %d\n", ret);
+		goto do_unmap_regs;
+	}
+
+	/* Set default frequency/period (about 200Hz) on all pwm modules. */
+	for (i = 0; i < pwm->num_of_pwms; i++)
+		pwm->chip.pwms[i].period = PWM_DEFAULT_PERIOD;
+
+	pci_set_drvdata(pci, pwm);
+	pm_runtime_allow(&pci->dev);
+	pm_runtime_put_noidle(&pci->dev);
+
+	return ret;
+
+do_unmap_regs:
+	iounmap(pwm->regs);
+	pci_release_regions(pci);
+do_disable_device:
+	pci_disable_device(pci);
+
+	return ret;
+}
+
+static void
+intel_mid_pwm_remove(struct pci_dev *pci)
+{
+	struct intel_mid_pwm_chip *pwm = pci_get_drvdata(pci);
+
+	pm_runtime_get_noresume(&pci->dev);
+	pm_runtime_forbid(&pci->dev);
+	pwmchip_remove(&pwm->chip);
+	iounmap(pwm->regs);
+	pci_release_regions(pci);
+	pci_disable_device(pci);
+	pci_set_drvdata(pci, NULL);
+}
+
+#if CONFIG_PM
+static int
+intel_mid_pwm_runtime_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int
+intel_mid_pwm_runtime_resume(struct device *dev)
+{
+	return 0;
+}
+
+static void
+intel_mid_pwm_runtime_complete(struct device *dev) {
+}
+
+static const struct dev_pm_ops intel_mid_pm_ops = {
+	.prepare = intel_mid_pwm_runtime_suspend,
+	.complete = intel_mid_pwm_runtime_complete,
+	.runtime_suspend = intel_mid_pwm_runtime_suspend,
+	.runtime_resume = intel_mid_pwm_runtime_resume,
+};
+#endif
+
+/* PCI Routines */
+static DEFINE_PCI_DEVICE_TABLE(intel_mid_pwm_pci_ids) = {
+	{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_INTEL_MID_MRFLD), 0},
+	{ 0, }
+};
+MODULE_DEVICE_TABLE(pci, intel_mid_pwm_pci_ids);
+
+static struct pci_driver intel_mid_pci_driver = {
+	.name = PWM_INTEL_MID_DRIVER_NAME,
+	.id_table = intel_mid_pwm_pci_ids,
+	.probe = intel_mid_pwm_probe,
+	.remove = intel_mid_pwm_remove,
+#ifdef CONFIG_PM
+	.driver = {
+		.pm = &intel_mid_pm_ops,
+	},
+#endif
+};
+
+module_pci_driver(intel_mid_pci_driver);
+
+MODULE_ALIAS("pci:" PWM_INTEL_MID_DRIVER_NAME);
+MODULE_DESCRIPTION("Intel(R) MID PWM driver");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Nicolas Pernas Maradei <nicolas.pernas.maradei@emutex.com>");
+
diff --git a/drivers/tty/serial/mfd.h b/drivers/tty/serial/mfd.h
index 22cb3f3..bc12d89 100644
--- a/drivers/tty/serial/mfd.h
+++ b/drivers/tty/serial/mfd.h
@@ -248,5 +248,5 @@ int serial_hsu_do_suspend(struct uart_hsu_port *up);
 int serial_hsu_do_resume(struct uart_hsu_port *up);
 int serial_hsu_do_runtime_idle(struct uart_hsu_port *up);
 
-#include "mfd_trace.h"
+#include <trace/mfd_trace.h>
 #endif
diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index 19722e8..019cd17 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -93,6 +93,9 @@ struct gpio_chip {
 						unsigned offset,
 						unsigned debounce);
 
+	void			(*set_pinmux)(int gpio, int alt);
+	int			(*get_pinmux)(int gpio);
+
 	int			(*to_irq)(struct gpio_chip *chip,
 						unsigned offset);
 
diff --git a/include/linux/lnw_gpio.h b/include/linux/lnw_gpio.h
index 2e9f6b2..f33a9ff 100644
--- a/include/linux/lnw_gpio.h
+++ b/include/linux/lnw_gpio.h
@@ -8,7 +8,7 @@ enum {
 	LNW_ALT_3 = 3,
 };
 
-void lnw_gpio_set_alt(int gpio, int alt);
+void intel_mid_gpio_set_alt(int gpio, int alt);
 int gpio_get_alt(int gpio);
 
 #endif
diff --git a/include/trace/mfd_trace.h b/include/trace/mfd_trace.h
new file mode 100644
index 0000000..49afd9b
--- /dev/null
+++ b/include/trace/mfd_trace.h
@@ -0,0 +1,197 @@
+#undef TRACE_INCLUDE_PATH
+#undef TRACE_INCLUDE_FILE
+#define TRACE_INCLUDE_PATH .
+#define TRACE_INCLUDE_FILE mfd_trace
+
+#define TRACE_SYSTEM hsu
+
+#if !defined(_TRACE_HSU_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_HSU_H
+
+#include <linux/tracepoint.h>
+
+#define hsucmd_name(cmd) { cmd, #cmd }
+#define show_hsucmd_name(val)			\
+	__print_symbolic(val,			\
+		hsucmd_name(qcmd_overflow),	\
+		hsucmd_name(qcmd_get_msr),	\
+		hsucmd_name(qcmd_set_mcr),	\
+		hsucmd_name(qcmd_set_ier),	\
+		hsucmd_name(qcmd_start_rx),	\
+		hsucmd_name(qcmd_stop_rx),	\
+		hsucmd_name(qcmd_start_tx),	\
+		hsucmd_name(qcmd_stop_tx),	\
+		hsucmd_name(qcmd_cl),		\
+		hsucmd_name(qcmd_port_irq),	\
+		hsucmd_name(qcmd_dma_irq),	\
+		hsucmd_name(qcmd_enable_irq),   \
+		hsucmd_name(qcmd_cmd_off))
+
+
+TRACE_EVENT(hsu_cmd_insert,
+
+	TP_PROTO(unsigned port, char cmd),
+
+	TP_ARGS(port, cmd),
+
+	TP_STRUCT__entry(
+		__field(unsigned, port)
+		__field(char, cmd)
+	),
+
+	TP_fast_assign(
+		__entry->port = port;
+		__entry->cmd = cmd;
+	),
+
+	TP_printk("port=%u cmd=%s", __entry->port,
+		show_hsucmd_name(__entry->cmd))
+);
+
+TRACE_EVENT(hsu_cmd_add,
+
+	TP_PROTO(unsigned port, char cmd),
+
+	TP_ARGS(port, cmd),
+
+	TP_STRUCT__entry(
+		__field(unsigned, port)
+		__field(char, cmd)
+	),
+
+	TP_fast_assign(
+		__entry->port = port;
+		__entry->cmd = cmd;
+	),
+
+	TP_printk("port=%u cmd=%s", __entry->port,
+		show_hsucmd_name(__entry->cmd))
+);
+
+TRACE_EVENT(hsu_cmd_start,
+
+	TP_PROTO(unsigned port, char cmd),
+
+	TP_ARGS(port, cmd),
+
+	TP_STRUCT__entry(
+		__field(unsigned, port)
+		__field(char, cmd)
+	),
+
+	TP_fast_assign(
+		__entry->port = port;
+		__entry->cmd = cmd;
+	),
+
+	TP_printk("port=%u cmd=%s", __entry->port,
+		show_hsucmd_name(__entry->cmd))
+);
+
+TRACE_EVENT(hsu_cmd_end,
+
+	TP_PROTO(unsigned port, char cmd),
+
+	TP_ARGS(port, cmd),
+
+	TP_STRUCT__entry(
+		__field(unsigned, port)
+		__field(char, cmd)
+	),
+
+	TP_fast_assign(
+		__entry->port = port;
+		__entry->cmd = cmd;
+	),
+
+	TP_printk("port=%u cmd=%s", __entry->port,
+		show_hsucmd_name(__entry->cmd))
+);
+
+TRACE_EVENT(hsu_func_start,
+
+	TP_PROTO(unsigned port, const char *func),
+
+	TP_ARGS(port, func),
+
+	TP_STRUCT__entry(
+		__field(unsigned, port)
+		__string(name, func)
+	),
+
+	TP_fast_assign(
+		__entry->port = port;
+		__assign_str(name, func);
+	),
+
+	TP_printk("port=%u func=%s", __entry->port,
+		__get_str(name))
+);
+
+TRACE_EVENT(hsu_func_end,
+
+	TP_PROTO(unsigned port, const char *func, char *err),
+
+	TP_ARGS(port, func, err),
+
+	TP_STRUCT__entry(
+		__field(unsigned, port)
+		__string(name, func)
+		__string(ret, err)
+	),
+
+	TP_fast_assign(
+		__entry->port = port;
+		__assign_str(name, func);
+		__assign_str(ret, err);
+	),
+
+	TP_printk("port=%u func=%s err=%s", __entry->port,
+		__get_str(name), __get_str(ret))
+);
+
+TRACE_EVENT(hsu_mctrl,
+
+	TP_PROTO(unsigned port, unsigned mctrl),
+
+	TP_ARGS(port, mctrl),
+
+	TP_STRUCT__entry(
+		__field(unsigned, port)
+		__field(unsigned, mctrl)
+	),
+
+	TP_fast_assign(
+		__entry->port = port;
+		__entry->mctrl = mctrl;
+	),
+
+	TP_printk("port=%u mctrl=%d", __entry->port, __entry->mctrl)
+);
+
+TRACE_EVENT(hsu_set_termios,
+
+	TP_PROTO(unsigned port, unsigned int baud, int ctsrts),
+
+	TP_ARGS(port, baud, ctsrts),
+
+	TP_STRUCT__entry(
+		__field(unsigned, port)
+		__field(unsigned int, baud)
+		__field(int, ctsrts)
+	),
+
+	TP_fast_assign(
+		__entry->port = port;
+		__entry->baud = baud;
+		__entry->ctsrts = ctsrts;
+	),
+
+	TP_printk("port=%u baud=%d ctsrts=%d", __entry->port,
+		__entry->baud, __entry->ctsrts)
+);
+
+#endif /* if !defined(_TRACE_HSU_H) || defined(TRACE_HEADER_MULTI_READ) */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
-- 
1.7.5.4

