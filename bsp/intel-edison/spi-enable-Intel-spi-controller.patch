From dff44cf56a052d936e40a2cc638bf1efc8cfcec5 Mon Sep 17 00:00:00 2001
From: Liwei Song <liwei.song@windriver.com>
Date: Tue, 1 Mar 2016 07:02:11 -0500
Subject: [PATCH 03/11] spi: enable Intel spi controller

This patch is from yocto Intel Edison support:
http://downloadmirror.intel.com/25028/eng/edison-src-ww25.5-15.tgz

This is use to enable Intel Edison spi controller

Signed-off-by: Liwei Song <liwei.song@windriver.com>
---
 arch/x86/include/asm/intel-mid.h      |    4 +
 drivers/dma/Makefile                  |    2 +-
 drivers/dma/intel_mid_dma.c           | 1279 ++++++++++++++++++------
 drivers/dma/intel_mid_dma_acpi.c      |  192 ++++
 drivers/dma/intel_mid_dma_regs.h      |  168 +++-
 drivers/spi/Kconfig                   |    9 +
 drivers/spi/Makefile                  |    1 +
 drivers/spi/intel_mid_ssp_spi.c       | 1775 +++++++++++++++++++++++++++++++++
 drivers/spi/spi-dw-mid.c              |  133 ++-
 drivers/spi/spi-dw-pci.c              |   96 ++-
 drivers/spi/spi-dw.c                  |  151 ++--
 drivers/spi/spi-dw.h                  |    7 +-
 drivers/tty/serial/mfd_dma.c          |    4 +-
 include/acpi/acpi_bus.h               |    2 +
 include/linux/intel_mid_dma.h         |    7 +
 include/linux/spi/intel_mid_ssp_spi.h |  354 +++++++
 16 files changed, 3744 insertions(+), 440 deletions(-)
 create mode 100644 drivers/dma/intel_mid_dma_acpi.c
 create mode 100644 drivers/spi/intel_mid_ssp_spi.c
 create mode 100644 include/linux/spi/intel_mid_ssp_spi.h

diff --git a/arch/x86/include/asm/intel-mid.h b/arch/x86/include/asm/intel-mid.h
index 7de28fa..149eab0 100644
--- a/arch/x86/include/asm/intel-mid.h
+++ b/arch/x86/include/asm/intel-mid.h
@@ -50,10 +50,14 @@ struct devs_id {
  * identified via MSRs.
  */
 enum intel_mid_cpu_type {
+	INTEL_CPU_CHIP_NOTMID = 0,
 	/* 1 was Moorestown */
 	INTEL_MID_CPU_CHIP_PENWELL = 2,
 	INTEL_MID_CPU_CHIP_CLOVERVIEW,
 	INTEL_MID_CPU_CHIP_TANGIER,
+	INTEL_MID_CPU_CHIP_VALLEYVIEW2,
+	INTEL_MID_CPU_CHIP_ANNIEDALE,
+	INTEL_MID_CPU_CHIP_CARBONCANYON,
 };
 
 extern enum intel_mid_cpu_type __intel_mid_cpu_chip;
diff --git a/drivers/dma/Makefile b/drivers/dma/Makefile
index a029d0f4..5aea45c 100644
--- a/drivers/dma/Makefile
+++ b/drivers/dma/Makefile
@@ -7,7 +7,7 @@ obj-$(CONFIG_DMA_ACPI) += acpi-dma.o
 obj-$(CONFIG_DMA_OF) += of-dma.o
 
 obj-$(CONFIG_NET_DMA) += iovlock.o
-obj-$(CONFIG_INTEL_MID_DMAC) += intel_mid_dma.o
+obj-$(CONFIG_INTEL_MID_DMAC) += intel_mid_dma.o intel_mid_dma_acpi.o
 obj-$(CONFIG_DMATEST) += dmatest.o
 obj-$(CONFIG_INTEL_IOATDMA) += ioat/
 obj-$(CONFIG_INTEL_IOP_ADMA) += iop-adma.o
diff --git a/drivers/dma/intel_mid_dma.c b/drivers/dma/intel_mid_dma.c
index 1aab813..b1387b5 100644
--- a/drivers/dma/intel_mid_dma.c
+++ b/drivers/dma/intel_mid_dma.c
@@ -28,34 +28,41 @@
 #include <linux/pm_runtime.h>
 #include <linux/intel_mid_dma.h>
 #include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
 
 #include "dmaengine.h"
 
-#define MAX_CHAN	4 /*max ch across controllers*/
+#define MAX_CHAN	8 /*max ch across controllers*/
 #include "intel_mid_dma_regs.h"
 
 #define INTEL_MID_DMAC1_ID		0x0814
 #define INTEL_MID_DMAC2_ID		0x0813
 #define INTEL_MID_GP_DMAC2_ID		0x0827
 #define INTEL_MFLD_DMAC1_ID		0x0830
-#define LNW_PERIPHRAL_MASK_BASE		0xFFAE8008
-#define LNW_PERIPHRAL_MASK_SIZE		0x10
-#define LNW_PERIPHRAL_STATUS		0x0
-#define LNW_PERIPHRAL_MASK		0x8
-
-struct intel_mid_dma_probe_info {
-	u8 max_chan;
-	u8 ch_base;
-	u16 block_size;
-	u32 pimr_mask;
-};
-
-#define INFO(_max_chan, _ch_base, _block_size, _pimr_mask) \
+#define INTEL_CLV_GP_DMAC2_ID		0x08EF
+#define INTEL_CLV_DMAC1_ID		0x08F0
+#define INTEL_MRFLD_GP_DMAC2_ID         0x11A2
+#define INTEL_MRFLD_DMAC0_ID		0x119B
+#define INTEL_BYT_LPIO1_DMAC_ID		0x0F06
+#define INTEL_BYT_LPIO2_DMAC_ID		0x0F40
+#define INTEL_BYT_DMAC0_ID		0x0F28
+
+#define LNW_PERIPHRAL_MASK_SIZE		0x20
+
+#define INFO(_max_chan, _ch_base, _block_size, _pimr_mask,	\
+		_pimr_base, _dword_trf, _pimr_offset, _pci_id,	\
+			_pdma_ops)				\
 	((kernel_ulong_t)&(struct intel_mid_dma_probe_info) {	\
 		.max_chan = (_max_chan),			\
 		.ch_base = (_ch_base),				\
 		.block_size = (_block_size),			\
 		.pimr_mask = (_pimr_mask),			\
+		.pimr_base = (_pimr_base),			\
+		.dword_trf = (_dword_trf),			\
+		.pimr_offset = (_pimr_offset),			\
+		.pci_id = (_pci_id),				\
+		.pdma_ops = (_pdma_ops)				\
 	})
 
 /*****************************************************************************
@@ -65,32 +72,90 @@ Utility Functions*/
  * @status: status mask
  * @base: dma ch base value
  *
- * Modify the status mask and return the channel index needing
- * attention (or -1 if neither)
+ * Returns the channel index by checking the status bits.
+ * If none of the bits in status are set, then returns -1.
  */
-static int get_ch_index(int *status, unsigned int base)
+static int get_ch_index(int status, unsigned int base)
 {
 	int i;
 	for (i = 0; i < MAX_CHAN; i++) {
-		if (*status & (1 << (i + base))) {
-			*status = *status & ~(1 << (i + base));
-			pr_debug("MDMA: index %d New status %x\n", i, *status);
+		if (status & (1 << (i + base)))
 			return i;
-		}
 	}
 	return -1;
 }
 
+static inline bool is_byt_lpio_dmac(struct middma_device *mid)
+{
+	return (mid->pci_id == INTEL_BYT_LPIO1_DMAC_ID ||
+		mid->pci_id == INTEL_BYT_LPIO2_DMAC_ID);
+}
+
+static void dump_dma_reg(struct dma_chan *chan)
+{
+	struct intel_mid_dma_chan	*midc = to_intel_mid_dma_chan(chan);
+	struct middma_device	*mid = to_middma_device(chan->device);
+
+	if (!mid->pimr_base)
+		return;
+
+	pr_debug("<<<<<<<<<<<< DMA Dump Start >>>>>>>>>>>>");
+	pr_debug("DMA Dump for Channel id:%d & Chnl Base:%p",
+					midc->ch_id, midc->ch_regs);
+	/* dump common DMA registers */
+	pr_debug("PIMR:\t%#x", readl(mid->mask_reg) - 8);
+	pr_debug("ISRX:\t%#x", readl(mid->mask_reg));
+	pr_debug("ISRD:\t%#x", readl(mid->mask_reg + 0x8));
+	pr_debug("IMRX:\t%#x", readl(mid->mask_reg + 0x10));
+	pr_debug("IMRD:\t%#x", readl(mid->mask_reg + 0x18));
+	pr_debug("DMA_CHAN_EN:\t%#x", readl(midc->dma_base + DMA_CHAN_EN));
+	pr_debug("DMA_CFG:\t%#x", readl(midc->dma_base + DMA_CFG));
+	pr_debug("INTR_STATUS:\t%#x", readl(midc->dma_base + INTR_STATUS));
+	pr_debug("MASK_TFR:\t%#x", readl(midc->dma_base + MASK_TFR));
+	pr_debug("MASK_BLOCK:\t%#x", readl(midc->dma_base + MASK_BLOCK));
+	pr_debug("MASK_ERR:\t%#x", readl(midc->dma_base + MASK_ERR));
+	pr_debug("RAW_TFR:\t%#x", readl(midc->dma_base + RAW_TFR));
+	pr_debug("RAW_BLOCK:\t%#x", readl(midc->dma_base + RAW_BLOCK));
+	pr_debug("RAW_ERR:\t%#x", readl(midc->dma_base + RAW_ERR));
+	pr_debug("STATUS_TFR:\t%#x", readl(midc->dma_base + STATUS_TFR));
+	pr_debug("STATUS_BLOCK:\t%#x", readl(midc->dma_base + STATUS_BLOCK));
+	pr_debug("STATUS_ERR:\t%#x", readl(midc->dma_base + STATUS_ERR));
+	if (!mid->dword_trf) {
+		pr_debug("FIFO_PARTITION0_LO:\t%#x",
+				readl(midc->dma_base + FIFO_PARTITION0_LO));
+		pr_debug("FIFO_PARTITION0_HI:\t%#x",
+				readl(midc->dma_base + FIFO_PARTITION0_HI));
+		pr_debug("FIFO_PARTITION1_LO:\t%#x",
+				readl(midc->dma_base + FIFO_PARTITION1_LO));
+		pr_debug("FIFO_PARTITION1_HI:\t%#x",
+				readl(midc->dma_base + FIFO_PARTITION1_HI));
+		pr_debug("CH_SAI_ERR:\t%#x", readl(midc->dma_base + CH_SAI_ERR));
+	}
+
+	/* dump channel specific registers */
+	pr_debug("SAR:\t%#x", readl(midc->ch_regs + SAR));
+	pr_debug("DAR:\t%#x", readl(midc->ch_regs + DAR));
+	pr_debug("LLP:\t%#x", readl(midc->ch_regs + LLP));
+	pr_debug("CTL_LOW:\t%#x", readl(midc->ch_regs + CTL_LOW));
+	pr_debug("CTL_HIGH:\t%#x", readl(midc->ch_regs + CTL_HIGH));
+	pr_debug("CFG_LOW:\t%#x", readl(midc->ch_regs + CFG_LOW));
+	pr_debug("CFG_HIGH:\t%#x", readl(midc->ch_regs + CFG_HIGH));
+	pr_debug("<<<<<<<<<<<< DMA Dump ends >>>>>>>>>>>>");
+}
+
 /**
  * get_block_ts	-	calculates dma transaction length
  * @len: dma transfer length
  * @tx_width: dma transfer src width
  * @block_size: dma controller max block size
+ * @dword_trf: is transfer dword size aligned and needs the data transfer to
+ *   be in terms of data items and not bytes
  *
  * Based on src width calculate the DMA trsaction length in data items
  * return data items or FFFF if exceeds max length for block
  */
-static int get_block_ts(int len, int tx_width, int block_size)
+static unsigned int get_block_ts(int len, int tx_width,
+				int block_size, int dword_trf)
 {
 	int byte_width = 0, block_ts = 0;
 
@@ -106,13 +171,46 @@ static int get_block_ts(int len, int tx_width, int block_size)
 		byte_width = 4;
 		break;
 	}
-
-	block_ts = len/byte_width;
+	if (dword_trf)
+		block_ts = len/byte_width;
+	else
+		block_ts = len;
 	if (block_ts > block_size)
 		block_ts = 0xFFFF;
 	return block_ts;
 }
 
+/**
+ * get_reg_width	-	computes the DMA sample width
+ * @kernel_width: Kernel DMA slave bus width
+ *
+ * converts the DMA kernel slave bus width in the Intel DMA
+ * bus width
+ */
+static int get_reg_width(enum dma_slave_buswidth kernel_width)
+{
+	int reg_width = -1;
+
+	switch (kernel_width) {
+	case DMA_SLAVE_BUSWIDTH_1_BYTE:
+		reg_width = 0;
+		break;
+	case DMA_SLAVE_BUSWIDTH_2_BYTES:
+		reg_width = 1;
+		break;
+	case DMA_SLAVE_BUSWIDTH_4_BYTES:
+		reg_width = 2;
+		break;
+	case DMA_SLAVE_BUSWIDTH_UNDEFINED:
+	case DMA_SLAVE_BUSWIDTH_8_BYTES:
+	default:
+		pr_err("ERR_MDMA: get_reg_width unsupported reg width\n");
+		break;
+	}
+	return reg_width;
+}
+
+
 /*****************************************************************************
 DMAC1 interrupt Functions*/
 
@@ -129,9 +227,9 @@ static void dmac1_mask_periphral_intr(struct middma_device *mid)
 	u32 pimr;
 
 	if (mid->pimr_mask) {
-		pimr = readl(mid->mask_reg + LNW_PERIPHRAL_MASK);
+		pimr = readl(mid->mask_reg + mid->pimr_offset);
 		pimr |= mid->pimr_mask;
-		writel(pimr, mid->mask_reg + LNW_PERIPHRAL_MASK);
+		writel(pimr, mid->mask_reg + mid->pimr_offset);
 	}
 	return;
 }
@@ -149,14 +247,37 @@ static void dmac1_unmask_periphral_intr(struct intel_mid_dma_chan *midc)
 	u32 pimr;
 	struct middma_device *mid = to_middma_device(midc->chan.device);
 
-	if (mid->pimr_mask) {
-		pimr = readl(mid->mask_reg + LNW_PERIPHRAL_MASK);
+	if (mid->pimr_mask && mid->dword_trf) {
+		pimr = readl(mid->mask_reg + mid->pimr_offset);
 		pimr &= ~mid->pimr_mask;
-		writel(pimr, mid->mask_reg + LNW_PERIPHRAL_MASK);
+		writel(pimr, mid->mask_reg + mid->pimr_offset);
+	}
+	if (mid->pimr_mask && !mid->dword_trf) {
+		pimr = readl(mid->mask_reg + mid->pimr_offset);
+		pimr &= ~(1 << (midc->ch_id + 16));
+		writel(pimr, mid->mask_reg + mid->pimr_offset);
 	}
 	return;
 }
 
+/*
+ * Some consumer may need to know how many bytes have been
+ * really transfered for one specific dma channel
+ */
+inline dma_addr_t intel_dma_get_src_addr(struct dma_chan *chan)
+{
+	struct intel_mid_dma_chan	*midc = to_intel_mid_dma_chan(chan);
+	return readl(midc->ch_regs + SAR);
+}
+EXPORT_SYMBOL(intel_dma_get_src_addr);
+
+inline dma_addr_t intel_dma_get_dst_addr(struct dma_chan *chan)
+{
+	struct intel_mid_dma_chan	*midc = to_intel_mid_dma_chan(chan);
+	return readl(midc->ch_regs + DAR);
+}
+EXPORT_SYMBOL(intel_dma_get_dst_addr);
+
 /**
  * enable_dma_interrupt -	enable the periphral interrupt
  * @midc: dma channel for which enable interrupt is required
@@ -167,10 +288,13 @@ static void dmac1_unmask_periphral_intr(struct intel_mid_dma_chan *midc)
  */
 static void enable_dma_interrupt(struct intel_mid_dma_chan *midc)
 {
+	struct middma_device *mid = to_middma_device(midc->chan.device);
+
 	dmac1_unmask_periphral_intr(midc);
 
 	/*en ch interrupts*/
 	iowrite32(UNMASK_INTR_REG(midc->ch_id), midc->dma_base + MASK_TFR);
+	set_bit(midc->ch_id, &mid->tfr_intr_mask);
 	iowrite32(UNMASK_INTR_REG(midc->ch_id), midc->dma_base + MASK_ERR);
 	return;
 }
@@ -185,10 +309,39 @@ static void enable_dma_interrupt(struct intel_mid_dma_chan *midc)
  */
 static void disable_dma_interrupt(struct intel_mid_dma_chan *midc)
 {
+	struct middma_device *mid = to_middma_device(midc->chan.device);
+	u32 pimr;
+
 	/*Check LPE PISR, make sure fwd is disabled*/
 	iowrite32(MASK_INTR_REG(midc->ch_id), midc->dma_base + MASK_BLOCK);
+	clear_bit(midc->ch_id, &mid->block_intr_mask);
 	iowrite32(MASK_INTR_REG(midc->ch_id), midc->dma_base + MASK_TFR);
+	clear_bit(midc->ch_id, &mid->tfr_intr_mask);
 	iowrite32(MASK_INTR_REG(midc->ch_id), midc->dma_base + MASK_ERR);
+	if (mid->pimr_mask && !mid->dword_trf) {
+		pimr = readl(mid->mask_reg + mid->pimr_offset);
+		pimr |= (1 << (midc->ch_id + 16));
+		writel(pimr, mid->mask_reg + mid->pimr_offset);
+	}
+
+	return;
+}
+
+/**
+ * clear_dma_channel_interrupt - clear channel interrupt
+ * @midc: dma channel for which clear interrupt is required
+ *
+ */
+static void clear_dma_channel_interrupt(struct intel_mid_dma_chan *midc)
+{
+	struct middma_device *mid = to_middma_device(midc->chan.device);
+
+	/*clearing this interrupts first*/
+	iowrite32((1 << midc->ch_id), mid->dma_base + CLEAR_TFR);
+	iowrite32((1 << midc->ch_id), mid->dma_base + CLEAR_BLOCK);
+	iowrite32((1 << midc->ch_id), mid->dma_base + CLEAR_ERR);
+
+
 	return;
 }
 
@@ -243,7 +396,7 @@ static void midc_desc_put(struct intel_mid_dma_chan *midc,
  * Load a transaction into the engine. This must be called with midc->lock
  * held and bh disabled.
  */
-static void midc_dostart(struct intel_mid_dma_chan *midc,
+static int midc_dostart(struct intel_mid_dma_chan *midc,
 			struct intel_mid_dma_desc *first)
 {
 	struct middma_device *mid = to_middma_device(midc->chan.device);
@@ -253,7 +406,7 @@ static void midc_dostart(struct intel_mid_dma_chan *midc,
 		/*error*/
 		pr_err("ERR_MDMA: channel is busy in start\n");
 		/* The tasklet will hopefully advance the queue... */
-		return;
+		return -EBUSY;
 	}
 	midc->busy = true;
 	/*write registers and en*/
@@ -264,12 +417,13 @@ static void midc_dostart(struct intel_mid_dma_chan *midc,
 	iowrite32(first->cfg_lo, midc->ch_regs + CFG_LOW);
 	iowrite32(first->ctl_lo, midc->ch_regs + CTL_LOW);
 	iowrite32(first->ctl_hi, midc->ch_regs + CTL_HIGH);
-	pr_debug("MDMA:TX SAR %x,DAR %x,CFGL %x,CFGH %x,CTLH %x, CTLL %x\n",
+	pr_debug("MDMA:TX SAR %x,DAR %x,CFGH %x,CFGL %x,CTLH %x, CTLL %x LLI %x",
 		(int)first->sar, (int)first->dar, first->cfg_hi,
-		first->cfg_lo, first->ctl_hi, first->ctl_lo);
+		first->cfg_lo, first->ctl_hi, first->ctl_lo, (int)first->lli_phys);
 	first->status = DMA_IN_PROGRESS;
 
 	iowrite32(ENABLE_CHANNEL(midc->ch_id), mid->dma_base + DMA_CHAN_EN);
+	return 0;
 }
 
 /**
@@ -303,46 +457,65 @@ static void midc_descriptor_complete(struct intel_mid_dma_chan *midc,
 		else
 			desc->current_lli = 0;
 	}
-	spin_unlock_bh(&midc->lock);
-	if (callback_txd) {
-		pr_debug("MDMA: TXD callback set ... calling\n");
-		callback_txd(param_txd);
-	}
 	if (midc->raw_tfr) {
+		list_del(&desc->desc_node);
 		desc->status = DMA_COMPLETE;
-		if (desc->lli != NULL) {
-			pci_pool_free(desc->lli_pool, desc->lli,
+		if (desc->lli != NULL && desc->lli->llp != 0)
+			dma_pool_free(desc->lli_pool, desc->lli,
 						desc->lli_phys);
-			pci_pool_destroy(desc->lli_pool);
-			desc->lli = NULL;
-		}
-		list_move(&desc->desc_node, &midc->free_list);
+		list_add(&desc->desc_node, &midc->free_list);
 		midc->busy = false;
+		midc->raw_tfr = 0;
+		spin_unlock_bh(&midc->lock);
+	} else {
+		spin_unlock_bh(&midc->lock);
+	}
+	if (callback_txd) {
+		pr_debug("MDMA: TXD callback set ... calling\n");
+		callback_txd(param_txd);
 	}
+
 	spin_lock_bh(&midc->lock);
+}
 
+static struct
+intel_mid_dma_desc *midc_first_queued(struct intel_mid_dma_chan *midc)
+{
+	return list_entry(midc->queue.next, struct intel_mid_dma_desc, desc_node);
 }
-/**
- * midc_scan_descriptors -		check the descriptors in channel
- *					mark completed when tx is completete
- * @mid: device
- * @midc: channel to scan
- *
- * Walk the descriptor chain for the device and process any entries
- * that are complete.
- */
-static void midc_scan_descriptors(struct middma_device *mid,
+
+static void midc_collect_descriptors(struct middma_device *mid,
 				struct intel_mid_dma_chan *midc)
 {
 	struct intel_mid_dma_desc *desc = NULL, *_desc = NULL;
-
 	/*tx is complete*/
 	list_for_each_entry_safe(desc, _desc, &midc->active_list, desc_node) {
 		if (desc->status == DMA_IN_PROGRESS)
 			midc_descriptor_complete(midc, desc);
 	}
-	return;
+
+}
+
+/**
+ * midc_start_descriptors -		start the descriptors in queue
+ *
+ * @mid: device
+ * @midc: channel to scan
+ *
+ */
+static void midc_start_descriptors(struct middma_device *mid,
+				struct intel_mid_dma_chan *midc)
+{
+	if (!list_empty(&midc->queue)) {
+		pr_debug("MDMA: submitting txn in queue\n");
+		if (0 == midc_dostart(midc, midc_first_queued(midc)))
+			list_splice_init(&midc->queue, &midc->active_list);
+		else
+			pr_warn("Submit failed as ch is busy\n");
 	}
+	return;
+}
+
 /**
  * midc_lli_fill_sg -		Helper function to convert
  *				SG list to Linked List Items.
@@ -357,7 +530,8 @@ static void midc_scan_descriptors(struct middma_device *mid,
  */
 static int midc_lli_fill_sg(struct intel_mid_dma_chan *midc,
 				struct intel_mid_dma_desc *desc,
-				struct scatterlist *sglist,
+				struct scatterlist *src_sglist,
+				struct scatterlist *dst_sglist,
 				unsigned int sglen,
 				unsigned int flags)
 {
@@ -366,18 +540,18 @@ static int midc_lli_fill_sg(struct intel_mid_dma_chan *midc,
 	dma_addr_t lli_next, sg_phy_addr;
 	struct intel_mid_dma_lli *lli_bloc_desc;
 	union intel_mid_dma_ctl_lo ctl_lo;
-	union intel_mid_dma_ctl_hi ctl_hi;
+	u32 ctl_hi;
 	int i;
 
-	pr_debug("MDMA: Entered midc_lli_fill_sg\n");
+	pr_debug("MDMA: Entered %s\n", __func__);
 	mids = midc->mid_slave;
 
 	lli_bloc_desc = desc->lli;
 	lli_next = desc->lli_phys;
 
 	ctl_lo.ctl_lo = desc->ctl_lo;
-	ctl_hi.ctl_hi = desc->ctl_hi;
-	for_each_sg(sglist, sg, sglen, i) {
+	ctl_hi = desc->ctl_hi;
+	for_each_sg(src_sglist, sg, sglen, i) {
 		/*Populate CTL_LOW and LLI values*/
 		if (i != sglen - 1) {
 			lli_next = lli_next +
@@ -389,29 +563,37 @@ static int midc_lli_fill_sg(struct intel_mid_dma_chan *midc,
 				lli_next = desc->lli_phys;
 			} else {
 				lli_next = 0;
-				ctl_lo.ctlx.llp_dst_en = 0;
-				ctl_lo.ctlx.llp_src_en = 0;
+				/* llp_dst_en = 0 llp_src_en = 0 */
+				ctl_lo.ctl_lo &= ~(1 << CTL_LO_BIT_LLP_DST_EN);
+				ctl_lo.ctl_lo &= ~(1 << CTL_LO_BIT_LLP_SRC_EN);
 			}
 		}
 		/*Populate CTL_HI values*/
-		ctl_hi.ctlx.block_ts = get_block_ts(sg_dma_len(sg),
-							desc->width,
-							midc->dma->block_size);
+		ctl_hi = get_block_ts(sg->length, desc->width,
+					midc->dma->block_size, midc->dma->dword_trf);
 		/*Populate SAR and DAR values*/
-		sg_phy_addr = sg_dma_address(sg);
+		sg_phy_addr = sg_phys(sg);
 		if (desc->dirn ==  DMA_MEM_TO_DEV) {
 			lli_bloc_desc->sar  = sg_phy_addr;
 			lli_bloc_desc->dar  = mids->dma_slave.dst_addr;
 		} else if (desc->dirn ==  DMA_DEV_TO_MEM) {
 			lli_bloc_desc->sar  = mids->dma_slave.src_addr;
 			lli_bloc_desc->dar  = sg_phy_addr;
+		} else if (desc->dirn == DMA_MEM_TO_MEM && dst_sglist) {
+				lli_bloc_desc->sar = sg_phy_addr;
+				lli_bloc_desc->dar = sg_phys(dst_sglist);
 		}
 		/*Copy values into block descriptor in system memroy*/
 		lli_bloc_desc->llp = lli_next;
 		lli_bloc_desc->ctl_lo = ctl_lo.ctl_lo;
-		lli_bloc_desc->ctl_hi = ctl_hi.ctl_hi;
+		lli_bloc_desc->ctl_hi = ctl_hi;
 
+		pr_debug("MDMA:Calc CTL LO %x, CTL HI %x src: %x dest: %x sg->l:%x\n",
+					ctl_lo.ctl_lo, lli_bloc_desc->ctl_hi,
+					lli_bloc_desc->sar, lli_bloc_desc->dar, sg->length);
 		lli_bloc_desc++;
+		if (dst_sglist)
+			dst_sglist = sg_next(dst_sglist);
 	}
 	/*Copy very first LLI values to descriptor*/
 	desc->ctl_lo = desc->lli->ctl_lo;
@@ -421,13 +603,14 @@ static int midc_lli_fill_sg(struct intel_mid_dma_chan *midc,
 
 	return 0;
 }
+
 /*****************************************************************************
 DMA engine callback Functions*/
 /**
  * intel_mid_dma_tx_submit -	callback to submit DMA transaction
  * @tx: dma engine descriptor
  *
- * Submit the DMA transaction for this descriptor, start if ch idle
+ * Submit the DMA trasaction for this descriptor, start if ch idle
  */
 static dma_cookie_t intel_mid_dma_tx_submit(struct dma_async_tx_descriptor *tx)
 {
@@ -436,6 +619,14 @@ static dma_cookie_t intel_mid_dma_tx_submit(struct dma_async_tx_descriptor *tx)
 	dma_cookie_t		cookie;
 
 	spin_lock_bh(&midc->lock);
+
+	if (unlikely(!midc->in_use)) {
+		spin_unlock_bh(&midc->lock);
+		WARN(1, "chan[%d] gets new request after close",
+			tx->chan->chan_id);
+		return -EIO;
+	}
+
 	cookie = dma_cookie_assign(tx);
 
 	if (list_empty(&midc->active_list))
@@ -461,11 +652,74 @@ static void intel_mid_dma_issue_pending(struct dma_chan *chan)
 
 	spin_lock_bh(&midc->lock);
 	if (!list_empty(&midc->queue))
-		midc_scan_descriptors(to_middma_device(chan->device), midc);
+		midc_start_descriptors(to_middma_device(chan->device), midc);
 	spin_unlock_bh(&midc->lock);
 }
 
 /**
+ * dma_wait_for_suspend - performs following functionality
+ * 		1. Suspends channel using mask bits
+ * 		2. Wait till FIFO to get empty
+ * 		3. Disable channel
+ * 		4. restore the previous masked bits
+ *
+ * @chan: chan where pending trascation needs to be checked and submitted
+ * @mask: mask bits to be used for suspend operation
+ *
+ */
+static inline void dma_wait_for_suspend(struct dma_chan *chan, unsigned int mask)
+{
+	union intel_mid_dma_cfg_lo cfg_lo;
+	struct middma_device	*mid = to_middma_device(chan->device);
+	struct intel_mid_dma_chan	*midc = to_intel_mid_dma_chan(chan);
+	int i;
+
+	/* Suspend channel */
+	cfg_lo.cfg_lo = ioread32(midc->ch_regs + CFG_LOW);
+	cfg_lo.cfg_lo |= mask;
+	iowrite32(cfg_lo.cfg_lo, midc->ch_regs + CFG_LOW);
+	/* wait till FIFO gets empty */
+	/* FIFO should be cleared in couple of milli secs */
+	for (i = 0; i < 10; i++) {
+		cfg_lo.cfg_lo = ioread32(midc->ch_regs + CFG_LOW);
+		if (cfg_lo.cfgx.fifo_empty)
+			break;
+	/* use delay since this might called from atomic context */
+		mdelay(1);
+	}
+	pr_debug("waited for %d ms for FIFO to get empty", i);
+	iowrite32(DISABLE_CHANNEL(midc->ch_id), mid->dma_base + DMA_CHAN_EN);
+
+	cfg_lo.cfg_lo = ioread32(midc->ch_regs + CFG_LOW);
+	cfg_lo.cfg_lo &= ~mask;
+	iowrite32(cfg_lo.cfg_lo, midc->ch_regs + CFG_LOW);
+}
+/**
+ * intel_mid_dma_chan_suspend_v1 - suspends the given channel, waits
+ *		till FIFO is cleared and disables channel.
+ * @chan: chan where pending trascation needs to be checked and submitted
+ *
+ */
+static void intel_mid_dma_chan_suspend_v1(struct dma_chan *chan)
+{
+
+	pr_debug("%s", __func__);
+	dma_wait_for_suspend(chan, CH_SUSPEND);
+}
+
+/**
+ * intel_mid_dma_chan_suspend_v2 - suspends the given channel, waits
+ *		till FIFO is cleared and disables channel.
+ * @chan: chan where pending trascation needs to be checked and submitted
+ *
+ */
+static void intel_mid_dma_chan_suspend_v2(struct dma_chan *chan)
+{
+	pr_debug("%s", __func__);
+	dma_wait_for_suspend(chan, CH_SUSPEND | CH_DRAIN);
+}
+
+/**
  * intel_mid_dma_tx_status -	Return status of txn
  * @chan: chan for where status needs to be checked
  * @cookie: cookie for txn
@@ -483,7 +737,7 @@ static enum dma_status intel_mid_dma_tx_status(struct dma_chan *chan,
 	ret = dma_cookie_status(chan, cookie, txstate);
 	if (ret != DMA_COMPLETE) {
 		spin_lock_bh(&midc->lock);
-		midc_scan_descriptors(to_middma_device(chan->device), midc);
+		midc_start_descriptors(to_middma_device(chan->device), midc);
 		spin_unlock_bh(&midc->lock);
 
 		ret = dma_cookie_status(chan, cookie, txstate);
@@ -509,6 +763,7 @@ static int dma_slave_control(struct dma_chan *chan, unsigned long arg)
 	midc->mid_slave = mid_slave;
 	return 0;
 }
+
 /**
  * intel_mid_dma_device_control -	DMA device control
  * @chan: chan for DMA control
@@ -523,8 +778,8 @@ static int intel_mid_dma_device_control(struct dma_chan *chan,
 	struct intel_mid_dma_chan	*midc = to_intel_mid_dma_chan(chan);
 	struct middma_device	*mid = to_middma_device(chan->device);
 	struct intel_mid_dma_desc	*desc, *_desc;
-	union intel_mid_dma_cfg_lo cfg_lo;
 
+	pr_debug("%s:CMD:%d for channel:%d\n", __func__, cmd, midc->ch_id);
 	if (cmd == DMA_SLAVE_CONFIG)
 		return dma_slave_control(chan, arg);
 
@@ -536,30 +791,25 @@ static int intel_mid_dma_device_control(struct dma_chan *chan,
 		spin_unlock_bh(&midc->lock);
 		return 0;
 	}
-	/*Suspend and disable the channel*/
-	cfg_lo.cfg_lo = ioread32(midc->ch_regs + CFG_LOW);
-	cfg_lo.cfgx.ch_susp = 1;
-	iowrite32(cfg_lo.cfg_lo, midc->ch_regs + CFG_LOW);
-	iowrite32(DISABLE_CHANNEL(midc->ch_id), mid->dma_base + DMA_CHAN_EN);
-	midc->busy = false;
-	/* Disable interrupts */
+	/* Disable CH interrupts */
 	disable_dma_interrupt(midc);
+	/* clear channel interrupts */
+	clear_dma_channel_interrupt(midc);
+	mid->dma_ops.dma_chan_suspend(chan);
+	midc->busy = false;
 	midc->descs_allocated = 0;
-
-	spin_unlock_bh(&midc->lock);
 	list_for_each_entry_safe(desc, _desc, &midc->active_list, desc_node) {
-		if (desc->lli != NULL) {
-			pci_pool_free(desc->lli_pool, desc->lli,
+		list_del(&desc->desc_node);
+		if (desc->lli != NULL)
+			dma_pool_free(desc->lli_pool, desc->lli,
 						desc->lli_phys);
-			pci_pool_destroy(desc->lli_pool);
-			desc->lli = NULL;
-		}
-		list_move(&desc->desc_node, &midc->free_list);
+		list_add(&desc->desc_node, &midc->free_list);
 	}
+	spin_unlock_bh(&midc->lock);
+
 	return 0;
 }
 
-
 /**
  * intel_mid_dma_prep_memcpy -	Prep memcpy txn
  * @chan: chan for DMA transfer
@@ -580,10 +830,12 @@ static struct dma_async_tx_descriptor *intel_mid_dma_prep_memcpy(
 	struct intel_mid_dma_desc *desc = NULL;
 	struct intel_mid_dma_slave *mids;
 	union intel_mid_dma_ctl_lo ctl_lo;
-	union intel_mid_dma_ctl_hi ctl_hi;
+	u32 ctl_hi;
 	union intel_mid_dma_cfg_lo cfg_lo;
 	union intel_mid_dma_cfg_hi cfg_hi;
 	enum dma_slave_buswidth width;
+	int dst_reg_width = 0;
+	int src_reg_width = 0;
 
 	pr_debug("MDMA: Prep for memcpy\n");
 	BUG_ON(!chan);
@@ -596,6 +848,11 @@ static struct dma_async_tx_descriptor *intel_mid_dma_prep_memcpy(
 	mids = midc->mid_slave;
 	BUG_ON(!mids);
 
+	if (unlikely(!midc->in_use)) {
+		pr_err("ERR_MDMA: %s: channel not in use", __func__);
+		return NULL;
+	}
+
 	pr_debug("MDMA:called for DMA %x CH %d Length %zu\n",
 				midc->dma->pci_id, midc->ch_id, len);
 	pr_debug("MDMA:Cfg passed Mode %x, Dirn %x, HS %x, Width %x\n",
@@ -634,36 +891,41 @@ static struct dma_async_tx_descriptor *intel_mid_dma_prep_memcpy(
 			}
 		} else {
 			cfg_hi.cfgx.protctl = 0x1; /*default value*/
-			cfg_hi.cfgx.src_per = cfg_hi.cfgx.dst_per =
+			/* Baytrail DMAC uses dynamic device instance */
+			if (is_byt_lpio_dmac(midc->dma))
+				cfg_hi.cfgx.src_per = cfg_hi.cfgx.dst_per =
+					mids->device_instance;
+			else
+				cfg_hi.cfgx.src_per = cfg_hi.cfgx.dst_per =
 					midc->ch_id - midc->dma->chan_base;
 		}
 	}
-
 	/*calculate CTL_HI*/
-	ctl_hi.ctlx.reser = 0;
-	ctl_hi.ctlx.done  = 0;
 	width = mids->dma_slave.src_addr_width;
-
-	ctl_hi.ctlx.block_ts = get_block_ts(len, width, midc->dma->block_size);
+	ctl_hi = get_block_ts(len, width, midc->dma->block_size, midc->dma->dword_trf);
 	pr_debug("MDMA:calc len %d for block size %d\n",
-				ctl_hi.ctlx.block_ts, midc->dma->block_size);
+				ctl_hi, midc->dma->block_size);
 	/*calculate CTL_LO*/
 	ctl_lo.ctl_lo = 0;
 	ctl_lo.ctlx.int_en = 1;
+
+	dst_reg_width = get_reg_width(mids->dma_slave.dst_addr_width);
+	if (dst_reg_width < 0) {
+		pr_err("ERR_MDMA: Failed to get DST reg width\n");
+		return NULL;
+
+	}
+	ctl_lo.ctlx.dst_tr_width = dst_reg_width;
+
+	src_reg_width = get_reg_width(mids->dma_slave.src_addr_width);
+	if (src_reg_width < 0) {
+		pr_err("ERR_MDMA: Failed to get SRC reg width\n");
+				return NULL;
+	}
+	ctl_lo.ctlx.src_tr_width = src_reg_width;
 	ctl_lo.ctlx.dst_msize = mids->dma_slave.src_maxburst;
 	ctl_lo.ctlx.src_msize = mids->dma_slave.dst_maxburst;
 
-	/*
-	 * Here we need some translation from "enum dma_slave_buswidth"
-	 * to the format for our dma controller
-	 *		standard	intel_mid_dmac's format
-	 *		 1 Byte			0b000
-	 *		 2 Bytes		0b001
-	 *		 4 Bytes		0b010
-	 */
-	ctl_lo.ctlx.dst_tr_width = mids->dma_slave.dst_addr_width / 2;
-	ctl_lo.ctlx.src_tr_width = mids->dma_slave.src_addr_width / 2;
-
 	if (mids->cfg_mode == LNW_DMA_MEM_TO_MEM) {
 		ctl_lo.ctlx.tt_fc = 0;
 		ctl_lo.ctlx.sinc = 0;
@@ -681,7 +943,7 @@ static struct dma_async_tx_descriptor *intel_mid_dma_prep_memcpy(
 	}
 
 	pr_debug("MDMA:Calc CTL LO %x, CTL HI %x, CFG LO %x, CFG HI %x\n",
-		ctl_lo.ctl_lo, ctl_hi.ctl_hi, cfg_lo.cfg_lo, cfg_hi.cfg_hi);
+		ctl_lo.ctl_lo, ctl_hi, cfg_lo.cfg_lo, cfg_hi.cfg_hi);
 
 	enable_dma_interrupt(midc);
 
@@ -694,7 +956,7 @@ static struct dma_async_tx_descriptor *intel_mid_dma_prep_memcpy(
 	desc->cfg_hi = cfg_hi.cfg_hi;
 	desc->cfg_lo = cfg_lo.cfg_lo;
 	desc->ctl_lo = ctl_lo.ctl_lo;
-	desc->ctl_hi = ctl_hi.ctl_hi;
+	desc->ctl_hi = ctl_hi;
 	desc->width = width;
 	desc->dirn = mids->dma_slave.direction;
 	desc->lli_phys = 0;
@@ -707,59 +969,193 @@ err_desc_get:
 	midc_desc_put(midc, desc);
 	return NULL;
 }
+
 /**
- * intel_mid_dma_prep_slave_sg -	Prep slave sg txn
+ * intel_mid_dma_prep_memcpy_v2 - Prep memcpy txn
  * @chan: chan for DMA transfer
- * @sgl: scatter gather list
- * @sg_len: length of sg txn
- * @direction: DMA transfer dirtn
+ * @dest: destn address
+ * @src: src address
+ * @len: DMA transfer len
  * @flags: DMA flags
- * @context: transfer context (ignored)
+ *
+ * Perform a DMA memcpy. Note we support slave periphral DMA transfers only
+ * The periphral txn details should be filled in slave structure properly
+ * Returns the descriptor for this txn
+ */
+static struct dma_async_tx_descriptor *intel_mid_dma_prep_memcpy_v2(
+			struct dma_chan *chan, dma_addr_t dest,
+			dma_addr_t src, size_t len, unsigned long flags)
+{
+	struct intel_mid_dma_chan *midc;
+	struct intel_mid_dma_desc *desc = NULL;
+	struct intel_mid_dma_slave *mids;
+	union intel_mid_dma_ctl_lo ctl_lo;
+	u32 ctl_hi;
+	union intel_mid_dma_cfg_lo cfg_lo;
+	union intel_mid_dma_cfg_hi cfg_hi;
+	enum dma_slave_buswidth width;
+	int dst_reg_width = 0;
+	int src_reg_width = 0;
+
+	pr_debug("MDMA:%s\n", __func__);
+	BUG_ON(!chan);
+	if (!len)
+		return NULL;
+
+	midc = to_intel_mid_dma_chan(chan);
+	BUG_ON(!midc);
+
+	mids = midc->mid_slave;
+	BUG_ON(!mids);
+
+	if (unlikely(!midc->in_use)) {
+		pr_err("ERR_MDMA: %s: channel not in use", __func__);
+		return NULL;
+	}
+
+	pr_debug("MDMA:called for DMA %x CH %d Length %zu\n",
+				midc->dma->pci_id, midc->ch_id, len);
+	pr_debug("MDMA:Cfg passed Mode %x, Dirn %x, HS %x, Width %x\n",
+			mids->cfg_mode, mids->dma_slave.direction,
+			mids->hs_mode, mids->dma_slave.src_addr_width);
+
+	/*calculate CFG_LO*/
+	cfg_lo.cfgx_v2.dst_burst_align = 1;
+	cfg_lo.cfgx_v2.src_burst_align = 1;
+
+	/*calculate CFG_HI*/
+	if (mids->cfg_mode == LNW_DMA_MEM_TO_MEM) {
+		/*SW HS only*/
+		cfg_hi.cfg_hi = 0;
+	} else {
+		cfg_hi.cfg_hi = 0;
+		if (midc->dma->pimr_mask) {
+			if (mids->dma_slave.direction == DMA_MEM_TO_DEV) {
+				cfg_hi.cfgx_v2.src_per = 0;
+				if (mids->device_instance == 0)
+					cfg_hi.cfgx_v2.dst_per = 1;
+				if (mids->device_instance == 1)
+					cfg_hi.cfgx_v2.dst_per = 3;
+			} else if (mids->dma_slave.direction == DMA_DEV_TO_MEM) {
+				if (mids->device_instance == 0)
+					cfg_hi.cfgx_v2.src_per = 0;
+				if (mids->device_instance == 1)
+					cfg_hi.cfgx_v2.src_per = 2;
+				cfg_hi.cfgx_v2.dst_per = 0;
+			}
+		} else {
+			cfg_hi.cfgx_v2.src_per = cfg_hi.cfgx_v2.dst_per =
+					midc->ch_id - midc->dma->chan_base;
+		}
+	}
+	/*calculate CTL_HI*/
+	width = mids->dma_slave.src_addr_width;
+	ctl_hi = get_block_ts(len, width, midc->dma->block_size, midc->dma->dword_trf);
+	pr_debug("MDMA:calc len %d for block size %d\n",
+				ctl_hi, midc->dma->block_size);
+	/*calculate CTL_LO*/
+	ctl_lo.ctl_lo = 0;
+	ctl_lo.ctlx_v2.int_en = 1;
+
+	dst_reg_width = get_reg_width(mids->dma_slave.dst_addr_width);
+	if (dst_reg_width < 0) {
+		pr_err("ERR_MDMA: Failed to get DST reg width\n");
+		return NULL;
+
+	}
+	ctl_lo.ctlx_v2.dst_tr_width = dst_reg_width;
+
+	src_reg_width = get_reg_width(mids->dma_slave.src_addr_width);
+	if (src_reg_width < 0) {
+		pr_err("ERR_MDMA: Failed to get SRC reg width\n");
+				return NULL;
+	}
+	ctl_lo.ctlx_v2.src_tr_width = src_reg_width;
+	ctl_lo.ctlx_v2.dst_msize = mids->dma_slave.src_maxburst;
+	ctl_lo.ctlx_v2.src_msize = mids->dma_slave.dst_maxburst;
+
+	if (mids->cfg_mode == LNW_DMA_MEM_TO_MEM) {
+		ctl_lo.ctlx_v2.tt_fc = 0;
+		ctl_lo.ctlx_v2.sinc = 0;
+		ctl_lo.ctlx_v2.dinc = 0;
+	} else {
+		if (mids->dma_slave.direction == DMA_MEM_TO_DEV) {
+			ctl_lo.ctlx_v2.sinc = 0;
+			ctl_lo.ctlx_v2.dinc = 1;
+			ctl_lo.ctlx_v2.tt_fc = 1;
+		} else if (mids->dma_slave.direction == DMA_DEV_TO_MEM) {
+			ctl_lo.ctlx_v2.sinc = 1;
+			ctl_lo.ctlx_v2.dinc = 0;
+			ctl_lo.ctlx_v2.tt_fc = 2;
+		}
+	}
+
+	pr_debug("MDMA:Calc CTL LO %x, CTL HI %x, CFG LO %x, CFG HI %x\n",
+		ctl_lo.ctl_lo, ctl_hi, cfg_lo.cfg_lo, cfg_hi.cfg_hi);
+
+	enable_dma_interrupt(midc);
+
+	desc = midc_desc_get(midc);
+	if (desc == NULL)
+		goto err_desc_get;
+	desc->sar = src;
+	desc->dar = dest ;
+	desc->len = len;
+	desc->cfg_hi = cfg_hi.cfg_hi;
+	desc->cfg_lo = cfg_lo.cfg_lo;
+	desc->ctl_lo = ctl_lo.ctl_lo;
+	desc->ctl_hi = ctl_hi;
+	desc->width = width;
+	desc->dirn = mids->dma_slave.direction;
+	desc->lli_phys = 0;
+	desc->lli = NULL;
+	desc->lli_pool = NULL;
+	return &desc->txd;
+
+err_desc_get:
+	pr_err("ERR_MDMA: Failed to get desc\n");
+	midc_desc_put(midc, desc);
+	return NULL;
+}
+
+/**
+ * intel_mid_dma_chan_prep_desc
+ * @chan: chan for DMA transfer
+ * @src_sg: destination scatter gather list
+ * @dst_sg: source scatter gather list
+ * @flags: DMA flags
+ * @src_sg_len: length of src sg list
+ * @direction DMA transfer dirtn
  *
  * Prepares LLI based periphral transfer
  */
-static struct dma_async_tx_descriptor *intel_mid_dma_prep_slave_sg(
-			struct dma_chan *chan, struct scatterlist *sgl,
-			unsigned int sg_len, enum dma_transfer_direction direction,
-			unsigned long flags, void *context)
+static struct dma_async_tx_descriptor *intel_mid_dma_chan_prep_desc(
+			struct dma_chan *chan, struct scatterlist *src_sg,
+			struct scatterlist *dst_sg, unsigned long flags,
+			unsigned long src_sg_len,
+			enum dma_transfer_direction direction)
 {
+	struct middma_device *mid = NULL;
 	struct intel_mid_dma_chan *midc = NULL;
 	struct intel_mid_dma_slave *mids = NULL;
 	struct intel_mid_dma_desc *desc = NULL;
 	struct dma_async_tx_descriptor *txd = NULL;
 	union intel_mid_dma_ctl_lo ctl_lo;
+	pr_debug("MDMA:intel_mid_dma_chan_prep_desc\n");
 
-	pr_debug("MDMA: Prep for slave SG\n");
-
-	if (!sg_len) {
-		pr_err("MDMA: Invalid SG length\n");
-		return NULL;
-	}
 	midc = to_intel_mid_dma_chan(chan);
 	BUG_ON(!midc);
 
+	mid = to_middma_device(midc->chan.device);
 	mids = midc->mid_slave;
 	BUG_ON(!mids);
 
 	if (!midc->dma->pimr_mask) {
-		/* We can still handle sg list with only one item */
-		if (sg_len == 1) {
-			txd = intel_mid_dma_prep_memcpy(chan,
-						mids->dma_slave.dst_addr,
-						mids->dma_slave.src_addr,
-						sg_dma_len(sgl),
-						flags);
-			return txd;
-		} else {
-			pr_warn("MDMA: SG list is not supported by this controller\n");
-			return  NULL;
-		}
+		pr_err("MDMA: SG list is not supported by this controller\n");
+		return  NULL;
 	}
 
-	pr_debug("MDMA: SG Length = %d, direction = %d, Flags = %#lx\n",
-			sg_len, direction, flags);
-
-	txd = intel_mid_dma_prep_memcpy(chan, 0, 0, sg_dma_len(sgl), flags);
+	txd = midc->dma->dma_ops.device_prep_dma_memcpy(chan, 0, 0, src_sg->length, flags);
 	if (NULL == txd) {
 		pr_err("MDMA: Prep memcpy failed\n");
 		return NULL;
@@ -768,35 +1164,113 @@ static struct dma_async_tx_descriptor *intel_mid_dma_prep_slave_sg(
 	desc = to_intel_mid_dma_desc(txd);
 	desc->dirn = direction;
 	ctl_lo.ctl_lo = desc->ctl_lo;
-	ctl_lo.ctlx.llp_dst_en = 1;
-	ctl_lo.ctlx.llp_src_en = 1;
+	ctl_lo.ctl_lo |= (1 << CTL_LO_BIT_LLP_DST_EN);
+	ctl_lo.ctl_lo |= (1 << CTL_LO_BIT_LLP_SRC_EN);
 	desc->ctl_lo = ctl_lo.ctl_lo;
-	desc->lli_length = sg_len;
+	desc->lli_length = src_sg_len;
 	desc->current_lli = 0;
 	/* DMA coherent memory pool for LLI descriptors*/
-	desc->lli_pool = pci_pool_create("intel_mid_dma_lli_pool",
-				midc->dma->pdev,
-				(sizeof(struct intel_mid_dma_lli)*sg_len),
+	desc->lli_pool = dma_pool_create("intel_mid_dma_lli_pool",
+				midc->dma->dev,
+				(sizeof(struct intel_mid_dma_lli)*src_sg_len),
 				32, 0);
 	if (NULL == desc->lli_pool) {
 		pr_err("MID_DMA:LLI pool create failed\n");
 		return NULL;
 	}
+	midc->lli_pool = desc->lli_pool;
 
-	desc->lli = pci_pool_alloc(desc->lli_pool, GFP_KERNEL, &desc->lli_phys);
+	desc->lli = dma_pool_alloc(desc->lli_pool, GFP_KERNEL, &desc->lli_phys);
 	if (!desc->lli) {
 		pr_err("MID_DMA: LLI alloc failed\n");
-		pci_pool_destroy(desc->lli_pool);
+		dma_pool_destroy(desc->lli_pool);
 		return NULL;
 	}
-
-	midc_lli_fill_sg(midc, desc, sgl, sg_len, flags);
+	midc_lli_fill_sg(midc, desc, src_sg, dst_sg, src_sg_len, flags);
 	if (flags & DMA_PREP_INTERRUPT) {
+		/* Enable Block intr, disable TFR intr.
+		* It's not required to enable TFR, when Block intr is enabled
+		* Otherwise, for last block we will end up in invoking calltxd
+		* two times */
+
+		iowrite32(MASK_INTR_REG(midc->ch_id),
+					midc->dma_base + MASK_TFR);
+		clear_bit(midc->ch_id, &mid->tfr_intr_mask);
 		iowrite32(UNMASK_INTR_REG(midc->ch_id),
-				midc->dma_base + MASK_BLOCK);
-		pr_debug("MDMA:Enabled Block interrupt\n");
+					midc->dma_base + MASK_BLOCK);
+		set_bit(midc->ch_id, &mid->block_intr_mask);
+		midc->block_intr_status = true;
+		pr_debug("MDMA: Enabled Block Interrupt\n");
 	}
 	return &desc->txd;
+
+}
+
+/**
+ * intel_mid_dma_prep_sg -        Prep sg txn
+ * @chan: chan for DMA transfer
+ * @dst_sg: destination scatter gather list
+ * @dst_sg_len: length of dest sg list
+ * @src_sg: source scatter gather list
+ * @src_sg_len: length of src sg list
+ * @flags: DMA flags
+ *
+ * Prepares LLI based periphral transfer
+ */
+static struct dma_async_tx_descriptor *intel_mid_dma_prep_sg(
+			struct dma_chan *chan, struct scatterlist *dst_sg,
+			unsigned int dst_sg_len, struct scatterlist *src_sg,
+			unsigned int src_sg_len, unsigned long flags)
+{
+
+	pr_debug("MDMA: Prep for memcpy SG\n");
+
+	if ((dst_sg_len != src_sg_len) || (dst_sg == NULL) ||
+							(src_sg == NULL)) {
+		pr_err("MDMA: Invalid SG length\n");
+		return NULL;
+	}
+
+	pr_debug("MDMA: SG Length = %d, Flags = %#lx, src_sg->length = %d\n",
+				src_sg_len, flags, src_sg->length);
+
+	return intel_mid_dma_chan_prep_desc(chan, src_sg, dst_sg, flags,
+						src_sg_len, DMA_MEM_TO_MEM);
+
+}
+
+/**
+ * intel_mid_dma_prep_slave_sg -	Prep slave sg txn
+ * @chan: chan for DMA transfer
+ * @sgl: scatter gather list
+ * @sg_len: length of sg txn
+ * @direction: DMA transfer dirtn
+ * @flags: DMA flags
+ * @context: transfer context (ignored)
+ *
+ * Prepares LLI based periphral transfer
+ */
+static struct dma_async_tx_descriptor *intel_mid_dma_prep_slave_sg(
+			struct dma_chan *chan, struct scatterlist *sg,
+			unsigned int sg_len, enum dma_transfer_direction direction,
+			unsigned long flags, void *context)
+{
+
+	pr_debug("MDMA: Prep for slave SG\n");
+
+	if (!sg_len || sg == NULL) {
+		pr_err("MDMA: Invalid SG length\n");
+		return NULL;
+	}
+	pr_debug("MDMA: SG Length = %d, direction = %d, Flags = %#lx\n",
+				sg_len, direction, flags);
+	if (direction != DMA_MEM_TO_MEM) {
+		return intel_mid_dma_chan_prep_desc(chan, sg, NULL, flags,
+							sg_len, direction);
+	} else {
+		pr_err("MDMA: Invalid Direction\n");
+		return NULL;
+	}
 }
 
 /**
@@ -811,31 +1285,52 @@ static void intel_mid_dma_free_chan_resources(struct dma_chan *chan)
 	struct middma_device	*mid = to_middma_device(chan->device);
 	struct intel_mid_dma_desc	*desc, *_desc;
 
+	pr_debug("entry:%s\n", __func__);
+	if (false == midc->in_use) {
+		pr_err("ERR_MDMA: try to free chnl already freed\n");
+		return;
+	}
 	if (true == midc->busy) {
 		/*trying to free ch in use!!!!!*/
 		pr_err("ERR_MDMA: trying to free ch in use\n");
+		dump_dma_reg(chan);
 	}
+
+	/* Disable CH interrupts */
+	disable_dma_interrupt(midc);
+	clear_dma_channel_interrupt(midc);
+
+	midc->block_intr_status = false;
+	midc->in_use = false;
+	midc->busy = false;
+
+	tasklet_unlock_wait(&mid->tasklet);
+
 	spin_lock_bh(&midc->lock);
 	midc->descs_allocated = 0;
 	list_for_each_entry_safe(desc, _desc, &midc->active_list, desc_node) {
 		list_del(&desc->desc_node);
-		pci_pool_free(mid->dma_pool, desc, desc->txd.phys);
+		dma_pool_free(mid->dma_pool, desc, desc->txd.phys);
 	}
 	list_for_each_entry_safe(desc, _desc, &midc->free_list, desc_node) {
 		list_del(&desc->desc_node);
-		pci_pool_free(mid->dma_pool, desc, desc->txd.phys);
+		dma_pool_free(mid->dma_pool, desc, desc->txd.phys);
 	}
 	list_for_each_entry_safe(desc, _desc, &midc->queue, desc_node) {
 		list_del(&desc->desc_node);
-		pci_pool_free(mid->dma_pool, desc, desc->txd.phys);
+		dma_pool_free(mid->dma_pool, desc, desc->txd.phys);
 	}
+	midc->raw_tfr = 0;
 	spin_unlock_bh(&midc->lock);
-	midc->in_use = false;
-	midc->busy = false;
-	/* Disable CH interrupts */
-	iowrite32(MASK_INTR_REG(midc->ch_id), mid->dma_base + MASK_BLOCK);
-	iowrite32(MASK_INTR_REG(midc->ch_id), mid->dma_base + MASK_ERR);
-	pm_runtime_put(&mid->pdev->dev);
+
+	if (midc->lli_pool) {
+		dma_pool_destroy(midc->lli_pool);
+		midc->lli_pool = NULL;
+	}
+
+	/* Disable the channel */
+	iowrite32(DISABLE_CHANNEL(midc->ch_id), mid->dma_base + DMA_CHAN_EN);
+	pm_runtime_put(mid->dev);
 }
 
 /**
@@ -853,20 +1348,19 @@ static int intel_mid_dma_alloc_chan_resources(struct dma_chan *chan)
 	dma_addr_t		phys;
 	int	i = 0;
 
-	pm_runtime_get_sync(&mid->pdev->dev);
+	pm_runtime_get_sync(mid->dev);
 
 	if (mid->state == SUSPENDED) {
-		if (dma_resume(&mid->pdev->dev)) {
+		if (dma_resume(mid->dev)) {
 			pr_err("ERR_MDMA: resume failed");
 			return -EFAULT;
 		}
 	}
 
 	/* ASSERT:  channel is idle */
-	if (test_ch_en(mid->dma_base, midc->ch_id)) {
-		/*ch is not idle*/
+	if (midc->in_use == true) {
 		pr_err("ERR_MDMA: ch not idle\n");
-		pm_runtime_put(&mid->pdev->dev);
+		pm_runtime_put(mid->dev);
 		return -EIO;
 	}
 	dma_cookie_init(chan);
@@ -874,10 +1368,10 @@ static int intel_mid_dma_alloc_chan_resources(struct dma_chan *chan)
 	spin_lock_bh(&midc->lock);
 	while (midc->descs_allocated < DESCS_PER_CHANNEL) {
 		spin_unlock_bh(&midc->lock);
-		desc = pci_pool_alloc(mid->dma_pool, GFP_KERNEL, &phys);
+		desc = dma_pool_alloc(mid->dma_pool, GFP_KERNEL, &phys);
 		if (!desc) {
 			pr_err("ERR_MDMA: desc failed\n");
-			pm_runtime_put(&mid->pdev->dev);
+			pm_runtime_put(mid->dev);
 			return -ENOMEM;
 			/*check*/
 		}
@@ -889,9 +1383,10 @@ static int intel_mid_dma_alloc_chan_resources(struct dma_chan *chan)
 		i = ++midc->descs_allocated;
 		list_add_tail(&desc->desc_node, &midc->free_list);
 	}
+	midc->busy = false;
 	spin_unlock_bh(&midc->lock);
 	midc->in_use = true;
-	midc->busy = false;
+	midc->block_intr_status = false;
 	pr_debug("MID_DMA: Desc alloc done ret: %d desc\n", i);
 	return i;
 }
@@ -906,7 +1401,8 @@ static int intel_mid_dma_alloc_chan_resources(struct dma_chan *chan)
 static void midc_handle_error(struct middma_device *mid,
 		struct intel_mid_dma_chan *midc)
 {
-	midc_scan_descriptors(mid, midc);
+	midc_collect_descriptors(mid, midc);
+	midc_start_descriptors(mid, midc);
 }
 
 /**
@@ -922,24 +1418,25 @@ static void dma_tasklet(unsigned long data)
 	struct intel_mid_dma_chan *midc = NULL;
 	u32 status, raw_tfr, raw_block;
 	int i;
-
 	mid = (struct middma_device *)data;
 	if (mid == NULL) {
 		pr_err("ERR_MDMA: tasklet Null param\n");
 		return;
 	}
-	pr_debug("MDMA: in tasklet for device %x\n", mid->pci_id);
 	raw_tfr = ioread32(mid->dma_base + RAW_TFR);
-	raw_block = ioread32(mid->dma_base + RAW_BLOCK);
-	status = raw_tfr | raw_block;
-	status &= mid->intr_mask;
+	status = raw_tfr & mid->tfr_intr_mask;
+	pr_debug("MDMA: in tasklet for device %x\n", mid->pci_id);
+	pr_debug("tfr_mask:%#lx, raw_tfr:%#x, status:%#x\n",
+			mid->tfr_intr_mask, raw_tfr, status);
 	while (status) {
 		/*txn interrupt*/
-		i = get_ch_index(&status, mid->chan_base);
+		i = get_ch_index(status, mid->chan_base);
 		if (i < 0) {
 			pr_err("ERR_MDMA:Invalid ch index %x\n", i);
 			return;
 		}
+		/* clear the status bit */
+		status = status & ~(1 << (i + mid->chan_base));
 		midc = &mid->ch[i];
 		if (midc == NULL) {
 			pr_err("ERR_MDMA:Null param midc\n");
@@ -947,38 +1444,69 @@ static void dma_tasklet(unsigned long data)
 		}
 		pr_debug("MDMA:Tx complete interrupt %x, Ch No %d Index %d\n",
 				status, midc->ch_id, i);
-		midc->raw_tfr = raw_tfr;
-		midc->raw_block = raw_block;
 		spin_lock_bh(&midc->lock);
+		midc->raw_tfr = raw_tfr;
 		/*clearing this interrupts first*/
 		iowrite32((1 << midc->ch_id), mid->dma_base + CLEAR_TFR);
-		if (raw_block) {
-			iowrite32((1 << midc->ch_id),
-				mid->dma_base + CLEAR_BLOCK);
+		if (likely(midc->in_use)) {
+			midc_collect_descriptors(mid, midc);
+			midc_start_descriptors(mid, midc);
 		}
-		midc_scan_descriptors(mid, midc);
 		pr_debug("MDMA:Scan of desc... complete, unmasking\n");
 		iowrite32(UNMASK_INTR_REG(midc->ch_id),
-				mid->dma_base + MASK_TFR);
-		if (raw_block) {
-			iowrite32(UNMASK_INTR_REG(midc->ch_id),
-				mid->dma_base + MASK_BLOCK);
+					mid->dma_base + MASK_TFR);
+		spin_unlock_bh(&midc->lock);
+	}
+
+	raw_block = ioread32(mid->dma_base + RAW_BLOCK);
+	status = raw_block & mid->block_intr_mask;
+	pr_debug("MDMA: in tasklet for device %x\n", mid->pci_id);
+	pr_debug("block_mask:%#lx, raw_block%#x, status:%#x\n",
+			 mid->block_intr_mask, raw_block, status);
+	while (status) {
+		/*txn interrupt*/
+		i = get_ch_index(status, mid->chan_base);
+		if (i < 0) {
+			pr_err("ERR_MDMA:Invalid ch index %x\n", i);
+			return;
+		}
+		/* clear the status bit */
+		status = status & ~(1 << (i + mid->chan_base));
+		midc = &mid->ch[i];
+		if (midc == NULL) {
+			pr_err("ERR_MDMA:Null param midc\n");
+			return;
+		}
+		pr_debug("MDMA:Tx complete interrupt raw block  %x, Ch No %d Index %d\n",
+				status, midc->ch_id, i);
+		spin_lock_bh(&midc->lock);
+		/*clearing this interrupts first*/
+
+		midc->raw_block = raw_block;
+		iowrite32((1 << midc->ch_id), mid->dma_base + CLEAR_BLOCK);
+		if (midc->block_intr_status) {
+			midc_collect_descriptors(mid, midc);
+			midc_start_descriptors(mid, midc);
 		}
+
+		iowrite32(UNMASK_INTR_REG(midc->ch_id),
+					mid->dma_base + MASK_BLOCK);
 		spin_unlock_bh(&midc->lock);
 	}
 
 	status = ioread32(mid->dma_base + RAW_ERR);
-	status &= mid->intr_mask;
+	pr_debug("MDMA:raw error status:%#x\n", status);
 	while (status) {
 		/*err interrupt*/
-		i = get_ch_index(&status, mid->chan_base);
+		i = get_ch_index(status, mid->chan_base);
 		if (i < 0) {
-			pr_err("ERR_MDMA:Invalid ch index %x\n", i);
+			pr_err("ERR_MDMA:Invalid ch index %x (raw err)\n", i);
 			return;
 		}
+		status = status & ~(1 << (i + mid->chan_base));
 		midc = &mid->ch[i];
 		if (midc == NULL) {
-			pr_err("ERR_MDMA:Null param midc\n");
+			pr_err("ERR_MDMA:Null param midc (raw err)\n");
 			return;
 		}
 		pr_debug("MDMA:Tx complete interrupt %x, Ch No %d Index %d\n",
@@ -1018,33 +1546,59 @@ static void dma_tasklet2(unsigned long data)
 static irqreturn_t intel_mid_dma_interrupt(int irq, void *data)
 {
 	struct middma_device *mid = data;
-	u32 tfr_status, err_status;
-	int call_tasklet = 0;
+	u32 tfr_status, err_status, block_status;
+	u32 isr;
 
-	tfr_status = ioread32(mid->dma_base + RAW_TFR);
-	err_status = ioread32(mid->dma_base + RAW_ERR);
-	if (!tfr_status && !err_status)
+	/* On Baytrail, the DMAC is sharing IRQ with other devices */
+	if (is_byt_lpio_dmac(mid) && mid->state == SUSPENDED)
 		return IRQ_NONE;
 
 	/*DMA Interrupt*/
 	pr_debug("MDMA:Got an interrupt on irq %d\n", irq);
-	pr_debug("MDMA: Status %x, Mask %x\n", tfr_status, mid->intr_mask);
-	tfr_status &= mid->intr_mask;
+	if (!mid) {
+		pr_err("ERR_MDMA:null pointer mid\n");
+		return -EINVAL;
+	}
+
+	/* Read the interrupt status registers */
+	tfr_status = ioread32(mid->dma_base + STATUS_TFR);
+	err_status = ioread32(mid->dma_base + STATUS_ERR);
+	block_status = ioread32(mid->dma_base + STATUS_BLOCK);
+
+	/* Common case if the IRQ is shared with other devices */
+	if (!tfr_status && !err_status && !block_status)
+		return IRQ_NONE;
+
+	pr_debug("MDMA: trf_Status %x, Mask %x\n", tfr_status, mid->intr_mask);
 	if (tfr_status) {
 		/*need to disable intr*/
-		iowrite32((tfr_status << INT_MASK_WE), mid->dma_base + MASK_TFR);
-		iowrite32((tfr_status << INT_MASK_WE), mid->dma_base + MASK_BLOCK);
-		pr_debug("MDMA: Calling tasklet %x\n", tfr_status);
-		call_tasklet = 1;
+		iowrite32((tfr_status << INT_MASK_WE),
+						mid->dma_base + MASK_TFR);
+	}
+	if (block_status) {
+		/*need to disable intr*/
+		iowrite32((block_status << INT_MASK_WE),
+						mid->dma_base + MASK_BLOCK);
 	}
-	err_status &= mid->intr_mask;
 	if (err_status) {
 		iowrite32((err_status << INT_MASK_WE),
 			  mid->dma_base + MASK_ERR);
-		call_tasklet = 1;
 	}
-	if (call_tasklet)
-		tasklet_schedule(&mid->tasklet);
+	/* in mrlfd we need to clear the pisr bits to stop intr as well
+	 * so read the PISR register, see if we have pisr bits status and clear
+	 * them
+	 */
+	if (mid->pimr_mask && !mid->dword_trf) {
+		isr = readl(mid->mask_reg);
+		pr_debug("isr says: %x", isr);
+		if (isr) {
+			isr &= mid->pimr_mask;
+			pr_debug("writing isr: %x", isr);
+			writel(isr, mid->mask_reg);
+		}
+	}
+
+	tasklet_schedule(&mid->tasklet);
 
 	return IRQ_HANDLED;
 }
@@ -1059,6 +1613,41 @@ static irqreturn_t intel_mid_dma_interrupt2(int irq, void *data)
 	return intel_mid_dma_interrupt(irq, data);
 }
 
+static void config_dma_fifo_partition(struct middma_device *dma)
+{
+	/* program FIFO Partition registers - 128 bytes for each ch */
+	iowrite32(DMA_FIFO_SIZE, dma->dma_base + FIFO_PARTITION0_HI);
+	iowrite32(DMA_FIFO_SIZE, dma->dma_base + FIFO_PARTITION1_LO);
+	iowrite32(DMA_FIFO_SIZE, dma->dma_base + FIFO_PARTITION1_HI);
+	iowrite32(DMA_FIFO_SIZE | BIT(26), dma->dma_base + FIFO_PARTITION0_LO);
+}
+
+/* v1 ops will be used for Medfield & CTP platforms */
+static struct intel_mid_dma_ops v1_dma_ops = {
+	.device_alloc_chan_resources	= intel_mid_dma_alloc_chan_resources,
+	.device_free_chan_resources	= intel_mid_dma_free_chan_resources,
+	.device_prep_dma_memcpy		= intel_mid_dma_prep_memcpy,
+	.device_prep_dma_sg		= intel_mid_dma_prep_sg,
+	.device_prep_slave_sg		= intel_mid_dma_prep_slave_sg,
+	.device_control			= intel_mid_dma_device_control,
+	.device_tx_status		= intel_mid_dma_tx_status,
+	.device_issue_pending		= intel_mid_dma_issue_pending,
+	.dma_chan_suspend		= intel_mid_dma_chan_suspend_v1,
+};
+
+/* v2 ops will be used in Merrifield and beyond plantforms */
+static struct intel_mid_dma_ops v2_dma_ops = {
+	.device_alloc_chan_resources    = intel_mid_dma_alloc_chan_resources,
+	.device_free_chan_resources     = intel_mid_dma_free_chan_resources,
+	.device_prep_dma_memcpy         = intel_mid_dma_prep_memcpy_v2,
+	.device_prep_dma_sg             = intel_mid_dma_prep_sg,
+	.device_prep_slave_sg           = intel_mid_dma_prep_slave_sg,
+	.device_control                 = intel_mid_dma_device_control,
+	.device_tx_status               = intel_mid_dma_tx_status,
+	.device_issue_pending           = intel_mid_dma_issue_pending,
+	.dma_chan_suspend		= intel_mid_dma_chan_suspend_v2,
+};
+
 /**
  * mid_setup_dma -	Setup the DMA controller
  * @pdev: Controller PCI device structure
@@ -1066,33 +1655,33 @@ static irqreturn_t intel_mid_dma_interrupt2(int irq, void *data)
  * Initialize the DMA controller, channels, registers with DMA engine,
  * ISR. Initialize DMA controller channels.
  */
-static int mid_setup_dma(struct pci_dev *pdev)
+int mid_setup_dma(struct device *dev)
 {
-	struct middma_device *dma = pci_get_drvdata(pdev);
+	struct middma_device *dma = dev_get_drvdata(dev);
 	int err, i;
 
 	/* DMA coherent memory pool for DMA descriptor allocations */
-	dma->dma_pool = pci_pool_create("intel_mid_dma_desc_pool", pdev,
+	dma->dma_pool = dma_pool_create("intel_mid_dma_desc_pool", dev,
 					sizeof(struct intel_mid_dma_desc),
 					32, 0);
 	if (NULL == dma->dma_pool) {
-		pr_err("ERR_MDMA:pci_pool_create failed\n");
+		pr_err("ERR_MDMA:dma_pool_create failed\n");
 		err = -ENOMEM;
+		kfree(dma);
 		goto err_dma_pool;
 	}
 
 	INIT_LIST_HEAD(&dma->common.channels);
-	dma->pci_id = pdev->device;
 	if (dma->pimr_mask) {
-		dma->mask_reg = ioremap(LNW_PERIPHRAL_MASK_BASE,
-					LNW_PERIPHRAL_MASK_SIZE);
+		dma->mask_reg = devm_ioremap(dma->dev, dma->pimr_base, LNW_PERIPHRAL_MASK_SIZE);
 		if (dma->mask_reg == NULL) {
 			pr_err("ERR_MDMA:Can't map periphral intr space !!\n");
 			err = -ENOMEM;
-			goto err_ioremap;
+			goto err_setup;
 		}
-	} else
+	} else {
 		dma->mask_reg = NULL;
+	}
 
 	pr_debug("MDMA:Adding %d channel for this controller\n", dma->max_chan);
 	/*init CH structures*/
@@ -1137,18 +1726,17 @@ static int mid_setup_dma(struct pci_dev *pdev)
 	dma_cap_set(DMA_MEMCPY, dma->common.cap_mask);
 	dma_cap_set(DMA_SLAVE, dma->common.cap_mask);
 	dma_cap_set(DMA_PRIVATE, dma->common.cap_mask);
-	dma->common.dev = &pdev->dev;
+	dma->common.dev = dev;
 
-	dma->common.device_alloc_chan_resources =
-					intel_mid_dma_alloc_chan_resources;
-	dma->common.device_free_chan_resources =
-					intel_mid_dma_free_chan_resources;
+	dma->common.device_alloc_chan_resources = dma->dma_ops.device_alloc_chan_resources;
+	dma->common.device_free_chan_resources = dma->dma_ops.device_free_chan_resources;
 
-	dma->common.device_tx_status = intel_mid_dma_tx_status;
-	dma->common.device_prep_dma_memcpy = intel_mid_dma_prep_memcpy;
-	dma->common.device_issue_pending = intel_mid_dma_issue_pending;
-	dma->common.device_prep_slave_sg = intel_mid_dma_prep_slave_sg;
-	dma->common.device_control = intel_mid_dma_device_control;
+	dma->common.device_tx_status = dma->dma_ops.device_tx_status;
+	dma->common.device_prep_dma_memcpy = dma->dma_ops.device_prep_dma_memcpy;
+	dma->common.device_prep_dma_sg = dma->dma_ops.device_prep_dma_sg;
+	dma->common.device_issue_pending = dma->dma_ops.device_issue_pending;
+	dma->common.device_prep_slave_sg = dma->dma_ops.device_prep_slave_sg;
+	dma->common.device_control = dma->dma_ops.device_control;
 
 	/*enable dma cntrl*/
 	iowrite32(REG_BIT0, dma->dma_base + DMA_CFG);
@@ -1156,23 +1744,23 @@ static int mid_setup_dma(struct pci_dev *pdev)
 	/*register irq */
 	if (dma->pimr_mask) {
 		pr_debug("MDMA:Requesting irq shared for DMAC1\n");
-		err = request_irq(pdev->irq, intel_mid_dma_interrupt1,
+		err = devm_request_irq(dma->dev, dma->irq, intel_mid_dma_interrupt1,
 			IRQF_SHARED, "INTEL_MID_DMAC1", dma);
 		if (0 != err)
-			goto err_irq;
+			goto err_setup;
 	} else {
 		dma->intr_mask = 0x03;
 		pr_debug("MDMA:Requesting irq for DMAC2\n");
-		err = request_irq(pdev->irq, intel_mid_dma_interrupt2,
+		err = devm_request_irq(dma->dev, dma->irq, intel_mid_dma_interrupt2,
 			IRQF_SHARED, "INTEL_MID_DMAC2", dma);
 		if (0 != err)
-			goto err_irq;
+			goto err_setup;
 	}
 	/*register device w/ engine*/
 	err = dma_async_device_register(&dma->common);
 	if (0 != err) {
 		pr_err("ERR_MDMA:device_register failed: %d\n", err);
-		goto err_engine;
+		goto err_dma_pool;
 	}
 	if (dma->pimr_mask) {
 		pr_debug("setting up tasklet1 for DMAC1\n");
@@ -1181,15 +1769,15 @@ static int mid_setup_dma(struct pci_dev *pdev)
 		pr_debug("setting up tasklet2 for DMAC2\n");
 		tasklet_init(&dma->tasklet, dma_tasklet2, (unsigned long)dma);
 	}
+	if (!dma->dword_trf) {
+		config_dma_fifo_partition(dma);
+		/* Mask all interrupts from DMA controller to IA by default */
+		dmac1_mask_periphral_intr(dma);
+	}
 	return 0;
 
-err_engine:
-	free_irq(pdev->irq, dma);
-err_irq:
-	if (dma->mask_reg)
-		iounmap(dma->mask_reg);
-err_ioremap:
-	pci_pool_destroy(dma->dma_pool);
+err_setup:
+	dma_pool_destroy(dma->dma_pool);
 err_dma_pool:
 	pr_err("ERR_MDMA:setup_dma failed: %d\n", err);
 	return err;
@@ -1198,25 +1786,42 @@ err_dma_pool:
 
 /**
  * middma_shutdown -	Shutdown the DMA controller
- * @pdev: Controller PCI device structure
+ * @dev: Controller device structure
  *
  * Called by remove
  * Unregister DMa controller, clear all structures and free interrupt
  */
-static void middma_shutdown(struct pci_dev *pdev)
+void middma_shutdown(struct device *dev)
 {
-	struct middma_device *device = pci_get_drvdata(pdev);
+	struct middma_device *device = dev_get_drvdata(dev);
 
 	dma_async_device_unregister(&device->common);
-	pci_pool_destroy(device->dma_pool);
-	if (device->mask_reg)
-		iounmap(device->mask_reg);
-	if (device->dma_base)
-		iounmap(device->dma_base);
-	free_irq(pdev->irq, device);
+	dma_pool_destroy(device->dma_pool);
 	return;
 }
 
+struct middma_device *mid_dma_setup_context(struct device *dev,
+					    struct intel_mid_dma_probe_info *info)
+{
+	struct middma_device *mid_device;
+	mid_device = devm_kzalloc(dev, sizeof(*mid_device), GFP_KERNEL);
+	if (!mid_device) {
+		pr_err("ERR_MDMA:kzalloc failed probe\n");
+		return NULL;
+	}
+	mid_device->dev = dev;
+	mid_device->max_chan = info->max_chan;
+	mid_device->chan_base = info->ch_base;
+	mid_device->block_size = info->block_size;
+	mid_device->pimr_mask = info->pimr_mask;
+	mid_device->pimr_base = info->pimr_base;
+	mid_device->dword_trf = info->dword_trf;
+	mid_device->pimr_offset = info->pimr_offset;
+	mid_device->pci_id = info->pci_id;
+	memcpy(&mid_device->dma_ops, info->pdma_ops, sizeof(struct intel_mid_dma_ops));
+	return mid_device;
+}
+
 /**
  * intel_mid_dma_probe -	PCI Probe
  * @pdev: Controller PCI device structure
@@ -1255,42 +1860,41 @@ static int intel_mid_dma_probe(struct pci_dev *pdev,
 	if (err)
 		goto err_set_dma_mask;
 
-	device = kzalloc(sizeof(*device), GFP_KERNEL);
-	if (!device) {
-		pr_err("ERR_MDMA:kzalloc failed probe\n");
-		err = -ENOMEM;
+	pci_dev_get(pdev);
+	device = mid_dma_setup_context(&pdev->dev, info);
+	if (!device)
 		goto err_kzalloc;
-	}
-	device->pdev = pci_dev_get(pdev);
+
+	device->pci_id = pdev->device;
 
 	base_addr = pci_resource_start(pdev, 0);
 	bar_size  = pci_resource_len(pdev, 0);
-	device->dma_base = ioremap_nocache(base_addr, DMA_REG_SIZE);
+	device->dma_base = devm_ioremap_nocache(&pdev->dev, base_addr, DMA_REG_SIZE);
 	if (!device->dma_base) {
 		pr_err("ERR_MDMA:ioremap failed\n");
 		err = -ENOMEM;
 		goto err_ioremap;
 	}
+	device->irq = pdev->irq;
 	pci_set_drvdata(pdev, device);
 	pci_set_master(pdev);
-	device->max_chan = info->max_chan;
-	device->chan_base = info->ch_base;
-	device->block_size = info->block_size;
-	device->pimr_mask = info->pimr_mask;
 
-	err = mid_setup_dma(pdev);
+#ifdef CONFIG_PRH_TEMP_WA_FOR_SPID
+	/* PRH uses, ch 4,5,6,7 override the info table data */
+	pr_info("Device is Bodegabay\n");
+	device->max_chan = 4;
+	device->chan_base = 4;
+#endif
+	err = mid_setup_dma(&pdev->dev);
 	if (err)
-		goto err_dma;
+		goto err_ioremap;
 
 	pm_runtime_put_noidle(&pdev->dev);
-	pm_runtime_allow(&pdev->dev);
+	pm_runtime_forbid(&pdev->dev);
 	return 0;
 
-err_dma:
-	iounmap(device->dma_base);
 err_ioremap:
 	pci_dev_put(pdev);
-	kfree(device);
 err_kzalloc:
 err_set_dma_mask:
 	pci_release_regions(pdev);
@@ -1310,31 +1914,26 @@ err_enable_device:
  */
 static void intel_mid_dma_remove(struct pci_dev *pdev)
 {
-	struct middma_device *device = pci_get_drvdata(pdev);
-
 	pm_runtime_get_noresume(&pdev->dev);
 	pm_runtime_forbid(&pdev->dev);
-	middma_shutdown(pdev);
+	middma_shutdown(&pdev->dev);
 	pci_dev_put(pdev);
-	kfree(device);
 	pci_release_regions(pdev);
 	pci_disable_device(pdev);
 }
 
 /* Power Management */
 /*
-* dma_suspend - PCI suspend function
+* dma_suspend - suspend function
 *
-* @pci: PCI device structure
-* @state: PM message
+* @dev: device structure
 *
 * This function is called by OS when a power event occurs
 */
-static int dma_suspend(struct device *dev)
+int dma_suspend(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
 	int i;
-	struct middma_device *device = pci_get_drvdata(pci);
+	struct middma_device *device = dev_get_drvdata(dev);
 	pr_debug("MDMA: dma_suspend called\n");
 
 	for (i = 0; i < device->max_chan; i++) {
@@ -1343,61 +1942,44 @@ static int dma_suspend(struct device *dev)
 	}
 	dmac1_mask_periphral_intr(device);
 	device->state = SUSPENDED;
-	pci_save_state(pci);
-	pci_disable_device(pci);
-	pci_set_power_state(pci, PCI_D3hot);
+
 	return 0;
 }
 
 /**
-* dma_resume - PCI resume function
+* dma_resume - resume function
 *
-* @pci:	PCI device structure
+* @dev:	device structure
 *
 * This function is called by OS when a power event occurs
 */
 int dma_resume(struct device *dev)
 {
-	struct pci_dev *pci = to_pci_dev(dev);
-	int ret;
-	struct middma_device *device = pci_get_drvdata(pci);
+	struct middma_device *device = dev_get_drvdata(dev);
 
 	pr_debug("MDMA: dma_resume called\n");
-	pci_set_power_state(pci, PCI_D0);
-	pci_restore_state(pci);
-	ret = pci_enable_device(pci);
-	if (ret) {
-		pr_err("MDMA: device can't be enabled for %x\n", pci->device);
-		return ret;
-	}
 	device->state = RUNNING;
 	iowrite32(REG_BIT0, device->dma_base + DMA_CFG);
+
+	if (!device->dword_trf)
+		config_dma_fifo_partition(device);
+
 	return 0;
 }
 
 static int dma_runtime_suspend(struct device *dev)
 {
-	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct middma_device *device = pci_get_drvdata(pci_dev);
-
-	device->state = SUSPENDED;
-	return 0;
+	return dma_suspend(dev);
 }
 
 static int dma_runtime_resume(struct device *dev)
 {
-	struct pci_dev *pci_dev = to_pci_dev(dev);
-	struct middma_device *device = pci_get_drvdata(pci_dev);
-
-	device->state = RUNNING;
-	iowrite32(REG_BIT0, device->dma_base + DMA_CFG);
-	return 0;
+	return dma_resume(dev);
 }
 
 static int dma_runtime_idle(struct device *dev)
 {
-	struct pci_dev *pdev = to_pci_dev(dev);
-	struct middma_device *device = pci_get_drvdata(pdev);
+	struct middma_device *device = dev_get_drvdata(dev);
 	int i;
 
 	for (i = 0; i < device->max_chan; i++) {
@@ -1405,31 +1987,62 @@ static int dma_runtime_idle(struct device *dev)
 			return -EAGAIN;
 	}
 
-	return 0;
+	return pm_schedule_suspend(dev, 0);;
 }
 
 /******************************************************************************
 * PCI stuff
 */
 static struct pci_device_id intel_mid_dma_ids[] = {
-	{ PCI_VDEVICE(INTEL, INTEL_MID_DMAC1_ID),	INFO(2, 6, 4095, 0x200020)},
-	{ PCI_VDEVICE(INTEL, INTEL_MID_DMAC2_ID),	INFO(2, 0, 2047, 0)},
-	{ PCI_VDEVICE(INTEL, INTEL_MID_GP_DMAC2_ID),	INFO(2, 0, 2047, 0)},
-	{ PCI_VDEVICE(INTEL, INTEL_MFLD_DMAC1_ID),	INFO(4, 0, 4095, 0x400040)},
+	{ PCI_VDEVICE(INTEL, INTEL_MID_DMAC1_ID),
+		INFO(2, 6, SST_MAX_DMA_LEN, 0x200020, 0xFFAE8008, 1, 0x8, INTEL_MID_DMAC1_ID, &v1_dma_ops)},
+	{ PCI_VDEVICE(INTEL, INTEL_MID_DMAC2_ID),
+		INFO(2, 0, 2047, 0, 0, 1, 0, INTEL_MID_DMAC2_ID, &v1_dma_ops)},
+	{ PCI_VDEVICE(INTEL, INTEL_MID_GP_DMAC2_ID),
+		INFO(2, 0, 2047, 0, 0, 1, 0, INTEL_MID_GP_DMAC2_ID, &v1_dma_ops)},
+	{ PCI_VDEVICE(INTEL, INTEL_MFLD_DMAC1_ID),
+		INFO(4, 0, SST_MAX_DMA_LEN, 0x400040, 0xFFAE8008, 1, 0x8, INTEL_MFLD_DMAC1_ID, &v1_dma_ops)},
+	/* Cloverview support */
+	{ PCI_VDEVICE(INTEL, INTEL_CLV_GP_DMAC2_ID),
+		INFO(2, 0, 2047, 0, 0, 1, 0, INTEL_CLV_GP_DMAC2_ID, &v1_dma_ops)},
+	{ PCI_VDEVICE(INTEL, INTEL_CLV_DMAC1_ID),
+		INFO(4, 0, SST_MAX_DMA_LEN, 0x400040, 0xFFAE8008, 1, 0x8, INTEL_CLV_DMAC1_ID, &v1_dma_ops)},
+	/* Mrfld */
+	{ PCI_VDEVICE(INTEL, INTEL_MRFLD_GP_DMAC2_ID),
+		INFO(4, 0, SST_MAX_DMA_LEN_MRFLD, 0, 0, 0, 0, INTEL_MRFLD_GP_DMAC2_ID, &v2_dma_ops)},
+	{ PCI_VDEVICE(INTEL, INTEL_MRFLD_DMAC0_ID),
+		INFO(2, 6, SST_MAX_DMA_LEN_MRFLD, 0xFF0000, 0xFF340018, 0, 0x10, INTEL_MRFLD_DMAC0_ID, &v2_dma_ops)},
+	/* Baytrail Low Speed Peripheral DMA */
+	{ PCI_VDEVICE(INTEL, INTEL_BYT_LPIO1_DMAC_ID),
+		INFO(6, 0, 2047, 0, 0, 1, 0, INTEL_BYT_LPIO1_DMAC_ID, &v1_dma_ops)},
+	{ PCI_VDEVICE(INTEL, INTEL_BYT_LPIO2_DMAC_ID),
+		INFO(6, 0, 2047, 0, 0, 1, 0, INTEL_BYT_LPIO2_DMAC_ID, &v1_dma_ops)},
 	{ 0, }
 };
 MODULE_DEVICE_TABLE(pci, intel_mid_dma_ids);
 
+struct intel_mid_dma_probe_info dma_byt_info = {
+	.max_chan = 4,
+	.ch_base = 4,
+	.block_size = 131071,
+	.pimr_mask = 0x00FF0000,
+	.pimr_base = 0xDF540018,
+	.dword_trf = 0,
+	.pimr_offset = 0x10,
+	.pci_id = INTEL_BYT_DMAC0_ID,
+	.pdma_ops = &v2_dma_ops,
+};
+
 static const struct dev_pm_ops intel_mid_dma_pm = {
-	.runtime_suspend = dma_runtime_suspend,
-	.runtime_resume = dma_runtime_resume,
-	.runtime_idle = dma_runtime_idle,
-	.suspend = dma_suspend,
-	.resume = dma_resume,
+	SET_SYSTEM_SLEEP_PM_OPS(dma_suspend,
+			dma_resume)
+	SET_RUNTIME_PM_OPS(dma_runtime_suspend,
+			dma_runtime_resume,
+			dma_runtime_idle)
 };
 
 static struct pci_driver intel_mid_dma_pci_driver = {
-	.name		=	"Intel MID DMA",
+	.name		=	"intel_mid_dma",
 	.id_table	=	intel_mid_dma_ids,
 	.probe		=	intel_mid_dma_probe,
 	.remove		=	intel_mid_dma_remove,
@@ -1440,17 +2053,55 @@ static struct pci_driver intel_mid_dma_pci_driver = {
 #endif
 };
 
+static const struct acpi_device_id dma_acpi_ids[];
+
+struct intel_mid_dma_probe_info *mid_get_acpi_driver_data(const char *hid)
+{
+	const struct acpi_device_id *id;
+
+	pr_debug("%s", __func__);
+	for (id = dma_acpi_ids; id->id[0]; id++)
+		if (!strncmp(id->id, hid, 16))
+			return (struct intel_mid_dma_probe_info *)id->driver_data;
+	return NULL;
+}
+static const struct acpi_device_id dma_acpi_ids[] = {
+	{ "DMA0F28", (kernel_ulong_t)&dma_byt_info },
+	{ },
+};
+
+static struct platform_driver intel_dma_acpi_driver = {
+	.driver = {
+		.name			= "intel_dma_acpi",
+		.owner			= THIS_MODULE,
+		.acpi_match_table	= dma_acpi_ids,
+		.pm			= &intel_mid_dma_pm,
+	},
+	.probe	= dma_acpi_probe,
+	.remove	= dma_acpi_remove,
+};
+
 static int __init intel_mid_dma_init(void)
 {
+	int ret;
+
 	pr_debug("INFO_MDMA: LNW DMA Driver Version %s\n",
 			INTEL_MID_DMA_DRIVER_VERSION);
-	return pci_register_driver(&intel_mid_dma_pci_driver);
+	ret = pci_register_driver(&intel_mid_dma_pci_driver);
+	if (ret)
+		pr_err("PCI dev registration failed");
+
+	ret = platform_driver_register(&intel_dma_acpi_driver);
+	if (ret)
+		pr_err("Platform dev registration failed");
+	return ret;
 }
-fs_initcall(intel_mid_dma_init);
+module_init(intel_mid_dma_init);
 
 static void __exit intel_mid_dma_exit(void)
 {
 	pci_unregister_driver(&intel_mid_dma_pci_driver);
+	platform_driver_unregister(&intel_dma_acpi_driver);
 }
 module_exit(intel_mid_dma_exit);
 
@@ -1458,3 +2109,5 @@ MODULE_AUTHOR("Vinod Koul <vinod.koul@intel.com>");
 MODULE_DESCRIPTION("Intel (R) MID DMAC Driver");
 MODULE_LICENSE("GPL v2");
 MODULE_VERSION(INTEL_MID_DMA_DRIVER_VERSION);
+MODULE_ALIAS("pci:intel_mid_dma");
+MODULE_ALIAS("acpi:intel_dma_acpi");
diff --git a/drivers/dma/intel_mid_dma_acpi.c b/drivers/dma/intel_mid_dma_acpi.c
new file mode 100644
index 0000000..2bef1ab
--- /dev/null
+++ b/drivers/dma/intel_mid_dma_acpi.c
@@ -0,0 +1,192 @@
+
+/* intel_mid_dma_acpi.c - Intel MID DMA driver init file for ACPI enumaration.
+ *
+ * Copyright (c) 2013, Intel Corporation.
+ *
+ *  Authors:	Ramesh Babu K V <Ramesh.Babu@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/intel_mid_dma.h>
+#include <linux/pm_runtime.h>
+#include <acpi/acpi_bus.h>
+
+#include "intel_mid_dma_regs.h"
+
+#define HID_MAX_SIZE 8
+
+struct list_head dma_dev_list;
+
+LIST_HEAD(dma_dev_list);
+
+struct acpi_dma_dev_list {
+	struct list_head dmadev_list;
+	char dma_hid[HID_MAX_SIZE];
+	struct device *acpi_dma_dev;
+};
+
+struct device *intel_mid_get_acpi_dma(const char *hid)
+{
+	struct acpi_dma_dev_list *listnode;
+	if (list_empty(&dma_dev_list))
+		return NULL;
+
+	list_for_each_entry(listnode, &dma_dev_list, dmadev_list) {
+		if (!(strncmp(listnode->dma_hid, hid, HID_MAX_SIZE)))
+			return listnode->acpi_dma_dev;
+	}
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(intel_mid_get_acpi_dma);
+
+#if IS_ENABLED(CONFIG_ACPI)
+static int mid_get_and_map_rsrc(void **dest, struct platform_device *pdev,
+				unsigned int num)
+{
+	struct resource *rsrc;
+	rsrc = platform_get_resource(pdev, IORESOURCE_MEM, num);
+	if (!rsrc) {
+		pr_err("%s: Invalid resource - %d", __func__, num);
+		return -EIO;
+	}
+	pr_debug("rsrc #%d = %#x", num, rsrc->start);
+	*dest = devm_ioremap_nocache(&pdev->dev, rsrc->start, resource_size(rsrc));
+	if (!*dest) {
+		pr_err("%s: unable to map resource: %#x", __func__, rsrc->start);
+		return -EIO;
+	}
+	return 0;
+}
+
+static int mid_platform_get_resources(struct middma_device *mid_device,
+				      struct platform_device *pdev)
+{
+	int ret;
+	pr_debug("%s", __func__);
+
+	/* All ACPI resource request here */
+	/* Get DDR addr from platform resource table */
+	ret = mid_get_and_map_rsrc(&mid_device->dma_base, pdev, 0);
+	if (ret)
+		return ret;
+	pr_debug("dma_base:%p", mid_device->dma_base);
+
+	ret = mid_get_and_map_rsrc(&mid_device->mask_reg, pdev, 1);
+	if (ret)
+		return ret;
+	/* mask_reg should point to ISRX register */
+	mid_device->mask_reg += 0x18;
+	pr_debug("pimr_base:%p", mid_device->mask_reg);
+
+	mid_device->irq = platform_get_irq(pdev, 0);
+	if (mid_device->irq < 0) {
+		pr_err("invalid irq:%d", mid_device->irq);
+		return mid_device->irq;
+	}
+	pr_debug("irq from pdev is:%d", mid_device->irq);
+
+	return 0;
+}
+
+int dma_acpi_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	acpi_handle handle = ACPI_HANDLE(dev);
+	struct acpi_device *device;
+	struct middma_device *mid_device;
+	struct intel_mid_dma_probe_info *info;
+	const char *hid;
+	int ret;
+
+	ret = acpi_bus_get_device(handle, &device);
+	if (ret) {
+		pr_err("%s: could not get acpi device - %d\n", __func__, ret);
+		return -ENODEV;
+	}
+
+	if (acpi_bus_get_status(device) || !device->status.present) {
+		pr_err("%s: device has invalid status", __func__);
+		return -ENODEV;
+	}
+
+	hid = acpi_device_hid(device);
+	pr_info("%s for %s", __func__, hid);
+
+	/* Apply default dma_mask if needed */
+	if (!pdev->dev.dma_mask) {
+		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
+		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
+	}
+
+	ret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
+	if (ret) {
+		pr_err("dma_set_mask failed with err:%d", ret);
+		return ret;
+	}
+
+	ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
+	if (ret) {
+		pr_err("_coherent_mask failed with err:%d", ret);
+		return ret;
+	}
+	info = mid_get_acpi_driver_data(hid);
+	if (!info) {
+		pr_err("acpi driver data is null");
+		goto err_dma;
+	}
+
+	mid_device = mid_dma_setup_context(&pdev->dev, info);
+	if (!mid_device)
+		goto err_dma;
+
+	ret = mid_platform_get_resources(mid_device, pdev);
+	if (ret) {
+		pr_err("Error while get resources:%d", ret);
+		goto err_dma;
+	}
+	platform_set_drvdata(pdev, mid_device);
+	ret = mid_setup_dma(&pdev->dev);
+	if (ret)
+		goto err_dma;
+	pm_runtime_enable(&pdev->dev);
+	acpi_dma_dev = &pdev->dev;
+	pr_debug("%s:completed", __func__);
+	return 0;
+err_dma:
+	pr_err("ERR_MDMA:Probe failed %d\n", ret);
+	return ret;
+}
+#else
+int dma_acpi_probe(struct platform_device *pdev)
+{
+	return -EIO;
+}
+#endif
+
+int dma_acpi_remove(struct platform_device *pdev)
+{
+	pm_runtime_forbid(&pdev->dev);
+	middma_shutdown(&pdev->dev);
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
diff --git a/drivers/dma/intel_mid_dma_regs.h b/drivers/dma/intel_mid_dma_regs.h
index 17b4219..30160e4 100644
--- a/drivers/dma/intel_mid_dma_regs.h
+++ b/drivers/dma/intel_mid_dma_regs.h
@@ -31,6 +31,8 @@
 
 #define INTEL_MID_DMA_DRIVER_VERSION "1.1.0"
 
+#define MID_MAX_CHAN	8 /*max ch across controllers*/
+
 #define	REG_BIT0		0x00000001
 #define	REG_BIT8		0x00000100
 #define INT_MASK_WE		0x8
@@ -45,11 +47,13 @@
 #define DISABLE_CHANNEL(chan_num) \
 	(REG_BIT8 << chan_num)
 
-#define DESCS_PER_CHANNEL	16
+#define DESCS_PER_CHANNEL	128
 /*DMA Registers*/
 /*registers associated with channel programming*/
 #define DMA_REG_SIZE		0x400
 #define DMA_CH_SIZE		0x58
+#define DMA_FIFO_SIZE 0x100080
+
 
 /*CH X REG = (DMA_CH_SIZE)*CH_NO + REG*/
 #define SAR			0x00 /* Source Address Register*/
@@ -83,6 +87,17 @@
 #define INTR_STATUS		0x360
 #define DMA_CFG			0x398
 #define DMA_CHAN_EN		0x3A0
+#define FIFO_PARTITION0_LO	0x400
+#define FIFO_PARTITION0_HI	0x404
+#define FIFO_PARTITION1_LO	0x408
+#define FIFO_PARTITION1_HI	0x40C
+#define CH_SAI_ERR		0x410
+
+#define CTL_LO_BIT_LLP_DST_EN	27
+#define CTL_LO_BIT_LLP_SRC_EN	28
+
+#define CH_SUSPEND	(BIT(8))
+#define CH_DRAIN	(BIT(10))
 
 /*DMA channel control registers*/
 union intel_mid_dma_ctl_lo {
@@ -111,6 +126,34 @@ union intel_mid_dma_ctl_lo {
 		u32	llp_src_en:1;	/*enable/disable source LLP = 0*/
 		u32	reser2:3;
 	} ctlx;
+	struct {
+		u32	int_en:1;	/*enable or disable interrupts*/
+					/*should be 0*/
+		u32	dst_tr_width:3;	/*destination transfer width*/
+					/*usually 32 bits = 010*/
+		u32	src_tr_width:3; /*source transfer width*/
+					/*usually 32 bits = 010*/
+		u32	rsvd4:1;
+		u32	dinc:1;		/*destination address inc/dec*/
+		u32	rsvd3:1;
+					/*For mem:INC=00, Periphral NoINC=11*/
+		u32	sinc:1;		/*source address inc or dec, as above*/
+		u32	dst_msize:3;	/*destination burst transaction length*/
+					/*always = 16 ie 011*/
+		u32	src_msize:3;	/*source burst transaction length*/
+					/*always = 16 ie 011*/
+		u32	src_gather_en:1;
+		u32	dst_scatter_en:1;
+		u32	rsvd2:1;
+		u32	tt_fc:2;	/*transfer type and flow controller*/
+					/*M-M = 000
+					  P-M = 010
+					  M-P = 001*/
+		u32	rsvd1:5;
+		u32	llp_dst_en:1;	/*enable/disable destination LLP = 0*/
+		u32	llp_src_en:1;	/*enable/disable source LLP = 0*/
+		u32	reser:3;
+	} ctlx_v2;
 	u32	ctl_lo;
 };
 
@@ -120,8 +163,13 @@ union intel_mid_dma_ctl_hi {
 		u32	done:1;		/*Done - updated by DMAC*/
 		u32	reser:19;	/*configured by DMAC*/
 	} ctlx;
+	struct {
+		u32	block_ts:12;	/*block transfer size*/
+		u32	done:1;		/*Done - updated by DMAC*/
+		u32	ch_weight:11;
+		u32	ch_class:2;
+	} ctlx_v2;
 	u32	ctl_hi;
-
 };
 
 /*DMA channel configuration registers*/
@@ -141,6 +189,33 @@ union intel_mid_dma_cfg_lo {
 		u32	reload_src:1;	/*auto reload src addr =1 if src is P*/
 		u32	reload_dst:1;	/*AR destn addr =1 if dstn is P*/
 	} cfgx;
+	struct {
+		u32	dst_burst_align:1;
+		u32	src_burst_align:1;
+		u32	all_np_wr:1;
+		u32	hshake_np_wr:1;
+		u32	rsvd4:1;
+		u32	ctl_hi_upd_en:1;
+		u32	ds_upd_en:1;
+		u32	ss_upd_en:1;
+		u32	ch_susp:1;
+		u32	fifo_empty:1;
+		u32	ch_drain:1;
+		u32	rsvd11:1;
+		u32	rd_snp:1;
+		u32	wr_snp:1;
+		u32	rd_llp_snp:1;
+		u32	rd_stat_snp:1;
+		u32	wr_stat_snp:1;
+		u32	wr_ctlhi_snp:1;
+		u32	dst_hs_pol:1;
+		u32	src_hs_pol:1;
+		u32	dst_opt_bl:1;
+		u32	src_opt_bl:1;
+		u32	rsvd_22_29:8;
+		u32	reload_src:1;
+		u32	reload_dst:1;
+	} cfgx_v2;
 	u32	cfg_lo;
 };
 
@@ -154,9 +229,43 @@ union intel_mid_dma_cfg_hi {
 		u32	dst_per:4;	/*dstn hw HS interface*/
 		u32	reser2:17;
 	} cfgx;
+	struct {
+		u32	src_per:4;	/*src hw HS interface*/
+		u32	dst_per:4;	/*dstn hw HS interface*/
+		u32	rd_issue_thd:10;
+		u32	wr_issue_thd:10;
+		u32	src_per_ext:2;
+		u32	dst_per_ext:2;
+	} cfgx_v2;
 	u32	cfg_hi;
 };
 
+struct intel_mid_dma_ops {
+	int (*device_alloc_chan_resources)(struct dma_chan *chan);
+	void (*device_free_chan_resources)(struct dma_chan *chan);
+
+	struct dma_async_tx_descriptor *(*device_prep_dma_memcpy)(
+		struct dma_chan *chan, dma_addr_t dest, dma_addr_t src,
+		size_t len, unsigned long flags);
+	struct dma_async_tx_descriptor *(*device_prep_dma_sg)(
+		struct dma_chan *chan,
+		struct scatterlist *dst_sg, unsigned int dst_nents,
+		struct scatterlist *src_sg, unsigned int src_nents,
+		unsigned long flags);
+
+	struct dma_async_tx_descriptor *(*device_prep_slave_sg)(
+		struct dma_chan *chan, struct scatterlist *sgl,
+		unsigned int sg_len, enum dma_transfer_direction direction,
+		unsigned long flags, void *context);
+	int (*device_control)(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
+		unsigned long arg);
+
+	enum dma_status (*device_tx_status)(struct dma_chan *chan,
+					    dma_cookie_t cookie,
+					    struct dma_tx_state *txstate);
+	void (*device_issue_pending)(struct dma_chan *chan);
+	void (*dma_chan_suspend)(struct dma_chan *chan);
+};
 
 /**
  * struct intel_mid_dma_chan - internal mid representation of a DMA channel
@@ -168,13 +277,14 @@ union intel_mid_dma_cfg_hi {
  * @active_list: current active descriptors
  * @queue: current queued up descriptors
  * @free_list: current free descriptors
- * @slave: dma slave structure
- * @descs_allocated: total number of descriptors allocated
- * @dma: dma device structure pointer
+ * @slave: dma slave struture
+ * @descs_allocated: total number of decsiptors allocated
+ * @dma: dma device struture pointer
  * @busy: bool representing if ch is busy (active txn) or not
  * @in_use: bool representing if ch is in use or not
  * @raw_tfr: raw trf interrupt received
  * @raw_block: raw block interrupt received
+ * @block_intr_status: bool representing if block intr is enabled or not
  */
 struct intel_mid_dma_chan {
 	struct dma_chan		chan;
@@ -192,6 +302,8 @@ struct intel_mid_dma_chan {
 	u32			raw_tfr;
 	u32			raw_block;
 	struct intel_mid_dma_slave *mid_slave;
+	struct dma_pool		*lli_pool;
+	bool block_intr_status;
 };
 
 static inline struct intel_mid_dma_chan *to_intel_mid_dma_chan(
@@ -207,6 +319,8 @@ enum intel_mid_dma_state {
 /**
  * struct middma_device - internal representation of a DMA device
  * @pdev: PCI device
+ * @dev : pointer to current device struct
+ * @irq : holds irq for the device
  * @dma_base: MMIO register space pointer of DMA
  * @dma_pool: for allocating DMA descriptors
  * @common: embedded struct dma_device
@@ -220,14 +334,17 @@ enum intel_mid_dma_state {
  * @block_size: Block size of DMA transfer supported (from drv_data)
  * @pimr_mask: MMIO register addr for periphral interrupt (from drv_data)
  * @state: dma PM device state
+ * @tfr_intr_mask: hold the status of tfr intr mask register
+ * @block_intr_mask: hold the status of block intr mask register
  */
 struct middma_device {
-	struct pci_dev		*pdev;
+	struct device		*dev;
+	unsigned int		irq;
 	void __iomem		*dma_base;
 	struct pci_pool		*dma_pool;
 	struct dma_device	common;
 	struct tasklet_struct   tasklet;
-	struct intel_mid_dma_chan ch[MAX_CHAN];
+	struct intel_mid_dma_chan ch[MID_MAX_CHAN];
 	unsigned int		pci_id;
 	unsigned int		intr_mask;
 	void __iomem		*mask_reg;
@@ -235,7 +352,13 @@ struct middma_device {
 	int			max_chan;
 	int			block_size;
 	unsigned int		pimr_mask;
+	unsigned int		pimr_base;
+	unsigned int		dword_trf;
+	unsigned int		pimr_offset;
+	unsigned long		tfr_intr_mask;
+	unsigned long		block_intr_mask;
 	enum intel_mid_dma_state state;
+	struct intel_mid_dma_ops	dma_ops;
 };
 
 static inline struct middma_device *to_middma_device(struct dma_device *common)
@@ -266,15 +389,30 @@ struct intel_mid_dma_desc {
 	enum intel_mid_dma_mode		cfg_mode; /*mode configuration*/
 
 };
-
+/* struct intel_mid_dma_lli is used to provide the DMA IP with SAR,DAR,LLP etc.
+   Use u32 for the elements of this structure irrespective
+   of whether dma_addr_t is u32 or u64.This is necessary because
+   the DMA IP expects these elements to be 32 bit wide */
 struct intel_mid_dma_lli {
-	dma_addr_t			sar;
-	dma_addr_t			dar;
-	dma_addr_t			llp;
+	u32				sar;
+	u32				dar;
+	u32				llp;
 	u32				ctl_lo;
 	u32				ctl_hi;
 } __attribute__ ((packed));
 
+struct intel_mid_dma_probe_info {
+	u8 max_chan;
+	u8 ch_base;
+	u32 block_size;
+	u32 pimr_mask;
+	u32 pimr_base;
+	u8 dword_trf;
+	u32 pimr_offset;
+	unsigned int		pci_id;
+	struct intel_mid_dma_ops *pdma_ops;
+};
+
 static inline int test_ch_en(void __iomem *dma, u32 ch_no)
 {
 	u32 en_reg = ioread32(dma + DMA_CHAN_EN);
@@ -294,6 +432,12 @@ static inline struct intel_mid_dma_slave *to_intel_mid_dma_slave
 }
 
 
+struct middma_device *mid_dma_setup_context(struct device *dev,
+					    struct intel_mid_dma_probe_info *info);
 int dma_resume(struct device *dev);
-
+int dma_acpi_probe(struct platform_device *pdev);
+int dma_acpi_remove(struct platform_device *pdev);
+struct intel_mid_dma_probe_info *mid_get_acpi_driver_data(const char *hid);
+int mid_setup_dma(struct device *dev);
+void middma_shutdown(struct device *dev);
 #endif /*__INTEL_MID_DMAC_REGS_H__*/
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 64362e1..94ed057 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -217,6 +217,15 @@ config SPI_IMX
 	  This enables using the Freescale i.MX SPI controllers in master
 	  mode.
 
+config SPI_INTEL_MID_SSP
+	tristate "SSP SPI controller driver for Intel MID platforms (EXPERIMENTAL)"
+	depends on SPI_MASTER && INTEL_MID_DMAC
+	help
+	  This is the unified SSP SPI slave controller driver for the Intel
+	  MID platforms (Moorestown, Medfield, Clovertrial and
+	  Merrifield), primarily used to implement a SPI host controller
+	  driver over a SSP host controller.
+
 config SPI_LM70_LLP
 	tristate "Parallel port adapter for LM70 eval board (DEVELOPMENT)"
 	depends on PARPORT
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 95af48d..fc9e372 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -39,6 +39,7 @@ obj-$(CONFIG_SPI_FSL_ESPI)		+= spi-fsl-espi.o
 obj-$(CONFIG_SPI_FSL_SPI)		+= spi-fsl-spi.o
 obj-$(CONFIG_SPI_GPIO)			+= spi-gpio.o
 obj-$(CONFIG_SPI_IMX)			+= spi-imx.o
+obj-$(CONFIG_SPI_INTEL_MID_SSP)		+= intel_mid_ssp_spi.o
 obj-$(CONFIG_SPI_LM70_LLP)		+= spi-lm70llp.o
 obj-$(CONFIG_SPI_MPC512x_PSC)		+= spi-mpc512x-psc.o
 obj-$(CONFIG_SPI_MPC52xx_PSC)		+= spi-mpc52xx-psc.o
diff --git a/drivers/spi/intel_mid_ssp_spi.c b/drivers/spi/intel_mid_ssp_spi.c
new file mode 100644
index 0000000..df23a85
--- /dev/null
+++ b/drivers/spi/intel_mid_ssp_spi.c
@@ -0,0 +1,1775 @@
+/*
+ * intel_mid_ssp_spi.c
+ * This driver supports Bulverde SSP core used on Intel MID platforms
+ * It supports SSP of Moorestown & Medfield platforms and handles clock
+ * slave & master modes.
+ *
+ * Copyright (c) 2010, Intel Corporation.
+ *  Ken Mills <ken.k.mills@intel.com>
+ *  Sylvain Centelles <sylvain.centelles@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+/*
+ * Note:
+ *
+ * Supports DMA and non-interrupt polled transfers.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/highmem.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/intel_mid_dma.h>
+#include <linux/pm_qos.h>
+#include <linux/pm_runtime.h>
+#include <linux/completion.h>
+#include <asm/intel-mid.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/intel_mid_ssp_spi.h>
+
+#define DRIVER_NAME "intel_mid_ssp_spi_unified"
+
+MODULE_AUTHOR("Ken Mills");
+MODULE_DESCRIPTION("Bulverde SSP core SPI contoller");
+MODULE_LICENSE("GPL");
+
+static int ssp_timing_wr;
+
+#ifdef DUMP_RX
+static void dump_trailer(const struct device *dev, char *buf, int len, int sz)
+{
+	int tlen1 = (len < sz ? len : sz);
+	int tlen2 =  ((len - sz) > sz) ? sz : (len - sz);
+	unsigned char *p;
+	static char msg[MAX_SPI_TRANSFER_SIZE];
+
+	memset(msg, '\0', sizeof(msg));
+	p = buf;
+	while (p < buf + tlen1)
+		sprintf(msg, "%s%02x", msg, (unsigned int)*p++);
+
+	if (tlen2 > 0) {
+		sprintf(msg, "%s .....", msg);
+		p = (buf+len) - tlen2;
+		while (p < buf + len)
+			sprintf(msg, "%s%02x", msg, (unsigned int)*p++);
+	}
+
+	dev_info(dev, "DUMP: %p[0:%d ... %d:%d]:%s", buf, tlen1 - 1,
+		   len-tlen2, len - 1, msg);
+}
+#endif
+
+static inline u8 ssp_cfg_get_mode(u8 ssp_cfg)
+{
+	if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER ||
+	    intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_ANNIEDALE)
+		return (ssp_cfg) & 0x03;
+	else
+		return (ssp_cfg) & 0x07;
+}
+
+static inline u8 ssp_cfg_get_spi_bus_nb(u8 ssp_cfg)
+{
+	if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER ||
+	    intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_ANNIEDALE)
+		return ((ssp_cfg) >> 2) & 0x07;
+	else
+		return ((ssp_cfg) >> 3) & 0x07;
+}
+
+static inline u8 ssp_cfg_is_spi_slave(u8 ssp_cfg)
+{
+	if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER ||
+	    intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_ANNIEDALE)
+		return (ssp_cfg) & 0x20;
+	else
+		return (ssp_cfg) & 0x40;
+}
+
+static inline u32 is_tx_fifo_empty(struct ssp_drv_context *sspc)
+{
+	u32 sssr;
+	sssr = read_SSSR(sspc->ioaddr);
+	if ((sssr & SSSR_TFL_MASK) || (sssr & SSSR_TNF) == 0)
+		return 0;
+	else
+		return 1;
+}
+
+static inline u32 is_rx_fifo_empty(struct ssp_drv_context *sspc)
+{
+	return ((read_SSSR(sspc->ioaddr) & SSSR_RNE) == 0);
+}
+
+static inline void disable_interface(struct ssp_drv_context *sspc)
+{
+	void *reg = sspc->ioaddr;
+	write_SSCR0(read_SSCR0(reg) & ~SSCR0_SSE, reg);
+}
+
+static inline void disable_triggers(struct ssp_drv_context *sspc)
+{
+	void *reg = sspc->ioaddr;
+	write_SSCR1(read_SSCR1(reg) & ~sspc->cr1_sig, reg);
+}
+
+
+static void flush(struct ssp_drv_context *sspc)
+{
+	void *reg = sspc->ioaddr;
+	u32 i = 0;
+
+	/* If the transmit fifo is not empty, reset the interface. */
+	if (!is_tx_fifo_empty(sspc)) {
+		dev_err(&sspc->pdev->dev, "TX FIFO not empty. Reset of SPI IF");
+		disable_interface(sspc);
+		return;
+	}
+
+	dev_dbg(&sspc->pdev->dev, " SSSR=%x\r\n", read_SSSR(reg));
+	while (!is_rx_fifo_empty(sspc) && (i < SPI_FIFO_SIZE + 1)) {
+		read_SSDR(reg);
+		i++;
+	}
+	WARN(i > 0, "%d words flush occured\n", i);
+
+	return;
+}
+
+static int null_writer(struct ssp_drv_context *sspc)
+{
+	void *reg = sspc->ioaddr;
+	u8 n_bytes = sspc->n_bytes;
+
+	if (((read_SSSR(reg) & SSSR_TFL_MASK) == SSSR_TFL_MASK)
+		|| (sspc->tx == sspc->tx_end))
+		return 0;
+
+	write_SSDR(0, reg);
+	sspc->tx += n_bytes;
+
+	return 1;
+}
+
+static int null_reader(struct ssp_drv_context *sspc)
+{
+	void *reg = sspc->ioaddr;
+	u8 n_bytes = sspc->n_bytes;
+
+	while ((read_SSSR(reg) & SSSR_RNE)
+		&& (sspc->rx < sspc->rx_end)) {
+		read_SSDR(reg);
+		sspc->rx += n_bytes;
+	}
+
+	return sspc->rx == sspc->rx_end;
+}
+
+static int u8_writer(struct ssp_drv_context *sspc)
+{
+	void *reg = sspc->ioaddr;
+	if (((read_SSSR(reg) & SSSR_TFL_MASK) == SSSR_TFL_MASK)
+		|| (sspc->tx == sspc->tx_end))
+		return 0;
+
+	write_SSDR(*(u8 *)(sspc->tx), reg);
+	++sspc->tx;
+
+	return 1;
+}
+
+static int u8_reader(struct ssp_drv_context *sspc)
+{
+	void *reg = sspc->ioaddr;
+	while ((read_SSSR(reg) & SSSR_RNE)
+		&& (sspc->rx < sspc->rx_end)) {
+		*(u8 *)(sspc->rx) = read_SSDR(reg);
+		++sspc->rx;
+	}
+
+	return sspc->rx == sspc->rx_end;
+}
+
+static int u16_writer(struct ssp_drv_context *sspc)
+{
+	void *reg = sspc->ioaddr;
+	if (((read_SSSR(reg) & SSSR_TFL_MASK) == SSSR_TFL_MASK)
+		|| (sspc->tx == sspc->tx_end))
+		return 0;
+
+	write_SSDR(*(u16 *)(sspc->tx), reg);
+	sspc->tx += 2;
+
+	return 1;
+}
+
+static int u16_reader(struct ssp_drv_context *sspc)
+{
+	void *reg = sspc->ioaddr;
+	while ((read_SSSR(reg) & SSSR_RNE) && (sspc->rx < sspc->rx_end)) {
+		*(u16 *)(sspc->rx) = read_SSDR(reg);
+		sspc->rx += 2;
+	}
+
+	return sspc->rx == sspc->rx_end;
+}
+
+static int u32_writer(struct ssp_drv_context *sspc)
+{
+	void *reg = sspc->ioaddr;
+	if (((read_SSSR(reg) & SSSR_TFL_MASK) == SSSR_TFL_MASK)
+		|| (sspc->tx == sspc->tx_end))
+		return 0;
+
+	write_SSDR(*(u32 *)(sspc->tx), reg);
+	sspc->tx += 4;
+
+	return 1;
+}
+
+static int u32_reader(struct ssp_drv_context *sspc)
+{
+	void *reg = sspc->ioaddr;
+	while ((read_SSSR(reg) & SSSR_RNE) && (sspc->rx < sspc->rx_end)) {
+		*(u32 *)(sspc->rx) = read_SSDR(reg);
+		sspc->rx += 4;
+	}
+
+	return sspc->rx == sspc->rx_end;
+}
+
+static bool chan_filter(struct dma_chan *chan, void *param)
+{
+	struct ssp_drv_context *sspc = param;
+	bool ret = false;
+
+	if (!sspc->dmac1)
+		return ret;
+
+	if (chan->device->dev == &sspc->dmac1->dev)
+		ret = true;
+
+	return ret;
+}
+
+/**
+ * unmap_dma_buffers() - Unmap the DMA buffers used during the last transfer.
+ * @sspc:	Pointer to the private driver context
+ */
+static void unmap_dma_buffers(struct ssp_drv_context *sspc)
+{
+	struct device *dev = &sspc->pdev->dev;
+
+	if (!sspc->dma_mapped)
+		return;
+	dma_unmap_single(dev, sspc->rx_dma, sspc->len, PCI_DMA_FROMDEVICE);
+	dma_unmap_single(dev, sspc->tx_dma, sspc->len, PCI_DMA_TODEVICE);
+	sspc->dma_mapped = 0;
+}
+
+/**
+ * intel_mid_ssp_spi_dma_done() - End of DMA transfer callback
+ * @arg:	Pointer to the data provided at callback registration
+ *
+ * This function is set as callback for both RX and TX DMA transfers. The
+ * RX or TX 'done' flag is set acording to the direction of the ended
+ * transfer. Then, if both RX and TX flags are set, it means that the
+ * transfer job is completed.
+ */
+static void intel_mid_ssp_spi_dma_done(void *arg)
+{
+	struct callback_param *cb_param = (struct callback_param *)arg;
+	struct ssp_drv_context *sspc = cb_param->drv_context;
+	struct device *dev = &sspc->pdev->dev;
+	void *reg = sspc->ioaddr;
+
+	if (cb_param->direction == TX_DIRECTION) {
+		dma_sync_single_for_cpu(dev, sspc->tx_dma,
+			sspc->len, DMA_TO_DEVICE);
+		sspc->txdma_done = 1;
+	} else {
+		sspc->rxdma_done = 1;
+		dma_sync_single_for_cpu(dev, sspc->rx_dma,
+			sspc->len, DMA_FROM_DEVICE);
+	}
+
+	dev_dbg(dev, "DMA callback for direction %d [RX done:%d] [TX done:%d]\n",
+		cb_param->direction, sspc->rxdma_done,
+		sspc->txdma_done);
+
+	if (sspc->txdma_done && sspc->rxdma_done) {
+		/* Clear Status Register */
+		write_SSSR(sspc->clear_sr, reg);
+		dev_dbg(dev, "DMA done\n");
+		/* Disable Triggers to DMA or to CPU*/
+		disable_triggers(sspc);
+		unmap_dma_buffers(sspc);
+
+		queue_work(sspc->dma_wq, &sspc->complete_work);
+	}
+}
+
+/**
+ * intel_mid_ssp_spi_dma_init() - Initialize DMA
+ * @sspc:	Pointer to the private driver context
+ *
+ * This function is called at driver setup phase to allocate DMA
+ * ressources.
+ */
+static void intel_mid_ssp_spi_dma_init(struct ssp_drv_context *sspc)
+{
+	struct intel_mid_dma_slave *rxs, *txs;
+	struct dma_slave_config *ds;
+	dma_cap_mask_t mask;
+	struct device *dev = &sspc->pdev->dev;
+	unsigned int device_id;
+
+	/* Configure RX channel parameters */
+	rxs = &sspc->dmas_rx;
+	ds = &rxs->dma_slave;
+
+	ds->direction = DMA_FROM_DEVICE;
+	rxs->hs_mode = LNW_DMA_HW_HS;
+	rxs->cfg_mode = LNW_DMA_PER_TO_MEM;
+	ds->dst_addr_width = sspc->n_bytes;
+	ds->src_addr_width = sspc->n_bytes;
+
+	if (sspc->quirks & QUIRKS_PLATFORM_BYT) {
+		/*These are fixed HW info from Baytrail datasheet*/
+		rxs->device_instance = 1; /*DMA Req line*/
+	} else if (sspc->quirks & QUIRKS_PLATFORM_MRFL)
+		rxs->device_instance = sspc->master->bus_num;
+	else
+		rxs->device_instance = 0;
+
+	/* Use a DMA burst according to the FIFO thresholds */
+	if (sspc->rx_fifo_threshold == 8) {
+		ds->src_maxburst = LNW_DMA_MSIZE_8;
+		ds->dst_maxburst = LNW_DMA_MSIZE_8;
+	} else if (sspc->rx_fifo_threshold == 4) {
+		ds->src_maxburst = LNW_DMA_MSIZE_4;
+		ds->dst_maxburst = LNW_DMA_MSIZE_4;
+	} else {
+		ds->src_maxburst = LNW_DMA_MSIZE_1;
+		ds->dst_maxburst = LNW_DMA_MSIZE_1;
+	}
+
+	/* Configure TX channel parameters */
+	txs = &sspc->dmas_tx;
+	ds = &txs->dma_slave;
+
+	ds->direction = DMA_TO_DEVICE;
+	txs->hs_mode = LNW_DMA_HW_HS;
+	txs->cfg_mode = LNW_DMA_MEM_TO_PER;
+	ds->src_addr_width = sspc->n_bytes;
+	ds->dst_addr_width = sspc->n_bytes;
+
+	if (sspc->quirks & QUIRKS_PLATFORM_BYT) {
+		/*These are fixed HW info from Baytrail datasheet*/
+		txs->device_instance = 0;/*DMA Req Line*/
+	} else if (sspc->quirks & QUIRKS_PLATFORM_MRFL)
+		txs->device_instance = sspc->master->bus_num;
+	else
+		txs->device_instance = 0;
+
+	/* Use a DMA burst according to the FIFO thresholds */
+	if (sspc->rx_fifo_threshold == 8) {
+		ds->src_maxburst = LNW_DMA_MSIZE_8;
+		ds->dst_maxburst = LNW_DMA_MSIZE_8;
+	} else if (sspc->rx_fifo_threshold == 4) {
+		ds->src_maxburst = LNW_DMA_MSIZE_4;
+		ds->dst_maxburst = LNW_DMA_MSIZE_4;
+	} else {
+		ds->src_maxburst = LNW_DMA_MSIZE_1;
+		ds->dst_maxburst = LNW_DMA_MSIZE_1;
+	}
+
+	/* Nothing more to do if already initialized */
+	if (sspc->dma_initialized)
+		return;
+
+	/* Use DMAC1 */
+	if (sspc->quirks & QUIRKS_PLATFORM_MRST)
+		device_id = PCI_MRST_DMAC1_ID;
+	else if (sspc->quirks & QUIRKS_PLATFORM_BYT)
+		device_id = PCI_BYT_DMAC1_ID;
+	else if (sspc->quirks & QUIRKS_PLATFORM_MRFL)
+		device_id = PCI_MRFL_DMAC_ID;
+	else
+		device_id = PCI_MDFL_DMAC1_ID;
+
+	sspc->dmac1 = pci_get_device(PCI_VENDOR_ID_INTEL, device_id, NULL);
+	if (!sspc->dmac1) {
+		dev_err(dev, "Can't find DMAC1");
+		return;
+	}
+
+	if (sspc->quirks & QUIRKS_SRAM_ADDITIONAL_CPY) {
+		sspc->virt_addr_sram_rx = ioremap_nocache(SRAM_BASE_ADDR,
+				2 * MAX_SPI_TRANSFER_SIZE);
+		if (sspc->virt_addr_sram_rx)
+			sspc->virt_addr_sram_tx = sspc->virt_addr_sram_rx +
+							MAX_SPI_TRANSFER_SIZE;
+		else
+			dev_err(dev, "Virt_addr_sram_rx is null\n");
+	}
+
+	/* 1. Allocate rx channel */
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_MEMCPY, mask);
+	dma_cap_set(DMA_SLAVE, mask);
+
+	sspc->rxchan = dma_request_channel(mask, chan_filter, sspc);
+	if (!sspc->rxchan)
+		goto err_exit;
+
+	sspc->rxchan->private = rxs;
+
+	/* 2. Allocate tx channel */
+	dma_cap_set(DMA_SLAVE, mask);
+	dma_cap_set(DMA_MEMCPY, mask);
+
+	sspc->txchan = dma_request_channel(mask, chan_filter, sspc);
+	if (!sspc->txchan)
+		goto free_rxchan;
+	else
+		sspc->txchan->private = txs;
+
+	/* set the dma done bit to 1 */
+	sspc->txdma_done = 1;
+	sspc->rxdma_done = 1;
+
+	sspc->tx_param.drv_context  = sspc;
+	sspc->tx_param.direction = TX_DIRECTION;
+	sspc->rx_param.drv_context  = sspc;
+	sspc->rx_param.direction = RX_DIRECTION;
+
+	sspc->dma_initialized = 1;
+	return;
+
+free_rxchan:
+	dma_release_channel(sspc->rxchan);
+err_exit:
+	dev_err(dev, "Error : DMA Channel Not available\n");
+
+	if (sspc->quirks & QUIRKS_SRAM_ADDITIONAL_CPY)
+		iounmap(sspc->virt_addr_sram_rx);
+
+	pci_dev_put(sspc->dmac1);
+	return;
+}
+
+/**
+ * intel_mid_ssp_spi_dma_exit() - Release DMA ressources
+ * @sspc:	Pointer to the private driver context
+ */
+static void intel_mid_ssp_spi_dma_exit(struct ssp_drv_context *sspc)
+{
+	dma_release_channel(sspc->txchan);
+	dma_release_channel(sspc->rxchan);
+
+	if (sspc->quirks & QUIRKS_SRAM_ADDITIONAL_CPY)
+		iounmap(sspc->virt_addr_sram_rx);
+
+	pci_dev_put(sspc->dmac1);
+}
+
+/**
+ * dma_transfer() - Initiate a DMA transfer
+ * @sspc:	Pointer to the private driver context
+ */
+static void dma_transfer(struct ssp_drv_context *sspc)
+{
+	dma_addr_t ssdr_addr;
+	struct dma_async_tx_descriptor *txdesc = NULL, *rxdesc = NULL;
+	struct dma_chan *txchan, *rxchan;
+	enum dma_ctrl_flags flag;
+	struct device *dev = &sspc->pdev->dev;
+
+	/* get Data Read/Write address */
+	ssdr_addr = (dma_addr_t)(sspc->paddr + 0x10);
+
+	if (sspc->tx_dma)
+		sspc->txdma_done = 0;
+
+	if (sspc->rx_dma)
+		sspc->rxdma_done = 0;
+
+	/* 2. prepare the RX dma transfer */
+	txchan = sspc->txchan;
+	rxchan = sspc->rxchan;
+
+	flag = DMA_PREP_INTERRUPT | DMA_CTRL_ACK;
+
+	if (likely(sspc->quirks & QUIRKS_DMA_USE_NO_TRAIL)) {
+		/* Since the DMA is configured to do 32bits access */
+		/* to/from the DDR, the DMA transfer size must be  */
+		/* a multiple of 4 bytes                           */
+		sspc->len_dma_rx = sspc->len & ~(4 - 1);
+		sspc->len_dma_tx = sspc->len_dma_rx;
+
+		/* In Rx direction, TRAIL Bytes are handled by memcpy */
+		if (sspc->rx_dma &&
+			(sspc->len_dma_rx >
+				sspc->rx_fifo_threshold * sspc->n_bytes))
+			sspc->len_dma_rx = TRUNCATE(sspc->len_dma_rx,
+				sspc->rx_fifo_threshold * sspc->n_bytes);
+		else if (!sspc->rx_dma)
+			dev_err(dev, "ERROR : rx_dma is null\r\n");
+	} else {
+		/* TRAIL Bytes are handled by DMA */
+		if (sspc->rx_dma) {
+			sspc->len_dma_rx = sspc->len;
+			sspc->len_dma_tx = sspc->len;
+		} else
+			dev_err(dev, "ERROR : sspc->rx_dma is null!\n");
+	}
+
+	sspc->dmas_rx.dma_slave.src_addr = ssdr_addr;
+	rxchan->device->device_control(rxchan, DMA_SLAVE_CONFIG,
+		(unsigned long)&(sspc->dmas_rx.dma_slave));
+	dma_sync_single_for_device(dev, sspc->rx_dma,
+		sspc->len, DMA_FROM_DEVICE);
+
+	rxdesc = rxchan->device->device_prep_dma_memcpy
+		(rxchan,			/* DMA Channel */
+		sspc->rx_dma,			/* DAR */
+		ssdr_addr,			/* SAR */
+		sspc->len_dma_rx,		/* Data Length */
+		flag);					/* Flag */
+
+	if (rxdesc) {
+		rxdesc->callback = intel_mid_ssp_spi_dma_done;
+		rxdesc->callback_param = &sspc->rx_param;
+	} else {
+		dev_dbg(dev, "rxdesc is null! (len_dma_rx:%d)\n",
+			sspc->len_dma_rx);
+		sspc->rxdma_done = 1;
+	}
+
+	/* 3. prepare the TX dma transfer */
+	sspc->dmas_tx.dma_slave.dst_addr = ssdr_addr;
+	txchan->device->device_control(txchan, DMA_SLAVE_CONFIG,
+		(unsigned long)&(sspc->dmas_tx.dma_slave));
+	dma_sync_single_for_device(dev, sspc->tx_dma,
+		sspc->len, DMA_TO_DEVICE);
+
+	if (sspc->tx_dma) {
+		txdesc = txchan->device->device_prep_dma_memcpy
+			(txchan,			/* DMA Channel */
+			ssdr_addr,			/* DAR */
+			sspc->tx_dma,			/* SAR */
+			sspc->len_dma_tx,		/* Data Length */
+			flag);				/* Flag */
+		if (txdesc) {
+			txdesc->callback = intel_mid_ssp_spi_dma_done;
+			txdesc->callback_param = &sspc->tx_param;
+		} else {
+			dev_dbg(dev, "txdesc is null! (len_dma_tx:%d)\n",
+				sspc->len_dma_tx);
+			sspc->txdma_done = 1;
+		}
+	} else {
+		dev_err(dev, "ERROR : sspc->tx_dma is null!\n");
+		return;
+	}
+
+	dev_dbg(dev, "DMA transfer len:%d len_dma_tx:%d len_dma_rx:%d\n",
+		sspc->len, sspc->len_dma_tx, sspc->len_dma_rx);
+
+	if (rxdesc || txdesc) {
+		if (rxdesc) {
+			dev_dbg(dev, "Firing DMA RX channel\n");
+			rxdesc->tx_submit(rxdesc);
+		}
+		if (txdesc) {
+			dev_dbg(dev, "Firing DMA TX channel\n");
+			txdesc->tx_submit(txdesc);
+		}
+	} else {
+		struct callback_param cb_param;
+		cb_param.drv_context = sspc;
+		dev_dbg(dev, "Bypassing DMA transfer\n");
+		intel_mid_ssp_spi_dma_done(&cb_param);
+	}
+}
+
+/**
+ * map_dma_buffers() - Map DMA buffer before a transfer
+ * @sspc:	Pointer to the private drivzer context
+ */
+static int map_dma_buffers(struct ssp_drv_context *sspc)
+{
+	struct device *dev = &sspc->pdev->dev;
+
+	if (unlikely(sspc->dma_mapped)) {
+		dev_err(dev, "ERROR : DMA buffers already mapped\n");
+		return 0;
+	}
+	if (unlikely(sspc->quirks & QUIRKS_SRAM_ADDITIONAL_CPY)) {
+		/* Copy sspc->tx into sram_tx */
+		memcpy_toio(sspc->virt_addr_sram_tx, sspc->tx, sspc->len);
+#ifdef DUMP_RX
+		dump_trailer(&sspc->pdev->dev, sspc->tx, sspc->len, 16);
+#endif
+		sspc->rx_dma = SRAM_RX_ADDR;
+		sspc->tx_dma = SRAM_TX_ADDR;
+	} else {
+		/* no QUIRKS_SRAM_ADDITIONAL_CPY */
+		if (unlikely(sspc->dma_mapped))
+			return 1;
+
+		sspc->tx_dma = dma_map_single(dev, sspc->tx, sspc->len,
+						PCI_DMA_TODEVICE);
+		if (unlikely(dma_mapping_error(dev, sspc->tx_dma))) {
+			dev_err(dev, "ERROR : tx dma mapping failed\n");
+			return 0;
+		}
+
+		sspc->rx_dma = dma_map_single(dev, sspc->rx, sspc->len,
+						PCI_DMA_FROMDEVICE);
+		if (unlikely(dma_mapping_error(dev, sspc->rx_dma))) {
+			dma_unmap_single(dev, sspc->tx_dma,
+				sspc->len, DMA_TO_DEVICE);
+			dev_err(dev, "ERROR : rx dma mapping failed\n");
+			return 0;
+		}
+	}
+	return 1;
+}
+
+/**
+ * drain_trail() - Handle trailing bytes of a transfer
+ * @sspc:	Pointer to the private driver context
+ *
+ * This function handles the trailing bytes of a transfer for the case
+ * they are not handled by the DMA.
+ */
+void drain_trail(struct ssp_drv_context *sspc)
+{
+	struct device *dev = &sspc->pdev->dev;
+	void *reg = sspc->ioaddr;
+
+	if (sspc->len != sspc->len_dma_rx) {
+		dev_dbg(dev, "Handling trailing bytes. SSSR:%08x\n",
+			read_SSSR(reg));
+		sspc->rx += sspc->len_dma_rx;
+		sspc->tx += sspc->len_dma_tx;
+
+		while ((sspc->tx != sspc->tx_end) ||
+			(sspc->rx != sspc->rx_end)) {
+			sspc->read(sspc);
+			sspc->write(sspc);
+		}
+	}
+}
+
+/**
+ * sram_to_ddr_cpy() - Copy data from Langwell SDRAM to DDR
+ * @sspc:	Pointer to the private driver context
+ */
+static void sram_to_ddr_cpy(struct ssp_drv_context *sspc)
+{
+	u32 length = sspc->len;
+
+	if ((sspc->quirks & QUIRKS_DMA_USE_NO_TRAIL)
+		&& (sspc->len > sspc->rx_fifo_threshold * sspc->n_bytes))
+		length = TRUNCATE(sspc->len,
+			sspc->rx_fifo_threshold * sspc->n_bytes);
+
+	memcpy_fromio(sspc->rx, sspc->virt_addr_sram_rx, length);
+}
+
+static void int_transfer_complete(struct ssp_drv_context *sspc)
+{
+	void *reg = sspc->ioaddr;
+	struct spi_message *msg;
+	struct device *dev = &sspc->pdev->dev;
+
+	if (unlikely(sspc->quirks & QUIRKS_USE_PM_QOS))
+		pm_qos_update_request(&sspc->pm_qos_req,
+					PM_QOS_DEFAULT_VALUE);
+
+	if (unlikely(sspc->quirks & QUIRKS_SRAM_ADDITIONAL_CPY))
+		sram_to_ddr_cpy(sspc);
+
+	if (likely(sspc->quirks & QUIRKS_DMA_USE_NO_TRAIL))
+		drain_trail(sspc);
+	else
+		/* Stop getting Time Outs */
+		write_SSTO(0, reg);
+
+	sspc->cur_msg->status = 0;
+	sspc->cur_msg->actual_length = sspc->len;
+
+#ifdef DUMP_RX
+	dump_trailer(dev, sspc->rx, sspc->len, 16);
+#endif
+
+	if (sspc->cs_control)
+		sspc->cs_control(!sspc->cs_assert);
+
+	dev_dbg(dev, "End of transfer. SSSR:%08X\n", read_SSSR(reg));
+	msg = sspc->cur_msg;
+	if (likely(msg->complete))
+		msg->complete(msg->context);
+	complete(&sspc->msg_done);
+}
+
+static void int_transfer_complete_work(struct work_struct *work)
+{
+	struct ssp_drv_context *sspc = container_of(work,
+				struct ssp_drv_context, complete_work);
+
+	int_transfer_complete(sspc);
+}
+
+static void poll_transfer_complete(struct ssp_drv_context *sspc)
+{
+	/* Update total byte transfered return count actual bytes read */
+	sspc->cur_msg->actual_length += sspc->len - (sspc->rx_end - sspc->rx);
+
+	sspc->cur_msg->status = 0;
+}
+
+/**
+ * ssp_int() - Interrupt handler
+ * @irq
+ * @dev_id
+ *
+ * The SSP interrupt is not used for transfer which are handled by
+ * DMA or polling: only under/over run are catched to detect
+ * broken transfers.
+ */
+static irqreturn_t ssp_int(int irq, void *dev_id)
+{
+	struct ssp_drv_context *sspc = dev_id;
+	void *reg = sspc->ioaddr;
+	struct device *dev = &sspc->pdev->dev;
+	u32 status = read_SSSR(reg);
+
+	/* It should never be our interrupt since SSP will */
+	/* only trigs interrupt for under/over run.*/
+	if (likely(!(status & sspc->mask_sr)))
+		return IRQ_NONE;
+
+	if (status & SSSR_ROR || status & SSSR_TUR) {
+		dev_err(dev, "--- SPI ROR or TUR occurred : SSSR=%x\n",	status);
+		WARN_ON(1);
+		if (status & SSSR_ROR)
+			dev_err(dev, "we have Overrun\n");
+		if (status & SSSR_TUR)
+			dev_err(dev, "we have Underrun\n");
+	}
+
+	/* We can fall here when not using DMA mode */
+	if (!sspc->cur_msg) {
+		disable_interface(sspc);
+		disable_triggers(sspc);
+	}
+	/* clear status register */
+	write_SSSR(sspc->clear_sr, reg);
+	return IRQ_HANDLED;
+}
+
+static void poll_writer(struct work_struct *work)
+{
+	struct ssp_drv_context *sspc =
+		container_of(work, struct ssp_drv_context, poll_write);
+
+	while (sspc->tx < sspc->tx_end)
+		sspc->write(sspc);
+
+}
+
+/*
+ * Perform a single transfer.
+ */
+static void poll_transfer(unsigned long data)
+{
+	struct ssp_drv_context *sspc = (void *)data;
+
+	while (!sspc->read(sspc))
+		cpu_relax();
+
+	poll_transfer_complete(sspc);
+}
+
+/**
+ * start_bitbanging() - Clock synchronization by bit banging
+ * @sspc:	Pointer to private driver context
+ *
+ * This clock synchronization will be removed as soon as it is
+ * handled by the SCU.
+ */
+static void start_bitbanging(struct ssp_drv_context *sspc)
+{
+	u32 sssr;
+	u32 count = 0;
+	u32 cr0;
+	void *i2c_reg = sspc->I2C_ioaddr;
+	struct device *dev = &sspc->pdev->dev;
+	void *reg = sspc->ioaddr;
+	struct chip_data *chip = spi_get_ctldata(sspc->cur_msg->spi);
+	cr0 = chip->cr0;
+
+	dev_warn(dev, "In %s : Starting bit banging\n",
+		__func__);
+	if (read_SSSR(reg) & SSP_NOT_SYNC)
+		dev_warn(dev, "SSP clock desynchronized.\n");
+	if (!(read_SSCR0(reg) & SSCR0_SSE))
+		dev_warn(dev, "in SSCR0, SSP disabled.\n");
+
+	dev_dbg(dev, "SSP not ready, start CLK sync\n");
+
+	write_SSCR0(cr0 & ~SSCR0_SSE, reg);
+	write_SSPSP(0x02010007, reg);
+
+	write_SSTO(chip->timeout, reg);
+	write_SSCR0(cr0, reg);
+
+	/*
+	*  This routine uses the DFx block to override the SSP inputs
+	*  and outputs allowing us to bit bang SSPSCLK. On Langwell,
+	*  we have to generate the clock to clear busy.
+	*/
+	write_I2CDATA(0x3, i2c_reg);
+	udelay(I2C_ACCESS_USDELAY);
+	write_I2CCTRL(0x01070034, i2c_reg);
+	udelay(I2C_ACCESS_USDELAY);
+	write_I2CDATA(0x00000099, i2c_reg);
+	udelay(I2C_ACCESS_USDELAY);
+	write_I2CCTRL(0x01070038, i2c_reg);
+	udelay(I2C_ACCESS_USDELAY);
+	sssr = read_SSSR(reg);
+
+	/* Bit bang the clock until CSS clears */
+	while ((sssr & 0x400000) && (count < MAX_BITBANGING_LOOP)) {
+		write_I2CDATA(0x2, i2c_reg);
+		udelay(I2C_ACCESS_USDELAY);
+		write_I2CCTRL(0x01070034, i2c_reg);
+		udelay(I2C_ACCESS_USDELAY);
+		write_I2CDATA(0x3, i2c_reg);
+		udelay(I2C_ACCESS_USDELAY);
+		write_I2CCTRL(0x01070034, i2c_reg);
+		udelay(I2C_ACCESS_USDELAY);
+		sssr = read_SSSR(reg);
+		count++;
+	}
+	if (count >= MAX_BITBANGING_LOOP)
+		dev_err(dev, "ERROR in %s : infinite loop on bit banging. Aborting\n",
+								__func__);
+
+	dev_dbg(dev, "---Bit bang count=%d\n", count);
+
+	write_I2CDATA(0x0, i2c_reg);
+	udelay(I2C_ACCESS_USDELAY);
+	write_I2CCTRL(0x01070038, i2c_reg);
+}
+
+static unsigned int ssp_get_clk_div(struct ssp_drv_context *sspc, int speed)
+{
+	if (sspc->quirks & QUIRKS_PLATFORM_MRFL)
+		/* The clock divider shall stay between 0 and 4095. */
+		return clamp(25000000 / speed - 1, 0, 4095);
+	else
+		return clamp(100000000 / speed - 1, 3, 4095);
+}
+
+
+static int ssp_get_speed(struct ssp_drv_context *sspc, int clk_div)
+{
+	if (sspc->quirks & QUIRKS_PLATFORM_MRFL)
+		return 25000000 / (clk_div + 1);
+	else
+		return 100000000 / (clk_div + 1);
+}
+
+/**
+ * transfer() - Start a SPI transfer
+ * @spi:	Pointer to the spi_device struct
+ * @msg:	Pointer to the spi_message struct
+ */
+static int transfer(struct spi_device *spi, struct spi_message *msg)
+{
+	struct ssp_drv_context *sspc = spi_master_get_devdata(spi->master);
+	unsigned long flags;
+
+	msg->actual_length = 0;
+	msg->status = -EINPROGRESS;
+	spin_lock_irqsave(&sspc->lock, flags);
+	list_add_tail(&msg->queue, &sspc->queue);
+	if (!sspc->suspended)
+		queue_work(sspc->workqueue, &sspc->pump_messages);
+	spin_unlock_irqrestore(&sspc->lock, flags);
+
+	return 0;
+}
+
+static int handle_message(struct ssp_drv_context *sspc)
+{
+	struct chip_data *chip = NULL;
+	struct spi_transfer *transfer = NULL;
+	void *reg = sspc->ioaddr;
+	u32 cr0, saved_cr0, cr1, saved_cr1;
+	struct device *dev = &sspc->pdev->dev;
+	struct spi_message *msg = sspc->cur_msg;
+	u32 clk_div, saved_speed_hz, speed_hz;
+	u8 dma_enabled;
+	u32 timeout;
+	u8 chip_select;
+	u32 mask = 0;
+	int bits_per_word, saved_bits_per_word;
+	unsigned long flags;
+
+	chip = spi_get_ctldata(msg->spi);
+
+	/* get every chip data we need to handle atomically the full message */
+	spin_lock_irqsave(&sspc->lock, flags);
+	saved_cr0 = chip->cr0;
+	saved_cr1 = chip->cr1;
+	saved_bits_per_word = msg->spi->bits_per_word;
+	saved_speed_hz = chip->speed_hz;
+	sspc->cs_control = chip->cs_control;
+	timeout = chip->timeout;
+	chip_select = chip->chip_select;
+	dma_enabled = chip->dma_enabled;
+	spin_unlock_irqrestore(&sspc->lock, flags);
+
+	list_for_each_entry(transfer, &msg->transfers, transfer_list) {
+
+		/* Check transfer length */
+		if (unlikely((transfer->len > MAX_SPI_TRANSFER_SIZE) ||
+					(transfer->len == 0))) {
+			dev_warn(dev, "transfer length null or greater than %d\n",
+					MAX_SPI_TRANSFER_SIZE);
+			dev_warn(dev, "length = %d\n", transfer->len);
+			msg->status = -EINVAL;
+
+			if (msg->complete)
+				msg->complete(msg->context);
+			complete(&sspc->msg_done);
+			return 0;
+		}
+
+		/* If the bits_per_word field in non-zero in the spi_transfer provided
+		 * by the user-space, consider this value. Otherwise consider the
+		 * default bits_per_word field from the spi setting. */
+		if (transfer->bits_per_word) {
+			bits_per_word = transfer->bits_per_word;
+			cr0 = saved_cr0;
+			cr0 &= ~(SSCR0_EDSS | SSCR0_DSS);
+			cr0 |= SSCR0_DataSize(bits_per_word > 16 ?
+					bits_per_word - 16 : bits_per_word)
+				| (bits_per_word > 16 ? SSCR0_EDSS : 0);
+		} else {
+			/* Use default value. */
+			bits_per_word = saved_bits_per_word;
+			cr0 = saved_cr0;
+		}
+
+		if ((bits_per_word < MIN_BITS_PER_WORD
+					|| bits_per_word > MAX_BITS_PER_WORD)) {
+			dev_warn(dev, "invalid wordsize\n");
+			msg->status = -EINVAL;
+			if (msg->complete)
+				msg->complete(msg->context);
+			complete(&sspc->msg_done);
+			return 0;
+		}
+
+		/* Check message length and bit per words consistency */
+		if (bits_per_word <= 8)
+			mask = 0;
+		else if (bits_per_word <= 16)
+			mask = 1;
+		else if (bits_per_word <= 32)
+			mask = 3;
+
+		if (transfer->len & mask) {
+			dev_warn(dev,
+					"message rejected : data length %d not multiple of %d "
+					"while in %d bits mode\n",
+					transfer->len,
+					mask + 1,
+					(mask == 1) ? 16 : 32);
+			msg->status = -EINVAL;
+			if (msg->complete)
+				msg->complete(msg->context);
+			complete(&sspc->msg_done);
+			return 0;
+		}
+
+		/* Flush any remaining data (in case of failed previous transfer) */
+		flush(sspc);
+
+		dev_dbg(dev, "%d bits/word, mode %d\n",
+				bits_per_word, msg->spi->mode & 0x3);
+		if (bits_per_word <= 8) {
+			sspc->n_bytes = 1;
+			sspc->read = u8_reader;
+			sspc->write = u8_writer;
+		} else if (bits_per_word <= 16) {
+			sspc->n_bytes = 2;
+			sspc->read = u16_reader;
+			sspc->write = u16_writer;
+		} else if (bits_per_word <= 32) {
+			if (!ssp_timing_wr)
+				cr0 |= SSCR0_EDSS;
+			sspc->n_bytes = 4;
+			sspc->read = u32_reader;
+			sspc->write = u32_writer;
+		}
+		sspc->tx  = (void *)transfer->tx_buf;
+		sspc->rx  = (void *)transfer->rx_buf;
+		sspc->len = transfer->len;
+		sspc->cs_change = transfer->cs_change;
+
+		if (likely(dma_enabled)) {
+			sspc->dma_mapped = map_dma_buffers(sspc);
+			if (unlikely(!sspc->dma_mapped))
+				return 0;
+		}
+		sspc->tx  = (void *)transfer->tx_buf;
+		sspc->rx  = (void *)transfer->rx_buf;
+		sspc->len = transfer->len;
+		sspc->cs_control = chip->cs_control;
+		sspc->cs_change = transfer->cs_change;
+
+		if (likely(chip->dma_enabled)) {
+			sspc->dma_mapped = map_dma_buffers(sspc);
+			if (unlikely(!sspc->dma_mapped))
+				return 0;
+		} else {
+			sspc->write = sspc->tx ? sspc->write : null_writer;
+			sspc->read  = sspc->rx ? sspc->read : null_reader;
+		}
+		sspc->tx_end = sspc->tx + transfer->len;
+		sspc->rx_end = sspc->rx + transfer->len;
+
+		/* [REVERT ME] Bug in status register clear for Tangier simulation */
+		if ((intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER) ||
+				(intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_ANNIEDALE)) {
+			if ((intel_mid_identify_sim() != INTEL_MID_CPU_SIMULATION_VP &&
+						(intel_mid_identify_sim() != INTEL_MID_CPU_SIMULATION_HVP)))
+				write_SSSR(sspc->clear_sr, reg);
+		} else /* Clear status  */
+			write_SSSR(sspc->clear_sr, reg);
+
+		/* setup the CR1 control register */
+		cr1 = saved_cr1 | sspc->cr1_sig;
+
+		if (likely(sspc->quirks & QUIRKS_DMA_USE_NO_TRAIL)) {
+			/* in case of len smaller than burst size, adjust the RX     */
+			/* threshold. All other cases will use the default threshold */
+			/* value. The RX fifo threshold must be aligned with the DMA */
+			/* RX transfer size, which may be limited to a multiple of 4 */
+			/* bytes due to 32bits DDR access.                           */
+			if  (sspc->len / sspc->n_bytes <= sspc->rx_fifo_threshold) {
+				u32 rx_fifo_threshold;
+
+				rx_fifo_threshold = (sspc->len & ~(4 - 1)) /
+					sspc->n_bytes;
+				cr1 &= ~(SSCR1_RFT);
+				cr1 |= SSCR1_RxTresh(rx_fifo_threshold) & SSCR1_RFT;
+			} else
+				write_SSTO(timeout, reg);
+		}
+		dev_dbg(dev, "transfer len:%d  n_bytes:%d  cr0:%x  cr1:%x",
+				sspc->len, sspc->n_bytes, cr0, cr1);
+
+		/* first set CR1 */
+		write_SSCR1(cr1, reg);
+
+		if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER)
+			write_SSFS((1 << chip_select), reg);
+
+		/* recalculate the frequency for each transfer */
+		if (transfer->speed_hz)
+			speed_hz = transfer->speed_hz;
+		else
+			speed_hz = saved_speed_hz;
+
+		clk_div = ssp_get_clk_div(sspc, speed_hz);
+
+		cr0 &= ~SSCR0_SCR;
+		cr0 |= (clk_div & 0xFFF) << 8;
+
+		/* Do bitbanging only if SSP not-enabled or not-synchronized */
+		if (unlikely(((read_SSSR(reg) & SSP_NOT_SYNC) ||
+						(!(read_SSCR0(reg) & SSCR0_SSE))) &&
+					(sspc->quirks & QUIRKS_BIT_BANGING))) {
+			start_bitbanging(sspc);
+		} else {
+
+			/* if speed is higher than 6.25Mhz, enable clock delay */
+			if (speed_hz > 6250000)
+				write_SSCR2((read_SSCR2(reg) | SSCR2_CLK_DEL_EN), reg);
+			else
+				write_SSCR2((read_SSCR2(reg) & ~SSCR2_CLK_DEL_EN), reg);
+
+			/* (re)start the SSP */
+			if (ssp_timing_wr) {
+				dev_dbg(dev, "original cr0 before reset:%x",
+						cr0);
+				/*we should not disable TUM and RIM interrup*/
+				write_SSCR0(0x0000000F, reg);
+				cr0 &= ~(SSCR0_SSE);
+				dev_dbg(dev, "reset ssp:cr0:%x", cr0);
+				write_SSCR0(cr0, reg);
+				cr0 |= SSCR0_SSE;
+				dev_dbg(dev, "reset ssp:cr0:%x", cr0);
+				write_SSCR0(cr0, reg);
+			} else
+				write_SSCR0(cr0, reg);
+		}
+
+		if (sspc->cs_control)
+			sspc->cs_control(sspc->cs_assert);
+
+		if (likely(dma_enabled)) {
+			if (unlikely(sspc->quirks & QUIRKS_USE_PM_QOS))
+				pm_qos_update_request(&sspc->pm_qos_req,
+						MIN_EXIT_LATENCY);
+			dma_transfer(sspc);
+		} else {
+			/* Do the transfer syncronously */
+			queue_work(sspc->wq_poll_write, &sspc->poll_write);
+			poll_transfer((unsigned long)sspc);
+		}
+
+		if (list_is_last(&transfer->transfer_list, &msg->transfers)
+				|| sspc->cs_change) {
+			if (sspc->cs_control)
+				sspc->cs_control(!sspc->cs_assert);
+		}
+
+	} /* end of list_for_each_entry */
+
+	/* Now we are done with this entire message */
+	if (!dma_enabled) {
+		if (likely(msg->complete))
+			msg->complete(msg->context);
+		complete(&sspc->msg_done);
+	}
+
+	return 0;
+}
+
+static void pump_messages(struct work_struct *work)
+{
+	struct ssp_drv_context *sspc =
+		container_of(work, struct ssp_drv_context, pump_messages);
+	struct device *dev = &sspc->pdev->dev;
+	unsigned long flags;
+	struct spi_message *msg;
+
+	pm_runtime_get_sync(dev);
+	spin_lock_irqsave(&sspc->lock, flags);
+	while (!list_empty(&sspc->queue)) {
+		if (sspc->suspended)
+			break;
+		msg = list_entry(sspc->queue.next, struct spi_message, queue);
+		list_del_init(&msg->queue);
+		sspc->cur_msg = msg;
+		spin_unlock_irqrestore(&sspc->lock, flags);
+		reinit_completion(&sspc->msg_done);
+		handle_message(sspc);
+		wait_for_completion(&sspc->msg_done);
+		spin_lock_irqsave(&sspc->lock, flags);
+		sspc->cur_msg = NULL;
+	}
+	spin_unlock_irqrestore(&sspc->lock, flags);
+	pm_runtime_mark_last_busy(dev);
+	pm_runtime_put_autosuspend(dev);
+}
+
+/**
+ * setup() - Driver setup procedure
+ * @spi:	Pointeur to the spi_device struct
+ */
+static int setup(struct spi_device *spi)
+{
+	struct intel_mid_ssp_spi_chip *chip_info = NULL;
+	struct chip_data *chip;
+	struct ssp_drv_context *sspc =
+		spi_master_get_devdata(spi->master);
+	u32 tx_fifo_threshold;
+	u32 burst_size;
+	u32 clk_div;
+	static u32 one_time_setup = 1;
+	unsigned long flags;
+
+	spin_lock_irqsave(&sspc->lock, flags);
+	if (!spi->bits_per_word)
+		spi->bits_per_word = DFLT_BITS_PER_WORD;
+
+	if ((spi->bits_per_word < MIN_BITS_PER_WORD
+		|| spi->bits_per_word > MAX_BITS_PER_WORD)) {
+		spin_unlock_irqrestore(&sspc->lock, flags);
+		return -EINVAL;
+	}
+
+	chip = spi_get_ctldata(spi);
+	if (!chip) {
+		chip = kzalloc(sizeof(struct chip_data), GFP_KERNEL);
+		if (!chip) {
+			dev_err(&spi->dev,
+			"failed setup: can't allocate chip data\n");
+			spin_unlock_irqrestore(&sspc->lock, flags);
+			return -ENOMEM;
+		}
+	}
+	chip->cr0 = SSCR0_Motorola | SSCR0_DataSize(spi->bits_per_word > 16 ?
+		spi->bits_per_word - 16 : spi->bits_per_word)
+			| SSCR0_SSE
+			| (spi->bits_per_word > 16 ? SSCR0_EDSS : 0);
+
+	/* protocol drivers may change the chip settings, so...  */
+	/* if chip_info exists, use it                           */
+	chip_info = spi->controller_data;
+
+	/* chip_info isn't always needed */
+	chip->cr1 = 0;
+	if (chip_info) {
+		/* If user requested CS Active High need to verify that there
+		 * is no transfer pending. If this is the case, kindly fail.  */
+		if ((spi->mode & SPI_CS_HIGH) != sspc->cs_assert) {
+			if (sspc->cur_msg) {
+				dev_err(&spi->dev, "message pending... Failing\n");
+				/* A message is currently in transfer. Do not toggle CS */
+				spin_unlock_irqrestore(&sspc->lock, flags);
+				return -EAGAIN;
+			}
+			if (!chip_info->cs_control) {
+				/* unable to control cs by hand */
+				dev_err(&spi->dev,
+						"This CS does not support SPI_CS_HIGH flag\n");
+				spin_unlock_irqrestore(&sspc->lock, flags);
+				return -EINVAL;
+			}
+			sspc->cs_assert = spi->mode & SPI_CS_HIGH;
+			chip_info->cs_control(!sspc->cs_assert);
+		}
+
+		burst_size = chip_info->burst_size;
+		if (burst_size > IMSS_FIFO_BURST_8)
+			burst_size = DFLT_FIFO_BURST_SIZE;
+
+		chip->timeout = chip_info->timeout;
+
+		if (chip_info->enable_loopback)
+			chip->cr1 |= SSCR1_LBM;
+
+		chip->dma_enabled = chip_info->dma_enabled;
+		chip->cs_control = chip_info->cs_control;
+
+		/* Request platform-specific gpio and pinmux here since
+		 * it is not possible to get the intel_mid_ssp_spi_chip
+		 * structure in probe */
+		if (one_time_setup && !chip_info->dma_enabled
+				&& chip_info->platform_pinmux) {
+			chip_info->platform_pinmux();
+			one_time_setup = 0;
+		}
+
+	} else {
+		/* if no chip_info provided by protocol driver, */
+		/* set default values                           */
+		dev_info(&spi->dev, "setting default chip values\n");
+
+		burst_size = DFLT_FIFO_BURST_SIZE;
+		chip->dma_enabled = 1;
+		if (sspc->quirks & QUIRKS_DMA_USE_NO_TRAIL)
+			chip->timeout = 0;
+		else
+			chip->timeout = DFLT_TIMEOUT_VAL;
+	}
+	/* Set FIFO thresholds according to burst_size */
+	if (burst_size == IMSS_FIFO_BURST_8)
+		sspc->rx_fifo_threshold = 8;
+	else if (burst_size == IMSS_FIFO_BURST_4)
+		sspc->rx_fifo_threshold = 4;
+	else
+		sspc->rx_fifo_threshold = 1;
+	/*FIXME:this is workaround.
+	On MRST, in DMA mode, it is very strang that RX fifo can't reach
+	burst size.*/
+	if (sspc->quirks & QUIRKS_PLATFORM_MRFL && chip->dma_enabled)
+		sspc->rx_fifo_threshold = 1;
+	tx_fifo_threshold = SPI_FIFO_SIZE - sspc->rx_fifo_threshold;
+	chip->cr1 |= (SSCR1_RxTresh(sspc->rx_fifo_threshold) &
+		SSCR1_RFT) | (SSCR1_TxTresh(tx_fifo_threshold) & SSCR1_TFT);
+
+	sspc->dma_mapped = 0;
+
+	/* setting phase and polarity. spi->mode comes from boardinfo */
+	if ((spi->mode & SPI_CPHA) != 0)
+		chip->cr1 |= SSCR1_SPH;
+	if ((spi->mode & SPI_CPOL) != 0)
+		chip->cr1 |= SSCR1_SPO;
+
+	if (sspc->quirks & QUIRKS_SPI_SLAVE_CLOCK_MODE)
+		/* set slave mode */
+		chip->cr1 |= SSCR1_SCLKDIR | SSCR1_SFRMDIR;
+	chip->cr1 |= SSCR1_SCFR;        /* clock is not free running */
+
+	if (spi->bits_per_word <= 8) {
+		chip->n_bytes = 1;
+	} else if (spi->bits_per_word <= 16) {
+		chip->n_bytes = 2;
+	} else if (spi->bits_per_word <= 32) {
+		chip->n_bytes = 4;
+	} else {
+		dev_err(&spi->dev, "invalid wordsize\n");
+		spin_unlock_irqrestore(&sspc->lock, flags);
+		return -EINVAL;
+	}
+
+	if ((sspc->quirks & QUIRKS_SPI_SLAVE_CLOCK_MODE) == 0) {
+		clk_div = ssp_get_clk_div(sspc, spi->max_speed_hz);
+		chip->cr0 |= (clk_div & 0xFFF) << 8;
+		spi->max_speed_hz = ssp_get_speed(sspc, clk_div);
+		chip->speed_hz = spi->max_speed_hz;
+		dev_dbg(&spi->dev, "spi->max_speed_hz:%d clk_div:%x cr0:%x",
+			spi->max_speed_hz, clk_div, chip->cr0);
+	}
+	chip->bits_per_word = spi->bits_per_word;
+	chip->chip_select = spi->chip_select;
+
+	spi_set_ctldata(spi, chip);
+
+	/* setup of sspc members that will not change across transfers */
+
+	if (chip->dma_enabled) {
+		sspc->n_bytes = chip->n_bytes;
+		intel_mid_ssp_spi_dma_init(sspc);
+		sspc->cr1_sig = SSCR1_TSRE | SSCR1_RSRE;
+		sspc->mask_sr = SSSR_ROR | SSSR_TUR;
+		if (sspc->quirks & QUIRKS_DMA_USE_NO_TRAIL)
+			sspc->cr1_sig |= SSCR1_TRAIL;
+	} else {
+		sspc->cr1_sig = SSCR1_TINTE;
+		sspc->mask_sr = SSSR_ROR | SSSR_TUR | SSSR_TINT;
+	}
+	sspc->clear_sr = SSSR_TUR | SSSR_ROR | SSSR_TINT;
+
+	spin_unlock_irqrestore(&sspc->lock, flags);
+	return 0;
+}
+
+/**
+ * cleanup() - Driver cleanup procedure
+ * @spi:	Pointer to the spi_device struct
+ */
+static void cleanup(struct spi_device *spi)
+{
+	struct chip_data *chip = spi_get_ctldata(spi);
+	struct ssp_drv_context *sspc =
+		spi_master_get_devdata(spi->master);
+
+	if (sspc->dma_initialized)
+		intel_mid_ssp_spi_dma_exit(sspc);
+
+	/* Remove the PM_QOS request */
+	if (sspc->quirks & QUIRKS_USE_PM_QOS)
+		pm_qos_remove_request(&sspc->pm_qos_req);
+
+	kfree(chip);
+	spi_set_ctldata(spi, NULL);
+}
+
+/**
+ * intel_mid_ssp_spi_probe() - Driver probe procedure
+ * @pdev:	Pointer to the pci_dev struct
+ * @ent:	Pointer to the pci_device_id struct
+ */
+static int intel_mid_ssp_spi_probe(struct pci_dev *pdev,
+	const struct pci_device_id *ent)
+{
+	struct device *dev = &pdev->dev;
+	struct spi_master *master;
+	struct ssp_drv_context *sspc = 0;
+	int status;
+	u32 iolen = 0;
+	u8 ssp_cfg;
+	int pos;
+	void __iomem *syscfg_ioaddr;
+	unsigned long syscfg;
+
+	/* Check if the SSP we are probed for has been allocated */
+	/* to operate as SPI. This information is retreived from */
+	/* the field adid of the Vendor-Specific PCI capability  */
+	/* which is used as a configuration register.            */
+	pos = pci_find_capability(pdev, PCI_CAP_ID_VNDR);
+	if (pos > 0) {
+		pci_read_config_byte(pdev,
+			pos + VNDR_CAPABILITY_ADID_OFFSET,
+			&ssp_cfg);
+	} else {
+		dev_info(dev, "No Vendor Specific PCI capability\n");
+		goto err_abort_probe;
+	}
+
+	if (ssp_cfg_get_mode(ssp_cfg) != SSP_CFG_SPI_MODE_ID) {
+		dev_info(dev, "Unsupported SSP mode (%02xh)\n", ssp_cfg);
+		goto err_abort_probe;
+	}
+
+	dev_info(dev, "found PCI SSP controller (ID: %04xh:%04xh cfg: %02xh)\n",
+		pdev->vendor, pdev->device, ssp_cfg);
+
+	status = pci_enable_device(pdev);
+	if (status)
+		return status;
+
+	/* Allocate Slave with space for sspc and null dma buffer */
+	master = spi_alloc_master(dev, sizeof(struct ssp_drv_context));
+
+	if (!master) {
+		dev_err(dev, "cannot alloc spi_slave\n");
+		status = -ENOMEM;
+		goto err_free_0;
+	}
+
+	sspc = spi_master_get_devdata(master);
+	sspc->master = master;
+
+	sspc->pdev = pdev;
+	sspc->quirks = ent->driver_data;
+
+	/* Set platform & configuration quirks */
+	if (sspc->quirks & QUIRKS_PLATFORM_MRST) {
+		/* Apply bit banging workarround on MRST */
+		sspc->quirks |= QUIRKS_BIT_BANGING;
+		/* MRST slave mode workarrounds */
+		if (ssp_cfg_is_spi_slave(ssp_cfg))
+			sspc->quirks |= QUIRKS_USE_PM_QOS |
+					QUIRKS_SRAM_ADDITIONAL_CPY;
+	}
+	sspc->quirks |= QUIRKS_DMA_USE_NO_TRAIL;
+	if (ssp_cfg_is_spi_slave(ssp_cfg))
+		sspc->quirks |= QUIRKS_SPI_SLAVE_CLOCK_MODE;
+
+	master->mode_bits = SPI_CS_HIGH | SPI_CPOL | SPI_CPHA;
+	master->bus_num = ssp_cfg_get_spi_bus_nb(ssp_cfg);
+	master->num_chipselect = 4;
+	master->cleanup = cleanup;
+	master->setup = setup;
+	master->transfer = transfer;
+	sspc->dma_wq = create_workqueue("intel_mid_ssp_spi");
+	INIT_WORK(&sspc->complete_work, int_transfer_complete_work);
+
+	sspc->dma_initialized = 0;
+	sspc->suspended = 0;
+	sspc->cur_msg = NULL;
+
+	/* get basic io resource and map it */
+	sspc->paddr = pci_resource_start(pdev, 0);
+	iolen = pci_resource_len(pdev, 0);
+
+	status = pci_request_region(pdev, 0, dev_name(&pdev->dev));
+	if (status)
+		goto err_free_1;
+
+	sspc->ioaddr = ioremap_nocache(sspc->paddr, iolen);
+	if (!sspc->ioaddr) {
+		status = -ENOMEM;
+		goto err_free_2;
+	}
+	dev_dbg(dev, "paddr = : %08lx", sspc->paddr);
+	dev_dbg(dev, "ioaddr = : %p\n", sspc->ioaddr);
+	dev_dbg(dev, "attaching to IRQ: %04x\n", pdev->irq);
+	dev_dbg(dev, "quirks = : %08lx\n", sspc->quirks);
+
+	if (sspc->quirks & QUIRKS_BIT_BANGING) {
+		/* Bit banging on the clock is done through */
+		/* DFT which is available through I2C.      */
+		/* get base address of I2C_Serbus registers */
+		sspc->I2C_paddr = 0xff12b000;
+		sspc->I2C_ioaddr = ioremap_nocache(sspc->I2C_paddr, 0x10);
+		if (!sspc->I2C_ioaddr) {
+			status = -ENOMEM;
+			goto err_free_3;
+		}
+	}
+
+	/* Attach to IRQ */
+	sspc->irq = pdev->irq;
+	status = request_irq(sspc->irq, ssp_int, IRQF_SHARED,
+		"intel_mid_ssp_spi", sspc);
+
+	if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER) {
+		if ((intel_mid_identify_sim() ==
+				INTEL_MID_CPU_SIMULATION_SLE) ||
+		    (intel_mid_identify_sim() ==
+				INTEL_MID_CPU_SIMULATION_NONE)) {
+			/* [REVERT ME] Tangier SLE not supported.
+			 * Requires debug before removal.  Assume
+			 * also required in Si. */
+			disable_irq_nosync(sspc->irq);
+		}
+		if (intel_mid_identify_sim() == INTEL_MID_CPU_SIMULATION_NONE)
+			ssp_timing_wr = 1;
+	}
+
+	if (status < 0) {
+		dev_err(&pdev->dev, "can not get IRQ\n");
+		goto err_free_4;
+	}
+
+	if (sspc->quirks & QUIRKS_PLATFORM_MDFL) {
+		/* get base address of DMA selector. */
+		syscfg = sspc->paddr - SYSCFG;
+		syscfg_ioaddr = ioremap_nocache(syscfg, 0x10);
+		if (!syscfg_ioaddr) {
+			status = -ENOMEM;
+			goto err_free_5;
+		}
+		iowrite32(ioread32(syscfg_ioaddr) | 2, syscfg_ioaddr);
+	}
+
+	INIT_LIST_HEAD(&sspc->queue);
+	init_completion(&sspc->msg_done);
+	spin_lock_init(&sspc->lock);
+	INIT_WORK(&sspc->pump_messages, pump_messages);
+	sspc->workqueue = create_singlethread_workqueue(dev_name(&pdev->dev));
+
+	INIT_WORK(&sspc->poll_write, poll_writer);
+	sspc->wq_poll_write = create_singlethread_workqueue("spi_poll_wr");
+
+	/* Register with the SPI framework */
+	dev_info(dev, "register with SPI framework (bus spi%d)\n",
+			master->bus_num);
+
+	status = spi_register_master(master);
+	if (status) {
+		dev_err(dev, "problem registering spi\n");
+		goto err_free_5;
+	}
+
+	pci_set_drvdata(pdev, sspc);
+
+	/* Create the PM_QOS request */
+	if (sspc->quirks & QUIRKS_USE_PM_QOS)
+		pm_qos_add_request(&sspc->pm_qos_req, PM_QOS_CPU_DMA_LATENCY,
+				PM_QOS_DEFAULT_VALUE);
+
+	pm_runtime_set_autosuspend_delay(&pdev->dev, 25);
+	pm_runtime_use_autosuspend(&pdev->dev);
+	pm_runtime_set_active(&pdev->dev);
+	pm_runtime_enable(&pdev->dev);
+	if (!pm_runtime_enabled(&pdev->dev))
+		dev_err(&pdev->dev, "spi runtime pm not enabled!\n");
+	pm_runtime_put_noidle(&pdev->dev);
+	pm_runtime_allow(&pdev->dev);
+
+	return status;
+
+err_free_5:
+	free_irq(sspc->irq, sspc);
+err_free_4:
+	iounmap(sspc->I2C_ioaddr);
+err_free_3:
+	iounmap(sspc->ioaddr);
+err_free_2:
+	pci_release_region(pdev, 0);
+err_free_1:
+	spi_master_put(master);
+err_free_0:
+	pci_disable_device(pdev);
+
+	return status;
+err_abort_probe:
+	dev_info(dev, "Abort probe for SSP %04xh:%04xh\n",
+		pdev->vendor, pdev->device);
+	return -ENODEV;
+}
+
+/**
+ * intel_mid_ssp_spi_remove() - driver remove procedure
+ * @pdev:	Pointer to the pci_dev struct
+ */
+static void intel_mid_ssp_spi_remove(struct pci_dev *pdev)
+{
+	struct ssp_drv_context *sspc = pci_get_drvdata(pdev);
+
+	if (!sspc)
+		return;
+
+	pm_runtime_forbid(&pdev->dev);
+	pm_runtime_get_noresume(&pdev->dev);
+
+	if (sspc->dma_wq)
+		destroy_workqueue(sspc->dma_wq);
+	if (sspc->workqueue)
+		destroy_workqueue(sspc->workqueue);
+
+	/* Release IRQ */
+	free_irq(sspc->irq, sspc);
+
+	if (sspc->ioaddr)
+		iounmap(sspc->ioaddr);
+	if (sspc->quirks & QUIRKS_BIT_BANGING && sspc->I2C_ioaddr)
+		iounmap(sspc->I2C_ioaddr);
+
+	/* disconnect from the SPI framework */
+	if (sspc->master)
+		spi_unregister_master(sspc->master);
+
+	pci_set_drvdata(pdev, NULL);
+	pci_release_region(pdev, 0);
+	pci_disable_device(pdev);
+
+	return;
+}
+
+#ifdef CONFIG_PM
+static int intel_mid_ssp_spi_suspend(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct ssp_drv_context *sspc = pci_get_drvdata(pdev);
+	unsigned long flags;
+	int loop = 26;
+
+	dev_dbg(dev, "suspend\n");
+
+	spin_lock_irqsave(&sspc->lock, flags);
+	sspc->suspended = 1;
+	/*
+	 * If there is one msg being handled, wait 500ms at most,
+	 * if still not done, return busy
+	 */
+	while (sspc->cur_msg && --loop) {
+		spin_unlock_irqrestore(&sspc->lock, flags);
+		msleep(20);
+		spin_lock_irqsave(&sspc->lock, flags);
+		if (!loop)
+			sspc->suspended = 0;
+	}
+	spin_unlock_irqrestore(&sspc->lock, flags);
+
+	if (loop)
+		return 0;
+	else
+		return -EBUSY;
+}
+
+static int intel_mid_ssp_spi_resume(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct ssp_drv_context *sspc = pci_get_drvdata(pdev);
+
+	dev_dbg(dev, "resume\n");
+	spin_lock(&sspc->lock);
+	sspc->suspended = 0;
+	if (!list_empty(&sspc->queue))
+		queue_work(sspc->workqueue, &sspc->pump_messages);
+	spin_unlock(&sspc->lock);
+	return 0;
+}
+
+static int intel_mid_ssp_spi_runtime_suspend(struct device *dev)
+{
+	dev_dbg(dev, "runtime suspend called\n");
+	return 0;
+}
+
+static int intel_mid_ssp_spi_runtime_resume(struct device *dev)
+{
+	dev_dbg(dev, "runtime resume called\n");
+	return 0;
+}
+
+static int intel_mid_ssp_spi_runtime_idle(struct device *dev)
+{
+	int err;
+
+	dev_dbg(dev, "runtime idle called\n");
+	if (system_state == SYSTEM_BOOTING)
+		/* if SSP SPI UART is set as default console and earlyprintk
+		 * is enabled, it cannot shutdown SSP controller during booting.
+		 */
+		err = pm_schedule_suspend(dev, 30000);
+	else
+		err = pm_schedule_suspend(dev, 500);
+
+	return err;
+}
+#else
+#define intel_mid_ssp_spi_suspend NULL
+#define intel_mid_ssp_spi_resume NULL
+#define intel_mid_ssp_spi_runtime_suspend NULL
+#define intel_mid_ssp_spi_runtime_resume NULL
+#define intel_mid_ssp_spi_runtime_idle NULL
+#endif /* CONFIG_PM */
+
+
+static DEFINE_PCI_DEVICE_TABLE(pci_ids) = {
+	/* MRST SSP0 */
+	{ PCI_VDEVICE(INTEL, 0x0815), QUIRKS_PLATFORM_MRST},
+	/* MDFL SSP0 */
+	{ PCI_VDEVICE(INTEL, 0x0832), QUIRKS_PLATFORM_MDFL},
+	/* MDFL SSP1 */
+	{ PCI_VDEVICE(INTEL, 0x0825), QUIRKS_PLATFORM_MDFL},
+	/* MDFL SSP3 */
+	{ PCI_VDEVICE(INTEL, 0x0816), QUIRKS_PLATFORM_MDFL},
+	/* MRFL SSP5 */
+	{ PCI_VDEVICE(INTEL, 0x1194), QUIRKS_PLATFORM_MRFL},
+	/* BYT SSP3 */
+	{ PCI_VDEVICE(INTEL, 0x0f0e), QUIRKS_PLATFORM_BYT},
+	{},
+};
+
+static const struct dev_pm_ops intel_mid_ssp_spi_pm_ops = {
+	.suspend = intel_mid_ssp_spi_suspend,
+	.resume = intel_mid_ssp_spi_resume,
+	.runtime_suspend = intel_mid_ssp_spi_runtime_suspend,
+	.runtime_resume = intel_mid_ssp_spi_runtime_resume,
+	.runtime_idle = intel_mid_ssp_spi_runtime_idle,
+};
+
+static struct pci_driver intel_mid_ssp_spi_driver = {
+	.name =		DRIVER_NAME,
+	.id_table =	pci_ids,
+	.probe =	intel_mid_ssp_spi_probe,
+	.remove =	intel_mid_ssp_spi_remove,
+	.driver =	{
+		.pm	= &intel_mid_ssp_spi_pm_ops,
+	},
+};
+
+static int __init intel_mid_ssp_spi_init(void)
+{
+	return pci_register_driver(&intel_mid_ssp_spi_driver);
+}
+
+late_initcall(intel_mid_ssp_spi_init);
+
+static void __exit intel_mid_ssp_spi_exit(void)
+{
+	pci_unregister_driver(&intel_mid_ssp_spi_driver);
+}
+
+module_exit(intel_mid_ssp_spi_exit);
diff --git a/drivers/spi/spi-dw-mid.c b/drivers/spi/spi-dw-mid.c
index 996e16d..631445d 100644
--- a/drivers/spi/spi-dw-mid.c
+++ b/drivers/spi/spi-dw-mid.c
@@ -22,7 +22,6 @@
 #include <linux/interrupt.h>
 #include <linux/slab.h>
 #include <linux/spi/spi.h>
-#include <linux/types.h>
 
 #include "spi-dw.h"
 
@@ -55,6 +54,8 @@ static int mid_spi_dma_init(struct dw_spi *dws)
 	dws->dmac = pci_get_device(PCI_VENDOR_ID_INTEL, 0x0813, NULL);
 	if (!dws->dmac)
 		dws->dmac = pci_get_device(PCI_VENDOR_ID_INTEL, 0x0827, NULL);
+	if (!dws->dmac)
+		dws->dmac = pci_get_device(PCI_VENDOR_ID_INTEL, 0x08EF, NULL);
 
 	dma_cap_zero(mask);
 	dma_cap_set(DMA_SLAVE, mask);
@@ -117,8 +118,11 @@ static int mid_spi_dma_transfer(struct dw_spi *dws, int cs_change)
 {
 	struct dma_async_tx_descriptor *txdesc = NULL, *rxdesc = NULL;
 	struct dma_chan *txchan, *rxchan;
-	struct dma_slave_config txconf, rxconf;
+	struct dma_slave_config *txconf, *rxconf;
 	u16 dma_ctrl = 0;
+	enum dma_ctrl_flags flag;
+	struct device *dev = &dws->master->dev;
+	struct intel_mid_dma_slave *rxs, *txs;
 
 	/* 1. setup DMA related registers */
 	if (cs_change) {
@@ -137,51 +141,65 @@ static int mid_spi_dma_transfer(struct dw_spi *dws, int cs_change)
 	txchan = dws->txchan;
 	rxchan = dws->rxchan;
 
-	/* 2. Prepare the TX dma transfer */
-	txconf.direction = DMA_MEM_TO_DEV;
-	txconf.dst_addr = dws->dma_addr;
-	txconf.dst_maxburst = LNW_DMA_MSIZE_16;
-	txconf.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	txconf.dst_addr_width = dws->dma_width;
-	txconf.device_fc = false;
+	txs = txchan->private;
+	rxs = rxchan->private;
 
-	txchan->device->device_control(txchan, DMA_SLAVE_CONFIG,
-				       (unsigned long) &txconf);
+	txconf = &txs->dma_slave;
+	rxconf = &rxs->dma_slave;
 
-	memset(&dws->tx_sgl, 0, sizeof(dws->tx_sgl));
-	dws->tx_sgl.dma_address = dws->tx_dma;
-	dws->tx_sgl.length = dws->len;
+	flag = DMA_PREP_INTERRUPT | DMA_COMPL_SKIP_DEST_UNMAP | DMA_CTRL_ACK;
 
-	txdesc = dmaengine_prep_slave_sg(txchan,
-				&dws->tx_sgl,
-				1,
-				DMA_MEM_TO_DEV,
-				DMA_PREP_INTERRUPT);
-	txdesc->callback = dw_spi_dma_done;
-	txdesc->callback_param = dws;
+	/* 2. Prepare the TX dma transfer */
+	txconf->direction = DMA_MEM_TO_DEV;
+	txconf->dst_addr = dws->dma_addr;
+	txconf->src_maxburst = LNW_DMA_MSIZE_16;
+	txconf->dst_maxburst = LNW_DMA_MSIZE_16;
+	txconf->src_addr_width = dws->dma_width;
+	txconf->dst_addr_width = dws->dma_width;
+	txconf->device_fc = false;
+
+	txchan->device->device_control(txchan, DMA_SLAVE_CONFIG,
+				       (unsigned long) txconf);
+
+	txdesc = txchan->device->device_prep_dma_memcpy
+		(txchan,			/* DMA Channel */
+		dws->dma_addr,			/* DAR */
+		dws->tx_dma,			/* SAR */
+		dws->len,			/* Data Length */
+		flag);
+	if (txdesc) {
+		txdesc->callback = dw_spi_dma_done;
+		txdesc->callback_param = dws;
+	} else {
+		dev_err(dev, "ERROR: prepare txdesc failed\n");
+		return -EINVAL;
+	}
 
 	/* 3. Prepare the RX dma transfer */
-	rxconf.direction = DMA_DEV_TO_MEM;
-	rxconf.src_addr = dws->dma_addr;
-	rxconf.src_maxburst = LNW_DMA_MSIZE_16;
-	rxconf.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
-	rxconf.src_addr_width = dws->dma_width;
-	rxconf.device_fc = false;
+	rxconf->direction = DMA_DEV_TO_MEM;
+	rxconf->src_addr = dws->dma_addr;
+	rxconf->src_maxburst = LNW_DMA_MSIZE_16;
+	rxconf->dst_maxburst = LNW_DMA_MSIZE_16;
+	rxconf->dst_addr_width = dws->dma_width;
+	rxconf->src_addr_width = dws->dma_width;
+	rxconf->device_fc = false;
 
 	rxchan->device->device_control(rxchan, DMA_SLAVE_CONFIG,
-				       (unsigned long) &rxconf);
-
-	memset(&dws->rx_sgl, 0, sizeof(dws->rx_sgl));
-	dws->rx_sgl.dma_address = dws->rx_dma;
-	dws->rx_sgl.length = dws->len;
-
-	rxdesc = dmaengine_prep_slave_sg(rxchan,
-				&dws->rx_sgl,
-				1,
-				DMA_DEV_TO_MEM,
-				DMA_PREP_INTERRUPT);
-	rxdesc->callback = dw_spi_dma_done;
-	rxdesc->callback_param = dws;
+				       (unsigned long) rxconf);
+
+	rxdesc = rxchan->device->device_prep_dma_memcpy
+		(rxchan,			/* DMA Channel */
+		dws->rx_dma,			/* DAR */
+		dws->dma_addr,			/* SAR */
+		dws->len,			/* Data Length */
+		flag);
+	if (rxdesc) {
+		rxdesc->callback = dw_spi_dma_done;
+		rxdesc->callback_param = dws;
+	} else {
+		dev_err(dev, "ERROR: prepare rxdesc failed\n");
+		return -EINVAL;
+	}
 
 	/* rx must be started before tx due to spi instinct */
 	rxdesc->tx_submit(rxdesc);
@@ -189,10 +207,41 @@ static int mid_spi_dma_transfer(struct dw_spi *dws, int cs_change)
 	return 0;
 }
 
+static int mid_spi_dma_suspend(struct dw_spi *dws)
+{
+	struct dma_chan *txchan, *rxchan;
+
+	txchan = dws->txchan;
+	rxchan = dws->rxchan;
+
+	txchan->device->device_control(txchan, DMA_TERMINATE_ALL, 0);
+	rxchan->device->device_control(rxchan, DMA_TERMINATE_ALL, 0);
+
+	txchan->device->device_control(txchan, DMA_PAUSE, 0);
+	rxchan->device->device_control(rxchan, DMA_PAUSE, 0);
+
+	return 0;
+}
+
+static int mid_spi_dma_resume(struct dw_spi *dws)
+{
+	struct dma_chan *txchan, *rxchan;
+
+	txchan = dws->txchan;
+	rxchan = dws->rxchan;
+
+	txchan->device->device_control(txchan, DMA_RESUME, 0);
+	rxchan->device->device_control(rxchan, DMA_RESUME, 0);
+
+	return 0;
+}
+
 static struct dw_spi_dma_ops mid_dma_ops = {
 	.dma_init	= mid_spi_dma_init,
 	.dma_exit	= mid_spi_dma_exit,
 	.dma_transfer	= mid_spi_dma_transfer,
+	.dma_suspend	= mid_spi_dma_suspend,
+	.dma_resume	= mid_spi_dma_resume,
 };
 #endif
 
@@ -207,12 +256,12 @@ static struct dw_spi_dma_ops mid_dma_ops = {
 #define CLK_SPI_CDIV_MASK	0x00000e00
 #define CLK_SPI_DISABLE_OFFSET	8
 
-int dw_spi_mid_init(struct dw_spi *dws)
+int dw_spi_mid_init(struct dw_spi *dws, int bus_num)
 {
 	void __iomem *clk_reg;
 	u32 clk_cdiv;
 
-	clk_reg = ioremap_nocache(MRST_CLK_SPI0_REG, 16);
+	clk_reg = ioremap_nocache(MRST_CLK_SPI0_REG + bus_num * 4, 16);
 	if (!clk_reg)
 		return -ENOMEM;
 
diff --git a/drivers/spi/spi-dw-pci.c b/drivers/spi/spi-dw-pci.c
index e149604..79d41da 100644
--- a/drivers/spi/spi-dw-pci.c
+++ b/drivers/spi/spi-dw-pci.c
@@ -20,6 +20,7 @@
 #include <linux/interrupt.h>
 #include <linux/pci.h>
 #include <linux/slab.h>
+#include <linux/pm_runtime.h>
 #include <linux/spi/spi.h>
 #include <linux/module.h>
 
@@ -64,7 +65,7 @@ static int spi_pci_probe(struct pci_dev *pdev,
 
 	dws->regs = pcim_iomap_table(pdev)[pci_bar];
 
-	dws->bus_num = 0;
+	dws->bus_num = ent->driver_data;
 	dws->num_cs = 4;
 	dws->irq = pdev->irq;
 
@@ -77,6 +78,9 @@ static int spi_pci_probe(struct pci_dev *pdev,
 		if (ret)
 			return ret;
 	}
+	ret = dw_spi_mid_init(dws, ent->driver_data);
+	if (ret)
+		return ret;
 
 	ret = dw_spi_add_host(&pdev->dev, dws);
 	if (ret)
@@ -85,6 +89,10 @@ static int spi_pci_probe(struct pci_dev *pdev,
 	/* PCI hook and SPI hook use the same drv data */
 	pci_set_drvdata(pdev, dwpci);
 
+	pm_suspend_ignore_children(&pdev->dev, true);
+	pm_runtime_put_noidle(&pdev->dev);
+	pm_runtime_allow(&pdev->dev);
+
 	return 0;
 }
 
@@ -93,11 +101,14 @@ static void spi_pci_remove(struct pci_dev *pdev)
 	struct dw_spi_pci *dwpci = pci_get_drvdata(pdev);
 
 	dw_spi_remove_host(&dwpci->dws);
+	pm_runtime_forbid(&pdev->dev);
+	pm_runtime_get_noresume(&pdev->dev);
 }
 
 #ifdef CONFIG_PM
-static int spi_suspend(struct pci_dev *pdev, pm_message_t state)
+static int spi_suspend(struct device *dev)
 {
+	struct pci_dev *pdev = to_pci_dev(dev);
 	struct dw_spi_pci *dwpci = pci_get_drvdata(pdev);
 	int ret;
 
@@ -106,12 +117,13 @@ static int spi_suspend(struct pci_dev *pdev, pm_message_t state)
 		return ret;
 	pci_save_state(pdev);
 	pci_disable_device(pdev);
-	pci_set_power_state(pdev, pci_choose_state(pdev, state));
+	pci_set_power_state(pdev, PCI_D3hot);
 	return ret;
 }
 
-static int spi_resume(struct pci_dev *pdev)
+static int spi_resume(struct device *dev)
 {
+	struct pci_dev *pdev = to_pci_dev(dev);
 	struct dw_spi_pci *dwpci = pci_get_drvdata(pdev);
 	int ret;
 
@@ -122,27 +134,93 @@ static int spi_resume(struct pci_dev *pdev)
 		return ret;
 	return dw_spi_resume_host(&dwpci->dws);
 }
+
+static int spi_dw_pci_runtime_suspend(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct dw_spi_pci *dwpci = pci_get_drvdata(pdev);
+
+	dev_dbg(dev, "PCI runtime suspend called\n");
+	return dw_spi_suspend_host(&dwpci->dws);
+}
+
+static int spi_dw_pci_runtime_resume(struct device *dev)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	struct dw_spi_pci *dwpci = pci_get_drvdata(pdev);
+
+	dev_dbg(dev, "pci_runtime_resume called\n");
+	return dw_spi_resume_host(&dwpci->dws);
+}
+
+static int spi_dw_pci_runtime_idle(struct device *dev)
+{
+	int err;
+
+	dev_dbg(dev, "pci_runtime_idle called\n");
+	if (system_state == SYSTEM_BOOTING)
+		/* if SPI UART is set as default console and earlyprintk
+		 * is enabled, it cannot shutdown SPI controller during booting.
+		 */
+		err = pm_schedule_suspend(dev, 30000);
+	else
+		err = pm_schedule_suspend(dev, 500);
+
+	if (err != 0)
+		return 0;
+
+	return -EBUSY;
+}
+
 #else
 #define spi_suspend	NULL
 #define spi_resume	NULL
+#define spi_dw_pci_runtime_suspend NULL
+#define spi_dw_pci_runtime_resume NULL
+#define spi_dw_pci_runtime_idle NULL
 #endif
 
 static const struct pci_device_id pci_ids[] = {
-	/* Intel MID platform SPI controller 0 */
-	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0800) },
+	/* Intel Medfield platform SPI controller 1 */
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0800), .driver_data = 0 },
+	/* Intel Cloverview platform SPI controller 1 */
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x08E1), .driver_data = 0 },
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x08EE), .driver_data = 1 },
+	/* Intel EVx platform SPI controller 1 */
+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0812), .driver_data = 2 },
 	{},
 };
 
+static const struct dev_pm_ops dw_spi_pm_ops = {
+	.suspend = spi_suspend,
+	.resume = spi_resume,
+	.runtime_suspend = spi_dw_pci_runtime_suspend,
+	.runtime_resume = spi_dw_pci_runtime_resume,
+	.runtime_idle = spi_dw_pci_runtime_idle,
+};
+
 static struct pci_driver dw_spi_driver = {
 	.name =		DRIVER_NAME,
 	.id_table =	pci_ids,
 	.probe =	spi_pci_probe,
 	.remove =	spi_pci_remove,
-	.suspend =	spi_suspend,
-	.resume	=	spi_resume,
+	.driver =	{
+		.pm	= &dw_spi_pm_ops,
+	},
 };
 
-module_pci_driver(dw_spi_driver);
+static int __init mrst_spi_init(void)
+{
+	return pci_register_driver(&dw_spi_driver);
+}
+
+static void __exit mrst_spi_exit(void)
+{
+	pci_unregister_driver(&dw_spi_driver);
+}
+
+module_init(mrst_spi_init);
+module_exit(mrst_spi_exit);
 
 MODULE_AUTHOR("Feng Tang <feng.tang@intel.com>");
 MODULE_DESCRIPTION("PCI interface driver for DW SPI Core");
diff --git a/drivers/spi/spi-dw.c b/drivers/spi/spi-dw.c
index e543b80..21f49ff 100644
--- a/drivers/spi/spi-dw.c
+++ b/drivers/spi/spi-dw.c
@@ -23,6 +23,7 @@
 #include <linux/highmem.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
+#include <linux/pm_runtime.h>
 #include <linux/spi/spi.h>
 
 #include "spi-dw.h"
@@ -63,6 +64,12 @@ struct chip_data {
 };
 
 #ifdef CONFIG_DEBUG_FS
+static int spi_show_regs_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
 #define SPI_REGS_BUFSIZE	1024
 static ssize_t  spi_show_regs(struct file *file, char __user *user_buf,
 				size_t count, loff_t *ppos)
@@ -122,7 +129,7 @@ static ssize_t  spi_show_regs(struct file *file, char __user *user_buf,
 
 static const struct file_operations mrst_spi_regs_ops = {
 	.owner		= THIS_MODULE,
-	.open		= simple_open,
+	.open		= spi_show_regs_open,
 	.read		= spi_show_regs,
 	.llseek		= default_llseek,
 };
@@ -191,7 +198,7 @@ static void dw_writer(struct dw_spi *dws)
 	u16 txw = 0;
 
 	while (max--) {
-		/* Set the tx word if the transfer's original "tx" is not null */
+		/* Set the txw if the transfer's original "tx" is not null */
 		if (dws->tx_end - dws->len) {
 			if (dws->n_bytes == 1)
 				txw = *(u8 *)(dws->tx);
@@ -256,7 +263,40 @@ static int map_dma_buffers(struct dw_spi *dws)
 	if (dws->cur_transfer->rx_dma)
 		dws->rx_dma = dws->cur_transfer->rx_dma;
 
+	/* map dma buffer if it's not mapped */
+	if (!dws->tx_dma) {
+		dws->tx_dma = dma_map_single(NULL, dws->tx,
+				dws->len, DMA_TO_DEVICE);
+		if (dma_mapping_error(NULL, dws->tx_dma)) {
+			pr_err("map tx dma buffer failed\n");
+			goto err1;
+		}
+	}
+
+	if (!dws->rx_dma) {
+		dws->rx_dma = dma_map_single(NULL, dws->rx,
+				dws->len, DMA_FROM_DEVICE);
+		if (dma_mapping_error(NULL, dws->rx_dma)) {
+			pr_err("map rx dma buffer failed\n");
+			goto err2;
+		}
+	}
+
 	return 1;
+
+err2:
+	dma_unmap_single(NULL, dws->tx_dma, dws->len, DMA_TO_DEVICE);
+err1:
+	dws->cur_msg->is_dma_mapped = 0;
+	return 0;
+}
+
+static void unmap_dma_buffers(struct dw_spi *dws)
+{
+	dma_unmap_single(NULL, dws->rx_dma,
+				dws->len, DMA_FROM_DEVICE);
+	dma_unmap_single(NULL, dws->tx_dma,
+				dws->len, DMA_TO_DEVICE);
 }
 
 /* Caller already set message->status; dma and pio irqs are blocked */
@@ -267,7 +307,12 @@ static void giveback(struct dw_spi *dws)
 	struct spi_message *msg;
 
 	spin_lock_irqsave(&dws->lock, flags);
+
+	if (dws->dma_mapped)
+		unmap_dma_buffers(dws);
+
 	msg = dws->cur_msg;
+	list_del_init(&dws->cur_msg->queue);
 	dws->cur_msg = NULL;
 	dws->cur_transfer = NULL;
 	dws->prev_chip = dws->cur_chip;
@@ -312,6 +357,7 @@ void dw_spi_xfer_done(struct dw_spi *dws)
 		giveback(dws);
 	} else
 		tasklet_schedule(&dws->pump_transfers);
+
 }
 EXPORT_SYMBOL_GPL(dw_spi_xfer_done);
 
@@ -324,7 +370,7 @@ static irqreturn_t interrupt_transfer(struct dw_spi *dws)
 		dw_readw(dws, DW_SPI_TXOICR);
 		dw_readw(dws, DW_SPI_RXOICR);
 		dw_readw(dws, DW_SPI_RXUICR);
-		int_error_stop(dws, "interrupt_transfer: fifo overrun/underrun");
+		int_error_stop(dws, "interrupt_transfer: fifo over/underrun");
 		return IRQ_HANDLED;
 	}
 
@@ -489,7 +535,8 @@ static void pump_transfers(unsigned long data)
 		txint_level = dws->fifo_len / 2;
 		txint_level = (templen > txint_level) ? txint_level : templen;
 
-		imask |= SPI_INT_TXEI | SPI_INT_TXOI | SPI_INT_RXUI | SPI_INT_RXOI;
+		imask |= SPI_INT_TXEI | SPI_INT_TXOI | SPI_INT_RXUI
+			| SPI_INT_RXOI;
 		dws->transfer_handler = interrupt_transfer;
 	}
 
@@ -499,7 +546,8 @@ static void pump_transfers(unsigned long data)
 	 *	2. clk_div is changed
 	 *	3. control value changes
 	 */
-	if (dw_readw(dws, DW_SPI_CTRL0) != cr0 || cs_change || clk_div || imask) {
+	if (dw_readw(dws, DW_SPI_CTRL0) != cr0 || cs_change
+			|| clk_div || imask) {
 		spi_enable_chip(dws, 0);
 
 		if (dw_readw(dws, DW_SPI_CTRL0) != cr0)
@@ -539,23 +587,19 @@ static void pump_messages(struct work_struct *work)
 		container_of(work, struct dw_spi, pump_messages);
 	unsigned long flags;
 
+	pm_runtime_get_sync(dws->parent_dev);
+
 	/* Lock queue and check for queue work */
 	spin_lock_irqsave(&dws->lock, flags);
-	if (list_empty(&dws->queue) || dws->run == QUEUE_STOPPED) {
-		dws->busy = 0;
-		spin_unlock_irqrestore(&dws->lock, flags);
-		return;
-	}
+	if (list_empty(&dws->queue) || dws->run == QUEUE_STOPPED)
+		goto exit;
 
 	/* Make sure we are not already running a message */
-	if (dws->cur_msg) {
-		spin_unlock_irqrestore(&dws->lock, flags);
-		return;
-	}
+	if (dws->cur_msg)
+		goto exit;
 
 	/* Extract head of queue */
 	dws->cur_msg = list_entry(dws->queue.next, struct spi_message, queue);
-	list_del_init(&dws->cur_msg->queue);
 
 	/* Initial message state*/
 	dws->cur_msg->state = START_STATE;
@@ -567,8 +611,9 @@ static void pump_messages(struct work_struct *work)
 	/* Mark as busy and launch transfers */
 	tasklet_schedule(&dws->pump_transfers);
 
-	dws->busy = 1;
+exit:
 	spin_unlock_irqrestore(&dws->lock, flags);
+	pm_runtime_put_sync(dws->parent_dev);
 }
 
 /* spi_device use this to queue in their spi_msg */
@@ -579,29 +624,13 @@ static int dw_spi_transfer(struct spi_device *spi, struct spi_message *msg)
 
 	spin_lock_irqsave(&dws->lock, flags);
 
-	if (dws->run == QUEUE_STOPPED) {
-		spin_unlock_irqrestore(&dws->lock, flags);
-		return -ESHUTDOWN;
-	}
-
 	msg->actual_length = 0;
 	msg->status = -EINPROGRESS;
 	msg->state = START_STATE;
 
 	list_add_tail(&msg->queue, &dws->queue);
 
-	if (dws->run == QUEUE_RUNNING && !dws->busy) {
-
-		if (dws->cur_transfer || dws->cur_msg)
-			queue_work(dws->workqueue,
-					&dws->pump_messages);
-		else {
-			/* If no other data transaction in air, just go */
-			spin_unlock_irqrestore(&dws->lock, flags);
-			pump_messages(&dws->pump_messages);
-			return 0;
-		}
-	}
+	queue_work(dws->workqueue, &dws->pump_messages);
 
 	spin_unlock_irqrestore(&dws->lock, flags);
 	return 0;
@@ -667,13 +696,12 @@ static int dw_spi_setup(struct spi_device *spi)
 	return 0;
 }
 
-static int init_queue(struct dw_spi *dws)
+static int dw_spi_init_queue(struct dw_spi *dws)
 {
 	INIT_LIST_HEAD(&dws->queue);
 	spin_lock_init(&dws->lock);
 
 	dws->run = QUEUE_STOPPED;
-	dws->busy = 0;
 
 	tasklet_init(&dws->pump_transfers,
 			pump_transfers,	(unsigned long)dws);
@@ -687,13 +715,13 @@ static int init_queue(struct dw_spi *dws)
 	return 0;
 }
 
-static int start_queue(struct dw_spi *dws)
+static int dw_spi_start_queue(struct dw_spi *dws)
 {
 	unsigned long flags;
 
 	spin_lock_irqsave(&dws->lock, flags);
 
-	if (dws->run == QUEUE_RUNNING || dws->busy) {
+	if (dws->run == QUEUE_RUNNING) {
 		spin_unlock_irqrestore(&dws->lock, flags);
 		return -EBUSY;
 	}
@@ -710,32 +738,27 @@ static int start_queue(struct dw_spi *dws)
 	return 0;
 }
 
-static int stop_queue(struct dw_spi *dws)
+int dw_spi_stop_queue(struct dw_spi *dws)
 {
 	unsigned long flags;
-	unsigned limit = 50;
 	int status = 0;
 
 	spin_lock_irqsave(&dws->lock, flags);
-	dws->run = QUEUE_STOPPED;
-	while ((!list_empty(&dws->queue) || dws->busy) && limit--) {
-		spin_unlock_irqrestore(&dws->lock, flags);
-		msleep(10);
-		spin_lock_irqsave(&dws->lock, flags);
-	}
-
-	if (!list_empty(&dws->queue) || dws->busy)
+	if (!list_empty(&dws->queue))
 		status = -EBUSY;
+	else
+		dws->run = QUEUE_STOPPED;
 	spin_unlock_irqrestore(&dws->lock, flags);
 
 	return status;
 }
+EXPORT_SYMBOL_GPL(dw_spi_stop_queue);
 
-static int destroy_queue(struct dw_spi *dws)
+static int dw_spi_destroy_queue(struct dw_spi *dws)
 {
 	int status;
 
-	status = stop_queue(dws);
+	status = dw_spi_stop_queue(dws);
 	if (status != 0)
 		return status;
 	destroy_workqueue(dws->workqueue);
@@ -743,11 +766,10 @@ static int destroy_queue(struct dw_spi *dws)
 }
 
 /* Restart the controller, disable all interrupts, clean rx fifo */
-static void spi_hw_init(struct dw_spi *dws)
+static void dw_spi_hw_init(struct dw_spi *dws)
 {
 	spi_enable_chip(dws, 0);
 	spi_mask_intr(dws, 0xff);
-	spi_enable_chip(dws, 1);
 
 	/*
 	 * Try to detect the FIFO depth if not set by interface driver,
@@ -764,6 +786,8 @@ static void spi_hw_init(struct dw_spi *dws)
 		dws->fifo_len = (fifo == 257) ? 0 : fifo;
 		dw_writew(dws, DW_SPI_TXFLTR, 0);
 	}
+
+	spi_enable_chip(dws, 1);
 }
 
 int dw_spi_add_host(struct device *dev, struct dw_spi *dws)
@@ -800,7 +824,7 @@ int dw_spi_add_host(struct device *dev, struct dw_spi *dws)
 	master->transfer = dw_spi_transfer;
 
 	/* Basic HW init */
-	spi_hw_init(dws);
+	dw_spi_hw_init(dws);
 
 	if (dws->dma_ops && dws->dma_ops->dma_init) {
 		ret = dws->dma_ops->dma_init(dws);
@@ -811,12 +835,12 @@ int dw_spi_add_host(struct device *dev, struct dw_spi *dws)
 	}
 
 	/* Initial and start queue */
-	ret = init_queue(dws);
+	ret = dw_spi_init_queue(dws);
 	if (ret) {
 		dev_err(&master->dev, "problem initializing queue\n");
 		goto err_diable_hw;
 	}
-	ret = start_queue(dws);
+	ret = dw_spi_start_queue(dws);
 	if (ret) {
 		dev_err(&master->dev, "problem starting queue\n");
 		goto err_diable_hw;
@@ -833,7 +857,7 @@ int dw_spi_add_host(struct device *dev, struct dw_spi *dws)
 	return 0;
 
 err_queue_alloc:
-	destroy_queue(dws);
+	dw_spi_destroy_queue(dws);
 	if (dws->dma_ops && dws->dma_ops->dma_exit)
 		dws->dma_ops->dma_exit(dws);
 err_diable_hw:
@@ -853,7 +877,7 @@ void dw_spi_remove_host(struct dw_spi *dws)
 	mrst_spi_debugfs_remove(dws);
 
 	/* Remove the queue */
-	status = destroy_queue(dws);
+	status = dw_spi_destroy_queue(dws);
 	if (status != 0)
 		dev_err(&dws->master->dev,
 			"dw_spi_remove: workqueue will not complete, message memory not freed\n");
@@ -870,11 +894,16 @@ int dw_spi_suspend_host(struct dw_spi *dws)
 {
 	int ret = 0;
 
-	ret = stop_queue(dws);
+	ret = dw_spi_stop_queue(dws);
 	if (ret)
 		return ret;
+
 	spi_enable_chip(dws, 0);
 	spi_set_clk(dws, 0);
+
+	if (dws->dma_inited)
+		dws->dma_ops->dma_suspend(dws);
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(dw_spi_suspend_host);
@@ -883,10 +912,14 @@ int dw_spi_resume_host(struct dw_spi *dws)
 {
 	int ret;
 
-	spi_hw_init(dws);
-	ret = start_queue(dws);
+	if (dws->dma_inited)
+		dws->dma_ops->dma_resume(dws);
+
+	dw_spi_hw_init(dws);
+	ret = dw_spi_start_queue(dws);
 	if (ret)
 		dev_err(&dws->master->dev, "fail to start queue (%d)\n", ret);
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(dw_spi_resume_host);
diff --git a/drivers/spi/spi-dw.h b/drivers/spi/spi-dw.h
index 587643d..57dcbbc 100644
--- a/drivers/spi/spi-dw.h
+++ b/drivers/spi/spi-dw.h
@@ -87,6 +87,8 @@ struct dw_spi_dma_ops {
 	int (*dma_init)(struct dw_spi *dws);
 	void (*dma_exit)(struct dw_spi *dws);
 	int (*dma_transfer)(struct dw_spi *dws, int cs_change);
+	int (*dma_suspend)(struct dw_spi *dws);
+	int (*dma_resume)(struct dw_spi *dws);
 };
 
 struct dw_spi {
@@ -109,7 +111,6 @@ struct dw_spi {
 	struct work_struct	pump_messages;
 	spinlock_t		lock;
 	struct list_head	queue;
-	int			busy;
 	int			run;
 
 	/* Message Transfer pump */
@@ -233,7 +234,9 @@ extern void dw_spi_remove_host(struct dw_spi *dws);
 extern int dw_spi_suspend_host(struct dw_spi *dws);
 extern int dw_spi_resume_host(struct dw_spi *dws);
 extern void dw_spi_xfer_done(struct dw_spi *dws);
+extern int dw_spi_stop_queue(struct dw_spi *dws);
 
 /* platform related setup */
-extern int dw_spi_mid_init(struct dw_spi *dws); /* Intel MID platforms */
+/* Intel MID platforms */
+extern int dw_spi_mid_init(struct dw_spi *dws, int bus_num);
 #endif /* DW_SPI_HEADER_H */
diff --git a/drivers/tty/serial/mfd_dma.c b/drivers/tty/serial/mfd_dma.c
index a9371fb..f035634 100644
--- a/drivers/tty/serial/mfd_dma.c
+++ b/drivers/tty/serial/mfd_dma.c
@@ -353,7 +353,7 @@ static void dw_dma_start_tx(struct uart_hsu_port *up)
 					   dbuf->dma_size,
 					   DMA_TO_DEVICE);
 
-	flag = DMA_PREP_INTERRUPT | DMA_COMPL_SKIP_DEST_UNMAP | DMA_CTRL_ACK;
+	flag = DMA_PREP_INTERRUPT | DMA_CTRL_ACK;
 
 	txdesc = txchan->device->device_prep_dma_memcpy(
 					txchan,		/* DMA Channel */
@@ -457,7 +457,7 @@ static void dw_dma_start_rx(struct uart_hsu_port *up)
 
 	rxchan->device->device_control(rxchan, DMA_SLAVE_CONFIG,
 				       (unsigned long) rxconf);
-	flag = DMA_PREP_INTERRUPT | DMA_COMPL_SKIP_DEST_UNMAP | DMA_CTRL_ACK;
+	flag = DMA_PREP_INTERRUPT | DMA_CTRL_ACK;
 	rxdesc = rxchan->device->device_prep_dma_memcpy(
 					rxchan,			/* DMA chan */
 					dbuf->dma_addr,		/* DAR */
diff --git a/include/acpi/acpi_bus.h b/include/acpi/acpi_bus.h
index 306c7c3..730f62a 100644
--- a/include/acpi/acpi_bus.h
+++ b/include/acpi/acpi_bus.h
@@ -28,6 +28,8 @@
 
 #include <linux/device.h>
 
+#include <acpi/acpi.h>
+
 /* TBD: Make dynamic */
 #define ACPI_MAX_HANDLES	10
 struct acpi_handle_list {
diff --git a/include/linux/intel_mid_dma.h b/include/linux/intel_mid_dma.h
index 10496bd..d7f2997 100644
--- a/include/linux/intel_mid_dma.h
+++ b/include/linux/intel_mid_dma.h
@@ -29,6 +29,10 @@
 
 #define DMA_PREP_CIRCULAR_LIST		(1 << 10)
 
+#define SST_MAX_DMA_LEN		4095
+#define SST_MAX_DMA_LEN_MRFLD	131071 /* 2^17 - 1 */
+
+
 /*DMA mode configurations*/
 enum intel_mid_dma_mode {
 	LNW_DMA_PER_TO_MEM = 0, /*periphral to memory configuration*/
@@ -73,4 +77,7 @@ struct intel_mid_dma_slave {
 	struct dma_slave_config		dma_slave;
 };
 
+struct device *intel_mid_get_acpi_dma(const char *hid);
+dma_addr_t intel_dma_get_src_addr(struct dma_chan *chan);
+dma_addr_t intel_dma_get_dst_addr(struct dma_chan *chan);
 #endif /*__INTEL_MID_DMA_H__*/
diff --git a/include/linux/spi/intel_mid_ssp_spi.h b/include/linux/spi/intel_mid_ssp_spi.h
new file mode 100644
index 0000000..b212eee
--- /dev/null
+++ b/include/linux/spi/intel_mid_ssp_spi.h
@@ -0,0 +1,354 @@
+/*
+ *  Copyright (C) Intel 2009
+ *  Ken Mills <ken.k.mills@intel.com>
+ *  Sylvain Centelles <sylvain.centelles@intel.com>
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ */
+#ifndef INTEL_MID_SSP_SPI_H_
+#define INTEL_MID_SSP_SPI_H_
+
+#include <linux/intel_mid_dma.h>
+#include <linux/pm_qos.h>
+#include <linux/spi/spi.h>
+#include <linux/interrupt.h>
+#include <linux/completion.h>
+
+#define PCI_MRST_DMAC1_ID	0x0814
+#define PCI_MDFL_DMAC1_ID	0x0827
+#define PCI_BYT_DMAC1_ID	0x0f06
+#define PCI_MRFL_DMAC_ID	0x11A2
+
+#define SSP_NOT_SYNC 0x400000
+#define MAX_SPI_TRANSFER_SIZE 8192
+#define MAX_BITBANGING_LOOP   10000
+#define SPI_FIFO_SIZE 16
+
+/* PM QoS define */
+#define MIN_EXIT_LATENCY 20
+
+/* SSP assignement configuration from PCI config */
+
+#define SSP_CFG_SPI_MODE_ID		1
+/* adid field offset is 6 inside the vendor specific capability */
+#define VNDR_CAPABILITY_ADID_OFFSET	6
+
+/* Driver's quirk flags */
+/* This workarround bufferizes data in the audio fabric SDRAM from  */
+/* where the DMA transfers will operate. Should be enabled only for */
+/* SPI slave mode.                                                  */
+#define QUIRKS_SRAM_ADDITIONAL_CPY	1
+/* If set the trailing bytes won't be handled by the DMA.           */
+/* Trailing byte feature not fully available.                       */
+#define QUIRKS_DMA_USE_NO_TRAIL		2
+/* If set, the driver will use PM_QOS to reduce the latency         */
+/* introduced by the deeper C-states which may produce over/under   */
+/* run issues. Must be used in slave mode. In master mode, the      */
+/* latency is not critical, but setting this workarround  may       */
+/* improve the SPI throughput.                                      */
+#define QUIRKS_USE_PM_QOS		4
+/* This quirks is set on Moorestown                                 */
+#define QUIRKS_PLATFORM_MRST		8
+/* This quirks is set on Medfield                                   */
+#define QUIRKS_PLATFORM_MDFL		16
+/* If set, the driver will apply the bitbanging workarround needed  */
+/* to enable defective Langwell stepping A SSP. The defective SSP   */
+/* can be enabled only once, and should never be disabled.          */
+#define QUIRKS_BIT_BANGING		32
+/* If set, SPI is in slave clock mode                               */
+#define QUIRKS_SPI_SLAVE_CLOCK_MODE	64
+/* Add more platform here. */
+/* This quirks is set on Baytrail. */
+#define QUIRKS_PLATFORM_BYT		128
+#define QUIRKS_PLATFORM_MRFL		256
+
+/* Uncomment to get RX and TX short dumps after each transfer */
+/* #define DUMP_RX 1 */
+#define MAX_TRAILING_BYTE_RETRY 16
+#define MAX_TRAILING_BYTE_LOOP 100
+#define DELAY_TO_GET_A_WORD 3
+#define DFLT_TIMEOUT_VAL 500
+
+#define DEFINE_SSP_REG(reg, off) \
+static inline u32 read_##reg(void *p) { return __raw_readl(p + (off)); } \
+static inline void write_##reg(u32 v, void *p) { __raw_writel(v, p + (off)); }
+
+#define RX_DIRECTION 0
+#define TX_DIRECTION 1
+
+#define I2C_ACCESS_USDELAY 10
+
+#define DFLT_BITS_PER_WORD 16
+#define MIN_BITS_PER_WORD     4
+#define MAX_BITS_PER_WORD     32
+#define DFLT_FIFO_BURST_SIZE	IMSS_FIFO_BURST_8
+
+#define TRUNCATE(x, a) ((x) & ~((a)-1))
+
+DEFINE_SSP_REG(SSCR0, 0x00)
+DEFINE_SSP_REG(SSCR1, 0x04)
+DEFINE_SSP_REG(SSSR, 0x08)
+DEFINE_SSP_REG(SSITR, 0x0c)
+DEFINE_SSP_REG(SSDR, 0x10)
+DEFINE_SSP_REG(SSTO, 0x28)
+DEFINE_SSP_REG(SSPSP, 0x2c)
+DEFINE_SSP_REG(SSCR2, 0x40)
+DEFINE_SSP_REG(SSFS, 0x44)
+DEFINE_SSP_REG(SFIFOL, 0x68)
+
+DEFINE_SSP_REG(I2CCTRL, 0x00);
+DEFINE_SSP_REG(I2CDATA, 0x04);
+
+DEFINE_SSP_REG(GPLR1, 0x04);
+DEFINE_SSP_REG(GPDR1, 0x0c);
+DEFINE_SSP_REG(GPSR1, 0x14);
+DEFINE_SSP_REG(GPCR1, 0x1C);
+DEFINE_SSP_REG(GAFR1_U, 0x44);
+
+#define SYSCFG  0x20bc0
+
+#define SRAM_BASE_ADDR 0xfffdc000
+#define SRAM_RX_ADDR   SRAM_BASE_ADDR
+#define SRAM_TX_ADDR  (SRAM_BASE_ADDR + MAX_SPI_TRANSFER_SIZE)
+
+#define SSCR0_DSS   (0x0000000f)     /* Data Size Select (mask) */
+#define SSCR0_DataSize(x)  ((x) - 1)    /* Data Size Select [4..16] */
+#define SSCR0_FRF   (0x00000030)     /* FRame Format (mask) */
+#define SSCR0_Motorola        (0x0 << 4)         /* Motorola's SPI mode */
+#define SSCR0_ECS   (1 << 6) /* External clock select */
+#define SSCR0_SSE   (1 << 7) /* Synchronous Serial Port Enable */
+
+#define SSCR0_SCR   (0x000fff00)      /* Serial Clock Rate (mask) */
+#define SSCR0_SerClkDiv(x) (((x) - 1) << 8) /* Divisor [1..4096] */
+#define SSCR0_EDSS  (1 << 20)           /* Extended data size select */
+#define SSCR0_NCS   (1 << 21)           /* Network clock select */
+#define SSCR0_RIM    (1 << 22)           /* Receive FIFO overrrun int mask */
+#define SSCR0_TUM   (1 << 23)           /* Transmit FIFO underrun int mask */
+#define SSCR0_FRDC (0x07000000)     /* Frame rate divider control (mask) */
+#define SSCR0_SlotsPerFrm(x) (((x) - 1) << 24) /* Time slots per frame */
+#define SSCR0_ADC   (1 << 30)           /* Audio clock select */
+#define SSCR0_MOD  (1 << 31)           /* Mode (normal or network) */
+
+#define SSCR1_RIE    (1 << 0) /* Receive FIFO Interrupt Enable */
+#define SSCR1_TIE     (1 << 1) /* Transmit FIFO Interrupt Enable */
+#define SSCR1_LBM   (1 << 2) /* Loop-Back Mode */
+#define SSCR1_SPO   (1 << 3) /* SSPSCLK polarity setting */
+#define SSCR1_SPH   (1 << 4) /* Motorola SPI SSPSCLK phase setting */
+#define SSCR1_MWDS           (1 << 5) /* Microwire Transmit Data Size */
+#define SSCR1_TFT    (0x000003c0)     /* Transmit FIFO Threshold (mask) */
+#define SSCR1_TxTresh(x) (((x) - 1) << 6) /* level [1..16] */
+#define SSCR1_RFT    (0x00003c00)     /* Receive FIFO Threshold (mask) */
+#define SSCR1_RxTresh(x) (((x) - 1) << 10) /* level [1..16] */
+
+#define SSSR_TNF		(1 << 2)	/* Tx FIFO Not Full */
+#define SSSR_RNE		(1 << 3)	/* Rx FIFO Not Empty */
+#define SSSR_BSY		(1 << 4)	/* SSP Busy */
+#define SSSR_TFS		(1 << 5)	/* Tx FIFO Service Request */
+#define SSSR_RFS		(1 << 6)	/* Rx FIFO Service Request */
+#define SSSR_ROR		(1 << 7)	/* Rx FIFO Overrun */
+#define SSSR_TFL_MASK           (0x0F << 8)     /* Tx FIFO level field mask */
+#define SSSR_RFL_SHIFT		12		/* Rx FIFO MASK shift */
+#define SSSR_RFL_MASK		(0x0F << SSSR_RFL_SHIFT)/* RxFIFOlevel mask */
+
+#define SSCR0_TIM    (1 << 23)          /* Transmit FIFO Under Run Int Mask */
+#define SSCR0_RIM    (1 << 22)          /* Receive FIFO Over Run int Mask */
+#define SSCR0_NCS    (1 << 21)          /* Network Clock Select */
+#define SSCR0_EDSS   (1 << 20)          /* Extended Data Size Select */
+
+#define SSCR0_TISSP      (1 << 4)  /* TI Sync Serial Protocol */
+#define SSCR0_PSP        (3 << 4)  /* PSP - Programmable Serial Protocol */
+#define SSCR1_TTELP      (1 << 31) /* TXD Tristate Enable Last Phase */
+#define SSCR1_TTE        (1 << 30) /* TXD Tristate Enable */
+#define SSCR1_EBCEI      (1 << 29) /* Enable Bit Count Error interrupt */
+#define SSCR1_SCFR       (1 << 28) /* Slave Clock free Running */
+#define SSCR1_ECRA       (1 << 27) /* Enable Clock Request A */
+#define SSCR1_ECRB       (1 << 26) /* Enable Clock request B */
+#define SSCR1_SCLKDIR    (1 << 25) /* Serial Bit Rate Clock Direction */
+#define SSCR1_SFRMDIR    (1 << 24) /* Frame Direction */
+#define SSCR1_RWOT       (1 << 23) /* Receive Without Transmit */
+#define SSCR1_TRAIL      (1 << 22) /* Trailing Byte */
+#define SSCR1_TSRE       (1 << 21) /* Transmit Service Request Enable */
+#define SSCR1_RSRE       (1 << 20) /* Receive Service Request Enable */
+#define SSCR1_TINTE      (1 << 19) /* Receiver Time-out Interrupt enable */
+#define SSCR1_PINTE      (1 << 18) /* Trailing Byte Interupt Enable */
+#define SSCR1_STRF       (1 << 15) /* Select FIFO or EFWR */
+#define SSCR1_EFWR       (1 << 14) /* Enable FIFO Write/Read */
+#define SSCR1_IFS        (1 << 16) /* Invert Frame Signal */
+
+#define SSSR_BCE         (1 << 23) /* Bit Count Error */
+#define SSSR_CSS         (1 << 22) /* Clock Synchronisation Status */
+#define SSSR_TUR         (1 << 21) /* Transmit FIFO Under Run */
+#define SSSR_EOC         (1 << 20) /* End Of Chain */
+#define SSSR_TINT        (1 << 19) /* Receiver Time-out Interrupt */
+#define SSSR_PINT        (1 << 18) /* Peripheral Trailing Byte Interrupt */
+
+#define SSPSP_FSRT       (1 << 25)   /* Frame Sync Relative Timing */
+#define SSPSP_DMYSTOP(x) ((x) << 23) /* Dummy Stop */
+#define SSPSP_SFRMWDTH(x)((x) << 16) /* Serial Frame Width */
+#define SSPSP_SFRMDLY(x) ((x) << 9)  /* Serial Frame Delay */
+#define SSPSP_DMYSTRT(x) ((x) << 7)  /* Dummy Start */
+#define SSPSP_STRTDLY(x) ((x) << 4)  /* Start Delay */
+#define SSPSP_ETDS       (1 << 3)    /* End of Transfer data State */
+#define SSPSP_SFRMP      (1 << 2)    /* Serial Frame Polarity */
+#define SSPSP_SCMODE(x)  ((x) << 0)  /* Serial Bit Rate Clock Mode */
+
+#define SSCR2_CLK_DEL_EN (1 << 3)	/* Delay logic for capturing input data */
+
+/*
+ * For testing SSCR1 changes that require SSP restart, basically
+ * everything except the service and interrupt enables
+ */
+
+#define SSCR1_CHANGE_MASK (SSCR1_TTELP | SSCR1_TTE | SSCR1_SCFR \
+				| SSCR1_ECRA | SSCR1_ECRB | SSCR1_SCLKDIR \
+				| SSCR1_SFRMDIR | SSCR1_RWOT | SSCR1_TRAIL \
+				| SSCR1_IFS | SSCR1_STRF | SSCR1_EFWR \
+				| SSCR1_RFT | SSCR1_TFT | SSCR1_MWDS \
+				| SSCR1_SPH | SSCR1_SPO | SSCR1_LBM)
+
+struct callback_param {
+	void *drv_context;
+	u32 direction;
+};
+
+struct ssp_drv_context {
+	/* Driver model hookup */
+	struct pci_dev *pdev;
+
+	/* SPI framework hookup */
+	struct spi_master *master;
+
+	/* SSP register addresses */
+	unsigned long paddr;
+	void *ioaddr;
+	int irq;
+
+	/* I2C registers */
+	dma_addr_t I2C_paddr;
+	void *I2C_ioaddr;
+
+	/* SSP masks*/
+	u32 cr1_sig;
+	u32 cr1;
+	u32 clear_sr;
+	u32 mask_sr;
+
+	/* PM_QOS request */
+	struct pm_qos_request pm_qos_req;
+
+	struct tasklet_struct poll_transfer;
+
+	spinlock_t lock;
+	struct workqueue_struct *workqueue;
+	struct workqueue_struct *wq_poll_write;
+	struct work_struct pump_messages;
+	struct work_struct poll_write;
+	struct list_head queue;
+	struct completion msg_done;
+
+	int suspended;
+
+	/* Current message transfer state info */
+	struct spi_message *cur_msg;
+	size_t len;
+	size_t len_dma_rx;
+	size_t len_dma_tx;
+	void *tx;
+	void *tx_end;
+	void *rx;
+	void *rx_end;
+	bool dma_initialized;
+	int dma_mapped;
+	dma_addr_t rx_dma;
+	dma_addr_t tx_dma;
+	u8 n_bytes;
+	int (*write)(struct ssp_drv_context *sspc);
+	int (*read)(struct ssp_drv_context *sspc);
+
+	struct intel_mid_dma_slave    dmas_tx;
+	struct intel_mid_dma_slave    dmas_rx;
+	struct dma_chan    *txchan;
+	struct dma_chan    *rxchan;
+	struct workqueue_struct *dma_wq;
+	struct work_struct complete_work;
+
+	u8 __iomem *virt_addr_sram_tx;
+	u8 __iomem *virt_addr_sram_rx;
+
+	int txdma_done;
+	int rxdma_done;
+	struct callback_param tx_param;
+	struct callback_param rx_param;
+	struct pci_dev *dmac1;
+
+	unsigned long quirks;
+	u32 rx_fifo_threshold;
+
+	/* if CS_ACTIVE_HIGH, cs_assert == 1 else cs_assert == 0 */
+	int cs_assert;
+	int cs_change;
+	void (*cs_control)(u32 command);
+};
+
+struct chip_data {
+	u32 cr0;
+	u32 cr1;
+	u32 timeout;
+	u8 chip_select;
+	u8 n_bytes;
+	u8 dma_enabled;
+	u8 bits_per_word;
+	u32 speed_hz;
+	int (*write)(struct ssp_drv_context *sspc);
+	int (*read)(struct ssp_drv_context *sspc);
+	void (*cs_control)(u32 command);
+};
+
+
+enum intel_mid_ssp_spi_fifo_burst {
+	IMSS_FIFO_BURST_1,
+	IMSS_FIFO_BURST_4,
+	IMSS_FIFO_BURST_8
+};
+
+/* spi_board_info.controller_data for SPI slave devices,
+ * copied to spi_device.platform_data ... mostly for dma tuning
+ */
+struct intel_mid_ssp_spi_chip {
+	enum intel_mid_ssp_spi_fifo_burst burst_size;
+	u32 timeout;
+	u8 enable_loopback;
+	u8 dma_enabled;
+	void (*cs_control)(u32 command);
+	void (*platform_pinmux)(void);
+};
+
+#define SPI_DIB_NAME_LEN  16
+#define SPI_DIB_SPEC_INFO_LEN      10
+
+struct spi_dib_header {
+	u32       signature;
+	u32       length;
+	u8         rev;
+	u8         checksum;
+	u8         dib[0];
+} __packed;
+
+#endif /*INTEL_MID_SSP_SPI_H_*/
-- 
1.7.5.4

