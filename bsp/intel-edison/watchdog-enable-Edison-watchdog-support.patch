From 661bc22cced18904c1a854707530f65b1ed7b953 Mon Sep 17 00:00:00 2001
From: Liwei Song <liwei.song@windriver.com>
Date: Tue, 1 Mar 2016 19:49:08 -0500
Subject: [PATCH 07/11] watchdog: enable Edison watchdog support

This patch is from yocto Intel Edison support:
http://downloadmirror.intel.com/25028/eng/edison-src-ww25.5-15.tgz

Enable Intel Edison watchdog support.

Signed-off-by: Liwei Song <liwei.song@windriver.com>
---
 arch/x86/include/asm/intel_mip.h          |   32 +
 arch/x86/include/asm/intel_scu_ipcutil.h  |  135 ++
 drivers/platform/x86/Makefile             |    2 +-
 drivers/platform/x86/intel_scu_ipc.c      |  704 ++++-----
 drivers/platform/x86/intel_scu_ipcutil.c  | 2587 ++++++++++++++++++++++++++++-
 drivers/platform/x86/intel_scu_mip.c      |  776 +++++++++
 drivers/platform/x86/intel_scu_pmic.c     |  477 ++++++
 drivers/watchdog/Kconfig                  |   21 +
 drivers/watchdog/Makefile                 |    1 +
 drivers/watchdog/intel_scu_watchdog.c     |  567 -------
 drivers/watchdog/intel_scu_watchdog_evo.c | 1403 ++++++++++++++++
 drivers/watchdog/intel_scu_watchdog_evo.h |   68 +
 12 files changed, 5741 insertions(+), 1032 deletions(-)
 create mode 100644 arch/x86/include/asm/intel_mip.h
 create mode 100644 arch/x86/include/asm/intel_scu_ipcutil.h
 create mode 100644 drivers/platform/x86/intel_scu_mip.c
 create mode 100644 drivers/platform/x86/intel_scu_pmic.c
 delete mode 100644 drivers/watchdog/intel_scu_watchdog.c
 create mode 100644 drivers/watchdog/intel_scu_watchdog_evo.c
 create mode 100644 drivers/watchdog/intel_scu_watchdog_evo.h

diff --git a/arch/x86/include/asm/intel_mip.h b/arch/x86/include/asm/intel_mip.h
new file mode 100644
index 0000000..f05fc05
--- /dev/null
+++ b/arch/x86/include/asm/intel_mip.h
@@ -0,0 +1,32 @@
+#ifndef _ASM_X86_INTEL_MIP_H_
+#define  _ASM_X86_INTEL_MIP_H_
+
+#include <asm/intel-mid.h>
+
+/* SMIP property related definitions */
+#define SCU_MIP_DEV_NAME		"intel_scu_mip"
+#define SMIP_NUM_CONFIG_PROPS		6
+#define SMIP_MAX_PROP_LEN		4
+
+enum platform_prop {
+	USB_COMPLIANCE,
+	CHARGE_TERMINATION,
+	SHUTDOWN_METHODOLOGY,
+	MOS_TRANS_CAPACITY,
+	NFC_RESV_CAPACITY,
+	TEMP_CRIT_SHUTDOWN,
+};
+
+struct smip_platform_prop {
+	unsigned int offset;
+	unsigned int len;
+	bool is_bit_field;
+	unsigned int mask;
+};
+
+struct scu_mip_platform_data {
+	struct smip_platform_prop smip_prop[SMIP_NUM_CONFIG_PROPS];
+};
+
+int get_smip_property_by_name(enum platform_prop);
+#endif
diff --git a/arch/x86/include/asm/intel_scu_ipcutil.h b/arch/x86/include/asm/intel_scu_ipcutil.h
new file mode 100644
index 0000000..0153882
--- /dev/null
+++ b/arch/x86/include/asm/intel_scu_ipcutil.h
@@ -0,0 +1,135 @@
+#ifndef _ASM_X86_INTEL_SCU_IPCUTIL_H_
+#define _ASM_X86_INTEL_SCU_IPCUTIL_H_
+
+#include <linux/types.h>
+
+/* ioctl commnds */
+#define INTEL_SCU_IPC_REGISTER_READ	0
+#define INTEL_SCU_IPC_REGISTER_WRITE	1
+#define INTEL_SCU_IPC_REGISTER_UPDATE	2
+#define INTEL_SCU_IPC_FW_UPDATE			    0xA2
+#define INTEL_SCU_IPC_MEDFIELD_FW_UPDATE	    0xA3
+#define INTEL_SCU_IPC_FW_REVISION_GET		    0xB0
+#define INTEL_SCU_IPC_FW_REVISION_EXT_GET	    0xB1
+#define INTEL_SCU_IPC_S0IX_RESIDENCY		    0xB8
+#define INTEL_SCU_IPC_READ_RR_FROM_OSNIB	    0xC1
+#define INTEL_SCU_IPC_WRITE_RR_TO_OSNIB		    0xC2
+#define INTEL_SCU_IPC_READ_VBATTCRIT		    0xC4
+#define INTEL_SCU_IPC_WRITE_ALARM_FLAG_TO_OSNIB	    0xC5
+#define INTEL_SCU_IPC_OSC_CLK_CNTL		    0xC6
+#define INTEL_SCU_IPC_PMDB_ACCESS		    0xD0
+
+#define SIGNED_MOS_ATTR		0x0
+#define SIGNED_COS_ATTR		0x0A
+#define SIGNED_RECOVERY_ATTR	0x0C
+#define SIGNED_POS_ATTR		0x0E
+#define SIGNED_FACTORY_ATTR	0x12
+
+enum intel_scu_ipc_wake_src {
+	WAKE_BATT_INSERT,
+	WAKE_PWR_BUTTON_PRESS,
+	WAKE_RTC_TIMER,
+	WAKE_USB_CHRG_INSERT,
+	WAKE_RESERVED,
+	WAKE_REAL_RESET,
+	WAKE_COLD_BOOT,
+	WAKE_UNKNOWN,
+	WAKE_KERNEL_WATCHDOG_RESET,
+	WAKE_SECURITY_WATCHDOG_RESET,
+	WAKE_WATCHDOG_COUNTER_EXCEEDED,
+	WAKE_POWER_SUPPLY_DETECTED,
+	WAKE_FASTBOOT_BUTTONS_COMBO,
+	WAKE_NO_MATCHING_OSIP_ENTRY,
+	WAKE_CRITICAL_BATTERY,
+	WAKE_INVALID_CHECKSUM,
+	WAKE_FORCED_RESET,
+	WAKE_ACDC_CHRG_INSERT,
+	WAKE_PMIC_WATCHDOG_RESET,
+	WAKE_PLATFORM_WATCHDOG_RESET,
+	WAKE_SC_WATCHDOG_RESET
+};
+
+struct scu_ipc_data {
+	__u32	count;  /* No. of registers */
+	__u16	addr[5]; /* Register addresses */
+	__u8	data[5]; /* Register data */
+	__u8	mask; /* Valid for read-modify-write */
+};
+
+struct scu_ipc_version {
+	__u32	count;  /* length of version info */
+	__u8	data[16]; /* version data */
+};
+
+struct osc_clk_t {
+	__u32	id; /* clock id */
+	__u32	khz; /* clock frequency */
+};
+
+/* PMDB buffer, cmd, and limits */
+#define PMDB_SIZE              512
+#define PMDB_WMDB_SIZE         76
+#define PMDB_OTPDB_SIZE        384
+#define PMDB_OTPCTL_SIZE       48
+#define PMDB_ACCESS_SIZE       16
+
+#define PMDB_SUB_CMD_R_WMDB    0
+#define PMDB_SUB_CMD_R_OTPDB   1
+#define PMDB_SUB_CMD_W_WMDB    2
+#define PMDB_SUB_CMD_W_OTPDB   3
+#define PMDB_SUB_CMD_R_OTPCTL  4
+
+struct scu_ipc_pmdb_buffer {
+	__u32	sub; /* sub cmd of SCU's PMDB IPC commands */
+	__u32	count; /* length of PMDB buffer */
+	__u32	offset; /* buffer start offset for each PMDB component */
+	__u8	data[PMDB_SIZE]; /* PMDB buffer */
+};
+
+/* Penwell has 4 osc clocks */
+#define OSC_CLK_AUDIO	0	/* Audio */
+#define OSC_CLK_CAM0	1	/* Primary camera */
+#define OSC_CLK_CAM1	2	/* Secondary camera */
+#define OSC_CLK_DISP	3	/* Display buffer */
+
+#ifdef __KERNEL__
+
+int intel_scu_ipc_osc_clk(u8 clk, unsigned int khz);
+
+enum clk0_mode {
+	CLK0_AUDIENCE = 0x4,
+	CLK0_VIBRA1 = 0x8,
+	CLK0_VIBRA2 = 0x10,
+	CLK0_MSIC = 0x20,
+	CLK0_DEBUG = 0x100,
+	CLK0_QUERY = 0x1000,
+};
+
+int intel_scu_ipc_set_osc_clk0(unsigned int enable, enum clk0_mode mode);
+
+/* Helpers to turn on/off msic vprog1 and vprog2 */
+int intel_scu_ipc_msic_vprog1(int on);
+int intel_scu_ipc_msic_vprog2(int on);
+
+/* OSHOB-OS Handoff Buffer read */
+int intel_scu_ipc_get_oshob_base(void);
+int intel_scu_ipc_get_oshob_size(void);
+
+/* SCU trace buffer interface */
+u32 intel_scu_ipc_get_scu_trace_buffer(void);
+u32 intel_scu_ipc_get_scu_trace_buffer_size(void);
+u32 intel_scu_ipc_get_fabricerror_buf1_offset(void);
+u32 intel_scu_ipc_get_fabricerror_buf2_offset(void);
+
+/* OSNIB interface. */
+int intel_scu_ipc_write_osnib(u8 *data, int len, int offset);
+int intel_scu_ipc_read_osnib(u8 *data, int len, int offset);
+int intel_scu_ipc_write_osnib_extend(u8 *data, int len, int offset);
+int intel_scu_ipc_read_osnib_extend(u8 *data, int len, int offset);
+int intel_scu_ipc_write_osnib_rr(u8 rr);
+int intel_scu_ipc_read_osnib_rr(u8 *rr);
+int intel_scu_ipc_read_osnib_wd(u8 *wd);
+int intel_scu_ipc_write_osnib_wd(u8 *wd);
+#endif
+
+#endif
diff --git a/drivers/platform/x86/Makefile b/drivers/platform/x86/Makefile
index 303ab95..2acdf96 100644
--- a/drivers/platform/x86/Makefile
+++ b/drivers/platform/x86/Makefile
@@ -37,7 +37,7 @@ obj-$(CONFIG_TOPSTAR_LAPTOP)	+= topstar-laptop.o
 obj-$(CONFIG_ACPI_TOSHIBA)	+= toshiba_acpi.o
 
 obj-$(CONFIG_TOSHIBA_BT_RFKILL)	+= toshiba_bluetooth.o
-obj-$(CONFIG_INTEL_SCU_IPC)	+= intel_scu_ipc.o
+obj-$(CONFIG_INTEL_SCU_IPC)	+= intel_scu_ipc.o intel_scu_pmic.o intel_scu_mip.o
 obj-$(CONFIG_INTEL_SCU_IPC_UTIL) += intel_scu_ipcutil.o
 obj-$(CONFIG_INTEL_MFLD_THERMAL) += intel_mid_thermal.o
 obj-$(CONFIG_INTEL_SCU_FLIS)   += intel_scu_flis.o
diff --git a/drivers/platform/x86/intel_scu_ipc.c b/drivers/platform/x86/intel_scu_ipc.c
index 76ca094..ed5a972 100644
--- a/drivers/platform/x86/intel_scu_ipc.c
+++ b/drivers/platform/x86/intel_scu_ipc.c
@@ -23,22 +23,67 @@
 #include <linux/pm.h>
 #include <linux/pci.h>
 #include <linux/interrupt.h>
-#include <linux/sfi.h>
 #include <linux/module.h>
 #include <asm/intel-mid.h>
 #include <asm/intel_scu_ipc.h>
+#include <linux/pm_qos.h>
+#include <linux/intel_mid_pm.h>
+#include <linux/kernel.h>
+#include <linux/bitops.h>
+#include <linux/sched.h>
+#include <linux/atomic.h>
+#include <linux/notifier.h>
+#include <linux/suspend.h>
+
+enum {
+	SCU_IPC_LINCROFT,
+	SCU_IPC_PENWELL,
+	SCU_IPC_CLOVERVIEW,
+	SCU_IPC_TANGIER,
+};
 
-/* IPC defines the following message types */
-#define IPCMSG_WATCHDOG_TIMER 0xF8 /* Set Kernel Watchdog Threshold */
-#define IPCMSG_BATTERY        0xEF /* Coulomb Counter Accumulator */
-#define IPCMSG_FW_UPDATE      0xFE /* Firmware update */
-#define IPCMSG_PCNTRL         0xFF /* Power controller unit read/write */
-#define IPCMSG_FW_REVISION    0xF4 /* Get firmware revision */
+/* intel scu ipc driver data*/
+struct intel_scu_ipc_pdata_t {
+	u32 ipc_base;
+	u32 i2c_base;
+	u32 ipc_len;
+	u32 i2c_len;
+};
 
-/* Command id associated with message IPCMSG_PCNTRL */
-#define IPC_CMD_PCNTRL_W      0 /* Register write */
-#define IPC_CMD_PCNTRL_R      1 /* Register read */
-#define IPC_CMD_PCNTRL_M      2 /* Register read-modify-write */
+static struct intel_scu_ipc_pdata_t intel_scu_ipc_pdata[] = {
+	[SCU_IPC_LINCROFT] = {
+		.ipc_base = 0xff11c000,
+		.i2c_base = 0xff12b000,
+		.ipc_len = 0x100,
+		.i2c_len = 0x10,
+	},
+	[SCU_IPC_PENWELL] = {
+		.ipc_base = 0xff11c000,
+		.i2c_base = 0xff12b000,
+		.ipc_len = 0x100,
+		.i2c_len = 0x10,
+	},
+	[SCU_IPC_CLOVERVIEW] = {
+		.ipc_base = 0xff11c000,
+		.i2c_base = 0xff12b000,
+		.ipc_len = 0x100,
+		.i2c_len = 0x10,
+	},
+	[SCU_IPC_TANGIER] = {
+		.ipc_base = 0xff009000,
+		.i2c_base  = 0xff00d000,
+		.ipc_len  = 0x100,
+		.i2c_len = 0x10,
+	},
+};
+static int  scu_ipc_pm_callback(struct notifier_block *nb,
+					unsigned long action,
+					void *ignored);
+
+static struct notifier_block scu_ipc_pm_notifier = {
+	.notifier_call = scu_ipc_pm_callback,
+	.priority = 1,
+};
 
 /*
  * IPC register summary
@@ -58,75 +103,82 @@
  *    message handler is called within firmware.
  */
 
-#define IPC_WWBUF_SIZE    20		/* IPC Write buffer Size */
-#define IPC_RWBUF_SIZE    20		/* IPC Read buffer Size */
+#define IPC_STATUS_ADDR		0X04
+#define IPC_SPTR_ADDR		0x08
+#define IPC_DPTR_ADDR		0x0C
+#define IPC_READ_BUFFER		0x90
+#define IPC_WRITE_BUFFER	0x80
 #define IPC_IOC	          0x100		/* IPC command register IOC bit */
 
-#define PCI_DEVICE_ID_LINCROFT		0x082a
-#define PCI_DEVICE_ID_PENWELL		0x080e
-#define PCI_DEVICE_ID_CLOVERVIEW	0x08ea
-#define PCI_DEVICE_ID_TANGIER		0x11a0
-
-/* intel scu ipc driver data*/
-struct intel_scu_ipc_pdata_t {
-	u32 ipc_base;
-	u32 i2c_base;
-	u32 ipc_len;
-	u32 i2c_len;
-	u8 irq_mode;
-};
-
-static struct intel_scu_ipc_pdata_t intel_scu_ipc_lincroft_pdata = {
-	.ipc_base = 0xff11c000,
-	.i2c_base = 0xff12b000,
-	.ipc_len = 0x100,
-	.i2c_len = 0x10,
-	.irq_mode = 0,
-};
-
-/* Penwell and Cloverview */
-static struct intel_scu_ipc_pdata_t intel_scu_ipc_penwell_pdata = {
-	.ipc_base = 0xff11c000,
-	.i2c_base = 0xff12b000,
-	.ipc_len = 0x100,
-	.i2c_len = 0x10,
-	.irq_mode = 1,
-};
-
-static struct intel_scu_ipc_pdata_t intel_scu_ipc_tangier_pdata = {
-	.ipc_base = 0xff009000,
-	.i2c_base  = 0xff00d000,
-	.ipc_len  = 0x100,
-	.i2c_len = 0x10,
-	.irq_mode = 0,
-};
-
-static int ipc_probe(struct pci_dev *dev, const struct pci_device_id *id);
-static void ipc_remove(struct pci_dev *pdev);
-
-struct intel_scu_ipc_dev {
+struct intel_ipc_controller {
 	struct pci_dev *pdev;
 	void __iomem *ipc_base;
 	void __iomem *i2c_base;
+	int ioc;
+	int cmd;
 	struct completion cmd_complete;
-	u8 irq_mode;
 };
 
-static struct intel_scu_ipc_dev  ipcdev; /* Only one for now */
+static struct intel_ipc_controller  ipcdev; /* Only one for now */
+
+static int platform; /* Platform type */
+
+static char *ipc_err_sources[] = {
+	[IPC_ERR_NONE] =
+		"no error",
+	[IPC_ERR_CMD_NOT_SUPPORTED] =
+		"command not supported",
+	[IPC_ERR_CMD_NOT_SERVICED] =
+		"command not serviced",
+	[IPC_ERR_UNABLE_TO_SERVICE] =
+		"unable to service",
+	[IPC_ERR_CMD_INVALID] =
+		"command invalid",
+	[IPC_ERR_CMD_FAILED] =
+		"command failed",
+	[IPC_ERR_EMSECURITY] =
+		"Invalid Battery",
+	[IPC_ERR_UNSIGNEDKERNEL] =
+		"Unsigned kernel",
+};
 
-static int platform;		/* Platform type */
+/* PM Qos struct */
+static struct pm_qos_request *qos;
 
-/*
- * IPC Read Buffer (Read Only):
- * 16 byte buffer for receiving data from SCU, if IPC command
- * processing results in response data
- */
-#define IPC_READ_BUFFER		0x90
+/* Suspend status*/
+static bool suspend_status;
+static DEFINE_MUTEX(scu_suspend_lock);
 
-#define IPC_I2C_CNTRL_ADDR	0
-#define I2C_DATA_ADDR		0x04
+/* Suspend status get */
+bool suspend_in_progress(void)
+{
+	return suspend_status;
+}
+
+/* Suspend status set */
+void set_suspend_status(bool status)
+{
+	mutex_lock(&scu_suspend_lock);
+	suspend_status = status;
+	mutex_unlock(&scu_suspend_lock);
+}
+
+/* IPC PM notifier callback */
+static int scu_ipc_pm_callback(struct notifier_block *nb,
+					unsigned long action,
+					void *ignored)
+{
+	switch (action) {
+	case PM_SUSPEND_PREPARE:
+		set_suspend_status(true);
+		return NOTIFY_OK;
+	case PM_POST_SUSPEND:
+		set_suspend_status(false);
+		return NOTIFY_OK;
+	}
 
-static DEFINE_MUTEX(ipclock); /* lock used to prevent multiple call to SCU */
+	return NOTIFY_DONE;
+}
 
 /*
  * Command Register (Write Only):
@@ -134,13 +186,18 @@ static DEFINE_MUTEX(ipclock); /* lock used to prevent multiple call to SCU */
  * Format:
  * |rfu2(8) | size(8) | command id(4) | rfu1(3) | ioc(1) | command(8)|
  */
-static inline void ipc_command(u32 cmd) /* Send ipc command */
+void intel_scu_ipc_send_command(u32 cmd) /* Send ipc command */
 {
-	if (ipcdev.irq_mode) {
-		reinit_completion(&ipcdev.cmd_complete);
+	ipcdev.cmd = cmd;
+	reinit_completion(&ipcdev.cmd_complete);
+
+	if (system_state == SYSTEM_RUNNING && !suspend_in_progress()) {
+		ipcdev.ioc = 1;
 		writel(cmd | IPC_IOC, ipcdev.ipc_base);
+	} else {
+		ipcdev.ioc = 0;
+		writel(cmd, ipcdev.ipc_base);
 	}
-	writel(cmd, ipcdev.ipc_base);
 }
 
 /*
@@ -150,7 +207,7 @@ static inline void ipc_command(u32 cmd) /* Send ipc command */
  */
 static inline void ipc_data_writel(u32 data, u32 offset) /* Write ipc data */
 {
-	writel(data, ipcdev.ipc_base + 0x80 + offset);
+	writel(data, ipcdev.ipc_base + IPC_WRITE_BUFFER + offset);
 }
 
 /*
@@ -161,9 +218,9 @@ static inline void ipc_data_writel(u32 data, u32 offset) /* Write ipc data */
  * |rfu3(8)|error code(8)|initiator id(8)|cmd id(4)|rfu1(2)|error(1)|busy(1)|
  */
 
-static inline u8 ipc_read_status(void)
+static inline u32 ipc_read_status(void)
 {
-	return __raw_readl(ipcdev.ipc_base + 0x04);
+	return __raw_readl(ipcdev.ipc_base + IPC_STATUS_ADDR);
 }
 
 static inline u8 ipc_data_readb(u32 offset) /* Read ipc byte data */
@@ -176,267 +233,72 @@ static inline u32 ipc_data_readl(u32 offset) /* Read ipc u32 data */
 	return readl(ipcdev.ipc_base + IPC_READ_BUFFER + offset);
 }
 
-static inline int busy_loop(void) /* Wait till scu status is busy */
-{
-	u32 status = 0;
-	u32 loop_count = 0;
-
-	status = ipc_read_status();
-	while (status & 1) {
-		udelay(1); /* scu processing time is in few u secods */
-		status = ipc_read_status();
-		loop_count++;
-		/* break if scu doesn't reset busy bit after huge retry */
-		if (loop_count > 100000) {
-			dev_err(&ipcdev.pdev->dev, "IPC timed out");
-			return -ETIMEDOUT;
-		}
-	}
-	if ((status >> 1) & 1)
-		return -EIO;
-
-	return 0;
-}
-
-/* Wait till ipc ioc interrupt is received or timeout in 3 HZ */
-static inline int ipc_wait_for_interrupt(void)
+int intel_scu_ipc_check_status(void)
 {
+	int i;
+	int ret = 0;
 	int status;
+	int loop_count = 3000000;
 
-	if (!wait_for_completion_timeout(&ipcdev.cmd_complete, 3 * HZ)) {
-		struct device *dev = &ipcdev.pdev->dev;
-		dev_err(dev, "IPC timed out\n");
-		return -ETIMEDOUT;
-	}
+	if (ipcdev.ioc && (system_state == SYSTEM_RUNNING) &&
+			(!suspend_in_progress())) {
+		if (0 == wait_for_completion_timeout(
+				&ipcdev.cmd_complete, 3 * HZ))
+			ret = -ETIMEDOUT;
+	} else {
+		while ((ipc_read_status() & 1) && --loop_count)
+			udelay(1);
+		if (loop_count == 0)
+			ret = -ETIMEDOUT;
+ 	}
 
 	status = ipc_read_status();
-
-	if ((status >> 1) & 1)
-		return -EIO;
-
-	return 0;
-}
-
-int intel_scu_ipc_check_status(void)
-{
-	return ipcdev.irq_mode ? ipc_wait_for_interrupt() : busy_loop();
-}
-
-/* Read/Write power control(PMIC in Langwell, MSIC in PenWell) registers */
-static int pwr_reg_rdwr(u16 *addr, u8 *data, u32 count, u32 op, u32 id)
-{
-	int nc;
-	u32 offset = 0;
-	int err;
-	u8 cbuf[IPC_WWBUF_SIZE] = { };
-	u32 *wbuf = (u32 *)&cbuf;
-
-	mutex_lock(&ipclock);
-
-	memset(cbuf, 0, sizeof(cbuf));
-
-	if (ipcdev.pdev == NULL) {
-		mutex_unlock(&ipclock);
-		return -ENODEV;
-	}
-
-	for (nc = 0; nc < count; nc++, offset += 2) {
-		cbuf[offset] = addr[nc];
-		cbuf[offset + 1] = addr[nc] >> 8;
-	}
-
-	if (id == IPC_CMD_PCNTRL_R) {
-		for (nc = 0, offset = 0; nc < count; nc++, offset += 4)
-			ipc_data_writel(wbuf[nc], offset);
-		ipc_command((count*2) << 16 |  id << 12 | 0 << 8 | op);
-	} else if (id == IPC_CMD_PCNTRL_W) {
-		for (nc = 0; nc < count; nc++, offset += 1)
-			cbuf[offset] = data[nc];
-		for (nc = 0, offset = 0; nc < count; nc++, offset += 4)
-			ipc_data_writel(wbuf[nc], offset);
-		ipc_command((count*3) << 16 |  id << 12 | 0 << 8 | op);
-	} else if (id == IPC_CMD_PCNTRL_M) {
-		cbuf[offset] = data[0];
-		cbuf[offset + 1] = data[1];
-		ipc_data_writel(wbuf[0], 0); /* Write wbuff */
-		ipc_command(4 << 16 |  id << 12 | 0 << 8 | op);
-	}
-
-	err = intel_scu_ipc_check_status();
-	if (!err && id == IPC_CMD_PCNTRL_R) { /* Read rbuf */
-		/* Workaround: values are read as 0 without memcpy_fromio */
-		memcpy_fromio(cbuf, ipcdev.ipc_base + 0x90, 16);
-		for (nc = 0; nc < count; nc++)
-			data[nc] = ipc_data_readb(nc);
-	}
-	mutex_unlock(&ipclock);
-	return err;
-}
-
-/**
- *	intel_scu_ipc_ioread8		-	read a word via the SCU
- *	@addr: register on SCU
- *	@data: return pointer for read byte
- *
- *	Read a single register. Returns 0 on success or an error code. All
- *	locking between SCU accesses is handled for the caller.
- *
- *	This function may sleep.
- */
-int intel_scu_ipc_ioread8(u16 addr, u8 *data)
-{
-	return pwr_reg_rdwr(&addr, data, 1, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_R);
-}
-EXPORT_SYMBOL(intel_scu_ipc_ioread8);
-
-/**
- *	intel_scu_ipc_ioread16		-	read a word via the SCU
- *	@addr: register on SCU
- *	@data: return pointer for read word
- *
- *	Read a register pair. Returns 0 on success or an error code. All
- *	locking between SCU accesses is handled for the caller.
- *
- *	This function may sleep.
- */
-int intel_scu_ipc_ioread16(u16 addr, u16 *data)
-{
-	u16 x[2] = {addr, addr + 1 };
-	return pwr_reg_rdwr(x, (u8 *)data, 2, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_R);
+	if (ret == -ETIMEDOUT)
+		dev_err(&ipcdev.pdev->dev,
+			"IPC timed out, IPC_STS=0x%x, IPC_CMD=0x%x\n",
+			status, ipcdev.cmd);
+
+	if (status & 0x2) {
+		ret = -EIO;
+		i = (status >> 16) & 0xFF;
+		if (i < ARRAY_SIZE(ipc_err_sources))
+			dev_err(&ipcdev.pdev->dev,
+				"IPC failed: %s, IPC_STS=0x%x, IPC_CMD=0x%x\n",
+				ipc_err_sources[i], status, ipcdev.cmd);
+		else
+			dev_err(&ipcdev.pdev->dev,
+				"IPC failed: unknown error, IPC_STS=0x%x, "
+				"IPC_CMD=0x%x\n", status, ipcdev.cmd);
+		if ((i == IPC_ERR_UNSIGNEDKERNEL) || (i == IPC_ERR_EMSECURITY))
+			ret = -EACCES;
+ 	}
+
+	return ret;
 }
-EXPORT_SYMBOL(intel_scu_ipc_ioread16);
 
-/**
- *	intel_scu_ipc_ioread32		-	read a dword via the SCU
- *	@addr: register on SCU
- *	@data: return pointer for read dword
- *
- *	Read four registers. Returns 0 on success or an error code. All
- *	locking between SCU accesses is handled for the caller.
- *
- *	This function may sleep.
- */
-int intel_scu_ipc_ioread32(u16 addr, u32 *data)
+void intel_scu_ipc_lock(void)
 {
-	u16 x[4] = {addr, addr + 1, addr + 2, addr + 3};
-	return pwr_reg_rdwr(x, (u8 *)data, 4, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_R);
-}
-EXPORT_SYMBOL(intel_scu_ipc_ioread32);
+	/* Prevent C-states beyond C6 */
+	pm_qos_update_request(qos, CSTATE_EXIT_LATENCY_S0i1 - 1);
 
-/**
- *	intel_scu_ipc_iowrite8		-	write a byte via the SCU
- *	@addr: register on SCU
- *	@data: byte to write
- *
- *	Write a single register. Returns 0 on success or an error code. All
- *	locking between SCU accesses is handled for the caller.
- *
- *	This function may sleep.
- */
-int intel_scu_ipc_iowrite8(u16 addr, u8 data)
-{
-	return pwr_reg_rdwr(&addr, &data, 1, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_W);
-}
-EXPORT_SYMBOL(intel_scu_ipc_iowrite8);
+	/* Prevent S3 */
+	mutex_lock(&scu_suspend_lock);
 
-/**
- *	intel_scu_ipc_iowrite16		-	write a word via the SCU
- *	@addr: register on SCU
- *	@data: word to write
- *
- *	Write two registers. Returns 0 on success or an error code. All
- *	locking between SCU accesses is handled for the caller.
- *
- *	This function may sleep.
- */
-int intel_scu_ipc_iowrite16(u16 addr, u16 data)
-{
-	u16 x[2] = {addr, addr + 1 };
-	return pwr_reg_rdwr(x, (u8 *)&data, 2, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_W);
 }
-EXPORT_SYMBOL(intel_scu_ipc_iowrite16);
+EXPORT_SYMBOL_GPL(intel_scu_ipc_lock);
 
-/**
- *	intel_scu_ipc_iowrite32		-	write a dword via the SCU
- *	@addr: register on SCU
- *	@data: dword to write
- *
- *	Write four registers. Returns 0 on success or an error code. All
- *	locking between SCU accesses is handled for the caller.
- *
- *	This function may sleep.
- */
-int intel_scu_ipc_iowrite32(u16 addr, u32 data)
+void intel_scu_ipc_unlock(void)
 {
-	u16 x[4] = {addr, addr + 1, addr + 2, addr + 3};
-	return pwr_reg_rdwr(x, (u8 *)&data, 4, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_W);
-}
-EXPORT_SYMBOL(intel_scu_ipc_iowrite32);
+	/* Re-enable S3 */
+	mutex_unlock(&scu_suspend_lock);
 
-/**
- *	intel_scu_ipc_readvv		-	read a set of registers
- *	@addr: register list
- *	@data: bytes to return
- *	@len: length of array
- *
- *	Read registers. Returns 0 on success or an error code. All
- *	locking between SCU accesses is handled for the caller.
- *
- *	The largest array length permitted by the hardware is 5 items.
- *
- *	This function may sleep.
- */
-int intel_scu_ipc_readv(u16 *addr, u8 *data, int len)
-{
-	return pwr_reg_rdwr(addr, data, len, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_R);
+	/* Re-enable Deeper C-states beyond C6 */
+	pm_qos_update_request(qos, PM_QOS_DEFAULT_VALUE);
 }
-EXPORT_SYMBOL(intel_scu_ipc_readv);
+EXPORT_SYMBOL_GPL(intel_scu_ipc_unlock);
 
 /**
- *	intel_scu_ipc_writev		-	write a set of registers
- *	@addr: register list
- *	@data: bytes to write
- *	@len: length of array
- *
- *	Write registers. Returns 0 on success or an error code. All
- *	locking between SCU accesses is handled for the caller.
- *
- *	The largest array length permitted by the hardware is 5 items.
- *
- *	This function may sleep.
- *
- */
-int intel_scu_ipc_writev(u16 *addr, u8 *data, int len)
-{
-	return pwr_reg_rdwr(addr, data, len, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_W);
-}
-EXPORT_SYMBOL(intel_scu_ipc_writev);
-
-
-/**
- *	intel_scu_ipc_update_register	-	r/m/w a register
- *	@addr: register address
- *	@bits: bits to update
- *	@mask: mask of bits to update
- *
- *	Read-modify-write power control unit register. The first data argument
- *	must be register value and second is mask value
- *	mask is a bitmap that indicates which bits to update.
- *	0 = masked. Don't modify this bit, 1 = modify this bit.
- *	returns 0 on success or an error code.
- *
- *	This function may sleep. Locking between SCU accesses is handled
- *	for the caller.
- */
-int intel_scu_ipc_update_register(u16 addr, u8 bits, u8 mask)
-{
-	u8 data[2] = { bits, mask };
-	return pwr_reg_rdwr(&addr, data, 1, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_M);
-}
-EXPORT_SYMBOL(intel_scu_ipc_update_register);
-
-/**
- *	intel_scu_ipc_simple_command	-	send a simple command
+ *	intel_scu_ipc_simple_command - send a simple command
  *	@cmd: command
  *	@sub: sub type
  *
@@ -451,122 +313,115 @@ int intel_scu_ipc_simple_command(int cmd, int sub)
 {
 	int err;
 
-	mutex_lock(&ipclock);
-	if (ipcdev.pdev == NULL) {
-		mutex_unlock(&ipclock);
+	if (ipcdev.pdev == NULL)
 		return -ENODEV;
-	}
-	ipc_command(sub << 12 | cmd);
+
+	intel_scu_ipc_lock();
+	intel_scu_ipc_send_command(sub << 12 | cmd);
 	err = intel_scu_ipc_check_status();
-	mutex_unlock(&ipclock);
+	intel_scu_ipc_unlock();
 	return err;
 }
 EXPORT_SYMBOL(intel_scu_ipc_simple_command);
 
 /**
- *	intel_scu_ipc_command	-	command with data
- *	@cmd: command
- *	@sub: sub type
- *	@in: input data
- *	@inlen: input length in dwords
- *	@out: output data
- *	@outlein: output length in dwords
- *
- *	Issue a command to the SCU which involves data transfers. Do the
- *	data copies under the lock but leave it for the caller to interpret
+ * intel_scu_ipc_raw_cmd - raw ipc command with data
+ * @cmd: command
+ * @sub: sub type
+ * @in: input data
+ * @inlen: input length in bytes
+ * @out: output data
+ * @outlen: output length in dwords
+ * @sptr: data writing to SPTR register
+ * @dptr: data writing to DPTR register
+ *
+ * Issue a command to the SCU which involves data transfers. Do the
+ * data copies under the lock but leave it for the caller to interpret
+ * Note: This function should be called with the holding of ipclock
  */
-
-int intel_scu_ipc_command(int cmd, int sub, u32 *in, int inlen,
-							u32 *out, int outlen)
+int intel_scu_ipc_raw_cmd(u32 cmd, u32 sub, u8 *in, u32 inlen, u32 *out,
+		u32 outlen, u32 dptr, u32 sptr)
 {
 	int i, err;
+	u32 wbuf[4] = { 0 };
 
-	mutex_lock(&ipclock);
-	if (ipcdev.pdev == NULL) {
-		mutex_unlock(&ipclock);
+	if (ipcdev.pdev == NULL)
 		return -ENODEV;
-	}
-
-	for (i = 0; i < inlen; i++)
-		ipc_data_writel(*in++, 4 * i);
 
-	ipc_command((inlen << 16) | (sub << 12) | cmd);
+	if (inlen > 16)
+		return -EINVAL;
+
+	memcpy(wbuf, in, inlen);
+
+	writel(dptr, ipcdev.ipc_base + IPC_DPTR_ADDR);
+	writel(sptr, ipcdev.ipc_base + IPC_SPTR_ADDR);
+
+	/**
+	 * SRAM controller doesn't support 8bit write, it only supports
+	 * 32bit write, so we have to write into the WBUF in 32bit,
+	 * and SCU FW will use the inlen to determine the actual input
+	 * data length in the WBUF.
+	 */
+	for (i = 0; i < ((inlen + 3) / 4); i++)
+		ipc_data_writel(wbuf[i], 4 * i);
+
+	/**
+	 * Watchdog IPC command is an exception here using double word
+	 * as the unit of input data size because of historical reasons
+	 * and SCU FW is doing so.
+	 */
+	if ((cmd & 0xFF) == IPCMSG_WATCHDOG_TIMER)
+		inlen = (inlen + 3) / 4;
+	/*
+	 *  In case of 3 pmic writes or read-modify-writes
+	 *  there are holes in the middle of the buffer which are
+	 *  ignored by SCU. These bytes should not be included into
+	 *  size of the ipc msg. Holes are as follows:
+	 *  write: wbuf[6 & 7]
+	 *  read-modifu-write: wbuf[6 & 7 & 11]
+	 */
+	else if ((cmd & 0xFF) == IPCMSG_PCNTRL) {
+		if (sub == IPC_CMD_PCNTRL_W && inlen == 11)
+			inlen -= 2;
+		else if (sub == IPC_CMD_PCNTRL_M && inlen == 15)
+			inlen -= 3;
+	}
+	intel_scu_ipc_send_command((inlen << 16) | (sub << 12) | cmd);
 	err = intel_scu_ipc_check_status();
 
-	if (!err) {
-		for (i = 0; i < outlen; i++)
-			*out++ = ipc_data_readl(4 * i);
-	}
+	for (i = 0; i < outlen; i++)
+		*out++ = ipc_data_readl(4 * i);
 
-	mutex_unlock(&ipclock);
 	return err;
 }
-EXPORT_SYMBOL(intel_scu_ipc_command);
-
-/*I2C commands */
-#define IPC_I2C_WRITE 1 /* I2C Write command */
-#define IPC_I2C_READ  2 /* I2C Read command */
+EXPORT_SYMBOL_GPL(intel_scu_ipc_raw_cmd);
 
-/**
- *	intel_scu_ipc_i2c_cntrl		-	I2C read/write operations
- *	@addr: I2C address + command bits
- *	@data: data to read/write
- *
- *	Perform an an I2C read/write operation via the SCU. All locking is
- *	handled for the caller. This function may sleep.
- *
- *	Returns an error code or 0 on success.
- *
- *	This has to be in the IPC driver for the locking.
- */
-int intel_scu_ipc_i2c_cntrl(u32 addr, u32 *data)
+int intel_scu_ipc_command(u32 cmd, u32 sub, u8 *in, u32 inlen,
+		u32 *out, u32 outlen)
 {
-	u32 cmd = 0;
-
-	mutex_lock(&ipclock);
-	if (ipcdev.pdev == NULL) {
-		mutex_unlock(&ipclock);
-		return -ENODEV;
-	}
-	cmd = (addr >> 24) & 0xFF;
-	if (cmd == IPC_I2C_READ) {
-		writel(addr, ipcdev.i2c_base + IPC_I2C_CNTRL_ADDR);
-		/* Write not getting updated without delay */
-		mdelay(1);
-		*data = readl(ipcdev.i2c_base + I2C_DATA_ADDR);
-	} else if (cmd == IPC_I2C_WRITE) {
-		writel(*data, ipcdev.i2c_base + I2C_DATA_ADDR);
-		mdelay(1);
-		writel(addr, ipcdev.i2c_base + IPC_I2C_CNTRL_ADDR);
-	} else {
-		dev_err(&ipcdev.pdev->dev,
-			"intel_scu_ipc: I2C INVALID_CMD = 0x%x\n", cmd);
-
-		mutex_unlock(&ipclock);
-		return -EIO;
-	}
-	mutex_unlock(&ipclock);
-	return 0;
+	int ret;
+	intel_scu_ipc_lock();
+	ret = intel_scu_ipc_raw_cmd(cmd, sub, in, inlen, out, outlen, 0, 0);
+	intel_scu_ipc_unlock();
+	return ret;
 }
-EXPORT_SYMBOL(intel_scu_ipc_i2c_cntrl);
+EXPORT_SYMBOL_GPL(intel_scu_ipc_command);
 
 /*
  * Interrupt handler gets called when ioc bit of IPC_COMMAND_REG set to 1
  * When ioc bit is set to 1, caller api must wait for interrupt handler called
- * which in turn unlocks the caller api. Currently this is not used
+ * which in turn unlocks the caller api.
  *
  * This is edge triggered so we need take no action to clear anything
  */
 static irqreturn_t ioc(int irq, void *dev_id)
 {
-	if (ipcdev.irq_mode)
-		complete(&ipcdev.cmd_complete);
-
+	complete(&ipcdev.cmd_complete);
 	return IRQ_HANDLED;
 }
 
 /**
- *	ipc_probe	-	probe an Intel SCU IPC
+ *	ipc_probe - probe an Intel SCU IPC
  *	@dev: the PCI device matching
  *	@id: entry in the match table
  *
@@ -575,17 +430,17 @@ static irqreturn_t ioc(int irq, void *dev_id)
  */
 static int ipc_probe(struct pci_dev *dev, const struct pci_device_id *id)
 {
-	int err;
+	int err, pid;
 	struct intel_scu_ipc_pdata_t *pdata;
 	resource_size_t pci_resource;
 
 	if (ipcdev.pdev)		/* We support only one SCU */
 		return -EBUSY;
 
-	pdata = (struct intel_scu_ipc_pdata_t *)id->driver_data;
+	pid = id->driver_data;
+	pdata = &intel_scu_ipc_pdata[pid];
 
 	ipcdev.pdev = pci_dev_get(dev);
-	ipcdev.irq_mode = pdata->irq_mode;
 
 	err = pci_enable_device(dev);
 	if (err)
@@ -601,7 +456,8 @@ static int ipc_probe(struct pci_dev *dev, const struct pci_device_id *id)
 
 	init_completion(&ipcdev.cmd_complete);
 
-	if (request_irq(dev->irq, ioc, 0, "intel_scu_ipc", &ipcdev))
+	if (request_irq(dev->irq, ioc, IRQF_NO_SUSPEND, "intel_scu_ipc",
+		&ipcdev))
 		return -EBUSY;
 
 	ipcdev.ipc_base = ioremap_nocache(pdata->ipc_base, pdata->ipc_len);
@@ -620,7 +476,7 @@ static int ipc_probe(struct pci_dev *dev, const struct pci_device_id *id)
 }
 
 /**
- *	ipc_remove	-	remove a bound IPC device
+ *	ipc_remove - remove a bound IPC device
  *	@pdev: PCI device
  *
  *	In practice the SCU is not removable but this function is also
@@ -641,21 +497,11 @@ static void ipc_remove(struct pci_dev *pdev)
 }
 
 static DEFINE_PCI_DEVICE_TABLE(pci_ids) = {
-	{
-		PCI_VDEVICE(INTEL, PCI_DEVICE_ID_LINCROFT),
-		(kernel_ulong_t)&intel_scu_ipc_lincroft_pdata,
-	}, {
-		PCI_VDEVICE(INTEL, PCI_DEVICE_ID_PENWELL),
-		(kernel_ulong_t)&intel_scu_ipc_penwell_pdata,
-	}, {
-		PCI_VDEVICE(INTEL, PCI_DEVICE_ID_CLOVERVIEW),
-		(kernel_ulong_t)&intel_scu_ipc_penwell_pdata,
-	}, {
-		PCI_VDEVICE(INTEL, PCI_DEVICE_ID_TANGIER),
-		(kernel_ulong_t)&intel_scu_ipc_tangier_pdata,
-	}, {
-		0,
-	}
+	{PCI_VDEVICE(INTEL, 0x080e), SCU_IPC_PENWELL},
+	{PCI_VDEVICE(INTEL, 0x082a), SCU_IPC_LINCROFT},
+	{PCI_VDEVICE(INTEL, 0x08ea), SCU_IPC_CLOVERVIEW},
+	{PCI_VDEVICE(INTEL, 0x11a0), SCU_IPC_TANGIER},
+ 	{ 0,}
 };
 MODULE_DEVICE_TABLE(pci, pci_ids);
 
@@ -666,17 +512,27 @@ static struct pci_driver ipc_driver = {
 	.remove = ipc_remove,
 };
 
-
-static int __init intel_scu_ipc_init(void)
+static int intel_scu_ipc_init(void)
 {
 	platform = intel_mid_identify_cpu();
 	if (platform == 0)
 		return -ENODEV;
+
+	qos = kzalloc(sizeof(struct pm_qos_request), GFP_KERNEL);
+	if (!qos)
+		return -ENOMEM;
+
+	pm_qos_add_request(qos, PM_QOS_CPU_DMA_LATENCY, PM_QOS_DEFAULT_VALUE);
+
+	register_pm_notifier(&scu_ipc_pm_notifier);
+
 	return  pci_register_driver(&ipc_driver);
 }
 
 static void __exit intel_scu_ipc_exit(void)
 {
+	pm_qos_remove_request(qos);
+
 	pci_unregister_driver(&ipc_driver);
 }
 
@@ -684,5 +540,5 @@ MODULE_AUTHOR("Sreedhara DS <sreedhara.ds@intel.com>");
 MODULE_DESCRIPTION("Intel SCU IPC driver");
 MODULE_LICENSE("GPL");
 
-module_init(intel_scu_ipc_init);
+fs_initcall(intel_scu_ipc_init);
 module_exit(intel_scu_ipc_exit);
diff --git a/drivers/platform/x86/intel_scu_ipcutil.c b/drivers/platform/x86/intel_scu_ipcutil.c
index 02bc5a6..8d4c96c 100644
--- a/drivers/platform/x86/intel_scu_ipcutil.c
+++ b/drivers/platform/x86/intel_scu_ipcutil.c
@@ -3,6 +3,8 @@
  *
  * (C) Copyright 2008-2010 Intel Corporation
  * Author: Sreedhara DS (sreedhara.ds@intel.com)
+ * (C) Copyright 2010 Intel Corporation
+ * Author: Sudha Krishnakumar (sudha.krishnakumar@intel.com)
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -22,22 +24,420 @@
 #include <linux/uaccess.h>
 #include <linux/slab.h>
 #include <linux/init.h>
+#include <linux/miscdevice.h>
+#include <linux/io.h>
+#include <linux/rpmsg.h>
 #include <asm/intel_scu_ipc.h>
+#include <asm/intel_scu_pmic.h>
+#include <asm/intel_scu_ipcutil.h>
+#include <asm/intel-mid.h>
+#include <asm/intel_mid_rpmsg.h>
+#include <linux/platform_data/intel_mid_remoteproc.h>
+#include <linux/pm_runtime.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
 
-static int major;
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+#endif
 
-/* ioctl commnds */
-#define	INTE_SCU_IPC_REGISTER_READ	0
-#define INTE_SCU_IPC_REGISTER_WRITE	1
-#define INTE_SCU_IPC_REGISTER_UPDATE	2
+#define MAX_FW_SIZE 264192
+
+#define PMIT_RESET1_OFFSET		14
+#define PMIT_RESET2_OFFSET		15
+
+#define IPC_RESIDENCY_CMD_ID_START	0
+#define IPC_RESIDENCY_CMD_ID_DUMP	2
+
+#define SRAM_ADDR_S0IX_RESIDENCY	0xFFFF71E0
+#define ALL_RESIDENCY_DATA_SIZE		12
+
+#define DUMP_OSNIB
+
+#define OSHOB_EXTEND_DESC_SIZE	52  /* OSHOB header+osnib+oem info: 52 bytes.*/
+
+#define OSHOB_HEADER_MAGIC_SIZE	4   /* Size (bytes) of magic number in OSHOB */
+				    /* header.                               */
+
+#define OSHOB_MAGIC_NUMBER	"$OH$"	/* If found when reading the first   */
+					/* 4 bytes of the OSOHB zone, it     */
+					/* means that the new extended OSHOB */
+					/* is going to be used.              */
+
+#define OSHOB_REV_MAJ_DEFAULT	0	/* Default revision number of OSHOB. */
+#define OSHOB_REV_MIN_DEFAULT	1	/* If 0.1 the default OSHOB is used  */
+					/* instead of the extended one.      */
+
+/* Defines for the SCU buffer included in OSHOB structure. */
+#define OSHOB_SCU_BUF_BASE_DW_SIZE	1   /* In dwords. By default SCU     */
+					    /* buffer size is 1 dword.       */
+
+#define OSHOB_SCU_BUF_MRFLD_DW_SIZE (4*OSHOB_SCU_BUF_BASE_DW_SIZE)
+					    /* In dwords. On Merrifield the  */
+					    /* SCU trace buffer size is      */
+					    /* 4 dwords.                     */
+#define OSHOB_DEF_FABRIC_ERR_MRFLD_SIZE   50	/* In DWORDS. For Merrifield.*/
+					/* Fabric error log size (in DWORDS).*/
+					/* From offs 0x44 to 0x10C.          */
+					/* Used in default OSHOB.            */
+
+#define OSNIB_SIZE		32	/* Size (bytes) of the default OSNIB.*/
+
+#define OSNIB_INTEL_RSVD_SIZE	24	/* Size (bytes) of Intel RESERVED in */
+					/* OSNIB.                            */
+#define OSNIB_OEM_RSVD_SIZE	96	/* Size (bytes) of OEM RESERVED      */
+					/* in OSNIB.                         */
+
+#define OSNIB_NVRAM_SIZE	128	/* Size (bytes) of NVRAM             */
+					/* in OSNIB.                         */
+
+#define OSHOB_DEF_FABRIC_ERR_SIZE   50	/* In DWORDS.                        */
+					/* Fabric error log size (in DWORDS).*/
+					/* From offs 0x44 to 0x10C.          */
+					/* Used in default OSHOB.            */
+
+#define OSHOB_FABRIC_ERROR1_SIZE  12    /* 1st part of Fabric error dump.    */
+					/* Used in extended OSHOB.           */
+
+#define OSHOB_FABRIC_ERROR2_SIZE  9     /* 2nd part of Fabric error dump.    */
+					/* Used in extended OSHOB.           */
+
+#define OSHOB_RESERVED_DEBUG_SIZE 5     /* Reserved for debug                */
+
+/* Size (bytes) of the default OSHOB structure. Includes the default OSNIB   */
+/* size.                                                                     */
+#define OSHOB_SIZE	(68 + (4*OSHOB_SCU_BUF_BASE_DW_SIZE) + \
+			    (4*OSHOB_DEF_FABRIC_ERR_SIZE))	/* In bytes. */
+
+#define OSHOB_MRFLD_SIZE (68 + (4*OSHOB_SCU_BUF_MRFLD_DW_SIZE) + \
+			    (4*OSHOB_DEF_FABRIC_ERR_MRFLD_SIZE))/* In bytes. */
+
+/* SCU buffer size is give in dwords. So it is x4 here to get the total      */
+/* number of bytes.                                                          */
+
+#define SCU_TRACE_HEADER_SIZE    16     /* SCU trace header                  */
+
+#define CHAABI_DEBUG_DATA_SIZE   5      /* Reserved for chaabi debug         */
+
+#define OSHOB_RESERVED_SIZE      184    /* Reserved                          */
+
+
+struct chip_reset_event {
+	int id;
+	const char *reset_ev1_name;
+	const char *reset_ev2_name;
+};
+
+static struct chip_reset_event chip_reset_events[] = {
+	{ INTEL_MID_CPU_CHIP_TANGIER, "RESETSRC0", "RESETSRC1" },
+	{ INTEL_MID_CPU_CHIP_CLOVERVIEW, "RESETIRQ1", "RESETIRQ2" },
+	{ INTEL_MID_CPU_CHIP_PENWELL, "RESETIRQ1", "RESETIRQ2" },
+};
+
+struct osnib_target_os {
+	const char *target_os_name;
+	int id;
+};
+
+static struct osnib_target_os osnib_target_oses[] = {
+	{ "main", SIGNED_MOS_ATTR },
+	{ "charging", SIGNED_COS_ATTR  },
+	{ "recovery", SIGNED_RECOVERY_ATTR },
+	{ "fastboot", SIGNED_POS_ATTR },
+	{ "factory", SIGNED_FACTORY_ATTR },
+};
+
+
+struct osnib_wake_src {
+	u8 id;
+	const char *wakesrc_name;
+};
+
+static struct osnib_wake_src osnib_wake_srcs[] = {
+	{ WAKE_BATT_INSERT, "battery inserted" },
+	{ WAKE_PWR_BUTTON_PRESS, "power button pressed" },
+	{ WAKE_RTC_TIMER, "rtc timer" },
+	{ WAKE_USB_CHRG_INSERT, "usb charger inserted" },
+	{ WAKE_RESERVED, "reserved" },
+	{ WAKE_REAL_RESET, "real reset" },
+	{ WAKE_COLD_BOOT, "cold boot" },
+	{ WAKE_UNKNOWN, "unknown" },
+	{ WAKE_KERNEL_WATCHDOG_RESET, "kernel watchdog reset" },
+	{ WAKE_SECURITY_WATCHDOG_RESET, "security watchdog reset" },
+	{ WAKE_WATCHDOG_COUNTER_EXCEEDED, "watchdog counter exceeded" },
+	{ WAKE_POWER_SUPPLY_DETECTED, "power supply detected" },
+	{ WAKE_FASTBOOT_BUTTONS_COMBO, "fastboot combo" },
+	{ WAKE_NO_MATCHING_OSIP_ENTRY, "no matching osip entry" },
+	{ WAKE_CRITICAL_BATTERY, "critical battery" },
+	{ WAKE_INVALID_CHECKSUM, "invalid checksum" },
+	{ WAKE_FORCED_RESET, "forced reset"},
+	{ WAKE_ACDC_CHRG_INSERT, "ac charger inserted" },
+	{ WAKE_PMIC_WATCHDOG_RESET, "pmic watchdog reset" },
+	{ WAKE_PLATFORM_WATCHDOG_RESET, "HWWDT reset platform" },
+	{ WAKE_SC_WATCHDOG_RESET, "HWWDT reset SC" },
+};
+
+
+/* OSNIB allocation. */
+struct scu_ipc_osnib {
+	u8 target_mode;        /* Target mode.                      */
+	u8 wd_count;           /* Software watchdog.                */
+	u8 alarm;              /* RTC alarm.                        */
+	u8 wakesrc;            /* WAKESRC.                          */
+	u8 reset_ev1;          /* RESETIRQ1 or RESETSRC0.           */
+	u8 reset_ev2;          /* RESETIRQ2 or RESETSRC1.           */
+	u8 spare;              /* Spare.                            */
+	u8 intel_reserved[OSNIB_INTEL_RSVD_SIZE]; /* INTEL RESERVED */
+			       /* (offsets 7 to 30).                */
+	u8 checksum;           /* CHECKSUM.                         */
+	u8 oem_reserved[OSNIB_OEM_RSVD_SIZE];     /* OEM RESERVED   */
+			       /* (offsets 32 to 127).              */
+	u8 nvram[OSNIB_NVRAM_SIZE];               /* NVRAM          */
+			       /* (offsets 128 to 255).             */
+};
+
+/* Default OSHOB allocation. */
+struct scu_ipc_oshob {
+	u32 scutxl;             /* SCUTxl offset position.      */
+	u32 iatxl;              /* IATxl offset.                */
+	u32 bocv;               /* BOCV offset.                 */
+	u8 osnibr[OSNIB_SIZE];  /* OSNIB area offset.           */
+	u32 pmit;               /* PMIT offset.                 */
+	u32 pemmcmhki;          /* PeMMCMHKI offset.            */
+	u32 osnibw_ptr;         /* OSNIB Write at offset 0x34.  */
+	u32 fab_err_log[OSHOB_DEF_FABRIC_ERR_SIZE]; /* Fabric   */
+				/* error log buffer.            */
+};
+
+/* Extended OSHOB allocation. version 1.3 */
+struct scu_ipc_oshob_extend {
+	u32 magic;              /* MAGIC number.                           */
+	u8  rev_major;          /* Revision major.                         */
+	u8  rev_minor;          /* Revision minor.                         */
+	u16 oshob_size;         /* OSHOB size.                             */
+	u32 nvram_addr;         /* NVRAM phys addres                       */
+	u32 scutxl;             /* SCUTxl offset position.                 */
+				/* If on MRFLD platform, next param may be */
+				/* shifted by                              */
+				/* (OSHOB_SCU_BUF_MRFLD_DW_SIZE - 1) bytes.*/
+	u32 iatxl;              /* IATxl.                                  */
+	u32 bocv;               /* BOCV.                                   */
+
+	u16 intel_size;         /* Intel size (in OSNIB area).             */
+	u16 oem_size;           /* OEM size (of OEM area).                 */
+	u32 r_intel_ptr;        /* Read Intel pointer.                     */
+	u32 w_intel_ptr;        /* Write Intel pointer.                    */
+	u32 r_oem_ptr;          /* Read OEM pointer.                       */
+	u32 w_oem_ptr;          /* Write OEM pointer.                      */
+
+	u32 pmit;               /* PMIT.                       */
+	u32 pemmcmhki;          /* PeMMCMHKI.                  */
+
+	/* OSHOB as defined for CLOVERVIEW */
+	u32 nvram_size;         /* NVRAM max size in bytes     */
+	u32 fabricerrlog1[OSHOB_FABRIC_ERROR1_SIZE]; /* fabric error data */
+	u8  vrtc_alarm_dow;     /* Alarm sync                  */
+	u8  vrtc_alarm_dom;     /* Alarm sync                  */
+	u8  vrtc_alarm_month;   /* Alarm sync                  */
+	u8  vrtc_alarm_year;    /* Alarm sync                  */
+	u32 reserved_debug[OSHOB_RESERVED_DEBUG_SIZE];/* Reserved Debug data */
+	u32 reserved2;          /* Reserved                    */
+	u32 fabricerrlog2[OSHOB_FABRIC_ERROR2_SIZE]; /* fabric error data2 */
+	u32 sculogbufferaddr;   /* phys addr of scu log buffer   */
+	u32 sculogbuffersize;   /* size of scu log buffer      */
+};
+
+/* Extended OSHOB allocation. version 1.4. */
+struct scu_ipc_oshob_extend_v14 {
+	u32 magic;              /* MAGIC number.                           */
+	u8  rev_major;          /* Revision major.                         */
+	u8  rev_minor;          /* Revision minor.                         */
+	u16 oshob_size;         /* OSHOB size.                             */
+
+	u32 scutxl;             /* SCUTxl offset position.                 */
+				/* If on MRFLD platform, next param may be */
+				/* shifted by                              */
+				/* (OSHOB_SCU_BUF_MRFLD_DW_SIZE - 1) bytes.*/
+	u32 iatxl;              /* IATxl.                                  */
+	u32 bocv;               /* BOCV.                                   */
+
+	u32 osnib_ptr;          /* The unique OSNIB pointer.               */
+
+	u32 pmit;               /* PMIT.                                   */
+	u8  scutraceheader[SCU_TRACE_HEADER_SIZE];   /* SCU trace header   */
+	u32 fabricerrlog[OSHOB_DEF_FABRIC_ERR_SIZE]; /* fabric error data  */
+	u32 chaabidebugdata[CHAABI_DEBUG_DATA_SIZE]; /* fabric error data  */
+	u32 pmuemergency;       /* pmu emergency                           */
+	u32 sculogbufferaddr;   /* scu log buffer address                  */
+	u32 sculogbuffersize;   /* size of scu log buffer                  */
+	u32 oshob_reserved[OSHOB_RESERVED_SIZE];     /* oshob reserved     */
+};
+
+struct scu_ipc_oshob_info {
+	__u32	oshob_base;     /* Base address of OSHOB. Use ioremap to     */
+				/* remap for access.                         */
+	__u8	oshob_majrev;   /* Major revision number of OSHOB structure. */
+	__u8	oshob_minrev;   /* Minor revision number of OSHOB structure. */
+	__u16	oshob_size;     /* Total size (bytes) of OSHOB structure.    */
+	__u32   scu_trace[OSHOB_SCU_BUF_BASE_DW_SIZE*4]; /* SCU trace buffer.*/
+				/* Set to max SCU buffer size (dwords) to    */
+				/* adapt to MRFLD. On other platforms, only  */
+				/* the first dword is stored and read.       */
+	__u32   ia_trace;       /* IA trace buffer.                          */
+	__u16	osnib_size;     /* Total size (bytes) of OSNIB structure.    */
+	__u16	oemnib_size;    /* Total size (bytes) of OEMNIB area.        */
+	__u32	osnibr_ptr;     /* Pointer to Intel read zone.               */
+	__u32	osnibw_ptr;     /* Pointer to Intel write zone.              */
+	__u32	oemnibr_ptr;    /* Pointer to OEM read zone.                 */
+	__u32	oemnibw_ptr;    /* Pointer to OEM write zone.                */
+	__u32   scu_trace_buf;  /* SCU extended trace buffer                 */
+	__u32   scu_trace_size; /* SCU extended trace buffer size            */
+	__u32   nvram_addr;     /* NV ram phys addr                          */
+	__u32   nvram_size;     /* NV ram size in bytes                      */
+
+	int (*scu_ipc_write_osnib)(u8 *data, int len, int offset);
+	int (*scu_ipc_read_osnib)(u8 *data, int len, int offset);
+
+	int platform_type;     /* Identifies the platform (list of supported */
+			       /* platforms is given in intel-mid.h).        */
+
+	u16 offs_add;          /* The additional shift bytes to consider     */
+			       /* giving the offset at which the OSHOB params*/
+			       /* will be read. If MRFLD it must be set to   */
+			       /* take into account the extra SCU dwords.    */
 
-struct scu_ipc_data {
-	u32     count;  /* No. of registers */
-	u16     addr[5]; /* Register addresses */
-	u8      data[5]; /* Register data */
-	u8      mask; /* Valid for read-modify-write */
 };
 
+/* Structure for OSHOB info */
+struct scu_ipc_oshob_info *oshob_info;
+
+static struct rpmsg_instance *ipcutil_instance;
+
+/* Mode for Audio clock */
+static DEFINE_MUTEX(osc_clk0_lock);
+static unsigned int osc_clk0_mode;
+
+int intel_scu_ipc_osc_clk(u8 clk, unsigned int khz)
+{
+	/* SCU IPC COMMAND(osc clk on/off) definition:
+	 * ipc_wbuf[0] = clock to act on {0, 1, 2, 3}
+	 * ipc_wbuf[1] =
+	 * bit 0 - 1:on  0:off
+	 * bit 1 - if 1, read divider setting from bits 3:2 as follows:
+	 * bit [3:2] - 00: clk/1, 01: clk/2, 10: clk/4, 11: reserved
+	 */
+	unsigned int base_freq;
+	unsigned int div;
+	u8 ipc_wbuf[2];
+	int ipc_ret;
+
+	if (clk > 3)
+		return -EINVAL;
+
+	ipc_wbuf[0] = clk;
+	ipc_wbuf[1] = 0;
+	if (khz) {
+#ifdef CONFIG_CTP_CRYSTAL_38M4
+		base_freq = 38400;
+#else
+		base_freq = 19200;
+#endif
+		div = fls(base_freq / khz) - 1;
+		if (div >= 3 || (1 << div) * khz != base_freq)
+			return -EINVAL;	/* Allow only exact frequencies */
+		ipc_wbuf[1] = 0x03 | (div << 2);
+	}
+
+	ipc_ret = rpmsg_send_command(ipcutil_instance,
+		RP_OSC_CLK_CTRL, 0, ipc_wbuf, NULL, 2, 0);
+	if (ipc_ret != 0)
+		pr_err("%s: failed to set osc clk(%d) output\n", __func__, clk);
+
+	return ipc_ret;
+}
+EXPORT_SYMBOL_GPL(intel_scu_ipc_osc_clk);
+
+/*
+ * OSC_CLK_AUDIO is connected to the MSIC as well as Audience, so it should be
+ * turned on if any one of them requests it to be on and it should be turned off
+ * only if no one needs it on.
+ */
+int intel_scu_ipc_set_osc_clk0(unsigned int enable, enum clk0_mode mode)
+{
+	int ret = 0, clk_enable;
+	static const unsigned int clk_khz = 19200;
+
+	pr_info("set_clk0 request %s for Mode 0x%x\n",
+				enable ? "ON" : "OFF", mode);
+	mutex_lock(&osc_clk0_lock);
+	if (mode == CLK0_QUERY) {
+		ret = osc_clk0_mode;
+		goto out;
+	}
+	if (enable) {
+		/* if clock is already on, just add new user */
+		if (osc_clk0_mode) {
+			osc_clk0_mode |= mode;
+			goto out;
+		}
+		osc_clk0_mode |= mode;
+		pr_info("set_clk0: enabling clk, mode 0x%x\n", osc_clk0_mode);
+		clk_enable = 1;
+	} else {
+		osc_clk0_mode &= ~mode;
+		pr_info("set_clk0: disabling clk, mode 0x%x\n", osc_clk0_mode);
+		/* others using the clock, cannot turn it of */
+		if (osc_clk0_mode)
+			goto out;
+		clk_enable = 0;
+	}
+	pr_info("configuring OSC_CLK_AUDIO now\n");
+	ret = intel_scu_ipc_osc_clk(OSC_CLK_AUDIO, clk_enable ? clk_khz : 0);
+out:
+	mutex_unlock(&osc_clk0_lock);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(intel_scu_ipc_set_osc_clk0);
+
+#define MSIC_VPROG1_CTRL        0xD6
+#define MSIC_VPROG2_CTRL        0xD7
+
+#define MSIC_VPROG2_ON          0x36 /*1.200V and Auto mode*/
+#define MSIC_VPROG1_ON          0xF6 /*2.800V and Auto mode*/
+#define MSIC_VPROG_OFF          0x24 /*1.200V and OFF*/
+
+/* Defines specific of MRFLD platform (CONFIG_X86_MRFLD). */
+#define MSIC_VPROG1_MRFLD_CTRL	0xAC
+#define MSIC_VPROG2_MRFLD_CTRL	0xAD
+
+#define MSIC_VPROG1_MRFLD_ON	0xC1	/* 2.80V */
+#define MSIC_VPROG2_MRFLD_ON	0xC1	/* 2.80V */
+#define MSIC_VPROG_MRFLD_OFF	0	/* OFF */
+/* End of MRFLD specific.*/
+
+/* Helpers to turn on/off msic vprog1 and vprog2 */
+int intel_scu_ipc_msic_vprog1(int on)
+{
+	if (oshob_info->platform_type == INTEL_MID_CPU_CHIP_TANGIER)
+		return intel_scu_ipc_iowrite8(MSIC_VPROG1_MRFLD_CTRL,
+			on ? MSIC_VPROG1_MRFLD_ON : MSIC_VPROG_MRFLD_OFF);
+	else
+		return intel_scu_ipc_iowrite8(MSIC_VPROG1_CTRL,
+			on ? MSIC_VPROG1_ON : MSIC_VPROG_OFF);
+}
+EXPORT_SYMBOL_GPL(intel_scu_ipc_msic_vprog1);
+
+int intel_scu_ipc_msic_vprog2(int on)
+{
+	if (oshob_info->platform_type == INTEL_MID_CPU_CHIP_TANGIER)
+		return intel_scu_ipc_iowrite8(MSIC_VPROG2_MRFLD_CTRL,
+			on ? MSIC_VPROG2_MRFLD_ON : MSIC_VPROG_MRFLD_OFF);
+	else
+		return intel_scu_ipc_iowrite8(MSIC_VPROG2_CTRL,
+			on ? MSIC_VPROG2_ON : MSIC_VPROG_OFF);
+}
+EXPORT_SYMBOL_GPL(intel_scu_ipc_msic_vprog2);
+
 /**
  *	scu_reg_access		-	implement register access ioctls
  *	@cmd: command we are doing (read/write/update)
@@ -49,22 +449,169 @@ struct scu_ipc_data {
 
 static int scu_reg_access(u32 cmd, struct scu_ipc_data  *data)
 {
-	int count = data->count;
+	int ret;
 
-	if (count == 0 || count == 3 || count > 4)
+	if (data->count == 0 || data->count > 5)
 		return -EINVAL;
 
 	switch (cmd) {
-	case INTE_SCU_IPC_REGISTER_READ:
-		return intel_scu_ipc_readv(data->addr, data->data, count);
-	case INTE_SCU_IPC_REGISTER_WRITE:
-		return intel_scu_ipc_writev(data->addr, data->data, count);
-	case INTE_SCU_IPC_REGISTER_UPDATE:
-		return intel_scu_ipc_update_register(data->addr[0],
-						    data->data[0], data->mask);
+	case INTEL_SCU_IPC_REGISTER_READ:
+		ret = intel_scu_ipc_readv(data->addr, data->data, data->count);
+		break;
+	case INTEL_SCU_IPC_REGISTER_WRITE:
+		ret = intel_scu_ipc_writev(data->addr, data->data, data->count);
+		break;
+	case INTEL_SCU_IPC_REGISTER_UPDATE:
+		ret = intel_scu_ipc_update_register(data->addr[0],
+							data->data[0],
+							data->mask);
+		break;
 	default:
 		return -ENOTTY;
 	}
+	return ret;
+}
+
+#define check_pmdb_sub_cmd(x)	(x == PMDB_SUB_CMD_R_OTPCTL || \
+		x == PMDB_SUB_CMD_R_WMDB || x == PMDB_SUB_CMD_W_WMDB || \
+		x == PMDB_SUB_CMD_R_OTPDB || x == PMDB_SUB_CMD_W_OTPDB)
+#define pmdb_sub_cmd_is_read(x)	(x == PMDB_SUB_CMD_R_OTPCTL || \
+		x == PMDB_SUB_CMD_R_WMDB || x == PMDB_SUB_CMD_R_OTPDB)
+
+static int check_pmdb_buffer(struct scu_ipc_pmdb_buffer *p_buf)
+{
+	int size;
+
+	switch (p_buf->sub) {
+	case PMDB_SUB_CMD_R_WMDB:
+	case PMDB_SUB_CMD_W_WMDB:
+		size = PMDB_WMDB_SIZE;
+		break;
+	case PMDB_SUB_CMD_R_OTPDB:
+	case PMDB_SUB_CMD_W_OTPDB:
+		size = PMDB_OTPDB_SIZE;
+		break;
+	case PMDB_SUB_CMD_R_OTPCTL:
+		size = PMDB_OTPCTL_SIZE;
+		break;
+	default:
+		size = 0;
+	}
+
+	return check_pmdb_sub_cmd(p_buf->sub) &&
+		(p_buf->count + p_buf->offset < size) &&
+		(p_buf->count % 4 == 0);
+}
+
+/**
+ *	scu_pmdb_access	-	access PMDB data through SCU IPC cmds
+ *	@p_buf: PMDB access buffer, it describe the data to write/read.
+ *		p_buf->sub - SCU IPC sub cmd of PMDB access,
+ *			this sub cmd distinguish different componet
+ *			in PMDB which to be accessd. (WMDB, OTPDB, OTPCTL)
+ *		p_buf->count - access data's count;
+ *		p_buf->offset - access data's offset for each component in PMDB;
+ *		p_buf->data - data to write/read.
+ *
+ *	Write/read data to/from PMDB.
+ *
+ */
+static int scu_pmdb_access(struct scu_ipc_pmdb_buffer *p_buf)
+{
+	int i, offset, ret = -EINVAL;
+	u8 *p_data;
+
+	if (!check_pmdb_buffer(p_buf)) {
+		pr_err("Invalid PMDB buffer!\n");
+		return -EINVAL;
+	}
+
+	/* 1. we use rpmsg_send_raw_command() IPC cmd interface
+	 *    to access PMDB data. Each call of rpmsg_send_raw_command()
+	 *    can only access at most PMDB_ACCESS_SIZE bytes' data.
+	 * 2. There are two kinds of pmdb sub commands, read command
+	 *    and write command. For read command, we must transport
+	 *    in and out buffer to rpmsg_send_raw_command(), because
+	 *    in buffer length is pass as access length which must
+	 *    be transported to SCU.
+	 */
+	p_data = p_buf->data;
+	offset = p_buf->offset;
+	for (i = 0; i < p_buf->count/PMDB_ACCESS_SIZE; i++) {
+		if (pmdb_sub_cmd_is_read(p_buf->sub))
+			ret = rpmsg_send_raw_command(ipcutil_instance,
+					RP_PMDB, p_buf->sub,
+					p_data, (u32 *)p_data,
+					PMDB_ACCESS_SIZE, PMDB_ACCESS_SIZE / 4,
+					0, offset);
+		else
+			ret = rpmsg_send_raw_command(ipcutil_instance,
+					RP_PMDB, p_buf->sub,
+					p_data, NULL, PMDB_ACCESS_SIZE,
+					0, 0, offset);
+		if (ret < 0) {
+			pr_err("intel_scu_ipc_raw_cmd failed!\n");
+			return ret;
+		}
+		offset += PMDB_ACCESS_SIZE;
+		p_data += PMDB_ACCESS_SIZE;
+	}
+	if (p_buf->count % PMDB_ACCESS_SIZE > 0) {
+		if (pmdb_sub_cmd_is_read(p_buf->sub))
+			ret = rpmsg_send_raw_command(ipcutil_instance,
+					RP_PMDB, p_buf->sub,
+					p_data, (u32 *)p_data,
+					p_buf->count % PMDB_ACCESS_SIZE,
+					(p_buf->count % PMDB_ACCESS_SIZE) / 4,
+					0, offset);
+		else
+			ret = rpmsg_send_raw_command(ipcutil_instance,
+					RP_PMDB, p_buf->sub,
+					p_data, NULL,
+					p_buf->count % PMDB_ACCESS_SIZE,
+					0, 0, offset);
+		if (ret < 0) {
+			pr_err("intel_scu_ipc_raw_cmd failed!\n");
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int do_pmdb_user_buf_access(void __user *argp)
+{
+	int ret;
+	struct scu_ipc_pmdb_buffer *p_buf;
+
+	p_buf = kzalloc(sizeof(struct scu_ipc_pmdb_buffer), GFP_KERNEL);
+	if (p_buf == NULL) {
+		pr_err("failed to allocate memory for pmdb buffer!\n");
+		return -ENOMEM;
+	}
+
+	ret = copy_from_user(p_buf, argp, sizeof(struct scu_ipc_pmdb_buffer));
+	if (ret < 0) {
+		pr_err("copy from user failed!!\n");
+		goto err;
+	}
+
+	ret = scu_pmdb_access(p_buf);
+	if (ret < 0) {
+		pr_err("scu_pmdb_access error!\n");
+		goto err;
+	}
+
+	if (pmdb_sub_cmd_is_read(p_buf->sub)) {
+		ret = copy_to_user(argp + 3 * sizeof(u32),
+					p_buf->data, p_buf->count);
+		if (ret < 0)
+			pr_err("copy to user failed!!\n");
+	}
+
+err:
+	kfree(p_buf);
+	return ret;
 }
 
 /**
@@ -78,43 +625,2003 @@ static int scu_reg_access(u32 cmd, struct scu_ipc_data  *data)
 static long scu_ipc_ioctl(struct file *fp, unsigned int cmd,
 							unsigned long arg)
 {
-	int ret;
+	int ret = -EINVAL;
 	struct scu_ipc_data  data;
 	void __user *argp = (void __user *)arg;
 
-	if (!capable(CAP_SYS_RAWIO))
+	/* Only IOCTL cmd allowed to pass through without capability check */
+	/* is getting fw version info, all others need to check to prevent */
+	/* arbitrary access to all sort of bit of the hardware exposed here*/
+
+	if ((cmd != INTEL_SCU_IPC_FW_REVISION_GET &&
+		cmd != INTEL_SCU_IPC_FW_REVISION_EXT_GET &&
+		cmd != INTEL_SCU_IPC_S0IX_RESIDENCY) &&
+		!capable(CAP_SYS_RAWIO))
 		return -EPERM;
 
-	if (copy_from_user(&data, argp, sizeof(struct scu_ipc_data)))
-		return -EFAULT;
-	ret = scu_reg_access(cmd, &data);
+	switch (cmd) {
+	case INTEL_SCU_IPC_S0IX_RESIDENCY:
+	{
+		void __iomem *s0ix_residencies_addr;
+		u8 dump_results[ALL_RESIDENCY_DATA_SIZE] = {0};
+		u32 cmd_id;
+
+		if (copy_from_user(&cmd_id, argp, sizeof(u32))) {
+			pr_err("copy from user failed!!\n");
+			return -EFAULT;
+		}
+
+		/* Check get residency counter valid cmd range */
+
+		if (cmd_id > IPC_RESIDENCY_CMD_ID_DUMP) {
+			pr_err("invalid si0x residency sub-cmd id!\n");
+			return -EINVAL;
+		}
+
+		ret = rpmsg_send_simple_command(ipcutil_instance,
+					RP_S0IX_COUNTER, cmd_id);
+
+		if (ret < 0) {
+			pr_err("ipc_get_s0ix_counter failed!\n");
+			return ret;
+		}
+
+		if (cmd_id == IPC_RESIDENCY_CMD_ID_DUMP) {
+			s0ix_residencies_addr = ioremap_nocache(
+				SRAM_ADDR_S0IX_RESIDENCY,
+				ALL_RESIDENCY_DATA_SIZE);
+
+			if (!s0ix_residencies_addr) {
+				pr_err("ioremap SRAM address failed!!\n");
+				return -EFAULT;
+			}
+
+			memcpy(&dump_results[0], s0ix_residencies_addr,
+				ALL_RESIDENCY_DATA_SIZE);
+
+			iounmap(s0ix_residencies_addr);
+			ret = copy_to_user(argp, &dump_results[0],
+					ALL_RESIDENCY_DATA_SIZE);
+		}
+
+		break;
+	}
+	case INTEL_SCU_IPC_READ_RR_FROM_OSNIB:
+	{
+		u8 reboot_reason;
+		ret = intel_scu_ipc_read_osnib_rr(&reboot_reason);
+		if (ret < 0)
+			return ret;
+		ret = copy_to_user(argp, &reboot_reason, 1);
+		break;
+	}
+	case INTEL_SCU_IPC_WRITE_RR_TO_OSNIB:
+	{
+		u8 data;
+
+		ret = copy_from_user(&data, (u8 *)arg, 1);
+		if (ret < 0) {
+			pr_err("copy from user failed!!\n");
+			return ret;
+		}
+		ret = intel_scu_ipc_write_osnib_rr(data);
+		break;
+	}
+	case INTEL_SCU_IPC_WRITE_ALARM_FLAG_TO_OSNIB:
+	{
+		u8 flag, data;
+		ret = copy_from_user(&flag, (u8 *)arg, 1);
+		if (ret < 0) {
+			pr_err("copy from user failed!!\n");
+			return ret;
+		}
+
+		ret = oshob_info->scu_ipc_read_osnib(
+				&data,
+				1,
+				offsetof(struct scu_ipc_osnib, alarm));
+
+		if (ret < 0)
+			return ret;
+		if (flag) {
+			data = data | 0x1; /* set alarm flag */
+			pr_info("scu_ipc_ioctl: set alarm flag\n");
+		} else {
+			data = data & 0xFE; /* clear alarm flag */
+			pr_info("scu_ipc_ioctl: clear alarm flag\n");
+		}
+
+		ret = oshob_info->scu_ipc_write_osnib(
+				&data,
+				1,
+				offsetof(struct scu_ipc_osnib, alarm));
+
+		break;
+	}
+	case INTEL_SCU_IPC_READ_VBATTCRIT:
+	{
+		u32 value = 0;
+
+		pr_info("cmd = INTEL_SCU_IPC_READ_VBATTCRIT");
+		ret = intel_scu_ipc_read_mip((u8 *)&value, 4, 0x318, 1);
+		if (ret < 0)
+			return ret;
+		pr_info("VBATTCRIT VALUE = %x\n", value);
+		ret = copy_to_user(argp, &value, 4);
+		break;
+	}
+	case INTEL_SCU_IPC_FW_REVISION_GET:
+	case INTEL_SCU_IPC_FW_REVISION_EXT_GET:
+	{
+		struct scu_ipc_version version;
+
+		if (copy_from_user(&version, argp, sizeof(u32)))
+			return -EFAULT;
+
+		if (version.count > 16)
+			return -EINVAL;
+
+		ret = rpmsg_send_command(ipcutil_instance, RP_GET_FW_REVISION,
+			cmd & 0x1, NULL, (u32 *)version.data, 0, 4);
+		if (ret < 0)
+			return ret;
+
+		if (copy_to_user(argp + sizeof(u32),
+					version.data, version.count))
+			ret = -EFAULT;
+		break;
+	}
+	case INTEL_SCU_IPC_OSC_CLK_CNTL:
+	{
+		struct osc_clk_t osc_clk;
+
+		if (copy_from_user(&osc_clk, argp, sizeof(struct osc_clk_t)))
+			return -EFAULT;
+
+		ret = intel_scu_ipc_osc_clk(osc_clk.id, osc_clk.khz);
+		if (ret)
+			pr_err("%s: failed to set osc clk\n", __func__);
+
+		break;
+	}
+	case INTEL_SCU_IPC_PMDB_ACCESS:
+	{
+		ret = do_pmdb_user_buf_access(argp);
+
+		break;
+	}
+	default:
+		if (copy_from_user(&data, argp, sizeof(struct scu_ipc_data)))
+			return -EFAULT;
+		ret = scu_reg_access(cmd, &data);
+		if (ret < 0)
+			return ret;
+		if (copy_to_user(argp, &data, sizeof(struct scu_ipc_data)))
+			return -EFAULT;
+		return 0;
+	}
+
+	return ret;
+}
+
+int intel_scu_ipc_get_oshob_base(void)
+{
+	if (oshob_info == NULL)
+		return NULL;
+
+	return oshob_info->oshob_base;
+}
+EXPORT_SYMBOL_GPL(intel_scu_ipc_get_oshob_base);
+
+int intel_scu_ipc_get_oshob_size(void)
+{
+	if (oshob_info == NULL)
+		return 0;
+
+	return oshob_info->oshob_size;
+}
+EXPORT_SYMBOL_GPL(intel_scu_ipc_get_oshob_size);
+
+int intel_scu_ipc_read_oshob(u8 *data, int len, int offset)
+{
+	int ret = 0, i;
+	void __iomem *oshob_addr;
+	u8 *ptr = data;
+
+	oshob_addr = ioremap_nocache(
+				    oshob_info->oshob_base,
+				    oshob_info->oshob_size);
+
+	if (!oshob_addr) {
+		pr_err("ipc_read_oshob: addr ioremap failed!\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	for (i = 0; i < len; i = i+1) {
+		*ptr = readb(oshob_addr + offset + i);
+		pr_debug("addr(remapped)=%8x, offset=%2x, value=%2x\n",
+			(u32)(oshob_addr + i),
+			offset + i, *ptr);
+		ptr++;
+	}
+
+	iounmap(oshob_addr);
+exit:
+	return ret;
+}
+
+EXPORT_SYMBOL_GPL(intel_scu_ipc_read_oshob);
+
+/* This function is used for the default OSNIB. */
+int intel_scu_ipc_read_osnib(u8 *data, int len, int offset)
+{
+	int i, ret = 0;
+	u32 osnibw_ptr;
+	u8 *ptr, check = 0;
+	u16 struct_offs;
+	void __iomem *oshob_addr, *osnibr_addr, *osnibw_addr;
+
+	pr_debug("OSHOB base addr value is %x\n", oshob_info->oshob_base);
+	oshob_addr = ioremap_nocache(oshob_info->oshob_base,
+				     oshob_info->oshob_size);
+	if (!oshob_addr) {
+		pr_err("ioremap failed!\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	struct_offs = offsetof(struct scu_ipc_oshob, osnibr) +
+			    oshob_info->offs_add;
+	osnibr_addr = oshob_addr + struct_offs;
+
+	if (!osnibr_addr) {
+		pr_err("Bad osnib address!\n");
+		ret = -EFAULT;
+		iounmap(oshob_addr);
+		goto exit;
+	}
+
+	pr_debug("OSNIB read addr (remapped) is %x\n",
+						(unsigned int)osnibr_addr);
+
+	/* Make a chksum verification for osnib */
+	for (i = 0; i < oshob_info->osnib_size; i++)
+		check += readb(osnibr_addr + i);
+	if (check) {
+		pr_err("WARNING!!! osnib chksum verification faild, reset all osnib data!\n");
+		struct_offs = offsetof(struct scu_ipc_oshob, osnibw_ptr) +
+				    oshob_info->offs_add;
+		osnibw_ptr = readl(oshob_addr + struct_offs);
+		osnibw_addr = ioremap_nocache(
+					osnibw_ptr, oshob_info->osnib_size);
+		if (osnibw_addr) {
+			for (i = 0; i < oshob_info->osnib_size; i++)
+				writeb(0, osnibw_addr + i);
+			rpmsg_send_raw_command(ipcutil_instance,
+				RP_WRITE_OSNIB, 0,
+				NULL, NULL, 0, 0,
+				0xFFFFFFFF, 0);
+			iounmap(osnibw_addr);
+		}
+	}
+
+	ptr = data;
+	for (i = 0; i < len; i++) {
+		*ptr = readb(osnibr_addr + offset + i);
+		pr_debug("addr(remapped)=%8x, offset=%2x, value=%2x\n",
+			(u32)(osnibr_addr+offset+i), offset+i, *ptr);
+		ptr++;
+	}
+
+	iounmap(oshob_addr);
+exit:
+	return ret;
+}
+
+/* This function is used for the default OSNIB. */
+int intel_scu_ipc_write_osnib(u8 *data, int len, int offset)
+{
+	int i;
+	int ret = 0;
+	u32 osnibw_ptr;
+	u8 osnib_data[oshob_info->osnib_size];
+	u8 check = 0, chksum = 0;
+	u16 struct_offs;
+	void __iomem *oshob_addr, *osnibw_addr, *osnibr_addr;
+
+	pr_debug("OSHOB base addr value is 0x%8x\n", oshob_info->oshob_base);
+
+	rpmsg_global_lock();
+
+	oshob_addr = ioremap_nocache(oshob_info->oshob_base,
+				     oshob_info->oshob_size);
+	if (!oshob_addr) {
+		pr_err("ioremap failed!\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	/*Dump osnib data for generate chksum */
+	struct_offs = offsetof(struct scu_ipc_oshob, osnibr) +
+			    oshob_info->offs_add;
+	osnibr_addr = oshob_addr + struct_offs;
+
+	pr_debug("OSNIB read addr (remapped) in OSHOB at %x\n",
+						(unsigned int)osnibr_addr);
+
+	for (i = 0; i < oshob_info->osnib_size; i++) {
+		osnib_data[i] = readb(osnibr_addr + i);
+		check += osnib_data[i];
+	}
+	memcpy(osnib_data + offset, data, len);
+
+	if (check) {
+		pr_err("WARNING!!! OSNIB data chksum verification FAILED!\n");
+	} else {
+		/* generate chksum */
+		for (i = 0; i < oshob_info->osnib_size - 1; i++)
+			chksum += osnib_data[i];
+		osnib_data[oshob_info->osnib_size - 1] = ~chksum + 1;
+	}
+
+	struct_offs = offsetof(struct scu_ipc_oshob, osnibw_ptr) +
+			    oshob_info->offs_add;
+	osnibw_ptr = readl(oshob_addr + struct_offs);
+	if (osnibw_ptr == 0) { /* workaround here for BZ 2914 */
+		osnibw_ptr = 0xFFFF3400;
+		pr_err("ERR: osnibw ptr from oshob is 0, manually set it here\n");
+	}
+
+	pr_debug("POSNIB write address: %x\n", osnibw_ptr);
+
+	osnibw_addr = ioremap_nocache(osnibw_ptr, oshob_info->osnib_size);
+	if (!osnibw_addr) {
+		pr_err("ioremap failed!\n");
+		ret = -ENOMEM;
+		goto unmap_oshob_addr;
+	}
+
+	for (i = 0; i < oshob_info->osnib_size; i++)
+		writeb(*(osnib_data + i), (osnibw_addr + i));
+
+	ret = rpmsg_send_raw_command(ipcutil_instance,
+			RP_WRITE_OSNIB, 0,
+			NULL, NULL, 0, 0,
+			0xFFFFFFFF, 0);
 	if (ret < 0)
-		return ret;
-	if (copy_to_user(argp, &data, sizeof(struct scu_ipc_data)))
-		return -EFAULT;
-	return 0;
+		pr_err("ipc_write_osnib failed!!\n");
+
+	iounmap(osnibw_addr);
+
+unmap_oshob_addr:
+	iounmap(oshob_addr);
+exit:
+	rpmsg_global_unlock();
+
+	return ret;
 }
 
-static const struct file_operations scu_ipc_fops = {
-	.unlocked_ioctl = scu_ipc_ioctl,
-};
+/* This function is used for the extended OSHOB/OSNIB. */
+int intel_scu_ipc_read_osnib_extend(u8 *data, int len, int offset)
+{
+	int i, ret = 0;
+	u8 *ptr, check = 0;
+	void __iomem *oshob_addr, *osnibr_addr, *osnibw_addr;
+	u32 sptr_dw_mask;
 
-static int __init ipc_module_init(void)
+	oshob_addr = ioremap_nocache(oshob_info->oshob_base,
+				     oshob_info->oshob_size);
+	if (!oshob_addr) {
+		pr_err("ipc_read_osnib_extend: ioremap failed!\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	pr_debug(
+		"ipc_read_osnib_extend: remap OSNIB addr=0x%x size %d\n",
+		oshob_info->osnibr_ptr, oshob_info->osnib_size);
+
+	osnibr_addr = ioremap_nocache(oshob_info->osnibr_ptr,
+				      oshob_info->osnib_size);
+
+	if (!osnibr_addr) {
+		pr_err("ipc_read_osnib_extend: ioremap of osnib failed!\n");
+		ret = -ENOMEM;
+		goto unmap_oshob_addr;
+	}
+
+	/* Make a chksum verification for osnib */
+	for (i = 0; i < oshob_info->osnib_size; i++)
+		check += readb(osnibr_addr + i);
+
+	if (check) {
+		pr_err("ipc_read_osnib_extend: WARNING!!! osnib chksum verification faild, reset all osnib data!\n");
+		pr_debug(
+			"ipc_read_osnib_extend: remap osnibw ptr addr=0x%x size %d\n",
+			oshob_info->osnibw_ptr, oshob_info->osnib_size);
+
+		osnibw_addr = ioremap_nocache(oshob_info->osnibw_ptr,
+					      oshob_info->osnib_size);
+		if (!osnibw_addr) {
+			pr_err("ipc_read_osnib_extend: cannot remap osnib write ptr\n");
+			goto unmap_oshob_addr;
+		}
+
+		for (i = 0; i < oshob_info->osnib_size; i++)
+			writeb(0, osnibw_addr + i);
+
+		/* Send command. The mask to be written identifies which      */
+		/* double words of the OSNIB osnib_size bytes will be written.*/
+		/* So the mask is coded on 4 bytes.                           */
+		sptr_dw_mask = 0xFFFFFFFF;
+		rpmsg_send_raw_command(ipcutil_instance,
+			RP_WRITE_OSNIB,
+			0, NULL, NULL, 0, 0, sptr_dw_mask, 0);
+		iounmap(osnibw_addr);
+	}
+
+	ptr = data;
+	pr_debug("ipc_read_osnib_extend: OSNIB content:\n");
+	for (i = 0; i < len; i++) {
+		*ptr = readb(osnibr_addr + offset + i);
+		pr_debug("addr(remapped)=%8x, offset=%2x, value=%2x\n",
+			(u32)(osnibr_addr+offset+i), offset+i, *ptr);
+		ptr++;
+	}
+
+	iounmap(osnibr_addr);
+
+unmap_oshob_addr:
+	iounmap(oshob_addr);
+exit:
+	return ret;
+}
+
+/* This function is used for the extended OSHOB/OSNIB. */
+int intel_scu_ipc_write_osnib_extend(u8 *data, int len, int offset)
 {
-	major = register_chrdev(0, "intel_mid_scu", &scu_ipc_fops);
-	if (major < 0)
-		return major;
+	int i;
+	int ret = 0;
+	u8 *posnib_data, *ptr;
+	u8 check = 0, chksum = 0;
+	void __iomem *oshob_addr, *osnibw_addr, *osnibr_addr;
+	u32 sptr_dw_mask;
 
-	return 0;
+	rpmsg_global_lock();
+
+	pr_debug(
+		"ipc_write_osnib_extend: remap OSHOB addr 0x%8x size %d\n",
+		oshob_info->oshob_base, oshob_info->oshob_size);
+
+	oshob_addr = ioremap_nocache(oshob_info->oshob_base,
+				     oshob_info->oshob_size);
+	if (!oshob_addr) {
+		pr_err("ipc_write_osnib_extend: ioremap failed!\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	osnibr_addr = ioremap_nocache(oshob_info->osnibr_ptr,
+				      oshob_info->osnib_size);
+
+	if (!osnibr_addr) {
+		pr_err("ipc_write_osnib_extend: ioremap of osnib failed!\n");
+		ret = -ENOMEM;
+		goto unmap_oshob_addr;
+	}
+
+	/* Dump osnib data for generate chksum */
+	posnib_data = kzalloc(oshob_info->osnib_size, GFP_KERNEL);
+
+	if (posnib_data == NULL) {
+		pr_err("ipc_write_osnib_extend: The buffer for getting OSNIB is NULL\n");
+		ret = -EFAULT;
+		iounmap(osnibr_addr);
+		goto unmap_oshob_addr;
+	}
+
+	ptr = posnib_data;
+	for (i = 0; i < oshob_info->osnib_size; i++) {
+		*ptr = readb(osnibr_addr + i);
+		check += *ptr;
+		ptr++;
+	}
+
+	memcpy(posnib_data + offset, data, len);
+
+	if (check) {
+		pr_err("ipc_write_osnib_extend: WARNING!!! OSNIB data chksum verification FAILED!\n");
+	} else {
+		/* generate chksum.  */
+		pr_debug("ipc_write_osnib_extend: generating checksum\n");
+		for (i = 0; i < oshob_info->osnib_size - 1; i++)
+			chksum += *(posnib_data + i);
+		/* Fill checksum at the CHECKSUM offset place in OSNIB. */
+		*(posnib_data +
+		    offsetof(struct scu_ipc_osnib, checksum)) = ~chksum + 1;
+	}
+
+	pr_debug(
+		"ipc_write_osnib_extend: remap osnibw ptr addr=0x%x size %d\n",
+		oshob_info->osnibw_ptr, oshob_info->osnib_size);
+
+	osnibw_addr = ioremap_nocache(oshob_info->osnibw_ptr,
+				      oshob_info->osnib_size);
+	if (!osnibw_addr) {
+		pr_err("scu_ipc_write_osnib_extend: ioremap failed!\n");
+		ret = -ENOMEM;
+		goto exit_osnib;
+	}
+
+	for (i = 0; i < oshob_info->osnib_size; i++)
+		writeb(*(posnib_data + i), (osnibw_addr + i));
+
+	/* Send command. The mask to be written identifies which            */
+	/* double words of the OSNIB osnib_size bytes will be written.*/
+	/* So the mask is coded on 4 bytes.                                 */
+	sptr_dw_mask = 0xFFFFFFFF;
+	ret = rpmsg_send_raw_command(ipcutil_instance,
+			RP_WRITE_OSNIB, 0, NULL, NULL,
+			0, 0, sptr_dw_mask, 0);
+	if (ret < 0)
+		pr_err("scu_ipc_write_osnib_extend: ipc_write_osnib failed!!\n");
+
+	iounmap(osnibw_addr);
+
+exit_osnib:
+	iounmap(osnibr_addr);
+
+	kfree(posnib_data);
+
+unmap_oshob_addr:
+	iounmap(oshob_addr);
+exit:
+	rpmsg_global_unlock();
+
+	return ret;
+}
+
+/*
+ * This writes the reboot reason in the OSNIB (factor and avoid any overlap)
+ */
+int intel_scu_ipc_write_osnib_rr(u8 rr)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(osnib_target_oses); i++) {
+		if (osnib_target_oses[i].id == rr) {
+			pr_info("intel_scu_ipc_write_osnib_rr: reboot reason: %s\n",
+				osnib_target_oses[i].target_os_name);
+			return oshob_info->scu_ipc_write_osnib(
+				&rr,
+				1,
+				offsetof(struct scu_ipc_osnib, target_mode));
+		}
+	}
+
+	pr_warn("intel_scu_ipc_write_osnib_rr: reboot reason [0x%x] not found\n",
+			rr);
+	return -1;
+}
+EXPORT_SYMBOL_GPL(intel_scu_ipc_write_osnib_rr);
+
+/*
+ * This reads the reboot reason from the OSNIB (factor)
+ */
+int intel_scu_ipc_read_osnib_rr(u8 *rr)
+{
+	pr_debug("intel_scu_ipc_read_osnib_rr: read reboot reason\n");
+	return oshob_info->scu_ipc_read_osnib(
+			rr,
+			1,
+			offsetof(struct scu_ipc_osnib, target_mode));
+}
+EXPORT_SYMBOL_GPL(intel_scu_ipc_read_osnib_rr);
+
+
+int intel_scu_ipc_read_oshob_extend_param(void __iomem *poshob_addr)
+{
+	u16 struct_offs;
+	int buff_size;
+
+	/* Get defined OSNIB space size. */
+	oshob_info->osnib_size = readw(
+			    poshob_addr +
+			    offsetof(struct scu_ipc_oshob_extend, intel_size));
+
+	if (oshob_info->osnib_size == 0) {
+		pr_err("ipc_read_oshob_extend_param: OSNIB size is null!\n");
+		return -EFAULT;
+	}
+
+	/* Get defined OEM space size. */
+	oshob_info->oemnib_size = readw(
+			    poshob_addr +
+			    offsetof(struct scu_ipc_oshob_extend, oem_size));
+
+	if (oshob_info->oemnib_size == 0) {
+		pr_err("ipc_read_oshob_extend_param: OEMNIB size is null!\n");
+		return -EFAULT;
+	}
+
+	/* Set SCU and IA trace buffers. Size calculated in bytes here. */
+	if (oshob_info->platform_type == INTEL_MID_CPU_CHIP_TANGIER)
+		buff_size = OSHOB_SCU_BUF_MRFLD_DW_SIZE*4;
+	else
+		buff_size = OSHOB_SCU_BUF_BASE_DW_SIZE*4;
+
+	intel_scu_ipc_read_oshob(
+		(u8 *)(oshob_info->scu_trace),
+		buff_size,
+		offsetof(struct scu_ipc_oshob_extend, scutxl));
+
+	struct_offs = offsetof(struct scu_ipc_oshob_extend, iatxl) +
+			    oshob_info->offs_add;
+	oshob_info->ia_trace = readl(poshob_addr + struct_offs);
+
+	/* Set pointers */
+	struct_offs = offsetof(struct scu_ipc_oshob_extend, r_intel_ptr) +
+			    oshob_info->offs_add;
+	oshob_info->osnibr_ptr = readl(poshob_addr + struct_offs);
+
+	if (!oshob_info->osnibr_ptr) {
+		pr_err("ipc_read_oshob_extend_param: R_INTEL_POINTER is NULL!\n");
+		return -ENOMEM;
+	}
+
+	struct_offs = offsetof(struct scu_ipc_oshob_extend, w_intel_ptr) +
+			    oshob_info->offs_add;
+	oshob_info->osnibw_ptr = readl(poshob_addr + struct_offs);
+
+	if (oshob_info->osnibw_ptr == 0) {
+		/* workaround here for BZ 2914 */
+		oshob_info->osnibw_ptr = 0xFFFF3400;
+		pr_err(
+		    "ipc_read_oshob_extend_param: ERR: osnibw from oshob is 0, manually set it here\n");
+	}
+
+	pr_info("(extend oshob) osnib read ptr = 0x%8x\n",
+			oshob_info->osnibr_ptr);
+	pr_info("(extend oshob) osnib write ptr = 0x%8x\n",
+			oshob_info->osnibw_ptr);
+
+	struct_offs = offsetof(struct scu_ipc_oshob_extend, r_oem_ptr) +
+			    oshob_info->offs_add;
+	oshob_info->oemnibr_ptr = readl(poshob_addr + struct_offs);
+
+	if (!oshob_info->oemnibr_ptr) {
+		pr_err("ipc_read_oshob_extend_param: R_OEM_POINTER is NULL!\n");
+		return -ENOMEM;
+	}
+
+	struct_offs = offsetof(struct scu_ipc_oshob_extend, w_oem_ptr) +
+			    oshob_info->offs_add;
+	oshob_info->oemnibw_ptr = readl(poshob_addr + struct_offs);
+
+	if (!oshob_info->oemnibw_ptr) {
+		pr_err("ipc_read_oshob_extend_param: W_OEM_POINTER is NULL!\n");
+		return -ENOMEM;
+	}
+
+	oshob_info->scu_ipc_write_osnib =
+					&intel_scu_ipc_write_osnib_extend;
+	oshob_info->scu_ipc_read_osnib =
+					&intel_scu_ipc_read_osnib_extend;
+
+	pr_info(
+		"Using extended oshob structure size = %d bytes\n",
+		oshob_info->oshob_size);
+	pr_info(
+		"OSNIB Intel size = %d bytes OEMNIB size = %d bytes\n",
+		oshob_info->osnib_size, oshob_info->oemnib_size);
+
+	if (oshob_info->platform_type == INTEL_MID_CPU_CHIP_CLOVERVIEW) {
+		if ((oshob_info->oshob_majrev >= 1) &&
+		    (oshob_info->oshob_minrev >= 1)) {
+			/* CLVP and correct version of the oshob. */
+			oshob_info->scu_trace_buf =
+				readl(poshob_addr +
+				      offsetof(struct scu_ipc_oshob_extend,
+					       sculogbufferaddr));
+			oshob_info->scu_trace_size =
+				readl(poshob_addr +
+				      offsetof(struct scu_ipc_oshob_extend,
+					       sculogbuffersize));
+		}
+		if ((oshob_info->oshob_majrev >= 1) &&
+		    (oshob_info->oshob_minrev >= 3)) {
+			/* CLVP and correct version of the oshob. */
+			oshob_info->nvram_addr =
+				readl(poshob_addr +
+				      offsetof(struct scu_ipc_oshob_extend,
+					       nvram_addr));
+			oshob_info->nvram_size =
+				readl(poshob_addr +
+				      offsetof(struct scu_ipc_oshob_extend,
+					       nvram_size));
+		}
+	}
+	return 0;
+}
+
+int intel_scu_ipc_read_oshob_extend_param_v14(void __iomem *poshob_addr)
+{
+	u16 struct_offs;
+	int buff_size;
+
+	/* set intel OSNIB space size. */
+	oshob_info->osnib_size = OSNIB_SIZE;
+
+	/* set OEM OSNIB space size. */
+	oshob_info->oemnib_size = OSNIB_OEM_RSVD_SIZE;
+
+	/* Set SCU and IA trace buffers. Size calculated in bytes here. */
+	if (oshob_info->platform_type == INTEL_MID_CPU_CHIP_TANGIER)
+		buff_size = OSHOB_SCU_BUF_MRFLD_DW_SIZE*4;
+	else
+		buff_size = OSHOB_SCU_BUF_BASE_DW_SIZE*4;
+
+	intel_scu_ipc_read_oshob(
+		(u8 *)(oshob_info->scu_trace),
+		buff_size,
+		offsetof(struct scu_ipc_oshob_extend_v14, scutxl));
+
+	struct_offs = offsetof(struct scu_ipc_oshob_extend_v14, iatxl) +
+			    oshob_info->offs_add;
+	oshob_info->ia_trace = readl(poshob_addr + struct_offs);
+
+	/* Set pointers */
+	struct_offs = offsetof(struct scu_ipc_oshob_extend_v14, osnib_ptr) +
+			    oshob_info->offs_add;
+	oshob_info->osnibr_ptr = readl(poshob_addr + struct_offs);
+
+	if (!oshob_info->osnibr_ptr) {
+		pr_err("ipc_read_oshob_extend_param_v14: R_INTEL_POINTER is NULL!\n");
+		return -ENOMEM;
+	}
+
+	/* write and read pointer are the same */
+	oshob_info->osnibw_ptr = oshob_info->osnibr_ptr;
+
+	pr_info("(latest extend oshob) osnib ptr = 0x%8x\n",
+		oshob_info->osnibr_ptr);
+
+	/* OEM NIB point at offset OSNIB_SIZE */
+	oshob_info->oemnibr_ptr = oshob_info->osnibr_ptr + OSNIB_SIZE;
+
+	/* write and read pinter are the same */
+	oshob_info->oemnibw_ptr = oshob_info->oemnibr_ptr;
+
+	/* we use tha same function for all extended OSHOB structure */
+	oshob_info->scu_ipc_write_osnib =
+					&intel_scu_ipc_write_osnib_extend;
+	oshob_info->scu_ipc_read_osnib =
+					&intel_scu_ipc_read_osnib_extend;
+
+	pr_info(
+		"Using latest extended oshob structure size = %d bytes\n",
+		oshob_info->oshob_size);
+	pr_info(
+		"OSNIB Intel size = %d bytes OEMNIB size = %d bytes\n",
+		oshob_info->osnib_size, oshob_info->oemnib_size);
+
+	struct_offs = offsetof(struct scu_ipc_oshob_extend_v14,
+			    sculogbufferaddr) + oshob_info->offs_add;
+	oshob_info->scu_trace_buf = readl(poshob_addr + struct_offs);
+
+	struct_offs = offsetof(struct scu_ipc_oshob_extend_v14,
+			    sculogbuffersize) + oshob_info->offs_add;
+	oshob_info->scu_trace_size = readl(poshob_addr + struct_offs);
+
+	/* NVRAM after Intel and OEM OSNIB */
+	oshob_info->nvram_addr = oshob_info->oemnibr_ptr + OSNIB_OEM_RSVD_SIZE;
+	oshob_info->nvram_size = OSNIB_NVRAM_SIZE;
+
+	return 0;
+}
+
+int intel_scu_ipc_read_oshob_def_param(void __iomem *poshob_addr)
+{
+	u16 struct_offs;
+	int ret = 0;
+	int buff_size;
+
+	oshob_info->oshob_majrev = OSHOB_REV_MAJ_DEFAULT;
+	oshob_info->oshob_minrev = OSHOB_REV_MIN_DEFAULT;
+	oshob_info->osnib_size = OSNIB_SIZE;
+	oshob_info->oemnib_size = 0;
+
+	/* Set OSHOB total size */
+	if (oshob_info->platform_type == INTEL_MID_CPU_CHIP_TANGIER)
+		oshob_info->oshob_size = OSHOB_MRFLD_SIZE;
+	else
+		oshob_info->oshob_size = OSHOB_SIZE;
+
+	/* Set SCU and IA trace buffers. Size calculated in bytes here. */
+	if (oshob_info->platform_type == INTEL_MID_CPU_CHIP_TANGIER)
+		buff_size = OSHOB_SCU_BUF_MRFLD_DW_SIZE*4;
+	else
+		buff_size = OSHOB_SCU_BUF_BASE_DW_SIZE*4;
+
+	ret = intel_scu_ipc_read_oshob(
+		(u8 *)(oshob_info->scu_trace),
+		buff_size,
+		offsetof(struct scu_ipc_oshob, scutxl));
+
+	if (ret != 0) {
+		pr_err("Cannot get scutxl data from OSHOB\n");
+		return ret;
+	}
+
+	struct_offs = offsetof(struct scu_ipc_oshob, iatxl) +
+			    oshob_info->offs_add;
+	oshob_info->ia_trace = readl(poshob_addr + struct_offs);
+
+	oshob_info->scu_ipc_write_osnib =
+					&intel_scu_ipc_write_osnib;
+	oshob_info->scu_ipc_read_osnib =
+					&intel_scu_ipc_read_osnib;
+
+	struct_offs = offsetof(struct scu_ipc_oshob, osnibr) +
+			    oshob_info->offs_add;
+	oshob_info->osnibr_ptr = (unsigned long)(poshob_addr + struct_offs);
+
+	pr_info("Using default oshob structure size = %d bytes\n",
+					oshob_info->oshob_size);
+
+	pr_debug("Using default oshob structure OSNIB read ptr %x\n",
+		oshob_info->osnibr_ptr);
+
+	return ret;
+}
+
+int intel_scu_ipc_read_oshob_info(void)
+{
+	int i, ret = 0;
+	u32 oshob_base = 0;
+	void __iomem *oshob_addr;
+	unsigned char oshob_magic[4];
+
+	ret = rpmsg_send_command(ipcutil_instance,
+		RP_GET_HOBADDR, 0, NULL, &oshob_base, 0, 1);
+
+	if (ret < 0) {
+		pr_err("ipc_read_oshob cmd failed!!\n");
+		goto exit;
+	}
+
+	/* At this stage, we still don't know which OSHOB type (default or  */
+	/* extended) can be used, and the size of resource to be remapped   */
+	/* depends on the type of OSHOB structure to be used.               */
+	/* So just remap the minimum size to get the needed bytes of the    */
+	/* OSHOB zone.                                                      */
+	oshob_addr = ioremap_nocache(oshob_base, OSHOB_EXTEND_DESC_SIZE);
+
+	if (!oshob_addr) {
+		pr_err("oshob addr ioremap failed!\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	pr_info("(oshob) base addr = 0x%8x\n", oshob_base);
+
+	/* Store base address. */
+	oshob_info->oshob_base = oshob_base;
+
+	oshob_info->platform_type = intel_mid_identify_cpu();
+
+	/*
+	 * Buffer is allocated using kmalloc. Memory is not initialized and
+	 * these fields are not updated in all the branches.
+	 */
+	oshob_info->scu_trace_buf = 0;
+	oshob_info->scu_trace_size = 0;
+	oshob_info->nvram_addr = 0;
+	oshob_info->nvram_size = 0;
+
+	if (oshob_info->platform_type == INTEL_MID_CPU_CHIP_TANGIER) {
+		pr_info("(oshob) identified platform = INTEL_MID_CPU_CHIP_TANGIER\n");
+
+		/* By default we already have 1 dword reserved in the OSHOB */
+		/* structures for SCU buffer. For Merrifield, SCU size to   */
+		/* consider is OSHOB_SCU_BUF_MRFLD_DW_SIZE dwords. So with  */
+		/* Merrifield, when calculating structures offsets, we have */
+		/* to add (OSHOB_SCU_BUF_MRFLD_DW_SIZE - 1) dwords, with    */
+		/* the offsets calculated in bytes.                         */
+		oshob_info->offs_add = (OSHOB_SCU_BUF_MRFLD_DW_SIZE - 1)*4;
+	} else
+		oshob_info->offs_add = 0;
+
+	pr_debug("(oshob) additional offset = 0x%x\n", oshob_info->offs_add);
+
+	/* Extract magic number that will help identifying the good OSHOB  */
+	/* that is going to be used.                                       */
+	for (i = 0; i < OSHOB_HEADER_MAGIC_SIZE; i = i+1)
+		oshob_magic[i] = readb(oshob_addr + i);
+
+	pr_debug("(oshob) OSHOB magic = %x %x %x %x\n",
+		oshob_magic[0], oshob_magic[1], oshob_magic[2], oshob_magic[3]);
+
+	if (strncmp(oshob_magic, OSHOB_MAGIC_NUMBER,
+		    OSHOB_HEADER_MAGIC_SIZE) == 0) {
+		/* Get OSHOB version and size which are commoon to all */
+		/* extended OSHOB structure. */
+		oshob_info->oshob_majrev = readb(oshob_addr +
+			offsetof(struct scu_ipc_oshob_extend, rev_major));
+		oshob_info->oshob_minrev = readb(oshob_addr +
+			offsetof(struct scu_ipc_oshob_extend, rev_minor));
+		oshob_info->oshob_size = readw(oshob_addr +
+			offsetof(struct scu_ipc_oshob_extend, oshob_size));
+
+		pr_info("(oshob) oshob version = %x.%x\n",
+			oshob_info->oshob_majrev, oshob_info->oshob_minrev);
+
+		if ((oshob_info->oshob_majrev >= 1) &&
+		    (oshob_info->oshob_minrev >= 4)) {
+			if (intel_scu_ipc_read_oshob_extend_param_v14(
+					oshob_addr) != 0) {
+				ret = -EFAULT;
+				goto unmap_oshob;
+			}
+		} else {
+			if (intel_scu_ipc_read_oshob_extend_param(
+					oshob_addr) != 0) {
+				ret = -EFAULT;
+				goto unmap_oshob;
+			}
+		}
+
+		if (oshob_info->platform_type == INTEL_MID_CPU_CHIP_TANGIER) {
+			pr_info("(extend oshob) SCU buffer size is %d bytes\n",
+				OSHOB_SCU_BUF_MRFLD_DW_SIZE*4);
+		} else {
+			pr_debug("(extend oshob) SCU buffer size is %d bytes\n",
+				OSHOB_SCU_BUF_BASE_DW_SIZE*4);
+		}
+	} else {
+		ret = intel_scu_ipc_read_oshob_def_param(oshob_addr);
+
+		if (oshob_info->platform_type == INTEL_MID_CPU_CHIP_TANGIER) {
+			pr_debug("(default oshob) SCU buffer size is %d bytes\n",
+				OSHOB_SCU_BUF_MRFLD_DW_SIZE*4);
+		} else {
+			pr_debug("(default oshob) SCU buffer size is %d bytes\n",
+				OSHOB_SCU_BUF_BASE_DW_SIZE*4);
+		}
+	}
+
+unmap_oshob:
+	iounmap(oshob_addr);
+
+exit:
+	return ret;
+}
+
+/*
+ * This writes the OEMNIB buffer in the internal RAM of the SCU.
+ */
+int intel_scu_ipc_write_oemnib(u8 *oemnib, int len, int offset)
+{
+	int i;
+	int ret = 0;
+	void __iomem *oshob_addr, *oemnibw_addr;
+	u32 sptr_dw_mask;
+
+	if (oemnib == NULL) {
+		pr_err("ipc_write_oemnib: passed buffer for writting OEMNIB is NULL\n");
+		return -EINVAL;
+	}
+
+	rpmsg_global_lock();
+
+	pr_debug("ipc_write_oemnib: remap OSHOB addr 0x%8x size %d\n",
+		oshob_info->oshob_base, oshob_info->oshob_size);
+
+	oshob_addr = ioremap_nocache(oshob_info->oshob_base,
+				     oshob_info->oshob_size);
+	if (!oshob_addr) {
+		pr_err("ipc_write_oemnib: ioremap failed!\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	if ((len == 0) || (len > oshob_info->oemnib_size)) {
+		pr_err(
+			"ipc_write_oemnib: bad OEMNIB data length (%d) to write (max=%d bytes)\n",
+			    len, oshob_info->oemnib_size);
+		ret = -EINVAL;
+		goto unmap_oshob_addr;
+	}
+
+	/* offset shall start at 0 from the OEMNIB base address and shall */
+	/* not exceed the OEMNIB allowed size.                            */
+	if ((offset < 0) || (offset >= oshob_info->oemnib_size) ||
+	    (len + offset > oshob_info->oemnib_size)) {
+		pr_err(
+			"ipc_write_oemnib: Bad OEMNIB data offset/len for writing (offset=%d , len=%d)\n",
+			offset, len);
+		ret = -EINVAL;
+		goto unmap_oshob_addr;
+	}
+
+	pr_debug("ipc_write_oemnib: POEMNIB remap oemnibw ptr 0x%x size %d\n",
+		oshob_info->oemnibw_ptr, oshob_info->oemnib_size);
+
+	oemnibw_addr = ioremap_nocache(oshob_info->oemnibw_ptr,
+				       oshob_info->oemnib_size);
+	if (!oemnibw_addr) {
+		pr_err("ipc_write_oemnib: ioremap failed!\n");
+		ret = -ENOMEM;
+		goto unmap_oshob_addr;
+	}
+
+	for (i = 0; i < len; i++)
+		writeb(*(oemnib + i), (oemnibw_addr + offset + i));
+
+	/* Send command. The mask to be written identifies which double */
+	/* words of the OSNIB oemnib_size bytes will be written.        */
+	/* So the mask is coded on 4 bytes.                             */
+	sptr_dw_mask = 0xFFFFFFFF;
+	if ((oshob_info->oshob_majrev >= 1) &&
+	    (oshob_info->oshob_minrev >= 4)) {
+		sptr_dw_mask = 0xFFFFFFFF;
+		/* OEM NIB lies on region 1, 2, and 3 */
+		ret = rpmsg_send_raw_command(ipcutil_instance,
+			RP_WRITE_OSNIB, 0, NULL, NULL,
+			0, 0, sptr_dw_mask, 1);
+		if (ret < 0) {
+			pr_err("ipc_write_oemnib: ipc_write_osnib failed!!\n");
+			goto unmap_oemnibw_addr;
+		}
+		ret = rpmsg_send_raw_command(ipcutil_instance,
+			RP_WRITE_OSNIB, 0, NULL, NULL,
+			0, 0, sptr_dw_mask, 2);
+		if (ret < 0) {
+			pr_err("ipc_write_oemnib: ipc_write_osnib failed!!\n");
+			goto unmap_oemnibw_addr;
+		}
+		ret = rpmsg_send_raw_command(ipcutil_instance,
+			RP_WRITE_OSNIB, 0, NULL, NULL,
+			0, 0, sptr_dw_mask, 3);
+		if (ret < 0) {
+			pr_err("ipc_write_oemnib: ipc_write_osnib failed!!\n");
+			goto unmap_oemnibw_addr;
+		}
+	} else {
+		ret = rpmsg_send_raw_command(ipcutil_instance,
+			RP_WRITE_OEMNIB, 0, NULL, NULL,
+			0, 0, sptr_dw_mask, 0);
+		if (ret < 0) {
+			pr_err("ipc_write_oemnib: ipc_write_osnib failed!!\n");
+			goto unmap_oemnibw_addr;
+		}
+	}
+
+unmap_oemnibw_addr:
+	iounmap(oemnibw_addr);
+
+unmap_oshob_addr:
+	iounmap(oshob_addr);
+exit:
+	rpmsg_global_unlock();
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(intel_scu_ipc_write_oemnib);
+
+/*
+ * This reads the OEMNIB from the internal RAM of the SCU.
+ */
+static int intel_scu_ipc_read_oemnib(u8 *oemnib, int len, int offset)
+{
+	int i, ret = 0;
+	u8 *ptr;
+	void __iomem *oshob_addr, *oemnibr_addr;
+
+	if (oemnib == NULL) {
+		pr_err("ipc_read_oemnib: passed buffer for reading OEMNIB is NULL\n");
+		return -EINVAL;
+	}
+
+	pr_debug("ipc_read_oemnib: remap OSHOB base addr 0x%x size %d\n",
+		oshob_info->oshob_base, oshob_info->oshob_size);
+
+	oshob_addr = ioremap_nocache(oshob_info->oshob_base,
+				     oshob_info->oshob_size);
+	if (!oshob_addr) {
+		pr_err("ipc_read_oemnib: ioremap failed!\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	if ((len == 0) || (len > oshob_info->oemnib_size)) {
+		pr_err("ipc_read_oemnib: Bad OEMNIB data length (%d) to be read (max=%d bytes)\n",
+			    len, oshob_info->oemnib_size);
+		ret = -EINVAL;
+		goto unmap_oshob_addr;
+	}
+
+	/* offset shall start at 0 from the OEMNIB base address and shall */
+	/* not exceed the OEMNIB allowed size.                            */
+	if ((offset < 0) || (offset >= oshob_info->oemnib_size) ||
+	    (len + offset > oshob_info->oemnib_size)) {
+		pr_err(
+		"ipc_read_oemnib: Bad OEMNIB data offset/len to read (offset=%d ,len=%d)\n",
+		offset, len);
+		ret = -EINVAL;
+		goto unmap_oshob_addr;
+	}
+
+	pr_debug("ipc_read_oemnib: POEMNIB remap oemnibr ptr 0x%x size %d\n",
+		oshob_info->oemnibr_ptr, oshob_info->oemnib_size);
+
+	oemnibr_addr = ioremap_nocache(oshob_info->oemnibr_ptr,
+				       oshob_info->oemnib_size);
+
+	if (!oemnibr_addr) {
+		pr_err("ipc_read_oemnib: ioremap of oemnib failed!\n");
+		ret = -ENOMEM;
+		goto unmap_oshob_addr;
+	}
+
+	ptr = oemnib;
+	pr_debug("ipc_read_oemnib: OEMNIB content:\n");
+	for (i = 0; i < len; i++) {
+		*ptr = readb(oemnibr_addr + offset + i);
+		pr_debug("addr(remapped)=%8x, offset=%2x, value=%2x\n",
+			(u32)(oemnibr_addr+offset+i), offset+i, *ptr);
+		ptr++;
+	}
+
+	iounmap(oemnibr_addr);
+
+unmap_oshob_addr:
+	iounmap(oshob_addr);
+exit:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(intel_scu_ipc_read_oemnib);
+
+#ifdef DUMP_OSNIB
+/*
+ * This reads the PMIT from the OSHOB (pointer to interrupt tree)
+ */
+static int intel_scu_ipc_read_oshob_it_tree(u32 *ptr)
+{
+	u16 struct_offs;
+
+	pr_debug("intel_scu_ipc_read_oshob_it_tree: read IT tree\n");
+
+	if ((oshob_info->oshob_majrev == OSHOB_REV_MAJ_DEFAULT) &&
+	    (oshob_info->oshob_minrev == OSHOB_REV_MIN_DEFAULT)) {
+		struct_offs = offsetof(struct scu_ipc_oshob, pmit) +
+				    oshob_info->offs_add;
+	} else if ((oshob_info->oshob_majrev >= 1) &&
+		   (oshob_info->oshob_minrev >= 4)) {
+		struct_offs = offsetof(struct scu_ipc_oshob_extend_v14, pmit) +
+				    oshob_info->offs_add;
+	} else {
+		struct_offs = offsetof(struct scu_ipc_oshob_extend, pmit) +
+				    oshob_info->offs_add;
+	}
+	return intel_scu_ipc_read_oshob(
+			(u8 *) ptr,
+			4,
+			struct_offs);
+}
+#endif
+
+/*
+ * This reads the RESETIRQ1 or RESETSRC0 from the OSNIB
+ */
+#ifdef DUMP_OSNIB
+static int intel_scu_ipc_read_osnib_reset_ev1(u8 *rev1)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(chip_reset_events); i++) {
+		if (chip_reset_events[i].id == oshob_info->platform_type) {
+			pr_debug(
+				"intel_scu_ipc_read_osnib_rst_ev1: read %s\n",
+				chip_reset_events[i].reset_ev1_name);
+
+			return oshob_info->scu_ipc_read_osnib(
+				    rev1,
+				    1,
+				    offsetof(struct scu_ipc_osnib, reset_ev1));
+		}
+	}
+
+	pr_err("intel_scu_ipc_read_osnib_reset_ev1: param not found\n");
+	return -EFAULT;
+}
+#endif
+
+/*
+ * This reads the RESETIRQ2 or RESETSRC1 from the OSNIB
+ */
+#ifdef DUMP_OSNIB
+static int intel_scu_ipc_read_osnib_reset_ev2(u8 *rev2)
+{
+	int i;
+
+	for (i = 0 ; i < ARRAY_SIZE(chip_reset_events); i++) {
+		if (chip_reset_events[i].id == oshob_info->platform_type) {
+			pr_debug(
+				"intel_scu_ipc_read_osnib_rst_ev2: read %s\n",
+				chip_reset_events[i].reset_ev2_name);
+
+			return oshob_info->scu_ipc_read_osnib(
+				rev2,
+				1,
+				offsetof(struct scu_ipc_osnib, reset_ev2));
+		}
+	}
+
+	pr_err("intel_scu_ipc_read_osnib_reset_ev2: param not found\n");
+	return -EFAULT;
+}
+#endif
+
+/*
+ * This reads the WD from the OSNIB
+ */
+int intel_scu_ipc_read_osnib_wd(u8 *wd)
+{
+	pr_debug("intel_scu_ipc_read_osnib_wd: read WATCHDOG\n");
+
+	return oshob_info->scu_ipc_read_osnib(
+			wd,
+			1,
+			offsetof(struct scu_ipc_osnib, wd_count));
+}
+
+/*
+ * This writes the WD in the OSNIB
+ */
+int intel_scu_ipc_write_osnib_wd(u8 *wd)
+{
+	pr_info("intel_scu_ipc_write_osnib_wd: write WATCHDOG %x\n", *wd);
+
+	return oshob_info->scu_ipc_write_osnib(
+			wd,
+			1,
+			offsetof(struct scu_ipc_osnib, wd_count));
+}
+EXPORT_SYMBOL_GPL(intel_scu_ipc_write_osnib_wd);
+
+/*
+ * Get SCU trace buffer physical address if available
+ */
+u32 intel_scu_ipc_get_scu_trace_buffer(void)
+{
+	if (oshob_info == NULL)
+		return 0;
+	return oshob_info->scu_trace_buf;
+}
+EXPORT_SYMBOL_GPL(intel_scu_ipc_get_scu_trace_buffer);
+
+/*
+ * Get SCU trace buffer size
+ */
+u32 intel_scu_ipc_get_scu_trace_buffer_size(void)
+{
+	if (oshob_info == NULL)
+		return 0;
+	return oshob_info->scu_trace_size;
+}
+EXPORT_SYMBOL_GPL(intel_scu_ipc_get_scu_trace_buffer_size);
+
+/*
+ * Get nvram size
+ */
+u32 intel_scu_ipc_get_nvram_size(void)
+{
+	if (oshob_info == NULL)
+		return 0;
+	return oshob_info->nvram_size;
+}
+EXPORT_SYMBOL_GPL(intel_scu_ipc_get_nvram_size);
+
+/*
+ * Get nvram addr
+ */
+u32 intel_scu_ipc_get_nvram_addr(void)
+{
+	if (oshob_info == NULL)
+		return 0;
+	return oshob_info->nvram_addr;
+}
+EXPORT_SYMBOL_GPL(intel_scu_ipc_get_nvram_addr);
+
+/*
+ * Get SCU fabric error buffer1 offset
+ */
+u32 intel_scu_ipc_get_fabricerror_buf1_offset(void)
+{
+	if (oshob_info == NULL)
+		return 0;
+
+	if (oshob_info->platform_type == INTEL_MID_CPU_CHIP_CLOVERVIEW)
+		return offsetof(struct scu_ipc_oshob_extend, fabricerrlog1);
+	else if (oshob_info->platform_type == INTEL_MID_CPU_CHIP_TANGIER)
+		if ((oshob_info->oshob_majrev >= 1) &&
+		    (oshob_info->oshob_minrev >= 4)) {
+			return offsetof(struct scu_ipc_oshob_extend_v14,
+					fabricerrlog) + oshob_info->offs_add;
+		} else {
+			return offsetof(struct scu_ipc_oshob,
+					fab_err_log) + oshob_info->offs_add;
+		}
+	else {
+		pr_err("scu_ipc_get_fabricerror_buf_offset: platform not recognized!\n");
+		return 0;
+	}
+}
+
+/*
+ * Get SCU fabric error buffer2 offset
+ */
+u32 intel_scu_ipc_get_fabricerror_buf2_offset(void)
+{
+	if (oshob_info == NULL)
+		return 0;
+
+	if (oshob_info->platform_type == INTEL_MID_CPU_CHIP_CLOVERVIEW)
+		return offsetof(struct scu_ipc_oshob_extend, fabricerrlog2);
+	else {
+		pr_warn("scu_ipc_get_fabricerror_buf2_offset: not supported for this platform!\n");
+		return 0;
+	}
+}
+
+
+/*
+ * This reads the ALARM from the OSNIB
+ */
+#ifdef DUMP_OSNIB
+static int intel_scu_ipc_read_osnib_alarm(u8 *alarm)
+{
+	pr_debug("intel_scu_ipc_read_osnib_alarm: read ALARM\n");
+
+	return oshob_info->scu_ipc_read_osnib(
+			alarm,
+			1,
+			offsetof(struct scu_ipc_osnib, alarm));
+}
+#endif
+
+/*
+ * This reads the WAKESRC from the OSNIB
+ */
+#ifdef DUMP_OSNIB
+static int intel_scu_ipc_read_osnib_wakesrc(u8 *wksrc)
+{
+	pr_debug("intel_scu_ipc_read_osnib_wakesrc: read WAKESRC\n");
+
+	return oshob_info->scu_ipc_read_osnib(
+			wksrc,
+			1,
+			offsetof(struct scu_ipc_osnib, wakesrc));
+}
+#endif
+
+
+#define OEMNIB_BUF_DESC_LEN	4096
+
+#ifdef CONFIG_DEBUG_FS
+static int intel_scu_ipc_oshob_stat(struct seq_file *m, void *unused)
+{
+	void __iomem *osnib;
+	int i, count;
+	int ret = 0;
+
+	u32 value;
+	if ((oshob_info->oshob_majrev == OSHOB_REV_MAJ_DEFAULT) &&
+	     (oshob_info->oshob_minrev == OSHOB_REV_MIN_DEFAULT)) {
+		seq_printf(m, "DEFAULT OSHOB\n");
+		seq_printf(m, "OSHOB size : %d\n", oshob_info->oshob_size);
+		if (oshob_info->platform_type == INTEL_MID_CPU_CHIP_TANGIER) {
+			seq_printf(m, "SCU trace : ");
+
+			for (i = 0; i < OSHOB_SCU_BUF_MRFLD_DW_SIZE; i++)
+				seq_printf(m, "%x ", oshob_info->scu_trace[i]);
+
+			seq_printf(m, "\n");
+		} else
+			seq_printf(m, "SCU trace : %x\n",
+					oshob_info->scu_trace[0]);
+
+		seq_printf(m, "IA trace  : %x\n", oshob_info->ia_trace);
+	} else {
+		seq_printf(m, "EXTENDED OSHOB v%d.%d\n",
+						oshob_info->oshob_majrev,
+						oshob_info->oshob_minrev);
+		seq_printf(m, "OSHOB size : %d\n\n", oshob_info->oshob_size);
+		if (oshob_info->platform_type == INTEL_MID_CPU_CHIP_TANGIER) {
+			seq_printf(m, "SCU trace : ");
+
+			for (i = 0; i < OSHOB_SCU_BUF_MRFLD_DW_SIZE; i++)
+				seq_printf(m, "%x ", oshob_info->scu_trace[i]);
+
+			seq_printf(m, "\n");
+		} else
+			seq_printf(m, "SCU trace : %x\n",
+					oshob_info->scu_trace[0]);
+
+		seq_printf(m, "IA trace  : %x\n\n", oshob_info->ia_trace);
+
+		seq_printf(m, "OSNIB size : %d\n", oshob_info->osnib_size);
+		seq_printf(m, "OSNIB  read address  : %x\n",
+						    oshob_info->osnibr_ptr);
+		seq_printf(m, "OSNIB  write address : %x\n",
+						oshob_info->osnibw_ptr);
+		/* Dump OSNIB */
+		osnib = ioremap_nocache(oshob_info->osnibr_ptr,
+						oshob_info->osnib_size);
+		if (!osnib) {
+			pr_err("Cannot remap OSNIB\n");
+			ret = -ENOMEM;
+			return ret;
+		}
+
+		i = 0;
+		count = 0; /* used for fancy presentation */
+		while (i < oshob_info->osnib_size) {
+			if (count%4 == 0)
+				seq_printf(m, "\nOSNIB[%08x] ",
+						oshob_info->osnibr_ptr+i);
+
+			value = readl(osnib+i);
+			seq_printf(m, "%08x ", value);
+			i += 4;
+			count++;
+		}
+		seq_printf(m, "\n\n");
+		iounmap(osnib);
+
+		seq_printf(m, "OEMNIB size : %d\n",
+						oshob_info->oemnib_size);
+		seq_printf(m, "OEMNIB read address  : %x\n",
+						oshob_info->oemnibr_ptr);
+		seq_printf(m, "OEMNIB write address : %x\n",
+						oshob_info->oemnibw_ptr);
+		seq_printf(m, "\n\n");
+	}
+	return 0;
+}
+
+static int intel_scu_ipc_oemnib_stat(struct seq_file *m, void *unused)
+{
+	void __iomem *oemnib;
+	int i, count;
+	u32 value;
+
+	/* Dump OEMNIB */
+	oemnib = ioremap_nocache(oshob_info->oemnibr_ptr,
+				oshob_info->oemnib_size);
+
+	if (!oemnib) {
+		pr_err("Cannot remap OEMNIB\n");
+		return -ENOMEM;
+	}
+
+	i = 0;
+	count = 0; /* used for fancy presentation */
+	while (i < oshob_info->oemnib_size) {
+		if (count%4 == 0)
+			seq_printf(m, "\nOEMNIB[%08x] ",
+				    oshob_info->oemnibr_ptr+i);
+
+		value = readl(oemnib+i);
+		seq_printf(m, "%08x ", value);
+		i += 4;
+		count++;
+	}
+	seq_printf(m, "\n\n");
+	iounmap(oemnib);
+
+	return 0;
+}
+
+static ssize_t intel_scu_ipc_oshob_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, intel_scu_ipc_oshob_stat, NULL);
+}
+
+static ssize_t intel_scu_ipc_oemnib_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, intel_scu_ipc_oemnib_stat, NULL);
+}
+
+
+/*
+*	debugfs interface: the "oemnib_write" stores the OEMNIB part of OSNIB,
+*       starting at offset ppos.
+*/
+static ssize_t intel_scu_ipc_oemnib_write(struct file *file,
+					  const char __user *buf,
+					    size_t count, loff_t *ppos)
+{
+	int ret, i;
+	u8 *posnib_data, *ptr;
+	char *ptrchar, *temp;
+
+	if ((oshob_info->oshob_majrev == OSHOB_REV_MAJ_DEFAULT) &&
+	    (oshob_info->oshob_minrev == OSHOB_REV_MIN_DEFAULT)) {
+		/* OEMNIB only usable with extended OSHOB structure. */
+		pr_err(
+		"Write OEMNIB: OEMNIB only usable with extended OSHOB structure.\n");
+		return -EFAULT;
+	}
+
+	pr_info("Write OEMNIB: number bytes = %d\n", count);
+
+	/* Note: when the string is passed through debugfs interface, the  */
+	/* real count value includes the end of line \n. So we must take   */
+	/* care to consider count - 1 as the real number of OEM bytes.     */
+
+	if (buf == NULL) {
+		pr_err("Write OEMNIB: The passed OEMNIB buffer is NULL\n");
+		return -EINVAL;
+	}
+
+	if (count == 0) {
+		pr_err("Write OEMNIB: The OEMNIB data length to write is NULL\n");
+		return -EINVAL;
+	}
+
+	posnib_data = kzalloc(count - 1, GFP_KERNEL);
+
+	if (posnib_data == NULL) {
+		pr_err("Write OEMNIB: Cannot allocate buffer for writting OEMNIB\n");
+		return -ENOMEM;
+	}
+
+	memset(posnib_data, 0, count - 1);
+
+	temp = kzalloc(count - 1, GFP_KERNEL);
+
+	if (temp == NULL) {
+		pr_err(
+		"Write OEMNIB: Cannot allocate temp buffer for writting OEMNIB\n");
+		return -ENOMEM;
+	}
+
+	memset(temp, 0, count - 1);
+
+	if (copy_from_user(temp, buf, count - 1)) {
+		pr_err(
+		"Write OEMNIB: Cannot transfer from user buf to OEMNIB buf\n");
+		kfree(posnib_data);
+		return -EFAULT;
+	}
+
+	ptrchar = temp;
+	ptr = posnib_data;
+
+	for (i = 0; i <= count - 1; i++) {
+		if (*ptrchar >= '0' && *ptrchar <= '9')
+			*ptr = *ptrchar - '0';
+		if (*ptrchar >= 'A' && *ptrchar <= 'F')
+			*ptr = *ptrchar - 'A' + 10;
+		if (*ptrchar >= 'a' && *ptrchar <= 'f')
+			*ptr = *ptrchar - 'a' + 10;
+
+		ptrchar++;
+		ptr++;
+	}
+
+	ret = intel_scu_ipc_write_oemnib(posnib_data, count - 1, *ppos);
+
+	if (ret < 0) {
+		pr_err("Write OEMNIB: ipc write of OEMNIB failed!!\n");
+		kfree(posnib_data);
+		return ret;
+	}
+
+	kfree(posnib_data);
+	kfree(temp);
+
+	pr_info("Write OEMNIB: OEMNIB updated: count=%d bytes\n", count);
+
+	return count;
+}
+
+/* Attach the debugfs operations methods */
+static const struct file_operations scu_ipc_oemnib_fops = {
+	.owner = THIS_MODULE,
+	.open = intel_scu_ipc_oemnib_open,
+	.read = seq_read,
+	.write = intel_scu_ipc_oemnib_write,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+static const struct file_operations scu_ipc_oshob_fops = {
+	.owner = THIS_MODULE,
+	.open = intel_scu_ipc_oshob_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+static struct dentry *scu_ipc_oemnib_dir;
+static struct dentry *scu_ipc_oemnib_file;
+static struct dentry *scu_ipc_oshob_file;
+
+/*
+*	debugfs interface: init interface.
+*/
+static int intel_mid_scu_ipc_oemnib_debugfs_init(void)
+{
+	/* Create debugfs directory /sys/kernel/debug/intel_scu_oshob */
+	scu_ipc_oemnib_dir = debugfs_create_dir("intel_scu_oshob", NULL);
+
+	if (!scu_ipc_oemnib_dir) {
+		pr_err("cannot create OSHOB debugfs directory\n");
+		return -1;
+	}
+
+	/* Add operations /sys/kernel/debug/intel_scu_oshob to control */
+	/* the OEM.                                                     */
+	scu_ipc_oemnib_file = debugfs_create_file("oemnib_debug",
+				S_IFREG | S_IRUGO | S_IWUSR | S_IWGRP,
+				scu_ipc_oemnib_dir,
+				NULL, &scu_ipc_oemnib_fops);
+
+	if (!scu_ipc_oemnib_file) {
+		pr_err("cannot create OEMNIB debugfs file\n");
+		debugfs_remove(scu_ipc_oemnib_dir);
+		return -1;
+	}
+
+	/* Add operations /sys/kernel/debug/intel_scu_oshob to debug OSHOB */
+	/* content.                                                         */
+	scu_ipc_oshob_file = debugfs_create_file("oshob_dump",
+				S_IFREG | S_IRUGO | S_IWUSR | S_IWGRP,
+				scu_ipc_oemnib_dir, NULL, &scu_ipc_oshob_fops);
+
+	if (!scu_ipc_oshob_file) {
+		pr_err("cannot create OSHOB debugfs file\n");
+		debugfs_remove_recursive(scu_ipc_oemnib_dir);
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+*	debugfs interface: exit interface.
+*/
+static void intel_mid_scu_ipc_oemnib_debugfs_exit(void)
+{
+	debugfs_remove_recursive(scu_ipc_oemnib_dir);
+}
+
+#endif /* CONFIG_DEBUG_FS */
+
+static const struct file_operations scu_ipc_fops = {
+	.unlocked_ioctl = scu_ipc_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl   = scu_ipc_ioctl,
+#endif
+};
+
+static struct miscdevice scu_ipcutil = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "mid_ipc",
+	.fops = &scu_ipc_fops,
+};
+
+static int oshob_init(void)
+{
+	int ret, i;
+	u16 struct_offs;
+
+#ifdef DUMP_OSNIB
+	u8 rr, reset_ev1, reset_ev2, wd, alarm, wakesrc, *ptr;
+	int rr_found = 0, wksrc_found = 0;
+	u32 pmit, scu_trace[OSHOB_SCU_BUF_BASE_DW_SIZE*4], ia_trace;
+	int buff_size;
+#endif
+
+	/* Identify the type and size of OSHOB to be used. */
+	ret = intel_scu_ipc_read_oshob_info();
+
+	if (ret != 0) {
+		pr_err("Cannot init ipc module: oshob info not read\n");
+		goto exit;
+	}
+
+#ifdef DUMP_OSNIB
+	/* Dumping reset events from the interrupt tree */
+	ret = intel_scu_ipc_read_oshob_it_tree(&pmit);
+
+	if (ret != 0) {
+		pr_err("Cannot read interrupt tree\n");
+		goto exit;
+	}
+
+	ptr = ioremap_nocache(pmit + PMIT_RESET1_OFFSET, 2);
+
+	if (!ptr) {
+		pr_err("Cannot remap PMIT\n");
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	pr_debug("PMIT addr 0x%8x remapped to 0x%8x\n", pmit, (u32)ptr);
+
+	reset_ev1 = readb(ptr);
+	reset_ev2 = readb(ptr+1);
+	for (i = 0; i < ARRAY_SIZE(chip_reset_events); i++) {
+		if (chip_reset_events[i].id == oshob_info->platform_type) {
+			pr_warn("[BOOT] %s=0x%02x %s=0x%02x (PMIT interrupt tree)\n",
+				chip_reset_events[i].reset_ev1_name,
+				reset_ev1,
+				chip_reset_events[i].reset_ev2_name,
+				reset_ev2);
+		}
+	}
+	iounmap(ptr);
+
+	/* Dumping OSHOB content */
+	if ((oshob_info->oshob_majrev == OSHOB_REV_MAJ_DEFAULT) &&
+	    (oshob_info->oshob_minrev == OSHOB_REV_MIN_DEFAULT)) {
+		/* Use default OSHOB here. Calculate in bytes here. */
+		if (oshob_info->platform_type == INTEL_MID_CPU_CHIP_TANGIER)
+			buff_size = OSHOB_SCU_BUF_MRFLD_DW_SIZE*4;
+		else
+			buff_size = OSHOB_SCU_BUF_BASE_DW_SIZE*4;
+
+		ret = intel_scu_ipc_read_oshob(
+			(u8 *)(scu_trace),
+			buff_size,
+			offsetof(struct scu_ipc_oshob, scutxl));
+
+		if (ret != 0) {
+			pr_err("Cannot read SCU data\n");
+			goto exit;
+		}
+
+		struct_offs = offsetof(struct scu_ipc_oshob, iatxl) +
+				oshob_info->offs_add;
+		ret = intel_scu_ipc_read_oshob(
+			    (u8 *)(&ia_trace),
+			    4,
+			    struct_offs);
+
+		if (ret != 0) {
+			pr_err("Cannot read IA data\n");
+			goto exit;
+		}
+	    } else {
+		/* Use extended OSHOB here. Calculate in bytes here. */
+		if (oshob_info->platform_type == INTEL_MID_CPU_CHIP_TANGIER)
+			buff_size = OSHOB_SCU_BUF_MRFLD_DW_SIZE*4;
+		else
+			buff_size = OSHOB_SCU_BUF_BASE_DW_SIZE*4;
+
+		if ((oshob_info->oshob_majrev >= 1) &&
+		    (oshob_info->oshob_minrev >= 4)) {
+			ret = intel_scu_ipc_read_oshob(
+				(u8 *)(scu_trace),
+				buff_size,
+				offsetof(struct scu_ipc_oshob_extend_v14,
+								scutxl));
+		} else {
+			ret = intel_scu_ipc_read_oshob(
+				(u8 *)(scu_trace),
+				buff_size,
+				offsetof(struct scu_ipc_oshob_extend, scutxl));
+		}
+
+		if (ret != 0) {
+			pr_err("Cannot read SCU data\n");
+			goto exit;
+		}
+
+		if ((oshob_info->oshob_majrev >= 1) &&
+		    (oshob_info->oshob_minrev >= 4)) {
+			struct_offs = offsetof(struct scu_ipc_oshob_extend_v14,
+						iatxl) + oshob_info->offs_add;
+		} else {
+			struct_offs = offsetof(struct scu_ipc_oshob_extend,
+						iatxl) + oshob_info->offs_add;
+		}
+
+		ret = intel_scu_ipc_read_oshob(
+				(u8 *)(&ia_trace),
+				4,
+				struct_offs);
+
+		if (ret != 0) {
+			pr_err("Cannot read IA data\n");
+			goto exit;
+		}
+	}
+
+	if (oshob_info->platform_type == INTEL_MID_CPU_CHIP_TANGIER) {
+		for (i = 0; i < OSHOB_SCU_BUF_MRFLD_DW_SIZE; i++)
+			pr_warn("[BOOT] SCU_TR[%d]=0x%08x\n", i, scu_trace[i]);
+	} else
+		pr_warn("[BOOT] SCU_TR=0x%08x (oshob)\n", scu_trace[0]);
+
+	pr_warn("[BOOT] IA_TR=0x%08x (oshob)\n", ia_trace);
+
+	/* Dumping OSNIB content */
+	ret = 0;
+	ret |= intel_scu_ipc_read_osnib_rr(&rr);
+	ret |= intel_scu_ipc_read_osnib_reset_ev1(&reset_ev1);
+	ret |= intel_scu_ipc_read_osnib_reset_ev2(&reset_ev2);
+	ret |= intel_scu_ipc_read_osnib_wd(&wd);
+	ret |= intel_scu_ipc_read_osnib_alarm(&alarm);
+	ret |= intel_scu_ipc_read_osnib_wakesrc(&wakesrc);
+
+	if (ret) {
+		pr_err("Cannot read OSNIB content\n");
+		goto exit;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(osnib_target_oses); i++) {
+		if (osnib_target_oses[i].id == rr) {
+			pr_warn("[BOOT] RR=[%s] WD=0x%02x ALARM=0x%02x (osnib)\n",
+				osnib_target_oses[i].target_os_name, wd, alarm);
+			rr_found++;
+			break;
+		}
+	}
+
+	if (!rr_found)
+		pr_warn("[BOOT] RR=[UNKNOWN 0x%02x] WD=0x%02x ALARM=0x%02x (osnib)\n",
+			rr, wd, alarm);
+
+	for (i = 0; i < ARRAY_SIZE(osnib_wake_srcs); i++) {
+		if (osnib_wake_srcs[i].id == wakesrc) {
+			pr_warn("[BOOT] WAKESRC=[%s] (osnib)\n",
+				osnib_wake_srcs[i].wakesrc_name);
+			wksrc_found++;
+			break;
+		}
+	}
+
+	if (!wksrc_found)
+		pr_warn("[BOOT] WAKESRC=[UNKNOWN 0x%02x] (osnib)\n", wakesrc);
+
+	for (i = 0; i < ARRAY_SIZE(chip_reset_events); i++) {
+		if (chip_reset_events[i].id == oshob_info->platform_type) {
+			pr_warn("[BOOT] %s=0x%02x %s=0x%02x (osnib)\n",
+				chip_reset_events[i].reset_ev1_name,
+				reset_ev1,
+				chip_reset_events[i].reset_ev2_name,
+				reset_ev2);
+			break;
+		}
+	}
+
+#endif /* DUMP_OSNIB */
+
+#ifdef CONFIG_DEBUG_FS
+	if (oshob_info->oshob_majrev != OSHOB_REV_MAJ_DEFAULT) {
+		/* OEMNIB only usable with extended OSHOB structure. */
+		ret = intel_mid_scu_ipc_oemnib_debugfs_init();
+
+		if (ret != 0) {
+			pr_err("Cannot register OEMNIB interface to debugfs\n");
+			goto exit;
+		} else {
+			pr_info("OEMNIB interface registered to debugfs\n");
+		}
+	}
+#endif /* CONFIG_DEBUG_FS */
+
+exit:
+	return ret;
+}
+
+static int ipcutil_rpmsg_probe(struct rpmsg_channel *rpdev)
+{
+	int ret = 0;
+
+	oshob_info = kmalloc(sizeof(struct scu_ipc_oshob_info), GFP_KERNEL);
+	if (oshob_info == NULL) {
+		pr_err(
+		"Cannot init ipc module: oshob info struct not allocated\n");
+		return -ENOMEM;
+	}
+
+	if (rpdev == NULL) {
+		pr_err("ipcutil rpmsg channel not created\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	dev_info(&rpdev->dev, "Probed ipcutil rpmsg device\n");
+
+	/* Allocate rpmsg instance for mip*/
+	ret = alloc_rpmsg_instance(rpdev, &ipcutil_instance);
+	if (!ipcutil_instance) {
+		dev_err(&rpdev->dev, "kzalloc ipcutil instance failed\n");
+		goto out;
+	}
+
+	/* Initialize rpmsg instance */
+	init_rpmsg_instance(ipcutil_instance);
+
+	ret = oshob_init();
+	if (ret)
+		goto misc_err;
+
+	ret = misc_register(&scu_ipcutil);
+	if (ret) {
+		pr_err("misc register failed\n");
+		goto misc_err;
+	}
+
+	return ret;
+
+misc_err:
+	free_rpmsg_instance(rpdev, &ipcutil_instance);
+out:
+	kfree(oshob_info);
+	return ret;
+}
+
+static void ipcutil_rpmsg_remove(struct rpmsg_channel *rpdev)
+{
+#ifdef CONFIG_DEBUG_FS
+	if (oshob_info->oshob_majrev != OSHOB_REV_MAJ_DEFAULT) {
+		/* OEMNIB only usable with extended OSHOB structure. */
+		/* unregister from debugfs.                     */
+		intel_mid_scu_ipc_oemnib_debugfs_exit();
+	}
+#endif /* CONFIG_DEBUG_FS */
+
+	kfree(oshob_info);
+
+	/* unregister scu_ipc_ioctl from sysfs. */
+	misc_deregister(&scu_ipcutil);
+	free_rpmsg_instance(rpdev, &ipcutil_instance);
+}
+
+static void ipcutil_rpmsg_cb(struct rpmsg_channel *rpdev, void *data,
+					int len, void *priv, u32 src)
+{
+	dev_warn(&rpdev->dev, "unexpected, message\n");
+
+	print_hex_dump(KERN_DEBUG, __func__, DUMP_PREFIX_NONE, 16, 1,
+		       data, len,  true);
+}
+
+static struct rpmsg_device_id ipcutil_rpmsg_id_table[] = {
+	{ .name	= "rpmsg_ipc_util" },
+	{ },
+};
+MODULE_DEVICE_TABLE(rpmsg, ipcutil_rpmsg_id_table);
+
+static struct rpmsg_driver ipcutil_rpmsg = {
+	.drv.name	= KBUILD_MODNAME,
+	.drv.owner	= THIS_MODULE,
+	.id_table	= ipcutil_rpmsg_id_table,
+	.probe		= ipcutil_rpmsg_probe,
+	.callback	= ipcutil_rpmsg_cb,
+	.remove		= ipcutil_rpmsg_remove,
+};
+
+static int __init ipcutil_rpmsg_init(void)
+{
+	return register_rpmsg_driver(&ipcutil_rpmsg);
 }
 
-static void __exit ipc_module_exit(void)
+static void __exit ipcutil_rpmsg_exit(void)
 {
-	unregister_chrdev(major, "intel_mid_scu");
+	unregister_rpmsg_driver(&ipcutil_rpmsg);
 }
 
-module_init(ipc_module_init);
-module_exit(ipc_module_exit);
+rootfs_initcall(ipcutil_rpmsg_init);
+module_exit(ipcutil_rpmsg_exit);
 
 MODULE_LICENSE("GPL v2");
 MODULE_DESCRIPTION("Utility driver for intel scu ipc");
diff --git a/drivers/platform/x86/intel_scu_mip.c b/drivers/platform/x86/intel_scu_mip.c
new file mode 100644
index 0000000..ec06140
--- /dev/null
+++ b/drivers/platform/x86/intel_scu_mip.c
@@ -0,0 +1,776 @@
+/*
+ * intel_scu_mip.c: Driver for the Intel scu mip and umip access
+ *
+ * (C) Copyright 2012 Intel Corporation
+ * Author: Shijie Zhang (shijie.zhang@intel.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/rpmsg.h>
+#include <linux/blkdev.h>
+#include <linux/pagemap.h>
+#include <asm/intel_scu_ipc.h>
+#include <asm/intel_mip.h>
+#include <asm/intel_mid_rpmsg.h>
+#include <linux/platform_data/intel_mid_remoteproc.h>
+
+#define DRIVER_NAME "intel_scu_mip"
+
+#define IPC_MIP_BASE     0xFFFD8000	/* sram base address for mip accessing*/
+#define IPC_MIP_MAX_ADDR 0x1000
+
+#define KOBJ_MIP_ATTR(_name, _mode, _show, _store) \
+	struct kobj_attribute _name##_attr = __ATTR(_name, _mode, _show, _store)
+
+static struct kobject *scu_mip_kobj;
+static struct rpmsg_instance *mip_instance;
+static struct scu_mip_platform_data *pdata;
+
+static void __iomem *intel_mip_base;
+#define SECTOR_SIZE			512
+#define UMIP_TOTAL_CHKSUM_ENTRY		126
+#define UMIP_HEADER_HEADROOM_SECTOR	1
+#define UMIP_HEADER_SECTOR		0
+#define UMIP_HEADER_CHKSUM_ADDR		7
+#define UMIP_START_CHKSUM_ADDR		8
+#define UMIP_TOTAL_HEADER_SECTOR_NO	2
+
+#define UMIP_BLKDEVICE			"mmcblk0boot0"
+
+static int xorblock(u32 *buf, u32 size)
+{
+	u32 cs = 0;
+
+	size >>= 2;
+	while (size--)
+		cs ^= *buf++;
+
+	return cs;
+}
+
+static u8 dword_to_byte_chksum(u32 dw)
+{
+	int n = 0;
+	u32 cs = dw;
+	for (n = 0; n < 3; n++) {
+		dw >>= 8;
+		cs ^= dw;
+	}
+
+	return (u8)cs;
+}
+
+static u8 calc_checksum(void *_buf, int size)
+{
+	int i;
+	u8 checksum = 0, *buf = (u8 *)_buf;
+
+	for (i = 0; i < size; i++)
+		checksum = checksum ^ (buf[i]);
+
+	return checksum;
+}
+
+static int mmcblk0boot0_match(struct device *dev, const void *data)
+{
+	if (strcmp(dev_name(dev), UMIP_BLKDEVICE) == 0)
+		return 1;
+
+	return 0;
+}
+
+static struct block_device *get_emmc_bdev(void)
+{
+	struct block_device *bdev;
+	struct device *emmc_disk;
+
+	emmc_disk = class_find_device(&block_class, NULL, NULL,
+					mmcblk0boot0_match);
+	if (emmc_disk == 0) {
+		pr_err("emmc not found!\n");
+		return NULL;
+	}
+
+	/* partition 0 means raw disk */
+	bdev = bdget_disk(dev_to_disk(emmc_disk), 0);
+	if (bdev == NULL) {
+		dev_err(emmc_disk, "unable to get disk\n");
+		return NULL;
+	}
+
+	/* Note: this bdev ref will be freed after first
+	 * bdev_get/bdev_put cycle
+	 */
+
+	return bdev;
+}
+
+
+static int read_mip(u8 *data, int len, int offset, int issigned)
+{
+	int ret;
+	u32 sptr, dptr, cmd, cmdid, data_off;
+
+	dptr = offset;
+	sptr = (len + 3) / 4;
+
+	cmdid = issigned ? IPC_CMD_SMIP_RD : IPC_CMD_UMIP_RD;
+	cmd = 4 << 16 | cmdid << 12 | IPCMSG_MIP_ACCESS;
+
+	do {
+		ret = rpmsg_send_raw_command(mip_instance, cmd, 0, NULL,
+			(u32 *)&data_off, 0, 1, sptr, dptr);
+
+		if (ret == -EIO)
+			msleep(20);
+	} while (ret == -EIO);
+
+	if (!ret)
+		memcpy(data, intel_mip_base + data_off, len);
+
+	return ret;
+}
+
+int intel_scu_ipc_read_mip(u8 *data, int len, int offset, int issigned)
+{
+	int ret = 0;
+	Sector sect;
+	struct block_device *bdev;
+	char *buffer = NULL;
+	int *holderId = NULL;
+	int sect_no, remainder;
+
+	/* Only SMIP read for Cloverview is supported */
+	if ((intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_CLOVERVIEW)
+			&& (issigned != 1)) { /* CTP read UMIP from eMMC */
+
+		/* Opening the mmcblk0boot0 */
+		bdev = get_emmc_bdev();
+		if (bdev == NULL) {
+			pr_err("%s: get_emmc failed!\n", __func__);
+			return -ENODEV;
+		}
+
+		/* make sure the block device is open read only */
+		ret = blkdev_get(bdev, FMODE_READ, holderId);
+		if (ret < 0) {
+			pr_err("%s: blk_dev_get failed!\n", __func__);
+			return -ret;
+		}
+
+		/* Get sector number of where data located */
+		sect_no = offset / SECTOR_SIZE;
+		remainder = offset % SECTOR_SIZE;
+		buffer = read_dev_sector(bdev, sect_no +
+					UMIP_HEADER_HEADROOM_SECTOR, &sect);
+
+		/* Shouldn't need to access UMIP sector 0/1 */
+		if (sect_no < UMIP_TOTAL_HEADER_SECTOR_NO) {
+			pr_err("invalid umip offset\n");
+			ret = -EINVAL;
+			goto bd_put;
+		} else if (data == NULL || buffer == NULL) {
+			pr_err("buffer is empty\n");
+			ret = -ENODEV;
+			goto bd_put;
+		} else if (len > (SECTOR_SIZE - remainder)) {
+			pr_err("not enough data to read\n");
+			ret = -EINVAL;
+			goto bd_put;
+		}
+
+		memcpy(data, buffer + remainder, len);
+bd_put:
+		if (buffer)
+			put_dev_sector(sect);
+
+		blkdev_put(bdev, FMODE_READ);
+		return ret;
+	} else {
+
+		if (!intel_mip_base)
+			return -ENODEV;
+
+		if (offset + len > IPC_MIP_MAX_ADDR)
+			return -EINVAL;
+
+		rpmsg_global_lock();
+		ret = read_mip(data, len, offset, issigned);
+		rpmsg_global_unlock();
+
+		return ret;
+	}
+}
+EXPORT_SYMBOL(intel_scu_ipc_read_mip);
+
+int get_smip_property_by_name(enum platform_prop pp)
+{
+	u8 data[SMIP_MAX_PROP_LEN];
+	int i, val, ret;
+	struct smip_platform_prop prop[SMIP_NUM_CONFIG_PROPS];
+
+	if (!pdata->smip_prop)
+		return -EINVAL;
+
+	for (i = 0; i < SMIP_NUM_CONFIG_PROPS; i++)
+		prop[i] = pdata->smip_prop[i];
+
+	/* Read the property requested by the caller */
+	ret = intel_scu_ipc_read_mip(data, prop[pp].len, prop[pp].offset, 1);
+	if (ret)
+		return ret;
+
+	/* Adjust the bytes according to the length and return the int */
+	val = data[0];
+	for (i = 1; i < prop[pp].len; i++)
+		val = val << 8 | data[i];
+
+	/* If the requested property is a bit field, return that bit value */
+	if (prop[pp].is_bit_field)
+		val &= prop[pp].mask;
+
+	return val;
+}
+EXPORT_SYMBOL(get_smip_property_by_name);
+
+int intel_scu_ipc_write_umip(u8 *data, int len, int offset)
+{
+	int i, ret = 0, offset_align;
+	int remainder, len_align = 0;
+	u32 dptr, sptr, cmd;
+	u8 cs, tbl_cs = 0, *buf = NULL;
+	Sector sect;
+	struct block_device *bdev;
+	char *buffer = NULL;
+	int *holderId = NULL;
+	int sect_no;
+	u8 checksum;
+
+	if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_CLOVERVIEW) {
+
+		/* Opening the mmcblk0boot0 */
+		bdev = get_emmc_bdev();
+		if (bdev == NULL) {
+			pr_err("%s: get_emmc failed!\n", __func__);
+			return -ENODEV;
+		}
+
+		/* make sure the block device is open rw */
+		ret = blkdev_get(bdev, FMODE_READ|FMODE_WRITE, holderId);
+		if (ret < 0) {
+			pr_err("%s: blk_dev_get failed!\n", __func__);
+			return -ret;
+		}
+
+		/* get memmap of the UMIP header */
+		sect_no = offset / SECTOR_SIZE;
+		remainder = offset % SECTOR_SIZE;
+		buffer = read_dev_sector(bdev, sect_no +
+					UMIP_HEADER_HEADROOM_SECTOR, &sect);
+
+		/* Shouldn't need to access UMIP sector 0/1 */
+		if (sect_no < UMIP_TOTAL_HEADER_SECTOR_NO) {
+			pr_err("invalid umip offset\n");
+			ret = -EINVAL;
+			goto bd_put;
+		} else if (data == NULL || buffer == NULL) {
+			pr_err("buffer is empty\n");
+			ret = -ENODEV;
+			goto bd_put;
+		} else if (len > (SECTOR_SIZE - remainder)) {
+			pr_err("too much data to write\n");
+			ret = -EINVAL;
+			goto bd_put;
+		}
+
+		lock_page(sect.v);
+		memcpy(buffer + remainder, data, len);
+		checksum = calc_checksum(buffer, SECTOR_SIZE);
+
+		set_page_dirty(sect.v);
+		unlock_page(sect.v);
+		sync_blockdev(bdev);
+		put_dev_sector(sect);
+
+		/*
+		 * Updating the checksum, sector 0 (starting from UMIP
+		 * offset 0x08), we maintains 4 bytes for tracking each of
+		 * sector changes individually. For example, the dword at
+		 * offset 0x08 is used to checksum data integrity of sector
+		 * number 2, and so on so forth. It's worthnoting that only
+		 * the first byte in each 4 bytes stores checksum.
+		 * For detail, please check CTP FAS UMIP header definition
+		 */
+
+		buffer = read_dev_sector(bdev, UMIP_HEADER_SECTOR +
+					UMIP_HEADER_HEADROOM_SECTOR, &sect);
+
+		if (buffer == NULL) {
+			pr_err("buffer is empty\n");
+			ret = -ENODEV;
+			goto bd_put;
+		}
+
+		lock_page(sect.v);
+		memcpy(buffer + 4 * (sect_no - UMIP_TOTAL_HEADER_SECTOR_NO) +
+			UMIP_START_CHKSUM_ADDR, &checksum, 1/* one byte */);
+
+		/* Change UMIP prologue chksum to zero */
+		*(buffer + UMIP_HEADER_CHKSUM_ADDR) = 0;
+
+		for (i = 0; i < UMIP_TOTAL_CHKSUM_ENTRY; i++) {
+			tbl_cs ^= *(u8 *)(buffer + 4 * i +
+					UMIP_START_CHKSUM_ADDR);
+		}
+
+		/* Finish up with re-calcuating UMIP prologue checksum */
+		cs = dword_to_byte_chksum(xorblock((u32 *)buffer,
+							SECTOR_SIZE));
+
+		*(buffer + UMIP_HEADER_CHKSUM_ADDR) = tbl_cs ^ cs;
+
+		set_page_dirty(sect.v);
+		unlock_page(sect.v);
+		sync_blockdev(bdev);
+bd_put:
+		if (buffer)
+			put_dev_sector(sect);
+
+		blkdev_put(bdev, FMODE_READ|FMODE_WRITE);
+		return ret;
+	} else {
+
+		if (!intel_mip_base)
+			return -ENODEV;
+
+		if (offset + len > IPC_MIP_MAX_ADDR)
+			return -EINVAL;
+
+		rpmsg_global_lock();
+
+		offset_align = offset & (~0x3);
+		len_align = (len + (offset - offset_align) + 3) & (~0x3);
+
+		if (len != len_align) {
+			buf = kzalloc(len_align, GFP_KERNEL);
+			if (!buf) {
+				pr_err("Alloc memory failed\n");
+				ret = -ENOMEM;
+				goto fail;
+			}
+			ret = read_mip(buf, len_align, offset_align, 0);
+			if (ret)
+				goto fail;
+			memcpy(buf + offset - offset_align, data, len);
+		} else {
+			buf = data;
+		}
+
+		dptr = offset_align;
+		sptr = len_align / 4;
+		cmd = IPC_CMD_UMIP_WR << 12 | IPCMSG_MIP_ACCESS;
+
+		memcpy(intel_mip_base, buf, len_align);
+
+		do {
+			ret = rpmsg_send_raw_command(mip_instance, cmd, 0, NULL,
+					NULL, 0, 0, sptr, dptr);
+			if (ret == -EIO)
+				msleep(20);
+		} while (ret == -EIO);
+
+fail:
+		if (buf && len_align != len)
+			kfree(buf);
+
+		rpmsg_global_unlock();
+
+		return ret;
+	}
+}
+EXPORT_SYMBOL(intel_scu_ipc_write_umip);
+
+
+#define MAX_DATA_NR 8
+#define MIP_CMD_LEN 11
+
+enum {
+	MIP_DBG_DATA,
+	MIP_DBG_LEN,
+	MIP_DBG_OFFSET,
+	MIP_DBG_ISSIGNED,
+	MIP_DBG_ERROR,
+};
+
+static u8 mip_data[MAX_DATA_NR];
+static int valid_data_nr;
+static int mip_len;
+static int mip_offset;
+static int mip_issigned;
+static int mip_dbg_error;
+static char mip_cmd[MIP_CMD_LEN];
+
+static ssize_t mip_generic_show(char *buf, int type, int *data)
+{
+	int i;
+	ssize_t ret = 0;
+
+	switch (type) {
+	case MIP_DBG_DATA:
+		for (i = 0; i < valid_data_nr; i++) {
+			ret += snprintf(buf + ret, PAGE_SIZE - ret,
+					"data[%d]: %#x\n",
+					i, mip_data[i]);
+		}
+		break;
+	case MIP_DBG_LEN:
+		ret = snprintf(buf, PAGE_SIZE, "len: %d\n", *data);
+		break;
+	case MIP_DBG_OFFSET:
+		ret = snprintf(buf, PAGE_SIZE, "offset: %#x\n", *data);
+		break;
+	case MIP_DBG_ISSIGNED:
+		ret = snprintf(buf, PAGE_SIZE, "issigned: %d\n", *data);
+		break;
+	case MIP_DBG_ERROR:
+		ret = snprintf(buf, PAGE_SIZE, "error: %d\n", *data);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static void mip_generic_store(const char *buf, int type, int *data)
+{
+	int i, ret;
+
+	if (type == MIP_DBG_DATA) {
+		u32 t[MAX_DATA_NR];
+
+		valid_data_nr = 0;
+		memset(mip_data, 0, sizeof(mip_data));
+
+		ret = sscanf(buf, "%x %x %x %x %x %x %x %x", &t[0], &t[1],
+				&t[2], &t[3], &t[4], &t[5], &t[6], &t[7]);
+		if (ret == 0 || ret > MAX_DATA_NR) {
+			mip_dbg_error = -EINVAL;
+			return;
+		} else {
+			for (i = 0; i < ret; i++)
+				mip_data[i] = (u8)t[i];
+			valid_data_nr = ret;
+		}
+	} else {
+		*data = 0;
+		switch (type) {
+		case MIP_DBG_OFFSET:
+			ret = sscanf(buf, "%x", data);
+			break;
+		case MIP_DBG_LEN:
+		case MIP_DBG_ISSIGNED:
+			ret = sscanf(buf, "%d", data);
+			break;
+		default:
+			ret = -1;
+			break;
+		}
+	}
+
+	if (ret)
+		mip_dbg_error = 0;
+	else
+		mip_dbg_error = -EINVAL;
+
+	return;
+}
+
+static ssize_t mip_data_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return mip_generic_show(buf, MIP_DBG_DATA, NULL);
+}
+
+static ssize_t mip_data_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t size)
+{
+	mip_generic_store(buf, MIP_DBG_DATA, NULL);
+	return size;
+}
+
+static ssize_t mip_len_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return mip_generic_show(buf, MIP_DBG_LEN, &mip_len);
+}
+
+static ssize_t mip_len_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t size)
+{
+	mip_generic_store(buf, MIP_DBG_LEN, &mip_len);
+	return size;
+}
+
+static ssize_t mip_offset_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return mip_generic_show(buf, MIP_DBG_OFFSET, &mip_offset);
+}
+
+static ssize_t mip_offset_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t size)
+{
+	mip_generic_store(buf, MIP_DBG_OFFSET, &mip_offset);
+	return size;
+}
+
+static ssize_t mip_issigned_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return mip_generic_show(buf, MIP_DBG_ISSIGNED, &mip_issigned);
+}
+
+static ssize_t mip_issigned_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t size)
+{
+	mip_generic_store(buf, MIP_DBG_ISSIGNED, &mip_issigned);
+	return size;
+}
+
+static ssize_t mip_error_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return mip_generic_show(buf, MIP_DBG_ERROR, &mip_dbg_error);
+}
+
+static ssize_t mip_cmd_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t size)
+{
+
+	int ret;
+
+	memset(mip_cmd, 0, sizeof(mip_cmd));
+
+	ret = sscanf(buf, "%10s", mip_cmd);
+	if (ret == 0) {
+		mip_dbg_error = -EINVAL;
+		goto end;
+	}
+
+	if (!strncmp("read_mip", mip_cmd, MIP_CMD_LEN)) {
+		memset(mip_data, 0, sizeof(mip_data));
+		ret = intel_scu_ipc_read_mip(mip_data, mip_len, mip_offset,
+				mip_issigned);
+		if (!ret)
+			valid_data_nr = mip_len;
+
+	} else if (!strncmp("write_umip", mip_cmd, MIP_CMD_LEN)) {
+		if (mip_len == valid_data_nr) {
+			ret = intel_scu_ipc_write_umip(mip_data, mip_len,
+					mip_offset);
+		} else
+			goto error;
+	} else
+		goto error;
+
+	if (ret)
+		goto error;
+	else
+		goto end;
+
+error:
+	mip_dbg_error = -EINVAL;
+
+end:
+	return size;
+}
+
+static KOBJ_MIP_ATTR(data, S_IRUGO|S_IWUSR, mip_data_show, mip_data_store);
+static KOBJ_MIP_ATTR(len, S_IRUGO|S_IWUSR, mip_len_show, mip_len_store);
+static KOBJ_MIP_ATTR(offset, S_IRUGO|S_IWUSR, mip_offset_show,
+		mip_offset_store);
+static KOBJ_MIP_ATTR(issigned, S_IRUGO|S_IWUSR, mip_issigned_show,
+		mip_issigned_store);
+static KOBJ_MIP_ATTR(cmd, S_IWUSR, NULL, mip_cmd_store);
+static KOBJ_MIP_ATTR(error, S_IRUGO, mip_error_show, NULL);
+
+static struct attribute *mip_attrs[] = {
+	&data_attr.attr,
+	&len_attr.attr,
+	&offset_attr.attr,
+	&issigned_attr.attr,
+	&cmd_attr.attr,
+	&error_attr.attr,
+	NULL,
+};
+
+static struct attribute_group mip_attr_group = {
+	.name = "mip_debug",
+	.attrs = mip_attrs,
+};
+
+static int scu_mip_probe(struct platform_device *pdev)
+{
+	if (intel_mid_identify_cpu() != INTEL_MID_CPU_CHIP_PENWELL) {
+		if (!pdev->dev.platform_data)
+			return -EINVAL;
+		pdata =
+		(struct scu_mip_platform_data *)pdev->dev.platform_data;
+	}
+	return 0;
+}
+
+static int scu_mip_remove(struct platform_device *pdev)
+{
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+static const struct platform_device_id scu_mip_table[] = {
+		{DRIVER_NAME, 1 },
+};
+
+static struct platform_driver scu_mip_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+	},
+	.probe = scu_mip_probe,
+	.remove = scu_mip_remove,
+	.id_table = scu_mip_table,
+};
+
+static int __init scu_mip_init(void)
+{
+	return platform_driver_register(&scu_mip_driver);
+}
+
+static void scu_mip_exit(void)
+{
+	platform_driver_unregister(&scu_mip_driver);
+}
+
+static int mip_rpmsg_probe(struct rpmsg_channel *rpdev)
+{
+	int ret = 0;
+
+	if (rpdev == NULL) {
+		pr_err("rpmsg channel not created\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	dev_info(&rpdev->dev, "Probed mip rpmsg device\n");
+
+	/* Allocate rpmsg instance for mip*/
+	ret = alloc_rpmsg_instance(rpdev, &mip_instance);
+	if (!mip_instance) {
+		dev_err(&rpdev->dev, "kzalloc mip instance failed\n");
+		goto out;
+	}
+	/* Initialize rpmsg instance */
+	init_rpmsg_instance(mip_instance);
+
+	/* Init mip base */
+	intel_mip_base = ioremap_nocache(IPC_MIP_BASE, IPC_MIP_MAX_ADDR);
+	if (!intel_mip_base) {
+		ret = -ENOMEM;
+		goto rpmsg_err;
+	}
+
+	/* Create debugfs for mip regs */
+	scu_mip_kobj = kobject_create_and_add(mip_attr_group.name,
+						kernel_kobj);
+
+	if (!scu_mip_kobj) {
+		ret = -ENOMEM;
+		goto mip_base_err;
+	}
+
+	ret = sysfs_create_group(scu_mip_kobj, &mip_attr_group);
+
+	if (ret) {
+		kobject_put(scu_mip_kobj);
+		goto mip_base_err;
+	}
+
+	ret = scu_mip_init();
+	goto out;
+mip_base_err:
+	iounmap(intel_mip_base);
+rpmsg_err:
+	free_rpmsg_instance(rpdev, &mip_instance);
+out:
+	return ret;
+}
+
+static void mip_rpmsg_remove(struct rpmsg_channel *rpdev)
+{
+	scu_mip_exit();
+	iounmap(intel_mip_base);
+	free_rpmsg_instance(rpdev, &mip_instance);
+	sysfs_remove_group(scu_mip_kobj, &mip_attr_group);
+	kobject_put(scu_mip_kobj);
+	dev_info(&rpdev->dev, "Removed mip rpmsg device\n");
+}
+
+static void mip_rpmsg_cb(struct rpmsg_channel *rpdev, void *data,
+					int len, void *priv, u32 src)
+{
+	dev_warn(&rpdev->dev, "unexpected, message\n");
+
+	print_hex_dump(KERN_DEBUG, __func__, DUMP_PREFIX_NONE, 16, 1,
+		       data, len,  true);
+}
+
+static struct rpmsg_device_id mip_rpmsg_id_table[] = {
+	{ .name	= "rpmsg_mip" },
+	{ },
+};
+MODULE_DEVICE_TABLE(rpmsg, mip_rpmsg_id_table);
+
+static struct rpmsg_driver mip_rpmsg = {
+	.drv.name	= KBUILD_MODNAME,
+	.drv.owner	= THIS_MODULE,
+	.id_table	= mip_rpmsg_id_table,
+	.probe		= mip_rpmsg_probe,
+	.callback	= mip_rpmsg_cb,
+	.remove		= mip_rpmsg_remove,
+};
+
+static int __init mip_rpmsg_init(void)
+{
+	if ((intel_mid_identify_cpu() != INTEL_MID_CPU_CHIP_PENWELL)
+		&& (intel_mid_identify_cpu() != INTEL_MID_CPU_CHIP_CLOVERVIEW))
+		return -EINVAL;
+
+	return register_rpmsg_driver(&mip_rpmsg);
+}
+
+#ifdef MODULE
+module_init(mip_rpmsg_init);
+#else
+fs_initcall_sync(mip_rpmsg_init);
+#endif
+
+static void __exit mip_rpmsg_exit(void)
+{
+	return unregister_rpmsg_driver(&mip_rpmsg);
+}
+module_exit(mip_rpmsg_exit);
+
+MODULE_AUTHOR("Shijie Zhang <shijie.zhang@intel.com>");
+MODULE_DESCRIPTION("Intel SCU MIP driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/platform/x86/intel_scu_pmic.c b/drivers/platform/x86/intel_scu_pmic.c
new file mode 100644
index 0000000..d92e1dc
--- /dev/null
+++ b/drivers/platform/x86/intel_scu_pmic.c
@@ -0,0 +1,477 @@
+/*
+ * pmic.c - Intel MSIC Driver
+ *
+ * Copyright (C) 2012 Intel Corporation
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ * Author: Bin Yang <bin.yang@intel.com>
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/debugfs.h>
+#include <linux/rpmsg.h>
+#include <asm/intel_scu_pmic.h>
+#include <asm/intel_scu_ipc.h>
+#include <asm/intel_mid_rpmsg.h>
+#include <linux/platform_data/intel_mid_remoteproc.h>
+
+#define IPC_WWBUF_SIZE    20
+#define IPC_RWBUF_SIZE    20
+
+static struct kobject *scu_pmic_kobj;
+static struct rpmsg_instance *pmic_instance;
+
+static int pwr_reg_rdwr(u16 *addr, u8 *data, u32 count, u32 cmd, u32 sub)
+{
+	int i, err, inlen = 0, outlen = 0;
+
+	u8 wbuf[IPC_WWBUF_SIZE] = {};
+	u8 rbuf[IPC_RWBUF_SIZE] = {};
+
+	memset(wbuf, 0, sizeof(wbuf));
+
+	for (i = 0; i < count; i++) {
+		wbuf[inlen++] = addr[i] & 0xff;
+		wbuf[inlen++] = (addr[i] >> 8) & 0xff;
+	}
+
+	if (sub == IPC_CMD_PCNTRL_R) {
+		outlen = count > 0 ? ((count - 1) / 4) + 1 : 0;
+	} else if (sub == IPC_CMD_PCNTRL_W) {
+		if (count == 3)
+			inlen += 2;
+
+		for (i = 0; i < count; i++)
+			wbuf[inlen++] = data[i] & 0xff;
+
+		if (count == 3)
+			inlen -= 2;
+
+		outlen = 0;
+	} else if (sub == IPC_CMD_PCNTRL_M) {
+		wbuf[inlen++] = data[0] & 0xff;
+		wbuf[inlen++] = data[1] & 0xff;
+		outlen = 0;
+	} else
+		pr_err("IPC command not supported\n");
+
+	err = rpmsg_send_command(pmic_instance, cmd, sub, wbuf,
+			(u32 *)rbuf, inlen, outlen);
+
+	if (sub == IPC_CMD_PCNTRL_R) {
+		for (i = 0; i < count; i++)
+			data[i] = rbuf[i];
+	}
+
+	return err;
+}
+
+int intel_scu_ipc_ioread8(u16 addr, u8 *data)
+{
+	return pwr_reg_rdwr(&addr, data, 1, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_R);
+}
+EXPORT_SYMBOL(intel_scu_ipc_ioread8);
+
+int intel_scu_ipc_iowrite8(u16 addr, u8 data)
+{
+	return pwr_reg_rdwr(&addr, &data, 1, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_W);
+}
+EXPORT_SYMBOL(intel_scu_ipc_iowrite8);
+
+int intel_scu_ipc_iowrite32(u16 addr, u32 data)
+{
+	u16 x[4] = {addr, addr + 1, addr + 2, addr + 3};
+	return pwr_reg_rdwr(x, (u8 *)&data, 4, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_W);
+}
+EXPORT_SYMBOL(intel_scu_ipc_iowrite32);
+
+int intel_scu_ipc_readv(u16 *addr, u8 *data, int len)
+{
+	if (len < 1 || len > 8)
+		return -EINVAL;
+
+	return pwr_reg_rdwr(addr, data, len, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_R);
+}
+EXPORT_SYMBOL(intel_scu_ipc_readv);
+
+int intel_scu_ipc_writev(u16 *addr, u8 *data, int len)
+{
+	if (len < 1 || len > 4)
+		return -EINVAL;
+
+	return pwr_reg_rdwr(addr, data, len, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_W);
+}
+EXPORT_SYMBOL(intel_scu_ipc_writev);
+
+int intel_scu_ipc_update_register(u16 addr, u8 bits, u8 mask)
+{
+	u8 data[2] = { bits, mask };
+	return pwr_reg_rdwr(&addr, data, 1, IPCMSG_PCNTRL, IPC_CMD_PCNTRL_M);
+}
+EXPORT_SYMBOL(intel_scu_ipc_update_register);
+
+/* pmic sysfs for debug */
+
+#define MAX_PMIC_REG_NR 4
+#define PMIC_OPS_LEN 10
+
+enum {
+	PMIC_DBG_ADDR,
+	PMIC_DBG_BITS,
+	PMIC_DBG_DATA,
+	PMIC_DBG_MASK,
+};
+
+static char *pmic_msg_format[] = {
+	"addr[%d]: %#x\n",
+	"bits[%d]: %#x\n",
+	"data[%d]: %#x\n",
+	"mask[%d]: %#x\n",
+};
+
+static u16 pmic_reg_addr[MAX_PMIC_REG_NR];
+static u8 pmic_reg_bits[MAX_PMIC_REG_NR];
+static u8 pmic_reg_data[MAX_PMIC_REG_NR];
+static u8 pmic_reg_mask[MAX_PMIC_REG_NR];
+static int valid_addr_nr;
+static int valid_bits_nr;
+static int valid_data_nr;
+static int valid_mask_nr;
+static char pmic_ops[PMIC_OPS_LEN];
+
+static int pmic_dbg_error;
+
+static ssize_t pmic_generic_show(char *buf, int valid, u8 *array, int type)
+{
+	int i, buf_size;
+	ssize_t ret = 0;
+
+	switch (type) {
+	case PMIC_DBG_ADDR:
+		for (i = 0; i < valid; i++) {
+			buf_size = PAGE_SIZE - ret;
+			ret += snprintf(buf + ret, buf_size,
+					pmic_msg_format[type],
+					i, pmic_reg_addr[i]);
+		}
+		break;
+	case PMIC_DBG_BITS:
+	case PMIC_DBG_DATA:
+	case PMIC_DBG_MASK:
+		for (i = 0; i < valid; i++) {
+			buf_size = PAGE_SIZE - ret;
+			ret += snprintf(buf + ret, buf_size,
+					pmic_msg_format[type],
+					i, array[i]);
+		}
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static void pmic_generic_store(const char *buf, int *valid, u8 *array, int type)
+{
+	u32 tmp[MAX_PMIC_REG_NR];
+	int i, ret;
+
+	ret = sscanf(buf, "%x %x %x %x", &tmp[0], &tmp[1], &tmp[2], &tmp[3]);
+	if (ret == 0 || ret > MAX_PMIC_REG_NR) {
+		*valid = 0;
+		pmic_dbg_error = -EINVAL;
+		return;
+	}
+
+	*valid = ret;
+
+	switch (type) {
+	case PMIC_DBG_ADDR:
+		memset(pmic_reg_addr, 0, sizeof(pmic_reg_addr));
+		for (i = 0; i < ret; i++)
+			pmic_reg_addr[i] = (u16)tmp[i];
+		break;
+	case PMIC_DBG_BITS:
+	case PMIC_DBG_DATA:
+	case PMIC_DBG_MASK:
+		memset(array, 0, sizeof(*array) * MAX_PMIC_REG_NR);
+		for (i = 0; i < ret; i++)
+			array[i] = (u8)tmp[i];
+		break;
+	default:
+		break;
+	}
+}
+
+static ssize_t pmic_addr_show(struct kobject *kobj, struct kobj_attribute *attr,
+				char *buf)
+{
+	return pmic_generic_show(buf, valid_addr_nr, NULL, PMIC_DBG_ADDR);
+}
+
+static ssize_t pmic_addr_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t size)
+{
+	pmic_generic_store(buf, &valid_addr_nr, NULL, PMIC_DBG_ADDR);
+	return size;
+}
+
+static ssize_t pmic_bits_show(struct kobject *kobj, struct kobj_attribute *attr,
+				char *buf)
+{
+	return pmic_generic_show(buf, valid_bits_nr, pmic_reg_bits,
+			PMIC_DBG_BITS);
+}
+static ssize_t pmic_bits_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t size)
+{
+	pmic_generic_store(buf, &valid_bits_nr, pmic_reg_bits, PMIC_DBG_BITS);
+	return size;
+}
+
+static ssize_t pmic_data_show(struct kobject *kobj, struct kobj_attribute *attr,
+				char *buf)
+{
+	return pmic_generic_show(buf, valid_data_nr, pmic_reg_data,
+			PMIC_DBG_DATA);
+}
+
+static ssize_t pmic_data_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t size)
+{
+	pmic_generic_store(buf, &valid_data_nr, pmic_reg_data, PMIC_DBG_DATA);
+	return size;
+}
+
+static ssize_t pmic_mask_show(struct kobject *kobj, struct kobj_attribute *attr,
+				char *buf)
+{
+	return pmic_generic_show(buf, valid_mask_nr, pmic_reg_mask,
+			PMIC_DBG_MASK);
+}
+
+static ssize_t pmic_mask_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t size)
+{
+	pmic_generic_store(buf, &valid_mask_nr, pmic_reg_mask, PMIC_DBG_MASK);
+	return size;
+}
+
+static ssize_t pmic_ops_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t size)
+{
+	int i, ret;
+
+	memset(pmic_ops, 0, sizeof(pmic_ops));
+
+	ret = sscanf(buf, "%9s", pmic_ops);
+	if (ret == 0) {
+		pmic_dbg_error = -EINVAL;
+		goto end;
+	}
+
+	if (valid_addr_nr <= 0) {
+		pmic_dbg_error = -EINVAL;
+		goto end;
+	}
+
+	if (!strncmp("read", pmic_ops, PMIC_OPS_LEN)) {
+		valid_data_nr = valid_addr_nr;
+		for (i = 0; i < valid_addr_nr; i++) {
+			ret = intel_scu_ipc_ioread8(pmic_reg_addr[i],
+					&pmic_reg_data[i]);
+			if (ret) {
+				pmic_dbg_error = ret;
+				goto end;
+			}
+		}
+	} else if (!strncmp("write", pmic_ops, PMIC_OPS_LEN)) {
+		if (valid_addr_nr == valid_data_nr) {
+			for (i = 0; i < valid_addr_nr; i++) {
+				ret = intel_scu_ipc_iowrite8(pmic_reg_addr[i],
+						pmic_reg_data[i]);
+				if (ret) {
+					pmic_dbg_error = ret;
+					goto end;
+				}
+			}
+		} else {
+			pmic_dbg_error = -EINVAL;
+			goto end;
+		}
+	} else if (!strncmp("update", pmic_ops, PMIC_OPS_LEN)) {
+		if (valid_addr_nr == valid_mask_nr &&
+				valid_mask_nr == valid_bits_nr) {
+			for (i = 0; i < valid_addr_nr; i++) {
+				ret = intel_scu_ipc_update_register(
+						pmic_reg_addr[i],
+						pmic_reg_bits[i],
+						pmic_reg_mask[i]);
+				if (ret) {
+					pmic_dbg_error = ret;
+					goto end;
+				}
+			}
+		} else {
+			pmic_dbg_error = -EINVAL;
+			goto end;
+		}
+	} else {
+		pmic_dbg_error = -EINVAL;
+		goto end;
+	}
+
+		pmic_dbg_error = 0;
+
+end:
+	return size;
+}
+
+static ssize_t pmic_show_error(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "%d\n", pmic_dbg_error);
+}
+
+static KOBJ_PMIC_ATTR(addr, S_IRUGO|S_IWUSR, pmic_addr_show, pmic_addr_store);
+static KOBJ_PMIC_ATTR(bits, S_IRUGO|S_IWUSR, pmic_bits_show, pmic_bits_store);
+static KOBJ_PMIC_ATTR(data, S_IRUGO|S_IWUSR, pmic_data_show, pmic_data_store);
+static KOBJ_PMIC_ATTR(mask, S_IRUGO|S_IWUSR, pmic_mask_show, pmic_mask_store);
+static KOBJ_PMIC_ATTR(ops, S_IWUSR, NULL, pmic_ops_store);
+static KOBJ_PMIC_ATTR(error, S_IRUGO, pmic_show_error, NULL);
+
+static struct attribute *pmic_attrs[] = {
+	&addr_attr.attr,
+	&bits_attr.attr,
+	&data_attr.attr,
+	&mask_attr.attr,
+	&ops_attr.attr,
+	&error_attr.attr,
+	NULL,
+};
+
+static struct attribute_group pmic_attr_group = {
+	.name = "pmic_debug",
+	.attrs = pmic_attrs,
+};
+
+static int pmic_rpmsg_probe(struct rpmsg_channel *rpdev)
+{
+	int ret = 0;
+
+	if (rpdev == NULL) {
+		pr_err("rpmsg channel not created\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	dev_info(&rpdev->dev, "Probed pmic rpmsg device\n");
+
+	/* Allocate rpmsg instance for pmic*/
+	ret = alloc_rpmsg_instance(rpdev, &pmic_instance);
+	if (!pmic_instance) {
+		dev_err(&rpdev->dev, "kzalloc pmic instance failed\n");
+		goto out;
+	}
+	/* Initialize rpmsg instance */
+	init_rpmsg_instance(pmic_instance);
+
+	/* Create debugfs for pmic regs */
+	scu_pmic_kobj = kobject_create_and_add(pmic_attr_group.name,
+						kernel_kobj);
+
+	if (!scu_pmic_kobj) {
+		ret = -ENOMEM;
+		goto rpmsg_err;
+	}
+
+	ret = sysfs_create_group(scu_pmic_kobj, &pmic_attr_group);
+
+	if (ret) {
+		kobject_put(scu_pmic_kobj);
+		goto rpmsg_err;
+	}
+
+	goto out;
+
+rpmsg_err:
+	free_rpmsg_instance(rpdev, &pmic_instance);
+out:
+	return ret;
+}
+
+static void pmic_rpmsg_remove(struct rpmsg_channel *rpdev)
+{
+	free_rpmsg_instance(rpdev, &pmic_instance);
+	sysfs_remove_group(scu_pmic_kobj, &pmic_attr_group);
+	kobject_put(scu_pmic_kobj);
+	dev_info(&rpdev->dev, "Removed pmic rpmsg device\n");
+}
+
+static void pmic_rpmsg_cb(struct rpmsg_channel *rpdev, void *data,
+					int len, void *priv, u32 src)
+{
+	dev_warn(&rpdev->dev, "unexpected, message\n");
+
+	print_hex_dump(KERN_DEBUG, __func__, DUMP_PREFIX_NONE, 16, 1,
+		       data, len,  true);
+}
+
+static struct rpmsg_device_id pmic_rpmsg_id_table[] = {
+	{ .name	= "rpmsg_pmic" },
+	{ },
+};
+MODULE_DEVICE_TABLE(rpmsg, pmic_rpmsg_id_table);
+
+static struct rpmsg_driver pmic_rpmsg = {
+	.drv.name	= KBUILD_MODNAME,
+	.drv.owner	= THIS_MODULE,
+	.id_table	= pmic_rpmsg_id_table,
+	.probe		= pmic_rpmsg_probe,
+	.callback	= pmic_rpmsg_cb,
+	.remove		= pmic_rpmsg_remove,
+};
+
+static int __init pmic_rpmsg_init(void)
+{
+	return register_rpmsg_driver(&pmic_rpmsg);
+}
+
+#ifdef MODULE
+module_init(pmic_rpmsg_init);
+#else
+fs_initcall_sync(pmic_rpmsg_init);
+#endif
+
+static void __exit pmic_rpmsg_exit(void)
+{
+	return unregister_rpmsg_driver(&pmic_rpmsg);
+}
+module_exit(pmic_rpmsg_exit);
+
+MODULE_AUTHOR("Bin Yang<bin.yang@intel.com>");
+MODULE_DESCRIPTION("Intel PMIC Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig
index 3c49330..dbec9a3 100644
--- a/drivers/watchdog/Kconfig
+++ b/drivers/watchdog/Kconfig
@@ -643,6 +643,27 @@ config INTEL_SCU_WATCHDOG
 
 	  To compile this driver as a module, choose M here.
 
+config INTEL_SCU_WATCHDOG_EVO
+	bool "Intel SCU Watchdog Evolution for Mobile Platforms"
+	depends on X86_INTEL_MID
+	---help---
+	  Hardware driver evolution for the watchdog timer built into the Intel
+	  SCU for Intel Mobile Platforms.
+
+	  This driver supports the watchdog evolution implementation in SCU,
+	  available for Merrifield generation.
+
+	  To compile this driver as a module, choose M here.
+
+config DISABLE_SCU_WATCHDOG
+	bool "De-activate Intel SCU Watchdog by cmdline for Mobile Platforms"
+	depends on INTEL_SCU_WATCHDOG || INTEL_SCU_WATCHDOG_EVO
+	---help---
+	  De-activate the watchdog by cmdline for Intel Mobile Platforms.
+	  This allows to use breakpoints without resetting.
+
+	  Only for debug purpose.
+
 config ITCO_WDT
 	tristate "Intel TCO Timer/Watchdog"
 	depends on (X86 || IA64) && PCI
diff --git a/drivers/watchdog/Makefile b/drivers/watchdog/Makefile
index 985a66c..abf5eab 100644
--- a/drivers/watchdog/Makefile
+++ b/drivers/watchdog/Makefile
@@ -113,6 +113,7 @@ obj-$(CONFIG_W83977F_WDT) += w83977f_wdt.o
 obj-$(CONFIG_MACHZ_WDT) += machzwd.o
 obj-$(CONFIG_SBC_EPX_C3_WATCHDOG) += sbc_epx_c3.o
 obj-$(CONFIG_INTEL_SCU_WATCHDOG) += intel_scu_watchdog.o
+obj-$(CONFIG_INTEL_SCU_WATCHDOG_EVO) += intel_scu_watchdog_evo.o
 
 # M32R Architecture
 
diff --git a/drivers/watchdog/intel_scu_watchdog.c b/drivers/watchdog/intel_scu_watchdog.c
deleted file mode 100644
index e13e65e..0000000
--- a/drivers/watchdog/intel_scu_watchdog.c
+++ /dev/null
@@ -1,567 +0,0 @@
-/*
- *      Intel_SCU 0.2:  An Intel SCU IOH Based Watchdog Device
- *			for Intel part #(s):
- *				- AF82MP20 PCH
- *
- *      Copyright (C) 2009-2010 Intel Corporation. All rights reserved.
- *
- *      This program is free software; you can redistribute it and/or
- *      modify it under the terms of version 2 of the GNU General
- *      Public License as published by the Free Software Foundation.
- *
- *      This program is distributed in the hope that it will be
- *      useful, but WITHOUT ANY WARRANTY; without even the implied
- *      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
- *      PURPOSE.  See the GNU General Public License for more details.
- *      You should have received a copy of the GNU General Public
- *      License along with this program; if not, write to the Free
- *      Software Foundation, Inc., 59 Temple Place - Suite 330,
- *      Boston, MA  02111-1307, USA.
- *      The full GNU General Public License is included in this
- *      distribution in the file called COPYING.
- *
- */
-
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
-#include <linux/compiler.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/moduleparam.h>
-#include <linux/types.h>
-#include <linux/miscdevice.h>
-#include <linux/watchdog.h>
-#include <linux/fs.h>
-#include <linux/notifier.h>
-#include <linux/reboot.h>
-#include <linux/init.h>
-#include <linux/jiffies.h>
-#include <linux/uaccess.h>
-#include <linux/slab.h>
-#include <linux/io.h>
-#include <linux/interrupt.h>
-#include <linux/delay.h>
-#include <linux/sched.h>
-#include <linux/signal.h>
-#include <linux/sfi.h>
-#include <asm/irq.h>
-#include <linux/atomic.h>
-#include <asm/intel_scu_ipc.h>
-#include <asm/apb_timer.h>
-#include <asm/intel-mid.h>
-
-#include "intel_scu_watchdog.h"
-
-/* Bounds number of times we will retry loading time count */
-/* This retry is a work around for a silicon bug.	   */
-#define MAX_RETRY 16
-
-#define IPC_SET_WATCHDOG_TIMER	0xF8
-
-static int timer_margin = DEFAULT_SOFT_TO_HARD_MARGIN;
-module_param(timer_margin, int, 0);
-MODULE_PARM_DESC(timer_margin,
-		"Watchdog timer margin"
-		"Time between interrupt and resetting the system"
-		"The range is from 1 to 160"
-		"This is the time for all keep alives to arrive");
-
-static int timer_set = DEFAULT_TIME;
-module_param(timer_set, int, 0);
-MODULE_PARM_DESC(timer_set,
-		"Default Watchdog timer setting"
-		"Complete cycle time"
-		"The range is from 1 to 170"
-		"This is the time for all keep alives to arrive");
-
-/* After watchdog device is closed, check force_boot. If:
- * force_boot == 0, then force boot on next watchdog interrupt after close,
- * force_boot == 1, then force boot immediately when device is closed.
- */
-static int force_boot;
-module_param(force_boot, int, 0);
-MODULE_PARM_DESC(force_boot,
-		"A value of 1 means that the driver will reboot"
-		"the system immediately if the /dev/watchdog device is closed"
-		"A value of 0 means that when /dev/watchdog device is closed"
-		"the watchdog timer will be refreshed for one more interval"
-		"of length: timer_set. At the end of this interval, the"
-		"watchdog timer will reset the system."
-		);
-
-/* there is only one device in the system now; this can be made into
- * an array in the future if we have more than one device */
-
-static struct intel_scu_watchdog_dev watchdog_device;
-
-/* Forces restart, if force_reboot is set */
-static void watchdog_fire(void)
-{
-	if (force_boot) {
-		pr_crit("Initiating system reboot\n");
-		emergency_restart();
-		pr_crit("Reboot didn't ?????\n");
-	}
-
-	else {
-		pr_crit("Immediate Reboot Disabled\n");
-		pr_crit("System will reset when watchdog timer times out!\n");
-	}
-}
-
-static int check_timer_margin(int new_margin)
-{
-	if ((new_margin < MIN_TIME_CYCLE) ||
-	    (new_margin > MAX_TIME - timer_set)) {
-		pr_debug("value of new_margin %d is out of the range %d to %d\n",
-			 new_margin, MIN_TIME_CYCLE, MAX_TIME - timer_set);
-		return -EINVAL;
-	}
-	return 0;
-}
-
-/*
- * IPC operations
- */
-static int watchdog_set_ipc(int soft_threshold, int threshold)
-{
-	u32	*ipc_wbuf;
-	u8	 cbuf[16] = { '\0' };
-	int	 ipc_ret = 0;
-
-	ipc_wbuf = (u32 *)&cbuf;
-	ipc_wbuf[0] = soft_threshold;
-	ipc_wbuf[1] = threshold;
-
-	ipc_ret = intel_scu_ipc_command(
-			IPC_SET_WATCHDOG_TIMER,
-			0,
-			ipc_wbuf,
-			2,
-			NULL,
-			0);
-
-	if (ipc_ret != 0)
-		pr_err("Error setting SCU watchdog timer: %x\n", ipc_ret);
-
-	return ipc_ret;
-};
-
-/*
- *      Intel_SCU operations
- */
-
-/* timer interrupt handler */
-static irqreturn_t watchdog_timer_interrupt(int irq, void *dev_id)
-{
-	int int_status;
-	int_status = ioread32(watchdog_device.timer_interrupt_status_addr);
-
-	pr_debug("irq, int_status: %x\n", int_status);
-
-	if (int_status != 0)
-		return IRQ_NONE;
-
-	/* has the timer been started? If not, then this is spurious */
-	if (watchdog_device.timer_started == 0) {
-		pr_debug("spurious interrupt received\n");
-		return IRQ_HANDLED;
-	}
-
-	/* temporarily disable the timer */
-	iowrite32(0x00000002, watchdog_device.timer_control_addr);
-
-	/* set the timer to the threshold */
-	iowrite32(watchdog_device.threshold,
-		  watchdog_device.timer_load_count_addr);
-
-	/* allow the timer to run */
-	iowrite32(0x00000003, watchdog_device.timer_control_addr);
-
-	return IRQ_HANDLED;
-}
-
-static int intel_scu_keepalive(void)
-{
-
-	/* read eoi register - clears interrupt */
-	ioread32(watchdog_device.timer_clear_interrupt_addr);
-
-	/* temporarily disable the timer */
-	iowrite32(0x00000002, watchdog_device.timer_control_addr);
-
-	/* set the timer to the soft_threshold */
-	iowrite32(watchdog_device.soft_threshold,
-		  watchdog_device.timer_load_count_addr);
-
-	/* allow the timer to run */
-	iowrite32(0x00000003, watchdog_device.timer_control_addr);
-
-	return 0;
-}
-
-static int intel_scu_stop(void)
-{
-	iowrite32(0, watchdog_device.timer_control_addr);
-	return 0;
-}
-
-static int intel_scu_set_heartbeat(u32 t)
-{
-	int			 ipc_ret;
-	int			 retry_count;
-	u32			 soft_value;
-	u32			 hw_pre_value;
-	u32			 hw_value;
-
-	watchdog_device.timer_set = t;
-	watchdog_device.threshold =
-		timer_margin * watchdog_device.timer_tbl_ptr->freq_hz;
-	watchdog_device.soft_threshold =
-		(watchdog_device.timer_set - timer_margin)
-		* watchdog_device.timer_tbl_ptr->freq_hz;
-
-	pr_debug("set_heartbeat: timer freq is %d\n",
-		 watchdog_device.timer_tbl_ptr->freq_hz);
-	pr_debug("set_heartbeat: timer_set is %x (hex)\n",
-		 watchdog_device.timer_set);
-	pr_debug("set_hearbeat: timer_margin is %x (hex)\n", timer_margin);
-	pr_debug("set_heartbeat: threshold is %x (hex)\n",
-		 watchdog_device.threshold);
-	pr_debug("set_heartbeat: soft_threshold is %x (hex)\n",
-		 watchdog_device.soft_threshold);
-
-	/* Adjust thresholds by FREQ_ADJUSTMENT factor, to make the */
-	/* watchdog timing come out right. */
-	watchdog_device.threshold =
-		watchdog_device.threshold / FREQ_ADJUSTMENT;
-	watchdog_device.soft_threshold =
-		watchdog_device.soft_threshold / FREQ_ADJUSTMENT;
-
-	/* temporarily disable the timer */
-	iowrite32(0x00000002, watchdog_device.timer_control_addr);
-
-	/* send the threshold and soft_threshold via IPC to the processor */
-	ipc_ret = watchdog_set_ipc(watchdog_device.soft_threshold,
-				   watchdog_device.threshold);
-
-	if (ipc_ret != 0) {
-		/* Make sure the watchdog timer is stopped */
-		intel_scu_stop();
-		return ipc_ret;
-	}
-
-	/* Soft Threshold set loop. Early versions of silicon did */
-	/* not always set this count correctly.  This loop checks */
-	/* the value and retries if it was not set correctly.     */
-
-	retry_count = 0;
-	soft_value = watchdog_device.soft_threshold & 0xFFFF0000;
-	do {
-
-		/* Make sure timer is stopped */
-		intel_scu_stop();
-
-		if (MAX_RETRY < retry_count++) {
-			/* Unable to set timer value */
-			pr_err("Unable to set timer\n");
-			return -ENODEV;
-		}
-
-		/* set the timer to the soft threshold */
-		iowrite32(watchdog_device.soft_threshold,
-			watchdog_device.timer_load_count_addr);
-
-		/* read count value before starting timer */
-		hw_pre_value = ioread32(watchdog_device.timer_load_count_addr);
-		hw_pre_value = hw_pre_value & 0xFFFF0000;
-
-		/* Start the timer */
-		iowrite32(0x00000003, watchdog_device.timer_control_addr);
-
-		/* read the value the time loaded into its count reg */
-		hw_value = ioread32(watchdog_device.timer_load_count_addr);
-		hw_value = hw_value & 0xFFFF0000;
-
-
-	} while (soft_value != hw_value);
-
-	watchdog_device.timer_started = 1;
-
-	return 0;
-}
-
-/*
- * /dev/watchdog handling
- */
-
-static int intel_scu_open(struct inode *inode, struct file *file)
-{
-
-	/* Set flag to indicate that watchdog device is open */
-	if (test_and_set_bit(0, &watchdog_device.driver_open))
-		return -EBUSY;
-
-	/* Check for reopen of driver. Reopens are not allowed */
-	if (watchdog_device.driver_closed)
-		return -EPERM;
-
-	return nonseekable_open(inode, file);
-}
-
-static int intel_scu_release(struct inode *inode, struct file *file)
-{
-	/*
-	 * This watchdog should not be closed, after the timer
-	 * is started with the WDIPC_SETTIMEOUT ioctl
-	 * If force_boot is set watchdog_fire() will cause an
-	 * immediate reset. If force_boot is not set, the watchdog
-	 * timer is refreshed for one more interval. At the end
-	 * of that interval, the watchdog timer will reset the system.
-	 */
-
-	if (!test_and_clear_bit(0, &watchdog_device.driver_open)) {
-		pr_debug("intel_scu_release, without open\n");
-		return -ENOTTY;
-	}
-
-	if (!watchdog_device.timer_started) {
-		/* Just close, since timer has not been started */
-		pr_debug("closed, without starting timer\n");
-		return 0;
-	}
-
-	pr_crit("Unexpected close of /dev/watchdog!\n");
-
-	/* Since the timer was started, prevent future reopens */
-	watchdog_device.driver_closed = 1;
-
-	/* Refresh the timer for one more interval */
-	intel_scu_keepalive();
-
-	/* Reboot system (if force_boot is set) */
-	watchdog_fire();
-
-	/* We should only reach this point if force_boot is not set */
-	return 0;
-}
-
-static ssize_t intel_scu_write(struct file *file,
-			      char const *data,
-			      size_t len,
-			      loff_t *ppos)
-{
-
-	if (watchdog_device.timer_started)
-		/* Watchdog already started, keep it alive */
-		intel_scu_keepalive();
-	else
-		/* Start watchdog with timer value set by init */
-		intel_scu_set_heartbeat(watchdog_device.timer_set);
-
-	return len;
-}
-
-static long intel_scu_ioctl(struct file *file,
-			   unsigned int cmd,
-			   unsigned long arg)
-{
-	void __user *argp = (void __user *)arg;
-	u32 __user *p = argp;
-	u32 new_margin;
-
-
-	static const struct watchdog_info ident = {
-		.options =          WDIOF_SETTIMEOUT
-				    | WDIOF_KEEPALIVEPING,
-		.firmware_version = 0,  /* @todo Get from SCU via
-						 ipc_get_scu_fw_version()? */
-		.identity =         "Intel_SCU IOH Watchdog"  /* len < 32 */
-	};
-
-	switch (cmd) {
-	case WDIOC_GETSUPPORT:
-		return copy_to_user(argp,
-				    &ident,
-				    sizeof(ident)) ? -EFAULT : 0;
-	case WDIOC_GETSTATUS:
-	case WDIOC_GETBOOTSTATUS:
-		return put_user(0, p);
-	case WDIOC_KEEPALIVE:
-		intel_scu_keepalive();
-
-		return 0;
-	case WDIOC_SETTIMEOUT:
-		if (get_user(new_margin, p))
-			return -EFAULT;
-
-		if (check_timer_margin(new_margin))
-			return -EINVAL;
-
-		if (intel_scu_set_heartbeat(new_margin))
-			return -EINVAL;
-		return 0;
-	case WDIOC_GETTIMEOUT:
-		return put_user(watchdog_device.soft_threshold, p);
-
-	default:
-		return -ENOTTY;
-	}
-}
-
-/*
- *      Notifier for system down
- */
-static int intel_scu_notify_sys(struct notifier_block *this,
-			       unsigned long code,
-			       void *another_unused)
-{
-	if (code == SYS_DOWN || code == SYS_HALT)
-		/* Turn off the watchdog timer. */
-		intel_scu_stop();
-	return NOTIFY_DONE;
-}
-
-/*
- *      Kernel Interfaces
- */
-static const struct file_operations intel_scu_fops = {
-	.owner          = THIS_MODULE,
-	.llseek         = no_llseek,
-	.write          = intel_scu_write,
-	.unlocked_ioctl = intel_scu_ioctl,
-	.open           = intel_scu_open,
-	.release        = intel_scu_release,
-};
-
-static int __init intel_scu_watchdog_init(void)
-{
-	int ret;
-	u32 __iomem *tmp_addr;
-
-	/*
-	 * We don't really need to check this as the SFI timer get will fail
-	 * but if we do so we can exit with a clearer reason and no noise.
-	 *
-	 * If it isn't an intel MID device then it doesn't have this watchdog
-	 */
-	if (!intel_mid_identify_cpu())
-		return -ENODEV;
-
-	/* Check boot parameters to verify that their initial values */
-	/* are in range. */
-	/* Check value of timer_set boot parameter */
-	if ((timer_set < MIN_TIME_CYCLE) ||
-	    (timer_set > MAX_TIME - MIN_TIME_CYCLE)) {
-		pr_err("value of timer_set %x (hex) is out of range from %x to %x (hex)\n",
-		       timer_set, MIN_TIME_CYCLE, MAX_TIME - MIN_TIME_CYCLE);
-		return -EINVAL;
-	}
-
-	/* Check value of timer_margin boot parameter */
-	if (check_timer_margin(timer_margin))
-		return -EINVAL;
-
-	watchdog_device.timer_tbl_ptr = sfi_get_mtmr(sfi_mtimer_num-1);
-
-	if (watchdog_device.timer_tbl_ptr == NULL) {
-		pr_debug("timer is not available\n");
-		return -ENODEV;
-	}
-	/* make sure the timer exists */
-	if (watchdog_device.timer_tbl_ptr->phys_addr == 0) {
-		pr_debug("timer %d does not have valid physical memory\n",
-			 sfi_mtimer_num);
-		return -ENODEV;
-	}
-
-	if (watchdog_device.timer_tbl_ptr->irq == 0) {
-		pr_debug("timer %d invalid irq\n", sfi_mtimer_num);
-		return -ENODEV;
-	}
-
-	tmp_addr = ioremap_nocache(watchdog_device.timer_tbl_ptr->phys_addr,
-			20);
-
-	if (tmp_addr == NULL) {
-		pr_debug("timer unable to ioremap\n");
-		return -ENOMEM;
-	}
-
-	watchdog_device.timer_load_count_addr = tmp_addr++;
-	watchdog_device.timer_current_value_addr = tmp_addr++;
-	watchdog_device.timer_control_addr = tmp_addr++;
-	watchdog_device.timer_clear_interrupt_addr = tmp_addr++;
-	watchdog_device.timer_interrupt_status_addr = tmp_addr++;
-
-	/* Set the default time values in device structure */
-
-	watchdog_device.timer_set = timer_set;
-	watchdog_device.threshold =
-		timer_margin * watchdog_device.timer_tbl_ptr->freq_hz;
-	watchdog_device.soft_threshold =
-		(watchdog_device.timer_set - timer_margin)
-		* watchdog_device.timer_tbl_ptr->freq_hz;
-
-
-	watchdog_device.intel_scu_notifier.notifier_call =
-		intel_scu_notify_sys;
-
-	ret = register_reboot_notifier(&watchdog_device.intel_scu_notifier);
-	if (ret) {
-		pr_err("cannot register notifier %d)\n", ret);
-		goto register_reboot_error;
-	}
-
-	watchdog_device.miscdev.minor = WATCHDOG_MINOR;
-	watchdog_device.miscdev.name = "watchdog";
-	watchdog_device.miscdev.fops = &intel_scu_fops;
-
-	ret = misc_register(&watchdog_device.miscdev);
-	if (ret) {
-		pr_err("cannot register miscdev %d err =%d\n",
-		       WATCHDOG_MINOR, ret);
-		goto misc_register_error;
-	}
-
-	ret = request_irq((unsigned int)watchdog_device.timer_tbl_ptr->irq,
-		watchdog_timer_interrupt,
-		IRQF_SHARED, "watchdog",
-		&watchdog_device.timer_load_count_addr);
-	if (ret) {
-		pr_err("error requesting irq %d\n", ret);
-		goto request_irq_error;
-	}
-	/* Make sure timer is disabled before returning */
-	intel_scu_stop();
-	return 0;
-
-/* error cleanup */
-
-request_irq_error:
-	misc_deregister(&watchdog_device.miscdev);
-misc_register_error:
-	unregister_reboot_notifier(&watchdog_device.intel_scu_notifier);
-register_reboot_error:
-	intel_scu_stop();
-	iounmap(watchdog_device.timer_load_count_addr);
-	return ret;
-}
-
-static void __exit intel_scu_watchdog_exit(void)
-{
-
-	misc_deregister(&watchdog_device.miscdev);
-	unregister_reboot_notifier(&watchdog_device.intel_scu_notifier);
-	/* disable the timer */
-	iowrite32(0x00000002, watchdog_device.timer_control_addr);
-	iounmap(watchdog_device.timer_load_count_addr);
-}
-
-late_initcall(intel_scu_watchdog_init);
-module_exit(intel_scu_watchdog_exit);
-
-MODULE_AUTHOR("Intel Corporation");
-MODULE_DESCRIPTION("Intel SCU Watchdog Device Driver");
-MODULE_LICENSE("GPL");
-MODULE_VERSION(WDT_VER);
diff --git a/drivers/watchdog/intel_scu_watchdog_evo.c b/drivers/watchdog/intel_scu_watchdog_evo.c
new file mode 100644
index 0000000..8aeecc4
--- /dev/null
+++ b/drivers/watchdog/intel_scu_watchdog_evo.c
@@ -0,0 +1,1403 @@
+/*
+ *      Intel_SCU 0.3:  An Intel SCU IOH Based Watchdog Device
+ *			for Intel part #(s):
+ *				- AF82MP20 PCH
+ *
+ *      Copyright (C) 2009-2013 Intel Corporation. All rights reserved.
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of version 2 of the GNU General
+ *      Public License as published by the Free Software Foundation.
+ *
+ *      This program is distributed in the hope that it will be
+ *      useful, but WITHOUT ANY WARRANTY; without even the implied
+ *      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *      PURPOSE.  See the GNU General Public License for more details.
+ *      You should have received a copy of the GNU General Public
+ *      License along with this program; if not, write to the Free
+ *      Software Foundation, Inc., 59 Temple Place - Suite 330,
+ *      Boston, MA  02111-1307, USA.
+ *      The full GNU General Public License is included in this
+ *      distribution in the file called COPYING.
+ *
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+/* See Documentation/watchdog/intel-scu-watchdog.txt */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/watchdog.h>
+#include <linux/reboot.h>
+#include <linux/interrupt.h>
+#include <linux/kernel_stat.h>
+#include <linux/rpmsg.h>
+#include <linux/nmi.h>
+#include <asm/intel_scu_ipcutil.h>
+#include <asm/intel_mid_rpmsg.h>
+#include <asm/intel-mid.h>
+
+#include "intel_scu_watchdog_evo.h"
+
+/* Adjustment flags */
+#define CONFIG_INTEL_SCU_SOFT_LOCKUP
+#define CONFIG_DEBUG_WATCHDOG
+
+/* Defines */
+#define STRING_RESET_TYPE_MAX_LEN   11
+#define STRING_COLD_OFF             "COLD_OFF"
+#define STRING_COLD_RESET           "COLD_RESET"
+#define STRING_COLD_BOOT            "COLD_BOOT"
+
+#define EXT_TIMER0_MSI 12
+
+#define IPC_WATCHDOG 0xF8
+
+enum {
+	SCU_WATCHDOG_START = 0,
+	SCU_WATCHDOG_STOP,
+	SCU_WATCHDOG_KEEPALIVE,
+	SCU_WATCHDOG_SET_ACTION_ON_TIMEOUT
+};
+
+enum {
+	SCU_COLD_OFF_ON_TIMEOUT = 0,
+	SCU_COLD_RESET_ON_TIMEOUT,
+	SCU_COLD_BOOT_ON_TIMEOUT,
+	SCU_DO_NOTHING_ON_TIMEOUT
+};
+
+#ifdef CONFIG_DEBUG_FS
+#define SECURITY_WATCHDOG_ADDR  0xFF222230
+#define STRING_NONE "NONE"
+#endif
+
+/* Statics */
+static int reset_type_to_string(int reset_type, char *string);
+static int string_to_reset_type(const char *string, int *reset_type);
+static struct intel_scu_watchdog_dev watchdog_device;
+static unsigned char osnib_reset = OSNIB_WRITE_VALUE;
+
+/* Module params */
+static bool kicking_active = true;
+#ifdef CONFIG_DEBUG_WATCHDOG
+module_param(kicking_active, bool, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(kicking_active,
+		"Deactivate the kicking will result in a cold reset"
+		"after a while");
+#endif
+
+static bool disable_kernel_watchdog = false;
+#ifdef CONFIG_DISABLE_SCU_WATCHDOG
+/*
+ * Please note that we are using a config CONFIG_DISABLE_SCU_WATCHDOG
+ * because this boot parameter should only be settable in a developement
+ */
+module_param(disable_kernel_watchdog, bool, S_IRUGO);
+MODULE_PARM_DESC(disable_kernel_watchdog,
+		"Disable kernel watchdog"
+		"Set to 0, watchdog started at boot"
+		"and left running; Set to 1; watchdog"
+		"is not started until user space"
+		"watchdog daemon is started; also if the"
+		"timer is started by the iafw firmware, it"
+		"will be disabled upon initialization of this"
+		"driver if disable_kernel_watchdog is set");
+#endif
+
+static int pre_timeout = DEFAULT_PRETIMEOUT;
+
+static int timeout = DEFAULT_TIMEOUT;
+module_param(timeout, int, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(timeout,
+		"Default Watchdog timer setting"
+		"Complete cycle time"
+		"The range is from 35 to 170"
+		"This is the time for all keep alives to arrive");
+
+static bool reset_on_release = true;
+
+#ifdef CONFIG_INTEL_SCU_SOFT_LOCKUP
+/*
+ * heartbeats: cpu last kstat.system times
+ * beattime : jiffies at the sample time of heartbeats.
+ * SOFT_LOCK_TIME : some time out in sec after warning interrupt.
+ * dump_softloc_debug : called on SOFT_LOCK_TIME time out after scu
+ *	interrupt to log data to logbuffer and emmc-panic code,
+ *	SOFT_LOCK_TIME needs to be < SCU warn to reset time
+ *	which is currently thats 15 sec.
+ *
+ * The soft lock works be taking a snapshot of kstat_cpu(i).cpustat.system at
+ * the time of the warning interrupt for each cpu.  Then at SOFT_LOCK_TIME the
+ * amount of time spend in system is computed and if its within 10 ms of the
+ * total SOFT_LOCK_TIME on any cpu it will dump the stack on that cpu and then
+ * calls panic.
+ *
+ */
+static u64 heartbeats[NR_CPUS];
+static u64 beattime;
+#define SOFT_LOCK_TIME 10
+static void dump_softlock_debug(unsigned long data);
+DEFINE_TIMER(softlock_timer, dump_softlock_debug, 0, 0);
+
+static struct rpmsg_instance *watchdog_instance;
+
+/* time is about to run out and the scu will reset soon.  quickly
+ * dump debug data to logbuffer and emmc via calling panic before lights
+ * go out.
+ */
+static void smp_dumpstack(void *info)
+{
+	dump_stack();
+}
+
+static void dump_softlock_debug(unsigned long data)
+{
+	int i, reboot;
+	u64 system[NR_CPUS], num_jifs;
+
+	memset(system, 0, NR_CPUS*sizeof(u64));
+
+	num_jifs = jiffies - beattime;
+	for_each_possible_cpu(i) {
+		system[i] = kcpustat_cpu(i).cpustat[CPUTIME_SYSTEM] -
+				heartbeats[i];
+	}
+
+	reboot = 0;
+
+	for_each_possible_cpu(i) {
+		if ((num_jifs - cputime_to_jiffies(system[i])) <
+						msecs_to_jiffies(10)) {
+			WARN(1, "cpu %d wedged\n", i);
+			smp_call_function_single(i, smp_dumpstack, NULL, 1);
+			reboot = 1;
+		}
+	}
+
+	if (reboot) {
+		panic_timeout = 10;
+		trigger_all_cpu_backtrace();
+		panic("Soft lock on CPUs\n");
+	}
+}
+#endif /* CONFIG_INTEL_SCU_SOFT_LOCKUP */
+
+/* Check current timeouts */
+/* Timeout bounds come from the MODULE_PARAM_DESC description */
+static int check_timeouts(int pre_timeout_time, int timeout_time)
+{
+	if (pre_timeout_time >= timeout_time)
+		return -EINVAL;
+	if (pre_timeout_time > 155 || pre_timeout_time < 1)
+		return -EINVAL;
+	if (timeout_time > 170 || timeout_time < 35)
+		return -EINVAL;
+
+	return 0;
+}
+
+/* Set the different timeouts needed by the SCU FW and start the
+ * kernel watchdog */
+static int watchdog_set_timeouts_and_start(int pretimeout,
+					   int timeout)
+{
+	int ret, error = 0;
+	struct ipc_wd_start {
+		u32 pretimeout;
+		u32 timeout;
+	} ipc_wd_start = { pretimeout, timeout };
+
+	ret = rpmsg_send_command(watchdog_instance, IPC_WATCHDOG,
+				 SCU_WATCHDOG_START, (u8 *)&ipc_wd_start,
+				 NULL, sizeof(ipc_wd_start), 0);
+	if (ret) {
+		pr_crit("Error configuring and starting watchdog: %d\n",
+			ret);
+		error = -EIO;
+	}
+
+	return error;
+}
+
+/* Provisioning function for future enhancement : allow to fine tune timing
+   according to watchdog action settings */
+static int watchdog_set_appropriate_timeouts(void)
+{
+	pr_debug("Setting shutdown timeouts\n");
+	return watchdog_set_timeouts_and_start(pre_timeout, timeout);
+}
+
+/* Keep alive  */
+static int watchdog_keepalive(void)
+{
+	int ret, error = 0;
+
+	pr_debug("%s\n", __func__);
+
+	if (unlikely(!kicking_active)) {
+		/* Close our eyes */
+		pr_err("Transparent kicking\n");
+		return 0;
+	}
+
+	/* Really kick it */
+	ret = rpmsg_send_simple_command(watchdog_instance, IPC_WATCHDOG,
+					SCU_WATCHDOG_KEEPALIVE);
+	if (ret) {
+		pr_crit("Error executing keepalive: %x\n", ret);
+		error = -EIO;
+	}
+
+	return error;
+}
+
+/* stops the timer */
+static int watchdog_stop(void)
+{
+	int ret = 0;
+	int error = 0;
+
+	pr_crit("%s\n", __func__);
+
+	ret = rpmsg_send_simple_command(watchdog_instance, IPC_WATCHDOG,
+					SCU_WATCHDOG_STOP);
+	if (ret) {
+		pr_crit("Error stopping watchdog: %x\n", ret);
+		error = -EIO;
+	}
+
+	watchdog_device.started = false;
+
+	return error;
+}
+
+/* warning interrupt handler */
+static irqreturn_t watchdog_warning_interrupt(int irq, void *dev_id)
+{
+	if (unlikely(!kicking_active))
+		pr_warn("[SHTDWN] WATCHDOG TIMEOUT for test!, %s\n", __func__);
+
+	else
+		pr_warn("[SHTDWN] %s, WATCHDOG TIMEOUT!\n", __func__);
+
+	/* Let's reset the platform after dumping some data */
+	trigger_all_cpu_backtrace();
+	panic("Kernel Watchdog");
+
+	/* This code should not be reached */
+	return IRQ_HANDLED;
+}
+
+/* Program and starts the timer */
+static int watchdog_config_and_start(u32 newtimeout, u32 newpretimeout)
+{
+	int ret;
+
+	timeout = newtimeout;
+	pre_timeout = newpretimeout;
+
+	pr_debug("timeout=%ds, pre_timeout=%ds\n", timeout, pre_timeout);
+
+	/* Configure the watchdog */
+	ret = watchdog_set_timeouts_and_start(pre_timeout, timeout);
+	if (ret) {
+		pr_err("%s: Cannot configure the watchdog\n", __func__);
+
+		/* Make sure the watchdog timer is stopped */
+		watchdog_stop();
+		return ret;
+	}
+
+	watchdog_device.started = true;
+
+	return 0;
+}
+
+/* Open */
+static int intel_scu_open(struct inode *inode, struct file *file)
+{
+	/* Set flag to indicate that watchdog device is open */
+	if (test_and_set_bit(0, &watchdog_device.driver_open)) {
+		pr_err("watchdog device is busy\n");
+		return -EBUSY;
+	}
+
+	/* Check for reopen of driver. Reopens are not allowed */
+	if (watchdog_device.driver_closed) {
+		pr_err("watchdog device has been closed\n");
+		return -EPERM;
+	}
+
+	return nonseekable_open(inode, file);
+}
+
+/* Release */
+static int intel_scu_release(struct inode *inode, struct file *file)
+{
+	/*
+	 * This watchdog should not be closed, after the timer
+	 * is started with the WDIPC_SETTIMEOUT ioctl
+	 * If reset_on_release is set this  will cause an
+	 * immediate reset. If reset_on_release is not set, the watchdog
+	 * timer is refreshed for one more interval. At the end
+	 * of that interval, the watchdog timer will reset the system.
+	 */
+
+	if (!test_bit(0, &watchdog_device.driver_open)) {
+		pr_err("intel_scu_release, without open\n");
+		return -ENOTTY;
+	}
+
+	if (!watchdog_device.started) {
+		/* Just close, since timer has not been started */
+		pr_err("Closed, without starting timer\n");
+		return 0;
+	}
+
+	pr_crit("Unexpected close of /dev/watchdog!\n");
+
+	/* Since the timer was started, prevent future reopens */
+	watchdog_device.driver_closed = 1;
+
+	/* Refresh the timer for one more interval */
+	watchdog_keepalive();
+
+	/* Reboot system if requested */
+	if (reset_on_release) {
+		pr_crit("Initiating system reboot.\n");
+		emergency_restart();
+	}
+
+	pr_crit("Immediate Reboot Disabled\n");
+	pr_crit("System will reset when watchdog timer expire!\n");
+
+	return 0;
+}
+
+/* Write */
+static ssize_t intel_scu_write(struct file *file, char const *data, size_t len,
+			      loff_t *ppos)
+{
+	pr_debug("watchdog %s\n", __func__);
+
+	if (watchdog_device.shutdown_flag == true)
+		/* do nothing if we are shutting down */
+		return len;
+
+	if (watchdog_device.started) {
+		/* Watchdog already started, keep it alive */
+		watchdog_keepalive();
+	}
+
+	return len;
+}
+
+/* ioctl */
+static long intel_scu_ioctl(struct file *file, unsigned int cmd,
+			    unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	u32 __user *p = argp;
+	u32 val;
+	u32 new_pre_timeout;
+	int options;
+
+	static const struct watchdog_info ident = {
+		.options = WDIOF_SETTIMEOUT | WDIOF_KEEPALIVEPING,
+		/* @todo Get from SCU via ipc_get_scu_fw_version()? */
+		.firmware_version = 0,
+		/* len < 32 */
+		.identity = "Intel_SCU IOH Watchdog"
+	};
+
+	switch (cmd) {
+	case WDIOC_GETSUPPORT:
+		return copy_to_user(argp, &ident,
+				    sizeof(ident)) ? -EFAULT : 0;
+	case WDIOC_GETSTATUS:
+	case WDIOC_GETBOOTSTATUS:
+		return put_user(0, p);
+	case WDIOC_KEEPALIVE:
+		pr_debug("%s: KeepAlive ioctl\n", __func__);
+		if (!watchdog_device.started)
+			return -EINVAL;
+
+		watchdog_keepalive();
+		return 0;
+	case WDIOC_SETTIMEOUT:
+		pr_debug("%s: SetTimeout ioctl\n", __func__);
+
+		if (watchdog_device.started)
+			return -EBUSY;
+
+		if (get_user(val, p))
+			return -EFAULT;
+		new_pre_timeout = val-15;
+		if (check_timeouts(new_pre_timeout, val)) {
+			pr_warn("%s: Invalid timeout thresholds (timeout: %d, pretimeout: %d) \n", __func__, val, new_pre_timeout);
+			return -EINVAL;
+		}
+
+		pre_timeout = new_pre_timeout;
+		timeout = val;
+		return 0;
+	case WDIOC_GETTIMEOUT:
+		return put_user(timeout, p);
+	case WDIOC_SETOPTIONS:
+		if (get_user(options, p))
+			return -EFAULT;
+
+		if (options & WDIOS_DISABLECARD) {
+			pr_debug("%s: Stopping the watchdog\n", __func__);
+			watchdog_stop();
+			return 0;
+		}
+
+		if (options & WDIOS_ENABLECARD) {
+			pr_debug("%s: Starting the watchdog\n", __func__);
+
+			if (watchdog_device.started)
+				return -EBUSY;
+
+			if (check_timeouts(pre_timeout, timeout)) {
+				pr_warn("%s: Invalid thresholds\n",
+					__func__);
+				return -EINVAL;
+			}
+			if (watchdog_config_and_start(timeout, pre_timeout))
+				return -EINVAL;
+			return 0;
+		}
+		return 0;
+	default:
+		return -ENOTTY;
+	}
+}
+
+static int watchdog_set_reset_type(int reset_type)
+{
+	int ret;
+	struct ipc_wd_on_timeout {
+		u32 reset_type;
+	} ipc_wd_on_timeout = { reset_type };
+
+	ret = rpmsg_send_command(watchdog_instance, IPC_WATCHDOG,
+				 SCU_WATCHDOG_SET_ACTION_ON_TIMEOUT,
+				 (u8 *)&ipc_wd_on_timeout, NULL,
+				 sizeof(ipc_wd_on_timeout), 0);
+	if (ret) {
+		pr_crit("Error setting watchdog action: %d\n", ret);
+		return -EIO;
+	}
+
+	watchdog_device.normal_wd_action = reset_type;
+
+	return 0;
+}
+
+/* Reboot notifier */
+static int reboot_notifier(struct notifier_block *this,
+			   unsigned long code,
+			   void *another_unused)
+{
+	int ret;
+
+	if (code == SYS_RESTART || code == SYS_HALT || code == SYS_POWER_OFF) {
+		pr_warn("Reboot notifier\n");
+
+		if (watchdog_set_appropriate_timeouts())
+			pr_crit("reboot notifier cant set time\n");
+
+		switch (code) {
+		case SYS_RESTART:
+			ret = watchdog_set_reset_type(
+				watchdog_device.reboot_wd_action);
+			break;
+
+		case SYS_HALT:
+		case SYS_POWER_OFF:
+			ret = watchdog_set_reset_type(
+				watchdog_device.shutdown_wd_action);
+			break;
+		}
+		if (ret)
+			pr_err("%s: could not set reset type\n", __func__);
+
+#ifdef CONFIG_DEBUG_FS
+		/* debugfs entry to generate a BUG during
+		any shutdown/reboot call */
+		if (watchdog_device.panic_reboot_notifier)
+			BUG();
+#endif
+		/* Don't do instant reset on close */
+		reset_on_release = false;
+
+		/* Kick once again */
+		if (disable_kernel_watchdog == false) {
+			ret = watchdog_keepalive();
+			if (ret)
+				pr_warn("%s: no keep alive\n", __func__);
+
+			/* Don't allow any more keep-alives */
+			watchdog_device.shutdown_flag = true;
+		}
+	}
+	return NOTIFY_DONE;
+}
+
+#ifdef CONFIG_DEBUG_FS
+/* This code triggers a Security Watchdog */
+int open_security(struct inode *i, struct file *f)
+{
+	int ret = 0;
+	u64 *ptr;
+	u32 value;
+
+	ptr = ioremap_nocache(SECURITY_WATCHDOG_ADDR, sizeof(u32));
+
+	if (!ptr) {
+		pr_err("cannot open secwd's debugfile\n");
+		ret = -ENODEV;
+		goto error;
+	}
+	value = readl(ptr); /* trigger */
+
+	pr_err("%s: This code should never be reached but it got %x\n",
+		__func__, (unsigned int)value);
+
+error:
+	return ret;
+}
+
+static const struct file_operations security_watchdog_fops = {
+	.open = open_security,
+};
+
+static int kwd_trigger_write(struct file *file, const char __user *buff,
+			     size_t count, loff_t *ppos)
+{
+	pr_debug("kwd_trigger_write\n");
+	panic("Kernel watchdog triggered\n");
+	return 0;
+}
+
+static const struct file_operations kwd_trigger_fops = {
+	.open		= nonseekable_open,
+	.write		= kwd_trigger_write,
+	.llseek		= no_llseek,
+};
+
+static int kwd_reset_type_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static ssize_t kwd_reset_type_read(struct file *file, char __user *buff,
+				   size_t count, loff_t *ppos)
+{
+	ssize_t len;
+	int ret;
+	char str[STRING_RESET_TYPE_MAX_LEN + 1];
+
+	pr_debug("reading reset_type of %x\n",
+		 watchdog_device.normal_wd_action);
+
+	if (*ppos > 0)
+		return 0;
+
+	ret = reset_type_to_string(watchdog_device.normal_wd_action, str);
+	if (ret)
+		return -EINVAL;
+	else {
+		for (len = 0; len < (STRING_RESET_TYPE_MAX_LEN - 1)
+			     && str[len] != '\0'; len++)
+			;
+		str[len++] = '\n';
+		ret = copy_to_user(buff, str, len);
+	}
+
+	*ppos += len;
+	return len;
+}
+
+static ssize_t kwd_reset_type_write(struct file *file, const char __user *buff,
+				    size_t count, loff_t *ppos)
+{
+	char str[STRING_RESET_TYPE_MAX_LEN];
+	unsigned long res;
+	int ret, reset_type;
+
+	if (count > STRING_RESET_TYPE_MAX_LEN) {
+		pr_err("Invalid size: count=%d\n", count);
+		return -EINVAL;
+	}
+
+	memset(str, 0x00, STRING_RESET_TYPE_MAX_LEN);
+
+	res = copy_from_user((void *)str,
+		(void __user *)buff,
+		(unsigned long)min((unsigned long)(count-1),
+		(unsigned long)(STRING_RESET_TYPE_MAX_LEN-1)));
+
+	if (res) {
+		pr_err("%s: copy to user failed\n", __func__);
+		return -EINVAL;
+	}
+
+	pr_debug("writing reset_type of %s\n", str);
+
+	ret = string_to_reset_type(str, &reset_type);
+	if (ret) {
+		pr_err("Invalid value\n");
+		return -EINVAL;
+	}
+
+	ret = watchdog_set_reset_type(reset_type);
+	if (ret) {
+		pr_err("%s: could not set reset type\n", __func__);
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+static const struct file_operations kwd_reset_type_fops = {
+	.open		= nonseekable_open,
+	.release	= kwd_reset_type_release,
+	.read		= kwd_reset_type_read,
+	.write		= kwd_reset_type_write,
+	.llseek		= no_llseek,
+};
+
+static ssize_t kwd_panic_reboot_read(struct file *file, char __user *buff,
+		size_t count, loff_t *ppos)
+{
+	# define RET_SIZE 3 /* prints only 2 chars : '0' or '1', plus '\n' */
+	char str[RET_SIZE];
+
+	int res;
+
+	if (*ppos > 0)
+		return 0;
+
+	strcpy(str, watchdog_device.panic_reboot_notifier ? "1\n" : "0\n");
+
+	res = copy_to_user(buff, str, RET_SIZE);
+	if (res) {
+		pr_err("%s: copy to user failed\n", __func__);
+		return -EINVAL;
+	}
+
+	*ppos += RET_SIZE-1;
+	return RET_SIZE-1;
+}
+
+
+static ssize_t kwd_panic_reboot_write(struct file *file,
+		const char __user *buff, size_t count, loff_t *ppos)
+{
+	/* whatever is written, simply set flag to TRUE */
+	watchdog_device.panic_reboot_notifier = true;
+
+	return count;
+}
+
+
+static const struct file_operations kwd_panic_reboot_fops = {
+	.open		= nonseekable_open,
+	.read		= kwd_panic_reboot_read,
+	.write		= kwd_panic_reboot_write,
+	.llseek		= no_llseek,
+};
+
+static int remove_debugfs_entries(void)
+{
+struct intel_scu_watchdog_dev *dev = &watchdog_device;
+
+	/* /sys/kernel/debug/watchdog */
+	debugfs_remove_recursive(dev->dfs_wd);
+
+	return 0;
+}
+
+static int create_debugfs_entries(void)
+{
+	struct intel_scu_watchdog_dev *dev = &watchdog_device;
+
+	/* /sys/kernel/debug/watchdog */
+	dev->dfs_wd = debugfs_create_dir("watchdog", NULL);
+	if (!dev->dfs_wd) {
+		pr_err("%s: Error, cannot create main dir\n", __func__);
+		goto error;
+	}
+
+	/* /sys/kernel/debug/watchdog/security_watchdog */
+	dev->dfs_secwd = debugfs_create_dir("security_watchdog", dev->dfs_wd);
+	if (!dev->dfs_secwd) {
+		pr_err("%s: Error, cannot create sec dir\n", __func__);
+		goto error;
+	}
+
+	/* /sys/kernel/debug/watchdog/security_watchdog/trigger */
+	dev->dfs_secwd_trigger = debugfs_create_file("trigger",
+				    S_IFREG | S_IRUGO | S_IWUSR | S_IWGRP,
+				    dev->dfs_secwd, NULL,
+				    &security_watchdog_fops);
+
+	if (!dev->dfs_secwd_trigger) {
+		pr_err("%s: Error, cannot create sec file\n", __func__);
+		goto error;
+	}
+
+	/* /sys/kernel/debug/watchdog/kernel_watchdog */
+	dev->dfs_kwd = debugfs_create_dir("kernel_watchdog", dev->dfs_wd);
+	if (!dev->dfs_kwd) {
+		pr_err("%s: Error, cannot create kwd dir\n", __func__);
+		goto error;
+	}
+
+	/* /sys/kernel/debug/watchdog/kernel_watchdog/trigger */
+	dev->dfs_kwd_trigger = debugfs_create_file("trigger",
+				    S_IFREG | S_IWUSR | S_IWGRP,
+				    dev->dfs_kwd, NULL,
+				    &kwd_trigger_fops);
+
+	if (!dev->dfs_kwd_trigger) {
+		pr_err("%s: Error, cannot create kwd trigger file\n",
+			__func__);
+		goto error;
+	}
+
+	/* /sys/kernel/debug/watchdog/kernel_watchdog/reset_type */
+	dev->dfs_kwd_trigger = debugfs_create_file("reset_type",
+				    S_IFREG | S_IRUGO | S_IWUSR | S_IWGRP,
+				    dev->dfs_kwd, NULL,
+				    &kwd_reset_type_fops);
+
+	if (!dev->dfs_kwd_trigger) {
+		pr_err("%s: Error, cannot create kwd trigger file\n",
+			__func__);
+		goto error;
+	}
+
+	/* /sys/kernel/debug/watchdog/kernel_watchdog/panic_reboot_notifier */
+	dev->dfs_kwd_panic_reboot = debugfs_create_file("panic_reboot_notifier",
+					S_IFREG | S_IRUGO | S_IWUSR | S_IWGRP,
+					dev->dfs_kwd, NULL,
+					&kwd_panic_reboot_fops);
+
+	if (!dev->dfs_kwd_panic_reboot) {
+		pr_err("%s: Error, cannot create kwd panic_reboot_notifier file\n",
+			__func__);
+		goto error;
+	}
+
+
+	return 0;
+error:
+	remove_debugfs_entries();
+	return 1;
+}
+#endif  /* CONFIG_DEBUG_FS*/
+
+/* Kernel Interfaces */
+static const struct file_operations intel_scu_fops = {
+	.owner          = THIS_MODULE,
+	.llseek         = no_llseek,
+	.write          = intel_scu_write,
+	.unlocked_ioctl = intel_scu_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl	= intel_scu_ioctl,
+#endif
+	.open           = intel_scu_open,
+	.release        = intel_scu_release,
+};
+
+/* sysfs entry to disable watchdog */
+#ifdef CONFIG_DISABLE_SCU_WATCHDOG
+static ssize_t disable_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t size)
+{
+	int ret;
+
+	if (!strtobool(buf, &disable_kernel_watchdog)) {
+		if (disable_kernel_watchdog) {
+			ret = watchdog_stop();
+			if (ret)
+				pr_err("cannot disable the timer\n");
+		} else {
+			ret = watchdog_config_and_start(timeout, pre_timeout);
+			if (ret)
+				return -EINVAL;
+		}
+	} else {
+		pr_err("got invalid value\n");
+		return -EINVAL;
+	}
+
+	return size;
+}
+
+static ssize_t disable_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	pr_debug("%s\n", __func__);
+	if (disable_kernel_watchdog)
+		return sprintf(buf, "1\n");
+
+	return sprintf(buf, "0\n");
+}
+
+static DEVICE_ATTR(disable, S_IWUSR | S_IRUGO,
+	disable_show, disable_store);
+
+#endif
+
+#define OSNIB_WDOG_COUNTER_MASK 0xF0
+#define OSNIB_WDOG_COUNTER_SHIFT 4
+#define WDOG_COUNTER_MAX_VALUE   3
+static ssize_t counter_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t size)
+{
+	int ret;
+
+	pr_debug("%s\n", __func__);
+
+	ret = sscanf(buf, "%hhu", &osnib_reset);
+	if (ret != 1) {
+		pr_err(PFX "cannot get counter value\n");
+		if (ret == 0)
+			ret = -EINVAL;
+		return ret;
+	}
+	if (osnib_reset > WDOG_COUNTER_MAX_VALUE)
+		osnib_reset = WDOG_COUNTER_MAX_VALUE;
+	osnib_reset = ((osnib_reset << OSNIB_WDOG_COUNTER_SHIFT) &
+				OSNIB_WDOG_COUNTER_MASK);
+	ret = intel_scu_ipc_write_osnib_wd(&osnib_reset);
+
+	if (ret != 0) {
+		pr_err(PFX "cannot write OSNIB\n");
+		return -EINVAL;
+	}
+
+	return size;
+}
+
+
+static ssize_t counter_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	unsigned char osnib_read = (unsigned char)0;
+	int ret;
+	pr_debug("%s\n", __func__);
+
+	ret = intel_scu_ipc_read_osnib_wd(&osnib_read);
+
+	if (ret != 0)
+		return -EIO;
+
+	return sprintf(buf, "%d\n", (int)((osnib_read & OSNIB_WDOG_COUNTER_MASK)
+						>> OSNIB_WDOG_COUNTER_SHIFT));
+}
+
+static int reset_type_to_string(int reset_type, char *string)
+{
+	switch (reset_type) {
+	case SCU_COLD_BOOT_ON_TIMEOUT:
+		strcpy(string, STRING_COLD_BOOT);
+		break;
+	case SCU_COLD_RESET_ON_TIMEOUT:
+		strcpy(string, STRING_COLD_RESET);
+		break;
+	case SCU_COLD_OFF_ON_TIMEOUT:
+		strcpy(string, STRING_COLD_OFF);
+		break;
+#ifdef CONFIG_DEBUG_FS
+	case SCU_DO_NOTHING_ON_TIMEOUT:
+		/* The IPC command DONOTHING is provided */
+		/* for debug purpose only.               */
+		strcpy(string, STRING_NONE);
+		break;
+#endif
+	default:
+		return 1;
+	}
+
+	return 0;
+}
+
+static int string_to_reset_type(const char *string, int *reset_type)
+{
+	if (!reset_type || !string)
+		return 1;
+
+	if (strncmp(string, STRING_COLD_RESET,
+			sizeof(STRING_COLD_RESET) - 1) == 0) {
+		*reset_type = SCU_COLD_RESET_ON_TIMEOUT;
+		return 0;
+	}
+	if (strncmp(string, STRING_COLD_BOOT,
+			sizeof(STRING_COLD_BOOT) - 1) == 0) {
+		*reset_type = SCU_COLD_BOOT_ON_TIMEOUT;
+		return 0;
+	}
+	if (strncmp(string, STRING_COLD_OFF,
+			sizeof(STRING_COLD_OFF) - 1) == 0) {
+		*reset_type = SCU_COLD_OFF_ON_TIMEOUT;
+		return 0;
+	}
+#ifdef CONFIG_DEBUG_FS
+	if (strncmp(string, STRING_NONE,
+			sizeof(STRING_NONE) - 1) == 0) {
+		*reset_type = SCU_DO_NOTHING_ON_TIMEOUT;
+		return 0;
+	}
+#endif
+	/* We should not be here, this is an error case */
+	pr_debug("Invalid reset type value\n");
+	return 1;
+}
+
+static ssize_t reboot_ongoing_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t size)
+{
+	int ret;
+
+	pr_debug("%s\n", __func__);
+	/* reprogram timeouts. if error : continue */
+	ret = watchdog_set_appropriate_timeouts();
+	if (ret)
+		pr_err("%s: could not set timeouts\n", __func__);
+
+	/* restore reset type */
+	watchdog_set_reset_type(watchdog_device.reboot_wd_action);
+	if (ret) {
+		pr_err("%s: could not set reset type\n", __func__);
+		return -EINVAL;
+	}
+
+	return size;
+}
+
+static ssize_t shutdown_ongoing_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t size)
+{
+	int ret;
+
+	pr_debug("%s\n", __func__);
+	/* reprogram timeouts. if error : continue */
+	ret = watchdog_set_appropriate_timeouts();
+	if (ret)
+		pr_err("%s: could not set timeouts\n", __func__);
+
+	/* restore reset type */
+	watchdog_set_reset_type(watchdog_device.shutdown_wd_action);
+	if (ret) {
+		pr_err("%s: could not set reset type\n", __func__);
+		return -EINVAL;
+	}
+
+	return size;
+}
+
+static ssize_t normal_config_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	if (reset_type_to_string(watchdog_device.normal_wd_action, buf) != 0)
+		return -EINVAL;
+	strcat(buf, "\n");
+	return strlen(buf);
+}
+
+static ssize_t normal_config_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t size)
+{
+	if (string_to_reset_type(buf, &watchdog_device.normal_wd_action) != 0)
+		return -EINVAL;
+	if (watchdog_set_reset_type(watchdog_device.normal_wd_action) != 0)
+		return -EINVAL;
+
+	return size;
+}
+
+static ssize_t reboot_config_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	if (reset_type_to_string(watchdog_device.reboot_wd_action, buf) != 0)
+		return -EINVAL;
+	strcat(buf, "\n");
+	return strlen(buf);
+}
+
+static ssize_t reboot_config_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t size)
+{
+	if (string_to_reset_type(buf, &watchdog_device.reboot_wd_action) != 0)
+		return -EINVAL;
+
+	return size;
+}
+
+static ssize_t shutdown_config_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	if (reset_type_to_string(watchdog_device.shutdown_wd_action, buf) != 0)
+		return -EINVAL;
+	strcat(buf, "\n");
+	return strlen(buf);
+}
+
+static ssize_t shutdown_config_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t size)
+{
+	if (string_to_reset_type(buf, &watchdog_device.shutdown_wd_action) != 0)
+		return -EINVAL;
+
+	return size;
+}
+
+/* Watchdog behavior depending on system phase */
+static DEVICE_ATTR(normal_config, S_IWUSR | S_IRUGO,
+	normal_config_show, normal_config_store);
+static DEVICE_ATTR(reboot_config, S_IWUSR | S_IRUGO,
+	reboot_config_show, reboot_config_store);
+static DEVICE_ATTR(shutdown_config, S_IWUSR | S_IRUGO,
+	shutdown_config_show, shutdown_config_store);
+static DEVICE_ATTR(reboot_ongoing, S_IWUSR,
+	NULL, reboot_ongoing_store);
+static DEVICE_ATTR(shutdown_ongoing, S_IWUSR,
+	NULL, shutdown_ongoing_store);
+
+/* Reset counter watchdog entry */
+static DEVICE_ATTR(counter, S_IWUSR | S_IRUGO,
+	counter_show, counter_store);
+
+
+int create_watchdog_sysfs_files(void)
+{
+	int ret;
+
+#ifdef CONFIG_DISABLE_SCU_WATCHDOG
+	ret = device_create_file(watchdog_device.miscdev.this_device,
+		&dev_attr_disable);
+	if (ret) {
+		pr_warn("cant register dev file for disable\n");
+		return ret;
+	}
+#endif
+
+	ret = device_create_file(watchdog_device.miscdev.this_device,
+		&dev_attr_normal_config);
+	if (ret) {
+		pr_warn("cant register dev file for normal_config\n");
+		return ret;
+	}
+
+	ret = device_create_file(watchdog_device.miscdev.this_device,
+		&dev_attr_reboot_config);
+	if (ret) {
+		pr_warn("cant register dev file for reboot_config\n");
+		return ret;
+	}
+
+	ret = device_create_file(watchdog_device.miscdev.this_device,
+		&dev_attr_shutdown_config);
+	if (ret) {
+		pr_warn("cant register dev file for shutdown_config\n");
+		return ret;
+	}
+
+	ret = device_create_file(watchdog_device.miscdev.this_device,
+		&dev_attr_counter);
+	if (ret) {
+		pr_warn("cant register dev file for counter\n");
+		return ret;
+	}
+
+	ret = device_create_file(watchdog_device.miscdev.this_device,
+		&dev_attr_reboot_ongoing);
+	if (ret) {
+		pr_warn("cant register dev file for reboot_ongoing\n");
+		return ret;
+	}
+
+	ret = device_create_file(watchdog_device.miscdev.this_device,
+		&dev_attr_shutdown_ongoing);
+	if (ret) {
+		pr_warn("cant register dev file for shutdown_ongoing\n");
+		return ret;
+	}
+	return 0;
+}
+
+int remove_watchdog_sysfs_files(void)
+{
+#ifdef CONFIG_DISABLE_SCU_WATCHDOG
+	device_remove_file(watchdog_device.miscdev.this_device,
+		&dev_attr_disable);
+#endif
+	device_remove_file(watchdog_device.miscdev.this_device,
+		&dev_attr_normal_config);
+
+	device_remove_file(watchdog_device.miscdev.this_device,
+		&dev_attr_reboot_config);
+
+	device_remove_file(watchdog_device.miscdev.this_device,
+		&dev_attr_shutdown_config);
+
+	device_remove_file(watchdog_device.miscdev.this_device,
+		&dev_attr_counter);
+
+	device_remove_file(watchdog_device.miscdev.this_device,
+		&dev_attr_reboot_ongoing);
+
+	device_remove_file(watchdog_device.miscdev.this_device,
+		&dev_attr_shutdown_ongoing);
+	return 0;
+}
+
+static int handle_mrfl_dev_ioapic(int irq)
+{
+	int ret = 0;
+	int ioapic;
+	struct io_apic_irq_attr irq_attr;
+
+	ioapic = mp_find_ioapic(irq);
+	if (ioapic >= 0) {
+		irq_attr.ioapic = ioapic;
+		irq_attr.ioapic_pin = irq;
+		irq_attr.trigger = 1;
+		irq_attr.polarity = 0; /* Active high */
+		io_apic_set_pci_routing(NULL, irq, &irq_attr);
+	} else {
+		pr_warn("can not find interrupt %d in ioapic\n", irq);
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+/* Init code */
+static int intel_scu_watchdog_init(void)
+{
+	int ret = 0;
+
+	watchdog_device.normal_wd_action   = SCU_COLD_RESET_ON_TIMEOUT;
+	watchdog_device.reboot_wd_action   = SCU_COLD_RESET_ON_TIMEOUT;
+	watchdog_device.shutdown_wd_action = SCU_COLD_OFF_ON_TIMEOUT;
+
+#ifdef CONFIG_DEBUG_FS
+	watchdog_device.panic_reboot_notifier = false;
+#endif /* CONFIG_DEBUG_FS */
+
+	/* Initially, we are not in shutdown mode */
+	watchdog_device.shutdown_flag = false;
+
+	/* Since timeout can be set by MODULE_PARAM, need to reset pre_timeout */
+	pre_timeout = timeout-15;
+
+	/* Check timeouts boot parameter */
+	if (check_timeouts(pre_timeout, timeout)) {
+		pr_err("%s: Invalid timeouts\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Reboot notifier */
+	watchdog_device.reboot_notifier.notifier_call = reboot_notifier;
+	watchdog_device.reboot_notifier.priority = 1;
+	ret = register_reboot_notifier(&watchdog_device.reboot_notifier);
+	if (ret) {
+		pr_crit("cannot register reboot notifier %d\n", ret);
+		goto error_stop_timer;
+	}
+
+	/* Do not publish the watchdog device when disable (TO BE REMOVED) */
+	if (!disable_kernel_watchdog) {
+		watchdog_device.miscdev.minor = WATCHDOG_MINOR;
+		watchdog_device.miscdev.name = "watchdog";
+		watchdog_device.miscdev.fops = &intel_scu_fops;
+
+		ret = misc_register(&watchdog_device.miscdev);
+		if (ret) {
+			pr_crit("Cannot register miscdev %d err =%d\n",
+				WATCHDOG_MINOR, ret);
+			goto error_reboot_notifier;
+		}
+	}
+
+	/* MSI #12 handler to dump registers */
+	handle_mrfl_dev_ioapic(EXT_TIMER0_MSI);
+	ret = request_irq((unsigned int)EXT_TIMER0_MSI,
+		watchdog_warning_interrupt,
+		IRQF_SHARED|IRQF_NO_SUSPEND, "watchdog",
+		&watchdog_device);
+	if (ret) {
+		pr_err("error requesting warning irq %d\n",
+		       EXT_TIMER0_MSI);
+		pr_err("error value returned is %d\n", ret);
+		goto error_misc_register;
+	}
+
+#ifdef CONFIG_INTEL_SCU_SOFT_LOCKUP
+	init_timer(&softlock_timer);
+#endif
+
+	if (disable_kernel_watchdog) {
+		pr_err("%s: Disable kernel watchdog\n", __func__);
+
+		/* Make sure timer is stopped */
+		ret = watchdog_stop();
+		if (ret != 0)
+			pr_debug("cant disable timer\n");
+	}
+
+#ifdef CONFIG_DEBUG_FS
+	ret = create_debugfs_entries();
+	if (ret) {
+		pr_err("%s: Error creating debugfs entries\n", __func__);
+		goto error_debugfs_entry;
+	}
+#endif
+
+	watchdog_device.started = false;
+
+	ret = create_watchdog_sysfs_files();
+	if (ret) {
+		pr_err("%s: Error creating debugfs entries\n", __func__);
+		goto error_sysfs_entry;
+	}
+
+	return ret;
+
+error_sysfs_entry:
+	/* Nothing special to do */
+#ifdef CONFIG_DEBUG_FS
+error_debugfs_entry:
+	/* Remove entries done by create function */
+#endif
+
+error_misc_register:
+	misc_deregister(&watchdog_device.miscdev);
+
+error_reboot_notifier:
+	unregister_reboot_notifier(&watchdog_device.reboot_notifier);
+
+error_stop_timer:
+	watchdog_stop();
+
+	return ret;
+}
+
+static void intel_scu_watchdog_exit(void)
+{
+	int ret = 0;
+
+	remove_watchdog_sysfs_files();
+#ifdef CONFIG_DEBUG_FS
+	remove_debugfs_entries();
+#endif
+
+#ifdef CONFIG_INTEL_SCU_SOFT_LOCKUP
+	del_timer_sync(&softlock_timer);
+#endif
+
+	ret = watchdog_stop();
+	if (ret != 0)
+		pr_err("cant disable timer\n");
+
+	misc_deregister(&watchdog_device.miscdev);
+	unregister_reboot_notifier(&watchdog_device.reboot_notifier);
+}
+
+static int watchdog_rpmsg_probe(struct rpmsg_channel *rpdev)
+{
+	int ret = 0;
+
+	if (rpdev == NULL) {
+		pr_err("rpmsg channel not created\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	dev_info(&rpdev->dev, "Probed watchdog rpmsg device\n");
+
+	/* Allocate rpmsg instance for watchdog*/
+	ret = alloc_rpmsg_instance(rpdev, &watchdog_instance);
+	if (!watchdog_instance) {
+		dev_err(&rpdev->dev, "kzalloc watchdog instance failed\n");
+		goto out;
+	}
+	/* Initialize rpmsg instance */
+	init_rpmsg_instance(watchdog_instance);
+	/* Init scu watchdog */
+	ret = intel_scu_watchdog_init();
+
+	if (ret)
+		free_rpmsg_instance(rpdev, &watchdog_instance);
+out:
+	return ret;
+}
+
+static void watchdog_rpmsg_remove(struct rpmsg_channel *rpdev)
+{
+	intel_scu_watchdog_exit();
+	free_rpmsg_instance(rpdev, &watchdog_instance);
+	dev_info(&rpdev->dev, "Removed watchdog rpmsg device\n");
+}
+
+static void watchdog_rpmsg_cb(struct rpmsg_channel *rpdev, void *data,
+					int len, void *priv, u32 src)
+{
+	dev_warn(&rpdev->dev, "unexpected, message\n");
+
+	print_hex_dump(KERN_DEBUG, __func__, DUMP_PREFIX_NONE, 16, 1,
+		       data, len,  true);
+}
+
+static struct rpmsg_device_id watchdog_rpmsg_id_table[] = {
+	{ .name	= "rpmsg_watchdog" },
+	{ },
+};
+MODULE_DEVICE_TABLE(rpmsg, watchdog_rpmsg_id_table);
+
+static struct rpmsg_driver watchdog_rpmsg = {
+	.drv.name	= KBUILD_MODNAME,
+	.drv.owner	= THIS_MODULE,
+	.id_table	= watchdog_rpmsg_id_table,
+	.probe		= watchdog_rpmsg_probe,
+	.callback	= watchdog_rpmsg_cb,
+	.remove		= watchdog_rpmsg_remove,
+};
+
+static int __init watchdog_rpmsg_init(void)
+{
+	if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER)
+		return register_rpmsg_driver(&watchdog_rpmsg);
+	else {
+		pr_err("%s: watchdog driver: bad platform\n", __func__);
+		return -ENODEV;
+	}
+}
+
+#ifdef MODULE
+module_init(watchdog_rpmsg_init);
+#else
+rootfs_initcall(watchdog_rpmsg_init);
+#endif
+
+static void __exit watchdog_rpmsg_exit(void)
+{
+	return unregister_rpmsg_driver(&watchdog_rpmsg);
+}
+module_exit(watchdog_rpmsg_exit);
+
+MODULE_AUTHOR("Intel Corporation");
+MODULE_AUTHOR("mark.a.allyn@intel.com");
+MODULE_AUTHOR("yannx.puech@intel.com");
+MODULE_DESCRIPTION("Intel SCU Watchdog Device Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS_MISCDEV(WATCHDOG_MINOR);
+MODULE_VERSION(WDT_VER);
diff --git a/drivers/watchdog/intel_scu_watchdog_evo.h b/drivers/watchdog/intel_scu_watchdog_evo.h
new file mode 100644
index 0000000..2176974
--- /dev/null
+++ b/drivers/watchdog/intel_scu_watchdog_evo.h
@@ -0,0 +1,68 @@
+/*
+ *      Intel_SCU 0.3:  An Intel SCU IOH Based Watchdog Device
+ *			for Intel part #(s):
+ *				- AF82MP20 PCH
+ *
+ *      Copyright (C) 2009-2013 Intel Corporation. All rights reserved.
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of version 2 of the GNU General
+ *      Public License as published by the Free Software Foundation.
+ *
+ *      This program is distributed in the hope that it will be
+ *      useful, but WITHOUT ANY WARRANTY; without even the implied
+ *      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *      PURPOSE.  See the GNU General Public License for more details.
+ *      You should have received a copy of the GNU General Public
+ *      License along with this program; if not, write to the Free
+ *      Software Foundation, Inc., 59 Temple Place - Suite 330,
+ *      Boston, MA  02111-1307, USA.
+ *      The full GNU General Public License is included in this
+ *      distribution in the file called COPYING.
+ *
+ */
+
+#ifndef __INTEL_SCU_WATCHDOG_H
+#define __INTEL_SCU_WATCHDOG_H
+
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+#endif
+
+#ifdef CONFIG_DEBUG_FS
+#include <linux/debugfs.h>
+#endif
+
+#define PFX "intel_scu_watchdog: "
+#define WDT_VER "0.3"
+
+#define DEFAULT_PRETIMEOUT 75
+#define DEFAULT_TIMEOUT 90
+
+/* Value 0 to reset the reset counter */
+#define OSNIB_WRITE_VALUE 0
+
+struct intel_scu_watchdog_dev {
+	ulong driver_open;
+	ulong driver_closed;
+	bool started;
+	struct notifier_block reboot_notifier;
+	struct miscdevice miscdev;
+	bool shutdown_flag;
+	int reset_type;
+	int normal_wd_action;
+	int reboot_wd_action;
+	int shutdown_wd_action;
+#ifdef CONFIG_DEBUG_FS
+	bool panic_reboot_notifier;
+	struct dentry *dfs_wd;
+	struct dentry *dfs_secwd;
+	struct dentry *dfs_secwd_trigger;
+	struct dentry *dfs_kwd;
+	struct dentry *dfs_kwd_trigger;
+	struct dentry *dfs_kwd_reset_type;
+	struct dentry *dfs_kwd_panic_reboot;
+#endif /* CONFIG_DEBUG_FS */
+};
+
+#endif /* __INTEL_SCU_WATCHDOG_H */
-- 
1.7.5.4

