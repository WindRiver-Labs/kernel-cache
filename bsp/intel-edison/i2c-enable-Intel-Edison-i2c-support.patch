From 17aabaf7bad29bfed97feed6eb304d6a6168e0b1 Mon Sep 17 00:00:00 2001
From: Liwei Song <liwei.song@windriver.com>
Date: Tue, 1 Mar 2016 19:39:20 -0500
Subject: [PATCH 05/11] i2c: enable Intel Edison i2c support

This patch is from yocto Intel Edison support:
http://downloadmirror.intel.com/25028/eng/edison-src-ww25.5-15.tgz

Use to enable Edison i2c support. Driver name i2c-designware-pci.

Signed-off-by: Liwei Song <liwei.song@windriver.com>
---
 arch/x86/platform/intel-mid/device_libs/Makefile   |    1 +
 .../intel-mid/device_libs/platform_dw_i2c.c        |  113 ++
 drivers/i2c/busses/Kconfig                         |   46 +
 drivers/i2c/busses/Makefile                        |    8 +
 drivers/i2c/busses/i2c-designware-core.c           | 1177 +++++++++++++++-----
 drivers/i2c/busses/i2c-designware-core.h           |  280 +++++-
 drivers/i2c/busses/i2c-designware-pcidrv.c         |  364 +++----
 drivers/i2c/busses/i2c-designware-platdrv.c        |  273 ++---
 drivers/i2c/busses/i2c-pmic-regs.h                 |   78 ++
 drivers/i2c/busses/i2c-pmic.c                      |  452 ++++++++
 10 files changed, 2126 insertions(+), 666 deletions(-)
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_dw_i2c.c
 create mode 100644 drivers/i2c/busses/i2c-pmic-regs.h
 create mode 100644 drivers/i2c/busses/i2c-pmic.c

diff --git a/arch/x86/platform/intel-mid/device_libs/Makefile b/arch/x86/platform/intel-mid/device_libs/Makefile
index 1e409dd..b038a02 100644
--- a/arch/x86/platform/intel-mid/device_libs/Makefile
+++ b/arch/x86/platform/intel-mid/device_libs/Makefile
@@ -17,6 +17,7 @@ obj-$(subst m,y,$(CONFIG_INPUT_MPU3050)) += platform_mpu3050.o
 obj-$(subst m,y,$(CONFIG_INPUT_BMA150)) += platform_bma023.o
 obj-$(subst m,y,$(CONFIG_GPIO_PCA953X)) += platform_tca6416.o
 obj-$(subst m,y,$(CONFIG_DRM_MEDFIELD)) += platform_tc35876x.o
+obj-$(subst m,y,$(CONFIG_I2C_DESIGNWARE_CORE_FORK)) += platform_dw_i2c.o
 # SPI Devices
 obj-$(subst m,y,$(CONFIG_SERIAL_MRST_MAX3110)) += platform_max3111.o
 # MISC Devices
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_dw_i2c.c b/arch/x86/platform/intel-mid/device_libs/platform_dw_i2c.c
new file mode 100644
index 0000000..9f1822d
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_dw_i2c.c
@@ -0,0 +1,113 @@
+/*
+ * platform_dw_i2c.c: I2C platform data initilization file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/lnw_gpio.h>
+#include <linux/gpio.h>
+#include <asm/intel-mid.h>
+
+struct i2c_pin_cfg {
+	int scl_gpio;
+	int scl_alt;
+	int sda_gpio;
+	int sda_alt;
+};
+
+enum {
+	BOARD_NONE = 0,
+	BOARD_VTB,
+	BOARD_SALTBAY,
+};
+
+static struct i2c_pin_cfg dw_i2c_pin_cfgs[][10] = {
+	[BOARD_NONE] =  {},
+	[BOARD_VTB] =  {
+		[1] = {27, 1, 26, 1},
+	},
+	[BOARD_SALTBAY] =  {
+		[1] = {19, 1, 20, 1},
+	},
+};
+
+int intel_mid_dw_i2c_abort(int busnum)
+{
+	int i;
+	int ret = -EBUSY;
+	struct i2c_pin_cfg *pins = &dw_i2c_pin_cfgs[BOARD_NONE][busnum];
+
+	switch (intel_mid_identify_cpu()) {
+	case INTEL_MID_CPU_CHIP_CLOVERVIEW:
+		pins = &dw_i2c_pin_cfgs[BOARD_VTB][busnum];
+		break;
+	case INTEL_MID_CPU_CHIP_TANGIER:
+		pins = &dw_i2c_pin_cfgs[BOARD_SALTBAY][busnum];
+		break;
+	default:
+		break;
+	}
+
+	if (!pins->scl_gpio || !pins->sda_gpio) {
+		pr_err("i2c-%d: recovery ignore\n", busnum);
+		return 0;
+	}
+	pr_err("i2c-%d: try to abort xfer, scl_gpio %d, sda_gpio %d\n",
+			busnum, pins->scl_gpio, pins->sda_gpio);
+	gpio_request(pins->scl_gpio, "scl");
+	gpio_request(pins->sda_gpio, "sda");
+	lnw_gpio_set_alt(pins->scl_gpio, LNW_GPIO);
+	lnw_gpio_set_alt(pins->sda_gpio, LNW_GPIO);
+	gpio_direction_input(pins->scl_gpio);
+	gpio_direction_input(pins->sda_gpio);
+	usleep_range(10, 10);
+	pr_err("i2c-%d: scl_gpio val %d, sda_gpio val %d\n",
+			busnum,
+			gpio_get_value(pins->scl_gpio) ? 1 : 0,
+			gpio_get_value(pins->sda_gpio) ? 1 : 0);
+	gpio_direction_output(pins->scl_gpio, 1);
+	pr_err("i2c-%d: toggle begin\n", busnum);
+	for (i = 0; i < 9; i++) {
+		if (gpio_get_value(pins->sda_gpio)) {
+			if (gpio_get_value(pins->scl_gpio)) {
+				pr_err("i2c-%d: recovery success\n", busnum);
+				break;
+			} else {
+				gpio_direction_output(pins->scl_gpio, 0);
+				pr_err("i2c-%d: scl_gpio val 0, sda_gpio val 1\n",
+					busnum);
+			}
+		}
+		gpio_set_value(pins->scl_gpio, 0);
+		usleep_range(10, 20);
+		gpio_set_value(pins->scl_gpio, 1);
+		usleep_range(10, 20);
+		pr_err("i2c-%d: toggle SCL loop %d\n", busnum, i);
+	}
+	pr_err("i2c-%d: toggle end\n", busnum);
+	gpio_direction_output(pins->scl_gpio, 1);
+	gpio_direction_output(pins->sda_gpio, 0);
+	gpio_set_value(pins->scl_gpio, 0);
+	usleep_range(10, 20);
+	gpio_set_value(pins->scl_gpio, 1);
+	usleep_range(10, 20);
+	gpio_set_value(pins->sda_gpio, 0);
+	lnw_gpio_set_alt(pins->scl_gpio, pins->scl_alt);
+	lnw_gpio_set_alt(pins->sda_gpio, pins->sda_alt);
+	usleep_range(10, 10);
+	gpio_free(pins->scl_gpio);
+	gpio_free(pins->sda_gpio);
+
+	return ret;
+}
+EXPORT_SYMBOL(intel_mid_dw_i2c_abort);
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index bfacb9e..3caa720 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -410,6 +410,52 @@ config I2C_DAVINCI
 	  devices such as DaVinci NIC.
 	  For details please see http://www.ti.com/davinci
 
+config I2C_DESIGNWARE_CORE_FORK
+	tristate "Synopsys DesignWare Controller"
+	help
+	  If you say yes to this option, support will be included for the
+	  Synopsys DesignWare adapter core. Only master mode is supported.
+          You need choose platform or pci driver for its driver support.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called i2c-designware-core.
+
+config I2C_DESIGNWARE_PCI_FORK
+	tristate "Synopsys DesignWare PCI"
+	depends on PCI && I2C_DESIGNWARE_CORE_FORK
+	help
+	  If you say yes to this option, support will be included for the
+	  Synopsys DesignWare I2C adapter. Only master mode is supported.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called i2c-designware-pci.
+
+config I2C_DESIGNWARE_PLATFORM_FORK
+	tristate "Synopsys DesignWare Platform"
+	depends on I2C_DESIGNWARE_CORE_FORK
+	help
+	  If you say yes to this option, support will be included for the
+	  Synopsys DesignWare I2C adapter. Only master mode is supported.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called i2c-designware-platform.
+
+config I2C_DW_SPEED_MODE_DEBUG
+	bool "Designware I2C Speed Mode Debug"
+	depends on I2C_DESIGNWARE_CORE_FORK
+	help
+	  If you say yes to this option, you could runtime change the I2C
+	  controller bus speed mode.
+
+config I2C_PMIC
+	bool "PMIC I2C Adapter"
+	depends on INTEL_SCU_IPC
+	help
+	  Say Y here if you have PMIC I2C adapter.
+
+	  PMIC-I2C adapter driver to handle I2C transactions
+	  in the PMIC's I2C bus.
+
 config I2C_DESIGNWARE_CORE
 	tristate
 
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index a08931f..1e0f238 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -98,4 +98,12 @@ obj-$(CONFIG_I2C_SIBYTE)	+= i2c-sibyte.o
 obj-$(CONFIG_SCx200_ACB)	+= scx200_acb.o
 obj-$(CONFIG_SCx200_I2C)	+= scx200_i2c.o
 
+obj-$(CONFIG_I2C_DESIGNWARE_CORE_FORK)	+= i2c-designware-core.o
+obj-$(CONFIG_I2C_DESIGNWARE_PCI_FORK)	+= i2c-designware-pci.o
+i2c-designware-pci-objs := i2c-designware-pcidrv.o
+obj-$(CONFIG_I2C_DESIGNWARE_PLATFORM_FORK)	+= i2c-designware-platform.o
+i2c-designware-platform-objs := i2c-designware-platdrv.o
+
+obj-$(CONFIG_I2C_PMIC)          += i2c-pmic.o
+
 ccflags-$(CONFIG_I2C_DEBUG_BUS) := -DDEBUG
diff --git a/drivers/i2c/busses/i2c-designware-core.c b/drivers/i2c/busses/i2c-designware-core.c
index 3c20e4b..668ddcc 100644
--- a/drivers/i2c/busses/i2c-designware-core.c
+++ b/drivers/i2c/busses/i2c-designware-core.c
@@ -25,124 +25,36 @@
  * ----------------------------------------------------------------------------
  *
  */
-#include <linux/export.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/errno.h>
 #include <linux/err.h>
 #include <linux/i2c.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
 #include <linux/pm_runtime.h>
+#include <linux/nmi.h>
 #include <linux/delay.h>
-#include <linux/module.h>
+#include <linux/semaphore.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/acpi.h>
 #include "i2c-designware-core.h"
 
-/*
- * Registers offset
- */
-#define DW_IC_CON		0x0
-#define DW_IC_TAR		0x4
-#define DW_IC_DATA_CMD		0x10
-#define DW_IC_SS_SCL_HCNT	0x14
-#define DW_IC_SS_SCL_LCNT	0x18
-#define DW_IC_FS_SCL_HCNT	0x1c
-#define DW_IC_FS_SCL_LCNT	0x20
-#define DW_IC_INTR_STAT		0x2c
-#define DW_IC_INTR_MASK		0x30
-#define DW_IC_RAW_INTR_STAT	0x34
-#define DW_IC_RX_TL		0x38
-#define DW_IC_TX_TL		0x3c
-#define DW_IC_CLR_INTR		0x40
-#define DW_IC_CLR_RX_UNDER	0x44
-#define DW_IC_CLR_RX_OVER	0x48
-#define DW_IC_CLR_TX_OVER	0x4c
-#define DW_IC_CLR_RD_REQ	0x50
-#define DW_IC_CLR_TX_ABRT	0x54
-#define DW_IC_CLR_RX_DONE	0x58
-#define DW_IC_CLR_ACTIVITY	0x5c
-#define DW_IC_CLR_STOP_DET	0x60
-#define DW_IC_CLR_START_DET	0x64
-#define DW_IC_CLR_GEN_CALL	0x68
-#define DW_IC_ENABLE		0x6c
-#define DW_IC_STATUS		0x70
-#define DW_IC_TXFLR		0x74
-#define DW_IC_RXFLR		0x78
 #define DW_IC_SDA_HOLD		0x7c
-#define DW_IC_TX_ABRT_SOURCE	0x80
-#define DW_IC_ENABLE_STATUS	0x9c
-#define DW_IC_COMP_PARAM_1	0xf4
 #define DW_IC_COMP_VERSION	0xf8
 #define DW_IC_SDA_HOLD_MIN_VERS	0x3131312A
-#define DW_IC_COMP_TYPE		0xfc
-#define DW_IC_COMP_TYPE_VALUE	0x44570140
-
-#define DW_IC_INTR_RX_UNDER	0x001
-#define DW_IC_INTR_RX_OVER	0x002
-#define DW_IC_INTR_RX_FULL	0x004
-#define DW_IC_INTR_TX_OVER	0x008
-#define DW_IC_INTR_TX_EMPTY	0x010
-#define DW_IC_INTR_RD_REQ	0x020
-#define DW_IC_INTR_TX_ABRT	0x040
-#define DW_IC_INTR_RX_DONE	0x080
-#define DW_IC_INTR_ACTIVITY	0x100
-#define DW_IC_INTR_STOP_DET	0x200
-#define DW_IC_INTR_START_DET	0x400
-#define DW_IC_INTR_GEN_CALL	0x800
-
-#define DW_IC_INTR_DEFAULT_MASK		(DW_IC_INTR_RX_FULL | \
-					 DW_IC_INTR_TX_EMPTY | \
-					 DW_IC_INTR_TX_ABRT | \
-					 DW_IC_INTR_STOP_DET)
-
-#define DW_IC_STATUS_ACTIVITY	0x1
-
-#define DW_IC_ERR_TX_ABRT	0x1
 
 #define DW_IC_TAR_10BITADDR_MASTER BIT(12)
 
-/*
- * status codes
- */
-#define STATUS_IDLE			0x0
-#define STATUS_WRITE_IN_PROGRESS	0x1
-#define STATUS_READ_IN_PROGRESS		0x2
-
-#define TIMEOUT			20 /* ms */
-
-/*
- * hardware abort codes from the DW_IC_TX_ABRT_SOURCE register
- *
- * only expected abort codes are listed here
- * refer to the datasheet for the full list
- */
-#define ABRT_7B_ADDR_NOACK	0
-#define ABRT_10ADDR1_NOACK	1
-#define ABRT_10ADDR2_NOACK	2
-#define ABRT_TXDATA_NOACK	3
-#define ABRT_GCALL_NOACK	4
-#define ABRT_GCALL_READ		5
-#define ABRT_SBYTE_ACKDET	7
-#define ABRT_SBYTE_NORSTRT	9
-#define ABRT_10B_RD_NORSTRT	10
-#define ABRT_MASTER_DIS		11
-#define ARB_LOST		12
-
-#define DW_IC_TX_ABRT_7B_ADDR_NOACK	(1UL << ABRT_7B_ADDR_NOACK)
-#define DW_IC_TX_ABRT_10ADDR1_NOACK	(1UL << ABRT_10ADDR1_NOACK)
-#define DW_IC_TX_ABRT_10ADDR2_NOACK	(1UL << ABRT_10ADDR2_NOACK)
-#define DW_IC_TX_ABRT_TXDATA_NOACK	(1UL << ABRT_TXDATA_NOACK)
-#define DW_IC_TX_ABRT_GCALL_NOACK	(1UL << ABRT_GCALL_NOACK)
-#define DW_IC_TX_ABRT_GCALL_READ	(1UL << ABRT_GCALL_READ)
-#define DW_IC_TX_ABRT_SBYTE_ACKDET	(1UL << ABRT_SBYTE_ACKDET)
-#define DW_IC_TX_ABRT_SBYTE_NORSTRT	(1UL << ABRT_SBYTE_NORSTRT)
-#define DW_IC_TX_ABRT_10B_RD_NORSTRT	(1UL << ABRT_10B_RD_NORSTRT)
-#define DW_IC_TX_ABRT_MASTER_DIS	(1UL << ABRT_MASTER_DIS)
-#define DW_IC_TX_ARB_LOST		(1UL << ARB_LOST)
-
-#define DW_IC_TX_ABRT_NOACK		(DW_IC_TX_ABRT_7B_ADDR_NOACK | \
-					 DW_IC_TX_ABRT_10ADDR1_NOACK | \
-					 DW_IC_TX_ABRT_10ADDR2_NOACK | \
-					 DW_IC_TX_ABRT_TXDATA_NOACK | \
-					 DW_IC_TX_ABRT_GCALL_NOACK)
+int i2c_dw_init(struct dw_i2c_dev *dev);
+int i2c_dw_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num);
+u32 i2c_dw_func(struct i2c_adapter *adap);
+void i2c_dw_enable(struct dw_i2c_dev *dev);
+void i2c_dw_disable(struct dw_i2c_dev *dev);
+irqreturn_t i2c_dw_isr(int this_irq, void *dev_id);
+void i2c_dw_disable_int(struct dw_i2c_dev *dev);
+void i2c_dw_clear_int(struct dw_i2c_dev *dev);
 
 static char *abort_sources[] = {
 	[ABRT_7B_ADDR_NOACK] =
@@ -171,15 +83,9 @@ static char *abort_sources[] = {
 
 u32 dw_readl(struct dw_i2c_dev *dev, int offset)
 {
-	u32 value;
+	u32 value = readl(dev->base + offset);
 
-	if (dev->accessor_flags & ACCESS_16BIT)
-		value = readw(dev->base + offset) |
-			(readw(dev->base + offset + 2) << 16);
-	else
-		value = readl(dev->base + offset);
-
-	if (dev->accessor_flags & ACCESS_SWAP)
+	if (dev->swab)
 		return swab32(value);
 	else
 		return value;
@@ -187,17 +93,787 @@ u32 dw_readl(struct dw_i2c_dev *dev, int offset)
 
 void dw_writel(struct dw_i2c_dev *dev, u32 b, int offset)
 {
-	if (dev->accessor_flags & ACCESS_SWAP)
+	if (dev->swab)
 		b = swab32(b);
 
-	if (dev->accessor_flags & ACCESS_16BIT) {
-		writew((u16)b, dev->base + offset);
-		writew((u16)(b >> 16), dev->base + offset + 2);
+	writel(b, dev->base + offset);
+}
+
+static void i2c_dw_dump(struct dw_i2c_dev *dev)
+{
+	u32 value;
+
+	dev_err(dev->dev, "===== REGISTER DUMP (i2c) =====\n");
+	value = dw_readl(dev, DW_IC_CON);
+	dev_err(dev->dev, "DW_IC_CON:               0x%x\n", value);
+	value = dw_readl(dev, DW_IC_TAR);
+	dev_err(dev->dev, "DW_IC_TAR:               0x%x\n", value);
+	value = dw_readl(dev, DW_IC_SS_SCL_HCNT);
+	dev_err(dev->dev, "DW_IC_SS_SCL_HCNT:       0x%x\n", value);
+	value = dw_readl(dev, DW_IC_SS_SCL_LCNT);
+	dev_err(dev->dev, "DW_IC_SS_SCL_LCNT:       0x%x\n", value);
+	value = dw_readl(dev, DW_IC_FS_SCL_HCNT);
+	dev_err(dev->dev, "DW_IC_FS_SCL_HCNT:       0x%x\n", value);
+	value = dw_readl(dev, DW_IC_FS_SCL_LCNT);
+	dev_err(dev->dev, "DW_IC_FS_SCL_LCNT:       0x%x\n", value);
+	value = dw_readl(dev, DW_IC_INTR_STAT);
+	dev_err(dev->dev, "DW_IC_INTR_STAT:         0x%x\n", value);
+	value = dw_readl(dev, DW_IC_INTR_MASK);
+	dev_err(dev->dev, "DW_IC_INTR_MASK:         0x%x\n", value);
+	value = dw_readl(dev, DW_IC_RAW_INTR_STAT);
+	dev_err(dev->dev, "DW_IC_RAW_INTR_STAT:     0x%x\n", value);
+	value = dw_readl(dev, DW_IC_RX_TL);
+	dev_err(dev->dev, "DW_IC_RX_TL:             0x%x\n", value);
+	value = dw_readl(dev, DW_IC_TX_TL);
+	dev_err(dev->dev, "DW_IC_TX_TL:             0x%x\n", value);
+	value = dw_readl(dev, DW_IC_ENABLE);
+	dev_err(dev->dev, "DW_IC_ENABLE:            0x%x\n", value);
+	value = dw_readl(dev, DW_IC_STATUS);
+	dev_err(dev->dev, "DW_IC_STATUS:            0x%x\n", value);
+	value = dw_readl(dev, DW_IC_TXFLR);
+	dev_err(dev->dev, "DW_IC_TXFLR:             0x%x\n", value);
+	value = dw_readl(dev, DW_IC_RXFLR);
+	dev_err(dev->dev, "DW_IC_RXFLR:             0x%x\n", value);
+	value = dw_readl(dev, DW_IC_TX_ABRT_SOURCE);
+	dev_err(dev->dev, "DW_IC_TX_ABRT_SOURCE:    0x%x\n", value);
+	value = dw_readl(dev, DW_IC_DATA_CMD);
+	dev_err(dev->dev, "DW_IC_DATA_CMD:          0x%x\n", value);
+	dev_err(dev->dev, "===============================\n");
+}
+
+/* VLV2 PCI config space memio access to the controller is
+* enabled by
+* 1. Reset 0x804 and 0x808 offset from base address.
+* 2. Set 0x804 offset from base address to 0x3.
+*/
+static void vlv2_reset(struct dw_i2c_dev *dev)
+{
+	int i;
+
+	for (i = 0; i < 10; i++) {
+		dw_writel(dev, 0, 0x804);
+		dw_writel(dev, 0, 0x808);
+		usleep_range(10, 100);
+
+		dw_writel(dev, 3, 0x804);
+		usleep_range(10, 100);
+
+		if (dw_readl(dev, DW_IC_COMP_TYPE) != DW_IC_COMP_TYPE_VALUE)
+			continue;
+
+		return;
+	}
+
+	dev_warn(dev->dev, "vlv2 I2C reset failed\n");
+}
+
+static int mfld_i2c_scl_cfg(struct dw_i2c_dev *dev)
+{
+	dw_writel(dev, PNW_SS_SCLK_HCNT, DW_IC_SS_SCL_HCNT);
+	dw_writel(dev, PNW_SS_SCLK_LCNT, DW_IC_SS_SCL_LCNT);
+
+	dw_writel(dev, PNW_FS_SCLK_HCNT, DW_IC_FS_SCL_HCNT);
+	dw_writel(dev, PNW_FS_SCLK_LCNT, DW_IC_FS_SCL_LCNT);
+
+	return 0;
+}
+
+static int ctp_i2c_scl_cfg(struct dw_i2c_dev *dev)
+{
+	dw_writel(dev, CLV_SS_SCLK_HCNT, DW_IC_SS_SCL_HCNT);
+	dw_writel(dev, CLV_SS_SCLK_LCNT, DW_IC_SS_SCL_LCNT);
+
+	dw_writel(dev, CLV_FS_SCLK_HCNT, DW_IC_FS_SCL_HCNT);
+	dw_writel(dev, CLV_FS_SCLK_LCNT, DW_IC_FS_SCL_LCNT);
+
+	return 0;
+}
+
+static int merr_i2c_scl_cfg(struct dw_i2c_dev *dev)
+{
+	dw_writel(dev, MERR_SS_SCLK_HCNT, DW_IC_SS_SCL_HCNT);
+	dw_writel(dev, MERR_SS_SCLK_LCNT, DW_IC_SS_SCL_LCNT);
+
+	dw_writel(dev, MERR_FS_SCLK_HCNT, DW_IC_FS_SCL_HCNT);
+	dw_writel(dev, MERR_FS_SCLK_LCNT, DW_IC_FS_SCL_LCNT);
+
+	dw_writel(dev, MERR_HS_SCLK_HCNT, DW_IC_HS_SCL_HCNT);
+	dw_writel(dev, MERR_HS_SCLK_LCNT, DW_IC_HS_SCL_LCNT);
+
+	return 0;
+}
+
+static int vlv2_i2c_scl_cfg(struct dw_i2c_dev *dev)
+{
+	dw_writel(dev, VLV2_SS_SCLK_HCNT, DW_IC_SS_SCL_HCNT);
+	dw_writel(dev, VLV2_SS_SCLK_LCNT, DW_IC_SS_SCL_LCNT);
+
+	dw_writel(dev, VLV2_FS_SCLK_HCNT, DW_IC_FS_SCL_HCNT);
+	dw_writel(dev, VLV2_FS_SCLK_LCNT, DW_IC_FS_SCL_LCNT);
+
+	dw_writel(dev, VLV2_HS_SCLK_HCNT, DW_IC_HS_SCL_HCNT);
+	dw_writel(dev, VLV2_HS_SCLK_LCNT, DW_IC_HS_SCL_LCNT);
+
+	return 0;
+}
+
+static struct  dw_controller  dw_controllers[] = {
+	[moorestown_0] = {
+		.bus_num     = 0,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 32,
+		.rx_fifo_depth = 32,
+		.clk_khz      = 25000,
+	},
+	[moorestown_1] = {
+		.bus_num     = 1,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 32,
+		.rx_fifo_depth = 32,
+		.clk_khz      = 25000,
+	},
+	[moorestown_2] = {
+		.bus_num     = 2,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 32,
+		.rx_fifo_depth = 32,
+		.clk_khz      = 25000,
+	},
+	[medfield_0] = {
+		.bus_num     = 0,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 256,
+		.rx_fifo_depth = 256,
+		.clk_khz      = 17000,
+		.scl_cfg = mfld_i2c_scl_cfg,
+	},
+	[medfield_1] = {
+		.bus_num     = 1,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_STD,
+		.tx_fifo_depth = 256,
+		.rx_fifo_depth = 256,
+		.clk_khz      = 20500,
+		.scl_cfg = mfld_i2c_scl_cfg,
+	},
+	[medfield_2] = {
+		.bus_num     = 2,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 256,
+		.rx_fifo_depth = 256,
+		.clk_khz      = 17000,
+		.scl_cfg = mfld_i2c_scl_cfg,
+	},
+	[medfield_3] = {
+		.bus_num     = 3,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_STD,
+		.tx_fifo_depth = 256,
+		.rx_fifo_depth = 256,
+		.clk_khz      = 20500,
+		.scl_cfg = mfld_i2c_scl_cfg,
+	},
+	[medfield_4] = {
+		.bus_num     = 4,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 256,
+		.rx_fifo_depth = 256,
+		.clk_khz      = 17000,
+		.scl_cfg = mfld_i2c_scl_cfg,
+	},
+	[medfield_5] = {
+		.bus_num     = 5,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 256,
+		.rx_fifo_depth = 256,
+		.clk_khz      = 17000,
+		.scl_cfg = mfld_i2c_scl_cfg,
+	},
+	[baytrail] = {
+		.bus_num = -1,
+		.bus_cfg = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 32,
+		.rx_fifo_depth = 32,
+		.clk_khz = 100000,
+		.functionality = I2C_FUNC_10BIT_ADDR,
+		.scl_sda_cfg = &byt_config,
+	},
+
+	[cloverview_0] = {
+		.bus_num     = 0,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 256,
+		.rx_fifo_depth = 256,
+		.clk_khz      = 17000,
+		.scl_cfg = ctp_i2c_scl_cfg,
+	},
+	[cloverview_1] = {
+		.bus_num     = 1,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 256,
+		.rx_fifo_depth = 256,
+		.clk_khz      = 17000,
+		.scl_cfg = ctp_i2c_scl_cfg,
+	},
+	[cloverview_2] = {
+		.bus_num     = 2,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 256,
+		.rx_fifo_depth = 256,
+		.clk_khz      = 17000,
+		.scl_cfg = ctp_i2c_scl_cfg,
+	},
+	[cloverview_3] = {
+		.bus_num     = 3,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_STD,
+		.tx_fifo_depth = 256,
+		.rx_fifo_depth = 256,
+		.clk_khz      = 20500,
+		.scl_cfg = ctp_i2c_scl_cfg,
+	},
+	[cloverview_4] = {
+		.bus_num     = 4,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 256,
+		.rx_fifo_depth = 256,
+		.clk_khz      = 17000,
+		.scl_cfg = ctp_i2c_scl_cfg,
+	},
+	[cloverview_5] = {
+		.bus_num     = 5,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 256,
+		.rx_fifo_depth = 256,
+		.clk_khz      = 17000,
+		.scl_cfg = ctp_i2c_scl_cfg,
+	},
+
+	[merrifield_0] = {
+		.bus_num     = 1,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 64,
+		.rx_fifo_depth = 64,
+		.enable_stop = 1,
+		.scl_cfg = merr_i2c_scl_cfg,
+	},
+	[merrifield_1] = {
+		.bus_num     = 2,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_STD,
+		.tx_fifo_depth = 64,
+		.rx_fifo_depth = 64,
+		.enable_stop = 1,
+		.scl_cfg = merr_i2c_scl_cfg,
+	},
+	[merrifield_2] = {
+		.bus_num     = 3,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 64,
+		.rx_fifo_depth = 64,
+		.enable_stop = 1,
+		.scl_cfg = merr_i2c_scl_cfg,
+	},
+	[merrifield_3] = {
+		.bus_num     = 4,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 64,
+		.rx_fifo_depth = 64,
+		.enable_stop = 1,
+		.scl_cfg = merr_i2c_scl_cfg,
+	},
+	[merrifield_4] = {
+		.bus_num     = 5,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 64,
+		.rx_fifo_depth = 64,
+		.enable_stop = 1,
+		.scl_cfg = merr_i2c_scl_cfg,
+	},
+	[merrifield_5] = {
+		.bus_num     = 6,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 64,
+		.rx_fifo_depth = 64,
+		.enable_stop = 1,
+		.scl_cfg = merr_i2c_scl_cfg,
+	},
+	[merrifield_6] = {
+		.bus_num     = 7,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 64,
+		.rx_fifo_depth = 64,
+		.enable_stop = 1,
+		.scl_cfg = merr_i2c_scl_cfg,
+	},
+	[valleyview_0] = {
+		.bus_num     = 1,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 64,
+		.rx_fifo_depth = 64,
+		.enable_stop = 1,
+		.scl_cfg = vlv2_i2c_scl_cfg,
+		.reset = vlv2_reset,
+		.share_irq = 1,
+		.acpi_name = "\\_SB.I2C1"
+	},
+	[valleyview_1] = {
+		.bus_num     = 2,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 64,
+		.rx_fifo_depth = 64,
+		.enable_stop = 1,
+		.scl_cfg = vlv2_i2c_scl_cfg,
+		.reset = vlv2_reset,
+		.share_irq = 1,
+		.acpi_name = "\\_SB.I2C2"
+	},
+	[valleyview_2] = {
+		.bus_num     = 3,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 64,
+		.rx_fifo_depth = 64,
+		.enable_stop = 1,
+		.scl_cfg = vlv2_i2c_scl_cfg,
+		.reset = vlv2_reset,
+		.share_irq = 1,
+		.acpi_name = "\\_SB.I2C3"
+	},
+	[valleyview_3] = {
+		.bus_num     = 4,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 64,
+		.rx_fifo_depth = 64,
+		.enable_stop = 1,
+		.scl_cfg = vlv2_i2c_scl_cfg,
+		.reset = vlv2_reset,
+		.share_irq = 1,
+		.acpi_name = "\\_SB.I2C4"
+	},
+	[valleyview_4] = {
+		.bus_num     = 5,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 64,
+		.rx_fifo_depth = 64,
+		.enable_stop = 1,
+		.scl_cfg = vlv2_i2c_scl_cfg,
+		.reset = vlv2_reset,
+		.share_irq = 1,
+		.acpi_name = "\\_SB.I2C5"
+	},
+	[valleyview_5] = {
+		.bus_num     = 6,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 64,
+		.rx_fifo_depth = 64,
+		.enable_stop = 1,
+		.scl_cfg = vlv2_i2c_scl_cfg,
+		.reset = vlv2_reset,
+		.share_irq = 1,
+		.acpi_name = "\\_SB.I2C6"
+	},
+	[valleyview_6] = {
+		.bus_num     = 7,
+		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
+		.tx_fifo_depth = 64,
+		.rx_fifo_depth = 64,
+		.enable_stop = 1,
+		.scl_cfg = vlv2_i2c_scl_cfg,
+		.reset = vlv2_reset,
+		.share_irq = 1,
+		.acpi_name = "\\_SB.I2C7"
+	}
+};
+
+static struct i2c_algorithm i2c_dw_algo = {
+	.master_xfer	= i2c_dw_xfer,
+	.functionality	= i2c_dw_func,
+};
+
+int i2c_dw_suspend(struct dw_i2c_dev *dev, bool runtime)
+{
+	if (runtime)
+		i2c_dw_disable(dev);
+	else {
+		if (down_trylock(&dev->lock))
+			return -EBUSY;
+		i2c_dw_disable(dev);
+		dev->status &= ~STATUS_POWERON;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(i2c_dw_suspend);
+
+int i2c_dw_resume(struct dw_i2c_dev *dev, bool runtime)
+{
+	i2c_dw_init(dev);
+	if (!runtime) {
+		dev->status |= STATUS_POWERON;
+		up(&dev->lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(i2c_dw_resume);
+
+static u32 i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)
+{
+	return dev->controller->clk_khz;
+}
+
+#ifdef CONFIG_I2C_DW_SPEED_MODE_DEBUG
+static ssize_t show_bus_num(struct device *dev, struct device_attribute *attr,
+							char *buf)
+{
+	struct dw_i2c_dev *i2c = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", i2c->controller->bus_num);
+}
+
+#define MODE_NAME_SIZE	10
+
+static ssize_t store_mode(struct device *dev,
+			  struct device_attribute *attr,
+			  const char *buf, size_t size)
+{
+	struct dw_i2c_dev *i2c = dev_get_drvdata(dev);
+	int ret = 0;
+	char mode[MODE_NAME_SIZE];
+
+	if (sscanf(buf, "%9s", mode) != 1) {
+		dev_err(dev, "input I2C speed mode: std/fast\n");
+		return -EINVAL;
+	}
+
+	down(&i2c->lock);
+	pm_runtime_get_sync(i2c->dev);
+
+	if (!strncmp("std", mode, MODE_NAME_SIZE)) {
+		i2c->master_cfg &= ~DW_IC_SPEED_MASK;
+		i2c->master_cfg |= DW_IC_CON_SPEED_STD;
+	} else if (!strncmp("fast", mode, MODE_NAME_SIZE)) {
+		i2c->master_cfg &= ~DW_IC_SPEED_MASK;
+		i2c->master_cfg |= DW_IC_CON_SPEED_FAST;
+	} else if (!strncmp("high", mode, MODE_NAME_SIZE)) {
+		i2c->master_cfg &= ~DW_IC_SPEED_MASK;
+		i2c->master_cfg |= DW_IC_CON_SPEED_HIGH;
 	} else {
-		writel(b, dev->base + offset);
+		ret = -EINVAL;
+		goto out;
 	}
+
+	/* init to configure the i2c master */
+	i2c_dw_init(i2c);
+
+	dev_info(dev, "I2C speed mode changed to %s\n", mode);
+
+out:
+	pm_runtime_mark_last_busy(i2c->dev);
+	pm_runtime_put_autosuspend(i2c->dev);
+	up(&i2c->lock);
+
+	return (ret < 0) ? ret : size;
 }
 
+static ssize_t show_mode(struct device *dev,
+			 struct device_attribute *attr,
+			 char *buf)
+{
+	struct dw_i2c_dev *i2c = dev_get_drvdata(dev);
+	int ret;
+
+	switch (i2c->master_cfg & DW_IC_SPEED_MASK) {
+	case DW_IC_CON_SPEED_STD:
+		ret = snprintf(buf, PAGE_SIZE, "%s\n", "std");
+		break;
+	case DW_IC_CON_SPEED_FAST:
+		ret = snprintf(buf, PAGE_SIZE, "%s\n", "fast");
+		break;
+	case DW_IC_CON_SPEED_HIGH:
+		ret = snprintf(buf, PAGE_SIZE, "%s\n", "high");
+		break;
+	default:
+		ret = snprintf(buf, PAGE_SIZE, "%s\n", "Not Supported\n");
+		break;
+	}
+
+	return ret;
+}
+
+static DEVICE_ATTR(bus_num, S_IRUGO, show_bus_num, NULL);
+static DEVICE_ATTR(mode, S_IRUGO | S_IWUSR, show_mode, store_mode);
+
+static struct attribute *i2c_dw_attrs[] = {
+	&dev_attr_bus_num.attr,
+	&dev_attr_mode.attr,
+	NULL,
+};
+
+static struct attribute_group i2c_dw_attr_group = {
+	.name = "i2c_dw_sysnode",
+	.attrs = i2c_dw_attrs,
+};
+#endif
+
+static ssize_t store_lock_xfer(struct device *dev,
+			  struct device_attribute *attr,
+			  const char *buf, size_t size)
+{
+	struct dw_i2c_dev *i2c = dev_get_drvdata(dev->parent);
+	ssize_t	status = -EINVAL;
+	long lock;
+
+
+	status = kstrtol(buf, 0, &lock);
+	if (status == 0) {
+		if (lock && !i2c->lock_flag) {
+			down(&i2c->lock);
+			pm_runtime_get_sync(i2c->dev);
+			i2c->lock_flag = 1;
+			dev_info(dev, "lock i2c xfer\n");
+		} else if (!lock && i2c->lock_flag) {
+			pm_runtime_mark_last_busy(i2c->dev);
+			pm_runtime_put_autosuspend(i2c->dev);
+			i2c->lock_flag = 0;
+			up(&i2c->lock);
+			dev_info(dev, "unlock i2c xfer\n");
+		} else
+			return -EINVAL;
+	}
+
+	return status ? : size;
+}
+
+static DEVICE_ATTR(lock_xfer, S_IWUSR, NULL, store_lock_xfer);
+
+struct dw_i2c_dev *i2c_dw_setup(struct device *pdev, int bus_idx,
+	unsigned long start, unsigned long len, int irq)
+{
+	struct dw_i2c_dev *dev;
+	struct i2c_adapter *adap;
+	void __iomem *base;
+	struct  dw_controller *controller;
+	int r;
+
+	if (bus_idx >= ARRAY_SIZE(dw_controllers)) {
+		dev_err(pdev, "invalid bus index %d\n",
+			bus_idx);
+		r = -EINVAL;
+		goto exit;
+	}
+
+	controller = &dw_controllers[bus_idx];
+
+	base = ioremap_nocache(start, len);
+	if (!base) {
+		dev_err(pdev, "I/O memory remapping failed\n");
+		r = -ENOMEM;
+		goto exit;
+	}
+
+	dev = kzalloc(sizeof(struct dw_i2c_dev), GFP_KERNEL);
+	if (!dev) {
+		r = -ENOMEM;
+		goto err_iounmap;
+	}
+
+	init_completion(&dev->cmd_complete);
+	sema_init(&dev->lock, 1);
+	dev->status = STATUS_IDLE;
+	dev->clk = NULL;
+	dev->controller = controller;
+	dev->get_clk_rate_khz = i2c_dw_get_clk_rate_khz;
+	dev->base = base;
+	dev->dev = get_device(pdev);
+	dev->functionality =
+		I2C_FUNC_I2C |
+		I2C_FUNC_SMBUS_BYTE |
+		I2C_FUNC_SMBUS_BYTE_DATA |
+		I2C_FUNC_SMBUS_WORD_DATA |
+		I2C_FUNC_SMBUS_I2C_BLOCK;
+	dev->master_cfg =  controller->bus_cfg;
+	dev->get_scl_cfg = controller->scl_cfg;
+	dev->enable_stop = controller->enable_stop;
+	dev->clk_khz = controller->clk_khz;
+	dev->speed_cfg = dev->master_cfg & DW_IC_SPEED_MASK;
+	dev->use_dyn_clk = 0;
+	dev->reset = controller->reset;
+	dev->irq = irq;
+	dev->share_irq = controller->share_irq;
+	dev->abort = intel_mid_dw_i2c_abort;
+	dev->tx_fifo_depth = controller->tx_fifo_depth;
+	dev->rx_fifo_depth = controller->rx_fifo_depth;
+
+	r = i2c_dw_init(dev);
+	if (r)
+		goto err_kfree;
+
+	adap = &dev->adapter;
+	i2c_set_adapdata(adap, dev);
+	adap->owner = THIS_MODULE;
+	adap->class = 0;
+	adap->algo = &i2c_dw_algo;
+	adap->dev.parent = pdev;
+	adap->nr = controller->bus_num;
+	snprintf(adap->name, sizeof(adap->name), "i2c-designware-%d",
+		adap->nr);
+
+	r = request_irq(irq, i2c_dw_isr, IRQF_SHARED, adap->name, dev);
+	if (r) {
+		dev_err(pdev, "failure requesting irq %i\n", irq);
+		goto err_kfree;
+	}
+
+	i2c_dw_disable_int(dev);
+	i2c_dw_clear_int(dev);
+	r = i2c_add_numbered_adapter(adap);
+	if (r) {
+		dev_err(pdev, "failure adding adapter\n");
+		goto err_free_irq;
+	}
+
+#ifdef CONFIG_I2C_DW_SPEED_MODE_DEBUG
+	r = sysfs_create_group(&pdev->kobj, &i2c_dw_attr_group);
+	if (r) {
+		dev_err(pdev,
+			"Unable to export sysfs interface, error: %d\n", r);
+		goto err_del_adap;
+	}
+#endif
+	r = device_create_file(&adap->dev, &dev_attr_lock_xfer);
+	if (r < 0)
+		dev_err(&adap->dev,
+			"Failed to add lock_xfer sysfs files: %d\n", r);
+
+	return dev;
+
+#ifdef CONFIG_I2C_DW_SPEED_MODE_DEBUG
+err_del_adap:
+	i2c_del_adapter(&dev->adapter);
+#endif
+err_free_irq:
+	free_irq(irq, dev);
+err_kfree:
+	put_device(pdev);
+	kfree(dev);
+err_iounmap:
+	iounmap(base);
+exit:
+	return ERR_PTR(r);
+}
+EXPORT_SYMBOL(i2c_dw_setup);
+
+#ifdef CONFIG_ACPI
+static int acpi_i2c_get_freq(struct acpi_resource *ares,
+					void *data)
+{
+	struct dw_i2c_dev *i2c = data;
+
+	if (ares->type == ACPI_RESOURCE_TYPE_SERIAL_BUS) {
+		struct acpi_resource_i2c_serialbus *sb;
+
+		sb = &ares->data.i2c_serial_bus;
+		if (sb->type == ACPI_RESOURCE_SERIAL_TYPE_I2C) {
+			i2c->freq = sb->connection_speed;
+			if (i2c->freq == DW_STD_SPEED) {
+				i2c->master_cfg &= ~DW_IC_SPEED_MASK;
+				i2c->master_cfg |= DW_IC_CON_SPEED_STD;
+			} else if (i2c->freq == DW_FAST_SPEED) {
+				i2c->master_cfg &= ~DW_IC_SPEED_MASK;
+				i2c->master_cfg |= DW_IC_CON_SPEED_FAST;
+			} else if (i2c->freq == DW_HIGH_SPEED) {
+				i2c->master_cfg &= ~DW_IC_SPEED_MASK;
+				i2c->master_cfg |= DW_IC_CON_SPEED_HIGH;
+			}
+
+			down(&i2c->lock);
+			i2c_dw_init(i2c);
+			up(&i2c->lock);
+		}
+	}
+
+	return 1;
+}
+
+static acpi_status acpi_i2c_find_device_speed(acpi_handle handle, u32 level,
+					void *data, void **return_value)
+{
+	struct dw_i2c_dev *i2c = data;
+	struct list_head resource_list;
+	struct acpi_device *adev;
+	acpi_status status;
+	unsigned long long sta = 0;
+	int ret;
+
+	if (acpi_bus_get_device(handle, &adev))
+		return AE_OK;
+	if (acpi_bus_get_status(adev) || !adev->status.present)
+		return AE_OK;
+
+	INIT_LIST_HEAD(&resource_list);
+	ret = acpi_dev_get_resources(adev, &resource_list,
+				     acpi_i2c_get_freq, i2c);
+	acpi_dev_free_resource_list(&resource_list);
+
+	if (ret < 0)
+		return AE_OK;
+
+	pr_debug("i2c device: %s, freq: %dkHz\n",
+			dev_name(&adev->dev), i2c->freq/1000);
+
+	return AE_OK;
+}
+
+void i2c_acpi_devices_setup(struct device *pdev, struct dw_i2c_dev *dev)
+{
+	acpi_handle pdev_handle = ACPI_HANDLE(pdev);
+	acpi_handle handle = NULL;
+	acpi_status status;
+
+	if (pdev_handle) {
+		handle = pdev_handle;
+	} else if (dev->controller->acpi_name) {
+		acpi_get_handle(NULL,
+			dev->controller->acpi_name, &handle);
+
+		ACPI_HANDLE_SET(pdev, handle);
+	}
+
+	if (handle == NULL)
+		return;
+
+	acpi_i2c_register_devices(&dev->adapter);
+
+	/* Find I2C adapter bus frequency */
+	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,
+				     acpi_i2c_find_device_speed, NULL,
+				     dev, NULL);
+	if (ACPI_FAILURE(status))
+		dev_warn(pdev, "failed to get I2C bus freq\n");
+
+	/* Set the handle back to its raw value */
+	ACPI_HANDLE_SET(pdev, pdev_handle);
+}
+#else
+void i2c_acpi_devices_setup(struct device *pdev, struct dw_i2c_dev *dev) { }
+#endif
+EXPORT_SYMBOL(i2c_acpi_devices_setup);
+
+void i2c_dw_free(struct device *pdev, struct dw_i2c_dev *dev)
+{
+	struct i2c_adapter *adap = &dev->adapter;
+
+	i2c_dw_disable(dev);
+
+	device_remove_file(&adap->dev, &dev_attr_lock_xfer);
+#ifdef CONFIG_I2C_DW_SPEED_MODE_DEBUG
+	sysfs_remove_group(&pdev->kobj, &i2c_dw_attr_group);
+#endif
+
+	i2c_del_adapter(&dev->adapter);
+	put_device(pdev);
+	free_irq(dev->irq, dev);
+	kfree(dev);
+}
+EXPORT_SYMBOL(i2c_dw_free);
+
 static u32
 i2c_dw_scl_hcnt(u32 ic_clk, u32 tSYMBOL, u32 tf, int cond, int offset)
 {
@@ -254,27 +930,6 @@ static u32 i2c_dw_scl_lcnt(u32 ic_clk, u32 tLOW, u32 tf, int offset)
 	return ((ic_clk * (tLOW + tf) + 500000) / 1000000) - 1 + offset;
 }
 
-static void __i2c_dw_enable(struct dw_i2c_dev *dev, bool enable)
-{
-	int timeout = 100;
-
-	do {
-		dw_writel(dev, enable, DW_IC_ENABLE);
-		if ((dw_readl(dev, DW_IC_ENABLE_STATUS) & 1) == enable)
-			return;
-
-		/*
-		 * Wait 10 times the signaling period of the highest I2C
-		 * transfer supported by the driver (for 400KHz this is
-		 * 25us) as described in the DesignWare I2C databook.
-		 */
-		usleep_range(25, 250);
-	} while (timeout--);
-
-	dev_warn(dev->dev, "timeout in %sabling adapter\n",
-		 enable ? "en" : "dis");
-}
-
 /**
  * i2c_dw_init() - initialize the designware i2c master hardware
  * @dev: device private data
@@ -290,87 +945,72 @@ int i2c_dw_init(struct dw_i2c_dev *dev)
 	u32 reg;
 	u32 sda_falling_time, scl_falling_time;
 
+	if (dev->reset)
+		dev->reset(dev);
+
 	input_clock_khz = dev->get_clk_rate_khz(dev);
 
+	/* Configure register endianess access */
 	reg = dw_readl(dev, DW_IC_COMP_TYPE);
 	if (reg == ___constant_swab32(DW_IC_COMP_TYPE_VALUE)) {
-		/* Configure register endianess access */
-		dev->accessor_flags |= ACCESS_SWAP;
-	} else if (reg == (DW_IC_COMP_TYPE_VALUE & 0x0000ffff)) {
-		/* Configure register access mode 16bit */
-		dev->accessor_flags |= ACCESS_16BIT;
-	} else if (reg != DW_IC_COMP_TYPE_VALUE) {
+		dev->swab = 1;
+		reg = DW_IC_COMP_TYPE_VALUE;
+	}
+
+	if (reg != DW_IC_COMP_TYPE_VALUE) {
 		dev_err(dev->dev, "Unknown Synopsys component type: "
 			"0x%08x\n", reg);
 		return -ENODEV;
 	}
 
 	/* Disable the adapter */
-	__i2c_dw_enable(dev, false);
-
-	/* set standard and fast speed deviders for high/low periods */
-
-	sda_falling_time = dev->sda_falling_time ?: 300; /* ns */
-	scl_falling_time = dev->scl_falling_time ?: 300; /* ns */
-
-	/* Standard-mode */
-	hcnt = i2c_dw_scl_hcnt(input_clock_khz,
-				4000,	/* tHD;STA = tHIGH = 4.0 us */
-				sda_falling_time,
-				0,	/* 0: DW default, 1: Ideal */
-				0);	/* No offset */
-	lcnt = i2c_dw_scl_lcnt(input_clock_khz,
-				4700,	/* tLOW = 4.7 us */
-				scl_falling_time,
-				0);	/* No offset */
-
-	/* Allow platforms to specify the ideal HCNT and LCNT values */
-	if (dev->ss_hcnt && dev->ss_lcnt) {
-		hcnt = dev->ss_hcnt;
-		lcnt = dev->ss_lcnt;
-	}
-	dw_writel(dev, hcnt, DW_IC_SS_SCL_HCNT);
-	dw_writel(dev, lcnt, DW_IC_SS_SCL_LCNT);
-	dev_dbg(dev->dev, "Standard-mode HCNT:LCNT = %d:%d\n", hcnt, lcnt);
-
-	/* Fast-mode */
-	hcnt = i2c_dw_scl_hcnt(input_clock_khz,
-				600,	/* tHD;STA = tHIGH = 0.6 us */
-				sda_falling_time,
-				0,	/* 0: DW default, 1: Ideal */
-				0);	/* No offset */
-	lcnt = i2c_dw_scl_lcnt(input_clock_khz,
-				1300,	/* tLOW = 1.3 us */
-				scl_falling_time,
-				0);	/* No offset */
-
-	if (dev->fs_hcnt && dev->fs_lcnt) {
-		hcnt = dev->fs_hcnt;
-		lcnt = dev->fs_lcnt;
-	}
-	dw_writel(dev, hcnt, DW_IC_FS_SCL_HCNT);
-	dw_writel(dev, lcnt, DW_IC_FS_SCL_LCNT);
-	dev_dbg(dev->dev, "Fast-mode HCNT:LCNT = %d:%d\n", hcnt, lcnt);
-
-	/* Configure SDA Hold Time if required */
-	if (dev->sda_hold_time) {
-		reg = dw_readl(dev, DW_IC_COMP_VERSION);
-		if (reg >= DW_IC_SDA_HOLD_MIN_VERS)
-			dw_writel(dev, dev->sda_hold_time, DW_IC_SDA_HOLD);
-		else
-			dev_warn(dev->dev,
-				"Hardware too old to adjust SDA hold time.");
+	i2c_dw_disable(dev);
+
+	if (dev->get_scl_cfg)
+		dev->get_scl_cfg(dev);
+	else {
+		/* set standard and fast speed deviders for high/low periods */
+
+		/* Standard-mode */
+		hcnt = i2c_dw_scl_hcnt(input_clock_khz,
+					227,	/* tHD;STA = tHIGH = 22.7 us */
+					3,	/* tf = 0.3 us */
+					0,	/* 0: DW default, 1: Ideal */
+					23);	/* offset = 23 */
+		lcnt = i2c_dw_scl_lcnt(input_clock_khz,
+					227,	/* tLOW = 22.7 us */
+					3,	/* tf = 0.3 us */
+					28);	/* offset = 28 */
+		dw_writel(dev, hcnt, DW_IC_SS_SCL_HCNT);
+		dw_writel(dev, lcnt, DW_IC_SS_SCL_LCNT);
+		dev_dbg(dev->dev, "Standard-mode HCNT:LCNT = %d:%d\n",
+					hcnt, lcnt);
+
+		/* Fast-mode */
+		hcnt = i2c_dw_scl_hcnt(input_clock_khz,
+					52,	/* tHD;STA = tHIGH = 5.2 us */
+					3,	/* tf = 0.3 us */
+					0,	/* 0: DW default, 1: Ideal */
+					11);	/* offset = 11 */
+		lcnt = i2c_dw_scl_lcnt(input_clock_khz,
+					72,	/* tLOW = 7.2 us */
+					3,	/* tf = 0.3 us */
+					12);	/* offset = 12 */
+		dw_writel(dev, hcnt, DW_IC_FS_SCL_HCNT);
+		dw_writel(dev, lcnt, DW_IC_FS_SCL_LCNT);
+		dev_dbg(dev->dev, "Fast-mode HCNT:LCNT = %d:%d\n", hcnt, lcnt);
 	}
 
 	/* Configure Tx/Rx FIFO threshold levels */
-	dw_writel(dev, dev->tx_fifo_depth - 1, DW_IC_TX_TL);
-	dw_writel(dev, 0, DW_IC_RX_TL);
+	dw_writel(dev, dev->tx_fifo_depth/2, DW_IC_TX_TL);
+	dw_writel(dev, dev->rx_fifo_depth/2, DW_IC_RX_TL);
 
 	/* configure the i2c master */
 	dw_writel(dev, dev->master_cfg , DW_IC_CON);
+
 	return 0;
 }
-EXPORT_SYMBOL_GPL(i2c_dw_init);
+EXPORT_SYMBOL(i2c_dw_init);
 
 /*
  * Waiting for bus not busy
@@ -385,7 +1025,7 @@ static int i2c_dw_wait_bus_not_busy(struct dw_i2c_dev *dev)
 			return -ETIMEDOUT;
 		}
 		timeout--;
-		usleep_range(1000, 1100);
+		mdelay(1);
 	}
 
 	return 0;
@@ -397,7 +1037,7 @@ static void i2c_dw_xfer_init(struct dw_i2c_dev *dev)
 	u32 ic_con, ic_tar = 0;
 
 	/* Disable the adapter */
-	__i2c_dw_enable(dev, false);
+	i2c_dw_disable(dev);
 
 	/* if the slave address is ten bit address, enable 10BITADDR */
 	ic_con = dw_readl(dev, DW_IC_CON);
@@ -426,7 +1066,7 @@ static void i2c_dw_xfer_init(struct dw_i2c_dev *dev)
 	i2c_dw_disable_int(dev);
 
 	/* Enable the adapter */
-	__i2c_dw_enable(dev, true);
+	i2c_dw_enable(dev);
 
 	/* Clear and enable interrupts */
 	i2c_dw_clear_int(dev);
@@ -439,20 +1079,33 @@ static void i2c_dw_xfer_init(struct dw_i2c_dev *dev)
  * messages into the tx buffer.  Even if the size of i2c_msg data is
  * longer than the size of the tx buffer, it handles everything.
  */
-static void
+void
 i2c_dw_xfer_msg(struct dw_i2c_dev *dev)
 {
 	struct i2c_msg *msgs = dev->msgs;
 	u32 intr_mask;
 	int tx_limit, rx_limit;
+	int cmd;
 	u32 addr = msgs[dev->msg_write_idx].addr;
 	u32 buf_len = dev->tx_buf_len;
 	u8 *buf = dev->tx_buf;
+	unsigned long flags;
 	bool need_restart = false;
 
 	intr_mask = DW_IC_INTR_DEFAULT_MASK;
 
+	raw_local_irq_save(flags);
+	/* if fifo only has one byte, it is not safe */
+	if (!dev->enable_stop && (dev->status & STATUS_WRITE_IN_PROGRESS) &&
+		(dw_readl(dev, DW_IC_TXFLR) < 1)) {
+		dev_err(dev->dev, "TX FIFO underrun, addr: 0x%x.\n", addr);
+		dev->msg_err = -EAGAIN;
+	}
+
 	for (; dev->msg_write_idx < dev->msgs_num; dev->msg_write_idx++) {
+		if (dev->msg_err)
+			break;
+
 		/*
 		 * if target address has changed, we need to
 		 * reprogram the target address in the i2c
@@ -490,18 +1143,9 @@ i2c_dw_xfer_msg(struct dw_i2c_dev *dev)
 		rx_limit = dev->rx_fifo_depth - dw_readl(dev, DW_IC_RXFLR);
 
 		while (buf_len > 0 && tx_limit > 0 && rx_limit > 0) {
-			u32 cmd = 0;
-
-			/*
-			 * If IC_EMPTYFIFO_HOLD_MASTER_EN is set we must
-			 * manually set the stop bit. However, it cannot be
-			 * detected from the registers so we set it always
-			 * when writing/reading the last byte.
-			 */
-			if (dev->msg_write_idx == dev->msgs_num - 1 &&
-			    buf_len == 1)
-				cmd |= BIT(9);
-
+			cmd = (dev->enable_stop && buf_len == 1
+				&& dev->msg_write_idx == dev->msgs_num - 1) ?
+				DW_IC_CMD_STOP : 0;
 			if (need_restart) {
 				cmd |= BIT(10);
 				need_restart = false;
@@ -509,13 +1153,8 @@ i2c_dw_xfer_msg(struct dw_i2c_dev *dev)
 
 			if (msgs[dev->msg_write_idx].flags & I2C_M_RD) {
 
-				/* avoid rx buffer overrun */
-				if (rx_limit - dev->rx_outstanding <= 0)
-					break;
-
 				dw_writel(dev, cmd | 0x100, DW_IC_DATA_CMD);
 				rx_limit--;
-				dev->rx_outstanding++;
 			} else
 				dw_writel(dev, cmd | *buf++, DW_IC_DATA_CMD);
 			tx_limit--; buf_len--;
@@ -531,6 +1170,7 @@ i2c_dw_xfer_msg(struct dw_i2c_dev *dev)
 		} else
 			dev->status &= ~STATUS_WRITE_IN_PROGRESS;
 	}
+	raw_local_irq_restore(flags);
 
 	/*
 	 * If i2c_msg index search is completed, we don't need TX_EMPTY
@@ -568,10 +1208,8 @@ i2c_dw_read(struct dw_i2c_dev *dev)
 
 		rx_valid = dw_readl(dev, DW_IC_RXFLR);
 
-		for (; len > 0 && rx_valid > 0; len--, rx_valid--) {
+		for (; len > 0 && rx_valid > 0; len--, rx_valid--)
 			*buf++ = dw_readl(dev, DW_IC_DATA_CMD);
-			dev->rx_outstanding--;
-		}
 
 		if (len > 0) {
 			dev->status |= STATUS_READ_IN_PROGRESS;
@@ -614,10 +1252,11 @@ i2c_dw_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
 {
 	struct dw_i2c_dev *dev = i2c_get_adapdata(adap);
 	int ret;
+	unsigned long timeout;
 
 	dev_dbg(dev->dev, "%s: msgs: %d\n", __func__, num);
 
-	mutex_lock(&dev->lock);
+	down(&dev->lock);
 	pm_runtime_get_sync(dev->dev);
 
 	reinit_completion(&dev->cmd_complete);
@@ -629,7 +1268,6 @@ i2c_dw_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
 	dev->msg_err = 0;
 	dev->status = STATUS_IDLE;
 	dev->abort_source = 0;
-	dev->rx_outstanding = 0;
 
 	ret = i2c_dw_wait_bus_not_busy(dev);
 	if (ret < 0)
@@ -639,9 +1277,13 @@ i2c_dw_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
 	i2c_dw_xfer_init(dev);
 
 	/* wait for tx to complete */
-	ret = wait_for_completion_timeout(&dev->cmd_complete, HZ);
-	if (ret == 0) {
-		dev_err(dev->dev, "controller timed out\n");
+	timeout = wait_for_completion_timeout(&dev->cmd_complete, 3*HZ);
+	if (timeout == 0) {
+		dev_WARN(dev->dev, "controller timed out\n");
+		i2c_dw_dump(dev);
+		trigger_all_cpu_backtrace();
+		if (dev->abort)
+			dev->abort(adap->nr);
 		/* i2c_dw_init implicitly disables the adapter */
 		i2c_dw_init(dev);
 		ret = -ETIMEDOUT;
@@ -655,7 +1297,7 @@ i2c_dw_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
 	 * Needs some more investigation if the additional interrupts are
 	 * a hardware bug or this driver doesn't handle them correctly yet.
 	 */
-	__i2c_dw_enable(dev, false);
+	i2c_dw_disable(dev);
 
 	if (dev->msg_err) {
 		ret = dev->msg_err;
@@ -678,18 +1320,16 @@ i2c_dw_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
 done:
 	pm_runtime_mark_last_busy(dev->dev);
 	pm_runtime_put_autosuspend(dev->dev);
-	mutex_unlock(&dev->lock);
+	up(&dev->lock);
 
 	return ret;
 }
-EXPORT_SYMBOL_GPL(i2c_dw_xfer);
 
 u32 i2c_dw_func(struct i2c_adapter *adap)
 {
 	struct dw_i2c_dev *dev = i2c_get_adapdata(adap);
 	return dev->functionality;
 }
-EXPORT_SYMBOL_GPL(i2c_dw_func);
 
 static u32 i2c_dw_read_clear_intrbits(struct dw_i2c_dev *dev)
 {
@@ -755,15 +1395,33 @@ irqreturn_t i2c_dw_isr(int this_irq, void *dev_id)
 	struct dw_i2c_dev *dev = dev_id;
 	u32 stat, enabled;
 
+	pm_runtime_get(dev->dev);
+#ifdef CONFIG_PM_RUNTIME
+	if (!pm_runtime_active(dev->dev)) {
+		pm_runtime_put_autosuspend(dev->dev);
+		if (dev->share_irq)
+			return IRQ_NONE;
+		else
+			return IRQ_HANDLED;
+	}
+#endif
 	enabled = dw_readl(dev, DW_IC_ENABLE);
 	stat = dw_readl(dev, DW_IC_RAW_INTR_STAT);
 	dev_dbg(dev->dev, "%s:  %s enabled= 0x%x stat=0x%x\n", __func__,
 		dev->adapter.name, enabled, stat);
-	if (!enabled || !(stat & ~DW_IC_INTR_ACTIVITY))
-		return IRQ_NONE;
+	if (!enabled || !(stat & ~DW_IC_INTR_ACTIVITY)) {
+		pm_runtime_put_autosuspend(dev->dev);
+		if (dev->share_irq)
+			return IRQ_NONE;
+		else
+			return IRQ_HANDLED;
+	}
 
 	stat = i2c_dw_read_clear_intrbits(dev);
 
+	if (stat & DW_IC_INTR_RX_OVER)
+		dev_warn(dev->dev, "RX fifo overrun\n");
+
 	if (stat & DW_IC_INTR_TX_ABRT) {
 		dev->cmd_err |= DW_IC_ERR_TX_ABRT;
 		dev->status = STATUS_IDLE;
@@ -789,25 +1447,49 @@ irqreturn_t i2c_dw_isr(int this_irq, void *dev_id)
 	 */
 
 tx_aborted:
-	if ((stat & (DW_IC_INTR_TX_ABRT | DW_IC_INTR_STOP_DET)) || dev->msg_err)
+	if ((stat & (DW_IC_INTR_TX_ABRT | DW_IC_INTR_STOP_DET))
+					|| dev->msg_err) {
+		/*
+		 * Check DW_IC_RXFLR register,
+		 * read from the RX FIFO if it's not empty.
+		 */
+		if ((stat & DW_IC_INTR_STOP_DET) &&
+			dw_readl(dev, DW_IC_RXFLR) > 0)
+			i2c_dw_read(dev);
+
 		complete(&dev->cmd_complete);
+	}
 
+	pm_runtime_put_autosuspend(dev->dev);
 	return IRQ_HANDLED;
 }
-EXPORT_SYMBOL_GPL(i2c_dw_isr);
 
-void i2c_dw_enable(struct dw_i2c_dev *dev)
+u32 i2c_dw_is_enabled(struct dw_i2c_dev *dev)
 {
-       /* Enable the adapter */
-	__i2c_dw_enable(dev, true);
+	return dw_readl(dev, DW_IC_ENABLE_STATUS);
 }
-EXPORT_SYMBOL_GPL(i2c_dw_enable);
 
-u32 i2c_dw_is_enabled(struct dw_i2c_dev *dev)
+static void __i2c_dw_enable(struct dw_i2c_dev *dev, bool enable)
+{
+	int timeout = 100;
+
+	do {
+		dw_writel(dev, enable, DW_IC_ENABLE);
+		if (i2c_dw_is_enabled(dev) == enable)
+			return;
+
+		usleep_range(25, 250);
+	} while (timeout-- > 0);
+
+	dev_warn(dev->dev, "timeout in %sabling adapter\n",
+		enable ? "en" : "dis");
+}
+
+void i2c_dw_enable(struct dw_i2c_dev *dev)
 {
-	return dw_readl(dev, DW_IC_ENABLE);
+       /* Enable the adapter */
+	__i2c_dw_enable(dev, true);
 }
-EXPORT_SYMBOL_GPL(i2c_dw_is_enabled);
 
 void i2c_dw_disable(struct dw_i2c_dev *dev)
 {
@@ -818,25 +1500,18 @@ void i2c_dw_disable(struct dw_i2c_dev *dev)
 	dw_writel(dev, 0, DW_IC_INTR_MASK);
 	dw_readl(dev, DW_IC_CLR_INTR);
 }
-EXPORT_SYMBOL_GPL(i2c_dw_disable);
 
 void i2c_dw_clear_int(struct dw_i2c_dev *dev)
 {
 	dw_readl(dev, DW_IC_CLR_INTR);
 }
-EXPORT_SYMBOL_GPL(i2c_dw_clear_int);
 
 void i2c_dw_disable_int(struct dw_i2c_dev *dev)
 {
 	dw_writel(dev, 0, DW_IC_INTR_MASK);
 }
-EXPORT_SYMBOL_GPL(i2c_dw_disable_int);
 
 u32 i2c_dw_read_comp_param(struct dw_i2c_dev *dev)
 {
 	return dw_readl(dev, DW_IC_COMP_PARAM_1);
 }
-EXPORT_SYMBOL_GPL(i2c_dw_read_comp_param);
-
-MODULE_DESCRIPTION("Synopsys DesignWare I2C bus adapter core");
-MODULE_LICENSE("GPL");
diff --git a/drivers/i2c/busses/i2c-designware-core.h b/drivers/i2c/busses/i2c-designware-core.h
index d66b6cb..1c7180d 100644
--- a/drivers/i2c/busses/i2c-designware-core.h
+++ b/drivers/i2c/busses/i2c-designware-core.h
@@ -26,15 +26,171 @@
  *
  */
 
+/*
+ * Registers offset
+ */
+#define DW_IC_CON		0x0
+#define DW_IC_TAR		0x4
+#define DW_IC_DATA_CMD		0x10
+#define DW_IC_SS_SCL_HCNT	0x14
+#define DW_IC_SS_SCL_LCNT	0x18
+#define DW_IC_FS_SCL_HCNT	0x1c
+#define DW_IC_FS_SCL_LCNT	0x20
+#define DW_IC_HS_SCL_HCNT	0x24
+#define DW_IC_HS_SCL_LCNT	0x28
+#define DW_IC_INTR_STAT		0x2c
+#define DW_IC_INTR_MASK		0x30
+#define DW_IC_RAW_INTR_STAT	0x34
+#define DW_IC_RX_TL		0x38
+#define DW_IC_TX_TL		0x3c
+#define DW_IC_CLR_INTR		0x40
+#define DW_IC_CLR_RX_UNDER	0x44
+#define DW_IC_CLR_RX_OVER	0x48
+#define DW_IC_CLR_TX_OVER	0x4c
+#define DW_IC_CLR_RD_REQ	0x50
+#define DW_IC_CLR_TX_ABRT	0x54
+#define DW_IC_CLR_RX_DONE	0x58
+#define DW_IC_CLR_ACTIVITY	0x5c
+#define DW_IC_CLR_STOP_DET	0x60
+#define DW_IC_CLR_START_DET	0x64
+#define DW_IC_CLR_GEN_CALL	0x68
+#define DW_IC_ENABLE		0x6c
+#define DW_IC_STATUS		0x70
+#define DW_IC_TXFLR		0x74
+#define DW_IC_RXFLR		0x78
+#define DW_IC_TX_ABRT_SOURCE	0x80
+#define DW_IC_ENABLE_STATUS	0x9c
+#define DW_IC_COMP_PARAM_1	0xf4
+#define DW_IC_COMP_TYPE		0xfc
+#define DW_IC_COMP_TYPE_VALUE	0x44570140
 
 #define DW_IC_CON_MASTER		0x1
 #define DW_IC_CON_SPEED_STD		0x2
 #define DW_IC_CON_SPEED_FAST		0x4
+#define DW_IC_CON_SPEED_HIGH		0x6
 #define DW_IC_CON_10BITADDR_MASTER	0x10
 #define DW_IC_CON_RESTART_EN		0x20
 #define DW_IC_CON_SLAVE_DISABLE		0x40
 
+#define INTEL_MID_STD_CFG  (DW_IC_CON_MASTER |			\
+				DW_IC_CON_SLAVE_DISABLE |	\
+				DW_IC_CON_RESTART_EN)
+
+#define DW_IC_INTR_RX_UNDER	0x001
+#define DW_IC_INTR_RX_OVER	0x002
+#define DW_IC_INTR_RX_FULL	0x004
+#define DW_IC_INTR_TX_OVER	0x008
+#define DW_IC_INTR_TX_EMPTY	0x010
+#define DW_IC_INTR_RD_REQ	0x020
+#define DW_IC_INTR_TX_ABRT	0x040
+#define DW_IC_INTR_RX_DONE	0x080
+#define DW_IC_INTR_ACTIVITY	0x100
+#define DW_IC_INTR_STOP_DET	0x200
+#define DW_IC_INTR_START_DET	0x400
+#define DW_IC_INTR_GEN_CALL	0x800
+
+#define DW_IC_INTR_DEFAULT_MASK		(DW_IC_INTR_RX_FULL | \
+					 DW_IC_INTR_TX_EMPTY | \
+					 DW_IC_INTR_TX_ABRT | \
+					 DW_IC_INTR_STOP_DET | \
+					 DW_IC_INTR_RX_OVER)
+
+#define DW_IC_STATUS_ACTIVITY	0x1
+
+#define DW_IC_ERR_TX_ABRT	0x1
+
+#define DW_IC_CMD_STOP		0x200
+
+#define DW_IC_SPEED_MASK	0x6
+
+/*
+ * status codes
+ */
+#define STATUS_POWERON			0x0
+#define STATUS_IDLE			STATUS_POWERON
+#define STATUS_WRITE_IN_PROGRESS	0x1
+#define STATUS_READ_IN_PROGRESS		0x2
+
+#define TIMEOUT			20 /* ms */
+
+/*
+ * hardware abort codes from the DW_IC_TX_ABRT_SOURCE register
+ *
+ * only expected abort codes are listed here
+ * refer to the datasheet for the full list
+ */
+#define ABRT_7B_ADDR_NOACK	0
+#define ABRT_10ADDR1_NOACK	1
+#define ABRT_10ADDR2_NOACK	2
+#define ABRT_TXDATA_NOACK	3
+#define ABRT_GCALL_NOACK	4
+#define ABRT_GCALL_READ		5
+#define ABRT_SBYTE_ACKDET	7
+#define ABRT_SBYTE_NORSTRT	9
+#define ABRT_10B_RD_NORSTRT	10
+#define ABRT_MASTER_DIS		11
+#define ARB_LOST		12
+
+#define DW_IC_TX_ABRT_7B_ADDR_NOACK	(1UL << ABRT_7B_ADDR_NOACK)
+#define DW_IC_TX_ABRT_10ADDR1_NOACK	(1UL << ABRT_10ADDR1_NOACK)
+#define DW_IC_TX_ABRT_10ADDR2_NOACK	(1UL << ABRT_10ADDR2_NOACK)
+#define DW_IC_TX_ABRT_TXDATA_NOACK	(1UL << ABRT_TXDATA_NOACK)
+#define DW_IC_TX_ABRT_GCALL_NOACK	(1UL << ABRT_GCALL_NOACK)
+#define DW_IC_TX_ABRT_GCALL_READ	(1UL << ABRT_GCALL_READ)
+#define DW_IC_TX_ABRT_SBYTE_ACKDET	(1UL << ABRT_SBYTE_ACKDET)
+#define DW_IC_TX_ABRT_SBYTE_NORSTRT	(1UL << ABRT_SBYTE_NORSTRT)
+#define DW_IC_TX_ABRT_10B_RD_NORSTRT	(1UL << ABRT_10B_RD_NORSTRT)
+#define DW_IC_TX_ABRT_MASTER_DIS	(1UL << ABRT_MASTER_DIS)
+#define DW_IC_TX_ARB_LOST		(1UL << ARB_LOST)
+
+#define DW_IC_TX_ABRT_NOACK		(DW_IC_TX_ABRT_7B_ADDR_NOACK | \
+					 DW_IC_TX_ABRT_10ADDR1_NOACK | \
+					 DW_IC_TX_ABRT_10ADDR2_NOACK | \
+					 DW_IC_TX_ABRT_TXDATA_NOACK | \
+					 DW_IC_TX_ABRT_GCALL_NOACK)
 
+/*
+ * i2c scl hcnt/lcnt setting
+ */
+#define PNW_SS_SCLK_HCNT		0x1EC
+#define PNW_SS_SCLK_LCNT		0x1F3
+#define PNW_FS_SCLK_HCNT		0x66
+#define PNW_FS_SCLK_LCNT		0x8B
+#define PNW_HS_SCLK_HCNT		0x9
+#define PNW_HS_SCLK_LCNT		0x17
+
+#define CLV_SS_SCLK_HCNT		0x1EC
+#define CLV_SS_SCLK_LCNT		0x1F3
+#define CLV_FS_SCLK_HCNT		0x59
+#define CLV_FS_SCLK_LCNT		0x98
+#define CLV_HS_SCLK_HCNT		0x8
+#define CLV_HS_SCLK_LCNT		0x17
+
+/* inofficial configuration
+#define MERR_SS_SCLK_HCNT 0x2c8
+#define MERR_SS_SCLK_LCNT 0x380
+#define MERR_FS_SCLK_HCNT 0x084
+#define MERR_FS_SCLK_LCNT 0x100
+*/
+#define MERR_SS_SCLK_HCNT 0x2f8
+#define MERR_SS_SCLK_LCNT 0x37b
+#define MERR_FS_SCLK_HCNT 0x087
+#define MERR_FS_SCLK_LCNT 0x10a
+#define MERR_HS_SCLK_HCNT 0x8
+#define MERR_HS_SCLK_LCNT 0x20
+
+#define VLV2_SS_SCLK_HCNT 0x214
+#define VLV2_SS_SCLK_LCNT 0x272
+#define VLV2_FS_SCLK_HCNT 0x50
+#define VLV2_FS_SCLK_LCNT 0xad
+#define VLV2_HS_SCLK_HCNT 0x6
+#define VLV2_HS_SCLK_LCNT 0x16
+
+#define DW_STD_SPEED	100000
+#define DW_FAST_SPEED	400000
+#define DW_HIGH_SPEED	3400000
+
+struct dw_controller;
 /**
  * struct dw_i2c_dev - private i2c-designware data
  * @dev: driver model device node
@@ -74,10 +230,15 @@ struct dw_i2c_dev {
 	struct device		*dev;
 	void __iomem		*base;
 	struct completion	cmd_complete;
-	struct mutex		lock;
+	struct semaphore	lock;
 	struct clk		*clk;
 	u32			(*get_clk_rate_khz) (struct dw_i2c_dev *dev);
-	struct dw_pci_controller *controller;
+	int			(*get_scl_cfg) (struct dw_i2c_dev *dev);
+	void			(*reset)(struct dw_i2c_dev *dev);
+	int			(*abort)(int busnum);
+	struct dw_controller 	*controller;
+	int			enable_stop;
+	int			share_irq;
 	int			cmd_err;
 	struct i2c_msg		*msgs;
 	int			msgs_num;
@@ -91,13 +252,17 @@ struct dw_i2c_dev {
 	unsigned int		status;
 	u32			abort_source;
 	int			irq;
-	u32			accessor_flags;
+	int			swab;
 	struct i2c_adapter	adapter;
 	u32			functionality;
 	u32			master_cfg;
 	unsigned int		tx_fifo_depth;
 	unsigned int		rx_fifo_depth;
-	int			rx_outstanding;
+	int			use_dyn_clk;	/* use dynamic clk setting */
+	u32			clk_khz;	/* input clock */
+	u32			speed_cfg;
+	u32			lock_flag;
+	u32			freq;
 	u32			sda_hold_time;
 	u32			sda_falling_time;
 	u32			scl_falling_time;
@@ -107,19 +272,94 @@ struct dw_i2c_dev {
 	u16			fs_lcnt;
 };
 
-#define ACCESS_SWAP		0x00000001
-#define ACCESS_16BIT		0x00000002
-
-extern u32 dw_readl(struct dw_i2c_dev *dev, int offset);
-extern void dw_writel(struct dw_i2c_dev *dev, u32 b, int offset);
-extern int i2c_dw_init(struct dw_i2c_dev *dev);
-extern int i2c_dw_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[],
-		int num);
-extern u32 i2c_dw_func(struct i2c_adapter *adap);
-extern irqreturn_t i2c_dw_isr(int this_irq, void *dev_id);
-extern void i2c_dw_enable(struct dw_i2c_dev *dev);
-extern u32 i2c_dw_is_enabled(struct dw_i2c_dev *dev);
-extern void i2c_dw_disable(struct dw_i2c_dev *dev);
-extern void i2c_dw_clear_int(struct dw_i2c_dev *dev);
-extern void i2c_dw_disable_int(struct dw_i2c_dev *dev);
-extern u32 i2c_dw_read_comp_param(struct dw_i2c_dev *dev);
+struct dw_controller {
+	u32 bus_num;
+	u32 bus_cfg;
+	u32 tx_fifo_depth;
+	u32 rx_fifo_depth;
+	u32 clk_khz;
+	int enable_stop;
+	int share_irq;
+	char *acpi_name;
+	int (*scl_cfg) (struct dw_i2c_dev *dev);
+	void (*reset)(struct dw_i2c_dev *dev);
+	u32 functionality;
+	struct dw_scl_sda_cfg *scl_sda_cfg;
+};
+
+struct dw_scl_sda_cfg {
+        u32 ss_hcnt;
+        u32 fs_hcnt;
+        u32 ss_lcnt;
+        u32 fs_lcnt;
+        u32 sda_hold;
+};
+
+#define DW_DEFAULT_FUNCTIONALITY (I2C_FUNC_I2C |                        \
+                                        I2C_FUNC_SMBUS_BYTE |           \
+                                        I2C_FUNC_SMBUS_BYTE_DATA |      \
+                                        I2C_FUNC_SMBUS_WORD_DATA |      \
+                                        I2C_FUNC_SMBUS_I2C_BLOCK)
+
+
+/* BayTrail HCNT/LCNT/SDA hold time */
+static struct dw_scl_sda_cfg byt_config = {
+        .ss_hcnt = 0x200,
+        .fs_hcnt = 0x55,
+        .ss_lcnt = 0x200,
+        .fs_lcnt = 0x99,
+        .sda_hold = 0x6,
+};
+enum dw_ctl_id_t {
+	moorestown_0,
+	moorestown_1,
+	moorestown_2,
+
+	medfield_0,
+	medfield_1,
+	medfield_2,
+	medfield_3,
+	medfield_4,
+	medfield_5,
+	baytrail,
+
+	cloverview_0,
+	cloverview_1,
+	cloverview_2,
+	cloverview_3,
+	cloverview_4,
+	cloverview_5,
+
+	merrifield_0,
+	merrifield_1,
+	merrifield_2,
+	merrifield_3,
+	merrifield_4,
+	merrifield_5,
+	merrifield_6,
+
+	valleyview_0,
+	valleyview_1,
+	valleyview_2,
+	valleyview_3,
+	valleyview_4,
+	valleyview_5,
+	valleyview_6,
+
+	cherryview_0 = valleyview_0,
+	cherryview_1 = valleyview_1,
+	cherryview_2 = valleyview_2,
+	cherryview_3 = valleyview_3,
+	cherryview_4 = valleyview_4,
+	cherryview_5 = valleyview_5,
+	cherryview_6 = valleyview_6,
+};
+
+extern int intel_mid_dw_i2c_abort(int busnum);
+int i2c_dw_init(struct dw_i2c_dev *dev);
+struct dw_i2c_dev *i2c_dw_setup(struct device *pdev, int bus_idx,
+	unsigned long start, unsigned long len, int irq);
+void i2c_dw_free(struct device *pdev, struct dw_i2c_dev *dev);
+int i2c_dw_suspend(struct dw_i2c_dev *dev, bool runtime);
+int i2c_dw_resume(struct dw_i2c_dev *dev, bool runtime);
+void i2c_acpi_devices_setup(struct device *pdev, struct dw_i2c_dev *dev);
diff --git a/drivers/i2c/busses/i2c-designware-pcidrv.c b/drivers/i2c/busses/i2c-designware-pcidrv.c
index 7415810..ea2811f 100644
--- a/drivers/i2c/busses/i2c-designware-pcidrv.c
+++ b/drivers/i2c/busses/i2c-designware-pcidrv.c
@@ -39,149 +39,33 @@
 #include <linux/slab.h>
 #include <linux/pci.h>
 #include <linux/pm_runtime.h>
+#include <linux/semaphore.h>
+#include <linux/fs.h>
+#include <linux/acpi.h>
 #include "i2c-designware-core.h"
 
 #define DRIVER_NAME "i2c-designware-pci"
+#define DW_I2C_STATIC_BUS_NUM	10
 
-enum dw_pci_ctl_id_t {
-	moorestown_0,
-	moorestown_1,
-	moorestown_2,
-
-	medfield_0,
-	medfield_1,
-	medfield_2,
-	medfield_3,
-	medfield_4,
-	medfield_5,
-
-	baytrail,
-};
-
-struct dw_scl_sda_cfg {
-	u32 ss_hcnt;
-	u32 fs_hcnt;
-	u32 ss_lcnt;
-	u32 fs_lcnt;
-	u32 sda_hold;
-};
-
-struct dw_pci_controller {
-	u32 bus_num;
-	u32 bus_cfg;
-	u32 tx_fifo_depth;
-	u32 rx_fifo_depth;
-	u32 clk_khz;
-	u32 functionality;
-	struct dw_scl_sda_cfg *scl_sda_cfg;
-};
+static int i2c_dw_pci_suspend(struct device *dev)
+{
+	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
+	struct dw_i2c_dev *i2c = pci_get_drvdata(pdev);
 
-#define INTEL_MID_STD_CFG  (DW_IC_CON_MASTER |			\
-				DW_IC_CON_SLAVE_DISABLE |	\
-				DW_IC_CON_RESTART_EN)
-
-#define DW_DEFAULT_FUNCTIONALITY (I2C_FUNC_I2C |			\
-					I2C_FUNC_SMBUS_BYTE |		\
-					I2C_FUNC_SMBUS_BYTE_DATA |	\
-					I2C_FUNC_SMBUS_WORD_DATA |	\
-					I2C_FUNC_SMBUS_I2C_BLOCK)
-
-/* BayTrail HCNT/LCNT/SDA hold time */
-static struct dw_scl_sda_cfg byt_config = {
-	.ss_hcnt = 0x200,
-	.fs_hcnt = 0x55,
-	.ss_lcnt = 0x200,
-	.fs_lcnt = 0x99,
-	.sda_hold = 0x6,
-};
+	dev_dbg(dev, "suspend called\n");
 
-static struct  dw_pci_controller  dw_pci_controllers[] = {
-	[moorestown_0] = {
-		.bus_num     = 0,
-		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
-		.clk_khz      = 25000,
-	},
-	[moorestown_1] = {
-		.bus_num     = 1,
-		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
-		.clk_khz      = 25000,
-	},
-	[moorestown_2] = {
-		.bus_num     = 2,
-		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
-		.clk_khz      = 25000,
-	},
-	[medfield_0] = {
-		.bus_num     = 0,
-		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
-		.clk_khz      = 25000,
-	},
-	[medfield_1] = {
-		.bus_num     = 1,
-		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
-		.clk_khz      = 25000,
-	},
-	[medfield_2] = {
-		.bus_num     = 2,
-		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
-		.clk_khz      = 25000,
-	},
-	[medfield_3] = {
-		.bus_num     = 3,
-		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_STD,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
-		.clk_khz      = 25000,
-	},
-	[medfield_4] = {
-		.bus_num     = 4,
-		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
-		.clk_khz      = 25000,
-	},
-	[medfield_5] = {
-		.bus_num     = 5,
-		.bus_cfg   = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
-		.clk_khz      = 25000,
-	},
-	[baytrail] = {
-		.bus_num = -1,
-		.bus_cfg = INTEL_MID_STD_CFG | DW_IC_CON_SPEED_FAST,
-		.tx_fifo_depth = 32,
-		.rx_fifo_depth = 32,
-		.clk_khz = 100000,
-		.functionality = I2C_FUNC_10BIT_ADDR,
-		.scl_sda_cfg = &byt_config,
-	},
-};
-static struct i2c_algorithm i2c_dw_algo = {
-	.master_xfer	= i2c_dw_xfer,
-	.functionality	= i2c_dw_func,
-};
+	return i2c_dw_suspend(i2c, false);
+}
 
-static int i2c_dw_pci_suspend(struct device *dev)
+static int i2c_dw_pci_runtime_suspend(struct device *dev)
 {
 	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
 	struct dw_i2c_dev *i2c = pci_get_drvdata(pdev);
 	int err;
 
 
-	i2c_dw_disable(i2c);
+	dev_dbg(dev, "runtime suspend called\n");
+	i2c_dw_suspend(i2c, true);
 
 	err = pci_save_state(pdev);
 	if (err) {
@@ -205,9 +89,17 @@ static int i2c_dw_pci_resume(struct device *dev)
 	int err;
 	u32 enabled;
 
-	enabled = i2c_dw_is_enabled(i2c);
-	if (enabled)
-		return 0;
+	dev_dbg(dev, "resume called\n");
+	return i2c_dw_resume(i2c, false);
+}
+
+static int i2c_dw_pci_runtime_resume(struct device *dev)
+{
+	struct pci_dev *pdev = container_of(dev, struct pci_dev, dev);
+	struct dw_i2c_dev *i2c = pci_get_drvdata(pdev);
+	int err;
+ 
+	dev_dbg(dev, "runtime resume called\n");
 
 	err = pci_set_power_state(pdev, PCI_D0);
 	if (err) {
@@ -216,122 +108,66 @@ static int i2c_dw_pci_resume(struct device *dev)
 	}
 
 	pci_restore_state(pdev);
+	i2c_dw_resume(i2c, true);
 
-	i2c_dw_init(i2c);
 	return 0;
 }
 
-static int i2c_dw_pci_runtime_idle(struct device *dev)
-{
-	int err = pm_schedule_suspend(dev, 500);
-	dev_dbg(dev, "runtime_idle called\n");
-
-	if (err != 0)
-		return 0;
-	return -EBUSY;
-}
-
 static const struct dev_pm_ops i2c_dw_pm_ops = {
-	.resume         = i2c_dw_pci_resume,
-	.suspend        = i2c_dw_pci_suspend,
-	SET_RUNTIME_PM_OPS(i2c_dw_pci_suspend, i2c_dw_pci_resume,
-			   i2c_dw_pci_runtime_idle)
+	.suspend_late = i2c_dw_pci_suspend,
+	.resume_early = i2c_dw_pci_resume,
+	SET_RUNTIME_PM_OPS(i2c_dw_pci_runtime_suspend,
+			   i2c_dw_pci_runtime_resume,
+			   NULL)
 };
 
-static u32 i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)
-{
-	return dev->controller->clk_khz;
-}
-
 static int i2c_dw_pci_probe(struct pci_dev *pdev,
-			    const struct pci_device_id *id)
+const struct pci_device_id *id)
 {
 	struct dw_i2c_dev *dev;
-	struct i2c_adapter *adap;
+	unsigned long start, len;
 	int r;
-	struct  dw_pci_controller *controller;
 	struct dw_scl_sda_cfg *cfg;
+	int bus_idx;
+	static int bus_num;
 
-	if (id->driver_data >= ARRAY_SIZE(dw_pci_controllers)) {
-		dev_err(&pdev->dev, "%s: invalid driver data %ld\n", __func__,
-			id->driver_data);
-		return -EINVAL;
-	}
-
-	controller = &dw_pci_controllers[id->driver_data];
-
-	r = pcim_enable_device(pdev);
+	r = pci_enable_device(pdev);
 	if (r) {
 		dev_err(&pdev->dev, "Failed to enable I2C PCI device (%d)\n",
 			r);
 		return r;
 	}
 
-	r = pcim_iomap_regions(pdev, 1 << 0, pci_name(pdev));
+	/* Determine the address of the I2C area */
+	start = pci_resource_start(pdev, 0);
+	len = pci_resource_len(pdev, 0);
+	if (!start || len == 0) {
+		dev_err(&pdev->dev, "base address not set\n");
+		return -ENODEV;
+	}
+
+	r = pci_request_region(pdev, 0, DRIVER_NAME);
 	if (r) {
-		dev_err(&pdev->dev, "I/O memory remapping failed\n");
+		dev_err(&pdev->dev, "failed to request I2C region "
+			"0x%lx-0x%lx\n", start,
+			(unsigned long)pci_resource_end(pdev, 0));
 		return r;
 	}
 
-	dev = devm_kzalloc(&pdev->dev, sizeof(struct dw_i2c_dev), GFP_KERNEL);
-	if (!dev)
-		return -ENOMEM;
-
-	init_completion(&dev->cmd_complete);
-	mutex_init(&dev->lock);
-	dev->clk = NULL;
-	dev->controller = controller;
-	dev->get_clk_rate_khz = i2c_dw_get_clk_rate_khz;
-	dev->base = pcim_iomap_table(pdev)[0];
-	dev->dev = &pdev->dev;
-	dev->functionality = controller->functionality |
-				DW_DEFAULT_FUNCTIONALITY;
-
-	dev->master_cfg =  controller->bus_cfg;
-	if (controller->scl_sda_cfg) {
-		cfg = controller->scl_sda_cfg;
-		dev->ss_hcnt = cfg->ss_hcnt;
-		dev->fs_hcnt = cfg->fs_hcnt;
-		dev->ss_lcnt = cfg->ss_lcnt;
-		dev->fs_lcnt = cfg->fs_lcnt;
-		dev->sda_hold_time = cfg->sda_hold;
-	}
+	dev = i2c_dw_setup(&pdev->dev, bus_idx, start, len, pdev->irq);
+	if (IS_ERR(dev)) {
+		pci_release_region(pdev, 0);
+		dev_err(&pdev->dev, "failed to setup i2c\n");
+		return -EINVAL;
+ 	}
 
 	pci_set_drvdata(pdev, dev);
 
-	dev->tx_fifo_depth = controller->tx_fifo_depth;
-	dev->rx_fifo_depth = controller->rx_fifo_depth;
-	r = i2c_dw_init(dev);
-	if (r)
-		return r;
-
-	adap = &dev->adapter;
-	i2c_set_adapdata(adap, dev);
-	adap->owner = THIS_MODULE;
-	adap->class = 0;
-	adap->algo = &i2c_dw_algo;
-	adap->dev.parent = &pdev->dev;
-	adap->nr = controller->bus_num;
-
-	snprintf(adap->name, sizeof(adap->name), "i2c-designware-pci");
-
-	r = devm_request_irq(&pdev->dev, pdev->irq, i2c_dw_isr, IRQF_SHARED,
-			adap->name, dev);
-	if (r) {
-		dev_err(&pdev->dev, "failure requesting irq %i\n", dev->irq);
-		return r;
-	}
-
-	i2c_dw_disable_int(dev);
-	i2c_dw_clear_int(dev);
-	r = i2c_add_numbered_adapter(adap);
-	if (r) {
-		dev_err(&pdev->dev, "failure adding adapter\n");
-		return r;
-	}
+	i2c_acpi_devices_setup(&pdev->dev, dev);
 
-	pm_runtime_set_autosuspend_delay(&pdev->dev, 1000);
+	pm_runtime_set_autosuspend_delay(&pdev->dev, 50);
 	pm_runtime_use_autosuspend(&pdev->dev);
+	pm_runtime_put_noidle(&pdev->dev);
 	pm_runtime_allow(&pdev->dev);
 
 	return 0;
@@ -341,28 +177,53 @@ static void i2c_dw_pci_remove(struct pci_dev *pdev)
 {
 	struct dw_i2c_dev *dev = pci_get_drvdata(pdev);
 
-	i2c_dw_disable(dev);
 	pm_runtime_forbid(&pdev->dev);
-	pm_runtime_get_noresume(&pdev->dev);
-
-	i2c_del_adapter(&dev->adapter);
+	i2c_dw_free(&pdev->dev, dev);
+	pci_set_drvdata(pdev, NULL);
+	pci_release_region(pdev, 0);
 }
 
 /* work with hotplug and coldplug */
 MODULE_ALIAS("i2c_designware-pci");
 
-static const struct pci_device_id i2_designware_pci_ids[] = {
+DEFINE_PCI_DEVICE_TABLE(i2c_designware_pci_ids) = {
 	/* Moorestown */
 	{ PCI_VDEVICE(INTEL, 0x0802), moorestown_0 },
-	{ PCI_VDEVICE(INTEL, 0x0803), moorestown_1 },
-	{ PCI_VDEVICE(INTEL, 0x0804), moorestown_2 },
+	{ PCI_VDEVICE(INTEL, 0x0803), moorestown_0 },
+	{ PCI_VDEVICE(INTEL, 0x0804), moorestown_0 },
 	/* Medfield */
-	{ PCI_VDEVICE(INTEL, 0x0817), medfield_3,},
-	{ PCI_VDEVICE(INTEL, 0x0818), medfield_4 },
-	{ PCI_VDEVICE(INTEL, 0x0819), medfield_5 },
+	{ PCI_VDEVICE(INTEL, 0x0817), medfield_0 },
+	{ PCI_VDEVICE(INTEL, 0x0818), medfield_0 },
+	{ PCI_VDEVICE(INTEL, 0x0819), medfield_0 },
 	{ PCI_VDEVICE(INTEL, 0x082C), medfield_0 },
-	{ PCI_VDEVICE(INTEL, 0x082D), medfield_1 },
-	{ PCI_VDEVICE(INTEL, 0x082E), medfield_2 },
+	{ PCI_VDEVICE(INTEL, 0x082D), medfield_0 },
+	{ PCI_VDEVICE(INTEL, 0x082E), medfield_0 },
+	/* Cloverview */
+	{ PCI_VDEVICE(INTEL, 0x08E2), cloverview_0 },
+	{ PCI_VDEVICE(INTEL, 0x08E3), cloverview_0 },
+	{ PCI_VDEVICE(INTEL, 0x08E4), cloverview_0 },
+	{ PCI_VDEVICE(INTEL, 0x08F4), cloverview_0 },
+	{ PCI_VDEVICE(INTEL, 0x08F5), cloverview_0 },
+	{ PCI_VDEVICE(INTEL, 0x08F6), cloverview_0 },
+	/* Merrifield */
+	{ PCI_VDEVICE(INTEL, 0x1195), merrifield_0 },
+	{ PCI_VDEVICE(INTEL, 0x1196), merrifield_0 },
+	/* Valleyview 2 */
+	{ PCI_VDEVICE(INTEL, 0x0F41), valleyview_0 },
+	{ PCI_VDEVICE(INTEL, 0x0F42), valleyview_0 },
+	{ PCI_VDEVICE(INTEL, 0x0F43), valleyview_0 },
+	{ PCI_VDEVICE(INTEL, 0x0F44), valleyview_0 },
+	{ PCI_VDEVICE(INTEL, 0x0F45), valleyview_0 },
+	{ PCI_VDEVICE(INTEL, 0x0F46), valleyview_0 },
+	{ PCI_VDEVICE(INTEL, 0x0F47), valleyview_0 },
+	/* Cherryview */
+	{ PCI_VDEVICE(INTEL, 0x22C1), cherryview_0 },
+	{ PCI_VDEVICE(INTEL, 0x22C2), cherryview_0 },
+	{ PCI_VDEVICE(INTEL, 0x22C3), cherryview_0 },
+	{ PCI_VDEVICE(INTEL, 0x22C4), cherryview_0 },
+	{ PCI_VDEVICE(INTEL, 0x22C5), cherryview_0 },
+	{ PCI_VDEVICE(INTEL, 0x22C6), cherryview_0 },
+	{ PCI_VDEVICE(INTEL, 0x22C7), cherryview_0 },
 	/* Baytrail */
 	{ PCI_VDEVICE(INTEL, 0x0F41), baytrail },
 	{ PCI_VDEVICE(INTEL, 0x0F42), baytrail },
@@ -373,11 +234,11 @@ static const struct pci_device_id i2_designware_pci_ids[] = {
 	{ PCI_VDEVICE(INTEL, 0x0F47), baytrail },
 	{ 0,}
 };
-MODULE_DEVICE_TABLE(pci, i2_designware_pci_ids);
+MODULE_DEVICE_TABLE(pci, i2c_designware_pci_ids);
 
 static struct pci_driver dw_i2c_driver = {
 	.name		= DRIVER_NAME,
-	.id_table	= i2_designware_pci_ids,
+	.id_table	= i2c_designware_pci_ids,
 	.probe		= i2c_dw_pci_probe,
 	.remove		= i2c_dw_pci_remove,
 	.driver         = {
@@ -385,7 +246,38 @@ static struct pci_driver dw_i2c_driver = {
 	},
 };
 
-module_pci_driver(dw_i2c_driver);
+static int __init dw_i2c_init_driver(void)
+{
+	return  pci_register_driver(&dw_i2c_driver);
+}
+module_init(dw_i2c_init_driver);
+
+static void __exit dw_i2c_exit_driver(void)
+{
+	pci_unregister_driver(&dw_i2c_driver);
+}
+module_exit(dw_i2c_exit_driver);
+
+#ifndef MODULE
+static int __init dw_i2c_reserve_static_bus(void)
+{
+	struct i2c_board_info dummy = {
+		I2C_BOARD_INFO("dummy", 0xff),
+	};
+
+	i2c_register_board_info(DW_I2C_STATIC_BUS_NUM, &dummy, 1);
+	return 0;
+}
+subsys_initcall(dw_i2c_reserve_static_bus);
+
+static void dw_i2c_pci_final_quirks(struct pci_dev *pdev)
+{
+	pdev->pm_cap = 0x80;
+}
+
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x0F44,
+				dw_i2c_pci_final_quirks);
+#endif
 
 MODULE_AUTHOR("Baruch Siach <baruch@tkos.co.il>");
 MODULE_DESCRIPTION("Synopsys DesignWare PCI I2C bus adapter");
diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 089d4fa..c536af0 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -36,21 +36,33 @@
 #include <linux/interrupt.h>
 #include <linux/of.h>
 #include <linux/platform_device.h>
-#include <linux/pm.h>
-#include <linux/pm_runtime.h>
 #include <linux/io.h>
 #include <linux/slab.h>
 #include <linux/acpi.h>
+#include <linux/pci.h>
+#include <linux/pm_runtime.h>
+#include <linux/semaphore.h>
+#include <linux/fs.h>
 #include <linux/platform_data/i2c-designware.h>
 #include "i2c-designware-core.h"
 
-static struct i2c_algorithm i2c_dw_algo = {
-	.master_xfer	= i2c_dw_xfer,
-	.functionality	= i2c_dw_func,
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id dw_i2c_acpi_ids[] = {
+	{ "80860F41", valleyview_0 },
+	{ "808622C1", cherryview_0 },
+	{ }
 };
-static u32 i2c_dw_get_clk_rate_khz(struct dw_i2c_dev *dev)
+MODULE_DEVICE_TABLE(acpi, dw_i2c_acpi_ids);
+#endif
+
+static int dw_i2c_plat_suspend(struct device *dev)
 {
-	return clk_get_rate(dev->clk)/1000;
+	struct platform_device *pdev =
+		container_of(dev, struct platform_device, dev);
+	struct dw_i2c_dev *i2c = platform_get_drvdata(pdev);
+
+	dev_dbg(dev, "suspend called\n");
+	return i2c_dw_suspend(i2c, false);
 }
 
 #ifdef CONFIG_ACPI
@@ -76,55 +88,74 @@ static void dw_i2c_acpi_params(struct platform_device *pdev, char method[],
 
 	kfree(buf.pointer);
 }
+#endif
 
-static int dw_i2c_acpi_configure(struct platform_device *pdev)
+static int dw_i2c_plat_runtime_suspend(struct device *dev)
 {
-	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
-	bool fs_mode = dev->master_cfg & DW_IC_CON_SPEED_FAST;
+	struct platform_device *pdev =
+		container_of(dev, struct platform_device, dev);
+	struct dw_i2c_dev *i2c = platform_get_drvdata(pdev);
 
-	if (!ACPI_HANDLE(&pdev->dev))
-		return -ENODEV;
+	dev_dbg(dev, "runtime suspend called\n");
+	i2c_dw_suspend(i2c, true);
 
-	dev->adapter.nr = -1;
-	dev->tx_fifo_depth = 32;
-	dev->rx_fifo_depth = 32;
+	return 0;
+}
 
-	/*
-	 * Try to get SDA hold time and *CNT values from an ACPI method if
-	 * it exists for both supported speed modes.
-	 */
-	dw_i2c_acpi_params(pdev, "SSCN", &dev->ss_hcnt, &dev->ss_lcnt,
-			   fs_mode ? NULL : &dev->sda_hold_time);
-	dw_i2c_acpi_params(pdev, "FMCN", &dev->fs_hcnt, &dev->fs_lcnt,
-			   fs_mode ? &dev->sda_hold_time : NULL);
+static int dw_i2c_plat_resume(struct device *dev)
+{
+	struct platform_device *pdev =
+		container_of(dev, struct platform_device, dev);
+	struct dw_i2c_dev *i2c = platform_get_drvdata(pdev);
 
-	return 0;
+	dev_dbg(dev, "resume called\n");
+	return i2c_dw_resume(i2c, false);
 }
 
-static const struct acpi_device_id dw_i2c_acpi_match[] = {
-	{ "INT33C2", 0 },
-	{ "INT33C3", 0 },
-	{ "INT3432", 0 },
-	{ "INT3433", 0 },
-	{ "80860F41", 0 },
-	{ }
-};
-MODULE_DEVICE_TABLE(acpi, dw_i2c_acpi_match);
-#else
-static inline int dw_i2c_acpi_configure(struct platform_device *pdev)
+static int dw_i2c_plat_runtime_resume(struct device *dev)
 {
-	return -ENODEV;
+	struct platform_device *pdev =
+		container_of(dev, struct platform_device, dev);
+	struct dw_i2c_dev *i2c = platform_get_drvdata(pdev);
+
+	dev_dbg(dev, "runtime resume called\n");
+	i2c_dw_resume(i2c, true);
+
+	return 0;
 }
-#endif
 
-static int dw_i2c_probe(struct platform_device *pdev)
+static const struct dev_pm_ops dw_i2c_plat_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(dw_i2c_plat_suspend,
+				dw_i2c_plat_resume)
+	SET_RUNTIME_PM_OPS(dw_i2c_plat_runtime_suspend,
+			   dw_i2c_plat_runtime_resume,
+			   NULL)
+};
+
+static int __init dw_i2c_probe(struct platform_device *pdev)
 {
 	struct dw_i2c_dev *dev;
-	struct i2c_adapter *adap;
-	struct resource *mem;
 	struct dw_i2c_platform_data *pdata;
-	int irq, r;
 	u32 clk_freq;
+	struct resource *mem, *ioarea;
+	const struct acpi_device_id *id;
+	unsigned long start, len;
+	int bus_idx = 0;
+	static int bus_num;
+	int irq;
+
+#ifdef CONFIG_ACPI
+	for (id = dw_i2c_acpi_ids; id->id[0]; id++)
+		if (!strncmp(id->id, dev_name(&pdev->dev), strlen(id->id))) {
+			bus_idx = id->driver_data + bus_num;
+			bus_num++;
+		}
+#else
+	bus_idx = pdev->id;
+#endif
+
+	start = mem->start;
+	len = resource_size(mem);
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0) {
@@ -132,28 +163,6 @@ static int dw_i2c_probe(struct platform_device *pdev)
 		return irq; /* -ENXIO */
 	}
 
-	dev = devm_kzalloc(&pdev->dev, sizeof(struct dw_i2c_dev), GFP_KERNEL);
-	if (!dev)
-		return -ENOMEM;
-
-	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	dev->base = devm_ioremap_resource(&pdev->dev, mem);
-	if (IS_ERR(dev->base))
-		return PTR_ERR(dev->base);
-
-	init_completion(&dev->cmd_complete);
-	mutex_init(&dev->lock);
-	dev->dev = &pdev->dev;
-	dev->irq = irq;
-	platform_set_drvdata(pdev, dev);
-
-	dev->clk = devm_clk_get(&pdev->dev, NULL);
-	dev->get_clk_rate_khz = i2c_dw_get_clk_rate_khz;
-
-	if (IS_ERR(dev->clk))
-		return PTR_ERR(dev->clk);
-	clk_prepare_enable(dev->clk);
-
 	/* fast mode by default because of legacy reasons */
 	clk_freq = 400000;
 
@@ -189,117 +198,45 @@ static int dw_i2c_probe(struct platform_device *pdev)
 			clk_freq = pdata->i2c_scl_freq;
 	}
 
-	dev->functionality =
-		I2C_FUNC_I2C |
-		I2C_FUNC_10BIT_ADDR |
-		I2C_FUNC_SMBUS_BYTE |
-		I2C_FUNC_SMBUS_BYTE_DATA |
-		I2C_FUNC_SMBUS_WORD_DATA |
-		I2C_FUNC_SMBUS_I2C_BLOCK;
-	if (clk_freq == 100000)
-		dev->master_cfg =  DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |
-			DW_IC_CON_RESTART_EN | DW_IC_CON_SPEED_STD;
-	else
-		dev->master_cfg =  DW_IC_CON_MASTER | DW_IC_CON_SLAVE_DISABLE |
-			DW_IC_CON_RESTART_EN | DW_IC_CON_SPEED_FAST;
-
-	/* Try first if we can configure the device from ACPI */
-	r = dw_i2c_acpi_configure(pdev);
-	if (r) {
-		u32 param1 = i2c_dw_read_comp_param(dev);
-
-		dev->tx_fifo_depth = ((param1 >> 16) & 0xff) + 1;
-		dev->rx_fifo_depth = ((param1 >> 8)  & 0xff) + 1;
-		dev->adapter.nr = pdev->id;
-	}
-	r = i2c_dw_init(dev);
-	if (r)
-		return r;
-
-	i2c_dw_disable_int(dev);
-	r = devm_request_irq(&pdev->dev, dev->irq, i2c_dw_isr, IRQF_SHARED,
-			pdev->name, dev);
-	if (r) {
-		dev_err(&pdev->dev, "failure requesting irq %i\n", dev->irq);
-		return r;
+	ioarea = request_mem_region(mem->start, resource_size(mem),
+			pdev->name);
+	if (!ioarea) {
+		dev_err(&pdev->dev, "I2C region already claimed\n");
+		return -EBUSY;
 	}
 
-	adap = &dev->adapter;
-	i2c_set_adapdata(adap, dev);
-	adap->owner = THIS_MODULE;
-	adap->class = I2C_CLASS_HWMON;
-	strlcpy(adap->name, "Synopsys DesignWare I2C adapter",
-			sizeof(adap->name));
-	adap->algo = &i2c_dw_algo;
-	adap->dev.parent = &pdev->dev;
-	adap->dev.of_node = pdev->dev.of_node;
-
-	r = i2c_add_numbered_adapter(adap);
-	if (r) {
-		dev_err(&pdev->dev, "failure adding adapter\n");
-		return r;
+	dev = i2c_dw_setup(&pdev->dev, bus_idx, start, len, irq);
+	if (IS_ERR(dev)) {
+		release_mem_region(mem->start, resource_size(mem));
+		dev_err(&pdev->dev, "failed to setup i2c\n");
+		return -EINVAL;
 	}
 
-	pm_runtime_set_autosuspend_delay(&pdev->dev, 1000);
-	pm_runtime_use_autosuspend(&pdev->dev);
+	platform_set_drvdata(pdev, dev);
+
 	pm_runtime_set_active(&pdev->dev);
 	pm_runtime_enable(&pdev->dev);
+	pm_runtime_allow(&pdev->dev);
+	pm_runtime_use_autosuspend(&pdev->dev);
+	pm_runtime_set_autosuspend_delay(&pdev->dev, 50);
 
 	return 0;
 }
 
-static int dw_i2c_remove(struct platform_device *pdev)
+static int __exit dw_i2c_remove(struct platform_device *pdev)
 {
 	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
+	struct resource *mem;
 
-	pm_runtime_get_sync(&pdev->dev);
-
-	i2c_del_adapter(&dev->adapter);
-
-	i2c_dw_disable(dev);
-
-	pm_runtime_put(&pdev->dev);
-	pm_runtime_disable(&pdev->dev);
-
-	return 0;
-}
-
-#ifdef CONFIG_OF
-static const struct of_device_id dw_i2c_of_match[] = {
-	{ .compatible = "snps,designware-i2c", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, dw_i2c_of_match);
-#endif
-
-#ifdef CONFIG_PM_SLEEP
-static int dw_i2c_suspend(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct dw_i2c_dev *i_dev = platform_get_drvdata(pdev);
-
-	clk_disable_unprepare(i_dev->clk);
-
-	return 0;
-}
-
-static int dw_i2c_resume(struct device *dev)
-{
-	struct platform_device *pdev = to_platform_device(dev);
-	struct dw_i2c_dev *i_dev = platform_get_drvdata(pdev);
-
-	clk_prepare_enable(i_dev->clk);
-	i2c_dw_init(i_dev);
-
+	pm_runtime_forbid(&pdev->dev);
+	i2c_dw_free(&pdev->dev, dev);
+	platform_set_drvdata(pdev, NULL);
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (mem)
+		release_mem_region(mem->start, resource_size(mem));
 	return 0;
 }
 
-static SIMPLE_DEV_PM_OPS(dw_i2c_dev_pm_ops, dw_i2c_suspend, dw_i2c_resume);
-#define DW_I2C_DEV_PM_OPS	(&dw_i2c_dev_pm_ops)
-#else
-#define DW_I2C_DEV_PM_OPS	NULL
-#endif
-
 /* work with hotplug and coldplug */
 MODULE_ALIAS("platform:i2c_designware");
 
@@ -311,15 +248,33 @@ static struct platform_driver dw_i2c_driver = {
 		.owner	= THIS_MODULE,
 		.of_match_table = of_match_ptr(dw_i2c_of_match),
 		.acpi_match_table = ACPI_PTR(dw_i2c_acpi_match),
-		.pm	= DW_I2C_DEV_PM_OPS,
+		.pm     = &dw_i2c_plat_pm_ops,
+#ifdef CONFIG_ACPI
+		.acpi_match_table = ACPI_PTR(dw_i2c_acpi_ids),
+#endif
 	},
 };
 
 static int __init dw_i2c_init_driver(void)
 {
+	struct pci_dev *dw_pci;
+
+	/*
+	 * Try to get pci device, if exist, then exit ACPI platform
+	 * register, On BYT FDK, include two enum mode: PCI, ACPI,
+	 * ignore ACPI enum mode.
+	 */
+	dw_pci = pci_get_device(PCI_VENDOR_ID_INTEL, 0x0F41, NULL);
+	if (dw_pci) {
+		pr_info("DW I2C: Find I2C controller in PCI device, "
+			"exit ACPI platform register!\n");
+		return 0;
+	}
+
 	return platform_driver_register(&dw_i2c_driver);
 }
 subsys_initcall(dw_i2c_init_driver);
+module_init(dw_i2c_init_driver);
 
 static void __exit dw_i2c_exit_driver(void)
 {
diff --git a/drivers/i2c/busses/i2c-pmic-regs.h b/drivers/i2c/busses/i2c-pmic-regs.h
new file mode 100644
index 0000000..e5a55ff
--- /dev/null
+++ b/drivers/i2c/busses/i2c-pmic-regs.h
@@ -0,0 +1,78 @@
+/*
+ * i2c-pmic-regs.h - PMIC I2C registers
+ *
+ * Copyright (C) 2011 Intel Corporation
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ * Author: Yegnesh Iyer <yegnesh.s.iyer@intel.com>
+ */
+
+#ifndef __I2C_PMIC_REGS_H__
+#define __I2C_PMIC_REGS_H__
+
+#include <linux/mutex.h>
+
+/*********************************************************************
+ *		Generic defines
+ *********************************************************************/
+
+#define D7 (1 << 7)
+#define D6 (1 << 6)
+#define D5 (1 << 5)
+#define D4 (1 << 4)
+#define D3 (1 << 3)
+#define D2 (1 << 2)
+#define D1 (1 << 1)
+#define D0 (1 << 0)
+
+#define PMIC_SRAM_INTR_ADDR 0xFFFFF616
+
+#define I2C_MSG_LEN		4
+
+#define I2COVRCTRL_ADDR		0x58
+#define I2COVRDADDR_ADDR	0x59
+#define I2COVROFFSET_ADDR	0x5A
+#define I2COVRWRDATA_ADDR	0x5B
+#define I2COVRRDDATA_ADDR	0x5C
+
+#define IRQLVL1_ADDR			0x01
+#define IRQLVL1_MASK_ADDR		0x0c
+#define IRQLVL1_CHRGR_MASK		D5
+
+#define MCHGRIRQ1_ADDR			0x13
+#define MCHGRIRQ0_ADDR			0x12
+
+#define PMIC_I2C_INTR_MASK ((u8)(D3|D2|D1))
+#define I2COVRCTRL_I2C_RD D1
+#define I2COVRCTRL_I2C_WR D0
+#define CHGRIRQ0_ADDR			0x07
+
+#define IRQ0_I2C_BIT_POS 1
+
+struct pmic_i2c_dev {
+	int irq;
+	u32 pmic_intr_sram_addr;
+	struct i2c_adapter adapter;
+	int i2c_rw;
+	wait_queue_head_t i2c_wait;
+	struct mutex i2c_pmic_rw_lock;
+	void __iomem *pmic_intr_map;
+	struct device *dev;
+};
+
+#endif
diff --git a/drivers/i2c/busses/i2c-pmic.c b/drivers/i2c/busses/i2c-pmic.c
new file mode 100644
index 0000000..9e96f10
--- /dev/null
+++ b/drivers/i2c/busses/i2c-pmic.c
@@ -0,0 +1,452 @@
+/*
+ * i2c-pmic.c: PMIC I2C adapter driver.
+ *
+ * Copyright (C) 2011 Intel Corporation
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ * Author: Yegnesh Iyer <yegnesh.s.iyer@intel.com>
+ */
+
+#include <linux/slab.h>
+#include <linux/rpmsg.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/power_supply.h>
+#include <linux/interrupt.h>
+#include <linux/completion.h>
+#include <linux/pm_runtime.h>
+#include <asm/intel_scu_pmic.h>
+#include <asm/intel_mid_rpmsg.h>
+#include <asm/intel_mid_remoteproc.h>
+#include "i2c-pmic-regs.h"
+
+#define DRIVER_NAME "i2c_pmic_adap"
+#define PMIC_I2C_ADAPTER 8
+
+enum I2C_STATUS {
+	I2C_WR = 1,
+	I2C_RD,
+	I2C_NACK = 4
+};
+
+static struct pmic_i2c_dev *pmic_dev;
+
+/* Function Definitions */
+
+/* PMIC I2C read-write completion interrupt handler */
+static irqreturn_t pmic_i2c_handler(int irq, void *data)
+{
+	u8 irq0_int;
+
+	irq0_int = ioread8(pmic_dev->pmic_intr_map);
+	irq0_int &= PMIC_I2C_INTR_MASK;
+
+	if (irq0_int) {
+		pmic_dev->i2c_rw = (irq0_int >> IRQ0_I2C_BIT_POS);
+		return IRQ_WAKE_THREAD;
+	}
+
+	return IRQ_NONE;
+}
+
+
+static irqreturn_t pmic_thread_handler(int id, void *data)
+{
+#define IRQLVL1_MASK_ADDR		0x0c
+#define IRQLVL1_CHRGR_MASK		D5
+
+	dev_dbg(pmic_dev->dev, "Clearing IRQLVL1_MASK_ADDR\n");
+
+	intel_scu_ipc_update_register(IRQLVL1_MASK_ADDR, 0x00,
+			IRQLVL1_CHRGR_MASK);
+	wake_up(&(pmic_dev->i2c_wait));
+	return IRQ_HANDLED;
+}
+
+/* PMIC i2c read msg */
+static inline int pmic_i2c_read_xfer(struct i2c_msg msg)
+{
+	int ret;
+	u16 i;
+	u8 mask = (I2C_RD | I2C_NACK);
+	u16 regs[I2C_MSG_LEN] = {0};
+	u8 data[I2C_MSG_LEN] = {0};
+
+	for (i = 0; i < msg.len ; i++) {
+		pmic_dev->i2c_rw = 0;
+		regs[0] = I2COVRDADDR_ADDR;
+		data[0] = msg.addr;
+		regs[1] = I2COVROFFSET_ADDR;
+		data[1] = msg.buf[0] + i;
+		/* intel_scu_ipc_function works fine for even number of bytes */
+		/* Hence adding a dummy byte transfer */
+		regs[2] = I2COVROFFSET_ADDR;
+		data[2] = msg.buf[0] + i;
+		regs[3] = I2COVRCTRL_ADDR;
+		data[3] = I2COVRCTRL_I2C_RD;
+		ret = intel_scu_ipc_writev(regs, data, I2C_MSG_LEN);
+		if (unlikely(ret))
+			return ret;
+
+		ret = wait_event_timeout(pmic_dev->i2c_wait,
+				(pmic_dev->i2c_rw & mask),
+				HZ);
+
+		if (ret == 0) {
+			ret = -ETIMEDOUT;
+			goto read_err_exit;
+		} else if (pmic_dev->i2c_rw == I2C_NACK) {
+			ret = -EIO;
+			goto read_err_exit;
+		} else {
+			ret = intel_scu_ipc_ioread8(I2COVRRDDATA_ADDR,
+					&(msg.buf[i]));
+			if (unlikely(ret)) {
+				ret = -EIO;
+				goto read_err_exit;
+			}
+		}
+	}
+	return 0;
+
+read_err_exit:
+	return ret;
+}
+
+/* PMIC i2c write msg */
+static inline int pmic_i2c_write_xfer(struct i2c_msg msg)
+{
+	int ret;
+	u16 i;
+	u8 mask = (I2C_WR | I2C_NACK);
+	u16 regs[I2C_MSG_LEN] = {0};
+	u8 data[I2C_MSG_LEN] = {0};
+
+	for (i = 1; i <= msg.len ; i++) {
+		pmic_dev->i2c_rw = 0;
+		regs[0] = I2COVRDADDR_ADDR;
+		data[0] = msg.addr;
+		regs[1] = I2COVRWRDATA_ADDR;
+		data[1] = msg.buf[i];
+		regs[2] = I2COVROFFSET_ADDR;
+		data[2] = msg.buf[0] + i - 1;
+		regs[3] = I2COVRCTRL_ADDR;
+		data[3] = I2COVRCTRL_I2C_WR;
+		ret = intel_scu_ipc_writev(regs, data, I2C_MSG_LEN);
+		if (unlikely(ret))
+			return ret;
+
+		ret = wait_event_timeout(pmic_dev->i2c_wait,
+				(pmic_dev->i2c_rw & mask),
+				HZ);
+		if (ret == 0)
+			return -ETIMEDOUT;
+		else if (pmic_dev->i2c_rw == I2C_NACK)
+			return -EIO;
+	}
+	return 0;
+}
+
+static int (*xfer_fn[]) (struct i2c_msg) = {
+	pmic_i2c_write_xfer,
+	pmic_i2c_read_xfer
+};
+
+/* PMIC I2C Master transfer algorithm function */
+static int pmic_master_xfer(struct i2c_adapter *adap,
+				struct i2c_msg msgs[],
+				int num)
+{
+	int ret = 0;
+	int i;
+	u8 index;
+
+	mutex_lock(&pmic_dev->i2c_pmic_rw_lock);
+	pm_runtime_get_sync(pmic_dev->dev);
+	for (i = 0 ; i < num ; i++) {
+		index = msgs[i].flags & I2C_M_RD;
+		ret = (xfer_fn[index])(msgs[i]);
+
+		if (ret == -EACCES)
+			dev_info(pmic_dev->dev, "Blocked Access!\n");
+
+		/* If access is restricted, return true to
+		*  avoid extra error handling in client
+		*/
+
+		if (ret != 0 && ret != -EACCES)
+			goto transfer_err_exit;
+	}
+
+	ret = num;
+
+transfer_err_exit:
+	mutex_unlock(&pmic_dev->i2c_pmic_rw_lock);
+	pm_runtime_put_sync(pmic_dev->dev);
+	intel_scu_ipc_update_register(IRQLVL1_MASK_ADDR, 0x00,
+			IRQLVL1_CHRGR_MASK);
+	return ret;
+}
+
+/* PMIC I2C adapter capability function */
+static u32 pmic_master_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_BYTE_DATA;
+}
+
+static int pmic_smbus_xfer(struct i2c_adapter *adap, u16 addr,
+				unsigned short flags, char read_write,
+				u8 command, int size,
+				union i2c_smbus_data *data)
+{
+	struct i2c_msg msg;
+	u8 buf[2];
+	int ret;
+
+	msg.addr = addr;
+	msg.flags = flags & I2C_M_TEN;
+	msg.buf = buf;
+	msg.buf[0] = command;
+	if (read_write == I2C_SMBUS_WRITE) {
+		msg.len = 1;
+		msg.buf[1] = data->byte;
+	} else {
+		msg.flags |= I2C_M_RD;
+		msg.len = 1;
+	}
+
+	ret = pmic_master_xfer(adap, &msg, 1);
+	if (ret == 1) {
+		if (read_write == I2C_SMBUS_READ)
+			data->byte = msg.buf[0];
+		return 0;
+	}
+	return ret;
+}
+
+
+static const struct i2c_algorithm pmic_i2c_algo = {
+	.master_xfer = pmic_master_xfer,
+	.functionality = pmic_master_func,
+	.smbus_xfer = pmic_smbus_xfer,
+};
+
+static int pmic_i2c_probe(struct platform_device *pdev)
+{
+	struct i2c_adapter *adap;
+	int ret;
+
+	pmic_dev = kzalloc(sizeof(struct pmic_i2c_dev), GFP_KERNEL);
+	if (!pmic_dev)
+		return -ENOMEM;
+
+	pmic_dev->dev = &pdev->dev;
+	pmic_dev->irq = platform_get_irq(pdev, 0);
+
+
+
+	mutex_init(&pmic_dev->i2c_pmic_rw_lock);
+	init_waitqueue_head(&(pmic_dev->i2c_wait));
+
+	pmic_dev->pmic_intr_map = ioremap_nocache(PMIC_SRAM_INTR_ADDR, 8);
+	if (!pmic_dev->pmic_intr_map) {
+		dev_err(&pdev->dev, "ioremap Failed\n");
+		ret = -ENOMEM;
+		goto ioremap_failed;
+	}
+	ret = request_threaded_irq(pmic_dev->irq, pmic_i2c_handler,
+					pmic_thread_handler,
+					IRQF_SHARED|IRQF_NO_SUSPEND,
+					DRIVER_NAME, pmic_dev);
+	if (ret)
+		goto err_irq_request;
+
+	ret = intel_scu_ipc_update_register(IRQLVL1_MASK_ADDR, 0x00,
+			IRQLVL1_CHRGR_MASK);
+	if (unlikely(ret))
+		goto unmask_irq_failed;
+	ret = intel_scu_ipc_update_register(MCHGRIRQ0_ADDR, 0x00,
+			PMIC_I2C_INTR_MASK);
+	if (unlikely(ret))
+		goto unmask_irq_failed;
+
+	/* Init runtime PM state*/
+	pm_runtime_put_noidle(pmic_dev->dev);
+
+	adap = &pmic_dev->adapter;
+	adap->owner = THIS_MODULE;
+	adap->class = I2C_CLASS_HWMON;
+	adap->algo = &pmic_i2c_algo;
+	strcpy(adap->name, "PMIC I2C Adapter");
+	adap->nr = PMIC_I2C_ADAPTER;
+	ret = i2c_add_numbered_adapter(adap);
+
+	if (ret) {
+		dev_err(&pdev->dev, "Error adding the adapter\n");
+		goto err_adap_add;
+	}
+
+	pm_schedule_suspend(pmic_dev->dev, MSEC_PER_SEC);
+	return 0;
+
+err_adap_add:
+	free_irq(pmic_dev->irq, pmic_dev);
+unmask_irq_failed:
+err_irq_request:
+	iounmap(pmic_dev->pmic_intr_map);
+ioremap_failed:
+	kfree(pmic_dev);
+	return ret;
+}
+
+static int pmic_i2c_remove(struct platform_device *pdev)
+{
+	iounmap(pmic_dev->pmic_intr_map);
+	free_irq(pmic_dev->irq, pmic_dev);
+	pm_runtime_get_noresume(pmic_dev->dev);
+	kfree(pmic_dev);
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int pmic_i2c_suspend(struct device *dev)
+{
+	dev_info(dev, "%s\n", __func__);
+	return 0;
+}
+
+static int pmic_i2c_resume(struct device *dev)
+{
+	dev_info(dev, "%s\n", __func__);
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PM_RUNTIME
+static int pmic_i2c_runtime_suspend(struct device *dev)
+{
+	dev_info(dev, "%s\n", __func__);
+	return 0;
+}
+
+static int pmic_i2c_runtime_resume(struct device *dev)
+{
+	dev_info(dev, "%s\n", __func__);
+	return 0;
+}
+
+static int pmic_i2c_runtime_idle(struct device *dev)
+{
+	dev_info(dev, "%s\n", __func__);
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops pmic_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(pmic_i2c_suspend,
+				pmic_i2c_resume)
+	SET_RUNTIME_PM_OPS(pmic_i2c_runtime_suspend,
+				pmic_i2c_runtime_resume,
+				pmic_i2c_runtime_idle)
+};
+
+struct platform_driver pmic_i2c_driver = {
+	.probe = pmic_i2c_probe,
+	.remove = pmic_i2c_remove,
+	.driver = {
+		.name = DRIVER_NAME,
+		.owner = THIS_MODULE,
+		.pm = &pmic_i2c_pm_ops,
+	},
+};
+
+static int pmic_i2c_init(void)
+{
+	return platform_driver_register(&pmic_i2c_driver);
+}
+
+static void pmic_i2c_exit(void)
+{
+	platform_driver_unregister(&pmic_i2c_driver);
+}
+
+static int pmic_i2c_rpmsg_probe(struct rpmsg_channel *rpdev)
+{
+	int ret = 0;
+
+	if (rpdev == NULL) {
+		pr_err("rpmsg channel not created\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	dev_info(&rpdev->dev, "Probed pmic_i2c rpmsg device\n");
+
+	ret = pmic_i2c_init();
+
+out:
+	return ret;
+}
+
+static void pmic_i2c_rpmsg_remove(struct rpmsg_channel *rpdev)
+{
+	pmic_i2c_exit();
+	dev_info(&rpdev->dev, "Removed pmic_i2c rpmsg device\n");
+}
+
+static void pmic_i2c_rpmsg_cb(struct rpmsg_channel *rpdev, void *data,
+					int len, void *priv, u32 src)
+{
+	dev_warn(&rpdev->dev, "unexpected, message\n");
+
+	print_hex_dump(KERN_DEBUG, __func__, DUMP_PREFIX_NONE, 16, 1,
+		       data, len,  true);
+}
+
+static struct rpmsg_device_id pmic_i2c_rpmsg_id_table[] = {
+	{ .name	= "rpmsg_i2c_pmic_adap" },
+	{ },
+};
+MODULE_DEVICE_TABLE(rpmsg, pmic_i2c_rpmsg_id_table);
+
+static struct rpmsg_driver pmic_i2c_rpmsg = {
+	.drv.name	= KBUILD_MODNAME,
+	.drv.owner	= THIS_MODULE,
+	.id_table	= pmic_i2c_rpmsg_id_table,
+	.probe		= pmic_i2c_rpmsg_probe,
+	.callback	= pmic_i2c_rpmsg_cb,
+	.remove		= pmic_i2c_rpmsg_remove,
+};
+
+static int __init pmic_i2c_rpmsg_init(void)
+{
+	return register_rpmsg_driver(&pmic_i2c_rpmsg);
+}
+
+static void __exit pmic_i2c_rpmsg_exit(void)
+{
+	return unregister_rpmsg_driver(&pmic_i2c_rpmsg);
+}
+module_init(pmic_i2c_rpmsg_init);
+module_exit(pmic_i2c_rpmsg_exit);
+
+MODULE_AUTHOR("Yegnesh Iyer <yegnesh.s.iyer@intel.com");
+MODULE_DESCRIPTION("PMIC I2C Master driver");
+MODULE_LICENSE("GPL");
-- 
1.7.5.4

