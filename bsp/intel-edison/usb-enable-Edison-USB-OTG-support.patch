From 8241ac1f4d8ae2624869af7b833cb03aa2702e97 Mon Sep 17 00:00:00 2001
From: Liwei Song <liwei.song@windriver.com>
Date: Tue, 1 Mar 2016 20:17:50 -0500
Subject: [PATCH 09/11] usb: enable Edison USB OTG support

This patch is from yocto Intel Edison support:
http://downloadmirror.intel.com/25028/eng/edison-src-ww25.5-15.tgz

Enable Intel USB OTG feature. driver name: g_multi

Signed-off-by: Liwei Song <liwei.song@windriver.com>
---
 arch/x86/platform/intel-mid/device_libs/Makefile   |    6 +
 .../intel-mid/device_libs/pci/platform_usb_otg.c   |   93 +
 .../intel-mid/device_libs/platform_btlpm.c         |   80 +
 .../platform/intel-mid/device_libs/platform_wifi.c |  128 +
 drivers/mmc/host/sdhci-pci.h                       |    1 -
 drivers/net/wireless/Kconfig                       |   10 +
 drivers/usb/Kconfig                                |    1 +
 drivers/usb/core/hcd.c                             |   23 +-
 drivers/usb/dwc3/Kconfig                           |   66 +
 drivers/usb/dwc3/Makefile                          |   15 +-
 drivers/usb/dwc3/core.c                            |   29 +-
 drivers/usb/dwc3/core.h                            |    7 +-
 drivers/usb/dwc3/debugfs.c                         |   70 +-
 drivers/usb/dwc3/drd.c                             |  163 -
 drivers/usb/dwc3/drd.h                             |   30 -
 drivers/usb/dwc3/dwc3-device-intel.c               |  648 +++
 drivers/usb/dwc3/dwc3-host-intel.c                 |  724 +++
 drivers/usb/dwc3/dwc3-intel-mrfl.c                 |  992 ++++
 drivers/usb/dwc3/dwc3-pci.c                        |    4 +
 drivers/usb/dwc3/ep0.c                             |   37 +-
 drivers/usb/dwc3/gadget.c                          | 1041 ++++-
 drivers/usb/dwc3/gadget.h                          |   11 +-
 drivers/usb/dwc3/host.c                            |    2 -
 drivers/usb/dwc3/otg.c                             | 1509 +++++
 drivers/usb/dwc3/otg.h                             |  432 ++
 drivers/usb/gadget/epautoconf.c                    |   42 +
 drivers/usb/gadget/f_dvc_dfx.c                     |  922 ++++
 drivers/usb/gadget/f_dvc_trace.c                   |  887 +++
 drivers/usb/gadget/f_mass_storage.c                |    2 +-
 drivers/usb/gadget/gadget_chips.h                  |    5 +-
 drivers/usb/gadget/multi.c                         |   37 +-
 drivers/usb/gadget/u_ether.c                       |    2 -
 drivers/usb/gadget/u_serial.c                      |    2 +-
 drivers/usb/host/ehci-pci.c                        |    2 +-
 drivers/usb/host/xhci-plat.c                       |   11 +
 drivers/usb/host/xhci.c                            |    3 +
 drivers/usb/phy/penwell_otg.c                      | 5780 ++++++++++++++++++++
 include/linux/pci_ids.h                            |    2 +
 include/linux/power_supply.h                       |   92 +-
 include/linux/usb/debug.h                          |  253 +
 include/linux/usb/dwc3-intel-mid.h                 |  190 +
 include/linux/usb/dwc3-intel-mrfl.h                |  168 +
 include/linux/usb/hcd.h                            |    3 +
 include/linux/usb/penwell_otg.h                    |  515 ++
 include/linux/wlan_plat.h                          |   29 +
 include/uapi/linux/usb/ch9.h                       |    1 +
 46 files changed, 14736 insertions(+), 334 deletions(-)
 create mode 100644 arch/x86/platform/intel-mid/device_libs/pci/platform_usb_otg.c
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_btlpm.c
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_wifi.c
 delete mode 100644 drivers/usb/dwc3/drd.c
 delete mode 100644 drivers/usb/dwc3/drd.h
 create mode 100644 drivers/usb/dwc3/dwc3-device-intel.c
 create mode 100644 drivers/usb/dwc3/dwc3-host-intel.c
 create mode 100644 drivers/usb/dwc3/dwc3-intel-mrfl.c
 create mode 100644 drivers/usb/dwc3/otg.c
 create mode 100644 drivers/usb/dwc3/otg.h
 create mode 100644 drivers/usb/gadget/f_dvc_dfx.c
 create mode 100644 drivers/usb/gadget/f_dvc_trace.c
 create mode 100644 drivers/usb/phy/penwell_otg.c
 create mode 100644 include/linux/usb/debug.h
 create mode 100644 include/linux/usb/dwc3-intel-mid.h
 create mode 100644 include/linux/usb/dwc3-intel-mrfl.h
 create mode 100644 include/linux/usb/penwell_otg.h
 create mode 100644 include/linux/wlan_plat.h

diff --git a/arch/x86/platform/intel-mid/device_libs/Makefile b/arch/x86/platform/intel-mid/device_libs/Makefile
index 02b97fa..e6e4213 100644
--- a/arch/x86/platform/intel-mid/device_libs/Makefile
+++ b/arch/x86/platform/intel-mid/device_libs/Makefile
@@ -33,3 +33,9 @@ obj-$(subst m,y,$(CONFIG_KEYBOARD_GPIO)) += platform_gpio_keys.o
 # UART Devices
 obj-$(subst m,y,$(CONFIG_SERIAL_MFD_HSU)) += platform_hsu.o
 obj-$(subst m,y,$(CONFIG_TI_ADS7955_ADC)) += platform_ads7955.o
+# SD Devices
+ifndef CONFIG_ACPI
+obj-$(subst m,y,$(CONFIG_BCM_BT_LPM)) += platform_btlpm.o
+endif
+# WIFI devices
+obj-$(subst m,y,$(CONFIG_WIFI_PLATFORM_DATA)) += platform_wifi.o
diff --git a/arch/x86/platform/intel-mid/device_libs/pci/platform_usb_otg.c b/arch/x86/platform/intel-mid/device_libs/pci/platform_usb_otg.c
new file mode 100644
index 0000000..4deead8
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/pci/platform_usb_otg.c
@@ -0,0 +1,93 @@
+/*
+ * platform_otg_pci.c: USB OTG platform data initilization file
+ *
+ * (C) Copyright 2013 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/pci.h>
+#include <asm/intel-mid.h>
+#include <asm/intel_scu_ipc.h>
+#include <linux/dma-mapping.h>
+
+#ifdef CONFIG_USB_DWC3_OTG
+#include <linux/usb/dwc3-intel-mid.h>
+static struct intel_dwc_otg_pdata dwc_otg_pdata;
+
+static bool dwc_otg_get_usbspecoverride(void)
+{
+	void __iomem *usb_comp_iomap;
+	bool usb_spec_override;
+
+	/* Read MISCFLAGS byte from offset 0x717 */
+	usb_comp_iomap = ioremap_nocache(0xFFFCE717, 4);
+	/* MISCFLAGS.BIT[6] indicates USB spec override */
+	usb_spec_override = ioread8(usb_comp_iomap) & 0x40;
+	iounmap(usb_comp_iomap);
+
+	return usb_spec_override;
+}
+
+static struct intel_dwc_otg_pdata *get_otg_platform_data(struct pci_dev *pdev)
+{
+	switch (pdev->device) {
+	case PCI_DEVICE_ID_INTEL_MRFL_DWC3_OTG:
+		dwc_otg_pdata.pmic_type = BASIN_COVE;
+		dwc_otg_pdata.charger_detect_enable = 1;
+
+		dwc_otg_pdata.charging_compliance =
+			dwc_otg_get_usbspecoverride();
+
+		return &dwc_otg_pdata;
+	default:
+		break;
+	}
+
+	return NULL;
+}
+#endif
+
+#ifdef CONFIG_USB_PENWELL_OTG
+#include <linux/usb/penwell_otg.h>
+static struct intel_mid_otg_pdata otg_pdata = {
+	.gpio_vbus = 0,
+	.gpio_cs = 0,
+	.gpio_reset = 0,
+	.charging_compliance = 0,
+	.hnp_poll_support = 0,
+	.power_budget = 500
+};
+
+static struct intel_mid_otg_pdata *get_otg_platform_data(struct pci_dev *pdev)
+{
+	struct intel_mid_otg_pdata *pdata = &otg_pdata;
+
+	switch (pdev->device) {
+	case PCI_DEVICE_ID_INTEL_MRFL_DWC3_OTG:
+		dwc_otg_pdata.pmic_type = BASIN_COVE;
+		dwc_otg_pdata.charger_detect_enable = 1;
+
+		dwc_otg_pdata.charging_compliance =
+			dwc_otg_get_usbspecoverride();
+		return &dwc_otg_pdata;
+
+	default:
+		break;
+	}
+
+	return pdata;
+}
+#endif
+
+static void otg_pci_early_quirks(struct pci_dev *pci_dev)
+{
+	pci_dev->dev.platform_data = get_otg_platform_data(pci_dev);
+}
+
+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_MRFL_DWC3_OTG,
+			otg_pci_early_quirks);
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_btlpm.c b/arch/x86/platform/intel-mid/device_libs/platform_btlpm.c
new file mode 100644
index 0000000..084452d
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_btlpm.c
@@ -0,0 +1,80 @@
+/*
+ * platform_btlpm: btlpm platform data initialization file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#include <linux/init.h>
+#include <linux/pm_runtime.h>
+#include <asm/bcm_bt_lpm.h>
+#include <asm/intel-mid.h>
+#include <linux/gpio.h>
+
+#define UART_PORT_NO 0 /* Bluetooth is using UART port number 0 */
+
+#define LPM_ON
+
+static struct bcm_bt_lpm_platform_data bcm_bt_lpm_pdata = {
+	.gpio_wake = -EINVAL,
+	.gpio_host_wake = -EINVAL,
+	.int_host_wake = -EINVAL,
+	.gpio_enable = -EINVAL,
+	.port = UART_PORT_NO,
+};
+
+struct platform_device bcm_bt_lpm_device = {
+	.name = "bcm_bt_lpm",
+	.id = 0,
+	.dev = {
+		.platform_data = &bcm_bt_lpm_pdata,
+	},
+};
+
+static int __init bluetooth_init(void)
+{
+
+	int error_reg;
+
+	/* Get the GPIO numbers from the SFI table */
+
+	bcm_bt_lpm_pdata.gpio_enable = get_gpio_by_name("BT-reset");
+	if (!gpio_is_valid(bcm_bt_lpm_pdata.gpio_enable)) {
+		pr_err("%s: gpio %s not found\n", __func__, "BT-reset");
+		return -ENODEV;
+	}
+
+#ifdef LPM_ON
+	bcm_bt_lpm_pdata.gpio_host_wake = get_gpio_by_name("bt_uart_enable");
+	if (!gpio_is_valid(bcm_bt_lpm_pdata.gpio_host_wake)) {
+		pr_err("%s: gpio %s not found\n", __func__, "bt_uart_enable");
+		return -ENODEV;
+	}
+
+	bcm_bt_lpm_pdata.int_host_wake =
+				gpio_to_irq(bcm_bt_lpm_pdata.gpio_host_wake);
+
+	bcm_bt_lpm_pdata.gpio_wake = get_gpio_by_name("bt_wakeup");
+	if (!gpio_is_valid(bcm_bt_lpm_pdata.gpio_wake)) {
+		pr_err("%s: gpio %s not found\n", __func__, "bt_wakeup");
+		return -ENODEV;
+	}
+
+	pr_debug("%s: gpio_wake %d, gpio_host_wake %d\n", __func__,
+		bcm_bt_lpm_pdata.gpio_wake, bcm_bt_lpm_pdata.gpio_host_wake);
+#endif
+
+	error_reg = platform_device_register(&bcm_bt_lpm_device);
+	if (error_reg < 0) {
+		pr_err("%s: platform_device_register for %s failed\n",
+					__func__, bcm_bt_lpm_device.name);
+		return -ENODEV;
+	}
+	return 0;
+}
+
+device_initcall(bluetooth_init);
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_wifi.c b/arch/x86/platform/intel-mid/device_libs/platform_wifi.c
new file mode 100644
index 0000000..ad0b6b4
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_wifi.c
@@ -0,0 +1,128 @@
+/*
+ * platform_bcm43xx.c: bcm43xx platform data initilization file
+ *
+ * (C) Copyright 2011 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/gpio.h>
+#include <linux/lnw_gpio.h>
+#include <asm/intel-mid.h>
+#include <linux/wlan_plat.h>
+#include <linux/interrupt.h>
+#include <linux/mmc/sdhci.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include "pci/platform_sdhci_pci.h"
+#include "platform_wifi.h"
+
+static struct resource wifi_res[] = {
+	{
+	.name = "wlan_irq",
+	.start = -1,
+	.end = -1,
+	.flags = IORESOURCE_IRQ | IRQF_TRIGGER_FALLING ,
+	},
+};
+
+static struct wifi_platform_data pdata;
+
+static struct platform_device wifi_device = {
+	.name = "wlan",
+	.dev = {
+		.platform_data = &pdata,
+		},
+	.num_resources = ARRAY_SIZE(wifi_res),
+	.resource = wifi_res,
+};
+
+static const unsigned int sdhci_quirk = SDHCI_QUIRK2_ADVERTISE_2V0_FORCE_1V8
+		| SDHCI_QUIRK2_ENABLE_MMC_PM_IGNORE_PM_NOTIFY
+		| SDHCI_QUIRK2_ADVERTISE_3V0_FORCE_1V8
+		| SDHCI_QUIRK2_NON_STD_CIS;
+
+static void __init wifi_platform_data_init_sfi_fastirq(struct sfi_device_table_entry *pentry,
+						       bool should_register)
+{
+	int wifi_irq_gpio = -1;
+
+	/* If the GPIO mode was previously called, this code overloads
+	   the IRQ anyway */
+	wifi_res[0].start = wifi_res[0].end = pentry->irq;
+	wifi_res[0].flags = IORESOURCE_IRQ | IRQF_TRIGGER_HIGH;
+
+	pr_info("wifi_platform_data: IRQ == %d\n", pentry->irq);
+
+	if (should_register && platform_device_register(&wifi_device) < 0)
+		pr_err("platform_device_register failed for wifi_device\n");
+}
+
+/* Called if SFI device WLAN is present */
+void __init wifi_platform_data_fastirq(struct sfi_device_table_entry *pe,
+				       struct devs_id *dev)
+{
+	/* This is used in the driver to know if it is GPIO/FastIRQ */
+	pdata.use_fast_irq = true;
+
+	if (wifi_res[0].start == -1) {
+		pr_info("Using WiFi platform data (Fast IRQ)\n");
+
+		/* Set vendor specific SDIO quirks */
+		sdhci_pdata_set_quirks(sdhci_quirk);
+		wifi_platform_data_init_sfi_fastirq(pe, true);
+	} else {
+		pr_info("Using WiFi platform data (Fast IRQ, overloading GPIO mode set previously)\n");
+		/* We do not register platform device, as it's already been
+		   done by wifi_platform_data */
+		wifi_platform_data_init_sfi_fastirq(pe, false);
+	}
+
+}
+
+/* GPIO legacy code path */
+static void __init wifi_platform_data_init_sfi_gpio(void)
+{
+	int wifi_irq_gpio = -1;
+
+	/*Get GPIO numbers from the SFI table*/
+	wifi_irq_gpio = get_gpio_by_name(WIFI_SFI_GPIO_IRQ_NAME);
+	if (wifi_irq_gpio < 0) {
+		pr_err("%s: Unable to find " WIFI_SFI_GPIO_IRQ_NAME
+		       " WLAN-interrupt GPIO in the SFI table\n",
+		       __func__);
+		return;
+	}
+
+	wifi_res[0].start = wifi_res[0].end = wifi_irq_gpio;
+	pr_info("wifi_platform_data: GPIO == %d\n", wifi_irq_gpio);
+
+	if (platform_device_register(&wifi_device) < 0)
+		pr_err("platform_device_register failed for wifi_device\n");
+}
+
+/* Called from board.c */
+void __init *wifi_platform_data(void *info)
+{
+	/* When fast IRQ platform data has been called first, don't pursue */
+	if (wifi_res[0].start != -1)
+		return NULL;
+
+	pr_info("Using generic wifi platform data\n");
+
+	/* Set vendor specific SDIO quirks */
+#ifdef CONFIG_MMC_SDHCI_PCI
+	sdhci_pdata_set_quirks(sdhci_quirk);
+#endif
+
+#ifndef CONFIG_ACPI
+	/* We are SFI here, register platform device */
+	wifi_platform_data_init_sfi_gpio();
+#endif
+
+	return &wifi_device;
+}
diff --git a/drivers/mmc/host/sdhci-pci.h b/drivers/mmc/host/sdhci-pci.h
index de290ef..19da33c 100644
--- a/drivers/mmc/host/sdhci-pci.h
+++ b/drivers/mmc/host/sdhci-pci.h
@@ -12,7 +12,6 @@
 #define PCI_DEVICE_ID_INTEL_BYT_EMMC2	0x0f50
 #define PCI_DEVICE_ID_INTEL_QRK_SD	0x08A7
 #define PCI_DEVICE_ID_INTEL_CLV_OTG    0xE006
-#define PCI_DEVICE_ID_INTEL_MRFL_DWC3_OTG      0x119E
 #define PCI_DEVICE_ID_INTEL_BYT_EMMC   0x0f14
 #define PCI_DEVICE_ID_INTEL_BYT_EMMC45 0x0f50
 #define PCI_DEVICE_ID_INTEL_BYT_OTG    0x0f37
diff --git a/drivers/net/wireless/Kconfig b/drivers/net/wireless/Kconfig
index 200020e..b8b486d 100644
--- a/drivers/net/wireless/Kconfig
+++ b/drivers/net/wireless/Kconfig
@@ -264,6 +264,16 @@ config MWL8K
 	  To compile this driver as a module, choose M here: the module
 	  will be called mwl8k.  If unsure, say N.
 
+config WIFI_CONTROL_FUNC
+	bool "Enable WiFi control function abstraction"
+	help
+	  Enables Power/Reset/Carddetect function abstraction
+
+config WIFI_PLATFORM_DATA
+	bool "Enable WiFi platform data"
+	---help---
+	 Enables platform_wifi
+
 source "drivers/net/wireless/ath/Kconfig"
 source "drivers/net/wireless/b43/Kconfig"
 source "drivers/net/wireless/b43legacy/Kconfig"
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 2e6b832..7efccb0 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -28,6 +28,7 @@ config USB_EHCI_BIG_ENDIAN_DESC
 
 config USB_ARCH_HAS_XHCI
 	bool
+	default PCI
 
 menuconfig USB_SUPPORT
 	bool "USB support"
diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c
index 33d9f36..93c60f5 100644
--- a/drivers/usb/core/hcd.c
+++ b/drivers/usb/core/hcd.c
@@ -2269,6 +2269,11 @@ static void hcd_resume_work(struct work_struct *work)
 	struct usb_device *udev = hcd->self.root_hub;
 
 	usb_remote_wakeup(udev);
+	if (HCD_IRQ_DISABLED(hcd)) {
+		/* We can now process IRQs so enable IRQ */
+		clear_bit(HCD_FLAG_IRQ_DISABLED, &hcd->flags);
+		enable_irq(hcd->irq);
+	}
 }
 
 /**
@@ -2353,9 +2358,23 @@ irqreturn_t usb_hcd_irq (int irq, void *__hcd)
 	struct usb_hcd		*hcd = __hcd;
 	irqreturn_t		rc;
 
-	if (unlikely(HCD_DEAD(hcd) || !HCD_HW_ACCESSIBLE(hcd)))
+	if (unlikely(HCD_DEAD(hcd)))
 		rc = IRQ_NONE;
-	else if (hcd->driver->irq(hcd) == IRQ_NONE)
+	else if (unlikely(!HCD_HW_ACCESSIBLE(hcd))) {
+		if (hcd->has_wakeup_irq) {
+			/*
+			 * We got a wakeup interrupt while the controller was
+			 * suspending or suspended. We can't handle it now, so
+			 * disable the IRQ and resume the root hub (and hence
+			 * the controller too).
+			 */
+			disable_irq_nosync(hcd->irq);
+			set_bit(HCD_FLAG_IRQ_DISABLED, &hcd->flags);
+			usb_hcd_resume_root_hub(hcd);
+			rc = IRQ_HANDLED;
+		} else
+			rc = IRQ_NONE;
+	} else if (hcd->driver->irq(hcd) == IRQ_NONE)
 		rc = IRQ_NONE;
 	else
 		rc = IRQ_HANDLED;
diff --git a/drivers/usb/dwc3/Kconfig b/drivers/usb/dwc3/Kconfig
index e2c730f..b6eebbb8 100644
--- a/drivers/usb/dwc3/Kconfig
+++ b/drivers/usb/dwc3/Kconfig
@@ -42,6 +42,72 @@ endchoice
 
 comment "Platform Glue Driver Support"
 
+config USB_DWC3_PCI
+	tristate "PCIe-based Platforms"
+	depends on PCI
+	default USB_DWC3
+	help
+	  If you're using the DesignWare Core IP with a PCIe, please say
+	  'Y' or 'M' here.
+
+	  One such PCIe-based platform is Synopsys' PCIe HAPS model of
+	  this IP.
+
+config USB_DWC3_OTG
+	tristate "DWC3 OTG mode support"
+	depends on USB && PCI
+	select USB_OTG
+	help
+	  Say Y here to enable DWC3 OTG driver.
+	  This driver implement OTG framework for DWC3 OTG controller.
+	  Support role switch and charger detection feature. And maintain
+	  one state machine. This driver should be work with platform
+	  speical driver. Because every platform has their own hardware design.
+
+config USB_DWC3_INTEL_MRFL
+	tristate "DWC OTG 3.0 for Intel Merrifield platforms"
+	depends on USB && USB_DWC3_OTG
+	select USB_DWC3_DEVICE_INTEL
+	help
+	  Say Y here to enable DWC3 OTG driver for Intel Merrifield platforms.
+	  It implement OTG feature on DWC3 OTG controller.
+	  Support role switch and charger detection feature.
+	  This driver is must be set if you want to enable host mode on Intel
+	  Merrifield platforms.
+
+config USB_DWC3_INTEL_BYT
+	tristate "DWC OTG 3.0 for Intel Baytrail platforms"
+	depends on USB && USB_DWC3_OTG
+	select USB_DWC3_DEVICE_INTEL
+	help
+	  Say Y here to enable DWC3 OTG driver for Intel Baytrail platforms.
+	  It implement OTG feature on DWC3 OTG controller.
+	  Support role switch and charger detection feature.
+	  This driver is must be set if you want to enable device mode on Intel
+	  Baytrial platforms.
+
+config USB_DWC3_DEVICE_INTEL
+	bool "DWC3 Device Mode support on Intel platform"
+	depends on USB_DWC3_OTG
+	help
+	  Support Device mode of DWC3 controller on Intel platform.
+	  It implement device mode feature on DWC3 OTG controller.
+	  This driver is must be set if you want to enable device mode for Intel
+	  platforms(e.g Baytrail and Merrifield)
+
+config USB_DWC3_HOST_INTEL
+	bool "DWC3 Host Mode support on Intel Merrifield platform"
+	depends on USB_ARCH_HAS_XHCI && USB_DWC3_INTEL_MRFL
+	help
+	  Support Host mode of DWC3 controller on Intel Merrifield platform.
+	  It is should be enable with DWC3 INTEL driver. Because Intel platform
+	  use different design with standard USB_DWC3_HOST. So if you want to
+	  enable host mode on Intel platform, then you have to enable this config.
+
+comment "Debugging features"
+
+comment "Platform Glue Driver Support"
+
 config USB_DWC3_OMAP
 	tristate "Texas Instruments OMAP5 and similar Platforms"
 	depends on EXTCON
diff --git a/drivers/usb/dwc3/Makefile b/drivers/usb/dwc3/Makefile
index 1feca26..4b1aaec 100644
--- a/drivers/usb/dwc3/Makefile
+++ b/drivers/usb/dwc3/Makefile
@@ -1,6 +1,13 @@
 ccflags-$(CONFIG_USB_DWC3_DEBUG)	:= -DDEBUG
 ccflags-$(CONFIG_USB_DWC3_VERBOSE)	+= -DVERBOSE_DEBUG
 
+obj-$(CONFIG_USB_DWC3_DEVICE_INTEL)		+= dwc3-device-intel.o
+obj-$(CONFIG_USB_DWC3_INTEL_MRFL)		+= dwc3-intel-mrfl.o
+ifneq ($(CONFIG_DEBUG_FS),)
+	obj-$(CONFIG_USB_DWC3_DEVICE_INTEL)	+= debugfs.o
+endif
+
+ifeq ($(CONFIG_USB_DWC3_DEVICE_INTEL),)
 obj-$(CONFIG_USB_DWC3)			+= dwc3.o
 
 dwc3-y					:= core.o
@@ -11,12 +18,12 @@ endif
 
 ifneq ($(filter y,$(CONFIG_USB_DWC3_GADGET) $(CONFIG_USB_DWC3_DUAL_ROLE)),)
 	dwc3-y				+= gadget.o ep0.o
-	dwc3-y				+= gadget.o ep0.o drd.o
 endif
 
 ifneq ($(CONFIG_DEBUG_FS),)
 	dwc3-y				+= debugfs.o
 endif
+endif
 
 ##
 # Platform-specific glue layers go here
@@ -32,5 +39,9 @@ endif
 
 obj-$(CONFIG_USB_DWC3_OMAP)		+= dwc3-omap.o
 obj-$(CONFIG_USB_DWC3_EXYNOS)		+= dwc3-exynos.o
-obj-$(CONFIG_USB_DWC3_PCI)		+= dwc3-pci.o
+
+ifneq ($(CONFIG_PCI),)
+	obj-$(CONFIG_USB_DWC3_OTG)	+= otg.o
+	obj-$(CONFIG_USB_DWC3)		+= dwc3-pci.o
+endif
 obj-$(CONFIG_USB_DWC3_KEYSTONE)		+= dwc3-keystone.o
diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index be5007a..8d7c912 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -35,6 +35,7 @@
 
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
+#include <linux/usb/ulpi.h>
 #include <linux/usb/of.h>
 #include <linux/usb/otg.h>
 
@@ -45,6 +46,7 @@
 
 #include "debug.h"
 
+static char *maximum_speed = "super";
 extern void octeon3_usb_phy_reset(int index);
 extern int xhci_octeon_start(struct platform_device *pdev);
 extern int xhci_octeon_stop(struct platform_device *pdev);
@@ -69,7 +71,7 @@ void dwc3_set_mode(struct dwc3 *dwc, u32 mode)
  * dwc3_core_soft_reset - Issues core soft reset and PHY reset
  * @dwc: pointer to our context structure
  */
-int dwc3_core_soft_reset(struct dwc3 *dwc)
+static void dwc3_core_soft_reset(struct dwc3 *dwc)
 {
 	u32		reg;
 	int		index;
@@ -114,7 +116,6 @@ int dwc3_core_soft_reset(struct dwc3 *dwc)
 	reg = dwc3_readl(dwc->regs, DWC3_GCTL);
 	reg &= ~DWC3_GCTL_CORESOFTRESET;
 	dwc3_writel(dwc->regs, DWC3_GCTL, reg);
-	return 0;
 }
 
 /**
@@ -214,7 +215,7 @@ static int dwc3_alloc_event_buffers(struct dwc3 *dwc, unsigned length)
  *
  * Returns 0 on success otherwise negative errno.
  */
-int dwc3_event_buffers_setup(struct dwc3 *dwc)
+static int dwc3_event_buffers_setup(struct dwc3 *dwc)
 {
 	struct dwc3_event_buffer	*evt;
 	int				n;
@@ -239,7 +240,7 @@ int dwc3_event_buffers_setup(struct dwc3 *dwc)
 	return 0;
 }
 
-static void dwc3_event_buffers_cleanup(struct dwc3 *dwc)
+void dwc3_event_buffers_cleanup(struct dwc3 *dwc)
 {
 	struct dwc3_event_buffer	*evt;
 	int				n;
@@ -253,7 +254,8 @@ static void dwc3_event_buffers_cleanup(struct dwc3 *dwc)
 		dwc3_writel(dwc->regs, DWC3_GEVNTADRHI(n), 0);
 		dwc3_writel(dwc->regs, DWC3_GEVNTSIZ(n), DWC3_GEVNTSIZ_INTMASK
 				| DWC3_GEVNTSIZ_SIZE(0));
-		dwc3_writel(dwc->regs, DWC3_GEVNTCOUNT(n), 0);
+		dwc3_writel(dwc->regs, DWC3_GEVNTCOUNT(n),
+			dwc3_readl(dwc->regs, DWC3_GEVNTCOUNT(n)));
 	}
 }
 
@@ -294,6 +296,7 @@ static int dwc3_core_init(struct dwc3 *dwc)
 	unsigned long		timeout;
 	u32			reg;
 	int			ret;
+	struct usb_phy		*usb_phy;
 
 	reg = dwc3_readl(dwc->regs, DWC3_GSNPSID);
 	/* This should read as U3 followed by revision number */
@@ -304,6 +307,13 @@ static int dwc3_core_init(struct dwc3 *dwc)
 	}
 	dwc->revision = reg;
 
+	dwc3_core_soft_reset(dwc);
+
+	/* Delay 1 ms Before DCTL soft reset to make it safer from hitting
+	 * Tx-CMD PHY hang issue.
+	 */
+	mdelay(1);
+
 	/* issue device SoftReset too */
 	timeout = jiffies + msecs_to_jiffies(500);
 	dwc3_writel(dwc->regs, DWC3_DCTL, DWC3_DCTL_CSFTRST);
@@ -321,7 +331,14 @@ static int dwc3_core_init(struct dwc3 *dwc)
 		cpu_relax();
 	} while (true);
 
-	dwc3_core_soft_reset(dwc);
+	/* DCTL core soft reset may cause PHY hang, delay 1 ms and check ulpi */
+	mdelay(1);
+	usb_phy = usb_get_phy(USB_PHY_TYPE_USB2);
+	if (usb_phy &&
+		usb_phy_io_read(usb_phy, ULPI_VENDOR_ID_LOW) < 0)
+		dev_err(dwc->dev,
+			"ULPI not working after DCTL soft reset\n");
+	usb_put_phy(usb_phy);
 
 	reg = dwc3_readl(dwc->regs, DWC3_GCTL);
 	reg &= ~DWC3_GCTL_SCALEDOWN_MASK;
diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index fc4169f..d995a35 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -649,8 +649,6 @@ struct dwc3_hwregs {
  * @u1u2: only used on revisions <1.83a for workaround
  * @maximum_speed: maximum speed requested (mainly for testing purposes)
  * @revision: revision register contents
- *  <at> has_gadget: true when gadget is initialized
- *  <at> has_xhci: true when xhci is initialized
  * @dr_mode: requested mode of operation
  * @usb2_phy: pointer to USB2 PHY
  * @usb3_phy: pointer to USB3 PHY
@@ -749,8 +747,6 @@ struct dwc3 {
 	unsigned		pullups_connected:1;
 	unsigned		quirks_disable_irqthread:1;
 
-	bool			has_gadget;
-	bool			has_xhci;
 	enum dwc3_ep0_next	ep0_next_event;
 	enum dwc3_ep0_state	ep0state;
 	enum dwc3_link_state	link_state;
@@ -955,8 +951,6 @@ void dwc3_unregister_io_ebc(struct ebc_io *ebc);
 /* prototypes */
 void dwc3_set_mode(struct dwc3 *dwc, u32 mode);
 int dwc3_gadget_resize_tx_fifos(struct dwc3 *dwc);
-int dwc3_core_soft_reset(struct dwc3 *dwc);
-int dwc3_event_buffers_setup(struct dwc3 *dwc);
 
 #if IS_ENABLED(CONFIG_USB_DWC3_HOST) || IS_ENABLED(CONFIG_USB_DWC3_DUAL_ROLE)
 int dwc3_host_init(struct dwc3 *dwc);
@@ -977,6 +971,7 @@ int dwc3_gadget_set_link_state(struct dwc3 *dwc, enum dwc3_link_state state);
 int dwc3_send_gadget_ep_cmd(struct dwc3 *dwc, unsigned ep,
 		unsigned cmd, struct dwc3_gadget_ep_cmd_params *params);
 int dwc3_send_gadget_generic_command(struct dwc3 *dwc, int cmd, u32 param);
+void dwc3_event_buffers_cleanup(struct dwc3 *dwc);
 #else
 static inline int dwc3_gadget_init(struct dwc3 *dwc)
 { return 0; }
diff --git a/drivers/usb/dwc3/debugfs.c b/drivers/usb/dwc3/debugfs.c
index 22205ed..6fa94ea 100644
--- a/drivers/usb/dwc3/debugfs.c
+++ b/drivers/usb/dwc3/debugfs.c
@@ -32,7 +32,6 @@
 #include "gadget.h"
 #include "io.h"
 #include "debug.h"
-#include "drd.h"
 
 #define dump_register(nm)				\
 {							\
@@ -395,6 +394,7 @@ static ssize_t dwc3_mode_write(struct file *file,
 {
 	struct seq_file		*s = file->private_data;
 	struct dwc3		*dwc = s->private;
+	unsigned long		flags;
 	u32			mode = 0;
 	char			buf[32];
 
@@ -410,20 +410,11 @@ static ssize_t dwc3_mode_write(struct file *file,
 	if (!strncmp(buf, "otg", 3))
 		mode |= DWC3_GCTL_PRTCAP_OTG;
 
-	switch (mode) {
-	case DWC3_GCTL_PRTCAP_DEVICE:
-		dwc3_drd_to_device(dwc);
-		break;
-	case DWC3_GCTL_PRTCAP_HOST:
-		dwc3_drd_to_host(dwc);
-		break;
-	case DWC3_GCTL_PRTCAP_OTG:
-		dwc3_drd_to_otg(dwc);
-		break;
-	default:
-		/* Should never happen */
-		break;
-        }
+	if (mode) {
+		spin_lock_irqsave(&dwc->lock, flags);
+		dwc3_set_mode(dwc, mode);
+		spin_unlock_irqrestore(&dwc->lock, flags);
+	}
 	return count;
 }
 
@@ -627,6 +618,48 @@ static const struct file_operations dwc3_link_state_fops = {
 	.release		= single_release,
 };
 
+static int dwc3_hiber_enabled_show(struct seq_file *s, void *unused)
+{
+	struct dwc3		*dwc = s->private;
+
+	if (dwc->hiber_enabled)
+		seq_puts(s, "hibernation enabled\n");
+	else
+		seq_puts(s, "hibernation disabled\n");
+
+	return 0;
+}
+
+static int dwc3_hiber_enabled_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, dwc3_hiber_enabled_show, inode->i_private);
+}
+
+static ssize_t dwc3_hiber_enabled_write(struct file *file,
+		const char __user *ubuf, size_t count, loff_t *ppos)
+{
+	struct seq_file		*s = file->private_data;
+	struct dwc3		*dwc = s->private;
+	char			buf[32];
+	int			enabled = 0;
+
+	if (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))
+		return -EFAULT;
+
+	sscanf(buf, "%d", &enabled);
+	dwc->hiber_enabled = enabled;
+
+	return count;
+}
+
+static const struct file_operations dwc3_hiber_enabled_fops = {
+	.open			= dwc3_hiber_enabled_open,
+	.write			= dwc3_hiber_enabled_write,
+	.read			= seq_read,
+	.llseek			= seq_lseek,
+	.release		= single_release,
+};
+
 int dwc3_debugfs_init(struct dwc3 *dwc)
 {
 	struct dentry		*root;
@@ -681,6 +714,13 @@ int dwc3_debugfs_init(struct dwc3 *dwc)
 			ret = -ENOMEM;
 			goto err1;
 		}
+
+		file = debugfs_create_file("hiber_enabled", S_IRUGO | S_IWUSR,
+				root, dwc, &dwc3_hiber_enabled_fops);
+		if (!file) {
+			ret = -ENOMEM;
+			goto err1;
+		}
 	}
 
 	return 0;
diff --git a/drivers/usb/dwc3/drd.c b/drivers/usb/dwc3/drd.c
deleted file mode 100644
index f80090f..0000000
--- a/drivers/usb/dwc3/drd.c
+++ /dev/null
@@ -1,163 +0,0 @@
-/****
- * drd.c - DesignWare USB3 DRD Controller Dual Role Switch Funciton File
- *
- * Copyright (C) 2014 Advanced Micro Devices, Inc.
- *
- * Author: Huang Rui <ray.huang@... <http://gmane.org/get-address.php?address=ray.huang%2d5C7GfCeVMHo%40public.gmane.org>>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2  of
- * the License as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/spinlock.h>
-#include <linux/platform_device.h>
-#include <linux/pm_runtime.h>
-#include <linux/interrupt.h>
-#include <linux/ioport.h>
-#include <linux/io.h>
-#include <linux/list.h>
-#include <linux/delay.h>
-#include <linux/dma-mapping.h>
-#include <linux/of.h>
-
-#include <linux/usb/ch9.h>
-#include <linux/usb/gadget.h>
-#include <linux/usb/composite.h>
-
-#include "core.h"
-#include "gadget.h"
-#include "io.h"
-#include "drd.h"
-
-
-int dwc3_drd_to_host(struct dwc3 *dwc)
-{
-	int ret;
-	unsigned long flags = 0;
-
-	if (dwc->has_xhci)
-		dwc3_host_exit(dwc);
-	if (dwc->has_gadget)
-		dwc3_gadget_stop_on_switch(dwc);
-
-	ret = dwc3_core_soft_reset(dwc);
-	if (ret) {
-		dev_err(dwc->dev, "soft reset failed\n");
-		goto err0;
-	}
-
-	spin_lock_irqsave(&dwc->lock, flags);
-	ret = dwc3_event_buffers_setup(dwc);
-	if (ret) {
-		dev_err(dwc->dev, "failed to setup event buffers\n");
-		goto err0;
-	}
-
-	dwc3_set_mode(dwc, DWC3_GCTL_PRTCAP_HOST);
-
-	ret = dwc3_host_init(dwc);
-	if (ret) {
-		dev_err(dwc->dev, "failed to init host\n");
-		goto err0;
-	}
-err0:
-	spin_unlock_irqrestore(&dwc->lock, flags);
-	return ret;
-}
-
-int dwc3_drd_to_device(struct dwc3 *dwc)
-{
-	int ret;
-	unsigned long timeout, flags = 0;
-	u32 reg;
-
-	if (dwc->has_xhci)
-		dwc3_host_exit(dwc);
-	if (dwc->has_gadget)
-		dwc3_gadget_stop_on_switch(dwc);
-
-	ret = dwc3_core_soft_reset(dwc);
-	if (ret) {
-		dev_err(dwc->dev, "soft reset failed\n");
-		goto err0;
-	}
-
-	spin_lock_irqsave(&dwc->lock, flags);
-	dwc3_set_mode(dwc, DWC3_GCTL_PRTCAP_DEVICE);
-
-	/* issue device SoftReset too */
-	timeout = jiffies + msecs_to_jiffies(500);
-	dwc3_writel(dwc->regs, DWC3_DCTL, DWC3_DCTL_CSFTRST);
-	do {
-		reg = dwc3_readl(dwc->regs, DWC3_DCTL);
-		if (!(reg & DWC3_DCTL_CSFTRST))
-			break;
-
-		if (time_after(jiffies, timeout)) {
-			dev_err(dwc->dev, "Reset Timed Out\n");
-			ret = -ETIMEDOUT;
-			goto err0;
-		}
-
-		cpu_relax();
-	} while (true);
-
-	ret = dwc3_event_buffers_setup(dwc);
-	if (ret) {
-		dev_err(dwc->dev, "failed to setup event buffers\n");
-		goto err0;
-	}
-
-	ret = dwc3_gadget_restart(dwc);
-	if (ret) {
-		dev_err(dwc->dev, "failed to restart gadget\n");
-		goto err0;
-	}
-err0:
-	spin_unlock_irqrestore(&dwc->lock, flags);
-	return ret;
-}
-
-int dwc3_drd_to_otg(struct dwc3 *dwc)
-{
-	int ret = 0;
-	unsigned long flags = 0;
-
-	if (dwc->has_xhci)
-		dwc3_host_exit(dwc);
-	if (dwc->has_gadget)
-		dwc3_gadget_stop_on_switch(dwc);
-
-	ret = dwc3_core_soft_reset(dwc);
-	if (ret) {
-		dev_err(dwc->dev, "soft reset failed\n");
-		goto err0;
-	}
-
-	spin_lock_irqsave(&dwc->lock, flags);
-	ret = dwc3_event_buffers_setup(dwc);
-	if (ret) {
-		dev_err(dwc->dev, "failed to setup event buffers\n");
-		goto err0;
-	}
-
-	dwc3_set_mode(dwc, DWC3_GCTL_PRTCAP_OTG);
-
-	ret = dwc3_host_init(dwc);
-	if (ret) {
-		dev_err(dwc->dev, "failed to init host\n");
-		goto err0;
-	}
-
-err0:
-	spin_unlock_irqrestore(&dwc->lock, flags);
-	return ret;
-}
diff --git a/drivers/usb/dwc3/drd.h b/drivers/usb/dwc3/drd.h
deleted file mode 100644
index 1bacead..0000000
--- a/drivers/usb/dwc3/drd.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/****
- * drd.c - DesignWare USB3 DRD Controller Dual Role Switch Funciton Header
- *
- * Copyright (C) 2014 Advanced Micro Devices, Inc.
- *
- * Author: Huang Rui <ray.huang@... <http://gmane.org/get-address.php?address=ray.huang%2d5C7GfCeVMHo%40public.gmane.org>>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2  of
- * the License as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#ifndef __DRIVERS_USB_DWC3_DRD_H
-#define __DRIVERS_USB_DWC3_DRD_H
-
-#include "core.h"
-#include "gadget.h"
-#include "io.h"
-
-extern int dwc3_drd_to_host(struct dwc3 *dwc);
-extern int dwc3_drd_to_device(struct dwc3 *dwc);
-extern int dwc3_drd_to_otg(struct dwc3 *dwc);
-
-#endif /* __DRIVERS_USB_DWC3_CORE_H */
-
diff --git a/drivers/usb/dwc3/dwc3-device-intel.c b/drivers/usb/dwc3/dwc3-device-intel.c
new file mode 100644
index 0000000..38534eb
--- /dev/null
+++ b/drivers/usb/dwc3/dwc3-device-intel.c
@@ -0,0 +1,648 @@
+/**
+ * Copyright (C) 2012 Intel Corp.
+ * Author: Jiebing Li
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+#include <linux/usb/dwc3-intel-mid.h>
+#include <linux/usb/phy.h>
+
+#include "core.h"
+#include "gadget.h"
+#include "io.h"
+#include "otg.h"
+
+#include "debug.h"
+
+#include "core.c"
+#include "ep0.c"
+#include "gadget.c"
+
+/* FLIS register */
+#define APBFC_EXIOTG3_MISC0_REG		0xF90FF85C
+
+/* Global User Control Register Auto Retry bit*/
+#define DWC3_GUCTL_USB_HST_IN_AUTO_RETRY_EN	(1 << 14)
+
+/* Global Configuration Register */
+#define DWC3_GRXTHRCFG_USBRXPKTCNTSEL		(1 << 29)
+#define DWC3_GRXTHRCFG_USBRXPKTCNT(n)		(n << 24)
+#define DWC3_GRXTHRCFG_USBRXPKTCNT_MASK		(0xf << 24)
+#define DWC3_GRXTHRCFG_USBMAXRXBURSTSIZE(n)	(n << 19)
+#define DWC3_GRXTHRCFG_USBMAXRXBURSTSIZE_MASK	(0x1f << 19)
+
+/**
+ * struct dwc3_dev_data - Structure holding platform related
+ *			information
+ * @flis_reg:		FLIS register
+ * @grxthrcfg:		DWC3 GRXTHCFG register
+ */
+struct dwc3_dev_data {
+	struct dwc3		*dwc;
+	void __iomem		*flis_reg;
+	u32			grxthrcfg;
+	struct mutex		mutex;
+};
+
+static struct dwc3_dev_data	*_dev_data;
+
+/*
+ * dwc3_set_fils_reg - set FLIS register
+ *
+ * This is a workaround for OTG3 IP bug of using EP #8 for host mode
+ */
+static void dwc3_set_flis_reg(void)
+{
+	u32			reg;
+	void __iomem		*flis_reg;
+
+	flis_reg = _dev_data->flis_reg;
+
+	reg = dwc3_readl(flis_reg, DWC3_GLOBALS_REGS_START);
+	reg &= ~(1 << 3);
+	dwc3_writel(flis_reg, DWC3_GLOBALS_REGS_START, reg);
+}
+
+/*
+ * dwc3_disable_multi_packet - set GRXTHRCFG register to disable
+ * reception multi-packet thresholdingfor DWC2.50a.
+ */
+static void dwc3_disable_multi_packet(struct dwc3 *dwc)
+{
+	u32			reg;
+
+	reg = dwc3_readl(dwc->regs, DWC3_GRXTHRCFG);
+	_dev_data->grxthrcfg = reg;
+	if (reg) {
+		reg &= ~DWC3_GRXTHRCFG_USBRXPKTCNTSEL;
+		reg &= ~DWC3_GRXTHRCFG_USBRXPKTCNT_MASK;
+		reg &= ~DWC3_GRXTHRCFG_USBMAXRXBURSTSIZE_MASK;
+
+		dwc3_writel(dwc->regs, DWC3_GRXTHRCFG, reg);
+	}
+}
+
+/*
+ * dwc3_enable_host_auto_retry - clear Auto Retry Enable bit
+ * for device mode
+ */
+static void dwc3_enable_host_auto_retry(struct dwc3 *dwc, bool enable)
+{
+	u32			reg;
+
+	reg = dwc3_readl(dwc->regs, DWC3_GUCTL);
+
+	if (enable)
+		reg |= DWC3_GUCTL_USB_HST_IN_AUTO_RETRY_EN;
+	else
+		reg &= ~DWC3_GUCTL_USB_HST_IN_AUTO_RETRY_EN;
+
+	dwc3_writel(dwc->regs, DWC3_GUCTL, reg);
+}
+
+static void dwc3_do_extra_change(struct dwc3 *dwc)
+{
+	dwc3_set_flis_reg();
+
+	if (dwc->revision == DWC3_REVISION_250A)
+		dwc3_disable_multi_packet(dwc);
+
+	dwc3_enable_host_auto_retry(dwc, false);
+}
+
+static void dwc3_enable_hibernation(struct dwc3 *dwc)
+{
+	u32 num, reg;
+
+	if (DWC3_GHWPARAMS1_EN_PWROPT(dwc->hwparams.hwparams1)
+		!= DWC3_GHWPARAMS1_EN_PWROPT_HIB) {
+		dev_err(dwc->dev, "Device Mode Hibernation is not supported\n");
+		return;
+	}
+
+	num = DWC3_GHWPARAMS4_HIBER_SCRATCHBUFS(
+		 dwc->hwparams.hwparams4);
+	if (num != 1)
+		dev_err(dwc->dev, "number of scratchpad buffer: %d\n", num);
+
+	reg = dwc3_readl(dwc->regs, DWC3_GCTL);
+	reg |= DWC3_GCTL_GBLHIBERNATIONEN;
+	dwc3_writel(dwc->regs, DWC3_GCTL, reg);
+
+	dwc3_send_gadget_generic_command(dwc, DWC3_DGCMD_SET_SCRATCH_ADDR_LO,
+		dwc->scratch_array_dma & 0xffffffffU);
+}
+
+/*
+ * Re-write irq functions. Not use irq thread. Because irqthread has negative
+ * impact on usb performance, especially for usb network performance, USB3 UDP
+ * download performance will drop from 80MB/s to 40MB/s if irqthread is enabled.
+ */
+static irqreturn_t dwc3_quirks_process_event_buf(struct dwc3 *dwc, u32 buf)
+{
+	struct dwc3_event_buffer *evt;
+	u32 count;
+	u32 reg;
+	int left;
+
+	evt = dwc->ev_buffs[buf];
+
+	count = dwc3_readl(dwc->regs, DWC3_GEVNTCOUNT(buf));
+	count &= DWC3_GEVNTCOUNT_MASK;
+	if (!count)
+		return IRQ_NONE;
+
+	evt->count = count;
+
+	/* WORKAROUND: Add 4 us delay workaround to A-unit issue in A0 stepping.
+	* Can be removed after B0.
+	*/
+	if (dwc->is_otg && dwc->revision == DWC3_REVISION_210A)
+		udelay(4);
+
+	left = evt->count;
+
+	while (left > 0) {
+		union dwc3_event event;
+
+		event.raw = *(u32 *) (evt->buf + evt->lpos);
+
+		dwc3_process_event_entry(dwc, &event);
+
+		/*
+		* FIXME we wrap around correctly to the next entry as
+		* almost all entries are 4 bytes in size. There is one
+		* entry which has 12 bytes which is a regular entry
+		* followed by 8 bytes data. ATM I don't know how
+		* things are organized if we get next to the a
+		* boundary so I worry about that once we try to handle
+		* that.
+		*/
+		evt->lpos = (evt->lpos + 4) % DWC3_EVENT_BUFFERS_SIZE;
+		left -= 4;
+
+		dwc3_writel(dwc->regs, DWC3_GEVNTCOUNT(buf), 4);
+	}
+
+	evt->count = 0;
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t dwc3_quirks_interrupt(int irq, void *_dwc)
+{
+	struct dwc3	*dwc = _dwc;
+	int		i;
+	irqreturn_t	ret = IRQ_NONE;
+
+	spin_lock(&dwc->lock);
+	if (dwc->pm_state != PM_ACTIVE) {
+		if (dwc->pm_state == PM_SUSPENDED) {
+			dev_info(dwc->dev, "u2/u3 pmu is received\n");
+			pm_runtime_get(dwc->dev);
+			dwc->pm_state = PM_RESUMING;
+			ret = IRQ_HANDLED;
+		}
+		goto out;
+	}
+
+	for (i = 0; i < dwc->num_event_buffers; i++) {
+		irqreturn_t status;
+
+		status = dwc3_quirks_process_event_buf(dwc, i);
+		if (status == IRQ_HANDLED)
+			ret = status;
+	}
+
+out:
+	spin_unlock(&dwc->lock);
+
+	return ret;
+}
+
+int dwc3_start_peripheral(struct usb_gadget *g)
+{
+	struct dwc3		*dwc = gadget_to_dwc(g);
+	unsigned long		flags;
+	int			irq;
+	int			ret = 0;
+
+	pm_runtime_get_sync(dwc->dev);
+
+	mutex_lock(&_dev_data->mutex);
+	spin_lock_irqsave(&dwc->lock, flags);
+
+	if (dwc->gadget_driver && dwc->soft_connected) {
+		spin_unlock_irqrestore(&dwc->lock, flags);
+		dwc3_core_init(dwc);
+		spin_lock_irqsave(&dwc->lock, flags);
+
+		if (dwc->hiber_enabled)
+			dwc3_enable_hibernation(dwc);
+		dwc3_do_extra_change(dwc);
+		dwc3_event_buffers_setup(dwc);
+		ret = dwc3_init_for_enumeration(dwc);
+		if (ret)
+			goto err1;
+
+		if (dwc->soft_connected)
+			dwc3_gadget_run_stop(dwc, 1);
+	}
+
+	dwc->pm_state = PM_ACTIVE;
+
+	spin_unlock_irqrestore(&dwc->lock, flags);
+
+	irq = platform_get_irq(to_platform_device(dwc->dev), 0);
+	if (dwc->quirks_disable_irqthread)
+		ret = request_irq(irq, dwc3_quirks_interrupt,
+				IRQF_SHARED, "dwc3", dwc);
+	else
+		ret = request_threaded_irq(irq, dwc3_interrupt, dwc3_thread_interrupt,
+				IRQF_SHARED, "dwc3", dwc);
+	if (ret) {
+		dev_err(dwc->dev, "failed to request irq #%d --> %d\n",
+				irq, ret);
+		goto err0;
+	}
+	mutex_unlock(&_dev_data->mutex);
+
+	return 0;
+
+err1:
+	spin_unlock_irqrestore(&dwc->lock, flags);
+err0:
+	mutex_unlock(&_dev_data->mutex);
+
+	return ret;
+}
+
+int dwc3_stop_peripheral(struct usb_gadget *g)
+{
+	struct dwc3		*dwc = gadget_to_dwc(g);
+	unsigned long		flags;
+	u8			epnum;
+	int			irq;
+
+	mutex_lock(&_dev_data->mutex);
+	spin_lock_irqsave(&dwc->lock, flags);
+
+	dwc3_stop_active_transfers(dwc);
+
+	if (dwc->gadget.speed != USB_SPEED_UNKNOWN) {
+		dwc3_disconnect_gadget(dwc);
+
+		dwc->gadget.speed = USB_SPEED_UNKNOWN;
+	}
+
+	dwc->start_config_issued = false;
+
+	/* Clear Run/Stop bit */
+	dwc3_gadget_run_stop(dwc, 0);
+	dwc3_gadget_keep_conn(dwc, 0);
+
+	for (epnum = 0; epnum < 2; epnum++) {
+		struct dwc3_ep  *dep;
+
+		dep = dwc->eps[epnum];
+
+		if (dep->flags & DWC3_EP_ENABLED)
+			__dwc3_gadget_ep_disable(dep);
+	}
+
+	dwc3_gadget_disable_irq(dwc);
+
+	dwc3_event_buffers_cleanup(dwc);
+
+	if (_dev_data->grxthrcfg && dwc->revision == DWC3_REVISION_250A) {
+		dwc3_writel(dwc->regs, DWC3_GRXTHRCFG, _dev_data->grxthrcfg);
+		_dev_data->grxthrcfg = 0;
+	}
+
+	dwc3_enable_host_auto_retry(dwc, true);
+
+	if (dwc->pm_state != PM_SUSPENDED)
+		pm_runtime_put(dwc->dev);
+
+	dwc->pm_state = PM_DISCONNECTED;
+	spin_unlock_irqrestore(&dwc->lock, flags);
+
+	irq = platform_get_irq(to_platform_device(dwc->dev), 0);
+	free_irq(irq, dwc);
+
+	mutex_unlock(&_dev_data->mutex);
+
+	cancel_delayed_work_sync(&dwc->link_work);
+
+	return 0;
+}
+
+static int dwc3_device_gadget_pullup(struct usb_gadget *g, int is_on)
+{
+	struct dwc3		*dwc = gadget_to_dwc(g);
+	unsigned long		flags;
+	int			ret;
+
+	/*
+	 * FIXME If pm_state is PM_RESUMING, we should wait for it to
+	 * become PM_ACTIVE before continue. The chance of hitting
+	 * PM_RESUMING is rare, but if so, we'll return directly.
+	 *
+	 * If some gadget reaches here in atomic context,
+	 * pm_runtime_get_sync will cause a sleep problem.
+	 */
+	if (dwc->pm_state == PM_RESUMING) {
+		dev_err(dwc->dev, "%s: PM_RESUMING, return -EIO\n", __func__);
+		return -EIO;
+	}
+
+	if (dwc->pm_state == PM_SUSPENDED)
+		pm_runtime_get_sync(dwc->dev);
+
+	is_on = !!is_on;
+
+	mutex_lock(&_dev_data->mutex);
+
+	if (dwc->soft_connected == is_on)
+		goto done;
+
+	dwc->soft_connected = is_on;
+
+	spin_lock_irqsave(&dwc->lock, flags);
+	if (dwc->pm_state == PM_DISCONNECTED) {
+		spin_unlock_irqrestore(&dwc->lock, flags);
+		goto done;
+	}
+
+	if (is_on) {
+		/* Per dwc3 databook 2.40a section 8.1.9, re-connection
+		 * should follow steps described section 8.1.1 power on
+		 * or soft reset.
+		 */
+		spin_unlock_irqrestore(&dwc->lock, flags);
+		dwc3_core_init(dwc);
+		spin_lock_irqsave(&dwc->lock, flags);
+
+		if (dwc->hiber_enabled)
+			dwc3_enable_hibernation(dwc);
+		dwc3_do_extra_change(dwc);
+		dwc3_event_buffers_setup(dwc);
+		dwc3_init_for_enumeration(dwc);
+		ret = dwc3_gadget_run_stop(dwc, 1);
+		if (dwc->hiber_enabled)
+			dwc3_gadget_keep_conn(dwc, 1);
+	} else {
+		u8 epnum;
+
+		for (epnum = 0; epnum < 2; epnum++) {
+			struct dwc3_ep  *dep;
+
+			dep = dwc->eps[epnum];
+
+			if (dep->flags & DWC3_EP_ENABLED)
+				__dwc3_gadget_ep_disable(dep);
+		}
+
+		dwc3_stop_active_transfers(dwc);
+		dwc3_gadget_keep_conn(dwc, 0);
+		ret = dwc3_gadget_run_stop(dwc, 0);
+		dwc3_gadget_disable_irq(dwc);
+	}
+
+	spin_unlock_irqrestore(&dwc->lock, flags);
+	mutex_unlock(&_dev_data->mutex);
+
+	return ret;
+
+done:
+	mutex_unlock(&_dev_data->mutex);
+
+	return 0;
+}
+
+static const struct usb_gadget_ops dwc3_device_gadget_ops = {
+	.get_frame		= dwc3_gadget_get_frame,
+	.wakeup			= dwc3_gadget_wakeup,
+	.set_selfpowered	= dwc3_gadget_set_selfpowered,
+	.pullup			= dwc3_device_gadget_pullup,
+	.udc_start		= dwc3_gadget_start,
+	.udc_stop		= dwc3_gadget_stop,
+	.vbus_draw		= dwc3_vbus_draw,
+};
+
+static int dwc3_device_intel_probe(struct platform_device *pdev)
+{
+	struct device_node	*node = pdev->dev.of_node;
+	struct dwc3		*dwc;
+	struct device		*dev = &pdev->dev;
+	int			ret = -ENOMEM;
+	void			*mem;
+
+	struct dwc_device_par	*pdata;
+	struct usb_phy		*usb_phy;
+	struct dwc_otg2		*otg;
+
+	mem = devm_kzalloc(dev, sizeof(*dwc) + DWC3_ALIGN_MASK, GFP_KERNEL);
+	if (!mem) {
+		dev_err(dev, "not enough memory\n");
+		return -ENOMEM;
+	}
+	dwc = PTR_ALIGN(mem, DWC3_ALIGN_MASK + 1);
+	dwc->mem = mem;
+
+	_dev_data = kzalloc(sizeof(*_dev_data), GFP_KERNEL);
+	if (!_dev_data) {
+		dev_err(dev, "not enough memory\n");
+		return -ENOMEM;
+	}
+
+	_dev_data->dwc = dwc;
+
+	pdata = (struct dwc_device_par *)pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev, "No platform data for %s.\n",
+				dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+
+	if (node) {
+		dwc->usb2_phy = devm_usb_get_phy_by_phandle(dev, "usb-phy", 0);
+		dwc->usb3_phy = devm_usb_get_phy_by_phandle(dev, "usb-phy", 1);
+	} else {
+		dwc->usb2_phy = devm_usb_get_phy(dev, USB_PHY_TYPE_USB2);
+		dwc->usb3_phy = devm_usb_get_phy(dev, USB_PHY_TYPE_USB3);
+	}
+
+	if (IS_ERR(dwc->usb2_phy)) {
+		ret = PTR_ERR(dwc->usb2_phy);
+
+		/*
+		 * if -ENXIO is returned, it means PHY layer wasn't
+		 * enabled, so it makes no sense to return -EPROBE_DEFER
+		 * in that case, since no PHY driver will ever probe.
+		 */
+		if (ret == -ENXIO)
+			return ret;
+
+		dev_err(dev, "no usb2 phy configured\n");
+		return -EPROBE_DEFER;
+	}
+
+	if (IS_ERR(dwc->usb3_phy)) {
+		ret = PTR_ERR(dwc->usb2_phy);
+
+		/*
+		 * if -ENXIO is returned, it means PHY layer wasn't
+		 * enabled, so it makes no sense to return -EPROBE_DEFER
+		 * in that case, since no PHY driver will ever probe.
+		 */
+		if (ret == -ENXIO)
+			return ret;
+
+		dev_err(dev, "no usb3 phy configured\n");
+		return -EPROBE_DEFER;
+	}
+
+	mutex_init(&_dev_data->mutex);
+	spin_lock_init(&dwc->lock);
+	platform_set_drvdata(pdev, dwc);
+
+	dwc->regs   = pdata->io_addr + DWC3_GLOBALS_REGS_START;
+	dwc->regs_size  = pdata->len - DWC3_GLOBALS_REGS_START;
+	dwc->dev	= dev;
+
+	dev->dma_mask	= dev->parent->dma_mask;
+	dev->dma_parms	= dev->parent->dma_parms;
+	dma_set_coherent_mask(dev, dev->parent->coherent_dma_mask);
+
+	if (!strncmp("super", maximum_speed, 5))
+		dwc->maximum_speed = DWC3_DCFG_SUPERSPEED;
+	else if (!strncmp("high", maximum_speed, 4))
+		dwc->maximum_speed = DWC3_DCFG_HIGHSPEED;
+	else if (!strncmp("full", maximum_speed, 4))
+		dwc->maximum_speed = DWC3_DCFG_FULLSPEED1;
+	else if (!strncmp("low", maximum_speed, 3))
+		dwc->maximum_speed = DWC3_DCFG_LOWSPEED;
+	else
+		dwc->maximum_speed = DWC3_DCFG_SUPERSPEED;
+
+	dwc->needs_fifo_resize = of_property_read_bool(node, "tx-fifo-resize");
+
+	pm_runtime_set_active(&pdev->dev);
+	pm_runtime_enable(dev);
+	pm_runtime_set_suspended(&pdev->dev);
+	pm_runtime_get_sync(dev);
+	pm_runtime_forbid(dev);
+
+	dwc3_cache_hwparams(dwc);
+	dwc3_core_num_eps(dwc);
+
+	_dev_data->flis_reg =
+		ioremap_nocache(APBFC_EXIOTG3_MISC0_REG, 4);
+
+	ret = dwc3_alloc_event_buffers(dwc, DWC3_EVENT_BUFFERS_SIZE);
+	if (ret) {
+		dev_err(dwc->dev, "failed to allocate event buffers\n");
+		ret = -ENOMEM;
+		goto err0;
+	}
+
+	/*
+	* Not use irq thread, because irqthread has negative impact
+	* on usb performance, especially for usb network performance.
+	*/
+	dwc->quirks_disable_irqthread = 1;
+
+	usb_phy = usb_get_phy(USB_PHY_TYPE_USB2);
+	otg = container_of(usb_phy, struct dwc_otg2, usb2_phy);
+	otg->start_device = dwc3_start_peripheral;
+	otg->stop_device = dwc3_stop_peripheral;
+	otg->vbus_draw = dwc3_vbus_draw;
+	usb_put_phy(usb_phy);
+	dwc->is_otg = 1;
+
+	dwc3_set_mode(dwc, DWC3_GCTL_PRTCAP_DEVICE);
+	ret = dwc3_gadget_init(dwc);
+	if (ret) {
+		dev_err(dev, "failed to initialize gadget\n");
+		goto err0;
+	}
+	dwc->gadget.ops = &dwc3_device_gadget_ops;
+	dwc->gadget.is_otg = 1;
+
+	dwc->dr_mode = USB_DR_MODE_PERIPHERAL;
+
+	ret = dwc3_debugfs_init(dwc);
+	if (ret) {
+		dev_err(dev, "failed to initialize debugfs\n");
+		goto err1;
+	}
+
+	pm_runtime_allow(dev);
+	pm_runtime_put(dev);
+
+	return 0;
+
+err1:
+	dwc3_gadget_exit(dwc);
+
+err0:
+	dwc3_free_event_buffers(dwc);
+
+	return ret;
+}
+
+static int dwc3_device_intel_remove(struct platform_device *pdev)
+{
+	iounmap(_dev_data->flis_reg);
+
+	dwc3_remove(pdev);
+
+	kfree(_dev_data);
+	_dev_data = NULL;
+
+	return 0;
+}
+
+#ifdef CONFIG_PM_RUNTIME
+static const struct dev_pm_ops dwc3_device_pm_ops = {
+	.runtime_suspend	= dwc3_runtime_suspend,
+	.runtime_resume		= dwc3_runtime_resume,
+};
+#define DWC3_DEVICE_PM_OPS	(&dwc3_device_pm_ops)
+#else
+#define DWC3_DEVICE_PM_OPS	NULL
+#endif
+
+static struct platform_driver dwc3_device_intel_driver = {
+	.probe		= dwc3_device_intel_probe,
+	.remove		= dwc3_device_intel_remove,
+	.driver		= {
+		.name	= "dwc3-device",
+		.of_match_table	= of_match_ptr(of_dwc3_match),
+		.pm	= DWC3_DEVICE_PM_OPS,
+	},
+};
+
+module_platform_driver(dwc3_device_intel_driver);
+
+MODULE_ALIAS("platform:dwc3");
+MODULE_AUTHOR("Felipe Balbi <balbi@ti.com>");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("DesignWare USB3 DRD Controller Driver");
diff --git a/drivers/usb/dwc3/dwc3-host-intel.c b/drivers/usb/dwc3/dwc3-host-intel.c
new file mode 100644
index 0000000..05ef0aa
--- /dev/null
+++ b/drivers/usb/dwc3/dwc3-host-intel.c
@@ -0,0 +1,724 @@
+/*
+ * Copyright (C) 2012 Intel Corp.
+ * Author: Yu Wang
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/pm_runtime.h>
+#include <linux/usb/otg.h>
+#include <linux/platform_device.h>
+#include <linux/usb/dwc3-intel-mid.h>
+#include "../host/xhci.h"
+#include "core.h"
+#include "otg.h"
+
+#define WAIT_DISC_EVENT_COMPLETE_TIMEOUT 5 /* 100ms */
+
+static int otg_irqnum;
+
+static int dwc3_start_host(struct usb_hcd *hcd);
+static int dwc3_stop_host(struct usb_hcd *hcd);
+static struct platform_driver dwc3_xhci_driver;
+
+static void xhci_dwc3_quirks(struct device *dev, struct xhci_hcd *xhci)
+{
+	/*
+	 * As of now platform drivers don't provide MSI support so we ensure
+	 * here that the generic code does not try to make a pci_dev from our
+	 * dev struct in order to setup MSI
+	 *
+	 * Synopsys DWC3 controller will generate PLC when link transfer to
+	 * compliance/loopback mode.
+	 */
+	xhci->quirks |= XHCI_PLAT;
+}
+
+/* called during probe() after chip reset completes */
+static int xhci_dwc3_setup(struct usb_hcd *hcd)
+{
+	return xhci_gen_setup(hcd, xhci_dwc3_quirks);
+}
+
+static int xhci_dwc_bus_resume(struct usb_hcd *hcd)
+{
+	int ret;
+
+	/* before resume bus, delay 1ms to waiting core stable */
+	mdelay(1);
+
+	ret = xhci_bus_resume(hcd);
+	return ret;
+}
+
+static const struct hc_driver xhci_dwc_hc_driver = {
+	.description =		"dwc-xhci",
+	.product_desc =		"xHCI Host Controller",
+	.hcd_priv_size =	sizeof(struct xhci_hcd *),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq =			xhci_irq,
+	.flags =		HCD_MEMORY | HCD_USB3 | HCD_SHARED,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset =		xhci_dwc3_setup,
+	.start =		xhci_run,
+	.stop =			xhci_stop,
+	.shutdown =		xhci_shutdown,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue =		xhci_urb_enqueue,
+	.urb_dequeue =		xhci_urb_dequeue,
+	.alloc_dev =		xhci_alloc_dev,
+	.free_dev =		xhci_free_dev,
+	.alloc_streams =	xhci_alloc_streams,
+	.free_streams =		xhci_free_streams,
+	.add_endpoint =		xhci_add_endpoint,
+	.drop_endpoint =	xhci_drop_endpoint,
+	.endpoint_reset =	xhci_endpoint_reset,
+	.check_bandwidth =	xhci_check_bandwidth,
+	.reset_bandwidth =	xhci_reset_bandwidth,
+	.address_device =	xhci_address_device,
+	.update_hub_device =	xhci_update_hub_device,
+	.reset_device =		xhci_discover_or_reset_device,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number =	xhci_get_frame,
+
+	/* Root hub support */
+	.hub_control =		xhci_hub_control,
+	.hub_status_data =	xhci_hub_status_data,
+	.bus_suspend =		xhci_bus_suspend,
+	.bus_resume =		xhci_dwc_bus_resume,
+};
+
+static int if_usb_devices_connected(struct xhci_hcd *xhci)
+{
+	struct usb_device		*usb_dev;
+	int i, connected_devices = 0;
+
+	if (!xhci)
+		return -EINVAL;
+
+	usb_dev = xhci->main_hcd->self.root_hub;
+	for (i = 1; i <= usb_dev->maxchild; ++i) {
+		if (usb_hub_find_child(usb_dev, i))
+			connected_devices++;
+	}
+
+	usb_dev = xhci->shared_hcd->self.root_hub;
+	for (i = 1; i <= usb_dev->maxchild; ++i) {
+		if (usb_hub_find_child(usb_dev, i))
+			connected_devices++;
+	}
+
+	if (connected_devices)
+		return 1;
+
+	return 0;
+}
+
+static void dwc_xhci_enable_phy_auto_resume(struct usb_hcd *hcd, bool enable)
+{
+	u32 val;
+
+	val = readl(hcd->regs + GUSB2PHYCFG0);
+	val |= GUSB2PHYCFG_ULPI_EXT_VBUS_DRV;
+	if (enable)
+		val |= GUSB2PHYCFG_ULPI_AUTO_RESUME;
+	else
+		val &= ~GUSB2PHYCFG_ULPI_AUTO_RESUME;
+	writel(val, hcd->regs + GUSB2PHYCFG0);
+}
+
+static void dwc_xhci_enable_phy_suspend(struct usb_hcd *hcd, bool enable)
+{
+	u32 val;
+
+	val = readl(hcd->regs + GUSB3PIPECTL0);
+	if (enable)
+		val |= GUSB3PIPECTL_SUS_EN;
+	else
+		val &= ~GUSB3PIPECTL_SUS_EN;
+	writel(val, hcd->regs + GUSB3PIPECTL0);
+
+	val = readl(hcd->regs + GUSB2PHYCFG0);
+	if (enable)
+		val |= GUSB2PHYCFG_SUS_PHY;
+	else
+		val &= ~GUSB2PHYCFG_SUS_PHY;
+	writel(val, hcd->regs + GUSB2PHYCFG0);
+}
+
+static void dwc_silicon_wa(struct usb_hcd *hcd)
+{
+	void __iomem *addr;
+	u32 val;
+
+	/* Clear GUCTL bit 15 as workaround of DWC controller Bugs
+	 * This Bug cause the xHCI driver does not see any
+	 * transfer complete events for certain EP after exit
+	 * from hibernation mode.*/
+	val = readl(hcd->regs + GUCTL);
+	val &= ~GUCTL_CMDEVADDR;
+	writel(val, hcd->regs + GUCTL);
+
+	/* Disable OTG3-EXI interface by default. It is one
+	 * workaround for silicon BUG. It will cause transfer
+	 * failed on EP#8 of any USB device.
+	 */
+	addr = ioremap_nocache(APBFC_EXIOTG3_MISC0_REG, 4);
+	val = readl(addr);
+	val |= (1 << 3);
+	writel(val, addr);
+	iounmap(addr);
+}
+
+static void dwc_core_reset(struct usb_hcd *hcd)
+{
+	u32 val;
+
+	val = readl(hcd->regs + GCTL);
+	val |= GCTL_CORESOFTRESET;
+	writel(val, hcd->regs + GCTL);
+
+	val = readl(hcd->regs + GUSB3PIPECTL0);
+	val |= GUSB3PIPECTL_PHYSOFTRST;
+	writel(val, hcd->regs + GUSB3PIPECTL0);
+
+	val = readl(hcd->regs + GUSB2PHYCFG0);
+	val |= GUSB2PHYCFG_PHYSOFTRST;
+	writel(val, hcd->regs + GUSB2PHYCFG0);
+
+	msleep(100);
+
+	val = readl(hcd->regs + GUSB3PIPECTL0);
+	val &= ~GUSB3PIPECTL_PHYSOFTRST;
+	writel(val, hcd->regs + GUSB3PIPECTL0);
+
+	val = readl(hcd->regs + GUSB2PHYCFG0);
+	val &= ~GUSB2PHYCFG_PHYSOFTRST;
+	writel(val, hcd->regs + GUSB2PHYCFG0);
+
+	msleep(20);
+
+	val = readl(hcd->regs + GCTL);
+	val &= ~GCTL_CORESOFTRESET;
+	writel(val, hcd->regs + GCTL);
+}
+
+/*
+ * On MERR platform, the suspend clock is 19.2MHz.
+ * Hence PwrDnScale = 19200 / 16 = 1200 (= 0x4B0).
+ * To account for possible jitter of suspend clock and to have margin,
+ * So recommend it to be set to 1250 (= 0x4E2).
+ * */
+static void dwc_set_ssphy_p3_clockrate(struct usb_hcd *hcd)
+{
+	u32 gctl;
+
+	gctl = readl(hcd->regs + GCTL);
+	gctl &= ~GCTL_PWRDNSCALE_MASK;
+	gctl |= GCTL_PWRDNSCALE(0x4E2);
+	writel(gctl, hcd->regs + GCTL);
+}
+
+static ssize_t
+show_pm_get(struct device *_dev, struct device_attribute *attr, char *buf)
+{
+	struct platform_device		*pdev = to_platform_device(_dev);
+	struct usb_hcd		*hcd = platform_get_drvdata(pdev);
+
+	pm_runtime_put(hcd->self.controller);
+	return 0;
+
+}
+static ssize_t store_pm_get(struct device *_dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct platform_device		*pdev = to_platform_device(_dev);
+	struct usb_hcd		*hcd = platform_get_drvdata(pdev);
+
+	pm_runtime_get(hcd->self.controller);
+	return count;
+
+}
+static DEVICE_ATTR(pm_get, S_IRUGO|S_IWUSR|S_IWGRP,
+			show_pm_get, store_pm_get);
+
+static void dwc_set_host_mode(struct usb_hcd *hcd)
+{
+	writel(0x45801000, hcd->regs + GCTL);
+
+	msleep(20);
+}
+
+static int dwc3_start_host(struct usb_hcd *hcd)
+{
+	int ret = -EINVAL;
+	struct xhci_hcd *xhci;
+	struct usb_hcd *xhci_shared_hcd;
+
+	if (!hcd)
+		return ret;
+
+	if (hcd->rh_registered) {
+		dev_dbg(hcd->self.controller,
+				"%s() - Already registered", __func__);
+		return 0;
+	}
+
+	pm_runtime_get_sync(hcd->self.controller);
+
+	dwc_core_reset(hcd);
+	dwc_silicon_wa(hcd);
+	dwc_set_host_mode(hcd);
+	dwc_set_ssphy_p3_clockrate(hcd);
+
+	/* Clear the hcd->flags.
+	 * To prevent incorrect flags set during last time. */
+	hcd->flags = 0;
+
+	ret = usb_add_hcd(hcd, otg_irqnum, IRQF_SHARED);
+	if (ret)
+		return -EINVAL;
+
+	xhci = hcd_to_xhci(hcd);
+	xhci->shared_hcd = usb_create_shared_hcd(&xhci_dwc_hc_driver,
+		   hcd->self.controller, dev_name(hcd->self.controller), hcd);
+	if (!xhci->shared_hcd) {
+		ret = -ENOMEM;
+		goto dealloc_usb2_hcd;
+	}
+
+	xhci->quirks |= XHCI_PLAT;
+
+	/* Set the xHCI pointer before xhci_pci_setup() (aka hcd_driver.reset)
+	 * is called by usb_add_hcd().
+	 */
+	*((struct xhci_hcd **) xhci->shared_hcd->hcd_priv) = xhci;
+
+	xhci->shared_hcd->regs = hcd->regs;
+
+	xhci->shared_hcd->rsrc_start = hcd->rsrc_start;
+	xhci->shared_hcd->rsrc_len = hcd->rsrc_len;
+
+	ret = usb_add_hcd(xhci->shared_hcd, otg_irqnum, IRQF_SHARED);
+	if (ret)
+		goto put_usb3_hcd;
+
+	pm_runtime_put(hcd->self.controller);
+
+	ret = device_create_file(hcd->self.controller, &dev_attr_pm_get);
+	if (ret < 0)
+		dev_err(hcd->self.controller,
+			"Can't register sysfs attribute: %d\n", ret);
+
+	dwc3_xhci_driver.shutdown = usb_hcd_platform_shutdown;
+
+	return ret;
+
+put_usb3_hcd:
+	if (xhci->shared_hcd) {
+		xhci_shared_hcd = xhci->shared_hcd;
+		usb_remove_hcd(xhci_shared_hcd);
+		usb_put_hcd(xhci_shared_hcd);
+	}
+
+dealloc_usb2_hcd:
+	local_irq_disable();
+	usb_hcd_irq(0, hcd);
+	local_irq_enable();
+	usb_remove_hcd(hcd);
+
+	kfree(xhci);
+	*((struct xhci_hcd **) hcd->hcd_priv) = NULL;
+
+	pm_runtime_put(hcd->self.controller);
+	return ret;
+}
+
+static int dwc3_stop_host(struct usb_hcd *hcd)
+{
+	int count = 0;
+	struct xhci_hcd *xhci;
+	struct usb_hcd *xhci_shared_hcd;
+
+	if (!hcd)
+		return -EINVAL;
+
+	xhci = hcd_to_xhci(hcd);
+
+	pm_runtime_get_sync(hcd->self.controller);
+
+	/* When plug out micro A cable, there will be two flows be executed.
+	 * The first one is xHCI controller get disconnect event. The
+	 * second one is PMIC get ID change event. During these events
+	 * handling, they both try to call usb_disconnect. Then met some
+	 * conflicts and cause kernel panic.
+	 * So treat disconnect event as first priority, handle the ID change
+	 * event until disconnect event handled done.*/
+	while (if_usb_devices_connected(xhci)) {
+		msleep(20);
+		if (count++ > WAIT_DISC_EVENT_COMPLETE_TIMEOUT)
+			break;
+	};
+	dwc3_xhci_driver.shutdown = NULL;
+
+	if (xhci->shared_hcd) {
+		xhci_shared_hcd = xhci->shared_hcd;
+		usb_remove_hcd(xhci_shared_hcd);
+		usb_put_hcd(xhci_shared_hcd);
+	}
+
+	usb_remove_hcd(hcd);
+
+	kfree(xhci);
+	*((struct xhci_hcd **) hcd->hcd_priv) = NULL;
+
+	dwc_xhci_enable_phy_suspend(hcd, false);
+
+	pm_runtime_put(hcd->self.controller);
+	device_remove_file(hcd->self.controller, &dev_attr_pm_get);
+	return 0;
+}
+static int xhci_dwc_drv_probe(struct platform_device *pdev)
+{
+	struct dwc_otg2 *otg;
+	struct usb_phy *usb_phy;
+	struct dwc_device_par *pdata;
+	struct usb_hcd *hcd;
+	struct resource *res;
+	int retval = 0;
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	pr_debug("initializing FSL-SOC USB Controller\n");
+
+	/* Need platform data for setup */
+	pdata = (struct dwc_device_par *)pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev,
+			"No platform data for %s.\n", dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&pdev->dev,
+			"Found HC with no IRQ. Check %s setup!\n",
+			dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+	otg_irqnum = res->start;
+
+	hcd = usb_create_hcd(&xhci_dwc_hc_driver,
+			&pdev->dev, dev_name(&pdev->dev));
+	if (!hcd) {
+		retval = -ENOMEM;
+		return retval;
+	}
+
+	hcd->regs = pdata->io_addr;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev,
+			"Found HC with no IRQ. Check %s setup!\n",
+			dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+	hcd->rsrc_start = res->start;
+	hcd->rsrc_len = res->end - res->start;
+
+	usb_phy = usb_get_phy(USB_PHY_TYPE_USB2);
+	if (usb_phy)
+		otg_set_host(usb_phy->otg, &hcd->self);
+
+	otg = container_of(usb_phy->otg, struct dwc_otg2, otg);
+	if (otg) {
+		otg->start_host = dwc3_start_host;
+		otg->stop_host = dwc3_stop_host;
+	}
+
+
+	usb_put_phy(usb_phy);
+
+	/* Enable wakeup irq */
+	hcd->has_wakeup_irq = 1;
+
+	platform_set_drvdata(pdev, hcd);
+	pm_runtime_enable(hcd->self.controller);
+
+	return retval;
+}
+
+static int xhci_dwc_drv_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct usb_phy *usb_phy;
+	struct xhci_hcd *xhci = hcd_to_xhci(hcd);
+
+	usb_phy = usb_get_phy(USB_PHY_TYPE_USB2);
+	otg_set_host(usb_phy->otg, NULL);
+	usb_put_phy(usb_phy);
+
+	if (xhci)
+		dwc3_stop_host(hcd);
+	usb_put_hcd(hcd);
+
+	pm_runtime_disable(hcd->self.controller);
+	pm_runtime_set_suspended(hcd->self.controller);
+	return 0;
+}
+
+
+#ifdef CONFIG_PM
+
+#ifdef CONFIG_PM_RUNTIME
+/*
+ * Do nothing in runtime pm callback.
+ * On HVP platform, if make controller go to hibernation mode.
+ * controller will not send IRQ until restore status which
+ * implement in pm runtime resume callback. So there is no
+ * any one can trigger pm_runtime_get to resume USB3 device.
+ * This issue need to continue investigate. So just implement SW logic at here.
+ */
+static int dwc_hcd_runtime_idle(struct device *dev)
+{
+	return 0;
+}
+
+/* dwc_hcd_suspend_common and dwc_hcd_resume_common are refer to
+ * suspend_common and resume_common in usb core.
+ * Because the usb core function just support PCI device.
+ * So re-write them in here to support platform devices.
+ */
+static int dwc_hcd_suspend_common(struct device *dev)
+{
+	struct platform_device		*pdev = to_platform_device(dev);
+	struct usb_hcd		*hcd = platform_get_drvdata(pdev);
+	struct xhci_hcd		*xhci = hcd_to_xhci(hcd);
+	int			retval = 0;
+	u32 data = 0;
+
+	if (!xhci) {
+		dev_dbg(dev, "%s: host already stop!\n", __func__);
+		return 0;
+	}
+
+	/* Root hub suspend should have stopped all downstream traffic,
+	 * and all bus master traffic.  And done so for both the interface
+	 * and the stub usb_device (which we check here).  But maybe it
+	 * didn't; writing sysfs power/state files ignores such rules...
+	 */
+	if (HCD_RH_RUNNING(hcd)) {
+		dev_warn(dev, "Root hub is not suspended\n");
+		return -EBUSY;
+	}
+	if (hcd->shared_hcd) {
+		hcd = hcd->shared_hcd;
+		if (HCD_RH_RUNNING(hcd)) {
+			dev_warn(dev, "Secondary root hub is not suspended\n");
+			return -EBUSY;
+		}
+	}
+
+	if (!HCD_DEAD(hcd)) {
+		/* Optimization: Don't suspend if a root-hub wakeup is
+		 * pending and it would cause the HCD to wake up anyway.
+		 */
+		if (HCD_WAKEUP_PENDING(hcd))
+			return -EBUSY;
+		if (hcd->shared_hcd &&
+				HCD_WAKEUP_PENDING(hcd->shared_hcd))
+			return -EBUSY;
+		if (hcd->state != HC_STATE_SUSPENDED ||
+				xhci->shared_hcd->state != HC_STATE_SUSPENDED)
+			retval = -EINVAL;
+
+		if (!retval) {
+			/* The auto-resume is diabled by default. Need enable it
+			 * if there have valid connection. To ensure that when
+			 * device resumes, host does resume reflect within
+			 * 900 usec as in USB spec.
+			 */
+			if (if_usb_devices_connected(xhci) == 1)
+				dwc_xhci_enable_phy_auto_resume(
+						xhci->main_hcd, true);
+
+			/* Ensure that suspend enable are set for
+			 * USB2 and USB3 PHY
+			 */
+			dwc_xhci_enable_phy_suspend(hcd, true);
+
+			data = readl(hcd->regs + GCTL);
+			data |= GCTL_GBL_HIBERNATION_EN;
+			writel(data, hcd->regs + GCTL);
+			dev_dbg(hcd->self.controller, "set xhci hibernation enable!\n");
+			retval = xhci_suspend(xhci, device_may_wakeup(dev));
+		}
+
+		/* Check again in case wakeup raced with pci_suspend */
+		if ((retval == 0 && HCD_WAKEUP_PENDING(hcd)) ||
+				(retval == 0 && hcd->shared_hcd &&
+				 HCD_WAKEUP_PENDING(hcd->shared_hcd))) {
+			xhci_resume(xhci, false);
+			retval = -EBUSY;
+		}
+		if (retval)
+			return retval;
+	}
+
+	synchronize_irq(otg_irqnum);
+
+	return retval;
+
+}
+
+static int dwc_hcd_resume_common(struct device *dev)
+{
+	struct platform_device		*pdev = to_platform_device(dev);
+	struct usb_hcd		*hcd = platform_get_drvdata(pdev);
+	struct xhci_hcd		*xhci = hcd_to_xhci(hcd);
+	int			retval = 0;
+
+	if (!xhci)
+		return 0;
+
+	if (HCD_RH_RUNNING(hcd) ||
+			(hcd->shared_hcd &&
+			 HCD_RH_RUNNING(hcd->shared_hcd))) {
+		dev_dbg(dev, "can't resume, not suspended!\n");
+		return 0;
+	}
+
+	if (!HCD_DEAD(hcd)) {
+		retval = xhci_resume(xhci, false);
+		if (retval) {
+			dev_err(dev, "PCI post-resume error %d!\n", retval);
+			if (hcd->shared_hcd)
+				usb_hc_died(hcd->shared_hcd);
+			usb_hc_died(hcd);
+		}
+	}
+
+	dev_dbg(dev, "hcd_pci_runtime_resume: %d\n", retval);
+
+	return retval;
+}
+
+static int dwc_hcd_runtime_suspend(struct device *dev)
+{
+	int retval;
+	struct platform_device      *pdev = to_platform_device(dev);
+	struct usb_hcd      *hcd = platform_get_drvdata(pdev);
+
+	retval = dwc_hcd_suspend_common(dev);
+
+	if (retval)
+		dwc_xhci_enable_phy_auto_resume(
+			hcd, false);
+
+	dev_dbg(dev, "hcd_pci_runtime_suspend: %d\n", retval);
+	return retval;
+}
+
+static int dwc_hcd_runtime_resume(struct device *dev)
+{
+	int retval;
+	struct platform_device      *pdev = to_platform_device(dev);
+	struct usb_hcd      *hcd = platform_get_drvdata(pdev);
+
+	dwc_xhci_enable_phy_auto_resume(
+			hcd, false);
+
+	retval = dwc_hcd_resume_common(dev);
+	dev_dbg(dev, "hcd_pci_runtime_resume: %d\n", retval);
+
+	return retval;
+}
+#else
+#define dwc_hcd_runtime_idle NULL
+#define dwc_hcd_runtime_suspend NULL
+#define dwc_hcd_runtime_resume NULL
+#endif
+
+
+static int dwc_hcd_suspend(struct device *dev)
+{
+	int retval;
+	struct platform_device      *pdev = to_platform_device(dev);
+	struct usb_hcd      *hcd = platform_get_drvdata(pdev);
+
+	retval = dwc_hcd_suspend_common(dev);
+
+	if (retval)
+		dwc_xhci_enable_phy_auto_resume(
+			hcd, false);
+
+	dev_dbg(dev, "hcd_pci_runtime_suspend: %d\n", retval);
+	return retval;
+}
+
+static int dwc_hcd_resume(struct device *dev)
+{
+	int retval;
+	struct platform_device      *pdev = to_platform_device(dev);
+	struct usb_hcd      *hcd = platform_get_drvdata(pdev);
+
+	dwc_xhci_enable_phy_auto_resume(
+			hcd, false);
+
+	retval = dwc_hcd_resume_common(dev);
+	dev_dbg(dev, "hcd_pci_runtime_resume: %d\n", retval);
+
+	return retval;
+}
+
+static const struct dev_pm_ops dwc_usb_hcd_pm_ops = {
+	.runtime_suspend = dwc_hcd_runtime_suspend,
+	.runtime_resume	= dwc_hcd_runtime_resume,
+	.runtime_idle	= dwc_hcd_runtime_idle,
+	.suspend	=	dwc_hcd_suspend,
+	.resume		=	dwc_hcd_resume,
+};
+#endif
+
+static struct platform_driver dwc3_xhci_driver = {
+	.probe = xhci_dwc_drv_probe,
+	.remove = xhci_dwc_drv_remove,
+	.driver = {
+		.name = "dwc3-host",
+#ifdef CONFIG_PM
+		.pm = &dwc_usb_hcd_pm_ops,
+#endif
+	},
+};
diff --git a/drivers/usb/dwc3/dwc3-intel-mrfl.c b/drivers/usb/dwc3/dwc3-intel-mrfl.c
new file mode 100644
index 0000000..981c841
--- /dev/null
+++ b/drivers/usb/dwc3/dwc3-intel-mrfl.c
@@ -0,0 +1,992 @@
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/usb/otg.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/freezer.h>
+#include <linux/delay.h>
+#include <linux/kthread.h>
+#include <linux/version.h>
+
+#include <linux/usb.h>
+#include <linux/usb/hcd.h>
+#include <linux/usb/gadget.h>
+#include <linux/usb/dwc3-intel-mid.h>
+#include <asm/intel_scu_pmic.h>
+#include "otg.h"
+
+#define VERSION "2.10a"
+
+static int otg_id = -1;
+static int enable_usb_phy(struct dwc_otg2 *otg, bool on_off);
+static int dwc3_intel_notify_charger_type(struct dwc_otg2 *otg,
+		enum power_supply_charger_event event);
+static struct power_supply_cable_props cap_record;
+
+static int charger_detect_enable(struct dwc_otg2 *otg)
+{
+	struct intel_dwc_otg_pdata *data;
+
+	if (!otg || !otg->otg_data)
+		return 0;
+
+	data = (struct intel_dwc_otg_pdata *)otg->otg_data;
+
+	return data->charger_detect_enable;
+}
+
+static int is_basin_cove(struct dwc_otg2 *otg)
+{
+	struct intel_dwc_otg_pdata *data;
+	if (!otg || !otg->otg_data)
+		return -EINVAL;
+
+	data = (struct intel_dwc_otg_pdata *)otg->otg_data;
+
+	return data->pmic_type == BASIN_COVE;
+}
+
+static int is_hybridvp(struct dwc_otg2 *otg)
+{
+	struct intel_dwc_otg_pdata *data;
+	if (!otg || !otg->otg_data)
+		return -EINVAL;
+
+	data = (struct intel_dwc_otg_pdata *)otg->otg_data;
+
+	return data->is_hvp;
+}
+
+static void usb2phy_eye_optimization(struct dwc_otg2 *otg)
+{
+	struct usb_phy *phy;
+
+	phy = usb_get_phy(USB_PHY_TYPE_USB2);
+	if (!phy)
+		return;
+
+	/* Set 0x7f for better quality in eye diagram
+	 * It means ZHSDRV = 0b11 and IHSTX = 0b1111*/
+	usb_phy_io_write(phy, 0x7f, TUSB1211_VENDOR_SPECIFIC1_SET);
+
+	usb_put_phy(phy);
+}
+
+
+/* As we use SW mode to do charger detection, need to notify HW
+ * the result SW get, charging port or not */
+static int dwc_otg_charger_hwdet(bool enable)
+{
+	int				retval;
+	struct usb_phy *phy;
+	struct dwc_otg2 *otg = dwc3_get_otg();
+
+	/* Just return if charger detection is not enabled */
+	if (!charger_detect_enable(otg))
+		return 0;
+
+	phy = usb_get_phy(USB_PHY_TYPE_USB2);
+	if (!phy)
+		return -ENODEV;
+
+	if (enable) {
+		retval = usb_phy_io_write(phy, PWCTRL_HWDETECT,
+				TUSB1211_POWER_CONTROL_SET);
+		if (retval)
+			return retval;
+		otg_dbg(otg, "set HWDETECT\n");
+	} else {
+		retval = usb_phy_io_write(phy, PWCTRL_HWDETECT,
+				TUSB1211_POWER_CONTROL_CLR);
+		if (retval)
+			return retval;
+		otg_dbg(otg, "clear HWDETECT\n");
+	}
+	usb_put_phy(phy);
+
+	return 0;
+}
+
+static enum power_supply_charger_cable_type
+			basin_cove_aca_check(struct dwc_otg2 *otg)
+{
+	u8 rarbrc;
+	int ret;
+	enum power_supply_charger_cable_type type =
+		POWER_SUPPLY_CHARGER_TYPE_NONE;
+
+	ret = intel_scu_ipc_update_register(PMIC_USBIDCTRL,
+			USBIDCTRL_ACA_DETEN_D1,
+			USBIDCTRL_ACA_DETEN_D1);
+	if (ret)
+		otg_err(otg, "Fail to enable ACA&ID detection logic\n");
+
+	/* Wait >66.1ms (for TCHGD_SERX_DEB) */
+	msleep(66);
+
+	/* Read decoded RID value */
+	ret = intel_scu_ipc_ioread8(PMIC_USBIDSTS, &rarbrc);
+	if (ret)
+		otg_err(otg, "Fail to read decoded RID value\n");
+	rarbrc &= USBIDSTS_ID_RARBRC_STS(3);
+	rarbrc >>= 1;
+
+	/* If ID_RARBRC_STS==01: ACA-Dock detected
+	 * If ID_RARBRC_STS==00: MHL detected
+	 */
+	if (rarbrc == 1) {
+		/* ACA-Dock */
+		type = POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK;
+	} else if (!rarbrc) {
+		/* MHL */
+		type = POWER_SUPPLY_CHARGER_TYPE_MHL;
+	}
+
+	ret = intel_scu_ipc_update_register(PMIC_USBIDCTRL,
+			USBIDCTRL_ACA_DETEN_D1,
+			0);
+	if (ret)
+		otg_err(otg, "Fail to enable ACA&ID detection logic\n");
+
+	return type;
+}
+
+static enum power_supply_charger_cable_type
+		dwc3_intel_aca_check(struct dwc_otg2 *otg)
+{
+	return basin_cove_aca_check(otg);
+}
+
+static ssize_t store_otg_id(struct device *_dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long flags;
+	struct dwc_otg2 *otg = dwc3_get_otg();
+
+	if (!otg)
+		return 0;
+	if (count != 2) {
+		otg_err(otg, "return EINVAL\n");
+		return -EINVAL;
+	}
+
+	if (count > 0 && buf[count-1] == '\n')
+		((char *) buf)[count-1] = 0;
+
+	switch (buf[0]) {
+	case 'a':
+	case 'A':
+		otg_dbg(otg, "Change ID to A\n");
+		otg->user_events |= USER_ID_A_CHANGE_EVENT;
+		spin_lock_irqsave(&otg->lock, flags);
+		dwc3_wakeup_otg_thread(otg);
+		otg_id = 0;
+		spin_unlock_irqrestore(&otg->lock, flags);
+		return count;
+	case 'b':
+	case 'B':
+		otg_dbg(otg, "Change ID to B\n");
+		otg->user_events |= USER_ID_B_CHANGE_EVENT;
+		spin_lock_irqsave(&otg->lock, flags);
+		dwc3_wakeup_otg_thread(otg);
+		otg_id = 1;
+		spin_unlock_irqrestore(&otg->lock, flags);
+		return count;
+	default:
+		otg_err(otg, "Just support change ID to A!\n");
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+static ssize_t
+show_otg_id(struct device *_dev, struct device_attribute *attr, char *buf)
+{
+	char				*next;
+	unsigned			size, t;
+
+	next = buf;
+	size = PAGE_SIZE;
+
+	t = scnprintf(next, size,
+		"USB OTG ID: %s\n",
+		(otg_id ? "B" : "A")
+		);
+	size -= t;
+	next += t;
+
+	return PAGE_SIZE - size;
+}
+
+static DEVICE_ATTR(otg_id, S_IRUGO|S_IWUSR|S_IWGRP,
+			show_otg_id, store_otg_id);
+
+static void set_sus_phy(struct dwc_otg2 *otg, int bit)
+{
+	u32 data = 0;
+
+	data = otg_read(otg, GUSB2PHYCFG0);
+	if (bit)
+		data |= GUSB2PHYCFG_SUS_PHY;
+	else
+		data &= ~GUSB2PHYCFG_SUS_PHY;
+
+	otg_write(otg, GUSB2PHYCFG0, data);
+
+	data = otg_read(otg, GUSB3PIPECTL0);
+	if (bit)
+		data |= GUSB3PIPECTL_SUS_EN;
+	else
+		data &= ~GUSB3PIPECTL_SUS_EN;
+	otg_write(otg, GUSB3PIPECTL0, data);
+}
+
+int dwc3_intel_platform_init(struct dwc_otg2 *otg)
+{
+	u32 gctl;
+	int retval;
+
+	otg_info(otg, "De-assert USBRST# to enable PHY\n");
+	retval = intel_scu_ipc_iowrite8(PMIC_USBPHYCTRL,
+			PMIC_USBPHYCTRL_D0);
+	if (retval)
+		otg_err(otg, "Fail to de-assert USBRST#\n");
+
+	/* Don't let phy go to suspend mode, which
+	 * will cause FS/LS devices enum failed in host mode.
+	 */
+	set_sus_phy(otg, 0);
+
+	retval = device_create_file(otg->dev, &dev_attr_otg_id);
+	if (retval < 0) {
+		otg_dbg(otg,
+			"Can't register sysfs attribute: %d\n", retval);
+		return -ENOMEM;
+	}
+
+	otg_dbg(otg, "\n");
+	otg_write(otg, OEVTEN, 0);
+	otg_write(otg, OCTL, 0);
+	gctl = otg_read(otg, GCTL);
+	gctl |= GCTL_PRT_CAP_DIR_OTG << GCTL_PRT_CAP_DIR_SHIFT;
+	otg_write(otg, GCTL, gctl);
+
+	return 0;
+}
+
+/* Disable auto-resume feature for USB2 PHY. This is one
+ * silicon workaround. It will cause fabric timeout error
+ * for LS case after resume from hibernation */
+static void disable_phy_auto_resume(struct dwc_otg2 *otg)
+{
+	u32 data = 0;
+
+	data = otg_read(otg, GUSB2PHYCFG0);
+	data &= ~GUSB2PHYCFG_ULPI_AUTO_RESUME;
+	otg_write(otg, GUSB2PHYCFG0, data);
+}
+
+/* This function will control VUSBPHY to power gate/ungate USBPHY */
+static int enable_usb_phy(struct dwc_otg2 *otg, bool on_off)
+{
+	int ret;
+
+	if (on_off) {
+		ret = intel_scu_ipc_update_register(PMIC_VLDOCNT,
+				0xff, PMIC_VLDOCNT_VUSBPHYEN);
+		if (ret)
+			otg_err(otg, "Fail to enable VBUSPHY\n");
+
+		msleep(20);
+	} else {
+		ret = intel_scu_ipc_update_register(PMIC_VLDOCNT,
+				0x00, PMIC_VLDOCNT_VUSBPHYEN);
+		if (ret)
+			otg_err(otg, "Fail to disable VBUSPHY\n");
+	}
+
+	return 0;
+}
+
+int basin_cove_get_id(struct dwc_otg2 *otg)
+{
+	int ret, id = RID_UNKNOWN;
+	u8 idsts, pmic_id;
+
+	ret = intel_scu_ipc_update_register(PMIC_USBIDCTRL,
+			USBIDCTRL_ACA_DETEN_D1 | PMIC_USBPHYCTRL_D0,
+			USBIDCTRL_ACA_DETEN_D1 | PMIC_USBPHYCTRL_D0);
+	if (ret)
+		otg_err(otg, "Fail to enable ACA&ID detection logic\n");
+
+	mdelay(50);
+
+	ret = intel_scu_ipc_ioread8(PMIC_USBIDSTS, &idsts);
+	if (ret) {
+		otg_err(otg, "Fail to read id\n");
+		return id;
+	}
+
+	if (idsts & USBIDSTS_ID_FLOAT_STS)
+		id = RID_FLOAT;
+	else if (idsts & USBIDSTS_ID_RARBRC_STS(1))
+		id = RID_A;
+	else if (idsts & USBIDSTS_ID_RARBRC_STS(2))
+		id = RID_B;
+	else if (idsts & USBIDSTS_ID_RARBRC_STS(3))
+		id = RID_C;
+	else {
+		/* PMIC A0 reports ID_GND = 0 for RID_GND but PMIC B0 reports
+		*  ID_GND = 1 for RID_GND
+		*/
+		ret = intel_scu_ipc_ioread8(0x00, &pmic_id);
+		if (ret) {
+			otg_err(otg, "Fail to read PMIC ID register\n");
+		} else if (((pmic_id & VENDOR_ID_MASK) == BASIN_COVE_PMIC_ID) &&
+			((pmic_id & PMIC_MAJOR_REV) == PMIC_A0_MAJOR_REV)) {
+				if (idsts & USBIDSTS_ID_GND)
+					id = RID_GND;
+		} else {
+			if (!(idsts & USBIDSTS_ID_GND))
+				id = RID_GND;
+		}
+	}
+
+	ret = intel_scu_ipc_update_register(PMIC_USBIDCTRL,
+			USBIDCTRL_ACA_DETEN_D1 | PMIC_USBPHYCTRL_D0,
+			0);
+	if (ret)
+		otg_err(otg, "Fail to enable ACA&ID detection logic\n");
+
+	return id;
+}
+
+int dwc3_intel_get_id(struct dwc_otg2 *otg)
+{
+	return basin_cove_get_id(otg);
+}
+
+int dwc3_intel_b_idle(struct dwc_otg2 *otg)
+{
+	u32 gctl, tmp;
+
+	/* Disable hibernation mode by default */
+	gctl = otg_read(otg, GCTL);
+	gctl &= ~GCTL_GBL_HIBERNATION_EN;
+	otg_write(otg, GCTL, gctl);
+
+	/* Reset ADP related registers */
+	otg_write(otg, ADPCFG, 0);
+	otg_write(otg, ADPCTL, 0);
+	otg_write(otg, ADPEVTEN, 0);
+	tmp = otg_read(otg, ADPEVT);
+	otg_write(otg, ADPEVT, tmp);
+
+	otg_write(otg, OCFG, 0);
+	otg_write(otg, OEVTEN, 0);
+	tmp = otg_read(otg, OEVT);
+	otg_write(otg, OEVT, tmp);
+	otg_write(otg, OCTL, OCTL_PERI_MODE);
+
+	/* Force config to device mode as default */
+	gctl = otg_read(otg, GCTL);
+	gctl &= ~GCTL_PRT_CAP_DIR;
+	gctl |= GCTL_PRT_CAP_DIR_DEV << GCTL_PRT_CAP_DIR_SHIFT;
+	otg_write(otg, GCTL, gctl);
+
+	if (!is_hybridvp(otg)) {
+		dwc_otg_charger_hwdet(false);
+		enable_usb_phy(otg, false);
+	}
+
+	mdelay(100);
+
+	return 0;
+}
+
+static int dwc3_intel_set_power(struct usb_phy *_otg,
+		unsigned ma)
+{
+	unsigned long flags;
+	struct dwc_otg2 *otg = dwc3_get_otg();
+	struct power_supply_cable_props cap;
+	struct intel_dwc_otg_pdata *data;
+
+	data = (struct intel_dwc_otg_pdata *)otg->otg_data;
+
+	if (otg->charging_cap.chrg_type ==
+			POWER_SUPPLY_CHARGER_TYPE_USB_CDP)
+		return 0;
+	else if (otg->charging_cap.chrg_type !=
+			POWER_SUPPLY_CHARGER_TYPE_USB_SDP) {
+		otg_err(otg, "%s: currently, chrg type is not SDP!\n",
+				__func__);
+		return -EINVAL;
+	}
+
+	if (ma == OTG_DEVICE_SUSPEND) {
+		spin_lock_irqsave(&otg->lock, flags);
+		cap.chrg_type = otg->charging_cap.chrg_type;
+		cap.ma = otg->charging_cap.ma;
+		cap.chrg_evt = POWER_SUPPLY_CHARGER_EVENT_SUSPEND;
+		spin_unlock_irqrestore(&otg->lock, flags);
+
+		/* mA is zero mean D+/D- opened cable.
+		 * If SMIP set, then notify 500mA.
+		 * Otherwise, notify 0mA.
+		*/
+		if (!cap.ma) {
+			if (data->charging_compliance) {
+				cap.ma = 500;
+				cap.chrg_evt =
+					POWER_SUPPLY_CHARGER_EVENT_CONNECT;
+			}
+		/* For standard SDP, if SMIP set, then ignore suspend */
+		} else if (data->charging_compliance)
+			return 0;
+		/* Stander SDP(cap.mA != 0) and SMIP not set.
+		 * Should send 0mA with SUSPEND event
+		 */
+		else
+			cap.ma = 0;
+
+		atomic_notifier_call_chain(&otg->usb2_phy.notifier,
+				USB_EVENT_CHARGER, &cap);
+		otg_dbg(otg, "Notify EM");
+		otg_dbg(otg, "POWER_SUPPLY_CHARGER_EVENT_SUSPEND\n");
+
+		return 0;
+	} else if (ma == OTG_DEVICE_RESUME) {
+		otg_dbg(otg, "Notify EM");
+		otg_dbg(otg, "POWER_SUPPLY_CHARGER_EVENT_CONNECT\n");
+		dwc3_intel_notify_charger_type(otg,
+				POWER_SUPPLY_CHARGER_EVENT_CONNECT);
+
+		return 0;
+	}
+
+	/* For SMIP set case, only need to report 500/900mA */
+	if (data->charging_compliance) {
+		if ((ma != OTG_USB2_500MA) &&
+				(ma != OTG_USB3_900MA))
+			return 0;
+	}
+
+	/* Covert macro to integer number*/
+	switch (ma) {
+	case OTG_USB2_100MA:
+		ma = 100;
+		break;
+	case OTG_USB3_150MA:
+		ma = 150;
+		break;
+	case OTG_USB2_500MA:
+		ma = 500;
+		break;
+	case OTG_USB3_900MA:
+		ma = 900;
+		break;
+	default:
+		otg_err(otg, "Device driver set invalid SDP current value!\n");
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&otg->lock, flags);
+	otg->charging_cap.ma = ma;
+	spin_unlock_irqrestore(&otg->lock, flags);
+
+	dwc3_intel_notify_charger_type(otg,
+			POWER_SUPPLY_CHARGER_EVENT_CONNECT);
+
+	return 0;
+}
+
+int dwc3_intel_enable_vbus(struct dwc_otg2 *otg, int enable)
+{
+	atomic_notifier_call_chain(&otg->usb2_phy.notifier,
+			USB_EVENT_DRIVE_VBUS, &enable);
+
+	return 0;
+}
+
+static int dwc3_intel_notify_charger_type(struct dwc_otg2 *otg,
+		enum power_supply_charger_event event)
+{
+	struct power_supply_cable_props cap;
+	int ret = 0;
+	unsigned long flags;
+
+	if (!charger_detect_enable(otg) &&
+		(otg->charging_cap.chrg_type !=
+		POWER_SUPPLY_CHARGER_TYPE_USB_SDP))
+		return 0;
+
+	if (event > POWER_SUPPLY_CHARGER_EVENT_DISCONNECT) {
+		otg_err(otg,
+		"%s: Invalid power_supply_charger_event!\n", __func__);
+		return -EINVAL;
+	}
+
+	if ((otg->charging_cap.chrg_type ==
+			POWER_SUPPLY_CHARGER_TYPE_USB_SDP) &&
+			((otg->charging_cap.ma != 0) &&
+			 (otg->charging_cap.ma != 100) &&
+			 (otg->charging_cap.ma != 150) &&
+			 (otg->charging_cap.ma != 500) &&
+			 (otg->charging_cap.ma != 900))) {
+		otg_err(otg, "%s: invalid SDP current!\n", __func__);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&otg->lock, flags);
+	cap.chrg_type = otg->charging_cap.chrg_type;
+	cap.ma = otg->charging_cap.ma;
+	cap.chrg_evt = event;
+	spin_unlock_irqrestore(&otg->lock, flags);
+
+	atomic_notifier_call_chain(&otg->usb2_phy.notifier, USB_EVENT_CHARGER,
+			&cap);
+
+	return ret;
+}
+
+static void dwc3_phy_soft_reset(struct dwc_otg2 *otg)
+{
+	u32 val;
+
+	val = otg_read(otg, GCTL);
+	val |= GCTL_CORESOFTRESET;
+	otg_write(otg, GCTL, val);
+
+	val = otg_read(otg, GUSB3PIPECTL0);
+	val |= GUSB3PIPECTL_PHYSOFTRST;
+	otg_write(otg, GUSB3PIPECTL0, val);
+
+	val = otg_read(otg, GUSB2PHYCFG0);
+	val |= GUSB2PHYCFG_PHYSOFTRST;
+	otg_write(otg, GUSB2PHYCFG0, val);
+
+	msleep(50);
+
+	val = otg_read(otg, GUSB3PIPECTL0);
+	val &= ~GUSB3PIPECTL_PHYSOFTRST;
+	otg_write(otg, GUSB3PIPECTL0, val);
+
+	val = otg_read(otg, GUSB2PHYCFG0);
+	val &= ~GUSB2PHYCFG_PHYSOFTRST;
+	otg_write(otg, GUSB2PHYCFG0, val);
+
+	msleep(100);
+
+	val = otg_read(otg, GCTL);
+	val &= ~GCTL_CORESOFTRESET;
+	otg_write(otg, GCTL, val);
+}
+
+static enum power_supply_charger_cable_type
+			dwc3_intel_get_charger_type(struct dwc_otg2 *otg)
+{
+	int ret;
+	struct usb_phy *phy;
+	u8 val, vdat_det, chgd_serx_dm;
+	unsigned long timeout, interval;
+	enum power_supply_charger_cable_type type =
+		POWER_SUPPLY_CHARGER_TYPE_NONE;
+
+	if (!charger_detect_enable(otg))
+		return cap_record.chrg_type;
+
+	phy = usb_get_phy(USB_PHY_TYPE_USB2);
+	if (!phy) {
+		otg_err(otg, "Get USB2 PHY failed\n");
+		return POWER_SUPPLY_CHARGER_TYPE_NONE;
+	}
+
+	/* PHY Enable:
+	 * Power on PHY
+	 */
+	enable_usb_phy(otg, true);
+	dwc3_phy_soft_reset(otg);
+
+	/* Enable ACA:
+	 * Enable ACA & ID detection logic.
+	 */
+	ret = intel_scu_ipc_update_register(PMIC_USBIDCTRL,
+			USBIDCTRL_ACA_DETEN_D1 | PMIC_USBPHYCTRL_D0,
+			USBIDCTRL_ACA_DETEN_D1 | PMIC_USBPHYCTRL_D0);
+	if (ret)
+		otg_err(otg, "Fail to enable ACA&ID detection logic\n");
+
+	/* DCD Enable: Change OPMODE to 01 (Non-driving),
+	 * TermSel to 0, &
+	 * XcvrSel to 01 (enable FS xcvr)
+	 */
+	usb_phy_io_write(phy, FUNCCTRL_OPMODE(1) | FUNCCTRL_XCVRSELECT(1),
+					TUSB1211_FUNC_CTRL_SET);
+
+	usb_phy_io_write(phy, FUNCCTRL_OPMODE(2) | FUNCCTRL_XCVRSELECT(2)
+					| FUNCCTRL_TERMSELECT,
+					TUSB1211_FUNC_CTRL_CLR);
+
+	/*Enable SW control*/
+	usb_phy_io_write(phy, PWCTRL_SW_CONTROL, TUSB1211_POWER_CONTROL_SET);
+
+	/* Enable IDPSRC */
+	usb_phy_io_write(phy, VS3_CHGD_IDP_SRC_EN,
+			TUSB1211_VENDOR_SPECIFIC3_SET);
+
+	/* Check DCD result, use same polling parameter */
+	timeout = jiffies + msecs_to_jiffies(DATACON_TIMEOUT);
+	interval = DATACON_INTERVAL * 1000; /* us */
+
+	/* DCD Check:
+	 * Delay 66.5 ms. (Note:
+	 * TIDP_SRC_ON + TCHGD_SERX_DEB =
+	 * 347.8us + 66.1ms).
+	 */
+	usleep_range(66500, 67000);
+
+	while (!time_after(jiffies, timeout)) {
+		/* Read DP logic level. */
+		val = usb_phy_io_read(phy, TUSB1211_VENDOR_SPECIFIC4);
+		if (val < 0) {
+			otg_err(otg, "ULPI read error! try again\n");
+			continue;
+		}
+
+		if (!(val & VS4_CHGD_SERX_DP)) {
+			otg_info(otg, "Data contact detected!\n");
+			break;
+		}
+
+		/* Polling interval */
+		usleep_range(interval, interval + 2000);
+	}
+
+	/* Disable DP pullup (Idp_src) */
+	usb_phy_io_write(phy, VS3_CHGD_IDP_SRC_EN,
+			TUSB1211_VENDOR_SPECIFIC3_CLR);
+
+	/* ID Check:
+	 * Check ID pin state.
+	 */
+	val = dwc3_intel_get_id(otg);
+	if (val != RID_FLOAT) {
+		type = dwc3_intel_aca_check(otg);
+		goto cleanup;
+	}
+
+	/* SE1 Det Enable:
+	 * Read DP/DM logic level. Note: use DEBUG
+	 * because VS4 isnt enabled in this situation.
+     */
+	val = usb_phy_io_read(phy, TUSB1211_DEBUG);
+	if (val < 0)
+		otg_err(otg, "ULPI read error!\n");
+
+	val &= DEBUG_LINESTATE;
+
+	/* If '11': SE1 detected; goto 'Cleanup'.
+	 * Else: goto 'Pri Det Enable'.
+	 */
+	if (val == 3) {
+		type = POWER_SUPPLY_CHARGER_TYPE_SE1;
+		goto cleanup;
+	}
+
+	/* Pri Det Enable:
+	 * Enable VDPSRC.
+	 */
+	usb_phy_io_write(phy, PWCTRL_DP_VSRC_EN, TUSB1211_POWER_CONTROL_SET);
+
+	/* Wait >106.1ms (40ms for BC
+	 * Tvdpsrc_on, 66.1ms for TI CHGD_SERX_DEB).
+	 */
+	msleep(107);
+
+	/* Pri Det Check:
+	 * Check if DM > VDATREF.
+	 */
+	vdat_det = usb_phy_io_read(phy, TUSB1211_POWER_CONTROL);
+	if (vdat_det < 0)
+		otg_err(otg, "ULPI read error!\n");
+
+	vdat_det &= PWCTRL_VDAT_DET;
+
+	/* Check if DM<VLGC */
+	chgd_serx_dm = usb_phy_io_read(phy, TUSB1211_VENDOR_SPECIFIC4);
+	if (chgd_serx_dm < 0)
+		otg_err(otg, "ULPI read error!\n");
+
+	chgd_serx_dm &= VS4_CHGD_SERX_DM;
+
+	/* If VDAT_DET==0 || CHGD_SERX_DM==1: SDP detected
+	 * If VDAT_DET==1 && CHGD_SERX_DM==0: CDP/DCP
+	 */
+	if (vdat_det == 0 || chgd_serx_dm == 1)
+		type = POWER_SUPPLY_CHARGER_TYPE_USB_SDP;
+
+	/* Disable VDPSRC. */
+	usb_phy_io_write(phy, PWCTRL_DP_VSRC_EN, TUSB1211_POWER_CONTROL_CLR);
+
+	/* If SDP, goto Cleanup.
+	 * Else, goto Sec Det Enable
+	 */
+	if (type == POWER_SUPPLY_CHARGER_TYPE_USB_SDP)
+		goto cleanup;
+
+	/* Sec Det Enable:
+	 * delay 1ms.
+	 */
+	usleep_range(1000, 1500);
+
+	/* Swap DP & DM */
+	usb_phy_io_write(phy, VS1_DATAPOLARITY, TUSB1211_VENDOR_SPECIFIC1_CLR);
+
+	/* Enable 'VDMSRC'. */
+	usb_phy_io_write(phy, PWCTRL_DP_VSRC_EN, TUSB1211_POWER_CONTROL_SET);
+
+	/* Wait >73ms (40ms for BC Tvdmsrc_on, 33ms for TI TVDPSRC_DEB) */
+	msleep(80);
+
+	/* Sec Det Check:
+	 * Check if DP>VDATREF.
+	 */
+	val = usb_phy_io_read(phy, TUSB1211_POWER_CONTROL);
+	if (val < 0)
+		otg_err(otg, "ULPI read error!\n");
+
+	val &= PWCTRL_VDAT_DET;
+
+	/* If VDAT_DET==0: CDP detected.
+	 * If VDAT_DET==1: DCP detected.
+	 */
+	if (!val)
+		type = POWER_SUPPLY_CHARGER_TYPE_USB_CDP;
+	else
+		type = POWER_SUPPLY_CHARGER_TYPE_USB_DCP;
+
+	/* Disable VDMSRC. */
+	usb_phy_io_write(phy, PWCTRL_DP_VSRC_EN, TUSB1211_POWER_CONTROL_CLR);
+
+	/* Swap DP & DM. */
+	usb_phy_io_write(phy, VS1_DATAPOLARITY, TUSB1211_VENDOR_SPECIFIC1_SET);
+
+cleanup:
+
+	/* If DCP detected, assert VDPSRC. */
+	if (type == POWER_SUPPLY_CHARGER_TYPE_USB_DCP)
+		usb_phy_io_write(phy, PWCTRL_SW_CONTROL | PWCTRL_DP_VSRC_EN,
+				TUSB1211_POWER_CONTROL_SET);
+
+	usb_put_phy(phy);
+
+	switch (type) {
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK:
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_A:
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_B:
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_C:
+	case POWER_SUPPLY_CHARGER_TYPE_USB_DCP:
+	case POWER_SUPPLY_CHARGER_TYPE_USB_CDP:
+	case POWER_SUPPLY_CHARGER_TYPE_SE1:
+		dwc_otg_charger_hwdet(true);
+		break;
+	default:
+		break;
+	};
+
+	return type;
+}
+
+static int dwc3_intel_handle_notification(struct notifier_block *nb,
+		unsigned long event, void *data)
+{
+	int state;
+	unsigned long flags, valid_chrg_type;
+	struct dwc_otg2 *otg = dwc3_get_otg();
+	struct power_supply_cable_props *cap;
+
+	if (!otg)
+		return NOTIFY_BAD;
+
+	valid_chrg_type = POWER_SUPPLY_CHARGER_TYPE_USB_SDP |
+		POWER_SUPPLY_CHARGER_TYPE_USB_CDP |
+		POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK;
+
+	spin_lock_irqsave(&otg->lock, flags);
+	switch (event) {
+	case USB_EVENT_ID:
+		otg->otg_events |= OEVT_CONN_ID_STS_CHNG_EVNT;
+		state = NOTIFY_OK;
+		break;
+	case USB_EVENT_VBUS:
+		if (*(int *)data) {
+			otg->otg_events |= OEVT_B_DEV_SES_VLD_DET_EVNT;
+			otg->otg_events &= ~OEVT_A_DEV_SESS_END_DET_EVNT;
+		} else {
+			otg->otg_events |= OEVT_A_DEV_SESS_END_DET_EVNT;
+			otg->otg_events &= ~OEVT_B_DEV_SES_VLD_DET_EVNT;
+		}
+		state = NOTIFY_OK;
+		break;
+	case USB_EVENT_CHARGER:
+		if (charger_detect_enable(otg)) {
+			state = NOTIFY_DONE;
+			goto done;
+		}
+		cap = (struct power_supply_cable_props *)data;
+		if (!(cap->chrg_type & valid_chrg_type)) {
+			otg_err(otg, "Invalid charger type!\n");
+			state = NOTIFY_BAD;
+		}
+		if (cap->chrg_evt == POWER_SUPPLY_CHARGER_EVENT_CONNECT) {
+			otg->otg_events |= OEVT_B_DEV_SES_VLD_DET_EVNT;
+			otg->otg_events &= ~OEVT_A_DEV_SESS_END_DET_EVNT;
+
+			cap_record.chrg_type = cap->chrg_type;
+			cap_record.ma = cap->ma;
+			cap_record.chrg_evt = cap->chrg_evt;
+		} else if (cap->chrg_evt ==
+				POWER_SUPPLY_CHARGER_EVENT_DISCONNECT) {
+			otg->otg_events |= OEVT_A_DEV_SESS_END_DET_EVNT;
+			otg->otg_events &= ~OEVT_B_DEV_SES_VLD_DET_EVNT;
+
+			cap_record.chrg_type = POWER_SUPPLY_CHARGER_TYPE_NONE;
+			cap_record.ma = 0;
+			cap_record.chrg_evt =
+				POWER_SUPPLY_CHARGER_EVENT_DISCONNECT;
+		}
+		state = NOTIFY_OK;
+		break;
+	default:
+		otg_dbg(otg, "DWC OTG Notify unknow notify message\n");
+		state = NOTIFY_DONE;
+	}
+
+done:
+	dwc3_wakeup_otg_thread(otg);
+	spin_unlock_irqrestore(&otg->lock, flags);
+
+	return state;
+
+}
+
+int dwc3_intel_prepare_start_host(struct dwc_otg2 *otg)
+{
+	if (!is_hybridvp(otg)) {
+		enable_usb_phy(otg, true);
+		usb2phy_eye_optimization(otg);
+		disable_phy_auto_resume(otg);
+	}
+
+	return 0;
+}
+
+int dwc3_intel_prepare_start_peripheral(struct dwc_otg2 *otg)
+{
+	if (!is_hybridvp(otg)) {
+		enable_usb_phy(otg, true);
+		usb2phy_eye_optimization(otg);
+		disable_phy_auto_resume(otg);
+	}
+
+	return 0;
+}
+
+int dwc3_intel_suspend(struct dwc_otg2 *otg)
+{
+	struct pci_dev *pci_dev;
+	pci_power_t state = PCI_D3cold;
+
+	if (!otg)
+		return 0;
+
+	pci_dev = to_pci_dev(otg->dev);
+
+	if (otg->state == DWC_STATE_B_PERIPHERAL ||
+			otg->state == DWC_STATE_A_HOST)
+		state = PCI_D3hot;
+
+	set_sus_phy(otg, 1);
+
+	if (pci_save_state(pci_dev)) {
+		otg_err(otg, "pci_save_state failed!\n");
+		return -EIO;
+	}
+
+	pci_disable_device(pci_dev);
+	pci_set_power_state(pci_dev, state);
+
+	return 0;
+}
+
+int dwc3_intel_resume(struct dwc_otg2 *otg)
+{
+	struct pci_dev *pci_dev;
+
+	if (!otg)
+		return 0;
+
+	pci_dev = to_pci_dev(otg->dev);
+
+	/* From synopsys spec 12.2.11.
+	 * Software cannot access memory-mapped I/O space
+	 * for 10ms. Delay 5 ms here should be enough. Too
+	 * long a delay causes hibernation exit failure.
+	 */
+	mdelay(5);
+
+	pci_restore_state(pci_dev);
+	if (pci_enable_device(pci_dev) < 0) {
+		otg_err(otg, "pci_enable_device failed.\n");
+		return -EIO;
+	}
+
+	set_sus_phy(otg, 0);
+
+	/* Delay 1ms waiting PHY clock debounce.
+	 * Without this debounce, will met fabric error randomly.
+	 **/
+	mdelay(1);
+
+	return 0;
+}
+
+struct dwc3_otg_hw_ops dwc3_intel_otg_pdata = {
+	.mode = DWC3_DRD,
+	.bus = DWC3_PCI,
+	.get_id = dwc3_intel_get_id,
+	.b_idle = dwc3_intel_b_idle,
+	.set_power = dwc3_intel_set_power,
+	.enable_vbus = dwc3_intel_enable_vbus,
+	.platform_init = dwc3_intel_platform_init,
+	.get_charger_type = dwc3_intel_get_charger_type,
+	.otg_notifier_handler = dwc3_intel_handle_notification,
+	.prepare_start_peripheral = dwc3_intel_prepare_start_peripheral,
+	.prepare_start_host = dwc3_intel_prepare_start_host,
+	.notify_charger_type = dwc3_intel_notify_charger_type,
+
+	.suspend = dwc3_intel_suspend,
+	.resume = dwc3_intel_resume,
+};
+
+static int __init dwc3_intel_init(void)
+{
+	return dwc3_otg_register(&dwc3_intel_otg_pdata);
+}
+module_init(dwc3_intel_init);
+
+static void __exit dwc3_intel_exit(void)
+{
+	dwc3_otg_unregister(&dwc3_intel_otg_pdata);
+}
+module_exit(dwc3_intel_exit);
+
+MODULE_AUTHOR("Wang Yu <yu.y.wang@intel.com>");
+MODULE_DESCRIPTION("DWC3 Intel OTG Driver");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_VERSION(VERSION);
diff --git a/drivers/usb/dwc3/dwc3-pci.c b/drivers/usb/dwc3/dwc3-pci.c
index f393c18..8acb246 100644
--- a/drivers/usb/dwc3/dwc3-pci.c
+++ b/drivers/usb/dwc3/dwc3-pci.c
@@ -187,6 +187,10 @@ static const struct pci_device_id dwc3_pci_id_table[] = {
 	{
 		PCI_DEVICE(PCI_VENDOR_ID_SYNOPSYS,
 				PCI_DEVICE_ID_SYNOPSYS_HAPSUSB3),
+		/* FIXME: move to pci_ids.h */
+	}, {
+#define PCI_DEVICE_ID_INTEL_DWC_TNG	0x119e
+		PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_DWC_TNG),
 	},
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_BYT), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_MRFLD), },
diff --git a/drivers/usb/dwc3/ep0.c b/drivers/usb/dwc3/ep0.c
index 0985ff7..31358d2 100644
--- a/drivers/usb/dwc3/ep0.c
+++ b/drivers/usb/dwc3/ep0.c
@@ -398,6 +398,9 @@ static int dwc3_ep0_handle_feature(struct dwc3 *dwc,
 			if (dwc->speed != DWC3_DSTS_SUPERSPEED)
 				return -EINVAL;
 
+			if (dwc->is_ebc)
+				break;
+
 			reg = dwc3_readl(dwc->regs, DWC3_DCTL);
 			if (set)
 				reg |= DWC3_DCTL_INITU1ENA;
@@ -412,6 +415,9 @@ static int dwc3_ep0_handle_feature(struct dwc3 *dwc,
 			if (dwc->speed != DWC3_DSTS_SUPERSPEED)
 				return -EINVAL;
 
+			if (dwc->is_ebc)
+				break;
+
 			reg = dwc3_readl(dwc->regs, DWC3_DCTL);
 			if (set)
 				reg |= DWC3_DCTL_INITU2ENA;
@@ -551,9 +557,12 @@ static int dwc3_ep0_set_config(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)
 			 * Enable transition to U1/U2 state when
 			 * nothing is pending from application.
 			 */
-			reg = dwc3_readl(dwc->regs, DWC3_DCTL);
-			reg |= (DWC3_DCTL_ACCEPTU1ENA | DWC3_DCTL_ACCEPTU2ENA);
-			dwc3_writel(dwc->regs, DWC3_DCTL, reg);
+			if (!dwc->is_ebc) {
+				reg = dwc3_readl(dwc->regs, DWC3_DCTL);
+				reg |= (DWC3_DCTL_ACCEPTU1ENA
+					| DWC3_DCTL_ACCEPTU2ENA);
+				dwc3_writel(dwc->regs, DWC3_DCTL, reg);
+			}
 
 			dwc->resize_fifos = true;
 			dev_dbg(dwc->dev, "resize fifos flag SET\n");
@@ -767,6 +776,9 @@ static void dwc3_ep0_complete_data(struct dwc3 *dwc,
 
 	dwc->ep0_next_event = DWC3_EP0_NRDY_STATUS;
 
+	if (list_empty(&ep0->request_list))
+		return;
+
 	r = next_request(&ep0->request_list);
 	ur = &r->request;
 
@@ -1007,6 +1019,25 @@ static void dwc3_ep0_xfernotready(struct dwc3 *dwc,
 			return;
 		}
 
+		/*
+		 * Per databook, if an XferNotready(Data) is received after
+		 * XferComplete(Data), one possible reason is host is trying
+		 * to complete data stage by moving a 0-length packet.
+		 *
+		 * REVISIT in case of other cases
+		 */
+		if (dwc->ep0_next_event == DWC3_EP0_NRDY_STATUS) {
+			u32		size = 0;
+			struct dwc3_ep *dep = dwc->eps[event->endpoint_number];
+
+			if (dep->number == 0)
+				size = dep->endpoint.maxpacket;
+
+			dwc3_ep0_start_trans(dwc, dep->number,
+				dwc->ctrl_req_addr, size,
+				DWC3_TRBCTL_CONTROL_DATA);
+		}
+
 		break;
 
 	case DEPEVT_STATUS_CONTROL_STATUS:
diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c
index b91d759..d520022 100644
--- a/drivers/usb/dwc3/gadget.c
+++ b/drivers/usb/dwc3/gadget.c
@@ -29,10 +29,16 @@
 
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
+#include <linux/usb/phy.h>
+#include <linux/usb/otg.h>
+#include <linux/usb/ulpi.h>
 
 #include "core.h"
 #include "gadget.h"
 #include "io.h"
+#include "otg.h"
+
+static LIST_HEAD(ebc_io_ops);
 
 /**
  * dwc3_gadget_set_test_mode - Enables USB2 Test Modes
@@ -247,7 +253,7 @@ void dwc3_gadget_giveback(struct dwc3_ep *dep, struct dwc3_request *req,
 
 	if (dwc->ep0_bounced && dep->number == 0)
 		dwc->ep0_bounced = false;
-	else
+	else if (!dep->ebc)
 		usb_gadget_unmap_request(&dwc->gadget, &req->request,
 				req->direction);
 
@@ -317,7 +323,7 @@ int dwc3_send_gadget_ep_cmd(struct dwc3 *dwc, unsigned ep,
 		unsigned cmd, struct dwc3_gadget_ep_cmd_params *params)
 {
 	struct dwc3_ep		*dep = dwc->eps[ep];
-	u32			timeout = 500;
+	u32			timeout = 5000;
 	u32			reg;
 
 	dev_vdbg(dwc->dev, "%s: cmd '%s' params %08x %08x %08x\n",
@@ -368,9 +374,13 @@ static int dwc3_alloc_trb_pool(struct dwc3_ep *dep)
 	if (dep->number == 0 || dep->number == 1)
 		return 0;
 
-	dep->trb_pool = dma_alloc_coherent(dwc->dev,
-			sizeof(struct dwc3_trb) * DWC3_TRB_NUM,
-			&dep->trb_pool_dma, GFP_KERNEL);
+	if (dep->ebc)
+		dep->trb_pool = dep->ebc->alloc_static_trb_pool(
+				&dep->trb_pool_dma);
+	else
+		dep->trb_pool = dma_alloc_coherent(dwc->dev,
+				sizeof(struct dwc3_trb) * DWC3_TRB_NUM,
+				&dep->trb_pool_dma, GFP_KERNEL);
 	if (!dep->trb_pool) {
 		dev_err(dep->dwc->dev, "failed to allocate trb pool for %s\n",
 				dep->name);
@@ -384,7 +394,11 @@ static void dwc3_free_trb_pool(struct dwc3_ep *dep)
 {
 	struct dwc3		*dwc = dep->dwc;
 
-	dma_free_coherent(dwc->dev, sizeof(struct dwc3_trb) * DWC3_TRB_NUM,
+	if (dep->ebc)
+		dep->ebc->free_static_trb_pool();
+	else
+		dma_free_coherent(dwc->dev,
+			sizeof(struct dwc3_trb) * DWC3_TRB_NUM,
 			dep->trb_pool, dep->trb_pool_dma);
 
 	dep->trb_pool = NULL;
@@ -417,35 +431,58 @@ static int dwc3_gadget_start_config(struct dwc3 *dwc, struct dwc3_ep *dep)
 static int dwc3_gadget_set_ep_config(struct dwc3 *dwc, struct dwc3_ep *dep,
 		const struct usb_endpoint_descriptor *desc,
 		const struct usb_ss_ep_comp_descriptor *comp_desc,
-		bool ignore)
+		bool ignore, u32 cfg_action)
 {
 	struct dwc3_gadget_ep_cmd_params params;
 
 	memset(&params, 0x00, sizeof(params));
 
 	params.param0 = DWC3_DEPCFG_EP_TYPE(usb_endpoint_type(desc))
-		| DWC3_DEPCFG_MAX_PACKET_SIZE(usb_endpoint_maxp(desc));
+		| DWC3_DEPCFG_MAX_PACKET_SIZE(usb_endpoint_maxp(desc))
+		| cfg_action;
 
-	/* Burst size is only needed in SuperSpeed mode */
-	if (dwc->gadget.speed == USB_SPEED_SUPER) {
-		u32 burst = dep->endpoint.maxburst - 1;
+	if (dep->ebc) {
+		if (dwc->gadget.speed == USB_SPEED_SUPER) {
+			u32 burst = 0;
 
-		params.param0 |= DWC3_DEPCFG_BURST_SIZE(burst);
-	}
+			params.param0 |= DWC3_DEPCFG_BURST_SIZE(burst);
+		}
 
-	if (ignore)
 		params.param0 |= DWC3_DEPCFG_IGN_SEQ_NUM;
 
-	params.param1 = DWC3_DEPCFG_XFER_COMPLETE_EN
-		| DWC3_DEPCFG_XFER_NOT_READY_EN;
+		params.param1 = DWC3_DEPCFG_EBC_MODE_EN;
+
+		if (dep->ebc->is_ondemand)
+			params.param1 |= DWC3_DEPCFG_XFER_NOT_READY_EN;
+
+		dep->stream_capable = false;
+	} else {
+		/* Burst size is only needed in SuperSpeed mode */
+		if (dwc->gadget.speed == USB_SPEED_SUPER) {
+			/* In case a function forgets to set maxburst, maxburst
+			 * may be still 0, and we shouldn't minus 1 for it.
+			 */
+			u32 burst = dep->endpoint.maxburst ?
+					dep->endpoint.maxburst - 1 : 0;
 
-	if (usb_ss_max_streams(comp_desc) && usb_endpoint_xfer_bulk(desc)) {
-		params.param1 |= DWC3_DEPCFG_STREAM_CAPABLE
-			| DWC3_DEPCFG_STREAM_EVENT_EN;
-		dep->stream_capable = true;
+			params.param0 |= DWC3_DEPCFG_BURST_SIZE(burst);
+		}
+
+		if (ignore)
+			params.param0 |= DWC3_DEPCFG_IGN_SEQ_NUM;
+
+		params.param1 = DWC3_DEPCFG_XFER_COMPLETE_EN
+			| DWC3_DEPCFG_XFER_NOT_READY_EN;
+
+		if (usb_ss_max_streams(comp_desc) &&
+				usb_endpoint_xfer_bulk(desc)) {
+			params.param1 |= DWC3_DEPCFG_STREAM_CAPABLE
+				| DWC3_DEPCFG_STREAM_EVENT_EN;
+			dep->stream_capable = true;
+		}
 	}
 
-	if (usb_endpoint_xfer_isoc(desc))
+	if (usb_endpoint_xfer_isoc(desc) || usb_endpoint_is_bulk_out(desc))
 		params.param1 |= DWC3_DEPCFG_XFER_IN_PROGRESS_EN;
 
 	/*
@@ -468,6 +505,56 @@ static int dwc3_gadget_set_ep_config(struct dwc3 *dwc, struct dwc3_ep *dep,
 		dep->interval = 1 << (desc->bInterval - 1);
 	}
 
+	if (cfg_action == DWC3_DEPCFG_ACTION_RESTORE)
+		params.param2 = dep->ep_state;
+
+	return dwc3_send_gadget_ep_cmd(dwc, dep->number,
+			DWC3_DEPCMD_SETEPCONFIG, &params);
+}
+
+static int dwc3_gadget_update_ebc_ep_config(struct dwc3 *dwc,
+		struct dwc3_ep *dep,
+		const struct usb_endpoint_descriptor *desc,
+		const struct usb_ss_ep_comp_descriptor *comp_desc,
+		bool ignore_nrdy)
+{
+	u16	maxp;
+	struct dwc3_gadget_ep_cmd_params params;
+
+	if (!dep->ebc)
+		return -EINVAL;
+
+	memset(&params, 0x00, sizeof(params));
+
+	maxp = usb_endpoint_maxp(desc);
+
+	params.param0 =	DWC3_DEPCFG_EP_TYPE(usb_endpoint_type(desc))
+		| DWC3_DEPCFG_MAX_PACKET_SIZE(maxp)
+		| DWC3_DEPCFG_ACTION_MODIFY;
+
+	if (dwc->gadget.speed == USB_SPEED_SUPER) {
+		u32 burst = 0;
+
+		params.param0 |= DWC3_DEPCFG_BURST_SIZE(burst);
+	}
+	params.param0 |= DWC3_DEPCFG_IGN_SEQ_NUM;
+	params.param1 = DWC3_DEPCFG_EBC_MODE_EN;
+
+	if (!ignore_nrdy)
+		params.param1 |= DWC3_DEPCFG_XFER_NOT_READY_EN;
+
+	dep->stream_capable = false;
+
+	params.param1 |= DWC3_DEPCFG_EP_NUMBER(dep->number);
+
+	if (dep->direction)
+		params.param0 |= DWC3_DEPCFG_FIFO_NUMBER(dep->number >> 1);
+
+	if (desc->bInterval) {
+		params.param1 |= DWC3_DEPCFG_BINTERVAL_M1(desc->bInterval - 1);
+		dep->interval = 1 << (desc->bInterval - 1);
+	}
+
 	return dwc3_send_gadget_ep_cmd(dwc, dep->number,
 			DWC3_DEPCMD_SETEPCONFIG, &params);
 }
@@ -508,7 +595,8 @@ static int __dwc3_gadget_ep_enable(struct dwc3_ep *dep,
 			return ret;
 	}
 
-	ret = dwc3_gadget_set_ep_config(dwc, dep, desc, comp_desc, ignore);
+	ret = dwc3_gadget_set_ep_config(dwc, dep, desc, comp_desc, ignore,
+				DWC3_DEPCFG_ACTION_INIT);
 	if (ret)
 		return ret;
 
@@ -529,6 +617,9 @@ static int __dwc3_gadget_ep_enable(struct dwc3_ep *dep,
 		reg |= DWC3_DALEPENA_EP(dep->number);
 		dwc3_writel(dwc->regs, DWC3_DALEPENA, reg);
 
+		if (dep->ebc)
+			dwc->is_ebc = 1;
+
 		if (!usb_endpoint_xfer_isoc(desc))
 			return 0;
 
@@ -547,13 +638,13 @@ static int __dwc3_gadget_ep_enable(struct dwc3_ep *dep,
 	return 0;
 }
 
-static void dwc3_stop_active_transfer(struct dwc3 *dwc, u32 epnum);
+static void dwc3_stop_active_transfer(struct dwc3 *dwc, u32 epnum, int forcerm);
 static void dwc3_remove_requests(struct dwc3 *dwc, struct dwc3_ep *dep)
 {
 	struct dwc3_request		*req;
 
 	if (!list_empty(&dep->req_queued)) {
-		dwc3_stop_active_transfer(dwc, dep->number);
+		dwc3_stop_active_transfer(dwc, dep->number, 1);
 
 		/* - giveback all requests to gadget driver */
 		while (!list_empty(&dep->req_queued)) {
@@ -581,8 +672,16 @@ static void dwc3_remove_requests(struct dwc3 *dwc, struct dwc3_ep *dep)
 static int __dwc3_gadget_ep_disable(struct dwc3_ep *dep)
 {
 	struct dwc3		*dwc = dep->dwc;
+	struct ebc_io		*ebc = dep->ebc;
 	u32			reg;
 
+	if (ebc) {
+		dwc->is_ebc = 0;
+
+		if (ebc->is_ondemand && ebc->xfer_stop)
+			ebc->xfer_stop();
+	}
+
 	dwc3_remove_requests(dwc, dep);
 
 	/* make sure HW endpoint isn't stalled */
@@ -599,6 +698,10 @@ static int __dwc3_gadget_ep_disable(struct dwc3_ep *dep)
 	dep->type = 0;
 	dep->flags = 0;
 
+	/* set normal endpoint maxpacket to default value */
+	if (dep->number > 1)
+		dep->endpoint.maxpacket = 1024;
+
 	return 0;
 }
 
@@ -683,7 +786,8 @@ static int dwc3_gadget_ep_disable(struct usb_ep *ep)
 	dep = to_dwc3_ep(ep);
 	dwc = dep->dwc;
 
-	if (!(dep->flags & DWC3_EP_ENABLED)) {
+	if (!(dep->flags & DWC3_EP_ENABLED) &&
+		dep->flags != DWC3_EP_HIBERNATION) {
 		dev_WARN_ONCE(dwc->dev, true, "%s is already disabled\n",
 				dep->name);
 		return 0;
@@ -734,7 +838,8 @@ static void dwc3_gadget_ep_free_request(struct usb_ep *ep,
  */
 static void dwc3_prepare_one_trb(struct dwc3_ep *dep,
 		struct dwc3_request *req, dma_addr_t dma,
-		unsigned length, unsigned last, unsigned chain, unsigned node)
+		unsigned length, unsigned last, unsigned chain,
+		unsigned node, unsigned csp)
 {
 	struct dwc3		*dwc = dep->dwc;
 	struct dwc3_trb		*trb;
@@ -801,6 +906,12 @@ static void dwc3_prepare_one_trb(struct dwc3_ep *dep,
 	if (chain)
 		trb->ctrl |= DWC3_TRB_CTRL_CHN;
 
+	if (csp) {
+		trb->ctrl |= DWC3_TRB_CTRL_CSP;
+		trb->ctrl |= DWC3_TRB_CTRL_IOC;
+	}
+
+
 	if (usb_endpoint_xfer_bulk(dep->endpoint.desc) && dep->stream_capable)
 		trb->ctrl |= DWC3_TRB_CTRL_SID_SOFN(req->request.stream_id);
 
@@ -865,7 +976,8 @@ static void dwc3_prepare_trbs(struct dwc3_ep *dep, bool starting)
 	}
 
 	/* The last TRB is a link TRB, not used for xfer */
-	if ((trbs_left <= 1) && usb_endpoint_xfer_isoc(dep->endpoint.desc))
+	if ((trbs_left <= 1) && usb_endpoint_xfer_isoc(dep->endpoint.desc) &&
+		(dep->free_slot & DWC3_TRB_MASK) == DWC3_TRB_NUM - 1)
 		return;
 
 	list_for_each_entry_safe(req, n, &dep->request_list, list) {
@@ -900,7 +1012,7 @@ static void dwc3_prepare_trbs(struct dwc3_ep *dep, bool starting)
 					chain = false;
 
 				dwc3_prepare_one_trb(dep, req, dma, length,
-						last_one, chain, i);
+						last_one, chain, i, false);
 
 				if (last_one)
 					break;
@@ -909,6 +1021,8 @@ static void dwc3_prepare_trbs(struct dwc3_ep *dep, bool starting)
 			if (last_one)
 				break;
 		} else {
+			unsigned csp = false;
+
 			dma = req->request.dma;
 			length = req->request.length;
 			trbs_left--;
@@ -920,8 +1034,13 @@ static void dwc3_prepare_trbs(struct dwc3_ep *dep, bool starting)
 			if (list_is_last(&req->list, &dep->request_list))
 				last_one = 1;
 
+			/* For bulk-out ep, if req is the short packet and
+			 * not the last one, enable CSP. */
+			if (req->short_packet && !last_one)
+				csp = true;
+
 			dwc3_prepare_one_trb(dep, req, dma, length,
-					last_one, false, 0);
+					last_one, false, 0, csp);
 
 			if (last_one)
 				break;
@@ -929,6 +1048,115 @@ static void dwc3_prepare_trbs(struct dwc3_ep *dep, bool starting)
 	}
 }
 
+/*
+ * dwc3_prepare_ebc_trbs - setup TRBs from DvC endpoint requests
+ * @dep: endpoint for which requests are being prepared
+ * @starting: true if the endpoint is idle and no requests are queued.
+ *
+ * The functions goes through the requests list and setups TRBs for the
+ * transfers.
+ */
+static void dwc3_prepare_ebc_trbs(struct dwc3_ep *dep,
+		bool starting)
+{
+	struct dwc3_request	*req, *n;
+	struct dwc3_trb		*trb_st_hw;
+	struct dwc3_trb		*trb_link;
+	struct dwc3_trb		*trb;
+	u32			trbs_left;
+	u32			trbs_num;
+	u32			trbs_mask;
+
+	/* BUILD_BUG_ON_NOT_POWER_OF_2(DWC3_TRB_NUM);*/
+	trbs_num = dep->ebc->static_trb_pool_size;
+	trbs_mask = trbs_num - 1;
+
+	/* the first request must not be queued */
+	trbs_left = (dep->busy_slot - dep->free_slot) & trbs_mask;
+	/*
+	 * if busy & slot are equal than it is either full or empty. If we are
+	 * starting to proceed requests then we are empty. Otherwise we ar
+	 * full and don't do anything
+	 */
+	if (!trbs_left) {
+		if (!starting)
+			return;
+		trbs_left = trbs_num;
+		dep->busy_slot = 0;
+		dep->free_slot = 0;
+	}
+
+	/* The tailed TRB is a link TRB, not used for xfer */
+	if ((trbs_left <= 1))
+		return;
+
+	list_for_each_entry_safe(req, n, &dep->request_list, list) {
+		unsigned int last_one = 0;
+		unsigned int cur_slot;
+
+		/* revisit: dont use specific TRB buffer for Debug class? */
+		trb = &dep->trb_pool[dep->free_slot & trbs_mask];
+		cur_slot = dep->free_slot;
+		dep->free_slot++;
+
+		/* Skip the LINK-TRB */
+		if (((cur_slot & trbs_mask) == trbs_num - 1))
+			continue;
+
+		dwc3_gadget_move_request_queued(req);
+		trbs_left--;
+
+		/* Is our TRB pool empty? */
+		if (!trbs_left)
+			last_one = 1;
+		/* Is this the last request? */
+		if (list_empty(&dep->request_list))
+			last_one = 1;
+
+		req->trb = trb;
+		req->trb_dma = dwc3_trb_dma_offset(dep, trb);
+
+		trb->size = DWC3_TRB_SIZE_LENGTH(req->request.length);
+		trb->bpl = lower_32_bits(req->request.dma);
+		trb->bph = upper_32_bits(req->request.dma);
+
+		switch (usb_endpoint_type(dep->endpoint.desc)) {
+		case USB_ENDPOINT_XFER_BULK:
+			trb->ctrl = DWC3_TRBCTL_NORMAL;
+			break;
+
+		case USB_ENDPOINT_XFER_CONTROL:
+		case USB_ENDPOINT_XFER_ISOC:
+		case USB_ENDPOINT_XFER_INT:
+		default:
+			/*
+			 * This is only possible with faulty memory because we
+			 * checked it already :)
+			 */
+			BUG();
+		}
+
+		trb->ctrl |= DWC3_TRB_CTRL_HWO | DWC3_TRB_CTRL_CHN;
+
+		if (last_one) {
+			if (trbs_left >= 1) {
+				trb_st_hw = &dep->trb_pool[0];
+
+				trb_link = &dep->trb_pool[dep->free_slot &
+						trbs_mask];
+				trb_link->bpl = lower_32_bits(
+					dwc3_trb_dma_offset(dep, trb_st_hw));
+				trb_link->bph = upper_32_bits(
+					dwc3_trb_dma_offset(dep, trb_st_hw));
+				trb_link->ctrl = DWC3_TRBCTL_LINK_TRB;
+				trb_link->ctrl |= DWC3_TRB_CTRL_HWO;
+				trb_link->size = 0;
+			}
+			break;
+		}
+	}
+}
+
 static int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep, u16 cmd_param,
 		int start_new)
 {
@@ -949,8 +1177,11 @@ static int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep, u16 cmd_param,
 	 * new requests as we try to set the IOC bit only on the last request.
 	 */
 	if (start_new) {
-		if (list_empty(&dep->req_queued))
-			dwc3_prepare_trbs(dep, start_new);
+		if (dep->ebc)
+			dwc3_prepare_ebc_trbs(dep, start_new);
+		else
+			if (list_empty(&dep->req_queued))
+				dwc3_prepare_trbs(dep, start_new);
 
 		/* req points to the first request which will be sent */
 		req = next_request(&dep->req_queued);
@@ -987,8 +1218,9 @@ static int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep, u16 cmd_param,
 		 * here and stop, unmap, free and del each of the linked
 		 * requests instead of what we do now.
 		 */
-		usb_gadget_unmap_request(&dwc->gadget, &req->request,
-				req->direction);
+		if (!dep->ebc)
+			usb_gadget_unmap_request(&dwc->gadget, &req->request,
+					req->direction);
 		list_del(&req->list);
 		return ret;
 	}
@@ -1001,6 +1233,26 @@ static int __dwc3_gadget_kick_transfer(struct dwc3_ep *dep, u16 cmd_param,
 		WARN_ON_ONCE(!dep->resource_index);
 	}
 
+	if (dep->ebc) {
+		if (dep->ebc->is_ondemand == 1) {
+			ret = dwc3_gadget_update_ebc_ep_config(dwc, dep,
+				dep->endpoint.desc, dep->comp_desc, true);
+
+			if (ret < 0) {
+				dev_dbg(dwc->dev,
+					"DEPCFG command failed on %s\n",
+					dep->name);
+				return ret;
+			}
+			dev_dbg(dwc->dev,
+				"successfully udpated DEPCFG command on %s\n",
+				dep->name);
+		}
+
+		if (dep->ebc->xfer_start)
+			dep->ebc->xfer_start();
+	}
+
 	return 0;
 }
 
@@ -1043,6 +1295,29 @@ static int __dwc3_gadget_ep_queue(struct dwc3_ep *dep, struct dwc3_request *req)
 	req->direction		= dep->direction;
 	req->epnum		= dep->number;
 
+	/* specific handling for debug class */
+	if (dep->ebc) {
+		list_add_tail(&req->list, &dep->request_list);
+
+		if ((dep->ebc->is_ondemand == 1) &&
+			(!(dep->flags & DWC3_EP_PENDING_REQUEST))) {
+			dev_dbg(dwc->dev, "%s: delayed to kick ebc transfers\n",
+				dep->name);
+			return 0;
+		}
+
+		if (dep->flags & DWC3_EP_BUSY) {
+			dwc3_stop_active_transfer(dwc, dep->number, 1);
+			dep->flags = DWC3_EP_ENABLED;
+		}
+
+		ret = __dwc3_gadget_kick_transfer(dep, 0, true);
+		if (ret)
+			dev_dbg(dwc->dev, "%s: failed to kick transfers\n",
+					dep->name);
+		return ret;
+	}
+
 	/*
 	 * We only add to our list of requests now and
 	 * start consuming the list once we get XferNotReady
@@ -1082,7 +1357,7 @@ static int __dwc3_gadget_ep_queue(struct dwc3_ep *dep, struct dwc3_request *req)
 		 */
 		if (usb_endpoint_xfer_isoc(dep->endpoint.desc)) {
 			if (list_empty(&dep->req_queued)) {
-				dwc3_stop_active_transfer(dwc, dep->number);
+				dwc3_stop_active_transfer(dwc, dep->number, 1);
 				dep->flags = DWC3_EP_ENABLED;
 			}
 			return 0;
@@ -1126,16 +1401,28 @@ static int dwc3_gadget_ep_queue(struct usb_ep *ep, struct usb_request *request,
 
 	int				ret;
 
+	spin_lock_irqsave(&dwc->lock, flags);
 	if (!dep->endpoint.desc) {
 		dev_dbg(dwc->dev, "trying to queue request %p to disabled %s\n",
 				request, ep->name);
+		spin_unlock_irqrestore(&dwc->lock, flags);
 		return -ESHUTDOWN;
 	}
 
 	dev_vdbg(dwc->dev, "queing request %p to %s length %d\n",
 			request, ep->name, request->length);
 
-	spin_lock_irqsave(&dwc->lock, flags);
+	/* pad OUT endpoint buffer to MaxPacketSize per databook requirement*/
+	req->short_packet = false;
+	if (!IS_ALIGNED(request->length, ep->desc->wMaxPacketSize)
+		&& !(dep->number & 1) && (dep->number != DWC3_EP_EBC_OUT_NB)) {
+		request->length = roundup(request->length,
+					(u32) ep->desc->wMaxPacketSize);
+		/* set flag for bulk-out short request */
+		if (usb_endpoint_is_bulk_out(dep->endpoint.desc))
+			req->short_packet = true;
+	}
+
 	ret = __dwc3_gadget_ep_queue(dep, req);
 	spin_unlock_irqrestore(&dwc->lock, flags);
 
@@ -1168,7 +1455,7 @@ static int dwc3_gadget_ep_dequeue(struct usb_ep *ep,
 		}
 		if (r == req) {
 			/* wait until it is processed */
-			dwc3_stop_active_transfer(dwc, dep->number);
+			dwc3_stop_active_transfer(dwc, dep->number, 1);
 			goto out1;
 		}
 		dev_err(dwc->dev, "request %p was not queued to %s\n",
@@ -1400,13 +1687,44 @@ static int dwc3_gadget_set_selfpowered(struct usb_gadget *g,
 	return 0;
 }
 
+static int __dwc3_gadget_run_stop(struct dwc3 *dwc, int is_on)
+{
+	u32			reg;
+	u32			timeout = 500;
+
+	reg = dwc3_readl(dwc->regs, DWC3_DCTL);
+	if (is_on)
+		reg |= DWC3_DCTL_RUN_STOP;
+	else
+		reg &= ~DWC3_DCTL_RUN_STOP;
+	dwc3_writel(dwc->regs, DWC3_DCTL, reg);
+
+	do {
+		reg = dwc3_readl(dwc->regs, DWC3_DSTS);
+		if (is_on) {
+			if (!(reg & DWC3_DSTS_DEVCTRLHLT))
+				break;
+		} else {
+			if (reg & DWC3_DSTS_DEVCTRLHLT)
+				break;
+		}
+		timeout--;
+		if (!timeout)
+			return -ETIMEDOUT;
+		udelay(1);
+	} while (1);
+
+	return 0;
+}
+
 static int dwc3_gadget_run_stop(struct dwc3 *dwc, int is_on)
 {
 	u32			reg;
 	u32			timeout = 500;
+	struct usb_phy		*usb_phy;
 
 	reg = dwc3_readl(dwc->regs, DWC3_DCTL);
-	if (is_on) {
+	if (is_on && !dwc->pullups_connected) {
 		if (dwc->revision <= DWC3_REVISION_187A) {
 			reg &= ~DWC3_DCTL_TRGTULST_MASK;
 			reg |= DWC3_DCTL_TRGTULST_RX_DET;
@@ -1416,10 +1734,20 @@ static int dwc3_gadget_run_stop(struct dwc3 *dwc, int is_on)
 			reg &= ~DWC3_DCTL_KEEP_CONNECT;
 		reg |= DWC3_DCTL_RUN_STOP;
 		dwc->pullups_connected = true;
-	} else {
+	} else if (!is_on && dwc->pullups_connected) {
 		reg &= ~DWC3_DCTL_RUN_STOP;
 		dwc->pullups_connected = false;
-	}
+
+		/* WORKAROUND: reset PHY via FUNC_CTRL before disconnect
+		 * to avoid PHY hang
+		 */
+		usb_phy = usb_get_phy(USB_PHY_TYPE_USB2);
+		if (usb_phy)
+			usb_phy_io_write(usb_phy,
+					0x6D, ULPI_FUNC_CTRL);
+		usb_put_phy(usb_phy);
+	} else
+		return 0;
 
 	dwc3_writel(dwc->regs, DWC3_DCTL, reg);
 
@@ -1454,6 +1782,11 @@ static int dwc3_gadget_pullup(struct usb_gadget *g, int is_on)
 
 	is_on = !!is_on;
 
+	if (dwc->soft_connected == is_on)
+		return 0;
+
+	dwc->soft_connected = is_on;
+
 	spin_lock_irqsave(&dwc->lock, flags);
 	ret = dwc3_gadget_run_stop(dwc, is_on);
 	spin_unlock_irqrestore(&dwc->lock, flags);
@@ -1470,6 +1803,7 @@ static void dwc3_gadget_enable_irq(struct dwc3 *dwc)
 			DWC3_DEVTEN_EVNTOVERFLOWEN |
 			DWC3_DEVTEN_CMDCMPLTEN |
 			DWC3_DEVTEN_ERRTICERREN |
+			DWC3_DEVTEN_HIBERNATIONREQEVTEN |
 			DWC3_DEVTEN_WKUPEVTEN |
 			DWC3_DEVTEN_ULSTCNGEN |
 			DWC3_DEVTEN_CONNECTDONEEN |
@@ -1488,13 +1822,11 @@ static void dwc3_gadget_disable_irq(struct dwc3 *dwc)
 static irqreturn_t dwc3_interrupt(int irq, void *_dwc);
 static irqreturn_t dwc3_thread_interrupt(int irq, void *_dwc);
 
-int dwc3_gadget_restart(struct dwc3 *dwc)
+static int dwc3_init_for_enumeration(struct dwc3 *dwc)
 {
+	struct dwc3_ep		*dep;
 	int			ret = 0;
 	u32			reg;
-	struct dwc3_ep		*dep;
-	
-	dwc->has_gadget = true;
 
 	reg = dwc3_readl(dwc->regs, DWC3_DCFG);
 	reg &= ~(DWC3_DCFG_SPEED_MASK);
@@ -1533,6 +1865,7 @@ int dwc3_gadget_restart(struct dwc3 *dwc)
 	}
 	dwc3_writel(dwc->regs, DWC3_DCFG, reg);
 
+	dwc->is_ebc = 0;
 	dwc->start_config_issued = false;
 
 	/* Start with SuperSpeed Default */
@@ -1542,14 +1875,14 @@ int dwc3_gadget_restart(struct dwc3 *dwc)
 	ret = __dwc3_gadget_ep_enable(dep, &dwc3_gadget_ep0_desc, NULL, false);
 	if (ret) {
 		dev_err(dwc->dev, "failed to enable %s\n", dep->name);
-		goto err0;
+		return ret;
 	}
 
 	dep = dwc->eps[1];
 	ret = __dwc3_gadget_ep_enable(dep, &dwc3_gadget_ep0_desc, NULL, false);
 	if (ret) {
 		dev_err(dwc->dev, "failed to enable %s\n", dep->name);
-		goto err1;
+		goto err0;
 	}
 
 	/* begin to receive SETUP packets */
@@ -1559,32 +1892,41 @@ int dwc3_gadget_restart(struct dwc3 *dwc)
 	dwc3_gadget_enable_irq(dwc);
 
 	return 0;
-
-err1:
-	__dwc3_gadget_ep_disable(dwc->eps[0]);
-
 err0:
-	dwc->gadget_driver = NULL;
+	__dwc3_gadget_ep_disable(dwc->eps[0]);
 
 	return ret;
 }
 
-
 static int dwc3_gadget_start(struct usb_gadget *g,
 		struct usb_gadget_driver *driver)
 {
 	struct dwc3		*dwc = gadget_to_dwc(g);
 	unsigned long		flags;
 	int			ret = 0;
-	int			irq;
+	int			irq = 0;
+	struct usb_phy		*usb_phy;
+
+	if (dwc->is_otg) {
+		usb_phy = usb_get_phy(USB_PHY_TYPE_USB2);
+		if (!usb_phy) {
+			dev_err(dwc->dev, "OTG driver not available\n");
+			ret = -ENODEV;
+			goto err0;
+		}
 
-	irq = platform_get_irq(to_platform_device(dwc->dev), 0);
-	ret = request_threaded_irq(irq, dwc3_interrupt, dwc3_thread_interrupt,
-			IRQF_SHARED, "dwc3", dwc);
-	if (ret) {
-		dev_err(dwc->dev, "failed to request irq #%d --> %d\n",
-				irq, ret);
-		goto err0;
+		otg_set_peripheral(usb_phy->otg, &dwc->gadget);
+		usb_put_phy(usb_phy);
+	} else {
+		irq = platform_get_irq(to_platform_device(dwc->dev), 0);
+		ret = request_threaded_irq(irq, dwc3_interrupt,
+				dwc3_thread_interrupt, IRQF_SHARED,
+				"dwc3", dwc);
+		if (ret) {
+			dev_err(dwc->dev, "failed to request irq #%d --> %d\n",
+					irq, ret);
+			goto err0;
+		}
 	}
 
 	spin_lock_irqsave(&dwc->lock, flags);
@@ -1599,30 +1941,28 @@ static int dwc3_gadget_start(struct usb_gadget *g,
 
 	dwc->gadget_driver	= driver;
 
-	ret = dwc3_gadget_restart(dwc);
-	if (ret)
-		goto err1;
+	if (!dwc->is_otg) {
+		ret = dwc3_init_for_enumeration(dwc);
+		if (ret)
+			goto err2;
+	}
 
 	spin_unlock_irqrestore(&dwc->lock, flags);
 
 	return 0;
-err1:
- 	spin_unlock_irqrestore(&dwc->lock, flags);
-	free_irq(irq, dwc);
-err0:
- 	return ret; 
-}
 
+err2:
+	dwc->gadget_driver = NULL;
 
-int dwc3_gadget_stop_on_switch(struct dwc3 *dwc)
-{
-	dwc->has_gadget = false;
-	__dwc3_gadget_ep_disable(dwc->eps[0]);
-	__dwc3_gadget_ep_disable(dwc->eps[1]);
+err1:
+	spin_unlock_irqrestore(&dwc->lock, flags);
 
-	return 0;
-}
+	if (!dwc->is_otg)
+		free_irq(irq, dwc);
 
+err0:
+	return ret;
+}
 
 static int dwc3_gadget_stop(struct usb_gadget *g,
 		struct usb_gadget_driver *driver)
@@ -1647,6 +1987,51 @@ static int dwc3_gadget_stop(struct usb_gadget *g,
 	return 0;
 }
 
+static int __dwc3_vbus_draw(struct dwc3 *dwc, unsigned ma)
+{
+	int		ret;
+	struct usb_phy	*usb_phy;
+
+	usb_phy = usb_get_phy(USB_PHY_TYPE_USB2);
+	if (!usb_phy) {
+		dev_err(dwc->dev, "OTG driver not available\n");
+		return -ENODEV;
+	}
+
+	ret = usb_phy_set_power(usb_phy, ma);
+	usb_put_phy(usb_phy);
+
+	return ret;
+}
+
+static int dwc3_vbus_draw(struct usb_gadget *g, unsigned ma)
+{
+	unsigned	ma_otg = 0;
+	struct dwc3	*dwc = gadget_to_dwc(g);
+
+	dev_dbg(dwc->dev, "otg_set_power: %d mA\n", ma);
+
+	switch (ma) {
+	case USB3_I_MAX_OTG:
+		ma_otg = OTG_USB3_900MA;
+		break;
+	case USB3_I_UNIT_OTG:
+		ma_otg = OTG_USB3_150MA;
+		break;
+	case USB2_I_MAX_OTG:
+		ma_otg = OTG_USB2_500MA;
+		break;
+	case USB2_I_UNIT_OTG:
+		ma_otg = OTG_USB2_100MA;
+		break;
+	default:
+		dev_err(dwc->dev,
+			"wrong charging current reported: %dmA\n", ma);
+	}
+
+	return __dwc3_vbus_draw(dwc, ma_otg);
+}
+
 static const struct usb_gadget_ops dwc3_gadget_ops = {
 	.get_frame		= dwc3_gadget_get_frame,
 	.wakeup			= dwc3_gadget_wakeup,
@@ -1662,6 +2047,7 @@ static int dwc3_gadget_init_hw_endpoints(struct dwc3 *dwc,
 		u8 num, u32 direction)
 {
 	struct dwc3_ep			*dep;
+	struct ebc_io			*ebc, *n;
 	u8				i;
 
 	for (i = 0; i < num; i++) {
@@ -1686,6 +2072,17 @@ static int dwc3_gadget_init_hw_endpoints(struct dwc3 *dwc,
 
 		dev_vdbg(dwc->dev, "initializing %s\n", dep->name);
 
+		list_for_each_entry_safe(ebc, n, &ebc_io_ops, list) {
+			if (epnum == ebc->epnum) {
+				dep->ebc = ebc;
+				if (ebc->init)
+					if (ebc->init() == -ENODEV)
+						dev_err(dwc->dev,
+						"debug class init fail %d\n",
+						epnum);
+			}
+		}
+
 		if (epnum == 0 || epnum == 1) {
 			usb_ep_set_maxpacket_limit(&dep->endpoint, 512);
 			dep->endpoint.maxburst = 1;
@@ -1886,7 +2283,7 @@ static int dwc3_cleanup_done_reqs(struct dwc3 *dwc, struct dwc3_ep *dep,
 			 */
 			dep->flags = DWC3_EP_PENDING_REQUEST;
 		} else {
-			dwc3_stop_active_transfer(dwc, dep->number);
+			dwc3_stop_active_transfer(dwc, dep->number, 1);
 			dep->flags = DWC3_EP_ENABLED;
 		}
 		return 1;
@@ -1970,8 +2367,9 @@ static void dwc3_endpoint_interrupt(struct dwc3 *dwc,
 		dwc3_endpoint_transfer_complete(dwc, dep, event, 1);
 		break;
 	case DWC3_DEPEVT_XFERINPROGRESS:
-		if (!usb_endpoint_xfer_isoc(dep->endpoint.desc)) {
-			dev_dbg(dwc->dev, "%s is not an Isochronous endpoint\n",
+		if ((!usb_endpoint_xfer_isoc(dep->endpoint.desc)) &&
+			(!usb_endpoint_xfer_bulk(dep->endpoint.desc))) {
+			dev_dbg(dwc->dev, "%s is not an Isochronous/bulk endpoint\n",
 					dep->name);
 			return;
 		}
@@ -2036,7 +2434,7 @@ static void dwc3_disconnect_gadget(struct dwc3 *dwc)
 	}
 }
 
-static void dwc3_stop_active_transfer(struct dwc3 *dwc, u32 epnum)
+static void dwc3_stop_active_transfer(struct dwc3 *dwc, u32 epnum, int forcerm)
 {
 	struct dwc3_ep *dep;
 	struct dwc3_gadget_ep_cmd_params params;
@@ -2045,6 +2443,31 @@ static void dwc3_stop_active_transfer(struct dwc3 *dwc, u32 epnum)
 
 	dep = dwc->eps[epnum];
 
+	if (dep->ebc) {
+		if (dep->ebc->is_ondemand == 1) {
+			ret = dwc3_gadget_update_ebc_ep_config(dwc, dep,
+				dep->endpoint.desc, dep->comp_desc, false);
+			if (ret < 0) {
+				dev_dbg(dwc->dev,
+					"DEPCFG failed on %s\n",
+					dep->name);
+				return;
+			}
+			dev_dbg(dwc->dev,
+				"successfully udpated DEPCFG command on %s\n",
+				dep->name);
+		}
+
+		if (dep->ebc->xfer_stop)
+			dep->ebc->xfer_stop();
+		else
+			dev_dbg(dwc->dev, "%s xfer_stop() NULL\n", dep->name);
+	}
+
+	if (usb_endpoint_xfer_isoc(dep->endpoint.desc))
+		dep->resource_index = dwc3_gadget_ep_get_transfer_index(dwc,
+				dep->number);
+
 	if (!dep->resource_index)
 		return;
 
@@ -2068,8 +2491,10 @@ static void dwc3_stop_active_transfer(struct dwc3 *dwc, u32 epnum)
 	 */
 
 	cmd = DWC3_DEPCMD_ENDTRANSFER;
-	cmd |= DWC3_DEPCMD_HIPRI_FORCERM | DWC3_DEPCMD_CMDIOC;
+	cmd |= DWC3_DEPCMD_CMDIOC;
 	cmd |= DWC3_DEPCMD_PARAM(dep->resource_index);
+	if (forcerm)
+		cmd |= DWC3_DEPCMD_HIPRI_FORCERM;
 	memset(&params, 0, sizeof(params));
 	ret = dwc3_send_gadget_ep_cmd(dwc, dep->number, cmd, &params);
 	WARN_ON_ONCE(ret);
@@ -2141,6 +2566,17 @@ static void dwc3_gadget_disconnect_interrupt(struct dwc3 *dwc)
 	dwc->setup_packet_pending = false;
 }
 
+static void link_state_change_work(struct work_struct *data)
+{
+	struct dwc3 *dwc = container_of((struct delayed_work *)data,
+			struct dwc3, link_work);
+
+	if (dwc->link_state == DWC3_LINK_STATE_U3) {
+		dev_info(dwc->dev, "device suspended; notify OTG\n");
+		__dwc3_vbus_draw(dwc, OTG_DEVICE_SUSPEND);
+	}
+}
+
 static void dwc3_gadget_reset_interrupt(struct dwc3 *dwc)
 {
 	u32			reg;
@@ -2260,22 +2696,26 @@ static void dwc3_gadget_conndone_interrupt(struct dwc3 *dwc)
 		dwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(512);
 		dwc->gadget.ep0->maxpacket = 512;
 		dwc->gadget.speed = USB_SPEED_SUPER;
+		__dwc3_vbus_draw(dwc, OTG_USB3_150MA);
 		break;
 	case DWC3_DCFG_HIGHSPEED:
 		dwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(64);
 		dwc->gadget.ep0->maxpacket = 64;
 		dwc->gadget.speed = USB_SPEED_HIGH;
+		__dwc3_vbus_draw(dwc, OTG_USB2_100MA);
 		break;
 	case DWC3_DCFG_FULLSPEED2:
 	case DWC3_DCFG_FULLSPEED1:
 		dwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(64);
 		dwc->gadget.ep0->maxpacket = 64;
 		dwc->gadget.speed = USB_SPEED_FULL;
+		__dwc3_vbus_draw(dwc, OTG_USB2_100MA);
 		break;
 	case DWC3_DCFG_LOWSPEED:
 		dwc3_gadget_ep0_desc.wMaxPacketSize = cpu_to_le16(8);
 		dwc->gadget.ep0->maxpacket = 8;
 		dwc->gadget.speed = USB_SPEED_LOW;
+		__dwc3_vbus_draw(dwc, OTG_USB2_100MA);
 		break;
 	}
 
@@ -2300,16 +2740,20 @@ static void dwc3_gadget_conndone_interrupt(struct dwc3 *dwc)
 	}
 
 	dep = dwc->eps[0];
-	ret = __dwc3_gadget_ep_enable(dep, &dwc3_gadget_ep0_desc, NULL, true);
+	ret = dwc3_gadget_set_ep_config(dwc, dep,
+			&dwc3_gadget_ep0_desc, NULL, false,
+			DWC3_DEPCFG_ACTION_MODIFY);
 	if (ret) {
-		dev_err(dwc->dev, "failed to enable %s\n", dep->name);
+		dev_err(dwc->dev, "failed to update %s\n", dep->name);
 		return;
 	}
 
 	dep = dwc->eps[1];
-	ret = __dwc3_gadget_ep_enable(dep, &dwc3_gadget_ep0_desc, NULL, true);
+	ret = dwc3_gadget_set_ep_config(dwc, dep,
+			&dwc3_gadget_ep0_desc, NULL, false,
+			DWC3_DEPCFG_ACTION_MODIFY);
 	if (ret) {
-		dev_err(dwc->dev, "failed to enable %s\n", dep->name);
+		dev_err(dwc->dev, "failed to update %s\n", dep->name);
 		return;
 	}
 
@@ -2326,6 +2770,9 @@ static void dwc3_gadget_wakeup_interrupt(struct dwc3 *dwc)
 {
 	dev_vdbg(dwc->dev, "%s\n", __func__);
 
+	dev_info(dwc->dev, "device resumed; notify OTG\n");
+	__dwc3_vbus_draw(dwc, OTG_DEVICE_RESUME);
+
 	/*
 	 * TODO take core out of low power mode when that's
 	 * implemented.
@@ -2415,12 +2862,26 @@ static void dwc3_gadget_linksts_change_interrupt(struct dwc3 *dwc,
 
 	dwc->link_state = next;
 
+	if (next ==  DWC3_LINK_STATE_U3)
+		schedule_delayed_work(
+			&dwc->link_work, msecs_to_jiffies(1000));
+
 	dev_vdbg(dwc->dev, "%s link %d\n", __func__, dwc->link_state);
 }
 
+static void dwc3_gadget_hibernation_interrupt(struct dwc3 *dwc)
+{
+	dev_vdbg(dwc->dev, "%s\n", __func__);
+
+	if (dwc->hiber_enabled)
+		pm_runtime_put(dwc->dev);
+}
+
 static void dwc3_gadget_interrupt(struct dwc3 *dwc,
 		const struct dwc3_event_devt *event)
 {
+	u32	reg;
+
 	switch (event->type) {
 	case DWC3_DEVICE_EVENT_DISCONNECT:
 		dwc3_gadget_disconnect_interrupt(dwc);
@@ -2437,6 +2898,9 @@ static void dwc3_gadget_interrupt(struct dwc3 *dwc,
 	case DWC3_DEVICE_EVENT_LINK_STATUS_CHANGE:
 		dwc3_gadget_linksts_change_interrupt(dwc, event->event_info);
 		break;
+	case DWC3_DEVICE_EVENT_HIBER_REQ:
+		dwc3_gadget_hibernation_interrupt(dwc);
+		break;
 	case DWC3_DEVICE_EVENT_EOPF:
 		dev_vdbg(dwc->dev, "End of Periodic Frame\n");
 		break;
@@ -2445,6 +2909,14 @@ static void dwc3_gadget_interrupt(struct dwc3 *dwc,
 		break;
 	case DWC3_DEVICE_EVENT_ERRATIC_ERROR:
 		dev_vdbg(dwc->dev, "Erratic Error\n");
+
+		/* Controller may generate too many Erratic Errors Messages,
+		 * Disable it until we find a way to recover the failure.
+		 */
+		reg = dwc3_readl(dwc->regs, DWC3_DEVTEN);
+		reg &= ~DWC3_DEVTEN_ERRTICERREN;
+		dwc3_writel(dwc->regs, DWC3_DEVTEN, reg);
+		dev_info(dwc->dev, "Erratic Error Event disabled\n");
 		break;
 	case DWC3_DEVICE_EVENT_CMD_CMPL:
 		dev_vdbg(dwc->dev, "Command Complete\n");
@@ -2571,6 +3043,15 @@ static irqreturn_t dwc3_interrupt(int irq, void *_dwc)
 	irqreturn_t			ret = IRQ_NONE;
 
 	spin_lock(&dwc->lock);
+	if (dwc->pm_state != PM_ACTIVE) {
+		if (dwc->pm_state == PM_SUSPENDED) {
+			dev_info(dwc->dev, "u2/u3 pmu is received\n");
+			pm_runtime_get(dwc->dev);
+			dwc->pm_state = PM_RESUMING;
+			ret = IRQ_HANDLED;
+		}
+		goto out;
+	}
 
 	for (i = 0; i < dwc->num_event_buffers; i++) {
 		irqreturn_t status;
@@ -2580,6 +3061,7 @@ static irqreturn_t dwc3_interrupt(int irq, void *_dwc)
 			ret = status;
 	}
 
+out:
 	spin_unlock(&dwc->lock);
 
 	return ret;
@@ -2595,6 +3077,23 @@ int dwc3_gadget_init(struct dwc3 *dwc)
 {
 	int					ret;
 
+	dwc->scratch_array = dma_alloc_coherent(dwc->dev,
+			sizeof(*dwc->scratch_array),
+			&dwc->scratch_array_dma, GFP_KERNEL);
+	if (!dwc->scratch_array) {
+		dev_err(dwc->dev, "failed to allocate scratch_arrary\n");
+		return -ENOMEM;
+	}
+
+	dwc->scratch_buffer[0] = dma_alloc_coherent(dwc->dev,
+			DWC3_SCRATCH_BUF_SIZE,
+			&dwc->scratch_array->dma_adr[0], GFP_KERNEL);
+	if (!dwc->scratch_buffer[0]) {
+		dev_err(dwc->dev, "failed to allocate scratch_buffer\n");
+		ret = -ENOMEM;
+		goto err;
+	}
+
 	dwc->ctrl_req = dma_alloc_coherent(dwc->dev, sizeof(*dwc->ctrl_req),
 			&dwc->ctrl_req_addr, GFP_KERNEL);
 	if (!dwc->ctrl_req) {
@@ -2627,7 +3126,6 @@ int dwc3_gadget_init(struct dwc3 *dwc)
 		goto err3;
 	}
 
-	dwc->has_gadget			= true;
 	dwc->gadget.ops			= &dwc3_gadget_ops;
 	dwc->gadget.max_speed		= USB_SPEED_SUPER;
 	dwc->gadget.speed		= USB_SPEED_UNKNOWN;
@@ -2640,6 +3138,8 @@ int dwc3_gadget_init(struct dwc3 *dwc)
 	 */
 	dwc->gadget.quirk_ep_out_aligned_size = true;
 
+	INIT_DELAYED_WORK(&dwc->link_work, link_state_change_work);
+
 	/*
 	 * REVISIT: Here we should clear all pending IRQs to be
 	 * sure we're starting from a well known location.
@@ -2674,6 +3174,13 @@ err1:
 			dwc->ctrl_req, dwc->ctrl_req_addr);
 
 err0:
+	dma_free_coherent(dwc->dev,
+			DWC3_SCRATCH_BUF_SIZE, dwc->scratch_buffer[0],
+			(dma_addr_t)dwc->scratch_array->dma_adr[0]);
+
+err:
+	dma_free_coherent(dwc->dev, sizeof(*dwc->scratch_array),
+			dwc->scratch_array, dwc->scratch_array_dma);
 	return ret;
 }
 
@@ -2681,7 +3188,6 @@ err0:
 
 void dwc3_gadget_exit(struct dwc3 *dwc)
 {
-	dwc->has_gadget = false;
 	usb_del_gadget_udc(&dwc->gadget);
 
 	dwc3_gadget_free_endpoints(dwc);
@@ -2696,6 +3202,13 @@ void dwc3_gadget_exit(struct dwc3 *dwc)
 
 	dma_free_coherent(dwc->dev, sizeof(*dwc->ctrl_req),
 			dwc->ctrl_req, dwc->ctrl_req_addr);
+
+	dma_free_coherent(dwc->dev,
+			DWC3_SCRATCH_BUF_SIZE, dwc->scratch_buffer[0],
+			(dma_addr_t)dwc->scratch_array->dma_adr[0]);
+
+	dma_free_coherent(dwc->dev, sizeof(*dwc->scratch_array),
+			dwc->scratch_array, dwc->scratch_array_dma);
 }
 
 int dwc3_gadget_prepare(struct dwc3 *dwc)
@@ -2756,3 +3269,359 @@ err1:
 err0:
 	return ret;
 }
+
+void dwc3_register_io_ebc(struct ebc_io *ebc)
+{
+	list_add_tail(&ebc->list, &ebc_io_ops);
+}
+
+void dwc3_unregister_io_ebc(struct ebc_io *ebc)
+{
+	list_del(&ebc->list);
+}
+
+#ifdef CONFIG_PM_RUNTIME
+static void dwc3_gadget_get_ep_state(struct dwc3 *dwc, struct dwc3_ep *dep)
+{
+	struct	dwc3_gadget_ep_cmd_params params;
+	int	ret;
+
+	dev_vdbg(dwc->dev, "%s\n", __func__);
+
+	memset(&params, 0, sizeof(params));
+	ret = dwc3_send_gadget_ep_cmd(dwc, dep->number,
+			DWC3_DEPCMD_GETEPSTATE, &params);
+	WARN_ON_ONCE(ret);
+
+	dep->ep_state = dwc3_readl(dwc->regs, DWC3_DEPCMDPAR2(dep->number));
+}
+
+static void dwc3_cache_hwregs(struct dwc3 *dwc)
+{
+	struct dwc3_hwregs	*regs = &dwc->hwregs;
+
+	dev_vdbg(dwc->dev, "%s\n", __func__);
+
+	regs->guctl = dwc3_readl(dwc->regs, DWC3_GUCTL);
+	regs->grxthrcfg = dwc3_readl(dwc->regs, DWC3_GRXTHRCFG);
+	regs->dcfg = dwc3_readl(dwc->regs, DWC3_DCFG);
+	regs->devten = dwc3_readl(dwc->regs, DWC3_DEVTEN);
+	regs->gctl = dwc3_readl(dwc->regs, DWC3_GCTL);
+	regs->gusb3pipectl0 = dwc3_readl(dwc->regs, DWC3_GUSB3PIPECTL(0));
+	regs->gusb2phycfg0 = dwc3_readl(dwc->regs, DWC3_GUSB2PHYCFG(0));
+	regs->gevntadrlo = dwc3_readl(dwc->regs, DWC3_GEVNTADRLO(0));
+	regs->gevntadrhi = dwc3_readl(dwc->regs, DWC3_GEVNTADRHI(0));
+	regs->gevntsiz = dwc3_readl(dwc->regs, DWC3_GEVNTSIZ(0));
+}
+
+static void dwc3_restore_hwregs(struct dwc3 *dwc)
+{
+	struct dwc3_hwregs	*regs = &dwc->hwregs;
+
+	dev_vdbg(dwc->dev, "%s\n", __func__);
+
+	dwc3_writel(dwc->regs, DWC3_GUCTL, regs->guctl);
+	dwc3_writel(dwc->regs, DWC3_GRXTHRCFG, regs->grxthrcfg);
+	dwc3_writel(dwc->regs, DWC3_GUSB3PIPECTL(0), regs->gusb3pipectl0);
+	dwc3_writel(dwc->regs, DWC3_GUSB2PHYCFG(0), regs->gusb2phycfg0);
+	dwc3_writel(dwc->regs, DWC3_GEVNTADRLO(0), regs->gevntadrlo);
+	dwc3_writel(dwc->regs, DWC3_GEVNTADRHI(0), regs->gevntadrhi);
+	dwc3_writel(dwc->regs, DWC3_GEVNTSIZ(0), regs->gevntsiz);
+	dwc3_writel(dwc->regs, DWC3_GEVNTCOUNT(0), 0);
+	dwc3_writel(dwc->regs, DWC3_DCFG, regs->dcfg);
+	dwc3_writel(dwc->regs, DWC3_DEVTEN, regs->devten);
+	dwc3_writel(dwc->regs, DWC3_GCTL, regs->gctl);
+}
+
+static int dwc3_gadget_controller_save_state(struct dwc3 *dwc)
+{
+	u32			reg;
+	u32			timeout = 1000;
+
+	dev_vdbg(dwc->dev, "---> %s()\n", __func__);
+
+	reg = dwc3_readl(dwc->regs, DWC3_DCTL);
+
+	reg |= DWC3_DCTL_CSS;
+	dwc3_writel(dwc->regs, DWC3_DCTL, reg);
+
+	do {
+		reg = dwc3_readl(dwc->regs, DWC3_DSTS);
+		if (!(reg & DWC3_DSTS_SSS))
+				return 0;
+
+		timeout--;
+		if (!timeout)
+			return -ETIMEDOUT;
+		udelay(1);
+	} while (1);
+
+	dev_vdbg(dwc->dev, "<--- %s()\n", __func__);
+}
+
+static int dwc3_gadget_controller_restore_state(struct dwc3 *dwc)
+{
+	u32			reg;
+	u32			timeout = 1000;
+
+	dev_vdbg(dwc->dev, "---> %s()\n", __func__);
+
+	reg = dwc3_readl(dwc->regs, DWC3_DCTL);
+
+	reg |= DWC3_DCTL_CRS;
+	dwc3_writel(dwc->regs, DWC3_DCTL, reg);
+
+	do {
+		reg = dwc3_readl(dwc->regs, DWC3_DSTS);
+		if (!(reg & DWC3_DSTS_RSS))
+				return 0;
+
+		timeout--;
+		if (!timeout)
+			return -ETIMEDOUT;
+		udelay(1);
+	} while (1);
+
+	dev_vdbg(dwc->dev, "<--- %s()\n", __func__);
+}
+
+void dwc3_gadget_keep_conn(struct dwc3 *dwc, int is_on)
+{
+	u32         reg;
+
+	reg = dwc3_readl(dwc->regs, DWC3_DCTL);
+	if (is_on)
+		reg |= DWC3_DCTL_KEEP_CONNECT;
+	else
+		reg &= ~DWC3_DCTL_KEEP_CONNECT;
+	dwc3_writel(dwc->regs, DWC3_DCTL, reg);
+}
+
+int dwc3_runtime_suspend(struct device *device)
+{
+	struct dwc3			*dwc;
+	struct platform_device		*pdev;
+	unsigned long			flags;
+	u32				epnum;
+	struct dwc3_ep			*dep;
+
+	pdev = to_platform_device(device);
+	dwc = platform_get_drvdata(pdev);
+
+	if (!dwc || !dwc->hiber_enabled)
+		return 0;
+
+	dev_vdbg(dwc->dev, "---> %s()\n", __func__);
+
+	spin_lock_irqsave(&dwc->lock, flags);
+
+	if (dwc->pm_state != PM_ACTIVE) {
+		spin_unlock_irqrestore(&dwc->lock, flags);
+		return 0;
+	}
+
+
+	for (epnum = 0; epnum < DWC3_ENDPOINTS_NUM; epnum++) {
+		dep = dwc->eps[epnum];
+		if (!(dep->flags & DWC3_EP_ENABLED))
+			continue;
+
+		dep->flags_backup = dep->flags;
+		if (dep->flags & DWC3_EP_BUSY)
+			dwc3_stop_active_transfer(dwc, epnum, 0);
+
+		dwc3_gadget_get_ep_state(dwc, dep);
+
+		dep->flags = DWC3_EP_HIBERNATION;
+	}
+
+	__dwc3_gadget_run_stop(dwc, 0);
+	dwc3_gadget_keep_conn(dwc, 1);
+
+	dwc3_cache_hwregs(dwc);
+
+	dwc3_gadget_disable_irq(dwc);
+	dwc3_event_buffers_cleanup(dwc);
+
+	dwc3_gadget_controller_save_state(dwc);
+
+	dwc->pm_state = PM_SUSPENDED;
+
+	spin_unlock_irqrestore(&dwc->lock, flags);
+
+	schedule_delayed_work(&dwc->link_work, msecs_to_jiffies(1000));
+	dev_info(dwc->dev, "suspended\n");
+	dev_vdbg(dwc->dev, "<--- %s()\n", __func__);
+
+	return 0;
+}
+
+int dwc3_runtime_resume(struct device *device)
+{
+	struct dwc3			*dwc;
+	struct platform_device		*pdev;
+	unsigned long			flags;
+	int				ret;
+	u32				epnum;
+	u32				timeout = 500;
+	u32				reg;
+	u8				link_state;
+	struct dwc3_ep			*dep;
+
+	pdev = to_platform_device(device);
+	dwc = platform_get_drvdata(pdev);
+
+	if (!dwc || !dwc->hiber_enabled)
+		return 0;
+
+	dev_vdbg(dwc->dev, "---> %s()\n", __func__);
+
+	spin_lock_irqsave(&dwc->lock, flags);
+
+	if (dwc->pm_state == PM_ACTIVE ||
+		dwc->pm_state == PM_DISCONNECTED) {
+		spin_unlock_irqrestore(&dwc->lock, flags);
+		return 0;
+	}
+
+	dwc3_send_gadget_generic_command(dwc, DWC3_DGCMD_SET_SCRATCH_ADDR_LO,
+		dwc->scratch_array_dma & 0xffffffffU);
+
+	dwc3_gadget_controller_restore_state(dwc);
+
+	dwc3_restore_hwregs(dwc);
+
+	dep = dwc->eps[0];
+	ret = __dwc3_gadget_ep_enable(dep, &dwc3_gadget_ep0_desc, NULL, false);
+	if (ret) {
+		dev_err(dwc->dev, "failed to enable %s during runtime resume\n",
+			dep->name);
+		goto err0;
+	}
+
+	dep = dwc->eps[1];
+	ret = __dwc3_gadget_ep_enable(dep, &dwc3_gadget_ep0_desc, NULL, false);
+	if (ret) {
+		dev_err(dwc->dev, "failed to enable %s during runtime resume\n",
+			dep->name);
+		goto err1;
+	}
+
+	for (epnum = 0; epnum < 2; epnum++) {
+		struct dwc3_gadget_ep_cmd_params params;
+
+		dep = dwc->eps[epnum];
+		if (dep->flags_backup & DWC3_EP_BUSY) {
+			dwc->ep0_trb->ctrl |= DWC3_TRB_CTRL_HWO;
+
+			memset(&params, 0, sizeof(params));
+			params.param0 = upper_32_bits(dwc->ep0_trb_addr);
+			params.param1 = lower_32_bits(dwc->ep0_trb_addr);
+
+			ret = dwc3_send_gadget_ep_cmd(dwc, epnum,
+					DWC3_DEPCMD_STARTTRANSFER, &params);
+			WARN_ON_ONCE(ret);
+		}
+
+		dep->flags = dep->flags_backup;
+		dep->flags_backup = 0;
+	}
+
+	__dwc3_gadget_run_stop(dwc, 1);
+	dwc3_gadget_keep_conn(dwc, 1);
+
+	do {
+		reg = dwc3_readl(dwc->regs, DWC3_DSTS);
+		if (!(reg & DWC3_DSTS_DCNRD))
+				break;
+
+		timeout--;
+		if (!timeout)
+			break;
+		udelay(1);
+	} while (1);
+
+	reg = dwc3_readl(dwc->regs, DWC3_DSTS);
+	link_state = DWC3_DSTS_USBLNKST(reg);
+	switch (link_state) {
+	case DWC3_LINK_STATE_U3:
+	case DWC3_LINK_STATE_RESUME:
+		dwc3_gadget_conndone_interrupt(dwc);
+
+		for (epnum = 2; epnum < DWC3_ENDPOINTS_NUM; epnum++) {
+			dep = dwc->eps[epnum];
+			if (!(dep->flags_backup & DWC3_EP_ENABLED))
+				continue;
+			if (dep->endpoint.desc)
+				dwc3_gadget_set_ep_config(dwc,
+					dep, dep->endpoint.desc, dep->comp_desc,
+					false, DWC3_DEPCFG_ACTION_RESTORE);
+
+			dwc3_gadget_set_xfer_resource(dwc, dep);
+
+			reg = dwc3_readl(dwc->regs, DWC3_DALEPENA);
+			reg |= DWC3_DALEPENA_EP(epnum);
+			dwc3_writel(dwc->regs, DWC3_DALEPENA, reg);
+
+			if (dep->flags_backup & DWC3_EP_STALL)
+				__dwc3_gadget_ep_set_halt(dep, 1, false);
+
+			if (dep->flags_backup & DWC3_EP_BUSY) {
+				struct dwc3_request			*req;
+				struct dwc3_gadget_ep_cmd_params	params;
+
+				req = next_request(&dep->req_queued);
+				if (!req)
+					break;
+				req->trb->ctrl |= DWC3_TRB_CTRL_HWO;
+				memset(&params, 0, sizeof(params));
+				params.param0 = upper_32_bits(req->trb_dma);
+				params.param1 = lower_32_bits(req->trb_dma);
+
+				ret = dwc3_send_gadget_ep_cmd(dwc, epnum,
+						DWC3_DEPCMD_STARTTRANSFER,
+						&params);
+				WARN_ON_ONCE(ret);
+
+			}
+
+			dep->flags = dep->flags_backup;
+			dep->flags_backup = 0;
+		}
+
+		reg = dwc3_readl(dwc->regs, DWC3_DCTL);
+		reg |= DWC3_DCTL_ULSTCHNG_RECOVERY;
+		dwc3_writel(dwc->regs, DWC3_DCTL, reg);
+
+		break;
+	case DWC3_LINK_STATE_RESET:
+		reg = dwc3_readl(dwc->regs, DWC3_DCTL);
+		reg |= DWC3_DCTL_ULSTCHNG_RECOVERY;
+		dwc3_writel(dwc->regs, DWC3_DCTL, reg);
+
+		break;
+	default:
+		/* wait for USB Reset or Connect Done event */
+		break;
+	}
+
+	dwc->pm_state = PM_ACTIVE;
+
+	spin_unlock_irqrestore(&dwc->lock, flags);
+
+	__dwc3_vbus_draw(dwc, OTG_DEVICE_RESUME);
+	dev_info(dwc->dev, "resumed\n");
+	dev_vdbg(dwc->dev, "<--- %s()\n", __func__);
+	return 0;
+
+err1:
+	__dwc3_gadget_ep_disable(dwc->eps[0]);
+
+err0:
+	spin_unlock_irqrestore(&dwc->lock, flags);
+
+	return ret;
+}
+#else
+void dwc3_gadget_keep_conn(struct dwc3 *dwc, int is_on) {}
+#endif
diff --git a/drivers/usb/dwc3/gadget.h b/drivers/usb/dwc3/gadget.h
index d22efa9..d77f634 100644
--- a/drivers/usb/dwc3/gadget.h
+++ b/drivers/usb/dwc3/gadget.h
@@ -27,6 +27,12 @@ struct dwc3;
 #define to_dwc3_ep(ep)		(container_of(ep, struct dwc3_ep, endpoint))
 #define gadget_to_dwc(g)	(container_of(g, struct dwc3, gadget))
 
+/* max power consumption of the device from the bus */
+#define USB3_I_MAX_OTG		896
+#define USB3_I_UNIT_OTG		144
+#define USB2_I_MAX_OTG		500
+#define USB2_I_UNIT_OTG		100
+
 /* DEPCFG parameter 1 */
 #define DWC3_DEPCFG_INT_NUM(n)		((n) << 0)
 #define DWC3_DEPCFG_XFER_COMPLETE_EN	(1 << 8)
@@ -34,6 +40,7 @@ struct dwc3;
 #define DWC3_DEPCFG_XFER_NOT_READY_EN	(1 << 10)
 #define DWC3_DEPCFG_FIFO_ERROR_EN	(1 << 11)
 #define DWC3_DEPCFG_STREAM_EVENT_EN	(1 << 13)
+#define DWC3_DEPCFG_EBC_MODE_EN		(1 << 15)
 #define DWC3_DEPCFG_BINTERVAL_M1(n)	((n) << 16)
 #define DWC3_DEPCFG_STREAM_CAPABLE	(1 << 24)
 #define DWC3_DEPCFG_EP_NUMBER(n)	((n) << 25)
@@ -103,10 +110,6 @@ static inline u32 dwc3_gadget_ep_get_transfer_index(struct dwc3 *dwc, u8 number)
 	return DWC3_DEPCMD_GET_RSC_IDX(res_id);
 }
 
-int dwc3_gadget_restart(struct dwc3 *dwc);
-int dwc3_gadget_stop_on_switch(struct dwc3 *dwc);
-
-
 /**
  * dwc3_gadget_event_string - returns event name
  * @event: the event code
diff --git a/drivers/usb/dwc3/host.c b/drivers/usb/dwc3/host.c
index 5a46d74..32db328 100644
--- a/drivers/usb/dwc3/host.c
+++ b/drivers/usb/dwc3/host.c
@@ -38,7 +38,6 @@ int dwc3_host_init(struct dwc3 *dwc)
 	xhci->dev.dma_parms	= dwc->dev->dma_parms;
 
 	dwc->xhci = xhci;
-	dwc->has_xhci = true;
 
 	ret = platform_device_add_resources(xhci, dwc->xhci_resources,
 						DWC3_XHCI_RESOURCES_NUM);
@@ -64,6 +63,5 @@ err0:
 
 void dwc3_host_exit(struct dwc3 *dwc)
 {
-	dwc->has_xhci = false;
 	platform_device_unregister(dwc->xhci);
 }
diff --git a/drivers/usb/dwc3/otg.c b/drivers/usb/dwc3/otg.c
new file mode 100644
index 0000000..31ee4b9
--- /dev/null
+++ b/drivers/usb/dwc3/otg.c
@@ -0,0 +1,1509 @@
+/*
+ * otg.c - Designware USB3 DRD Controller OTG driver
+ *
+ * Authors: Wang Yu <yu.y.wang@intel.com>
+ *		Synopsys inc
+ *
+ * Description:
+ *
+ * This driver is developed base on dwc_otg3.c which provided by
+ * Synopsys company. Yu removed some unused features from it,
+ * for example: HNP/SRP/ADP support. Because haven't use these features
+ * so far. And add charger detection support into the state machine.
+ * Support SDP/CDP/DCP/Micro-ACA/ACA-Dock and SE1 USB charger type.
+ *
+ * Beside that, make all hardware dependence as arguments, which need
+ * vendor to implemented by themselves. For example: VBus drive, USB ID
+ * pin value and so on.
+ *
+ * To enable this OTG driver, user have to call dwc3_otg_register API to
+ * regiter one dwc3_otg_hw_ops object which include all hardware
+ * dependent code.
+ *
+ * License:
+ * Below declaration is copy from Synopsys DWC3 SW 2.10a released README.txt.
+ *
+ * IMPORTANT:
+ *
+ * Synopsys SS USB3 Linux Driver Software and documentation (hereinafter,
+ * "Software") is an Unsupported proprietary work of Synopsys, Inc. unless
+ * otherwise expressly agreed to in writing between Synopsys and you.
+ *
+ * The Software IS NOT an item of Licensed Software or Licensed Product under
+ * any End User Software License Agreement or Agreement for Licensed Product
+ * with Synopsys or any supplement thereto. You are permitted to use and
+ * redistribute this Software in source and binary forms, with or without
+ * modification, provided that redistributions of source code must retain this
+ * notice. You may not view, use, disclose, copy or distribute this file or
+ * any information contained herein except pursuant to this license grant from
+ * Synopsys. If you do not agree with this notice, including the disclaimer
+ * below, then you are not authorized to use the Software.
+ *
+ * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON AN "AS IS" BASIS
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/usb/otg.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/freezer.h>
+#include <linux/delay.h>
+#include <linux/kthread.h>
+#include <linux/version.h>
+
+#include "otg.h"
+
+#define VERSION "2.10a"
+
+struct dwc3_otg_hw_ops *dwc3_otg_pdata;
+struct dwc_device_par *platform_par;
+
+static struct mutex lock;
+static const char driver_name[] = "dwc3_otg";
+static struct dwc_otg2 *the_transceiver;
+static void dwc_otg_remove(struct pci_dev *pdev);
+
+
+static inline struct dwc_otg2 *xceiv_to_dwc_otg2(struct usb_otg *x)
+{
+	return container_of(x, struct dwc_otg2, otg);
+}
+
+struct dwc_otg2 *dwc3_get_otg(void)
+{
+	return the_transceiver;
+}
+EXPORT_SYMBOL_GPL(dwc3_get_otg);
+
+/* Caller must hold otg->lock */
+void dwc3_wakeup_otg_thread(struct dwc_otg2 *otg)
+{
+	if (!otg->main_thread)
+		return;
+
+	otg_dbg(otg, "\n");
+	/* Tell the main thread that something has happened */
+	otg->main_wakeup_needed = 1;
+	wake_up_interruptible(&otg->main_wq);
+}
+EXPORT_SYMBOL_GPL(dwc3_wakeup_otg_thread);
+
+static int sleep_main_thread_timeout(struct dwc_otg2 *otg, int msecs)
+{
+	signed long jiffies;
+	int rc = msecs;
+
+	if (otg->state == DWC_STATE_EXIT) {
+		otg_dbg(otg, "Main thread exiting\n");
+		rc = -EINTR;
+		goto done;
+	}
+
+	if (signal_pending(current)) {
+		otg_dbg(otg, "Main thread signal pending\n");
+		rc = -EINTR;
+		goto done;
+	}
+	if (otg->main_wakeup_needed) {
+		otg_dbg(otg, "Main thread wakeup needed\n");
+		rc = msecs;
+		goto done;
+	}
+
+	jiffies = msecs_to_jiffies(msecs);
+	rc = wait_event_freezable_timeout(otg->main_wq,
+					otg->main_wakeup_needed,
+					jiffies);
+
+	if (otg->state == DWC_STATE_EXIT) {
+		otg_dbg(otg, "Main thread exiting\n");
+		rc = -EINTR;
+		goto done;
+	}
+
+	if (rc > 0)
+		rc = jiffies_to_msecs(rc);
+
+done:
+	otg->main_wakeup_needed = 0;
+	return rc;
+}
+
+static int sleep_main_thread(struct dwc_otg2 *otg)
+{
+	int rc = 0;
+
+	do {
+		rc = sleep_main_thread_timeout(otg, 5000);
+	} while (rc == 0);
+
+	return rc;
+}
+
+static void get_and_clear_events(struct dwc_otg2 *otg,
+				u32 otg_mask,
+				u32 user_mask,
+				u32 *otg_events,
+				u32 *user_events)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&otg->lock, flags);
+
+	if (otg_events) {
+		if (otg->otg_events & otg_mask) {
+			*otg_events = otg->otg_events;
+			otg->otg_events &= ~otg_mask;
+		} else
+			*otg_events = 0;
+	}
+
+	if (user_events) {
+		if (otg->user_events & user_mask) {
+			*user_events = otg->user_events;
+			otg->user_events &= ~user_mask;
+		} else
+			*user_events = 0;
+	}
+
+	spin_unlock_irqrestore(&otg->lock, flags);
+}
+
+static int check_event(struct dwc_otg2 *otg,
+		u32 otg_mask,
+		u32 user_mask,
+		u32 *otg_events,
+		u32 *user_events)
+{
+	get_and_clear_events(otg, otg_mask, user_mask,
+			otg_events, user_events);
+
+	otg_dbg(otg, "Event occurred:");
+
+	if (otg_events && (*otg_events & otg_mask)) {
+		otg_dbg(otg, "otg_events=0x%x, otg_mask=0x%x",
+				*otg_events, otg_mask);
+		return 1;
+	}
+
+	if (user_events && (*user_events & user_mask)) {
+		otg_dbg(otg, "user_events=0x%x, user_mask=0x%x",
+				*user_events, user_mask);
+		return 1;
+	}
+
+	return 0;
+}
+
+static int sleep_until_event(struct dwc_otg2 *otg,
+			u32 otg_mask, u32 user_mask,
+			u32 *otg_events, u32 *user_events,
+			int timeout)
+{
+	int rc = 0;
+
+	pm_runtime_mark_last_busy(otg->dev);
+	pm_runtime_put_autosuspend(otg->dev);
+	/* Wait until it occurs, or timeout, or interrupt. */
+	if (timeout) {
+		otg_dbg(otg, "Waiting for event (timeout=%d)...\n", timeout);
+		rc = sleep_main_thread_until_condition_timeout(otg,
+				check_event(otg, otg_mask,
+				user_mask, otg_events, user_events), timeout);
+	} else {
+		otg_dbg(otg, "Waiting for event (no timeout)...\n");
+		rc = sleep_main_thread_until_condition(otg,
+				check_event(otg, otg_mask,
+					user_mask, otg_events, user_events));
+	}
+	pm_runtime_get_sync(otg->dev);
+
+	/* Disable the events */
+	otg_write(otg, OEVTEN, 0);
+	otg_write(otg, ADPEVTEN, 0);
+
+	otg_dbg(otg, "Woke up rc=%d\n", rc);
+
+	return rc;
+}
+
+
+static int start_host(struct dwc_otg2 *otg)
+{
+	int ret = 0;
+	struct usb_hcd *hcd = NULL;
+
+	otg_dbg(otg, "\n");
+
+	if (!otg->otg.host) {
+		otg_err(otg, "Haven't set host yet!\n");
+		return -ENODEV;
+	}
+
+	if (dwc3_otg_pdata->prepare_start_host)
+		ret = dwc3_otg_pdata->prepare_start_host(otg);
+
+	/* Start host driver */
+	hcd = container_of(otg->otg.host, struct usb_hcd, self);
+	ret = otg->start_host(hcd);
+
+	return ret;
+}
+
+static int stop_host(struct dwc_otg2 *otg)
+{
+	int ret = -1;
+	struct usb_hcd *hcd = NULL;
+
+	otg_dbg(otg, "\n");
+
+	hcd = container_of(otg->otg.host, struct usb_hcd, self);
+	if (otg->otg.host)
+		ret = otg->stop_host(hcd);
+
+	if (dwc3_otg_pdata->after_stop_host)
+		ret = dwc3_otg_pdata->after_stop_host(otg);
+
+	return ret;
+}
+
+static void start_peripheral(struct dwc_otg2 *otg)
+{
+	struct usb_gadget *gadget;
+	int ret;
+
+	if (dwc3_otg_pdata->prepare_start_peripheral)
+		ret = dwc3_otg_pdata->prepare_start_peripheral(otg);
+
+	gadget = otg->otg.gadget;
+	if (!gadget) {
+		otg_err(otg, "Haven't set gadget yet!\n");
+		return;
+	}
+
+	otg->start_device(gadget);
+}
+
+static void stop_peripheral(struct dwc_otg2 *otg)
+{
+	struct usb_gadget *gadget = otg->otg.gadget;
+	int ret;
+
+	if (!gadget)
+		return;
+
+	otg->stop_device(gadget);
+
+	if (dwc3_otg_pdata->after_stop_peripheral)
+		ret = dwc3_otg_pdata->after_stop_peripheral(otg);
+}
+
+static int get_id(struct dwc_otg2 *otg)
+{
+	if (dwc3_otg_pdata->get_id)
+		return dwc3_otg_pdata->get_id(otg);
+	return RID_UNKNOWN;
+}
+
+static int dwc_otg_notify_charger_type(struct dwc_otg2 *otg,
+		enum power_supply_charger_event event)
+{
+	if (dwc3_otg_pdata->notify_charger_type)
+		return dwc3_otg_pdata->notify_charger_type(otg, event);
+
+	return 0;
+}
+
+static int dwc_otg_get_chrg_status(struct usb_phy *x, void *data)
+{
+	unsigned long flags;
+	struct power_supply_cable_props *cap =
+		(struct power_supply_cable_props *)data;
+	struct dwc_otg2 *otg = the_transceiver;
+
+	if (!x)
+		return -ENODEV;
+
+	if (!data)
+		return -EINVAL;
+
+	spin_lock_irqsave(&otg->lock, flags);
+	cap->chrg_type = otg->charging_cap.chrg_type;
+	cap->chrg_evt = otg->charging_cap.chrg_evt;
+	cap->ma = otg->charging_cap.ma;
+	spin_unlock_irqrestore(&otg->lock, flags);
+
+	return 0;
+}
+
+static int dwc_otg_enable_vbus(struct dwc_otg2 *otg, int enable)
+{
+	if (dwc3_otg_pdata->enable_vbus)
+		return dwc3_otg_pdata->enable_vbus(otg, enable);
+
+	return -EINVAL;
+}
+
+static int is_self_powered_b_device(struct dwc_otg2 *otg)
+{
+	return get_id(otg) == RID_GND;
+}
+
+static enum dwc_otg_state do_wait_vbus_raise(struct dwc_otg2 *otg)
+{
+	int ret;
+	u32 otg_events = 0;
+	u32 user_events = 0;
+	u32 otg_mask = 0;
+	u32 user_mask = 0;
+
+	otg_mask = OEVT_B_DEV_SES_VLD_DET_EVNT;
+
+	ret = sleep_until_event(otg, otg_mask,
+			user_mask, &otg_events,
+			&user_events, VBUS_TIMEOUT);
+	if (ret < 0)
+		return DWC_STATE_EXIT;
+
+	if (otg_events & OEVT_B_DEV_SES_VLD_DET_EVNT) {
+		otg_dbg(otg, "OEVT_B_SES_VLD_EVT\n");
+		return DWC_STATE_CHARGER_DETECTION;
+	}
+
+	/* timeout*/
+	if (!ret)
+		return DWC_STATE_A_HOST;
+
+	return DWC_STATE_B_IDLE;
+}
+
+static enum dwc_otg_state do_wait_vbus_fall(struct dwc_otg2 *otg)
+{
+	int ret;
+
+	u32 otg_events = 0;
+	u32 user_events = 0;
+	u32 otg_mask = 0;
+	u32 user_mask = 0;
+
+	otg_mask = OEVT_A_DEV_SESS_END_DET_EVNT;
+
+	ret = sleep_until_event(otg, otg_mask,
+			user_mask, &otg_events,
+			&user_events, VBUS_TIMEOUT);
+	if (ret < 0)
+		return DWC_STATE_EXIT;
+
+	if (otg_events & OEVT_A_DEV_SESS_END_DET_EVNT) {
+		otg_dbg(otg, "OEVT_A_DEV_SESS_END_DET_EVNT\n");
+		if (otg->charging_cap.chrg_type ==
+				POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK)
+			dwc_otg_notify_charger_type(otg,
+				POWER_SUPPLY_CHARGER_EVENT_DISCONNECT);
+		return DWC_STATE_B_IDLE;
+	}
+
+	/* timeout*/
+	if (!ret) {
+		otg_err(otg, "Haven't get VBus drop event! Maybe something wrong\n");
+		return DWC_STATE_B_IDLE;
+	}
+
+	return DWC_STATE_INVALID;
+}
+
+static enum dwc_otg_state do_charging(struct dwc_otg2 *otg)
+{
+	int ret;
+	u32 otg_events = 0;
+	u32 user_events = 0;
+	u32 otg_mask = 0;
+	u32 user_mask = 0;
+
+	otg_mask = OEVT_A_DEV_SESS_END_DET_EVNT;
+
+	if (dwc3_otg_pdata->do_charging)
+		dwc3_otg_pdata->do_charging(otg);
+
+	ret = sleep_until_event(otg, otg_mask,
+			user_mask, &otg_events,
+			&user_events, 0);
+	if (ret < 0)
+		return DWC_STATE_EXIT;
+
+	if (otg_events & OEVT_A_DEV_SESS_END_DET_EVNT) {
+		otg_dbg(otg, "OEVT_A_DEV_SESS_END_DET_EVNT\n");
+		dwc_otg_notify_charger_type(otg,
+				POWER_SUPPLY_CHARGER_EVENT_DISCONNECT);
+		return DWC_STATE_B_IDLE;
+	}
+
+	return DWC_STATE_INVALID;
+}
+
+static enum power_supply_charger_cable_type
+		get_charger_type(struct dwc_otg2 *otg)
+{
+	if (dwc3_otg_pdata->get_charger_type)
+		return dwc3_otg_pdata->get_charger_type(otg);
+
+	return POWER_SUPPLY_CHARGER_TYPE_NONE;
+}
+
+static enum dwc_otg_state do_charger_detection(struct dwc_otg2 *otg)
+{
+	enum dwc_otg_state state = DWC_STATE_INVALID;
+	enum power_supply_charger_cable_type charger =
+			POWER_SUPPLY_CHARGER_TYPE_NONE;
+	unsigned long flags, ma = 0;
+
+	charger = get_charger_type(otg);
+	switch (charger) {
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_A:
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_B:
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_C:
+		otg_err(otg, "Ignore micro ACA charger.\n");
+		charger = POWER_SUPPLY_CHARGER_TYPE_NONE;
+		break;
+	case POWER_SUPPLY_CHARGER_TYPE_USB_SDP:
+	case POWER_SUPPLY_CHARGER_TYPE_USB_CDP:
+		state = DWC_STATE_B_PERIPHERAL;
+		break;
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK:
+		state = DWC_STATE_A_HOST;
+		break;
+	case POWER_SUPPLY_CHARGER_TYPE_USB_DCP:
+	case POWER_SUPPLY_CHARGER_TYPE_SE1:
+		state = DWC_STATE_CHARGING;
+		break;
+	case POWER_SUPPLY_CHARGER_TYPE_NONE:
+	default:
+		if (is_self_powered_b_device(otg)) {
+			state = DWC_STATE_A_HOST;
+			charger = POWER_SUPPLY_CHARGER_TYPE_B_DEVICE;
+			break;
+		}
+	};
+
+	switch (charger) {
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK:
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_A:
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_B:
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_C:
+	case POWER_SUPPLY_CHARGER_TYPE_USB_DCP:
+	case POWER_SUPPLY_CHARGER_TYPE_USB_CDP:
+	case POWER_SUPPLY_CHARGER_TYPE_SE1:
+		ma = 1500;
+		break;
+	case POWER_SUPPLY_CHARGER_TYPE_USB_SDP:
+		/* Notify SDP current is 100ma before enumeration. */
+		ma = 100;
+		break;
+	default:
+		otg_err(otg, "Charger type is not valid to notify battery\n");
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&otg->lock, flags);
+	otg->charging_cap.chrg_type = charger;
+	otg->charging_cap.ma = ma;
+	spin_unlock_irqrestore(&otg->lock, flags);
+
+	switch (charger) {
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK:
+	case POWER_SUPPLY_CHARGER_TYPE_USB_DCP:
+	case POWER_SUPPLY_CHARGER_TYPE_USB_CDP:
+	case POWER_SUPPLY_CHARGER_TYPE_SE1:
+		if (dwc_otg_notify_charger_type(otg,
+					POWER_SUPPLY_CHARGER_EVENT_CONNECT) < 0)
+			otg_err(otg, "Notify battery type failed!\n");
+		break;
+	case POWER_SUPPLY_CHARGER_TYPE_USB_SDP:
+	/* SDP is complicate, it will be handle in set_power */
+	default:
+		break;
+	}
+
+	return state;
+}
+
+static enum dwc_otg_state do_connector_id_status(struct dwc_otg2 *otg)
+{
+	int ret;
+	unsigned long flags;
+	u32 events = 0, user_events = 0;
+	u32 otg_mask = 0, user_mask = 0;
+
+	otg_dbg(otg, "\n");
+	spin_lock_irqsave(&otg->lock, flags);
+	otg->charging_cap.chrg_type = POWER_SUPPLY_CHARGER_TYPE_NONE;
+	otg->charging_cap.ma = 0;
+	otg->charging_cap.chrg_evt = POWER_SUPPLY_CHARGER_EVENT_DISCONNECT;
+	spin_unlock_irqrestore(&otg->lock, flags);
+
+stay_b_idle:
+	otg_mask = OEVT_CONN_ID_STS_CHNG_EVNT |
+			OEVT_B_DEV_SES_VLD_DET_EVNT;
+
+	user_mask = USER_ID_B_CHANGE_EVENT |
+				USER_ID_A_CHANGE_EVENT;
+
+	if (dwc3_otg_pdata->b_idle)
+		dwc3_otg_pdata->b_idle(otg);
+
+	ret = sleep_until_event(otg, otg_mask,
+			user_mask, &events,
+			&user_events, 0);
+	if (ret < 0)
+		return DWC_STATE_EXIT;
+
+	if (events & OEVT_B_DEV_SES_VLD_DET_EVNT) {
+		otg_dbg(otg, "OEVT_B_DEV_SES_VLD_DET_EVNT\n");
+		return DWC_STATE_CHARGER_DETECTION;
+	}
+
+	if (events & OEVT_CONN_ID_STS_CHNG_EVNT) {
+		otg_dbg(otg, "OEVT_CONN_ID_STS_CHNG_EVNT\n");
+
+		/* Prevent user fast plug out after plug in.
+		 * It will cause the first ID change event lost.
+		 * So need to check real ID currently.
+		 */
+		if (get_id(otg) == RID_FLOAT) {
+			otg_dbg(otg, "Stay DWC_STATE_INIT\n");
+			goto stay_b_idle;
+		}
+		return DWC_STATE_WAIT_VBUS_RAISE;
+	}
+
+	if (user_events & USER_ID_A_CHANGE_EVENT) {
+		otg_dbg(otg, "events is user id A change\n");
+		return DWC_STATE_A_HOST;
+	}
+
+	if (user_events & USER_ID_B_CHANGE_EVENT) {
+		otg_dbg(otg, "events is user id B change\n");
+		return DWC_STATE_B_PERIPHERAL;
+	}
+
+	return DWC_STATE_B_IDLE;
+}
+
+static enum dwc_otg_state do_a_host(struct dwc_otg2 *otg)
+{
+	int rc = 0;
+	u32 otg_events, user_events, otg_mask, user_mask;
+	int id = RID_UNKNOWN;
+	unsigned long flags;
+
+	if (otg->charging_cap.chrg_type !=
+			POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK) {
+		dwc_otg_enable_vbus(otg, 1);
+
+		/* meant receive vbus valid event*/
+		if (do_wait_vbus_raise(otg) == DWC_STATE_A_HOST)
+			otg_err(otg, "Drive VBUS maybe fail!\n");
+	}
+
+	rc = start_host(otg);
+	if (rc < 0) {
+		stop_host(otg);
+		otg_err(otg, "start_host failed!");
+		return DWC_STATE_INVALID;
+	}
+
+stay_host:
+	otg_events = 0;
+	user_events = 0;
+
+	user_mask = USER_A_BUS_DROP |
+				USER_ID_B_CHANGE_EVENT;
+	otg_mask = OEVT_CONN_ID_STS_CHNG_EVNT |
+			OEVT_A_DEV_SESS_END_DET_EVNT;
+
+	rc = sleep_until_event(otg,
+			otg_mask, user_mask,
+			&otg_events, &user_events, 0);
+	if (rc < 0) {
+		stop_host(otg);
+		return DWC_STATE_EXIT;
+	}
+
+	/* Higher priority first */
+	if (otg_events & OEVT_A_DEV_SESS_END_DET_EVNT) {
+		otg_dbg(otg, "OEVT_A_DEV_SESS_END_DET_EVNT\n");
+
+		/* ACA-Dock plug out */
+		if (otg->charging_cap.chrg_type ==
+				POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK)
+			dwc_otg_notify_charger_type(otg,
+					POWER_SUPPLY_CHARGER_EVENT_DISCONNECT);
+		else
+			dwc_otg_enable_vbus(otg, 0);
+
+		stop_host(otg);
+		return DWC_STATE_B_IDLE;
+	}
+
+	if (user_events & USER_A_BUS_DROP) {
+		/* Due to big consume by DUT, even ACA-Dock connected,
+		 * the battery capability still maybe decrease. For this
+		 * case, still save host mode. Because DUT haven't drive VBus.*/
+		if (otg->charging_cap.chrg_type ==
+				POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK)
+			goto stay_host;
+
+		dwc_otg_enable_vbus(otg, 0);
+		stop_host(otg);
+		return DWC_STATE_B_IDLE;
+	}
+
+	if (otg_events & OEVT_CONN_ID_STS_CHNG_EVNT) {
+		otg_dbg(otg, "OEVT_CONN_ID_STS_CHNG_EVNT\n");
+		id = get_id(otg);
+
+		/* Plug out ACA_DOCK/USB device */
+		if (id == RID_FLOAT) {
+			if (otg->charging_cap.chrg_type ==
+					POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK) {
+				/* ACA_DOCK plug out, receive
+				 * id change prior to vBus change
+				 */
+				stop_host(otg);
+			} else {
+				/* Normal USB device plug out */
+				spin_lock_irqsave(&otg->lock, flags);
+				otg->charging_cap.chrg_type =
+					POWER_SUPPLY_CHARGER_TYPE_NONE;
+				spin_unlock_irqrestore(&otg->lock, flags);
+
+				stop_host(otg);
+				dwc_otg_enable_vbus(otg, 0);
+			}
+		} else if (id == RID_GND || id == RID_A) {
+			otg_dbg(otg, "Stay DWC_STATE_A_HOST!!\n");
+			/* Prevent user fast plug in after plug out.
+			 * It will cause the first ID change event lost.
+			 * So need to check real ID currently.
+			 */
+			goto stay_host;
+		} else {
+			otg_err(otg, "Meet invalid charger cases!");
+			spin_lock_irqsave(&otg->lock, flags);
+			otg->charging_cap.chrg_type =
+				POWER_SUPPLY_CHARGER_TYPE_NONE;
+			spin_unlock_irqrestore(&otg->lock, flags);
+
+			stop_host(otg);
+		}
+		return DWC_STATE_WAIT_VBUS_FALL;
+	}
+
+	/* Higher priority first */
+	if (user_events & USER_ID_B_CHANGE_EVENT) {
+		otg_dbg(otg, "USER_ID_B_CHANGE_EVENT\n");
+		stop_host(otg);
+		otg->user_events |= USER_ID_B_CHANGE_EVENT;
+		return DWC_STATE_B_IDLE;
+	}
+
+	/* Invalid state */
+	return DWC_STATE_INVALID;
+}
+
+static int do_b_peripheral(struct dwc_otg2 *otg)
+{
+	int rc = 0;
+	u32 otg_mask, user_mask, otg_events, user_events;
+
+	otg_mask = 0;
+	user_mask = 0;
+	otg_events = 0;
+	user_events = 0;
+
+	otg_mask = OEVT_A_DEV_SESS_END_DET_EVNT;
+	user_mask = USER_ID_A_CHANGE_EVENT;
+
+	rc = sleep_until_event(otg,
+			otg_mask, user_mask,
+			&otg_events, &user_events, 0);
+	if (rc < 0)
+		return DWC_STATE_EXIT;
+
+	if (otg_events & OEVT_A_DEV_SESS_END_DET_EVNT) {
+		otg_dbg(otg, "OEVT_A_DEV_SESS_END_DET_EVNT\n");
+		dwc_otg_notify_charger_type(otg,
+				POWER_SUPPLY_CHARGER_EVENT_DISCONNECT);
+		return DWC_STATE_B_IDLE;
+	}
+
+	if (user_events & USER_ID_A_CHANGE_EVENT) {
+		otg_dbg(otg, "USER_ID_A_CHANGE_EVENT\n");
+		otg->user_events |= USER_ID_A_CHANGE_EVENT;
+		return DWC_STATE_B_IDLE;
+	}
+
+	return DWC_STATE_INVALID;
+}
+
+/* Charger driver may send ID change and VBus change event to OTG driver.
+ * This is like IRQ handler, just the event source is from charger driver.
+ * Because on Merrifield platform, the ID line and VBus line are connect to
+ * PMic which can make USB controller and PHY power off to save power.
+ */
+static int dwc_otg_handle_notification(struct notifier_block *nb,
+		unsigned long event, void *data)
+{
+	if (dwc3_otg_pdata->otg_notifier_handler)
+		return dwc3_otg_pdata->otg_notifier_handler(nb, event, data);
+
+	return NOTIFY_DONE;
+}
+
+int otg_main_thread(void *data)
+{
+	struct dwc_otg2 *otg = (struct dwc_otg2 *)data;
+
+	/* Allow the thread to be killed by a signal, but set the signal mask
+	 * to block everything but INT, TERM, KILL, and USR1. */
+	allow_signal(SIGINT);
+	allow_signal(SIGTERM);
+	allow_signal(SIGKILL);
+	allow_signal(SIGUSR1);
+
+	pm_runtime_get_sync(otg->dev);
+
+	/* Allow the thread to be frozen */
+	set_freezable();
+
+	otg_dbg(otg, "Thread running\n");
+	while (otg->state != DWC_STATE_TERMINATED) {
+		int next = DWC_STATE_B_IDLE;
+		otg_dbg(otg, "\n\n\nMain thread entering state\n");
+
+		switch (otg->state) {
+		case DWC_STATE_B_IDLE:
+			otg_dbg(otg, "DWC_STATE_B_IDLE\n");
+			next = do_connector_id_status(otg);
+			break;
+		case DWC_STATE_CHARGER_DETECTION:
+			otg_dbg(otg, "DWC_STATE_CHARGER_DETECTION\n");
+			next = do_charger_detection(otg);
+			break;
+		case DWC_STATE_WAIT_VBUS_RAISE:
+			otg_dbg(otg, "DWC_STATE_WAIT_VBUS_RAISE\n");
+			next = do_wait_vbus_raise(otg);
+			break;
+		case DWC_STATE_WAIT_VBUS_FALL:
+			otg_dbg(otg, "DWC_STATE_WAIT_VBUS_FALL\n");
+			next = do_wait_vbus_fall(otg);
+			break;
+		case DWC_STATE_CHARGING:
+			otg_dbg(otg, "DWC_STATE_CHARGING\n");
+			next = do_charging(otg);
+			break;
+		case DWC_STATE_A_HOST:
+			otg_dbg(otg, "DWC_STATE_A_HOST\n");
+			next = do_a_host(otg);
+			break;
+		case DWC_STATE_B_PERIPHERAL:
+			otg_dbg(otg, "DWC_STATE_B_PERIPHERAL\n");
+			start_peripheral(otg);
+			next = do_b_peripheral(otg);
+
+			stop_peripheral(otg);
+			break;
+		case DWC_STATE_EXIT:
+			otg_dbg(otg, "DWC_STATE_EXIT\n");
+			next = DWC_STATE_TERMINATED;
+			break;
+		case DWC_STATE_INVALID:
+			otg_dbg(otg, "DWC_STATE_INVALID!!!\n");
+		default:
+			otg_dbg(otg, "Unknown State %d, sleeping...\n",
+					otg->state);
+			sleep_main_thread(otg);
+			break;
+		}
+
+		otg->prev = otg->state;
+		otg->state = next;
+	}
+
+	pm_runtime_mark_last_busy(otg->dev);
+	pm_runtime_put_autosuspend(otg->dev);
+	otg->main_thread = NULL;
+	otg_dbg(otg, "OTG main thread exiting....\n");
+
+	return 0;
+}
+
+static void start_main_thread(struct dwc_otg2 *otg)
+{
+	enum dwc3_otg_mode mode = dwc3_otg_pdata->mode;
+	bool children_ready = false;
+
+	mutex_lock(&lock);
+
+	if ((mode == DWC3_DEVICE_ONLY) &&
+			otg->otg.gadget)
+		children_ready = true;
+
+	if ((mode == DWC3_HOST_ONLY) &&
+			otg->otg.host)
+		children_ready = true;
+
+	if ((mode == DWC3_DRD) &&
+			otg->otg.host && otg->otg.gadget)
+		children_ready = true;
+
+	if (!otg->main_thread && children_ready) {
+		otg_dbg(otg, "Starting OTG main thread\n");
+		otg->main_thread = kthread_create(otg_main_thread, otg, "otg");
+		wake_up_process(otg->main_thread);
+	}
+	mutex_unlock(&lock);
+}
+
+static void stop_main_thread(struct dwc_otg2 *otg)
+{
+	mutex_lock(&lock);
+	if (otg->main_thread) {
+		otg_dbg(otg, "Stopping OTG main thread\n");
+		otg->state = DWC_STATE_EXIT;
+		dwc3_wakeup_otg_thread(otg);
+	}
+	mutex_unlock(&lock);
+}
+
+static int dwc_otg2_set_peripheral(struct usb_otg *x,
+		struct usb_gadget *gadget)
+{
+	struct dwc_otg2 *otg;
+
+	if (!x) {
+		otg_err(otg, "otg is NULL!\n");
+		return -ENODEV;
+	}
+
+	otg = xceiv_to_dwc_otg2(x);
+	otg_dbg(otg, "\n");
+
+	if (!gadget) {
+		otg->otg.gadget = NULL;
+		stop_main_thread(otg);
+		return -ENODEV;
+	}
+
+	otg->otg.gadget = gadget;
+	otg->usb2_phy.state = OTG_STATE_B_IDLE;
+	start_main_thread(otg);
+	return 0;
+}
+
+static int dwc_otg2_set_host(struct usb_otg *x, struct usb_bus *host)
+{
+	struct dwc_otg2 *otg;
+
+	if (!x) {
+		otg_dbg(otg, "otg is NULL!\n");
+		return -ENODEV;
+	}
+
+	otg = xceiv_to_dwc_otg2(x);
+	otg_dbg(otg, "\n");
+
+	if (!host) {
+		otg->otg.host = NULL;
+		stop_main_thread(otg);
+		return -ENODEV;
+	}
+
+	otg->otg.host = host;
+	start_main_thread(otg);
+	return 0;
+}
+
+static int ulpi_read(struct usb_phy *phy, u32 reg)
+{
+	struct dwc_otg2 *otg = container_of(phy, struct dwc_otg2, usb2_phy);
+	u32 val32 = 0, count = 200;
+	u8 val, tmp;
+
+	reg &= 0xFF;
+
+	while (count) {
+		if (otg_read(otg, GUSB2PHYACC0) & GUSB2PHYACC0_VSTSBSY)
+			udelay(5);
+		else
+			break;
+
+		count--;
+	}
+
+	if (!count) {
+		otg_err(otg, "USB2 PHY always busy!!\n");
+		return -EBUSY;
+	}
+
+	count = 200;
+	/* Determine if use extend registers access */
+	if (reg & EXTEND_ULPI_REGISTER_ACCESS_MASK) {
+		otg_dbg(otg, "Access extend registers 0x%x\n", reg);
+		val32 = GUSB2PHYACC0_NEWREGREQ
+			| GUSB2PHYACC0_REGADDR(ULPI_ACCESS_EXTENDED)
+			| GUSB2PHYACC0_VCTRL(reg);
+	} else {
+		otg_dbg(otg, "Access normal registers 0x%x\n", reg);
+		val32 = GUSB2PHYACC0_NEWREGREQ | GUSB2PHYACC0_REGADDR(reg)
+			| GUSB2PHYACC0_VCTRL(0x00);
+	}
+	otg_write(otg, GUSB2PHYACC0, val32);
+
+	while (count) {
+		if (otg_read(otg, GUSB2PHYACC0) & GUSB2PHYACC0_VSTSDONE) {
+			val = otg_read(otg, GUSB2PHYACC0) &
+				  GUSB2PHYACC0_REGDATA_MASK;
+			otg_dbg(otg, "%s - reg 0x%x data 0x%x\n",
+					__func__, reg, val);
+			goto cleanup;
+		}
+
+		count--;
+	}
+
+	otg_err(otg, "%s read PHY data failed.\n", __func__);
+
+	return -ETIMEDOUT;
+
+cleanup:
+	/* Clear GUSB2PHYACC0[16:21] before return.
+	 * Otherwise, it will cause PHY can't in workable
+	 * state. This is one dwc3 controller silicon bug. */
+	tmp = otg_read(otg, GUSB2PHYACC0);
+	otg_write(otg, GUSB2PHYACC0, tmp &
+			~GUSB2PHYACC0_REGADDR(0x3F));
+	return val;
+}
+
+static int ulpi_write(struct usb_phy *phy, u32 val, u32 reg)
+{
+	struct dwc_otg2 *otg = container_of(phy, struct dwc_otg2, usb2_phy);
+	u32 val32 = 0, count = 200;
+	u8 tmp;
+
+	val &= 0xFF;
+	reg &= 0xFF;
+
+	while (count) {
+		if (otg_read(otg, GUSB2PHYACC0) & GUSB2PHYACC0_VSTSBSY)
+			udelay(5);
+		else
+			break;
+
+		count--;
+	}
+
+	if (!count) {
+		otg_err(otg, "USB2 PHY always busy!!\n");
+		return -EBUSY;
+	}
+
+	count = 200;
+
+	if (reg & EXTEND_ULPI_REGISTER_ACCESS_MASK) {
+		otg_dbg(otg, "Access extend registers 0x%x\n", reg);
+		val32 = GUSB2PHYACC0_NEWREGREQ
+			| GUSB2PHYACC0_REGADDR(ULPI_ACCESS_EXTENDED)
+			| GUSB2PHYACC0_VCTRL(reg)
+			| GUSB2PHYACC0_REGWR | GUSB2PHYACC0_REGDATA(val);
+	} else {
+		otg_dbg(otg, "Access normal registers 0x%x\n", reg);
+		val32 = GUSB2PHYACC0_NEWREGREQ
+			| GUSB2PHYACC0_REGADDR(reg)
+			| GUSB2PHYACC0_REGWR
+			| GUSB2PHYACC0_REGDATA(val);
+	}
+	otg_write(otg, GUSB2PHYACC0, val32);
+
+	while (count) {
+		if (otg_read(otg, GUSB2PHYACC0) & GUSB2PHYACC0_VSTSDONE) {
+			otg_dbg(otg, "%s - reg 0x%x data 0x%x write done\n",
+					__func__, reg, val);
+			goto cleanup;
+		}
+
+		count--;
+	}
+
+	otg_err(otg, "%s read PHY data failed.\n", __func__);
+
+	return -ETIMEDOUT;
+
+cleanup:
+	/* Clear GUSB2PHYACC0[16:21] before return.
+	 * Otherwise, it will cause PHY can't in workable
+	 * state. This is one dwc3 controller silicon bug. */
+	tmp = otg_read(otg, GUSB2PHYACC0);
+	otg_write(otg, GUSB2PHYACC0, tmp &
+			~GUSB2PHYACC0_REGADDR(0x3F));
+	return 0;
+}
+
+static struct usb_phy_io_ops dwc_otg_io_ops = {
+	.read = ulpi_read,
+	.write = ulpi_write,
+};
+
+static struct dwc_otg2 *dwc3_otg_alloc(struct device *dev)
+{
+	struct dwc_otg2 *otg = NULL;
+	struct usb_phy *usb_phy;
+	int retval;
+
+	otg = kzalloc(sizeof(*otg), GFP_KERNEL);
+	if (!otg) {
+		otg_err(otg, "Alloc otg failed\n");
+		return NULL;
+	}
+
+	the_transceiver = otg;
+	otg->otg_data = dev->platform_data;
+
+	usb_phy = &otg->usb2_phy;
+	otg->otg.phy = usb_phy;
+	otg->usb2_phy.otg = &otg->otg;
+
+	otg->dev		= dev;
+	otg->usb3_phy.dev		= otg->dev;
+	otg->usb3_phy.label		= "dwc-usb3-phy";
+	otg->usb3_phy.state		= OTG_STATE_UNDEFINED;
+	otg->usb3_phy.otg	= &otg->otg;
+	otg->usb2_phy.dev		= otg->dev;
+	otg->usb2_phy.label		= "dwc-usb2-phy";
+	otg->usb2_phy.state		= OTG_STATE_UNDEFINED;
+	otg->usb2_phy.set_power	= dwc3_otg_pdata->set_power;
+	otg->usb2_phy.get_chrg_status	= dwc_otg_get_chrg_status;
+	otg->usb2_phy.io_ops = &dwc_otg_io_ops;
+	otg->usb2_phy.otg	= &otg->otg;
+	otg->otg.set_host	= dwc_otg2_set_host;
+	otg->otg.set_peripheral	= dwc_otg2_set_peripheral;
+	ATOMIC_INIT_NOTIFIER_HEAD(&otg->usb2_phy.notifier);
+	ATOMIC_INIT_NOTIFIER_HEAD(&otg->usb3_phy.notifier);
+
+	otg->state = DWC_STATE_B_IDLE;
+	spin_lock_init(&otg->lock);
+	init_waitqueue_head(&otg->main_wq);
+
+	/* Register otg notifier to monitor ID and VBus change events */
+	otg->nb.notifier_call = dwc_otg_handle_notification;
+	usb_register_notifier(&otg->usb2_phy, &otg->nb);
+
+	otg_dbg(otg, "Version: %s\n", VERSION);
+	retval = usb_add_phy(&otg->usb2_phy, USB_PHY_TYPE_USB2);
+	if (retval) {
+		otg_err(otg, "can't register transceiver, err: %d\n",
+			retval);
+		goto err1;
+	}
+
+	retval = usb_add_phy(&otg->usb3_phy, USB_PHY_TYPE_USB3);
+	if (retval) {
+		otg_err(otg, "can't register transceiver, err: %d\n",
+			retval);
+		goto err2;
+	}
+
+	return otg;
+
+err2:
+	usb_remove_phy(&otg->usb2_phy);
+
+err1:
+	kfree(otg);
+	otg = NULL;
+
+	return otg;
+}
+
+static int dwc3_otg_create_children(struct dwc_otg2 *otg,
+		struct resource *res, int num)
+{
+	struct platform_device *dwc_host, *dwc_gadget;
+	enum dwc3_otg_mode mode = dwc3_otg_pdata->mode;
+	int retval = 0, i;
+
+	if (!otg || !res)
+		return -EINVAL;
+
+	if (num != 2)
+		return -EINVAL;
+
+	dwc_host = dwc_gadget = NULL;
+
+	for (i = 0; i < 2; i++) {
+		if (res[i].flags == IORESOURCE_MEM) {
+			otg->usb2_phy.io_priv = ioremap_nocache(
+				res[i].start, res[i].end - res[i].start);
+			if (!otg->usb2_phy.io_priv) {
+				otg_err(otg, "dwc3 otg ioremap failed\n");
+				return -ENOMEM;
+			}
+			break;
+		}
+	}
+
+	/* resource have no mem io resource */
+	if (!otg->usb2_phy.io_priv)
+		return -EINVAL;
+
+	platform_par = kzalloc(sizeof(*platform_par), GFP_KERNEL);
+	if (!platform_par) {
+		otg_err(otg, "alloc dwc_device_par failed\n");
+		goto err1;
+	}
+
+	platform_par->io_addr = otg->usb2_phy.io_priv;
+	platform_par->len = res[i].end - res[i].start;
+
+	if (mode == DWC3_DEVICE_ONLY)
+		goto device_only;
+
+	dwc_host = platform_device_alloc(DWC3_HOST_NAME,
+			HOST_DEVID);
+	if (!dwc_host) {
+		otg_err(otg, "couldn't allocate dwc3 host device\n");
+		goto err2;
+	}
+
+	retval = platform_device_add_resources(dwc_host, res, num);
+	if (retval) {
+		otg_err(otg, "couldn't add resources to dwc3 device\n");
+		goto err3;
+	}
+
+	platform_device_add_data(dwc_host, platform_par,
+			sizeof(struct dwc_device_par));
+
+	dwc_host->dev.dma_mask = otg->dev->dma_mask;
+	dwc_host->dev.dma_parms = otg->dev->dma_parms;
+	dwc_host->dev.parent = otg->dev;
+
+	retval = platform_device_add(dwc_host);
+	if (retval)	{
+		otg_err(otg, "failed to register dwc3 host\n");
+		goto err1;
+	}
+
+	otg->host = dwc_host;
+
+	if (mode != DWC3_DRD)
+		return 0;
+
+device_only:
+	dwc_gadget = platform_device_alloc(DWC3_DEVICE_NAME,
+			GADGET_DEVID);
+	if (!dwc_gadget) {
+		otg_err(otg, "couldn't allocate dwc3 device\n");
+		goto err3;
+	}
+
+	retval = platform_device_add_resources(dwc_gadget,
+				res, num);
+	if (retval) {
+		otg_err(otg, "couldn't add resources to dwc3 device\n");
+		goto err3;
+	}
+
+	dwc_gadget->dev.dma_mask = otg->dev->dma_mask;
+	dwc_gadget->dev.dma_parms = otg->dev->dma_parms;
+	dwc_gadget->dev.parent = otg->dev;
+
+	platform_device_add_data(dwc_gadget, platform_par,
+			sizeof(struct dwc_device_par));
+	retval = platform_device_add(dwc_gadget);
+	if (retval) {
+		otg_err(otg, "failed to register dwc3 gadget\n");
+		goto err3;
+	}
+	otg->gadget = dwc_gadget;
+
+	return 0;
+
+err3:
+	if (mode == DWC3_DRD)
+		platform_device_unregister(dwc_host);
+
+err2:
+	kfree(platform_par);
+
+err1:
+	iounmap(otg->usb2_phy.io_priv);
+
+	return retval;
+}
+
+#ifdef CONFIG_PCI
+
+static int dwc_otg_probe(struct pci_dev *pdev,
+			const struct pci_device_id *id)
+{
+	int retval = 0;
+	struct resource		res[2];
+	struct dwc_otg2 *otg = NULL;
+	unsigned long resource, len;
+
+	if (!dwc3_otg_pdata)
+		return -ENODEV;
+
+	if (pci_enable_device(pdev) < 0) {
+		dev_err(&pdev->dev, "pci device enable failed\n");
+		return -ENODEV;
+	}
+
+	pci_set_power_state(pdev, PCI_D0);
+	pci_set_master(pdev);
+
+	otg = dwc3_otg_alloc(&pdev->dev);
+	if (!otg) {
+		otg_err(otg, "dwc3 otg init failed\n");
+		goto err;
+	}
+
+	/* control register: BAR 0 */
+	resource = pci_resource_start(pdev, 0);
+	len = pci_resource_len(pdev, 0);
+	if (!request_mem_region(resource, len, driver_name)) {
+		otg_err(otg, "Request memory region failed\n");
+		retval = -EBUSY;
+		goto err;
+	}
+
+	otg_dbg(otg, "dwc otg pci resouce: 0x%lu, len: 0x%lu\n",
+			resource, len);
+	otg_dbg(otg, "vendor: 0x%x, device: 0x%x\n",
+			pdev->vendor, pdev->device);
+
+	memset(res, 0x00, sizeof(struct resource) * ARRAY_SIZE(res));
+
+	res[0].start	= pci_resource_start(pdev, 0);
+	res[0].end	= pci_resource_end(pdev, 0);
+	res[0].name	= "dwc_usb3_io";
+	res[0].flags	= IORESOURCE_MEM;
+
+	res[1].start	= pdev->irq;
+	res[1].name	= "dwc_usb3_irq";
+	res[1].flags	= IORESOURCE_IRQ;
+
+	retval = dwc3_otg_create_children(otg, res, ARRAY_SIZE(res));
+	if (retval) {
+		otg_err(otg, "dwc3 otg create alloc children failed\n");
+		goto err;
+	}
+
+	otg->irqnum = pdev->irq;
+
+	if (dwc3_otg_pdata->platform_init) {
+		retval = dwc3_otg_pdata->platform_init(otg);
+		if (retval)
+			goto err;
+	}
+
+	pm_runtime_set_autosuspend_delay(&pdev->dev, 100);
+	pm_runtime_use_autosuspend(&pdev->dev);
+	pm_runtime_allow(&pdev->dev);
+	pm_runtime_mark_last_busy(otg->dev);
+	pm_runtime_put_autosuspend(&pdev->dev);
+
+	return 0;
+
+err:
+	if (the_transceiver)
+		dwc_otg_remove(pdev);
+
+	return retval;
+}
+
+static void dwc_otg_remove(struct pci_dev *pdev)
+{
+	struct dwc_otg2 *otg = the_transceiver;
+	int resource, len;
+
+	if (otg->gadget)
+		platform_device_unregister(otg->gadget);
+	if (otg->host)
+		platform_device_unregister(otg->host);
+
+	pm_runtime_forbid(&pdev->dev);
+	pm_runtime_set_suspended(&pdev->dev);
+
+	kfree(platform_par);
+	iounmap(otg->usb2_phy.io_priv);
+
+	usb_remove_phy(&otg->usb2_phy);
+	usb_remove_phy(&otg->usb3_phy);
+	kfree(otg);
+	otg = NULL;
+
+	resource = pci_resource_start(pdev, 0);
+	len = pci_resource_len(pdev, 0);
+	release_mem_region(resource, len);
+
+	pci_disable_device(pdev);
+
+	the_transceiver = NULL;
+}
+
+static void dwc_otg_shutdown(struct pci_dev *pdev)
+{
+	struct dwc_otg2 *otg = the_transceiver;
+
+	/* stop main thread, ignore notification events */
+	stop_main_thread(otg);
+
+	pci_disable_device(pdev);
+}
+
+static int dwc_otg_runtime_idle(struct device *dev)
+{
+	if (dwc3_otg_pdata->idle)
+		return dwc3_otg_pdata->idle(the_transceiver);
+
+	return 0;
+}
+
+static int dwc_otg_runtime_suspend(struct device *dev)
+{
+	if (dwc3_otg_pdata->suspend)
+		return dwc3_otg_pdata->suspend(the_transceiver);
+
+	return 0;
+}
+
+static int dwc_otg_runtime_resume(struct device *dev)
+{
+	if (dwc3_otg_pdata->resume)
+		return dwc3_otg_pdata->resume(the_transceiver);
+	return 0;
+}
+
+static int dwc_otg_suspend(struct device *dev)
+{
+	if (dwc3_otg_pdata->suspend)
+		return dwc3_otg_pdata->suspend(the_transceiver);
+	return 0;
+}
+
+static int dwc_otg_resume(struct device *dev)
+{
+	if (dwc3_otg_pdata->resume)
+		return dwc3_otg_pdata->resume(the_transceiver);
+	return 0;
+}
+
+static const struct dev_pm_ops dwc_usb_otg_pm_ops = {
+	.runtime_suspend = dwc_otg_runtime_suspend,
+	.runtime_resume	= dwc_otg_runtime_resume,
+	.runtime_idle = dwc_otg_runtime_idle,
+	.suspend = dwc_otg_suspend,
+	.resume	= dwc_otg_resume
+};
+
+static DEFINE_PCI_DEVICE_TABLE(pci_ids) = {
+	{ PCI_DEVICE_CLASS(((PCI_CLASS_SERIAL_USB << 8) | 0x20), ~0),
+		.vendor = PCI_VENDOR_ID_INTEL,
+		.device = PCI_DEVICE_ID_DWC,
+	},
+	{ PCI_DEVICE_CLASS(((PCI_CLASS_SERIAL_USB << 8) | 0x80), ~0),
+		.vendor = PCI_VENDOR_ID_INTEL,
+		.device = PCI_DEVICE_ID_DWC,
+	},
+	{ /* end: all zeroes */ }
+};
+
+static struct pci_driver dwc_otg_pci_driver = {
+	.name =		(char *) driver_name,
+	.id_table =	pci_ids,
+	.probe =	dwc_otg_probe,
+	.remove =	dwc_otg_remove,
+	.shutdown = dwc_otg_shutdown,
+	.driver = {
+		.name = (char *) driver_name,
+		.pm = &dwc_usb_otg_pm_ops,
+		.owner = THIS_MODULE,
+	},
+};
+#endif
+
+int dwc3_otg_register(struct dwc3_otg_hw_ops *pdata)
+{
+	int retval;
+
+	if (!pdata)
+		return -EINVAL;
+
+	if (dwc3_otg_pdata)
+		return -EBUSY;
+
+	dwc3_otg_pdata = pdata;
+
+#ifdef CONFIG_PCI
+	retval = pci_register_driver(&dwc_otg_pci_driver);
+#endif
+	mutex_init(&lock);
+
+	return retval;
+}
+EXPORT_SYMBOL_GPL(dwc3_otg_register);
+
+int dwc3_otg_unregister(struct dwc3_otg_hw_ops *pdata)
+{
+	if (!pdata)
+		return -EINVAL;
+
+	if (dwc3_otg_pdata != pdata)
+		return -EINVAL;
+
+	dwc3_otg_pdata = NULL;
+
+#ifdef CONFIG_PCI
+	pci_unregister_driver(&dwc_otg_pci_driver);
+#endif
+	mutex_destroy(&lock);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(dwc3_otg_unregister);
+
+static int __init dwc_otg_init(void)
+{
+	return 0;
+}
+module_init(dwc_otg_init);
+
+static void __exit dwc_otg_exit(void)
+{
+}
+module_exit(dwc_otg_exit);
+
+MODULE_AUTHOR("Synopsys, Inc and Wang Yu <yu.y.wang@intel.com>");
+MODULE_DESCRIPTION("DWC3 OTG Driver");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_VERSION("1.0");
diff --git a/drivers/usb/dwc3/otg.h b/drivers/usb/dwc3/otg.h
new file mode 100644
index 0000000..a1bcd97
--- /dev/null
+++ b/drivers/usb/dwc3/otg.h
@@ -0,0 +1,432 @@
+/*
+ * Intel Penwell USB OTG transceiver driver
+ * Copyright (C) 2009 - 2010, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef __DWC3_OTG_H
+#define __DWC3_OTG_H
+
+#include <linux/usb.h>
+#include <linux/device.h>
+#include <linux/compiler.h>
+#include <linux/power_supply.h>
+#include <linux/usb/gadget.h>
+#include <linux/usb/hcd.h>
+#include <linux/usb/ulpi.h>
+
+
+struct dwc_device_par {
+	void __iomem *io_addr;
+	int len;
+};
+
+#define DWC3_DEVICE_NAME "dwc3-device"
+#define DWC3_HOST_NAME "dwc3-host"
+#define GADGET_DEVID 1
+#define HOST_DEVID 2
+#define DRIVER_VERSION "0.1"
+
+#ifdef CONFIG_USB_DWC3_OTG_DEBUG
+#define DWC_OTG_DEBUG 1
+#else
+#define DWC_OTG_DEBUG 0
+#endif
+
+#define otg_dbg(d, fmt, args...)  \
+	do { if (DWC_OTG_DEBUG) dev_dbg((d)->dev, \
+			"%s(): " fmt , __func__, ## args); } while (0)
+#define otg_vdbg(d, fmt, args...)  \
+	do { if (DWC_OTG_DEBUG) dev_dbg((d)->dev, \
+			"%s(): " fmt , __func__, ## args); } while (0)
+#define otg_err(d, fmt, args...)  \
+	do { if (DWC_OTG_DEBUG) dev_err((d)->dev, \
+			"%s(): " fmt , __func__, ## args); } while (0)
+#define otg_warn(d, fmt, args...)  \
+	do { if (DWC_OTG_DEBUG) dev_warn((d)->dev, \
+			"%s(): " fmt , __func__, ## args); } while (0)
+#define otg_info(d, fmt, args...)  \
+	do { if (DWC_OTG_DEBUG) dev_info((d)->dev, \
+			"%s(): " fmt , __func__, ## args); } while (0)
+
+#ifdef DEBUG
+#define otg_write(o, reg, val)	do { \
+		otg_dbg(o, "OTG_WRITE: reg=0x%05x, val=0x%08x\n", reg, val); \
+		writel(val, ((void *)((o)->usb2_phy.io_priv)) + reg);	\
+	} while (0)
+
+#define otg_read(o, reg) ({ \
+		u32 __r; \
+		__r = readl(((void *)((o)->usb2_phy.io_priv)) + reg);	\
+		otg_dbg(o, "OTG_READ: reg=0x%05x, val=0x%08x\n", reg, __r); \
+		__r;							\
+	})
+#else
+#define otg_write(o, reg, val) \
+		writel(val, ((void *)((o)->usb2_phy.io_priv)) + reg);
+
+#define otg_read(o, reg)	({ \
+		readl(((void *)((o)->usb2_phy.io_priv)) + reg); \
+	})
+#endif
+
+#define GUSB2PHYCFG0				0xc200
+#define GUSB2PHYCFG_SUS_PHY                     0x40
+#define GUSB2PHYCFG_PHYSOFTRST (1 << 31)
+#define GUSB2PHYCFG_ULPI_AUTO_RESUME (1 << 15)
+#define GUSB2PHYCFG_ULPI_EXT_VBUS_DRV (1 << 17)
+
+#define EXTEND_ULPI_REGISTER_ACCESS_MASK	0xC0
+#define GUSB2PHYACC0	0xc280
+#define GUSB2PHYACC0_DISULPIDRVR  (1 << 26)
+#define GUSB2PHYACC0_NEWREGREQ  (1 << 25)
+#define GUSB2PHYACC0_VSTSDONE  (1 << 24)
+#define GUSB2PHYACC0_VSTSBSY  (1 << 23)
+#define GUSB2PHYACC0_REGWR  (1 << 22)
+#define GUSB2PHYACC0_REGADDR(v)  ((v & 0x3F) << 16)
+#define GUSB2PHYACC0_EXTREGADDR(v)  ((v & 0x3F) << 8)
+#define GUSB2PHYACC0_VCTRL(v)  ((v & 0xFF) << 8)
+#define GUSB2PHYACC0_REGDATA(v)  (v & 0xFF)
+#define GUSB2PHYACC0_REGDATA_MASK  0xFF
+
+#define GUSB3PIPECTL0                           0xc2c0
+#define GUSB3PIPECTL_SUS_EN                     0x20000
+#define GUSB3PIPE_DISRXDETP3                    (1 << 28)
+#define GUSB3PIPECTL_PHYSOFTRST (1 << 31)
+
+#define GHWPARAMS6				0xc158
+#define GHWPARAMS6_SRP_SUPPORT_ENABLED		0x0400
+#define GHWPARAMS6_HNP_SUPPORT_ENABLED		0x0800
+#define GHWPARAMS6_ADP_SUPPORT_ENABLED		0x1000
+
+#define GUCTL 0xC12C
+#define GUCTL_CMDEVADDR		(1 << 15)
+
+#define GCTL 0xc110
+#define GCTL_PRT_CAP_DIR 0x3000
+#define GCTL_PRT_CAP_DIR_SHIFT 12
+#define GCTL_PRT_CAP_DIR_HOST 1
+#define GCTL_PRT_CAP_DIR_DEV 2
+#define GCTL_PRT_CAP_DIR_OTG 3
+#define GCTL_GBL_HIBERNATION_EN 0x2
+#define GCTL_CORESOFTRESET (1 << 11)
+#define GCTL_PWRDNSCALE(x) (x << 19)
+#define GCTL_PWRDNSCALE_MASK (0x1fff << 19)
+
+#define OCFG					0xcc00
+#define OCFG_SRP_CAP				0x01
+#define OCFG_SRP_CAP_SHIFT			0
+#define OCFG_HNP_CAP				0x02
+#define OCFG_HNP_CAP_SHIFT			1
+#define OCFG_OTG_VERSION			0x04
+#define OCFG_OTG_VERSION_SHIFT			2
+
+#define GCTL					0xc110
+#define OCTL					0xcc04
+#define OCTL_HST_SET_HNP_EN			0x01
+#define OCTL_HST_SET_HNP_EN_SHIFT		0
+#define OCTL_DEV_SET_HNP_EN			0x02
+#define OCTL_DEV_SET_HNP_EN_SHIFT		1
+#define OCTL_TERM_SEL_DL_PULSE			0x04
+#define OCTL_TERM_SEL_DL_PULSE_SHIFT		2
+#define OCTL_SES_REQ				0x08
+#define OCTL_SES_REQ_SHIFT			3
+#define OCTL_HNP_REQ				0x10
+#define OCTL_HNP_REQ_SHIFT			4
+#define OCTL_PRT_PWR_CTL			0x20
+#define OCTL_PRT_PWR_CTL_SHIFT			5
+#define OCTL_PERI_MODE				0x40
+#define OCTL_PERI_MODE_SHIFT			6
+
+#define OEVT					0xcc08
+#define OEVT_ERR				0x00000001
+#define OEVT_ERR_SHIFT				0
+#define OEVT_SES_REQ_SCS			0x00000002
+#define OEVT_SES_REQ_SCS_SHIFT			1
+#define OEVT_HST_NEG_SCS			0x00000004
+#define OEVT_HST_NEG_SCS_SHIFT			2
+#define OEVT_B_SES_VLD_EVT			0x00000008
+#define OEVT_B_SES_VLD_EVT_SHIFT		3
+#define OEVT_B_DEV_VBUS_CHNG_EVNT		0x00000100
+#define OEVT_B_DEV_VBUS_CHNG_EVNT_SHIFT		8
+#define OEVT_B_DEV_SES_VLD_DET_EVNT		0x00000200
+#define OEVT_B_DEV_SES_VLD_DET_EVNT_SHIFT	9
+#define OEVT_B_DEV_HNP_CHNG_EVNT		0x00000400
+#define OEVT_B_DEV_HNP_CHNG_EVNT_SHIFT		10
+#define OEVT_B_DEV_B_HOST_END_EVNT		0x00000800
+#define OEVT_B_DEV_B_HOST_END_EVNT_SHIFT	11
+#define OEVT_A_DEV_SESS_END_DET_EVNT		0x00010000
+#define OEVT_A_DEV_SESS_END_DET_EVNT_SHIFT	16
+#define OEVT_A_DEV_SRP_DET_EVNT			0x00020000
+#define OEVT_A_DEV_SRP_DET_EVNT_SHIFT		17
+#define OEVT_A_DEV_HNP_CHNG_EVNT		0x00040000
+#define OEVT_A_DEV_HNP_CHNG_EVNT_SHIFT		18
+#define OEVT_A_DEV_HOST_EVNT			0x00080000
+#define OEVT_A_DEV_HOST_EVNT_SHIFT		19
+#define OEVT_A_DEV_B_DEV_HOST_END_EVNT		0x00100000
+#define OEVT_A_DEV_B_DEV_HOST_END_EVNT_SHIFT	20
+#define OEVT_HOST_ROLE_REQ_INIT_EVNT            0x00400000
+#define OEVT_HOST_ROLE_REQ_INIT_EVNT_SHIFT      22
+#define OEVT_HOST_ROLE_REQ_CONFIRM_EVNT         0x00800000
+#define OEVT_HOST_ROLE_REQ_CONFIRM_EVNT_SHIFT   23
+#define OEVT_CONN_ID_STS_CHNG_EVNT		0x01000000
+#define OEVT_CONN_ID_STS_CHNG_EVNT_SHIFT	24
+#define OEVT_DEV_MOD_EVNT			0x80000000
+#define OEVT_DEV_MOD_EVNT_SHIFT			31
+
+#define OEVTEN					0xcc0c
+
+#define OEVT_ALL (OEVT_CONN_ID_STS_CHNG_EVNT | \
+		OEVT_HOST_ROLE_REQ_INIT_EVNT | \
+		OEVT_HOST_ROLE_REQ_CONFIRM_EVNT | \
+		OEVT_A_DEV_B_DEV_HOST_END_EVNT | \
+		OEVT_A_DEV_HOST_EVNT | \
+		OEVT_A_DEV_HNP_CHNG_EVNT | \
+		OEVT_A_DEV_SRP_DET_EVNT | \
+		OEVT_A_DEV_SESS_END_DET_EVNT | \
+		OEVT_B_DEV_B_HOST_END_EVNT | \
+		OEVT_B_DEV_HNP_CHNG_EVNT | \
+		OEVT_B_DEV_SES_VLD_DET_EVNT | \
+		OEVT_B_DEV_VBUS_CHNG_EVNT)
+
+#define OSTS					0xcc10
+#define OSTS_CONN_ID_STS			0x0001
+#define OSTS_CONN_ID_STS_SHIFT			0
+#define OSTS_A_SES_VLD				0x0002
+#define OSTS_A_SES_VLD_SHIFT			1
+#define OSTS_B_SES_VLD				0x0004
+#define OSTS_B_SES_VLD_SHIFT			2
+#define OSTS_XHCI_PRT_PWR			0x0008
+#define OSTS_XHCI_PRT_PWR_SHIFT			3
+#define OSTS_PERIP_MODE				0x0010
+#define OSTS_PERIP_MODE_SHIFT			4
+#define OSTS_OTG_STATES				0x0f00
+#define OSTS_OTG_STATE_SHIFT			8
+
+#define ADPCFG					0xcc20
+#define ADPCFG_PRB_DSCHGS			0x0c000000
+#define ADPCFG_PRB_DSCHG_SHIFT			26
+#define ADPCFG_PRB_DELTAS			0x30000000
+#define ADPCFG_PRB_DELTA_SHIFT			28
+#define ADPCFG_PRB_PERS				0xc0000000
+#define ADPCFG_PRB_PER_SHIFT			30
+
+#define ADPCTL					0xcc24
+#define ADPCTL_WB				0x01000000
+#define ADPCTL_WB_SHIFT				24
+#define ADPCTL_ADP_RES				0x02000000
+#define ADPCTL_ADP_RES_SHIFT			25
+#define ADPCTL_ADP_EN				0x04000000
+#define ADPCTL_ADP_EN_SHIFT			26
+#define ADPCTL_ENA_SNS				0x08000000
+#define ADPCTL_ENA_SNS_SHIFT			27
+#define ADPCTL_ENA_PRB				0x10000000
+#define ADPCTL_ENA_PRB_SHIFT			28
+
+#define ADPEVT					0xcc28
+#define ADPEVT_RTIM_EVNTS			0x000007ff
+#define ADPEVT_RTIM_EVNT_SHIFT			0
+#define ADPEVT_ADP_RST_CMPLT_EVNT		0x02000000
+#define ADPEVT_ADP_RST_CMPLT_EVNT_SHIFT		25
+#define ADPEVT_ADP_TMOUT_EVNT			0x04000000
+#define ADPEVT_ADP_TMOUT_EVNT_SHIFT		26
+#define ADPEVT_ADP_SNS_EVNT			0x08000000
+#define ADPEVT_ADP_SNS_EVNT_SHIFT		27
+#define ADPEVT_ADP_PRB_EVNT			0x10000000
+#define ADPEVT_ADP_PRB_EVNT_SHIFT		28
+
+#define ADPEVTEN				0xcc2c
+#define ADPEVTEN_ACC_DONE_EN			0x01000000
+#define ADPEVTEN_ACC_DONE_EN_SHIFT		24
+#define ADPEVTEN_ADP_RST_CMPLT_EVNT_EN		0x02000000
+#define ADPEVTEN_ADP_RST_CMPLT_EVNT_EN_SHIFT	25
+#define ADPEVTEN_ADP_TMOUT_EVNT_EN		0x04000000
+#define ADPEVTEN_ADP_TMOUT_EVNT_EN_SHIFT	26
+#define ADPEVTEN_ADP_SNS_EVNT_EN		0x08000000
+#define ADPEVTEN_ADP_SNS_EVNT_EN_SHIFT		27
+#define ADPEVTEN_ADP_PRB_EVNT_EN		0x10000000
+#define ADPEVTEN_ADP_PRB_EVNT_EN_SHIFT		28
+
+#define RID_A		0x01
+#define RID_B		0x02
+#define RID_C		0x03
+#define RID_FLOAT	0x04
+#define RID_GND		0x05
+#define RID_UNKNOWN	0x00
+
+/** The states for the OTG driver */
+enum dwc_otg_state {
+	DWC_STATE_INVALID = -1,
+
+	/** The initial state, check the connector
+	 * id status and determine what mode
+	 * (A-device or B-device) to operate in. */
+	DWC_STATE_B_IDLE = 0,
+
+	/* A-Host states */
+	DWC_STATE_A_PROBE,
+	DWC_STATE_A_HOST,
+	DWC_STATE_A_HNP_INIT,
+
+	/* A-Peripheral states */
+	DWC_STATE_A_PERIPHERAL,
+
+	/* B-Peripheral states */
+	DWC_STATE_B_SENSE,
+	DWC_STATE_B_PROBE,
+	DWC_STATE_B_PERIPHERAL,
+	DWC_STATE_B_HNP_INIT,
+
+	/* B-Host states */
+	DWC_STATE_B_HOST,
+
+	/* RSP */
+	DWC_STATE_B_RSP_INIT,
+
+	/* USB charger detection */
+	DWC_STATE_CHARGER_DETECTION,
+
+	/* VBUS */
+	DWC_STATE_WAIT_VBUS_RAISE,
+	DWC_STATE_WAIT_VBUS_FALL,
+
+	/* Charging*/
+	DWC_STATE_CHARGING,
+
+	/* Exit */
+	DWC_STATE_EXIT,
+	DWC_STATE_TERMINATED
+};
+
+/** The main structure to keep track of OTG driver state. */
+struct dwc_otg2 {
+	/** OTG transceiver */
+	struct usb_otg	otg;
+	struct usb_phy	usb2_phy;
+	struct usb_phy	usb3_phy;
+	struct device		*dev;
+	int irqnum;
+
+	int main_wakeup_needed;
+	struct task_struct *main_thread;
+	wait_queue_head_t main_wq;
+
+	spinlock_t lock;
+
+	/* Events */
+	u32 otg_events;
+	u32 user_events;
+
+	/** User space ID switch event */
+#define USER_ID_A_CHANGE_EVENT 0x01
+#define USER_ID_B_CHANGE_EVENT 0x02
+	/** a_bus_drop event from userspace */
+#define USER_A_BUS_DROP 0x40
+
+	/* States */
+	enum dwc_otg_state prev;
+	enum dwc_otg_state state;
+	struct platform_device *host;
+	struct platform_device *gadget;
+
+	/* Charger detection */
+	struct power_supply_cable_props charging_cap;
+	struct notifier_block nb;
+
+	/* Interfaces between host/device driver */
+	int (*start_host) (struct usb_hcd *hcd);
+	int (*stop_host) (struct usb_hcd *hcd);
+	int (*start_device)(struct usb_gadget *);
+	int (*stop_device)(struct usb_gadget *);
+	int (*vbus_draw) (struct usb_gadget *, unsigned ma);
+
+	/* Vendor driver private date */
+	void *otg_data;
+};
+
+#define sleep_main_thread_until_condition_timeout(otg, condition, msecs) ({ \
+		int __timeout = msecs;				\
+		while (!(condition)) {				\
+			otg_dbg(otg, "  ... sleeping for %d\n", __timeout); \
+			__timeout = sleep_main_thread_timeout(otg, __timeout); \
+			if (__timeout <= 0) {			\
+				break;				\
+			}					\
+		}						\
+		__timeout;					\
+	})
+
+#define sleep_main_thread_until_condition(otg, condition) ({	\
+		int __rc = 0;					\
+		do {						\
+			__rc = sleep_main_thread_until_condition_timeout(otg, \
+			condition, 50000); \
+		} while (__rc == 0);				\
+		__rc;						\
+	})
+
+#define VBUS_TIMEOUT	300
+#define PCI_DEVICE_ID_DWC 0x119E
+
+enum dwc3_otg_mode {
+	DWC3_DEVICE_ONLY,
+	DWC3_HOST_ONLY,
+	DWC3_DRD,
+};
+
+enum driver_bus_type {
+	DWC3_PLAT,
+	DWC3_PCI,
+};
+
+struct dwc3_otg_hw_ops {
+	enum dwc3_otg_mode mode;
+	enum driver_bus_type bus;
+
+	int (*set_power)(struct usb_phy *_otg, unsigned ma);
+	int (*platform_init)(struct dwc_otg2 *otg);
+	int (*otg_notifier_handler)(struct notifier_block *nb,
+			unsigned long event, void *data);
+	int (*prepare_start_peripheral)(struct dwc_otg2 *otg);
+	int (*prepare_start_host)(struct dwc_otg2 *otg);
+	int (*after_stop_peripheral)(struct dwc_otg2 *otg);
+	int (*after_stop_host)(struct dwc_otg2 *otg);
+	int (*b_idle)(struct dwc_otg2 *otg);
+	int (*do_charging)(struct dwc_otg2 *otg);
+	int (*notify_charger_type)(struct dwc_otg2 *otg,
+			enum power_supply_charger_event event);
+	enum power_supply_charger_cable_type
+		(*get_charger_type)(struct dwc_otg2 *otg);
+	int (*enable_vbus)(struct dwc_otg2 *otg, int enable);
+	int (*get_id)(struct dwc_otg2 *otg);
+
+	int (*idle)(struct dwc_otg2 *otg);
+	int (*suspend)(struct dwc_otg2 *otg);
+	int (*resume)(struct dwc_otg2 *otg);
+};
+
+#define OTG_USB2_100MA				0xfff1
+#define OTG_USB3_150MA				0xfff2
+#define OTG_USB2_500MA				0xfff3
+#define OTG_USB3_900MA				0xfff4
+#define OTG_DEVICE_SUSPEND			0xfffe
+#define OTG_DEVICE_RESUME			0xffff
+
+void dwc3_wakeup_otg_thread(struct dwc_otg2 *otg);
+struct dwc_otg2 *dwc3_get_otg(void);
+int dwc3_otg_register(struct dwc3_otg_hw_ops *pdata);
+int dwc3_otg_unregister(struct dwc3_otg_hw_ops *pdata);
+#endif /* __DWC3_OTG_H */
diff --git a/drivers/usb/gadget/epautoconf.c b/drivers/usb/gadget/epautoconf.c
index 0567cca..7f5dfcc 100644
--- a/drivers/usb/gadget/epautoconf.c
+++ b/drivers/usb/gadget/epautoconf.c
@@ -187,6 +187,8 @@ ep_matches (
 	ep->address = desc->bEndpointAddress;
 	return 1;
 }
+EXPORT_SYMBOL_GPL(ep_matches);
+
 
 static struct usb_ep *
 find_ep (struct usb_gadget *gadget, const char *name)
@@ -199,6 +201,7 @@ find_ep (struct usb_gadget *gadget, const char *name)
 	}
 	return NULL;
 }
+EXPORT_SYMBOL_GPL(find_ep);
 
 /**
  * usb_ep_autoconfig_ss() - choose an endpoint matching the ep
@@ -252,7 +255,11 @@ struct usb_ep *usb_ep_autoconfig_ss(
 {
 	struct usb_ep	*ep;
 	u8		type;
+#ifdef CONFIG_USB_DWC3_GADGET
+	u8	       addr;
 
+	addr = desc->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK;
+#endif
 	type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
 
 	/* First, apply chip-specific "best usage" knowledge.
@@ -300,10 +307,45 @@ struct usb_ep *usb_ep_autoconfig_ss(
 		if (ep && ep_matches(gadget, ep, desc, ep_comp))
 			goto found_ep;
 #endif
+
+#ifdef CONFIG_USB_DWC3_GADGET
+	} else if (gadget_is_middwc3tng(gadget)) {
+		if (addr == 0x1) {
+			/* statically assigned ebc-ep1 in/out  */
+			if ((desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK)
+			    & USB_DIR_IN)
+				ep = find_ep(gadget, "ep1in");
+			else
+				ep = NULL;
+		} else if (addr == 0x8) {
+			/* statically assigned ebc-ep8 in/out */
+			if ((desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK)
+			    & USB_DIR_IN)
+				ep = find_ep (gadget, "ep8in");
+			else
+				ep = find_ep (gadget, "ep8out");
+		} else
+			ep = NULL;
+		if (ep && ep_matches(gadget, ep, desc, ep_comp))
+			goto found_ep;
+#endif
+
 	}
 
 	/* Second, look at endpoints until an unclaimed one looks usable */
 	list_for_each_entry (ep, &gadget->ep_list, ep_list) {
+
+#ifdef CONFIG_USB_DWC3_GADGET
+		/* ep1in and ep8in are reserved for DWC3 device controller */
+		if (!strncmp(ep->name, "ep1in", 5) ||
+		    !strncmp(ep->name, "ep8in", 5))
+			continue;
+		if (gadget_is_middwc3tng(gadget))
+			/* ep1out and ep8out are also reserved */
+			if (!strncmp(ep->name, "ep1out", 6) ||
+			    !strncmp(ep->name, "ep8out", 6))
+				continue;
+#endif
 		if (ep_matches(gadget, ep, desc, ep_comp))
 			goto found_ep;
 	}
diff --git a/drivers/usb/gadget/f_dvc_dfx.c b/drivers/usb/gadget/f_dvc_dfx.c
new file mode 100644
index 0000000..6137e11
--- /dev/null
+++ b/drivers/usb/gadget/f_dvc_dfx.c
@@ -0,0 +1,922 @@
+/*
+ * Gadget Driver for Android DvC.Dfx Debug Capability
+ *
+ * Copyright (C) 2008-2010, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/usb/debug.h>
+#include <linux/sdm.h>
+#include <asm/intel_soc_debug.h>
+
+#define DFX_RX_REQ_MAX 1
+#define DFX_TX_REQ_MAX 2
+#define DFX_BULK_REQ_SIZE 64
+
+#define CONFIG_BOARD_MRFLD_VV
+
+struct dvc_dfx_dev {
+	struct usb_function function;
+	struct usb_composite_dev *cdev;
+	spinlock_t lock;
+	u8	ctrl_id, data_id;
+
+	struct usb_ep *ep_in;
+	struct usb_ep *ep_out;
+
+	int transfering;
+	int online;
+	int online_ctrl;
+	int online_data;
+	int error;
+
+	atomic_t read_excl;
+	atomic_t write_excl;
+	atomic_t open_excl;
+
+	wait_queue_head_t read_wq;
+	wait_queue_head_t write_wq;
+
+	struct usb_request *rx_req[DFX_RX_REQ_MAX];
+
+	struct list_head tx_idle;
+	struct list_head tx_xfer;
+};
+
+static struct usb_interface_assoc_descriptor dfx_iad_desc = {
+	.bLength		= sizeof(dfx_iad_desc),
+	.bDescriptorType	= USB_DT_INTERFACE_ASSOCIATION,
+	/* .bFirstInterface	= DYNAMIC, */
+	.bInterfaceCount	= 2, /* debug control + data */
+	.bFunctionClass		= USB_CLASS_DEBUG,
+	.bFunctionSubClass	= USB_SUBCLASS_DVC_DFX,
+	/* .bFunctionProtocol	= DC_PROTOCOL_VENDOR, */
+	/* .iFunction		= 0, */
+};
+
+static struct usb_interface_descriptor dfx_interface_desc = {
+	.bLength                = USB_DT_INTERFACE_SIZE,
+	.bDescriptorType        = USB_DT_INTERFACE,
+	.bNumEndpoints          = 0,
+	.bInterfaceClass        = USB_CLASS_DEBUG,
+	.bInterfaceSubClass     = USB_SUBCLASS_DEBUG_CONTROL,
+	/* .bInterfaceProtocol     = DC_PROTOCOL_VENDOR, */
+};
+
+#define DC_DBG_ATTRI_LENGTH	DC_DBG_ATTRI_SIZE(2, 32)
+/* 1 input terminal, 1 output terminal and 1 feature unit */
+#define DC_DBG_TOTAL_LENGTH (DC_DBG_ATTRI_LENGTH)
+
+DECLARE_DC_DEBUG_ATTR_DESCR(DVCD, 2, 32);
+
+static struct DC_DEBUG_ATTR_DESCR(DVCD) dfx_debug_attri_desc = {
+	.bLength		= DC_DBG_ATTRI_LENGTH,
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype	= DC_DEBUG_ATTRIBUTES,
+	.bcdDC			= __constant_cpu_to_le16(0x0100),
+	.wTotalLength		= __constant_cpu_to_le16(DC_DBG_TOTAL_LENGTH),
+	.bmSupportedFeatures	= 0, /* Debug Event Supported, per SAS */
+	.bControlSize		= 2,
+	.bmControl		= {	/* per SAS */
+		[0]		= 0xFF,
+		[1]		= 0x3F,
+	},
+	.wAuxDataSize		= __constant_cpu_to_le16(0x20),
+/* per SAS v0.3*/
+	.dInputBufferSize	= __constant_cpu_to_le32(0x40),
+	.dOutputBufferSize	= __constant_cpu_to_le32(0x80),
+	.qBaseAddress		= 0, /* revision */
+	.hGlobalID		= { /* revision */
+		[0]		= 0,
+		[1]		= 0,
+	}
+};
+
+static struct usb_interface_descriptor dfx_data_interface_desc = {
+	.bLength                = USB_DT_INTERFACE_SIZE,
+	.bDescriptorType        = USB_DT_INTERFACE,
+	.bAlternateSetting	= 0,
+	.bNumEndpoints          = 2,
+	.bInterfaceClass        = USB_CLASS_DEBUG,
+	.bInterfaceSubClass     = USB_SUBCLASS_DVC_DFX,
+	/* .bInterfaceProtocol     = DC_PROTOCOL_VENDOR, */
+};
+
+static struct usb_endpoint_descriptor dfx_fullspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_endpoint_descriptor dfx_fullspeed_out_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_OUT,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_endpoint_descriptor dfx_highspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(512),
+};
+
+static struct usb_endpoint_descriptor dfx_highspeed_out_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_OUT,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(512),
+};
+
+static struct usb_endpoint_descriptor dfx_superspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(1024),
+};
+
+static struct usb_ss_ep_comp_descriptor dfx_superspeed_in_comp_desc = {
+	.bLength		= USB_DT_SS_EP_COMP_SIZE,
+	.bDescriptorType	= USB_DT_SS_ENDPOINT_COMP,
+	.bMaxBurst		= 0,
+	.bmAttributes		= 0,
+};
+
+static struct usb_endpoint_descriptor dfx_superspeed_out_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_OUT,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(1024),
+};
+
+static struct usb_ss_ep_comp_descriptor dfx_superspeed_out_comp_desc = {
+	.bLength		= USB_DT_SS_EP_COMP_SIZE,
+	.bDescriptorType	= USB_DT_SS_ENDPOINT_COMP,
+	.bMaxBurst		= 0,
+	.bmAttributes		= 0,
+};
+
+/* no INPUT/OUTPUT CONNECTION and UNIT descriptors for DvC.DFx */
+static struct usb_descriptor_header *fs_dfx_descs[] = {
+	(struct usb_descriptor_header *) &dfx_iad_desc,
+	(struct usb_descriptor_header *) &dfx_data_interface_desc,
+	(struct usb_descriptor_header *) &dfx_fullspeed_in_desc,
+	(struct usb_descriptor_header *) &dfx_fullspeed_out_desc,
+
+	(struct usb_descriptor_header *) &dfx_interface_desc,
+	(struct usb_descriptor_header *) &dfx_debug_attri_desc,
+	NULL,
+};
+
+static struct usb_descriptor_header *hs_dfx_descs[] = {
+	(struct usb_descriptor_header *) &dfx_iad_desc,
+	(struct usb_descriptor_header *) &dfx_data_interface_desc,
+	(struct usb_descriptor_header *) &dfx_highspeed_in_desc,
+	(struct usb_descriptor_header *) &dfx_highspeed_out_desc,
+
+	(struct usb_descriptor_header *) &dfx_interface_desc,
+	(struct usb_descriptor_header *) &dfx_debug_attri_desc,
+	NULL,
+};
+
+static struct usb_descriptor_header *ss_dfx_descs[] = {
+	(struct usb_descriptor_header *) &dfx_iad_desc,
+	(struct usb_descriptor_header *) &dfx_data_interface_desc,
+	(struct usb_descriptor_header *) &dfx_superspeed_in_desc,
+	(struct usb_descriptor_header *) &dfx_superspeed_in_comp_desc,
+	(struct usb_descriptor_header *) &dfx_superspeed_out_desc,
+	(struct usb_descriptor_header *) &dfx_superspeed_out_comp_desc,
+
+	(struct usb_descriptor_header *) &dfx_interface_desc,
+	(struct usb_descriptor_header *) &dfx_debug_attri_desc,
+	NULL,
+};
+
+/* string descriptors: */
+
+#define DVCDFX_CTRL_IDX	0
+#define DVCDFX_DATA_IDX	1
+#define DVCDFX_IAD_IDX	2
+
+/* static strings, in UTF-8 */
+static struct usb_string dfx_string_defs[] = {
+	[DVCDFX_CTRL_IDX].s = "Debug Sub-Class DvC.DFx (Control)",
+	[DVCDFX_DATA_IDX].s = "Debug Sub-Class DvC.DFx (Data)",
+	[DVCDFX_IAD_IDX].s = "Debug Sub-Class DvC.DFx",
+	{  /* ZEROES END LIST */ },
+};
+
+static struct usb_gadget_strings dfx_string_table = {
+	.language =		0x0409,	/* en-us */
+	.strings =		dfx_string_defs,
+};
+
+static struct usb_gadget_strings *dfx_strings[] = {
+	&dfx_string_table,
+	NULL,
+};
+
+/*-------------------------------------------------------------------------*/
+
+/* temporary variable used between dvc_dfx_open() and dvc_dfx_gadget_bind() */
+static struct dvc_dfx_dev *_dvc_dfx_dev;
+
+static inline struct dvc_dfx_dev *func_to_dvc_dfx(struct usb_function *f)
+{
+	return container_of(f, struct dvc_dfx_dev, function);
+}
+
+static int dvc_dfx_is_enabled(void)
+{
+	if ((!cpu_has_debug_feature(DEBUG_FEATURE_USB3DFX)) ||
+	    (!stm_is_enabled())) {
+		pr_info("%s STM and/or USB3DFX is not enabled\n", __func__);
+		return 0;
+	}
+	return 1;
+}
+
+static struct usb_request *dvc_dfx_request_new(struct usb_ep *ep,
+					       int buffer_size, dma_addr_t dma)
+{
+	struct usb_request *req = usb_ep_alloc_request(ep, GFP_KERNEL);
+	if (!req)
+		return NULL;
+
+
+	req->dma = dma;
+	/* now allocate buffers for the requests */
+	req->buf = kmalloc(buffer_size, GFP_KERNEL);
+	if (!req->buf) {
+		usb_ep_free_request(ep, req);
+		return NULL;
+	}
+
+	return req;
+}
+
+static void dvc_dfx_request_free(struct usb_request *req, struct usb_ep *ep)
+{
+	if (req) {
+		kfree(req->buf);
+		usb_ep_free_request(ep, req);
+	}
+}
+
+/* add a request to the tail of a list */
+static void dvc_dfx_req_put(struct dvc_dfx_dev *dev, struct list_head *head,
+		struct usb_request *req)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	list_add_tail(&req->list, head);
+	spin_unlock_irqrestore(&dev->lock, flags);
+}
+
+/* remove a request from the head of a list */
+static struct usb_request *dvc_dfx_req_get(struct dvc_dfx_dev *dev,
+					   struct list_head *head)
+{
+	unsigned long flags;
+	struct usb_request *req;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (list_empty(head)) {
+		req = 0;
+	} else {
+		req = list_first_entry(head, struct usb_request, list);
+		list_del(&req->list);
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return req;
+}
+
+static void dvc_dfx_set_disconnected(struct dvc_dfx_dev *dev)
+{
+	dev->transfering = 0;
+}
+
+static void dvc_dfx_complete_in(struct usb_ep *ep, struct usb_request *req)
+{
+	struct dvc_dfx_dev *dev = _dvc_dfx_dev;
+
+	if (req->status != 0)
+		dvc_dfx_set_disconnected(dev);
+
+	dvc_dfx_req_put(dev, &dev->tx_idle, req);
+
+	wake_up(&dev->write_wq);
+}
+
+static void dvc_dfx_complete_out(struct usb_ep *ep, struct usb_request *req)
+{
+	struct dvc_dfx_dev *dev = _dvc_dfx_dev;
+
+	if (req->status != 0)
+		dvc_dfx_set_disconnected(dev);
+	wake_up(&dev->read_wq);
+}
+
+
+static inline int dvc_dfx_lock(atomic_t *excl)
+{
+	if (atomic_inc_return(excl) == 1) {
+		return 0;
+	} else {
+		atomic_dec(excl);
+		return -1;
+	}
+}
+
+static inline void dvc_dfx_unlock(atomic_t *excl)
+{
+	atomic_dec(excl);
+}
+
+static int dfx_create_bulk_endpoints(struct dvc_dfx_dev *dev,
+				     struct usb_endpoint_descriptor *in_desc,
+				     struct usb_endpoint_descriptor *out_desc,
+				     struct usb_ss_ep_comp_descriptor *in_comp_desc,
+				     struct usb_ss_ep_comp_descriptor *out_comp_desc
+	)
+{
+	struct usb_composite_dev *cdev = dev->cdev;
+	struct usb_request *req;
+	struct usb_ep *ep;
+	int i;
+
+	pr_debug("%s dev: %p\n", __func__, dev);
+
+	in_desc->bEndpointAddress |= 0x8;
+	ep = usb_ep_autoconfig_ss(cdev->gadget, in_desc, in_comp_desc);
+	if (!ep) {
+		pr_debug("%s for ep_in failed\n", __func__);
+		return -ENODEV;
+	}
+	pr_debug("%s for ep_in got %s\n", __func__, ep->name);
+
+	ep->driver_data = dev;		/* claim the endpoint */
+	dev->ep_in = ep;
+
+	out_desc->bEndpointAddress |= 0x8;
+	ep = usb_ep_autoconfig_ss(cdev->gadget, out_desc, out_comp_desc);
+	if (!ep) {
+		pr_debug("%s for ep_out failed\n", __func__);
+		return -ENODEV;
+	}
+	pr_debug("%s for ep_out got %s\n", __func__, ep->name);
+
+	ep->driver_data = dev;		/* claim the endpoint */
+	dev->ep_out = ep;
+
+	/* now allocate requests for our endpoints */
+	for (i = 0; i < DFX_TX_REQ_MAX; i++) {
+		if (!(i % 2))
+			req = dvc_dfx_request_new(dev->ep_in,
+				DFX_BULK_BUFFER_SIZE,
+				(dma_addr_t)DFX_BULK_IN_BUFFER_ADDR);
+		else
+			req = dvc_dfx_request_new(dev->ep_in,
+				DFX_BULK_BUFFER_SIZE,
+				(dma_addr_t)DFX_BULK_IN_BUFFER_ADDR_2);
+		if (!req)
+			goto fail;
+		req->complete = dvc_dfx_complete_in;
+		dvc_dfx_req_put(dev, &dev->tx_idle, req);
+	}
+	for (i = 0; i < DFX_RX_REQ_MAX; i++) {
+		req = dvc_dfx_request_new(dev->ep_out, DFX_BULK_BUFFER_SIZE,
+			(dma_addr_t)DFX_BULK_OUT_BUFFER_ADDR);
+		if (!req)
+			goto fail;
+		req->complete = dvc_dfx_complete_out;
+		dev->rx_req[i] = req;
+	}
+
+	return 0;
+
+fail:
+	pr_err("%s could not allocate requests\n", __func__);
+	while ((req = dvc_dfx_req_get(dev, &dev->tx_idle)))
+		dvc_dfx_request_free(req, dev->ep_out);
+	for (i = 0; i < DFX_RX_REQ_MAX; i++)
+		dvc_dfx_request_free(dev->rx_req[i], dev->ep_out);
+	return -1;
+}
+
+static ssize_t dvc_dfx_start_transfer(size_t count)
+{
+	struct dvc_dfx_dev *dev = _dvc_dfx_dev;
+	struct usb_request *req;
+	int r = count, xfer;
+	int ret = -ENODEV;
+
+
+	pr_info("%s start\n", __func__);
+	if (!_dvc_dfx_dev)
+		return ret;
+
+	if (dvc_dfx_lock(&dev->read_excl)
+	    && dvc_dfx_lock(&dev->write_excl))
+		return -EBUSY;
+
+	/* we will block until enumeration completes */
+	while (!(dev->online || dev->error)) {
+		pr_debug("%s waiting for online state\n", __func__);
+		ret = wait_event_interruptible(dev->read_wq,
+				(dev->online || dev->error));
+
+		if (ret < 0) {
+			/* not at CONFIGURED state */
+			pr_info("%s USB not at CONFIGURED\n", __func__);
+			dvc_dfx_unlock(&dev->read_excl);
+			dvc_dfx_unlock(&dev->write_excl);
+			return ret;
+		}
+	}
+
+	/* queue a ep_in endless request */
+	while (r > 0) {
+		if (dev->error) {
+			pr_debug("%s dev->error\n", __func__);
+			r = -EIO;
+			break;
+		}
+
+		if (!dev->online) {
+			pr_debug("%s !dev->online issue\n", __func__);
+			r = -EIO;
+			break;
+		}
+
+		/* get an idle tx request to use */
+		req = 0;
+		ret = wait_event_interruptible(dev->write_wq,
+				dev->error || !dev->online ||
+				(req = dvc_dfx_req_get(dev, &dev->tx_idle)));
+
+		if (ret < 0) {
+			r = ret;
+			break;
+		}
+
+		if (req != 0) {
+			if (count > DFX_BULK_BUFFER_SIZE)
+				xfer = DFX_BULK_BUFFER_SIZE;
+			else
+				xfer = count;
+
+			req->no_interrupt = 1;
+			req->context = &dev->function;
+			req->length = xfer;
+			pr_debug("%s queue tx_idle list req to dev->ep_in\n",
+				__func__);
+			ret = usb_ep_queue(dev->ep_in, req, GFP_ATOMIC);
+			if (ret < 0) {
+				pr_err("%s xfer error %d\n", __func__, ret);
+					dev->error = 1;
+				r = -EIO;
+				break;
+			}
+			pr_debug("%s xfer=%d/%d  queued req/%x\n", __func__,
+				xfer, r, (uint)req);
+			dvc_dfx_req_put(dev, &dev->tx_xfer, req);
+			r -= xfer;
+
+			/* zero this so we don't try to free it on error exit */
+			req = 0;
+		}
+	}
+	if (req) {
+		pr_debug("%s req re-added to tx_idle on error\n", __func__);
+		dvc_dfx_req_put(dev, &dev->tx_idle, req);
+	}
+
+	pr_debug("%s rx_req to dev->ep_out\n", __func__);
+	/* queue a ep_out endless request */
+	req = dev->rx_req[0];
+	req->length = DFX_BULK_BUFFER_SIZE;
+	req->no_interrupt = 1;
+	req->context = &dev->function;
+	ret = usb_ep_queue(dev->ep_out, req, GFP_ATOMIC);
+	if (ret < 0) {
+		pr_err("%s failed to queue out req %p (%d)\n",
+		       __func__, req, req->length);
+		r = -EIO;
+	} else {
+		dev->transfering = 1;
+	}
+
+	dvc_dfx_unlock(&dev->read_excl);
+	dvc_dfx_unlock(&dev->write_excl);
+	pr_debug("%s returning\n", __func__);
+	return r;
+}
+
+static int dvc_dfx_disable_transfer(void)
+{
+	struct dvc_dfx_dev *dev = _dvc_dfx_dev;
+	struct usb_request *req;
+	int r = 1;
+	int ret;
+
+
+	pr_info("%s start\n", __func__);
+	if (!_dvc_dfx_dev)
+		return -ENODEV;
+
+	if (dvc_dfx_lock(&dev->read_excl)
+	    && dvc_dfx_lock(&dev->write_excl))
+		return -EBUSY;
+
+	if (dev->error) {
+		pr_debug("%s dev->error\n", __func__);
+		r = -EIO;
+		goto end;
+	}
+
+	if ((!dev->online) || (!dev->transfering)) {
+		pr_debug("%s !dev->online OR !dev->transfering\n", __func__);
+		r = -EIO;
+		goto end;
+	}
+
+	/* get an xfer tx request to use */
+	while ((req = dvc_dfx_req_get(dev, &dev->tx_xfer))) {
+		ret = usb_ep_dequeue(dev->ep_in, req);
+		if (ret < 0) {
+			pr_err("%s dequeue error %d\n", __func__, ret);
+			dev->error = 1;
+			r = -EIO;
+			goto end;
+		}
+		pr_debug("%s dequeued tx req/%x\n", __func__, (uint)req);
+	}
+	ret = usb_ep_dequeue(dev->ep_out, dev->rx_req[0]);
+	if (ret < 0) {
+		pr_err("%s dequeue rx error %d\n", __func__, ret);
+		dev->error = 1;
+		r = -EIO;
+		goto end;
+	}
+
+end:
+	dvc_dfx_unlock(&dev->read_excl);
+	dvc_dfx_unlock(&dev->write_excl);
+	return r;
+}
+
+static int dvc_dfx_open(struct inode *ip, struct file *fp)
+{
+	pr_info("%s\n", __func__);
+	if (!_dvc_dfx_dev)
+		return -ENODEV;
+
+	if (dvc_dfx_lock(&_dvc_dfx_dev->open_excl))
+		return -EBUSY;
+
+	fp->private_data = _dvc_dfx_dev;
+
+	/* clear the error latch */
+	_dvc_dfx_dev->error = 0;
+	_dvc_dfx_dev->transfering = 0;
+
+	return 0;
+}
+
+static int dvc_dfx_release(struct inode *ip, struct file *fp)
+{
+	pr_info("%s\n", __func__);
+
+	dvc_dfx_unlock(&_dvc_dfx_dev->open_excl);
+	return 0;
+}
+
+/* file operations for DvC.Dfx device /dev/usb_dvc_dfx */
+static const struct file_operations dvc_dfx_fops = {
+	.owner = THIS_MODULE,
+	.open = dvc_dfx_open,
+	.release = dvc_dfx_release,
+};
+
+static struct miscdevice dvc_dfx_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "usb_dvc_dfx",
+	.fops = &dvc_dfx_fops,
+};
+
+static int dvc_dfx_ctrlrequest(struct usb_composite_dev *cdev,
+				const struct usb_ctrlrequest *ctrl)
+{
+	struct dvc_dfx_dev *dev = _dvc_dfx_dev;
+	int	value = -EOPNOTSUPP;
+	u16	w_index = le16_to_cpu(ctrl->wIndex);
+	u16	w_value = le16_to_cpu(ctrl->wValue);
+	u16	w_length = le16_to_cpu(ctrl->wLength);
+
+	pr_debug("%s %02x.%02x v%04x i%04x l%u\n", __func__,
+			ctrl->bRequestType, ctrl->bRequest,
+			w_value, w_index, w_length);
+
+	switch ((ctrl->bRequestType << 8) | ctrl->bRequest) {
+
+	/* DC_REQUEST_SET_RESET ... stop active transfer */
+	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)
+		| DC_REQUEST_SET_RESET:
+		if (w_index != dev->data_id)
+			goto invalid;
+
+		pr_info("%s DC_REQUEST_SET_RESET v%04x i%04x l%u\n", __func__,
+			w_value, w_index, w_length);
+
+		dvc_dfx_disable_transfer();
+		value = 0;
+		break;
+
+	default:
+invalid:
+		pr_debug("unknown class-specific control req "
+			 "%02x.%02x v%04x i%04x l%u\n",
+			 ctrl->bRequestType, ctrl->bRequest,
+			 w_value, w_index, w_length);
+	}
+
+	/* respond with data transfer or status phase? */
+	if (value >= 0) {
+		cdev->req->zero = 0;
+		cdev->req->length = value;
+		value = usb_ep_queue(cdev->gadget->ep0, cdev->req, GFP_ATOMIC);
+		if (value < 0)
+			pr_err("%s setup response queue error\n", __func__);
+	}
+
+	/* device either stalls (value < 0) or reports success */
+	return value;
+}
+
+static int
+dvc_dfx_function_bind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct usb_composite_dev	*cdev = c->cdev;
+	struct dvc_dfx_dev		*dev = func_to_dvc_dfx(f);
+	int			id;
+	int			ret;
+
+	dev->cdev = cdev;
+	pr_info("%s dev: %p\n", __func__, dev);
+
+	/* allocate interface ID(s) */
+	id = usb_interface_id(c, f);
+	if (id < 0)
+		return id;
+	dev->data_id = id;
+	dfx_data_interface_desc.bInterfaceNumber = id;
+	dfx_iad_desc.bFirstInterface = id;
+
+	id = usb_interface_id(c, f);
+	if (id < 0)
+		return id;
+	dev->ctrl_id = id;
+	dfx_interface_desc.bInterfaceNumber = id;
+
+	/* allocate endpoints */
+	ret = dfx_create_bulk_endpoints(dev, &dfx_fullspeed_in_desc,
+					&dfx_fullspeed_out_desc,
+					&dfx_superspeed_in_comp_desc,
+					&dfx_superspeed_out_comp_desc
+		);
+	if (ret)
+		return ret;
+
+	/* support high speed hardware */
+	if (gadget_is_dualspeed(c->cdev->gadget)) {
+		dfx_highspeed_in_desc.bEndpointAddress =
+			dfx_fullspeed_in_desc.bEndpointAddress;
+		dfx_highspeed_out_desc.bEndpointAddress =
+			dfx_fullspeed_out_desc.bEndpointAddress;
+	}
+
+	if (gadget_is_superspeed(c->cdev->gadget)) {
+		dfx_superspeed_in_desc.bEndpointAddress =
+			dfx_fullspeed_in_desc.bEndpointAddress;
+
+		dfx_superspeed_out_desc.bEndpointAddress =
+			dfx_fullspeed_out_desc.bEndpointAddress;
+	}
+
+	pr_info("%s speed %s: IN/%s, OUT/%s\n",
+			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
+			f->name, dev->ep_in->name, dev->ep_out->name);
+	return 0;
+}
+
+static void
+dvc_dfx_function_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct dvc_dfx_dev	*dev = func_to_dvc_dfx(f);
+	struct usb_request *req;
+	int i;
+
+	dev->online = 0;
+	dev->online_ctrl = 0;
+	dev->online_data = 0;
+	dev->transfering = 0;
+	dev->error = 0;
+
+	dfx_string_defs[DVCDFX_CTRL_IDX].id = 0;
+
+	wake_up(&dev->read_wq);
+
+	for (i = 0; i < DFX_RX_REQ_MAX; i++)
+		dvc_dfx_request_free(dev->rx_req[i], dev->ep_out);
+	while ((req = dvc_dfx_req_get(dev, &dev->tx_idle)))
+		dvc_dfx_request_free(req, dev->ep_in);
+
+}
+
+static int dvc_dfx_function_set_alt(struct usb_function *f,
+		unsigned intf, unsigned alt)
+{
+	struct dvc_dfx_dev	*dev = func_to_dvc_dfx(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
+	int ret;
+
+	pr_info("%s intf: %d alt: %d\n", __func__, intf, alt);
+	if (intf == dfx_data_interface_desc.bInterfaceNumber) {
+		ret = config_ep_by_speed(cdev->gadget, f, dev->ep_in);
+		if (ret) {
+			pr_err("%s intf: %d alt: %d ep_by_speed in error %d\n",
+				__func__, intf, alt, ret);
+			return ret;
+		}
+		ret = usb_ep_enable(dev->ep_in);
+		if (ret) {
+			pr_err("%s intf: %d alt: %d ep_enable in err %d\n",
+				__func__, intf, alt, ret);
+			return ret;
+		}
+
+		ret = config_ep_by_speed(cdev->gadget, f, dev->ep_out);
+		if (ret) {
+			pr_err("%s intf: %d alt: %d ep_enable out error %d\n",
+				__func__, intf, alt, ret);
+			return ret;
+		}
+
+		ret = usb_ep_enable(dev->ep_out);
+		if (ret) {
+			pr_err("%s intf: %d alt: %d ep_enable out err %d\n",
+				__func__, intf, alt, ret);
+			usb_ep_disable(dev->ep_in);
+			return ret;
+		}
+		dev->online_data = 1;
+	}
+	if (intf == dfx_interface_desc.bInterfaceNumber)
+		dev->online_ctrl = 1;
+
+	if (dev->online_data && dev->online_ctrl) {
+		dev->online = 1;
+		dev->error = 0;
+	}
+
+	/* readers may be blocked waiting for us to go online */
+	wake_up(&dev->read_wq);
+	return 0;
+}
+
+static void dvc_dfx_function_disable(struct usb_function *f)
+{
+	struct dvc_dfx_dev	*dev = func_to_dvc_dfx(f);
+	struct usb_composite_dev	*cdev = dev->cdev;
+
+	pr_info("%s cdev %p\n", __func__, cdev);
+
+	if (dev->transfering)
+		dvc_dfx_disable_transfer();
+
+	dev->online = 0;
+	dev->online_ctrl = 0;
+	dev->online_data = 0;
+	dev->error = 0;
+	usb_ep_disable(dev->ep_in);
+	usb_ep_disable(dev->ep_out);
+
+	/* readers may be blocked waiting for us to go online */
+	wake_up(&dev->read_wq);
+
+	pr_debug("%s disabled\n", dev->function.name);
+}
+
+static int dvc_dfx_bind_config(struct usb_configuration *c)
+{
+	struct dvc_dfx_dev *dev = _dvc_dfx_dev;
+	int status;
+
+	pr_info("%s\n", __func__);
+
+	if (dfx_string_defs[DVCDFX_CTRL_IDX].id == 0) {
+		status = usb_string_id(c->cdev);
+		if (status < 0)
+			return status;
+		dfx_string_defs[DVCDFX_CTRL_IDX].id = status;
+
+		dfx_interface_desc.iInterface = status;
+
+		status = usb_string_id(c->cdev);
+		if (status < 0)
+			return status;
+		dfx_string_defs[DVCDFX_DATA_IDX].id = status;
+
+		dfx_data_interface_desc.iInterface = status;
+
+		status = usb_string_id(c->cdev);
+		if (status < 0)
+			return status;
+		dfx_string_defs[DVCDFX_IAD_IDX].id = status;
+
+		dfx_iad_desc.iFunction = status;
+	}
+
+	dev->cdev = c->cdev;
+	dev->function.name = "dvcdfx";
+	dev->function.fs_descriptors = fs_dfx_descs;
+	dev->function.hs_descriptors = hs_dfx_descs;
+	dev->function.ss_descriptors = ss_dfx_descs;
+	dev->function.strings = dfx_strings;
+	dev->function.bind = dvc_dfx_function_bind;
+	dev->function.unbind = dvc_dfx_function_unbind;
+	dev->function.set_alt = dvc_dfx_function_set_alt;
+	dev->function.disable = dvc_dfx_function_disable;
+
+	return usb_add_function(c, &dev->function);
+}
+
+static int dvc_dfx_setup(void)
+{
+	struct dvc_dfx_dev *dev;
+	int ret;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	spin_lock_init(&dev->lock);
+
+	init_waitqueue_head(&dev->read_wq);
+	init_waitqueue_head(&dev->write_wq);
+
+	INIT_LIST_HEAD(&dev->tx_idle);
+	INIT_LIST_HEAD(&dev->tx_xfer);
+
+	atomic_set(&dev->open_excl, 0);
+	atomic_set(&dev->read_excl, 0);
+	atomic_set(&dev->write_excl, 0);
+
+	_dvc_dfx_dev = dev;
+
+	ret = misc_register(&dvc_dfx_device);
+	if (ret)
+		goto err;
+
+	return 0;
+
+err:
+	kfree(dev);
+	pr_err("DvC.Dfx gadget driver failed to initialize\n");
+	return ret;
+}
+
+static void dvc_dfx_cleanup(void)
+{
+	misc_deregister(&dvc_dfx_device);
+
+	kfree(_dvc_dfx_dev);
+	_dvc_dfx_dev = NULL;
+}
diff --git a/drivers/usb/gadget/f_dvc_trace.c b/drivers/usb/gadget/f_dvc_trace.c
new file mode 100644
index 0000000..4837bf1
--- /dev/null
+++ b/drivers/usb/gadget/f_dvc_trace.c
@@ -0,0 +1,887 @@
+/*
+ * Gadget Driver for Android DvC.Trace Debug Capability
+ *
+ * Copyright (C) 2008-2010, Intel Corporation.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/miscdevice.h>
+#include <linux/usb/debug.h>
+#include <linux/sdm.h>
+
+#define TRACE_TX_REQ_MAX 3
+
+#define CONFIG_BOARD_MRFLD_VV
+
+struct dvc_trace_dev {
+	struct usb_function function;
+	struct usb_composite_dev *cdev;
+	spinlock_t lock;
+	u8	ctrl_id, data_id;
+	u8	class_id, subclass_id;
+
+	struct usb_ep *ep_in;
+
+	int online;
+	int online_data;
+	int online_ctrl;
+	int transfering;
+	int error;
+
+	atomic_t write_excl;
+	atomic_t open_excl;
+
+	wait_queue_head_t write_wq;
+
+	struct list_head tx_idle;
+	struct list_head tx_xfer;
+};
+
+static struct usb_interface_assoc_descriptor trace_iad_desc = {
+	.bLength		= sizeof(trace_iad_desc),
+	.bDescriptorType	= USB_DT_INTERFACE_ASSOCIATION,
+	/* .bFirstInterface	= DYNAMIC, */
+	.bInterfaceCount	= 2, /* debug control + data */
+	.bFunctionClass		= USB_CLASS_DEBUG,
+	.bFunctionSubClass	= USB_SUBCLASS_DVC_TRACE,
+	/* .bFunctionProtocol	= 0, */
+	/* .iFunction		= DYNAMIC, */
+};
+
+static struct usb_interface_descriptor trace_interface_desc = {
+	.bLength                = USB_DT_INTERFACE_SIZE,
+	.bDescriptorType        = USB_DT_INTERFACE,
+	.bNumEndpoints          = 0,
+	.bInterfaceClass        = USB_CLASS_DEBUG,
+	.bInterfaceSubClass     = USB_SUBCLASS_DEBUG_CONTROL,
+	/* .bInterfaceProtocol     = 0, */
+};
+
+#define DC_DVCTRACE_ATTRI_LENGTH	DC_DBG_ATTRI_SIZE(2, 32)
+/* 1 input terminal, 1 output terminal and 1 feature unit */
+#define DC_DVCTRACE_TOTAL_LENGTH (DC_DVCTRACE_ATTRI_LENGTH \
+	+ DC_OUTPUT_CONNECTION_SIZE \
+	+ DC_OUTPUT_CONNECTION_SIZE \
+	+ DC_DBG_UNIT_SIZE(STM_NB_IN_PINS, 2, 2, 24))
+
+DECLARE_DC_DEBUG_ATTR_DESCR(DVCT, 2, 32);
+
+static struct DC_DEBUG_ATTR_DESCR(DVCT) trace_debug_attri_desc = {
+	.bLength		= DC_DVCTRACE_ATTRI_LENGTH,
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype	= DC_DEBUG_ATTRIBUTES,
+	.bcdDC			= __constant_cpu_to_le16(0x0100),
+	.wTotalLength	= __constant_cpu_to_le16(DC_DVCTRACE_TOTAL_LENGTH),
+	.bmSupportedFeatures	= 0, /* Debug Event Supported, per SAS */
+	.bControlSize		= 2,
+	.bmControl		= {	/* per SAS */
+		[0]		= 0xFF,
+		[1]		= 0x3F,
+	},
+	.wAuxDataSize		= __constant_cpu_to_le16(0x20),
+	.dInputBufferSize	= __constant_cpu_to_le32(0x00), /* per SAS */
+	.dOutputBufferSize = __constant_cpu_to_le32(TRACE_BULK_BUFFER_SIZE),
+	.qBaseAddress		= 0, /* revision */
+	.hGlobalID		= { /* revision */
+		[0]		= 0,
+		[1]		= 0,
+	}
+};
+
+static struct dc_output_connection_descriptor trace_output_conn_usb_desc = {
+	.bLength		= DC_OUTPUT_CONNECTION_SIZE,
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype	= DC_OUTPUT_CONNECTION,
+	.bConnectionID		= 0x01, /* USB */
+	.bConnectionType	= DC_CONNECTION_USB,
+	.bAssocConnection	= 0, /* No related input-connection */
+	.wSourceID		= __constant_cpu_to_le16(0x01),
+	/* .iConnection		= DYNAMIC, */
+};
+
+static struct dc_output_connection_descriptor trace_output_conn_pti_desc = {
+	.bLength		= DC_OUTPUT_CONNECTION_SIZE,
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype	= DC_OUTPUT_CONNECTION,
+	.bConnectionID		= 0, /* PTI */
+	.bConnectionType	= DC_CONNECTION_DEBUG_DATA,
+	.bAssocConnection	= 0, /* No related input-connection */
+	.wSourceID		= __constant_cpu_to_le16(0x01),
+	/* .iConnection		= DYNAMIC, */
+};
+
+#define DC_DVCTRACE_UNIT_LENGTH	DC_DBG_UNIT_SIZE(STM_NB_IN_PINS, 2, 2, 24)
+
+DECLARE_DC_DEBUG_UNIT_DESCRIPTOR(STM_NB_IN_PINS, 2, 2, 24);
+
+static struct DC_DEBUG_UNIT_DESCRIPTOR(STM_NB_IN_PINS, 2, 2, 24)
+		trace_debug_unit_stm_desc = {
+	.bLength		= DC_DVCTRACE_UNIT_LENGTH,
+	.bDescriptorType	= USB_DT_CS_INTERFACE,
+	.bDescriptorSubtype	= DC_DEBUG_UNIT,
+	.bUnitID		= 0x01, /* per SAS */
+/* STM Trace Unit processor: revision */
+	.bDebugUnitType		= DC_UNIT_TYPE_TRACE_PROC,
+ /* STM: Trace compressor controller */
+	.bDebugSubUnitType	= DC_UNIT_SUBTYPE_TRACEZIP,
+	.bAliasUnitID		= 0, /* no associated debug unit */
+	.bNrInPins		= STM_NB_IN_PINS, /* p */
+/* wSourceID  contains STM_NB_IN_PINS elements */
+/*	.wSourceID		= {0}, */
+	.bNrOutPins		= 0x02,	/* q */
+	.dTraceFormat		= {
+		[0]	= __constant_cpu_to_le32(DC_TRACE_MIPI_FORMATED_STPV1),
+		[1]	= __constant_cpu_to_le32(DC_TRACE_MIPI_FORMATED_STPV1),
+	},
+	.dStreamID		= __constant_cpu_to_le32(0xFFFFFFFF),
+	.bControlSize		= 0x02,	/* n */
+	.bmControl		= {
+		[0]		= 0xFF,
+		[1]		= 0x3F,
+	},
+	.wAuxDataSize		= __constant_cpu_to_le16(24), /* m */
+	.qBaseAddress		= 0, /* revision */
+	.hIPID			= {
+		[0]		= 0,
+		[1]		= 0,
+	},
+	/* .iDebugUnitType		= DYNAMIC, */
+};
+
+static struct usb_interface_descriptor trace_data_interface_desc = {
+	.bLength                = USB_DT_INTERFACE_SIZE,
+	.bDescriptorType        = USB_DT_INTERFACE,
+	.bAlternateSetting	= 0,
+	.bNumEndpoints          = 1,
+	.bInterfaceClass        = USB_CLASS_DEBUG,
+	.bInterfaceSubClass     = USB_SUBCLASS_DVC_TRACE,
+	/* .bInterfaceProtocol     = 0, */
+};
+
+static struct usb_endpoint_descriptor trace_fullspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_endpoint_descriptor trace_highspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(512),
+};
+
+static struct usb_endpoint_descriptor trace_superspeed_in_desc = {
+	.bLength                = USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType        = USB_DT_ENDPOINT,
+	.bEndpointAddress       = USB_DIR_IN,
+	.bmAttributes           = USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize         = __constant_cpu_to_le16(1024),
+};
+
+static struct usb_ss_ep_comp_descriptor trace_superspeed_in_comp_desc = {
+	.bLength		= USB_DT_SS_EP_COMP_SIZE,
+	.bDescriptorType	= USB_DT_SS_ENDPOINT_COMP,
+	.bMaxBurst		= 0,
+	.bmAttributes		= 0,
+};
+
+static struct usb_descriptor_header *fs_trace_descs[] = {
+	(struct usb_descriptor_header *) &trace_iad_desc,
+	(struct usb_descriptor_header *) &trace_data_interface_desc,
+	(struct usb_descriptor_header *) &trace_fullspeed_in_desc,
+	(struct usb_descriptor_header *) &trace_interface_desc,
+	(struct usb_descriptor_header *) &trace_debug_attri_desc,
+	(struct usb_descriptor_header *) &trace_output_conn_pti_desc,
+	(struct usb_descriptor_header *) &trace_output_conn_usb_desc,
+	(struct usb_descriptor_header *) &trace_debug_unit_stm_desc,
+	NULL,
+};
+
+static struct usb_descriptor_header *hs_trace_descs[] = {
+	(struct usb_descriptor_header *) &trace_iad_desc,
+	(struct usb_descriptor_header *) &trace_data_interface_desc,
+	(struct usb_descriptor_header *) &trace_highspeed_in_desc,
+	(struct usb_descriptor_header *) &trace_interface_desc,
+	(struct usb_descriptor_header *) &trace_debug_attri_desc,
+	(struct usb_descriptor_header *) &trace_output_conn_pti_desc,
+	(struct usb_descriptor_header *) &trace_output_conn_usb_desc,
+	(struct usb_descriptor_header *) &trace_debug_unit_stm_desc,
+	NULL,
+};
+
+static struct usb_descriptor_header *ss_trace_descs[] = {
+	(struct usb_descriptor_header *) &trace_iad_desc,
+	(struct usb_descriptor_header *) &trace_data_interface_desc,
+	(struct usb_descriptor_header *) &trace_superspeed_in_desc,
+	(struct usb_descriptor_header *) &trace_superspeed_in_comp_desc,
+	(struct usb_descriptor_header *) &trace_interface_desc,
+	(struct usb_descriptor_header *) &trace_debug_attri_desc,
+	(struct usb_descriptor_header *) &trace_output_conn_pti_desc,
+	(struct usb_descriptor_header *) &trace_output_conn_usb_desc,
+	(struct usb_descriptor_header *) &trace_debug_unit_stm_desc,
+	NULL,
+};
+
+/* string descriptors: */
+#define DVCTRACE_CTRL_IDX	0
+#define DVCTRACE_DATA_IDX	1
+#define DVCTRACE_IAD_IDX	2
+#define DVCTRACE_CONN_PTI_IDX	3
+#define DVCTRACE_CONN_USB_IDX	4
+#define DVCTRACE_UNIT_STM_IDX	5
+
+/* static strings, in UTF-8 */
+static struct usb_string trace_string_defs[] = {
+	[DVCTRACE_CTRL_IDX].s = "Debug Sub-Class DvC.Trace (Control)",
+	[DVCTRACE_DATA_IDX].s = "Debug Sub-Class DvC.Trace (Data)",
+	[DVCTRACE_IAD_IDX].s = "Debug Sub-Class DvC.Trace",
+	[DVCTRACE_CONN_PTI_IDX].s = "MIPI PTIv1 output Connector ",
+	[DVCTRACE_CONN_USB_IDX].s = "USB Device output connector",
+	[DVCTRACE_UNIT_STM_IDX].s = "MIPI STM Debug Unit",
+	{  /* ZEROES END LIST */ },
+};
+
+static struct usb_gadget_strings trace_string_table = {
+	.language =		0x0409,	/* en-us */
+	.strings =		trace_string_defs,
+};
+
+static struct usb_gadget_strings *trace_strings[] = {
+	&trace_string_table,
+	NULL,
+};
+
+/* temporary var used between dvc_trace_open() and dvc_trace_gadget_bind() */
+static struct dvc_trace_dev *_dvc_trace_dev;
+
+static inline struct dvc_trace_dev *func_to_dvc_trace(struct usb_function *f)
+{
+	return container_of(f, struct dvc_trace_dev, function);
+}
+
+static int dvc_trace_is_enabled(void)
+{
+	if (!stm_is_enabled()) {
+		pr_info("%s STM/PTI block is not enabled\n", __func__);
+		return 0;
+	}
+	return 1;
+}
+
+static struct usb_request *dvc_trace_request_new(struct usb_ep *ep,
+					 int buffer_size, dma_addr_t dma)
+{
+	struct usb_request *req = usb_ep_alloc_request(ep, GFP_KERNEL);
+	if (!req)
+		return NULL;
+
+	req->dma = dma;
+	/* now allocate buffers for the requests */
+	req->buf = kmalloc(buffer_size, GFP_KERNEL);
+	if (!req->buf) {
+		usb_ep_free_request(ep, req);
+		return NULL;
+	}
+
+	return req;
+}
+
+static void dvc_trace_request_free(struct usb_request *req, struct usb_ep *ep)
+{
+	if (req) {
+		kfree(req->buf);
+		usb_ep_free_request(ep, req);
+	}
+}
+
+/* add a request to the tail of a list */
+static void dvc_trace_req_put(struct dvc_trace_dev *dev, struct list_head *head,
+		struct usb_request *req)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	list_add_tail(&req->list, head);
+	spin_unlock_irqrestore(&dev->lock, flags);
+}
+
+/* remove a request from the head of a list */
+static struct usb_request *dvc_trace_req_get(struct dvc_trace_dev *dev,
+			struct list_head *head)
+{
+	unsigned long flags;
+	struct usb_request *req;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (list_empty(head)) {
+		req = 0;
+	} else {
+		req = list_first_entry(head, struct usb_request, list);
+		list_del(&req->list);
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return req;
+}
+
+static void dvc_trace_set_disconnected(struct dvc_trace_dev *dev)
+{
+	dev->transfering = 0;
+}
+
+static void dvc_trace_complete_in(struct usb_ep *ep, struct usb_request *req)
+{
+	struct dvc_trace_dev *dev = _dvc_trace_dev;
+
+	if (req->status != 0)
+		dvc_trace_set_disconnected(dev);
+
+	dvc_trace_req_put(dev, &dev->tx_idle, req);
+
+	wake_up(&dev->write_wq);
+}
+
+static inline int dvc_trace_lock(atomic_t *excl)
+{
+	if (atomic_inc_return(excl) == 1) {
+		return 0;
+	} else {
+		atomic_dec(excl);
+		return -1;
+	}
+}
+
+static inline void dvc_trace_unlock(atomic_t *excl)
+{
+	atomic_dec(excl);
+}
+
+static int trace_create_bulk_endpoints(struct dvc_trace_dev *dev,
+				       struct usb_endpoint_descriptor *in_desc,
+				       struct usb_ss_ep_comp_descriptor *in_comp_desc
+	)
+{
+	struct usb_composite_dev *cdev = dev->cdev;
+	struct usb_request *req;
+	struct usb_ep *ep;
+	int i;
+
+	pr_debug("%s dev: %p\n", __func__, dev);
+
+	in_desc->bEndpointAddress |= 0x1;
+	ep = usb_ep_autoconfig_ss(cdev->gadget, in_desc, in_comp_desc);
+	if (!ep) {
+		pr_err("%s usb_ep_autoconfig for ep_in failed\n", __func__);
+		return -ENODEV;
+	}
+	pr_debug("%s usb_ep_autoconfig for ep_in got %s\n", __func__, ep->name);
+
+	ep->driver_data = dev;		/* claim the endpoint */
+	dev->ep_in = ep;
+
+	for (i = 0; i < TRACE_TX_REQ_MAX; i++) {
+		req = dvc_trace_request_new(dev->ep_in, TRACE_BULK_BUFFER_SIZE,
+			(dma_addr_t)TRACE_BULK_IN_BUFFER_ADDR);
+		if (!req)
+			goto fail;
+		req->complete = dvc_trace_complete_in;
+		dvc_trace_req_put(dev, &dev->tx_idle, req);
+		pr_debug("%s req= %x : for %s predefined TRB\n", __func__,
+			(uint)req, ep->name);
+	}
+
+	return 0;
+
+fail:
+	pr_err("%s could not allocate requests\n", __func__);
+	return -1;
+}
+
+static ssize_t dvc_trace_start_transfer(size_t count)
+{
+	struct dvc_trace_dev *dev = _dvc_trace_dev;
+	struct usb_request *req = 0;
+	int r = count, xfer;
+	int ret;
+
+	pr_debug("%s\n", __func__);
+	if (!_dvc_trace_dev)
+		return -ENODEV;
+
+	if (dvc_trace_lock(&dev->write_excl))
+		return -EBUSY;
+
+	/* we will block until enumeration completes */
+	while (!(dev->online || dev->error)) {
+		pr_debug("%s: waiting for online state\n", __func__);
+		ret = wait_event_interruptible(dev->write_wq,
+				(dev->online || dev->error));
+
+		if (ret < 0) {
+			/* not at CONFIGURED state */
+			pr_info("%s !dev->online already\n", __func__);
+			dvc_trace_unlock(&dev->write_excl);
+			return ret;
+		}
+	}
+
+	/* queue a ep_in endless request */
+	while (r > 0) {
+		if (dev->error) {
+			pr_debug("%s dev->error\n", __func__);
+			r = -EIO;
+			break;
+		}
+
+		if (!dev->online) {
+			pr_debug("%s !dev->online\n", __func__);
+			r = -EIO;
+			break;
+		}
+
+		/* get an idle tx request to use */
+		req = 0;
+		ret = wait_event_interruptible(dev->write_wq,
+				dev->error || !dev->online ||
+				(req = dvc_trace_req_get(dev, &dev->tx_idle)));
+
+		if (ret < 0) {
+			r = ret;
+			break;
+		}
+
+		if (req != 0) {
+			if (count > TRACE_BULK_BUFFER_SIZE)
+				xfer = TRACE_BULK_BUFFER_SIZE;
+			else
+				xfer = count;
+			pr_debug("%s queue tx_idle list req to dev->ep_in\n",
+				__func__);
+			req->no_interrupt = 1;
+			req->context = &dev->function;
+			req->length = xfer;
+			ret = usb_ep_queue(dev->ep_in, req, GFP_ATOMIC);
+			if (ret < 0) {
+				pr_err("%s: xfer error %d\n", __func__, ret);
+				dev->error = 1;
+				dev->transfering = 0;
+				r = -EIO;
+				break;
+			}
+			pr_debug("%s: xfer=%d/%d  queued req/%x\n", __func__,
+				xfer, r, (uint)req);
+			dvc_trace_req_put(dev, &dev->tx_xfer, req);
+			r -= xfer;
+
+			/* zero this so we don't try to free it on error exit */
+			req = 0;
+		}
+	}
+	if (req) {
+		pr_debug("%s req re-added to tx_idle on error\n", __func__);
+		dvc_trace_req_put(dev, &dev->tx_idle, req);
+	} else {
+		dev->transfering = 1;
+	}
+	dvc_trace_unlock(&dev->write_excl);
+	pr_debug("%s end\n", __func__);
+	return ret;
+}
+
+static int dvc_trace_disable_transfer(void)
+{
+	struct dvc_trace_dev *dev = _dvc_trace_dev;
+	struct usb_request *req = 0;
+	int ret;
+
+	pr_debug("%s\n", __func__);
+	if (!_dvc_trace_dev)
+		return -ENODEV;
+
+	if (dvc_trace_lock(&dev->write_excl))
+		return -EBUSY;
+
+	if (dev->error) {
+		pr_debug("%s dev->error\n", __func__);
+		dvc_trace_unlock(&dev->write_excl);
+		return -EIO;
+	}
+
+	if ((!dev->online) || (!dev->transfering)) {
+		pr_debug("%s !dev->online OR !dev->transfering\n", __func__);
+		dvc_trace_unlock(&dev->write_excl);
+		return -EIO;
+	}
+
+	/* get an xfer tx request to use */
+	while ((req = dvc_trace_req_get(dev, &dev->tx_xfer))) {
+		ret = usb_ep_dequeue(dev->ep_in, req);
+		if (ret < 0) {
+			pr_err("%s: dequeue error %d\n", __func__, ret);
+			dev->error = 1;
+			dvc_trace_unlock(&dev->write_excl);
+			return -EIO;
+		}
+		pr_debug("%s: dequeued req/%x\n", __func__, (uint)req);
+	}
+
+	dvc_trace_unlock(&dev->write_excl);
+	return 1;
+}
+
+static int dvc_trace_open(struct inode *ip, struct file *fp)
+{
+	pr_debug("%s\n", __func__);
+	if (!_dvc_trace_dev)
+		return -ENODEV;
+
+	if (dvc_trace_lock(&_dvc_trace_dev->open_excl))
+		return -EBUSY;
+
+	fp->private_data = _dvc_trace_dev;
+
+	/* clear the error latch */
+	_dvc_trace_dev->error = 0;
+	_dvc_trace_dev->transfering = 0;
+
+	return 0;
+}
+
+static int dvc_trace_release(struct inode *ip, struct file *fp)
+{
+	pr_debug("%s\n", __func__);
+
+	dvc_trace_unlock(&_dvc_trace_dev->open_excl);
+	return 0;
+}
+
+/* file operations for DvC.Trace device /dev/usb_dvc_trace */
+static const struct file_operations dvc_trace_fops = {
+	.owner = THIS_MODULE,
+	.open = dvc_trace_open,
+	.release = dvc_trace_release,
+};
+
+static struct miscdevice dvc_trace_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "usb_dvc_trace",
+	.fops = &dvc_trace_fops,
+};
+
+static int dvc_trace_ctrlrequest(struct usb_composite_dev *cdev,
+				const struct usb_ctrlrequest *ctrl)
+{
+
+	struct dvc_trace_dev *dev = _dvc_trace_dev;
+	int	value = -EOPNOTSUPP;
+	int	ret;
+	u16	w_index = le16_to_cpu(ctrl->wIndex);
+	u16	w_value = le16_to_cpu(ctrl->wValue);
+	u16	w_length = le16_to_cpu(ctrl->wLength);
+
+	pr_debug("%s %02x.%02x v%04x i%04x l%u\n", __func__,
+			ctrl->bRequestType, ctrl->bRequest,
+			w_value, w_index, w_length);
+
+	switch ((ctrl->bRequestType << 8) | ctrl->bRequest) {
+
+	/* DC_REQUEST_SET_RESET ... stop active transfer */
+	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)
+		| DC_REQUEST_SET_RESET:
+		if (w_index != dev->data_id)
+			goto invalid;
+
+		pr_info("%s DC_REQUEST_SET_RESET v%04x i%04x l%u\n", __func__,
+			 w_value, w_index, w_length);
+
+		dvc_trace_disable_transfer();
+		value = 0;
+		break;
+
+	/* DC_REQUEST_SET_TRACE ... start trace transfer */
+	case ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8)
+		| DC_REQUEST_SET_TRACE:
+
+		pr_info("%s DC_REQUEST_SET_TRACE v%04x i%04x l%u\n", __func__,
+			 w_value, w_index, w_length);
+
+		if (!w_index)
+			ret = dvc_trace_disable_transfer();
+		else
+			ret = dvc_trace_start_transfer(4096);
+
+		if (ret < 0)
+			value = -EINVAL;
+		else
+			value = (int) w_index;
+		break;
+
+	default:
+invalid:
+		pr_debug("unknown class-specific control req "
+			 "%02x.%02x v%04x i%04x l%u\n",
+			 ctrl->bRequestType, ctrl->bRequest,
+			 w_value, w_index, w_length);
+	}
+
+	/* respond with data transfer or status phase? */
+	if (value >= 0) {
+		cdev->req->zero = 0;
+		cdev->req->length = value;
+		value = usb_ep_queue(cdev->gadget->ep0, cdev->req, GFP_ATOMIC);
+		if (value < 0)
+			pr_err("%s setup response queue error\n", __func__);
+	}
+
+	/* device either stalls (value < 0) or reports success */
+	return value;
+}
+
+static int
+dvc_trace_function_bind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct usb_composite_dev	*cdev = c->cdev;
+	struct dvc_trace_dev		*dev = func_to_dvc_trace(f);
+	int			id;
+	int			ret;
+	int status;
+
+	dev->cdev = cdev;
+	pr_debug("%s dev: %p\n", __func__, dev);
+
+	/* maybe allocate device-global string IDs, and patch descriptors */
+	if (trace_string_defs[DVCTRACE_CTRL_IDX].id == 0) {
+		status = usb_string_id(cdev);
+		if (status < 0)
+			return status;
+		trace_string_defs[DVCTRACE_DATA_IDX].id = status;
+		trace_data_interface_desc.iInterface = status;
+
+		status = usb_string_id(cdev);
+		if (status < 0)
+			return status;
+		trace_string_defs[DVCTRACE_CTRL_IDX].id = status;
+		trace_interface_desc.iInterface = status;
+
+		status = usb_string_id(cdev);
+		if (status < 0)
+			return status;
+		trace_string_defs[DVCTRACE_IAD_IDX].id = status;
+		trace_iad_desc.iFunction = status;
+
+		status = usb_string_id(cdev);
+		if (status < 0)
+			return status;
+		trace_string_defs[DVCTRACE_CONN_PTI_IDX].id = status;
+		trace_output_conn_pti_desc.iConnection = status;
+
+		status = usb_string_id(cdev);
+		if (status < 0)
+			return status;
+		trace_string_defs[DVCTRACE_CONN_USB_IDX].id = status;
+		trace_output_conn_usb_desc.iConnection = status;
+
+		status = usb_string_id(cdev);
+		if (status < 0)
+			return status;
+		trace_string_defs[DVCTRACE_UNIT_STM_IDX].id = status;
+		trace_debug_unit_stm_desc.iDebugUnitType = status;
+	}
+
+	/* allocate interface ID(s) */
+	id = usb_interface_id(c, f);
+	if (id < 0)
+		return id;
+	dev->data_id = id;
+	trace_data_interface_desc.bInterfaceNumber = id;
+	trace_iad_desc.bFirstInterface = id;
+
+	id = usb_interface_id(c, f);
+	if (id < 0)
+		return id;
+	dev->ctrl_id = id;
+	trace_interface_desc.bInterfaceNumber = id;
+
+	/* allocate endpoints */
+	ret = trace_create_bulk_endpoints(dev, &trace_fullspeed_in_desc,
+					  &trace_superspeed_in_comp_desc);
+	if (ret)
+		return ret;
+
+	/* support high speed hardware */
+	if (gadget_is_dualspeed(c->cdev->gadget)) {
+		trace_highspeed_in_desc.bEndpointAddress =
+			trace_fullspeed_in_desc.bEndpointAddress;
+	}
+
+	if (gadget_is_superspeed(c->cdev->gadget)) {
+		trace_superspeed_in_desc.bEndpointAddress =
+			trace_fullspeed_in_desc.bEndpointAddress;
+	}
+
+	pr_debug("%s speed %s: IN/%s\n",
+			gadget_is_dualspeed(c->cdev->gadget) ? "dual" : "full",
+			f->name, dev->ep_in->name);
+	return 0;
+}
+
+static void
+dvc_trace_function_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct dvc_trace_dev	*dev = func_to_dvc_trace(f);
+	struct usb_request *req;
+
+	dev->online = 0;
+	dev->online_data = 0;
+	dev->online_ctrl = 0;
+	dev->error = 0;
+	trace_string_defs[DVCTRACE_CTRL_IDX].id = 0;
+
+	wake_up(&dev->write_wq);
+
+	while ((req = dvc_trace_req_get(dev, &dev->tx_idle)))
+		dvc_trace_request_free(req, dev->ep_in);
+}
+
+static int dvc_trace_function_set_alt(struct usb_function *f,
+		unsigned intf, unsigned alt)
+{
+	struct dvc_trace_dev	*dev = func_to_dvc_trace(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
+	int ret;
+
+	pr_debug("%s intf: %d alt: %d\n", __func__, intf, alt);
+
+	if (intf == trace_interface_desc.bInterfaceNumber)
+		dev->online_ctrl = 1;
+
+	if (intf == trace_data_interface_desc.bInterfaceNumber) {
+		ret = config_ep_by_speed(cdev->gadget, f, dev->ep_in);
+		if (ret) {
+			pr_err("%s intf: %d alt: %d ep_by_speed in err %d\n",
+				__func__, intf, alt, ret);
+			return ret;
+		}
+
+		ret = usb_ep_enable(dev->ep_in);
+		if (ret) {
+			pr_err("%s intf: %d alt: %d ep_enable in err %d\n",
+				__func__, intf, alt, ret);
+			return ret;
+		}
+		dev->online_data = 1;
+	}
+
+	if (dev->online_data && dev->online_ctrl) {
+		dev->online = 1;
+		dev->transfering = 0;
+	}
+
+	/* readers may be blocked waiting for us to go online */
+	wake_up(&dev->write_wq);
+	return 0;
+}
+
+static void dvc_trace_function_disable(struct usb_function *f)
+{
+	struct dvc_trace_dev	*dev = func_to_dvc_trace(f);
+	struct usb_composite_dev	*cdev = dev->cdev;
+
+	pr_debug("%s dev %p\n", __func__, cdev);
+
+	if (dev->transfering)
+		dvc_trace_disable_transfer();
+
+	dev->online = 0;
+	dev->online_data = 0;
+	dev->online_ctrl = 0;
+	dev->error = 0;
+	usb_ep_disable(dev->ep_in);
+
+	/* writer may be blocked waiting for us to go online */
+	wake_up(&dev->write_wq);
+
+	pr_debug("%s : %s disabled\n", __func__, dev->function.name);
+}
+
+static int dvc_trace_bind_config(struct usb_configuration *c)
+{
+	struct dvc_trace_dev *dev = _dvc_trace_dev;
+
+	pr_debug("%s\n", __func__);
+
+	dev->cdev = c->cdev;
+	dev->function.name = "dvctrace";
+	dev->function.strings = trace_strings;
+	dev->function.fs_descriptors = fs_trace_descs;
+	dev->function.hs_descriptors = hs_trace_descs;
+	dev->function.ss_descriptors = ss_trace_descs;
+	dev->function.bind = dvc_trace_function_bind;
+	dev->function.unbind = dvc_trace_function_unbind;
+	dev->function.set_alt = dvc_trace_function_set_alt;
+	dev->function.disable = dvc_trace_function_disable;
+
+	return usb_add_function(c, &dev->function);
+}
+
+static int dvc_trace_setup(void)
+{
+	struct dvc_trace_dev *dev;
+	int ret;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	spin_lock_init(&dev->lock);
+
+	INIT_LIST_HEAD(&dev->tx_idle);
+	INIT_LIST_HEAD(&dev->tx_xfer);
+
+	init_waitqueue_head(&dev->write_wq);
+
+	atomic_set(&dev->open_excl, 0);
+	atomic_set(&dev->write_excl, 0);
+
+	_dvc_trace_dev = dev;
+
+	ret = misc_register(&dvc_trace_device);
+	if (ret)
+		goto err;
+
+	return 0;
+
+err:
+	kfree(dev);
+	pr_err("DvC.Trace gadget driver failed to initialize\n");
+	return ret;
+}
+
+static void dvc_trace_cleanup(void)
+{
+	misc_deregister(&dvc_trace_device);
+
+	kfree(_dvc_trace_dev);
+	_dvc_trace_dev = NULL;
+}
diff --git a/drivers/usb/gadget/f_mass_storage.c b/drivers/usb/gadget/f_mass_storage.c
index b963939..930ccb2 100644
--- a/drivers/usb/gadget/f_mass_storage.c
+++ b/drivers/usb/gadget/f_mass_storage.c
@@ -3181,7 +3181,7 @@ static void fsg_unbind(struct usb_configuration *c, struct usb_function *f)
 		fsg->common->new_fsg = NULL;
 		raise_exception(fsg->common, FSG_STATE_CONFIG_CHANGE);
 		/* FIXME: make interruptible or killable somehow? */
-		wait_event(common->fsg_wait, common->fsg != fsg);
+		wait_event_timeout(common->fsg_wait, common->fsg != fsg, msecs_to_jiffies(1000));
 	}
 
 	usb_free_all_descriptors(&fsg->function);
diff --git a/drivers/usb/gadget/gadget_chips.h b/drivers/usb/gadget/gadget_chips.h
index bcd04bc..a3b44f2 100644
--- a/drivers/usb/gadget/gadget_chips.h
+++ b/drivers/usb/gadget/gadget_chips.h
@@ -16,6 +16,7 @@
 #define __GADGET_CHIPS_H
 
 #include <linux/usb/gadget.h>
+#include <asm/intel-mid.h>
 
 /*
  * NOTICE: the entries below are alphabetical and should be kept
@@ -29,11 +30,13 @@
  */
 #define gadget_is_at91(g)		(!strcmp("at91_udc", (g)->name))
 #define gadget_is_goku(g)		(!strcmp("goku_udc", (g)->name))
+#define gadget_is_middwc3tng(g)		((!strcmp("dwc3-gadget", (g)->name)) && \
+					 (intel_mid_identify_cpu() ==	\
+					  INTEL_MID_CPU_CHIP_TANGIER))
 #define gadget_is_musbhdrc(g)		(!strcmp("musb-hdrc", (g)->name))
 #define gadget_is_net2280(g)		(!strcmp("net2280", (g)->name))
 #define gadget_is_pxa(g)		(!strcmp("pxa25x_udc", (g)->name))
 #define gadget_is_pxa27x(g)		(!strcmp("pxa27x_udc", (g)->name))
-
 /**
  * gadget_supports_altsettings - return true if altsettings work
  * @gadget: the gadget in question
diff --git a/drivers/usb/gadget/multi.c b/drivers/usb/gadget/multi.c
index 940f6cd..ba96744 100644
--- a/drivers/usb/gadget/multi.c
+++ b/drivers/usb/gadget/multi.c
@@ -15,6 +15,7 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/moduleparam.h>
 #include <linux/netdevice.h>
 
 #include "u_serial.h"
@@ -46,6 +47,12 @@ USB_GADGET_COMPOSITE_OPTIONS();
 
 USB_ETHERNET_MODULE_PARAMETERS();
 
+static char ethernet_config[6];
+module_param_string(ethernet_config, ethernet_config, sizeof(ethernet_config),
+	0444);
+MODULE_PARM_DESC(ethernet_config,
+	"ethernet configuration : should be cdc or rndis");
+
 /***************************** Device Descriptor ****************************/
 
 #define MULTI_VENDOR_NUM	0x1d6b	/* Linux Foundation */
@@ -430,13 +437,31 @@ static int __ref multi_bind(struct usb_composite_dev *cdev)
 	device_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;
 
 	/* register configurations */
-	status = rndis_config_register(cdev);
-	if (unlikely(status < 0))
-		goto fail_string_ids;
+	/* RNDIS configuration */
+	if (strncmp(ethernet_config, "rndis", 5) == 0) {
+		status = rndis_config_register(cdev);
+
+		if (unlikely(status < 0))
+			goto fail2;
+	} else if (strncmp(ethernet_config, "cdc", 3) == 0) {
+		/* CDC ECM configuration  */
+		status = cdc_config_register(cdev);
+
+		if (unlikely(status < 0))
+			goto fail2;
+	} else {
+		status = rndis_config_register(cdev);
+
+		if (unlikely(status < 0))
+			goto fail2;
+
+		status = cdc_config_register(cdev);
+
+		if (unlikely(status < 0))
+			goto fail2;
+	}
+
 
-	status = cdc_config_register(cdev);
-	if (unlikely(status < 0))
-		goto fail_string_ids;
 	usb_composite_overwrite_options(cdev, &coverwrite);
 
 	/* we're done */
diff --git a/drivers/usb/gadget/u_ether.c b/drivers/usb/gadget/u_ether.c
index b7d4f82..9c55454 100644
--- a/drivers/usb/gadget/u_ether.c
+++ b/drivers/usb/gadget/u_ether.c
@@ -222,8 +222,6 @@ rx_submit(struct eth_dev *dev, struct usb_request *req, gfp_t gfp_flags)
 	 */
 	size += sizeof(struct ethhdr) + dev->net->mtu + RX_EXTRA;
 	size += dev->port_usb->header_len;
-	size += out->maxpacket - 1;
-	size -= size % out->maxpacket;
 
 	if (dev->port_usb->is_fixed)
 		size = max_t(size_t, size, dev->port_usb->fixed_out_len);
diff --git a/drivers/usb/gadget/u_serial.c b/drivers/usb/gadget/u_serial.c
index ad0aca8..f792236 100644
--- a/drivers/usb/gadget/u_serial.c
+++ b/drivers/usb/gadget/u_serial.c
@@ -1075,7 +1075,7 @@ static void gserial_free_port(struct gs_port *port)
 {
 	tasklet_kill(&port->push);
 	/* wait for old opens to finish */
-	wait_event(port->port.close_wait, gs_closed(port));
+	wait_event_timeout(port->port.close_wait, gs_closed(port), msecs_to_jiffies(1000));
 	WARN_ON(port->port_usb != NULL);
 	tty_port_destroy(&port->port);
 	kfree(port);
diff --git a/drivers/usb/host/ehci-pci.c b/drivers/usb/host/ehci-pci.c
index ca7b964..3f77944 100644
--- a/drivers/usb/host/ehci-pci.c
+++ b/drivers/usb/host/ehci-pci.c
@@ -383,7 +383,7 @@ static struct pci_driver ehci_pci_driver = {
 
 static int __init ehci_pci_init(void)
 {
-	if (usb_disabled())
+	//if (usb_disabled())
 		return -ENODEV;
 
 	pr_info("%s: " DRIVER_DESC "\n", hcd_name);
diff --git a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c
index 6ab64d7..2aef940 100644
--- a/drivers/usb/host/xhci-plat.c
+++ b/drivers/usb/host/xhci-plat.c
@@ -304,12 +304,23 @@ static struct platform_driver usb_xhci_driver = {
 };
 MODULE_ALIAS("platform:xhci-hcd");
 
+#ifdef CONFIG_USB_DWC3_HOST_INTEL
+#include "../dwc3/dwc3-host-intel.c"
+#endif
+
 int xhci_register_plat(void)
 {
+#ifdef CONFIG_USB_DWC3_HOST_INTEL
+	return platform_driver_register(&dwc3_xhci_driver);
+#endif
 	return platform_driver_register(&usb_xhci_driver);
 }
 
 void xhci_unregister_plat(void)
 {
+#ifdef CONFIG_USB_DWC3_HOST_INTEL
+	platform_driver_unregister(&dwc3_xhci_driver);
+	return;
+#endif
 	platform_driver_unregister(&usb_xhci_driver);
 }
diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
index 0670b6f..b275f06 100644
--- a/drivers/usb/host/xhci.c
+++ b/drivers/usb/host/xhci.c
@@ -342,6 +342,9 @@ static void xhci_cleanup_msix(struct xhci_hcd *xhci)
 
 	xhci_free_irq(xhci);
 
+	if (xhci->quirks & XHCI_PLAT)
+		return;
+
 	if (xhci->msix_entries) {
 		pci_disable_msix(pdev);
 		kfree(xhci->msix_entries);
diff --git a/drivers/usb/phy/penwell_otg.c b/drivers/usb/phy/penwell_otg.c
new file mode 100644
index 0000000..14b7d42
--- /dev/null
+++ b/drivers/usb/phy/penwell_otg.c
@@ -0,0 +1,5780 @@
+/*
+ * Intel Penwell USB OTG transceiver driver
+ * Copyright (C) 2009 - 2010, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+/* This driver helps to switch Penwell OTG controller function between host
+ * and peripheral. It works with EHCI driver and Penwell client controller
+ * driver together.
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/moduleparam.h>
+#include <linux/gpio.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include <linux/usb.h>
+#include <linux/usb/hcd.h>
+#include <linux/usb/otg.h>
+#include <linux/notifier.h>
+#include <linux/delay.h>
+#include <linux/pm_runtime.h>
+#include <linux/wakelock.h>
+#include <asm/intel_scu_pmic.h>
+#include <asm/intel_scu_ipc.h>
+#include <asm/intel-mid.h>
+#include "../core/usb.h"
+#include <linux/intel_mid_pm.h>
+
+#include <linux/usb/penwell_otg.h>
+
+#define	DRIVER_DESC		"Intel Penwell USB OTG transceiver driver"
+#define	DRIVER_VERSION		"0.8"
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("Henry Yuan <hang.yuan@intel.com>, Hao Wu <hao.wu@intel.com>");
+MODULE_VERSION(DRIVER_VERSION);
+MODULE_LICENSE("GPL");
+
+static const char driver_name[] = "penwell_otg";
+
+static void penwell_otg_remove(struct pci_dev *pdev);
+
+static int penwell_otg_set_host(struct usb_otg *otg, struct usb_bus *host);
+static int penwell_otg_set_peripheral(struct usb_otg *otg,
+				      struct usb_gadget *gadget);
+static int penwell_otg_start_srp(struct usb_otg *otg);
+static void penwell_otg_mon_bus(void);
+
+static int penwell_otg_msic_write(u16 addr, u8 data);
+
+static void penwell_otg_phy_low_power(int on);
+static int penwell_otg_ulpi_read(struct intel_mid_otg_xceiv *iotg,
+				u8 reg, u8 *val);
+static int penwell_otg_ulpi_write(struct intel_mid_otg_xceiv *iotg,
+				u8 reg, u8 val);
+static void penwell_spi_reset_phy(void);
+static int penwell_otg_charger_hwdet(bool enable);
+static void update_hsm(void);
+static void set_client_mode(void);
+
+#ifdef CONFIG_DEBUG_FS
+unsigned int *pm_sss0_base;
+
+int check_pm_otg(void)
+{
+	/* check whether bit 12 and 13 are 0 */
+	/* printk(">>>>leon, pm_sss0_base:0x%x\n", *(pm_sss0_base)); */
+	if (pm_sss0_base)
+		return (*pm_sss0_base) & 0x3000;
+	else
+		return 0;
+}
+#ifdef readl
+#undef readl
+#endif
+#ifdef writel
+#undef writel
+#endif
+#define readl(addr) ({ if (check_pm_otg()) { \
+	panic("usb otg, read reg:%p, pm_sss0_base:0x%x",  \
+	addr, *(pm_sss0_base)); }; __le32_to_cpu(__raw_readl(addr)); })
+#define writel(b, addr) ({ if (check_pm_otg()) { \
+	panic("usb otg, write reg:%p, pm_sss0_base:0x%x",  \
+	addr, *(pm_sss0_base)); }; __raw_writel(__cpu_to_le32(b), addr); })
+#endif
+
+#ifdef CONFIG_PM_SLEEP
+#include <linux/suspend.h>
+DECLARE_WAIT_QUEUE_HEAD(stop_host_wait);
+atomic_t pnw_sys_suspended;
+
+static int pnw_sleep_pm_callback(struct notifier_block *nfb,
+			unsigned long action, void *ignored)
+{
+	switch (action) {
+	case PM_SUSPEND_PREPARE:
+		atomic_set(&pnw_sys_suspended, 1);
+		return NOTIFY_OK;
+	case PM_POST_SUSPEND:
+		atomic_set(&pnw_sys_suspended, 0);
+		return NOTIFY_OK;
+	}
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block pnw_sleep_pm_notifier = {
+	.notifier_call = pnw_sleep_pm_callback,
+	.priority = 0
+};
+
+/* the root hub will call this callback when device added/removed */
+static int otg_notify(struct notifier_block *nb, unsigned long action,
+		struct usb_device *udev)
+{
+	struct usb_phy			*otg;
+	struct intel_mid_otg_xceiv	*iotg;
+
+	/* skip bus add/remove notification, else access udev->parent could
+	 * panic if bus register and unregister quickly(setup failed). And we
+	 * do not care bus event.
+	 */
+	if (action == USB_BUS_ADD || action == USB_BUS_REMOVE)
+		return NOTIFY_DONE;
+
+	/* Ignore root hub add/remove event */
+	if (!udev->parent) {
+		pr_debug("%s Ignore root hub otg_notify\n", __func__);
+		return NOTIFY_DONE;
+	}
+
+	/* Ignore USB devices on external hub */
+	if (udev->parent && udev->parent->parent) {
+		pr_debug("%s Ignore USB devices on external hub\n", __func__);
+		return NOTIFY_DONE;
+	}
+
+	otg = usb_get_phy(USB_PHY_TYPE_USB2);
+	if (otg == NULL) {
+		pr_err("%s: failed to get otg transceiver\n", __func__);
+		return NOTIFY_BAD;
+	}
+	iotg = otg_to_mid_xceiv(otg);
+
+	switch (action) {
+	case USB_DEVICE_ADD:
+		pr_debug("Notify OTG HNP add device\n");
+		atomic_notifier_call_chain(&iotg->iotg_notifier,
+					MID_OTG_NOTIFY_CONNECT, iotg);
+		break;
+	case USB_DEVICE_REMOVE:
+		pr_debug("Notify OTG HNP delete device\n");
+		atomic_notifier_call_chain(&iotg->iotg_notifier,
+					MID_OTG_NOTIFY_DISCONN, iotg);
+		break;
+	case USB_OTG_TESTDEV:
+		pr_debug("Notify OTG test device\n");
+		atomic_notifier_call_chain(&iotg->iotg_notifier,
+					MID_OTG_NOTIFY_TEST, iotg);
+		break;
+	case USB_OTG_TESTDEV_VBUSOFF:
+		pr_debug("Notify OTG test device, Vbusoff mode\n");
+		atomic_notifier_call_chain(&iotg->iotg_notifier,
+					MID_OTG_NOTIFY_TEST_VBUS_OFF, iotg);
+		break;
+	default:
+		usb_put_phy(otg);
+		return NOTIFY_DONE;
+	}
+	usb_put_phy(otg);
+	return NOTIFY_OK;
+}
+
+static struct notifier_block otg_nb = {
+	.notifier_call = otg_notify,
+};
+
+#define PNW_PM_RESUME_WAIT(a) do { \
+		while (atomic_read(&pnw_sys_suspended)) { \
+			wait_event_timeout(a, false, HZ/100); \
+		} \
+	} while (0)
+#else
+
+#define PNW_PM_RESUME_WAIT(a)
+
+#endif
+
+#define PNW_STOP_HOST(pnw) do { \
+	if ((pnw)->iotg.stop_host) { \
+		PNW_PM_RESUME_WAIT(stop_host_wait); \
+		(pnw)->iotg.stop_host(&(pnw)->iotg); \
+	} \
+	} while (0)
+
+inline int is_clovertrail(struct pci_dev *pdev)
+{
+	return (pdev->vendor == 0x8086 && pdev->device == 0xE006);
+}
+EXPORT_SYMBOL_GPL(is_clovertrail);
+
+static const char *state_string(enum usb_otg_state state)
+{
+	switch (state) {
+	case OTG_STATE_A_IDLE:
+		return "a_idle";
+	case OTG_STATE_A_WAIT_VRISE:
+		return "a_wait_vrise";
+	case OTG_STATE_A_WAIT_BCON:
+		return "a_wait_bcon";
+	case OTG_STATE_A_HOST:
+		return "a_host";
+	case OTG_STATE_A_SUSPEND:
+		return "a_suspend";
+	case OTG_STATE_A_PERIPHERAL:
+		return "a_peripheral";
+	case OTG_STATE_A_WAIT_VFALL:
+		return "a_wait_vfall";
+	case OTG_STATE_A_VBUS_ERR:
+		return "a_vbus_err";
+	case OTG_STATE_B_IDLE:
+		return "b_idle";
+	case OTG_STATE_B_PERIPHERAL:
+		return "b_peripheral";
+	case OTG_STATE_B_WAIT_ACON:
+		return "b_wait_acon";
+	case OTG_STATE_B_HOST:
+		return "b_host";
+	default:
+		return "UNDEFINED";
+	}
+}
+
+static const char *charger_string(enum usb_charger_type charger)
+{
+	switch (charger) {
+	case CHRG_SDP:
+		return "Standard Downstream Port";
+	case CHRG_SDP_INVAL:
+		return "Invalid Standard Downstream Port";
+	case CHRG_CDP:
+		return "Charging Downstream Port";
+	case CHRG_DCP:
+		return "Dedicated Charging Port";
+	case CHRG_ACA:
+		return "Accessory Charger Adaptor";
+	case CHRG_SE1:
+		return "SE1 Charger";
+	case CHRG_UNKNOWN:
+		return "Unknown";
+	default:
+		return "Undefined";
+	}
+}
+
+static const char *psc_string(enum power_supply_charger_cable_type charger)
+{
+	switch (charger) {
+	case POWER_SUPPLY_CHARGER_TYPE_USB_SDP:
+		return "Standard Downstream Port";
+	case POWER_SUPPLY_CHARGER_TYPE_USB_CDP:
+		return "Charging Downstream Port";
+	case POWER_SUPPLY_CHARGER_TYPE_USB_DCP:
+		return "Dedicated Charging Port";
+	case POWER_SUPPLY_CHARGER_TYPE_USB_ACA:
+		return "Accessory Charger Adaptor";
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK:
+		return "Accessory Charger Adaptor Dock";
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_A:
+		return "Accessory Charger Adaptor Type A";
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_B:
+		return "Accessory Charger Adaptor Type B";
+	case POWER_SUPPLY_CHARGER_TYPE_ACA_C:
+		return "Accessory Charger Adaptor Type C";
+	case POWER_SUPPLY_CHARGER_TYPE_SE1:
+		return "SE1 Charger";
+	case POWER_SUPPLY_CHARGER_TYPE_NONE:
+		return "Unknown";
+	default:
+		return "Undefined";
+	}
+}
+
+
+static struct penwell_otg *the_transceiver;
+
+void penwell_update_transceiver(void)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	unsigned long	flags;
+
+
+	if (!pnw->qwork) {
+		dev_warn(pnw->dev, "no workqueue for state machine\n");
+		return;
+	}
+
+	spin_lock_irqsave(&pnw->lock, flags);
+	if (!pnw->queue_stop) {
+		queue_work(pnw->qwork, &pnw->work);
+		dev_dbg(pnw->dev, "transceiver is updated\n");
+	}
+	spin_unlock_irqrestore(&pnw->lock, flags);
+}
+
+static int penwell_otg_set_host(struct usb_otg *otg, struct usb_bus *host)
+{
+	otg->host = host;
+
+	return 0;
+}
+
+static int penwell_otg_set_peripheral(struct usb_otg *otg,
+				      struct usb_gadget *gadget)
+{
+	otg->gadget = gadget;
+
+	return 0;
+}
+
+static void penwell_otg_set_charger(enum usb_charger_type charger)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+
+	dev_dbg(pnw->dev, "%s ---> %s\n", __func__,
+			charger_string(charger));
+
+	switch (charger) {
+	case CHRG_SDP:
+	case CHRG_DCP:
+	case CHRG_CDP:
+	case CHRG_ACA:
+	case CHRG_SDP_INVAL:
+	case CHRG_SE1:
+	case CHRG_UNKNOWN:
+		pnw->charging_cap.chrg_type = charger;
+		break;
+	default:
+		dev_warn(pnw->dev, "undefined charger type\n");
+		break;
+	}
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+}
+
+static void _penwell_otg_update_chrg_cap(enum usb_charger_type charger,
+				unsigned ma)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	int			flag = 0;
+	int			event, retval;
+
+	dev_dbg(pnw->dev, "%s = %s, %d --->\n", __func__,
+			charger_string(charger), ma);
+
+	/* Check charger type information */
+	if (pnw->charging_cap.chrg_type != charger) {
+		if (pnw->charging_cap.chrg_type == CHRG_UNKNOWN ||
+			charger == CHRG_UNKNOWN) {
+			penwell_otg_set_charger(charger);
+		} else if (pnw->charging_cap.chrg_type == CHRG_SDP &&
+			charger == CHRG_SDP_INVAL) {
+			penwell_otg_set_charger(charger);
+		} else
+			return;
+	} else {
+		/* Do nothing if no update for current */
+		if (pnw->charging_cap.ma == ma)
+			return;
+	}
+
+	/* set current */
+	switch (pnw->charging_cap.chrg_type) {
+	case CHRG_SDP:
+		if (pnw->charging_cap.ma == CHRG_CURR_DISCONN
+				&& (ma == CHRG_CURR_SDP_LOW
+				|| ma == CHRG_CURR_SDP_HIGH)) {
+			/* SDP event: charger connect */
+			event = USBCHRG_EVENT_CONNECT;
+			flag = 1;
+		} else if (pnw->charging_cap.ma == CHRG_CURR_SDP_LOW
+				&& ma == CHRG_CURR_SDP_HIGH) {
+			/* SDP event: configuration update */
+			event = USBCHRG_EVENT_UPDATE;
+			flag = 1;
+		} else if (pnw->charging_cap.ma == CHRG_CURR_SDP_HIGH
+				&& ma == CHRG_CURR_SDP_LOW) {
+			/* SDP event: configuration update */
+			event = USBCHRG_EVENT_UPDATE;
+			flag = 1;
+		} else if (pnw->charging_cap.ma == CHRG_CURR_SDP_SUSP
+				&& (ma == CHRG_CURR_SDP_LOW
+				|| ma == CHRG_CURR_SDP_HIGH)) {
+			/* SDP event: resume from suspend state */
+			event = USBCHRG_EVENT_RESUME;
+			flag = 1;
+		} else if ((pnw->charging_cap.ma == CHRG_CURR_SDP_LOW
+			|| pnw->charging_cap.ma == CHRG_CURR_SDP_HIGH)
+				&& ma == CHRG_CURR_SDP_SUSP) {
+			/* SDP event: enter suspend state */
+			event = USBCHRG_EVENT_SUSPEND;
+			flag = 1;
+		} else if (ma == 0) {
+			event = USBCHRG_EVENT_DISCONN;
+			flag = 1;
+		} else
+			dev_dbg(pnw->dev, "SDP: no need to update EM\n");
+		break;
+	case CHRG_DCP:
+		if (ma == CHRG_CURR_DCP) {
+			/* DCP event: charger connect */
+			event = USBCHRG_EVENT_CONNECT;
+			flag = 1;
+		} else
+			dev_dbg(pnw->dev, "DCP: no need to update EM\n");
+		break;
+	case CHRG_SE1:
+		if (ma == CHRG_CURR_SE1) {
+			/* SE1 event: charger connect */
+			event = USBCHRG_EVENT_CONNECT;
+			flag = 1;
+		} else
+			dev_dbg(pnw->dev, "SE1: no need to update EM\n");
+		break;
+	case CHRG_CDP:
+		if (pnw->charging_cap.ma == CHRG_CURR_DISCONN
+				&& ma == CHRG_CURR_CDP) {
+			/* CDP event: charger connect */
+			event = USBCHRG_EVENT_CONNECT;
+			flag = 1;
+		} else
+			dev_dbg(pnw->dev, "CDP: no need to update EM\n");
+		break;
+	case CHRG_UNKNOWN:
+		if (ma == CHRG_CURR_DISCONN) {
+			/* event: chargers disconnect */
+			event = USBCHRG_EVENT_DISCONN;
+			flag = 1;
+		} else
+			dev_dbg(pnw->dev, "UNKNOWN: no need to update EM\n");
+		break;
+	case CHRG_SDP_INVAL:
+		if (ma == CHRG_CURR_SDP_INVAL) {
+			event = USBCHRG_EVENT_UPDATE;
+			flag = 1;
+		} else
+			dev_dbg(pnw->dev, "SDP_INVAL: no need to update EM\n");
+	default:
+		break;
+	}
+
+	if (flag) {
+		pnw->charging_cap.ma = ma;
+		pnw->charging_cap.current_event = event;
+
+		/* Notify EM the charging current update */
+		dev_dbg(pnw->dev, "Notify EM charging capability change\n");
+		dev_dbg(pnw->dev, "%s event = %d ma = %d\n",
+			charger_string(pnw->charging_cap.chrg_type), event, ma);
+
+		if (pnw->bc_callback) {
+			retval = pnw->bc_callback(pnw->bc_arg, event,
+					&pnw->charging_cap);
+			if (retval)
+				dev_dbg(pnw->dev,
+					"bc callback return %d\n", retval);
+		}
+	}
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+}
+
+static enum power_supply_charger_cable_type usb_chrg_to_power_supply_chrg(
+				enum usb_charger_type chrg_type)
+{
+	switch (chrg_type) {
+	case CHRG_UNKNOWN: return POWER_SUPPLY_CHARGER_TYPE_NONE;
+	case CHRG_SDP: return POWER_SUPPLY_CHARGER_TYPE_USB_SDP;
+	case CHRG_CDP: return POWER_SUPPLY_CHARGER_TYPE_USB_CDP;
+	case CHRG_SDP_INVAL: return POWER_SUPPLY_CHARGER_TYPE_USB_SDP;
+	case CHRG_DCP: return POWER_SUPPLY_CHARGER_TYPE_USB_DCP;
+	case CHRG_ACA: return POWER_SUPPLY_CHARGER_TYPE_USB_ACA;
+	case CHRG_ACA_DOCK: return POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK;
+	case CHRG_ACA_A: return POWER_SUPPLY_CHARGER_TYPE_ACA_A;
+	case CHRG_ACA_B: return POWER_SUPPLY_CHARGER_TYPE_ACA_B;
+	case CHRG_ACA_C: return POWER_SUPPLY_CHARGER_TYPE_ACA_C;
+	case CHRG_SE1: return POWER_SUPPLY_CHARGER_TYPE_SE1;
+	case CHRG_MHL: return POWER_SUPPLY_CHARGER_TYPE_MHL;
+	default: return POWER_SUPPLY_CHARGER_TYPE_NONE;
+	}
+}
+
+static enum power_supply_charger_event check_psc_event(
+			struct power_supply_cable_props old,
+			struct power_supply_cable_props new)
+{
+	struct penwell_otg *pnw = the_transceiver;
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+
+	/* Check charger type information */
+	if (old.chrg_type != new.chrg_type) {
+		if (old.chrg_type == POWER_SUPPLY_CHARGER_TYPE_NONE
+					&& new.ma != 0)
+			return POWER_SUPPLY_CHARGER_EVENT_CONNECT;
+		else if (new.chrg_type == POWER_SUPPLY_CHARGER_TYPE_NONE)
+			return POWER_SUPPLY_CHARGER_EVENT_DISCONNECT;
+		else {
+			dev_dbg(pnw->dev, "not a valid event\n");
+			return -1;
+		}
+	}
+
+	/* Check the charging current limit */
+	if (old.ma == new.ma) {
+		dev_dbg(pnw->dev, "not a valid event\n");
+		return -1;
+	}
+
+	switch (new.chrg_type) {
+	case POWER_SUPPLY_CHARGER_TYPE_USB_SDP:
+		if (old.ma == CHRG_CURR_DISCONN &&
+		   (new.ma == CHRG_CURR_SDP_LOW ||
+		    new.ma == CHRG_CURR_SDP_HIGH)) {
+			/* SDP event: charger connect */
+			return POWER_SUPPLY_CHARGER_EVENT_CONNECT;
+		} else if (old.ma == CHRG_CURR_SDP_LOW &&
+			  new.ma == CHRG_CURR_SDP_HIGH) {
+			/* SDP event: configuration update */
+			return POWER_SUPPLY_CHARGER_EVENT_UPDATE;
+		} else if (old.ma == CHRG_CURR_SDP_HIGH &&
+			  new.ma == CHRG_CURR_SDP_LOW) {
+			/* SDP event: configuration update */
+			return POWER_SUPPLY_CHARGER_EVENT_UPDATE;
+		} else if (old.ma == CHRG_CURR_SDP_SUSP &&
+			  (new.ma == CHRG_CURR_SDP_LOW ||
+			   new.ma == CHRG_CURR_SDP_HIGH)) {
+			/* SDP event: resume from suspend state */
+			return POWER_SUPPLY_CHARGER_EVENT_RESUME;
+		} else if ((old.ma == CHRG_CURR_SDP_LOW ||
+			   old.ma == CHRG_CURR_SDP_HIGH) &&
+			  new.ma == CHRG_CURR_SDP_SUSP) {
+			/* SDP event: enter suspend state */
+			return POWER_SUPPLY_CHARGER_EVENT_SUSPEND;
+		} else
+			dev_dbg(pnw->dev, "SDP: no need to update EM\n");
+		break;
+	case POWER_SUPPLY_CHARGER_TYPE_USB_DCP:
+		if (new.ma == CHRG_CURR_DCP) {
+			/* DCP event: charger connect */
+			return POWER_SUPPLY_CHARGER_EVENT_CONNECT;
+		} else
+			dev_dbg(pnw->dev, "DCP: no need to update EM\n");
+		break;
+	case POWER_SUPPLY_CHARGER_TYPE_USB_CDP:
+		if (pnw->charging_cap.ma == CHRG_CURR_DISCONN &&
+		   new.ma == CHRG_CURR_CDP) {
+			/* CDP event: charger connect */
+			return POWER_SUPPLY_CHARGER_EVENT_CONNECT;
+		} else
+			dev_dbg(pnw->dev, "CDP: no need to update EM\n");
+		break;
+	case POWER_SUPPLY_CHARGER_TYPE_NONE:
+		if (new.ma == CHRG_CURR_DISCONN) {
+			/* event: chargers disconnect */
+			return POWER_SUPPLY_CHARGER_EVENT_DISCONNECT;
+		} else
+			dev_dbg(pnw->dev, "UNKNOWN: no need to update EM\n");
+		break;
+	default:
+		break;
+	}
+
+	return -1;
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+}
+
+static void penwell_otg_update_chrg_cap(enum usb_charger_type charger,
+				unsigned ma)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct pci_dev			*pdev;
+	unsigned long			flags;
+	struct otg_bc_event		*event;
+
+	pdev = to_pci_dev(pnw->dev);
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+
+	if (!is_clovertrail(pdev)) {
+		spin_lock_irqsave(&pnw->charger_lock, flags);
+		_penwell_otg_update_chrg_cap(charger, ma);
+		spin_unlock_irqrestore(&pnw->charger_lock, flags);
+	} else {
+		dev_dbg(pnw->dev, "clv cable_props_update\n");
+
+		event = kzalloc(sizeof(*event), GFP_ATOMIC);
+		if (!event) {
+			dev_err(pnw->dev, "no memory for charging event");
+			return;
+		}
+
+		event->cap.chrg_type = usb_chrg_to_power_supply_chrg(charger);
+		event->cap.ma = ma;
+		INIT_LIST_HEAD(&event->node);
+
+		spin_lock_irqsave(&pnw->charger_lock, flags);
+		list_add_tail(&event->node, &pnw->chrg_evt_queue);
+		spin_unlock_irqrestore(&pnw->charger_lock, flags);
+
+		queue_work(pnw->chrg_qwork, &pnw->psc_notify);
+	}
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+}
+
+static int penwell_otg_set_power(struct usb_phy *otg, unsigned ma)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	unsigned long			flags;
+	struct pci_dev			*pdev;
+	struct otg_bc_event		*event;
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+
+	pdev = to_pci_dev(pnw->dev);
+
+	if (!is_clovertrail(pdev)) {
+		spin_lock_irqsave(&pnw->charger_lock, flags);
+
+		if (pnw->charging_cap.chrg_type != CHRG_SDP) {
+			spin_unlock_irqrestore(&pnw->charger_lock, flags);
+			return 0;
+		}
+
+		if (!pnw->otg_pdata->charging_compliance)
+			ma = CHRG_CURR_SDP_HIGH;
+
+		_penwell_otg_update_chrg_cap(CHRG_SDP, ma);
+
+		spin_unlock_irqrestore(&pnw->charger_lock, flags);
+	} else {
+		dev_dbg(pnw->dev, "clv charger_set_power\n");
+
+		if (pnw->psc_cap.chrg_type != POWER_SUPPLY_CHARGER_TYPE_USB_SDP)
+			return 0;
+
+		if (!pnw->otg_pdata->charging_compliance)
+			ma = CHRG_CURR_SDP_HIGH;
+
+		event = kzalloc(sizeof(*event), GFP_ATOMIC);
+		if (!event) {
+			dev_err(pnw->dev, "no memory for charging event");
+			return -ENOMEM;
+		}
+
+		event->cap.chrg_type = POWER_SUPPLY_CHARGER_TYPE_USB_SDP;
+		event->cap.ma = ma;
+		INIT_LIST_HEAD(&event->node);
+
+		spin_lock_irqsave(&pnw->charger_lock, flags);
+		list_add_tail(&event->node, &pnw->chrg_evt_queue);
+		spin_unlock_irqrestore(&pnw->charger_lock, flags);
+
+		queue_work(pnw->chrg_qwork, &pnw->psc_notify);
+	}
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+
+	return 0;
+}
+
+int penwell_otg_get_chrg_status(struct usb_phy *x, void *data)
+{
+	unsigned long flags;
+	struct power_supply_cable_props *cap =
+		(struct power_supply_cable_props *)data;
+	struct penwell_otg *pnw = the_transceiver;
+
+	if (pnw == NULL)
+		return -ENODEV;
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+
+	if (data == NULL)
+		return -EINVAL;
+
+	spin_lock_irqsave(&pnw->cap_lock, flags);
+	cap->chrg_evt = pnw->psc_cap.chrg_evt;
+	cap->chrg_type = pnw->psc_cap.chrg_type;
+	cap->ma = pnw->psc_cap.ma;
+	spin_unlock_irqrestore(&pnw->cap_lock, flags);
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+	return 0;
+}
+
+int penwell_otg_query_charging_cap(struct otg_bc_cap *cap)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	unsigned long		flags;
+
+	if (pnw == NULL)
+		return -ENODEV;
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+
+	if (cap == NULL)
+		return -EINVAL;
+
+	if (is_clovertrail(to_pci_dev(pnw->dev)))
+		return -ENODEV;
+
+	spin_lock_irqsave(&pnw->charger_lock, flags);
+	cap->chrg_type = pnw->charging_cap.chrg_type;
+	cap->ma = pnw->charging_cap.ma;
+	cap->current_event = pnw->charging_cap.current_event;
+	spin_unlock_irqrestore(&pnw->charger_lock, flags);
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(penwell_otg_query_charging_cap);
+
+/* Register/unregister battery driver callback */
+void *penwell_otg_register_bc_callback(
+	int (*cb)(void *, int, struct otg_bc_cap *), void *arg)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	unsigned long		flags;
+
+	if (pnw == NULL)
+		return pnw;
+
+	if (is_clovertrail(to_pci_dev(pnw->dev)))
+		return NULL;
+
+	spin_lock_irqsave(&pnw->charger_lock, flags);
+
+	if (pnw->bc_callback != NULL)
+		dev_dbg(pnw->dev, "callback has already registered\n");
+
+	pnw->bc_callback = cb;
+	pnw->bc_arg = arg;
+	spin_unlock_irqrestore(&pnw->charger_lock, flags);
+
+	return pnw;
+}
+EXPORT_SYMBOL_GPL(penwell_otg_register_bc_callback);
+
+int penwell_otg_unregister_bc_callback(void *handler)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	unsigned long		flags;
+
+	if (pnw == NULL)
+		return -ENODEV;
+
+	if (pnw != handler)
+		return -EINVAL;
+
+	if (is_clovertrail(to_pci_dev(pnw->dev)))
+		return -ENODEV;
+
+	spin_lock_irqsave(&pnw->charger_lock, flags);
+	pnw->bc_callback = NULL;
+	pnw->bc_arg = NULL;
+	spin_unlock_irqrestore(&pnw->charger_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(penwell_otg_unregister_bc_callback);
+
+/* After probe, it should enable the power of USB PHY */
+static void penwell_otg_phy_enable(int on)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	u8			data;
+
+	dev_dbg(pnw->dev, "%s ---> %s\n", __func__, on ? "on" : "off");
+
+	data = on ? 0x37 : 0x24;
+
+	mutex_lock(&pnw->msic_mutex);
+
+	if (penwell_otg_msic_write(MSIC_VUSB330CNT, data)) {
+		mutex_unlock(&pnw->msic_mutex);
+		dev_err(pnw->dev, "Fail to enable PHY power\n");
+		return;
+	}
+
+	mutex_unlock(&pnw->msic_mutex);
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+}
+
+/* A-device drives vbus, controlled through MSIC register */
+static int penwell_otg_set_vbus(struct usb_otg *otg, bool enabled)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	u8				data;
+	unsigned long			flags;
+	int				retval = 0;
+	struct otg_bc_event		*evt;
+
+	dev_dbg(pnw->dev, "%s ---> %s\n", __func__, enabled ? "on" : "off");
+
+	/*
+	 * For Clovertrail, VBUS is driven by TPS2052 power switch chip.
+	 * But TPS2052 is controlled by ULPI PHY.
+	 */
+	if (is_clovertrail(to_pci_dev(pnw->dev))) {
+		penwell_otg_phy_low_power(0);
+		if (enabled)
+			penwell_otg_ulpi_write(&pnw->iotg,
+				ULPI_OTGCTRLSET, DRVVBUS | DRVVBUS_EXTERNAL);
+		else
+			penwell_otg_ulpi_write(&pnw->iotg,
+				ULPI_OTGCTRLCLR, DRVVBUS | DRVVBUS_EXTERNAL);
+
+		evt = kzalloc(sizeof(*evt), GFP_KERNEL);
+		if (!evt) {
+			dev_err(pnw->dev, "no memory for charging event");
+			return -ENOMEM;
+		}
+
+		evt->cap.chrg_type = POWER_SUPPLY_CHARGER_TYPE_NONE;
+		INIT_LIST_HEAD(&evt->node);
+
+		if ((!enabled) && (pnw->iotg.hsm.id == ID_ACA_A
+				|| pnw->iotg.hsm.id == ID_ACA_B
+				|| pnw->iotg.hsm.id == ID_ACA_C)) {
+			evt->cap.chrg_type = POWER_SUPPLY_CHARGER_TYPE_USB_ACA;
+			evt->cap.ma = CHRG_CURR_ACA;
+			evt->cap.chrg_evt = POWER_SUPPLY_CHARGER_EVENT_CONNECT;
+		} else {
+			dev_info(pnw->dev, "notification: turn %s VBUS\n",
+						enabled ? "ON" : "OFF");
+			atomic_notifier_call_chain(&pnw->iotg.otg.notifier,
+				USB_EVENT_DRIVE_VBUS, &enabled);
+			kfree(evt);
+			goto done;
+		}
+
+		dev_dbg(pnw->dev, "set_vbus ma = %d, event = %d, type = %s\n",
+				evt->cap.ma, evt->cap.chrg_evt,
+				psc_string(evt->cap.chrg_type));
+
+		spin_lock_irqsave(&pnw->charger_lock, flags);
+		list_add_tail(&evt->node, &pnw->chrg_evt_queue);
+		spin_unlock_irqrestore(&pnw->charger_lock, flags);
+
+		queue_work(pnw->chrg_qwork, &pnw->psc_notify);
+
+		goto done;
+	}
+
+	if (pnw->otg_pdata->gpio_vbus) {
+		dev_info(pnw->dev, "Turn %s VBUS using GPIO pin %d\n",
+			enabled ? "on" : "off", pnw->otg_pdata->gpio_vbus);
+		gpio_direction_output(pnw->otg_pdata->gpio_vbus,
+							enabled ? 1 : 0);
+		goto done;
+	}
+
+	data = enabled ? VOTGEN : 0;
+
+	mutex_lock(&pnw->msic_mutex);
+
+	retval = intel_scu_ipc_update_register(MSIC_VOTGCNT, data, VOTGEN);
+
+	if (retval)
+		dev_err(pnw->dev, "Fail to set power on OTG Port\n");
+
+	mutex_unlock(&pnw->msic_mutex);
+
+done:
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+
+	return retval;
+}
+
+static int penwell_otg_ulpi_run(void)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	u32			val;
+
+	val = readl(pnw->iotg.base + CI_ULPIVP);
+
+	if (val & ULPI_RUN)
+		return 1;
+
+	dev_dbg(pnw->dev, "%s: ULPI command done\n", __func__);
+	return 0;
+}
+
+/* io_ops to access ulpi registers */
+static int
+penwell_otg_ulpi_read(struct intel_mid_otg_xceiv *iotg, u8 reg, u8 *val)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	u32			val32 = 0;
+	int			count;
+	unsigned long		flags;
+
+	dev_dbg(pnw->dev, "%s - addr 0x%x\n", __func__, reg);
+
+	spin_lock_irqsave(&pnw->lock, flags);
+
+	/* Port = 0 */
+	val32 = ULPI_RUN | reg << 16;
+	writel(val32, pnw->iotg.base + CI_ULPIVP);
+
+	/* Polling at least 2ms for read operation to complete*/
+	count = 400;
+
+	while (count) {
+		val32 = readl(pnw->iotg.base + CI_ULPIVP);
+		if (val32 & ULPI_RUN) {
+			count--;
+			udelay(5);
+		} else {
+			*val = (u8)((val32 & ULPI_DATRD) >> 8);
+			dev_dbg(pnw->dev,
+				"%s - done data 0x%x\n", __func__, *val);
+			spin_unlock_irqrestore(&pnw->lock, flags);
+			return 0;
+		}
+	}
+
+	dev_warn(pnw->dev, "%s - addr 0x%x timeout\n", __func__, reg);
+
+	spin_unlock_irqrestore(&pnw->lock, flags);
+	return -ETIMEDOUT;
+
+}
+
+static int
+penwell_otg_ulpi_write(struct intel_mid_otg_xceiv *iotg, u8 reg, u8 val)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	u32			val32 = 0;
+	int			count;
+	unsigned long		flags;
+
+	dev_dbg(pnw->dev,
+		"%s - addr 0x%x - data 0x%x\n", __func__, reg, val);
+
+	spin_lock_irqsave(&pnw->lock, flags);
+
+	/* Port = 0 */
+	val32 = ULPI_RUN | ULPI_RW | reg << 16 | val;
+	writel(val32, pnw->iotg.base + CI_ULPIVP);
+
+	/* Polling at least 2ms for write operation to complete*/
+	count = 400;
+
+	while (count && penwell_otg_ulpi_run()) {
+		count--;
+		udelay(5);
+	}
+
+	dev_dbg(pnw->dev, "%s - addr 0x%x %s\n", __func__, reg,
+			count ? "complete" : "timeout");
+
+	spin_unlock_irqrestore(&pnw->lock, flags);
+	return count ? 0 : -ETIMEDOUT;
+}
+
+int pnw_otg_ulpi_write(u8 reg, u8 val)
+{
+	return penwell_otg_ulpi_write(&the_transceiver->iotg,
+					reg, val);
+}
+EXPORT_SYMBOL_GPL(pnw_otg_ulpi_write);
+
+static enum msic_vendor penwell_otg_check_msic(void)
+{
+	/* Return MSIC_VD_TI directly */
+	return MSIC_VD_TI;
+}
+
+/* Monitor function check if SRP initial conditions. Use polling on current
+ * status for b_ssend_srp, b_se0_srp */
+static void penwell_otg_mon_bus(void)
+{
+	struct penwell_otg *pnw = the_transceiver;
+	int count = 6;
+	int interval = 300; /* ms */
+	u32 val = 0;
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+	pnw->iotg.hsm.b_ssend_srp = 0;
+	pnw->iotg.hsm.b_se0_srp = 0;
+
+	while (count) {
+		msleep(interval);
+
+		/* Check VBus status */
+		val = readl(pnw->iotg.base + CI_OTGSC);
+		if (!(val & OTGSC_BSE))
+			return;
+
+		val = readl(pnw->iotg.base + CI_PORTSC1);
+		if (val & PORTSC_LS)
+			return;
+
+		count--;
+	}
+
+	pnw->iotg.hsm.b_ssend_srp = 1;
+	pnw->iotg.hsm.b_se0_srp = 1;
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+}
+
+/* HNP polling function */
+/* The timeout callback function which polls the host request flag for HNP */
+static void penwell_otg_hnp_poll_fn(unsigned long indicator)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+
+	queue_work(pnw->qwork, &pnw->hnp_poll_work);
+}
+
+/* Start HNP polling */
+/* Call this function with iotg->hnp_poll_lock held */
+static int penwell_otg_add_hnp_poll_timer(struct intel_mid_otg_xceiv *iotg,
+					unsigned long delay)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	unsigned long		j = jiffies;
+
+	pnw->hnp_poll_timer.data = 1;
+	pnw->hnp_poll_timer.function = penwell_otg_hnp_poll_fn;
+	pnw->hnp_poll_timer.expires = j + msecs_to_jiffies(delay);
+
+	add_timer(&pnw->hnp_poll_timer);
+
+	return 0;
+}
+
+static int penwell_otg_start_hnp_poll(struct intel_mid_otg_xceiv *iotg)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	unsigned long		flags;
+
+	spin_lock_irqsave(&pnw->iotg.hnp_poll_lock, flags);
+
+	if (pnw->iotg.hsm.hnp_poll_enable) {
+		spin_unlock_irqrestore(&pnw->iotg.hnp_poll_lock, flags);
+		dev_dbg(pnw->dev, "HNP polling is already enabled\n");
+		return 0;
+	}
+
+	/* mark HNP polling enabled and start HNP polling in 50ms */
+	pnw->iotg.hsm.hnp_poll_enable = 1;
+	penwell_otg_add_hnp_poll_timer(&pnw->iotg, 50);
+
+	spin_unlock_irqrestore(&pnw->iotg.hnp_poll_lock, flags);
+
+	return 0;
+}
+
+static int penwell_otg_continue_hnp_poll(struct intel_mid_otg_xceiv *iotg)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	unsigned long		flags;
+
+	spin_lock_irqsave(&pnw->iotg.hnp_poll_lock, flags);
+
+	if (!pnw->iotg.hsm.hnp_poll_enable) {
+		spin_unlock_irqrestore(&pnw->iotg.hnp_poll_lock, flags);
+		dev_dbg(pnw->dev, "HNP polling is disabled, stop polling\n");
+		return 0;
+	}
+
+	penwell_otg_add_hnp_poll_timer(&pnw->iotg, THOS_REQ_POL);
+
+	spin_unlock_irqrestore(&pnw->iotg.hnp_poll_lock, flags);
+
+	return 0;
+}
+
+/* Stop HNP polling */
+static int penwell_otg_stop_hnp_poll(struct intel_mid_otg_xceiv *iotg)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	unsigned long		flags;
+
+	spin_lock_irqsave(&pnw->iotg.hnp_poll_lock, flags);
+
+	if (!pnw->iotg.hsm.hnp_poll_enable) {
+		spin_unlock_irqrestore(&pnw->iotg.hnp_poll_lock, flags);
+		dev_dbg(pnw->dev, "HNP polling is already disabled\n");
+		return 0;
+	}
+
+	pnw->iotg.hsm.hnp_poll_enable = 0;
+	del_timer_sync(&pnw->hnp_poll_timer);
+
+	spin_unlock_irqrestore(&pnw->iotg.hnp_poll_lock, flags);
+
+	return 0;
+}
+
+/* Start SRP function */
+static int penwell_otg_start_srp(struct usb_otg *otg)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	u32			val;
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+
+	val = readl(pnw->iotg.base + CI_OTGSC);
+
+	writel((val & ~OTGSC_INTSTS_MASK) | OTGSC_HADP,
+				pnw->iotg.base + CI_OTGSC);
+
+	/* Check if the data plus is finished or not */
+	msleep(8);
+	val = readl(pnw->iotg.base + CI_OTGSC);
+	if (val & (OTGSC_HADP | OTGSC_DP))
+		dev_warn(pnw->dev, "DataLine SRP Error\n");
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+	return 0;
+}
+
+/* stop SOF via bus_suspend */
+static void penwell_otg_loc_sof(int on)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	struct usb_hcd		*hcd;
+	int			err;
+
+	dev_dbg(pnw->dev, "%s ---> %s\n", __func__, on ? "resume" : "suspend");
+
+	hcd = bus_to_hcd(pnw->iotg.otg.otg->host);
+	if (on)
+		err = hcd->driver->bus_resume(hcd);
+	else
+		err = hcd->driver->bus_suspend(hcd);
+
+	if (err)
+		dev_warn(pnw->dev, "Fail to resume/suspend USB bus -%d\n", err);
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+}
+
+static void penwell_otg_phy_low_power(int on)
+{
+	struct	penwell_otg	*pnw = the_transceiver;
+	u32			val;
+
+	dev_dbg(pnw->dev, "%s ---> %s\n", __func__, on ? "on" : "off");
+
+	val = readl(pnw->iotg.base + CI_USBMODE);
+	if (!(val & USBMODE_CM)) {
+		dev_err(pnw->dev,
+			"PHY can't enter low power mode "
+			"when UDC is in idle mode\n");
+		set_client_mode();
+	}
+
+	val = readl(pnw->iotg.base + CI_HOSTPC1);
+	dev_dbg(pnw->dev, "---> Register CI_HOSTPC1 = %x\n", val);
+
+	if (on) {
+		if (val & HOSTPC1_PHCD) {
+			dev_dbg(pnw->dev, "already in Low power mode\n");
+			return;
+		}
+		writel(val | HOSTPC1_PHCD, pnw->iotg.base + CI_HOSTPC1);
+	} else {
+		if (!(val & HOSTPC1_PHCD)) {
+			dev_dbg(pnw->dev, "already in Normal mode\n");
+			return;
+		}
+		writel(val & ~HOSTPC1_PHCD, pnw->iotg.base + CI_HOSTPC1);
+	}
+
+	val = readl(pnw->iotg.base + CI_HOSTPC1);
+
+	dev_dbg(pnw->dev, "<--- Register CI_HOSTPC1 = %x\n", val);
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+}
+
+/*
+ * For Penwell, VBUS330 is the power rail to otg PHY inside MSIC, set it
+ * into low power mode or normal mode according to pm state.
+ * Call this function when spi access to MSIC registers is enabled.
+ *
+ * For Clovertrail, we don't have a controllable power rail to the PHY -
+ * it's always on.
+ */
+static int penwell_otg_vusb330_low_power(int on)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	u8			data;
+	int			retval = 0;
+
+	dev_dbg(pnw->dev, "%s ---> %s\n", __func__, on ? "on" : "off");
+
+	if (!is_clovertrail(to_pci_dev(pnw->dev))) {
+		if (on)
+			data = 0x5; /* Low power mode */
+		else
+			data = 0x7; /* Normal mode */
+		retval = penwell_otg_msic_write(MSIC_VUSB330CNT, data);
+	}
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+
+	return retval;
+}
+
+/* Enable/Disable OTG interrupt */
+static void penwell_otg_intr(int on)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	u32			val;
+
+	dev_dbg(pnw->dev, "%s ---> %s\n", __func__, on ? "on" : "off");
+
+	val = readl(pnw->iotg.base + CI_OTGSC);
+	/* mask W/C bits to avoid clearing them when
+	*  val is written back to OTGSC */
+	val &= ~OTGSC_INTSTS_MASK;
+	if (on) {
+		val = val | (OTGSC_INTEN_MASK);
+		writel(val, pnw->iotg.base + CI_OTGSC);
+	} else {
+		val = val & ~(OTGSC_INTEN_MASK);
+		writel(val, pnw->iotg.base + CI_OTGSC);
+	}
+}
+
+/* set HAAR: Hardware Assist Auto-Reset */
+static void penwell_otg_HAAR(int on)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	u32			val;
+
+	dev_dbg(pnw->dev, "%s ---> %s\n", __func__, on ? "on" : "off");
+
+	val = readl(pnw->iotg.base + CI_OTGSC);
+	if (on)
+		writel((val & ~OTGSC_INTSTS_MASK) | OTGSC_HAAR,
+				pnw->iotg.base + CI_OTGSC);
+	else
+		writel((val & ~OTGSC_INTSTS_MASK) & ~OTGSC_HAAR,
+				pnw->iotg.base + CI_OTGSC);
+}
+
+/* set HABA: Hardware Assist B-Disconnect to A-Connect */
+static void penwell_otg_HABA(int on)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	u32	val;
+
+	dev_dbg(pnw->dev, "%s ---> %s\n", __func__, on ? "on" : "off");
+
+	val = readl(pnw->iotg.base + CI_OTGSC);
+	if (on)
+		writel((val & ~OTGSC_INTSTS_MASK) | OTGSC_HABA,
+					pnw->iotg.base + CI_OTGSC);
+	else
+		writel((val & ~OTGSC_INTSTS_MASK) & ~OTGSC_HABA,
+					pnw->iotg.base + CI_OTGSC);
+}
+
+/* read 8bit msic register */
+static int penwell_otg_msic_read(u16 addr, u8 *data)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	int			retval = intel_scu_ipc_ioread8(addr, data);
+	if (retval)
+		dev_warn(pnw->dev, "Failed to read MSIC register %x\n", addr);
+
+	return retval;
+}
+
+/* write 8bit msic register */
+static int penwell_otg_msic_write(u16 addr, u8 data)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	int			retval = 0;
+
+	retval = intel_scu_ipc_iowrite8(addr, data);
+	if (retval)
+		dev_warn(pnw->dev, "Failed to write MSIC register %x\n", addr);
+
+	return retval;
+}
+
+/* USB related register in MSIC can be access via SPI address and ulpi address
+ * Access the control register to switch */
+static void penwell_otg_msic_spi_access(bool enabled)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	u8			data;
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+
+	/* Set ULPI ACCESS MODE */
+	data = enabled ? SPIMODE : 0;
+
+	penwell_otg_msic_write(MSIC_ULPIACCESSMODE, data);
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+}
+
+/* USB Battery Charger detection related functions */
+/* Data contact detection is the first step for charger detection */
+static int penwell_otg_data_contact_detect(void)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	u8			data;
+	int			count = 50;
+	int			retval = 0;
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+
+	/* Enable SPI access */
+	penwell_otg_msic_spi_access(true);
+
+	/* Set POWER_CTRL_CLR */
+	retval = penwell_otg_msic_write(MSIC_PWRCTRLCLR, DPVSRCEN);
+	if (retval)
+		return retval;
+
+	/* Set FUNC_CTRL_SET */
+	retval = penwell_otg_msic_write(MSIC_FUNCTRLSET, OPMODE0);
+	if (retval)
+		return retval;
+
+	/* Set FUNC_CTRL_CLR */
+	retval = penwell_otg_msic_write(MSIC_FUNCTRLCLR, OPMODE1);
+	if (retval)
+		return retval;
+
+	/* Set OTG_CTRL_CLR */
+	retval = penwell_otg_msic_write(MSIC_OTGCTRLCLR,
+					DMPULLDOWN | DPPULLDOWN);
+	if (retval)
+		return retval;
+
+	/* Set POWER_CTRL_CLR */
+	retval = penwell_otg_msic_write(MSIC_PWRCTRLCLR, SWCNTRL);
+	if (retval)
+		return retval;
+
+	retval = penwell_otg_msic_write(MSIC_VS3SET, DATACONEN | SWUSBDET);
+	if (retval)
+		return retval;
+
+	dev_dbg(pnw->dev, "Start Polling for Data contact detection!\n");
+
+	while (count) {
+		retval = intel_scu_ipc_ioread8(MSIC_USB_MISC, &data);
+		if (retval) {
+			dev_warn(pnw->dev, "Failed to read MSIC register\n");
+			return retval;
+		}
+
+		if (data & MISC_CHGDSERXDPINV) {
+			dev_dbg(pnw->dev, "Data contact detected!\n");
+			return 0;
+		}
+		count--;
+		/* Interval is 10 - 11ms */
+		usleep_range(10000, 11000);
+	}
+
+	dev_dbg(pnw->dev, "Data contact Timeout\n");
+
+	retval = penwell_otg_msic_write(MSIC_VS3CLR, DATACONEN | SWUSBDET);
+	if (retval)
+		return retval;
+
+	udelay(100);
+
+	retval = penwell_otg_msic_write(MSIC_VS3SET, SWUSBDET);
+	if (retval)
+		return retval;
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+	return 0;
+}
+
+static int penwell_otg_charger_detect(void)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+
+	msleep(125);
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+
+	return 0;
+}
+
+static int penwell_otg_charger_type_detect(void)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	enum usb_charger_type		charger;
+	u8				data;
+	int				retval;
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+
+	retval = penwell_otg_msic_write(MSIC_VS3CLR, DATACONEN);
+	if (retval)
+		return retval;
+
+	retval = penwell_otg_msic_write(MSIC_PWRCTRLSET, DPWKPUEN | SWCNTRL);
+	if (retval)
+		return retval;
+
+	retval = penwell_otg_msic_write(MSIC_PWRCTRLCLR, DPVSRCEN);
+	if (retval)
+		return retval;
+
+	retval = penwell_otg_msic_write(MSIC_OTGCTRLCLR,
+					DMPULLDOWN | DPPULLDOWN);
+	if (retval)
+		return retval;
+
+	msleep(55);
+
+	retval = penwell_otg_msic_write(MSIC_PWRCTRLCLR,
+					SWCNTRL | DPWKPUEN | HWDET);
+	if (retval)
+		return retval;
+
+	msleep(1);
+
+	/* Enable ULPI mode */
+	penwell_otg_msic_spi_access(false);
+
+	retval = intel_scu_ipc_ioread8(MSIC_SPWRSRINT1, &data);
+	if (retval) {
+		dev_warn(pnw->dev, "Failed to read MSIC register\n");
+		return retval;
+	}
+
+	switch (data & MSIC_SPWRSRINT1_MASK) {
+	case SPWRSRINT1_SDP:
+		charger = CHRG_SDP;
+		break;
+	case SPWRSRINT1_DCP:
+		charger = CHRG_DCP;
+		break;
+	case SPWRSRINT1_CDP:
+		charger = CHRG_CDP;
+		break;
+	default:
+		charger = CHRG_UNKNOWN;
+		break;
+	}
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+
+	return charger;
+}
+
+/* manual charger detection by ULPI access */
+static int penwell_otg_manual_chrg_det(void)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg;
+	int				retval;
+	u8				data, data1, data2;
+	unsigned long			timeout, interval;
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+
+	iotg = &pnw->iotg;
+
+	dev_info(pnw->dev, "USB charger detection start...\n");
+
+	/* WA for invalid (SE1) charger: add DCD & SE1 detection over SPI
+	* instead of ULPI interface to avoid any ulpi read/write failures
+	* with SE1 charger */
+	penwell_otg_msic_spi_access(true);
+
+	retval = penwell_otg_msic_write(MSIC_FUNCTRLCLR,
+					OPMODE1 | TERMSELECT | XCVRSELECT1);
+	if (retval) {
+		penwell_otg_msic_spi_access(false);
+		return retval;
+	}
+
+	retval = penwell_otg_msic_write(MSIC_FUNCTRLSET, OPMODE0 | XCVRSELECT0);
+	if (retval) {
+		penwell_otg_msic_spi_access(false);
+		return retval;
+	}
+
+	retval = penwell_otg_msic_write(MSIC_PWRCTRLSET, SWCNTRL);
+	if (retval) {
+		penwell_otg_msic_spi_access(false);
+		return retval;
+	}
+
+	retval = penwell_otg_msic_write(MSIC_VS3SET, CHGD_IDP_SRC);
+	if (retval) {
+		penwell_otg_msic_spi_access(false);
+		return retval;
+	}
+
+	dev_info(pnw->dev, "charger detection DCD start...\n");
+
+	/* Check DCD result, use same polling parameter */
+	timeout = jiffies + msecs_to_jiffies(DATACON_TIMEOUT);
+	interval = DATACON_INTERVAL * 1000; /* us */
+
+	dev_info(pnw->dev, "DCD started!\n");
+
+	/* Delay TIDP_SRC_ON + TCHGD_SERX_DEB */
+	usleep_range(66500, 67000);
+
+	while (!time_after(jiffies, timeout)) {
+		retval = penwell_otg_msic_read(MSIC_VS4, &data);
+		if (retval) {
+			penwell_otg_msic_spi_access(false);
+			return retval;
+		}
+		if (!(data & CHRG_SERX_DP)) {
+			dev_info(pnw->dev, "Data contact detected!\n");
+			break;
+		}
+
+		/* Polling interval */
+		usleep_range(interval, interval + 2000);
+	}
+
+	retval = penwell_otg_msic_write(MSIC_VS3CLR, CHGD_IDP_SRC);
+	if (retval) {
+		penwell_otg_msic_spi_access(false);
+		return retval;
+	}
+
+	dev_info(pnw->dev, "DCD complete\n");
+
+	/* Check for SE1, Linestate = '11' */
+	retval = penwell_otg_msic_read(MSIC_DEBUG, &data);
+	if (retval) {
+		penwell_otg_msic_spi_access(false);
+		return retval;
+	}
+	dev_info(pnw->dev, "MSIC.DEBUG.LINESTATE.D[1:0] = 0x%02X\n", data);
+
+	data &= LINESTATE_MSK;
+	if (data == LINESTATE_SE1) {
+		dev_info(pnw->dev, "SE1 Detected\n");
+		penwell_otg_msic_spi_access(false);
+		return CHRG_SE1;
+	}
+
+	penwell_otg_msic_spi_access(false);
+
+	dev_info(pnw->dev, "Primary Detection start...\n");
+
+	/* Primary Dection config */
+	/* ulpi_write(0x0b, 0x06) */
+	retval = penwell_otg_ulpi_write(iotg, ULPI_OTGCTRLSET,
+				DMPULLDOWN | DPPULLDOWN);
+	if (retval)
+		return retval;
+
+	retval = penwell_otg_ulpi_write(iotg, ULPI_PWRCTRLSET, DPVSRCEN);
+	if (retval)
+		return retval;
+
+	msleep(125);
+
+	/* Check result SDP vs CDP/DCP */
+	retval = penwell_otg_ulpi_read(iotg, ULPI_PWRCTRL, &data1);
+	if (retval)
+		return retval;
+
+	data1 = data1 & VDATDET;
+
+	retval = penwell_otg_ulpi_read(iotg, ULPI_VS4, &data2);
+	if (retval)
+		return retval;
+
+	data2 = data2 & CHRG_SERX_DM;
+
+	if (!data1 || data2) {
+		retval = penwell_otg_ulpi_write(iotg, ULPI_PWRCTRLCLR,
+						DPVSRCEN);
+		if (retval)
+			return retval;
+
+		dev_info(pnw->dev, "USB Charger Detection done\n");
+		return CHRG_SDP;
+	}
+
+	/* start detection on CDP vs DCP */
+	retval = penwell_otg_ulpi_write(iotg, ULPI_PWRCTRLCLR, DPVSRCEN);
+	if (retval)
+		return retval;
+
+	/* sleep 1ms between Primary and Secondary detection */
+	usleep_range(1000, 1200);
+
+	retval = penwell_otg_ulpi_write(iotg, ULPI_VS1CLR, DATAPOLARITY);
+	if (retval)
+		return retval;
+
+	retval = penwell_otg_ulpi_write(iotg, ULPI_PWRCTRLSET, DPVSRCEN);
+	if (retval)
+		return retval;
+
+	msleep(85);
+
+	/* read result on CDP vs DCP */
+	retval = penwell_otg_ulpi_read(iotg, ULPI_PWRCTRL, &data);
+	if (retval)
+		return retval;
+
+	data = data & VDATDET;
+
+	retval = penwell_otg_ulpi_write(iotg, ULPI_PWRCTRLCLR, DPVSRCEN);
+	if (retval)
+		return retval;
+
+	retval = penwell_otg_ulpi_write(iotg, ULPI_VS1SET, DATAPOLARITY);
+	if (retval)
+		return retval;
+
+	dev_info(pnw->dev, "USB Charger Detection done\n");
+
+	if (data) {
+		retval = penwell_otg_ulpi_write(iotg, ULPI_PWRCTRLSET,
+							DPVSRCEN);
+		if (retval)
+			return retval;
+
+		return CHRG_DCP;
+	} else
+		return CHRG_CDP;
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+};
+
+static int penwell_otg_charger_det_dcd_clt(void)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	int				retval;
+	unsigned long			timeout, interval;
+	u8				data;
+
+	/* Change OPMODE to '01' Non-driving */
+	retval = penwell_otg_ulpi_write(iotg, ULPI_FUNCTRLSET,
+						OPMODE0 | XCVRSELECT0);
+	if (retval)
+		return retval;
+
+	retval = penwell_otg_ulpi_write(iotg, ULPI_FUNCTRLCLR,
+					OPMODE1 | XCVRSELECT1 | TERMSELECT);
+	if (retval)
+		return retval;
+
+	/* Enable SW control */
+	retval = penwell_otg_ulpi_write(iotg, ULPI_PWRCTRLSET, SWCNTRL);
+	if (retval)
+		return retval;
+
+	/* Clear HWDETECT result for safety */
+	penwell_otg_charger_hwdet(false);
+
+	/* Enable IDPSRC */
+	retval = penwell_otg_ulpi_write(iotg, ULPI_VS3SET, CHGD_IDP_SRC);
+	if (retval)
+		return retval;
+
+	/* Check DCD result, use same polling parameter */
+	timeout = jiffies + msecs_to_jiffies(DATACON_TIMEOUT);
+	interval = DATACON_INTERVAL * 1000; /* us */
+
+	dev_info(pnw->dev, "DCD started\n");
+
+	/* Delay TIDP_SRC_ON + TCHGD_SERX_DEB = 347.8us + 66.1ms max */
+	usleep_range(66500, 67000);
+
+	while (!time_after(jiffies, timeout)) {
+		retval = penwell_otg_ulpi_read(iotg, ULPI_VS4, &data);
+		if (retval) {
+			dev_warn(pnw->dev, "Failed to read ULPI register\n");
+			return retval;
+		}
+
+		dev_dbg(pnw->dev, "VS4 = 0x%02x.. DP = bit1\n", data);
+
+		if (!(data & CHRG_SERX_DP)) {
+			dev_info(pnw->dev, "Data contact detected!\n");
+			break;
+		}
+
+		/* Polling interval */
+		usleep_range(interval, interval + 2000);
+	}
+
+	/* ulpi_write(0x87, 0x40)*/
+	retval = penwell_otg_ulpi_write(iotg, ULPI_VS3CLR, CHGD_IDP_SRC);
+	if (retval)
+		return retval;
+
+	dev_info(pnw->dev, "DCD complete\n");
+
+	return 0;
+}
+
+static int penwell_otg_charger_det_aca_clt(void)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	int				retval;
+	u8				data;
+	u8				usb_vs2_sts = 0;
+	u8				usb_vs2_latch = 0;
+	u8				usb_vdat_det = 0;
+	u8				usb_vdm = 0;
+
+	retval = penwell_otg_ulpi_read(iotg, ULPI_VS2LATCH, &usb_vs2_latch);
+	dev_dbg(pnw->dev, "%s: usb_vs2_latch = 0x%x\n",
+			__func__, usb_vs2_latch);
+	if (retval) {
+		dev_warn(pnw->dev, "ULPI read failed, exit\n");
+		return retval;
+	}
+
+	retval = penwell_otg_ulpi_read(iotg, ULPI_VS2STS, &usb_vs2_sts);
+	dev_dbg(pnw->dev, "%s: usb_vs2_sts = 0x%x\n",
+			__func__, usb_vs2_sts);
+	if (retval) {
+		dev_warn(pnw->dev, "ULPI read failed, exit\n");
+		return retval;
+	}
+
+	if (usb_vs2_latch & IDRARBRC_MSK) {
+		switch (IDRARBRC_STS(usb_vs2_sts)) {
+		case IDRARBRC_A:
+			iotg->hsm.id = ID_ACA_A;
+			break;
+		case IDRARBRC_B:
+			iotg->hsm.id = ID_ACA_B;
+			dev_info(pnw->dev, "ACA-B detected\n");
+			break;
+		case IDRARBRC_C:
+			iotg->hsm.id = ID_ACA_C;
+			dev_info(pnw->dev, "ACA-C detected\n");
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (iotg->hsm.id == ID_ACA_A) {
+		retval = penwell_otg_ulpi_write(iotg,
+					ULPI_PWRCTRLSET, DPVSRCEN);
+		if (retval)
+			return retval;
+
+		msleep(70);
+
+		retval = penwell_otg_ulpi_read(iotg, ULPI_PWRCTRL, &data);
+		usb_vdat_det = data & VDATDET;
+		if (retval) {
+			dev_warn(pnw->dev, "ULPI read failed, exit\n");
+			return retval;
+		}
+
+		retval = penwell_otg_ulpi_read(iotg, ULPI_VS4, &data);
+		usb_vdm = data & CHRG_SERX_DM;
+		if (retval) {
+			dev_warn(pnw->dev, "ULPI read failed, exit\n");
+			return retval;
+		}
+
+		retval = penwell_otg_ulpi_write(iotg,
+					 ULPI_PWRCTRLCLR, DPVSRCEN);
+		if (retval)
+			return retval;
+
+		if (usb_vdat_det && !usb_vdm)
+			dev_info(pnw->dev, "ACA-Dock detected\n");
+		else if (!usb_vdat_det && usb_vdm)
+			dev_info(pnw->dev, "ACA-A detected\n");
+	}
+
+	if (iotg->hsm.id == ID_ACA_A || iotg->hsm.id == ID_ACA_B
+			|| iotg->hsm.id == ID_ACA_C) {
+		return CHRG_ACA;
+	}
+
+	return 0;
+}
+
+static int penwell_otg_charger_det_se1_clt(void)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	int				retval;
+	u8				data;
+
+	retval = penwell_otg_ulpi_read(iotg, ULPI_DEBUG, &data);
+	if (retval) {
+		dev_warn(pnw->dev, "ULPI read failed, exit\n");
+		return -EBUSY;
+	}
+
+	if ((data & CHRG_SERX_DP) && (data & CHRG_SERX_DM))
+		return CHRG_SE1;
+
+	return 0;
+}
+
+static int penwell_otg_charger_det_pri_clt(void)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	int				retval;
+	u8				vdat_det, serx_dm;
+
+	retval = penwell_otg_ulpi_write(iotg, ULPI_PWRCTRLSET, DPVSRCEN);
+	if (retval)
+		return retval;
+
+	msleep(110);
+
+	retval = penwell_otg_ulpi_read(iotg, ULPI_PWRCTRL, &vdat_det);
+	if (retval) {
+		dev_warn(pnw->dev, "ULPI read failed, exit\n");
+		return -EBUSY;
+	}
+
+	retval = penwell_otg_ulpi_read(iotg, ULPI_VS4, &serx_dm);
+	if (retval) {
+		dev_warn(pnw->dev, "ULPI read failed, exit\n");
+		return -EBUSY;
+	}
+
+	retval = penwell_otg_ulpi_write(iotg, ULPI_PWRCTRLCLR, DPVSRCEN);
+	if (retval)
+		return retval;
+
+	vdat_det &= VDATDET;
+	serx_dm &= CHRG_SERX_DM;
+
+	if ((!vdat_det) || serx_dm)
+		return CHRG_SDP;
+
+	return 0;
+}
+
+static int penwell_otg_charger_det_sec_clt(void)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	int				retval;
+	u8				vdat_det;
+
+	usleep_range(1000, 1500);
+
+	retval = penwell_otg_ulpi_write(iotg, ULPI_VS1CLR, DATAPOLARITY);
+	if (retval)
+		return retval;
+
+	retval = penwell_otg_ulpi_write(iotg, ULPI_PWRCTRLSET, DPVSRCEN);
+	if (retval)
+		return retval;
+
+	msleep(80);
+
+	retval = penwell_otg_ulpi_read(iotg, ULPI_PWRCTRL, &vdat_det);
+	if (retval) {
+		dev_warn(pnw->dev, "ULPI read failed, exit\n");
+		return retval;
+	}
+
+	retval = penwell_otg_ulpi_write(iotg, ULPI_PWRCTRLCLR, DPVSRCEN);
+	if (retval)
+		return retval;
+
+	retval = penwell_otg_ulpi_write(iotg, ULPI_VS1SET, DATAPOLARITY);
+	if (retval)
+		return retval;
+
+	vdat_det &= VDATDET;
+
+	if (vdat_det)
+		return CHRG_DCP;
+	else
+		return CHRG_CDP;
+
+	return 0;
+}
+
+static int penwell_otg_charger_det_clean_clt(void)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	int				retval;
+
+	retval = penwell_otg_ulpi_write(iotg, ULPI_PWRCTRLSET,
+					DPVSRCEN | SWCNTRL);
+	if (retval)
+		return retval;
+
+	return 0;
+}
+
+/* As we use SW mode to do charger detection, need to notify HW
+ * the result SW get, charging port or not */
+static int penwell_otg_charger_hwdet(bool enable)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	int				retval;
+
+	/* This is for CLV only */
+	if (!is_clovertrail(to_pci_dev(pnw->dev)))
+		return 0;
+
+	if (enable) {
+		retval = penwell_otg_ulpi_write(iotg, ULPI_PWRCTRLSET, HWDET);
+		if (retval)
+			return retval;
+		dev_dbg(pnw->dev, "set HWDETECT\n");
+	} else {
+		retval = penwell_otg_ulpi_write(iotg, ULPI_PWRCTRLCLR, HWDET);
+		if (retval)
+			return retval;
+		dev_dbg(pnw->dev, "clear HWDETECT\n");
+	}
+
+	return 0;
+}
+
+static int penwell_otg_charger_det_clt(void)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	int				retval;
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+
+	/* DCD */
+	retval = penwell_otg_charger_det_dcd_clt();
+	if (retval) {
+		dev_warn(pnw->dev, "DCD failed, exit\n");
+		return retval;
+	}
+
+	/* ACA Detection */
+	retval = penwell_otg_charger_det_aca_clt();
+	if (retval < 0) {
+		dev_warn(pnw->dev, "ACA Det failed, exit\n");
+		return retval;
+	} else if (retval == CHRG_ACA) {
+		dev_info(pnw->dev, "ACA detected\n");
+		penwell_otg_charger_hwdet(true);
+		return CHRG_ACA;
+	}
+
+	/* SE1 Detection */
+	retval = penwell_otg_charger_det_se1_clt();
+	if (retval < 0) {
+		dev_warn(pnw->dev, "SE1 Det failed, exit\n");
+		return retval;
+	} else if (retval == CHRG_SE1) {
+		dev_info(pnw->dev, "SE1 detected\n");
+		penwell_otg_charger_hwdet(true);
+		return CHRG_SE1;
+	}
+
+	/* Pri Det */
+	retval = penwell_otg_charger_det_pri_clt();
+	if (retval < 0) {
+		dev_warn(pnw->dev, "Pri Det failed, exit\n");
+		return retval;
+	} else if (retval == CHRG_SDP) {
+		dev_info(pnw->dev, "SDP detected\n");
+		return CHRG_SDP;
+	}
+
+	/* Sec Det */
+	retval = penwell_otg_charger_det_sec_clt();
+	if (retval < 0) {
+		dev_warn(pnw->dev, "Sec Det failed, exit\n");
+		return retval;
+	} else if (retval == CHRG_CDP) {
+		dev_info(pnw->dev, "CDP detected\n");
+		penwell_otg_charger_hwdet(true);
+		return CHRG_CDP;
+	} else  if (retval == CHRG_DCP) {
+		dev_info(pnw->dev, "DCP detected\n");
+		penwell_otg_charger_det_clean_clt();
+		penwell_otg_charger_hwdet(true);
+		return CHRG_DCP;
+	}
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+
+	return 0;
+}
+
+void penwell_otg_phy_vbus_wakeup(bool on)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv  *iotg = &pnw->iotg;
+	u8			flag = 0;
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+
+	penwell_otg_msic_spi_access(true);
+
+	flag = VBUSVLD | SESSVLD | SESSEND;
+
+	if (is_clovertrail(to_pci_dev(pnw->dev))) {
+		if (on) {
+			penwell_otg_ulpi_write(iotg, ULPI_USBINTEN_RISINGSET,
+						flag);
+			penwell_otg_ulpi_write(iotg, ULPI_USBINTEN_FALLINGSET,
+						flag);
+		} else {
+			penwell_otg_ulpi_write(iotg, ULPI_USBINTEN_RISINGCLR,
+						flag);
+			penwell_otg_ulpi_write(iotg, ULPI_USBINTEN_FALLINGCLR,
+						flag);
+		}
+	} else {
+		if (on) {
+			penwell_otg_msic_write(MSIC_USBINTEN_RISESET, flag);
+			penwell_otg_msic_write(MSIC_USBINTEN_FALLSET, flag);
+		} else {
+			penwell_otg_msic_write(MSIC_USBINTEN_RISECLR, flag);
+			penwell_otg_msic_write(MSIC_USBINTEN_FALLCLR, flag);
+		}
+	}
+
+	penwell_otg_msic_spi_access(false);
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+}
+
+void penwell_otg_phy_intr(bool on)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	u8			flag = 0;
+	int			retval;
+	u8			data;
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+
+	penwell_otg_msic_spi_access(true);
+
+	flag = VBUSVLD | IDGND;
+
+	if (on) {
+		dev_info(pnw->dev, "enable VBUSVLD & IDGND\n");
+		penwell_otg_msic_write(MSIC_USBINTEN_RISESET, flag);
+		penwell_otg_msic_write(MSIC_USBINTEN_FALLSET, flag);
+	} else {
+		dev_info(pnw->dev, "disable VBUSVLD & IDGND\n");
+		penwell_otg_msic_write(MSIC_USBINTEN_RISECLR, flag);
+		penwell_otg_msic_write(MSIC_USBINTEN_FALLCLR, flag);
+	}
+
+	retval = intel_scu_ipc_ioread8(MSIC_USBINTEN_RISE, &data);
+	if (retval)
+		dev_warn(pnw->dev, "Failed to read MSIC register\n");
+	else
+		dev_info(pnw->dev, "MSIC_USBINTEN_RISE = 0x%x", data);
+
+	retval = intel_scu_ipc_ioread8(MSIC_USBINTEN_FALL, &data);
+	if (retval)
+		dev_warn(pnw->dev, "Failed to read MSIC register\n");
+	else
+		dev_info(pnw->dev, "MSIC_USBINTEN_FALL = 0x%x", data);
+
+	penwell_otg_msic_spi_access(false);
+}
+
+void penwell_otg_phy_power(int on)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+
+	if (is_clovertrail(to_pci_dev(pnw->dev))) {
+		dev_dbg(pnw->dev, "turn %s USB PHY by gpio_cs(%d)\n",
+					on ? "on" : "off",
+					pnw->otg_pdata->gpio_cs);
+		gpio_direction_output(pnw->otg_pdata->gpio_cs, on);
+	}
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+}
+
+void penwell_otg_phy_reset(void)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+
+	if (is_clovertrail(to_pci_dev(pnw->dev))) {
+		gpio_direction_output(pnw->otg_pdata->gpio_reset, 0);
+		usleep_range(200, 500);
+		gpio_set_value(pnw->otg_pdata->gpio_reset, 1);
+	}
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+}
+
+#if 0
+knext_wa: usb_notify_warning should be implemented again instead of in hub.c
+static void penwell_otg_notify_warning(int warning_code)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+
+	dev_dbg(pnw->dev, "%s ---> %d\n", __func__, warning_code);
+
+	if (pnw && pnw->iotg.otg.otg->host && pnw->iotg.otg.otg->host->root_hub)
+		usb_notify_warning(pnw->iotg.otg.otg->host->root_hub,
+					warning_code);
+	else
+		dev_dbg(pnw->dev, "no valid device for notification\n");
+
+	dev_dbg(pnw->dev, "%s <--- %d\n", __func__, warning_code);
+}
+#else
+#define penwell_otg_notify_warning(x)
+#endif
+
+void penwell_otg_nsf_msg(unsigned long indicator)
+{
+	switch (indicator) {
+	case 2:
+	case 4:
+	case 6:
+	case 7:
+		dev_warn(the_transceiver->dev,
+			"NSF-%lu - device not responding\n", indicator);
+		break;
+	case 3:
+		dev_warn(the_transceiver->dev,
+			"NSF-%lu - device not supported\n", indicator);
+		break;
+	default:
+		dev_warn(the_transceiver->dev,
+			"Do not have this kind of NSF\n");
+		break;
+	}
+}
+
+/* The timeout callback function to set time out bit */
+static void penwell_otg_timer_fn(unsigned long indicator)
+{
+	struct penwell_otg *pnw = the_transceiver;
+
+	*(int *)indicator = 1;
+
+	dev_dbg(pnw->dev, "kernel timer - timeout\n");
+
+	penwell_update_transceiver();
+}
+
+/* kernel timer used for OTG timing */
+static void penwell_otg_add_timer(enum penwell_otg_timer_type timers)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	unsigned long			j = jiffies;
+	unsigned long			data, time;
+
+	if (timer_pending(&pnw->hsm_timer))
+		return;
+
+	switch (timers) {
+	case TA_WAIT_VRISE_TMR:
+		iotg->hsm.a_wait_vrise_tmout = 0;
+		data = (unsigned long)&iotg->hsm.a_wait_vrise_tmout;
+		/* Charger HW limitation workaround for CLV */
+		time = is_clovertrail(to_pci_dev(pnw->dev)) ?
+						400 : TA_WAIT_VRISE;
+		dev_dbg(pnw->dev,
+			"Add timer TA_WAIT_VRISE = %lu\n", time);
+		break;
+	case TA_WAIT_BCON_TMR:
+		iotg->hsm.a_wait_bcon_tmout = 0;
+		data = (unsigned long)&iotg->hsm.a_wait_bcon_tmout;
+		time = TA_WAIT_BCON;
+		dev_dbg(pnw->dev,
+			"Add timer TA_WAIT_BCON = %d\n", TA_WAIT_BCON);
+		break;
+	case TA_AIDL_BDIS_TMR:
+		iotg->hsm.a_aidl_bdis_tmout = 0;
+		data = (unsigned long)&iotg->hsm.a_aidl_bdis_tmout;
+		time = TA_AIDL_BDIS;
+		dev_dbg(pnw->dev,
+			"Add timer TA_AIDL_BDIS = %d\n", TA_AIDL_BDIS);
+		break;
+	case TA_BIDL_ADIS_TMR:
+		iotg->hsm.a_bidl_adis_tmout = 0;
+		iotg->hsm.a_bidl_adis_tmr = 1;
+		data = (unsigned long)&iotg->hsm.a_bidl_adis_tmout;
+		time = TA_BIDL_ADIS;
+		dev_dbg(pnw->dev,
+			"Add timer TA_BIDL_ADIS = %d\n", TA_BIDL_ADIS);
+		break;
+	case TA_WAIT_VFALL_TMR:
+		iotg->hsm.a_wait_vfall_tmout = 0;
+		data = (unsigned long)&iotg->hsm.a_wait_vfall_tmout;
+		time = TA_WAIT_VFALL;
+		dev_dbg(pnw->dev,
+			"Add timer TA_WAIT_VFALL = %d\n", TA_WAIT_VFALL);
+		break;
+	case TB_ASE0_BRST_TMR:
+		iotg->hsm.b_ase0_brst_tmout = 0;
+		data = (unsigned long)&iotg->hsm.b_ase0_brst_tmout;
+		time = TB_ASE0_BRST;
+		dev_dbg(pnw->dev,
+			"Add timer TB_ASE0_BRST = %d\n", TB_ASE0_BRST);
+		break;
+	case TB_SRP_FAIL_TMR:
+		iotg->hsm.b_srp_fail_tmout = 0;
+		iotg->hsm.b_srp_fail_tmr = 1;
+		data = (unsigned long)&iotg->hsm.b_srp_fail_tmout;
+		time = TB_SRP_FAIL;
+		dev_dbg(pnw->dev,
+			"Add timer TB_SRP_FAIL = %d\n", TB_SRP_FAIL);
+		break;
+	/* support OTG test mode */
+	case TTST_MAINT_TMR:
+		iotg->hsm.tst_maint_tmout = 0;
+		data = (unsigned long)&iotg->hsm.tst_maint_tmout;
+		time = TTST_MAINT;
+		dev_dbg(pnw->dev,
+			"Add timer TTST_MAINT = %d\n", TTST_MAINT);
+		break;
+	case TTST_NOADP_TMR:
+		iotg->hsm.tst_noadp_tmout = 0;
+		data = (unsigned long)&iotg->hsm.tst_noadp_tmout;
+		time = TTST_NOADP;
+		dev_dbg(pnw->dev,
+			"Add timer TTST_NOADP = %d\n", TTST_NOADP);
+		break;
+	default:
+		dev_dbg(pnw->dev,
+			"unkown timer, can not enable such timer\n");
+		return;
+	}
+
+	pnw->hsm_timer.data = data;
+	pnw->hsm_timer.function = penwell_otg_timer_fn;
+	pnw->hsm_timer.expires = j + time * HZ / 1000; /* milliseconds */
+
+	add_timer(&pnw->hsm_timer);
+}
+
+static inline void penwell_otg_del_timer(enum penwell_otg_timer_type timers)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+
+	switch (timers) {
+	case TA_BIDL_ADIS_TMR:
+		iotg->hsm.a_bidl_adis_tmr = 0;
+		break;
+	case TB_SRP_FAIL_TMR:
+		iotg->hsm.b_srp_fail_tmr = 0;
+		break;
+	case TA_WAIT_BCON_TMR:
+		iotg->hsm.a_wait_bcon_tmout = 0;
+		break;
+	case TTST_MAINT_TMR:
+		iotg->hsm.tst_maint_tmout = 0;
+		break;
+	case TTST_NOADP_TMR:
+		iotg->hsm.tst_noadp_tmout = 0;
+		break;
+	default:
+		break;
+	}
+
+	dev_dbg(pnw->dev, "state machine timer deleted\n");
+	del_timer_sync(&pnw->hsm_timer);
+}
+
+static void reset_otg(void)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	u32			val;
+	int			delay_time = 1000;
+
+	dev_dbg(pnw->dev, "reseting OTG controller ...\n");
+	val = readl(pnw->iotg.base + CI_USBCMD);
+	writel(val | USBCMD_RST, pnw->iotg.base + CI_USBCMD);
+	do {
+		udelay(100);
+		if (!delay_time--)
+			dev_dbg(pnw->dev, "reset timeout\n");
+		val = readl(pnw->iotg.base + CI_USBCMD);
+		val &= USBCMD_RST;
+	} while (val != 0);
+	dev_dbg(pnw->dev, "reset done.\n");
+}
+
+static void pnw_phy_ctrl_rst(void)
+{
+	struct penwell_otg *pnw = the_transceiver;
+	struct pci_dev	*pdev;
+
+	pdev = to_pci_dev(pnw->dev);
+
+	/* mask id intr before reset and delay for 4 ms
+	* before unmasking id intr to avoid wrongly
+	* detecting ID_A which is a side-effect of reset
+	* PHY
+	*/
+	penwell_otg_intr(0);
+	synchronize_irq(pdev->irq);
+
+	penwell_otg_phy_reset();
+
+	reset_otg();
+
+	msleep(50);
+	penwell_otg_intr(1);
+
+	/* after reset, need to sync to OTGSC status bits to hsm */
+	update_hsm();
+	penwell_update_transceiver();
+}
+
+static void set_host_mode(void)
+{
+	u32	val;
+
+	reset_otg();
+	val = readl(the_transceiver->iotg.base + CI_USBMODE);
+	val = (val & (~USBMODE_CM)) | USBMODE_HOST;
+	writel(val, the_transceiver->iotg.base + CI_USBMODE);
+}
+
+static void set_client_mode(void)
+{
+	u32	val;
+
+	reset_otg();
+	val = readl(the_transceiver->iotg.base + CI_USBMODE);
+	val = (val & (~USBMODE_CM)) | USBMODE_DEVICE;
+	writel(val, the_transceiver->iotg.base + CI_USBMODE);
+}
+
+static void init_hsm(void)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	u32				val32;
+
+	/* read OTGSC after reset */
+	val32 = readl(iotg->base + CI_OTGSC);
+	dev_dbg(pnw->dev,
+		"%s: OTGSC init value = 0x%x\n", __func__, val32);
+
+	/* set init state */
+	if (val32 & OTGSC_ID) {
+		iotg->hsm.id = ID_B;
+		iotg->otg.otg->default_a = 0;
+		set_client_mode();
+		iotg->otg.state = OTG_STATE_B_IDLE;
+	} else {
+		iotg->hsm.id = ID_A;
+		iotg->otg.otg->default_a = 1;
+		set_host_mode();
+		iotg->otg.state = OTG_STATE_A_IDLE;
+	}
+
+	/* set session indicator */
+	if (val32 & OTGSC_BSE)
+		iotg->hsm.b_sess_end = 1;
+	if (val32 & OTGSC_BSV)
+		iotg->hsm.b_sess_vld = 1;
+	if (val32 & OTGSC_ASV)
+		iotg->hsm.a_sess_vld = 1;
+	if (val32 & OTGSC_AVV)
+		iotg->hsm.a_vbus_vld = 1;
+
+	/* default user is not request the bus */
+	iotg->hsm.a_bus_req = 1;
+	iotg->hsm.a_bus_drop = 0;
+	/* init hsm means power_up case */
+	iotg->hsm.power_up = 0;
+	/* defautly don't request bus as B device */
+	iotg->hsm.b_bus_req = 0;
+	/* no system error */
+	iotg->hsm.a_clr_err = 0;
+
+	if (iotg->otg.state == OTG_STATE_A_IDLE) {
+		wake_lock(&pnw->wake_lock);
+		pm_runtime_get(pnw->dev);
+	}
+}
+
+static void update_hsm(void)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	u32				val32;
+
+	/* read OTGSC */
+	val32 = readl(iotg->base + CI_OTGSC);
+	dev_dbg(pnw->dev,
+		"%s OTGSC current value = 0x%x\n", __func__, val32);
+
+	iotg->hsm.id = !!(val32 & OTGSC_ID) ? ID_B : ID_A;
+	iotg->hsm.b_sess_end = !!(val32 & OTGSC_BSE);
+	iotg->hsm.b_sess_vld = !!(val32 & OTGSC_BSV);
+	iotg->hsm.a_sess_vld = !!(val32 & OTGSC_ASV);
+	iotg->hsm.a_vbus_vld = !!(val32 & OTGSC_AVV);
+}
+
+static void penwell_otg_eye_diagram_optimize(void)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	int				retval;
+	u8				value = 0;
+
+	/* Check platform value as different value will be used*/
+	if (is_clovertrail(to_pci_dev(pnw->dev))) {
+		/* Set 0x7f for better quality in eye diagram
+		 * It means ZHSDRV = 0b11 and IHSTX = 0b1111*/
+		value = 0x7f;
+	} else {
+		/* Set 0x77 for better quality in eye diagram
+		 * It means ZHSDRV = 0b11 and IHSTX = 0b0111*/
+		value = 0x77;
+	}
+
+	retval = penwell_otg_ulpi_write(iotg, ULPI_VS1SET, value);
+	if (retval)
+		dev_warn(pnw->dev,
+			"eye diagram optimize failed with ulpi failure\n");
+}
+
+static irqreturn_t otg_dummy_irq(int irq, void *_dev)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	void __iomem		*reg_base = _dev;
+	u32			val;
+	u32			int_mask = 0;
+
+	val = readl(reg_base + CI_USBMODE);
+	if ((val & USBMODE_CM) != USBMODE_DEVICE)
+		return IRQ_NONE;
+
+	val = readl(reg_base + CI_USBSTS);
+	int_mask = val & INTR_DUMMY_MASK;
+
+	if (int_mask == 0)
+		return IRQ_NONE;
+
+	/* clear hsm.b_conn here since host driver can't detect it
+	*  otg_dummy_irq called means B-disconnect happened.
+	*/
+	if (pnw->iotg.hsm.b_conn) {
+		pnw->iotg.hsm.b_conn = 0;
+		penwell_update_transceiver();
+	}
+
+	/* Clear interrupts */
+	writel(int_mask, reg_base + CI_USBSTS);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t otg_irq_handle(struct penwell_otg *pnw,
+					struct intel_mid_otg_xceiv *iotg)
+{
+	int				id = 0;
+	int				flag = 0;
+	u32				int_sts, int_en, int_mask = 0;
+	u8				usb_vs2_latch = 0;
+	u8				usb_vs2_sts = 0;
+	struct iotg_ulpi_access_ops	*ops;
+
+	/* Check VBUS/SRP interrup */
+	int_sts = readl(pnw->iotg.base + CI_OTGSC);
+	int_en = (int_sts & OTGSC_INTEN_MASK) >> 8;
+	int_mask = int_sts & int_en;
+
+	if (int_mask == 0)
+		return IRQ_NONE;
+
+	ops = &iotg->ulpi_ops;
+	ops->read(iotg, ULPI_VS2LATCH, &usb_vs2_latch);
+	dev_dbg(pnw->dev, "usb_vs2_latch = 0x%x\n", usb_vs2_latch);
+	if (usb_vs2_latch & IDRARBRC_MSK) {
+		ops->read(iotg, ULPI_VS2STS, &usb_vs2_sts);
+		dev_dbg(pnw->dev, "%s: usb_vs2_sts = 0x%x\n",
+				__func__, usb_vs2_sts);
+
+		switch (IDRARBRC_STS(usb_vs2_sts)) {
+		case IDRARBRC_A:
+			id = ID_ACA_A;
+			dev_dbg(pnw->dev, "ACA-A interrupt detected\n");
+			break;
+		case IDRARBRC_B:
+			id = ID_ACA_B;
+			dev_dbg(pnw->dev, "ACA-B interrupt detected\n");
+			break;
+		case IDRARBRC_C:
+			id = ID_ACA_C;
+			dev_dbg(pnw->dev, "ACA-C interrupt detected\n");
+			break;
+		default:
+			break;
+		}
+
+		if (id) {
+			iotg->hsm.id = id;
+			flag = 1;
+			dev_dbg(pnw->dev, "%s: id change int = %d\n",
+					__func__, iotg->hsm.id);
+		} else {
+			iotg->hsm.id = (int_sts & OTGSC_ID) ?
+				ID_B : ID_A;
+			flag = 1;
+			dev_dbg(pnw->dev, "%s: id change int = %d\n",
+					__func__, iotg->hsm.id);
+		}
+	}
+
+	if (int_mask) {
+		dev_dbg(pnw->dev,
+			"OTGSC = 0x%x, mask =0x%x\n", int_sts, int_mask);
+
+		if (int_mask & OTGSC_IDIS) {
+			if (!id)
+				iotg->hsm.id = (int_sts & OTGSC_ID) ?
+					ID_B : ID_A;
+			flag = 1;
+			dev_dbg(pnw->dev, "%s: id change int = %d\n",
+						__func__, iotg->hsm.id);
+
+			/* Update a_vbus_valid once ID changed */
+			iotg->hsm.a_vbus_vld = (int_sts & OTGSC_AVV) ? 1 : 0;
+		}
+		if (int_mask & OTGSC_DPIS) {
+			iotg->hsm.a_srp_det = (int_sts & OTGSC_DPS) ? 1 : 0;
+			flag = 1;
+			dev_dbg(pnw->dev, "%s: data pulse int = %d\n",
+						__func__, iotg->hsm.a_srp_det);
+		}
+		if (int_mask & OTGSC_BSEIS) {
+			iotg->hsm.b_sess_end = (int_sts & OTGSC_BSE) ? 1 : 0;
+			flag = 1;
+			dev_dbg(pnw->dev, "%s: b sess end int = %d\n",
+						__func__, iotg->hsm.b_sess_end);
+		}
+		if (int_mask & OTGSC_BSVIS) {
+			iotg->hsm.b_sess_vld = (int_sts & OTGSC_BSV) ? 1 : 0;
+			flag = 1;
+			dev_dbg(pnw->dev, "%s: b sess valid int = %d\n",
+						__func__, iotg->hsm.b_sess_vld);
+		}
+		if (int_mask & OTGSC_ASVIS) {
+			iotg->hsm.a_sess_vld = (int_sts & OTGSC_ASV) ? 1 : 0;
+			flag = 1;
+			dev_dbg(pnw->dev, "%s: a sess valid int = %d\n",
+						__func__, iotg->hsm.a_sess_vld);
+		}
+		if (int_mask & OTGSC_AVVIS) {
+			iotg->hsm.a_vbus_vld = (int_sts & OTGSC_AVV) ? 1 : 0;
+			flag = 1;
+			dev_dbg(pnw->dev, "%s: a vbus valid int = %d\n",
+						__func__, iotg->hsm.a_vbus_vld);
+		}
+
+		writel((int_sts & ~OTGSC_INTSTS_MASK) | int_mask,
+				pnw->iotg.base + CI_OTGSC);
+	}
+
+	if (flag)
+		penwell_update_transceiver();
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t otg_irq(int irq, void *_dev)
+{
+	struct penwell_otg		*pnw = _dev;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	unsigned long			flags;
+
+#ifdef CONFIG_PM_RUNTIME
+	if (pnw->rt_resuming)
+		return IRQ_HANDLED;
+
+	/* If it's not active, resume device first before access regs */
+	if (pnw->rt_quiesce) {
+		spin_lock_irqsave(&pnw->lock, flags);
+		if (pnw->rt_quiesce) {
+			dev_dbg(pnw->dev, "Wake up? Interrupt detected in suspended\n");
+			pnw->rt_resuming = 1;
+			pm_runtime_get(pnw->dev);
+		}
+		spin_unlock_irqrestore(&pnw->lock, flags);
+
+		return IRQ_HANDLED;
+	}
+#endif /* CONFIG_PM_RUNTIME */
+
+	return otg_irq_handle(pnw, iotg);
+}
+
+static void penwell_otg_start_ulpi_poll(void)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	int				retval = 0;
+
+	retval = penwell_otg_ulpi_write(&pnw->iotg, 0x16, 0x5a);
+	if (retval)
+		dev_err(pnw->dev, "ulpi write in init failed\n");
+
+	schedule_delayed_work(&pnw->ulpi_poll_work, HZ);
+}
+
+static void penwell_otg_continue_ulpi_poll(void)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+
+	schedule_delayed_work(&pnw->ulpi_poll_work, HZ);
+}
+
+static void penwell_otg_stop_ulpi_poll(void)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+
+	/* we have to use this version because this function can
+	 * be called in irq handler */
+	__cancel_delayed_work(&pnw->ulpi_poll_work);
+}
+
+
+static int penwell_otg_iotg_notify(struct notifier_block *nb,
+				unsigned long action, void *data)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = data;
+	int				flag = 0;
+	struct pci_dev			*pdev;
+
+	if (iotg == NULL)
+		return NOTIFY_BAD;
+
+	if (pnw == NULL)
+		return NOTIFY_BAD;
+
+	pdev = to_pci_dev(pnw->dev);
+
+	switch (action) {
+	case MID_OTG_NOTIFY_CONNECT:
+		dev_dbg(pnw->dev, "PNW OTG Notify Connect Event\n");
+		if (iotg->otg.otg->default_a == 1)
+			iotg->hsm.b_conn = 1;
+		else
+			iotg->hsm.a_conn = 1;
+		flag = 1;
+		break;
+	case MID_OTG_NOTIFY_DISCONN:
+		dev_dbg(pnw->dev, "PNW OTG Notify Disconnect Event\n");
+		if (iotg->otg.otg->default_a == 1)
+			iotg->hsm.b_conn = 0;
+		else
+			iotg->hsm.a_conn = 0;
+		flag = 1;
+		break;
+	case MID_OTG_NOTIFY_HSUSPEND:
+		dev_dbg(pnw->dev, "PNW OTG Notify Host Bus suspend Event\n");
+		break;
+	case MID_OTG_NOTIFY_HRESUME:
+		dev_dbg(pnw->dev, "PNW OTG Notify Host Bus resume Event\n");
+		if (iotg->otg.otg->default_a == 1 && iotg->hsm.a_bus_req == 0) {
+			iotg->hsm.a_bus_req = 1;
+			flag = 1;
+		}
+		break;
+	case MID_OTG_NOTIFY_CSUSPEND:
+		dev_dbg(pnw->dev, "PNW OTG Notify Client Bus suspend Event\n");
+		if (iotg->otg.otg->default_a == 1) {
+			iotg->hsm.b_bus_suspend = 1;
+			flag = 1;
+		} else {
+			penwell_otg_stop_ulpi_poll();
+			if (iotg->hsm.a_bus_suspend == 0) {
+				iotg->hsm.a_bus_suspend = 1;
+				flag = 1;
+			} else
+				flag = 0;
+		}
+		break;
+	case MID_OTG_NOTIFY_CRESUME:
+		dev_dbg(pnw->dev, "PNW OTG Notify Client Bus resume Event\n");
+		if (iotg->otg.otg->default_a == 1) {
+			/* in A_PERIPHERAL state */
+			iotg->hsm.b_bus_suspend = 0;
+			flag = 1;
+		} else {
+			/* in B_PERIPHERAL state */
+			if (!is_clovertrail(pdev))
+				penwell_otg_start_ulpi_poll();
+			iotg->hsm.a_bus_suspend = 0;
+			flag = 0;
+		}
+		break;
+	case MID_OTG_NOTIFY_CRESET:
+		dev_dbg(pnw->dev, "PNW OTG Notify Client Bus reset Event\n");
+		penwell_otg_set_power(&pnw->iotg.otg, CHRG_CURR_SDP_SUSP);
+		flag = 0;
+		break;
+	case MID_OTG_NOTIFY_HOSTADD:
+		dev_dbg(pnw->dev, "PNW OTG Nofity Host Driver Add\n");
+		flag = 1;
+		break;
+	case MID_OTG_NOTIFY_HOSTREMOVE:
+		dev_dbg(pnw->dev, "PNW OTG Nofity Host Driver remove\n");
+		flag = 1;
+		break;
+	case MID_OTG_NOTIFY_CLIENTADD:
+		dev_dbg(pnw->dev, "PNW OTG Nofity Client Driver Add\n");
+		flag = 1;
+		break;
+	case MID_OTG_NOTIFY_CLIENTREMOVE:
+		dev_dbg(pnw->dev, "PNW OTG Nofity Client Driver remove\n");
+		flag = 1;
+		break;
+	/* Test mode support */
+	case MID_OTG_NOTIFY_TEST_MODE_START:
+		dev_dbg(pnw->dev, "PNW OTG Notfiy Client Testmode Start\n");
+		iotg->hsm.in_test_mode = 1;
+		flag = 0;
+		break;
+	case MID_OTG_NOTIFY_TEST_MODE_STOP:
+		dev_dbg(pnw->dev, "PNW OTG Notfiy Client Testmode Stop\n");
+		iotg->hsm.in_test_mode = 0;
+		flag = 0;
+		break;
+	case MID_OTG_NOTIFY_TEST_SRP_REQD:
+		dev_dbg(pnw->dev, "PNW OTG Notfiy Client SRP REQD\n");
+		iotg->hsm.otg_srp_reqd = 1;
+		flag = 1;
+		break;
+	case MID_OTG_NOTIFY_TEST:
+		dev_dbg(pnw->dev, "PNW OTG Notfiy Test device detected\n");
+		iotg->hsm.test_device = 1;
+		flag = 0;
+		break;
+	case MID_OTG_NOTIFY_TEST_VBUS_OFF:
+		dev_dbg(pnw->dev, "PNW OTG Notfiy Test device Vbus off mode\n");
+		iotg->hsm.test_device = 1;
+		iotg->hsm.otg_vbus_off = 1;
+		flag = 1;
+		break;
+	default:
+		dev_dbg(pnw->dev, "PNW OTG Nofity unknown notify message\n");
+		return NOTIFY_DONE;
+	}
+
+	if (flag)
+		penwell_update_transceiver();
+
+	return NOTIFY_OK;
+}
+
+static void penwell_otg_hnp_poll_work(struct work_struct *work)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	struct usb_device		*udev;
+	int				err = 0;
+	u8				data;
+
+	if (iotg->otg.otg->host && iotg->otg.otg->host->root_hub) {
+		udev = usb_hub_find_child(iotg->otg.otg->host->root_hub, 1);
+	} else {
+		dev_warn(pnw->dev, "no host or root_hub registered\n");
+		return;
+	}
+
+	if (iotg->otg.state != OTG_STATE_A_HOST
+		&& iotg->otg.state != OTG_STATE_B_HOST)
+		return;
+
+	if (!udev) {
+		dev_warn(pnw->dev,
+			"no usb dev connected, stop HNP polling\n");
+		return;
+	}
+
+	/* Skip HS Electrical Test Device */
+	if (le16_to_cpu(udev->descriptor.idVendor) == 0x1A0A &&
+		le16_to_cpu(udev->descriptor.idProduct) > 0x0100 &&
+		le16_to_cpu(udev->descriptor.idProduct) < 0x0109) {
+		return;
+	}
+
+	/* get host request flag from connected USB device */
+	err = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),
+		USB_REQ_GET_STATUS, USB_DIR_IN, 0, 0xF000, &data, 1, 5000);
+
+	if (err < 0) {
+		dev_warn(pnw->dev,
+			"ERR in HNP polling = %d, stop HNP polling\n", err);
+		return;
+	}
+
+	if (data & HOST_REQUEST_FLAG) {
+		/* start HNP sequence to switch role */
+		dev_dbg(pnw->dev, "host_request_flag = 1\n");
+
+		if (iotg->hsm.id == ID_B) {
+			dev_dbg(pnw->dev,
+				"Device B host - start HNP - b_bus_req = 0\n");
+			iotg->hsm.b_bus_req = 0;
+		} else if (iotg->hsm.id == ID_A) {
+			dev_dbg(pnw->dev,
+				"Device A host - start HNP - a_bus_req = 0\n");
+			iotg->hsm.a_bus_req = 0;
+		}
+		penwell_update_transceiver();
+	} else {
+		dev_dbg(pnw->dev, "host_request_flag = 0\n");
+		penwell_otg_continue_hnp_poll(&pnw->iotg);
+	}
+}
+
+static int penwell_otg_ulpi_check(void)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	u8				data;
+	int				retval;
+
+	retval = penwell_otg_ulpi_read(iotg, 0x16, &data);
+	if (retval) {
+		dev_err(pnw->dev,
+				"%s: [ ULPI hang ] detected\n"
+				"reset PHY & ctrl to recover\n",
+				 __func__);
+		pnw_phy_ctrl_rst();
+		return retval;
+	}
+	return 0;
+}
+
+static void penwell_otg_ulpi_check_work(struct work_struct *work)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	int				status;
+
+	status = pm_runtime_get_sync(pnw->dev);
+	if (status < 0) {
+		dev_err(pnw->dev, "%s: pm_runtime_get_sync FAILED err = %d\n",
+				__func__, status);
+		pm_runtime_put_sync(pnw->dev);
+		return;
+	}
+
+	if (iotg->otg.state == OTG_STATE_B_IDLE) {
+		/* Before charger detection or charger detection done */
+		dev_dbg(pnw->dev, "ulpi_check health\n");
+		penwell_otg_ulpi_check();
+	} else if (iotg->otg.state == OTG_STATE_B_PERIPHERAL) {
+		/* After charger detection, SDP/CDP is detected */
+		dev_dbg(pnw->dev, "ulpi_check health\n");
+		status = penwell_otg_ulpi_check();
+		if (status) {
+			/* After phy rst then restart peripheral stack */
+			if (iotg->stop_peripheral)
+				iotg->stop_peripheral(iotg);
+			else
+				dev_dbg(pnw->dev,
+					"client driver not support\n");
+
+			if (iotg->start_peripheral)
+				iotg->start_peripheral(iotg);
+			else
+				dev_dbg(pnw->dev,
+					"client driver not support\n");
+		}
+	}
+
+	pm_runtime_put(pnw->dev);
+}
+
+static void penwell_otg_uevent_work(struct work_struct *work)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	char *uevent_envp[2] = { "USB_INTR=BOGUS", NULL };
+
+	dev_info(pnw->dev, "%s: send uevent USB_INTR=BOGUS\n", __func__);
+	kobject_uevent_env(&pnw->dev->kobj, KOBJ_CHANGE, uevent_envp);
+}
+
+static void penwell_otg_ulpi_poll_work(struct work_struct *work)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	u8				data;
+
+	if (iotg->otg.state != OTG_STATE_B_PERIPHERAL)
+		return;
+
+	if (iotg->hsm.in_test_mode)
+		return;
+
+	if (penwell_otg_ulpi_read(iotg, 0x16, &data)) {
+		dev_err(pnw->dev, "ulpi read time out by polling\n");
+		iotg->hsm.ulpi_error = 1;
+		iotg->hsm.ulpi_polling = 0;
+		penwell_update_transceiver();
+	} else if (data != 0x5A) {
+		dev_err(pnw->dev, "ulpi read value incorrect by polling\n");
+		iotg->hsm.ulpi_error = 1;
+		iotg->hsm.ulpi_polling = 0;
+		penwell_update_transceiver();
+	} else {
+		dev_dbg(pnw->dev, "ulpi fine by polling\n");
+		iotg->hsm.ulpi_error = 0;
+		iotg->hsm.ulpi_polling = 1;
+		penwell_otg_continue_ulpi_poll();
+	}
+}
+
+static void penwell_otg_psc_notify_work(struct work_struct *work)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	struct power_supply_cable_props	psc_cap;
+	enum power_supply_charger_event chrg_event;
+	unsigned long			flags;
+	struct otg_bc_event		*event, *temp;
+
+	spin_lock_irqsave(&pnw->charger_lock, flags);
+	list_for_each_entry_safe(event, temp, &pnw->chrg_evt_queue, node) {
+		list_del(&event->node);
+		spin_unlock_irqrestore(&pnw->charger_lock, flags);
+
+		spin_lock_irqsave(&pnw->cap_lock, flags);
+		chrg_event = check_psc_event(pnw->psc_cap, event->cap);
+		if (chrg_event == -1)
+			dev_dbg(pnw->dev, "no need to notify\n");
+		else if (chrg_event == POWER_SUPPLY_CHARGER_EVENT_DISCONNECT) {
+			/* In Disconnect case, EM driver needs same chrg type
+			 * like Connect even, construct one here */
+			psc_cap = event->cap;
+			psc_cap.chrg_evt = chrg_event;
+			psc_cap.chrg_type = pnw->psc_cap.chrg_type;
+			pnw->psc_cap = event->cap;
+			pnw->psc_cap.chrg_evt = chrg_event;
+		} else {
+			pnw->psc_cap = event->cap;
+			pnw->psc_cap.chrg_evt = chrg_event;
+			psc_cap = pnw->psc_cap;
+		}
+		spin_unlock_irqrestore(&pnw->cap_lock, flags);
+
+		if (chrg_event != -1) {
+			dev_dbg(pnw->dev, "ma = %d, evt = %d, type = %s\n",
+				psc_cap.ma, psc_cap.chrg_evt,
+				psc_string(psc_cap.chrg_type));
+
+			atomic_notifier_call_chain(&iotg->otg.notifier,
+					USB_EVENT_CHARGER, &psc_cap);
+		}
+
+		kfree(event);
+		spin_lock_irqsave(&pnw->charger_lock, flags);
+	}
+	spin_unlock_irqrestore(&pnw->charger_lock, flags);
+}
+
+static void penwell_otg_sdp_check_work(struct work_struct *work)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct otg_bc_cap		cap;
+
+	/* Need to handle MFLD/CLV differently per different interface */
+	if (!is_clovertrail(to_pci_dev(pnw->dev))) {
+		if (penwell_otg_query_charging_cap(&cap)) {
+			dev_warn(pnw->dev, "SDP checking failed\n");
+			return;
+		}
+
+		/* If current charging cap is still 100ma SDP,
+		 * assume this is a invalid charger and do 500ma
+		 * charging */
+		if (cap.ma != 100 || cap.chrg_type != CHRG_SDP)
+			return;
+	} else
+		return;
+
+	dev_info(pnw->dev, "Notify invalid SDP at %dma\n", CHRG_CURR_SDP_INVAL);
+	penwell_otg_update_chrg_cap(CHRG_SDP_INVAL, CHRG_CURR_SDP_INVAL);
+}
+
+static void penwell_otg_work(struct work_struct *work)
+{
+	struct penwell_otg			*pnw = container_of(work,
+						struct penwell_otg, work);
+	struct intel_mid_otg_xceiv		*iotg = &pnw->iotg;
+	struct otg_hsm				*hsm = &iotg->hsm;
+	enum usb_charger_type			charger_type;
+	enum power_supply_charger_cable_type	type;
+	int					retval;
+	struct pci_dev				*pdev;
+	unsigned long				flags;
+
+	dev_dbg(pnw->dev,
+		"old state = %s\n", state_string(iotg->otg.state));
+
+	pm_runtime_get_sync(pnw->dev);
+
+	pdev = to_pci_dev(pnw->dev);
+
+	switch (iotg->otg.state) {
+	case OTG_STATE_UNDEFINED:
+	case OTG_STATE_B_IDLE:
+		if (hsm->id == ID_A || hsm->id == ID_ACA_A) {
+			/* Move to A_IDLE state, ID changes */
+
+			/* Delete current timer */
+			penwell_otg_del_timer(TB_SRP_FAIL_TMR);
+
+			iotg->otg.otg->default_a = 1;
+			hsm->a_srp_det = 0;
+			set_host_mode();
+			penwell_otg_phy_low_power(0);
+
+			/* Always set a_bus_req to 1, in case no ADP */
+			hsm->a_bus_req = 1;
+
+			/* Prevent device enter D0i1 or S3*/
+			wake_lock(&pnw->wake_lock);
+			pm_runtime_get(pnw->dev);
+
+			iotg->otg.state = OTG_STATE_A_IDLE;
+			penwell_update_transceiver();
+		} else if (hsm->b_adp_sense_tmout) {
+			hsm->b_adp_sense_tmout = 0;
+		} else if (hsm->b_srp_fail_tmout) {
+			hsm->b_srp_fail_tmr = 0;
+			hsm->b_srp_fail_tmout = 0;
+			hsm->b_bus_req = 0;
+			penwell_otg_nsf_msg(6);
+
+			penwell_update_transceiver();
+		} else if (hsm->b_sess_vld) {
+			/* Check if DCP is detected */
+			spin_lock_irqsave(&pnw->charger_lock, flags);
+			charger_type = pnw->charging_cap.chrg_type;
+			type = pnw->psc_cap.chrg_type;
+			if (charger_type == CHRG_DCP ||
+				type == POWER_SUPPLY_CHARGER_TYPE_USB_DCP) {
+				spin_unlock_irqrestore(&pnw->charger_lock,
+						flags);
+				break;
+			}
+			spin_unlock_irqrestore(&pnw->charger_lock, flags);
+
+			penwell_otg_phy_low_power(0);
+
+			/* Clear power_up */
+			hsm->power_up = 0;
+
+			/* Move to B_PERIPHERAL state, Session Valid */
+
+			/* Delete current timer */
+			penwell_otg_del_timer(TB_SRP_FAIL_TMR);
+
+			hsm->b_sess_end = 0;
+			hsm->a_bus_suspend = 0;
+
+			/* Start USB Battery charger detection flow */
+
+			/* We need new charger detection flow for Clovertrail.
+			 * But for now(power-on), we just skip it.
+			 * Later on we'll figure it out.
+			 */
+			if (!is_clovertrail(pdev)) {
+				mutex_lock(&pnw->msic_mutex);
+				if (pdev->revision >= 0x8) {
+					retval = penwell_otg_manual_chrg_det();
+					if (retval < 0) {
+						/* if failed, reset controller
+						 * and try charger detection
+						 * flow again */
+						dev_warn(pnw->dev,
+								"detection failed, retry");
+						set_client_mode();
+						msleep(100);
+						penwell_otg_phy_low_power(0);
+						penwell_spi_reset_phy();
+					retval = penwell_otg_manual_chrg_det();
+					}
+				} else {
+					/* Enable data contact detection */
+					penwell_otg_data_contact_detect();
+					/* Enable charger detection */
+					penwell_otg_charger_detect();
+					retval =
+					penwell_otg_charger_type_detect();
+				}
+				mutex_unlock(&pnw->msic_mutex);
+				if (retval < 0) {
+					dev_warn(pnw->dev, "Charger detect failure\n");
+					break;
+				} else {
+					charger_type = retval;
+				}
+			} else {
+				/* Clovertrail charger detection flow */
+				retval = penwell_otg_charger_det_clt();
+				if (retval < 0) {
+					dev_warn(pnw->dev, "detect failed\n");
+					/* Reset PHY and redo the detection */
+					pnw_phy_ctrl_rst();
+					/* Restart charger detection */
+					retval = penwell_otg_charger_det_clt();
+					if (retval)
+						dev_warn(pnw->dev,
+							"detect fail again\n");
+					break;
+				} else
+					charger_type = retval;
+			}
+
+			/* This is a workaround for self-powered hub case,
+			 * vbus valid event comes several ms before id change */
+			if (hsm->id == ID_A) {
+				dev_warn(pnw->dev, "ID changed\n");
+				break;
+			}
+
+			if (charger_type == CHRG_SE1) {
+				dev_info(pnw->dev, "SE1 detected\n");
+
+				/* SE1: set charger type, current, notify EM */
+				penwell_otg_update_chrg_cap(CHRG_SE1,
+							CHRG_CURR_SE1);
+				dev_info(pnw->dev,
+					"reset PHY via SPI if SE1 detected\n");
+
+				if (!is_clovertrail(pdev)) {
+					/* Reset PHY for MFLD only */
+					penwell_otg_msic_spi_access(true);
+					penwell_otg_msic_write(MSIC_FUNCTRLSET,
+							PHYRESET);
+					penwell_otg_msic_spi_access(false);
+				}
+				break;
+			} else if (charger_type == CHRG_DCP) {
+				dev_info(pnw->dev, "DCP detected\n");
+
+				/* DCP: set charger type, current, notify EM */
+				penwell_otg_update_chrg_cap(CHRG_DCP,
+							CHRG_CURR_DCP);
+				set_client_mode();
+				break;
+
+			} else if (charger_type == CHRG_ACA) {
+				dev_info(pnw->dev, "ACA detected\n");
+				if (hsm->id == ID_ACA_A) {
+					/* Move to A_IDLE state, ID changes */
+					penwell_otg_update_chrg_cap(CHRG_ACA,
+								CHRG_CURR_ACA);
+
+					/* Delete current timer */
+					penwell_otg_del_timer(TB_SRP_FAIL_TMR);
+
+					iotg->otg.otg->default_a = 1;
+					hsm->a_srp_det = 0;
+					set_host_mode();
+					penwell_otg_phy_low_power(0);
+
+					/* Always set a_bus_req to 1,
+					 * in case no ADP */
+					hsm->a_bus_req = 1;
+
+					/* Prevent device enter D0i1 or S3*/
+					wake_lock(&pnw->wake_lock);
+					pm_runtime_get(pnw->dev);
+
+					iotg->otg.state = OTG_STATE_A_IDLE;
+					penwell_update_transceiver();
+					break;
+				} else if (hsm->id == ID_ACA_B) {
+					penwell_otg_update_chrg_cap(CHRG_ACA,
+								CHRG_CURR_ACA);
+					break;
+				} else if (hsm->id == ID_ACA_C) {
+					penwell_otg_update_chrg_cap(CHRG_ACA,
+								CHRG_CURR_ACA);
+					/* Clear HNP polling flag */
+					if (iotg->otg.otg->gadget)
+						iotg->otg.otg->gadget->
+							host_request_flag = 0;
+
+					penwell_otg_phy_low_power(0);
+					set_client_mode();
+
+					if (iotg->start_peripheral) {
+						iotg->start_peripheral(iotg);
+					} else {
+						dev_dbg(pnw->dev,
+							"client driver not support\n");
+						break;
+					}
+				}
+			} else if (charger_type == CHRG_CDP) {
+				dev_info(pnw->dev, "CDP detected\n");
+
+				/* MFLD WA: MSIC issue need disable phy intr */
+				if (!is_clovertrail(pdev)) {
+					dev_dbg(pnw->dev,
+						"MFLD WA: enable PHY int\n");
+					penwell_otg_phy_intr(0);
+				}
+
+				/* CDP: set charger type, current, notify EM */
+				penwell_otg_update_chrg_cap(CHRG_CDP,
+							CHRG_CURR_CDP);
+
+				/* Clear HNP polling flag */
+				if (iotg->otg.otg->gadget)
+					iotg->otg.otg->gadget->
+							host_request_flag = 0;
+
+				if (iotg->start_peripheral) {
+					iotg->start_peripheral(iotg);
+				} else {
+					dev_dbg(pnw->dev,
+						"client driver not support\n");
+					break;
+				}
+			} else if (charger_type == CHRG_SDP) {
+				dev_info(pnw->dev, "SDP detected\n");
+
+				/* MFLD WA: MSIC issue need disable phy intr */
+				if (!is_clovertrail(pdev)) {
+					dev_dbg(pnw->dev,
+						"MFLD WA: enable PHY int\n");
+					penwell_otg_phy_intr(0);
+				}
+
+				/* SDP: set charger type and 100ma by default */
+				penwell_otg_update_chrg_cap(CHRG_SDP, 100);
+
+				/* Clear HNP polling flag */
+				if (iotg->otg.otg->gadget)
+					iotg->otg.otg->gadget->
+							host_request_flag = 0;
+
+				penwell_otg_phy_low_power(0);
+				set_client_mode();
+
+				if (iotg->start_peripheral) {
+					iotg->start_peripheral(iotg);
+				} else {
+					dev_dbg(pnw->dev,
+						"client driver not support\n");
+					break;
+				}
+
+				/* Schedule the SDP checking after TIMEOUT */
+				queue_delayed_work(pnw->qwork,
+						&pnw->sdp_check_work,
+						INVALID_SDP_TIMEOUT);
+			} else if (charger_type == CHRG_UNKNOWN) {
+				dev_info(pnw->dev, "Unknown Charger Found\n");
+
+				/* Unknown: set charger type */
+				penwell_otg_update_chrg_cap(CHRG_UNKNOWN, 0);
+			}
+
+			penwell_otg_eye_diagram_optimize();
+
+			/* MFLD WA for PHY issue */
+			iotg->hsm.in_test_mode = 0;
+			iotg->hsm.ulpi_error = 0;
+
+			if (!is_clovertrail(pdev))
+				penwell_otg_start_ulpi_poll();
+
+			iotg->otg.state = OTG_STATE_B_PERIPHERAL;
+
+		} else if ((hsm->b_bus_req || hsm->power_up || hsm->adp_change
+				|| hsm->otg_srp_reqd) && !hsm->b_srp_fail_tmr) {
+
+			penwell_otg_mon_bus();
+
+			if (hsm->b_ssend_srp && hsm->b_se0_srp) {
+
+				hsm->power_up = 0;
+				hsm->adp_change = 0;
+
+				/* clear the PHCD before start srp */
+				penwell_otg_phy_low_power(0);
+
+				/* Start SRP */
+				if (pnw->iotg.otg.otg->start_srp)
+					pnw->iotg.otg.otg->start_srp(
+							pnw->iotg.otg.otg);
+				penwell_otg_add_timer(TB_SRP_FAIL_TMR);
+
+			} else {
+				hsm->b_bus_req = 0;
+				dev_info(pnw->dev,
+					"BUS is active, try SRP later\n");
+			}
+
+			/* clear after SRP attemp */
+			if (hsm->otg_srp_reqd) {
+				dev_dbg(pnw->dev, "Test mode: SRP done\n");
+				hsm->otg_srp_reqd = 0;
+			}
+		} else if (!hsm->b_sess_vld && hsm->id == ID_B) {
+			spin_lock_irqsave(&pnw->charger_lock, flags);
+			charger_type = pnw->charging_cap.chrg_type;
+			type = pnw->psc_cap.chrg_type;
+			spin_unlock_irqrestore(&pnw->charger_lock, flags);
+
+			if (charger_type == CHRG_DCP) {
+				/* Notify EM charger remove event */
+				penwell_otg_update_chrg_cap(CHRG_UNKNOWN,
+						CHRG_CURR_DISCONN);
+
+				retval = penwell_otg_ulpi_write(iotg,
+						ULPI_PWRCTRLCLR, DPVSRCEN);
+				if (retval)
+					dev_warn(pnw->dev, "ulpi failed\n");
+				penwell_otg_charger_hwdet(false);
+			} else if (charger_type == CHRG_SE1) {
+				/* Notify EM charger remove event */
+				penwell_otg_update_chrg_cap(CHRG_UNKNOWN,
+						CHRG_CURR_DISCONN);
+
+				/* WA: on SE1 detach, reset PHY over SPI */
+				dev_info(pnw->dev,
+					"reset PHY over SPI if SE1 detached\n");
+				penwell_otg_msic_spi_access(true);
+				penwell_otg_msic_write(MSIC_FUNCTRLSET,
+							PHYRESET);
+				penwell_otg_msic_spi_access(false);
+			} else if (type == POWER_SUPPLY_CHARGER_TYPE_USB_ACA) {
+				/* Notify EM charger remove event */
+				penwell_otg_update_chrg_cap(CHRG_UNKNOWN,
+						CHRG_CURR_DISCONN);
+				penwell_otg_charger_hwdet(false);
+			} else if (type == POWER_SUPPLY_CHARGER_TYPE_USB_DCP) {
+				/* Notify EM charger remove event */
+				penwell_otg_update_chrg_cap(CHRG_UNKNOWN,
+						CHRG_CURR_DISCONN);
+
+				retval = penwell_otg_ulpi_write(iotg,
+						ULPI_PWRCTRLCLR, DPVSRCEN);
+				if (retval)
+					dev_warn(pnw->dev, "ulpi failed\n");
+				penwell_otg_charger_hwdet(false);
+			} else if (type == POWER_SUPPLY_CHARGER_TYPE_SE1) {
+				/* Notify EM charger remove event */
+				penwell_otg_update_chrg_cap(CHRG_UNKNOWN,
+						CHRG_CURR_DISCONN);
+			}
+		}
+		break;
+
+	case OTG_STATE_B_PERIPHERAL:
+		/* FIXME: Check if ID_ACA_A event will happened in this state */
+		if (hsm->id == ID_A) {
+			iotg->otg.otg->default_a = 1;
+			hsm->a_srp_det = 0;
+
+			cancel_delayed_work_sync(&pnw->ulpi_poll_work);
+			cancel_delayed_work_sync(&pnw->sdp_check_work);
+			penwell_otg_charger_hwdet(false);
+
+			if (iotg->stop_peripheral)
+				iotg->stop_peripheral(iotg);
+			else
+				dev_dbg(pnw->dev,
+					"client driver has been removed.\n");
+
+			set_host_mode();
+
+			/* Always set a_bus_req to 1, in case no ADP */
+			hsm->a_bus_req = 1;
+
+			/* Notify EM charger remove event */
+			penwell_otg_update_chrg_cap(CHRG_UNKNOWN,
+						CHRG_CURR_DISCONN);
+
+			/* Prevent device enter D0i1 or S3*/
+			wake_lock(&pnw->wake_lock);
+			pm_runtime_get(pnw->dev);
+
+			iotg->otg.state = OTG_STATE_A_IDLE;
+			penwell_update_transceiver();
+		} else if (hsm->ulpi_error && !hsm->in_test_mode) {
+			/* WA: try to recover once detected PHY issue */
+			hsm->ulpi_error = 0;
+
+			cancel_delayed_work_sync(&pnw->ulpi_poll_work);
+			cancel_delayed_work_sync(&pnw->sdp_check_work);
+
+			if (iotg->stop_peripheral)
+				iotg->stop_peripheral(iotg);
+
+			msleep(2000);
+
+			if (iotg->start_peripheral)
+				iotg->start_peripheral(iotg);
+
+			if (!is_clovertrail(pdev))
+				penwell_otg_start_ulpi_poll();
+
+		} else if (!hsm->b_sess_vld || hsm->id == ID_ACA_B) {
+			/* Move to B_IDLE state, VBUS off/ACA */
+
+			cancel_delayed_work(&pnw->ulpi_poll_work);
+			cancel_delayed_work_sync(&pnw->sdp_check_work);
+
+			hsm->b_bus_req = 0;
+
+			if (is_clovertrail(pdev)) {
+				queue_delayed_work(pnw->qwork,
+					&pnw->ulpi_check_work, HZ);
+			}
+
+			if (iotg->stop_peripheral)
+				iotg->stop_peripheral(iotg);
+			else
+				dev_dbg(pnw->dev,
+					"client driver has been removed.\n");
+
+			/* MFLD WA: reenable it for unplug event */
+			if (!is_clovertrail(pdev)) {
+				dev_dbg(pnw->dev, "MFLD WA: disable PHY int\n");
+				penwell_otg_phy_intr(1);
+			}
+
+			if (hsm->id == ID_ACA_B)
+				penwell_otg_update_chrg_cap(CHRG_ACA,
+							CHRG_CURR_ACA);
+			else if (hsm->id == ID_B) {
+				/* Notify EM charger remove event */
+				penwell_otg_update_chrg_cap(CHRG_UNKNOWN,
+							CHRG_CURR_DISCONN);
+				penwell_otg_charger_hwdet(false);
+			}
+
+				iotg->otg.state = OTG_STATE_B_IDLE;
+		} else if (hsm->b_bus_req && hsm->a_bus_suspend
+				&& iotg->otg.otg->gadget
+				&& iotg->otg.otg->gadget->b_hnp_enable) {
+
+			penwell_otg_phy_low_power(0);
+			msleep(10);
+
+			if (iotg->stop_peripheral)
+				iotg->stop_peripheral(iotg);
+			else
+				dev_dbg(pnw->dev,
+					"client driver has been removed.\n");
+
+			penwell_otg_phy_low_power(0);
+
+			hsm->a_conn = 0;
+			hsm->a_bus_resume = 0;
+
+			if (iotg->start_host) {
+				iotg->start_host(iotg);
+				hsm->test_device = 0;
+
+				/* FIXME: can we allow D3 and D0i3
+				* in B_WAIT_ACON?
+				* Now just disallow it
+				*/
+				/* disallow D3 or D0i3 */
+				pm_runtime_get(pnw->dev);
+				wake_lock(&pnw->wake_lock);
+				iotg->otg.state = OTG_STATE_B_WAIT_ACON;
+				penwell_otg_add_timer(TB_ASE0_BRST_TMR);
+			} else
+				dev_dbg(pnw->dev, "host driver not loaded.\n");
+
+		} else if (hsm->id == ID_ACA_C) {
+			cancel_delayed_work_sync(&pnw->sdp_check_work);
+
+			/* Make sure current limit updated */
+			penwell_otg_update_chrg_cap(CHRG_ACA, CHRG_CURR_ACA);
+		} else if (hsm->id == ID_B) {
+			spin_lock_irqsave(&pnw->charger_lock, flags);
+			type = pnw->psc_cap.chrg_type;
+			spin_unlock_irqrestore(&pnw->charger_lock, flags);
+
+			if (type == POWER_SUPPLY_CHARGER_TYPE_USB_ACA) {
+				/* Notify EM charger ACA removal event */
+				penwell_otg_update_chrg_cap(CHRG_UNKNOWN,
+						CHRG_CURR_DISCONN);
+				penwell_otg_charger_hwdet(false);
+				/* Set current when switch from ACA to SDP */
+				if (!hsm->a_bus_suspend && iotg->otg.set_power)
+					iotg->otg.set_power(&iotg->otg, 500);
+			}
+		}
+		break;
+
+	case OTG_STATE_B_WAIT_ACON:
+		if (hsm->id == ID_A) {
+			/* Move to A_IDLE state, ID changes */
+
+			/* Delete current timer */
+			penwell_otg_del_timer(TB_ASE0_BRST_TMR);
+
+			iotg->otg.otg->default_a = 1;
+			hsm->a_srp_det = 0;
+
+			penwell_otg_HAAR(0);
+
+			PNW_STOP_HOST(pnw);
+
+			set_host_mode();
+
+			/* Always set a_bus_req to 1, in case no ADP */
+			iotg->hsm.a_bus_req = 1;
+
+			iotg->otg.state = OTG_STATE_A_IDLE;
+			penwell_update_transceiver();
+		} else if (!hsm->b_sess_vld || hsm->id == ID_ACA_B) {
+			/* Move to B_IDLE state, VBUS off/ACA */
+
+			if (hsm->id == ID_ACA_B)
+				penwell_otg_update_chrg_cap(CHRG_ACA,
+							CHRG_CURR_ACA);
+			else if (hsm->id == ID_B) {
+				/* Notify EM charger remove event */
+				penwell_otg_update_chrg_cap(CHRG_UNKNOWN,
+							CHRG_CURR_DISCONN);
+			}
+
+			/* Delete current timer */
+			penwell_otg_del_timer(TB_ASE0_BRST_TMR);
+
+			hsm->b_hnp_enable = 0;
+			hsm->b_bus_req = 0;
+			penwell_otg_HAAR(0);
+
+			PNW_STOP_HOST(pnw);
+
+			set_client_mode();
+
+			/* allow D3 and D0i3 */
+			pm_runtime_put(pnw->dev);
+			wake_unlock(&pnw->wake_lock);
+			iotg->otg.state = OTG_STATE_B_IDLE;
+		} else if (hsm->a_conn) {
+			/* Move to B_HOST state, A connected */
+
+			/* Delete current timer */
+			penwell_otg_del_timer(TB_ASE0_BRST_TMR);
+
+			penwell_otg_HAAR(0);
+
+			iotg->otg.state = OTG_STATE_B_HOST;
+			penwell_update_transceiver();
+		} else if (hsm->a_bus_resume || hsm->b_ase0_brst_tmout) {
+			/* Move to B_HOST state, A connected */
+
+			/* Delete current timer */
+			penwell_otg_del_timer(TB_ASE0_BRST_TMR);
+
+			penwell_otg_HAAR(0);
+			penwell_otg_nsf_msg(7);
+
+			PNW_STOP_HOST(pnw);
+
+			hsm->a_bus_suspend = 0;
+			hsm->b_bus_req = 0;
+
+			if (iotg->start_peripheral)
+				iotg->start_peripheral(iotg);
+			else
+				dev_dbg(pnw->dev, "client driver not loaded\n");
+
+			/* allow D3 and D0i3 in A_WAIT_BCON */
+			pm_runtime_put(pnw->dev);
+			wake_unlock(&pnw->wake_lock);
+			iotg->otg.state = OTG_STATE_B_PERIPHERAL;
+		} else if (hsm->id == ID_ACA_C) {
+			/* Make sure current limit updated */
+			penwell_otg_update_chrg_cap(CHRG_ACA, CHRG_CURR_ACA);
+		} else if (hsm->id == ID_B) {
+#if 0
+			/* only set 2ma due to client function stopped */
+			if (iotg->otg.set_power)
+				iotg->otg.set_power(&iotg->otg, 2);
+#endif
+		}
+		break;
+
+	case OTG_STATE_B_HOST:
+		if (hsm->id == ID_A) {
+			iotg->otg.otg->default_a = 1;
+			hsm->a_srp_det = 0;
+
+			/* Stop HNP polling */
+			if (iotg->stop_hnp_poll)
+				iotg->stop_hnp_poll(iotg);
+
+			PNW_STOP_HOST(pnw);
+
+			set_host_mode();
+
+			/* Always set a_bus_req to 1, in case no ADP */
+			hsm->a_bus_req = 1;
+
+			iotg->otg.state = OTG_STATE_A_IDLE;
+			penwell_update_transceiver();
+		} else if (!hsm->b_sess_vld || hsm->id == ID_ACA_B) {
+			/* Move to B_IDLE state, VBUS off/ACA */
+
+			if (hsm->id == ID_ACA_B)
+				penwell_otg_update_chrg_cap(CHRG_ACA,
+							CHRG_CURR_ACA);
+			else if (hsm->id == ID_B) {
+				/* Notify EM charger remove event */
+				penwell_otg_update_chrg_cap(CHRG_UNKNOWN,
+							CHRG_CURR_DISCONN);
+			}
+
+			hsm->b_hnp_enable = 0;
+			hsm->b_bus_req = 0;
+
+			/* Stop HNP polling */
+			if (iotg->stop_hnp_poll)
+				iotg->stop_hnp_poll(iotg);
+
+			PNW_STOP_HOST(pnw);
+
+			set_client_mode();
+
+			/* allow D3 and D0i3 in A_WAIT_BCON */
+			pm_runtime_put(pnw->dev);
+			wake_unlock(&pnw->wake_lock);
+			iotg->otg.state = OTG_STATE_B_IDLE;
+		} else if (!hsm->b_bus_req || !hsm->a_conn
+					|| hsm->test_device) {
+			hsm->b_bus_req = 0;
+
+			/* Stop HNP polling */
+			if (iotg->stop_hnp_poll)
+				iotg->stop_hnp_poll(iotg);
+
+			PNW_STOP_HOST(pnw);
+			hsm->a_bus_suspend = 0;
+
+			/* Clear HNP polling flag */
+			if (iotg->otg.otg->gadget)
+				iotg->otg.otg->gadget->host_request_flag = 0;
+
+			if (iotg->start_peripheral)
+				iotg->start_peripheral(iotg);
+			else
+				dev_dbg(pnw->dev,
+						"client driver not loaded.\n");
+
+			/* allow D3 and D0i3 in A_WAIT_BCON */
+			pm_runtime_put(pnw->dev);
+			wake_unlock(&pnw->wake_lock);
+			iotg->otg.state = OTG_STATE_B_PERIPHERAL;
+		} else if (hsm->id == ID_ACA_C) {
+			/* Make sure current limit updated */
+			penwell_otg_update_chrg_cap(CHRG_ACA, CHRG_CURR_ACA);
+		}
+		break;
+
+	case OTG_STATE_A_IDLE:
+		if (hsm->id == ID_B || hsm->id == ID_ACA_B) {
+			pnw->iotg.otg.otg->default_a = 0;
+			hsm->b_bus_req = 0;
+
+			if (hsm->id == ID_ACA_B)
+				penwell_otg_update_chrg_cap(CHRG_ACA,
+							CHRG_CURR_ACA);
+
+			hsm->b_bus_req = 0;
+
+			set_client_mode();
+
+			iotg->otg.state = OTG_STATE_B_IDLE;
+			penwell_update_transceiver();
+
+			/* Decrement the device usage counter */
+			pm_runtime_put(pnw->dev);
+			wake_unlock(&pnw->wake_lock);
+		} else if (hsm->id == ID_ACA_A) {
+
+			penwell_otg_update_chrg_cap(CHRG_ACA, CHRG_CURR_ACA);
+
+			if (hsm->power_up)
+				hsm->power_up = 0;
+
+			if (hsm->adp_change)
+				hsm->adp_change = 0;
+
+			if (hsm->a_srp_det)
+				hsm->a_srp_det = 0;
+
+			hsm->b_conn = 0;
+			hsm->hnp_poll_enable = 0;
+
+			if (iotg->start_host)
+				iotg->start_host(iotg);
+			else {
+				dev_dbg(pnw->dev, "host driver not loaded.\n");
+				break;
+			}
+
+			/* allow D3 and D0i3 in A_WAIT_BCON */
+			pm_runtime_put(pnw->dev);
+			wake_unlock(&pnw->wake_lock);
+
+			iotg->otg.state = OTG_STATE_A_WAIT_BCON;
+
+		} else if (!hsm->a_bus_drop && (hsm->power_up || hsm->a_bus_req
+				|| hsm->a_srp_det || hsm->adp_change)) {
+			/* power up / adp changes / srp detection should be
+			 * cleared at once after handled. */
+			if (hsm->power_up)
+				hsm->power_up = 0;
+
+			if (hsm->adp_change)
+				hsm->adp_change = 0;
+
+			if (hsm->a_srp_det) {
+				hsm->a_srp_det = 0;
+				/* wait SRP done, then enable VBUS */
+				usleep_range(10000, 11000);
+			}
+
+			otg_set_vbus(iotg->otg.otg, true);
+
+			penwell_otg_add_timer(TA_WAIT_VRISE_TMR);
+
+			iotg->otg.state = OTG_STATE_A_WAIT_VRISE;
+
+			penwell_update_transceiver();
+		} else if (hsm->b_sess_end || hsm->a_sess_vld ||
+				hsm->a_srp_det || !hsm->b_sess_vld) {
+			hsm->a_srp_det = 0;
+			dev_dbg(pnw->dev, "reconfig...\n");
+		}
+		break;
+
+	case OTG_STATE_A_WAIT_VRISE:
+		if (hsm->a_bus_drop ||
+				hsm->id == ID_B || hsm->id == ID_ACA_B) {
+			/* Move to A_WAIT_VFALL, over current/user request */
+
+			/* Delete current timer */
+			penwell_otg_del_timer(TA_WAIT_VRISE_TMR);
+
+			/* Turn off VBUS */
+			otg_set_vbus(iotg->otg.otg, false);
+
+			penwell_otg_add_timer(TA_WAIT_VFALL_TMR);
+			iotg->otg.state = OTG_STATE_A_WAIT_VFALL;
+		} else if (hsm->a_vbus_vld || hsm->a_wait_vrise_tmout
+						|| hsm->id == ID_ACA_A) {
+			/* Move to A_WAIT_BCON state, a vbus vld */
+			/* Delete current timer and clear flags */
+			penwell_otg_del_timer(TA_WAIT_VRISE_TMR);
+
+			if (!hsm->a_vbus_vld) {
+				dev_warn(pnw->dev, "vbus can't rise to vbus vld, overcurrent!\n");
+				/* Turn off VBUS */
+				otg_set_vbus(iotg->otg.otg, false);
+
+				penwell_otg_add_timer(TA_WAIT_VFALL_TMR);
+				iotg->otg.state = OTG_STATE_A_WAIT_VFALL;
+				break;
+			}
+
+			if (hsm->id == ID_ACA_A) {
+				otg_set_vbus(iotg->otg.otg, false);
+
+				penwell_otg_update_chrg_cap(CHRG_ACA,
+							CHRG_CURR_ACA);
+			}
+
+			hsm->a_bus_req = 1;
+			hsm->b_conn = 0;
+			hsm->hnp_poll_enable = 0;
+
+			penwell_otg_eye_diagram_optimize();
+
+			if (iotg->start_host) {
+				dev_dbg(pnw->dev, "host_ops registered!\n");
+				iotg->start_host(iotg);
+			} else {
+				dev_dbg(pnw->dev, "host driver not loaded.\n");
+				break;
+			}
+
+			penwell_otg_add_timer(TA_WAIT_BCON_TMR);
+
+			/* allow D3 and D0i3 in A_WAIT_BCON */
+			pm_runtime_put(pnw->dev);
+			wake_unlock(&pnw->wake_lock);
+			/* at least give some time to USB HOST to enumerate
+			* devices before trying to suspend the system*/
+			wake_lock_timeout(&pnw->wake_lock, 5 * HZ);
+
+			iotg->otg.state = OTG_STATE_A_WAIT_BCON;
+		}
+		break;
+	case OTG_STATE_A_WAIT_BCON:
+		if (hsm->id == ID_B || hsm->id == ID_ACA_B || hsm->a_bus_drop ||
+			hsm->a_wait_bcon_tmout) {
+			/* Move to A_WAIT_VFALL state, user request */
+
+			/* Delete current timer and clear flags for B-Device */
+			penwell_otg_del_timer(TA_WAIT_BCON_TMR);
+
+			hsm->b_bus_req = 0;
+
+			PNW_STOP_HOST(pnw);
+
+			/* Turn off VBUS */
+			otg_set_vbus(iotg->otg.otg, false);
+
+			penwell_otg_add_timer(TA_WAIT_VFALL_TMR);
+
+			/* disallow D3 or D0i3 */
+			pm_runtime_get(pnw->dev);
+			wake_lock(&pnw->wake_lock);
+			iotg->otg.state = OTG_STATE_A_WAIT_VFALL;
+		} else if (!hsm->a_vbus_vld) {
+			/* Move to A_VBUS_ERR state, over-current detected */
+
+			/* CTP SW Workaround, add 300ms debouce on VBUS drop */
+			if (is_clovertrail(pdev)) {
+				msleep(300);
+				if (hsm->a_vbus_vld)
+					break;
+			}
+
+			/* Notify user space for vbus invalid event */
+			penwell_otg_notify_warning(USB_WARNING_VBUS_INVALID);
+
+			/* Delete current timer and disable host function */
+			penwell_otg_del_timer(TA_WAIT_BCON_TMR);
+
+			PNW_STOP_HOST(pnw);
+
+			/* Turn off VBUS and enter PHY low power mode */
+			otg_set_vbus(iotg->otg.otg, false);
+
+			/* disallow D3 or D0i3 */
+			pm_runtime_get(pnw->dev);
+			wake_lock(&pnw->wake_lock);
+			iotg->otg.state = OTG_STATE_A_VBUS_ERR;
+		} else if (hsm->b_conn) {
+			/* Move to A_HOST state, device connected */
+
+			/* Delete current timer and disable host function */
+			penwell_otg_del_timer(TA_WAIT_BCON_TMR);
+
+			/* Start HNP polling */
+			if (iotg->start_hnp_poll)
+				iotg->start_hnp_poll(iotg);
+
+			if (!hsm->a_bus_req)
+				hsm->a_bus_req = 1;
+
+			if (hsm->test_device)
+				penwell_otg_add_timer(TTST_MAINT_TMR);
+
+			iotg->otg.state = OTG_STATE_A_HOST;
+		} else if (hsm->id == ID_ACA_A) {
+			penwell_otg_update_chrg_cap(CHRG_ACA, CHRG_CURR_ACA);
+
+			/* Turn off VBUS */
+			otg_set_vbus(iotg->otg.otg, false);
+		}
+		break;
+
+	case OTG_STATE_A_HOST:
+		if (hsm->id == ID_B || hsm->id == ID_ACA_B || hsm->a_bus_drop) {
+			/* Move to A_WAIT_VFALL state, timeout/user request */
+
+			/* Delete current timer and clear flags */
+			if (hsm->test_device) {
+				hsm->test_device = 0;
+				penwell_otg_del_timer(TTST_MAINT_TMR);
+			}
+
+			if (hsm->id == ID_ACA_B)
+				penwell_otg_update_chrg_cap(CHRG_ACA,
+							CHRG_CURR_ACA);
+
+			/* Stop HNP polling */
+			if (iotg->stop_hnp_poll)
+				iotg->stop_hnp_poll(iotg);
+
+			penwell_otg_phy_low_power(0);
+
+			PNW_STOP_HOST(pnw);
+
+			/* Turn off VBUS */
+			otg_set_vbus(iotg->otg.otg, false);
+
+			penwell_otg_add_timer(TA_WAIT_VFALL_TMR);
+
+			/* disallow D3 or D0i3 */
+			pm_runtime_get(pnw->dev);
+			wake_lock(&pnw->wake_lock);
+			iotg->otg.state = OTG_STATE_A_WAIT_VFALL;
+		} else if (hsm->test_device && hsm->tst_maint_tmout) {
+
+			hsm->test_device = 0;
+
+			/* Stop HNP polling */
+			if (iotg->stop_hnp_poll)
+				iotg->stop_hnp_poll(iotg);
+
+			penwell_otg_phy_low_power(0);
+
+			PNW_STOP_HOST(pnw);
+
+			/* Turn off VBUS */
+			otg_set_vbus(iotg->otg.otg, false);
+
+			/* Clear states and wait for SRP */
+			hsm->a_srp_det = 0;
+			hsm->a_bus_req = 0;
+
+			/* disallow D3 or D0i3 */
+			pm_runtime_get(pnw->dev);
+			wake_lock(&pnw->wake_lock);
+			iotg->otg.state = OTG_STATE_A_IDLE;
+		} else if (!hsm->a_vbus_vld) {
+			/* Move to A_VBUS_ERR state */
+
+			/* CTP SW Workaround, add 300ms debouce on VBUS drop */
+			if (is_clovertrail(pdev)) {
+				msleep(300);
+				if (hsm->a_vbus_vld)
+					break;
+			}
+
+			/* Notify user space for vbus invalid event */
+			penwell_otg_notify_warning(USB_WARNING_VBUS_INVALID);
+
+			/* Delete current timer and clear flags */
+			if (hsm->test_device) {
+				hsm->test_device = 0;
+				penwell_otg_del_timer(TTST_MAINT_TMR);
+			}
+
+			/* Stop HNP polling */
+			if (iotg->stop_hnp_poll)
+				iotg->stop_hnp_poll(iotg);
+
+			PNW_STOP_HOST(pnw);
+
+			/* Turn off VBUS */
+			otg_set_vbus(iotg->otg.otg, false);
+
+			/* disallow D3 or D0i3 */
+			pm_runtime_get(pnw->dev);
+			wake_lock(&pnw->wake_lock);
+			iotg->otg.state = OTG_STATE_A_VBUS_ERR;
+		} else if (!hsm->a_bus_req &&
+			   iotg->otg.otg->host->b_hnp_enable) {
+			/* Move to A_SUSPEND state */
+
+			/* Stop HNP polling */
+			if (iotg->stop_hnp_poll)
+				iotg->stop_hnp_poll(iotg);
+
+			/* According to Spec 7.1.5 */
+			penwell_otg_add_timer(TA_AIDL_BDIS_TMR);
+
+			/* Set HABA to enable hardware assistance to
+			 * signal A-connect after receiver B-disconnect
+			 * Hardware will then set client mode and
+			 * enable URE, SLE and PCE after the assistance
+			 * otg_dummy_irq is used to clean these ints
+			 * when client driver is not resumed.
+			 */
+			if (request_irq(pdev->irq, otg_dummy_irq,
+					IRQF_SHARED, driver_name,
+					iotg->base) != 0) {
+					dev_dbg(pnw->dev,
+					"request interrupt %d failed\n",
+					pdev->irq);
+			}
+			penwell_otg_HABA(1);
+
+			penwell_otg_loc_sof(0);
+			penwell_otg_phy_low_power(0);
+
+			/* disallow D3 or D0i3 */
+			pm_runtime_get(pnw->dev);
+			wake_lock(&pnw->wake_lock);
+			iotg->otg.state = OTG_STATE_A_SUSPEND;
+		} else if (!hsm->b_conn && hsm->test_device
+						&& hsm->otg_vbus_off) {
+			/* If it is a test device with otg_vbus_off bit set,
+			 * turn off VBUS on disconnect event and stay for
+			 * TTST_NOADP without ADP */
+
+			penwell_otg_del_timer(TTST_MAINT_TMR);
+
+			/* Stop HNP polling */
+			if (iotg->stop_hnp_poll)
+				iotg->stop_hnp_poll(iotg);
+
+			penwell_otg_phy_low_power(0);
+
+			PNW_STOP_HOST(pnw);
+
+			/* Turn off VBUS */
+			otg_set_vbus(iotg->otg.otg, false);
+
+			penwell_otg_add_timer(TTST_NOADP_TMR);
+
+			/* disallow D3 or D0i3 */
+			pm_runtime_get(pnw->dev);
+			wake_lock(&pnw->wake_lock);
+			iotg->otg.state = OTG_STATE_A_WAIT_VFALL;
+
+		} else if (!hsm->b_conn) {
+
+			/* Delete current timer and clear flags */
+			if (hsm->test_device) {
+				hsm->test_device = 0;
+				penwell_otg_del_timer(TTST_MAINT_TMR);
+			}
+
+			/* Stop HNP polling */
+			if (iotg->stop_hnp_poll)
+				iotg->stop_hnp_poll(iotg);
+
+			/* add kernel timer */
+			iotg->otg.state = OTG_STATE_A_WAIT_BCON;
+		} else if (hsm->id == ID_ACA_A) {
+			penwell_otg_update_chrg_cap(CHRG_ACA, CHRG_CURR_ACA);
+
+			/* Turn off VBUS */
+			otg_set_vbus(iotg->otg.otg, false);
+		} else if (hsm->id == ID_A) {
+			/* Turn on VBUS */
+			otg_set_vbus(iotg->otg.otg, true);
+		}
+		break;
+
+	case OTG_STATE_A_SUSPEND:
+		if (hsm->id == ID_B || hsm->id == ID_ACA_B ||
+				hsm->a_bus_drop || hsm->a_aidl_bdis_tmout) {
+			/* Move to A_WAIT_VFALL state, timeout/user request */
+			penwell_otg_HABA(0);
+			free_irq(pdev->irq, iotg->base);
+
+			/* Delete current timer and clear HW assist */
+			if (hsm->a_aidl_bdis_tmout)
+				hsm->a_aidl_bdis_tmout = 0;
+			penwell_otg_del_timer(TA_AIDL_BDIS_TMR);
+
+			if (hsm->id == ID_ACA_B)
+				penwell_otg_update_chrg_cap(CHRG_ACA,
+							CHRG_CURR_ACA);
+
+			/* Stop HNP polling */
+			if (iotg->stop_hnp_poll)
+				iotg->stop_hnp_poll(iotg);
+
+			PNW_STOP_HOST(pnw);
+
+			/* Turn off VBUS */
+			otg_set_vbus(iotg->otg.otg, false);
+
+			penwell_otg_add_timer(TA_WAIT_VFALL_TMR);
+			iotg->otg.state = OTG_STATE_A_WAIT_VFALL;
+		} else if (!hsm->a_vbus_vld) {
+			/* Move to A_VBUS_ERR state, Over-current */
+			penwell_otg_HABA(0);
+			free_irq(pdev->irq, iotg->base);
+
+			/* Delete current timer and clear flags */
+			penwell_otg_del_timer(TA_AIDL_BDIS_TMR);
+
+			PNW_STOP_HOST(pnw);
+
+			/* Turn off VBUS */
+			otg_set_vbus(iotg->otg.otg, false);
+			iotg->otg.state = OTG_STATE_A_VBUS_ERR;
+		} else if (!hsm->b_conn &&
+			   !pnw->iotg.otg.otg->host->b_hnp_enable) {
+			/* Move to A_WAIT_BCON */
+
+			/* delete current timer */
+			penwell_otg_del_timer(TA_AIDL_BDIS_TMR);
+
+			/* add kernel timer */
+			penwell_otg_add_timer(TA_WAIT_BCON_TMR);
+
+			/* allow D3 and D0i3 in A_WAIT_BCON */
+			pm_runtime_put(pnw->dev);
+			wake_unlock(&pnw->wake_lock);
+			iotg->otg.state = OTG_STATE_A_WAIT_BCON;
+		} else if (!hsm->b_conn &&
+			   pnw->iotg.otg.otg->host->b_hnp_enable) {
+			/* Move to A_PERIPHERAL state, HNP */
+			penwell_otg_HABA(0);
+			free_irq(pdev->irq, iotg->base);
+
+			/* Delete current timer and clear flags */
+			penwell_otg_del_timer(TA_AIDL_BDIS_TMR);
+			penwell_otg_phy_low_power(0);
+
+			PNW_STOP_HOST(pnw);
+
+			penwell_otg_phy_low_power(0);
+			hsm->b_bus_suspend = 0;
+
+			/* Clear HNP polling flag */
+			if (iotg->otg.otg->gadget)
+				iotg->otg.otg->gadget->host_request_flag = 0;
+
+			penwell_otg_phy_low_power(0);
+
+			if (iotg->start_peripheral)
+				iotg->start_peripheral(iotg);
+			else
+				dev_dbg(pnw->dev,
+						"client driver not loaded.\n");
+
+			penwell_otg_add_timer(TA_BIDL_ADIS_TMR);
+			iotg->otg.state = OTG_STATE_A_PERIPHERAL;
+		} else if (hsm->a_bus_req) {
+			/* Move to A_HOST state, user request */
+			penwell_otg_HABA(0);
+			free_irq(pdev->irq, iotg->base);
+
+			/* Delete current timer and clear flags */
+			penwell_otg_del_timer(TA_AIDL_BDIS_TMR);
+
+			penwell_otg_loc_sof(1);
+
+			/* Start HNP polling */
+			if (iotg->start_hnp_poll)
+				iotg->start_hnp_poll(iotg);
+
+			/* allow D3 and D0i3 in A_HOST */
+			pm_runtime_put(pnw->dev);
+			wake_unlock(&pnw->wake_lock);
+			iotg->otg.state = OTG_STATE_A_HOST;
+		} else if (hsm->id == ID_ACA_A) {
+			penwell_otg_update_chrg_cap(CHRG_ACA, CHRG_CURR_ACA);
+
+			/* Turn off VBUS */
+			otg_set_vbus(iotg->otg.otg, false);
+		}
+		break;
+	case OTG_STATE_A_PERIPHERAL:
+		if (hsm->id == ID_B || hsm->a_bus_drop) {
+			/* Move to A_WAIT_VFALL state */
+
+			/* Delete current timer and clear flags */
+			penwell_otg_del_timer(TA_BIDL_ADIS_TMR);
+
+			if (iotg->stop_peripheral)
+				iotg->stop_peripheral(iotg);
+			else
+				dev_dbg(pnw->dev,
+					"client driver has been removed.\n");
+
+			/* Turn off VBUS */
+			otg_set_vbus(iotg->otg.otg, false);
+			set_host_mode();
+
+			penwell_otg_add_timer(TA_WAIT_VFALL_TMR);
+			iotg->otg.state = OTG_STATE_A_WAIT_VFALL;
+		} else if (!hsm->a_vbus_vld) {
+			/* Move to A_VBUS_ERR state, over-current detected */
+
+			/* Delete current timer and disable client function */
+			penwell_otg_del_timer(TA_BIDL_ADIS_TMR);
+
+			if (iotg->stop_peripheral)
+				iotg->stop_peripheral(iotg);
+			else
+				dev_dbg(pnw->dev,
+					"client driver has been removed.\n");
+
+			/* Turn off the VBUS and enter PHY low power mode */
+			otg_set_vbus(iotg->otg.otg, false);
+
+			iotg->otg.state = OTG_STATE_A_VBUS_ERR;
+		} else if (hsm->a_bidl_adis_tmout) {
+			/* Move to A_WAIT_BCON state */
+			hsm->a_bidl_adis_tmr = 0;
+
+			msleep(10);
+			penwell_otg_phy_low_power(0);
+
+			/* Disable client function and switch to host mode */
+			if (iotg->stop_peripheral)
+				iotg->stop_peripheral(iotg);
+			else
+				dev_dbg(pnw->dev,
+					"client driver has been removed.\n");
+
+			hsm->hnp_poll_enable = 0;
+			hsm->b_conn = 0;
+
+			penwell_otg_phy_low_power(0);
+
+			if (iotg->start_host)
+				iotg->start_host(iotg);
+			else
+				dev_dbg(pnw->dev,
+						"host driver not loaded.\n");
+
+			penwell_otg_add_timer(TA_WAIT_BCON_TMR);
+
+			/* allow D3 and D0i3 in A_WAIT_BCON */
+			pm_runtime_put(pnw->dev);
+			wake_unlock(&pnw->wake_lock);
+			iotg->otg.state = OTG_STATE_A_WAIT_BCON;
+		} else if (hsm->id == ID_A && hsm->b_bus_suspend) {
+			if (!timer_pending(&pnw->hsm_timer))
+				penwell_otg_add_timer(TA_BIDL_ADIS_TMR);
+		} else if (hsm->id == ID_A && !hsm->b_bus_suspend) {
+			penwell_otg_del_timer(TA_BIDL_ADIS_TMR);
+		} else if (hsm->id == ID_ACA_A) {
+			penwell_otg_update_chrg_cap(CHRG_ACA, CHRG_CURR_ACA);
+
+			/* Turn off VBUS */
+			otg_set_vbus(iotg->otg.otg, false);
+		}
+		break;
+	case OTG_STATE_A_VBUS_ERR:
+		if (hsm->id == ID_B || hsm->id == ID_ACA_B ||
+			hsm->id == ID_ACA_A || hsm->a_bus_drop ||
+						hsm->a_clr_err) {
+			if (hsm->a_clr_err)
+				hsm->a_clr_err = 0;
+
+			penwell_otg_add_timer(TA_WAIT_VFALL_TMR);
+			iotg->otg.state = OTG_STATE_A_WAIT_VFALL;
+		}
+		break;
+	case OTG_STATE_A_WAIT_VFALL:
+		if (hsm->a_wait_vfall_tmout) {
+			hsm->a_srp_det = 0;
+			hsm->a_wait_vfall_tmout = 0;
+
+			/* Move to A_IDLE state, vbus falls */
+			/* Always set a_bus_req to 1, in case no ADP */
+			hsm->a_bus_req = 1;
+
+			iotg->otg.state = OTG_STATE_A_IDLE;
+			penwell_update_transceiver();
+		} else if (hsm->test_device && hsm->otg_vbus_off
+					&& hsm->tst_noadp_tmout) {
+			/* After noadp timeout, switch back to normal mode */
+			hsm->test_device = 0;
+			hsm->otg_vbus_off = 0;
+			hsm->tst_noadp_tmout = 0;
+
+			hsm->a_bus_req = 1;
+
+			iotg->otg.state = OTG_STATE_A_IDLE;
+			penwell_update_transceiver();
+		}
+		break;
+	default:
+		break;
+		;
+	}
+
+	pm_runtime_put_sync(pnw->dev);
+
+	dev_dbg(pnw->dev,
+			"new state = %s\n", state_string(iotg->otg.state));
+}
+
+static ssize_t
+show_registers(struct device *_dev, struct device_attribute *attr, char *buf)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	char			*next;
+	unsigned		size;
+	unsigned		t;
+
+	next = buf;
+	size = PAGE_SIZE;
+
+	pm_runtime_get_sync(pnw->dev);
+
+	t = scnprintf(next, size,
+		"\n"
+		"USBCMD = 0x%08x\n"
+		"USBSTS = 0x%08x\n"
+		"USBINTR = 0x%08x\n"
+		"ASYNCLISTADDR = 0x%08x\n"
+		"PORTSC1 = 0x%08x\n"
+		"HOSTPC1 = 0x%08x\n"
+		"OTGSC = 0x%08x\n"
+		"USBMODE = 0x%08x\n",
+		readl(pnw->iotg.base + 0x30),
+		readl(pnw->iotg.base + 0x34),
+		readl(pnw->iotg.base + 0x38),
+		readl(pnw->iotg.base + 0x48),
+		readl(pnw->iotg.base + 0x74),
+		readl(pnw->iotg.base + 0xb4),
+		readl(pnw->iotg.base + 0xf4),
+		readl(pnw->iotg.base + 0xf8)
+		);
+
+	pm_runtime_put_sync(pnw->dev);
+
+	size -= t;
+	next += t;
+
+	return PAGE_SIZE - size;
+}
+static DEVICE_ATTR(registers, S_IRUGO, show_registers, NULL);
+
+static ssize_t
+show_hsm(struct device *_dev, struct device_attribute *attr, char *buf)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	char				*next;
+	unsigned			size, t;
+
+	next = buf;
+	size = PAGE_SIZE;
+
+	if (iotg->otg.otg->host)
+		iotg->hsm.a_set_b_hnp_en = iotg->otg.otg->host->b_hnp_enable;
+
+	if (iotg->otg.otg->gadget)
+		iotg->hsm.b_hnp_enable = iotg->otg.otg->gadget->b_hnp_enable;
+
+	t = scnprintf(next, size,
+		"\n"
+		"current state = %s\n"
+		"a_bus_resume = \t%d\n"
+		"a_bus_suspend = \t%d\n"
+		"a_conn = \t%d\n"
+		"a_sess_vld = \t%d\n"
+		"a_srp_det = \t%d\n"
+		"a_vbus_vld = \t%d\n"
+		"b_bus_suspend = \t%d\n"
+		"b_conn = \t%d\n"
+		"b_se0_srp = \t%d\n"
+		"b_ssend_srp = \t%d\n"
+		"b_sess_end = \t%d\n"
+		"b_sess_vld = \t%d\n"
+		"id = \t%d\n"
+		"power_up = \t%d\n"
+		"adp_change = \t%d\n"
+		"test_device = \t%d\n"
+		"a_set_b_hnp_en = \t%d\n"
+		"b_srp_done = \t%d\n"
+		"b_hnp_enable = \t%d\n"
+		"hnp_poll_enable = \t%d\n"
+		"a_wait_vrise_tmout = \t%d\n"
+		"a_wait_bcon_tmout = \t%d\n"
+		"a_aidl_bdis_tmout = \t%d\n"
+		"a_bidl_adis_tmout = \t%d\n"
+		"a_bidl_adis_tmr = \t%d\n"
+		"a_wait_vfall_tmout = \t%d\n"
+		"b_ase0_brst_tmout = \t%d\n"
+		"b_srp_fail_tmout = \t%d\n"
+		"b_srp_fail_tmr = \t%d\n"
+		"b_adp_sense_tmout = \t%d\n"
+		"tst_maint_tmout = \t%d\n"
+		"tst_noadp_tmout = \t%d\n"
+		"a_bus_drop = \t%d\n"
+		"a_bus_req = \t%d\n"
+		"a_clr_err = \t%d\n"
+		"b_bus_req = \t%d\n"
+		"ulpi_error = \t%d\n"
+		"ulpi_polling = \t%d\n",
+		state_string(iotg->otg.state),
+		iotg->hsm.a_bus_resume,
+		iotg->hsm.a_bus_suspend,
+		iotg->hsm.a_conn,
+		iotg->hsm.a_sess_vld,
+		iotg->hsm.a_srp_det,
+		iotg->hsm.a_vbus_vld,
+		iotg->hsm.b_bus_suspend,
+		iotg->hsm.b_conn,
+		iotg->hsm.b_se0_srp,
+		iotg->hsm.b_ssend_srp,
+		iotg->hsm.b_sess_end,
+		iotg->hsm.b_sess_vld,
+		iotg->hsm.id,
+		iotg->hsm.power_up,
+		iotg->hsm.adp_change,
+		iotg->hsm.test_device,
+		iotg->hsm.a_set_b_hnp_en,
+		iotg->hsm.b_srp_done,
+		iotg->hsm.b_hnp_enable,
+		iotg->hsm.hnp_poll_enable,
+		iotg->hsm.a_wait_vrise_tmout,
+		iotg->hsm.a_wait_bcon_tmout,
+		iotg->hsm.a_aidl_bdis_tmout,
+		iotg->hsm.a_bidl_adis_tmout,
+		iotg->hsm.a_bidl_adis_tmr,
+		iotg->hsm.a_wait_vfall_tmout,
+		iotg->hsm.b_ase0_brst_tmout,
+		iotg->hsm.b_srp_fail_tmout,
+		iotg->hsm.b_srp_fail_tmr,
+		iotg->hsm.b_adp_sense_tmout,
+		iotg->hsm.tst_maint_tmout,
+		iotg->hsm.tst_noadp_tmout,
+		iotg->hsm.a_bus_drop,
+		iotg->hsm.a_bus_req,
+		iotg->hsm.a_clr_err,
+		iotg->hsm.b_bus_req,
+		iotg->hsm.ulpi_error,
+		iotg->hsm.ulpi_polling
+		);
+	size -= t;
+	next += t;
+
+	return PAGE_SIZE - size;
+}
+static DEVICE_ATTR(hsm, S_IRUGO, show_hsm, NULL);
+
+static ssize_t
+show_chargers(struct device *_dev, struct device_attribute *attr, char *buf)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	char				*next;
+	unsigned			size, t;
+	enum usb_charger_type		type;
+	unsigned int			ma;
+	unsigned long			flags;
+	struct pci_dev			*pdev;
+	struct power_supply_cable_props	psc_cap;
+
+	pdev = to_pci_dev(pnw->dev);
+
+	next = buf;
+	size = PAGE_SIZE;
+
+	if (!is_clovertrail(pdev)) {
+		spin_lock_irqsave(&pnw->charger_lock, flags);
+		type = pnw->charging_cap.chrg_type;
+		ma = pnw->charging_cap.ma;
+		spin_unlock_irqrestore(&pnw->charger_lock, flags);
+
+		t = scnprintf(next, size,
+			"USB Battery Charging Capability\n"
+			"\tUSB Charger Type:  %s\n"
+			"\tMax Charging Current:  %u\n",
+			charger_string(type),
+			ma
+		);
+	} else {
+		spin_lock_irqsave(&pnw->charger_lock, flags);
+		psc_cap = pnw->psc_cap;
+		spin_unlock_irqrestore(&pnw->charger_lock, flags);
+
+		t = scnprintf(next, size,
+			"USB Battery Charging Capability(CLV)\n"
+			"\tUSB Charger Type:  %s\n"
+			"\tMax Charging Current:  %u\n",
+			psc_string(psc_cap.chrg_type),
+			psc_cap.ma
+		);
+
+	}
+	size -= t;
+	next += t;
+
+	return PAGE_SIZE - size;
+}
+static DEVICE_ATTR(chargers, S_IRUGO, show_chargers, NULL);
+
+static ssize_t
+get_a_bus_req(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	char			*next;
+	unsigned		size, t;
+
+	next = buf;
+	size = PAGE_SIZE;
+
+	t = scnprintf(next, size, "%d", pnw->iotg.hsm.a_bus_req);
+	size -= t;
+	next += t;
+
+	return PAGE_SIZE - size;
+}
+
+static ssize_t
+set_a_bus_req(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+
+	if (!iotg->otg.otg->default_a)
+		return -1;
+	if (count > 2)
+		return -1;
+
+	if (buf[0] == '0') {
+		iotg->hsm.a_bus_req = 0;
+		dev_dbg(pnw->dev, "a_bus_req = 0\n");
+	} else if (buf[0] == '1') {
+		/* If a_bus_drop is TRUE, a_bus_req can't be set */
+		if (iotg->hsm.a_bus_drop)
+			return -1;
+		iotg->hsm.a_bus_req = 1;
+		dev_dbg(pnw->dev, "a_bus_req = 1\n");
+		if (iotg->otg.state == OTG_STATE_A_PERIPHERAL) {
+			dev_warn(pnw->dev, "Role switch will be "
+				"performed soon, if connected OTG device "
+				"supports role switch request.\n");
+			dev_warn(pnw->dev, "It may cause data"
+				"corruption during data transfer\n");
+		}
+	}
+
+	penwell_update_transceiver();
+
+	return count;
+}
+static DEVICE_ATTR(a_bus_req, S_IRUGO | S_IWUSR | S_IWGRP,
+				   get_a_bus_req, set_a_bus_req);
+
+static ssize_t
+get_a_bus_drop(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	char			*next;
+	unsigned		size;
+	unsigned		t;
+
+	next = buf;
+	size = PAGE_SIZE;
+
+	t = scnprintf(next, size, "%d", pnw->iotg.hsm.a_bus_drop);
+	size -= t;
+	next += t;
+
+	return PAGE_SIZE - size;
+}
+
+static ssize_t
+set_a_bus_drop(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+
+	if (!iotg->otg.otg->default_a)
+		return -1;
+	if (count > 2)
+		return -1;
+
+	if (buf[0] == '0') {
+		iotg->hsm.a_bus_drop = 0;
+		dev_dbg(pnw->dev, "a_bus_drop = 0\n");
+	} else if (buf[0] == '1') {
+		iotg->hsm.a_bus_drop = 1;
+		iotg->hsm.a_bus_req = 0;
+		dev_dbg(pnw->dev, "a_bus_drop = 1, so a_bus_req = 0\n");
+	}
+
+	penwell_update_transceiver();
+
+	return count;
+}
+static DEVICE_ATTR(a_bus_drop, S_IRUGO | S_IWUSR | S_IWGRP,
+	get_a_bus_drop, set_a_bus_drop);
+
+static ssize_t
+get_b_bus_req(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	char			*next;
+	unsigned		size;
+	unsigned		t;
+
+	next = buf;
+	size = PAGE_SIZE;
+
+	t = scnprintf(next, size, "%d", pnw->iotg.hsm.b_bus_req);
+	size -= t;
+	next += t;
+
+	return PAGE_SIZE - size;
+}
+
+static ssize_t
+set_b_bus_req(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+
+	if (iotg->otg.otg->default_a)
+		return -1;
+
+	if (count > 2)
+		return -1;
+
+	if (buf[0] == '0') {
+		iotg->hsm.b_bus_req = 0;
+		dev_dbg(pnw->dev, "b_bus_req = 0\n");
+
+		if (iotg->otg.otg->gadget)
+			iotg->otg.otg->gadget->host_request_flag = 0;
+	} else if (buf[0] == '1') {
+		iotg->hsm.b_bus_req = 1;
+		dev_dbg(pnw->dev, "b_bus_req = 1\n");
+
+		if (iotg->otg.state == OTG_STATE_B_PERIPHERAL) {
+			if (iotg->otg.otg->gadget)
+				iotg->otg.otg->gadget->host_request_flag = 1;
+
+			dev_warn(pnw->dev, "Role switch will be "
+				"performed soon, if connected OTG device "
+				"supports role switch request.\n");
+			dev_warn(pnw->dev, "It may cause data "
+				"corruption during data transfer\n");
+		}
+	}
+
+	penwell_update_transceiver();
+
+	return count;
+}
+static DEVICE_ATTR(b_bus_req, S_IRUGO | S_IWUSR | S_IWGRP,
+				   get_b_bus_req, set_b_bus_req);
+
+static ssize_t
+set_a_clr_err(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+
+	if (!iotg->otg.otg->default_a)
+		return -1;
+	if (iotg->otg.state != OTG_STATE_A_VBUS_ERR)
+		return -1;
+	if (count > 2)
+		return -1;
+
+	if (buf[0] == '1') {
+		iotg->hsm.a_clr_err = 1;
+		dev_dbg(pnw->dev, "a_clr_err = 1\n");
+	}
+
+	penwell_update_transceiver();
+
+	return count;
+}
+static DEVICE_ATTR(a_clr_err, S_IRUGO | S_IWUSR | S_IWGRP, NULL, set_a_clr_err);
+
+static ssize_t
+set_ulpi_err(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+
+	dev_dbg(pnw->dev, "trigger ulpi error manually\n");
+
+	iotg->hsm.ulpi_error = 1;
+
+	penwell_update_transceiver();
+
+	return count;
+}
+static DEVICE_ATTR(ulpi_err, S_IRUGO | S_IWUSR | S_IWGRP, NULL, set_ulpi_err);
+
+static struct attribute *inputs_attrs[] = {
+	&dev_attr_a_bus_req.attr,
+	&dev_attr_a_bus_drop.attr,
+	&dev_attr_b_bus_req.attr,
+	&dev_attr_a_clr_err.attr,
+	&dev_attr_ulpi_err.attr,
+	NULL,
+};
+
+static struct attribute_group debug_dev_attr_group = {
+	.name = "inputs",
+	.attrs = inputs_attrs,
+};
+
+static int penwell_otg_aca_enable(void)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	int				retval = 0;
+	struct pci_dev			*pdev;
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+
+	pdev = to_pci_dev(pnw->dev);
+
+	if (!is_clovertrail(pdev)) {
+		penwell_otg_msic_spi_access(true);
+
+		retval = intel_scu_ipc_update_register(SPI_TI_VS4,
+				TI_ACA_DET_EN, TI_ACA_DET_EN);
+		if (retval)
+			goto done;
+
+		retval = intel_scu_ipc_update_register(SPI_TI_VS5,
+				TI_ID_FLOAT_EN | TI_ID_RES_EN,
+				TI_ID_FLOAT_EN | TI_ID_RES_EN);
+		if (retval)
+			goto done;
+	} else {
+		retval = penwell_otg_ulpi_write(iotg, ULPI_VS4SET,
+				ACADET);
+		if (retval)
+			goto done;
+
+		retval = penwell_otg_ulpi_write(iotg, ULPI_VS5SET,
+				IDFLOAT_EN | IDRES_EN);
+	}
+done:
+	if (!is_clovertrail(pdev))
+		penwell_otg_msic_spi_access(false);
+
+	if (retval)
+		dev_warn(pnw->dev, "Failed to enable ACA device detection\n");
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+
+	return retval;
+}
+
+static int penwell_otg_aca_disable(void)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	int				retval = 0;
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+
+	retval = penwell_otg_ulpi_write(iotg, ULPI_VS5CLR,
+			IDFLOAT_EN | IDRES_EN);
+	if (retval)
+		goto done;
+
+	retval = penwell_otg_ulpi_write(iotg, ULPI_VS4CLR,
+			ACADET);
+
+done:
+	if (retval)
+		dev_warn(pnw->dev, "Failed to disable ACA device detection\n");
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+
+	return retval;
+}
+
+static void penwell_spi_reset_phy(void)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+
+	dev_dbg(pnw->dev, "Reset Phy over SPI\n");
+	penwell_otg_msic_spi_access(true);
+	penwell_otg_msic_write(MSIC_FUNCTRLSET, PHYRESET);
+	penwell_otg_msic_spi_access(false);
+	dev_dbg(pnw->dev, "Reset Phy over SPI Done\n");
+}
+
+static int penwell_otg_probe(struct pci_dev *pdev,
+		const struct pci_device_id *id)
+{
+	unsigned long		resource, len;
+	void __iomem		*base = NULL;
+	int			retval;
+	u32			val32;
+	struct penwell_otg	*pnw;
+	char			qname[] = "penwell_otg_queue";
+	char			chrg_qname[] = "penwell_otg_chrg_queue";
+
+	retval = 0;
+
+	dev_info(&pdev->dev, "Intel OTG2.0 controller is detected.\n");
+	dev_info(&pdev->dev, "Driver version: " DRIVER_VERSION "\n");
+
+	if (pci_enable_device(pdev) < 0) {
+		retval = -ENODEV;
+		goto done;
+	}
+
+	pnw = kzalloc(sizeof(*pnw), GFP_KERNEL);
+	if (pnw == NULL) {
+		retval = -ENOMEM;
+		goto done;
+	}
+	the_transceiver = pnw;
+
+	/* control register: BAR 0 */
+	resource = pci_resource_start(pdev, 0);
+	len = pci_resource_len(pdev, 0);
+	if (!request_mem_region(resource, len, driver_name)) {
+		retval = -EBUSY;
+		goto err;
+	}
+	pnw->region = 1;
+
+	base = ioremap_nocache(resource, len);
+	if (base == NULL) {
+		retval = -EFAULT;
+		goto err;
+	}
+	pnw->iotg.base = base;
+
+	if (!request_mem_region(USBCFG_ADDR, USBCFG_LEN, driver_name)) {
+		retval = -EBUSY;
+		goto err;
+	}
+	pnw->cfg_region = 1;
+
+	if (!pdev->irq) {
+		dev_dbg(&pdev->dev, "No IRQ.\n");
+		retval = -ENODEV;
+		goto err;
+	}
+
+	pnw->qwork = create_singlethread_workqueue(qname);
+	if (!pnw->qwork) {
+		dev_dbg(&pdev->dev, "cannot create workqueue %s\n", qname);
+		retval = -ENOMEM;
+		goto err;
+	}
+
+	pnw->chrg_qwork = create_singlethread_workqueue(chrg_qname);
+	if (!pnw->chrg_qwork) {
+		dev_dbg(&pdev->dev, "cannot create workqueue %s\n", chrg_qname);
+		retval = -ENOMEM;
+		goto err;
+	}
+
+	INIT_LIST_HEAD(&pnw->chrg_evt_queue);
+	INIT_WORK(&pnw->work, penwell_otg_work);
+	INIT_WORK(&pnw->psc_notify, penwell_otg_psc_notify_work);
+	INIT_WORK(&pnw->hnp_poll_work, penwell_otg_hnp_poll_work);
+	INIT_WORK(&pnw->uevent_work, penwell_otg_uevent_work);
+	INIT_DELAYED_WORK(&pnw->ulpi_poll_work, penwell_otg_ulpi_poll_work);
+	INIT_DELAYED_WORK(&pnw->ulpi_check_work, penwell_otg_ulpi_check_work);
+	INIT_DELAYED_WORK(&pnw->sdp_check_work, penwell_otg_sdp_check_work);
+
+	/* OTG common part */
+	pnw->dev = &pdev->dev;
+	pnw->iotg.otg.dev = &pdev->dev;
+	pnw->iotg.otg.label = driver_name;
+	pnw->iotg.otg.otg = kzalloc(sizeof(struct usb_otg), GFP_KERNEL);
+	if (!pnw->iotg.otg.otg) {
+		retval = -ENOMEM;
+		goto err;
+	}
+	pnw->iotg.otg.otg->set_host = penwell_otg_set_host;
+	pnw->iotg.otg.otg->set_peripheral = penwell_otg_set_peripheral;
+	pnw->iotg.otg.set_power = penwell_otg_set_power;
+	pnw->iotg.otg.otg->set_vbus =  penwell_otg_set_vbus;
+	pnw->iotg.otg.otg->start_srp = penwell_otg_start_srp;
+	pnw->iotg.otg.get_chrg_status = penwell_otg_get_chrg_status;
+	pnw->iotg.set_adp_probe = NULL;
+	pnw->iotg.set_adp_sense = NULL;
+	pnw->iotg.start_hnp_poll = NULL;
+	pnw->iotg.stop_hnp_poll = NULL;
+	pnw->iotg.otg.state = OTG_STATE_UNDEFINED;
+	pnw->rt_resuming = 0;
+	pnw->rt_quiesce = 0;
+	pnw->queue_stop = 0;
+	pnw->phy_power_state = 1;
+	if (usb_add_phy(&pnw->iotg.otg, USB_PHY_TYPE_USB2)) {
+		dev_err(pnw->dev, "can't set transceiver\n");
+		retval = -EBUSY;
+		goto err;
+	}
+
+	pnw->iotg.ulpi_ops.read = penwell_otg_ulpi_read;
+	pnw->iotg.ulpi_ops.write = penwell_otg_ulpi_write;
+
+	spin_lock_init(&pnw->iotg.hnp_poll_lock);
+	spin_lock_init(&pnw->lock);
+
+	wake_lock_init(&pnw->wake_lock, WAKE_LOCK_SUSPEND, "pnw_wake_lock");
+
+	init_timer(&pnw->hsm_timer);
+	init_timer(&pnw->bus_mon_timer);
+	init_timer(&pnw->hnp_poll_timer);
+	init_completion(&pnw->adp.adp_comp);
+
+	/* Battery Charging part */
+	spin_lock_init(&pnw->charger_lock);
+	spin_lock_init(&pnw->cap_lock);
+	pnw->charging_cap.ma = CHRG_CURR_DISCONN;
+	pnw->charging_cap.chrg_type = CHRG_UNKNOWN;
+	pnw->charging_cap.current_event = USBCHRG_EVENT_DISCONN;
+	pnw->psc_cap.ma = CHRG_CURR_DISCONN;
+	pnw->psc_cap.chrg_type = POWER_SUPPLY_CHARGER_TYPE_NONE;
+	pnw->psc_cap.chrg_evt = POWER_SUPPLY_CHARGER_EVENT_DISCONNECT;
+
+	ATOMIC_INIT_NOTIFIER_HEAD(&pnw->iotg.iotg_notifier);
+	/* For generic otg notifications */
+	ATOMIC_INIT_NOTIFIER_HEAD(&pnw->iotg.otg.notifier);
+
+	pnw->iotg_notifier.notifier_call = penwell_otg_iotg_notify;
+	if (intel_mid_otg_register_notifier(&pnw->iotg, &pnw->iotg_notifier)) {
+		dev_dbg(pnw->dev, "Failed to register notifier\n");
+		retval = -EBUSY;
+		goto err;
+	}
+	if (register_pm_notifier(&pnw_sleep_pm_notifier)) {
+		dev_dbg(pnw->dev, "Fail to register PM notifier\n");
+		retval = -EBUSY;
+		goto err;
+	}
+
+	/* listen usb core events */
+	usb_register_notify(&otg_nb);
+
+	pnw->otg_pdata = pdev->dev.platform_data;
+	if (pnw->otg_pdata == NULL) {
+		dev_err(pnw->dev, "Failed to get OTG platform data.\n");
+		retval = -ENODEV;
+		goto err;
+	}
+
+	if (pnw->otg_pdata->hnp_poll_support) {
+		pnw->iotg.start_hnp_poll = penwell_otg_start_hnp_poll;
+		pnw->iotg.stop_hnp_poll = penwell_otg_stop_hnp_poll;
+	}
+
+	/* FIXME: Reads Charging compliance bit from scu mip.
+	 * This snippet needs to be cleaned up after EM inteface is ready
+	 */
+	if (is_clovertrail(pdev)) {
+		u8	smip_data = 0;
+		if (!intel_scu_ipc_read_mip(&smip_data, 1, 0x2e7, 1)) {
+			pnw->otg_pdata->charging_compliance =
+							!(smip_data & 0x40);
+			dev_info(pnw->dev, "charging_compliance = %d\n",
+					pnw->otg_pdata->charging_compliance);
+		} else
+			dev_err(pnw->dev, "scu mip read error\n");
+	}
+
+	if (!is_clovertrail(pdev)) {
+		if (pnw->otg_pdata->gpio_vbus) {
+			retval = gpio_request(pnw->otg_pdata->gpio_vbus,
+					"usb_otg_phy_reset");
+			if (retval < 0) {
+				dev_err(pnw->dev, "request gpio(%d) failed\n",
+						pnw->otg_pdata->gpio_vbus);
+				retval = -ENODEV;
+				goto err;
+			}
+		}
+	}
+
+	if (is_clovertrail(pdev)) {
+		/* Set up gpio for Clovertrail */
+		retval = gpio_request(pnw->otg_pdata->gpio_reset,
+					"usb_otg_phy_reset");
+		if (retval < 0) {
+			dev_err(pnw->dev, "request phy reset gpio(%d) failed\n",
+						pnw->otg_pdata->gpio_reset);
+			retval = -ENODEV;
+			goto err;
+		}
+		retval = gpio_request(pnw->otg_pdata->gpio_cs,
+					"usb_otg_phy_cs");
+		if (retval < 0) {
+			dev_err(pnw->dev, "request phy cs gpio(%d) failed\n",
+						pnw->otg_pdata->gpio_cs);
+			gpio_free(pnw->otg_pdata->gpio_reset);
+			retval = -ENODEV;
+			goto err;
+		}
+	}
+
+	penwell_otg_phy_power(1);
+	penwell_otg_phy_reset();
+
+	mutex_init(&pnw->msic_mutex);
+	pnw->msic = penwell_otg_check_msic();
+
+	penwell_otg_phy_low_power(0);
+
+	if (!is_clovertrail(pdev)) {
+		/* Workaround for ULPI lockup issue, need turn off PHY 4ms */
+		penwell_otg_phy_enable(0);
+		usleep_range(4000, 4500);
+		penwell_otg_phy_enable(1);
+		/* reset phy */
+		dev_dbg(pnw->dev, "Reset Phy over SPI\n");
+		penwell_otg_msic_spi_access(true);
+		penwell_otg_msic_write(MSIC_FUNCTRLSET, PHYRESET);
+		penwell_otg_msic_spi_access(false);
+		dev_dbg(pnw->dev, "Reset Phy over SPI Done\n");
+	}
+
+	/* Enable ID pullup immediately after reeable PHY */
+	val32 = readl(pnw->iotg.base + CI_OTGSC);
+	writel(val32 | OTGSC_IDPU, pnw->iotg.base + CI_OTGSC);
+
+	/* Wait correct value to be synced */
+	set_host_mode();
+	usleep_range(2000, 3000);
+	penwell_otg_phy_low_power(1);
+	msleep(100);
+
+	/* enable ACA device detection for CTP */
+	if (is_clovertrail(pdev))
+		penwell_otg_aca_enable();
+
+	reset_otg();
+	init_hsm();
+
+	/* we need to set active early or the first irqs will be ignored */
+	pm_runtime_set_active(&pdev->dev);
+
+	if (request_irq(pdev->irq, otg_irq, IRQF_SHARED,
+				driver_name, pnw) != 0) {
+		dev_dbg(pnw->dev,
+			"request interrupt %d failed\n", pdev->irq);
+		retval = -EBUSY;
+		goto err;
+	}
+
+	/* enable OTGSC int */
+	val32 = OTGSC_DPIE | OTGSC_BSEIE | OTGSC_BSVIE |
+		OTGSC_ASVIE | OTGSC_AVVIE | OTGSC_IDIE | OTGSC_IDPU;
+	writel(val32, pnw->iotg.base + CI_OTGSC);
+
+	retval = device_create_file(&pdev->dev, &dev_attr_registers);
+	if (retval < 0) {
+		dev_dbg(pnw->dev,
+			"Can't register sysfs attribute: %d\n", retval);
+		goto err;
+	}
+
+	retval = device_create_file(&pdev->dev, &dev_attr_hsm);
+	if (retval < 0) {
+		dev_dbg(pnw->dev,
+			"Can't hsm sysfs attribute: %d\n", retval);
+		goto err;
+	}
+
+	retval = device_create_file(&pdev->dev, &dev_attr_chargers);
+	if (retval < 0) {
+		dev_dbg(pnw->dev,
+			"Can't chargers sysfs attribute: %d\n", retval);
+		goto err;
+	}
+
+	retval = sysfs_create_group(&pdev->dev.kobj, &debug_dev_attr_group);
+	if (retval < 0) {
+		dev_dbg(pnw->dev,
+			"Can't register sysfs attr group: %d\n", retval);
+		goto err;
+	}
+
+	pm_runtime_put_noidle(&pdev->dev);
+	pm_runtime_allow(&pdev->dev);
+
+	penwell_update_transceiver();
+
+	return 0;
+
+err:
+	if (the_transceiver)
+		penwell_otg_remove(pdev);
+done:
+	return retval;
+}
+
+static void penwell_otg_remove(struct pci_dev *pdev)
+{
+	struct penwell_otg *pnw = the_transceiver;
+	struct otg_bc_event *evt, *tmp;
+
+	/* ACA device detection disable */
+	penwell_otg_aca_disable();
+
+	pm_runtime_get_noresume(&pdev->dev);
+	pm_runtime_forbid(&pdev->dev);
+
+	if (pnw->qwork) {
+		flush_workqueue(pnw->qwork);
+		destroy_workqueue(pnw->qwork);
+	}
+
+	if (pnw->chrg_qwork) {
+		flush_workqueue(pnw->chrg_qwork);
+		destroy_workqueue(pnw->chrg_qwork);
+		list_for_each_entry_safe(evt, tmp, &pnw->chrg_evt_queue, node) {
+			list_del(&evt->node);
+			kfree(evt);
+		}
+	}
+
+	/* disable OTGSC interrupt as OTGSC doesn't change in reset */
+	writel(0, pnw->iotg.base + CI_OTGSC);
+
+	wake_lock_destroy(&pnw->wake_lock);
+
+	if (pdev->irq)
+		free_irq(pdev->irq, pnw);
+	if (pnw->cfg_region)
+		release_mem_region(USBCFG_ADDR, USBCFG_LEN);
+	if (pnw->iotg.base)
+		iounmap(pnw->iotg.base);
+	kfree(pnw->iotg.otg.otg);
+	if (pnw->region)
+		release_mem_region(pci_resource_start(pdev, 0),
+				pci_resource_len(pdev, 0));
+
+	usb_remove_phy(&pnw->iotg.otg);
+	pci_disable_device(pdev);
+	sysfs_remove_group(&pdev->dev.kobj, &debug_dev_attr_group);
+	device_remove_file(&pdev->dev, &dev_attr_chargers);
+	device_remove_file(&pdev->dev, &dev_attr_hsm);
+	device_remove_file(&pdev->dev, &dev_attr_registers);
+	usb_unregister_notify(&otg_nb);
+	kfree(pnw);
+	pnw = NULL;
+}
+
+void penwell_otg_shutdown(struct pci_dev *pdev)
+{
+	struct penwell_otg *pnw = the_transceiver;
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+
+	if (!is_clovertrail(pdev)) {
+		/* Disable MSIC Interrupt Notifications */
+		penwell_otg_msic_spi_access(true);
+
+		penwell_otg_msic_write(MSIC_INT_EN_RISE_CLR, 0x1F);
+		penwell_otg_msic_write(MSIC_INT_EN_FALL_CLR, 0x1F);
+
+		penwell_otg_msic_spi_access(false);
+	}
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+}
+
+
+static int penwell_otg_suspend_noirq(struct device *dev)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	int				ret = 0;
+	unsigned long	flags;
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+
+	switch (iotg->otg.state) {
+	case OTG_STATE_A_VBUS_ERR:
+		set_host_mode();
+		iotg->otg.state = OTG_STATE_A_IDLE;
+		break;
+	case OTG_STATE_A_WAIT_VFALL:
+		penwell_otg_del_timer(TA_WAIT_VFALL_TMR);
+		iotg->otg.state = OTG_STATE_A_IDLE;
+	case OTG_STATE_A_IDLE:
+	case OTG_STATE_B_IDLE:
+		break;
+	case OTG_STATE_A_WAIT_VRISE:
+		penwell_otg_del_timer(TA_WAIT_VRISE_TMR);
+		iotg->hsm.a_srp_det = 0;
+
+		/* Turn off VBus */
+		otg_set_vbus(iotg->otg.otg, false);
+		iotg->otg.state = OTG_STATE_A_IDLE;
+		break;
+	case OTG_STATE_A_WAIT_BCON:
+	case OTG_STATE_A_HOST:
+		if (pnw->iotg.suspend_noirq_host)
+			ret = pnw->iotg.suspend_noirq_host(&pnw->iotg);
+		goto done;
+		break;
+	case OTG_STATE_A_SUSPEND:
+		penwell_otg_del_timer(TA_AIDL_BDIS_TMR);
+		penwell_otg_HABA(0);
+		PNW_STOP_HOST(pnw);
+		iotg->hsm.a_srp_det = 0;
+
+		penwell_otg_phy_vbus_wakeup(false);
+
+		/* Turn off VBus */
+		otg_set_vbus(iotg->otg.otg, false);
+		iotg->otg.state = OTG_STATE_A_IDLE;
+		break;
+	case OTG_STATE_A_PERIPHERAL:
+		penwell_otg_del_timer(TA_BIDL_ADIS_TMR);
+
+		if (pnw->iotg.stop_peripheral)
+			pnw->iotg.stop_peripheral(&pnw->iotg);
+		else
+			dev_dbg(pnw->dev, "client driver has been stopped.\n");
+
+		/* Turn off VBus */
+		otg_set_vbus(iotg->otg.otg, false);
+		iotg->hsm.a_srp_det = 0;
+		iotg->otg.state = OTG_STATE_A_IDLE;
+		break;
+	case OTG_STATE_B_HOST:
+		/* Stop HNP polling */
+		if (iotg->stop_hnp_poll)
+			iotg->stop_hnp_poll(iotg);
+
+		PNW_STOP_HOST(pnw);
+		iotg->hsm.b_bus_req = 0;
+		iotg->otg.state = OTG_STATE_B_IDLE;
+		break;
+	case OTG_STATE_B_PERIPHERAL:
+		dev_dbg(pnw->dev, "don't suspend, client still alive\n");
+		ret = -EBUSY;
+		break;
+	case OTG_STATE_B_WAIT_ACON:
+		penwell_otg_del_timer(TB_ASE0_BRST_TMR);
+
+		penwell_otg_HAAR(0);
+
+		PNW_STOP_HOST(pnw);
+		iotg->hsm.b_bus_req = 0;
+		iotg->otg.state = OTG_STATE_B_IDLE;
+		break;
+	default:
+		dev_dbg(pnw->dev, "error state before suspend\n");
+		break;
+	}
+
+
+	if (ret) {
+		spin_lock_irqsave(&pnw->lock, flags);
+		pnw->queue_stop = 0;
+		spin_unlock_irqrestore(&pnw->lock, flags);
+
+		penwell_update_transceiver();
+	} else {
+		penwell_otg_phy_low_power(1);
+		penwell_otg_vusb330_low_power(1);
+#ifdef CONFIG_USB_PENWELL_OTG_PHY_OFF
+		if (iotg->otg.state == OTG_STATE_B_IDLE) {
+			penwell_otg_phy_power(0);
+			pnw->phy_power_state = 0;
+		}
+#endif
+	}
+
+done:
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+	return ret;
+}
+
+static int penwell_otg_suspend(struct device *dev)
+{
+	struct penwell_otg		*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	int				ret = 0;
+	unsigned long	flags;
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+
+	if (iotg->otg.state == OTG_STATE_B_PERIPHERAL) {
+		dev_dbg(pnw->dev, "still alive, don't suspend\n");
+		ret = -EBUSY;
+		goto done;
+	}
+
+	/* quiesce any work scheduled */
+	spin_lock_irqsave(&pnw->lock, flags);
+	pnw->queue_stop = 1;
+	spin_unlock_irqrestore(&pnw->lock, flags);
+	flush_workqueue(pnw->qwork);
+	if (delayed_work_pending(&pnw->ulpi_check_work)) {
+		spin_lock_irqsave(&pnw->lock, flags);
+		pnw->queue_stop = 0;
+		spin_unlock_irqrestore(&pnw->lock, flags);
+		ret = -EBUSY;
+		goto done;
+	} else
+		flush_delayed_work_sync(&pnw->ulpi_check_work);
+
+	switch (iotg->otg.state) {
+	case OTG_STATE_A_WAIT_BCON:
+		penwell_otg_del_timer(TA_WAIT_BCON_TMR);
+		iotg->hsm.a_srp_det = 0;
+		if (iotg->suspend_host)
+			ret = iotg->suspend_host(iotg);
+		break;
+	case OTG_STATE_A_HOST:
+		if (iotg->stop_hnp_poll)
+			iotg->stop_hnp_poll(iotg);
+		if (iotg->suspend_host)
+			ret = iotg->suspend_host(iotg);
+		break;
+	default:
+		break;
+	}
+
+done:
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+	return ret;
+}
+
+static void penwell_otg_dump_bogus_wake(void)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	int addr = 0x2C8, retval;
+	u8 val;
+
+	/* Enable SPI access */
+	penwell_otg_msic_spi_access(true);
+
+	retval = penwell_otg_msic_read(addr, &val);
+	if (retval) {
+		dev_err(pnw->dev, "msic read failed\n");
+		goto out;
+	}
+	dev_info(pnw->dev, "0x%03x: 0x%02x", addr, val);
+
+	for (addr = 0x340; addr <= 0x348; addr++) {
+		retval = penwell_otg_msic_read(addr, &val);
+		if (retval) {
+			dev_err(pnw->dev, "msic read failed\n");
+			goto out;
+		}
+		dev_info(pnw->dev, "0x%03x: 0x%02x", addr, val);
+	}
+
+	for (addr = 0x394; addr <= 0x3BF; addr++) {
+		retval = penwell_otg_msic_read(addr, &val);
+		if (retval) {
+			dev_err(pnw->dev, "msic read failed\n");
+			goto out;
+		}
+		dev_info(pnw->dev, "0x%03x: 0x%02x", addr, val);
+	}
+
+	addr = 0x192;
+	retval = penwell_otg_msic_read(addr, &val);
+	if (retval) {
+		dev_err(pnw->dev, "msic read failed\n");
+		goto out;
+	}
+
+	dev_info(pnw->dev, "0x%03x: 0x%02x", addr, val);
+out:
+	penwell_otg_msic_spi_access(false);
+}
+
+static int penwell_otg_resume_noirq(struct device *dev)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	struct pci_dev			*pdev;
+	int			ret = 0;
+	u32			val;
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+
+	pdev = to_pci_dev(pnw->dev);
+
+	/* If USB PHY is in OFF state, power on it and do basic init work */
+	if (!pnw->phy_power_state) {
+		penwell_otg_phy_power(1);
+		/* Change phy_power_state to 1 again */
+		pnw->phy_power_state = 1;
+		penwell_otg_phy_reset();
+
+		/* Reset controller and clear PHY low power mode setting */
+		reset_otg();
+		penwell_otg_phy_low_power(0);
+
+		/* Wait ID value to be synced */
+		msleep(60);
+	}
+
+	/* add delay in case controller is back to D0, controller
+	 * needs time to sync/latch value for OTGSC register */
+	usleep_range(2000, 2500);
+
+	if (mid_pmu_is_wake_source(PMU_OTG_WAKE_SOURCE)) {
+		/* dump OTGSC register for wakeup event */
+		val = readl(pnw->iotg.base + CI_OTGSC);
+		dev_info(pnw->dev, "%s: CI_OTGSC=0x%x\n", __func__, val);
+		if (val & OTGSC_IDIS)
+			dev_info(pnw->dev, "%s: id change\n", __func__);
+		if (val & OTGSC_DPIS)
+			dev_info(pnw->dev, "%s: data pulse\n", __func__);
+		if (val & OTGSC_BSEIS)
+			dev_info(pnw->dev, "%s: b sess end\n", __func__);
+		if (val & OTGSC_BSVIS)
+			dev_info(pnw->dev, "%s: b sess valid\n", __func__);
+		if (val & OTGSC_ASVIS)
+			dev_info(pnw->dev, "%s: a sess valid\n", __func__);
+		if (val & OTGSC_AVVIS)
+			dev_info(pnw->dev, "%s: a vbus valid\n", __func__);
+
+		if (!(val & OTGSC_INTSTS_MASK)) {
+			static bool uevent_reported;
+			dev_info(pnw->dev,
+				 "%s: waking up from USB source, but not a OTG wakeup event\n",
+				 __func__);
+			if (!uevent_reported) {
+				if (!is_clovertrail(pdev))
+					penwell_otg_dump_bogus_wake();
+				queue_work(pnw->qwork, &pnw->uevent_work);
+				uevent_reported = true;
+			}
+		}
+	}
+
+	if (iotg->otg.state != OTG_STATE_A_WAIT_BCON &&
+		iotg->otg.state != OTG_STATE_A_HOST) {
+		penwell_otg_vusb330_low_power(0);
+		penwell_otg_phy_low_power(0);
+	}
+
+	/* D3->D0 controller will be reset, so reset work mode and PHY state
+	 * which is cleared by the reset */
+
+	switch (pnw->iotg.otg.state) {
+	case OTG_STATE_B_IDLE:
+		break;
+	case OTG_STATE_A_WAIT_BCON:
+	case OTG_STATE_A_HOST:
+		if (iotg->resume_noirq_host)
+			ret = iotg->resume_noirq_host(iotg);
+		break;
+	default:
+		break;
+	}
+
+
+	/* We didn't disable otgsc interrupt, to prevent intr from happening
+	* before penwell_otg_resume, intr is disabled here, and can be enabled
+	* by penwell_otg_resume
+	*/
+	penwell_otg_intr(0);
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+	return ret;
+}
+
+static int penwell_otg_resume(struct device *dev)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	struct intel_mid_otg_xceiv	*iotg = &pnw->iotg;
+	int			ret = 0;
+	unsigned long	flags;
+
+	dev_dbg(pnw->dev, "%s --->\n", __func__);
+	switch (iotg->otg.state) {
+	case OTG_STATE_A_WAIT_BCON:
+		if (iotg->resume_host)
+			ret = iotg->resume_host(iotg);
+		penwell_otg_add_timer(TA_WAIT_BCON_TMR);
+		break;
+	case OTG_STATE_A_HOST:
+		if (iotg->resume_host)
+			ret = iotg->resume_host(iotg);
+
+		/* FIXME: Ideally here should re-start HNP polling,
+		 * no start HNP here, because it blocks the resume
+		*/
+		break;
+	default:
+		break;
+	}
+
+	if (ret)
+		return ret;
+
+	/* allow queue work from notifier */
+	spin_lock_irqsave(&pnw->lock, flags);
+	pnw->queue_stop = 0;
+	spin_unlock_irqrestore(&pnw->lock, flags);
+
+	penwell_otg_intr(1);
+
+	/* If a plugging in or pluggout event happens during D3,
+	* we will miss the interrupt, so check OTGSC here to check
+	* if any ID change and update hsm correspondingly
+	*/
+	update_hsm();
+	penwell_update_transceiver();
+
+	dev_dbg(pnw->dev, "%s <---\n", __func__);
+	return ret;
+}
+
+
+#ifdef CONFIG_PM_RUNTIME
+/* Runtime PM */
+static int penwell_otg_runtime_suspend(struct device *dev)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	struct pci_dev		*pdev = to_pci_dev(dev);
+	int			ret = 0;
+	u32			val;
+	unsigned long		flags;
+
+	dev_dbg(dev, "%s --->\n", __func__);
+
+	pnw->rt_quiesce = 1;
+
+	/* Flush any pending otg irq on local or any other CPUs.
+	*
+	* Host mode or Device mode irq should be synchronized by itself in
+	* their runtime_suspend handler. In fact, Host mode does so. For
+	* device mode, we don't care as its runtime PM is disabled.
+	*
+	* As device's runtime_status is already RPM_SUSPENDING, after flushing,
+	* any new irq handling will be rejected (otg irq handler only continues
+	* if runtime_status is RPM_ACTIVE).
+	* Thus, now it's safe to put PHY into low power mode and gate the
+	* fabric later in pci_set_power_state().
+	*/
+	synchronize_irq(pdev->irq);
+
+	switch (pnw->iotg.otg.state) {
+	case OTG_STATE_A_IDLE:
+		break;
+	case OTG_STATE_B_IDLE:
+		val = readl(pnw->iotg.base + CI_USBMODE);
+		if (!(val & USBMODE_CM)) {
+			/* Controller needs to reset & set mode */
+			dev_dbg(dev, "reset to client mode\n");
+			set_client_mode();
+		}
+		break;
+	case OTG_STATE_A_WAIT_BCON:
+	case OTG_STATE_A_HOST:
+	case OTG_STATE_A_SUSPEND:
+		if (pnw->iotg.runtime_suspend_host)
+			ret = pnw->iotg.runtime_suspend_host(&pnw->iotg);
+		break;
+	case OTG_STATE_A_PERIPHERAL:
+	case OTG_STATE_B_PERIPHERAL:
+		if (pnw->iotg.runtime_suspend_peripheral)
+			ret = pnw->iotg.runtime_suspend_peripheral(&pnw->iotg);
+		break;
+	default:
+		break;
+	}
+
+	if (ret) {
+		spin_lock_irqsave(&pnw->lock, flags);
+		pnw->rt_quiesce = 0;
+		if (pnw->rt_resuming) {
+			pnw->rt_resuming = 0;
+			pm_runtime_put(pnw->dev);
+		}
+		spin_unlock_irqrestore(&pnw->lock, flags);
+		goto DONE;
+	}
+
+	penwell_otg_phy_low_power(1);
+
+	msleep(2);
+
+	penwell_otg_vusb330_low_power(1);
+
+DONE:
+	dev_dbg(dev, "%s <---: ret = %d\n", __func__, ret);
+	return ret;
+}
+
+static int penwell_otg_runtime_resume(struct device *dev)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+	int			ret = 0;
+	u32			val;
+	unsigned long		flags;
+
+	dev_dbg(dev, "%s --->\n", __func__);
+
+	penwell_otg_phy_low_power(0);
+	penwell_otg_vusb330_low_power(0);
+	/* waiting for hardware stable */
+	usleep_range(2000, 4000);
+
+	switch (pnw->iotg.otg.state) {
+	case OTG_STATE_A_IDLE:
+		break;
+	case OTG_STATE_B_IDLE:
+		val = readl(pnw->iotg.base + CI_USBMODE);
+		if (!(val & USBMODE_CM)) {
+			/* Controller needs to reset & set mode */
+			dev_dbg(dev, "reset to client mode\n");
+			set_client_mode();
+		}
+		break;
+	case OTG_STATE_A_WAIT_BCON:
+	case OTG_STATE_A_HOST:
+	case OTG_STATE_A_SUSPEND:
+		if (pnw->iotg.runtime_resume_host)
+			ret = pnw->iotg.runtime_resume_host(&pnw->iotg);
+		break;
+	case OTG_STATE_A_PERIPHERAL:
+	case OTG_STATE_B_PERIPHERAL:
+		if (pnw->iotg.runtime_resume_peripheral)
+			ret = pnw->iotg.runtime_resume_peripheral(&pnw->iotg);
+		break;
+	default:
+		break;
+	}
+
+	spin_lock_irqsave(&pnw->lock, flags);
+	pnw->rt_quiesce = 0;
+	if (pnw->rt_resuming) {
+		pnw->rt_resuming = 0;
+		pm_runtime_put(pnw->dev);
+	}
+	spin_unlock_irqrestore(&pnw->lock, flags);
+
+	dev_dbg(dev, "%s <---\n", __func__);
+
+	return ret;
+}
+
+static int penwell_otg_runtime_idle(struct device *dev)
+{
+	struct penwell_otg	*pnw = the_transceiver;
+
+	dev_dbg(dev, "%s --->\n", __func__);
+
+	switch (pnw->iotg.otg.state) {
+	case OTG_STATE_A_WAIT_VRISE:
+	case OTG_STATE_A_WAIT_VFALL:
+	case OTG_STATE_A_VBUS_ERR:
+	case OTG_STATE_B_WAIT_ACON:
+	case OTG_STATE_B_HOST:
+		dev_dbg(dev, "Keep in active\n");
+		dev_dbg(dev, "%s <---\n", __func__);
+		return -EBUSY;
+	case OTG_STATE_A_WAIT_BCON:
+	case OTG_STATE_A_HOST:
+		/* Schedule runtime_suspend without delay */
+		pm_schedule_suspend(dev, 0);
+		dev_dbg(dev, "%s <---\n", __func__);
+		return -EBUSY;
+	default:
+		break;
+	}
+
+	/* some delay for stability */
+	pm_schedule_suspend(dev, 500);
+
+	dev_dbg(dev, "%s <---\n", __func__);
+
+	return -EBUSY;
+}
+
+#else
+
+#define penwell_otg_runtime_suspend NULL
+#define penwell_otg_runtime_resume NULL
+#define penwell_otg_runtime_idle NULL
+
+#endif
+
+/*----------------------------------------------------------*/
+
+DEFINE_PCI_DEVICE_TABLE(pci_ids) = {{
+	.class =        ((PCI_CLASS_SERIAL_USB << 8) | 0x20),
+	.class_mask =   ~0,
+	.vendor =	0x8086,
+	.device =	0x0829,
+	.subvendor =	PCI_ANY_ID,
+	.subdevice =	PCI_ANY_ID,
+	},
+	{ /* Cloverview */
+		.class =        ((PCI_CLASS_SERIAL_USB << 8) | 0x20),
+		.class_mask =   ~0,
+		.vendor =	0x8086,
+		.device =	0xE006,
+		.subvendor =	PCI_ANY_ID,
+		.subdevice =	PCI_ANY_ID,
+	},
+	{ /* end: all zeroes */ }
+};
+
+static const struct dev_pm_ops penwell_otg_pm_ops = {
+	.runtime_suspend = penwell_otg_runtime_suspend,
+	.runtime_resume = penwell_otg_runtime_resume,
+	.runtime_idle = penwell_otg_runtime_idle,
+	.suspend = penwell_otg_suspend,
+	.suspend_noirq = penwell_otg_suspend_noirq,
+	.resume = penwell_otg_resume,
+	.resume_noirq = penwell_otg_resume_noirq,
+};
+
+static struct pci_driver otg_pci_driver = {
+	.name =		(char *) driver_name,
+	.id_table =	pci_ids,
+
+	.probe =	penwell_otg_probe,
+	.remove =	penwell_otg_remove,
+	.shutdown =	penwell_otg_shutdown,
+	.driver = {
+		.pm =	&penwell_otg_pm_ops
+	},
+};
+
+static int __init penwell_otg_init(void)
+{
+#ifdef	CONFIG_DEBUG_FS
+	pm_sss0_base = ioremap_nocache(0xFF11D030, 0x100);
+#endif
+	return pci_register_driver(&otg_pci_driver);
+}
+module_init(penwell_otg_init);
+
+static void __exit penwell_otg_cleanup(void)
+{
+#ifdef	CONFIG_DEBUG_FS
+	iounmap(pm_sss0_base);
+#endif
+	pci_unregister_driver(&otg_pci_driver);
+}
+module_exit(penwell_otg_cleanup);
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index fd40294..7b343b2 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -2559,6 +2559,7 @@
 #define PCI_DEVICE_ID_INTEL_CLV_EMMC0   0x08e5
 #define PCI_DEVICE_ID_INTEL_CLV_EMMC1   0x08e6
 #define PCI_DEVICE_ID_INTEL_MRFL_MMC    0x1190
+#define PCI_DEVICE_ID_INTEL_MRFL_DWC3_OTG	0x119E
 #define PCI_DEVICE_ID_INTEL_BYT_SDIO    0x0f15
 #define PCI_DEVICE_ID_INTEL_I960RM	0x0962
 #define PCI_DEVICE_ID_INTEL_CENTERTON_ILB	0x0c60
@@ -2886,6 +2887,7 @@
 #define PCI_DEVICE_ID_INTEL_IXP4XX	0x8500
 #define PCI_DEVICE_ID_INTEL_IXP2800	0x9004
 #define PCI_DEVICE_ID_INTEL_S21152BB	0xb152
+#define PCI_DEVICE_ID_INTEL_SST_MRFLD   0x119A
 
 #define PCI_VENDOR_ID_SCALEMP		0x8686
 #define PCI_DEVICE_ID_SCALEMP_VSMP_CTL	0x1010
diff --git a/include/linux/power_supply.h b/include/linux/power_supply.h
index c9dc4e0..edfbebe 100644
--- a/include/linux/power_supply.h
+++ b/include/linux/power_supply.h
@@ -85,6 +85,14 @@ enum {
 	POWER_SUPPLY_SCOPE_DEVICE,
 };
 
+enum {
+	POWER_SUPPLY_CHARGE_CURRENT_LIMIT_ZERO = 0,
+	POWER_SUPPLY_CHARGE_CURRENT_LIMIT_LOW,
+	POWER_SUPPLY_CHARGE_CURRENT_LIMIT_MEDIUM,
+	POWER_SUPPLY_CHARGE_CURRENT_LIMIT_HIGH,
+	POWER_SUPPLY_CHARGE_CURRENT_LIMIT_NONE,
+};
+
 enum power_supply_property {
 	/* Properties of type `int' */
 	POWER_SUPPLY_PROP_STATUS = 0,
@@ -118,8 +126,14 @@ enum power_supply_property {
 	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,
 	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE,
 	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX,
+	POWER_SUPPLY_CHARGE_CURRENT_LIMIT,
 	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT,
 	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX,
+	POWER_SUPPLY_PROP_CHARGE_CURRENT,
+	POWER_SUPPLY_PROP_MAX_CHARGE_CURRENT,
+	POWER_SUPPLY_PROP_CHARGE_VOLTAGE,
+	POWER_SUPPLY_PROP_MAX_CHARGE_VOLTAGE,
+	POWER_SUPPLY_PROP_INLMT,
 	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN,
 	POWER_SUPPLY_PROP_ENERGY_EMPTY_DESIGN,
 	POWER_SUPPLY_PROP_ENERGY_FULL,
@@ -133,6 +147,8 @@ enum power_supply_property {
 	POWER_SUPPLY_PROP_TEMP,
 	POWER_SUPPLY_PROP_TEMP_ALERT_MIN,
 	POWER_SUPPLY_PROP_TEMP_ALERT_MAX,
+	POWER_SUPPLY_PROP_MAX_TEMP,
+	POWER_SUPPLY_PROP_MIN_TEMP,
 	POWER_SUPPLY_PROP_TEMP_AMBIENT,
 	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN,
 	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX,
@@ -141,6 +157,11 @@ enum power_supply_property {
 	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW,
 	POWER_SUPPLY_PROP_TIME_TO_FULL_AVG,
 	POWER_SUPPLY_PROP_TYPE, /* use power_supply.type instead */
+	POWER_SUPPLY_PROP_CHARGE_TERM_CUR,
+	POWER_SUPPLY_PROP_ENABLE_CHARGING,
+	POWER_SUPPLY_PROP_ENABLE_CHARGER,
+	POWER_SUPPLY_PROP_CABLE_TYPE,
+	POWER_SUPPLY_PROP_PRIORITY,
 	POWER_SUPPLY_PROP_SCOPE,
 	/* Properties of type `const char *' */
 	POWER_SUPPLY_PROP_MODEL_NAME,
@@ -154,11 +175,57 @@ enum power_supply_type {
 	POWER_SUPPLY_TYPE_UPS,
 	POWER_SUPPLY_TYPE_MAINS,
 	POWER_SUPPLY_TYPE_USB,		/* Standard Downstream Port */
+	POWER_SUPPLY_TYPE_USB_INVAL,	/* Invalid Standard Downstream Port */
 	POWER_SUPPLY_TYPE_USB_DCP,	/* Dedicated Charging Port */
 	POWER_SUPPLY_TYPE_USB_CDP,	/* Charging Downstream Port */
 	POWER_SUPPLY_TYPE_USB_ACA,	/* Accessory Charger Adapters */
+	POWER_SUPPLY_TYPE_USB_HOST,	/* To support OTG devices */
+};
+
+enum power_supply_charger_event {
+	POWER_SUPPLY_CHARGER_EVENT_CONNECT = 0,
+	POWER_SUPPLY_CHARGER_EVENT_UPDATE,
+	POWER_SUPPLY_CHARGER_EVENT_RESUME,
+	POWER_SUPPLY_CHARGER_EVENT_SUSPEND,
+	POWER_SUPPLY_CHARGER_EVENT_DISCONNECT,
+};
+
+struct power_supply_charger_cap {
+	enum power_supply_charger_event chrg_evt;
+	enum power_supply_type chrg_type;
+	unsigned int mA; /* input current limit */
+};
+
+enum power_supply_charger_cable_type {
+	POWER_SUPPLY_CHARGER_TYPE_NONE = 0,
+	POWER_SUPPLY_CHARGER_TYPE_USB_SDP = 1 << 0,
+	POWER_SUPPLY_CHARGER_TYPE_USB_DCP = 1 << 1,
+	POWER_SUPPLY_CHARGER_TYPE_USB_CDP = 1 << 2,
+	POWER_SUPPLY_CHARGER_TYPE_USB_ACA = 1 << 3,
+	POWER_SUPPLY_CHARGER_TYPE_AC = 1 << 4,
+	POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK = 1 << 5,
+	POWER_SUPPLY_CHARGER_TYPE_ACA_A = 1 << 6,
+	POWER_SUPPLY_CHARGER_TYPE_ACA_B = 1 << 7,
+	POWER_SUPPLY_CHARGER_TYPE_ACA_C = 1 << 8,
+	POWER_SUPPLY_CHARGER_TYPE_SE1 = 1 << 9,
+	POWER_SUPPLY_CHARGER_TYPE_MHL = 1 << 10,
+	POWER_SUPPLY_CHARGER_TYPE_B_DEVICE = 1 << 11,
 };
 
+struct power_supply_cable_props {
+	enum power_supply_charger_event	chrg_evt;
+	enum power_supply_charger_cable_type chrg_type;
+	unsigned int ma;   /* input current limit */
+};
+
+#define POWER_SUPPLY_CHARGER_TYPE_USB \
+	(POWER_SUPPLY_CHARGER_TYPE_USB_SDP | \
+	POWER_SUPPLY_CHARGER_TYPE_USB_DCP | \
+	POWER_SUPPLY_CHARGER_TYPE_USB_CDP | \
+	POWER_SUPPLY_CHARGER_TYPE_USB_ACA | \
+	POWER_SUPPLY_CHARGER_TYPE_ACA_DOCK| \
+	POWER_SUPPLY_CHARGER_TYPE_SE1)
+
 enum power_supply_notifier_events {
 	PSY_EVENT_PROP_CHANGED,
 };
@@ -168,6 +235,19 @@ union power_supply_propval {
 	const char *strval;
 };
 
+enum psy_throttle_action {
+
+	PSY_THROTTLE_DISABLE_CHARGER = 0,
+	PSY_THROTTLE_DISABLE_CHARGING,
+	PSY_THROTTLE_CC_LIMIT,
+	PSY_THROTTLE_INPUT_LIMIT,
+};
+
+struct power_supply_throttle {
+	enum psy_throttle_action throttle_action;
+	unsigned throttle_val;
+};
+
 struct device_node;
 
 struct power_supply {
@@ -177,8 +257,10 @@ struct power_supply {
 	size_t num_properties;
 
 	char **supplied_to;
+	unsigned long supported_cables;
 	size_t num_supplicants;
-
+	struct power_supply_throttle *throttle_states;
+	size_t num_throttle_states;
 	char **supplied_from;
 	size_t num_supplies;
 	struct device_node *of_node;
@@ -193,6 +275,8 @@ struct power_supply {
 				     enum power_supply_property psp);
 	void (*external_power_changed)(struct power_supply *psy);
 	void (*set_charged)(struct power_supply *psy);
+	void (*charging_port_changed)(struct power_supply *psy,
+				struct power_supply_charger_cap *cap);
 
 	/* For APM emulation, think legacy userspace. */
 	int use_for_apm;
@@ -254,9 +338,13 @@ power_supply_get_by_phandle(struct device_node *np, const char *property)
 #endif /* CONFIG_OF */
 extern void power_supply_changed(struct power_supply *psy);
 extern int power_supply_am_i_supplied(struct power_supply *psy);
+extern int power_supply_is_battery_connected(void);
 extern int power_supply_set_battery_charged(struct power_supply *psy);
+extern void power_supply_charger_event(struct power_supply_charger_cap cap);
+extern void power_supply_query_charger_caps(struct power_supply_charger_cap
+									*cap);
 
-#ifdef CONFIG_POWER_SUPPLY
+#if defined(CONFIG_POWER_SUPPLY) || defined(CONFIG_POWER_SUPPLY_MODULE)
 extern int power_supply_is_system_supplied(void);
 #else
 static inline int power_supply_is_system_supplied(void) { return -ENOSYS; }
diff --git a/include/linux/usb/debug.h b/include/linux/usb/debug.h
new file mode 100644
index 0000000..2a08e36
--- /dev/null
+++ b/include/linux/usb/debug.h
@@ -0,0 +1,253 @@
+/*
+ * <linux/usb/debug.h> -- USB Debug Class definitions.
+ *
+ * Copyright (C) 2008-2010, Intel Corporation.
+ *
+ * This software is distributed under the terms of the GNU General Public
+ * License ("GPL") version 2, as published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __LINUX_USB_DEBUG_H
+#define __LINUX_USB_DEBUG_H
+
+#include <linux/types.h>
+
+/* Debug Interface Subclass Codes */
+#define USB_SUBCLASS_DVC_GP		0x05
+#define USB_SUBCLASS_DVC_DFX		0x06
+#define USB_SUBCLASS_DVC_TRACE		0x07
+#define USB_SUBCLASS_DEBUG_CONTROL	0x08
+
+/* Debug Interface Function Protocol */
+#define DC_PROTOCOL_VENDOR			0x00
+#define DC_PROTOCOL_LAUTERBACH			0x01
+#define DC_PROTOCOL_ITP			0x02
+
+/* Debug Class-Specific Interface Descriptor Subtypes */
+#define DC_UNDEFINED			0x00
+#define DC_INPUT_CONNECTION		0x01
+#define DC_OUTPUT_CONNECTION		0x02
+#define DC_DEBUG_UNIT			0x03
+#define DC_DEBUG_ATTRIBUTES		0x04 /* revision: per SAS */
+
+/* Debug-Class Input/Output Connection Type */
+#define DC_CONNECTION_USB			0x00
+#define DC_CONNECTION_JTAG			0x01
+#define DC_CONNECTION_DEBUG_DATA_CONTROL	0x02
+#define DC_CONNECTION_DEBUG_DATA		0x03
+#define DC_CONNECTION_DEBUG_CONTROL		0x04
+
+/*
+ * Debug-class (rev 0.88r2) section 4.4.3
+ * Attibute  Descriptor, bmControl
+ */
+#define DC_CTL_SET_CFG_DATA_SG			(1 << 0)
+#define DC_CTL_SET_CFG_DATA			(1 << 1)
+#define DC_CTL_GET_CFG_DATA			(1 << 2)
+#define DC_CTL_SET_CFG_ADDR			(1 << 3)
+#define DC_CTL_GET_CFG_ADDR			(1 << 4)
+#define DC_CTL_SET_ALT_STACK			(1 << 5)
+#define DC_CTL_GET_ALT_STACK			(1 << 6)
+#define DC_CTL_SET_OP_MODE			(1 << 7)
+#define DC_CTL_GET_OP_MODE			(1 << 8)
+#define DC_CTL_SET_TRACE_CFG			(1 << 9)
+#define DC_CTL_GET_TRACE_CFG			(1 << 10)
+#define DC_CTL_SET_BUFF_INFO			(1 << 11)
+#define DC_CTL_GET_BUFF_INFO			(1 << 12)
+#define DC_CTL_SET_RESET			(1 << 13)
+
+/* Debug-class (rev 0.88r2) section 4.4.6
+ * Unit/Input/Output connection Descriptors,
+ * dTraceFormat
+ */
+#define DC_TRACE_NOT_FORMATED_PASSTHROUGH   0x00000000
+#define DC_TRACE_NOT_FORMATED_HEADER        0x00000001
+#define DC_TRACE_NOT_FORMATED_FOOTER        0x00000002
+#define DC_TRACE_NOT_FORMATED_GUID          0x00000005
+#define DC_TRACE_NOT_FORMATED_UTF8          0x00000006
+#define DC_TRACE_INTEL_FORMATED_VENDOR      0x01000000
+#define DC_TRACE_MIPI_FORMATED_STPV1        0x80000000
+#define DC_TRACE_MIPI_FORMATED_STPV2        0x80000001
+#define DC_TRACE_MIPI_FORMATED_TWP          0x80000100
+#define DC_TRACE_MIPI_FORMATED_OST          0x80001000
+#define DC_TRACE_NEXUS_FORMATED             0x81000000
+
+/* Debug-class (rev 0.88r2) section 4.4.6
+ * Unit connection Descriptors, dDebugUnitType
+ */
+#define DC_UNIT_TYPE_DFX		0x00
+#define DC_UNIT_TYPE_SELECT		0x01
+#define DC_UNIT_TYPE_TRACE_ROUTE	0x02
+#define DC_UNIT_TYPE_TRACE_PROC	0x03
+#define DC_UNIT_TYPE_TRACE_GEN		0x04
+#define DC_UNIT_TYPE_TRACE_SINK	0x05
+#define DC_UNIT_TYPE_CONTROL		0x06
+#define DC_UNIT_TYPE_VENDOR		0x40
+
+/* Debug-class (rev 0.88r2) section 4.4.6
+ * Unit connection Descriptors, dDebugUnitSubType
+ */
+#define DC_UNIT_SUBTYPE_NO              0x00
+#define DC_UNIT_SUBTYPE_CPU             0x01
+#define DC_UNIT_SUBTYPE_GFX             0x02
+#define DC_UNIT_SUBTYPE_VIDEO		0x03
+#define DC_UNIT_SUBTYPE_IMAGING	0x04
+#define DC_UNIT_SUBTYPE_AUDIO		0x05
+#define DC_UNIT_SUBTYPE_MODEM		0x06
+#define DC_UNIT_SUBTYPE_BLUETOOTH	0x07
+#define DC_UNIT_SUBTYPE_PWR_MGT	0x08
+#define DC_UNIT_SUBTYPE_SECURITY	0x09
+#define DC_UNIT_SUBTYPE_SENSOR		0x0A
+#define DC_UNIT_SUBTYPE_BUSWATCH	0x0B
+#define DC_UNIT_SUBTYPE_GPS		0x0C
+#define DC_UNIT_SUBTYPE_TRACEZIP	0x0D
+#define DC_UNIT_SUBTYPE_TAPCTL		0x0E
+#define DC_UNIT_SUBTYPE_MEMACC		0x0F
+#define DC_UNIT_SUBTYPE_SWLOGGER	0x40
+#define DC_UNIT_SUBTYPE_SWROUTER	0x41
+#define DC_UNIT_SUBTYPE_SWDRIVER	0x42
+#define DC_UNIT_SUBTYPE_VENDOR		0x80
+
+/* USB DBG requests values */
+#define DC_REQUEST_SET_CONFIG_DATA		0x01
+#define DC_REQUEST_SET_CONFIG_DATA_SINGLE	0x02
+#define DC_REQUEST_SET_CONFIG_ADDRESS		0x03
+#define DC_REQUEST_SET_ALT_STACK		0x04
+#define DC_REQUEST_SET_OPERATING		0x05
+#define DC_REQUEST_SET_TRACE			0x08
+#define DC_REQUEST_SET_BUFFER_INFO		0x09
+#define DC_REQUEST_SET_RESET			0x0A
+#define DC_REQUEST_GET_CONFIG_DATA		0x81
+#define DC_REQUEST_GET_CONFIG_DATA_SINGLE	0x82
+#define DC_REQUEST_GET_CONFIG_ADDRESS		0x83
+#define DC_REQUEST_GET_ALT_STACK		0x84
+#define DC_REQUEST_GET_OPERATING		0x85
+#define DC_REQUEST_GET_TRACE			0x86
+#define DC_REQUEST_GET_INFO			0x87
+#define DC_REQUEST_GET_ERROR			0x88
+#define DC_REQUEST_GET_BUFFER_INFO		0x89
+
+/* Debug-Class Debug-Attributes Descriptor */
+struct dc_debug_attributes_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u8  bDescriptorSubtype;
+	__le16 bcdDC;
+	__le16 wTotalLength;
+	__u8  bmSupportedFeatures;
+	__u8  bControlSize;		/* n */
+	__u8  bmControl[0];		/* [n] */
+	__le16 wAuxDataSize;		/* m */
+	__le32 dInputBufferSize;
+	__le32 dOutputBufferSize;
+	__le64 qBaseAddress;
+	__le64 hGlobalID[2];
+	__u8  Supplementary[0];		/* [m-32] */
+} __attribute__((__packed__));
+
+#define DC_DEBUG_ATTR_DESCR(name)		 \
+	dc_debug_attributes_descriptor_##name
+
+#define DECLARE_DC_DEBUG_ATTR_DESCR(name, n, m)	\
+struct DC_DEBUG_ATTR_DESCR(name) {		\
+	__u8  bLength;					\
+	__u8  bDescriptorType;				\
+	__u8  bDescriptorSubtype;			\
+	__le16 bcdDC;					\
+	__le16 wTotalLength;				\
+	__u8  bmSupportedFeatures;			\
+	__u8  bControlSize;				\
+	__u8  bmControl[n];				\
+	__le16 wAuxDataSize;				\
+	__le32 dInputBufferSize;			\
+	__le32 dOutputBufferSize;			\
+	__le64 qBaseAddress;				\
+	__le64 hGlobalID[2];				\
+	__u8  Supplementary[m-32];			\
+} __attribute__((__packed__));
+
+#define DC_DBG_ATTRI_SIZE(n, m)		(9 + (n) + 2 + (m))
+
+/* Debug-Class Input Connection Descriptor */
+struct dc_input_connection_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u8  bDescriptorSubtype;
+	__u8  bConnectionID;
+	__u8  bConnectionType;
+	__u8  bAssocConnection;
+	__u8  iConnection;
+	__le32 dTraceFormat;
+	__le32 dStreamID;
+} __attribute__((__packed__));
+
+#define DC_INPUT_CONNECTION_SIZE	15
+
+/* Debug-Class Output Connection Descriptor */
+struct dc_output_connection_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u8  bDescriptorSubtype;
+	__u8  bConnectionID;
+	__u8  bConnectionType;
+	__u8  bAssocConnection;
+	__le16 wSourceID;
+	__u8  iConnection;
+} __attribute__((__packed__));
+
+#define DC_OUTPUT_CONNECTION_SIZE	9
+
+/* Debug-Class Debug-Unit Descriptor */
+struct dc_debug_unit_descriptor {
+	__u8  bLength;
+	__u8  bDescriptorType;
+	__u8  bDescriptorSubtype;
+	__u8  bUnitID;
+	__u8  bDebugUnitType;
+	__u8  bDebugSubUnitType;
+	__u8  bAliasUnitID;
+	__u8  bNrInPins;		/* p */
+	__le16 wSourceID[0];		/* [p] */
+	__u8  bNrOutPins;		/* q */
+	__le32 dTraceFormat[0];		/* [q] */
+	__le32 dStreamID;
+	__u8  bControlSize;		/* n */
+	__u8  bmControl[0];		/* [n] */
+	__le16 wAuxDataSize;		/* m */
+	__le64 qBaseAddress;
+	__le64 hIPID[2];
+	__u8  Supplementary[0];		/* [m-24] */
+	__u8  iDebugUnitType;
+} __attribute__((__packed__));
+
+#define DC_DEBUG_UNIT_DESCRIPTOR(p, q, n, m)		\
+	dc_debug_unit_descriptor_##p_##q##n_##m
+
+#define DECLARE_DC_DEBUG_UNIT_DESCRIPTOR(p, q, n, m)	\
+struct DC_DEBUG_UNIT_DESCRIPTOR(p, q, n, m) {		\
+	__u8  bLength;					\
+	__u8  bDescriptorType;				\
+	__u8  bDescriptorSubtype;			\
+	__u8  bUnitID;					\
+	__u8  bDebugUnitType;				\
+	__u8  bDebugSubUnitType;			\
+	__u8  bAliasUnitID;				\
+	__u8  bNrInPins;				\
+	__le16 wSourceID[p];				\
+	__u8  bNrOutPins;				\
+	__le32 dTraceFormat[q];			\
+	__le32 dStreamID;				\
+	__u8  bControlSize;				\
+	__u8  bmControl[n];				\
+	__le16 wAuxDataSize;				\
+	__le64 qBaseAddress;				\
+	__le64 hIPID[2];				\
+	__u8  Supplementary[m-24];			\
+	__u8  iDebugUnitType;				\
+} __attribute__((__packed__));
+
+#define DC_DBG_UNIT_SIZE(p, q, n, m)	\
+(8 + (p * 2) + 1 + (q * 4) + 5 + (n) + 2 + (m) + 1)
+
+#endif /* __LINUX_USB_DEBUG_H */
diff --git a/include/linux/usb/dwc3-intel-mid.h b/include/linux/usb/dwc3-intel-mid.h
new file mode 100644
index 0000000..376b01e
--- /dev/null
+++ b/include/linux/usb/dwc3-intel-mid.h
@@ -0,0 +1,190 @@
+/*
+ * Intel Penwell USB OTG transceiver driver
+ * Copyright (C) 2009 - 2010, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef __DWC3_INTEL_H
+#define __DWC3_INTEL_H
+
+#include "otg.h"
+
+enum intel_mid_pmic_type {
+	NO_PMIC,
+	SHADY_COVE,
+	BASIN_COVE
+};
+
+struct intel_dwc_otg_pdata {
+	int is_hvp;
+	enum intel_mid_pmic_type pmic_type;
+	int charger_detect_enable;
+	int gpio_cs;
+	int gpio_reset;
+	int gpio_id;
+	int id;
+	int charging_compliance;
+	struct delayed_work suspend_discon_work;
+	u8 ti_phy_vs1;
+	int sdp_charging;
+};
+
+#define TUSB1211_VENDOR_ID_LO					0x00
+#define TUSB1211_VENDOR_ID_HI					0x01
+#define TUSB1211_PRODUCT_ID_LO					0x02
+#define TUSB1211_PRODUCT_ID_HI					0x03
+#define TUSB1211_FUNC_CTRL						0x04
+#define TUSB1211_FUNC_CTRL_SET					0x05
+#define TUSB1211_FUNC_CTRL_CLR					0x06
+#define TUSB1211_IFC_CTRL						0x07
+#define TUSB1211_IFC_CTRL_SET					0x08
+#define TUSB1211_IFC_CTRL_CLR					0x09
+#define TUSB1211_OTG_CTRL						0x0A
+#define TUSB1211_OTG_CTRL_SET					0x0B
+#define TUSB1211_OTG_CTRL_CLR					0x0C
+#define TUSB1211_USB_INT_EN_RISE				0x0D
+#define TUSB1211_USB_INT_EN_RISE_SET			0x0E
+#define TUSB1211_USB_INT_EN_RISE_CLR			0x0F
+#define TUSB1211_USB_INT_EN_FALL				0x10
+#define TUSB1211_USB_INT_EN_FALL_SET			0x11
+#define TUSB1211_USB_INT_EN_FALL_CLR			0x12
+#define TUSB1211_USB_INT_STS					0x13
+#define TUSB1211_USB_INT_LATCH					0x14
+#define TUSB1211_DEBUG							0x15
+#define TUSB1211_SCRATCH_REG					0x16
+#define TUSB1211_SCRATCH_REG_SET				0x17
+#define TUSB1211_SCRATCH_REG_CLR				0x18
+#define TUSB1211_ACCESS_EXT_REG_SET				0x2F
+
+#define TUSB1211_VENDOR_SPECIFIC1				0x80
+#define TUSB1211_VENDOR_SPECIFIC1_SET			0x81
+#define TUSB1211_VENDOR_SPECIFIC1_CLR			0x82
+#define TUSB1211_POWER_CONTROL					0x3D
+#define TUSB1211_POWER_CONTROL_SET				0x3E
+#define TUSB1211_POWER_CONTROL_CLR				0x3F
+
+#define TUSB1211_VENDOR_SPECIFIC2				0x80
+#define TUSB1211_VENDOR_SPECIFIC2_SET			0x81
+#define TUSB1211_VENDOR_SPECIFIC2_CLR			0x82
+#define TUSB1211_VENDOR_SPECIFIC2_STS			0x83
+#define TUSB1211_VENDOR_SPECIFIC2_LATCH			0x84
+#define TUSB1211_VENDOR_SPECIFIC3				0x85
+#define TUSB1211_VENDOR_SPECIFIC3_SET			0x86
+#define TUSB1211_VENDOR_SPECIFIC3_CLR			0x87
+#define TUSB1211_VENDOR_SPECIFIC4				0x88
+#define TUSB1211_VENDOR_SPECIFIC4_SET			0x89
+#define TUSB1211_VENDOR_SPECIFIC4_CLR			0x8A
+#define TUSB1211_VENDOR_SPECIFIC5				0x8B
+#define TUSB1211_VENDOR_SPECIFIC5_SET			0x8C
+#define TUSB1211_VENDOR_SPECIFIC5_CLR			0x8D
+#define TUSB1211_VENDOR_SPECIFIC6				0x8E
+#define TUSB1211_VENDOR_SPECIFIC6_SET			0x8F
+#define TUSB1211_VENDOR_SPECIFIC6_CLR			0x90
+
+#define VS1_DATAPOLARITY						(1 << 6)
+#define VS1_ZHSDRV(v)					((v & 0x3) << 5)
+#define VS1_IHSTX(v)						 ((v & 0x7))
+
+#define VS2STS_VBUS_MNTR_STS					(1 << 7)
+#define VS2STS_REG3V3IN_MNTR_STS				(1 << 6)
+#define VS2STS_SVLDCONWKB_WDOG_STS				(1 << 5)
+#define VS2STS_ID_FLOAT_STS						(1 << 4)
+#define VS2STS_ID_RARBRC_STS(v)					((v & 0x3) << 2)
+#define VS2STS_BVALID_STS						(1 << 0)
+
+#define VS3_CHGD_IDP_SRC_EN						(1 << 6)
+#define VS3_IDPULLUP_WK_EN						(1 << 5)
+#define VS3_SW_USB_DET							(1 << 4)
+#define VS3_DATA_CONTACT_DET_EN					(1 << 3)
+#define VS3_REG3V3_VSEL(v)					   (v & 0x7)
+
+#define VS4_ACA_DET_EN							(1 << 6)
+#define VS4_RABUSIN_EN							(1 << 5)
+#define VS4_R1KSERIES							(1 << 4)
+#define VS4_PSW_OSOD							(1 << 3)
+#define VS4_PSW_CMOS							(1 << 2)
+#define VS4_CHGD_SERX_DP						(1 << 1)
+#define VS4_CHGD_SERX_DM						(1 << 0)
+
+#define VS5_AUTORESUME_WDOG_EN					(1 << 6)
+#define VS5_ID_FLOAT_EN							(1 << 5)
+#define VS5_ID_RES_EN							(1 << 4)
+#define VS5_SVLDCONWKB_WDOG_EN					(1 << 3)
+#define VS5_VBUS_MNTR_RISE_EN					(1 << 2)
+#define VS5_VBUS_MNTR_FALL_EN					(1 << 1)
+#define VS5_REG3V3IN_MNTR_EN					(1 << 0)
+
+#define DEBUG_LINESTATE                       (0x3 << 0)
+
+#define OTGCTRL_USEEXTVBUS_INDICATOR			(1 << 7)
+#define OTGCTRL_DRVVBUSEXTERNAL					(1 << 6)
+#define OTGCTRL_DRVVBUS							(1 << 5)
+#define OTGCTRL_CHRGVBUS						(1 << 4)
+#define OTGCTRL_DISCHRGVBUS						(1 << 3)
+#define OTGCTRL_DMPULLDOWN						(1 << 2)
+#define OTGCTRL_DPPULLDOWN						(1 << 1)
+#define OTGCTRL_IDPULLUP						(1 << 0)
+
+#define FUNCCTRL_SUSPENDM						(1 << 6)
+#define FUNCCTRL_RESET							(1 << 5)
+#define FUNCCTRL_OPMODE(v)				((v & 0x3) << 3)
+#define FUNCCTRL_TERMSELECT						(1 << 2)
+#define FUNCCTRL_XCVRSELECT(v)					(v & 0x3)
+
+#define PWCTRL_HWDETECT							(1 << 7)
+#define PWCTRL_DP_VSRC_EN						(1 << 6)
+#define PWCTRL_VDAT_DET							(1 << 5)
+#define PWCTRL_DP_WKPU_EN						(1 << 4)
+#define PWCTRL_BVALID_FALL						(1 << 3)
+#define PWCTRL_BVALID_RISE						(1 << 2)
+#define PWCTRL_DET_COMP							(1 << 1)
+#define PWCTRL_SW_CONTROL						(1 << 0)
+
+
+#define PMIC_VLDOCNT                0xAF
+#define PMIC_VLDOCNT_VUSBPHYEN      (1 << 2)
+
+#define PMIC_TLP1ESBS0I1VNNBASE		0X6B
+#define PMIC_I2COVRDADDR			0x59
+#define PMIC_I2COVROFFSET			0x5A
+#define PMIC_USBPHYCTRL				0x30
+#define PMIC_I2COVRWRDATA			0x5B
+#define PMIC_I2COVRCTRL				0x58
+#define PMIC_I2COVRCTL_I2CWR		0x01
+
+#define USBPHYCTRL_D0			(1 << 0)
+#define PMIC_USBIDCTRL				0x19
+#define USBIDCTRL_ACA_DETEN_D1	(1 << 1)
+#define USBIDCTRL_USB_IDEN_D0	(1 << 0)
+#define PMIC_USBIDSTS				0x1A
+#define USBIDSTS_ID_GND			(1 << 0)
+#define USBIDSTS_ID_RARBRC_STS(v)	((v & 0x3)  << 1)
+#define USBIDSTS_ID_FLOAT_STS	(1 << 3)
+#define PMIC_USBPHYCTRL_D0		(1 << 0)
+#define APBFC_EXIOTG3_MISC0_REG			0xF90FF85C
+
+#define DATACON_TIMEOUT		750
+#define DATACON_INTERVAL	10
+#define VBUS_TIMEOUT	300
+#define PCI_DEVICE_ID_DWC 0x119E
+
+#define VENDOR_ID_MASK (0x03 << 6)
+#define BASIN_COVE_PMIC_ID (0x03 << 6)
+
+#define PMIC_MAJOR_REV (0x07 << 3)
+#define PMIC_A0_MAJOR_REV 0x00
+
+#endif /* __DWC3_INTEL_H */
diff --git a/include/linux/usb/dwc3-intel-mrfl.h b/include/linux/usb/dwc3-intel-mrfl.h
new file mode 100644
index 0000000..82f3099
--- /dev/null
+++ b/include/linux/usb/dwc3-intel-mrfl.h
@@ -0,0 +1,168 @@
+/*
+ * Intel Penwell USB OTG transceiver driver
+ * Copyright (C) 2009 - 2010, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef __DWC3_INTEL_H
+#define __DWC3_INTEL_H
+
+#include "otg.h"
+
+struct intel_dwc_otg_pdata {
+	int is_hvp;
+	int charging_compliance;
+};
+
+#define TUSB1211_VENDOR_ID_LO					0x00
+#define TUSB1211_VENDOR_ID_HI					0x01
+#define TUSB1211_PRODUCT_ID_LO					0x02
+#define TUSB1211_PRODUCT_ID_HI					0x03
+#define TUSB1211_FUNC_CTRL						0x04
+#define TUSB1211_FUNC_CTRL_SET					0x05
+#define TUSB1211_FUNC_CTRL_CLR					0x06
+#define TUSB1211_IFC_CTRL						0x07
+#define TUSB1211_IFC_CTRL_SET					0x08
+#define TUSB1211_IFC_CTRL_CLR					0x09
+#define TUSB1211_OTG_CTRL						0x0A
+#define TUSB1211_OTG_CTRL_SET					0x0B
+#define TUSB1211_OTG_CTRL_CLR					0x0C
+#define TUSB1211_USB_INT_EN_RISE				0x0D
+#define TUSB1211_USB_INT_EN_RISE_SET			0x0E
+#define TUSB1211_USB_INT_EN_RISE_CLR			0x0F
+#define TUSB1211_USB_INT_EN_FALL				0x10
+#define TUSB1211_USB_INT_EN_FALL_SET			0x11
+#define TUSB1211_USB_INT_EN_FALL_CLR			0x12
+#define TUSB1211_USB_INT_STS					0x13
+#define TUSB1211_USB_INT_LATCH					0x14
+#define TUSB1211_DEBUG							0x15
+#define TUSB1211_SCRATCH_REG					0x16
+#define TUSB1211_SCRATCH_REG_SET				0x17
+#define TUSB1211_SCRATCH_REG_CLR				0x18
+#define TUSB1211_ACCESS_EXT_REG_SET				0x2F
+
+#define TUSB1211_VENDOR_SPECIFIC1				0x80
+#define TUSB1211_VENDOR_SPECIFIC1_SET			0x81
+#define TUSB1211_VENDOR_SPECIFIC1_CLR			0x82
+#define TUSB1211_POWER_CONTROL					0x3D
+#define TUSB1211_POWER_CONTROL_SET				0x3E
+#define TUSB1211_POWER_CONTROL_CLR				0x3F
+
+#define TUSB1211_VENDOR_SPECIFIC2				0x80
+#define TUSB1211_VENDOR_SPECIFIC2_SET			0x81
+#define TUSB1211_VENDOR_SPECIFIC2_CLR			0x82
+#define TUSB1211_VENDOR_SPECIFIC2_STS			0x83
+#define TUSB1211_VENDOR_SPECIFIC2_LATCH			0x84
+#define TUSB1211_VENDOR_SPECIFIC3				0x85
+#define TUSB1211_VENDOR_SPECIFIC3_SET			0x86
+#define TUSB1211_VENDOR_SPECIFIC3_CLR			0x87
+#define TUSB1211_VENDOR_SPECIFIC4				0x88
+#define TUSB1211_VENDOR_SPECIFIC4_SET			0x89
+#define TUSB1211_VENDOR_SPECIFIC4_CLR			0x8A
+#define TUSB1211_VENDOR_SPECIFIC5				0x8B
+#define TUSB1211_VENDOR_SPECIFIC5_SET			0x8C
+#define TUSB1211_VENDOR_SPECIFIC5_CLR			0x8D
+#define TUSB1211_VENDOR_SPECIFIC6				0x8E
+#define TUSB1211_VENDOR_SPECIFIC6_SET			0x8F
+#define TUSB1211_VENDOR_SPECIFIC6_CLR			0x90
+
+#define VS1_DATAPOLARITY						(1 << 6)
+#define VS1_ZHSDRV(v)					((v & 0x3) << 5)
+#define VS1_IHSTX(v)						 ((v & 0x7))
+
+#define VS2STS_VBUS_MNTR_STS					(1 << 7)
+#define VS2STS_REG3V3IN_MNTR_STS				(1 << 6)
+#define VS2STS_SVLDCONWKB_WDOG_STS				(1 << 5)
+#define VS2STS_ID_FLOAT_STS						(1 << 4)
+#define VS2STS_ID_RARBRC_STS(v)					((v & 0x3) << 2)
+#define VS2STS_BVALID_STS						(1 << 0)
+
+#define VS3_CHGD_IDP_SRC_EN						(1 << 6)
+#define VS3_IDPULLUP_WK_EN						(1 << 5)
+#define VS3_SW_USB_DET							(1 << 4)
+#define VS3_DATA_CONTACT_DET_EN					(1 << 3)
+#define VS3_REG3V3_VSEL(v)					   (v & 0x7)
+
+#define VS4_ACA_DET_EN							(1 << 6)
+#define VS4_RABUSIN_EN							(1 << 5)
+#define VS4_R1KSERIES							(1 << 4)
+#define VS4_PSW_OSOD							(1 << 3)
+#define VS4_PSW_CMOS							(1 << 2)
+#define VS4_CHGD_SERX_DP						(1 << 1)
+#define VS4_CHGD_SERX_DM						(1 << 0)
+
+#define VS5_AUTORESUME_WDOG_EN					(1 << 6)
+#define VS5_ID_FLOAT_EN							(1 << 5)
+#define VS5_ID_RES_EN							(1 << 4)
+#define VS5_SVLDCONWKB_WDOG_EN					(1 << 3)
+#define VS5_VBUS_MNTR_RISE_EN					(1 << 2)
+#define VS5_VBUS_MNTR_FALL_EN					(1 << 1)
+#define VS5_REG3V3IN_MNTR_EN					(1 << 0)
+
+#define DEBUG_LINESTATE                       (0x3 << 0)
+
+#define OTGCTRL_USEEXTVBUS_INDICATOR			(1 << 7)
+#define OTGCTRL_DRVVBUSEXTERNAL					(1 << 6)
+#define OTGCTRL_DRVVBUS							(1 << 5)
+#define OTGCTRL_CHRGVBUS						(1 << 4)
+#define OTGCTRL_DISCHRGVBUS						(1 << 3)
+#define OTGCTRL_DMPULLDOWN						(1 << 2)
+#define OTGCTRL_DPPULLDOWN						(1 << 1)
+#define OTGCTRL_IDPULLUP						(1 << 0)
+
+#define FUNCCTRL_SUSPENDM						(1 << 6)
+#define FUNCCTRL_RESET							(1 << 5)
+#define FUNCCTRL_OPMODE(v)				((v & 0x3) << 3)
+#define FUNCCTRL_TERMSELECT						(1 << 2)
+#define FUNCCTRL_XCVRSELECT(v)					(v & 0x3)
+
+#define PWCTRL_HWDETECT							(1 << 7)
+#define PWCTRL_DP_VSRC_EN						(1 << 6)
+#define PWCTRL_VDAT_DET							(1 << 5)
+#define PWCTRL_DP_WKPU_EN						(1 << 4)
+#define PWCTRL_BVALID_FALL						(1 << 3)
+#define PWCTRL_BVALID_RISE						(1 << 2)
+#define PWCTRL_DET_COMP							(1 << 1)
+#define PWCTRL_SW_CONTROL						(1 << 0)
+
+
+#define PMIC_VLDOCNT                0xAF
+#define PMIC_VLDOCNT_VUSBPHYEN      (1 << 2)
+
+#define PMIC_TLP1ESBS0I1VNNBASE		0X6B
+#define PMIC_I2COVRDADDR			0x59
+#define PMIC_I2COVROFFSET			0x5A
+#define PMIC_USBPHYCTRL				0x30
+#define PMIC_I2COVRWRDATA			0x5B
+#define PMIC_I2COVRCTRL				0x58
+#define PMIC_I2COVRCTL_I2CWR		0x01
+
+#define USBPHYCTRL_D0			(1 << 0)
+#define PMIC_USBIDCTRL				0x19
+#define USBIDCTRL_ACA_DETEN_D1	(1 << 1)
+#define USBIDCTRL_USB_IDEN_D0	(1 << 0)
+#define PMIC_USBIDSTS				0x1A
+#define USBIDSTS_ID_GND			(1 << 0)
+#define USBIDSTS_ID_RARBRC_STS(v)	((v & 0x3)  << 0)
+#define USBIDSTS_ID_FLOAT_STS	(1 << 3)
+#define PMIC_USBPHYCTRL_D0		(1 << 0)
+#define APBFC_EXIOTG3_MISC0_REG			0xF90FF85C
+
+#define DATACON_TIMEOUT		750
+#define DATACON_INTERVAL	10
+#define VBUS_TIMEOUT	300
+#define PCI_DEVICE_ID_DWC 0x119E
+#endif /* __DWC3_INTEL_H */
diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h
index e34bce3..0373e75 100644
--- a/include/linux/usb/hcd.h
+++ b/include/linux/usb/hcd.h
@@ -119,6 +119,7 @@ struct usb_hcd {
 #define HCD_FLAG_WAKEUP_PENDING		4	/* root hub is resuming? */
 #define HCD_FLAG_RH_RUNNING		5	/* root hub is running? */
 #define HCD_FLAG_DEAD			6	/* controller has died? */
+#define HCD_FLAG_IRQ_DISABLED	 7	/* Interrupt was disabled */
 
 	/* The flags can be tested using these macros; they are likely to
 	 * be slightly faster than test_bit().
@@ -129,6 +130,7 @@ struct usb_hcd {
 #define HCD_WAKEUP_PENDING(hcd)	((hcd)->flags & (1U << HCD_FLAG_WAKEUP_PENDING))
 #define HCD_RH_RUNNING(hcd)	((hcd)->flags & (1U << HCD_FLAG_RH_RUNNING))
 #define HCD_DEAD(hcd)		((hcd)->flags & (1U << HCD_FLAG_DEAD))
+#define HCD_IRQ_DISABLED(hcd)	((hcd)->flags & (1U << HCD_FLAG_IRQ_DISABLED))
 
 	/* Flags that get set only during HCD registration or removal. */
 	unsigned		rh_registered:1;/* is root hub registered? */
@@ -142,6 +144,7 @@ struct usb_hcd {
 	unsigned		wireless:1;	/* Wireless USB HCD */
 	unsigned		authorized_default:1;
 	unsigned		has_tt:1;	/* Integrated TT in root hub */
+	unsigned		has_wakeup_irq:1; /* Can IRQ when suspended */
 	unsigned		amd_resume_bug:1; /* AMD remote wakeup quirk */
 
 	unsigned int		irq;		/* irq allocated */
diff --git a/include/linux/usb/penwell_otg.h b/include/linux/usb/penwell_otg.h
new file mode 100644
index 0000000..bf80b75
--- /dev/null
+++ b/include/linux/usb/penwell_otg.h
@@ -0,0 +1,515 @@
+/*
+ * Intel Penwell USB OTG transceiver driver
+ * Copyright (C) 2009 - 2010, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+#ifndef __PENWELL_OTG_H__
+#define __PENWELL_OTG_H__
+
+#include <linux/usb/intel_mid_otg.h>
+#include <linux/power_supply.h>
+#include <linux/wakelock.h>
+
+#define PMU_OTG_WAKE_SOURCE     6
+#define CI_USBCMD		0x30
+#	define USBCMD_RST		BIT(1)
+#	define USBCMD_RS		BIT(0)
+#define CI_USBSTS		0x34
+#	define USBSTS_SLI		BIT(8)
+#	define USBSTS_URI		BIT(6)
+#	define USBSTS_PCI		BIT(2)
+#define CI_USBINTR		0x38
+#	define USBINTR_PCE		BIT(2)
+#define CI_ULPIVP		0x60
+#	define ULPI_WU			BIT(31)
+#	define ULPI_RUN			BIT(30)
+#	define ULPI_RW			BIT(29)
+#	define ULPI_SS			BIT(27)
+#	define ULPI_PORT		(BIT(26) | BIT(25) | BIT(24))
+#	define ULPI_ADDR		(0xff << 16)
+#	define ULPI_DATRD		(0xff << 8)
+#	define ULPI_DATWR		(0xff << 0)
+#define CI_PORTSC1		0x74
+#	define PORTSC_PP		BIT(12)
+#	define PORTSC_LS		(BIT(11) | BIT(10))
+#	define PORTSC_SUSP		BIT(7)
+#	define PORTSC_CCS		BIT(0)
+#define CI_HOSTPC1		0xb4
+#	define HOSTPC1_PHCD		BIT(22)
+#define CI_OTGSC		0xf4
+#	define OTGSC_DPIE		BIT(30)
+#	define OTGSC_1MSE		BIT(29)
+#	define OTGSC_BSEIE		BIT(28)
+#	define OTGSC_BSVIE		BIT(27)
+#	define OTGSC_ASVIE		BIT(26)
+#	define OTGSC_AVVIE		BIT(25)
+#	define OTGSC_IDIE		BIT(24)
+#	define OTGSC_DPIS		BIT(22)
+#	define OTGSC_1MSS		BIT(21)
+#	define OTGSC_BSEIS		BIT(20)
+#	define OTGSC_BSVIS		BIT(19)
+#	define OTGSC_ASVIS		BIT(18)
+#	define OTGSC_AVVIS		BIT(17)
+#	define OTGSC_IDIS		BIT(16)
+#	define OTGSC_DPS		BIT(14)
+#	define OTGSC_1MST		BIT(13)
+#	define OTGSC_BSE		BIT(12)
+#	define OTGSC_BSV		BIT(11)
+#	define OTGSC_ASV		BIT(10)
+#	define OTGSC_AVV		BIT(9)
+#	define OTGSC_ID			BIT(8)
+#	define OTGSC_HABA		BIT(7)
+#	define OTGSC_HADP		BIT(6)
+#	define OTGSC_IDPU		BIT(5)
+#	define OTGSC_DP			BIT(4)
+#	define OTGSC_OT			BIT(3)
+#	define OTGSC_HAAR		BIT(2)
+#	define OTGSC_VC			BIT(1)
+#	define OTGSC_VD			BIT(0)
+#define CI_USBMODE		0xf8
+#	define USBMODE_CM		(BIT(1) | BIT(0))
+#	define USBMODE_IDLE		0
+#	define USBMODE_DEVICE		0x2
+#	define USBMODE_HOST		0x3
+#define USBCFG_ADDR			0xff10801c
+#define USBCFG_LEN			4
+#	define USBCFG_VBUSVAL		BIT(14)
+#	define USBCFG_AVALID		BIT(13)
+#	define USBCFG_BVALID		BIT(12)
+#	define USBCFG_SESEND		BIT(11)
+
+#define OTGSC_INTEN_MASK \
+	(OTGSC_DPIE | OTGSC_BSEIE | OTGSC_BSVIE \
+	| OTGSC_ASVIE | OTGSC_AVVIE | OTGSC_IDIE)
+
+#define OTGSC_INTSTS_MASK \
+	(OTGSC_DPIS | OTGSC_BSEIS | OTGSC_BSVIS \
+	| OTGSC_ASVIS | OTGSC_AVVIS | OTGSC_IDIS)
+
+#define INTR_DUMMY_MASK (USBSTS_SLI | USBSTS_URI | USBSTS_PCI)
+
+#define HOST_REQUEST_FLAG		BIT(0)
+
+/* MSIC register for vbus power control */
+#define MSIC_ID			0x00
+#	define ID0_VENDID0		(BIT(7) | BIT(6))
+#define MSIC_ID1		0x01
+#	define ID1_VENDID1		(BIT(7) | BIT(6))
+#define MSIC_VUSB330CNT		0xd4
+#define MSIC_VOTGCNT		0xdf
+#	define VOTGEN			BIT(7)
+#	define VOTGRAMP			BIT(4)
+#define MSIC_SPWRSRINT1		0x193
+#	define SUSBCHPDET		BIT(6)
+#	define SUSBDCDET		BIT(2)
+#	define MSIC_SPWRSRINT1_MASK	(BIT(6) | BIT(2))
+#	define SPWRSRINT1_CDP		BIT(6)
+#	define SPWRSRINT1_SDP		0
+#	define SPWRSRINT1_DCP		BIT(2)
+#define MSIC_USB_MISC		0x2c8	/* Intel Specific */
+#	define MISC_CHGDSERXDPINV	BIT(5)
+#define MSIC_OTGCTRL		0x39c
+#define MSIC_OTGCTRLSET		0x340
+#define MSIC_OTGCTRLCLR		0x341
+#define	ULPI_OTGCTRL		0x0a
+#define	ULPI_OTGCTRLSET		0x0b
+#define	ULPI_OTGCTRLCLR		0x0c
+#	define DRVVBUS_EXTERNAL		BIT(6)
+#	define DRVVBUS			BIT(5)
+#	define DMPULLDOWN		BIT(2)
+#	define DPPULLDOWN		BIT(1)
+#define MSIC_USBINTEN_RISE	0x39d
+#define MSIC_USBINTEN_RISESET	0x39e
+#define MSIC_USBINTEN_RISECLR	0x39f
+#define MSIC_USBINTEN_FALL	0x3a0
+#define MSIC_USBINTEN_FALLSET	0x3a1
+#define MSIC_USBINTEN_FALLCLR	0x3a2
+
+/*
+ * For Clovertrail, due to change of USB PHY from MSIC to external standalone
+ * chip, USB Interrupt Enable Rising/Falling registers can be accessed only
+ * from ULPI interface.
+ */
+#define ULPI_USBINTEN_RISING		0xd
+#define ULPI_USBINTEN_RISINGSET		0xe
+#define ULPI_USBINTEN_RISINGCLR		0xf
+#define ULPI_USBINTEN_FALLING		0x10
+#define ULPI_USBINTEN_FALLINGSET	0x11
+#define ULPI_USBINTEN_FALLINGCLR	0x12
+
+#	define IDGND			BIT(4)
+#	define SESSEND			BIT(3)
+#	define SESSVLD			BIT(2)
+#	define VBUSVLD			BIT(1)
+#	define HOSTDISCON		BIT(0)
+#define MSIC_PWRCTRL		0x3b5
+#define MSIC_PWRCTRLSET		0x342
+#define MSIC_PWRCTRLCLR		0x343
+#define ULPI_PWRCTRL		0x3d
+#define ULPI_PWRCTRLSET		0x3e
+#define ULPI_PWRCTRLCLR		0x3f
+#	define HWDET			BIT(7)
+#	define DPVSRCEN			BIT(6)
+#	define VDATDET			BIT(5)
+#	define DPWKPUEN			BIT(4)
+#	define SWCNTRL			BIT(0)
+#define MSIC_FUNCTRL		0x398
+#define MSIC_FUNCTRLSET		0x344
+#define MSIC_FUNCTRLCLR		0x345
+#define ULPI_FUNCTRL		0x04
+#define ULPI_FUNCTRLSET		0x05
+#define ULPI_FUNCTRLCLR		0x06
+#	define PHYRESET			BIT(5)
+#	define OPMODE1			BIT(4)
+#	define OPMODE0			BIT(3)
+#	define TERMSELECT		BIT(2)
+#	define XCVRSELECT1		BIT(1)
+#	define XCVRSELECT0		BIT(0)
+#define MSIC_DEBUG		0x3a5
+#define ULPI_DEBUG		0x15
+#	define LINESTATE_MSK		(BIT(0) | BIT(1))
+#	define LINESTATE_SE1		(BIT(0) | BIT(1))
+#	define LINESTATE_SE0		(0)
+#	define LINESTATE_FSJ		BIT(0)
+#	define LINESTATE_FSK		BIT(1)
+#define MSIC_VS1		0x3b6
+#define MSIC_VS1SET		0x3a9
+#define MSIC_VS1CLR		0x3aa
+#define ULPI_VS1		0x80
+#define ULPI_VS1SET		0x81
+#define ULPI_VS1CLR		0x82
+#	define DATAPOLARITY		BIT(6)
+#define ULPI_VS2STS		0x83
+#define ULPI_VS2LATCH		0x84
+#	define VBUS_MNTR_STS		BIT(7)
+#	define REG3V3_MNTR_STS		BIT(6)
+#	define SVLDCONWKB_WDOG_STS	BIT(5)
+#	define IDFLOAT_STS		BIT(4)
+#	define IDRARBRC_STS(d)		(((d)>>2)&3)
+#	define IDRARBRC_STS1		BIT(3)
+#	define IDRARBRC_STS2		BIT(2)
+#	define IDRARBRC_MSK		(BIT(2) | BIT(3))
+#	define IDRARBRC_A		1
+#	define IDRARBRC_B		2
+#	define IDRARBRC_C		3
+#	define BVALID_STS		BIT(0)
+#define MSIC_VS3		0x3b9
+#define MSIC_VS3SET		0x346	/* Vendor Specific */
+#define MSIC_VS3CLR		0x347
+#	define SWUSBDET			BIT(4)
+#	define DATACONEN		BIT(3)
+#define ULPI_VS3		0x85
+#define ULPI_VS3SET		0x86
+#define ULPI_VS3CLR		0x87
+#	define CHGD_IDP_SRC		BIT(6)
+#	define IDPULLUP_WK		BIT(5)
+#	define SWUSBDET			BIT(4)
+#	define DATACONEN		BIT(3)
+#define MSIC_VS4		0x3ba
+#define MSIC_VS4SET		0x3ab
+#define MSIC_VS4CLR		0x3ac
+#define ULPI_VS4		0x88
+#define ULPI_VS4SET		0x89
+#define ULPI_VS4CLR		0x8a
+#	define ACADET			BIT(6)
+#	define RABUSIN			BIT(5)
+#	define R1KERIES			BIT(4)
+#	define CHRG_SERX_DP		BIT(1)
+#	define CHRG_SERX_DM		BIT(0)
+#define ULPI_VS5		0x8b
+#define ULPI_VS5SET		0x8c
+#define ULPI_VS5CLR		0x8d
+#	define AUTORESUME_WDOG		BIT(6)
+#	define IDFLOAT_EN		BIT(5)
+#	define IDRES_EN			BIT(4)
+#	define SVLDCONWKB_WDOG		BIT(3)
+#	define VBUS_MNTR_RISEEN		BIT(2)
+#	define VBUS_MNTR_FALLEN		BIT(1)
+#	define REG3V3IN_MNTR_EN		BIT(0)
+#define ULPI_VS6		0x8e
+#define ULPI_VS6SET		0x8f
+#define ULPI_VS6CLR		0x90
+#	define ACA_RID_B_CFG		BIT(7)
+#	define ACA_RID_A_CFG		BIT(6)
+#	define SOF_EN			BIT(5)
+#define MSIC_ULPIACCESSMODE	0x348
+#	define SPIMODE			BIT(0)
+#define MSIC_INT_EN_RISE	0x39D
+#define MSIC_INT_EN_RISE_SET	0x39E
+#define MSIC_INT_EN_RISE_CLR	0x39F
+#define MSIC_INT_EN_FALL	0x3A0
+#define MSIC_INT_EN_FALL_SET	0x3A1
+#define MSIC_INT_EN_FALL_CLR	0x3A2
+
+/* MSIC TI implementation for ADP/ACA */
+#define SPI_TI_VS2		0x3B7
+#define SPI_TI_VS2_LATCH	0x3B8
+#define SPI_TI_VS4		0x3BA
+#define SPI_TI_VS5		0x3BB
+#define ULPI_TI_USB_INT_STS	0x13
+#define ULPI_TI_USB_INT_LAT	0x14
+#	define USB_INT_IDGND		BIT(4)
+#	define USB_INT_SESSEND		BIT(3)
+#	define USB_INT_SESSVLD		BIT(2)
+#	define USB_INT_VBUSVLD		BIT(1)
+#define ULPI_TI_VS2		0x83
+#	define TI_ID_FLOAT_STS		BIT(4)
+#	define TI_ID_RARBRC_STS(d)	(((d)>>2)&3)
+#	define TI_ID_RARBRC_STS_MASK	(BIT(3) | BIT(2))
+#	define TI_ID_RARBRC_NONE	0
+#	define TI_ID_RARBRC_A		1
+#	define TI_ID_RARBRC_B		2
+#	define TI_ID_RARBRC_C		3
+#	define TI_ADP_INT_STS		BIT(1)
+#define ULPI_TI_VS4		0x88
+#	define TI_ACA_DET_EN		BIT(6)
+#define ULPI_TI_VS5		0x8b
+#	define TI_ADP_INT_EN		BIT(7)
+#	define TI_ID_FLOAT_EN		BIT(5)
+#	define TI_ID_RES_EN		BIT(4)
+#define ULPI_TI_VS6		0x8e
+#	define TI_HS_TXPREN		BIT(4)
+#	define TI_ADP_MODE(d)		(((d)>>2)&3)
+#	define TI_ADP_MODE_MASK		(BIT(3) | BIT(2))
+#	define TI_ADP_MODE_DISABLE	0
+#	define TI_ADP_MODE_SENSE	1
+#	define TI_ADP_MODE_PRB_A	2
+#	define TI_ADP_MODE_PRB_B	3
+#	define TI_VBUS_IADP_SRC		BIT(1)
+#	define TI_VBUS_IADP_SINK	BIT(0)
+#define ULPI_TI_VS7		0x91
+#	define TI_T_ADP_HIGH		(0xff)
+#define ULPI_TI_VS8		0x94
+#	define TI_T_ADP_LOW		(0xff)
+#define ULPI_TI_VS9		0x97
+#	define TI_T_ADP_RISE		(0xff)
+
+#define TI_PRB_DELTA			0x08
+
+/* MSIC FreeScale Implementation for ADP */
+#define ULPI_FS_ADPCL		0x28
+#	define ADPCL_PRBDSCHG		(BIT(5) | BIT(6))
+#	define ADPCL_PRBDSCHG_4		0
+#	define ADPCL_PRBDSCHG_8		1
+#	define ADPCL_PRBDSCHG_16	2
+#	define ADPCL_PRBDSCHG_32	3
+#	define ADPCL_PRBPRD		(BIT(3) | BIT(4))
+#	define ADPCL_PRBPRD_A_HALF	0
+#	define ADPCL_PRBPRD_B_HALF	1
+#	define ADPCL_PRBPRD_A		2
+#	define ADPCL_PRBPRD_B		3
+#	define ADPCL_SNSEN		BIT(2)
+#	define ADPCL_PRBEN		BIT(1)
+#	define ADPCL_ADPEN		BIT(0)
+#define ULPI_FS_ADPCH		0x29
+#	define ADPCH_PRBDELTA		(0x1f << 0)
+#define ULPI_FS_ADPIE		0x2a
+#	define ADPIE_ADPRAMPIE		BIT(2)
+#	define ADPIE_SNSMISSIE		BIT(1)
+#	define ADPIE_PRBTRGIE		BIT(0)
+#define ULPI_FS_ADPIS		0x2b
+#	define ADPIS_ADPRAMPS		BIT(5)
+#	define ADPIS_SNSMISSS		BIT(4)
+#	define ADPIS_PRBTRGS		BIT(3)
+#	define ADPIS_ADPRAMPI		BIT(2)
+#	define ADPIS_SNSMISSI		BIT(1)
+#	define ADPIS_PRBTRGI		BIT(0)
+#define ULPI_FS_ADPRL		0x2c
+#	define ADPRL_ADPRAMP		(0xff << 0)
+#define ULPI_FS_ADPRH		0x2d
+#	define ADPRH_ADPRAMP		(0x7 << 0)
+
+#define FS_ADPI_MASK	(ADPIS_ADPRAMPI | ADPIS_SNSMISSI | ADPIS_PRBTRGI)
+
+/* define Data connect checking timeout and polling interval */
+#define DATACON_TIMEOUT		750
+#define DATACON_INTERVAL	20
+
+enum penwell_otg_timer_type {
+	TA_WAIT_VRISE_TMR,
+	TA_WAIT_BCON_TMR,
+	TA_AIDL_BDIS_TMR,
+	TA_BIDL_ADIS_TMR,
+	TA_WAIT_VFALL_TMR,
+	TB_ASE0_BRST_TMR,
+	TB_SE0_SRP_TMR,
+	TB_SRP_FAIL_TMR, /* wait for response of SRP */
+	TB_BUS_SUSPEND_TMR,
+	TTST_MAINT_TMR,
+	TTST_NOADP_TMR,
+};
+
+#define TA_WAIT_VRISE		100
+#define TA_WAIT_BCON		50000
+#define TA_AIDL_BDIS		1500
+#define TA_BIDL_ADIS		300
+#define TA_WAIT_VFALL		950
+#define TB_ASE0_BRST		300
+#define TB_SE0_SRP		1200
+#define TB_SSEND_SRP		1800
+#	define SRP_MON_INVAL	300	/* TODO: interval needs more tuning */
+#define TB_SRP_FAIL		5500
+#define TB_BUS_SUSPEND		500
+#define THOS_REQ_POL		1500
+/* Test mode */
+#define	TTST_MAINT		9900
+#define	TTST_NOADP		5000
+
+/* MSIC vendor information */
+enum msic_vendor {
+	MSIC_VD_FS,
+	MSIC_VD_TI,
+	MSIC_VD_UNKNOWN
+};
+
+/* charger defined in BC 1.2 */
+enum usb_charger_type {
+	CHRG_UNKNOWN,
+	CHRG_SDP,	/* Standard Downstream Port */
+	CHRG_CDP,	/* Charging Downstream Port */
+	CHRG_SDP_INVAL,	/* Invaild Standard Downstream Port */
+	CHRG_DCP,	/* Dedicated Charging Port */
+	CHRG_ACA,	/* Accessory Charger Adapter */
+	CHRG_ACA_DOCK,	/* Accessory Charger Adapter - Dock */
+	CHRG_ACA_A,	/* Accessory Charger Adapter - RID_A */
+	CHRG_ACA_B,	/* Accessory Charger Adapter - RID_B */
+	CHRG_ACA_C,	/* Accessory Charger Adapter - RID_C */
+	CHRG_SE1,	/* SE1 (Apple)*/
+	CHRG_MHL	/* Moblie High-Definition Link */
+};
+
+struct adp_status {
+	struct completion	adp_comp;
+	u8			t_adp_rise;
+};
+
+/* Invalid SDP checking timeout */
+#define INVALID_SDP_TIMEOUT	(HZ * 15)
+
+/* OTG Battery Charging capability is used in charger capability detection */
+struct otg_bc_cap {
+	enum usb_charger_type	chrg_type;
+	unsigned int		ma;
+#define CHRG_CURR_UNKNOWN	0
+#define CHRG_CURR_DISCONN	0
+#define CHRG_CURR_SDP_SUSP	2
+#define CHRG_CURR_SDP_UNCONFIG	100
+#define CHRG_CURR_SDP_LOW	100
+#define CHRG_CURR_SDP_HIGH	500
+#define CHRG_CURR_SDP_INVAL	500
+#define CHRG_CURR_CDP		1500
+#define CHRG_CURR_DCP	1500
+#define CHRG_CURR_SE1	1500
+#define CHRG_CURR_ACA	1500
+	unsigned int            current_event;
+};
+
+struct otg_bc_event {
+	struct list_head		node;
+	struct power_supply_cable_props	cap;
+};
+
+/* Bus monitor action for b_ssend_srp/b_se0_srp */
+#define BUS_MON_STOP		0
+#define BUS_MON_START		1
+#define BUS_MON_CONTINUE	2
+
+/* define event ids to notify battery driver */
+#define USBCHRG_EVENT_CONNECT	1
+#define USBCHRG_EVENT_DISCONN	2
+#define USBCHRG_EVENT_SUSPEND	3
+#define USBCHRG_EVENT_RESUME	4
+#define USBCHRG_EVENT_UPDATE	5
+
+struct intel_mid_otg_pdata {
+	int gpio_vbus;
+	int gpio_cs;
+	int gpio_reset;
+	int charging_compliance;
+	int hnp_poll_support;
+	unsigned power_budget;
+};
+
+struct penwell_otg {
+	struct intel_mid_otg_xceiv	iotg;
+	struct device			*dev;
+
+	unsigned			region;
+	unsigned			cfg_region;
+
+	struct work_struct		work;
+	struct work_struct		hnp_poll_work;
+	struct work_struct		psc_notify;
+	struct work_struct		uevent_work;
+	struct delayed_work		ulpi_poll_work;
+	struct delayed_work		ulpi_check_work;
+	struct delayed_work		sdp_check_work;
+	struct workqueue_struct		*qwork;
+	struct workqueue_struct		*chrg_qwork;
+
+
+	struct timer_list		hsm_timer;
+	struct timer_list		hnp_poll_timer;
+	struct timer_list		bus_mon_timer;
+
+	unsigned long			b_se0_srp_time;
+	unsigned long			b_ssend_srp_time;
+
+	struct mutex			msic_mutex;
+	enum msic_vendor		msic;
+
+	struct notifier_block		iotg_notifier;
+	int				queue_stop;
+
+	struct adp_status		adp;
+
+	spinlock_t			charger_lock;
+	struct list_head		chrg_evt_queue;
+	struct otg_bc_cap		charging_cap;
+	spinlock_t			cap_lock;
+	struct power_supply_cable_props psc_cap;
+	int (*bc_callback)(void *arg, int event, struct otg_bc_cap *cap);
+	void				*bc_arg;
+
+	unsigned			rt_resuming;
+
+	unsigned			rt_quiesce;
+	struct intel_mid_otg_pdata	*otg_pdata;
+
+	struct wake_lock		wake_lock;
+	spinlock_t			lock;
+
+	int				phy_power_state;
+};
+
+static inline
+struct penwell_otg *iotg_to_penwell(struct intel_mid_otg_xceiv *iotg)
+{
+	return container_of(iotg, struct penwell_otg, iotg);
+}
+
+extern int penwell_otg_query_charging_cap(struct otg_bc_cap *cap);
+extern int penwell_otg_query_power_supply_cap(
+			struct power_supply_cable_props *cap);
+extern void *penwell_otg_register_bc_callback(
+	int (*cb)(void *, int, struct otg_bc_cap *), void *arg);
+extern int penwell_otg_unregister_bc_callback(void *handler);
+
+extern int pnw_otg_ulpi_write(u8 reg, u8 val);
+extern int is_clovertrail(struct pci_dev *pdev);
+
+#endif /* __PENWELL_OTG_H__ */
diff --git a/include/linux/wlan_plat.h b/include/linux/wlan_plat.h
new file mode 100644
index 0000000..98bbea0
--- /dev/null
+++ b/include/linux/wlan_plat.h
@@ -0,0 +1,29 @@
+/* include/linux/wlan_plat.h
+ *
+ * Copyright (C) 2010 Google, Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _LINUX_WLAN_PLAT_H_
+#define _LINUX_WLAN_PLAT_H_
+
+struct wifi_platform_data {
+	int (*set_power)(int val);
+	int (*set_reset)(int val);
+	int (*set_carddetect)(int val);
+	void *(*mem_prealloc)(int section, unsigned long size);
+	int (*get_mac_addr)(unsigned char *buf);
+	void *(*get_country_code)(char *ccode);
+	char *nvram_id;
+	bool use_fast_irq;
+};
+
+#endif
diff --git a/include/uapi/linux/usb/ch9.h b/include/uapi/linux/usb/ch9.h
index aa33fd1..29860d6 100644
--- a/include/uapi/linux/usb/ch9.h
+++ b/include/uapi/linux/usb/ch9.h
@@ -294,6 +294,7 @@ struct usb_device_descriptor {
 #define USB_CLASS_CSCID			0x0b	/* chip+ smart card */
 #define USB_CLASS_CONTENT_SEC		0x0d	/* content security */
 #define USB_CLASS_VIDEO			0x0e
+#define USB_CLASS_DEBUG			0xdc
 #define USB_CLASS_WIRELESS_CONTROLLER	0xe0
 #define USB_CLASS_MISC			0xef
 #define USB_CLASS_APP_SPEC		0xfe
-- 
1.7.5.4

