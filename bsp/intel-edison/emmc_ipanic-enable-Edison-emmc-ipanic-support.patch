From 9862e0354f405c2631959fbc5f7be78415e61508 Mon Sep 17 00:00:00 2001
From: Liwei Song <liwei.song@windriver.com>
Date: Tue, 1 Mar 2016 20:29:08 -0500
Subject: [PATCH 11/11] emmc_ipanic: enable Edison emmc ipanic support

This patch is from yocto Intel Edison support:
http://downloadmirror.intel.com/25028/eng/edison-src-ww25.5-15.tgz

This is emmc reatleated feature, use to detect and deal with the
emmc partion panic happen.

Signed-off-by: Liwei Song <liwei.song@windriver.com>
---
 arch/x86/Kconfig.cpu                               |   19 +-
 arch/x86/Makefile                                  |    2 +
 arch/x86/Makefile_32.cpu                           |    2 +
 arch/x86/include/asm/apb_timer.h                   |    1 +
 arch/x86/include/asm/intel-mid.h                   |    5 +
 arch/x86/include/asm/intel_basincove_ocd.h         |  161 +++
 arch/x86/include/asm/module.h                      |    2 +-
 arch/x86/include/asm/mwait.h                       |    6 +
 arch/x86/include/asm/required-features.h           |    2 +-
 arch/x86/kernel/early_printk.c                     |    7 +-
 arch/x86/platform/intel-mid/Makefile               |    3 +
 arch/x86/platform/intel-mid/device_libs/Makefile   |   15 +-
 .../intel-mid/device_libs/pci/platform_sdhci_pci.c |   11 -
 .../intel-mid/device_libs/platform_bq24261.c       |   77 ++
 .../intel-mid/device_libs/platform_max3111.c       |   56 +-
 .../device_libs/platform_mrfl_regulator.c          |  125 +++
 .../device_libs/platform_msic_power_btn.c          |   67 +-
 .../intel-mid/device_libs/platform_pcal9555a.c     |   68 ++
 .../intel-mid/device_libs/platform_soc_thermal.c   |  136 +++
 .../intel-mid/device_libs/platform_spidev.c        |   73 ++
 .../platform/intel-mid/device_libs/platform_wifi.c |    2 -
 .../intel-mid/device_libs/platform_wm8994.c        |  243 ++++
 .../platform/intel-mid/early_printk_intel_mid.c    |  343 ++++++-
 arch/x86/platform/intel-mid/intel_soc_debug.c      |  202 ++++
 drivers/acpi/acpi_platform.c                       |    2 +
 drivers/dma/intel_mid_dma_acpi.c                   |  119 --
 drivers/i2c/busses/i2c-designware-core.c           |   93 --
 drivers/i2c/busses/i2c-designware-platdrv.c        |   49 +-
 drivers/idle/intel_idle.c                          |  356 ++++++-
 drivers/misc/bcm-lpm/bcm_bt_lpm.c                  |  106 --
 drivers/misc/emmc_ipanic.c                         | 1158 ++++++++++++++++++++
 drivers/misc/emmc_ipanic.h                         |   96 ++
 drivers/mmc/core/Makefile                          |    2 +-
 drivers/mmc/core/core.c                            |    1 +
 drivers/mmc/core/mmc_panic_ops.c                   |  837 ++++++++++++++
 drivers/mmc/host/sdhci-pci.h                       |    1 -
 drivers/power/power_supply_sysfs.c                 |   15 +-
 drivers/spi/spi-dw-mid.c                           |    2 +-
 drivers/spi/spi-dw-pci.c                           |    2 +-
 drivers/spi/spi-dw.c                               |    3 -
 drivers/tty/serial/mfd_dma.c                       |   24 -
 drivers/tty/serial/mfd_plat.c                      |   26 -
 drivers/tty/serial/mrst_max3110.c                  |   40 +-
 drivers/usb/Kconfig                                |    2 +
 drivers/usb/dwc3/otg.c                             |    8 +-
 include/linux/mfd/intel_msic.h                     |   42 +
 include/linux/panic_gbuffer.h                      |   37 +
 include/linux/wl12xx.h                             |    5 +
 kernel/irq/chip.c                                  |    1 +
 kernel/irq/settings.h                              |    7 +
 kernel/printk/printk.c                             |   18 +-
 51 files changed, 4159 insertions(+), 521 deletions(-)
 create mode 100644 arch/x86/include/asm/intel_basincove_ocd.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_bq24261.c
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_mrfl_regulator.c
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_pcal9555a.c
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_soc_thermal.c
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_spidev.c
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_wm8994.c
 create mode 100644 arch/x86/platform/intel-mid/intel_soc_debug.c
 create mode 100644 drivers/misc/emmc_ipanic.c
 create mode 100644 drivers/misc/emmc_ipanic.h
 create mode 100644 drivers/mmc/core/mmc_panic_ops.c
 create mode 100644 include/linux/panic_gbuffer.h

diff --git a/arch/x86/Kconfig.cpu b/arch/x86/Kconfig.cpu
index f3aaf23..86e4080 100644
--- a/arch/x86/Kconfig.cpu
+++ b/arch/x86/Kconfig.cpu
@@ -269,6 +269,15 @@ config MATOM
 	  accordingly optimized code. Use a recent GCC with specific Atom
 	  support in order to fully benefit from selecting this option.
 
+config MSLM
+	bool "Intel Silvermont (Atom)"
+	---help---
+
+	  Select this for the Intel Silvermont (Atom) platform. Intel Atom
+	  CPUs have an in-order pipelining architecture and thus can benefit
+	  from accordingly optimized code. Use a recent GCC with specific
+	  Atom support in order to fully benefit from selecting this option.
+
 config GENERIC_CPU
 	bool "Generic-x86-64"
 	depends on X86_64
@@ -300,7 +309,7 @@ config X86_INTERNODE_CACHE_SHIFT
 config X86_L1_CACHE_SHIFT
 	int
 	default "7" if MPENTIUM4 || MPSC
-	default "6" if MK7 || MK8 || MPENTIUMM || MCORE2 || MATOM || MVIAC7 || X86_GENERIC || GENERIC_CPU
+	default "6" if MK7 || MK8 || MPENTIUMM || MCORE2 || MATOM || MSLM || MVIAC7 || X86_GENERIC || GENERIC_CPU
 	default "4" if MELAN || M486 || MGEODEGX1
 	default "5" if MWINCHIP3D || MWINCHIPC6 || MCRUSOE || MEFFICEON || MCYRIXIII || MK6 || MPENTIUMIII || MPENTIUMII || M686 || M586MMX || M586TSC || M586 || MVIAC3_2 || MGEODE_LX
 
@@ -335,7 +344,7 @@ config X86_INTEL_USERCOPY
 
 config X86_USE_PPRO_CHECKSUM
 	def_bool y
-	depends on MWINCHIP3D || MWINCHIPC6 || MCYRIXIII || MK7 || MK6 || MPENTIUM4 || MPENTIUMM || MPENTIUMIII || MPENTIUMII || M686 || MK8 || MVIAC3_2 || MVIAC7 || MEFFICEON || MGEODE_LX || MCORE2 || MATOM
+	depends on MWINCHIP3D || MWINCHIPC6 || MCYRIXIII || MK7 || MK6 || MPENTIUM4 || MPENTIUMM || MPENTIUMIII || MPENTIUMII || M686 || MK8 || MVIAC3_2 || MVIAC7 || MEFFICEON || MGEODE_LX || MCORE2 || MATOM || MSLM
 
 config X86_USE_3DNOW
 	def_bool y
@@ -359,17 +368,17 @@ config X86_P6_NOP
 
 config X86_TSC
 	def_bool y
-	depends on ((MWINCHIP3D || MCRUSOE || MEFFICEON || MCYRIXIII || MK7 || MK6 || MPENTIUM4 || MPENTIUMM || MPENTIUMIII || MPENTIUMII || M686 || M586MMX || M586TSC || MK8 || MVIAC3_2 || MVIAC7 || MGEODEGX1 || MGEODE_LX || MCORE2 || MATOM) && !X86_NUMAQ) || X86_64
+	depends on ((MWINCHIP3D || MCRUSOE || MEFFICEON || MCYRIXIII || MK7 || MK6 || MPENTIUM4 || MPENTIUMM || MPENTIUMIII || MPENTIUMII || M686 || M586MMX || M586TSC || MK8 || MVIAC3_2 || MVIAC7 || MGEODEGX1 || MGEODE_LX || MCORE2 || MATOM || MSLM) && !X86_NUMAQ) || X86_64
 
 config X86_CMPXCHG64
 	def_bool y
-	depends on X86_PAE || X86_64 || MCORE2 || MPENTIUM4 || MPENTIUMM || MPENTIUMIII || MPENTIUMII || M686 || MATOM
+	depends on X86_PAE || X86_64 || MCORE2 || MPENTIUM4 || MPENTIUMM || MPENTIUMIII || MPENTIUMII || M686 || MATOM || MSLM
 
 # this should be set for all -march=.. options where the compiler
 # generates cmov.
 config X86_CMOV
 	def_bool y
-	depends on (MK8 || MK7 || MCORE2 || MPENTIUM4 || MPENTIUMM || MPENTIUMIII || MPENTIUMII || M686 || MVIAC3_2 || MVIAC7 || MCRUSOE || MEFFICEON || X86_64 || MATOM || MGEODE_LX)
+	depends on (MK8 || MK7 || MCORE2 || MPENTIUM4 || MPENTIUMM || MPENTIUMIII || MPENTIUMII || M686 || MVIAC3_2 || MVIAC7 || MCRUSOE || MEFFICEON || X86_64 || MATOM || MSLM || MGEODE_LX)
 
 config X86_MINIMUM_CPU_FAMILY
 	int
diff --git a/arch/x86/Makefile b/arch/x86/Makefile
index 0dd99ea..ede3775 100644
--- a/arch/x86/Makefile
+++ b/arch/x86/Makefile
@@ -97,6 +97,8 @@ else
                 $(call cc-option,-march=core2,$(call cc-option,-mtune=generic))
 	cflags-$(CONFIG_MATOM) += $(call cc-option,-march=atom) \
 		$(call cc-option,-mtune=atom,$(call cc-option,-mtune=generic))
+        cflags-$(CONFIG_MSLM) += $(call cc-option,-march=slm) \
+                $(call cc-option,-mtune=slm,$(call cc-option,-mtune=generic))
         cflags-$(CONFIG_GENERIC_CPU) += $(call cc-option,-mtune=generic)
         KBUILD_CFLAGS += $(cflags-y)
 
diff --git a/arch/x86/Makefile_32.cpu b/arch/x86/Makefile_32.cpu
index 6647ed4..a2eb6c6 100644
--- a/arch/x86/Makefile_32.cpu
+++ b/arch/x86/Makefile_32.cpu
@@ -34,6 +34,8 @@ cflags-$(CONFIG_MVIAC7)		+= -march=i686
 cflags-$(CONFIG_MCORE2)		+= -march=i686 $(call tune,core2)
 cflags-$(CONFIG_MATOM)		+= $(call cc-option,-march=atom,$(call cc-option,-march=core2,-march=i686)) \
 	$(call cc-option,-mtune=atom,$(call cc-option,-mtune=generic))
+cflags-$(CONFIG_MSLM)		+= $(call cc-option,-march=slm,$(call cc-option,-march=core2,-march=i686)) \
+	$(call cc-option,-mtune=slm,$(call cc-option,-mtune=generic))
 
 # AMD Elan support
 cflags-$(CONFIG_MELAN)		+= -march=i486
diff --git a/arch/x86/include/asm/apb_timer.h b/arch/x86/include/asm/apb_timer.h
index 0acbac2..2a67dda 100644
--- a/arch/x86/include/asm/apb_timer.h
+++ b/arch/x86/include/asm/apb_timer.h
@@ -44,6 +44,7 @@ extern int sfi_mtimer_num;
 
 static inline unsigned long apbt_quick_calibrate(void) {return 0; }
 static inline void apbt_time_init(void) { }
+static inline void apbt_setup_secondary_clock(void) { }
 
 #endif
 #endif /* ASM_X86_APBT_H */
diff --git a/arch/x86/include/asm/intel-mid.h b/arch/x86/include/asm/intel-mid.h
index a38c793..988184d 100644
--- a/arch/x86/include/asm/intel-mid.h
+++ b/arch/x86/include/asm/intel-mid.h
@@ -212,9 +212,14 @@ extern enum intel_mid_timer_options intel_mid_timer_options;
 extern struct console early_mrst_console;
 extern void mrst_early_console_init(void);
 
+extern struct console early_mrfld_console;
+extern void mrfld_early_console_init(void);
+
 extern struct console early_hsu_console;
 extern void hsu_early_console_init(const char *);
 
+extern struct console early_pti_console;
+
 extern void intel_scu_devices_create(void);
 extern void intel_scu_devices_destroy(void);
 extern void intel_psh_devices_create(void);
diff --git a/arch/x86/include/asm/intel_basincove_ocd.h b/arch/x86/include/asm/intel_basincove_ocd.h
new file mode 100644
index 0000000..eff495e
--- /dev/null
+++ b/arch/x86/include/asm/intel_basincove_ocd.h
@@ -0,0 +1,161 @@
+#ifndef __INTEL_BASINCOVE_OCD_H__
+#define __INTEL_BASINCOVE_OCD_H__
+
+#define DRIVER_NAME "bcove_bcu"
+#define DEVICE_NAME "mrfl_pmic_bcu"
+
+/* Generic bit representaion macros */
+#define B0	(1 << 0)
+#define B1	(1 << 1)
+#define B2	(1 << 2)
+#define B3	(1 << 3)
+#define B4	(1 << 4)
+#define B5	(1 << 5)
+#define B6	(1 << 6)
+#define B7	(1 << 7)
+
+/* 30 seconds delay macro for VWARN1 interrupt Unmask (enable) */
+#define VWARN2_INTR_EN_DELAY	(30 * HZ)
+
+/* IRQ registers */
+#define BCUIRQ                  0x05
+#define IRQLVL1                 0x01
+#define MIRQLVL1                0x0C
+
+/* Status registers */
+#define S_BCUINT                0x3B
+#define S_BCUCTRL               0x49
+
+/* PMIC SRAM address for BCU register */
+#define PMIC_SRAM_BCU_ADDR      0xFFFFF614
+#define IOMAP_LEN               1
+
+#define NUM_VOLT_LEVELS         3
+#define NUM_CURR_LEVELS         2
+
+#define VWARN_EN_MASK		B3
+#define ICCMAXVCC_EN_MASK	B6
+
+#define MVWARN1_MASK		B0
+#define MVWARN2_MASK		B1
+#define MVCRIT_MASK		B2
+
+#define MVCRIT			B2
+#define MVWARN2			B1
+#define MVWARN1			B0
+
+#define ICCMAXVCC_EN		(1 << 6)
+#define VWARN_EN		(1 << 3)
+#define VCRIT_SHUTDOWN		(1 << 4)
+
+#define BCU_ALERT               (1 << 3)
+#define VWARN1_IRQ              (1 << 0)
+#define VWARN2_IRQ              (1 << 1)
+#define VCRIT_IRQ               (1 << 2)
+#define GSMPULSE_IRQ            (1 << 3)
+#define TXPWRTH_IRQ             (1 << 4)
+
+/* Number of configurable thresholds for current and voltage */
+#define NUM_THRESHOLDS          8
+
+/* BCU real time status flags for corresponding input signals */
+#define SVWARN1                 (1<<0)
+#define SVWARN2                 (1<<1)
+#define SVCRIT                  (1<<2)
+
+/* S_BCUCTRL register status bits */
+#define S_CAMFLTORCH		B3
+#define S_CAMFLDIS		B2
+#define S_BCUDISW2		B1
+
+#define S_BCUDISW2_MASK		B1
+#define S_CAMFLDIS_MASK		B2
+#define S_CAMFLTORCH_MASK	B3
+
+/* check whether bit is sticky or not by checking 5th bit */
+#define IS_STICKY(data)         (!!(data & 0x10))
+
+/* check whether signal asserted for VW1/VW2/VC */
+#define IS_ASSRT_ON_VW1(data)   (!!(data & 0x01))
+#define IS_ASSRT_ON_VW2(data)   (!!(data & 0x02))
+#define IS_ASSRT_ON_VC(data)    (!!(data & 0x04))
+
+/* Configuration registers that monitor the voltage drop */
+#define VWARN1_CFG              0x3C
+#define VWARN2_CFG              0x3D
+#define VCRIT_CFG               0x3E
+#define ICCMAXVSYS_CFG          0x3F
+#define ICCMAXVCC_CFG           0x40
+#define ICCMAXVNN_CFG           0x41
+
+/* Behaviour registers */
+#define VFLEXSRC_BEH            0x42
+#define VFLEXDIS_BEH            0x43
+#define VIBDIS_BEH              0x44
+#define CAMFLTORCH_BEH          0x45
+#define CAMFLDIS_BEH            0x46
+#define BCUDISW2_BEH            0x47
+#define BCUDISCRIT_BEH          0x48
+
+/*IRQ Mask Register*/
+#define MBCUIRQ                 0x10
+
+#define MRFL_SMIP_SRAM_ADDR	0xFFFCE000
+
+/* SMIP offset address from where the BCU related info should be read */
+#define BCU_SMIP_OFFSET		0x3BA
+
+/* No of Bytes we have to read from SMIP from BCU_SMIP_BASE*/
+#define NUM_SMIP_BYTES          14
+
+/* Max length of the register name string */
+#define MAX_REGNAME_LEN		15
+
+/* String to send the uevent along with env info to user space */
+#define EVT_STR	"BCUEVT="
+
+/* Macro to get the mode of acess for the BCU registers	*/
+#define MODE(m)	(((m != S_BCUINT) && (m != BCUIRQ) && (m != IRQLVL1))	\
+			? (S_IRUGO | S_IWUSR) : S_IRUGO)
+
+/* Generic macro to assign the parameters (reg name and address) */
+#define reg_info(x)	{ .name = #x, .addr = x, .mode = MODE(x) }
+
+/* Generic macro to fill the environmental data for bcu uevent */
+#define get_envp(evt)	(EVT_STR#evt)
+
+/*
+* These values are read from SMIP.
+* SMIP contains these entries - default register configurations
+* BCU is programmed to these default values during boot time.
+*/
+
+struct ocd_bcove_config_data {
+	uint8_t vwarn1_cfg;
+	uint8_t vwarn2_cfg;
+	uint8_t vcrit_cfg;
+	uint8_t iccmaxvsys_cfg;
+	uint8_t iccmaxvcc_cfg;
+	uint8_t iccmaxvnn_cfg;
+	uint8_t vflexsrc_beh;
+	uint8_t vflexdis_beh;
+	uint8_t vibdis_beh;
+	uint8_t camfltorch_beh;
+	uint8_t camfldis_beh;
+	uint8_t bcudisw2_beh;
+	uint8_t bcudiscrit_beh;
+	uint8_t mbcuirq;
+} __packed;
+
+struct ocd_platform_data {
+	int (*bcu_config_data) (struct ocd_bcove_config_data *);
+};
+
+struct bcu_reg_info {
+	char	name[MAX_REGNAME_LEN];	/* register name   */
+	u16	addr;			/* offset address  */
+	u16	mode;			/* permission mode */
+};
+
+#endif
+
diff --git a/arch/x86/include/asm/module.h b/arch/x86/include/asm/module.h
index e3b7819..a11269b 100644
--- a/arch/x86/include/asm/module.h
+++ b/arch/x86/include/asm/module.h
@@ -15,7 +15,7 @@
 #define MODULE_PROC_FAMILY "586MMX "
 #elif defined CONFIG_MCORE2
 #define MODULE_PROC_FAMILY "CORE2 "
-#elif defined CONFIG_MATOM
+#elif (defined CONFIG_MATOM) || (defined CONFIG_MSLM)
 #define MODULE_PROC_FAMILY "ATOM "
 #elif defined CONFIG_M686
 #define MODULE_PROC_FAMILY "686 "
diff --git a/arch/x86/include/asm/mwait.h b/arch/x86/include/asm/mwait.h
index 1da25a5..75fc782 100644
--- a/arch/x86/include/asm/mwait.h
+++ b/arch/x86/include/asm/mwait.h
@@ -15,6 +15,12 @@
 
 #define MWAIT_ECX_INTERRUPT_BREAK	0x1
 
+#ifdef CONFIG_ATOM_SOC_POWER
+#define MWAIT_MAX_NUM_CSTATES		10
+#else
+#define MWAIT_MAX_NUM_CSTATES		8
+#endif
+
 static inline void __monitor(const void *eax, unsigned long ecx,
 			     unsigned long edx)
 {
diff --git a/arch/x86/include/asm/required-features.h b/arch/x86/include/asm/required-features.h
index 5c6e4fb..ee177f7 100644
--- a/arch/x86/include/asm/required-features.h
+++ b/arch/x86/include/asm/required-features.h
@@ -47,7 +47,7 @@
 # define NEED_NOPL	0
 #endif
 
-#ifdef CONFIG_MATOM
+#if defined(CONFIG_MATOM) || defined(CONFIG_MSLM)
 # define NEED_MOVBE	(1<<(X86_FEATURE_MOVBE & 31))
 #else
 # define NEED_MOVBE	0
diff --git a/arch/x86/kernel/early_printk.c b/arch/x86/kernel/early_printk.c
index 01d1c18..ecc7206 100644
--- a/arch/x86/kernel/early_printk.c
+++ b/arch/x86/kernel/early_printk.c
@@ -230,11 +230,16 @@ static int __init setup_early_printk(char *buf)
 			mrst_early_console_init();
 			early_console_register(&early_mrst_console, keep);
 		}
-
+		if (!strncmp(buf, "mrfld", 5)) {
+			mrfld_early_console_init();
+			early_console_register(&early_mrfld_console, keep);
+		}
 		if (!strncmp(buf, "hsu", 3)) {
 			hsu_early_console_init(buf + 3);
 			early_console_register(&early_hsu_console, keep);
 		}
+		if (!strncmp(buf, "pti", 3))
+			early_console_register(&early_pti_console, keep);
 #endif
 #ifdef CONFIG_EARLY_PRINTK_EFI
 		if (!strncmp(buf, "efi", 3))
diff --git a/arch/x86/platform/intel-mid/Makefile b/arch/x86/platform/intel-mid/Makefile
index 4b64cd2..e1a5f22 100644
--- a/arch/x86/platform/intel-mid/Makefile
+++ b/arch/x86/platform/intel-mid/Makefile
@@ -17,3 +17,6 @@ obj-$(CONFIG_X86_INTEL_MID) += intel_mid_scu.o
 obj-$(CONFIG_ATOM_SOC_POWER) += intel_soc_pmu.o intel_soc_pm_debug.o intel_soc_dump.o
 obj-$(CONFIG_REMOVEME_INTEL_ATOM_MRFLD_POWER) += intel_soc_mrfld.o
 obj-$(CONFIG_REMOVEME_INTEL_ATOM_MRFLD_POWER) += pmu_tng.o
+
+# Debug features driver
+obj-$(CONFIG_INTEL_DEBUG_FEATURE) += intel_soc_debug.o
diff --git a/arch/x86/platform/intel-mid/device_libs/Makefile b/arch/x86/platform/intel-mid/device_libs/Makefile
index e6e4213..be2a8c1 100644
--- a/arch/x86/platform/intel-mid/device_libs/Makefile
+++ b/arch/x86/platform/intel-mid/device_libs/Makefile
@@ -1,12 +1,13 @@
 # IPC Devices
 obj-y += platform_ipc.o
+obj-y += platform_mrfl_regulator.o
+obj-y += platform_soc_thermal.o
+obj-y += platform_msic_gpio.o
+obj-y += platform_msic_ocd.o
+obj-y += platform_tc35876x.o
 obj-$(subst m,y,$(CONFIG_MFD_INTEL_MSIC)) += platform_msic.o
 obj-$(subst m,y,$(CONFIG_SND_MFLD_MACHINE)) += platform_msic_audio.o
-obj-$(subst m,y,$(CONFIG_GPIO_MSIC)) += platform_msic_gpio.o
-obj-$(subst m,y,$(CONFIG_MFD_INTEL_MSIC)) += platform_msic_ocd.o
 obj-$(subst m,y,$(CONFIG_MFD_INTEL_MSIC)) += platform_msic_battery.o
-obj-$(subst m,y,$(CONFIG_INTEL_MID_POWER_BUTTON)) += platform_msic_power_btn.o
-obj-$(subst m,y,$(CONFIG_GPIO_INTEL_PMIC)) += platform_pmic_gpio.o
 obj-$(subst m,y,$(CONFIG_INTEL_MFLD_THERMAL)) += platform_msic_thermal.o
 obj-y += pci/
 obj-$(subst m,y,$(CONFIG_INTEL_MID_POWER_BUTTON)) += platform_msic_power_btn.o
@@ -21,10 +22,12 @@ obj-$(subst m,y,$(CONFIG_GPIO_PCA953X)) += platform_max7315.o
 obj-$(subst m,y,$(CONFIG_INPUT_MPU3050)) += platform_mpu3050.o
 obj-$(subst m,y,$(CONFIG_INPUT_BMA150)) += platform_bma023.o
 obj-$(subst m,y,$(CONFIG_GPIO_PCA953X)) += platform_tca6416.o
-obj-$(subst m,y,$(CONFIG_DRM_MEDFIELD)) += platform_tc35876x.o
+obj-$(subst m,y,$(CONFIG_BQ24261_CHARGER)) += platform_bq24261.o
+obj-$(subst m,y,$(CONFIG_GPIO_PCA953X)) += platform_pcal9555a.o
 obj-$(subst m,y,$(CONFIG_I2C_DESIGNWARE_CORE_FORK)) += platform_dw_i2c.o
 # SPI Devices
 obj-$(subst m,y,$(CONFIG_SERIAL_MRST_MAX3110)) += platform_max3111.o
+obj-$(subst m,y,$(CONFIG_SPI_SPIDEV)) += platform_spidev.o
 # ADC
 obj-$(subst m,y,$(CONFIG_MSIC_GPADC))  += platform_msic_adc.o
 obj-$(subst m,y,$(CONFIG_IIO_BASINCOVE_GPADC)) += platform_bcove_adc.o
@@ -34,8 +37,6 @@ obj-$(subst m,y,$(CONFIG_KEYBOARD_GPIO)) += platform_gpio_keys.o
 obj-$(subst m,y,$(CONFIG_SERIAL_MFD_HSU)) += platform_hsu.o
 obj-$(subst m,y,$(CONFIG_TI_ADS7955_ADC)) += platform_ads7955.o
 # SD Devices
-ifndef CONFIG_ACPI
 obj-$(subst m,y,$(CONFIG_BCM_BT_LPM)) += platform_btlpm.o
-endif
 # WIFI devices
 obj-$(subst m,y,$(CONFIG_WIFI_PLATFORM_DATA)) += platform_wifi.o
diff --git a/arch/x86/platform/intel-mid/device_libs/pci/platform_sdhci_pci.c b/arch/x86/platform/intel-mid/device_libs/pci/platform_sdhci_pci.c
index 89e0af2..0de50fa 100644
--- a/arch/x86/platform/intel-mid/device_libs/pci/platform_sdhci_pci.c
+++ b/arch/x86/platform/intel-mid/device_libs/pci/platform_sdhci_pci.c
@@ -409,21 +409,10 @@ static struct sdhci_pci_data mrfl_sdhci_pci_data[] = {
 static int byt_sdio_setup(struct sdhci_pci_data *data)
 {
 	struct pci_dev *pdev = data->pdev;
-#ifdef CONFIG_ACPI
-	acpi_handle handle;
-	acpi_status status;
-#endif
 
 	/* Control card power through a regulator */
 	wlan_vmmc_supply.dev_name = dev_name(&pdev->dev);
 
-#ifdef CONFIG_ACPI
-	status = acpi_get_handle(NULL, "\\_SB.SDHB", &handle);
-	if (ACPI_FAILURE(status))
-		pr_err("wlan: cannot get SDHB acpi handle");
-	ACPI_COMPANION_SET(&pdev->dev, handle);
-	vwlan.gpio = acpi_get_gpio_by_index(&pdev->dev, 0, NULL);
-#endif
 	if (vwlan.gpio < 0)
 		pr_err("%s: No wlan-enable GPIO in SDHB ACPI block\n",
 		       __func__);
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_bq24261.c b/arch/x86/platform/intel-mid/device_libs/platform_bq24261.c
new file mode 100644
index 0000000..1c1a583
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_bq24261.c
@@ -0,0 +1,77 @@
+/*
+ * platform_mrfl_bq24261.c: Platform data for bq24261 charger driver
+ *
+ * (C) Copyright 2012 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/scatterlist.h>
+#include <linux/init.h>
+#include <linux/sfi.h>
+#include <linux/power_supply.h>
+#include <asm/pmic_pdata.h>
+#include <linux/power/bq24261_charger.h>
+#include <asm/intel-mid.h>
+
+#include "platform_ipc.h"
+#include "platform_bq24261.h"
+
+#define BOOST_CUR_LIM 500
+
+static struct power_supply_throttle bq24261_throttle_states[] = {
+	{
+		.throttle_action = PSY_THROTTLE_CC_LIMIT,
+		.throttle_val = BQ24261_CHRG_CUR_NOLIMIT,
+
+	},
+	{
+		.throttle_action = PSY_THROTTLE_CC_LIMIT,
+		.throttle_val = BQ24261_CHRG_CUR_MEDIUM,
+
+	},
+	{
+		.throttle_action = PSY_THROTTLE_DISABLE_CHARGING,
+	},
+	{
+		.throttle_action = PSY_THROTTLE_DISABLE_CHARGER,
+	},
+
+};
+
+char *bq24261_supplied_to[] = {
+				"max170xx_battery",
+				"max17047_battery",
+};
+
+
+void __init *bq24261_platform_data(void *info)
+{
+	static struct bq24261_plat_data bq24261_pdata;
+
+
+	bq24261_pdata.irq_map = PMIC_SRAM_INTR_MAP;
+	bq24261_pdata.irq_mask = PMIC_EXT_INTR_MASK;
+	bq24261_pdata.supplied_to = bq24261_supplied_to;
+	bq24261_pdata.num_supplicants = ARRAY_SIZE(bq24261_supplied_to);
+	bq24261_pdata.throttle_states = bq24261_throttle_states;
+	bq24261_pdata.num_throttle_states = ARRAY_SIZE(bq24261_throttle_states);
+	bq24261_pdata.enable_charger = NULL;
+#ifdef CONFIG_PMIC_CCSM
+	bq24261_pdata.enable_charging = pmic_enable_charging;
+	bq24261_pdata.set_inlmt = pmic_set_ilimma;
+	bq24261_pdata.set_cc = pmic_set_cc;
+	bq24261_pdata.set_cv = pmic_set_cv;
+	bq24261_pdata.dump_master_regs = dump_pmic_regs;
+	bq24261_pdata.enable_vbus = pmic_enable_vbus;
+#endif
+	bq24261_pdata.set_iterm = NULL;
+	bq24261_pdata.boost_mode_ma = BOOST_CUR_LIM;
+
+	return &bq24261_pdata;
+}
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_max3111.c b/arch/x86/platform/intel-mid/device_libs/platform_max3111.c
index afd1df9..cf6b88b 100644
--- a/arch/x86/platform/intel-mid/device_libs/platform_max3111.c
+++ b/arch/x86/platform/intel-mid/device_libs/platform_max3111.c
@@ -1,8 +1,8 @@
 /*
  * platform_max3111.c: max3111 platform data initilization file
  *
- * (C) Copyright 2013 Intel Corporation
- * Author: Sathyanarayanan Kuppuswamy <sathyanarayanan.kuppuswamy@intel.com>
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -12,24 +12,50 @@
 
 #include <linux/gpio.h>
 #include <linux/spi/spi.h>
+#include <linux/lnw_gpio.h>
+#include <linux/serial_max3110.h>
+#include <linux/spi/intel_mid_ssp_spi.h>
 #include <asm/intel-mid.h>
+#include "platform_max3111.h"
 
-static void __init *max3111_platform_data(void *info)
+static struct intel_mid_ssp_spi_chip chip = {
+	.burst_size = DFLT_FIFO_BURST_SIZE,
+	.timeout = DFLT_TIMEOUT_VAL,
+	/* UART DMA is not supported in VP */
+	.dma_enabled = false,
+};
+
+void __init *max3111_platform_data(void *info)
 {
 	struct spi_board_info *spi_info = info;
-	int intr = get_gpio_by_name("max3111_int");
+	int intr;
+	static struct plat_max3110 max3110_pdata;
 
 	spi_info->mode = SPI_MODE_0;
-	if (intr == -1)
-		return NULL;
-	spi_info->irq = intr + INTEL_MID_IRQ_OFFSET;
-	return NULL;
-}
 
-static const struct devs_id max3111_dev_id __initconst = {
-	.name = "spi_max3111",
-	.type = SFI_DEV_TYPE_SPI,
-	.get_platform_data = &max3111_platform_data,
-};
+	/* max 3110 interrupt not supported by sim platforms */
+	if (intel_mid_identify_sim()) {
+		spi_info->controller_data = &chip;
+		spi_info->bus_num = FORCE_SPI_BUS_NUM;
+		return &max3110_pdata;
+	}
 
-sfi_device(max3111_dev_id);
+	spi_info->controller_data = &chip;
+	spi_info->bus_num = FORCE_SPI_BUS_NUM;
+
+	/* use fast_int_1 (IRQ 41) on MRFL */
+	max3110_pdata.irq_edge_triggered = 0;
+
+	/*force polling for HVP and VP simulation platforms
+	 * on TANGIER AND ANNIEDALE.
+	 */
+	if ((intel_mid_identify_sim() == INTEL_MID_CPU_SIMULATION_VP) ||
+	    (intel_mid_identify_sim() == INTEL_MID_CPU_SIMULATION_HVP)) {
+		if ((intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER) ||
+		   (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_ANNIEDALE)) {
+			spi_info->irq = 0;
+		}
+	}
+
+	return &max3110_pdata;
+}
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_mrfl_regulator.c b/arch/x86/platform/intel-mid/device_libs/platform_mrfl_regulator.c
new file mode 100644
index 0000000..f7d38fa
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_mrfl_regulator.c
@@ -0,0 +1,125 @@
+/*
+ * platform_mrfl_regulator.c - Merrifield regulator machine drvier
+ * Copyright (c) 2012, Intel Corporation.
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <linux/regulator/intel_basin_cove_pmic.h>
+#include <linux/regulator/machine.h>
+
+#include <asm/intel-mid.h>
+
+/***********VPROG1 REGUATOR platform data*************/
+static struct regulator_consumer_supply vprog1_consumer[] = {
+};
+static struct regulator_init_data vprog1_data = {
+	.constraints = {
+		.min_uV			= 1500000,
+		.max_uV			= 2800000,
+		.valid_ops_mask		= REGULATOR_CHANGE_STATUS
+			| REGULATOR_CHANGE_VOLTAGE,
+		.valid_modes_mask	= REGULATOR_MODE_NORMAL,
+	},
+	.num_consumer_supplies	= ARRAY_SIZE(vprog1_consumer),
+	.consumer_supplies	= vprog1_consumer,
+};
+
+static struct intel_pmic_info vprog1_info = {
+	.pmic_reg   = VPROG1CNT_ADDR,
+	.init_data  = &vprog1_data,
+	.table_len  = ARRAY_SIZE(VPROG1_VSEL_table),
+	.table      = VPROG1_VSEL_table,
+};
+static struct platform_device vprog1_device = {
+	.name = "intel_regulator",
+	.id = VPROG1,
+	.dev = {
+		.platform_data = &vprog1_info,
+	},
+};
+/***********VPROG2 REGUATOR platform data*************/
+static struct regulator_consumer_supply vprog2_consumer[] = {
+};
+static struct regulator_init_data vprog2_data = {
+	.constraints = {
+		.min_uV			= 1500000,
+		.max_uV			= 2850000,
+		.valid_ops_mask		= REGULATOR_CHANGE_STATUS
+			| REGULATOR_CHANGE_VOLTAGE,
+		.valid_modes_mask	= REGULATOR_MODE_NORMAL
+	},
+	.num_consumer_supplies	= ARRAY_SIZE(vprog2_consumer),
+	.consumer_supplies	= vprog2_consumer,
+};
+static struct intel_pmic_info vprog2_info = {
+	.pmic_reg   = VPROG2CNT_ADDR,
+	.init_data  = &vprog2_data,
+	.table_len  = ARRAY_SIZE(VPROG2_VSEL_table),
+	.table      = VPROG2_VSEL_table,
+};
+static struct platform_device vprog2_device = {
+	.name = "intel_regulator",
+	.id = VPROG2,
+	.dev = {
+		.platform_data = &vprog2_info,
+	},
+};
+
+/***********VPROG3 REGUATOR platform data*************/
+static struct regulator_consumer_supply vprog3_consumer[] = {
+};
+static struct regulator_init_data vprog3_data = {
+	.constraints = {
+		.min_uV			= 1050000,
+		.max_uV			= 2800000,
+		.valid_ops_mask		= REGULATOR_CHANGE_STATUS
+			| REGULATOR_CHANGE_VOLTAGE,
+		.valid_modes_mask	= REGULATOR_MODE_NORMAL
+	},
+	.num_consumer_supplies	= ARRAY_SIZE(vprog2_consumer),
+	.consumer_supplies	= vprog3_consumer,
+};
+static struct intel_pmic_info vprog3_info = {
+	.pmic_reg   = VPROG3CNT_ADDR,
+	.init_data  = &vprog3_data,
+	.table_len  = ARRAY_SIZE(VPROG3_VSEL_table),
+	.table      = VPROG3_VSEL_table,
+};
+static struct platform_device vprog3_device = {
+	.name = "intel_regulator",
+	.id = VPROG3,
+	.dev = {
+		.platform_data = &vprog3_info,
+	},
+};
+
+static struct platform_device *regulator_devices[] __initdata = {
+	&vprog1_device,
+	&vprog2_device,
+	&vprog3_device,
+};
+
+static int __init regulator_init(void)
+{
+	/* register the regulator only if SoC is Tangier */
+	if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER)
+		platform_add_devices(regulator_devices,
+				ARRAY_SIZE(regulator_devices));
+
+	return 0;
+}
+device_initcall(regulator_init);
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_msic_power_btn.c b/arch/x86/platform/intel-mid/device_libs/platform_msic_power_btn.c
index 83a3459..f745750 100644
--- a/arch/x86/platform/intel-mid/device_libs/platform_msic_power_btn.c
+++ b/arch/x86/platform/intel-mid/device_libs/platform_msic_power_btn.c
@@ -1,8 +1,8 @@
 /*
  * platform_msic_power_btn.c: MSIC power btn platform data initilization file
  *
- * (C) Copyright 2013 Intel Corporation
- * Author: Sathyanarayanan Kuppuswamy <sathyanarayanan.kuppuswamy@intel.com>
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -14,23 +14,60 @@
 #include <linux/scatterlist.h>
 #include <linux/sfi.h>
 #include <linux/init.h>
-#include <linux/mfd/intel_msic.h>
 #include <asm/intel-mid.h>
+#include <asm/intel_mid_powerbtn.h>
+#include <asm/intel_scu_ipc.h>
+#include <asm/intel_scu_pmic.h>
+#include "platform_msic_power_btn.h"
+#include <linux/platform_data/intel_mid_remoteproc.h>
 
-#include "platform_msic.h"
-#include "platform_ipc.h"
+#define BCOVE_PBIRQ 0x02
+#define BCOVE_PBIRQMASK	0x0d
 
-static void __init *msic_power_btn_platform_data(void *info)
+static struct intel_msic_power_btn_platform_data msic_power_btn_pdata;
+
+static int mrfl_pb_irq_ack(struct intel_msic_power_btn_platform_data *pdata)
 {
-	return msic_generic_platform_data(info, INTEL_MSIC_BLOCK_POWER_BTN);
+	intel_scu_ipc_update_register(BCOVE_PBIRQ, 0, MSIC_PWRBTNM);
+	intel_scu_ipc_update_register(BCOVE_PBIRQMASK, 0, MSIC_PWRBTNM);
+
+	return 0;
 }
 
-static const struct devs_id msic_power_btn_dev_id __initconst = {
-	.name = "msic_power_btn",
-	.type = SFI_DEV_TYPE_IPC,
-	.delay = 1,
-	.get_platform_data = &msic_power_btn_platform_data,
-	.device_handler = &ipc_device_handler,
-};
+void __init *msic_power_btn_platform_data(void *info)
+{
+	int ret;
+	struct platform_device *pdev;
+	struct sfi_device_table_entry *entry = info;
+	struct resource res;
+
+	pdev = platform_device_alloc(INTEL_MID_POWERBTN_DEV_NAME, -1);
+	if (!pdev) {
+		pr_err("%s(): out of memory\n", __func__);
+		return NULL;
+	}
+
+	msic_power_btn_pdata.pbstat = 0xfffff61a;
+	msic_power_btn_pdata.pb_level = (1 << 4);
+	msic_power_btn_pdata.irq_lvl1_mask = 0x0c;
+	msic_power_btn_pdata.irq_ack = mrfl_pb_irq_ack;
 
-sfi_device(msic_power_btn_dev_id);
+	pdev->dev.platform_data = &msic_power_btn_pdata;
+
+	ret = platform_device_add(pdev);
+	if (ret) {
+		pr_err("%s(): platform_device_add() failed\n", __func__);
+		platform_device_put(pdev);
+		return NULL;
+	}
+
+	res.name = "IRQ",
+	res.flags = IORESOURCE_IRQ,
+	res.start = entry->irq;
+	platform_device_add_resources(pdev, &res, 1);
+
+	register_rpmsg_service("rpmsg_mid_powerbtn",
+			RPROC_SCU, RP_MSIC_POWER_BTN);
+
+	return &msic_power_btn_pdata;
+}
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_pcal9555a.c b/arch/x86/platform/intel-mid/device_libs/platform_pcal9555a.c
new file mode 100644
index 0000000..9765f22
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_pcal9555a.c
@@ -0,0 +1,68 @@
+/*
+ * platform_pcal9555a.c: pcal9555a platform data initilization file
+ *
+ * (C) Copyright 2014 Intel Corporation
+ * Author: Dan O'Donovan <dan@emutex.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/init.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/platform_data/pca953x.h>
+#include <asm/intel-mid.h>
+#include "platform_pcal9555a.h"
+
+
+void __init *pcal9555a_platform_data(void *info)
+{
+	static struct pca953x_platform_data pcal9555a_pdata[PCAL9555A_NUM];
+	static int nr;
+	struct pca953x_platform_data *pcal9555a;
+	struct i2c_board_info *i2c_info = info;
+	int gpio_base, intr;
+	char base_pin_name[SFI_NAME_LEN + 1];
+	char intr_pin_name[SFI_NAME_LEN + 1];
+
+	if (!info) {
+		pr_err("%s: invalid info pointer\n", __func__);
+		return NULL;
+	}
+
+	if (nr >= PCAL9555A_NUM) {
+		pr_err("%s: too many pcal9555a, we only support %d\n",
+			__func__, PCAL9555A_NUM);
+		return NULL;
+	}
+	pcal9555a = &pcal9555a_pdata[nr++];
+
+	/* we have several pcal9555a on the board, we only need load several
+	 * instances of the same pca953x driver to cover them
+	 */
+
+	snprintf(base_pin_name, sizeof(base_pin_name),
+		 "%s_base", i2c_info->type);
+	snprintf(intr_pin_name, sizeof(intr_pin_name),
+		 "%s_int", i2c_info->type);
+
+	strcpy(i2c_info->type, "pcal9555a");
+
+	gpio_base = get_gpio_by_name(base_pin_name);
+	intr = get_gpio_by_name(intr_pin_name);
+
+	if (gpio_base == -1)
+		return NULL;
+	pcal9555a->gpio_base = gpio_base;
+	if (intr != -1) {
+		i2c_info->irq = intr + INTEL_MID_IRQ_OFFSET;
+		pcal9555a->irq_base = gpio_base + INTEL_MID_IRQ_OFFSET;
+	} else {
+		i2c_info->irq = -1;
+		pcal9555a->irq_base = -1;
+	}
+	return pcal9555a;
+}
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_soc_thermal.c b/arch/x86/platform/intel-mid/device_libs/platform_soc_thermal.c
new file mode 100644
index 0000000..004784a
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_soc_thermal.c
@@ -0,0 +1,136 @@
+/*
+ * platform_soc_thermal.c: Platform data for SoC DTS driver
+ *
+ * (C) Copyright 2013 Intel Corporation
+ * Author: Durgadoss R <durgadoss.r@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#define pr_fmt(fmt)  "intel_soc_thermal: " fmt
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+
+#include "platform_soc_thermal.h"
+
+#include <asm/intel-mid.h>
+#include <asm/intel_mid_thermal.h>
+
+#define BYT_SOC_THRM_IRQ	86
+#define BYT_SOC_THRM		"soc_thrm"
+
+static struct resource res = {
+		.flags = IORESOURCE_IRQ,
+};
+
+static struct soc_throttle_data tng_soc_data[] = {
+	{
+		.power_limit = 0x9C,
+		.floor_freq = 0x00,
+	},
+	{
+		.power_limit = 0x8C,
+		.floor_freq = 0x00,
+	},
+	{
+		.power_limit = 0x7C,
+		.floor_freq = 0x00,
+	},
+	{
+		.power_limit = 0x6C,
+		.floor_freq = 0x00,
+	},
+};
+
+static struct soc_throttle_data vlv2_soc_data[] = {
+	{
+		.power_limit = 0xDA, /* 7W */
+		.floor_freq = 0x00,
+	},
+	{
+		.power_limit = 0x6D, /* 3.5W */
+		.floor_freq = 0x01,
+	},
+	{
+		.power_limit = 0x2E, /* 1.5W */
+		.floor_freq = 0x01,
+	},
+	{
+		.power_limit = 0x2E, /* 1.5W */
+		.floor_freq = 0x01,
+	},
+};
+
+void soc_thrm_device_handler(struct sfi_device_table_entry *pentry,
+				struct devs_id *dev)
+{
+	int ret;
+	struct platform_device *pdev;
+
+	pr_info("IPC bus = %d, name = %16.16s, irq = 0x%2x\n",
+		pentry->host_num, pentry->name, pentry->irq);
+
+	res.start = pentry->irq;
+
+	pdev = platform_device_register_simple(pentry->name, -1,
+					(const struct resource *)&res, 1);
+	if (IS_ERR(pdev)) {
+		ret = PTR_ERR(pdev);
+		pr_err("platform_soc_thermal:pdev_register failed: %d\n", ret);
+	}
+
+	pdev->dev.platform_data = &tng_soc_data;
+}
+
+static inline int byt_program_ioapic(int irq, int trigger, int polarity)
+{
+	struct io_apic_irq_attr irq_attr;
+	int ioapic;
+
+	ioapic = mp_find_ioapic(irq);
+	if (ioapic < 0)
+		return -EINVAL;
+	irq_attr.ioapic = ioapic;
+	irq_attr.ioapic_pin = irq;
+	irq_attr.trigger = trigger;
+	irq_attr.polarity = polarity;
+	return io_apic_set_pci_routing(NULL, irq, &irq_attr);
+}
+
+static int __init byt_soc_thermal_init(void)
+{
+	int ret;
+	struct platform_device *pdev;
+
+	res.start = BYT_SOC_THRM_IRQ;
+
+	pdev = platform_device_register_simple(BYT_SOC_THRM, -1,
+					(const struct resource *)&res, 1);
+	if (IS_ERR(pdev)) {
+		ret = PTR_ERR(pdev);
+		pr_err("byt_soc_thermal:pdev_register failed: %d\n", ret);
+		return ret;
+	}
+
+	ret = byt_program_ioapic(BYT_SOC_THRM_IRQ, 0, 1);
+	if (ret) {
+		pr_err("%s: ioapic programming failed", __func__);
+		platform_device_unregister(pdev);
+	}
+
+	pdev->dev.platform_data = &vlv2_soc_data;
+
+	return ret;
+}
+
+static int __init platform_soc_thermal_init(void)
+{
+	return 0;
+}
+device_initcall(platform_soc_thermal_init);
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_spidev.c b/arch/x86/platform/intel-mid/device_libs/platform_spidev.c
new file mode 100644
index 0000000..283020a
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_spidev.c
@@ -0,0 +1,73 @@
+/*
+ * platform_spidev.c: spidev platform data initilization file
+ *
+ * (C) Copyright 2014 Intel Corporation
+ * Author: Dan O'Donovan <dan@emutex.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/spi/spi.h>
+#include <linux/spi/intel_mid_ssp_spi.h>
+#include <asm/intel-mid.h>
+#include <linux/gpio.h>
+#include <linux/lnw_gpio.h>
+#include "platform_spidev.h"
+
+static void tng_ssp_spi_cs_control(u32 command);
+static void tng_ssp_spi_platform_pinmux(void);
+
+static int tng_ssp_spi2_FS_gpio = 111;
+
+static struct intel_mid_ssp_spi_chip chip = {
+	.burst_size = DFLT_FIFO_BURST_SIZE,
+	.timeout = DFLT_TIMEOUT_VAL,
+	/* SPI DMA is currently not usable on Tangier */
+	.dma_enabled = false,
+	.cs_control = tng_ssp_spi_cs_control,
+	.platform_pinmux = tng_ssp_spi_platform_pinmux,
+};
+
+static void tng_ssp_spi_cs_control(u32 command)
+{
+	gpio_set_value(tng_ssp_spi2_FS_gpio, (command != 0) ? 1 : 0);
+}
+
+static void tng_ssp_spi_platform_pinmux(void)
+{
+	int err;
+	int saved_muxing;
+	/* Request Chip Select gpios */
+	saved_muxing = gpio_get_alt(tng_ssp_spi2_FS_gpio);
+
+	intel_mid_gpio_set_alt(tng_ssp_spi2_FS_gpio, LNW_GPIO);
+	err = gpio_request_one(tng_ssp_spi2_FS_gpio,
+			GPIOF_DIR_OUT|GPIOF_INIT_HIGH, "Arduino Shield SS");
+	if (err) {
+		pr_err("%s: unable to get Chip Select GPIO,\
+				fallback to legacy CS mode \n", __func__);
+		intel_mid_gpio_set_alt(tng_ssp_spi2_FS_gpio, saved_muxing);
+		chip.cs_control = NULL;
+		chip.platform_pinmux = NULL;
+	}
+}
+
+void __init *spidev_platform_data(void *info)
+{
+	struct spi_board_info *spi_info = info;
+
+	if (!spi_info) {
+		pr_err("%s: invalid info pointer\n", __func__);
+		return NULL;
+	}
+
+	spi_info->mode = SPI_MODE_0;
+
+	spi_info->controller_data = &chip;
+	spi_info->bus_num = FORCE_SPI_BUS_NUM;
+
+	return NULL;
+}
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_wifi.c b/arch/x86/platform/intel-mid/device_libs/platform_wifi.c
index ad0b6b4..ca0e51e 100644
--- a/arch/x86/platform/intel-mid/device_libs/platform_wifi.c
+++ b/arch/x86/platform/intel-mid/device_libs/platform_wifi.c
@@ -119,10 +119,8 @@ void __init *wifi_platform_data(void *info)
 	sdhci_pdata_set_quirks(sdhci_quirk);
 #endif
 
-#ifndef CONFIG_ACPI
 	/* We are SFI here, register platform device */
 	wifi_platform_data_init_sfi_gpio();
-#endif
 
 	return &wifi_device;
 }
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_wm8994.c b/arch/x86/platform/intel-mid/device_libs/platform_wm8994.c
new file mode 100644
index 0000000..51a6352
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_wm8994.c
@@ -0,0 +1,243 @@
+/*
+ * platform_wm8994.c: wm8994 platform data initilization file
+ *
+ * (C) Copyright 2013 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/gpio.h>
+#include <linux/lnw_gpio.h>
+#include <asm/intel-mid.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/fixed.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/mfd/wm8994/pdata.h>
+#include "platform_wm8994.h"
+
+/***********WM89941 REGUATOR platform data*************/
+static struct regulator_consumer_supply vwm89941_consumer[] = {
+	REGULATOR_SUPPLY("DBVDD", "1-001a"),
+	REGULATOR_SUPPLY("DBVDD1", "1-001a"),
+	REGULATOR_SUPPLY("DBVDD2", "1-001a"),
+	REGULATOR_SUPPLY("DBVDD3", "1-001a"),
+	REGULATOR_SUPPLY("AVDD2", "1-001a"),
+	REGULATOR_SUPPLY("CPVDD", "1-001a"),
+};
+
+static struct regulator_init_data vwm89941_data = {
+		.constraints = {
+			.always_on = 1,
+		},
+		.num_consumer_supplies	=	ARRAY_SIZE(vwm89941_consumer),
+		.consumer_supplies	=	vwm89941_consumer,
+};
+
+static struct fixed_voltage_config vwm89941_config = {
+	.supply_name	= "VCC_1.8V_PDA",
+	.microvolts	= 1800000,
+	.gpio		= -EINVAL,
+	.init_data	= &vwm89941_data,
+};
+
+static struct platform_device vwm89941_device = {
+	.name = "reg-fixed-voltage",
+	.id = 0,
+	.dev = {
+		.platform_data = &vwm89941_config,
+	},
+};
+
+/***********WM89942 REGUATOR platform data*************/
+static struct regulator_consumer_supply vwm89942_consumer[] = {
+	REGULATOR_SUPPLY("SPKVDD1", "1-001a"),
+	REGULATOR_SUPPLY("SPKVDD2", "1-001a"),
+};
+
+static struct regulator_init_data vwm89942_data = {
+		.constraints = {
+			.always_on = 1,
+		},
+		.num_consumer_supplies	=	ARRAY_SIZE(vwm89942_consumer),
+		.consumer_supplies	=	vwm89942_consumer,
+};
+
+static struct fixed_voltage_config vwm89942_config = {
+	.supply_name	= "V_BAT",
+	.microvolts	= 3700000,
+	.gpio		= -EINVAL,
+	.init_data  = &vwm89942_data,
+};
+
+static struct platform_device vwm89942_device = {
+	.name = "reg-fixed-voltage",
+	.id = 1,
+	.dev = {
+		.platform_data = &vwm89942_config,
+	},
+};
+
+static struct platform_device wm8994_ldo1_device;
+static struct platform_device wm8994_ldo2_device;
+static struct platform_device *wm1811a_reg_devices[] __initdata = {
+	&vwm89941_device,
+	&vwm89942_device,
+	&wm8994_ldo1_device,
+	&wm8994_ldo2_device
+};
+
+static struct platform_device *wm8958_reg_devices[] __initdata = {
+	&vwm89941_device,
+	&vwm89942_device
+};
+
+static struct regulator_consumer_supply wm8994_avdd1_supply =
+	REGULATOR_SUPPLY("AVDD1", "1-001a");
+
+static struct regulator_consumer_supply wm8994_dcvdd_supply =
+	REGULATOR_SUPPLY("DCVDD", "1-001a");
+
+static struct regulator_init_data wm8994_ldo1_data = {
+	.constraints	= {
+		.always_on	= 1,
+		.name		= "AVDD1_3.0V",
+		.valid_ops_mask	= REGULATOR_CHANGE_STATUS,
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &wm8994_avdd1_supply,
+};
+
+static struct fixed_voltage_config wm8994_ldo1_config = {
+	.supply_name	= "V_BAT_X",
+	.microvolts	= 3700000,
+	.gpio		= -EINVAL,
+	.init_data  = &wm8994_ldo1_data,
+};
+
+static struct platform_device wm8994_ldo1_device = {
+	.name = "reg-fixed-voltage",
+	.id = 2,
+	.dev = {
+		.platform_data = &wm8994_ldo1_config,
+	},
+};
+
+
+static struct regulator_init_data wm8994_ldo2_data = {
+	.constraints	= {
+		.always_on	= 1,
+		.name		= "DCVDD_1.0V",
+	},
+	.num_consumer_supplies	= 1,
+	.consumer_supplies	= &wm8994_dcvdd_supply,
+};
+
+static struct fixed_voltage_config wm8994_ldo2_config = {
+	.supply_name	= "V_BAT_Y",
+	.microvolts	= 3700000,
+	.gpio		= -EINVAL,
+	.init_data  = &wm8994_ldo2_data,
+};
+
+static struct platform_device wm8994_ldo2_device = {
+	.name = "reg-fixed-voltage",
+	.id = 3,
+	.dev = {
+		.platform_data = &wm8994_ldo2_config,
+	},
+};
+
+static struct  wm8958_custom_config custom_config = {
+	.format = 6,
+	.rate = 48000,
+	.channels = 2,
+};
+
+static struct wm8994_pdata wm8994_pdata = {
+	/* configure gpio1 function: 0x0001(Logic level input/output) */
+	.gpio_defaults[0] = 0x0003,
+	.irq_flags = IRQF_TRIGGER_RISING | IRQF_ONESHOT,
+	/* FIXME: Below are 1811A specfic, we need to use SPID for these */
+
+	/* configure gpio3/4/5/7 function for AIF2 voice */
+	.gpio_defaults[2] = 0x8100,
+	.gpio_defaults[3] = 0x8100,
+	.gpio_defaults[4] = 0x8100,
+	.gpio_defaults[6] = 0x0100,
+	/* configure gpio8/9/10/11 function for AIF3 BT */
+	/* gpio7 is codec intr pin for GV M2 */
+	.gpio_defaults[7] = 0x0003,
+	.gpio_defaults[8] = 0x0105,
+	.gpio_defaults[9] = 0x0100,
+	.gpio_defaults[10] = 0x0100,
+	.ldo[0]	= { 0, &wm8994_ldo1_data }, /* set actual value at wm8994_platform_data() */
+	.ldo[1]	= { 0, &wm8994_ldo2_data },
+	.ldo_ena_always_driven = 1,
+
+	.mic_id_delay = 300, /*300ms delay*/
+	.micdet_delay = 500,
+	.micb_en_delay = 5000, /* Keeps MICBIAS2 high for 5sec during jack insertion/removal */
+
+	.custom_cfg = &custom_config,
+};
+
+static int wm8994_get_irq_data(struct wm8994_pdata *pdata,
+			struct i2c_board_info *i2c_info, char *name)
+{
+	int codec_gpio;
+
+	/* alek tells me that since driver is registering a new chip
+	 * irq we need to give it a base which is unused so put
+	 * 256+192 here */
+	pdata->irq_base = (256 + 192);
+	codec_gpio = get_gpio_by_name(name);
+	if (codec_gpio < 0) {
+		pr_err("%s failed for : %d\n", __func__, codec_gpio);
+		return -EINVAL;
+	}
+	i2c_info->irq = codec_gpio + INTEL_MID_IRQ_OFFSET;
+	return codec_gpio;
+}
+
+void __init *wm8994_platform_data(void *info)
+{
+	struct i2c_board_info *i2c_info = (struct i2c_board_info *)info;
+	int irq = 0;
+
+	platform_add_devices(wm8958_reg_devices,
+		ARRAY_SIZE(wm8958_reg_devices));
+
+	irq = wm8994_get_irq_data(&wm8994_pdata, i2c_info,
+					"audiocodec_int");
+	if (irq < 0)
+		return NULL;
+
+	return &wm8994_pdata;
+}
+
+static struct i2c_board_info wm8958_info = {
+	I2C_BOARD_INFO("wm8958", 0x1a),
+};
+
+void __init *wm8958_platform_data(void *info)
+{
+	int irq = 0, bus_num = 1;
+
+	platform_add_devices(wm8958_reg_devices,
+			ARRAY_SIZE(wm8958_reg_devices));
+
+	irq = wm8994_get_irq_data(&wm8994_pdata, &wm8958_info,
+					"audiocodec_int");
+
+	if (irq)
+		wm8958_info.platform_data = &wm8994_pdata;
+
+	i2c_register_board_info(bus_num, &wm8958_info, 1);
+
+	return;
+}
diff --git a/arch/x86/platform/intel-mid/early_printk_intel_mid.c b/arch/x86/platform/intel-mid/early_printk_intel_mid.c
index e0bd082..3b361bd 100644
--- a/arch/x86/platform/intel-mid/early_printk_intel_mid.c
+++ b/arch/x86/platform/intel-mid/early_printk_intel_mid.c
@@ -10,10 +10,18 @@
  */
 
 /*
- * This file implements two early consoles named mrst and hsu.
- * mrst is based on Maxim3110 spi-uart device, it exists in both
- * Moorestown and Medfield platforms, while hsu is based on a High
- * Speed UART device which only exists in the Medfield platform
+ * Currently we have 3 types of early printk consoles: PTI, HSU and
+ * MAX3110 SPI-UART.
+ * PTI is available for mdfld, clv and mrfld.
+ * HSU is available for mdfld, clv and mrfld. But it depends on board design.
+ * Some boards don't have HSU UART pins routed to the connector so we can't
+ * use it.
+ * Max3110 SPI-UART is a stand-alone chip with SPI interface located in the
+ * debug card. Drivers can access to this chip via Soc's SPI controller or SSP
+ * controller(working in SPI mode).
+ * Max3110 is available for mrst, mdfld, clv and mrfld. But for mrst, mdfld
+ * and clv, MAX3110 is connected to SPI controller, for mrfld, MAX3110 is
+ * connected to SSP controller.
  */
 
 #include <linux/serial_reg.h>
@@ -22,7 +30,11 @@
 #include <linux/console.h>
 #include <linux/kernel.h>
 #include <linux/delay.h>
+#include <linux/init.h>
 #include <linux/io.h>
+#include <linux/sched.h>
+#include <linux/hardirq.h>
+#include <linux/pti.h>
 
 #include <asm/fixmap.h>
 #include <asm/pgtable.h>
@@ -31,7 +43,10 @@
 #define MRST_SPI_TIMEOUT		0x200000
 #define MRST_REGBASE_SPI0		0xff128000
 #define MRST_REGBASE_SPI1		0xff128400
+#define CLV_REGBASE_SPI1		0xff135000
 #define MRST_CLK_SPI0_REG		0xff11d86c
+#define MRFLD_SSP_TIMEOUT		0x200000
+#define MRFLD_REGBASE_SSP5		0xff189000
 
 /* Bit fields in CTRLR0 */
 #define SPI_DFS_OFFSET			0
@@ -65,6 +80,15 @@
 #define SR_TX_ERR			(1 << 5)
 #define SR_DCOL				(1 << 6)
 
+/* SR bit fields for SSP*/
+#define SSP_SR_TF_NOT_FULL		(1 << 2)
+
+static int ssp_timing_wr; /* Tangier A0 SSP timing workaround */
+
+static unsigned int early_pti_console_channel;
+static unsigned int early_pti_control_channel;
+
+/* SPI controller registers */
 struct dw_spi_reg {
 	u32	ctrl0;
 	u32	ctrl1;
@@ -95,6 +119,15 @@ struct dw_spi_reg {
 	u32	dr;
 } __packed;
 
+/* SSP controler registers */
+struct dw_ssp_reg {
+	u32 ctrl0;
+	u32 ctrl1;
+	u32 sr;
+	u32 ssitr;
+	u32 dr;
+} __packed;
+
 #define dw_readl(dw, name)		__raw_readl(&(dw)->name)
 #define dw_writel(dw, name, val)	__raw_writel((val), &(dw)->name)
 
@@ -104,6 +137,7 @@ static unsigned long mrst_spi_paddr = MRST_REGBASE_SPI0;
 static u32 *pclk_spi0;
 /* Always contains an accessible address, start with 0 */
 static struct dw_spi_reg *pspi;
+static struct dw_ssp_reg *pssp;
 
 static struct kmsg_dumper dw_dumper;
 static int dumper_registered;
@@ -122,7 +156,7 @@ static void dw_kmsg_dump(struct kmsg_dumper *dumper,
 }
 
 /* Set the ratio rate to 115200, 8n1, IRQ disabled */
-static void max3110_write_config(void)
+static void max3110_spi_write_config(void)
 {
 	u16 config;
 
@@ -131,7 +165,7 @@ static void max3110_write_config(void)
 }
 
 /* Translate char to a eligible word and send to max3110 */
-static void max3110_write_data(char c)
+static void max3110_spi_write_data(char c)
 {
 	u16 data;
 
@@ -139,6 +173,30 @@ static void max3110_write_data(char c)
 	dw_writel(pspi, dr, data);
 }
 
+/* similar to max3110_spi_write_config, but via SSP controller */
+static void max3110_ssp_write_config(void)
+{
+	u16 config;
+
+	config = 0xc001;
+	dw_writel(pssp, dr, config);
+	dw_readl(pssp, dr);
+	udelay(10);
+	return;
+}
+
+/* similar to max3110_spi_write_data, but via SSP controller */
+static void max3110_ssp_write_data(char c)
+{
+	u16 data;
+
+	data = 0x8000 | c;
+	dw_writel(pssp, dr, data);
+	dw_readl(pssp, dr);
+	udelay(10);
+	return;
+}
+
 void mrst_early_console_init(void)
 {
 	u32 ctrlr0 = 0;
@@ -153,6 +211,8 @@ void mrst_early_console_init(void)
 
 	if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_PENWELL)
 		mrst_spi_paddr = MRST_REGBASE_SPI1;
+	else if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_CLOVERVIEW)
+		mrst_spi_paddr = CLV_REGBASE_SPI1;
 
 	pspi = (void *)set_fixmap_offset_nocache(FIX_EARLYCON_MEM_BASE,
 						mrst_spi_paddr);
@@ -185,7 +245,7 @@ void mrst_early_console_init(void)
 	dw_writel(pspi, ssienr, 0x1);
 
 	/* Set the default configuration */
-	max3110_write_config();
+	max3110_spi_write_config();
 
 	/* Register the kmsg dumper */
 	if (!dumper_registered) {
@@ -214,12 +274,12 @@ static void early_mrst_spi_putc(char c)
 	if (!timeout)
 		pr_warn("MRST earlycon: timed out\n");
 	else
-		max3110_write_data(c);
+		max3110_spi_write_data(c);
 }
 
 /* Early SPI only uses polling mode */
 static void early_mrst_spi_write(struct console *con, const char *str,
-					unsigned n)
+				unsigned n)
 {
 	int i;
 
@@ -238,11 +298,108 @@ struct console early_mrst_console = {
 	.index =	-1,
 };
 
+void mrfld_early_console_init(void)
+{
+	u32 ctrlr0 = 0;
+
+	set_fixmap_nocache(FIX_EARLYCON_MEM_BASE, MRFLD_REGBASE_SSP5);
+
+	pssp = (void *)(__fix_to_virt(FIX_EARLYCON_MEM_BASE) +
+			(MRFLD_REGBASE_SSP5 & (PAGE_SIZE - 1)));
+
+	if (intel_mid_identify_sim() == INTEL_MID_CPU_SIMULATION_NONE)
+		ssp_timing_wr = 1;
+
+	/* mask interrupts, clear enable and set DSS config */
+	/* SSPSCLK on active transfers only */
+	if (ssp_timing_wr) {
+		dw_writel(pssp, ctrl0, 0xc12c0f);
+		dw_writel(pssp, ctrl1, 0x0);
+	} else {
+		dw_writel(pssp, ctrl0, 0xc0000f);
+		dw_writel(pssp, ctrl1, 0x10000000);
+	}
+
+	dw_readl(pssp, sr);
+
+	/* enable port */
+	ctrlr0 = dw_readl(pssp, ctrl0);
+	ctrlr0 |= 0x80;
+	dw_writel(pssp, ctrl0, ctrlr0);
+}
+
+/* slave select should be called in the read/write function */
+static int early_mrfld_putc(char c)
+{
+	unsigned int timeout;
+	u32 sr;
+
+	timeout = MRFLD_SSP_TIMEOUT;
+	/* early putc need make sure the TX FIFO is not full*/
+	while (timeout--) {
+		sr = dw_readl(pssp, sr);
+		if (ssp_timing_wr) {
+			if (sr & 0xF00)
+				cpu_relax();
+			else
+				break;
+		} else {
+			if (!(sr & SSP_SR_TF_NOT_FULL))
+				cpu_relax();
+			else
+				break;
+		}
+	}
+
+	if (timeout == 0xffffffff) {
+		pr_info("SSP: waiting timeout\n");
+		return -1;
+	}
+
+	max3110_ssp_write_data(c);
+	return 0;
+}
+
+static void early_mrfld_write(struct console *con,
+				const char *str, unsigned n)
+{
+	int  i;
+
+	for (i = 0; i < n && *str; i++) {
+		if (*str == '\n')
+			early_mrfld_putc('\r');
+		early_mrfld_putc(*str);
+
+		str++;
+	}
+}
+
+struct console early_mrfld_console = {
+	.name =		"earlymrfld",
+	.write =	early_mrfld_write,
+	.flags =	CON_PRINTBUFFER,
+	.index =	-1,
+};
+
+void mrfld_early_printk(const char *fmt, ...)
+{
+	char buf[512];
+	int n;
+	va_list ap;
+
+	va_start(ap, fmt);
+	n = vscnprintf(buf, 512, fmt, ap);
+	va_end(ap);
+
+	early_mrfld_console.write(&early_mrfld_console, buf, n);
+}
+
 /*
- * Following is the early console based on Medfield HSU (High
- * Speed UART) device.
+ * Following is the early console based on High Speed UART device.
  */
-#define HSU_PORT_BASE		0xffa28080
+#define MERR_HSU_PORT_BASE	0xff010180
+#define MERR_HSU_CLK_CTL	0xff00b830
+#define MFLD_HSU_PORT_BASE	0xffa28080
 
 static void __iomem *phsu;
 
@@ -250,6 +407,16 @@ void hsu_early_console_init(const char *s)
 {
 	unsigned long paddr, port = 0;
 	u8 lcr;
+	int *clkctl;
+
+	if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER) {
+		paddr = MERR_HSU_PORT_BASE;
+		clkctl = (int *)set_fixmap_offset_nocache(FIX_CLOCK_CTL,
+							  MERR_HSU_CLK_CTL);
+	} else {
+		paddr = MFLD_HSU_PORT_BASE;
+		clkctl = NULL;
+	}
 
 	/*
 	 * Select the early HSU console port if specified by user in the
@@ -258,7 +425,7 @@ void hsu_early_console_init(const char *s)
 	if (*s && !kstrtoul(s, 10, &port))
 		port = clamp_val(port, 0, 2);
 
-	paddr = HSU_PORT_BASE + port * 0x80;
+	paddr += port * 0x80;
 	phsu = (void *)set_fixmap_offset_nocache(FIX_EARLYCON_MEM_BASE, paddr);
 
 	/* Disable FIFO */
@@ -267,9 +434,22 @@ void hsu_early_console_init(const char *s)
 	/* Set to default 115200 bps, 8n1 */
 	lcr = readb(phsu + UART_LCR);
 	writeb((0x80 | lcr), phsu + UART_LCR);
-	writeb(0x18, phsu + UART_DLL);
+	writeb(0x01, phsu + UART_DLL);
+	writeb(0x00, phsu + UART_DLM);
 	writeb(lcr,  phsu + UART_LCR);
-	writel(0x3600, phsu + UART_MUL*4);
+	writel(0x0010, phsu + UART_ABR * 4);
+	writel(0x0010, phsu + UART_PS * 4);
+
+	if (intel_mid_identify_cpu() == INTEL_MID_CPU_CHIP_TANGIER) {
+		/* detect HSU clock is 50M or 19.2M */
+		if (clkctl && *clkctl & (1 << 16))
+			writel(0x0120, phsu + UART_MUL * 4); /* for 50M */
+		else
+			writel(0x05DC, phsu + UART_MUL * 4);  /* for 19.2M */
+	} else
+		writel(0x0240, phsu + UART_MUL * 4);
+
+	writel(0x3D09, phsu + UART_DIV * 4);
 
 	writeb(0x8, phsu + UART_MCR);
 	writeb(0x7, phsu + UART_FCR);
@@ -322,3 +502,136 @@ struct console early_hsu_console = {
 	.flags =	CON_PRINTBUFFER,
 	.index =	-1,
 };
+
+void hsu_early_printk(const char *fmt, ...)
+{
+	char buf[512];
+	int n;
+	va_list ap;
+
+	va_start(ap, fmt);
+	n = vscnprintf(buf, 512, fmt, ap);
+	va_end(ap);
+
+	early_hsu_console.write(&early_hsu_console, buf, n);
+}
+
+#define PTI_ADDRESS		0xfd800000
+#define CONTROL_FRAME_LEN 32    /* PTI control frame maximum size */
+
+static void early_pti_write_to_aperture(struct pti_masterchannel *mc,
+					 u8 *buf, int len)
+{
+	int dwordcnt, final, i;
+	u32 ptiword;
+	u8 *p ;
+	u32 pti_phys_address ;
+	u32 __iomem *aperture;
+
+	p = buf;
+
+	/*
+	   calculate the aperture offset from the base using the master and
+	   channel id's.
+	*/
+	pti_phys_address = PTI_ADDRESS +
+				(mc->master << 15) + (mc->channel << 8);
+
+	set_fixmap_nocache(FIX_EARLYCON_MEM_BASE, pti_phys_address);
+	aperture = (void *)(__fix_to_virt(FIX_EARLYCON_MEM_BASE) +
+				(pti_phys_address & (PAGE_SIZE - 1)));
+
+	dwordcnt = len >> 2;
+	final = len - (dwordcnt << 2);		/* final = trailing bytes */
+	if (final == 0 && dwordcnt != 0) {	/* always have a final dword */
+		final += 4;
+		dwordcnt--;
+	}
+
+	for (i = 0; i < dwordcnt; i++) {
+		ptiword = be32_to_cpu(*(u32 *)p);
+		p += 4;
+		iowrite32(ptiword, aperture);
+	}
+
+	aperture += PTI_LASTDWORD_DTS;	/* adding DTS signals that is EOM */
+	ptiword = 0;
+
+	for (i = 0; i < final; i++)
+		ptiword |= *p++ << (24-(8*i));
+
+	iowrite32(ptiword, aperture);
+
+	return;
+}
+
+static int pti_early_console_init(void)
+{
+	early_pti_console_channel = 0;
+	early_pti_control_channel = 0;
+	return 0;
+}
+
+static void early_pti_write(struct console *con,
+			const char *str, unsigned n)
+{
+	static struct pti_masterchannel mccontrol = {.master = 72,
+						     .channel = 0};
+	static struct pti_masterchannel mcconsole = {.master = 73,
+						     .channel = 0};
+	const char *control_format = "%3d %3d %s";
+
+	/*
+	 * Since we access the comm member in current's task_struct,
+	 * we only need to be as large as what 'comm' in that
+	 * structure is.
+	 */
+	char comm[TASK_COMM_LEN];
+	u8 control_frame[CONTROL_FRAME_LEN];
+
+	/* task information */
+	if (in_irq())
+		strncpy(comm, "hardirq", sizeof(comm));
+	else if (in_softirq())
+		strncpy(comm, "softirq", sizeof(comm));
+	else
+		strncpy(comm, current->comm, sizeof(comm));
+
+	/* Absolutely ensure our buffer is zero terminated */
+	comm[TASK_COMM_LEN-1] = 0;
+
+	mccontrol.channel = early_pti_control_channel;
+	early_pti_control_channel = (early_pti_control_channel + 1) & 0x7f;
+
+	mcconsole.channel = early_pti_console_channel;
+	early_pti_console_channel = (early_pti_console_channel + 1) & 0x7f;
+
+	snprintf(control_frame, CONTROL_FRAME_LEN, control_format,
+		mcconsole.master, mcconsole.channel, comm);
+
+	early_pti_write_to_aperture(&mccontrol, control_frame,
+					strlen(control_frame));
+	early_pti_write_to_aperture(&mcconsole, (u8 *)str, n);
+
+}
+
+struct console early_pti_console = {
+	.name =		"earlypti",
+	.early_setup =  pti_early_console_init,
+	.write =	early_pti_write,
+	.flags =	CON_PRINTBUFFER,
+	.index =	-1,
+};
+
+void pti_early_printk(const char *fmt, ...)
+{
+	char buf[512];
+	int n;
+	va_list ap;
+
+	va_start(ap, fmt);
+	n = vscnprintf(buf, sizeof(buf), fmt, ap);
+	va_end(ap);
+
+	early_pti_console.write(&early_pti_console, buf, n);
+}
diff --git a/arch/x86/platform/intel-mid/intel_soc_debug.c b/arch/x86/platform/intel-mid/intel_soc_debug.c
new file mode 100644
index 0000000..d824e59
--- /dev/null
+++ b/arch/x86/platform/intel-mid/intel_soc_debug.c
@@ -0,0 +1,202 @@
+/*
+ * intel_soc_debug.c - This driver provides utility debug api's
+ * Copyright (c) 2013, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <asm/intel-mid.h>
+#include <asm/intel_soc_debug.h>
+
+/* This module currently only supports Intel Tangier
+ * and Anniedale SOCs (CONFIG_INTEL_DEBUG_FEATURE will
+ * only be set in i386_mrfl_defconfig and i386_moor_defconfig).
+ * In addition, a platform check is done in soc_debug_init()
+ * to make sure that this module is only used by appropriate
+ * platforms.
+ */
+#define PGRR_BASE           0xff03a0bc
+#define MAX_MODE_NUMBER     9
+#define MAX_DEBUG_NUMBER    5
+
+static struct dentry *dfs_entry;
+
+enum pgrr_mode {
+	manufacturing_mode = 0x0F,
+	production_mode = 0x07,
+	intel_production_mode = 0x04,
+	oem_production_mode = 0x05,
+	gfx_production_mode = 0x0E,
+	end_user_mode = 0x0B,
+	intel_end_user_mode = 0x08,
+	rma_mode = 0x03,
+	permanent_mode = 0x00
+};
+
+static struct debug_mode {
+	enum pgrr_mode mode;
+	u32 bitmask;
+	char *name;
+} asset_array[] = {
+	{ manufacturing_mode,
+	  DEBUG_FEATURE_PTI | DEBUG_FEATURE_RTIT | DEBUG_FEATURE_USB3DFX |
+	  DEBUG_FEATURE_SOCHAPS | DEBUG_FEATURE_LAKEMORE,
+	  "ManufacturingMode",
+	},
+	{ production_mode,
+	  DEBUG_FEATURE_SOCHAPS | DEBUG_FEATURE_LAKEMORE,
+	  "ProductionMode",
+	},
+	{ intel_production_mode,
+	  DEBUG_FEATURE_PTI | DEBUG_FEATURE_RTIT | DEBUG_FEATURE_USB3DFX |
+	  DEBUG_FEATURE_SOCHAPS | DEBUG_FEATURE_LAKEMORE,
+	  "IntelProductionMode",
+	},
+	{ oem_production_mode,
+	  DEBUG_FEATURE_PTI | DEBUG_FEATURE_RTIT | DEBUG_FEATURE_USB3DFX |
+	  DEBUG_FEATURE_SOCHAPS | DEBUG_FEATURE_LAKEMORE,
+	  "OemProductionMode",
+	},
+	{ gfx_production_mode,
+	  DEBUG_FEATURE_SOCHAPS | DEBUG_FEATURE_LAKEMORE,
+	  "GfxProductionMode",
+	},
+	{ intel_end_user_mode,
+	  DEBUG_FEATURE_PTI | DEBUG_FEATURE_RTIT | DEBUG_FEATURE_USB3DFX |
+	  DEBUG_FEATURE_SOCHAPS | DEBUG_FEATURE_LAKEMORE,
+	  "IntelEndUserMode",
+	},
+	{ end_user_mode,
+	  DEBUG_FEATURE_SOCHAPS | DEBUG_FEATURE_LAKEMORE,
+	  "EndUserMode",
+	},
+	{ rma_mode,
+	  DEBUG_FEATURE_PTI | DEBUG_FEATURE_RTIT | DEBUG_FEATURE_USB3DFX |
+	  DEBUG_FEATURE_SOCHAPS | DEBUG_FEATURE_LAKEMORE,
+	  "RmaMode",
+	},
+	{ permanent_mode,
+	  DEBUG_FEATURE_SOCHAPS | DEBUG_FEATURE_LAKEMORE,
+	  "PermanentMode",
+	}
+};
+
+static int debug_mode_idx; /* index in asset_array */
+
+static struct debug_feature {
+	u32 bit;
+	char *name;
+} debug_feature_array[] = {
+	{ DEBUG_FEATURE_PTI,
+	  "PTI",
+	},
+	{ DEBUG_FEATURE_RTIT,
+	  "RTIT",
+	},
+	{ DEBUG_FEATURE_LAKEMORE,
+	  "LAKERMORE",
+	},
+	{ DEBUG_FEATURE_SOCHAPS,
+	  "SOCHAPS",
+	},
+	{ DEBUG_FEATURE_USB3DFX,
+	  "USB3DFX",
+	},
+};
+
+int cpu_has_debug_feature(u32 bit)
+{
+	if (asset_array[debug_mode_idx].bitmask & bit)
+		return 1;
+
+	return  0;
+}
+EXPORT_SYMBOL(cpu_has_debug_feature);
+
+static int show_debug_feature(struct seq_file *s, void *unused)
+{
+	int i = 0;
+
+	if (debug_mode_idx >= 0 && (debug_mode_idx < MAX_MODE_NUMBER)) {
+		seq_printf(s, "Profile: %s\n",
+			   asset_array[debug_mode_idx].name);
+
+		for (i = 0; i < MAX_DEBUG_NUMBER; i++)
+			if (cpu_has_debug_feature(debug_feature_array[i].bit))
+				seq_printf(s, "%s\n",
+					   debug_feature_array[i].name);
+	}
+
+	return 0;
+}
+
+static int debug_feature_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, show_debug_feature, NULL);
+}
+
+static const struct file_operations debug_feature_ops = {
+	.open		= debug_feature_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+int __init soc_debug_init(void)
+{
+	u32 __iomem *pgrr;
+	int i = 0;
+	enum pgrr_mode soc_debug_setting = 0;
+
+	if ((intel_mid_identify_cpu() != INTEL_MID_CPU_CHIP_TANGIER) &&
+	    (intel_mid_identify_cpu() != INTEL_MID_CPU_CHIP_ANNIEDALE))
+		return -EINVAL;
+
+	/* Read Policy Generator Result Register */
+	pgrr = ioremap_nocache(PGRR_BASE, sizeof(u32));
+	if (pgrr == NULL)
+		return -EFAULT;
+
+	pr_info("pgrr = %08x\n", *pgrr);
+	soc_debug_setting = *pgrr & 0x0F;
+	iounmap(pgrr);
+
+	for (i = 0; i < MAX_MODE_NUMBER; i++)
+		if (asset_array[i].mode == soc_debug_setting)
+			break;
+
+	if (i == MAX_MODE_NUMBER)
+		return -EFAULT;
+
+	debug_mode_idx = i;
+
+	dfs_entry = debugfs_create_file("debug_feature", S_IFREG | S_IRUGO,
+					NULL, NULL, &debug_feature_ops);
+
+	return 0;
+}
+arch_initcall(soc_debug_init);
+
+void __exit soc_debug_exit(void)
+{
+	debugfs_remove(dfs_entry);
+}
+module_exit(soc_debug_exit);
diff --git a/drivers/acpi/acpi_platform.c b/drivers/acpi/acpi_platform.c
index 1d49503..3f471db 100644
--- a/drivers/acpi/acpi_platform.c
+++ b/drivers/acpi/acpi_platform.c
@@ -29,6 +29,8 @@ ACPI_MODULE_NAME("platform");
 static const struct acpi_device_id acpi_platform_device_ids[] = {
 
 	{ "PNP0D40" },
+	{ "BCM43241" },
+	{ "BCM2E1A" },
 	{ "VPC2004" },
 	{ "BCM4752" },
 
diff --git a/drivers/dma/intel_mid_dma_acpi.c b/drivers/dma/intel_mid_dma_acpi.c
index 2bef1ab..9ee8376 100644
--- a/drivers/dma/intel_mid_dma_acpi.c
+++ b/drivers/dma/intel_mid_dma_acpi.c
@@ -59,129 +59,10 @@ struct device *intel_mid_get_acpi_dma(const char *hid)
 }
 EXPORT_SYMBOL_GPL(intel_mid_get_acpi_dma);
 
-#if IS_ENABLED(CONFIG_ACPI)
-static int mid_get_and_map_rsrc(void **dest, struct platform_device *pdev,
-				unsigned int num)
-{
-	struct resource *rsrc;
-	rsrc = platform_get_resource(pdev, IORESOURCE_MEM, num);
-	if (!rsrc) {
-		pr_err("%s: Invalid resource - %d", __func__, num);
-		return -EIO;
-	}
-	pr_debug("rsrc #%d = %#x", num, rsrc->start);
-	*dest = devm_ioremap_nocache(&pdev->dev, rsrc->start, resource_size(rsrc));
-	if (!*dest) {
-		pr_err("%s: unable to map resource: %#x", __func__, rsrc->start);
-		return -EIO;
-	}
-	return 0;
-}
-
-static int mid_platform_get_resources(struct middma_device *mid_device,
-				      struct platform_device *pdev)
-{
-	int ret;
-	pr_debug("%s", __func__);
-
-	/* All ACPI resource request here */
-	/* Get DDR addr from platform resource table */
-	ret = mid_get_and_map_rsrc(&mid_device->dma_base, pdev, 0);
-	if (ret)
-		return ret;
-	pr_debug("dma_base:%p", mid_device->dma_base);
-
-	ret = mid_get_and_map_rsrc(&mid_device->mask_reg, pdev, 1);
-	if (ret)
-		return ret;
-	/* mask_reg should point to ISRX register */
-	mid_device->mask_reg += 0x18;
-	pr_debug("pimr_base:%p", mid_device->mask_reg);
-
-	mid_device->irq = platform_get_irq(pdev, 0);
-	if (mid_device->irq < 0) {
-		pr_err("invalid irq:%d", mid_device->irq);
-		return mid_device->irq;
-	}
-	pr_debug("irq from pdev is:%d", mid_device->irq);
-
-	return 0;
-}
-
-int dma_acpi_probe(struct platform_device *pdev)
-{
-	struct device *dev = &pdev->dev;
-	acpi_handle handle = ACPI_HANDLE(dev);
-	struct acpi_device *device;
-	struct middma_device *mid_device;
-	struct intel_mid_dma_probe_info *info;
-	const char *hid;
-	int ret;
-
-	ret = acpi_bus_get_device(handle, &device);
-	if (ret) {
-		pr_err("%s: could not get acpi device - %d\n", __func__, ret);
-		return -ENODEV;
-	}
-
-	if (acpi_bus_get_status(device) || !device->status.present) {
-		pr_err("%s: device has invalid status", __func__);
-		return -ENODEV;
-	}
-
-	hid = acpi_device_hid(device);
-	pr_info("%s for %s", __func__, hid);
-
-	/* Apply default dma_mask if needed */
-	if (!pdev->dev.dma_mask) {
-		pdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;
-		pdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);
-	}
-
-	ret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
-	if (ret) {
-		pr_err("dma_set_mask failed with err:%d", ret);
-		return ret;
-	}
-
-	ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
-	if (ret) {
-		pr_err("_coherent_mask failed with err:%d", ret);
-		return ret;
-	}
-	info = mid_get_acpi_driver_data(hid);
-	if (!info) {
-		pr_err("acpi driver data is null");
-		goto err_dma;
-	}
-
-	mid_device = mid_dma_setup_context(&pdev->dev, info);
-	if (!mid_device)
-		goto err_dma;
-
-	ret = mid_platform_get_resources(mid_device, pdev);
-	if (ret) {
-		pr_err("Error while get resources:%d", ret);
-		goto err_dma;
-	}
-	platform_set_drvdata(pdev, mid_device);
-	ret = mid_setup_dma(&pdev->dev);
-	if (ret)
-		goto err_dma;
-	pm_runtime_enable(&pdev->dev);
-	acpi_dma_dev = &pdev->dev;
-	pr_debug("%s:completed", __func__);
-	return 0;
-err_dma:
-	pr_err("ERR_MDMA:Probe failed %d\n", ret);
-	return ret;
-}
-#else
 int dma_acpi_probe(struct platform_device *pdev)
 {
 	return -EIO;
 }
-#endif
 
 int dma_acpi_remove(struct platform_device *pdev)
 {
diff --git a/drivers/i2c/busses/i2c-designware-core.c b/drivers/i2c/busses/i2c-designware-core.c
index 726e277..1b57b09 100644
--- a/drivers/i2c/busses/i2c-designware-core.c
+++ b/drivers/i2c/busses/i2c-designware-core.c
@@ -760,100 +760,7 @@ exit:
 }
 EXPORT_SYMBOL(i2c_dw_setup);
 
-#ifdef CONFIG_ACPI
-static int acpi_i2c_get_freq(struct acpi_resource *ares,
-					void *data)
-{
-	struct dw_i2c_dev *i2c = data;
-
-	if (ares->type == ACPI_RESOURCE_TYPE_SERIAL_BUS) {
-		struct acpi_resource_i2c_serialbus *sb;
-
-		sb = &ares->data.i2c_serial_bus;
-		if (sb->type == ACPI_RESOURCE_SERIAL_TYPE_I2C) {
-			i2c->freq = sb->connection_speed;
-			if (i2c->freq == DW_STD_SPEED) {
-				i2c->master_cfg &= ~DW_IC_SPEED_MASK;
-				i2c->master_cfg |= DW_IC_CON_SPEED_STD;
-			} else if (i2c->freq == DW_FAST_SPEED) {
-				i2c->master_cfg &= ~DW_IC_SPEED_MASK;
-				i2c->master_cfg |= DW_IC_CON_SPEED_FAST;
-			} else if (i2c->freq == DW_HIGH_SPEED) {
-				i2c->master_cfg &= ~DW_IC_SPEED_MASK;
-				i2c->master_cfg |= DW_IC_CON_SPEED_HIGH;
-			}
-
-			down(&i2c->lock);
-			i2c_dw_init(i2c);
-			up(&i2c->lock);
-		}
-	}
-
-	return 1;
-}
-
-static acpi_status acpi_i2c_find_device_speed(acpi_handle handle, u32 level,
-					void *data, void **return_value)
-{
-	struct dw_i2c_dev *i2c = data;
-	struct list_head resource_list;
-	struct acpi_device *adev;
-	acpi_status status;
-	unsigned long long sta = 0;
-	int ret;
-
-	if (acpi_bus_get_device(handle, &adev))
-		return AE_OK;
-	if (acpi_bus_get_status(adev) || !adev->status.present)
-		return AE_OK;
-
-	INIT_LIST_HEAD(&resource_list);
-	ret = acpi_dev_get_resources(adev, &resource_list,
-				     acpi_i2c_get_freq, i2c);
-	acpi_dev_free_resource_list(&resource_list);
-
-	if (ret < 0)
-		return AE_OK;
-
-	pr_debug("i2c device: %s, freq: %dkHz\n",
-			dev_name(&adev->dev), i2c->freq/1000);
-
-	return AE_OK;
-}
-
-void i2c_acpi_devices_setup(struct device *pdev, struct dw_i2c_dev *dev)
-{
-	acpi_handle pdev_handle = ACPI_HANDLE(pdev);
-	acpi_handle handle = NULL;
-	acpi_status status;
-
-	if (pdev_handle) {
-		handle = pdev_handle;
-	} else if (dev->controller->acpi_name) {
-		acpi_get_handle(NULL,
-			dev->controller->acpi_name, &handle);
-
-		ACPI_HANDLE_SET(pdev, handle);
-	}
-
-	if (handle == NULL)
-		return;
-
-	acpi_i2c_register_devices(&dev->adapter);
-
-	/* Find I2C adapter bus frequency */
-	status = acpi_walk_namespace(ACPI_TYPE_DEVICE, handle, 1,
-				     acpi_i2c_find_device_speed, NULL,
-				     dev, NULL);
-	if (ACPI_FAILURE(status))
-		dev_warn(pdev, "failed to get I2C bus freq\n");
-
-	/* Set the handle back to its raw value */
-	ACPI_HANDLE_SET(pdev, pdev_handle);
-}
-#else
 void i2c_acpi_devices_setup(struct device *pdev, struct dw_i2c_dev *dev) { }
-#endif
 EXPORT_SYMBOL(i2c_acpi_devices_setup);
 
 void i2c_dw_free(struct device *pdev, struct dw_i2c_dev *dev)
diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index 14ae3e6..bdbc8a1 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -46,15 +46,6 @@
 #include <linux/platform_data/i2c-designware.h>
 #include "i2c-designware-core.h"
 
-#ifdef CONFIG_ACPI
-static const struct acpi_device_id dw_i2c_acpi_ids[] = {
-	{ "80860F41", valleyview_0 },
-	{ "808622C1", cherryview_0 },
-	{ }
-};
-MODULE_DEVICE_TABLE(acpi, dw_i2c_acpi_ids);
-#endif
-
 static int dw_i2c_plat_suspend(struct device *dev)
 {
 	struct platform_device *pdev =
@@ -65,31 +56,6 @@ static int dw_i2c_plat_suspend(struct device *dev)
 	return i2c_dw_suspend(i2c, false);
 }
 
-#ifdef CONFIG_ACPI
-static void dw_i2c_acpi_params(struct platform_device *pdev, char method[],
-			       u16 *hcnt, u16 *lcnt, u32 *sda_hold)
-{
-	struct acpi_buffer buf = { ACPI_ALLOCATE_BUFFER };
-	acpi_handle handle = ACPI_HANDLE(&pdev->dev);
-	union acpi_object *obj;
-
-	if (ACPI_FAILURE(acpi_evaluate_object(handle, method, NULL, &buf)))
-		return;
-
-	obj = (union acpi_object *)buf.pointer;
-	if (obj->type == ACPI_TYPE_PACKAGE && obj->package.count == 3) {
-		const union acpi_object *objs = obj->package.elements;
-
-		*hcnt = (u16)objs[0].integer.value;
-		*lcnt = (u16)objs[1].integer.value;
-		if (sda_hold)
-			*sda_hold = (u32)objs[2].integer.value;
-	}
-
-	kfree(buf.pointer);
-}
-#endif
-
 static int dw_i2c_plat_runtime_suspend(struct device *dev)
 {
 	struct platform_device *pdev =
@@ -139,18 +105,8 @@ static int __init dw_i2c_probe(struct platform_device *pdev)
 	unsigned long start, len;
 	int bus_idx = 0;
 	int irq;
-#ifdef CONFIG_ACPI
-	const struct acpi_device_id *id;
-	static int bus_num;
-
-	for (id = dw_i2c_acpi_ids; id->id[0]; id++)
-		if (!strncmp(id->id, dev_name(&pdev->dev), strlen(id->id))) {
-			bus_idx = id->driver_data + bus_num;
-			bus_num++;
-		}
-#else
+
 	bus_idx = pdev->id;
-#endif
 
 	/* NOTE: driver uses the static register mapping */
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -215,9 +171,6 @@ static struct platform_driver dw_i2c_driver = {
 		.name	= "i2c_designware",
 		.owner	= THIS_MODULE,
 		.pm     = &dw_i2c_plat_pm_ops,
-#ifdef CONFIG_ACPI
-		.acpi_match_table = ACPI_PTR(dw_i2c_acpi_ids),
-#endif
 	},
 };
 
diff --git a/drivers/idle/intel_idle.c b/drivers/idle/intel_idle.c
index a0230b8..aba321d 100644
--- a/drivers/idle/intel_idle.c
+++ b/drivers/idle/intel_idle.c
@@ -61,6 +61,7 @@
 #include <linux/notifier.h>
 #include <linux/cpu.h>
 #include <linux/module.h>
+#include <linux/intel_mid_pm.h>
 #include <asm/cpu_device_id.h>
 #include <asm/mwait.h>
 #include <asm/msr.h>
@@ -455,6 +456,321 @@ static struct cpuidle_state avn_cstates[] = {
 		.enter = NULL }
 };
 
+static struct cpuidle_state vlv_cstates[CPUIDLE_STATE_MAX] = {
+	{ /* MWAIT C1 */
+		.name = "C1-ATM",
+		.desc = "MWAIT 0x00",
+		.flags = MWAIT2flg(0x00) | CPUIDLE_FLAG_TIME_VALID,
+		.exit_latency = 1,
+		.target_residency = 4,
+		.enter = &intel_idle },
+	{ /* MWAIT C4 */
+		.name = "C4-ATM",
+		.desc = "MWAIT 0x30",
+		.flags = MWAIT2flg(0x30) | CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_TLB_FLUSHED,
+		.exit_latency = 100,
+		.target_residency = 400,
+		.enter = &intel_idle },
+	{ /* MWAIT C6 */
+		.name = "C6-ATM",
+		.desc = "MWAIT 0x52",
+		.flags = MWAIT2flg(0x52) | CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_TLB_FLUSHED,
+		.exit_latency = 140,
+		.target_residency = 560,
+		.enter = &intel_idle },
+	{ /* MWAIT C7-S0i1 */
+		.name = "S0i1-ATM",
+		.desc = "MWAIT 0x60",
+		.flags = MWAIT2flg(0x60) | CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_TLB_FLUSHED,
+		.exit_latency = 1200,
+		.target_residency = 4000,
+		.enter = &intel_idle },
+	{ /* MWAIT C8-S0i2 */
+		.name = "S0i2-ATM",
+		.desc = "MWAIT 0x62",
+		.flags = MWAIT2flg(0x62) | CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_TLB_FLUSHED,
+		.exit_latency = 2000,
+		.target_residency = 8000,
+		.enter = &intel_idle },
+	{ /* MWAIT C9-S0i3 */
+		.name = "S0i3-ATM",
+		.desc = "MWAIT 0x64",
+		.flags = MWAIT2flg(0x64) | CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_TLB_FLUSHED,
+		.exit_latency = 10000,
+		.target_residency = 20000,
+		.enter = &intel_idle },
+	{
+		.enter = NULL }
+};
+
+#if defined(CONFIG_REMOVEME_INTEL_ATOM_MRFLD_POWER)
+static struct cpuidle_state mrfld_cstates[CPUIDLE_STATE_MAX] = {
+	{ /* MWAIT C1 */
+		.name = "C1-ATM",
+		.desc = "MWAIT 0x00",
+		.flags = MWAIT2flg(0x00) | CPUIDLE_FLAG_TIME_VALID,
+		.exit_latency = 1,
+		.target_residency = 4,
+		.enter = &intel_idle },
+	{ /* MWAIT C4 */
+		.name = "C4-ATM",
+		.desc = "MWAIT 0x30",
+		.flags = MWAIT2flg(0x30) | CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_TLB_FLUSHED,
+		.exit_latency = 100,
+		.target_residency = 400,
+		.enter = &intel_idle },
+	{ /* MWAIT C6 */
+		.name = "C6-ATM",
+		.desc = "MWAIT 0x52",
+		.flags = MWAIT2flg(0x52) | CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_TLB_FLUSHED,
+		.exit_latency = 140,
+		.target_residency = 560,
+		.enter = &intel_idle },
+	{ /* MWAIT C7-S0i1 */
+		.name = "S0i1-ATM",
+		.desc = "MWAIT 0x60",
+		.flags = MWAIT2flg(0x60) | CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_TLB_FLUSHED,
+		.exit_latency = 1200,
+		.target_residency = 4000,
+		.enter = &intel_idle },
+	{ /* MWAIT C9-S0i3 */
+		.name = "S0i3-ATM",
+		.desc = "MWAIT 0x64",
+		.flags = MWAIT2flg(0x64) | CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_TLB_FLUSHED,
+		.exit_latency = 10000,
+		.target_residency = 20000,
+		.enter = &intel_idle },
+	{
+		.enter = NULL }
+};
+#else
+#define mrfld_cstates atom_cstates
+#endif
+
+#if defined(CONFIG_REMOVEME_INTEL_ATOM_MDFLD_POWER) || \
+	defined(CONFIG_REMOVEME_INTEL_ATOM_CLV_POWER)
+
+static struct cpuidle_state mfld_cstates[CPUIDLE_STATE_MAX] = {
+	{ /* MWAIT C1 */
+		.name = "ATM-C1",
+		.desc = "MWAIT 0x00",
+		.flags = MWAIT2flg(0x00) | CPUIDLE_FLAG_TIME_VALID,
+		.exit_latency = CSTATE_EXIT_LATENCY_C1,
+		.target_residency = 4,
+		.enter = &intel_idle },
+	{ /* MWAIT C2 */
+		.name = "ATM-C2",
+		.desc = "MWAIT 0x10",
+		.flags = MWAIT2flg(0x10) | CPUIDLE_FLAG_TIME_VALID,
+		.exit_latency = CSTATE_EXIT_LATENCY_C2,
+		.target_residency = 80,
+		.enter = &intel_idle },
+	{ /* MWAIT C4 */
+		.name = "ATM-C4",
+		.desc = "MWAIT 0x30",
+		.flags = MWAIT2flg(0x30) | CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_TLB_FLUSHED,
+		.exit_latency = CSTATE_EXIT_LATENCY_C4,
+		.target_residency = 400,
+		.enter = &intel_idle },
+	{ /* MWAIT C6 */
+		.name = "ATM-C6",
+		.desc = "MWAIT 0x52",
+		.flags = MWAIT2flg(0x52) | CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_TLB_FLUSHED,
+		.exit_latency = CSTATE_EXIT_LATENCY_C6,
+		.power_usage  = C6_POWER_USAGE,
+		.target_residency = 560,
+		.enter = &soc_s0ix_idle },
+	{
+		.name = "ATM-S0i1",
+		.desc = "MWAIT 0x52",
+		.flags = MWAIT2flg(0x52) | CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_TLB_FLUSHED,
+		.exit_latency = CSTATE_EXIT_LATENCY_S0i1,
+		.power_usage  = S0I1_POWER_USAGE,
+		.enter = &soc_s0ix_idle },
+	{
+		.name = "ATM-LpAudio",
+		.desc = "MWAIT 0x52",
+		.flags = MWAIT2flg(0x52) | CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_TLB_FLUSHED,
+		.exit_latency = CSTATE_EXIT_LATENCY_LPMP3,
+		.power_usage  = LPMP3_POWER_USAGE,
+		.enter = &soc_s0ix_idle },
+	{
+		.name = "ATM-S0i3",
+		.desc = "MWAIT 0x52",
+		.flags = MWAIT2flg(0x52) | CPUIDLE_FLAG_TIME_VALID | CPUIDLE_FLAG_TLB_FLUSHED,
+		.exit_latency = CSTATE_EXIT_LATENCY_S0i3,
+		.power_usage  = S0I3_POWER_USAGE,
+		.enter = &soc_s0ix_idle },
+	{
+		.enter = NULL }
+};
+
+static int enter_s0ix_state(u32 eax, int gov_req_state, int s0ix_state,
+		  struct cpuidle_device *dev, int index)
+{
+	int s0ix_entered = 0;
+	int selected_state = C6_STATE_IDX;
+
+	if (atomic_add_return(1, &nr_cpus_in_c6) == num_online_cpus() &&
+		 s0ix_state) {
+		s0ix_entered = mid_s0ix_enter(s0ix_state);
+		if (!s0ix_entered) {
+			if (pmu_is_s0ix_in_progress()) {
+				atomic_dec(&nr_cpus_in_c6);
+				eax = C4_HINT;
+			}
+			pmu_set_s0ix_complete();
+		}
+	}
+	switch (s0ix_state) {
+	case MID_S0I1_STATE:
+		trace_cpu_idle(S0I1_STATE_IDX, dev->cpu);
+		break;
+	case MID_LPMP3_STATE:
+		trace_cpu_idle(LPMP3_STATE_IDX, dev->cpu);
+		break;
+	case MID_S0I3_STATE:
+		trace_cpu_idle(S0I3_STATE_IDX, dev->cpu);
+		break;
+	case MID_S3_STATE:
+		trace_cpu_idle(S0I3_STATE_IDX, dev->cpu);
+		break;
+	default:
+		trace_cpu_idle((eax >> 4) + 1, dev->cpu);
+	}
+	__monitor((void *)&current_thread_info()->flags, 0, 0);
+	smp_mb();
+	if (!need_resched())
+		__mwait(eax, 1);
+
+	if (likely(eax == C6_HINT))
+		atomic_dec(&nr_cpus_in_c6);
+
+	/* During s0ix exit inform scu that OS
+	 * has exited. In case scu is still waiting
+	 * for ack c6 trigger, it would exit out
+	 * of the ack-c6 timeout loop
+	 */
+	pmu_set_s0ix_complete();
+
+	/* In case of demotion to S0i1/lpmp3 update last_state */
+	if (s0ix_entered) {
+		selected_state = S0I3_STATE_IDX;
+
+		if (s0ix_state == MID_S0I1_STATE) {
+			index = S0I1_STATE_IDX;
+			selected_state = S0I1_STATE_IDX;
+		} else if (s0ix_state == MID_LPMP3_STATE) {
+			index = LPMP3_STATE_IDX;
+			selected_state = LPMP3_STATE_IDX;
+		}
+	} else if (eax == C4_HINT) {
+		index = C4_STATE_IDX;
+		selected_state = C4_STATE_IDX;
+	} else
+		index = C6_STATE_IDX;
+
+	pmu_s0ix_demotion_stat(gov_req_state, selected_state);
+
+	return index;
+}
+
+static int soc_s0ix_idle(struct cpuidle_device *dev,
+		struct cpuidle_driver *drv, int index)
+{
+	struct cpuidle_state *state = &drv->states[index];
+	unsigned long eax = flg2MWAIT(state->flags);
+	int cpu = smp_processor_id();
+	int s0ix_state   = 0;
+	unsigned int cstate;
+	int gov_req_state = (int) eax;
+
+	/* Check if s0ix is already in progress,
+	 * This is required to demote C6 while S0ix
+	 * is in progress
+	 */
+	if (unlikely(pmu_is_s0ix_in_progress()))
+		return intel_idle(dev, drv, C4_STATE_IDX);
+
+	/* check if we need/possible to do s0ix */
+	if (eax != C6_HINT)
+		s0ix_state = get_target_platform_state(&eax);
+
+	/*
+	 * leave_mm() to avoid costly and often unnecessary wakeups
+	 * for flushing the user TLB's associated with the active mm.
+	 */
+	if (state->flags & CPUIDLE_FLAG_TLB_FLUSHED)
+		leave_mm(cpu);
+
+	cstate = (((eax) >> MWAIT_SUBSTATE_SIZE) & MWAIT_CSTATE_MASK) + 1;
+
+	if (!(lapic_timer_reliable_states & (1 << (cstate))))
+		clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_ENTER, &cpu);
+
+	stop_critical_timings();
+
+	if (!need_resched())
+		index = enter_s0ix_state(eax, gov_req_state,
+					s0ix_state, dev, index);
+
+	start_critical_timings();
+
+	if (!(lapic_timer_reliable_states & (1 << (cstate))))
+		clockevents_notify(CLOCK_EVT_NOTIFY_BROADCAST_EXIT, &cpu);
+
+	return index;
+}
+#else
+#define mfld_cstates atom_cstates
+#endif
+
+#ifdef CONFIG_ATOM_SOC_POWER
+static unsigned int get_target_residency(unsigned int cstate)
+{
+	unsigned int t_sleep = cpuidle_state_table[cstate].target_residency;
+	unsigned int prev_idx;
+
+	/* get the previous lower sleep state */
+	if ((cstate == 8) || (cstate == 9))
+		prev_idx = cstate - 2;
+	else
+		prev_idx = cstate - 1;
+
+	/* calculate target_residency only if not defined already */
+	if (!t_sleep) {
+		unsigned int p_active = cpuidle_state_table[0].power_usage;
+		unsigned int prev_state_power = cpuidle_state_table
+							[prev_idx].power_usage;
+		unsigned int curr_state_power = cpuidle_state_table
+							[cstate].power_usage;
+		unsigned int prev_state_lat = cpuidle_state_table
+							[prev_idx].exit_latency;
+		unsigned int curr_state_lat = cpuidle_state_table
+							[cstate].exit_latency;
+
+		if (curr_state_power && prev_state_power && p_active &&
+		    prev_state_lat && curr_state_lat &&
+		    (curr_state_lat > prev_state_lat) &&
+		    (prev_state_power > curr_state_power)) {
+			t_sleep = (p_active * (curr_state_lat - prev_state_lat)
+					+ (prev_state_lat * prev_state_power)
+					- (curr_state_lat * curr_state_power)) /
+				  (prev_state_power - curr_state_power);
+
+			/* round-up target_residency */
+			t_sleep++;
+		}
+	}
+
+	WARN_ON(!t_sleep);
+
+	pr_debug(PREFIX "cpuidle: target_residency[%d]= %d\n", cstate, t_sleep);
+
+	return t_sleep;
+}
+#endif
+
 /**
  * intel_idle
  * @dev: cpuidle_device
@@ -472,6 +788,17 @@ static int intel_idle(struct cpuidle_device *dev,
 	unsigned int cstate;
 	int cpu = smp_processor_id();
 
+#if (defined(CONFIG_REMOVEME_INTEL_ATOM_MRFLD_POWER) && \
+	defined(CONFIG_PM_DEBUG))
+	{
+		/* Get Cstate based on ignore table from PMU driver */
+		unsigned int ncstate;
+		cstate =
+		(((eax) >> MWAIT_SUBSTATE_SIZE) & MWAIT_CSTATE_MASK) + 1;
+		ncstate = pmu_get_new_cstate(cstate, &index);
+		eax	= flg2MWAIT(drv->states[index].flags);
+	}
+#endif
 	cstate = (((eax) >> MWAIT_SUBSTATE_SIZE) & MWAIT_CSTATE_MASK) + 1;
 
 	/*
@@ -596,6 +923,10 @@ static const struct idle_cpu idle_cpu_avn = {
 	.disable_promotion_to_c1e = true,
 };
 
+static const struct idle_cpu idle_cpu_mrfld = {
+	.state_table = mrfld_cstates,
+};
+
 #define ICPU(model, cpu) \
 	{ X86_VENDOR_INTEL, 6, model, X86_FEATURE_MWAIT, (unsigned long)&cpu }
 
@@ -622,6 +953,7 @@ static const struct x86_cpu_id intel_idle_ids[] = {
 	ICPU(0x3d, idle_cpu_bdw),
 	ICPU(0x4f, idle_cpu_bdw),
 	ICPU(0x56, idle_cpu_bdw),
+	ICPU(0x4a, idle_cpu_mrfld),	/* Tangier SoC */
 	{}
 };
 MODULE_DEVICE_TABLE(x86cpu, intel_idle_ids);
@@ -719,14 +1051,24 @@ static int __init intel_idle_cpuidle_driver_init(void)
 		mwait_hint = flg2MWAIT(cpuidle_state_table[cstate].flags);
 		mwait_cstate = MWAIT_HINT2CSTATE(mwait_hint);
 
-		/* number of sub-states for this state in CPUID.MWAIT */
-		num_substates = (mwait_substates >> ((mwait_cstate + 1) * 4))
+		/* FIXME: Do not check number of substates for any states above C6
+		 * as these are not real C states supported by the CPU, they
+		 * are emulated c states for s0ix support.
+		*/
+		if ((cstate + 1) < 6) {
+			num_substates = (mwait_substates >> ((mwait_cstate + 1) * 4))
 					& MWAIT_SUBSTATE_MASK;
-
-		/* if NO sub-states for this state in CPUID, skip it */
-		if (num_substates == 0)
-			continue;
-
+			if (num_substates == 0)
+				continue;
+		}
+ 
+#if !defined(CONFIG_ATOM_SOC_POWER)
+		if (boot_cpu_data.x86_model != 0x37) {
+			/* if sub-state in table is not enumerated by CPUID */
+			if ((mwait_substate + 1) > num_substates)
+				continue;
+		}
+#endif
 		if (((mwait_cstate + 1) > 2) &&
 			!boot_cpu_has(X86_FEATURE_NONSTOP_TSC))
 			mark_tsc_unstable("TSC halts in idle"
diff --git a/drivers/misc/bcm-lpm/bcm_bt_lpm.c b/drivers/misc/bcm-lpm/bcm_bt_lpm.c
index 335a925..8cfeee6 100644
--- a/drivers/misc/bcm-lpm/bcm_bt_lpm.c
+++ b/drivers/misc/bcm-lpm/bcm_bt_lpm.c
@@ -31,18 +31,7 @@
 #include <asm/intel-mid.h>
 #include <asm/intel_mid_hsu.h>
 
-#ifndef CONFIG_ACPI
 #include <asm/bcm_bt_lpm.h>
-#else
-#include <linux/acpi.h>
-#include <linux/acpi_gpio.h>
-
-enum {
-	gpio_wake_acpi_idx,
-	gpio_enable_bt_acpi_idx,
-	host_wake_acpi_idx
-};
-#endif
 
 static struct rfkill *bt_rfkill;
 static bool bt_enabled;
@@ -87,72 +76,6 @@ static void uart_disable(struct device *tty)
 }
 #endif
 
-#ifdef CONFIG_ACPI
-static int bcm_bt_lpm_acpi_probe(struct platform_device *pdev)
-{
-	struct acpi_gpio_info info;
-	acpi_handle handle;
-	acpi_integer port;
-
-	/*
-	 * Handle ACPI specific initializations.
-	 */
-	dev_dbg(&pdev->dev, "BCM2E1A ACPI specific probe\n");
-
-	bt_lpm.gpio_enable_bt = acpi_get_gpio_by_index(&pdev->dev,
-						gpio_enable_bt_acpi_idx, &info);
-	if (!gpio_is_valid(bt_lpm.gpio_enable_bt)) {
-		pr_err("%s: gpio %d for gpio_enable_bt not valid\n", __func__,
-							bt_lpm.gpio_enable_bt);
-		return -EINVAL;
-	}
-
-#ifdef LPM_ON
-	bt_lpm.gpio_wake = acpi_get_gpio_by_index(&pdev->dev,
-						gpio_wake_acpi_idx, &info);
-	if (!gpio_is_valid(bt_lpm.gpio_wake)) {
-		pr_err("%s: gpio %d for gpio_wake not valid\n", __func__,
-							bt_lpm.gpio_wake);
-		return -EINVAL;
-	}
-
-	bt_lpm.gpio_host_wake = acpi_get_gpio_by_index(&pdev->dev,
-						host_wake_acpi_idx, &info);
-	if (!gpio_is_valid(bt_lpm.gpio_host_wake)) {
-		pr_err("%s: gpio %d for gpio_host_wake not valid\n", __func__,
-							bt_lpm.gpio_host_wake);
-		return -EINVAL;
-	}
-
-	bt_lpm.int_host_wake = gpio_to_irq(bt_lpm.gpio_host_wake);
-
-	pr_debug("%s: gpio_wake %d, gpio_host_wake %d, int_host_wake %d\n",
-							__func__,
-							bt_lpm.gpio_wake,
-							bt_lpm.gpio_host_wake,
-							bt_lpm.int_host_wake);
-#endif
-
-	handle = DEVICE_ACPI_HANDLE(&pdev->dev);
-
-	if (ACPI_FAILURE(acpi_evaluate_integer(handle, "UART", NULL, &port))) {
-		dev_err(&pdev->dev, "Error evaluating UART port number\n");
-
-		/* FIXME - Force port 0 if the information is missing from the
-		 * ACPI table.
-		 * That will be removed once the ACPI tables will all have been
-		 * updated.
-		 */
-		 port = 0;
-	}
-
-	bt_lpm.port = port;
-	pr_debug("%s: UART port %d\n", __func__, bt_lpm.port);
-
-	return 0;
-}
-#endif /* CONFIG_ACPI */
-
 static int bcm43xx_bt_rfkill_set_power(void *data, bool blocked)
 {
 	/* rfkill_ops callback. Turn transmitter on when blocked is false */
@@ -334,7 +257,6 @@ static int bcm_bt_lpm_init(struct platform_device *pdev)
 }
 #endif
 
-#ifndef CONFIG_ACPI
 static int bcm43xx_bluetooth_pdata_probe(struct platform_device *pdev)
 {
 	struct bcm_bt_lpm_platform_data *pdata = pdev->dev.platform_data;
@@ -366,7 +288,6 @@ static int bcm43xx_bluetooth_pdata_probe(struct platform_device *pdev)
 
 	return 0;
 }
-#endif /* !CONFIG_ACPI */
 
 static int bcm43xx_bluetooth_probe(struct platform_device *pdev)
 {
@@ -375,20 +296,7 @@ static int bcm43xx_bluetooth_probe(struct platform_device *pdev)
 
 	int_handler_enabled = false;
 
-#ifdef CONFIG_ACPI
-	if (ACPI_HANDLE(&pdev->dev)) {
-		/*
-		 * acpi specific probe
-		 */
-		pr_debug("%s for ACPI device %s\n", __func__,
-							dev_name(&pdev->dev));
-		if (bcm_bt_lpm_acpi_probe(pdev) < 0)
-			ret = -EINVAL;
-	} else
-		ret = -ENODEV;
-#else
 	ret = bcm43xx_bluetooth_pdata_probe(pdev);
-#endif
 
 	if (ret < 0) {
 		pr_err("%s: Cannot register platform data\n", __func__);
@@ -532,17 +440,6 @@ int bcm43xx_bluetooth_resume(struct platform_device *pdev)
 }
 #endif
 
-#ifdef CONFIG_ACPI
-static struct acpi_device_id bcm_id_table[] = {
-	/* ACPI IDs here */
-	{ "BCM2E1A", 0 },
-	{ "BCM2E3A", 0 },
-	{ }
-};
-
-MODULE_DEVICE_TABLE(acpi, bcm_id_table);
-#endif
-
 static struct platform_driver bcm43xx_bluetooth_platform_driver = {
 	.probe = bcm43xx_bluetooth_probe,
 	.remove = bcm43xx_bluetooth_remove,
@@ -553,9 +450,6 @@ static struct platform_driver bcm43xx_bluetooth_platform_driver = {
 	.driver = {
 		   .name = "bcm_bt_lpm",
 		   .owner = THIS_MODULE,
-#ifdef CONFIG_ACPI
-		.acpi_match_table = ACPI_PTR(bcm_id_table),
-#endif
 		   },
 };
 
diff --git a/drivers/misc/emmc_ipanic.c b/drivers/misc/emmc_ipanic.c
new file mode 100644
index 0000000..ab587e4
--- /dev/null
+++ b/drivers/misc/emmc_ipanic.c
@@ -0,0 +1,1158 @@
+/*
+ * drivers/misc/emmc_ipanic.c
+ *
+ * Copyright (C) 2011 Intel Corp
+ * Author: dongxing.zhang@intel.com
+ * Author: jun.zhang@intel.com
+ * Author: chuansheng.liu@intel.com
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/platform_device.h>
+#include <linux/uaccess.h>
+#include <linux/notifier.h>
+#include <linux/mmc/host.h>
+#include <linux/debugfs.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/preempt.h>
+#include <linux/pci.h>
+#include <linux/nmi.h>
+#include <linux/blkdev.h>
+#include <linux/genhd.h>
+#include <linux/panic_gbuffer.h>
+#include "emmc_ipanic.h"
+
+#include <linux/kmsg_dump.h>
+
+static char *part_label = "";
+module_param(part_label, charp, 0);
+MODULE_PARM_DESC(part_label, "IPanic mmc partition device label (panic)");
+
+static u32 disable_emmc_ipanic;
+core_param(disable_emmc_ipanic, disable_emmc_ipanic, uint, 0644);
+
+static struct mmc_emergency_info emmc_info = {
+	.init = mmc_emergency_init,
+	.write = mmc_emergency_write,
+	.part_label = CONFIG_EMMC_IPANIC_PLABEL,
+};
+
+static unsigned char *ipanic_proc_entry_name[PROC_MAX_ENTRIES] = {
+	"emmc_ipanic_header",
+	"emmc_ipanic_console",
+	"emmc_ipanic_threads",
+	"emmc_ipanic_gbuffer"
+};
+
+static int in_panic;
+static struct emmc_ipanic_data drv_ctx;
+static struct work_struct proc_removal_work;
+static int log_offset[IPANIC_LOG_MAX];
+static int log_len[IPANIC_LOG_MAX];	/* sector count */
+static int log_size[IPANIC_LOG_MAX];	/* byte count */
+static size_t log_head[IPANIC_LOG_MAX];
+static size_t log_woff[IPANIC_LOG_MAX];
+static unsigned char last_chunk_buf[SECTOR_SIZE];
+static int last_chunk_buf_len;
+static DEFINE_MUTEX(drv_mutex);
+static void (*func_stream_emmc) (void);
+
+static struct kmsg_dumper ipanic_dumper;
+
+static void emmc_panic_erase(unsigned char *buffer, Sector * sect)
+{
+	struct emmc_ipanic_data *ctx = &drv_ctx;
+	struct mmc_emergency_info *emmc = ctx->emmc;
+	unsigned char *read_buf_ptr = buffer;
+	Sector new_sect;
+	int rc;
+
+	if (!emmc) {
+		pr_err("%s:invalid emmc infomation\n", __func__);
+		return;
+	}
+
+	if (!read_buf_ptr || !sect) {
+		sect = &new_sect;
+		if (!emmc->bdev) {
+			pr_err("%s:invalid emmc block device\n", __func__);
+			goto out;
+		}
+		/* make sure the block device is open rw */
+		rc = blkdev_get(emmc->bdev, FMODE_READ | FMODE_WRITE,
+				emmc_panic_erase);
+		if (rc < 0) {
+			pr_err("%s: blk_dev_get failed!\n", __func__);
+			goto out;
+		}
+
+		/*read panic header */
+		read_buf_ptr =
+		    read_dev_sector(emmc->bdev, emmc->start_block, sect);
+		if (!read_buf_ptr) {
+			pr_err("%s: read sector error(%llu)!\n",
+			       __func__, (u64) emmc->start_block);
+			goto out;
+		}
+	}
+
+	/*write all zero to panic header */
+	lock_page(sect->v);
+	memset(read_buf_ptr, 0, SECTOR_SIZE);
+	set_page_dirty(sect->v);
+	unlock_page(sect->v);
+	sync_blockdev(emmc->bdev);
+
+	if (!read_buf_ptr)
+		put_dev_sector(*sect);
+out:
+	memset(&ctx->hdr, 0, SECTOR_SIZE);
+	return;
+}
+
+static int emmc_read(struct mmc_emergency_info *emmc, void *holder,
+		     char *buffer, off_t offset, int count, bool to_user)
+{
+	unsigned char *read_ptr;
+	unsigned int sector_no;
+	off_t sector_offset;
+	Sector sect;
+	int rc;
+
+	if (!emmc) {
+		pr_err("%s:invalid emmc infomation\n", __func__);
+		return 0;
+	}
+	if (!emmc->bdev) {
+		pr_err("%s:invalid emmc block device\n", __func__);
+		return 0;
+	}
+
+	sector_no = offset >> SECTOR_SIZE_SHIFT;
+	sector_offset = offset & (SECTOR_SIZE - 1);
+	if (sector_no >= emmc->block_count) {
+		pr_err("%s: reading an invalid address\n", __func__);
+		return -EINVAL;
+	}
+
+	/* make sure the block device is open rw */
+	rc = blkdev_get(emmc->bdev, FMODE_READ | FMODE_WRITE, holder);
+	if (rc < 0) {
+		pr_err("%s: blk_dev_get failed!\n", __func__);
+		return 0;
+	}
+
+	read_ptr = read_dev_sector(emmc->bdev, sector_no + emmc->start_block,
+				   &sect);
+	if (!read_ptr) {
+		put_dev_sector(sect);
+		return -EINVAL;
+	}
+	/* count and read_ptr are updated to match flash page size */
+	if (count + sector_offset > SECTOR_SIZE)
+		count = SECTOR_SIZE - sector_offset;
+
+	if (sector_offset)
+		read_ptr += sector_offset;
+
+	if (to_user) {
+		if (copy_to_user(buffer, read_ptr, count)) {
+			pr_err("%s: Failed to copy buffer to User\n", __func__);
+			return 0;
+		}
+	} else
+		memcpy(buffer, read_ptr, count);
+
+	put_dev_sector(sect);
+
+	return count;
+}
+
+static ssize_t emmc_ipanic_gbuffer_proc_read(struct file *file,
+					     char __user * buffer, size_t count,
+					     loff_t * ppos)
+{
+	struct emmc_ipanic_data *ctx = &drv_ctx;
+	size_t log_len, log_head;
+	off_t log_off;
+	int rc;
+
+	if (!ctx) {
+		pr_err("%s:invalid panic handler\n", __func__);
+		return 0;
+	}
+
+	if (!count)
+		return 0;
+
+	mutex_lock(&drv_mutex);
+
+	log_off = ctx->curr.log_offset[IPANIC_LOG_GBUFFER];
+	log_len = ctx->curr.log_length[IPANIC_LOG_GBUFFER];
+	log_head = ctx->curr.log_head[IPANIC_LOG_GBUFFER];
+
+	if (*ppos >= log_len) {
+		mutex_unlock(&drv_mutex);
+		return 0;
+	}
+
+	if (*ppos < log_len - log_head) {
+		/* No overflow (log_head == 0)
+		 * or
+		 * overflow 2nd part buf (log_head = log_woff)
+		 * |-------w--------|
+		 *           off^
+		 *         |--------|
+		 */
+		log_off += log_head;
+		log_len -= log_head;
+	} else {
+		/* 1st part buf
+		 * |-------w--------|
+		 *   off^
+		 * |-------|
+		 */
+		*ppos -= (log_len - log_head);
+		log_len = log_head;
+	}
+
+	if ((*ppos + count) > log_len)
+		count = log_len - *ppos;
+
+	rc = emmc_read(ctx->emmc, emmc_ipanic_gbuffer_proc_read,
+		       buffer, log_off + *ppos, count, true);
+	if (rc <= 0) {
+		mutex_unlock(&drv_mutex);
+		pr_err
+		    ("%s: emmc_read: invalid args: offset:0x%08llx, count:%zd",
+		     __func__, (u64) (log_off + *ppos), count);
+		return rc;
+	}
+
+	*ppos += rc;
+
+	mutex_unlock(&drv_mutex);
+
+	return rc;
+}
+
+static ssize_t emmc_ipanic_proc_read_by_log(struct file *file,
+					    char __user * buffer, size_t count,
+					    loff_t * ppos, int log)
+{
+	struct emmc_ipanic_data *ctx = &drv_ctx;
+	size_t file_length;
+	off_t file_offset;
+	int rc;
+
+	if (!ctx) {
+		pr_err("%s:invalid panic handler\n", __func__);
+		return 0;
+	}
+
+	if (!count)
+		return 0;
+
+	if (log < 0 || log > IPANIC_LOG_MAX) {
+		pr_err("%s: Bad log number (%d)\n", __func__, log);
+		return -EINVAL;
+	}
+
+	mutex_lock(&drv_mutex);
+
+	if (log == IPANIC_LOG_HEADER) {
+		file_length = ctx->hdr.log_size;
+		file_offset = offsetof(struct panic_header, panic);
+	} else {
+		file_length = ctx->curr.log_length[log];
+		file_offset = ctx->curr.log_offset[log];
+	}
+
+	if (*ppos >= file_length) {
+		mutex_unlock(&drv_mutex);
+		return 0;
+	}
+
+	if ((*ppos + count) > file_length)
+		count = file_length - *ppos;
+
+	rc = emmc_read(ctx->emmc, emmc_ipanic_proc_read_by_log,
+		       buffer, file_offset + *ppos, count, true);
+	if (rc <= 0) {
+		mutex_unlock(&drv_mutex);
+		pr_err
+		    ("%s: emmc_read: invalid args: offset:0x%08llx, count:%zd",
+		     __func__, (u64) (file_offset + *ppos), count);
+		return rc;
+	}
+
+	*ppos += rc;
+
+	mutex_unlock(&drv_mutex);
+
+	return rc;
+}
+
+static ssize_t emmc_ipanic_proc_read_hdr(struct file *file,
+					 char __user * buffer, size_t count,
+					 loff_t * ppos)
+{
+	return emmc_ipanic_proc_read_by_log(file, buffer, count, ppos,
+					    IPANIC_LOG_HEADER);
+}
+
+static ssize_t emmc_ipanic_proc_read0(struct file *file, char __user * buffer,
+				      size_t count, loff_t * ppos)
+{
+	return emmc_ipanic_proc_read_by_log(file, buffer, count, ppos,
+					    IPANIC_LOG_CONSOLE);
+}
+
+static ssize_t emmc_ipanic_proc_read1(struct file *file, char __user * buffer,
+				      size_t count, loff_t * ppos)
+{
+	return emmc_ipanic_proc_read_by_log(file, buffer, count, ppos,
+					    IPANIC_LOG_THREADS);
+}
+
+static void emmc_ipanic_remove_proc_work(struct work_struct *work)
+{
+	struct emmc_ipanic_data *ctx = &drv_ctx;
+	int log;
+
+	mutex_lock(&drv_mutex);
+	emmc_panic_erase(NULL, NULL);
+
+	for (log = 0; log < PROC_MAX_ENTRIES; log++) {
+		if (ctx->ipanic_proc_entry[log]) {
+			remove_proc_entry(ctx->ipanic_proc_entry_name
+					  [log], NULL);
+			ctx->ipanic_proc_entry[log] = NULL;
+		}
+	}
+	mutex_unlock(&drv_mutex);
+}
+
+static ssize_t emmc_ipanic_proc_write(struct file *file,
+				      const char __user * buffer,
+				      size_t count, loff_t * ppos)
+{
+	schedule_work(&proc_removal_work);
+	return count;
+}
+
+/* In section order inside panic partition : */
+static const struct file_operations ipanic_emmc_read_header_fops = {
+	.read = emmc_ipanic_proc_read_hdr,
+	.write = emmc_ipanic_proc_write,
+};
+
+static const struct file_operations ipanic_emmc0_fops = {
+	.read = emmc_ipanic_proc_read0,
+	.write = emmc_ipanic_proc_write,
+};
+
+static const struct file_operations ipanic_emmc1_fops = {
+	.read = emmc_ipanic_proc_read1,
+	.write = emmc_ipanic_proc_write,
+};
+
+static const struct file_operations ipanic_emmc_gbuffer_fops = {
+	.read = emmc_ipanic_gbuffer_proc_read,
+	.write = emmc_ipanic_proc_write
+};
+
+static void emmc_panic_notify_add(void)
+{
+	struct emmc_ipanic_data *ctx = &drv_ctx;
+	struct mmc_emergency_info *emmc;
+	unsigned char *read_buf_ptr;
+	Sector sect;
+	int rc, idx_log, idx_proc;
+	int proc_entry_created = 0;
+
+	if (!ctx) {
+		pr_err("%s:invalid panic handler\n", __func__);
+		return;
+	}
+
+	emmc = ctx->emmc;
+	if (!emmc) {
+		pr_err("%s:invalid emmc infomation\n", __func__);
+		goto out_err;
+	}
+
+	if (!emmc->bdev) {
+		pr_err("%s:invalid emmc block device\n", __func__);
+		goto out_err;
+	}
+
+	/* make sure the block device is open rw */
+	rc = blkdev_get(emmc->bdev, FMODE_READ | FMODE_WRITE,
+			emmc_panic_notify_add);
+	if (rc < 0) {
+		pr_err("%s: blk_dev_get failed!\n", __func__);
+		goto out_err;
+	}
+
+	/* read panic header */
+	read_buf_ptr = read_dev_sector(emmc->bdev, emmc->start_block, &sect);
+	if (!read_buf_ptr) {
+		pr_err("%s: read sector error(%llu)!\n", __func__,
+		       (u64) emmc->start_block);
+		return;
+	}
+
+	memcpy(&ctx->hdr, read_buf_ptr, sizeof(struct panic_header));
+
+	if (ctx->hdr.magic != PANIC_MAGIC) {
+		pr_info("%s: bad magic %x, no data available\n",
+			__func__, ctx->hdr.magic);
+		emmc_panic_erase(read_buf_ptr, &sect);
+		goto put_sector;
+	}
+
+	pr_info("%s: Data available in panic partition\n", __func__);
+
+	if (ctx->hdr.version != PHDR_VERSION) {
+		pr_err("%s: Version mismatch (%d != %d)\n",
+		       __func__, ctx->hdr.version, PHDR_VERSION);
+		emmc_panic_erase(read_buf_ptr, &sect);
+		goto put_sector;
+	}
+
+	/* Create proc entry for the panic header */
+	ctx->ipanic_proc_entry[PROC_HEADER_INDEX] =
+	    proc_create(ctx->ipanic_proc_entry_name
+			[PROC_HEADER_INDEX], S_IFREG | S_IRUGO, NULL,
+			&ipanic_emmc_read_header_fops);
+
+	if (!ctx->ipanic_proc_entry[PROC_HEADER_INDEX])
+		pr_err("%s: failed creating proc file\n", __func__);
+	else {
+		proc_entry_created = 1;
+		pr_info("%s: proc entry created: %s\n", __func__,
+			ctx->ipanic_proc_entry_name[PROC_HEADER_INDEX]);
+	}
+
+	/* read log_info to retrieve block numbers and offsets */
+	read_buf_ptr =
+	    read_dev_sector(emmc->bdev, emmc->start_block + 1, &sect);
+	if (!read_buf_ptr) {
+		pr_err("%s: read sector error(%llu)!\n", __func__,
+		       (u64) emmc->start_block + 1);
+		return;
+	}
+
+	memcpy(&ctx->curr, read_buf_ptr, sizeof(struct log_info));
+
+	/* Log files other than header */
+	for (idx_log = 0; idx_log < IPANIC_LOG_MAX; idx_log++) {
+
+		pr_info("%s: log file %u(%u, %u)\n", __func__, idx_log,
+			ctx->curr.log_offset[idx_log],
+			ctx->curr.log_length[idx_log]);
+
+		/* Skip empty file. */
+		if (ctx->curr.log_length[idx_log] == 0) {
+			pr_info("%s: empty log file %u\n", __func__, idx_log);
+			continue;
+		}
+
+		/* Create proc entry for console, threads and gbuffer log. */
+		if (idx_log == IPANIC_LOG_CONSOLE) {
+			idx_proc = PROC_CONSOLE_INDEX;
+			ctx->ipanic_proc_entry[PROC_CONSOLE_INDEX] =
+			    proc_create(ctx->ipanic_proc_entry_name
+					[PROC_CONSOLE_INDEX], S_IFREG | S_IRUGO,
+					NULL, &ipanic_emmc0_fops);
+		} else if (idx_log == IPANIC_LOG_THREADS) {
+			idx_proc = PROC_THREADS_INDEX;
+			ctx->ipanic_proc_entry[PROC_THREADS_INDEX] =
+			    proc_create(ctx->ipanic_proc_entry_name
+					[PROC_THREADS_INDEX], S_IFREG | S_IRUGO,
+					NULL, &ipanic_emmc1_fops);
+		} else if (idx_log == IPANIC_LOG_GBUFFER) {
+			idx_proc = PROC_GBUFFER_INDEX;
+			ctx->ipanic_proc_entry[PROC_GBUFFER_INDEX] =
+			    proc_create(ctx->ipanic_proc_entry_name
+					[PROC_GBUFFER_INDEX], S_IFREG | S_IRUGO,
+					NULL, &ipanic_emmc_gbuffer_fops);
+		} else {
+			/* No proc entry for this index */
+			idx_proc = 0;
+			continue;
+		}
+		if (!ctx->ipanic_proc_entry[idx_proc])
+			pr_err("%s: failed creating proc file\n", __func__);
+		else {
+			proc_entry_created = 1;
+			pr_info("%s: proc entry created: %s\n",
+				__func__,
+				ctx->ipanic_proc_entry_name[idx_proc]);
+		}
+	}
+
+	if (!proc_entry_created)
+		emmc_panic_erase(read_buf_ptr, &sect);
+
+put_sector:
+	put_dev_sector(sect);
+	return;
+out_err:
+	ctx->emmc = NULL;
+}
+
+static void emmc_panic_notify_remove(void)
+{
+	struct emmc_ipanic_data *ctx = &drv_ctx;
+
+	if (ctx->emmc && ctx->emmc->part_dev) {
+		put_device(ctx->emmc->part_dev);
+		ctx->emmc->bdev = NULL;
+	}
+
+	ctx->emmc = NULL;
+}
+
+static int emmc_ipanic_writeflashpage(struct mmc_emergency_info *emmc,
+				      loff_t to, const u_char * buf)
+{
+	int rc;
+	size_t wlen = SECTOR_SIZE;
+
+	if (to >= emmc->start_block + emmc->block_count) {
+		pr_emerg("%s: panic partition is full.\n", __func__);
+		return 0;
+	}
+
+	rc = emmc->write((char *)buf, (unsigned int)to);
+	if (rc) {
+		pr_emerg("%s: Error writing data to flash (%d)\n",
+			 __func__, rc);
+		return rc;
+	}
+
+	return wlen;
+}
+
+/*
+ * Writes the contents of the console to the specified offset in flash.
+ * Returns number of bytes written
+ */
+static int emmc_ipanic_write_console(struct mmc_emergency_info *emmc,
+				     unsigned int off, int *actual_size)
+{
+	struct emmc_ipanic_data *ctx = &drv_ctx;
+	int saved_oip, rc, block_shift = 0, bounce_idx = 0;
+	size_t line_len = 0;
+	bool ret;
+
+	static unsigned char line[SECTOR_SIZE];
+
+	*actual_size = 0;
+	while (1) {
+		saved_oip = oops_in_progress;
+		oops_in_progress = 1;
+		bounce_idx = 0;
+
+		if (last_chunk_buf_len) {
+			memcpy(ctx->bounce, last_chunk_buf, last_chunk_buf_len);
+			bounce_idx += last_chunk_buf_len;
+			last_chunk_buf_len = 0;
+		}
+
+		do {
+			ret = kmsg_dump_get_line(&ipanic_dumper, false,
+						 line, SECTOR_SIZE, &line_len);
+
+			if (ret) {
+				if (bounce_idx + line_len < SECTOR_SIZE) {
+					memcpy(ctx->bounce + bounce_idx,
+					       line, line_len);
+					bounce_idx += line_len;
+				} else {
+					int len = SECTOR_SIZE - bounce_idx;
+					memcpy(ctx->bounce + bounce_idx,
+					       line, len);
+					bounce_idx = SECTOR_SIZE;
+					memcpy(last_chunk_buf,
+					       line + len, line_len - len);
+					last_chunk_buf_len = line_len - len;
+				}
+			}
+		} while (ret && (bounce_idx != SECTOR_SIZE));
+
+		oops_in_progress = saved_oip;
+
+		/* If it is the last chunk, just copy it to last chunk
+		 * buffer and exit loop.
+		 */
+		if (!ret) {
+			/* Leave the last chunk for next writing */
+			memcpy(last_chunk_buf, ctx->bounce, bounce_idx);
+			last_chunk_buf_len = bounce_idx;
+			break;
+		}
+
+		rc = emmc_ipanic_writeflashpage(emmc, off + block_shift,
+						ctx->bounce);
+		if (rc <= 0) {
+			pr_emerg("%s: Flash write failed (%d)\n", __func__, rc);
+			return block_shift;
+		}
+
+		block_shift++;
+		*actual_size += SECTOR_SIZE;
+	}
+
+	return block_shift;
+}
+
+static void emmc_ipanic_flush_lastchunk_emmc(loff_t to,
+					     int *size_written,
+					     int *sector_written)
+{
+	struct emmc_ipanic_data *ctx = &drv_ctx;
+	struct mmc_emergency_info *emmc = ctx->emmc;
+	int rc = 0;
+
+	if (last_chunk_buf_len) {
+		memset(last_chunk_buf + last_chunk_buf_len, 0,
+		       SECTOR_SIZE - last_chunk_buf_len);
+
+		rc = emmc_ipanic_writeflashpage(emmc, to, last_chunk_buf);
+		if (rc <= 0) {
+			pr_emerg("emmc_ipanic: write last chunk failed (%d)\n",
+				 rc);
+			return;
+		}
+
+		*size_written += last_chunk_buf_len;
+		(*sector_written)++;
+		last_chunk_buf_len = 0;
+	}
+	return;
+}
+
+static void emmc_ipanic_write_thread_func(void)
+{
+	struct emmc_ipanic_data *ctx = &drv_ctx;
+	struct mmc_emergency_info *emmc = ctx->emmc;
+	int size_written;
+	int thread_sector_count;
+
+	thread_sector_count =
+	    emmc_ipanic_write_console(emmc,
+				      log_offset[IPANIC_LOG_THREADS] +
+				      log_len[IPANIC_LOG_THREADS],
+				      &size_written);
+	if (thread_sector_count < 0) {
+		pr_emerg("Error writing threads to panic log! (%d)\n",
+			 log_len[IPANIC_LOG_THREADS]);
+		return;
+	}
+	log_size[IPANIC_LOG_THREADS] += size_written;
+	log_len[IPANIC_LOG_THREADS] += thread_sector_count;
+
+	/*reset the log buffer */
+	log_buf_clear();
+	kmsg_dump_rewind(&ipanic_dumper);
+}
+
+static void emmc_ipanic_write_logbuf(struct mmc_emergency_info *emmc, int log)
+{
+	/*
+	 * Write the log data from the third block :
+	 * - the first block is reserved for panic header
+	 * - the second one is reserved for offset information
+	 */
+	log_offset[log] = emmc->start_block + 2;
+	log_len[log] = emmc_ipanic_write_console(emmc, log_offset[log],
+						 &log_size[log]);
+	if (log_size[log] < 0) {
+		pr_emerg("Error writing console to panic log! (%d)\n",
+			 log_len[log]);
+		log_size[log] = 0;
+		log_len[log] = 0;
+	}
+	/* flush last chunk buffer for console */
+	emmc_ipanic_flush_lastchunk_emmc(log_offset[log] +
+					 log_len[log],
+					 &log_size[log], &log_len[log]);
+}
+
+static void emmc_ipanic_write_calltrace(struct mmc_emergency_info *emmc,
+					int log)
+{
+	log_offset[log] = log_offset[log - 1] + log_len[log - 1];
+	/*
+	 * config func_stream_emmc to emmc_ipanic_write_thread_func to
+	 * stream thread call trace.
+	 */
+	log_buf_clear();
+	kmsg_dump_rewind(&ipanic_dumper);
+	func_stream_emmc = emmc_ipanic_write_thread_func;
+	show_state_filter(0);
+
+	/* flush last chunk buffer */
+	emmc_ipanic_flush_lastchunk_emmc(log_offset[log] +
+					 log_len[log],
+					 &log_size[log], &log_len[log]);
+}
+
+static int emmc_ipanic_write_gbuffer_data(struct mmc_emergency_info *emmc,
+					  struct g_buffer_header *gbuffer,
+					  unsigned int off, int *actual_size)
+{
+	int rc, block_shift = 0;
+	size_t log_off = 0;
+	size_t log_size;
+	unsigned char *buf = gbuffer->base;
+
+	if (gbuffer->head)
+		/* has overflow */
+		log_size = gbuffer->size;
+	else
+		/* no overflow */
+		log_size = gbuffer->woff;
+
+	while (log_off < log_size) {
+		size_t size_copy = log_size - log_off;
+		if (size_copy < SECTOR_SIZE) {
+			/*
+			 * flash page not complete, flushed with
+			 * emmc_ipanic_flush_lastchunk_emmc
+			 */
+			memcpy(last_chunk_buf, buf + log_off, size_copy);
+			last_chunk_buf_len = size_copy;
+			break;
+		}
+		rc = emmc_ipanic_writeflashpage(emmc, off + block_shift,
+						buf + log_off);
+		if (rc <= 0) {
+			pr_emerg("%s: Flash write failed (%d)\n", __func__, rc);
+			return 0;
+		}
+		log_off += rc;
+		block_shift++;
+	}
+	*actual_size = log_off;
+
+	return block_shift;
+}
+
+static struct g_buffer_header gbuffer = {
+	.base = NULL,
+};
+
+static void emmc_ipanic_write_gbuffer(struct mmc_emergency_info *emmc, int log)
+{
+	struct g_buffer_header *m_gbuffer = &gbuffer;
+
+	log_offset[log] = log_offset[log - 1] + log_len[log - 1];
+
+	pr_info("write gbuffer data\n");
+	if (!m_gbuffer->base) {
+		pr_err("Ipanic error, no gbuffer data\n");
+		return;
+	}
+
+	log_len[log] = emmc_ipanic_write_gbuffer_data(emmc, m_gbuffer,
+						      log_offset[log],
+						      &log_size[log]);
+	if (log_len[log] < 0) {
+		pr_emerg("Error writing gbuffer to panic log! (%d)\n",
+			 log_len[log]);
+		log_size[log] = 0;
+		log_len[log] = 0;
+	}
+	/* flush last chunk buffer */
+	emmc_ipanic_flush_lastchunk_emmc(log_offset[log] + log_len[log],
+					 &log_size[log], &log_len[log]);
+	log_head[log] = m_gbuffer->head;
+	log_woff[log] = m_gbuffer->woff;
+	pr_info("write gbuffer data END\n");
+}
+
+/*
+ * Exported in <linux/panic_gbuffer.h>
+ */
+void panic_set_gbuffer(struct g_buffer_header *buf)
+{
+	if (gbuffer.base) {
+		pr_err("%s: gbuffer already set to 0x%p, can not set again",
+		       __func__, gbuffer.base);
+		return;
+	}
+
+	gbuffer.base = buf->base;
+	gbuffer.size = buf->size;
+	gbuffer.woff = buf->woff;
+	gbuffer.head = buf->head;
+}
+
+EXPORT_SYMBOL(panic_set_gbuffer);
+
+static void emmc_ipanic_write_pageheader(struct mmc_emergency_info *emmc)
+{
+	struct emmc_ipanic_data *ctx = &drv_ctx;
+	struct panic_header *hdr = (struct panic_header *)ctx->bounce;
+	int wc;
+	size_t len, total, max;
+
+	memset(ctx->bounce, 0, SECTOR_SIZE);
+	hdr->magic = PANIC_MAGIC;
+	hdr->version = PHDR_VERSION;
+
+	total = snprintf(hdr->panic, SECTOR_SIZE, "###Kernel panic###\n");
+
+	max = SECTOR_SIZE - offsetof(struct panic_header, panic) - total;
+	kmsg_dump_get_buffer(&ipanic_dumper, false, last_chunk_buf, max, &len);
+	kmsg_dump_rewind(&ipanic_dumper);
+
+	memcpy(hdr->panic + total, last_chunk_buf, len);
+	hdr->log_size = len + total;
+
+	/* Write header block */
+	wc = emmc_ipanic_writeflashpage(emmc, emmc->start_block, ctx->bounce);
+	if (wc <= 0) {
+		pr_emerg("emmc_ipanic: Info write failed (%d)\n", wc);
+		return;
+	}
+}
+
+static void emmc_ipanic_clean_loginfo(struct mmc_emergency_info *emmc)
+{
+	struct emmc_ipanic_data *ctx = &drv_ctx;
+	int rc;
+
+	memset(log_offset, 0, IPANIC_LOG_MAX * sizeof(int));
+	memset(log_len, 0, IPANIC_LOG_MAX * sizeof(int));
+	memset(log_size, 0, IPANIC_LOG_MAX * sizeof(int));
+
+	memset(ctx->bounce, 0, SECTOR_SIZE);
+
+	rc = emmc_ipanic_writeflashpage(emmc, emmc->start_block + 1,
+					ctx->bounce);
+	if (rc <= 0) {
+		pr_emerg("emmc_ipanic: Header write failed (%d)\n", rc);
+		return;
+	}
+}
+
+static void emmc_ipanic_write_loginfo(struct mmc_emergency_info *emmc,
+				      int newlog)
+{
+	struct emmc_ipanic_data *ctx = &drv_ctx;
+	struct log_info *info = (struct log_info *)ctx->bounce;
+	int log = IPANIC_LOG_CONSOLE;
+	int rc;
+
+	if ((newlog < 0) || (newlog >= IPANIC_LOG_MAX))
+		return;
+
+	if (log_size[newlog] == 0)
+		return;
+
+	memset(ctx->bounce, 0, SECTOR_SIZE);
+	/*Fill up log offset and size */
+	while (log < IPANIC_LOG_MAX) {
+		/*Configurate log offset and log size */
+		info->log_offset[log] = (log_offset[log] - emmc->start_block)
+		    << SECTOR_SIZE_SHIFT;
+		info->log_length[log] = log_size[log];
+		info->log_head[log] = log_head[log];
+		info->log_woff[log] = log_woff[log];
+		log++;
+	}
+	rc = emmc_ipanic_writeflashpage(emmc, emmc->start_block + 1,
+					ctx->bounce);
+	if (rc <= 0) {
+		pr_emerg("emmc_ipanic: Header write failed (%d)\n", rc);
+		return;
+	}
+}
+
+static int emmc_ipanic(struct notifier_block *this, unsigned long event,
+		       void *ptr)
+{
+	struct emmc_ipanic_data *ctx = &drv_ctx;
+	struct mmc_emergency_info *emmc;
+	int rc, log;
+
+	pr_emerg("panic notified\n");
+
+	if (in_panic || disable_emmc_ipanic)
+		return NOTIFY_DONE;
+
+	in_panic = 1;
+
+#ifdef CONFIG_PREEMPT
+	/* Ensure that cond_resched() won't try to preempt anybody */
+	preempt_count_add(PREEMPT_ACTIVE);
+#endif
+	touch_nmi_watchdog();
+
+	if (!ctx)
+		goto out;
+	emmc = ctx->emmc;
+	if (!emmc)
+		goto out;
+	if (ctx->hdr.magic) {
+		pr_emerg("Crash partition in use!\n");
+		goto out;
+	}
+
+	rc = emmc->init();
+	if (rc) {
+		/* String too long to fit on 1 80-char line */
+		pr_emerg("%s %s, rc=%d\n",
+			 "Emmc emergency driver is",
+			 "not initialized successfully!", rc);
+		goto out;
+	}
+
+	/* Prepare kmsg dumper */
+	ipanic_dumper.active = 1;
+	/* Rewind kmsg dumper */
+	kmsg_dump_rewind(&ipanic_dumper);
+
+	/* Write emmc ipanic partition header */
+	emmc_ipanic_write_pageheader(emmc);
+	/* Clean emmc ipanic sections offsets */
+	emmc_ipanic_clean_loginfo(emmc);
+
+	/*Write all buffer into emmc */
+	log = IPANIC_LOG_CONSOLE;
+	while (log < IPANIC_LOG_MAX) {
+		/* Clear temporary buffer */
+		memset(ctx->bounce, 0, SECTOR_SIZE);
+		/* Log every buffer into emmc */
+		switch (log) {
+		case IPANIC_LOG_CONSOLE:
+			emmc_ipanic_write_logbuf(emmc, log);
+			break;
+		case IPANIC_LOG_THREADS:
+			emmc_ipanic_write_calltrace(emmc, log);
+			break;
+		case IPANIC_LOG_GBUFFER:
+			emmc_ipanic_write_gbuffer(emmc, log);
+			break;
+		default:
+			break;
+		}
+		/* Update emmc ipanic sections offsets */
+		emmc_ipanic_write_loginfo(emmc, log);
+		log++;
+	}
+	pr_info("Panic log data written done!\n");
+
+	ipanic_dumper.active = 0;
+
+out:
+#ifdef CONFIG_PREEMPT
+	preempt_count_sub(PREEMPT_ACTIVE);
+#endif
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block panic_blk = {
+	.notifier_call = emmc_ipanic,
+	.priority = 100,
+};
+
+static int panic_dbg_get(void *data, u64 * val)
+{
+	emmc_ipanic(NULL, 0, NULL);
+	return 0;
+}
+
+static int panic_dbg_set(void *data, u64 val)
+{
+	BUG();
+	return -1;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(panic_dbg_fops, panic_dbg_get, panic_dbg_set, "%llu\n");
+
+static int match_dev_panic_part(struct device *dev, const void *data)
+{
+	struct hd_struct *part = dev_to_part(dev);
+	const char *name = (char *)data;
+
+	return part->info && !strcmp(name, part->info->volname);
+}
+
+static int emmc_panic_partition_notify(struct notifier_block *nb,
+				       unsigned long action, void *data)
+{
+	struct device *dev = data;
+	struct emmc_ipanic_data *ctx = &drv_ctx;
+	struct mmc_emergency_info *emmc;
+	struct gendisk *disk;
+
+	if (!ctx) {
+		pr_err("%s:invalid panic handler\n", __func__);
+		return 0;
+	}
+
+	emmc = ctx->emmc;
+	if (!emmc) {
+		pr_err("%s:invalid emmc information\n", __func__);
+		return 0;
+	}
+
+	switch (action) {
+	case BUS_NOTIFY_ADD_DEVICE:
+	case BUS_NOTIFY_BOUND_DRIVER:
+		/* if emmc already found, exit the function */
+		if (emmc->bdev)
+			return 0;
+
+		emmc->part_dev = class_find_device(&block_class, NULL,
+						   emmc->part_label,
+						   &match_dev_panic_part);
+		if (emmc->part_dev) {
+			emmc->part = dev_to_part(emmc->part_dev);
+			if (!emmc->part) {
+				pr_err("unable to get partition\n");
+				goto put_dev;
+			}
+
+			disk = part_to_disk(emmc->part);
+			if (!disk) {
+				pr_err("unable to get disk\n");
+				goto put_dev;
+			}
+
+			/* get whole disk */
+			emmc->bdev = bdget_disk(disk, 0);
+			if (!emmc->bdev) {
+				pr_err("unable to get emmc block device\n");
+				goto put_dev;
+			}
+
+			emmc->start_block = emmc->part->start_sect;
+			emmc->block_count = emmc->part->nr_sects;
+
+			pr_info("panic partition found, label:%s, device:%s\n",
+				emmc->part_label, dev_name(emmc->part_dev));
+
+			/* notify to add the panic device */
+			emmc_panic_notify_add();
+
+			atomic_notifier_chain_register(&panic_notifier_list,
+						       &panic_blk);
+
+			INIT_WORK(&proc_removal_work,
+				  emmc_ipanic_remove_proc_work);
+		}
+		break;
+	case BUS_NOTIFY_DEL_DEVICE:
+	case BUS_NOTIFY_UNBIND_DRIVER:
+		if (match_dev_panic_part(dev, emmc->part_label)) {
+			pr_info("bus notify removed device '%s', cleaning.\n",
+				dev_name(dev));
+			flush_scheduled_work();
+			atomic_notifier_chain_unregister(&panic_notifier_list,
+							 &panic_blk);
+			emmc_panic_notify_remove();
+		}
+		break;
+	case BUS_NOTIFY_BIND_DRIVER:
+	case BUS_NOTIFY_UNBOUND_DRIVER:
+		/* Nothing to do here, but we don't want
+		 * these actions to generate error messages,
+		 * so we need to catch them
+		 */
+		break;
+	default:
+		pr_err("Unknown action (%lu) on %s\n", action, dev_name(dev));
+		return 0;
+	}
+	return 1;
+
+put_dev:
+	put_device(emmc->part_dev);
+	return 0;
+}
+
+static struct notifier_block panic_partition_notifier = {
+	.notifier_call = emmc_panic_partition_notify,
+};
+
+void emmc_ipanic_stream_emmc(void)
+{
+	if (func_stream_emmc)
+		(*func_stream_emmc) ();
+}
+
+EXPORT_SYMBOL(emmc_ipanic_stream_emmc);
+
+static struct dentry *emmc_ipanic_d;
+static struct dentry *emmc_ipanic_disable_d;
+
+static int __init emmc_ipanic_init(void)
+{
+	/* initialization of drv_ctx */
+	memset(&drv_ctx, 0, sizeof(drv_ctx));
+	drv_ctx.emmc = &emmc_info;
+
+	if (*part_label)
+		strcpy(emmc_info.part_label, part_label);
+
+	drv_ctx.ipanic_proc_entry_name = ipanic_proc_entry_name;
+	drv_ctx.bounce = (void *)__get_free_page(GFP_KERNEL);
+
+	bus_register_notifier(&pci_bus_type, &panic_partition_notifier);
+
+	emmc_ipanic_d = debugfs_create_file("emmc_ipanic", 0644, NULL, NULL,
+					    &panic_dbg_fops);
+	emmc_ipanic_disable_d = debugfs_create_u32("disable_emmc_ipanic", 0644,
+						   NULL, &disable_emmc_ipanic);
+
+	pr_info("init success\n");
+
+	return 0;
+}
+
+static void __exit emmc_ipanic_exit(void)
+{
+	debugfs_remove(emmc_ipanic_d);
+	debugfs_remove(emmc_ipanic_disable_d);
+	bus_unregister_notifier(&pci_bus_type, &panic_partition_notifier);
+	flush_scheduled_work();
+	atomic_notifier_chain_unregister(&panic_notifier_list, &panic_blk);
+	emmc_panic_notify_remove();
+}
+
+module_init(emmc_ipanic_init);
+module_exit(emmc_ipanic_exit);
diff --git a/drivers/misc/emmc_ipanic.h b/drivers/misc/emmc_ipanic.h
new file mode 100644
index 0000000..541f613
--- /dev/null
+++ b/drivers/misc/emmc_ipanic.h
@@ -0,0 +1,96 @@
+/*
+ * drivers/misc/emmc_ipanic.h
+ *
+ * Copyright (C) 2011 Intel Corp
+ * Author: dongxing.zhang@intel.com
+ * Author: jun.zhang@intel.com
+ * Author: chuansheng.liu@intel.com
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ */
+
+#ifndef _LINUX_EMMC_IPANIC_H
+#define _LINUX_EMMC_IPANIC_H
+
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/blkdev.h>
+#include <linux/genhd.h>
+#include <linux/version.h>
+
+extern void log_buf_clear(void);
+
+#define SECTOR_SIZE_SHIFT (9)
+
+#define PROC_HEADER_INDEX        0
+#define PROC_CONSOLE_INDEX       1
+#define PROC_THREADS_INDEX       2
+#define PROC_GBUFFER_INDEX       3
+#define PROC_MAX_ENTRIES         4
+
+#define IPANIC_LOG_CONSOLE       0
+#define IPANIC_LOG_THREADS       1
+#define IPANIC_LOG_GBUFFER       2
+#define IPANIC_LOG_MAX           3
+#define IPANIC_LOG_HEADER        IPANIC_LOG_MAX
+
+
+struct mmc_emergency_info {
+#define DISK_NAME_LENGTH 20
+	/* emmc panic partition label */
+	char part_label[PARTITION_META_INFO_VOLNAMELTH];
+
+	struct block_device *bdev;
+	struct device *part_dev;
+	struct hd_struct *part;
+
+	/*panic partition start block */
+	sector_t start_block;
+	/*panic partition block count */
+	sector_t block_count;
+
+	int (*init) (void);
+	int (*write) (char *, unsigned int);
+	int (*read) (char *, unsigned int);
+};
+
+struct panic_header {
+	u32 magic;
+#define PANIC_MAGIC 0xdeadf00d
+
+	u32 version;
+#define PHDR_VERSION   0x01
+	u32 log_size;
+
+	char panic[SECTOR_SIZE];
+};
+
+struct log_info {
+	u32 log_offset[IPANIC_LOG_MAX];
+	u32 log_length[IPANIC_LOG_MAX];
+
+	/* For logcat and generic buffer log status */
+	size_t log_head[IPANIC_LOG_MAX];
+	size_t log_woff[IPANIC_LOG_MAX];
+};
+
+struct emmc_ipanic_data {
+	struct mmc_emergency_info *emmc;
+	struct panic_header hdr;
+	struct log_info curr;
+	void *bounce;
+	struct proc_dir_entry *ipanic_proc_entry[PROC_MAX_ENTRIES];
+	unsigned char **ipanic_proc_entry_name;
+};
+
+#endif /* _LINUX_EMMC_IPANIC_H */
diff --git a/drivers/mmc/core/Makefile b/drivers/mmc/core/Makefile
index 38ed210..d55cc5d 100644
--- a/drivers/mmc/core/Makefile
+++ b/drivers/mmc/core/Makefile
@@ -7,6 +7,6 @@ mmc_core-y			:= core.o bus.o host.o \
 				   mmc.o mmc_ops.o sd.o sd_ops.o \
 				   sdio.o sdio_ops.o sdio_bus.o \
 				   sdio_cis.o sdio_io.o sdio_irq.o \
-				   quirks.o slot-gpio.o
+				   quirks.o slot-gpio.o mmc_panic_ops.o
 
 mmc_core-$(CONFIG_DEBUG_FS)	+= debugfs.o
diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 01488b6..0b0778e 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -2489,6 +2489,7 @@ void mmc_rescan(struct work_struct *work)
 	mmc_release_host(host);
 
  out:
+	mmc_emergency_setup(host);
 	if (host->caps & MMC_CAP_NEEDS_POLL) 
 		mmc_schedule_delayed_work(&host->detect, HZ);
 }
diff --git a/drivers/mmc/core/mmc_panic_ops.c b/drivers/mmc/core/mmc_panic_ops.c
new file mode 100644
index 0000000..bc1e09b
--- /dev/null
+++ b/drivers/mmc/core/mmc_panic_ops.c
@@ -0,0 +1,837 @@
+/*
+ * linux/drivers/mmc/core/mmc_panic_ops.c
+ *
+ * Copyright (C) 2011 Intel Corp
+ * Author: dongxing.zhang@intel.com
+ * Author: jun.zhang@intel.com
+ * Author: chuansheng.liu@intel.com
+ * Author: chuanxiao.dong@intel.com
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ */
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+
+#include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/sd.h>
+
+#include "core.h"
+#include "bus.h"
+#include "host.h"
+
+#include "mmc_ops.h"
+
+
+static struct mmc_panic_host *panic_host;
+
+static int mmc_emergency_prepare(void)
+{
+	struct mmc_host *mmc = panic_host->mmc;
+
+	if (mmc == NULL) {
+		pr_err("%s: panic host was not setup\n", __func__);
+		return -ENODEV;
+	}
+
+	/*
+	 * once panic happened, we monopolize the host controller.
+	 * so claim host without relase any more.
+	 */
+	mmc->claimed = 1;
+	mmc->claimer = current;
+	mmc->claim_cnt += 1;
+#ifdef CONFIG_MMC_CLKGATE
+	/*
+	 * disable the clock gating
+	 */
+	mmc->clk_gated = false;
+	mmc->clk_requests++;
+	mmc->ios.clock = mmc->clk_old;
+#endif
+	return 0;
+}
+
+static void mmc_emergency_ready(void)
+{
+	panic_host->panic_ready = 1;
+}
+
+/*
+ * Return the card size in sectors.
+ *
+ * return value:
+ * the sector number
+ */
+static unsigned int mmc_get_capacity(struct mmc_card *card)
+{
+	if (!mmc_card_sd(card) && mmc_card_blockaddr(card))
+		return card->ext_csd.sectors;
+	else
+		return card->csd.capacity << (card->csd.read_blkbits - 9);
+}
+
+static void mmc_emergency_send_req(struct mmc_request *mrq)
+{
+	struct mmc_panic_host *host = panic_host;
+
+	mrq->cmd->error = 0;
+	mrq->cmd->mrq = mrq;
+
+	if (mrq->data) {
+		BUG_ON(mrq->data->blksz > host->max_blk_size);
+		BUG_ON(mrq->data->blocks > host->max_blk_count);
+		BUG_ON(mrq->data->blocks * mrq->data->blksz >
+				host->max_req_size);
+
+		mrq->cmd->data = mrq->data;
+		mrq->data->error = 0;
+		mrq->data->mrq = mrq;
+		if (mrq->stop) {
+			mrq->data->stop = mrq->stop;
+			mrq->stop->error = 0;
+			mrq->stop->mrq = mrq;
+		}
+	}
+
+	/*
+	 * Send the request to host
+	 *
+	 * if request handling is successful, return.
+	 * If request handling is failed and has rety, resend request.
+	 * During retry, if request handling is still failed, core layer
+	 * will keep on retry untill cmd->retries is 0.
+	 *
+	 * So in this way, makes retry blind to host driver. Totally
+	 * controlled by core driver
+	 */
+	host->panic_ops->request(host, mrq);
+
+	while ((mrq->cmd->error || (mrq->data && (mrq->data->error ||
+			(mrq->data->stop && mrq->data->stop->error)))) &&
+			mrq->cmd->retries > 0) {
+		/* clear errors */
+		mrq->cmd->error = 0;
+		if (mrq->data) {
+			mrq->data->error = 0;
+			if (mrq->stop)
+				mrq->stop->error = 0;
+		}
+		host->panic_ops->request(host, mrq);
+		mrq->cmd->retries--;
+	}
+}
+
+static int mmc_emergency_send_cmd(struct mmc_command *cmd, int retries)
+{
+	struct mmc_request mrq;
+
+	memset(&mrq, 0, sizeof(struct mmc_request));
+
+	memset(cmd->resp, 0, sizeof(cmd->resp));
+	cmd->retries = retries;
+
+	mrq.cmd = cmd;
+	cmd->data = NULL;
+
+	mmc_emergency_send_req(&mrq);
+
+	return cmd->error;
+}
+
+static int __mmc_emergency_write(unsigned int blk_id)
+{
+	struct mmc_request mrq;
+	struct mmc_command cmd;
+	struct mmc_data data;
+
+	memset(&mrq, 0, sizeof(struct mmc_request));
+	memset(&cmd, 0, sizeof(struct mmc_command));
+	memset(&data, 0, sizeof(struct mmc_data));
+
+	mrq.cmd = &cmd;
+	mrq.data = &data;
+	cmd.opcode = MMC_WRITE_BLOCK;
+	cmd.arg = blk_id;
+	if (!panic_host->blkaddr)
+		cmd.arg <<= 9;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;
+	/*
+	 * Fix these values;
+	 */
+	data.blksz = 512;
+	data.blocks = 1;
+	data.dmabuf = panic_host->dmabuf;
+
+	mmc_emergency_send_req(&mrq);
+
+	return cmd.error;
+}
+
+
+static int mmc_emergency_go_idle(struct mmc_panic_host *host)
+{
+	int err;
+	struct mmc_command cmd;
+
+	/*
+	 * Non-SPI hosts need to prevent chipselect going active during
+	 * GO_IDLE; that would put chips into SPI mode.  Remind them of
+	 * that in case of hardware that won't pull up DAT3/nCS otherwise.
+	 *
+	 * SPI hosts ignore ios.chip_select; it's managed according to
+	 * rules that must accomodate non-MMC slaves which this layer
+	 * won't even know about.
+	 */
+	if (!mmc_host_is_spi(host)) {
+		host->ios.chip_select = MMC_CS_HIGH;
+		host->panic_ops->set_ios(host);
+		mdelay(1);
+	}
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+
+	cmd.opcode = MMC_GO_IDLE_STATE;
+	cmd.arg = 0;
+	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_NONE | MMC_CMD_BC;
+
+	err = mmc_emergency_send_cmd(&cmd, 0);
+
+	mdelay(1);
+
+	if (!mmc_host_is_spi(host)) {
+		host->ios.chip_select = MMC_CS_DONTCARE;
+		host->panic_ops->set_ios(host);
+		mdelay(1);
+	}
+
+	return err;
+}
+static int mmc_emergency_send_op_cond(struct mmc_panic_host *host,
+		u32 ocr, u32 *rocr)
+{
+	struct mmc_command cmd;
+	int i, err = 0;
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+
+	cmd.opcode = MMC_SEND_OP_COND;
+	cmd.arg = mmc_host_is_spi(host) ? 0 : ocr;
+	cmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R3 | MMC_CMD_BCR;
+
+	for (i = 100; i; i--) {
+		err = mmc_emergency_send_cmd(&cmd, 0);
+		if (err)
+			break;
+
+		/* if we're just probing, do a single pass */
+		if (ocr == 0)
+			break;
+
+		/* otherwise wait until reset completes */
+		if (mmc_host_is_spi(host)) {
+			if (!(cmd.resp[0] & R1_SPI_IDLE))
+				break;
+		} else {
+			if (cmd.resp[0] & MMC_CARD_BUSY)
+				break;
+		}
+
+		err = -ETIMEDOUT;
+
+		/*
+		 * If command 1 is failed, wait 10ms and then
+		 * have a retry. Card may need time to prepare
+		 * for the next command 1
+		 */
+		mdelay(10);
+	}
+
+	if (rocr && !mmc_host_is_spi(host))
+		*rocr = cmd.resp[0];
+
+	return err;
+}
+
+static int mmc_emergency_all_send_cid(u32 *cid)
+{
+	int err;
+	struct mmc_command cmd;
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+
+	cmd.opcode = MMC_ALL_SEND_CID;
+	cmd.arg = 0;
+	cmd.flags = MMC_RSP_R2 | MMC_CMD_BCR;
+
+	err = mmc_emergency_send_cmd(&cmd, MMC_CMD_RETRIES);
+	if (err)
+		return err;
+
+	memcpy(cid, cmd.resp, sizeof(u32) * 4);
+
+	return 0;
+}
+
+static int mmc_emergency_set_relative_addr(struct mmc_card *card)
+{
+	int err;
+	struct mmc_command cmd;
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+
+	cmd.opcode = MMC_SET_RELATIVE_ADDR;
+	cmd.arg = card->rca << 16;
+	cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+
+	err = mmc_emergency_send_cmd(&cmd, MMC_CMD_RETRIES);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int mmc_emergency_select_card(struct mmc_card *card)
+{
+	int err;
+	struct mmc_command cmd;
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+
+	cmd.opcode = MMC_SELECT_CARD;
+
+	if (card) {
+		cmd.arg = card->rca << 16;
+		cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
+	} else {
+		cmd.arg = 0;
+		cmd.flags = MMC_RSP_NONE | MMC_CMD_AC;
+	}
+
+	err = mmc_emergency_send_cmd(&cmd, MMC_CMD_RETRIES);
+	if (err)
+		return err;
+
+	return 0;
+}
+
+static int mmc_emergency_send_status(struct mmc_panic_host *host, u32 *status)
+{
+	struct mmc_card *card = host->card;
+	int err;
+	struct mmc_command cmd;
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+
+	cmd.opcode = MMC_SEND_STATUS;
+	if (!mmc_host_is_spi(host))
+		cmd.arg = card->rca << 16;
+	cmd.flags = MMC_RSP_SPI_R2 | MMC_RSP_R1 | MMC_CMD_AC;
+
+	err = mmc_emergency_send_cmd(&cmd, MMC_CMD_RETRIES);
+	if (err)
+		return err;
+
+	/* NOTE: callers are required to understand the difference
+	 * between "native" and SPI format status words!
+	 */
+	if (status)
+		*status = cmd.resp[0];
+
+	return 0;
+}
+static int mmc_emergency_switch(struct mmc_panic_host *host,
+		u8 set, u8 index, u8 value)
+{
+	struct mmc_card *card = host->card;
+	int err;
+	struct mmc_command cmd;
+	u32 status;
+
+	memset(&cmd, 0, sizeof(struct mmc_command));
+
+	cmd.opcode = MMC_SWITCH;
+	cmd.arg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
+		(index << 16) |
+		(value << 8) |
+		set;
+	cmd.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;
+
+	err = mmc_emergency_send_cmd(&cmd, MMC_CMD_RETRIES);
+	if (err)
+		return err;
+
+	/* Must check status to be sure of no errors */
+	do {
+		err = mmc_emergency_send_status(host, &status);
+		if (err)
+			return err;
+		if (host->caps & MMC_CAP_WAIT_WHILE_BUSY)
+			break;
+		if (mmc_host_is_spi(host))
+			break;
+	} while (R1_CURRENT_STATE(status) == 7);
+
+	if (mmc_host_is_spi(host)) {
+		if (status & R1_SPI_ILLEGAL_COMMAND)
+			return -EBADMSG;
+	} else {
+		if (status & 0xFDFFA000)
+			pr_warn("%s: unexpected status %#x after switch",
+				mmc_hostname(card->host), status);
+		if (status & R1_SWITCH_ERROR)
+			return -EBADMSG;
+	}
+
+	return 0;
+}
+
+static int mmc_emergency_spi_set_crc(struct mmc_panic_host *host, int use)
+{
+	return -1;
+}
+
+static int mmc_emergency_send_cid(struct mmc_panic_host *host, u32 *cid)
+{
+	return -1;
+}
+/*
+ * reinit card:
+ * should also consider about the SPI host
+ */
+static int mmc_emergency_reinit_card(void)
+{
+	struct mmc_panic_host *host = panic_host;
+	struct mmc_card *card = host->card;
+	u32 ocr = host->ocr;
+	int err, ddr = 0;
+	u32 cid[4];
+	unsigned int max_dtr;
+
+	/*
+	 * low the clock to be init clock
+	 */
+	if (mmc_host_is_spi(host)) {
+		host->ios.chip_select = MMC_CS_HIGH;
+		host->ios.bus_mode = MMC_BUSMODE_PUSHPULL;
+	} else {
+		host->ios.chip_select = MMC_CS_DONTCARE;
+		host->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;
+	}
+	host->ios.bus_width = MMC_BUS_WIDTH_1;
+	host->ios.timing = MMC_TIMING_LEGACY;
+	/*
+	 * AS eMMC spec said, card init frequency cannot higher
+	 * then 400Khz. But a good card should support for 400Khz
+	 * frequence in initialize process.
+	 */
+	host->ios.clock = 400000;
+	host->panic_ops->set_ios(host);
+
+	/*
+	 * Since we're changing the OCR value, we seem to
+	 * need to tell some cards to go back to the idle
+	 * state.  We wait 1ms to give cards time to
+	 * respond.
+	 */
+	mmc_emergency_go_idle(host);
+
+	/* The extra bit indicates that we support high capacity */
+	err = mmc_emergency_send_op_cond(host, ocr | (1 << 30), NULL);
+	if (err)
+		goto err;
+
+	/*
+	 * For SPI, enable CRC as appropriate.
+	 */
+	if (mmc_host_is_spi(host)) {
+		err = mmc_emergency_spi_set_crc(host, 1);
+		if (err)
+			goto err;
+	}
+
+	/*
+	 * Fetch CID from card.
+	 */
+	if (mmc_host_is_spi(host))
+		err = mmc_emergency_send_cid(host, cid);
+	else
+		err = mmc_emergency_all_send_cid(cid);
+	if (err)
+		goto err;
+
+	if (memcmp(cid, card->raw_cid, sizeof(cid)) != 0) {
+		err = -ENOENT;
+		goto err;
+	}
+
+	/*
+	 * For native busses:  set card RCA and quit open drain mode.
+	 */
+	if (!mmc_host_is_spi(host)) {
+		err = mmc_emergency_set_relative_addr(card);
+		if (err)
+			goto err;
+
+		host->ios.bus_mode = MMC_BUSMODE_PUSHPULL;
+		host->panic_ops->set_ios(host);
+	}
+	/*
+	 * Select card, as all following commands rely on that.
+	 */
+	if (!mmc_host_is_spi(host)) {
+		err = mmc_emergency_select_card(card);
+		if (err)
+			goto err;
+	}
+
+	/*
+	 * Activate high speed (if supported)
+	 */
+	if ((card->ext_csd.hs_max_dtr != 0) &&
+			(host->caps & MMC_CAP_MMC_HIGHSPEED)) {
+		err = mmc_emergency_switch(host, EXT_CSD_CMD_SET_NORMAL,
+				EXT_CSD_HS_TIMING, 1);
+		if (err && err != -EBADMSG)
+			goto err;
+
+		if (err) {
+			pr_warn("%s: switch to highspeed failed\n",
+					__func__);
+			err = 0;
+		} else {
+			mmc_card_set_highspeed(card);
+			host->ios.timing = MMC_TIMING_MMC_HS;
+			host->panic_ops->set_ios(host);
+		}
+	}
+
+	/*
+	 * Compute bus speed.
+	 */
+	max_dtr = (unsigned int)-1;
+
+	if (mmc_card_highspeed(card)) {
+		if (max_dtr > card->ext_csd.hs_max_dtr)
+			max_dtr = card->ext_csd.hs_max_dtr;
+	} else if (max_dtr > card->csd.max_dtr) {
+		max_dtr = card->csd.max_dtr;
+	}
+
+	host->ios.clock = max_dtr;
+	host->panic_ops->set_ios(host);
+
+	/*
+	 * Activate wide bus.
+	 * By default use SDR mode for panic write
+	 */
+	if ((card->csd.mmca_vsn >= CSD_SPEC_VER_4) &&
+		(host->caps & (MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA))) {
+		unsigned ext_csd_bit, bus_width;
+
+		if (host->caps & MMC_CAP_8_BIT_DATA) {
+			ext_csd_bit = EXT_CSD_BUS_WIDTH_8;
+			bus_width = MMC_BUS_WIDTH_8;
+		} else {
+			ext_csd_bit = EXT_CSD_BUS_WIDTH_4;
+			bus_width = MMC_BUS_WIDTH_4;
+		}
+
+		err = mmc_emergency_switch(host, EXT_CSD_CMD_SET_NORMAL,
+				EXT_CSD_BUS_WIDTH, ext_csd_bit);
+
+		if (err && err != -EBADMSG)
+			goto err;
+
+		if (err) {
+			pr_warn("%s: switch to bus %dbit failed\n",
+				__func__, 1 << bus_width);
+			err = 0;
+		} else {
+			ddr = MMC_SDR_MODE;
+			host->ios.bus_width = bus_width;
+			host->panic_ops->set_ios(host);
+		}
+	}
+
+	return 0;
+err:
+	return err;
+}
+
+/*
+ * mmc_emergency_write - write 512Bytes to card in panic mode
+ * @data: data pointer which should pointed to an area no more than
+ * 512Bytes
+ * @blk_id: the block id need to write this 512B data
+ *
+ * This function is supplied to ipanic driver to write 512B data
+ * in panic mode. Please also make sure the data size should not be
+ * larger than 512B, otherwise data lossing.
+ */
+int mmc_emergency_write(char *data, unsigned int blk_id)
+{
+	struct mmc_panic_host *host = panic_host;
+	int ret;
+	if (host == NULL) {
+		pr_err("%s: no device for panic record\n", __func__);
+		return -ENODEV;
+	}
+
+	if (!host->panic_ready) {
+		pr_err("%s: device is not ready for panic record\n", __func__);
+		return -EPERM;
+	}
+
+	if (!data) {
+		pr_err("%s: invalided writing data\n", __func__);
+		return -EINVAL;
+	}
+
+	if (blk_id > host->totalsecs || blk_id < 0) {
+		pr_err("%s: invalided writing blk_id\n", __func__);
+		return -EINVAL;
+	}
+	/*
+	 * everything is OK. So, let's start panic record.
+	 *
+	 * Copy the message data to logbuf
+	 */
+	memcpy(host->logbuf, data, SECTOR_SIZE);
+
+	/* hold Dekker mutex first */
+	if (host->panic_ops->hold_mutex && host->panic_ops->release_mutex) {
+		ret = host->panic_ops->hold_mutex(host);
+		if (ret) {
+			pr_err("%s: hold Dekker mutex failed\n", __func__);
+			return ret;
+		}
+	}
+
+	ret = __mmc_emergency_write(blk_id);
+
+	/* release Dekker mutex */
+	if (host->panic_ops->hold_mutex && host->panic_ops->release_mutex)
+		host->panic_ops->release_mutex(host);
+
+	return ret;
+}
+EXPORT_SYMBOL(mmc_emergency_write);
+
+/*
+ * mmc_emergency_init: init host controller and emmc card
+ * when kernel panic occures
+ *
+ * return value:
+ * 0 - init successfully
+ * negative value - Failed during init
+ * -ENODEV - emmc card was removed by driver
+ */
+int mmc_emergency_init(void)
+{
+	struct mmc_panic_host *host = panic_host;
+	int ret;
+	if (host == NULL) {
+		pr_err("%s: no device for panic record\n", __func__);
+		return -ENODEV;
+	}
+
+	ret = mmc_emergency_prepare();
+	if (ret) {
+		pr_err("%s: prepare host controller failed\n", __func__);
+		return ret;
+	}
+
+	if (!host->panic_ops) {
+		pr_err("%s: no panic_ops for panic host\n", __func__);
+		return -EPERM;
+	}
+
+	/*
+	 * prepare host controller
+	 */
+	if (host->panic_ops->prepare)
+		host->panic_ops->prepare(host);
+
+	/*
+	 * during init eMMC card, don't want to be interrupted by SCU FW
+	 */
+	if (host->panic_ops->hold_mutex && host->panic_ops->release_mutex) {
+		ret = host->panic_ops->hold_mutex(host);
+		if (ret) {
+			pr_err("%s: hold Dekker mutex failed\n", __func__);
+			return ret;
+		}
+	} else if (host->panic_ops->power_on)
+		/* don't have Dekker mutex, just power on host controller */
+		host->panic_ops->power_on(host);
+
+	/*
+	 * reset card since we are not sure whether card is in a good status
+	 *
+	 * Since in panic mode, we init a old card, so all the command to be
+	 * used has no data. So we can reuse the sdhci ops
+	 */
+	ret = mmc_emergency_reinit_card();
+	if (ret) {
+		pr_info("%s: reinit card failed\n", __func__);
+		goto out;
+	}
+
+	/*
+	 * OK. we are ready
+	 */
+	mmc_emergency_ready();
+out:
+	/* release Dekker mutex */
+	if (host->panic_ops->hold_mutex && host->panic_ops->release_mutex)
+		host->panic_ops->release_mutex(host);
+
+	return ret;
+}
+EXPORT_SYMBOL(mmc_emergency_init);
+
+/*
+ * mmc_emergency_setup - init panic_host which is used for panic writing
+ * @host: mmc host
+ *
+ * This function can sample some important value for panic_host use to init
+ * host controller and card. It only works for the driver which has already
+ * called mmc_alloc_panic_host in its probing process
+ */
+void mmc_emergency_setup(struct mmc_host *mmc)
+{
+	struct mmc_panic_host *host = panic_host;
+
+	/*
+	 * mmc host has no panic host
+	 */
+	if (!mmc->phost)
+		return;
+
+	/*
+	 * before setup panic host, make sure panic host is
+	 * allocated
+	 */
+	if (host == NULL)
+		return;
+
+	/*
+	 * panic host has already been setup
+	 */
+	if (host->mmc)
+		return;
+
+	/*
+	 * mmc host didn't init card
+	 */
+	if (!mmc->card)
+		return;
+	/*
+	 * if is SDIO card or SD card, by pass
+	 */
+	if (mmc_card_sdio(mmc->card) ||
+			mmc_card_sd(mmc->card))
+		return;
+
+	host->card = kzalloc(sizeof(struct mmc_card), GFP_KERNEL);
+	if (!host->card) {
+		pr_err("%s: cannot alloc mmc_card for panic host\n",
+				__func__);
+		return;
+	}
+
+	memcpy(host->card, mmc->card, sizeof(struct mmc_card));
+	host->caps = mmc->caps;
+	host->mmc = mmc;
+	host->ocr = mmc->card->ocr;
+	host->totalsecs = mmc_get_capacity(mmc->card);
+	host->max_blk_size = mmc->max_blk_size;
+	host->max_blk_count = mmc->max_blk_count;
+	host->max_req_size = mmc->max_req_size;
+	if (mmc_card_blockaddr(mmc->card))
+		host->blkaddr = 1;
+	/*
+	 * sample ios values
+	 */
+	memcpy(&host->ios, &mmc->ios, sizeof(struct mmc_ios));
+#ifdef CONFIG_MMC_CLKGATE
+	if (mmc->ios.clock == 0)
+		host->ios.clock = mmc->clk_old;
+#endif
+	if (host->panic_ops && host->panic_ops->setup)
+		host->panic_ops->setup(host);
+
+	return;
+}
+EXPORT_SYMBOL(mmc_emergency_setup);
+/*
+ * mmc_alloc_panic_host - used for host layer driver to alloc mmc_panic_host.
+ * @host: mmc host
+ * @ops: this is a pointer which points to mmc_host_panic_ops. This ops should
+ * be defined in host layer driver
+ *
+ * This function need to know the mmc_host_panic_ops, host layer driver should
+ * call this function during probing.
+ *
+ */
+void mmc_alloc_panic_host(struct mmc_host *host,
+		const struct mmc_host_panic_ops *ops)
+{
+	if (panic_host) {
+		pr_info("%s: already allocate panic host\n", __func__);
+		return;
+	}
+
+	panic_host = kzalloc(sizeof(struct mmc_panic_host), GFP_KERNEL);
+	if (!panic_host) {
+		pr_err("%s %s: panic structure allocate error\n",
+				__func__, mmc_hostname(host));
+		return;
+	}
+	/*
+	 * allocate log buffer and DMA buffer
+	 * log buffer size is 512
+	 */
+	panic_host->logbuf = kzalloc(SECTOR_SIZE, GFP_KERNEL);
+	if (!panic_host->logbuf) {
+		pr_err("%s %s: log buf allocate error\n",
+				__func__, mmc_hostname(host));
+		goto free_panic_host;
+	}
+
+	panic_host->dmabuf = dma_map_single(host->parent, panic_host->logbuf,
+			SECTOR_SIZE, DMA_TO_DEVICE);
+	if (!panic_host->dmabuf) {
+		pr_err("%s %s: DMA buf allocate error\n",
+				__func__, mmc_hostname(host));
+		goto free_logbuf;
+	}
+
+	panic_host->panic_ops = ops;
+	panic_host->mmc = NULL;
+	host->phost = panic_host;
+
+	return;
+
+free_logbuf:
+	kfree(panic_host->logbuf);
+free_panic_host:
+	kfree(panic_host);
+}
+EXPORT_SYMBOL(mmc_alloc_panic_host);
diff --git a/drivers/mmc/host/sdhci-pci.h b/drivers/mmc/host/sdhci-pci.h
index 19da33c..57dba48 100644
--- a/drivers/mmc/host/sdhci-pci.h
+++ b/drivers/mmc/host/sdhci-pci.h
@@ -7,7 +7,6 @@
 
 #define PCI_DEVICE_ID_INTEL_PCH_SDIO0	0x8809
 #define PCI_DEVICE_ID_INTEL_PCH_SDIO1	0x880a
-#define PCI_DEVICE_ID_INTEL_BYT_EMMC	0x0f14
 #define PCI_DEVICE_ID_INTEL_BYT_SD	0x0f16
 #define PCI_DEVICE_ID_INTEL_BYT_EMMC2	0x0f50
 #define PCI_DEVICE_ID_INTEL_QRK_SD	0x08A7
diff --git a/drivers/power/power_supply_sysfs.c b/drivers/power/power_supply_sysfs.c
index 44420d1..2b48c84 100644
--- a/drivers/power/power_supply_sysfs.c
+++ b/drivers/power/power_supply_sysfs.c
@@ -44,7 +44,7 @@ static ssize_t power_supply_show_property(struct device *dev,
 					  struct device_attribute *attr,
 					  char *buf) {
 	static char *type_text[] = {
-		"Unknown", "Battery", "UPS", "Mains", "USB",
+		"Unknown", "Battery", "UPS", "Mains", "USB", "USB",
 		"USB_DCP", "USB_CDP", "USB_ACA"
 	};
 	static char *status_text[] = {
@@ -165,8 +165,14 @@ static struct device_attribute power_supply_attrs[] = {
 	POWER_SUPPLY_ATTR(constant_charge_current_max),
 	POWER_SUPPLY_ATTR(constant_charge_voltage),
 	POWER_SUPPLY_ATTR(constant_charge_voltage_max),
+	POWER_SUPPLY_ATTR(charge_current_limit),
 	POWER_SUPPLY_ATTR(charge_control_limit),
 	POWER_SUPPLY_ATTR(charge_control_limit_max),
+	POWER_SUPPLY_ATTR(charge_current),
+	POWER_SUPPLY_ATTR(max_charge_current),
+	POWER_SUPPLY_ATTR(charge_voltage),
+	POWER_SUPPLY_ATTR(max_charge_voltage),
+	POWER_SUPPLY_ATTR(input_cur_limit),
 	POWER_SUPPLY_ATTR(energy_full_design),
 	POWER_SUPPLY_ATTR(energy_empty_design),
 	POWER_SUPPLY_ATTR(energy_full),
@@ -180,6 +186,8 @@ static struct device_attribute power_supply_attrs[] = {
 	POWER_SUPPLY_ATTR(temp),
 	POWER_SUPPLY_ATTR(temp_alert_min),
 	POWER_SUPPLY_ATTR(temp_alert_max),
+	POWER_SUPPLY_ATTR(max_temp),
+	POWER_SUPPLY_ATTR(min_temp),
 	POWER_SUPPLY_ATTR(temp_ambient),
 	POWER_SUPPLY_ATTR(temp_ambient_alert_min),
 	POWER_SUPPLY_ATTR(temp_ambient_alert_max),
@@ -188,6 +196,11 @@ static struct device_attribute power_supply_attrs[] = {
 	POWER_SUPPLY_ATTR(time_to_full_now),
 	POWER_SUPPLY_ATTR(time_to_full_avg),
 	POWER_SUPPLY_ATTR(type),
+	POWER_SUPPLY_ATTR(charge_term_cur),
+	POWER_SUPPLY_ATTR(enable_charging),
+	POWER_SUPPLY_ATTR(enable_charger),
+	POWER_SUPPLY_ATTR(cable_type),
+	POWER_SUPPLY_ATTR(priority),
 	POWER_SUPPLY_ATTR(scope),
 	/* Properties of type `const char *' */
 	POWER_SUPPLY_ATTR(model_name),
diff --git a/drivers/spi/spi-dw-mid.c b/drivers/spi/spi-dw-mid.c
index 631445d..1791a45 100644
--- a/drivers/spi/spi-dw-mid.c
+++ b/drivers/spi/spi-dw-mid.c
@@ -147,7 +147,7 @@ static int mid_spi_dma_transfer(struct dw_spi *dws, int cs_change)
 	txconf = &txs->dma_slave;
 	rxconf = &rxs->dma_slave;
 
-	flag = DMA_PREP_INTERRUPT | DMA_COMPL_SKIP_DEST_UNMAP | DMA_CTRL_ACK;
+	flag = DMA_PREP_INTERRUPT | DMA_CTRL_ACK;
 
 	/* 2. Prepare the TX dma transfer */
 	txconf->direction = DMA_MEM_TO_DEV;
diff --git a/drivers/spi/spi-dw-pci.c b/drivers/spi/spi-dw-pci.c
index 79d41da..71afb28 100644
--- a/drivers/spi/spi-dw-pci.c
+++ b/drivers/spi/spi-dw-pci.c
@@ -74,7 +74,7 @@ static int spi_pci_probe(struct pci_dev *pdev,
 	 * clock rate, FIFO depth.
 	 */
 	if (pdev->device == 0x0800) {
-		ret = dw_spi_mid_init(dws);
+		ret = dw_spi_mid_init(dws, ent->driver_data);
 		if (ret)
 			return ret;
 	}
diff --git a/drivers/spi/spi-dw.c b/drivers/spi/spi-dw.c
index 21f49ff..da8a9fc 100644
--- a/drivers/spi/spi-dw.c
+++ b/drivers/spi/spi-dw.c
@@ -587,8 +587,6 @@ static void pump_messages(struct work_struct *work)
 		container_of(work, struct dw_spi, pump_messages);
 	unsigned long flags;
 
-	pm_runtime_get_sync(dws->parent_dev);
-
 	/* Lock queue and check for queue work */
 	spin_lock_irqsave(&dws->lock, flags);
 	if (list_empty(&dws->queue) || dws->run == QUEUE_STOPPED)
@@ -613,7 +611,6 @@ static void pump_messages(struct work_struct *work)
 
 exit:
 	spin_unlock_irqrestore(&dws->lock, flags);
-	pm_runtime_put_sync(dws->parent_dev);
 }
 
 /* spi_device use this to queue in their spi_msg */
diff --git a/drivers/tty/serial/mfd_dma.c b/drivers/tty/serial/mfd_dma.c
index f035634..3eb0e18 100644
--- a/drivers/tty/serial/mfd_dma.c
+++ b/drivers/tty/serial/mfd_dma.c
@@ -87,30 +87,6 @@ static bool dw_dma_chan_filter(struct dma_chan *chan, void *param)
 	if (dw_dma->dmac && (&dw_dma->dmac->dev == chan->device->dev))
 		return true;
 	else {
-#ifdef CONFIG_ACPI
-		acpi_handle handle = ACPI_HANDLE(chan->device->dev);
-		struct acpi_device *device;
-		int ret;
-		const char *hid;
-		ret = acpi_bus_get_device(handle, &device);
-		if (ret) {
-			pr_warn("DW HSU: no acpi entry\n");
-			return false;
-		}
-		hid = acpi_device_hid(device);
-		if (!strncmp(hid, "INTL9C60", strlen(hid))) {
-			acpi_status status;
-			unsigned long long tmp;
-			status = acpi_evaluate_integer(handle,
-					"_UID", NULL, &tmp);
-			if (!ACPI_FAILURE(status) && (tmp == 1))
-				return true;
-		}
-		if (!strncmp(hid, "80862286", strlen(hid))) {
-			return true;
-		}
-
-#endif
 		return false;
 	}
 }
diff --git a/drivers/tty/serial/mfd_plat.c b/drivers/tty/serial/mfd_plat.c
index 261acd5..5715833 100644
--- a/drivers/tty/serial/mfd_plat.c
+++ b/drivers/tty/serial/mfd_plat.c
@@ -21,15 +21,6 @@
 
 #include "mfd.h"
 
-#ifdef CONFIG_ACPI
-static const struct acpi_device_id hsu_acpi_ids[] = {
-	{ "80860F0A", 0 },
-	{ "8086228A", 0 },
-	{ }
-};
-MODULE_DEVICE_TABLE(acpi, hsu_acpi_ids);
-#endif
-
 #ifdef CONFIG_PM
 static int serial_hsu_plat_suspend(struct device *dev)
 {
@@ -113,20 +104,6 @@ static int serial_hsu_plat_port_probe(struct platform_device *pdev)
 	const struct acpi_device_id *id;
 	resource_size_t start, len;
 
-#ifdef CONFIG_ACPI
-	for (id = hsu_acpi_ids; id->id[0]; id++)
-		if (!strncmp(id->id, dev_name(&pdev->dev), strlen(id->id))) {
-			acpi_status status;
-			unsigned long long tmp;
-
-			status = acpi_evaluate_integer(ACPI_HANDLE(&pdev->dev),
-					"_UID", NULL, &tmp);
-			if (ACPI_FAILURE(status))
-				return -ENODEV;
-			port = tmp - 1;
-		}
-#endif
-
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!mem) {
 		dev_err(&pdev->dev, "no mem resource?\n");
@@ -206,9 +183,6 @@ static struct platform_driver hsu_plat_driver = {
 #if defined(CONFIG_PM) && !defined(CONFIG_CONSOLE_POLL)
 		.pm     = &serial_hsu_plat_pm_ops,
 #endif
-#ifdef CONFIG_ACPI
-		.acpi_match_table = ACPI_PTR(hsu_acpi_ids),
-#endif
 	},
 };
 
diff --git a/drivers/tty/serial/mrst_max3110.c b/drivers/tty/serial/mrst_max3110.c
index db0448a..9520d41e 100644
--- a/drivers/tty/serial/mrst_max3110.c
+++ b/drivers/tty/serial/mrst_max3110.c
@@ -40,6 +40,7 @@
 #include <linux/tty_flip.h>
 #include <linux/serial_core.h>
 #include <linux/serial_reg.h>
+#include <linux/serial_max3110.h>
 
 #include <linux/kthread.h>
 #include <linux/spi/spi.h>
@@ -69,6 +70,7 @@ struct uart_max3110 {
 	u8 clock;
 	u8 parity, word_7bits;
 	u16 irq;
+	u16 irq_edge_triggered;
 
 	unsigned long uart_flags;
 
@@ -263,7 +265,6 @@ static void serial_m3110_stop_rx(struct uart_port *port)
 	return;
 }
 
-#define WORDS_PER_XFER	128
 static void send_circ_buf(struct uart_max3110 *max,
 				struct circ_buf *xmit)
 {
@@ -272,7 +273,7 @@ static void send_circ_buf(struct uart_max3110 *max,
 	int i, len, blen, dma_size, left, ret = 0;
 
 
-	dma_size = WORDS_PER_XFER * sizeof(u16) * 2;
+	dma_size = M3110_RX_FIFO_DEPTH * sizeof(u16) * 2;
 	buf = kzalloc(dma_size, GFP_KERNEL | GFP_DMA);
 	if (!buf)
 		return;
@@ -282,7 +283,7 @@ static void send_circ_buf(struct uart_max3110 *max,
 	while (!uart_circ_empty(xmit)) {
 		left = uart_circ_chars_pending(xmit);
 		while (left) {
-			len = min(left, WORDS_PER_XFER);
+			len = min(left, M3110_RX_FIFO_DEPTH);
 			blen = len * sizeof(u16);
 			memset(ibuf, 0, blen);
 
@@ -418,8 +419,8 @@ static int max3110_main_thread(void *_max)
 				max->uart_flags || kthread_should_stop());
 
 		mutex_lock(&max->thread_mutex);
-
-		if (test_and_clear_bit(BIT_IRQ_PENDING, &max->uart_flags))
+		if (max->irq_edge_triggered &&
+			test_and_clear_bit(BIT_IRQ_PENDING, &max->uart_flags))
 			max3110_con_receive(max);
 
 		/* first handle console output */
@@ -441,11 +442,15 @@ static irqreturn_t serial_m3110_irq(int irq, void *dev_id)
 {
 	struct uart_max3110 *max = dev_id;
 
-	/* max3110's irq is a falling edge, not level triggered,
-	 * so no need to disable the irq */
+	if (max->irq_edge_triggered) {
+		/* max3110's irq is a falling edge, not level triggered,
+		 * so no need to disable the irq */
 
-	if (!test_and_set_bit(BIT_IRQ_PENDING, &max->uart_flags))
-		wake_up(&max->wq);
+		if (!test_and_set_bit(BIT_IRQ_PENDING, &max->uart_flags))
+			wake_up(&max->wq);
+	} else {
+		max3110_con_receive(max);
+	}
 
 	return IRQ_HANDLED;
 }
@@ -771,6 +776,10 @@ static int serial_m3110_probe(struct spi_device *spi)
 	void *buffer;
 	u16 res;
 	int ret = 0;
+	struct plat_max3110 *pdata = spi->dev.platform_data;
+
+	if (!pdata)
+		return -EINVAL;
 
 	max = kzalloc(sizeof(*max), GFP_KERNEL);
 	if (!max)
@@ -832,9 +841,18 @@ static int serial_m3110_probe(struct spi_device *spi)
 		goto err_kthread;
 	}
 
+	max->irq_edge_triggered = pdata->irq_edge_triggered;
+
 	if (max->irq) {
-		ret = request_irq(max->irq, serial_m3110_irq,
-				IRQ_TYPE_EDGE_FALLING, "max3110", max);
+		if (max->irq_edge_triggered) {
+			ret = request_irq(max->irq, serial_m3110_irq,
+					IRQ_TYPE_EDGE_FALLING, "max3110", max);
+		} else {
+			ret = request_threaded_irq(max->irq, NULL,
+					serial_m3110_irq,
+					IRQF_ONESHOT, "max3110", max);
+		}
+
 		if (ret) {
 			max->irq = 0;
 			dev_warn(&spi->dev,
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 7efccb0..7e9634f 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -5,6 +5,7 @@
 # These are unused now, remove them once they are no longer selected
 config USB_ARCH_HAS_OHCI
 	bool
+	default PCI
 
 config USB_OHCI_BIG_ENDIAN_DESC
 	bool
@@ -19,6 +20,7 @@ config USB_OHCI_LITTLE_ENDIAN
 
 config USB_ARCH_HAS_EHCI
 	bool
+	default PCI
 
 config USB_EHCI_BIG_ENDIAN_MMIO
 	bool
diff --git a/drivers/usb/dwc3/otg.c b/drivers/usb/dwc3/otg.c
index 31ee4b9..98eaa1d 100644
--- a/drivers/usb/dwc3/otg.c
+++ b/drivers/usb/dwc3/otg.c
@@ -1112,10 +1112,6 @@ static struct dwc_otg2 *dwc3_otg_alloc(struct device *dev)
 	spin_lock_init(&otg->lock);
 	init_waitqueue_head(&otg->main_wq);
 
-	/* Register otg notifier to monitor ID and VBus change events */
-	otg->nb.notifier_call = dwc_otg_handle_notification;
-	usb_register_notifier(&otg->usb2_phy, &otg->nb);
-
 	otg_dbg(otg, "Version: %s\n", VERSION);
 	retval = usb_add_phy(&otg->usb2_phy, USB_PHY_TYPE_USB2);
 	if (retval) {
@@ -1124,6 +1120,10 @@ static struct dwc_otg2 *dwc3_otg_alloc(struct device *dev)
 		goto err1;
 	}
 
+	/* Register otg notifier to monitor ID and VBus change events */
+	otg->nb.notifier_call = dwc_otg_handle_notification;
+	usb_register_notifier(&otg->usb2_phy, &otg->nb);
+
 	retval = usb_add_phy(&otg->usb3_phy, USB_PHY_TYPE_USB3);
 	if (retval) {
 		otg_err(otg, "can't register transceiver, err: %d\n",
diff --git a/include/linux/mfd/intel_msic.h b/include/linux/mfd/intel_msic.h
index 439a7a6..5121763 100644
--- a/include/linux/mfd/intel_msic.h
+++ b/include/linux/mfd/intel_msic.h
@@ -12,6 +12,8 @@
 #ifndef __LINUX_MFD_INTEL_MSIC_H__
 #define __LINUX_MFD_INTEL_MSIC_H__
 
+#include <asm/intel_mid_gpadc.h>
+
 /* ID */
 #define INTEL_MSIC_ID0			0x000	/* RO */
 #define INTEL_MSIC_ID1			0x001	/* RO */
@@ -52,6 +54,15 @@
 #define INTEL_MSIC_PBCONFIG		0x03e
 #define INTEL_MSIC_PBSTATUS		0x03f	/* RO */
 
+/*
+ * MSIC interrupt tree is readable from SRAM at INTEL_MSIC_IRQ_PHYS_BASE.
+ * Since IRQ block starts from address 0x002 we need to substract that from
+ * the actual IRQ status register address.
+ */
+#define MSIC_IRQ_STATUS(x)      (INTEL_MSIC_IRQ_PHYS_BASE + ((x) - 2))
+#define MSIC_IRQ_STATUS_ACCDET  MSIC_IRQ_STATUS(INTEL_MSIC_ACCDET)
+#define MSIC_IRQ_STATUS_OCAUDIO MSIC_IRQ_STATUS(INTEL_MSIC_OCAUDIO)
+
 /* GPIO */
 #define INTEL_MSIC_GPIO0LV7CTLO		0x040
 #define INTEL_MSIC_GPIO0LV6CTLO		0x041
@@ -377,9 +388,39 @@
 /**
  * struct intel_msic_gpio_pdata - platform data for the MSIC GPIO driver
  * @gpio_base: base number for the GPIOs
+ * @ngpio_lv: number of low voltage GPIOs
+ * @ngpio_hv: number of high voltage GPIOs
+ * @gpio0_lv_ctlo: low voltage GPIO0 output control register
+ * @gpio0_lv_ctli: low voltage GPIO0 input control register
+ * @gpio0_hv_ctlo: high voltage GPIO0 output control register
+ * @gpio0_hv_ctli: high voltage GPIO0 input control register
+ * @can_sleep: flag for gpio chip
  */
 struct intel_msic_gpio_pdata {
 	unsigned	gpio_base;
+	int		ngpio_lv;
+	int		ngpio_hv;
+	u16		gpio0_lv_ctlo;
+	u16		gpio0_lv_ctli;
+	u16		gpio0_hv_ctlo;
+	u16		gpio0_hv_ctli;
+	int		can_sleep;
+};
+
+#define DISABLE_VCRIT	0x01
+#define DISABLE_VWARNB	0x02
+#define DISABLE_VWARNA	0x04
+/**
+ * struct intel_msic_vdd_pdata - platform data for the MSIC VDD driver
+ * @msi: MSI number used for VDD interrupts
+ *
+ * The MSIC CTP driver converts @msi into an IRQ number and passes it to
+ * the VDD driver as %IORESOURCE_IRQ.
+ */
+struct intel_msic_vdd_pdata {
+	unsigned	msi;
+	/* 1 = VCRIT, 2 = WARNB, 4 = WARNA */
+	u8 disable_unused_comparator;
 };
 
 /**
@@ -429,6 +470,7 @@ struct intel_msic_platform_data {
 	int				irq[INTEL_MSIC_BLOCK_LAST];
 	struct intel_msic_gpio_pdata	*gpio;
 	struct intel_msic_ocd_pdata	*ocd;
+	struct intel_mid_gpadc_platform_data	*gpadc;
 };
 
 struct intel_msic;
diff --git a/include/linux/panic_gbuffer.h b/include/linux/panic_gbuffer.h
new file mode 100644
index 0000000..c0580e5
--- /dev/null
+++ b/include/linux/panic_gbuffer.h
@@ -0,0 +1,37 @@
+/*
+ * panic_gbuffer.h
+ *
+ * Copyright (C) 2013 Intel Corp
+ *
+ * Expose a generic buffer header to be passed to the panic handler in
+ * order to dump buffer content in case of kernel panic.
+ *
+ * -----------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ */
+
+#ifndef _LINUX_PANIC_GBUFFER_H
+#define _LINUX_PANIC_GBUFFER_H
+
+struct g_buffer_header {
+	unsigned char *base;
+	size_t size;
+	size_t woff;
+	size_t head;
+};
+
+void panic_set_gbuffer(struct g_buffer_header *gbuffer);
+
+#endif /* _LINUX_PANIC_GBUFFER_H */
diff --git a/include/linux/wl12xx.h b/include/linux/wl12xx.h
index a54fe82..5020662 100644
--- a/include/linux/wl12xx.h
+++ b/include/linux/wl12xx.h
@@ -50,8 +50,13 @@ enum {
 
 struct wl12xx_platform_data {
 	void (*set_power)(bool enable);
+	int (*hw_init)(struct wl12xx_platform_data *pdata);
+	void (*hw_deinit)(struct wl12xx_platform_data *pdata);
 	/* SDIO only: IRQ number if WLAN_IRQ line is used, 0 for SDIO IRQs */
 	int irq;
+	/* gpio must be set to -EINVAL by platform code if gpio based irq is
+	not used */
+	int gpio;
 	bool use_eeprom;
 	int board_ref_clock;
 	int board_tcxo_clock;
diff --git a/kernel/irq/chip.c b/kernel/irq/chip.c
index dc04c16..8d21fca 100644
--- a/kernel/irq/chip.c
+++ b/kernel/irq/chip.c
@@ -685,6 +685,7 @@ __irq_set_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,
 		irq_settings_set_noprobe(desc);
 		irq_settings_set_norequest(desc);
 		irq_settings_set_nothread(desc);
+		irq_settings_set_chained(desc);
 		irq_startup(desc, true);
 	}
 out:
diff --git a/kernel/irq/settings.h b/kernel/irq/settings.h
index 3320b84..2719b65 100644
--- a/kernel/irq/settings.h
+++ b/kernel/irq/settings.h
@@ -16,6 +16,7 @@ enum {
 	_IRQ_PER_CPU_DEVID	= IRQ_PER_CPU_DEVID,
 	_IRQ_IS_POLLED		= IRQ_IS_POLLED,
 	_IRQF_MODIFY_MASK	= IRQF_MODIFY_MASK,
+	_IRQ_CHAINED		= IRQ_CHAINED,
 };
 
 #define IRQ_PER_CPU		GOT_YOU_MORON
@@ -30,6 +31,7 @@ enum {
 #define IRQ_IS_POLLED		GOT_YOU_MORON
 #undef IRQF_MODIFY_MASK
 #define IRQF_MODIFY_MASK	GOT_YOU_MORON
+#define IRQ_CHAINED		GOT_YOU_MORON
 
 static inline void
 irq_settings_clr_and_set(struct irq_desc *desc, u32 clr, u32 set)
@@ -150,6 +152,11 @@ static inline bool irq_settings_is_nested_thread(struct irq_desc *desc)
 	return desc->status_use_accessors & _IRQ_NESTED_THREAD;
 }
 
+static inline bool irq_settings_set_chained(struct irq_desc *desc)
+{
+	return desc->status_use_accessors |= _IRQ_CHAINED;
+}
+
 static inline bool irq_settings_is_polled(struct irq_desc *desc)
 {
 	return desc->status_use_accessors & _IRQ_IS_POLLED;
diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index a755ad7..b1d2c51 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -358,6 +358,13 @@ static void log_store(int facility, int level,
 	log_next_seq++;
 }
 
+/* Clears the ring-buffer */
+void log_buf_clear(void)
+{
+	clear_seq = log_next_seq;
+	clear_idx = log_next_idx;
+}
+
 #ifdef CONFIG_SECURITY_DMESG_RESTRICT
 int dmesg_restrict = 1;
 #else
@@ -1343,7 +1350,7 @@ static int console_trylock_for_printk(unsigned int cpu)
 {
 	int retval = 0, wake = 0;
 
-	if (console_trylock()) {
+	if (!in_nmi() && console_trylock()) {
 		retval = 1;
 
 		/*
@@ -1522,7 +1529,13 @@ asmlinkage int vprintk_emit(int facility, int level,
 	}
 
 	lockdep_off();
-	raw_spin_lock(&logbuf_lock);
+	if (unlikely(in_nmi())) {
+		if (!raw_spin_trylock(&logbuf_lock))
+			goto out_restore_lockdep_irqs;
+	} else {
+		raw_spin_lock(&logbuf_lock);
+	}
+
 	logbuf_cpu = this_cpu;
 
 	if (recursion_bug) {
@@ -1621,6 +1634,7 @@ asmlinkage int vprintk_emit(int facility, int level,
 	if (console_trylock_for_printk(this_cpu))
 		console_unlock();
 
+out_restore_lockdep_irqs:
 	lockdep_on();
 out_restore_irqs:
 	local_irq_restore(flags);
-- 
1.7.5.4

