From b0f6ceb4ebd937434e03f0394c0f2b8874c8c696 Mon Sep 17 00:00:00 2001
From: Liwei Song <liwei.song@windriver.com>
Date: Tue, 1 Mar 2016 07:09:27 -0500
Subject: [PATCH 04/11] iio: enable Intel Edison IIO device

This patch is from yocto Intel Edison support:
http://downloadmirror.intel.com/25028/eng/edison-src-ww25.5-15.tgz

The patch is use to enable intel edison iio device.
With it the kernel can detect the iio device connect to spi.

Signed-off-by: Liwei Song <liwei.song@windriver.com>
---
 arch/x86/include/asm/intel_basincove_gpadc.h       |   61 ++
 arch/x86/include/asm/intel_mid_remoteproc.h        |  117 ++++
 arch/x86/platform/intel-mid/Makefile               |    1 +
 arch/x86/platform/intel-mid/board.c                |  165 ++++++
 arch/x86/platform/intel-mid/device_libs/Makefile   |    1 +
 .../intel-mid/device_libs/platform_ads7955.c       |   37 ++
 .../intel-mid/device_libs/platform_ads7955.h       |   20 +
 .../intel-mid/device_libs/platform_bcove_adc.h     |   17 +
 .../intel-mid/device_libs/platform_bq24261.h       |   26 +
 .../intel-mid/device_libs/platform_emc1403.h       |   16 +
 .../intel-mid/device_libs/platform_lis331.h        |   16 +
 .../intel-mid/device_libs/platform_max3111.h       |   20 +
 .../intel-mid/device_libs/platform_max7315.h       |   19 +
 .../intel-mid/device_libs/platform_mpu3050.h       |   16 +
 .../intel-mid/device_libs/platform_mrfl_ocd.h      |   19 +
 .../intel-mid/device_libs/platform_mrfl_pmic.h     |   17 +
 .../intel-mid/device_libs/platform_mrfl_pmic_i2c.h |   17 +
 .../intel-mid/device_libs/platform_mrfl_thermal.h  |   26 +
 .../intel-mid/device_libs/platform_mrfld_audio.h   |   25 +
 .../intel-mid/device_libs/platform_msic_adc.h      |   18 +
 .../intel-mid/device_libs/platform_msic_audio.h    |   16 +
 .../intel-mid/device_libs/platform_msic_battery.h  |   17 +
 .../intel-mid/device_libs/platform_msic_gpio.h     |   18 +
 .../intel-mid/device_libs/platform_msic_ocd.h      |   16 +
 .../device_libs/platform_msic_power_btn.h          |   19 +
 .../intel-mid/device_libs/platform_msic_thermal.h  |   26 +
 .../intel-mid/device_libs/platform_pcal9555a.h     |   19 +
 .../intel-mid/device_libs/platform_pmic_gpio.h     |   16 +
 .../intel-mid/device_libs/platform_soc_thermal.h   |   20 +
 .../intel-mid/device_libs/platform_spidev.h        |   20 +
 .../intel-mid/device_libs/platform_tc35876x.h      |   16 +
 .../intel-mid/device_libs/platform_tca6416.h       |   20 +
 .../platform/intel-mid/device_libs/platform_wifi.h |   21 +
 .../intel-mid/device_libs/platform_wl12xx.h        |   21 +
 .../intel-mid/device_libs/platform_wm8994.h        |    6 +
 drivers/iio/adc/Kconfig                            |   18 +
 drivers/iio/adc/Makefile                           |    2 +
 drivers/iio/adc/iio_basincove_gpadc.c              |  596 ++++++++++++++++++++
 drivers/iio/adc/ti-ads7955.c                       |  421 ++++++++++++++
 drivers/iio/industrialio-core.c                    |    1 +
 drivers/iio/inkern.c                               |   60 ++
 include/linux/iio/consumer.h                       |    3 +
 include/linux/iio/iio.h                            |    3 +
 include/linux/iio/types.h                          |    1 +
 include/linux/platform_data/ti-ads7955.h           |   21 +
 include/linux/sfi.h                                |    5 +
 46 files changed, 2056 insertions(+), 0 deletions(-)
 create mode 100644 arch/x86/include/asm/intel_basincove_gpadc.h
 create mode 100644 arch/x86/include/asm/intel_mid_remoteproc.h
 create mode 100644 arch/x86/platform/intel-mid/board.c
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_ads7955.c
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_ads7955.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_bcove_adc.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_bq24261.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_emc1403.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_lis331.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_max3111.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_max7315.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_mpu3050.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_mrfl_ocd.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_mrfl_pmic.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_mrfl_pmic_i2c.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_mrfl_thermal.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_mrfld_audio.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_msic_adc.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_msic_audio.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_msic_battery.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_msic_gpio.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_msic_ocd.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_msic_power_btn.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_msic_thermal.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_pcal9555a.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_pmic_gpio.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_soc_thermal.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_spidev.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_tc35876x.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_tca6416.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_wifi.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_wl12xx.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_wm8994.h
 create mode 100644 drivers/iio/adc/iio_basincove_gpadc.c
 create mode 100644 drivers/iio/adc/ti-ads7955.c
 create mode 100644 include/linux/platform_data/ti-ads7955.h

diff --git a/arch/x86/include/asm/intel_basincove_gpadc.h b/arch/x86/include/asm/intel_basincove_gpadc.h
new file mode 100644
index 0000000..d4d1ffa
--- /dev/null
+++ b/arch/x86/include/asm/intel_basincove_gpadc.h
@@ -0,0 +1,61 @@
+#ifndef __INTEL_BASINCOVE_GPADC_H__
+#define __INTEL_BASINCOVE_GPADC_H__
+
+#define GPADC_VBAT	(1 << 0)
+#define GPADC_BATID	(1 << 1)
+#define GPADC_IBAT	(1 << 2)
+#define GPADC_PMICTEMP	(1 << 3)
+#define GPADC_BATTEMP0	(1 << 4)
+#define GPADC_BATTEMP1	(1 << 5)
+#define GPADC_SYSTEMP0	(1 << 6)
+#define GPADC_SYSTEMP1	(1 << 7)
+#define GPADC_SYSTEMP2	(1 << 8)
+#define GPADC_CH_NUM	9
+
+#define MBATTEMP	(1 << 2)
+#define MSYSTEMP	(1 << 3)
+#define MBATT		(1 << 4)
+#define MVIBATT		(1 << 5)
+#define MCCTICK		(1 << 7)
+
+#define GPADC_RSL(channel, res) (res->data[ffs(channel)-1])
+
+struct gpadc_regmap_t {
+	char *name;
+	int cntl;       /* GPADC Conversion Control Bit indicator */
+	int rslth;      /* GPADC Conversion Result Register Addr High */
+	int rsltl;      /* GPADC Conversion Result Register Addr Low */
+};
+
+struct gpadc_regs_t {
+	u16 gpadcreq;
+	u16 gpadcreq_irqen;
+	u16 gpadcreq_busy;
+	u16 mirqlvl1;
+	u16 mirqlvl1_adc;
+	u16 adc1cntl;
+	u16 adcirq;
+	u16 madcirq;
+};
+
+struct iio_dev;
+
+struct intel_basincove_gpadc_platform_data {
+	int channel_num;
+	unsigned long intr;
+	u8 intr_mask;
+	struct iio_map *gpadc_iio_maps;
+	struct gpadc_regmap_t *gpadc_regmaps;
+	struct gpadc_regs_t *gpadc_regs;
+	const struct iio_chan_spec *gpadc_channels;
+};
+
+struct gpadc_result {
+	int data[GPADC_CH_NUM];
+};
+
+int iio_basincove_gpadc_sample(struct iio_dev *indio_dev,
+				int ch, struct gpadc_result *res);
+
+int intel_basincove_gpadc_sample(int ch, struct gpadc_result *res);
+#endif
diff --git a/arch/x86/include/asm/intel_mid_remoteproc.h b/arch/x86/include/asm/intel_mid_remoteproc.h
new file mode 100644
index 0000000..d65a8139
--- /dev/null
+++ b/arch/x86/include/asm/intel_mid_remoteproc.h
@@ -0,0 +1,117 @@
+/*
+ * INTEL MID Remote Processor Head File
+ *
+ * Copyright (C) 2012 Intel, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef _ASM_INTEL_MID_REMOTEPROC_H
+#define _ASM_INTEL_MID_REMOTEPROC_H
+
+#define RP_IPC_COMMAND		0xA0
+#define RP_IPC_SIMPLE_COMMAND	0xA1
+#define RP_IPC_RAW_COMMAND	0xA2
+
+#define	RP_PMIC_ACCESS		0xFF
+#define	RP_DFU_REQUEST		0xFE
+#define	RP_SET_WATCHDOG		0xF8
+#define	RP_FLIS_ACCESS		0xF5
+#define	RP_GET_FW_REVISION	0xF4
+#define	RP_COLD_BOOT		0xF3
+#define	RP_COLD_RESET		0xF1
+#define	RP_COLD_OFF		0x80
+#define	RP_MIP_ACCESS		0xEC
+#define RP_GET_HOBADDR		0xE5
+#define RP_OSC_CLK_CTRL		0xE6
+#define RP_S0IX_COUNTER		0xE8
+#define RP_WRITE_OSNIB		0xE4
+#define RP_FW_UPDATE		0xFE
+#define RP_VRTC			0xFA
+#define RP_PMDB			0xE0
+#define RP_INDIRECT_WRITE	0x05
+
+/*
+ * Assigning some temp ids for following devices
+ * TODO: Need to change it to some meaningful
+ *       values.
+ */
+#define RP_PMIC_GPIO		0X02
+#define RP_PMIC_AUDIO		0x03
+#define RP_MSIC_GPIO		0x05
+#define RP_MSIC_AUDIO		0x06
+#define RP_MSIC_OCD		0x07
+#define RP_MSIC_BATTERY		0XEF
+#define RP_MSIC_THERMAL		0x09
+#define RP_MSIC_POWER_BTN	0x10
+#define RP_IPC			0X11
+#define RP_IPC_UTIL		0X12
+#define RP_FW_ACCESS		0X13
+#define RP_UMIP_ACCESS		0x14
+#define RP_OSIP_ACCESS		0x15
+#define RP_MSIC_ADC		0x16
+#define RP_BQ24192		0x17
+#define RP_MSIC_CLV_AUDIO	0x18
+#define RP_PMIC_CCSM		0x19
+#define RP_PMIC_I2C		0x20
+#define RP_MSIC_MRFLD_AUDIO	0x21
+#define RP_MSIC_PWM		0x22
+#define RP_MSIC_KPD_LED		0x23
+#define RP_BCOVE_ADC		0x24
+#define RP_BCOVE_THERMAL	0x25
+#define RP_MRFL_OCD		0x26
+#define RP_FW_LOGGING		0x27
+#define RP_PMIC_CHARGER		0x28
+
+enum rproc_type {
+	RPROC_SCU = 0,
+	RPROC_PSH,
+	RPROC_NUM,
+};
+
+struct rproc_ops;
+struct platform_device;
+struct rpmsg_ns_msg;
+
+struct rpmsg_ns_info {
+	enum rproc_type type;
+	char name[RPMSG_NAME_SIZE];
+	u32 addr;
+	u32 flags;
+	struct list_head node;
+};
+
+struct rpmsg_ns_list {
+	struct list_head list;
+	struct mutex lock;
+};
+
+extern struct rpmsg_ns_info *rpmsg_ns_alloc(const char *name,
+						int id, u32 addr);
+extern void rpmsg_ns_add_to_list(struct rpmsg_ns_info *info,
+					struct rpmsg_ns_list *nslist);
+
+/*
+ * struct intel_mid_rproc_pdata - intel mid remoteproc's platform data
+ * @name: the remoteproc's name
+ * @firmware: name of firmware file to load
+ * @ops: start/stop rproc handlers
+ * @device_enable: handler for enabling a device
+ * @device_shutdown: handler for shutting down a device
+ */
+struct intel_mid_rproc_pdata {
+	const char *name;
+	const char *firmware;
+	const struct rproc_ops *ops;
+	int (*device_enable) (struct platform_device *pdev);
+	int (*device_shutdown) (struct platform_device *pdev);
+	struct rpmsg_ns_list *nslist;
+};
+
+#endif /* _ASM_INTEL_MID_REMOTEPROC_H */
diff --git a/arch/x86/platform/intel-mid/Makefile b/arch/x86/platform/intel-mid/Makefile
index 0a8ee70..a63c34b 100644
--- a/arch/x86/platform/intel-mid/Makefile
+++ b/arch/x86/platform/intel-mid/Makefile
@@ -5,3 +5,4 @@ obj-$(CONFIG_EARLY_PRINTK_INTEL_MID) += early_printk_intel_mid.o
 ifdef CONFIG_X86_INTEL_MID
 obj-$(CONFIG_SFI) += sfi.o device_libs/
 endif
+obj-$(CONFIG_X86_INTEL_MID) += board.o
diff --git a/arch/x86/platform/intel-mid/board.c b/arch/x86/platform/intel-mid/board.c
new file mode 100644
index 0000000..fb22a20
--- /dev/null
+++ b/arch/x86/platform/intel-mid/board.c
@@ -0,0 +1,165 @@
+/*
+ * board-blackbay.c: Intel Medfield based board (Blackbay)
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/scatterlist.h>
+#include <linux/sfi.h>
+#include <linux/intel_pmic_gpio.h>
+#include <linux/spi/spi.h>
+#include <linux/i2c.h>
+#include <linux/platform_data/pca953x.h>
+#include <linux/gpio.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/platform_device.h>
+#include <linux/mfd/intel_msic.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+#include <linux/i2c-gpio.h>
+
+#include <asm/setup.h>
+#include <asm/mpspec_def.h>
+#include <asm/hw_irq.h>
+#include <asm/apic.h>
+#include <asm/io_apic.h>
+#include <asm/intel-mid.h>
+#include <asm/intel_mid_vrtc.h>
+#include <asm/io.h>
+#include <asm/i8259.h>
+#include <asm/intel_scu_ipc.h>
+#include <asm/apb_timer.h>
+#include <asm/reboot.h>
+
+/*
+ * IPC devices
+ */
+#include "device_libs/platform_ipc.h"
+#include "device_libs/platform_pmic_gpio.h"
+#include "device_libs/platform_msic.h"
+#include "device_libs/platform_msic_battery.h"
+#include "device_libs/platform_msic_gpio.h"
+#include "device_libs/platform_msic_audio.h"
+#include "device_libs/platform_msic_power_btn.h"
+#include "device_libs/platform_msic_ocd.h"
+#include "device_libs/platform_mrfl_pmic.h"
+#include "device_libs/platform_mrfl_pmic_i2c.h"
+#include "device_libs/platform_mrfl_ocd.h"
+#include "device_libs/platform_msic_thermal.h"
+#include "device_libs/platform_soc_thermal.h"
+#include "device_libs/platform_msic_adc.h"
+#include "device_libs/platform_bcove_adc.h"
+#include "device_libs/platform_mrfld_audio.h"
+#include "device_libs/platform_mrfl_thermal.h"
+
+/*
+ * I2C devices
+ */
+#include "device_libs/platform_max7315.h"
+#include "device_libs/platform_tca6416.h"
+#include "device_libs/platform_mpu3050.h"
+#include "device_libs/platform_emc1403.h"
+#include "device_libs/platform_lis331.h"
+#include "device_libs/platform_mpu3050.h"
+#include "device_libs/platform_tc35876x.h"
+#include "device_libs/platform_bq24261.h"
+#include "device_libs/platform_pcal9555a.h"
+
+#include "device_libs/platform_wm8994.h"
+
+/*
+ * SPI devices
+ */
+#include "device_libs/platform_max3111.h"
+#include "device_libs/platform_spidev.h"
+#include "device_libs/platform_ads7955.h"
+
+/* WIFI devices */
+#include "device_libs/platform_wl12xx.h"
+#include "device_libs/platform_wifi.h"
+
+static void __init *no_platform_data(void *info)
+{
+	return NULL;
+}
+
+struct devs_id __initconst device_ids[] = {
+	/* SD devices */
+	{"wl12xx_clk_vmmc", SFI_DEV_TYPE_SD, 0, &wl12xx_platform_data, NULL},
+	{"bcm43xx_clk_vmmc", SFI_DEV_TYPE_SD, 0, &wifi_platform_data, NULL},
+	{"bcm43xx_vmmc", SFI_DEV_TYPE_SD, 0, &wifi_platform_data, NULL},
+	{"iwlwifi_clk_vmmc", SFI_DEV_TYPE_SD, 0, &wifi_platform_data, NULL},
+	{"WLAN_FAST_IRQ", SFI_DEV_TYPE_SD, 0, &no_platform_data,
+	 &wifi_platform_data_fastirq},
+
+	/* I2C devices*/
+	{"pcal9555a-1", SFI_DEV_TYPE_I2C, 1, &pcal9555a_platform_data, NULL},
+	{"pcal9555a-2", SFI_DEV_TYPE_I2C, 1, &pcal9555a_platform_data, NULL},
+	{"pcal9555a-3", SFI_DEV_TYPE_I2C, 1, &pcal9555a_platform_data, NULL},
+	{"pcal9555a-4", SFI_DEV_TYPE_I2C, 1, &pcal9555a_platform_data, NULL},
+
+	/* SPI devices */
+	{"spidev", SFI_DEV_TYPE_SPI, 0, &spidev_platform_data, NULL},
+	{"ads7955", SFI_DEV_TYPE_SPI, 0, &ads7955_platform_data, NULL},
+	{"bma023", SFI_DEV_TYPE_I2C, 1, &no_platform_data, NULL},
+	{"pmic_gpio", SFI_DEV_TYPE_SPI, 1, &pmic_gpio_platform_data, NULL},
+	{"pmic_gpio", SFI_DEV_TYPE_IPC, 1, &pmic_gpio_platform_data,
+					&ipc_device_handler},
+	{"spi_max3111", SFI_DEV_TYPE_SPI, 0, &max3111_platform_data, NULL},
+	{"i2c_max7315", SFI_DEV_TYPE_I2C, 1, &max7315_platform_data, NULL},
+	{"i2c_max7315_2", SFI_DEV_TYPE_I2C, 1, &max7315_platform_data, NULL},
+	{"tca6416", SFI_DEV_TYPE_I2C, 1, &tca6416_platform_data, NULL},
+	{"emc1403", SFI_DEV_TYPE_I2C, 1, &emc1403_platform_data, NULL},
+	{"i2c_accel", SFI_DEV_TYPE_I2C, 0, &lis331dl_platform_data, NULL},
+	{"pmic_audio", SFI_DEV_TYPE_IPC, 1, &no_platform_data,
+					&ipc_device_handler},
+	{"mpu3050", SFI_DEV_TYPE_I2C, 1, &mpu3050_platform_data, NULL},
+	{"i2c_disp_brig", SFI_DEV_TYPE_I2C, 0, &tc35876x_platform_data, NULL},
+
+	/* MSIC subdevices */
+	{"msic_adc", SFI_DEV_TYPE_IPC, 1, &msic_adc_platform_data,
+						&ipc_device_handler},
+	{"bcove_power_btn", SFI_DEV_TYPE_IPC, 1, &msic_power_btn_platform_data,
+					&ipc_device_handler},
+	{"msic_battery", SFI_DEV_TYPE_IPC, 1, &msic_battery_platform_data,
+					&ipc_device_handler},
+	{"msic_gpio", SFI_DEV_TYPE_IPC, 1, &msic_gpio_platform_data,
+					&ipc_device_handler},
+	{"msic_audio", SFI_DEV_TYPE_IPC, 1, &msic_audio_platform_data,
+					&ipc_device_handler},
+	{"msic_power_btn", SFI_DEV_TYPE_IPC, 1, &msic_power_btn_platform_data,
+					&ipc_device_handler},
+	{"msic_ocd", SFI_DEV_TYPE_IPC, 1, &msic_ocd_platform_data,
+					&ipc_device_handler},
+	{"bcove_bcu", SFI_DEV_TYPE_IPC, 1, &mrfl_ocd_platform_data,
+					&ipc_device_handler},
+	{"msic_thermal", SFI_DEV_TYPE_IPC, 1, &msic_thermal_platform_data,
+					&ipc_device_handler},
+	{"bcove_adc", SFI_DEV_TYPE_IPC, 1, &bcove_adc_platform_data,
+					&ipc_device_handler},
+	{"bcove_thrm", SFI_DEV_TYPE_IPC, 1, &mrfl_thermal_platform_data,
+					&ipc_device_handler},
+	{"wm8994", SFI_DEV_TYPE_I2C, 0, &wm8994_platform_data, NULL},
+	/* IPC devices */
+	{"pmic_charger", SFI_DEV_TYPE_IPC, 1, &no_platform_data, NULL},
+	{"pmic_ccsm", SFI_DEV_TYPE_IPC, 1, &mrfl_pmic_ccsm_platform_data,
+						&ipc_device_handler},
+	{"i2c_pmic_adap", SFI_DEV_TYPE_IPC, 1, &mrfl_pmic_i2c_platform_data,
+						&ipc_device_handler},
+	{"mrfld_sst", SFI_DEV_TYPE_IPC, 1, &mrfld_sst_audio_platform_data,
+						&ipc_device_handler},
+	{"soc_thrm", SFI_DEV_TYPE_IPC, 1, &no_platform_data,
+						&soc_thrm_device_handler},
+	{},
+};
diff --git a/arch/x86/platform/intel-mid/device_libs/Makefile b/arch/x86/platform/intel-mid/device_libs/Makefile
index 9d3012b..1e409dd 100644
--- a/arch/x86/platform/intel-mid/device_libs/Makefile
+++ b/arch/x86/platform/intel-mid/device_libs/Makefile
@@ -23,3 +23,4 @@ obj-$(subst m,y,$(CONFIG_SERIAL_MRST_MAX3110)) += platform_max3111.o
 obj-$(subst m,y,$(CONFIG_KEYBOARD_GPIO)) += platform_gpio_keys.o
 # UART Devices
 obj-$(subst m,y,$(CONFIG_SERIAL_MFD_HSU)) += platform_hsu.o
+obj-$(subst m,y,$(CONFIG_TI_ADS7955_ADC)) += platform_ads7955.o
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_ads7955.c b/arch/x86/platform/intel-mid/device_libs/platform_ads7955.c
new file mode 100644
index 0000000..c0d07aa
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_ads7955.c
@@ -0,0 +1,37 @@
+/*
+ * platform_ads7955.c: ads7955 platform data initialization file
+ *
+ * (C) Copyright 2014 Intel Corporation
+ * Author: Dan O'Donovan <dan@emutex.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#include <linux/gpio.h>
+#include <linux/spi/spi.h>
+#include <linux/lnw_gpio.h>
+#include <linux/spi/intel_mid_ssp_spi.h>
+#include <asm/intel-mid.h>
+#include "platform_ads7955.h"
+
+static struct intel_mid_ssp_spi_chip chip = {
+	.burst_size = DFLT_FIFO_BURST_SIZE,
+	.timeout = DFLT_TIMEOUT_VAL,
+	/* SPI DMA is current not usable on Tangier */
+	.dma_enabled = false,
+};
+
+void __init *ads7955_platform_data(void *info)
+{
+	struct spi_board_info *spi_info = info;
+
+	spi_info->mode = SPI_MODE_0;
+
+	spi_info->controller_data = &chip;
+	spi_info->bus_num = FORCE_SPI_BUS_NUM;
+
+	return NULL;
+}
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_ads7955.h b/arch/x86/platform/intel-mid/device_libs/platform_ads7955.h
new file mode 100644
index 0000000..114958f
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_ads7955.h
@@ -0,0 +1,20 @@
+/*
+ * platform_ads7955.h: ads7955 platform data header file
+ *
+ * (C) Copyright 2014 Intel Corporation
+ * Author: Dan O'Donovan <dan@emutex.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_ADS7955_H_
+#define _PLATFORM_ADS7955_H_
+
+/* REVERT ME workaround[MRFL] for invalid bus number in IAFW .25 */
+#define FORCE_SPI_BUS_NUM	5
+#define FORCE_CHIP_SELECT	0
+
+extern void *ads7955_platform_data(void *info) __attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_bcove_adc.h b/arch/x86/platform/intel-mid/device_libs/platform_bcove_adc.h
new file mode 100644
index 0000000..044adc7
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_bcove_adc.h
@@ -0,0 +1,17 @@
+/*
+ * platform_bcove_adc.h: Head File for Merrifield Basincove GPADC driver
+ *
+ * (C) Copyright 2012 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_BCOVE_ADC_H_
+#define _PLATFORM_BCOVE_ADC_H_
+
+#define BCOVE_ADC_DEV_NAME	"bcove_adc"
+
+extern void __init *bcove_adc_platform_data(void *info) __attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_bq24261.h b/arch/x86/platform/intel-mid/device_libs/platform_bq24261.h
new file mode 100644
index 0000000..6b97380
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_bq24261.h
@@ -0,0 +1,26 @@
+/*
+ * platform_mrfl_bq24261.h: platform data for bq24261 driver
+ *
+ * (C) Copyright 2012 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_MRFL_BQ24261_H_
+#define _PLATFORM_MRFL_BQ24261_H_
+
+#define MRFL_CHRGR_DEV_NAME	"bq24261_charger"
+
+#define PMIC_SRAM_INTR_MAP 0xFFFFF616
+#define PMIC_EXT_INTR_MASK 0x01
+
+#define BQ24261_CHRG_CUR_LOW		100	/* 100mA */
+#define BQ24261_CHRG_CUR_MEDIUM		500	/* 500mA */
+#define BQ24261_CHRG_CUR_HIGH		900	/* 900mA */
+#define BQ24261_CHRG_CUR_NOLIMIT	1500	/* 1500mA */
+
+extern void __init *bq24261_platform_data(
+			void *info) __attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_emc1403.h b/arch/x86/platform/intel-mid/device_libs/platform_emc1403.h
new file mode 100644
index 0000000..0229438
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_emc1403.h
@@ -0,0 +1,16 @@
+/*
+ * platform_emc1403.h: emc1403 platform data header file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_EMC1403_H_
+#define _PLATFORM_EMC1403_H_
+
+extern void __init *emc1403_platform_data(void *info) __attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_lis331.h b/arch/x86/platform/intel-mid/device_libs/platform_lis331.h
new file mode 100644
index 0000000..37fbe0c
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_lis331.h
@@ -0,0 +1,16 @@
+/*
+ * platform_lis331.h: lis331 platform data header file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_LIS331_H_
+#define _PLATFORM_LIS331_H_
+
+extern void __init *lis331dl_platform_data(void *info) __attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_max3111.h b/arch/x86/platform/intel-mid/device_libs/platform_max3111.h
new file mode 100644
index 0000000..fe2c361
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_max3111.h
@@ -0,0 +1,20 @@
+/*
+ * platform_max3111.h: max3111 platform data header file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_MAX3111_H_
+#define _PLATFORM_MAX3111_H_
+
+/* REVERT ME workaround[MRFL] for invalid bus number in IAFW .25 */
+#define FORCE_SPI_BUS_NUM	5
+#define FORCE_CHIP_SELECT	0
+
+extern void *max3111_platform_data(void *info) __attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_max7315.h b/arch/x86/platform/intel-mid/device_libs/platform_max7315.h
new file mode 100644
index 0000000..d62daa5
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_max7315.h
@@ -0,0 +1,19 @@
+/*
+ * platform_max7315.h: max7315 platform data header file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_MAX7315_H_
+#define _PLATFORM_MAX7315_H_
+
+/* we have multiple max7315 on the board ... */
+#define MAX7315_NUM 2
+
+extern void __init *max7315_platform_data(void *info) __attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_mpu3050.h b/arch/x86/platform/intel-mid/device_libs/platform_mpu3050.h
new file mode 100644
index 0000000..c324c16
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_mpu3050.h
@@ -0,0 +1,16 @@
+/*
+ * platform_mpu3050.h: mpu3050 platform data header file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_MPU3050_H_
+#define _PLATFORM_MPU3050_H_
+
+extern void *mpu3050_platform_data(void *info) __attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_mrfl_ocd.h b/arch/x86/platform/intel-mid/device_libs/platform_mrfl_ocd.h
new file mode 100644
index 0000000..d817e7d
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_mrfl_ocd.h
@@ -0,0 +1,19 @@
+/*
+ * platform_mrfl_ocd.h: msic_thermal platform data header file
+ *
+ * (C) Copyright 2013 Intel Corporation
+ * Author: Saranya Gopal <saranya.gopal@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_MRFL_OCD_H_
+#define _PLATFORM_MRFL_OCD_H_
+
+#define MRFL_OCD_DEV_NAME "bcove_bcu"
+
+extern void __init *mrfl_ocd_platform_data(void *info)
+			__attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_mrfl_pmic.h b/arch/x86/platform/intel-mid/device_libs/platform_mrfl_pmic.h
new file mode 100644
index 0000000..5eb3ed5
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_mrfl_pmic.h
@@ -0,0 +1,17 @@
+/*
+ * platform_mrfl_pmic.h: platform data for pmic driver
+ *
+ * (C) Copyright 2012 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_MRFL_PMIC_H_
+#define _PLATFORM_MRFL_PMIC_H_
+
+extern void __init *mrfl_pmic_ccsm_platform_data(
+				void *info) __attribute__((weak));
+
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_mrfl_pmic_i2c.h b/arch/x86/platform/intel-mid/device_libs/platform_mrfl_pmic_i2c.h
new file mode 100644
index 0000000..3034a7f
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_mrfl_pmic_i2c.h
@@ -0,0 +1,17 @@
+/*
+ * platform_mrfl_pmic_i2c.h: platform data for pmic i2c adapter driver
+ *
+ * (C) Copyright 2012 Intel Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_MRFL_PMIC_I2C_H_
+#define _PLATFORM_MRFL_PMIC_I2C_H_
+
+extern void __init *mrfl_pmic_i2c_platform_data(
+				void *info) __attribute__((weak));
+
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_mrfl_thermal.h b/arch/x86/platform/intel-mid/device_libs/platform_mrfl_thermal.h
new file mode 100644
index 0000000..f1011a1
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_mrfl_thermal.h
@@ -0,0 +1,26 @@
+/*
+ * platform_mrfl_thermal.h: Platform data initilization file for
+ *			Intel Merrifield Platform thermal driver
+ *
+ * (C) Copyright 2013 Intel Corporation
+ * Author: Durgadoss R <durgadoss.r@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_MRFL_THERMAL_H_
+#define _PLATFORM_MRFL_THERMAL_H_
+
+#define MRFL_THERM_DEV_NAME "bcove_thrm"
+
+extern void __init *mrfl_thermal_platform_data(void *)
+			__attribute__((weak));
+
+enum {
+	mrfl_thermal,
+	bdgb_thermal,
+};
+
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_mrfld_audio.h b/arch/x86/platform/intel-mid/device_libs/platform_mrfld_audio.h
new file mode 100644
index 0000000..2a57556
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_mrfld_audio.h
@@ -0,0 +1,25 @@
+/*
+ * platform_mrfld_audio.h: MRFLD audio platform data header file
+ *
+ * (C) Copyright 2012 Intel Corporation
+ * Author: Vinod Koul <vinod.koul@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_MRFLD_AUDIO_H_
+#define _PLATFORM_MRFLD_AUDIO_H_
+
+#include <linux/sfi.h>
+
+struct mrfld_audio_platform_data {
+	const struct soft_platform_id *spid;
+	int codec_gpio;
+	int codec_rst;
+};
+
+extern void __init *merfld_audio_platform_data(void *info) __attribute__((weak));
+extern void __init *mrfld_sst_audio_platform_data(void *info) __attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_msic_adc.h b/arch/x86/platform/intel-mid/device_libs/platform_msic_adc.h
new file mode 100644
index 0000000..8e1f901
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_msic_adc.h
@@ -0,0 +1,18 @@
+/*
+ * platform_msic_adc.h: MSIC ADC platform data header file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_MSIC_ADC_H_
+#define _PLATFORM_MSIC_ADC_H_
+
+#define ADC_DEVICE_NAME "msic_adc"
+
+extern void __init *msic_adc_platform_data(void *info) __attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_msic_audio.h b/arch/x86/platform/intel-mid/device_libs/platform_msic_audio.h
new file mode 100644
index 0000000..1fca68f
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_msic_audio.h
@@ -0,0 +1,16 @@
+/*
+ * platform_msic_audio.h: MSIC audio platform data header file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_MSIC_AUDIO_H_
+#define _PLATFORM_MSIC_AUDIO_H_
+
+extern void __init *msic_audio_platform_data(void *info) __attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_msic_battery.h b/arch/x86/platform/intel-mid/device_libs/platform_msic_battery.h
new file mode 100644
index 0000000..9be705d
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_msic_battery.h
@@ -0,0 +1,17 @@
+/*
+ * platform_msic_battery.h: MSIC battery platform data header file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_MSIC_BATTERY_H_
+#define _PLATFORM_MSIC_BATTERY_H_
+
+extern void __init *msic_battery_platform_data(void *info)
+			__attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_msic_gpio.h b/arch/x86/platform/intel-mid/device_libs/platform_msic_gpio.h
new file mode 100644
index 0000000..b78b236
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_msic_gpio.h
@@ -0,0 +1,18 @@
+/*
+ * platform_msic_gpio.h: MSIC GPIO platform data header file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_MSIC_GPIO_H_
+#define _PLATFORM_MSIC_GPIO_H_
+
+#define MSIC_GPIO_DEVICE_NAME "msic_gpio"
+
+extern void __init *msic_gpio_platform_data(void *info) __attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_msic_ocd.h b/arch/x86/platform/intel-mid/device_libs/platform_msic_ocd.h
new file mode 100644
index 0000000..7caa13b
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_msic_ocd.h
@@ -0,0 +1,16 @@
+/*
+ * platform_msic_ocd.h: MSIC OCD platform data header file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_MSIC_OCD_H_
+#define _PLATFORM_MSIC_OCD_H_
+
+extern void __init *msic_ocd_platform_data(void *info) __attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_msic_power_btn.h b/arch/x86/platform/intel-mid/device_libs/platform_msic_power_btn.h
new file mode 100644
index 0000000..3de94ca
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_msic_power_btn.h
@@ -0,0 +1,19 @@
+/*
+ * platform_msic_power_btn.h: MSIC power btn platform data header file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_MSIC_POWER_BTN_H_
+#define _PLATFORM_MSIC_POWER_BTN_H_
+
+#define INTEL_MID_POWERBTN_DEV_NAME "mid_powerbtn"
+
+extern void __init *msic_power_btn_platform_data(void *info)
+		__attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_msic_thermal.h b/arch/x86/platform/intel-mid/device_libs/platform_msic_thermal.h
new file mode 100644
index 0000000..c4f3404
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_msic_thermal.h
@@ -0,0 +1,26 @@
+/*
+ * platform_msic_thermal.h: msic_thermal platform data header file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_MSIC_THERMAL_H_
+#define _PLATFORM_MSIC_THERMAL_H_
+
+#define MSIC_THERM_DEV_NAME "msic_thermal"
+
+extern void __init *msic_thermal_platform_data(void *info)
+			__attribute__((weak));
+enum {
+	mfld_thermal,
+	ctp_thermal,
+	lex_thermal,
+	vb_thermal,
+};
+
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_pcal9555a.h b/arch/x86/platform/intel-mid/device_libs/platform_pcal9555a.h
new file mode 100644
index 0000000..5593db2
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_pcal9555a.h
@@ -0,0 +1,19 @@
+/*
+ * platform_pcal9555a.h: pcal9555a platform data header file
+ *
+ * (C) Copyright 2014 Intel Corporation
+ * Author: Dan O'Donovan <dan@emutex.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_PCAL9555A_H_
+#define _PLATFORM_PCAL9555A_H_
+
+/* we have multiple pcal9555a on the board ... */
+#define PCAL9555A_NUM 4
+
+extern void __init *pcal9555a_platform_data(void *info) __attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_pmic_gpio.h b/arch/x86/platform/intel-mid/device_libs/platform_pmic_gpio.h
new file mode 100644
index 0000000..0bce0de
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_pmic_gpio.h
@@ -0,0 +1,16 @@
+/*
+ * platform_pmic_gpio.h: PMIC GPIO platform data header file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_PMIC_GPIO_H_
+#define _PLATFORM_PMIC_GPIO_H_
+
+extern void __init *pmic_gpio_platform_data(void *info) __attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_soc_thermal.h b/arch/x86/platform/intel-mid/device_libs/platform_soc_thermal.h
new file mode 100644
index 0000000..c8ece32
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_soc_thermal.h
@@ -0,0 +1,20 @@
+/*
+ * platform_soc_thermal.h: platform SoC thermal driver library header file
+ *
+ * (C) Copyright 2013 Intel Corporation
+ * Author: Durgadoss R <durgadoss.r@intel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_SOC_THERMAL_H_
+#define _PLATFORM_SOC_THERMAL_H_
+
+#include <linux/sfi.h>
+#include <asm/intel-mid.h>
+
+extern void soc_thrm_device_handler(struct sfi_device_table_entry *,
+			struct devs_id *) __attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_spidev.h b/arch/x86/platform/intel-mid/device_libs/platform_spidev.h
new file mode 100644
index 0000000..a40ef8f
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_spidev.h
@@ -0,0 +1,20 @@
+/*
+ * platform_spidev.h: spidev platform data header file
+ *
+ * (C) Copyright 2014 Intel Corporation
+ * Author: Dan O'Donovan <dan@emutex.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_SPIDEV_H_
+#define _PLATFORM_SPIDEV_H_
+
+/* REVERT ME workaround[MRFL] for invalid bus number in IAFW .25 */
+#define FORCE_SPI_BUS_NUM	5
+#define FORCE_CHIP_SELECT	1
+
+extern void *spidev_platform_data(void *info) __attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_tc35876x.h b/arch/x86/platform/intel-mid/device_libs/platform_tc35876x.h
new file mode 100644
index 0000000..56a74eb
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_tc35876x.h
@@ -0,0 +1,16 @@
+/*
+ * platform_tc35876x.h: tc35876x platform data header file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_TC35876X_H_
+#define _PLATFORM_TC35876X_H_
+
+extern void *tc35876x_platform_data(void *info) __attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_tca6416.h b/arch/x86/platform/intel-mid/device_libs/platform_tca6416.h
new file mode 100644
index 0000000..69802d6
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_tca6416.h
@@ -0,0 +1,20 @@
+/*
+ * platform_tca6416.h: tca6416 platform data header file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_TCA6416_H_
+#define _PLATFORM_TCA6416_H_
+
+#define TCA6416_NAME	"tca6416"
+#define TCA6416_BASE	"tca6416_base"
+#define TCA6416_INTR	"tca6416_int"
+
+extern void *tca6416_platform_data(void *info) __attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_wifi.h b/arch/x86/platform/intel-mid/device_libs/platform_wifi.h
new file mode 100644
index 0000000..7f1f710
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_wifi.h
@@ -0,0 +1,21 @@
+/*
+ * platform_wifi.h: WiFi platform data header file
+ *
+ * (C) Copyright 2011 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_WIFI_H_
+#define _PLATFORM_WIFI_H_
+
+#define WIFI_SFI_GPIO_IRQ_NAME "WLAN-interrupt"
+#define WIFI_SFI_GPIO_ENABLE_NAME "WLAN-enable"
+
+extern void __init *wifi_platform_data(void *info) __attribute__((weak));
+extern void wifi_platform_data_fastirq(struct sfi_device_table_entry *pe,
+				       struct devs_id *dev) __attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_wl12xx.h b/arch/x86/platform/intel-mid/device_libs/platform_wl12xx.h
new file mode 100644
index 0000000..909f697
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_wl12xx.h
@@ -0,0 +1,21 @@
+/*
+ * platform_wl12xx.h: wl12xx platform data header file
+ *
+ * (C) Copyright 2008 Intel Corporation
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _PLATFORM_WL12XX_H_
+#define _PLATFORM_WL12XX_H_
+
+#define WL12XX_SFI_GPIO_IRQ_NAME "WLAN-interrupt"
+#define WL12XX_SFI_GPIO_ENABLE_NAME "WLAN-enable"
+#define ICDK_BOARD_REF_CLK 26000000
+#define NCDK_BOARD_REF_CLK 38400000
+
+extern void __init *wl12xx_platform_data(void *info) __attribute__((weak));
+#endif
diff --git a/arch/x86/platform/intel-mid/device_libs/platform_wm8994.h b/arch/x86/platform/intel-mid/device_libs/platform_wm8994.h
new file mode 100644
index 0000000..ac3b2b6
--- /dev/null
+++ b/arch/x86/platform/intel-mid/device_libs/platform_wm8994.h
@@ -0,0 +1,6 @@
+#ifndef _PLATFORM_WM8994_H_
+#define _PLATFORM_WM8994_H_
+
+extern void *wm8994_platform_data(void *info) __attribute__((weak));
+extern void *wm8958_platform_data(void *info) __attribute__((weak));
+#endif
diff --git a/drivers/iio/adc/Kconfig b/drivers/iio/adc/Kconfig
index 2209f28..9be77ff 100644
--- a/drivers/iio/adc/Kconfig
+++ b/drivers/iio/adc/Kconfig
@@ -174,6 +174,18 @@ config TI_ADC081C
 	  This driver can also be built as a module. If so, the module will be
 	  called ti-adc081c.
 
+config TI_ADS7955_ADC
+	tristate "Texas Instruments ADS7955 ADC driver"
+	depends on SPI
+	select IIO_BUFFER
+	select IIO_TRIGGERED_BUFFER
+	help
+	  Say yes here to build support for Texas Instruments ADS7955
+	  8 Channel ADC.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ti-ads7955.
+
 config TI_AM335X_ADC
 	tristate "TI's AM335X ADC driver"
 	depends on MFD_TI_AM335X_TSCADC
@@ -204,4 +216,10 @@ config VIPERBOARD_ADC
 	  Say yes here to access the ADC part of the Nano River
 	  Technologies Viperboard.
 
+config IIO_BASINCOVE_GPADC
+	tristate "IIO Basincove GPADC driver"
+	depends on IIO
+	help
+	  Say yes here to build support for the IIO basincove GPADC driver.
+
 endmenu
diff --git a/drivers/iio/adc/Makefile b/drivers/iio/adc/Makefile
index ba9a10a..bbb6ce5 100644
--- a/drivers/iio/adc/Makefile
+++ b/drivers/iio/adc/Makefile
@@ -19,6 +19,8 @@ obj-$(CONFIG_MCP320X) += mcp320x.o
 obj-$(CONFIG_MCP3422) += mcp3422.o
 obj-$(CONFIG_NAU7802) += nau7802.o
 obj-$(CONFIG_TI_ADC081C) += ti-adc081c.o
+obj-$(CONFIG_TI_ADS7955_ADC) += ti-ads7955.o
 obj-$(CONFIG_TI_AM335X_ADC) += ti_am335x_adc.o
 obj-$(CONFIG_TWL6030_GPADC) += twl6030-gpadc.o
 obj-$(CONFIG_VIPERBOARD_ADC) += viperboard_adc.o
+obj-$(CONFIG_IIO_BASINCOVE_GPADC) += iio_basincove_gpadc.o
diff --git a/drivers/iio/adc/iio_basincove_gpadc.c b/drivers/iio/adc/iio_basincove_gpadc.c
new file mode 100644
index 0000000..c20b61b
--- /dev/null
+++ b/drivers/iio/adc/iio_basincove_gpadc.c
@@ -0,0 +1,596 @@
+/*
+ * iio_basincove_gpadc.c - Intel Merrifield Basin Cove GPADC Driver
+ *
+ * Copyright (C) 2012 Intel Corporation
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ * Author: Bin Yang <bin.yang@intel.com>
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/sched.h>
+#include <linux/intel_mid_pm.h>
+#include <linux/rpmsg.h>
+
+#include <asm/intel_mid_rpmsg.h>
+#include <asm/intel_mid_remoteproc.h>
+#include <asm/intel_scu_pmic.h>
+#include <asm/intel_basincove_gpadc.h>
+
+#include <linux/iio/iio.h>
+#include <linux/iio/machine.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/driver.h>
+#include <linux/iio/types.h>
+#include <linux/iio/consumer.h>
+
+struct gpadc_info {
+	int initialized;
+	/* This mutex protects gpadc sample/config from concurrent conflict.
+	   Any function, which does the sample or config, needs to
+	   hold this lock.
+	   If it is locked, it also means the gpadc is in active mode.
+	*/
+	struct mutex lock;
+	struct device *dev;
+	int irq;
+	u8 irq_status;
+	wait_queue_head_t wait;
+	int sample_done;
+	void __iomem *intr;
+	int channel_num;
+	struct gpadc_regmap_t *gpadc_regmaps;
+	struct gpadc_regs_t *gpadc_regs;
+};
+
+static inline int gpadc_clear_bits(u16 addr, u8 mask)
+{
+	return intel_scu_ipc_update_register(addr, 0, mask);
+}
+
+static inline int gpadc_set_bits(u16 addr, u8 mask)
+{
+	return intel_scu_ipc_update_register(addr, 0xff, mask);
+}
+
+static inline int gpadc_write(u16 addr, u8 data)
+{
+	return intel_scu_ipc_iowrite8(addr, data);
+}
+
+static inline int gpadc_read(u16 addr, u8 *data)
+{
+	return intel_scu_ipc_ioread8(addr, data);
+}
+
+static int gpadc_busy_wait(struct gpadc_regs_t *regs)
+{
+	u8 tmp;
+	int timeout = 0;
+
+	gpadc_read(regs->gpadcreq, &tmp);
+	while (tmp & regs->gpadcreq_busy && timeout < 500) {
+		gpadc_read(regs->gpadcreq, &tmp);
+		usleep_range(1800, 2000);
+		timeout++;
+	}
+
+	if (tmp & regs->gpadcreq_busy)
+		return -EBUSY;
+	else
+		return 0;
+}
+
+static void gpadc_dump(struct gpadc_info *info)
+{
+	u8 tmp;
+	struct gpadc_regs_t *regs = info->gpadc_regs;
+
+	dev_err(info->dev, "GPADC registers dump:\n");
+	gpadc_read(regs->adcirq, &tmp);
+	dev_err(info->dev, "ADCIRQ: 0x%x\n", tmp);
+	gpadc_read(regs->madcirq, &tmp);
+	dev_err(info->dev, "MADCIRQ: 0x%x\n", tmp);
+	gpadc_read(regs->gpadcreq, &tmp);
+	dev_err(info->dev, "GPADCREQ: 0x%x\n", tmp);
+	gpadc_read(regs->adc1cntl, &tmp);
+	dev_err(info->dev, "ADC1CNTL: 0x%x\n", tmp);
+}
+
+static irqreturn_t gpadc_isr(int irq, void *data)
+{
+	struct gpadc_info *info = iio_priv(data);
+
+	info->irq_status = ioread8(info->intr);
+	info->sample_done = 1;
+	wake_up(&info->wait);
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t gpadc_threaded_isr(int irq, void *data)
+{
+	struct gpadc_info *info = iio_priv(data);
+	struct gpadc_regs_t *regs = info->gpadc_regs;
+
+	/* Clear IRQLVL1MASK */
+	gpadc_clear_bits(regs->mirqlvl1, regs->mirqlvl1_adc);
+
+	return IRQ_HANDLED;
+}
+
+
+/**
+ * iio_basincove_gpadc_sample - do gpadc sample.
+ * @indio_dev: industrial IO GPADC device handle
+ * @ch: gpadc bit set of channels to sample, for example, set ch = (1<<0)|(1<<2)
+ *	means you are going to sample both channel 0 and 2 at the same time.
+ * @res:gpadc sampling result
+ *
+ * Returns 0 on success or an error code.
+ *
+ * This function may sleep.
+ */
+
+int iio_basincove_gpadc_sample(struct iio_dev *indio_dev,
+				int ch, struct gpadc_result *res)
+{
+	struct gpadc_info *info = iio_priv(indio_dev);
+	int i, ret;
+	u8 tmp, th, tl;
+	u8 mask;
+	struct gpadc_regs_t *regs = info->gpadc_regs;
+
+	if (!info->initialized)
+		return -ENODEV;
+
+	mutex_lock(&info->lock);
+
+	mask = MBATTEMP | MSYSTEMP | MBATT | MVIBATT | MCCTICK;
+	gpadc_clear_bits(regs->madcirq, mask);
+	gpadc_clear_bits(regs->mirqlvl1, regs->mirqlvl1_adc);
+
+	tmp = regs->gpadcreq_irqen;
+
+	for (i = 0; i < info->channel_num; i++) {
+		if (ch & (1 << i))
+			tmp |= (1 << info->gpadc_regmaps[i].cntl);
+	}
+
+	info->sample_done = 0;
+
+	ret = gpadc_busy_wait(regs);
+	if (ret) {
+		dev_err(info->dev, "GPADC is busy\n");
+		goto done;
+	}
+
+	gpadc_write(regs->gpadcreq, tmp);
+
+	ret = wait_event_timeout(info->wait, info->sample_done, HZ);
+	if (ret == 0) {
+		gpadc_dump(info);
+		ret = -ETIMEDOUT;
+		dev_err(info->dev, "sample timeout, return %d\n", ret);
+		goto done;
+	} else {
+		ret = 0;
+	}
+
+	for (i = 0; i < info->channel_num; i++) {
+		if (ch & (1 << i)) {
+			gpadc_read(info->gpadc_regmaps[i].rslth, &th);
+			gpadc_read(info->gpadc_regmaps[i].rsltl, &tl);
+			res->data[i] = ((th & 0x3) << 8) + tl;
+		}
+	}
+
+done:
+	gpadc_set_bits(regs->mirqlvl1, regs->mirqlvl1_adc);
+	gpadc_set_bits(regs->madcirq, mask);
+	mutex_unlock(&info->lock);
+	return ret;
+}
+EXPORT_SYMBOL(iio_basincove_gpadc_sample);
+
+static struct gpadc_result sample_result;
+static int chs;
+
+static ssize_t intel_basincove_gpadc_store_channel(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t size)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct gpadc_info *info = iio_priv(indio_dev);
+
+	if (sscanf(buf, "%x", &chs) != 1) {
+		dev_err(dev, "one channel argument is needed\n");
+		return -EINVAL;
+	}
+
+	if (chs < (1 << 0) || chs >= (1 << info->channel_num)) {
+		dev_err(dev, "invalid channel, should be in [0x1 - 0x1FF]\n");
+		return -EINVAL;
+	}
+
+	return size;
+}
+
+static ssize_t intel_basincove_gpadc_show_channel(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "0x%x\n", chs);
+}
+
+static ssize_t intel_basincove_gpadc_store_sample(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t size)
+{
+	int value, ret;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+
+	memset(sample_result.data, 0, sizeof(sample_result.data));
+
+	if (sscanf(buf, "%d", &value) != 1) {
+		dev_err(dev, "one argument is needed\n");
+		return -EINVAL;
+	}
+
+	if (value == 1) {
+		ret = iio_basincove_gpadc_sample(indio_dev, chs,
+						&sample_result);
+		if (ret) {
+			dev_err(dev, "sample failed\n");
+			return ret;
+		}
+	} else {
+		dev_err(dev, "input '1' to sample\n");
+		return -EINVAL;
+	}
+
+	return size;
+}
+
+static ssize_t intel_basincove_gpadc_show_result(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	int i;
+	int used = 0;
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct gpadc_info *info = iio_priv(indio_dev);
+
+	for (i = 0; i < info->channel_num; i++) {
+		used += snprintf(buf + used, PAGE_SIZE - used,
+			 "sample_result[%d] = %d\n", i, sample_result.data[i]);
+	}
+
+	return used;
+}
+
+
+static DEVICE_ATTR(channel, S_IWUSR | S_IRUGO,
+		intel_basincove_gpadc_show_channel,
+		intel_basincove_gpadc_store_channel);
+static DEVICE_ATTR(sample, S_IWUSR, NULL, intel_basincove_gpadc_store_sample);
+static DEVICE_ATTR(result, S_IRUGO, intel_basincove_gpadc_show_result, NULL);
+
+static struct attribute *intel_basincove_gpadc_attrs[] = {
+	&dev_attr_channel.attr,
+	&dev_attr_sample.attr,
+	&dev_attr_result.attr,
+	NULL,
+};
+static struct attribute_group intel_basincove_gpadc_attr_group = {
+	.name = "basincove_gpadc",
+	.attrs = intel_basincove_gpadc_attrs,
+};
+
+static int basincove_adc_read_raw(struct iio_dev *indio_dev,
+			struct iio_chan_spec const *chan,
+			int *val, int *val2, long m)
+{
+	int ret;
+	int ch = chan->channel;
+	struct gpadc_info *info = iio_priv(indio_dev);
+	struct gpadc_result res;
+
+	ret = iio_basincove_gpadc_sample(indio_dev, (1 << ch), &res);
+	if (ret) {
+		dev_err(info->dev, "sample failed\n");
+		return -EINVAL;
+	}
+
+	*val = res.data[ch];
+
+	return ret;
+}
+
+static int basincove_adc_read_all_raw(struct iio_channel *chan,
+					int *val)
+{
+	int ret;
+	int i, num = 0;
+	int ch = 0;
+	int *channels;
+	struct gpadc_info *info = iio_priv(chan->indio_dev);
+	struct gpadc_result res;
+
+	while (chan[num].indio_dev)
+		num++;
+
+	channels = kzalloc(sizeof(int) * num, GFP_KERNEL);
+	if (channels == NULL)
+		return -ENOMEM;
+
+	for (i = 0; i < num; i++) {
+		channels[i] = chan[i].channel->channel;
+		ch |= (1 << channels[i]);
+	}
+
+	ret = iio_basincove_gpadc_sample(chan->indio_dev, ch, &res);
+	if (ret) {
+		dev_err(info->dev, "sample failed\n");
+		ret = -EINVAL;
+		goto end;
+	}
+
+	for (i = 0; i < num; i++)
+		val[i] = res.data[channels[i]];
+
+end:
+	kfree(channels);
+	return ret;
+}
+
+static const struct iio_info basincove_adc_info = {
+	.read_raw = &basincove_adc_read_raw,
+	.read_all_raw = &basincove_adc_read_all_raw,
+	.driver_module = THIS_MODULE,
+};
+
+static int bcove_gpadc_probe(struct platform_device *pdev)
+{
+	int err;
+	struct gpadc_info *info;
+	struct iio_dev *indio_dev;
+	struct intel_basincove_gpadc_platform_data *pdata =
+			pdev->dev.platform_data;
+
+	if (!pdata) {
+		dev_err(&pdev->dev, "no platform data supplied\n");
+		err = -EINVAL;
+		goto out;
+	}
+
+	indio_dev = iio_device_alloc(sizeof(struct gpadc_info));
+	if (indio_dev == NULL) {
+		dev_err(&pdev->dev, "allocating iio device failed\n");
+		err = -ENOMEM;
+		goto out;
+	}
+
+	info = iio_priv(indio_dev);
+
+	mutex_init(&info->lock);
+	init_waitqueue_head(&info->wait);
+	info->dev = &pdev->dev;
+	info->irq = platform_get_irq(pdev, 0);
+	info->intr = ioremap_nocache(pdata->intr, 1);
+	if (!info->intr) {
+		dev_err(&pdev->dev, "ioremap of ADCIRQ failed\n");
+		err = -ENOMEM;
+		goto err_free;
+	}
+	info->channel_num = pdata->channel_num;
+	info->gpadc_regmaps = pdata->gpadc_regmaps;
+	info->gpadc_regs = pdata->gpadc_regs;
+
+	err = request_threaded_irq(info->irq, gpadc_isr, gpadc_threaded_isr,
+			IRQF_ONESHOT, "adc", indio_dev);
+	if (err) {
+		gpadc_dump(info);
+		dev_err(&pdev->dev, "unable to register irq %d\n", info->irq);
+		goto err_iounmap;
+	}
+
+	platform_set_drvdata(pdev, indio_dev);
+
+	indio_dev->dev.parent = &pdev->dev;
+	indio_dev->name = pdev->name;
+
+	indio_dev->channels = pdata->gpadc_channels;
+	indio_dev->num_channels = pdata->channel_num;
+	indio_dev->info = &basincove_adc_info;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+
+	err = iio_map_array_register(indio_dev, pdata->gpadc_iio_maps);
+	if (err)
+		goto err_release_irq;
+
+	err = iio_device_register(indio_dev);
+	if (err < 0)
+		goto err_array_unregister;
+
+	err = sysfs_create_group(&pdev->dev.kobj,
+			&intel_basincove_gpadc_attr_group);
+	if (err) {
+		dev_err(&pdev->dev, "Unable to export sysfs interface, error: %d\n",
+			err);
+		goto err_iio_device_unregister;
+	}
+
+	info->initialized = 1;
+
+	dev_info(&pdev->dev, "bcove adc probed\n");
+
+	return 0;
+
+err_iio_device_unregister:
+	iio_device_unregister(indio_dev);
+err_array_unregister:
+	iio_map_array_unregister(indio_dev);
+err_release_irq:
+	free_irq(info->irq, info);
+err_iounmap:
+	iounmap(info->intr);
+err_free:
+	iio_device_free(indio_dev);
+out:
+	return err;
+}
+
+static int bcove_gpadc_remove(struct platform_device *pdev)
+{
+	struct iio_dev *indio_dev = platform_get_drvdata(pdev);
+	struct gpadc_info *info = iio_priv(indio_dev);
+
+	sysfs_remove_group(&pdev->dev.kobj,
+			&intel_basincove_gpadc_attr_group);
+
+	iio_device_unregister(indio_dev);
+	iio_map_array_unregister(indio_dev);
+	free_irq(info->irq, info);
+	iounmap(info->intr);
+	iio_device_free(indio_dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int bcove_gpadc_suspend(struct device *dev)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct gpadc_info *info = iio_priv(indio_dev);
+
+	if (!mutex_trylock(&info->lock))
+		return -EBUSY;
+
+	return 0;
+}
+
+static int bcove_gpadc_resume(struct device *dev)
+{
+	struct iio_dev *indio_dev = dev_get_drvdata(dev);
+	struct gpadc_info *info = iio_priv(indio_dev);
+
+	mutex_unlock(&info->lock);
+	return 0;
+}
+#else
+#define bcove_gpadc_suspend		NULL
+#define bcove_gpadc_resume		NULL
+#endif
+
+static const struct dev_pm_ops bcove_gpadc_driver_pm_ops = {
+	.suspend	= bcove_gpadc_suspend,
+	.resume		= bcove_gpadc_resume,
+};
+
+static struct platform_driver bcove_gpadc_driver = {
+	.driver = {
+		   .name = "bcove_adc",
+		   .owner = THIS_MODULE,
+		   .pm = &bcove_gpadc_driver_pm_ops,
+		   },
+	.probe = bcove_gpadc_probe,
+	.remove = bcove_gpadc_remove,
+};
+
+static int bcove_gpadc_module_init(void)
+{
+	return platform_driver_register(&bcove_gpadc_driver);
+}
+
+static void bcove_gpadc_module_exit(void)
+{
+	platform_driver_unregister(&bcove_gpadc_driver);
+}
+
+static int bcove_adc_rpmsg_probe(struct rpmsg_channel *rpdev)
+{
+	int ret = 0;
+
+	if (rpdev == NULL) {
+		pr_err("rpmsg channel not created\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	dev_info(&rpdev->dev, "Probed bcove_gpadc rpmsg device\n");
+
+	ret = bcove_gpadc_module_init();
+
+out:
+	return ret;
+}
+
+static void bcove_adc_rpmsg_remove(struct rpmsg_channel *rpdev)
+{
+	bcove_gpadc_module_exit();
+	dev_info(&rpdev->dev, "Removed bcove_gpadc rpmsg device\n");
+}
+
+static void bcove_adc_rpmsg_cb(struct rpmsg_channel *rpdev, void *data,
+					int len, void *priv, u32 src)
+{
+	dev_warn(&rpdev->dev, "unexpected, message\n");
+
+	print_hex_dump(KERN_DEBUG, __func__, DUMP_PREFIX_NONE, 16, 1,
+		       data, len,  true);
+}
+
+static struct rpmsg_device_id bcove_adc_rpmsg_id_table[] = {
+	{ .name	= "rpmsg_bcove_adc" },
+	{ },
+};
+MODULE_DEVICE_TABLE(rpmsg, bcove_adc_rpmsg_id_table);
+
+static struct rpmsg_driver bcove_adc_rpmsg = {
+	.drv.name	= KBUILD_MODNAME,
+	.drv.owner	= THIS_MODULE,
+	.id_table	= bcove_adc_rpmsg_id_table,
+	.probe		= bcove_adc_rpmsg_probe,
+	.callback	= bcove_adc_rpmsg_cb,
+	.remove		= bcove_adc_rpmsg_remove,
+};
+
+static int __init bcove_adc_rpmsg_init(void)
+{
+	return register_rpmsg_driver(&bcove_adc_rpmsg);
+}
+
+#ifdef MODULE
+module_init(bcove_adc_rpmsg_init);
+#else
+rootfs_initcall(bcove_adc_rpmsg_init);
+#endif
+
+static void __exit bcove_adc_rpmsg_exit(void)
+{
+	return unregister_rpmsg_driver(&bcove_adc_rpmsg);
+}
+module_exit(bcove_adc_rpmsg_exit);
+
+MODULE_AUTHOR("Yang Bin<bin.yang@intel.com>");
+MODULE_DESCRIPTION("Intel Merrifield Basin Cove GPADC Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/adc/ti-ads7955.c b/drivers/iio/adc/ti-ads7955.c
new file mode 100644
index 0000000..fde230b
--- /dev/null
+++ b/drivers/iio/adc/ti-ads7955.c
@@ -0,0 +1,421 @@
+/*
+ * ADS7955 SPI ADC driver
+ *
+ * (C) Copyright 2014 Intel Corporation
+ * Author: Dave Hunt <dave.hunt@emutex.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+/*
+ * [FIXME]
+ * Notes: This version of the ti-ads7955 driver is written with a couple of
+ * workarounds for the functionality of the SPI driver on Edison at the time
+ * of writing.
+ * Issue 1: The CS is pushed low between every frame
+ * Issue 2: spi_message_add_tail() can only be called once in the driver.
+ *		Subsequent messages are ignored.
+*/
+
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/sysfs.h>
+#include <linux/spi/spi.h>
+#include <linux/regulator/consumer.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/bitops.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/trigger_consumer.h>
+#include <linux/iio/triggered_buffer.h>
+
+#include <linux/platform_data/ti-ads7955.h>
+
+#define ADS7955_EXTREF		true
+#define SPI_MAX_SPEED_HZ	20000000
+#define SPI_BITS_PER_WORD	16
+
+#define ADS7955_MANUAL_MODE	(0x1 << 12)	/* Selects Manual Mode */
+#define ADS7955_AUTO1_MODE	(0x2 << 12)	/* Selects Auto Mode 1 */
+#define ADS7955_AUTO2_MODE	(0x3 << 12)	/* Selects Auto Mode 2 */
+#define ADS7955_AUTO1_PROGRAM	(0x8 << 12)	/* Programming Auto Mode 1 */
+#define ADS7955_AUTO2_PROGRAM	(0x9 << 12)	/* Programming Auto Mode 2 */
+
+#define ADS7955_CONFIG		BIT(11)		/* program bits DI06-00 */
+#define ADS7955_AUTO1_RESET	BIT(10)		/* Reset to first channel  */
+#define ADS7955_CHANNEL(x)	((x & 0xf) << 7)/* Channel select (DI10-07) */
+
+#define ADS7955_RANGE_1		0		/* Selects 2.5V input range */
+#define ADS7955_RANGE_2		BIT(6)		/* Selects 5.0V input range */
+
+#define ADS7955_POWER_NORMAL	0		/* No Powerdown */
+#define ADS7955_POWER_DOWN	BIT(5)		/* Powerdown on last edge */
+
+#define ADS7955_GET_CONVERSION	0		/* High bits have ch index*/
+#define ADS7955_GET_GPIO	BIT(4)		/* High bits have GPIO bits */
+
+#define ADS7955_SET_READ	(ADS7955_MANUAL_MODE | ADS7955_CONFIG | \
+				ADS7955_RANGE_2 | ADS7955_POWER_NORMAL | \
+				ADS7955_GET_CONVERSION)
+
+#define ADS7955_READ_AUTO1	(ADS7955_AUTO1_MODE | ADS7955_CONFIG | \
+				ADS7955_RANGE_2 | ADS7955_POWER_NORMAL | \
+				ADS7955_GET_CONVERSION)
+
+#define ADS7955_MAX_CHAN	8
+#define ADS7955_BITS		12
+#define ADS7955_STORAGE_BITS	16
+/*
+ * Define the Reference Voltage for the board on which this ADC is used.
+ * May change depending on jumper settings or wiring configuration.
+ */
+#define ADS7955_INTREF_mV	5000
+#define SPI_MSG_MAX_LEN		20		/* 8 channels plus timestamp */
+
+#define RES_MASK(bits)	((1 << (bits)) - 1)
+
+struct ads7955_state {
+	struct spi_device	*spi;
+	struct regulator	*reg;
+	unsigned		ext_ref;
+	struct spi_transfer	ring_xfer[10];
+	struct spi_transfer	scan_single_xfer[3];
+	struct spi_message	ring_msg;
+	struct spi_message	scan_single_msg;
+	/*
+	 * DMA (thus cache coherency maintenance) requires the
+	 * transfer buffers to live in their own cache lines.
+	 */
+	__u16			rx_buf[SPI_MSG_MAX_LEN] ____cacheline_aligned;
+	__u16			tx_buf[SPI_MSG_MAX_LEN];
+};
+
+#define ADS7955_V_CHAN(index)						\
+	{								\
+		.type = IIO_VOLTAGE,					\
+		.indexed = 1,						\
+		.channel = index,					\
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),		\
+		.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),	\
+		.address = index,					\
+		.scan_index = index,					\
+		.scan_type = {						\
+			.sign = 'u',					\
+			.realbits = ADS7955_BITS,			\
+			.storagebits = ADS7955_STORAGE_BITS,		\
+			.endianness = IIO_CPU,				\
+		},							\
+	}
+
+static const struct iio_chan_spec ads7955_channels[] = {
+	ADS7955_V_CHAN(0),
+	ADS7955_V_CHAN(1),
+	ADS7955_V_CHAN(2),
+	ADS7955_V_CHAN(3),
+	ADS7955_V_CHAN(4),
+	ADS7955_V_CHAN(5),
+	ADS7955_V_CHAN(6),
+	ADS7955_V_CHAN(7),
+	IIO_CHAN_SOFT_TIMESTAMP(8),
+};
+
+/**
+ * ads7955_update_scan_mode() setup the spi transfer buffer for the scan mask
+ **/
+static int ads7955_update_scan_mode(struct iio_dev *indio_dev,
+	const unsigned long *active_scan_mask)
+{
+	struct ads7955_state *st = iio_priv(indio_dev);
+	int i, ret;
+	unsigned short channel_count;
+
+	/*
+	 * For programming the auto1 mode, we need to send two words, one to
+	 * specify program mode, and the other to give a bitmask of channels
+	 * to be read when reading the auto sequence.
+	 */
+	/*
+	 * [FIXME]
+	 * Workaround: Build up a custom SPI message containing all required
+	 * frames (including space for expected responses), and send as one
+	 * SPI messge. This is to get around the issue that the current SPI
+	 * driver only supports the first 'spi_message_add_tail' call.
+	 */
+	st->tx_buf[0] = ADS7955_AUTO1_PROGRAM;
+	st->tx_buf[1] = (unsigned short)*active_scan_mask;
+	st->tx_buf[2] = (ADS7955_SET_READ | ADS7955_POWER_DOWN);
+
+	ret = spi_sync(st->spi, &st->scan_single_msg);
+	if (ret)
+		return ret;
+
+	/*
+	* So now we've told the hardware about the channels we want to sample,
+	* now we set up the message sequence for when we're triggered.
+	*/
+	/*
+	 * [FIXME]
+	 * Workaround: Build up a custom SPI message containing all required
+	 * frames (including space for expected responses), and send as one
+	 * SPI messge. This is to get around the issue that the current SPI
+	 * driver only supports the first 'spi_message_add_tail' call.
+	 */
+	channel_count = 0;
+	for (i = 0; i < ADS7955_MAX_CHAN; i++) {
+		if (test_bit(i, active_scan_mask)) {
+			if (channel_count == 0)
+				st->tx_buf[channel_count] = (ADS7955_READ_AUTO1
+							| ADS7955_AUTO1_RESET);
+			else
+				st->tx_buf[channel_count] =
+							(ADS7955_READ_AUTO1);
+			channel_count++;
+		}
+	}
+
+	/* Put in some extra tx frames to allow us to get the
+		rx frames (behind tx by two frames) */
+	st->tx_buf[channel_count++] = (ADS7955_READ_AUTO1);
+	st->tx_buf[channel_count++] = (ADS7955_READ_AUTO1 |
+					ADS7955_POWER_DOWN);
+
+	st->ring_xfer[0].tx_buf = &st->tx_buf[0];
+	st->ring_xfer[0].rx_buf = &st->rx_buf[0];
+	st->ring_xfer[0].len = channel_count * 2;
+	spi_message_init(&st->ring_msg);
+	spi_message_add_tail(&st->ring_xfer[0], &st->ring_msg);
+	return 0;
+}
+
+/**
+ * ads7955_trigger_handler() bh of trigger launched polling to ring buffer
+ **/
+static irqreturn_t ads7955_trigger_handler(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *indio_dev = pf->indio_dev;
+	struct ads7955_state *st = iio_priv(indio_dev);
+	u8 *return_data = (u8 *)&(st->rx_buf[2]);
+	s64 time_ns = 0;
+	int ret;
+
+	ret = spi_sync(st->spi, &st->ring_msg);
+	if (ret)
+		return IRQ_HANDLED;
+
+	if (indio_dev->scan_timestamp) {
+		time_ns = iio_get_time_ns();
+		memcpy(return_data +
+			indio_dev->scan_bytes - sizeof(s64),
+			&time_ns, sizeof(time_ns));
+	}
+
+	iio_push_to_buffers(indio_dev, return_data);
+
+	iio_trigger_notify_done(indio_dev->trig);
+
+	return IRQ_HANDLED;
+}
+
+static int ads7955_scan_direct(struct ads7955_state *st, unsigned ch)
+{
+	int ret;
+
+	/*
+	 * [FIXME]
+	 * Workaround: Build up a custom SPI message containing all required
+	 * frames (including space for expected responses), and send as one
+	 * SPI messge. This is to get around the issue that the current SPI
+	 * driver only supports the first 'spi_message_add_tail' call.
+	 */
+	st->tx_buf[0] = (ADS7955_SET_READ | ADS7955_CHANNEL(ch));
+	st->tx_buf[1] = (ADS7955_SET_READ | ADS7955_CHANNEL(ch));
+	st->tx_buf[2] = (ADS7955_SET_READ | ADS7955_CHANNEL(ch) |
+						ADS7955_POWER_DOWN);
+
+	ret = spi_sync(st->spi, &st->scan_single_msg);
+	if (ret)
+		return ret;
+	return st->rx_buf[2];
+}
+
+
+static int ads7955_get_ref_voltage(struct ads7955_state *st)
+{
+	int vref;
+
+	if (st->ext_ref) {
+		vref = regulator_get_voltage(st->reg);
+		if (vref < 0)
+			return vref;
+
+		return vref / 1000;
+	} else {
+		return ADS7955_INTREF_mV;
+	}
+}
+
+static int ads7955_read_raw(struct iio_dev *indio_dev,
+			   struct iio_chan_spec const *chan,
+			   int *val,
+			   int *val2,
+			   long m)
+{
+	int ret;
+	struct ads7955_state *st = iio_priv(indio_dev);
+
+	switch (m) {
+	case IIO_CHAN_INFO_RAW:
+		mutex_lock(&indio_dev->mlock);
+		if (indio_dev->currentmode == INDIO_BUFFER_TRIGGERED)
+			ret = -EBUSY;
+		else
+			ret = ads7955_scan_direct(st, chan->address);
+		mutex_unlock(&indio_dev->mlock);
+		if (ret < 0)
+			return ret;
+
+		*val = ret & RES_MASK(ADS7955_BITS);
+		return IIO_VAL_INT;
+	case IIO_CHAN_INFO_SCALE:
+		switch (chan->type) {
+		case IIO_VOLTAGE:
+			*val = ads7955_get_ref_voltage(st);
+			*val2 = chan->scan_type.realbits;
+			return IIO_VAL_FRACTIONAL_LOG2;
+		default:
+			return -EINVAL;
+		}
+	}
+	return -EINVAL;
+}
+
+static const struct iio_info ads7955_info = {
+	.read_raw = &ads7955_read_raw,
+	.update_scan_mode = ads7955_update_scan_mode,
+	.driver_module = THIS_MODULE,
+};
+
+static int ads7955_probe(struct spi_device *spi)
+{
+	struct ads7955_platform_data *pdata = spi->dev.platform_data;
+	struct ads7955_state *st;
+	struct iio_dev *indio_dev = iio_device_alloc(sizeof(*st));
+	int ret;
+
+	if (indio_dev == NULL)
+		return -ENOMEM;
+
+	st = iio_priv(indio_dev);
+
+	if (pdata && pdata->ext_ref)
+		st->ext_ref = ADS7955_EXTREF;
+
+	if (st->ext_ref) {
+		st->reg = regulator_get(&spi->dev, "vref");
+		if (IS_ERR(st->reg)) {
+			ret = PTR_ERR(st->reg);
+			goto error_free;
+		}
+		ret = regulator_enable(st->reg);
+		if (ret)
+			goto error_put_reg;
+	}
+
+	spi_set_drvdata(spi, indio_dev);
+
+	st->spi = spi;
+
+	indio_dev->name = spi_get_device_id(spi)->name;
+	indio_dev->dev.parent = &spi->dev;
+	indio_dev->modes = INDIO_DIRECT_MODE;
+	indio_dev->channels = ads7955_channels;
+	indio_dev->num_channels = ARRAY_SIZE(ads7955_channels);
+	indio_dev->info = &ads7955_info;
+
+	/*
+	 * Setup default message
+	 * [FIXME]
+	 * Workaround:  Send each frame as 16 bits to get over the fact that
+	 * the current SPI hardware pulls CS low between every frame.
+	 */
+	spi->bits_per_word = SPI_BITS_PER_WORD;
+	spi->max_speed_hz = SPI_MAX_SPEED_HZ;
+	spi_setup(spi);
+
+	st->scan_single_xfer[0].tx_buf = &st->tx_buf[0];
+	st->scan_single_xfer[0].rx_buf = &st->rx_buf[0];
+	st->scan_single_xfer[0].len = 6;
+
+	spi_message_init(&st->scan_single_msg);
+	spi_message_add_tail(&st->scan_single_xfer[0], &st->scan_single_msg);
+
+	ret = iio_triggered_buffer_setup(indio_dev, NULL,
+			&ads7955_trigger_handler, NULL);
+	if (ret) {
+		dev_warn(&indio_dev->dev,
+			"Failed to set up iio_triggered_buffer_setup\n");
+		goto error_disable_reg;
+	}
+
+	ret = iio_device_register(indio_dev);
+	if (ret)
+		goto error_cleanup_ring;
+
+	return 0;
+
+error_cleanup_ring:
+	iio_triggered_buffer_cleanup(indio_dev);
+error_disable_reg:
+	if (st->ext_ref)
+		regulator_disable(st->reg);
+error_put_reg:
+	if (st->ext_ref)
+		regulator_put(st->reg);
+error_free:
+	iio_device_free(indio_dev);
+
+	return ret;
+}
+
+static int ads7955_remove(struct spi_device *spi)
+{
+	struct iio_dev *indio_dev = spi_get_drvdata(spi);
+	struct ads7955_state *st = iio_priv(indio_dev);
+
+	iio_device_unregister(indio_dev);
+	iio_triggered_buffer_cleanup(indio_dev);
+	if (st->ext_ref) {
+		regulator_disable(st->reg);
+		regulator_put(st->reg);
+	}
+	iio_device_free(indio_dev);
+
+	return 0;
+}
+
+static const struct spi_device_id ads7955_id[] = {
+	{"ads7955", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(spi, ads7955_id);
+
+static struct spi_driver ads7955_driver = {
+	.driver = {
+		.name	= "ads7955",
+		.owner	= THIS_MODULE,
+	},
+	.probe		= ads7955_probe,
+	.remove		= ads7955_remove,
+	.id_table	= ads7955_id,
+};
+module_spi_driver(ads7955_driver);
+
+MODULE_AUTHOR("Dave Hunt <dave.hunt@emutex.com>");
+MODULE_DESCRIPTION("Texas Instruments ADS7955 ADC");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/industrialio-core.c b/drivers/iio/industrialio-core.c
index acc911a..26442f5 100644
--- a/drivers/iio/industrialio-core.c
+++ b/drivers/iio/industrialio-core.c
@@ -69,6 +69,7 @@ static const char * const iio_chan_type_name_spec[] = {
 	[IIO_ALTVOLTAGE] = "altvoltage",
 	[IIO_CCT] = "cct",
 	[IIO_PRESSURE] = "pressure",
+	[IIO_RESISTANCE] = "resistance",
 	[IIO_HUMIDITYRELATIVE] = "humidityrelative",
 };
 
diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c
index 4fc88e6..5584188 100644
--- a/drivers/iio/inkern.c
+++ b/drivers/iio/inkern.c
@@ -415,6 +415,48 @@ void iio_channel_release_all(struct iio_channel *channels)
 }
 EXPORT_SYMBOL_GPL(iio_channel_release_all);
 
+int iio_channel_get_num(const struct iio_channel *chan)
+{
+	int num = 0;
+
+	if (chan == NULL)
+		return -ENODEV;
+
+	while (chan[num].indio_dev)
+		num++;
+
+	return num;
+}
+EXPORT_SYMBOL_GPL(iio_channel_get_num);
+
+int iio_channel_get_name(const struct iio_channel *chan, char **chan_name)
+{
+	int i = 0;
+	struct iio_map_internal *c = NULL;
+
+	if (chan == NULL)
+		return -ENODEV;
+
+	if (chan_name == NULL)
+		return -EINVAL;
+
+	while (chan[i].indio_dev) {
+		mutex_lock(&iio_map_list_lock);
+		list_for_each_entry(c, &iio_map_list, l) {
+			if (strcmp(chan[i].channel->datasheet_name,
+				c->map->adc_channel_label) != 0)
+				continue;
+			strcpy(chan_name[i], c->map->consumer_channel);
+			break;
+		}
+		mutex_unlock(&iio_map_list_lock);
+		i++;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(iio_channel_get_name);
+
 static int iio_channel_read(struct iio_channel *chan, int *val, int *val2,
 	enum iio_chan_info_enum info)
 {
@@ -445,6 +487,24 @@ err_unlock:
 }
 EXPORT_SYMBOL_GPL(iio_read_channel_raw);
 
+int iio_read_channel_all_raw(struct iio_channel *chan, int *val)
+{
+	int ret;
+
+	mutex_lock(&chan->indio_dev->info_exist_lock);
+	if (chan->indio_dev->info == NULL) {
+		ret = -ENODEV;
+		goto err_unlock;
+	}
+
+	ret = chan->indio_dev->info->read_all_raw(chan, val);
+err_unlock:
+	mutex_unlock(&chan->indio_dev->info_exist_lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(iio_read_channel_all_raw);
+
 static int iio_convert_raw_to_processed_unlocked(struct iio_channel *chan,
 	int raw, int *processed, unsigned int scale)
 {
diff --git a/include/linux/iio/consumer.h b/include/linux/iio/consumer.h
index 2752b1f..b50b59c 100644
--- a/include/linux/iio/consumer.h
+++ b/include/linux/iio/consumer.h
@@ -183,4 +183,7 @@ int iio_read_channel_scale(struct iio_channel *chan, int *val,
 int iio_convert_raw_to_processed(struct iio_channel *chan, int raw,
 	int *processed, unsigned int scale);
 
+int iio_read_channel_all_raw(struct iio_channel *chan, int *val);
+int iio_channel_get_name(const struct iio_channel *chan, char **chan_name);
+int iio_channel_get_num(const struct iio_channel *chan);
 #endif
diff --git a/include/linux/iio/iio.h b/include/linux/iio/iio.h
index 75a8a20..81879b8 100644
--- a/include/linux/iio/iio.h
+++ b/include/linux/iio/iio.h
@@ -324,6 +324,9 @@ struct iio_info {
 			int *val2,
 			long mask);
 
+	int (*read_all_raw)(struct iio_channel *chan,
+			int *val);
+
 	int (*write_raw)(struct iio_dev *indio_dev,
 			 struct iio_chan_spec const *chan,
 			 int val,
diff --git a/include/linux/iio/types.h b/include/linux/iio/types.h
index 084d882..fd6946f 100644
--- a/include/linux/iio/types.h
+++ b/include/linux/iio/types.h
@@ -29,6 +29,7 @@ enum iio_chan_type {
 	IIO_ALTVOLTAGE,
 	IIO_CCT,
 	IIO_PRESSURE,
+	IIO_RESISTANCE,
 	IIO_HUMIDITYRELATIVE,
 };
 
diff --git a/include/linux/platform_data/ti-ads7955.h b/include/linux/platform_data/ti-ads7955.h
new file mode 100644
index 0000000..da1451e
--- /dev/null
+++ b/include/linux/platform_data/ti-ads7955.h
@@ -0,0 +1,21 @@
+/*
+ * ADS7955 SPI ADC driver
+ *
+ * (C) Copyright 2014 Intel Corporation
+ * Author: Dave Hunt <dave.hunt@emutex.com>
+ *
+ * Licensed under the GPL-2.
+ */
+
+#ifndef __LINUX_PLATFORM_DATA_TI_ADS7955_H__
+#define __LINUX_PLATFORM_DATA_TI_ADS7955_H__
+
+/**
+ * struct ads7955_platform_data - Platform data for the ads7955 ADC driver
+ * @ext_ref: Whether to use an external reference voltage.
+ **/
+struct ads7955_platform_data {
+	bool ext_ref;
+};
+
+#endif /* __LINUX_PLATFORM_DATA_TI_ADS7955_H__ */
diff --git a/include/linux/sfi.h b/include/linux/sfi.h
index d9b436f..3a07cf1 100644
--- a/include/linux/sfi.h
+++ b/include/linux/sfi.h
@@ -75,6 +75,7 @@
 #define SFI_SIG_WAKE		"WAKE"
 #define SFI_SIG_DEVS		"DEVS"
 #define SFI_SIG_GPIO		"GPIO"
+#define SFI_SIG_OEMB		"OEMB"
 
 #define SFI_SIGNATURE_SIZE	4
 #define SFI_OEM_ID_SIZE		6
@@ -88,6 +89,9 @@
 #define SFI_GET_NUM_ENTRIES(ptable, entry_type) \
 	((ptable->header.len - sizeof(struct sfi_table_header)) / \
 	(sizeof(entry_type)))
+
+#define SPID_FRU_SIZE	10
+
 /*
  * Table structures must be byte-packed to match the SFI specification,
  * as they are provided by the BIOS.
@@ -156,6 +160,7 @@ struct sfi_device_table_entry {
 #define SFI_DEV_TYPE_UART	2
 #define SFI_DEV_TYPE_HSI	3
 #define SFI_DEV_TYPE_IPC	4
+#define SFI_DEV_TYPE_SD		5
 
 	u8	host_num;	/* attached to host 0, 1...*/
 	u16	addr;
-- 
1.7.5.4

