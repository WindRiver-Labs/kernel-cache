From c48072bffcf325e78c298f48cc57b77d95a3b4b9 Mon Sep 17 00:00:00 2001
From: Ralf Baechle <ralf.baechle@windriver.com>
Date: Fri, 14 Aug 2009 03:19:03 +0100
Subject: [PATCH] MIPS: Live snapshotting fixes for Raza

o snap.c: Live snapshots may trigger cause memory accesses beyond the end
   of memory.  The accesses are harmless but can crash the system if the
   access has any side effects.  As for several other systems before we
   avoid this sort of problem which also can be caused by some PCI cards
   etc. by leaving the last page of memory of each memory region.
 o ksnap.c: Do not dump reserved pages.  Reserved pages might have side
   effects so we better don't touch them.
 o ksnap.c: To avoid accesses beyond the end of physical memory copy the
   last page of an extend being written into a dump into a temporary buffer
   before writing it to the dump file.
 o ksnap.c: There was a bug that if the last page of a populated zone was
   not reserved the entire range of contiguous pages this page belongs to,
   was not getting remembered to be written to disk.

Signed-off-by: Ralf Baechle <ralf.baechle@windriver.com>
---
 arch/mips/rmi/ptr/setup.c |   15 +++++++++------
 kernel/power/ksnap.c      |   33 ++++++++++++++++++++++++++-------
 2 files changed, 35 insertions(+), 13 deletions(-)

diff --git a/arch/mips/rmi/ptr/setup.c b/arch/mips/rmi/ptr/setup.c
index 9542fad..d26723f 100644
--- a/arch/mips/rmi/ptr/setup.c
+++ b/arch/mips/rmi/ptr/setup.c
@@ -1151,10 +1151,10 @@ static void prom_add_memory(void)
 					start = exc_end;
 					continue;
 				}
-				if (prom_map.map[i].type == BOOT_MEM_RAM){
+				if (prom_map.map[i].type == BOOT_MEM_RAM) {
 					add_memory_region(start,
-									  exc_start-start, 
-									  (long)prom_map.map[i].type);
+						  exc_start - start - 0x1000,
+						  (long)prom_map.map[i].type);
 					start = exc_end;
 				}
 			} 
@@ -1165,15 +1165,18 @@ static void prom_add_memory(void)
 		}
 		if (start != end)
 			if (prom_map.map[i].type == BOOT_MEM_RAM)
-				add_memory_region(start, end-start, (long)prom_map.map[i].type);
+				add_memory_region(start,
+						  end - start - 0x1000,
+						  (long)prom_map.map[i].type);
 	}
 	
 	return;
 	
  use_default:
 	printk("Using default physical memory map\n");
-	add_memory_region (DEF_PHYMEM_START_ADDR, DEF_PHYMEM_SIZE, 
-						(long)BOOT_MEM_RAM); // 255m@1m
+	add_memory_region(DEF_PHYMEM_START_ADDR,	/* 255M @ 1M */
+			  DEF_PHYMEM_SIZE - 0x1000,
+			  (long)BOOT_MEM_RAM);
 	xlr_loader_support = 0;
 }
 
diff --git a/kernel/power/ksnap.c b/kernel/power/ksnap.c
index 5dfa147..d0b5439 100644
--- a/kernel/power/ksnap.c
+++ b/kernel/power/ksnap.c
@@ -283,19 +283,17 @@ static int ext_create(void)
 
 	for_each_populated_zone(zone) {
 		unsigned long start_pfn, end_pfn;
-		unsigned long ext_start, invalid;
+		unsigned long ext_start;
 
 		start_pfn = zone->zone_start_pfn;
 		end_pfn = start_pfn + zone->spanned_pages;
 
 		ext_start = -1;
-		invalid = 0;
 		for (pfn = start_pfn; pfn < end_pfn; pfn++) {
-			if (!pfn_valid(pfn))
-				invalid++;
-			if (pfn_valid(pfn)) {
-				if (ext_start == -1)
+			if (pfn_valid(pfn) && !PageReserved(pfn_to_page(pfn))) {
+				if (ext_start == -1) {
 					ext_start = pfn;
+				}
 			} else {
 				if (ext_start == -1)
 					continue;
@@ -307,6 +305,11 @@ static int ext_create(void)
 				ext_start = -1;
 			}
 		}
+		if (ext_start) {	/* Deal with possible remainder  */
+			res = ext_add(ext_start, pfn - 1);
+			if (res)
+				goto out_free;
+		}
 		i++;
 	}
 
@@ -404,6 +407,8 @@ static int dump_seek(struct file *file, loff_t off)
         return 0;
 }
 
+static char buf[PAGE_SIZE];
+
 static int dump_write_extends(struct file *file)
 {
 	struct extend *ext;
@@ -411,6 +416,8 @@ static int dump_write_extends(struct file *file)
 	int ret;
 
 	list_for_each_entry(ext, &ext_list, ext_list) {
+		unsigned long start, size;
+
 		if (!ext->ext_addr)
 			continue;
 
@@ -420,7 +427,19 @@ static int dump_write_extends(struct file *file)
 			return ret;
 		}
 
-		ret = dump_write(file, ext->ext_addr, ph->p_filesz);
+		start = (unsigned long) ext->ext_addr;
+		size = ph->p_filesz;
+
+		if (size > PAGE_SIZE) {
+			ret = dump_write(file, (void *)start, size - PAGE_SIZE);
+			if (ret)
+				return ret;
+
+			size %= PAGE_SIZE;
+		}
+
+		memcpy(buf, (void *) (start + PAGE_SIZE - PAGE_SIZE), size);
+		ret = dump_write(file, buf, size);
 		if (ret)
 			return ret;
 	}
-- 
1.6.0.4

