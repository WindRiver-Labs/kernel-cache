From aceaf9b5fc3ff25a3bd307aa1c5b83335fae094a Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Wed, 17 Dec 2008 19:04:15 +0800
Subject: [PATCH] rmi xlr sec engine driver

RMI XLR Security engine driver.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 drivers/char/Kconfig                            |    3 +-
 drivers/char/Makefile                           |    2 +
 drivers/char/rmisec/Kconfig                     |   14 +
 drivers/char/rmisec/Makefile                    |    7 +
 drivers/char/rmisec/linux/Makefile              |   13 +
 drivers/char/rmisec/linux/device.c              |  621 ++++
 drivers/char/rmisec/linux/rmisec.h              |   49 +
 drivers/char/rmisec/linux/rmisecio.h            |   53 +
 drivers/char/rmisec/phxdrv/Makefile             |   13 +
 drivers/char/rmisec/phxdrv/ecc_microcode_data.h |  368 ++
 drivers/char/rmisec/phxdrv/phxcmd.c             | 4041 +++++++++++++++++++++++
 drivers/char/rmisec/phxdrv/phxcrypto.c          |  682 ++++
 drivers/char/rmisec/phxdrv/phxdesc.h            | 3122 +++++++++++++++++
 drivers/char/rmisec/phxdrv/phxdev.c             |  913 +++++
 drivers/char/rmisec/phxdrv/phxdrv.h             |  849 +++++
 drivers/char/rmisec/phxdrv/phxsec.h             |  867 +++++
 drivers/char/rmisec/phxdrv/proc.c               |  449 +++
 include/linux/crypto.h                          |    5 +
 18 files changed, 12070 insertions(+), 1 deletions(-)
 create mode 100644 drivers/char/rmisec/Kconfig
 create mode 100644 drivers/char/rmisec/Makefile
 create mode 100644 drivers/char/rmisec/linux/Makefile
 create mode 100644 drivers/char/rmisec/linux/device.c
 create mode 100644 drivers/char/rmisec/linux/rmisec.h
 create mode 100644 drivers/char/rmisec/linux/rmisecio.h
 create mode 100644 drivers/char/rmisec/phxdrv/Makefile
 create mode 100644 drivers/char/rmisec/phxdrv/ecc_microcode_data.h
 create mode 100644 drivers/char/rmisec/phxdrv/phxcmd.c
 create mode 100644 drivers/char/rmisec/phxdrv/phxcrypto.c
 create mode 100644 drivers/char/rmisec/phxdrv/phxdesc.h
 create mode 100644 drivers/char/rmisec/phxdrv/phxdev.c
 create mode 100644 drivers/char/rmisec/phxdrv/phxdrv.h
 create mode 100644 drivers/char/rmisec/phxdrv/phxsec.h
 create mode 100644 drivers/char/rmisec/phxdrv/proc.c

diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index 2438be1..c1ba114 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -1126,5 +1126,6 @@ config DEVPORT
 
 source "drivers/s390/char/Kconfig"
 
-endmenu
+source "drivers/char/rmisec/Kconfig"
 
+endmenu
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 1362d37..6c99c91 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -106,6 +106,8 @@ obj-$(CONFIG_AGP)		+= agp/
 obj-$(CONFIG_PCMCIA)		+= pcmcia/
 obj-$(CONFIG_IPMI_HANDLER)	+= ipmi/
 
+obj-$(CONFIG_RMISEC)		+= rmisec/
+
 obj-$(CONFIG_HANGCHECK_TIMER)	+= hangcheck-timer.o
 obj-$(CONFIG_TCG_TPM)		+= tpm/
 
diff --git a/drivers/char/rmisec/Kconfig b/drivers/char/rmisec/Kconfig
new file mode 100644
index 0000000..ee81779
--- /dev/null
+++ b/drivers/char/rmisec/Kconfig
@@ -0,0 +1,14 @@
+#
+# RMI security driver configuration
+#
+
+menu "RMI security subsystem driver configuration"
+	depends on RMI_PHOENIX!=n
+
+config RMISEC
+	boolean "RMI security subsystem driver"
+	help
+	  Enables support for RMI built-in security accelerator
+
+endmenu
+
diff --git a/drivers/char/rmisec/Makefile b/drivers/char/rmisec/Makefile
new file mode 100644
index 0000000..256a56d
--- /dev/null
+++ b/drivers/char/rmisec/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for the linux Raza Microelectronics Security Engine subsystem.
+#
+#
+
+obj-$(CONFIG_RMISEC) += linux/
+obj-$(CONFIG_RMISEC) += phxdrv/
diff --git a/drivers/char/rmisec/linux/Makefile b/drivers/char/rmisec/linux/Makefile
new file mode 100644
index 0000000..75779be
--- /dev/null
+++ b/drivers/char/rmisec/linux/Makefile
@@ -0,0 +1,13 @@
+#******************************************************************************
+#
+#  This Driver software is distributed as is, without any warranty of any kind,
+#  either express or implied as further specified in the GNU Public License.
+#  This software may be used and distributed according to the terms of the
+#  GNU Public License.
+#
+#******************************************************************************
+#
+# Device makefile for LINUX
+# 
+
+obj-y	 += device.o
diff --git a/drivers/char/rmisec/linux/device.c b/drivers/char/rmisec/linux/device.c
new file mode 100644
index 0000000..2a822f7
--- /dev/null
+++ b/drivers/char/rmisec/linux/device.c
@@ -0,0 +1,621 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+
+#include <asm/errno.h>
+#include <asm/uaccess.h>
+
+#include <asm/rmi/debug.h>
+#include <asm/rmi/msgring.h>
+#include <asm/rmi/devices.h>
+
+#include "rmisec.h"
+#include "rmisecio.h"
+#include "../phxdrv/phxdesc.h"
+#include "../phxdrv/phxdrv.h"
+
+extern int xlr_loader_support;
+extern int xlr_loader_sharedcore;
+
+static int rmisec_ioctl(struct inode *inode, struct file *filp,
+						unsigned int cmd, unsigned long arg);
+static long rmisec_compat_ioctl(struct file *filp, unsigned int cmd,
+								unsigned long arg);
+static ssize_t rmisec_write(struct file *file, const char *buf, size_t count,
+							loff_t * ppos);
+static int rmisec_open(struct inode *inode, struct file *filp);
+static int rmisec_release(struct inode *inode, struct file *filp);
+
+
+/*
+ *  PHXSEC's set of file operations.  This is the data structure that
+ *  will be passed when we call register_chrdev().
+ */
+
+static struct file_operations rmisec_file_ops = {
+	.owner = THIS_MODULE,
+	.ioctl = rmisec_ioctl,
+	.write = rmisec_write,
+	.open = rmisec_open,
+	.release = rmisec_release,
+	.compat_ioctl = rmisec_compat_ioctl,
+};
+
+dev_info_t rmisec_device;
+
+int phxsec_major_number = -1;
+
+unsigned short Version = 0x0100;	/* Upper byte is major, lower byte is Minor */
+
+/*
+static char *version_string="%s driver v%x.%02x";
+*/
+
+void (*rmisec_callback) (void);
+
+
+/**************************************************************************
+ *
+ *  FUNCTION:      rmisec_interrupt_proc
+ *
+ *  CALLED FROM:   
+ *
+ *  PARAMETERS:
+ *
+ *  DESCRIPTION:
+ *                 This function receives the completion signal from the 
+ *                 device.  At completion time, it marks the time and 
+ *                 schedules the bottom half.
+ *
+ *  RETURNS:
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+void rmisec_interrupt_proc(int irq, void *pvoid, struct pt_regs *regs)
+{
+}
+
+/*
+ * Initialize and return all devices.
+ * Return the number of initialized devices.
+ */
+/**************************************************************************
+ *
+ *  FUNCTION:      
+ *
+ *  CALLED FROM:   
+ *
+ *  PARAMETERS:    
+ * 
+ *  DESCRIPTION:
+ *
+ *
+ *
+ *  RETURNS:
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+static int rmisec_init_device(int max_ring_descriptors)
+{
+	phxsec_status_t status;
+
+	dev_info_pt devinfo_p = &rmisec_device;
+
+	dbg_msg(" PHXSEC: %s \n ", __func__);
+
+	status = phxsec_init_device(RMI_SECENG_DEV_ID,
+								PHOENIX_IO_SECURITY_OFFSET,
+								RMI_SECENG_IRQ,
+								max_ring_descriptors, devinfo_p);
+
+	if (status != PHXSEC_STATUS_SUCCESS) {
+		dbg_msg("InitDevice Failed (%ld)\n", (unsigned long) status);
+		return -ENOMEM;
+	}
+
+#ifdef PHX_INIT_SELFTEST
+	status = Selftest(pDevice->Context, pDev);
+#endif
+
+	devinfo_p->dev_status = status;
+
+	/*
+	 *  Register the device -- ask for a dnynamicly assigned major number
+	 */
+	phxsec_major_number = register_chrdev(XLR_CRYPTO_MAJOR,
+										  PHXSEC_DEVICE_NAME,
+										  &rmisec_file_ops);
+	if (phxsec_major_number < 0) {	/* Bound? */
+		printk("PHXSEC:  register_chrdev() failed\n");
+		return -ENOMEM;
+	}
+	printk("RMISEC device registered with major number = %d\n",
+		   XLR_CRYPTO_MAJOR);
+	return (0);
+}
+
+void *rmisec_get_context(unsigned int devid)
+{
+	dev_info_pt devinfo_p = &rmisec_device;
+	return (void *) devinfo_p->context;
+}
+
+#ifdef RMISEC_CALLBACK_CODE
+/* *********************************************************
+   ***   NOT FUNCTIONAL                                  ***
+   *********************************************************
+*/
+
+/*
+ * Use an Intermediate ISR callback because of
+ * differences in parameters. For ISR and callback
+ * instead of saving the SRL functions we just call
+ * them directly.
+ */
+/**************************************************************************
+ *
+ *  FUNCTION:      
+ *
+ *  CALLED FROM:   
+ *
+ *  PARAMETERS:    
+ * 
+ *  DESCRIPTION:
+ *
+ *
+ *
+ *  RETURNS:
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+void rmisec_inter_callback(int irq, void *param, struct pt_regs *regs)
+{
+	dev_info_pt devinfo_p = (dev_info_pt) param;
+
+	if (devinfo_p->context == 0)
+		return;
+	phxsec_ISR(devinfo_p->context);
+}
+
+
+
+/*
+ * Redirection of callback to make it fit
+ * 
+ */
+/**************************************************************************
+ *
+ *  FUNCTION:      
+ *
+ *  CALLED FROM:   
+ *
+ *  PARAMETERS:    
+ * 
+ *  DESCRIPTION:
+ *
+ *
+ *
+ *  RETURNS:
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+void rmisec_callback_dpc(void *param)
+{
+	dev_info_pt devinfo_p = (dev_info_pt) param;
+
+	if (devinfo_p->context == 0)
+		return;
+	phxsec_ISRCallback(devinfo_p->context);
+}
+
+#endif /* RMISEC_CALLBACK_CODE */
+
+#ifdef RMISEC_CONTROL_CODE
+/* *********************************************************
+   ***   NOT FUNCTIONAL                                  ***
+   *********************************************************
+*/
+
+/**************************************************************************
+ *
+ *  FUNCTION:      
+ *
+ *  CALLED FROM:   
+ *
+ *  PARAMETERS:    
+ * 
+ *  DESCRIPTION:
+ *
+ *
+ *
+ *  RETURNS:
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+int rmisec_fail_device()
+{
+	dev_info_pt devinfo_p = &rmisec_device;
+
+	devinfo_p->dev_status = -1;
+	phxsec_DisableInterrupt(devinfo_p->context);
+	return (0);
+}
+
+/**************************************************************************
+ *
+ *  FUNCTION:      
+ *
+ *  CALLED FROM:   
+ *
+ *  PARAMETERS:    
+ * 
+ *  DESCRIPTION:
+ *
+ *
+ *
+ *  RETURNS:
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+int rmisec_get_device_status(dev_info_pt devinfo_p)
+{
+	return devinfo_p->dev_status;
+}
+
+
+/**************************************************************************
+ *
+ *  FUNCTION:      
+ *
+ *  CALLED FROM:   
+ *
+ *  PARAMETERS:    
+ * 
+ *  DESCRIPTION:
+ *
+ *
+ *
+ *  RETURNS:
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+int rmisec_set_device_status(dev_info_pt devinfo_p, int status)
+{
+	return (devinfo_p->dev_status = status);
+}
+
+#endif /* RMISEC_CONTROL_CODE */
+
+
+/**************************************************************************
+ *
+ *  FUNCTION:      
+ *
+ *  CALLED FROM:   
+ *
+ *  PARAMETERS:    
+ * 
+ *  DESCRIPTION:
+ *
+ *
+ *
+ *  RETURNS:
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+static int
+rmisec_ioctl(struct inode *inode,
+			 struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	dev_info_pt devinfo_p = &rmisec_device;
+	int status = 0;
+
+	switch (cmd) {
+
+		case RMISEC_ENCRYPT_DECRYPT_FUNC:
+			{
+				phxsec_io_t sym_op;
+
+#ifdef SYM_DEBUG
+				printk("\tPHXSEC:  rmisec_ioctl():  RMISEC_ENCRYPT_DECRYPT_FUNC\n");
+#endif
+
+				if (copy_from_user(&sym_op, (void *) arg, sizeof(sym_op)))
+					return (-EFAULT);
+
+				status =
+					phxsec_CipherDigestUserOp(devinfo_p->context, &sym_op);
+			}
+			break;
+
+		case RMISEC_DIGEST_FUNC:
+			{
+				phxsec_io_t sym_op;
+
+#ifdef SYM_DEBUG
+				printk("\tPHXSEC:  rmisec_ioctl():  RMISEC_DIGEST_FUNC\n");
+#endif
+
+				if (copy_from_user(&sym_op, (void *) arg, sizeof(sym_op)))
+					return (-EFAULT);
+
+				status =
+					phxsec_CipherDigestUserOp(devinfo_p->context, &sym_op);
+			}
+			break;
+
+		case RMISEC_KEY_SETUP_FUNC:
+			{
+				phxsec_key_io_t key_op;
+
+#ifdef SYM_DEBUG
+				printk("\tPHXSEC:  rmisec_ioctl():  RMISEC_KEY_SETUP_FUNC\n");
+#endif
+
+				if (copy_from_user(&key_op, (void *) arg, sizeof(key_op)))
+					return (-EFAULT);
+				status = phxsec_PublicKeyUserOp(devinfo_p->context, &key_op);
+			}
+			break;
+
+#ifdef RMISEC_IOCTL_BELLS
+		case RMISEC_STATS_FUNC:
+			status = EINVAL;
+			break;
+
+
+		case RMISEC_SELFTEST:
+			status = EINVAL;
+#endif /* RMISEC_IOCTL_BELLS */
+
+		case RMISEC_ECC_FUNC:
+			{
+				phxsec_key_io_t key_op;
+
+#ifdef SYM_DEBUG
+				printk("\tPHXSEC:  rmisec_ioctl():  RMISEC_KEY_SETUP_FUNC\n");
+#endif
+
+				if (copy_from_user(&key_op, (void *) arg, sizeof(key_op)))
+					return (-EFAULT);
+				status = phxsec_ecc(devinfo_p->context, &key_op);
+			}
+			break;
+
+		default:
+			status = EINVAL;
+			printk("%s: Unknown IOCTL command %x\n", __func__, cmd);
+	}
+
+	return status;
+}
+
+long rmisec_compat_ioctl(struct file *filp, unsigned int cmd,
+						 unsigned long arg)
+{
+	unsigned long ret = -1;
+	ret = rmisec_ioctl(NULL, filp, cmd, arg);
+	if (ret) {
+		printk("rmisec_ioctl returned with an error %lx", ret);
+		return -ENOIOCTLCMD;
+	}
+	return ret;
+}
+
+
+/**************************************************************************
+ *
+ *  FUNCTION:      
+ *
+ *  CALLED FROM:   
+ *
+ *  PARAMETERS:    
+ * 
+ *  DESCRIPTION:
+ *
+ *
+ *
+ *  RETURNS:
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+static ssize_t
+rmisec_write(struct file *file, const char *buf, size_t count, loff_t * ppos)
+{
+	phxsec_io_pt op;
+	dev_info_pt devinfo_p = &rmisec_device;
+	int status = 0;
+
+	op = (phxsec_io_pt) buf;
+
+	/* we expect to find a 'long' as the first element in struct */
+	switch (op->command) {
+		case RMISEC_ENCRYPT_DECRYPT_FUNC:
+		case RMISEC_DIGEST_FUNC:
+			{
+				phxsec_io_t sym_op;
+
+
+				if (copy_from_user(&sym_op, (void *) buf, sizeof(sym_op))) {
+					printk
+						("RMISEC_WRITE: copy_from_user(CipherDigest) !FAILED!\n");
+					return (-EFAULT);
+				}
+				status =
+					phxsec_CipherDigestUserOp(devinfo_p->context, &sym_op);
+			}
+			break;
+
+		case RMISEC_KEY_SETUP_FUNC:
+			{
+				phxsec_key_io_t key_op;
+
+				if (copy_from_user(&key_op, (void *) buf, sizeof(key_op))) {
+					printk
+						("RMISEC_WRITE:  copy_from_user(ModExp) !FAILED! \n");
+					return (-EFAULT);
+				}
+				status = phxsec_PublicKeyUserOp(devinfo_p->context, &key_op);
+			}
+			break;
+
+		case RMISEC_ECC_FUNC:
+			{
+				phxsec_key_io_t key_op;
+				phxsec_key_io_pt key_op_p;
+
+				if (copy_from_user(&key_op, (void *) buf, sizeof(key_op))) {
+					printk("RMISEC_WRITE:  copy_from_user(ECC) !FAILED! \n");
+					return (-EFAULT);
+				}
+				status = phxsec_ecc(devinfo_p->context, &key_op);
+				key_op_p = (phxsec_key_io_pt) buf;
+				put_user(key_op.key.ECC_params.r_x.bignum_length,
+						 &key_op_p->key.ECC_params.r_x.bignum_length);
+				put_user(key_op.key.ECC_params.r_y.bignum_length,
+						 &key_op_p->key.ECC_params.r_y.bignum_length);
+				put_user(key_op.key.ECC_params.result,
+						 &key_op_p->key.ECC_params.result);
+			}
+			break;
+
+		default:
+			printk("RMISEC_WRITE: !FAILED! Unknown Command=%ld \n",
+				   (unsigned long) op->command);
+			status = EINVAL;
+	}
+
+	return status;
+}
+
+
+
+#ifdef CONFIG_PHOENIX_GMAC_NAPI
+extern int xlr_napi;
+extern int xlr_napi_ready;
+#endif /* CONFIG_PHOENIX_GMAC_NAPI */
+
+
+/**************************************************************************
+ *
+ *  FUNCTION:      
+ *
+ *  CALLED FROM:   
+ *
+ *  PARAMETERS:    
+ * 
+ *  DESCRIPTION:
+ *
+ *
+ *
+ *  RETURNS:
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+static int rmisec_open(struct inode *inode, struct file *filp)
+{
+#ifdef CONFIG_PHOENIX_ON_CHIP_DEVICES_NAPI
+	xlr_napi_ready = xlr_napi;
+#endif /* CONFIG_PHOENIX_ON_CHIP_DEVICES_NAPI */
+	return (0);
+}
+
+/**************************************************************************
+ *
+ *  FUNCTION:      
+ *
+ *  CALLED FROM:   
+ *
+ *  PARAMETERS:    
+ * 
+ *  DESCRIPTION:
+ *
+ *
+ *
+ *  RETURNS:
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+static int rmisec_release(struct inode *inode, struct file *filp)
+{
+	return (0);
+}
+
+int rmisec_init(void)
+{
+	dbg_msg("rmisec_init: BEGIN INIT \n");
+
+#ifdef CONFIG_PHOENIX_GMAC_NAPI
+#ifndef CONFIG_PHOENIX_ON_CHIP_DEVICES_NAPI
+	if (xlr_napi) {
+		printk(KERN_ALERT "%s: RMI Security Driver: Incompatibility with "
+			   " NAPI mode\n", __func__);
+		printk(KERN_ALERT
+			   "%s: RMI Security Driver: Aborting init sequence.\n",
+			   __func__);
+		printk(KERN_ALERT "%s: RMI Security Driver: Enable "
+			   "CONFIG_PHOENIX_ON_CHIP_DEVICES_NAPI in the kernel\n",
+			   __func__);
+
+		return -EINVAL;
+	}
+#endif /* !CONFIG_PHOENIX_ON_CHIP_DEVICES_NAPI */
+#endif /* CONFIG_PHOENIX_GMAC_NAPI */
+
+	/* if support for loading apps on same core as Linux is enabled */
+	if (xlr_loader_support && xlr_loader_sharedcore)
+		return -EINVAL;
+
+	return rmisec_init_device(RMI_MAX_DESCRIPTORS);
+}
+
+void rmisec_exit(void)
+{
+	dbg_msg("rmisec_exit: GAME OVER \n");
+}
+
+module_init(rmisec_init);
+module_exit(rmisec_exit);
diff --git a/drivers/char/rmisec/linux/rmisec.h b/drivers/char/rmisec/linux/rmisec.h
new file mode 100644
index 0000000..52e4c92
--- /dev/null
+++ b/drivers/char/rmisec/linux/rmisec.h
@@ -0,0 +1,49 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+#ifndef __RMI_SEC_H__
+#define __RMI_SEC_H__
+
+#include <linux/semaphore.h>
+
+#define RMI_SECENG_DEV_ID     4444
+#define RMI_SECENG_IRQ        0
+
+#define RMI_MAX_DESCRIPTORS   20
+
+
+typedef struct device_info_s {
+    void               *context;
+    void               *completion_handler;
+    struct semaphore   dev_sem;
+    volatile uint32_t  dev_status;
+    uint32_t           dev_features;
+} dev_info_t, *dev_info_pt;
+
+#endif /* __RMI_SEC_H__ */
diff --git a/drivers/char/rmisec/linux/rmisecio.h b/drivers/char/rmisec/linux/rmisecio.h
new file mode 100644
index 0000000..0400869
--- /dev/null
+++ b/drivers/char/rmisec/linux/rmisecio.h
@@ -0,0 +1,53 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _RMISECIO_H_
+#define _RMISECIO_H_
+
+#include <linux/ioctl.h> 
+
+#define PHXSEC_MAJOR             99
+#define PHXSEC_DEVICE_NAME       "xlr_crypto"
+#define PHXSEC_KEYDEVICE_NAME    "RMISECSSL"
+#define PHXSEC_DEVICE_PRINT_NAME "RMI_PHOENIX_SEC"
+
+/*
+ * Ioctl command codes.
+ */
+#define RMI_IOC_MAGIC                'Y'
+#define RMISEC_ENCRYPT_DECRYPT_FUNC  _IOWR(RMI_IOC_MAGIC,  1, unsigned int)
+#define RMISEC_DIGEST_FUNC           _IOWR(RMI_IOC_MAGIC,  2, unsigned int)
+#define RMISEC_KEY_SETUP_FUNC        _IOWR(RMI_IOC_MAGIC,  3, unsigned int)
+#define RMISEC_ECC_FUNC              _IOWR(RMI_IOC_MAGIC,  4, unsigned int)
+
+/* public function to get device context. Used by CryptoAPI */
+void * rmisec_get_context(unsigned int devid);
+
+#endif /* _RMISECIO_H_ */
diff --git a/drivers/char/rmisec/phxdrv/Makefile b/drivers/char/rmisec/phxdrv/Makefile
new file mode 100644
index 0000000..8957d68
--- /dev/null
+++ b/drivers/char/rmisec/phxdrv/Makefile
@@ -0,0 +1,13 @@
+#******************************************************************************
+#
+#  This software is distributed as is, without any warranty of any kind,either
+#  express or implied as further specified in the GNU Public License.
+#  This software may be used and distributed according to the terms of the
+#  GNU Public License.
+#
+#******************************************************************************
+#
+# PHXDRV makefile for Linux platforms
+# 
+
+obj-y	 += phxcmd.o phxdev.o proc.o phxcrypto.o
diff --git a/drivers/char/rmisec/phxdrv/ecc_microcode_data.h b/drivers/char/rmisec/phxdrv/ecc_microcode_data.h
new file mode 100644
index 0000000..7f4de33
--- /dev/null
+++ b/drivers/char/rmisec/phxdrv/ecc_microcode_data.h
@@ -0,0 +1,368 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+#ifndef __ECC_MICROCODE_DATA_H__
+#define __ECC_MICROCODE_DATA_H__
+
+uint64_t ecc_uc_data[] __attribute__ ((aligned(32))) = {
+		0x0000000022000006ULL,
+		0x0000000022000009ULL,
+		0x0000000022000288ULL,
+		0x220000232200028fULL,
+		0x2200028f24000000ULL,
+		0x2400000022000062ULL,
+		0x0000000022000240ULL,
+		0x000000002200022fULL,
+		0x0000000022000213ULL,
+		0x0000000022000225ULL,
+		0x0000000022000239ULL,
+		0x0000000022000248ULL,
+		0x000000002200025eULL,
+		0x000000002200001eULL,
+		0x000000002200027eULL,
+		0x4518400008c00001ULL,
+		0x4308868044184400ULL,
+		0x220000ae2000010dULL,
+		0x4500c3c0220000bcULL,
+		0x10c0000050d07e00ULL,
+		0x08a0010043004780ULL,
+		0x21a0003415ba8000ULL,
+		0x15ba800008a00200ULL,
+		0x68d0fa0021a00034ULL,
+		0x4400478031600032ULL,
+		0x3100003650b0f200ULL,
+		0x2000003b50b0fa00ULL,
+		0x50d07e004500c3c0ULL,
+		0x14ba800010c00000ULL,
+		0x3300006120000040ULL,
+		0x2200015028a00040ULL,
+		0x2000005f22000084ULL,
+		0x68b0fa0028a00048ULL,
+		0x08c0000131600045ULL,
+		0x220001ad2000004eULL,
+		0x2000005f2200008bULL,
+		0x08c0000110a00000ULL,
+		0x68f0fa0008e00000ULL,
+		0x08c000003360004eULL,
+		0x220001ad10a00000ULL,
+		0x11a000002200007dULL,
+		0x6890fa0008800001ULL,
+		0x23c000593160005bULL,
+		0x08c000012200008bULL,
+		0x220001502000005bULL,
+		0x220001ad22000084ULL,
+		0x108000002200007dULL,
+		0x2200009228a00053ULL,
+		0x24000000220000a0ULL,
+		0x220000ae4008dc00ULL,
+		0x2200020040185000ULL,
+		0x4018120040180380ULL,
+		0x2200020040184000ULL,
+		0x220001f940181200ULL,
+		0x4018320040180340ULL,
+		0x220001f94010d800ULL,
+		0x220001f940181200ULL,
+		0x40183a00401802c0ULL,
+		0x220001f94010d800ULL,
+		0x22000248d0005c00ULL,
+		0x22000248d0006c00ULL,
+		0x50988000d8007400ULL,
+		0x40182a0024000000ULL,
+		0x40186800401840c0ULL,
+		0x4018a800401802c0ULL,
+		0x24000000401804c0ULL,
+		0x4018408040182200ULL,
+		0x4018028040186000ULL,
+		0x401804804018a000ULL,
+		0x40182a0024000000ULL,
+		0x4018680040184080ULL,
+		0x4018a80040180280ULL,
+		0x2400000040180480ULL,
+		0x4418400040181200ULL,
+		0x40180200220001f9ULL,
+		0x4018500040184080ULL,
+		0x220001f944180200ULL,
+		0x4018900040180280ULL,
+		0x220001f944180200ULL,
+		0x2400000040180480ULL,
+		0x4018900040181400ULL,
+		0x40188080220000a9ULL,
+		0x4018900040185400ULL,
+		0x40188280220000a9ULL,
+		0x08c0000024000000ULL,
+		0x430887004010c200ULL,
+		0x24000000220000caULL,
+		0x4010d80040181200ULL,
+		0x40180200220001f9ULL,
+		0x4018500040184080ULL,
+		0x220001f94010da00ULL,
+		0x4018900040180280ULL,
+		0x220001f94010da00ULL,
+		0x2400000040180480ULL,
+		0x4010d80040181a00ULL,
+		0x40180200220001f9ULL,
+		0x40185800401840c0ULL,
+		0x220001f94010da00ULL,
+		0x40189800401802c0ULL,
+		0x220001f94010da00ULL,
+		0x24000000401804c0ULL,
+		0x4010c20008800000ULL,
+		0x200000d023c000ceULL,
+		0x200000d708c00000ULL,
+		0x50a18a00d8004440ULL,
+		0x688804003300010cULL,
+		0x41180440336000dfULL,
+		0x6888860040188800ULL,
+		0x41008240336000dcULL,
+		0x200000d040014c00ULL,
+		0x41180c00d010c040ULL,
+		0x68804400200000d0ULL,
+		0x41184440336000ecULL,
+		0x6888e40040188a00ULL,
+		0x4100e440336000e8ULL,
+		0x200000d040018f00ULL,
+		0xd011c0404000e440ULL,
+		0x200000d041110f00ULL,
+		0x334000fcd8004440ULL,
+		0xd810e04041088800ULL,
+		0x314000f440090c00ULL,
+		0x40180c00d010c040ULL,
+		0x336000f968888700ULL,
+		0x40180c0041188040ULL,
+		0xd010c040200000d0ULL,
+		0x200000d041180c00ULL,
+		0x41008a00d8080440ULL,
+		0x40090f00d81c8040ULL,
+		0xd001c44031400103ULL,
+		0x6888e40040018f00ULL,
+		0x4100e44033600108ULL,
+		0x200000d040018f00ULL,
+		0xd011c0404000e440ULL,
+		0x200000d041100f00ULL,
+		0x0880000024000000ULL,
+		0x23c001114010c200ULL,
+		0x08c0000020000113ULL,
+		0xd80044402000011aULL,
+		0x3300014f50a18a00ULL,
+		0x3360012268880400ULL,
+		0x4018880041180440ULL,
+		0x3360011f68888600ULL,
+		0x40014c0041008240ULL,
+		0xd010c04020000113ULL,
+		0x2000011341180c00ULL,
+		0x3360012f68804400ULL,
+		0x40188a0041184440ULL,
+		0x3360012b6888d400ULL,
+		0x40018e804100d440ULL,
+		0x4000d44020000113ULL,
+		0x41110e80d011c040ULL,
+		0xd800444020000113ULL,
+		0x410888003340013fULL,
+		0x40090c00d810d040ULL,
+		0xd010c04031400137ULL,
+		0x6888868040180c00ULL,
+		0x411880403360013cULL,
+		0x2000011340180c00ULL,
+		0x41180c00d010c040ULL,
+		0xd808044020000113ULL,
+		0xd81a804041008a00ULL,
+		0x3140014640090e80ULL,
+		0x40018e80d001c440ULL,
+		0x3360014b6888d400ULL,
+		0x40018e804100d440ULL,
+		0x4000d44020000113ULL,
+		0x41100e80d011c040ULL,
+		0x2400000020000113ULL,
+		0x4018980040101200ULL,
+		0x40080700220001f9ULL,
+		0x4008900040101a00ULL,
+		0x40100300220001f9ULL,
+		0x22000207d80ce400ULL,
+		0xd00ce40040180500ULL,
+		0x4008054022000248ULL,
+		0x220002004018a000ULL,
+		0x4000a20040100740ULL,
+		0x40080780220001f9ULL,
+		0x4000aa004010e800ULL,
+		0x40100340220001f9ULL,
+		0x40189a0040185000ULL,
+		0x40180580220001f9ULL,
+		0x4018920040185800ULL,
+		0x40100700220001f9ULL,
+		0x40187400d81cb380ULL,
+		0x4010038022000207ULL,
+		0x40180400d01cb000ULL,
+		0x401003c022000248ULL,
+		0x2200020040107000ULL,
+		0x401845c040100200ULL,
+		0x40189a0040189000ULL,
+		0x40100700220001f9ULL,
+		0x220001f94018ba00ULL,
+		0xd8006c0040080740ULL,
+		0x4018a20022000207ULL,
+		0x40180200220001f9ULL,
+		0x4210680040184100ULL,
+		0x2200024840180400ULL,
+		0x22000248d00d0400ULL,
+		0x4208ec0040180500ULL,
+		0x4018020022000248ULL,
+		0x40180400d8144000ULL,
+		0x4018020022000207ULL,
+		0x220001f940187000ULL,
+		0x4018780040180500ULL,
+		0x220001f94000f200ULL,
+		0x4000ec00d8140740ULL,
+		0x4010074022000207ULL,
+		0x68f0e80008e00000ULL,
+		0x200001a7336001a4ULL,
+		0xd008e8004010c200ULL,
+		0x4110eb0040100740ULL,
+		0x4010f2004008e000ULL,
+		0x40080500220001f9ULL,
+		0x40009a0024000000ULL,
+		0x220001f940185800ULL,
+		0x2200024842080400ULL,
+		0x40101a0040080540ULL,
+		0x2200020040104000ULL,
+		0x4210020040100780ULL,
+		0x2200024840004400ULL,
+		0x22000248d000f400ULL,
+		0x4018980040180580ULL,
+		0x401804c022000200ULL,
+		0x4010d80040183200ULL,
+		0x40189a00220001f9ULL,
+		0xd0160200220001f9ULL,
+		0x2200024840004400ULL,
+		0x40101a0040180580ULL,
+		0x220001f940105800ULL,
+		0x4018b000401805c0ULL,
+		0x4010038022000200ULL,
+		0x4018ba004018a800ULL,
+		0x401003c0220001f9ULL,
+		0x220002004018a800ULL,
+		0x42187c0040080700ULL,
+		0x4010074022000248ULL,
+		0x2200024842180400ULL,
+		0x40187000401803c0ULL,
+		0x22000207d8007c00ULL,
+		0x220001f94018aa00ULL,
+		0x4018814040180400ULL,
+		0x22000248d00fec00ULL,
+		0x22000207d8007400ULL,
+		0x220001f94018b200ULL,
+		0x40185800401803c0ULL,
+		0x4010e20022000200ULL,
+		0x42180400220001f9ULL,
+		0xd80f040022000248ULL,
+		0x4018034022000207ULL,
+		0x4000e2004018a800ULL,
+		0x40180540220001f9ULL,
+		0xc800440024000000ULL,
+		0xc808c000c910ca00ULL,
+		0x40184c00d1008200ULL,
+		0x2400000022000248ULL,
+		0xc910ca00ca004400ULL,
+		0xd1008200c808c000ULL,
+		0x2200024840184c00ULL,
+		0x3340020924000000ULL,
+		0xd010c0002000020bULL,
+		0x400880002000020cULL,
+		0x3340020f24000000ULL,
+		0xd010c00020000211ULL,
+		0x4008800020000212ULL,
+		0x3340021c24000000ULL,
+		0x08c0000133200220ULL,
+		0xd000440022000257ULL,
+		0xd800c40022000248ULL,
+		0x2000022431400218ULL,
+		0x4310024043104040ULL,
+		0x20000217d0014c00ULL,
+		0x4310024043104040ULL,
+		0x20000217d8014c00ULL,
+		0x2200025724000000ULL,
+		0x3340022b22000251ULL,
+		0x40188000d8188040ULL,
+		0xd81880002000022eULL,
+		0x2000022e40188040ULL,
+		0x4010468024000000ULL,
+		0x4008040022000240ULL,
+		0x400086804010d000ULL,
+		0x4010d20022000240ULL,
+		0x22000244220001f9ULL,
+		0x4018820024000000ULL,
+		0x4018440022000257ULL,
+		0x08c0000043104680ULL,
+		0x240000002200010dULL,
+		0x4010d80040180200ULL,
+		0x24000000220001f9ULL,
+		0x08c000014410c200ULL,
+		0x24000000220001f9ULL,
+		0x2000024c3320024aULL,
+		0x40080c00d810c040ULL,
+		0xd800c40040088000ULL,
+		0x4008800033400250ULL,
+		0xd800440024000000ULL,
+		0x2000025633400254ULL,
+		0xd8004440d8080400ULL,
+		0x4010068024000000ULL,
+		0x2200024840184400ULL,
+		0x4008d40040100200ULL,
+		0x2400000022000248ULL,
+		0x43180a00f8000000ULL,
+		0x4318404043080e40ULL,
+		0x4110c24044184000ULL,
+		0x6a8044005180c400ULL,
+		0xd100440008c00000ULL,
+		0x3340026ed91a88c0ULL,
+		0x401880003300027aULL,
+		0x6a80cc0040188840ULL,
+		0x6b004c0008c00001ULL,
+		0x08c0000033600272ULL,
+		0x41004c4041004400ULL,
+		0x40008a4040008200ULL,
+		0x6d20440021c00278ULL,
+		0x2000026711800000ULL,
+		0x3100026e51c08600ULL,
+		0x240000006a80cc00ULL,
+		0x6b10020008c00003ULL,
+		0xd000c20031600283ULL,
+		0x4118020040184000ULL,
+		0x28c0027f40184000ULL,
+		0x24000000400806c0ULL,
+		0x401032002200028fULL,
+		0x40103a0040104000ULL,
+		0x2200022f40104040ULL,
+		0x2200027e24000000ULL,
+		0x400086802200001eULL,
+		0x440044802200025eULL, 
+		0x24000000440044c0ULL, 
+		0x0000000000000000ULL,
+};
+
+#endif	/* __ECC_MICROCODE_DATA_H__ */
diff --git a/drivers/char/rmisec/phxdrv/phxcmd.c b/drivers/char/rmisec/phxdrv/phxcmd.c
new file mode 100644
index 0000000..c4e6068
--- /dev/null
+++ b/drivers/char/rmisec/phxdrv/phxcmd.c
@@ -0,0 +1,4041 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/semaphore.h>
+#include <asm/io.h>
+#include <asm/smp.h>
+#include <asm/uaccess.h>
+#include <asm/errno.h>
+
+#include <asm/rmi/debug.h>
+#include <asm/rmi/msgring.h>
+
+#include "../linux/rmisec.h"
+#include "phxdesc.h"
+#include "phxsec.h"
+#include "phxdrv.h"
+#include "asm/rmi/sim.h"
+#include "ecc_microcode_data.h"
+
+/* #define PHXCMD_DEBUG */
+/* #define PHXPKCMD_DEBUG */
+
+#ifdef PHXCMD_DEBUG
+extern int phxcrypto_verbosity;
+
+#define DPRINT  printk
+#define PHXCMD_DIAG(fmt, args...) { \
+            if (phxcrypto_verbosity >= PHXDRV_VERBOSE) \
+                DPRINT(fmt, ##args); \
+        }
+
+#define PHXCMD_DIAG_BUF(hdr, buf, len) { \
+            if (phxcrypto_verbosity >= PHXDRV_VERBOSE) \
+                print_buf((hdr), (buf), (len)); \
+        }
+#define PHXCMD_DIAG_SYM_DESC(desc, vec) { \
+            if (phxcrypto_verbosity >= PHXDRV_VERBOSE) \
+			    decode_symkey_desc ((desc), (vec)); \
+        }
+#else
+#define DPRINT(fmt, args...)
+#define PHXCMD_DIAG(fmt, args...)
+#define PHXCMD_DIAG_BUF(hdr, buf, len)
+#define PHXCMD_DIAG_SYM_DESC(desc, vec)
+#endif
+
+#ifdef PHXPKCMD_DEBUG
+extern int phxcrypto_verbosity;
+
+#ifdef DPRINT
+#undef DPRINT
+#define DPRINT  printk
+#endif
+
+#define PHXPKCMD_DIAG(fmt, args...) { \
+            if (phxcrypto_verbosity >= PHXDRV_VERBOSE) \
+                DPRINT(fmt, ##args); \
+        }
+
+#define PHXPKCMD_DIAG_BUF(hdr, buf, len) { \
+            if (phxcrypto_verbosity >= PHXDRV_VERBOSE) \
+                print_buf((hdr), (buf), (len)); \
+        }
+#else
+#define PHXPKCMD_DIAG(fmt, args...)
+#define PHXPKCMD_DIAG_BUF(hdr, buf, len)
+#endif
+
+
+/* statistics structure pointer */
+extern rmisec_stats_pt stats;
+
+#define NUM_CHUNKS(size, bits) ( ((size)>>(bits)) + (((size)&((1<<(bits))-1))?1:0) )
+
+#define BITS2BYTES(bits) ( (bits >> 3) + (((bits)&0x7)?1:0) )
+
+static const char nib2hex[] = "0123456789ABCDEF";
+
+void print_buf(char *desc, void *data, int len)
+{
+	uint8_t *dp;
+	int i;
+
+	DPRINT("%s: ", desc);		/* newline done in for-loop */
+	dp = data;
+	for (i = 0; i < len; i++, dp++) {
+		if ((i % 16) == 0)
+			DPRINT("\n");
+		DPRINT(" %c%c",
+			   nib2hex[(((*dp) & 0xf0) >> 4)], nib2hex[((*dp) & 0x0f)]);
+	}
+	DPRINT("\n");
+}
+
+void format_buf(char *desc, void *data, int len, char *buf)
+{
+	uint8_t *dp;
+	int i;
+
+	if (buf == NULL)
+		return;
+	*buf = '\0';
+	sprintf(buf, "%s\n", desc);
+	if (len > 2048)
+		return;
+	dp = data;
+	for (i = 0; i < len; i++, dp++) {
+		if ((i % 16) == 0)
+			sprintf(buf, "%s\n", buf);
+		sprintf(buf, "%s %c%c", buf,
+				nib2hex[(((*dp) & 0xf0) >> 4)], nib2hex[((*dp) & 0x0f)]);
+	}
+	sprintf(buf, "%s\n", buf);
+}
+
+
+static inline void decode_pubkey_desc(pubkey_desc_pt desc)
+{
+	unsigned long long word;
+	int i;
+	char buf[2048];
+
+	DPRINT("MSG - CTL WORD 0:  0x%llx \n",
+		   (unsigned long long) desc->control0);
+	DPRINT("\t CTRL          = %lld \n",
+		   GET_FIELD(desc->control0, PUBKEY_CTL_CTL));
+	DPRINT("\t VALID         = %lld \n",
+		   GET_FIELD(desc->control0, PUBKEY_CTL_VALID));
+
+	word = GET_FIELD(desc->control0, PUBKEY_CTL_BLKWIDTH);
+	i = ((word == 0) ? 512 : 1024);
+	DPRINT("\t BLOCK WIDTH   = 0x%llx  (%d)\n", word, i);
+
+	word = GET_FIELD(desc->control0, PUBKEY_CTL_LD_CONST);
+	DPRINT("\t LOAD CONST    = 0x%llx  (%s)\n", word,
+		   ((word == 0) ? "OLD" : "NEW"));
+
+	word = GET_FIELD(desc->control0, PUBKEY_CTL_OP_CLASS);
+	DPRINT("\t OP CLASS      = 0x%llx  (%s)\n", word,
+		   ((word == 0) ? "RSA" : "ECC"));
+
+	word = GET_FIELD(desc->control0, PUBKEY_CTL_ECC_TYPE);
+	DPRINT("\t ECC TYPE      = 0x%llx\n", word);
+
+	word = GET_FIELD(desc->control0, PUBKEY_CTL_ECC_FUNCTION);
+	DPRINT("\t ECC FUNCTION  = 0x%llx\n", word);
+
+	DPRINT("\t EXP WIDTH     = 0x%llx \n",
+		   GET_FIELD(desc->control0, PUBKEY_CTL_EXPWIDTH));
+
+	DPRINT("\t SOURCE ADDR   = 0x%llx \n",
+		   GET_FIELD(desc->control0, PUBKEY_CTL_SRCADDR));
+
+	DPRINT("\t SOURCE OFFSET = 0x%llx \n",
+		   GET_FIELD(desc->control0, PUBKEY_CTL_SRC_OFFSET));
+
+	DPRINT("\nMSG - CTL WORD 1:  0x%llx  \n",
+		   (unsigned long long) desc->control1);
+
+	DPRINT("\t CTRL          = 0x%llx \n",
+		   GET_FIELD(desc->control1, PUBKEY_CTL1_CTL));
+
+	DPRINT("\t MODULUS WIDTH = 0x%llx \n",
+		   GET_FIELD(desc->control1, PUBKEY_CTL1_MODWIDTH));
+
+
+	DPRINT("\t DEST ADDR     = 0x%llx \n",
+		   GET_FIELD(desc->control1, PUBKEY_CTL1_DSTADDR));
+
+	DPRINT("\t DEST OFFSET   = 0x%llx \n\n",
+		   GET_FIELD(desc->control1, PUBKEY_CTL1_DST_OFFSET));
+
+
+	format_buf("SOURCE Constant+Exponent+Modulus+Message",
+			   &desc->source[0], (i >> 1), buf);
+
+	printk("%s \n", buf);
+
+	format_buf("DEST  Post-op Message", &desc->dest[0], (i >> 3), buf);
+
+	printk("%s \n", buf);
+}
+
+
+static inline void
+decode_symkey_desc(symkey_desc_pt desc, uint32_t cfg_vector)
+{
+	unsigned long long word;
+
+	DPRINT("MSG - CTL: \n");
+	DPRINT("\t CTRL      = %lld \n",
+		   GET_FIELD(desc->control, MSG_CMD_CTL_CTL));
+	DPRINT("\t CTRL LEN  = %lld \n",
+		   GET_FIELD(desc->control, MSG_CMD_CTL_LEN));
+	DPRINT("\t CTRL ADDR = %llx \n\n",
+		   GET_FIELD(desc->control, MSG_CMD_CTL_ADDR));
+
+	DPRINT("MSG - DATA: \n");
+	DPRINT("\t CTRL      = %lld \n", GET_FIELD(desc->data, MSG_CMD_DATA_CTL));
+	DPRINT("\t DATA LEN  = %lld \n", GET_FIELD(desc->data, MSG_CMD_DATA_LEN));
+	DPRINT("\t DATA ADDR = %llx \n\n",
+		   GET_FIELD(desc->data, MSG_CMD_DATA_ADDR));
+
+	DPRINT("CONTROL DESCRIPTOR: \n");
+	word = desc->ctl_desc.instruction;
+	DPRINT("\tINSTRUCTION:   %llx\n", word);
+	DPRINT("\t\tOVERRIDE CIPH = %lld \n",
+		   GET_FIELD(word, CTL_DSC_OVERRIDECIPHER));
+	DPRINT("\t\tARC4 WAIT     = %lld \n",
+		   GET_FIELD(word, CTL_DSC_ARC4_WAIT4SAVE));
+	DPRINT("\t\tARC4 SAVE     = %lld \n",
+		   GET_FIELD(word, CTL_DSC_ARC4_SAVESTATE));
+	DPRINT("\t\tARC4 LOAD     = %lld \n",
+		   GET_FIELD(word, CTL_DSC_ARC4_LOADSTATE));
+	DPRINT("\t\tARC4 KEYLEN   = %lld \n",
+		   GET_FIELD(word, CTL_DSC_ARC4_KEYLEN));
+	DPRINT("\t\tCIPHER        = %lld \n", GET_FIELD(word, CTL_DSC_CPHR));
+	DPRINT("\t\tCIPHER MODE   = %lld \n", GET_FIELD(word, CTL_DSC_MODE));
+	DPRINT("\t\tINIT CIPHER   = %lld \n", GET_FIELD(word, CTL_DSC_ICPHR));
+	DPRINT("\t\tHMAC          = %lld \n", GET_FIELD(word, CTL_DSC_HMAC));
+	DPRINT("\t\tHASH ALG      = %lld \n",
+		   GET_FIELD(word, CTL_DSC_HASH) | 
+		   (GET_FIELD(word, CTL_DSC_HASHHI) << 2));
+	DPRINT("\t\tINIT HASH     = %lld \n", GET_FIELD(word, CTL_DSC_IHASH));
+	DPRINT("\t\tCHKSUM        = %lld \n", GET_FIELD(word, CTL_DSC_CKSUM));
+	DPRINT("\tCIPHER HASH INFO: \n");
+
+	switch (cfg_vector) {
+		case PHX_VECTOR_CIPHER_ARC4:
+			DPRINT("VECTOR:  PHX_VECTOR_CIPHER_ARC4 \n");
+			print_buf("ARC4 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoARC4.cipherKey0,
+					  GET_FIELD(word, CTL_DSC_ARC4_KEYLEN));
+			break;
+		case PHX_VECTOR_CIPHER_ARC4__HMAC:
+			DPRINT("VECTOR:  PHX_VECTOR_CIPHER_ARC4__HMAC \n");
+			print_buf("ARC4 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoARC4HMAC.cipherKey0,
+					  GET_FIELD(word, CTL_DSC_ARC4_KEYLEN));
+			print_buf("HMAC Key",
+					  &desc->ctl_desc.cipherHashInfo.infoARC4HMAC.hmacKey0,
+					  sizeof(HMAC_t));
+			break;
+		case PHX_VECTOR_CIPHER_ARC4__STATE:
+			DPRINT("VECTOR:  PHX_VECTOR_CIPHER_ARC4__STATE \n");
+			print_buf("ARC4 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoARC4State.cipherKey0,
+					  GET_FIELD(word, CTL_DSC_ARC4_KEYLEN));
+			break;
+		case PHX_VECTOR_CIPHER_ARC4__HMAC__STATE:
+			DPRINT("VECTOR:  PHX_VECTOR_CIPHER_ARC4__HMAC__STATE \n");
+			print_buf("ARC4 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoARC4StateHMAC.
+					  cipherKey0, GET_FIELD(word, CTL_DSC_ARC4_KEYLEN));
+			print_buf("HMAC Key",
+					  &desc->ctl_desc.cipherHashInfo.infoARC4StateHMAC.
+					  hmacKey0, sizeof(HMAC_t));
+			break;
+		case PHX_VECTOR_CIPHER_KASUMI_F8:
+			DPRINT("VECTOR:  PHX_VECTOR_CIPHER_KASUMI_F8 \n");
+			print_buf("KASUMI_F8 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoKASUMIF8.cipherKey0,
+					  PHXSEC_KASUMI_F8_KEY_LENGTH);
+			break;
+		case PHX_VECTOR_CIPHER_KASUMI_F8__HMAC:
+			DPRINT("PHX_VECTOR_CIPHER_KASUMI_F8__HMAC\n");
+			print_buf("KASUMI_F8 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoKASUMIF8HMAC.
+					  cipherKey0, PHXSEC_KASUMI_F8_KEY_LENGTH);
+			print_buf("HMAC Key",
+					  &desc->ctl_desc.cipherHashInfo.infoKASUMIF8HMAC.
+					  hmacKey0, sizeof(HMAC_t));
+			break;
+		case PHX_VECTOR_CIPHER_KASUMI_F8__HMAC2:
+			DPRINT("PHX_VECTOR_CIPHER_KASUMI_F8__HMAC2\n");
+			print_buf("KASUMI_F8 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoKASUMIF8HMAC2.
+					  cipherKey0, PHXSEC_KASUMI_F8_KEY_LENGTH);
+			print_buf("HMAC2 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoKASUMIF8HMAC2.
+					  hmacKey0, sizeof(HMAC2_t));
+			break;
+		case PHX_VECTOR_CIPHER_KASUMI_F8__GCM:
+			DPRINT("PHX_VECTOR_CIPHER_KASUMI_F8__GCM\n");
+			print_buf("KASUMI_F8 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoKASUMIF8GCM.
+					  cipherKey0, PHXSEC_KASUMI_F8_KEY_LENGTH);
+			print_buf("GCM Key",
+					  &desc->ctl_desc.cipherHashInfo.infoKASUMIF8GCM.GCMH0,
+					  sizeof(GCM_t));
+			break;
+		case PHX_VECTOR_CIPHER_KASUMI_F8__F9:
+			DPRINT("PHX_VECTOR_CIPHER_KASUMI_F8__F9\n");
+			print_buf("KASUMI_F8 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoKASUMIF8F9.
+					  cipherKey0, PHXSEC_KASUMI_F8_KEY_LENGTH);
+			print_buf("F9 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoKASUMIF8F9.authKey0,
+					  sizeof(F9_t));
+			break;
+		case PHX_VECTOR_MAC:
+			DPRINT("VECTOR:  PHX_VECTOR_MAC \n");
+			DPRINT("MAC-ONLY - No Info\n");
+			break;
+		case PHX_VECTOR_HMAC:
+			DPRINT("VECTOR:  PHX_VECTOR_HMAC \n");
+			print_buf("HMAC Key",
+					  &desc->ctl_desc.cipherHashInfo.infoHMAC.hmacKey0,
+					  sizeof(HMAC_t));
+			break;
+		case PHX_VECTOR__CIPHER_DES__HMAC__MODE_ECB_CBC:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_DES__HMAC__MODE_ECB_CBC \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoDESHMAC.cipherKey0,
+					  PHXSEC_DES_KEY_LENGTH);
+			print_buf("HMAC Key",
+					  &desc->ctl_desc.cipherHashInfo.infoDESHMAC.hmacKey0,
+					  sizeof(HMAC_t));
+			break;
+		case PHX_VECTOR__CIPHER_DES__MODE_ECB_CBC:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_DES__MODE_ECB_CBC \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoDES.cipherKey0,
+					  PHXSEC_DES_KEY_LENGTH);
+			break;
+		case PHX_VECTOR__CIPHER_3DES__HMAC__MODE_ECB_CBC:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_3DES__HMAC__MODE_ECB_CBC \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.info3DESHMAC.cipherKey0,
+					  PHXSEC_3DES_KEY_LENGTH);
+			print_buf("HMAC Key",
+					  &desc->ctl_desc.cipherHashInfo.info3DESHMAC.hmacKey0,
+					  sizeof(HMAC_t));
+			break;
+		case PHX_VECTOR__CIPHER_3DES__MODE_ECB_CBC:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_3DES__MODE_ECB_CBC \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.info3DES.cipherKey0,
+					  PHXSEC_3DES_KEY_LENGTH);
+			break;
+		case PHX_VECTOR__CIPHER_AES128__HMAC__MODE_CTR_CFB:
+			DPRINT
+				("VECTOR:  PHX_VECTOR__CIPHER_AES128__HMAC__MODE_CTR_CFB \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128HMAC.
+					  cipherKey0, PHXSEC_AES128_KEY_LENGTH);
+			print_buf("HMAC Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128HMAC.hmacKey0,
+					  sizeof(HMAC_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES128__MODE_CTR_CFB:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES128__MODE_CTR_CFB \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128.cipherKey0,
+					  PHXSEC_AES128_KEY_LENGTH);
+			break;
+		case PHX_VECTOR__CIPHER_AES128__HMAC__MODE_ECB_CBC_OFB:
+			DPRINT
+				("VECTOR:  PHX_VECTOR__CIPHER_AES128__HMAC__MODE_ECB_CBC_OFB\n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128HMAC.
+					  cipherKey0, PHXSEC_AES128_KEY_LENGTH);
+			print_buf("HMAC Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128HMAC.hmacKey0,
+					  sizeof(HMAC_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES128__MODE_ECB_CBC_OFB:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES128__MODE_ECB_CBC_OFB \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128.cipherKey0,
+					  PHXSEC_AES128_KEY_LENGTH);
+			break;
+		case PHX_VECTOR__CIPHER_AES192__HMAC__MODE_CTR_CFB:
+			DPRINT
+				("VECTOR:  PHX_VECTOR__CIPHER_AES192__HMAC__MODE_CTR_CFB \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192HMAC.
+					  cipherKey0, PHXSEC_AES192_KEY_LENGTH);
+			print_buf("HMAC Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192HMAC.hmacKey0,
+					  sizeof(HMAC_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES192__MODE_CTR_CFB:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES192__MODE_CTR_CFB \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192.cipherKey0,
+					  PHXSEC_AES192_KEY_LENGTH);
+			break;
+		case PHX_VECTOR__CIPHER_AES192__HMAC__MODE_ECB_CBC_OFB:
+			DPRINT
+				("VECTOR:  PHX_VECTOR__CIPHER_AES192__HMAC__MODE_ECB_CBC_OFB\n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192HMAC.
+					  cipherKey0, PHXSEC_AES192_KEY_LENGTH);
+			print_buf("HMAC Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192HMAC.hmacKey0,
+					  sizeof(HMAC_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES192__MODE_ECB_CBC_OFB:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES192__MODE_ECB_CBC_OFB \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192.cipherKey0,
+					  PHXSEC_AES192_KEY_LENGTH);
+			break;
+
+		case PHX_VECTOR__CIPHER_AES256__HMAC__MODE_CTR_CFB:
+			DPRINT
+				("VECTOR:  PHX_VECTOR__CIPHER_AES256__HMAC__MODE_CTR_CFB \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256HMAC.
+					  cipherKey0, PHXSEC_AES256_KEY_LENGTH);
+			print_buf("HMAC Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256HMAC.hmacKey0,
+					  sizeof(HMAC_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES256__MODE_CTR_CFB:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES256__MODE_CTR_CFB \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256.cipherKey0,
+					  PHXSEC_AES256_KEY_LENGTH);
+			break;
+		case PHX_VECTOR__CIPHER_AES256__HMAC__MODE_ECB_CBC_OFB:
+			DPRINT
+				("VECTOR:  PHX_VECTOR__CIPHER_AES256__HMAC__MODE_ECB_CBC_OFB \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256HMAC.
+					  cipherKey0, PHXSEC_AES256_KEY_LENGTH);
+			print_buf("HMAC Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256HMAC.hmacKey0,
+					  sizeof(HMAC_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES256__MODE_ECB_CBC_OFB:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES256__MODE_ECB_CBC_OFB \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256.cipherKey0,
+					  PHXSEC_AES256_KEY_LENGTH);
+			break;
+		case PHX_VECTOR_CIPHER_ARC4__HMAC2:
+			DPRINT("VECTOR:  PHX_VECTOR_CIPHER_ARC4__HMAC2 \n");
+			print_buf("ARC4 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoARC4HMAC2.cipherKey0,
+					  GET_FIELD(word, CTL_DSC_ARC4_KEYLEN));
+			print_buf("HMAC2 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoARC4HMAC2.hmacKey0,
+					  sizeof(HMAC2_t));
+			break;
+		case PHX_VECTOR_CIPHER_ARC4__HMAC2__STATE:
+			DPRINT("VECTOR:  PHX_VECTOR_CIPHER_ARC4__HMAC2__STATE \n");
+			print_buf("ARC4 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoARC4StateHMAC2.
+					  cipherKey0, GET_FIELD(word, CTL_DSC_ARC4_KEYLEN));
+			print_buf("HMAC2 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoARC4StateHMAC2.
+					  hmacKey0, sizeof(HMAC2_t));
+			break;
+		case PHX_VECTOR_HMAC2:
+			DPRINT("VECTOR:  PHX_VECTOR_HMAC2 \n");
+			print_buf("HMAC2 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoHMAC2.hmacKey0,
+					  sizeof(HMAC2_t));
+			break;
+		case PHX_VECTOR__CIPHER_DES__HMAC2__MODE_ECB_CBC:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_DES__HMAC2__MODE_ECB_CBC \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoDESHMAC2.cipherKey0,
+					  PHXSEC_DES_KEY_LENGTH);
+			print_buf("HMAC2 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoDESHMAC2.hmacKey0,
+					  sizeof(HMAC2_t));
+			break;
+		case PHX_VECTOR__CIPHER_3DES__HMAC2__MODE_ECB_CBC:
+			DPRINT
+				("VECTOR:  PHX_VECTOR__CIPHER_3DES__HMAC2__MODE_ECB_CBC \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.info3DESHMAC2.cipherKey0,
+					  PHXSEC_3DES_KEY_LENGTH);
+			print_buf("HMAC2 Key",
+					  &desc->ctl_desc.cipherHashInfo.info3DESHMAC2.hmacKey0,
+					  sizeof(HMAC2_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES128__HMAC2__MODE_CTR_CFB:
+			DPRINT
+				("VECTOR:  PHX_VECTOR__CIPHER_AES128__HMAC2__MODE_CTR_CFB \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128HMAC2.
+					  cipherKey0, PHXSEC_AES128_KEY_LENGTH);
+			print_buf("HMAC2 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128HMAC2.hmacKey0,
+					  sizeof(HMAC2_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES128__HMAC2__MODE_ECB_CBC_OFB:
+			DPRINT
+				("VECTOR:  PHX_VECTOR__CIPHER_AES128__HMAC2__MODE_ECB_CBC_OFB\n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128HMAC2.
+					  cipherKey0, PHXSEC_AES128_KEY_LENGTH);
+			print_buf("HMAC2 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128HMAC2.hmacKey0,
+					  sizeof(HMAC2_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES192__HMAC2__MODE_CTR_CFB:
+			DPRINT
+				("VECTOR:  PHX_VECTOR__CIPHER_AES192__HMAC2__MODE_CTR_CFB \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192HMAC2.
+					  cipherKey0, PHXSEC_AES192_KEY_LENGTH);
+			print_buf("HMAC2 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192HMAC2.hmacKey0,
+					  sizeof(HMAC2_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES192__HMAC2__MODE_ECB_CBC_OFB:
+			DPRINT
+				("VECTOR:  PHX_VECTOR__CIPHER_AES192__HMAC2__MODE_ECB_CBC_OFB\n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192HMAC2.
+					  cipherKey0, PHXSEC_AES192_KEY_LENGTH);
+			print_buf("HMAC2 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192HMAC2.hmacKey0,
+					  sizeof(HMAC2_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES256__HMAC2__MODE_CTR_CFB:
+			DPRINT
+				("VECTOR:  PHX_VECTOR__CIPHER_AES256__HMAC2__MODE_CTR_CFB \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256HMAC2.
+					  cipherKey0, PHXSEC_AES256_KEY_LENGTH);
+			print_buf("HMAC2 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256HMAC2.hmacKey0,
+					  sizeof(HMAC2_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES256__HMAC2__MODE_ECB_CBC_OFB:
+			DPRINT
+				("VECTOR:  PHX_VECTOR__CIPHER_AES256__HMAC2__MODE_ECB_CBC_OFB \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256HMAC2.
+					  cipherKey0, PHXSEC_AES256_KEY_LENGTH);
+			print_buf("HMAC2 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256HMAC2.hmacKey0,
+					  sizeof(HMAC2_t));
+			break;
+		case PHX_VECTOR_CIPHER_ARC4__GCM:
+			DPRINT("VECTOR:  PHX_VECTOR_CIPHER_ARC4__GCM \n");
+			print_buf("ARC4 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoARC4GCM.cipherKey0,
+					  GET_FIELD(word, CTL_DSC_ARC4_KEYLEN));
+			print_buf("GCM Key",
+					  &desc->ctl_desc.cipherHashInfo.infoARC4GCM.GCMH0,
+					  sizeof(GCM_t));
+			break;
+		case PHX_VECTOR_CIPHER_ARC4__GCM__STATE:
+			DPRINT("VECTOR:  PHX_VECTOR_CIPHER_ARC4__GCM__STATE \n");
+			print_buf("ARC4 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoARC4StateGCM.
+					  cipherKey0, GET_FIELD(word, CTL_DSC_ARC4_KEYLEN));
+			print_buf("GCM Key",
+					  &desc->ctl_desc.cipherHashInfo.infoARC4StateGCM.GCMH0,
+					  sizeof(GCM_t));
+			break;
+		case PHX_VECTOR_GCM:
+			DPRINT("VECTOR:  PHX_VECTOR_GCM \n");
+			print_buf("GCM Key",
+					  &desc->ctl_desc.cipherHashInfo.infoGCM.GCMH0,
+					  sizeof(GCM_t));
+			break;
+		case PHX_VECTOR__CIPHER_DES__GCM__MODE_ECB_CBC:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_DES__GCM__MODE_ECB_CBC \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoDESGCM.cipherKey0,
+					  PHXSEC_DES_KEY_LENGTH);
+			print_buf("GCM Key",
+					  &desc->ctl_desc.cipherHashInfo.infoDESGCM.GCMH0,
+					  sizeof(GCM_t));
+			break;
+		case PHX_VECTOR__CIPHER_3DES__GCM__MODE_ECB_CBC:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_3DES__GCM__MODE_ECB_CBC \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.info3DESGCM.cipherKey0,
+					  PHXSEC_3DES_KEY_LENGTH);
+			print_buf("GCM Key",
+					  &desc->ctl_desc.cipherHashInfo.info3DESGCM.GCMH0,
+					  sizeof(GCM_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES128__GCM__MODE_CTR_CFB:
+			DPRINT
+				("VECTOR:  PHX_VECTOR__CIPHER_AES128__GCM__MODE_CTR_CFB \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128GCM.cipherKey0,
+					  PHXSEC_AES128_KEY_LENGTH);
+			print_buf("GCM Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128GCM.GCMH0,
+					  PHXSEC_AES128_KEY_LENGTH);
+			break;
+		case PHX_VECTOR__CIPHER_AES128__GCM__MODE_ECB_CBC_OFB:
+			DPRINT
+				("VECTOR:  PHX_VECTOR__CIPHER_AES128__GCM__MODE_ECB_CBC_OFB\n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128GCM.cipherKey0,
+					  PHXSEC_AES128_KEY_LENGTH);
+			print_buf("GCM Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128GCM.GCMH0,
+					  PHXSEC_AES128_KEY_LENGTH);
+			break;
+		case PHX_VECTOR__CIPHER_AES192__GCM__MODE_CTR_CFB:
+			DPRINT
+				("VECTOR:  PHX_VECTOR__CIPHER_AES192__GCM__MODE_CTR_CFB \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192GCM.cipherKey0,
+					  PHXSEC_AES192_KEY_LENGTH);
+			print_buf("GCM Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192GCM.GCMH0,
+					  PHXSEC_AES192_KEY_LENGTH);
+			break;
+		case PHX_VECTOR__CIPHER_AES192__GCM__MODE_ECB_CBC_OFB:
+			DPRINT
+				("VECTOR:  PHX_VECTOR__CIPHER_AES192__GCM__MODE_ECB_CBC_OFB\n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192GCM.cipherKey0,
+					  PHXSEC_AES192_KEY_LENGTH);
+			print_buf("GCM Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192GCM.GCMH0,
+					  PHXSEC_AES192_KEY_LENGTH);
+			break;
+		case PHX_VECTOR__CIPHER_AES256__GCM__MODE_CTR_CFB:
+			DPRINT
+				("VECTOR:  PHX_VECTOR__CIPHER_AES256__GCM__MODE_CTR_CFB \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256GCM.cipherKey0,
+					  PHXSEC_AES256_KEY_LENGTH);
+			print_buf("GCM Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256GCM.GCMH0,
+					  PHXSEC_AES256_KEY_LENGTH);
+			break;
+		case PHX_VECTOR__CIPHER_AES256__GCM__MODE_ECB_CBC_OFB:
+			DPRINT
+				("VECTOR:  PHX_VECTOR__CIPHER_AES256__GCM__MODE_ECB_CBC_OFB \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256GCM.cipherKey0,
+					  PHXSEC_AES256_KEY_LENGTH);
+			print_buf("GCM Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256GCM.GCMH0,
+					  PHXSEC_AES256_KEY_LENGTH);
+			break;
+		case PHX_VECTOR_CIPHER_ARC4__F9:
+			DPRINT("VECTOR:  PHX_VECTOR_CIPHER_ARC4__F9 \n");
+			print_buf("ARC4 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoARC4F9.cipherKey0,
+					  GET_FIELD(word, CTL_DSC_ARC4_KEYLEN));
+			print_buf("F9 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoARC4F9.authKey0,
+					  sizeof(F9_t));
+			break;
+		case PHX_VECTOR_CIPHER_ARC4__F9__STATE:
+			DPRINT("VECTOR:  PHX_VECTOR_CIPHER_ARC4__F9__STATE \n");
+			print_buf("ARC4 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoARC4StateF9.
+					  cipherKey0, GET_FIELD(word, CTL_DSC_ARC4_KEYLEN));
+			print_buf("F9 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoARC4StateF9.authKey0,
+					  sizeof(F9_t));
+			break;
+		case PHX_VECTOR_F9:
+			DPRINT("VECTOR:  PHX_VECTOR_F9 \n");
+			print_buf("F9 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoF9.authKey0,
+					  sizeof(F9_t));
+			break;
+		case PHX_VECTOR__CIPHER_DES__F9__MODE_ECB_CBC:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_DES__F9__MODE_ECB_CBC \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoDESF9.cipherKey0,
+					  PHXSEC_DES_KEY_LENGTH);
+			print_buf("F9 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoDESF9.authKey0,
+					  sizeof(F9_t));
+			break;
+		case PHX_VECTOR__CIPHER_3DES__F9__MODE_ECB_CBC:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_3DES__F9__MODE_ECB_CBC \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.info3DESF9.cipherKey0,
+					  PHXSEC_3DES_KEY_LENGTH);
+			print_buf("F9 Key",
+					  &desc->ctl_desc.cipherHashInfo.info3DESF9.authKey0,
+					  sizeof(F9_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES128__F9__MODE_CTR_CFB:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES128__F9__MODE_CTR_CFB \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128F9.cipherKey0,
+					  PHXSEC_AES128_KEY_LENGTH);
+			print_buf("F9 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128F9.authKey0,
+					  sizeof(F9_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES128__F9__MODE_ECB_CBC_OFB:
+			DPRINT
+				("VECTOR:  PHX_VECTOR__CIPHER_AES128__F9__MODE_ECB_CBC_OFB\n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128F9.cipherKey0,
+					  PHXSEC_AES128_KEY_LENGTH);
+			print_buf("F9 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128F9.authKey0,
+					  sizeof(F9_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES192__F9__MODE_CTR_CFB:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES192__F9__MODE_CTR_CFB \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192F9.cipherKey0,
+					  PHXSEC_AES192_KEY_LENGTH);
+			print_buf("F9 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192F9.authKey0,
+					  sizeof(F9_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES192__F9__MODE_ECB_CBC_OFB:
+			DPRINT
+				("VECTOR:  PHX_VECTOR__CIPHER_AES192__F9__MODE_ECB_CBC_OFB\n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192F9.cipherKey0,
+					  PHXSEC_AES192_KEY_LENGTH);
+			print_buf("F9 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192F9.authKey0,
+					  sizeof(F9_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES256__F9__MODE_CTR_CFB:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES256__F9__MODE_CTR_CFB \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256F9.cipherKey0,
+					  PHXSEC_AES256_KEY_LENGTH);
+			print_buf("F9 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256F9.authKey0,
+					  sizeof(F9_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES256__F9__MODE_ECB_CBC_OFB:
+			DPRINT
+				("VECTOR:  PHX_VECTOR__CIPHER_AES256__F9__MODE_ECB_CBC_OFB \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256F9.cipherKey0,
+					  PHXSEC_AES256_KEY_LENGTH);
+			print_buf("F9 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256F9.authKey0,
+					  sizeof(F9_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES128__HMAC__MODE_F8:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES128__HMAC__MODE_F8 \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128F8HMAC.
+					  cipherKey0, PHXSEC_AES128F8_KEY_LENGTH);
+			print_buf("HMAC Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128F8HMAC.
+					  hmacKey0, sizeof(HMAC_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES128__MODE_F8:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES128__MODE_F8 \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128F8.cipherKey0,
+					  PHXSEC_AES128F8_KEY_LENGTH);
+			break;
+		case PHX_VECTOR__CIPHER_AES192__HMAC__MODE_F8:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES192__HMAC__MODE_F8 \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192F8HMAC.
+					  cipherKey0, PHXSEC_AES192F8_KEY_LENGTH);
+			print_buf("HMAC Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192F8HMAC.
+					  hmacKey0, sizeof(HMAC_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES192__MODE_F8:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES192__MODE_F8 \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192F8.cipherKey0,
+					  PHXSEC_AES192F8_KEY_LENGTH);
+			break;
+		case PHX_VECTOR__CIPHER_AES256__HMAC__MODE_F8:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES256__HMAC__MODE_F8 \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256F8HMAC.
+					  cipherKey0, PHXSEC_AES256F8_KEY_LENGTH);
+			print_buf("HMAC Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256HMAC.hmacKey0,
+					  sizeof(HMAC_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES256__MODE_F8:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES256__MODE_F8 \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256F8.cipherKey0,
+					  PHXSEC_AES256F8_KEY_LENGTH);
+			break;
+		case PHX_VECTOR__CIPHER_AES128__HMAC2__MODE_F8:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES128__HMAC2__MODE_F8 \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128F8HMAC2.
+					  cipherKey0, PHXSEC_AES128F8_KEY_LENGTH);
+			print_buf("HMAC2 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128F8HMAC2.
+					  hmacKey0, sizeof(HMAC2_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES192__HMAC2__MODE_F8:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES192__HMAC2__MODE_F8 \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192F8HMAC2.
+					  cipherKey0, PHXSEC_AES192F8_KEY_LENGTH);
+			print_buf("HMAC2 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192F8HMAC2.
+					  hmacKey0, sizeof(HMAC2_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES256__HMAC2__MODE_F8:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES256__HMAC2__MODE_F8 \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256F8HMAC2.
+					  cipherKey0, PHXSEC_AES256F8_KEY_LENGTH);
+			print_buf("HMAC2 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256F8HMAC2.
+					  hmacKey0, sizeof(HMAC2_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES128__GCM__MODE_F8:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES128__GCM__MODE_F8 \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128F8GCM.
+					  cipherKey0, PHXSEC_AES128F8_KEY_LENGTH);
+			print_buf("GCM Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128GCM.GCMH0,
+					  PHXSEC_AES128_KEY_LENGTH);
+			break;
+		case PHX_VECTOR__CIPHER_AES192__GCM__MODE_F8:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES192__GCM__MODE_F8 \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192F8GCM.
+					  cipherKey0, PHXSEC_AES192_KEY_LENGTH);
+			print_buf("GCM Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192F8GCM.GCMH0,
+					  PHXSEC_AES192_KEY_LENGTH);
+			break;
+		case PHX_VECTOR__CIPHER_AES256__GCM__MODE_F8:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES256__GCM__MODE_F8 \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256F8GCM.
+					  cipherKey0, PHXSEC_AES256F8_KEY_LENGTH);
+			print_buf("GCM Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256F8GCM.GCMH0,
+					  PHXSEC_AES256_KEY_LENGTH);
+			break;
+		case PHX_VECTOR__CIPHER_AES128__F9__MODE_F8:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES128__F9__MODE_F8 \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128F8F9.
+					  cipherKey0, PHXSEC_AES128F8_KEY_LENGTH);
+			print_buf("F9 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES128F8F9.authKey0,
+					  sizeof(F9_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES192__F9__MODE_F8:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES192__F9__MODE_F8 \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192F8F9.
+					  cipherKey0, PHXSEC_AES192F8_KEY_LENGTH);
+			print_buf("F9 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES192F8F9.authKey0,
+					  sizeof(F9_t));
+			break;
+		case PHX_VECTOR__CIPHER_AES256__F9__MODE_F8:
+			DPRINT("VECTOR:  PHX_VECTOR__CIPHER_AES256__F9__MODE_F8 \n");
+			print_buf("CIPHER Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256F8F9.
+					  cipherKey0, PHXSEC_AES256F8_KEY_LENGTH);
+			print_buf("F9 Key",
+					  &desc->ctl_desc.cipherHashInfo.infoAES256F8F9.authKey0,
+					  sizeof(F9_t));
+			break;
+
+		default:
+			DPRINT("VECTOR:  ???? \n");
+			DPRINT(">>>  WHAT THE HECK !!!  <<< \n");
+			break;
+	}
+
+	DPRINT("PACKET DESCRIPTOR: \n");
+	word = desc->pkt_desc.srcLengthIVOffUseIVNext;
+	DPRINT("\tSrcLengthIVOffsetIVNext:   %llx\n", word);
+	DPRINT("\t\tLoad HMAC         = %lld \n",
+		   GET_FIELD(word, PKT_DSC_LOADHMACKEY));
+	DPRINT("\t\tPad Hash          = %lld \n",
+		   GET_FIELD(word, PKT_DSC_PADHASH));
+	DPRINT("\t\tHash Byte Count   = %lld \n",
+		   GET_FIELD(word, PKT_DSC_HASHBYTES));
+	DPRINT("\t\tNext              = %lld \n", GET_FIELD(word, PKT_DSC_NEXT));
+	DPRINT("\t\tUse IV            = %lld \n", GET_FIELD(word, PKT_DSC_IV));
+	DPRINT("\t\tIV Offset         = %lld \n", GET_FIELD(word, PKT_DSC_IVOFF));
+	DPRINT("\t\tPacket Length     = %lld \n",
+		   GET_FIELD(word, PKT_DSC_PKTLEN));
+	DPRINT("\t\tNLHMAC            = %lld \n",
+		   GET_FIELD(word, PKT_DSC_NLHMAC));
+	DPRINT("\t\tBreak             = %lld \n", GET_FIELD(word, PKT_DSC_BREAK));
+	DPRINT("\t\tWait              = %lld \n", GET_FIELD(word, PKT_DSC_WAIT));
+	DPRINT("\t\tSegment Src Addr  = %llx \n",
+		   (GET_FIELD(word, PKT_DSC_SEGADDR) << 5) & 0xffffffffffULL);
+	DPRINT("\t\tSRTCP             = %lld \n", GET_FIELD(word, PKT_DSC_SRTCP));
+	DPRINT("\t\tGlobal Src Offset = %lld \n",
+		   GET_FIELD(word, PKT_DSC_SEGOFFSET));
+
+	word = desc->pkt_desc.dstDataSettings;
+	DPRINT("\tdstDataSettings:  %llx \n", word);
+	DPRINT("\t\tArc4 Byte Count   = %lld \n", GET_FIELD(word,
+			PKT_DSC_ARC4BYTECOUNT));
+	DPRINT("\t\tSym Operation     = %lld \n",
+		   GET_FIELD(word, PKT_DSC_SYM_OP));
+	DPRINT("\t\tCipher Offset     = %lld \n",
+		   GET_FIELD(word, PKT_DSC_CPHROFF));
+	DPRINT("\t\tHash Offset       = %lld \n",
+		   GET_FIELD(word, PKT_DSC_HASHOFF));
+	DPRINT("\t\tHash Source       = %lld \n",
+		   GET_FIELD(word, PKT_DSC_HASHSRC));
+	DPRINT("\t\tChecksum Offset   = %lld \n",
+		   GET_FIELD(word, PKT_DSC_CKSUMOFF));
+	DPRINT("\t\tChecksum Source   = %lld \n",
+		   GET_FIELD(word, PKT_DSC_CKSUMSRC));
+	DPRINT("\t\tCipher Dest Addr  = %llx \n",
+		   GET_FIELD(word, PKT_DSC_CPHR_DST_ADDR));
+	DPRINT("\t\tCipher Dest Dword = %lld \n",
+		   GET_FIELD(word, PKT_DSC_CPHR_DST_DWOFFSET));
+	DPRINT("\t\tCipher Dest Offset= %lld \n",
+		   GET_FIELD(word, PKT_DSC_CPHR_DST_OFFSET));
+	word = desc->pkt_desc.authDstNonceLow;
+	DPRINT("\tauthDstNonceLow:  %llx \n", word);
+	DPRINT("\t\tNonce Low 24      = %lld \n", 
+			GET_FIELD(word, PKT_DSC_NONCE_LOW));
+	DPRINT("\t\tauthDst           = %llx \n", 
+			GET_FIELD(word, PKT_DSC_AUTH_DST_ADDR));
+	DPRINT("\t\tCipher Offset High= %lld \n", 
+			GET_FIELD(word, PKT_DSC_CIPH_OFF_HI));
+	word = desc->pkt_desc.ckSumDstNonceHiCFBMaskLLWMask;
+	DPRINT("\tckSumDstNonceHiCFBMaskLLWMask:  %llx \n", word);
+	DPRINT("\t\tHash Byte off     = %lld \n",
+		   GET_FIELD(word, PKT_DSC_HASH_BYTE_OFF));
+	DPRINT("\t\tPacket Len bytes  = %lld \n",
+		   GET_FIELD(word, PKT_DSC_PKTLEN_BYTES));
+	DPRINT("\t\tLast Long Word Mask = %lld \n",
+		   GET_FIELD(word, PKT_DSC_LASTWORD));
+	DPRINT("\t\tCipher Dst Address  = %llx \n",
+		   GET_FIELD(word, PKT_DSC_CPHR_DST_ADDR));
+	DPRINT("\t\tGlobal Dst Offset  = %lld \n",
+		   GET_FIELD(word, PKT_DSC_CPHR_DST_OFFSET));
+
+	DPRINT("CFG_VECTOR = %04x\n", cfg_vector);
+	DPRINT("\n\n");
+}
+
+/* public interface */
+void phxsec_DecodeDescriptor(void *desc, __u32 cfg_vector)
+{
+#ifdef PHXCMD_DEBUG
+	symkey_desc_pt sym_desc = (symkey_desc_pt) desc;
+	PHXCMD_DIAG_SYM_DESC(sym_desc, cfg_vector);
+#endif
+}
+
+static phxsec_error_t 
+cipher_setup(phxsec_io_pt op,
+				ControlDescriptor_pt ctl_desc, __u32 * vector)
+{
+	__u32 aes_flag = 0;
+	__u32 cipher_vector = 0;
+
+	PHXCMD_DIAG("cipher_setup:  ENTER  vector = %04x\n", *vector);
+
+	switch (op->cipher_type) {
+		case PHX_CIPHER_TYPE_NONE:
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_CPHR,
+					  CTL_DSC_CPHR_BYPASS);
+			PHXCMD_DIAG("cipher_setup:  CIPHER_TYPE_NONE EXIT\n");
+			return PHXSEC_ERR_NONE;
+		case PHX_CIPHER_TYPE_DES:
+			cipher_vector |= PHX_VECTOR_CIPHER_DES;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_CPHR, CTL_DSC_CPHR_DES);
+			break;
+		case PHX_CIPHER_TYPE_3DES:
+			cipher_vector |= PHX_VECTOR_CIPHER_3DES;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_CPHR, CTL_DSC_CPHR_3DES);
+			break;
+		case PHX_CIPHER_TYPE_AES128:
+			aes_flag = 1;
+			cipher_vector |= PHX_VECTOR_CIPHER_AES128;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_CPHR,
+					  CTL_DSC_CPHR_AES128);
+			break;
+		case PHX_CIPHER_TYPE_AES192:
+			aes_flag = 1;
+			cipher_vector |= PHX_VECTOR_CIPHER_AES192;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_CPHR,
+					  CTL_DSC_CPHR_AES192);
+			break;
+		case PHX_CIPHER_TYPE_AES256:
+			aes_flag = 1;
+			cipher_vector |= PHX_VECTOR_CIPHER_AES256;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_CPHR,
+					  CTL_DSC_CPHR_AES256);
+			break;
+		case PHX_CIPHER_TYPE_ARC4:
+			cipher_vector |= PHX_VECTOR_CIPHER_ARC4;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_CPHR, CTL_DSC_CPHR_ARC4);
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_ARC4_KEYLEN,
+					  op->rc4_key_len);
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_ARC4_LOADSTATE,
+					  op->rc4_loadstate);
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_ARC4_SAVESTATE,
+					  op->rc4_savestate);
+			if (op->rc4_loadstate || op->rc4_savestate)
+				cipher_vector |= PHX_VECTOR_STATE;
+			break;
+		case PHX_CIPHER_TYPE_KASUMI_F8:
+			aes_flag = 1;
+			cipher_vector |= PHX_VECTOR_CIPHER_KASUMI_F8;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_CPHR,
+					  CTL_DSC_CPHR_KASUMI_F8);
+			break;
+		default:
+			PHXCMD_DIAG("cipher_setup:  ERR_CIPHER_TYPE EXIT\n");
+			return PHXSEC_ERR_CIPHER_TYPE;
+	}
+
+	switch (op->cipher_mode) {
+		case PHX_CIPHER_MODE_ECB:
+			if (aes_flag == 1)
+				cipher_vector |= PHX_VECTOR_MODE_ECB_CBC_OFB;
+			else
+				cipher_vector |= PHX_VECTOR_MODE_ECB_CBC;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_MODE, CTL_DSC_MODE_ECB);
+			break;
+		case PHX_CIPHER_MODE_CBC:
+			if (aes_flag == 1)
+				cipher_vector |= PHX_VECTOR_MODE_ECB_CBC_OFB;
+			else
+				cipher_vector |= PHX_VECTOR_MODE_ECB_CBC;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_MODE, CTL_DSC_MODE_CBC);
+			break;
+		case PHX_CIPHER_MODE_OFB:
+			if (aes_flag == 0) {
+				PHXCMD_DIAG("cipher_setup:  ERR_CIPHER_MODE EXIT\n");
+				return PHXSEC_ERR_CIPHER_MODE;
+			}
+			cipher_vector |= PHX_VECTOR_MODE_ECB_CBC_OFB;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_MODE, CTL_DSC_MODE_OFB);
+			break;
+		case PHX_CIPHER_MODE_CTR:
+			if (aes_flag == 0) {
+				PHXCMD_DIAG("cipher_setup:  ERR_CIPHER_MODE EXIT\n");
+				return PHXSEC_ERR_CIPHER_MODE;
+			}
+			cipher_vector |= PHX_VECTOR_MODE_CTR_CFB;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_MODE, CTL_DSC_MODE_CTR);
+			break;
+		case PHX_CIPHER_MODE_CFB:
+			if (aes_flag == 0) {
+				PHXCMD_DIAG("cipher_setup:  ERR_CIPHER_MODE EXIT\n");
+				return PHXSEC_ERR_CIPHER_MODE;
+			}
+			cipher_vector |= PHX_VECTOR_MODE_CTR_CFB;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_MODE, CTL_DSC_MODE_CFB);
+			break;
+		case PHX_CIPHER_MODE_F8:
+			if (aes_flag == 0) {
+				PHXCMD_DIAG("cipher_setup:  ERR_CIPHER_MODE EXIT\n");
+				return PHXSEC_ERR_CIPHER_MODE;
+			}
+			cipher_vector |= PHX_VECTOR_MODE_F8;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_MODE, CTL_DSC_MODE_F8);
+			break;
+		default:
+			if (!
+				(cipher_vector &
+				 (PHX_VECTOR_CIPHER_ARC4 | PHX_VECTOR_CIPHER_KASUMI_F8))) {
+				PHXCMD_DIAG("cipher_setup:  ERR_CIPHER_MODE EXIT\n");
+				return PHXSEC_ERR_CIPHER_MODE;
+			}
+	}
+
+	switch (op->cipher_init) {
+		case PHX_CIPHER_INIT_OK:
+			SET_FIELD(ctl_desc->instruction,
+					  CTL_DSC_ICPHR, CTL_DSC_ICPHR_OKY);
+			break;
+
+		case PHX_CIPHER_INIT_NK:
+			SET_FIELD(ctl_desc->instruction,
+					  CTL_DSC_ICPHR, CTL_DSC_ICPHR_NKY);
+			break;
+		default:
+			PHXCMD_DIAG("cipher_setup:  ERR_CIPHER_INIT EXIT\n");
+			return PHXSEC_ERR_CIPHER_INIT;
+	}
+
+	*vector |= cipher_vector;
+
+	PHXCMD_DIAG("cipher_setup:  EXIT  vector = %04x\n", *vector);
+
+	return PHXSEC_ERR_NONE;
+}
+
+
+static phxsec_error_t
+digest_setup(phxsec_io_pt op,
+				ControlDescriptor_pt ctl_desc, __u32 * vector)
+{
+	__u32 hash_flag = 0;
+	__u32 hmac_flag = 0;
+	__u32 digest_vector = 0;
+
+	PHXCMD_DIAG("digest_setup:  ENTER  vector = %04x\n", *vector);
+
+	switch (op->digest_type) {
+		case PHX_DIGEST_TYPE_MD5:
+			digest_vector |= PHX_VECTOR_MAC;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH, CTL_DSC_HASH_MD5);
+			break;
+		case PHX_DIGEST_TYPE_SHA1:
+			digest_vector |= PHX_VECTOR_MAC;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH, CTL_DSC_HASH_SHA1);
+			break;
+		case PHX_DIGEST_TYPE_SHA256:
+			digest_vector |= PHX_VECTOR_MAC;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH,
+					  CTL_DSC_HASH_SHA256);
+			break;
+		case PHX_DIGEST_TYPE_SHA384:
+			digest_vector |= PHX_VECTOR_MAC;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_HASHHI,
+					  CTL_DSC_HASH_SHA384 >> 2);
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH,
+					  CTL_DSC_HASH_SHA384);
+			break;
+		case PHX_DIGEST_TYPE_SHA512:
+			digest_vector |= PHX_VECTOR_MAC;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_HASHHI,
+					  CTL_DSC_HASH_SHA512 >> 2);
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH,
+					  CTL_DSC_HASH_SHA512);
+			break;
+		case PHX_DIGEST_TYPE_GCM:
+			hash_flag = 1;
+			digest_vector |= PHX_VECTOR_GCM;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_HASHHI,
+					  CTL_DSC_HASH_GCM >> 2);
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH, CTL_DSC_HASH_GCM);
+			break;
+		case PHX_DIGEST_TYPE_KASUMI_F9:
+			hash_flag = 1;
+			digest_vector |= PHX_VECTOR_F9;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_HASHHI,
+					  CTL_DSC_HASH_KASUMI_F9 >> 2);
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH,
+					  CTL_DSC_HASH_KASUMI_F9);
+			break;
+		case PHX_DIGEST_TYPE_HMAC_MD5:
+			hmac_flag = 1;
+			digest_vector |= PHX_VECTOR_HMAC;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH, CTL_DSC_HASH_MD5);
+			break;
+		case PHX_DIGEST_TYPE_HMAC_SHA1:
+			hmac_flag = 1;
+			digest_vector |= PHX_VECTOR_HMAC;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH, CTL_DSC_HASH_SHA1);
+			break;
+		case PHX_DIGEST_TYPE_HMAC_SHA256:
+			hmac_flag = 1;
+			digest_vector |= PHX_VECTOR_HMAC;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH,
+					  CTL_DSC_HASH_SHA256);
+			break;
+		case PHX_DIGEST_TYPE_HMAC_SHA384:
+			hmac_flag = 1;
+			digest_vector |= PHX_VECTOR_HMAC2;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_HASHHI,
+					  CTL_DSC_HASH_SHA384 >> 2);
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH,
+					  CTL_DSC_HASH_SHA384);
+			break;
+		case PHX_DIGEST_TYPE_HMAC_SHA512:
+			hmac_flag = 1;
+			digest_vector |= PHX_VECTOR_HMAC2;
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_HASHHI,
+					  CTL_DSC_HASH_SHA512 >> 2);
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH,
+					  CTL_DSC_HASH_SHA512);
+			break;
+		default:
+			return PHXSEC_ERR_DIGEST_TYPE;
+	}
+
+	if (hmac_flag == 1) {
+		SET_FIELD(ctl_desc->instruction, CTL_DSC_HMAC, CTL_DSC_HMAC_ON);
+
+	}
+	if (hmac_flag || hash_flag) {
+		switch (op->digest_init) {
+			case PHX_DIGEST_INIT_OLDKEY:
+				SET_FIELD(ctl_desc->instruction, CTL_DSC_IHASH,
+						  CTL_DSC_IHASH_OLD);
+				break;
+			case PHX_DIGEST_INIT_NEWKEY:
+				SET_FIELD(ctl_desc->instruction, CTL_DSC_IHASH,
+						  CTL_DSC_IHASH_NEW);
+				break;
+			default:
+				return PHXSEC_ERR_DIGEST_INIT;
+		}
+	}							/* hmac_flag */
+
+	*vector |= digest_vector;
+
+	PHXCMD_DIAG("digest_setup: EXIT  vector = %04x\n", *vector);
+
+	return PHXSEC_ERR_NONE;
+}
+
+static phxsec_error_t 
+cksum_setup(phxsec_io_pt op, ControlDescriptor_pt ctl_desc)
+{
+	switch (op->cksum_type) {
+		case PHX_CKSUM_TYPE_NOP:
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_CKSUM,
+					  CTL_DSC_CKSUM_NOP);
+			return PHXSEC_ERR_NONE;
+		case PHX_CKSUM_TYPE_IP:
+			SET_FIELD(ctl_desc->instruction, CTL_DSC_CKSUM, CTL_DSC_CKSUM_IP);
+			break;
+		default:
+			return PHXSEC_ERR_CKSUM_TYPE;
+	}
+
+	return PHXSEC_ERR_NONE;
+}
+
+
+static phxsec_error_t 
+control_setup(phxsec_io_pt op,
+				 unsigned int flags,
+				 __u64 * control,
+				 ControlDescriptor_pt ctl_desc,
+				 phxdrv_user_t * user, __u32 vector)
+{
+	uint64_t *hmac_key = NULL;
+	uint64_t *cipher_key = NULL;
+	uint64_t *cipher_state = NULL;
+	uint32_t ctl_size = 0;
+	uint64_t ctl_addr = 0;
+	uint32_t cipher_keylen = 0;
+	uint32_t hmac_keylen = 0;
+	uint32_t ctl_len;
+
+#ifdef SYM_DEBUG
+	PHXCMD_DIAG(" ENTER  vector = %04x\n", vector);
+#endif
+
+	switch (vector) {
+		case PHX_VECTOR_MAC:
+			PHXCMD_DIAG(" PHX_VECTOR_MAC \n");
+			ctl_size = sizeof(HMAC_t);
+			break;
+		case PHX_VECTOR_HMAC:
+			PHXCMD_DIAG("PHX_VECTOR_HMAC  \n");
+			hmac_key = &ctl_desc->cipherHashInfo.infoHMAC.hmacKey0;
+			hmac_keylen = sizeof(HMAC_t);
+			ctl_size = sizeof(HMAC_t);
+			break;
+		case PHX_VECTOR_CIPHER_ARC4:
+			PHXCMD_DIAG("PHX_VECTOR_CIPHER_ARC4\n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoARC4.cipherKey0;
+			cipher_keylen = op->rc4_key_len;
+			ctl_size = sizeof(ARC4_t);
+			break;
+		case PHX_VECTOR_CIPHER_ARC4__HMAC:
+			PHXCMD_DIAG("PHX_VECTOR_CIPHER_ARC4__HMAC\n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoARC4HMAC.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoARC4HMAC.hmacKey0;
+			cipher_keylen = op->rc4_key_len;
+			hmac_keylen = sizeof(HMAC_t);
+			ctl_size = sizeof(ARC4HMAC_t);
+			break;
+		case PHX_VECTOR_CIPHER_ARC4__STATE:
+			PHXCMD_DIAG("PHX_VECTOR_CIPHER_ARC4__STATE\n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoARC4State.cipherKey0;
+			cipher_state =
+				&ctl_desc->cipherHashInfo.infoARC4State.Arc4SboxData0;
+			cipher_keylen = op->rc4_key_len;
+			ctl_size = sizeof(ARC4State_t);
+			break;
+		case PHX_VECTOR_CIPHER_ARC4__HMAC__STATE:
+			PHXCMD_DIAG("PHX_VECTOR_CIPHER_ARC4__HMAC__STATE\n");
+			cipher_key =
+				&ctl_desc->cipherHashInfo.infoARC4StateHMAC.cipherKey0;
+			cipher_state =
+				&ctl_desc->cipherHashInfo.infoARC4StateHMAC.Arc4SboxData0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoARC4StateHMAC.hmacKey0;
+			cipher_keylen = op->rc4_key_len;
+			hmac_keylen = sizeof(HMAC_t);
+			ctl_size = sizeof(ARC4StateHMAC_t);
+			break;
+		case PHX_VECTOR_CIPHER_KASUMI_F8:
+			PHXCMD_DIAG("PHX_VECTOR_CIPHER_KASUMI_F8\n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoKASUMIF8.cipherKey0;
+			cipher_keylen = PHXSEC_KASUMI_F8_KEY_LENGTH;
+			ctl_size = sizeof(KASUMIF8_t);
+			break;
+		case PHX_VECTOR_CIPHER_KASUMI_F8__HMAC:
+			PHXCMD_DIAG("PHX_VECTOR_CIPHER_KASUMI_F8__HMAC\n");
+			cipher_key =
+				&ctl_desc->cipherHashInfo.infoKASUMIF8HMAC.cipherKey0;
+			cipher_keylen = PHXSEC_KASUMI_F8_KEY_LENGTH;
+			hmac_key = &ctl_desc->cipherHashInfo.infoKASUMIF8HMAC.hmacKey0;
+			hmac_keylen = sizeof(HMAC_t);
+			ctl_size = sizeof(KASUMIF8HMAC_t);
+			break;
+		case PHX_VECTOR_CIPHER_KASUMI_F8__HMAC2:
+			PHXCMD_DIAG("PHX_VECTOR_CIPHER_KASUMI_F8__HMAC2\n");
+			cipher_key =
+				&ctl_desc->cipherHashInfo.infoKASUMIF8HMAC2.cipherKey0;
+			cipher_keylen = PHXSEC_KASUMI_F8_KEY_LENGTH;
+			hmac_key = &ctl_desc->cipherHashInfo.infoKASUMIF8HMAC2.hmacKey0;
+			hmac_keylen = sizeof(HMAC2_t);
+			ctl_size = sizeof(KASUMIF8HMAC2_t);
+			break;
+		case PHX_VECTOR_CIPHER_KASUMI_F8__GCM:
+			PHXCMD_DIAG("PHX_VECTOR_CIPHER_KASUMI_F8__GCM\n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoKASUMIF8GCM.cipherKey0;
+			cipher_keylen = PHXSEC_KASUMI_F8_KEY_LENGTH;
+			hmac_key = &ctl_desc->cipherHashInfo.infoKASUMIF8GCM.GCMH0;
+			hmac_keylen = sizeof(GCM_t);
+			ctl_size = sizeof(KASUMIF8GCM_t);
+			break;
+		case PHX_VECTOR_CIPHER_KASUMI_F8__F9:
+			PHXCMD_DIAG("PHX_VECTOR_CIPHER_KASUMI_F8__F9\n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoKASUMIF8F9.cipherKey0;
+			cipher_keylen = PHXSEC_KASUMI_F8_KEY_LENGTH;
+			hmac_key = &ctl_desc->cipherHashInfo.infoKASUMIF8F9.authKey0;
+			hmac_keylen = sizeof(F9_t);
+			ctl_size = sizeof(KASUMIF8F9_t);
+			break;
+		case PHX_VECTOR__CIPHER_DES__HMAC__MODE_ECB_CBC:
+			PHXCMD_DIAG(" PHX_VECTOR__CIPHER_DES__HMAC__MODE_ECB_CBC  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoDESHMAC.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoDESHMAC.hmacKey0;
+			hmac_keylen = sizeof(HMAC_t);
+			cipher_keylen = PHXSEC_DES_KEY_LENGTH;
+			ctl_size = sizeof(DESHMAC_t);
+			break;
+		case PHX_VECTOR__CIPHER_DES__MODE_ECB_CBC:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_DES__MODE_ECB_CBC  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoDES.cipherKey0;
+			cipher_keylen = PHXSEC_DES_KEY_LENGTH;
+			ctl_size = sizeof(DES_t);
+			break;
+		case PHX_VECTOR__CIPHER_3DES__HMAC__MODE_ECB_CBC:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_3DES__HMAC__MODE_ECB_CBC  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.info3DESHMAC.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.info3DESHMAC.hmacKey0;
+			cipher_keylen = PHXSEC_3DES_KEY_LENGTH;
+			hmac_keylen = sizeof(HMAC_t);
+			ctl_size = sizeof(DES3HMAC_t);
+			break;
+		case PHX_VECTOR__CIPHER_3DES__MODE_ECB_CBC:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_3DES__MODE_ECB_CBC  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.info3DES.cipherKey0;
+			cipher_keylen = PHXSEC_3DES_KEY_LENGTH;
+			ctl_size = sizeof(DES3_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES128__HMAC__MODE_CTR_CFB:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES128__HMAC__MODE_CTR_CFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES128HMAC.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES128HMAC.hmacKey0;
+			cipher_keylen = PHXSEC_AES128_KEY_LENGTH;
+			hmac_keylen = sizeof(HMAC_t);
+			ctl_size = sizeof(AES128HMAC_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES128__MODE_CTR_CFB:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES128__MODE_CTR_CFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES128.cipherKey0;
+			cipher_keylen = PHXSEC_AES128_KEY_LENGTH;
+			ctl_size = sizeof(AES128_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES128__HMAC__MODE_ECB_CBC_OFB:
+			PHXCMD_DIAG
+				(" PHX_VECTOR__CIPHER_AES128__HMAC__MODE_ECB_CBC_OFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES128HMAC.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES128HMAC.hmacKey0;
+			cipher_keylen = PHXSEC_AES128_KEY_LENGTH;
+			hmac_keylen = sizeof(HMAC_t);
+			ctl_size = sizeof(AES128HMAC_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES128__MODE_ECB_CBC_OFB:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES128__MODE_ECB_CBC_OFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES128.cipherKey0;
+			cipher_keylen = PHXSEC_AES128_KEY_LENGTH;
+			ctl_size = sizeof(AES128_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES128__HMAC__MODE_F8:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES128__HMAC__MODE_F8  \n");
+			cipher_key =
+				&ctl_desc->cipherHashInfo.infoAES128F8HMAC.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES128F8HMAC.hmacKey0;
+			cipher_keylen = PHXSEC_AES128F8_KEY_LENGTH;
+			hmac_keylen = sizeof(HMAC_t);
+			ctl_size = sizeof(AES128F8HMAC_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES128__MODE_F8:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES128__MODE_F8  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES128F8.cipherKey0;
+			cipher_keylen = PHXSEC_AES128F8_KEY_LENGTH;
+			ctl_size = sizeof(AES128F8_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES192__HMAC__MODE_CTR_CFB:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES192__HMAC__MODE_CTR_CFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES192HMAC.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES192HMAC.hmacKey0;
+			cipher_keylen = PHXSEC_AES192_KEY_LENGTH;
+			hmac_keylen = sizeof(HMAC_t);
+			ctl_size = sizeof(AES192HMAC_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES192__MODE_CTR_CFB:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES192__MODE_CTR_CFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES192.cipherKey0;
+			cipher_keylen = PHXSEC_AES192_KEY_LENGTH;
+			ctl_size = sizeof(AES192_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES192__HMAC__MODE_ECB_CBC_OFB:
+			PHXCMD_DIAG
+				("PHX_VECTOR__CIPHER_AES192__HMAC__MODE_ECB_CBC_OFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES192HMAC.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES192HMAC.hmacKey0;
+			cipher_keylen = PHXSEC_AES192_KEY_LENGTH;
+			hmac_keylen = sizeof(HMAC_t);
+			ctl_size = sizeof(AES192HMAC_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES192__MODE_ECB_CBC_OFB:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES192__MODE_ECB_CBC_OFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES192.cipherKey0;
+			cipher_keylen = PHXSEC_AES192_KEY_LENGTH;
+			ctl_size = sizeof(AES192_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES192__HMAC__MODE_F8:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES192__HMAC__MODE_F8  \n");
+			cipher_key =
+				&ctl_desc->cipherHashInfo.infoAES192F8HMAC.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES192F8HMAC.hmacKey0;
+			cipher_keylen = PHXSEC_AES192F8_KEY_LENGTH;
+			hmac_keylen = sizeof(HMAC_t);
+			ctl_size = sizeof(AES192F8HMAC_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES192__MODE_F8:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES192__MODE_F8  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES192F8.cipherKey0;
+			cipher_keylen = PHXSEC_AES192F8_KEY_LENGTH;
+			ctl_size = sizeof(AES192F8_t);
+			break;
+
+		case PHX_VECTOR__CIPHER_AES256__HMAC__MODE_CTR_CFB:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES256__HMAC__MODE_CTR_CFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES256HMAC.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES256HMAC.hmacKey0;
+			cipher_keylen = PHXSEC_AES256_KEY_LENGTH;
+			hmac_keylen = sizeof(HMAC_t);
+			ctl_size = sizeof(AES256HMAC_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES256__MODE_CTR_CFB:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES256__MODE_CTR_CFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES256.cipherKey0;
+			cipher_keylen = PHXSEC_AES256_KEY_LENGTH;
+			ctl_size = sizeof(AES256_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES256__HMAC__MODE_ECB_CBC_OFB:
+			PHXCMD_DIAG
+				("PHX_VECTOR__CIPHER_AES256__HMAC__MODE_ECB_CBC_OFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES256HMAC.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES256HMAC.hmacKey0;
+			cipher_keylen = PHXSEC_AES256_KEY_LENGTH;
+			hmac_keylen = sizeof(HMAC_t);
+			ctl_size = sizeof(AES256HMAC_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES256__MODE_ECB_CBC_OFB:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES256__MODE_ECB_CBC_OFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES256.cipherKey0;
+			cipher_keylen = PHXSEC_AES256_KEY_LENGTH;
+			ctl_size = sizeof(AES256_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES256__HMAC__MODE_F8:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES256__HMAC__MODE_F8  \n");
+			cipher_key =
+				&ctl_desc->cipherHashInfo.infoAES256F8HMAC.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES256F8HMAC.hmacKey0;
+			cipher_keylen = PHXSEC_AES256F8_KEY_LENGTH;
+			hmac_keylen = sizeof(HMAC_t);
+			ctl_size = sizeof(AES256F8HMAC_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES256__MODE_F8:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES256__MODE_F8  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES256F8.cipherKey0;
+			cipher_keylen = PHXSEC_AES256F8_KEY_LENGTH;
+			ctl_size = sizeof(AES256F8_t);
+			break;
+		case PHX_VECTOR_HMAC2:
+			PHXCMD_DIAG("PHX_VECTOR_HMAC2  \n");
+			hmac_key = &ctl_desc->cipherHashInfo.infoHMAC2.hmacKey0;
+			hmac_keylen = sizeof(HMAC2_t);
+			ctl_size = sizeof(HMAC2_t);
+			break;
+		case PHX_VECTOR_CIPHER_ARC4__HMAC2:
+			PHXCMD_DIAG("PHX_VECTOR_CIPHER_ARC4__HMAC2\n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoARC4HMAC2.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoARC4HMAC2.hmacKey0;
+			cipher_keylen = op->rc4_key_len;
+			hmac_keylen = sizeof(HMAC2_t);
+			ctl_size = sizeof(ARC4HMAC2_t);
+			break;
+		case PHX_VECTOR_CIPHER_ARC4__HMAC2__STATE:
+			PHXCMD_DIAG("PHX_VECTOR_CIPHER_ARC4__HMAC2__STATE\n");
+			cipher_key =
+				&ctl_desc->cipherHashInfo.infoARC4StateHMAC2.cipherKey0;
+			cipher_state =
+				&ctl_desc->cipherHashInfo.infoARC4StateHMAC2.Arc4SboxData0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoARC4StateHMAC2.hmacKey0;
+			cipher_keylen = op->rc4_key_len;
+			hmac_keylen = sizeof(HMAC2_t);
+			ctl_size = sizeof(ARC4StateHMAC2_t);
+			break;
+		case PHX_VECTOR__CIPHER_DES__HMAC2__MODE_ECB_CBC:
+			PHXCMD_DIAG(" PHX_VECTOR__CIPHER_DES__HMAC2__MODE_ECB_CBC  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoDESHMAC2.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoDESHMAC2.hmacKey0;
+			hmac_keylen = sizeof(HMAC2_t);
+			cipher_keylen = PHXSEC_DES_KEY_LENGTH;
+			ctl_size = sizeof(DESHMAC2_t);
+			break;
+		case PHX_VECTOR__CIPHER_3DES__HMAC2__MODE_ECB_CBC:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_3DES__HMAC2__MODE_ECB_CBC  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.info3DESHMAC2.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.info3DESHMAC2.hmacKey0;
+			cipher_keylen = PHXSEC_3DES_KEY_LENGTH;
+			hmac_keylen = sizeof(HMAC2_t);
+			ctl_size = sizeof(DES3HMAC2_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES128__HMAC2__MODE_CTR_CFB:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES128__HMAC2__MODE_CTR_CFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES128HMAC2.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES128HMAC2.hmacKey0;
+			cipher_keylen = PHXSEC_AES128_KEY_LENGTH;
+			hmac_keylen = sizeof(HMAC2_t);
+			ctl_size = sizeof(AES128HMAC2_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES128__HMAC2__MODE_ECB_CBC_OFB:
+			PHXCMD_DIAG
+				(" PHX_VECTOR__CIPHER_AES128__HMAC2__MODE_ECB_CBC_OFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES128HMAC2.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES128HMAC2.hmacKey0;
+			cipher_keylen = PHXSEC_AES128_KEY_LENGTH;
+			hmac_keylen = sizeof(HMAC2_t);
+			ctl_size = sizeof(AES128HMAC2_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES128__HMAC2__MODE_F8:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES128__HMAC2__MODE_F8  \n");
+			cipher_key =
+				&ctl_desc->cipherHashInfo.infoAES128F8HMAC2.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES128F8HMAC2.hmacKey0;
+			cipher_keylen = PHXSEC_AES128F8_KEY_LENGTH;
+			hmac_keylen = sizeof(HMAC2_t);
+			ctl_size = sizeof(AES128F8HMAC2_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES192__HMAC2__MODE_CTR_CFB:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES192__HMAC2__MODE_CTR_CFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES192HMAC2.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES192HMAC2.hmacKey0;
+			cipher_keylen = PHXSEC_AES192_KEY_LENGTH;
+			hmac_keylen = sizeof(HMAC2_t);
+			ctl_size = sizeof(AES192HMAC2_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES192__HMAC2__MODE_ECB_CBC_OFB:
+			PHXCMD_DIAG
+				("PHX_VECTOR__CIPHER_AES192__HMAC2__MODE_ECB_CBC_OFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES192HMAC2.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES192HMAC2.hmacKey0;
+			cipher_keylen = PHXSEC_AES192_KEY_LENGTH;
+			hmac_keylen = sizeof(HMAC2_t);
+			ctl_size = sizeof(AES192HMAC2_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES192__HMAC2__MODE_F8:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES192__HMAC2__MODE_F8  \n");
+			cipher_key =
+				&ctl_desc->cipherHashInfo.infoAES192F8HMAC2.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES192F8HMAC2.hmacKey0;
+			cipher_keylen = PHXSEC_AES192F8_KEY_LENGTH;
+			hmac_keylen = sizeof(HMAC2_t);
+			ctl_size = sizeof(AES192F8HMAC2_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES256__HMAC2__MODE_CTR_CFB:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES256__HMAC2__MODE_CTR_CFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES256HMAC2.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES256HMAC2.hmacKey0;
+			cipher_keylen = PHXSEC_AES256_KEY_LENGTH;
+			hmac_keylen = sizeof(HMAC2_t);
+			ctl_size = sizeof(AES256HMAC2_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES256__HMAC2__MODE_ECB_CBC_OFB:
+			PHXCMD_DIAG
+				("PHX_VECTOR__CIPHER_AES256__HMAC2__MODE_ECB_CBC_OFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES256HMAC2.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES256HMAC2.hmacKey0;
+			cipher_keylen = PHXSEC_AES256_KEY_LENGTH;
+			hmac_keylen = sizeof(HMAC2_t);
+			ctl_size = sizeof(AES256HMAC2_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES256__HMAC2__MODE_F8:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES256__HMAC2__MODE_F8  \n");
+			cipher_key =
+				&ctl_desc->cipherHashInfo.infoAES256F8HMAC2.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES256F8HMAC2.hmacKey0;
+			cipher_keylen = PHXSEC_AES256F8_KEY_LENGTH;
+			hmac_keylen = sizeof(HMAC2_t);
+			ctl_size = sizeof(AES256F8HMAC2_t);
+			break;
+		case PHX_VECTOR_GCM:
+			PHXCMD_DIAG("PHX_VECTOR_GCM  \n");
+			hmac_key = &ctl_desc->cipherHashInfo.infoGCM.GCMH0;
+			hmac_keylen = sizeof(GCM_t);
+			ctl_size = sizeof(GCM_t);
+			break;
+		case PHX_VECTOR_CIPHER_ARC4__GCM:
+			PHXCMD_DIAG("PHX_VECTOR_CIPHER_ARC4__GCM\n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoARC4GCM.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoARC4GCM.GCMH0;
+			cipher_keylen = op->rc4_key_len;
+			hmac_keylen = sizeof(GCM_t);
+			ctl_size = sizeof(ARC4GCM_t);
+			break;
+		case PHX_VECTOR_CIPHER_ARC4__GCM__STATE:
+			PHXCMD_DIAG("PHX_VECTOR_CIPHER_ARC4__GCM__STATE\n");
+			cipher_key =
+				&ctl_desc->cipherHashInfo.infoARC4StateGCM.cipherKey0;
+			cipher_state =
+				&ctl_desc->cipherHashInfo.infoARC4StateGCM.Arc4SboxData0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoARC4StateGCM.GCMH0;
+			cipher_keylen = op->rc4_key_len;
+			hmac_keylen = sizeof(GCM_t);
+			ctl_size = sizeof(ARC4StateGCM_t);
+			break;
+		case PHX_VECTOR__CIPHER_DES__GCM__MODE_ECB_CBC:
+			PHXCMD_DIAG(" PHX_VECTOR__CIPHER_DES__GCM__MODE_ECB_CBC  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoDESGCM.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoDESGCM.GCMH0;
+			hmac_keylen = sizeof(GCM_t);
+			cipher_keylen = PHXSEC_DES_KEY_LENGTH;
+			ctl_size = sizeof(DESGCM_t);
+			break;
+		case PHX_VECTOR__CIPHER_3DES__GCM__MODE_ECB_CBC:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_3DES__GCM__MODE_ECB_CBC  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.info3DESGCM.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.info3DESGCM.GCMH0;
+			cipher_keylen = PHXSEC_3DES_KEY_LENGTH;
+			hmac_keylen = sizeof(GCM_t);
+			ctl_size = sizeof(DES3GCM_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES128__GCM__MODE_CTR_CFB:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES128__GCM__MODE_CTR_CFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES128GCM.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES128GCM.GCMH0;
+			cipher_keylen = PHXSEC_AES128_KEY_LENGTH;
+			hmac_keylen = sizeof(GCM_t);
+			ctl_size = sizeof(AES128GCM_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES128__GCM__MODE_ECB_CBC_OFB:
+			PHXCMD_DIAG
+				(" PHX_VECTOR__CIPHER_AES128__GCM__MODE_ECB_CBC_OFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES128GCM.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES128GCM.GCMH0;
+			cipher_keylen = PHXSEC_AES128_KEY_LENGTH;
+			hmac_keylen = sizeof(GCM_t);
+			ctl_size = sizeof(AES128GCM_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES128__GCM__MODE_F8:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES128__GCM__MODE_F8  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES128F8GCM.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES128F8GCM.GCMH0;
+			cipher_keylen = PHXSEC_AES128F8_KEY_LENGTH;
+			hmac_keylen = sizeof(GCM_t);
+			ctl_size = sizeof(AES128F8GCM_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES192__GCM__MODE_CTR_CFB:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES192__GCM__MODE_CTR_CFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES192GCM.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES192GCM.GCMH0;
+			cipher_keylen = PHXSEC_AES192_KEY_LENGTH;
+			hmac_keylen = sizeof(GCM_t);
+			ctl_size = sizeof(AES192GCM_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES192__GCM__MODE_ECB_CBC_OFB:
+			PHXCMD_DIAG
+				("PHX_VECTOR__CIPHER_AES192__GCM__MODE_ECB_CBC_OFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES192GCM.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES192GCM.GCMH0;
+			cipher_keylen = PHXSEC_AES192_KEY_LENGTH;
+			hmac_keylen = sizeof(GCM_t);
+			ctl_size = sizeof(AES192GCM_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES192__GCM__MODE_F8:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES192__GCM__MODE_F8  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES192F8GCM.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES192F8GCM.GCMH0;
+			cipher_keylen = PHXSEC_AES192F8_KEY_LENGTH;
+			hmac_keylen = sizeof(GCM_t);
+			ctl_size = sizeof(AES192F8GCM_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES256__GCM__MODE_CTR_CFB:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES256__GCM__MODE_CTR_CFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES256GCM.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES256GCM.GCMH0;
+			cipher_keylen = PHXSEC_AES256_KEY_LENGTH;
+			hmac_keylen = sizeof(GCM_t);
+			ctl_size = sizeof(AES256GCM_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES256__GCM__MODE_ECB_CBC_OFB:
+			PHXCMD_DIAG
+				("PHX_VECTOR__CIPHER_AES256__GCM__MODE_ECB_CBC_OFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES256GCM.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES256GCM.GCMH0;
+			cipher_keylen = PHXSEC_AES256_KEY_LENGTH;
+			hmac_keylen = sizeof(GCM_t);
+			ctl_size = sizeof(AES256GCM_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES256__GCM__MODE_F8:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES256__GCM__MODE_F8  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES256F8GCM.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES256F8GCM.GCMH0;
+			cipher_keylen = PHXSEC_AES256F8_KEY_LENGTH;
+			hmac_keylen = sizeof(GCM_t);
+			ctl_size = sizeof(AES256F8GCM_t);
+			break;
+		case PHX_VECTOR_F9:
+			PHXCMD_DIAG("PHX_VECTOR_F9  \n");
+			hmac_key = &ctl_desc->cipherHashInfo.infoF9.authKey0;
+			hmac_keylen = sizeof(F9_t);
+			ctl_size = sizeof(F9_t);
+			break;
+		case PHX_VECTOR_CIPHER_ARC4__F9:
+			PHXCMD_DIAG("PHX_VECTOR_CIPHER_ARC4__F9\n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoARC4F9.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoARC4F9.authKey0;
+			cipher_keylen = op->rc4_key_len;
+			hmac_keylen = sizeof(F9_t);
+			ctl_size = sizeof(ARC4F9_t);
+			break;
+		case PHX_VECTOR_CIPHER_ARC4__F9__STATE:
+			PHXCMD_DIAG("PHX_VECTOR_CIPHER_ARC4__F9__STATE\n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoARC4StateF9.cipherKey0;
+			cipher_state =
+				&ctl_desc->cipherHashInfo.infoARC4StateF9.Arc4SboxData0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoARC4StateF9.authKey0;
+			cipher_keylen = op->rc4_key_len;
+			hmac_keylen = sizeof(F9_t);
+			ctl_size = sizeof(ARC4StateF9_t);
+			break;
+		case PHX_VECTOR__CIPHER_DES__F9__MODE_ECB_CBC:
+			PHXCMD_DIAG(" PHX_VECTOR__CIPHER_DES__F9__MODE_ECB_CBC  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoDESF9.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoDESF9.authKey0;
+			hmac_keylen = sizeof(F9_t);
+			cipher_keylen = PHXSEC_DES_KEY_LENGTH;
+			ctl_size = sizeof(DESF9_t);
+			break;
+		case PHX_VECTOR__CIPHER_3DES__F9__MODE_ECB_CBC:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_3DES__F9__MODE_ECB_CBC  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.info3DESF9.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.info3DESF9.authKey0;
+			cipher_keylen = PHXSEC_3DES_KEY_LENGTH;
+			hmac_keylen = sizeof(F9_t);
+			ctl_size = sizeof(DES3F9_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES128__F9__MODE_CTR_CFB:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES128__F9__MODE_CTR_CFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES128F9.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES128F9.authKey0;
+			cipher_keylen = PHXSEC_AES128_KEY_LENGTH;
+			hmac_keylen = sizeof(F9_t);
+			ctl_size = sizeof(AES128F9_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES128__F9__MODE_ECB_CBC_OFB:
+			PHXCMD_DIAG
+				(" PHX_VECTOR__CIPHER_AES128__F9__MODE_ECB_CBC_OFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES128F9.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES128F9.authKey0;
+			cipher_keylen = PHXSEC_AES128_KEY_LENGTH;
+			hmac_keylen = sizeof(F9_t);
+			ctl_size = sizeof(AES128F9_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES128__F9__MODE_F8:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES128__F9__MODE_F8  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES128F8F9.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES128F8F9.authKey0;
+			cipher_keylen = PHXSEC_AES128F8_KEY_LENGTH;
+			hmac_keylen = sizeof(F9_t);
+			ctl_size = sizeof(AES128F8F9_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES192__F9__MODE_CTR_CFB:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES192__F9__MODE_CTR_CFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES192F9.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES192F9.authKey0;
+			cipher_keylen = PHXSEC_AES192_KEY_LENGTH;
+			hmac_keylen = sizeof(F9_t);
+			ctl_size = sizeof(AES192F9_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES192__F9__MODE_ECB_CBC_OFB:
+			PHXCMD_DIAG
+				("PHX_VECTOR__CIPHER_AES192__F9__MODE_ECB_CBC_OFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES192F9.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES192F9.authKey0;
+			cipher_keylen = PHXSEC_AES192_KEY_LENGTH;
+			hmac_keylen = sizeof(F9_t);
+			ctl_size = sizeof(AES192F9_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES192__F9__MODE_F8:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES192__F9__MODE_F8  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES192F8F9.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES192F8F9.authKey0;
+			cipher_keylen = PHXSEC_AES192F8_KEY_LENGTH;
+			hmac_keylen = sizeof(F9_t);
+			ctl_size = sizeof(AES192F8F9_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES256__F9__MODE_CTR_CFB:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES256__F9__MODE_CTR_CFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES256F9.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES256F9.authKey0;
+			cipher_keylen = PHXSEC_AES256_KEY_LENGTH;
+			hmac_keylen = sizeof(F9_t);
+			ctl_size = sizeof(AES256F9_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES256__F9__MODE_ECB_CBC_OFB:
+			PHXCMD_DIAG
+				("PHX_VECTOR__CIPHER_AES256__F9__MODE_ECB_CBC_OFB  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES256F9.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES256F9.authKey0;
+			cipher_keylen = PHXSEC_AES256_KEY_LENGTH;
+			hmac_keylen = sizeof(F9_t);
+			ctl_size = sizeof(AES256F9_t);
+			break;
+		case PHX_VECTOR__CIPHER_AES256__F9__MODE_F8:
+			PHXCMD_DIAG("PHX_VECTOR__CIPHER_AES256__F9__MODE_F8  \n");
+			cipher_key = &ctl_desc->cipherHashInfo.infoAES256F8F9.cipherKey0;
+			hmac_key = &ctl_desc->cipherHashInfo.infoAES256F8F9.authKey0;
+			cipher_keylen = PHXSEC_AES256F8_KEY_LENGTH;
+			hmac_keylen = sizeof(F9_t);
+			ctl_size = sizeof(AES256F8F9_t);
+			break;
+
+		default:
+			PHXCMD_DIAG("default  \n");
+			return PHXSEC_ERR_CONTROL_VECTOR;
+	}
+
+	if ((cipher_key != NULL) && !(flags & PHX_SETUP_OP_PRESERVE_CIPHER_KEY))
+		memcpy(cipher_key, &op->crypt_key[0], cipher_keylen);
+
+	if ((hmac_key != NULL) && !(flags & PHX_SETUP_OP_PRESERVE_HMAC_KEY))
+		memcpy(hmac_key, &op->mac_key[0], hmac_keylen);
+	if (cipher_state) {
+		if (op->rc4_loadstate)
+			memcpy(cipher_state, (void *) (unsigned long) op->rc4_state,
+				   PHXSEC_MAX_RC4_STATE_SIZE);
+		if (op->rc4_savestate)
+			user->aligned_state = (char *) cipher_state;
+	}
+
+	if (flags & PHX_SETUP_OP_FLIP_3DES_KEY) {
+		uint64_t temp;
+
+		temp = ctl_desc->cipherHashInfo.info3DES.cipherKey0;
+		ctl_desc->cipherHashInfo.info3DES.cipherKey0 =
+			ctl_desc->cipherHashInfo.info3DES.cipherKey2;
+		ctl_desc->cipherHashInfo.info3DES.cipherKey2 = temp;
+	}
+
+	/*
+	 *  Control length is the number of control cachelines to be read so
+	 *  user needs to round up the control length to closest integer 
+	 *  multiple of 32 bytes.
+	 */
+	ctl_size += sizeof(ctl_desc->instruction);
+	ctl_len = NUM_CHUNKS(ctl_size, 5);
+	PHXCMD_DIAG("ctl_size in bytes: %u, in cachelines: %u\n", ctl_size,
+				ctl_len);
+	CLEAR_SET_FIELD(*control, MSG_CMD_CTL_LEN, ctl_len);
+
+	ctl_addr = (__u64) virt_to_phys(ctl_desc);
+	CLEAR_SET_FIELD(*control, MSG_CMD_CTL_ADDR, ctl_addr);
+
+	PHXCMD_DIAG(" control_setup():  ctl_desc=%p   ctl_addr=%llx \n",
+				ctl_desc, (unsigned long long) ctl_addr);
+
+	CLEAR_SET_FIELD(*control, MSG_CMD_CTL_CTL, SEC_SOP);
+
+	return PHXSEC_ERR_NONE;
+}
+
+static phxsec_error_t packet_setup(phxsec_io_pt op,
+								unsigned int flags,
+								__u64 * data,
+								PacketDescriptor_pt pkt_desc,
+								ControlDescriptor_pt ctl_desc, __u32 vector)
+{
+	__u32 len, len_dwords, last_u64_bytes;
+	__u64 addr;
+	__u64 seg_addr;
+	__u64 byte_offset, global_offset;
+	__u32 cipher_offset_dwords;
+
+	PHXCMD_DIAG("packet_setup: ENTER  vector = %04x\n", vector);
+
+	/* physical address of the source buffer */
+	addr = (__u64) virt_to_phys((void *) (unsigned long) op->source_buf);
+	/* cache-aligned base of the source buffer */
+	seg_addr = (addr & ~(SMP_CACHE_BYTES - 1));
+	/* offset in bytes to the source buffer start from the segment base */
+	byte_offset = addr - seg_addr;
+	/* global offset: 0-7 bytes */
+	global_offset = byte_offset & 0x7;
+
+	/*
+	 *  op->source_buf_size is expected to be the Nb double words to stream 
+	 *  in (Including Segment address->CP/IV/Auth/CkSum offsets)
+	 */
+
+	/* adjusted length of the whole thing, accounting for the added head,
+	   sans global_offset (per Paul S.)
+	 */
+	len = op->source_buf_size + byte_offset - global_offset;
+
+	/* length of the whole thing in dwords */
+	len_dwords = NUM_CHUNKS(len, 3);
+	/* number of bytes in the last chunk (len % 8) */
+	last_u64_bytes = len & 0x07;
+
+	if (op->cipher_offset & 0x7) {
+		printk("** cipher_offset(%d) fails 64-bit word alignment **",
+			   op->cipher_offset);
+
+		return PHXSEC_ERR_CIPHER_MODE;	/* ! fix ! */
+	}
+
+	/* global_offset is only three bits, so work the number of the whole
+	   8-byte words into the global offset.
+	   both offset and cipher_offset are byte counts
+	 */
+	cipher_offset_dwords = (op->iv_offset + byte_offset) >> 3;
+
+	if (op->cipher_mode == PHX_CIPHER_MODE_F8 ||
+		op->cipher_mode == PHX_CIPHER_MODE_CTR) {
+
+		int nlhmac =
+			((op->source_buf_size + global_offset + 7 -
+			  op->cipher_offset) >> 3) & 1;
+		pkt_desc->srcLengthIVOffUseIVNext =
+			FIELD_VALUE(PKT_DSC_HASHBYTES, len & 7) | 
+			FIELD_VALUE(PKT_DSC_IVOFF, cipher_offset_dwords) |
+			FIELD_VALUE(PKT_DSC_PKTLEN, nlhmac + ((len + 7) >> 3)) | 
+			FIELD_VALUE(PKT_DSC_NLHMAC, nlhmac) |
+			FIELD_VALUE(PKT_DSC_BREAK, 0) | 
+			FIELD_VALUE(PKT_DSC_WAIT, 0) |
+			FIELD_VALUE(PKT_DSC_SEGADDR, seg_addr >> (PKT_DSC_SEGADDR_LSB)) |
+			FIELD_VALUE(PKT_DSC_SEGOFFSET, global_offset);
+	}
+	else
+		pkt_desc->srcLengthIVOffUseIVNext =
+			FIELD_VALUE(PKT_DSC_HASHBYTES, len & 7) |
+			FIELD_VALUE(PKT_DSC_IVOFF, cipher_offset_dwords) |
+			FIELD_VALUE(PKT_DSC_PKTLEN, (len + 7) >> 3) |
+			FIELD_VALUE(PKT_DSC_BREAK, 0) |
+			FIELD_VALUE(PKT_DSC_WAIT, 0) |
+			FIELD_VALUE(PKT_DSC_SEGADDR, seg_addr >> (PKT_DSC_SEGADDR_LSB)) |
+			FIELD_VALUE(PKT_DSC_SEGOFFSET, global_offset);
+
+	switch (op->pkt_hmac) {
+		case PHX_LOADHMACKEY_MODE_OLD:
+			CLEAR_SET_FIELD(pkt_desc->srcLengthIVOffUseIVNext,
+							PKT_DSC_LOADHMACKEY, PKT_DSC_LOADHMACKEY_OLD);
+			break;
+		case PHX_LOADHMACKEY_MODE_LOAD:
+			CLEAR_SET_FIELD(pkt_desc->srcLengthIVOffUseIVNext,
+							PKT_DSC_LOADHMACKEY, PKT_DSC_LOADHMACKEY_LOAD);
+			break;
+		default:
+			if (vector &
+				(PHX_VECTOR_HMAC | PHX_VECTOR_HMAC2 | PHX_VECTOR_GCM |
+				 PHX_VECTOR_F9)) {
+				PHXCMD_DIAG("packet_setup:  ERR_LOADHMACKEY_MODE EXIT\n");
+				return PHXSEC_ERR_LOADHMACKEY_MODE;
+			}
+			break;
+	}
+
+	switch (op->pkt_hash) {
+		case PHX_PADHASH_PADDED:
+			CLEAR_SET_FIELD(pkt_desc->srcLengthIVOffUseIVNext,
+							PKT_DSC_PADHASH, PKT_DSC_PADHASH_PADDED);
+			break;
+		case PHX_PADHASH_PAD:
+			CLEAR_SET_FIELD(pkt_desc->srcLengthIVOffUseIVNext,
+							PKT_DSC_PADHASH, PKT_DSC_PADHASH_PAD);
+			break;
+		default:
+			if (vector &
+				(PHX_VECTOR_MAC | PHX_VECTOR_HMAC | PHX_VECTOR_HMAC2)) {
+				PHXCMD_DIAG("packet_setup:  ERR_PADHASH_MODE EXIT\n");
+				return PHXSEC_ERR_PADHASH_MODE;
+			}
+			break;
+	}
+
+	switch (op->pkt_iv) {
+		case PHX_PKT_IV_OLD:
+			CLEAR_SET_FIELD(pkt_desc->srcLengthIVOffUseIVNext,
+							PKT_DSC_IV, PKT_DSC_IV_OLD);
+			break;
+		case PHX_PKT_IV_NEW:
+			CLEAR_SET_FIELD(pkt_desc->srcLengthIVOffUseIVNext,
+							PKT_DSC_IV, PKT_DSC_IV_NEW);
+			break;
+		default:
+			if (vector & PHX_VECTOR_CIPHER) {
+				PHXCMD_DIAG("packet_setup:  ERR_PKT_IV_MODE EXIT\n");
+				return PHXSEC_ERR_PKT_IV_MODE;
+			}
+			break;
+	}
+
+	PHXCMD_DIAG("packet_setup:  src_buf=%llx  phys_src_buf=%llx \n",
+				(unsigned long long) op->source_buf,
+				(unsigned long long) addr);
+
+	PHXCMD_DIAG("packet_setup:  seg_addr=%llx  offset=%lld\n",
+				(unsigned long long) seg_addr,
+				(unsigned long long) byte_offset);
+
+	PHXCMD_DIAG("packet_setup: global src offset: %d, iv_offset=%d\n",
+				cipher_offset_dwords, op->iv_offset);
+
+	PHXCMD_DIAG("packet_setup: src_buf_sz=%d  PKT_LEN=%d\n",
+				op->source_buf_size, len_dwords);
+
+	/*
+	 * same operation with the destination.
+	 * cipher offset affects this, as well
+	 */
+	addr = (__u64) virt_to_phys((void *) (unsigned long) op->dest_buf);
+	seg_addr = (addr & ~(SMP_CACHE_BYTES - 1));
+	byte_offset = addr - seg_addr;
+	global_offset = byte_offset & 0x7;
+
+	PHXCMD_DIAG("packet_setup:  dest_buf=%llx  phys_dest_buf=%llx \n",
+				(unsigned long long) op->dest_buf, (unsigned long long) addr);
+
+	PHXCMD_DIAG("packet_setup:  seg_addr=%llx  offset=%lld\n",
+				(unsigned long long) seg_addr,
+				(unsigned long long) byte_offset);
+
+	/*
+	 *  Dest Address =
+	 *     (Cipher Dest Address) + (Cipher Offset) + (Global Dest Data Offset)
+	 *
+	 *   Cipher Dest Address - Cache-line  (0xffffffffe0)
+	 *   Cipher Offset - Which (64-bit) Word in Cacheline  (0-3)
+	 *   Global Dest Data Offset - Number of Bytes in (64-bit) Word before data
+	 *
+	 *  It must be set for Digest-only Ops, since
+	 *   the Digest engine will write data to this address.
+	 */
+	cipher_offset_dwords = (op->cipher_offset + byte_offset) >> 3;
+
+	pkt_desc->dstDataSettings =
+		/* SYM_OP, HASHSRC */
+		FIELD_VALUE(PKT_DSC_CPHROFF, cipher_offset_dwords) |
+		FIELD_VALUE(PKT_DSC_HASHOFF, (op->digest_offset + byte_offset) >> 3) |
+		FIELD_VALUE(PKT_DSC_CPHR_DST_ADDR, seg_addr) |
+		FIELD_VALUE(PKT_DSC_CPHR_DST_DWOFFSET, 0) |
+		FIELD_VALUE(PKT_DSC_CPHR_DST_OFFSET, global_offset);
+
+	if (op->cipher_type == PHX_CIPHER_TYPE_ARC4)
+		pkt_desc->dstDataSettings |=
+			FIELD_VALUE(PKT_DSC_ARC4BYTECOUNT, last_u64_bytes);
+
+	if (op->cipher_type != PHX_CIPHER_TYPE_NONE) {
+		switch (op->cipher_op) {
+			case PHX_CIPHER_OP_ENCRYPT:
+				CLEAR_SET_FIELD(pkt_desc->dstDataSettings,
+								PKT_DSC_SYM_OP, PKT_DSC_SYM_OP_ENCRYPT);
+				break;
+			case PHX_CIPHER_OP_DECRYPT:
+				CLEAR_SET_FIELD(pkt_desc->dstDataSettings,
+								PKT_DSC_SYM_OP, PKT_DSC_SYM_OP_DECRYPT);
+				break;
+			default:
+				PHXCMD_DIAG("packet_setup:  ERR_CIPHER_OP EXIT\n");
+				return PHXSEC_ERR_CIPHER_OP;
+		}
+	}
+	if (flags & PHX_SETUP_OP_HMAC) {
+		switch (op->digest_src) {
+			case PHX_DIGEST_SRC_DMA:
+				CLEAR_SET_FIELD(pkt_desc->dstDataSettings,
+								PKT_DSC_HASHSRC, PKT_DSC_HASHSRC_DMA);
+				break;
+			case PHX_DIGEST_SRC_CPHR:
+				CLEAR_SET_FIELD(pkt_desc->dstDataSettings,
+								PKT_DSC_HASHSRC, PKT_DSC_HASHSRC_CIPHER);
+				break;
+			default:
+				PHXCMD_DIAG("packet_setup:  ERR_DIGEST_SRC EXIT\n");
+				return PHXSEC_ERR_DIGEST_SRC;
+		}
+	}
+	if (op->cksum_type != PHX_CKSUM_TYPE_NOP) {
+		switch (op->cksum_src) {
+			case PHX_CKSUM_SRC_DMA:
+				CLEAR_SET_FIELD(pkt_desc->dstDataSettings,
+								PKT_DSC_CKSUMSRC, PKT_DSC_CKSUMSRC_DMA);
+				break;
+			case PHX_CKSUM_SRC_CIPHER:
+				CLEAR_SET_FIELD(pkt_desc->dstDataSettings,
+								PKT_DSC_CKSUMSRC, PKT_DSC_CKSUMSRC_CIPHER);
+				break;
+			default:
+				PHXCMD_DIAG("packet_setup:  ERR_CKSUM_SRC EXIT\n");
+				return PHXSEC_ERR_CKSUM_SRC;
+		}
+	}
+
+	pkt_desc->ckSumDstNonceHiCFBMaskLLWMask =
+		FIELD_VALUE(PKT_DSC_HASH_BYTE_OFF, (op->digest_offset & 0x7)) |
+		FIELD_VALUE(PKT_DSC_PKTLEN_BYTES, 0) |
+		/* NONCE_HI, PKT_DSC_LASTWORD, CFB_MASK, CKSUM_DST_ADDR */
+		FIELD_VALUE(PKT_DSC_IV_OFF_HI, 0);
+
+	switch (op->pkt_lastword) {
+		case PHX_LASTWORD_128:
+			CLEAR_SET_FIELD(pkt_desc->ckSumDstNonceHiCFBMaskLLWMask,
+							PKT_DSC_LASTWORD, PKT_DSC_LASTWORD_128);
+			break;
+		case PHX_LASTWORD_96MASK:
+			CLEAR_SET_FIELD(pkt_desc->ckSumDstNonceHiCFBMaskLLWMask,
+							PKT_DSC_LASTWORD, PKT_DSC_LASTWORD_96MASK);
+			break;
+		case PHX_LASTWORD_64MASK:
+			CLEAR_SET_FIELD(pkt_desc->ckSumDstNonceHiCFBMaskLLWMask,
+							PKT_DSC_LASTWORD, PKT_DSC_LASTWORD_64MASK);
+			break;
+		case PHX_LASTWORD_32MASK:
+			CLEAR_SET_FIELD(pkt_desc->ckSumDstNonceHiCFBMaskLLWMask,
+							PKT_DSC_LASTWORD, PKT_DSC_LASTWORD_32MASK);
+			break;
+		default:
+			PHXCMD_DIAG("packet_setup:  ERR_LASTWORD_MODE EXIT\n");
+			return PHXSEC_ERR_LASTWORD_MODE;
+	}
+	CLEAR_SET_FIELD(pkt_desc->ckSumDstNonceHiCFBMaskLLWMask,
+					PKT_DSC_CFB_MASK, op->cfb_mask);
+	CLEAR_SET_FIELD(pkt_desc->ckSumDstNonceHiCFBMaskLLWMask,
+					PKT_DSC_NONCE_HI, htonl(op->nonce) >> 24);
+	CLEAR_SET_FIELD(pkt_desc->authDstNonceLow,
+					PKT_DSC_NONCE_LOW, htonl(op->nonce) & 0xffffff);
+	/* Auth Dest Address must be Cacheline aligned on input */
+	if (vector &
+		(PHX_VECTOR_MAC | PHX_VECTOR_HMAC | PHX_VECTOR_HMAC2 | PHX_VECTOR_GCM
+		 | PHX_VECTOR_F9))
+		pkt_desc->authDstNonceLow |=
+			/* NONCE_LOW */
+			FIELD_VALUE(PKT_DSC_AUTH_DST_ADDR,
+						(__u64) virt_to_phys((void *) (unsigned long) op->
+											 auth_dest)) |
+			FIELD_VALUE(PKT_DSC_CIPH_OFF_HI, 0);
+
+	PHXCMD_DIAG(" packet_setup():  auth_dest=%llx   phys_auth_dest=%llx \n",
+				(unsigned long long) op->auth_dest,
+				(unsigned long long) virt_to_phys((void *) op->auth_dest));
+
+	/* CkSum Dest Address must be Cacheline aligned on input */
+	if (op->cksum_type == PHX_CKSUM_TYPE_IP)
+		CLEAR_SET_FIELD(pkt_desc->ckSumDstNonceHiCFBMaskLLWMask,
+						PKT_DSC_CKSUM_DST_ADDR,
+						(__u64) virt_to_phys((void *) (unsigned long) op->
+											 cksum_dest));
+
+	PHXCMD_DIAG(" packet_setup():  pkt_desc=%llx   phys_pkt_desc=%llx \n",
+				(unsigned long long) pkt_desc,
+				(unsigned long long) virt_to_phys(pkt_desc));
+
+	CLEAR_SET_FIELD(*data, MSG_CMD_DATA_ADDR,
+					((__u64) virt_to_phys(pkt_desc)));
+	CLEAR_SET_FIELD(*data, MSG_CMD_DATA_CTL, SEC_EOP);
+	CLEAR_SET_FIELD(*data, MSG_CMD_DATA_LEN, MSG_CMD_DATA_LEN_LOAD);
+
+	PHXCMD_DIAG("packet_setup:  DONE\n");
+
+#ifdef SYMBOL
+	if (op->cipher_type == PHX_CIPHER_TYPE_ARC4) {
+		op->source_buf -= 0;
+		op->source_buf_size += 0;
+		op->dest_buf -= 0;
+	}
+#endif
+	return PHXSEC_ERR_NONE;
+}
+
+
+static int identify_symkey_ctl_error(__u32 code, phxsec_error_t err)
+{
+	int ret_val = -EINVAL;
+
+	switch (code) {
+		case CTL_ERR_NONE:
+			PHXCMD_DIAG("PHXSEC: CTL Error:  No Error\n");
+			ret_val = 0;
+			break;
+		case CTL_ERR_CIPHER_OP:
+			PHXCMD_DIAG
+				("PHXSEC: CTL Error(CTL_ERR_CIPHER_OP) - Unknown Cipher Op \n");
+			break;
+		case CTL_ERR_MODE:
+			PHXCMD_DIAG("PHXSEC: CTL Error(CTL_ERR_MODE) - "
+						"Unknown or Not Allowed Mode \n");
+			break;
+		case CTL_ERR_CHKSUM_SRC:
+			PHXCMD_DIAG
+				("PHXSEC: CTL Error(CTL_ERR_CHKSUM_SRC) - Unknown CkSum Src\n");
+			break;
+		case CTL_ERR_CFB_MASK:
+			PHXCMD_DIAG
+				("PHXSEC: CTL Error(CTL_ERR_CFB_MASK) - Forbidden CFB Mask \n");
+			break;
+		case CTL_ERR_OP:
+			PHXCMD_DIAG("PHXSEC: CTL Error(CTL_ERR_OP) - Unknown Ctrl Op \n");
+			break;
+		case CTL_ERR_DATA_READ:
+			PHXCMD_DIAG
+				("PHXSEC: CTL Error(CTL_ERR_DATA_READ) - Data Read Error\n");
+			break;
+		case CTL_ERR_DESC_CTRL:
+			PHXCMD_DIAG("PHXSEC: CTL Error(CTL_ERR_DESC_CTRL) - "
+						"Descriptor Ctrl Field Error  \n");
+			break;
+		case CTL_ERR_UNDEF1:
+		case CTL_ERR_UNDEF2:
+		default:
+			PHXCMD_DIAG("PHXSEC: CTL Error:  UNKNOWN CODE=%d \n", code);
+			break;
+	}
+	return ret_val;
+}
+
+static int identify_symkey_data_error(__u32 code, phxsec_error_t err)
+{
+	int ret_val = -EINVAL;
+
+	switch (code) {
+		case DATA_ERR_NONE:
+			PHXCMD_DIAG("PHXSEC: DATA Error  No Error\n");
+			ret_val = 0;
+			break;
+		case DATA_ERR_LEN_CIPHER:
+			PHXCMD_DIAG("PHXSEC: DATA Error() - Not Enough Data To Cipher\n");
+			break;
+		case DATA_ERR_IV_ADDR:
+			PHXCMD_DIAG("PHXSEC: DATA Error() - Illegal IV Loacation\n");
+			break;
+		case DATA_ERR_WD_LEN_AES:
+			PHXCMD_DIAG("PHXSEC: DATA Error() - Illegal Nb Words To AES\n");
+			break;
+		case DATA_ERR_BYTE_COUNT:
+			PHXCMD_DIAG
+				("PHXSEC: DATA Error() - Illegal Pad And ByteCount Spec\n");
+			break;
+		case DATA_ERR_LEN_CKSUM:
+			PHXCMD_DIAG("PHXSEC: DATA Error() - Not Enough Data To CkSum\n");
+			break;
+		case DATA_ERR_OP:
+			PHXCMD_DIAG("PHXSEC: DATA Error() - Unknown Data Op \n");
+			break;
+		case DATA_ERR_READ:
+			PHXCMD_DIAG("PHXSEC: DATA Error() - Data Read Error \n");
+			break;
+		case DATA_ERR_WRITE:
+			PHXCMD_DIAG("PHXSEC: DATA Error() - Data Write Error \n");
+			break;
+		case DATA_ERR_UNDEF1:
+		default:
+			PHXCMD_DIAG("PHXSEC: DATA Error - UNKNOWN CODE=%d \n", code);
+			break;
+	}
+	return ret_val;
+}
+
+static inline phxsec_error_t
+phxsec_OneOffDescriptorSetup(phxsec_io_pt op,
+							 unsigned int flags,
+							 symkey_desc_pt desc, __u32 * cfg_vector)
+{
+	phxsec_error_t err;
+
+	PHXCMD_DIAG("phxsec_OneOffDescriptorSetup: ENTER\n");
+
+
+	if ((err =
+		 cipher_setup(op, &desc->ctl_desc, cfg_vector)) != PHXSEC_ERR_NONE) {
+		PHXCMD_DIAG
+			("phxsec_OneOffDescriptorSetup: cipher_setup done err %d\n",
+			 (int) err);
+		return err;
+	}
+
+	if (op->digest_type != PHX_DIGEST_TYPE_NONE) {
+		if ((err =
+			 digest_setup(op, &desc->ctl_desc,
+						  cfg_vector)) != PHXSEC_ERR_NONE) {
+			PHXCMD_DIAG
+				("phxsec_OneOffDescriptorSetup: digest_setup done err %d\n",
+				 (int) err);
+			return err;
+		}
+	}
+
+	if ((err = cksum_setup(op, &desc->ctl_desc)) != PHXSEC_ERR_NONE) {
+		PHXCMD_DIAG("phxsec_OneOffDescriptorSetup: cksum_setup done err %d\n",
+					(int) err);
+		return err;
+	}
+
+	if ((err = control_setup(op,
+							 flags,
+							 &desc->control,
+							 &desc->ctl_desc,
+							 &desc->user, *cfg_vector)) != PHXSEC_ERR_NONE) {
+		PHXCMD_DIAG
+			("phxsec_OneOffDescriptorSetup: control_setup done err %d\n",
+			 (int) err);
+		return err;
+	}
+
+	PHXCMD_DIAG("phxsec_OneOffDescriptorSetup: DONE\n");
+	return err;
+}
+
+static inline phxsec_error_t
+phxsec_PerPacketDescriptorSetup(phxsec_io_pt op,
+								unsigned int flags,
+								symkey_desc_pt desc, __u32 vector)
+{
+	phxsec_error_t err;
+	ControlDescriptor_pt ctl_desc = &desc->ctl_desc;
+	int hmac_flag = 0;
+
+	PHXCMD_DIAG("phxsec_PerPacketDescriptorSetup: ENTER\n");
+
+	/* these are duplicated in the OneOff at this time */
+	if (flags & PHX_SETUP_OP_CIPHER) {
+		switch (op->cipher_mode) {
+			case PHX_CIPHER_MODE_ECB:
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_MODE,
+								CTL_DSC_MODE_ECB);
+				break;
+			case PHX_CIPHER_MODE_CBC:
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_MODE,
+								CTL_DSC_MODE_CBC);
+				break;
+			case PHX_CIPHER_MODE_OFB:
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_MODE,
+								CTL_DSC_MODE_OFB);
+				break;
+			case PHX_CIPHER_MODE_CTR:
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_MODE,
+								CTL_DSC_MODE_CTR);
+				break;
+			case PHX_CIPHER_MODE_CFB:
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_MODE,
+								CTL_DSC_MODE_CFB);
+				break;
+			case PHX_CIPHER_MODE_F8:
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_MODE,
+								CTL_DSC_MODE_F8);
+				break;
+			case PHX_CIPHER_MODE_PASS:
+			case PHX_CIPHER_MODE_NONE:
+				break;
+			default:
+				return PHXSEC_ERR_CIPHER_MODE;
+		}
+	}
+
+	/* 
+	   for cipher-only setups reset to digest type PHX_DIGEST_TYPE_NONE
+	 */
+	if (!(flags & PHX_SETUP_OP_HMAC)) {
+		CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH,
+						CTL_DSC_HASH_NOP);
+		CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_HMAC,
+						CTL_DSC_HMAC_OFF);
+	}
+	else {
+		switch (op->digest_type) {
+			case PHX_DIGEST_TYPE_MD5:
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH,
+								CTL_DSC_HASH_MD5);
+				break;
+			case PHX_DIGEST_TYPE_SHA1:
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH,
+								CTL_DSC_HASH_SHA1);
+				break;
+			case PHX_DIGEST_TYPE_SHA256:
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH,
+								CTL_DSC_HASH_SHA256);
+				break;
+			case PHX_DIGEST_TYPE_SHA384:
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_HASHHI,
+								CTL_DSC_HASH_SHA384 >> 2);
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH,
+								CTL_DSC_HASH_SHA384);
+				break;
+			case PHX_DIGEST_TYPE_SHA512:
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_HASHHI,
+								CTL_DSC_HASH_SHA512 >> 2);
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH,
+								CTL_DSC_HASH_SHA512);
+				break;
+			case PHX_DIGEST_TYPE_GCM:
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_HASHHI,
+								CTL_DSC_HASH_GCM >> 2);
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH,
+								CTL_DSC_HASH_GCM);
+				break;
+			case PHX_DIGEST_TYPE_KASUMI_F9:
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_HASHHI,
+								CTL_DSC_HASH_KASUMI_F9 >> 2);
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH,
+								CTL_DSC_HASH_KASUMI_F9);
+				break;
+			case PHX_DIGEST_TYPE_HMAC_MD5:
+				hmac_flag = 1;
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH,
+								CTL_DSC_HASH_MD5);
+				break;
+			case PHX_DIGEST_TYPE_HMAC_SHA1:
+				hmac_flag = 1;
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH,
+								CTL_DSC_HASH_SHA1);
+				break;
+			case PHX_DIGEST_TYPE_HMAC_SHA256:
+				hmac_flag = 1;
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH,
+								CTL_DSC_HASH_SHA256);
+				break;
+			case PHX_DIGEST_TYPE_HMAC_SHA384:
+				hmac_flag = 1;
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_HASHHI,
+								CTL_DSC_HASH_SHA384 >> 2);
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH,
+								CTL_DSC_HASH_SHA384);
+				break;
+			case PHX_DIGEST_TYPE_HMAC_SHA512:
+				hmac_flag = 1;
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_HASHHI,
+								CTL_DSC_HASH_SHA512 >> 2);
+				CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_HASH,
+								CTL_DSC_HASH_SHA512);
+				break;
+			default:
+				return PHXSEC_ERR_DIGEST_TYPE;
+		}
+
+		if (hmac_flag == 1) {
+			CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_HMAC,
+							CTL_DSC_HMAC_ON);
+
+			switch (op->digest_init) {
+				case PHX_DIGEST_INIT_OLDKEY:
+					CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_IHASH,
+									CTL_DSC_IHASH_OLD);
+					break;
+				case PHX_DIGEST_INIT_NEWKEY:
+					CLEAR_SET_FIELD(ctl_desc->instruction, CTL_DSC_IHASH,
+									CTL_DSC_IHASH_NEW);
+					break;
+				default:
+					return PHXSEC_ERR_DIGEST_INIT;
+			}
+		}
+	}
+	if (flags & (PHX_SETUP_OP_UPDATE_KEYS | PHX_SETUP_OP_FLIP_3DES_KEY)) {
+		/* if updating keys requested, call control_setup
+		   control_setup will preserve specified keys
+		 */
+		err = control_setup(op,
+							flags,
+							&desc->control,
+							&desc->ctl_desc, &desc->user, vector);
+		if (err < 0)
+			return err;
+	}
+
+	/* now call packet_setup */
+	err = packet_setup(op,
+					   flags, &desc->data, &desc->pkt_desc, ctl_desc, vector);
+
+	PHXCMD_DIAG("phxsec_PerPacketDescriptorSetup: DONE\n");
+	return err;
+}
+
+/* "Public" interface to a OneOff descriptor initialization */
+/* phxsec_io_t structure serves as a public data interface for
+   kernel components using the phxsec driver. Same structure is being used
+   by the ioctl interface for userland operations.
+   Driver context, void *desc and __u32 cfg_vector are kept within the SA
+   and are passed back upon subsequent driver calls.
+   For phxsec_FillDescriptor call phxsec_io_t structure is filled with values
+   that are not going to change for the lifetime of the SA. For the per-packet
+   values see the call below.
+*/
+phxsec_error_t
+phxsec_FillDescriptor(phxsec_io_pt op, void *desc, __u32 * cfg_vector)
+{
+	return phxsec_OneOffDescriptorSetup(op, 0,	/* no need to preserve anything */
+										(symkey_desc_pt) desc, cfg_vector);
+}
+
+/* Public interface to a per-packet descriptor setup */
+/*
+  The phxsec ioctl structure (see above) is zeroed out, and the per-packet
+  values are filled in before the call to this functions.
+  At this time, these values are: (NB: outdated list, needs to be updated)
+  
+  cipher_op
+  cipher_offset
+
+  digest_src
+  digest_offset
+
+  pkt_hmac
+  pkt_hash
+  pkt_hashbytes
+  pkt_next
+  pkt_iv
+  pkt_lastword
+
+  iv_offset
+
+  source_buf
+  source_buf_size
+  dest_buf
+  dest_buf_size
+
+  auth_dest
+*/
+phxsec_error_t
+phxsec_SetupDescriptor(phxsec_io_pt op, unsigned int flags,
+					   void *desc, __u32 vector)
+{
+	return phxsec_PerPacketDescriptorSetup(op, flags,
+										   (symkey_desc_pt) desc, vector);
+}
+
+/* this submits message to the hardware, and waits (or whatever) */
+static inline int
+phxsec_SubmitMessage(void *ctx, symkey_desc_pt desc, __u32 cfg_vector)
+{
+	phxsec_error_t err;
+	__u32 ctl_error, data_error;
+	int ret_val = 0;
+
+	PHXCMD_DIAG("phxsec_SubmitMessage:  ENTER\n");
+
+	err = PHXSEC_ERR_NONE;
+
+	PHXCMD_DIAG_SYM_DESC(desc, cfg_vector);
+
+	do {
+		/* For now, send message and wait for response */
+		err = phxsec_submit_op_wait(desc);
+
+		PHXCMD_DIAG("phxsec_SubmitMessage:  err = %d \n", (__u32) err);
+
+		if (err != PHXSEC_ERR_NONE) {
+			ret_val = (-ENODATA);
+			break;
+		}
+
+		ctl_error = desc->ctl_result;
+		data_error = desc->data_result;
+
+		PHXCMD_DIAG
+			("phxsec_SubmitMessage: ctl_error = %x   data_error = %x\n",
+			 ctl_error, data_error);
+
+		if ((ret_val = identify_symkey_ctl_error(ctl_error, err)) == 0)
+			ret_val = identify_symkey_data_error(data_error, err);
+
+		PHXCMD_DIAG("phxsec_SubmitMessage: identify error = %d \n", ret_val);
+
+	} while (0);
+
+	if ((err != PHXSEC_ERR_NONE) || (ret_val != 0))
+		phxdrv_record_sym_failed(stats, 0);
+
+
+	PHXCMD_DIAG("phxsec_SubmitMessage:  DONE\n");
+	return (ret_val);
+}
+
+/* the public interface to SubmitMessage */
+int phxsec_ProcessPacket(void *ctx, void *desc, __u32 cfg_vector)
+{
+	return phxsec_SubmitMessage(ctx, (symkey_desc_pt) desc, cfg_vector);
+}
+
+/*
+ * phxsec_BuildCipherDigestOp:  Build Descriptor for Cipher and Digest operations.
+ *
+ */
+int phxsec_CipherHashCommand(void *ctx, phxsec_io_pt op, symkey_desc_pt desc)
+{
+	phxsec_error_t err;
+	__u32 cfg_vector;
+	unsigned int setup_flags = 0;
+	driver_data_pt drvr = (driver_data_pt) ctx;
+
+	drvr = drvr;				/* !fix! */
+	err = PHXSEC_ERR_NONE;
+	cfg_vector = 0;
+
+	if ((op->digest_type == PHX_DIGEST_TYPE_NONE) &&
+		(op->cipher_type != PHX_CIPHER_TYPE_ARC4) &&
+		(op->cipher_mode != PHX_CIPHER_MODE_F8) &&
+		(op->cipher_type != PHX_CIPHER_TYPE_KASUMI_F8) &&
+		(op->source_buf_size & 0x7)) {
+		printk("Invalid Cipher Block Size, data len=%d\n",
+			   op->source_buf_size);
+		return (-EINVAL);
+	}
+
+	do {
+
+		if ((op->cipher_type == PHX_CIPHER_TYPE_3DES) &&
+			(op->cipher_op == PHX_CIPHER_OP_DECRYPT))
+			setup_flags = PHX_SETUP_OP_FLIP_3DES_KEY;
+
+		err = phxsec_OneOffDescriptorSetup(op,
+										   setup_flags, desc, &cfg_vector);
+		if (err != PHXSEC_ERR_NONE)
+			break;
+
+		err = packet_setup(op,
+						   op->digest_type != PHX_DIGEST_TYPE_NONE ?
+						   PHX_SETUP_OP_CIPHER_HMAC : 0,
+						   &desc->data,
+						   &desc->pkt_desc, &desc->ctl_desc, cfg_vector);
+		if (err != PHXSEC_ERR_NONE)
+			break;
+	} while (0);
+	if (err != PHXSEC_ERR_NONE) {
+		return (-ENODATA);
+	}
+
+	err = phxsec_SubmitMessage(ctx, desc, cfg_vector);
+
+	if (err == PHXSEC_ERR_NONE) {
+		/* first check if there is a digest op */
+		switch (op->digest_type) {
+			case PHX_DIGEST_TYPE_MD5:
+			case PHX_DIGEST_TYPE_HMAC_MD5:
+				phxdrv_record_md5(stats, op->source_buf_size);
+				break;
+			case PHX_DIGEST_TYPE_SHA1:
+			case PHX_DIGEST_TYPE_HMAC_SHA1:
+				phxdrv_record_sha1(stats, op->source_buf_size);
+				break;
+			case PHX_DIGEST_TYPE_SHA256:
+			case PHX_DIGEST_TYPE_HMAC_SHA256:
+				phxdrv_record_sha256(stats, op->source_buf_size);
+				break;
+			case PHX_DIGEST_TYPE_SHA384:
+			case PHX_DIGEST_TYPE_HMAC_SHA384:
+				phxdrv_record_sha384(stats, op->source_buf_size);
+				break;
+			case PHX_DIGEST_TYPE_SHA512:
+			case PHX_DIGEST_TYPE_HMAC_SHA512:
+				phxdrv_record_sha512(stats, op->source_buf_size);
+				break;
+			case PHX_DIGEST_TYPE_GCM:
+				phxdrv_record_gcm(stats, op->source_buf_size);
+				break;
+			case PHX_DIGEST_TYPE_KASUMI_F9:
+				phxdrv_record_kasumi_f9(stats, op->source_buf_size);
+				break;
+			case PHX_DIGEST_TYPE_UNSUPPORTED:
+			case PHX_DIGEST_TYPE_NONE:
+			default:
+				break;
+		}
+		/* now for the cipher */
+		switch (op->cipher_type) {
+			case PHX_CIPHER_TYPE_DES:
+				phxdrv_record_des(stats,
+								  (op->cipher_op ==
+								   PHX_CIPHER_OP_ENCRYPT) ? 1 : 0,
+								  op->source_buf_size);
+				break;
+			case PHX_CIPHER_TYPE_3DES:
+				phxdrv_record_3des(stats,
+								   (op->cipher_op ==
+									PHX_CIPHER_OP_ENCRYPT) ? 1 : 0,
+								   op->source_buf_size);
+				break;
+			case PHX_CIPHER_TYPE_AES128:
+			case PHX_CIPHER_TYPE_AES192:
+			case PHX_CIPHER_TYPE_AES256:
+				phxdrv_record_aes(stats,
+								  (op->cipher_op ==
+								   PHX_CIPHER_OP_ENCRYPT) ? 1 : 0,
+								  op->source_buf_size);
+				break;
+			case PHX_CIPHER_TYPE_ARC4:
+				phxdrv_record_arc4(stats,
+								   (op->cipher_op ==
+									PHX_CIPHER_OP_ENCRYPT) ? 1 : 0,
+								   op->source_buf_size);
+				break;
+			case PHX_CIPHER_TYPE_KASUMI_F8:
+				phxdrv_record_kasumi_f8(stats,
+										(op->cipher_op ==
+										 PHX_CIPHER_OP_ENCRYPT) ? 1 : 0,
+										op->source_buf_size);
+				break;
+			case PHX_CIPHER_TYPE_UNSUPPORTED:
+			case PHX_CIPHER_TYPE_NONE:
+				break;
+		}
+	}
+
+	return err;
+}
+
+/* This is used by the CryptoAPI to allocate a new symkey_desc_t descriptor,
+   which will be stored with the SA, and deallocated upon that SA's demise
+*/
+void *phxsec_AllocateDescriptor(void *ctx)
+{
+	driver_data_pt drvr = (driver_data_pt) ctx;
+	symkey_desc_pt desc;
+
+	drvr = drvr;				/* !fix! */
+	/* sanity check on the context */
+	if (ctx == NULL)
+		return (void *) NULL;
+
+	desc = phxsec_alloc_symkey_desc();
+	if (desc == NULL)
+		return (void *) NULL;
+
+	return (void *) desc;
+}
+
+int phxsec_FreeDescriptor(void *ctx, void *desc)
+{
+	driver_data_pt drvr = (driver_data_pt) ctx;
+
+	/* sanity check */
+	drvr = drvr;				/* !fix! */
+	if (ctx == NULL || desc == NULL)
+		return (-EINVAL);
+
+	phxsec_free_symkey_desc(desc);
+
+	return 0;
+}
+
+/******************************************************************
+ *
+ *  FUNCTION:      
+ *
+ *  CALLED FROM:   
+ *
+ *  PARAMETERS:    
+ * 
+ *  DESCRIPTION:
+ *
+ *
+ *
+ *  RETURNS:
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *****************************************************************/
+int phxsec_CipherDigestUserOp(void *ctx, phxsec_io_pt op)
+{
+	driver_data_pt drvr = (driver_data_pt) ctx;
+	symkey_desc_pt desc;
+	__u64 addr;
+	int size, ret_val;
+	int iv_len;
+
+	PHXCMD_DIAG(" ENTER   src_size=%d  dst_size=%d  \n",
+				op->source_buf_size, op->dest_buf_size);
+
+	drvr = drvr;				/* !fix! */
+	desc = phxsec_alloc_symkey_desc();
+	if (desc == NULL)
+		return (-ENOMEM);
+
+	if (op->flags & PHXSEC_FLAGS_HIGH_PRIORITY)
+		if (!is_xls())
+			desc->op_ctl.stn_id++;
+
+	desc->user.user_src = (__u8 *) (unsigned long) op->source_buf;
+	desc->user.user_dest = (__u8 *) (unsigned long) op->dest_buf;
+	desc->user.user_auth = (__u8 *) (unsigned long) op->auth_dest;
+
+	if ((op->cipher_type == PHX_CIPHER_TYPE_ARC4) &&
+		(!op->rc4_state && (op->rc4_loadstate || op->rc4_savestate))) {
+		printk(" ** Load/Save State and no State **");
+		phxsec_free_symkey_desc(desc);
+		return (-EINVAL);
+	}
+	desc->user.user_state = (__u8 *) (unsigned long) op->rc4_state;
+
+	switch (op->cipher_type) {
+		case PHX_CIPHER_TYPE_NONE:
+			iv_len = 0;
+			break;
+		case PHX_CIPHER_TYPE_DES:
+		case PHX_CIPHER_TYPE_3DES:
+			iv_len = PHXSEC_DES_IV_LENGTH;
+			break;
+		case PHX_CIPHER_TYPE_AES128:
+		case PHX_CIPHER_TYPE_AES192:
+		case PHX_CIPHER_TYPE_AES256:
+			iv_len = PHXSEC_AES_IV_LENGTH;
+			break;
+		case PHX_CIPHER_TYPE_ARC4:
+			iv_len = PHXSEC_ARC4_IV_LENGTH;
+			break;
+		case PHX_CIPHER_TYPE_KASUMI_F8:
+			iv_len = PHXSEC_KASUMI_F8_IV_LENGTH;
+			break;
+
+		default:
+			printk(" ** Undefined Cipher Type **");
+			phxsec_free_symkey_desc(desc);
+			return (-EINVAL);
+	}
+
+	size = op->source_buf_size + SMP_CACHE_BYTES + iv_len;
+
+	/* make sure that there are enough bytes for aes based stream ciphers */
+	if (op->cipher_mode == PHX_CIPHER_MODE_F8 ||
+		op->cipher_mode == PHX_CIPHER_MODE_CTR)
+		size += PHXSEC_AES_BLOCK_SIZE - 1;
+	/* 
+	 *  Build new source buffer 
+	 */
+	desc->user.kern_src = (__u8 *) OS_ALLOC_KERNEL(size);
+	if (desc->user.kern_src == NULL) {
+		printk("kmalloc() failed for kern_src: size=%d", size);
+		phxsec_free_symkey_desc(desc);
+		return (-ENOMEM);
+	}
+
+	/* find cacheline alignment */
+	addr = (__u64) virt_to_phys(desc->user.kern_src);
+	if (addr & (SMP_CACHE_BYTES - 1))
+		addr = (__u64) ((addr + SMP_CACHE_BYTES) & ~(SMP_CACHE_BYTES - 1));
+	desc->user.aligned_src = (__u8 *) phys_to_virt(addr);
+
+	if (op->cipher_type == PHX_CIPHER_TYPE_NONE) {
+		if (op->source_buf_size != 0 &&
+			copy_from_user(desc->user.aligned_src,
+						   (void *) (unsigned long) op->source_buf,
+						   op->source_buf_size)) {
+			printk("digest - copy_from_user(source) failed");
+			OS_FREE(desc->user.kern_src);
+			phxsec_free_symkey_desc(desc);
+			return (-EFAULT);
+		}
+	}
+	else {
+
+		/* copy IV into temporary kernel source buffer */
+		memcpy(desc->user.aligned_src, &op->initial_vector[0], iv_len);
+
+		/* copy input data to temporary kernel source buffer */
+		if (copy_from_user((__u8 *) (desc->user.aligned_src + iv_len),
+						   (void *) (unsigned long) op->source_buf,
+						   op->source_buf_size)) {
+			printk("cipher - copy_from_user(source) failed");
+			OS_FREE(desc->user.kern_src);
+			phxsec_free_symkey_desc(desc);
+			return (-EFAULT);
+		}
+		op->source_buf_size += iv_len;
+	}
+
+	/* Set source to new kernel space */
+	op->source_buf = (uint64_t) (unsigned long) desc->user.aligned_src;
+
+	/* 
+	 *  Build new dest buffer, for Cipher output only 
+	 */
+	if (op->cipher_type == PHX_CIPHER_TYPE_NONE) {
+		/* 
+		 *  Digest Engine *NEEDS* this, 
+		 *    otherwise it will write at 0[x] 
+		 */
+		op->dest_buf = (uint64_t) (unsigned long) desc->user.aligned_src;
+	}
+	else {
+
+		/* DEBUG -dpk */
+		PHXCMD_DIAG("dest_buf_size = %d \n", op->dest_buf_size);
+
+		size = op->dest_buf_size + SMP_CACHE_BYTES + iv_len;
+
+		/* make sure that there are enough bytes for aes based stream ciphers */
+		if (op->cipher_mode == PHX_CIPHER_MODE_F8 ||
+			op->cipher_mode == PHX_CIPHER_MODE_CTR)
+			size += PHXSEC_AES_BLOCK_SIZE - 1;
+
+		desc->user.kern_dest = (__u8 *) OS_ALLOC_KERNEL(size);
+
+		/* find cacheline alignment */
+		addr = (__u64) virt_to_phys(desc->user.kern_dest);
+		if (addr & (SMP_CACHE_BYTES - 1))
+			addr = (__u64) ((addr + SMP_CACHE_BYTES) &
+							~(SMP_CACHE_BYTES - 1));
+		desc->user.aligned_dest = (__u8 *) (unsigned long) phys_to_virt(addr);
+
+		memset(desc->user.kern_dest, 0, size);
+		op->dest_buf = (uint64_t) (unsigned long) desc->user.aligned_dest;
+	}
+
+	/* 
+	 *  Build new digest buffer, for Digest output only 
+	 */
+	if (op->digest_type != PHX_DIGEST_TYPE_NONE) {
+		size = PHXSEC_HMAC_LENGTH + SMP_CACHE_BYTES;
+
+		desc->user.kern_auth = (__u8 *) OS_ALLOC_KERNEL(size);
+
+		/* find cacheline alignment */
+		addr = (__u64) virt_to_phys(desc->user.kern_auth);
+		if (addr & (SMP_CACHE_BYTES - 1))
+			addr = (__u64) ((addr + SMP_CACHE_BYTES) &
+					~(SMP_CACHE_BYTES - 1));
+		desc->user.aligned_auth = (__u8 *) phys_to_virt(addr);
+
+		memset(desc->user.kern_auth, 0, size);
+		op->auth_dest = (uint64_t) (unsigned long) desc->user.aligned_auth;
+	}
+
+	ret_val = phxsec_CipherHashCommand(ctx, op, desc);
+
+	if (ret_val == 0) {
+
+		/* Copy cipher-data to User-space */
+		if (op->cipher_type != PHX_CIPHER_TYPE_NONE) {
+
+			size = op->dest_buf_size;
+
+			/* DEBUG -dpk */
+			PHXCMD_DIAG("cipher: to_addr=%p  from_addr=%p  size=%d \n",
+						desc->user.user_dest, desc->user.aligned_dest, size);
+
+			if (copy_to_user(desc->user.user_dest,
+							 (void *) (desc->user.aligned_dest +
+									   op->cipher_offset), size)) {
+				printk("cipher - copy_to_user(dest) failed to_addr=%p\
+						from_addr=%p  size=%d \n",
+						desc->user.user_dest, desc->user.aligned_dest, size);
+				phxsec_free_symkey_desc(desc);
+				ret_val = (-EFAULT);
+			}
+			OS_FREE(desc->user.kern_dest);
+			op->dest_buf = (uint64_t) (unsigned long) desc->user.user_dest;
+		}
+
+		/* Copy digest to User-space */
+		if (op->digest_type != PHX_DIGEST_TYPE_NONE) {
+
+			int offset = 0;
+			switch (op->digest_type) {
+				case PHX_DIGEST_TYPE_MD5:
+					size = PHXSEC_MD5_LENGTH;
+					break;
+				case PHX_DIGEST_TYPE_SHA1:
+					size = PHXSEC_SHA1_LENGTH;
+					break;
+				case PHX_DIGEST_TYPE_SHA256:
+					size = PHXSEC_SHA256_LENGTH;
+					break;
+				case PHX_DIGEST_TYPE_SHA384:
+					size = PHXSEC_SHA384_LENGTH;
+					break;
+				case PHX_DIGEST_TYPE_SHA512:
+					size = PHXSEC_SHA512_LENGTH;
+					break;
+				case PHX_DIGEST_TYPE_GCM:
+					size = PHXSEC_GCM_LENGTH;
+					break;
+				case PHX_DIGEST_TYPE_KASUMI_F9:
+					offset = 4;
+					size = PHXSEC_KASUMI_F9_RESULT_LENGTH;
+					break;
+				default:
+					size = 0;
+			}
+
+			PHXCMD_DIAG("digest:  to_addr=%p  from_addr=%p  size=%d \n",
+						desc->user.user_auth, desc->user.aligned_auth, size);
+
+			if (copy_to_user(desc->user.user_auth,
+							 desc->user.aligned_auth + offset, size)) {
+				printk("digest - copy_to_user(dest) failed");
+				phxsec_free_symkey_desc(desc);
+				ret_val = (-EFAULT);
+			}
+			OS_FREE(desc->user.kern_auth);
+			op->auth_dest = (uint64_t) (unsigned long) desc->user.user_auth;
+		}
+
+		if (op->cipher_type == PHX_CIPHER_TYPE_ARC4 && op->rc4_savestate) {
+
+			size = PHXSEC_MAX_RC4_STATE_SIZE;
+
+			PHXCMD_DIAG("state:  to_addr=%p  from_addr=%p  size=%d \n",
+						desc->user.user_state, desc->user.aligned_state,
+						size);
+
+			if (copy_to_user(desc->user.user_state,
+							 desc->user.aligned_state, size)) {
+				printk("state - copy_to_user(dest) failed");
+				phxsec_free_symkey_desc(desc);
+				ret_val = (-EFAULT);
+			}
+			op->rc4_state = (uint64_t) (unsigned long) desc->user.user_state;
+		}
+	}
+	op->source_buf = (uint64_t) (unsigned long) desc->user.user_src;
+	OS_FREE(desc->user.kern_src);
+
+	phxsec_free_symkey_desc(desc);
+
+	return (ret_val);
+}
+
+
+/*
+ * phxsec_modexp_setup:  compute modular exponential y = x^e mod m.
+ */
+static phxsec_error_t phxsec_modexp_setup(phxsec_RSA_op_pt op,
+									   pubkey_desc_pt desc)
+{
+	__u64 addr40;
+
+	/*
+	 * We only support 512 and 1024 block size 
+	 */
+	if (op->modulus.bignum_length <= 512) {
+		SET_FIELD(desc->control0,
+				  PUBKEY_CTL_BLKWIDTH, PUBKEY_CTL_BLKWIDTH_512);
+	}
+	else if (op->modulus.bignum_length <= 1024) {
+		SET_FIELD(desc->control0,
+				  PUBKEY_CTL_BLKWIDTH, PUBKEY_CTL_BLKWIDTH_1024);
+	}
+	else
+		return -1;				/* !fix me! */
+
+#ifdef PREVIOUS_SESSION_KNOWLEDGE
+	/* if previous session the same as current, we can reuse the loaded value */
+	SET_FIELD(desc->control0, PUBKEY_CTL_LD_CONST, PUBKEY_CTL_LD_CONST_OLD);
+#else
+	SET_FIELD(desc->control0, PUBKEY_CTL_LD_CONST, PUBKEY_CTL_LD_CONST_NEW);
+#endif
+
+	SET_FIELD(desc->control0, PUBKEY_CTL_EXPWIDTH,
+			  op->exponent.bignum_length);
+
+	SET_FIELD(desc->control1, PUBKEY_CTL1_MODWIDTH,
+			  op->modulus.bignum_length);
+
+	addr40 = (__u64) virt_to_phys((void *) (unsigned long) op->data_in);
+	SET_FIELD(desc->control0, PUBKEY_CTL_SRCADDR, addr40);
+	addr40 = (__u64) virt_to_phys((void *) (unsigned long) op->data_out);
+	SET_FIELD(desc->control1, PUBKEY_CTL1_DSTADDR, addr40);
+
+	SET_FIELD(desc->control0, PUBKEY_CTL_CTL, SEC_SOP);
+	SET_FIELD(desc->control1, PUBKEY_CTL_CTL, SEC_EOP);
+
+	SET_FIELD(desc->control0, PUBKEY_CTL_VALID, PUBKEY_CTL_VALID_TRUE);
+
+	return PHXSEC_ERR_NONE;
+}
+
+/*
+ * phxsec_ecc_setup: perform ecc operations
+ */
+static phxsec_error_t
+phxsec_ecc_setup(phxsec_ECC_op_pt op, pubkey_desc_pt desc)
+{
+	__u64 addr40;
+
+	SET_FIELD(desc->control0, PUBKEY_CTL_OP_CLASS, PUBKEY_CTL_OP_CLASS_ECC);
+	switch (op->degree) {
+		case PHX_ECC_LOAD:
+			SET_FIELD(desc->control0, PUBKEY_CTL_ECC_TYPE,
+					  PUBKEY_CTL_ECC_TYPE_UC_LOAD);
+			break;
+		case 160:
+			SET_FIELD(desc->control0, PUBKEY_CTL_ECC_TYPE,
+					  PUBKEY_CTL_ECC_TYPE_PRIME_160);
+			break;
+		case 192:
+			SET_FIELD(desc->control0, PUBKEY_CTL_ECC_TYPE,
+					  PUBKEY_CTL_ECC_TYPE_PRIME_192);
+			break;
+		case 224:
+			SET_FIELD(desc->control0, PUBKEY_CTL_ECC_TYPE,
+					  PUBKEY_CTL_ECC_TYPE_PRIME_224);
+			break;
+		case 256:
+			SET_FIELD(desc->control0, PUBKEY_CTL_ECC_TYPE,
+					  PUBKEY_CTL_ECC_TYPE_PRIME_256);
+			break;
+		case 384:
+			SET_FIELD(desc->control0, PUBKEY_CTL_ECC_TYPE,
+					  PUBKEY_CTL_ECC_TYPE_PRIME_384);
+			break;
+		case 512:
+			SET_FIELD(desc->control0, PUBKEY_CTL_ECC_TYPE,
+					  PUBKEY_CTL_ECC_TYPE_PRIME_512);
+			break;
+		case 163:
+			SET_FIELD(desc->control0, PUBKEY_CTL_ECC_TYPE,
+					  PUBKEY_CTL_ECC_TYPE_BIN_163);
+			break;
+		case 191:
+			SET_FIELD(desc->control0, PUBKEY_CTL_ECC_TYPE,
+					  PUBKEY_CTL_ECC_TYPE_BIN_191);
+			break;
+		case 233:
+			SET_FIELD(desc->control0, PUBKEY_CTL_ECC_TYPE,
+					  PUBKEY_CTL_ECC_TYPE_BIN_233);
+			break;
+	}
+	switch (op->op) {
+		case PHX_ECC_NOP:
+			SET_FIELD(desc->control0, PUBKEY_CTL_ECC_FUNCTION,
+					  PUBKEY_CTL_ECC_FUNCTION_NOP);
+			break;
+		case PHX_ECC_MUL:
+		case PHX_ECC_BIN_MUL:
+			SET_FIELD(desc->control0, PUBKEY_CTL_ECC_FUNCTION,
+					  PUBKEY_CTL_ECC_FUNCTION_POINT_MUL);
+			break;
+		case PHX_ECC_ADD:
+		case PHX_ECC_FIELD_BIN_INV:
+			SET_FIELD(desc->control0, PUBKEY_CTL_ECC_FUNCTION,
+					  PUBKEY_CTL_ECC_FUNCTION_POINT_ADD);
+			break;
+		case PHX_ECC_DBL:
+		case PHX_ECC_FIELD_BIN_MUL:
+			SET_FIELD(desc->control0, PUBKEY_CTL_ECC_FUNCTION,
+					  PUBKEY_CTL_ECC_FUNCTION_POINT_DBL);
+			break;
+		case PHX_ECC_VFY:
+		case PHX_ECC_FIELD_BIN_ADD:
+			SET_FIELD(desc->control0, PUBKEY_CTL_ECC_FUNCTION,
+					  PUBKEY_CTL_ECC_FUNCTION_POINT_VFY);
+			break;
+		case PHX_ECC_FIELD_ADD:
+			SET_FIELD(desc->control0, PUBKEY_CTL_ECC_FUNCTION,
+					  PUBKEY_CTL_ECC_FUNCTION_MODULAR_ADD);
+			break;
+		case PHX_ECC_FIELD_SUB:
+			SET_FIELD(desc->control0, PUBKEY_CTL_ECC_FUNCTION,
+					  PUBKEY_CTL_ECC_FUNCTION_MODULAR_SUB);
+			break;
+		case PHX_ECC_FIELD_MUL:
+			SET_FIELD(desc->control0, PUBKEY_CTL_ECC_FUNCTION,
+					  PUBKEY_CTL_ECC_FUNCTION_MODULAR_MUL);
+			break;
+		case PHX_ECC_FIELD_DIV:
+			SET_FIELD(desc->control0, PUBKEY_CTL_ECC_FUNCTION,
+					  PUBKEY_CTL_ECC_FUNCTION_MODULAR_DIV);
+			break;
+		case PHX_ECC_FIELD_INV:
+			SET_FIELD(desc->control0, PUBKEY_CTL_ECC_FUNCTION,
+					  PUBKEY_CTL_ECC_FUNCTION_MODULAR_INV);
+			break;
+		case PHX_ECC_FIELD_RED:
+			SET_FIELD(desc->control0, PUBKEY_CTL_ECC_FUNCTION,
+					  PUBKEY_CTL_ECC_FUNCTION_MODULAR_RED);
+			break;
+		case PHX_ECC_FIELD:
+		case PHX_ECC_BIN:
+			break;
+	}
+
+	addr40 = (__u64) virt_to_phys((void *) (unsigned long) op->data_in);
+	SET_FIELD(desc->control0, PUBKEY_CTL_SRCADDR, addr40);
+	addr40 = (__u64) virt_to_phys((void *) (unsigned long) op->data_out);
+	SET_FIELD(desc->control1, PUBKEY_CTL1_DSTADDR, addr40);
+
+	SET_FIELD(desc->control0, PUBKEY_CTL_CTL, SEC_SOP);
+	SET_FIELD(desc->control1, PUBKEY_CTL_CTL, SEC_EOP);
+
+	SET_FIELD(desc->control0, PUBKEY_CTL_VALID, PUBKEY_CTL_VALID_TRUE);
+
+	return PHXSEC_ERR_NONE;
+}
+
+static int identify_pubkey_error(__u32 ctl_code, __u32 data_code)
+{
+	int ret_val = -EINVAL;
+
+	switch (ctl_code) {
+		case PK_CTL_ERR_NONE:
+			PHXPKCMD_DIAG("PHXSEC: PUBKEY CTL Error: * No Error * \n");
+			ret_val = 0;
+			break;
+		case PK_CTL_ERR_READ:
+			PHXPKCMD_DIAG("PHXSEC: PUBKEY CTL Error: * Data Read Error * \n");
+			break;
+		case PK_CTL_ERR_OP_CLASS:
+			PHXPKCMD_DIAG
+				("PHXSEC: PUBKEY CTL Error: * Undefined Op Class Error * \n");
+			break;
+		case PK_CTL_ERR_ECC_TYPE:
+			PHXPKCMD_DIAG
+				("PHXSEC: PUBKEY CTL Error: * Undefined ECC Type Error * \n");
+			break;
+		case PK_CTL_ERR_ECC_FUNCT:
+			PHXPKCMD_DIAG
+				("PHXSEC: PUBKEY CTL Error: * Undefined ECC Function Error * \n");
+			break;
+		case PK_CTL_ERR_ECC_TIMEOUT:
+			PHXPKCMD_DIAG
+				("PHXSEC: PUBKEY CTL Error: * ECC Timeout Error * \n");
+			break;
+		case PK_CTL_ERR_DESC:
+			PHXPKCMD_DIAG
+				("PHXSEC: PUBKEY CTL Error: * Descriptor Ctrl Field Error"
+				 " (D0.Ctrl != SOP || D1.Ctrl != EOP) * \n");
+			break;
+		case PK_CTL_ERR_TIMEOUT:
+			PHXPKCMD_DIAG("PHXSEC: PUBKEY CTL Error: * TIMEOUT * \n");
+			break;
+		default:
+			PHXPKCMD_DIAG("PHXSEC: PUBKEY CTL Error - UNKNOWN CODE=%d \n",
+						  ctl_code);
+			break;
+	}
+
+	switch (data_code) {
+		case PK_DATA_ERR_NONE:
+			PHXPKCMD_DIAG("PHXSEC: PUBKEY DATA Error: * No Error * \n");
+			break;
+		case PK_DATA_ERR_EXP_WIDTH:
+			PHXPKCMD_DIAG("PHXSEC: PUBKEY DATA Error: "
+						  "* Exponent Width > Block Width * \n");
+			break;
+		case PK_DATA_ERR_MOD_WIDTH:
+			PHXPKCMD_DIAG("PHXSEC: PUBKEY DATA Error: "
+						  "* Modulus Width  > Block Width * \n");
+			break;
+		case PK_DATA_ERR_READ:
+			PHXPKCMD_DIAG
+				("PHXSEC: PUBKEY DATA Error: * Data Read Error * \n");
+			break;
+		default:
+			PHXPKCMD_DIAG("PHXSEC: PUBKEY DATA Error - UNKNOWN CODE=%d \n",
+						  data_code);
+			break;
+	}
+	return ret_val;
+}
+
+
+/**************************************************************************
+ *
+ *  FUNCTION:      
+ *
+ *  CALLED FROM:   
+ *
+ *  PARAMETERS:    
+ * 
+ *  DESCRIPTION:
+ *
+ *
+ *
+ *  RETURNS:
+ *
+ *************************************************************************/
+static int reverse_word64_array(__u64 * base, int num_words)
+{
+	__u64 temp;
+	int i, hi;
+
+	if (num_words < 2)
+		return (num_words);
+
+	for (i = 0; i < (num_words >> 1); i++) {
+		hi = num_words - 1 - i;
+		temp = base[hi];
+		base[hi] = base[i];
+		base[i] = temp;
+	}
+	return (i);
+}
+
+
+/**************************************************************************
+ *
+ *  FUNCTION:      
+ *
+ *  CALLED FROM:   
+ *
+ *  PARAMETERS:    
+ * 
+ *  DESCRIPTION:
+ *
+ *
+ *
+ *  RETURNS:
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+int phxsec_PublicKeyUserOp(void *ctx, phxsec_key_io_pt op)
+{
+	driver_data_pt drvr = (driver_data_pt) ctx;
+	__u8 *mem;
+	__u64 *word64;
+	pubkey_desc_pt desc;
+	int size, offset, word64_source;
+	int word8_con, word8_exp, word8_mod, word8_msg;
+	int word64_con, word64_exp, word64_mod, word64_msg;
+	int ret_val = 0;
+
+	PHXPKCMD_DIAG("phxsec_PublicKeyUserOp: ENTER  \n");
+
+	drvr = drvr;				/* !fix! */
+	if ((desc = phxsec_alloc_pubkey_desc()) == NULL)
+		return (-ENOMEM);
+
+	do {
+
+		/* 
+		 * Calculate Source buffer offsets and size (64-bit words)
+		 */
+		size = op->key.RSA_params.constant.bignum_length;	/* bits */
+		word8_con = BITS2BYTES(size);	/* bytes */
+		word64_con = NUM_CHUNKS(word8_con, 3);	/* 64-bit words */
+
+		size = op->key.RSA_params.exponent.bignum_length;
+		word8_exp = BITS2BYTES(size);
+		word64_exp = NUM_CHUNKS(word8_exp, 3);
+
+		size = op->key.RSA_params.modulus.bignum_length;
+		word8_mod = BITS2BYTES(size);
+		word64_mod = NUM_CHUNKS(word8_mod, 3);
+
+		size = op->key.RSA_params.data_in_len;
+		word8_msg = BITS2BYTES(size);
+		word64_msg = NUM_CHUNKS(word8_msg, 3);
+
+		/* zero the source buffer */
+		memset(&desc->source[0], 0, sizeof(desc->source));
+
+		/* setup pointers to source buffer for factors */
+		mem = &desc->source[0];
+		word64 = (__u64 *) & desc->source[0];
+		word64_source = 0;
+
+
+		/*
+		 * Setup the Source Buffer
+		 *   word64[0]:           Constant
+		 *   word64[word64_con]:  Exponent
+		 *   word64[word64_exp]:  Modulus 
+		 *   word64[word64_mod]:  Message 
+		 *
+		 *   Values are stored in Big-Endian order (bit63->bit0)
+		 *   Also known as right-justified.
+		 *
+		 */
+
+		/* 
+		 *  Setup the Constant 
+		 */
+		offset = (word8_con & 0x7);
+		if (offset != 0)
+			offset = sizeof(uint64_t) - offset;
+		if (copy_from_user(&mem[offset], (void *) (unsigned long)
+						   op->key.RSA_params.constant.bignum, word8_con)) {
+			printk("ModExp: copy_from_user(constant) failed\n");
+			ret_val = (-EFAULT);
+			break;
+		}
+		PHXPKCMD_DIAG("CONSTANT LENGTH:  %d (bits)  %d (bytes)  offset=%d\n",
+					  op->key.RSA_params.constant.bignum_length, word8_con,
+					  offset);
+		PHXPKCMD_DIAG
+			("CONSTANT ADDR:  USER_PTR=%llx  KERN_PTR=%p  SRC_PTR=%p\n",
+			 (unsigned long long) op->key.RSA_params.constant.bignum, mem,
+			 &mem[offset]);
+		PHXPKCMD_DIAG_BUF("CONSTANT", mem, word8_con);
+
+		reverse_word64_array((uint64_t *) mem, word64_con);
+
+		PHXPKCMD_DIAG_BUF("CONSTANT-REV", mem, word8_con);
+
+		/* 
+		 *  Setup the Exponent 
+		 */
+		/*store exponent next word64 after constant */
+		word64_source = word64_con;
+		mem = (unsigned char *) &word64[word64_source];
+		offset = (word8_exp & 0x7);
+		if (offset != 0)
+			offset = sizeof(uint64_t) - offset;
+
+		if (copy_from_user(&mem[offset], (void *) (unsigned long)
+						   op->key.RSA_params.exponent.bignum, word8_exp)) {
+			printk("ModExp: copy_from_user(exponent) failed\n");
+			ret_val = (-EFAULT);
+			break;
+		}
+
+		PHXPKCMD_DIAG("EXPONENT LENGTH:  %d (bits)  %d (bytes)  offset=%d\n",
+					  op->key.RSA_params.exponent.bignum_length, word8_exp,
+					  offset);
+		PHXPKCMD_DIAG
+			("EXPONENT ADDR:  USER_PTR=%llx  KERN_PTR=%p  SRC_PTR=%p\n",
+			 (unsigned long long) op->key.RSA_params.exponent.bignum, mem,
+			 &mem[offset]);
+		PHXPKCMD_DIAG_BUF("EXPONENT", mem, word8_exp);
+
+		reverse_word64_array((__u64 *) mem, word64_exp);
+
+		PHXPKCMD_DIAG_BUF("EXPONENT-REV", mem, word8_exp);
+
+		/* 
+		 *  Setup the Modulus 
+		 */
+		/*store modulus next word64 after exponent */
+		word64_source += word64_exp;
+		mem = (unsigned char *) &word64[word64_source];
+		offset = (word8_mod & 0x7);
+		if (offset != 0)
+			offset = sizeof(uint64_t) - offset;
+
+		if (copy_from_user(&mem[offset], (void *) (unsigned long)
+						   op->key.RSA_params.modulus.bignum, word8_mod)) {
+			printk("ModExp: copy_from_user(modulus) failed\n");
+			ret_val = (-EFAULT);
+			break;
+		}
+		PHXPKCMD_DIAG("MODULUS LENGTH:  %d (bits)  %d (bytes)  offset=%d\n",
+					  op->key.RSA_params.modulus.bignum_length, word8_mod,
+					  offset);
+		PHXPKCMD_DIAG
+			("MODULUS ADDR:  USER_PTR=%llx  KERN_PTR=%p  SRC_PTR=%p\n",
+			 (unsigned long long) op->key.RSA_params.modulus.bignum, mem,
+			 &mem[offset]);
+		PHXPKCMD_DIAG_BUF("MODULUS", mem, word8_mod);
+
+		reverse_word64_array((__u64 *) mem, word64_mod);
+
+		PHXPKCMD_DIAG_BUF("MODULUS-REV", mem, word8_mod);
+
+
+		/* 
+		 *  Setup the Message 
+		 */
+		/*store message next word64 after modulus */
+		word64_source += word64_mod;
+		mem = (unsigned char *) &word64[word64_source];
+
+		if (op->key.RSA_params.modulus.bignum_length <= 512) {
+			/* fill 64 bytes */
+			word64_msg = 8;
+			offset = 64 - word8_msg;
+		}
+		else if (op->key.RSA_params.modulus.bignum_length <= 1024) {
+			/* fill 128 bytes */
+			word64_msg = 16;
+			offset = 128 - word8_msg;
+		}
+		else {
+			printk("ModExp: Invalid Block Size, size=%d\n",
+				   op->key.RSA_params.modulus.bignum_length);
+			ret_val = (-EFAULT);
+			break;
+		}
+
+		if (copy_from_user(&mem[offset],
+						   (void *) (unsigned long) op->key.RSA_params.
+						   data_in, word8_msg)) {
+			printk("ModExp: copy_from_user(message) failed\n");
+			ret_val = (-EFAULT);
+			break;
+		}
+
+		PHXPKCMD_DIAG("MESSAGE LENGTH:  %d (bits)  %d (bytes)  offset=%d\n",
+					  op->key.RSA_params.data_in_len, word8_msg, offset);
+		PHXPKCMD_DIAG
+			("MESSAGE ADDR:  USER_PTR=%llx  KERN_PTR=%p   SRC_PTR=%p\n",
+			 (unsigned long long) op->key.RSA_params.data_in, mem,
+			 &mem[offset]);
+		PHXPKCMD_DIAG_BUF("MESSAGE", mem, word8_msg);
+
+		reverse_word64_array((__u64 *) mem, word64_msg);
+
+		PHXPKCMD_DIAG_BUF("MESSAGE-REV", mem, word8_msg);
+
+		/* store source address for engine */
+		op->key.RSA_params.data_in =
+			(uint64_t) (unsigned long) &desc->source[0];
+
+		/* 
+		 * Allocate Destination buffer size (64-bit words) 
+		 */
+		size = op->key.RSA_params.data_out_len;
+		size = BITS2BYTES(size);
+
+		mem = &desc->dest[0];
+		memset(mem, 0, sizeof(desc->dest));
+
+		/*save User-space pointer */
+		desc->kern.user_result = (uint8_t *) (unsigned long)
+			op->key.RSA_params.data_out;
+		desc->kern.result_length = size;	/* save for result */
+
+		op->key.RSA_params.data_out = (uint64_t) (unsigned long) mem;	/* store for setup() */
+
+		PHXPKCMD_DIAG("RESULT LENGTH:  %d (bits)  %d (bytes)\n",
+					  op->key.RSA_params.data_out_len, size);
+		PHXPKCMD_DIAG("RESULT USER ADDR:  PTR=%p \n", desc->kern.user_result);
+		PHXPKCMD_DIAG("RESULT VIRT ADDR:  PTR=%p \n", mem);
+
+	} while (0);
+
+	if (ret_val == 0) {
+		phxsec_error_t err;
+
+		err = phxsec_modexp_setup(&op->key.RSA_params, desc);
+		if (err != PHXSEC_ERR_NONE) {
+			ret_val = (-EINVAL);
+		}
+		else {
+
+			err = phxsec_submit_pkop_wait(desc);
+		}
+
+		if (err != PHXSEC_ERR_NONE) {
+			ret_val = (-ENODATA);
+			phxdrv_record_modexp_failed(stats, 0);
+		}
+		else {
+			ret_val = identify_pubkey_error(desc->ctl_result,
+											desc->data_result);
+		}
+
+		if ((err == PHXSEC_ERR_NONE) && (ret_val == 0)) {
+			PHXPKCMD_DIAG("OUTPUT LENGTH:  %d (bits)  %d (bytes)\n",
+						  op->key.RSA_params.data_out_len,
+						  desc->kern.result_length);
+
+			mem = &desc->dest[0];
+			word64 = (__u64 *) & desc->dest[0];
+
+			PHXPKCMD_DIAG_BUF("OUTPUT: ", mem, desc->kern.result_length);
+
+			word64_source = NUM_CHUNKS(desc->kern.result_length, 3);
+
+			reverse_word64_array((uint64_t *) mem, word64_source);
+
+			PHXPKCMD_DIAG_BUF("OUTPUT-REV: ", mem, desc->kern.result_length);
+
+			/* Copy data to User-space */
+			if (copy_to_user(desc->kern.user_result,
+							 &desc->dest[0], desc->kern.result_length)) {
+				printk("ModExp: copy_to_user(data_out) failed\n");
+				ret_val = (-EFAULT);
+			}
+
+			phxdrv_record_modexp(stats, (word64_msg << 6));
+
+#ifdef DESC_DUMP_ON
+			{
+				static unsigned long count = 0;
+
+				count++;
+				if ((count % 1000) == 0) {
+					printk("PKOP - **GOOD ONE ** \n");
+					decode_pubkey_desc(desc);
+				}
+			}
+#endif
+		}
+		else {
+			phxdrv_record_modexp_failed(stats, 0);
+		}
+	}
+
+	phxsec_free_pubkey_desc(desc);
+
+	return (ret_val);
+}
+
+/**************************************************************************
+ *
+ *  FUNCTION: phxsec_ecc_init
+ *
+ *  CALLED FROM: rmisec_init
+ *
+ *  PARAMETERS: none
+ *
+ *  DESCRIPTION: sends the ECC init message to the security engine
+ *
+ *  RETURNS:
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+int phxsec_ecc_init(void)
+{
+	unsigned long flags = 0;
+	struct msgrng_msg send_msg;
+	int code;
+	int cpu, hard_cpu, hard_thread, rsp_dest_id;
+	/* threads (0-3) are orthogonal to buckets 0-3 */
+	cpu = cpu_logical_map(smp_processor_id());
+	hard_cpu = cpu >> 2;
+	hard_thread = cpu & 0x3;	/* thread id */
+	rsp_dest_id = (hard_cpu << 3) + hard_thread;
+
+
+	send_msg.msg0 = send_msg.msg1 = send_msg.msg2 = send_msg.msg3 = 0;
+	SET_FIELD(send_msg.msg0, PUBKEY_CTL_OP_CLASS, PUBKEY_CTL_OP_CLASS_ECC);
+	SET_FIELD(send_msg.msg0, PUBKEY_CTL_ECC_TYPE,
+			  PUBKEY_CTL_ECC_TYPE_UC_LOAD);
+	SET_FIELD(send_msg.msg0, PUBKEY_CTL_SRCADDR,
+			  (uint64_t) virt_to_phys(&ecc_uc_data));
+	SET_FIELD(send_msg.msg0, PUBKEY_CTL_CTL, SEC_SOP);
+	SET_FIELD(send_msg.msg0, PUBKEY_CTL_VALID, PUBKEY_CTL_VALID_TRUE);
+	SET_FIELD(send_msg.msg1, PUBKEY_CTL_CTL, SEC_EOP);
+	SET_FIELD(send_msg.msg1, MSG_CMD_CTL_ID, rsp_dest_id);
+	SET_FIELD(send_msg.msg0, MSG_CTL_OP_TYPE, MSG0_CTL_OP_ENGINE_PUBKEY);
+	SET_FIELD(send_msg.msg1, MSG_CTL_OP_TYPE, MSG1_CTL_OP_SYMKEY_PIPE1);
+
+	while (1) {
+
+		__sync();
+		msgrng_flags_save(flags);
+		code = message_send_retry(SEC_MSGRING_WORDSIZE,
+								  MSGRNG_CODE_SEC,
+								  MSGRNG_STNID_XLS_PK0, &send_msg);
+		msgrng_flags_restore(flags);
+
+		if (likely(code == 0))	/* message sent */
+			break;
+	}
+
+	return 0;
+}
+
+/**************************************************************************
+ *
+ *  FUNCTION: copy_from_bignum
+ *
+ *  CALLED FROM: phxsec_ecc
+ *
+ *  PARAMETERS: word64, bignum, len
+ *
+ *  DESCRIPTION: copies a bignum to the security engine input buffer
+ *
+ *  RETURNS: new address
+ *
+ *************************************************************************/
+static uint64_t *copy_from_bignum(uint64_t * word64, phxsec_bignum_t * bignum,
+								  int len)
+{
+	int offset, size = bignum->bignum_length;
+	int word8_num = BITS2BYTES(size);
+	int word64_num = NUM_CHUNKS(word8_num, 3);
+	unsigned char *mem;
+
+	mem = (unsigned char *) &word64[len - word64_num];
+	offset = (word8_num & 0x7);
+	if (offset != 0)
+		offset = sizeof(uint64_t) - offset;
+	if (copy_from_user
+		((char *) &mem[offset], (void *) (unsigned long) bignum->bignum,
+		 word8_num)) {
+		printk("ECC: copy_from_user(BN) failed\n");
+		return 0;
+	}
+	PHXPKCMD_DIAG("BN LENGTH:  %d (bits)  %d (bytes)  offset=%d\n",
+				  bignum->bignum_length, word8_num, offset);
+	PHXPKCMD_DIAG("BN ADDR:  USER_PTR=%llx  KERN_PTR=%p  SRC_PTR=%p\n",
+				  (unsigned long long) bignum->bignum, mem, &mem[offset]);
+	PHXPKCMD_DIAG_BUF("BN", word64, len << 3);
+
+	reverse_word64_array(word64, len);
+
+	PHXPKCMD_DIAG_BUF("BN-REV", word64, len << 3);
+
+	return (word64 + len);
+}
+
+/**************************************************************************
+ *
+ *  FUNCTION: copy_to_bignum
+ *
+ *  CALLED FROM: phxsec_ecc
+ *
+ *  PARAMETERS: word64, bignum, len
+ *
+ *  DESCRIPTION: copies a bignum from the security engine input buffer
+ *
+ *  RETURNS: new address
+ *
+ *************************************************************************/
+static uint64_t *copy_to_bignum(uint64_t * word64, phxsec_bignum_t * bignum,
+								char *mem, int len)
+{
+
+	int bignum_length, i;
+	PHXPKCMD_DIAG_BUF("OUTPUT BN: ", (char *) word64, len << 3);
+
+	reverse_word64_array(word64, len);
+
+	PHXPKCMD_DIAG_BUF("OUTPUT BN-REV: ", (char *) word64, len << 3);
+
+	for (i = 0; i < (len << 3); i++)
+		if (mem[i])
+			break;
+
+	bignum_length = ((len << 3) - i) << 3;
+	/* Copy length to User-space done in rmisec_write */
+	bignum->bignum_length = bignum_length;
+	/* Copy data to User-space */
+	if (copy_to_user
+		((void *) (unsigned long) bignum->bignum, (char *) &mem[i],
+		 bignum->bignum_length >> 3)) {
+		printk("ECC: copy_to_user(BN) failed\n");
+		return 0;
+	}
+
+	return (word64 + len);
+}
+
+/**************************************************************************
+ *
+ *  FUNCTION: phxsec_ecc
+ *
+ *  CALLED FROM: rmisec_write
+ *
+ *  PARAMETERS: ctx, phxsec_key_io_pt
+ * 
+ *  DESCRIPTION: routes ECC operations to the security engine
+ *
+ *  RETURNS:
+ *                == 0   =>   Success
+ *                != 0   =>   Failure
+ *
+ *************************************************************************/
+int phxsec_ecc(void *ctx, phxsec_key_io_pt op)
+{
+	__u8 *mem;
+	__u64 *word64;
+	pubkey_desc_pt desc;
+	int len, k_len;
+	int ret_val = 0;
+
+	PHXPKCMD_DIAG("phxsec_ecc: ENTER  \n");
+
+	if ((desc = phxsec_alloc_pubkey_desc()) == NULL)
+		return (-ENOMEM);
+
+	do {
+
+		/* 
+		 * Calculate Source buffer offsets and size (64-bit words)
+		 */
+		len = NUM_CHUNKS(op->key.ECC_params.degree, 6);
+		k_len = NUM_CHUNKS(op->key.ECC_params.degree, 8);
+
+		/* zero the source buffer */
+		memset(&desc->source[0], 0, sizeof(desc->source));
+
+		/* setup pointers to source buffer for factors */
+		word64 = (__u64 *) & desc->source[0];
+
+		/*
+		 * Setup the Source Buffer
+		 *
+		 *   Values are stored in Big-Endian order (bit63->bit0)
+		 *   Also known as right-justified.
+		 *
+		 */
+
+		if (op->key.ECC_params.op == PHX_ECC_BIN_MUL) {
+			/*
+			 *  Setup b
+			 */
+			if (!(word64 =
+					copy_from_bignum(word64, &op->key.ECC_params.b, len))) {
+				ret_val = (-EFAULT);
+				break;
+			}
+			/*
+			 *  Setup k
+			 */
+			if (!(word64 =
+					copy_from_bignum(word64, &op->key.ECC_params.k, len))) {
+				ret_val = (-EFAULT);
+				break;
+			}
+		}
+		/* 
+		 *  Setup x
+		 */
+		if (!(word64 = copy_from_bignum(word64, &op->key.ECC_params.x, len))) {
+			ret_val = (-EFAULT);
+			break;
+		}
+		if (op->key.ECC_params.op == PHX_ECC_MUL) {
+			/* 
+			 *  Setup x
+			 */
+			memcpy(word64, word64 - len, len << 3);
+			word64 += len;
+		}
+		if (op->key.ECC_params.op != PHX_ECC_FIELD_BIN_INV &&
+			op->key.ECC_params.op != PHX_ECC_FIELD_INV &&
+			op->key.ECC_params.op != PHX_ECC_FIELD_RED) {
+			/*
+			 *  Setup y
+			 */
+			if (!(word64 =
+					copy_from_bignum(word64, &op->key.ECC_params.y, len))) {
+				ret_val = (-EFAULT);
+				break;
+			}
+		}
+		if (op->key.ECC_params.op == PHX_ECC_MUL) {
+			/*
+			 *  Setup y
+			 */
+			memcpy(word64, word64 - len, len << 3);
+			word64 += len;
+		}
+		if (op->key.ECC_params.op == PHX_ECC_ADD) {
+			/*
+			 *  Setup x2
+			 */
+			if (!(word64 =
+					copy_from_bignum(word64, &op->key.ECC_params.x2, len))) {
+				ret_val = (-EFAULT);
+				break;
+			}
+			/*
+			 *  Setup y2
+			 */
+			if (!(word64 =
+					copy_from_bignum(word64, &op->key.ECC_params.y2, len))) {
+				ret_val = (-EFAULT);
+				break;
+			}
+		}
+		if (!(op->key.ECC_params.op & (PHX_ECC_BIN | PHX_ECC_FIELD))) {
+			/*
+			 *  Setup a
+			 */
+			if (!(word64 =
+					copy_from_bignum(word64, &op->key.ECC_params.a, len))) {
+				ret_val = (-EFAULT);
+				break;
+			}
+		}
+		if (op->key.ECC_params.op == PHX_ECC_VFY) {
+			/*
+			 *  Setup b
+			 */
+			if (!(word64 =
+					copy_from_bignum(word64, &op->key.ECC_params.b, len))) {
+				ret_val = (-EFAULT);
+				break;
+			}
+		}
+		if (op->key.ECC_params.op == PHX_ECC_MUL) {
+			/*
+			 *  Setup k
+			 */
+			if (!(word64 =
+					copy_from_bignum(word64, &op->key.ECC_params.k,
+								  k_len << 2))) {
+				ret_val = (-EFAULT);
+				break;
+			}
+		}
+		if (!(op->key.ECC_params.op & PHX_ECC_BIN)) {
+			/*
+			 *  Setup n
+			 */
+			if (!(word64 =
+					copy_from_bignum(word64, &op->key.ECC_params.n, len))) {
+				ret_val = (-EFAULT);
+				break;
+			}
+			if (!(op->key.ECC_params.op & PHX_ECC_BIN) ||
+				op->key.ECC_params.op == PHX_ECC_FIELD_MUL) {
+				/* 
+				 *  Setup const
+				 */
+				if (!(word64 =
+						copy_from_bignum(word64, &op->key.ECC_params.c, len))) {
+					ret_val = (-EFAULT);
+					break;
+				}
+			}
+		}
+		op->key.ECC_params.data_in =
+			(uint64_t) (unsigned long) &desc->source[0];
+		/*
+		 * Allocate Destination buffer size (64-bit words) 
+		 */
+
+		mem = &desc->dest[0];
+		memset(mem, 0, op->key.ECC_params.op == PHX_ECC_VFY ? 8 : len << 2);
+		op->key.ECC_params.data_out = (uint64_t) (unsigned long) mem;	
+		/* store for setup() */
+
+	} while (0);
+
+	if (ret_val == 0) {
+		phxsec_error_t err;
+
+		err = phxsec_ecc_setup(&op->key.ECC_params, desc);
+		if (err != PHXSEC_ERR_NONE) {
+			ret_val = (-EINVAL);
+		}
+		else {
+			err = phxsec_submit_pkop_wait(desc);
+		}
+
+		if (err != PHXSEC_ERR_NONE) {
+			ret_val = (-ENODATA);
+			phxdrv_record_ecc_failed(stats, 0);
+		}
+		else {
+			ret_val = identify_pubkey_error(desc->ctl_result,
+											desc->data_result);
+		}
+
+		if ((err == PHXSEC_ERR_NONE) && (ret_val == 0)) {
+
+			PHXPKCMD_DIAG("OUTPUT LENGTH:  %d (bits)  %d (bytes)\n",
+						  op->key.ECC_params.data_out_len,
+						  desc->kern.result_length);
+
+			word64 = (__u64 *) & desc->dest[0];
+
+			if (op->key.ECC_params.op == PHX_ECC_VFY) {
+				/* Copy data to User-space done in rmisec_write */
+				op->key.ECC_params.result = *(unsigned int *) &desc->dest[4];
+			}
+			else if (op->key.ECC_params.op & PHX_ECC_FIELD) {
+				if (!(word64 = copy_to_bignum(word64, &op->key.ECC_params.r_x,
+											  (char *) &desc->dest[0],
+											  len))) {
+					ret_val = (-EFAULT);
+				}
+			}
+			else {
+				if (!(word64 = copy_to_bignum(word64, &op->key.ECC_params.r_x,
+											  (char *) &desc->dest[0],
+											  len))) {
+					ret_val = (-EFAULT);
+				}
+				else if (!(word64 =
+							copy_to_bignum(word64, &op->key.ECC_params.r_y,
+										 (char *) &desc->dest[len << 3],
+										 len))) {
+					ret_val = (-EFAULT);
+				}
+			}
+
+
+			phxdrv_record_ecc(stats, op->key.ECC_params.op);
+
+		}
+		else {
+			phxdrv_record_ecc_failed(stats, 0);
+		}
+	}
+
+	phxsec_free_pubkey_desc(desc);
+
+	return (ret_val);
+}
diff --git a/drivers/char/rmisec/phxdrv/phxcrypto.c b/drivers/char/rmisec/phxdrv/phxcrypto.c
new file mode 100644
index 0000000..c11ce53
--- /dev/null
+++ b/drivers/char/rmisec/phxdrv/phxcrypto.c
@@ -0,0 +1,682 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/crypto.h>
+#include <linux/semaphore.h>
+#include <linux/scatterlist.h>
+#include <asm/io.h>
+#include <asm/smp.h>
+#include <asm/uaccess.h>
+#include <asm/scatterlist.h>
+#include <asm/kmap_types.h>
+#include <asm/hardirq.h>
+#include <linux/mm.h>
+#include <linux/pagemap.h>
+#include <linux/highmem.h>
+#include <linux/hardirq.h>
+
+#include <asm/rmi/debug.h>
+#include <asm/rmi/msgring.h>
+
+#include "../linux/rmisec.h"
+#include "phxdesc.h"
+#include "phxsec.h"
+#include "phxdrv.h"
+
+int phxcrypto_verbosity = PHXDRV_VERY_VERBOSE;
+
+#ifdef DEBUG_VERBOSE
+#define PHXCRYPTO_VDIAG(fmt, args...) { \
+                                       if (phxcrypto_verbosity >= PHXDRV_VERY_VERBOSE) \
+                                           printk(fmt, ##args); \
+                                      }
+#define PHXCRYPTO_DIAG(fmt, args...) { \
+                                       if (phxcrypto_verbosity >= PHXDRV_VERBOSE) \
+                                           printk(fmt, ##args); \
+                                     }
+#else
+#define PHXCRYPTO_VDIAG(fmt, args...)
+#define PHXCRYPTO_DIAG(fmt, args...)
+#endif
+
+#define PHXCRYPTO_ERR(fmt, args...) { \
+                                      if (phxcrypto_verbosity >= PHXDRV_NORMAL) \
+                                           printk(fmt, ##args); \
+                                    }
+
+/* Driver specific cipher context */
+struct phxcrypto_cipher_context
+{
+	int des3_key_encrypt;
+	__u32 vector;
+	symkey_desc_pt pdesc;
+};
+
+static void *driver_context;
+
+/* statistics structure pointer */
+rmisec_stats_pt stats;
+
+/* Crypto API low-level entry points */
+static int phxcrypto_mac(void *p,
+						 u16 flags, u8 * key, unsigned int keylen,
+						 struct scatterlist *sg, unsigned int nsg, u8 * out);
+static int phxcrypto_aes_setkey(struct crypto_tfm *p,
+								const u8 * key, unsigned int keylen);
+static int phxcrypto_des_setkey(struct crypto_tfm *p,
+								const u8 * key, unsigned int keylen);
+static int phxcrypto_des3_ede_setkey(struct crypto_tfm *p,
+									 const u8 * key, unsigned int keylen);
+
+/* Crypto API digest entry points */
+#define HASH_IMPL(name, algo, block_size, digest_size)			\
+static int phxcrypto_##name##_digest(void* ctx, struct scatterlist *sg,	\
+	unsigned int nsg, u8* out)					\
+{									\
+	return phxcrypto_mac(ctx, algo, 0, 0, sg, nsg, out);		\
+}									\
+static int phxcrypto_##name##_hmac(void* ctx, u8* key, unsigned int* keylen, \
+	struct scatterlist *sg, unsigned int nsg, u8* out) 		\
+{                                                                       \
+	if (out == 0)							\
+            return -algo;                                               \
+	return phxcrypto_mac(ctx, algo, key, *keylen, sg, nsg, out);	\
+}									\
+static struct crypto_alg name##_alg = {					\
+	.cra_name	= #name,					\
+	.cra_flags	= CRYPTO_ALG_TYPE_DIGEST | CRYPTO_ALG_HW,	\
+	.cra_blocksize	= block_size,					\
+	.cra_ctxsize	= sizeof(struct phxcrypto_cipher_context),	\
+	.cra_module	= THIS_MODULE,					\
+	.cra_list	= LIST_HEAD_INIT(name##_alg.cra_list),		\
+        /*.cra_ctx_init   = phxcrypto_ctx_construct, */                     \
+        /*.cra_ctx_exit   = phxcrypto_ctx_destruct,  */                     \
+	.cra_u		= { 						\
+		.digest = {						\
+			.dia_digestsize	= digest_size,			\
+			.dia_hw_digest 	= phxcrypto_##name##_digest,	\
+			.dia_hw_hmac 	= phxcrypto_##name##_hmac,	\
+		}							\
+	}								\
+}
+
+#define MAC_ALGO_MD5		0x0001
+#define MAC_ALGO_SHA1		0x0002
+#define MAC_ALGO_SHA256		0x0003
+#define MAC_ALGO_SHA384         0x0004
+#define MAC_ALGO_SHA512         0x0005
+#define MAC_ALGO_GCM            0x0006
+#define MAC_ALGO_KASUMI_F9      0x0007
+
+
+/* Digest algortihms we can handle */
+HASH_IMPL(md5, MAC_ALGO_MD5, PHXSEC_MD5_BLOCK_SIZE, PHXSEC_MD5_LENGTH);
+HASH_IMPL(sha1, MAC_ALGO_SHA1, PHXSEC_SHA1_BLOCK_SIZE, PHXSEC_SHA1_LENGTH);
+HASH_IMPL(sha256, MAC_ALGO_SHA256, PHXSEC_SHA256_BLOCK_SIZE,
+		  PHXSEC_SHA256_LENGTH);
+HASH_IMPL(sha384, MAC_ALGO_SHA384, PHXSEC_SHA384_BLOCK_SIZE,
+		  PHXSEC_SHA384_LENGTH);
+HASH_IMPL(sha512, MAC_ALGO_SHA512, PHXSEC_SHA512_BLOCK_SIZE,
+		  PHXSEC_SHA512_LENGTH);
+HASH_IMPL(gcm, MAC_ALGO_GCM, PHXSEC_GCM_BLOCK_SIZE, PHXSEC_GCM_LENGTH);
+HASH_IMPL(kasumi_f9, MAC_ALGO_KASUMI_F9, PHXSEC_KASUMI_F9_BLOCK_SIZE,
+		  PHXSEC_KASUMI_F9_LENGTH);
+
+/* Crypto API cipher entry points */
+#define CIPHER_IMPL(name, block, keymin, keymax, ctxsize)        	\
+static struct crypto_alg name##_alg = {					\
+	.cra_name	= #name,					\
+	.cra_flags	= CRYPTO_ALG_TYPE_CIPHER | CRYPTO_ALG_HW,	\
+	.cra_blocksize	= block,					\
+	.cra_ctxsize	= sizeof(struct phxcrypto_cipher_context) + ctxsize, \
+	.cra_module	= THIS_MODULE,					\
+	.cra_list	= LIST_HEAD_INIT(name##_alg.cra_list),		\
+	.cra_u		= {						\
+		.cipher = {						\
+			.cia_min_keysize = keymin,			\
+			.cia_max_keysize = keymax,			\
+			.cia_setkey	 = phxcrypto_##name##_setkey,	\
+		}							\
+	}								\
+}
+
+/* Ciphers we can handle */
+CIPHER_IMPL(aes, PHXSEC_AES_BLOCK_SIZE, PHXSEC_AES128_KEY_LENGTH,
+			PHXSEC_AES256_KEY_LENGTH, 0);
+CIPHER_IMPL(des, PHXSEC_DES_BLOCK_SIZE, PHXSEC_DES_KEY_LENGTH,
+			PHXSEC_DES_KEY_LENGTH, 0);
+CIPHER_IMPL(des3_ede, PHXSEC_3DES_BLOCK_SIZE, PHXSEC_3DES_KEY_LENGTH,
+			PHXSEC_3DES_KEY_LENGTH, 0);
+
+enum km_type phxcrypto_km_types[] = {
+	KM_USER0,
+	KM_USER1,
+	KM_SOFTIRQ0,
+	KM_SOFTIRQ1,
+};
+
+static inline enum km_type phxcrypto_kmap_type(int out)
+{
+	return phxcrypto_km_types[(in_softirq()? 2 : 0) + out];
+}
+
+static inline void *phxcrypto_kmap(struct page *page, int out)
+{
+	return kmap_atomic(page, phxcrypto_kmap_type(out));
+}
+
+static inline void phxcrypto_kunmap(void *vaddr, int out)
+{
+	kunmap_atomic(vaddr, phxcrypto_kmap_type(out));
+}
+
+static int phxcrypto_mac(void *p,
+						 u16 flags, u8 * key, unsigned int keylen,
+						 struct scatterlist *sg, unsigned int nsg, u8 * out)
+{
+	struct phxcrypto_cipher_context *ctx = 
+		(struct phxcrypto_cipher_context *) p;
+	phxsec_io_t io_block;
+	phxsec_error_t err;
+	int n, digest_len = 0, digest_type = 0;
+	int bytes_to_save;
+	u8 *auth_dest = 0;
+	u8 auth_save[SMP_CACHE_BYTES];
+
+	PHXCRYPTO_DIAG
+		("phxcrypto_mac: ctx %p key %p keylen %d flags %x nsg %d out %p\n",
+		 ctx, key, keylen, flags, nsg, out);
+
+	/*
+	   things known at this point:
+
+	   flags is the algorithm
+	   src is a scatterlist for the digest source, for the fast case
+	   only has 1 fragment
+	   if key != NULL && keylen != 0 then the key is passed in and 
+	   needs to be set before the operation
+	*/
+
+	/* TODO: do multiple fragments */
+	if (nsg > 1) {
+		int total = 0;
+		for (n = 0; n < nsg; ++n, ++sg)
+			total += sg->length;
+		phxdrv_record_hmac_revert(stats, total);
+		PHXCRYPTO_DIAG("phxcrypto_mac: multiple (%d) fragments, reverting\n",
+					   nsg);
+		return -EINVAL;
+	}
+
+	if (key != NULL && keylen != 0) {
+		/* we have the key, so first do the general setup */
+
+		/* 
+		 * first determine the digest type, so we can check the control bits
+		 * Reverts because of the control bits are not counted
+		 */
+		switch (flags) {
+			case MAC_ALGO_MD5:
+				if (!(stats->control_mask & PHXDRV_CONTROL_HW_MD5))
+					return -EINVAL;
+				digest_type = PHX_DIGEST_TYPE_HMAC_MD5;
+				digest_len = PHXSEC_MD5_LENGTH;
+				break;
+			case MAC_ALGO_SHA1:
+				if (!(stats->control_mask & PHXDRV_CONTROL_HW_SHA1))
+					return -EINVAL;
+				digest_type = PHX_DIGEST_TYPE_HMAC_SHA1;
+				digest_len = PHXSEC_SHA1_LENGTH;
+				break;
+			case MAC_ALGO_SHA256:
+				if (!(stats->control_mask & PHXDRV_CONTROL_HW_SHA256))
+					return -EINVAL;
+				digest_type = PHX_DIGEST_TYPE_HMAC_SHA256;
+				digest_len = PHXSEC_SHA256_LENGTH;
+				break;
+			case MAC_ALGO_SHA384:
+				if (!(stats->control_mask & PHXDRV_CONTROL_HW_SHA384))
+					return -EINVAL;
+				digest_type = PHX_DIGEST_TYPE_HMAC_SHA384;
+				digest_len = PHXSEC_SHA384_LENGTH;
+				break;
+			case MAC_ALGO_SHA512:
+				if (!(stats->control_mask & PHXDRV_CONTROL_HW_SHA512))
+					return -EINVAL;
+				digest_type = PHX_DIGEST_TYPE_HMAC_SHA512;
+				digest_len = PHXSEC_SHA512_LENGTH;
+				break;
+			case MAC_ALGO_GCM:
+				if (!(stats->control_mask & PHXDRV_CONTROL_HW_GCM))
+					return -EINVAL;
+				digest_type = PHX_DIGEST_TYPE_GCM;
+				digest_len = PHXSEC_GCM_LENGTH;
+				break;
+			case MAC_ALGO_KASUMI_F9:
+				if (!(stats->control_mask & PHXDRV_CONTROL_HW_KASUMI_F9))
+					return -EINVAL;
+				digest_type = PHX_DIGEST_TYPE_KASUMI_F9;
+				digest_len = PHXSEC_KASUMI_F9_RESULT_LENGTH;
+				break;
+			default:
+				PHXCRYPTO_DIAG
+					("phxcrypto_mac: unknown digest type %d, reverting\n",
+					 flags);
+				{
+					int total = 0;
+					for (n = 0; n < nsg; ++n, ++sg)
+						total += sg->length;
+					phxdrv_record_hmac_revert(stats, total);
+				}
+				return -EINVAL;
+		}
+
+		memset(&io_block, '\0', sizeof(io_block));
+
+		/* fields for cipher_setup */
+		io_block.cipher_type = PHX_CIPHER_TYPE_NONE;
+		io_block.cipher_mode = PHX_CIPHER_MODE_PASS;
+
+		/* fields for digest_setup */
+		io_block.digest_type = digest_type;
+		io_block.digest_init = PHX_DIGEST_INIT_NEWKEY;
+		io_block.digest_src = PHX_DIGEST_SRC_DMA;
+
+		/* fields for cksum_setup  - UNUSED */
+		io_block.cksum_type = PHX_CKSUM_TYPE_NOP;
+
+		/* fields for control_setup */
+		/* nonce  - UNUSED */
+		/* cfb_mask  - UNUSED */
+		memcpy(io_block.mac_key, key, keylen);
+
+		err = phxsec_FillDescriptor(&io_block, ctx->pdesc, &ctx->vector);
+		if (unlikely(err != PHXSEC_ERR_NONE)) {
+			int total = 0;
+			for (n = 0; n < nsg; ++n, ++sg)
+				total += sg->length;
+			phxdrv_record_hmac_revert(stats, total);
+			PHXCRYPTO_ERR
+				("phxcrypto_mac: error in %d phxsec_FillDescriptor, reverting\n",
+				 (int) err);
+			return -EINVAL;
+		}
+	}
+
+	/* TODO: what to do about multiple fragments? */
+	for (n = 0; n < nsg; ++n, ++sg) {
+		u8 *src_p;
+		int rest_of_page, len_this_page;
+
+		src_p = phxcrypto_kmap(sg_page(sg), 0) + sg->offset;
+
+		PHXCRYPTO_DIAG
+			("phxcrypto_mac: chunk %d bytes page %p offset %d mapped %p\n",
+			 sg->length, sg->page, sg->offset, src_p);
+
+		rest_of_page = PAGE_CACHE_SIZE - (sg->offset & (PAGE_CACHE_SIZE - 1));
+		len_this_page =
+			(sg->length < rest_of_page) ? sg->length : rest_of_page;
+
+		PHXCRYPTO_DIAG("phxcrypto_mac: rest_of_page %d, len_this_page %d\n",
+					   rest_of_page, len_this_page);
+
+		if (!(sg->length <= len_this_page &&
+			  (((unsigned long) src_p) & (PAGE_CACHE_SIZE - 1)) +
+			  sg->length <= PAGE_CACHE_SIZE)) {
+			/* TODO: could do it here */
+			phxcrypto_kunmap(src_p, 0);
+			phxdrv_record_hmac_revert(stats, sg->length);
+			PHXCRYPTO_DIAG
+				("phxcrypto_mac: reverting to software need temp buffer\n");
+			return -EINVAL;
+		}
+
+		PHXCRYPTO_DIAG("phxcrypto_mac: source buffer at %p\n", src_p);
+
+		/* per-packet setup */
+		memset(&io_block, '\0', sizeof(io_block));
+
+		io_block.digest_type = digest_type;
+		io_block.digest_src = PHX_DIGEST_SRC_DMA;
+		io_block.digest_init = PHX_DIGEST_INIT_NEWKEY;
+		io_block.digest_offset = 0;
+
+		/* packet_setup fields */
+		io_block.pkt_next = PHX_NEXT_FINISH;
+		io_block.pkt_hash = PHX_PADHASH_PAD;
+		io_block.pkt_hashbytes = PHX_HASHBYTES_ALL8;
+		io_block.pkt_lastword = PHX_LASTWORD_128;
+		io_block.pkt_hmac = PHX_LOADHMACKEY_MODE_LOAD;
+
+		io_block.source_buf = (uint64_t) (unsigned long) src_p;
+		io_block.source_buf_size = sg->length;
+		io_block.dest_buf = (uint64_t) (unsigned long) src_p;
+		io_block.dest_buf_size = sg->length;
+
+		/* ensure cache alignment for auth destination */
+		if ((unsigned long) out & (SMP_CACHE_BYTES - 1)) {
+			PHXCRYPTO_DIAG("phxcrypto_mac: unaligned auth_dest %p\n", out);
+			/* need to allocate cache-aligned temp buffer */
+			auth_dest = kmalloc(digest_len + SMP_CACHE_BYTES - 1,
+								GFP_KERNEL | GFP_ATOMIC);
+			if (auth_dest == NULL) {
+				phxcrypto_kunmap(src_p, 0);
+				PHXCRYPTO_ERR
+					("phxcrypto_mac: error allocating temporary buffer\n");
+				phxdrv_record_hmac_revert(stats, sg->length);
+				return -ENOMEM;
+			}
+			/* find cacheline alignment */
+			if ((unsigned long) auth_dest & (SMP_CACHE_BYTES - 1))
+				io_block.auth_dest = (unsigned long)
+					(((unsigned long) auth_dest + SMP_CACHE_BYTES) &
+					 ~(SMP_CACHE_BYTES - 1));
+			else
+				io_block.auth_dest = (unsigned long) auth_dest;
+			phxdrv_record_unaligned_auth_dest(stats, 0);
+		}
+		else {
+			auth_dest = 0;
+			io_block.auth_dest = (unsigned long) out;
+		}
+
+		err = phxsec_SetupDescriptor(&io_block, PHX_SETUP_OP_HMAC,
+									 ctx->pdesc, ctx->vector);
+		if (unlikely(err != PHXSEC_ERR_NONE)) {
+			phxcrypto_kunmap(src_p, 0);
+			phxdrv_record_hmac_revert(stats, sg->length);
+			PHXCRYPTO_ERR
+				("phxcrypto_mac: error %d in phxsec_SetupDescriptor, reverting to software\n",
+				 (int) err);
+			return -EINVAL;
+		}
+
+		/* TODO: remove offset when the SSIM bug is fixed */
+		bytes_to_save = SMP_CACHE_BYTES;
+		memcpy(auth_save, (u8 *) (((unsigned long) io_block.dest_buf +
+								   io_block.dest_buf_size) & ~0x7),
+			   bytes_to_save);
+
+#ifdef DEBUG_VERBOSE
+		{
+			int i;
+			PHXCRYPTO_VDIAG("source block at %p\n", &io_block.source_buf[0]);
+			for (i = 0; i < io_block.source_buf_size; i++) {
+				if ((i > 0) && ((i & 0xf) == 0))
+					PHXCRYPTO_VDIAG("\n");
+				PHXCRYPTO_VDIAG("%02x ", io_block.source_buf[i]);
+			}
+			PHXCRYPTO_VDIAG("\n");
+		}
+#endif
+
+		err = phxsec_ProcessPacket(driver_context, ctx->pdesc, ctx->vector);
+		if (unlikely(err != PHXSEC_ERR_NONE)) {
+			phxcrypto_kunmap(src_p, 0);
+			phxdrv_record_hmac_revert(stats, sg->length);
+			PHXCRYPTO_ERR
+				("phxcrypto_mac: error %d in phxsec_ProcessPacket, reverting to software\n",
+				 (int) err);
+			if (auth_dest)
+				kfree(auth_dest);
+			return -EINVAL;
+		}
+
+		phxcrypto_kunmap(src_p, 0);
+
+		memcpy((u8 *) (((unsigned long) io_block.dest_buf +
+						io_block.dest_buf_size) & ~0x7),
+			   auth_save, bytes_to_save);
+
+		switch (flags) {
+			case MAC_ALGO_MD5:
+				phxdrv_record_md5(stats, sg->length);
+				break;
+			case MAC_ALGO_SHA1:
+				phxdrv_record_sha1(stats, sg->length);
+				break;
+			case MAC_ALGO_SHA256:
+				phxdrv_record_sha256(stats, sg->length);
+				break;
+			case MAC_ALGO_SHA384:
+				phxdrv_record_sha384(stats, sg->length);
+				break;
+			case MAC_ALGO_SHA512:
+				phxdrv_record_sha512(stats, sg->length);
+				break;
+			case MAC_ALGO_GCM:
+				phxdrv_record_gcm(stats, sg->length);
+				break;
+			case MAC_ALGO_KASUMI_F9:
+				phxdrv_record_kasumi_f9(stats, sg->length);
+				break;
+		}
+	}
+
+#ifdef DEBUG_VERBOSE
+	{
+		int i;
+		PHXCRYPTO_VDIAG("digest result: ");
+		for (i = 0; i < digest_len; i++) {
+			if ((i > 0) && ((i & 0xf) == 0))
+				PHXCRYPTO_VDIAG("\n");
+			PHXCRYPTO_VDIAG("%02x ", io_block.auth_dest[i]);
+		}
+		PHXCRYPTO_VDIAG("\n");
+	}
+#endif
+
+	/* copy back the result */
+	if (auth_dest) {
+		memcpy(out, (void *) ((unsigned long) io_block.auth_dest),
+			   digest_len);
+		kfree(auth_dest);
+		auth_dest = 0;
+	}
+
+	return 0;
+}
+
+static int phxcrypto_aes_setkey(struct crypto_tfm *p,
+								const u8 * key, unsigned int keylen)
+{
+	struct phxcrypto_cipher_context *ctx =
+		(struct phxcrypto_cipher_context *) p;
+	phxsec_io_t io_block;
+	phxsec_error_t err;
+
+	PHXCRYPTO_DIAG("phxcrypto_aes_setkey: ctx %p keylen %d\n", ctx, keylen);
+
+	BUG_ON((keylen < PHXSEC_AES128_KEY_LENGTH) ||
+		   (keylen > PHXSEC_AES256_KEY_LENGTH));
+
+	memset(&io_block, '\0', sizeof(io_block));
+
+	/* fields for cipher_setup */
+	switch (keylen) {
+		case PHXSEC_AES128_KEY_LENGTH:
+			io_block.cipher_type = PHX_CIPHER_TYPE_AES128;
+			break;
+		case PHXSEC_AES192_KEY_LENGTH:
+			io_block.cipher_type = PHX_CIPHER_TYPE_AES192;
+			break;
+		case PHXSEC_AES256_KEY_LENGTH:
+			io_block.cipher_type = PHX_CIPHER_TYPE_AES256;
+			break;
+		default:
+			PHXCRYPTO_ERR("phxcrypto_aes_setkey: keylen %d is invalid\n",
+						  keylen);
+			return -EINVAL;
+	}
+
+	io_block.cipher_mode = PHX_CIPHER_MODE_CBC;
+	io_block.cipher_op = PHX_CIPHER_OP_ENCRYPT;
+	io_block.cipher_init = PHX_CIPHER_INIT_NK;
+
+	/* fields for digest_setup */
+	io_block.digest_type = PHX_DIGEST_TYPE_NONE;
+	io_block.digest_init = PHX_DIGEST_INIT_NEWKEY;
+	io_block.digest_src = PHX_DIGEST_SRC_DMA;
+
+	/* fields for cksum_setup  - UNUSED */
+	io_block.cksum_type = PHX_CKSUM_TYPE_NOP;
+	io_block.cksum_src = PHX_CKSUM_SRC_DMA;
+
+	/* fields for control_setup */
+	/* nonce  - UNUSED */
+	/* cfb_mask  - UNUSED */
+	memcpy(io_block.crypt_key, key, keylen);
+
+	err = phxsec_FillDescriptor(&io_block, ctx->pdesc, &ctx->vector);
+
+	BUG_ON(err != PHXSEC_ERR_NONE);
+
+	return 0;
+}
+
+static int phxcrypto_des_setkey(struct crypto_tfm *p,
+								const u8 * key, unsigned int keylen)
+{
+	struct phxcrypto_cipher_context *ctx =
+		(struct phxcrypto_cipher_context *) p;
+	phxsec_io_t io_block;
+	phxsec_error_t err;
+
+	PHXCRYPTO_DIAG("phxcrypto_des_setkey: ctx %p keylen %d\n", ctx, keylen);
+
+	BUG_ON(keylen != PHXSEC_DES_KEY_LENGTH);
+
+	memset(&io_block, '\0', sizeof(io_block));
+
+	/* fields for cipher_setup */
+	io_block.cipher_type = PHX_CIPHER_TYPE_DES;
+	io_block.cipher_mode = PHX_CIPHER_MODE_CBC;
+	io_block.cipher_op = PHX_CIPHER_OP_ENCRYPT;
+	io_block.cipher_init = PHX_CIPHER_INIT_NK;
+
+	/* fields for digest_setup */
+	io_block.digest_type = PHX_DIGEST_TYPE_NONE;
+	io_block.digest_init = PHX_DIGEST_INIT_NEWKEY;
+	io_block.digest_src = PHX_DIGEST_SRC_DMA;
+
+	/* fields for cksum_setup  - UNUSED */
+	io_block.cksum_type = PHX_CKSUM_TYPE_NOP;
+	io_block.cksum_src = PHX_CKSUM_SRC_DMA;
+
+	/* fields for control_setup */
+	/* nonce  - UNUSED */
+	/* cfb_mask  - UNUSED */
+	memcpy(io_block.crypt_key, key, keylen);
+
+	err = phxsec_FillDescriptor(&io_block, ctx->pdesc, &ctx->vector);
+
+	BUG_ON(err != PHXSEC_ERR_NONE);
+
+	return 0;
+}
+
+static int phxcrypto_des3_ede_setkey(struct crypto_tfm *p,
+									 const u8 * key, unsigned int keylen)
+{
+	struct phxcrypto_cipher_context *ctx =
+		(struct phxcrypto_cipher_context *) p;
+	phxsec_io_t io_block;
+	phxsec_error_t err;
+
+	PHXCRYPTO_DIAG("phxcrypto_des3_ede_setkey: ctx %p keylen %d\n", ctx,
+				   keylen);
+
+	BUG_ON(keylen != PHXSEC_3DES_KEY_LENGTH);
+
+	/* 
+	   things known at this point:
+
+	   Key length
+	   key itself
+	   cipher algorithm used
+
+	 */
+
+	memset(&io_block, '\0', sizeof(io_block));
+
+	/* fields for cipher_setup */
+	io_block.cipher_type = PHX_CIPHER_TYPE_3DES;
+	io_block.cipher_mode = PHX_CIPHER_MODE_CBC;
+	io_block.cipher_op = PHX_CIPHER_OP_ENCRYPT;
+	io_block.cipher_init = PHX_CIPHER_INIT_NK;
+
+	/* fields for digest_setup */
+	io_block.digest_type = PHX_DIGEST_TYPE_NONE;
+	io_block.digest_init = PHX_DIGEST_INIT_NEWKEY;
+	io_block.digest_src = PHX_DIGEST_SRC_DMA;
+
+	/* fields for cksum_setup  - UNUSED */
+	io_block.cksum_type = PHX_CKSUM_TYPE_NOP;
+	io_block.cksum_src = PHX_CKSUM_SRC_DMA;
+
+	/* fields for control_setup */
+	/* nonce  - UNUSED */
+	/* cfb_mask  - UNUSED */
+	memcpy(io_block.crypt_key, key, keylen);
+
+	err = phxsec_FillDescriptor(&io_block, ctx->pdesc, &ctx->vector);
+
+	BUG_ON(err != PHXSEC_ERR_NONE);
+
+	ctx->des3_key_encrypt = 1;
+
+	return 0;
+}
+
+extern rmisec_stats_pt phxdrv_proc_init(void);
+
+/* This routine registers relevant crypto algorithms with the CryptoAPI */
+int phxcrypto_init(void *drv_ctx)
+{
+	PHXCRYPTO_DIAG("phxcrypto_init: initializing /proc entries...\n");
+
+	stats = phxdrv_proc_init();
+	if (!stats)
+		return PHXSEC_ERR_ALLOC;
+
+	PHXCRYPTO_DIAG("phxcrypto_init: registering CryptoAPI handlers... ");
+
+	/* at this time driver context is stored statically */
+	driver_context = drv_ctx;
+
+	PHXCRYPTO_DIAG("completed\n");
+
+	return PHXSEC_ERR_NONE;
+}
diff --git a/drivers/char/rmisec/phxdrv/phxdesc.h b/drivers/char/rmisec/phxdrv/phxdesc.h
new file mode 100644
index 0000000..37aa8a5
--- /dev/null
+++ b/drivers/char/rmisec/phxdrv/phxdesc.h
@@ -0,0 +1,3122 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _PHXDESC_H_
+#define _PHXDESC_H_
+
+#include <linux/semaphore.h>
+
+#define ONE_BIT              0x0000000000000001ULL
+#define TWO_BITS             0x0000000000000003ULL
+#define THREE_BITS           0x0000000000000007ULL
+#define FOUR_BITS            0x000000000000000fULL
+#define FIVE_BITS            0x000000000000001fULL
+#define SIX_BITS             0x000000000000003fULL
+#define SEVEN_BITS           0x000000000000007fULL
+#define EIGHT_BITS           0x00000000000000ffULL
+#define NINE_BITS            0x00000000000001ffULL
+#define ELEVEN_BITS          0x00000000000007ffULL
+#define TWELVE_BITS          0x0000000000000fffULL
+#define FOURTEEN_BITS        0x0000000000003fffULL
+#define TWENTYFOUR_BITS      0x0000000000ffffffULL
+#define THIRTY_TWO_BITS      0x00000000ffffffffULL
+#define THIRTY_FIVE_BITS     0x00000007ffffffffULL
+#define FOURTY_BITS          0x000000ffffffffffULL
+
+#define MSG_IN_CTL_LEN_BASE  40
+#define MSG_IN_CTL_ADDR_BASE 0
+
+#define GET_FIELD(word,field) \
+ ((word) & (field ## _MASK)) >> (field ## _LSB)
+
+#define FIELD_VALUE(field,value) (((value) & (field ## _BITS)) << (field ## _LSB))
+
+/*
+ * NOTE: this macro expects 'word' to be uninitialized (i.e. zeroed)
+ */
+#define SET_FIELD(word,field,value) \
+ { (word) |=  (((value) & (field ## _BITS)) << (field ## _LSB)); }
+
+/*
+ * This macro clears 'word', then sets the value
+ */
+#define CLEAR_SET_FIELD(word,field,value) \
+ { (word) &= ~((field ## _BITS) << (field ## _LSB)); \
+   (word) |=  (((value) & (field ## _BITS)) << (field ## _LSB)); }
+
+/*
+ * NOTE: May be used to build value specific mask 
+ *        (e.g.  GEN_MASK(CTL_DSC_CPHR_3DES,CTL_DSC_CPHR_LSB)
+ */
+#define GEN_MASK(bits,lsb) ((bits) << (lsb))
+
+
+/*
+ * Security block data and control exchange
+ *
+ * A 2-word message ring descriptor is used to pass a pointer to the control descriptor data structure
+ * and a pointer to the packet descriptor data structure:
+ *
+ *  63  61 60                 54      53      52    49 48            45 44    40
+ *  39                                                     5 4                 0
+ *  ---------------------------------------------------------------------------------------------------------------------------------------------------------
+ * | Ctrl | Resp Dest Id Entry0 | IF_L2ALLOC | UNUSED | Control Length | UNUSED
+ * | 35 MSB of address of control descriptor data structure | Software Scratch0
+ * |
+ *  ---------------------------------------------------------------------------------------------------------------------------------------------------------
+ *    3              7                1          4             4           5
+ *    35                                       5
+ *
+ *  63  61 60    54     53          52             51        50    46      45       44    40 39                                                    5 4      0
+ *  ---------------------------------------------------------------------------------------------------------------------------------------------------------
+ * | Ctrl | UNUSED | WRB_COH | WRB_L2ALLOC | DF_PTR_L2ALLOC | UNUSED | Data Length | UNUSED | 35 MSB of address of packet descriptor data structure | UNUSED |
+ *  ---------------------------------------------------------------------------------------------------------------------------------------------------------
+ *    3       7         1          1               1            5           1          5                                35                              5
+ *
+ * Addresses assumed to be cache-line aligned, i.e., Address[4:0] ignored (using 5'h00 instead)
+ *
+ * Control length is the number of control cachelines to be read so user needs
+ * to round up
+ * the control length to closest integer multiple of 32 bytes. Note that at
+ * present (08/12/04)
+ * the longest (sensical) ctrl structure is <= 416 bytes, i.e., 13 cachelines.
+ *
+ * The packet descriptor data structure size is fixed at 1 cacheline (32 bytes).
+ * This effectively makes "Data Length" a Load/NoLoad bit. NoLoad causes an abort.
+ *
+ *
+ * Upon completion of operation, the security block returns a 2-word free descriptor
+ * in the following format:
+ *
+ *  63  61 60            54 53   52 51       49   48   47               40 39                                                  0
+ *  ----------------------------------------------------------------------------------------------------------------------------
+ * | Ctrl | Destination Id | 2'b00 | Desc Ctrl | 1'b0 | Instruction Error |    Address of control descriptor data structure     |
+ *  ----------------------------------------------------------------------------------------------------------------------------
+ * | Ctrl | Destination Id | 2'b00 | Desc Ctrl | 1'b0 |     Data Error    |    Address of packet descriptor data structure      |
+ *  ----------------------------------------------------------------------------------------------------------------------------
+ *
+ * The Instruction and Data Error codes are enumerated in the 
+ * ControlDescriptor and PacketDescriptor sections below
+ *
+ */
+
+
+/*
+ * Operating assumptions
+ * =====================
+ *
+ * 
+ *	        -> For all IpSec ops, I assume that all the IP/IPSec/TCP headers
+ *		   and the data are present at the specified source addresses.
+ *		   I also assume that all necessary header data already exists
+ *		   at the destination. Additionally, in AH I assume that all
+ *		   mutable fields (IP.{TOS, Flags, Offset, TTL, Header_Checksum}) 
+ *		   and the AH.Authentication_Data have been zeroed by the client.
+ *
+ *
+ *		-> In principle, the HW can calculate TCP checksums on both
+ *		   incoming and outgoing data; however, since the TCP header
+ *		   contains the TCP checksum of the plain payload and the header
+ *		   is encrypted, two passes would be necessary to do checksum + encryption
+ *                 for outgoing messages;
+ *		   therefore the checksum engine will likely only be used during decryption
+ *                 (incoming).
+ *
+ *
+ *		-> For all operations involving TCP checksum, I assume the client has filled
+ *		   the TCP checksum field with the appropriate value:
+ *
+ *			    - 0 for generation phase
+ *			    - actual value for verification phase (expecting 0 result)
+ *
+ *
+ *		-> For ESP tunnel, the original IP header exists between the end of the
+ *		   ESP header and the beginning of the TCP header; it is assumed that the
+ *		   maximum length of this header is 16 k(32bit)words (used in CkSum_Offset).
+ *
+ *
+ *		-> The authentication data is merely written to the destination address;
+ *		   the client is left with the task of comparing to the data in packet
+ *		   in decrypt.
+ *
+ *              -> PacketDescriptor_t.dstLLWMask relevant to AES CTR mode only but it will
+ *                 affect all AES-related operations. It will not affect DES/3DES/bypass ops.
+ *                 The mask is applied to data as it emerges from the AES engine for the sole
+ *                 purpose of providing the authenticator and cksum engines with correct data.
+ *                 CAVEAT: the HW does not mask the incoming data. It is the user's responsibility
+ *                 to set to 0 the corresponding data in memory. If the surplus data is not masked
+ *                 in memory, cksum/auth results will be incorrect if those engines receive data
+ *                 straight from memory (i.e., not from cipher, as it happens while decoding)
+ */
+
+/*
+ * Fragmentation and offset related notes
+ * ======================================
+ *
+ *
+ *      A) Rebuilding packets from fragments on dword boundaries. The discussion
+ *         below is exemplified by tests memcpy_all_off_frags and memcpy_same_off_frags
+ * 
+ *	        1) The Offset before data/iv on first fragment is ALWAYS written back
+ *                 Non-zero dst dword or global offsets may cause more data to be 
+ *                 written than the user-specified length.
+ *
+ *
+ *                 Example:
+ *                 --------
+ *
+ *                 Below is a source (first fragment) packet (@ ADD0 cache-aligned address).
+ *                 Assume we just copy it and relevant data starts on
+ *                 dword 3 so Cipher_Offset = IV_Offset = 3 (dwords).
+ *                 D0X denotes relevant data and G denotes dont care data.
+ *                 Offset data is also copied so Packet_Legth = 9 (dwords) * 8 = 72 (bytes)
+ *                 Segment_src_address = ADD0
+ *
+ *                 If we want to, e.g., copy so that the relevant (i.e., D0X) data
+ *                 starts at (cache-aligned address) ADD1, we need to specify
+ *                 Dst_dword_offset = 1 so D00 is moved from dword position 3 to 0 on next cache-line
+ *                 Cipher_dst_address = ADD1 - 0x20 so D00 is written to ADD1
+ *
+ *                 Note that the security engine always writes full cachelines
+ *                 therefore, data written to dword0 0 of ADD1 (denoted w/ ?) is what the sec pipe
+ *                 write back buffer contained from previous op.
+ *
+ *
+ *                      SOURCE:                                                 DESTINATION:
+ *                      -------                                                 ------------
+ *
+ *                      Segment_src_address = ADD0                              Cipher_dst_address = ADD1 - 0x20
+ *                      Packet_Legth        = 72                                Dst_dword_offset   = 1
+ *                      Cipher_Offset       = 3
+ *                      IV_Offset           = 3
+ *                      Use_IV              = ANY
+ *                      
+ *
+ *
+ *                         3     2     1     0                                  3     2     1     0
+ *                       -----------------------                              -----------------------
+ *                      | D00 | G   | G   | G   | <- ADD0                    | G   | G   | G   | ?   | <- ADD1 - 0x20
+ *                       -----------------------                              -----------------------
+ *                      | D04 | D03 | D02 | D01 |                            | D03 | D02 | D01 | D00 | <- ADD1
+ *                       -----------------------                              -----------------------
+ *                      |     |     |     | D05 |                            |     |     | D05 | D04 |
+ *                       -----------------------                              -----------------------
+ * 
+ *	        2) On fragments following the first, IV_Offset is overloaded to mean data offset
+ *                 (number of dwords to skip from beginning of cacheline before starting processing)
+ *                 and Use_IV is overloaded to mean do writeback the offset (in the clear).
+ *                 These fields in combination with Dst_dword_offset allow packet fragments with
+ *                 arbitrary boundaries/lengthd to be reasembled.
+ *
+ *
+ *                 Example:
+ *                 --------
+ *
+ *                 Assume data above was first fragment of a packet we'd like to merge to
+ *                 (second) fragment below located at ADD2. The written data should follow
+ *                 the previous data without gaps or overwrites. To achieve this, one should
+ *                 assert the "Next" field on the previous fragment and use self-explanatory
+ *                 set of parameters below
+ *
+ *
+ *                      SOURCE:                                                 DESTINATION:
+ *                      -------                                                 ------------
+ *
+ *                      Segment_src_address = ADD2                              Cipher_dst_address = ADD1 + 0x20
+ *                      Packet_Legth        = 104                               Dst_dword_offset   = 1
+ *                      IV_Offset           = 1
+ *                      Use_IV              = 0
+ *                      
+ *
+ *
+ *                         3     2     1     0                                  3     2     1     0
+ *                       -----------------------                              -----------------------
+ *                      | D12 | D11 | D10 | G   | <- ADD2                    | G   | G   | G   | ?   | <- ADD1 - 0x20
+ *                       -----------------------                              -----------------------
+ *                      | D16 | D15 | D14 | D13 |                            | D03 | D02 | D01 | D00 | <- ADD1
+ *                       -----------------------                              -----------------------
+ *                      | D1a | D19 | D18 | D17 |                            | D11 | D10 | D05 | D04 | <- ADD1 + 0x20
+ *                       -----------------------                              -----------------------
+ *                      |     |     |     | D1b |                            | D15 | D14 | D13 | D12 |
+ *                       -----------------------                              -----------------------
+ *                                                                           | D19 | D18 | D17 | D16 |
+ *                                                                            -----------------------
+ *                                                                           |     |     | D1b | D1a |
+ *                                                                            -----------------------
+ *
+ *                 It is note-worthy that the merging can only be achieved if Use_IV is 0. Indeed, the security
+ *                 engine always writes full lines, therefore ADD1 + 0x20 will be re-written. Setting Use_IV to 0
+ *                 will allow the sec pipe write back buffer to preserve D04, D05 from previous frag and only
+ *                 receive D10, D11 thereby preserving the integrity of the previous data.
+ * 
+ *	        3) On fragments following the first, !UseIV in combination w/ Dst_dword_offset >= (4 - IV_Offset)
+ *                 will cause a wraparound of the write thus achieving all 16 possible (Initial_Location, Final_Location)
+ *                 combinations for the data.
+ *
+ *
+ *                 Example:
+ *                 --------
+ *
+ *                 Contiguously merging 2 data sets above with a third located at ADD3. If this is the last fragment, 
+ *                 reset its Next bit.
+ *
+ *
+ *                      SOURCE:                                                 DESTINATION:
+ *                      -------                                                 ------------
+ *
+ *                      Segment_src_address = ADD3                              Cipher_dst_address = ADD1 + 0x80
+ *                      Packet_Legth        = 152                               Dst_dword_offset   = 3
+ *                      IV_Offset           = 3
+ *                      Use_IV              = 0
+ *                      
+ *
+ *
+ *                         3     2     1     0                                  3     2     1     0
+ *                       -----------------------                              -----------------------
+ *                      | D20 | G   | G   | G   | <- ADD2                    | G   | G   | G   | ?   | <- ADD1 - 0x20
+ *                       -----------------------                              -----------------------
+ *                      | D24 | D23 | D22 | D21 |                            | D03 | D02 | D01 | D00 | <- ADD1
+ *                       -----------------------                              -----------------------
+ *                      | D28 | D27 | D26 | D25 |                            | D11 | D10 | D05 | D04 | <- ADD1 + 0x20
+ *                       -----------------------                              -----------------------
+ *                      | D2c | D2b | D2a | D29 |                            | D15 | D14 | D13 | D12 |
+ *                       -----------------------                              -----------------------
+ *                      |     | D2f | D2e | D2d |                            | D19 | D18 | D17 | D16 |
+ *                       -----------------------                              -----------------------
+ *                                                                           | D21 | D20 | D1b | D1a | <- ADD1 + 0x80
+ *                                                                            -----------------------
+ *                                                                           | D25 | D24 | D23 | D22 | 
+ *                                                                            -----------------------
+ *                                                                           | D29 | D28 | D27 | D26 | 
+ *                                                                            -----------------------
+ *                                                                           | D2d | D2c | D2b | D2a | 
+ *                                                                            -----------------------
+ *                                                                           |(D2d)|(D2c)| D2f | D2e | 
+ *                                                                            -----------------------
+ *
+ *                 It is worth noticing that always writing full-lines causes the last 2 dwords in the reconstituted
+ *                 packet to be unnecessarily written: (D2d) and (D2c)
+ *
+ *
+ *
+ *      B) Implications of fragmentation on AES
+ * 
+ *	        1) AES is a 128 bit block cipher; therefore it requires an even dword total data length
+ *                 Data fragments (provided there are more than 1) are allowed to have odd dword
+ *                 data lengths provided the total length (cumulated over fragments) is an even dword
+ *                 count; an error will be generated otherwise, upon receiving the last fragment descriptor
+ *                 (see error conditions below).
+ *
+ *              2) While using fragments with AES, a fragment (other than first) starting with a != 0 (IV) offset
+ *                 while the subsequent total dword count given to AES is odd may not be required to write
+ *                 its offset (UseIV). Doing so will cause an error (see error conditions below).
+ *
+ *
+ *                 Example:
+ *                 --------
+ *
+ *                 Suppose the first fragment has an odd DATA dword count and USES AES (as seen below)
+ *
+ *                      SOURCE:                                                 DESTINATION:
+ *                      -------                                                 ------------
+ *
+ *                      Segment_src_address = ADD0                              Cipher_dst_address = ADD1
+ *                      Packet_Legth        = 64                                Dst_dword_offset   = 1
+ *                      Cipher_Offset       = 3
+ *                      IV_Offset           = 1
+ *                      Use_IV              = 1
+ *                      Cipher              = Any AES
+ *                      Next                = 1
+ *                      
+ *
+ * 
+ *
+ *                         3     2     1     0                                  3     2     1     0
+ *                       -----------------------                              -----------------------
+ *                      | D00 | IV1 | IV0 | G   | <- ADD0                    | E00 | IV1 | IV0 | G   | <- ADD1
+ *                       -----------------------                              -----------------------
+ *                      | D04 | D03 | D02 | D01 |                            | X   | E03 | E02 | E01 |
+ *                       -----------------------                              -----------------------
+ *
+ *                 At the end of processing of the previous fragment, the AES engine input buffer has D04
+ *                 and waits for next dword, therefore the writeback buffer cannot finish writing the fragment
+ *                 to destination (X instead of E04).
+ *
+ *                 If a second fragment now arrives with a non-0 offset and requires the offset data to be
+ *                 written to destination, the previous write (still needing the arrival of the last dword
+ *                 required by the AES to complete the previous operation) cannot complete before the present
+ *                 should start causing a deadlock.
+ */
+
+/*
+ *  Command Control Word for Message Ring Descriptor
+ */
+
+/* #define MSG_CMD_CTL_CTL       */
+#define MSG_CMD_CTL_CTL_LSB   61
+#define MSG_CMD_CTL_CTL_BITS  THREE_BITS
+#define MSG_CMD_CTL_CTL_MASK  (MSG_CMD_CTL_CTL_BITS << MSG_CMD_CTL_CTL_LSB)
+
+/* #define MSG_CMD_CTL_ID */
+#define MSG_CMD_CTL_ID_LSB    54
+#define MSG_CMD_CTL_ID_BITS   SEVEN_BITS
+#define MSG_CMD_CTL_ID_MASK   (MSG_CMD_CTL_ID_BITS << MSG_CMD_CTL_ID_LSB)
+
+/* #define MSG_CMD_CTL_LEN */
+#define MSG_CMD_CTL_LEN_LSB   45
+#define MSG_CMD_CTL_LEN_BITS  FOUR_BITS
+#define MSG_CMD_CTL_LEN_MASK  (MSG_CMD_CTL_LEN_BITS << MSG_CMD_CTL_LEN_LSB)
+
+
+/* #define MSG_CMD_CTL_ADDR */
+#define MSG_CMD_CTL_ADDR_LSB  0
+#define MSG_CMD_CTL_ADDR_BITS FOURTY_BITS
+#define MSG_CMD_CTL_ADDR_MASK (MSG_CMD_CTL_ADDR_BITS << MSG_CMD_CTL_ADDR_LSB)
+
+#define MSG_CMD_CTL_MASK      (MSG_CMD_CTL_CTL_MASK | \
+                               MSG_CMD_CTL_LEN_MASK | MSG_CMD_CTL_ADDR_MASK)
+
+/*
+ *  Command Data Word for Message Ring Descriptor
+ */
+
+/* #define MSG_IN_DATA_CTL */
+#define MSG_CMD_DATA_CTL_LSB   61
+#define MSG_CMD_DATA_CTL_BITS  THREE_BITS
+#define MSG_CMD_DATA_CTL_MASK  (MSG_CMD_DATA_CTL_BITS  << MSG_CMD_DATA_CTL_LSB)
+
+/* #define MSG_CMD_DATA_LEN */
+#define MSG_CMD_DATA_LEN_LOAD  1
+#define MSG_CMD_DATA_LEN_LSB   45
+#define MSG_CMD_DATA_LEN_BITS  ONE_BIT
+#define MSG_CMD_DATA_LEN_MASK  (MSG_CMD_DATA_LEN_BITS << MSG_CMD_DATA_LEN_LSB)
+
+/* #define MSG_CMD_DATA_ADDR */
+#define MSG_CMD_DATA_ADDR_LSB  0
+#define MSG_CMD_DATA_ADDR_BITS FOURTY_BITS
+#define MSG_CMD_DATA_ADDR_MASK (MSG_CMD_DATA_ADDR_BITS << MSG_CMD_DATA_ADDR_LSB)
+
+#define MSG_CMD_DATA_MASK      (MSG_CMD_DATA_CTL_MASK | \
+                               MSG_CMD_DATA_LEN_MASK | MSG_CMD_DATA_ADDR_MASK)
+
+
+/*
+ * Upon completion of operation, the Sec block returns a 2-word free descriptor
+ * in the following format:
+ *
+ *  63  61 60            54 53   52 51       49  48          40 39             0
+ *  ----------------------------------------------------------------------------
+ * | Ctrl | Destination Id | 2'b00 | Desc Ctrl | Control Error | Source Address |
+ *  ----------------------------------------------------------------------------
+ * | Ctrl | Destination Id | 2'b00 | Desc Ctrl |   Data Error  | Dest Address   |
+ *  ----------------------------------------------------------------------------
+ *
+ * The Control and Data Error codes are enumerated below
+ *
+ *                                Error conditions
+ *                                ================
+ *
+ *             Control Error Code                  Control Error Condition
+ *             ------------------                  ---------------------------
+ *             9'h000                              No Error
+ *             9'h001                              Unknown Cipher Op                      ( Cipher == 3'h{6,7})
+ *             9'h002                              Unknown or Illegal Mode                ((Mode   == 3'h{2,3,4} & !AES) | (Mode   == 3'h{5,6,7}))
+ *             9'h004                              Unsupported CkSum Src                  (CkSum_Src   == 2'h{2,3} & CKSUM)
+ *             9'h008                              Forbidden CFB Mask                     (AES & CFBMode & UseNewKeysCFBMask & CFBMask[7] & (| CFBMask[6:0]))
+ *             9'h010                              Unknown Ctrl Op                        ((| Ctrl[63:37]) | (| Ctrl[15:14]))
+ *             9'h020                              UNUSED
+ *             9'h040                              UNUSED
+ *             9'h080                              Data Read Error
+ *             9'h100                              Descriptor Ctrl Field Error            (D0.Ctrl != SOP || D1.Ctrl != EOP)
+ *
+ *             Data Error Code                     Data Error Condition
+ *             ---------------                     --------------------
+ *             9'h000                              No Error
+ *             9'h001                              Insufficient Data To Cipher            (Packet_Length <= (Cipher_Offset or IV_Offset))
+ *             9'h002                              Illegal IV Location                    ((Cipher_Offset <  IV_Offset) | (Cipher_Offset <= IV_Offset & AES & ~CTR))
+ *             9'h004                              Illegal Wordcount To AES               (Packet_Length[3] != Cipher_Offset[0] & AES)
+ *             9'h008                              Illegal Pad And ByteCount Spec         (Hash_Byte_Count != 0 & !Pad_Hash)
+ *             9'h010                              Insufficient Data To CkSum             ({Packet_Length, 1'b0} <= CkSum_Offset)
+ *             9'h020                              Unknown Data Op                        ((| dstLLWMask[63:60]) | (| dstLLWMask[57:40]) | (| authDst[63:40]) | (| ckSumDst[63:40]))
+ *             9'h040                              Insufficient Data To Auth              ({Packet_Length} <= Auth_Offset)
+ *             9'h080                              Data Read Error
+ *             9'h100                              UNUSED
+ */
+
+/*
+ * Result Control Word for Message Ring Descriptor
+ */
+
+/* #define MSG_RSLT_CTL_CTL */
+#define MSG_RSLT_CTL_CTL_LSB      61
+#define MSG_RSLT_CTL_CTL_BITS     THREE_BITS
+#define MSG_RSLT_CTL_CTL_MASK \
+ (MSG_RSLT_CTL_CTL_BITS << MSG_RSLT_CTL_CTL_LSB)
+
+/* #define MSG_RSLT_CTL_DST_ID */
+#define MSG_RSLT_CTL_DST_ID_LSB   54
+#define MSG_RSLT_CTL_DST_ID_BITS  SEVEN_BITS
+#define MSG_RSLT_CTL_DST_ID_MASK \
+ (MSG_RSLT_CTL_DST_ID_BITS << MSG_RSLT_CTL_DST_ID_LSB)
+
+/* #define MSG_RSLT_CTL_DSC_CTL */
+#define MSG_RSLT_CTL_DSC_CTL_LSB  49
+#define MSG_RSLT_CTL_DSC_CTL_BITS THREE_BITS
+#define MSG_RSLT_CTL_DSC_CTL_MASK \
+ (MSG_RSLT_CTL_DSC_CTL_BITS << MSG_RSLT_CTL_DSC_CTL_LSB)
+
+/* #define MSG_RSLT_CTL_INST_ERR */
+#define MSG_RSLT_CTL_INST_ERR_LSB      40
+#define MSG_RSLT_CTL_INST_ERR_BITS     NINE_BITS
+#define MSG_RSLT_CTL_INST_ERR_MASK \
+ (MSG_RSLT_CTL_INST_ERR_BITS << MSG_RSLT_CTL_INST_ERR_LSB)
+
+/* #define MSG_RSLT_CTL_DSC_ADDR */
+#define MSG_RSLT_CTL_DSC_ADDR_LSB      0
+#define MSG_RSLT_CTL_DSC_ADDR_BITS     FOURTY_BITS
+#define MSG_RSLT_CTL_DSC_ADDR_MASK \
+ (MSG_RSLT_CTL_DSC_ADDR_BITS << MSG_RSLT_CTL_DSC_ADDR_LSB)
+
+/* #define MSG_RSLT_CTL_MASK */
+#define MSG_RSLT_CTL_MASK \
+ (MSG_RSLT_CTL_CTRL_MASK | MSG_RSLT_CTL_DST_ID_MASK | \
+  MSG_RSLT_CTL_DSC_CTL_MASK | MSG_RSLT_CTL_INST_ERR_MASK | \
+  MSG_RSLT_CTL_DSC_ADDR_MASK)
+
+/*
+ * Result Data Word for Message Ring Descriptor
+ */
+/* #define MSG_RSLT_DATA_CTL */
+#define MSG_RSLT_DATA_CTL_LSB     61
+#define MSG_RSLT_DATA_CTL_BITS    THREE_BITS
+#define MSG_RSLT_DATA_CTL_MASK \
+ (MSG_RSLT_DATA_CTL_BITS << MSG_RSLT_DATA_CTL_LSB)
+
+/* #define MSG_RSLT_DATA_DST_ID */
+#define MSG_RSLT_DATA_DST_ID_LSB  54
+#define MSG_RSLT_DATA_DST_ID_BITS SEVEN_BITS
+#define MSG_RSLT_DATA_DST_ID_MASK \
+ (MSG_RSLT_DATA_DST_ID_BITS << MSG_RSLT_DATA_DST_ID_LSB)
+
+/* #define MSG_RSLT_DATA_DSC_CTL */
+#define MSG_RSLT_DATA_DSC_CTL_LSB       49
+#define MSG_RSLT_DATA_DSC_CTL_BITS      THREE_BITS
+#define MSG_RSLT_DATA_DSC_CTL_MASK \
+ (MSG_RSLT_DATA_DSC_CTL_BITS << MSG_RSLT_DATA_DSC_CTL_LSB)
+
+/* #define MSG_RSLT_DATA_INST_ERR */
+#define MSG_RSLT_DATA_INST_ERR_LSB      40
+#define MSG_RSLT_DATA_INST_ERR_BITS     NINE_BITS
+#define MSG_RSLT_DATA_INST_ERR_MASK \
+ (MSG_RSLT_DATA_INST_ERR_BITS << MSG_RSLT_DATA_INST_ERR_LSB)
+
+/* #define MSG_RSLT_DATA_DSC_ADDR */
+#define MSG_RSLT_DATA_DSC_ADDR_LSB      0
+#define MSG_RSLT_DATA_DSC_ADDR_BITS     FOURTY_BITS
+#define MSG_RSLT_DATA_DSC_ADDR_MASK     \
+ (MSG_RSLT_DATA_DSC_ADDR_BITS << MSG_RSLT_DATA_DSC_ADDR_LSB)
+
+#define MSG_RSLT_DATA_MASK   \
+ (MSG_RSLT_DATA_CTRL_MASK | MSG_RSLT_DATA_DST_ID_MASK | \
+  MSG_RSLT_DATA_DSC_CTL_MASK | MSG_RSLT_DATA_INST_ERR_MASK | \
+  MSG_RSLT_DATA_DSC_ADDR_MASK)
+
+
+/*
+ * Common Message Definitions
+ *
+ */
+
+/* #define MSG_CTL_OP_ADDR */
+#define MSG_CTL_OP_ADDR_LSB      0
+#define MSG_CTL_OP_ADDR_BITS     FOURTY_BITS
+#define MSG_CTL_OP_ADDR_MASK     (MSG_CTL_OP_ADDR_BITS << MSG_CTL_OP_ADDR_LSB)
+
+#define MSG_CTL_OP_TYPE
+#define MSG_CTL_OP_TYPE_LSB             3
+#define MSG_CTL_OP_TYPE_BITS            TWO_BITS
+#define MSG_CTL_OP_TYPE_MASK            \
+ (MSG_CTL_OP_TYPE_BITS << MSG_CTL_OP_TYPE_LSB)
+
+#define MSG0_CTL_OP_ENGINE_SYMKEY       0x01
+#define MSG0_CTL_OP_ENGINE_PUBKEY       0x02
+
+#define MSG1_CTL_OP_SYMKEY_PIPE0        0x00
+#define MSG1_CTL_OP_SYMKEY_PIPE1        0x01
+#define MSG1_CTL_OP_SYMKEY_PIPE2        0x02
+#define MSG1_CTL_OP_SYMKEY_PIPE3        0x03
+
+#define MSG1_CTL_OP_PUBKEY_PIPE0        0x00
+#define MSG1_CTL_OP_PUBKEY_PIPE1        0x01
+#define MSG1_CTL_OP_PUBKEY_PIPE2        0x02
+#define MSG1_CTL_OP_PUBKEY_PIPE3        0x03
+
+
+/*       /----------------------------------------\
+ *       |                                        |
+ *       |   ControlDescriptor_s datastructure    |
+ *       |                                        |
+ *       \----------------------------------------/
+ *
+ *
+ *       ControlDescriptor_t.Instruction
+ *       -------------------------------
+ *
+ *   63    44         43               42            41              40           39        35 34    32 31  29     28
+ *  --------------------------------------------------------------------------------------------------------------------
+ * || UNUSED || OverrideCipher | Arc4Wait4Save | SaveArc4State | LoadArc4State | Arc4KeyLen | Cipher | Mode | InCp_Key || ... CONT ...
+ *  --------------------------------------------------------------------------------------------------------------------
+ *      20            1                1              1               1               5          3       3        1
+ *            <-----------------------------------------------CIPHER--------------------------------------------------->
+ *
+ *   27    25     24      23   22     21     20      19    17    16     15     0
+ *  -----------------------------------------------------------------------------
+ * || UNUSED | Hash_Hi | HMAC | Hash_Lo | InHs_Key || UNUSED || CkSum || UNUSED ||
+ *  -----------------------------------------------------------------------------
+ *      3         1       1        2         1          3        1        16
+ *  <---------------------HASH---------------------><-----------CKSUM----------->
+ *
+ *  X0  CIPHER.Arc4Wait4Save   =                   If op is Arc4 and it requires state saving, then
+ *                                                 setting this bit will cause the current op to
+ *                                                 delay subsequent op loading until saved state data
+ *                                                 becomes visible.
+ *      CIPHER.OverrideCipher  =                   Override encryption if PacketDescriptor_t.dstDataSettings.CipherPrefix
+ *                                                 is set; data will be copied out (and optionally auth/cksum)
+ *                                                 in the clear. This is used in GCM mode if auth only as we
+ *                                                 still need E(K, 0) calculated by cipher. Engine behavior is
+ *                                                 undefined if this bit is set and CipherPrefix is not.
+ *  X0         SaveArc4State   =                   Save Arc4 state at the end of Arc4 operation
+ *  X0         LoadArc4State   =                   Load Arc4 state at the beginning of an Arc4 operation
+ *                                                 This overriden by the InCp_Key setting for Arc4
+ *             Arc4KeyLen      =                   Length in bytes of Arc4 key (0 is interpreted as 32)
+ *                                                 Ignored for other ciphers
+ *                                                 For ARC4, IFetch/IDecode will always read exactly 4
+ *                                                 consecutive dwords into its CipherKey{0,3} regardless
+ *                                                 of this quantity; it will however only use the specified
+ *                                                 number of bytes.        
+ *             Cipher          =        3'b000     Bypass
+ *                                      3'b001     DES
+ *                                      3'b010     3DES
+ *                                      3'b011     AES 128-bit key
+ *                                      3'b100     AES 192-bit key
+ *                                      3'b101     AES 256-bit key
+ *                                      3'b110     ARC4
+ *                                      3'b111     Kasumi f8
+ *                                      Remainder  UNDEFINED
+ *             Mode            =        3'b000     ECB
+ *                                      3'b001     CBC
+ *                                      3'b010     CFB (AES only, otherwise undefined)
+ *                                      3'b011     OFB (AES only, otherwise undefined)
+ *                                      3'b100     CTR (AES only, otherwise undefined)
+ *                                      3'b101     F8  (AES only, otherwise undefined)
+ *                                      Remainder  UNDEFINED
+ *             InCp_Key        =        1'b0       Preserve old Cipher Keys
+ *                                      1'b1       Load new Cipher Keys from memory to local registers
+ *                                                 and recalculate the Arc4 Sbox if Arc4 Cipher chosen;
+ *                                                 This overrides LoadArc4State setting.
+ *        HASH.HMAC            =        1'b0       Hash without HMAC
+ *                                      1'b1       Hash with HMAC 
+ *                                                 Needs to be set to 0 for GCM and Kasumi F9 authenticators
+ *                                                 otherwise unpredictable results will be generated
+ *             Hash            =        2'b00      Hash NOP
+ *                                      2'b01      MD5
+ *                                      2'b10      SHA-1
+ *                                      2'b11      SHA-256
+ *                                      3'b100     SHA-384
+ *                                      3'b101     SHA-512
+ *                                      3'b110     GCM
+ *                                      3'b111     Kasumi f9
+ *             InHs_Key        =        1'b0       Preserve old HMAC Keys
+ *                                                 If GCM is selected as authenticator, leaving this bit
+ *                                                 at 0 will cause the engine to use the old H value.
+ *                                                 It will use the old SCI inside the decoder if
+ *                                                 CFBMask[1:0] == 2'b11.
+ *                                                 If Kasumi F9 authenticator, using 0 preserves
+ *                                                 old keys (IK) in decoder.
+ *                                      1'b1       Load new HMAC Keys from memory to local registers
+ *                                                 Setting this bit while Cipher=Arc4 and LoadArc4State=1
+ *                                                 causes the decoder to load the Arc4 state from the
+ *                                                 cacheline following the HMAC keys (Whether HASH.HMAC
+ *                                                 is set or not).
+ *                                                 If GCM is selected as authenticator, setting this bit
+ *                                                 causes both H (16 bytes) and SCI (8 bytes) to be loaded
+ *                                                 from memory to the decoder. H will be loaded to the engine
+ *                                                 but SCI is only loaded to the engine if CFBMask[1:0] == 2'b11.
+ *                                                 If Kasumi F9 authenticator, using 1 loads new keys (IK)
+ *                                                 from memory to decoder.
+ *    CHECKSUM.CkSum           =        1'b0       CkSum NOP
+ *                                      1'b1       INTERNET_CHECKSUM
+ *
+ *
+ *
+ */
+
+ /* #define CTRL_DSC_OVERRIDECIPHER */
+#define CTL_DSC_OVERRIDECIPHER_OFF       0
+#define CTL_DSC_OVERRIDECIPHER_ON        1
+#define CTL_DSC_OVERRIDECIPHER_LSB       43
+#define CTL_DSC_OVERRIDECIPHER_BITS      ONE_BIT
+#define CTL_DSC_OVERRIDECIPHER_MASK      (CTL_DSC_OVERRIDECIPHER_BITS << CTL_DSC_OVERRIDECIPHER_LSB)
+
+/* #define CTRL_DSC_ARC4_WAIT4SAVE */
+#define CTL_DSC_ARC4_WAIT4SAVE_OFF       0
+#define CTL_DSC_ARC4_WAIT4SAVE_ON        1
+#define CTL_DSC_ARC4_WAIT4SAVE_LSB       42
+#define CTL_DSC_ARC4_WAIT4SAVE_BITS      ONE_BIT
+#define CTL_DSC_ARC4_WAIT4SAVE_MASK      (CTL_DSC_ARC4_WAIT4SAVE_BITS << CTL_DSC_ARC4_WAIT4SAVE_LSB)
+
+/* #define CTRL_DSC_ARC4_SAVESTATE */
+#define CTL_DSC_ARC4_SAVESTATE_OFF       0
+#define CTL_DSC_ARC4_SAVESTATE_ON        1
+#define CTL_DSC_ARC4_SAVESTATE_LSB       41
+#define CTL_DSC_ARC4_SAVESTATE_BITS      ONE_BIT
+#define CTL_DSC_ARC4_SAVESTATE_MASK      (CTL_DSC_ARC4_SAVESTATE_BITS << CTL_DSC_ARC4_SAVESTATE_LSB)
+
+/* #define CTRL_DSC_ARC4_LOADSTATE */
+#define CTL_DSC_ARC4_LOADSTATE_OFF       0
+#define CTL_DSC_ARC4_LOADSTATE_ON        1
+#define CTL_DSC_ARC4_LOADSTATE_LSB       40
+#define CTL_DSC_ARC4_LOADSTATE_BITS      ONE_BIT
+#define CTL_DSC_ARC4_LOADSTATE_MASK      (CTL_DSC_ARC4_LOADSTATE_BITS << CTL_DSC_ARC4_LOADSTATE_LSB)
+
+/* #define CTRL_DSC_ARC4_KEYLEN */
+#define CTL_DSC_ARC4_KEYLEN_LSB          35
+#define CTL_DSC_ARC4_KEYLEN_BITS         FIVE_BITS
+#define CTL_DSC_ARC4_KEYLEN_MASK         (CTL_DSC_ARC4_KEYLEN_BITS << CTL_DSC_ARC4_KEYLEN_LSB)
+
+/* #define CTL_DSC_CPHR  (cipher) */
+#define CTL_DSC_CPHR_BYPASS       0	/* undefined */
+#define CTL_DSC_CPHR_DES          1
+#define CTL_DSC_CPHR_3DES         2
+#define CTL_DSC_CPHR_AES128       3
+#define CTL_DSC_CPHR_AES192       4
+#define CTL_DSC_CPHR_AES256       5
+#define CTL_DSC_CPHR_ARC4         6
+#define CTL_DSC_CPHR_KASUMI_F8    7
+#define CTL_DSC_CPHR_LSB          32
+#define CTL_DSC_CPHR_BITS         THREE_BITS
+#define CTL_DSC_CPHR_MASK         (CTL_DSC_CPHR_BITS << CTL_DSC_CPHR_LSB)
+
+/* #define CTL_DSC_MODE  */
+#define CTL_DSC_MODE_ECB          0
+#define CTL_DSC_MODE_CBC          1
+#define CTL_DSC_MODE_CFB          2
+#define CTL_DSC_MODE_OFB          3
+#define CTL_DSC_MODE_CTR          4
+#define CTL_DSC_MODE_F8           5
+#define CTL_DSC_MODE_LSB          29
+#define CTL_DSC_MODE_BITS         THREE_BITS
+#define CTL_DSC_MODE_MASK         (CTL_DSC_MODE_BITS << CTL_DSC_MODE_LSB)
+
+/* #define CTL_DSC_ICPHR */
+#define CTL_DSC_ICPHR_OKY          0	/* Old Keys */
+#define CTL_DSC_ICPHR_NKY          1	/* New Keys */
+#define CTL_DSC_ICPHR_LSB          28
+#define CTL_DSC_ICPHR_BITS         ONE_BIT
+#define CTL_DSC_ICPHR_MASK         (CTL_DSC_ICPHR_BITS << CTL_DSC_ICPHR_LSB)
+
+/* #define CTL_DSC_HASHHI */
+#define CTL_DSC_HASHHI_LSB          24
+#define CTL_DSC_HASHHI_BITS         ONE_BIT
+#define CTL_DSC_HASHHI_MASK         (CTL_DSC_HASHHI_BITS << CTL_DSC_HASHHI_LSB)
+
+/* #define CTL_DSC_HMAC */
+#define CTL_DSC_HMAC_OFF          0
+#define CTL_DSC_HMAC_ON           1
+#define CTL_DSC_HMAC_LSB          23
+#define CTL_DSC_HMAC_BITS         ONE_BIT
+#define CTL_DSC_HMAC_MASK         (CTL_DSC_HMAC_BITS << CTL_DSC_HMAC_LSB)
+
+/* #define CTL_DSC_HASH */
+#define CTL_DSC_HASH_NOP          0
+#define CTL_DSC_HASH_MD5          1
+#define CTL_DSC_HASH_SHA1         2
+#define CTL_DSC_HASH_SHA256       3
+#define CTL_DSC_HASH_SHA384       4
+#define CTL_DSC_HASH_SHA512       5
+#define CTL_DSC_HASH_GCM          6
+#define CTL_DSC_HASH_KASUMI_F9    7
+#define CTL_DSC_HASH_LSB          21
+#define CTL_DSC_HASH_BITS         TWO_BITS
+#define CTL_DSC_HASH_MASK         (CTL_DSC_HASH_BITS << CTL_DSC_HASH_LSB)
+
+/* #define CTL_DSC_IHASH */
+#define CTL_DSC_IHASH_OLD         0
+#define CTL_DSC_IHASH_NEW         1
+#define CTL_DSC_IHASH_LSB         20
+#define CTL_DSC_IHASH_BITS        ONE_BIT
+#define CTL_DSC_IHASH_MASK        (CTL_DSC_IHASH_BITS << CTL_DSC_IHASH_LSB)
+
+/* #define CTL_DSC_CKSUM */
+#define CTL_DSC_CKSUM_NOP         0
+#define CTL_DSC_CKSUM_IP          1
+#define CTL_DSC_CKSUM_LSB         16
+#define CTL_DSC_CKSUM_BITS        ONE_BIT
+#define CTL_DSC_CKSUM_MASK        (CTL_DSC_CKSUM_BITS << CTL_DSC_CKSUM_LSB)
+
+
+/*
+ * Component strcts and unions defining CipherHashInfo_u
+ */
+
+/* AES256, (ECB, CBC, OFB, CTR, CFB), HMAC (MD5, SHA-1, SHA-256)      - 96  bytes */
+typedef struct AES256HMAC_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t cipherKey3;
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+} AES256HMAC_t, *AES256HMAC_pt;
+
+/* AES256, (ECB, CBC, OFB, CTR, CFB), HMAC (SHA-384, SHA-512)      - 160  bytes */
+typedef struct AES256HMAC2_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t cipherKey3;
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+	uint64_t hmacKey8;
+	uint64_t hmacKey9;
+	uint64_t hmacKey10;
+	uint64_t hmacKey11;
+	uint64_t hmacKey12;
+	uint64_t hmacKey13;
+	uint64_t hmacKey14;
+	uint64_t hmacKey15;
+} AES256HMAC2_t, *AES256HMAC2_pt;
+
+/* AES256, (ECB, CBC, OFB, CTR, CFB), GCM      - 56  bytes */
+typedef struct AES256GCM_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t cipherKey3;
+	uint64_t GCMH0;
+	uint64_t GCMH1;
+	uint64_t GCMSCI;
+} AES256GCM_t, *AES256GCM_pt;
+
+/* AES256, (ECB, CBC, OFB, CTR, CFB), F9      - 56  bytes */
+typedef struct AES256F9_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t cipherKey3;
+	uint64_t authKey0;
+	uint64_t authKey1;
+} AES256F9_t, *AES256F9_pt;
+
+/* AES256, (ECB, CBC, OFB, CTR, CFB), Non-HMAC (MD5, SHA-1, SHA-256)  - 32  bytes */
+typedef struct AES256_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t cipherKey3;
+} AES256_t, *AES256_pt;
+
+
+/* All AES192 possibilities */
+
+/* AES192, (ECB, CBC, OFB, CTR, CFB), HMAC (MD5, SHA-1, SHA-192)      - 88  bytes */
+typedef struct AES192HMAC_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+} AES192HMAC_t, *AES192HMAC_pt;
+
+/* AES192, (ECB, CBC, OFB, CTR, CFB), HMAC (SHA-384, SHA-512)      - 152  bytes */
+typedef struct AES192HMAC2_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+	uint64_t hmacKey8;
+	uint64_t hmacKey9;
+	uint64_t hmacKey10;
+	uint64_t hmacKey11;
+	uint64_t hmacKey12;
+	uint64_t hmacKey13;
+	uint64_t hmacKey14;
+	uint64_t hmacKey15;
+} AES192HMAC2_t, *AES192HMAC2_pt;
+
+/* AES192, (ECB, CBC, OFB, CTR, CFB), GCM      - 48  bytes */
+typedef struct AES192GCM_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t GCMH0;
+	uint64_t GCMH1;
+	uint64_t GCMSCI;
+} AES192GCM_t, *AES192GCM_pt;
+
+/* AES192, (ECB, CBC, OFB, CTR, CFB), F9      - 48  bytes */
+typedef struct AES192F9_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t authKey0;
+	uint64_t authKey1;
+} AES192F9_t, *AES192F9_pt;
+
+/* AES192, (ECB, CBC, OFB, CTR, CFB), Non-HMAC (MD5, SHA-1, SHA-192)  - 24  bytes */
+typedef struct AES192_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+} AES192_t, *AES192_pt;
+
+
+/* All AES128 possibilities */
+
+/* AES128, (ECB, CBC, OFB, CTR, CFB), HMAC (MD5, SHA-1, SHA-128)      - 80  bytes */
+typedef struct AES128HMAC_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+} AES128HMAC_t, *AES128HMAC_pt;
+
+/* AES128, (ECB, CBC, OFB, CTR, CFB), HMAC (SHA-384, SHA-612)      - 144  bytes */
+typedef struct AES128HMAC2_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+	uint64_t hmacKey8;
+	uint64_t hmacKey9;
+	uint64_t hmacKey10;
+	uint64_t hmacKey11;
+	uint64_t hmacKey12;
+	uint64_t hmacKey13;
+	uint64_t hmacKey14;
+	uint64_t hmacKey15;
+} AES128HMAC2_t, *AES128HMAC2_pt;
+
+/* AES128, (ECB, CBC, OFB, CTR, CFB), GCM      - 40  bytes */
+typedef struct AES128GCM_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t GCMH0;
+	uint64_t GCMH1;
+	uint64_t GCMSCI;
+} AES128GCM_t, *AES128GCM_pt;
+
+/* AES128, (ECB, CBC, OFB, CTR, CFB), F9      - 48  bytes */
+typedef struct AES128F9_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t authKey0;
+	uint64_t authKey1;
+} AES128F9_t, *AES128F9_pt;
+
+/* AES128, (ECB, CBC, OFB, CTR, CFB), Non-HMAC (MD5, SHA-1, SHA-128)  - 16  bytes */
+typedef struct AES128_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+} AES128_t, *AES128_pt;
+
+/* AES128, (OFB F8), Non-HMAC (MD5, SHA-1, SHA-256)  - 32  bytes */
+typedef struct AES128F8_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKeyMask0;
+	uint64_t cipherKeyMask1;
+} AES128F8_t, *AES128F8_pt;
+
+/* AES128, (OFB F8), HMAC (MD5, SHA-1, SHA-256)  - 96  bytes */
+typedef struct AES128F8HMAC_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKeyMask0;
+	uint64_t cipherKeyMask1;
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+} AES128F8HMAC_t, *AES128F8HMAC_pt;
+
+/* AES128, (OFB F8), HMAC (SHA-384, SHA-512)  - 160  bytes */
+typedef struct AES128F8HMAC2_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKeyMask0;
+	uint64_t cipherKeyMask1;
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+	uint64_t hmacKey8;
+	uint64_t hmacKey9;
+	uint64_t hmacKey10;
+	uint64_t hmacKey11;
+	uint64_t hmacKey12;
+	uint64_t hmacKey13;
+	uint64_t hmacKey14;
+	uint64_t hmacKey15;
+} AES128F8HMAC2_t, *AES128F8HMAC2_pt;
+
+/* AES192, (OFB F8), Non-HMAC (MD5, SHA-1, SHA-256)  - 48  bytes */
+typedef struct AES192F8_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t cipherKeyMask0;
+	uint64_t cipherKeyMask1;
+	uint64_t cipherKeyMask2;
+} AES192F8_t, *AES192F8_pt;
+
+/* AES192, (OFB F8), HMAC (MD5, SHA-1, SHA-256)  - 112 bytes */
+typedef struct AES192F8HMAC_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t cipherKeyMask0;
+	uint64_t cipherKeyMask1;
+	uint64_t cipherKeyMask2;
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+} AES192F8HMAC_t, *AES192F8HMAC_pt;
+
+/* AES192, (OFB F8), HMAC (SHA-384, SHA-512)  - 176 bytes */
+typedef struct AES192F8HMAC2_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t cipherKeyMask0;
+	uint64_t cipherKeyMask1;
+	uint64_t cipherKeyMask2;
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+	uint64_t hmacKey8;
+	uint64_t hmacKey9;
+	uint64_t hmacKey10;
+	uint64_t hmacKey11;
+	uint64_t hmacKey12;
+	uint64_t hmacKey13;
+	uint64_t hmacKey14;
+	uint64_t hmacKey15;
+} AES192F8HMAC2_t, *AES192F8HMAC2_pt;
+
+/* AES256, (OFB F8), Non-HMAC (MD5, SHA-1, SHA-256)  - 64  bytes */
+typedef struct AES256F8_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t cipherKey3;
+	uint64_t cipherKeyMask0;
+	uint64_t cipherKeyMask1;
+	uint64_t cipherKeyMask2;
+	uint64_t cipherKeyMask3;
+} AES256F8_t, *AES256F8_pt;
+
+/* AES256, (OFB F8), HMAC (MD5, SHA-1, SHA-256)  - 128  bytes */
+typedef struct AES256F8HMAC_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t cipherKey3;
+	uint64_t cipherKeyMask0;
+	uint64_t cipherKeyMask1;
+	uint64_t cipherKeyMask2;
+	uint64_t cipherKeyMask3;
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+} AES256F8HMAC_t, *AES256F8HMAC_pt;
+
+/* AES256, (OFB F8), HMAC (SHA-384, SHA-512)  - 192  bytes */
+typedef struct AES256F8HMAC2_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t cipherKey3;
+	uint64_t cipherKeyMask0;
+	uint64_t cipherKeyMask1;
+	uint64_t cipherKeyMask2;
+	uint64_t cipherKeyMask3;
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+	uint64_t hmacKey8;
+	uint64_t hmacKey9;
+	uint64_t hmacKey10;
+	uint64_t hmacKey11;
+	uint64_t hmacKey12;
+	uint64_t hmacKey13;
+	uint64_t hmacKey14;
+	uint64_t hmacKey15;
+} AES256F8HMAC2_t, *AES256F8HMAC2_pt;
+
+/* AES256, (F8), GCM      - 40  bytes */
+typedef struct AES128F8GCM_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey2;
+	uint64_t GCMH0;
+	uint64_t GCMH1;
+	uint64_t GCMSCI;
+} AES128F8GCM_t, *AES128F8GCM_pt;
+
+/* AES256, (F8), GCM      - 48  bytes */
+typedef struct AES192F8GCM_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t GCMH0;
+	uint64_t GCMH1;
+	uint64_t GCMSCI;
+} AES192F8GCM_t, *AES192F8GCM_pt;
+
+/* AES256, (F8), GCM      - 56  bytes */
+typedef struct AES256F8GCM_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t cipherKey3;
+	uint64_t GCMH0;
+	uint64_t GCMH1;
+	uint64_t GCMSCI;
+} AES256F8GCM_t, *AES256F8GCM_pt;
+
+/* AES256, (F8), F9      - 40  bytes */
+typedef struct AES128F8F9_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey2;
+	uint64_t authKey0;
+	uint64_t authKey1;
+} AES128F8F9_t, *AES128F8F9_pt;
+
+/* AES256, (F8), F9      - 48  bytes */
+typedef struct AES192F8F9_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t authKey0;
+	uint64_t authKey1;
+} AES192F8F9_t, *AES192F8F9_pt;
+
+/* AES256F8, (F8), F9      - 56  bytes */
+typedef struct AES256F8F9_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t cipherKey3;
+	uint64_t authKey0;
+	uint64_t authKey1;
+} AES256F8F9_t, *AES256F8F9_pt;
+
+/* All DES possibilities */
+
+/* DES, (ECB, CBC), HMAC (MD5, SHA-1, SHA-128)              - 72  bytes */
+typedef struct DESHMAC_s
+{
+	uint64_t cipherKey0;
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+} DESHMAC_t, *DESHMAC_pt;
+
+/* DES, (ECB, CBC), HMAC (SHA-384, SHA-512)              - 136  bytes */
+typedef struct DESHMAC2_s
+{
+	uint64_t cipherKey0;
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+	uint64_t hmacKey8;
+	uint64_t hmacKey9;
+	uint64_t hmacKey10;
+	uint64_t hmacKey11;
+	uint64_t hmacKey12;
+	uint64_t hmacKey13;
+	uint64_t hmacKey14;
+	uint64_t hmacKey15;
+} DESHMAC2_t, *DESHMAC2_pt;
+
+/* DES, (ECB, CBC), GCM              - 32  bytes */
+typedef struct DESGCM_s
+{
+	uint64_t cipherKey0;
+	uint64_t GCMH0;
+	uint64_t GCMH1;
+	uint64_t GCMSCI;
+} DESGCM_t, *DESGCM_pt;
+
+/* DES, (ECB, CBC), F9              - 32  bytes */
+typedef struct DESF9_s
+{
+	uint64_t cipherKey0;
+	uint64_t authKey0;
+	uint64_t authKey1;
+} DESF9_t, *DESF9_pt;
+
+/* DES, (ECB, CBC), Non-HMAC (MD5, SHA-1, SHA-128)          - 9   bytes */
+typedef struct DES_s
+{
+	uint64_t cipherKey0;
+} DES_t, *DES_pt;
+
+
+/* All 3DES possibilities */
+
+/* 3DES, (ECB, CBC), HMAC (MD5, SHA-1, SHA-128)             - 88  bytes */
+typedef struct DES3HMAC_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+} DES3HMAC_t, *DES3HMAC_pt;
+
+/* 3DES, (ECB, CBC), HMAC (SHA-384, SHA-512)             - 152  bytes */
+typedef struct DES3HMAC2_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+	uint64_t hmacKey8;
+	uint64_t hmacKey9;
+	uint64_t hmacKey10;
+	uint64_t hmacKey11;
+	uint64_t hmacKey12;
+	uint64_t hmacKey13;
+	uint64_t hmacKey14;
+	uint64_t hmacKey15;
+} DES3HMAC2_t, *DES3HMAC2_pt;
+
+/* 3DES, (ECB, CBC), GCM             - 48  bytes */
+typedef struct DES3GCM_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t GCMH0;
+	uint64_t GCMH1;
+	uint64_t GCMSCI;
+} DES3GCM_t, *DES3GCM_pt;
+
+/* 3DES, (ECB, CBC), GCM             - 48  bytes */
+typedef struct DES3F9_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t authKey0;
+	uint64_t authKey1;
+} DES3F9_t, *DES3F9_pt;
+
+/* 3DES, (ECB, CBC), Non-HMAC (MD5, SHA-1, SHA-128)         - 24  bytes */
+typedef struct DES3_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+} DES3_t, *DES3_pt;
+
+
+/* HMAC only - no cipher */
+
+/* HMAC (MD5, SHA-1, SHA-128)                               - 64  bytes */
+typedef struct HMAC_s
+{
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+} HMAC_t, *HMAC_pt;
+
+/* HMAC (SHA-384, SHA-512)                               - 128  bytes */
+typedef struct HMAC2_s
+{
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+	uint64_t hmacKey8;
+	uint64_t hmacKey9;
+	uint64_t hmacKey10;
+	uint64_t hmacKey11;
+	uint64_t hmacKey12;
+	uint64_t hmacKey13;
+	uint64_t hmacKey14;
+	uint64_t hmacKey15;
+} HMAC2_t, *HMAC2_pt;
+
+/* GCM                               - 24  bytes */
+typedef struct GCM_s
+{
+	uint64_t GCMH0;
+	uint64_t GCMH1;
+	uint64_t GCMSCI;
+} GCM_t, *GCM_pt;
+
+/* F9                               - 24  bytes */
+typedef struct F9_s
+{
+	uint64_t authKey0;
+	uint64_t authKey1;
+} F9_t, *F9_pt;
+
+/* All ARC4 possibilities */
+/* ARC4, HMAC (MD5, SHA-1, SHA-256)      - 96 bytes */
+typedef struct ARC4HMAC_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t cipherKey3;
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+} ARC4HMAC_t, *ARC4HMAC_pt;
+
+/* ARC4, HMAC (SHA-384, SHA-512)      - 160 bytes */
+typedef struct ARC4HMAC2_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t cipherKey3;
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+	uint64_t hmacKey8;
+	uint64_t hmacKey9;
+	uint64_t hmacKey10;
+	uint64_t hmacKey11;
+	uint64_t hmacKey12;
+	uint64_t hmacKey13;
+	uint64_t hmacKey14;
+	uint64_t hmacKey15;
+} ARC4HMAC2_t, *ARC4HMAC2_pt;
+
+/* ARC4, GCM      - 56 bytes */
+typedef struct ARC4GCM_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t cipherKey3;
+	uint64_t GCMH0;
+	uint64_t GCMH1;
+	uint64_t GCMSCI;
+} ARC4GCM_t, *ARC4GCM_pt;
+
+/* ARC4, F9      - 56 bytes */
+typedef struct ARC4F9_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t cipherKey3;
+	uint64_t authKey0;
+	uint64_t authKey1;
+} ARC4F9_t, *ARC4F9_pt;
+
+/* ARC4, HMAC (MD5, SHA-1, SHA-256)      - 408 bytes (not including 8 bytes from instruction) */
+typedef struct ARC4StateHMAC_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t cipherKey3;
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+	uint64_t PAD0;
+	uint64_t PAD1;
+	uint64_t PAD2;
+	uint64_t Arc4SboxData0;
+	uint64_t Arc4SboxData1;
+	uint64_t Arc4SboxData2;
+	uint64_t Arc4SboxData3;
+	uint64_t Arc4SboxData4;
+	uint64_t Arc4SboxData5;
+	uint64_t Arc4SboxData6;
+	uint64_t Arc4SboxData7;
+	uint64_t Arc4SboxData8;
+	uint64_t Arc4SboxData9;
+	uint64_t Arc4SboxData10;
+	uint64_t Arc4SboxData11;
+	uint64_t Arc4SboxData12;
+	uint64_t Arc4SboxData13;
+	uint64_t Arc4SboxData14;
+	uint64_t Arc4SboxData15;
+	uint64_t Arc4SboxData16;
+	uint64_t Arc4SboxData17;
+	uint64_t Arc4SboxData18;
+	uint64_t Arc4SboxData19;
+	uint64_t Arc4SboxData20;
+	uint64_t Arc4SboxData21;
+	uint64_t Arc4SboxData22;
+	uint64_t Arc4SboxData23;
+	uint64_t Arc4SboxData24;
+	uint64_t Arc4SboxData25;
+	uint64_t Arc4SboxData26;
+	uint64_t Arc4SboxData27;
+	uint64_t Arc4SboxData28;
+	uint64_t Arc4SboxData29;
+	uint64_t Arc4SboxData30;
+	uint64_t Arc4SboxData31;
+	uint64_t Arc4IJData;
+	uint64_t PAD3;
+	uint64_t PAD4;
+	uint64_t PAD5;
+} ARC4StateHMAC_t, *ARC4StateHMAC_pt;
+
+/* ARC4, HMAC (SHA-384, SHA-512)      - 480 bytes (not including 8 bytes from instruction) */
+typedef struct ARC4StateHMAC2_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t cipherKey3;
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+	uint64_t hmacKey8;
+	uint64_t hmacKey9;
+	uint64_t hmacKey10;
+	uint64_t hmacKey11;
+	uint64_t hmacKey12;
+	uint64_t hmacKey13;
+	uint64_t hmacKey14;
+	uint64_t hmacKey15;
+	uint64_t PAD0;
+	uint64_t PAD1;
+	uint64_t PAD2;
+	uint64_t Arc4SboxData0;
+	uint64_t Arc4SboxData1;
+	uint64_t Arc4SboxData2;
+	uint64_t Arc4SboxData3;
+	uint64_t Arc4SboxData4;
+	uint64_t Arc4SboxData5;
+	uint64_t Arc4SboxData6;
+	uint64_t Arc4SboxData7;
+	uint64_t Arc4SboxData8;
+	uint64_t Arc4SboxData9;
+	uint64_t Arc4SboxData10;
+	uint64_t Arc4SboxData11;
+	uint64_t Arc4SboxData12;
+	uint64_t Arc4SboxData13;
+	uint64_t Arc4SboxData14;
+	uint64_t Arc4SboxData15;
+	uint64_t Arc4SboxData16;
+	uint64_t Arc4SboxData17;
+	uint64_t Arc4SboxData18;
+	uint64_t Arc4SboxData19;
+	uint64_t Arc4SboxData20;
+	uint64_t Arc4SboxData21;
+	uint64_t Arc4SboxData22;
+	uint64_t Arc4SboxData23;
+	uint64_t Arc4SboxData24;
+	uint64_t Arc4SboxData25;
+	uint64_t Arc4SboxData26;
+	uint64_t Arc4SboxData27;
+	uint64_t Arc4SboxData28;
+	uint64_t Arc4SboxData29;
+	uint64_t Arc4SboxData30;
+	uint64_t Arc4SboxData31;
+	uint64_t Arc4IJData;
+	uint64_t PAD3;
+	uint64_t PAD4;
+	uint64_t PAD5;
+} ARC4StateHMAC2_t, *ARC4StateHMAC2_pt;
+
+/* ARC4, GCM      - 408 bytes (not including 8 bytes from instruction) */
+typedef struct ARC4StateGCM_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t cipherKey3;
+	uint64_t GCMH0;
+	uint64_t GCMH1;
+	uint64_t GCMSCI;
+	uint64_t PAD0;
+	uint64_t PAD1;
+	uint64_t PAD2;
+	uint64_t PAD3;
+	uint64_t PAD4;
+	uint64_t PAD5;
+	uint64_t PAD6;
+	uint64_t PAD7;
+	uint64_t Arc4SboxData0;
+	uint64_t Arc4SboxData1;
+	uint64_t Arc4SboxData2;
+	uint64_t Arc4SboxData3;
+	uint64_t Arc4SboxData4;
+	uint64_t Arc4SboxData5;
+	uint64_t Arc4SboxData6;
+	uint64_t Arc4SboxData7;
+	uint64_t Arc4SboxData8;
+	uint64_t Arc4SboxData9;
+	uint64_t Arc4SboxData10;
+	uint64_t Arc4SboxData11;
+	uint64_t Arc4SboxData12;
+	uint64_t Arc4SboxData13;
+	uint64_t Arc4SboxData14;
+	uint64_t Arc4SboxData15;
+	uint64_t Arc4SboxData16;
+	uint64_t Arc4SboxData17;
+	uint64_t Arc4SboxData18;
+	uint64_t Arc4SboxData19;
+	uint64_t Arc4SboxData20;
+	uint64_t Arc4SboxData21;
+	uint64_t Arc4SboxData22;
+	uint64_t Arc4SboxData23;
+	uint64_t Arc4SboxData24;
+	uint64_t Arc4SboxData25;
+	uint64_t Arc4SboxData26;
+	uint64_t Arc4SboxData27;
+	uint64_t Arc4SboxData28;
+	uint64_t Arc4SboxData29;
+	uint64_t Arc4SboxData30;
+	uint64_t Arc4SboxData31;
+	uint64_t Arc4IJData;
+	uint64_t PAD8;
+	uint64_t PAD9;
+	uint64_t PAD10;
+} ARC4StateGCM_t, *ARC4StateGCM_pt;
+
+/* ARC4, F9      - 408 bytes (not including 8 bytes from instruction) */
+typedef struct ARC4StateF9_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t cipherKey3;
+	uint64_t authKey0;
+	uint64_t authKey1;
+	uint64_t PAD0;
+	uint64_t PAD1;
+	uint64_t PAD2;
+	uint64_t PAD3;
+	uint64_t PAD4;
+	uint64_t PAD5;
+	uint64_t PAD6;
+	uint64_t PAD7;
+	uint64_t PAD8;
+	uint64_t Arc4SboxData0;
+	uint64_t Arc4SboxData1;
+	uint64_t Arc4SboxData2;
+	uint64_t Arc4SboxData3;
+	uint64_t Arc4SboxData4;
+	uint64_t Arc4SboxData5;
+	uint64_t Arc4SboxData6;
+	uint64_t Arc4SboxData7;
+	uint64_t Arc4SboxData8;
+	uint64_t Arc4SboxData9;
+	uint64_t Arc4SboxData10;
+	uint64_t Arc4SboxData11;
+	uint64_t Arc4SboxData12;
+	uint64_t Arc4SboxData13;
+	uint64_t Arc4SboxData14;
+	uint64_t Arc4SboxData15;
+	uint64_t Arc4SboxData16;
+	uint64_t Arc4SboxData17;
+	uint64_t Arc4SboxData18;
+	uint64_t Arc4SboxData19;
+	uint64_t Arc4SboxData20;
+	uint64_t Arc4SboxData21;
+	uint64_t Arc4SboxData22;
+	uint64_t Arc4SboxData23;
+	uint64_t Arc4SboxData24;
+	uint64_t Arc4SboxData25;
+	uint64_t Arc4SboxData26;
+	uint64_t Arc4SboxData27;
+	uint64_t Arc4SboxData28;
+	uint64_t Arc4SboxData29;
+	uint64_t Arc4SboxData30;
+	uint64_t Arc4SboxData31;
+	uint64_t Arc4IJData;
+	uint64_t PAD9;
+	uint64_t PAD10;
+	uint64_t PAD11;
+} ARC4StateF9_t, *ARC4StateF9_pt;
+
+/* ARC4, Non-HMAC (MD5, SHA-1, SHA-256)  - 32  bytes */
+typedef struct ARC4_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t cipherKey3;
+} ARC4_t, *ARC4_pt;
+
+/* ARC4, Non-HMAC (MD5, SHA-1, SHA-256)  - 344  bytes (not including 8 bytes from instruction) */
+typedef struct ARC4State_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t cipherKey2;
+	uint64_t cipherKey3;
+	uint64_t PAD0;
+	uint64_t PAD1;
+	uint64_t PAD2;
+	uint64_t Arc4SboxData0;
+	uint64_t Arc4SboxData1;
+	uint64_t Arc4SboxData2;
+	uint64_t Arc4SboxData3;
+	uint64_t Arc4SboxData4;
+	uint64_t Arc4SboxData5;
+	uint64_t Arc4SboxData6;
+	uint64_t Arc4SboxData7;
+	uint64_t Arc4SboxData8;
+	uint64_t Arc4SboxData9;
+	uint64_t Arc4SboxData10;
+	uint64_t Arc4SboxData11;
+	uint64_t Arc4SboxData12;
+	uint64_t Arc4SboxData13;
+	uint64_t Arc4SboxData14;
+	uint64_t Arc4SboxData15;
+	uint64_t Arc4SboxData16;
+	uint64_t Arc4SboxData17;
+	uint64_t Arc4SboxData18;
+	uint64_t Arc4SboxData19;
+	uint64_t Arc4SboxData20;
+	uint64_t Arc4SboxData21;
+	uint64_t Arc4SboxData22;
+	uint64_t Arc4SboxData23;
+	uint64_t Arc4SboxData24;
+	uint64_t Arc4SboxData25;
+	uint64_t Arc4SboxData26;
+	uint64_t Arc4SboxData27;
+	uint64_t Arc4SboxData28;
+	uint64_t Arc4SboxData29;
+	uint64_t Arc4SboxData30;
+	uint64_t Arc4SboxData31;
+	uint64_t Arc4IJData;
+	uint64_t PAD3;
+	uint64_t PAD4;
+	uint64_t PAD5;
+} ARC4State_t, *ARC4State_pt;
+
+/* Kasumi f8  - 32  bytes */
+typedef struct KASUMIF8_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+} KASUMIF8_t, *KASUMIF8_pt;
+
+/* Kasumi f8 + HMAC (MD5, SHA-1, SHA-256)  - 80  bytes */
+typedef struct KASUMIF8HMAC_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+} KASUMIF8HMAC_t, *KASUMIF8HMAC_pt;
+
+/* Kasumi f8 + HMAC (SHA-384, SHA-512)  - 144 bytes */
+typedef struct KASUMIF8HMAC2_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t hmacKey0;
+	uint64_t hmacKey1;
+	uint64_t hmacKey2;
+	uint64_t hmacKey3;
+	uint64_t hmacKey4;
+	uint64_t hmacKey5;
+	uint64_t hmacKey6;
+	uint64_t hmacKey7;
+	uint64_t hmacKey8;
+	uint64_t hmacKey9;
+	uint64_t hmacKey10;
+	uint64_t hmacKey11;
+	uint64_t hmacKey12;
+	uint64_t hmacKey13;
+	uint64_t hmacKey14;
+	uint64_t hmacKey15;
+} KASUMIF8HMAC2_t, *KASUMIF8HMAC2_pt;
+
+/* Kasumi f8 + GCM  - 144 bytes */
+typedef struct KASUMIF8GCM_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t GCMH0;
+	uint64_t GCMH1;
+	uint64_t GCMSCI;
+} KASUMIF8GCM_t, *KASUMIF8GCM_pt;
+
+/* Kasumi f8 + f9  - 32  bytes */
+typedef struct KASUMIF8F9_s
+{
+	uint64_t cipherKey0;
+	uint64_t cipherKey1;
+	uint64_t authKey0;
+	uint64_t authKey1;
+} KASUMIF8F9_t, *KASUMIF8F9_pt;
+
+typedef union CipherHashInfo_u
+{
+	AES256HMAC_t infoAES256HMAC;
+	AES256_t infoAES256;
+	AES192HMAC_t infoAES192HMAC;
+	AES192_t infoAES192;
+	AES128HMAC_t infoAES128HMAC;
+	AES128_t infoAES128;
+	DESHMAC_t infoDESHMAC;
+	DES_t infoDES;
+	DES3HMAC_t info3DESHMAC;
+	DES3_t info3DES;
+	HMAC_t infoHMAC;
+	/* ARC4 */
+	ARC4HMAC_t infoARC4HMAC;
+	ARC4StateHMAC_t infoARC4StateHMAC;
+	ARC4_t infoARC4;
+	ARC4State_t infoARC4State;
+	/* AES mode F8 */
+	AES256F8HMAC_t infoAES256F8HMAC;
+	AES256F8_t infoAES256F8;
+	AES192F8HMAC_t infoAES192F8HMAC;
+	AES192F8_t infoAES192F8;
+	AES128F8HMAC_t infoAES128F8HMAC;
+	AES128F8_t infoAES128F8;
+	/* KASUMI F8 */
+	KASUMIF8HMAC_t infoKASUMIF8HMAC;
+	KASUMIF8_t infoKASUMIF8;
+	/* GCM */
+	GCM_t infoGCM;
+	AES256F8GCM_t infoAES256F8GCM;
+	AES192F8GCM_t infoAES192F8GCM;
+	AES128F8GCM_t infoAES128F8GCM;
+	AES256GCM_t infoAES256GCM;
+	AES192GCM_t infoAES192GCM;
+	AES128GCM_t infoAES128GCM;
+	DESGCM_t infoDESGCM;
+	DES3GCM_t info3DESGCM;
+	ARC4GCM_t infoARC4GCM;
+	ARC4StateGCM_t infoARC4StateGCM;
+	KASUMIF8GCM_t infoKASUMIF8GCM;
+	/* HMAC2 */
+	HMAC2_t infoHMAC2;
+	AES256F8HMAC2_t infoAES256F8HMAC2;
+	AES192F8HMAC2_t infoAES192F8HMAC2;
+	AES128F8HMAC2_t infoAES128F8HMAC2;
+	AES256HMAC2_t infoAES256HMAC2;
+	AES192HMAC2_t infoAES192HMAC2;
+	AES128HMAC2_t infoAES128HMAC2;
+	DESHMAC2_t infoDESHMAC2;
+	DES3HMAC2_t info3DESHMAC2;
+	ARC4HMAC2_t infoARC4HMAC2;
+	ARC4StateHMAC2_t infoARC4StateHMAC2;
+	KASUMIF8HMAC2_t infoKASUMIF8HMAC2;
+	/* F9 */
+	F9_t infoF9;
+	AES256F8F9_t infoAES256F8F9;
+	AES192F8F9_t infoAES192F8F9;
+	AES128F8F9_t infoAES128F8F9;
+	AES256F9_t infoAES256F9;
+	AES192F9_t infoAES192F9;
+	AES128F9_t infoAES128F9;
+	DESF9_t infoDESF9;
+	DES3F9_t info3DESF9;
+	ARC4F9_t infoARC4F9;
+	ARC4StateF9_t infoARC4StateF9;
+	KASUMIF8F9_t infoKASUMIF8F9;
+} CipherHashInfo_t, *CipherHashInfo_pt;
+
+
+/* 
+ * 
+ *    ControlDescriptor_s datastructure 
+ * 
+ */
+
+typedef struct ControlDescriptor_s
+{
+	uint64_t instruction;
+	CipherHashInfo_t cipherHashInfo;
+} ControlDescriptor_t, *ControlDescriptor_pt;
+
+
+
+
+/* **********************************************************************
+ *       PacketDescriptor_t
+ * **********************************************************************
+ */
+
+/*       /--------------------------------------------\
+ *       |                                            |
+ *       |    New PacketDescriptor_s datastructure    |
+ *       |                                            |
+ *       \--------------------------------------------/
+ *
+ *
+ *
+ *       PacketDescriptor_t.srcLengthIVOffUseIVNext
+ *       ------------------------------------------
+ *
+ *           63           62      61             59    58        57    56       54  53           43 
+ *  ------------------------------------------------------------------------------------------------
+ * || Load HMAC key || Pad Hash || Hash Byte Count || Next || Use IV || IV Offset || Packet length ||   ... CONT ...
+ *  ------------------------------------------------------------------------------------------------
+ *           1            1           3                1        1          3              11
+ *
+ *
+ *      42          41      40    39                  5     4          3       2
+ *      0
+ *  ----------------------------------------------------------------------------------------------------
+ * ||  NLHMAC || Break || Wait || Segment src address || SRTCP  || Reserved || Global src data offset ||
+ *  ----------------------------------------------------------------------------------------------------
+ *      1           1       1             35                1           1                  3
+ *
+ *
+ *
+ *             Load HMAC key           =        1'b0       Preserve old HMAC key stored in Auth engine (moot if HASH.HMAC == 0)
+ *                                              1'b1       Load HMAC key from ID registers at beginning of op
+ *                                                         If GCM is selected as authenticator, setting this bit
+ *                                                         will cause the H value from ID to be loaded to the engine
+ *                                                         If Kasumi F9 is selected as authenticator, setting this bit
+ *                                                         will cause the IK value from ID to be loaded to the engine.
+ *             Pad Hash                =        1'b0       HASH will assume the data was padded to be a multiple
+ *                                                         of 512 bits in length and that the last 64 bit word
+ *                                                         expresses the total datalength in bits seen by HASH engine
+ *                                              1'b1       The data was not padded to be a multiple of 512 bits in length;
+ *                                                         The Hash engine will do its own padding to generate the correct digest.
+ *                                                        Ignored by GCM (always does its own padding)
+ *             Hash Byte Count                             Number of BYTES on last 64-bit data word to use in digest calculation RELEVANT ONLY IF Pad Hash IS SET
+ *                                              3'b000     Use all 8
+ *                                              3'b001     Use first (MS) byte only (0-out rest), i.e., 0xddXXXXXXXXXXXXXX
+ *                                              3'b010     Use first 2 bytes only (0-out rest), i.e., 0xddddXXXXXXXXXXXX     ... etc
+ *             Next                    =        1'b0       Finish (return msg descriptor) at end of operation
+ *                                              1'b1       Grab the next PacketDescriptor (i.e. next cache-line) when the current is complete.
+ *                                                         This allows for fragmentation/defragmentation and processing of large (>16kB) packets.
+ *                                                         The sequence of adjacent PacketDescriptor acts as a contiguous linked list of
+ *                                                         pointers to the actual packets with Next==0 on the last PacketDescriptor to end processing.
+ *             Use IV                  =        1'b0       On first frag:           Use old IV
+ *                                                         On subsequent frags:     Do not write out to DST the (dword) offset data
+ *                                              1'b1       On first frag:           Use data @ Segment_address + IV_Offset as IV
+ *                                                         On subsequent frags:     Do write out to DST the (dword) offset data
+ *             IV Offset               =                   On first frag:           Offset IN NB OF 8 BYTE WORDS (dwords) from beginning of packet
+ *                                                                                  (i.e. (Potentially byte-shifted) Segment address) to cipher IV
+ *                                                         On subsequent frags:     Offset to beginning of data to process; data to offset won't 
+ *                                                                                  be given to engines and will be written out to dst in the clear.
+ *                                                                                  ON SUBSEQUENT FRAGS, IV_Offset MAY NOT EXCEED 3; LARGER VALUES WILL CAUSE AN ERROR
+ *                                                                                  SEE ERROR CONDITIONS BELOW
+ *             Packet length           =                   Nb double words to stream in (Including Segment address->CP/IV/Auth/CkSum offsets)
+ *                                                         This is the total amount of data (x8 in bytes) read    (+1 dword if "Global src data offset" != 0)
+ *                                                         This is the total amount of data (x8 in bytes) written (+1 dword if "Global dst data offset" != 0, if Dst dword offset == 0)
+ *                                                         If Packet length == 11'h7ff and (Global src data offset != 0 or Global dst data offset != 0)
+ *                                                         the operation is aborted (no mem writes occur)
+ *                                                         and the "Insufficient Data To Cipher" error flag is raised
+ *             NLHMAC                  =                   No last to hmac. Setting this to 1 will prevent the transmission of the last DWORD
+ *                                                         to the authenticator, i.e., the DWORD before last will be designated as last for the purposes of authentication.
+ *             Break                   =                   Break a wait (see below) state - causes the operation to be flushed and free descriptor to be returned.
+ *                                                         Activated if DFetch blocked by Wait and Wait still active.
+ *                                                         AS OF 02/10/2005 THIS FEATURE IS EXPERIMENTAL
+ *             Wait                    =                   Setting that bit causes the operation to block in DFetch stage.
+ *                                                         DFetch will keep polling the memory location until the bit is reset at which time
+ *                                                         the pipe resumes normal operation. This feature is convenient for software dealing with fragmented packets.
+ *                                                         AS OF 02/10/2005 THIS FEATURE IS EXPERIMENTAL
+ *             Segment src address     =                   35 MSB of pointer to src data (i.e., cache-line aligned)
+ *             SRTCP                   =                   Bypass the cipher for the last 4 bytes of data, i.e. the last 4 bytes will be sent to memory
+ *                                                         and the authenticator in the clear. Applicable to last packet descriptor andlast frag only.
+ *                                                         This accommodates a requirement of SRTCP.
+ *             Global src data offset  =                   Nb BYTES to right-shift data by before presenting it to engines
+ *                                                         (0-7); allows realignment of byte-aligned, non-double-word aligned data
+ *
+ *       PacketDescriptor_t.dstDataSettings
+ *       ----------------------------------
+ *
+ *
+ *         63       62           60  59   58           56  55         54     53      52          41     40
+ *  ------------------------------------------------------------------------------------------------------------
+ * || CipherPrefix | Arc4ByteCount | E/D | Cipher_Offset || Hash_Offset | Hash_Src || CkSum_Offset | CkSum_Src ||   ... CONT ...
+ *  ------------------------------------------------------------------------------------------------------------
+ *         1                3         1          3               2           1             12            1
+ *  <-----------------------CIPHER-----------------------><---------HASH-----------><-------CHECKSUM----------->
+ *
+ *
+ *             CipherPrefix            =                   128'b0 will be sent to the selected cipher
+ *             KEEP VALUE ON ALL FRAGS                     after the IV is loaded, before the actual data goes in.
+ *                                                         The result of that encryption (aka E(K, 0))will be stored
+ *                                                         locally and XOR-ed with the auth digest to create the final
+ *                                                         digest at the end of the auth OP:
+ *                                                         This is covered by the GCM spec
+ *                                                                   AesPrefix =  1'b1    -> Force   E=Cipher(K,0) before start of data encr.
+ *                                                                                        -> Digest ^= E
+ *                                                                   AesPrefix =  1'b0    -> Regular digest
+ *                                                         This flag is ignored if no cipher is chosen (Bypass condition)
+ *  X0         Arc4ByteCount           =                   Number of BYTES on last 64-bit data word to encrypt
+ *                                              3'b000     Encrypt all 8
+ *                                              3'b001     Encrypt first (MS) byte only i.e., 0xddXXXXXXXXXXXXXX
+ *                                              3'b010     Encrypt first 2 bytes only i.e., 0xddddXXXXXXXXXXXX     ... etc
+ *                                                         In reality, all are encrypted, however, the SBOX
+ *                                                         is not written past the last byte to encrypt
+ *             E/D                     =        1'b0       Decrypt
+ *                                              1'b1       Encrypt
+ *                                                         Overloaded to also mean IV byte offset for first frag
+ *             Cipher_Offset           =                   Nb of words between the first data segment 
+ *                                                         and word on which to start cipher operation
+ *                                                         (64 BIT WORDS !!!)
+ *             Hash_Offset             =                   Nb of words between the first data segment
+ *                                                         and word on which to start hashing 
+ *                                                         (64 bit words)
+ *             Hash_Src                =        1'b0       DMA channel
+ *                                              1'b1       Cipher if word count exceeded Cipher_Offset; 
+ *                                                         DMA channel otherwise
+ *             CkSum_Offset            =                   Nb of words between the first data segment 
+ *                                                         and word on which to start 
+ *                                                         checksum calculation (32 BIT WORDS !!!)
+ *             CkSum_Src               =        1'b0       DMA channel
+ *                                              1'b1       Cipher if word count exceeded Cipher_Offset
+ *                                                         DMA channel otherwise
+ *             Cipher dst address      =                   35 MSB of pointer to dst location (i.e., cache-line aligned)
+ *             Dst dword offset        =                   Nb of double-words to left-shift data from spec'ed Cipher dst address before writing it to memory
+ *             Global dst data offset  =                   Nb BYTES to left-shift (double-word boundary aligned) data by before writing it to memory
+ *
+ *
+ *       PacketDescriptor_t.authDstNonceLow
+ *       ----------------------------------
+ *
+ *   63       40  39               5  4                0   
+ *  -----------------------------------------------------
+ * || Nonce_Low || Auth_dst_address || Cipher_Offset_Hi ||
+ *  -----------------------------------------------------
+ *        24             35                    5
+ *
+ *
+ *
+ *             Nonce_Low         =                 Nonce[23:0] 24 least significant bits of 32-bit long nonce
+ *                                                 Used by AES in counter mode
+ *             Auth_dst_address  =                 35 MSB of pointer to authentication dst location (i.e., cache-line aligned)
+ * X0          Cipher_Offset_Hi  =                 On first frag:           5 MSB of 8-bit Cipher_offset; will be concatenated to
+ *                                                                          the top of PacketDescriptor_t.dstDataSettings.Cipher_Offset
+ *                                                 On subsequent frags:     Ignored
+ *
+ *
+ *       PacketDescriptor_t.ckSumDstNonceHiCFBMaskLLWMask
+ *       ------------------------------------------------
+ *
+ *
+ *   63              61  60                 58  57     56  55      48  47      40  39                5  4            0
+ *  -------------------------------------------------------------------------------------------------------------------
+ * || Hash_Byte_Offset || Packet length bytes || LLWMask || CFB_Mask || Nonce_Hi || CkSum_dst_address || IV_Offset_Hi ||
+ *  -------------------------------------------------------------------------------------------------------------------
+ *           3                    3                 2          8           8               35                 5
+ *
+ *
+ *                 Hash_Byte_Offset    =              On first frag:            Additional offset in bytes to be added to Hash_Offset
+ *                                                                              to obtain the full offset applied to the data before
+ *                                                                              submitting it to authenticator
+ *                                                    On subsequent frags:      Same
+ *                 Packet length bytes =              On one fragment payloads: Ignored (i.e. assumed to be 0, last dword used in its entirety)
+ *                                                    On fragments before last: Number of bytes on last fragment dword
+ *                                                    On last fragment:         Ignored (i.e. assumed to be 0, last dword used in its entirety)
+ *   LLWMask, aka, Last_long_word_mask =   2'b00      Give last 128 bit word from AES engine to auth/cksum/wrbbufer as is - applicable in AES CTR only
+ *                                         2'b11      Mask (zero-out) 32 least significant bits
+ *                                         2'b10      Mask 64 LSBs
+ *                                         2'b01      Mask 96 LSBs
+ *                                                    If the GCM authenticator is used, setting LLWMask to 2'b10 or 2'b01
+ *                                                    will also prevent the transmission of the last DWORD
+ *                                                    to the authenticator, i.e., the DWORD before last will
+ *                                                    be designated as last for the purposes of authentication.
+ *                 CFB_Mask            =              8 bit mask used by AES in CFB mode
+ *                                                    In CTR mode:
+ *                                                         CFB_Mask[1:0] =  2'b00   -> Counter[127:0] = {Nonce[31:0],       IV0[63:0], 4'h00000001} (only 1 IV exp
+ected) regular CTR
+ *                                                                          2'b01   -> Counter[127:0] = {Nonce[31:0],       IV0[63:0], IV1[31:0]}   (2 IV expected
+) CCMP
+ *                                                                          2'b10   -> Counter[127:0] = {IV1[63:0],         IV0[31:0], Nonce[31:0]} (2 IV expected
+) GCM with SCI
+ *                                                                          2'b11   -> Counter[127:0] = {IDecode.SCI[63:0], IV0[31:0], Nonce[31:0]} (1 IV expected
+) GCM w/o SCI
+ *                 Nonce_Hi            =              Nonce[31:24] 8 most significant bits of 32-bit long nonce
+ *                                                    Used by AES in counter mode
+ *                 CkSum_dst_address   =              35 MSB of pointer to cksum dst location (i.e., cache-line aligned)
+ *  X0             IV_Offset_Hi        =              On first frag:           5 MSB of 8-bit IV offset; will be concatenated to
+ *                                                                             the top of PacketDescriptor_t.srcLengthIVOffUseIVNext.IV_Offset
+ *                                                    On subsequent frags:     Ignored
+ */
+
+/* #define PKT_DSC_LOADHMACKEY */
+#define PKT_DSC_LOADHMACKEY_OLD   0
+#define PKT_DSC_LOADHMACKEY_LOAD  1
+#define PKT_DSC_LOADHMACKEY_LSB   63
+#define PKT_DSC_LOADHMACKEY_BITS  ONE_BIT
+#define PKT_DSC_LOADHMACKEY_MASK  \
+ (PKT_DSC_LOADHMACKEY_BITS << PKT_DSC_LOADHMACKEY_LSB)
+
+/* #define PKT_DSC_PADHASH */
+#define PKT_DSC_PADHASH_PADDED    0
+#define PKT_DSC_PADHASH_PAD       1	/* requires padding */
+#define PKT_DSC_PADHASH_LSB       62
+#define PKT_DSC_PADHASH_BITS      ONE_BIT
+#define PKT_DSC_PADHASH_MASK      (PKT_DSC_PADHASH_BITS << PKT_DSC_PADHASH_LSB)
+
+/* #define PKT_DSC_HASHBYTES */
+#define PKT_DSC_HASHBYTES_ALL8    0
+#define PKT_DSC_HASHBYTES_MSB     1
+#define PKT_DSC_HASHBYTES_MSW     2
+#define PKT_DSC_HASHBYTES_LSB     59
+#define PKT_DSC_HASHBYTES_BITS    THREE_BITS
+#define PKT_DSC_HASHBYTES_MASK    \
+ (PKT_DSC_HASHBYTES_BITS << PKT_DSC_HASHBYTES_LSB)
+
+/* #define PKT_DSC_NEXT */
+#define PKT_DSC_NEXT_FINISH       0
+#define PKT_DSC_NEXT_DO           1
+#define PKT_DSC_NEXT_LSB          58
+#define PKT_DSC_NEXT_BITS         ONE_BIT
+#define PKT_DSC_NEXT_MASK         (PKT_DSC_NEXT_BITS << PKT_DSC_NEXT_LSB)
+
+/* #define PKT_DSC_IV */
+#define PKT_DSC_IV_OLD            0
+#define PKT_DSC_IV_NEW            1
+#define PKT_DSC_IV_LSB            57
+#define PKT_DSC_IV_BITS           ONE_BIT
+#define PKT_DSC_IV_MASK           (PKT_DSC_IV_BITS << PKT_DSC_IV_LSB)
+
+/* #define PKT_DSC_IVOFF */
+#define PKT_DSC_IVOFF_LSB         54
+#define PKT_DSC_IVOFF_BITS        THREE_BITS
+#define PKT_DSC_IVOFF_MASK        (PKT_DSC_IVOFF_BITS << PKT_DSC_IVOFF_LSB)
+
+/* #define PKT_DSC_PKTLEN */
+#define PKT_DSC_PKTLEN_LSB         43
+#define PKT_DSC_PKTLEN_BITS        ELEVEN_BITS
+#define PKT_DSC_PKTLEN_MASK        (PKT_DSC_PKTLEN_BITS << PKT_DSC_PKTLEN_LSB)
+
+/* #define PKT_DSC_NLHMAC */
+#define PKT_DSC_NLHMAC_LSB         42
+#define PKT_DSC_NLHMAC_BITS        ONE_BIT
+#define PKT_DSC_NLHMAC_MASK        (PKT_DSC_NLHMAC_BITS << PKT_DSC_NLHMAC_LSB)
+
+/* #define PKT_DSC_BREAK */
+#define PKT_DSC_BREAK_OLD          0
+#define PKT_DSC_BREAK_NEW          1
+#define PKT_DSC_BREAK_LSB          41
+#define PKT_DSC_BREAK_BITS         ONE_BIT
+#define PKT_DSC_BREAK_MASK         (PKT_DSC_BREAK_BITS << PKT_DSC_BREAK_LSB)
+
+/* #define PKT_DSC_WAIT */
+#define PKT_DSC_WAIT_OLD           0
+#define PKT_DSC_WAIT_NEW           1
+#define PKT_DSC_WAIT_LSB           40
+#define PKT_DSC_WAIT_BITS          ONE_BIT
+#define PKT_DSC_WAIT_MASK          (PKT_DSC_WAIT_BITS << PKT_DSC_WAIT_LSB)
+
+/* #define PKT_DSC_SEGADDR */
+#define PKT_DSC_SEGADDR_LSB        5
+#define PKT_DSC_SEGADDR_BITS       FOURTY_BITS
+#define PKT_DSC_SEGADDR_MASK       \
+ (PKT_DSC_SEGADDR_BITS << PKT_DSC_SEGADDR_LSB)
+
+/* #define PKT_DSC_SRTCP */
+#define PKT_DSC_SRTCP_OFF       0
+#define PKT_DSC_SRTCP_ON        1
+#define PKT_DSC_SRTCP_LSB       4
+#define PKT_DSC_SRTCP_BITS      ONE_BIT
+#define PKT_DSC_SRTCP_MASK      (PKT_DSC_SRTCP_BITS << PKT_DSC_SRTCP_LSB)
+
+#define PKT_DSC_SEGOFFSET_LSB        0
+#define PKT_DSC_SEGOFFSET_BITS       THREE_BITS
+#define PKT_DSC_SEGOFFSET_MASK       \
+ (PKT_DSC_SEGOFFSET_BITS << PKT_DSC_SEGOFFSET_LSB)
+
+/* **********************************************************************
+ *       PacketDescriptor_t.dstDataSettings
+ * **********************************************************************
+ */
+/* #define PKT_DSC_ARC4BYTECOUNT */
+#define PKT_DSC_ARC4BYTECOUNT_ALL8    0
+#define PKT_DSC_ARC4BYTECOUNT_MSB     1
+#define PKT_DSC_ARC4BYTECOUNT_MSW     2
+#define PKT_DSC_ARC4BYTECOUNT_LSB     60
+#define PKT_DSC_ARC4BYTECOUNT_BITS    THREE_BITS
+#define PKT_DSC_ARC4BYTECOUNT_MASK    (PKT_DSC_ARC4BYTECOUNT_BITS << PKT_DSC_ARC4BYTECOUNT_LSB)
+
+/* #define PKT_DSC_SYM_OP (symmetric key operation) */
+#define PKT_DSC_SYM_OP_DECRYPT    0
+#define PKT_DSC_SYM_OP_ENCRYPT    1
+#define PKT_DSC_SYM_OP_LSB        59
+#define PKT_DSC_SYM_OP_BITS       ONE_BIT
+#define PKT_DSC_SYM_OP_MASK       (PKT_DSC_SYM_OP_BITS << PKT_DSC_SYM_OP_LSB)
+
+/* #define PKT_DSC_CPHROFF */
+#define PKT_DSC_CPHROFF_LSB        56
+#define PKT_DSC_CPHROFF_BITS       THREE_BITS
+#define PKT_DSC_CPHROFF_MASK       (PKT_DSC_CPHROFF_BITS << PKT_DSC_CPHROFF_LSB)
+
+/* #define PKT_DSC_HASHOFF */
+#define PKT_DSC_HASHOFF_LSB       54
+#define PKT_DSC_HASHOFF_BITS      TWO_BITS
+#define PKT_DSC_HASHOFF_MASK      (PKT_DSC_HASHOFF_BITS << PKT_DSC_HASHOFF_LSB)
+
+/* #define PKT_DSC_HASHSRC */
+#define PKT_DSC_HASHSRC_DMA       0
+#define PKT_DSC_HASHSRC_CIPHER    1
+#define PKT_DSC_HASHSRC_LSB       53
+#define PKT_DSC_HASHSRC_BITS      ONE_BIT
+#define PKT_DSC_HASHSRC_MASK      (PKT_DSC_HASHSRC_BITS << PKT_DSC_HASHSRC_LSB)
+
+/* #define PKT_DSC_CKSUMOFF */
+#define PKT_DSC_CKSUMOFF_LSB      41
+#define PKT_DSC_CKSUMOFF_BITS     TWELVE_BITS
+#define PKT_DSC_CKSUMOFF_MASK   (PKT_DSC_CKSUMOFF_BITS << PKT_DSC_CKSUMOFF_LSB)
+
+/* #define PKT_DSC_CKSUMSRC */
+#define PKT_DSC_CKSUMSRC_DMA      0
+#define PKT_DSC_CKSUMSRC_CIPHER   1
+#define PKT_DSC_CKSUMSRC_LSB      40
+#define PKT_DSC_CKSUMSRC_BITS     ONE_BIT
+#define PKT_DSC_CKSUMSRC_MASK   (PKT_DSC_CKSUMSRC_BITS << PKT_DSC_CKSUMSRC_LSB)
+
+/* #define PKT_DSC_CPHR_DST_ADDR */
+#define PKT_DSC_CPHR_DST_ADDR_LSB  0
+#define PKT_DSC_CPHR_DST_ADDR_BITS FOURTY_BITS
+#define PKT_DSC_CPHR_DST_ADDR_MASK \
+     (PKT_DSC_CPHR_DST_ADDR_BITS << PKT_DSC_CPHR_DST_ADDR_LSB)
+
+/* #define PKT_DSC_CPHR_DST_DWOFFSET */
+#define PKT_DSC_CPHR_DST_DWOFFSET_LSB   3
+#define PKT_DSC_CPHR_DST_DWOFFSET_BITS  TWO_BITS
+#define PKT_DSC_CPHR_DST_DWOFFSET_MASK \
+          (PKT_DSC_CPHR_DST_DWOFFSET_BITS << PKT_DSC_CPHR_DST_DWOFFSET_LSB)
+
+ /* #define PKT_DSC_CPHR_DST_OFFSET */
+#define PKT_DSC_CPHR_DST_OFFSET_LSB   0
+#define PKT_DSC_CPHR_DST_OFFSET_BITS  THREE_BITS
+#define PKT_DSC_CPHR_DST_OFFSET_MASK \
+     (PKT_DSC_CPHR_DST_OFFSET_BITS << PKT_DSC_CPHR_DST_OFFSET_LSB)
+
+/* **********************************************************************
+ *       PacketDescriptor_t.authDstNonceLow
+ * **********************************************************************
+ */
+/* #define PKT_DSC_NONCE_LOW */
+#define PKT_DSC_NONCE_LOW_LSB  40
+#define PKT_DSC_NONCE_LOW_BITS TWENTYFOUR_BITS
+#define PKT_DSC_NONCE_LOW_MASK \
+         (PKT_DSC_NONCE_LOW_BITS << PKT_DSC_NONCE_LOW_LSB)
+
+/* #define PKT_DSC_AUTH_DST_ADDR */
+#define PKT_DSC_AUTH_DST_ADDR_LSB  0
+#define PKT_DSC_AUTH_DST_ADDR_BITS FOURTY_BITS
+#define PKT_DSC_AUTH_DST_ADDR_MASK \
+         (PKT_DSC_AUTH_DST_ADDR_BITS << PKT_DSC_AUTH_DST_ADDR_LSB)
+
+/* #define PKT_DSC_CIPH_OFF_HI */
+#define PKT_DSC_CIPH_OFF_HI_LSB      0
+#define PKT_DSC_CIPH_OFF_HI_BITS     FIVE_BITS
+#define PKT_DSC_CIPH_OFF_HI_MASK   (PKT_DSC_CIPH_OFF_HI_BITS << PKT_DSC_CIPH_OFF_HI_LSB)
+
+/* **********************************************************************
+ *       PacketDescriptor_t.ckSumDstNonceHiCFBMaskLLWMask
+ * **********************************************************************
+ */
+/* #define PKT_DSC_HASH_BYTE_OFF */
+#define PKT_DSC_HASH_BYTE_OFF_LSB  61
+#define PKT_DSC_HASH_BYTE_OFF_BITS THREE_BITS
+#define PKT_DSC_HASH_BYTE_OFF_MASK (PKT_DSC_HASH_BYTE_OFF_BITS << PKT_DSC_HASH_BYTE_OFF_LSB)
+
+/* #define PKT_DSC_PKTLEN_BYTES */
+#define PKT_DSC_PKTLEN_BYTES_LSB   58
+#define PKT_DSC_PKTLEN_BYTES_BITS  THREE_BITS
+#define PKT_DSC_PKTLEN_BYTES_MASK  (PKT_DSC_PKTLEN_BYTES_BITS << PKT_DSC_PKTLEN_BYTES_LSB)
+
+/* #define PKT_DSC_LASTWORD */
+#define PKT_DSC_LASTWORD_128       0
+#define PKT_DSC_LASTWORD_96MASK    1
+#define PKT_DSC_LASTWORD_64MASK    2
+#define PKT_DSC_LASTWORD_32MASK    3
+#define PKT_DSC_LASTWORD_LSB       56
+#define PKT_DSC_LASTWORD_BITS      TWO_BITS
+#define PKT_DSC_LASTWORD_MASK      (PKT_DSC_LASTWORD_BITS << PKT_DSC_LASTWORD_LSB)
+
+/* #define PKT_DSC_CFB_MASK */
+#define PKT_DSC_CFB_MASK_LSB      48
+#define PKT_DSC_CFB_MASK_BITS     EIGHT_BITS
+#define PKT_DSC_CFB_MASK_MASK     (PKT_DSC_CFB_MASK_BITS << PKT_DSC_CFB_MASK_LSB)
+
+/* #define PKT_DSC_NONCE_HI */
+#define PKT_DSC_NONCE_HI_LSB      40
+#define PKT_DSC_NONCE_HI_BITS     EIGHT_BITS
+#define PKT_DSC_NONCE_HI_MASK (PKT_DSC_NONCE_HI_BITS << PKT_DSC_NONCE_HI_LSB)
+
+/* #define PKT_DSC_CKSUM_DST_ADDR */
+#define PKT_DSC_CKSUM_DST_ADDR_LSB  5
+#define PKT_DSC_CKSUM_DST_ADDR_BITS THIRTY_FIVE_BITS
+#define PKT_DSC_CKSUM_DST_ADDR_MASK (PKT_DSC_CKSUM_DST_ADDR_BITS << PKT_DSC_CKSUM_DST_ADDR_LSB)
+
+/* #define PKT_DSC_IV_OFF_HI */
+#define PKT_DSC_IV_OFF_HI_LSB      0
+#define PKT_DSC_IV_OFF_HI_BITS     FIVE_BITS
+#define PKT_DSC_IV_OFF_HI_MASK   (PKT_DSC_IV_OFF_HI_BITS << PKT_DSC_IV_OFF_HI_LSB)
+
+
+/* ******************************************************************
+ *             Control Error Code and Conditions
+ * ******************************************************************
+ */
+#define CTL_ERR_NONE         0x0000	/* No Error */
+#define CTL_ERR_CIPHER_OP    0x0001	/* Unknown Cipher Op */
+#define CTL_ERR_MODE         0x0002	/* Unknown or Not Allowed Mode */
+#define CTL_ERR_CHKSUM_SRC   0x0004	/* Unknown CkSum Src - UNUSED */
+#define CTL_ERR_CFB_MASK     0x0008	/* Forbidden CFB Mask - UNUSED */
+#define CTL_ERR_OP           0x0010	/* Unknown Ctrl Op - UNUSED */
+#define CTL_ERR_UNDEF1       0x0020	/* UNUSED */
+#define CTL_ERR_UNDEF2       0x0040	/* UNUSED */
+#define CTL_ERR_DATA_READ    0x0080	/* Data Read Error */
+#define CTL_ERR_DESC_CTRL    0x0100	/* Descriptor Ctrl Field Error */
+
+#define CTL_ERR_TIMEOUT      0x1000	/* Message Response Timeout */
+
+/* ******************************************************************
+ *             Data Error Code and Conditions
+ * ******************************************************************
+ */
+#define DATA_ERR_NONE        0x0000	/* No Error */
+#define DATA_ERR_LEN_CIPHER  0x0001	/* Not Enough Data To Cipher */
+#define DATA_ERR_IV_ADDR     0x0002	/* Illegal IV Loacation */
+#define DATA_ERR_WD_LEN_AES  0x0004	/* Illegal Nb Words To AES */
+#define DATA_ERR_BYTE_COUNT  0x0008	/* Illegal Pad And ByteCount Spec */
+#define DATA_ERR_LEN_CKSUM   0x0010	/* Not Enough Data To CkSum */
+#define DATA_ERR_OP          0x0020	/* Unknown Data Op */
+#define DATA_ERR_UNDEF1      0x0040	/* UNUSED */
+#define DATA_ERR_READ        0x0080	/* Data Read Error */
+#define DATA_ERR_WRITE       0x0100	/* Data Write Error */
+
+
+/*
+ * Common Descriptor 
+ * NOTE:  Size of struct is size of cacheline.
+ */
+
+typedef struct OperationDescriptor_s
+{
+	uint64_t phys_self;
+	uint32_t stn_id;
+	uint32_t flags;
+	uint32_t cpu;
+	uint32_t seq_num;
+	uint64_t reserved;
+} OperationDescriptor_t, *OperationDescriptor_pt;
+
+
+/*
+ * This defines the security data descriptor format
+ */
+typedef struct PacketDescriptor_s
+{
+	uint64_t srcLengthIVOffUseIVNext;
+	uint64_t dstDataSettings;
+	uint64_t authDstNonceLow;
+	uint64_t ckSumDstNonceHiCFBMaskLLWMask;
+} PacketDescriptor_t, *PacketDescriptor_pt;
+
+typedef struct
+{
+	__u8 *user_auth;
+	__u8 *user_src;
+	__u8 *user_dest;
+	__u8 *user_state;
+	__u8 *kern_auth;
+	__u8 *kern_src;
+	__u8 *kern_dest;
+	__u8 *kern_state;
+	__u8 *aligned_auth;
+	__u8 *aligned_src;
+	__u8 *aligned_dest;
+	__u8 *aligned_state;
+} phxdrv_user_t, *phxdrv_user_pt;
+
+typedef struct symkey_desc
+{
+	OperationDescriptor_t op_ctl;	/* size is cacheline */
+	PacketDescriptor_t pkt_desc;	/* size is cacheline  */
+	ControlDescriptor_t ctl_desc;	/*  makes this aligned */
+	__u64 control;				/* message word0 */
+	__u64 data;					/* message word1 */
+	__u64 ctl_result;
+	__u64 data_result;
+	struct symkey_desc *alloc;	/* real allocated addr */
+	phxdrv_user_t user;
+	volatile atomic_t flag_complete;
+	struct semaphore sem_complete;
+	wait_queue_t submit_wait;
+} symkey_desc_t, *symkey_desc_pt;
+
+
+/*
+ * **************************************************************************
+ *                                 RSA Block
+ * **************************************************************************
+ */
+
+/*
+ *                                 RSA and ECC Block
+ *                                 =================
+ *
+ * A 2-word message ring descriptor is used to pass all information
+ * pertaining to the RSA or ECC operation:
+ *
+ *  63  61 60         54     53     52      40 39          5 4                 3 2                      0
+ *  -----------------------------------------------------------------------------------------------------
+ * | Ctrl |  Op Class   | Valid Op | Op Ctrl0 | Source Addr | Software Scratch0 | Global src data offset |
+ *  -----------------------------------------------------------------------------------------------------
+ *    3         7           1           13         35                 2                     3
+ *
+ *
+ *  63  61 60            54     53         52             51     50      40 39        5 4                 3 2                      0
+ *  --------------------------------------------------------------------------------------------------------------------------------
+ * | Ctrl | Destination Id | WRB_COH | WRB_L2ALLOC | DF_L2ALLOC | Op Ctrl1 | Dest Addr | Software Scratch1 | Global dst data offset |
+ *  --------------------------------------------------------------------------------------------------------------------------------
+ *    3            7            1          1              1          11         35                2                     3
+ *
+ *
+ *             Op Class                =        7'h0_0     Modular exponentiation
+ *                                              7'h0_1     ECC (including prime modular ops and binary GF ops)
+ *                                              REMAINDER  UNDEF
+ *                                               
+ *             Valid Op                =        1'b1       Will cause operation to start; descriptors sent back at end of operation
+ *                                              1'b0       No operation performed; descriptors sent back right away
+ *
+ *                                                                   RSA                 ECC
+ *                                                                   ===                 ===
+ *             Op Ctrl0                =                             BlockWidth[1]	 {TYPE[6:0], FUNCTION[5:0]}
+ *                                                                   LoadConstant[1]
+ *                                                                   ExponentWidth[10:0]
+ *                                               RSA Only
+ *                                               ========
+ *                                               Block Width             =        1'b1       1024 bit op
+ *                                                                       =        1'b0       512  bit op
+ *                                               Load Constant           =        1'b1       Load constant from data structure
+ *                                                                                1'b0       Preserve old constant (this assumes 
+ *                                                                                           Source Addr points to RSAData_pt->Exponent
+ *                                                                                           or that the length of Constant is 0)
+ *                                               Exponent Width          =                   11-bit expression of exponent width EXPRESSED IN NUMBER OF BITS
+ *
+ *                                               ECC Only
+ *                                               ========
+ *
+ *                                               TYPE      = 7'h0_0 ECC prime 160
+ *                                                           7'h0_1 ECC prime 192
+ *                                                           7'h0_2 ECC prime 224
+ *                                                           7'h0_3 ECC prime 256
+ *                                                           7'h0_4 ECC prime 384
+ *                                                           7'h0_5 ECC prime 512
+ *
+ *                                                           7'h0_6 through 7'h1_f  UNDEF
+ *
+ *                                                           7'h2_0 ECC bin   163
+ *                                                           7'h2_1 ECC bin   191
+ *                                                           7'h2_2 ECC bin   233
+ *
+ *                                                           7'h2_3 through 7'h6_f  UNDEF
+ *
+ *                                                           7'h7_0 ECC UC load
+ *
+ *                                                           7'b7_1 through 7'b7_f  UNDEF
+ *
+ *                                                                   Prime field                                    Binary field
+ *                                                                   ===========                                    ============
+ *                                               FUNCTION  = 6'h0_0  Point multiplication     R = k.P               Point multiplication       R = k.P
+ *                                                           6'h0_1  Point addition           R = P + Q             Binary GF inversion        C(x) = 1 / A(x) mod F(x)
+ *                                                           6'h0_2  Point double             R = 2 x P             Binary GF multiplication   C(x) = B(x) * A(x) mod F(x)
+ *                                                           6'h0_3  Point verification       R ?                   Binary GF addition         C(x) = B(x) + A(x) mod F(x)
+ *                                                           6'h0_4  Modular addition         c = x + y mod m	    UNDEF
+ *                                                           6'h0_5  Modular substraction     c = x - y mod m	    UNDEF
+ *                                                           6'h0_6  Modular multiplication   c = x * y mod m       UNDEF
+ *                                                           6'h0_7  Modular division         c = x / y mod m       UNDEF
+ *                                                           6'h0_8  Modular inversion        c = 1 / y mod m       UNDEF
+ *                                                           6'h0_9  Modular reduction        c = x mod m           UNDEF
+ *
+ *                                                           6'h0_a
+ *                                                           through UNDEF                                          UNDEF
+ *                                                           6'h3_f
+ *
+ *             Source Addr             =                   35 MSB of pointer to source address (i.e., cache-line aligned)
+ *
+ *             Software Scratch0       =                   Two bit field ignored by engine and returned as is in free descriptor
+ *
+ *             Global src data offset  =                   Nb BYTES to right-shift data by before presenting it to engines
+ *                                                         (0-7); allows realignment of byte-aligned, non-double-word aligned data
+ *
+ *                                                                   RSA                 ECC
+ *                                                                   ===                 ===
+ *             OpCtrl1                 =                             ModulusWidth[10:0]  Not used
+ *                                               RSA Only
+ *                                               ========
+ *                                               Modulus Width           =                   11-bit expression of modulus width EXPRESSED IN NUMBER OF BITS
+ *
+ *             Dest Addr               =                   35 MSB of pointer to destination address (i.e., cache-line aligned)
+ *
+ *             Software Scratch1       =                   Two bit field ignored by engine and returned as is in free descriptor
+ *
+ *             Global dst data offset  =                   Nb BYTES to left-shift (double-word boundary aligned) data by before writing it to memory
+ *                                                 
+ *
+ */
+
+/* 
+ * ECC data formats
+ */
+
+/**********************************************************
+ *                                                        *
+ *     ECC prime data formats                             *
+ *                                                        *
+ **********************************************************
+ *
+ *
+ *  The size of all quantities below is that of the precision
+ *  of the chosen op (160, 192, ...) ROUNDED UP to a multiple
+ *  of 8 bytes, i.e., 3 dwords (160, 192), 4 dwords (224, 256)
+ *  6 dwords (384) and 8 dwords (512) and padded with zeroes
+ *  when necessary.
+ *
+ *  The only exception to this is the key quantity (k) which
+ *  needs to be rounded up to 32 bytes in all cases and padded
+ *  with zeroes; therefore the key needs to be 4 dwords (160, 192,
+ *  224, 256) or 8 dwords (384, 512)
+ *
+ *  The total lengths in dwords that are read and in
+ *  bytes that are written, for each operation and 
+ *  length group, are specified at the bottom of each 
+ *  datastructure.
+ *
+ *  In all that follows, m is the modulus and cst is the constant,
+ *  cst = 2 ^ (2*length + 4) mod m . a and b are the curve
+ *  parameters.
+ *
+ *  0) UC load
+ *
+ *                 DATA IN                 DATA OUT
+ *                 =======                 ========
+ * src+glb_off->   Dword_0                 N/A
+ *                 .
+ *                 .
+ *                 .
+ *                 Dword_331
+ *                 332 dw
+ *
+ *  1) Point multiplication       R(x_r, y_r) = k . P(x_p, y_p)
+ *
+ *                 DATA IN                 DATA OUT
+ *                 =======                 ========
+ * src+glb_off->   x_p      dst+glb_off->  x_r
+ *                 x_p                     y_r
+ *                 y_p			   2x(3/4/6/8)=
+ *                 y_p			   6/8/12/16 dw
+ *                 a
+ *                 k			   
+ *                 m
+ *                 cst
+ *                 7x(3/4/6/8)+(4/4/8/8)=
+ *                 25/32/50/64 dw
+ *
+ *  2) Point addition             R(x_r, y_r) = P(x_p, y_p) + Q(x_q, y_q)
+ *
+ *                 DATA IN                 DATA OUT
+ *                 =======                 ========
+ * src+glb_off->   x_p      dst+glb_off->  x_r
+ *                 y_p                     y_r
+ *                 x_q			   2x(3/4/6/8)=
+ *                 y_q			   6/8/12/16 dw
+ *                 a
+ *                 m
+ *                 cst
+ *                 7x(3/4/6/8)=
+ *                 21/28/42/56 dw
+ *
+ *  3) Point double               R(x_r, y_r) = 2 . P(x_p, y_p)
+ *
+ *                 DATA IN                 DATA OUT
+ *                 =======                 ========
+ * src+glb_off->   x_p      dst+glb_off->  x_r
+ *                 y_p                     y_r
+ *                 a			   2x(3/4/6/8)=
+ *                 m			   6/8/12/16 dw
+ *                 cst
+ *                 5x(3/4/6/8)=
+ *                 15/20/30/40 dw
+ *
+ *  4) Point verification         Is_On_Curve = P(x_p, y_p) on curve ? 1 : 0
+ *
+ *                 DATA IN                 DATA OUT
+ *                 =======                 ========
+ * src+glb_off->   x_p      dst+glb_off->  Is_On_Curve
+ *                 y_p			   1 dw
+ *                 a
+ *                 b
+ *                 m
+ *                 cst
+ *                 6x(3/4/6/8)=
+ *                 18/24/36/48 dw
+ *
+ *  5) Modular addition           c = x + y mod m
+ *
+ *                 DATA IN                 DATA OUT
+ *                 =======                 ========
+ * src+glb_off->   x        dst+glb_off->  c
+ *                 y			   3/4/6/8 dw
+ *                 m
+ *                 3x(3/4/6/8)=
+ *                 9/12/18/24 dw
+ *
+ *  6) Modular substraction       c = x - y mod m
+ *
+ *                 DATA IN                 DATA OUT
+ *                 =======                 ========
+ * src+glb_off->   x        dst+glb_off->  c
+ *                 y			   3/4/6/8 dw
+ *                 m
+ *                 3x(3/4/6/8)=
+ *                 9/12/18/24 dw
+ *
+ *  7) Modular multiplication     c = x * y mod m
+ *
+ *                 DATA IN                 DATA OUT
+ *                 =======                 ========
+ * src+glb_off->   x        dst+glb_off->  c
+ *                 y			   3/4/6/8 dw
+ *                 m
+ *                 cst
+ *                 4x(3/4/6/8)=
+ *                 12/16/24/32 dw
+ *
+ *  8) Modular division           c = x / y mod m
+ *
+ *                 DATA IN                 DATA OUT
+ *                 =======                 ========
+ * src+glb_off->   y        dst+glb_off->  c
+ *                 x			   3/4/6/8 dw
+ *                 m
+ *                 3x(3/4/6/8)=
+ *                 9/12/18/24 dw
+ *
+ *  9) Modular inversion          c = 1 / y mod m
+ *
+ *                 DATA IN                 DATA OUT
+ *                 =======                 ========
+ * src+glb_off->   y        dst+glb_off->  c
+ *                 m			   3/4/6/8 dw
+ *                 2x(3/4/6/8)=
+ *                 6/8/12/16 dw
+ *
+ *  10) Modular reduction         c = x mod m
+ *
+ *                 DATA IN                 DATA OUT
+ *                 =======                 ========
+ * src+glb_off->   x        dst+glb_off->  c
+ *                 m			   3/4/6/8 dw
+ *                 2x(3/4/6/8)=
+ *                 6/8/12/16 dw
+ *
+ */
+
+/**********************************************************
+ *                                                        *
+ *     ECC binary data formats                            *
+ *                                                        *
+ **********************************************************
+ *
+ *
+ *  The size of all quantities below is that of the precision
+ *  of the chosen op (163, 191, 233) ROUNDED UP to a multiple
+ *  of 8 bytes, i.e. 3 dwords for (163, 191) and 4 dwords for
+ *  (233), padded with zeroes as necessary.
+ *
+ *  The total lengths in dwords that are read and written,
+ *  for each operation and length group, are specified
+ *  at the bottom of each datastructure.
+ *  In all that follows, b is the curve parameter.
+ *
+ *  1) Point multiplication       R(x_r, y_r) = k . P(x_p, y_p)
+ *
+ *                 DATA IN                 DATA OUT
+ *                 =======                 ========
+ * src+glb_off->   b        dst+glb_off->  x_r
+ *                 k                       y_r
+ *                 x_p    		   2x(3/4)
+ *                 y_p			   6/8 dw
+ *                 4x(3/4)=
+ *                 12/16 dw
+ *
+ *  2) Binary GF inversion        C(x) = 1 / A(x) mod F(x)
+ *
+ *                 DATA IN                 DATA OUT
+ *                 =======                 ========
+ * src+glb_off->   A        dst+glb_off->  C
+ *		   1x(3/4)=                1x(3/4)
+ *                 3/4 dw		   3/4 dw
+ *
+ *  3) Binary GF multiplication   C(x) = B(x) * A(x) mod F(x)
+ *
+ *                 DATA IN                 DATA OUT
+ *                 =======                 ========
+ * src+glb_off->   A        dst+glb_off->  C
+ *                 B                       1x(3/4)
+ *		   2x(3/4)=		   3/4 dw
+ *                 6/8 dw
+ *
+ *  4) Binary GF addition         C(x) = B(x) + A(x) mod F(x)
+ *
+ *                 DATA IN                 DATA OUT
+ *                 =======                 ========
+ * src+glb_off->   A        dst+glb_off->  C
+ *                 B                       1x(3/4)
+ *		   2x(3/4)=		   3/4 dw
+ *                 6/8dw
+ *
+ */
+
+/*
+ * RSA data format
+ */
+
+/*
+ * IMPORTANT NOTE: 
+ *
+ * As specified in the datastructures below,
+ * the engine assumes all data (including
+ * exponent and modulus) to be adjacent on
+ * dword boundaries, e.g.,
+ *
+ * Operation length = 512 bits
+ * Exponent  length = 16  bits
+ * Modulus   length = 512 bits
+ *
+ * The engine expects to read:
+ *
+ *   63                    0
+ *   -----------------------
+ *  |                       | Constant0
+ *   -----------------------
+ *  |                       | Constant1
+ *   -----------------------
+ *  |                       | Constant2
+ *   -----------------------
+ *  |                       | Constant3
+ *   -----------------------
+ *  |                       | Constant4
+ *   -----------------------
+ *  |                       | Constant5
+ *   -----------------------
+ *  |                       | Constant6
+ *   -----------------------
+ *  |                       | Constant7
+ *   -----------------------
+ *  |      IGNORED    |B1|B0| Exponent0    (Exponent length = 16 bits = 2 bytes, so only 2 least significant bytes of exponent used)
+ *   -----------------------
+ *  |                       | Modulus0
+ *   -----------------------
+ *  |                       | Modulus1
+ *   -----------------------
+ *  |                       | Modulus2
+ *   -----------------------
+ *  |                       | Modulus3
+ *   -----------------------
+ *  |                       | Modulus4
+ *   -----------------------
+ *  |                       | Modulus5
+ *   -----------------------
+ *  |                       | Modulus6
+ *   -----------------------
+ *  |                       | Modulus7
+ *   -----------------------
+ *  |                       | Message0
+ *   -----------------------
+ *  |                       | Message1
+ *   -----------------------
+ *  |                       | Message2
+ *   -----------------------
+ *  |                       | Message3
+ *   -----------------------
+ *  |                       | Message4
+ *   -----------------------
+ *  |                       | Message5
+ *   -----------------------
+ *  |                       | Message6
+ *   -----------------------
+ *  |                       | Message7
+ *   -----------------------
+ *
+ */
+
+/* #define PUBKEY_CTL_CTL */
+#define PUBKEY_CTL_CTL_LSB         61
+#define PUBKEY_CTL_CTL_BITS        THREE_BITS
+#define PUBKEY_CTL_CTL_MASK        (PUBKEY_CTL_CTL_BITS << PUBKEY_CTL_CTL_LSB)
+
+/* #define PUBKEY_CTL_OP_CLASS */
+#define PUBKEY_CTL_OP_CLASS_RSA    0
+#define PUBKEY_CTL_OP_CLASS_ECC    1
+#define PUBKEY_CTL_OP_CLASS_LSB    54
+#define PUBKEY_CTL_OP_CLASS_BITS   SEVEN_BITS
+#define PUBKEY_CTL_OP_CLASS_MASK   (PUBKEY_CTL_OP_CLASS_BITS << PUBKEY_CTL_OP_CLASS_LSB)
+
+/* #define PUBKEY_CTL_VALID */
+#define PUBKEY_CTL_VALID_FALSE     0
+#define PUBKEY_CTL_VALID_TRUE      1
+#define PUBKEY_CTL_VALID_LSB       53
+#define PUBKEY_CTL_VALID_BITS      ONE_BIT
+#define PUBKEY_CTL_VALID_MASK      \
+ (PUBKEY_CTL_VALID_BITS << PUBKEY_CTL_VALID_LSB)
+
+/* #define PUBKEY_CTL_ECC_TYPE */
+#define PUBKEY_CTL_ECC_TYPE_PRIME_160    0
+#define PUBKEY_CTL_ECC_TYPE_PRIME_192    1
+#define PUBKEY_CTL_ECC_TYPE_PRIME_224    2
+#define PUBKEY_CTL_ECC_TYPE_PRIME_256    3
+#define PUBKEY_CTL_ECC_TYPE_PRIME_384    4
+#define PUBKEY_CTL_ECC_TYPE_PRIME_512    5
+#define PUBKEY_CTL_ECC_TYPE_BIN_163      0x20
+#define PUBKEY_CTL_ECC_TYPE_BIN_191      0x21
+#define PUBKEY_CTL_ECC_TYPE_BIN_233      0x22
+#define PUBKEY_CTL_ECC_TYPE_UC_LOAD      0x70
+#define PUBKEY_CTL_ECC_TYPE_LSB    46
+#define PUBKEY_CTL_ECC_TYPE_BITS   SEVEN_BITS
+#define PUBKEY_CTL_ECC_TYPE_MASK   (PUBKEY_CTL_ECC_TYPE_BITS << PUBKEY_CTL_ECC_TYPE_LSB)
+
+/* #define PUBKEY_CTL_ECC_FUNCTION */
+#define PUBKEY_CTL_ECC_FUNCTION_NOP          0
+#define PUBKEY_CTL_ECC_FUNCTION_POINT_MUL    0
+#define PUBKEY_CTL_ECC_FUNCTION_POINT_ADD    1
+#define PUBKEY_CTL_ECC_FUNCTION_POINT_DBL    2
+#define PUBKEY_CTL_ECC_FUNCTION_POINT_VFY    3
+#define PUBKEY_CTL_ECC_FUNCTION_MODULAR_ADD  4
+#define PUBKEY_CTL_ECC_FUNCTION_MODULAR_SUB  5
+#define PUBKEY_CTL_ECC_FUNCTION_MODULAR_MUL  6
+#define PUBKEY_CTL_ECC_FUNCTION_MODULAR_DIV  7
+#define PUBKEY_CTL_ECC_FUNCTION_MODULAR_INV  8
+#define PUBKEY_CTL_ECC_FUNCTION_MODULAR_RED  9
+#define PUBKEY_CTL_ECC_FUNCTION_LSB    40
+#define PUBKEY_CTL_ECC_FUNCTION_BITS   SIX_BITS
+#define PUBKEY_CTL_ECC_FUNCTION_MASK   (PUBKEY_CTL_ECC_FUNCTION_BITS << PUBKEY_CTL_ECC_FUNCTION_LSB)
+
+/* #define PUBKEY_CTL_BLKWIDTH */
+#define PUBKEY_CTL_BLKWIDTH_512    0
+#define PUBKEY_CTL_BLKWIDTH_1024   1
+#define PUBKEY_CTL_BLKWIDTH_LSB    52
+#define PUBKEY_CTL_BLKWIDTH_BITS   ONE_BIT
+#define PUBKEY_CTL_BLKWIDTH_MASK   \
+ (PUBKEY_CTL_BLKWIDTH_BITS << PUBKEY_CTL_BLKWIDTH_LSB)
+
+/* #define PUBKEY_CTL_LD_CONST */
+#define PUBKEY_CTL_LD_CONST_OLD    0
+#define PUBKEY_CTL_LD_CONST_NEW    1
+#define PUBKEY_CTL_LD_CONST_LSB    51
+#define PUBKEY_CTL_LD_CONST_BITS   ONE_BIT
+#define PUBKEY_CTL_LD_CONST_MASK   \
+ (PUBKEY_CTL_LD_CONST_BITS << PUBKEY_CTL_LD_CONST_LSB)
+
+/* #define PUBKEY_CTL_EXPWIDTH */
+#define PUBKEY_CTL_EXPWIDTH_LSB    40
+#define PUBKEY_CTL_EXPWIDTH_BITS   ELEVEN_BITS
+#define PUBKEY_CTL_EXPWIDTH_MASK   \
+ (PUBKEY_CTL_EXPWIDTH_BITS << PUBKEY_CTL_EXPWIDTH_LSB)
+
+/* #define PUBKEY_CTL_SRCADDR */
+#define PUBKEY_CTL_SRCADDR_LSB     0
+#define PUBKEY_CTL_SRCADDR_BITS    FOURTY_BITS
+#define PUBKEY_CTL_SRCADDR_MASK    \
+ (PUBKEY_CTL_SRCADDR_BITS << PUBKEY_CTL_SRCADDR_LSB)
+
+/* #define PUBKEY_CTL_SRC_OFFSET */
+#define PUBKEY_CTL_SRC_OFFSET_LSB  0
+#define PUBKEY_CTL_SRC_OFFSET_BITS THREE_BITS
+#define PUBKEY_CTL_SRC_OFFSET_MASK \
+ (PUBKEY_CTL_SRC_OFFSET_BITS << PUBKEY_CTL_SRC_OFFSET_LSB)
+
+
+/* #define PUBKEY_CTL1_CTL */
+#define PUBKEY_CTL1_CTL_LSB        61
+#define PUBKEY_CTL1_CTL_BITS       THREE_BITS
+#define PUBKEY_CTL1_CTL_MASK       (PUBKEY_CTL_CTL_BITS << PUBKEY_CTL_CTL_LSB)
+
+/* #define PUBKEY_CTL1_MODWIDTH */
+#define PUBKEY_CTL1_MODWIDTH_LSB   40
+#define PUBKEY_CTL1_MODWIDTH_BITS  ELEVEN_BITS
+#define PUBKEY_CTL1_MODWIDTH_MASK  \
+ (PUBKEY_CTL1_MODWIDTH_BITS << PUBKEY_CTL1_MODWIDTH_LSB)
+
+/* #define PUBKEY_CTL1_DSTADDR */
+#define PUBKEY_CTL1_DSTADDR_LSB    0
+#define PUBKEY_CTL1_DSTADDR_BITS   FOURTY_BITS
+#define PUBKEY_CTL1_DSTADDR_MASK   \
+ (PUBKEY_CTL1_DSTADDR_BITS << PUBKEY_CTL1_DSTADDR_LSB)
+
+/* #define PUBKEY_CTL1_DST_OFFSET */
+#define PUBKEY_CTL1_DST_OFFSET_LSB    0
+#define PUBKEY_CTL1_DST_OFFSET_BITS   THREE_BITS
+#define PUBKEY_CTL1_DST_OFFSET_MASK   \
+ (PUBKEY_CTL1_DST_OFFSET_BITS << PUBKEY_CTL1_DST_OFFSET_LSB)
+
+/*
+ * Upon completion of operation, the RSA block returns a 2-word free descriptor
+ * in the following format:
+ *
+ *  63  61 60            54 53   52 51       49  48          40 39             5 4                 3 2                      0
+ *  -------------------------------------------------------------------------------------------------------------------------
+ * | Ctrl | Destination Id | 2'b00 | Desc Ctrl | Control Error | Source Address | Software Scratch0 | Global src data offset |
+ *  -------------------------------------------------------------------------------------------------------------------------
+ * | Ctrl | Destination Id | 2'b00 | Desc Ctrl |   Data Error  | Dest Address   | Software Scratch1 | Global dst data offset |
+ *  -------------------------------------------------------------------------------------------------------------------------
+ *
+ * The Control and Data Error codes are enumerated below
+ *
+ *                                Error conditions
+ *                                ================
+ *
+ *             Control Error Code                  Control Error Condition
+ *             ------------------                  -----------------------
+ *             9'h000                              No Error
+ *             9'h001                              Undefined Op Class
+ *             9'h002                              Undefined ECC TYPE       (ECC only)
+ *             9'h004                              Undefined ECC FUNCTION   (ECC only)
+ *             9'h008                              ECC timeout              (ECC only)
+ *             9'h010                              UNUSED
+ *             9'h020                              UNUSED
+ *             9'h040                              UNUSED
+ *             9'h080                              Data Read Error
+ *             9'h100                              Descriptor Ctrl Field Error        (D0.Ctrl != SOP || D1.Ctrl != EOP)
+ *
+ *             Data Error Code                     Data Error Condition
+ *             ---------------                     --------------------
+ *             9'h000                              No Error
+ *             9'h001                              Exponent Width > Block Width (RSA Only)
+ *             9'h002                              Modulus Width  > Block Width (RSA Only)
+ *             9'h004                              UNUSED
+ *             9'h008                              UNUSED
+ *             9'h010                              UNUSED
+ *             9'h020                              UNUSED
+ *             9'h040                              UNUSED
+ *             9'h080                              Data Read Error
+ *             9'h100                              UNUSED
+ */
+
+/*
+ * Result Data Word for Message Ring Descriptor
+ */
+
+/* #define PUBKEY_RSLT_CTL_CTL */
+#define PUBKEY_RSLT_CTL_CTL_LSB        61
+#define PUBKEY_RSLT_CTL_CTL_BITS       THREE_BITS
+#define PUBKEY_RSLT_CTL_CTL_MASK       \
+ (PUBKEY_RSLT_CTL_CTL_BITS << PUBKEY_RSLT_CTL_CTL_LSB)
+
+/* #define PUBKEY_RSLT_CTL_DST_ID */
+#define PUBKEY_RSLT_CTL_DST_ID_LSB     54
+#define PUBKEY_RSLT_CTL_DST_ID_BITS    SEVEN_BITS
+#define PUBKEY_RSLT_CTL_DST_ID_MASK    \
+ (PUBKEY_RSLT_CTL_DST_ID_BITS << PUBKEY_RSLT_CTL_DST_ID_LSB)
+
+/* #define PUBKEY_RSLT_CTL_DESC_CTL */
+#define PUBKEY_RSLT_CTL_DESC_CTL_LSB   49
+#define PUBKEY_RSLT_CTL_DESC_CTL_BITS  THREE_BITS
+#define PUBKEY_RSLT_CTL_DESC_CTL_MASK  \
+ (PUBKEY_RSLT_CTL_DESC_CTL_BITS << PUBKEY_RSLT_CTL_DESC_CTL_LSB)
+
+
+/* #define PUBKEY_RSLT_CTL_ERROR */
+#define PUBKEY_RSLT_CTL_ERROR_LSB      40
+#define PUBKEY_RSLT_CTL_ERROR_BITS     NINE_BITS
+#define PUBKEY_RSLT_CTL_ERROR_MASK     \
+ (PUBKEY_RSLT_CTL_ERROR_BITS << PUBKEY_RSLT_CTL_ERROR_LSB)
+
+/* #define PUBKEY_RSLT_CTL_SRCADDR */
+#define PUBKEY_RSLT_CTL_SRCADDR_LSB    0
+#define PUBKEY_RSLT_CTL_SRCADDR_BITS   FOURTY_BITS
+#define PUBKEY_RSLT_CTL_SRCADDR_MASK   \
+ (PUBKEY_RSLT_CTL_SRCADDR_BITS << PUBKEY_RSLT_CTL_SRCADDR_LSB)
+
+
+/* #define PUBKEY_RSLT_DATA_CTL */
+#define PUBKEY_RSLT_DATA_CTL_LSB       61
+#define PUBKEY_RSLT_DATA_CTL_BITS      THREE_BITS
+#define PUBKEY_RSLT_DATA_CTL_MASK      \
+ (PUBKEY_RSLT_DATA_CTL_BITS << PUBKEY_RSLT_DATA_CTL_LSB)
+
+/* #define PUBKEY_RSLT_DATA_DST_ID */
+#define PUBKEY_RSLT_DATA_DST_ID_LSB    54
+#define PUBKEY_RSLT_DATA_DST_ID_BITS   SEVEN_BITS
+#define PUBKEY_RSLT_DATA_DST_ID_MASK   \
+ (PUBKEY_RSLT_DATA_DST_ID_BITS << PUBKEY_RSLT_DATA_DST_ID_LSB)
+
+/* #define PUBKEY_RSLT_DATA_DESC_CTL */
+#define PUBKEY_RSLT_DATA_DESC_CTL_LSB  49
+#define PUBKEY_RSLT_DATA_DESC_CTL_BITS THREE_BITS
+#define PUBKEY_RSLT_DATA_DESC_CTL_MASK \
+ (PUBKEY_RSLT_DATA_DESC_CTL_BITS << PUBKEY_RSLT_DATA_DESC_CTL_LSB)
+
+/* #define PUBKEY_RSLT_DATA_ERROR */
+#define PUBKEY_RSLT_DATA_ERROR_LSB     40
+#define PUBKEY_RSLT_DATA_ERROR_BITS    NINE_BITS
+#define PUBKEY_RSLT_DATA_ERROR_MASK    \
+ (PUBKEY_RSLT_DATA_ERROR_BITS << PUBKEY_RSLT_DATA_ERROR_LSB)
+
+/* #define PUBKEY_RSLT_DATA_DSTADDR */
+#define PUBKEY_RSLT_DATA_DSTADDR_LSB   40
+#define PUBKEY_RSLT_DATA_DSTADDR_BITS  FOURTY_BITS
+#define PUBKEY_RSLT_DATA_DSTADDR_MASK  \
+ (PUBKEY_RSLT_DATA_DSTADDR_BITS << PUBKEY_RSLT_DATA_DSTADDR_LSB)
+
+/* 
+ * ******************************************************************
+ *             RSA Block - Data Error Code and Conditions
+ * ******************************************************************
+ */
+
+#define PK_CTL_ERR_NONE        0x0000	/* No Error */
+#define PK_CTL_ERR_OP_CLASS    0x0001	/* Undefined Op Class */
+#define PK_CTL_ERR_ECC_TYPE    0x0002	/* Undefined ECC TYPE (ECC only) */
+#define PK_CTL_ERR_ECC_FUNCT   0x0004	/* Undefined ECC FUNCTION   (ECC only) */
+#define PK_CTL_ERR_ECC_TIMEOUT 0x0008	/* ECC timeout              (ECC only) */
+#define PK_CTL_ERR_READ        0x0080	/* Data Read Error */
+#define PK_CTL_ERR_DESC        0x0100	/* Descriptor Ctrl Field Error  (D0.Ctrl != SOP || D1.Ctrl != EOP) */
+#define PK_CTL_ERR_TIMEOUT     0x1000	/* Message Responce Timeout */
+
+#define PK_DATA_ERR_NONE       0x0000	/* No Error */
+#define PK_DATA_ERR_EXP_WIDTH  0x0001	/* Exponent Width > Block Width */
+#define PK_DATA_ERR_MOD_WIDTH  0x0002	/* Modulus Width  > Block Width */
+#define PK_DATA_ERR_READ       0x0080	/* Data Read Error */
+
+
+/*
+ * This defines the RSA data format
+ */
+/*
+ * typedef struct RSAData_s {
+ *  uint64_t            Constant;
+ *  uint64_t            Exponent;
+ *  uint64_t            Modulus;
+ * uint64_t            Message;
+ *} RSAData_t, *RSAData_pt;
+ *
+ * typedef RSAData_t DHData_t;
+ * typedef RSAData_pt DHData_pt;
+ */
+
+typedef struct UserPubData_s
+{
+	uint8_t *source;
+	uint8_t *user_result;
+	uint32_t result_length;
+} UserPubData_t, *UserPubData_pt;
+
+typedef struct pubkey_desc
+{
+	OperationDescriptor_t op_ctl;	/* size is cacheline */
+	uint8_t source[1024];
+	uint8_t dest[256];			/* 1024 makes cacheline-aligned */
+	__u64 control0;
+	__u64 control1;
+	__u64 ctl_result;
+	__u64 data_result;
+	struct pubkey_desc *alloc;
+	UserPubData_t kern;			/* ptrs for temp buffers */
+	volatile atomic_t flag_complete;
+	struct semaphore sem_complete;
+	wait_queue_t submit_wait;
+} pubkey_desc_t, *pubkey_desc_pt;
+
+/*
+ * KASUMI F8 and F9 use the IV0/IV1 fields :
+ *
+ *  63 41      40      39   37 36        32 31                                 0
+ *  ----------------------------------------------------------------------------
+ * |     |FX/DIRECTION|       | F8/BEARER  |              F8/COUNT              | IV0
+ *  ---------------------------------------------------------------------------- 
+ *              1                   5                         32
+ *
+ *  63                                   32 31                                 0
+ *  ----------------------------------------------------------------------------
+ * |                F9/FRESH               |              F9/COUNT              | IV1
+ *  ----------------------------------------------------------------------------
+ *                     32                                     32
+ */
+#endif /* _PHXDESC_H_ */
diff --git a/drivers/char/rmisec/phxdrv/phxdev.c b/drivers/char/rmisec/phxdrv/phxdev.c
new file mode 100644
index 0000000..06b8628
--- /dev/null
+++ b/drivers/char/rmisec/phxdrv/phxdev.c
@@ -0,0 +1,913 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/compiler.h>
+#include <linux/wait.h>
+
+#include <asm/io.h>
+#include <asm/smp.h>
+#include <asm/errno.h>
+#include <asm/system.h>
+
+#include <asm/atomic.h>
+
+#include <asm/rmi/debug.h>
+#include <asm/rmi/msgring.h>
+
+#include "../linux/rmisec.h"
+#include "phxdesc.h"
+#include "phxsec.h"
+#include "phxdrv.h"
+#include "asm/rmi/sim.h"
+
+#define PHXDEV_MSGSND_RETRY   10
+
+extern rmisec_stats_pt stats;
+
+#ifdef PHXDEV_DEBUG
+extern int phxcrypto_verbosity;
+
+#define DPRINT  printk
+#define PHXDEV_DIAG(fmt, args...) { \
+            if (phxcrypto_verbosity >= PHXDRV_VERBOSE) \
+                DPRINT(fmt, ##args); \
+        }
+
+#define PHXDEV_DIAG_BUF(hdr, buf, len) { \
+            if (phxcrypto_verbosity >= PHXDRV_VERBOSE) \
+                print_buf((hdr), (buf), (len)); \
+        }
+#define PHXDEV_DIAG_SYM_DESC(desc, vec) { \
+            if (phxcrypto_verbosity >= PHXDRV_VERBOSE) \
+			    decode_symkey_desc ((desc), (vec)); \
+        }
+#else
+#define DPRINT(fmt, args...)
+#define PHXDEV_DIAG(fmt, args...)
+#define PHXDEV_DIAG_BUF(hdr, buf, len)
+#define PHXDEV_DIAG_SYM_DESC(desc, vec)
+#endif
+
+
+/*
+ * Globals
+ */
+driver_data_t phxdrvr;
+
+static spinlock_t msgrng_lock;
+
+static wait_queue_head_t submit_q[NR_CPUS];
+static wait_queue_head_t pk_submit_q[NR_CPUS];
+
+/*
+ * Code
+ */
+extern void format_buf(char *desc, void *data, int len, char *buf);
+
+static int msgrng_stnid_pk0 = MSGRNG_STNID_PK0;
+extern int phxsec_ecc_init(void);
+
+symkey_desc_pt phxsec_alloc_symkey_desc()
+{
+	__u64 addr;
+	symkey_desc_pt aligned, new;
+
+	new = (symkey_desc_pt)
+		OS_ALLOC_KERNEL((sizeof(symkey_desc_t) + SMP_CACHE_BYTES));
+	if (new == NULL)
+		return (NULL);
+
+	memset((void *) new, 0, (sizeof(symkey_desc_t) + SMP_CACHE_BYTES));
+
+	/* find cacheline alignment */
+	addr = (__u64) virt_to_phys(new);
+	if (addr & (SMP_CACHE_BYTES - 1))
+		addr = (__u64) ((addr + SMP_CACHE_BYTES) & ~(SMP_CACHE_BYTES - 1));
+	aligned = (symkey_desc_pt) phys_to_virt(addr);
+
+	/* save for free */
+	aligned->alloc = new;
+
+	/* setup common control info */
+	aligned->op_ctl.phys_self = addr;
+	aligned->op_ctl.stn_id = MSGRNG_STNID_SEC0;
+
+	return (aligned);
+}
+
+
+void phxsec_free_symkey_desc(symkey_desc_pt desc)
+{
+	if ((desc == NULL) || (desc->alloc == NULL)) {
+		dbg_msg("%s:  NULL descriptor \n", __func__);
+		return;
+	}
+	OS_FREE(desc->alloc);
+
+	return;
+}
+
+
+pubkey_desc_pt phxsec_alloc_pubkey_desc()
+{
+	__u64 addr;
+	pubkey_desc_pt aligned, new;
+
+	new = (pubkey_desc_pt)
+		OS_ALLOC_KERNEL((sizeof(pubkey_desc_t) + SMP_CACHE_BYTES));
+	if (new == NULL)
+		return (NULL);
+
+	memset((void *) new, 0, (sizeof(pubkey_desc_t) + SMP_CACHE_BYTES));
+
+	/* find cacheline alignment */
+	addr = (__u64) virt_to_phys(new);
+	if (addr & (SMP_CACHE_BYTES - 1))
+		addr = (__u64) ((addr + SMP_CACHE_BYTES) & ~(SMP_CACHE_BYTES - 1));
+
+	aligned = (pubkey_desc_pt) phys_to_virt(addr);
+
+	/* save for free */
+	aligned->alloc = new;
+
+	/* setup common control info */
+	aligned->op_ctl.phys_self = addr;
+	aligned->op_ctl.stn_id = msgrng_stnid_pk0;
+
+	return (aligned);
+}
+
+
+void phxsec_free_pubkey_desc(pubkey_desc_pt desc)
+{
+	if ((desc == NULL) || (desc->alloc == NULL)) {
+		dbg_msg("%s:  NULL descriptor \n", __func__);
+		return;
+	}
+	OS_FREE(desc->alloc);
+	return;
+}
+
+#ifdef RMISEC_CTLBLK_DEBUG
+static void phxsec_DumpCTLBLK(symkey_desc_pt desc)
+{
+	uint64_t *word;
+	int i;
+
+	printk("Sym Key Control Block: \n");
+	printk("\tPacket Descriptor: \n");
+	printk("\t\tsrcLengthIVOffUseIVNext:    0x%llx \n",
+		   desc->pkt_desc.srcLengthIVOffUseIVNext);
+	printk("\t\tdstLLWMask:                 0x%llx \n",
+		   desc->pkt_desc.dstLLWMask);
+	printk("\t\tauthDst:                    0x%llx \n",
+		   desc->pkt_desc.authDst);
+	printk("\t\tckSumDst:                   0x%llx \n",
+		   desc->pkt_desc.ckSumDst);
+
+	word = (uint64_t *) & desc->ctl_desc;
+	printk("\tControl Descriptor:  \n");
+	for (i = 0; i < 14; i++) {
+		printk("\t\t0x%llx \n", *word);
+		word++;
+	}
+
+	printk("\tControl Word:             0x%llx \n", desc->control);
+	printk("\tData Word:                0x%llx \n", desc->data);
+	printk("\tControl Result:           0x%llx \n", desc->ctl_result);
+	printk("\tData Result:              0x%llx \n", desc->data_result);
+	printk("\tAlloc:                    PTR=%p \n", desc->alloc);
+	printk("\tflag_complete:            0x%x \n",
+		   atomic_read(&desc->flag_complete));
+
+	printk("\tUSER: \n");
+	printk("\t\tuser_auth:              PTR=%p \n", desc->user.user_auth);
+	printk("\t\tuser_src:               PTR=%p \n", desc->user.user_src);
+	printk("\t\tuser_dest:              PTR=%p \n", desc->user.user_dest);
+	printk("\t\tkern_auth:              PTR=%p \n", desc->user.kern_auth);
+	printk("\t\tkern_src:               PTR=%p \n", desc->user.kern_src);
+	printk("\t\tkern_dest:              PTR=%p \n", desc->user.kern_dest);
+	printk("\t\taligned_auth:           PTR=%p \n", desc->user.aligned_auth);
+	printk("\t\taligned_src:            PTR=%p \n", desc->user.aligned_src);
+	printk("\t\taligned_dest:           PTR=%p \n", desc->user.aligned_dest);
+}
+#endif /* RMISEC_CTLBLK_DEBUG */
+
+
+/* This function is called from an interrupt handler */
+void phxsec_msgring_handler(int bucket, int size, int code, int stid,
+							struct msgrng_msg *msg, void *data)
+{
+	__u64 addr, sec_eng, sec_pipe;
+
+	PHXDEV_DIAG
+		("[%s]: HANDLER  bucket=%d size=%d, code=%d, stid=%d, msg=%p\n",
+		 __func__, bucket, size, code, stid, msg);
+
+	PHXDEV_DIAG("[%s]:  msg0=0x%llx  msg1=0x%llx \n",
+				__func__, msg->msg0, msg->msg1);
+
+	if (size != SEC_MSGRING_WORDSIZE) {
+		panic("phxsec_msgring_handler:  bad size = %d, expecting %d\n",
+			  size, SEC_MSGRING_WORDSIZE);
+	}
+
+	if (code != MSGRNG_CODE_SEC) {
+		panic("phxsec_msgring_handler: bad code = %d,"
+			  " expecting MSGRNG_CODE_SEC = %d\n", code, MSGRNG_CODE_SEC);
+	}
+
+	if ((stid < MSGRNG_STNID_SEC0) || (stid > MSGRNG_STNID_PK0)) {
+		panic("phxsec_msgring_handler: bad stn id = %d, expect %d - %d\n",
+			  stid, MSGRNG_STNID_SEC0, MSGRNG_STNID_PK0);
+	}
+
+	/*
+	 * The Submit() operation encodes the engine and pipe in these two
+	 * separate fields.  This allows use to verify the result type with
+	 * the submitted operation type.
+	 */
+	sec_eng = GET_FIELD(msg->msg0, MSG_CTL_OP_TYPE);
+	sec_pipe = GET_FIELD(msg->msg1, MSG_CTL_OP_TYPE);
+
+	PHXDEV_DIAG("[%s]:  eng=%lld  pipe=%lld\n",
+				__func__, sec_eng, sec_pipe);
+
+	/* Symmetric Key Operation ? */
+	if (sec_eng == MSG0_CTL_OP_ENGINE_SYMKEY) {
+		symkey_desc_pt desc;
+
+		/*
+		 * The data descriptor address allows us to associate the response
+		 * with the submitted operation.
+		 * Address is 40-bit cacheline aligned address.
+		 * We need to zero bit 0-4 since they are used for the
+		 *  engine and pipe Id.
+		 */
+		addr = GET_FIELD(msg->msg1, MSG_RSLT_DATA_DSC_ADDR);
+		addr = addr & ~((1 << 5) - 1);
+		if (!addr) {
+			panic("[%s:STNID_SEC]:  NULL symkey addr!\n", __func__);
+
+		}
+
+		/*
+		 * The adddress points to the data descriptor.
+		 * The operation descriptor is defined with the 32-byte cacheline
+		 * size in mind.  It allows the code to use this address to reference
+		 * the symkey descriptor.   (ref:  phxdesc.h)
+		 */
+		addr = addr - sizeof(OperationDescriptor_t);
+
+		/* Get pointer to symkey Descriptor */
+		desc = (symkey_desc_pt) bus_to_virt(addr);
+		if (!desc) {
+			panic("[%s:STNID_SEC]:  NULL symkey data descriptor!\n",
+				  __func__);
+		}
+
+
+		PHXDEV_DIAG("[%s:STNID_SEC]:  addr=0x%llx  desc=%p  alloc=%p \n",
+					__func__, addr, desc, desc->alloc);
+
+		PHXDEV_DIAG
+			("[%s:STNID_SEC]:  op_ctl=%p  phys_self=%llx  stn_id=%d \n",
+			 __func__, &desc->op_ctl, desc->op_ctl.phys_self,
+			 desc->op_ctl.stn_id);
+
+		if (addr != desc->op_ctl.phys_self) {
+			PHXDEV_DIAG
+				("[%s:STNID_SEC]:  Control Descriptor fails Self-Verify !\n",
+				 __func__);
+			printk
+				("[%s:STNID_SEC]:  Control Descriptor fails Self-Verify !\n",
+				 __func__);
+			printk("[%s:STNID_SEC]:  addr=0x%llx  desc=%p  alloc=%p \n",
+				   __func__, (unsigned long long) addr, desc,
+				   desc->alloc);
+			printk("[%s:STNID_SEC]:  op_ctl=%p  phys_self=%llx  stn_id=%d \n",
+				   __func__, &desc->op_ctl,
+				   (unsigned long long) desc->op_ctl.phys_self,
+				   desc->op_ctl.stn_id);
+
+		}
+
+		if (desc->op_ctl.stn_id != MSGRNG_STNID_SEC0 &&
+			desc->op_ctl.stn_id != MSGRNG_STNID_SEC1) {
+			PHXDEV_DIAG("[%s:STNID_SEC]:  Operation Type Mismatch !\n",
+						__func__);
+			printk("[%s:STNID_SEC]:  Operation Type Mismatch !\n",
+				   __func__);
+			printk("[%s:STNID_SEC]:  addr=0x%llx  desc=%p  alloc=%p \n",
+				   __func__, (unsigned long long) addr, desc,
+				   desc->alloc);
+			printk("[%s:STNID_SEC]:  op_ctl=%p  phys_self=%llx  stn_id=%d \n",
+				   __func__, &desc->op_ctl,
+				   (unsigned long long) desc->op_ctl.phys_self,
+				   desc->op_ctl.stn_id);
+		}
+
+		desc->ctl_result = GET_FIELD(msg->msg0, MSG_RSLT_CTL_INST_ERR);
+		desc->data_result = GET_FIELD(msg->msg1, MSG_RSLT_DATA_INST_ERR);
+
+		PHXDEV_DIAG
+			("[%s:STNID_SEC]:  cpu=%d  ctl_result=0x%llx  data_result=%llx\n",
+			 __func__, desc->op_ctl.cpu, desc->ctl_result,
+			 desc->data_result);
+
+		if (desc->op_ctl.flags) {
+			atomic_set(&desc->flag_complete, 1);
+		}
+		else {
+			up(&desc->sem_complete);
+		}
+
+	}
+	else if (sec_eng == MSG0_CTL_OP_ENGINE_PUBKEY) {
+		pubkey_desc_pt desc;
+
+		if (sec_pipe != MSG1_CTL_OP_PUBKEY_PIPE0) {
+			/* response to uc load */
+			PHXDEV_DIAG
+				("[%s:STNID_SEC]: ecc cpu=%d  ctl_result=0x%llx  data_result=%llx\n",
+				 __func__, desc->op_ctl.cpu, desc->ctl_result,
+				 desc->data_result);
+			return;
+		}
+		/*
+		 * The data descriptor address allows us to associate the response
+		 * with the submitted operation.
+		 * Address is 40-bit cacheline aligned address.
+		 * We need to zero bit 0-4 since they are used for the
+		 *  engine and pipe Id.
+		 */
+		addr = GET_FIELD(msg->msg0, PUBKEY_RSLT_CTL_SRCADDR);
+		addr = addr & ~((1 << 5) - 1);
+		if (!addr) {
+			panic("[%s:STNID_SEC]:  NULL pubkey ctrl desc!\n", __func__);
+		}
+
+
+		/*
+		 * The adddress points to the data descriptor.
+		 * The operation descriptor is defined with the 32-byte cacheline
+		 * size in mind.  It allows the code to use this address to reference
+		 * the symkey descriptor.   (ref:  phxdesc.h)
+		 */
+		addr = addr - sizeof(OperationDescriptor_t);
+
+		/* Get pointer to pubkey Descriptor */
+		desc = (pubkey_desc_pt) bus_to_virt(addr);
+		if (!desc) {
+			panic("[%s:STNID_SEC]:  NULL pubkey data descriptor!\n",
+				  __func__);
+		}
+
+		PHXDEV_DIAG("[%s:STNID_PK0]:  addr=0x%llx  desc=%p  alloc=%p \n",
+					__func__, addr, desc, desc->alloc);
+
+		PHXDEV_DIAG
+			("[%s:STNID_PK0]:  op_ctl=%p  phys_self=%llx  stn_id=%d \n",
+			 __func__, &desc->op_ctl, desc->op_ctl.phys_self,
+			 desc->op_ctl.stn_id);
+
+		if (addr != desc->op_ctl.phys_self) {
+			PHXDEV_DIAG
+				("[%s:STNID_PK0]:  Control Descriptor fails Self-Verify !\n",
+				 __func__);
+		}
+
+		if (desc->op_ctl.stn_id != msgrng_stnid_pk0) {
+			PHXDEV_DIAG("[%s:STNID_PK0]:  Operation Type Mismatch ! \n",
+						__func__);
+		}
+
+		desc->ctl_result = GET_FIELD(msg->msg0, PUBKEY_RSLT_CTL_ERROR);
+		desc->data_result = GET_FIELD(msg->msg1, PUBKEY_RSLT_DATA_ERROR);
+
+		PHXDEV_DIAG("[%s:STNID_PK0]:  ctl_result=0x%llx  data_result=%llx\n",
+					__func__, desc->ctl_result, desc->data_result);
+
+		atomic_set(&desc->flag_complete, 1);
+		up(&desc->sem_complete);
+	}
+	else {
+		printk("[%s]: HANDLER  bad id = %d\n", __func__, stid);
+	}
+
+}
+
+
+static void phxsec_op_timeout(unsigned long data)
+{
+	symkey_desc_pt desc = (symkey_desc_pt) data;
+
+	printk("phxsec_op_timeout:  TIMEOUT!\n");
+
+	desc->ctl_result = CTL_ERR_TIMEOUT;
+
+	atomic_set(&desc->flag_complete, 1);
+
+}
+
+
+phxsec_error_t phxsec_submit_op_wait(symkey_desc_pt desc)
+{
+	struct msgrng_msg send_msg;
+
+	struct timer_list timer;
+
+	int rsp_dest_id, cpu, hard_cpu, hard_thread;
+	int code, retries;
+	unsigned long msgrng_flags = 0;
+	uint32_t wait_time1, wait_time2;
+	uint32_t send_wait_time1, send_wait_time2;
+
+	/* threads (0-3) are orthogonal to buckets 0-3 */
+	cpu = cpu_logical_map(get_cpu());
+	hard_cpu = cpu >> 2;
+	hard_thread = cpu & 0x3;	/* thread id */
+	rsp_dest_id = (hard_cpu << 3) + hard_thread;
+
+	desc->op_ctl.cpu = hard_cpu;
+	desc->op_ctl.flags = 0;		/* called from kernel thread */
+	atomic_set(&desc->flag_complete, 0);
+
+
+	PHXDEV_DIAG
+		("[%s]:%d:  cpu=0x%x  hard_cpu=0x%x  hard_thrd=0x%x  id=0x%x \n",
+		 __func__, __LINE__, cpu, hard_cpu, hard_thread, rsp_dest_id);
+
+	/*
+	 * Set DestId in Message Control Word.
+	 * This tells the Security Engine which bucket to send the
+	 * reply to for this CPU
+	 */
+	CLEAR_SET_FIELD(desc->control, MSG_CMD_CTL_ID, rsp_dest_id);
+	CLEAR_SET_FIELD(desc->data, MSG_CMD_CTL_ID, rsp_dest_id);
+
+	CLEAR_SET_FIELD(desc->control, MSG_CTL_OP_TYPE,
+					MSG0_CTL_OP_ENGINE_SYMKEY);
+	CLEAR_SET_FIELD(desc->data, MSG_CTL_OP_TYPE, MSG1_CTL_OP_SYMKEY_PIPE0);
+
+	send_msg.msg0 = desc->control | (1ULL << 53);
+	send_msg.msg1 = desc->data | (1ULL << 53) | (1ULL << 52);
+	send_msg.msg2 = send_msg.msg3 = 0;
+
+	desc->op_ctl.flags = 1;
+
+	PHXDEV_DIAG("[%s]: IN_IRQ=%d  msg0=0x%llx  msg1=0x%llx \n",
+				__func__, desc->op_ctl.flags, send_msg.msg0,
+				send_msg.msg1);
+
+	if (likely(desc->op_ctl.flags)) {	/* ipsec softirq ? */
+		atomic_set(&desc->flag_complete, 0);
+	}
+	else {
+		OS_SEMAPHORE_INIT(&desc->sem_complete);
+	}
+
+	retries = PHXDEV_MSGSND_RETRY;
+
+	send_wait_time1 = read_c0_count();
+
+	while (retries--) {
+		__sync();
+		msgrng_flags_save(msgrng_flags);
+
+		code = message_send_retry(SEC_MSGRING_WORDSIZE,
+								  MSGRNG_CODE_SEC,
+								  desc->op_ctl.stn_id, &send_msg);
+
+		msgrng_flags_restore(msgrng_flags);
+
+		if (code == 0)
+			break;
+
+		stats->wait_count += 1;
+		/* Get in line !! */
+		if (waitqueue_active(&submit_q[hard_cpu])) {
+			init_waitqueue_entry(&desc->submit_wait, current);
+
+			set_current_state(TASK_INTERRUPTIBLE);
+			add_wait_queue_exclusive(&submit_q[hard_cpu], &desc->submit_wait);
+
+			put_cpu();
+			schedule();
+
+			PHXDEV_DIAG("[%s]:%d Message dequeued before send_message() \n",
+						__func__, __LINE__);
+
+			set_current_state(TASK_RUNNING);
+			remove_wait_queue(&submit_q[hard_cpu], &desc->submit_wait);
+
+			/*
+			 * Setup the responce Id again since we might wake on
+			 * another CPU
+			 * threads (0-3) are orthogonal to buckets 4-7
+			 */
+			cpu = cpu_logical_map(get_cpu());
+			hard_cpu = cpu >> 2;
+			hard_thread = cpu & 0x3;	/* thread id */
+			rsp_dest_id = (hard_cpu << 3) + hard_thread;
+
+			desc->op_ctl.cpu = hard_cpu;
+
+			CLEAR_SET_FIELD(send_msg.msg0, MSG_CMD_CTL_ID, rsp_dest_id);
+			CLEAR_SET_FIELD(send_msg.msg1, MSG_CMD_CTL_ID, rsp_dest_id);
+			desc->submit_wait.flags = 0;
+		}
+	}
+
+	send_wait_time2 = read_c0_count() - send_wait_time1;
+	stats->maxsnd_wait_time = max(stats->maxsnd_wait_time, send_wait_time2);
+
+	if (code != 0) {
+		PHXDEV_DIAG("[%s]: Message Send Failed after %d attempts: code=%x\n",
+					__func__, PHXDEV_MSGSND_RETRY, code);
+		put_cpu();
+		return PHXSEC_ERR_SYMKEY_MSGSND;
+	}
+	PHXDEV_DIAG("[%s]: Message Sent:   code = %x\n", __func__, code);
+
+	if (likely(desc->op_ctl.flags)) {	/* ipsec softirq ? */
+		/*
+		 * The exit from msgrng_wait() indicates a message was recieved in
+		 * the bucket for which we were waiting.  However, it could have been
+		 * for a previously submitted operation, so we must spin waiting for
+		 * the message ring handler to complete the operation.
+		 * NOTE:  We can't issue another msgrng_wait() because it might be
+		 *        after the message was received.
+		 */
+		/* Wait for message ring interrupt handler to process response */
+		if (atomic_read(&desc->flag_complete) == 0) {
+			init_timer(&timer);
+			timer.function = phxsec_op_timeout;
+			timer.expires = jiffies + 5000;
+			timer.data = (unsigned long) desc;
+			add_timer(&timer);
+			wait_time1 = read_c0_count();
+
+			while (atomic_read(&desc->flag_complete) == 0);
+			wait_time2 = read_c0_count() - wait_time1;
+			stats->wait_time += wait_time2;
+			stats->max_wait_time = max(stats->max_wait_time, wait_time2);
+			del_timer_sync(&timer);
+		}
+	}
+	else {						/* Kernel Thread */
+		/* Wait for message ring interrupt handler to process response */
+		put_cpu();
+		down(&desc->sem_complete);
+		cpu = cpu_logical_map(get_cpu());
+		hard_cpu = cpu >> 2;
+
+		if (waitqueue_active(&submit_q[hard_cpu])) {
+			wake_up(&submit_q[hard_cpu]);
+		}
+	}
+	PHXDEV_DIAG("[%s]: Message Received:  id = 0x%x\n",
+				__func__, rsp_dest_id);
+
+	put_cpu();
+	return (PHXSEC_ERR_NONE);
+}
+
+
+phxsec_error_t phxsec_submit_pkop_wait(pubkey_desc_pt desc)
+{
+	int rsp_dest_id, cpu, hard_cpu, hard_thread;
+	struct msgrng_msg send_msg;
+	int code, retries;
+	unsigned long flags = 0;
+
+	/* No reason to support this function on an interrupt */
+	if (in_interrupt()) {
+		printk("[%s]:  Called on Interrupt \n", __func__);
+		return PHXSEC_ERR_PUBKEY_MSGSND;
+	}
+
+	/* threads (0-3) are orthogonal to buckets 0-3 */
+	cpu = cpu_logical_map(get_cpu());
+	hard_cpu = cpu >> 2;
+	hard_thread = cpu & 0x3;	/* thread id */
+	rsp_dest_id = (hard_cpu << 3) + hard_thread;
+
+	desc->op_ctl.cpu = hard_cpu;
+
+	PHXDEV_DIAG("[%s]:  cpu=0x%x  hard_cpu=0x%x  hard_thrd=0x%x  id=0x%x \n",
+				__func__, cpu, hard_cpu, hard_thread, rsp_dest_id);
+
+	/*
+	 * Set DestId in Message Control Word.
+	 * This tells the Security Engine which bucket to send the
+	 * reply to for this CPU
+	 */
+	CLEAR_SET_FIELD(desc->control1, MSG_CMD_CTL_ID, rsp_dest_id);
+
+	CLEAR_SET_FIELD(desc->control0,
+					MSG_CTL_OP_TYPE, MSG0_CTL_OP_ENGINE_PUBKEY);
+	CLEAR_SET_FIELD(desc->control1,
+					MSG_CTL_OP_TYPE, MSG1_CTL_OP_PUBKEY_PIPE0);
+
+	send_msg.msg0 = desc->control0;
+	send_msg.msg1 = desc->control1;
+	send_msg.msg2 = send_msg.msg3 = 0;
+
+	atomic_set(&desc->flag_complete, 0);
+	sema_init(&desc->sem_complete, 0);
+
+	/* Get in line !! */
+	if (waitqueue_active(&pk_submit_q[hard_cpu])) {
+
+		init_waitqueue_entry(&desc->submit_wait, current);
+
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_wait_queue_exclusive(&pk_submit_q[hard_cpu], &desc->submit_wait);
+
+		put_cpu();
+		schedule();
+
+		PHXDEV_DIAG("[%s]: Message dequeued before send_message() \n",
+					__func__);
+
+		set_current_state(TASK_RUNNING);
+		remove_wait_queue(&pk_submit_q[hard_cpu], &desc->submit_wait);
+
+		/*
+		 * Setup the response Id again since we might wake on
+		 * another CPU
+		 * threads (0-3) are orthogonal to buckets 0-3
+		 */
+		cpu = cpu_logical_map(get_cpu());
+		hard_cpu = cpu >> 2;
+		hard_thread = cpu & 0x3;	/* thread id */
+		rsp_dest_id = (hard_cpu << 3) + hard_thread;
+
+		desc->op_ctl.cpu = hard_cpu;
+
+		CLEAR_SET_FIELD(send_msg.msg1, MSG_CMD_CTL_ID, rsp_dest_id);
+		desc->submit_wait.flags = 0;
+	}
+
+	retries = PHXDEV_MSGSND_RETRY;
+	while (retries--) {
+
+		flags = 0;
+		__sync();
+		msgrng_flags_save(flags);
+		code = message_send_retry(SEC_MSGRING_WORDSIZE,
+								  MSGRNG_CODE_SEC,
+								  msgrng_stnid_pk0, &send_msg);
+		msgrng_flags_restore(flags);
+
+		if (likely(code == 0))	/* message sent */
+			break;
+
+		PHXDEV_DIAG("[%s]: Thread Message Send Failed:  code = %x\n",
+					__func__, code);
+
+		/*
+		 * We use wait_queues with exclusive elements.
+		 * This provides FIFO order and a single process wake.
+		 * There is a wait_queue per CPU since message ring credits
+		 *  are defined per CPU.
+		 *
+		 * If the WQ_FLAG_EXCLUSIVE flag is set, then this is not
+		 * the first time this task has been queued.  In this case,
+		 * we need to put the task back on the wait queue head
+		 * (not the tail).
+		 */
+		if (desc->submit_wait.flags & WQ_FLAG_EXCLUSIVE) {
+			desc->submit_wait.private = current;
+			flags = 0;
+			spin_lock_irqsave(&pk_submit_q[hard_cpu].lock, flags);
+			__add_wait_queue(&pk_submit_q[hard_cpu], &desc->submit_wait);
+			set_current_state(TASK_INTERRUPTIBLE);
+			spin_unlock_irqrestore(&pk_submit_q[hard_cpu].lock, flags);
+		}
+		else {
+			init_waitqueue_entry(&desc->submit_wait, current);
+			set_current_state(TASK_INTERRUPTIBLE);
+			add_wait_queue_exclusive(&pk_submit_q[hard_cpu],
+									 &desc->submit_wait);
+		}
+
+		put_cpu();
+		schedule();
+
+		PHXDEV_DIAG("[%s]: Thread Message Dequeued \n", __func__);
+
+		set_current_state(TASK_RUNNING);
+		remove_wait_queue(&pk_submit_q[hard_cpu], &desc->submit_wait);
+
+		/*
+		 * Setup the response Id again since we might wake on
+		 * another CPU
+		 * threads (0-3) are orthogonal to buckets 0-3
+		 */
+		cpu = cpu_logical_map(get_cpu());
+		hard_cpu = cpu >> 2;
+		hard_thread = cpu & 0x3;	/* thread id */
+		rsp_dest_id = (hard_cpu << 3) + hard_thread;
+
+		desc->op_ctl.cpu = hard_cpu;
+
+		CLEAR_SET_FIELD(send_msg.msg1, MSG_CMD_CTL_ID, rsp_dest_id);
+	}
+	if (code != 0) {
+		PHXDEV_DIAG("[%s]: Message Send Failed after %d attempts: code=%x\n",
+					__func__, PHXDEV_MSGSND_RETRY, code);
+		put_cpu();
+		return PHXSEC_ERR_PUBKEY_MSGSND;
+	}
+
+	PHXDEV_DIAG("[%s]: Message Sent:   code = %x desc %p\n", __func__,
+				code, desc);
+
+	/* Wait for message ring interrupt handler to process response */
+	put_cpu();
+	down(&desc->sem_complete);
+
+	cpu = cpu_logical_map(get_cpu());
+	hard_cpu = cpu >> 2;
+
+	PHXDEV_DIAG("[%s]: Message Received:  id = 0x%x\n",
+				__func__, rsp_dest_id);
+
+	if (waitqueue_active(&pk_submit_q[hard_cpu])) {
+		wake_up(&pk_submit_q[hard_cpu]);
+	}
+
+	put_cpu();
+	return (PHXSEC_ERR_NONE);
+}
+extern char *saved_command_line;
+
+/*
+ * phxsec_InitDevice:
+ *
+ * Initialize a device for operation.
+ * Return a status indicating result of the initialization
+ * along with a context to be used in further device operations.
+ */
+phxsec_status_t
+phxsec_init_device(unsigned short dev_id, unsigned long base_address,
+				   unsigned int irq, unsigned int num_descriptors,
+				   dev_info_pt dev_ctx)
+{
+	struct driver_data *data = &phxdrvr;
+	int i = 0;
+	int ret = 0;
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_SECURITY_OFFSET);
+	char *hybrid = strstr(saved_command_line, "hybrid=");
+
+	if (is_xls())
+		msgrng_stnid_pk0 = MSGRNG_STNID_XLS_PK0;
+
+	/* To prevent preemption */
+	spin_lock_init(&msgrng_lock);
+
+	dbg_msg("Registering PHOENIX_SEC\n");
+
+	ret = -ENOMEM;
+
+	data->base_address = (unsigned long) mmio;
+	data->id = dev_id;
+	data->instance = 1;
+	data->irq = irq;
+	data->mem_end = (unsigned long) mmio + PHOENIX_IO_SIZE - 1;
+	data->pending_ops = 0;
+
+	dev_ctx->completion_handler = NULL;
+	dev_ctx->context = data;
+	dev_ctx->dev_features = 0;
+	dev_ctx->dev_status = PHXSEC_STATUS_SUCCESS;
+
+	dbg_msg("PHXSEC:  Init  mmio=%p   *mmio=0x%x \n", mmio, (*mmio));
+
+	if (!hybrid) {
+		phoenix_write_reg(mmio, SEC_DMA_CREDIT, SEC_DMA_CREDIT_CONFIG);
+
+		phoenix_write_reg(mmio, SEC_CONFIG2, SEC_CFG2_ROUND_ROBIN_ON);
+
+		for (i = 0; i < 8; i++)
+			phoenix_write_reg(mmio,
+							  SEC_MSG_BUCKET0_SIZE + i,
+							  is_xls()?
+							  xls_bucket_sizes.bucket[MSGRNG_STNID_SEC + i] :
+							  bucket_sizes.bucket[MSGRNG_STNID_SEC + i]);
+
+		for (i = 0; i < 128; i++)
+			phoenix_write_reg(mmio,
+							  SEC_CC_CPU0_0 + i,
+							  is_xls()?
+							  xls_cc_table_sec.counters[i >> 3][i & 0x07] :
+							  cc_table_sec.counters[i >> 3][i & 0x07]);
+	}
+
+	/*
+	 * Register a bucket handler with the phoenix messaging subsystem
+	 * For now, register handler for bucket 0->5 in msg stn 0
+	 */
+	if (register_msgring_handler(TX_STN_SEC, phxsec_msgring_handler, dev_ctx)) {
+		panic("Couldn't register msgring handler 0\n");
+	}
+
+	/* Initialize the device specific driver data */
+	spin_lock_init(&data->lock);
+
+	/* initialize the wait queues per CPU */
+	for (i = 0; i < NR_CPUS; i++) {
+		init_waitqueue_head(&submit_q[i]);
+		init_waitqueue_head(&pk_submit_q[i]);
+	}
+
+	data->mmio = (void *) mmio;
+	if (data->mmio == NULL) {
+		dbg_panic("Unable to ioremap MMIO region of size %x @ %x\n",
+				  PHOENIX_IO_SIZE, (*mmio));
+		return (ret);
+	}
+
+	if (phxcrypto_init((void *) data) != PHXSEC_ERR_NONE) {
+		dbg_msg("%s:  failed CryptoAPI interface init \n", __func__);
+		return (PHXSEC_ERR_ALLOC);
+	}
+
+	dbg_msg("%s: Phoenix SecEng at 0x%p (descriptors=%d)\n",
+			__func__, data->mmio, num_descriptors);
+
+	if (is_xls())
+		phxsec_ecc_init();
+
+	return (PHXSEC_ERR_NONE);
+}
+
+
+/*
+ * phxsec_ShutdownDevice:
+ *
+ * Disable the device from operating and free up any related resources.
+ */
+phxsec_status_t phxsec_shutdown(dev_info_pt dev_ctx)
+{
+	unsigned long count;
+	struct driver_data *data = dev_ctx->context;
+
+	dbg_msg("%s: Enter (ctx=%p)\n", __func__, dev_ctx);
+
+	/* Wait for outstanding requests to complete */
+	for (count = 0; (data->pending_ops != 0) || count < 5; count++) {
+		OS_WAIT_US(1000000);	/* one second */
+	}
+
+	/* DEBUG-only */
+	if (data->pending_ops > 0)
+		dbg_msg("%s: Pending Ops = %d\n", __func__, data->pending_ops);
+
+
+	return (PHXSEC_STATUS_SUCCESS);
+}
+
+/*
+ * phxsec_reset:
+ *
+ * Reset the device.
+ */
+phxsec_status_t phxsec_reset(dev_info_pt dev_ctx)
+{
+	return (PHXSEC_STATUS_SUCCESS);
+}
diff --git a/drivers/char/rmisec/phxdrv/phxdrv.h b/drivers/char/rmisec/phxdrv/phxdrv.h
new file mode 100644
index 0000000..3d9efe5
--- /dev/null
+++ b/drivers/char/rmisec/phxdrv/phxdrv.h
@@ -0,0 +1,849 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#ifndef _PHXDRV_H_
+#define _PHXDRV_H_
+
+#include <asm/rmi/msgring.h>
+#include "phxsec.h"
+
+/*
+ *   Message Ring Specifics
+ */
+
+#define SEC_MSGRING_WORDSIZE      2
+
+/*
+ *
+ * 
+ * rwR      31  30 29     27 26    24 23      21 20     18     
+ *         |  NA  | RSA0Out | Rsa0In | Pipe3Out | Pipe3In | ... 
+ *
+ *          17       15 14     12 11      9 8       6 5        3 2       0
+ *         |  Pipe2Out | Pipe2In | Pipe1In | Pipe1In | Pipe0Out | Pipe0In |
+ *
+ * DMA CREDIT REG -
+ *   NUMBER OF CREDITS PER PIPE
+ */
+#define SEC_DMA_CREDIT_RSA0_OUT_FOUR   0x20000000
+#define SEC_DMA_CREDIT_RSA0_OUT_TWO    0x10000000
+#define SEC_DMA_CREDIT_RSA0_OUT_ONE    0x08000000
+
+#define SEC_DMA_CREDIT_RSA0_IN_FOUR    0x04000000
+#define SEC_DMA_CREDIT_RSA0_IN_TWO     0x02000000
+#define SEC_DMA_CREDIT_RSA0_IN_ONE     0x01000000
+
+#define SEC_DMA_CREDIT_PIPE3_OUT_FOUR  0x00800000
+#define SEC_DMA_CREDIT_PIPE3_OUT_TWO   0x00400000
+#define SEC_DMA_CREDIT_PIPE3_OUT_ONE   0x00200000
+
+#define SEC_DMA_CREDIT_PIPE3_IN_FOUR   0x00100000
+#define SEC_DMA_CREDIT_PIPE3_IN_TWO    0x00080000
+#define SEC_DMA_CREDIT_PIPE3_IN_ONE    0x00040000
+
+#define SEC_DMA_CREDIT_PIPE2_OUT_FOUR  0x00020000
+#define SEC_DMA_CREDIT_PIPE2_OUT_TWO   0x00010000
+#define SEC_DMA_CREDIT_PIPE2_OUT_ONE   0x00008000
+
+#define SEC_DMA_CREDIT_PIPE2_IN_FOUR   0x00004000
+#define SEC_DMA_CREDIT_PIPE2_IN_TWO    0x00002000
+#define SEC_DMA_CREDIT_PIPE2_IN_ONE    0x00001000
+
+#define SEC_DMA_CREDIT_PIPE1_OUT_FOUR  0x00000800
+#define SEC_DMA_CREDIT_PIPE1_OUT_TWO   0x00000400
+#define SEC_DMA_CREDIT_PIPE1_OUT_ONE   0x00000200
+
+#define SEC_DMA_CREDIT_PIPE1_IN_FOUR   0x00000100
+#define SEC_DMA_CREDIT_PIPE1_IN_TWO    0x00000080
+#define SEC_DMA_CREDIT_PIPE1_IN_ONE    0x00000040
+
+#define SEC_DMA_CREDIT_PIPE0_OUT_FOUR  0x00000020
+#define SEC_DMA_CREDIT_PIPE0_OUT_TWO   0x00000010
+#define SEC_DMA_CREDIT_PIPE0_OUT_ONE   0x00000008
+
+#define SEC_DMA_CREDIT_PIPE0_IN_FOUR   0x00000004
+#define SEC_DMA_CREDIT_PIPE0_IN_TWO    0x00000002
+#define SEC_DMA_CREDIT_PIPE0_IN_ONE    0x00000001
+
+/*
+ *  Currently, FOUR credits per PIPE
+ *  0x24924924  
+ */
+#define SEC_DMA_CREDIT_CONFIG          SEC_DMA_CREDIT_RSA0_OUT_FOUR | \
+                                       SEC_DMA_CREDIT_RSA0_IN_FOUR | \
+                                       SEC_DMA_CREDIT_PIPE3_OUT_FOUR | \
+                                       SEC_DMA_CREDIT_PIPE3_IN_FOUR | \
+                                       SEC_DMA_CREDIT_PIPE2_OUT_FOUR | \
+                                       SEC_DMA_CREDIT_PIPE2_IN_FOUR | \
+                                       SEC_DMA_CREDIT_PIPE1_OUT_FOUR | \
+                                       SEC_DMA_CREDIT_PIPE1_IN_FOUR | \
+                                       SEC_DMA_CREDIT_PIPE0_OUT_FOUR | \
+                                       SEC_DMA_CREDIT_PIPE0_IN_FOUR
+
+/*
+ * CONFIG2  
+ *    31   5         4                   3            
+ *   |  NA  | PIPE3_DEF_DBL_ISS | PIPE2_DEF_DBL_ISS | ...
+ *
+ *                 2                   1                   0
+ *   ... | PIPE1_DEF_DBL_ISS | PIPE0_DEF_DBL_ISS | ROUND_ROBIN_MODE |
+ *
+ *  DBL_ISS - mode for SECENG and DMA controller which slows down transfers 
+ *             (to be conservativei; 0=Disable,1=Enable).
+ *  ROUND_ROBIN - mode where SECENG dispatches operations to PIPE0-PIPE3 
+ *                and all messages are sent to PIPE0.
+ *
+ */
+
+#define SEC_CFG2_PIPE3_DBL_ISS_ON      0x00000010
+#define SEC_CFG2_PIPE3_DBL_ISS_OFF     0x00000000
+#define SEC_CFG2_PIPE2_DBL_ISS_ON      0x00000008
+#define SEC_CFG2_PIPE2_DBL_ISS_OFF     0x00000000
+#define SEC_CFG2_PIPE1_DBL_ISS_ON      0x00000004
+#define SEC_CFG2_PIPE1_DBL_ISS_OFF     0x00000000
+#define SEC_CFG2_PIPE0_DBL_ISS_ON      0x00000002
+#define SEC_CFG2_PIPE0_DBL_ISS_OFF     0x00000000
+#define SEC_CFG2_ROUND_ROBIN_ON        0x00000001
+#define SEC_CFG2_ROUND_ROBIN_OFF       0x00000000
+
+
+
+enum sec_pipe_config
+{
+
+	SEC_PIPE_CIPHER_KEY0_L0 = 0x00,
+	SEC_PIPE_CIPHER_KEY0_HI,
+	SEC_PIPE_CIPHER_KEY1_LO,
+	SEC_PIPE_CIPHER_KEY1_HI,
+	SEC_PIPE_CIPHER_KEY2_LO,
+	SEC_PIPE_CIPHER_KEY2_HI,
+	SEC_PIPE_CIPHER_KEY3_LO,
+	SEC_PIPE_CIPHER_KEY3_HI,
+	SEC_PIPE_HMAC_KEY0_LO,
+	SEC_PIPE_HMAC_KEY0_HI,
+	SEC_PIPE_HMAC_KEY1_LO,
+	SEC_PIPE_HMAC_KEY1_HI,
+	SEC_PIPE_HMAC_KEY2_LO,
+	SEC_PIPE_HMAC_KEY2_HI,
+	SEC_PIPE_HMAC_KEY3_LO,
+	SEC_PIPE_HMAC_KEY3_HI,
+	SEC_PIPE_HMAC_KEY4_LO,
+	SEC_PIPE_HMAC_KEY4_HI,
+	SEC_PIPE_HMAC_KEY5_LO,
+	SEC_PIPE_HMAC_KEY5_HI,
+	SEC_PIPE_HMAC_KEY6_LO,
+	SEC_PIPE_HMAC_KEY6_HI,
+	SEC_PIPE_HMAC_KEY7_LO,
+	SEC_PIPE_HMAC_KEY7_HI,
+	SEC_PIPE_NCFBM_LO,
+	SEC_PIPE_NCFBM_HI,
+	SEC_PIPE_INSTR_LO,
+	SEC_PIPE_INSTR_HI,
+	SEC_PIPE_RSVD0,
+	SEC_PIPE_RSVD1,
+	SEC_PIPE_RSVD2,
+	SEC_PIPE_RSVD3,
+
+	SEC_PIPE_DF_PTRS0,
+	SEC_PIPE_DF_PTRS1,
+	SEC_PIPE_DF_PTRS2,
+	SEC_PIPE_DF_PTRS3,
+	SEC_PIPE_DF_PTRS4,
+	SEC_PIPE_DF_PTRS5,
+	SEC_PIPE_DF_PTRS6,
+	SEC_PIPE_DF_PTRS7,
+
+	SEC_PIPE_DU_DATA_IN_LO,
+	SEC_PIPE_DU_DATA_IN_HI,
+	SEC_PIPE_DU_DATA_IN_CTRL,
+	SEC_PIPE_DU_DATA_OUT_LO,
+	SEC_PIPE_DU_DATA_OUT_HI,
+	SEC_PIPE_DU_DATA_OUT_CTRL,
+
+	SEC_PIPE_STATE0,
+	SEC_PIPE_STATE1,
+	SEC_PIPE_STATE2,
+	SEC_PIPE_STATE3,
+	SEC_PIPE_STATE4,
+	SEC_PIPE_INCLUDE_MASK0,
+	SEC_PIPE_INCLUDE_MASK1,
+	SEC_PIPE_INCLUDE_MASK2,
+	SEC_PIPE_INCLUDE_MASK3,
+	SEC_PIPE_INCLUDE_MASK4,
+	SEC_PIPE_EXCLUDE_MASK0,
+	SEC_PIPE_EXCLUDE_MASK1,
+	SEC_PIPE_EXCLUDE_MASK2,
+	SEC_PIPE_EXCLUDE_MASK3,
+	SEC_PIPE_EXCLUDE_MASK4,
+};
+
+enum sec_pipe_base_config
+{
+
+	SEC_PIPE0_BASE = 0x00,
+	SEC_PIPE1_BASE = 0x40,
+	SEC_PIPE2_BASE = 0x80,
+	SEC_PIPE3_BASE = 0xc0
+};
+
+enum sec_rsa_config
+{
+
+	SEC_RSA_PIPE0_DU_DATA_IN_LO = 0x100,
+	SEC_RSA_PIPE0_DU_DATA_IN_HI,
+	SEC_RSA_PIPE0_DU_DATA_IN_CTRL,
+	SEC_RSA_PIPE0_DU_DATA_OUT_LO,
+	SEC_RSA_PIPE0_DU_DATA_OUT_HI,
+	SEC_RSA_PIPE0_DU_DATA_OUT_CTRL,
+	SEC_RSA_RSVD0,
+	SEC_RSA_RSVD1,
+
+	SEC_RSA_PIPE0_STATE0,
+	SEC_RSA_PIPE0_STATE1,
+	SEC_RSA_PIPE0_STATE2,
+	SEC_RSA_PIPE0_INCLUDE_MASK0,
+	SEC_RSA_PIPE0_INCLUDE_MASK1,
+	SEC_RSA_PIPE0_INCLUDE_MASK2,
+	SEC_RSA_PIPE0_EXCLUDE_MASK0,
+	SEC_RSA_PIPE0_EXCLUDE_MASK1,
+	SEC_RSA_PIPE0_EXCLUDE_MASK2,
+	SEC_RSA_PIPE0_EVENT_CTR
+};
+
+enum sec_config
+{
+
+	SEC_DMA_CREDIT = 0x140,
+	SEC_CONFIG1,
+	SEC_CONFIG2,
+	SEC_CONFIG3,
+
+};
+
+enum sec_debug_config
+{
+
+	SEC_DW0_DESCRIPTOR0_LO = 0x180,
+	SEC_DW0_DESCRIPTOR0_HI,
+	SEC_DW0_DESCRIPTOR1_LO,
+	SEC_DW0_DESCRIPTOR1_HI,
+	SEC_DW1_DESCRIPTOR0_LO,
+	SEC_DW1_DESCRIPTOR0_HI,
+	SEC_DW1_DESCRIPTOR1_LO,
+	SEC_DW1_DESCRIPTOR1_HI,
+	SEC_DW2_DESCRIPTOR0_LO,
+	SEC_DW2_DESCRIPTOR0_HI,
+	SEC_DW2_DESCRIPTOR1_LO,
+	SEC_DW2_DESCRIPTOR1_HI,
+	SEC_DW3_DESCRIPTOR0_LO,
+	SEC_DW3_DESCRIPTOR0_HI,
+	SEC_DW3_DESCRIPTOR1_LO,
+	SEC_DW3_DESCRIPTOR1_HI,
+
+	SEC_STATE0,
+	SEC_STATE1,
+	SEC_STATE2,
+	SEC_INCLUDE_MASK0,
+	SEC_INCLUDE_MASK1,
+	SEC_INCLUDE_MASK2,
+	SEC_EXCLUDE_MASK0,
+	SEC_EXCLUDE_MASK1,
+	SEC_EXCLUDE_MASK2,
+	SEC_EVENT_CTR
+};
+
+enum sec_msgring_bucket_config
+{
+
+	SEC_BIU_CREDITS = 0x308,
+
+	SEC_MSG_BUCKET0_SIZE = 0x320,
+	SEC_MSG_BUCKET1_SIZE,
+	SEC_MSG_BUCKET2_SIZE,
+	SEC_MSG_BUCKET3_SIZE,
+	SEC_MSG_BUCKET4_SIZE,
+	SEC_MSG_BUCKET5_SIZE,
+	SEC_MSG_BUCKET6_SIZE,
+	SEC_MSG_BUCKET7_SIZE,
+};
+
+enum sec_msgring_credit_config
+{
+
+	SEC_CC_CPU0_0 = 0x380,
+	SEC_CC_CPU1_0 = 0x388,
+	SEC_CC_CPU2_0 = 0x390,
+	SEC_CC_CPU3_0 = 0x398,
+	SEC_CC_CPU4_0 = 0x3a0,
+	SEC_CC_CPU5_0 = 0x3a8,
+	SEC_CC_CPU6_0 = 0x3b0,
+	SEC_CC_CPU7_0 = 0x3b8
+};
+
+enum sec_engine_id
+{
+	SEC_PIPE0,
+	SEC_PIPE1,
+	SEC_PIPE2,
+	SEC_PIPE3,
+	SEC_RSA
+};
+
+enum sec_cipher
+{
+	SEC_AES256_MODE_HMAC,
+	SEC_AES256_MODE,
+	SEC_AES256_HMAC,
+	SEC_AES256,
+	SEC_AES192_MODE_HMAC,
+	SEC_AES192_MODE,
+	SEC_AES192_HMAC,
+	SEC_AES192,
+	SEC_AES128_MODE_HMAC,
+	SEC_AES128_MODE,
+	SEC_AES128_HMAC,
+	SEC_AES128,
+	SEC_DES_HMAC,
+	SEC_DES,
+	SEC_3DES,
+	SEC_3DES_HMAC,
+	SEC_HMAC
+};
+
+enum sec_msgrng_msg_ctrl_config
+{
+	SEC_EOP = 5,
+	SEC_SOP = 6,
+};
+
+
+/*
+ *  STRUCTS
+ */
+
+typedef struct phx_sec_stats
+{
+	__u32 operations;
+} phx_sec_stats_t;
+
+
+typedef struct driver_data
+{
+
+	phx_sec_stats_t stats;
+	spinlock_t lock;
+	__u32 pending_ops;
+
+	volatile unsigned int *mmio;
+
+	unsigned long mem_end;
+
+	unsigned long base_address;
+	__u16 irq;
+
+	int id;
+	int type;
+	int instance;
+
+} driver_data_t, *driver_data_pt;
+
+
+symkey_desc_pt phxsec_alloc_symkey_desc(void);
+void phxsec_free_symkey_desc(symkey_desc_pt desc);
+pubkey_desc_pt phxsec_alloc_pubkey_desc(void);
+void phxsec_free_pubkey_desc(pubkey_desc_pt desc);
+void phxsec_msgring_handler(int bucket, int size, int code, int stid,
+							struct msgrng_msg *msg, void *data);
+phxsec_error_t phxsec_submit_op_wait(symkey_desc_pt desc);
+phxsec_error_t phxsec_submit_pkop_wait(pubkey_desc_pt desc);
+
+phxsec_status_t phxsec_init_device(unsigned short dev_id,
+								   unsigned long base_address,
+								   unsigned int irq,
+								   unsigned int num_descriptors,
+								   dev_info_pt dev_ctx);
+
+phxsec_status_t phxsec_shutdown(dev_info_pt dev_ctx);
+phxsec_status_t phxsec_reset(dev_info_pt dev_ctx);
+
+/* Stats-related section */
+
+#define PHXDRV_PROFILE_DES                 0x00000001
+#define PHXDRV_PROFILE_3DES                0x00000002
+#define PHXDRV_PROFILE_AES                 0x00000004
+#define PHXDRV_PROFILE_ARC4                0x00000008
+#define PHXDRV_PROFILE_MD5                 0x00000010
+#define PHXDRV_PROFILE_SHA1                0x00000020
+#define PHXDRV_PROFILE_SHA256              0x00000040
+#define PHXDRV_PROFILE_MODEXP              0x00000080
+#define PHXDRV_PROFILE_COMBINED            0x00000100
+#define PHXDRV_PROFILE_SHA384              0x00000400
+#define PHXDRV_PROFILE_SHA512              0x00000800
+#define PHXDRV_PROFILE_GCM                 0x00001000
+#define PHXDRV_PROFILE_KASUMI_F8           0x00002000
+#define PHXDRV_PROFILE_KASUMI_F9           0x00004000
+#define PHXDRV_PROFILE_ECC                 0x00008000
+#define PHXDRV_PROFILE_HMAC_REVERTS        0x00010000
+#define PHXDRV_PROFILE_CPHR_REVERTS        0x00020000
+#define PHXDRV_PROFILE_UNALIGNED_AUTH_DEST 0x10000000
+
+typedef struct hmac_stats
+{
+	unsigned long md5_count;
+	unsigned long long md5_bytes;
+	unsigned long sha1_count;
+	unsigned long long sha1_bytes;
+	unsigned long sha256_count;
+	unsigned long long sha256_bytes;
+	unsigned long sha384_count;
+	unsigned long long sha384_bytes;
+	unsigned long sha512_count;
+	unsigned long long sha512_bytes;
+	unsigned long gcm_count;
+	unsigned long long gcm_bytes;
+	unsigned long kasumi_f9_count;
+	unsigned long long kasumi_f9_bytes;
+	unsigned long reverts;
+	unsigned long long reverts_bytes;
+} hmac_stats_t, *hmac_stats_pt;
+
+typedef struct cipher_stats
+{
+	unsigned long des_encrypts;
+	unsigned long long des_encrypt_bytes;
+	unsigned long des_decrypts;
+	unsigned long long des_decrypt_bytes;
+	unsigned long des3_encrypts;
+	unsigned long long des3_encrypt_bytes;
+	unsigned long des3_decrypts;
+	unsigned long long des3_decrypt_bytes;
+	unsigned long aes_encrypts;
+	unsigned long long aes_encrypt_bytes;
+	unsigned long aes_decrypts;
+	unsigned long long aes_decrypt_bytes;
+	unsigned long arc4_encrypts;
+	unsigned long long arc4_encrypt_bytes;
+	unsigned long arc4_decrypts;
+	unsigned long long arc4_decrypt_bytes;
+	unsigned long kasumi_f8_encrypts;
+	unsigned long long kasumi_f8_encrypt_bytes;
+	unsigned long kasumi_f8_decrypts;
+	unsigned long long kasumi_f8_decrypt_bytes;
+	unsigned long reverts;
+	unsigned long long reverts_bytes;
+} cipher_stats_t, *cipher_stats_pt;
+
+typedef struct modexp_stats
+{
+	unsigned long modexp_512s;
+	unsigned long modexp_1024s;
+} modexp_stats_t, *modexp_stats_pt;
+
+typedef struct ecc_stats
+{
+	unsigned long ecc_mul;
+	unsigned long ecc_add;
+	unsigned long ecc_dbl;
+	unsigned long ecc_vfy;
+	unsigned long ecc_bin_mul;
+	unsigned long ecc_field_bin_inv;
+	unsigned long ecc_field_bin_mul;
+	unsigned long ecc_field_bin_add;
+	unsigned long ecc_field_add;
+	unsigned long ecc_field_sub;
+	unsigned long ecc_field_mul;
+	unsigned long ecc_field_inv;
+	unsigned long ecc_field_div;
+	unsigned long ecc_field_red;
+} ecc_stats_t, *ecc_stats_pt;
+
+typedef struct opt_stats
+{
+	unsigned long combined;
+	unsigned long unaligned_auth_dest;
+	unsigned long sym_failed;
+	unsigned long modexp_failed;
+	unsigned long ecc_failed;
+} opt_stats_t, *opt_stats_pt;
+
+typedef struct rmisec_stats
+{
+	uint32_t sent;
+	uint32_t received;
+	uint32_t stats_mask;
+	uint32_t control_mask;
+	rwlock_t rmisec_control_lock;
+	rwlock_t rmisec_stats_lock;
+	char clear_start[0];
+	uint64_t wait_time;
+	uint32_t max_wait_time;
+	uint32_t maxsnd_wait_time;
+	uint32_t wait_count;
+	hmac_stats_t hmac;
+	cipher_stats_t cipher;
+	modexp_stats_t modexp;
+	ecc_stats_t ecc;
+	opt_stats_t opt;
+} rmisec_stats_t, *rmisec_stats_pt;
+
+/* Control-related section */
+
+#define PHXDRV_CONTROL_HW_DES          0x00000001
+#define PHXDRV_CONTROL_HW_3DES         0x00000002
+#define PHXDRV_CONTROL_HW_AES          0x00000004
+#define PHXDRV_CONTROL_HW_ARC4         0x00000008
+#define PHXDRV_CONTROL_HW_MD5          0x00000010
+#define PHXDRV_CONTROL_HW_SHA1         0x00000020
+#define PHXDRV_CONTROL_HW_SHA256       0x00000040
+#define PHXDRV_CONTROL_HW_SHA384       0x00000080
+#define PHXDRV_CONTROL_HW_SHA512       0x00000100
+#define PHXDRV_CONTROL_HW_GCM          0x00000200
+#define PHXDRV_CONTROL_HW_KASUMI_F8    0x00000400
+#define PHXDRV_CONTROL_HW_KASUMI_F9    0x00000800
+#define PHXDRV_CONTROL_HW_COMBINED     0x00008000
+#define PHXDRV_CONTROL_SILENT          0x20000000
+#define PHXDRV_CONTROL_VERBOSE         0x40000000
+#define PHXDRV_CONTROL_VVERBOSE        0x80000000
+
+#define PHXDRV_VERY_VERBOSE            2
+#define PHXDRV_VERBOSE                 1
+#define PHXDRV_NORMAL                  0
+#define PHXDRV_SILENT                 -1
+
+/* stats routines */
+
+static void inline phxdrv_record_sent(rmisec_stats_pt stats)
+{
+	write_lock(&stats->rmisec_stats_lock);
+	stats->sent++;
+	write_unlock(&stats->rmisec_stats_lock);
+}
+
+static void inline phxdrv_record_received(rmisec_stats_pt stats)
+{
+	write_lock(&stats->rmisec_stats_lock);
+	stats->received++;
+	write_unlock(&stats->rmisec_stats_lock);
+}
+
+static void inline phxdrv_record_des(rmisec_stats_pt stats, int enc,
+									 int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_DES) {
+		write_lock(&stats->rmisec_stats_lock);
+		if (enc) {
+			stats->cipher.des_encrypts++;
+			stats->cipher.des_encrypt_bytes += nbytes;
+		}
+		else {
+			stats->cipher.des_decrypts++;
+			stats->cipher.des_decrypt_bytes += nbytes;
+		}
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_3des(rmisec_stats_pt stats, int enc,
+									  int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_3DES) {
+		write_lock(&stats->rmisec_stats_lock);
+		if (enc) {
+			stats->cipher.des3_encrypts++;
+			stats->cipher.des3_encrypt_bytes += nbytes;
+		}
+		else {
+			stats->cipher.des3_decrypts++;
+			stats->cipher.des3_decrypt_bytes += nbytes;
+		}
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_aes(rmisec_stats_pt stats, int enc,
+									 int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_AES) {
+		write_lock(&stats->rmisec_stats_lock);
+		if (enc) {
+			stats->cipher.aes_encrypts++;
+			stats->cipher.aes_encrypt_bytes += nbytes;
+		}
+		else {
+			stats->cipher.aes_decrypts++;
+			stats->cipher.aes_decrypt_bytes += nbytes;
+		}
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_arc4(rmisec_stats_pt stats, int enc,
+									  int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_ARC4) {
+		write_lock(&stats->rmisec_stats_lock);
+		if (enc) {
+			stats->cipher.arc4_encrypts++;
+			stats->cipher.arc4_encrypt_bytes += nbytes;
+		}
+		else {
+			stats->cipher.arc4_decrypts++;
+			stats->cipher.arc4_decrypt_bytes += nbytes;
+		}
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+static void inline phxdrv_record_kasumi_f8(rmisec_stats_pt stats, int enc,
+										   int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_KASUMI_F8) {
+		write_lock(&stats->rmisec_stats_lock);
+		if (enc) {
+			stats->cipher.kasumi_f8_encrypts++;
+			stats->cipher.kasumi_f8_encrypt_bytes += nbytes;
+		}
+		else {
+			stats->cipher.kasumi_f8_decrypts++;
+			stats->cipher.kasumi_f8_decrypt_bytes += nbytes;
+		}
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_modexp(rmisec_stats_pt stats, int blksize)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_MODEXP) {
+		write_lock(&stats->rmisec_stats_lock);
+		if (blksize == 512) {
+			stats->modexp.modexp_512s++;
+		}
+		if (blksize == 1024) {
+			stats->modexp.modexp_1024s++;
+		}
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_ecc(rmisec_stats_pt stats, PHX_ECC_OP op)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_ECC) {
+		write_lock(&stats->rmisec_stats_lock);
+		switch (op) {
+			case PHX_ECC_NOP:
+				break;
+			case PHX_ECC_MUL:
+				stats->ecc.ecc_mul++;
+				break;
+			case PHX_ECC_BIN_MUL:
+				stats->ecc.ecc_bin_mul++;
+				break;
+			case PHX_ECC_ADD:
+				stats->ecc.ecc_add++;
+				break;
+			case PHX_ECC_DBL:
+				stats->ecc.ecc_dbl++;
+				break;
+			case PHX_ECC_VFY:
+				stats->ecc.ecc_vfy++;
+				break;
+			case PHX_ECC_FIELD_BIN_INV:
+				stats->ecc.ecc_field_bin_inv++;
+				break;
+			case PHX_ECC_FIELD_BIN_MUL:
+				stats->ecc.ecc_field_bin_mul++;
+				break;
+			case PHX_ECC_FIELD_BIN_ADD:
+				stats->ecc.ecc_field_bin_add++;
+				break;
+			case PHX_ECC_FIELD_ADD:
+				stats->ecc.ecc_field_add++;
+				break;
+			case PHX_ECC_FIELD_SUB:
+				stats->ecc.ecc_field_sub++;
+				break;
+			case PHX_ECC_FIELD_MUL:
+				stats->ecc.ecc_field_mul++;
+				break;
+			case PHX_ECC_FIELD_INV:
+				stats->ecc.ecc_field_inv++;
+				break;
+			case PHX_ECC_FIELD_DIV:
+				stats->ecc.ecc_field_div++;
+				break;
+			case PHX_ECC_FIELD_RED:
+				stats->ecc.ecc_field_red++;
+				break;
+			case PHX_ECC_FIELD:
+			case PHX_ECC_BIN:
+				break;
+		}
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_cipher_revert(rmisec_stats_pt stats,
+											   int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_CPHR_REVERTS) {
+		write_lock(&stats->rmisec_stats_lock);
+		stats->cipher.reverts++;
+		stats->cipher.reverts_bytes += nbytes;
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_hmac_revert(rmisec_stats_pt stats,
+											 int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_HMAC_REVERTS) {
+		write_lock(&stats->rmisec_stats_lock);
+		stats->hmac.reverts++;
+		stats->hmac.reverts_bytes += nbytes;
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_md5(rmisec_stats_pt stats, int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_MD5) {
+		write_lock(&stats->rmisec_stats_lock);
+		stats->hmac.md5_count++;
+		stats->hmac.md5_bytes += nbytes;
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_sha1(rmisec_stats_pt stats, int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_SHA1) {
+		write_lock(&stats->rmisec_stats_lock);
+		stats->hmac.sha1_count++;
+		stats->hmac.sha1_bytes += nbytes;
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_sha256(rmisec_stats_pt stats, int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_SHA256) {
+		write_lock(&stats->rmisec_stats_lock);
+		stats->hmac.sha256_count++;
+		stats->hmac.sha256_bytes += nbytes;
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_sha384(rmisec_stats_pt stats, int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_SHA384) {
+		write_lock(&stats->rmisec_stats_lock);
+		stats->hmac.sha384_count++;
+		stats->hmac.sha384_bytes += nbytes;
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_sha512(rmisec_stats_pt stats, int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_SHA512) {
+		write_lock(&stats->rmisec_stats_lock);
+		stats->hmac.sha512_count++;
+		stats->hmac.sha512_bytes += nbytes;
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_gcm(rmisec_stats_pt stats, int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_GCM) {
+		write_lock(&stats->rmisec_stats_lock);
+		stats->hmac.gcm_count++;
+		stats->hmac.gcm_bytes += nbytes;
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_kasumi_f9(rmisec_stats_pt stats, int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_KASUMI_F9) {
+		write_lock(&stats->rmisec_stats_lock);
+		stats->hmac.kasumi_f9_count++;
+		stats->hmac.kasumi_f9_bytes += nbytes;
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_unaligned_auth_dest(rmisec_stats_pt stats,
+													 int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_UNALIGNED_AUTH_DEST) {
+		write_lock(&stats->rmisec_stats_lock);
+		stats->opt.unaligned_auth_dest++;
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_combined(rmisec_stats_pt stats, int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_COMBINED) {
+		write_lock(&stats->rmisec_stats_lock);
+		stats->opt.combined++;
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_sym_failed(rmisec_stats_pt stats, int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_COMBINED) {
+		write_lock(&stats->rmisec_stats_lock);
+		stats->opt.sym_failed++;
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_modexp_failed(rmisec_stats_pt stats,
+											   int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_COMBINED) {
+		write_lock(&stats->rmisec_stats_lock);
+		stats->opt.modexp_failed++;
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+
+static void inline phxdrv_record_ecc_failed(rmisec_stats_pt stats, int nbytes)
+{
+	if (stats->stats_mask & PHXDRV_PROFILE_COMBINED) {
+		write_lock(&stats->rmisec_stats_lock);
+		stats->opt.ecc_failed++;
+		write_unlock(&stats->rmisec_stats_lock);
+	}
+}
+#endif /* _PHXDRV_H_ */
diff --git a/drivers/char/rmisec/phxdrv/phxsec.h b/drivers/char/rmisec/phxdrv/phxsec.h
new file mode 100644
index 0000000..c8c78c1
--- /dev/null
+++ b/drivers/char/rmisec/phxdrv/phxsec.h
@@ -0,0 +1,867 @@
+/*
+ **  Raza Microelectronics Incorporated
+ **  Phoenix Security Engine driver for Linux
+ **
+ **  Copyright (C) 2003 Raza Foundries
+ **  Author: Dave Koplos;  dkoplos@razafoundries.com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*
+ * RMI Phoenix Security Engine
+ *
+ * phxsec.h: Interface functions and defintions for the phxsec Software Reference
+ *           Library.
+ *
+ * Revision History:
+ *
+ * 04/01/2004  DPK   Created
+ */
+
+#ifndef _PHXSEC_H_
+#define _PHXSEC_H_
+
+#include <linux/types.h>
+
+#ifndef __KERNEL__
+typedef unsigned long long uint64_t;
+#endif
+
+
+/* 
+ *  Wrapper OS types.
+ */
+#ifndef OS_DeviceInfo_t
+#define OS_DeviceInfo_t void *
+#endif
+
+#ifndef OS_MemHandle_t
+#define OS_MemHandle_t uint64_t
+#endif
+
+#ifdef __KERNEL__
+
+#include <linux/completion.h>
+
+#ifndef OS_ALLOC_KERNEL
+#include <linux/gfp.h>
+#define OS_ALLOC_KERNEL(size) kmalloc((size), GFP_KERNEL)
+#endif
+
+#ifndef OS_FREE
+#define OS_FREE(mem) kfree((mem))
+#endif
+
+#ifndef OS_SEMAPHORE_INIT
+#define OS_SEMAPHORE_INIT(sema) sema_init((sema),0)
+#endif
+
+#ifndef OS_SEMAPHORE_GET
+#define OS_SEMAPHORE_GET(sema) down_interruptible((sema))
+#endif
+
+#ifndef OS_SEMAPHORE_SET
+#define OS_SEMAPHORE_SET(sema) up((sema))
+#endif
+
+
+#ifndef OS_WAIT_INIT
+#define OS_WAIT_INIT(event) init_completion((event))
+#endif
+
+#ifndef OS_WAIT
+#define OS_WAIT(event) wait_for_completion((event))
+#endif
+
+#ifndef OS_WAIT_END
+#define OS_WAIT_END(event) complete((event))
+#endif
+
+#ifndef OS_WAIT_US
+#include <asm/delay.h>
+#define OS_WAIT_US(us) udelay((us))
+#endif
+
+#endif /* __KERNEL__ */
+
+/* 
+ * Version of the device library
+ */
+#define PHXSEC_VERSION_MAJOR 0x1
+#define PHXSEC_VERSION_MINOR 0x0
+/* Single alphanumeric character, start with blank, then a,b,c... */
+#define PHXSEC_VERSION_REV   ' '
+
+/*
+ * Cryptographic parameter definitions
+ */
+#define PHXSEC_DES_KEY_LENGTH        8	/* Bytes */
+#define PHXSEC_3DES_KEY_LENGTH       24	/* Bytes */
+#define PHXSEC_AES128_KEY_LENGTH     16	/* Bytes */
+#define PHXSEC_AES192_KEY_LENGTH     24	/* Bytes */
+#define PHXSEC_AES256_KEY_LENGTH     32	/* Bytes */
+#define PHXSEC_AES128F8_KEY_LENGTH   32	/* Bytes */
+#define PHXSEC_AES192F8_KEY_LENGTH   48	/* Bytes */
+#define PHXSEC_AES256F8_KEY_LENGTH   64	/* Bytes */
+#define PHXSEC_KASUMI_F8_KEY_LENGTH  16	/* Bytes */
+#define PHXSEC_MAX_CRYPT_KEY_LENGTH  PHXSEC_AES256F8_KEY_LENGTH
+
+#define PHXSEC_DES_IV_LENGTH         8	/* Bytes */
+#define PHXSEC_AES_IV_LENGTH         16	/* Bytes */
+#define PHXSEC_ARC4_IV_LENGTH        0	/* Bytes */
+#define PHXSEC_KASUMI_F8_IV_LENGTH   16	/* Bytes */
+#define PHXSEC_MAX_IV_LENGTH         16	/* Bytes */
+#define PHXSEC_IV_LENGTH_BYTES       8	/* Bytes */
+
+#define PHXSEC_AES_BLOCK_SIZE        16	/* Bytes */
+#define PHXSEC_DES_BLOCK_SIZE        8	/* Bytes */
+#define PHXSEC_3DES_BLOCK_SIZE       8	/* Bytes */
+
+#define PHXSEC_MD5_BLOCK_SIZE        64	/* Bytes */
+#define PHXSEC_SHA1_BLOCK_SIZE       64	/* Bytes */
+#define PHXSEC_SHA256_BLOCK_SIZE     64	/* Bytes */
+#define PHXSEC_SHA384_BLOCK_SIZE     128	/* Bytes */
+#define PHXSEC_SHA512_BLOCK_SIZE     128	/* Bytes */
+#define PHXSEC_GCM_BLOCK_SIZE        16	/* XXX: Bytes */
+#define PHXSEC_KASUMI_F9_BLOCK_SIZE  16	/* XXX: Bytes */
+#define PHXSEC_MAX_BLOCK_SIZE        64	/* Max of MD5/SHA */
+#define PHXSEC_MD5_LENGTH            16	/* Bytes */
+#define PHXSEC_SHA1_LENGTH           20	/* Bytes */
+#define PHXSEC_SHA256_LENGTH         32	/* Bytes */
+#define PHXSEC_SHA384_LENGTH         64	/* Bytes */
+#define PHXSEC_SHA512_LENGTH         64	/* Bytes */
+#define PHXSEC_GCM_LENGTH            16	/* Bytes */
+#define PHXSEC_KASUMI_F9_LENGTH      16	/* Bytes */
+#define PHXSEC_KASUMI_F9_RESULT_LENGTH 4	/* Bytes */
+#define PHXSEC_HMAC_LENGTH           64	/* Max of MD5/SHA/SHA256 */
+#define PHXSEC_MAX_AUTH_KEY_LENGTH   PHXSEC_SHA512_BLOCK_SIZE
+#define PHXSEC_MAX_RC4_STATE_SIZE    264	/* char s[256], int i, int j */
+
+
+/* Status code is used by the SRL to indicate status */
+typedef unsigned int phxsec_status_t;
+
+/*
+ * Status codes
+ */
+#define PHXSEC_STATUS_SUCCESS              0
+#define PHXSEC_STATUS_NO_DEVICE           -1
+#define PHXSEC_STATUS_TIMEOUT             -2
+#define PHXSEC_STATUS_INVALID_PARAMETER   -3
+#define PHXSEC_STATUS_DEVICE_FAILED       -4
+#define PHXSEC_STATUS_DEVICE_BUSY         -5
+#define PHXSEC_STATUS_NO_RESOURCE         -6
+#define PHXSEC_STATUS_CANCELLED           -7
+
+/*
+ * Flags
+ */
+#define PHXSEC_FLAGS_HIGH_PRIORITY         1
+
+/* Error code is used to indicate any errors */
+typedef int phxsec_error_t;
+
+/*
+ */
+#define PHXSEC_ERR_NONE                    0
+#define PHXSEC_ERR_CIPHER_OP              -1
+#define PHXSEC_ERR_CIPHER_TYPE            -2
+#define PHXSEC_ERR_CIPHER_MODE            -3
+#define PHXSEC_ERR_CIPHER_INIT            -4
+#define PHXSEC_ERR_DIGEST_TYPE            -5
+#define PHXSEC_ERR_DIGEST_INIT            -6
+#define PHXSEC_ERR_DIGEST_SRC             -7
+#define PHXSEC_ERR_CKSUM_TYPE             -8
+#define PHXSEC_ERR_CKSUM_SRC              -9
+#define PHXSEC_ERR_ALLOC                  -10
+#define PHXSEC_ERR_CONTROL_VECTOR         -11
+#define PHXSEC_ERR_LOADHMACKEY_MODE       -12
+#define PHXSEC_ERR_PADHASH_MODE           -13
+#define PHXSEC_ERR_HASHBYTES_MODE         -14
+#define PHXSEC_ERR_NEXT_MODE              -15
+#define PHXSEC_ERR_PKT_IV_MODE            -16
+#define PHXSEC_ERR_LASTWORD_MODE          -17
+#define PHXSEC_ERR_PUBKEY_OP              -18
+#define PHXSEC_ERR_SYMKEY_MSGSND          -19
+#define PHXSEC_ERR_PUBKEY_MSGSND          -20
+#define PHXSEC_ERR_SYMKEY_GETSEM          -21
+#define PHXSEC_ERR_PUBKEY_GETSEM          -22
+
+
+/*
+ * Descriptor Vector quantities 
+ *  (helps to identify descriptor type per operation)
+ */
+#define PHX_VECTOR_CIPHER_DES             0x0001
+#define PHX_VECTOR_CIPHER_3DES            0x0002
+#define PHX_VECTOR_CIPHER_AES128          0x0004
+#define PHX_VECTOR_CIPHER_AES192          0x0008
+#define PHX_VECTOR_CIPHER_AES256          0x0010
+#define PHX_VECTOR_CIPHER_ARC4            0x0020
+#define PHX_VECTOR_CIPHER_AES             (PHX_VECTOR_CIPHER_AES128 | \
+                                           PHX_VECTOR_CIPHER_AES192 | \
+                                           PHX_VECTOR_CIPHER_AES256)
+#define PHX_VECTOR_CIPHER                 (PHX_VECTOR_CIPHER_DES | \
+                                           PHX_VECTOR_CIPHER_3DES | \
+                                           PHX_VECTOR_CIPHER_AES128 | \
+                                           PHX_VECTOR_CIPHER_AES192 | \
+                                           PHX_VECTOR_CIPHER_AES256 | \
+                                           PHX_VECTOR_CIPHER_ARC4)
+
+#define PHX_VECTOR_HMAC                   0x0040
+#define PHX_VECTOR_MAC                    0x0080
+#define PHX_VECTOR_MODE_CTR_CFB           0x0100
+#define PHX_VECTOR_MODE_ECB_CBC_OFB       0x0200
+#define PHX_VECTOR_MODE_ECB_CBC           0x0400
+#define PHX_VECTOR_STATE                  0x0800
+#define PHX_VECTOR_CIPHER_KASUMI_F8       0x01000
+#define PHX_VECTOR_HMAC2                  0x02000
+#define PHX_VECTOR_GCM                    0x04000
+#define PHX_VECTOR_F9                     0x08000
+#define PHX_VECTOR_MODE_F8                0x10000
+
+
+#define PHX_VECTOR_CIPHER_ARC4__HMAC  \
+(PHX_VECTOR_CIPHER_ARC4 | PHX_VECTOR_HMAC)
+#define PHX_VECTOR_CIPHER_ARC4__STATE  \
+(PHX_VECTOR_CIPHER_ARC4 | PHX_VECTOR_STATE)
+#define PHX_VECTOR_CIPHER_ARC4__HMAC__STATE  \
+(PHX_VECTOR_CIPHER_ARC4 | PHX_VECTOR_HMAC | PHX_VECTOR_STATE)
+
+#define PHX_VECTOR__CIPHER_DES__HMAC__MODE_ECB_CBC \
+(PHX_VECTOR_CIPHER_DES | PHX_VECTOR_HMAC | PHX_VECTOR_MODE_ECB_CBC)
+
+#define PHX_VECTOR__CIPHER_DES__MODE_ECB_CBC \
+(PHX_VECTOR_CIPHER_DES | PHX_VECTOR_MODE_ECB_CBC)
+
+#define PHX_VECTOR__CIPHER_3DES__HMAC__MODE_ECB_CBC \
+(PHX_VECTOR_CIPHER_3DES | PHX_VECTOR_HMAC | PHX_VECTOR_MODE_ECB_CBC)
+
+#define PHX_VECTOR__CIPHER_3DES__MODE_ECB_CBC \
+(PHX_VECTOR_CIPHER_3DES | PHX_VECTOR_MODE_ECB_CBC)
+
+#define PHX_VECTOR__CIPHER_AES128__HMAC__MODE_CTR_CFB \
+(PHX_VECTOR_CIPHER_AES128 | PHX_VECTOR_HMAC | PHX_VECTOR_MODE_CTR_CFB)
+
+#define PHX_VECTOR__CIPHER_AES128__MODE_CTR_CFB \
+(PHX_VECTOR_CIPHER_AES128 | PHX_VECTOR_MODE_CTR_CFB)
+
+#define PHX_VECTOR__CIPHER_AES128__HMAC__MODE_ECB_CBC_OFB \
+(PHX_VECTOR_CIPHER_AES128 | PHX_VECTOR_HMAC | PHX_VECTOR_MODE_ECB_CBC_OFB)
+
+#define PHX_VECTOR__CIPHER_AES128__MODE_ECB_CBC_OFB \
+(PHX_VECTOR_CIPHER_AES128 | PHX_VECTOR_MODE_ECB_CBC_OFB)
+
+#define PHX_VECTOR__CIPHER_AES192__HMAC__MODE_CTR_CFB \
+(PHX_VECTOR_CIPHER_AES192 | PHX_VECTOR_HMAC | PHX_VECTOR_MODE_CTR_CFB)
+
+#define PHX_VECTOR__CIPHER_AES192__MODE_CTR_CFB \
+(PHX_VECTOR_CIPHER_AES192 | PHX_VECTOR_MODE_CTR_CFB)
+
+#define PHX_VECTOR__CIPHER_AES192__HMAC__MODE_ECB_CBC_OFB \
+(PHX_VECTOR_CIPHER_AES192 | PHX_VECTOR_HMAC | PHX_VECTOR_MODE_ECB_CBC_OFB)
+
+#define PHX_VECTOR__CIPHER_AES192__MODE_ECB_CBC_OFB \
+(PHX_VECTOR_CIPHER_AES192 | PHX_VECTOR_MODE_ECB_CBC_OFB)
+
+#define PHX_VECTOR__CIPHER_AES256__HMAC__MODE_CTR_CFB \
+(PHX_VECTOR_CIPHER_AES256 | PHX_VECTOR_HMAC | PHX_VECTOR_MODE_CTR_CFB)
+
+#define PHX_VECTOR__CIPHER_AES256__MODE_CTR_CFB \
+(PHX_VECTOR_CIPHER_AES256 | PHX_VECTOR_MODE_CTR_CFB)
+
+#define PHX_VECTOR__CIPHER_AES256__HMAC__MODE_ECB_CBC_OFB \
+(PHX_VECTOR_CIPHER_AES256 | PHX_VECTOR_HMAC | PHX_VECTOR_MODE_ECB_CBC_OFB)
+
+#define PHX_VECTOR__CIPHER_AES256__MODE_ECB_CBC_OFB \
+(PHX_VECTOR_CIPHER_AES256 | PHX_VECTOR_MODE_ECB_CBC_OFB)
+
+#define PHX_VECTOR__CIPHER_AES128__HMAC__MODE_F8 \
+(PHX_VECTOR_CIPHER_AES128 | PHX_VECTOR_HMAC | PHX_VECTOR_MODE_F8)
+
+#define PHX_VECTOR__CIPHER_AES128__MODE_F8 \
+(PHX_VECTOR_CIPHER_AES128 | PHX_VECTOR_MODE_F8)
+
+#define PHX_VECTOR__CIPHER_AES192__HMAC__MODE_F8 \
+(PHX_VECTOR_CIPHER_AES192 | PHX_VECTOR_HMAC | PHX_VECTOR_MODE_F8)
+
+#define PHX_VECTOR__CIPHER_AES192__MODE_F8 \
+(PHX_VECTOR_CIPHER_AES192 | PHX_VECTOR_MODE_F8)
+
+#define PHX_VECTOR__CIPHER_AES256__HMAC__MODE_F8 \
+(PHX_VECTOR_CIPHER_AES256 | PHX_VECTOR_HMAC | PHX_VECTOR_MODE_F8)
+
+#define PHX_VECTOR__CIPHER_AES256__MODE_F8 \
+(PHX_VECTOR_CIPHER_AES256 | PHX_VECTOR_MODE_F8)
+
+#define PHX_VECTOR_CIPHER_KASUMI_F8__F9  \
+(PHX_VECTOR_CIPHER_KASUMI_F8 | PHX_VECTOR_F9)
+
+#define PHX_VECTOR_CIPHER_KASUMI_F8__HMAC  \
+(PHX_VECTOR_CIPHER_KASUMI_F8 | PHX_VECTOR_HMAC)
+
+#define PHX_VECTOR_CIPHER_KASUMI_F8__HMAC2  \
+(PHX_VECTOR_CIPHER_KASUMI_F8 | PHX_VECTOR_HMAC2)
+
+#define PHX_VECTOR_CIPHER_KASUMI_F8__GCM  \
+(PHX_VECTOR_CIPHER_KASUMI_F8 | PHX_VECTOR_GCM)
+
+#define PHX_VECTOR_CIPHER_ARC4__HMAC2  \
+(PHX_VECTOR_CIPHER_ARC4 | PHX_VECTOR_HMAC2)
+
+#define PHX_VECTOR_CIPHER_ARC4__HMAC2__STATE  \
+(PHX_VECTOR_CIPHER_ARC4 | PHX_VECTOR_HMAC2 | PHX_VECTOR_STATE)
+
+#define PHX_VECTOR__CIPHER_DES__HMAC2__MODE_ECB_CBC \
+(PHX_VECTOR_CIPHER_DES | PHX_VECTOR_HMAC2 | PHX_VECTOR_MODE_ECB_CBC)
+
+#define PHX_VECTOR__CIPHER_3DES__HMAC2__MODE_ECB_CBC \
+(PHX_VECTOR_CIPHER_3DES | PHX_VECTOR_HMAC2 | PHX_VECTOR_MODE_ECB_CBC)
+
+#define PHX_VECTOR__CIPHER_AES128__HMAC2__MODE_CTR_CFB \
+(PHX_VECTOR_CIPHER_AES128 | PHX_VECTOR_HMAC2 | PHX_VECTOR_MODE_CTR_CFB)
+
+#define PHX_VECTOR__CIPHER_AES128__HMAC2__MODE_ECB_CBC_OFB \
+(PHX_VECTOR_CIPHER_AES128 | PHX_VECTOR_HMAC2 | PHX_VECTOR_MODE_ECB_CBC_OFB)
+
+#define PHX_VECTOR__CIPHER_AES192__HMAC2__MODE_CTR_CFB \
+(PHX_VECTOR_CIPHER_AES192 | PHX_VECTOR_HMAC2 | PHX_VECTOR_MODE_CTR_CFB)
+
+#define PHX_VECTOR__CIPHER_AES192__HMAC2__MODE_ECB_CBC_OFB \
+(PHX_VECTOR_CIPHER_AES192 | PHX_VECTOR_HMAC2 | PHX_VECTOR_MODE_ECB_CBC_OFB)
+
+#define PHX_VECTOR__CIPHER_AES256__HMAC2__MODE_CTR_CFB \
+(PHX_VECTOR_CIPHER_AES256 | PHX_VECTOR_HMAC2 | PHX_VECTOR_MODE_CTR_CFB)
+
+#define PHX_VECTOR__CIPHER_AES256__HMAC2__MODE_ECB_CBC_OFB \
+(PHX_VECTOR_CIPHER_AES256 | PHX_VECTOR_HMAC2 | PHX_VECTOR_MODE_ECB_CBC_OFB)
+
+#define PHX_VECTOR__CIPHER_AES128__HMAC2__MODE_F8 \
+(PHX_VECTOR_CIPHER_AES128 | PHX_VECTOR_HMAC2 | PHX_VECTOR_MODE_F8)
+
+#define PHX_VECTOR__CIPHER_AES192__HMAC2__MODE_F8 \
+(PHX_VECTOR_CIPHER_AES192 | PHX_VECTOR_HMAC2 | PHX_VECTOR_MODE_F8)
+
+#define PHX_VECTOR__CIPHER_AES256__HMAC2__MODE_F8 \
+(PHX_VECTOR_CIPHER_AES256 | PHX_VECTOR_HMAC2 | PHX_VECTOR_MODE_F8)
+
+#define PHX_VECTOR_CIPHER_ARC4__GCM  \
+(PHX_VECTOR_CIPHER_ARC4 | PHX_VECTOR_GCM)
+
+#define PHX_VECTOR_CIPHER_ARC4__GCM__STATE  \
+(PHX_VECTOR_CIPHER_ARC4 | PHX_VECTOR_GCM | PHX_VECTOR_STATE)
+
+#define PHX_VECTOR__CIPHER_DES__GCM__MODE_ECB_CBC \
+(PHX_VECTOR_CIPHER_DES | PHX_VECTOR_GCM | PHX_VECTOR_MODE_ECB_CBC)
+
+#define PHX_VECTOR__CIPHER_3DES__GCM__MODE_ECB_CBC \
+(PHX_VECTOR_CIPHER_3DES | PHX_VECTOR_GCM | PHX_VECTOR_MODE_ECB_CBC)
+
+#define PHX_VECTOR__CIPHER_AES128__GCM__MODE_CTR_CFB \
+(PHX_VECTOR_CIPHER_AES128 | PHX_VECTOR_GCM | PHX_VECTOR_MODE_CTR_CFB)
+
+#define PHX_VECTOR__CIPHER_AES128__GCM__MODE_ECB_CBC_OFB \
+(PHX_VECTOR_CIPHER_AES128 | PHX_VECTOR_GCM | PHX_VECTOR_MODE_ECB_CBC_OFB)
+
+#define PHX_VECTOR__CIPHER_AES192__GCM__MODE_CTR_CFB \
+(PHX_VECTOR_CIPHER_AES192 | PHX_VECTOR_GCM | PHX_VECTOR_MODE_CTR_CFB)
+
+#define PHX_VECTOR__CIPHER_AES192__GCM__MODE_ECB_CBC_OFB \
+(PHX_VECTOR_CIPHER_AES192 | PHX_VECTOR_GCM | PHX_VECTOR_MODE_ECB_CBC_OFB)
+
+#define PHX_VECTOR__CIPHER_AES256__GCM__MODE_CTR_CFB \
+(PHX_VECTOR_CIPHER_AES256 | PHX_VECTOR_GCM | PHX_VECTOR_MODE_CTR_CFB)
+
+#define PHX_VECTOR__CIPHER_AES256__GCM__MODE_ECB_CBC_OFB \
+(PHX_VECTOR_CIPHER_AES256 | PHX_VECTOR_GCM | PHX_VECTOR_MODE_ECB_CBC_OFB)
+
+#define PHX_VECTOR__CIPHER_AES128__GCM__MODE_F8 \
+(PHX_VECTOR_CIPHER_AES128 | PHX_VECTOR_GCM | PHX_VECTOR_MODE_F8)
+
+#define PHX_VECTOR__CIPHER_AES192__GCM__MODE_F8 \
+(PHX_VECTOR_CIPHER_AES192 | PHX_VECTOR_GCM | PHX_VECTOR_MODE_F8)
+
+#define PHX_VECTOR__CIPHER_AES256__GCM__MODE_F8 \
+(PHX_VECTOR_CIPHER_AES256 | PHX_VECTOR_GCM | PHX_VECTOR_MODE_F8)
+
+#define PHX_VECTOR_CIPHER_ARC4__F9  \
+(PHX_VECTOR_CIPHER_ARC4 | PHX_VECTOR_F9)
+
+#define PHX_VECTOR_CIPHER_ARC4__F9__STATE  \
+(PHX_VECTOR_CIPHER_ARC4 | PHX_VECTOR_F9 | PHX_VECTOR_STATE)
+
+#define PHX_VECTOR__CIPHER_DES__F9__MODE_ECB_CBC \
+(PHX_VECTOR_CIPHER_DES | PHX_VECTOR_F9 | PHX_VECTOR_MODE_ECB_CBC)
+
+#define PHX_VECTOR__CIPHER_3DES__F9__MODE_ECB_CBC \
+(PHX_VECTOR_CIPHER_3DES | PHX_VECTOR_F9 | PHX_VECTOR_MODE_ECB_CBC)
+
+#define PHX_VECTOR__CIPHER_AES128__F9__MODE_CTR_CFB \
+(PHX_VECTOR_CIPHER_AES128 | PHX_VECTOR_F9 | PHX_VECTOR_MODE_CTR_CFB)
+
+#define PHX_VECTOR__CIPHER_AES128__F9__MODE_ECB_CBC_OFB \
+(PHX_VECTOR_CIPHER_AES128 | PHX_VECTOR_F9 | PHX_VECTOR_MODE_ECB_CBC_OFB)
+
+#define PHX_VECTOR__CIPHER_AES192__F9__MODE_CTR_CFB \
+(PHX_VECTOR_CIPHER_AES192 | PHX_VECTOR_F9 | PHX_VECTOR_MODE_CTR_CFB)
+
+#define PHX_VECTOR__CIPHER_AES192__F9__MODE_ECB_CBC_OFB \
+(PHX_VECTOR_CIPHER_AES192 | PHX_VECTOR_F9 | PHX_VECTOR_MODE_ECB_CBC_OFB)
+
+#define PHX_VECTOR__CIPHER_AES256__F9__MODE_CTR_CFB \
+(PHX_VECTOR_CIPHER_AES256 | PHX_VECTOR_F9 | PHX_VECTOR_MODE_CTR_CFB)
+
+#define PHX_VECTOR__CIPHER_AES256__F9__MODE_ECB_CBC_OFB \
+(PHX_VECTOR_CIPHER_AES256 | PHX_VECTOR_F9 | PHX_VECTOR_MODE_ECB_CBC_OFB)
+
+#define PHX_VECTOR__CIPHER_AES128__F9__MODE_F8 \
+(PHX_VECTOR_CIPHER_AES128 | PHX_VECTOR_F9 | PHX_VECTOR_MODE_F8)
+
+#define PHX_VECTOR__CIPHER_AES192__F9__MODE_F8 \
+(PHX_VECTOR_CIPHER_AES192 | PHX_VECTOR_F9 | PHX_VECTOR_MODE_F8)
+
+#define PHX_VECTOR__CIPHER_AES256__F9__MODE_F8 \
+(PHX_VECTOR_CIPHER_AES256 | PHX_VECTOR_F9 | PHX_VECTOR_MODE_F8)
+
+/*
+ * Cipher Modes
+ */
+typedef enum
+{
+	PHX_CIPHER_MODE_NONE = 0,
+	PHX_CIPHER_MODE_PASS = 1,
+	PHX_CIPHER_MODE_ECB,
+	PHX_CIPHER_MODE_CBC,
+	PHX_CIPHER_MODE_OFB,
+	PHX_CIPHER_MODE_CTR,
+	PHX_CIPHER_MODE_CFB,
+	PHX_CIPHER_MODE_F8
+} PHX_CIPHER_MODE;
+
+typedef enum
+{
+	PHX_CIPHER_OP_NONE = 0,
+	PHX_CIPHER_OP_ENCRYPT = 1,
+	PHX_CIPHER_OP_DECRYPT
+} PHX_CIPHER_OP;
+
+typedef enum
+{
+	PHX_CIPHER_TYPE_UNSUPPORTED = -1,
+	PHX_CIPHER_TYPE_NONE = 0,
+	PHX_CIPHER_TYPE_DES,
+	PHX_CIPHER_TYPE_3DES,
+	PHX_CIPHER_TYPE_AES128,
+	PHX_CIPHER_TYPE_AES192,
+	PHX_CIPHER_TYPE_AES256,
+	PHX_CIPHER_TYPE_ARC4,
+	PHX_CIPHER_TYPE_KASUMI_F8
+} PHX_CIPHER_TYPE;
+
+typedef enum
+{
+	PHX_CIPHER_INIT_OK = 1,		/* Preserve old Keys */
+	PHX_CIPHER_INIT_NK			/*Load new Keys */
+} PHX_CIPHER_INIT;
+
+
+/*
+ *  Hash Modes
+ */
+typedef enum
+{
+	PHX_DIGEST_TYPE_UNSUPPORTED = -1,
+	PHX_DIGEST_TYPE_NONE = 0,
+	PHX_DIGEST_TYPE_MD5,
+	PHX_DIGEST_TYPE_SHA1,
+	PHX_DIGEST_TYPE_SHA256,
+	PHX_DIGEST_TYPE_SHA384,
+	PHX_DIGEST_TYPE_SHA512,
+	PHX_DIGEST_TYPE_GCM,
+	PHX_DIGEST_TYPE_KASUMI_F9,
+	PHX_DIGEST_TYPE_HMAC_MD5,
+	PHX_DIGEST_TYPE_HMAC_SHA1,
+	PHX_DIGEST_TYPE_HMAC_SHA256,
+	PHX_DIGEST_TYPE_HMAC_SHA384,
+	PHX_DIGEST_TYPE_HMAC_SHA512,
+	PHX_DIGEST_TYPE_HMAC_AES_CBC,
+	PHX_DIGEST_TYPE_HMAC_AES_XCBC
+} PHX_DIGEST_TYPE;
+
+typedef enum
+{
+	PHX_DIGEST_INIT_OLDKEY = 1,	/* Preserve old key HMAC key stored in ID registers (moot if HASH.HMAC == 0) */
+	PHX_DIGEST_INIT_NEWKEY		/*Load new HMAC key from memory ctrl section to ID registers */
+} PHX_DIGEST_INIT;
+
+typedef enum
+{
+	PHX_DIGEST_SRC_DMA = 1,		/* DMA channel */
+	PHX_DIGEST_SRC_CPHR			/*Cipher if word count exceeded Cipher_Offset; else DMA */
+} PHX_DIGEST_SRC;
+
+/*
+ *  Checksum Modes
+ */
+typedef enum
+{
+	PHX_CKSUM_TYPE_NOP = 1,
+	PHX_CKSUM_TYPE_IP
+} PHX_CKSUM_TYPE;
+
+typedef enum
+{
+	PHX_CKSUM_SRC_DMA = 1,
+	PHX_CKSUM_SRC_CIPHER
+} PHX_CKSUM_SRC;
+
+
+/*
+ *  Packet Modes
+ */
+typedef enum
+{
+	PHX_LOADHMACKEY_MODE_OLD = 1,
+	PHX_LOADHMACKEY_MODE_LOAD
+} PHX_LOADHMACKEY_MODE;
+
+typedef enum
+{
+	PHX_PADHASH_PADDED = 1,
+	PHX_PADHASH_PAD
+} PHX_PADHASH_MODE;
+
+typedef enum
+{
+	PHX_HASHBYTES_ALL8 = 1,
+	PHX_HASHBYTES_MSB,
+	PHX_HASHBYTES_MSW
+} PHX_HASHBYTES_MODE;
+
+typedef enum
+{
+	PHX_NEXT_FINISH = 1,
+	PHX_NEXT_DO
+} PHX_NEXT_MODE;
+
+typedef enum
+{
+	PHX_PKT_IV_OLD = 1,
+	PHX_PKT_IV_NEW
+} PHX_PKT_IV_MODE;
+
+typedef enum
+{
+	PHX_LASTWORD_128 = 1,
+	PHX_LASTWORD_96MASK,
+	PHX_LASTWORD_64MASK,
+	PHX_LASTWORD_32MASK
+} PHX_LASTWORD_MODE;
+
+typedef enum
+{
+	PHX_CFB_MASK_REGULAR_CTR = 0,
+	PHX_CFB_MASK_CCMP,
+	PHX_CFB_MASK_GCM_WITH_SCI,
+	PHX_CFB_MASK_GCM_WITHOUT_SCI
+} PHX_CFB_MASK_MODE;
+
+/*
+ *  Public Key
+ */
+typedef enum
+{
+	RMIPK_BLKWIDTH_512 = 1,
+	RMIPK_BLKWIDTH_1024
+} RMIPK_BLKWIDTH_MODE;
+
+typedef enum
+{
+	RMIPK_LDCONST_OLD = 1,
+	RMIPK_LDCONST_NEW
+} RMIPK_LDCONST_MODE;
+
+
+/*
+ * Bulk encryption/decryption ioctl
+ */
+typedef struct phxsec_io_s
+{
+	unsigned int command;
+	unsigned int result_status;
+	unsigned int flags;
+	unsigned int session_num;
+	unsigned int use_callback;
+	unsigned int time_us;
+	unsigned int user_context[2];	/*usable for anything by caller */
+	unsigned int command_context;	/* Context (ID) of this command). */
+	unsigned char initial_vector[PHXSEC_MAX_IV_LENGTH];
+	unsigned char crypt_key[PHXSEC_MAX_CRYPT_KEY_LENGTH];
+	unsigned char mac_key[PHXSEC_MAX_AUTH_KEY_LENGTH];
+
+	PHX_CIPHER_OP cipher_op;
+	PHX_CIPHER_MODE cipher_mode;
+	PHX_CIPHER_TYPE cipher_type;
+	PHX_CIPHER_INIT cipher_init;
+	unsigned int cipher_offset;
+
+	PHX_DIGEST_TYPE digest_type;
+	PHX_DIGEST_INIT digest_init;
+	PHX_DIGEST_SRC digest_src;
+	unsigned int digest_offset;
+
+	PHX_CKSUM_TYPE cksum_type;
+	PHX_CKSUM_SRC cksum_src;
+	unsigned int cksum_offset;
+
+	PHX_LOADHMACKEY_MODE pkt_hmac;
+	PHX_PADHASH_MODE pkt_hash;
+	PHX_HASHBYTES_MODE pkt_hashbytes;
+	PHX_NEXT_MODE pkt_next;
+	PHX_PKT_IV_MODE pkt_iv;
+	PHX_LASTWORD_MODE pkt_lastword;
+
+	unsigned int nonce;
+	unsigned int cfb_mask;
+
+	unsigned int iv_offset;
+	unsigned short pad_type;
+	unsigned short rc4_key_len;
+
+	unsigned int num_packets;
+	unsigned int num_fragments;
+
+	uint64_t source_buf;
+	unsigned int source_buf_size;
+	uint64_t dest_buf;
+	unsigned int dest_buf_size;
+
+	uint64_t auth_dest;
+	uint64_t cksum_dest;
+
+	unsigned short rc4_loadstate;
+	unsigned short rc4_savestate;
+	uint64_t rc4_state;
+
+} phxsec_io_t, *phxsec_io_pt;
+
+
+
+/*
+ * The long key type is used as a generic type to hold public
+ * key information.
+ * KeyValue points to an array of 32-bit integers. The convention of these keys
+ * is such that element[0] of this array holds the least significant part of
+ * the "bignum" (multi-precision integer).
+ * Keylength holds the number of significant bits in the key, i.e. the bit
+ * position of the most significant "1" bit, plus 1.
+ * For example, the multi-precision integer ("key")
+ *    0x0102030405060708090A0B0C0D0E0F00
+ * has 121 significant bits (KeyLength), and would be arranged in the N-element 
+ * array (pointed to by KeyLength) of 32-bit integers as
+ *    array[0] = 0x0D0E0F00
+ *    array[1] = 0x090A0B0C
+ *    array[2] = 0x05060708
+ *    array[3] = 0x01020304
+ *    array[4] = 0x00000000
+ *        ...
+ *    array[N-1] = 0x00000000
+ */
+typedef struct phxsec_LongKey_s
+{
+	unsigned int KeyLength;		/* length in bits */
+	OS_MemHandle_t KeyValue;	/* pointer to 32-bit integer "key" array */
+} phxsec_LongKey_t, *phxsec_LongKey_pt;
+
+
+
+/*
+ * The bignum type is used as a generic type to hold the multi-precision integer
+ * values used in public key calculations.
+ * bignum points to an array of 32-bit integers. The convention of these keys
+ * is such that element[0] of this array holds the least significant part of
+ * the "bignum".
+ * bignum_length holds the number of significant bits in the key, i.e. the bit
+ * position of the most significant "1" bit, plus 1.
+ * For example, the multi-precision integer ("bignum")
+ *    0x0102030405060708090A0B0C0D0E0F00
+ * has 121 significant bits (bignum_length), 
+ *  and would be arranged in the N-element  array 
+ *  (pointed to by bignum) of 32-bit integers as
+ *    array[0] = 0x0D0E0F00
+ *    array[1] = 0x090A0B0C
+ *    array[2] = 0x05060708
+ *    array[3] = 0x01020304
+ *    array[4] = 0x00000000
+ *        ...
+ *    array[N-1] = 0x00000000
+ */
+typedef struct phxsec_bignum_s
+{
+	unsigned int bignum_length;	/* length in bits */
+	OS_MemHandle_t bignum;		/* pointer to 32-bit integer array */
+} phxsec_bignum_t, *phxsec_bignum_pt;
+
+
+/*
+ * Diffie-Hellman parameter type definition.
+ */
+typedef struct phxsec_DH_Params_t
+{
+	phxsec_bignum_t Y;			/* Public value, in (PHXSEC_DH_SHARED), out (PHXSEC_DH_PUBLIC) */
+	phxsec_bignum_t X;			/* Secret value, in (PHXSEC_DH_SHARED), out (PHXSEC_DH_PUBLIC) */
+	phxsec_bignum_t K;			/* Shared secret value, out (PHXSEC_DH_SHARED) */
+	phxsec_bignum_t N;			/* Modulus, in (PHXSEC_DH_SHARED), out (PHXSEC_DH_PUBLIC) */
+	phxsec_bignum_t G;			/* Generator, in (PHXSEC_DH_PUBLIC) */
+} phxsec_DH_op_t, *phxsec_DH_op_pt;
+
+
+/*
+ * RSA parameter type definition.
+ */
+typedef struct phxsec_RSA_Params_t
+{
+	uint64_t data_in;			/* InputKeyInfo - Input data. */
+	uint64_t data_out;			/* OutputKeyInfo - Output data. */
+	unsigned short data_in_len;
+	unsigned short data_out_len;
+	phxsec_bignum_t constant;	/* RMI: Montgomery Product */
+	phxsec_bignum_t modulus;	/* ModN - Modulo N value to be applied */
+	phxsec_bignum_t exponent;	/* ExpE - BaseG value to be applied. */
+} phxsec_RSA_op_t, *phxsec_RSA_op_pt;
+
+
+typedef enum
+{
+	PHX_PUBKEY_DH_PUBLIC = 1,
+	PHX_PUBKEY_DH_SHARED,
+	PHX_PUBKEY_RSA_PUBLIC,
+	PHX_PUBKEY_RSA_PRIVATE
+} PHX_PUBKEY_CMD;
+
+typedef enum
+{
+	PHX_ECC_NOP = 0,
+	PHX_ECC_MUL,
+	PHX_ECC_ADD,
+	PHX_ECC_DBL,
+	PHX_ECC_VFY,
+	PHX_ECC_BIN = 0x8,
+	PHX_ECC_BIN_MUL,
+	PHX_ECC_FIELD = 0x10,
+	PHX_ECC_FIELD_BIN_INV,
+	PHX_ECC_FIELD_BIN_MUL,
+	PHX_ECC_FIELD_BIN_ADD,
+	PHX_ECC_FIELD_ADD,
+	PHX_ECC_FIELD_SUB,
+	PHX_ECC_FIELD_MUL,
+	PHX_ECC_FIELD_INV,
+	PHX_ECC_FIELD_DIV,
+	PHX_ECC_FIELD_RED
+} PHX_ECC_OP;
+
+typedef enum
+{
+	PHX_ECC_LOAD = 0
+} PHX_ECC_DEG;
+/*
+ * ECC parameter type definition.
+ */
+typedef struct phxsec_ECC_Params_t
+{
+	PHX_ECC_OP op;
+	int degree;
+	uint64_t data_in;			/* InputKeyInfo - Input data. */
+	uint64_t data_out;			/* OutputKeyInfo - Output data. */
+	unsigned short data_in_len;
+	unsigned short data_out_len;
+	phxsec_bignum_t x;			/* input point x coordinate */
+	phxsec_bignum_t y;			/* input point y coordinate */
+	phxsec_bignum_t x2;			/* input point x coordinate */
+	phxsec_bignum_t y2;			/* input point y coordinate */
+	phxsec_bignum_t a;			/* curve parameter a */
+	phxsec_bignum_t b;			/* curve parameter b */
+	phxsec_bignum_t k;			/* scalar */
+	phxsec_bignum_t n;			/* order of the generator */
+	phxsec_bignum_t c;			/* RMI: Montgomery Product */
+	phxsec_bignum_t r_x;		/* output point x coordinate */
+	phxsec_bignum_t r_y;		/* output point y coordinate */
+	unsigned int result;
+} phxsec_ECC_op_t, *phxsec_ECC_op_pt;
+
+/* 
+ * Generic key command parameters
+ */
+typedef union phxsec_pubkey_u
+{
+	phxsec_DH_op_t DH_params;	/* DH parameters  */
+	phxsec_RSA_op_t RSA_params;	/* RSA Parameters */
+	phxsec_ECC_op_t ECC_params;	/* ECC parameters */
+} phxsec_pubkey_t;
+typedef phxsec_pubkey_t *phxsec_pubkey_pt;
+
+
+/*
+ * Key setup ioctl
+ */
+typedef struct phxsec_key_io_s
+{
+	unsigned int command;
+	unsigned int result_status;
+	unsigned int command_context;	/* Context (ID) of this command). */
+	unsigned int time_us;
+	unsigned int user_context[2];	/* usable for anything by caller */
+	phxsec_pubkey_t key;
+} phxsec_key_io_t;
+
+typedef phxsec_key_io_t *phxsec_key_io_pt;
+
+int phxsec_CipherDigestUserOp(void *ctx, phxsec_io_pt op);
+int phxsec_PublicKeyUserOp(void *ctx, phxsec_key_io_pt op);
+int phxsec_ecc(void *ctx, phxsec_key_io_pt op);
+
+/* this initializes CryptoAPI interface */
+int phxcrypto_init(void *ctx);
+
+/* these functions are used by the CryptoAPI to alloc/dealloc descriptors */
+void *phxsec_AllocateDescriptor(void *ctx);
+int phxsec_FreeDescriptor(void *ctx, void *desc);
+
+/* this is used by the CryptoAPI to fill in descriptors */
+phxsec_error_t phxsec_FillDescriptor(phxsec_io_pt op, void *desc,
+									 unsigned int *cfg_vector);
+
+/* this is passed to packet setup to optimize */
+#define PHX_SETUP_OP_CIPHER              0x00000001
+#define PHX_SETUP_OP_HMAC                0x00000002
+#define PHX_SETUP_OP_CIPHER_HMAC         (PHX_SETUP_OP_CIPHER | PHX_SETUP_OP_HMAC)
+/* this is passed to control_setup to update w/preserving existing keys */
+#define PHX_SETUP_OP_PRESERVE_HMAC_KEY    0x80000000
+#define PHX_SETUP_OP_PRESERVE_CIPHER_KEY  0x40000000
+#define PHX_SETUP_OP_UPDATE_KEYS          0x00000010
+#define PHX_SETUP_OP_FLIP_3DES_KEY        0x00000020
+
+/* this sets up per-packet descriptor */
+phxsec_error_t phxsec_SetupDescriptor(phxsec_io_pt op, unsigned int flags,
+									  void *desc, unsigned int vector);
+
+/* this processes the packet */
+int phxsec_ProcessPacket(void *ctx, void *desc, unsigned int cfg_vector);
+
+/* debugging function */
+void phxsec_DecodeDescriptor(void *desc, unsigned int cfg_vector);
+
+#endif /* _PHXSEC_H_ */
diff --git a/drivers/char/rmisec/phxdrv/proc.c b/drivers/char/rmisec/phxdrv/proc.c
new file mode 100644
index 0000000..a0f04df
--- /dev/null
+++ b/drivers/char/rmisec/phxdrv/proc.c
@@ -0,0 +1,449 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/crypto.h>
+#include <linux/proc_fs.h>
+#include "linux/seq_file.h"
+#include <linux/mm.h>
+#include <linux/timer.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+
+#include "../linux/rmisec.h"
+#include "phxdesc.h"
+#include "phxsec.h"
+#include "phxdrv.h"
+
+#include <asm/rmi/user/phnx_user_mac.h>
+extern struct user_mac_data *user_mac;
+
+struct proc_dir_entry *proc_rmisec_control, *proc_rmisec_stats,
+	*proc_rmisec_speed;
+
+static rmisec_stats_t stats;
+
+static struct timer_list rmisec_speed_timer;
+static rmisec_stats_t stats_last;
+static rmisec_stats_t stats_now;
+static rmisec_stats_t stats_speed;
+
+static void *r_start(struct seq_file *m, loff_t * pos)
+{
+	if (*pos == 1) {
+		return 0;
+	}
+	return m->private;
+}
+
+static void *r_next(struct seq_file *m, void *v, loff_t * pos)
+{
+	(*pos)++;
+	if (*pos == 1) {
+		return 0;
+	}
+	return m->private;
+}
+
+static void r_stop(struct seq_file *m, void *v)
+{
+	if (m->private) {
+		kfree(m->private);
+		m->private = 0;
+	}
+}
+
+static int r_show(struct seq_file *m, void *v)
+{
+	rmisec_stats_t *p = v;
+    seq_printf(m,"RMISEC Statistics:\n\n");
+    seq_printf(m,"\ttime: hi:                %-8u  \tlo:                      %u\n",
+                 user_mac ? user_mac->time.hi : 0,user_mac ? user_mac->time.lo : 0),
+    seq_printf(m,"\tStats Mask:              %08x  \tControl Mask:            %08x\n\n",
+                 p->stats_mask,p->control_mask);
+    seq_printf(m, "\tWait Count:     %-8u  Wait Cycles :  %-8llu Max: %-8u\n\n",
+	       p->wait_count, p->wait_time, p->max_wait_time);
+    seq_printf(m, "\tMax MsgSend Wait Time:     %-8u\n\n",
+	       p->maxsnd_wait_time);
+    seq_printf(m,"HMAC:\n\n");
+    seq_printf(m,"\tmd5_count:               %-10lu\tmd5_bytes:               %llu\n",
+                 p->hmac.md5_count, p->hmac.md5_bytes);
+    seq_printf(m,"\tsha1_count:              %-10lu\tsha1_bytes:              %llu\n",
+                 p->hmac.sha1_count, p->hmac.sha1_bytes);
+    seq_printf(m,"\tsha256_count:            %-10lu\tsha256_bytes:            %llu\n",
+                 p->hmac.sha256_count, p->hmac.sha256_bytes);
+    seq_printf(m,"\tsha384_count:            %-10lu\tsha384_bytes:            %llu\n",
+                 p->hmac.sha384_count, p->hmac.sha384_bytes);
+    seq_printf(m,"\tsha512_count:            %-10lu\tsha512_bytes:            %llu\n",
+                 p->hmac.sha512_count, p->hmac.sha512_bytes);
+    seq_printf(m,"\tgcm_count:               %-10lu\tgcm_bytes:               %llu\n",
+                 p->hmac.gcm_count, p->hmac.gcm_bytes);
+    seq_printf(m,"\tkasumi_f9_count:         %-10lu\tkasumi_f9_bytes:         %llu\n",
+                 p->hmac.kasumi_f9_count, p->hmac.kasumi_f9_bytes);
+    seq_printf(m,"\treverts:                 %-10lu\treverts_bytes:           %llu\n\n",
+                 p->hmac.reverts, p->hmac.reverts_bytes);
+    seq_printf(m,"CIPHER:\n\n");
+    seq_printf(m,"\tdes_encrypts:            %-10lu\tdes_encrypt_bytes:       %llu\n",
+                 p->cipher.des_encrypts, p->cipher.des_encrypt_bytes);
+    seq_printf(m,"\tdes_decrypts:            %-10lu\tdes_decrypt_bytes:       %llu\n",
+                 p->cipher.des_decrypts, p->cipher.des_decrypt_bytes);
+    seq_printf(m,"\tdes3_encrypts:           %-10lu\tdes3_encrypt_bytes:      %llu\n",
+                 p->cipher.des3_encrypts, p->cipher.des3_encrypt_bytes);
+    seq_printf(m,"\tdes3_decrypts:           %-10lu\tdes3_decrypt_bytes:      %llu\n",
+                 p->cipher.des3_decrypts, p->cipher.des3_decrypt_bytes);
+    seq_printf(m,"\taes_encrypts:            %-10lu\taes_encrypt_bytes:       %llu\n",
+                 p->cipher.aes_encrypts, p->cipher.aes_encrypt_bytes);
+    seq_printf(m,"\taes_decrypts:            %-10lu\taes_decrypt_bytes:       %llu\n",
+                 p->cipher.aes_decrypts, p->cipher.aes_decrypt_bytes);
+    seq_printf(m,"\tarc4_encrypts:           %-10lu\tarc4_encrypt_bytes:      %llu\n",
+                 p->cipher.arc4_encrypts, p->cipher.arc4_encrypt_bytes);
+    seq_printf(m,"\tarc4_decrypts:           %-10lu\tarc4_decrypt_bytes:      %llu\n",
+                 p->cipher.arc4_decrypts, p->cipher.arc4_decrypt_bytes);
+    seq_printf(m,"\tkasumi_f8_encrypts:      %-10lu\tkasumi_f8_encrypt_bytes: %llu\n",
+                 p->cipher.kasumi_f8_encrypts, p->cipher.kasumi_f8_encrypt_bytes);
+    seq_printf(m,"\tkasumi_f8_decrypts:      %-10lu\tkasumi_f8_decrypt_bytes: %llu\n",
+                 p->cipher.kasumi_f8_decrypts, p->cipher.kasumi_f8_decrypt_bytes);
+    seq_printf(m,"\treverts:                 %-10lu\treverts_bytes:           %llu\n\n",
+                 p->cipher.reverts, p->cipher.reverts_bytes);
+    seq_printf(m,"MODEXP:\n\n");
+    seq_printf(m,"\tmod_exp_512s:            %-10lu\tmod_exp_1024s:           %lu\n\n",
+                 p->modexp.modexp_512s, p->modexp.modexp_1024s);
+    seq_printf(m,"ECC:\n\n");
+    seq_printf(m,"\tbin_mul:                 %-10lu\tmul:                     %lu\n",
+                 p->ecc.ecc_bin_mul, p->ecc.ecc_mul);
+    seq_printf(m,"\tadd:                     %-10lu\tdbl:                     %lu\n",
+                 p->ecc.ecc_add, p->ecc.ecc_dbl);
+    seq_printf(m,"\tvfy:                     %-10lu\tfield_bin_inv:           %lu\n",
+                 p->ecc.ecc_vfy, p->ecc.ecc_field_bin_inv);
+    seq_printf(m,"\tfield_bin_mul:           %-10lu\tfield_bin_add:           %lu\n",
+                 p->ecc.ecc_field_bin_mul, p->ecc.ecc_field_bin_add);
+    seq_printf(m,"\tfield_add:               %-10lu\tfield_sub:               %lu\n",
+                 p->ecc.ecc_field_add, p->ecc.ecc_field_sub);
+    seq_printf(m,"\tfield_mul:               %-10lu\tfield_inv:               %lu\n",
+                 p->ecc.ecc_field_mul, p->ecc.ecc_field_inv);
+    seq_printf(m,"\tfield_div:               %-10lu\tfield_red:               %lu\n",
+                 p->ecc.ecc_field_div, p->ecc.ecc_field_red);
+    seq_printf(m,"\tfail:                    %-10lu\n\n",
+                 p->opt.ecc_failed);
+    seq_printf(m,"OPT:\n\n");
+    seq_printf(m,"\tunaligned_auth_dest:     %-10lu\tcombined ops:            %lu\n\n",
+                 p->opt.unaligned_auth_dest, p->opt.combined);
+    seq_printf(m,"\tsym_failures:            %-10lu\tmodexp_failures:         %lu\n",
+                 p->opt.sym_failed, p->opt.modexp_failed);
+
+	return 0;
+}
+
+static struct seq_operations proc_rmisec_stats_op = {
+	.start = r_start,
+	.next = r_next,
+	.stop = r_stop,
+	.show = r_show,
+};
+
+static int proc_rmisec_stats_open(struct inode *inode, struct file *file)
+{
+	int res;
+	struct seq_file *m;
+	rmisec_stats_t *p;
+
+	res = seq_open(file, &proc_rmisec_stats_op);
+	if (!res) {
+		m = file->private_data;
+		p = kmalloc(sizeof(rmisec_stats_t), GFP_KERNEL);
+		if (!p)
+			return -ENOMEM;
+		read_lock(&stats.rmisec_stats_lock);
+		*p = stats;
+		read_unlock(&stats.rmisec_stats_lock);
+		m->private = p;
+	}
+	return res;
+}
+
+static ssize_t write_rmisec_stats(struct file *file,
+								  const char __user * buffer, size_t buflen,
+								  loff_t * fpos)
+{
+	/* clear stats */
+	write_lock(&stats.rmisec_stats_lock);
+	memset(&stats.clear_start, '\0',
+		   sizeof(rmisec_stats_t) - ((char *) &stats.clear_start 
+				   - (char *) &stats));
+	write_unlock(&stats.rmisec_stats_lock);
+
+	return buflen;
+}
+
+static struct file_operations proc_rmisec_stats_operations = {
+	.open = proc_rmisec_stats_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release,
+	.write = write_rmisec_stats,
+};
+
+static struct seq_operations proc_rmisec_speed_op = {
+	.start = r_start,
+	.next = r_next,
+	.stop = r_stop,
+	.show = r_show,
+};
+
+static int proc_rmisec_speed_open(struct inode *inode, struct file *file)
+{
+	int res;
+	struct seq_file *m;
+	rmisec_stats_t *p;
+
+	res = seq_open(file, &proc_rmisec_speed_op);
+	if (!res) {
+		m = file->private_data;
+		p = kmalloc(sizeof(rmisec_stats_t), GFP_KERNEL);
+		if (!p)
+			return -ENOMEM;
+		read_lock(&stats.rmisec_stats_lock);
+		*p = stats_speed;
+		read_unlock(&stats.rmisec_stats_lock);
+		m->private = p;
+	}
+	return res;
+}
+
+static struct file_operations proc_rmisec_speed_operations = {
+	.open = proc_rmisec_speed_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release,
+};
+
+static int open_rmisec_control(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static ssize_t read_rmisec_control(struct file *file, char __user * buffer,
+								   size_t buflen, loff_t * fpos)
+{
+	return 0;
+}
+
+#define RMISEC_CONTROL_COMMAND_STATSMASK "statsmask"
+#define RMISEC_CONTROL_COMMAND_CONTROLMASK "controlmask"
+#define RMISEC_CONTROL_COMMAND_RESET "reset"
+
+extern int phxcrypto_verbosity;
+
+static ssize_t write_rmisec_control(struct file *file,
+									const char __user * buffer,
+									size_t buflen, loff_t * fpos)
+{
+	char command[256], *p;
+	unsigned int mask;
+
+	printk("write_rmisec_control\n");
+	if (buflen > (sizeof(command) - 1))
+		return -EFAULT;
+
+	if (copy_from_user(command, buffer, sizeof(command)))
+		return -EFAULT;
+
+	if (command[buflen - 1] == 0x0a)
+		command[buflen - 1] = 0;
+	else
+		command[buflen] = 0;
+
+	printk("write_rmisec_control: %d bytes command (%s)\n", (int) buflen,
+		   command);
+
+	if (!strncmp(command,
+				 RMISEC_CONTROL_COMMAND_STATSMASK,
+				 sizeof(RMISEC_CONTROL_COMMAND_STATSMASK) - 1)) {
+		p = command + sizeof(RMISEC_CONTROL_COMMAND_STATSMASK) - 1;
+		while (*p == ' ')
+			p++;
+		if (sscanf(p, "%x", &mask) < 1)
+			return 0;
+		printk("stats mask extracted %x\n", mask);
+		write_lock(&stats.rmisec_stats_lock);
+		stats.stats_mask = mask;
+		write_unlock(&stats.rmisec_stats_lock);
+		return buflen;
+	}
+
+	if (!strncmp(command,
+				 RMISEC_CONTROL_COMMAND_RESET,
+				 sizeof(RMISEC_CONTROL_COMMAND_RESET) - 1)) {
+		phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_SECURITY_OFFSET);
+		phoenix_write_reg(mmio, 0x0000, 0xFF);	//      SEC_PIPE0_STATE0
+		phoenix_write_reg(mmio, 0x0040, 0xFF);	//      SEC_PIPE1_STATE0
+		phoenix_write_reg(mmio, 0x0080, 0xFF);	//      SEC_PIPE2_STATE0
+		phoenix_write_reg(mmio, 0x00c0, 0xFF);	//      SEC_PIPE3_STATE0
+		phoenix_write_reg(mmio, 0x0130, 0x3F);	//      RSA_PIPE0_STATE0
+		phoenix_write_reg(mmio, 0x01a0, 0x3F);	//      SEC_STATE0
+		printk("reset the security engines\n");
+		return buflen;
+	}
+
+	if (!strncmp(command,
+				 RMISEC_CONTROL_COMMAND_CONTROLMASK,
+				 sizeof(RMISEC_CONTROL_COMMAND_CONTROLMASK) - 1)) {
+		p = command + sizeof(RMISEC_CONTROL_COMMAND_CONTROLMASK) - 1;
+		while (*p == ' ')
+			p++;
+		if (sscanf(p, "%x", &mask) < 1)
+			return 0;
+		printk("control mask extracted %x\n", mask);
+		write_lock(&stats.rmisec_control_lock);
+		stats.control_mask = mask;
+		if (mask & PHXDRV_CONTROL_VVERBOSE)
+			phxcrypto_verbosity = PHXDRV_VERY_VERBOSE;
+		else if (mask & PHXDRV_CONTROL_VERBOSE)
+			phxcrypto_verbosity = PHXDRV_VERBOSE;
+		else if (mask & PHXDRV_CONTROL_SILENT)
+			phxcrypto_verbosity = PHXDRV_SILENT;
+		else
+			phxcrypto_verbosity = PHXDRV_NORMAL;
+		write_unlock(&stats.rmisec_control_lock);
+		return buflen;
+	}
+
+	return buflen;
+}
+
+struct file_operations proc_rmisec_control_operations = {
+	.read = read_rmisec_control,
+	.open = open_rmisec_control,
+	.write = write_rmisec_control,
+};
+
+#define RMISEC_SPEED(field) \
+  if (stats_now.field - stats_last.field > stats_speed.field) \
+  stats_speed.field = stats_now.field - stats_last.field
+static void rmisec_speed_compute(long unsigned int unused)
+{
+	stats_now = stats;
+	RMISEC_SPEED(hmac.md5_count);
+	RMISEC_SPEED(hmac.md5_bytes);
+	RMISEC_SPEED(hmac.sha1_count);
+	RMISEC_SPEED(hmac.sha1_bytes);
+	RMISEC_SPEED(hmac.sha256_count);
+	RMISEC_SPEED(hmac.sha256_bytes);
+	RMISEC_SPEED(hmac.sha384_count);
+	RMISEC_SPEED(hmac.sha384_bytes);
+	RMISEC_SPEED(hmac.sha512_count);
+	RMISEC_SPEED(hmac.sha512_bytes);
+	RMISEC_SPEED(hmac.gcm_count);
+	RMISEC_SPEED(hmac.gcm_bytes);
+	RMISEC_SPEED(hmac.kasumi_f9_count);
+	RMISEC_SPEED(hmac.kasumi_f9_bytes);
+	RMISEC_SPEED(hmac.reverts);
+	RMISEC_SPEED(hmac.reverts_bytes);
+	RMISEC_SPEED(cipher.des_encrypts);
+	RMISEC_SPEED(cipher.des_encrypt_bytes);
+	RMISEC_SPEED(cipher.des_decrypts);
+	RMISEC_SPEED(cipher.des_decrypt_bytes);
+	RMISEC_SPEED(cipher.des3_encrypts);
+	RMISEC_SPEED(cipher.des3_encrypt_bytes);
+	RMISEC_SPEED(cipher.des3_decrypts);
+	RMISEC_SPEED(cipher.des3_decrypt_bytes);
+	RMISEC_SPEED(cipher.aes_encrypts);
+	RMISEC_SPEED(cipher.aes_encrypt_bytes);
+	RMISEC_SPEED(cipher.aes_decrypts);
+	RMISEC_SPEED(cipher.aes_decrypt_bytes);
+	RMISEC_SPEED(cipher.arc4_encrypts);
+	RMISEC_SPEED(cipher.arc4_encrypt_bytes);
+	RMISEC_SPEED(cipher.arc4_decrypts);
+	RMISEC_SPEED(cipher.arc4_decrypt_bytes);
+	RMISEC_SPEED(cipher.kasumi_f8_encrypts);
+	RMISEC_SPEED(cipher.kasumi_f8_encrypt_bytes);
+	RMISEC_SPEED(cipher.kasumi_f8_decrypts);
+	RMISEC_SPEED(cipher.kasumi_f8_decrypt_bytes);
+	RMISEC_SPEED(cipher.reverts);
+	RMISEC_SPEED(cipher.reverts_bytes);
+	RMISEC_SPEED(modexp.modexp_512s);
+	RMISEC_SPEED(modexp.modexp_1024s);
+	RMISEC_SPEED(ecc.ecc_bin_mul);
+	RMISEC_SPEED(ecc.ecc_mul);
+	RMISEC_SPEED(ecc.ecc_add);
+	RMISEC_SPEED(ecc.ecc_dbl);
+	RMISEC_SPEED(ecc.ecc_vfy);
+	RMISEC_SPEED(ecc.ecc_field_bin_inv);
+	RMISEC_SPEED(ecc.ecc_field_bin_mul);
+	RMISEC_SPEED(ecc.ecc_field_bin_add);
+	RMISEC_SPEED(ecc.ecc_field_add);
+	RMISEC_SPEED(ecc.ecc_field_sub);
+	RMISEC_SPEED(ecc.ecc_field_mul);
+	RMISEC_SPEED(ecc.ecc_field_inv);
+	RMISEC_SPEED(ecc.ecc_field_div);
+	RMISEC_SPEED(ecc.ecc_field_red);
+	RMISEC_SPEED(opt.ecc_failed);
+	RMISEC_SPEED(opt.unaligned_auth_dest);
+	RMISEC_SPEED(opt.combined);
+	RMISEC_SPEED(opt.sym_failed);
+	RMISEC_SPEED(opt.modexp_failed);
+	stats_last = stats_now;
+	rmisec_speed_timer.expires = jiffies + HZ;
+	add_timer(&rmisec_speed_timer);
+}
+
+rmisec_stats_pt phxdrv_proc_init(void)
+{
+	proc_rmisec_stats = create_proc_entry("rmisec_stats", S_IRUSR, NULL);
+	proc_rmisec_speed = create_proc_entry("rmisec_speed", S_IRUSR, NULL);
+	proc_rmisec_control = create_proc_entry("rmisec_control", S_IRUSR, NULL);
+
+	if (proc_rmisec_control) {
+		proc_rmisec_control->proc_fops = &proc_rmisec_control_operations;
+	}
+
+	if (proc_rmisec_stats) {
+		proc_rmisec_stats->proc_fops = &proc_rmisec_stats_operations;
+	}
+
+	if (proc_rmisec_speed) {
+		proc_rmisec_speed->proc_fops = &proc_rmisec_speed_operations;
+	}
+
+	stats.stats_mask = (unsigned int) -1;
+	stats.control_mask = (unsigned int) -1;
+	stats.rmisec_stats_lock = RW_LOCK_UNLOCKED;
+	stats.rmisec_control_lock = RW_LOCK_UNLOCKED;
+
+	init_timer(&rmisec_speed_timer);
+	rmisec_speed_timer.function = rmisec_speed_compute;
+	rmisec_speed_timer.data = 0;
+	rmisec_speed_timer.expires = jiffies + HZ;
+	add_timer(&rmisec_speed_timer);
+
+	return &stats;
+}
diff --git a/include/linux/crypto.h b/include/linux/crypto.h
index c43dc47..a6fb8c4 100644
--- a/include/linux/crypto.h
+++ b/include/linux/crypto.h
@@ -48,6 +48,8 @@
 #define CRYPTO_ALG_DYING		0x00000040
 #define CRYPTO_ALG_ASYNC		0x00000080
 
+#define CRYPTO_ALG_HW                   0x00000100
+
 /*
  * Set this bit if and only if the algorithm requires another algorithm of
  * the same type to handle corner cases.
@@ -268,6 +270,9 @@ struct digest_alg {
 	void (*dia_final)(struct crypto_tfm *tfm, u8 *out);
 	int (*dia_setkey)(struct crypto_tfm *tfm, const u8 *key,
 	                  unsigned int keylen);
+	int (*dia_hw_digest)(void* ctx, struct scatterlist *sg, unsigned int nsg, u8* out);
+	int (*dia_hw_hmac)(void* ctx, u8* key, unsigned int* keylen,
+                            struct scatterlist *sg, unsigned int nsg, u8* out);
 };
 
 struct hash_alg {
-- 
1.6.0.4

