From d87d6014db66d74a364cd6057d3ad92bc80eea77 Mon Sep 17 00:00:00 2001
From: Zhang Xiao <xiao.zhang@windriver.com>
Date: Fri, 22 Jul 2011 15:02:26 +0800
Subject: [PATCH 1/2] Enable workaround for silicon errata 10409.1

Signed-off-by: Zhang Xiao <xiao.zhang@windriver.com>
---
 arch/mips/Makefile                 |    2 +
 include/asm-mips/rmi/rmi_rw_lock.h |  109 ++++++++++++++++++++++++++++++++++++
 2 files changed, 111 insertions(+), 0 deletions(-)

diff --git a/arch/mips/Makefile b/arch/mips/Makefile
index a19cd32..61efce1 100644
--- a/arch/mips/Makefile
+++ b/arch/mips/Makefile
@@ -149,6 +149,8 @@ cflags-$(CONFIG_CPU_R4000_WORKAROUNDS)	+= $(call cc-option,-mfix-r4000,)
 cflags-$(CONFIG_CPU_R4400_WORKAROUNDS)	+= $(call cc-option,-mfix-r4400,)
 cflags-$(CONFIG_CPU_DADDI_WORKAROUNDS)	+= $(call cc-option,-mno-daddi,)
 
+cflags-$(CONFIG_CPU_PHOENIX)	+= -DRMI_BRIDGE_WKAROUND
+
 ifdef CONFIG_CPU_SB1
 ifdef CONFIG_SB1_PASS_1_WORKAROUNDS
 MODFLAGS	+= -msb1-pass1-workarounds
diff --git a/include/asm-mips/rmi/rmi_rw_lock.h b/include/asm-mips/rmi/rmi_rw_lock.h
index 9316f31..120b469 100644
--- a/include/asm-mips/rmi/rmi_rw_lock.h
+++ b/include/asm-mips/rmi/rmi_rw_lock.h
@@ -115,3 +115,112 @@ static inline unsigned int rmi_read_lock_irq_save(rmi_rwlock_t *rw)
 
 	rmi_local_irq_save(flags);
 	cpu = rmi_processor_id();
+
+		__asm__ __volatile__(
+		"	.set	noreorder	\n"
+		"1:	ll	%1, %2		\n"
+		"	bltz	%1, 2f		\n"
+		"	 addu	%1, 1		\n"
+		"	sc	%1, %0		\n"
+		"	beqz	%1, 1b		\n"
+		"	 nop			\n"
+		"	.subsection 2		\n"
+		"2:	ll	%1, %2		\n"
+		"	bltz	%1, 2b		\n"
+		"	 addu	%1, 1		\n"
+		"	b	1b		\n"
+		"	 nop			\n"
+		"	.previous		\n"
+		"	.set	reorder		\n"
+		: "=m" (rw->lock), "=&r" (temp)
+		: "m" (rw->lock)
+		: "memory");
+
+		rw->read_cpus[cpu] = 1;
+		rmi_sync();
+
+		return flags;
+}
+
+static inline void rmi_read_unlock_irq_restore(rmi_rwlock_t *rw, 
+			unsigned int flags)
+{
+	unsigned int temp;
+	unsigned int cpu;
+
+	cpu = rmi_processor_id();
+
+	rmi_sync();
+	__asm__ __volatile__(
+		"       .set    noreorder       			\n"
+		"1:     ll      %1, %2                                  \n"
+		"       sub     %1, 1                                   \n"
+		"       sc      %1, %0                                  \n"
+		"       beqz    %1, 2f                                  \n"
+		"        nop                                            \n"
+		"       .subsection 2                                   \n"
+		"2:     b       1b                                      \n"
+		"        nop                                            \n"
+		"       .previous                                       \n"
+		"       .set    reorder                                 \n"
+		: "=m" (rw->lock), "=&r" (temp)
+		: "m" (rw->lock)
+		: "memory");
+	rw->read_cpus[cpu] = 0;
+	rmi_local_irq_restore(flags);
+
+}
+
+static inline unsigned int rmi_write_lock_irq_save(rmi_rwlock_t *rw)
+{
+	unsigned int temp;
+	unsigned int cpu;
+	unsigned int flags;
+
+	rmi_local_irq_save(flags);
+	cpu = rmi_processor_id();
+
+	__asm__ __volatile__(
+		"       .set    noreorder       			\n"
+		"1:     ll      %1, %2                                  \n"
+		"       bnez    %1, 2f                                  \n"
+		"        lui    %1, 0x8000                              \n"
+		"       sc      %1, %0                                  \n"
+		"       beqz    %1, 2f                                  \n"
+		"        nop                                            \n"
+		"       .subsection 2                                   \n"
+		"2:     ll      %1, %2                                  \n"
+		"       bnez    %1, 2b                                  \n"
+		"        lui    %1, 0x8000                              \n"
+		"       b       1b                                      \n"
+		"        nop                                            \n"
+		"       .previous                                       \n"
+		"       .set    reorder                                 \n"
+		: "=m" (rw->lock), "=&r" (temp)
+		: "m" (rw->lock)
+		: "memory");
+
+	rw->write_cpu = cpu;
+	rmi_sync();
+	
+	return flags;
+
+}
+
+
+static inline void rmi_write_unlock_irq_restore(rmi_rwlock_t *rw, 
+						unsigned int flags)
+{
+	rmi_sync();
+
+	__asm__ __volatile__(
+		"       sw      $0, %0                                  \n"
+		: "=m" (rw->lock)
+		: "m" (rw->lock)
+		: "memory");
+	rw->write_cpu = -1;
+	rmi_local_irq_restore(flags);
+}
+
+
+#endif
-- 
1.7.0.4

