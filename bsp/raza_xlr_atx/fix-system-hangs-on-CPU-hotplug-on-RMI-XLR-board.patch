From dc162c6f0422beb58266658a9d9e11e23e113e09 Mon Sep 17 00:00:00 2001
From: Shan Hai <shan.hai@windriver.com>
Date: Thu, 30 Dec 2010 23:40:41 -0800
Subject: [PATCH] fix system hangs on CPU hotplug on RMI XLR board

Lack of enabling IRQs on CPUs in cpu online after offline operaion
causes the kernel hangs on NFS root filesystem, because the cpu failed
to be notified MSGRING interrupts on packet transmission.

Signed-off-by: Shan Hai <shan.hai@windriver.com>
---
 arch/mips/rmi/phoenix/irq.c     |   10 +++++++---
 arch/mips/rmi/phoenix/on_chip.c |    5 +++++
 arch/mips/rmi/phoenix/smp.c     |   24 +++++++++++++++++++-----
 3 files changed, 31 insertions(+), 8 deletions(-)

diff --git a/arch/mips/rmi/phoenix/irq.c b/arch/mips/rmi/phoenix/irq.c
index 6f2e27e..fb0fcff 100644
--- a/arch/mips/rmi/phoenix/irq.c
+++ b/arch/mips/rmi/phoenix/irq.c
@@ -525,10 +525,10 @@ asmlinkage void plat_irq_dispatch(void)
 }
 
 #ifdef CONFIG_HOTPLUG_CPU
-void fixup_irqs(void)
+void fixup_irqs(unsigned int cpu, int flag)
 {
 	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
-	unsigned int irq, cpu = smp_processor_id();
+	unsigned int irq;
 	cpumask_t mask0 = cpumask_of_cpu(0);
 	cpumask_t mycpu = cpumask_of_cpu(cpu);
 	uint32_t hw0_mask, my_mask, hw_mask;
@@ -545,8 +545,12 @@ void fixup_irqs(void)
 		hw_mask = phoenix_read_reg(mmio, PIC_IRT_0_BASE + irq - PIC_IRQ_BASE);
 		if (!hw_mask)
 			continue;
+		
+		if (flag)
+			hw_mask |= my_mask;
+		else	
+			hw_mask &= ~my_mask;
 
-		hw_mask &= ~my_mask;
 		if (!hw_mask)
 			hw_mask |= hw0_mask;
 		phoenix_write_reg(mmio, PIC_IRT_0_BASE + irq - PIC_IRQ_BASE, hw_mask);
diff --git a/arch/mips/rmi/phoenix/on_chip.c b/arch/mips/rmi/phoenix/on_chip.c
index db8fa67..d3f2ad7 100644
--- a/arch/mips/rmi/phoenix/on_chip.c
+++ b/arch/mips/rmi/phoenix/on_chip.c
@@ -647,6 +647,11 @@ void on_chip_shutoff_msgring(void)
 	msgrng_disable(flags);
 }
 
+void on_chip_turnon_msgring(void)
+{
+	enable_msgring_int(NULL);
+}
+
 extern void rmi_reset_gmacs(void);
 void on_chip_init(void)
 {
diff --git a/arch/mips/rmi/phoenix/smp.c b/arch/mips/rmi/phoenix/smp.c
index 7559b52..6aaf7a8 100644
--- a/arch/mips/rmi/phoenix/smp.c
+++ b/arch/mips/rmi/phoenix/smp.c
@@ -49,6 +49,12 @@
 __u32 ipi_3_counter_tx[NR_CPUS][NR_CPUS];
 __u32 ipi_3_counter_rx[NR_CPUS];
 
+#ifdef CONFIG_HOTPLUG_CPU
+extern void on_chip_turnon_msgring(void);
+extern void fixup_irqs(unsigned int cpu, int flag);
+static DEFINE_SPINLOCK(smp_reserve_lock);
+#endif
+
 extern void save_epc(unsigned long *epc);
 extern void smp_call_function_interrupt(void);
 extern void phoenix_smp_time_init(void);
@@ -162,6 +168,18 @@ extern void __cpuinit phoenix_clockevent_init(void);
 void phoenix_smp_finish(void)
 {
 	phoenix_msgring_cpu_init();
+
+#ifdef CONFIG_HOTPLUG_CPU
+	spin_lock(&smp_reserve_lock);
+
+	on_chip_turnon_msgring();
+	/* Enable IRQs on the cpu */
+	local_irq_disable();
+	fixup_irqs(smp_processor_id(), 1);
+	local_irq_enable();
+
+	spin_unlock(&smp_reserve_lock);
+#endif
 }
 
 extern void __init phoenix_smp_init(void);
@@ -290,10 +308,6 @@ void phoenix_prepare_cpus(unsigned int max_cpus)
 
 #ifdef CONFIG_HOTPLUG_CPU
 
-extern void fixup_irqs(void);
-
-static DEFINE_SPINLOCK(smp_reserve_lock);
-
 static int phoenix_cpu_disable(void)
 {
 	unsigned int cpu = smp_processor_id();
@@ -306,7 +320,7 @@ static int phoenix_cpu_disable(void)
 	cpu_clear(cpu, cpu_online_map);
 	cpu_clear(cpu, cpu_callin_map);
 	local_irq_disable();
-	fixup_irqs();
+	fixup_irqs(cpu, 0);
 	local_irq_enable();
 
 	flush_cache_all();
-- 
1.7.0.4

