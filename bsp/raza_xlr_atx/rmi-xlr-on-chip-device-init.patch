From 62a8e408d01b03ab471f0dd5d2724f2d1c1bbf8c Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Tue, 16 Dec 2008 19:07:13 +0800
Subject: [PATCH] rmi xlr on chip device init

RMI XLR on-chip devices init. Including PIC and Fast Message Network.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/mips/rmi/Kconfig                   |   33 ++
 arch/mips/rmi/phoenix/Makefile          |    9 +
 arch/mips/rmi/phoenix/msgring.c         |  301 +++++++++++++++
 arch/mips/rmi/phoenix/msgring_shared.c  |  301 +++++++++++++++
 arch/mips/rmi/phoenix/msgring_xls.c     |  201 ++++++++++
 arch/mips/rmi/phoenix/on_chip.c         |  602 +++++++++++++++++++++++++++++++
 arch/mips/rmi/phoenix/on_chip_devtree.c |  260 +++++++++++++
 7 files changed, 1707 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/rmi/Kconfig
 create mode 100644 arch/mips/rmi/phoenix/Makefile
 create mode 100644 arch/mips/rmi/phoenix/msgring.c
 create mode 100644 arch/mips/rmi/phoenix/msgring_shared.c
 create mode 100644 arch/mips/rmi/phoenix/msgring_xls.c
 create mode 100644 arch/mips/rmi/phoenix/on_chip.c
 create mode 100644 arch/mips/rmi/phoenix/on_chip_devtree.c

diff --git a/arch/mips/rmi/Kconfig b/arch/mips/rmi/Kconfig
new file mode 100644
index 0000000..3fbaaf0
--- /dev/null
+++ b/arch/mips/rmi/Kconfig
@@ -0,0 +1,33 @@
+config RMI_PHOENIX
+	bool 
+
+config PHOENIX_PCIX_GEN_DRIVER
+	bool
+
+config PHOENIX_IP_OVER_PCI
+        bool "Enable IP-Over-Pci Networking Support"
+        depends on RMI_PHOENIX
+	select PHOENIX_PCIX_GEN_DRIVER
+        default n
+
+config PHOENIX_BOOT_OVER_PCI
+        bool "Enable Boot-Over-Pci Support"
+        depends on RMI_PHOENIX
+	select PHOENIX_PCIX_GEN_DRIVER
+        default n
+
+config PHOENIX_CONSOLE_OVER_PCI 
+        bool "Enable Console Over PCI Support"
+        depends on RMI_PHOENIX
+	select PHOENIX_PCIX_GEN_DRIVER
+        default n
+
+config RMI_PHOENIX_LOAD_ADDRESS
+	hex "RMI Linux kernel start address"
+	depends on RMI_PHOENIX
+	default "0xffffffff83400000"
+	help
+	  This is start address for the linux kernel. Default value
+          should be good for most of the applications unless specified 
+          explicitly: e.g. running RMI ToE requires kernel to be linked
+	  at address 0xffffffff86000000.
diff --git a/arch/mips/rmi/phoenix/Makefile b/arch/mips/rmi/phoenix/Makefile
new file mode 100644
index 0000000..dfa2ac1
--- /dev/null
+++ b/arch/mips/rmi/phoenix/Makefile
@@ -0,0 +1,9 @@
+obj-y := irq.o time.o on_chip.o on_chip_devtree.o
+
+obj-y += msgring.o msgring_xls.o msgring_shared.o 
+
+obj-$(CONFIG_PHOENIX_IP_OVER_PCI) += dma.o
+
+obj-$(CONFIG_SMP)		+= smp.o smpboot.o
+
+EXTRA_AFLAGS := $(CFLAGS)
diff --git a/arch/mips/rmi/phoenix/msgring.c b/arch/mips/rmi/phoenix/msgring.c
new file mode 100644
index 0000000..e19548a
--- /dev/null
+++ b/arch/mips/rmi/phoenix/msgring.c
@@ -0,0 +1,301 @@
+/*
+ *  Copyright 2008 Wind River Systems, Inc. 
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <asm/rmi/msgring.h> 
+
+struct bucket_size bucket_sizes = {
+	{
+		 32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  16,  16,  16,  16,  16,  16,  16, 
+		16,  16,  16,  16,  16,  16,  16,   0, 
+		32,  16,  16,  16,  16,  16,  16,  16, 
+		16,  16,  16,  16,  16,  16,  16,   0, 
+		0,  32,  32,  32,  32,  32,   0,  32, 
+		64,  64,  64,  64,   0,   0,   0,   0, 
+		0,  32,   0,  32,   0,   0,   0,   0, 
+		128,   0,   0,   0, 128,   0,   0,   0, 
+	}
+};
+
+struct stn_cc cc_table_cpu_0 = {{
+		
+		{1, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 4 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{0, 2 , 4 , 4 , 4 , 4 , 0 , 2 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 2 , 0 , 2 , 0 , 0 , 0 , 0 },
+		{16, 0 , 0 , 0 , 16 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_cpu_1 = {{
+		
+		{1, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{0, 2 , 4 , 4 , 4 , 4 , 0 , 2 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 2 , 0 , 2 , 0 , 0 , 0 , 0 },
+		{16, 0 , 0 , 0 , 16 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_cpu_2 = {{
+		
+		{1, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{0, 4 , 4 , 4 , 4 , 4 , 0 , 4 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 2 , 0 , 2 , 0 , 0 , 0 , 0 },
+		{16, 0 , 0 , 0 , 16 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_cpu_3 = {{
+		
+		{1, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{0, 4 , 4 , 4 , 4 , 4 , 0 , 4 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 2 , 0 , 2 , 0 , 0 , 0 , 0 },
+		{16, 0 , 0 , 0 , 16 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_cpu_4 = {{
+		
+		{1, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{0, 4 , 4 , 4 , 4 , 4 , 0 , 4 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 4 , 0 , 4 , 0 , 0 , 0 , 0 },
+		{16, 0 , 0 , 0 , 16 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_cpu_5 = {{
+		
+		{1, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{0, 4 , 4 , 4 , 4 , 4 , 0 , 4 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 4 , 0 , 4 , 0 , 0 , 0 , 0 },
+		{16, 0 , 0 , 0 , 16 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_cpu_6 = {{
+		
+		{1, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{0, 4 , 4 , 4 , 4 , 4 , 0 , 4 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 4 , 0 , 4 , 0 , 0 , 0 , 0 },
+		{16, 0 , 0 , 0 , 16 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_cpu_7 = {{
+		
+		{1, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{4, 2 , 2 , 2 , 2 , 2 , 2 , 2 },
+		{2, 2 , 2 , 2 , 2 , 2 , 2 , 0 },
+		{0, 4 , 4 , 4 , 4 , 4 , 0 , 4 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 4 , 0 , 4 , 0 , 0 , 0 , 0 },
+		{16, 0 , 0 , 0 , 16 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_xgs_0 = {{
+		
+		{4, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 4 , 0 , 4 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_xgs_1 = {{
+		
+		{4, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 4 , 0 , 4 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_gmac = {{
+		
+		{8, 8 , 8 , 8 , 16 , 16 , 16 , 16 },
+		{8, 8 , 8 , 8 , 16 , 16 , 16 , 16 },
+		{8, 8 , 8 , 8 , 16 , 16 , 16 , 16 },
+		{8, 8 , 8 , 8 , 16 , 16 , 16 , 16 },
+		{8, 8 , 8 , 8 , 16 , 16 , 16 , 16 },
+		{8, 8 , 8 , 8 , 16 , 16 , 16 , 16 },
+		{8, 8 , 8 , 8 , 16 , 16 , 16 , 16 },
+		{8, 8 , 8 , 8 , 16 , 16 , 16 , 16 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 4 , 0 , 0 , 0 , 0 , 0 , 4 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_dma = {{
+		
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc cc_table_sec = {{
+		
+		{4, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{4, 8 , 8 , 4 , 0 , 0 , 0 , 0 },
+		{4, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{4, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{4, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{4, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{4, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{4, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
diff --git a/arch/mips/rmi/phoenix/msgring_shared.c b/arch/mips/rmi/phoenix/msgring_shared.c
new file mode 100644
index 0000000..2ca1d65
--- /dev/null
+++ b/arch/mips/rmi/phoenix/msgring_shared.c
@@ -0,0 +1,301 @@
+/*
+ *  Copyright 2008 Wind River Systems, Inc. 
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <asm/rmi/msgring.h> 
+
+struct bucket_size shared_bucket_sizes = {
+	{
+		 32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  32,  32,  32,  32,  32,  32,  32, 
+		0,   0,   0,   0,   0,   0,   0,   0, 
+		0,   0,   0,   0,   0,   0,   0,   0, 
+		0,   0,   0,   0,   0,   0,   0,   0, 
+		0,   0,   0,   0,   0,   0,   0,   0, 
+		0,  32,  32,  32,  32,  32,   0,  32, 
+		64,  64,  64,  64,   0,   0,   0,   0, 
+		0,   0,   0,   0,   0,   0,   0,   0, 
+		0,   0,   0,   0,   0,   0,   0,   0, 
+	}
+};
+
+struct stn_cc shared_cc_table_cpu_0 = {{
+		
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 2 , 4 , 4 , 4 , 4 , 0 , 2 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc shared_cc_table_cpu_1 = {{
+		
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 2 , 4 , 4 , 4 , 4 , 0 , 2 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc shared_cc_table_cpu_2 = {{
+		
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 4 , 4 , 4 , 4 , 4 , 0 , 4 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc shared_cc_table_cpu_3 = {{
+		
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 4 , 4 , 4 , 4 , 4 , 0 , 4 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc shared_cc_table_cpu_4 = {{
+		
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 4 , 4 , 4 , 4 , 4 , 0 , 4 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc shared_cc_table_cpu_5 = {{
+		
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 4 , 4 , 4 , 4 , 4 , 0 , 4 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc shared_cc_table_cpu_6 = {{
+		
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 4 , 4 , 4 , 4 , 4 , 0 , 4 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc shared_cc_table_cpu_7 = {{
+		
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 4 , 4 , 4 , 4 , 4 , 0 , 4 },
+		{8, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc shared_cc_table_xgs_0 = {{
+		
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc shared_cc_table_xgs_1 = {{
+		
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc shared_cc_table_gmac = {{
+		
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 16 , 16 , 16 , 16 },
+		{8, 8 , 8 , 8 , 16 , 16 , 16 , 16 },
+		{8, 8 , 8 , 8 , 16 , 16 , 16 , 16 },
+		{8, 8 , 8 , 8 , 16 , 16 , 16 , 16 },
+		{8, 8 , 8 , 8 , 16 , 16 , 16 , 16 },
+		{8, 8 , 8 , 8 , 16 , 16 , 16 , 16 },
+		{8, 8 , 8 , 8 , 16 , 16 , 16 , 16 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 4 , 0 , 0 , 0 , 0 , 0 , 4 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc shared_cc_table_dma = {{
+		
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{4, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc shared_cc_table_sec = {{
+		
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
diff --git a/arch/mips/rmi/phoenix/msgring_xls.c b/arch/mips/rmi/phoenix/msgring_xls.c
new file mode 100644
index 0000000..0683b98
--- /dev/null
+++ b/arch/mips/rmi/phoenix/msgring_xls.c
@@ -0,0 +1,201 @@
+/*
+ *  Copyright 2008 Wind River Systems, Inc. 
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <asm/rmi/msgring.h> 
+
+struct bucket_size xls_bucket_sizes = {
+	{
+		 32,  32,  32,  32,  32,  32,  32,  32, 
+		32,  32,  32,  32,  32,  32,  32,  32, 
+		0,   0,   0,   0,   0,   0,   0,   0, 
+		0,   0,   0,   0,   0,   0,   0,   0, 
+		0,   0,   0,   0,   0,   0,   0,   0, 
+		0,   0,   0,   0,   0,   0,   0,   0, 
+		0,   0,   0,   0,   0,   0,   0,   0, 
+		0,   0,   0,   0,   0,   0,   0,   0, 
+		0,   0,   0,   0,   0,   0,   0,   0, 
+		0,   0,   0,   0,   0,   0,   0,   0, 
+		0,  32,  32,  32,  32,  32,   0,   0, 
+		0,   0,   0,   0,   0,   0,   0,   0, 
+		0,  32,  32,  32,  32,  32,   0,   0, 
+		64,  64,  64,  64,  32,  32,  32,  32, 
+		0,   0,   0,   0,   0,   0,   0,   0, 
+		128, 128,   0,   0,   0,   0,   0,   0, 
+	}
+};
+
+struct stn_cc xls_cc_table_cpu_0 = {{
+		
+		{1, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 8 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 8 , 16 , 16 , 16 , 16 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 8 , 16 , 16 , 16 , 16 , 0 , 0 },
+		{32, 32 , 32 , 32 , 16 , 16 , 16 , 16 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{64, 64 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc xls_cc_table_cpu_1 = {{
+		
+		{1, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 8 , 16 , 16 , 16 , 16 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 8 , 16 , 16 , 16 , 16 , 0 , 0 },
+		{32, 32 , 32 , 32 , 16 , 16 , 16 , 16 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{64, 64 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc xls_cc_table_gmac0 = {{
+		
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 8 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 8 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc xls_cc_table_gmac1 = {{
+		
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{8, 8 , 8 , 8 , 8 , 8 , 8 , 8 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 8 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 8 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc xls_cc_table_dma = {{
+		
+		{4, 4 , 4 , 4 , 4 , 4 , 4 , 4 },
+		{4, 4 , 4 , 2 , 4 , 4 , 4 , 4 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc xls_cc_table_cmp = {{
+		
+		{4, 4 , 4 , 4 , 4 , 4 , 4 , 4 },
+		{4, 4 , 4 , 2 , 4 , 4 , 4 , 4 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc xls_cc_table_pcie = {{
+		
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
+struct stn_cc xls_cc_table_sec = {{
+		
+		{6, 8 , 8 , 8 , 0 , 0 , 0 , 0 },
+		{8, 8 , 8 , 4 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+		{0, 0 , 0 , 0 , 0 , 0 , 0 , 0 },
+	}};
+
diff --git a/arch/mips/rmi/phoenix/on_chip.c b/arch/mips/rmi/phoenix/on_chip.c
new file mode 100644
index 0000000..de493f7
--- /dev/null
+++ b/arch/mips/rmi/phoenix/on_chip.c
@@ -0,0 +1,602 @@
+/*********************************************************************
+
+  Copyright 2003-2006 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+
+#include <asm/rmi/msgring.h>
+#include <asm/rmi/iomap.h>
+#include <asm/rmi/mips-exts.h>
+#include <asm/rmi/debug.h>
+#include <asm/rmi/phnx_user_mac.h>
+#include <asm/rmi/sim.h>
+
+unsigned long phoenix_io_base = (unsigned long)(DEFAULT_PHOENIX_IO_BASE);
+extern int xlr_loader_support;
+extern int xlr_loader_sharedcore;
+extern int xlr_loader_own_gmac;
+extern int xlr_loader_own_dma;
+extern uint32_t dev_tree_en;
+extern void rmi_dev_phoenix_msgring_cpu_init(void);
+extern int rmi_dev_register_msgring_handler(void);
+extern uint32_t rmi_dev_get_int_thread_mask(int irt);
+
+
+#define MSGRNG_CC_INIT_CPU_DEST(conf, dest,cpu)	\
+do {	\
+	msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][0], 0 ); \
+	msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][1], 1 ); \
+	msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][2], 2 ); \
+	msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][3], 3 ); \
+	msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][4], 4 ); \
+	msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][5], 5 ); \
+	msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][6], 6 ); \
+	msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf##cc_table_cpu_##cpu.counters[dest][7], 7 ); \
+} while(0)
+
+/* Initialized CC for cpu 0 to send to all buckets at 0-7 cpus */
+#define MSGRNG_CC_INIT_CPU(conf, cpu)	\
+do {	\
+	MSGRNG_CC_INIT_CPU_DEST(conf,0,cpu);\
+	MSGRNG_CC_INIT_CPU_DEST(conf,1,cpu); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,2,cpu); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,3,cpu); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,4,cpu); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,5,cpu); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,6,cpu); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,7,cpu); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,8,cpu); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,9,cpu); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,10,cpu); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,11,cpu); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,12,cpu); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,13,cpu); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,14,cpu); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,15,cpu); \
+} while (0)
+
+#define MSGRNG_BUCKETSIZE_INIT_CPU(conf, base)	\
+do {	\
+	msgrng_write_bucksize(0, conf##bucket_sizes.bucket[base+0]);  \
+	msgrng_write_bucksize(1, conf##bucket_sizes.bucket[base+1]);  \
+	msgrng_write_bucksize(2, conf##bucket_sizes.bucket[base+2]);  \
+	msgrng_write_bucksize(3, conf##bucket_sizes.bucket[base+3]);  \
+	msgrng_write_bucksize(4, conf##bucket_sizes.bucket[base+4]);  \
+	msgrng_write_bucksize(5, conf##bucket_sizes.bucket[base+5]);  \
+	msgrng_write_bucksize(6, conf##bucket_sizes.bucket[base+6]);  \
+	msgrng_write_bucksize(7, conf##bucket_sizes.bucket[base+7]);  \
+} while(0)
+
+#define XLR_MSG_TBL
+#define XLS_MSG_TBL  xls_
+#define SHARED_XLR_MSG_TBL shared_
+
+#define X_MSGRNG_BUCKETSIZE_INIT_CPU(x,y) MSGRNG_BUCKETSIZE_INIT_CPU(x,y)
+
+
+static __u32  shared_msgring_pop_bucket_mask_array[8];
+static int 	  shared_msgring_pop_num_buckets_array[8];
+uint32_t hard_cpu_online_map = 0;
+uint32_t msgring_global_thread_mask = 0;
+
+void phoenix_msgring_cpu_init(void)
+{
+    int id; 
+    unsigned long flags;
+    int shared_msgring = 0;
+
+	if(dev_tree_en)
+		return rmi_dev_phoenix_msgring_cpu_init();
+
+	id = cpu_logical_map(get_cpu());
+
+    /* if support for loading apps on same core as Linux is enabled */
+    if(xlr_loader_support && xlr_loader_sharedcore) {
+       if (xlr_loader_own_gmac || xlr_loader_own_dma)
+           shared_msgring = 1;
+       else if (!xlr_hybrid_rmios_ipsec()){
+		   put_cpu();
+		   return;
+       }
+    }
+
+    if (shared_msgring) {
+	    shared_msgring_pop_bucket_mask_array[id >> 2] |= ( 1 << (id % 4));
+	    if(shared_msgring_pop_num_buckets_array[id >> 2] < (id % 4) + 1)
+		    shared_msgring_pop_num_buckets_array[id >> 2] = (id % 4) + 1;
+    }
+
+    /* if not thead 0 */
+    if ((id & 0x03)!=0) {
+		put_cpu();
+		return;
+	}
+
+    prom_dbg_msg("Initializing message ring for cpu_%d\n", id);
+
+    msgrng_flags_save(flags);
+
+    /* 
+	 * Message Stations are shared among all threads in a cpu core
+     * Assume, thread 0 on all cores are always active when more than
+     * 1 thread is active in a core
+    */
+    if (is_xls()) {
+	if (id == 0) {
+		X_MSGRNG_BUCKETSIZE_INIT_CPU(XLS_MSG_TBL,0);
+		MSGRNG_CC_INIT_CPU(XLS_MSG_TBL,0);
+	}
+	else if (id == 4) {
+		X_MSGRNG_BUCKETSIZE_INIT_CPU(XLS_MSG_TBL,8);
+		MSGRNG_CC_INIT_CPU(XLS_MSG_TBL,1);
+	}
+    }
+    else {
+       if (shared_msgring) {
+           if (id == 0) {
+               X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,0);
+               MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL,0);
+           }
+           else if (id == 4) {
+               X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,8);
+               MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL,1);
+           }
+           else if (id == 8) {
+               X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,16);
+               MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL,2);
+           }
+           else if (id == 12) {
+               X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,24);
+               MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL,3);
+           }
+           else if (id == 16) {
+               X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,32);
+               MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL,4);
+           }
+           else if (id == 20) {
+               X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,40);
+               MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL,5);
+           }
+           else if (id == 24) {
+               X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,48);
+               MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL,6);
+           }
+           else if (id == 28) {
+               X_MSGRNG_BUCKETSIZE_INIT_CPU(SHARED_XLR_MSG_TBL,56);
+               MSGRNG_CC_INIT_CPU(SHARED_XLR_MSG_TBL,7);
+           }
+       } else {
+           if (id == 0) {
+               X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL,0);
+               MSGRNG_CC_INIT_CPU(XLR_MSG_TBL,0);
+           }
+           else if (id == 4) {
+               X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL,8);
+               MSGRNG_CC_INIT_CPU(XLR_MSG_TBL,1);
+           }
+           else if (id == 8) {
+               X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL,16);
+               MSGRNG_CC_INIT_CPU(XLR_MSG_TBL,2);
+           }
+           else if (id == 12) {
+               X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL,24);
+               MSGRNG_CC_INIT_CPU(XLR_MSG_TBL,3);
+           }
+           else if (id == 16) {
+               X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL,32);
+               MSGRNG_CC_INIT_CPU(XLR_MSG_TBL,4);
+           }
+           else if (id == 20) {
+               X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL,40);
+               MSGRNG_CC_INIT_CPU(XLR_MSG_TBL,5);
+           }
+           else if (id == 24) {
+               X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL,48);
+               MSGRNG_CC_INIT_CPU(XLR_MSG_TBL,6);
+           }
+           else if (id == 28) {
+               X_MSGRNG_BUCKETSIZE_INIT_CPU(XLR_MSG_TBL,56);
+               MSGRNG_CC_INIT_CPU(XLR_MSG_TBL,7);
+           }
+       }
+    }
+    msgrng_flags_restore(flags);
+	put_cpu();
+}
+
+
+struct tx_stn tx_stns[MAX_TX_STNS];
+
+int rxstn_to_txstn_map[128] = {
+	[0 ... 7] = TX_STN_CPU_0,
+	[8 ... 15] = TX_STN_CPU_1,
+	[16 ... 23] = TX_STN_CPU_2,
+	[24 ... 31] = TX_STN_CPU_3,
+	[32 ... 39] = TX_STN_CPU_4,
+	[40 ... 47] = TX_STN_CPU_5,
+	[48 ... 55] = TX_STN_CPU_6,
+	[56 ... 63] = TX_STN_CPU_7,
+	[64 ... 95] = TX_STN_INVALID,
+	[96 ... 103] = TX_STN_GMAC,
+	[104 ... 107] = TX_STN_DMA,
+	[108 ... 111] = TX_STN_INVALID,
+	[112 ... 113] = TX_STN_XGS_0,
+	[114 ... 115] = TX_STN_XGS_1,
+	[116 ... 119] = TX_STN_INVALID,
+	[120 ... 127] = TX_STN_SEC
+};
+
+int xls_rxstn_to_txstn_map[128] = {
+	[0 ... 7] = TX_STN_CPU_0,
+	[8 ... 15] = TX_STN_CPU_1,
+	[16 ... 80] = TX_STN_INVALID,
+	[80 ... 87] = TX_STN_GMAC1,
+	[96 ... 103] = TX_STN_GMAC0,
+	[104 ... 107] = TX_STN_DMA,
+	[108 ... 111] = TX_STN_CMP,
+	[112 ... 115] = TX_STN_INVALID,
+	[116 ... 119] = TX_STN_PCIE,
+	[120 ... 121] = TX_STN_SEC,
+	[122 ... 127] = TX_STN_INVALID,
+};
+
+/* make this a read/write spinlock */
+spinlock_t msgrng_lock;
+static phnx_atomic_t msgring_int_enabled;
+static int msgring_pop_num_buckets;
+static __u32 msgring_pop_bucket_mask;
+int msgring_int_type;
+int msgring_watermark_count;
+static __u32  msgring_thread_mask;
+
+extern int rmi_dev_own_bucket_list_get(int *start, int *end, int *mask);
+int own_bucket_start[8], own_bucket_end[8], own_bucket_mask[8];
+
+
+#ifdef CONFIG_PHOENIX_GMAC_NAPI
+extern int xlr_napi;
+extern int xlr_napi_ready; 
+extern void xlr_napi_rx_schedule(void);
+#endif /* CONFIG_PHOENIX_GMAC_NAPI */
+
+
+void phnx_msgring_config(void)
+{
+	if (xlr_hybrid_user_mac() || xlr_hybrid_user_mac_xgmac()) {
+		msgring_int_type = 0x00;
+		msgring_pop_num_buckets = 4;
+		msgring_pop_bucket_mask = 0x0f;
+	} else {
+
+#ifdef CONFIG_PHOENIX_GMAC_NAPI
+		/* If we use NAPI then we enable queue non-empty interrupt */
+		msgring_int_type = xlr_napi ? 0x01 : 0x02;
+#else
+		msgring_int_type = 0x02;
+#endif /* CONFIG_PHOENIX_GMAC_NAPI */
+
+		msgring_pop_bucket_mask = 0xff;
+		msgring_pop_num_buckets = 8;
+	}
+
+	msgring_watermark_count = 1;
+	msgring_thread_mask = 0x0f;
+
+	if(dev_tree_en)
+		rmi_dev_own_bucket_list_get(own_bucket_start, own_bucket_end, own_bucket_mask);
+
+}
+
+static int __init xlr_msgring_watermark_setup(char *str)
+{
+	if (*str == '=') str++;
+
+	msgring_watermark_count = (int)simple_strtoul(str, NULL, 10);
+
+	return 1;
+}
+
+static int __init xlr_msgring_thread_mask_setup(char *str)
+{
+	if (*str == '=') str++;
+
+	msgring_thread_mask = simple_strtoul(str, NULL, 16);
+	msgring_thread_mask &= 0x0f;
+
+	return 1;
+}
+
+static int __init xlr_complete_msgring_thread_mask_setup(char *str) {
+	if(*str == '=') str++;
+	msgring_global_thread_mask = simple_strtoul(str, NULL, 16);
+	msgring_global_thread_mask &= 0xffffffff;
+	return 1;
+}
+
+__setup("xlr_msgring_watermark=", xlr_msgring_watermark_setup);
+__setup("xlr_msgring_thread_mask=", xlr_msgring_thread_mask_setup);
+__setup("xlr_complete_msgring_thread_mask=", xlr_complete_msgring_thread_mask_setup);
+
+extern void phoenix_cpu_stat_update_msgring_int(void);
+extern void phoenix_cpu_stat_update_msgring_cycles(__u32 cycles);
+extern void phoenix_user_mac_update_time(void);
+
+void msgring_process_rx_msgs(int start_bucket, int end_bucket, __u32 pop_bucket_mask)
+{
+    unsigned int bucket_empty_bm = 0;
+    int bucket=0;
+    int size=0, code=0, rx_stid=0, tx_stid=0;
+    struct msgrng_msg msg;
+    struct tx_stn_handler *handler=0;
+    unsigned int status=0;
+
+
+#ifdef CONFIG_PHOENIX_GMAC_NAPI
+    if (xlr_napi_ready && in_irq()) {
+	  xlr_napi_rx_schedule();
+          return;
+    }
+#endif /* CONFIG_PHOENIX_GMAC_NAPI */
+
+    /* First Drain all the high priority messages */
+	for(;;) {
+
+		bucket_empty_bm = (msgrng_read_status() >> 24) & pop_bucket_mask;
+
+		/* all buckets empty, break*/
+		if (bucket_empty_bm == pop_bucket_mask) break;
+
+		for (bucket=start_bucket; bucket < end_bucket; bucket++) {
+
+			if ((bucket_empty_bm & (1 << bucket)) ||  
+				!((1 << bucket) & pop_bucket_mask))
+				continue;
+
+			status = message_receive(bucket, &size, &code, &rx_stid, &msg);
+			if (status) continue;
+
+			if (is_xls())
+				tx_stid = xls_rxstn_to_txstn_map[rx_stid];
+			else
+				tx_stid = rxstn_to_txstn_map[rx_stid];
+
+			/* TODO: hold a read lock on the handler */
+			handler = &tx_stns[tx_stid].handler;
+			if (!handler->action) {
+				printk("[%s]: No Handler for message from stn_id=%d, bucket=%d, "
+						"size=%d, msg0=%llx, dropping message\n",
+						__func__, tx_stid, bucket, size,
+						(unsigned long long)msg.msg0);
+			}
+			else {
+				(handler->action)(bucket, size, code, rx_stid, &msg, handler->dev_id);
+			}
+		}
+	}
+}
+
+#ifndef CONFIG_PHOENIX_MAC
+__u64 xlr_cp2_exceptions[32];
+struct user_mac_data *user_mac;
+struct xlr_user_mac_config xlr_user_mac;
+void phoenix_cpu_stat_update_msgring_int(void) { }
+void phoenix_cpu_stat_update_msgring_cycles(__u32 cycles) { }
+void phoenix_user_mac_update_time(void) { }
+#endif /* CONFIG_PHOENIX_MAC */
+
+__u32 msgrng_msg_cycles = 0;
+void phnx_msgring_int_handler(unsigned int irq, struct pt_regs *regs)
+{
+	unsigned long mflags;
+	__u32 cycles = 0;
+
+	if (irq == PIC_TIMER_0_IRQ) {
+		phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+
+		/* msgring timeout interrupt */
+		phnx_inc_counter(MSGRNG_PIC_INT);
+		/* ack the pic */
+#ifdef CONFIG_PHOENIX_GMAC_NAPI
+		if (!xlr_napi)
+                  phoenix_write_reg(mmio, PIC_INT_ACK, (1 << (PIC_TIMER_0_IRQ - PIC_IRQ_BASE)));
+#else
+                phoenix_write_reg(mmio, PIC_INT_ACK, (1 << (PIC_TIMER_0_IRQ - PIC_IRQ_BASE)));
+#endif /* CONFIG_PHOENIX_GMAC_NAPI */
+
+		phoenix_user_mac_update_time();
+	}
+	else {
+		/* normal message ring interrupt */
+		phnx_inc_counter(MSGRNG_INT);
+		phoenix_cpu_stat_update_msgring_int();
+	}
+
+	irq_enter();
+
+	/* TODO: not necessary to disable preemption */
+	msgrng_flags_save(mflags);
+
+	cycles = read_c0_count();
+
+	if(dev_tree_en == 0x0) {
+	if (xlr_loader_support && xlr_loader_sharedcore && xlr_loader_own_gmac) {
+		int core = cpu_logical_map(smp_processor_id()) & ~(0x3);
+		msgring_process_rx_msgs(0, shared_msgring_pop_num_buckets_array[core],
+				shared_msgring_pop_bucket_mask_array[core]);
+	} else if (xlr_loader_support && xlr_loader_sharedcore && xlr_hybrid_rmios_ipsec()) {
+		msgring_process_rx_msgs(0, 1, 1);
+	} else  {
+		msgring_process_rx_msgs(0, msgring_pop_num_buckets, msgring_pop_bucket_mask);
+	}
+	} else {
+		int core = cpu_logical_map(smp_processor_id())/4;
+		msgring_process_rx_msgs(own_bucket_start[core], own_bucket_end[core], own_bucket_mask[core]);
+	}
+
+	phoenix_cpu_stat_update_msgring_cycles(read_c0_count()-cycles);
+
+	msgrng_flags_restore(mflags);
+
+	/* Call the msg callback */
+	irq_exit();
+}
+
+static void enable_msgring_int(void *info)
+{
+	unsigned long flags = 0, mflags=0;
+	unsigned int th_mask;
+	unsigned int core;
+	msgrng_access_save(&msgrng_lock, flags, mflags);
+
+	core = hard_smp_processor_id() & ~(0x3);
+	th_mask = (msgring_global_thread_mask >> core) & 0x0f;
+
+	/* enable the message ring interrupts */
+	msgrng_write_config((msgring_watermark_count<<24)|(IRQ_MSGRING<<16)
+			    |(th_mask<<8)|msgring_int_type);
+	msgrng_access_restore(&msgrng_lock, flags, mflags);
+}
+
+extern spinlock_t phnx_pic_lock;
+int register_msgring_handler(int major,
+			     void (*action)(int, int,int,int,struct msgrng_msg *, void *),
+			     void *dev_id)
+{
+	struct tx_stn_handler *handler = 0;
+	int ret = 1;
+	unsigned long flags = 0;
+
+
+	if (major >= MAX_TX_STNS) return ret;
+
+	/* Check if the message station is valid, if not return error */
+	spin_lock_irqsave(&msgrng_lock, flags);
+
+	handler = &tx_stns[major].handler;
+
+	if (handler->action) goto out;
+
+	handler->action = action;
+	handler->dev_id = dev_id;
+	
+	ret = 0;
+
+ out:
+	spin_unlock_irqrestore(&msgrng_lock, flags);
+
+	if(dev_tree_en)
+		return rmi_dev_register_msgring_handler();
+  
+	if (!ret && phnx_test_and_set(&msgring_int_enabled)) {
+		phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+		int i=0;
+
+		/* Configure PIC to deliver msgring interrupt for timeouts */
+		hard_cpu_online_map = 0;
+		for (i=0;i<32;i++) {
+			if (cpu_isset(i, cpu_online_map))
+				hard_cpu_online_map |= (1 << cpu_logical_map(i));
+		}
+
+		if(msgring_global_thread_mask == 0) {
+			for(i=0;i<8;i++) {
+				msgring_global_thread_mask |= (msgring_thread_mask << (i<<2));
+			}
+		}
+
+		msgring_global_thread_mask &= hard_cpu_online_map;
+
+		/* configure the msgring interrupt on all cpus */
+		if(!(xlr_loader_support && xlr_loader_sharedcore && xlr_loader_own_gmac))
+			on_each_cpu(enable_msgring_int, 0, 1);
+
+		/* 
+		 * Take an interrupt every 66666 pic cycles(66MHz) i.e 1ms
+		 * it is round robin across 8 cpus cores, so each cpu (assuming all 8 cpu cores
+		 * are active) takes an interrupt every 8ms
+		*/
+		spin_lock_irqsave(&phnx_pic_lock, flags);
+		phoenix_write_reg(mmio, PIC_TIMER_0_MAXVAL_0, 66666);
+		phoenix_write_reg(mmio, PIC_TIMER_0_MAXVAL_1, 0);
+		phoenix_write_reg(mmio, PIC_IRT_0_TIMER_0,
+				  (hard_cpu_online_map & msgring_global_thread_mask));
+		phoenix_write_reg(mmio, PIC_IRT_1_TIMER_0, (1<<31)|(0<<30)|(1<<6)|(PIC_TIMER_0_IRQ));
+		pic_update_control(1<<(8+0));
+		spin_unlock_irqrestore(&phnx_pic_lock, flags);
+	}
+
+	return ret;
+}
+
+static void pic_init(void)
+{
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	int i=0;
+	int level;
+	uint32_t thread_mask = (1 << hard_smp_processor_id());
+
+	for(i=0; i<PIC_NUM_IRTS; i++) {
+
+		level = PIC_IRQ_IS_EDGE_TRIGGERED(i);
+
+		/* Bind all PIC irqs to boot cpu */
+		phoenix_write_reg(mmio, PIC_IRT_0_BASE + i, thread_mask);
+
+		/*
+		 * Use local scheduling and high polarity for all IRTs
+		 * Invalidate all IRTs, by default
+		*/
+		phoenix_write_reg(mmio, PIC_IRT_1_BASE + i, (level<<30)|(1<<6)|(PIC_IRQ_BASE + i));
+	}
+}
+
+atomic_t phnx_counters[NR_CPUS][PHNX_MAX_COUNTERS] __cacheline_aligned;
+
+void on_chip_init(void)
+{
+	int i=0, j=0;
+
+	/* Set phoenix_io_base to the run time value */
+	spin_lock_init(&msgrng_lock);
+
+	msgring_int_enabled.value = 0;
+
+	phnx_msgring_config();
+
+	pic_init();
+
+	phoenix_msgring_cpu_init();
+
+	for(i=0;i<NR_CPUS;i++)
+		for(j=0;j<PHNX_MAX_COUNTERS;j++)
+			atomic_set(&phnx_counters[i][j], 0);
+}
diff --git a/arch/mips/rmi/phoenix/on_chip_devtree.c b/arch/mips/rmi/phoenix/on_chip_devtree.c
new file mode 100644
index 0000000..453d753
--- /dev/null
+++ b/arch/mips/rmi/phoenix/on_chip_devtree.c
@@ -0,0 +1,260 @@
+/*********************************************************************
+
+  Copyright 2003-2008 Raza Microelectronics, Inc. (RMI). All rights
+  reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in
+  the documentation and/or other materials provided with the
+  distribution.
+
+  THIS SOFTWARE IS PROVIDED BY Raza Microelectronics, Inc. ``AS IS'' AND
+  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL RMI OR CONTRIBUTORS BE LIABLE
+  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+  THE POSSIBILITY OF SUCH DAMAGE.
+
+  *****************************#RMI_2#**********************************/
+
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+
+#include <asm/rmi/msgring.h>
+#include <asm/rmi/iomap.h>
+#include <asm/rmi/mips-exts.h>
+#include <asm/rmi/debug.h>
+#include <asm/rmi/phnx_user_mac.h>
+#include <asm/rmi/sim.h>
+
+#define MSGRNG_CC_INIT_CPU_DEST(conf, dest) \
+do { \
+     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf[dest][0], 0 ); \
+     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf[dest][1], 1 ); \
+     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf[dest][2], 2 ); \
+     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf[dest][3], 3 ); \
+     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf[dest][4], 4 ); \
+     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf[dest][5], 5 ); \
+     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf[dest][6], 6 ); \
+     msgrng_write_cc(MSGRNG_CC_##dest##_REG, conf[dest][7], 7 ); \
+} while(0)
+
+/* Initialized CC for cpu 0 to send to all buckets at 0-7 cpus */
+#define MSGRNG_CC_INIT_CPU(conf) \
+do { \
+	MSGRNG_CC_INIT_CPU_DEST(conf,0); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,1); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,2); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,3); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,4); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,5); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,6); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,7); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,8); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,9); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,10); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,11); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,12); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,13); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,14); \
+	MSGRNG_CC_INIT_CPU_DEST(conf,15); \
+} while (0)
+
+#define MSGRNG_BUCKETSIZE_INIT_CPU(conf) \
+do { \
+	msgrng_write_bucksize(0, conf[0]);         \
+	msgrng_write_bucksize(1, conf[1]);         \
+	msgrng_write_bucksize(2, conf[2]);  \
+	msgrng_write_bucksize(3, conf[3]);  \
+	msgrng_write_bucksize(4, conf[4]);  \
+	msgrng_write_bucksize(5, conf[5]);  \
+	msgrng_write_bucksize(6, conf[6]);  \
+	msgrng_write_bucksize(7, conf[7]);  \
+} while(0)
+
+#define XLR_TOT_NUM_STATIONS        128
+#define XLR_CORE_NUM_STATIONS       8
+
+
+static uint32_t cpu_msgring_int_mask[NR_CPUS / 4];
+static uint32_t cpu_msgring_cfgd[NR_CPUS / 4];
+extern int fdt_get_msgring_int_threadmask(int core, uint32_t *mask);
+extern int fdt_get_core_bucket_conf(int core, char buckets[], int bklen, 
+										char credits[][8], int crlen);
+extern int fdt_alloc_pic_timer(uint32_t *mask);
+extern spinlock_t msgrng_lock;
+extern int msgring_int_type, msgring_watermark_count;
+extern spinlock_t phnx_pic_lock;
+static phnx_atomic_t msgring_int_en;
+extern unsigned long phoenix_io_base;
+static uint32_t hard_cpu_online_map;
+
+
+void rmi_dev_phoenix_msgring_cpu_init(void)
+{
+    int id = cpu_logical_map(smp_processor_id());
+	int core;
+	int ret;
+	char buckets[XLR_CORE_NUM_STATIONS + 1];
+	char credits[MAX_TX_STNS][8];
+    unsigned long flags;
+
+	/* get the ownership flags proceed only if this cpu is the owner */
+	core = id / 4;
+	if(cpu_msgring_cfgd[core])
+		return;
+
+	cpu_msgring_cfgd[core] = 1;
+
+	ret = fdt_get_core_bucket_conf(core, buckets, XLR_CORE_NUM_STATIONS, 
+									credits, XLR_TOT_NUM_STATIONS);
+	if(ret < 0) {
+		prom_dbg_msg("DTB:Linux is not the msgring owner for core-%d\n", core);
+		return;
+	}
+    prom_dbg_msg("DTB:Initializing message ring for core-%d\n", core);
+		
+	msgrng_flags_save(flags);
+    MSGRNG_BUCKETSIZE_INIT_CPU(buckets);
+	MSGRNG_CC_INIT_CPU(credits);
+    msgrng_flags_restore(flags);
+	return;
+}
+
+static void rmi_dev_enable_msgring_int(void *info)
+{
+	unsigned long flags = 0, mflags=0;
+    int core = cpu_logical_map(smp_processor_id()) / 4;
+	
+	
+	if(cpu_msgring_int_mask[core] == 0x0)
+			return;
+
+    prom_dbg_msg("DTB:Msgring interrupt therad mask for core%d = 0x%x\n", core, 
+					cpu_msgring_int_mask[core]);
+
+	msgrng_access_save(&msgrng_lock, flags, mflags);
+	/* enable the message ring interrupts */
+	msgrng_write_config((msgring_watermark_count<<24)|(IRQ_MSGRING<<16)
+			    |(cpu_msgring_int_mask[core]<<8)|msgring_int_type);
+	msgrng_access_restore(&msgrng_lock, flags, mflags);  
+
+	return;
+}
+
+
+int rmi_dev_register_msgring_handler(void)
+{
+	int ret = 0, ret_fdt;
+	unsigned long flags = 0;
+	int core, vcpu_idx;
+	uint32_t timer_int_thread_mask  = 0x0, mask = 0x0;
+	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
+	int i=0, timer_id;
+	int core_processed = 0xff;
+
+	for (i=0; i < NR_CPUS ;i++) {
+		if (cpu_isset(i, cpu_online_map)) 
+			hard_cpu_online_map |= (1 << cpu_logical_map(i));
+	}
+
+	if (!ret && phnx_test_and_set(&msgring_int_en)) {
+
+		for (i=0; i < NR_CPUS ;i++) {
+			if (cpu_isset(i, cpu_online_map)) {
+				core = cpu_logical_map(i) / 4;
+				if(core_processed == core)
+					continue;
+				core_processed = core;
+				vcpu_idx = cpu_logical_map(i) % 4;
+					
+				cpu_msgring_int_mask[core] = 0x0;
+
+				ret_fdt = fdt_get_msgring_int_threadmask(core, &mask);
+				if((ret_fdt >= 0) && (mask != 0x0)) {
+					cpu_msgring_int_mask[core] = ( mask & hard_cpu_online_map);
+					timer_int_thread_mask  |= (mask << (core * 4));
+				} else {
+					 /* pass the timer interrupt to the first active thread */
+                    timer_int_thread_mask  |= (1 << vcpu_idx);
+				}
+			}
+		}
+
+		/* configure the msgring interrupt on non shared cpus */
+		on_each_cpu(rmi_dev_enable_msgring_int, 0, 1);
+
+
+		/* 
+		 * Configure PIC to deliver msgring interrupt for timeouts 
+		 * take an interrupt every 66666 pic cycles(66MHz) i.e 1ms 
+		 * it is round robin across 8 cpus cores, so each cpu (assuming all 8 cpu
+		 * cores are active) takes an interrupt every 8ms
+		*/
+		timer_id = fdt_alloc_pic_timer(&mask);
+		if(timer_id == -1)
+			return ret;
+		if(mask != 0x0)
+			timer_int_thread_mask = mask;
+		
+		timer_int_thread_mask &= hard_cpu_online_map;
+
+    	prom_dbg_msg("DTB:Timer interrupt thread mask =  0x%x\n", 
+						timer_int_thread_mask);
+
+		spin_lock_irqsave(&phnx_pic_lock, flags);
+		phoenix_write_reg(mmio, PIC_TIMER_0_MAXVAL_0, 66666);
+		phoenix_write_reg(mmio, PIC_TIMER_0_MAXVAL_1, 0);
+		phoenix_write_reg(mmio, PIC_IRT_0_BASE + timer_id + 1, timer_int_thread_mask);
+		phoenix_write_reg(mmio, PIC_IRT_1_BASE + timer_id + 1, (1<<31) | (0<<30) | 
+							(1<<6) | (PIC_TIMER_0_IRQ));
+		pic_update_control(1 << (8 + 0));
+		spin_unlock_irqrestore(&phnx_pic_lock, flags);
+	}
+  
+	return ret;
+}
+
+#define NR_STATIONS_PER_CPU 8
+#define NR_THREADS_PER_CPU 4
+
+extern int fdt_get_bucketmask(uint64_t *);
+
+int rmi_dev_own_bucket_list_get(int *start, int *end, int *mask)
+{
+	uint64_t bkmask = 0x0;
+	uint16_t bk, core;
+	int sfound = 0, ret = 0x0, i;
+
+	fdt_get_bucketmask(&bkmask);
+
+	for(core = 0x0; core < NR_CPUS / NR_THREADS_PER_CPU ; core++ ) {
+		sfound = 0;
+		bk = (uint16_t)(bkmask >> (core * NR_STATIONS_PER_CPU)) & 0x00ff;
+		for(i = 0x0; i < NR_STATIONS_PER_CPU; i++) {
+			if(!sfound && (bk & (1 << i))) {
+				start[core] = i;
+				sfound = 1;
+			}
+			if((bk & (1 << i)))
+				end[core] = i;
+		}
+		mask[core] = bk;
+		prom_dbg_msg("DTB:Core bucket map for core-%d is 0x%x 0x%x 0x%x\n", core, 
+							start[core], end[core], mask[core]);
+	}
+	return ret;
+}
-- 
1.6.0.4

