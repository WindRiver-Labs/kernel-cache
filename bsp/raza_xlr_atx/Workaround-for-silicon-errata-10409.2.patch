From 7f02cf4a6e25ee29fce00b2f8e5243009505c83d Mon Sep 17 00:00:00 2001
From: Zhang Xiao <xiao.zhang@windriver.com>
Date: Fri, 22 Jul 2011 15:54:23 +0800
Subject: [PATCH 2/2] Workaround for silicon errata 10409.2

The XLR System (Memory) Bridge does not always handle simultaneous register
load (i.e., register read) accesses correctly. Port the workaround
from vendor's silicon errata 10409.2. It changes the use of rmi_bridge_lock
from a multiple reader/single writer lock to a true mutex. The old code did not
prevent simultaneous read access by multiple cores.

Signed-off-by: Zhang Xiao <xiao.zhang@windriver.com>
---
 include/asm-mips/rmi/iomap.h |   36 +++++++++++++++++++++++++++---------
 1 files changed, 27 insertions(+), 9 deletions(-)

diff --git a/include/asm-mips/rmi/iomap.h b/include/asm-mips/rmi/iomap.h
index 3c4533d..9e20577 100644
--- a/include/asm-mips/rmi/iomap.h
+++ b/include/asm-mips/rmi/iomap.h
@@ -113,33 +113,51 @@ extern unsigned long phoenix_io_base;
 
 #ifdef RMI_BRIDGE_WKAROUND
 #include <asm/rmi/rmi_rw_lock.h>
+#include <linux/preempt.h>
 
 extern rmi_rwlock_t *rmi_bridge_lock;
 extern int rmi_enable_br_wrkaround;
 
 static inline uint32_t rmi_br_read_lock(void)
 {
-	if(rmi_enable_br_wrkaround)
-		return rmi_read_lock_irq_save(rmi_bridge_lock);
-	return 0;
+	uint32_t ret = 0;
+	if(rmi_enable_br_wrkaround) {
+		preempt_disable();
+		ret = rmi_write_lock_irq_save(rmi_bridge_lock);
+		preempt_enable_no_resched();
+	}
+
+	return ret;
 }
 static inline void rmi_br_read_unlock(unsigned int flags)
 {
-	if(rmi_enable_br_wrkaround)
-		rmi_read_unlock_irq_restore(rmi_bridge_lock, flags);
+	if(rmi_enable_br_wrkaround) {
+		preempt_disable();
+		rmi_write_unlock_irq_restore(rmi_bridge_lock, flags);
+		preempt_enable_no_resched();
+	}
 }
 
 static inline uint32_t rmi_br_write_lock(void)
 {
-	if(rmi_enable_br_wrkaround)
-		return rmi_write_lock_irq_save(rmi_bridge_lock);
-	return 0;
+	uint32_t ret = 0;
+
+	if(rmi_enable_br_wrkaround) {
+		preempt_disable();
+		ret = rmi_write_lock_irq_save(rmi_bridge_lock);
+		preempt_enable_no_resched();
+	}
+
+	return ret;
 }
 
 static inline void rmi_br_write_unlock(unsigned int flags)
 {
-	if(rmi_enable_br_wrkaround)
+	if(rmi_enable_br_wrkaround) {
+		preempt_disable();
 		rmi_write_unlock_irq_restore(rmi_bridge_lock, flags);
+		preempt_enable_no_resched();
+	}
 }
 
 static inline uint32_t rmi_read_reg_locked(phoenix_reg_t *base, 
-- 
1.7.0.4

