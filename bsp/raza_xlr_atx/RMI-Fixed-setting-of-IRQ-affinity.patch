From 81b29f8dfbc2ded3c096afb002fe518ad98cf415 Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Sat, 11 Jul 2009 16:08:58 -0400
Subject: [PATCH] RMI: Fixed setting of IRQ affinity.

Assigning an interrupt to a group of CPU was miscalculated if the
boot CPU was not core0/thread0 and if not all CPUs were online,
such as in the case of a kdump kernel. Logical CPU0 was considered
to be core0/thread0, which is not necessarily true. If rebooting
and only using one CPU, but not core0/thread0, interrupts being
assigned an affinity would be directed to core0/thread0 and never
serviced.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>
---
 arch/mips/rmi/phoenix/irq.c |    6 ++++--
 arch/mips/rmi/phoenix/smp.c |   23 +++++++++++++++++++++++
 2 files changed, 27 insertions(+), 2 deletions(-)

diff --git a/arch/mips/rmi/phoenix/irq.c b/arch/mips/rmi/phoenix/irq.c
index f108241..ae05652 100644
--- a/arch/mips/rmi/phoenix/irq.c
+++ b/arch/mips/rmi/phoenix/irq.c
@@ -60,6 +60,7 @@
  * for interrupt lines 
 */
 
+extern uint32_t phoenix_smp_logical_to_hw_mask(uint32_t logical_mask);
 extern void *ht_config_base;
 extern int link0, link1;
 
@@ -248,14 +249,15 @@ static void pic_set_affinity(unsigned int irq, cpumask_t mask)
 {
 	phoenix_reg_t *mmio = phoenix_io_mmio(PHOENIX_IO_PIC_OFFSET);
 	unsigned long flags;
+	uint32_t hw_mask;
 
 	if (!PIC_IRQ_IS_IRT(irq))
 		return;
 
 	spin_lock_irqsave(&phnx_pic_lock, flags);
 
-	phoenix_write_reg(mmio, PIC_IRT_0_BASE + irq - PIC_IRQ_BASE,
-					  (uint32_t) (mask.bits[0]));
+	hw_mask = phoenix_smp_logical_to_hw_mask((uint32_t)(mask.bits[0]));
+	phoenix_write_reg(mmio, PIC_IRT_0_BASE + irq - PIC_IRQ_BASE, hw_mask);
 
 	spin_unlock_irqrestore(&phnx_pic_lock, flags);
 }
diff --git a/arch/mips/rmi/phoenix/smp.c b/arch/mips/rmi/phoenix/smp.c
index 90c26d6..e42e2f6 100644
--- a/arch/mips/rmi/phoenix/smp.c
+++ b/arch/mips/rmi/phoenix/smp.c
@@ -54,6 +54,7 @@ extern void smp_call_function_interrupt(void);
 extern void phoenix_smp_time_init(void);
 
 static int phoenix_ipi_stats[NR_CPUS];
+static uint32_t phoenix_logical_hi_mask = 0;
 
 static void phoenix_send_ipi_single(int logical_cpu, unsigned int action)
 {
@@ -252,8 +253,13 @@ void __init phoenix_smp_setup(void)
 		}
 	}
 
+	for(i = boot_cpu+1; i < NR_CPUS; i++) {
+		phoenix_logical_hi_mask |= (1 << i);
+	}
+
 	fast_syscall_cpumask_phy = (unsigned int)phys_cpu_present_map.bits[0];
 
+	printk("Boot CPU: %d\n", boot_cpu);
 	printk("Phys CPU present map: %lx, possible map %lx\n", 
 	       (unsigned long)phys_cpu_present_map.bits[0], 
 	       (unsigned long)cpu_possible_map.bits[0]);
@@ -261,6 +267,23 @@ void __init phoenix_smp_setup(void)
 	printk("Detected %i Slave CPU(s)\n", num_cpus);
 }
 
+uint32_t phoenix_smp_logical_to_hw_mask(uint32_t logical_mask)
+{
+	int boot_cpu;
+	uint32_t hw_mask;
+
+	/* The boot cpu is always at index 0 of the logical map; following
+	 * are CPUs 0 to <boot cpu-1>, then CPUs <boot cpu+1> to 31.
+	 * We have to take that map and find the map of physical CPUs that
+	 * are online.
+	 */
+	boot_cpu = cpu_logical_map(0);
+	hw_mask = (logical_mask & ~phoenix_logical_hi_mask) >> 1;
+	hw_mask |= logical_mask & phoenix_logical_hi_mask;
+	hw_mask |= (1 << boot_cpu);
+	return hw_mask;
+}
+
 void phoenix_prepare_cpus(unsigned int max_cpus)
 {
 }
-- 
1.6.0.4

