From 29ea1783b99300fcc3a888e467714711f7e9c4a8 Mon Sep 17 00:00:00 2001
From: Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
Date: Wed, 18 Mar 2009 15:35:31 -0400
Subject: [PATCH] Introduce generic PIT timer for 82xx boards

This is intended to be the common HWTimer code for all boards
with PIT's.  Currently only the sbcpq2 is utilizing it.

Signed-off-by: Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
---
 arch/powerpc/platforms/82xx/Kconfig         |    9 +-
 arch/powerpc/platforms/82xx/Makefile        |    2 +-
 arch/powerpc/platforms/82xx/pq2_pit_timer.c |  205 +++++++++++++++++++++++++++
 arch/powerpc/platforms/82xx/sbcpq2.c        |    7 +
 4 files changed, 221 insertions(+), 2 deletions(-)
 create mode 100644 arch/powerpc/platforms/82xx/pq2_pit_timer.c

diff --git a/arch/powerpc/platforms/82xx/Kconfig b/arch/powerpc/platforms/82xx/Kconfig
index 4c78769..a8d647c 100644
--- a/arch/powerpc/platforms/82xx/Kconfig
+++ b/arch/powerpc/platforms/82xx/Kconfig
@@ -44,11 +44,18 @@ config SBCPQ2
 	select 8260
 	select CPM2
 	select FSL_SOC
+	select PIT_HWTIMER if HWTIMER_HOOKS
 	help
 	  This option enables support for Wind River SBC PowerQUICCII 82xx,
 	  which is a single-board computer with MPC82xx CPU.
 
-
+config PIT_HWTIMER
+	bool "PIT Timer as clock source"
+	default n
+	depends on HWTIMER_HOOKS
+	help
+	  This enables the PIT Timer to be used as a secondary
+	  time source.
 endif
 
 config PQ2ADS
diff --git a/arch/powerpc/platforms/82xx/Makefile b/arch/powerpc/platforms/82xx/Makefile
index ae522db..f145af9 100644
--- a/arch/powerpc/platforms/82xx/Makefile
+++ b/arch/powerpc/platforms/82xx/Makefile
@@ -7,4 +7,4 @@ obj-$(CONFIG_PQ2_ADS_PCI_PIC) += pq2ads-pci-pic.o
 obj-$(CONFIG_PQ2FADS) += pq2fads.o
 obj-$(CONFIG_EP8248E) += ep8248e.o
 obj-$(CONFIG_SBCPQ2) += sbcpq2.o
-
+obj-$(CONFIG_PIT_HWTIMER) += pq2_pit_timer.o
diff --git a/arch/powerpc/platforms/82xx/pq2_pit_timer.c b/arch/powerpc/platforms/82xx/pq2_pit_timer.c
new file mode 100644
index 0000000..6a6d96a
--- /dev/null
+++ b/arch/powerpc/platforms/82xx/pq2_pit_timer.c
@@ -0,0 +1,205 @@
+/*
+ *
+ * pq2_pit_timer.c, Wind River PowerQUICCII HWClock using pit timer
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * By Jeremy McNicoll <jeremy.mcnicoll@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+*/
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/io.h>
+#include <linux/fsl_devices.h>
+#include <linux/fs_enet_pd.h>
+#include <linux/of_platform.h>
+
+#include <linux/hwtimer.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include <asm/prom.h>
+#include <asm/cpm2.h>
+#include <asm/fs_pd.h>
+#include <asm/immap_cpm2.h>
+
+#include <sysdev/cpm2_pic.h>
+
+#ifdef CONFIG_SBCPQ2
+#define BASE_FREQ	470000
+#else
+#error "Please set default PIT timer frequency for your board."
+#endif
+
+static DECLARE_HWTIMER_LOCK(pit_hwtimer_lock);
+
+static struct hwtimer_data pit_hwtimer_data;
+static void __iomem *reg_base;
+static int pit_irq;
+static int pit_hwtimer_freq;
+
+irqreturn_t pit_hwtimer_interrupt(int irq, void *dev_id);
+static int pit_hwtimer_start(void);
+extern int pit_hwtimer_init(void);
+
+static int pit_hwtimer_get_freq(void)
+{
+	return pit_hwtimer_freq;
+}
+
+static int pit_hwtimer_set_freq(int freq)
+{
+	u32 pitc = 0;
+
+	if ((freq < pit_hwtimer_data.min_freq) || \
+		(freq > pit_hwtimer_data.max_freq)) {
+		printk(KERN_INFO "pit_hwtimer: Invalid frequency \n");
+		return -EINVAL;
+	}
+	pit_hwtimer_freq = freq;
+	pitc =  BASE_FREQ / pit_hwtimer_freq;
+	out_be32(&cpm2_immr->im_sit.sit_pitc, pitc << 16);
+
+	return 0;
+}
+
+static int pit_hwtimer_stop(void)
+{
+	free_irq(pit_irq, NULL);
+	clrbits32(&cpm2_immr->im_sit.sit_piscr, PISCR_PIE | PISCR_PTE);
+	return 0;
+}
+
+static struct hwtimer_data pit_hwtimer_data = {
+
+#ifdef CONFIG_SBCPQ2
+	.name = "sbcpq2_timer",
+	.desc = "PPC kernel sbcPQII PIT timer",
+#else
+	.name = "generic_pit",
+	.desc = "Generic PPC PIT timer",
+#endif
+	.def_freq = HZ,
+	.min_freq = 8,
+#ifdef CONFIG_SBCPQ2
+	.max_freq = 2048,
+#else
+	.max_freq = 8192,
+#endif
+};
+
+static struct hwtimer pit_hwtimer = {
+	.data = &pit_hwtimer_data,
+	.set_freq = pit_hwtimer_set_freq,
+	.get_freq = pit_hwtimer_get_freq,
+	.start = pit_hwtimer_start,
+	.stop = pit_hwtimer_stop,
+	.lock = &pit_hwtimer_lock,
+	.hook = NULL,
+	.hook_data = NULL
+};
+
+irqreturn_t pit_hwtimer_interrupt(int irq, void *dev_id)
+{
+	int pit_scr = 0;
+
+	pit_scr = in_be16(&cpm2_immr->im_sit.sit_piscr);
+	pit_scr |= PISCR_PS;
+	out_be16(&cpm2_immr->im_sit.sit_piscr, pit_scr);
+
+	spin_lock(pit_hwtimer.lock);
+	if (pit_hwtimer.hook != NULL) {
+		pit_hwtimer.hook(pit_hwtimer.hook_data);
+	}
+	spin_unlock(pit_hwtimer.lock);
+	return IRQ_HANDLED;
+}
+
+int pit_hwtimer_setup(void)
+{
+	int ret = 0;
+	pit_hwtimer_freq = pit_hwtimer_data.def_freq;
+	register_hwtimer(&pit_hwtimer);
+
+	return ret;
+}
+EXPORT_SYMBOL(pit_hwtimer_setup);
+
+int pit_hwtimer_init(void)
+{
+	struct device_node *np;
+	struct resource res;
+	int ret = 0;
+	int size;
+	const u32 *prop;
+	unsigned long pit_addr;
+
+	np = of_find_compatible_node(NULL, "pit", "fsl,mpc_pit");
+	if (!np) {
+		printk(KERN_ERR "pit_hwtimer: cannot find devices\n");
+		return -ENODEV;
+	}
+	pit_irq = irq_of_parse_and_map(np, 0);
+
+	set_irq_type(pit_irq, IRQ_TYPE_LEVEL_LOW);
+
+	prop = of_get_property(np, "reg", &size);
+	if (prop && size >= sizeof(*prop)) {
+		pit_addr = of_translate_address(np, prop);
+		reg_base = ioremap(pit_addr, size);
+	}
+
+	if (reg_base == NULL) {
+		printk(KERN_ERR "pit_hwtimer: unable to remap PIT Timer\n");
+		printk(KERN_ERR "pit_hwtimer: remapping i/o address 0x%lx size 0x%x \n",
+			pit_addr, size);
+		return -ENOMEM;
+	}
+
+	/* Before we request the IRQ lets make sure it doesn't fire until
+	* hwtimer_start is called */
+
+	out_be16(&cpm2_immr->im_sit.sit_piscr, 0x0);
+
+	if ((ret = request_irq(pit_irq, pit_hwtimer_interrupt, \
+				IRQF_TIMER, "pit_hwtimer", NULL)) != 0) {
+		printk(KERN_ERR "pit_hwtimer: cannot register IRQ %d, ret:%d\n", pit_irq, ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+
+static int pit_hwtimer_start(void)
+{
+	u32 pitc = 0;
+	int ret = 0;
+	ret = pit_hwtimer_init();
+	if (ret != 0) {
+		printk(KERN_ERR " pit_hwtimer: cannot initialize timers\n");
+		return ret;
+	}
+
+	pitc = BASE_FREQ / pit_hwtimer_freq;
+	out_be32(&cpm2_immr->im_sit.sit_pitc, pitc << 16);
+	out_be16(&cpm2_immr->im_sit.sit_piscr, PISCR_PIE | PISCR_PTE | PISCR_PTF);
+	return ret;
+
+}
+
+
diff --git a/arch/powerpc/platforms/82xx/sbcpq2.c b/arch/powerpc/platforms/82xx/sbcpq2.c
index acba870..470192b 100644
--- a/arch/powerpc/platforms/82xx/sbcpq2.c
+++ b/arch/powerpc/platforms/82xx/sbcpq2.c
@@ -54,6 +54,10 @@
 static int __init declare_of_platform_devices(void);
 static int pcmcia_build;
 
+#ifdef CONFIG_HWTIMER_HOOKS
+extern int pit_hwtimer_setup(void);
+#endif
+
 /*
  * sbcpq2_pdev_init - Register the platform device for sbcpq2 board
  */
@@ -244,6 +248,9 @@ static void __init sbcpq2_setup_arch(void)
 	init_ioports();
 	if (ppc_md.progress)
 		ppc_md.progress("sbcpq2_setup_arch(), finish", 0);
+#ifdef CONFIG_HWTIMER_HOOKS
+	pit_hwtimer_setup();
+#endif
 }
 
 static void sbcpq2_show_cpuinfo(struct seq_file *m)
-- 
1.6.0.4

