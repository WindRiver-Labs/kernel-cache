From bf1e8eb5b65a8f82b6b0712c2546fbec6b124360 Mon Sep 17 00:00:00 2001
From: Limeng <Meng.Li@windriver.com>
Date: Fri, 17 Mar 2017 14:13:18 +0800
Subject: [PATCH] tpm: Add sysfs interface to show TPM family major version

So far, there is not a sysfs interface for user space code to
check the TPM family major version(1 or 2). So, add a file
named family_major in /sys/class/tpm/tpmX/ to show it.

This idea is from below usage case:
When tss 1.2 and 2.0 are all installed in one rootfs, we need to
judge which one is used via the sys interface family_major file.

Signed-off-by: Meng Li <Meng.Li@windriver.com>
---
 drivers/char/tpm/tpm-chip.c  |    4 +++-
 drivers/char/tpm/tpm-sysfs.c |   39 +++++++++++++++++++++++++++++++++++++--
 drivers/char/tpm/tpm.h       |    1 +
 3 files changed, 41 insertions(+), 3 deletions(-)

diff --git a/drivers/char/tpm/tpm-chip.c b/drivers/char/tpm/tpm-chip.c
index 377cdc1..e28b9b9 100644
--- a/drivers/char/tpm/tpm-chip.c
+++ b/drivers/char/tpm/tpm-chip.c
@@ -281,7 +281,7 @@ static int tpm1_chip_register(struct tpm_chip *chip)
 	if (chip->flags & TPM_CHIP_FLAG_TPM2)
 		return 0;
 
-	tpm_sysfs_add_device(chip);
+	tpm1_sysfs_add_device(chip);
 
 	chip->bios_dir = tpm_bios_log_setup(dev_name(&chip->dev));
 
@@ -369,6 +369,8 @@ int tpm_chip_register(struct tpm_chip *chip)
 
 	tpm_add_ppi(chip);
 
+	tpm_sysfs_add_device(chip);
+
 	rc = tpm_add_char_device(chip);
 	if (rc) {
 		tpm1_chip_unregister(chip);
diff --git a/drivers/char/tpm/tpm-sysfs.c b/drivers/char/tpm/tpm-sysfs.c
index b46cf70..cfcf221 100644
--- a/drivers/char/tpm/tpm-sysfs.c
+++ b/drivers/char/tpm/tpm-sysfs.c
@@ -264,7 +264,7 @@ static ssize_t timeouts_show(struct device *dev, struct device_attribute *attr,
 }
 static DEVICE_ATTR_RO(timeouts);
 
-static struct attribute *tpm_dev_attrs[] = {
+static struct attribute *tpm1_dev_attrs[] = {
 	&dev_attr_pubek.attr,
 	&dev_attr_pcrs.attr,
 	&dev_attr_enabled.attr,
@@ -278,6 +278,42 @@ static struct attribute *tpm_dev_attrs[] = {
 	NULL,
 };
 
+static const struct attribute_group tpm1_dev_group = {
+	.attrs = tpm1_dev_attrs,
+};
+
+void tpm1_sysfs_add_device(struct tpm_chip *chip)
+{
+	/* The sysfs routines rely on an implicit tpm_try_get_ops, device_del
+	 * is called before ops is null'd and the sysfs core synchronizes this
+	 * removal so that no callbacks are running or can run again
+	 */
+	WARN_ON(chip->groups_cnt != 0);
+	chip->groups[chip->groups_cnt++] = &tpm1_dev_group;
+}
+
+static ssize_t family_major_show(struct device *dev, struct device_attribute *attr,
+			      char *buf)
+{
+	int ret;
+	struct tpm_chip *chip = to_tpm_chip(dev);
+
+	if (chip->flags & TPM_CHIP_FLAG_TPM2)
+		ret = sprintf(buf, "2");
+	else
+		ret = sprintf(buf, "1");
+
+	return ret;
+}
+
+static DEVICE_ATTR_RO(family_major);
+
+
+static struct attribute *tpm_dev_attrs[] = {
+	&dev_attr_family_major.attr,
+	NULL,
+};
+
 static const struct attribute_group tpm_dev_group = {
 	.attrs = tpm_dev_attrs,
 };
@@ -288,6 +324,5 @@ void tpm_sysfs_add_device(struct tpm_chip *chip)
 	 * is called before ops is null'd and the sysfs core synchronizes this
 	 * removal so that no callbacks are running or can run again
 	 */
-	WARN_ON(chip->groups_cnt != 0);
 	chip->groups[chip->groups_cnt++] = &tpm_dev_group;
 }
diff --git a/drivers/char/tpm/tpm.h b/drivers/char/tpm/tpm.h
index 3e32d5b..b96cea6 100644
--- a/drivers/char/tpm/tpm.h
+++ b/drivers/char/tpm/tpm.h
@@ -504,6 +504,7 @@ extern int tpm_chip_register(struct tpm_chip *chip);
 extern void tpm_chip_unregister(struct tpm_chip *chip);
 
 void tpm_sysfs_add_device(struct tpm_chip *chip);
+void tpm1_sysfs_add_device(struct tpm_chip *chip);
 
 int tpm_pcr_read_dev(struct tpm_chip *chip, int pcr_idx, u8 *res_buf);
 
-- 
1.7.5.4

