From 70af08d2156e6e56435b438472bc4f646b0def93 Mon Sep 17 00:00:00 2001
From: Kedareswara rao Appana <appana.durga.rao@xilinx.com>
Date: Fri, 29 Apr 2016 15:34:22 +0530
Subject: [PATCH 178/188] net: ethernet: xilinx: Fix race condition for 10G MAC

This patch comes from:
  https://github.com/Xilinx/linux-xlnx.git

In the driver napi is enabled after interrupts
are being registered. This may casue issue
if there is already data in the mac rx fifo.

If there is already data in the mac rx fifo
in the current driver flow it will trigger RX ISR
there we are disabling RX interrupts again it will
get enabled after processing the packets upto quota
in the napi poll.

But with the current driver flow napi will never be called
resulting no more rx packets being processed(As napi is enabled
at the end of the open function).

This patch fixes this issue.

Signed-off-by: Kedareswara rao Appana <appanad@xilinx.com>
Acked-by: Harini Katakam <harinik@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
(cherry picked from commit 00526bfcb5e6908603c1b7f332ecda82931889f3)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/xilinx/xilinx_axienet_main.c | 11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
index b3d99a0..1f561d3 100644
--- a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
@@ -1269,6 +1269,14 @@ static int axienet_open(struct net_device *ndev)
 	tasklet_init(&lp->dma_err_tasklet, axienet_dma_err_handler,
 		     (unsigned long) lp);
 
+	/* Enable NAPI scheduling before enabling Axi DMA Rx IRQ, or you
+	 * might run into a race condition; the RX ISR disables IRQ processing
+	 * before scheduling the NAPI function to complete the processing.
+	 * If NAPI scheduling is (still) disabled at that time, no more RX IRQs
+	 * will be processed as only the NAPI function re-enables them!
+	 */
+	napi_enable(&lp->napi);
+
 	/* Enable interrupts for Axi DMA Tx */
 	ret = request_irq(lp->tx_irq, axienet_tx_irq, 0, ndev->name, ndev);
 	if (ret)
@@ -1286,8 +1294,6 @@ static int axienet_open(struct net_device *ndev)
 			goto err_eth_irq;
 	}
 
-	napi_enable(&lp->napi);
-
 	return 0;
 
 err_eth_irq:
@@ -1295,6 +1301,7 @@ err_eth_irq:
 err_rx_irq:
 	free_irq(lp->tx_irq, ndev);
 err_tx_irq:
+	napi_disable(&lp->napi);
 	if (lp->phy_dev)
 		phy_disconnect(lp->phy_dev);
 	tasklet_kill(&lp->dma_err_tasklet);
-- 
2.0.2

