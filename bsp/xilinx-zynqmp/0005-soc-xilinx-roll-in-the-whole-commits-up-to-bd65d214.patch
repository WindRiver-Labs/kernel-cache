From 6d7cce935b57f6c9426c2d6c582062c7b8619675 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Tue, 18 Oct 2016 13:52:43 +0800
Subject: [PATCH 005/188] soc: xilinx: roll in the whole commits up to bd65d214

This commit is to roll in all the commits up to bd65d214, including
the related head files from:
  https://github.com/Xilinx/linux-xlnx.git

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 .../devicetree/bindings/power/zynqmp-genpd.txt     |   41 +
 .../devicetree/bindings/soc/xilinx/zynq_mpsoc.txt  |   13 +
 drivers/soc/Kconfig                                |    1 +
 drivers/soc/Makefile                               |    1 +
 drivers/soc/xilinx/Kconfig                         |   26 +
 drivers/soc/xilinx/zynqmp/Makefile                 |    2 +
 drivers/soc/xilinx/zynqmp/pm.c                     | 1024 ++++++++++++++++++++
 drivers/soc/xilinx/zynqmp/pm_domains.c             |  176 ++++
 drivers/soc/xilinx/zynqmp/tap_delays.c             |  302 ++++++
 include/linux/soc/xilinx/zynqmp/pm.h               |  248 +++++
 include/linux/soc/xilinx/zynqmp/tap_delays.h       |   31 +
 11 files changed, 1865 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/power/zynqmp-genpd.txt
 create mode 100644 Documentation/devicetree/bindings/soc/xilinx/zynq_mpsoc.txt
 create mode 100644 drivers/soc/xilinx/Kconfig
 create mode 100644 drivers/soc/xilinx/zynqmp/Makefile
 create mode 100644 drivers/soc/xilinx/zynqmp/pm.c
 create mode 100644 drivers/soc/xilinx/zynqmp/pm_domains.c
 create mode 100644 drivers/soc/xilinx/zynqmp/tap_delays.c
 create mode 100644 include/linux/soc/xilinx/zynqmp/pm.h
 create mode 100644 include/linux/soc/xilinx/zynqmp/tap_delays.h

diff --git a/Documentation/devicetree/bindings/power/zynqmp-genpd.txt b/Documentation/devicetree/bindings/power/zynqmp-genpd.txt
new file mode 100644
index 0000000..8960112
--- /dev/null
+++ b/Documentation/devicetree/bindings/power/zynqmp-genpd.txt
@@ -0,0 +1,41 @@
+Device Tree bindings for Xilinx Zynq MPSoC PM domains
+
+The binding for zynqmp-genpd follow the common generic PM domain binding[1].
+
+[1] Documentation/devicetree/bindings/power/power_domain.txt
+
+== Zynq MPSoC Generic PM Domain Node ==
+
+Required properties:
+ - compatible: Must be: "xlnx,zynqmp-genpd"
+
+This node contains a number of subnodes, each representing a single PM domain
+that PM domain consumer devices reference.
+
+== PM Domain Nodes ==
+
+Required properties:
+ - #power-domain-cells: Number of cells in a PM domain specifier. Must be 0.
+ - pd-id: Unique domain identifier of as defined by platform firmware. This
+	  identifier is passed to the PM firmware.
+
+Example:
+	zynqmp-genpd {
+		compatible = "xlnx,zynqmp-genpd";
+
+		pd_usb0: pd-usb0 {
+			pd-id = <22>;
+			#power-domain-cells = <0>;
+		};
+
+		pd_sata: pd-sata {
+			pd-id = <25>;
+			#power-domain-cells = <0>;
+		};
+	};
+
+	sata0: ahci@SATA_AHCI_HBA {
+		...
+		power-domains = <&pd_sata>;
+		...
+	};
diff --git a/Documentation/devicetree/bindings/soc/xilinx/zynq_mpsoc.txt b/Documentation/devicetree/bindings/soc/xilinx/zynq_mpsoc.txt
new file mode 100644
index 0000000..2f5675e
--- /dev/null
+++ b/Documentation/devicetree/bindings/soc/xilinx/zynq_mpsoc.txt
@@ -0,0 +1,13 @@
+Xilinx Zynq MPSoC Device Tree Bindings
+
+Zynq MPSoC based systems rely on the "psci" node to detect the presence of PMU
+firmware as well as to determine the calling method (either "smc" or "hvc")
+to the PM-API firmware layer.
+
+Required properties:
+ - compatible  : Must contain:  "xlnx,zynqmp-pm"
+
+ - method      : The method of calling the PM-API firmware layer.
+                 Permitted values are:
+                 "smc" : To be used in configurations without a hypervisor
+                 "hvc" : To be used when hypervisor is present
diff --git a/drivers/soc/Kconfig b/drivers/soc/Kconfig
index fe42a2f..ba8e77e 100644
--- a/drivers/soc/Kconfig
+++ b/drivers/soc/Kconfig
@@ -11,5 +11,6 @@ source "drivers/soc/tegra/Kconfig"
 source "drivers/soc/ti/Kconfig"
 source "drivers/soc/ux500/Kconfig"
 source "drivers/soc/versatile/Kconfig"
+source "drivers/soc/xilinx/Kconfig"
 
 endmenu
diff --git a/drivers/soc/Makefile b/drivers/soc/Makefile
index 50c23d0..6c3ba97 100644
--- a/drivers/soc/Makefile
+++ b/drivers/soc/Makefile
@@ -16,3 +16,4 @@ obj-$(CONFIG_ARCH_TEGRA)	+= tegra/
 obj-$(CONFIG_SOC_TI)		+= ti/
 obj-$(CONFIG_ARCH_U8500)	+= ux500/
 obj-$(CONFIG_PLAT_VERSATILE)	+= versatile/
+obj-$(CONFIG_ARCH_ZYNQMP)	+= xilinx/zynqmp/
diff --git a/drivers/soc/xilinx/Kconfig b/drivers/soc/xilinx/Kconfig
new file mode 100644
index 0000000..ea09eb2
--- /dev/null
+++ b/drivers/soc/xilinx/Kconfig
@@ -0,0 +1,26 @@
+#
+# Xilinx ZYNQ MPSoC configuration
+#
+menuconfig SOC_XILINX_ZYNQMP
+	bool "Xilinx Zynq MPSoC driver support"
+	depends on ARCH_ZYNQMP
+
+if SOC_XILINX_ZYNQMP
+
+config ZYNQMP_PM_API_DEBUGFS
+	bool "Enable Xilinx Zynq MPSoC Power Management API debugfs functionality"
+	depends on DEBUG_FS
+	help
+	  Say yes to enable power domain management API requests through debugfs
+	  In doubt, say N
+
+config ZYNQMP_PM_DOMAINS
+	bool "Enable Zynq MPSoC generic PM domains"
+	default y
+	depends on PM
+	select PM_GENERIC_DOMAINS
+	help
+	  Say yes to enable device power management through PM domains
+	  In doubt, say N
+
+endif #SOC_XILINX_ZYNQMP
diff --git a/drivers/soc/xilinx/zynqmp/Makefile b/drivers/soc/xilinx/zynqmp/Makefile
new file mode 100644
index 0000000..4b67ae1
--- /dev/null
+++ b/drivers/soc/xilinx/zynqmp/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_ARCH_ZYNQMP) += pm.o tap_delays.o
+obj-$(CONFIG_ZYNQMP_PM_DOMAINS) += pm_domains.o
diff --git a/drivers/soc/xilinx/zynqmp/pm.c b/drivers/soc/xilinx/zynqmp/pm.c
new file mode 100644
index 0000000..18ecc37
--- /dev/null
+++ b/drivers/soc/xilinx/zynqmp/pm.c
@@ -0,0 +1,1024 @@
+/*
+ * Xilinx Zynq MPSoC Power Management
+ *
+ *  Copyright (C) 2014-2015 Xilinx, Inc.
+ *
+ *  Davorin Mista <davorin.mista@aggios.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/compiler.h>
+#include <linux/of.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/uaccess.h>
+#include <linux/platform_device.h>
+#include <linux/debugfs.h>
+#include <linux/soc/xilinx/zynqmp/pm.h>
+
+/* SMC SIP service Call Function Identifier Prefix */
+#define PM_SIP_SVC	0xC2000000
+
+/* Number of 32bits values in payload */
+#define PAYLOAD_ARG_CNT	5U
+
+#define DRIVER_NAME	"zynqmp_pm"
+
+static u32 pm_api_version;
+
+enum pm_api_id {
+	/* Miscellaneous API functions: */
+	GET_API_VERSION = 1,
+	SET_CONFIGURATION,
+	GET_NODE_STATUS,
+	GET_OPERATING_CHARACTERISTIC,
+	REGISTER_NOTIFIER,
+	/* API for suspending of PUs: */
+	REQUEST_SUSPEND,
+	SELF_SUSPEND,
+	FORCE_POWERDOWN,
+	ABORT_SUSPEND,
+	REQUEST_WAKEUP,
+	SET_WAKEUP_SOURCE,
+	SYSTEM_SHUTDOWN,
+	/* API for managing PM slaves: */
+	REQUEST_NODE,
+	RELEASE_NODE,
+	SET_REQUIREMENT,
+	SET_MAX_LATENCY,
+	/* Direct control API functions: */
+	RESET_ASSERT,
+	RESET_GET_STATUS,
+	MMIO_WRITE,
+	MMIO_READ,
+};
+
+/* PMU-FW return status codes */
+enum pm_ret_status {
+	XST_PM_SUCCESS = 0,
+	XST_PM_INTERNAL	= 2000,
+	XST_PM_CONFLICT,
+	XST_PM_NO_ACCESS,
+	XST_PM_INVALID_NODE,
+	XST_PM_DOUBLE_REQ,
+	XST_PM_ABORT_SUSPEND,
+};
+
+/**
+ * zynqmp_pm_ret_code - Convert PMU-FW error codes to Linux error codes
+ * @ret_status:		PMUFW return code
+ *
+ * Return:		corresponding Linux error code
+ */
+static int zynqmp_pm_ret_code(u32 ret_status)
+{
+	switch (ret_status) {
+	case XST_PM_SUCCESS:
+		return 0;
+	case XST_PM_NO_ACCESS:
+		return -EACCES;
+	case XST_PM_ABORT_SUSPEND:
+		return -ECANCELED;
+	case XST_PM_INTERNAL:
+	case XST_PM_CONFLICT:
+	case XST_PM_INVALID_NODE:
+	case XST_PM_DOUBLE_REQ:
+	default:
+		return -EINVAL;
+	}
+}
+
+static noinline int do_fw_call_fail(u64 arg0, u64 arg1, u64 arg2,
+				    u32 *ret_payload)
+{
+	return -ENODEV;
+}
+
+/*
+ * PM function call wrapper
+ * Invoke do_fw_call_smc or do_fw_call_hvc, depending on the configuration
+ */
+static int (*do_fw_call)(u64, u64, u64, u32 *ret_payload) = do_fw_call_fail;
+
+/**
+ * do_fw_call_smc - Call system-level power management layer (SMC)
+ * @arg0:		Argument 0 to SMC call
+ * @arg1:		Argument 1 to SMC call
+ * @arg2:		Argument 2 to SMC call
+ * @ret_payload:	Returned value array
+ *
+ * Return:		Returns status, either success or error+reason
+ *
+ * Invoke power management function via SMC call (no hypervisor present)
+ */
+static noinline int do_fw_call_smc(u64 arg0, u64 arg1, u64 arg2,
+						u32 *ret_payload)
+{
+	/*
+	 * This firmware calling code may be moved to an assembly file
+	 * so as to compile it successfully with GCC 5, as per the
+	 * reference git commit f5e0a12ca2d939e47995f73428d9bf1ad372b289
+	 */
+	asm volatile(
+		__asmeq("%0", "x0")
+		__asmeq("%1", "x1")
+		__asmeq("%2", "x2")
+		"smc	#0\n"
+		: "+r" (arg0), "+r" (arg1), "+r" (arg2)
+		: /* no input only */
+		: "x3", "x4", "x5", "x6", "x7", "x8", "x9", "x10", "x11", "x12",
+		  "x13", "x14", "x15", "x16", "x17"
+		);
+
+	if (ret_payload != NULL) {
+		ret_payload[0] = (u32)arg0;
+		ret_payload[1] = (u32)(arg0 >> 32);
+		ret_payload[2] = (u32)arg1;
+		ret_payload[3] = (u32)(arg1 >> 32);
+		ret_payload[4] = (u32)arg2;
+	}
+	return zynqmp_pm_ret_code((enum pm_ret_status)arg0);
+}
+
+/**
+ * do_fw_call_hvc - Call system-level power management layer (HVC)
+ * @arg0:		Argument 0 to HVC call
+ * @arg1:		Argument 1 to HVC call
+ * @arg2:		Argument 2 to HVC call
+ * @ret_payload:	Returned value array
+ *
+ * Return:		Returns status, either success or error+reason
+ *
+ * Invoke power management function via HVC
+ * HVC-based for communication through hypervisor
+ * (no direct communication with ATF)
+ */
+static noinline int do_fw_call_hvc(u64 arg0, u64 arg1, u64 arg2,
+						u32 *ret_payload)
+{
+	/*
+	 * This firmware calling code may be moved to an assembly file
+	 * so as to compile it successfully with GCC 5, as per the
+	 * reference git commit f5e0a12ca2d939e47995f73428d9bf1ad372b289
+	 */
+	asm volatile(
+		__asmeq("%0", "x0")
+		__asmeq("%1", "x1")
+		__asmeq("%2", "x2")
+		"hvc	#0\n"
+		: "+r" (arg0), "+r" (arg1), "+r" (arg2)
+		: /* no input only */
+		: "x3", "x4", "x5", "x6", "x7", "x8", "x9", "x10", "x11", "x12",
+		  "x13", "x14", "x15", "x16", "x17"
+		);
+
+	if (ret_payload != NULL) {
+		ret_payload[0] = (u32)arg0;
+		ret_payload[1] = (u32)(arg0 >> 32);
+		ret_payload[2] = (u32)arg1;
+		ret_payload[3] = (u32)(arg1 >> 32);
+		ret_payload[4] = (u32)arg2;
+	}
+
+	return zynqmp_pm_ret_code((enum pm_ret_status)arg0);
+}
+
+/**
+ * invoke_pm_fn - Invoke the system-level power management layer caller
+ *			function depending on the configuration
+ * @pm_api_id:         Requested PM-API call
+ * @arg0:              Argument 0 to requested PM-API call
+ * @arg1:              Argument 1 to requested PM-API call
+ * @arg2:              Argument 2 to requested PM-API call
+ * @arg3:              Argument 3 to requested PM-API call
+ * @ret_payload:       Returned value array
+ *
+ * Return:             Returns status, either success or error+reason
+ *
+ * Invoke power management function for SMC or HVC call, depending on
+ * configuration
+ * Following SMC Calling Convention (SMCCC) for SMC64:
+ * Pm Function Identifier,
+ * PM_SIP_SVC + PM_API_ID =
+ *     ((SMC_TYPE_FAST << FUNCID_TYPE_SHIFT)
+ *     ((SMC_64) << FUNCID_CC_SHIFT)
+ *     ((SIP_START) << FUNCID_OEN_SHIFT)
+ *     ((PM_API_ID) & FUNCID_NUM_MASK))
+ *
+ * PM_SIP_SVC  - Registered ZynqMP SIP Service Call
+ * PM_API_ID   - Power Management API ID
+ */
+static int invoke_pm_fn(u32 pm_api_id, u32 arg0, u32 arg1, u32 arg2, u32 arg3,
+							u32 *ret_payload)
+{
+	/*
+	 * Added SIP service call Function Identifier
+	 * Make sure to stay in x0 register
+	 */
+	u64 smc_arg[4];
+
+	smc_arg[0] = PM_SIP_SVC | pm_api_id;
+	smc_arg[1] = ((u64)arg1 << 32) | arg0;
+	smc_arg[2] = ((u64)arg3 << 32) | arg2;
+
+	return do_fw_call(smc_arg[0], smc_arg[1], smc_arg[2], ret_payload);
+}
+
+/* PM-APIs for suspending of APU */
+
+#ifdef CONFIG_ZYNQMP_PM_API_DEBUGFS
+/**
+ * zynqmp_pm_self_suspend - PM call for master to suspend itself
+ * @node:	Node ID of the master or subsystem
+ * @latency:	Requested maximum wakeup latency (not supported)
+ * @state:	Requested state (not supported)
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+static int zynqmp_pm_self_suspend(const u32 node,
+				  const u32 latency,
+				  const u32 state)
+{
+	return invoke_pm_fn(SELF_SUSPEND, node, latency, state, 0, NULL);
+}
+
+/**
+ * zynqmp_pm_abort_suspend - PM call to announce that a prior suspend request
+ *				is to be aborted.
+ * @reason:	Reason for the abort
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+static int zynqmp_pm_abort_suspend(const enum zynqmp_pm_abort_reason reason)
+{
+	return invoke_pm_fn(ABORT_SUSPEND, reason, 0, 0, 0, NULL);
+}
+
+/**
+ * zynqmp_pm_register_notifier - Register the PU to be notified of PM events
+ * @node:	Node ID of the slave
+ * @event:	The event to be notified about
+ * @wake:	Wake up on event
+ * @enable:	Enable or disable the notifier
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+static int zynqmp_pm_register_notifier(const u32 node, const u32 event,
+				       const u32 wake, const u32 enable)
+{
+	return invoke_pm_fn(REGISTER_NOTIFIER, node, event,
+						wake, enable, NULL);
+}
+#endif
+
+/**
+ * zynqmp_pm_request_suspend - PM call to request for another PU or subsystem to
+ *					be suspended gracefully.
+ * @node:	Node ID of the targeted PU or subsystem
+ * @ack:	Flag to specify whether acknowledge is requested
+ * @latency:	Requested wakeup latency (not supported)
+ * @state:	Requested state (not supported)
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_request_suspend(const u32 node,
+				      const enum zynqmp_pm_request_ack ack,
+				      const u32 latency,
+				      const u32 state)
+{
+	return invoke_pm_fn(REQUEST_SUSPEND, node, ack,
+						latency, state, NULL);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_request_suspend);
+
+/**
+ * zynqmp_pm_force_powerdown - PM call to request for another PU or subsystem to
+ *				be powered down forcefully
+ * @target:	Node ID of the targeted PU or subsystem
+ * @ack:	Flag to specify whether acknowledge is requested
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_force_powerdown(const u32 target,
+					  const enum zynqmp_pm_request_ack ack)
+{
+	return invoke_pm_fn(FORCE_POWERDOWN, target, ack, 0, 0, NULL);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_force_powerdown);
+
+/**
+ * zynqmp_pm_request_wakeup - PM call for to wake up selected master or subsystem
+ * @node:	Node ID of the master or subsystem
+ * @ack:	Flag to specify whether acknowledge requested
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_request_wakeup(const u32 node,
+				     const enum zynqmp_pm_request_ack ack)
+{
+	return invoke_pm_fn(REQUEST_WAKEUP, node, ack, 0, 0, NULL);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_request_wakeup);
+
+/**
+ * zynqmp_pm_set_wakeup_source - PM call to specify the wakeup source
+ *					while suspended
+ * @target:	Node ID of the targeted PU or subsystem
+ * @wakeup_node:Node ID of the wakeup peripheral
+ * @enable:	Enable or disable the specified peripheral as wake source
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_set_wakeup_source(const u32 target,
+					    const u32 wakeup_node,
+					    const u32 enable)
+{
+	return invoke_pm_fn(SET_WAKEUP_SOURCE, target,
+					wakeup_node, enable, 0, NULL);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_set_wakeup_source);
+
+/**
+ * zynqmp_pm_system_shutdown - PM call to request a system shutdown or restart
+ * @restart:	Shutdown or restart? 0 for shutdown, 1 for restart
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_system_shutdown(const u32 restart)
+{
+	return invoke_pm_fn(SYSTEM_SHUTDOWN, restart, 0, 0, 0, NULL);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_system_shutdown);
+
+/* API functions for managing PM Slaves */
+
+/**
+ * zynqmp_pm_request_node - PM call to request a node with specific capabilities
+ * @node:		Node ID of the slave
+ * @capabilities:	Requested capabilities of the slave
+ * @qos:		Quality of service (not supported)
+ * @ack:		Flag to specify whether acknowledge is requested
+ *
+ * Return:		Returns status, either success or error+reason
+ */
+int zynqmp_pm_request_node(const u32 node,
+				   const u32 capabilities,
+				   const u32 qos,
+				   const enum zynqmp_pm_request_ack ack)
+{
+	return invoke_pm_fn(REQUEST_NODE, node, capabilities,
+						qos, ack, NULL);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_request_node);
+
+/**
+ * zynqmp_pm_release_node - PM call to release a node
+ * @node:	Node ID of the slave
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_release_node(const u32 node)
+{
+	return invoke_pm_fn(RELEASE_NODE, node, 0, 0, 0, NULL);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_release_node);
+
+/**
+ * zynqmp_pm_set_requirement - PM call to set requirement for PM slaves
+ * @node:		Node ID of the slave
+ * @capabilities:	Requested capabilities of the slave
+ * @qos:		Quality of service (not supported)
+ * @ack:		Flag to specify whether acknowledge is requested
+ *
+ * This API function is to be used for slaves a PU already has requested
+ *
+ * Return:		Returns status, either success or error+reason
+ */
+int zynqmp_pm_set_requirement(const u32 node,
+				const u32 capabilities,
+				const u32 qos,
+				const enum zynqmp_pm_request_ack ack)
+{
+	return invoke_pm_fn(SET_REQUIREMENT, node, capabilities,
+						qos, ack, NULL);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_set_requirement);
+
+/**
+ * zynqmp_pm_set_max_latency - PM call to set wakeup latency requirements
+ * @node:	Node ID of the slave
+ * @latency:	Requested maximum wakeup latency
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_set_max_latency(const u32 node,
+					  const u32 latency)
+{
+	return invoke_pm_fn(SET_MAX_LATENCY, node,
+					latency, 0, 0, NULL);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_set_max_latency);
+
+/* Miscellaneous API functions */
+
+/**
+ * zynqmp_pm_get_api_version - Get version number of PMU PM firmware
+ * @version:	Returned version value
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_get_api_version(u32 *version)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+
+	if (version == NULL)
+		return zynqmp_pm_ret_code(XST_PM_CONFLICT);
+
+	/* Check is PM API version already verified */
+	if (pm_api_version > 0) {
+		*version = pm_api_version;
+		return XST_PM_SUCCESS;
+	}
+	invoke_pm_fn(GET_API_VERSION, 0, 0, 0, 0, ret_payload);
+	*version = ret_payload[1];
+
+	return zynqmp_pm_ret_code((enum pm_ret_status)ret_payload[0]);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_get_api_version);
+
+/**
+ * zynqmp_pm_set_configuration - PM call to set system configuration
+ * @physical_addr:	Physical 32-bit address of data structure in memory
+ *
+ * Return:		Returns status, either success or error+reason
+ */
+int zynqmp_pm_set_configuration(const u32 physical_addr)
+{
+	return invoke_pm_fn(SET_CONFIGURATION, physical_addr, 0, 0, 0, NULL);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_set_configuration);
+
+/**
+ * zynqmp_pm_get_node_status - PM call to request a node's current power state
+ * @node:	Node ID of the slave
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_get_node_status(const u32 node)
+{
+	return invoke_pm_fn(GET_NODE_STATUS, node, 0, 0, 0, NULL);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_get_node_status);
+
+/**
+ * zynqmp_pm_get_operating_characteristic - PM call to request operating
+ *						characteristic information
+ * @node:	Node ID of the slave
+ * @type:	Type of the operating characteristic requested
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_get_operating_characteristic(const u32 node,
+					const enum zynqmp_pm_opchar_type type)
+{
+	return invoke_pm_fn(GET_OPERATING_CHARACTERISTIC,
+						node, type, 0, 0, NULL);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_get_operating_characteristic);
+
+/* Direct-Control API functions */
+
+/**
+ * zynqmp_pm_reset_assert - Request setting of reset (1 - assert, 0 - release)
+ * @reset:		Reset to be configured
+ * @assert_flag:	Flag stating should reset be asserted (1) or
+ *			released (0)
+ *
+ * Return:		Returns status, either success or error+reason
+ */
+int zynqmp_pm_reset_assert(const enum zynqmp_pm_reset reset,
+			   const enum zynqmp_pm_reset_action assert_flag)
+{
+	return invoke_pm_fn(RESET_ASSERT, reset, assert_flag, 0, 0, NULL);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_reset_assert);
+
+/**
+ * zynqmp_pm_reset_get_status - Get status of the reset
+ * @reset:	Reset whose status should be returned
+ * @status:	Returned status
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_reset_get_status(const enum zynqmp_pm_reset reset, u32 *status)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+
+	if (status == NULL)
+		return zynqmp_pm_ret_code(XST_PM_CONFLICT);
+
+	invoke_pm_fn(RESET_GET_STATUS, reset, 0, 0, 0, ret_payload);
+	*status = ret_payload[1];
+
+	return zynqmp_pm_ret_code((enum pm_ret_status)ret_payload[0]);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_reset_get_status);
+
+/**
+ * zynqmp_pm_mmio_write - Perform write to protected mmio
+ * @address:	Address to write to
+ * @mask:	Mask to apply
+ * @value:	Value to write
+ *
+ * This function provides access to PM-related control registers
+ * that may not be directly accessible by a particular PU.
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_mmio_write(const u32 address,
+				     const u32 mask,
+				     const u32 value)
+{
+	return invoke_pm_fn(MMIO_WRITE, address, mask, value, 0, NULL);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_mmio_write);
+
+/**
+ * zynqmp_pm_mmio_read - Read value from protected mmio
+ * @address:	Address to write to
+ * @value:	Value to read
+ *
+ * This function provides access to PM-related control registers
+ * that may not be directly accessible by a particular PU.
+ *
+ * Return:	Returns status, either success or error+reason
+ */
+int zynqmp_pm_mmio_read(const u32 address, u32 *value)
+{
+	u32 ret_payload[PAYLOAD_ARG_CNT];
+
+	if (!value)
+		return -EINVAL;
+
+	invoke_pm_fn(MMIO_READ, address, 0, 0, 0, ret_payload);
+	*value = ret_payload[1];
+
+	return zynqmp_pm_ret_code((enum pm_ret_status)ret_payload[0]);
+}
+EXPORT_SYMBOL_GPL(zynqmp_pm_mmio_read);
+
+#ifdef CONFIG_ZYNQMP_PM_API_DEBUGFS
+/**
+ * zynqmp_pm_argument_value - Extract argument value from a PM-API request
+ * @arg:	Entered PM-API argument in string format
+ *
+ * Return:	Argument value in unsigned integer format on success
+ *		0 otherwise
+ */
+static u32 zynqmp_pm_argument_value(char *arg)
+{
+	u32 value;
+
+	if (!arg)
+		return 0;
+
+	if (!kstrtouint(arg, 0, &value))
+		return value;
+
+	return 0;
+}
+
+static struct dentry *zynqmp_pm_debugfs_dir;
+static struct dentry *zynqmp_pm_debugfs_power;
+static struct dentry *zynqmp_pm_debugfs_api_version;
+
+/**
+ * zynqmp_pm_debugfs_api_write - debugfs write function
+ * @file:	User file structure
+ * @ptr:	User entered PM-API string
+ * @len:	Length of the userspace buffer
+ * @off:	Offset within the file
+ *
+ * Return:	Number of bytes copied if PM-API request succeeds,
+ *		the corresponding error code otherwise
+ *
+ * Used for triggering pm api functions by writing
+ * echo <pm_api_id>    > /sys/kernel/debug/zynqmp_pm/power or
+ * echo <pm_api_name>  > /sys/kernel/debug/zynqmp_pm/power
+ */
+static ssize_t zynqmp_pm_debugfs_api_write(struct file *file,
+		    const char __user *ptr, size_t len, loff_t *off)
+{
+	char *kern_buff;
+	char *pm_api_req;
+	u32 pm_id = 0;
+	u32 pm_api_arg[4];
+	int ret;
+	int i = 0;
+
+	if (*off != 0 || len <= 0)
+		return -EINVAL;
+
+	kern_buff = kzalloc(len, GFP_KERNEL);
+	if (!kern_buff)
+		return -ENOMEM;
+
+	while (i < ARRAY_SIZE(pm_api_arg))
+		pm_api_arg[i++] = 0;
+
+	ret = strncpy_from_user(kern_buff, ptr, len);
+	if (ret < 0) {
+		ret = -EFAULT;
+		goto err;
+	}
+
+	/* Read the API name from an user request */
+	pm_api_req = strsep(&kern_buff, " ");
+
+	if (strncasecmp(pm_api_req, "REQUEST_SUSPEND", 15) == 0)
+		pm_id = REQUEST_SUSPEND;
+	else if (strncasecmp(pm_api_req, "SELF_SUSPEND", 12) == 0)
+		pm_id = SELF_SUSPEND;
+	else if (strncasecmp(pm_api_req, "FORCE_POWERDOWN", 15) == 0)
+		pm_id = FORCE_POWERDOWN;
+	else if (strncasecmp(pm_api_req, "ABORT_SUSPEND", 13) == 0)
+		pm_id = ABORT_SUSPEND;
+	else if (strncasecmp(pm_api_req, "REQUEST_WAKEUP", 14) == 0)
+		pm_id = REQUEST_WAKEUP;
+	else if (strncasecmp(pm_api_req, "SET_WAKEUP_SOURCE", 17) == 0)
+		pm_id = SET_WAKEUP_SOURCE;
+	else if (strncasecmp(pm_api_req, "SYSTEM_SHUTDOWN", 15) == 0)
+		pm_id = SYSTEM_SHUTDOWN;
+	else if (strncasecmp(pm_api_req, "REQUEST_NODE", 12) == 0)
+		pm_id = REQUEST_NODE;
+	else if (strncasecmp(pm_api_req, "RELEASE_NODE", 12) == 0)
+		pm_id = RELEASE_NODE;
+	else if (strncasecmp(pm_api_req, "SET_REQUIREMENT", 15) == 0)
+		pm_id = SET_REQUIREMENT;
+	else if (strncasecmp(pm_api_req, "SET_MAX_LATENCY", 15) == 0)
+		pm_id = SET_MAX_LATENCY;
+	else if (strncasecmp(pm_api_req, "GET_API_VERSION", 15) == 0)
+		pm_id = GET_API_VERSION;
+	else if (strncasecmp(pm_api_req, "SET_CONFIGURATION", 17) == 0)
+		pm_id = SET_CONFIGURATION;
+	else if (strncasecmp(pm_api_req, "GET_NODE_STATUS", 15) == 0)
+		pm_id = GET_NODE_STATUS;
+	else if (strncasecmp(pm_api_req,
+				"GET_OPERATING_CHARACTERISTIC", 28) == 0)
+		pm_id = GET_OPERATING_CHARACTERISTIC;
+	else if (strncasecmp(pm_api_req, "REGISTER_NOTIFIER", 17) == 0)
+		pm_id = REGISTER_NOTIFIER;
+	else if (strncasecmp(pm_api_req, "RESET_ASSERT", 12) == 0)
+		pm_id = RESET_ASSERT;
+	else if (strncasecmp(pm_api_req, "RESET_GET_STATUS", 16) == 0)
+		pm_id = RESET_GET_STATUS;
+	else if (strncasecmp(pm_api_req, "MMIO_READ", 9) == 0)
+		pm_id = MMIO_READ;
+	else if (strncasecmp(pm_api_req, "MMIO_WRITE", 10) == 0)
+		pm_id = MMIO_WRITE;
+	/* If no name was entered look for PM-API ID instead */
+	else if (kstrtouint(pm_api_req, 10, &pm_id))
+		ret = -EINVAL;
+
+	/* Read node_id and arguments from the PM-API request */
+	i = 0;
+	pm_api_req = strsep(&kern_buff, " ");
+	while ((i < ARRAY_SIZE(pm_api_arg)) && pm_api_req) {
+		pm_api_arg[i++] = zynqmp_pm_argument_value(pm_api_req);
+		pm_api_req = strsep(&kern_buff, " ");
+	}
+
+	switch (pm_id) {
+	case GET_API_VERSION:
+		pr_info("%s PM-API Version = %d.%d\n", __func__,
+				pm_api_version >> 16, pm_api_version & 0xffff);
+		break;
+	case REQUEST_SUSPEND:
+		ret = zynqmp_pm_request_suspend(pm_api_arg[0],
+				pm_api_arg[1] ? pm_api_arg[1] :
+						ZYNQMP_PM_REQUEST_ACK_NO,
+				pm_api_arg[2] ? pm_api_arg[2] :
+						ZYNQMP_PM_MAX_LATENCY, 0);
+		break;
+	case SELF_SUSPEND:
+		ret = zynqmp_pm_self_suspend(pm_api_arg[0],
+				pm_api_arg[1] ? pm_api_arg[1] :
+						ZYNQMP_PM_MAX_LATENCY, 0);
+		break;
+	case FORCE_POWERDOWN:
+		ret = zynqmp_pm_force_powerdown(pm_api_arg[0],
+				pm_api_arg[1] ? pm_api_arg[1] :
+						ZYNQMP_PM_REQUEST_ACK_NO);
+		break;
+	case ABORT_SUSPEND:
+		ret = zynqmp_pm_abort_suspend(
+			pm_api_arg[0] ? pm_api_arg[0] :
+					ZYNQMP_PM_ABORT_REASON_UNKNOWN);
+		break;
+	case REQUEST_WAKEUP:
+		ret = zynqmp_pm_request_wakeup(pm_api_arg[0],
+				pm_api_arg[1] ? pm_api_arg[1] :
+						ZYNQMP_PM_REQUEST_ACK_NO);
+		break;
+	case SET_WAKEUP_SOURCE:
+		ret = zynqmp_pm_set_wakeup_source(pm_api_arg[0],
+					pm_api_arg[1], pm_api_arg[2]);
+		break;
+	case SYSTEM_SHUTDOWN:
+		ret = zynqmp_pm_system_shutdown(pm_api_arg[0]);
+		break;
+	case REQUEST_NODE:
+		ret = zynqmp_pm_request_node(pm_api_arg[0],
+			pm_api_arg[1] ? pm_api_arg[1] :
+					ZYNQMP_PM_CAPABILITY_ACCESS,
+			pm_api_arg[2] ? pm_api_arg[2] : 0,
+			pm_api_arg[3] ? pm_api_arg[3] :
+				ZYNQMP_PM_REQUEST_ACK_NON_BLOCKING);
+		break;
+	case RELEASE_NODE:
+		ret = zynqmp_pm_release_node(pm_api_arg[0]);
+		break;
+	case SET_REQUIREMENT:
+		ret = zynqmp_pm_set_requirement(pm_api_arg[0],
+			pm_api_arg[1] ? pm_api_arg[1] :
+					ZYNQMP_PM_CAPABILITY_CONTEXT,
+			pm_api_arg[2] ? pm_api_arg[2] : 0,
+			pm_api_arg[3] ? pm_api_arg[3] :
+				ZYNQMP_PM_REQUEST_ACK_NON_BLOCKING);
+		break;
+	case SET_MAX_LATENCY:
+		ret = zynqmp_pm_set_max_latency(pm_api_arg[0],
+				pm_api_arg[1] ? pm_api_arg[1] :
+						ZYNQMP_PM_MAX_LATENCY);
+		break;
+	case SET_CONFIGURATION:
+		ret = zynqmp_pm_set_configuration(pm_api_arg[0]);
+		break;
+	case GET_NODE_STATUS:
+		ret = zynqmp_pm_get_node_status(pm_api_arg[0]);
+		break;
+	case GET_OPERATING_CHARACTERISTIC:
+		ret = zynqmp_pm_get_operating_characteristic(pm_api_arg[0],
+				pm_api_arg[1] ? pm_api_arg[1] :
+				ZYNQMP_PM_OPERATING_CHARACTERISTIC_POWER);
+		break;
+	case REGISTER_NOTIFIER:
+		ret = zynqmp_pm_register_notifier(pm_api_arg[0],
+				pm_api_arg[1] ? pm_api_arg[1] : 0,
+				pm_api_arg[2] ? pm_api_arg[2] : 0,
+				pm_api_arg[3] ? pm_api_arg[3] : 0);
+		break;
+	case RESET_ASSERT:
+		ret = zynqmp_pm_reset_assert(pm_api_arg[0], pm_api_arg[1]);
+		break;
+	case RESET_GET_STATUS:
+		ret = zynqmp_pm_reset_get_status(pm_api_arg[0], &pm_api_arg[1]);
+		pr_info("%s Reset status: %u\n", __func__, pm_api_arg[1]);
+		break;
+	case MMIO_READ:
+		ret = zynqmp_pm_mmio_read(pm_api_arg[0], &pm_api_arg[1]);
+		pr_info("%s MMIO value: %#x\n", __func__, pm_api_arg[1]);
+		break;
+	case MMIO_WRITE:
+		ret = zynqmp_pm_mmio_write(pm_api_arg[0],
+				     pm_api_arg[1], pm_api_arg[2]);
+		break;
+	default:
+		pr_err("%s Unsupported PM-API request\n", __func__);
+		ret = -EINVAL;
+	}
+
+ err:
+	kfree(kern_buff);
+	if (ret)
+		return ret;
+
+	return len;
+}
+
+/**
+ * zynqmp_pm_debugfs_api_version_read - debugfs read function
+ * @file:	User file structure
+ * @ptr:	Requested pm_api_version string
+ * @len:	Length of the userspace buffer
+ * @off:	Offset within the file
+ *
+ * Return:	Length of the version string on success
+ *		-EFAULT otherwise
+ *
+ * Used to display the pm api version.
+ * cat /sys/kernel/debug/zynqmp_pm/pm_api_version
+ */
+static ssize_t zynqmp_pm_debugfs_api_version_read(struct file *file,
+			char __user *ptr, size_t len, loff_t *off)
+{
+	char *kern_buff;
+	int ret;
+	int kern_buff_len;
+
+	if (len <= 0)
+		return -EINVAL;
+
+	if (*off != 0)
+		return 0;
+
+	kern_buff = kzalloc(len, GFP_KERNEL);
+	if (!kern_buff)
+		return -ENOMEM;
+
+	sprintf(kern_buff, "PM-API Version = %d.%d\n",
+				pm_api_version >> 16, pm_api_version & 0xffff);
+	kern_buff_len = strlen(kern_buff) + 1;
+
+	if (len > kern_buff_len)
+		len = kern_buff_len;
+	ret = copy_to_user(ptr, kern_buff, len);
+
+	kfree(kern_buff);
+	if (ret)
+		return -EFAULT;
+
+	*off = len + 1;
+	return len;
+}
+
+/* Setup debugfs fops */
+static const struct file_operations fops_zynqmp_pm_dbgfs = {
+	.owner  =	THIS_MODULE,
+	.write  =	zynqmp_pm_debugfs_api_write,
+	.read   =	zynqmp_pm_debugfs_api_version_read,
+};
+
+/**
+ * zynqmp_pm_api_debugfs_init - Initialize debugfs interface
+ *
+ * Return:      Returns 0 on success
+ *		Corresponding error code otherwise
+ */
+static int zynqmp_pm_api_debugfs_init(void)
+{
+	int err;
+
+	/* Initialize debugfs interface */
+	zynqmp_pm_debugfs_dir = debugfs_create_dir(DRIVER_NAME, NULL);
+	if (!zynqmp_pm_debugfs_dir) {
+		pr_err("%s debugfs_create_dir failed\n", __func__);
+		return -ENODEV;
+	}
+
+	zynqmp_pm_debugfs_power =
+		debugfs_create_file("power", S_IWUSR | S_IWGRP | S_IWOTH,
+					zynqmp_pm_debugfs_dir, NULL,
+					&fops_zynqmp_pm_dbgfs);
+	if (!zynqmp_pm_debugfs_power) {
+		pr_err("%s debugfs_create_file power failed\n", __func__);
+		err = -ENODEV;
+		goto err_dbgfs;
+	}
+
+	zynqmp_pm_debugfs_api_version =
+		debugfs_create_file("api_version", S_IRUSR | S_IRGRP | S_IROTH,
+					zynqmp_pm_debugfs_dir, NULL,
+					&fops_zynqmp_pm_dbgfs);
+	if (!zynqmp_pm_debugfs_api_version) {
+		pr_err("%s debugfs_create_file api_version failed\n",
+								__func__);
+		err = -ENODEV;
+		goto err_dbgfs;
+	}
+	return 0;
+
+ err_dbgfs:
+	debugfs_remove_recursive(zynqmp_pm_debugfs_dir);
+	zynqmp_pm_debugfs_dir = NULL;
+	return err;
+}
+
+#else
+static int zynqmp_pm_api_debugfs_init(void)
+{
+	return 0;
+}
+
+#endif /* CONFIG_ZYNQMP_PM_API_DEBUGFS */
+
+static const struct of_device_id pm_of_match[] = {
+	{ .compatible = "xlnx,zynqmp-pm", },
+	{ /* end of table */ },
+};
+
+MODULE_DEVICE_TABLE(of, pm_of_match);
+
+/**
+ * get_set_conduit_method - Choose SMC or HVC based communication
+ * @np:	Pointer to the device_node structure
+ *
+ * Use SMC or HVC-based functions to communicate with EL2/EL3
+ */
+static void get_set_conduit_method(struct device_node *np)
+{
+	const char *method;
+	struct device *dev;
+
+	dev = container_of(&np, struct device, of_node);
+
+	if (of_property_read_string(np, "method", &method)) {
+		dev_warn(dev, "%s Missing \"method\" property - defaulting to smc\n",
+			__func__);
+		do_fw_call = do_fw_call_smc;
+		return;
+	}
+
+	if (!strcmp("hvc", method)) {
+		do_fw_call = do_fw_call_hvc;
+
+	} else if (!strcmp("smc", method)) {
+		do_fw_call = do_fw_call_smc;
+	} else {
+		dev_warn(dev, "%s Invalid \"method\" property: %s - defaulting to smc\n",
+			__func__, method);
+		do_fw_call = do_fw_call_smc;
+	}
+}
+
+/**
+ * zynqmp_pm_probe - Probe existence of the PMU Firmware
+ *			and initialize debugfs interface
+ *
+ * @pdev:	Pointer to the platform_device structure
+ *
+ * Return:	Returns 0 on success
+ *		Negative error code otherwise
+ */
+static int zynqmp_pm_probe(struct platform_device *pdev)
+{
+
+	/* Check PM API version number */
+	if (pm_api_version != ZYNQMP_PM_VERSION)
+		return -ENODEV;
+
+	pr_info("%s Power management API v%d.%d\n", __func__,
+		ZYNQMP_PM_VERSION_MAJOR, ZYNQMP_PM_VERSION_MINOR);
+
+	zynqmp_pm_api_debugfs_init();
+
+	return 0;
+}
+
+static struct platform_driver zynqmp_pm_platform_driver = {
+	.probe   = zynqmp_pm_probe,
+	.driver  = {
+			.name             = DRIVER_NAME,
+			.of_match_table   = pm_of_match,
+		   },
+};
+builtin_platform_driver(zynqmp_pm_platform_driver);
+
+static int __init zynqmp_plat_init(void)
+{
+	struct device_node *np;
+	int ret = 0;
+
+	np = of_find_compatible_node(NULL, NULL, "xlnx,zynqmp-pm");
+	if (!np) {
+		pr_err("%s: pm node not found\n", __func__);
+		ret = -ENXIO;
+		goto np_err;
+	}
+
+	get_set_conduit_method(np);
+
+	/* Check PM API version number */
+	zynqmp_pm_get_api_version(&pm_api_version);
+	if (pm_api_version != ZYNQMP_PM_VERSION) {
+		pr_err("%s power management API version error. Expected: v%d.%d - Found: v%d.%d\n",
+		       __func__,
+		       ZYNQMP_PM_VERSION_MAJOR, ZYNQMP_PM_VERSION_MINOR,
+		       pm_api_version >> 16, pm_api_version & 0xffff);
+
+		do_fw_call = do_fw_call_fail;
+	}
+
+	pr_info("%s Power management API v%d.%d\n", __func__,
+		ZYNQMP_PM_VERSION_MAJOR, ZYNQMP_PM_VERSION_MINOR);
+
+np_err:
+	of_node_put(np);
+	return ret;
+}
+
+early_initcall(zynqmp_plat_init);
diff --git a/drivers/soc/xilinx/zynqmp/pm_domains.c b/drivers/soc/xilinx/zynqmp/pm_domains.c
new file mode 100644
index 0000000..a34f51e
--- /dev/null
+++ b/drivers/soc/xilinx/zynqmp/pm_domains.c
@@ -0,0 +1,176 @@
+/*
+ * ZynqMP Generic PM domain support
+ *
+ *  Copyright (C) 2015 Xilinx
+ *
+ *  Davorin Mista <davorin.mista@aggios.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/pm_domain.h>
+#include <linux/slab.h>
+#include <linux/soc/xilinx/zynqmp/pm.h>
+
+#define DRIVER_NAME "zynqmp_gpd"
+
+/**
+ * struct zynqmp_pm_domain - Wrapper around struct generic_pm_domain
+ * @gpd:		Generic power domain
+ * @node_id:	PM node id of a device inside PM domain
+ */
+struct zynqmp_pm_domain {
+	struct generic_pm_domain gpd;
+	u32 node_id;
+};
+
+/**
+ * zynqmp_gpd_set_power - power on/off PM domain
+ * @domain:	Generic PM domain
+ * @power_on:	Flag to specify whether to power on or off PM domain
+ *
+ * This functions calls zynqmp_pm_set_requirement to trigger power state change
+ * of a resource (device inside PM domain), depending on power_on flag.
+ *
+ * Return:	0 on success, error code otherwise.
+ */
+static int zynqmp_gpd_set_power(struct generic_pm_domain *domain, bool power_on)
+{
+	int status;
+	struct zynqmp_pm_domain *pd;
+
+	pd = container_of(domain, struct zynqmp_pm_domain, gpd);
+	if (pd->node_id == 0) {
+		pr_err("%s: unknown node specified, powering %s domain %s\n",
+			__func__, power_on ? "on" : "off", pd->gpd.name);
+		return -EINVAL;
+	}
+
+	if (!power_on)
+		status = zynqmp_pm_set_requirement(pd->node_id, 0, 0,
+						ZYNQMP_PM_REQUEST_ACK_NO);
+	else
+		status = zynqmp_pm_set_requirement(pd->node_id,
+						ZYNQMP_PM_CAPABILITY_ACCESS,
+						ZYNQMP_PM_MAX_QOS,
+						ZYNQMP_PM_REQUEST_ACK_NO);
+	return status;
+}
+
+/**
+ * zynqmp_gpd_power_on - Power on PM domain
+ * @domain:	Generic PM domain
+ *
+ * This function is called before devices inside a PM domain are resumed, to
+ * power on PM domain.
+ *
+ * Return:	0 on success, error code otherwise.
+ */
+static int zynqmp_gpd_power_on(struct generic_pm_domain *domain)
+{
+	return zynqmp_gpd_set_power(domain, true);
+}
+
+/**
+ * zynqmp_gpd_power_off - Power off PM domain
+ * @domain:	Generic PM domain
+ *
+ * This function is called after devices inside a PM domain are suspended, to
+ * power off PM domain.
+ *
+ * Return:	0 on success, error code otherwise.
+ */
+static int zynqmp_gpd_power_off(struct generic_pm_domain *domain)
+{
+	return zynqmp_gpd_set_power(domain, false);
+}
+
+/**
+ * zynqmp_gpd_probe - Initialize ZynqMP specific PM domains
+ * @pdev:	Platform device pointer
+ *
+ * Description:	This function populates struct zynqmp_pm_domain for each PM
+ * domain and initalizes generic PM domain. If the "pd-id" DT property
+ * of a certain domain is missing or invalid, that domain will be skipped.
+ *
+ * Return:	0 on success, error code otherwise.
+ */
+static int __init zynqmp_gpd_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct device_node *child_err, *child, *np = pdev->dev.of_node;
+
+	for_each_child_of_node(np, child) {
+		u32 node_id;
+		struct zynqmp_pm_domain *pd;
+
+		pd = devm_kzalloc(&pdev->dev, sizeof(*pd), GFP_KERNEL);
+		if (!pd) {
+			ret = -ENOMEM;
+			goto err_cleanup;
+		}
+
+		ret = of_property_read_u32(child, "pd-id", &node_id);
+		if (ret)
+			goto err_cleanup;
+
+		pd->node_id = node_id;
+		pd->gpd.name = kstrdup(child->name, GFP_KERNEL);
+		pd->gpd.power_off = zynqmp_gpd_power_off;
+		pd->gpd.power_on = zynqmp_gpd_power_on;
+
+		ret = of_genpd_add_provider_simple(child, &pd->gpd);
+		if (ret)
+			goto err_cleanup;
+
+		pm_genpd_init(&pd->gpd, NULL, false);
+	}
+
+	return 0;
+
+err_cleanup:
+	child_err = child;
+	for_each_child_of_node(np, child) {
+		if (child == child_err)
+			break;
+		of_genpd_del_provider(child);
+	}
+
+	return ret;
+}
+
+static const struct of_device_id zynqmp_gpd_of_match[] = {
+	{ .compatible = "xlnx,zynqmp-genpd" },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, zynqmp_gpd_of_match);
+
+static struct platform_driver zynqmp_gpd_platform_driver = {
+	.driver	= {
+		.name = DRIVER_NAME,
+		.of_match_table = zynqmp_gpd_of_match,
+	},
+};
+
+static __init int zynqmp_gpd_init(void)
+{
+	return platform_driver_probe(&zynqmp_gpd_platform_driver,
+				     zynqmp_gpd_probe);
+}
+subsys_initcall(zynqmp_gpd_init);
diff --git a/drivers/soc/xilinx/zynqmp/tap_delays.c b/drivers/soc/xilinx/zynqmp/tap_delays.c
new file mode 100644
index 0000000..08d357e
--- /dev/null
+++ b/drivers/soc/xilinx/zynqmp/tap_delays.c
@@ -0,0 +1,302 @@
+/*
+ * Xilinx Zynq MPSoC Tap Delay Programming
+ *
+ *  Copyright (C) 2016 Xilinx, Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/soc/xilinx/zynqmp/tap_delays.h>
+
+#define SD_DLL_CTRL			0xFF180358
+#define SD_ITAP_DLY			0xFF180314
+#define SD_OTAP_DLY			0xFF180318
+#define SD0_DLL_RST_MASK		0x00000004
+#define SD0_DLL_RST			0x00000004
+#define SD1_DLL_RST_MASK		0x00040000
+#define SD1_DLL_RST			0x00040000
+#define SD0_ITAPCHGWIN_MASK		0x00000200
+#define SD0_ITAPCHGWIN			0x00000200
+#define SD1_ITAPCHGWIN_MASK		0x02000000
+#define SD1_ITAPCHGWIN			0x02000000
+#define SD0_ITAPDLYENA_MASK		0x00000100
+#define SD0_ITAPDLYENA			0x00000100
+#define SD1_ITAPDLYENA_MASK		0x01000000
+#define SD1_ITAPDLYENA			0x01000000
+#define SD0_ITAPDLYSEL_MASK		0x000000FF
+#define SD0_ITAPDLYSEL_HSD		0x00000015
+#define SD0_ITAPDLYSEL_SD_DDR50		0x0000003D
+#define SD0_ITAPDLYSEL_MMC_DDR50	0x00000012
+
+#define SD1_ITAPDLYSEL_MASK		0x00FF0000
+#define SD1_ITAPDLYSEL_HSD		0x00150000
+#define SD1_ITAPDLYSEL_SD_DDR50		0x003D0000
+#define SD1_ITAPDLYSEL_MMC_DDR50	0x00120000
+
+#define SD0_OTAPDLYENA_MASK		0x00000040
+#define SD0_OTAPDLYENA			0x00000040
+#define SD1_OTAPDLYENA_MASK		0x00400000
+#define SD1_OTAPDLYENA			0x00400000
+#define SD0_OTAPDLYSEL_MASK		0x0000003F
+#define SD0_OTAPDLYSEL_MMC_HSD		0x00000006
+#define SD0_OTAPDLYSEL_SD_HSD		0x00000005
+#define SD0_OTAPDLYSEL_SDR50		0x00000003
+#define SD0_OTAPDLYSEL_SDR104_B0	0x00000003
+#define SD0_OTAPDLYSEL_SDR104_B2	0x00000002
+#define SD0_OTAPDLYSEL_SD_DDR50		0x00000004
+#define SD0_OTAPDLYSEL_MMC_DDR50	0x00000006
+
+#define SD1_OTAPDLYSEL_MASK		0x003F0000
+#define SD1_OTAPDLYSEL_MMC_HSD		0x00060000
+#define SD1_OTAPDLYSEL_SD_HSD		0x00050000
+#define SD1_OTAPDLYSEL_SDR50		0x00030000
+#define SD1_OTAPDLYSEL_SDR104_B0	0x00030000
+#define SD1_OTAPDLYSEL_SDR104_B2	0x00020000
+#define SD1_OTAPDLYSEL_SD_DDR50		0x00040000
+#define SD1_OTAPDLYSEL_MMC_DDR50	0x00060000
+
+#define MMC_BANK2		0x2
+
+#define MMC_TIMING_MMC_HS       1
+#define MMC_TIMING_SD_HS        2
+#define MMC_TIMING_UHS_SDR25    4
+#define MMC_TIMING_UHS_SDR50    5
+#define MMC_TIMING_UHS_SDR104   6
+#define MMC_TIMING_UHS_DDR50    7
+#define MMC_TIMING_MMC_DDR52    8
+#define MMC_TIMING_MMC_HS200    9
+
+/**
+ * arasan_zynqmp_tap_sdr104 - Program the tap delys for HS and SDR25 modes.
+ * @deviceid:		Unique Id of device
+ * @timing:		timing specification used
+ * @bank:		MIO bank for SDIO
+ */
+static void arasan_zynqmp_tap_hs(u8 deviceid, u8 timing, u8 bank)
+{
+	if (deviceid == 0) {
+		/* Program ITAP */
+		zynqmp_pm_mmio_write(SD_ITAP_DLY, SD0_ITAPCHGWIN_MASK,
+				     SD0_ITAPCHGWIN);
+		zynqmp_pm_mmio_write(SD_ITAP_DLY, SD0_ITAPDLYENA_MASK,
+				     SD0_ITAPDLYENA);
+		zynqmp_pm_mmio_write(SD_ITAP_DLY, SD0_ITAPDLYSEL_MASK,
+				     SD0_ITAPDLYSEL_HSD);
+		zynqmp_pm_mmio_write(SD_ITAP_DLY, SD0_ITAPCHGWIN_MASK, 0x0);
+		/* Program OTAP */
+		zynqmp_pm_mmio_write(SD_OTAP_DLY, SD0_OTAPDLYENA_MASK,
+				     SD0_OTAPDLYENA);
+		if (timing == MMC_TIMING_MMC_HS)
+			zynqmp_pm_mmio_write(SD_OTAP_DLY, SD0_OTAPDLYSEL_MASK,
+					     SD0_OTAPDLYSEL_MMC_HSD);
+		else
+			zynqmp_pm_mmio_write(SD_OTAP_DLY, SD0_OTAPDLYSEL_MASK,
+					     SD0_OTAPDLYSEL_SD_HSD);
+	} else {
+		/* Program ITAP */
+		zynqmp_pm_mmio_write(SD_ITAP_DLY, SD1_ITAPCHGWIN_MASK,
+				     SD1_ITAPCHGWIN);
+		zynqmp_pm_mmio_write(SD_ITAP_DLY, SD1_ITAPDLYENA_MASK,
+				     SD1_ITAPDLYENA);
+		zynqmp_pm_mmio_write(SD_ITAP_DLY, SD1_ITAPDLYSEL_MASK,
+				     SD1_ITAPDLYSEL_HSD);
+		zynqmp_pm_mmio_write(SD_ITAP_DLY, SD1_ITAPCHGWIN_MASK, 0x0);
+		/* Program OTAP */
+		zynqmp_pm_mmio_write(SD_OTAP_DLY, SD1_OTAPDLYENA_MASK,
+				     SD1_OTAPDLYENA);
+		if (timing == MMC_TIMING_MMC_HS)
+			zynqmp_pm_mmio_write(SD_OTAP_DLY, SD1_OTAPDLYSEL_MASK,
+					     SD1_OTAPDLYSEL_MMC_HSD);
+		else
+			zynqmp_pm_mmio_write(SD_OTAP_DLY, SD1_OTAPDLYSEL_MASK,
+					     SD1_OTAPDLYSEL_SD_HSD);
+	}
+}
+
+/**
+ * arasan_zynqmp_tap_ddr50 - Program the tap delys for DDR50 and DDR52 modes.
+ * @deviceid:		Unique Id of device
+ * @timing:		timing specification used
+ * @bank:		MIO bank for SDIO
+ */
+static void arasan_zynqmp_tap_ddr50(u8 deviceid, u8 timing, u8 bank)
+{
+	if (deviceid == 0) {
+		/* Program ITAP */
+		zynqmp_pm_mmio_write(SD_ITAP_DLY, SD0_ITAPCHGWIN_MASK,
+				     SD0_ITAPCHGWIN);
+		zynqmp_pm_mmio_write(SD_ITAP_DLY, SD0_ITAPDLYENA_MASK,
+				     SD0_ITAPDLYENA);
+		if (timing == MMC_TIMING_UHS_DDR50)
+			zynqmp_pm_mmio_write(SD_ITAP_DLY, SD0_ITAPDLYSEL_MASK,
+					     SD0_ITAPDLYSEL_SD_DDR50);
+		else
+			zynqmp_pm_mmio_write(SD_ITAP_DLY, SD0_ITAPDLYSEL_MASK,
+					     SD0_ITAPDLYSEL_MMC_DDR50);
+		zynqmp_pm_mmio_write(SD_ITAP_DLY, SD0_ITAPCHGWIN_MASK, 0x0);
+		/* Program OTAP */
+		zynqmp_pm_mmio_write(SD_OTAP_DLY, SD0_OTAPDLYENA_MASK,
+				     SD0_OTAPDLYENA);
+		if (timing == MMC_TIMING_UHS_DDR50)
+			zynqmp_pm_mmio_write(SD_OTAP_DLY, SD0_OTAPDLYSEL_MASK,
+					     SD0_OTAPDLYSEL_SD_DDR50);
+		else
+			zynqmp_pm_mmio_write(SD_OTAP_DLY, SD0_OTAPDLYSEL_MASK,
+					     SD0_OTAPDLYSEL_MMC_DDR50);
+	} else {
+		/* Program ITAP */
+		zynqmp_pm_mmio_write(SD_ITAP_DLY, SD1_ITAPCHGWIN_MASK,
+				     SD1_ITAPCHGWIN);
+		zynqmp_pm_mmio_write(SD_ITAP_DLY, SD1_ITAPDLYENA_MASK,
+				     SD1_ITAPDLYENA);
+		if (timing == MMC_TIMING_UHS_DDR50)
+			zynqmp_pm_mmio_write(SD_ITAP_DLY, SD1_ITAPDLYSEL_MASK,
+					     SD1_ITAPDLYSEL_SD_DDR50);
+		else
+			zynqmp_pm_mmio_write(SD_ITAP_DLY, SD1_ITAPDLYSEL_MASK,
+					     SD1_ITAPDLYSEL_MMC_DDR50);
+		zynqmp_pm_mmio_write(SD_ITAP_DLY, SD1_ITAPCHGWIN_MASK, 0x0);
+		/* Program OTAP */
+		zynqmp_pm_mmio_write(SD_OTAP_DLY, SD1_OTAPDLYENA_MASK,
+				     SD1_OTAPDLYENA);
+		if (timing == MMC_TIMING_UHS_DDR50)
+			zynqmp_pm_mmio_write(SD_OTAP_DLY, SD1_OTAPDLYSEL_MASK,
+					     SD1_OTAPDLYSEL_SD_DDR50);
+		else
+			zynqmp_pm_mmio_write(SD_OTAP_DLY, SD1_OTAPDLYSEL_MASK,
+					     SD1_OTAPDLYSEL_MMC_DDR50);
+	}
+}
+
+/**
+ * arasan_zynqmp_tap_sdr50 - Program the tap delys for SDR50 mode.
+ * @deviceid:		Unique Id of device
+ * @timing:		timing specification used
+ * @bank:		MIO bank for SDIO
+ */
+static void arasan_zynqmp_tap_sdr50(u8 deviceid, u8 timing, u8 bank)
+{
+	if (deviceid == 0) {
+		/* Program OTAP */
+		zynqmp_pm_mmio_write(SD_OTAP_DLY, SD0_OTAPDLYENA_MASK,
+				     SD0_OTAPDLYENA);
+		zynqmp_pm_mmio_write(SD_OTAP_DLY, SD0_OTAPDLYSEL_MASK,
+				     SD0_OTAPDLYSEL_SDR50);
+	} else {
+		/* Program OTAP */
+		zynqmp_pm_mmio_write(SD_OTAP_DLY, SD1_OTAPDLYENA_MASK,
+				     SD1_OTAPDLYENA);
+		zynqmp_pm_mmio_write(SD_OTAP_DLY, SD1_OTAPDLYSEL_MASK,
+				     SD1_OTAPDLYSEL_SDR50);
+	}
+}
+
+/**
+ * arasan_zynqmp_tap_sdr104 - Program the tap delys for SDR104 and HS200 modes.
+ * @deviceid:		Unique Id of device
+ * @timing:		timing specification used
+ * @bank:		MIO bank for SDIO
+ */
+static void arasan_zynqmp_tap_sdr104(u8 deviceid, u8 timing, u8 bank)
+{
+	if (deviceid == 0) {
+		/* Program OTAP */
+		zynqmp_pm_mmio_write(SD_OTAP_DLY, SD0_OTAPDLYENA_MASK,
+				     SD0_OTAPDLYENA);
+		if (bank == MMC_BANK2)
+			zynqmp_pm_mmio_write(SD_OTAP_DLY, SD0_OTAPDLYSEL_MASK,
+					     SD0_OTAPDLYSEL_SDR104_B2);
+		else
+			zynqmp_pm_mmio_write(SD_OTAP_DLY, SD0_OTAPDLYSEL_MASK,
+					     SD0_OTAPDLYSEL_SDR104_B0);
+	} else {
+		/* Program OTAP */
+		zynqmp_pm_mmio_write(SD_OTAP_DLY, SD1_OTAPDLYENA_MASK,
+				     SD1_OTAPDLYENA);
+		if (bank == MMC_BANK2)
+			zynqmp_pm_mmio_write(SD_OTAP_DLY, SD1_OTAPDLYSEL_MASK,
+					     SD1_OTAPDLYSEL_SDR104_B2);
+		else
+			zynqmp_pm_mmio_write(SD_OTAP_DLY, SD1_OTAPDLYSEL_MASK,
+					     SD1_OTAPDLYSEL_SDR104_B0);
+	}
+}
+
+/**
+ * arasan_zynqmp_set_tap_delay - Program the tap delys based on the mmc timing.
+ * @deviceid:		Unique Id of device
+ * @timing:		Timing specification used
+ * @bank:		MIO bank for SDIO
+ */
+void arasan_zynqmp_set_tap_delay(u8 deviceid, u8 timing, u8 bank)
+{
+	if (deviceid == 0)
+		zynqmp_pm_mmio_write(SD_DLL_CTRL, SD0_DLL_RST_MASK,
+				     SD0_DLL_RST);
+	else
+		zynqmp_pm_mmio_write(SD_DLL_CTRL, SD1_DLL_RST_MASK,
+				     SD1_DLL_RST);
+
+	switch (timing) {
+	case MMC_TIMING_SD_HS:
+	case MMC_TIMING_MMC_HS:
+	case MMC_TIMING_UHS_SDR25:
+		arasan_zynqmp_tap_hs(deviceid, timing, bank);
+		break;
+	case MMC_TIMING_UHS_SDR50:
+		arasan_zynqmp_tap_sdr50(deviceid, timing, bank);
+		break;
+	case MMC_TIMING_UHS_SDR104:
+	case MMC_TIMING_MMC_HS200:
+		arasan_zynqmp_tap_sdr104(deviceid, timing, bank);
+		break;
+	case MMC_TIMING_UHS_DDR50:
+	case MMC_TIMING_MMC_DDR52:
+		arasan_zynqmp_tap_ddr50(deviceid, timing, bank);
+		break;
+	}
+
+	if (deviceid == 0)
+		zynqmp_pm_mmio_write(SD_DLL_CTRL, SD0_DLL_RST_MASK, 0x0);
+	else
+		zynqmp_pm_mmio_write(SD_DLL_CTRL, SD1_DLL_RST_MASK, 0x0);
+
+}
+EXPORT_SYMBOL_GPL(arasan_zynqmp_set_tap_delay);
+
+/**
+ * arasan_zynqmp_dll_reset - Issue the DLL reset.
+ * @deviceid:		Unique Id of device
+ */
+void zynqmp_dll_reset(u8 deviceid)
+{
+	/* Issue DLL Reset */
+	if (deviceid == 0)
+		zynqmp_pm_mmio_write(SD_DLL_CTRL, SD0_DLL_RST_MASK,
+				     SD0_DLL_RST);
+	else
+		zynqmp_pm_mmio_write(SD_DLL_CTRL, SD1_DLL_RST_MASK,
+				     SD1_DLL_RST);
+
+	mdelay(1);
+
+	/* Release DLL Reset */
+	if (deviceid == 0)
+		zynqmp_pm_mmio_write(SD_DLL_CTRL, SD0_DLL_RST_MASK, 0x0);
+	else
+		zynqmp_pm_mmio_write(SD_DLL_CTRL, SD1_DLL_RST_MASK, 0x0);
+}
+EXPORT_SYMBOL_GPL(zynqmp_dll_reset);
diff --git a/include/linux/soc/xilinx/zynqmp/pm.h b/include/linux/soc/xilinx/zynqmp/pm.h
new file mode 100644
index 0000000..0a353bb
--- /dev/null
+++ b/include/linux/soc/xilinx/zynqmp/pm.h
@@ -0,0 +1,248 @@
+/*
+ * Xilinx Zynq MPSoC Power Management
+ *
+ *  Copyright (C) 2014-2015 Xilinx
+ *
+ *  Davorin Mista <davorin.mista@aggios.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __SOC_ZYNQMP_PM_H__
+#define __SOC_ZYNQMP_PM_H__
+
+#define ZYNQMP_PM_VERSION_MAJOR	0
+#define ZYNQMP_PM_VERSION_MINOR	2
+
+#define ZYNQMP_PM_VERSION	((ZYNQMP_PM_VERSION_MAJOR << 16) | \
+					ZYNQMP_PM_VERSION_MINOR)
+
+#define ZYNQMP_PM_MAX_LATENCY	(~0U)
+#define ZYNQMP_PM_MAX_QOS	100U
+
+/* Capabilities for RAM */
+#define	ZYNQMP_PM_CAPABILITY_ACCESS	0x1U
+#define	ZYNQMP_PM_CAPABILITY_CONTEXT	0x2U
+#define	ZYNQMP_PM_CAPABILITY_WAKEUP	0x4U
+#define	ZYNQMP_PM_CAPABILITY_POWER	0x8U
+
+enum zynqmp_pm_request_ack {
+	ZYNQMP_PM_REQUEST_ACK_NO = 1,
+	ZYNQMP_PM_REQUEST_ACK_BLOCKING,
+	ZYNQMP_PM_REQUEST_ACK_NON_BLOCKING,
+};
+
+enum zynqmp_pm_abort_reason {
+	ZYNQMP_PM_ABORT_REASON_WAKEUP_EVENT = 100,
+	ZYNQMP_PM_ABORT_REASON_POWER_UNIT_BUSY,
+	ZYNQMP_PM_ABORT_REASON_NO_POWERDOWN,
+	ZYNQMP_PM_ABORT_REASON_UNKNOWN,
+};
+
+enum zynqmp_pm_suspend_reason {
+	ZYNQMP_PM_SUSPEND_REASON_POWER_UNIT_REQUEST = 201,
+	ZYNQMP_PM_SUSPEND_REASON_ALERT,
+	ZYNQMP_PM_SUSPEND_REASON_SYSTEM_SHUTDOWN,
+};
+
+enum zynqmp_pm_ram_state {
+	ZYNQMP_PM_RAM_STATE_OFF = 1,
+	ZYNQMP_PM_RAM_STATE_RETENTION,
+	ZYNQMP_PM_RAM_STATE_ON,
+};
+
+enum zynqmp_pm_opchar_type {
+	ZYNQMP_PM_OPERATING_CHARACTERISTIC_POWER = 1,
+	ZYNQMP_PM_OPERATING_CHARACTERISTIC_ENERGY,
+	ZYNQMP_PM_OPERATING_CHARACTERISTIC_TEMPERATURE,
+};
+
+enum zynqmp_pm_reset_action {
+	PM_RESET_ACTION_RELEASE,
+	PM_RESET_ACTION_ASSERT,
+	PM_RESET_ACTION_PULSE,
+};
+
+enum zynqmp_pm_reset {
+	ZYNQMP_PM_RESET_START = 999,
+	ZYNQMP_PM_RESET_PCIE_CFG,
+	ZYNQMP_PM_RESET_PCIE_BRIDGE,
+	ZYNQMP_PM_RESET_PCIE_CTRL,
+	ZYNQMP_PM_RESET_DP,
+	ZYNQMP_PM_RESET_SWDT_CRF,
+	ZYNQMP_PM_RESET_AFI_FM5,
+	ZYNQMP_PM_RESET_AFI_FM4,
+	ZYNQMP_PM_RESET_AFI_FM3,
+	ZYNQMP_PM_RESET_AFI_FM2,
+	ZYNQMP_PM_RESET_AFI_FM1,
+	ZYNQMP_PM_RESET_AFI_FM0,
+	ZYNQMP_PM_RESET_GDMA,
+	ZYNQMP_PM_RESET_GPU_PP1,
+	ZYNQMP_PM_RESET_GPU_PP0,
+	ZYNQMP_PM_RESET_GPU,
+	ZYNQMP_PM_RESET_GT,
+	ZYNQMP_PM_RESET_SATA,
+	ZYNQMP_PM_RESET_ACPU3_PWRON,
+	ZYNQMP_PM_RESET_ACPU2_PWRON,
+	ZYNQMP_PM_RESET_ACPU1_PWRON,
+	ZYNQMP_PM_RESET_ACPU0_PWRON,
+	ZYNQMP_PM_RESET_APU_L2,
+	ZYNQMP_PM_RESET_ACPU3,
+	ZYNQMP_PM_RESET_ACPU2,
+	ZYNQMP_PM_RESET_ACPU1,
+	ZYNQMP_PM_RESET_ACPU0,
+	ZYNQMP_PM_RESET_DDR,
+	ZYNQMP_PM_RESET_APM_FPD,
+	ZYNQMP_PM_RESET_SOFT,
+	ZYNQMP_PM_RESET_GEM0,
+	ZYNQMP_PM_RESET_GEM1,
+	ZYNQMP_PM_RESET_GEM2,
+	ZYNQMP_PM_RESET_GEM3,
+	ZYNQMP_PM_RESET_QSPI,
+	ZYNQMP_PM_RESET_UART0,
+	ZYNQMP_PM_RESET_UART1,
+	ZYNQMP_PM_RESET_SPI0,
+	ZYNQMP_PM_RESET_SPI1,
+	ZYNQMP_PM_RESET_SDIO0,
+	ZYNQMP_PM_RESET_SDIO1,
+	ZYNQMP_PM_RESET_CAN0,
+	ZYNQMP_PM_RESET_CAN1,
+	ZYNQMP_PM_RESET_I2C0,
+	ZYNQMP_PM_RESET_I2C1,
+	ZYNQMP_PM_RESET_TTC0,
+	ZYNQMP_PM_RESET_TTC1,
+	ZYNQMP_PM_RESET_TTC2,
+	ZYNQMP_PM_RESET_TTC3,
+	ZYNQMP_PM_RESET_SWDT_CRL,
+	ZYNQMP_PM_RESET_NAND,
+	ZYNQMP_PM_RESET_ADMA,
+	ZYNQMP_PM_RESET_GPIO,
+	ZYNQMP_PM_RESET_IOU_CC,
+	ZYNQMP_PM_RESET_TIMESTAMP,
+	ZYNQMP_PM_RESET_RPU_R50,
+	ZYNQMP_PM_RESET_RPU_R51,
+	ZYNQMP_PM_RESET_RPU_AMBA,
+	ZYNQMP_PM_RESET_OCM,
+	ZYNQMP_PM_RESET_RPU_PGE,
+	ZYNQMP_PM_RESET_USB0_CORERESET,
+	ZYNQMP_PM_RESET_USB1_CORERESET,
+	ZYNQMP_PM_RESET_USB0_HIBERRESET,
+	ZYNQMP_PM_RESET_USB1_HIBERRESET,
+	ZYNQMP_PM_RESET_USB0_APB,
+	ZYNQMP_PM_RESET_USB1_APB,
+	ZYNQMP_PM_RESET_IPI,
+	ZYNQMP_PM_RESET_APM_LPD,
+	ZYNQMP_PM_RESET_RTC,
+	ZYNQMP_PM_RESET_SYSMON,
+	ZYNQMP_PM_RESET_AFI_FM6,
+	ZYNQMP_PM_RESET_LPD_SWDT,
+	ZYNQMP_PM_RESET_FPD,
+	ZYNQMP_PM_RESET_RPU_DBG1,
+	ZYNQMP_PM_RESET_RPU_DBG0,
+	ZYNQMP_PM_RESET_DBG_LPD,
+	ZYNQMP_PM_RESET_DBG_FPD,
+	ZYNQMP_PM_RESET_APLL,
+	ZYNQMP_PM_RESET_DPLL,
+	ZYNQMP_PM_RESET_VPLL,
+	ZYNQMP_PM_RESET_IOPLL,
+	ZYNQMP_PM_RESET_RPLL,
+	ZYNQMP_PM_RESET_GPO3_PL_0,
+	ZYNQMP_PM_RESET_GPO3_PL_1,
+	ZYNQMP_PM_RESET_GPO3_PL_2,
+	ZYNQMP_PM_RESET_GPO3_PL_3,
+	ZYNQMP_PM_RESET_GPO3_PL_4,
+	ZYNQMP_PM_RESET_GPO3_PL_5,
+	ZYNQMP_PM_RESET_GPO3_PL_6,
+	ZYNQMP_PM_RESET_GPO3_PL_7,
+	ZYNQMP_PM_RESET_GPO3_PL_8,
+	ZYNQMP_PM_RESET_GPO3_PL_9,
+	ZYNQMP_PM_RESET_GPO3_PL_10,
+	ZYNQMP_PM_RESET_GPO3_PL_11,
+	ZYNQMP_PM_RESET_GPO3_PL_12,
+	ZYNQMP_PM_RESET_GPO3_PL_13,
+	ZYNQMP_PM_RESET_GPO3_PL_14,
+	ZYNQMP_PM_RESET_GPO3_PL_15,
+	ZYNQMP_PM_RESET_GPO3_PL_16,
+	ZYNQMP_PM_RESET_GPO3_PL_17,
+	ZYNQMP_PM_RESET_GPO3_PL_18,
+	ZYNQMP_PM_RESET_GPO3_PL_19,
+	ZYNQMP_PM_RESET_GPO3_PL_20,
+	ZYNQMP_PM_RESET_GPO3_PL_21,
+	ZYNQMP_PM_RESET_GPO3_PL_22,
+	ZYNQMP_PM_RESET_GPO3_PL_23,
+	ZYNQMP_PM_RESET_GPO3_PL_24,
+	ZYNQMP_PM_RESET_GPO3_PL_25,
+	ZYNQMP_PM_RESET_GPO3_PL_26,
+	ZYNQMP_PM_RESET_GPO3_PL_27,
+	ZYNQMP_PM_RESET_GPO3_PL_28,
+	ZYNQMP_PM_RESET_GPO3_PL_29,
+	ZYNQMP_PM_RESET_GPO3_PL_30,
+	ZYNQMP_PM_RESET_GPO3_PL_31,
+	ZYNQMP_PM_RESET_RPU_LS,
+	ZYNQMP_PM_RESET_PS_ONLY,
+	ZYNQMP_PM_RESET_PL,
+	ZYNQMP_PM_RESET_END
+};
+
+/*
+ * OS-level PM API
+ */
+
+/* API for suspending of APU */
+int zynqmp_pm_request_suspend(const u32 node,
+				      const enum zynqmp_pm_request_ack ack,
+				      const u32 latency,
+				      const u32 state);
+int zynqmp_pm_request_wakeup(const u32 node,
+				     const enum zynqmp_pm_request_ack ack);
+int zynqmp_pm_set_wakeup_source(const u32 target,
+					const u32 wakeup_node,
+					const u32 enable);
+int zynqmp_pm_system_shutdown(const u32 restart);
+
+/* API for suspending of RPU */
+int zynqmp_pm_force_powerdown(const u32 target,
+					const enum zynqmp_pm_request_ack ack);
+
+/* API functions for managing PM Slaves */
+int zynqmp_pm_request_node(const u32 node,
+				   const u32 capabilities,
+				   const u32 qos,
+				   const enum zynqmp_pm_request_ack ack);
+int zynqmp_pm_release_node(const u32 node);
+int zynqmp_pm_set_requirement(const u32 node,
+				   const u32 capabilities,
+				   const u32 qos,
+				   const enum zynqmp_pm_request_ack ack);
+int zynqmp_pm_set_max_latency(const u32 node,
+					  const u32 latency);
+
+/* Miscellaneous API functions */
+int zynqmp_pm_get_api_version(u32 *version);
+int zynqmp_pm_set_configuration(const u32 physical_addr);
+int zynqmp_pm_get_node_status(const u32 node);
+int zynqmp_pm_get_operating_characteristic(const u32 node,
+					const enum zynqmp_pm_opchar_type type);
+
+/* Direct-Control API functions */
+int zynqmp_pm_reset_assert(const enum zynqmp_pm_reset reset,
+				const enum zynqmp_pm_reset_action assert_flag);
+int zynqmp_pm_reset_get_status(const enum zynqmp_pm_reset reset,
+					u32 *status);
+int zynqmp_pm_mmio_write(const u32 address,
+				     const u32 mask,
+				     const u32 value);
+int zynqmp_pm_mmio_read(const u32 address, u32 *value);
+
+#endif /* __SOC_ZYNQMP_PM_H__ */
diff --git a/include/linux/soc/xilinx/zynqmp/tap_delays.h b/include/linux/soc/xilinx/zynqmp/tap_delays.h
new file mode 100644
index 0000000..75d39b7
--- /dev/null
+++ b/include/linux/soc/xilinx/zynqmp/tap_delays.h
@@ -0,0 +1,31 @@
+/*
+ * Xilinx Zynq MPSoC Power Management
+ *
+ *  Copyright (C) 2016 Xilinx
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/soc/xilinx/zynqmp/pm.h>
+
+#ifdef CONFIG_SOC_XILINX_ZYNQMP
+/* API for programming the tap delays */
+void arasan_zynqmp_set_tap_delay(u8 deviceid, u8 timing, u8 bank);
+
+/* API to reset the DLL */
+void zynqmp_dll_reset(u8 deviceid);
+#else
+inline void arasan_zynqmp_set_tap_delay(u8 deviceid, u8 timing, u8 bank) {}
+inline void zynqmp_dll_reset(u8 deviceid) {}
+#endif
-- 
2.0.2

