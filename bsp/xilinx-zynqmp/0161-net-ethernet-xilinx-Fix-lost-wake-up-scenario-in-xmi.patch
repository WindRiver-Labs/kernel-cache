From 1f21e698c2112b09ae7c3c182d4b41b6fde520be Mon Sep 17 00:00:00 2001
From: Kedareswara rao Appana <appana.durga.rao@xilinx.com>
Date: Thu, 10 Sep 2015 22:24:52 +0530
Subject: [PATCH 161/188] net: ethernet: xilinx: Fix lost wake-up scenario in
 xmit

This patch comes from:
  https://github.com/Xilinx/linux-xlnx.git

In ndo_start_xmit we are checking for free BD count
and incase there are no available BD's we stop
the networking stack.

If these sequence of operation are preemted then
it will lead to classic Lost Wake-Up Problem.

If interrupt comes after xmit has checked  BD
count and TX post processing clears up the BD and
issue wake-up and then later xmit goes for a wait.
There is no one to wake up xmit and as wake-up
event is lost.

Signed-off-by: Radhey Shyam Pandey <radheys@xilinx.com>
Signed-off-by: Kedareswara rao Appana <appanad@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
(cherry picked from commit 27523ecfddd8277ca313da9c32d9f0bef4412411)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/xilinx/xilinx_axienet.h      | 2 ++
 drivers/net/ethernet/xilinx/xilinx_axienet_main.c | 7 +++++++
 2 files changed, 9 insertions(+)

diff --git a/drivers/net/ethernet/xilinx/xilinx_axienet.h b/drivers/net/ethernet/xilinx/xilinx_axienet.h
index dd55649..f73c137 100644
--- a/drivers/net/ethernet/xilinx/xilinx_axienet.h
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet.h
@@ -388,6 +388,7 @@ struct axidma_bd {
  * @regs:	Base address for the axienet_local device address space
  * @dma_regs:	Base address for the axidma device address space
  * @dma_err_tasklet: Tasklet structure to process Axi DMA errors
+ * @tx_lock:	Spin lock for tx path
  * @tx_irq:	Axidma TX IRQ number
  * @rx_irq:	Axidma RX IRQ number
  * @phy_type:	Phy type to identify between MII/GMII/RGMII/SGMII/1000 Base-X
@@ -432,6 +433,7 @@ struct axienet_local {
 	void __iomem *dma_regs;
 
 	struct tasklet_struct dma_err_tasklet;
+	spinlock_t tx_lock;
 	spinlock_t rx_lock;		/* Spin lock */
 	struct napi_struct napi;	/* NAPI Structure */
  
diff --git a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
index 48da9f2..6b153c7 100644
--- a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
@@ -677,15 +677,19 @@ static int axienet_start_xmit(struct sk_buff *skb, struct net_device *ndev)
 	dma_addr_t tail_p;
 	struct axienet_local *lp = netdev_priv(ndev);
 	struct axidma_bd *cur_p;
+	unsigned long flags;
 
 	num_frag = skb_shinfo(skb)->nr_frags;
 	cur_p = &lp->tx_bd_v[lp->tx_bd_tail];
 
+	spin_lock_irqsave(&lp->tx_lock, flags);
 	if (axienet_check_tx_bd_space(lp, num_frag)) {
 		if (!netif_queue_stopped(ndev))
 			netif_stop_queue(ndev);
+		spin_unlock_irqrestore(&lp->tx_lock, flags);
 		return NETDEV_TX_BUSY;
 	}
+	spin_unlock_irqrestore(&lp->tx_lock, flags);
 
 	if (skb->ip_summed == CHECKSUM_PARTIAL && !lp->is_10Gmac) {
 		if (lp->features & XAE_FEATURE_FULL_TX_CSUM) {
@@ -892,7 +896,9 @@ static irqreturn_t axienet_tx_irq(int irq, void *_ndev)
 	status = axienet_dma_in32(lp, XAXIDMA_TX_SR_OFFSET);
 	if (status & (XAXIDMA_IRQ_IOC_MASK | XAXIDMA_IRQ_DELAY_MASK)) {
 		axienet_dma_out32(lp, XAXIDMA_TX_SR_OFFSET, status);
+		spin_lock(&lp->tx_lock);
 		axienet_start_xmit_done(lp->ndev);
+		spin_unlock(&lp->tx_lock);
 		goto out;
 	}
 	if (!(status & XAXIDMA_IRQ_ALL_MASK))
@@ -1647,6 +1653,7 @@ static int axienet_probe(struct platform_device *pdev)
 		goto free_netdev;
 	}
 
+	spin_lock_init(&lp->tx_lock);
 	spin_lock_init(&lp->rx_lock);
 
 	/* Retrieve the MAC address */
-- 
2.0.2

