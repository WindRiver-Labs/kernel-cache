From 4b1363ea422141b3c659059f5c3f180f17a074c5 Mon Sep 17 00:00:00 2001
From: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date: Wed, 26 Mar 2014 04:02:01 +0100
Subject: [PATCH 526/827] media: xilinx: Support more than two VDMAs in DT

This patch comes from:
  https://github.com/Xilinx/linux-xlnx.git

Replace the vdma-mm2s and vdma-s2mm DT subnodes by a ports subnode that
can contain any number of ports, with one VDMAs. The port direction is
now specified explicitly in the port node.

Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
(cherry picked from commit eb62a2d4c9b3436c88c6cf91666e9bcbab3907fb)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/media/platform/xilinx/xilinx-dma.c  |  15 +-
 drivers/media/platform/xilinx/xilinx-dma.h  |   6 +-
 drivers/media/platform/xilinx/xilinx-vipp.c | 236 ++++++++++++++++++++++------
 drivers/media/platform/xilinx/xilinx-vipp.h |   6 +-
 4 files changed, 203 insertions(+), 60 deletions(-)

diff --git a/drivers/media/platform/xilinx/xilinx-dma.c b/drivers/media/platform/xilinx/xilinx-dma.c
index c95f9c4..0265663 100644
--- a/drivers/media/platform/xilinx/xilinx-dma.c
+++ b/drivers/media/platform/xilinx/xilinx-dma.c
@@ -899,12 +899,13 @@ static struct v4l2_file_operations xvip_dma_fops = {
  */
 
 int xvip_dma_init(struct xvip_composite_device *xdev, struct xvip_dma *dma,
-		  enum v4l2_buf_type type)
+		  enum v4l2_buf_type type, unsigned int port)
 {
-	char name[10];
+	char name[14];
 	int ret;
 
 	dma->xdev = xdev;
+	dma->port = port;
 	mutex_init(&dma->lock);
 	mutex_init(&dma->pipe.lock);
 
@@ -928,9 +929,10 @@ int xvip_dma_init(struct xvip_composite_device *xdev, struct xvip_dma *dma,
 	/* ... and the video node... */
 	dma->video.v4l2_dev = &xdev->v4l2_dev;
 	dma->video.fops = &xvip_dma_fops;
-	snprintf(dma->video.name, sizeof(dma->video.name), "%s %s",
-		 xdev->dev->of_node->full_name,
-		 type == V4L2_BUF_TYPE_VIDEO_CAPTURE ? "output" : "input");
+	snprintf(dma->video.name, sizeof(dma->video.name), "%s %s %u",
+		 xdev->dev->of_node->name,
+		 type == V4L2_BUF_TYPE_VIDEO_CAPTURE ? "output" : "input",
+		 port);
 	dma->video.vfl_type = VFL_TYPE_GRABBER;
 	dma->video.vfl_dir = type == V4L2_BUF_TYPE_VIDEO_CAPTURE
 			   ? VFL_DIR_RX : VFL_DIR_TX;
@@ -958,8 +960,7 @@ int xvip_dma_init(struct xvip_composite_device *xdev, struct xvip_dma *dma,
 	}
 
 	/* ... and the DMA channel. */
-	sprintf(name, "vdma-%s",
-		type == V4L2_BUF_TYPE_VIDEO_CAPTURE ? "s2mm" : "mm2s");
+	sprintf(name, "port%u", port);
 	dma->dma = dma_request_slave_channel(dma->xdev->dev, name);
 	if (dma->dma == NULL) {
 		dev_err(dma->xdev->dev, "no VDMA channel found\n");
diff --git a/drivers/media/platform/xilinx/xilinx-dma.h b/drivers/media/platform/xilinx/xilinx-dma.h
index 911132c..ecb50d4 100644
--- a/drivers/media/platform/xilinx/xilinx-dma.h
+++ b/drivers/media/platform/xilinx/xilinx-dma.h
@@ -51,10 +51,12 @@ static inline struct xvip_pipeline *to_xvip_pipeline(struct media_entity *e)
 
 /**
  * struct xvip_dma - Video DMA channel
+ * @list: list entry in a composite device dmas list
  * @video: V4L2 video device associated with the DMA channel
  * @pad: media pad for the video device entity
  * @xdev: composite device the DMA channel belongs to
  * @pipe: pipeline belonging to the DMA channel
+ * @port: composite device DT node port number for the DMA channel
  * @lock: protects the @format, @fmtinfo and @queue fields
  * @format: active V4L2 pixel format
  * @fmtinfo: format information corresponding to the active @format
@@ -65,11 +67,13 @@ static inline struct xvip_pipeline *to_xvip_pipeline(struct media_entity *e)
  * @align: transfer alignment required by the DMA channel (in bytes)
  */
 struct xvip_dma {
+	struct list_head list;
 	struct video_device video;
 	struct media_pad pad;
 
 	struct xvip_composite_device *xdev;
 	struct xvip_pipeline pipe;
+	unsigned int port;
 
 	struct mutex lock;
 	struct v4l2_pix_format format;
@@ -86,7 +90,7 @@ struct xvip_dma {
 #define to_xvip_dma(vdev)	container_of(vdev, struct xvip_dma, video)
 
 int xvip_dma_init(struct xvip_composite_device *xdev, struct xvip_dma *dma,
-		  enum v4l2_buf_type type);
+		  enum v4l2_buf_type type, unsigned int port);
 void xvip_dma_cleanup(struct xvip_dma *dma);
 
 #endif /* __XILINX_VIP_DMA_H__ */
diff --git a/drivers/media/platform/xilinx/xilinx-vipp.c b/drivers/media/platform/xilinx/xilinx-vipp.c
index 1816e94..c022ddf 100644
--- a/drivers/media/platform/xilinx/xilinx-vipp.c
+++ b/drivers/media/platform/xilinx/xilinx-vipp.c
@@ -31,9 +31,9 @@
  * struct xvip_graph_entity - Entity in the video graph
  * @list: list entry in a graph entities list
  * @node: the entity's DT node
- * @entity: media entity, from the corresponding V4L2 subdev or video device
+ * @entity: media entity, from the corresponding V4L2 subdev
  * @asd: subdev asynchronous registration information
- * @subdev: V4L2 subdev (valid for all entities by DMA channels)
+ * @subdev: V4L2 subdev
  */
 struct xvip_graph_entity {
 	struct list_head list;
@@ -116,6 +116,14 @@ static int xvip_graph_build_one(struct xvip_composite_device *xdev,
 			continue;
 		}
 
+		/* Skip DMA engines, they will be processed separately. */
+		if (link.remote_node == xdev->dev->of_node) {
+			dev_dbg(xdev->dev, "skipping DMA port %s:%u\n",
+				link.local_node->full_name, link.local_port);
+			v4l2_of_put_link(&link);
+			continue;
+		}
+
 		/* Find the remote entity. */
 		ent = xvip_graph_find_entity(xdev, link.remote_node);
 		if (ent == NULL) {
@@ -161,6 +169,120 @@ static int xvip_graph_build_one(struct xvip_composite_device *xdev,
 	return ret;
 }
 
+static struct xvip_dma *
+xvip_graph_find_dma(struct xvip_composite_device *xdev, unsigned int port)
+{
+	struct xvip_dma *dma;
+
+	list_for_each_entry(dma, &xdev->dmas, list) {
+		if (dma->port == port)
+			return dma;
+	}
+
+	return NULL;
+}
+
+static int xvip_graph_build_dma(struct xvip_composite_device *xdev)
+{
+	u32 link_flags = MEDIA_LNK_FL_ENABLED;
+	struct device_node *node = xdev->dev->of_node;
+	struct media_entity *source;
+	struct media_entity *sink;
+	struct media_pad *source_pad;
+	struct media_pad *sink_pad;
+	struct xvip_graph_entity *ent;
+	struct v4l2_of_link link;
+	struct device_node *ep = NULL;
+	struct device_node *next;
+	struct xvip_dma *dma;
+	int ret = 0;
+
+	dev_dbg(xdev->dev, "creating links for DMA engines\n");
+
+	while (1) {
+		/* Get the next endpoint and parse its link. */
+		next = v4l2_of_get_next_endpoint(node, ep);
+		if (next == NULL)
+			break;
+
+		of_node_put(ep);
+		ep = next;
+
+		dev_dbg(xdev->dev, "processing endpoint %s\n", ep->full_name);
+
+		ret = v4l2_of_parse_link(ep, &link);
+		if (ret < 0) {
+			dev_err(xdev->dev, "failed to parse link for %s\n",
+				ep->full_name);
+			continue;
+		}
+
+		/* Find the DMA engine. */
+		dma = xvip_graph_find_dma(xdev, link.local_port);
+		if (dma == NULL) {
+			dev_err(xdev->dev, "no DMA engine found for port %u\n",
+				link.local_port);
+			v4l2_of_put_link(&link);
+			ret = -EINVAL;
+			break;
+		}
+
+		dev_dbg(xdev->dev, "creating link for DMA engine %s\n",
+			dma->video.name);
+
+		/* Find the remote entity. */
+		ent = xvip_graph_find_entity(xdev, link.remote_node);
+		if (ent == NULL) {
+			dev_err(xdev->dev, "no entity found for %s\n",
+				link.remote_node->full_name);
+			v4l2_of_put_link(&link);
+			ret = -ENODEV;
+			break;
+		}
+
+		if (link.remote_port >= ent->entity->num_pads) {
+			dev_err(xdev->dev, "invalid port number %u on %s\n",
+				link.remote_port, link.remote_node->full_name);
+			v4l2_of_put_link(&link);
+			ret = -EINVAL;
+			break;
+		}
+
+		if (dma->pad.flags & MEDIA_PAD_FL_SOURCE) {
+			source = &dma->video.entity;
+			source_pad = &dma->pad;
+			sink = ent->entity;
+			sink_pad = &sink->pads[link.remote_port];
+		} else {
+			source = ent->entity;
+			source_pad = &source->pads[link.remote_port];
+			sink = &dma->video.entity;
+			sink_pad = &dma->pad;
+		}
+
+		v4l2_of_put_link(&link);
+
+		/* Create the media link. */
+		dev_dbg(xdev->dev, "creating %s:%u -> %s:%u link\n",
+			source->name, source_pad->index,
+			sink->name, sink_pad->index);
+
+		ret = media_entity_create_link(source, source_pad->index,
+					       sink, sink_pad->index,
+					       link_flags);
+		if (ret < 0) {
+			dev_err(xdev->dev,
+				"failed to create %s:%u -> %s:%u link\n",
+				source->name, source_pad->index,
+				sink->name, sink_pad->index);
+			break;
+		}
+	}
+
+	of_node_put(ep);
+	return ret;
+}
+
 static int xvip_graph_notify_complete(struct v4l2_async_notifier *notifier)
 {
 	struct xvip_composite_device *xdev =
@@ -177,6 +299,11 @@ static int xvip_graph_notify_complete(struct v4l2_async_notifier *notifier)
 			return ret;
 	}
 
+	/* Create links for DMA channels. */
+	ret = xvip_graph_build_dma(xdev);
+	if (ret < 0)
+		return ret;
+
 	ret = v4l2_device_register_subdev_nodes(&xdev->v4l2_dev);
 	if (ret < 0)
 		dev_err(xdev->dev, "failed to register subdev nodes\n");
@@ -243,7 +370,8 @@ static int xvip_graph_parse_one(struct xvip_composite_device *xdev,
 		}
 
 		/* Skip entities that we have already processed. */
-		if (xvip_graph_find_entity(xdev, remote)) {
+		if (remote == xdev->dev->of_node ||
+		    xvip_graph_find_entity(xdev, remote)) {
 			of_node_put(remote);
 			continue;
 		}
@@ -271,7 +399,16 @@ static int xvip_graph_parse(struct xvip_composite_device *xdev)
 	struct xvip_graph_entity *entity;
 	int ret;
 
-	/* Walk the links to parse the full graph. */
+	/*
+	 * Walk the links to parse the full graph. Start by parsing the
+	 * composite node and then parse entities in turn. The list_for_each
+	 * loop will handle entities added at the end of the list while walking
+	 * the links.
+	 */
+	ret = xvip_graph_parse_one(xdev, xdev->dev->of_node);
+	if (ret < 0)
+		return 0;
+
 	list_for_each_entry(entity, &xdev->entities, list) {
 		ret = xvip_graph_parse_one(xdev, entity->node);
 		if (ret < 0)
@@ -281,78 +418,83 @@ static int xvip_graph_parse(struct xvip_composite_device *xdev)
 	return ret;
 }
 
-static int
-xvip_graph_dma_init_one(struct xvip_composite_device *xdev,
-			struct xvip_dma *dma, struct device_node *node,
-			enum v4l2_buf_type type)
+static int xvip_graph_dma_init_one(struct xvip_composite_device *xdev,
+				   struct device_node *node)
 {
-	struct xvip_graph_entity *entity;
+	struct xvip_dma *dma;
+	enum v4l2_buf_type type;
+	const char *direction;
+	unsigned int index;
 	int ret;
 
-	ret = xvip_dma_init(xdev, dma, type);
+	ret = of_property_read_string(node, "direction", &direction);
+	if (ret < 0)
+		return ret;
+
+	if (strcmp(direction, "input") == 0)
+		type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	else if (strcmp(direction, "output") == 0)
+		type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
+	else
+		return -EINVAL;
+
+	of_property_read_u32(node, "reg", &index);
+
+	dma = devm_kzalloc(xdev->dev, sizeof(*dma), GFP_KERNEL);
+	if (dma == NULL)
+		return -ENOMEM;
+
+	ret = xvip_dma_init(xdev, dma, type, index);
 	if (ret < 0) {
 		dev_err(xdev->dev, "%s initialization failed\n",
 			node->full_name);
 		return ret;
 	}
 
-	entity = devm_kzalloc(xdev->dev, sizeof(*entity), GFP_KERNEL);
-	if (entity == NULL)
-		return -ENOMEM;
-
-	entity->node = of_node_get(node);
-	entity->entity = &dma->video.entity;
-
-	list_add_tail(&entity->list, &xdev->entities);
+	list_add_tail(&dma->list, &xdev->dmas);
 
 	return 0;
 }
 
 static int xvip_graph_dma_init(struct xvip_composite_device *xdev)
 {
-	struct device_node *vdma;
+	struct device_node *ports;
+	struct device_node *port;
 	int ret;
 
-	/* The s2mm vdma channel at the pipeline output is mandatory. */
-	vdma = of_get_child_by_name(xdev->dev->of_node, "vdma-s2mm");
-	if (vdma == NULL) {
-		dev_err(xdev->dev, "vdma-s2mm node not present\n");
+	ports = of_get_child_by_name(xdev->dev->of_node, "ports");
+	if (ports == NULL) {
+		dev_err(xdev->dev, "ports node not present\n");
 		return -EINVAL;
 	}
 
-	ret = xvip_graph_dma_init_one(xdev, &xdev->dma[XVIPP_DMA_S2MM],
-				      vdma, V4L2_BUF_TYPE_VIDEO_CAPTURE);
-	of_node_put(vdma);
-
-	if (ret < 0)
-		return ret;
-
-	/* The mm2s vdma channel at the pipeline input is optional. */
-	vdma = of_get_child_by_name(xdev->dev->of_node, "vdma-mm2s");
-	if (vdma == NULL)
-		return 0;
-
-	ret = xvip_graph_dma_init_one(xdev, &xdev->dma[XVIPP_DMA_MM2S],
-				      vdma, V4L2_BUF_TYPE_VIDEO_OUTPUT);
-	of_node_put(vdma);
+	for_each_child_of_node(ports, port) {
+		ret = xvip_graph_dma_init_one(xdev, port);
+		if (ret < 0)
+			return ret;
+	}
 
-	return ret;
+	return 0;
 }
 
 static void xvip_graph_cleanup(struct xvip_composite_device *xdev)
 {
+	struct xvip_graph_entity *entityp;
 	struct xvip_graph_entity *entity;
-	struct xvip_graph_entity *prev;
+	struct xvip_dma *dmap;
+	struct xvip_dma *dma;
 
 	v4l2_async_notifier_unregister(&xdev->notifier);
 
-	list_for_each_entry_safe(entity, prev, &xdev->entities, list) {
+	list_for_each_entry_safe(entity, entityp, &xdev->entities, list) {
 		of_node_put(entity->node);
 		list_del(&entity->list);
 	}
 
-	xvip_dma_cleanup(&xdev->dma[XVIPP_DMA_S2MM]);
-	xvip_dma_cleanup(&xdev->dma[XVIPP_DMA_MM2S]);
+	list_for_each_entry_safe(dma, dmap, &xdev->dmas, list) {
+		xvip_dma_cleanup(dma);
+		list_del(&dma->list);
+	}
 }
 
 static int xvip_graph_init(struct xvip_composite_device *xdev)
@@ -392,11 +534,8 @@ static int xvip_graph_init(struct xvip_composite_device *xdev)
 	}
 
 	i = 0;
-	list_for_each_entry(entity, &xdev->entities, list) {
-		/* Skip entities that correspond to video nodes. */
-		if (entity->entity == NULL)
-			subdevs[i++] = &entity->asd;
-	}
+	list_for_each_entry(entity, &xdev->entities, list)
+		subdevs[i++] = &entity->asd;
 
 	xdev->notifier.subdevs = subdevs;
 	xdev->notifier.num_subdevs = num_subdevs;
@@ -475,6 +614,7 @@ static int xvip_composite_probe(struct platform_device *pdev)
 
 	xdev->dev = &pdev->dev;
 	INIT_LIST_HEAD(&xdev->entities);
+	INIT_LIST_HEAD(&xdev->dmas);
 
 	ret = xvip_composite_v4l2_init(xdev);
 	if (ret < 0)
diff --git a/drivers/media/platform/xilinx/xilinx-vipp.h b/drivers/media/platform/xilinx/xilinx-vipp.h
index e6a947c..3437d9c 100644
--- a/drivers/media/platform/xilinx/xilinx-vipp.h
+++ b/drivers/media/platform/xilinx/xilinx-vipp.h
@@ -20,8 +20,6 @@
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-device.h>
 
-#include "xilinx-dma.h"
-
 /**
  * struct xvip_composite_device - Xilinx Video IP device structure
  * @v4l2_dev: V4L2 device
@@ -30,7 +28,7 @@
  * @notifier: V4L2 asynchronous subdevs notifier
  * @entities: entities in the graph as a list of xvip_graph_entity
  * @num_subdevs: number of subdevs in the pipeline
- * @dma: DMA channels at the pipeline output and input
+ * @dmas: list of DMA channels at the pipeline output and input
  * @ctrl_handler: control handler
  */
 struct xvip_composite_device {
@@ -42,7 +40,7 @@ struct xvip_composite_device {
 	struct list_head entities;
 	unsigned int num_subdevs;
 
-	struct xvip_dma dma[2];
+	struct list_head dmas;
 
 	struct v4l2_ctrl_handler ctrl_handler;
 };
-- 
2.9.3

