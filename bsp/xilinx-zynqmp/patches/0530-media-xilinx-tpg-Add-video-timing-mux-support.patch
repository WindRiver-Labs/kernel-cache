From 1a55228a355eab47b8bea3a1208ce41d7dd176e4 Mon Sep 17 00:00:00 2001
From: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date: Wed, 26 Mar 2014 04:02:05 +0100
Subject: [PATCH 530/827] media: xilinx: tpg: Add video timing mux support

This patch comes from:
  https://github.com/Xilinx/linux-xlnx.git

The current version of the TPG core has no video timing input interface
but requires video timings to be supplied through its AXI stream slave
interface when generating a test pattern.

The VDF design thus instantiates a video timing mux in front of the
video 2 AXI stream core. The mux is controlled through a GPIO, which
needs to be controlled by the TPG driver.

Future versions of the TPG core might have a video timing input
interface, removing the need for GPIO mux control.

Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/media/platform/xilinx/xilinx-tpg.c | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/drivers/media/platform/xilinx/xilinx-tpg.c b/drivers/media/platform/xilinx/xilinx-tpg.c
index b8b89b2..89bd7f2 100644
--- a/drivers/media/platform/xilinx/xilinx-tpg.c
+++ b/drivers/media/platform/xilinx/xilinx-tpg.c
@@ -11,6 +11,7 @@
  */
 
 #include <linux/device.h>
+#include <linux/gpio/consumer.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/platform_device.h>
@@ -69,6 +70,7 @@
  * @bayer: boolean flag if TPG is set to any bayer format
  * @ctrl_handler: control handler
  * @vtc: video timing controller
+ * @vtmux_gpio: video timing mux GPIO
  */
 struct xtpg_device {
 	struct xvip_device xvip;
@@ -84,6 +86,7 @@ struct xtpg_device {
 	struct v4l2_ctrl_handler ctrl_handler;
 
 	struct xvtc_device *vtc;
+	struct gpio_desc *vtmux_gpio;
 };
 
 static inline struct xtpg_device *to_tpg(struct v4l2_subdev *subdev)
@@ -286,6 +289,9 @@ static void xtpg_set_test_pattern(struct xtpg_device *xtpg,
 	xvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL, XTPG_PATTERN_MASK,
 			 pattern);
 
+	if (!IS_ERR(xtpg->vtmux_gpio))
+		gpiod_set_value_cansleep(xtpg->vtmux_gpio, pattern ? 1 : 0);
+
 	xvip_enable_reg_update(&xtpg->xvip);
 }
 
@@ -694,6 +700,12 @@ static int xtpg_probe(struct platform_device *pdev)
 	if (IS_ERR(xtpg->xvip.iomem))
 		return PTR_ERR(xtpg->xvip.iomem);
 
+	xtpg->vtmux_gpio = devm_gpiod_get_index(&pdev->dev, "timing", 0);
+	if (PTR_ERR(xtpg->vtmux_gpio) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	if (!IS_ERR(xtpg->vtmux_gpio))
+		gpiod_direction_output(xtpg->vtmux_gpio, 0);
+
 	xtpg->vtc = xvtc_of_get(pdev->dev.of_node);
 	if (IS_ERR(xtpg->vtc))
 		return PTR_ERR(xtpg->vtc);
-- 
2.9.3

