From daae13184c1f26bc56331dde7bd683d91359c110 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Wed, 16 Nov 2016 22:00:42 +0800
Subject: [PATCH 844/844] mtd: spi-nor: Fix jffs2 write issue

This commit fef2cc45 comes from:
  https://github.com/Xilinx/linux-xlnx.git

When validating data integrity using jffs2 file system, if we
do write and erase in multiple iterations, we are getting SPI
timed out error. this patch fixes that.

Signed-off-by: Naga Sureshkumar Relli <nagasure@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/mtd/spi-nor/spi-nor.c | 34 ++++++++++++++++++++++++++++++++++
 1 file changed, 34 insertions(+)

diff --git a/drivers/mtd/spi-nor/spi-nor.c b/drivers/mtd/spi-nor/spi-nor.c
index 12aebb7..7fb4806 100644
--- a/drivers/mtd/spi-nor/spi-nor.c
+++ b/drivers/mtd/spi-nor/spi-nor.c
@@ -100,7 +100,11 @@ static int read_sr(struct spi_nor *nor)
 			pr_err("error %d reading SR\n", (int) ret);
 			return ret;
 		}
+#ifdef CONFIG_ARCH_ZYNQMP
+		val[0] &= val[1];
+#else
 		val[0] |= val[1];
+#endif
 	} else {
 		ret = nor->read_reg(nor, SPINOR_OP_RDSR, &val[0], 1);
 		if (ret < 0) {
@@ -511,8 +515,10 @@ static int spi_nor_erase(struct mtd_info *mtd, struct erase_info *instr)
 	if (ret)
 		return ret;
 
+#ifndef CONFIG_ARCH_ZYNQMP
 	if (nor->isparallel)
 		nor->spi->master->flags |= SPI_DATA_STRIPE;
+#endif
 	/* whole-chip erase? */
 	if (len == mtd->size) {
 		unsigned long timeout;
@@ -596,8 +602,10 @@ static int spi_nor_erase(struct mtd_info *mtd, struct erase_info *instr)
 	instr->state = MTD_ERASE_DONE;
 	mtd_erase_callback(instr);
 
+#ifndef CONFIG_ARCH_ZYNQMP
 	if (nor->isparallel)
 		nor->spi->master->flags &= ~SPI_DATA_STRIPE;
+#endif
 	return ret;
 
 erase_err:
@@ -1360,7 +1368,11 @@ static struct flash_info *spi_nor_read_id(struct spi_nor *nor)
 	int			tmp;
 	u8			id[SPI_NOR_MAX_ID_LEN];
 	struct flash_info	*info;
+#ifdef CONFIG_ARCH_ZYNQMP
+	nor->spi->master->flags &= ~(SPI_BOTH_FLASH | SPI_DATA_STRIPE);
+#else
 	nor->spi->master->flags &= ~SPI_BOTH_FLASH;
+#endif
 
 	/* If more than one flash are present,need to read id of second flash */
 	tmp = nor->read_reg(nor, SPINOR_OP_RDID, id, SPI_NOR_MAX_ID_LEN);
@@ -1413,8 +1425,10 @@ static int spi_nor_read_ext(struct mtd_info *mtd, loff_t from, size_t len,
 	ret = spi_nor_lock_and_prep(nor, SPI_NOR_OPS_READ);
 	if (ret)
 		return ret;
+#ifndef CONFIG_ARCH_ZYNQMP
 	if (nor->isparallel)
 		nor->spi->master->flags |= SPI_DATA_STRIPE;
+#endif
 
 	while (len) {
 		if (nor->addr_width == 3) {
@@ -1464,8 +1478,10 @@ static int spi_nor_read_ext(struct mtd_info *mtd, loff_t from, size_t len,
 	*retlen = read_count;
 
 read_err:
+#ifndef CONFIG_ARCH_ZYNQMP
 	if (nor->isparallel)
 		nor->spi->master->flags &= ~SPI_DATA_STRIPE;
+#endif
 	spi_nor_unlock_and_unprep(nor, SPI_NOR_OPS_READ);
 	return ret;
 }
@@ -1606,8 +1622,10 @@ static int spi_nor_write_ext(struct mtd_info *mtd, loff_t to, size_t len,
 	ret = spi_nor_lock_and_prep(nor, SPI_NOR_OPS_WRITE);
 	if (ret)
 		return ret;
+#ifndef CONFIG_ARCH_ZYNQMP
 	if (nor->isparallel)
 		nor->spi->master->flags |= SPI_DATA_STRIPE;
+#endif
 
 	while (len) {
 		actual_len = 0;
@@ -1650,8 +1668,10 @@ static int spi_nor_write_ext(struct mtd_info *mtd, loff_t to, size_t len,
 	*retlen = write_count;
 
 write_err:
+#ifndef CONFIG_ARCH_ZYNQMP
 	if (nor->isparallel)
 		nor->spi->master->flags &= ~SPI_DATA_STRIPE;
+#endif
 	spi_nor_unlock_and_unprep(nor, SPI_NOR_OPS_WRITE);
 	return ret;
 }
@@ -1682,14 +1702,18 @@ static int spansion_quad_enable(struct spi_nor *nor)
 	int ret;
 	int quad_en = CR_QUAD_EN_SPAN << 8;
 
+#ifndef CONFIG_ARCH_ZYNQMP
 	if (nor->isparallel)
 		nor->spi->master->flags |= SPI_DATA_STRIPE;
+#endif
 
 	quad_en |= read_sr(nor);
 	quad_en |= (read_cr(nor) << 8);
 
+#ifndef CONFIG_ARCH_ZYNQMP
 	if (nor->isparallel)
 		nor->spi->master->flags &= ~SPI_DATA_STRIPE;
+#endif
 
 	write_enable(nor);
 
@@ -1700,19 +1724,25 @@ static int spansion_quad_enable(struct spi_nor *nor)
 		return -EINVAL;
 	}
 
+#ifndef CONFIG_ARCH_ZYNQMP
 	if (nor->isparallel)
 		nor->spi->master->flags |= SPI_DATA_STRIPE;
+#endif
 	/* read back and check it */
 	ret = read_cr(nor);
 	if (!(ret > 0 && (ret & CR_QUAD_EN_SPAN))) {
 		dev_err(nor->dev, "Spansion Quad bit not set\n");
+#ifndef CONFIG_ARCH_ZYNQMP
 		if (nor->isparallel)
 			nor->spi->master->flags &= ~SPI_DATA_STRIPE;
+#endif
 		return -EINVAL;
 	}
 
+#ifndef CONFIG_ARCH_ZYNQMP
 	if (nor->isparallel)
 		nor->spi->master->flags &= ~SPI_DATA_STRIPE;
+#endif
 
 	return 0;
 }
@@ -1854,7 +1884,11 @@ int spi_nor_scan(struct spi_nor *nor, const char *name, enum read_mode mode)
 					nor->isparallel = 1;
 					nor->isstacked = 0;
 					nor->spi->master->flags |=
+#ifndef CONFIG_ARCH_ZYNQMP
 							SPI_BOTH_FLASH;
+#else
+					(SPI_BOTH_FLASH | SPI_DATA_STRIPE);
+#endif
 				} else {
 #ifdef CONFIG_SPI_ZYNQ_QSPI_DUAL_STACKED
 					/* dual stacked */
-- 
1.9.1

