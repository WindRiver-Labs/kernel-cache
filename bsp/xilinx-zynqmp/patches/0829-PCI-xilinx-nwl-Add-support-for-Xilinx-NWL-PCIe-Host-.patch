From 3e45806e8bec15292ef407dda834c5245512f1b4 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Tue, 25 Oct 2016 09:07:48 +0800
Subject: [PATCH 829/830] PCI: xilinx-nwl: Add support for Xilinx NWL PCIe Host
 Controller

This commit ab597d35 comes from:
  https://github.com/Xilinx/linux-xlnx.git

Add PCIe Root Port driver for Xilinx PCIe NWL bridge IP.

[bhelgaas: wait for link like dw_pcie_wait_for_link(), simplify bitmap
error path, typos, whitespace, fold in Dan Carpenter's PTR_ERR() fix]
Signed-off-by: Bharat Kumar Gogada <bharatku@xilinx.com>
Signed-off-by: Ravi Kiran Gummaluri <rgummal@xilinx.com>
Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
Reviewed-by: Marc Zyngier <marc.zyngier@arm.com>
Acked-by: Rob Herring <robh@kernel.org>
---
 .../devicetree/bindings/pci/xilinx-nwl-pcie.txt    |  68 ++
 drivers/pci/host/Kconfig                           |  11 +-
 drivers/pci/host/Makefile                          |   2 +-
 .../host/{pci-xilinx-nwl.c => pcie-xilinx-nwl.c}   | 938 ++++++++-------------
 4 files changed, 406 insertions(+), 613 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/pci/xilinx-nwl-pcie.txt
 rename drivers/pci/host/{pci-xilinx-nwl.c => pcie-xilinx-nwl.c} (50%)

diff --git a/Documentation/devicetree/bindings/pci/xilinx-nwl-pcie.txt b/Documentation/devicetree/bindings/pci/xilinx-nwl-pcie.txt
new file mode 100644
index 0000000..337fc97
--- /dev/null
+++ b/Documentation/devicetree/bindings/pci/xilinx-nwl-pcie.txt
@@ -0,0 +1,68 @@
+* Xilinx NWL PCIe Root Port Bridge DT description
+
+Required properties:
+- compatible: Should contain "xlnx,nwl-pcie-2.11"
+- #address-cells: Address representation for root ports, set to <3>
+- #size-cells: Size representation for root ports, set to <2>
+- #interrupt-cells: specifies the number of cells needed to encode an
+	interrupt source. The value must be 1.
+- reg: Should contain Bridge, PCIe Controller registers location,
+	configuration space, and length
+- reg-names: Must include the following entries:
+	"breg": bridge registers
+	"pcireg": PCIe controller registers
+	"cfg": configuration space region
+- device_type: must be "pci"
+- interrupts: Should contain NWL PCIe interrupt
+- interrupt-names: Must include the following entries:
+	"msi1, msi0": interrupt asserted when MSI is received
+	"intx": interrupt asserted when a legacy interrupt is received
+	"misc": interrupt asserted when miscellaneous is received
+- interrupt-map-mask and interrupt-map: standard PCI properties to define the
+	mapping of the PCI interface to interrupt numbers.
+- ranges: ranges for the PCI memory regions (I/O space region is not
+	supported by hardware)
+	Please refer to the standard PCI bus binding document for a more
+	detailed explanation
+- msi-controller: indicates that this is MSI controller node
+- msi-parent:  MSI parent of the root complex itself
+- legacy-interrupt-controller: Interrupt controller device node for Legacy interrupts
+	- interrupt-controller: identifies the node as an interrupt controller
+	- #interrupt-cells: should be set to 1
+	- #address-cells: specifies the number of cells needed to encode an
+		address. The value must be 0.
+
+
+Example:
+++++++++
+
+nwl_pcie: pcie@fd0e0000 {
+	#address-cells = <3>;
+	#size-cells = <2>;
+	compatible = "xlnx,nwl-pcie-2.11";
+	#interrupt-cells = <1>;
+	msi-controller;
+	device_type = "pci";
+	interrupt-parent = <&gic>;
+	interrupts = <0 114 4>, <0 115 4>, <0 116 4>, <0 117 4>, <0 118 4>;
+	interrupt-names = "msi0", "msi1", "intx", "dummy", "misc";
+	interrupt-map-mask = <0x0 0x0 0x0 0x7>;
+	interrupt-map = <0x0 0x0 0x0 0x1 &pcie_intc 0x1>,
+			<0x0 0x0 0x0 0x2 &pcie_intc 0x2>,
+			<0x0 0x0 0x0 0x3 &pcie_intc 0x3>,
+			<0x0 0x0 0x0 0x4 &pcie_intc 0x4>;
+
+	msi-parent = <&nwl_pcie>;
+	reg = <0x0 0xfd0e0000 0x0 0x1000>,
+	      <0x0 0xfd480000 0x0 0x1000>,
+	      <0x0 0xe0000000 0x0 0x1000000>;
+	reg-names = "breg", "pcireg", "cfg";
+	ranges = <0x02000000 0x00000000 0xe1000000 0x00000000 0xe1000000 0 0x0f000000>;
+
+	pcie_intc: legacy-interrupt-controller {
+		interrupt-controller;
+		#address-cells = <0>;
+		#interrupt-cells = <1>;
+	};
+
+};
diff --git a/drivers/pci/host/Kconfig b/drivers/pci/host/Kconfig
index e9b3b26..349ab02 100644
--- a/drivers/pci/host/Kconfig
+++ b/drivers/pci/host/Kconfig
@@ -15,13 +15,14 @@ config PCI_MVEBU
 	depends on ARCH_MVEBU || ARCH_DOVE
 	depends on OF
 
-config PCI_XILINX_NWL
+config PCIE_XILINX_NWL
 	bool "NWL PCIe Core"
-	depends on ARCH_ZYNQMP && PCI_MSI
+	depends on ARCH_ZYNQMP
+	select PCI_MSI_IRQ_DOMAIN if PCI_MSI
 	help
-	 Say 'Y' here if you want kernel to support for Xilinx
-	 NWL PCIe controller.The controller can act as Root Port
-	 or End Point.The current option selection will only
+	 Say 'Y' here if you want kernel support for Xilinx
+	 NWL PCIe controller. The controller can act as Root Port
+	 or End Point. The current option selection will only
 	 support root port enabling.
 
 config PCIE_DW
diff --git a/drivers/pci/host/Makefile b/drivers/pci/host/Makefile
index 1fd58a2..8b76c5a 100644
--- a/drivers/pci/host/Makefile
+++ b/drivers/pci/host/Makefile
@@ -10,7 +10,7 @@ obj-$(CONFIG_PCI_HOST_GENERIC) += pci-host-generic.o
 obj-$(CONFIG_PCIE_SPEAR13XX) += pcie-spear13xx.o
 obj-$(CONFIG_PCI_KEYSTONE) += pci-keystone-dw.o pci-keystone.o
 obj-$(CONFIG_PCIE_XILINX) += pcie-xilinx.o
-obj-$(CONFIG_PCI_XILINX_NWL) += pci-xilinx-nwl.o
+obj-$(CONFIG_PCIE_XILINX_NWL) += pcie-xilinx-nwl.o
 obj-$(CONFIG_PCI_XGENE) += pci-xgene.o
 obj-$(CONFIG_PCI_LAYERSCAPE) += pci-layerscape.o
 obj-$(CONFIG_PCI_VERSATILE) += pci-versatile.o
diff --git a/drivers/pci/host/pci-xilinx-nwl.c b/drivers/pci/host/pcie-xilinx-nwl.c
similarity index 50%
rename from drivers/pci/host/pci-xilinx-nwl.c
rename to drivers/pci/host/pcie-xilinx-nwl.c
index f672691..5139e64 100644
--- a/drivers/pci/host/pci-xilinx-nwl.c
+++ b/drivers/pci/host/pcie-xilinx-nwl.c
@@ -1,6 +1,6 @@
 /*
  * PCIe host controller driver for NWL PCIe Bridge
- * Based on pci-xilinx.c, pci-tegra.c
+ * Based on pcie-xilinx.c, pci-tegra.c
  *
  * (C) Copyright 2014 - 2015, Xilinx, Inc.
  *
@@ -23,29 +23,19 @@
 #include <linux/of_irq.h>
 #include <linux/pci.h>
 #include <linux/platform_device.h>
+#include <linux/irqchip/chained_irq.h>
 
 /* Bridge core config registers */
 #define BRCFG_PCIE_RX0			0x00000000
-#define BRCFG_PCIE_RX1			0x00000004
-#define BRCFG_AXI_MASTER		0x00000008
-#define BRCFG_PCIE_TX			0x0000000C
 #define BRCFG_INTERRUPT			0x00000010
-#define BRCFG_RAM_DISABLE0		0x00000014
-#define BRCFG_RAM_DISABLE1		0x00000018
-#define BRCFG_PCIE_RELAXED_ORDER	0x0000001C
 #define BRCFG_PCIE_RX_MSG_FILTER	0x00000020
 
-/* Attribute registers */
-#define NWL_ATTRIB_100			0x00000190
-
 /* Egress - Bridge translation registers */
 #define E_BREG_CAPABILITIES		0x00000200
-#define E_BREG_STATUS			0x00000204
 #define E_BREG_CONTROL			0x00000208
 #define E_BREG_BASE_LO			0x00000210
 #define E_BREG_BASE_HI			0x00000214
 #define E_ECAM_CAPABILITIES		0x00000220
-#define E_ECAM_STATUS			0x00000224
 #define E_ECAM_CONTROL			0x00000228
 #define E_ECAM_BASE_LO			0x00000230
 #define E_ECAM_BASE_HI			0x00000234
@@ -67,11 +57,6 @@
 #define MSGF_MSI_STATUS_HI		0x00000444
 #define MSGF_MSI_MASK_LO		0x00000448
 #define MSGF_MSI_MASK_HI		0x0000044C
-#define MSGF_RX_FIFO_POP		0x00000484
-#define MSGF_RX_FIFO_TYPE		0x00000488
-#define MSGF_RX_FIFO_ADDRLO		0x00000490
-#define MSGF_RX_FIFO_ADDRHI		0x00000494
-#define MSGF_RX_FIFO_DATA		0x00000498
 
 /* Msg filter mask bits */
 #define CFG_ENABLE_PM_MSG_FWD		BIT(1)
@@ -100,16 +85,10 @@
 #define MSGF_MISC_SR_MASTER_ERR		BIT(5)
 #define MSGF_MISC_SR_I_ADDR_ERR		BIT(6)
 #define MSGF_MISC_SR_E_ADDR_ERR		BIT(7)
+#define MSGF_MISC_SR_UR_DETECT          BIT(20)
 
-#define MSGF_MISC_SR_FATAL_AER		BIT(16)
-#define MSGF_MISC_SR_NON_FATAL_AER	BIT(17)
-#define MSGF_MISC_SR_CORR_AER		BIT(18)
-#define MSGF_MISC_SR_UR_DETECT		BIT(20)
-#define MSGF_MISC_SR_NON_FATAL_DEV	BIT(22)
-#define MSGF_MISC_SR_FATAL_DEV		BIT(23)
-#define MSGF_MISC_SR_LINK_DOWN		BIT(24)
-#define MSGF_MSIC_SR_LINK_AUTO_BWIDTH	BIT(25)
-#define MSGF_MSIC_SR_LINK_BWIDTH	BIT(26)
+#define MSGF_MISC_SR_PCIE_CORE		GENMASK(18, 16)
+#define MSGF_MISC_SR_PCIE_CORE_ERR	GENMASK(31, 22)
 
 #define MSGF_MISC_SR_MASKALL		(MSGF_MISC_SR_RXMSG_AVAIL | \
 					MSGF_MISC_SR_RXMSG_OVER | \
@@ -117,19 +96,9 @@
 					MSGF_MISC_SR_MASTER_ERR | \
 					MSGF_MISC_SR_I_ADDR_ERR | \
 					MSGF_MISC_SR_E_ADDR_ERR | \
-					MSGF_MISC_SR_FATAL_AER | \
-					MSGF_MISC_SR_NON_FATAL_AER | \
-					MSGF_MISC_SR_CORR_AER | \
 					MSGF_MISC_SR_UR_DETECT | \
-					MSGF_MISC_SR_NON_FATAL_DEV | \
-					MSGF_MISC_SR_FATAL_DEV | \
-					MSGF_MISC_SR_LINK_DOWN | \
-					MSGF_MSIC_SR_LINK_AUTO_BWIDTH | \
-					MSGF_MSIC_SR_LINK_BWIDTH)
-
-/* Message rx fifo type mask bits */
-#define MSGF_RX_FIFO_TYPE_MSI	(1)
-#define MSGF_RX_FIFO_TYPE_TYPE	GENMASK(1, 0)
+					MSGF_MISC_SR_PCIE_CORE | \
+					MSGF_MISC_SR_PCIE_CORE_ERR)
 
 /* Legacy interrupt status mask bits */
 #define MSGF_LEG_SR_INTA		BIT(0)
@@ -155,99 +124,45 @@
 
 /* E_ECAM status mask bits */
 #define E_ECAM_PRESENT			BIT(0)
-#define E_ECAM_SR_WR_PEND		BIT(16)
-#define E_ECAM_SR_RD_PEND		BIT(0)
-#define E_ECAM_SR_MASKALL		(E_ECAM_SR_WR_PEND | E_ECAM_SR_RD_PEND)
 #define E_ECAM_CR_ENABLE		BIT(0)
 #define E_ECAM_SIZE_LOC			GENMASK(20, 16)
 #define E_ECAM_SIZE_SHIFT		16
 #define ECAM_BUS_LOC_SHIFT		20
 #define ECAM_DEV_LOC_SHIFT		12
 #define NWL_ECAM_VALUE_DEFAULT		12
-#define NWL_ECAM_SIZE_MIN		4096
 
-#define ATTR_UPSTREAM_FACING		BIT(6)
 #define CFG_DMA_REG_BAR			GENMASK(2, 0)
 
-/* msgf_rx_fifo_pop bits */
-#define MSGF_RX_FIFO_POP_POP	BIT(0)
-
 #define INT_PCI_MSI_NR			(2 * 32)
-
 #define INTX_NUM			4
-/* Readin the PS_LINKUP */
-#define PS_LINKUP_OFFSET			0x00000238
-#define PCIE_PHY_LINKUP_BIT			BIT(0)
-#define PHY_RDY_LINKUP_BIT			BIT(1)
-#define PCIE_USER_LINKUP			0
-#define PHY_RDY_LINKUP				1
-#define LINKUP_ITER_CHECK			5
-
-/* PCIE Message Request */
-#define TX_PCIE_MSG				0x00000620
-#define TX_PCIE_MSG_CNTL			0x00000004
-#define TX_PCIE_MSG_SPEC_LO			0x00000008
-#define TX_PCIE_MSG_SPEC_HI			0x0000000C
-#define TX_PCIE_MSG_DATA			0x00000010
-
-#define MSG_BUSY_BIT				BIT(8)
-#define MSG_EXECUTE_BIT				BIT(0)
-#define MSG_DONE_BIT				BIT(16)
-#define MSG_DONE_STATUS_BIT			(BIT(25) | BIT(24))
-#define RANDOM_DIGIT				0x11223344
-#define PATTRN_SSLP_TLP				0x01005074
 
-/**
- * struct nwl_msi - MSI information
- *
- * @chip: MSI controller
- * @used: Declare Bitmap for MSI
- * @domain: IRQ domain pointer
- * @pages: MSI pages
- * @lock: mutex lock
- * @irq_msi0: msi0 interrupt number
- * @irq_msi1: msi1 interrupt number
- */
-struct nwl_msi {
-	struct msi_controller chip;
-	DECLARE_BITMAP(used, INT_PCI_MSI_NR);
-	struct irq_domain *domain;
-	unsigned long pages;
-	struct mutex lock;
+/* Readin the PS_LINKUP */
+#define PS_LINKUP_OFFSET		0x00000238
+#define PCIE_PHY_LINKUP_BIT		BIT(0)
+#define PHY_RDY_LINKUP_BIT		BIT(1)
+
+/* Parameters for the waiting for link up routine */
+#define LINK_WAIT_MAX_RETRIES          10
+#define LINK_WAIT_USLEEP_MIN           90000
+#define LINK_WAIT_USLEEP_MAX           100000
+
+struct nwl_msi {			/* MSI information */
+	struct irq_domain *msi_domain;
+	unsigned long *bitmap;
+	struct irq_domain *dev_domain;
+	struct mutex lock;		/* protect bitmap variable */
 	int irq_msi0;
 	int irq_msi1;
 };
 
-/**
- * struct nwl_pcie - PCIe port information
- *
- * @dev: Device pointer
- * @breg_base: IO Mapped Bridge Register Base
- * @pcireg_base: IO Mapped PCIe controller attributes
- * @ecam_base: IO Mapped configuration space
- * @phys_breg_base: Physical Bridge Register Base
- * @phys_pcie_reg_base: Physical PCIe Controller Attributes
- * @phys_ecam_base: Physical Configuration Base
- * @breg_size: Bridge Register space
- * @pcie_reg_size: PCIe controller attributes space
- * @ecam_size: PCIe Configuration space
- * @irq_intx: Legacy interrupt number
- * @irq_misc: Misc interrupt number
- * @ecam_value: ECAM value
- * @last_busno: Last Bus number configured
- * @link_up: Link status flag
- * @enable_msi_fifo: Enable MSI FIFO mode
- * @bus: PCI bus
- * @msi: MSI interrupt info
- */
 struct nwl_pcie {
 	struct device *dev;
 	void __iomem *breg_base;
 	void __iomem *pcireg_base;
 	void __iomem *ecam_base;
-	phys_addr_t phys_breg_base;
-	phys_addr_t phys_pcie_reg_base;
-	phys_addr_t phys_ecam_base;
+	phys_addr_t phys_breg_base;	/* Physical Bridge Register Base */
+	phys_addr_t phys_pcie_reg_base;	/* Physical PCIe Controller Base */
+	phys_addr_t phys_ecam_base;	/* Physical Configuration Base */
 	u32 breg_size;
 	u32 pcie_reg_size;
 	u32 ecam_size;
@@ -256,18 +171,10 @@ struct nwl_pcie {
 	u32 ecam_value;
 	u8 last_busno;
 	u8 root_busno;
-	u8 link_up;
-	bool enable_msi_fifo;
-	struct pci_bus *bus;
 	struct nwl_msi msi;
 	struct irq_domain *legacy_irq_domain;
 };
 
-static inline struct nwl_msi *to_nwl_msi(struct msi_controller *chip)
-{
-	return container_of(chip, struct nwl_msi, chip);
-}
-
 static inline u32 nwl_bridge_readl(struct nwl_pcie *pcie, u32 off)
 {
 	return readl(pcie->breg_base + off);
@@ -278,26 +185,42 @@ static inline void nwl_bridge_writel(struct nwl_pcie *pcie, u32 val, u32 off)
 	writel(val, pcie->breg_base + off);
 }
 
-static inline bool nwl_pcie_is_link_up(struct nwl_pcie *pcie, u32 check_bit)
+static bool nwl_pcie_link_up(struct nwl_pcie *pcie)
+{
+	if (readl(pcie->pcireg_base + PS_LINKUP_OFFSET) & PCIE_PHY_LINKUP_BIT)
+		return true;
+	return false;
+}
+
+static bool nwl_phy_link_up(struct nwl_pcie *pcie)
 {
-	unsigned int status = -EINVAL;
-
-	if (check_bit == PCIE_USER_LINKUP)
-		status = (readl(pcie->pcireg_base + PS_LINKUP_OFFSET) &
-			  PCIE_PHY_LINKUP_BIT) ? 1 : 0;
-	else if (check_bit == PHY_RDY_LINKUP)
-		status = (readl(pcie->pcireg_base + PS_LINKUP_OFFSET) &
-			  PHY_RDY_LINKUP_BIT) ? 1 : 0;
-	return status;
+	if (readl(pcie->pcireg_base + PS_LINKUP_OFFSET) & PHY_RDY_LINKUP_BIT)
+		return true;
+	return false;
+}
+
+static int nwl_wait_for_link(struct nwl_pcie *pcie)
+{
+	int retries;
+
+	/* check if the link is up or not */
+	for (retries = 0; retries < LINK_WAIT_MAX_RETRIES; retries++) {
+		if (nwl_phy_link_up(pcie))
+			return 0;
+		usleep_range(LINK_WAIT_USLEEP_MIN, LINK_WAIT_USLEEP_MAX);
+	}
+
+	dev_err(pcie->dev, "PHY link never came up\n");
+	return -ETIMEDOUT;
 }
 
 static bool nwl_pcie_valid_device(struct pci_bus *bus, unsigned int devfn)
 {
 	struct nwl_pcie *pcie = bus->sysdata;
 
-	/* Check link,before accessing downstream ports */
+	/* Check link before accessing downstream ports */
 	if (bus->number != pcie->root_busno) {
-		if (!nwl_pcie_is_link_up(pcie, PCIE_USER_LINKUP))
+		if (!nwl_pcie_link_up(pcie))
 			return false;
 	}
 
@@ -309,7 +232,7 @@ static bool nwl_pcie_valid_device(struct pci_bus *bus, unsigned int devfn)
 }
 
 /**
- * nwl_pcie_get_config_base - Get configuration base
+ * nwl_pcie_map_bus - Get configuration base
  *
  * @bus: Bus structure of current bus
  * @devfn: Device/function
@@ -318,9 +241,8 @@ static bool nwl_pcie_valid_device(struct pci_bus *bus, unsigned int devfn)
  * Return: Base address of the configuration space needed to be
  *	   accessed.
  */
-static void __iomem *nwl_pcie_get_config_base(struct pci_bus *bus,
-						 unsigned int devfn,
-						 int where)
+static void __iomem *nwl_pcie_map_bus(struct pci_bus *bus, unsigned int devfn,
+				      int where)
 {
 	struct nwl_pcie *pcie = bus->sysdata;
 	int relbus;
@@ -334,153 +256,16 @@ static void __iomem *nwl_pcie_get_config_base(struct pci_bus *bus,
 	return pcie->ecam_base + relbus + where;
 }
 
-/**
- * nwl_setup_sspl - Set Slot Power limit
- *
- * @pcie: PCIe port information
- */
-static int nwl_setup_sspl(struct nwl_pcie *pcie)
-{
-	unsigned int status;
-	int check = 0;
-
-	do {
-		status = nwl_bridge_readl(pcie, TX_PCIE_MSG) & MSG_BUSY_BIT;
-		if (!status) {
-			/*
-			 * Generate the TLP message for a single EP
-			 * [TODO] Add a multi-endpoint code
-			 */
-			nwl_bridge_writel(pcie, 0x0,
-					  TX_PCIE_MSG + TX_PCIE_MSG_CNTL);
-			nwl_bridge_writel(pcie, 0x0,
-					  TX_PCIE_MSG + TX_PCIE_MSG_SPEC_LO);
-			nwl_bridge_writel(pcie, 0x0,
-					  TX_PCIE_MSG + TX_PCIE_MSG_SPEC_HI);
-			nwl_bridge_writel(pcie, 0x0,
-					  TX_PCIE_MSG + TX_PCIE_MSG_DATA);
-			/* Pattern to generate SSLP TLP */
-			nwl_bridge_writel(pcie, PATTRN_SSLP_TLP,
-					  TX_PCIE_MSG + TX_PCIE_MSG_CNTL);
-			nwl_bridge_writel(pcie, RANDOM_DIGIT,
-					  TX_PCIE_MSG + TX_PCIE_MSG_DATA);
-			nwl_bridge_writel(pcie, nwl_bridge_readl(pcie,
-					  TX_PCIE_MSG) | 0x1, TX_PCIE_MSG);
-			status = 0;
-			do {
-				status = nwl_bridge_readl(pcie, TX_PCIE_MSG) &
-							  MSG_DONE_BIT;
-				if (!status && (check < 1)) {
-					mdelay(1);
-					check++;
-				} else {
-					return false;
-				}
-
-			} while (!status);
-			status = nwl_bridge_readl(pcie, TX_PCIE_MSG)
-						  & MSG_DONE_STATUS_BIT;
-		}
-	} while (status);
-
-	return true;
-}
-
-/**
- * nwl_nwl_readl_config - Read configuration space
- *
- * @bus: Bus structure of current bus
- * @devfn: Device/function
- * @where: Offset from base
- * @size: Byte/word/dword
- * @val: Value to be read
- *
- * Return: PCIBIOS_SUCCESSFUL on success
- *	   PCIBIOS_DEVICE_NOT_FOUND on failure.
- */
-static int nwl_nwl_readl_config(struct pci_bus *bus,
-				unsigned int devfn,
-				int where,
-				int size,
-				u32 *val)
-{
-	void __iomem *addr;
-
-	addr = nwl_pcie_get_config_base(bus, devfn, where);
-	if (!addr) {
-		*val = ~0;
-		return PCIBIOS_DEVICE_NOT_FOUND;
-	}
-
-	switch (size) {
-	case 1:
-		*val = readb(addr);
-		break;
-	case 2:
-		*val = readw(addr);
-		break;
-	default:
-		*val = readl(addr);
-		break;
-	}
-	return PCIBIOS_SUCCESSFUL;
-}
-
-/**
- * nwl_nwl_writel_config - Write configuration space
- *
- * @bus: Bus structure of current bus
- * @devfn: Device/function
- * @where: Offset from base
- * @size: Byte/word/dword
- * @val: Value to be written to device
- *
- * Return: PCIBIOS_SUCCESSFUL on success,
- *	   PCIBIOS_DEVICE_NOT_FOUND on failure.
- */
-static int nwl_nwl_writel_config(struct pci_bus *bus,
-				unsigned int devfn,
-				int where,
-				int size,
-				u32 val)
-{
-	void __iomem *addr;
-	int err = 0;
-	struct nwl_pcie *pcie = bus->sysdata;
-
-	addr = nwl_pcie_get_config_base(bus, devfn, where);
-	if (!addr)
-		return PCIBIOS_DEVICE_NOT_FOUND;
-
-	switch (size) {
-	case 1:
-		writeb(val, addr);
-		break;
-	case 2:
-		writew(val, addr);
-		break;
-	default:
-		writel(val, addr);
-		break;
-	}
-	if (addr == (pcie->ecam_base + PCI_EXP_SLTCAP)) {
-		err = nwl_setup_sspl(pcie);
-		if (!err)
-			return PCIBIOS_SET_FAILED;
-	}
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
 /* PCIe operations */
 static struct pci_ops nwl_pcie_ops = {
-	.read  = nwl_nwl_readl_config,
-	.write = nwl_nwl_writel_config,
+	.map_bus = nwl_pcie_map_bus,
+	.read  = pci_generic_config_read,
+	.write = pci_generic_config_write,
 };
 
 static irqreturn_t nwl_pcie_misc_handler(int irq, void *data)
 {
-	struct nwl_pcie *pcie = (struct nwl_pcie *)data;
+	struct nwl_pcie *pcie = data;
 	u32 misc_stat;
 
 	/* Checking for misc interrupts */
@@ -506,98 +291,80 @@ static irqreturn_t nwl_pcie_misc_handler(int irq, void *data)
 		dev_err(pcie->dev,
 			"In Misc Egress address translation error\n");
 
-	if (misc_stat & MSGF_MISC_SR_FATAL_AER)
-		dev_err(pcie->dev, "Fatal Error in AER Capability\n");
+	if (misc_stat & MSGF_MISC_SR_PCIE_CORE_ERR)
+		dev_err(pcie->dev, "PCIe Core error\n");
 
-	if (misc_stat & MSGF_MISC_SR_NON_FATAL_AER)
-		dev_err(pcie->dev, "Non-Fatal Error in AER Capability\n");
-
-	if (misc_stat & MSGF_MISC_SR_CORR_AER)
-		dev_err(pcie->dev, "Correctable Error in AER Capability\n");
+	/* Clear misc interrupt status */
+	nwl_bridge_writel(pcie, misc_stat, MSGF_MISC_STATUS);
 
-	if (misc_stat & MSGF_MISC_SR_UR_DETECT)
-		dev_err(pcie->dev, "Unsupported request Detected\n");
+	return IRQ_HANDLED;
+}
 
-	if (misc_stat & MSGF_MISC_SR_NON_FATAL_DEV)
-		dev_err(pcie->dev, "Non-Fatal Error Detected\n");
+static void nwl_pcie_leg_handler(struct irq_desc *desc)
+{
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	struct nwl_pcie *pcie;
+	unsigned long status;
+	u32 bit;
+	u32 virq;
 
-	if (misc_stat & MSGF_MISC_SR_FATAL_DEV)
-		dev_err(pcie->dev, "Fatal Error Detected\n");
+	chained_irq_enter(chip, desc);
+	pcie = irq_desc_get_handler_data(desc);
 
-	if (misc_stat & MSGF_MSIC_SR_LINK_AUTO_BWIDTH)
-		dev_err(pcie->dev,
-			"Link Autonomous Bandwidth Management Status bit set\n");
-
-	if (misc_stat & MSGF_MSIC_SR_LINK_BWIDTH)
-		dev_err(pcie->dev, "Link Bandwidth Management Status bit set\n");
-
-	if (pcie->enable_msi_fifo) {
-		if (misc_stat & MSGF_MISC_SR_RXMSG_AVAIL) {
-			u32 msg_type = nwl_bridge_readl(pcie,
-							MSGF_RX_FIFO_TYPE) &
-							MSGF_RX_FIFO_TYPE_TYPE;
-
-			if (msg_type == MSGF_RX_FIFO_TYPE_MSI) {
-				u32 irq_msi;
-				struct nwl_msi *msi = &pcie->msi;
-				u32 msi_data = nwl_bridge_readl(pcie,
-							MSGF_RX_FIFO_DATA);
-				/* Let all ready be completed before write */
-				rmb();
-				/* POP the FIFO */
-				nwl_bridge_writel(pcie, MSGF_RX_FIFO_POP_POP,
-						  MSGF_RX_FIFO_POP);
-
-				/* Handle the msi virtual interrupt */
-				irq_msi = irq_find_mapping(msi->domain,
-							   msi_data);
-
-				if (irq_msi) {
-					if (test_bit(msi_data, msi->used))
-						generic_handle_irq(irq_msi);
-					else
-						dev_info(pcie->dev,
-							 "unhandled MSI %d\n",
-							 irq_msi);
-				} else {
-					dev_info(pcie->dev, "unexpected MSI\n");
-				}
-			}
+	while ((status = nwl_bridge_readl(pcie, MSGF_LEG_STATUS) &
+				MSGF_LEG_SR_MASKALL) != 0) {
+		for_each_set_bit(bit, &status, INTX_NUM) {
+			virq = irq_find_mapping(pcie->legacy_irq_domain,
+						bit + 1);
+			if (virq)
+				generic_handle_irq(virq);
 		}
 	}
-	/* Clear misc interrupt status */
-	nwl_bridge_writel(pcie, misc_stat, MSGF_MISC_STATUS);
 
-	return IRQ_HANDLED;
+	chained_irq_exit(chip, desc);
 }
 
-static irqreturn_t nwl_pcie_leg_handler(int irq, void *data)
+static void nwl_pcie_handle_msi_irq(struct nwl_pcie *pcie, u32 status_reg)
 {
-	struct nwl_pcie *pcie = (struct nwl_pcie *)data;
-	unsigned long leg_stat;
+	struct nwl_msi *msi;
+	unsigned long status;
 	u32 bit;
 	u32 virq;
 
-	/* Checking for legacy interrupts */
-	leg_stat = nwl_bridge_readl(pcie, MSGF_LEG_STATUS) &
-				MSGF_LEG_SR_MASKALL;
+	msi = &pcie->msi;
 
-	if (!leg_stat)
-		return IRQ_NONE;
+	while ((status = nwl_bridge_readl(pcie, status_reg)) != 0) {
+		for_each_set_bit(bit, &status, 32) {
+			nwl_bridge_writel(pcie, 1 << bit, status_reg);
+			virq = irq_find_mapping(msi->dev_domain, bit);
+			if (virq)
+				generic_handle_irq(virq);
+		}
+	}
+}
 
-	for_each_set_bit(bit, &leg_stat, 4) {
+static void nwl_pcie_msi_handler_high(struct irq_desc *desc)
+{
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	struct nwl_pcie *pcie = irq_desc_get_handler_data(desc);
 
-		virq = irq_find_mapping(pcie->legacy_irq_domain,
-					bit + 1);
-		if (virq)
-			generic_handle_irq(virq);
-	}
+	chained_irq_enter(chip, desc);
+	nwl_pcie_handle_msi_irq(pcie, MSGF_MSI_STATUS_HI);
+	chained_irq_exit(chip, desc);
+}
 
-	return IRQ_HANDLED;
+static void nwl_pcie_msi_handler_low(struct irq_desc *desc)
+{
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	struct nwl_pcie *pcie = irq_desc_get_handler_data(desc);
+
+	chained_irq_enter(chip, desc);
+	nwl_pcie_handle_msi_irq(pcie, MSGF_MSI_STATUS_LO);
+	chained_irq_exit(chip, desc);
 }
 
 static int nwl_legacy_map(struct irq_domain *domain, unsigned int irq,
-				irq_hw_number_t hwirq)
+			  irq_hw_number_t hwirq)
 {
 	irq_set_chip_and_handler(irq, &dummy_irq_chip, handle_simple_irq);
 	irq_set_chip_data(irq, domain->host_data);
@@ -609,170 +376,208 @@ static const struct irq_domain_ops legacy_domain_ops = {
 	.map = nwl_legacy_map,
 };
 
-static void __nwl_pcie_msi_handler(struct nwl_pcie *pcie,
-					unsigned long reg, u32 val)
+#ifdef CONFIG_PCI_MSI
+static struct irq_chip nwl_msi_irq_chip = {
+	.name = "nwl_pcie:msi",
+	.irq_enable = unmask_msi_irq,
+	.irq_disable = mask_msi_irq,
+	.irq_mask = mask_msi_irq,
+	.irq_unmask = unmask_msi_irq,
+
+};
+
+static struct msi_domain_info nwl_msi_domain_info = {
+	.flags = (MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS |
+		  MSI_FLAG_MULTI_PCI_MSI),
+	.chip = &nwl_msi_irq_chip,
+};
+#endif
+
+static void nwl_compose_msi_msg(struct irq_data *data, struct msi_msg *msg)
 {
-	struct nwl_msi *msi = &pcie->msi;
-	unsigned int offset, index;
-	int irq_msi;
-
-	offset = find_first_bit(&reg, 32);
-	index = offset;
-
-	/* Clear the interrupt */
-	nwl_bridge_writel(pcie, 1 << offset, val);
-
-	/* Handle the msi virtual interrupt */
-	irq_msi = irq_find_mapping(msi->domain, index);
-	if (irq_msi) {
-		if (test_bit(index, msi->used))
-			generic_handle_irq(irq_msi);
-		else
-			dev_info(pcie->dev, "unhandled MSI\n");
-	} else {
-		/* that's weird who triggered this? just clear it */
-		dev_info(pcie->dev, "unexpected MSI\n");
-	}
+	struct nwl_pcie *pcie = irq_data_get_irq_chip_data(data);
+	phys_addr_t msi_addr = pcie->phys_pcie_reg_base;
+
+	msg->address_lo = lower_32_bits(msi_addr);
+	msg->address_hi = upper_32_bits(msi_addr);
+	msg->data = data->hwirq;
 }
 
-static irqreturn_t nwl_pcie_msi_handler(int irq, void *data)
+static int nwl_msi_set_affinity(struct irq_data *irq_data,
+				const struct cpumask *mask, bool force)
 {
-	struct nwl_pcie *pcie = data;
-	unsigned long reg;
-	int processed = 0;
+	return -EINVAL;
+}
 
-	reg = nwl_bridge_readl(pcie, MSGF_MSI_STATUS_LO);
-	if (reg) {
-		__nwl_pcie_msi_handler(pcie, reg, MSGF_MSI_STATUS_LO);
-		processed++;
-	}
+static struct irq_chip nwl_irq_chip = {
+	.name = "Xilinx MSI",
+	.irq_compose_msi_msg = nwl_compose_msi_msg,
+	.irq_set_affinity = nwl_msi_set_affinity,
+};
 
-	reg = nwl_bridge_readl(pcie, MSGF_MSI_STATUS_HI);
-	if (reg) {
-		__nwl_pcie_msi_handler(pcie, reg, MSGF_MSI_STATUS_HI);
-		processed++;
+static int nwl_irq_domain_alloc(struct irq_domain *domain, unsigned int virq,
+				unsigned int nr_irqs, void *args)
+{
+	struct nwl_pcie *pcie = domain->host_data;
+	struct nwl_msi *msi = &pcie->msi;
+	int bit;
+	int i;
+
+	mutex_lock(&msi->lock);
+	bit = bitmap_find_next_zero_area(msi->bitmap, INT_PCI_MSI_NR, 0,
+					 nr_irqs, 0);
+	if (bit >= INT_PCI_MSI_NR) {
+		mutex_unlock(&msi->lock);
+		return -ENOSPC;
 	}
 
-	return processed > 0 ? IRQ_HANDLED : IRQ_NONE;
+	bitmap_set(msi->bitmap, bit, nr_irqs);
+
+	for (i = 0; i < nr_irqs; i++) {
+		irq_domain_set_info(domain, virq + i, bit + i, &nwl_irq_chip,
+				domain->host_data, handle_simple_irq,
+				NULL, NULL);
+	}
+	mutex_unlock(&msi->lock);
+	return 0;
 }
 
-static int nwl_msi_alloc(struct nwl_msi *chip)
+static void nwl_irq_domain_free(struct irq_domain *domain, unsigned int virq,
+					unsigned int nr_irqs)
 {
-	int msi;
-
-	mutex_lock(&chip->lock);
-
-	msi = find_first_zero_bit(chip->used, INT_PCI_MSI_NR);
-	if (msi < INT_PCI_MSI_NR)
-		set_bit(msi, chip->used);
-	else
-		msi = -ENOSPC;
-
-	mutex_unlock(&chip->lock);
+	struct irq_data *data = irq_domain_get_irq_data(domain, virq);
+	struct nwl_pcie *pcie = irq_data_get_irq_chip_data(data);
+	struct nwl_msi *msi = &pcie->msi;
 
-	return msi;
+	mutex_lock(&msi->lock);
+	bitmap_clear(msi->bitmap, data->hwirq, nr_irqs);
+	mutex_unlock(&msi->lock);
 }
 
-static void nwl_msi_free(struct nwl_msi *chip, unsigned long irq)
+static const struct irq_domain_ops dev_msi_domain_ops = {
+	.alloc  = nwl_irq_domain_alloc,
+	.free   = nwl_irq_domain_free,
+};
+
+static void nwl_msi_free_irq_domain(struct nwl_pcie *pcie)
 {
-	struct device *dev = chip->chip.dev;
+	struct nwl_msi *msi = &pcie->msi;
 
-	mutex_lock(&chip->lock);
+	if (msi->irq_msi0)
+		irq_set_chained_handler_and_data(msi->irq_msi0, NULL, NULL);
+	if (msi->irq_msi1)
+		irq_set_chained_handler_and_data(msi->irq_msi1, NULL, NULL);
 
-	if (!test_bit(irq, chip->used))
-		dev_err(dev, "trying to free unused MSI#%lu\n", irq);
-	else
-		clear_bit(irq, chip->used);
+	if (msi->msi_domain)
+		irq_domain_remove(msi->msi_domain);
+	if (msi->dev_domain)
+		irq_domain_remove(msi->dev_domain);
 
-	mutex_unlock(&chip->lock);
+	kfree(msi->bitmap);
+	msi->bitmap = NULL;
 }
 
-static int nwl_msi_setup_irq(struct msi_controller *chip, struct pci_dev *pdev,
-			       struct msi_desc *desc)
+static void nwl_pcie_free_irq_domain(struct nwl_pcie *pcie)
 {
-	struct nwl_msi *msi = to_nwl_msi(chip);
-	struct msi_msg msg;
-	unsigned int irq;
-	int hwirq;
+	int i;
+	u32 irq;
 
-	if (desc->msi_attrib.is_msix) {
-		/* currently we are not supporting MSIx */
-		return -ENOSPC;
+	for (i = 0; i < INTX_NUM; i++) {
+		irq = irq_find_mapping(pcie->legacy_irq_domain, i + 1);
+		if (irq > 0)
+			irq_dispose_mapping(irq);
 	}
+	if (pcie->legacy_irq_domain)
+		irq_domain_remove(pcie->legacy_irq_domain);
 
-	hwirq = nwl_msi_alloc(msi);
-	if (hwirq < 0)
-		return hwirq;
-
-	irq = irq_create_mapping(msi->domain, hwirq);
-	if (!irq)
-		return -EINVAL;
-
-	irq_set_msi_desc(irq, desc);
-
-	msg.address_lo = virt_to_phys((void *)msi->pages);
-	/* 32 bit address only */
-	msg.address_hi = 0;
-	msg.data = hwirq;
+	nwl_msi_free_irq_domain(pcie);
+}
 
-	write_msi_msg(irq, &msg);
+static int nwl_pcie_init_msi_irq_domain(struct nwl_pcie *pcie)
+{
+#ifdef CONFIG_PCI_MSI
+	struct fwnode_handle *fwnode = of_node_to_fwnode(pcie->dev->of_node);
+	struct nwl_msi *msi = &pcie->msi;
 
+	msi->dev_domain = irq_domain_add_linear(NULL, INT_PCI_MSI_NR,
+						&dev_msi_domain_ops, pcie);
+	if (!msi->dev_domain) {
+		dev_err(pcie->dev, "failed to create dev IRQ domain\n");
+		return -ENOMEM;
+	}
+	msi->msi_domain = pci_msi_create_irq_domain(fwnode,
+						    &nwl_msi_domain_info,
+						    msi->dev_domain);
+	if (!msi->msi_domain) {
+		dev_err(pcie->dev, "failed to create msi IRQ domain\n");
+		irq_domain_remove(msi->dev_domain);
+		return -ENOMEM;
+	}
+#endif
 	return 0;
 }
 
-static void nwl_msi_teardown_irq(struct msi_controller *chip, unsigned int irq)
+static int nwl_pcie_init_irq_domain(struct nwl_pcie *pcie)
 {
-	struct nwl_msi *msi = to_nwl_msi(chip);
-	struct irq_data *d = irq_get_irq_data(irq);
+	struct device_node *node = pcie->dev->of_node;
+	struct device_node *legacy_intc_node;
 
-	nwl_msi_free(msi, d->hwirq);
-}
+	legacy_intc_node = of_get_next_child(node, NULL);
+	if (!legacy_intc_node) {
+		dev_err(pcie->dev, "No legacy intc node found\n");
+		return -EINVAL;
+	}
 
-static struct irq_chip nwl_msi_irq_chip = {
-	.name = "nwl_pcie:msi",
-	.irq_enable = unmask_msi_irq,
-	.irq_disable = mask_msi_irq,
-	.irq_mask = mask_msi_irq,
-	.irq_unmask = unmask_msi_irq,
-};
+	pcie->legacy_irq_domain = irq_domain_add_linear(legacy_intc_node,
+							INTX_NUM,
+							&legacy_domain_ops,
+							pcie);
 
-static int nwl_msi_map(struct irq_domain *domain, unsigned int irq,
-			 irq_hw_number_t hwirq)
-{
-	irq_set_chip_and_handler(irq, &nwl_msi_irq_chip, handle_simple_irq);
-	irq_set_chip_data(irq, domain->host_data);
-	set_irq_flags(irq, IRQF_VALID);
+	if (!pcie->legacy_irq_domain) {
+		dev_err(pcie->dev, "failed to create IRQ domain\n");
+		return -ENOMEM;
+	}
 
+	nwl_pcie_init_msi_irq_domain(pcie);
 	return 0;
 }
 
-static const struct irq_domain_ops msi_domain_ops = {
-	.map = nwl_msi_map,
-};
-
 static int nwl_pcie_enable_msi(struct nwl_pcie *pcie, struct pci_bus *bus)
 {
 	struct platform_device *pdev = to_platform_device(pcie->dev);
 	struct nwl_msi *msi = &pcie->msi;
 	unsigned long base;
 	int ret;
+	int size = BITS_TO_LONGS(INT_PCI_MSI_NR) * sizeof(long);
 
 	mutex_init(&msi->lock);
 
-	/* Assign msi chip hooks */
-	msi->chip.dev = pcie->dev;
-	msi->chip.setup_irq = nwl_msi_setup_irq;
-	msi->chip.teardown_irq = nwl_msi_teardown_irq;
-
-	bus->msi = &msi->chip;
-	/* Allocate linear irq domain */
-	msi->domain = irq_domain_add_linear(pcie->dev->of_node, INT_PCI_MSI_NR,
-					    &msi_domain_ops, &msi->chip);
-	if (!msi->domain) {
-		dev_err(&pdev->dev, "failed to create IRQ domain\n");
+	msi->bitmap = kzalloc(size, GFP_KERNEL);
+	if (!msi->bitmap)
 		return -ENOMEM;
+
+	/* Get msi_1 IRQ number */
+	msi->irq_msi1 = platform_get_irq_byname(pdev, "msi1");
+	if (msi->irq_msi1 < 0) {
+		dev_err(&pdev->dev, "failed to get IRQ#%d\n", msi->irq_msi1);
+		ret = -EINVAL;
+		goto err;
 	}
 
+	irq_set_chained_handler_and_data(msi->irq_msi1,
+					 nwl_pcie_msi_handler_high, pcie);
+
+	/* Get msi_0 IRQ number */
+	msi->irq_msi0 = platform_get_irq_byname(pdev, "msi0");
+	if (msi->irq_msi0 < 0) {
+		dev_err(&pdev->dev, "failed to get IRQ#%d\n", msi->irq_msi0);
+		ret = -EINVAL;
+		goto err;
+	}
+
+	irq_set_chained_handler_and_data(msi->irq_msi0,
+					 nwl_pcie_msi_handler_low, pcie);
+
 	/* Check for msii_present bit */
 	ret = nwl_bridge_readl(pcie, I_MSII_CAPABILITIES) & MSII_PRESENT;
 	if (!ret) {
@@ -784,125 +589,62 @@ static int nwl_pcie_enable_msi(struct nwl_pcie *pcie, struct pci_bus *bus)
 	/* Enable MSII */
 	nwl_bridge_writel(pcie, nwl_bridge_readl(pcie, I_MSII_CONTROL) |
 			  MSII_ENABLE, I_MSII_CONTROL);
-	if (!pcie->enable_msi_fifo)
-		/* Enable MSII status */
-		nwl_bridge_writel(pcie, nwl_bridge_readl(pcie, I_MSII_CONTROL) |
-				  MSII_STATUS_ENABLE, I_MSII_CONTROL);
 
-	/* setup AFI/FPCI range */
-	msi->pages = __get_free_pages(GFP_KERNEL, 0);
-	base = virt_to_phys((void *)msi->pages);
-	/* Write base to MSII_BASE_LO */
-	nwl_bridge_writel(pcie, base, I_MSII_BASE_LO);
-
-	/* Write 0x0 to MSII_BASE_HI */
-	nwl_bridge_writel(pcie, 0x0, I_MSII_BASE_HI);
+	/* Enable MSII status */
+	nwl_bridge_writel(pcie, nwl_bridge_readl(pcie, I_MSII_CONTROL) |
+			  MSII_STATUS_ENABLE, I_MSII_CONTROL);
 
-	/* Disable high range msi interrupts */
+	/* setup AFI/FPCI range */
+	base = pcie->phys_pcie_reg_base;
+	nwl_bridge_writel(pcie, lower_32_bits(base), I_MSII_BASE_LO);
+	nwl_bridge_writel(pcie, upper_32_bits(base), I_MSII_BASE_HI);
+
+	/*
+	 * For high range MSI interrupts: disable, clear any pending,
+	 * and enable
+	 */
 	nwl_bridge_writel(pcie, (u32)~MSGF_MSI_SR_HI_MASK, MSGF_MSI_MASK_HI);
 
-	/* Clear pending high range msi interrupts */
 	nwl_bridge_writel(pcie, nwl_bridge_readl(pcie,  MSGF_MSI_STATUS_HI) &
 			  MSGF_MSI_SR_HI_MASK, MSGF_MSI_STATUS_HI);
-	/* Get msi_1 IRQ number */
-	msi->irq_msi1 = platform_get_irq_byname(pdev, "msi_1");
-	if (msi->irq_msi1 < 0) {
-		dev_err(&pdev->dev, "failed to get IRQ#%d\n", msi->irq_msi1);
-		goto err;
-	}
-	/* Register msi handler */
-	ret = devm_request_irq(pcie->dev, msi->irq_msi1, nwl_pcie_msi_handler,
-			       0, nwl_msi_irq_chip.name, pcie);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "failed to request IRQ#%d\n",
-					msi->irq_msi1);
-		goto err;
-	}
 
-	/* Enable all high range msi interrupts */
 	nwl_bridge_writel(pcie, MSGF_MSI_SR_HI_MASK, MSGF_MSI_MASK_HI);
 
-	/* Disable low range msi interrupts */
+	/*
+	 * For low range MSI interrupts: disable, clear any pending,
+	 * and enable
+	 */
 	nwl_bridge_writel(pcie, (u32)~MSGF_MSI_SR_LO_MASK, MSGF_MSI_MASK_LO);
 
-	/* Clear pending low range msi interrupts */
 	nwl_bridge_writel(pcie, nwl_bridge_readl(pcie, MSGF_MSI_STATUS_LO) &
 			  MSGF_MSI_SR_LO_MASK, MSGF_MSI_STATUS_LO);
-	/* Get msi_0 IRQ number */
-	msi->irq_msi0 = platform_get_irq_byname(pdev, "msi_0");
-	if (msi->irq_msi0 < 0) {
-		dev_err(&pdev->dev, "failed to get IRQ#%d\n", msi->irq_msi0);
-		goto err;
-	}
-	/* Register msi handler */
-	ret = devm_request_irq(pcie->dev, msi->irq_msi0, nwl_pcie_msi_handler,
-			       0, nwl_msi_irq_chip.name, pcie);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "failed to request IRQ#%d\n",
-					msi->irq_msi0);
-		goto err;
-	}
-	/* Enable all low range msi interrupts */
+
 	nwl_bridge_writel(pcie, MSGF_MSI_SR_LO_MASK, MSGF_MSI_MASK_LO);
 
 	return 0;
 err:
-	irq_domain_remove(msi->domain);
+	kfree(msi->bitmap);
+	msi->bitmap = NULL;
 	return ret;
 }
 
-static void nwl_pcie_free_irq_domain(struct nwl_pcie *pcie)
-{
-	int i;
-	u32 irq;
-
-	for (i = 0; i < INTX_NUM; i++) {
-		irq = irq_find_mapping(pcie->legacy_irq_domain, i + 1);
-		if (irq > 0)
-			irq_dispose_mapping(irq);
-	}
-	if (pcie->legacy_irq_domain)
-		irq_domain_remove(pcie->legacy_irq_domain);
-}
-
-static int nwl_pcie_init_irq_domain(struct nwl_pcie *pcie)
-{
-	struct device_node *node = pcie->dev->of_node;
-	struct device_node *legacy_intc_node;
-
-	legacy_intc_node = of_get_next_child(node, NULL);
-	if (!legacy_intc_node) {
-		dev_err(pcie->dev, "No legacy intc node found\n");
-		return PTR_ERR(legacy_intc_node);
-	}
-
-	pcie->legacy_irq_domain = irq_domain_add_linear(legacy_intc_node, 4,
-							&legacy_domain_ops,
-							pcie);
-
-	if (!pcie->legacy_irq_domain) {
-		dev_err(pcie->dev, "failed to create IRQ domain\n");
-		return -ENOMEM;
-	}
-	return 0;
-}
-
 static int nwl_pcie_bridge_init(struct nwl_pcie *pcie)
 {
 	struct platform_device *pdev = to_platform_device(pcie->dev);
 	u32 breg_val, ecam_val, first_busno = 0;
 	int err;
-	int check_link_up = 0;
 
-	/* Check for BREG present bit */
 	breg_val = nwl_bridge_readl(pcie, E_BREG_CAPABILITIES) & BREG_PRESENT;
 	if (!breg_val) {
 		dev_err(pcie->dev, "BREG is not present\n");
 		return breg_val;
 	}
+
 	/* Write bridge_off to breg base */
-	nwl_bridge_writel(pcie, (u32)(pcie->phys_breg_base),
+	nwl_bridge_writel(pcie, lower_32_bits(pcie->phys_breg_base),
 			  E_BREG_BASE_LO);
+	nwl_bridge_writel(pcie, upper_32_bits(pcie->phys_breg_base),
+			  E_BREG_BASE_HI);
 
 	/* Enable BREG */
 	nwl_bridge_writel(pcie, ~BREG_ENABLE_FORCE & BREG_ENABLE,
@@ -918,16 +660,11 @@ static int nwl_pcie_bridge_init(struct nwl_pcie *pcie)
 	/* Enable msg filtering details */
 	nwl_bridge_writel(pcie, CFG_ENABLE_MSG_FILTER_MASK,
 			  BRCFG_PCIE_RX_MSG_FILTER);
-	do {
-		err = nwl_pcie_is_link_up(pcie, PHY_RDY_LINKUP);
-		if (err != 1) {
-			check_link_up++;
-			if (check_link_up > LINKUP_ITER_CHECK)
-				return -ENODEV;
-		}
-	} while (!err);
 
-	/* Check for ECAM present bit */
+	err = nwl_wait_for_link(pcie);
+	if (err)
+		return err;
+
 	ecam_val = nwl_bridge_readl(pcie, E_ECAM_CAPABILITIES) & E_ECAM_PRESENT;
 	if (!ecam_val) {
 		dev_err(pcie->dev, "ECAM is not present\n");
@@ -937,12 +674,15 @@ static int nwl_pcie_bridge_init(struct nwl_pcie *pcie)
 	/* Enable ECAM */
 	nwl_bridge_writel(pcie, nwl_bridge_readl(pcie, E_ECAM_CONTROL) |
 			  E_ECAM_CR_ENABLE, E_ECAM_CONTROL);
-	/* Write ecam_value on ecam_control */
+
 	nwl_bridge_writel(pcie, nwl_bridge_readl(pcie, E_ECAM_CONTROL) |
 			  (pcie->ecam_value << E_ECAM_SIZE_SHIFT),
 			  E_ECAM_CONTROL);
-	/* Write phy_reg_base to ecam base */
-	nwl_bridge_writel(pcie, (u32)pcie->phys_ecam_base, E_ECAM_BASE_LO);
+
+	nwl_bridge_writel(pcie, lower_32_bits(pcie->phys_ecam_base),
+			  E_ECAM_BASE_LO);
+	nwl_bridge_writel(pcie, upper_32_bits(pcie->phys_ecam_base),
+			  E_ECAM_BASE_HI);
 
 	/* Get bus range */
 	ecam_val = nwl_bridge_readl(pcie, E_ECAM_CONTROL);
@@ -953,28 +693,19 @@ static int nwl_pcie_bridge_init(struct nwl_pcie *pcie)
 	ecam_val |= (pcie->last_busno << E_ECAM_SIZE_SHIFT);
 	writel(ecam_val, (pcie->ecam_base + PCI_PRIMARY_BUS));
 
-	/* Check if PCIe link is up? */
-	pcie->link_up = nwl_pcie_is_link_up(pcie, PCIE_USER_LINKUP);
-	if (!pcie->link_up)
-		dev_info(pcie->dev, "Link is DOWN\n");
-	else
+	if (nwl_pcie_link_up(pcie))
 		dev_info(pcie->dev, "Link is UP\n");
-
-	/* Disable all misc interrupts */
-	nwl_bridge_writel(pcie, (u32)~MSGF_MISC_SR_MASKALL, MSGF_MISC_MASK);
-
-	/* Clear pending misc interrupts */
-	nwl_bridge_writel(pcie, nwl_bridge_readl(pcie, MSGF_MISC_STATUS) &
-			  MSGF_MISC_SR_MASKALL, MSGF_MISC_STATUS);
+	else
+		dev_info(pcie->dev, "Link is DOWN\n");
 
 	/* Get misc IRQ number */
 	pcie->irq_misc = platform_get_irq_byname(pdev, "misc");
 	if (pcie->irq_misc < 0) {
-		dev_err(&pdev->dev, "failed to get misc IRQ#%d\n",
+		dev_err(&pdev->dev, "failed to get misc IRQ %d\n",
 			pcie->irq_misc);
-		return pcie->irq_misc;
+		return -EINVAL;
 	}
-	/* Register misc handler */
+
 	err = devm_request_irq(pcie->dev, pcie->irq_misc,
 			       nwl_pcie_misc_handler, IRQF_SHARED,
 			       "nwl_pcie:misc", pcie);
@@ -983,45 +714,37 @@ static int nwl_pcie_bridge_init(struct nwl_pcie *pcie)
 			pcie->irq_misc);
 		return err;
 	}
+
+	/* Disable all misc interrupts */
+	nwl_bridge_writel(pcie, (u32)~MSGF_MISC_SR_MASKALL, MSGF_MISC_MASK);
+
+	/* Clear pending misc interrupts */
+	nwl_bridge_writel(pcie, nwl_bridge_readl(pcie, MSGF_MISC_STATUS) &
+			  MSGF_MISC_SR_MASKALL, MSGF_MISC_STATUS);
+
 	/* Enable all misc interrupts */
 	nwl_bridge_writel(pcie, MSGF_MISC_SR_MASKALL, MSGF_MISC_MASK);
 
+
 	/* Disable all legacy interrupts */
 	nwl_bridge_writel(pcie, (u32)~MSGF_LEG_SR_MASKALL, MSGF_LEG_MASK);
 
 	/* Clear pending legacy interrupts */
 	nwl_bridge_writel(pcie, nwl_bridge_readl(pcie, MSGF_LEG_STATUS) &
 			  MSGF_LEG_SR_MASKALL, MSGF_LEG_STATUS);
-	/* Get intx IRQ number */
-	pcie->irq_intx = platform_get_irq_byname(pdev, "intx");
-	if (pcie->irq_intx < 0) {
-		dev_err(&pdev->dev, "failed to get intx IRQ#%d\n",
-			pcie->irq_intx);
-		return pcie->irq_intx;
-	}
 
-	/* Register intx handler */
-	err = devm_request_irq(pcie->dev, pcie->irq_intx,
-			       nwl_pcie_leg_handler, IRQF_SHARED,
-			       "nwl_pcie:intx", pcie);
-	if (err) {
-		dev_err(pcie->dev, "fail to register intx IRQ#%d\n",
-			pcie->irq_intx);
-		return err;
-	}
+	/* Enable all legacy interrupts */
+	nwl_bridge_writel(pcie, MSGF_LEG_SR_MASKALL, MSGF_LEG_MASK);
 
 	/* Enable the bridge config interrupt */
 	nwl_bridge_writel(pcie, nwl_bridge_readl(pcie, BRCFG_INTERRUPT) |
 			  BRCFG_INTERRUPT_MASK, BRCFG_INTERRUPT);
 
-	/* Enable all legacy interrupts */
-	nwl_bridge_writel(pcie, MSGF_LEG_SR_MASKALL, MSGF_LEG_MASK);
-
 	return 0;
 }
 
 static int nwl_pcie_parse_dt(struct nwl_pcie *pcie,
-					struct platform_device *pdev)
+			     struct platform_device *pdev)
 {
 	struct device_node *node = pcie->dev->of_node;
 	struct resource *res;
@@ -1052,7 +775,16 @@ static int nwl_pcie_parse_dt(struct nwl_pcie *pcie,
 		return PTR_ERR(pcie->ecam_base);
 	pcie->phys_ecam_base = res->start;
 
-	pcie->enable_msi_fifo = of_property_read_bool(node, "xlnx,msi-fifo");
+	/* Get intx IRQ number */
+	pcie->irq_intx = platform_get_irq_byname(pdev, "intx");
+	if (pcie->irq_intx < 0) {
+		dev_err(&pdev->dev, "failed to get intx IRQ %d\n",
+			pcie->irq_intx);
+		return -EINVAL;
+	}
+
+	irq_set_chained_handler_and_data(pcie->irq_intx,
+					 nwl_pcie_leg_handler, pcie);
 
 	return 0;
 }
@@ -1069,27 +801,22 @@ static int nwl_pcie_probe(struct platform_device *pdev)
 	struct pci_bus *bus;
 	struct pci_bus *child;
 	int err;
-
 	resource_size_t iobase = 0;
 	LIST_HEAD(res);
 
-	/* Allocate private nwl_pcie struct */
 	pcie = devm_kzalloc(&pdev->dev, sizeof(*pcie), GFP_KERNEL);
 	if (!pcie)
 		return -ENOMEM;
 
-	/* Set ecam value */
-	pcie->ecam_value = NWL_ECAM_VALUE_DEFAULT;
-
 	pcie->dev = &pdev->dev;
+	pcie->ecam_value = NWL_ECAM_VALUE_DEFAULT;
 
-	/* Parse the device tree */
 	err = nwl_pcie_parse_dt(pcie, pdev);
 	if (err) {
 		dev_err(pcie->dev, "Parsing DT failed\n");
 		return err;
 	}
-	/* Bridge initialization */
+
 	err = nwl_pcie_bridge_init(pcie);
 	if (err) {
 		dev_err(pcie->dev, "HW Initalization failed\n");
@@ -1107,18 +834,17 @@ static int nwl_pcie_probe(struct platform_device *pdev)
 		dev_err(pcie->dev, "Failed creating IRQ Domain\n");
 		return err;
 	}
+
 	bus = pci_create_root_bus(&pdev->dev, pcie->root_busno,
 				  &nwl_pcie_ops, pcie, &res);
 	if (!bus)
 		return -ENOMEM;
 
-	/* Enable MSI */
 	if (IS_ENABLED(CONFIG_PCI_MSI)) {
 		err = nwl_pcie_enable_msi(pcie, bus);
 		if (err < 0) {
 			dev_err(&pdev->dev,
-				"failed to enable MSI support: %d\n",
-				err);
+				"failed to enable MSI support: %d\n", err);
 			return err;
 		}
 	}
@@ -1128,7 +854,6 @@ static int nwl_pcie_probe(struct platform_device *pdev)
 		pcie_bus_configure_settings(child);
 	pci_bus_add_devices(bus);
 	platform_set_drvdata(pdev, pcie);
-
 	return 0;
 }
 
@@ -1138,7 +863,6 @@ static int nwl_pcie_remove(struct platform_device *pdev)
 
 	nwl_pcie_free_irq_domain(pcie);
 	platform_set_drvdata(pdev, NULL);
-
 	return 0;
 }
 
-- 
2.9.3

