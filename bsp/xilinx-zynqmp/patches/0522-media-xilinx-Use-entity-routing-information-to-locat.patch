From f5a762e1d6a5aadfeaa8e1c65cb950ee690ca4e8 Mon Sep 17 00:00:00 2001
From: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date: Wed, 26 Mar 2014 04:01:57 +0100
Subject: [PATCH 522/827] media: xilinx: Use entity routing information to locate source pad

This patch comes from:
  https://github.com/Xilinx/linux-xlnx.git

This prepares the stream handling code for pipelines containing a
switch.

Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
(cherry picked from commit 5dd07977852771a5b14e157ccd2631a3d5d6c1f3)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/media/platform/xilinx/xilinx-vipp.c | 36 ++++++++++++++++++++++++++++-
 1 file changed, 35 insertions(+), 1 deletion(-)

diff --git a/drivers/media/platform/xilinx/xilinx-vipp.c b/drivers/media/platform/xilinx/xilinx-vipp.c
index 83f8190..1728a84 100644
--- a/drivers/media/platform/xilinx/xilinx-vipp.c
+++ b/drivers/media/platform/xilinx/xilinx-vipp.c
@@ -48,6 +48,35 @@ struct xvip_graph_entity {
  * Pipeline Stream Management
  */
 
+/* Get the sink pad internally connected to a source pad in the given entity. */
+static struct media_pad *xvip_get_entity_sink(struct media_entity *entity,
+					      struct media_pad *source)
+{
+	unsigned int i;
+
+	/* The source pad can be NULL when the entity has no source pad. Return
+	 * the first pad in that case, guaranteed to be a sink pad.
+	 */
+	if (source == NULL)
+		return &entity->pads[0];
+
+	/* Iterates through the pads to find a connected sink pad. */
+	for (i = 0; i < entity->num_pads; ++i) {
+		struct media_pad *sink = &entity->pads[i];
+
+		if (!(sink->flags & MEDIA_PAD_FL_SINK))
+			continue;
+
+		if (sink == source)
+			continue;
+
+		if (media_entity_has_route(entity, sink->index, source->index))
+			return sink;
+	}
+
+	return NULL;
+}
+
 /**
  * xvip_pipeline_start_stop - Start ot stop streaming on a pipeline
  * @xdev: Xilinx video composite device
@@ -68,8 +97,13 @@ static int xvip_pipeline_start_stop(struct xvip_composite_device *xdev,
 	int ret;
 
 	entity = &xdev->dma[XVIPP_DMA_S2MM].video.entity;
+	pad = NULL;
+
 	while (1) {
-		pad = &entity->pads[0];
+		pad = xvip_get_entity_sink(entity, pad);
+		if (IS_ERR(pad))
+			return PTR_ERR(pad);
+
 		if (!(pad->flags & MEDIA_PAD_FL_SINK))
 			break;
 
-- 
2.9.3

