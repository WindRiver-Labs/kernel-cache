From 6d13a22b81f5de72adca79f746d1c02c588d77f5 Mon Sep 17 00:00:00 2001
From: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date: Fri, 24 Jan 2014 00:38:30 +0100
Subject: [PATCH 553/827] media: xilinx: vip: Group functions in sections

This patch comes from:
  https://github.com/Xilinx/linux-xlnx.git

Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
(cherry picked from commit 610c06ee17410628f88366520a8b82c5262ca186)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/media/platform/xilinx/xilinx-vip.c | 152 +++++++++++++++--------------
 1 file changed, 78 insertions(+), 74 deletions(-)

diff --git a/drivers/media/platform/xilinx/xilinx-vip.c b/drivers/media/platform/xilinx/xilinx-vip.c
index ee03060..a212f52 100644
--- a/drivers/media/platform/xilinx/xilinx-vip.c
+++ b/drivers/media/platform/xilinx/xilinx-vip.c
@@ -195,80 +195,6 @@ EXPORT_SYMBOL_GPL(xvip_clr_and_set);
  */
 
 /**
- * xvip_enum_mbus_code - Enumerate the media format code
- * @subdev: V4L2 subdevice
- * @fh: V4L2 subdevice file handle
- * @code: returning media bus code
- *
- * Enumerate the media bus code of the subdevice. Return the corresponding
- * pad format code. This function only works for subdevices with fixed format
- * on all pads. Subdevices with multiple format should have their own
- * function to enumerate mbus codes.
- *
- * Return: 0 if the media bus code is found, or -EINVAL if the format index
- * is not valid.
- */
-int xvip_enum_mbus_code(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh,
-			struct v4l2_subdev_mbus_code_enum *code)
-{
-	struct v4l2_mbus_framefmt *format;
-
-	if (code->index)
-		return -EINVAL;
-
-	format = v4l2_subdev_get_try_format(fh, code->pad);
-
-	code->code = format->code;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(xvip_enum_mbus_code);
-
-/**
- * xvip_enum_frame_size - Enumerate the media bus frame size
- * @subdev: V4L2 subdevice
- * @fh: V4L2 subdevice file handle
- * @fse: returning media bus frame size
- *
- * This function is a drop-in implementation of the subdev enum_frame_size pad
- * operation. It assumes that the subdevice has one sink pad and one source
- * pad, and that the format on the source pad is always identical to the
- * format on the sink pad. Entities with different requirements need to
- * implement their own enum_frame_size handlers.
- *
- * Return: 0 if the media bus frame size is found, or -EINVAL
- * if the index or the code is not valid.
- */
-int xvip_enum_frame_size(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh,
-			 struct v4l2_subdev_frame_size_enum *fse)
-{
-	struct v4l2_mbus_framefmt *format;
-
-	format = v4l2_subdev_get_try_format(fh, fse->pad);
-
-	if (fse->index || fse->code != format->code)
-		return -EINVAL;
-
-	if (fse->pad == XVIP_PAD_SINK) {
-		fse->min_width = XVIP_MIN_WIDTH;
-		fse->max_width = XVIP_MAX_WIDTH;
-		fse->min_height = XVIP_MIN_HEIGHT;
-		fse->max_height = XVIP_MAX_HEIGHT;
-	} else {
-		/* The size on the source pad is fixed and always identical to
-		 * the size on the sink pad.
-		 */
-		fse->min_width = format->width;
-		fse->max_width = format->width;
-		fse->min_height = format->height;
-		fse->max_height = format->height;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(xvip_enum_frame_size);
-
-/**
  * xvip_get_pad_format - Get the frame format on media bus for the pad
  * @fh: V4L2 subdevice file handle
  * @format: V4L2 active frame format on media bus
@@ -358,6 +284,84 @@ void xvip_init_formats(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
 EXPORT_SYMBOL_GPL(xvip_init_formats);
 
 /* -----------------------------------------------------------------------------
+ * Subdev operations handlers
+ */
+
+/**
+ * xvip_enum_mbus_code - Enumerate the media format code
+ * @subdev: V4L2 subdevice
+ * @fh: V4L2 subdevice file handle
+ * @code: returning media bus code
+ *
+ * Enumerate the media bus code of the subdevice. Return the corresponding
+ * pad format code. This function only works for subdevices with fixed format
+ * on all pads. Subdevices with multiple format should have their own
+ * function to enumerate mbus codes.
+ *
+ * Return: 0 if the media bus code is found, or -EINVAL if the format index
+ * is not valid.
+ */
+int xvip_enum_mbus_code(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh,
+			struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	if (code->index)
+		return -EINVAL;
+
+	format = v4l2_subdev_get_try_format(fh, code->pad);
+
+	code->code = format->code;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(xvip_enum_mbus_code);
+
+/**
+ * xvip_enum_frame_size - Enumerate the media bus frame size
+ * @subdev: V4L2 subdevice
+ * @fh: V4L2 subdevice file handle
+ * @fse: returning media bus frame size
+ *
+ * This function is a drop-in implementation of the subdev enum_frame_size pad
+ * operation. It assumes that the subdevice has one sink pad and one source
+ * pad, and that the format on the source pad is always identical to the
+ * format on the sink pad. Entities with different requirements need to
+ * implement their own enum_frame_size handlers.
+ *
+ * Return: 0 if the media bus frame size is found, or -EINVAL
+ * if the index or the code is not valid.
+ */
+int xvip_enum_frame_size(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh,
+			 struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	format = v4l2_subdev_get_try_format(fh, fse->pad);
+
+	if (fse->index || fse->code != format->code)
+		return -EINVAL;
+
+	if (fse->pad == XVIP_PAD_SINK) {
+		fse->min_width = XVIP_MIN_WIDTH;
+		fse->max_width = XVIP_MAX_WIDTH;
+		fse->min_height = XVIP_MIN_HEIGHT;
+		fse->max_height = XVIP_MAX_HEIGHT;
+	} else {
+		/* The size on the source pad is fixed and always identical to
+		 * the size on the sink pad.
+		 */
+		fse->min_width = format->width;
+		fse->max_width = format->width;
+		fse->min_height = format->height;
+		fse->max_height = format->height;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(xvip_enum_frame_size);
+
+/* -----------------------------------------------------------------------------
  * Initialization and cleanup
  */
 
-- 
2.9.3

