From 4f8d4c4667b44cea30541f51f62ab982bcb51fa9 Mon Sep 17 00:00:00 2001
From: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date: Wed, 26 Mar 2014 15:46:45 +0100
Subject: [PATCH 529/827] media: xilinx: tpg: Add VTC support

This patch comes from:
  https://github.com/Xilinx/linux-xlnx.git

commit cad4f22295c98eb1b030a462df7a8ebaf77a1d91 upstream

When configured in pattern generation (non-passthrough) mode the TPG
requires a VTC generator to supply timing information. Request the VTC
if specified in the device tree and configure it when starting and
stopping the stream.

Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/media/platform/xilinx/Kconfig      |  1 +
 drivers/media/platform/xilinx/xilinx-tpg.c | 31 +++++++++++++++++++++++++++++-
 2 files changed, 31 insertions(+), 1 deletion(-)

diff --git a/drivers/media/platform/xilinx/Kconfig b/drivers/media/platform/xilinx/Kconfig
index 5411771..24faacf 100644
--- a/drivers/media/platform/xilinx/Kconfig
+++ b/drivers/media/platform/xilinx/Kconfig
@@ -46,6 +46,7 @@ config VIDEO_XILINX_SWITCH
 config VIDEO_XILINX_TPG
 	tristate "Xilinx Video Test Pattern Generator"
 	depends on VIDEO_XILINX
+	select VIDEO_XILINX_VTC
 	---help---
 	   Driver for the Xilinx Video Test Pattern Generator
 
diff --git a/drivers/media/platform/xilinx/xilinx-tpg.c b/drivers/media/platform/xilinx/xilinx-tpg.c
index 7fe96bc..b8b89b2 100644
--- a/drivers/media/platform/xilinx/xilinx-tpg.c
+++ b/drivers/media/platform/xilinx/xilinx-tpg.c
@@ -21,6 +21,7 @@
 
 #include "xilinx-controls.h"
 #include "xilinx-vip.h"
+#include "xilinx-vtc.h"
 
 #define XTPG_CTRL_STATUS_SLAVE_ERROR		(1 << 16)
 #define XTPG_CTRL_IRQ_SLAVE_ERROR		(1 << 16)
@@ -67,6 +68,7 @@
  * @vip_format: format information corresponding to the active format
  * @bayer: boolean flag if TPG is set to any bayer format
  * @ctrl_handler: control handler
+ * @vtc: video timing controller
  */
 struct xtpg_device {
 	struct xvip_device xvip;
@@ -80,6 +82,8 @@ struct xtpg_device {
 	bool bayer;
 
 	struct v4l2_ctrl_handler ctrl_handler;
+
+	struct xvtc_device *vtc;
 };
 
 static inline struct xtpg_device *to_tpg(struct v4l2_subdev *subdev)
@@ -94,14 +98,33 @@ static inline struct xtpg_device *to_tpg(struct v4l2_subdev *subdev)
 static int xtpg_s_stream(struct v4l2_subdev *subdev, int enable)
 {
 	struct xtpg_device *xtpg = to_tpg(subdev);
+	unsigned int width = xtpg->formats[0].width;
+	unsigned int height = xtpg->formats[0].height;
 
 	if (!enable) {
 		xvip_stop(&xtpg->xvip);
+		if (xtpg->vtc)
+			xvtc_generator_stop(xtpg->vtc);
 		return 0;
 	}
 
 	xvip_set_frame_size(&xtpg->xvip, &xtpg->formats[0]);
 
+	if (xtpg->vtc) {
+		struct xvtc_config config = {
+			.hblank_start = width,
+			.hsync_start = width + 10,
+			.hsync_end = width + 20,
+			.hsize = width + 100,
+			.vblank_start = height,
+			.vsync_start = height + 10,
+			.vsync_end = height + 20,
+			.vsize = height + 100,
+		};
+
+		xvtc_generator_start(xtpg->vtc, &config);
+	}
+
 	xvip_start(&xtpg->xvip);
 
 	return 0;
@@ -671,6 +694,10 @@ static int xtpg_probe(struct platform_device *pdev)
 	if (IS_ERR(xtpg->xvip.iomem))
 		return PTR_ERR(xtpg->xvip.iomem);
 
+	xtpg->vtc = xvtc_of_get(pdev->dev.of_node);
+	if (IS_ERR(xtpg->vtc))
+		return PTR_ERR(xtpg->vtc);
+
 	/* Reset and initialize the core */
 	xvip_reset(&xtpg->xvip);
 
@@ -710,7 +737,7 @@ static int xtpg_probe(struct platform_device *pdev)
 
 	ret = media_entity_init(&subdev->entity, xtpg->npads, xtpg->pads, 0);
 	if (ret < 0)
-		return ret;
+		goto error_media_init;
 
 	v4l2_ctrl_handler_init(&xtpg->ctrl_handler, 18);
 
@@ -752,6 +779,8 @@ static int xtpg_probe(struct platform_device *pdev)
 error:
 	v4l2_ctrl_handler_free(&xtpg->ctrl_handler);
 	media_entity_cleanup(&subdev->entity);
+error_media_init:
+	xvtc_put(xtpg->vtc);
 	return ret;
 }
 
-- 
2.9.3

