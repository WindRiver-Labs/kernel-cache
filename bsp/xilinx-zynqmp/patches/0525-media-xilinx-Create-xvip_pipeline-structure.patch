From c4b6d70240bf6f5ba4d7f222f22398f7094bbc9d Mon Sep 17 00:00:00 2001
From: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date: Wed, 26 Mar 2014 04:02:00 +0100
Subject: [PATCH 525/827] media: xilinx: Create xvip_pipeline structure

This patch comes from:
  https://github.com/Xilinx/linux-xlnx.git

The new pipeline structure groups fields related to video streaming in a
linear pipeline.

Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
(cherry picked from commit 89e0e6755b3444896f314e6623cf1c6c560d5c7a)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/media/platform/xilinx/xilinx-dma.c  | 163 ++++++++++++++++++++++++----
 drivers/media/platform/xilinx/xilinx-dma.h  |  27 +++++
 drivers/media/platform/xilinx/xilinx-vipp.c |   6 +-
 drivers/media/platform/xilinx/xilinx-vipp.h |  12 --
 4 files changed, 170 insertions(+), 38 deletions(-)

diff --git a/drivers/media/platform/xilinx/xilinx-dma.c b/drivers/media/platform/xilinx/xilinx-dma.c
index 5640f27..c95f9c4 100644
--- a/drivers/media/platform/xilinx/xilinx-dma.c
+++ b/drivers/media/platform/xilinx/xilinx-dma.c
@@ -116,7 +116,7 @@ static struct media_pad *xvip_get_entity_sink(struct media_entity *entity,
 
 /**
  * xvip_pipeline_start_stop - Start ot stop streaming on a pipeline
- * @xdev: Xilinx video composite device
+ * @pipe: The pipeline
  * @start: Start (when true) or stop (when false) the pipeline
  *
  * Walk the entities chain starting at the pipeline output video node and start
@@ -125,15 +125,15 @@ static struct media_pad *xvip_get_entity_sink(struct media_entity *entity,
  * Return: 0 if successful, or the return value of the failed video::s_stream
  * operation otherwise.
  */
-static int xvip_pipeline_start_stop(struct xvip_composite_device *xdev,
-				    bool start)
+static int xvip_pipeline_start_stop(struct xvip_pipeline *pipe, bool start)
 {
+	struct xvip_dma *dma = pipe->output;
 	struct media_entity *entity;
 	struct media_pad *pad;
 	struct v4l2_subdev *subdev;
 	int ret;
 
-	entity = &xdev->dma[XVIPP_DMA_S2MM].video.entity;
+	entity = &dma->video.entity;
 	pad = NULL;
 
 	while (1) {
@@ -162,7 +162,7 @@ static int xvip_pipeline_start_stop(struct xvip_composite_device *xdev,
 
 /**
  * xvip_pipeline_set_stream - Enable/disable streaming on a pipeline
- * @xdev: Xilinx video composite device
+ * @pipe: The pipeline
  * @on: Turn the stream on when true or off when false
  *
  * The pipeline is shared between all DMA engines connect at its input and
@@ -185,26 +185,124 @@ static int xvip_pipeline_start_stop(struct xvip_composite_device *xdev,
  * operation otherwise. Stopping the pipeline never fails. The pipeline state is
  * not updated when the operation fails.
  */
-static int xvip_pipeline_set_stream(struct xvip_composite_device *xdev, bool on)
+static int xvip_pipeline_set_stream(struct xvip_pipeline *pipe, bool on)
 {
 	int ret = 0;
 
-	mutex_lock(&xdev->lock);
+	mutex_lock(&pipe->lock);
 
 	if (on) {
-		if (xdev->stream_count == xdev->num_dmas - 1) {
-			ret = xvip_pipeline_start_stop(xdev, true);
+		if (pipe->stream_count == pipe->num_dmas - 1) {
+			ret = xvip_pipeline_start_stop(pipe, true);
 			if (ret < 0)
 				goto done;
 		}
-		xdev->stream_count++;
+		pipe->stream_count++;
 	} else {
-		if (--xdev->stream_count == 0)
-			xvip_pipeline_start_stop(xdev, false);
+		if (--pipe->stream_count == 0)
+			xvip_pipeline_start_stop(pipe, false);
 	}
 
 done:
-	mutex_unlock(&xdev->lock);
+	mutex_unlock(&pipe->lock);
+	return ret;
+}
+
+static int xvip_pipeline_validate(struct xvip_pipeline *pipe,
+				  struct xvip_dma *start)
+{
+	struct media_entity_graph graph;
+	struct media_entity *entity = &start->video.entity;
+	struct media_device *mdev = entity->parent;
+	unsigned int num_inputs = 0;
+	unsigned int num_outputs = 0;
+
+	mutex_lock(&mdev->graph_mutex);
+
+	/* Walk the graph to locate the video nodes. */
+	media_entity_graph_walk_start(&graph, entity);
+
+	while ((entity = media_entity_graph_walk_next(&graph))) {
+		struct xvip_dma *dma;
+
+		if (entity->type != MEDIA_ENT_T_DEVNODE_V4L)
+			continue;
+
+		dma = to_xvip_dma(media_entity_to_video_device(entity));
+
+		if (dma->pad.flags & MEDIA_PAD_FL_SINK) {
+			pipe->output = dma;
+			num_outputs++;
+		} else {
+			num_inputs++;
+		}
+	}
+
+	mutex_unlock(&mdev->graph_mutex);
+
+	/* We need exactly one output and zero or one input. */
+	if (num_outputs != 1 || num_inputs > 1)
+		return -EPIPE;
+
+	pipe->num_dmas = num_inputs + num_outputs;
+
+	return 0;
+}
+
+static void __xvip_pipeline_cleanup(struct xvip_pipeline *pipe)
+{
+	pipe->num_dmas = 0;
+	pipe->output = NULL;
+}
+
+/**
+ * xvip_pipeline_cleanup - Cleanup the pipeline after streaming
+ * @pipe: the pipeline
+ *
+ * Decrease the pipeline use count and clean it up if we were the last user.
+ */
+static void xvip_pipeline_cleanup(struct xvip_pipeline *pipe)
+{
+	mutex_lock(&pipe->lock);
+
+	/* If we're the last user clean up the pipeline. */
+	if (--pipe->use_count == 0)
+		__xvip_pipeline_cleanup(pipe);
+
+	mutex_unlock(&pipe->lock);
+}
+
+/**
+ * xvip_pipeline_prepare - Prepare the pipeline for streaming
+ * @pipe: the pipeline
+ * @dma: DMA engine at one end of the pipeline
+ *
+ * Validate the pipeline if no user exists yet, otherwise just increase the use
+ * count.
+ *
+ * Return: 0 if successful or -EPIPE if the pipeline is not valid.
+ */
+static int xvip_pipeline_prepare(struct xvip_pipeline *pipe,
+				 struct xvip_dma *dma)
+{
+	int ret;
+
+	mutex_lock(&pipe->lock);
+
+	/* If we're the first user validate and initialize the pipeline. */
+	if (pipe->use_count == 0) {
+		ret = xvip_pipeline_validate(pipe, dma);
+		if (ret < 0) {
+			__xvip_pipeline_cleanup(pipe);
+			goto done;
+		}
+	}
+
+	pipe->use_count++;
+	ret = 0;
+
+done:
+	mutex_unlock(&pipe->lock);
 	return ret;
 }
 
@@ -315,13 +413,22 @@ static void xvip_dma_wait_finish(struct vb2_queue *vq)
 static int xvip_dma_start_streaming(struct vb2_queue *vq, unsigned int count)
 {
 	struct xvip_dma *dma = vb2_get_drv_priv(vq);
+	struct xvip_pipeline *pipe;
 	int ret;
 
 	dma->sequence = 0;
 
-	/* Mark the pipeline as streaming. */
-	ret = media_entity_pipeline_start(&dma->video.entity,
-					  &dma->xdev->pipe);
+	/*
+	 * Start streaming on the pipeline. No link touching an entity in the
+	 * pipeline can be activated or deactivated once streaming is started.
+	 *
+	 * Use the pipeline object embedded in the first DMA object that starts
+	 * streaming.
+	 */
+	pipe = dma->video.entity.pipe
+	     ? to_xvip_pipeline(&dma->video.entity) : &dma->pipe;
+
+	ret = media_entity_pipeline_start(&dma->video.entity, &pipe->pipe);
 	if (ret < 0)
 		return ret;
 
@@ -329,10 +436,12 @@ static int xvip_dma_start_streaming(struct vb2_queue *vq, unsigned int count)
 	 * connected subdev.
 	 */
 	ret = xvip_dma_verify_format(dma);
-	if (ret < 0) {
-		media_entity_pipeline_stop(&dma->video.entity);
-		return ret;
-	}
+	if (ret < 0)
+		goto error;
+
+	ret = xvip_pipeline_prepare(pipe, dma);
+	if (ret < 0)
+		goto error;
 
 	/* Start the DMA engine. This must be done before starting the blocks
 	 * in the pipeline to avoid DMA synchronization issues.
@@ -340,18 +449,23 @@ static int xvip_dma_start_streaming(struct vb2_queue *vq, unsigned int count)
 	dma_async_issue_pending(dma->dma);
 
 	/* Start the pipeline. */
-	xvip_pipeline_set_stream(dma->xdev, true);
+	xvip_pipeline_set_stream(pipe, true);
 
 	return 0;
+
+error:
+	media_entity_pipeline_stop(&dma->video.entity);
+	return ret;
 }
 
 static int xvip_dma_stop_streaming(struct vb2_queue *vq)
 {
 	struct xvip_dma *dma = vb2_get_drv_priv(vq);
+	struct xvip_pipeline *pipe = to_xvip_pipeline(&dma->video.entity);
 	struct xilinx_vdma_config config;
 
 	/* Stop the pipeline. */
-	xvip_pipeline_set_stream(dma->xdev, false);
+	xvip_pipeline_set_stream(pipe, false);
 
 	/* Stop and reset the DMA engine. */
 	dmaengine_device_control(dma->dma, DMA_TERMINATE_ALL, 0);
@@ -361,7 +475,8 @@ static int xvip_dma_stop_streaming(struct vb2_queue *vq)
 	dmaengine_device_control(dma->dma, DMA_SLAVE_CONFIG,
 				 (unsigned long)&config);
 
-	/* Mark the pipeline as being stopped. */
+	/* Cleanup the pipeline and mark it as being stopped. */
+	xvip_pipeline_cleanup(pipe);
 	media_entity_pipeline_stop(&dma->video.entity);
 
 	return 0;
@@ -791,6 +906,7 @@ int xvip_dma_init(struct xvip_composite_device *xdev, struct xvip_dma *dma,
 
 	dma->xdev = xdev;
 	mutex_init(&dma->lock);
+	mutex_init(&dma->pipe.lock);
 
 	dma->fmtinfo = xvip_get_format_by_fourcc(XVIP_DMA_DEF_FORMAT);
 	dma->format.pixelformat = dma->fmtinfo->fourcc;
@@ -879,4 +995,5 @@ void xvip_dma_cleanup(struct xvip_dma *dma)
 	media_entity_cleanup(&dma->video.entity);
 
 	mutex_destroy(&dma->lock);
+	mutex_destroy(&dma->pipe.lock);
 }
diff --git a/drivers/media/platform/xilinx/xilinx-dma.h b/drivers/media/platform/xilinx/xilinx-dma.h
index 45aeab66..911132c 100644
--- a/drivers/media/platform/xilinx/xilinx-dma.h
+++ b/drivers/media/platform/xilinx/xilinx-dma.h
@@ -25,10 +25,36 @@ struct xvip_composite_device;
 struct xvip_video_format;
 
 /**
+ * struct xvip_pipeline - Xilinx Video IP pipeline structure
+ * @pipe: media pipeline
+ * @lock: protects the pipeline @stream_count
+ * @use_count: number of DMA engines using the pipeline
+ * @stream_count: number of DMA engines currently streaming
+ * @num_dmas: number of DMA engines in the pipeline
+ * @output: DMA engine at the output of the pipeline
+ */
+struct xvip_pipeline {
+	struct media_pipeline pipe;
+
+	struct mutex lock;
+	unsigned int use_count;
+	unsigned int stream_count;
+
+	unsigned int num_dmas;
+	struct xvip_dma *output;
+};
+
+static inline struct xvip_pipeline *to_xvip_pipeline(struct media_entity *e)
+{
+	return container_of(e->pipe, struct xvip_pipeline, pipe);
+}
+
+/**
  * struct xvip_dma - Video DMA channel
  * @video: V4L2 video device associated with the DMA channel
  * @pad: media pad for the video device entity
  * @xdev: composite device the DMA channel belongs to
+ * @pipe: pipeline belonging to the DMA channel
  * @lock: protects the @format, @fmtinfo and @queue fields
  * @format: active V4L2 pixel format
  * @fmtinfo: format information corresponding to the active @format
@@ -43,6 +69,7 @@ struct xvip_dma {
 	struct media_pad pad;
 
 	struct xvip_composite_device *xdev;
+	struct xvip_pipeline pipe;
 
 	struct mutex lock;
 	struct v4l2_pix_format format;
diff --git a/drivers/media/platform/xilinx/xilinx-vipp.c b/drivers/media/platform/xilinx/xilinx-vipp.c
index b6c6900..1816e94 100644
--- a/drivers/media/platform/xilinx/xilinx-vipp.c
+++ b/drivers/media/platform/xilinx/xilinx-vipp.c
@@ -24,6 +24,9 @@
 #include "xilinx-dma.h"
 #include "xilinx-vipp.h"
 
+#define XVIPP_DMA_S2MM				0
+#define XVIPP_DMA_MM2S				1
+
 /**
  * struct xvip_graph_entity - Entity in the video graph
  * @list: list entry in a graph entities list
@@ -301,7 +304,6 @@ xvip_graph_dma_init_one(struct xvip_composite_device *xdev,
 	entity->entity = &dma->video.entity;
 
 	list_add_tail(&entity->list, &xdev->entities);
-	xdev->num_dmas++;
 
 	return 0;
 }
@@ -473,7 +475,6 @@ static int xvip_composite_probe(struct platform_device *pdev)
 
 	xdev->dev = &pdev->dev;
 	INIT_LIST_HEAD(&xdev->entities);
-	mutex_init(&xdev->lock);
 
 	ret = xvip_composite_v4l2_init(xdev);
 	if (ret < 0)
@@ -500,7 +501,6 @@ static int xvip_composite_remove(struct platform_device *pdev)
 
 	xvip_graph_cleanup(xdev);
 	xvip_composite_v4l2_cleanup(xdev);
-	mutex_destroy(&xdev->lock);
 
 	return 0;
 }
diff --git a/drivers/media/platform/xilinx/xilinx-vipp.h b/drivers/media/platform/xilinx/xilinx-vipp.h
index 07ca38f..e6a947c 100644
--- a/drivers/media/platform/xilinx/xilinx-vipp.h
+++ b/drivers/media/platform/xilinx/xilinx-vipp.h
@@ -22,28 +22,20 @@
 
 #include "xilinx-dma.h"
 
-#define XVIPP_DMA_S2MM				0
-#define XVIPP_DMA_MM2S				1
-
 /**
  * struct xvip_composite_device - Xilinx Video IP device structure
  * @v4l2_dev: V4L2 device
  * @media_dev: media device
- * @pipe: media pipeline
  * @dev: (OF) device
  * @notifier: V4L2 asynchronous subdevs notifier
  * @entities: entities in the graph as a list of xvip_graph_entity
  * @num_subdevs: number of subdevs in the pipeline
  * @dma: DMA channels at the pipeline output and input
- * @num_dmas: number of DMA engines in the pipeline
- * @lock: protects the pipeline @stream_count
- * @stream_count: number of DMA engines currently streaming
  * @ctrl_handler: control handler
  */
 struct xvip_composite_device {
 	struct v4l2_device v4l2_dev;
 	struct media_device media_dev;
-	struct media_pipeline pipe;
 	struct device *dev;
 
 	struct v4l2_async_notifier notifier;
@@ -51,10 +43,6 @@ struct xvip_composite_device {
 	unsigned int num_subdevs;
 
 	struct xvip_dma dma[2];
-	unsigned int num_dmas;
-
-	struct mutex lock;
-	unsigned int stream_count;
 
 	struct v4l2_ctrl_handler ctrl_handler;
 };
-- 
2.9.3

