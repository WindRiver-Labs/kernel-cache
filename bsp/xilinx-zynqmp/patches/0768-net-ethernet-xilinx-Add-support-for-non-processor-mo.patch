From f252ecfabaf43405379a923b3d9c4b1ff0a29144 Mon Sep 17 00:00:00 2001
From: Kedareswara rao Appana <appana.durga.rao@xilinx.com>
Date: Thu, 10 Sep 2015 22:24:55 +0530
Subject: [PATCH 768/827] net: ethernet: xilinx: Add support for non-processor mode

This patch comes from:
  https://github.com/Xilinx/linux-xlnx.git

This patch adds support for non-processor mode configuration.

Signed-off-by: Kedareswara rao Appana <appanad@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
(cherry picked from commit efba4746b7bb29e2cbca4e6a379f57bde9db5587)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/xilinx/xilinx_axienet.h      |  2 ++
 drivers/net/ethernet/xilinx/xilinx_axienet_main.c | 13 ++++++++-----
 2 files changed, 10 insertions(+), 5 deletions(-)

diff --git a/drivers/net/ethernet/xilinx/xilinx_axienet.h b/drivers/net/ethernet/xilinx/xilinx_axienet.h
index 6d7493f..97485fd 100644
--- a/drivers/net/ethernet/xilinx/xilinx_axienet.h
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet.h
@@ -426,6 +426,7 @@ struct axidma_bd {
  * @is_10Gmac:	  Check for 10g mac.
  * @phy_interface: Phy interface type.
  * @phy_flags:	Phy interface flags.
+ * @eth_hasnobuf: Ethernet is configured in Non buf mode.
  */
 struct axienet_local {
 	struct net_device *ndev;
@@ -476,6 +477,7 @@ struct axienet_local {
 	u32 is_10Gmac;
 	u32 phy_interface;
 	u32 phy_flags;
+	bool eth_hasnobuf;
 };
 
 /**
diff --git a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
index f223e4e..292570f 100644
--- a/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
+++ b/drivers/net/ethernet/xilinx/xilinx_axienet_main.c
@@ -308,7 +308,7 @@ static void axienet_set_mac_address(struct net_device *ndev, void *address)
 	if (!is_valid_ether_addr(ndev->dev_addr))
 		eth_random_addr(ndev->dev_addr);
 
-	if (lp->is_10Gmac)
+	if (lp->is_10Gmac || lp->eth_hasnobuf)
 		return;
 
 	/* Set up unicast MAC address filter set its mac address */
@@ -360,7 +360,7 @@ static void axienet_set_multicast_list(struct net_device *ndev)
 	u32 reg, af0reg, af1reg;
 	struct axienet_local *lp = netdev_priv(ndev);
 
-	if (lp->is_10Gmac)
+	if (lp->is_10Gmac || lp->eth_hasnobuf)
 		return;
 
 	if (ndev->flags & (IFF_ALLMULTI | IFF_PROMISC) ||
@@ -507,7 +507,7 @@ static void axienet_device_reset(struct net_device *ndev)
 	axienet_status &= ~XAE_RCW1_RX_MASK;
 	axienet_iow(lp, XAE_RCW1_OFFSET, axienet_status);
 
-	if (!lp->is_10Gmac) {
+	if (!lp->is_10Gmac || lp->eth_hasnobuf) {
 		axienet_status = axienet_ior(lp, XAE_IP_OFFSET);
 		if (axienet_status & XAE_INT_RXRJECT_MASK)
 			axienet_iow(lp, XAE_IS_OFFSET, XAE_INT_RXRJECT_MASK);
@@ -778,7 +778,7 @@ static int axienet_recv(struct net_device *ndev, int budget)
 		tail_p = lp->rx_bd_p + sizeof(*lp->rx_bd_v) * lp->rx_bd_ci;
 		skb = (struct sk_buff *) (cur_p->sw_id_offset);
 
-		if (lp->is_10Gmac)
+		if (lp->is_10Gmac || lp->eth_hasnobuf)
 			length = cur_p->status & XAXIDMA_BD_STS_ACTUAL_LEN_MASK;
 		else
 			length = cur_p->app4 & 0x0000FFFF;
@@ -1590,7 +1590,7 @@ static void axienet_dma_err_handler(unsigned long data)
 	axienet_status &= ~XAE_RCW1_RX_MASK;
 	axienet_iow(lp, XAE_RCW1_OFFSET, axienet_status);
 
-	if (!lp->is_10Gmac) {
+	if (!lp->is_10Gmac || !lp->eth_hasnobuf) {
 		axienet_status = axienet_ior(lp, XAE_IP_OFFSET);
 		if (axienet_status & XAE_INT_RXRJECT_MASK)
 			axienet_iow(lp, XAE_IS_OFFSET, XAE_INT_RXRJECT_MASK);
@@ -1709,6 +1709,9 @@ static int axienet_probe(struct platform_device *pdev)
 	if (of_device_is_compatible(pdev->dev.of_node, "xlnx,ten-gig-eth-mac"))
 		lp->is_10Gmac = 1;
 
+	lp->eth_hasnobuf = of_property_read_bool(pdev->dev.of_node,
+						 "xlnx,eth-hasnobuf");
+
 	/* Find the DMA node, map the DMA registers, and decode the DMA IRQs */
 	np = of_parse_phandle(pdev->dev.of_node, "axistream-connected", 0);
 	if (IS_ERR(np)) {
-- 
2.9.3

