From 38fe8f77cece0ce0de8f180918d35ce13cf95d3f Mon Sep 17 00:00:00 2001
From: Hyun Kwon <hyun.kwon@xilinx.com>
Date: Tue, 18 Mar 2014 09:18:16 -0700
Subject: [PATCH 460/827] media: xilinx: vip: Add yuv444 and bayer formats

This patch comes from:
  https://github.com/Xilinx/linux-xlnx.git

Add more video formats: yuv444 and bayer(rggb, grbg, gbrg, bggr).

Signed-off-by: Hyun Kwon <hyunk@xilinx.com>
Acked-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
(cherry picked from commit aae4345e34167860ab4579642fa5ef340fa72d9d)

Conflicts:
	Documentation/devicetree/bindings/media/xilinx/video.txt
	drivers/media/platform/xilinx/xilinx-vip.c
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/media/platform/xilinx/Kconfig           |  13 +-
 drivers/media/platform/xilinx/Makefile          |   6 +-
 drivers/media/platform/xilinx/xilinx-dma.c      | 707 ++++++++++----------
 drivers/media/platform/xilinx/xilinx-dma.h      |  60 +-
 drivers/media/platform/xilinx/xilinx-remapper.c | 533 +++++++++++++++
 drivers/media/platform/xilinx/xilinx-tpg.c      | 824 ++++--------------------
 drivers/media/platform/xilinx/xilinx-vip.c      | 263 +-------
 drivers/media/platform/xilinx/xilinx-vip.h      | 174 +----
 drivers/media/platform/xilinx/xilinx-vipp.c     | 579 ++++++++---------
 drivers/media/platform/xilinx/xilinx-vipp.h     |  34 +-
 10 files changed, 1345 insertions(+), 1848 deletions(-)
 create mode 100644 drivers/media/platform/xilinx/xilinx-remapper.c

diff --git a/drivers/media/platform/xilinx/Kconfig b/drivers/media/platform/xilinx/Kconfig
index d7324c7..b30322e 100644
--- a/drivers/media/platform/xilinx/Kconfig
+++ b/drivers/media/platform/xilinx/Kconfig
@@ -7,17 +7,16 @@ config VIDEO_XILINX
 
 if VIDEO_XILINX
 
-config VIDEO_XILINX_TPG
-	tristate "Xilinx Video Test Pattern Generator"
+config VIDEO_XILINX_REMAPPER
+	tristate "Xilinx Video Remapper"
 	depends on VIDEO_XILINX
-	select VIDEO_XILINX_VTC
 	---help---
-	   Driver for the Xilinx Video Test Pattern Generator
+	   Driver for the Xilinx Video Remapper
 
-config VIDEO_XILINX_VTC
-	tristate "Xilinx Video Timing Controller"
+config VIDEO_XILINX_TPG
+	tristate "Xilinx Video Test Pattern Generator"
 	depends on VIDEO_XILINX
 	---help---
-	   Driver for the Xilinx Video Timing Controller
+	   Driver for the Xilinx Video Test Pattern Generator
 
 endif #VIDEO_XILINX
diff --git a/drivers/media/platform/xilinx/Makefile b/drivers/media/platform/xilinx/Makefile
index e8a0f2a..33f22a3 100644
--- a/drivers/media/platform/xilinx/Makefile
+++ b/drivers/media/platform/xilinx/Makefile
@@ -1,5 +1,5 @@
-xilinx-video-objs += xilinx-dma.o xilinx-vip.o xilinx-vipp.o
+xilinx-axi-video-objs += xilinx-dma.o xilinx-vip.o xilinx-vipp.o
 
-obj-$(CONFIG_VIDEO_XILINX) += xilinx-video.o
+obj-$(CONFIG_VIDEO_XILINX) += xilinx-axi-video.o
+obj-$(CONFIG_VIDEO_XILINX_REMAPPER) += xilinx-remapper.o
 obj-$(CONFIG_VIDEO_XILINX_TPG) += xilinx-tpg.o
-obj-$(CONFIG_VIDEO_XILINX_VTC) += xilinx-vtc.o
diff --git a/drivers/media/platform/xilinx/xilinx-dma.c b/drivers/media/platform/xilinx/xilinx-dma.c
index efde88a..e9d1a0b 100644
--- a/drivers/media/platform/xilinx/xilinx-dma.c
+++ b/drivers/media/platform/xilinx/xilinx-dma.c
@@ -1,18 +1,17 @@
 /*
  * Xilinx Video DMA
  *
- * Copyright (C) 2013-2015 Ideas on Board
- * Copyright (C) 2013-2015 Xilinx, Inc.
+ * Copyright (C) 2013 Ideas on Board SPRL
  *
- * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
- *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
 
-#include <linux/dma/xilinx_dma.h>
+#include <linux/amba/xilinx_dma.h>
+#include <linux/dmaengine.h>
 #include <linux/lcm.h>
 #include <linux/list.h>
 #include <linux/module.h>
@@ -67,7 +66,7 @@ static int xvip_dma_verify_format(struct xvip_dma *dma)
 
 	subdev = xvip_dma_remote_subdev(&dma->pad, &fmt.pad);
 	if (subdev == NULL)
-		return -EPIPE;
+		return -EINVAL;
 
 	fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
 	ret = v4l2_subdev_call(subdev, pad, get_fmt, NULL, &fmt);
@@ -76,218 +75,32 @@ static int xvip_dma_verify_format(struct xvip_dma *dma)
 
 	if (dma->fmtinfo->code != fmt.format.code ||
 	    dma->format.height != fmt.format.height ||
-	    dma->format.width != fmt.format.width ||
-	    dma->format.colorspace != fmt.format.colorspace)
+	    dma->format.width != fmt.format.width)
 		return -EINVAL;
 
 	return 0;
 }
 
 /* -----------------------------------------------------------------------------
- * Pipeline Stream Management
- */
-
-/**
- * xvip_pipeline_start_stop - Start ot stop streaming on a pipeline
- * @pipe: The pipeline
- * @start: Start (when true) or stop (when false) the pipeline
- *
- * Walk the entities chain starting at the pipeline output video node and start
- * or stop all of them.
- *
- * Return: 0 if successful, or the return value of the failed video::s_stream
- * operation otherwise.
- */
-static int xvip_pipeline_start_stop(struct xvip_pipeline *pipe, bool start)
-{
-	struct xvip_dma *dma = pipe->output;
-	struct media_entity *entity;
-	struct media_pad *pad;
-	struct v4l2_subdev *subdev;
-	int ret;
-
-	entity = &dma->video.entity;
-	while (1) {
-		pad = &entity->pads[0];
-		if (!(pad->flags & MEDIA_PAD_FL_SINK))
-			break;
-
-		pad = media_entity_remote_pad(pad);
-		if (pad == NULL ||
-		    media_entity_type(pad->entity) != MEDIA_ENT_T_V4L2_SUBDEV)
-			break;
-
-		entity = pad->entity;
-		subdev = media_entity_to_v4l2_subdev(entity);
-
-		ret = v4l2_subdev_call(subdev, video, s_stream, start);
-		if (start && ret < 0 && ret != -ENOIOCTLCMD)
-			return ret;
-	}
-
-	return 0;
-}
-
-/**
- * xvip_pipeline_set_stream - Enable/disable streaming on a pipeline
- * @pipe: The pipeline
- * @on: Turn the stream on when true or off when false
- *
- * The pipeline is shared between all DMA engines connect at its input and
- * output. While the stream state of DMA engines can be controlled
- * independently, pipelines have a shared stream state that enable or disable
- * all entities in the pipeline. For this reason the pipeline uses a streaming
- * counter that tracks the number of DMA engines that have requested the stream
- * to be enabled.
- *
- * When called with the @on argument set to true, this function will increment
- * the pipeline streaming count. If the streaming count reaches the number of
- * DMA engines in the pipeline it will enable all entities that belong to the
- * pipeline.
- *
- * Similarly, when called with the @on argument set to false, this function will
- * decrement the pipeline streaming count and disable all entities in the
- * pipeline when the streaming count reaches zero.
- *
- * Return: 0 if successful, or the return value of the failed video::s_stream
- * operation otherwise. Stopping the pipeline never fails. The pipeline state is
- * not updated when the operation fails.
- */
-static int xvip_pipeline_set_stream(struct xvip_pipeline *pipe, bool on)
-{
-	int ret = 0;
-
-	mutex_lock(&pipe->lock);
-
-	if (on) {
-		if (pipe->stream_count == pipe->num_dmas - 1) {
-			ret = xvip_pipeline_start_stop(pipe, true);
-			if (ret < 0)
-				goto done;
-		}
-		pipe->stream_count++;
-	} else {
-		if (--pipe->stream_count == 0)
-			xvip_pipeline_start_stop(pipe, false);
-	}
-
-done:
-	mutex_unlock(&pipe->lock);
-	return ret;
-}
-
-static int xvip_pipeline_validate(struct xvip_pipeline *pipe,
-				  struct xvip_dma *start)
-{
-	struct media_entity_graph graph;
-	struct media_entity *entity = &start->video.entity;
-	struct media_device *mdev = entity->parent;
-	unsigned int num_inputs = 0;
-	unsigned int num_outputs = 0;
-
-	mutex_lock(&mdev->graph_mutex);
-
-	/* Walk the graph to locate the video nodes. */
-	media_entity_graph_walk_start(&graph, entity);
-
-	while ((entity = media_entity_graph_walk_next(&graph))) {
-		struct xvip_dma *dma;
-
-		if (entity->type != MEDIA_ENT_T_DEVNODE_V4L)
-			continue;
-
-		dma = to_xvip_dma(media_entity_to_video_device(entity));
-
-		if (dma->pad.flags & MEDIA_PAD_FL_SINK) {
-			pipe->output = dma;
-			num_outputs++;
-		} else {
-			num_inputs++;
-		}
-	}
-
-	mutex_unlock(&mdev->graph_mutex);
-
-	/* We need exactly one output and zero or one input. */
-	if (num_outputs != 1 || num_inputs > 1)
-		return -EPIPE;
-
-	pipe->num_dmas = num_inputs + num_outputs;
-
-	return 0;
-}
-
-static void __xvip_pipeline_cleanup(struct xvip_pipeline *pipe)
-{
-	pipe->num_dmas = 0;
-	pipe->output = NULL;
-}
-
-/**
- * xvip_pipeline_cleanup - Cleanup the pipeline after streaming
- * @pipe: the pipeline
- *
- * Decrease the pipeline use count and clean it up if we were the last user.
- */
-static void xvip_pipeline_cleanup(struct xvip_pipeline *pipe)
-{
-	mutex_lock(&pipe->lock);
-
-	/* If we're the last user clean up the pipeline. */
-	if (--pipe->use_count == 0)
-		__xvip_pipeline_cleanup(pipe);
-
-	mutex_unlock(&pipe->lock);
-}
-
-/**
- * xvip_pipeline_prepare - Prepare the pipeline for streaming
- * @pipe: the pipeline
- * @dma: DMA engine at one end of the pipeline
- *
- * Validate the pipeline if no user exists yet, otherwise just increase the use
- * count.
- *
- * Return: 0 if successful or -EPIPE if the pipeline is not valid.
- */
-static int xvip_pipeline_prepare(struct xvip_pipeline *pipe,
-				 struct xvip_dma *dma)
-{
-	int ret;
-
-	mutex_lock(&pipe->lock);
-
-	/* If we're the first user validate and initialize the pipeline. */
-	if (pipe->use_count == 0) {
-		ret = xvip_pipeline_validate(pipe, dma);
-		if (ret < 0) {
-			__xvip_pipeline_cleanup(pipe);
-			goto done;
-		}
-	}
-
-	pipe->use_count++;
-	ret = 0;
-
-done:
-	mutex_unlock(&pipe->lock);
-	return ret;
-}
-
-/* -----------------------------------------------------------------------------
  * videobuf2 queue operations
  */
 
 /**
  * struct xvip_dma_buffer - Video DMA buffer
  * @buf: vb2 buffer base object
- * @queue: buffer list entry in the DMA engine queued buffers list
  * @dma: DMA channel that uses the buffer
+ * @addr: DMA bus address for the buffer memory
+ * @length: total length of the buffer in bytes
+ * @bytesused: number of bytes used in the buffer
  */
 struct xvip_dma_buffer {
 	struct vb2_buffer buf;
-	struct list_head queue;
+
 	struct xvip_dma *dma;
+
+	dma_addr_t addr;
+	unsigned int length;
+	unsigned int bytesused;
 };
 
 #define to_xvip_dma_buffer(vb)	container_of(vb, struct xvip_dma_buffer, buf)
@@ -297,14 +110,9 @@ static void xvip_dma_complete(void *param)
 	struct xvip_dma_buffer *buf = param;
 	struct xvip_dma *dma = buf->dma;
 
-	spin_lock(&dma->queued_lock);
-	list_del(&buf->queue);
-	spin_unlock(&dma->queued_lock);
-
-	buf->buf.v4l2_buf.field = V4L2_FIELD_NONE;
 	buf->buf.v4l2_buf.sequence = dma->sequence++;
 	v4l2_get_timestamp(&buf->buf.v4l2_buf.timestamp);
-	vb2_set_plane_payload(&buf->buf, 0, dma->format.sizeimage);
+	vb2_set_plane_payload(&buf->buf, 0, buf->length);
 	vb2_buffer_done(&buf->buf, VB2_BUF_STATE_DONE);
 }
 
@@ -315,13 +123,9 @@ xvip_dma_queue_setup(struct vb2_queue *vq, const struct v4l2_format *fmt,
 {
 	struct xvip_dma *dma = vb2_get_drv_priv(vq);
 
-	/* Make sure the image size is large enough. */
-	if (fmt && fmt->fmt.pix.sizeimage < dma->format.sizeimage)
-		return -EINVAL;
-
 	*nplanes = 1;
 
-	sizes[0] = fmt ? fmt->fmt.pix.sizeimage : dma->format.sizeimage;
+	sizes[0] = dma->format.sizeimage;
 	alloc_ctxs[0] = dma->alloc_ctx;
 
 	return 0;
@@ -333,6 +137,9 @@ static int xvip_dma_buffer_prepare(struct vb2_buffer *vb)
 	struct xvip_dma_buffer *buf = to_xvip_dma_buffer(vb);
 
 	buf->dma = dma;
+	buf->addr = vb2_dma_contig_plane_dma_addr(vb, 0);
+	buf->length = vb2_plane_size(vb, 0);
+	buf->bytesused = 0;
 
 	return 0;
 }
@@ -342,80 +149,63 @@ static void xvip_dma_buffer_queue(struct vb2_buffer *vb)
 	struct xvip_dma *dma = vb2_get_drv_priv(vb->vb2_queue);
 	struct xvip_dma_buffer *buf = to_xvip_dma_buffer(vb);
 	struct dma_async_tx_descriptor *desc;
-	dma_addr_t addr = vb2_dma_contig_plane_dma_addr(vb, 0);
+	enum dma_transfer_direction dir;
 	u32 flags;
 
 	if (dma->queue.type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
 		flags = DMA_PREP_INTERRUPT | DMA_CTRL_ACK;
-		dma->xt.dir = DMA_DEV_TO_MEM;
-		dma->xt.src_sgl = false;
-		dma->xt.dst_sgl = true;
-		dma->xt.dst_start = addr;
+		dir = DMA_DEV_TO_MEM;
 	} else {
 		flags = DMA_PREP_INTERRUPT | DMA_CTRL_ACK;
-		dma->xt.dir = DMA_MEM_TO_DEV;
-		dma->xt.src_sgl = true;
-		dma->xt.dst_sgl = false;
-		dma->xt.src_start = addr;
+		dir = DMA_MEM_TO_DEV;
 	}
 
-	dma->xt.frame_size = 1;
-	dma->sgl[0].size = dma->format.width * dma->fmtinfo->bpp;
-	dma->sgl[0].icg = dma->format.bytesperline - dma->sgl[0].size;
-	dma->xt.numf = dma->format.height;
-
-	desc = dmaengine_prep_interleaved_dma(dma->dma, &dma->xt, flags);
-	if (!desc) {
-		dev_err(dma->xdev->dev, "Failed to prepare DMA transfer\n");
-		vb2_buffer_done(&buf->buf, VB2_BUF_STATE_ERROR);
-		return;
-	}
+	desc = dmaengine_prep_slave_single(dma->dma, buf->addr, buf->length,
+					   dir, flags);
 	desc->callback = xvip_dma_complete;
 	desc->callback_param = buf;
 
-	spin_lock_irq(&dma->queued_lock);
-	list_add_tail(&buf->queue, &dma->queued_bufs);
-	spin_unlock_irq(&dma->queued_lock);
-
 	dmaengine_submit(desc);
 
 	if (vb2_is_streaming(&dma->queue))
 		dma_async_issue_pending(dma->dma);
 }
 
+static void xvip_dma_wait_prepare(struct vb2_queue *vq)
+{
+	struct xvip_dma *dma = vb2_get_drv_priv(vq);
+
+	mutex_unlock(&dma->lock);
+}
+
+static void xvip_dma_wait_finish(struct vb2_queue *vq)
+{
+	struct xvip_dma *dma = vb2_get_drv_priv(vq);
+
+	mutex_lock(&dma->lock);
+}
+
 static int xvip_dma_start_streaming(struct vb2_queue *vq, unsigned int count)
 {
 	struct xvip_dma *dma = vb2_get_drv_priv(vq);
-	struct xvip_dma_buffer *buf, *nbuf;
-	struct xvip_pipeline *pipe;
 	int ret;
 
 	dma->sequence = 0;
 
-	/*
-	 * Start streaming on the pipeline. No link touching an entity in the
-	 * pipeline can be activated or deactivated once streaming is started.
-	 *
-	 * Use the pipeline object embedded in the first DMA object that starts
-	 * streaming.
-	 */
-	pipe = dma->video.entity.pipe
-	     ? to_xvip_pipeline(&dma->video.entity) : &dma->pipe;
-
-	ret = media_entity_pipeline_start(&dma->video.entity, &pipe->pipe);
+	/* Mark the pipeline as streaming. */
+	ret = media_entity_pipeline_start(&dma->video.entity,
+					  &dma->xvipp->pipe);
 	if (ret < 0)
-		goto error;
+		return ret;
 
 	/* Verify that the configured format matches the output of the
 	 * connected subdev.
 	 */
 	ret = xvip_dma_verify_format(dma);
-	if (ret < 0)
-		goto error_stop;
-
-	ret = xvip_pipeline_prepare(pipe, dma);
-	if (ret < 0)
-		goto error_stop;
+	if (ret < 0) {
+		media_entity_pipeline_stop(&dma->video.entity);
+		return ret;
+	}
 
 	/* Start the DMA engine. This must be done before starting the blocks
 	 * in the pipeline to avoid DMA synchronization issues.
@@ -423,56 +213,39 @@ static int xvip_dma_start_streaming(struct vb2_queue *vq, unsigned int count)
 	dma_async_issue_pending(dma->dma);
 
 	/* Start the pipeline. */
-	xvip_pipeline_set_stream(pipe, true);
+	xvip_pipeline_set_stream(dma->xvipp, true);
 
 	return 0;
-
-error_stop:
-	media_entity_pipeline_stop(&dma->video.entity);
-
-error:
-	/* Give back all queued buffers to videobuf2. */
-	spin_lock_irq(&dma->queued_lock);
-	list_for_each_entry_safe(buf, nbuf, &dma->queued_bufs, queue) {
-		vb2_buffer_done(&buf->buf, VB2_BUF_STATE_QUEUED);
-		list_del(&buf->queue);
-	}
-	spin_unlock_irq(&dma->queued_lock);
-
-	return ret;
 }
 
-static void xvip_dma_stop_streaming(struct vb2_queue *vq)
+static int xvip_dma_stop_streaming(struct vb2_queue *vq)
 {
 	struct xvip_dma *dma = vb2_get_drv_priv(vq);
-	struct xvip_pipeline *pipe = to_xvip_pipeline(&dma->video.entity);
-	struct xvip_dma_buffer *buf, *nbuf;
+	struct xilinx_vdma_config config;
 
 	/* Stop the pipeline. */
-	xvip_pipeline_set_stream(pipe, false);
+	xvip_pipeline_set_stream(dma->xvipp, false);
 
 	/* Stop and reset the DMA engine. */
-	dmaengine_terminate_all(dma->dma);
+	dmaengine_device_control(dma->dma, DMA_TERMINATE_ALL, 0);
+
+	config.reset = 1;
 
-	/* Cleanup the pipeline and mark it as being stopped. */
-	xvip_pipeline_cleanup(pipe);
+	dmaengine_device_control(dma->dma, DMA_SLAVE_CONFIG,
+				 (unsigned long)&config);
+
+	/* Mark the pipeline as being stopped. */
 	media_entity_pipeline_stop(&dma->video.entity);
 
-	/* Give back all queued buffers to videobuf2. */
-	spin_lock_irq(&dma->queued_lock);
-	list_for_each_entry_safe(buf, nbuf, &dma->queued_bufs, queue) {
-		vb2_buffer_done(&buf->buf, VB2_BUF_STATE_ERROR);
-		list_del(&buf->queue);
-	}
-	spin_unlock_irq(&dma->queued_lock);
+	return 0;
 }
 
 static struct vb2_ops xvip_dma_queue_qops = {
 	.queue_setup = xvip_dma_queue_setup,
 	.buf_prepare = xvip_dma_buffer_prepare,
 	.buf_queue = xvip_dma_buffer_queue,
-	.wait_prepare = vb2_ops_wait_prepare,
-	.wait_finish = vb2_ops_wait_finish,
+	.wait_prepare = xvip_dma_wait_prepare,
+	.wait_finish = xvip_dma_wait_finish,
 	.start_streaming = xvip_dma_start_streaming,
 	.stop_streaming = xvip_dma_stop_streaming,
 };
@@ -487,39 +260,14 @@ xvip_dma_querycap(struct file *file, void *fh, struct v4l2_capability *cap)
 	struct v4l2_fh *vfh = file->private_data;
 	struct xvip_dma *dma = to_xvip_dma(vfh->vdev);
 
-	cap->capabilities = V4L2_CAP_DEVICE_CAPS | V4L2_CAP_STREAMING
-			  | dma->xdev->v4l2_caps;
-
 	if (dma->queue.type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
-		cap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;
+		cap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING;
 	else
-		cap->device_caps = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING;
+		cap->capabilities = V4L2_CAP_VIDEO_OUTPUT | V4L2_CAP_STREAMING;
 
 	strlcpy(cap->driver, "xilinx-vipp", sizeof(cap->driver));
 	strlcpy(cap->card, dma->video.name, sizeof(cap->card));
-	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s:%u",
-		 dma->xdev->dev->of_node->name, dma->port);
-
-	return 0;
-}
-
-/* FIXME: without this callback function, some applications are not configured
- * with correct formats, and it results in frames in wrong format. Whether this
- * callback needs to be required is not clearly defined, so it should be
- * clarified through the mailing list.
- */
-static int
-xvip_dma_enum_format(struct file *file, void *fh, struct v4l2_fmtdesc *f)
-{
-	struct v4l2_fh *vfh = file->private_data;
-	struct xvip_dma *dma = to_xvip_dma(vfh->vdev);
-
-	if (f->index > 0)
-		return -EINVAL;
-
-	f->pixelformat = dma->format.pixelformat;
-	strlcpy(f->description, dma->fmtinfo->description,
-		sizeof(f->description));
+	strlcpy(cap->bus_info, "media", sizeof(cap->bus_info));
 
 	return 0;
 }
@@ -530,7 +278,9 @@ xvip_dma_get_format(struct file *file, void *fh, struct v4l2_format *format)
 	struct v4l2_fh *vfh = file->private_data;
 	struct xvip_dma *dma = to_xvip_dma(vfh->vdev);
 
+	mutex_lock(&dma->lock);
 	format->fmt.pix = dma->format;
+	mutex_unlock(&dma->lock);
 
 	return 0;
 }
@@ -552,10 +302,11 @@ __xvip_dma_try_format(struct xvip_dma *dma, struct v4l2_pix_format *pix,
 	 * requested format isn't supported.
 	 */
 	info = xvip_get_format_by_fourcc(pix->pixelformat);
-	if (IS_ERR(info))
+	if (info == NULL)
 		info = xvip_get_format_by_fourcc(XVIP_DMA_DEF_FORMAT);
 
 	pix->pixelformat = info->fourcc;
+	pix->colorspace = V4L2_COLORSPACE_SRGB;
 	pix->field = V4L2_FIELD_NONE;
 
 	/* The transfer alignment requirements are expressed in bytes. Compute
@@ -602,66 +353,291 @@ xvip_dma_set_format(struct file *file, void *fh, struct v4l2_format *format)
 	struct v4l2_fh *vfh = file->private_data;
 	struct xvip_dma *dma = to_xvip_dma(vfh->vdev);
 	const struct xvip_video_format *info;
+	struct xilinx_vdma_config config;
+	int ret;
 
 	__xvip_dma_try_format(dma, &format->fmt.pix, &info);
 
-	if (vb2_is_busy(&dma->queue))
-		return -EBUSY;
+	mutex_lock(&dma->lock);
+
+	if (vb2_is_streaming(&dma->queue)) {
+		ret = -EBUSY;
+		goto done;
+	}
 
 	dma->format = format->fmt.pix;
 	dma->fmtinfo = info;
 
-	return 0;
+	/* Configure the DMA engine. */
+	memset(&config, 0, sizeof(config));
+
+	config.park = 1;
+	config.park_frm = 0;
+	config.vsize = dma->format.height;
+	config.hsize = dma->format.width * info->bpp;
+	config.stride = dma->format.bytesperline;
+	config.ext_fsync = 2;
+	config.frm_cnt_en = 1;
+	config.coalesc = 1;
+
+	dmaengine_device_control(dma->dma, DMA_SLAVE_CONFIG,
+				 (unsigned long)&config);
+
+	ret = 0;
+
+done:
+	mutex_unlock(&dma->lock);
+	return ret;
+}
+
+static int
+xvip_dma_reqbufs(struct file *file, void *fh, struct v4l2_requestbuffers *rb)
+{
+	struct v4l2_fh *vfh = file->private_data;
+	struct xvip_dma *dma = to_xvip_dma(vfh->vdev);
+	int ret;
+
+	mutex_lock(&dma->lock);
+
+	if (dma->queue.owner && dma->queue.owner != vfh) {
+		ret = -EBUSY;
+		goto done;
+	}
+
+	ret = vb2_reqbufs(&dma->queue, rb);
+	if (ret < 0)
+		goto done;
+
+	dma->queue.owner = vfh;
+
+done:
+	mutex_unlock(&dma->lock);
+	return ret ? ret : rb->count;
+}
+
+static int
+xvip_dma_querybuf(struct file *file, void *fh, struct v4l2_buffer *buf)
+{
+	struct v4l2_fh *vfh = file->private_data;
+	struct xvip_dma *dma = to_xvip_dma(vfh->vdev);
+	int ret;
+
+	mutex_lock(&dma->lock);
+	ret = vb2_querybuf(&dma->queue, buf);
+	mutex_unlock(&dma->lock);
+
+	return ret;
+}
+
+static int
+xvip_dma_qbuf(struct file *file, void *fh, struct v4l2_buffer *buf)
+{
+	struct v4l2_fh *vfh = file->private_data;
+	struct xvip_dma *dma = to_xvip_dma(vfh->vdev);
+	int ret;
+
+	mutex_lock(&dma->lock);
+
+	if (dma->queue.owner && dma->queue.owner != vfh) {
+		ret = -EBUSY;
+		goto done;
+	}
+
+	ret = vb2_qbuf(&dma->queue, buf);
+
+done:
+	mutex_unlock(&dma->lock);
+	return ret;
+}
+
+static int
+xvip_dma_dqbuf(struct file *file, void *fh, struct v4l2_buffer *buf)
+{
+	struct v4l2_fh *vfh = file->private_data;
+	struct xvip_dma *dma = to_xvip_dma(vfh->vdev);
+	int ret;
+
+	mutex_lock(&dma->lock);
+
+	if (dma->queue.owner && dma->queue.owner != vfh) {
+		ret = -EBUSY;
+		goto done;
+	}
+
+	ret = vb2_dqbuf(&dma->queue, buf, file->f_flags & O_NONBLOCK);
+
+done:
+	mutex_unlock(&dma->lock);
+	return ret;
+}
+
+static int
+xvip_dma_expbuf(struct file *file, void *priv, struct v4l2_exportbuffer *eb)
+{
+	struct v4l2_fh *vfh = file->private_data;
+	struct xvip_dma *dma = to_xvip_dma(vfh->vdev);
+	int ret;
+
+	mutex_lock(&dma->lock);
+
+	if (dma->queue.owner && dma->queue.owner != vfh) {
+		ret = -EBUSY;
+		goto done;
+	}
+
+	ret = vb2_expbuf(&dma->queue, eb);
+
+done:
+	mutex_unlock(&dma->lock);
+	return ret;
+}
+
+static int
+xvip_dma_streamon(struct file *file, void *fh, enum v4l2_buf_type type)
+{
+	struct v4l2_fh *vfh = file->private_data;
+	struct xvip_dma *dma = to_xvip_dma(vfh->vdev);
+	int ret;
+
+	mutex_lock(&dma->lock);
+
+	if (dma->queue.owner && dma->queue.owner != vfh) {
+		ret = -EBUSY;
+		goto done;
+	}
+
+	ret = vb2_streamon(&dma->queue, type);
+
+done:
+	mutex_unlock(&dma->lock);
+	return ret;
+}
+
+static int
+xvip_dma_streamoff(struct file *file, void *fh, enum v4l2_buf_type type)
+{
+	struct v4l2_fh *vfh = file->private_data;
+	struct xvip_dma *dma = to_xvip_dma(vfh->vdev);
+	int ret;
+
+	mutex_lock(&dma->lock);
+
+	if (dma->queue.owner && dma->queue.owner != vfh) {
+		ret = -EBUSY;
+		goto done;
+	}
+
+	ret = vb2_streamoff(&dma->queue, type);
+
+done:
+	mutex_unlock(&dma->lock);
+	return ret;
 }
 
 static const struct v4l2_ioctl_ops xvip_dma_ioctl_ops = {
 	.vidioc_querycap		= xvip_dma_querycap,
-	.vidioc_enum_fmt_vid_cap	= xvip_dma_enum_format,
 	.vidioc_g_fmt_vid_cap		= xvip_dma_get_format,
 	.vidioc_g_fmt_vid_out		= xvip_dma_get_format,
 	.vidioc_s_fmt_vid_cap		= xvip_dma_set_format,
 	.vidioc_s_fmt_vid_out		= xvip_dma_set_format,
 	.vidioc_try_fmt_vid_cap		= xvip_dma_try_format,
 	.vidioc_try_fmt_vid_out		= xvip_dma_try_format,
-	.vidioc_reqbufs			= vb2_ioctl_reqbufs,
-	.vidioc_querybuf		= vb2_ioctl_querybuf,
-	.vidioc_qbuf			= vb2_ioctl_qbuf,
-	.vidioc_dqbuf			= vb2_ioctl_dqbuf,
-	.vidioc_create_bufs		= vb2_ioctl_create_bufs,
-	.vidioc_expbuf			= vb2_ioctl_expbuf,
-	.vidioc_streamon		= vb2_ioctl_streamon,
-	.vidioc_streamoff		= vb2_ioctl_streamoff,
+	.vidioc_reqbufs			= xvip_dma_reqbufs,
+	.vidioc_querybuf		= xvip_dma_querybuf,
+	.vidioc_qbuf			= xvip_dma_qbuf,
+	.vidioc_dqbuf			= xvip_dma_dqbuf,
+	.vidioc_expbuf			= xvip_dma_expbuf,
+	.vidioc_streamon		= xvip_dma_streamon,
+	.vidioc_streamoff		= xvip_dma_streamoff,
 };
 
 /* -----------------------------------------------------------------------------
  * V4L2 file operations
  */
 
-static const struct v4l2_file_operations xvip_dma_fops = {
-	.owner		= THIS_MODULE,
-	.unlocked_ioctl	= video_ioctl2,
-	.open		= v4l2_fh_open,
-	.release	= vb2_fop_release,
-	.poll		= vb2_fop_poll,
-	.mmap		= vb2_fop_mmap,
+static int xvip_dma_open(struct file *file)
+{
+	struct xvip_dma *dma = video_drvdata(file);
+	struct v4l2_fh *vfh;
+
+	vfh = kzalloc(sizeof(*vfh), GFP_KERNEL);
+	if (vfh == NULL)
+		return -ENOMEM;
+
+	v4l2_fh_init(vfh, &dma->video);
+	v4l2_fh_add(vfh);
+
+	file->private_data = vfh;
+
+	return 0;
+}
+
+static int xvip_dma_release(struct file *file)
+{
+	struct xvip_dma *dma = video_drvdata(file);
+	struct v4l2_fh *vfh = file->private_data;
+
+	mutex_lock(&dma->lock);
+	if (dma->queue.owner == vfh) {
+		vb2_queue_release(&dma->queue);
+		dma->queue.owner = NULL;
+	}
+	mutex_unlock(&dma->lock);
+
+	v4l2_fh_release(file);
+
+	file->private_data = NULL;
+
+	return 0;
+}
+
+static unsigned int xvip_dma_poll(struct file *file, poll_table *wait)
+{
+	struct v4l2_fh *vfh = file->private_data;
+	struct xvip_dma *dma = to_xvip_dma(vfh->vdev);
+	int ret;
+
+	mutex_lock(&dma->lock);
+	ret = vb2_poll(&dma->queue, file, wait);
+	mutex_unlock(&dma->lock);
+
+	return ret;
+}
+
+static int xvip_dma_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct v4l2_fh *vfh = file->private_data;
+	struct xvip_dma *dma = to_xvip_dma(vfh->vdev);
+	int ret;
+
+	mutex_lock(&dma->lock);
+	ret = vb2_mmap(&dma->queue, vma);
+	mutex_unlock(&dma->lock);
+
+	return ret;
+}
+
+static struct v4l2_file_operations xvip_dma_fops = {
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = video_ioctl2,
+	.open = xvip_dma_open,
+	.release = xvip_dma_release,
+	.poll = xvip_dma_poll,
+	.mmap = xvip_dma_mmap,
 };
 
 /* -----------------------------------------------------------------------------
  * Xilinx Video DMA Core
  */
 
-int xvip_dma_init(struct xvip_composite_device *xdev, struct xvip_dma *dma,
-		  enum v4l2_buf_type type, unsigned int port)
+int xvip_dma_init(struct xvip_pipeline *xvipp, struct xvip_dma *dma,
+		  enum v4l2_buf_type type)
 {
-	char name[14];
+	char name[10];
 	int ret;
 
-	dma->xdev = xdev;
-	dma->port = port;
+	dma->xvipp = xvipp;
 	mutex_init(&dma->lock);
-	mutex_init(&dma->pipe.lock);
-	INIT_LIST_HEAD(&dma->queued_bufs);
-	spin_lock_init(&dma->queued_lock);
 
 	dma->fmtinfo = xvip_get_format_by_fourcc(XVIP_DMA_DEF_FORMAT);
 	dma->format.pixelformat = dma->fmtinfo->fourcc;
@@ -678,57 +654,46 @@ int xvip_dma_init(struct xvip_composite_device *xdev, struct xvip_dma *dma,
 
 	ret = media_entity_init(&dma->video.entity, 1, &dma->pad, 0);
 	if (ret < 0)
-		goto error;
+		return ret;
 
 	/* ... and the video node... */
+	dma->video.v4l2_dev = &xvipp->v4l2_dev;
 	dma->video.fops = &xvip_dma_fops;
-	dma->video.v4l2_dev = &xdev->v4l2_dev;
-	dma->video.queue = &dma->queue;
-	snprintf(dma->video.name, sizeof(dma->video.name), "%s %s %u",
-		 xdev->dev->of_node->name,
-		 type == V4L2_BUF_TYPE_VIDEO_CAPTURE ? "output" : "input",
-		 port);
+	snprintf(dma->video.name, sizeof(dma->video.name), "%s %s",
+		 xvipp->dev->of_node->full_name,
+		 type == V4L2_BUF_TYPE_VIDEO_CAPTURE ? "output" : "input");
 	dma->video.vfl_type = VFL_TYPE_GRABBER;
 	dma->video.vfl_dir = type == V4L2_BUF_TYPE_VIDEO_CAPTURE
 			   ? VFL_DIR_RX : VFL_DIR_TX;
 	dma->video.release = video_device_release_empty;
 	dma->video.ioctl_ops = &xvip_dma_ioctl_ops;
-	dma->video.lock = &dma->lock;
 
 	video_set_drvdata(&dma->video, dma);
 
 	/* ... and the buffers queue... */
-	dma->alloc_ctx = vb2_dma_contig_init_ctx(dma->xdev->dev);
+	dma->alloc_ctx = vb2_dma_contig_init_ctx(dma->xvipp->dev);
 	if (IS_ERR(dma->alloc_ctx))
 		goto error;
 
-	/* Don't enable VB2_READ and VB2_WRITE, as using the read() and write()
-	 * V4L2 APIs would be inefficient. Testing on the command line with a
-	 * 'cat /dev/video?' thus won't be possible, but given that the driver
-	 * anyway requires a test tool to setup the pipeline before any video
-	 * stream can be started, requiring a specific V4L2 test tool as well
-	 * instead of 'cat' isn't really a drawback.
-	 */
 	dma->queue.type = type;
 	dma->queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;
-	dma->queue.lock = &dma->lock;
 	dma->queue.drv_priv = dma;
 	dma->queue.buf_struct_size = sizeof(struct xvip_dma_buffer);
 	dma->queue.ops = &xvip_dma_queue_qops;
 	dma->queue.mem_ops = &vb2_dma_contig_memops;
-	dma->queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC
-				   | V4L2_BUF_FLAG_TSTAMP_SRC_EOF;
+	dma->queue.timestamp_type = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
 	ret = vb2_queue_init(&dma->queue);
 	if (ret < 0) {
-		dev_err(dma->xdev->dev, "failed to initialize VB2 queue\n");
+		dev_err(dma->xvipp->dev, "failed to initialize VB2 queue\n");
 		goto error;
 	}
 
 	/* ... and the DMA channel. */
-	sprintf(name, "port%u", port);
-	dma->dma = dma_request_slave_channel(dma->xdev->dev, name);
+	sprintf(name, "vdma-%s",
+		type == V4L2_BUF_TYPE_VIDEO_CAPTURE ? "s2mm" : "mm2s");
+	dma->dma = dma_request_slave_channel(dma->xvipp->dev, name);
 	if (dma->dma == NULL) {
-		dev_err(dma->xdev->dev, "no VDMA channel found\n");
+		dev_err(dma->xvipp->dev, "no VDMA channel found\n");
 		ret = -ENODEV;
 		goto error;
 	}
@@ -737,13 +702,14 @@ int xvip_dma_init(struct xvip_composite_device *xdev, struct xvip_dma *dma,
 
 	ret = video_register_device(&dma->video, VFL_TYPE_GRABBER, -1);
 	if (ret < 0) {
-		dev_err(dma->xdev->dev, "failed to register video device\n");
+		dev_err(dma->xvipp->dev, "failed to register video device\n");
 		goto error;
 	}
 
 	return 0;
 
 error:
+	vb2_dma_contig_cleanup_ctx(dma->alloc_ctx);
 	xvip_dma_cleanup(dma);
 	return ret;
 }
@@ -756,11 +722,6 @@ void xvip_dma_cleanup(struct xvip_dma *dma)
 	if (dma->dma)
 		dma_release_channel(dma->dma);
 
-	if (!IS_ERR_OR_NULL(dma->alloc_ctx))
-		vb2_dma_contig_cleanup_ctx(dma->alloc_ctx);
-
+	vb2_dma_contig_cleanup_ctx(dma->alloc_ctx);
 	media_entity_cleanup(&dma->video.entity);
-
-	mutex_destroy(&dma->lock);
-	mutex_destroy(&dma->pipe.lock);
 }
diff --git a/drivers/media/platform/xilinx/xilinx-dma.h b/drivers/media/platform/xilinx/xilinx-dma.h
index a540111..26b677f 100644
--- a/drivers/media/platform/xilinx/xilinx-dma.h
+++ b/drivers/media/platform/xilinx/xilinx-dma.h
@@ -1,11 +1,9 @@
 /*
  * Xilinx Video DMA
  *
- * Copyright (C) 2013-2015 Ideas on Board
- * Copyright (C) 2013-2015 Xilinx, Inc.
+ * Copyright (C) 2013 Ideas on Board SPRL
  *
- * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
- *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -15,9 +13,7 @@
 #ifndef __XILINX_VIP_DMA_H__
 #define __XILINX_VIP_DMA_H__
 
-#include <linux/dmaengine.h>
 #include <linux/mutex.h>
-#include <linux/spinlock.h>
 #include <linux/videodev2.h>
 
 #include <media/media-entity.h>
@@ -25,63 +21,28 @@
 #include <media/videobuf2-core.h>
 
 struct dma_chan;
-struct xvip_composite_device;
+struct xvip_pipeline;
 struct xvip_video_format;
 
 /**
- * struct xvip_pipeline - Xilinx Video IP pipeline structure
- * @pipe: media pipeline
- * @lock: protects the pipeline @stream_count
- * @use_count: number of DMA engines using the pipeline
- * @stream_count: number of DMA engines currently streaming
- * @num_dmas: number of DMA engines in the pipeline
- * @output: DMA engine at the output of the pipeline
- */
-struct xvip_pipeline {
-	struct media_pipeline pipe;
-
-	struct mutex lock;
-	unsigned int use_count;
-	unsigned int stream_count;
-
-	unsigned int num_dmas;
-	struct xvip_dma *output;
-};
-
-static inline struct xvip_pipeline *to_xvip_pipeline(struct media_entity *e)
-{
-	return container_of(e->pipe, struct xvip_pipeline, pipe);
-}
-
-/**
- * struct xvip_dma - Video DMA channel
- * @list: list entry in a composite device dmas list
+ * struct xvip_dma - Video pipeline DMA channel
  * @video: V4L2 video device associated with the DMA channel
  * @pad: media pad for the video device entity
- * @xdev: composite device the DMA channel belongs to
- * @pipe: pipeline belonging to the DMA channel
- * @port: composite device DT node port number for the DMA channel
+ * @xvipp: video pipeline that uses the DMA channel
  * @lock: protects the @format, @fmtinfo and @queue fields
  * @format: active V4L2 pixel format
  * @fmtinfo: format information corresponding to the active @format
  * @queue: vb2 buffers queue
  * @alloc_ctx: allocation context for the vb2 @queue
  * @sequence: V4L2 buffers sequence number
- * @queued_bufs: list of queued buffers
- * @queued_lock: protects the buf_queued list
  * @dma: DMA engine channel
  * @align: transfer alignment required by the DMA channel (in bytes)
- * @xt: dma interleaved template for dma configuration
- * @sgl: data chunk structure for dma_interleaved_template
  */
 struct xvip_dma {
-	struct list_head list;
 	struct video_device video;
 	struct media_pad pad;
 
-	struct xvip_composite_device *xdev;
-	struct xvip_pipeline pipe;
-	unsigned int port;
+	struct xvip_pipeline *xvipp;
 
 	struct mutex lock;
 	struct v4l2_pix_format format;
@@ -91,19 +52,14 @@ struct xvip_dma {
 	void *alloc_ctx;
 	unsigned int sequence;
 
-	struct list_head queued_bufs;
-	spinlock_t queued_lock;
-
 	struct dma_chan *dma;
 	unsigned int align;
-	struct dma_interleaved_template xt;
-	struct data_chunk sgl[1];
 };
 
 #define to_xvip_dma(vdev)	container_of(vdev, struct xvip_dma, video)
 
-int xvip_dma_init(struct xvip_composite_device *xdev, struct xvip_dma *dma,
-		  enum v4l2_buf_type type, unsigned int port);
+int xvip_dma_init(struct xvip_pipeline *xvipp, struct xvip_dma *dma,
+		  enum v4l2_buf_type type);
 void xvip_dma_cleanup(struct xvip_dma *dma);
 
 #endif /* __XILINX_VIP_DMA_H__ */
diff --git a/drivers/media/platform/xilinx/xilinx-remapper.c b/drivers/media/platform/xilinx/xilinx-remapper.c
new file mode 100644
index 0000000..c382f83
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-remapper.c
@@ -0,0 +1,533 @@
+/*
+ * Xilinx Video Remapper
+ *
+ * Copyright (C) 2013 Ideas on Board SPRL
+ *
+ * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-subdev.h>
+
+#include "xilinx-vip.h"
+
+#define XREMAP_MIN_WIDTH			1
+#define XREMAP_DEF_WIDTH			1920
+#define XREMAP_MAX_WIDTH			65535
+#define XREMAP_MIN_HEIGHT			1
+#define XREMAP_DEF_HEIGHT			1080
+#define XREMAP_MAX_HEIGHT			65535
+
+#define XREMAP_PAD_SINK				0
+#define XREMAP_PAD_SOURCE			1
+
+/**
+ * struct xremap_mapping_output - Output format description
+ * @code: media bus pixel core after remapping
+ * @num_components: number of pixel components after remapping
+ * @component_maps: configuration array corresponding to this output
+ */
+struct xremap_mapping_output {
+	u32 code;
+	unsigned int num_components;
+	unsigned int component_maps[4];
+};
+
+/**
+ * struct xremap_mapping - Input-output remapping description
+ * @code: media bus pixel code before remapping
+ * @width: video bus width in bits
+ * @num_components: number of pixel components before remapping
+ * @outputs: array of possible output formats
+ */
+struct xremap_mapping {
+	u32 code;
+	unsigned int width;
+	unsigned int num_components;
+	const struct xremap_mapping_output *outputs;
+};
+
+/**
+ * struct xremap_device - Xilinx Test Pattern Generator device structure
+ * @xvip: Xilinx Video IP device
+ * @pads: media pads
+ * @formats: V4L2 media bus formats at the sink and source pads
+ * @config: device configuration parsed from its DT node
+ * @config.width: video bus width in bits
+ * @config.num_s_components: number of pixel components at the input
+ * @config.num_m_components: number of pixel components at the output
+ * @config.component_maps: component remapping configuration
+ * @default_mapping: Default mapping compatible with the configuration
+ * @default_output: Default output format for the default mapping
+ */
+struct xremap_device {
+	struct xvip_device xvip;
+	struct media_pad pads[2];
+	struct v4l2_mbus_framefmt formats[2];
+
+	struct {
+		unsigned int width;
+		unsigned int num_s_components;
+		unsigned int num_m_components;
+		unsigned int component_maps[4];
+	} config;
+
+	const struct xremap_mapping *default_mapping;
+	const struct xremap_mapping_output *default_output;
+};
+
+static inline struct xremap_device *to_remap(struct v4l2_subdev *subdev)
+{
+	return container_of(subdev, struct xremap_device, xvip.subdev);
+}
+
+/* -----------------------------------------------------------------------------
+ * Mappings
+ */
+
+static const struct xremap_mapping xremap_mappings[] = {
+	{
+		.code = V4L2_MBUS_FMT_RBG888_1X24,
+		.width = 8,
+		.num_components = 3,
+		.outputs = (const struct xremap_mapping_output[]) {
+			{ V4L2_MBUS_FMT_RGB888_1X32_PADHI, 4, { 1, 0, 2, 4 } },
+			{ },
+		},
+	},
+};
+
+static const struct xremap_mapping_output *
+xremap_match_mapping(struct xremap_device *xremap,
+		     const struct xremap_mapping *mapping)
+{
+	const struct xremap_mapping_output *output;
+
+	if (mapping->width != xremap->config.width ||
+	    mapping->num_components != xremap->config.num_s_components)
+		return NULL;
+
+	for (output = mapping->outputs; output->code; ++output) {
+		unsigned int i;
+
+		if (output->num_components != xremap->config.num_m_components)
+			continue;
+
+		for (i = 0; i < output->num_components; ++i) {
+			if (output->component_maps[i] !=
+			    xremap->config.component_maps[i])
+				break;
+		}
+
+		if (i == output->num_components)
+			return output;
+	}
+
+	return NULL;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Pad Operations
+ */
+
+static int xremap_enum_mbus_code(struct v4l2_subdev *subdev,
+				 struct v4l2_subdev_fh *fh,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct xremap_device *xremap = to_remap(subdev);
+	struct v4l2_mbus_framefmt *format;
+
+	if (code->pad == XREMAP_PAD_SINK) {
+		const struct xremap_mapping *mapping = NULL;
+		unsigned int index = code->index + 1;
+		unsigned int i;
+
+		/* Iterate through the mappings and skip the ones that don't
+		 * match the remapper configuration until we reach the requested
+		 * index.
+		 */
+		for (i = 0; i < ARRAY_SIZE(xremap_mappings) && index; ++i) {
+			mapping = &xremap_mappings[i];
+
+			if (xremap_match_mapping(xremap, mapping))
+				index--;
+		}
+
+		/* If the index was larger than the number of supported mappings
+		 * return -EINVAL.
+		 */
+		if (index > 0)
+			return -EINVAL;
+
+		code->code = mapping->code;
+	} else {
+		if (code->index)
+			return -EINVAL;
+
+		format = v4l2_subdev_get_try_format(fh, code->pad);
+		code->code = format->code;
+	}
+
+	return 0;
+}
+
+static int xremap_enum_frame_size(struct v4l2_subdev *subdev,
+				  struct v4l2_subdev_fh *fh,
+				  struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct v4l2_mbus_framefmt *format;
+
+	format = v4l2_subdev_get_try_format(fh, fse->pad);
+
+	if (fse->index || fse->code != format->code)
+		return -EINVAL;
+
+	if (fse->pad == XREMAP_PAD_SINK) {
+		/* The remapper doesn't restrict the size on the sink pad. */
+		fse->min_width = XREMAP_MIN_WIDTH;
+		fse->max_width = XREMAP_MAX_WIDTH;
+		fse->min_height = XREMAP_MIN_HEIGHT;
+		fse->max_height = XREMAP_MAX_HEIGHT;
+	} else {
+		/* The size on the source pad are fixed and always identical to
+		 * the size on the sink pad.
+		 */
+		fse->min_width = format->width;
+		fse->max_width = format->width;
+		fse->min_height = format->height;
+		fse->max_height = format->height;
+	}
+
+	return 0;
+}
+
+static struct v4l2_mbus_framefmt *
+xremap_get_pad_format(struct xremap_device *xremap, struct v4l2_subdev_fh *fh,
+		      unsigned int pad, u32 which)
+{
+	switch (which) {
+	case V4L2_SUBDEV_FORMAT_TRY:
+		return v4l2_subdev_get_try_format(fh, pad);
+	case V4L2_SUBDEV_FORMAT_ACTIVE:
+		return &xremap->formats[pad];
+	default:
+		return NULL;
+	}
+}
+
+static int xremap_get_format(struct v4l2_subdev *subdev,
+			     struct v4l2_subdev_fh *fh,
+			     struct v4l2_subdev_format *fmt)
+{
+	struct xremap_device *xremap = to_remap(subdev);
+
+	fmt->format = *xremap_get_pad_format(xremap, fh, fmt->pad, fmt->which);
+
+	return 0;
+}
+
+static int xremap_set_format(struct v4l2_subdev *subdev,
+			     struct v4l2_subdev_fh *fh,
+			     struct v4l2_subdev_format *fmt)
+{
+	struct xremap_device *xremap = to_remap(subdev);
+	const struct xremap_mapping_output *output;
+	const struct xremap_mapping *mapping;
+	struct v4l2_mbus_framefmt *format;
+	unsigned int i;
+
+	format = xremap_get_pad_format(xremap, fh, fmt->pad, fmt->which);
+
+	if (fmt->pad == XREMAP_PAD_SOURCE) {
+		fmt->format = *format;
+		return 0;
+	}
+
+	/* Find the mapping. If the requested format has no mapping, use the
+	 * default.
+	 */
+	for (i = 0; i < ARRAY_SIZE(xremap_mappings); ++i) {
+		mapping = &xremap_mappings[i];
+		if (mapping->code != fmt->format.code)
+			continue;
+
+		output = xremap_match_mapping(xremap, mapping);
+		if (output)
+			break;
+	}
+
+	if (!output) {
+		mapping = xremap->default_mapping;
+		output = xremap->default_output;
+	}
+
+	format->code = mapping->code;
+	format->width = clamp_t(unsigned int, fmt->format.width,
+				XREMAP_MIN_WIDTH, XREMAP_MAX_WIDTH);
+	format->height = clamp_t(unsigned int, fmt->format.height,
+				 XREMAP_MIN_HEIGHT, XREMAP_MAX_HEIGHT);
+	format->field = V4L2_FIELD_NONE;
+	format->colorspace = V4L2_COLORSPACE_SRGB;
+
+	fmt->format = *format;
+
+	/* Propagate the format to the source pad. */
+	format = xremap_get_pad_format(xremap, fh, XREMAP_PAD_SOURCE,
+				       fmt->which);
+	*format = fmt->format;
+	format->code = output->code;
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Operations
+ */
+
+/*
+ * xremap_init_formats - Initialize formats on all pads
+ * @subdev: remapper V4L2 subdevice
+ * @fh: V4L2 subdev file handle
+ *
+ * Initialize all pad formats with default values. If fh is not NULL, try
+ * formats are initialized on the file handle. Otherwise active formats are
+ * initialized on the device.
+ */
+static void xremap_init_formats(struct v4l2_subdev *subdev,
+				struct v4l2_subdev_fh *fh)
+{
+	struct xremap_device *xremap = to_remap(subdev);
+	struct v4l2_subdev_format format;
+
+	memset(&format, 0, sizeof(format));
+
+	format.pad = XREMAP_PAD_SINK;
+	format.which = fh ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;
+	format.format.code = xremap->default_mapping->code;
+	format.format.width = XREMAP_DEF_WIDTH;
+	format.format.height = XREMAP_DEF_HEIGHT;
+
+	xremap_set_format(subdev, fh, &format);
+}
+
+static int xremap_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	xremap_init_formats(subdev, fh);
+
+	return 0;
+}
+
+static int xremap_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
+{
+	return 0;
+}
+
+static struct v4l2_subdev_core_ops xremap_core_ops = {
+};
+
+static struct v4l2_subdev_video_ops xremap_video_ops = {
+};
+
+static struct v4l2_subdev_pad_ops xremap_pad_ops = {
+	.enum_mbus_code = xremap_enum_mbus_code,
+	.enum_frame_size = xremap_enum_frame_size,
+	.get_fmt = xremap_get_format,
+	.set_fmt = xremap_set_format,
+};
+
+static struct v4l2_subdev_ops xremap_ops = {
+	.core   = &xremap_core_ops,
+	.video  = &xremap_video_ops,
+	.pad    = &xremap_pad_ops,
+};
+
+static const struct v4l2_subdev_internal_ops xremap_internal_ops = {
+	.open = xremap_open,
+	.close = xremap_close,
+};
+
+/* -----------------------------------------------------------------------------
+ * Media Operations
+ */
+
+static const struct media_entity_operations xremap_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+/* -----------------------------------------------------------------------------
+ * Platform Device Driver
+ */
+
+static int xremap_parse_of(struct xremap_device *xremap)
+{
+	struct device_node *node = xremap->xvip.dev->of_node;
+	unsigned int i;
+	int ret;
+
+	/* Parse the DT properties. */
+	ret = of_property_read_u32(node, "xlnx,axi-video-width",
+				   &xremap->config.width);
+	if (ret < 0) {
+		dev_dbg(xremap->xvip.dev, "unable to parse %s property\n",
+			"xlnx,axi-video-width");
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32(node, "#xlnx,axi-s-components",
+				   &xremap->config.num_s_components);
+	if (ret < 0) {
+		dev_dbg(xremap->xvip.dev, "unable to parse %s property\n",
+			"#xlnx,axi-s-components");
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32(node, "#xlnx,axi-m-components",
+				   &xremap->config.num_m_components);
+	if (ret < 0) {
+		dev_dbg(xremap->xvip.dev, "unable to parse %s property\n",
+			"#xlnx,axi-m-components");
+		return -EINVAL;
+	}
+
+	ret = of_property_read_u32_array(node, "xlnx,axi-component-maps",
+					 xremap->config.component_maps,
+					 xremap->config.num_m_components);
+	if (ret < 0) {
+		dev_dbg(xremap->xvip.dev, "unable to parse %s property\n",
+			"xlnx,axi-component-maps");
+		return -EINVAL;
+	}
+
+	/* Validate the parsed values. */
+	if (xremap->config.num_s_components > 4 ||
+	    xremap->config.num_m_components > 4) {
+		dev_dbg(xremap->xvip.dev,
+			"invalid number of components (s %u m %u)\n",
+			xremap->config.num_s_components,
+			xremap->config.num_m_components);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < xremap->config.num_m_components; ++i) {
+		if (xremap->config.component_maps[i] > 4) {
+			dev_dbg(xremap->xvip.dev, "invalid map %u @%u\n",
+				xremap->config.component_maps[i], i);
+			return -EINVAL;
+		}
+	}
+
+	/* Find the first mapping that matches the remapper configuration and
+	 * store it as the default mapping.
+	 */
+	for (i = 0; i < ARRAY_SIZE(xremap_mappings); ++i) {
+		const struct xremap_mapping_output *output;
+		const struct xremap_mapping *mapping;
+
+		mapping = &xremap_mappings[i];
+		output = xremap_match_mapping(xremap, mapping);
+
+		if (output) {
+			xremap->default_mapping = mapping;
+			xremap->default_output = output;
+			return 0;
+		}
+	}
+
+	dev_err(xremap->xvip.dev,
+		"No format compatible with device configuration\n");
+
+	return -EINVAL;
+}
+
+static int xremap_probe(struct platform_device *pdev)
+{
+	struct xremap_device *xremap;
+	struct v4l2_subdev *subdev;
+	int ret;
+
+	xremap = devm_kzalloc(&pdev->dev, sizeof(*xremap), GFP_KERNEL);
+	if (!xremap)
+		return -ENOMEM;
+
+	xremap->xvip.dev = &pdev->dev;
+
+	ret = xremap_parse_of(xremap);
+	if (ret < 0)
+		return ret;
+
+	/* Initialize V4L2 subdevice and media entity */
+	subdev = &xremap->xvip.subdev;
+	v4l2_subdev_init(subdev, &xremap_ops);
+	subdev->dev = &pdev->dev;
+	subdev->internal_ops = &xremap_internal_ops;
+	strlcpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
+	v4l2_set_subdevdata(subdev, xremap);
+	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	xremap_init_formats(subdev, NULL);
+
+	xremap->pads[XREMAP_PAD_SINK].flags = MEDIA_PAD_FL_SINK;
+	xremap->pads[XREMAP_PAD_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	subdev->entity.ops = &xremap_media_ops;
+	ret = media_entity_init(&subdev->entity, 2, xremap->pads, 0);
+	if (ret < 0)
+		return ret;
+
+	platform_set_drvdata(pdev, xremap);
+
+	ret = v4l2_async_register_subdev(subdev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to register subdev\n");
+		goto error;
+	}
+
+	dev_info(&pdev->dev, "device registered\n");
+
+	return 0;
+
+error:
+	media_entity_cleanup(&subdev->entity);
+	return ret;
+}
+
+static int xremap_remove(struct platform_device *pdev)
+{
+	struct xremap_device *xremap = platform_get_drvdata(pdev);
+	struct v4l2_subdev *subdev = &xremap->xvip.subdev;
+
+	v4l2_async_unregister_subdev(subdev);
+	media_entity_cleanup(&subdev->entity);
+
+	return 0;
+}
+
+static const struct of_device_id xremap_of_id_table[] = {
+	{ .compatible = "xlnx,axi-remapper" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, xremap_of_id_table);
+
+static struct platform_driver xremap_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "xilinx-axi-remapper",
+		.of_match_table = of_match_ptr(xremap_of_id_table),
+	},
+	.probe = xremap_probe,
+	.remove = xremap_remove,
+};
+
+module_platform_driver(xremap_driver);
+
+MODULE_AUTHOR("Laurent Pinchart <laurent.pinchart@ideasonboard.com>");
+MODULE_DESCRIPTION("Xilinx Video Remapper Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/xilinx/xilinx-tpg.c b/drivers/media/platform/xilinx/xilinx-tpg.c
index b5f7d5e..7853cb4 100644
--- a/drivers/media/platform/xilinx/xilinx-tpg.c
+++ b/drivers/media/platform/xilinx/xilinx-tpg.c
@@ -1,113 +1,58 @@
 /*
  * Xilinx Test Pattern Generator
  *
- * Copyright (C) 2013-2015 Ideas on Board
- * Copyright (C) 2013-2015 Xilinx, Inc.
+ * Copyright (C) 2013 Ideas on Board SPRL
  *
- * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
- *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
 
-#include <linux/device.h>
-#include <linux/gpio/consumer.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/platform_device.h>
-#include <linux/xilinx-v4l2-controls.h>
+#include <linux/slab.h>
 
 #include <media/v4l2-async.h>
-#include <media/v4l2-ctrls.h>
 #include <media/v4l2-subdev.h>
 
 #include "xilinx-vip.h"
-#include "xilinx-vtc.h"
+
+#define XTPG_MIN_WIDTH				32
+#define XTPG_DEF_WIDTH				1920
+#define XTPG_MAX_WIDTH				7680
+#define XTPG_MIN_HEIGHT				32
+#define XTPG_DEF_HEIGHT				1080
+#define XTPG_MAX_HEIGHT				7680
 
 #define XTPG_CTRL_STATUS_SLAVE_ERROR		(1 << 16)
 #define XTPG_CTRL_IRQ_SLAVE_ERROR		(1 << 16)
 
 #define XTPG_PATTERN_CONTROL			0x0100
-#define XTPG_PATTERN_MASK			(0xf << 0)
-#define XTPG_PATTERN_CONTROL_CROSS_HAIRS	(1 << 4)
-#define XTPG_PATTERN_CONTROL_MOVING_BOX		(1 << 5)
-#define XTPG_PATTERN_CONTROL_COLOR_MASK_SHIFT	6
-#define XTPG_PATTERN_CONTROL_COLOR_MASK_MASK	(0xf << 6)
-#define XTPG_PATTERN_CONTROL_STUCK_PIXEL	(1 << 9)
-#define XTPG_PATTERN_CONTROL_NOISE		(1 << 10)
-#define XTPG_PATTERN_CONTROL_MOTION		(1 << 12)
 #define XTPG_MOTION_SPEED			0x0104
 #define XTPG_CROSS_HAIRS			0x0108
-#define XTPG_CROSS_HAIRS_ROW_SHIFT		0
-#define XTPG_CROSS_HAIRS_ROW_MASK		(0xfff << 0)
-#define XTPG_CROSS_HAIRS_COLUMN_SHIFT		16
-#define XTPG_CROSS_HAIRS_COLUMN_MASK		(0xfff << 16)
 #define XTPG_ZPLATE_HOR_CONTROL			0x010c
 #define XTPG_ZPLATE_VER_CONTROL			0x0110
-#define XTPG_ZPLATE_START_SHIFT			0
-#define XTPG_ZPLATE_START_MASK			(0xffff << 0)
-#define XTPG_ZPLATE_SPEED_SHIFT			16
-#define XTPG_ZPLATE_SPEED_MASK			(0xffff << 16)
 #define XTPG_BOX_SIZE				0x0114
 #define XTPG_BOX_COLOR				0x0118
 #define XTPG_STUCK_PIXEL_THRESH			0x011c
 #define XTPG_NOISE_GAIN				0x0120
-#define XTPG_BAYER_PHASE			0x0124
-#define XTPG_BAYER_PHASE_RGGB			0
-#define XTPG_BAYER_PHASE_GRBG			1
-#define XTPG_BAYER_PHASE_GBRG			2
-#define XTPG_BAYER_PHASE_BGGR			3
-#define XTPG_BAYER_PHASE_OFF			4
-
-/*
- * The minimum blanking value is one clock cycle for the front porch, one clock
- * cycle for the sync pulse and one clock cycle for the back porch.
- */
-#define XTPG_MIN_HBLANK			3
-#define XTPG_MAX_HBLANK			(XVTC_MAX_HSIZE - XVIP_MIN_WIDTH)
-#define XTPG_MIN_VBLANK			3
-#define XTPG_MAX_VBLANK			(XVTC_MAX_VSIZE - XVIP_MIN_HEIGHT)
 
 /**
  * struct xtpg_device - Xilinx Test Pattern Generator device structure
+ * @pad: media pad
  * @xvip: Xilinx Video IP device
- * @pads: media pads
- * @npads: number of pads (1 or 2)
- * @has_input: whether an input is connected to the sink pad
- * @formats: active V4L2 media bus format for each pad
- * @default_format: default V4L2 media bus format
+ * @format: active V4L2 media bus format at the source pad
  * @vip_format: format information corresponding to the active format
- * @bayer: boolean flag if TPG is set to any bayer format
- * @ctrl_handler: control handler
- * @hblank: horizontal blanking control
- * @vblank: vertical blanking control
- * @pattern: test pattern control
- * @streaming: is the video stream active
- * @vtc: video timing controller
- * @vtmux_gpio: video timing mux GPIO
  */
 struct xtpg_device {
 	struct xvip_device xvip;
+	struct media_pad pad;
 
-	struct media_pad pads[2];
-	unsigned int npads;
-	bool has_input;
-
-	struct v4l2_mbus_framefmt formats[2];
-	struct v4l2_mbus_framefmt default_format;
+	struct v4l2_mbus_framefmt format;
 	const struct xvip_video_format *vip_format;
-	bool bayer;
-
-	struct v4l2_ctrl_handler ctrl_handler;
-	struct v4l2_ctrl *hblank;
-	struct v4l2_ctrl *vblank;
-	struct v4l2_ctrl *pattern;
-	bool streaming;
-
-	struct xvtc_device *vtc;
-	struct gpio_desc *vtmux_gpio;
 };
 
 static inline struct xtpg_device *to_tpg(struct v4l2_subdev *subdev)
@@ -115,54 +60,6 @@ static inline struct xtpg_device *to_tpg(struct v4l2_subdev *subdev)
 	return container_of(subdev, struct xtpg_device, xvip.subdev);
 }
 
-static u32 xtpg_get_bayer_phase(unsigned int code)
-{
-	switch (code) {
-	case MEDIA_BUS_FMT_SRGGB8_1X8:
-		return XTPG_BAYER_PHASE_RGGB;
-	case MEDIA_BUS_FMT_SGRBG8_1X8:
-		return XTPG_BAYER_PHASE_GRBG;
-	case MEDIA_BUS_FMT_SGBRG8_1X8:
-		return XTPG_BAYER_PHASE_GBRG;
-	case MEDIA_BUS_FMT_SBGGR8_1X8:
-		return XTPG_BAYER_PHASE_BGGR;
-	default:
-		return XTPG_BAYER_PHASE_OFF;
-	}
-}
-
-static void __xtpg_update_pattern_control(struct xtpg_device *xtpg,
-					  bool passthrough, bool pattern)
-{
-	u32 pattern_mask = (1 << (xtpg->pattern->maximum + 1)) - 1;
-
-	/*
-	 * If the TPG has no sink pad or no input connected to its sink pad
-	 * passthrough mode can't be enabled.
-	 */
-	if (xtpg->npads == 1 || !xtpg->has_input)
-		passthrough = false;
-
-	/* If passthrough mode is allowed unmask bit 0. */
-	if (passthrough)
-		pattern_mask &= ~1;
-
-	/* If test pattern mode is allowed unmask all other bits. */
-	if (pattern)
-		pattern_mask &= 1;
-
-	__v4l2_ctrl_modify_range(xtpg->pattern, 0, xtpg->pattern->maximum,
-				 pattern_mask, pattern ? 9 : 0);
-}
-
-static void xtpg_update_pattern_control(struct xtpg_device *xtpg,
-					bool passthrough, bool pattern)
-{
-	mutex_lock(xtpg->ctrl_handler.lock);
-	__xtpg_update_pattern_control(xtpg, passthrough, pattern);
-	mutex_unlock(xtpg->ctrl_handler.lock);
-}
-
 /* -----------------------------------------------------------------------------
  * V4L2 Subdevice Video Operations
  */
@@ -170,148 +67,114 @@ static void xtpg_update_pattern_control(struct xtpg_device *xtpg,
 static int xtpg_s_stream(struct v4l2_subdev *subdev, int enable)
 {
 	struct xtpg_device *xtpg = to_tpg(subdev);
-	unsigned int width = xtpg->formats[0].width;
-	unsigned int height = xtpg->formats[0].height;
-	bool passthrough;
-	u32 bayer_phase;
+	const u32 width = xtpg->format.width;
+	const u32 height = xtpg->format.height;
 
 	if (!enable) {
-		xvip_stop(&xtpg->xvip);
-		if (xtpg->vtc)
-			xvtc_generator_stop(xtpg->vtc);
-
-		xtpg_update_pattern_control(xtpg, true, true);
-		xtpg->streaming = false;
+		/* Stopping the TPG without resetting it confuses the VDMA and
+		 * results in VDMA errors the next time the stream is started.
+		 * Reset the TPG when stopping the stream for now.
+		 */
+		xvip_write(&xtpg->xvip, XVIP_CTRL_CONTROL,
+			   XVIP_CTRL_CONTROL_SW_RESET);
+		xvip_write(&xtpg->xvip, XVIP_CTRL_CONTROL, 0);
 		return 0;
 	}
 
-	xvip_set_frame_size(&xtpg->xvip, &xtpg->formats[0]);
-
-	if (xtpg->vtc) {
-		struct xvtc_config config = {
-			.hblank_start = width,
-			.hsync_start = width + 1,
-			.vblank_start = height,
-			.vsync_start = height + 1,
-		};
-		unsigned int htotal;
-		unsigned int vtotal;
-
-		htotal = min_t(unsigned int, XVTC_MAX_HSIZE,
-			       v4l2_ctrl_g_ctrl(xtpg->hblank) + width);
-		vtotal = min_t(unsigned int, XVTC_MAX_VSIZE,
-			       v4l2_ctrl_g_ctrl(xtpg->vblank) + height);
-
-		config.hsync_end = htotal - 1;
-		config.hsize = htotal;
-		config.vsync_end = vtotal - 1;
-		config.vsize = vtotal;
-
-		xvtc_generator_start(xtpg->vtc, &config);
-	}
-
-	/*
-	 * Configure the bayer phase and video timing mux based on the
-	 * operation mode (passthrough or test pattern generation). The test
-	 * pattern can be modified by the control set handler, we thus need to
-	 * take the control lock here to avoid races.
-	 */
-	mutex_lock(xtpg->ctrl_handler.lock);
+	xvip_write(&xtpg->xvip, XVIP_TIMING_ACTIVE_SIZE,
+		   (height << XVIP_TIMING_ACTIVE_VSIZE_SHIFT) |
+		   (width << XVIP_TIMING_ACTIVE_HSIZE_SHIFT));
 
-	xvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
-			 XTPG_PATTERN_MASK, xtpg->pattern->cur.val);
+	xvip_write(&xtpg->xvip, XTPG_PATTERN_CONTROL, 0x00001029);
+	xvip_write(&xtpg->xvip, XTPG_MOTION_SPEED, 1);
+	xvip_write(&xtpg->xvip, XTPG_ZPLATE_HOR_CONTROL, (74 * 1920) / width);
+	xvip_write(&xtpg->xvip, XTPG_ZPLATE_VER_CONTROL, (3 * 1080) / height);
+	xvip_write(&xtpg->xvip, XTPG_BOX_SIZE, (112 * height) / 1080);
+	xvip_write(&xtpg->xvip, XTPG_BOX_COLOR, 0x76543200);
 
-	/*
-	 * Switching between passthrough and test pattern generation modes isn't
-	 * allowed during streaming, update the control range accordingly.
-	 */
-	passthrough = xtpg->pattern->cur.val == 0;
-	__xtpg_update_pattern_control(xtpg, passthrough, !passthrough);
+	xvip_write(&xtpg->xvip, XVIP_CTRL_CONTROL, XVIP_CTRL_CONTROL_SW_ENABLE |
+		   XVIP_CTRL_CONTROL_REG_UPDATE);
 
-	xtpg->streaming = true;
+	return 0;
+}
 
-	mutex_unlock(xtpg->ctrl_handler.lock);
+/* -----------------------------------------------------------------------------
+ * V4L2 Subdevice Pad Operations
+ */
 
-	/*
-	 * For TPG v5.0, the bayer phase needs to be off for the pass through
-	 * mode, otherwise the external input would be subsampled.
-	 */
-	bayer_phase = passthrough ? XTPG_BAYER_PHASE_OFF
-		    : xtpg_get_bayer_phase(xtpg->formats[0].code);
-	xvip_write(&xtpg->xvip, XTPG_BAYER_PHASE, bayer_phase);
+static int xtpg_enum_mbus_code(struct v4l2_subdev *subdev,
+				     struct v4l2_subdev_fh *fh,
+				     struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct xtpg_device *xtpg = to_tpg(subdev);
 
-	if (xtpg->vtmux_gpio)
-		gpiod_set_value_cansleep(xtpg->vtmux_gpio, !passthrough);
+	if (code->index)
+		return -EINVAL;
 
-	xvip_start(&xtpg->xvip);
+	code->code = xtpg->vip_format->code;
 
 	return 0;
 }
 
-/* -----------------------------------------------------------------------------
- * V4L2 Subdevice Pad Operations
- */
+static int xtpg_enum_frame_size(struct v4l2_subdev *subdev,
+				      struct v4l2_subdev_fh *fh,
+				      struct v4l2_subdev_frame_size_enum *fse)
+{
+	struct xtpg_device *xtpg = to_tpg(subdev);
+
+	if (fse->index || fse->code != xtpg->vip_format->code)
+		return -EINVAL;
+
+	fse->min_width = XTPG_MIN_WIDTH;
+	fse->max_width = XTPG_MAX_WIDTH;
+	fse->min_height = XTPG_MIN_HEIGHT;
+	fse->max_height = XTPG_MAX_HEIGHT;
+
+	return 0;
+}
 
 static struct v4l2_mbus_framefmt *
 __xtpg_get_pad_format(struct xtpg_device *xtpg,
-		      struct v4l2_subdev_pad_config *cfg,
-		      unsigned int pad, u32 which)
+			    struct v4l2_subdev_fh *fh,
+			    unsigned int pad, u32 which)
 {
 	switch (which) {
 	case V4L2_SUBDEV_FORMAT_TRY:
-		return v4l2_subdev_get_try_format(&xtpg->xvip.subdev, cfg, pad);
+		return v4l2_subdev_get_try_format(fh, pad);
 	case V4L2_SUBDEV_FORMAT_ACTIVE:
-		return &xtpg->formats[pad];
+		return &xtpg->format;
 	default:
 		return NULL;
 	}
 }
 
 static int xtpg_get_format(struct v4l2_subdev *subdev,
-			   struct v4l2_subdev_pad_config *cfg,
-			   struct v4l2_subdev_format *fmt)
+				 struct v4l2_subdev_fh *fh,
+				 struct v4l2_subdev_format *fmt)
 {
 	struct xtpg_device *xtpg = to_tpg(subdev);
 
-	fmt->format = *__xtpg_get_pad_format(xtpg, cfg, fmt->pad, fmt->which);
+	fmt->format =
+		*__xtpg_get_pad_format(xtpg, fh, fmt->pad, fmt->which);
 
 	return 0;
 }
 
 static int xtpg_set_format(struct v4l2_subdev *subdev,
-			   struct v4l2_subdev_pad_config *cfg,
-			   struct v4l2_subdev_format *fmt)
+				 struct v4l2_subdev_fh *fh,
+				 struct v4l2_subdev_format *format)
 {
 	struct xtpg_device *xtpg = to_tpg(subdev);
 	struct v4l2_mbus_framefmt *__format;
-	u32 bayer_phase;
 
-	__format = __xtpg_get_pad_format(xtpg, cfg, fmt->pad, fmt->which);
+	__format = __xtpg_get_pad_format(xtpg, fh, format->pad,
+					       format->which);
+	__format->width = clamp_t(unsigned int, format->format.width,
+				  XTPG_MIN_WIDTH, XTPG_MAX_WIDTH);
+	__format->height = clamp_t(unsigned int, format->format.height,
+				   XTPG_MIN_HEIGHT, XTPG_MAX_HEIGHT);
 
-	/* In two pads mode the source pad format is always identical to the
-	 * sink pad format.
-	 */
-	if (xtpg->npads == 2 && fmt->pad == 1) {
-		fmt->format = *__format;
-		return 0;
-	}
-
-	/* Bayer phase is configurable at runtime */
-	if (xtpg->bayer) {
-		bayer_phase = xtpg_get_bayer_phase(fmt->format.code);
-		if (bayer_phase != XTPG_BAYER_PHASE_OFF)
-			__format->code = fmt->format.code;
-	}
-
-	xvip_set_format_size(__format, fmt);
-
-	fmt->format = *__format;
-
-	/* Propagate the format to the source pad. */
-	if (xtpg->npads == 2) {
-		__format = __xtpg_get_pad_format(xtpg, cfg, 1, fmt->which);
-		*__format = fmt->format;
-	}
+	format->format = *__format;
 
 	return 0;
 }
@@ -320,47 +183,18 @@ static int xtpg_set_format(struct v4l2_subdev *subdev,
  * V4L2 Subdevice Operations
  */
 
-static int xtpg_enum_frame_size(struct v4l2_subdev *subdev,
-				struct v4l2_subdev_pad_config *cfg,
-				struct v4l2_subdev_frame_size_enum *fse)
-{
-	struct v4l2_mbus_framefmt *format;
-
-	format = v4l2_subdev_get_try_format(subdev, cfg, fse->pad);
-
-	if (fse->index || fse->code != format->code)
-		return -EINVAL;
-
-	/* Min / max values for pad 0 is always fixed in both one and two pads
-	 * modes. In two pads mode, the source pad(= 1) size is identical to
-	 * the sink pad size */
-	if (fse->pad == 0) {
-		fse->min_width = XVIP_MIN_WIDTH;
-		fse->max_width = XVIP_MAX_WIDTH;
-		fse->min_height = XVIP_MIN_HEIGHT;
-		fse->max_height = XVIP_MAX_HEIGHT;
-	} else {
-		fse->min_width = format->width;
-		fse->max_width = format->width;
-		fse->min_height = format->height;
-		fse->max_height = format->height;
-	}
-
-	return 0;
-}
-
 static int xtpg_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
 {
 	struct xtpg_device *xtpg = to_tpg(subdev);
 	struct v4l2_mbus_framefmt *format;
 
-	format = v4l2_subdev_get_try_format(subdev, fh->pad, 0);
-	*format = xtpg->default_format;
+	format = v4l2_subdev_get_try_format(fh, 0);
 
-	if (xtpg->npads == 2) {
-		format = v4l2_subdev_get_try_format(subdev, fh->pad, 1);
-		*format = xtpg->default_format;
-	}
+	format->code = xtpg->vip_format->code;
+	format->width = XTPG_DEF_WIDTH;
+	format->height = XTPG_DEF_HEIGHT;
+	format->field = V4L2_FIELD_NONE;
+	format->colorspace = V4L2_COLORSPACE_SRGB;
 
 	return 0;
 }
@@ -370,96 +204,6 @@ static int xtpg_close(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
 	return 0;
 }
 
-static int xtpg_s_ctrl(struct v4l2_ctrl *ctrl)
-{
-	struct xtpg_device *xtpg = container_of(ctrl->handler,
-						struct xtpg_device,
-						ctrl_handler);
-	switch (ctrl->id) {
-	case V4L2_CID_TEST_PATTERN:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
-				 XTPG_PATTERN_MASK, ctrl->val);
-		return 0;
-	case V4L2_CID_XILINX_TPG_CROSS_HAIRS:
-		xvip_clr_or_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
-				XTPG_PATTERN_CONTROL_CROSS_HAIRS, ctrl->val);
-		return 0;
-	case V4L2_CID_XILINX_TPG_MOVING_BOX:
-		xvip_clr_or_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
-				XTPG_PATTERN_CONTROL_MOVING_BOX, ctrl->val);
-		return 0;
-	case V4L2_CID_XILINX_TPG_COLOR_MASK:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
-				 XTPG_PATTERN_CONTROL_COLOR_MASK_MASK,
-				 ctrl->val <<
-				 XTPG_PATTERN_CONTROL_COLOR_MASK_SHIFT);
-		return 0;
-	case V4L2_CID_XILINX_TPG_STUCK_PIXEL:
-		xvip_clr_or_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
-				XTPG_PATTERN_CONTROL_STUCK_PIXEL, ctrl->val);
-		return 0;
-	case V4L2_CID_XILINX_TPG_NOISE:
-		xvip_clr_or_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
-				XTPG_PATTERN_CONTROL_NOISE, ctrl->val);
-		return 0;
-	case V4L2_CID_XILINX_TPG_MOTION:
-		xvip_clr_or_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
-				XTPG_PATTERN_CONTROL_MOTION, ctrl->val);
-		return 0;
-	case V4L2_CID_XILINX_TPG_MOTION_SPEED:
-		xvip_write(&xtpg->xvip, XTPG_MOTION_SPEED, ctrl->val);
-		return 0;
-	case V4L2_CID_XILINX_TPG_CROSS_HAIR_ROW:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_CROSS_HAIRS,
-				 XTPG_CROSS_HAIRS_ROW_MASK,
-				 ctrl->val << XTPG_CROSS_HAIRS_ROW_SHIFT);
-		return 0;
-	case V4L2_CID_XILINX_TPG_CROSS_HAIR_COLUMN:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_CROSS_HAIRS,
-				 XTPG_CROSS_HAIRS_COLUMN_MASK,
-				 ctrl->val << XTPG_CROSS_HAIRS_COLUMN_SHIFT);
-		return 0;
-	case V4L2_CID_XILINX_TPG_ZPLATE_HOR_START:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_HOR_CONTROL,
-				 XTPG_ZPLATE_START_MASK,
-				 ctrl->val << XTPG_ZPLATE_START_SHIFT);
-		return 0;
-	case V4L2_CID_XILINX_TPG_ZPLATE_HOR_SPEED:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_HOR_CONTROL,
-				 XTPG_ZPLATE_SPEED_MASK,
-				 ctrl->val << XTPG_ZPLATE_SPEED_SHIFT);
-		return 0;
-	case V4L2_CID_XILINX_TPG_ZPLATE_VER_START:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_VER_CONTROL,
-				 XTPG_ZPLATE_START_MASK,
-				 ctrl->val << XTPG_ZPLATE_START_SHIFT);
-		return 0;
-	case V4L2_CID_XILINX_TPG_ZPLATE_VER_SPEED:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_VER_CONTROL,
-				 XTPG_ZPLATE_SPEED_MASK,
-				 ctrl->val << XTPG_ZPLATE_SPEED_SHIFT);
-		return 0;
-	case V4L2_CID_XILINX_TPG_BOX_SIZE:
-		xvip_write(&xtpg->xvip, XTPG_BOX_SIZE, ctrl->val);
-		return 0;
-	case V4L2_CID_XILINX_TPG_BOX_COLOR:
-		xvip_write(&xtpg->xvip, XTPG_BOX_COLOR, ctrl->val);
-		return 0;
-	case V4L2_CID_XILINX_TPG_STUCK_PIXEL_THRESH:
-		xvip_write(&xtpg->xvip, XTPG_STUCK_PIXEL_THRESH, ctrl->val);
-		return 0;
-	case V4L2_CID_XILINX_TPG_NOISE_GAIN:
-		xvip_write(&xtpg->xvip, XTPG_NOISE_GAIN, ctrl->val);
-		return 0;
-	}
-
-	return 0;
-}
-
-static const struct v4l2_ctrl_ops xtpg_ctrl_ops = {
-	.s_ctrl	= xtpg_s_ctrl,
-};
-
 static struct v4l2_subdev_core_ops xtpg_core_ops = {
 };
 
@@ -468,10 +212,10 @@ static struct v4l2_subdev_video_ops xtpg_video_ops = {
 };
 
 static struct v4l2_subdev_pad_ops xtpg_pad_ops = {
-	.enum_mbus_code		= xvip_enum_mbus_code,
-	.enum_frame_size	= xtpg_enum_frame_size,
-	.get_fmt		= xtpg_get_format,
-	.set_fmt		= xtpg_set_format,
+	.enum_mbus_code = xtpg_enum_mbus_code,
+	.enum_frame_size = xtpg_enum_frame_size,
+	.get_fmt = xtpg_get_format,
+	.set_fmt = xtpg_set_format,
 };
 
 static struct v4l2_subdev_ops xtpg_ops = {
@@ -481,197 +225,8 @@ static struct v4l2_subdev_ops xtpg_ops = {
 };
 
 static const struct v4l2_subdev_internal_ops xtpg_internal_ops = {
-	.open	= xtpg_open,
-	.close	= xtpg_close,
-};
-
-/*
- * Control Config
- */
-
-static const char *const xtpg_pattern_strings[] = {
-	"Passthrough",
-	"Horizontal Ramp",
-	"Vertical Ramp",
-	"Temporal Ramp",
-	"Solid Red",
-	"Solid Green",
-	"Solid Blue",
-	"Solid Black",
-	"Solid White",
-	"Color Bars",
-	"Zone Plate",
-	"Tartan Color Bars",
-	"Cross Hatch",
-	"None",
-	"Vertical/Horizontal Ramps",
-	"Black/White Checker Board",
-};
-
-static struct v4l2_ctrl_config xtpg_ctrls[] = {
-	{
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_CROSS_HAIRS,
-		.name	= "Test Pattern: Cross Hairs",
-		.type	= V4L2_CTRL_TYPE_BOOLEAN,
-		.min	= false,
-		.max	= true,
-		.step	= 1,
-		.def	= 0,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_MOVING_BOX,
-		.name	= "Test Pattern: Moving Box",
-		.type	= V4L2_CTRL_TYPE_BOOLEAN,
-		.min	= false,
-		.max	= true,
-		.step	= 1,
-		.def	= 0,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_COLOR_MASK,
-		.name	= "Test Pattern: Color Mask",
-		.type	= V4L2_CTRL_TYPE_BITMASK,
-		.min	= 0,
-		.max	= 0xf,
-		.def	= 0,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_STUCK_PIXEL,
-		.name	= "Test Pattern: Stuck Pixel",
-		.type	= V4L2_CTRL_TYPE_BOOLEAN,
-		.min	= false,
-		.max	= true,
-		.step	= 1,
-		.def	= 0,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_NOISE,
-		.name	= "Test Pattern: Noise",
-		.type	= V4L2_CTRL_TYPE_BOOLEAN,
-		.min	= false,
-		.max	= true,
-		.step	= 1,
-		.def	= 0,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_MOTION,
-		.name	= "Test Pattern: Motion",
-		.type	= V4L2_CTRL_TYPE_BOOLEAN,
-		.min	= false,
-		.max	= true,
-		.step	= 1,
-		.def	= 0,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_MOTION_SPEED,
-		.name	= "Test Pattern: Motion Speed",
-		.type	= V4L2_CTRL_TYPE_INTEGER,
-		.min	= 0,
-		.max	= (1 << 8) - 1,
-		.step	= 1,
-		.def	= 4,
-		.flags	= V4L2_CTRL_FLAG_SLIDER,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_CROSS_HAIR_ROW,
-		.name	= "Test Pattern: Cross Hairs Row",
-		.type	= V4L2_CTRL_TYPE_INTEGER,
-		.min	= 0,
-		.max	= (1 << 12) - 1,
-		.step	= 1,
-		.def	= 0x64,
-		.flags	= V4L2_CTRL_FLAG_SLIDER,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_CROSS_HAIR_COLUMN,
-		.name	= "Test Pattern: Cross Hairs Column",
-		.type	= V4L2_CTRL_TYPE_INTEGER,
-		.min	= 0,
-		.max	= (1 << 12) - 1,
-		.step	= 1,
-		.def	= 0x64,
-		.flags	= V4L2_CTRL_FLAG_SLIDER,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_ZPLATE_HOR_START,
-		.name	= "Test Pattern: Zplate Horizontal Start Pos",
-		.type	= V4L2_CTRL_TYPE_INTEGER,
-		.min	= 0,
-		.max	= (1 << 16) - 1,
-		.step	= 1,
-		.def	= 0x1e,
-		.flags	= V4L2_CTRL_FLAG_SLIDER,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_ZPLATE_HOR_SPEED,
-		.name	= "Test Pattern: Zplate Horizontal Speed",
-		.type	= V4L2_CTRL_TYPE_INTEGER,
-		.min	= 0,
-		.max	= (1 << 16) - 1,
-		.step	= 1,
-		.def	= 0,
-		.flags	= V4L2_CTRL_FLAG_SLIDER,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_ZPLATE_VER_START,
-		.name	= "Test Pattern: Zplate Vertical Start Pos",
-		.type	= V4L2_CTRL_TYPE_INTEGER,
-		.min	= 0,
-		.max	= (1 << 16) - 1,
-		.step	= 1,
-		.def	= 1,
-		.flags	= V4L2_CTRL_FLAG_SLIDER,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_ZPLATE_VER_SPEED,
-		.name	= "Test Pattern: Zplate Vertical Speed",
-		.type	= V4L2_CTRL_TYPE_INTEGER,
-		.min	= 0,
-		.max	= (1 << 16) - 1,
-		.step	= 1,
-		.def	= 0,
-		.flags	= V4L2_CTRL_FLAG_SLIDER,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_BOX_SIZE,
-		.name	= "Test Pattern: Box Size",
-		.type	= V4L2_CTRL_TYPE_INTEGER,
-		.min	= 0,
-		.max	= (1 << 12) - 1,
-		.step	= 1,
-		.def	= 0x32,
-		.flags	= V4L2_CTRL_FLAG_SLIDER,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_BOX_COLOR,
-		.name	= "Test Pattern: Box Color(RGB)",
-		.type	= V4L2_CTRL_TYPE_INTEGER,
-		.min	= 0,
-		.max	= (1 << 24) - 1,
-		.step	= 1,
-		.def	= 0,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_STUCK_PIXEL_THRESH,
-		.name	= "Test Pattern: Stuck Pixel threshold",
-		.type	= V4L2_CTRL_TYPE_INTEGER,
-		.min	= 0,
-		.max	= (1 << 16) - 1,
-		.step	= 1,
-		.def	= 0,
-		.flags	= V4L2_CTRL_FLAG_SLIDER,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_NOISE_GAIN,
-		.name	= "Test Pattern: Noise Gain",
-		.type	= V4L2_CTRL_TYPE_INTEGER,
-		.min	= 0,
-		.max	= (1 << 8) - 1,
-		.step	= 1,
-		.def	= 0,
-		.flags	= V4L2_CTRL_FLAG_SLIDER,
-	},
+	.open = xtpg_open,
+	.close = xtpg_close,
 };
 
 /* -----------------------------------------------------------------------------
@@ -683,85 +238,19 @@ static const struct media_entity_operations xtpg_media_ops = {
 };
 
 /* -----------------------------------------------------------------------------
- * Power Management
- */
-
-static int __maybe_unused xtpg_pm_suspend(struct device *dev)
-{
-	struct xtpg_device *xtpg = dev_get_drvdata(dev);
-
-	xvip_suspend(&xtpg->xvip);
-
-	return 0;
-}
-
-static int __maybe_unused xtpg_pm_resume(struct device *dev)
-{
-	struct xtpg_device *xtpg = dev_get_drvdata(dev);
-
-	xvip_resume(&xtpg->xvip);
-
-	return 0;
-}
-
-/* -----------------------------------------------------------------------------
  * Platform Device Driver
  */
 
 static int xtpg_parse_of(struct xtpg_device *xtpg)
 {
-	struct device *dev = xtpg->xvip.dev;
 	struct device_node *node = xtpg->xvip.dev->of_node;
-	struct device_node *ports;
-	struct device_node *port;
-	unsigned int nports = 0;
-	bool has_endpoint = false;
-
-	ports = of_get_child_by_name(node, "ports");
-	if (ports == NULL)
-		ports = node;
-
-	for_each_child_of_node(ports, port) {
-		const struct xvip_video_format *format;
-		struct device_node *endpoint;
-
-		if (!port->name || of_node_cmp(port->name, "port"))
-			continue;
-
-		format = xvip_of_get_format(port);
-		if (IS_ERR(format)) {
-			dev_err(dev, "invalid format in DT");
-			return PTR_ERR(format);
-		}
-
-		/* Get and check the format description */
-		if (!xtpg->vip_format) {
-			xtpg->vip_format = format;
-		} else if (xtpg->vip_format != format) {
-			dev_err(dev, "in/out format mismatch in DT");
-			return -EINVAL;
-		}
-
-		if (nports == 0) {
-			endpoint = of_get_next_child(port, NULL);
-			if (endpoint)
-				has_endpoint = true;
-			of_node_put(endpoint);
-		}
-
-		/* Count the number of ports. */
-		nports++;
-	}
 
-	if (nports != 1 && nports != 2) {
-		dev_err(dev, "invalid number of ports %u\n", nports);
+	xtpg->vip_format = xvip_of_get_format(node);
+	if (xtpg->vip_format == NULL) {
+		dev_err(xtpg->xvip.dev, "invalid format in DT");
 		return -EINVAL;
 	}
 
-	xtpg->npads = nports;
-	if (nports == 2 && has_endpoint)
-		xtpg->has_input = true;
-
 	return 0;
 }
 
@@ -769,7 +258,8 @@ static int xtpg_probe(struct platform_device *pdev)
 {
 	struct v4l2_subdev *subdev;
 	struct xtpg_device *xtpg;
-	u32 i, bayer_phase;
+	struct resource *res;
+	u32 version;
 	int ret;
 
 	xtpg = devm_kzalloc(&pdev->dev, sizeof(*xtpg), GFP_KERNEL);
@@ -782,49 +272,16 @@ static int xtpg_probe(struct platform_device *pdev)
 	if (ret < 0)
 		return ret;
 
-	ret = xvip_init_resources(&xtpg->xvip);
-	if (ret < 0)
-		return ret;
-
-	xtpg->vtmux_gpio = devm_gpiod_get_optional(&pdev->dev, "timing",
-						   GPIOD_OUT_HIGH);
-	if (IS_ERR(xtpg->vtmux_gpio)) {
-		ret = PTR_ERR(xtpg->vtmux_gpio);
-		goto error_resource;
-	}
-
-	xtpg->vtc = xvtc_of_get(pdev->dev.of_node);
-	if (IS_ERR(xtpg->vtc)) {
-		ret = PTR_ERR(xtpg->vtc);
-		goto error_resource;
-	}
-
-	/* Reset and initialize the core */
-	xvip_reset(&xtpg->xvip);
-
-	/* Initialize V4L2 subdevice and media entity. Pad numbers depend on the
-	 * number of pads.
-	 */
-	if (xtpg->npads == 2) {
-		xtpg->pads[0].flags = MEDIA_PAD_FL_SINK;
-		xtpg->pads[1].flags = MEDIA_PAD_FL_SOURCE;
-	} else {
-		xtpg->pads[0].flags = MEDIA_PAD_FL_SOURCE;
-	}
+	xtpg->format.code = xtpg->vip_format->code;
+	xtpg->format.width = XTPG_DEF_WIDTH;
+	xtpg->format.height = XTPG_DEF_HEIGHT;
+	xtpg->format.field = V4L2_FIELD_NONE;
+	xtpg->format.colorspace = V4L2_COLORSPACE_SRGB;
 
-	/* Initialize the default format */
-	xtpg->default_format.code = xtpg->vip_format->code;
-	xtpg->default_format.field = V4L2_FIELD_NONE;
-	xtpg->default_format.colorspace = V4L2_COLORSPACE_SRGB;
-	xvip_get_frame_size(&xtpg->xvip, &xtpg->default_format);
-
-	bayer_phase = xtpg_get_bayer_phase(xtpg->vip_format->code);
-	if (bayer_phase != XTPG_BAYER_PHASE_OFF)
-		xtpg->bayer = true;
-
-	xtpg->formats[0] = xtpg->default_format;
-	if (xtpg->npads == 2)
-		xtpg->formats[1] = xtpg->default_format;
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	xtpg->xvip.iomem = devm_ioremap_resource(&pdev->dev, res);
+	if (xtpg->xvip.iomem == NULL)
+		return -ENODEV;
 
 	/* Initialize V4L2 subdevice and media entity */
 	subdev = &xtpg->xvip.subdev;
@@ -834,46 +291,24 @@ static int xtpg_probe(struct platform_device *pdev)
 	strlcpy(subdev->name, dev_name(&pdev->dev), sizeof(subdev->name));
 	v4l2_set_subdevdata(subdev, xtpg);
 	subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
-	subdev->entity.ops = &xtpg_media_ops;
 
-	ret = media_entity_init(&subdev->entity, xtpg->npads, xtpg->pads, 0);
+	xtpg->pad.flags = MEDIA_PAD_FL_SOURCE;
+	subdev->entity.ops = &xtpg_media_ops;
+	ret = media_entity_init(&subdev->entity, 1, &xtpg->pad, 0);
 	if (ret < 0)
-		goto error;
-
-	v4l2_ctrl_handler_init(&xtpg->ctrl_handler, 3 + ARRAY_SIZE(xtpg_ctrls));
-
-	xtpg->vblank = v4l2_ctrl_new_std(&xtpg->ctrl_handler, &xtpg_ctrl_ops,
-					 V4L2_CID_VBLANK, XTPG_MIN_VBLANK,
-					 XTPG_MAX_VBLANK, 1, 100);
-	xtpg->hblank = v4l2_ctrl_new_std(&xtpg->ctrl_handler, &xtpg_ctrl_ops,
-					 V4L2_CID_HBLANK, XTPG_MIN_HBLANK,
-					 XTPG_MAX_HBLANK, 1, 100);
-	xtpg->pattern = v4l2_ctrl_new_std_menu_items(&xtpg->ctrl_handler,
-					&xtpg_ctrl_ops, V4L2_CID_TEST_PATTERN,
-					ARRAY_SIZE(xtpg_pattern_strings) - 1,
-					1, 9, xtpg_pattern_strings);
-
-	for (i = 0; i < ARRAY_SIZE(xtpg_ctrls); i++)
-		v4l2_ctrl_new_custom(&xtpg->ctrl_handler, &xtpg_ctrls[i], NULL);
-
-	if (xtpg->ctrl_handler.error) {
-		dev_err(&pdev->dev, "failed to add controls\n");
-		ret = xtpg->ctrl_handler.error;
-		goto error;
-	}
-	subdev->ctrl_handler = &xtpg->ctrl_handler;
-
-	xtpg_update_pattern_control(xtpg, true, true);
-
-	ret = v4l2_ctrl_handler_setup(&xtpg->ctrl_handler);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "failed to set controls\n");
-		goto error;
-	}
+		return ret;
 
 	platform_set_drvdata(pdev, xtpg);
 
-	xvip_print_version(&xtpg->xvip);
+	version = xvip_read(&xtpg->xvip, XVIP_CTRL_VERSION);
+
+	dev_info(&pdev->dev, "device found, version %u.%02x%x\n",
+		 ((version & XVIP_CTRL_VERSION_MAJOR_MASK) >>
+		  XVIP_CTRL_VERSION_MAJOR_SHIFT),
+		 ((version & XVIP_CTRL_VERSION_MINOR_MASK) >>
+		  XVIP_CTRL_VERSION_MINOR_SHIFT),
+		 ((version & XVIP_CTRL_VERSION_REVISION_MASK) >>
+		  XVIP_CTRL_VERSION_REVISION_SHIFT));
 
 	ret = v4l2_async_register_subdev(subdev);
 	if (ret < 0) {
@@ -884,11 +319,7 @@ static int xtpg_probe(struct platform_device *pdev)
 	return 0;
 
 error:
-	v4l2_ctrl_handler_free(&xtpg->ctrl_handler);
 	media_entity_cleanup(&subdev->entity);
-	xvtc_put(xtpg->vtc);
-error_resource:
-	xvip_cleanup_resources(&xtpg->xvip);
 	return ret;
 }
 
@@ -898,30 +329,25 @@ static int xtpg_remove(struct platform_device *pdev)
 	struct v4l2_subdev *subdev = &xtpg->xvip.subdev;
 
 	v4l2_async_unregister_subdev(subdev);
-	v4l2_ctrl_handler_free(&xtpg->ctrl_handler);
 	media_entity_cleanup(&subdev->entity);
 
-	xvip_cleanup_resources(&xtpg->xvip);
-
 	return 0;
 }
 
-static SIMPLE_DEV_PM_OPS(xtpg_pm_ops, xtpg_pm_suspend, xtpg_pm_resume);
-
 static const struct of_device_id xtpg_of_id_table[] = {
-	{ .compatible = "xlnx,v-tpg-5.0" },
+	{ .compatible = "xlnx,axi-tpg" },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, xtpg_of_id_table);
 
 static struct platform_driver xtpg_driver = {
 	.driver = {
-		.name		= "xilinx-tpg",
-		.pm		= &xtpg_pm_ops,
-		.of_match_table	= xtpg_of_id_table,
+		.owner = THIS_MODULE,
+		.name = "xilinx-axi-tpg",
+		.of_match_table = of_match_ptr(xtpg_of_id_table),
 	},
-	.probe			= xtpg_probe,
-	.remove			= xtpg_remove,
+	.probe = xtpg_probe,
+	.remove = xtpg_remove,
 };
 
 module_platform_driver(xtpg_driver);
diff --git a/drivers/media/platform/xilinx/xilinx-vip.c b/drivers/media/platform/xilinx/xilinx-vip.c
index 3112591..567a713 100644
--- a/drivers/media/platform/xilinx/xilinx-vip.c
+++ b/drivers/media/platform/xilinx/xilinx-vip.c
@@ -1,24 +1,18 @@
 /*
  * Xilinx Video IP Core
  *
- * Copyright (C) 2013-2015 Ideas on Board
- * Copyright (C) 2013-2015 Xilinx, Inc.
+ * Copyright (C) 2013 Ideas on Board SPRL
  *
- * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
- *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
 
-#include <linux/clk.h>
 #include <linux/export.h>
 #include <linux/kernel.h>
 #include <linux/of.h>
-#include <linux/platform_device.h>
-
-#include <dt-bindings/media/xilinx-vip.h>
 
 #include "xilinx-vip.h"
 
@@ -27,22 +21,14 @@
  */
 
 static const struct xvip_video_format xvip_video_formats[] = {
-	{ XVIP_VF_YUV_422, 8, NULL, MEDIA_BUS_FMT_UYVY8_1X16,
-	  2, V4L2_PIX_FMT_YUYV, "4:2:2, packed, YUYV" },
-	{ XVIP_VF_YUV_444, 8, NULL, MEDIA_BUS_FMT_VUY8_1X24,
-	  3, V4L2_PIX_FMT_YUV444, "4:4:4, packed, YUYV" },
-	{ XVIP_VF_RBG, 8, NULL, MEDIA_BUS_FMT_RBG888_1X24,
-	  3, 0, NULL },
-	{ XVIP_VF_MONO_SENSOR, 8, "mono", MEDIA_BUS_FMT_Y8_1X8,
-	  1, V4L2_PIX_FMT_GREY, "Greyscale 8-bit" },
-	{ XVIP_VF_MONO_SENSOR, 8, "rggb", MEDIA_BUS_FMT_SRGGB8_1X8,
-	  1, V4L2_PIX_FMT_SGRBG8, "Bayer 8-bit RGGB" },
-	{ XVIP_VF_MONO_SENSOR, 8, "grbg", MEDIA_BUS_FMT_SGRBG8_1X8,
-	  1, V4L2_PIX_FMT_SGRBG8, "Bayer 8-bit GRBG" },
-	{ XVIP_VF_MONO_SENSOR, 8, "gbrg", MEDIA_BUS_FMT_SGBRG8_1X8,
-	  1, V4L2_PIX_FMT_SGBRG8, "Bayer 8-bit GBRG" },
-	{ XVIP_VF_MONO_SENSOR, 8, "bggr", MEDIA_BUS_FMT_SBGGR8_1X8,
-	  1, V4L2_PIX_FMT_SBGGR8, "Bayer 8-bit BGGR" },
+	{ "rbg", 8, 3, V4L2_MBUS_FMT_RBG888_1X24, 0 },
+	{ "xrgb", 8, 4, V4L2_MBUS_FMT_RGB888_1X32_PADHI, V4L2_PIX_FMT_BGR32 },
+	{ "yuv422", 8, 2, V4L2_MBUS_FMT_UYVY8_1X16, V4L2_PIX_FMT_YUYV },
+	{ "yuv444", 8, 3, V4L2_MBUS_FMT_VUY8_1X24, V4L2_PIX_FMT_YUV444 },
+	{ "rggb", 8, 1, V4L2_MBUS_FMT_SRGGB8_1X8, V4L2_PIX_FMT_SGRBG8 },
+	{ "grbg", 8, 1, V4L2_MBUS_FMT_SGRBG8_1X8, V4L2_PIX_FMT_SGRBG8 },
+	{ "gbrg", 8, 1, V4L2_MBUS_FMT_SGBRG8_1X8, V4L2_PIX_FMT_SGBRG8 },
+	{ "bggr", 8, 1, V4L2_MBUS_FMT_SBGGR8_1X8, V4L2_PIX_FMT_SBGGR8 },
 };
 
 /**
@@ -50,8 +36,8 @@ static const struct xvip_video_format xvip_video_formats[] = {
  * @code: the format media bus code
  *
  * Return: a pointer to the format information structure corresponding to the
- * given V4L2 media bus format @code, or ERR_PTR if no corresponding format can
- * be found.
+ * given V4L2 media bus format @code, or %NULL if no corresponding format can be
+ * found.
  */
 const struct xvip_video_format *xvip_get_format_by_code(unsigned int code)
 {
@@ -64,7 +50,7 @@ const struct xvip_video_format *xvip_get_format_by_code(unsigned int code)
 			return format;
 	}
 
-	return ERR_PTR(-EINVAL);
+	return NULL;
 }
 EXPORT_SYMBOL_GPL(xvip_get_format_by_code);
 
@@ -73,8 +59,7 @@ EXPORT_SYMBOL_GPL(xvip_get_format_by_code);
  * @fourcc: the format 4CC
  *
  * Return: a pointer to the format information structure corresponding to the
- * given V4L2 format @fourcc, or ERR_PTR if no corresponding format can be
- * found.
+ * given V4L2 format @fourcc, or %NULL if no corresponding format can be found.
  */
 const struct xvip_video_format *xvip_get_format_by_fourcc(u32 fourcc)
 {
@@ -87,7 +72,7 @@ const struct xvip_video_format *xvip_get_format_by_fourcc(u32 fourcc)
 			return format;
 	}
 
-	return ERR_PTR(-EINVAL);
+	return NULL;
 }
 EXPORT_SYMBOL_GPL(xvip_get_format_by_fourcc);
 
@@ -95,229 +80,35 @@ EXPORT_SYMBOL_GPL(xvip_get_format_by_fourcc);
  * xvip_of_get_format - Parse a device tree node and return format information
  * @node: the device tree node
  *
- * Read the xlnx,video-format, xlnx,video-width and xlnx,cfa-pattern properties
- * from the device tree @node passed as an argument and return the corresponding
- * format information.
+ * Read the xlnx,axi-video-format and xlnx,axi-video-width properties from the
+ * device tree @node passed as an argument and return the corresponding format
+ * information.
  *
  * Return: a pointer to the format information structure corresponding to the
- * format name and width, or ERR_PTR if no corresponding format can be found.
+ * format name and width, or %NULL if no corresponding format can be found.
  */
 const struct xvip_video_format *xvip_of_get_format(struct device_node *node)
 {
-	const char *pattern = "mono";
-	unsigned int vf_code;
+	const char *name;
 	unsigned int i;
 	u32 width;
 	int ret;
 
-	ret = of_property_read_u32(node, "xlnx,video-format", &vf_code);
+	ret = of_property_read_string(node, "xlnx,axi-video-format", &name);
 	if (ret < 0)
-		return ERR_PTR(ret);
+		return NULL;
 
-	ret = of_property_read_u32(node, "xlnx,video-width", &width);
+	ret = of_property_read_u32(node, "xlnx,axi-video-width", &width);
 	if (ret < 0)
-		return ERR_PTR(ret);
-
-	if (vf_code == XVIP_VF_MONO_SENSOR)
-		of_property_read_string(node, "xlnx,cfa-pattern", &pattern);
+		return NULL;
 
 	for (i = 0; i < ARRAY_SIZE(xvip_video_formats); ++i) {
 		const struct xvip_video_format *format = &xvip_video_formats[i];
 
-		if (format->vf_code != vf_code || format->width != width)
-			continue;
-
-		if (vf_code == XVIP_VF_MONO_SENSOR &&
-		    strcmp(pattern, format->pattern))
-			continue;
-
-		return format;
+		if (strcmp(format->name, name) == 0 && format->width == width)
+			return format;
 	}
 
-	return ERR_PTR(-EINVAL);
+	return NULL;
 }
 EXPORT_SYMBOL_GPL(xvip_of_get_format);
-
-/**
- * xvip_set_format_size - Set the media bus frame format size
- * @format: V4L2 frame format on media bus
- * @fmt: media bus format
- *
- * Set the media bus frame format size. The width / height from the subdevice
- * format are set to the given media bus format. The new format size is stored
- * in @format. The width and height are clamped using default min / max values.
- */
-void xvip_set_format_size(struct v4l2_mbus_framefmt *format,
-			  const struct v4l2_subdev_format *fmt)
-{
-	format->width = clamp_t(unsigned int, fmt->format.width,
-				XVIP_MIN_WIDTH, XVIP_MAX_WIDTH);
-	format->height = clamp_t(unsigned int, fmt->format.height,
-			 XVIP_MIN_HEIGHT, XVIP_MAX_HEIGHT);
-}
-EXPORT_SYMBOL_GPL(xvip_set_format_size);
-
-/**
- * xvip_clr_or_set - Clear or set the register with a bitmask
- * @xvip: Xilinx Video IP device
- * @addr: address of register
- * @mask: bitmask to be set or cleared
- * @set: boolean flag indicating whether to set or clear
- *
- * Clear or set the register at address @addr with a bitmask @mask depending on
- * the boolean flag @set. When the flag @set is true, the bitmask is set in
- * the register, otherwise the bitmask is cleared from the register
- * when the flag @set is false.
- *
- * Fox eample, this function can be used to set a control with a boolean value
- * requested by users. If the caller knows whether to set or clear in the first
- * place, the caller should call xvip_clr() or xvip_set() directly instead of
- * using this function.
- */
-void xvip_clr_or_set(struct xvip_device *xvip, u32 addr, u32 mask, bool set)
-{
-	u32 reg;
-
-	reg = xvip_read(xvip, addr);
-	reg = set ? reg | mask : reg & ~mask;
-	xvip_write(xvip, addr, reg);
-}
-EXPORT_SYMBOL_GPL(xvip_clr_or_set);
-
-/**
- * xvip_clr_and_set - Clear and set the register with a bitmask
- * @xvip: Xilinx Video IP device
- * @addr: address of register
- * @clr: bitmask to be cleared
- * @set: bitmask to be set
- *
- * Clear a bit(s) of mask @clr in the register at address @addr, then set
- * a bit(s) of mask @set in the register after.
- */
-void xvip_clr_and_set(struct xvip_device *xvip, u32 addr, u32 clr, u32 set)
-{
-	u32 reg;
-
-	reg = xvip_read(xvip, addr);
-	reg &= ~clr;
-	reg |= set;
-	xvip_write(xvip, addr, reg);
-}
-EXPORT_SYMBOL_GPL(xvip_clr_and_set);
-
-int xvip_init_resources(struct xvip_device *xvip)
-{
-	struct platform_device *pdev = to_platform_device(xvip->dev);
-	struct resource *res;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	xvip->iomem = devm_ioremap_resource(xvip->dev, res);
-	if (IS_ERR(xvip->iomem))
-		return PTR_ERR(xvip->iomem);
-
-	xvip->clk = devm_clk_get(xvip->dev, NULL);
-	if (IS_ERR(xvip->clk))
-		return PTR_ERR(xvip->clk);
-
-	clk_prepare_enable(xvip->clk);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(xvip_init_resources);
-
-void xvip_cleanup_resources(struct xvip_device *xvip)
-{
-	clk_disable_unprepare(xvip->clk);
-}
-EXPORT_SYMBOL_GPL(xvip_cleanup_resources);
-
-/* -----------------------------------------------------------------------------
- * Subdev operations handlers
- */
-
-/**
- * xvip_enum_mbus_code - Enumerate the media format code
- * @subdev: V4L2 subdevice
- * @cfg: V4L2 subdev pad configuration
- * @code: returning media bus code
- *
- * Enumerate the media bus code of the subdevice. Return the corresponding
- * pad format code. This function only works for subdevices with fixed format
- * on all pads. Subdevices with multiple format should have their own
- * function to enumerate mbus codes.
- *
- * Return: 0 if the media bus code is found, or -EINVAL if the format index
- * is not valid.
- */
-int xvip_enum_mbus_code(struct v4l2_subdev *subdev,
-			struct v4l2_subdev_pad_config *cfg,
-			struct v4l2_subdev_mbus_code_enum *code)
-{
-	struct v4l2_mbus_framefmt *format;
-
-	/* Enumerating frame sizes based on the active configuration isn't
-	 * supported yet.
-	 */
-	if (code->which == V4L2_SUBDEV_FORMAT_ACTIVE)
-		return -EINVAL;
-
-	if (code->index)
-		return -EINVAL;
-
-	format = v4l2_subdev_get_try_format(subdev, cfg, code->pad);
-
-	code->code = format->code;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(xvip_enum_mbus_code);
-
-/**
- * xvip_enum_frame_size - Enumerate the media bus frame size
- * @subdev: V4L2 subdevice
- * @cfg: V4L2 subdev pad configuration
- * @fse: returning media bus frame size
- *
- * This function is a drop-in implementation of the subdev enum_frame_size pad
- * operation. It assumes that the subdevice has one sink pad and one source
- * pad, and that the format on the source pad is always identical to the
- * format on the sink pad. Entities with different requirements need to
- * implement their own enum_frame_size handlers.
- *
- * Return: 0 if the media bus frame size is found, or -EINVAL
- * if the index or the code is not valid.
- */
-int xvip_enum_frame_size(struct v4l2_subdev *subdev,
-			 struct v4l2_subdev_pad_config *cfg,
-			 struct v4l2_subdev_frame_size_enum *fse)
-{
-	struct v4l2_mbus_framefmt *format;
-
-	/* Enumerating frame sizes based on the active configuration isn't
-	 * supported yet.
-	 */
-	if (fse->which == V4L2_SUBDEV_FORMAT_ACTIVE)
-		return -EINVAL;
-
-	format = v4l2_subdev_get_try_format(subdev, cfg, fse->pad);
-
-	if (fse->index || fse->code != format->code)
-		return -EINVAL;
-
-	if (fse->pad == XVIP_PAD_SINK) {
-		fse->min_width = XVIP_MIN_WIDTH;
-		fse->max_width = XVIP_MAX_WIDTH;
-		fse->min_height = XVIP_MIN_HEIGHT;
-		fse->max_height = XVIP_MAX_HEIGHT;
-	} else {
-		/* The size on the source pad is fixed and always identical to
-		 * the size on the sink pad.
-		 */
-		fse->min_width = format->width;
-		fse->max_width = format->width;
-		fse->min_height = format->height;
-		fse->max_height = format->height;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(xvip_enum_frame_size);
diff --git a/drivers/media/platform/xilinx/xilinx-vip.h b/drivers/media/platform/xilinx/xilinx-vip.h
index 42fee20..48842ad 100644
--- a/drivers/media/platform/xilinx/xilinx-vip.h
+++ b/drivers/media/platform/xilinx/xilinx-vip.h
@@ -1,11 +1,9 @@
 /*
  * Xilinx Video IP Core
  *
- * Copyright (C) 2013-2015 Ideas on Board
- * Copyright (C) 2013-2015 Xilinx, Inc.
+ * Copyright (C) 2013 Ideas on Board SPRL
  *
- * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
- *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,24 +16,6 @@
 #include <linux/io.h>
 #include <media/v4l2-subdev.h>
 
-struct clk;
-
-/*
- * Minimum and maximum width and height common to most video IP cores. IP
- * cores with different requirements must define their own values.
- */
-#define XVIP_MIN_WIDTH			32
-#define XVIP_MAX_WIDTH			7680
-#define XVIP_MIN_HEIGHT			32
-#define XVIP_MAX_HEIGHT			7680
-
-/*
- * Pad IDs. IP cores with with multiple inputs or outputs should define
- * their own values.
- */
-#define XVIP_PAD_SINK			0
-#define XVIP_PAD_SOURCE			1
-
 /* Xilinx Video IP Control Registers */
 #define XVIP_CTRL_CONTROL			0x0000
 #define XVIP_CTRL_CONTROL_SW_ENABLE		(1 << 0)
@@ -68,72 +48,56 @@ struct clk;
 #define XVIP_CTRL_VERSION_INTERNAL_SHIFT	0
 
 /* Xilinx Video IP Timing Registers */
-#define XVIP_ACTIVE_SIZE			0x0020
-#define XVIP_ACTIVE_VSIZE_MASK			(0x7ff << 16)
-#define XVIP_ACTIVE_VSIZE_SHIFT			16
-#define XVIP_ACTIVE_HSIZE_MASK			(0x7ff << 0)
-#define XVIP_ACTIVE_HSIZE_SHIFT			0
-#define XVIP_ENCODING				0x0028
-#define XVIP_ENCODING_NBITS_8			(0 << 4)
-#define XVIP_ENCODING_NBITS_10			(1 << 4)
-#define XVIP_ENCODING_NBITS_12			(2 << 4)
-#define XVIP_ENCODING_NBITS_16			(3 << 4)
-#define XVIP_ENCODING_NBITS_MASK		(3 << 4)
-#define XVIP_ENCODING_NBITS_SHIFT		4
-#define XVIP_ENCODING_VIDEO_FORMAT_YUV422	(0 << 0)
-#define XVIP_ENCODING_VIDEO_FORMAT_YUV444	(1 << 0)
-#define XVIP_ENCODING_VIDEO_FORMAT_RGB		(2 << 0)
-#define XVIP_ENCODING_VIDEO_FORMAT_YUV420	(3 << 0)
-#define XVIP_ENCODING_VIDEO_FORMAT_MASK		(3 << 0)
-#define XVIP_ENCODING_VIDEO_FORMAT_SHIFT	0
+#define XVIP_TIMING_ACTIVE_SIZE			0x0020
+#define XVIP_TIMING_ACTIVE_VSIZE_MASK		(0x7ff << 16)
+#define XVIP_TIMING_ACTIVE_VSIZE_SHIFT		16
+#define XVIP_TIMING_ACTIVE_HSIZE_MASK		(0x7ff << 0)
+#define XVIP_TIMING_ACTIVE_HSIZE_SHIFT		0
+#define XVIP_TIMING_OUTPUT_ENCODING		0x0028
+#define XVIP_TIMING_OUTPUT_NBITS_8		(0 << 4)
+#define XVIP_TIMING_OUTPUT_NBITS_10		(1 << 4)
+#define XVIP_TIMING_OUTPUT_NBITS_12		(2 << 4)
+#define XVIP_TIMING_OUTPUT_NBITS_16		(3 << 4)
+#define XVIP_TIMING_OUTPUT_NBITS_MASK		(3 << 4)
+#define XVIP_TIMING_OUTPUT_NBITS_SHIFT		4
+#define XVIP_TIMING_VIDEO_FORMAT_YUV422		(0 << 0)
+#define XVIP_TIMING_VIDEO_FORMAT_YUV444		(1 << 0)
+#define XVIP_TIMING_VIDEO_FORMAT_RGB		(2 << 0)
+#define XVIP_TIMING_VIDEO_FORMAT_YUV420		(3 << 0)
+#define XVIP_TIMING_VIDEO_FORMAT_MASK		(3 << 0)
+#define XVIP_TIMING_VIDEO_FORMAT_SHIFT		0
 
 /**
  * struct xvip_device - Xilinx Video IP device structure
  * @subdev: V4L2 subdevice
  * @dev: (OF) device
  * @iomem: device I/O register space remapped to kernel virtual memory
- * @clk: video core clock
- * @saved_ctrl: saved control register for resume / suspend
  */
 struct xvip_device {
 	struct v4l2_subdev subdev;
 	struct device *dev;
 	void __iomem *iomem;
-	struct clk *clk;
-	u32 saved_ctrl;
 };
 
 /**
  * struct xvip_video_format - Xilinx Video IP video format description
- * @vf_code: AXI4 video format code
+ * @name: AXI4 format name
  * @width: AXI4 format width in bits per component
- * @pattern: CFA pattern for Mono/Sensor formats
- * @code: media bus format code
  * @bpp: bytes per pixel (when stored in memory)
+ * @code: media bus format code
  * @fourcc: V4L2 pixel format FCC identifier
- * @description: format description, suitable for userspace
  */
 struct xvip_video_format {
-	unsigned int vf_code;
+	const char *name;
 	unsigned int width;
-	const char *pattern;
-	unsigned int code;
 	unsigned int bpp;
+	unsigned int code;
 	u32 fourcc;
-	const char *description;
 };
 
 const struct xvip_video_format *xvip_get_format_by_code(unsigned int code);
 const struct xvip_video_format *xvip_get_format_by_fourcc(u32 fourcc);
 const struct xvip_video_format *xvip_of_get_format(struct device_node *node);
-void xvip_set_format_size(struct v4l2_mbus_framefmt *format,
-			  const struct v4l2_subdev_format *fmt);
-int xvip_enum_mbus_code(struct v4l2_subdev *subdev,
-			struct v4l2_subdev_pad_config *cfg,
-			struct v4l2_subdev_mbus_code_enum *code);
-int xvip_enum_frame_size(struct v4l2_subdev *subdev,
-			 struct v4l2_subdev_pad_config *cfg,
-			 struct v4l2_subdev_frame_size_enum *fse);
 
 static inline u32 xvip_read(struct xvip_device *xvip, u32 addr)
 {
@@ -145,94 +109,4 @@ static inline void xvip_write(struct xvip_device *xvip, u32 addr, u32 value)
 	iowrite32(value, xvip->iomem + addr);
 }
 
-static inline void xvip_clr(struct xvip_device *xvip, u32 addr, u32 clr)
-{
-	xvip_write(xvip, addr, xvip_read(xvip, addr) & ~clr);
-}
-
-static inline void xvip_set(struct xvip_device *xvip, u32 addr, u32 set)
-{
-	xvip_write(xvip, addr, xvip_read(xvip, addr) | set);
-}
-
-void xvip_clr_or_set(struct xvip_device *xvip, u32 addr, u32 mask, bool set);
-void xvip_clr_and_set(struct xvip_device *xvip, u32 addr, u32 clr, u32 set);
-
-int xvip_init_resources(struct xvip_device *xvip);
-void xvip_cleanup_resources(struct xvip_device *xvip);
-
-static inline void xvip_reset(struct xvip_device *xvip)
-{
-	xvip_write(xvip, XVIP_CTRL_CONTROL, XVIP_CTRL_CONTROL_SW_RESET);
-}
-
-static inline void xvip_start(struct xvip_device *xvip)
-{
-	xvip_set(xvip, XVIP_CTRL_CONTROL,
-		 XVIP_CTRL_CONTROL_SW_ENABLE | XVIP_CTRL_CONTROL_REG_UPDATE);
-}
-
-static inline void xvip_stop(struct xvip_device *xvip)
-{
-	xvip_clr(xvip, XVIP_CTRL_CONTROL, XVIP_CTRL_CONTROL_SW_ENABLE);
-}
-
-static inline void xvip_resume(struct xvip_device *xvip)
-{
-	xvip_write(xvip, XVIP_CTRL_CONTROL,
-		   xvip->saved_ctrl | XVIP_CTRL_CONTROL_SW_ENABLE);
-}
-
-static inline void xvip_suspend(struct xvip_device *xvip)
-{
-	xvip->saved_ctrl = xvip_read(xvip, XVIP_CTRL_CONTROL);
-	xvip_write(xvip, XVIP_CTRL_CONTROL,
-		   xvip->saved_ctrl & ~XVIP_CTRL_CONTROL_SW_ENABLE);
-}
-
-static inline void xvip_set_frame_size(struct xvip_device *xvip,
-				       const struct v4l2_mbus_framefmt *format)
-{
-	xvip_write(xvip, XVIP_ACTIVE_SIZE,
-		   (format->height << XVIP_ACTIVE_VSIZE_SHIFT) |
-		   (format->width << XVIP_ACTIVE_HSIZE_SHIFT));
-}
-
-static inline void xvip_get_frame_size(struct xvip_device *xvip,
-				       struct v4l2_mbus_framefmt *format)
-{
-	u32 reg;
-
-	reg = xvip_read(xvip, XVIP_ACTIVE_SIZE);
-	format->width = (reg & XVIP_ACTIVE_HSIZE_MASK) >>
-			XVIP_ACTIVE_HSIZE_SHIFT;
-	format->height = (reg & XVIP_ACTIVE_VSIZE_MASK) >>
-			 XVIP_ACTIVE_VSIZE_SHIFT;
-}
-
-static inline void xvip_enable_reg_update(struct xvip_device *xvip)
-{
-	xvip_set(xvip, XVIP_CTRL_CONTROL, XVIP_CTRL_CONTROL_REG_UPDATE);
-}
-
-static inline void xvip_disable_reg_update(struct xvip_device *xvip)
-{
-	xvip_clr(xvip, XVIP_CTRL_CONTROL, XVIP_CTRL_CONTROL_REG_UPDATE);
-}
-
-static inline void xvip_print_version(struct xvip_device *xvip)
-{
-	u32 version;
-
-	version = xvip_read(xvip, XVIP_CTRL_VERSION);
-
-	dev_info(xvip->dev, "device found, version %u.%02x%x\n",
-		 ((version & XVIP_CTRL_VERSION_MAJOR_MASK) >>
-		  XVIP_CTRL_VERSION_MAJOR_SHIFT),
-		 ((version & XVIP_CTRL_VERSION_MINOR_MASK) >>
-		  XVIP_CTRL_VERSION_MINOR_SHIFT),
-		 ((version & XVIP_CTRL_VERSION_REVISION_MASK) >>
-		  XVIP_CTRL_VERSION_REVISION_SHIFT));
-}
-
 #endif /* __XILINX_VIP_H__ */
diff --git a/drivers/media/platform/xilinx/xilinx-vipp.c b/drivers/media/platform/xilinx/xilinx-vipp.c
index 7b7cb9c..ee0ab90 100644
--- a/drivers/media/platform/xilinx/xilinx-vipp.c
+++ b/drivers/media/platform/xilinx/xilinx-vipp.c
@@ -1,11 +1,9 @@
 /*
- * Xilinx Video IP Composite Device
+ * Xilinx Video IP Pipeline
  *
- * Copyright (C) 2013-2015 Ideas on Board
- * Copyright (C) 2013-2015 Xilinx, Inc.
+ * Copyright (C) 2013 Ideas on Board SPRL
  *
- * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
- *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -15,7 +13,6 @@
 #include <linux/list.h>
 #include <linux/module.h>
 #include <linux/of.h>
-#include <linux/of_graph.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 
@@ -31,14 +28,14 @@
 #define XVIPP_DMA_MM2S				1
 
 /**
- * struct xvip_graph_entity - Entity in the video graph
- * @list: list entry in a graph entities list
+ * struct xvip_pipeline_entity - Entity in a video pipeline
+ * @list: list entry in a pipeline entities list
  * @node: the entity's DT node
- * @entity: media entity, from the corresponding V4L2 subdev
+ * @entity: media entity, from the corresponding V4L2 subdev or video device
  * @asd: subdev asynchronous registration information
- * @subdev: V4L2 subdev
+ * @subdev: V4L2 subdev (valid for all entities by DMA channels)
  */
-struct xvip_graph_entity {
+struct xvip_pipeline_entity {
 	struct list_head list;
 	struct device_node *node;
 	struct media_entity *entity;
@@ -48,16 +45,108 @@ struct xvip_graph_entity {
 };
 
 /* -----------------------------------------------------------------------------
- * Graph Management
+ * Pipeline Stream Management
  */
 
-static struct xvip_graph_entity *
-xvip_graph_find_entity(struct xvip_composite_device *xdev,
-		       const struct device_node *node)
+/**
+ * xvip_pipeline_start_stop - Start ot stop streaming on a pipeline
+ * @xvipp: Xilinx Video Pipeline
+ * @start: Start (when true) or stop (when false) the pipeline
+ *
+ * Walk the entities chain starting at the pipeline output video node and start
+ * or stop all of them.
+ *
+ * Return: 0 if successful, or the return value of the failed video::s_stream
+ * operation otherwise.
+ */
+static int xvip_pipeline_start_stop(struct xvip_pipeline *xvipp, bool start)
+{
+	struct media_entity *entity;
+	struct media_pad *pad;
+	struct v4l2_subdev *subdev;
+	int ret;
+
+	entity = &xvipp->dma[XVIPP_DMA_S2MM].video.entity;
+	while (1) {
+		pad = &entity->pads[0];
+		if (!(pad->flags & MEDIA_PAD_FL_SINK))
+			break;
+
+		pad = media_entity_remote_pad(pad);
+		if (pad == NULL ||
+		    media_entity_type(pad->entity) != MEDIA_ENT_T_V4L2_SUBDEV)
+			break;
+
+		entity = pad->entity;
+		subdev = media_entity_to_v4l2_subdev(entity);
+
+		ret = v4l2_subdev_call(subdev, video, s_stream, start);
+		if (start && ret < 0 && ret != -ENOIOCTLCMD)
+			return ret;
+	}
+
+	return 0;
+}
+
+/**
+ * xvip_pipeline_set_stream - Enable/disable streaming on a pipeline
+ * @xvipp: Xilinx Video Pipeline
+ * @on: Turn the stream on when true or off when false
+ *
+ * The pipeline is shared between all DMA engines connect at its input and
+ * output. While the stream state of DMA engines can be controlled
+ * independently, pipelines have a shared stream state that enable or disable
+ * all entities in the pipeline. For this reason the pipeline uses a streaming
+ * counter that tracks the number of DMA engines that have requested the stream
+ * to be enabled.
+ *
+ * When called with the @on argument set to true, this function will increment
+ * the pipeline streaming count. If the streaming count reaches the number of
+ * DMA engines in the pipeline it will enable all entities that belong to the
+ * pipeline.
+ *
+ * Similarly, when called with the @on argument set to false, this function will
+ * decrement the pipeline streaming count and disable all entities in the
+ * pipeline when the streaming count reaches zero.
+ *
+ * Return: 0 if successful, or the return value of the failed video::s_stream
+ * operation otherwise. Stopping the pipeline never fails. The pipeline state is
+ * not updated when the operation fails.
+ */
+int xvip_pipeline_set_stream(struct xvip_pipeline *xvipp, bool on)
 {
-	struct xvip_graph_entity *entity;
+	int ret = 0;
+
+	mutex_lock(&xvipp->lock);
+
+	if (on) {
+		if (xvipp->stream_count == xvipp->num_dmas - 1) {
+			ret = xvip_pipeline_start_stop(xvipp, true);
+			if (ret < 0)
+				goto done;
+		}
+		xvipp->stream_count++;
+	} else {
+		if (--xvipp->stream_count == 0)
+			xvip_pipeline_start_stop(xvipp, false);
+	}
+
+done:
+	mutex_unlock(&xvipp->lock);
+	return ret;
+}
 
-	list_for_each_entry(entity, &xdev->entities, list) {
+/* -----------------------------------------------------------------------------
+ * Pipeline Management
+ */
+
+static struct xvip_pipeline_entity *
+xvipp_pipeline_find_entity(struct xvip_pipeline *xvipp,
+			   const struct device_node *node)
+{
+	struct xvip_pipeline_entity *entity;
+
+	list_for_each_entry(entity, &xvipp->entities, list) {
 		if (entity->node == node)
 			return entity;
 	}
@@ -65,36 +154,36 @@ xvip_graph_find_entity(struct xvip_composite_device *xdev,
 	return NULL;
 }
 
-static int xvip_graph_build_one(struct xvip_composite_device *xdev,
-				struct xvip_graph_entity *entity)
+static int xvipp_pipeline_build_one(struct xvip_pipeline *xvipp,
+				    struct xvip_pipeline_entity *entity)
 {
-	u32 link_flags = MEDIA_LNK_FL_ENABLED;
+	u32 link_flags = MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED;
 	struct media_entity *local = entity->entity;
 	struct media_entity *remote;
 	struct media_pad *local_pad;
 	struct media_pad *remote_pad;
-	struct xvip_graph_entity *ent;
+	struct xvip_pipeline_entity *ent;
 	struct v4l2_of_link link;
 	struct device_node *ep = NULL;
 	struct device_node *next;
 	int ret = 0;
 
-	dev_dbg(xdev->dev, "creating links for entity %s\n", local->name);
+	dev_dbg(xvipp->dev, "creating links for entity %s\n", local->name);
 
 	while (1) {
 		/* Get the next endpoint and parse its link. */
-		next = of_graph_get_next_endpoint(entity->node, ep);
+		next = v4l2_of_get_next_endpoint(entity->node, ep);
 		if (next == NULL)
 			break;
 
 		of_node_put(ep);
 		ep = next;
 
-		dev_dbg(xdev->dev, "processing endpoint %s\n", ep->full_name);
+		dev_dbg(xvipp->dev, "processing endpoint %s\n", ep->full_name);
 
 		ret = v4l2_of_parse_link(ep, &link);
 		if (ret < 0) {
-			dev_err(xdev->dev, "failed to parse link for %s\n",
+			dev_err(xvipp->dev, "failed to parse link for %s\n",
 				ep->full_name);
 			continue;
 		}
@@ -103,7 +192,7 @@ static int xvip_graph_build_one(struct xvip_composite_device *xdev,
 		 * the link.
 		 */
 		if (link.local_port >= local->num_pads) {
-			dev_err(xdev->dev, "invalid port number %u on %s\n",
+			dev_err(xvipp->dev, "invalid port number %u on %s\n",
 				link.local_port, link.local_node->full_name);
 			v4l2_of_put_link(&link);
 			ret = -EINVAL;
@@ -113,24 +202,16 @@ static int xvip_graph_build_one(struct xvip_composite_device *xdev,
 		local_pad = &local->pads[link.local_port];
 
 		if (local_pad->flags & MEDIA_PAD_FL_SINK) {
-			dev_dbg(xdev->dev, "skipping sink port %s:%u\n",
-				link.local_node->full_name, link.local_port);
-			v4l2_of_put_link(&link);
-			continue;
-		}
-
-		/* Skip DMA engines, they will be processed separately. */
-		if (link.remote_node == xdev->dev->of_node) {
-			dev_dbg(xdev->dev, "skipping DMA port %s:%u\n",
+			dev_dbg(xvipp->dev, "skipping sink port %s:%u\n",
 				link.local_node->full_name, link.local_port);
 			v4l2_of_put_link(&link);
 			continue;
 		}
 
 		/* Find the remote entity. */
-		ent = xvip_graph_find_entity(xdev, link.remote_node);
+		ent = xvipp_pipeline_find_entity(xvipp, link.remote_node);
 		if (ent == NULL) {
-			dev_err(xdev->dev, "no entity found for %s\n",
+			dev_err(xvipp->dev, "no entity found for %s\n",
 				link.remote_node->full_name);
 			v4l2_of_put_link(&link);
 			ret = -ENODEV;
@@ -140,7 +221,7 @@ static int xvip_graph_build_one(struct xvip_composite_device *xdev,
 		remote = ent->entity;
 
 		if (link.remote_port >= remote->num_pads) {
-			dev_err(xdev->dev, "invalid port number %u on %s\n",
+			dev_err(xvipp->dev, "invalid port number %u on %s\n",
 				link.remote_port, link.remote_node->full_name);
 			v4l2_of_put_link(&link);
 			ret = -EINVAL;
@@ -152,7 +233,7 @@ static int xvip_graph_build_one(struct xvip_composite_device *xdev,
 		v4l2_of_put_link(&link);
 
 		/* Create the media link. */
-		dev_dbg(xdev->dev, "creating %s:%u -> %s:%u link\n",
+		dev_dbg(xvipp->dev, "creating %s:%u -> %s:%u link\n",
 			local->name, local_pad->index,
 			remote->name, remote_pad->index);
 
@@ -160,7 +241,7 @@ static int xvip_graph_build_one(struct xvip_composite_device *xdev,
 					       remote, remote_pad->index,
 					       link_flags);
 		if (ret < 0) {
-			dev_err(xdev->dev,
+			dev_err(xvipp->dev,
 				"failed to create %s:%u -> %s:%u link\n",
 				local->name, local_pad->index,
 				remote->name, remote_pad->index);
@@ -172,214 +253,94 @@ static int xvip_graph_build_one(struct xvip_composite_device *xdev,
 	return ret;
 }
 
-static struct xvip_dma *
-xvip_graph_find_dma(struct xvip_composite_device *xdev, unsigned int port)
-{
-	struct xvip_dma *dma;
-
-	list_for_each_entry(dma, &xdev->dmas, list) {
-		if (dma->port == port)
-			return dma;
-	}
-
-	return NULL;
-}
-
-static int xvip_graph_build_dma(struct xvip_composite_device *xdev)
-{
-	u32 link_flags = MEDIA_LNK_FL_ENABLED;
-	struct device_node *node = xdev->dev->of_node;
-	struct media_entity *source;
-	struct media_entity *sink;
-	struct media_pad *source_pad;
-	struct media_pad *sink_pad;
-	struct xvip_graph_entity *ent;
-	struct v4l2_of_link link;
-	struct device_node *ep = NULL;
-	struct device_node *next;
-	struct xvip_dma *dma;
-	int ret = 0;
-
-	dev_dbg(xdev->dev, "creating links for DMA engines\n");
-
-	while (1) {
-		/* Get the next endpoint and parse its link. */
-		next = of_graph_get_next_endpoint(node, ep);
-		if (next == NULL)
-			break;
-
-		of_node_put(ep);
-		ep = next;
-
-		dev_dbg(xdev->dev, "processing endpoint %s\n", ep->full_name);
-
-		ret = v4l2_of_parse_link(ep, &link);
-		if (ret < 0) {
-			dev_err(xdev->dev, "failed to parse link for %s\n",
-				ep->full_name);
-			continue;
-		}
-
-		/* Find the DMA engine. */
-		dma = xvip_graph_find_dma(xdev, link.local_port);
-		if (dma == NULL) {
-			dev_err(xdev->dev, "no DMA engine found for port %u\n",
-				link.local_port);
-			v4l2_of_put_link(&link);
-			ret = -EINVAL;
-			break;
-		}
-
-		dev_dbg(xdev->dev, "creating link for DMA engine %s\n",
-			dma->video.name);
-
-		/* Find the remote entity. */
-		ent = xvip_graph_find_entity(xdev, link.remote_node);
-		if (ent == NULL) {
-			dev_err(xdev->dev, "no entity found for %s\n",
-				link.remote_node->full_name);
-			v4l2_of_put_link(&link);
-			ret = -ENODEV;
-			break;
-		}
-
-		if (link.remote_port >= ent->entity->num_pads) {
-			dev_err(xdev->dev, "invalid port number %u on %s\n",
-				link.remote_port, link.remote_node->full_name);
-			v4l2_of_put_link(&link);
-			ret = -EINVAL;
-			break;
-		}
-
-		if (dma->pad.flags & MEDIA_PAD_FL_SOURCE) {
-			source = &dma->video.entity;
-			source_pad = &dma->pad;
-			sink = ent->entity;
-			sink_pad = &sink->pads[link.remote_port];
-		} else {
-			source = ent->entity;
-			source_pad = &source->pads[link.remote_port];
-			sink = &dma->video.entity;
-			sink_pad = &dma->pad;
-		}
-
-		v4l2_of_put_link(&link);
-
-		/* Create the media link. */
-		dev_dbg(xdev->dev, "creating %s:%u -> %s:%u link\n",
-			source->name, source_pad->index,
-			sink->name, sink_pad->index);
-
-		ret = media_entity_create_link(source, source_pad->index,
-					       sink, sink_pad->index,
-					       link_flags);
-		if (ret < 0) {
-			dev_err(xdev->dev,
-				"failed to create %s:%u -> %s:%u link\n",
-				source->name, source_pad->index,
-				sink->name, sink_pad->index);
-			break;
-		}
-	}
-
-	of_node_put(ep);
-	return ret;
-}
-
-static int xvip_graph_notify_complete(struct v4l2_async_notifier *notifier)
+static int xvipp_pipeline_notify_complete(struct v4l2_async_notifier *notifier)
 {
-	struct xvip_composite_device *xdev =
-		container_of(notifier, struct xvip_composite_device, notifier);
-	struct xvip_graph_entity *entity;
+	struct xvip_pipeline *xvipp =
+		container_of(notifier, struct xvip_pipeline, notifier);
+	struct xvip_pipeline_entity *entity;
 	int ret;
 
-	dev_dbg(xdev->dev, "notify complete, all subdevs registered\n");
+	dev_dbg(xvipp->dev, "notify complete, all subdevs registered\n");
 
 	/* Create links for every entity. */
-	list_for_each_entry(entity, &xdev->entities, list) {
-		ret = xvip_graph_build_one(xdev, entity);
+	list_for_each_entry(entity, &xvipp->entities, list) {
+		ret = xvipp_pipeline_build_one(xvipp, entity);
 		if (ret < 0)
 			return ret;
 	}
 
-	/* Create links for DMA channels. */
-	ret = xvip_graph_build_dma(xdev);
+	ret = v4l2_device_register_subdev_nodes(&xvipp->v4l2_dev);
 	if (ret < 0)
-		return ret;
-
-	ret = v4l2_device_register_subdev_nodes(&xdev->v4l2_dev);
-	if (ret < 0)
-		dev_err(xdev->dev, "failed to register subdev nodes\n");
+		dev_err(xvipp->dev, "failed to register subdev nodes\n");
 
 	return ret;
 }
 
-static int xvip_graph_notify_bound(struct v4l2_async_notifier *notifier,
-				   struct v4l2_subdev *subdev,
-				   struct v4l2_async_subdev *asd)
+static int xvipp_pipeline_notify_bound(struct v4l2_async_notifier *notifier,
+				       struct v4l2_subdev *subdev,
+				       struct v4l2_async_subdev *asd)
 {
-	struct xvip_composite_device *xdev =
-		container_of(notifier, struct xvip_composite_device, notifier);
-	struct xvip_graph_entity *entity;
+	struct xvip_pipeline *xvipp =
+		container_of(notifier, struct xvip_pipeline, notifier);
+	struct xvip_pipeline_entity *entity;
 
 	/* Locate the entity corresponding to the bound subdev and store the
 	 * subdev pointer.
 	 */
-	list_for_each_entry(entity, &xdev->entities, list) {
+	list_for_each_entry(entity, &xvipp->entities, list) {
 		if (entity->node != subdev->dev->of_node)
 			continue;
 
 		if (entity->subdev) {
-			dev_err(xdev->dev, "duplicate subdev for node %s\n",
+			dev_err(xvipp->dev, "duplicate subdev for node %s\n",
 				entity->node->full_name);
 			return -EINVAL;
 		}
 
-		dev_dbg(xdev->dev, "subdev %s bound\n", subdev->name);
+		dev_dbg(xvipp->dev, "subdev %s bound\n", subdev->name);
 		entity->entity = &subdev->entity;
 		entity->subdev = subdev;
 		return 0;
 	}
 
-	dev_err(xdev->dev, "no entity for subdev %s\n", subdev->name);
+	dev_err(xvipp->dev, "no entity for subdev %s\n", subdev->name);
 	return -EINVAL;
 }
 
-static int xvip_graph_parse_one(struct xvip_composite_device *xdev,
-				struct device_node *node)
+static int xvipp_pipeline_parse_one(struct xvip_pipeline *xvipp,
+				    struct device_node *node)
 {
-	struct xvip_graph_entity *entity;
+	struct xvip_pipeline_entity *entity;
 	struct device_node *remote;
 	struct device_node *ep = NULL;
 	struct device_node *next;
 	int ret = 0;
 
-	dev_dbg(xdev->dev, "parsing node %s\n", node->full_name);
+	dev_dbg(xvipp->dev, "parsing node %s\n", node->full_name);
 
 	while (1) {
-		next = of_graph_get_next_endpoint(node, ep);
+		next = v4l2_of_get_next_endpoint(node, ep);
 		if (next == NULL)
 			break;
 
 		of_node_put(ep);
 		ep = next;
 
-		dev_dbg(xdev->dev, "handling endpoint %s\n", ep->full_name);
+		dev_dbg(xvipp->dev, "handling endpoint %s\n", ep->full_name);
 
-		remote = of_graph_get_remote_port_parent(ep);
+		remote = v4l2_of_get_remote_port_parent(ep);
 		if (remote == NULL) {
 			ret = -EINVAL;
 			break;
 		}
 
 		/* Skip entities that we have already processed. */
-		if (remote == xdev->dev->of_node ||
-		    xvip_graph_find_entity(xdev, remote)) {
+		if (xvipp_pipeline_find_entity(xvipp, remote)) {
 			of_node_put(remote);
 			continue;
 		}
 
-		entity = devm_kzalloc(xdev->dev, sizeof(*entity), GFP_KERNEL);
+		entity = devm_kzalloc(xvipp->dev, sizeof(*entity), GFP_KERNEL);
 		if (entity == NULL) {
 			of_node_put(remote);
 			ret = -ENOMEM;
@@ -389,31 +350,22 @@ static int xvip_graph_parse_one(struct xvip_composite_device *xdev,
 		entity->node = remote;
 		entity->asd.match_type = V4L2_ASYNC_MATCH_OF;
 		entity->asd.match.of.node = remote;
-		list_add_tail(&entity->list, &xdev->entities);
-		xdev->num_subdevs++;
+		list_add_tail(&entity->list, &xvipp->entities);
+		xvipp->num_subdevs++;
 	}
 
 	of_node_put(ep);
 	return ret;
 }
 
-static int xvip_graph_parse(struct xvip_composite_device *xdev)
+static int xvipp_pipeline_parse(struct xvip_pipeline *xvipp)
 {
-	struct xvip_graph_entity *entity;
+	struct xvip_pipeline_entity *entity;
 	int ret;
 
-	/*
-	 * Walk the links to parse the full graph. Start by parsing the
-	 * composite node and then parse entities in turn. The list_for_each
-	 * loop will handle entities added at the end of the list while walking
-	 * the links.
-	 */
-	ret = xvip_graph_parse_one(xdev, xdev->dev->of_node);
-	if (ret < 0)
-		return 0;
-
-	list_for_each_entry(entity, &xdev->entities, list) {
-		ret = xvip_graph_parse_one(xdev, entity->node);
+	/* Walk the links to parse the full pipeline. */
+	list_for_each_entry(entity, &xvipp->entities, list) {
+		ret = xvipp_pipeline_parse_one(xvipp, entity->node);
 		if (ret < 0)
 			break;
 	}
@@ -421,118 +373,110 @@ static int xvip_graph_parse(struct xvip_composite_device *xdev)
 	return ret;
 }
 
-static int xvip_graph_dma_init_one(struct xvip_composite_device *xdev,
-				   struct device_node *node)
+static int
+xvipp_pipeline_dma_init_one(struct xvip_pipeline *xvipp, struct xvip_dma *dma,
+			    struct device_node *node, enum v4l2_buf_type type)
 {
-	struct xvip_dma *dma;
-	enum v4l2_buf_type type;
-	const char *direction;
-	unsigned int index;
+	struct xvip_pipeline_entity *entity;
 	int ret;
 
-	ret = of_property_read_string(node, "direction", &direction);
-	if (ret < 0)
-		return ret;
-
-	if (strcmp(direction, "input") == 0)
-		type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-	else if (strcmp(direction, "output") == 0)
-		type = V4L2_BUF_TYPE_VIDEO_OUTPUT;
-	else
-		return -EINVAL;
-
-	of_property_read_u32(node, "reg", &index);
-
-	dma = devm_kzalloc(xdev->dev, sizeof(*dma), GFP_KERNEL);
-	if (dma == NULL)
-		return -ENOMEM;
-
-	ret = xvip_dma_init(xdev, dma, type, index);
+	ret = xvip_dma_init(xvipp, dma, type);
 	if (ret < 0) {
-		dev_err(xdev->dev, "%s initialization failed\n",
+		dev_err(xvipp->dev, "%s initialization failed\n",
 			node->full_name);
 		return ret;
 	}
 
-	list_add_tail(&dma->list, &xdev->dmas);
+	entity = devm_kzalloc(xvipp->dev, sizeof(*entity), GFP_KERNEL);
+	if (entity == NULL)
+		return -ENOMEM;
 
-	xdev->v4l2_caps |= type == V4L2_BUF_TYPE_VIDEO_CAPTURE
-			 ? V4L2_CAP_VIDEO_CAPTURE : V4L2_CAP_VIDEO_OUTPUT;
+	entity->node = of_node_get(node);
+	entity->entity = &dma->video.entity;
+
+	list_add_tail(&entity->list, &xvipp->entities);
+	xvipp->num_dmas++;
 
 	return 0;
 }
 
-static int xvip_graph_dma_init(struct xvip_composite_device *xdev)
+static int xvipp_pipeline_dma_init(struct xvip_pipeline *xvipp)
 {
-	struct device_node *ports;
-	struct device_node *port;
+	struct device_node *vdma;
 	int ret;
 
-	ports = of_get_child_by_name(xdev->dev->of_node, "ports");
-	if (ports == NULL) {
-		dev_err(xdev->dev, "ports node not present\n");
+	/* The s2mm vdma channel at the pipeline output is mandatory. */
+	vdma = of_get_child_by_name(xvipp->dev->of_node, "vdma-s2mm");
+	if (vdma == NULL) {
+		dev_err(xvipp->dev, "vdma-s2mm node not present\n");
 		return -EINVAL;
 	}
 
-	for_each_child_of_node(ports, port) {
-		ret = xvip_graph_dma_init_one(xdev, port);
-		if (ret < 0)
-			return ret;
-	}
+	ret = xvipp_pipeline_dma_init_one(xvipp, &xvipp->dma[XVIPP_DMA_S2MM],
+					  vdma, V4L2_BUF_TYPE_VIDEO_CAPTURE);
+	of_node_put(vdma);
 
-	return 0;
+	if (ret < 0)
+		return ret;
+
+	/* The mm2s vdma channel at the pipeline input is optional. */
+	vdma = of_get_child_by_name(xvipp->dev->of_node, "vdma-mm2s");
+	if (vdma == NULL)
+		return 0;
+
+	ret = xvipp_pipeline_dma_init_one(xvipp, &xvipp->dma[XVIPP_DMA_MM2S],
+					  vdma, V4L2_BUF_TYPE_VIDEO_OUTPUT);
+	of_node_put(vdma);
+
+	return ret;
 }
 
-static void xvip_graph_cleanup(struct xvip_composite_device *xdev)
+static void xvipp_pipeline_cleanup(struct xvip_pipeline *xvipp)
 {
-	struct xvip_graph_entity *entityp;
-	struct xvip_graph_entity *entity;
-	struct xvip_dma *dmap;
-	struct xvip_dma *dma;
+	struct xvip_pipeline_entity *entity;
+	struct xvip_pipeline_entity *prev;
 
-	v4l2_async_notifier_unregister(&xdev->notifier);
+	v4l2_async_notifier_unregister(&xvipp->notifier);
 
-	list_for_each_entry_safe(entity, entityp, &xdev->entities, list) {
+	list_for_each_entry_safe(entity, prev, &xvipp->entities, list) {
 		of_node_put(entity->node);
 		list_del(&entity->list);
 	}
 
-	list_for_each_entry_safe(dma, dmap, &xdev->dmas, list) {
-		xvip_dma_cleanup(dma);
-		list_del(&dma->list);
-	}
+	xvip_dma_cleanup(&xvipp->dma[XVIPP_DMA_S2MM]);
+	xvip_dma_cleanup(&xvipp->dma[XVIPP_DMA_MM2S]);
 }
 
-static int xvip_graph_init(struct xvip_composite_device *xdev)
+static int xvipp_pipeline_init(struct xvip_pipeline *xvipp)
 {
-	struct xvip_graph_entity *entity;
+	struct xvip_pipeline_entity *entity;
 	struct v4l2_async_subdev **subdevs = NULL;
 	unsigned int num_subdevs;
 	unsigned int i;
 	int ret;
 
 	/* Init the DMA channels. */
-	ret = xvip_graph_dma_init(xdev);
+	ret = xvipp_pipeline_dma_init(xvipp);
 	if (ret < 0) {
-		dev_err(xdev->dev, "DMA initialization failed\n");
+		dev_err(xvipp->dev, "DMA initialization failed\n");
 		goto done;
 	}
 
-	/* Parse the graph to extract a list of subdevice DT nodes. */
-	ret = xvip_graph_parse(xdev);
+	/* Parse the pipeline to extract a list of subdevice DT nodes. */
+	ret = xvipp_pipeline_parse(xvipp);
 	if (ret < 0) {
-		dev_err(xdev->dev, "graph parsing failed\n");
+		dev_err(xvipp->dev, "pipeline parsing failed\n");
 		goto done;
 	}
 
-	if (!xdev->num_subdevs) {
-		dev_err(xdev->dev, "no subdev found in graph\n");
+	if (!xvipp->num_subdevs) {
+		dev_err(xvipp->dev, "no subdev found in pipeline\n");
 		goto done;
 	}
 
 	/* Register the subdevices notifier. */
-	num_subdevs = xdev->num_subdevs;
-	subdevs = devm_kzalloc(xdev->dev, sizeof(*subdevs) * num_subdevs,
+	num_subdevs = xvipp->num_subdevs;
+	subdevs = devm_kzalloc(xvipp->dev, sizeof(*subdevs) * num_subdevs,
 			       GFP_KERNEL);
 	if (subdevs == NULL) {
 		ret = -ENOMEM;
@@ -540,17 +484,20 @@ static int xvip_graph_init(struct xvip_composite_device *xdev)
 	}
 
 	i = 0;
-	list_for_each_entry(entity, &xdev->entities, list)
-		subdevs[i++] = &entity->asd;
+	list_for_each_entry(entity, &xvipp->entities, list) {
+		/* Skip entities that correspond to video nodes. */
+		if (entity->entity == NULL)
+			subdevs[i++] = &entity->asd;
+	}
 
-	xdev->notifier.subdevs = subdevs;
-	xdev->notifier.num_subdevs = num_subdevs;
-	xdev->notifier.bound = xvip_graph_notify_bound;
-	xdev->notifier.complete = xvip_graph_notify_complete;
+	xvipp->notifier.subdevs = subdevs;
+	xvipp->notifier.num_subdevs = num_subdevs;
+	xvipp->notifier.bound = xvipp_pipeline_notify_bound;
+	xvipp->notifier.complete = xvipp_pipeline_notify_complete;
 
-	ret = v4l2_async_notifier_register(&xdev->v4l2_dev, &xdev->notifier);
+	ret = v4l2_async_notifier_register(&xvipp->v4l2_dev, &xvipp->notifier);
 	if (ret < 0) {
-		dev_err(xdev->dev, "notifier registration failed\n");
+		dev_err(xvipp->dev, "notifier registration failed\n");
 		goto done;
 	}
 
@@ -558,7 +505,7 @@ static int xvip_graph_init(struct xvip_composite_device *xdev)
 
 done:
 	if (ret < 0)
-		xvip_graph_cleanup(xdev);
+		xvipp_pipeline_cleanup(xvipp);
 
 	return ret;
 }
@@ -567,34 +514,34 @@ done:
  * Media Controller and V4L2
  */
 
-static void xvip_composite_v4l2_cleanup(struct xvip_composite_device *xdev)
+static void xvipp_v4l2_cleanup(struct xvip_pipeline *xvipp)
 {
-	v4l2_device_unregister(&xdev->v4l2_dev);
-	media_device_unregister(&xdev->media_dev);
+	v4l2_device_unregister(&xvipp->v4l2_dev);
+	media_device_unregister(&xvipp->media_dev);
 }
 
-static int xvip_composite_v4l2_init(struct xvip_composite_device *xdev)
+static int xvipp_v4l2_init(struct xvip_pipeline *xvipp)
 {
 	int ret;
 
-	xdev->media_dev.dev = xdev->dev;
-	strlcpy(xdev->media_dev.model, "Xilinx Video Composite Device",
-		sizeof(xdev->media_dev.model));
-	xdev->media_dev.hw_revision = 0;
+	xvipp->media_dev.dev = xvipp->dev;
+	strlcpy(xvipp->media_dev.model, "Xilinx Video Pipeline",
+		sizeof(xvipp->media_dev.model));
+	xvipp->media_dev.hw_revision = 0;
 
-	ret = media_device_register(&xdev->media_dev);
+	ret = media_device_register(&xvipp->media_dev);
 	if (ret < 0) {
-		dev_err(xdev->dev, "media device registration failed (%d)\n",
+		dev_err(xvipp->dev, "media device registration failed (%d)\n",
 			ret);
 		return ret;
 	}
 
-	xdev->v4l2_dev.mdev = &xdev->media_dev;
-	ret = v4l2_device_register(xdev->dev, &xdev->v4l2_dev);
+	xvipp->v4l2_dev.mdev = &xvipp->media_dev;
+	ret = v4l2_device_register(xvipp->dev, &xvipp->v4l2_dev);
 	if (ret < 0) {
-		dev_err(xdev->dev, "V4L2 device registration failed (%d)\n",
+		dev_err(xvipp->dev, "V4L2 device registration failed (%d)\n",
 			ret);
-		media_device_unregister(&xdev->media_dev);
+		media_device_unregister(&xvipp->media_dev);
 		return ret;
 	}
 
@@ -605,65 +552,67 @@ static int xvip_composite_v4l2_init(struct xvip_composite_device *xdev)
  * Platform Device Driver
  */
 
-static int xvip_composite_probe(struct platform_device *pdev)
+static int xvipp_probe(struct platform_device *pdev)
 {
-	struct xvip_composite_device *xdev;
+	struct xvip_pipeline *xvipp;
 	int ret;
 
-	xdev = devm_kzalloc(&pdev->dev, sizeof(*xdev), GFP_KERNEL);
-	if (!xdev)
+	xvipp = devm_kzalloc(&pdev->dev, sizeof(*xvipp), GFP_KERNEL);
+	if (!xvipp)
 		return -ENOMEM;
 
-	xdev->dev = &pdev->dev;
-	INIT_LIST_HEAD(&xdev->entities);
-	INIT_LIST_HEAD(&xdev->dmas);
+	xvipp->dev = &pdev->dev;
+	INIT_LIST_HEAD(&xvipp->entities);
+	mutex_init(&xvipp->lock);
 
-	ret = xvip_composite_v4l2_init(xdev);
+	ret = xvipp_v4l2_init(xvipp);
 	if (ret < 0)
 		return ret;
 
-	ret = xvip_graph_init(xdev);
+	ret = xvipp_pipeline_init(xvipp);
 	if (ret < 0)
 		goto error;
 
-	platform_set_drvdata(pdev, xdev);
+	platform_set_drvdata(pdev, xvipp);
 
-	dev_info(xdev->dev, "device registered\n");
+	dev_info(xvipp->dev, "device registered\n");
 
 	return 0;
 
 error:
-	xvip_composite_v4l2_cleanup(xdev);
+	xvipp_v4l2_cleanup(xvipp);
 	return ret;
 }
 
-static int xvip_composite_remove(struct platform_device *pdev)
+static int xvipp_remove(struct platform_device *pdev)
 {
-	struct xvip_composite_device *xdev = platform_get_drvdata(pdev);
+	struct xvip_pipeline *xvipp = platform_get_drvdata(pdev);
 
-	xvip_graph_cleanup(xdev);
-	xvip_composite_v4l2_cleanup(xdev);
+	xvipp_pipeline_cleanup(xvipp);
+	xvipp_v4l2_cleanup(xvipp);
+	mutex_destroy(&xvipp->lock);
 
 	return 0;
 }
 
-static const struct of_device_id xvip_composite_of_id_table[] = {
-	{ .compatible = "xlnx,video" },
+static const struct of_device_id xvipp_of_id_table[] = {
+	{ .compatible = "xlnx,axi-video" },
 	{ }
 };
-MODULE_DEVICE_TABLE(of, xvip_composite_of_id_table);
+MODULE_DEVICE_TABLE(of, xvipp_of_id_table);
 
-static struct platform_driver xvip_composite_driver = {
+static struct platform_driver xvipp_driver = {
 	.driver = {
-		.name = "xilinx-video",
-		.of_match_table = xvip_composite_of_id_table,
+		.owner = THIS_MODULE,
+		.name = "xilinx-axi-video",
+		.of_match_table = of_match_ptr(xvipp_of_id_table),
 	},
-	.probe = xvip_composite_probe,
-	.remove = xvip_composite_remove,
+	.probe = xvipp_probe,
+	.remove = xvipp_remove,
 };
 
-module_platform_driver(xvip_composite_driver);
+module_platform_driver(xvipp_driver);
 
 MODULE_AUTHOR("Laurent Pinchart <laurent.pinchart@ideasonboard.com>");
-MODULE_DESCRIPTION("Xilinx Video IP Composite Driver");
+MODULE_DESCRIPTION("Xilinx Video IP Pipeline Driver");
 MODULE_LICENSE("GPL v2");
diff --git a/drivers/media/platform/xilinx/xilinx-vipp.h b/drivers/media/platform/xilinx/xilinx-vipp.h
index faf6b6e..7b2bc52 100644
--- a/drivers/media/platform/xilinx/xilinx-vipp.h
+++ b/drivers/media/platform/xilinx/xilinx-vipp.h
@@ -1,11 +1,9 @@
 /*
- * Xilinx Video IP Composite Device
+ * Xilinx Video IP Pipeline
  *
- * Copyright (C) 2013-2015 Ideas on Board
- * Copyright (C) 2013-2015 Xilinx, Inc.
+ * Copyright (C) 2013 Ideas on Board SPRL
  *
- * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
- *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -19,31 +17,41 @@
 #include <linux/mutex.h>
 #include <media/media-device.h>
 #include <media/v4l2-async.h>
-#include <media/v4l2-ctrls.h>
 #include <media/v4l2-device.h>
 
+#include "xilinx-dma.h"
+
 /**
- * struct xvip_composite_device - Xilinx Video IP device structure
+ * struct xvip_pipeline - Xilinx Video IP device structure
  * @v4l2_dev: V4L2 device
  * @media_dev: media device
+ * @pipe: media pipeline
  * @dev: (OF) device
  * @notifier: V4L2 asynchronous subdevs notifier
- * @entities: entities in the graph as a list of xvip_graph_entity
+ * @entities: entities in the pipeline as a list of xvip_pipeline_entity
  * @num_subdevs: number of subdevs in the pipeline
- * @dmas: list of DMA channels at the pipeline output and input
- * @v4l2_caps: V4L2 capabilities of the whole device (see VIDIOC_QUERYCAP)
+ * @dma: DMA channels at the pipeline output and input
+ * @num_dmas: number of DMA engines in the pipeline
+ * @lock: protects the pipeline @stream_count
+ * @stream_count: number of DMA engines currently streaming
  */
-struct xvip_composite_device {
+struct xvip_pipeline {
 	struct v4l2_device v4l2_dev;
 	struct media_device media_dev;
+	struct media_pipeline pipe;
 	struct device *dev;
 
 	struct v4l2_async_notifier notifier;
 	struct list_head entities;
 	unsigned int num_subdevs;
 
-	struct list_head dmas;
-	u32 v4l2_caps;
+	struct xvip_dma dma[2];
+	unsigned int num_dmas;
+
+	struct mutex lock;
+	unsigned int stream_count;
 };
 
+int xvip_pipeline_set_stream(struct xvip_pipeline *xvipp, bool on);
+
 #endif /* __XILINX_VIPP_H__ */
-- 
2.9.3

