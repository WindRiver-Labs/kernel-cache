From 315a135dc450c086cbfad3242610dc58024b2716 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Sun, 25 Sep 2016 20:00:47 +0800
Subject: [PATCH 591/827] media: xilinx: merge to the commit 2ab6f261

This patch comes from:
  https://github.com/Xilinx/linux-xlnx.git

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 .../bindings/media/xilinx/xlnx,v-cfa.txt           |  20 +-
 .../bindings/media/xilinx/xlnx,v-cresample.txt     |  16 +-
 .../bindings/media/xilinx/xlnx,v-hls.txt           |  64 +++
 .../bindings/media/xilinx/xlnx,v-rgb2yuv.txt       |  16 +-
 .../bindings/media/xilinx/xlnx,v-scaler.txt        |  16 +-
 .../bindings/media/xilinx/xlnx,v-switch.txt        |   2 +-
 .../bindings/media/xilinx/xlnx,v-tpg.txt           |   4 +
 drivers/media/platform/xilinx/Kconfig              |   2 +-
 drivers/media/platform/xilinx/xilinx-cfa.c         |  50 +-
 drivers/media/platform/xilinx/xilinx-cresample.c   |  45 +-
 drivers/media/platform/xilinx/xilinx-dma.c         |  36 +-
 drivers/media/platform/xilinx/xilinx-dma.h         |   6 +-
 drivers/media/platform/xilinx/xilinx-hls-common.h  |  36 ++
 drivers/media/platform/xilinx/xilinx-hls.c         |  25 +-
 drivers/media/platform/xilinx/xilinx-remapper.c    |  36 +-
 drivers/media/platform/xilinx/xilinx-rgb2yuv.c     |  42 +-
 drivers/media/platform/xilinx/xilinx-scaler.c      |  98 ++--
 drivers/media/platform/xilinx/xilinx-switch.c      |  41 +-
 drivers/media/platform/xilinx/xilinx-tpg.c         | 545 +++++++++++++++------
 drivers/media/platform/xilinx/xilinx-vip.c         | 231 +++------
 drivers/media/platform/xilinx/xilinx-vip.h         |  41 +-
 drivers/media/platform/xilinx/xilinx-vipp.c        |  15 +-
 drivers/media/platform/xilinx/xilinx-vipp.h        |   6 +-
 drivers/media/platform/xilinx/xilinx-vtc.c         |   6 +-
 drivers/media/platform/xilinx/xilinx-vtc.h         |   6 +-
 include/uapi/linux/xilinx-v4l2-controls.h          |   9 +-
 26 files changed, 843 insertions(+), 571 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/media/xilinx/xlnx,v-hls.txt
 create mode 100644 drivers/media/platform/xilinx/xilinx-hls-common.h

diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-cfa.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-cfa.txt
index dbe0626..cdb0886 100644
--- a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-cfa.txt
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-cfa.txt
@@ -14,14 +14,17 @@ Required properties:
 
 Required port properties:
 
-- xlnx,axi-video-format: Must be one of "rggb", "grbg", "gbrg", and "bggr" for
-  the input port (0), and "rbg" for the output port (1).
+- xlnx,video-format: Must be SENSOR_MONO for the input port (0), and RBG for
+  the output port (1).
 
-- xlnx,axi-video-width: Video width as defined in video.txt
+- xlnx,video-width: Video width as defined in video.txt
+
+- xlnx, cfa-pattern: Must be one of "rggb", "grbg", "gbrg", and "bggr" for the
+  input port (0). Must not be specified for the output port (1).
 
 Example:
 
-	axi_cfa_0: axi_cfa {
+	cfa_0: cfa@400b0000 {
 		compatible = "xlnx,v-cfa-7.0";
 		reg = <0x400b0000 0x10000>;
 		clocks = <&clkc 15>;
@@ -33,8 +36,9 @@ Example:
 			port@0 {
 				reg = <0>;
 
-				xlnx,axi-video-format = "rggb";
-				xlnx,axi-video-width = <8>;
+				xlnx,video-format = <XVIP_VF_SENSOR_MONO>;
+				xlnx,video-width = <8>;
+				xlnx,cfa-pattern = "rggb";
 
 				cfa0_in: endpoint {
 					remote-endpoint = <&spc0_out>;
@@ -43,8 +47,8 @@ Example:
 			port@1 {
 				reg = <1>;
 
-				xlnx,axi-video-format = "rbg";
-				xlnx,axi-video-width = <8>;
+				xlnx,video-format = <XVIP_VF_RBG>;
+				xlnx,video-width = <8>;
 
 				cfa0_out: endpoint {
 					remote-endpoint = <&ccm0_in>;
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-cresample.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-cresample.txt
index 819db78..4546aab 100644
--- a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-cresample.txt
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-cresample.txt
@@ -14,14 +14,14 @@ Required properties:
 
 Required port properties:
 
-- xlnx,axi-video-format: Must be one of "yuv444", "yuv422", and "yuv420" for
-  the input port (0), and one of "yuv422" and "yuv420" for the output port (1).
+- xlnx,video-format: Must be one of YUV_444, YUV_422 or YUV_420 for the input
+  port (0), and one of YUV_422 or YUV_420 for the output port (1).
 
-- xlnx,axi-video-width: Video width as defined in video.txt
+- xlnx,video-width: Video width as defined in video.txt
 
 Example:
 
-	axi_cresample_0: axi_cresample {
+	cresample_0: cresample@40120000 {
 		compatible = "xlnx,v-cresample-4.0";
 		reg = <0x40120000 0x10000>;
 		clocks = <&clkc 15>;
@@ -33,8 +33,8 @@ Example:
 			port@0 {
 				reg = <0>;
 
-				xlnx,axi-input-video-format = "yuv444";
-				xlnx,axi-video-width = <8>;
+				xlnx,input-video-format = <XVIP_VF_YUV_444>;
+				xlnx,video-width = <8>;
 
 				cresample0_in: endpoint {
 					remote-endpoint = <&rgb2yuv0_out>;
@@ -43,8 +43,8 @@ Example:
 			port@1 {
 				reg = <1>;
 
-				xlnx,axi-output-video-format = "yuv422";
-				xlnx,axi-video-width = <8>;
+				xlnx,output-video-format = <XVIP_VF_YUV_422>;
+				xlnx,video-width = <8>;
 
 				cresample0_out: endpoint {
 					remote-endpoint = <&scaler0_in>;
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-hls.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-hls.txt
new file mode 100644
index 0000000..a6db304
--- /dev/null
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-hls.txt
@@ -0,0 +1,64 @@
+Xilinx High-Level Synthesis Core (HLS)
+--------------------------------------
+
+High-Level Synthesis cores are synthesized from a high-level function
+description developed by the user. As such their functions vary widely, but
+they all share a set of common characteristics that allow them to be described
+by common bindings.
+
+
+Required properties:
+
+- compatible: This property must contain "xlnx,v-hls" to indicate that the
+  core is compatible with the generic Xilinx HLS DT bindings. It can also
+  contain a more specific string to identify the HLS core implementation. The
+  value of those implementation-specific strings is out of scope for these DT
+  bindings.
+
+- reg: Physical base address and length of the registers sets for the device.
+  The HLS core has two registers sets, the first one contains the core
+  standard registers and the second one contains the custom user registers.
+
+- clocks: Reference to the video core clock.
+
+- ports: Video ports, using the DT bindings defined in ../video-interfaces.txt.
+  The HLS core has one input port (0) and one output port (1).
+
+Required port properties:
+
+- xlnx,video-format: Video format as defined in video.txt.
+- xlnx,video-width: Video width as defined in video.txt.
+
+Example:
+
+	hls_0: hls@43c00000 {
+		compatible = "xlnx,v-hls-sobel", "xlnx,v-hls";
+		reg = <0x43c00000 0x24>, <0x43c00024 0xa0>;
+		clocks = <&clkc 15>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@0 {
+				reg = <0>;
+
+				xlnx,video-format = <XVIP_VF_YUV_422>;
+				xlnx,video-width = <8>;
+
+				hls0_in: endpoint {
+					remote-endpoint = <&vdma_out>;
+				};
+			};
+			port@1 {
+				reg = <1>;
+
+				xlnx,video-format = <XVIP_VF_YUV_422>;
+				xlnx,video-width = <8>;
+
+				hls0_out: endpoint {
+					remote-endpoint = <&vdma_in>;
+				};
+			};
+		};
+	};
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-rgb2yuv.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-rgb2yuv.txt
index d28b495..ecd10fb 100644
--- a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-rgb2yuv.txt
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-rgb2yuv.txt
@@ -14,14 +14,14 @@ Required properties:
 
 Required port properties:
 
-- xlnx,axi-video-format: Must be 'rbg' for the input port (0) and 'yuv444' for
-  the output port (1).
+- xlnx,video-format: Must be RBG for the input port (0) and YUV_444 for the
+  output port (1).
 
-- xlnx,axi-video-width: Video width as defined in video.txt
+- xlnx,video-width: Video width as defined in video.txt
 
 Example:
 
-	axi_rgb2yuv_0: axi_rgb2yuv {
+	rgb2yuv_0: rgb2yuv@40100000 {
 		compatible = "xlnx,v-rgb2yuv-7.1";
 		reg = <0x40100000 0x10000>;
 		clocks = <&clkc 15>;
@@ -33,8 +33,8 @@ Example:
 			port@0 {
 				reg = <0>;
 
-				xlnx,axi-video-format = "rbg";
-				xlnx,axi-video-width = <8>;
+				xlnx,video-format = <XVIP_VF_RBG>;
+				xlnx,video-width = <8>;
 
 				rgb2yuv0_in: endpoint {
 					remote-endpoint = <&gamma0_out>;
@@ -43,8 +43,8 @@ Example:
 			port@1 {
 				reg = <1>;
 
-				xlnx,axi-video-format = "yuv444";
-				xlnx,axi-video-width = <8>;
+				xlnx,video-format = <XVIP_VF_YUV_444>;
+				xlnx,video-width = <8>;
 
 				rgb2yuv0_out: endpoint {
 					remote-endpoint = <&cresample0_in>;
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-scaler.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-scaler.txt
index 2aa363c..0bb9c40 100644
--- a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-scaler.txt
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-scaler.txt
@@ -30,14 +30,14 @@ Optional properties:
 
 Required port properties:
 
-- xlnx,axi-video-format: Must be one of "rbg", "yuv444", "yuv422", and "yuv420"
-  both input port (0) and output port (1). Both formats must be identical.
+- xlnx,video-format: Must be one of RBG, YUV_422, YUV_422 or YUV_420 for
+  both input port (0) and output port (1). The two formats must be identical.
 
-- xlnx,axi-video-width: Video width as defined in video.txt
+- xlnx,video-width: Video width as defined in video.txt
 
 Example:
 
-	axi_scaler_0: axi_scaler {
+	scaler_0: scaler@43c30000 {
 		compatible = "xlnx,v-scaler-8.1";
 		reg = <0x43c30000 0x10000>;
 		clocks = <&clkc 15>;
@@ -54,8 +54,8 @@ Example:
 			port@0 {
 				reg = <0>;
 
-				xlnx,axi-video-format = "yuv422";
-				xlnx,axi-video-width = <8>;
+				xlnx,video-format = <XVIP_VF_YUV_422>;
+				xlnx,video-width = <8>;
 
 				scaler0_in: endpoint {
 					remote-endpoint = <&cresample0_out>;
@@ -64,8 +64,8 @@ Example:
 			port@1 {
 				reg = <1>;
 
-				xlnx,axi-video-format = "yuv422";
-				xlnx,axi-video-width = <8>;
+				xlnx,video-format = <XVIP_VF_YUV_422>;
+				xlnx,video-width = <8>;
 
 				scaler0_out: endpoint {
 					remote-endpoint = <&vcap0_in>;
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-switch.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-switch.txt
index fde86d7..91dc3af 100644
--- a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-switch.txt
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-switch.txt
@@ -16,7 +16,7 @@ Required properties:
 
 Example:
 
-	axi_switch: axi_switch@43c10000 {
+	switch: switch@43c10000 {
 		compatible = "xlnx,v-switch-1.0";
 		reg = <0x43c10000 0x10000>;
 		clocks = <&clkc 15>;
diff --git a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-tpg.txt b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-tpg.txt
index 9dd86b3..e4df35b 100644
--- a/Documentation/devicetree/bindings/media/xilinx/xlnx,v-tpg.txt
+++ b/Documentation/devicetree/bindings/media/xilinx/xlnx,v-tpg.txt
@@ -7,6 +7,7 @@ Required properties:
 
     "xlnx,v-tpg-5.0" (TPG version 5.0)
     "xlnx,v-tpg-6.0" (TPG version 6.0)
+    "xlnx,v-tpg-7.0" (TPG version 7.0)
 
   TPG versions backward-compatible with previous versions should list all
   compatible versions in the newer to older order.
@@ -30,6 +31,9 @@ Optional properties:
   input. The GPIO active level corresponds to the selection of VTC-generated
   video timings.
 
+- reset-gpios: Specifier for a GPIO that assert TPG (AP_RST_N) reset.
+  This property is mandatory for TPG v7.0.
+
 The xlnx,vtc and timing-gpios properties are mandatory when the TPG is
 synthesized with two ports and forbidden when synthesized with one port.
 
diff --git a/drivers/media/platform/xilinx/Kconfig b/drivers/media/platform/xilinx/Kconfig
index 74cad9b..f6d1f6f 100644
--- a/drivers/media/platform/xilinx/Kconfig
+++ b/drivers/media/platform/xilinx/Kconfig
@@ -1,6 +1,6 @@
 config VIDEO_XILINX
 	tristate "Xilinx Video IP (EXPERIMENTAL)"
-	depends on VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API && OF
+	depends on VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API && OF && HAS_DMA
 	select VIDEOBUF2_DMA_CONTIG
 	---help---
 	  Driver for Xilinx Video IP Pipelines
diff --git a/drivers/media/platform/xilinx/xilinx-cfa.c b/drivers/media/platform/xilinx/xilinx-cfa.c
index 3249b5a..85805c9 100644
--- a/drivers/media/platform/xilinx/xilinx-cfa.c
+++ b/drivers/media/platform/xilinx/xilinx-cfa.c
@@ -1,9 +1,11 @@
 /*
  * Xilinx Color Filter Array
  *
- * Copyright (C) 2013 - 2014 Xilinx, Inc.
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
  *
- * Author: Hyun Woo Kwon <hyunk@xilinx.com>
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -61,13 +63,13 @@ static inline struct xcfa_device *to_cfa(struct v4l2_subdev *subdev)
 static int xcfa_get_bayer_phase(const unsigned int code)
 {
 	switch (code) {
-	case V4L2_MBUS_FMT_SRGGB8_1X8:
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
 		return XCFA_BAYER_PHASE_RGGB;
-	case V4L2_MBUS_FMT_SGRBG8_1X8:
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
 		return XCFA_BAYER_PHASE_GRBG;
-	case V4L2_MBUS_FMT_SGBRG8_1X8:
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
 		return XCFA_BAYER_PHASE_GBRG;
-	case V4L2_MBUS_FMT_SBGGR8_1X8:
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
 		return XCFA_BAYER_PHASE_BGGR;
 	}
 
@@ -103,12 +105,12 @@ static int xcfa_s_stream(struct v4l2_subdev *subdev, int enable)
 
 static struct v4l2_mbus_framefmt *
 __xcfa_get_pad_format(struct xcfa_device *xcfa,
-		      struct v4l2_subdev_fh *fh,
+		      struct v4l2_subdev_pad_config *cfg,
 		      unsigned int pad, u32 which)
 {
 	switch (which) {
 	case V4L2_SUBDEV_FORMAT_TRY:
-		return v4l2_subdev_get_try_format(fh, pad);
+		return v4l2_subdev_get_try_format(&xcfa->xvip.subdev, cfg, pad);
 	case V4L2_SUBDEV_FORMAT_ACTIVE:
 		return &xcfa->formats[pad];
 	default:
@@ -117,28 +119,28 @@ __xcfa_get_pad_format(struct xcfa_device *xcfa,
 }
 
 static int xcfa_get_format(struct v4l2_subdev *subdev,
-			   struct v4l2_subdev_fh *fh,
+			   struct v4l2_subdev_pad_config *cfg,
 			   struct v4l2_subdev_format *fmt)
 {
 	struct xcfa_device *xcfa = to_cfa(subdev);
 
-	fmt->format = *__xcfa_get_pad_format(xcfa, fh, fmt->pad, fmt->which);
+	fmt->format = *__xcfa_get_pad_format(xcfa, cfg, fmt->pad, fmt->which);
 
 	return 0;
 }
 
 static int xcfa_set_format(struct v4l2_subdev *subdev,
-			   struct v4l2_subdev_fh *fh,
+			   struct v4l2_subdev_pad_config *cfg,
 			   struct v4l2_subdev_format *fmt)
 {
 	struct xcfa_device *xcfa = to_cfa(subdev);
-	struct v4l2_mbus_framefmt *__format;
+	struct v4l2_mbus_framefmt *format;
 	int bayer_phase;
 
-	__format = __xcfa_get_pad_format(xcfa, fh, fmt->pad, fmt->which);
+	format = __xcfa_get_pad_format(xcfa, cfg, fmt->pad, fmt->which);
 
 	if (fmt->pad == XVIP_PAD_SOURCE) {
-		fmt->format = *__format;
+		fmt->format = *format;
 		return 0;
 	}
 
@@ -146,17 +148,17 @@ static int xcfa_set_format(struct v4l2_subdev *subdev,
 	if (bayer_phase >= 0) {
 		xcfa->vip_formats[XVIP_PAD_SINK] =
 			xvip_get_format_by_code(fmt->format.code);
-		__format->code = fmt->format.code;
+		format->code = fmt->format.code;
 	}
 
-	xvip_set_format_size(__format, fmt);
+	xvip_set_format_size(format, fmt);
 
-	fmt->format = *__format;
+	fmt->format = *format;
 
 	/* Propagate the format to the source pad */
-	__format = __xcfa_get_pad_format(xcfa, fh, XVIP_PAD_SOURCE, fmt->which);
+	format = __xcfa_get_pad_format(xcfa, cfg, XVIP_PAD_SOURCE, fmt->which);
 
-	xvip_set_format_size(__format, fmt);
+	xvip_set_format_size(format, fmt);
 
 	return 0;
 }
@@ -168,14 +170,14 @@ static int xcfa_set_format(struct v4l2_subdev *subdev,
 static int xcfa_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
 {
 	struct xcfa_device *xcfa = to_cfa(subdev);
-	struct v4l2_mbus_framefmt *__format;
+	struct v4l2_mbus_framefmt *format;
 
 	/* Initialize with default formats */
-	__format = v4l2_subdev_get_try_format(fh, XVIP_PAD_SINK);
-	*__format = xcfa->default_formats[XVIP_PAD_SINK];
+	format = v4l2_subdev_get_try_format(subdev, fh->pad, XVIP_PAD_SINK);
+	*format = xcfa->default_formats[XVIP_PAD_SINK];
 
-	__format = v4l2_subdev_get_try_format(fh, XVIP_PAD_SOURCE);
-	*__format = xcfa->default_formats[XVIP_PAD_SOURCE];
+	format = v4l2_subdev_get_try_format(subdev, fh->pad, XVIP_PAD_SOURCE);
+	*format = xcfa->default_formats[XVIP_PAD_SOURCE];
 
 	return 0;
 }
diff --git a/drivers/media/platform/xilinx/xilinx-cresample.c b/drivers/media/platform/xilinx/xilinx-cresample.c
index 064c64f..e160116 100644
--- a/drivers/media/platform/xilinx/xilinx-cresample.c
+++ b/drivers/media/platform/xilinx/xilinx-cresample.c
@@ -1,9 +1,11 @@
 /*
  * Xilinx Chroma Resampler
  *
- * Copyright (C) 2013 - 2014 Xilinx, Inc.
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
  *
- * Author: Hyun Woo Kwon <hyunk@xilinx.com>
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -84,12 +86,13 @@ static int xcresample_s_stream(struct v4l2_subdev *subdev, int enable)
 
 static struct v4l2_mbus_framefmt *
 __xcresample_get_pad_format(struct xcresample_device *xcresample,
-			    struct v4l2_subdev_fh *fh,
+			    struct v4l2_subdev_pad_config *cfg,
 			    unsigned int pad, u32 which)
 {
 	switch (which) {
 	case V4L2_SUBDEV_FORMAT_TRY:
-		return v4l2_subdev_get_try_format(fh, pad);
+		return v4l2_subdev_get_try_format(&xcresample->xvip.subdev, cfg,
+						  pad);
 	case V4L2_SUBDEV_FORMAT_ACTIVE:
 		return &xcresample->formats[pad];
 	default:
@@ -98,41 +101,41 @@ __xcresample_get_pad_format(struct xcresample_device *xcresample,
 }
 
 static int xcresample_get_format(struct v4l2_subdev *subdev,
-				 struct v4l2_subdev_fh *fh,
+				 struct v4l2_subdev_pad_config *cfg,
 				 struct v4l2_subdev_format *fmt)
 {
 	struct xcresample_device *xcresample = to_cresample(subdev);
 
-	fmt->format = *__xcresample_get_pad_format(xcresample, fh, fmt->pad,
+	fmt->format = *__xcresample_get_pad_format(xcresample, cfg, fmt->pad,
 						   fmt->which);
 
 	return 0;
 }
 
 static int xcresample_set_format(struct v4l2_subdev *subdev,
-				 struct v4l2_subdev_fh *fh,
+				 struct v4l2_subdev_pad_config *cfg,
 				 struct v4l2_subdev_format *fmt)
 {
 	struct xcresample_device *xcresample = to_cresample(subdev);
-	struct v4l2_mbus_framefmt *__format;
+	struct v4l2_mbus_framefmt *format;
 
-	__format = __xcresample_get_pad_format(xcresample, fh, fmt->pad,
-					       fmt->which);
+	format = __xcresample_get_pad_format(xcresample, cfg, fmt->pad,
+					     fmt->which);
 
 	if (fmt->pad == XVIP_PAD_SOURCE) {
-		fmt->format = *__format;
+		fmt->format = *format;
 		return 0;
 	}
 
-	xvip_set_format_size(__format, fmt);
+	xvip_set_format_size(format, fmt);
 
-	fmt->format = *__format;
+	fmt->format = *format;
 
 	/* Propagate the format to the source pad. */
-	__format = __xcresample_get_pad_format(xcresample, fh, XVIP_PAD_SOURCE,
-					       fmt->which);
+	format = __xcresample_get_pad_format(xcresample, cfg, XVIP_PAD_SOURCE,
+					     fmt->which);
 
-	xvip_set_format_size(__format, fmt);
+	xvip_set_format_size(format, fmt);
 
 	return 0;
 }
@@ -145,14 +148,14 @@ static int xcresample_open(struct v4l2_subdev *subdev,
 			   struct v4l2_subdev_fh *fh)
 {
 	struct xcresample_device *xcresample = to_cresample(subdev);
-	struct v4l2_mbus_framefmt *__format;
+	struct v4l2_mbus_framefmt *format;
 
 	/* Initialize with default formats */
-	__format = v4l2_subdev_get_try_format(fh, XVIP_PAD_SINK);
-	*__format = xcresample->default_formats[XVIP_PAD_SINK];
+	format = v4l2_subdev_get_try_format(subdev, fh->pad, XVIP_PAD_SINK);
+	*format = xcresample->default_formats[XVIP_PAD_SINK];
 
-	__format = v4l2_subdev_get_try_format(fh, XVIP_PAD_SOURCE);
-	*__format = xcresample->default_formats[XVIP_PAD_SOURCE];
+	format = v4l2_subdev_get_try_format(subdev, fh->pad, XVIP_PAD_SOURCE);
+	*format = xcresample->default_formats[XVIP_PAD_SOURCE];
 
 	return 0;
 }
diff --git a/drivers/media/platform/xilinx/xilinx-dma.c b/drivers/media/platform/xilinx/xilinx-dma.c
index d54e4c1..e0f52b0 100644
--- a/drivers/media/platform/xilinx/xilinx-dma.c
+++ b/drivers/media/platform/xilinx/xilinx-dma.c
@@ -1,16 +1,18 @@
 /*
  * Xilinx Video DMA
  *
- * Copyright (C) 2013 Ideas on Board SPRL
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
  *
- * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
 
-#include <linux/amba/xilinx_dma.h>
+#include <linux/dma/xilinx_dma.h>
 #include <linux/lcm.h>
 #include <linux/list.h>
 #include <linux/module.h>
@@ -333,6 +335,7 @@ static void xvip_dma_complete(void *param)
 	list_del(&buf->queue);
 	spin_unlock(&dma->queued_lock);
 
+	buf->buf.v4l2_buf.field = V4L2_FIELD_NONE;
 	buf->buf.v4l2_buf.sequence = dma->sequence++;
 	v4l2_get_timestamp(&buf->buf.v4l2_buf.timestamp);
 	vb2_set_plane_payload(&buf->buf, 0, dma->format.sizeimage);
@@ -346,9 +349,13 @@ xvip_dma_queue_setup(struct vb2_queue *vq, const struct v4l2_format *fmt,
 {
 	struct xvip_dma *dma = vb2_get_drv_priv(vq);
 
+	/* Make sure the image size is large enough. */
+	if (fmt && fmt->fmt.pix.sizeimage < dma->format.sizeimage)
+		return -EINVAL;
+
 	*nplanes = 1;
 
-	sizes[0] = dma->format.sizeimage;
+	sizes[0] = fmt ? fmt->fmt.pix.sizeimage : dma->format.sizeimage;
 	alloc_ctxs[0] = dma->alloc_ctx;
 
 	return 0;
@@ -479,7 +486,7 @@ static void xvip_dma_stop_streaming(struct vb2_queue *vq)
 	xvip_pipeline_set_stream(pipe, false);
 
 	/* Stop and reset the DMA engine. */
-	dmaengine_device_control(dma->dma, DMA_TERMINATE_ALL, 0);
+	dmaengine_terminate_all(dma->dma);
 
 	/* Cleanup the pipeline and mark it as being stopped. */
 	xvip_pipeline_cleanup(pipe);
@@ -654,6 +661,7 @@ static const struct v4l2_ioctl_ops xvip_dma_ioctl_ops = {
 	.vidioc_querybuf		= vb2_ioctl_querybuf,
 	.vidioc_qbuf			= vb2_ioctl_qbuf,
 	.vidioc_dqbuf			= vb2_ioctl_dqbuf,
+	.vidioc_create_bufs		= vb2_ioctl_create_bufs,
 	.vidioc_expbuf			= vb2_ioctl_expbuf,
 	.vidioc_streamon		= vb2_ioctl_streamon,
 	.vidioc_streamoff		= vb2_ioctl_streamoff,
@@ -679,7 +687,7 @@ static const struct v4l2_file_operations xvip_dma_fops = {
 int xvip_dma_init(struct xvip_composite_device *xdev, struct xvip_dma *dma,
 		  enum v4l2_buf_type type, unsigned int port)
 {
-	char name[14];
+	char name[16];
 	int ret;
 
 	dma->xdev = xdev;
@@ -725,9 +733,18 @@ int xvip_dma_init(struct xvip_composite_device *xdev, struct xvip_dma *dma,
 
 	/* ... and the buffers queue... */
 	dma->alloc_ctx = vb2_dma_contig_init_ctx(dma->xdev->dev);
-	if (IS_ERR(dma->alloc_ctx))
+	if (IS_ERR(dma->alloc_ctx)) {
+		ret = PTR_ERR(dma->alloc_ctx);
 		goto error;
+	}
 
+	/* Don't enable VB2_READ and VB2_WRITE, as using the read() and write()
+	 * V4L2 APIs would be inefficient. Testing on the command line with a
+	 * 'cat /dev/video?' thus won't be possible, but given that the driver
+	 * anyway requires a test tool to setup the pipeline before any video
+	 * stream can be started, requiring a specific V4L2 test tool as well
+	 * instead of 'cat' isn't really a drawback.
+	 */
 	dma->queue.type = type;
 	dma->queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;
 	dma->queue.lock = &dma->lock;
@@ -735,7 +752,8 @@ int xvip_dma_init(struct xvip_composite_device *xdev, struct xvip_dma *dma,
 	dma->queue.buf_struct_size = sizeof(struct xvip_dma_buffer);
 	dma->queue.ops = &xvip_dma_queue_qops;
 	dma->queue.mem_ops = &vb2_dma_contig_memops;
-	dma->queue.timestamp_type = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
+	dma->queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC
+				   | V4L2_BUF_FLAG_TSTAMP_SRC_EOF;
 	ret = vb2_queue_init(&dma->queue);
 	if (ret < 0) {
 		dev_err(dma->xdev->dev, "failed to initialize VB2 queue\n");
@@ -743,7 +761,7 @@ int xvip_dma_init(struct xvip_composite_device *xdev, struct xvip_dma *dma,
 	}
 
 	/* ... and the DMA channel. */
-	sprintf(name, "port%u", port);
+	snprintf(name, sizeof(name), "port%u", port);
 	dma->dma = dma_request_slave_channel(dma->xdev->dev, name);
 	if (dma->dma == NULL) {
 		dev_err(dma->xdev->dev, "no VDMA channel found\n");
diff --git a/drivers/media/platform/xilinx/xilinx-dma.h b/drivers/media/platform/xilinx/xilinx-dma.h
index f395179..a540111 100644
--- a/drivers/media/platform/xilinx/xilinx-dma.h
+++ b/drivers/media/platform/xilinx/xilinx-dma.h
@@ -1,9 +1,11 @@
 /*
  * Xilinx Video DMA
  *
- * Copyright (C) 2013 Ideas on Board SPRL
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
  *
- * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff --git a/drivers/media/platform/xilinx/xilinx-hls-common.h b/drivers/media/platform/xilinx/xilinx-hls-common.h
new file mode 100644
index 0000000..8ecc3cf
--- /dev/null
+++ b/drivers/media/platform/xilinx/xilinx-hls-common.h
@@ -0,0 +1,36 @@
+/*
+ * Xilinx HLS common header
+ *
+ * Copyright (C) 2013-2015 Xilinx, Inc.
+ *
+ * Contacts: Radhey Shyam Pandey <radheys@xilinx.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __XILINX_HLS_COMMON_H__
+#define __XILINX_HLS_COMMON_H__
+
+#include <linux/bitops.h>
+
+#define XHLS_DEF_WIDTH                          1920
+#define XHLS_DEF_HEIGHT                         1080
+
+#define XHLS_REG_CTRL_DONE                      BIT(1)
+#define XHLS_REG_CTRL_IDLE                      BIT(2)
+#define XHLS_REG_CTRL_READY                     BIT(3)
+#define XHLS_REG_CTRL_AUTO_RESTART              BIT(7)
+#define XHLS_REG_GIE                            0x04
+#define XHLS_REG_GIE_GIE                        BIT(0)
+#define XHLS_REG_IER                            0x08
+#define XHLS_REG_IER_DONE                       BIT(0)
+#define XHLS_REG_IER_READY                      BIT(1)
+#define XHLS_REG_ISR                            0x0c
+#define XHLS_REG_ISR_DONE                       BIT(0)
+#define XHLS_REG_ISR_READY                      BIT(1)
+#define XHLS_REG_ROWS                           0x10
+#define XHLS_REG_COLS                           0x18
+
+#endif /* __XILINX_HLS_COMMON_H__ */
diff --git a/drivers/media/platform/xilinx/xilinx-hls.c b/drivers/media/platform/xilinx/xilinx-hls.c
index 264f4bb..891bc4d 100644
--- a/drivers/media/platform/xilinx/xilinx-hls.c
+++ b/drivers/media/platform/xilinx/xilinx-hls.c
@@ -1,9 +1,11 @@
 /*
  * Xilinx HLS Core
  *
- * Copyright (C) 2013-2014 Ideas on Board SPRL
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
  *
- * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -21,26 +23,9 @@
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-subdev.h>
 
+#include "xilinx-hls-common.h"
 #include "xilinx-vip.h"
 
-#define XHLS_DEF_WIDTH				1920
-#define XHLS_DEF_HEIGHT				1080
-
-#define XHLS_REG_CTRL_DONE			(1 << 1)
-#define XHLS_REG_CTRL_IDLE			(1 << 2)
-#define XHLS_REG_CTRL_READY			(1 << 3)
-#define XHLS_REG_CTRL_AUTO_RESTART		(1 << 7)
-#define XHLS_REG_GIE				0x04
-#define XHLS_REG_GIE_GIE			(1 << 0)
-#define XHLS_REG_IER				0x08
-#define XHLS_REG_IER_DONE			(1 << 0)
-#define XHLS_REG_IER_READY			(1 << 1)
-#define XHLS_REG_ISR				0x0c
-#define XHLS_REG_ISR_DONE			(1 << 0)
-#define XHLS_REG_ISR_READY			(1 << 1)
-#define XHLS_REG_ROWS				0x14
-#define XHLS_REG_COLS				0x1c
-
 /**
  * struct xhls_device - Xilinx HLS Core device structure
  * @xvip: Xilinx Video IP device
diff --git a/drivers/media/platform/xilinx/xilinx-remapper.c b/drivers/media/platform/xilinx/xilinx-remapper.c
index 50648a4..acbc082 100644
--- a/drivers/media/platform/xilinx/xilinx-remapper.c
+++ b/drivers/media/platform/xilinx/xilinx-remapper.c
@@ -1,9 +1,11 @@
 /*
  * Xilinx Video Remapper
  *
- * Copyright (C) 2013 Ideas on Board SPRL
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
  *
- * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -97,11 +99,11 @@ static inline struct xremap_device *to_remap(struct v4l2_subdev *subdev)
 
 static const struct xremap_mapping xremap_mappings[] = {
 	{
-		.code = V4L2_MBUS_FMT_RBG888_1X24,
+		.code = MEDIA_BUS_FMT_RBG888_1X24,
 		.width = 8,
 		.num_components = 3,
 		.outputs = (const struct xremap_mapping_output[]) {
-			{ V4L2_MBUS_FMT_RGB888_1X32_PADHI, 4, { 1, 0, 2, 4 } },
+			{ MEDIA_BUS_FMT_RGB888_1X32_PADHI, 4, { 1, 0, 2, 4 } },
 			{ },
 		},
 	},
@@ -141,7 +143,7 @@ xremap_match_mapping(struct xremap_device *xremap,
  */
 
 static int xremap_enum_mbus_code(struct v4l2_subdev *subdev,
-				 struct v4l2_subdev_fh *fh,
+				 struct v4l2_subdev_pad_config *cfg,
 				 struct v4l2_subdev_mbus_code_enum *code)
 {
 	struct xremap_device *xremap = to_remap(subdev);
@@ -174,7 +176,7 @@ static int xremap_enum_mbus_code(struct v4l2_subdev *subdev,
 		if (code->index)
 			return -EINVAL;
 
-		format = v4l2_subdev_get_try_format(fh, code->pad);
+		format = v4l2_subdev_get_try_format(subdev, cfg, code->pad);
 		code->code = format->code;
 	}
 
@@ -182,12 +184,12 @@ static int xremap_enum_mbus_code(struct v4l2_subdev *subdev,
 }
 
 static int xremap_enum_frame_size(struct v4l2_subdev *subdev,
-				  struct v4l2_subdev_fh *fh,
+				  struct v4l2_subdev_pad_config *cfg,
 				  struct v4l2_subdev_frame_size_enum *fse)
 {
 	struct v4l2_mbus_framefmt *format;
 
-	format = v4l2_subdev_get_try_format(fh, fse->pad);
+	format = v4l2_subdev_get_try_format(subdev, cfg, fse->pad);
 
 	if (fse->index || fse->code != format->code)
 		return -EINVAL;
@@ -212,12 +214,14 @@ static int xremap_enum_frame_size(struct v4l2_subdev *subdev,
 }
 
 static struct v4l2_mbus_framefmt *
-xremap_get_pad_format(struct xremap_device *xremap, struct v4l2_subdev_fh *fh,
+xremap_get_pad_format(struct xremap_device *xremap,
+		      struct v4l2_subdev_pad_config *cfg,
 		      unsigned int pad, u32 which)
 {
 	switch (which) {
 	case V4L2_SUBDEV_FORMAT_TRY:
-		return v4l2_subdev_get_try_format(fh, pad);
+		return v4l2_subdev_get_try_format(&xremap->xvip.subdev, cfg,
+						  pad);
 	case V4L2_SUBDEV_FORMAT_ACTIVE:
 		return &xremap->formats[pad];
 	default:
@@ -226,18 +230,18 @@ xremap_get_pad_format(struct xremap_device *xremap, struct v4l2_subdev_fh *fh,
 }
 
 static int xremap_get_format(struct v4l2_subdev *subdev,
-			     struct v4l2_subdev_fh *fh,
+			     struct v4l2_subdev_pad_config *cfg,
 			     struct v4l2_subdev_format *fmt)
 {
 	struct xremap_device *xremap = to_remap(subdev);
 
-	fmt->format = *xremap_get_pad_format(xremap, fh, fmt->pad, fmt->which);
+	fmt->format = *xremap_get_pad_format(xremap, cfg, fmt->pad, fmt->which);
 
 	return 0;
 }
 
 static int xremap_set_format(struct v4l2_subdev *subdev,
-			     struct v4l2_subdev_fh *fh,
+			     struct v4l2_subdev_pad_config *cfg,
 			     struct v4l2_subdev_format *fmt)
 {
 	struct xremap_device *xremap = to_remap(subdev);
@@ -246,7 +250,7 @@ static int xremap_set_format(struct v4l2_subdev *subdev,
 	struct v4l2_mbus_framefmt *format;
 	unsigned int i;
 
-	format = xremap_get_pad_format(xremap, fh, fmt->pad, fmt->which);
+	format = xremap_get_pad_format(xremap, cfg, fmt->pad, fmt->which);
 
 	if (fmt->pad == XREMAP_PAD_SOURCE) {
 		fmt->format = *format;
@@ -282,7 +286,7 @@ static int xremap_set_format(struct v4l2_subdev *subdev,
 	fmt->format = *format;
 
 	/* Propagate the format to the source pad. */
-	format = xremap_get_pad_format(xremap, fh, XREMAP_PAD_SOURCE,
+	format = xremap_get_pad_format(xremap, cfg, XREMAP_PAD_SOURCE,
 				       fmt->which);
 	*format = fmt->format;
 	format->code = output->code;
@@ -317,7 +321,7 @@ static void xremap_init_formats(struct v4l2_subdev *subdev,
 	format.format.width = XREMAP_DEF_WIDTH;
 	format.format.height = XREMAP_DEF_HEIGHT;
 
-	xremap_set_format(subdev, fh, &format);
+	xremap_set_format(subdev, fh ? fh->pad : NULL, &format);
 }
 
 static int xremap_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
diff --git a/drivers/media/platform/xilinx/xilinx-rgb2yuv.c b/drivers/media/platform/xilinx/xilinx-rgb2yuv.c
index 0a6662a..9bd8d9f 100644
--- a/drivers/media/platform/xilinx/xilinx-rgb2yuv.c
+++ b/drivers/media/platform/xilinx/xilinx-rgb2yuv.c
@@ -1,9 +1,11 @@
 /*
  * Xilinx RGB to YUV Convertor
  *
- * Copyright (C) 2013 - 2014 Xilinx, Inc.
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
  *
- * Author: Hyun Woo Kwon <hyunk@xilinx.com>
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -93,12 +95,13 @@ static int xrgb2yuv_s_stream(struct v4l2_subdev *subdev, int enable)
 
 static struct v4l2_mbus_framefmt *
 __xrgb2yuv_get_pad_format(struct xrgb2yuv_device *xrgb2yuv,
-			  struct v4l2_subdev_fh *fh,
+			  struct v4l2_subdev_pad_config *cfg,
 			  unsigned int pad, u32 which)
 {
 	switch (which) {
 	case V4L2_SUBDEV_FORMAT_TRY:
-		return v4l2_subdev_get_try_format(fh, pad);
+		return v4l2_subdev_get_try_format(&xrgb2yuv->xvip.subdev, cfg,
+						  pad);
 	case V4L2_SUBDEV_FORMAT_ACTIVE:
 		return &xrgb2yuv->formats[pad];
 	default:
@@ -107,41 +110,40 @@ __xrgb2yuv_get_pad_format(struct xrgb2yuv_device *xrgb2yuv,
 }
 
 static int xrgb2yuv_get_format(struct v4l2_subdev *subdev,
-			       struct v4l2_subdev_fh *fh,
+			       struct v4l2_subdev_pad_config *cfg,
 			       struct v4l2_subdev_format *fmt)
 {
 	struct xrgb2yuv_device *xrgb2yuv = to_rgb2yuv(subdev);
 
-	fmt->format = *__xrgb2yuv_get_pad_format(xrgb2yuv, fh, fmt->pad,
+	fmt->format = *__xrgb2yuv_get_pad_format(xrgb2yuv, cfg, fmt->pad,
 						 fmt->which);
 
 	return 0;
 }
 
 static int xrgb2yuv_set_format(struct v4l2_subdev *subdev,
-			       struct v4l2_subdev_fh *fh,
+			       struct v4l2_subdev_pad_config *cfg,
 			       struct v4l2_subdev_format *fmt)
 {
 	struct xrgb2yuv_device *xrgb2yuv = to_rgb2yuv(subdev);
-	struct v4l2_mbus_framefmt *__format;
+	struct v4l2_mbus_framefmt *format;
 
-	__format = __xrgb2yuv_get_pad_format(xrgb2yuv, fh, fmt->pad,
-					     fmt->which);
+	format = __xrgb2yuv_get_pad_format(xrgb2yuv, cfg, fmt->pad, fmt->which);
 
 	if (fmt->pad == XVIP_PAD_SOURCE) {
-		fmt->format = *__format;
+		fmt->format = *format;
 		return 0;
 	}
 
-	xvip_set_format_size(__format, fmt);
+	xvip_set_format_size(format, fmt);
 
-	fmt->format = *__format;
+	fmt->format = *format;
 
 	/* Propagate the format to the source pad. */
-	__format = __xrgb2yuv_get_pad_format(xrgb2yuv, fh, XVIP_PAD_SOURCE,
+	format = __xrgb2yuv_get_pad_format(xrgb2yuv, cfg, XVIP_PAD_SOURCE,
 					     fmt->which);
 
-	xvip_set_format_size(__format, fmt);
+	xvip_set_format_size(format, fmt);
 
 	return 0;
 }
@@ -153,14 +155,14 @@ static int xrgb2yuv_set_format(struct v4l2_subdev *subdev,
 static int xrgb2yuv_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
 {
 	struct xrgb2yuv_device *xrgb2yuv = to_rgb2yuv(subdev);
-	struct v4l2_mbus_framefmt *__format;
+	struct v4l2_mbus_framefmt *format;
 
 	/* Initialize with default formats */
-	__format = v4l2_subdev_get_try_format(fh, XVIP_PAD_SINK);
-	*__format = xrgb2yuv->default_formats[XVIP_PAD_SINK];
+	format = v4l2_subdev_get_try_format(subdev, fh->pad, XVIP_PAD_SINK);
+	*format = xrgb2yuv->default_formats[XVIP_PAD_SINK];
 
-	__format = v4l2_subdev_get_try_format(fh, XVIP_PAD_SOURCE);
-	*__format = xrgb2yuv->default_formats[XVIP_PAD_SOURCE];
+	format = v4l2_subdev_get_try_format(subdev, fh->pad, XVIP_PAD_SOURCE);
+	*format = xrgb2yuv->default_formats[XVIP_PAD_SOURCE];
 
 	return 0;
 }
diff --git a/drivers/media/platform/xilinx/xilinx-scaler.c b/drivers/media/platform/xilinx/xilinx-scaler.c
index 51579eb..99e5ab2 100644
--- a/drivers/media/platform/xilinx/xilinx-scaler.c
+++ b/drivers/media/platform/xilinx/xilinx-scaler.c
@@ -1,9 +1,11 @@
 /*
  * Xilinx Scaler
  *
- * Copyright (C) 2013 - 2014 Xilinx, Inc.
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
  *
- * Author: Hyun Woo Kwon <hyunk@xilinx.com>
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -20,6 +22,7 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/platform_device.h>
+#include <linux/slab.h>
 
 #include <media/v4l2-async.h>
 #include <media/v4l2-subdev.h>
@@ -47,6 +50,19 @@
 #define XSCALER_COEF_DATA_IN			0x0134
 #define XSCALER_COEF_DATA_IN_SHIFT		16
 
+/* Fixed point operations */
+#define FRAC_N	8
+
+static inline s16 fixp_new(s16 a)
+{
+	return a << FRAC_N;
+}
+
+static inline s16 fixp_mult(s16 a, s16 b)
+{
+	return ((s32)(a * b)) >> FRAC_N;
+}
+
 /**
  * struct xscaler_device - Xilinx Scaler device structure
  * @xvip: Xilinx Video IP device
@@ -94,12 +110,12 @@ static inline struct xscaler_device *to_scaler(struct v4l2_subdev *subdev)
  *
  * Return: the coefficient value in fixed point format.
  */
-static fixp_t lanczos(fixp_t x, fixp_t a)
+static s16 lanczos(s16 x, s16 a)
 {
-	fixp_t pi;
-	fixp_t numerator;
-	fixp_t denominator;
-	fixp_t temp;
+	s16 pi;
+	s16 numerator;
+	s16 denominator;
+	s16 temp;
 
 	if (x < -a || x > a)
 		return 0;
@@ -115,14 +131,14 @@ static fixp_t lanczos(fixp_t x, fixp_t a)
 
 	/* sin(pi * x) */
 	temp = fixp_mult(fixp_new(180), x);
-	temp = fixp_sin(temp >> FRAC_N);
+	temp = fixp_sin16(temp >> FRAC_N);
 
 	/* a * sin(pi * x) */
 	numerator = fixp_mult(temp , a);
 
 	/* sin(pi * x / a) */
 	temp = (fixp_mult(fixp_new(180), x) << FRAC_N) / a;
-	temp = fixp_sin(temp >> FRAC_N);
+	temp = fixp_sin16(temp >> FRAC_N);
 
 	/* a * sin(pi * x) * sin(pi * x / a) */
 	numerator = fixp_mult(temp, numerator);
@@ -149,8 +165,8 @@ static fixp_t lanczos(fixp_t x, fixp_t a)
  */
 static int xscaler_set_coefs(struct xscaler_device *xscaler, s16 taps)
 {
-	fixp_t *coef;
-	fixp_t dy;
+	s16 *coef;
+	s16 dy;
 	u32 coef_val;
 	u16 phases = xscaler->max_num_phases;
 	u16 i;
@@ -161,7 +177,7 @@ static int xscaler_set_coefs(struct xscaler_device *xscaler, s16 taps)
 		return -ENOMEM;
 
 	for (i = 0; i < phases; i++) {
-		fixp_t sum = 0;
+		s16 sum = 0;
 
 		dy = ((fixp_new(i) << FRAC_N) / fixp_new(phases));
 
@@ -266,12 +282,12 @@ static int xscaler_s_stream(struct v4l2_subdev *subdev, int enable)
  */
 
 static int xscaler_enum_frame_size(struct v4l2_subdev *subdev,
-				   struct v4l2_subdev_fh *fh,
+				   struct v4l2_subdev_pad_config *cfg,
 				   struct v4l2_subdev_frame_size_enum *fse)
 {
 	struct v4l2_mbus_framefmt *format;
 
-	format = v4l2_subdev_get_try_format(fh, fse->pad);
+	format = v4l2_subdev_get_try_format(subdev, cfg, fse->pad);
 
 	if (fse->index || fse->code != format->code)
 		return -EINVAL;
@@ -286,12 +302,13 @@ static int xscaler_enum_frame_size(struct v4l2_subdev *subdev,
 
 static struct v4l2_mbus_framefmt *
 __xscaler_get_pad_format(struct xscaler_device *xscaler,
-			 struct v4l2_subdev_fh *fh,
+			 struct v4l2_subdev_pad_config *cfg,
 			 unsigned int pad, u32 which)
 {
 	switch (which) {
 	case V4L2_SUBDEV_FORMAT_TRY:
-		return v4l2_subdev_get_try_format(fh, pad);
+		return v4l2_subdev_get_try_format(&xscaler->xvip.subdev, cfg,
+						  pad);
 	case V4L2_SUBDEV_FORMAT_ACTIVE:
 		return &xscaler->formats[pad];
 	default:
@@ -299,13 +316,14 @@ __xscaler_get_pad_format(struct xscaler_device *xscaler,
 	}
 }
 
-static struct v4l2_rect *
-__xscaler_get_crop(struct xscaler_device *xscaler, struct v4l2_subdev_fh *fh,
-		   u32 which)
+static struct v4l2_rect *__xscaler_get_crop(struct xscaler_device *xscaler,
+					    struct v4l2_subdev_pad_config *cfg,
+					    u32 which)
 {
 	switch (which) {
 	case V4L2_SUBDEV_FORMAT_TRY:
-		return v4l2_subdev_get_try_crop(fh, XVIP_PAD_SINK);
+		return v4l2_subdev_get_try_crop(&xscaler->xvip.subdev, cfg,
+						XVIP_PAD_SINK);
 	case V4L2_SUBDEV_FORMAT_ACTIVE:
 		return &xscaler->crop;
 	default:
@@ -314,12 +332,12 @@ __xscaler_get_crop(struct xscaler_device *xscaler, struct v4l2_subdev_fh *fh,
 }
 
 static int xscaler_get_format(struct v4l2_subdev *subdev,
-			      struct v4l2_subdev_fh *fh,
+			      struct v4l2_subdev_pad_config *cfg,
 			      struct v4l2_subdev_format *fmt)
 {
 	struct xscaler_device *xscaler = to_scaler(subdev);
 
-	fmt->format = *__xscaler_get_pad_format(xscaler, fh, fmt->pad,
+	fmt->format = *__xscaler_get_pad_format(xscaler, cfg, fmt->pad,
 						fmt->which);
 
 	return 0;
@@ -338,25 +356,25 @@ static void xscaler_try_crop(const struct v4l2_mbus_framefmt *sink,
 }
 
 static int xscaler_set_format(struct v4l2_subdev *subdev,
-			      struct v4l2_subdev_fh *fh,
+			      struct v4l2_subdev_pad_config *cfg,
 			      struct v4l2_subdev_format *fmt)
 {
 	struct xscaler_device *xscaler = to_scaler(subdev);
-	struct v4l2_mbus_framefmt *__format;
+	struct v4l2_mbus_framefmt *format;
 	struct v4l2_rect *crop;
 
-	__format = __xscaler_get_pad_format(xscaler, fh, fmt->pad, fmt->which);
+	format = __xscaler_get_pad_format(xscaler, cfg, fmt->pad, fmt->which);
 
-	__format->width = clamp_t(unsigned int, fmt->format.width,
+	format->width = clamp_t(unsigned int, fmt->format.width,
 				  XSCALER_MIN_WIDTH, XSCALER_MAX_WIDTH);
-	__format->height = clamp_t(unsigned int, fmt->format.height,
+	format->height = clamp_t(unsigned int, fmt->format.height,
 				   XSCALER_MIN_HEIGHT, XSCALER_MAX_HEIGHT);
 
-	fmt->format = *__format;
+	fmt->format = *format;
 
 	if (fmt->pad == XVIP_PAD_SINK) {
 		/* Set the crop rectangle to the full frame */
-		crop = __xscaler_get_crop(xscaler, fh, fmt->which);
+		crop = __xscaler_get_crop(xscaler, cfg, fmt->which);
 		crop->left = 0;
 		crop->top = 0;
 		crop->width = fmt->format.width;
@@ -367,7 +385,7 @@ static int xscaler_set_format(struct v4l2_subdev *subdev,
 }
 
 static int xscaler_get_selection(struct v4l2_subdev *subdev,
-				 struct v4l2_subdev_fh *fh,
+				 struct v4l2_subdev_pad_config *cfg,
 				 struct v4l2_subdev_selection *sel)
 {
 	struct xscaler_device *xscaler = to_scaler(subdev);
@@ -378,7 +396,7 @@ static int xscaler_get_selection(struct v4l2_subdev *subdev,
 
 	switch (sel->target) {
 	case V4L2_SEL_TGT_CROP_BOUNDS:
-		format = __xscaler_get_pad_format(xscaler, fh, XVIP_PAD_SINK,
+		format = __xscaler_get_pad_format(xscaler, cfg, XVIP_PAD_SINK,
 						  sel->which);
 		sel->r.left = 0;
 		sel->r.top = 0;
@@ -386,7 +404,7 @@ static int xscaler_get_selection(struct v4l2_subdev *subdev,
 		sel->r.height = format->height;
 		return 0;
 	case V4L2_SEL_TGT_CROP:
-		sel->r = *__xscaler_get_crop(xscaler, fh, sel->which);
+		sel->r = *__xscaler_get_crop(xscaler, cfg, sel->which);
 		return 0;
 	default:
 		return -EINVAL;
@@ -394,7 +412,7 @@ static int xscaler_get_selection(struct v4l2_subdev *subdev,
 }
 
 static int xscaler_set_selection(struct v4l2_subdev *subdev,
-				 struct v4l2_subdev_fh *fh,
+				 struct v4l2_subdev_pad_config *cfg,
 				 struct v4l2_subdev_selection *sel)
 {
 	struct xscaler_device *xscaler = to_scaler(subdev);
@@ -403,10 +421,10 @@ static int xscaler_set_selection(struct v4l2_subdev *subdev,
 	if ((sel->target != V4L2_SEL_TGT_CROP) || (sel->pad != XVIP_PAD_SINK))
 		return -EINVAL;
 
-	format = __xscaler_get_pad_format(xscaler, fh, XVIP_PAD_SINK,
+	format = __xscaler_get_pad_format(xscaler, cfg, XVIP_PAD_SINK,
 					  sel->which);
 	xscaler_try_crop(format, &sel->r);
-	*__xscaler_get_crop(xscaler, fh, sel->which) = sel->r;
+	*__xscaler_get_crop(xscaler, cfg, sel->which) = sel->r;
 
 	return 0;
 }
@@ -418,14 +436,14 @@ static int xscaler_set_selection(struct v4l2_subdev *subdev,
 static int xscaler_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
 {
 	struct xscaler_device *xscaler = to_scaler(subdev);
-	struct v4l2_mbus_framefmt *__format;
+	struct v4l2_mbus_framefmt *format;
 
 	/* Initialize with default formats */
-	__format = v4l2_subdev_get_try_format(fh, XVIP_PAD_SINK);
-	*__format = xscaler->default_formats[XVIP_PAD_SINK];
+	format = v4l2_subdev_get_try_format(subdev, fh->pad, XVIP_PAD_SINK);
+	*format = xscaler->default_formats[XVIP_PAD_SINK];
 
-	__format = v4l2_subdev_get_try_format(fh, XVIP_PAD_SOURCE);
-	*__format = xscaler->default_formats[XVIP_PAD_SOURCE];
+	format = v4l2_subdev_get_try_format(subdev, fh->pad, XVIP_PAD_SOURCE);
+	*format = xscaler->default_formats[XVIP_PAD_SOURCE];
 
 	return 0;
 }
diff --git a/drivers/media/platform/xilinx/xilinx-switch.c b/drivers/media/platform/xilinx/xilinx-switch.c
index d6d178c..cc79de6 100644
--- a/drivers/media/platform/xilinx/xilinx-switch.c
+++ b/drivers/media/platform/xilinx/xilinx-switch.c
@@ -1,9 +1,11 @@
 /*
  * Xilinx Video Switch
  *
- * Copyright (C) 2014 Ideas on Board SPRL
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
  *
- * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -113,12 +115,13 @@ static int xsw_s_stream(struct v4l2_subdev *subdev, int enable)
  */
 
 static struct v4l2_mbus_framefmt *
-xsw_get_pad_format(struct xswitch_device *xsw, struct v4l2_subdev_fh *fh,
+xsw_get_pad_format(struct xswitch_device *xsw,
+		   struct v4l2_subdev_pad_config *cfg,
 		   unsigned int pad, u32 which)
 {
 	switch (which) {
 	case V4L2_SUBDEV_FORMAT_TRY:
-		return v4l2_subdev_get_try_format(fh, pad);
+		return v4l2_subdev_get_try_format(&xsw->xvip.subdev, cfg, pad);
 	case V4L2_SUBDEV_FORMAT_ACTIVE:
 		return &xsw->formats[pad];
 	default:
@@ -127,7 +130,7 @@ xsw_get_pad_format(struct xswitch_device *xsw, struct v4l2_subdev_fh *fh,
 }
 
 static int xsw_get_format(struct v4l2_subdev *subdev,
-			  struct v4l2_subdev_fh *fh,
+			  struct v4l2_subdev_pad_config *cfg,
 			  struct v4l2_subdev_format *fmt)
 {
 	struct xswitch_device *xsw = to_xsw(subdev);
@@ -141,35 +144,35 @@ static int xsw_get_format(struct v4l2_subdev *subdev,
 		}
 	}
 
-	fmt->format = *xsw_get_pad_format(xsw, fh, pad, fmt->which);
+	fmt->format = *xsw_get_pad_format(xsw, cfg, pad, fmt->which);
 
 	return 0;
 }
 
 static int xsw_set_format(struct v4l2_subdev *subdev,
-			  struct v4l2_subdev_fh *fh,
+			  struct v4l2_subdev_pad_config *cfg,
 			  struct v4l2_subdev_format *fmt)
 {
 	struct xswitch_device *xsw = to_xsw(subdev);
-	struct v4l2_mbus_framefmt *__format;
+	struct v4l2_mbus_framefmt *format;
 
 	/* The source pad format is always identical to the sink pad format and
 	 * can't be modified.
 	 */
 	if (fmt->pad >= xsw->nsinks)
-		return xsw_get_format(subdev, fh, fmt);
+		return xsw_get_format(subdev, cfg, fmt);
 
-	__format = xsw_get_pad_format(xsw, fh, fmt->pad, fmt->which);
+	format = xsw_get_pad_format(xsw, cfg, fmt->pad, fmt->which);
 
-	__format->code = fmt->format.code;
-	__format->width = clamp_t(unsigned int, fmt->format.width,
-				  XVIP_MIN_WIDTH, XVIP_MAX_WIDTH);
-	__format->height = clamp_t(unsigned int, fmt->format.height,
-				   XVIP_MIN_HEIGHT, XVIP_MAX_HEIGHT);
-	__format->field = V4L2_FIELD_NONE;
-	__format->colorspace = V4L2_COLORSPACE_SRGB;
+	format->code = fmt->format.code;
+	format->width = clamp_t(unsigned int, fmt->format.width,
+				XVIP_MIN_WIDTH, XVIP_MAX_WIDTH);
+	format->height = clamp_t(unsigned int, fmt->format.height,
+				 XVIP_MIN_HEIGHT, XVIP_MAX_HEIGHT);
+	format->field = V4L2_FIELD_NONE;
+	format->colorspace = V4L2_COLORSPACE_SRGB;
 
-	fmt->format = *__format;
+	fmt->format = *format;
 
 	return 0;
 }
@@ -253,7 +256,7 @@ static void xsw_init_formats(struct v4l2_subdev *subdev,
 		format.format.width = 1920;
 		format.format.height = 1080;
 
-		xsw_set_format(subdev, fh, &format);
+		xsw_set_format(subdev, fh ? fh->pad : NULL, &format);
 	}
 }
 
diff --git a/drivers/media/platform/xilinx/xilinx-tpg.c b/drivers/media/platform/xilinx/xilinx-tpg.c
index 1cdedb0..484001e 100644
--- a/drivers/media/platform/xilinx/xilinx-tpg.c
+++ b/drivers/media/platform/xilinx/xilinx-tpg.c
@@ -1,9 +1,11 @@
 /*
  * Xilinx Test Pattern Generator
  *
- * Copyright (C) 2013 Ideas on Board SPRL
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
  *
- * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -21,6 +23,7 @@
 #include <media/v4l2-ctrls.h>
 #include <media/v4l2-subdev.h>
 
+#include "xilinx-hls-common.h"
 #include "xilinx-vip.h"
 #include "xilinx-vtc.h"
 
@@ -59,6 +62,36 @@
 #define XTPG_BAYER_PHASE_BGGR			3
 #define XTPG_BAYER_PHASE_OFF			4
 
+/* TPG v7 is a completely redesigned IP using Vivado HLS
+ * having a different AXI4-Lite interface
+ */
+#define XTPG_HLS_BG_PATTERN			0x0020
+#define XTPG_HLS_FG_PATTERN			0x0028
+#define XTPG_HLS_FG_PATTERN_CROSS_HAIR		(1 << 1)
+#define XTPG_HLS_MASK_ID			0x0030
+#define XTPG_HLS_MOTION_SPEED			0x0038
+#define XTPG_HLS_COLOR_FORMAT			0x0040
+#define XTPG_HLS_COLOR_FORMAT_RGB		0
+#define XTPG_HLS_COLOR_FORMAT_YUV_444		1
+#define XTPG_HLS_COLOR_FORMAT_YUV_422		2
+#define XTPG_HLS_COLOR_FORMAT_YUV_420		3
+#define XTPG_HLS_CROSS_HAIR_HOR			0x0048
+#define XTPG_HLS_CROSS_HAIR_VER			0x0050
+#define XTPG_HLS_ZPLATE_HOR_CNTL_START		0x0058
+#define XTPG_HLS_ZPLATE_HOR_CNTL_DELTA		0x0060
+#define XTPG_HLS_ZPLATE_VER_CNTL_START		0x0068
+#define XTPG_HLS_ZPLATE_VER_CNTL_DELTA		0x0070
+#define XTPG_HLS_BOX_SIZE			0x0078
+#define XTPG_HLS_BOX_COLOR_RED_CB		0x0080
+#define XTPG_HLS_BOX_COLOR_GREEN_CR		0x0088
+#define XTPG_HLS_BOX_COLOR_BLUE_Y		0x0090
+#define XTPG_HLS_ENABLE_INPUT			0x0098
+#define XTPG_HLS_USE_INPUT_VID_STREAM		(1 << 0)
+#define XTPG_HLS_PASS_THRU_START_X		0x00a0
+#define XTPG_HLS_PASS_THRU_START_Y		0x00a8
+#define XTPG_HLS_PASS_THRU_END_X		0x00b0
+#define XTPG_HLS_PASS_THRU_END_Y		0x00b8
+
 /*
  * The minimum blanking value is one clock cycle for the front porch, one clock
  * cycle for the sync pulse and one clock cycle for the back porch.
@@ -83,8 +116,10 @@
  * @vblank: vertical blanking control
  * @pattern: test pattern control
  * @streaming: is the video stream active
+ * @is_hls: whether the IP core is HLS based
  * @vtc: video timing controller
  * @vtmux_gpio: video timing mux GPIO
+ * @rst_gpio: reset IP core GPIO
  */
 struct xtpg_device {
 	struct xvip_device xvip;
@@ -103,9 +138,11 @@ struct xtpg_device {
 	struct v4l2_ctrl *vblank;
 	struct v4l2_ctrl *pattern;
 	bool streaming;
+	bool is_hls;
 
 	struct xvtc_device *vtc;
 	struct gpio_desc *vtmux_gpio;
+	struct gpio_desc *rst_gpio;
 };
 
 static inline struct xtpg_device *to_tpg(struct v4l2_subdev *subdev)
@@ -116,19 +153,44 @@ static inline struct xtpg_device *to_tpg(struct v4l2_subdev *subdev)
 static u32 xtpg_get_bayer_phase(unsigned int code)
 {
 	switch (code) {
-	case V4L2_MBUS_FMT_SRGGB8_1X8:
+	case MEDIA_BUS_FMT_SRGGB8_1X8:
 		return XTPG_BAYER_PHASE_RGGB;
-	case V4L2_MBUS_FMT_SGRBG8_1X8:
+	case MEDIA_BUS_FMT_SGRBG8_1X8:
 		return XTPG_BAYER_PHASE_GRBG;
-	case V4L2_MBUS_FMT_SGBRG8_1X8:
+	case MEDIA_BUS_FMT_SGBRG8_1X8:
 		return XTPG_BAYER_PHASE_GBRG;
-	case V4L2_MBUS_FMT_SBGGR8_1X8:
+	case MEDIA_BUS_FMT_SBGGR8_1X8:
 		return XTPG_BAYER_PHASE_BGGR;
 	default:
 		return XTPG_BAYER_PHASE_OFF;
 	}
 }
 
+static void xtpg_config_vtc(struct xtpg_device *xtpg, int width, int height)
+{
+
+	struct xvtc_config config = {
+		.hblank_start = width,
+		.hsync_start = width + 1,
+		.vblank_start = height,
+		.vsync_start = height + 1,
+	};
+	unsigned int htotal;
+	unsigned int vtotal;
+
+	htotal = min_t(unsigned int, XVTC_MAX_HSIZE,
+		       v4l2_ctrl_g_ctrl(xtpg->hblank) + width);
+	vtotal = min_t(unsigned int, XVTC_MAX_VSIZE,
+		       v4l2_ctrl_g_ctrl(xtpg->vblank) + height);
+
+	config.hsync_end = htotal - 1;
+	config.hsize = htotal;
+	config.vsync_end = vtotal - 1;
+	config.vsize = vtotal;
+
+	xvtc_generator_start(xtpg->vtc, &config);
+}
+
 static void __xtpg_update_pattern_control(struct xtpg_device *xtpg,
 					  bool passthrough, bool pattern)
 {
@@ -174,7 +236,20 @@ static int xtpg_s_stream(struct v4l2_subdev *subdev, int enable)
 	u32 bayer_phase;
 
 	if (!enable) {
-		xvip_stop(&xtpg->xvip);
+		if (!xtpg->is_hls) {
+			xvip_stop(&xtpg->xvip);
+		} else {
+			/*
+			 * There is an known issue in TPG v7.0 that on
+			 * resolution change it doesn't generates pattern
+			 * correctly i.e some hor/ver offset is added.
+			 * As a workaround issue reset on stop.
+			 */
+			gpiod_set_value_cansleep(xtpg->rst_gpio, 0x1);
+			gpiod_set_value_cansleep(xtpg->rst_gpio, 0x0);
+			v4l2_ctrl_handler_setup(&xtpg->ctrl_handler);
+		}
+
 		if (xtpg->vtc)
 			xvtc_generator_stop(xtpg->vtc);
 
@@ -183,31 +258,29 @@ static int xtpg_s_stream(struct v4l2_subdev *subdev, int enable)
 		return 0;
 	}
 
-	xvip_set_frame_size(&xtpg->xvip, &xtpg->formats[0]);
-
-	if (xtpg->vtc) {
-		struct xvtc_config config = {
-			.hblank_start = width,
-			.hsync_start = width + 1,
-			.vblank_start = height,
-			.vsync_start = height + 1,
-		};
-		unsigned int htotal;
-		unsigned int vtotal;
-
-		htotal = min_t(unsigned int, XVTC_MAX_HSIZE,
-			       v4l2_ctrl_g_ctrl(xtpg->hblank) + width);
-		vtotal = min_t(unsigned int, XVTC_MAX_VSIZE,
-			       v4l2_ctrl_g_ctrl(xtpg->vblank) + height);
-
-		config.hsync_end = htotal - 1;
-		config.hsize = htotal;
-		config.vsync_end = vtotal - 1;
-		config.vsize = vtotal;
-
-		xvtc_generator_start(xtpg->vtc, &config);
+	if (xtpg->is_hls) {
+		u32 fmt;
+
+		switch (xtpg->vip_format->code) {
+		case MEDIA_BUS_FMT_UYVY8_1X16:
+			fmt = XTPG_HLS_COLOR_FORMAT_YUV_422;
+			break;
+		case MEDIA_BUS_FMT_VUY8_1X24:
+			fmt = XTPG_HLS_COLOR_FORMAT_YUV_444;
+			break;
+		case MEDIA_BUS_FMT_RBG888_1X24:
+			fmt = XTPG_HLS_COLOR_FORMAT_RGB;
+			break;
+		}
+		xvip_write(&xtpg->xvip, XTPG_HLS_COLOR_FORMAT, fmt);
+		xvip_write(&xtpg->xvip, XHLS_REG_COLS, width);
+		xvip_write(&xtpg->xvip, XHLS_REG_ROWS, height);
+	} else {
+		xvip_set_frame_size(&xtpg->xvip, &xtpg->formats[0]);
 	}
 
+	if (xtpg->vtc)
+		xtpg_config_vtc(xtpg, width, height);
 	/*
 	 * Configure the bayer phase and video timing mux based on the
 	 * operation mode (passthrough or test pattern generation). The test
@@ -216,7 +289,11 @@ static int xtpg_s_stream(struct v4l2_subdev *subdev, int enable)
 	 */
 	mutex_lock(xtpg->ctrl_handler.lock);
 
-	xvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
+	if (xtpg->is_hls)
+		xvip_write(&xtpg->xvip, XTPG_HLS_BG_PATTERN,
+			   xtpg->pattern->cur.val);
+	else
+		xvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
 			 XTPG_PATTERN_MASK, xtpg->pattern->cur.val);
 
 	/*
@@ -230,18 +307,26 @@ static int xtpg_s_stream(struct v4l2_subdev *subdev, int enable)
 
 	mutex_unlock(xtpg->ctrl_handler.lock);
 
-	/*
-	 * For TPG v5.0, the bayer phase needs to be off for the pass through
-	 * mode, otherwise the external input would be subsampled.
-	 */
-	bayer_phase = passthrough ? XTPG_BAYER_PHASE_OFF
-		    : xtpg_get_bayer_phase(xtpg->formats[0].code);
-	xvip_write(&xtpg->xvip, XTPG_BAYER_PHASE, bayer_phase);
-
-	if (!IS_ERR(xtpg->vtmux_gpio))
+	if (xtpg->vtmux_gpio)
 		gpiod_set_value_cansleep(xtpg->vtmux_gpio, !passthrough);
 
-	xvip_start(&xtpg->xvip);
+	if (xtpg->is_hls) {
+		xvip_set(&xtpg->xvip, XTPG_HLS_ENABLE_INPUT,
+			 XTPG_HLS_USE_INPUT_VID_STREAM);
+		xvip_set(&xtpg->xvip, XVIP_CTRL_CONTROL,
+			 XHLS_REG_CTRL_AUTO_RESTART |
+			 XVIP_CTRL_CONTROL_SW_ENABLE);
+	} else {
+		/*
+		 * For TPG v5.0, the bayer phase needs to be off for the pass
+		 * through mode, otherwise the external input would
+		 * be subsampled.
+		 */
+		bayer_phase = passthrough ? XTPG_BAYER_PHASE_OFF
+			    : xtpg_get_bayer_phase(xtpg->formats[0].code);
+		xvip_write(&xtpg->xvip, XTPG_BAYER_PHASE, bayer_phase);
+		xvip_start(&xtpg->xvip);
+	}
 
 	return 0;
 }
@@ -251,12 +336,13 @@ static int xtpg_s_stream(struct v4l2_subdev *subdev, int enable)
  */
 
 static struct v4l2_mbus_framefmt *
-__xtpg_get_pad_format(struct xtpg_device *xtpg, struct v4l2_subdev_fh *fh,
+__xtpg_get_pad_format(struct xtpg_device *xtpg,
+		      struct v4l2_subdev_pad_config *cfg,
 		      unsigned int pad, u32 which)
 {
 	switch (which) {
 	case V4L2_SUBDEV_FORMAT_TRY:
-		return v4l2_subdev_get_try_format(fh, pad);
+		return v4l2_subdev_get_try_format(&xtpg->xvip.subdev, cfg, pad);
 	case V4L2_SUBDEV_FORMAT_ACTIVE:
 		return &xtpg->formats[pad];
 	default:
@@ -265,25 +351,25 @@ __xtpg_get_pad_format(struct xtpg_device *xtpg, struct v4l2_subdev_fh *fh,
 }
 
 static int xtpg_get_format(struct v4l2_subdev *subdev,
-			   struct v4l2_subdev_fh *fh,
+			   struct v4l2_subdev_pad_config *cfg,
 			   struct v4l2_subdev_format *fmt)
 {
 	struct xtpg_device *xtpg = to_tpg(subdev);
 
-	fmt->format = *__xtpg_get_pad_format(xtpg, fh, fmt->pad, fmt->which);
+	fmt->format = *__xtpg_get_pad_format(xtpg, cfg, fmt->pad, fmt->which);
 
 	return 0;
 }
 
 static int xtpg_set_format(struct v4l2_subdev *subdev,
-			   struct v4l2_subdev_fh *fh,
+			   struct v4l2_subdev_pad_config *cfg,
 			   struct v4l2_subdev_format *fmt)
 {
 	struct xtpg_device *xtpg = to_tpg(subdev);
 	struct v4l2_mbus_framefmt *__format;
 	u32 bayer_phase;
 
-	__format = __xtpg_get_pad_format(xtpg, fh, fmt->pad, fmt->which);
+	__format = __xtpg_get_pad_format(xtpg, cfg, fmt->pad, fmt->which);
 
 	/* In two pads mode the source pad format is always identical to the
 	 * sink pad format.
@@ -306,7 +392,7 @@ static int xtpg_set_format(struct v4l2_subdev *subdev,
 
 	/* Propagate the format to the source pad. */
 	if (xtpg->npads == 2) {
-		__format = __xtpg_get_pad_format(xtpg, fh, 1, fmt->which);
+		__format = __xtpg_get_pad_format(xtpg, cfg, 1, fmt->which);
 		*__format = fmt->format;
 	}
 
@@ -318,12 +404,12 @@ static int xtpg_set_format(struct v4l2_subdev *subdev,
  */
 
 static int xtpg_enum_frame_size(struct v4l2_subdev *subdev,
-				struct v4l2_subdev_fh *fh,
+				struct v4l2_subdev_pad_config *cfg,
 				struct v4l2_subdev_frame_size_enum *fse)
 {
 	struct v4l2_mbus_framefmt *format;
 
-	format = v4l2_subdev_get_try_format(fh, fse->pad);
+	format = v4l2_subdev_get_try_format(subdev, cfg, fse->pad);
 
 	if (fse->index || fse->code != format->code)
 		return -EINVAL;
@@ -349,11 +435,15 @@ static int xtpg_enum_frame_size(struct v4l2_subdev *subdev,
 static int xtpg_open(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
 {
 	struct xtpg_device *xtpg = to_tpg(subdev);
+	struct v4l2_mbus_framefmt *format;
 
-	*v4l2_subdev_get_try_format(fh, 0) = xtpg->default_format;
+	format = v4l2_subdev_get_try_format(subdev, fh->pad, 0);
+	*format = xtpg->default_format;
 
-	if (xtpg->npads == 2)
-		*v4l2_subdev_get_try_format(fh, 1) = xtpg->default_format;
+	if (xtpg->npads == 2) {
+		format = v4l2_subdev_get_try_format(subdev, fh->pad, 1);
+		*format = xtpg->default_format;
+	}
 
 	return 0;
 }
@@ -370,8 +460,12 @@ static int xtpg_s_ctrl(struct v4l2_ctrl *ctrl)
 						ctrl_handler);
 	switch (ctrl->id) {
 	case V4L2_CID_TEST_PATTERN:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
-				 XTPG_PATTERN_MASK, ctrl->val);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_BG_PATTERN,
+				   ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
+					 XTPG_PATTERN_MASK, ctrl->val);
 		return 0;
 	case V4L2_CID_XILINX_TPG_CROSS_HAIRS:
 		xvip_clr_or_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
@@ -382,10 +476,13 @@ static int xtpg_s_ctrl(struct v4l2_ctrl *ctrl)
 				XTPG_PATTERN_CONTROL_MOVING_BOX, ctrl->val);
 		return 0;
 	case V4L2_CID_XILINX_TPG_COLOR_MASK:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
-				 XTPG_PATTERN_CONTROL_COLOR_MASK_MASK,
-				 ctrl->val <<
-				 XTPG_PATTERN_CONTROL_COLOR_MASK_SHIFT);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_MASK_ID, ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
+				      XTPG_PATTERN_CONTROL_COLOR_MASK_MASK,
+				      ctrl->val <<
+				      XTPG_PATTERN_CONTROL_COLOR_MASK_SHIFT);
 		return 0;
 	case V4L2_CID_XILINX_TPG_STUCK_PIXEL:
 		xvip_clr_or_set(&xtpg->xvip, XTPG_PATTERN_CONTROL,
@@ -400,43 +497,85 @@ static int xtpg_s_ctrl(struct v4l2_ctrl *ctrl)
 				XTPG_PATTERN_CONTROL_MOTION, ctrl->val);
 		return 0;
 	case V4L2_CID_XILINX_TPG_MOTION_SPEED:
-		xvip_write(&xtpg->xvip, XTPG_MOTION_SPEED, ctrl->val);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_MOTION_SPEED,
+				   ctrl->val);
+		else
+			xvip_write(&xtpg->xvip, XTPG_MOTION_SPEED, ctrl->val);
 		return 0;
 	case V4L2_CID_XILINX_TPG_CROSS_HAIR_ROW:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_CROSS_HAIRS,
-				 XTPG_CROSS_HAIRS_ROW_MASK,
-				 ctrl->val << XTPG_CROSS_HAIRS_ROW_SHIFT);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_CROSS_HAIR_HOR,
+				    ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_CROSS_HAIRS,
+					 XTPG_CROSS_HAIRS_ROW_MASK,
+					 ctrl->val <<
+					 XTPG_CROSS_HAIRS_ROW_SHIFT);
 		return 0;
 	case V4L2_CID_XILINX_TPG_CROSS_HAIR_COLUMN:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_CROSS_HAIRS,
-				 XTPG_CROSS_HAIRS_COLUMN_MASK,
-				 ctrl->val << XTPG_CROSS_HAIRS_COLUMN_SHIFT);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_CROSS_HAIR_VER,
+				   ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_CROSS_HAIRS,
+					 XTPG_CROSS_HAIRS_COLUMN_MASK,
+					 ctrl->val <<
+					 XTPG_CROSS_HAIRS_COLUMN_SHIFT);
 		return 0;
 	case V4L2_CID_XILINX_TPG_ZPLATE_HOR_START:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_HOR_CONTROL,
-				 XTPG_ZPLATE_START_MASK,
-				 ctrl->val << XTPG_ZPLATE_START_SHIFT);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_ZPLATE_HOR_CNTL_START,
+				   ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_HOR_CONTROL,
+					 XTPG_ZPLATE_START_MASK,
+					 ctrl->val << XTPG_ZPLATE_START_SHIFT);
 		return 0;
 	case V4L2_CID_XILINX_TPG_ZPLATE_HOR_SPEED:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_HOR_CONTROL,
-				 XTPG_ZPLATE_SPEED_MASK,
-				 ctrl->val << XTPG_ZPLATE_SPEED_SHIFT);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_ZPLATE_HOR_CNTL_DELTA,
+				   ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_HOR_CONTROL,
+					 XTPG_ZPLATE_SPEED_MASK,
+					 ctrl->val << XTPG_ZPLATE_SPEED_SHIFT);
 		return 0;
 	case V4L2_CID_XILINX_TPG_ZPLATE_VER_START:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_VER_CONTROL,
-				 XTPG_ZPLATE_START_MASK,
-				 ctrl->val << XTPG_ZPLATE_START_SHIFT);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_ZPLATE_VER_CNTL_START,
+				   ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_VER_CONTROL,
+					 XTPG_ZPLATE_START_MASK,
+					 ctrl->val << XTPG_ZPLATE_START_SHIFT);
 		return 0;
 	case V4L2_CID_XILINX_TPG_ZPLATE_VER_SPEED:
-		xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_VER_CONTROL,
-				 XTPG_ZPLATE_SPEED_MASK,
-				 ctrl->val << XTPG_ZPLATE_SPEED_SHIFT);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_ZPLATE_VER_CNTL_DELTA,
+				   ctrl->val);
+		else
+			xvip_clr_and_set(&xtpg->xvip, XTPG_ZPLATE_VER_CONTROL,
+					 XTPG_ZPLATE_SPEED_MASK,
+					 ctrl->val << XTPG_ZPLATE_SPEED_SHIFT);
 		return 0;
 	case V4L2_CID_XILINX_TPG_BOX_SIZE:
-		xvip_write(&xtpg->xvip, XTPG_BOX_SIZE, ctrl->val);
+		if (xtpg->is_hls)
+			xvip_write(&xtpg->xvip, XTPG_HLS_BOX_SIZE, ctrl->val);
+		else
+			xvip_write(&xtpg->xvip, XTPG_BOX_SIZE, ctrl->val);
 		return 0;
 	case V4L2_CID_XILINX_TPG_BOX_COLOR:
-		xvip_write(&xtpg->xvip, XTPG_BOX_COLOR, ctrl->val);
+		if (xtpg->is_hls) {
+			xvip_write(&xtpg->xvip, XTPG_HLS_BOX_COLOR_RED_CB,
+				   ctrl->val >> 16);
+			xvip_write(&xtpg->xvip, XTPG_HLS_BOX_COLOR_GREEN_CR,
+				   ctrl->val >> 8);
+			xvip_write(&xtpg->xvip, XTPG_HLS_BOX_COLOR_BLUE_Y,
+				   ctrl->val);
+		} else {
+			xvip_write(&xtpg->xvip, XTPG_BOX_COLOR, ctrl->val);
+		}
 		return 0;
 	case V4L2_CID_XILINX_TPG_STUCK_PIXEL_THRESH:
 		xvip_write(&xtpg->xvip, XTPG_STUCK_PIXEL_THRESH, ctrl->val);
@@ -444,6 +583,9 @@ static int xtpg_s_ctrl(struct v4l2_ctrl *ctrl)
 	case V4L2_CID_XILINX_TPG_NOISE_GAIN:
 		xvip_write(&xtpg->xvip, XTPG_NOISE_GAIN, ctrl->val);
 		return 0;
+	case V4L2_CID_XILINX_TPG_HLS_FG_PATTERN:
+		xvip_write(&xtpg->xvip, XTPG_HLS_FG_PATTERN, ctrl->val);
+		return 0;
 	}
 
 	return 0;
@@ -501,60 +643,51 @@ static const char *const xtpg_pattern_strings[] = {
 	"Black/White Checker Board",
 };
 
-static struct v4l2_ctrl_config xtpg_ctrls[] = {
+static const char *const xtpg_hls_pattern_strings[] = {
+	"Passthrough",
+	"Horizontal Ramp",
+	"Vertical Ramp",
+	"Temporal Ramp",
+	"Solid Red",
+	"Solid Green",
+	"Solid Blue",
+	"Solid Black",
+	"Solid White",
+	"Color Bars",
+	"Zone Plate",
+	"Tartan Color Bars",
+	"Cross Hatch",
+	"Color Sweep",
+	"Vertical/Horizontal Ramps",
+	"Black/White Checker Board",
+	"PseudoRandom",
+};
+
+static const char *const xtpg_hls_fg_strings[] = {
+	"No Overlay",
+	"Moving Box",
+	"Cross Hairs",
+};
+
+static const struct v4l2_ctrl_config xtpg_hls_fg_ctrl = {
+	.ops	= &xtpg_ctrl_ops,
+	.id     = V4L2_CID_XILINX_TPG_HLS_FG_PATTERN,
+	.name   = "Test Pattern: Foreground Pattern",
+	.type   = V4L2_CTRL_TYPE_MENU,
+	.min	= 0,
+	.max	= ARRAY_SIZE(xtpg_hls_fg_strings) - 1,
+	.qmenu	= xtpg_hls_fg_strings,
+};
+
+static struct v4l2_ctrl_config xtpg_common_ctrls[] = {
 	{
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_CROSS_HAIRS,
-		.name	= "Test Pattern: Cross Hairs",
-		.type	= V4L2_CTRL_TYPE_BOOLEAN,
-		.min	= false,
-		.max	= true,
-		.step	= 1,
-		.def	= 0,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_MOVING_BOX,
-		.name	= "Test Pattern: Moving Box",
-		.type	= V4L2_CTRL_TYPE_BOOLEAN,
-		.min	= false,
-		.max	= true,
-		.step	= 1,
-		.def	= 0,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_COLOR_MASK,
-		.name	= "Test Pattern: Color Mask",
-		.type	= V4L2_CTRL_TYPE_BITMASK,
-		.min	= 0,
-		.max	= 0xf,
-		.def	= 0,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_STUCK_PIXEL,
-		.name	= "Test Pattern: Stuck Pixel",
-		.type	= V4L2_CTRL_TYPE_BOOLEAN,
-		.min	= false,
-		.max	= true,
-		.step	= 1,
-		.def	= 0,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_NOISE,
-		.name	= "Test Pattern: Noise",
-		.type	= V4L2_CTRL_TYPE_BOOLEAN,
-		.min	= false,
-		.max	= true,
-		.step	= 1,
-		.def	= 0,
-	}, {
-		.ops	= &xtpg_ctrl_ops,
-		.id	= V4L2_CID_XILINX_TPG_MOTION,
-		.name	= "Test Pattern: Motion",
-		.type	= V4L2_CTRL_TYPE_BOOLEAN,
-		.min	= false,
-		.max	= true,
-		.step	= 1,
-		.def	= 0,
+		.ops    = &xtpg_ctrl_ops,
+		.id     = V4L2_CID_XILINX_TPG_COLOR_MASK,
+		.name   = "Test Pattern: Color Mask",
+		.type   = V4L2_CTRL_TYPE_BITMASK,
+		.min    = 0,
+		.max    = 0x7,
+		.def    = 0,
 	}, {
 		.ops	= &xtpg_ctrl_ops,
 		.id	= V4L2_CID_XILINX_TPG_MOTION_SPEED,
@@ -638,12 +771,61 @@ static struct v4l2_ctrl_config xtpg_ctrls[] = {
 	}, {
 		.ops	= &xtpg_ctrl_ops,
 		.id	= V4L2_CID_XILINX_TPG_BOX_COLOR,
-		.name	= "Test Pattern: Box Color(RGB)",
+		.name	= "Test Pattern: Box Color(RGB/YCbCr)",
 		.type	= V4L2_CTRL_TYPE_INTEGER,
 		.min	= 0,
 		.max	= (1 << 24) - 1,
 		.step	= 1,
 		.def	= 0,
+	},
+};
+
+static struct v4l2_ctrl_config xtpg_ctrls[] = {
+	{
+		.ops	= &xtpg_ctrl_ops,
+		.id	= V4L2_CID_XILINX_TPG_CROSS_HAIRS,
+		.name	= "Test Pattern: Cross Hairs",
+		.type	= V4L2_CTRL_TYPE_BOOLEAN,
+		.min	= false,
+		.max	= true,
+		.step	= 1,
+		.def	= 0,
+	}, {
+		.ops	= &xtpg_ctrl_ops,
+		.id	= V4L2_CID_XILINX_TPG_MOVING_BOX,
+		.name	= "Test Pattern: Moving Box",
+		.type	= V4L2_CTRL_TYPE_BOOLEAN,
+		.min	= false,
+		.max	= true,
+		.step	= 1,
+		.def	= 0,
+	}, {
+		.ops	= &xtpg_ctrl_ops,
+		.id	= V4L2_CID_XILINX_TPG_STUCK_PIXEL,
+		.name	= "Test Pattern: Stuck Pixel",
+		.type	= V4L2_CTRL_TYPE_BOOLEAN,
+		.min	= false,
+		.max	= true,
+		.step	= 1,
+		.def	= 0,
+	}, {
+		.ops	= &xtpg_ctrl_ops,
+		.id	= V4L2_CID_XILINX_TPG_NOISE,
+		.name	= "Test Pattern: Noise",
+		.type	= V4L2_CTRL_TYPE_BOOLEAN,
+		.min	= false,
+		.max	= true,
+		.step	= 1,
+		.def	= 0,
+	}, {
+		.ops	= &xtpg_ctrl_ops,
+		.id	= V4L2_CID_XILINX_TPG_MOTION,
+		.name	= "Test Pattern: Motion",
+		.type	= V4L2_CTRL_TYPE_BOOLEAN,
+		.min	= false,
+		.max	= true,
+		.step	= 1,
+		.def	= 0,
 	}, {
 		.ops	= &xtpg_ctrl_ops,
 		.id	= V4L2_CID_XILINX_TPG_STUCK_PIXEL_THRESH,
@@ -710,6 +892,9 @@ static int xtpg_parse_of(struct xtpg_device *xtpg)
 	unsigned int nports = 0;
 	bool has_endpoint = false;
 
+	if (of_device_is_compatible(dev->of_node, "xlnx,v-tpg-7.0"))
+		xtpg->is_hls = true;
+
 	ports = of_get_child_by_name(node, "ports");
 	if (ports == NULL)
 		ports = node;
@@ -763,6 +948,7 @@ static int xtpg_probe(struct platform_device *pdev)
 	struct v4l2_subdev *subdev;
 	struct xtpg_device *xtpg;
 	u32 i, bayer_phase;
+	u32 npatterns;
 	int ret;
 
 	xtpg = devm_kzalloc(&pdev->dev, sizeof(*xtpg), GFP_KERNEL);
@@ -779,13 +965,21 @@ static int xtpg_probe(struct platform_device *pdev)
 	if (ret < 0)
 		return ret;
 
-	xtpg->vtmux_gpio = devm_gpiod_get_index(&pdev->dev, "timing", 0);
-	if (PTR_ERR(xtpg->vtmux_gpio) == -EPROBE_DEFER) {
-		ret = -EPROBE_DEFER;
+	xtpg->vtmux_gpio = devm_gpiod_get_optional(&pdev->dev, "timing",
+						   GPIOD_OUT_HIGH);
+	if (IS_ERR(xtpg->vtmux_gpio)) {
+		ret = PTR_ERR(xtpg->vtmux_gpio);
 		goto error_resource;
 	}
-	if (!IS_ERR(xtpg->vtmux_gpio))
-		gpiod_direction_output(xtpg->vtmux_gpio, 1);
+
+	if (xtpg->is_hls) {
+		xtpg->rst_gpio = devm_gpiod_get(&pdev->dev, "reset",
+						   GPIOD_OUT_HIGH);
+		if (IS_ERR(xtpg->rst_gpio)) {
+			ret = PTR_ERR(xtpg->rst_gpio);
+			goto error_resource;
+		}
+	}
 
 	xtpg->vtc = xvtc_of_get(pdev->dev.of_node);
 	if (IS_ERR(xtpg->vtc)) {
@@ -793,8 +987,14 @@ static int xtpg_probe(struct platform_device *pdev)
 		goto error_resource;
 	}
 
-	/* Reset and initialize the core */
-	xvip_reset(&xtpg->xvip);
+	/*
+	 * Reset and initialize the core. For TPG HLS version there
+	 * is no SW_RESET bit hence using GPIO based reset.
+	 */
+	if (xtpg->is_hls)
+		gpiod_set_value_cansleep(xtpg->rst_gpio, 0x0);
+	else
+		xvip_reset(&xtpg->xvip);
 
 	/* Initialize V4L2 subdevice and media entity. Pad numbers depend on the
 	 * number of pads.
@@ -810,11 +1010,23 @@ static int xtpg_probe(struct platform_device *pdev)
 	xtpg->default_format.code = xtpg->vip_format->code;
 	xtpg->default_format.field = V4L2_FIELD_NONE;
 	xtpg->default_format.colorspace = V4L2_COLORSPACE_SRGB;
-	xvip_get_frame_size(&xtpg->xvip, &xtpg->default_format);
 
-	bayer_phase = xtpg_get_bayer_phase(xtpg->vip_format->code);
-	if (bayer_phase != XTPG_BAYER_PHASE_OFF)
-		xtpg->bayer = true;
+	if (xtpg->is_hls) {
+		npatterns = ARRAY_SIZE(xtpg_hls_pattern_strings);
+		xtpg->default_format.width = xvip_read(&xtpg->xvip,
+						       XHLS_REG_COLS);
+		xtpg->default_format.height = xvip_read(&xtpg->xvip,
+							XHLS_REG_ROWS);
+	} else {
+		npatterns = ARRAY_SIZE(xtpg_pattern_strings);
+		xvip_get_frame_size(&xtpg->xvip, &xtpg->default_format);
+	}
+
+	if (!xtpg->is_hls) {
+		bayer_phase = xtpg_get_bayer_phase(xtpg->vip_format->code);
+		if (bayer_phase != XTPG_BAYER_PHASE_OFF)
+			xtpg->bayer = true;
+	}
 
 	xtpg->formats[0] = xtpg->default_format;
 	if (xtpg->npads == 2)
@@ -834,7 +1046,13 @@ static int xtpg_probe(struct platform_device *pdev)
 	if (ret < 0)
 		goto error;
 
-	v4l2_ctrl_handler_init(&xtpg->ctrl_handler, 3 + ARRAY_SIZE(xtpg_ctrls));
+	if (xtpg->is_hls)
+		v4l2_ctrl_handler_init(&xtpg->ctrl_handler, 4 +
+				       ARRAY_SIZE(xtpg_common_ctrls));
+	else
+		v4l2_ctrl_handler_init(&xtpg->ctrl_handler, 3 +
+				       ARRAY_SIZE(xtpg_common_ctrls) +
+				       ARRAY_SIZE(xtpg_ctrls));
 
 	xtpg->vblank = v4l2_ctrl_new_std(&xtpg->ctrl_handler, &xtpg_ctrl_ops,
 					 V4L2_CID_VBLANK, XTPG_MIN_VBLANK,
@@ -842,19 +1060,41 @@ static int xtpg_probe(struct platform_device *pdev)
 	xtpg->hblank = v4l2_ctrl_new_std(&xtpg->ctrl_handler, &xtpg_ctrl_ops,
 					 V4L2_CID_HBLANK, XTPG_MIN_HBLANK,
 					 XTPG_MAX_HBLANK, 1, 100);
-	xtpg->pattern = v4l2_ctrl_new_std_menu_items(&xtpg->ctrl_handler,
-					&xtpg_ctrl_ops, V4L2_CID_TEST_PATTERN,
-					ARRAY_SIZE(xtpg_pattern_strings) - 1,
-					1, 9, xtpg_pattern_strings);
 
-	for (i = 0; i < ARRAY_SIZE(xtpg_ctrls); i++)
-		v4l2_ctrl_new_custom(&xtpg->ctrl_handler, &xtpg_ctrls[i], NULL);
+	if (xtpg->is_hls) {
+		xtpg->pattern =
+			v4l2_ctrl_new_std_menu_items(&xtpg->ctrl_handler,
+						     &xtpg_ctrl_ops,
+						     V4L2_CID_TEST_PATTERN,
+						     npatterns - 1,
+						     1, 9,
+						     xtpg_hls_pattern_strings);
+		v4l2_ctrl_new_custom(&xtpg->ctrl_handler,
+				     &xtpg_hls_fg_ctrl, NULL);
+	} else {
+		xtpg->pattern =
+			v4l2_ctrl_new_std_menu_items(&xtpg->ctrl_handler,
+						     &xtpg_ctrl_ops,
+						     V4L2_CID_TEST_PATTERN,
+						     npatterns - 1,
+						     1, 9,
+						     xtpg_pattern_strings);
+
+		for (i = 0; i < ARRAY_SIZE(xtpg_ctrls); i++)
+			v4l2_ctrl_new_custom(&xtpg->ctrl_handler,
+					     &xtpg_ctrls[i], NULL);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(xtpg_common_ctrls); i++)
+		v4l2_ctrl_new_custom(&xtpg->ctrl_handler,
+				     &xtpg_common_ctrls[i], NULL);
 
 	if (xtpg->ctrl_handler.error) {
 		dev_err(&pdev->dev, "failed to add controls\n");
 		ret = xtpg->ctrl_handler.error;
 		goto error;
 	}
+
 	subdev->ctrl_handler = &xtpg->ctrl_handler;
 
 	xtpg_update_pattern_control(xtpg, true, true);
@@ -904,6 +1144,7 @@ static SIMPLE_DEV_PM_OPS(xtpg_pm_ops, xtpg_pm_suspend, xtpg_pm_resume);
 
 static const struct of_device_id xtpg_of_id_table[] = {
 	{ .compatible = "xlnx,v-tpg-5.0" },
+	{ .compatible = "xlnx,v-tpg-7.0" },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, xtpg_of_id_table);
diff --git a/drivers/media/platform/xilinx/xilinx-vip.c b/drivers/media/platform/xilinx/xilinx-vip.c
index 4e057d7..3112591 100644
--- a/drivers/media/platform/xilinx/xilinx-vip.c
+++ b/drivers/media/platform/xilinx/xilinx-vip.c
@@ -1,9 +1,11 @@
 /*
  * Xilinx Video IP Core
  *
- * Copyright (C) 2013 Ideas on Board SPRL
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
  *
- * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -16,7 +18,7 @@
 #include <linux/of.h>
 #include <linux/platform_device.h>
 
-#include <media/media-entity.h>
+#include <dt-bindings/media/xilinx-vip.h>
 
 #include "xilinx-vip.h"
 
@@ -25,21 +27,22 @@
  */
 
 static const struct xvip_video_format xvip_video_formats[] = {
-	{ "rbg", 8, 3, V4L2_MBUS_FMT_RBG888_1X24, 0, NULL },
-	{ "xrgb", 8, 4, V4L2_MBUS_FMT_RGB888_1X32_PADHI, V4L2_PIX_FMT_BGR32,
-	  "RGB32 (BE)" },
-	{ "yuv422", 8, 2, V4L2_MBUS_FMT_UYVY8_1X16, V4L2_PIX_FMT_YUYV,
-	  "4:2:2, packed, YUYV" },
-	{ "yuv444", 8, 3, V4L2_MBUS_FMT_VUY8_1X24, V4L2_PIX_FMT_YUV444,
-	  "4:4:4, packed, YUYV" },
-	{ "rggb", 8, 1, V4L2_MBUS_FMT_SRGGB8_1X8, V4L2_PIX_FMT_SGRBG8,
-	  "Bayer 8-bit RGGB" },
-	{ "grbg", 8, 1, V4L2_MBUS_FMT_SGRBG8_1X8, V4L2_PIX_FMT_SGRBG8,
-	  "Bayer 8-bit GRBG" },
-	{ "gbrg", 8, 1, V4L2_MBUS_FMT_SGBRG8_1X8, V4L2_PIX_FMT_SGBRG8,
-	  "Bayer 8-bit GBRG" },
-	{ "bggr", 8, 1, V4L2_MBUS_FMT_SBGGR8_1X8, V4L2_PIX_FMT_SBGGR8,
-	  "Bayer 8-bit BGGR" },
+	{ XVIP_VF_YUV_422, 8, NULL, MEDIA_BUS_FMT_UYVY8_1X16,
+	  2, V4L2_PIX_FMT_YUYV, "4:2:2, packed, YUYV" },
+	{ XVIP_VF_YUV_444, 8, NULL, MEDIA_BUS_FMT_VUY8_1X24,
+	  3, V4L2_PIX_FMT_YUV444, "4:4:4, packed, YUYV" },
+	{ XVIP_VF_RBG, 8, NULL, MEDIA_BUS_FMT_RBG888_1X24,
+	  3, 0, NULL },
+	{ XVIP_VF_MONO_SENSOR, 8, "mono", MEDIA_BUS_FMT_Y8_1X8,
+	  1, V4L2_PIX_FMT_GREY, "Greyscale 8-bit" },
+	{ XVIP_VF_MONO_SENSOR, 8, "rggb", MEDIA_BUS_FMT_SRGGB8_1X8,
+	  1, V4L2_PIX_FMT_SGRBG8, "Bayer 8-bit RGGB" },
+	{ XVIP_VF_MONO_SENSOR, 8, "grbg", MEDIA_BUS_FMT_SGRBG8_1X8,
+	  1, V4L2_PIX_FMT_SGRBG8, "Bayer 8-bit GRBG" },
+	{ XVIP_VF_MONO_SENSOR, 8, "gbrg", MEDIA_BUS_FMT_SGBRG8_1X8,
+	  1, V4L2_PIX_FMT_SGBRG8, "Bayer 8-bit GBRG" },
+	{ XVIP_VF_MONO_SENSOR, 8, "bggr", MEDIA_BUS_FMT_SBGGR8_1X8,
+	  1, V4L2_PIX_FMT_SBGGR8, "Bayer 8-bit BGGR" },
 };
 
 /**
@@ -92,21 +95,22 @@ EXPORT_SYMBOL_GPL(xvip_get_format_by_fourcc);
  * xvip_of_get_format - Parse a device tree node and return format information
  * @node: the device tree node
  *
- * Read the xlnx,video-format and xlnx,video-width properties from the device
- * tree @node passed as an argument and return the corresponding format
- * information.
+ * Read the xlnx,video-format, xlnx,video-width and xlnx,cfa-pattern properties
+ * from the device tree @node passed as an argument and return the corresponding
+ * format information.
  *
  * Return: a pointer to the format information structure corresponding to the
  * format name and width, or ERR_PTR if no corresponding format can be found.
  */
 const struct xvip_video_format *xvip_of_get_format(struct device_node *node)
 {
-	const char *name;
+	const char *pattern = "mono";
+	unsigned int vf_code;
 	unsigned int i;
 	u32 width;
 	int ret;
 
-	ret = of_property_read_string(node, "xlnx,video-format", &name);
+	ret = of_property_read_u32(node, "xlnx,video-format", &vf_code);
 	if (ret < 0)
 		return ERR_PTR(ret);
 
@@ -114,11 +118,20 @@ const struct xvip_video_format *xvip_of_get_format(struct device_node *node)
 	if (ret < 0)
 		return ERR_PTR(ret);
 
+	if (vf_code == XVIP_VF_MONO_SENSOR)
+		of_property_read_string(node, "xlnx,cfa-pattern", &pattern);
+
 	for (i = 0; i < ARRAY_SIZE(xvip_video_formats); ++i) {
 		const struct xvip_video_format *format = &xvip_video_formats[i];
 
-		if (strcmp(format->name, name) == 0 && format->width == width)
-			return format;
+		if (format->vf_code != vf_code || format->width != width)
+			continue;
+
+		if (vf_code == XVIP_VF_MONO_SENSOR &&
+		    strcmp(pattern, format->pattern))
+			continue;
+
+		return format;
 	}
 
 	return ERR_PTR(-EINVAL);
@@ -218,106 +231,13 @@ void xvip_cleanup_resources(struct xvip_device *xvip)
 EXPORT_SYMBOL_GPL(xvip_cleanup_resources);
 
 /* -----------------------------------------------------------------------------
- * Subdev operation helpers
- */
-
-/**
- * xvip_get_pad_format - Get the frame format on media bus for the pad
- * @fh: V4L2 subdevice file handle
- * @format: V4L2 active frame format on media bus
- * @pad: media pad
- * @which: media bus format type
- *
- * Get the frame format on media bus for the pad. Return corresponding
- * frame format. The try format is returned by v4l2_subdev_get_try_format(),
- * and when the active format is requested, the given frame format, @format,
- * is returned.
- *
- * Return: frame format on media bus if successful, or NULL if no format
- * is found.
- */
-struct v4l2_mbus_framefmt *
-xvip_get_pad_format(struct v4l2_subdev_fh *fh,
-		    struct v4l2_mbus_framefmt *format,
-		    unsigned int pad, u32 which)
-{
-	switch (which) {
-	case V4L2_SUBDEV_FORMAT_TRY:
-		return v4l2_subdev_get_try_format(fh, pad);
-	case V4L2_SUBDEV_FORMAT_ACTIVE:
-		return format;
-	default:
-		return NULL;
-	}
-}
-EXPORT_SYMBOL_GPL(xvip_get_pad_format);
-
-/**
- * xvip_set_format - Set the subdevice format
- * @format: V4L2 frame format on media bus
- * @vip_format: Xilinx Video IP video format
- * @fmt: media bus format
- *
- * Set the subdevice format. The format code is defined in vip_format,
- * and width and height are defined in subdev format. The new format is stored
- * in @format.
- */
-void xvip_set_format(struct v4l2_mbus_framefmt *format,
-		     const struct xvip_video_format *vip_format,
-		     struct v4l2_subdev_format *fmt)
-{
-	format->code = vip_format->code;
-	format->width = clamp_t(unsigned int, fmt->format.width,
-				XVIP_MIN_WIDTH, XVIP_MAX_WIDTH);
-	format->height = clamp_t(unsigned int, fmt->format.height,
-			 XVIP_MIN_HEIGHT, XVIP_MAX_HEIGHT);
-}
-EXPORT_SYMBOL_GPL(xvip_set_format);
-
-/**
- * xvip_init_formats - Initialize formats on all pads
- * @subdev: V4L2 subdevice
- * @fh: V4L2 subdev file handle
- *
- * Initialize all pad formats with default values. If fh is not NULL, try
- * formats are initialized on the file handle. Otherwise active formats are
- * initialized on the device.
- */
-void xvip_init_formats(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh)
-{
-	struct xvip_device *xvip = container_of(subdev, struct xvip_device,
-						subdev);
-	struct v4l2_subdev_format format;
-
-	memset(&format, 0, sizeof(format));
-
-	format.which = fh ? V4L2_SUBDEV_FORMAT_TRY : V4L2_SUBDEV_FORMAT_ACTIVE;
-	format.format.width = xvip_read(xvip, XVIP_ACTIVE_SIZE) &
-			      XVIP_ACTIVE_HSIZE_MASK;
-	format.format.height = (xvip_read(xvip, XVIP_ACTIVE_SIZE) &
-				XVIP_ACTIVE_VSIZE_MASK) >>
-			       XVIP_ACTIVE_VSIZE_SHIFT;
-	format.format.field = V4L2_FIELD_NONE;
-	format.format.colorspace = V4L2_COLORSPACE_SRGB;
-
-	format.pad = XVIP_PAD_SOURCE;
-
-	v4l2_subdev_call(subdev, pad, set_fmt, fh, &format);
-
-	format.pad = XVIP_PAD_SINK;
-
-	v4l2_subdev_call(subdev, pad, set_fmt, fh, &format);
-}
-EXPORT_SYMBOL_GPL(xvip_init_formats);
-
-/* -----------------------------------------------------------------------------
  * Subdev operations handlers
  */
 
 /**
  * xvip_enum_mbus_code - Enumerate the media format code
  * @subdev: V4L2 subdevice
- * @fh: V4L2 subdevice file handle
+ * @cfg: V4L2 subdev pad configuration
  * @code: returning media bus code
  *
  * Enumerate the media bus code of the subdevice. Return the corresponding
@@ -328,15 +248,22 @@ EXPORT_SYMBOL_GPL(xvip_init_formats);
  * Return: 0 if the media bus code is found, or -EINVAL if the format index
  * is not valid.
  */
-int xvip_enum_mbus_code(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh,
+int xvip_enum_mbus_code(struct v4l2_subdev *subdev,
+			struct v4l2_subdev_pad_config *cfg,
 			struct v4l2_subdev_mbus_code_enum *code)
 {
 	struct v4l2_mbus_framefmt *format;
 
+	/* Enumerating frame sizes based on the active configuration isn't
+	 * supported yet.
+	 */
+	if (code->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
 	if (code->index)
 		return -EINVAL;
 
-	format = v4l2_subdev_get_try_format(fh, code->pad);
+	format = v4l2_subdev_get_try_format(subdev, cfg, code->pad);
 
 	code->code = format->code;
 
@@ -347,7 +274,7 @@ EXPORT_SYMBOL_GPL(xvip_enum_mbus_code);
 /**
  * xvip_enum_frame_size - Enumerate the media bus frame size
  * @subdev: V4L2 subdevice
- * @fh: V4L2 subdevice file handle
+ * @cfg: V4L2 subdev pad configuration
  * @fse: returning media bus frame size
  *
  * This function is a drop-in implementation of the subdev enum_frame_size pad
@@ -359,12 +286,19 @@ EXPORT_SYMBOL_GPL(xvip_enum_mbus_code);
  * Return: 0 if the media bus frame size is found, or -EINVAL
  * if the index or the code is not valid.
  */
-int xvip_enum_frame_size(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh,
+int xvip_enum_frame_size(struct v4l2_subdev *subdev,
+			 struct v4l2_subdev_pad_config *cfg,
 			 struct v4l2_subdev_frame_size_enum *fse)
 {
 	struct v4l2_mbus_framefmt *format;
 
-	format = v4l2_subdev_get_try_format(fh, fse->pad);
+	/* Enumerating frame sizes based on the active configuration isn't
+	 * supported yet.
+	 */
+	if (fse->which == V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
+	format = v4l2_subdev_get_try_format(subdev, cfg, fse->pad);
 
 	if (fse->index || fse->code != format->code)
 		return -EINVAL;
@@ -387,52 +321,3 @@ int xvip_enum_frame_size(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh,
 	return 0;
 }
 EXPORT_SYMBOL_GPL(xvip_enum_frame_size);
-
-/* -----------------------------------------------------------------------------
- * Initialization and cleanup
- */
-
-/**
- * xvip_device_init - Initialize a video IP device
- * @xvip: the video IP device
- *
- * Allocate pads and formats for the device. The caller must have set the
- * following xvip fields prior to calling this function.
- *
- * - npads to the number of pads
- *
- * Return 0 on success or -ENOMEM on memory allocation failure.
- */
-int xvip_device_init(struct xvip_device *xvip)
-{
-	struct v4l2_mbus_framefmt *formats;
-	struct media_pad *pads;
-
-	pads = kzalloc(xvip->npads * sizeof(*pads), GFP_KERNEL);
-	formats = kzalloc(xvip->npads * sizeof(*formats), GFP_KERNEL);
-
-	if (pads == NULL || formats == NULL) {
-		kfree(pads);
-		kfree(formats);
-		return -ENOMEM;
-	}
-
-	xvip->pads = pads;
-	xvip->formats = formats;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(xvip_device_init);
-
-/**
- * xvip_device_cleanup - Cleanup a video IP device
- * @xvip: the video IP device
- *
- * Free the memory allocated by xvip_device_init().
- */
-void xvip_device_cleanup(struct xvip_device *xvip)
-{
-	kfree(xvip->pads);
-	kfree(xvip->formats);
-}
-EXPORT_SYMBOL_GPL(xvip_device_cleanup);
diff --git a/drivers/media/platform/xilinx/xilinx-vip.h b/drivers/media/platform/xilinx/xilinx-vip.h
index 4447f76..42fee20 100644
--- a/drivers/media/platform/xilinx/xilinx-vip.h
+++ b/drivers/media/platform/xilinx/xilinx-vip.h
@@ -1,9 +1,11 @@
 /*
  * Xilinx Video IP Core
  *
- * Copyright (C) 2013 Ideas on Board SPRL
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
  *
- * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -91,9 +93,6 @@ struct clk;
  * @dev: (OF) device
  * @iomem: device I/O register space remapped to kernel virtual memory
  * @clk: video core clock
- * @npads: number of pads on the subdevice
- * @pads: media pads
- * @formats: active formats on the pads
  * @saved_ctrl: saved control register for resume / suspend
  */
 struct xvip_device {
@@ -101,52 +100,40 @@ struct xvip_device {
 	struct device *dev;
 	void __iomem *iomem;
 	struct clk *clk;
-
-	unsigned int npads;
-	struct media_pad *pads;
-	struct v4l2_mbus_framefmt *formats;
-
 	u32 saved_ctrl;
 };
 
 /**
  * struct xvip_video_format - Xilinx Video IP video format description
- * @name: AXI4 format name
+ * @vf_code: AXI4 video format code
  * @width: AXI4 format width in bits per component
- * @bpp: bytes per pixel (when stored in memory)
+ * @pattern: CFA pattern for Mono/Sensor formats
  * @code: media bus format code
+ * @bpp: bytes per pixel (when stored in memory)
  * @fourcc: V4L2 pixel format FCC identifier
  * @description: format description, suitable for userspace
  */
 struct xvip_video_format {
-	const char *name;
+	unsigned int vf_code;
 	unsigned int width;
-	unsigned int bpp;
+	const char *pattern;
 	unsigned int code;
+	unsigned int bpp;
 	u32 fourcc;
 	const char *description;
 };
 
-int xvip_device_init(struct xvip_device *xvip);
-void xvip_device_cleanup(struct xvip_device *xvip);
-
 const struct xvip_video_format *xvip_get_format_by_code(unsigned int code);
 const struct xvip_video_format *xvip_get_format_by_fourcc(u32 fourcc);
 const struct xvip_video_format *xvip_of_get_format(struct device_node *node);
 void xvip_set_format_size(struct v4l2_mbus_framefmt *format,
 			  const struct v4l2_subdev_format *fmt);
-int xvip_enum_mbus_code(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh,
+int xvip_enum_mbus_code(struct v4l2_subdev *subdev,
+			struct v4l2_subdev_pad_config *cfg,
 			struct v4l2_subdev_mbus_code_enum *code);
-int xvip_enum_frame_size(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh,
+int xvip_enum_frame_size(struct v4l2_subdev *subdev,
+			 struct v4l2_subdev_pad_config *cfg,
 			 struct v4l2_subdev_frame_size_enum *fse);
-struct v4l2_mbus_framefmt *
-xvip_get_pad_format(struct v4l2_subdev_fh *fh,
-		    struct v4l2_mbus_framefmt *format,
-		    unsigned int pad, u32 which);
-void xvip_set_format(struct v4l2_mbus_framefmt *format,
-		     const struct xvip_video_format *vip_format,
-		     struct v4l2_subdev_format *fmt);
-void xvip_init_formats(struct v4l2_subdev *subdev, struct v4l2_subdev_fh *fh);
 
 static inline u32 xvip_read(struct xvip_device *xvip, u32 addr)
 {
diff --git a/drivers/media/platform/xilinx/xilinx-vipp.c b/drivers/media/platform/xilinx/xilinx-vipp.c
index cc4f817..7b7cb9c 100644
--- a/drivers/media/platform/xilinx/xilinx-vipp.c
+++ b/drivers/media/platform/xilinx/xilinx-vipp.c
@@ -1,9 +1,11 @@
 /*
  * Xilinx Video IP Composite Device
  *
- * Copyright (C) 2013 Ideas on Board SPRL
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
  *
- * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -13,6 +15,7 @@
 #include <linux/list.h>
 #include <linux/module.h>
 #include <linux/of.h>
+#include <linux/of_graph.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 
@@ -80,7 +83,7 @@ static int xvip_graph_build_one(struct xvip_composite_device *xdev,
 
 	while (1) {
 		/* Get the next endpoint and parse its link. */
-		next = v4l2_of_get_next_endpoint(entity->node, ep);
+		next = of_graph_get_next_endpoint(entity->node, ep);
 		if (next == NULL)
 			break;
 
@@ -201,7 +204,7 @@ static int xvip_graph_build_dma(struct xvip_composite_device *xdev)
 
 	while (1) {
 		/* Get the next endpoint and parse its link. */
-		next = v4l2_of_get_next_endpoint(node, ep);
+		next = of_graph_get_next_endpoint(node, ep);
 		if (next == NULL)
 			break;
 
@@ -354,7 +357,7 @@ static int xvip_graph_parse_one(struct xvip_composite_device *xdev,
 	dev_dbg(xdev->dev, "parsing node %s\n", node->full_name);
 
 	while (1) {
-		next = v4l2_of_get_next_endpoint(node, ep);
+		next = of_graph_get_next_endpoint(node, ep);
 		if (next == NULL)
 			break;
 
@@ -363,7 +366,7 @@ static int xvip_graph_parse_one(struct xvip_composite_device *xdev,
 
 		dev_dbg(xdev->dev, "handling endpoint %s\n", ep->full_name);
 
-		remote = v4l2_of_get_remote_port_parent(ep);
+		remote = of_graph_get_remote_port_parent(ep);
 		if (remote == NULL) {
 			ret = -EINVAL;
 			break;
diff --git a/drivers/media/platform/xilinx/xilinx-vipp.h b/drivers/media/platform/xilinx/xilinx-vipp.h
index 536e226..faf6b6e 100644
--- a/drivers/media/platform/xilinx/xilinx-vipp.h
+++ b/drivers/media/platform/xilinx/xilinx-vipp.h
@@ -1,9 +1,11 @@
 /*
  * Xilinx Video IP Composite Device
  *
- * Copyright (C) 2013 Ideas on Board SPRL
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
  *
- * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff --git a/drivers/media/platform/xilinx/xilinx-vtc.c b/drivers/media/platform/xilinx/xilinx-vtc.c
index a5f6199..01c750e 100644
--- a/drivers/media/platform/xilinx/xilinx-vtc.c
+++ b/drivers/media/platform/xilinx/xilinx-vtc.c
@@ -1,9 +1,11 @@
 /*
  * Xilinx Video Timing Controller
  *
- * Copyright (C) 2014 Ideas on Board SPRL
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
  *
- * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff --git a/drivers/media/platform/xilinx/xilinx-vtc.h b/drivers/media/platform/xilinx/xilinx-vtc.h
index 6140eac..e1bb2cf 100644
--- a/drivers/media/platform/xilinx/xilinx-vtc.h
+++ b/drivers/media/platform/xilinx/xilinx-vtc.h
@@ -1,9 +1,11 @@
 /*
  * Xilinx Video Timing Controller
  *
- * Copyright (C) 2014 Ideas on Board SPRL
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
  *
- * Contacts: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff --git a/include/uapi/linux/xilinx-v4l2-controls.h b/include/uapi/linux/xilinx-v4l2-controls.h
index 6c98963..bcf91cd 100644
--- a/include/uapi/linux/xilinx-v4l2-controls.h
+++ b/include/uapi/linux/xilinx-v4l2-controls.h
@@ -1,9 +1,11 @@
 /*
  * Xilinx Controls Header
  *
- * Copyright (C) 2013 - 2014 Xilinx, Inc.
+ * Copyright (C) 2013-2015 Ideas on Board
+ * Copyright (C) 2013-2015 Xilinx, Inc.
  *
- * Author: Hyun Woo Kwon <hyunk@xilinx.com>
+ * Contacts: Hyun Kwon <hyun.kwon@xilinx.com>
+ *           Laurent Pinchart <laurent.pinchart@ideasonboard.com>
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -67,6 +69,9 @@
 #define V4L2_CID_XILINX_TPG_STUCK_PIXEL_THRESH	(V4L2_CID_XILINX_TPG + 16)
 /* Noise level */
 #define V4L2_CID_XILINX_TPG_NOISE_GAIN		(V4L2_CID_XILINX_TPG + 17)
+/* Foreground pattern (HLS)*/
+#define V4L2_CID_XILINX_TPG_HLS_FG_PATTERN     (V4L2_CID_XILINX_TPG + 18)
+
 
 /*
  * Xilinx CRESAMPLE Video IP
-- 
2.9.3

