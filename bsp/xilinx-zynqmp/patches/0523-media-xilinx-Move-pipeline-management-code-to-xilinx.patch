From c06766f3b094a629750bb5ad3f94c3518d931c71 Mon Sep 17 00:00:00 2001
From: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Date: Wed, 26 Mar 2014 04:01:58 +0100
Subject: [PATCH 523/827] media: xilinx: Move pipeline management code to xilinx-dma.c

This patch comes from:
  https://github.com/Xilinx/linux-xlnx.git

More pipeline management code will be added to xilinx-dma.c to support
complex graphs with multiple pipelines. Move the code to prepare for
that and ensure that all pipeline management code will be grouped in one
place.

Signed-off-by: Laurent Pinchart <laurent.pinchart@ideasonboard.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
(cherry picked from commit de534cf4be6fba39f218d273e563de98837ac590)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/media/platform/xilinx/xilinx-dma.c  | 127 +++++++++++++++++++++++++++
 drivers/media/platform/xilinx/xilinx-vipp.c | 130 ----------------------------
 drivers/media/platform/xilinx/xilinx-vipp.h |   5 +-
 3 files changed, 130 insertions(+), 132 deletions(-)

diff --git a/drivers/media/platform/xilinx/xilinx-dma.c b/drivers/media/platform/xilinx/xilinx-dma.c
index 2364797..cf356d3 100644
--- a/drivers/media/platform/xilinx/xilinx-dma.c
+++ b/drivers/media/platform/xilinx/xilinx-dma.c
@@ -82,6 +82,133 @@ static int xvip_dma_verify_format(struct xvip_dma *dma)
 }
 
 /* -----------------------------------------------------------------------------
+ * Pipeline Stream Management
+ */
+
+/* Get the sink pad internally connected to a source pad in the given entity. */
+static struct media_pad *xvip_get_entity_sink(struct media_entity *entity,
+					      struct media_pad *source)
+{
+	unsigned int i;
+
+	/* The source pad can be NULL when the entity has no source pad. Return
+	 * the first pad in that case, guaranteed to be a sink pad.
+	 */
+	if (source == NULL)
+		return &entity->pads[0];
+
+	/* Iterates through the pads to find a connected sink pad. */
+	for (i = 0; i < entity->num_pads; ++i) {
+		struct media_pad *sink = &entity->pads[i];
+
+		if (!(sink->flags & MEDIA_PAD_FL_SINK))
+			continue;
+
+		if (sink == source)
+			continue;
+
+		if (media_entity_has_route(entity, sink->index, source->index))
+			return sink;
+	}
+
+	return NULL;
+}
+
+/**
+ * xvip_pipeline_start_stop - Start ot stop streaming on a pipeline
+ * @xdev: Xilinx video composite device
+ * @start: Start (when true) or stop (when false) the pipeline
+ *
+ * Walk the entities chain starting at the pipeline output video node and start
+ * or stop all of them.
+ *
+ * Return: 0 if successful, or the return value of the failed video::s_stream
+ * operation otherwise.
+ */
+static int xvip_pipeline_start_stop(struct xvip_composite_device *xdev,
+				    bool start)
+{
+	struct media_entity *entity;
+	struct media_pad *pad;
+	struct v4l2_subdev *subdev;
+	int ret;
+
+	entity = &xdev->dma[XVIPP_DMA_S2MM].video.entity;
+	pad = NULL;
+
+	while (1) {
+		pad = xvip_get_entity_sink(entity, pad);
+		if (IS_ERR(pad))
+			return PTR_ERR(pad);
+
+		if (!(pad->flags & MEDIA_PAD_FL_SINK))
+			break;
+
+		pad = media_entity_remote_pad(pad);
+		if (pad == NULL ||
+		    media_entity_type(pad->entity) != MEDIA_ENT_T_V4L2_SUBDEV)
+			break;
+
+		entity = pad->entity;
+		subdev = media_entity_to_v4l2_subdev(entity);
+
+		ret = v4l2_subdev_call(subdev, video, s_stream, start);
+		if (start && ret < 0 && ret != -ENOIOCTLCMD)
+			return ret;
+	}
+
+	return 0;
+}
+
+/**
+ * xvip_pipeline_set_stream - Enable/disable streaming on a pipeline
+ * @xdev: Xilinx video composite device
+ * @on: Turn the stream on when true or off when false
+ *
+ * The pipeline is shared between all DMA engines connect at its input and
+ * output. While the stream state of DMA engines can be controlled
+ * independently, pipelines have a shared stream state that enable or disable
+ * all entities in the pipeline. For this reason the pipeline uses a streaming
+ * counter that tracks the number of DMA engines that have requested the stream
+ * to be enabled.
+ *
+ * When called with the @on argument set to true, this function will increment
+ * the pipeline streaming count. If the streaming count reaches the number of
+ * DMA engines in the pipeline it will enable all entities that belong to the
+ * pipeline.
+ *
+ * Similarly, when called with the @on argument set to false, this function will
+ * decrement the pipeline streaming count and disable all entities in the
+ * pipeline when the streaming count reaches zero.
+ *
+ * Return: 0 if successful, or the return value of the failed video::s_stream
+ * operation otherwise. Stopping the pipeline never fails. The pipeline state is
+ * not updated when the operation fails.
+ */
+static int xvip_pipeline_set_stream(struct xvip_composite_device *xdev, bool on)
+{
+	int ret = 0;
+
+	mutex_lock(&xdev->lock);
+
+	if (on) {
+		if (xdev->stream_count == xdev->num_dmas - 1) {
+			ret = xvip_pipeline_start_stop(xdev, true);
+			if (ret < 0)
+				goto done;
+		}
+		xdev->stream_count++;
+	} else {
+		if (--xdev->stream_count == 0)
+			xvip_pipeline_start_stop(xdev, false);
+	}
+
+done:
+	mutex_unlock(&xdev->lock);
+	return ret;
+}
+
+/* -----------------------------------------------------------------------------
  * videobuf2 queue operations
  */
 
diff --git a/drivers/media/platform/xilinx/xilinx-vipp.c b/drivers/media/platform/xilinx/xilinx-vipp.c
index 1728a84..b6c6900 100644
--- a/drivers/media/platform/xilinx/xilinx-vipp.c
+++ b/drivers/media/platform/xilinx/xilinx-vipp.c
@@ -24,9 +24,6 @@
 #include "xilinx-dma.h"
 #include "xilinx-vipp.h"
 
-#define XVIPP_DMA_S2MM				0
-#define XVIPP_DMA_MM2S				1
-
 /**
  * struct xvip_graph_entity - Entity in the video graph
  * @list: list entry in a graph entities list
@@ -45,133 +42,6 @@ struct xvip_graph_entity {
 };
 
 /* -----------------------------------------------------------------------------
- * Pipeline Stream Management
- */
-
-/* Get the sink pad internally connected to a source pad in the given entity. */
-static struct media_pad *xvip_get_entity_sink(struct media_entity *entity,
-					      struct media_pad *source)
-{
-	unsigned int i;
-
-	/* The source pad can be NULL when the entity has no source pad. Return
-	 * the first pad in that case, guaranteed to be a sink pad.
-	 */
-	if (source == NULL)
-		return &entity->pads[0];
-
-	/* Iterates through the pads to find a connected sink pad. */
-	for (i = 0; i < entity->num_pads; ++i) {
-		struct media_pad *sink = &entity->pads[i];
-
-		if (!(sink->flags & MEDIA_PAD_FL_SINK))
-			continue;
-
-		if (sink == source)
-			continue;
-
-		if (media_entity_has_route(entity, sink->index, source->index))
-			return sink;
-	}
-
-	return NULL;
-}
-
-/**
- * xvip_pipeline_start_stop - Start ot stop streaming on a pipeline
- * @xdev: Xilinx video composite device
- * @start: Start (when true) or stop (when false) the pipeline
- *
- * Walk the entities chain starting at the pipeline output video node and start
- * or stop all of them.
- *
- * Return: 0 if successful, or the return value of the failed video::s_stream
- * operation otherwise.
- */
-static int xvip_pipeline_start_stop(struct xvip_composite_device *xdev,
-				    bool start)
-{
-	struct media_entity *entity;
-	struct media_pad *pad;
-	struct v4l2_subdev *subdev;
-	int ret;
-
-	entity = &xdev->dma[XVIPP_DMA_S2MM].video.entity;
-	pad = NULL;
-
-	while (1) {
-		pad = xvip_get_entity_sink(entity, pad);
-		if (IS_ERR(pad))
-			return PTR_ERR(pad);
-
-		if (!(pad->flags & MEDIA_PAD_FL_SINK))
-			break;
-
-		pad = media_entity_remote_pad(pad);
-		if (pad == NULL ||
-		    media_entity_type(pad->entity) != MEDIA_ENT_T_V4L2_SUBDEV)
-			break;
-
-		entity = pad->entity;
-		subdev = media_entity_to_v4l2_subdev(entity);
-
-		ret = v4l2_subdev_call(subdev, video, s_stream, start);
-		if (start && ret < 0 && ret != -ENOIOCTLCMD)
-			return ret;
-	}
-
-	return 0;
-}
-
-/**
- * xvip_pipeline_set_stream - Enable/disable streaming on a pipeline
- * @xdev: Xilinx video composite device
- * @on: Turn the stream on when true or off when false
- *
- * The pipeline is shared between all DMA engines connect at its input and
- * output. While the stream state of DMA engines can be controlled
- * independently, pipelines have a shared stream state that enable or disable
- * all entities in the pipeline. For this reason the pipeline uses a streaming
- * counter that tracks the number of DMA engines that have requested the stream
- * to be enabled.
- *
- * When called with the @on argument set to true, this function will increment
- * the pipeline streaming count. If the streaming count reaches the number of
- * DMA engines in the pipeline it will enable all entities that belong to the
- * pipeline.
- *
- * Similarly, when called with the @on argument set to false, this function will
- * decrement the pipeline streaming count and disable all entities in the
- * pipeline when the streaming count reaches zero.
- *
- * Return: 0 if successful, or the return value of the failed video::s_stream
- * operation otherwise. Stopping the pipeline never fails. The pipeline state is
- * not updated when the operation fails.
- */
-int xvip_pipeline_set_stream(struct xvip_composite_device *xdev, bool on)
-{
-	int ret = 0;
-
-	mutex_lock(&xdev->lock);
-
-	if (on) {
-		if (xdev->stream_count == xdev->num_dmas - 1) {
-			ret = xvip_pipeline_start_stop(xdev, true);
-			if (ret < 0)
-				goto done;
-		}
-		xdev->stream_count++;
-	} else {
-		if (--xdev->stream_count == 0)
-			xvip_pipeline_start_stop(xdev, false);
-	}
-
-done:
-	mutex_unlock(&xdev->lock);
-	return ret;
-}
-
-/* -----------------------------------------------------------------------------
  * Graph Management
  */
 
diff --git a/drivers/media/platform/xilinx/xilinx-vipp.h b/drivers/media/platform/xilinx/xilinx-vipp.h
index a60df86..07ca38f 100644
--- a/drivers/media/platform/xilinx/xilinx-vipp.h
+++ b/drivers/media/platform/xilinx/xilinx-vipp.h
@@ -22,6 +22,9 @@
 
 #include "xilinx-dma.h"
 
+#define XVIPP_DMA_S2MM				0
+#define XVIPP_DMA_MM2S				1
+
 /**
  * struct xvip_composite_device - Xilinx Video IP device structure
  * @v4l2_dev: V4L2 device
@@ -56,6 +59,4 @@ struct xvip_composite_device {
 	struct v4l2_ctrl_handler ctrl_handler;
 };
 
-int xvip_pipeline_set_stream(struct xvip_composite_device *xdev, bool on);
-
 #endif /* __XILINX_VIPP_H__ */
-- 
2.9.3

