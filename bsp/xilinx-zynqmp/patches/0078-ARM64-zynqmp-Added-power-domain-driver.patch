From 6087d967c9b0f104de4f145061f353708d713bd9 Mon Sep 17 00:00:00 2001
From: Filip Drazic <filip.drazic@aggios.com>
Date: Mon, 11 Jan 2016 15:34:41 -0800
Subject: [PATCH 078/827] ARM64: zynqmp: Added power domain driver

This patch comes from:
  https://github.com/Xilinx/linux-xlnx.git

The zynqmp-genpd driver communicates the usage requirements for logical
power domains / devices to the platform FW. FW is responsible for
choosing appropriate power states, taking Linux' usage information into
account.

Signed-off-by: Filip Drazic <filip.drazic@aggios.com>
Signed-off-by: Davorin Mista <davorin.mista@aggios.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
(cherry picked from commit c0babc6f661f7da6f6a5743ab62ef789bc86ecab)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/soc/xilinx/Kconfig             |  10 ++
 drivers/soc/xilinx/zynqmp/Makefile     |   1 +
 drivers/soc/xilinx/zynqmp/pm_domains.c | 177 +++++++++++++++++++++++++++++++++
 3 files changed, 188 insertions(+)
 create mode 100644 drivers/soc/xilinx/zynqmp/pm_domains.c

diff --git a/drivers/soc/xilinx/Kconfig b/drivers/soc/xilinx/Kconfig
index 285092a..2c6f44e 100644
--- a/drivers/soc/xilinx/Kconfig
+++ b/drivers/soc/xilinx/Kconfig
@@ -21,4 +21,14 @@ config ZYNQMP_PM_API_DEBUGFS
 	  Say yes to enable power domain management API requests through debugfs
 	  In doubt, say N
 
+config ZYNQMP_PM_DOMAINS
+	bool "Enable Zynq MPSoC generic PM domains"
+	default y
+	depends on ZYNQMP_PM_API
+	depends on PM
+	select PM_GENERIC_DOMAINS
+	help
+	  Say yes to enable device power management through PM domains
+	  In doubt, say N
+
 endif #SOC_XILINX_ZYNQMP
diff --git a/drivers/soc/xilinx/zynqmp/Makefile b/drivers/soc/xilinx/zynqmp/Makefile
index 9592e5a..b7ac33d 100644
--- a/drivers/soc/xilinx/zynqmp/Makefile
+++ b/drivers/soc/xilinx/zynqmp/Makefile
@@ -1 +1,2 @@
 obj-$(CONFIG_ZYNQMP_PM_API) += pm.o
+obj-$(CONFIG_ZYNQMP_PM_DOMAINS) += pm_domains.o
diff --git a/drivers/soc/xilinx/zynqmp/pm_domains.c b/drivers/soc/xilinx/zynqmp/pm_domains.c
new file mode 100644
index 0000000..c225591
--- /dev/null
+++ b/drivers/soc/xilinx/zynqmp/pm_domains.c
@@ -0,0 +1,177 @@
+/*
+ * ZynqMP Generic PM domain support
+ *
+ *  Copyright (C) 2015 Xilinx
+ *
+ *  Davorin Mista <davorin.mista@aggios.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/pm_domain.h>
+#include <linux/slab.h>
+#include <linux/soc/xilinx/zynqmp/pm.h>
+
+#define DRIVER_NAME "zynqmp_gpd"
+
+/**
+ * struct zynqmp_pm_domain - Wrapper around struct generic_pm_domain
+ * @gpd:		Generic power domain
+ * @node_id:	PM node id of a device inside PM domain
+ */
+struct zynqmp_pm_domain {
+	struct generic_pm_domain gpd;
+	u32 node_id;
+};
+
+/**
+ * zynqmp_gpd_req_device - request/release device in PM domain
+ * @domain:	Generic PM domain
+ * @power_on:	Flag to specify whether to power on or off PM domain
+ *
+ * Depending on power_on flag, this functions calls zynqmp_pm_req/release_node
+ * to inform PM firmware if it needs a resource (device inside PM domain).
+ *
+ * Return:	0 on success, error code otherwise.
+ */
+static int zynqmp_gpd_req_device(struct generic_pm_domain *domain,
+				 bool power_on)
+{
+	int status;
+	struct zynqmp_pm_domain *pd;
+
+	pd = container_of(domain, struct zynqmp_pm_domain, gpd);
+	if (pd->node_id == 0) {
+		pr_err("%s: unknown node specified, powering %s domain %s\n",
+			__func__, power_on ? "on" : "off", pd->gpd.name);
+		return -EINVAL;
+	}
+
+	if (!power_on)
+		status = zynqmp_pm_release_node(pd->node_id,
+						ZYNQMP_PM_MAX_LATENCY);
+	else
+		status = zynqmp_pm_request_node(pd->node_id,
+						ZYNQMP_PM_CAPABILITY_ACCESS,
+						ZYNQMP_PM_MAX_QOS,
+						ZYNQMP_PM_REQUEST_ACK_NO);
+	return status;
+}
+
+/**
+ * zynqmp_gpd_power_on - Power on PM domain
+ * @domain:	Generic PM domain
+ *
+ * This function is called before devices inside a PM domain are resumed, to
+ * power on PM domain.
+ *
+ * Return:	0 on success, error code otherwise.
+ */
+static int zynqmp_gpd_power_on(struct generic_pm_domain *domain)
+{
+	return zynqmp_gpd_req_device(domain, true);
+}
+
+/**
+ * zynqmp_gpd_power_off - Power off PM domain
+ * @domain:	Generic PM domain
+ *
+ * This function is called after devices inside a PM domain are suspended, to
+ * power off PM domain.
+ *
+ * Return:	0 on success, error code otherwise.
+ */
+static int zynqmp_gpd_power_off(struct generic_pm_domain *domain)
+{
+	return zynqmp_gpd_req_device(domain, false);
+}
+
+/**
+ * zynqmp_gpd_probe - Initialize ZynqMP specific PM domains
+ * @pdev:	Platform device pointer
+ *
+ * Description:	This function populates struct zynqmp_pm_domain for each PM
+ * domain and initalizes generic PM domain. If the "pd-id" DT property
+ * of a certain domain is missing or invalid, that domain will be skipped.
+ *
+ * Return:	0 on success, error code otherwise.
+ */
+static int __init zynqmp_gpd_probe(struct platform_device *pdev)
+{
+	int ret;
+	struct device_node *child_err, *child, *np = pdev->dev.of_node;
+
+	for_each_child_of_node(np, child) {
+		u32 node_id;
+		struct zynqmp_pm_domain *pd;
+
+		pd = devm_kzalloc(&pdev->dev, sizeof(*pd), GFP_KERNEL);
+		if (!pd) {
+			ret = -ENOMEM;
+			goto err_cleanup;
+		}
+
+		ret = of_property_read_u32(child, "pd-id", &node_id);
+		if (ret)
+			goto err_cleanup;
+
+		pd->node_id = node_id;
+		pd->gpd.name = kstrdup(child->name, GFP_KERNEL);
+		pd->gpd.power_off = zynqmp_gpd_power_off;
+		pd->gpd.power_on = zynqmp_gpd_power_on;
+
+		ret = of_genpd_add_provider_simple(child, &pd->gpd);
+		if (ret)
+			goto err_cleanup;
+
+		pm_genpd_init(&pd->gpd, NULL, false);
+	}
+
+	return 0;
+
+err_cleanup:
+	child_err = child;
+	for_each_child_of_node(np, child) {
+		if (child == child_err)
+			break;
+		of_genpd_del_provider(child);
+	}
+
+	return ret;
+}
+
+static const struct of_device_id zynqmp_gpd_of_match[] = {
+	{ .compatible = "xlnx,zynqmp-genpd" },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, zynqmp_gpd_of_match);
+
+static struct platform_driver zynqmp_gpd_platform_driver = {
+	.driver	= {
+		.name = DRIVER_NAME,
+		.of_match_table = zynqmp_gpd_of_match,
+	},
+};
+
+static __init int zynqmp_gpd_init(void)
+{
+	return platform_driver_probe(&zynqmp_gpd_platform_driver,
+				     zynqmp_gpd_probe);
+}
+subsys_initcall(zynqmp_gpd_init);
-- 
2.9.3

