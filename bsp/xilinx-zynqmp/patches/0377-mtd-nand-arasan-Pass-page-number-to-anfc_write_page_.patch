From 355ddebe77bc590ac64a2104a621ae136a68202b Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Tue, 27 Sep 2016 09:43:21 +0800
Subject: [PATCH 377/827] mtd: nand: arasan: Pass page number to anfc_write_page_hwecc

This patch comes from:
  https://github.com/Xilinx/linux-xlnx.git

This patch is to roll in all the commits up to 5ec1e958

There is a change in ecc.write_page prototype in 4.4 kernel
originated from below commit. Modified the driver as per the
new prototype.
"mtd: nand: pass page number to ecc->write_xxx() methods"
(sha1:45aaeff947190e4b57b2d0db4d74ab5eea450825)

Signed-off-by: Punnaiah Choudary Kalluri <punnaia@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/mtd/nand/Kconfig      |    6 +
 drivers/mtd/nand/Makefile     |    1 +
 drivers/mtd/nand/arasan_nfc.c | 1023 +++++++++++++++++++++++++++++++++++++++++
 drivers/mtd/nand/nand_base.c  |  263 +++++++++--
 drivers/mtd/nand/nand_bbt.c   |   28 +-
 drivers/mtd/nand/nand_ids.c   |    6 +-
 drivers/mtd/nand/nandsim.c    |   27 +-
 include/uapi/mtd/mtd-abi.h    |   13 +
 8 files changed, 1303 insertions(+), 64 deletions(-)
 create mode 100644 drivers/mtd/nand/arasan_nfc.c

diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index 5897d8d..1d57583 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -530,4 +530,10 @@ config MTD_NAND_HISI504
 	help
 	  Enables support for NAND controller on Hisilicon SoC Hip04.
 
+config MTD_NAND_ARASAN
+	tristate "Support for Arasan Nand Flash controller"
+	depends on MTD_NAND
+	help
+	  Enables the driver for the Arasan Nand Flash controller in ZynqMP SoC.
+
 endif # MTD_NAND
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 582bbd05..fd863ea 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -52,5 +52,6 @@ obj-$(CONFIG_MTD_NAND_XWAY)		+= xway_nand.o
 obj-$(CONFIG_MTD_NAND_BCM47XXNFLASH)	+= bcm47xxnflash/
 obj-$(CONFIG_MTD_NAND_SUNXI)		+= sunxi_nand.o
 obj-$(CONFIG_MTD_NAND_HISI504)	        += hisi504_nand.o
+obj-$(CONFIG_MTD_NAND_ARASAN)		+= arasan_nfc.o
 
 nand-objs := nand_base.o nand_bbt.o nand_timings.o
diff --git a/drivers/mtd/nand/arasan_nfc.c b/drivers/mtd/nand/arasan_nfc.c
new file mode 100644
index 0000000..a6f7cd3
--- /dev/null
+++ b/drivers/mtd/nand/arasan_nfc.c
@@ -0,0 +1,1023 @@
+/*
+ * Arasan Nand Flash Controller Driver
+ *
+ * Copyright (C) 2014 - 2015 Xilinx, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/of.h>
+#include <linux/of_mtd.h>
+#include <linux/platform_device.h>
+
+#define DRIVER_NAME			"arasan_nfc"
+#define EVNT_TIMEOUT			1000
+#define STATUS_TIMEOUT			2000
+
+#define PKT_OFST			0x00
+#define MEM_ADDR1_OFST			0x04
+#define MEM_ADDR2_OFST			0x08
+#define CMD_OFST			0x0C
+#define PROG_OFST			0x10
+#define INTR_STS_EN_OFST		0x14
+#define INTR_SIG_EN_OFST		0x18
+#define INTR_STS_OFST			0x1C
+#define READY_STS_OFST			0x20
+#define DMA_ADDR1_OFST			0x24
+#define FLASH_STS_OFST			0x28
+#define DATA_PORT_OFST			0x30
+#define ECC_OFST			0x34
+#define ECC_ERR_CNT_OFST		0x38
+#define ECC_SPR_CMD_OFST		0x3C
+#define ECC_ERR_CNT_1BIT_OFST		0x40
+#define ECC_ERR_CNT_2BIT_OFST		0x44
+#define DMA_ADDR0_OFST			0x50
+#define DATA_INTERFACE_REG		0x6C
+
+#define PKT_CNT_SHIFT			12
+
+#define ECC_ENABLE			BIT(31)
+#define DMA_EN_MASK			GENMASK(27, 26)
+#define DMA_ENABLE			0x2
+#define DMA_EN_SHIFT			26
+#define PAGE_SIZE_MASK			GENMASK(25, 23)
+#define PAGE_SIZE_SHIFT			23
+#define PAGE_SIZE_512			0
+#define PAGE_SIZE_1K			5
+#define PAGE_SIZE_2K			1
+#define PAGE_SIZE_4K			2
+#define PAGE_SIZE_8K			3
+#define PAGE_SIZE_16K			4
+#define CMD2_SHIFT			8
+#define ADDR_CYCLES_SHIFT		28
+
+#define XFER_COMPLETE			BIT(2)
+#define READ_READY			BIT(1)
+#define WRITE_READY			BIT(0)
+#define MBIT_ERROR			BIT(3)
+#define ERR_INTRPT			BIT(4)
+
+#define PROG_PGRD			BIT(0)
+#define PROG_ERASE			BIT(2)
+#define PROG_STATUS			BIT(3)
+#define PROG_PGPROG			BIT(4)
+#define PROG_RDID			BIT(6)
+#define PROG_RDPARAM			BIT(7)
+#define PROG_RST			BIT(8)
+#define PROG_GET_FEATURE		BIT(9)
+#define PROG_SET_FEATURE		BIT(10)
+
+#define ONFI_STATUS_FAIL		BIT(0)
+#define ONFI_STATUS_READY		BIT(6)
+
+#define PG_ADDR_SHIFT			16
+#define BCH_MODE_SHIFT			25
+#define BCH_EN_SHIFT			27
+#define ECC_SIZE_SHIFT			16
+
+#define MEM_ADDR_MASK			GENMASK(7, 0)
+#define BCH_MODE_MASK			GENMASK(27, 25)
+
+#define CS_MASK				GENMASK(31, 30)
+#define CS_SHIFT			30
+
+#define PAGE_ERR_CNT_MASK		GENMASK(16, 8)
+#define PKT_ERR_CNT_MASK		GENMASK(7, 0)
+
+#define NVDDR_MODE			BIT(9)
+#define NVDDR_TIMING_MODE_SHIFT		3
+
+#define ONFI_ID_LEN			8
+#define TEMP_BUF_SIZE			512
+#define NVDDR_MODE_PACKET_SIZE		8
+#define SDR_MODE_PACKET_SIZE		4
+
+/**
+ * struct anfc_ecc_matrix - Defines ecc information storage format
+ * @pagesize:		Page size in bytes.
+ * @codeword_size:	Code word size information.
+ * @eccbits:		Number of ecc bits.
+ * @bch:		Bch / Hamming mode enable/disable.
+ * @eccsize:		Ecc size information.
+ */
+struct anfc_ecc_matrix {
+	u32 pagesize;
+	u32 codeword_size;
+	u8 eccbits;
+	u8 bch;
+	u16 eccsize;
+};
+
+static const struct anfc_ecc_matrix ecc_matrix[] = {
+	{512,	512,	1,	0,	0x3},
+	{512,	512,	4,	1,	0x7},
+	{512,	512,	8,	1,	0xD},
+	/* 2K byte page */
+	{2048,	512,	1,	0,	0xC},
+	{2048,	512,	4,	1,	0x1A},
+	{2048,	512,	8,	1,	0x34},
+	{2048,	512,	12,	1,	0x4E},
+	{2048,	1024,	24,	1,	0x54},
+	/* 4K byte page */
+	{4096,	512,	1,	0,	0x18},
+	{4096,	512,	4,	1,	0x34},
+	{4096,	512,	8,	1,	0x68},
+	{4096,	512,	12,	1,	0x9C},
+	{4096,	1024,	24,	1,	0xA8},
+	/* 8K byte page */
+	{8192,	512,	1,	0,	0x30},
+	{8192,	512,	4,	1,	0x68},
+	{8192,	512,	8,	1,	0xD0},
+	{8192,	512,	12,	1,	0x138},
+	{8192,	1024,	24,	1,	0x150},
+	/* 16K byte page */
+	{16384,	512,	1,	0,	0x60},
+	{16384,	512,	4,	1,	0xD0},
+	{16384,	512,	8,	1,	0x1A0},
+	{16384,	512,	12,	1,	0x270},
+	{16384,	1024,	24,	1,	0x2A0}
+};
+
+/**
+ * struct anfc - Defines the Arasan NAND flash driver instance
+ * @chip:		NAND chip information structure.
+ * @mtd:		MTD information structure.
+ * @dev:		Pointer to the device structure.
+ * @base:		Virtual address of the NAND flash device.
+ * @curr_cmd:		Current command issued.
+ * @clk_sys:		Pointer to the system clock.
+ * @clk_flash:		Pointer to the flash clock.
+ * @dma:		Dma enable/disable.
+ * @bch:		Bch / Hamming mode enable/disable.
+ * @err:		Error identifier.
+ * @iswriteoob:		Identifies if oob write operation is required.
+ * @buf:		Buffer used for read/write byte operations.
+ * @raddr_cycles:	Row address cycle information.
+ * @caddr_cycles:	Column address cycle information.
+ * @irq:		irq number
+ * @pktsize:		Packet size for read / write operation.
+ * @bufshift:		Variable used for indexing buffer operation
+ * @rdintrmask:		Interrupt mask value for read operation.
+ * @num_cs:		Number of chip selects in use.
+ * @spktsize:		Packet size in ddr mode for status operation.
+ * @bufrdy:		Completion event for buffer ready.
+ * @xfercomp:		Completion event for transfer complete.
+ * @ecclayout:		Ecc layout object
+ */
+struct anfc {
+	struct nand_chip chip;
+	struct mtd_info mtd;
+	struct device *dev;
+
+	void __iomem *base;
+	int curr_cmd;
+	struct clk *clk_sys;
+	struct clk *clk_flash;
+
+	bool dma;
+	bool bch;
+	bool err;
+	bool iswriteoob;
+
+	u8 buf[TEMP_BUF_SIZE];
+
+	u16 raddr_cycles;
+	u16 caddr_cycles;
+
+	u32 irq;
+	u32 pktsize;
+	u32 bufshift;
+	u32 rdintrmask;
+	u32 num_cs;
+	u32 spktsize;
+
+	struct completion bufrdy;
+	struct completion xfercomp;
+	struct nand_ecclayout ecclayout;
+};
+
+static u8 anfc_page(u32 pagesize)
+{
+	switch (pagesize) {
+	case 512:
+		return PAGE_SIZE_512;
+	case 2048:
+		return PAGE_SIZE_2K;
+	case 4096:
+		return PAGE_SIZE_4K;
+	case 8192:
+		return PAGE_SIZE_8K;
+	case 16384:
+		return PAGE_SIZE_16K;
+	case 1024:
+		return PAGE_SIZE_1K;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static inline void anfc_enable_intrs(struct anfc *nfc, u32 val)
+{
+	writel(val, nfc->base + INTR_STS_EN_OFST);
+	writel(val, nfc->base + INTR_SIG_EN_OFST);
+}
+
+static int anfc_wait_for_event(struct anfc *nfc, u32 event)
+{
+	struct completion *comp;
+	int ret;
+
+	if (event == XFER_COMPLETE)
+		comp = &nfc->xfercomp;
+	else
+		comp = &nfc->bufrdy;
+
+	ret = wait_for_completion_timeout(comp, msecs_to_jiffies(EVNT_TIMEOUT));
+
+	return ret;
+}
+
+static inline void anfc_setpktszcnt(struct anfc *nfc, u32 pktsize,
+				    u32 pktcount)
+{
+	writel(pktsize | (pktcount << PKT_CNT_SHIFT), nfc->base + PKT_OFST);
+}
+
+static inline void anfc_set_eccsparecmd(struct anfc *nfc, u8 cmd1, u8 cmd2)
+{
+	writel(cmd1 | (cmd2 << CMD2_SHIFT) |
+	       (nfc->caddr_cycles << ADDR_CYCLES_SHIFT),
+	       nfc->base + ECC_SPR_CMD_OFST);
+}
+
+static void anfc_setpagecoladdr(struct anfc *nfc, u32 page, u16 col)
+{
+	u32 val;
+
+	writel(col | (page << PG_ADDR_SHIFT), nfc->base + MEM_ADDR1_OFST);
+
+	val = readl(nfc->base + MEM_ADDR2_OFST);
+	val = (val & ~MEM_ADDR_MASK) |
+	      ((page >> PG_ADDR_SHIFT) & MEM_ADDR_MASK);
+	writel(val, nfc->base + MEM_ADDR2_OFST);
+}
+
+static void anfc_prepare_cmd(struct anfc *nfc, u8 cmd1, u8 cmd2,
+			     u8 dmamode, u32 pagesize, u8 addrcycles)
+{
+	u32 regval;
+
+	regval = cmd1 | (cmd2 << CMD2_SHIFT);
+	if (dmamode && nfc->dma)
+		regval |= DMA_ENABLE << DMA_EN_SHIFT;
+	if (addrcycles)
+		regval |= addrcycles << ADDR_CYCLES_SHIFT;
+	if (pagesize)
+		regval |= anfc_page(pagesize) << PAGE_SIZE_SHIFT;
+	writel(regval, nfc->base + CMD_OFST);
+}
+
+static int anfc_device_ready(struct mtd_info *mtd,
+			     struct nand_chip *chip)
+{
+	u8 status;
+	unsigned long timeout = jiffies + STATUS_TIMEOUT;
+
+	do {
+		chip->cmdfunc(mtd, NAND_CMD_STATUS, 0, 0);
+		status = chip->read_byte(mtd);
+		if (status & ONFI_STATUS_READY) {
+			if (status & ONFI_STATUS_FAIL)
+				return NAND_STATUS_FAIL;
+			break;
+		}
+		cpu_relax();
+	} while (!time_after_eq(jiffies, timeout));
+
+	if (time_after_eq(jiffies, timeout)) {
+		pr_err("%s timed out\n", __func__);
+		return -ETIMEDOUT;
+	}
+
+	return 0;
+}
+
+static int anfc_read_oob(struct mtd_info *mtd, struct nand_chip *chip,
+			 int page)
+{
+	struct anfc *nfc = container_of(mtd, struct anfc, mtd);
+
+	chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+	if (nfc->dma)
+		nfc->rdintrmask = XFER_COMPLETE;
+	else
+		nfc->rdintrmask = READ_READY;
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	return 0;
+}
+
+static int anfc_write_oob(struct mtd_info *mtd, struct nand_chip *chip,
+			  int page)
+{
+	struct anfc *nfc = container_of(mtd, struct anfc, mtd);
+
+	nfc->iswriteoob = true;
+	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+	nfc->iswriteoob = false;
+
+	return 0;
+}
+
+static void anfc_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)
+{
+	u32 i, pktcount, buf_rd_cnt = 0, pktsize;
+	u32 *bufptr = (u32 *)buf;
+	struct anfc *nfc = container_of(mtd, struct anfc, mtd);
+	dma_addr_t paddr = 0;
+
+	if (nfc->curr_cmd == NAND_CMD_READ0) {
+		pktsize = nfc->pktsize;
+		if (mtd->writesize % pktsize)
+			pktcount = mtd->writesize / pktsize + 1;
+		else
+			pktcount = mtd->writesize / pktsize;
+	} else {
+		pktsize = len;
+		pktcount = 1;
+	}
+
+	anfc_setpktszcnt(nfc, pktsize, pktcount);
+
+	if (nfc->dma) {
+		paddr = dma_map_single(nfc->dev, buf, len, DMA_FROM_DEVICE);
+		if (dma_mapping_error(nfc->dev, paddr)) {
+			dev_err(nfc->dev, "Read buffer mapping error");
+			return;
+		}
+		writel(lower_32_bits(paddr), nfc->base + DMA_ADDR0_OFST);
+		writel(upper_32_bits(paddr), nfc->base + DMA_ADDR1_OFST);
+		anfc_enable_intrs(nfc, nfc->rdintrmask);
+		writel(PROG_PGRD, nfc->base + PROG_OFST);
+		anfc_wait_for_event(nfc, XFER_COMPLETE);
+		dma_unmap_single(nfc->dev, paddr, len, DMA_FROM_DEVICE);
+		return;
+	}
+
+	anfc_enable_intrs(nfc, nfc->rdintrmask);
+	writel(PROG_PGRD, nfc->base + PROG_OFST);
+
+	while (buf_rd_cnt < pktcount) {
+
+		anfc_wait_for_event(nfc, READ_READY);
+		buf_rd_cnt++;
+
+		if (buf_rd_cnt == pktcount)
+			anfc_enable_intrs(nfc, XFER_COMPLETE);
+
+		for (i = 0; i < pktsize / 4; i++)
+			bufptr[i] = readl(nfc->base + DATA_PORT_OFST);
+
+		bufptr += (pktsize / 4);
+
+		if (buf_rd_cnt < pktcount)
+			anfc_enable_intrs(nfc, nfc->rdintrmask);
+	}
+
+	anfc_wait_for_event(nfc, XFER_COMPLETE);
+}
+
+static void anfc_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
+{
+	u32 buf_wr_cnt = 0, pktcount = 1, i, pktsize;
+	u32 *bufptr = (u32 *)buf;
+	struct anfc *nfc = container_of(mtd, struct anfc, mtd);
+	dma_addr_t paddr = 0;
+
+	if (nfc->iswriteoob) {
+		pktsize = len;
+		pktcount = 1;
+	} else {
+		pktsize = nfc->pktsize;
+		pktcount = mtd->writesize / pktsize;
+	}
+
+	anfc_setpktszcnt(nfc, pktsize, pktcount);
+
+	if (nfc->dma) {
+		paddr = dma_map_single(nfc->dev, (void *)buf, len,
+				       DMA_TO_DEVICE);
+		if (dma_mapping_error(nfc->dev, paddr)) {
+			dev_err(nfc->dev, "Write buffer mapping error");
+			return;
+		}
+		writel(lower_32_bits(paddr), nfc->base + DMA_ADDR0_OFST);
+		writel(upper_32_bits(paddr), nfc->base + DMA_ADDR1_OFST);
+		anfc_enable_intrs(nfc, XFER_COMPLETE);
+		writel(PROG_PGPROG, nfc->base + PROG_OFST);
+		anfc_wait_for_event(nfc, XFER_COMPLETE);
+		dma_unmap_single(nfc->dev, paddr, len, DMA_TO_DEVICE);
+		return;
+	}
+
+	anfc_enable_intrs(nfc, WRITE_READY);
+	writel(PROG_PGPROG, nfc->base + PROG_OFST);
+
+	while (buf_wr_cnt < pktcount) {
+		anfc_wait_for_event(nfc, WRITE_READY);
+
+		buf_wr_cnt++;
+		if (buf_wr_cnt == pktcount)
+			anfc_enable_intrs(nfc, XFER_COMPLETE);
+
+		for (i = 0; i < (pktsize / 4); i++)
+			writel(bufptr[i], nfc->base + DATA_PORT_OFST);
+
+		bufptr += (pktsize / 4);
+
+		if (buf_wr_cnt < pktcount)
+			anfc_enable_intrs(nfc, WRITE_READY);
+	}
+
+	anfc_wait_for_event(nfc, XFER_COMPLETE);
+}
+
+static int anfc_read_page_hwecc(struct mtd_info *mtd,
+				struct nand_chip *chip, uint8_t *buf,
+				int oob_required, int page)
+{
+	u32 val;
+	struct anfc *nfc = container_of(mtd, struct anfc, mtd);
+
+	anfc_set_eccsparecmd(nfc, NAND_CMD_RNDOUT, NAND_CMD_RNDOUTSTART);
+
+	val = readl(nfc->base + CMD_OFST);
+	val = val | ECC_ENABLE;
+	writel(val, nfc->base + CMD_OFST);
+
+	if (nfc->dma)
+		nfc->rdintrmask = XFER_COMPLETE;
+	else
+		nfc->rdintrmask = READ_READY;
+
+	if (!nfc->bch)
+		nfc->rdintrmask = MBIT_ERROR;
+
+	chip->read_buf(mtd, buf, mtd->writesize);
+
+	val = readl(nfc->base + ECC_ERR_CNT_OFST);
+	if (nfc->bch) {
+		mtd->ecc_stats.corrected += val & PAGE_ERR_CNT_MASK;
+	} else {
+		val = readl(nfc->base + ECC_ERR_CNT_1BIT_OFST);
+		mtd->ecc_stats.corrected += val;
+		val = readl(nfc->base + ECC_ERR_CNT_2BIT_OFST);
+		mtd->ecc_stats.failed += val;
+		/* Clear ecc error count register 1Bit, 2Bit */
+		writel(0x0, nfc->base + ECC_ERR_CNT_1BIT_OFST);
+		writel(0x0, nfc->base + ECC_ERR_CNT_2BIT_OFST);
+	}
+	nfc->err = false;
+
+	if (oob_required)
+		chip->ecc.read_oob(mtd, chip, page);
+
+	return 0;
+}
+
+static int anfc_write_page_hwecc(struct mtd_info *mtd,
+				 struct nand_chip *chip, const uint8_t *buf,
+				 int oob_required, int page)
+{
+	u32 val, i;
+	struct anfc *nfc = container_of(mtd, struct anfc, mtd);
+	uint8_t *ecc_calc = chip->buffers->ecccalc;
+	uint32_t *eccpos = chip->ecc.layout->eccpos;
+
+	anfc_set_eccsparecmd(nfc, NAND_CMD_RNDIN, 0);
+
+	val = readl(nfc->base + CMD_OFST);
+	val = val | ECC_ENABLE;
+	writel(val, nfc->base + CMD_OFST);
+
+	chip->write_buf(mtd, buf, mtd->writesize);
+
+	if (oob_required) {
+		anfc_device_ready(mtd, chip);
+		chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+		if (nfc->dma)
+			nfc->rdintrmask = XFER_COMPLETE;
+		else
+			nfc->rdintrmask = READ_READY;
+		chip->read_buf(mtd, ecc_calc, mtd->oobsize);
+		for (i = 0; i < chip->ecc.total; i++)
+			chip->oob_poi[eccpos[i]] = ecc_calc[eccpos[i]];
+		chip->ecc.write_oob(mtd, chip, page);
+	}
+
+	return 0;
+}
+
+static u8 anfc_read_byte(struct mtd_info *mtd)
+{
+	struct anfc *nfc = container_of(mtd, struct anfc, mtd);
+
+	return nfc->buf[nfc->bufshift++];
+}
+
+static void anfc_writefifo(struct anfc *nfc, u32 prog, u32 size, u8 *buf)
+{
+	u32 i, *bufptr = (u32 *)buf;
+
+	anfc_enable_intrs(nfc, WRITE_READY);
+
+	writel(prog, nfc->base + PROG_OFST);
+	anfc_wait_for_event(nfc, WRITE_READY);
+
+	anfc_enable_intrs(nfc, XFER_COMPLETE);
+	for (i = 0; i < size / 4; i++)
+		writel(bufptr[i], nfc->base + DATA_PORT_OFST);
+
+	anfc_wait_for_event(nfc, XFER_COMPLETE);
+}
+
+static void anfc_readfifo(struct anfc *nfc, u32 prog, u32 size)
+{
+	u32 i, *bufptr = (u32 *)&nfc->buf[0];
+
+	anfc_enable_intrs(nfc, READ_READY);
+
+	writel(prog, nfc->base + PROG_OFST);
+	anfc_wait_for_event(nfc, READ_READY);
+
+	anfc_enable_intrs(nfc, XFER_COMPLETE);
+
+	for (i = 0; i < size / 4; i++)
+		bufptr[i] = readl(nfc->base + DATA_PORT_OFST);
+
+	anfc_wait_for_event(nfc, XFER_COMPLETE);
+}
+
+static int anfc_ecc_init(struct mtd_info *mtd,
+			 struct nand_ecc_ctrl *ecc)
+{
+	u32 oob_index, i, ecc_addr, regval, bchmode = 0;
+	struct nand_chip *nand_chip = mtd->priv;
+	struct anfc *nfc = container_of(mtd, struct anfc, mtd);
+	int found = -1;
+
+	nand_chip->ecc.mode = NAND_ECC_HW;
+	nand_chip->ecc.read_page = anfc_read_page_hwecc;
+	nand_chip->ecc.write_page = anfc_write_page_hwecc;
+	nand_chip->ecc.write_oob = anfc_write_oob;
+	nand_chip->ecc.read_oob = anfc_read_oob;
+
+	for (i = 0; i < sizeof(ecc_matrix) / sizeof(struct anfc_ecc_matrix);
+	     i++) {
+		if ((ecc_matrix[i].pagesize == mtd->writesize) &&
+		    (ecc_matrix[i].codeword_size >= nand_chip->ecc_step_ds)) {
+			if (ecc_matrix[i].eccbits >=
+			    nand_chip->ecc_strength_ds) {
+				found = i;
+				break;
+			}
+			found = i;
+		}
+	}
+
+	if (found < 0) {
+		dev_err(nfc->dev, "ECC scheme not supported");
+		return 1;
+	}
+	if (ecc_matrix[found].bch) {
+		switch (ecc_matrix[found].eccbits) {
+		case 12:
+			bchmode = 0x1;
+			break;
+		case 8:
+			bchmode = 0x2;
+			break;
+		case 4:
+			bchmode = 0x3;
+			break;
+		case 24:
+			bchmode = 0x4;
+			break;
+		default:
+			bchmode = 0x0;
+		}
+	}
+
+	nand_chip->ecc.strength = ecc_matrix[found].eccbits;
+	nand_chip->ecc.size = ecc_matrix[found].codeword_size;
+	nand_chip->ecc.steps = ecc_matrix[found].pagesize /
+			       ecc_matrix[found].codeword_size;
+	nand_chip->ecc.bytes = ecc_matrix[found].eccsize /
+			       nand_chip->ecc.steps;
+	nfc->ecclayout.eccbytes = ecc_matrix[found].eccsize;
+	nfc->bch = ecc_matrix[found].bch;
+	oob_index = mtd->oobsize - nfc->ecclayout.eccbytes;
+	ecc_addr = mtd->writesize + oob_index;
+
+	for (i = 0; i < nand_chip->ecc.size; i++)
+		nfc->ecclayout.eccpos[i] = oob_index + i;
+
+	nfc->ecclayout.oobfree->offset = 2;
+	nfc->ecclayout.oobfree->length = oob_index -
+					 nfc->ecclayout.oobfree->offset;
+
+	nand_chip->ecc.layout = &nfc->ecclayout;
+	regval = ecc_addr | (ecc_matrix[found].eccsize << ECC_SIZE_SHIFT) |
+		 (ecc_matrix[found].bch << BCH_EN_SHIFT);
+	writel(regval, nfc->base + ECC_OFST);
+
+	regval = readl(nfc->base + MEM_ADDR2_OFST);
+	regval = (regval & ~(BCH_MODE_MASK)) | (bchmode << BCH_MODE_SHIFT);
+	writel(regval, nfc->base + MEM_ADDR2_OFST);
+
+	if (nand_chip->ecc_step_ds >= 1024)
+		nfc->pktsize = 1024;
+	else
+		nfc->pktsize = 512;
+
+	return 0;
+}
+
+static void anfc_cmd_function(struct mtd_info *mtd,
+			      unsigned int cmd, int column, int page_addr)
+{
+	struct anfc *nfc = container_of(mtd, struct anfc, mtd);
+	bool wait = false, read = false;
+	u32 addrcycles, prog;
+	u32 *bufptr = (u32 *)&nfc->buf[0];
+
+	nfc->bufshift = 0;
+	nfc->curr_cmd = cmd;
+
+	if (page_addr == -1)
+		page_addr = 0;
+	if (column == -1)
+		column = 0;
+
+	switch (cmd) {
+	case NAND_CMD_RESET:
+		anfc_prepare_cmd(nfc, cmd, 0, 0, 0, 0);
+		prog = PROG_RST;
+		wait = true;
+		break;
+	case NAND_CMD_SEQIN:
+		addrcycles = nfc->raddr_cycles + nfc->caddr_cycles;
+		anfc_prepare_cmd(nfc, cmd, NAND_CMD_PAGEPROG, 1,
+				 mtd->writesize, addrcycles);
+		anfc_setpagecoladdr(nfc, page_addr, column);
+		break;
+	case NAND_CMD_READOOB:
+		column += mtd->writesize;
+	case NAND_CMD_READ0:
+	case NAND_CMD_READ1:
+		addrcycles = nfc->raddr_cycles + nfc->caddr_cycles;
+		anfc_prepare_cmd(nfc, NAND_CMD_READ0, NAND_CMD_READSTART, 1,
+				 mtd->writesize, addrcycles);
+		anfc_setpagecoladdr(nfc, page_addr, column);
+		break;
+	case NAND_CMD_RNDOUT:
+		anfc_prepare_cmd(nfc, cmd, NAND_CMD_RNDOUTSTART, 1,
+				 mtd->writesize, 2);
+		anfc_setpagecoladdr(nfc, page_addr, column);
+		if (nfc->dma)
+			nfc->rdintrmask = XFER_COMPLETE;
+		else
+			nfc->rdintrmask = READ_READY;
+		break;
+	case NAND_CMD_PARAM:
+		anfc_prepare_cmd(nfc, cmd, 0, 0, 0, 1);
+		anfc_setpagecoladdr(nfc, page_addr, column);
+		anfc_setpktszcnt(nfc, sizeof(struct nand_onfi_params), 1);
+		anfc_readfifo(nfc, PROG_RDPARAM,
+				sizeof(struct nand_onfi_params));
+		break;
+	case NAND_CMD_READID:
+		anfc_prepare_cmd(nfc, cmd, 0, 0, 0, 1);
+		anfc_setpagecoladdr(nfc, page_addr, column);
+		anfc_setpktszcnt(nfc, ONFI_ID_LEN, 1);
+		anfc_readfifo(nfc, PROG_RDID, ONFI_ID_LEN);
+		break;
+	case NAND_CMD_ERASE1:
+		addrcycles = nfc->raddr_cycles;
+		prog = PROG_ERASE;
+		anfc_prepare_cmd(nfc, cmd, NAND_CMD_ERASE2, 0, 0, addrcycles);
+		column = page_addr & 0xffff;
+		page_addr = (page_addr >> PG_ADDR_SHIFT) & 0xffff;
+		anfc_setpagecoladdr(nfc, page_addr, column);
+		wait = true;
+		break;
+	case NAND_CMD_STATUS:
+		anfc_prepare_cmd(nfc, cmd, 0, 0, 0, 0);
+		anfc_setpktszcnt(nfc, nfc->spktsize/4, 1);
+		anfc_setpagecoladdr(nfc, page_addr, column);
+		prog = PROG_STATUS;
+		wait = read = true;
+		break;
+	case NAND_CMD_GET_FEATURES:
+		anfc_prepare_cmd(nfc, cmd, 0, 0, 0, 1);
+		anfc_setpagecoladdr(nfc, page_addr, column);
+		anfc_setpktszcnt(nfc, nfc->spktsize, 1);
+		anfc_readfifo(nfc, PROG_GET_FEATURE, 4);
+		break;
+	case NAND_CMD_SET_FEATURES:
+		anfc_prepare_cmd(nfc, cmd, 0, 0, 0, 1);
+		anfc_setpagecoladdr(nfc, page_addr, column);
+		anfc_setpktszcnt(nfc, nfc->spktsize, 1);
+		break;
+	default:
+		return;
+	}
+
+	if (wait) {
+		anfc_enable_intrs(nfc, XFER_COMPLETE);
+		writel(prog, nfc->base + PROG_OFST);
+		anfc_wait_for_event(nfc, XFER_COMPLETE);
+	}
+
+	if (read)
+		bufptr[0] = readl(nfc->base + FLASH_STS_OFST);
+}
+
+static void anfc_select_chip(struct mtd_info *mtd, int num)
+{
+	u32 val;
+	struct anfc *nfc = container_of(mtd, struct anfc, mtd);
+
+	if (num == -1)
+		return;
+
+	val = readl(nfc->base + MEM_ADDR2_OFST);
+	val = (val & ~(CS_MASK)) | (num << CS_SHIFT);
+	writel(val, nfc->base + MEM_ADDR2_OFST);
+}
+
+static irqreturn_t anfc_irq_handler(int irq, void *ptr)
+{
+	struct anfc *nfc = ptr;
+	u32 regval = 0, status;
+
+	status = readl(nfc->base + INTR_STS_OFST);
+	if (status & XFER_COMPLETE) {
+		complete(&nfc->xfercomp);
+		regval |= XFER_COMPLETE;
+	}
+
+	if (status & READ_READY) {
+		complete(&nfc->bufrdy);
+		regval |= READ_READY;
+	}
+
+	if (status & WRITE_READY) {
+		complete(&nfc->bufrdy);
+		regval |= WRITE_READY;
+	}
+
+	if (status & MBIT_ERROR) {
+		nfc->err = true;
+		complete(&nfc->bufrdy);
+		regval |= MBIT_ERROR;
+	}
+
+	if (regval) {
+		writel(regval, nfc->base + INTR_STS_OFST);
+		writel(0, nfc->base + INTR_STS_EN_OFST);
+		writel(0, nfc->base + INTR_SIG_EN_OFST);
+
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_NONE;
+}
+
+static int anfc_onfi_set_features(struct mtd_info *mtd, struct nand_chip *chip,
+				  int addr, uint8_t *subfeature_param)
+{
+	int status;
+	struct anfc *nfc = container_of(mtd, struct anfc, mtd);
+
+	if (!chip->onfi_version || !(le16_to_cpu(chip->onfi_params.opt_cmd)
+		& ONFI_OPT_CMD_SET_GET_FEATURES))
+		return -EINVAL;
+
+	chip->cmdfunc(mtd, NAND_CMD_SET_FEATURES, addr, -1);
+	anfc_writefifo(nfc, PROG_SET_FEATURE, nfc->spktsize, subfeature_param);
+
+	status = chip->waitfunc(mtd, chip);
+	if (status & NAND_STATUS_FAIL)
+		return -EIO;
+
+	return 0;
+}
+
+static int anfc_init_timing_mode(struct anfc *nfc)
+{
+	int mode, err;
+	unsigned int feature[2], regval, i;
+	struct nand_chip *chip = &nfc->chip;
+	struct mtd_info *mtd = &nfc->mtd;
+
+	memset(&feature[0], 0, NVDDR_MODE_PACKET_SIZE);
+	mode = onfi_get_sync_timing_mode(chip);
+	/* Get nvddr timing modes */
+	mode = mode & 0xFF;
+	if (!mode) {
+		mode = onfi_get_async_timing_mode(&nfc->chip);
+		mode = fls(mode) - 1;
+		regval = mode;
+	} else {
+		mode = fls(mode) - 1;
+		regval = NVDDR_MODE | mode << NVDDR_TIMING_MODE_SHIFT;
+		mode |= ONFI_DATA_INTERFACE_NVDDR;
+	}
+
+	feature[0] = mode;
+	for (i = 0; i < nfc->num_cs; i++) {
+		chip->select_chip(mtd, i);
+		err = chip->onfi_set_features(mtd, chip,
+					ONFI_FEATURE_ADDR_TIMING_MODE,
+					(uint8_t *)&feature[0]);
+		if (err)
+			return err;
+	}
+	writel(regval, nfc->base + DATA_INTERFACE_REG);
+
+	if (mode & ONFI_DATA_INTERFACE_NVDDR)
+		nfc->spktsize = NVDDR_MODE_PACKET_SIZE;
+
+	return 0;
+}
+
+static int anfc_probe(struct platform_device *pdev)
+{
+	struct anfc *nfc;
+	struct mtd_info *mtd;
+	struct nand_chip *nand_chip;
+	struct resource *res;
+	struct mtd_part_parser_data ppdata;
+	int err;
+
+	nfc = devm_kzalloc(&pdev->dev, sizeof(*nfc), GFP_KERNEL);
+	if (!nfc)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	nfc->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(nfc->base))
+		return PTR_ERR(nfc->base);
+
+	mtd = &nfc->mtd;
+	nand_chip = &nfc->chip;
+	nand_chip->priv = nfc;
+	mtd->priv = nand_chip;
+	mtd->owner = THIS_MODULE;
+	mtd->name = DRIVER_NAME;
+	nfc->dev = &pdev->dev;
+	mtd->dev.parent = &pdev->dev;
+
+	nand_chip->cmdfunc = anfc_cmd_function;
+	nand_chip->waitfunc = anfc_device_ready;
+	nand_chip->chip_delay = 30;
+	nand_chip->read_buf = anfc_read_buf;
+	nand_chip->write_buf = anfc_write_buf;
+	nand_chip->read_byte = anfc_read_byte;
+	nand_chip->options = NAND_BUSWIDTH_AUTO | NAND_NO_SUBPAGE_WRITE;
+	nand_chip->bbt_options = NAND_BBT_USE_FLASH;
+	nand_chip->select_chip = anfc_select_chip;
+	nand_chip->onfi_set_features = anfc_onfi_set_features;
+	nfc->dma = of_property_read_bool(pdev->dev.of_node,
+					 "arasan,has-mdma");
+	nfc->num_cs = 1;
+	of_property_read_u32(pdev->dev.of_node, "num-cs", &nfc->num_cs);
+	platform_set_drvdata(pdev, nfc);
+	init_completion(&nfc->bufrdy);
+	init_completion(&nfc->xfercomp);
+	nfc->irq = platform_get_irq(pdev, 0);
+	if (nfc->irq < 0) {
+		dev_err(&pdev->dev, "request_irq failed\n");
+		return -ENXIO;
+	}
+	err = devm_request_irq(&pdev->dev, nfc->irq, anfc_irq_handler,
+			       0, "arasannfc", nfc);
+	if (err)
+		return err;
+	nfc->clk_sys = devm_clk_get(&pdev->dev, "clk_sys");
+	if (IS_ERR(nfc->clk_sys)) {
+		dev_err(&pdev->dev, "sys clock not found.\n");
+		return PTR_ERR(nfc->clk_sys);
+	}
+
+	nfc->clk_flash = devm_clk_get(&pdev->dev, "clk_flash");
+	if (IS_ERR(nfc->clk_flash)) {
+		dev_err(&pdev->dev, "flash clock not found.\n");
+		return PTR_ERR(nfc->clk_flash);
+	}
+
+	err = clk_prepare_enable(nfc->clk_sys);
+	if (err) {
+		dev_err(&pdev->dev, "Unable to enable sys clock.\n");
+		return err;
+	}
+
+	err = clk_prepare_enable(nfc->clk_flash);
+	if (err) {
+		dev_err(&pdev->dev, "Unable to enable flash clock.\n");
+		goto clk_dis_sys;
+	}
+
+	nfc->spktsize = SDR_MODE_PACKET_SIZE;
+	if (nand_scan_ident(mtd, nfc->num_cs, NULL)) {
+		err = -ENXIO;
+		dev_err(&pdev->dev, "nand_scan_ident for NAND failed\n");
+		goto clk_dis_all;
+	}
+	if (nand_chip->onfi_version) {
+		nfc->raddr_cycles = nand_chip->onfi_params.addr_cycles & 0xF;
+		nfc->caddr_cycles =
+				(nand_chip->onfi_params.addr_cycles >> 4) & 0xF;
+	} else {
+		/* For non-ONFI devices, configuring the address cyles as 5 */
+		nfc->raddr_cycles = nfc->caddr_cycles = 5;
+	}
+
+	if (anfc_init_timing_mode(nfc)) {
+		err = -ENXIO;
+		dev_err(&pdev->dev, "timing mode init failed\n");
+		goto clk_dis_all;
+	}
+
+	if (anfc_ecc_init(mtd, &nand_chip->ecc)) {
+		err = -ENXIO;
+		goto clk_dis_all;
+	}
+
+	if (nand_scan_tail(mtd)) {
+		err = -ENXIO;
+		dev_err(&pdev->dev, "nand_scan_tail for NAND failed\n");
+		goto clk_dis_all;
+	}
+
+	ppdata.of_node = pdev->dev.of_node;
+
+	err = mtd_device_parse_register(&nfc->mtd, NULL, &ppdata, NULL, 0);
+	if (err)
+		goto clk_dis_all;
+
+	return err;
+
+clk_dis_all:
+	clk_disable_unprepare(nfc->clk_flash);
+clk_dis_sys:
+	clk_disable_unprepare(nfc->clk_sys);
+
+	return err;
+}
+
+static int anfc_remove(struct platform_device *pdev)
+{
+	struct anfc *nfc = platform_get_drvdata(pdev);
+
+	clk_disable_unprepare(nfc->clk_sys);
+	clk_disable_unprepare(nfc->clk_flash);
+
+	nand_release(&nfc->mtd);
+
+	return 0;
+}
+
+static const struct of_device_id anfc_ids[] = {
+	{ .compatible = "arasan,nfc-v3p10" },
+	{  }
+};
+MODULE_DEVICE_TABLE(of, anfc_ids);
+
+static struct platform_driver anfc_driver = {
+	.driver = {
+		.name = DRIVER_NAME,
+		.of_match_table = anfc_ids,
+	},
+	.probe = anfc_probe,
+	.remove = anfc_remove,
+};
+module_platform_driver(anfc_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Xilinx, Inc");
+MODULE_DESCRIPTION("Arasan NAND Flash Controller Driver");
diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index c2e1232..e19389f 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -1,6 +1,4 @@
 /*
- *  drivers/mtd/nand.c
- *
  *  Overview:
  *   This is the generic MTD driver for NAND flash devices. It should be
  *   capable of working with almost all NAND chips currently available.
@@ -48,6 +46,7 @@
 #include <linux/leds.h>
 #include <linux/io.h>
 #include <linux/mtd/partitions.h>
+#include <linux/of_mtd.h>
 
 /* Define default oob placement schemes for large and small page devices */
 static struct nand_ecclayout nand_oob_8 = {
@@ -544,23 +543,32 @@ static void panic_nand_wait_ready(struct mtd_info *mtd, unsigned long timeo)
 	}
 }
 
-/* Wait for the ready pin, after a command. The timeout is caught later. */
+/**
+ * nand_wait_ready - [GENERIC] Wait for the ready pin after commands.
+ * @mtd: MTD device structure
+ *
+ * Wait for the ready pin after a command, and warn if a timeout occurs.
+ */
 void nand_wait_ready(struct mtd_info *mtd)
 {
 	struct nand_chip *chip = mtd->priv;
-	unsigned long timeo = jiffies + msecs_to_jiffies(20);
+	unsigned long timeo = 400;
 
-	/* 400ms timeout */
 	if (in_interrupt() || oops_in_progress)
-		return panic_nand_wait_ready(mtd, 400);
+		return panic_nand_wait_ready(mtd, timeo);
 
 	led_trigger_event(nand_led_trigger, LED_FULL);
 	/* Wait until command is processed or timeout occurs */
+	timeo = jiffies + msecs_to_jiffies(timeo);
 	do {
 		if (chip->dev_ready(mtd))
-			break;
-		touch_softlockup_watchdog();
+			goto out;
+		cond_resched();
 	} while (time_before(jiffies, timeo));
+
+	pr_warn_ratelimited(
+		"timeout while waiting for chip to become ready\n");
+out:
 	led_trigger_event(nand_led_trigger, LED_OFF);
 }
 EXPORT_SYMBOL_GPL(nand_wait_ready);
@@ -886,15 +894,13 @@ static void panic_nand_wait(struct mtd_info *mtd, struct nand_chip *chip,
  * @mtd: MTD device structure
  * @chip: NAND chip structure
  *
- * Wait for command done. This applies to erase and program only. Erase can
- * take up to 400ms and program up to 20ms according to general NAND and
- * SmartMedia specs.
+ * Wait for command done. This applies to erase and program only.
  */
 static int nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
 {
 
-	int status, state = chip->state;
-	unsigned long timeo = (state == FL_ERASING ? 400 : 20);
+	int status;
+	unsigned long timeo = 400;
 
 	led_trigger_event(nand_led_trigger, LED_FULL);
 
@@ -910,7 +916,7 @@ static int nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
 		panic_nand_wait(mtd, chip, timeo);
 	else {
 		timeo = jiffies + msecs_to_jiffies(timeo);
-		while (time_before(jiffies, timeo)) {
+		do {
 			if (chip->dev_ready) {
 				if (chip->dev_ready(mtd))
 					break;
@@ -919,7 +925,7 @@ static int nand_wait(struct mtd_info *mtd, struct nand_chip *chip)
 					break;
 			}
 			cond_resched();
-		}
+		} while (time_before(jiffies, timeo));
 	}
 	led_trigger_event(nand_led_trigger, LED_OFF);
 
@@ -1102,6 +1108,134 @@ out:
 EXPORT_SYMBOL(nand_lock);
 
 /**
+ * nand_check_erased_buf - check if a buffer contains (almost) only 0xff data
+ * @buf: buffer to test
+ * @len: buffer length
+ * @bitflips_threshold: maximum number of bitflips
+ *
+ * Check if a buffer contains only 0xff, which means the underlying region
+ * has been erased and is ready to be programmed.
+ * The bitflips_threshold specify the maximum number of bitflips before
+ * considering the region is not erased.
+ * Note: The logic of this function has been extracted from the memweight
+ * implementation, except that nand_check_erased_buf function exit before
+ * testing the whole buffer if the number of bitflips exceed the
+ * bitflips_threshold value.
+ *
+ * Returns a positive number of bitflips less than or equal to
+ * bitflips_threshold, or -ERROR_CODE for bitflips in excess of the
+ * threshold.
+ */
+static int nand_check_erased_buf(void *buf, int len, int bitflips_threshold)
+{
+	const unsigned char *bitmap = buf;
+	int bitflips = 0;
+	int weight;
+
+	for (; len && ((uintptr_t)bitmap) % sizeof(long);
+	     len--, bitmap++) {
+		weight = hweight8(*bitmap);
+		bitflips += BITS_PER_BYTE - weight;
+		if (unlikely(bitflips > bitflips_threshold))
+			return -EBADMSG;
+	}
+
+	for (; len >= sizeof(long);
+	     len -= sizeof(long), bitmap += sizeof(long)) {
+		weight = hweight_long(*((unsigned long *)bitmap));
+		bitflips += BITS_PER_LONG - weight;
+		if (unlikely(bitflips > bitflips_threshold))
+			return -EBADMSG;
+	}
+
+	for (; len > 0; len--, bitmap++) {
+		weight = hweight8(*bitmap);
+		bitflips += BITS_PER_BYTE - weight;
+		if (unlikely(bitflips > bitflips_threshold))
+			return -EBADMSG;
+	}
+
+	return bitflips;
+}
+
+/**
+ * nand_check_erased_ecc_chunk - check if an ECC chunk contains (almost) only
+ *				 0xff data
+ * @data: data buffer to test
+ * @datalen: data length
+ * @ecc: ECC buffer
+ * @ecclen: ECC length
+ * @extraoob: extra OOB buffer
+ * @extraooblen: extra OOB length
+ * @bitflips_threshold: maximum number of bitflips
+ *
+ * Check if a data buffer and its associated ECC and OOB data contains only
+ * 0xff pattern, which means the underlying region has been erased and is
+ * ready to be programmed.
+ * The bitflips_threshold specify the maximum number of bitflips before
+ * considering the region as not erased.
+ *
+ * Note:
+ * 1/ ECC algorithms are working on pre-defined block sizes which are usually
+ *    different from the NAND page size. When fixing bitflips, ECC engines will
+ *    report the number of errors per chunk, and the NAND core infrastructure
+ *    expect you to return the maximum number of bitflips for the whole page.
+ *    This is why you should always use this function on a single chunk and
+ *    not on the whole page. After checking each chunk you should update your
+ *    max_bitflips value accordingly.
+ * 2/ When checking for bitflips in erased pages you should not only check
+ *    the payload data but also their associated ECC data, because a user might
+ *    have programmed almost all bits to 1 but a few. In this case, we
+ *    shouldn't consider the chunk as erased, and checking ECC bytes prevent
+ *    this case.
+ * 3/ The extraoob argument is optional, and should be used if some of your OOB
+ *    data are protected by the ECC engine.
+ *    It could also be used if you support subpages and want to attach some
+ *    extra OOB data to an ECC chunk.
+ *
+ * Returns a positive number of bitflips less than or equal to
+ * bitflips_threshold, or -ERROR_CODE for bitflips in excess of the
+ * threshold. In case of success, the passed buffers are filled with 0xff.
+ */
+int nand_check_erased_ecc_chunk(void *data, int datalen,
+				void *ecc, int ecclen,
+				void *extraoob, int extraooblen,
+				int bitflips_threshold)
+{
+	int data_bitflips = 0, ecc_bitflips = 0, extraoob_bitflips = 0;
+
+	data_bitflips = nand_check_erased_buf(data, datalen,
+					      bitflips_threshold);
+	if (data_bitflips < 0)
+		return data_bitflips;
+
+	bitflips_threshold -= data_bitflips;
+
+	ecc_bitflips = nand_check_erased_buf(ecc, ecclen, bitflips_threshold);
+	if (ecc_bitflips < 0)
+		return ecc_bitflips;
+
+	bitflips_threshold -= ecc_bitflips;
+
+	extraoob_bitflips = nand_check_erased_buf(extraoob, extraooblen,
+						  bitflips_threshold);
+	if (extraoob_bitflips < 0)
+		return extraoob_bitflips;
+
+	if (data_bitflips)
+		memset(data, 0xff, datalen);
+
+	if (ecc_bitflips)
+		memset(ecc, 0xff, ecclen);
+
+	if (extraoob_bitflips)
+		memset(extraoob, 0xff, extraooblen);
+
+	return data_bitflips + ecc_bitflips + extraoob_bitflips;
+}
+EXPORT_SYMBOL(nand_check_erased_ecc_chunk);
+
+/**
  * nand_read_page_raw - [INTERN] read raw page data without ecc
  * @mtd: mtd info structure
  * @chip: nand chip info structure
@@ -2028,11 +2162,12 @@ out:
  * @chip: nand chip info structure
  * @buf: data buffer
  * @oob_required: must write chip->oob_poi to OOB
+ * @page: page number to write
  *
  * Not for syndrome calculating ECC controllers, which use a special oob layout.
  */
 static int nand_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
-				const uint8_t *buf, int oob_required)
+			       const uint8_t *buf, int oob_required, int page)
 {
 	chip->write_buf(mtd, buf, mtd->writesize);
 	if (oob_required)
@@ -2047,12 +2182,14 @@ static int nand_write_page_raw(struct mtd_info *mtd, struct nand_chip *chip,
  * @chip: nand chip info structure
  * @buf: data buffer
  * @oob_required: must write chip->oob_poi to OOB
+ * @page: page number to write
  *
  * We need a special oob layout and handling even when ECC isn't checked.
  */
 static int nand_write_page_raw_syndrome(struct mtd_info *mtd,
 					struct nand_chip *chip,
-					const uint8_t *buf, int oob_required)
+					const uint8_t *buf, int oob_required,
+					int page)
 {
 	int eccsize = chip->ecc.size;
 	int eccbytes = chip->ecc.bytes;
@@ -2089,9 +2226,11 @@ static int nand_write_page_raw_syndrome(struct mtd_info *mtd,
  * @chip: nand chip info structure
  * @buf: data buffer
  * @oob_required: must write chip->oob_poi to OOB
+ * @page: page number to write
  */
 static int nand_write_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
-				  const uint8_t *buf, int oob_required)
+				 const uint8_t *buf, int oob_required,
+				 int page)
 {
 	int i, eccsize = chip->ecc.size;
 	int eccbytes = chip->ecc.bytes;
@@ -2107,7 +2246,7 @@ static int nand_write_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
 	for (i = 0; i < chip->ecc.total; i++)
 		chip->oob_poi[eccpos[i]] = ecc_calc[i];
 
-	return chip->ecc.write_page_raw(mtd, chip, buf, 1);
+	return chip->ecc.write_page_raw(mtd, chip, buf, 1, page);
 }
 
 /**
@@ -2116,9 +2255,11 @@ static int nand_write_page_swecc(struct mtd_info *mtd, struct nand_chip *chip,
  * @chip: nand chip info structure
  * @buf: data buffer
  * @oob_required: must write chip->oob_poi to OOB
+ * @page: page number to write
  */
 static int nand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
-				  const uint8_t *buf, int oob_required)
+				  const uint8_t *buf, int oob_required,
+				  int page)
 {
 	int i, eccsize = chip->ecc.size;
 	int eccbytes = chip->ecc.bytes;
@@ -2150,11 +2291,12 @@ static int nand_write_page_hwecc(struct mtd_info *mtd, struct nand_chip *chip,
  * @data_len:	data length
  * @buf:	data buffer
  * @oob_required: must write chip->oob_poi to OOB
+ * @page: page number to write
  */
 static int nand_write_subpage_hwecc(struct mtd_info *mtd,
 				struct nand_chip *chip, uint32_t offset,
 				uint32_t data_len, const uint8_t *buf,
-				int oob_required)
+				int oob_required, int page)
 {
 	uint8_t *oob_buf  = chip->oob_poi;
 	uint8_t *ecc_calc = chip->buffers->ecccalc;
@@ -2209,13 +2351,15 @@ static int nand_write_subpage_hwecc(struct mtd_info *mtd,
  * @chip: nand chip info structure
  * @buf: data buffer
  * @oob_required: must write chip->oob_poi to OOB
+ * @page: page number to write
  *
  * The hw generator calculates the error syndrome automatically. Therefore we
  * need a special oob layout and handling.
  */
 static int nand_write_page_syndrome(struct mtd_info *mtd,
 				    struct nand_chip *chip,
-				    const uint8_t *buf, int oob_required)
+				    const uint8_t *buf, int oob_required,
+				    int page)
 {
 	int i, eccsize = chip->ecc.size;
 	int eccbytes = chip->ecc.bytes;
@@ -2279,12 +2423,13 @@ static int nand_write_page(struct mtd_info *mtd, struct nand_chip *chip,
 
 	if (unlikely(raw))
 		status = chip->ecc.write_page_raw(mtd, chip, buf,
-							oob_required);
+						  oob_required, page);
 	else if (subpage)
 		status = chip->ecc.write_subpage(mtd, chip, offset, data_len,
-							 buf, oob_required);
+						 buf, oob_required, page);
 	else
-		status = chip->ecc.write_page(mtd, chip, buf, oob_required);
+		status = chip->ecc.write_page(mtd, chip, buf, oob_required,
+					      page);
 
 	if (status < 0)
 		return status;
@@ -2622,7 +2767,15 @@ static int nand_do_write_oob(struct mtd_info *mtd, loff_t to,
 	 * if we don't do this. I have no clue why, but I seem to have 'fixed'
 	 * it in the doc2000 driver in August 1999.  dwmw2.
 	 */
-	chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
+	/*
+	 * Nand onfi compatible devices may support different data interface
+	 * modes like SDR, NVDDR and NVDDR2. Giving reset to device places the
+	 * device in to power-up state and places the target in the SDR data
+	 * interface mode. This will be the problem for devices configured for
+	 * NVDDR modes. So, limiting the reset operation to Toshiba devices.
+	 */
+	if (chip->onfi_params.jedec_id == NAND_MFR_TOSHIBA)
+		chip->cmdfunc(mtd, NAND_CMD_RESET, -1, -1);
 
 	/* Check, if it is write protected */
 	if (nand_check_wp(mtd)) {
@@ -2928,9 +3081,6 @@ static int nand_onfi_get_features(struct mtd_info *mtd, struct nand_chip *chip,
 	      & ONFI_OPT_CMD_SET_GET_FEATURES))
 		return -EINVAL;
 
-	/* clear the sub feature parameters */
-	memset(subfeature_param, 0, ONFI_SUBFEATURE_PARAM_LEN);
-
 	chip->cmdfunc(mtd, NAND_CMD_GET_FEATURES, addr, -1);
 	for (i = 0; i < ONFI_SUBFEATURE_PARAM_LEN; ++i)
 		*subfeature_param++ = chip->read_byte(mtd);
@@ -2968,7 +3118,7 @@ static void nand_resume(struct mtd_info *mtd)
  */
 static void nand_shutdown(struct mtd_info *mtd)
 {
-	nand_get_device(mtd, FL_SHUTDOWN);
+	nand_get_device(mtd, FL_PM_SUSPENDED);
 }
 
 /* Set default functions */
@@ -3156,6 +3306,12 @@ static int nand_flash_detect_onfi(struct mtd_info *mtd, struct nand_chip *chip,
 	int i, j;
 	int val;
 
+	/* ONFI need to be probed in 8 bits mode, and 16 bits should be selected with NAND_BUSWIDTH_AUTO */
+	if (chip->options & NAND_BUSWIDTH_16) {
+		pr_err("Trying ONFI probe in 16 bits mode, aborting !\n");
+		return 0;
+	}
+
 	/* Try ONFI for unknown chip or LP */
 	chip->cmdfunc(mtd, NAND_CMD_READID, 0x20, -1);
 	if (chip->read_byte(mtd) != 'O' || chip->read_byte(mtd) != 'N' ||
@@ -3689,7 +3845,7 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 			if (find_full_id_nand(mtd, chip, type, id_data, &busw))
 				goto ident_done;
 		} else if (*dev_id == type->dev_id) {
-				break;
+			break;
 		}
 	}
 
@@ -3712,10 +3868,7 @@ static struct nand_flash_dev *nand_get_flash_type(struct mtd_info *mtd,
 
 	chip->chipsize = (uint64_t)type->chipsize << 20;
 
-	if (!type->pagesize && chip->init_size) {
-		/* Set the pagesize, oobsize, erasesize by the driver */
-		busw = chip->init_size(mtd, chip, id_data);
-	} else if (!type->pagesize) {
+	if (!type->pagesize) {
 		/* Decode parameters from extended ID */
 		nand_decode_ext_id(mtd, chip, id_data, &busw);
 	} else {
@@ -3798,6 +3951,39 @@ ident_done:
 	return type;
 }
 
+static int nand_dt_init(struct mtd_info *mtd, struct nand_chip *chip,
+			struct device_node *dn)
+{
+	int ecc_mode, ecc_strength, ecc_step;
+
+	if (of_get_nand_bus_width(dn) == 16)
+		chip->options |= NAND_BUSWIDTH_16;
+
+	if (of_get_nand_on_flash_bbt(dn))
+		chip->bbt_options |= NAND_BBT_USE_FLASH;
+
+	ecc_mode = of_get_nand_ecc_mode(dn);
+	ecc_strength = of_get_nand_ecc_strength(dn);
+	ecc_step = of_get_nand_ecc_step_size(dn);
+
+	if ((ecc_step >= 0 && !(ecc_strength >= 0)) ||
+	    (!(ecc_step >= 0) && ecc_strength >= 0)) {
+		pr_err("must set both strength and step size in DT\n");
+		return -EINVAL;
+	}
+
+	if (ecc_mode >= 0)
+		chip->ecc.mode = ecc_mode;
+
+	if (ecc_strength >= 0)
+		chip->ecc.strength = ecc_strength;
+
+	if (ecc_step > 0)
+		chip->ecc.size = ecc_step;
+
+	return 0;
+}
+
 /**
  * nand_scan_ident - [NAND Interface] Scan for the NAND device
  * @mtd: MTD device structure
@@ -3815,6 +4001,13 @@ int nand_scan_ident(struct mtd_info *mtd, int maxchips,
 	int i, nand_maf_id, nand_dev_id;
 	struct nand_chip *chip = mtd->priv;
 	struct nand_flash_dev *type;
+	int ret;
+
+	if (chip->flash_node) {
+		ret = nand_dt_init(mtd, chip, chip->flash_node);
+		if (ret)
+			return ret;
+	}
 
 	/* Set the default functions */
 	nand_set_defaults(chip, chip->options & NAND_BUSWIDTH_16);
diff --git a/drivers/mtd/nand/nand_bbt.c b/drivers/mtd/nand/nand_bbt.c
index 9bb8453..b1d4f81 100644
--- a/drivers/mtd/nand/nand_bbt.c
+++ b/drivers/mtd/nand/nand_bbt.c
@@ -1,6 +1,4 @@
 /*
- *  drivers/mtd/nand_bbt.c
- *
  *  Overview:
  *   Bad block table support for the NAND driver
  *
@@ -64,7 +62,6 @@
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/bbm.h>
 #include <linux/mtd/nand.h>
-#include <linux/mtd/nand_ecc.h>
 #include <linux/bitops.h>
 #include <linux/delay.h>
 #include <linux/vmalloc.h>
@@ -720,7 +717,7 @@ static int write_bbt(struct mtd_info *mtd, uint8_t *buf,
 		/* Must we save the block contents? */
 		if (td->options & NAND_BBT_SAVECONTENT) {
 			/* Make it block aligned */
-			to &= ~((loff_t)((1 << this->bbt_erase_shift) - 1));
+			to &= ~(((loff_t)1 << this->bbt_erase_shift) - 1);
 			len = 1 << this->bbt_erase_shift;
 			res = mtd_read(mtd, to, len, &retlen, buf);
 			if (res < 0) {
@@ -1075,15 +1072,15 @@ static void verify_bbt_descr(struct mtd_info *mtd, struct nand_bbt_descr *bd)
  * The bad block table memory is allocated here. It must be freed by calling
  * the nand_free_bbt function.
  */
-int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
+static int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
 {
 	struct nand_chip *this = mtd->priv;
-	int len, res = 0;
+	int len, res;
 	uint8_t *buf;
 	struct nand_bbt_descr *td = this->bbt_td;
 	struct nand_bbt_descr *md = this->bbt_md;
 
-	len = mtd->size >> (this->bbt_erase_shift + 2);
+	len = (mtd->size >> (this->bbt_erase_shift + 2)) ? : 1;
 	/*
 	 * Allocate memory (2bit per block) and clear the memory bad block
 	 * table.
@@ -1099,10 +1096,9 @@ int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
 	if (!td) {
 		if ((res = nand_memory_bbt(mtd, bd))) {
 			pr_err("nand_bbt: can't scan flash and build the RAM-based BBT\n");
-			kfree(this->bbt);
-			this->bbt = NULL;
+			goto err;
 		}
-		return res;
+		return 0;
 	}
 	verify_bbt_descr(mtd, td);
 	verify_bbt_descr(mtd, md);
@@ -1112,9 +1108,8 @@ int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
 	len += (len >> this->page_shift) * mtd->oobsize;
 	buf = vmalloc(len);
 	if (!buf) {
-		kfree(this->bbt);
-		this->bbt = NULL;
-		return -ENOMEM;
+		res = -ENOMEM;
+		goto err;
 	}
 
 	/* Is the bbt at a given page? */
@@ -1126,6 +1121,8 @@ int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
 	}
 
 	res = check_create(mtd, buf, bd);
+	if (res)
+		goto err;
 
 	/* Prevent the bbt regions from erasing / writing */
 	mark_bbt_region(mtd, td);
@@ -1133,6 +1130,11 @@ int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
 		mark_bbt_region(mtd, md);
 
 	vfree(buf);
+	return 0;
+
+err:
+	kfree(this->bbt);
+	this->bbt = NULL;
 	return res;
 }
 
diff --git a/drivers/mtd/nand/nand_ids.c b/drivers/mtd/nand/nand_ids.c
index dd620c1..a8804a3 100644
--- a/drivers/mtd/nand/nand_ids.c
+++ b/drivers/mtd/nand/nand_ids.c
@@ -1,6 +1,4 @@
 /*
- *  drivers/mtd/nandids.c
- *
  *  Copyright (C) 2002 Thomas Gleixner (tglx@linutronix.de)
  *
  * This program is free software; you can redistribute it and/or modify
@@ -31,6 +29,10 @@ struct nand_flash_dev nand_flash_ids[] = {
 	 * listed by full ID. We list them first so that we can easily identify
 	 * the most specific match.
 	 */
+	{"TC58NVG0S3E 1G 3.3V 8-bit",
+		{ .id = {0x98, 0xd1, 0x90, 0x15, 0x76, 0x14, 0x01, 0x00} },
+		  SZ_2K, SZ_128, SZ_128K, 0, 8, 64, NAND_ECC_INFO(1, SZ_512),
+		  2 },
 	{"TC58NVG2S0F 4G 3.3V 8-bit",
 		{ .id = {0x98, 0xdc, 0x90, 0x26, 0x76, 0x15, 0x01, 0x08} },
 		  SZ_4K, SZ_512, SZ_256K, 0, 8, 224, NAND_ECC_INFO(4, SZ_512) },
diff --git a/drivers/mtd/nand/nandsim.c b/drivers/mtd/nand/nandsim.c
index f232427..b16d70a 100644
--- a/drivers/mtd/nand/nandsim.c
+++ b/drivers/mtd/nand/nandsim.c
@@ -729,8 +729,7 @@ static int init_nandsim(struct mtd_info *mtd)
 	/* Fill the partition_info structure */
 	if (parts_num > ARRAY_SIZE(ns->partitions)) {
 		NS_ERR("too many partitions.\n");
-		ret = -EINVAL;
-		goto error;
+		return -EINVAL;
 	}
 	remains = ns->geom.totsz;
 	next_offset = 0;
@@ -739,10 +738,13 @@ static int init_nandsim(struct mtd_info *mtd)
 
 		if (!part_sz || part_sz > remains) {
 			NS_ERR("bad partition size.\n");
-			ret = -EINVAL;
-			goto error;
+			return -EINVAL;
 		}
 		ns->partitions[i].name   = get_partition_name(i);
+		if (!ns->partitions[i].name) {
+			NS_ERR("unable to allocate memory.\n");
+			return -ENOMEM;
+		}
 		ns->partitions[i].offset = next_offset;
 		ns->partitions[i].size   = part_sz;
 		next_offset += ns->partitions[i].size;
@@ -752,10 +754,13 @@ static int init_nandsim(struct mtd_info *mtd)
 	if (remains) {
 		if (parts_num + 1 > ARRAY_SIZE(ns->partitions)) {
 			NS_ERR("too many partitions.\n");
-			ret = -EINVAL;
-			goto error;
+			return -EINVAL;
 		}
 		ns->partitions[i].name   = get_partition_name(i);
+		if (!ns->partitions[i].name) {
+			NS_ERR("unable to allocate memory.\n");
+			return -ENOMEM;
+		}
 		ns->partitions[i].offset = next_offset;
 		ns->partitions[i].size   = remains;
 		ns->nbparts += 1;
@@ -782,24 +787,18 @@ static int init_nandsim(struct mtd_info *mtd)
 	printk("options: %#x\n",                ns->options);
 
 	if ((ret = alloc_device(ns)) != 0)
-		goto error;
+		return ret;
 
 	/* Allocate / initialize the internal buffer */
 	ns->buf.byte = kmalloc(ns->geom.pgszoob, GFP_KERNEL);
 	if (!ns->buf.byte) {
 		NS_ERR("init_nandsim: unable to allocate %u bytes for the internal buffer\n",
 			ns->geom.pgszoob);
-		ret = -ENOMEM;
-		goto error;
+		return -ENOMEM;
 	}
 	memset(ns->buf.byte, 0xFF, ns->geom.pgszoob);
 
 	return 0;
-
-error:
-	free_device(ns);
-
-	return ret;
 }
 
 /*
diff --git a/include/uapi/mtd/mtd-abi.h b/include/uapi/mtd/mtd-abi.h
index 763bb69..7a1638a 100644
--- a/include/uapi/mtd/mtd-abi.h
+++ b/include/uapi/mtd/mtd-abi.h
@@ -276,6 +276,19 @@ enum mtd_file_modes {
 	MTD_FILE_MODE_RAW,
 };
 
+/*
+ * MTD locking states - return codes for ioctl(MEMISLOCKED)
+ *
+ * @MTD_IS_UNLOCKED:		Specified region is completely unlocked
+ * @MTD_IS_LOCKED:		Specified region is completely locked
+ * @MTD_IS_PARTIALLY_LOCKED:	Specified region is partially locked
+ */
+enum mtd_locking_states {
+	MTD_IS_UNLOCKED,
+	MTD_IS_LOCKED,
+	MTD_IS_PARTIALLY_LOCKED,
+};
+
 static inline int mtd_type_is_nand_user(const struct mtd_info_user *mtd)
 {
 	return mtd->type == MTD_NANDFLASH || mtd->type == MTD_MLCNANDFLASH;
-- 
2.9.3

