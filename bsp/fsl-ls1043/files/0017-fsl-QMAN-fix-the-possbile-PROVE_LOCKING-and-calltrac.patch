From 0db5e20b3bd71ee5d59693ecceee1de05fe7be65 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Wed, 31 Aug 2016 12:53:36 +0800
Subject: [PATCH 17/19] fsl QMAN: fix the possbile PROVE_LOCKING and calltraces

1. add flags to avoid the possible PROVE_LOCKING;
2. add irq_eanble to avoid in irq_disabled when return from send_first_frame
3. using get_cpu and put_cpu for more reasonble.

BUG: sleeping function called from invalid context at drivers/staging/fsl_qbman/qman_test_hotpotato.c:489
in_atomic(): 0, irqs_disabled(): 128, pid: 984, name: insmod
INFO: lockdep is turned off.
irq event stamp: 0
hardirqs last  enabled at (0): [<          (null)>]           (null)
hardirqs last disabled at (0): [<ffff80000009fee4>] copy_process.part.51+0x420/0x14b8
softirqs last  enabled at (0): [<ffff80000009fee4>] copy_process.part.51+0x420/0x14b8
softirqs last disabled at (0): [<          (null)>]           (null)

CPU: 3 PID: 984 Comm: insmod Tainted: G        WC      4.1.21-rt13-WR8.0.0.0_preempt-rt #34
Hardware name: LS1043A RDB Board (DT)
Call trace:
[<ffff80000008a8f0>] dump_backtrace+0x0/0x138
[<ffff80000008aa48>] show_stack+0x20/0x28
[<ffff8000009d09fc>] dump_stack+0xa4/0xe0
[ 2271.695847] [<ffff8000000d28d4>] ___might_sleep+0x170/0x24c
g[ 2271.695852] [<ffff8000000d2a10>] __might_sleep+0x60/0x9c
.[ 2271.695866] [<ffff7ffffc0a0d00>] qman_test_hotpotato+0x368/0x590 [qman_tester]
[<ffff7ffffc0a0014>] test_init+0x14/0x24 [qman_tester]
[<ffff8000000842f4>] do_one_initcall+0x94/0x1b8
[<ffff8000009cec80>] do_init_module+0x68/0x1b8
[<ffff80000013e67c>] load_module+0x1570/0x1f9c

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/staging/fsl_qbman/qman_high.c           | 11 +++++++----
 drivers/staging/fsl_qbman/qman_test_hotpotato.c |  7 +++----
 2 files changed, 10 insertions(+), 8 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index adb0d9d..57e0cd3 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -265,8 +265,9 @@ static DEFINE_RAW_SPINLOCK(fq_hash_table_lock);
 static int find_empty_fq_table_entry(u32 *entry, struct qman_fq *fq)
 {
 	u32 i;
+	unsigned long flags;
 
-	raw_spin_lock(&fq_hash_table_lock);
+	raw_spin_lock_irqsave(&fq_hash_table_lock, flags);
 	/* Can't use index zero because this has special meaning
 	 * in context_b field. */
 	for (i = 1; i < qman_fq_lookup_table_size; i++) {
@@ -277,16 +278,17 @@ static int find_empty_fq_table_entry(u32 *entry, struct qman_fq *fq)
 			return 0;
 		}
 	}
-	raw_spin_unlock(&fq_hash_table_lock);
+	raw_spin_unlock_irqrestore(&fq_hash_table_lock, flags);
 	return -ENOMEM;
 }
 
 static void clear_fq_table_entry(u32 entry)
 {
-	raw_spin_lock(&fq_hash_table_lock);
+	unsigned long flags;
+	raw_spin_lock_irqsave(&fq_hash_table_lock, flags);
 	BUG_ON(entry >= qman_fq_lookup_table_size);
 	qman_fq_lookup_table[entry] = NULL;
-	raw_spin_unlock(&fq_hash_table_lock);
+	raw_spin_unlock_irqrestore(&fq_hash_table_lock, flags);
 }
 
 static inline struct qman_fq *get_fq_table_entry(u32 entry)
@@ -2487,6 +2489,7 @@ static noinline struct qm_eqcr_entry *wait_eq_start(struct qman_portal **p,
 					u32 flags)
 {
 	struct qm_eqcr_entry *eq;
+	local_irq_enable();
 	if (flags & QMAN_ENQUEUE_FLAG_WAIT_INT)
 		/* NB: return NULL if signal occurs before completion. Signal
 		 * can occur during return. Caller must check for signal */
diff --git a/drivers/staging/fsl_qbman/qman_test_hotpotato.c b/drivers/staging/fsl_qbman/qman_test_hotpotato.c
index 85495da..27b4a44 100644
--- a/drivers/staging/fsl_qbman/qman_test_hotpotato.c
+++ b/drivers/staging/fsl_qbman/qman_test_hotpotato.c
@@ -434,7 +434,6 @@ static void send_first_frame(void *ignore)
 	int loop;
 	struct qm_fd fd;
 
-	BUG_ON(special_handler->processor_id != smp_processor_id());
 	memset(&fd, 0, sizeof(fd));
 	qm_fd_addr_set64(&fd, special_handler->addr);
 	fd.format = qm_fd_contig_big;
@@ -480,14 +479,14 @@ void qman_test_hotpotato(void)
 
 	init_phase3();
 
-	preempt_disable();
-	if (special_handler->processor_id == smp_processor_id())
+	if (special_handler->processor_id == get_cpu())
 		send_first_frame(NULL);
 	else
 		smp_call_function_single(special_handler->processor_id,
 			send_first_frame, NULL, 1);
-	preempt_enable();
 
+	put_cpu();
+	local_irq_enable();
 	wait_event(queue, loop_counter == HP_LOOPS);
 	deallocate_frame_data();
 	if (on_all_cpus(destroy_per_cpu_handlers))
-- 
2.8.1

