From d31b9a32ce644e50621a19fc5646fc09384b18a2 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Fri, 26 Aug 2016 15:28:01 +0800
Subject: [PATCH 15/15] dpaa_eth: fix non-meanings and wrong workaround on ls1043

According to TODO quote about HW issue in the header file dpaa_eth.h,
these removing codes are supposed to avoid frames larger than 4K or
that exceed 4K alignements, but actually, these codes self have a big
wrong issue as follows:

 -if (unlikely(HAS_DMA_ISSUE(frag, frag->size))) {
 +if (unlikely(HAS_DMA_ISSUE(skb_frag_page(frag), frag->size))) {

The second line should be right page address to be checked. And I have
double-check the address after having fixed these wrong frag, it turns
out these addresses are safe for big file copy and survived in the ltp
test suite.

And removing these codes can avoid the following calltrace as well:

WARNING: CPU: 0 PID: 0 at lib/dma-debug.c:1106 check_unmap+0xf8/0x9fc()
platform dpaa_eth_bpool.32: DMA-API: device driver frees DMA memory with different size [device address=0x00000000edc89000] [map size=1344 bytes] [unmap size=272 bytes]
CPU: 0 PID: 0 Comm: swapper/0 Not tainted 4.1.21-WR8.0.0.0_standard #29
Hardware name: LS1043A RDB Board (DT)
Call trace:
[<ffff80000008a3ac>] dump_backtrace+0x0/0x138
[<ffff80000008a504>] show_stack+0x20/0x28
[<ffff8000009340f0>] dump_stack+0x84/0xa8
[<ffff8000000a1814>] warn_slowpath_common+0xa8/0xdc
[<ffff8000000a18c0>] warn_slowpath_fmt+0x78/0x88
[<ffff80000047d190>] check_unmap+0xf8/0x9fc
[<ffff80000047db08>] debug_dma_unmap_page+0x74/0x7c
[<ffff80000067b3c0>] _dpa_cleanup_tx_fd+0x26c/0x3a4
[<ffff80000067a3b8>] priv_tx_conf_default_dqrr+0x94/0x200
[<ffff8000007d1384>] qman_p_poll_dqrr+0x234/0x304
[<ffff800000679f28>] dpaa_eth_poll+0x2c/0x64
[<ffff80000080a710>] net_rx_action+0x290/0x3bc
[<ffff8000000a5a10>] __do_softirq+0xd4/0x3b0
[<ffff8000000a5f44>] irq_exit+0x64/0xa0
[<ffff8000000ec0b4>] __handle_domain_irq+0x94/0xf8
[<ffff80000008247c>] gic_handle_irq+0x3c/0x88
Exception stack(0xffff800000d87db0 to 0xffff800000d87ed0)

They come from the split of the dma-mapped address into two parts, and
dma-unmap will pop out the warnings above.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/freescale/sdk_dpaa/dpaa_eth_sg.c | 16 ----------------
 1 file changed, 16 deletions(-)

diff --git a/drivers/net/ethernet/freescale/sdk_dpaa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/sdk_dpaa/dpaa_eth_sg.c
index 73f82e4..f49e515 100644
--- a/drivers/net/ethernet/freescale/sdk_dpaa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/sdk_dpaa/dpaa_eth_sg.c
@@ -866,22 +866,6 @@ int __hot skb_to_sg_fd(struct dpa_priv_s *priv,
 		/* keep the offset in the address */
 		qm_sg_entry_set64(&sgt[j], addr);
 
-		if (unlikely(HAS_DMA_ISSUE(frag, frag->size))) {
-			boundary = (dma_addr_t)BOUNDARY_4K(frag, frag->size);
-			qm_sg_entry_set_len(&sgt[j], (u64)boundary - (u64)frag);
-
-			j++;
-			qm_sg_entry_set_bpid(&sgt[j], 0xff);
-			qm_sg_entry_set_offset(&sgt[j], 0);
-			qm_sg_entry_set_len(&sgt[j], ((u64)frag->size -
-						((u64)boundary - (u64)frag)));
-			qm_sg_entry_set_ext(&sgt[j], 0);
-
-			/* keep the offset in the address */
-			qm_sg_entry_set64(&sgt[j], addr +
-					((u64)boundary - (u64)frag));
-		}
-
 		if (i == nr_frags)
 			qm_sg_entry_set_final(&sgt[j], 1);
 		else
-- 
2.8.1

