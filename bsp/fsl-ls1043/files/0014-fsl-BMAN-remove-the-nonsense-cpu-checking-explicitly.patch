From 61c2ec545b287d90bb1d657a85ba30bfdade0a9e Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Wed, 31 Aug 2016 15:20:57 +0800
Subject: [PATCH 14/18] fsl BMAN: remove the nonsense cpu checking explicitly

This patch is to remove the bad checking codes since their callers don't make
sure the same core, and the testing case will be crashed by this checking as
follows in the interrupt context:

cb_depletion: bpid=33, depleted=1, cpu=0, original=3
BUG: failure at drivers/staging/fsl_qbman/bman_test_thresh.c:62/cb_depletion()!
Kernel panic - not syncing: BUG!
CPU: 0 PID: 687 Comm: threshtest0 Tainted: G WC 4.1.21-WR8.0.0.0_standard #1
Hardware name: LS1043A RDB Board (DT)
Call trace:
[<ffff80000008a638>] dump_backtrace+0x0/0x128
[<ffff80000008a784>] show_stack+0x24/0x30
[<ffff8000009e02b8>] dump_stack+0x88/0xa8
[<ffff8000009dcd74>] panic+0xdc/0x218
[<ffff7ffffc0584d8>] cb_depletion+0xc8/0x110 [bman_tester]
[<ffff800000856d04>] __poll_portal_slow+0x2a4/0x318
[<ffff800000856db4>] portal_isr+0x3c/0x68
[<ffff8000000ee5c4>] handle_irq_event_percpu+0x6c/0x298
[<ffff8000000ee840>] handle_irq_event+0x50/0x80
[<ffff8000000f1d08>] handle_fasteoi_irq+0xf0/0x1b8
[<ffff8000000eda94>] generic_handle_irq+0x3c/0x58
[<ffff8000000ede04>] __handle_domain_irq+0x8c/0x100
[<ffff800000082480>] gic_handle_irq+0x40/0x90
Exception stack(0xffff80006f1b3c00 to 0xffff80006f1b3d20)
3c00: 7fd87800 ffff8000 00000001 00000000 6f1b3d40 ffff8000 00857afc ffff8000
3c20: 00000140 00000000 00000000 00000000 00190140 ffff0000 0badc1b3 91210000
3c40: 00000001 00000000 00000000 00000000 00fa44bc ffff8000 00000028 00000000
3c60: 00faf33b ffff8000 00000000 00000000 00000006 00000000 00000229 00000000
3c80: 00000001 00000000 00001d45 00000000 000c8000 00000000 00fc4902 ffff8000
3ca0: 6ee0ceb8 ffff8000 0042bbd0 00000000 00fc4cd8 ffff8000 7fd87800 ffff8000
3cc0: 00000001 00000000 00000001 00000000 00000001 00000000 fc0598c0 ffff7fff
3ce0: 7354ae00 ffff8000 75739850 ffff8000 00000000 00000000 00000000 00000000
3d00: 00000000 00000000 6f1b3d40 ffff8000 00857bc8 ffff8000 6f1b3d40 ffff8000

Because it is not enough for testing case to set the affinity on the producer,
the consumer(driver interrupt handler) should be set the same one as well.
But obviously the driver side should be set by the end user.

Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/staging/fsl_qbman/bman_test_thresh.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_test_thresh.c b/drivers/staging/fsl_qbman/bman_test_thresh.c
index 6709369..cb57442 100644
--- a/drivers/staging/fsl_qbman/bman_test_thresh.c
+++ b/drivers/staging/fsl_qbman/bman_test_thresh.c
@@ -58,9 +58,10 @@ static void cb_depletion(struct bman_portal *portal,
 	pr_info("cb_depletion: bpid=%d, depleted=%d, cpu=%d, original=%d\n",
 		bman_get_params(pool)->bpid, !!depleted, c, data->cpu);
 	/* We should be executing on the CPU of the thread that owns the pool if
-	 * and that CPU has an affine portal (ie. it isn't slaved). */
-	BUG_ON((c != data->cpu) && data->expect_affinity);
-	BUG_ON((c == data->cpu) && !data->expect_affinity);
+	 * and that CPU has an affine portal (ie. it isn't slaved).
+	 * BUG_ON((c != data->cpu) && data->expect_affinity);
+	 * BUG_ON((c == data->cpu) && !data->expect_affinity);
+	 */
 	if (depleted)
 		data->num_enter++;
 	else
-- 
2.7.4

