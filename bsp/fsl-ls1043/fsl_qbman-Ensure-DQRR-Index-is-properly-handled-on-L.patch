From 4c65ae9ea24e01669bb1baa4786acc853fbd8893 Mon Sep 17 00:00:00 2001
From: Roy Pledge <Roy.Pledge@freescale.com>
Date: Mon, 20 Jul 2015 16:18:39 -0400
Subject: [PATCH 426/451] fsl_qbman: Ensure DQRR Index is properly handled on
 LE systems

When QMan is being used by little endian cores the DQRR entiries
are copied and swapped before being given to the application. This
requires special handling of the DQRR index as it cannot be computed
using the DQRR address. In this case we store the index in an unused
part of the DQRR entry.

Signed-off-by: Roy Pledge <Roy.Pledge@freescale.com>
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/staging/fsl_qbman/qman_high.c |   54 ++++++++++++++++++--------------
 1 files changed, 30 insertions(+), 24 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 2baba08..9413b81 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -125,6 +125,15 @@ struct qman_portal {
 	u8 alloced;
 	/* power management data */
 	u32 save_isdr;
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+	/* Keep a shadow copy of the DQRR on LE systems
+	   as the SW needs to do byteswaps of read only
+	   memory.  Must be aligned to the size of the
+	   ring to ensure easy index calcualtions based
+	   on address */
+	struct qm_dqrr_entry shadow_dqrr[QM_DQRR_SIZE]
+	            __attribute__((aligned(512)));
+#endif
 };
 
 #ifdef CONFIG_FSL_DPA_PORTAL_SHARE
@@ -1074,19 +1083,31 @@ static noinline void clear_vdqcr(struct qman_portal *p, struct qman_fq *fq)
 static inline unsigned int __poll_portal_fast(struct qman_portal *p,
 					unsigned int poll_limit)
 {
-	const struct qm_dqrr_entry *dq, *actual_dq;
-#if defined(CONFIG_ARM64)
-	struct qm_dqrr_entry dq_swapped;
-#endif
+	const struct qm_dqrr_entry *dq;
 	struct qman_fq *fq;
 	enum qman_cb_dqrr_result res;
 	unsigned int limit = 0;
-
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+	struct qm_dqrr_entry *shadow;
+#endif
 loop:
 	qm_dqrr_pvb_update(&p->p);
-	actual_dq = dq = qm_dqrr_current(&p->p);
+	dq = qm_dqrr_current(&p->p);
 	if (!dq)
 		goto done;
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+	/* If running on an LE system the fields of the
+	   dequeue entry must be swapped.  Because the
+	   QMan HW will ignore writes the DQRR entry is
+	   copied and the index stored within the copy */
+	shadow = &p->shadow_dqrr[DQRR_PTR2IDX(dq)];
+	*shadow = *dq;
+	dq = shadow;
+	shadow->fqid = be32_to_cpu(shadow->fqid);
+	shadow->contextB = be32_to_cpu(shadow->contextB);
+	shadow->seqnum = be16_to_cpu(shadow->seqnum);
+	hw_fd_to_cpu(&shadow->fd);
+#endif
 	if (dq->stat & QM_DQRR_STAT_UNSCHEDULED) {
 		/* VDQCR: don't trust contextB as the FQ may have been
 		 * configured for h/w consumption and we're draining it
@@ -1100,15 +1121,7 @@ loop:
 		/* this is duplicated from the SDQCR code, but we have stuff to
 		 * do before *and* after this callback, and we don't want
 		 * multiple if()s in the critical path (SDQCR). */
-#if defined(CONFIG_ARM64)
-		dq_swapped = *dq;
-		dq_swapped.fqid = be32_to_cpu(dq_swapped.fqid);
-		dq_swapped.contextB = be32_to_cpu(dq_swapped.contextB);
-		hw_fd_to_cpu(&dq_swapped.fd);
-		res = fq->cb.dqrr(p, fq, &dq_swapped);
-#else
 		res = fq->cb.dqrr(p, fq, dq);
-#endif
 		if (res == qman_cb_dqrr_stop)
 			goto done;
 		/* Check for VDQCR completion */
@@ -1117,16 +1130,9 @@ loop:
 	} else {
 		/* SDQCR: contextB points to the FQ */
 #ifdef CONFIG_FSL_QMAN_FQ_LOOKUP
-		fq = get_fq_table_entry(be32_to_cpu(dq->contextB));
+		fq = get_fq_table_entry(dq->contextB);
 #else
-		fq = (void *)(uintptr_t)be32_to_cpu(dq->contextB);
-#endif
-#if defined(CONFIG_ARM64)
-		dq_swapped = *dq;
-		dq_swapped.fqid = be32_to_cpu(dq_swapped.fqid);
-		dq_swapped.contextB = be32_to_cpu(dq_swapped.contextB);
-		hw_fd_to_cpu(&dq_swapped.fd);
-		dq = &dq_swapped;
+		fq = (void *)(uintptr_t)dq->contextB;
 #endif
 		/* Now let the callback do its stuff */
 		res = fq->cb.dqrr(p, fq, dq);
@@ -1144,7 +1150,7 @@ loop:
 		(res != qman_cb_dqrr_park));
 	/* Defer just means "skip it, I'll consume it myself later on" */
 	if (res != qman_cb_dqrr_defer)
-		qm_dqrr_cdc_consume_1ptr(&p->p, actual_dq, (res == qman_cb_dqrr_park));
+		qm_dqrr_cdc_consume_1ptr(&p->p, dq, (res == qman_cb_dqrr_park));
 	/* Move forward */
 	qm_dqrr_next(&p->p);
 	/* Entry processed and consumed, increment our counter. The callback can
-- 
1.7.5.4

