From 23d630734d7dfc97546a69a329a043a47465fae9 Mon Sep 17 00:00:00 2001
From: Mandy Lavi <mandy.lavi@freescale.com>
Date: Thu, 11 Jun 2015 11:13:56 +0300
Subject: [PATCH 246/451] fmd: fix endianness issues around HC

Signed-off-by: Mandy Lavi <mandy.lavi@freescale.com>
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 .../freescale/fman/src/wrapper/lnxwrp_fm_port.c    |   53 ++++++++++++++++++++
 1 files changed, 53 insertions(+), 0 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c
index d201047..b7a8b5a 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c
@@ -94,6 +94,31 @@ static enum qman_cb_dqrr_result qm_tx_conf_dqrr_cb(struct qman_portal *portal,
 	t_LnxWrpFmDev *p_LnxWrpFmDev = ((t_FmTestFq *) fq)->h_Arg;
 	unsigned long flags;
 
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+{
+	/* extract the HC frame address */
+	uint64_t hcf_va = XX_PhysToVirt(((struct qm_fd *)&dq->fd)->addr);
+	int hcf_l = ((struct qm_fd *)&dq->fd)->length20;
+	int i;
+
+	/* 32b byteswap of all data in the HC Frame */
+	for(i = 0; i < hcf_l / 4; ++i)
+		((uint32_t *)(hcf_va))[i] =
+			___constant_swab32(((uint32_t *)(hcf_va))[i]);
+}
+{
+	/* byteswap FD's 40bit address field LE to BE*/
+	uint8_t t;
+
+	t = ((uint8_t*)&dq->fd)[6];
+	((uint8_t*)&dq->fd)[6] = ((uint8_t*)&dq->fd)[5];
+	((uint8_t*)&dq->fd)[5] = ((uint8_t*)&dq->fd)[4];
+	((uint8_t*)&dq->fd)[4] = ((uint8_t*)&dq->fd)[3];
+	((uint8_t*)&dq->fd)[3] = ((uint8_t*)&dq->fd)[7];
+	((uint8_t*)&dq->fd)[7] = t;
+}
+
+#endif
 	FM_PCD_HcTxConf(p_LnxWrpFmDev->h_PcdDev, (t_DpaaFD *)&dq->fd);
 	spin_lock_irqsave(&lock, flags);
 	hcFrmRcv--;
@@ -204,6 +229,34 @@ static t_Error QmEnqueueCB(t_Handle h_Arg, void *p_Fd)
 	hcFrmRcv++;
 	spin_unlock_irqrestore(&lock, flags);
 
+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
+{
+	/* byteswap FD's 40bit address field */
+	uint8_t t;
+
+	t = ((uint8_t*)p_Fd)[7];
+	((uint8_t*)p_Fd)[7] = ((uint8_t*)p_Fd)[3];
+	((uint8_t*)p_Fd)[3] = ((uint8_t*)p_Fd)[4];
+	((uint8_t*)p_Fd)[4] = ((uint8_t*)p_Fd)[5];
+	((uint8_t*)p_Fd)[5] = ((uint8_t*)p_Fd)[6];
+	((uint8_t*)p_Fd)[6] = t;
+}
+{
+	/* extract the HC frame address */
+	uint64_t hcf_va = XX_PhysToVirt(((struct qm_fd *) p_Fd)->addr);
+	int hcf_l = ((struct qm_fd *)p_Fd)->length20;
+	int i;
+
+	/* 32b byteswap of all data in the HC Frame */
+	for(i = 0; i < hcf_l / 4; ++i)
+		((uint32_t *)(hcf_va))[i] =
+			___constant_swab32(((uint32_t *)(hcf_va))[i]);
+}
+#endif
+
+
+printk("QmEnqueueCB>  p_Fd->addr 0x%llx \n",((struct qm_fd *) p_Fd)->addr);
+
 	_errno = qman_enqueue(p_LnxWrpFmDev->hc_tx_fq, (struct qm_fd *) p_Fd,
 			      0);
 	if (_errno)
-- 
1.7.5.4

