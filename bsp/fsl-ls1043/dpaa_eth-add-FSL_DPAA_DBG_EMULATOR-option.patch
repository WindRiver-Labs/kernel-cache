From b0c0fed6dea25b8a55e8787328cbd1428351c0e3 Mon Sep 17 00:00:00 2001
From: Marian-Cristian Rotariu <marian.rotariu@freescale.com>
Date: Thu, 9 Jul 2015 15:44:25 +0300
Subject: [PATCH 290/451] dpaa_eth: add FSL_DPAA_DBG_EMULATOR option

This patch adds FSL_DPAA_DBG_EMULATOR kconfig option that guards the low level
calls to hardware devices not emulated or simulated. With this option, the
Ethernet driver can be initialized and tested with traffic in the FSL emulator
or simulator.

Signed-off-by: Marian-Cristian Rotariu <marian.rotariu@freescale.com>
Change-Id: I70fd2f690076ebaf634356cf32ef079a4e839498
Reviewed-on: http://git.am.freescale.net:8181/39519
Reviewed-by: Madalin-Cristian Bucur <madalin.bucur@freescale.com>
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/Kconfig         |   13 +++++++++++++
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c      |    3 ++-
 .../net/ethernet/freescale/dpa/dpaa_eth_common.c   |   10 ++++++++++
 drivers/net/ethernet/freescale/dpa/mac-api.c       |    2 ++
 drivers/net/ethernet/freescale/dpa/mac.c           |    6 ++++++
 5 files changed, 33 insertions(+), 1 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/Kconfig b/drivers/net/ethernet/freescale/dpa/Kconfig
index 527a802..51a2a4c 100644
--- a/drivers/net/ethernet/freescale/dpa/Kconfig
+++ b/drivers/net/ethernet/freescale/dpa/Kconfig
@@ -184,4 +184,17 @@ config FSL_DPAA_DBG_LOOP
 		# echo 5 > /sys/kernel/debug/powerpc/fsl_dpa/eth4_loop
 		# cat /sys/kernel/debug/powerpc/fsl_dpa/eth4_loop
 			4->5
+
+config FSL_DPAA_DBG_EMULATOR
+	bool "DPAA Ethernet for FSL Networking Emulation"
+	depends on FSL_DPAA_ETH
+	default y
+	---help---
+	  The DPAA Ethernet driver can be used in one of the proprietary FSL
+	  emulator/simulator for debugging purposes. These tools do not emulate
+	  the PHY devices or do not fully emulate the MAC devices. Therefore,
+	  some of the low level calls should be properly masked. In this tool,
+	  the DPAA Ethernet driver should behave as close as possible to the
+	  DPAA Ethernet driver running on a hardware device.
+
 endif # FSL_DPAA_ETH
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index a5fb44f..a09f393 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -1007,6 +1007,7 @@ dpaa_eth_priv_probe(struct platform_device *_of_dev)
 	 * Must be executed after probing the MAC, but before
 	 * assigning the egress FQs to the CGRs.
 	 */
+#ifndef CONFIG_FSL_DPAA_DBG_EMULATOR
 	err = dpaa_eth_cgr_init(priv);
 	if (err < 0) {
 		dev_err(dev, "Error initializing CGR\n");
@@ -1017,7 +1018,7 @@ dpaa_eth_priv_probe(struct platform_device *_of_dev)
 		dev_err(dev, "Error initializing ingress CGR\n");
 		goto rx_cgr_init_failed;
 	}
-
+#endif
 	/* Add the FQs to the interface, and make them active */
 	list_for_each_entry_safe(dpa_fq, tmp, &priv->dpa_fq_list, list) {
 		err = dpa_fq_init(dpa_fq, false);
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
index b186449..3fdf350 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
@@ -148,12 +148,14 @@ int __cold dpa_start(struct net_device *net_dev)
 	priv = netdev_priv(net_dev);
 	mac_dev = priv->mac_dev;
 
+#ifndef CONFIG_FSL_DPAA_DBG_EMULATOR
 	err = mac_dev->init_phy(net_dev, priv->mac_dev);
 	if (err < 0) {
 		if (netif_msg_ifup(priv))
 			netdev_err(net_dev, "init_phy() = %d\n", err);
 		return err;
 	}
+#endif
 
 	for_each_port_device(i, mac_dev->port_dev) {
 		err = fm_port_enable(mac_dev->port_dev[i]);
@@ -161,12 +163,14 @@ int __cold dpa_start(struct net_device *net_dev)
 			goto mac_start_failed;
 	}
 
+#ifndef CONFIG_FSL_DPAA_DBG_EMULATOR
 	err = priv->mac_dev->start(mac_dev);
 	if (err < 0) {
 		if (netif_msg_ifup(priv))
 			netdev_err(net_dev, "mac_dev->start() = %d\n", err);
 		goto mac_start_failed;
 	}
+#endif
 
 	netif_tx_start_all_queues(net_dev);
 
@@ -195,20 +199,24 @@ int __cold dpa_stop(struct net_device *net_dev)
 	 */
 	usleep_range(5000, 10000);
 
+#ifndef CONFIG_FSL_DPAA_DBG_EMULATOR
 	_errno = mac_dev->stop(mac_dev);
 	if (unlikely(_errno < 0))
 		if (netif_msg_ifdown(priv))
 			netdev_err(net_dev, "mac_dev->stop() = %d\n",
 					_errno);
+#endif
 
 	for_each_port_device(i, mac_dev->port_dev) {
 		err = fm_port_disable(mac_dev->port_dev[i]);
 		_errno = err ? err : _errno;
 	}
 
+#ifndef CONFIG_FSL_DPAA_DBG_EMULATOR
 	if (mac_dev->phy_dev)
 		phy_disconnect(mac_dev->phy_dev);
 	mac_dev->phy_dev = NULL;
+#endif
 
 	return _errno;
 }
@@ -670,9 +678,11 @@ void dpa_set_rx_mode(struct net_device *net_dev)
 					   _errno);
 	}
 
+#ifndef CONFIG_FSL_DPAA_DBG_EMULATOR
 	_errno = priv->mac_dev->set_multi(net_dev, priv->mac_dev);
 	if (unlikely(_errno < 0) && netif_msg_drv(priv))
 		netdev_err(net_dev, "mac_dev->set_multi() = %d\n", _errno);
+#endif
 }
 EXPORT_SYMBOL(dpa_set_rx_mode);
 
diff --git a/drivers/net/ethernet/freescale/dpa/mac-api.c b/drivers/net/ethernet/freescale/dpa/mac-api.c
index e33b85c..036d0e2 100644
--- a/drivers/net/ethernet/freescale/dpa/mac-api.c
+++ b/drivers/net/ethernet/freescale/dpa/mac-api.c
@@ -274,12 +274,14 @@ static int __cold start(struct mac_device *mac_dev)
 
 	_errno = fm_mac_enable(mac_dev->get_mac_handle(mac_dev));
 
+#ifndef CONFIG_FSL_DPAA_DBG_EMULATOR
 	if (!_errno && phy_dev) {
 		if (macdev2enetinterface(mac_dev) != e_ENET_MODE_XGMII_10000)
 			phy_start(phy_dev);
 		else if (phy_dev->drv->read_status)
 			phy_dev->drv->read_status(phy_dev);
 	}
+#endif
 
 	return _errno;
 }
diff --git a/drivers/net/ethernet/freescale/dpa/mac.c b/drivers/net/ethernet/freescale/dpa/mac.c
index faf00a1..f6e4b3d 100644
--- a/drivers/net/ethernet/freescale/dpa/mac.c
+++ b/drivers/net/ethernet/freescale/dpa/mac.c
@@ -329,6 +329,10 @@ static int __cold mac_probe(struct platform_device *_of_dev)
 	} else
 		mac_dev->phy_if = str2phy(char_prop);
 
+#ifdef CONFIG_FSL_DPAA_DBG_EMULATOR
+	_errno = 0;
+#endif
+
 	mac_dev->link		= false;
 	mac_dev->half_duplex	= false;
 	mac_dev->speed		= phy2speed[mac_dev->phy_if];
@@ -381,9 +385,11 @@ static int __cold mac_probe(struct platform_device *_of_dev)
 	 */
 	mac_dev->rx_pause_req = mac_dev->tx_pause_req = true;
 	mac_dev->rx_pause_active = mac_dev->tx_pause_active = false;
+#ifndef CONFIG_FSL_DPAA_DBG_EMULATOR
 	_errno = set_mac_active_pause(mac_dev, true, true);
 	if (unlikely(_errno < 0))
 		dev_err(dev, "set_mac_active_pause() = %d\n", _errno);
+#endif
 
 	dev_info(dev,
 		"FMan MAC address: %02hx:%02hx:%02hx:%02hx:%02hx:%02hx\n",
-- 
1.7.5.4

