From 16b6ea2348fb31266862a5780a193cac24ba1ce6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Horia=20Geant=C4=83?= <horia.geanta@freescale.com>
Date: Fri, 10 Jul 2015 13:28:57 +0300
Subject: [PATCH 304/451] crypto: caam/qi - endianness fixes
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Change-Id: Iaf845c71ad5f0b1e54cd8373ef384a56a3e9d3ba
Signed-off-by: Horia GeantÄƒ <horia.geanta@freescale.com>
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/crypto/caam/qi.c       |    7 +++++--
 drivers/crypto/caam/sg_sw_qm.h |   15 +++++++++++++++
 2 files changed, 20 insertions(+), 2 deletions(-)

diff --git a/drivers/crypto/caam/qi.c b/drivers/crypto/caam/qi.c
index e6911b2a..ea75389 100644
--- a/drivers/crypto/caam/qi.c
+++ b/drivers/crypto/caam/qi.c
@@ -14,6 +14,7 @@
 #include "desc.h"
 #include "intern.h"
 #include "desc_constr.h"
+#include "sg_sw_qm.h"
 
 #define PRE_HDR_LEN		2	/* Length in u32 words */
 #define PREHDR_RSLS_SHIFT	31
@@ -102,6 +103,8 @@ int caam_qi_enqueue(struct device *qidev, struct caam_drv_req *req)
 	fd.format = qm_fd_compound;
 	fd.cong_weight = req->fd_sgt[1].length;
 
+	cpu_to_hw_sg(&req->fd_sgt[0]);
+	cpu_to_hw_sg(&req->fd_sgt[1]);
 	fd.addr = dma_map_single(qidev, req->fd_sgt, size,
 				 DMA_BIDIRECTIONAL);
 	if (dma_mapping_error(qidev, fd.addr)) {
@@ -361,7 +364,7 @@ int caam_drv_ctx_update(struct caam_drv_ctx *drv_ctx, u32 *sh_desc)
 	 * Now update the shared descriptor for driver context.
 	 * Re-initialise pre-header. Set RSLS and SDLEN
 	 */
-	drv_ctx->prehdr[0] = (1 << PREHDR_RSLS_SHIFT) | num_words;
+	drv_ctx->prehdr[0] = wr_en_val32((1 << PREHDR_RSLS_SHIFT) | num_words);
 
 	/* Copy the new shared descriptor now */
 	memcpy(drv_ctx->sh_desc, sh_desc, desc_bytes(sh_desc));
@@ -426,7 +429,7 @@ struct caam_drv_ctx *caam_drv_ctx_init(struct device *qidev,
 	}
 
 	/* Initialise pre-header. Set RSLS and SDLEN */
-	drv_ctx->prehdr[0] = (1 << PREHDR_RSLS_SHIFT) | num_words;
+	drv_ctx->prehdr[0] = wr_en_val32((1 << PREHDR_RSLS_SHIFT) | num_words);
 
 	/* Copy the shared descriptor now */
 	memcpy(drv_ctx->sh_desc, sh_desc, desc_bytes(sh_desc));
diff --git a/drivers/crypto/caam/sg_sw_qm.h b/drivers/crypto/caam/sg_sw_qm.h
index 778e4be..e878c75 100644
--- a/drivers/crypto/caam/sg_sw_qm.h
+++ b/drivers/crypto/caam/sg_sw_qm.h
@@ -33,6 +33,16 @@
 #define __SG_SW_QM_H
 
 #include "linux/fsl_qman.h"
+#include "regs.h"
+
+static inline void cpu_to_hw_sg(struct qm_sg_entry *qm_sg_ptr)
+{
+	dma_addr_t addr = qm_sg_ptr->addr;
+
+	qm_sg_ptr->addr_hi = (uint8_t)upper_32_bits(addr);
+	qm_sg_ptr->addr_lo = wr_en_val32(lower_32_bits(addr));
+	qm_sg_ptr->sgt_efl = wr_en_val32(qm_sg_ptr->sgt_efl);
+}
 
 static inline void dma_to_qm_sg_one(struct qm_sg_entry *qm_sg_ptr,
 				      dma_addr_t dma, u32 len, u16 offset)
@@ -45,6 +55,8 @@ static inline void dma_to_qm_sg_one(struct qm_sg_entry *qm_sg_ptr,
 	qm_sg_ptr->bpid = 0;
 	qm_sg_ptr->__reserved3 = 0;
 	qm_sg_ptr->offset = offset & QM_SG_OFFSET_MASK;
+
+	cpu_to_hw_sg(qm_sg_ptr);
 }
 
 /*
@@ -75,7 +87,10 @@ static inline void sg_to_qm_sg_last(struct scatterlist *sg, int sg_count,
 				      u16 offset)
 {
 	qm_sg_ptr = sg_to_qm_sg(sg, sg_count, qm_sg_ptr, offset);
+
+	qm_sg_ptr->sgt_efl = rd_en_val32(qm_sg_ptr->sgt_efl);
 	qm_sg_ptr->final = 1;
+	qm_sg_ptr->sgt_efl = wr_en_val32(qm_sg_ptr->sgt_efl);
 }
 
 #endif /* __SG_SW_QM_H */
-- 
1.7.5.4

