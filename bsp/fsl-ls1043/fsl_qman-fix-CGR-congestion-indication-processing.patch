From c8ae08b173fa24c2aac1dbe7b2a8c7b874ae03c5 Mon Sep 17 00:00:00 2001
From: Alex Porosanu <alexandru.porosanu@freescale.com>
Date: Tue, 4 Aug 2015 23:32:48 +0300
Subject: [PATCH 437/451] fsl_qman: fix CGR congestion indication processing

QM_MCR_QUERYCONGESTION macro checks if the corresponding bit for
the CGR is set in the "query congestion" command response. If
the corresponding bit is set (meaning that the respective CGR
is in a congested state), then the corresponding callback
is called.
The bit-checking must be done by taking into account the difference
between the DPAA block's and the core's endianness.

Note: improper functioning of CGR callback (i.e. not being called
even if congestion is present) leads to packets being accumulated
in one or more FQs which will eventually lead in the end to
exhausting all the system memory (OOM)

Signed-off-by: Alex Porosanu <alexandru.porosanu@freescale.com>
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 include/linux/fsl_qman.h |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index 8628e1c..60eb91d 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -1632,7 +1632,8 @@ struct qm_mc_result {
 static inline int QM_MCR_QUERYCONGESTION(struct __qm_mcr_querycongestion *p,
 					u8 cgr)
 {
-	return p->__state[__CGR_WORD(cgr)] & (0x80000000 >> __CGR_SHIFT(cgr));
+	return be32_to_cpu(p->__state[__CGR_WORD(cgr)]) &
+	       (0x80000000 >> __CGR_SHIFT(cgr));
 }
 
 
-- 
1.7.5.4

