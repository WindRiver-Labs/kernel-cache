From 0734c1dd3683ae7e4e721bad770a30c00f739c35 Mon Sep 17 00:00:00 2001
From: Marian-Cristian Rotariu <marian.rotariu@freescale.com>
Date: Tue, 17 Feb 2015 18:15:29 +0200
Subject: [PATCH 154/451] dpaa_eth: fix the bitfields of a FD

In LE architectures the bitfields are switched also. Therefore the order of the
bitfields is dependent on the architecture.

There is no need to set high and low addresses separately. arm64 will fetch only
the first 40 bits anyway.

Signed-off-by: Marian-Cristian Rotariu <marian.rotariu@freescale.com>
Change-Id: I2434c245ac30f7f024f5225c316dfb486c25045a
Reviewed-on: http://git.am.freescale.net:8181/31273
Reviewed-by: Yang Li <LeoLi@freescale.com>
Tested-by: Yang Li <LeoLi@freescale.com>
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c |    4 ++--
 include/linux/fsl_qman.h                         |   16 ++++++++++++++++
 2 files changed, 18 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index 3e47bf7..5443a7d 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -722,8 +722,8 @@ static int __hot skb_to_contig_fd(struct dpa_priv_s *priv,
 			netdev_err(net_dev, "dma_map_single() failed\n");
 		return -EINVAL;
 	}
-	fd->addr_hi = (uint8_t)upper_32_bits(addr);
-	fd->addr_lo = lower_32_bits(addr);
+	fd->addr = addr;
+
 
 	return 0;
 }
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index ddcc877..418d5d4 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -185,19 +185,35 @@ struct qm_fd {
 		u32 opaque;
 		/* If 'format' is _contig or _sg, 20b length and 9b offset */
 		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 			enum qm_fd_format format:3;
 			u16 offset:9;
 			u32 length20:20;
+#else
+			u32 length20:20;
+			u16 offset:9;
+			enum qm_fd_format format:3;
+#endif
 		};
 		/* If 'format' is _contig_big or _sg_big, 29b length */
 		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 			enum qm_fd_format _format1:3;
 			u32 length29:29;
+#else
+			u32 length29:29;
+			enum qm_fd_format _format1:3;
+#endif
 		};
 		/* If 'format' is _compound, 29b "congestion weight" */
 		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 			enum qm_fd_format _format2:3;
 			u32 cong_weight:29;
+#else
+			u32 cong_weight:29;
+			enum qm_fd_format _format2:3;
+#endif
 		};
 	};
 	union {
-- 
1.7.5.4

