From 03785ee61bea9870993a5ee5ab1f3ad7f9134da8 Mon Sep 17 00:00:00 2001
From: Roy Pledge <Roy.Pledge@freescale.com>
Date: Wed, 12 Nov 2014 16:10:16 -0500
Subject: [PATCH 135/451] fsl_qbman: Update QBMan drivers to support little
 endian CPUs

This is the inital patch to add support for little endian CPUs
for the QBMan device (which is big endian). There are still some
TODOs and things to investigate, but basic enqueue/dequeue and
acquire/release have been successfully tested on LS1043 ARM sim

Signed-off-by: Roy Pledge <Roy.Pledge@freescale.com>
Change-Id: I9b31ca5cf21aca192decb39906ee5044b80fdf9f
Reviewed-on: http://git.am.freescale.net:8181/28085
Reviewed-by: Yang Li <LeoLi@freescale.com>
Tested-by: Yang Li <LeoLi@freescale.com>
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 arch/arm64/boot/dts/freescale/fsl-ls1043a.dtsi     |    8 +
 arch/arm64/boot/dts/freescale/fsl-ls1xxx-ch21.dtsi |  860 ++++++++++++++++++++
 .../boot/dts/freescale/qoriq-bman1-portals.dtsi    |  104 +++
 .../boot/dts/freescale/qoriq-qman1-portals.dtsi    |  136 +++
 drivers/misc/Kconfig                               |   17 +
 drivers/staging/Kconfig                            |    2 +
 drivers/staging/fsl_qbman/Kconfig                  |    4 +-
 drivers/staging/fsl_qbman/Makefile                 |    2 +-
 drivers/staging/fsl_qbman/bman_config.c            |   10 +-
 drivers/staging/fsl_qbman/bman_driver.c            |   28 +-
 drivers/staging/fsl_qbman/bman_high.c              |   36 +-
 drivers/staging/fsl_qbman/bman_low.h               |   43 +-
 drivers/staging/fsl_qbman/bman_test_high.c         |    9 +-
 drivers/staging/fsl_qbman/bman_test_thresh.c       |   11 +
 drivers/staging/fsl_qbman/dpa_sys.h                |   59 +--
 drivers/staging/fsl_qbman/dpa_sys_arm64.h          |  110 +++
 drivers/staging/fsl_qbman/dpa_sys_ppc32.h          |   70 ++
 drivers/staging/fsl_qbman/dpa_sys_ppc64.h          |   79 ++
 drivers/staging/fsl_qbman/qbman_driver.c           |    5 +
 drivers/staging/fsl_qbman/qman_config.c            |   28 +-
 drivers/staging/fsl_qbman/qman_driver.c            |   50 +-
 drivers/staging/fsl_qbman/qman_high.c              |  164 ++++-
 drivers/staging/fsl_qbman/qman_low.h               |   58 ++-
 drivers/staging/fsl_qbman/qman_private.h           |    3 +
 drivers/staging/fsl_qbman/qman_test.h              |    1 +
 include/linux/fsl_bman.h                           |   13 +
 include/linux/fsl_qman.h                           |   91 ++
 27 files changed, 1847 insertions(+), 154 deletions(-)
 create mode 100644 arch/arm64/boot/dts/freescale/fsl-ls1xxx-ch21.dtsi
 create mode 100644 arch/arm64/boot/dts/freescale/qoriq-bman1-portals.dtsi
 create mode 100644 arch/arm64/boot/dts/freescale/qoriq-qman1-portals.dtsi
 create mode 100644 drivers/staging/fsl_qbman/dpa_sys_arm64.h
 create mode 100644 drivers/staging/fsl_qbman/dpa_sys_ppc32.h
 create mode 100644 drivers/staging/fsl_qbman/dpa_sys_ppc64.h

diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1043a.dtsi b/arch/arm64/boot/dts/freescale/fsl-ls1043a.dtsi
index e5b2bc1..b1ee7b1 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls1043a.dtsi
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1043a.dtsi
@@ -705,4 +705,12 @@
 		reg = <0x0 0x80000000 0 0x80000000>;
 		      /* DRAM space 1 - 2 GB DRAM */
 	};
+	qportals: qman-portals@500000000 {
+		   ranges = <0x0 0x5 0x00000000 0x8000000>;
+        };
+	bportals: bman-portals@508000000 {
+		   ranges = <0x0 0x5 0x08000000 0x8000000>;
+        };
 };
+/include/ "qoriq-qman1-portals.dtsi"
+/include/ "qoriq-bman1-portals.dtsi"
diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1xxx-ch21.dtsi b/arch/arm64/boot/dts/freescale/fsl-ls1xxx-ch21.dtsi
new file mode 100644
index 0000000..ec59a9a
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1xxx-ch21.dtsi
@@ -0,0 +1,860 @@
+/*
+ * Device Tree Include file for Freescale Layerscape 1xxx family SoC
+ * (compliant to Chassis 2.1 specifications).
+ *
+ * Copyright 2014, Freescale Semiconductor Inc.
+ * Li Yang <leoli@freescale.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/ {
+
+	soc {
+		#address-cells = <2>;
+		#size-cells = <1>;
+		compatible = "simple-bus";
+		interrupt-parent = <&gic>;
+
+		gic: interrupt-controller@1400000 {
+			compatible = "arm,cortex-a15-gic";
+			#interrupt-cells = <3>;
+			interrupt-controller;
+			reg = <0x00 0x1401000 0x1000>,
+				<0x00 0x1402000 0x1000>,
+				<0x00 0x1404000 0x2000>,
+				<0x00 0x1406000 0x2000>;
+		};
+
+		tzasc: tzasc@1500000 {
+			reg = <0x00 0x1500000 0x10000>;
+			interrupts = <0 93 0x04>;
+			status = "disabled";
+		};
+
+		ifc: ifc@1530000 {
+			compatible = "fsl,ls-ifc", "fsl,ifc", "simple-bus";
+			reg = <0x00 0x1530000 0x10000>;
+			interrupts = <0 43 0x04>;
+			status = "disabled";
+		};
+
+		qspi: quadspi@1550000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "fsl,vf610-qspi";
+			reg = <0x00 0x1550000 0x10000>;
+			interrupts = <0 99 0x04>;
+			clock-names = "qspi_en", "qspi";
+			status = "disabled";
+		};
+
+		esdhc: esdhc@1560000 {
+			compatible = "fsl,ls-esdhc", "fsl,esdhc";
+			reg = <0x00 0x1560000 0x10000>;
+			interrupts = <0 62 0x04>;
+			clock-frequency = <0>;
+			voltage-ranges = <1800 3300>;
+			bus-width = <4>;
+			status = "disabled";
+		};
+
+		scfg: scfg@1570000 {
+			compatible = "fsl,ls-scfg";
+			reg = <0x00 0x1570000 0x10000>;
+		};
+
+		caam: crypto@1700000 {
+			compatible = "fsl,sec-v4.4", "fsl,sec-v4.0";
+			fsl,sec-era = <3>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x0 0x00 0x1700000 0x10000>;
+			reg = <0x00 0x1700000 0x10000>;
+			interrupts	 = <0 75 0x04>;
+			status = "disabled";
+
+			sec_jr0: jr@1000 {
+				compatible = "fsl,sec-v4.4-job-ring", "fsl,sec-v4.0-job-ring";
+				reg	   = <0x1000 0x1000>;
+				interrupts = <0 71 0x04>;
+			};
+
+			sec_jr1: jr@2000 {
+				compatible = "fsl,sec-v4.4-job-ring", "fsl,sec-v4.0-job-ring";
+				reg	   = <0x2000 0x1000>;
+				interrupts = <0 72 0x04>;
+			};
+
+			sec_jr2: jr@3000 {
+				compatible = "fsl,sec-v4.4-job-ring", "fsl,sec-v4.0-job-ring";
+				reg	   = <0x3000 0x1000>;
+				interrupts = <0 73 0x04>;
+			};
+
+			sec_jr3: jr@4000 {
+				compatible = "fsl,sec-v4.4-job-ring", "fsl,sec-v4.0-job-ring";
+				reg	   = <0x4000 0x1000>;
+				interrupts = <0 74 0x04>;
+			};
+		};
+
+		qman: qman@1880000 {
+			compatible = "fsl,qman";
+			reg = <0x00 0x1880000 0x10000>;
+			interrupts = <0 77 0x4>;
+		};
+
+		bman: bman@1890000 {
+			compatible = "fsl,bman";
+			reg = <0x00 0x1890000 0x10000>;
+			interrupts = <0 77 0x4>;
+		};
+
+		fman0: fman@1a000000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			cell-index = <0>;
+			compatible = "fsl,fman", "simple-bus";
+			ranges = <0x0 0x00 0x1a000000 0x100000>;
+			reg = <0x00 0x1a000000 0x100000>;
+			clock-frequency = <0>;
+			interrupts = <
+				96 2 0 0
+				16 2 1 1>; /* FIXME */
+			status = "disabled";
+
+			cc {
+				compatible = "fsl,fman-cc";
+			};
+
+			muram@0 {
+				compatible = "fsl,fman-muram";
+				reg = <0x0 0x60000>;
+			};
+
+			bmi@80000 {
+				compatible = "fsl,fman-bmi";
+				reg = <0x80000 0x400>;
+			};
+
+			qmi@80400 {
+				compatible = "fsl,fman-qmi";
+				reg = <0x80400 0x400>;
+			};
+
+			fman0_oh1: port@82000 {
+				cell-index = <0>;
+				compatible = "fsl,fman-port-oh";
+				reg = <0x82000 0x1000>;
+			};
+
+			fman0_oh2: port@83000 {
+				cell-index = <1>;
+				compatible = "fsl,fman-port-oh";
+				reg = <0x83000 0x1000>;
+			};
+
+			fman0_oh3: port@84000 {
+				cell-index = <2>;
+				compatible = "fsl,fman-port-oh";
+				reg = <0x84000 0x1000>;
+			};
+
+			fman0_oh4: port@85000 {
+				cell-index = <3>;
+				compatible = "fsl,fman-port-oh";
+				reg = <0x85000 0x1000>;
+			};
+
+			fman0_oh5: port@86000 {
+				cell-index = <4>;
+				compatible = "fsl,fman-port-oh";
+				reg = <0x86000 0x1000>;
+			};
+
+			fman0_oh6: port@87000 {
+				cell-index = <5>;
+				compatible = "fsl,fman-port-oh";
+				reg = <0x87000 0x1000>;
+			};
+
+			policer@c0000 {
+				compatible = "fsl,fman-policer";
+				reg = <0xc0000 0x1000>;
+			};
+
+			keygen@c1000 {
+				compatible = "fsl,fman-keygen";
+				reg = <0xc1000 0x1000>;
+			};
+
+			dma@c2000 {
+				compatible = "fsl,fman-dma";
+				reg = <0xc2000 0x1000>;
+			};
+
+			fpm@c3000 {
+				compatible = "fsl,fman-fpm";
+				reg = <0xc3000 0x1000>;
+			};
+
+			parser@c7000 {
+				compatible = "fsl,fman-parser";
+				reg = <0xc7000 0x1000>;
+			};
+
+			vsps@dc000 {
+				compatible = "fsl,fman-vsps";
+				reg = <0xdc000 0x1000>;
+			};
+
+			mdio@fc000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,fman-memac-mdio";
+				reg = <0xfc000 0x1000>;
+			};
+
+			mdio@fd000 {
+				#address-cells = <1>;
+				#size-cells = <0>;
+				compatible = "fsl,fman-memac-mdio";
+				reg = <0xfd000 0x1000>;
+			};
+
+			ptp_timer0: rtc@fe000 {
+				compatible = "fsl,fman-rtc";
+				reg = <0xfe000 0x1000>;
+			};
+		};
+
+		sfp: sfp@1e80000 {
+			reg = <0x00 0x1e80000 0x10000>;
+			status = "disabled";
+		};
+
+		snvs: snvs@1e90000 {
+			reg = <0x00 0x1e90000 0x10000>;
+			status = "disabled";
+		};
+
+		serdes1: serdes1@1ea0000 {
+			reg = <0x00 0x1ea0000 0x10000>;
+			status = "disabled";
+		};
+
+		dcfg: dcfg@1ee0000 {
+			compatible = "fsl,ls-dcfg";
+			reg = <0x00 0x1ee0000 0x10000>;
+		};
+
+		clockgen: clocking@1ee1000 {
+			compatible = "fsl,qoriq-clockgen-2.0";
+			reg = <0x00 0x1ee1000 0x10000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			sysclk: sysclk {
+				compatible = "fsl,sys-clock";
+				#clock-cells = <0>;
+				clock-frequency = <100000000>;
+				clock-output-names = "sysclk";
+			};
+
+			cga_pll1: pll1@800 {
+				compatible = "fsl,core-pll-clock";
+				#clock-cells = <1>;
+				reg = <0x800>;
+				clocks = <&sysclk>;
+				clock-output-names = "cga-pll1", "cga-pll1-div2",
+						"cga-pll1-div3", "cga-pll1-div4";
+			};
+
+			cga_pll2: pll2@820 {
+				compatible = "fsl,core-pll-clock";
+				#clock-cells = <1>;
+				reg = <0x820>;
+				clocks = <&sysclk>;
+				clock-output-names = "cga-pll2", "cga-pll2-div2",
+						"cga-pll2-div3", "cga-pll2-div4";
+			};
+
+			platform_clk: pll@c00 {
+				compatible = "fsl,core-pll-clock";
+				#clock-cells = <1>;
+				reg = <0xc00>;
+				clocks = <&sysclk>;
+				clock-output-names = "platform-clk", "platform-clk-div2";
+			};
+
+
+			cluster1_clk: clk0c0@0 {
+				compatible = "fsl,core-mux-clock";
+				#clock-cells = <1>;
+				reg = <0x0>;
+				clock-names = "pll1cga", "pll1cga-div2";
+				clocks = <&cga_pll1 0>, <&cga_pll1 2>;
+				clock-output-names = "cluster1-clk";
+
+			};
+
+		};
+
+		rcpm: rcpm@1ee2000 {
+			reg = <0x00 0x1ee2000 0x10000>;
+			status = "disabled";
+		};
+
+		tmu: tmu@1f00000 {
+			compatible = "fsl,tmu";
+			reg = <0x00 0x1f00000 0x10000>;
+			status = "disabled";
+		};
+
+		dspi0: dspi@2100000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "fsl,vf610-dspi";
+			reg = <0x00 0x2100000 0x10000>;
+			interrupts = <0 64 0x04>;
+			clock-names = "dspi";
+			clocks = <&platform_clk 1>;
+			spi-num-chipselects = <5>;
+			big-endian;
+			status = "disabled";
+		};
+
+		dspi1: dspi@2110000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "fsl,vf610-dspi";
+			reg = <0x00 0x2110000 0x10000>;
+			interrupts = <0 65 0x04>;
+			clock-names = "dspi";
+			clocks = <&platform_clk 1>;
+			spi-num-chipselects = <5>;
+			big-endian;
+			status = "disabled";
+		};
+
+		i2c0: i2c@2180000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "fsl,vf610-i2c";
+			reg = <0x00 0x2180000 0x10000>;
+			interrupts =<0 56 0x04>;
+			clock-names = "i2c";
+			clocks = <&platform_clk 1>;
+			dmas = <&edma0 1 39>,
+				<&edma0 1 38>;
+			dma-names = "tx", "rx";
+			status = "disabled";
+		};
+
+		i2c1: i2c@2190000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "fsl,vf610-i2c";
+			reg = <0x00 0x2190000 0x10000>;
+			interrupts = <0 57 0x04>;
+			clock-names = "i2c";
+			clocks = <&platform_clk 1>;
+			status = "disabled";
+		};
+
+		i2c2: i2c@21a0000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "fsl,vf610-i2c";
+			reg = <0x00 0x21a0000 0x10000>;
+			interrupts = <0 58 0x04>;
+			clock-names = "i2c";
+			clocks = <&platform_clk 1>;
+			status = "disabled";
+		};
+
+		i2c3: i2c@21b0000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "fsl,vf610-i2c";
+			reg = <0x00 0x21b0000 0x10000>;
+			interrupts = <0 59 0x04>;
+			clock-names = "i2c";
+			clocks = <&platform_clk 1>;
+			status = "disabled";
+		};
+
+		duart0: serial@21c0500 {
+			compatible = "fsl,ns16550", "ns16550a";
+			reg = <0x00 0x21c0500 0x100>;
+			interrupts = <0 54 0x04>;
+			clock-frequency = <66666666>;
+			fifo-size = <64>;
+		};
+
+		duart1: serial@21c0600 {
+			compatible = "fsl,ns16550", "ns16550a";
+			reg = <0x00 0x21c0600 0x100>;
+			interrupts = <0 54 0x04>;
+			clock-frequency = <66666666>;
+			fifo-size = <64>;
+		};
+
+		duart2: serial@21d0500 {
+			compatible = "fsl,ns16550", "ns16550a";
+			reg = <0x00 0x21d0500 0x100>;
+			interrupts = <0 55 0x04>;
+			clock-frequency = <66666666>;
+			fifo-size = <64>;
+		};
+
+		duart3: serial@21d0600 {
+			compatible = "fsl,ns16550", "ns16550a";
+			reg = <0x00 0x21d0600 0x100>;
+			interrupts = <0 55 0x04>;
+			clock-frequency = <66666666>;
+			fifo-size = <64>;
+		};
+
+		gpio1: gpio@2300000 {
+			compatible = "fsl,qoriq-gpio";
+			reg = <0x00 0x2300000 0x10000>;
+			interrupts = <0 66 0x04>;
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			status = "disabled";
+		};
+
+		gpio2: gpio@2310000 {
+			compatible = "fsl,qoriq-gpio";
+			reg = <0x00 0x2310000 0x10000>;
+			interrupts = <0 67 0x04>;
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			status = "disabled";
+		};
+
+		gpio3: gpio@2320000 {
+			compatible = "fsl,qoriq-gpio";
+			reg = <0x00 0x2320000 0x10000>;
+			interrupts = <0 68 0x04>;
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			status = "disabled";
+		};
+
+		gpio4: gpio@2330000 {
+			compatible = "fsl,qoriq-gpio";
+			reg = <0x00 0x2330000 0x10000>;
+			interrupts = <0 134 0x04>;
+			gpio-controller;
+			#gpio-cells = <2>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			status = "disabled";
+		};
+
+		uqe: uqe@2400000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x0 0x00 0x2400000 0x40000>;
+			device_type = "qe";
+			compatible = "fsl,qe";
+			fsl,qe-num-riscs = <1>;
+			fsl,qe-num-snums = <28>;
+			status = "disabled";
+
+			qeic: qeic@80 {
+				compatible = "fsl,qe-ic";
+				reg = <0x80 0x80>;
+				#address-cells = <0>;
+				interrupt-controller;
+				#interrupt-cells = <1>;
+				interrupts = <0 77 0x04>;
+			};
+
+			ucc@2000 {
+				cell-index = <1>;
+				reg = <0x2000 0x200>;
+				interrupts = <32>;
+				interrupt-parent = <&qeic>;
+			};
+
+			ucc@2200 {
+				cell-index = <3>;
+				reg = <0x2200 0x200>;
+				interrupts = <34>;
+				interrupt-parent = <&qeic>;
+			};
+
+			muram@10000 {
+				#address-cells = <1>;
+				#size-cells = <1>;
+				compatible = "fsl,qe-muram", "fsl,cpm-muram";
+				ranges = <0x0 0x10000 0x6000>;
+
+				data-only@0 {
+					compatible = "fsl,qe-muram-data",
+					"fsl,cpm-muram-data";
+					reg = <0x0 0x6000>;
+				};
+			};
+		};
+
+		lpuart0: serial@2950000 {
+			compatible = "fsl,vf610-lpuart";
+			reg = <0x00 0x2950000 0x1000>;
+			interrupts = <0 48 0x04>;
+			clocks = <&platform_clk 1>;
+			clock-names = "ipg";
+			status = "disabled";
+		};
+
+		lpuart1: serial@2960000 {
+			compatible = "fsl,vf610-lpuart";
+			reg = <0x00 0x2960000 0x1000>;
+			interrupts = <0 49 0x04>;
+			clocks = <&platform_clk 1>;
+			clock-names = "ipg";
+			status = "disabled";
+		};
+
+		lpuart2: serial@2970000 {
+			compatible = "fsl,vf610-lpuart";
+			reg = <0x00 0x2970000 0x1000>;
+			interrupts = <0 50 0x04>;
+			clocks = <&platform_clk 1>;
+			clock-names = "ipg";
+			status = "disabled";
+		};
+
+		lpuart3: serial@2980000 {
+			compatible = "fsl,vf610-lpuart";
+			reg = <0x00 0x2980000 0x1000>;
+			interrupts = <0 51 0x04>;
+			clocks = <&platform_clk 1>;
+			clock-names = "ipg";
+			status = "disabled";
+		};
+
+		lpuart4: serial@2990000 {
+			compatible = "fsl,vf610-lpuart";
+			reg = <0x00 0x2990000 0x1000>;
+			interrupts = <0 52 0x04>;
+			clocks = <&platform_clk 1>;
+			clock-names = "ipg";
+			status = "disabled";
+		};
+
+		lpuart5: serial@29a0000 {
+			compatible = "fsl,vf610-lpuart";
+			reg = <0x00 0x29a0000 0x1000>;
+			interrupts = <0 53 0x04>;
+			clocks = <&platform_clk 1>;
+			clock-names = "ipg";
+			status = "disabled";
+		};
+
+		ftm0_1: ftm0_1@29d0000 {
+			compatible = "fsl,ftm-timer";
+			reg = <0x00 0x29d0000 0x10000 0x00 0x29e0000 0x10000>;
+			interrupts = <0 86 0x04>;
+			clock-names = "ftm-evt", "ftm-src",
+			        "ftm-evt-counter-en", "ftm-src-counter-en";
+			clocks = <&platform_clk 1>, <&platform_clk 1>,
+			       <&platform_clk 1>, <&platform_clk 1>;
+			big-endian;
+			status = "disabled";
+		};
+
+		ftm2: ftm@29f0000 {
+			reg = <0x00 0x29f0000 0x10000>;
+			interrupts = <0 88 0x04>;
+			status = "disabled";
+		};
+
+		ftm3: ftm@2a00000 {
+			reg = <0x00 0x2a00000 0x10000>;
+			interrupts = <0 89 0x04>;
+			status = "disabled";
+		};
+
+		ftm4: ftm@2a10000 {
+			reg = <0x00 0x2a10000 0x10000>;
+			interrupts = <0 0 0x04>;
+			status = "disabled";
+		};
+
+		ftm5: ftm@2a20000 {
+			reg = <0x00 0x2a20000 0x10000>;
+			interrupts = <0 1 0x04>;
+			status = "disabled";
+		};
+
+		pwm6: ftm@2a30000 {
+			compatible = "fsl,vf610-ftm-pwm";
+			#pwm-cells = <3>;
+			reg = <0x00 0x2a30000 0x10000>;
+			interrupts = <0 91 0x04>;
+			clock-names = "ftm_sys", "ftm_ext",
+				"ftm_fix", "ftm_cnt_clk_en";
+			clocks = <&platform_clk 1>, <&platform_clk 1>,
+				<&platform_clk 1>, <&platform_clk 1>;
+			big-endian;
+			status = "disabled";
+		};
+
+		pwm7: ftm@2a40000 {
+			compatible = "fsl,vf610-ftm-pwm";
+			#pwm-cells = <3>;
+			reg = <0x00 0x2a40000 0x10000>;
+			interrupts = <0 92 0x04>;
+			clock-names = "ftm_sys", "ftm_ext",
+				"ftm_fix", "ftm_cnt_clk_en";
+			clocks = <&platform_clk 1>, <&platform_clk 1>,
+				<&platform_clk 1>, <&platform_clk 1>;
+			big-endian;
+			status = "disabled";
+		};
+
+		wdog0: wdog@2ad0000 {
+			compatible = "fsl,ls-wdt", "fsl,imx21-wdt";
+			reg = <0x00 0x2ad0000 0x10000>;
+			interrupts = <0 83 0x04>;
+			clocks = <&platform_clk 1>;
+			clock-names = "wdog";
+		};
+
+		sai2: sai@2b60000 {
+			compatible = "fsl,vf610-sai";
+			reg = <0x00 0x2b60000 0x10000>;
+			interrupts = <0 101 0x04>;
+			clocks = <&platform_clk 1>;
+			clock-names = "sai";
+			dma-names = "tx", "rx";
+			dmas = <&edma0 1 45>,
+				<&edma0 1 44>;
+			big-endian-regs;
+			status = "disabled";
+		};
+
+		edma0: edma@2c00000 {
+			#dma-cells = <2>;
+			compatible = "fsl,vf610-edma";
+			reg = <0x00 0x2c00000 0x10000>,
+				<0x00 0x2c10000 0x10000>,
+				<0x00 0x2c20000 0x10000>;
+			interrupts = <0 103 0x04>,
+					<0 103 0x04>;
+			interrupt-names = "edma-tx", "edma-err";
+			dma-channels = <32>;
+			big-endian;
+			clock-names = "dmamux0", "dmamux1";
+			clocks = <&platform_clk 1>,
+				<&platform_clk 1>;
+			status = "disabled";
+		};
+
+		dcu0: dcu@2ce0000 {
+			compatible = "fsl,vf610-dcu";
+			reg = <0x00 0x2ce000 0x10000>;
+			interrupts = <0 140 0x04>;
+			clocks = <&platform_clk 1>;
+			clock-names = "dcu";
+			big-endian;
+			status = "disabled";
+		};
+
+		mdio@2d10000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "fsl,etsec2-mdio";
+			reg = <0x00 0x2d10000 0x1000>;
+			status = "disabled";
+
+			phy0: ethernet-phy@0 {
+				reg = <0x0>;
+			};
+			phy1: ethernet-phy@1 {
+				reg = <0x1>;
+			};
+			phy2: ethernet-phy@2 {
+				reg = <0x2>;
+			};
+		};
+
+		enet0: ethernet@2d10000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			device_type = "network";
+			model = "eTSEC";
+			compatible = "fsl,etsec2";
+			fsl,num_rx_queues = <0x8>;
+			fsl,num_tx_queues = <0x8>;
+			local-mac-address = [ 00 00 00 00 00 00 ];
+			status = "disabled";
+
+			queue-group@0 {
+				#address-cells = <1>;
+				#size-cells = <1>;
+				reg = <0x2d10000 0x1000>;
+				fsl,rx-bit-map = <0xff>;
+				fsl,tx-bit-map = <0xff>;
+				interrupts = <0 112 0x04>,
+					<0 113 0x04>,
+					<0 114 0x04>;
+			};
+
+		};
+
+		enet1: ethernet@2d50000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			device_type = "network";
+			model = "eTSEC";
+			compatible = "fsl,etsec2";
+			fsl,num_rx_queues = <0x8>;
+			fsl,num_tx_queues = <0x8>;
+			local-mac-address = [ 00 00 00 00 00 00 ];
+			status = "disabled";
+
+			queue-group@0 {
+				#address-cells = <1>;
+				#size-cells = <1>;
+				reg = <0x2d50000 0x1000>;
+				fsl,rx-bit-map = <0xff>;
+				fsl,tx-bit-map = <0xff>;
+				interrupts = <0 118 0x04>,
+					<0 120 0x04>,
+					<0 121 0x04>;
+			};
+
+		};
+
+		enet2: ethernet@2d70000 {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			device_type = "network";
+			model = "eTSEC";
+			compatible = "fsl,etsec2";
+			fsl,num_rx_queues = <0x8>;
+			fsl,num_tx_queues = <0x8>;
+			local-mac-address = [ 00 00 00 00 00 00 ];
+			status = "disabled";
+
+			queue-group@0 {
+				#address-cells = <1>;
+				#size-cells = <1>;
+				reg = <0x2d70000 0x1000>;
+				fsl,rx-bit-map = <0xff>;
+				fsl,tx-bit-map = <0xff>;
+				interrupts = <0 125 0x04>,
+					<0 126 0x04>,
+					<0 127 0x04>;
+			};
+		};
+
+		usb@2f00000 {
+			compatible = "fsl-usb3"; /* FIXME */
+			reg = <0x00 0x2f00000 0x1000>;
+			status = "disabled";
+		};
+
+		usb@3000000 {
+			compatible = "fsl-usb3"; /* FIXME */
+			reg = <0x00 0x3000000 0x1000>;
+			status = "disabled";
+		};
+
+		usb@3100000 {
+			compatible = "fsl-usb3"; /* FIXME */
+			reg = <0x00 0x3100000 0x1000>;
+			status = "disabled";
+		};
+
+		pcie@3400000 {
+			compatible = "fsl,pcie", "snps,dw-pcie", "fsl,ls-pcie";
+			reg = <0x00 0x3400000 0x10000>;
+			interrupts = <0 145 0x04>, <0 147 0x04>, <0 149 0x04>, <0 151 0x04>, <0 59 0x04>;
+			interrupt-names = "intr", "msi", "pme", "cfg-err", "inta";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			device_type = "pci";
+			num-lanes = <4>;
+			bus-range = <0x0 0xff>;
+			ranges = <0x00000800 0x0 0x00000000 0x40 0x00000000 0x0 0x00080000 /* configuration space */
+				  0x81000000 0x0 0x00000000 0x40 0x10000000 0x0 0x00010000 /* downstream I/O */
+				  0x82000000 0x0 0x00000000 0x41 0x00000000 0x1 0x00000000>; /* non-prefetchable memory */
+			interrupt-map-mask = <0 0 0 7>;
+			interrupt-map = <0000 0 0 1 &gic 0 59  0x04>,
+					<0000 0 0 2 &gic 0 156 0x04>,
+					<0000 0 0 3 &gic 0 158 0x04>,
+					<0000 0 0 4 &gic 0 160 0x04>;
+			status = "disabled";
+			};
+
+		pcie@3500000 {
+			compatible = "fsl,pcie", "snps,dw-pcie", "fsl,ls-pcie";
+			reg = <0x00 0x3500000 0x10000>;
+			interrupts = <0 146 0>, <0 148 0>, <0 150 0>, <0 152 0>;
+			interrupt-names = "intr", "msi", "pme", "cfg-err";
+			#address-cells = <3>;
+			#size-cells = <2>;
+			device_type = "pci";
+			num-lanes = <2>;
+			bus-range = <0x0 0xff>;
+			ranges = <0x82000000 0x0 0x00000000 0x48 0x00000000 0x0 0x10000000 /* configuration space */
+				  0x81000000 0x0 0x00000000 0x48 0x10000000 0x0 0x00010000 /* downstream I/O */
+				  0x82000000 0x0 0x00000000 0x49 0x00000000 0x1 0x00000000>; /* non-prefetchable memory */
+			interrupt-map-mask = <0 0 0 7>;
+			interrupt-map = <0000 0 0 1 &gic 0 59  0>,
+					<0000 0 0 2 &gic 0 157 0>,
+					<0000 0 0 3 &gic 0 159 0>,
+					<0000 0 0 4 &gic 0 161 0>;
+			status = "disabled";
+		};
+
+		usb@8600000 {
+			compatible = "fsl-usb2-dr-v1.6", "fsl-usb2-dr";
+			reg = <0x00 0x8600000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			interrupts = <0 139 0x04>;
+			dr_mode = "host";
+			phy_type = "utmi";
+			status = "disabled";
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/freescale/qoriq-bman1-portals.dtsi b/arch/arm64/boot/dts/freescale/qoriq-bman1-portals.dtsi
new file mode 100644
index 0000000..fd322e8
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/qoriq-bman1-portals.dtsi
@@ -0,0 +1,104 @@
+/*
+ * QorIQ BMan Portal device tree stub for 10 portals
+ *
+ * Copyright 2011 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+&bportals {
+	  #address-cells = <1>;
+	  #size-cells = <1>;
+	  compatible = "simple-bus";
+	  bportal0: bman-portal@0 {
+		cell-index = <0>;
+		compatible = "fsl,bman-portal";
+		reg = <0x0 0x4000 0x4000000 0x4000>;
+		interrupts = <0 173 0x4>;
+	};
+	bportal1: bman-portal@10000 {
+		cell-index = <1>;
+		compatible = "fsl,bman-portal";
+		reg = <0x10000 0x4000 0x4010000 0x4000>;
+		interrupts = <0 175 0x4>;
+	};
+	bportal2: bman-portal@20000 {
+		cell-index = <2>;
+		compatible = "fsl,bman-portal";
+		reg = <0x20000 0x4000 0x4020000 0x4000>;
+		interrupts = <0 177 0x4>;
+	};
+	bportal3: bman-portal@30000 {
+		cell-index = <3>;
+		compatible = "fsl,bman-portal";
+		reg = <0x30000 0x4000 0x4030000 0x4000>;
+		interrupts = <0 179 0x4>;
+	};
+	bportal4: bman-portal@40000 {
+		cell-index = <4>;
+		compatible = "fsl,bman-portal";
+		reg = <0x40000 0x4000 0x4040000 0x4000>;
+		interrupts = <0 181 0x4>;
+		};
+	bportal5: bman-portal@50000 {
+		cell-index = <5>;
+		compatible = "fsl,bman-portal";
+		reg = <0x50000 0x4000 0x4050000 0x4000>;
+		interrupts = <0 183 0x4>;
+	};
+	bportal6: bman-portal@60000 {
+		cell-index = <6>;
+		compatible = "fsl,bman-portal";
+		reg = <0x60000 0x4000 0x4060000 0x4000>;
+		interrupts = <0 185 0x4>;
+	};
+	bportal7: bman-portal@70000 {
+		cell-index = <7>;
+		compatible = "fsl,bman-portal";
+		reg = <0x70000 0x4000 0x4070000 0x4000>;
+		interrupts = <0 187 0x4>;
+	};
+	bportal8: bman-portal@80000 {
+		cell-index = <8>;
+		compatible = "fsl,bman-portal";
+		reg = <0x80000 0x4000 0x4080000 0x4000>;
+		interrupts = <0 189 0x4>;
+	};
+	bportal9: bman-portal@90000 {
+		cell-index = <9>;
+		compatible = "fsl,bman-portal";
+		reg = <0x90000 0x4000 0x4090000 0x4000>;
+		interrupts = <0 191 0x4>;
+	};
+	 bman-bpids@0 {
+                compatible = "fsl,bpid-range";
+                fsl,bpid-range = <32 32>;
+        };
+
+};
diff --git a/arch/arm64/boot/dts/freescale/qoriq-qman1-portals.dtsi b/arch/arm64/boot/dts/freescale/qoriq-qman1-portals.dtsi
new file mode 100644
index 0000000..b1d6cfc
--- /dev/null
+++ b/arch/arm64/boot/dts/freescale/qoriq-qman1-portals.dtsi
@@ -0,0 +1,136 @@
+/*
+ * QorIQ QMan Portal device tree stub for 10 portals & 15 pool channels
+ *
+ * Copyright 2011-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+&qportals {
+
+	  #address-cells = <1>;
+	  #size-cells = <1>;
+	  compatible = "simple-bus";
+	  qportal0: qman-portal@0 {
+		cell-index = <0>;
+		compatible = "fsl,qman-portal";
+		reg = <0x0 0x4000 0x4000000 0x4000>;
+		interrupts = <0 172 0x4>;
+		fsl,qman-channel-id = <0x0>;
+	};
+
+	qportal1: qman-portal@10000 {
+		  cell-index = <1>;
+		  compatible = "fsl,qman-portal";
+		  reg = <0x10000 0x4000 0x4010000 0x4000>;
+		  interrupts = <0 174 0x4>;
+		  fsl,qman-channel-id = <1>;
+	};
+
+	qportal2: qman-portal@20000 {
+		  cell-index = <2>;
+		  compatible = "fsl,qman-portal";
+		  reg = <0x20000 0x4000 0x4020000 0x4000>;
+		  interrupts = <0 176 0x4>;
+		  fsl,qman-channel-id = <2>;
+	};
+
+	qportal3: qman-portal@30000 {
+		  cell-index = <3>;
+		  compatible = "fsl,qman-portal";
+		  reg = <0x30000 0x4000 0x4030000 0x4000>;
+		  interrupts = <0 178 0x4>;
+		  fsl,qman-channel-id = <3>;
+	};
+
+	qportal4: qman-portal@40000 {
+		  cell-index = <4>;
+		  compatible = "fsl,qman-portal";
+		  reg = <0x40000 0x4000 0x4040000 0x4000>;
+		  interrupts = <0 180 0x4>;
+		  fsl,qman-channel-id = <4>;
+	};
+
+	qportal5: qman-portal@50000 {
+		  cell-index = <5>;
+		  compatible = "fsl,qman-portal";
+		  reg = <0x50000 0x4000 0x4050000 0x4000>;
+		  interrupts = <0 182 0x4>;
+		  fsl,qman-channel-id = <5>;
+	};
+
+	qportal6: qman-portal@60000 {
+		  cell-index = <6>;
+		  compatible = "fsl,qman-portal";
+		  reg = <0x60000 0x4000 0x4060000 0x4000>;
+		  interrupts = <0 184 0x4>;
+		  fsl,qman-channel-id = <6>;
+	};
+
+	qportal7: qman-portal@70000 {
+		  cell-index = <7>;
+		  compatible = "fsl,qman-portal";
+		  reg = <0x70000 0x4000 0x4070000 0x4000>;
+		  interrupts = <0 186 0x4>;
+		  fsl,qman-channel-id = <7>;
+	};
+
+	qportal8: qman-portal@80000 {
+		cell-index = <8>;
+		compatible = "fsl,qman-portal";
+		reg = <0x80000 0x4000 0x4080000 0x4000>;
+		interrupts = <0 188 0x4>;
+		fsl,qman-channel-id = <8>;
+	};
+
+	qportal9: qman-portal@90000 {
+		cell-index = <9>;
+		compatible = "fsl,qman-portal";
+		reg = <0x90000 0x4000 0x4090000 0x4000>;
+		interrupts = <0 190 0x4>;
+		fsl,qman-channel-id = <9>;
+	};
+
+	qman-fqids@0 {
+                compatible = "fsl,fqid-range";
+                fsl,fqid-range = <256 256>;
+        };
+        qman-fqids@1 {
+                compatible = "fsl,fqid-range";
+                fsl,fqid-range = <32768 32768>;
+        };
+        qman-pools@0 {
+                compatible = "fsl,pool-channel-range";
+                fsl,pool-channel-range = <0x21 0xf>;
+        };
+        qman-cgrids@0 {
+                compatible = "fsl,cgrid-range";
+                fsl,cgrid-range = <0 256>;
+        };
+
+};
\ No newline at end of file
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 6cb388e..b4ed8f3 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -219,6 +219,23 @@ config ENCLOSURE_SERVICES
 	  driver (SCSI/ATA) which supports enclosures
 	  or a SCSI enclosure device (SES) to use these services.
 
+config FSL_USDPAA
+        bool "Freescale USDPAA process driver"
+        depends on FSL_DPA
+        default y
+        help
+          This driver provides user-space access to kernel-managed
+          resource interfaces for USDPAA applications, on the assumption
+          that each process will open this device once. Specifically, this
+          device exposes functionality that would be awkward if exposed
+          via the portal devices - ie. this device exposes functionality
+          that is inherently process-wide rather than portal-specific.
+          This device is necessary for obtaining access to DMA memory and
+          for allocation of Qman and Bman resources. In short, if you wish
+          to use USDPAA applications, you need this.
+
+          If unsure, say Y.
+
 config SGI_XP
 	tristate "Support communication between SGI SSIs"
 	depends on NET
diff --git a/drivers/staging/Kconfig b/drivers/staging/Kconfig
index ac3ac51..308985d 100644
--- a/drivers/staging/Kconfig
+++ b/drivers/staging/Kconfig
@@ -154,4 +154,6 @@ source "drivers/staging/fsl-mc/Kconfig"
 
 source "drivers/staging/fsl-dpaa2/Kconfig"
 
+source "drivers/staging/fsl_qbman/Kconfig"
+
 endif # STAGING
diff --git a/drivers/staging/fsl_qbman/Kconfig b/drivers/staging/fsl_qbman/Kconfig
index c857514..c6102e6 100644
--- a/drivers/staging/fsl_qbman/Kconfig
+++ b/drivers/staging/fsl_qbman/Kconfig
@@ -3,6 +3,8 @@ config FSL_DPA
 	depends on HAS_FSL_QBMAN
 	default y
 	select FSL_QMAN_FQ_LOOKUP if PPC64
+	select FSL_QMAN_FQ_LOOKUP if ARM64
+
 
 menu "Freescale Datapath QMan/BMan options"
 	depends on FSL_DPA
@@ -143,7 +145,7 @@ config FSL_QMAN_FQD_SZ
 
 config FSL_QMAN_PFDR_SZ
 	int "size of the PFDR pool"
-	default 13
+	default 10
 	---help---
 	  This is the size of the PFDR pool defined as: PAGE_SIZE * (2^value)
 	  ex: 13 => PAGE_SIZE * (2^13)
diff --git a/drivers/staging/fsl_qbman/Makefile b/drivers/staging/fsl_qbman/Makefile
index 8606233..8e23efb 100644
--- a/drivers/staging/fsl_qbman/Makefile
+++ b/drivers/staging/fsl_qbman/Makefile
@@ -23,6 +23,6 @@ obj-$(CONFIG_FSL_QMAN_DEBUGFS)	+= qman_debugfs_interface.o
 qman_debugfs_interface-y	 = qman_debugfs.o
 
 # USDPAA
-obj-$(CONFIG_FSL_USDPAA)	+= fsl_usdpaa.o fsl_usdpaa_irq.o
+#obj-$(CONFIG_FSL_USDPAA)	+= fsl_usdpaa.o fsl_usdpaa_irq.o
 
 GCOV_PROFILE := y
diff --git a/drivers/staging/fsl_qbman/bman_config.c b/drivers/staging/fsl_qbman/bman_config.c
index efba359..df9ac90 100644
--- a/drivers/staging/fsl_qbman/bman_config.c
+++ b/drivers/staging/fsl_qbman/bman_config.c
@@ -237,7 +237,10 @@ static void bm_set_memory(struct bman *bm, u64 ba, int prio, u32 size)
 /*****************/
 
 /* TODO: Kconfig these? */
+/* LS1043 TODO: Reduced default size unti memblock_alloc issues are resolved
 #define DEFAULT_FBPR_SZ	(PAGE_SIZE << 12)
+*/
+#define DEFAULT_FBPR_SZ	(PAGE_SIZE << 8)
 
 /* We support only one of these. */
 static struct bman *bm;
@@ -361,8 +364,9 @@ int bm_pool_set(u32 bpid, const u32 *thresholds)
 {
 	if (!bm)
 		return -ENODEV;
-	bm_set_pool(bm, bpid, thresholds[0], thresholds[1],
-		thresholds[2], thresholds[3]);
+	bm_set_pool(bm, bpid, thresholds[0],
+		    thresholds[1], thresholds[2],
+		    thresholds[3]);
 	return 0;
 }
 EXPORT_SYMBOL(bm_pool_set);
@@ -462,7 +466,7 @@ static int __bind_irq(void)
 	int ret, err_irq;
 
 	err_irq = of_irq_to_resource(bm_node, 0, NULL);
-	if (err_irq == NO_IRQ) {
+	if (err_irq == 0) {
 		pr_info("Can't get %s property '%s'\n", bm_node->full_name,
 			"interrupts");
 		return -ENODEV;
diff --git a/drivers/staging/fsl_qbman/bman_driver.c b/drivers/staging/fsl_qbman/bman_driver.c
index 7ef20e3..4f68a62 100644
--- a/drivers/staging/fsl_qbman/bman_driver.c
+++ b/drivers/staging/fsl_qbman/bman_driver.c
@@ -28,7 +28,7 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-#include "bman_private.h"
+#include "bman_low.h"
 #ifdef CONFIG_HOTPLUG_CPU
 #include <linux/cpu.h>
 #endif
@@ -70,7 +70,7 @@ static int __init fsl_bpool_init(struct device_node *node)
 	}
 	if (thresh) {
 #ifdef CONFIG_FSL_BMAN_CONFIG
-		ret = bm_pool_set(*bpid, thresh);
+		ret = bm_pool_set(be32_to_cpu(*bpid), thresh);
 		if (ret)
 			pr_err("No CCSR node for %s property '%s'\n",
 				node->full_name, "fsl,bpool-thresholds");
@@ -97,9 +97,9 @@ static int __init fsl_bpid_range_init(struct device_node *node)
 			node->full_name);
 		return -EINVAL;
 	}
-	bman_seed_bpid_range(range[0], range[1]);
+	bman_seed_bpid_range(be32_to_cpu(range[0]), be32_to_cpu(range[1]));
 	pr_info("Bman: BPID allocator includes range %d:%d\n",
-		range[0], range[1]);
+		be32_to_cpu(range[0]), be32_to_cpu(range[1]));
 	return 0;
 }
 
@@ -141,6 +141,12 @@ static struct bm_portal_config * __init parse_pcfg(struct device_node *node)
 		bman_ip_rev = BMAN_REV21;
 		bman_pool_max = 64;
 		bman_portal_max = 10;
+	} else {
+		pr_warn("unknown BMan version in portal node,"
+			"default to rev1.0\n");
+		bman_ip_rev = BMAN_REV10;
+		bman_pool_max = 64;
+		bman_portal_max = 10;
 	}
 
 	ret = of_address_to_resource(node, DPA_PORTAL_CE,
@@ -162,18 +168,21 @@ static struct bm_portal_config * __init parse_pcfg(struct device_node *node)
 			"cell-index");
 		goto err;
 	}
-	if (*index >= bman_portal_max)
+	if (be32_to_cpu(*index) >= bman_portal_max) {
+		pr_err("BMan portal cell index %d out of range, max %d\n",
+		       be32_to_cpu(*index), bman_portal_max);
 		goto err;
+	}
 
 	pcfg->public_cfg.cpu = -1;
 
 	irq = irq_of_parse_and_map(node, 0);
-	if (irq == NO_IRQ) {
+	if (irq == 0) {
 		pr_err("Can't get %s property 'interrupts'\n", node->full_name);
 		goto err;
 	}
 	pcfg->public_cfg.irq = irq;
-	pcfg->public_cfg.index = *index;
+	pcfg->public_cfg.index = be32_to_cpu(*index);
 	bman_depletion_fill(&pcfg->public_cfg.mask);
 
 	pcfg->addr_virt[DPA_PORTAL_CE] = ioremap_prot(
@@ -184,10 +193,9 @@ static struct bm_portal_config * __init parse_pcfg(struct device_node *node)
 				pcfg->addr_phys[DPA_PORTAL_CI].start,
 				resource_size(&pcfg->addr_phys[DPA_PORTAL_CI]),
 				_PAGE_GUARDED | _PAGE_NO_CACHE);
-
 	/* disable bp depletion */
-	__raw_writel(0x0, pcfg->addr_virt[DPA_PORTAL_CI] + 0x200);
-	__raw_writel(0x0, pcfg->addr_virt[DPA_PORTAL_CI] + 0x204);
+	__raw_writel(0x0, pcfg->addr_virt[DPA_PORTAL_CI] + BM_REG_SCN(0));
+	__raw_writel(0x0, pcfg->addr_virt[DPA_PORTAL_CI] + BM_REG_SCN(1));
 	return pcfg;
 err:
 	kfree(pcfg);
diff --git a/drivers/staging/fsl_qbman/bman_high.c b/drivers/staging/fsl_qbman/bman_high.c
index cc25de4..49654cd 100644
--- a/drivers/staging/fsl_qbman/bman_high.c
+++ b/drivers/staging/fsl_qbman/bman_high.c
@@ -829,21 +829,11 @@ static noinline struct bm_rcr_entry *wait_rel_start(struct bman_portal **p,
 }
 #endif
 
-/* to facilitate better copying of bufs into the ring without either (a) copying
- * noise into the first byte (prematurely triggering the command), nor (b) being
- * very inefficient by copying small fields using read-modify-write */
-struct overlay_bm_buffer {
-	u32 first;
-	u32 second;
-};
-
 static inline int __bman_release(struct bman_pool *pool,
 			const struct bm_buffer *bufs, u8 num, u32 flags)
 {
 	struct bman_portal *p;
 	struct bm_rcr_entry *r;
-	struct overlay_bm_buffer *o_dest;
-	struct overlay_bm_buffer *o_src = (struct overlay_bm_buffer *)&bufs[0];
 	__maybe_unused unsigned long irqflags;
 	u32 i = num - 1;
 
@@ -859,12 +849,16 @@ static inline int __bman_release(struct bman_pool *pool,
 		return -EBUSY;
 	/* We can copy all but the first entry, as this can trigger badness
 	 * with the valid-bit. Use the overlay to mask the verb byte. */
-	o_dest = (struct overlay_bm_buffer *)&r->bufs[0];
-	o_dest->first = (o_src->first & 0x0000ffff) |
-		(((u32)pool->params.bpid << 16) & 0x00ff0000);
-	o_dest->second = o_src->second;
-	if (i)
-		copy_words(&r->bufs[1], &bufs[1], i * sizeof(bufs[0]));
+	r->bufs[0].opaque =  r->bufs[0].opaque |
+		((cpu_to_be64((bufs[0].opaque |
+			      ((u64)pool->params.bpid<<48))
+			      & 0x0fffffffffffffff)));
+	if (i) {
+		for (i = 1; i < num; i++)
+			r->bufs[i].opaque =
+				cpu_to_be64(bufs[i].opaque);
+	}
+
 	bm_rcr_pvb_commit(&p->p, BM_RCR_VERB_CMD_BPID_SINGLE |
 			(num & BM_RCR_VERB_BUFCOUNT_MASK));
 #ifdef CONFIG_FSL_DPA_CAN_WAIT_SYNC
@@ -958,7 +952,7 @@ static inline int __bman_acquire(struct bman_pool *pool, struct bm_buffer *bufs,
 	struct bm_mc_command *mcc;
 	struct bm_mc_result *mcr;
 	__maybe_unused unsigned long irqflags;
-	int ret;
+	int ret, i;
 
 	PORTAL_IRQ_LOCK(p, irqflags);
 	mcc = bm_mc_start(&p->p);
@@ -968,9 +962,11 @@ static inline int __bman_acquire(struct bman_pool *pool, struct bm_buffer *bufs,
 	while (!(mcr = bm_mc_result(&p->p)))
 		cpu_relax();
 	ret = mcr->verb & BM_MCR_VERB_ACQUIRE_BUFCOUNT;
-	if (bufs)
-		copy_words(&bufs[0], &mcr->acquire.bufs[0],
-				num * sizeof(bufs[0]));
+	if (bufs) {
+		for (i = 0; i < num; i++)
+			bufs[i].opaque =
+				be64_to_cpu(mcr->acquire.bufs[i].opaque);
+	}
 	PORTAL_IRQ_UNLOCK(p, irqflags);
 	put_affine_portal();
 	if (ret != num)
diff --git a/drivers/staging/fsl_qbman/bman_low.h b/drivers/staging/fsl_qbman/bman_low.h
index e4ab771..7dc9d54 100644
--- a/drivers/staging/fsl_qbman/bman_low.h
+++ b/drivers/staging/fsl_qbman/bman_low.h
@@ -35,6 +35,8 @@
 /* Portal register assists */
 /***************************/
 
+#if defined(CONFIG_PPC32) || defined(CONFIG_PPC64)
+
 /* Cache-inhibited register offsets */
 #define BM_REG_RCR_PI_CINH	0x0000
 #define BM_REG_RCR_CI_CINH	0x0004
@@ -52,6 +54,29 @@
 #define BM_CL_RCR_PI_CENA	0x3000
 #define BM_CL_RCR_CI_CENA	0x3100
 
+#endif
+
+#if defined(CONFIG_ARM64)
+
+/* Cache-inhibited register offsets */
+#define BM_REG_RCR_PI_CINH	0x3000
+#define BM_REG_RCR_CI_CINH	0x3100
+#define BM_REG_RCR_ITR		0x3200
+#define BM_REG_CFG		0x3300
+#define BM_REG_SCN(n)		(0x3400 + ((n) << 6))
+#define BM_REG_ISR		0x3e00
+#define BM_REG_IIR              0x3ec0
+
+/* Cache-enabled register offsets */
+#define BM_CL_CR		0x0000
+#define BM_CL_RR0		0x0100
+#define BM_CL_RR1		0x0140
+#define BM_CL_RCR		0x1000
+#define BM_CL_RCR_PI_CENA	0x3000
+#define BM_CL_RCR_CI_CENA	0x3100
+
+#endif
+
 /* BTW, the drivers (and h/w programming model) already obtain the required
  * synchronisation for portal accesses via lwsync(), hwsync(), and
  * data-dependencies. Use of barrier()s or other order-preserving primitives
@@ -60,19 +85,20 @@
  * non-coherent). */
 
 /* Cache-inhibited register access. */
-#define __bm_in(bm, o)		__raw_readl((bm)->addr_ci + (o))
-#define __bm_out(bm, o, val)	__raw_writel((val), (bm)->addr_ci + (o))
+#define __bm_in(bm, o)		be32_to_cpu(__raw_readl((bm)->addr_ci + (o)))
+#define __bm_out(bm, o, val)    __raw_writel(cpu_to_be32(val), \
+					     (bm)->addr_ci + (o));
 #define bm_in(reg)		__bm_in(&portal->addr, BM_REG_##reg)
 #define bm_out(reg, val)	__bm_out(&portal->addr, BM_REG_##reg, val)
 
 /* Cache-enabled (index) register access */
 #define __bm_cl_touch_ro(bm, o) dcbt_ro((bm)->addr_ce + (o))
 #define __bm_cl_touch_rw(bm, o) dcbt_rw((bm)->addr_ce + (o))
-#define __bm_cl_in(bm, o)	__raw_readl((bm)->addr_ce + (o))
+#define __bm_cl_in(bm, o)	be32_to_cpu(__raw_readl((bm)->addr_ce + (o)))
 #define __bm_cl_out(bm, o, val) \
 	do { \
 		u32 *__tmpclout = (bm)->addr_ce + (o); \
-		__raw_writel((val), __tmpclout); \
+		__raw_writel(cpu_to_be32(val), __tmpclout); \
 		dcbf(__tmpclout); \
 	} while (0)
 #define __bm_cl_invalidate(bm, o) dcbi((bm)->addr_ce + (o))
@@ -196,6 +222,7 @@ static inline int bm_rcr_init(struct bm_portal *portal, enum bm_rcr_pmode pmode,
 
 	rcr->ring = portal->addr.addr_ce + BM_CL_RCR;
 	rcr->ci = bm_in(RCR_CI_CINH) & (BM_RCR_SIZE - 1);
+
 	pi = bm_in(RCR_PI_CINH) & (BM_RCR_SIZE - 1);
 	rcr->cursor = rcr->ring + pi;
 	rcr->vbit = (bm_in(RCR_PI_CINH) & BM_RCR_SIZE) ?  BM_RCR_VERB_VBIT : 0;
@@ -487,13 +514,21 @@ static inline void bm_isr_bscn_mask(struct bm_portal *portal, u8 bpid,
 
 static inline u32 __bm_isr_read(struct bm_portal *portal, enum bm_isr_reg n)
 {
+#if defined(CONFIG_ARM64)
+	return __bm_in(&portal->addr, BM_REG_ISR + (n << 6));
+#else
 	return __bm_in(&portal->addr, BM_REG_ISR + (n << 2));
+#endif
 }
 
 static inline void __bm_isr_write(struct bm_portal *portal, enum bm_isr_reg n,
 					u32 val)
 {
+#if defined(CONFIG_ARM64)
+	__bm_out(&portal->addr, BM_REG_ISR + (n << 6), val);
+#else
 	__bm_out(&portal->addr, BM_REG_ISR + (n << 2), val);
+#endif
 }
 
 /* Buffer Pool Cleanup */
diff --git a/drivers/staging/fsl_qbman/bman_test_high.c b/drivers/staging/fsl_qbman/bman_test_high.c
index 7bdd181..4a0152a 100644
--- a/drivers/staging/fsl_qbman/bman_test_high.c
+++ b/drivers/staging/fsl_qbman/bman_test_high.c
@@ -38,7 +38,7 @@
 
 #define PORTAL_OPAQUE	((void *)0xf00dbeef)
 #define POOL_OPAQUE	((void *)0xdeadabba)
-#define NUM_BUFS	93
+#define NUM_BUFS        93
 #define LOOPS		3
 #define BMAN_TOKEN_MASK 0x00FFFFFFFFFFLLU
 
@@ -69,8 +69,11 @@ static void bufs_init(void)
 
 static inline int bufs_cmp(const struct bm_buffer *a, const struct bm_buffer *b)
 {
-	if ((bman_ip_rev == BMAN_REV20) || (bman_ip_rev == BMAN_REV21)) {
-
+	/* TODO : LS1043A - need to revert this workaround once the
+	   uboot device tree fixup is ported to ARM
+	   if (bman_ip_rev == BMAN_REV20) || (bman_ip_rev == BMAN_REV21)) {
+	*/
+	if (1) {
 		/* On SoCs with Bman revison 2.0, Bman only respects the 40
 		 * LS-bits of buffer addresses, masking off the upper 8-bits on
 		 * release commands. The API provides for 48-bit addresses
diff --git a/drivers/staging/fsl_qbman/bman_test_thresh.c b/drivers/staging/fsl_qbman/bman_test_thresh.c
index 6709369..34e14bb 100644
--- a/drivers/staging/fsl_qbman/bman_test_thresh.c
+++ b/drivers/staging/fsl_qbman/bman_test_thresh.c
@@ -32,9 +32,20 @@
 #include "bman_test.h"
 
 /* Test constants */
+/* TODO: LS1043 - reduce counts for test until larger BMan areas
+   can be supported.
+
 #define TEST_NUMBUFS	129728
 #define TEST_EXIT	129536
 #define TEST_ENTRY	129024
+*/
+
+#define TEST_NUMBUFS	728
+#define TEST_EXIT	536
+#define TEST_ENTRY	024
+
+
+
 
 struct affine_test_data {
 	struct task_struct *t;
diff --git a/drivers/staging/fsl_qbman/dpa_sys.h b/drivers/staging/fsl_qbman/dpa_sys.h
index d782c51..3da0bf3 100644
--- a/drivers/staging/fsl_qbman/dpa_sys.h
+++ b/drivers/staging/fsl_qbman/dpa_sys.h
@@ -62,6 +62,7 @@
 #include <linux/vmalloc.h>
 #include <linux/ctype.h>
 #include <linux/math64.h>
+#include <linux/bitops.h>
 
 #include <linux/fsl_usdpaa.h>
 
@@ -76,58 +77,14 @@
 /* Misc inline assists */
 /***********************/
 
-/* TODO: NB, we currently assume that hwsync() and lwsync() imply compiler
- * barriers and that dcb*() won't fall victim to compiler or execution
- * reordering with respect to other code/instructions that manipulate the same
- * cacheline. */
-#define hwsync() (__asm__ __volatile__ ("sync" : : : "memory"))
-#define lwsync() (__asm__ __volatile__ (stringify_in_c(LWSYNC) : : : "memory"))
-#define dcbf(p) (__asm__ __volatile__ ("dcbf 0,%0" : : "r" (p) : "memory"))
-#define dcbt_ro(p) (__asm__ __volatile__ ("dcbt 0,%0" : : "r" (p)))
-#define dcbt_rw(p) (__asm__ __volatile__ ("dcbtst 0,%0" : : "r" (p)))
-#define dcbi(p) dcbf(p)
-#ifdef CONFIG_PPC_E500MC
-#define dcbzl(p) (__asm__ __volatile__ ("dcbzl 0,%0" : : "r" (p)))
-#define dcbz_64(p) dcbzl(p)
-#define dcbf_64(p) dcbf(p)
-/* Commonly used combo */
-#define dcbit_ro(p) \
-	do { \
-		dcbi(p); \
-		dcbt_ro(p); \
-	} while (0)
-#else
-#define dcbz(p) (__asm__ __volatile__ ("dcbz 0,%0" : : "r" (p)))
-#define dcbz_64(p) \
-	do { \
-		dcbz((u32)p + 32);	\
-		dcbz(p);	\
-	} while (0)
-#define dcbf_64(p) \
-	do { \
-		dcbf((u32)p + 32); \
-		dcbf(p); \
-	} while (0)
-/* Commonly used combo */
-#define dcbit_ro(p) \
-	do { \
-		dcbi(p); \
-		dcbi((u32)p + 32); \
-		dcbt_ro(p); \
-		dcbt_ro((u32)p + 32); \
-	} while (0)
-#endif /* CONFIG_PPC_E500MC */
+#if defined CONFIG_PPC32
+#include "dpa_sys_ppc32.h"
+#elif defined CONFIG_PPC64
+#include "dpa_sys_ppc64.h"
+#elif defined CONFIG_ARM64
+#include "dpa_sys_arm64.h"
+#endif
 
-static inline u64 mfatb(void)
-{
-	u32 hi, lo, chk;
-	do {
-		hi = mfspr(SPRN_ATBU);
-		lo = mfspr(SPRN_ATBL);
-		chk = mfspr(SPRN_ATBU);
-	} while (unlikely(hi != chk));
-	return ((u64)hi << 32) | (u64)lo;
-}
 
 #ifdef CONFIG_FSL_DPA_CHECKING
 #define DPA_ASSERT(x) \
diff --git a/drivers/staging/fsl_qbman/dpa_sys_arm64.h b/drivers/staging/fsl_qbman/dpa_sys_arm64.h
new file mode 100644
index 0000000..9ca2ab88
--- /dev/null
+++ b/drivers/staging/fsl_qbman/dpa_sys_arm64.h
@@ -0,0 +1,110 @@
+/* Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef DPA_SYS_ARM64_H
+#define DPA_SYS_ARM64_H
+
+#include <asm/cacheflush.h>
+#include <asm/barrier.h>
+
+/* Implementation of ARM 64 bit specific routines */
+
+/* TODO: NB, we currently assume that hwsync() and lwsync() imply compiler
+ * barriers and that dcb*() won't fall victim to compiler or execution
+ * reordering with respect to other code/instructions that manipulate the same
+ * cacheline. */
+#define hwsync() smp_mb()
+#define lwsync() hwsync()
+#define dcbf(p) __flush_dcache_area((void *) p, 64)
+#define dcbt_ro(p) prefetch((void *)p)
+#define dcbt_rw(p) prefetch((void *)p)
+#define dcbi(p) dcbf(p)
+
+#define dcbz(p) memset((void *) p, 0, 32);
+
+#define dcbz_64(p) \
+	do { \
+		dcbz((void *)p + 32);	\
+		dcbz(p);	\
+	} while (0)
+
+#define dcbf_64(p) \
+	do { \
+		dcbf((void *)p + 32); \
+		dcbf(p); \
+	} while (0)
+/* Commonly used combo */
+#define dcbit_ro(p) \
+	do { \
+		dcbi(p); \
+		dcbi((const void *)p + 32); \
+		dcbt_ro(p); \
+		dcbt_ro((const void *)p + 32); \
+	} while (0)
+
+static inline u64 mfatb(void)
+{
+	return get_cycles();
+}
+
+static inline u32 in_be32(void *addr)
+{
+	return be32_to_cpu(*((u32 *) addr));
+}
+
+static inline void out_be32(void *addr, u32 val)
+{
+	*((u32 *) addr) = cpu_to_be32(val);
+}
+
+
+static inline void set_bits(unsigned long mask, volatile unsigned long *p)
+{
+	*p |= mask;
+}
+static inline void clear_bits(unsigned long mask, volatile unsigned long *p)
+{
+	*p &= ~mask;
+}
+
+static inline void flush_dcache_range(unsigned long start, unsigned long stop)
+{
+	/* TBD: Need to imlempent for ARM */
+}
+
+/* TBD - may need to deal with this for ARM */
+#define ioremap_prot(addr, sz, prot) ioremap(addr, sz)
+
+#define hard_smp_processor_id() raw_smp_processor_id()
+
+
+
+#endif
diff --git a/drivers/staging/fsl_qbman/dpa_sys_ppc32.h b/drivers/staging/fsl_qbman/dpa_sys_ppc32.h
new file mode 100644
index 0000000..6ee3e25
--- /dev/null
+++ b/drivers/staging/fsl_qbman/dpa_sys_ppc32.h
@@ -0,0 +1,70 @@
+/* Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef DPA_SYS_PPC32_H
+#define DPA_SYS_PPC32_H
+
+/* Implementation of PowerPC 32 bit specific routines */
+
+/* TODO: NB, we currently assume that hwsync() and lwsync() imply compiler
+ * barriers and that dcb*() won't fall victim to compiler or execution
+ * reordering with respect to other code/instructions that manipulate the same
+ * cacheline. */
+#define hwsync() (__asm__ __volatile__ ("sync" : : : "memory"))
+#define lwsync() (__asm__ __volatile__ (stringify_in_c(LWSYNC) : : : "memory"))
+#define dcbf(p) (__asm__ __volatile__ ("dcbf 0,%0" : : "r" (p) : "memory"))
+#define dcbt_ro(p) (__asm__ __volatile__ ("dcbt 0,%0" : : "r" (p)))
+#define dcbt_rw(p) (__asm__ __volatile__ ("dcbtst 0,%0" : : "r" (p)))
+#define dcbi(p) dcbf(p)
+
+#define dcbzl(p) (__asm__ __volatile__ ("dcbzl 0,%0" : : "r" (p)))
+#define dcbz_64(p) dcbzl(p)
+#define dcbf_64(p) dcbf(p)
+
+/* Commonly used combo */
+#define dcbit_ro(p) \
+	do { \
+		dcbi(p); \
+		dcbt_ro(p); \
+	} while (0)
+
+static inline u64 mfatb(void)
+{
+	u32 hi, lo, chk;
+	do {
+		hi = mfspr(SPRN_ATBU);
+		lo = mfspr(SPRN_ATBL);
+		chk = mfspr(SPRN_ATBU);
+	} while (unlikely(hi != chk));
+	return ((u64)hi << 32) | (u64)lo;
+}
+
+#endif
diff --git a/drivers/staging/fsl_qbman/dpa_sys_ppc64.h b/drivers/staging/fsl_qbman/dpa_sys_ppc64.h
new file mode 100644
index 0000000..633ee3f
--- /dev/null
+++ b/drivers/staging/fsl_qbman/dpa_sys_ppc64.h
@@ -0,0 +1,79 @@
+/* Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef DPA_SYS_PPC64_H
+#define DPA_SYS_PPC64_H
+
+/* Implementation of PowerPC 64 bit specific routines */
+
+/* TODO: NB, we currently assume that hwsync() and lwsync() imply compiler
+ * barriers and that dcb*() won't fall victim to compiler or execution
+ * reordering with respect to other code/instructions that manipulate the same
+ * cacheline. */
+#define hwsync() (__asm__ __volatile__ ("sync" : : : "memory"))
+#define lwsync() (__asm__ __volatile__ (stringify_in_c(LWSYNC) : : : "memory"))
+#define dcbf(p) (__asm__ __volatile__ ("dcbf 0,%0" : : "r" (p) : "memory"))
+#define dcbt_ro(p) (__asm__ __volatile__ ("dcbt 0,%0" : : "r" (p)))
+#define dcbt_rw(p) (__asm__ __volatile__ ("dcbtst 0,%0" : : "r" (p)))
+#define dcbi(p) dcbf(p)
+
+#define dcbz(p) (__asm__ __volatile__ ("dcbz 0,%0" : : "r" (p)))
+#define dcbz_64(p) \
+	do { \
+		dcbz((u32)p + 32);	\
+		dcbz(p);	\
+	} while (0)
+#define dcbf_64(p) \
+	do { \
+		dcbf((u32)p + 32); \
+		dcbf(p); \
+	} while (0)
+/* Commonly used combo */
+#define dcbit_ro(p) \
+	do { \
+		dcbi(p); \
+		dcbi((u32)p + 32); \
+		dcbt_ro(p); \
+		dcbt_ro((u32)p + 32); \
+	} while (0)
+
+static inline u64 mfatb(void)
+{
+	u32 hi, lo, chk;
+	do {
+		hi = mfspr(SPRN_ATBU);
+		lo = mfspr(SPRN_ATBL);
+		chk = mfspr(SPRN_ATBU);
+	} while (unlikely(hi != chk));
+	return ((u64)hi << 32) | (u64)lo;
+}
+
+#endif
diff --git a/drivers/staging/fsl_qbman/qbman_driver.c b/drivers/staging/fsl_qbman/qbman_driver.c
index a2904bd..4b7e799 100644
--- a/drivers/staging/fsl_qbman/qbman_driver.c
+++ b/drivers/staging/fsl_qbman/qbman_driver.c
@@ -32,12 +32,17 @@
 #include <linux/time.h>
 #include "qman_private.h"
 #include "bman_private.h"
+__init void qman_init_early(void);
+__init void bman_init_early(void);
 
 static __init int qbman_init(void)
 {
 	struct device_node *dn;
 	u32 is_portal_available;
 
+	qman_init_early();
+	bman_init_early();
+
 	bman_init();
 	qman_init();
 
diff --git a/drivers/staging/fsl_qbman/qman_config.c b/drivers/staging/fsl_qbman/qman_config.c
index 8a10c22..60ce2e9 100644
--- a/drivers/staging/fsl_qbman/qman_config.c
+++ b/drivers/staging/fsl_qbman/qman_config.c
@@ -31,6 +31,7 @@
 
 #include <asm/cacheflush.h>
 #include "qman_private.h"
+#include <linux/highmem.h>
 
 /* Last updated for v00.800 of the BG */
 
@@ -396,6 +397,8 @@ static int qm_init_pfdr(struct qman *qm, u32 pfdr_start, u32 num)
 	lwsync();
 	qm_out(MCR, MCR_INIT_PFDR);
 	/* Poll for the result */
+	/* TODO: Bootup hanges without this pr_info???? */
+	pr_info("Waiting for PFDR result\n");
 	do {
 		rslt = MCR_get_rslt(qm_in(MCR));
 	} while (!MCR_rslt_idle(rslt));
@@ -435,17 +438,24 @@ static __init int parse_mem_property(struct device_node *node, const char *name,
 {
 	const u32 *pint;
 	int ret;
-	unsigned long vaddr;
+	void *vaddr;
 
 	pint = of_get_property(node, name, &ret);
 	if (!pint || (ret != 16)) {
 		pr_info("No %s property '%s', using memblock_alloc(%016zx)\n",
 				node->full_name, name, *sz);
+		/* TODO: memblock_alloc memory isn't working on ARM
+		   (not sure why).  Revert to using kmalloc() for now
 		*addr = memblock_alloc(*sz, *sz);
 		vaddr = (unsigned long)phys_to_virt(*addr);
+		*/
+		vaddr = kmalloc(*sz, GFP_KERNEL);
+		*addr = __pa(vaddr);
 		if (zero)
 			memset((void *)vaddr, 0, *sz);
-		flush_dcache_range(vaddr, vaddr + *sz);
+
+		flush_dcache_range((unsigned long) vaddr,
+				   (unsigned long)vaddr + *sz);
 		return 0;
 	}
 	pr_info("Using %s property '%s'\n", node->full_name, name);
@@ -464,16 +474,18 @@ static __init int parse_mem_property(struct device_node *node, const char *name,
 			pr_err("Failed to reserve %s\n", name);
 			return -ENOMEM;
 		}
-		vaddr = (unsigned long)phys_to_virt(*addr);
+		vaddr = phys_to_virt(*addr);
 		if (zero)
 			memset(phys_to_virt(*addr), 0, *sz);
-		flush_dcache_range(vaddr, vaddr + *sz);
+		flush_dcache_range((unsigned long) vaddr,
+				   (unsigned long) vaddr + *sz);
 	} else if (zero) {
 		/* map as cacheable, non-guarded */
 		void __iomem *tmpp = ioremap_prot(*addr, *sz, 0);
 		memset_io(tmpp, 0, *sz);
-		vaddr = (unsigned long)tmpp;
-		flush_dcache_range(vaddr, vaddr + *sz);
+		vaddr = (void *)tmpp;
+		flush_dcache_range((unsigned long) vaddr,
+				   (unsigned long) vaddr + *sz);
 		iounmap(tmpp);
 	}
 	return 0;
@@ -503,6 +515,7 @@ static int __init fsl_qman_init(struct device_node *node)
 	if (!standby) {
 		ret = parse_mem_property(node, "fsl,qman-fqd",
 					&fqd_a, &fqd_sz, 1);
+		pr_info("qman-fqd ret is %d", ret);
 		BUG_ON(ret);
 		ret = parse_mem_property(node, "fsl,qman-pfdr",
 					&pfdr_a, &pfdr_sz, 0);
@@ -566,6 +579,7 @@ __init void qman_init_early(void)
 	}
 }
 
+
 static void log_edata_bits(u32 bit_count)
 {
 	u32 i, j, mask = 0xffffffff;
@@ -669,7 +683,7 @@ static int __bind_irq(void)
 	int ret, err_irq;
 
 	err_irq = of_irq_to_resource(qm_node, 0, NULL);
-	if (err_irq == NO_IRQ) {
+	if (err_irq == 0) {
 		pr_info("Can't get %s property '%s'\n", qm_node->full_name,
 			"interrupts");
 		return -ENODEV;
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index b75bb0d..48ab5cf 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -91,9 +91,9 @@ static __init int fsl_fqid_range_init(struct device_node *node)
 		pr_err(STR_ERR_CELL, STR_FQID_RANGE, 2, node->full_name);
 		return -EINVAL;
 	}
-	qman_seed_fqid_range(range[0], range[1]);
+	qman_seed_fqid_range(be32_to_cpu(range[0]), be32_to_cpu(range[1]));
 	pr_info("Qman: FQID allocator includes range %d:%d\n",
-		range[0], range[1]);
+		be32_to_cpu(range[0]), be32_to_cpu(range[1]));
 	return 0;
 }
 
@@ -110,8 +110,8 @@ static __init int fsl_pool_channel_range_sdqcr(struct device_node *node)
 		pr_err(STR_ERR_CELL, STR_POOL_CHAN_RANGE, 1, node->full_name);
 		return -EINVAL;
 	}
-	for (ret = 0; ret < chanid[1]; ret++)
-		pools_sdqcr |= QM_SDQCR_CHANNELS_POOL_CONV(chanid[0] + ret);
+	for (ret = 0; ret < be32_to_cpu(chanid[1]); ret++)
+		pools_sdqcr |= QM_SDQCR_CHANNELS_POOL_CONV(be32_to_cpu(chanid[0]) + ret);
 	return 0;
 }
 
@@ -128,9 +128,9 @@ static __init int fsl_pool_channel_range_init(struct device_node *node)
 		pr_err(STR_ERR_CELL, STR_POOL_CHAN_RANGE, 1, node->full_name);
 		return -EINVAL;
 	}
-	qman_seed_pool_range(chanid[0], chanid[1]);
+	qman_seed_pool_range(be32_to_cpu(chanid[0]), be32_to_cpu(chanid[1]));
 	pr_info("Qman: pool channel allocator includes range %d:%d\n",
-		chanid[0], chanid[1]);
+		be32_to_cpu(chanid[0]), be32_to_cpu(chanid[1]));
 	return 0;
 }
 
@@ -148,9 +148,9 @@ static __init int fsl_cgrid_range_init(struct device_node *node)
 		pr_err(STR_ERR_CELL, STR_CGRID_RANGE, 2, node->full_name);
 		return -EINVAL;
 	}
-	qman_seed_cgrid_range(range[0], range[1]);
+	qman_seed_cgrid_range(be32_to_cpu(range[0]), be32_to_cpu(range[1]));
 	pr_info("Qman: CGRID allocator includes range %d:%d\n",
-		range[0], range[1]);
+		be32_to_cpu(range[0]), be32_to_cpu(range[1]));
 	for (cgr.cgrid = 0; cgr.cgrid < __CGR_NUM; cgr.cgrid++) {
 		ret = qman_modify_cgr(&cgr, QMAN_CGR_FLAG_USE_INIT, NULL);
 		if (ret)
@@ -183,18 +183,18 @@ static __init int fsl_ceetm_init(struct device_node *node)
 		return -EINVAL;
 	}
 
-	dcp_portal = (range[0] & 0x0F0000) >> 16;
+	dcp_portal = (be32_to_cpu(range[0]) & 0x0F0000) >> 16;
 	if (dcp_portal > qm_dc_portal_fman1) {
 		pr_err("The DCP portal %d doesn't support CEETM\n", dcp_portal);
 		return -EINVAL;
 	}
 
 	if (dcp_portal == qm_dc_portal_fman0)
-		qman_seed_ceetm0_lfqid_range(range[0], range[1]);
+		qman_seed_ceetm0_lfqid_range(be32_to_cpu(range[0]), be32_to_cpu(range[1]));
 	if (dcp_portal == qm_dc_portal_fman1)
-		qman_seed_ceetm1_lfqid_range(range[0], range[1]);
+		qman_seed_ceetm1_lfqid_range(be32_to_cpu(range[0]), be32_to_cpu(range[1]));
 	pr_debug("Qman: The lfqid allocator of CEETM %d includes range"
-			" 0x%x:0x%x\n", dcp_portal, range[0], range[1]);
+		 " 0x%x:0x%x\n", dcp_portal, be32_to_cpu(range[0]), be32_to_cpu(range[1]));
 
 	qman_ceetms[dcp_portal].idx = dcp_portal;
 	INIT_LIST_HEAD(&qman_ceetms[dcp_portal].sub_portals);
@@ -219,16 +219,16 @@ static __init int fsl_ceetm_init(struct device_node *node)
 							range[0] + i);
 			return -ENOMEM;
 		}
-		sp->idx = range[0] + i;
+		sp->idx = be32_to_cpu(range[0]) + i;
 		sp->dcp_idx = dcp_portal;
 		sp->is_claimed = 0;
 		list_add_tail(&sp->node, &qman_ceetms[dcp_portal].sub_portals);
 		sp++;
 	}
 	pr_debug("Qman: Reserve sub-portal %d:%d for CEETM %d\n",
-					range[0], range[1], dcp_portal);
-	qman_ceetms[dcp_portal].sp_range[0] = range[0];
-	qman_ceetms[dcp_portal].sp_range[1] = range[1];
+		 be32_to_cpu(range[0]), be32_to_cpu(range[1]), dcp_portal);
+	qman_ceetms[dcp_portal].sp_range[0] = be32_to_cpu(range[0]);
+	qman_ceetms[dcp_portal].sp_range[1] = be32_to_cpu(range[1]);
 
 	/* Find LNI range */
 	range = of_get_property(node, "fsl,ceetm-lni-range", &ret);
@@ -249,7 +249,7 @@ static __init int fsl_ceetm_init(struct device_node *node)
 							range[0] + i);
 			return -ENOMEM;
 		}
-		lni->idx = range[0] + i;
+		lni->idx = be32_to_cpu(range[0]) + i;
 		lni->dcp_idx = dcp_portal;
 		lni->is_claimed = 0;
 		INIT_LIST_HEAD(&lni->channels);
@@ -257,9 +257,9 @@ static __init int fsl_ceetm_init(struct device_node *node)
 		lni++;
 	}
 	pr_debug("Qman: Reserve LNI %d:%d for CEETM %d\n",
-					range[0], range[1], dcp_portal);
-	qman_ceetms[dcp_portal].lni_range[0] = range[0];
-	qman_ceetms[dcp_portal].lni_range[1] = range[1];
+		 be32_to_cpu(range[0]), be32_to_cpu(range[1]), dcp_portal);
+	qman_ceetms[dcp_portal].lni_range[0] = be32_to_cpu(range[0]);
+	qman_ceetms[dcp_portal].lni_range[1] = be32_to_cpu(range[1]);
 
 	/* Find CEETM channel range */
 	range = of_get_property(node, "fsl,ceetm-channel-range", &ret);
@@ -275,11 +275,11 @@ static __init int fsl_ceetm_init(struct device_node *node)
 	}
 
 	if (dcp_portal == qm_dc_portal_fman0)
-		qman_seed_ceetm0_channel_range(range[0], range[1]);
+		qman_seed_ceetm0_channel_range(be32_to_cpu(range[0]), be32_to_cpu(range[1]));
 	if (dcp_portal == qm_dc_portal_fman1)
-		qman_seed_ceetm1_channel_range(range[0], range[1]);
+		qman_seed_ceetm1_channel_range(be32_to_cpu(range[0]), be32_to_cpu(range[1]));
 	pr_debug("Qman: The channel allocator of CEETM %d includes"
-			" range %d:%d\n", dcp_portal, range[0], range[1]);
+		 " range %d:%d\n", dcp_portal, be32_to_cpu(range[0]), be32_to_cpu(range[1]));
 
 	/* Set CEETM PRES register */
 	ret = qman_ceetm_set_prescaler(dcp_portal);
@@ -422,7 +422,7 @@ static struct qm_portal_config * __init parse_pcfg(struct device_node *node)
 	pcfg->public_cfg.channel = *channel;
 	pcfg->public_cfg.cpu = -1;
 	irq = irq_of_parse_and_map(node, 0);
-	if (irq == NO_IRQ) {
+	if (irq == 0) {
 		pr_err("Can't get %s property '%s'\n", node->full_name,
 			"interrupts");
 		goto err;
@@ -645,6 +645,7 @@ __setup("qportals=", parse_qportals);
 static void qman_portal_update_sdest(const struct qm_portal_config *pcfg,
 							unsigned int cpu)
 {
+#ifdef CONFIG_FSL_PAMU
 	struct pamu_stash_attribute stash_attr;
 	int ret;
 
@@ -660,6 +661,7 @@ static void qman_portal_update_sdest(const struct qm_portal_config *pcfg,
 			return;
 		}
 	}
+#endif
 #ifdef CONFIG_FSL_QMAN_CONFIG
 	if (qman_set_sdest(pcfg->public_cfg.channel, cpu))
 #endif
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 09fcbb8..d6f50a4 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -281,6 +281,63 @@ static inline struct qman_fq *get_fq_table_entry(u32 entry)
 }
 #endif
 
+static inline void cpu_to_hw_fqd(struct qm_fqd *fqd)
+{
+	/* Byteswap the FQD to HW format */
+	fqd->fq_ctrl = cpu_to_be16(fqd->fq_ctrl);
+	fqd->dest_wq = cpu_to_be16(fqd->dest_wq);
+	fqd->ics_cred = cpu_to_be16(fqd->ics_cred);
+	fqd->context_b = cpu_to_be32(fqd->context_b);
+}
+
+static inline void hw_fqd_to_cpu(struct qm_fqd *fqd)
+{
+	/* Byteswap the FQD to CPU format */
+	fqd->fq_ctrl = be16_to_cpu(fqd->fq_ctrl);
+	fqd->dest_wq = be16_to_cpu(fqd->dest_wq);
+	fqd->ics_cred = be16_to_cpu(fqd->ics_cred);
+	fqd->context_b = be32_to_cpu(fqd->context_b);
+}
+
+/* Swap a 40 bit address */
+static inline u64 cpu_to_be40(u64 in)
+{
+	u64 out;
+	u8 *p = (u8 *) &out;
+	p[0] = in >> 32;
+	p[1] = in >> 24;
+	p[2] = in >> 16;
+	p[3] = in >> 8;
+	p[4] = in >> 0;
+	return out;
+}
+static inline u64 be40_to_cpu(u64 in)
+{
+	u64 out = 0;
+	u8 *pout = (u8 *) &out;
+	u8 *pin = (u8 *) &in;
+	pout[0] = pin[4];
+	pout[1] = pin[3];
+	pout[2] = pin[2];
+	pout[3] = pin[1];
+	pout[4] = pin[0];
+	return out;
+}
+
+static inline void cpu_to_hw_fd(struct qm_fd *fd)
+{
+	fd->addr = cpu_to_be40(fd->addr);
+	fd->status = cpu_to_be32(fd->status);
+	fd->opaque = cpu_to_be32(fd->opaque);
+}
+
+static inline void hw_fd_to_cpu(struct qm_fd *fd)
+{
+	fd->addr = be40_to_cpu(fd->addr);
+	fd->status = be32_to_cpu(fd->status);
+	fd->opaque = be32_to_cpu(fd->opaque);
+}
+
 /* In the case that slow- and fast-path handling are both done by qman_poll()
  * (ie. because there is no interrupt handling), we ought to balance how often
  * we do the fast-path poll versus the slow-path poll. We'll use two decrementer
@@ -421,8 +478,12 @@ struct qman_portal *qman_create_portal(
 
 	__p = &portal->p;
 
+#if defined(CONFIG_ARM64)
+	portal->use_eqcr_ci_stashing = 0;
+#else
 	portal->use_eqcr_ci_stashing = ((qman_ip_rev >= QMAN_REV30) ?
 								1 : 0);
+#endif
 
 	/* prep the low-level portal struct with the mapped addresses from the
 	 * config, everything that follows depends on it and "config" is more
@@ -500,15 +561,24 @@ struct qman_portal *qman_create_portal(
 	portal->cb_dc_ern = NULL;
 	sprintf(buf, "qportal-%d", config->public_cfg.channel);
 	portal->pdev = platform_device_alloc(buf, -1);
-	if (!portal->pdev)
+	if (!portal->pdev) {
+		pr_err("qman_portal - platform_device_alloc() failed\n");
 		goto fail_devalloc;
-	if (dma_set_mask(&portal->pdev->dev, DMA_BIT_MASK(40)))
+	}
+#if defined(CONFIG_PPC) || defined(CONFIG_PPC64)
+	/* TODO: Investigate if this needed for ARM */
+	if (dma_set_mask(&portal->pdev->dev, DMA_BIT_MASK(40))) {
+		pr_err("qman_portal - dma_set_mask() failed\n");
 		goto fail_devadd;
+	}
+#endif
 	portal->pdev->dev.pm_domain = &qman_portal_device_pm_domain;
 	portal->pdev->dev.platform_data = portal;
 	ret = platform_device_add(portal->pdev);
-	if (ret)
+	if (ret) {
+		pr_err("qman_portal - platform_device_add() failed\n");
 		goto fail_devadd;
+	}
 	dpa_rbtree_init(&portal->retire_table);
 	isdr = 0xffffffff;
 	qm_isr_disable_write(__p, isdr);
@@ -877,9 +947,11 @@ mr_loop:
 			case QM_MR_VERB_FQPN:
 				/* Parked */
 #ifdef CONFIG_FSL_QMAN_FQ_LOOKUP
-				fq = get_fq_table_entry(msg->fq.contextB);
+				fq = get_fq_table_entry(
+					be32_to_cpu(msg->fq.contextB));
 #else
-				fq = (void *)(uintptr_t)msg->fq.contextB;
+				fq = (void *)(uintptr_t)
+					be32_to_cpu(msg->fq.contextB);
 #endif
 				fq_state_change(p, fq, msg, verb);
 				if (fq->cb.fqs)
@@ -905,9 +977,9 @@ mr_loop:
 		} else {
 			/* Its a software ERN */
 #ifdef CONFIG_FSL_QMAN_FQ_LOOKUP
-			fq = get_fq_table_entry(msg->ern.tag);
+			fq = get_fq_table_entry(be32_to_cpu(msg->ern.tag));
 #else
-			fq = (void *)(uintptr_t)msg->ern.tag;
+			fq = (void *)(uintptr_t)be32_to_cpu(msg->ern.tag);
 #endif
 			fq->cb.ern(p, fq, msg);
 		}
@@ -966,14 +1038,17 @@ static noinline void clear_vdqcr(struct qman_portal *p, struct qman_fq *fq)
 static inline unsigned int __poll_portal_fast(struct qman_portal *p,
 					unsigned int poll_limit)
 {
-	const struct qm_dqrr_entry *dq;
+	const struct qm_dqrr_entry *dq, *actual_dq;
+#if defined(CONFIG_ARM64)
+	struct qm_dqrr_entry dq_swapped;
+#endif
 	struct qman_fq *fq;
 	enum qman_cb_dqrr_result res;
 	unsigned int limit = 0;
 
 loop:
 	qm_dqrr_pvb_update(&p->p);
-	dq = qm_dqrr_current(&p->p);
+	actual_dq = dq = qm_dqrr_current(&p->p);
 	if (!dq)
 		goto done;
 	if (dq->stat & QM_DQRR_STAT_UNSCHEDULED) {
@@ -989,7 +1064,15 @@ loop:
 		/* this is duplicated from the SDQCR code, but we have stuff to
 		 * do before *and* after this callback, and we don't want
 		 * multiple if()s in the critical path (SDQCR). */
+#if defined(CONFIG_ARM64)
+		dq_swapped = *dq;
+		dq_swapped.fqid = be32_to_cpu(dq_swapped.fqid);
+		dq_swapped.contextB = be32_to_cpu(dq_swapped.contextB);
+		hw_fd_to_cpu(&dq_swapped.fd);
+		res = fq->cb.dqrr(p, fq, &dq_swapped);
+#else
 		res = fq->cb.dqrr(p, fq, dq);
+#endif
 		if (res == qman_cb_dqrr_stop)
 			goto done;
 		/* Check for VDQCR completion */
@@ -998,12 +1081,20 @@ loop:
 	} else {
 		/* SDQCR: contextB points to the FQ */
 #ifdef CONFIG_FSL_QMAN_FQ_LOOKUP
-		fq = get_fq_table_entry(dq->contextB);
+		fq = get_fq_table_entry(be32_to_cpu(dq->contextB));
 #else
-		fq = (void *)(uintptr_t)dq->contextB;
+		fq = (void *)(uintptr_t)be32_to_cpu(dq->contextB);
+#endif
+#if defined(CONFIG_ARM64)
+		dq_swapped = *dq;
+		dq_swapped.fqid = be32_to_cpu(dq_swapped.fqid);
+		dq_swapped.contextB = be32_to_cpu(dq_swapped.contextB);
+		hw_fd_to_cpu(&dq_swapped.fd);
+		dq = &dq_swapped;
 #endif
 		/* Now let the callback do its stuff */
 		res = fq->cb.dqrr(p, fq, dq);
+
 		/* The callback can request that we exit without consuming this
 		 * entry nor advancing; */
 		if (res == qman_cb_dqrr_stop)
@@ -1017,7 +1108,7 @@ loop:
 		(res != qman_cb_dqrr_park));
 	/* Defer just means "skip it, I'll consume it myself later on" */
 	if (res != qman_cb_dqrr_defer)
-		qm_dqrr_cdc_consume_1ptr(&p->p, dq, (res == qman_cb_dqrr_park));
+		qm_dqrr_cdc_consume_1ptr(&p->p, actual_dq, (res == qman_cb_dqrr_park));
 	/* Move forward */
 	qm_dqrr_next(&p->p);
 	/* Entry processed and consumed, increment our counter. The callback can
@@ -1092,6 +1183,7 @@ int qman_p_irqsource_remove(struct qman_portal *p, u32 bits)
 	bits &= QM_PIRQ_VISIBLE;
 	clear_bits(bits, &p->irq_sources);
 	qm_isr_enable_write(&p->p, p->irq_sources);
+
 	ier = qm_isr_enable_read(&p->p);
 	/* Using "~ier" (rather than "bits" or "~p->irq_sources") creates a
 	 * data-dependency, ie. to protect against re-ordering. */
@@ -1378,7 +1470,7 @@ int qman_create_fq(u32 fqid, u32 flags, struct qman_fq *fq)
 	p = get_affine_portal();
 	PORTAL_IRQ_LOCK(p, irqflags);
 	mcc = qm_mc_start(&p->p);
-	mcc->queryfq.fqid = fqid;
+	mcc->queryfq.fqid = cpu_to_be32(fqid);
 	qm_mc_commit(&p->p, QM_MCC_VERB_QUERYFQ);
 	while (!(mcr = qm_mc_result(&p->p)))
 		cpu_relax();
@@ -1388,8 +1480,9 @@ int qman_create_fq(u32 fqid, u32 flags, struct qman_fq *fq)
 		goto err;
 	}
 	fqd = mcr->queryfq.fqd;
+	hw_fqd_to_cpu(&fqd);
 	mcc = qm_mc_start(&p->p);
-	mcc->queryfq_np.fqid = fqid;
+	mcc->queryfq_np.fqid = cpu_to_be32(fqid);
 	qm_mc_commit(&p->p, QM_MCC_VERB_QUERYFQ_NP);
 	while (!(mcr = qm_mc_result(&p->p)))
 		cpu_relax();
@@ -1508,10 +1601,18 @@ int qman_init_fq(struct qman_fq *fq, u32 flags, struct qm_mcc_initfq *opts)
 		return -EBUSY;
 	}
 	mcc = qm_mc_start(&p->p);
-	if (opts)
-		mcc->initfq = *opts;
-	mcc->initfq.fqid = fq->fqid;
+	if (opts) {
+		/* TODO: work around ARM alignment issue */
+		/* mcc->initfq = *opts; */
+		int i;
+		u8 *dest = (u8 *) &mcc->initfq;
+		u8 *src = (u8 *) opts;
+		for (i = 0; i < sizeof(opts); i++)
+			dest[i] = src[i];
+	}
+	mcc->initfq.fqid = cpu_to_be32(fq->fqid);
 	mcc->initfq.count = 0;
+
 	/* If the FQ does *not* have the TO_DCPORTAL flag, contextB is set as a
 	 * demux pointer. Otherwise, the caller-provided value is allowed to
 	 * stand, don't overwrite it. */
@@ -1542,6 +1643,8 @@ int qman_init_fq(struct qman_fq *fq, u32 flags, struct qm_mcc_initfq *opts)
 			mcc->initfq.fqd.dest.wq = 4;
 		}
 	}
+	mcc->initfq.we_mask = cpu_to_be16(mcc->initfq.we_mask);
+	cpu_to_hw_fqd(&mcc->initfq.fqd);
 	qm_mc_commit(&p->p, myverb);
 	while (!(mcr = qm_mc_result(&p->p)))
 		cpu_relax();
@@ -1597,7 +1700,7 @@ int qman_schedule_fq(struct qman_fq *fq)
 		goto out;
 	}
 	mcc = qm_mc_start(&p->p);
-	mcc->alterfq.fqid = fq->fqid;
+	mcc->alterfq.fqid = cpu_to_be32(fq->fqid);
 	qm_mc_commit(&p->p, QM_MCC_VERB_ALTER_SCHED);
 	while (!(mcr = qm_mc_result(&p->p)))
 		cpu_relax();
@@ -1645,7 +1748,7 @@ int qman_retire_fq(struct qman_fq *fq, u32 *flags)
 	if (rval)
 		goto out;
 	mcc = qm_mc_start(&p->p);
-	mcc->alterfq.fqid = fq->fqid;
+	mcc->alterfq.fqid = cpu_to_be32(fq->fqid);
 	qm_mc_commit(&p->p, QM_MCC_VERB_ALTER_RETIRE);
 	while (!(mcr = qm_mc_result(&p->p)))
 		cpu_relax();
@@ -1728,7 +1831,7 @@ int qman_oos_fq(struct qman_fq *fq)
 		goto out;
 	}
 	mcc = qm_mc_start(&p->p);
-	mcc->alterfq.fqid = fq->fqid;
+	mcc->alterfq.fqid = cpu_to_be32(fq->fqid);
 	qm_mc_commit(&p->p, QM_MCC_VERB_ALTER_OOS);
 	while (!(mcr = qm_mc_result(&p->p)))
 		cpu_relax();
@@ -1836,7 +1939,7 @@ int qman_query_fq_np(struct qman_fq *fq, struct qm_mcr_queryfq_np *np)
 
 	PORTAL_IRQ_LOCK(p, irqflags);
 	mcc = qm_mc_start(&p->p);
-	mcc->queryfq.fqid = fq->fqid;
+	mcc->queryfq.fqid = cpu_to_be32(fq->fqid);
 	qm_mc_commit(&p->p, QM_MCC_VERB_QUERYFQ_NP);
 	while (!(mcr = qm_mc_result(&p->p)))
 		cpu_relax();
@@ -1925,7 +2028,7 @@ int qman_query_cgr(struct qman_cgr *cgr, struct qm_mcr_querycgr *cgrd)
 
 	PORTAL_IRQ_LOCK(p, irqflags);
 	mcc = qm_mc_start(&p->p);
-	mcc->querycgr.cgid = cgr->cgrid;
+	mcc->querycgr.cgid = cpu_to_be32(cgr->cgrid);
 	qm_mc_commit(&p->p, QM_MCC_VERB_QUERYCGR);
 	while (!(mcr = qm_mc_result(&p->p)))
 		cpu_relax();
@@ -2202,6 +2305,7 @@ static inline struct qm_eqcr_entry *try_p_eq_start(struct qman_portal *p,
 	eq->tag = cpu_to_be32((u32)(uintptr_t)fq);
 #endif
 	eq->fd = *fd;
+	cpu_to_hw_fd(&eq->fd);
 	return eq;
 }
 
@@ -2367,8 +2471,8 @@ int qman_p_enqueue_orp(struct qman_portal *p, struct qman_fq *fq,
 			/* No need to check 4 QMAN_ENQUEUE_FLAG_HOLE */
 			orp_seqnum &= ~QM_EQCR_SEQNUM_NESN;
 	}
-	eq->seqnum = orp_seqnum;
-	eq->orp = orp->fqid;
+	eq->seqnum = cpu_to_be16(orp_seqnum);
+	eq->orp = cpu_to_be32(orp->fqid);
 	/* Note: QM_EQCR_VERB_INTERRUPT == QMAN_ENQUEUE_FLAG_WAIT_SYNC */
 	qm_eqcr_pvb_commit(&p->p, QM_EQCR_VERB_ORP |
 		((flags & (QMAN_ENQUEUE_FLAG_HOLE | QMAN_ENQUEUE_FLAG_NESN)) ?
@@ -2415,8 +2519,8 @@ int qman_enqueue_orp(struct qman_fq *fq, const struct qm_fd *fd, u32 flags,
 			/* No need to check 4 QMAN_ENQUEUE_FLAG_HOLE */
 			orp_seqnum &= ~QM_EQCR_SEQNUM_NESN;
 	}
-	eq->seqnum = orp_seqnum;
-	eq->orp = orp->fqid;
+	eq->seqnum = cpu_to_be32(orp_seqnum);
+	eq->orp = cpu_to_be32(orp->fqid);
 	/* Note: QM_EQCR_VERB_INTERRUPT == QMAN_ENQUEUE_FLAG_WAIT_SYNC */
 	qm_eqcr_pvb_commit(&p->p, QM_EQCR_VERB_ORP |
 		((flags & (QMAN_ENQUEUE_FLAG_HOLE | QMAN_ENQUEUE_FLAG_NESN)) ?
@@ -2532,6 +2636,14 @@ int qman_modify_cgr(struct qman_cgr *cgr, u32 flags,
 	mcc = qm_mc_start(&p->p);
 	if (opts)
 		mcc->initcgr = *opts;
+	mcc->initcgr.we_mask = cpu_to_be16(mcc->initcgr.we_mask);
+	mcc->initcgr.cgr.wr_parm_g.word =
+		cpu_to_be32(mcc->initcgr.cgr.wr_parm_g.word);
+	mcc->initcgr.cgr.wr_parm_y.word =
+		cpu_to_be32(mcc->initcgr.cgr.wr_parm_y.word);
+	mcc->initcgr.cgr.wr_parm_r.word =
+		cpu_to_be32(mcc->initcgr.cgr.wr_parm_r.word);
+
 	mcc->initcgr.cgid = cgr->cgrid;
 	if (flags & QMAN_CGR_FLAG_USE_INIT)
 		verb = QM_MCC_VERB_INITCGR;
diff --git a/drivers/staging/fsl_qbman/qman_low.h b/drivers/staging/fsl_qbman/qman_low.h
index 5d3e820..5b50924 100644
--- a/drivers/staging/fsl_qbman/qman_low.h
+++ b/drivers/staging/fsl_qbman/qman_low.h
@@ -36,6 +36,8 @@
 /***************************/
 
 /* Cache-inhibited register offsets */
+#if defined(CONFIG_PPC32) || defined(CONFIG_PPC64)
+
 #define QM_REG_EQCR_PI_CINH	0x0000
 #define QM_REG_EQCR_CI_CINH	0x0004
 #define QM_REG_EQCR_ITR		0x0008
@@ -68,6 +70,45 @@
 #define QM_CL_RR0		0x3900
 #define QM_CL_RR1		0x3940
 
+#endif
+
+#if defined(CONFIG_ARM64)
+
+#define QM_REG_EQCR_PI_CINH	0x3000
+#define QM_REG_EQCR_CI_CINH	0x3040
+#define QM_REG_EQCR_ITR		0x3080
+#define QM_REG_DQRR_PI_CINH	0x3100
+#define QM_REG_DQRR_CI_CINH	0x3140
+#define QM_REG_DQRR_ITR		0x3180
+#define QM_REG_DQRR_DCAP	0x31C0
+#define QM_REG_DQRR_SDQCR	0x3200
+#define QM_REG_DQRR_VDQCR	0x3240
+#define QM_REG_DQRR_PDQCR	0x3280
+#define QM_REG_MR_PI_CINH	0x3300
+#define QM_REG_MR_CI_CINH	0x3340
+#define QM_REG_MR_ITR		0x3380
+#define QM_REG_CFG		0x3500
+#define QM_REG_ISR		0x3600
+#define QM_REG_IIR              0x36C0
+#define QM_REG_ITPR		0x3740
+
+/* Cache-enabled register offsets */
+#define QM_CL_EQCR		0x0000
+#define QM_CL_DQRR		0x1000
+#define QM_CL_MR		0x2000
+#define QM_CL_EQCR_PI_CENA	0x3000
+#define QM_CL_EQCR_CI_CENA	0x3040
+#define QM_CL_DQRR_PI_CENA	0x3100
+#define QM_CL_DQRR_CI_CENA	0x3140
+#define QM_CL_MR_PI_CENA	0x3300
+#define QM_CL_MR_CI_CENA	0x3340
+#define QM_CL_CR		0x3800
+#define QM_CL_RR0		0x3900
+#define QM_CL_RR1		0x3940
+
+#endif
+
+
 /* BTW, the drivers (and h/w programming model) already obtain the required
  * synchronisation for portal accesses via lwsync(), hwsync(), and
  * data-dependencies. Use of barrier()s or other order-preserving primitives
@@ -76,19 +117,20 @@
  * non-coherent). */
 
 /* Cache-inhibited register access. */
-#define __qm_in(qm, o)		__raw_readl((qm)->addr_ci + (o))
-#define __qm_out(qm, o, val)	__raw_writel((val), (qm)->addr_ci + (o))
+#define __qm_in(qm, o)		be32_to_cpu(__raw_readl((qm)->addr_ci  + (o)))
+#define __qm_out(qm, o, val)	__raw_writel((cpu_to_be32(val)), \
+					     (qm)->addr_ci + (o));
 #define qm_in(reg)		__qm_in(&portal->addr, QM_REG_##reg)
 #define qm_out(reg, val)	__qm_out(&portal->addr, QM_REG_##reg, val)
 
 /* Cache-enabled (index) register access */
 #define __qm_cl_touch_ro(qm, o) dcbt_ro((qm)->addr_ce + (o))
 #define __qm_cl_touch_rw(qm, o) dcbt_rw((qm)->addr_ce + (o))
-#define __qm_cl_in(qm, o)	__raw_readl((qm)->addr_ce + (o))
+#define __qm_cl_in(qm, o)	be32_to_cpu(__raw_readl((qm)->addr_ce + (o)))
 #define __qm_cl_out(qm, o, val) \
 	do { \
 		u32 *__tmpclout = (qm)->addr_ce + (o); \
-		__raw_writel((val), __tmpclout); \
+		__raw_writel(cpu_to_be32(val), __tmpclout); \
 		dcbf(__tmpclout); \
 	} while (0)
 #define __qm_cl_invalidate(qm, o) dcbi((qm)->addr_ce + (o))
@@ -1120,13 +1162,21 @@ static inline void qm_isr_set_iperiod(struct qm_portal *portal, u16 iperiod)
 
 static inline u32 __qm_isr_read(struct qm_portal *portal, enum qm_isr_reg n)
 {
+#if defined(CONFIG_ARM64)
+	return __qm_in(&portal->addr, QM_REG_ISR + (n << 6));
+#else
 	return __qm_in(&portal->addr, QM_REG_ISR + (n << 2));
+#endif
 }
 
 static inline void __qm_isr_write(struct qm_portal *portal, enum qm_isr_reg n,
 					u32 val)
 {
+#if defined(CONFIG_ARM64)
+	__qm_out(&portal->addr, QM_REG_ISR + (n << 6), val);
+#else
 	__qm_out(&portal->addr, QM_REG_ISR + (n << 2), val);
+#endif
 }
 
 /* Cleanup FQs */
diff --git a/drivers/staging/fsl_qbman/qman_private.h b/drivers/staging/fsl_qbman/qman_private.h
index b6e7e62..2734f7e 100644
--- a/drivers/staging/fsl_qbman/qman_private.h
+++ b/drivers/staging/fsl_qbman/qman_private.h
@@ -32,7 +32,10 @@
 #include "dpa_sys.h"
 #include <linux/fsl_qman.h>
 #include <linux/iommu.h>
+
+#if defined(CONFIG_FSL_PAMU)
 #include <asm/fsl_pamu_stash.h>
+#endif
 
 #if !defined(CONFIG_FSL_QMAN_FQ_LOOKUP) && defined(CONFIG_PPC64)
 #error "_PPC64 requires _FSL_QMAN_FQ_LOOKUP"
diff --git a/drivers/staging/fsl_qbman/qman_test.h b/drivers/staging/fsl_qbman/qman_test.h
index 941a431..4d4ca33 100644
--- a/drivers/staging/fsl_qbman/qman_test.h
+++ b/drivers/staging/fsl_qbman/qman_test.h
@@ -36,6 +36,7 @@
 #include <linux/module.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>
+#include <linux/sched.h>
 
 #include <linux/fsl_qman.h>
 
diff --git a/include/linux/fsl_bman.h b/include/linux/fsl_bman.h
index 265d806..4394222 100644
--- a/include/linux/fsl_bman.h
+++ b/include/linux/fsl_bman.h
@@ -87,15 +87,28 @@ struct bm_mc_result;	/* MC result */
 struct bm_buffer {
 	union {
 		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 			u8 __reserved1;
 			u8 bpid;
 			u16 hi; /* High 16-bits of 48-bit address */
 			u32 lo; /* Low 32-bits of 48-bit address */
+#else
+			u32 lo;
+			u16 hi;
+			u8 bpid;
+			u8 __reserved;
+#endif
 		};
 		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 			u64 __notaddress:16;
 			u64 addr:48;
+#else
+			u64 addr:48;
+			u64 __notaddress:16;
+#endif
 		};
+		u64 opaque;
 	};
 } __aligned(8);
 static inline u64 bm_buffer_get64(const struct bm_buffer *buf)
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index 89721b9..205af44 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -149,6 +149,7 @@ enum qm_fd_format {
 struct qm_fd {
 	union {
 		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 			u8 dd:2;	/* dynamic debug */
 			u8 liodn_offset:6;
 			u8 bpid:8;	/* Buffer Pool ID */
@@ -156,6 +157,15 @@ struct qm_fd {
 			u8 __reserved:4;
 			u8 addr_hi;	/* high 8-bits of 40-bit address */
 			u32 addr_lo;	/* low 32-bits of 40-bit address */
+#else
+			u8 liodn_offset:6;
+			u8 dd:2;	/* dynamic debug */
+			u8 bpid:8;	/* Buffer Pool ID */
+			u8 __reserved:4;
+			u8 eliodn_offset:4;
+			u8 addr_hi;	/* high 8-bits of 40-bit address */
+			u32 addr_lo;	/* low 32-bits of 40-bit address */
+#endif
 		};
 		struct {
 			u64 __notaddress:24;
@@ -237,17 +247,33 @@ struct qm_sg_entry {
 			u32 addr_lo;	/* low 32-bits of 40-bit address */
 		};
 		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 			u64 __notaddress:24;
 			u64 addr:40;
+#else
+			u64 addr:40;
+			u64 __notaddress:24;
+#endif
 		};
 	};
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 	u32 extension:1;	/* Extension bit */
 	u32 final:1;		/* Final bit */
 	u32 length:30;
+#else
+	u32 length:30;
+	u32 final:1;		/* Final bit */
+	u32 extension:1;	/* Extension bit */
+#endif
 	u8 __reserved2;
 	u8 bpid;
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 	u16 __reserved3:3;
 	u16 offset:13;
+#else
+	u16 offset:13;
+	u16 __reserved3:3;
+#endif
 } __packed;
 static inline u64 qm_sg_entry_get64(const struct qm_sg_entry *sg)
 {
@@ -330,9 +356,15 @@ struct qm_mr_entry {
 			struct qm_fd fd;
 		} __packed ern;
 		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 			u8 colour:2;	/* See QM_MR_DCERN_COLOUR_* */
 			u8 __reserved1:3;
 			enum qm_dc_portal portal:3;
+#else
+			enum qm_dc_portal portal:3;
+			u8 __reserved1:3;
+			u8 colour:2;	/* See QM_MR_DCERN_COLOUR_* */
+#endif
 			u16 __reserved2;
 			u8 rc;		/* Rejection Code */
 			u32 __reserved3:24;
@@ -385,21 +417,39 @@ struct qm_mr_entry {
 struct qm_fqd_stashing {
 	/* See QM_STASHING_EXCL_<...> */
 	u8 exclusive;
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 	u8 __reserved1:2;
 	/* Numbers of cachelines */
 	u8 annotation_cl:2;
 	u8 data_cl:2;
 	u8 context_cl:2;
+#else
+	u8 context_cl:2;
+	u8 data_cl:2;
+	u8 annotation_cl:2;
+	u8 __reserved1:2;
+#endif
 } __packed;
 struct qm_fqd_taildrop {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 	u16 __reserved1:3;
 	u16 mant:8;
 	u16 exp:5;
+#else
+	u16 exp:5;
+	u16 mant:8;
+	u16 __reserved1:3;
+#endif
 } __packed;
 struct qm_fqd_oac {
 	/* See QM_OAC_<...> */
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 	u8 oac:2; /* "Overhead Accounting Control" */
 	u8 __reserved1:6;
+#else
+	u8 __reserved1:6;
+	u8 oac:2; /* "Overhead Accounting Control" */
+#endif
 	/* Two's-complement value (-128 to +127) */
 	signed char oal; /* "Overhead Accounting Length" */
 } __packed;
@@ -407,10 +457,17 @@ struct qm_fqd {
 	union {
 		u8 orpc;
 		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 			u8 __reserved1:2;
 			u8 orprws:3;
 			u8 oa:1;
 			u8 olws:2;
+#else
+			u8 olws:2;
+			u8 oa:1;
+			u8 orprws:3;
+			u8 __reserved1:2;
+#endif
 		} __packed;
 	};
 	u8 cgid;
@@ -418,12 +475,22 @@ struct qm_fqd {
 	union {
 		u16 dest_wq;
 		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 			u16 channel:13; /* qm_channel */
 			u16 wq:3;
+#else
+			u16 wq:3;
+			u16 channel:13; /* qm_channel */
+#endif
 		} __packed dest;
 	};
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 	u16 __reserved2:1;
 	u16 ics_cred:15;
+#else
+	u16 __reserved2:1;
+	u16 ics_cred:15;
+#endif
 	/* For "Initialize Frame Queue" commands, the write-enable mask
 	 * determines whether 'td' or 'oac_init' is observed. For query
 	 * commands, this field is always 'td', and 'oac_query' (below) reflects
@@ -542,11 +609,19 @@ struct qm_cgr_wr_parm {
 	union {
 		u32 word;
 		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 			u32 MA:8;
 			u32 Mn:5;
 			u32 SA:7; /* must be between 64-127 */
 			u32 Sn:6;
 			u32 Pn:6;
+#else
+			u32 Pn:6;
+			u32 Sn:6;
+			u32 SA:7; /* must be between 64-127 */
+			u32 Mn:5;
+			u32 MA:8;
+#endif
 		} __packed;
 	};
 } __packed;
@@ -557,9 +632,15 @@ struct qm_cgr_wr_parm {
  *   CS threshold = TA * (2 ^ Tn)
  */
 struct qm_cgr_cs_thres {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 	u16 __reserved:3;
 	u16 TA:8;
 	u16 Tn:5;
+#else
+	u16 Tn:5;
+	u16 TA:8;
+	u16 __reserved:3;
+#endif
 } __packed;
 /* This identical structure of CGR fields is present in the "Init/Modify CGR"
  * commands and the "Query CGR" result. It's suctioned out here into its own
@@ -677,8 +758,13 @@ struct qm_mcc_querywq {
 	union {
 		u16 channel_wq; /* ignores wq (3 lsbits) */
 		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 			u16 id:13; /* qm_channel */
 			u16 __reserved1:3;
+#else
+			u16 __reserved1:3;
+			u16 id:13; /* qm_channel */
+#endif
 		} __packed channel;
 	};
 	u8 __reserved2[60];
@@ -777,8 +863,13 @@ struct qm_mcc_ceetm_mapping_shaper_tcfc_config {
 			u8 __reserved2[58];
 		} __packed channel_mapping;
 		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 			u8 map_reserved:5;
 			u8 map_lni_id:3;
+#else
+			u8 map_lni_id:3;
+			u8 map_reserved:5;
+#endif
 			u8 __reserved2[58];
 		} __packed sp_mapping;
 		struct {
-- 
1.7.5.4

