From 46b6bec34d5d7dca06578f85dd5adcccc793722d Mon Sep 17 00:00:00 2001
From: Mandy Lavi <mandy.lavi@freescale.com>
Date: Thu, 16 Jul 2015 20:41:24 +0300
Subject: [PATCH 309/451] fmd: update fman to its sdk1.8 state

Signed-off-by: Mandy Lavi <mandy.lavi@freescale.com>
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/net/ethernet/freescale/fman/Kconfig        |   28 +-
 drivers/net/ethernet/freescale/fman/Makefile       |    2 +-
 .../freescale/fman/Peripherals/FM/HC/Makefile      |    4 +-
 .../ethernet/freescale/fman/Peripherals/FM/HC/hc.c |   70 +-
 .../freescale/fman/Peripherals/FM/MAC/Makefile     |   10 +-
 .../freescale/fman/Peripherals/FM/MAC/dtsec.c      |  102 +-
 .../fman/Peripherals/FM/MAC/dtsec_mii_acc.c        |   11 +-
 .../freescale/fman/Peripherals/FM/MAC/fm_mac.c     |   14 +-
 .../freescale/fman/Peripherals/FM/MAC/fm_mac.h     |    2 +-
 .../freescale/fman/Peripherals/FM/MAC/fman_dtsec.c |    1 -
 .../fman/Peripherals/FM/MAC/fman_dtsec_mii_acc.c   |    1 +
 .../freescale/fman/Peripherals/FM/MAC/fman_memac.c |    8 +-
 .../fman/Peripherals/FM/MAC/fman_memac_mii_acc.c   |    1 +
 .../freescale/fman/Peripherals/FM/MAC/memac.c      |  116 +-
 .../freescale/fman/Peripherals/FM/MAC/memac.h      |    1 +
 .../fman/Peripherals/FM/MAC/memac_mii_acc.h        |    4 +-
 .../freescale/fman/Peripherals/FM/MAC/tgec.c       |   66 +-
 .../freescale/fman/Peripherals/FM/MACSEC/Makefile  |   15 +
 .../fman/Peripherals/FM/MACSEC/fm_macsec.c         |  237 +
 .../fman/Peripherals/FM/MACSEC/fm_macsec.h         |  203 +
 .../fman/Peripherals/FM/MACSEC/fm_macsec_guest.c   |   59 +
 .../fman/Peripherals/FM/MACSEC/fm_macsec_master.c  | 1031 ++++
 .../fman/Peripherals/FM/MACSEC/fm_macsec_master.h  |  479 ++
 .../fman/Peripherals/FM/MACSEC/fm_macsec_secy.c    |  908 ++++
 .../fman/Peripherals/FM/MACSEC/fm_macsec_secy.h    |  144 +
 .../freescale/fman/Peripherals/FM/Makefile         |    5 +-
 .../freescale/fman/Peripherals/FM/Pcd/Makefile     |   12 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_cc.c      | 5333 +++++++++++---------
 .../freescale/fman/Peripherals/FM/Pcd/fm_cc.h      |   17 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_kg.c      |  227 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_manip.c   | 5038 ++++++++++++-------
 .../freescale/fman/Peripherals/FM/Pcd/fm_manip.h   |  178 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_pcd.c     |  127 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_pcd.h     |   11 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_plcr.c    |  119 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_prs.c     |   57 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_prs.h     |  215 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_replic.c  |   26 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_replic.h  |    4 +-
 .../freescale/fman/Peripherals/FM/Pcd/fman_kg.c    |   16 +-
 .../freescale/fman/Peripherals/FM/Port/Makefile    |    4 +-
 .../freescale/fman/Peripherals/FM/Port/fm_port.c   | 4566 ++++++++++--------
 .../freescale/fman/Peripherals/FM/Port/fm_port.h   |   63 +-
 .../fman/Peripherals/FM/Port/fm_port_dsar.h        |   30 +-
 .../fman/Peripherals/FM/Port/fm_port_im.c          |    9 +-
 .../freescale/fman/Peripherals/FM/Port/fman_port.c |   10 +-
 .../freescale/fman/Peripherals/FM/Rtc/Makefile     |    4 +-
 .../freescale/fman/Peripherals/FM/Rtc/fm_rtc.c     |   55 +-
 .../freescale/fman/Peripherals/FM/SP/Makefile      |    4 +-
 .../freescale/fman/Peripherals/FM/SP/fm_sp.c       |    4 +-
 .../ethernet/freescale/fman/Peripherals/FM/fm.c    |  705 ++--
 .../ethernet/freescale/fman/Peripherals/FM/fm.h    |   64 +-
 .../freescale/fman/Peripherals/FM/fm_ipc.h         |    1 +
 .../freescale/fman/Peripherals/FM/fm_muram.c       |    1 -
 .../ethernet/freescale/fman/Peripherals/FM/fman.c  |   27 +-
 .../freescale/fman/Peripherals/FM/inc/fm_common.h  |  123 +-
 .../freescale/fman/Peripherals/FM/inc/fm_hc.h      |    4 +-
 drivers/net/ethernet/freescale/fman/etc/Makefile   |    2 +-
 drivers/net/ethernet/freescale/fman/etc/mm.c       |   19 +-
 .../net/ethernet/freescale/fman/fmanv3h_dflags.h   |   57 +
 .../net/ethernet/freescale/fman/fmanv3l_dflags.h   |   56 +
 .../freescale/fman/inc/Peripherals/fm_ext.h        |   19 +-
 .../freescale/fman/inc/Peripherals/fm_macsec_ext.h | 1271 +++++
 .../freescale/fman/inc/Peripherals/fm_pcd_ext.h    |  243 +-
 .../freescale/fman/inc/Peripherals/fm_port_ext.h   |   96 +-
 drivers/net/ethernet/freescale/fman/inc/core_ext.h |   23 +-
 .../net/ethernet/freescale/fman/inc/ddr_std_ext.h  |    1 +
 .../net/ethernet/freescale/fman/inc/debug_ext.h    |   74 +-
 .../net/ethernet/freescale/fman/inc/endian_ext.h   |    1 +
 .../net/ethernet/freescale/fman/inc/error_ext.h    |    6 +
 .../fman/inc/flib/common/arch/ppc_access.h         |    1 +
 .../freescale/fman/inc/flib/common/general.h       |    4 +
 .../ethernet/freescale/fman/inc/flib/fsl_fman.h    |    7 +-
 .../ethernet/freescale/fman/inc/flib/fsl_fman_kg.h |    2 +-
 .../freescale/fman/inc/flib/fsl_fman_memac.h       |    2 +
 .../freescale/fman/inc/flib/fsl_fman_port.h        |    3 +-
 .../integrations/FMANV3H/dpaa_integration_ext.h    |  290 ++
 .../fman/inc/integrations/FMANV3H/part_ext.h       |   71 +
 .../integrations/FMANV3H/part_integration_ext.h    |  304 ++
 .../integrations/FMANV3L/dpaa_integration_ext.h    |  290 ++
 .../fman/inc/integrations/FMANV3L/part_ext.h       |   59 +
 .../integrations/FMANV3L/part_integration_ext.h    |  304 ++
 .../inc/integrations/LS1043/dpaa_integration_ext.h |   26 +-
 .../inc/integrations/LS1043/part_integration_ext.h |   72 +-
 .../inc/integrations/P1023/dpaa_integration_ext.h  |   27 +-
 .../P3040_P4080_P5020/dpaa_integration_ext.h       |   12 +-
 drivers/net/ethernet/freescale/fman/inc/ncsw_ext.h |   14 +-
 .../net/ethernet/freescale/fman/inc/types_ext.h    |   14 +-
 .../net/ethernet/freescale/fman/inc/xx_common.h    |    2 +-
 drivers/net/ethernet/freescale/fman/ncsw_config.mk |   49 +-
 drivers/net/ethernet/freescale/fman/src/Makefile   |    2 +-
 .../ethernet/freescale/fman/src/inc/types_linux.h  |    3 +
 .../fman/src/inc/wrapper/lnxwrp_fsl_fman.h         |  275 +-
 .../ethernet/freescale/fman/src/system/Makefile    |    2 +-
 .../ethernet/freescale/fman/src/wrapper/Makefile   |   10 +-
 .../freescale/fman/src/wrapper/lnxwrp_fm.c         |  837 +++-
 .../freescale/fman/src/wrapper/lnxwrp_fm.h         |   51 +-
 .../freescale/fman/src/wrapper/lnxwrp_fm_port.c    |   81 +-
 .../freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c  |  253 +-
 .../fman/src/wrapper/lnxwrp_ioctls_fm_compat.c     |   36 +-
 .../fman/src/wrapper/lnxwrp_ioctls_fm_compat.h     |   42 +-
 .../freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c   |    2 +-
 .../freescale/fman/src/wrapper/lnxwrp_sysfs_fm.h   |    2 +-
 .../fman/src/wrapper/lnxwrp_sysfs_fm_port.c        |   48 +-
 .../net/ethernet/freescale/fman/src/xx/Makefile    |    2 +-
 .../net/ethernet/freescale/fman/src/xx/xx_linux.c  |   29 +-
 include/uapi/linux/fmd/Peripherals/fm_ioctls.h     |    4 +-
 include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h |   82 +-
 .../uapi/linux/fmd/Peripherals/fm_port_ioctls.h    |   39 +-
 109 files changed, 17510 insertions(+), 8287 deletions(-)
 create mode 100644 drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/Makefile
 create mode 100644 drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec.c
 create mode 100644 drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec.h
 create mode 100644 drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_guest.c
 create mode 100644 drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_master.c
 create mode 100644 drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_master.h
 create mode 100644 drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_secy.c
 create mode 100644 drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_secy.h
 create mode 100644 drivers/net/ethernet/freescale/fman/fmanv3h_dflags.h
 create mode 100644 drivers/net/ethernet/freescale/fman/fmanv3l_dflags.h
 create mode 100644 drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_macsec_ext.h
 create mode 100644 drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3H/dpaa_integration_ext.h
 create mode 100644 drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3H/part_ext.h
 create mode 100644 drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3H/part_integration_ext.h
 create mode 100644 drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3L/dpaa_integration_ext.h
 create mode 100644 drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3L/part_ext.h
 create mode 100644 drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3L/part_integration_ext.h

diff --git a/drivers/net/ethernet/freescale/fman/Kconfig b/drivers/net/ethernet/freescale/fman/Kconfig
index 26b4f35..198d0b91 100644
--- a/drivers/net/ethernet/freescale/fman/Kconfig
+++ b/drivers/net/ethernet/freescale/fman/Kconfig
@@ -12,6 +12,7 @@ if FSL_FMAN
 config FSL_FMAN_TEST
 	bool "FMan test module"
 	default n
+	select FSL_DPAA_HOOKS
 	---help---
 		This option compiles test code for FMan.
 
@@ -29,23 +30,20 @@ config FMAN_P3040_P4080_P5020
 config FMAN_P1023
 	bool "P1023"
 
-config FMAN_T4240
-	bool "T4240"
-
-endchoice
-endmenu
+config FMAN_V3H
+	bool "FmanV3H"
+	---help---
+	  Choose "FmanV3H" for Fman rev3H:
+	  B4860, T4240, T4160, etc
 
 config FMAN_V3L
-	depends on FMAN_T4240
-	bool "FMAN_V3L like T1040, T1042, T1020, T1022"
-	default n
+	bool "FmanV3L"
 	---help---
-	  There are two FMAN V3 version: FMAN_V3H and FMAN_V3L.
-	  T1040, T1042, T1020, T1022 belong to FMAN_V3L, there
-	  are 4 Offline/Host Command Ports (O/H n) in FMAN_V3L.
-	  But there are 6 Offline/Host Command Ports (O/H n) in
-	  FMAN_V3H.
-	  Say "Y" if chips are T1040, T1042, T1020, T1022 family.
+	  Choose "FmanV3L" for Fman rev3L:
+	  T1040, T1042, T1020, T1022, T1023, T1024, etc
+
+endchoice
+endmenu
 
 config FMAN_MIB_CNT_OVF_IRQ_EN
 	bool "Enable the dTSEC MIB counters overflow interrupt"
@@ -105,7 +103,7 @@ config FSL_FM_RX_EXTRA_HEADROOM
 
 config FMAN_PFC
 	bool "FMan PFC support (EXPERIMENTAL)"
-	depends on (FMAN_T4240 || FMAN_LS1043) && FSL_FMAN
+	depends on ( FMAN_V3H || FMAN_V3L ) && FSL_FMAN
 	default n
 	---help---
 	  This option enables PFC support on FMan v3 ports.
diff --git a/drivers/net/ethernet/freescale/fman/Makefile b/drivers/net/ethernet/freescale/fman/Makefile
index 7115296..4a3fc9d 100644
--- a/drivers/net/ethernet/freescale/fman/Makefile
+++ b/drivers/net/ethernet/freescale/fman/Makefile
@@ -1,7 +1,7 @@
 #
 # Makefile for the Freescale Ethernet controllers
 #
-EXTRA_CFLAGS           += -DVERSION=\"\"
+ccflags-y           += -DVERSION=\"\"
 #
 #Include netcomm SW specific definitions
 include $(srctree)/drivers/net/ethernet/freescale/fman/ncsw_config.mk
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/Makefile b/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/Makefile
index bcbc72e..a6b64e8 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/Makefile
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/Makefile
@@ -1,14 +1,14 @@
 #
 # Makefile for the Freescale Ethernet controllers
 #
-EXTRA_CFLAGS           += -DVERSION=\"\"
+ccflags-y           += -DVERSION=\"\"
 #
 #Include netcomm SW specific definitions
 include $(srctree)/drivers/net/ethernet/freescale/fman/ncsw_config.mk
 
 NCSW_FM_INC = $(srctree)/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc
 
-EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+ccflags-y += -I$(NCSW_FM_INC)
 
 obj-y		+= fsl-ncsw-Hc.o
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/hc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/hc.c
index f94b494..8bc0889 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/hc.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/hc.c
@@ -50,14 +50,14 @@
 #define HC_HCOR_OPCODE_SYNC                                     0x2
 #define HC_HCOR_OPCODE_CC                                       0x3
 #define HC_HCOR_OPCODE_CC_CAPWAP_REASSM_TIMEOUT                 0x5
-#define HC_HCOR_OPCODE_CC_IP_REASSM_TIMEOUT                     0x10
-#define HC_HCOR_OPCODE_CC_IP_FRAG_INITIALIZATION                0x11
-#define HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_ACTIVE_SHIFT       24
-#define HC_HCOR_EXTRA_REG_IP_REASSM_TIMEOUT_TSBS_SHIFT          24
-#define HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_RES_SHIFT          16
-#define HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_RES_MASK           0xF
-#define HC_HCOR_ACTION_REG_IP_FRAG_SCRATCH_POOL_CMD_SHIFT       24
-#define HC_HCOR_ACTION_REG_IP_FRAG_SCRATCH_POOL_BPID            16
+#define HC_HCOR_OPCODE_CC_REASSM_TIMEOUT                     0x10
+#define HC_HCOR_OPCODE_CC_IP_FRAG_INITIALIZATION             0x11
+#define HC_HCOR_ACTION_REG_REASSM_TIMEOUT_ACTIVE_SHIFT       24
+#define HC_HCOR_EXTRA_REG_REASSM_TIMEOUT_TSBS_SHIFT          24
+#define HC_HCOR_ACTION_REG_REASSM_TIMEOUT_RES_SHIFT          16
+#define HC_HCOR_ACTION_REG_REASSM_TIMEOUT_RES_MASK           0xF
+#define HC_HCOR_ACTION_REG_IP_FRAG_SCRATCH_POOL_CMD_SHIFT    24
+#define HC_HCOR_ACTION_REG_IP_FRAG_SCRATCH_POOL_BPID         16
 
 #define HC_HCOR_GBL                         0x20000000
 
@@ -90,12 +90,12 @@ do {                                      \
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
 
-typedef _Packed struct t_FmPcdKgPortRegs {
+typedef struct t_FmPcdKgPortRegs {
     volatile uint32_t                       spReg;
     volatile uint32_t                       cppReg;
-} _PackedType t_FmPcdKgPortRegs;
+} t_FmPcdKgPortRegs;
 
-typedef _Packed struct t_HcFrame {
+typedef struct t_HcFrame {
     volatile uint32_t                           opcode;
     volatile uint32_t                           actionReg;
     volatile uint32_t                           extraReg;
@@ -108,7 +108,7 @@ typedef _Packed struct t_HcFrame {
         t_FmPcdKgPortRegs                       portRegsForRead;
         volatile uint32_t                       clsPlanEntries[CLS_PLAN_NUM_PER_GRP];
         t_FmPcdCcCapwapReassmTimeoutParams      ccCapwapReassmTimeout;
-        t_FmPcdCcIpReassmTimeoutParams          ccIpReassmTimeout;
+        t_FmPcdCcReassmTimeoutParams            ccReassmTimeout;
     } hcSpecificData;
 } _PackedType t_HcFrame;
 
@@ -276,7 +276,7 @@ t_Handle FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
         return NULL;
     }
 
-    err = FM_PORT_ConfigMaxFrameLength(p_FmHc->h_HcPortDev, sizeof(t_HcFrame));
+    err = FM_PORT_ConfigMaxFrameLength(p_FmHc->h_HcPortDev, (uint16_t)sizeof(t_HcFrame));
     if (err != E_OK)
     {
         REPORT_ERROR(MAJOR, err, ("FM HC port init!"));
@@ -292,7 +292,6 @@ t_Handle FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
         FmHcFree(p_FmHc);
         return NULL;
     }
-printk(">>hchchc1 >> \n");
 
     err = FM_PORT_Enable(p_FmHc->h_HcPortDev);
     if (err != E_OK)
@@ -301,7 +300,6 @@ printk(">>hchchc1 >> \n");
         FmHcFree(p_FmHc);
         return NULL;
     }
-printk(">>hchchc2 >> \n");
 
     return (t_Handle)p_FmHc;
 }
@@ -344,19 +342,6 @@ t_Error FmHcSetFramesDataMemory(t_Handle h_FmHc,
     return FillBufPool(p_FmHc);
 }
 
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-t_Error FmHcDumpRegs(t_Handle h_FmHc)
-{
-    t_FmHc  *p_FmHc = (t_FmHc*)h_FmHc;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmHc, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmHc->h_HcPortDev, E_INVALID_HANDLE);
-
-    return  FM_PORT_DumpRegs(p_FmHc->h_HcPortDev);
-
-}
-#endif /* (defined(DEBUG_ERRORS) && ... */
-
 void FmHcTxConf(t_Handle h_FmHc, t_DpaaFD *p_Fd)
 {
     t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
@@ -646,7 +631,7 @@ t_Error FmHcPcdKgSetClsPlan(t_Handle h_FmHc, t_FmPcdKgInterModuleClsPlanSet *p_S
     t_FmHc                  *p_FmHc = (t_FmHc*)h_FmHc;
     t_HcFrame               *p_HcFrame;
     t_DpaaFD                fmFd;
-    uint32_t                i;
+    uint8_t                 i, idx;
     uint32_t                seqNum;
     t_Error                 err = E_OK;
 
@@ -662,7 +647,11 @@ t_Error FmHcPcdKgSetClsPlan(t_Handle h_FmHc, t_FmPcdKgInterModuleClsPlanSet *p_S
         p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
         p_HcFrame->actionReg  = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
         p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_REGS_MASK;
-        memcpy((void*)&p_HcFrame->hcSpecificData.clsPlanEntries, (void *)&p_Set->vectors[i-p_Set->baseEntry], CLS_PLAN_NUM_PER_GRP*sizeof(uint32_t));
+        ASSERT_COND(IN_RANGE(0, (i-p_Set->baseEntry) ,FM_PCD_MAX_NUM_OF_CLS_PLANS-1));
+        idx = (uint8_t)(i - p_Set->baseEntry);
+        ASSERT_COND(idx < FM_PCD_MAX_NUM_OF_CLS_PLANS);
+        memcpy(&p_HcFrame->hcSpecificData.clsPlanEntries, &p_Set->vectors[idx], CLS_PLAN_NUM_PER_GRP*sizeof(uint32_t));
+
         p_HcFrame->commandSequence = seqNum;
 
         BUILD_FD(sizeof(t_HcFrame));
@@ -694,9 +683,12 @@ t_Error FmHcPcdKgDeleteClsPlan(t_Handle h_FmHc, uint8_t  grpId)
     ASSERT_COND(p_ClsPlanSet->numOfClsPlanEntries <= FM_PCD_MAX_NUM_OF_CLS_PLANS);
 
     if (FmHcPcdKgSetClsPlan(p_FmHc, p_ClsPlanSet) != E_OK)
+    {
+        XX_Free(p_ClsPlanSet);
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-    XX_Free(p_ClsPlanSet);
+    }
 
+    XX_Free(p_ClsPlanSet);
     FmPcdKgDestroyClsPlanGrp(p_FmHc->h_FmPcd, grpId);
 
     return E_OK;
@@ -766,7 +758,7 @@ t_Error FmHcPcdCcIpFragScratchPollCmd(t_Handle h_FmHc, bool fill, t_FmPcdCcFragS
     return E_OK;
 }
 
-t_Error FmHcPcdCcIpTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcIpReassmTimeoutParams *p_CcIpReassmTimeoutParams, uint8_t *p_Result)
+t_Error FmHcPcdCcTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcReassmTimeoutParams *p_CcReassmTimeoutParams, uint8_t *p_Result)
 {
     t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
     t_HcFrame                           *p_HcFrame;
@@ -781,9 +773,9 @@ t_Error FmHcPcdCcIpTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcIpReassmTimeoutParams
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
 
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
-    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_CC_IP_REASSM_TIMEOUT);
-    p_HcFrame->actionReg = (uint32_t)((p_CcIpReassmTimeoutParams->activate ? 0 : 1) << HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_ACTIVE_SHIFT);
-    p_HcFrame->extraReg = (p_CcIpReassmTimeoutParams->tsbs << HC_HCOR_EXTRA_REG_IP_REASSM_TIMEOUT_TSBS_SHIFT) | p_CcIpReassmTimeoutParams->iprcpt;
+    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_CC_REASSM_TIMEOUT);
+    p_HcFrame->actionReg = (uint32_t)((p_CcReassmTimeoutParams->activate ? 0 : 1) << HC_HCOR_ACTION_REG_REASSM_TIMEOUT_ACTIVE_SHIFT);
+    p_HcFrame->extraReg = (p_CcReassmTimeoutParams->tsbs << HC_HCOR_EXTRA_REG_REASSM_TIMEOUT_TSBS_SHIFT) | p_CcReassmTimeoutParams->iprcpt;
     p_HcFrame->commandSequence = seqNum;
 
     BUILD_FD(sizeof(t_HcFrame));
@@ -794,7 +786,7 @@ t_Error FmHcPcdCcIpTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcIpReassmTimeoutParams
     }
 
     *p_Result = (uint8_t)
-        ((p_HcFrame->actionReg >> HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_RES_SHIFT) & HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_RES_MASK);
+        ((p_HcFrame->actionReg >> HC_HCOR_ACTION_REG_REASSM_TIMEOUT_RES_SHIFT) & HC_HCOR_ACTION_REG_REASSM_TIMEOUT_RES_MASK);
 
     PutBuf(p_FmHc, p_HcFrame, seqNum);
     return E_OK;
@@ -1224,3 +1216,9 @@ t_Error FmHcPcdSync(t_Handle h_FmHc)
 
     return E_OK;
 }
+
+t_Handle    FmHcGetPort(t_Handle h_FmHc)
+{
+    t_FmHc *p_FmHc = (t_FmHc*)h_FmHc;
+    return p_FmHc->h_HcPortDev;
+}
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/Makefile b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/Makefile
index 449cfea..9f19a451 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/Makefile
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/Makefile
@@ -1,14 +1,14 @@
 #
 # Makefile for the Freescale Ethernet controllers
 #
-EXTRA_CFLAGS           += -DVERSION=\"\"
+ccflags-y           += -DVERSION=\"\"
 #
 #Include netcomm SW specific definitions
 include $(srctree)/drivers/net/ethernet/freescale/fman/ncsw_config.mk
 
 NCSW_FM_INC = $(srctree)/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc
 
-EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+ccflags-y += -I$(NCSW_FM_INC)
 
 obj-y		+= fsl-ncsw-MAC.o
 
@@ -16,9 +16,13 @@ fsl-ncsw-MAC-objs	:=  dtsec.o dtsec_mii_acc.o fm_mac.o tgec.o tgec_mii_acc.o \
 			    fman_dtsec.o fman_dtsec_mii_acc.o fman_memac.o \
 			    fman_tgec.o fman_crc32.o
 
-ifeq ($(CONFIG_FMAN_T4240),y)
+ifeq ($(CONFIG_FMAN_V3H),y)
 fsl-ncsw-MAC-objs	+=  memac.o memac_mii_acc.o fman_memac_mii_acc.o
 endif
+ifeq ($(CONFIG_FMAN_V3L),y)
+fsl-ncsw-MAC-objs       +=  memac.o memac_mii_acc.o fman_memac_mii_acc.o
+endif
 ifeq ($(CONFIG_FMAN_LS1043),y)
 fsl-ncsw-MAC-objs       +=  memac.o memac_mii_acc.o fman_memac_mii_acc.o
 endif
+
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c
index e8cc70a..5ae65f8 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c
@@ -559,17 +559,13 @@ static t_Error DtsecConfigException(t_Handle h_Dtsec, e_FmMacExceptions exceptio
     {
         if (!p_Dtsec->ptpTsuEnabled)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exception valid for 1588 only"));
-        switch (exception){
-        case (e_FM_MAC_EX_1G_1588_TS_RX_ERR):
-            if (enable)
-                p_Dtsec->enTsuErrExeption = TRUE;
-            else
-                p_Dtsec->enTsuErrExeption = FALSE;
-            break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
-        }
+
+        if (enable)
+            p_Dtsec->enTsuErrExeption = TRUE;
+        else
+            p_Dtsec->enTsuErrExeption = FALSE;
     }
+
     return E_OK;
 }
 
@@ -1090,7 +1086,7 @@ static t_Error DtsecSetWakeOnLan(t_Handle h_Dtsec, bool en)
 static t_Error DtsecAdjustLink(t_Handle h_Dtsec, e_EnetSpeed speed, bool fullDuplex)
 {
     t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    t_Error             err;
+    int                 err;
     enum enet_interface enet_interface;
     enum enet_speed     enet_speed;
 
@@ -1102,12 +1098,12 @@ static t_Error DtsecAdjustLink(t_Handle h_Dtsec, e_EnetSpeed speed, bool fullDup
     enet_speed = (enum enet_speed) ENET_SPEED_FROM_MODE(p_Dtsec->enetMode);
     p_Dtsec->halfDuplex = !fullDuplex;
 
-    err = (t_Error)fman_dtsec_adjust_link(p_Dtsec->p_MemMap, enet_interface, enet_speed, fullDuplex);
+    err = fman_dtsec_adjust_link(p_Dtsec->p_MemMap, enet_interface, enet_speed, fullDuplex);
 
-    if (err == E_CONFLICT)
+    if (err == -EINVAL)
         RETURN_ERROR(MAJOR, E_CONFLICT, ("Ethernet interface does not support Half Duplex mode"));
 
-    return err;
+    return (t_Error)err;
 }
 
 /* .............................................................................. */
@@ -1190,71 +1186,21 @@ static t_Error DtsecSetException(t_Handle h_Dtsec, e_FmMacExceptions exception,
     {
         if (!p_Dtsec->ptpTsuEnabled)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exception valid for 1588 only"));
-        switch (exception)
+
+        if (enable)
         {
-        case (e_FM_MAC_EX_1G_1588_TS_RX_ERR):
-            if (enable)
-            {
-                p_Dtsec->enTsuErrExeption = TRUE;
-                fman_dtsec_enable_tmr_interrupt(p_Dtsec->p_MemMap);
-            } else {
-                p_Dtsec->enTsuErrExeption = FALSE;
-                fman_dtsec_disable_tmr_interrupt(p_Dtsec->p_MemMap);
-            }
-            break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+            p_Dtsec->enTsuErrExeption = TRUE;
+            fman_dtsec_enable_tmr_interrupt(p_Dtsec->p_MemMap);
         }
-    }
-
-    return E_OK;
-}
-
-/* ........................................................................... */
-
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-static t_Error DtsecDumpRegs(t_Handle h_Dtsec)
-{
-    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    int i = 0;
-
-    DECLARE_DUMP;
-
-    if (p_Dtsec->p_MemMap)
-    {
-        DUMP_TITLE(p_Dtsec->p_MemMap, ("dTSEC %d: ", p_Dtsec->macId));
-        DUMP_VAR(p_Dtsec->p_MemMap, tsec_id);
-        DUMP_VAR(p_Dtsec->p_MemMap, tsec_id2);
-        DUMP_VAR(p_Dtsec->p_MemMap, ievent);
-        DUMP_VAR(p_Dtsec->p_MemMap, imask);
-        DUMP_VAR(p_Dtsec->p_MemMap, ecntrl);
-        DUMP_VAR(p_Dtsec->p_MemMap, ptv);
-        DUMP_VAR(p_Dtsec->p_MemMap, tmr_ctrl);
-        DUMP_VAR(p_Dtsec->p_MemMap, tmr_pevent);
-        DUMP_VAR(p_Dtsec->p_MemMap, tmr_pemask);
-        DUMP_VAR(p_Dtsec->p_MemMap, tctrl);
-        DUMP_VAR(p_Dtsec->p_MemMap, rctrl);
-        DUMP_VAR(p_Dtsec->p_MemMap, maccfg1);
-        DUMP_VAR(p_Dtsec->p_MemMap, maccfg2);
-        DUMP_VAR(p_Dtsec->p_MemMap, ipgifg);
-        DUMP_VAR(p_Dtsec->p_MemMap, hafdup);
-        DUMP_VAR(p_Dtsec->p_MemMap, maxfrm);
-
-        DUMP_VAR(p_Dtsec->p_MemMap, macstnaddr1);
-        DUMP_VAR(p_Dtsec->p_MemMap, macstnaddr2);
-
-        DUMP_SUBSTRUCT_ARRAY(i, 8)
+        else
         {
-            DUMP_VAR(p_Dtsec->p_MemMap, macaddr[i].exact_match1);
-            DUMP_VAR(p_Dtsec->p_MemMap, macaddr[i].exact_match2);
+            p_Dtsec->enTsuErrExeption = FALSE;
+            fman_dtsec_disable_tmr_interrupt(p_Dtsec->p_MemMap);
         }
-        DUMP_VAR(p_Dtsec->p_MemMap, car1);
-        DUMP_VAR(p_Dtsec->p_MemMap, car2);
     }
 
     return E_OK;
 }
-#endif /* (defined(DEBUG_ERRORS) && ... */
 
 
 /*****************************************************************************/
@@ -1330,6 +1276,8 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     maxFrmLn = fman_dtsec_get_max_frame_len(p_Dtsec->p_MemMap);
     err = FmSetMacMaxFrame(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MAC_1G,
             p_Dtsec->fmMacControllerDriver.macId, maxFrmLn);
+    if (err)
+        RETURN_ERROR(MINOR,err, NO_MSG);
 
     p_Dtsec->p_MulticastAddrHash = AllocHashTable(EXTENDED_HASH_TABLE_SIZE);
     if (!p_Dtsec->p_MulticastAddrHash) {
@@ -1386,14 +1334,17 @@ static t_Error DtsecFree(t_Handle h_Dtsec)
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
 
-    FreeInitResources(p_Dtsec);
-
     if (p_Dtsec->p_DtsecDriverParam)
     {
+        /* Called after config */
         XX_Free(p_Dtsec->p_DtsecDriverParam);
         p_Dtsec->p_DtsecDriverParam = NULL;
     }
-    XX_Free (h_Dtsec);
+    else
+        /* Called after init */
+        FreeInitResources(p_Dtsec);
+
+    XX_Free(p_Dtsec);
 
     return E_OK;
 }
@@ -1450,9 +1401,6 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
     p_FmMacControllerDriver->f_FM_MAC_MII_WritePhyReg           = DTSEC_MII_WritePhyReg;
     p_FmMacControllerDriver->f_FM_MAC_MII_ReadPhyReg            = DTSEC_MII_ReadPhyReg;
 
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-    p_FmMacControllerDriver->f_FM_MAC_DumpRegs                  = DtsecDumpRegs;
-#endif /* (defined(DEBUG_ERRORS) && ... */
 }
 
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec_mii_acc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec_mii_acc.c
index 69b8b43..87da25f 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec_mii_acc.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec_mii_acc.c
@@ -53,7 +53,7 @@ t_Error DTSEC_MII_WritePhyReg(t_Handle    h_Dtsec,
     t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
     struct dtsec_mii_reg *miiregs;
     uint16_t              dtsec_freq;
-    t_Error               err;
+    t_Error                   err;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MiiMemMap, E_INVALID_HANDLE);
@@ -75,7 +75,7 @@ t_Error DTSEC_MII_ReadPhyReg(t_Handle h_Dtsec,
     t_Dtsec               *p_Dtsec = (t_Dtsec *)h_Dtsec;
     struct dtsec_mii_reg  *miiregs;
     uint16_t               dtsec_freq;
-    t_Error                err;
+    t_Error                    err;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MiiMemMap, E_INVALID_HANDLE);
@@ -83,14 +83,15 @@ t_Error DTSEC_MII_ReadPhyReg(t_Handle h_Dtsec,
     dtsec_freq = (uint16_t)(p_Dtsec->fmMacControllerDriver.clkFreq >> 1);
     miiregs = p_Dtsec->p_MiiMemMap;
 
-    err = (t_Error)fman_dtsec_mii_read_reg(miiregs, phyAddr, reg, p_Data, dtsec_freq);
+    err = fman_dtsec_mii_read_reg(miiregs, phyAddr, reg, p_Data, dtsec_freq);
 
     if (*p_Data == 0xffff)
         RETURN_ERROR(MINOR, E_NO_DEVICE,
                      ("Read wrong data (0xffff): phyAddr 0x%x, reg 0x%x",
                       phyAddr, reg));
     if (err)
-        RETURN_ERROR(MINOR, err, NO_MSG);
+        RETURN_ERROR(MINOR, (t_Error)err, NO_MSG);
 
-    return err;
+    return E_OK;
 }
+
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.c
index e992f1a..a76ca6a 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.c
@@ -51,9 +51,17 @@
 t_Handle FM_MAC_Config (t_FmMacParams *p_FmMacParam)
 {
     t_FmMacControllerDriver *p_FmMacControllerDriver;
+    uint16_t                fmClkFreq;
 
     SANITY_CHECK_RETURN_VALUE(p_FmMacParam, E_INVALID_HANDLE, NULL);
 
+    fmClkFreq = FmGetClockFreq(p_FmMacParam->h_Fm);
+    if (fmClkFreq == 0)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Can't get clock for MAC!"));
+        return NULL;
+    }
+
 #if (DPAA_VERSION == 10)
     if (ENET_SPEED_FROM_MODE(p_FmMacParam->enetMode) < e_ENET_SPEED_10000)
         p_FmMacControllerDriver = (t_FmMacControllerDriver *)DTSEC_Config(p_FmMacParam);
@@ -75,11 +83,7 @@ t_Handle FM_MAC_Config (t_FmMacParams *p_FmMacParam)
     p_FmMacControllerDriver->macId          = p_FmMacParam->macId;
     p_FmMacControllerDriver->resetOnInit    = DEFAULT_resetOnInit;
 
-    if ((p_FmMacControllerDriver->clkFreq = FmGetClockFreq(p_FmMacControllerDriver->h_Fm)) == 0)
-    {
-        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Can't get clock for MAC!"));
-        return NULL;
-    }
+    p_FmMacControllerDriver->clkFreq        = fmClkFreq;
 
     return (t_Handle)p_FmMacControllerDriver;
 }
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.h
index 05ccd7e..0d7b8d2 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.h
@@ -198,7 +198,7 @@ static __inline__ t_EthHash * AllocHashTable(uint16_t size)
     t_EthHash *p_Hash;
 
     /* Allocate address hash table */
-    p_Hash = (t_EthHash *)XX_Malloc(size*sizeof(t_EthHash *));
+    p_Hash = (t_EthHash *)XX_Malloc(sizeof(t_EthHash));
     if (!p_Hash)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Address hash table"));
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec.c
index 1019b68..5b09286 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec.c
@@ -261,7 +261,6 @@ UNUSED(fm_rev_maj);UNUSED(fm_rev_min);
 	/***************MACCFG2***********************/
 
 	/***************IPGIFG************************/
-	tmp = 0;
 	tmp = (((cfg->non_back_to_back_ipg1 <<
 		IPGIFG_NON_BACK_TO_BACK_IPG_1_SHIFT)
 		& IPGIFG_NON_BACK_TO_BACK_IPG_1)
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec_mii_acc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec_mii_acc.c
index 21be6f0..8819f8f 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec_mii_acc.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec_mii_acc.c
@@ -160,3 +160,4 @@ int fman_dtsec_mii_read_reg(struct dtsec_mii_reg *regs, uint8_t  addr,
 
 	return 0;
 }
+
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac.c
index a79c208..00995a1 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac.c
@@ -156,6 +156,7 @@ int fman_memac_init(struct memac_regs *regs,
         struct memac_cfg *cfg,
         enum enet_interface enet_interface,
         enum enet_speed enet_speed,
+	bool slow_10g_if,
         uint32_t exceptions)
 {
     uint32_t    tmp;
@@ -216,8 +217,13 @@ int fman_memac_init(struct memac_regs *regs,
 	tmp = 0;
 	if (enet_interface == E_ENET_IF_XGMII ||
 		enet_interface == E_ENET_IF_XFI) {
-		tmp |= (TX_FIFO_SECTIONS_TX_AVAIL_10G |
+		if(slow_10g_if) {
+			tmp |= (TX_FIFO_SECTIONS_TX_AVAIL_SLOW_10G |
 				TX_FIFO_SECTIONS_TX_EMPTY_DEFAULT_10G);
+		} else {
+			tmp |= (TX_FIFO_SECTIONS_TX_AVAIL_10G |
+				TX_FIFO_SECTIONS_TX_EMPTY_DEFAULT_10G);
+		}
 	} else {
 		tmp |= (TX_FIFO_SECTIONS_TX_AVAIL_1G |
 				TX_FIFO_SECTIONS_TX_EMPTY_DEFAULT_1G);
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac_mii_acc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac_mii_acc.c
index 61be763..ccda11e 100755
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac_mii_acc.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac_mii_acc.c
@@ -210,3 +210,4 @@ int fman_memac_mii_read_phy_reg(struct memac_mii_access_mem_map *mii_regs,
 }
 
 /* ......................................................................... */
+
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c
index 4ea5d85..b5aacc9 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c
@@ -89,12 +89,13 @@ static void SetupSgmiiInternalPhy(t_Memac *p_Memac, uint8_t phyAddr)
         speed=10000 is provided for SGMII ports. Temporary modify enet mode
         to 1G one, so MII functions can work correctly. */
     enetMode = p_Memac->enetMode;
-    p_Memac->enetMode = MAKE_ENET_MODE(ENET_INTERFACE_FROM_MODE(p_Memac->enetMode), e_ENET_SPEED_1000);
 
     /* SGMII mode + AN enable */
     tmpReg16 = PHY_SGMII_IF_MODE_AN | PHY_SGMII_IF_MODE_SGMII;
     if ((p_Memac->enetMode) == e_ENET_MODE_SGMII_2500)
-        tmpReg16 = PHY_SGMII_CR_PHY_RESET | PHY_SGMII_IF_MODE_SGMII;
+        tmpReg16 = PHY_SGMII_CR_PHY_RESET | PHY_SGMII_IF_SPEED_GIGABIT | PHY_SGMII_IF_MODE_SGMII;
+
+    p_Memac->enetMode = MAKE_ENET_MODE(ENET_INTERFACE_FROM_MODE(p_Memac->enetMode), e_ENET_SPEED_1000);
     MEMAC_MII_WritePhyReg(p_Memac, phyAddr, 0x14, tmpReg16);
 
     /* Device ability according to SGMII specification */
@@ -695,6 +696,21 @@ static t_Error MemacDelExactMatchMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthA
 
 /* ......................................................................... */
 
+static t_Error MemacGetId(t_Handle h_Memac, uint32_t *macId)
+{
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
+
+    *macId = p_Memac->macId;
+
+    return E_OK;
+}
+
+/* ......................................................................... */
+
+
 static t_Error MemacAddHashMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
 {
     t_Memac             *p_Memac = (t_Memac *)h_Memac;
@@ -796,70 +812,13 @@ static uint16_t MemacGetMaxFrameLength(t_Handle h_Memac)
     return fman_memac_get_max_frame_len(p_Memac->p_MemMap);
 }
 
-/* ......................................................................... */
-
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-static t_Error MemacDumpRegs(t_Handle h_Memac)
-{
-    t_Memac     *p_Memac = (t_Memac *)h_Memac;
-    int         i = 0;
-
-    DECLARE_DUMP;
-
-    if (p_Memac->p_MemMap)
-    {
-        DUMP_TITLE(p_Memac->p_MemMap, ("mEMAC %d: ", p_Memac->macId));
-        DUMP_VAR(p_Memac->p_MemMap, command_config);
-        DUMP_VAR(p_Memac->p_MemMap, mac_addr0.mac_addr_l);
-        DUMP_VAR(p_Memac->p_MemMap, mac_addr0.mac_addr_u);
-        DUMP_VAR(p_Memac->p_MemMap, maxfrm);
-        DUMP_VAR(p_Memac->p_MemMap, hashtable_ctrl);
-        DUMP_VAR(p_Memac->p_MemMap, ievent);
-        DUMP_VAR(p_Memac->p_MemMap, tx_ipg_length);
-        DUMP_VAR(p_Memac->p_MemMap, imask);
-
-        DUMP_SUBSTRUCT_ARRAY(i, 4)
-        {
-            DUMP_VAR(p_Memac->p_MemMap, pause_quanta[i]);
-        }
-        DUMP_SUBSTRUCT_ARRAY(i, 4)
-        {
-            DUMP_VAR(p_Memac->p_MemMap, pause_thresh[i]);
-        }
-
-        DUMP_VAR(p_Memac->p_MemMap, rx_pause_status);
-
-        DUMP_SUBSTRUCT_ARRAY(i, MEMAC_NUM_OF_PADDRS)
-        {
-            DUMP_VAR(p_Memac->p_MemMap, mac_addr[i].mac_addr_l);
-            DUMP_VAR(p_Memac->p_MemMap, mac_addr[i].mac_addr_u);
-        }
-
-        DUMP_VAR(p_Memac->p_MemMap, lpwake_timer);
-        DUMP_VAR(p_Memac->p_MemMap, sleep_timer);
-        DUMP_VAR(p_Memac->p_MemMap, statn_config);
-        DUMP_VAR(p_Memac->p_MemMap, if_mode);
-        DUMP_VAR(p_Memac->p_MemMap, if_status);
-        DUMP_VAR(p_Memac->p_MemMap, hg_config);
-        DUMP_VAR(p_Memac->p_MemMap, hg_pause_quanta);
-        DUMP_VAR(p_Memac->p_MemMap, hg_pause_thresh);
-        DUMP_VAR(p_Memac->p_MemMap, hgrx_pause_status);
-        DUMP_VAR(p_Memac->p_MemMap, hg_fifos_status);
-        DUMP_VAR(p_Memac->p_MemMap, rhm);
-        DUMP_VAR(p_Memac->p_MemMap, thm);
-    }
-
-    return E_OK;
-}
-#endif /* (defined(DEBUG_ERRORS) && ... */
-
 
 /*****************************************************************************/
 /*                      mEMAC Init & Free API                                   */
 /*****************************************************************************/
 
 /* ......................................................................... */
-
+void *g_MemacRegs;
 static t_Error MemacInit(t_Handle h_Memac)
 {
     t_Memac                 *p_Memac = (t_Memac *)h_Memac;
@@ -870,13 +829,18 @@ static t_Error MemacInit(t_Handle h_Memac)
     t_EnetAddr              ethAddr;
     e_FmMacType             portType;
     t_Error                 err;
+    bool                    slow_10g_if = FALSE;
+    if (p_Memac->macId == 3) /* This is a quick WA */
+		g_MemacRegs = p_Memac->p_MemMap;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemacDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_Memac->fmMacControllerDriver.h_Fm, E_INVALID_HANDLE);
 
-    /* not needed! */
-    /*FM_GetRevision(p_Memac->fmMacControllerDriver.h_Fm, &p_Memac->fmMacControllerDriver.fmRevInfo);*/
+    FM_GetRevision(p_Memac->fmMacControllerDriver.h_Fm, &p_Memac->fmMacControllerDriver.fmRevInfo);
+    if (p_Memac->fmMacControllerDriver.fmRevInfo.majorRev == 6 &&
+        p_Memac->fmMacControllerDriver.fmRevInfo.minorRev == 4)
+        slow_10g_if = TRUE;
 
     CHECK_INIT_PARAMETERS(p_Memac, CheckInitParameters);
 
@@ -900,19 +864,20 @@ static t_Error MemacInit(t_Handle h_Memac)
                p_Memac->p_MemacDriverParam,
                enet_interface,
                enet_speed,
+               slow_10g_if,
                p_Memac->exceptions);
 
 #ifdef FM_RX_FIFO_CORRUPT_ERRATA_10GMAC_A006320
     {
-	uint32_t tmpReg = 0;
+    	uint32_t tmpReg = 0;
 
-	FM_GetRevision(p_Memac->fmMacControllerDriver.h_Fm, &p_Memac->fmMacControllerDriver.fmRevInfo);
+    	FM_GetRevision(p_Memac->fmMacControllerDriver.h_Fm, &p_Memac->fmMacControllerDriver.fmRevInfo);
         /* check the FMAN version - the bug exists only in rev1 */
         if ((p_Memac->fmMacControllerDriver.fmRevInfo.majorRev == 6) &&
-		(p_Memac->fmMacControllerDriver.fmRevInfo.minorRev == 0))
+        	(p_Memac->fmMacControllerDriver.fmRevInfo.minorRev == 0))
         {
-		/* MAC strips CRC from received frames - this workaround should
-		   decrease the likelihood of bug appearance
+        	/* MAC strips CRC from received frames - this workaround should
+        	   decrease the likelihood of bug appearance
             */
 			tmpReg = GET_UINT32(p_Memac->p_MemMap->command_config);
 			tmpReg &= ~CMD_CFG_CRC_FWD;
@@ -997,13 +962,16 @@ static t_Error MemacFree(t_Handle h_Memac)
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
 
-    FreeInitResources(p_Memac);
-
     if (p_Memac->p_MemacDriverParam)
     {
+        /* Called after config */
         XX_Free(p_Memac->p_MemacDriverParam);
         p_Memac->p_MemacDriverParam = NULL;
     }
+    else
+        /* Called after init */
+        FreeInitResources(p_Memac);
+
     XX_Free(p_Memac);
 
     return E_OK;
@@ -1055,16 +1023,12 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
     p_FmMacControllerDriver->f_FM_MAC_RemoveHashMacAddr         = MemacDelHashMacAddress;
     p_FmMacControllerDriver->f_FM_MAC_AddExactMatchMacAddr      = MemacAddExactMatchMacAddress;
     p_FmMacControllerDriver->f_FM_MAC_RemovelExactMatchMacAddr  = MemacDelExactMatchMacAddress;
-    p_FmMacControllerDriver->f_FM_MAC_GetId                     = NULL;
+    p_FmMacControllerDriver->f_FM_MAC_GetId                     = MemacGetId;
     p_FmMacControllerDriver->f_FM_MAC_GetVersion                = NULL;
     p_FmMacControllerDriver->f_FM_MAC_GetMaxFrameLength         = MemacGetMaxFrameLength;
 
     p_FmMacControllerDriver->f_FM_MAC_MII_WritePhyReg           = MEMAC_MII_WritePhyReg;
     p_FmMacControllerDriver->f_FM_MAC_MII_ReadPhyReg            = MEMAC_MII_ReadPhyReg;
-
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-    p_FmMacControllerDriver->f_FM_MAC_DumpRegs                  = MemacDumpRegs;
-#endif /* (defined(DEBUG_ERRORS) && ... */
 }
 
 
@@ -1094,11 +1058,11 @@ t_Handle MEMAC_Config(t_FmMacParams *p_FmMacParam)
     InitFmMacControllerDriver(&p_Memac->fmMacControllerDriver);
 
     /* Allocate memory for the mEMAC driver parameters data structure */
-    p_MemacDriverParam = (struct memac_cfg *) XX_Malloc(sizeof(struct memac_cfg));
+    p_MemacDriverParam = (struct memac_cfg *)XX_Malloc(sizeof(struct memac_cfg));
     if (!p_MemacDriverParam)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("mEMAC driver parameters"));
-        MemacFree(p_Memac);
+        XX_Free(p_Memac);
         return NULL;
     }
     memset(p_MemacDriverParam, 0, sizeof(struct memac_cfg));
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.h
index 4bb09d6..2fd89da 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.h
@@ -95,6 +95,7 @@ typedef struct
 #define PHY_SGMII_CR_DEF_VAL            0x1140
 #define PHY_SGMII_DEV_ABILITY_SGMII     0x4001
 #define PHY_SGMII_DEV_ABILITY_1000X     0x01A0
+#define PHY_SGMII_IF_SPEED_GIGABIT	0x0008
 #define PHY_SGMII_IF_MODE_AN            0x0002
 #define PHY_SGMII_IF_MODE_SGMII         0x0001
 #define PHY_SGMII_IF_MODE_1000X         0x0000
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac_mii_acc.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac_mii_acc.h
index a8824ef..325ec08 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac_mii_acc.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac_mii_acc.h
@@ -57,13 +57,13 @@
 /*----------------------------------------------------*/
 /* MII Configuration Control Memory Map Registers     */
 /*----------------------------------------------------*/
-typedef _Packed struct t_MemacMiiAccessMemMap
+typedef struct t_MemacMiiAccessMemMap
 {
     volatile uint32_t   mdio_cfg;       /* 0x030  */
     volatile uint32_t   mdio_ctrl;      /* 0x034  */
     volatile uint32_t   mdio_data;      /* 0x038  */
     volatile uint32_t   mdio_addr;      /* 0x03c  */
-} _PackedType t_MemacMiiAccessMemMap ;
+} t_MemacMiiAccessMemMap ;
 
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/tgec.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/tgec.c
index 91f4568..bf12c5d 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/tgec.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/tgec.c
@@ -741,50 +741,6 @@ static t_Error TgecTxEccWorkaround(t_Tgec *p_Tgec)
 }
 #endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
 
-/* ......................................................................... */
-
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-static t_Error TgecDumpRegs(t_Handle h_Tgec)
-{
-    t_Tgec    *p_Tgec = (t_Tgec *)h_Tgec;
-
-    DECLARE_DUMP;
-
-    if (p_Tgec->p_MemMap)
-    {
-        DUMP_TITLE(p_Tgec->p_MemMap, ("10G MAC %d: ", p_Tgec->macId));
-        DUMP_VAR(p_Tgec->p_MemMap, tgec_id);
-        DUMP_VAR(p_Tgec->p_MemMap, command_config);
-        DUMP_VAR(p_Tgec->p_MemMap, mac_addr_0);
-        DUMP_VAR(p_Tgec->p_MemMap, mac_addr_1);
-        DUMP_VAR(p_Tgec->p_MemMap, maxfrm);
-        DUMP_VAR(p_Tgec->p_MemMap, pause_quant);
-        DUMP_VAR(p_Tgec->p_MemMap, rx_fifo_sections);
-        DUMP_VAR(p_Tgec->p_MemMap, tx_fifo_sections);
-        DUMP_VAR(p_Tgec->p_MemMap, rx_fifo_almost_f_e);
-        DUMP_VAR(p_Tgec->p_MemMap, tx_fifo_almost_f_e);
-        DUMP_VAR(p_Tgec->p_MemMap, hashtable_ctrl);
-        DUMP_VAR(p_Tgec->p_MemMap, mdio_cfg_status);
-        DUMP_VAR(p_Tgec->p_MemMap, mdio_command);
-        DUMP_VAR(p_Tgec->p_MemMap, mdio_data);
-        DUMP_VAR(p_Tgec->p_MemMap, mdio_regaddr);
-        DUMP_VAR(p_Tgec->p_MemMap, status);
-        DUMP_VAR(p_Tgec->p_MemMap, tx_ipg_len);
-        DUMP_VAR(p_Tgec->p_MemMap, mac_addr_2);
-        DUMP_VAR(p_Tgec->p_MemMap, mac_addr_3);
-        DUMP_VAR(p_Tgec->p_MemMap, rx_fifo_ptr_rd);
-        DUMP_VAR(p_Tgec->p_MemMap, rx_fifo_ptr_wr);
-        DUMP_VAR(p_Tgec->p_MemMap, tx_fifo_ptr_rd);
-        DUMP_VAR(p_Tgec->p_MemMap, tx_fifo_ptr_wr);
-        DUMP_VAR(p_Tgec->p_MemMap, imask);
-        DUMP_VAR(p_Tgec->p_MemMap, ievent);
-    }
-
-    return E_OK;
-}
-#endif /* (defined(DEBUG_ERRORS) && ... */
-
-
 /*****************************************************************************/
 /*                      FM Init & Free API                                   */
 /*****************************************************************************/
@@ -839,7 +795,12 @@ static t_Error TgecInit(t_Handle h_Tgec)
                            e_FM_MAC_10G,
                            p_Tgec->fmMacControllerDriver.macId,
                            p_TgecDriverParam->max_frame_length);
-    /* we consider having no IPC a non crasher... */
+    if (err != E_OK)
+    {
+        FreeInitResources(p_Tgec);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+/* we consider having no IPC a non crasher... */
 
 #ifdef FM_TX_FIFO_CORRUPTION_ERRATA_10GMAC_A007
     if (p_Tgec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
@@ -886,14 +847,17 @@ static t_Error TgecFree(t_Handle h_Tgec)
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
 
-    FreeInitResources(p_Tgec);
-
     if (p_Tgec->p_TgecDriverParam)
     {
+        /* Called after config */
         XX_Free(p_Tgec->p_TgecDriverParam);
         p_Tgec->p_TgecDriverParam = NULL;
     }
-    XX_Free (p_Tgec);
+    else
+        /* Called after init */
+        FreeInitResources(p_Tgec);
+
+    XX_Free(p_Tgec);
 
     return E_OK;
 }
@@ -952,10 +916,6 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
 
     p_FmMacControllerDriver->f_FM_MAC_MII_WritePhyReg           = TGEC_MII_WritePhyReg;
     p_FmMacControllerDriver->f_FM_MAC_MII_ReadPhyReg            = TGEC_MII_ReadPhyReg;
-
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-    p_FmMacControllerDriver->f_FM_MAC_DumpRegs                  = TgecDumpRegs;
-#endif /* (defined(DEBUG_ERRORS) && ... */
 }
 
 
@@ -989,7 +949,7 @@ t_Handle TGEC_Config(t_FmMacParams *p_FmMacParam)
     if (!p_TgecDriverParam)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("10G MAC driver parameters"));
-        TgecFree(p_Tgec);
+        XX_Free(p_Tgec);
         return NULL;
     }
     memset(p_TgecDriverParam, 0, sizeof(struct tgec_cfg));
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/Makefile b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/Makefile
new file mode 100644
index 0000000..073351e
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/Makefile
@@ -0,0 +1,15 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+ccflags-y           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/ethernet/freescale/fman/ncsw_config.mk
+
+NCSW_FM_INC = $(srctree)/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc
+
+ccflags-y += -I$(NCSW_FM_INC)
+
+obj-y		+= fsl-ncsw-macsec.o
+
+fsl-ncsw-macsec-objs	:= fm_macsec.o fm_macsec_guest.o fm_macsec_master.o fm_macsec_secy.o
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec.c
new file mode 100644
index 0000000..0a1b31f
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec.c
@@ -0,0 +1,237 @@
+/*
+ * Copyright 2008-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/******************************************************************************
+
+ @File          fm_macsec.c
+
+ @Description   FM MACSEC driver routines implementation.
+*//***************************************************************************/
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "xx_ext.h"
+#include "string_ext.h"
+#include "sprint_ext.h"
+#include "debug_ext.h"
+
+#include "fm_macsec.h"
+
+
+/****************************************/
+/*       API Init unit functions        */
+/****************************************/
+t_Handle FM_MACSEC_Config(t_FmMacsecParams *p_FmMacsecParam)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmMacsecParam, E_INVALID_HANDLE, NULL);
+
+    if (p_FmMacsecParam->guestMode)
+        p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)FM_MACSEC_GUEST_Config(p_FmMacsecParam);
+    else
+        p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)FM_MACSEC_MASTER_Config(p_FmMacsecParam);
+
+    if (!p_FmMacsecControllerDriver)
+        return NULL;
+
+    return (t_Handle)p_FmMacsecControllerDriver;
+}
+
+t_Error FM_MACSEC_Init(t_Handle h_FmMacsec)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_Init)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_Init(h_FmMacsec);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_Free(t_Handle h_FmMacsec)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_Free)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_Free(h_FmMacsec);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_ConfigUnknownSciFrameTreatment(t_Handle h_FmMacsec, e_FmMacsecUnknownSciFrameTreatment treatMode)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigUnknownSciFrameTreatment)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigUnknownSciFrameTreatment(h_FmMacsec, treatMode);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_ConfigInvalidTagsFrameTreatment(t_Handle h_FmMacsec, bool deliverUncontrolled)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigInvalidTagsFrameTreatment)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigInvalidTagsFrameTreatment(h_FmMacsec, deliverUncontrolled);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_ConfigEncryptWithNoChangedTextFrameTreatment(t_Handle h_FmMacsec, bool discardUncontrolled)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigEncryptWithNoChangedTextFrameTreatment)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigEncryptWithNoChangedTextFrameTreatment(h_FmMacsec, discardUncontrolled);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_ConfigUntagFrameTreatment(t_Handle h_FmMacsec, e_FmMacsecUntagFrameTreatment treatMode)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigUntagFrameTreatment)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigUntagFrameTreatment(h_FmMacsec, treatMode);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_ConfigPnExhaustionThreshold(t_Handle h_FmMacsec, uint32_t pnExhThr)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigPnExhaustionThreshold)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigPnExhaustionThreshold(h_FmMacsec, pnExhThr);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_ConfigKeysUnreadable(t_Handle h_FmMacsec)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigKeysUnreadable)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigKeysUnreadable(h_FmMacsec);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_ConfigSectagWithoutSCI(t_Handle h_FmMacsec)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigSectagWithoutSCI)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigSectagWithoutSCI(h_FmMacsec);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_ConfigException(t_Handle h_FmMacsec, e_FmMacsecExceptions exception, bool enable)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigException)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigException(h_FmMacsec, exception, enable);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_GetRevision(t_Handle h_FmMacsec, uint32_t *p_MacsecRevision)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_GetRevision)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_GetRevision(h_FmMacsec, p_MacsecRevision);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+
+t_Error FM_MACSEC_Enable(t_Handle h_FmMacsec)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_Enable)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_Enable(h_FmMacsec);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_Disable(t_Handle h_FmMacsec)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_Disable)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_Disable(h_FmMacsec);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_SetException(t_Handle h_FmMacsec, e_FmMacsecExceptions exception, bool enable)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_SetException)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_SetException(h_FmMacsec, exception, enable);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec.h
new file mode 100644
index 0000000..fbe5187
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec.h
@@ -0,0 +1,203 @@
+/*
+ * Copyright 2008-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_macsec.h
+
+ @Description   FM MACSEC internal structures and definitions.
+*//***************************************************************************/
+#ifndef __FM_MACSEC_H
+#define __FM_MACSEC_H
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "fm_macsec_ext.h"
+
+#include "fm_common.h"
+
+
+#define __ERR_MODULE__  MODULE_FM_MACSEC
+
+
+typedef struct
+{
+    t_Error (*f_FM_MACSEC_Init) (t_Handle h_FmMacsec);
+    t_Error (*f_FM_MACSEC_Free) (t_Handle h_FmMacsec);
+
+    t_Error (*f_FM_MACSEC_ConfigUnknownSciFrameTreatment) (t_Handle h_FmMacsec, e_FmMacsecUnknownSciFrameTreatment treatMode);
+    t_Error (*f_FM_MACSEC_ConfigInvalidTagsFrameTreatment) (t_Handle h_FmMacsec, bool deliverUncontrolled);
+    t_Error (*f_FM_MACSEC_ConfigEncryptWithNoChangedTextFrameTreatment) (t_Handle h_FmMacsec, bool discardUncontrolled);
+    t_Error (*f_FM_MACSEC_ConfigChangedTextWithNoEncryptFrameTreatment) (t_Handle h_FmMacsec, bool deliverUncontrolled);
+    t_Error (*f_FM_MACSEC_ConfigUntagFrameTreatment) (t_Handle h_FmMacsec, e_FmMacsecUntagFrameTreatment treatMode);
+    t_Error (*f_FM_MACSEC_ConfigOnlyScbIsSetFrameTreatment) (t_Handle h_FmMacsec, bool deliverUncontrolled);
+    t_Error (*f_FM_MACSEC_ConfigPnExhaustionThreshold) (t_Handle h_FmMacsec, uint32_t pnExhThr);
+    t_Error (*f_FM_MACSEC_ConfigKeysUnreadable) (t_Handle h_FmMacsec);
+    t_Error (*f_FM_MACSEC_ConfigSectagWithoutSCI) (t_Handle h_FmMacsec);
+    t_Error (*f_FM_MACSEC_ConfigException) (t_Handle h_FmMacsec, e_FmMacsecExceptions exception, bool enable);
+
+    t_Error (*f_FM_MACSEC_GetRevision) (t_Handle h_FmMacsec, uint32_t *p_MacsecRevision);
+    t_Error (*f_FM_MACSEC_Enable) (t_Handle h_FmMacsec);
+    t_Error (*f_FM_MACSEC_Disable) (t_Handle h_FmMacsec);
+    t_Error (*f_FM_MACSEC_SetException) (t_Handle h_FmMacsec, e_FmMacsecExceptions exception, bool enable);
+
+} t_FmMacsecControllerDriver;
+
+t_Handle  FM_MACSEC_GUEST_Config(t_FmMacsecParams *p_FmMacsecParam);
+t_Handle  FM_MACSEC_MASTER_Config(t_FmMacsecParams *p_FmMacsecParams);
+
+/***********************************************************************/
+/*  MACSEC internal routines                                              */
+/***********************************************************************/
+
+/**************************************************************************//**
+
+ @Group         FM_MACSEC_InterModule_grp FM MACSEC Inter-Module Unit
+
+ @Description   FM MACSEC Inter Module functions -
+                These are not User API routines but routines that may be called
+                from other modules. This will be the case in a single core environment,
+                where instead of using the XX messaging mechanism, the routines may be
+                called from other modules. In a multicore environment, the other modules may
+                be run by other cores and therefore these routines may not be called directly.
+
+ @{
+*//***************************************************************************/
+
+#define MAX_NUM_OF_SA_PER_SC        4
+
+typedef enum
+{
+    e_SC_RX = 0,
+    e_SC_TX
+} e_ScType;
+
+typedef enum
+{
+    e_SC_SA_A = 0,
+    e_SC_SA_B ,
+    e_SC_SA_C ,
+    e_SC_SA_D
+} e_ScSaId;
+
+typedef struct
+{
+    uint32_t                        scId;
+    macsecSCI_t                     sci;
+    bool                            replayProtect;
+    uint32_t                        replayWindow;
+    e_FmMacsecValidFrameBehavior    validateFrames;
+    uint16_t                        confidentialityOffset;
+    e_FmMacsecSecYCipherSuite       cipherSuite;
+} t_RxScParams;
+
+typedef struct
+{
+    uint32_t                        scId;
+    macsecSCI_t                     sci;
+    bool                            protectFrames;
+    e_FmMacsecSciInsertionMode      sciInsertionMode;
+    bool                            confidentialityEnable;
+    uint16_t                        confidentialityOffset;
+    e_FmMacsecSecYCipherSuite       cipherSuite;
+} t_TxScParams;
+
+typedef enum e_FmMacsecGlobalExceptions {
+    e_FM_MACSEC_EX_TX_SC,               /**< Tx Sc 0 frame discarded error. */
+    e_FM_MACSEC_EX_ECC                  /**< MACSEC memory ECC multiple-bit error. */
+} e_FmMacsecGlobalExceptions;
+
+typedef enum e_FmMacsecGlobalEvents {
+    e_FM_MACSEC_EV_TX_SC_NEXT_PN        /**< Tx Sc 0 Next Pn exhaustion threshold reached. */
+} e_FmMacsecGlobalEvents;
+
+/**************************************************************************//**
+ @Description   Enum for inter-module interrupts registration
+*//***************************************************************************/
+typedef enum e_FmMacsecEventModules{
+    e_FM_MACSEC_MOD_SC_TX,
+    e_FM_MACSEC_MOD_DUMMY_LAST
+} e_FmMacsecEventModules;
+
+typedef enum e_FmMacsecInterModuleEvent {
+    e_FM_MACSEC_EV_SC_TX,
+    e_FM_MACSEC_EV_ERR_SC_TX,
+    e_FM_MACSEC_EV_DUMMY_LAST
+} e_FmMacsecInterModuleEvent;
+
+#define NUM_OF_INTER_MODULE_EVENTS (NUM_OF_TX_SC * 2)
+
+#define GET_MACSEC_MODULE_EVENT(mod, id, intrType, event) \
+    switch(mod){                                          \
+        case e_FM_MACSEC_MOD_SC_TX:                       \
+             event = (intrType == e_FM_INTR_TYPE_ERR) ?   \
+                        e_FM_MACSEC_EV_ERR_SC_TX:         \
+                        e_FM_MACSEC_EV_SC_TX;             \
+             event += (uint8_t)(2 * id);break;            \
+            break;                                        \
+        default:event = e_FM_MACSEC_EV_DUMMY_LAST;        \
+        break;}
+
+void FmMacsecRegisterIntr(t_Handle                h_FmMacsec,
+                          e_FmMacsecEventModules  module,
+                          uint8_t                 modId,
+                          e_FmIntrType            intrType,
+                          void (*f_Isr) (t_Handle h_Arg, uint32_t id),
+                          t_Handle                h_Arg);
+
+void FmMacsecUnregisterIntr(t_Handle                h_FmMacsec,
+                            e_FmMacsecEventModules  module,
+                            uint8_t                 modId,
+                            e_FmIntrType            intrType);
+
+t_Error FmMacsecAllocScs(t_Handle h_FmMacsec, e_ScType type, bool isPtp, uint32_t numOfScs, uint32_t *p_ScIds);
+t_Error FmMacsecFreeScs(t_Handle h_FmMacsec, e_ScType type, uint32_t numOfScs, uint32_t *p_ScIds);
+t_Error FmMacsecCreateRxSc(t_Handle h_FmMacsec, t_RxScParams *p_RxScParams);
+t_Error FmMacsecDeleteRxSc(t_Handle h_FmMacsec, uint32_t scId);
+t_Error FmMacsecCreateTxSc(t_Handle h_FmMacsec, t_TxScParams *p_RxScParams);
+t_Error FmMacsecDeleteTxSc(t_Handle h_FmMacsec, uint32_t scId);
+t_Error FmMacsecCreateRxSa(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, macsecAN_t an, uint32_t lowestPn, macsecSAKey_t key);
+t_Error FmMacsecCreateTxSa(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, macsecSAKey_t key);
+t_Error FmMacsecDeleteRxSa(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId);
+t_Error FmMacsecDeleteTxSa(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId);
+t_Error FmMacsecRxSaSetReceive(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, bool enableReceive);
+t_Error FmMacsecRxSaUpdateNextPn(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, uint32_t updtNextPN);
+t_Error FmMacsecRxSaUpdateLowestPn(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, uint32_t updtLowestPN);
+t_Error FmMacsecTxSaSetActive(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, macsecAN_t an);
+t_Error FmMacsecTxSaGetActive(t_Handle h_FmMacsec, uint32_t scId, macsecAN_t *p_An);
+t_Error FmMacsecSetPTP(t_Handle h_FmMacsec, bool enable);
+
+t_Error FmMacsecSetException(t_Handle h_FmMacsec, e_FmMacsecGlobalExceptions exception, uint32_t scId, bool enable);
+t_Error FmMacsecSetEvent(t_Handle h_FmMacsec, e_FmMacsecGlobalEvents event, uint32_t scId, bool enable);
+
+
+
+#endif /* __FM_MACSEC_H */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_guest.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_guest.c
new file mode 100644
index 0000000..31d789d
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_guest.c
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2008-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_macsec.c
+
+ @Description   FM MACSEC driver routines implementation.
+*//***************************************************************************/
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "xx_ext.h"
+#include "string_ext.h"
+#include "sprint_ext.h"
+#include "debug_ext.h"
+#include "fm_macsec.h"
+
+
+/****************************************/
+/*       static functions               */
+/****************************************/
+
+/****************************************/
+/*       API Init unit functions        */
+/****************************************/
+t_Handle FM_MACSEC_GUEST_Config(t_FmMacsecParams *p_FmMacsecParam)
+{
+    UNUSED(p_FmMacsecParam);
+    return NULL;
+}
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_master.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_master.c
new file mode 100644
index 0000000..79260c8
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_master.c
@@ -0,0 +1,1031 @@
+/*
+ * Copyright 2008-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_macsec.c
+
+ @Description   FM MACSEC driver routines implementation.
+*//***************************************************************************/
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "xx_ext.h"
+#include "string_ext.h"
+#include "sprint_ext.h"
+#include "fm_mac_ext.h"
+
+#include "fm_macsec_master.h"
+
+
+extern uint16_t    FM_MAC_GetMaxFrameLength(t_Handle FmMac);
+
+
+/****************************************/
+/*       static functions               */
+/****************************************/
+static t_Error CheckFmMacsecParameters(t_FmMacsec *p_FmMacsec)
+{
+    if (!p_FmMacsec->f_Exception)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exceptions callback not provided"));
+
+    return E_OK;
+}
+
+static void UnimplementedIsr(t_Handle h_Arg, uint32_t id)
+{
+    UNUSED(h_Arg); UNUSED(id);
+
+    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unimplemented Isr!"));
+}
+
+static void MacsecEventIsr(t_Handle h_FmMacsec)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint32_t    events,event,i;
+
+    SANITY_CHECK_RETURN(p_FmMacsec, E_INVALID_HANDLE);
+
+    events = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->evr);
+    events |= GET_UINT32(p_FmMacsec->p_FmMacsecRegs->ever);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->evr,events);
+
+    for (i=0; i<NUM_OF_TX_SC; i++)
+        if (events & FM_MACSEC_EV_TX_SC_NEXT_PN(i))
+        {
+            GET_MACSEC_MODULE_EVENT(e_FM_MACSEC_MOD_SC_TX, i, e_FM_INTR_TYPE_NORMAL, event);
+            p_FmMacsec->intrMng[event].f_Isr(p_FmMacsec->intrMng[event].h_SrcHandle, i);
+        }
+}
+
+static void MacsecErrorIsr(t_Handle h_FmMacsec)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint32_t    errors,error,i;
+
+    SANITY_CHECK_RETURN(p_FmMacsec, E_INVALID_HANDLE);
+
+    errors = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->err);
+    errors |= GET_UINT32(p_FmMacsec->p_FmMacsecRegs->erer);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->err,errors);
+
+    for (i=0; i<NUM_OF_TX_SC; i++)
+        if (errors & FM_MACSEC_EX_TX_SC(i))
+        {
+            GET_MACSEC_MODULE_EVENT(e_FM_MACSEC_MOD_SC_TX, i, e_FM_INTR_TYPE_ERR, error);
+            p_FmMacsec->intrMng[error].f_Isr(p_FmMacsec->intrMng[error].h_SrcHandle, i);
+        }
+
+    if (errors & FM_MACSEC_EX_ECC)
+    {
+        uint8_t     eccType;
+        uint32_t    tmpReg;
+
+        tmpReg = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->meec);
+        ASSERT_COND(tmpReg & MECC_CAP);
+        eccType = (uint8_t)((tmpReg & MECC_CET) >> MECC_CET_SHIFT);
+
+        if (!eccType && (p_FmMacsec->userExceptions & FM_MACSEC_USER_EX_SINGLE_BIT_ECC))
+            p_FmMacsec->f_Exception(p_FmMacsec->h_App,e_FM_MACSEC_EX_SINGLE_BIT_ECC);
+        else if (eccType && (p_FmMacsec->userExceptions & FM_MACSEC_USER_EX_MULTI_BIT_ECC))
+            p_FmMacsec->f_Exception(p_FmMacsec->h_App,e_FM_MACSEC_EX_MULTI_BIT_ECC);
+        else
+            WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->meec,tmpReg);
+    }
+}
+
+static t_Error MacsecInit(t_Handle h_FmMacsec)
+{
+    t_FmMacsec                  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_FmMacsecDriverParam       *p_FmMacsecDriverParam = NULL;
+    uint32_t                    tmpReg,i,macId;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    CHECK_INIT_PARAMETERS(p_FmMacsec, CheckFmMacsecParameters);
+
+    p_FmMacsecDriverParam = p_FmMacsec->p_FmMacsecDriverParam;
+
+    for (i=0;i<e_FM_MACSEC_EV_DUMMY_LAST;i++)
+        p_FmMacsec->intrMng[i].f_Isr = UnimplementedIsr;
+
+    tmpReg = 0;
+    tmpReg |= (p_FmMacsecDriverParam->changedTextWithNoEncryptDeliverUncontrolled << CFG_UECT_SHIFT)|
+              (p_FmMacsecDriverParam->onlyScbIsSetDeliverUncontrolled << CFG_ESCBT_SHIFT)           |
+              (p_FmMacsecDriverParam->unknownSciTreatMode << CFG_USFT_SHIFT)                        |
+              (p_FmMacsecDriverParam->invalidTagsDeliverUncontrolled << CFG_ITT_SHIFT)              |
+              (p_FmMacsecDriverParam->encryptWithNoChangedTextDiscardUncontrolled << CFG_KFT_SHIFT) |
+              (p_FmMacsecDriverParam->untagTreatMode << CFG_UFT_SHIFT)                              |
+              (p_FmMacsecDriverParam->keysUnreadable << CFG_KSS_SHIFT)                              |
+              (p_FmMacsecDriverParam->reservedSc0 << CFG_S0I_SHIFT)                                 |
+              (p_FmMacsecDriverParam->byPassMode << CFG_BYPN_SHIFT);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->cfg, tmpReg);
+
+    tmpReg = FM_MAC_GetMaxFrameLength(p_FmMacsec->h_FmMac);
+    /* At least Ethernet FCS (4 bytes) overhead must be subtracted from MFL.
+     * In addition, the SCI (8 bytes) overhead might be subtracted as well. */
+    tmpReg -= p_FmMacsecDriverParam->mflSubtract;
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->mfl, tmpReg);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->tpnet, p_FmMacsecDriverParam->pnExhThr);
+
+    if (!p_FmMacsec->userExceptions)
+        p_FmMacsec->exceptions &= ~FM_MACSEC_EX_ECC;
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->erer, p_FmMacsec->exceptions);
+
+    p_FmMacsec->numRxScAvailable = NUM_OF_RX_SC;
+    if (p_FmMacsecDriverParam->reservedSc0)
+        p_FmMacsec->numRxScAvailable --;
+    p_FmMacsec->numTxScAvailable = NUM_OF_TX_SC;
+
+    XX_Free(p_FmMacsecDriverParam);
+    p_FmMacsec->p_FmMacsecDriverParam = NULL;
+
+    FM_MAC_GetId(p_FmMacsec->h_FmMac, &macId);
+    FmRegisterIntr(p_FmMacsec->h_Fm,
+                   e_FM_MOD_MACSEC,
+                   (uint8_t)macId,
+                   e_FM_INTR_TYPE_NORMAL,
+                   MacsecEventIsr,
+                   p_FmMacsec);
+
+    FmRegisterIntr(p_FmMacsec->h_Fm,
+                   e_FM_MOD_MACSEC,
+                   0,
+                   e_FM_INTR_TYPE_ERR,
+                   MacsecErrorIsr,
+                   p_FmMacsec);
+
+    return E_OK;
+}
+
+static t_Error MacsecFree(t_Handle h_FmMacsec)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint32_t    macId;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    FM_MAC_GetId(p_FmMacsec->h_FmMac, &macId);
+    FmUnregisterIntr(p_FmMacsec->h_Fm,
+                   e_FM_MOD_MACSEC,
+                   (uint8_t)macId,
+                   e_FM_INTR_TYPE_NORMAL);
+
+    FmUnregisterIntr(p_FmMacsec->h_Fm,
+                   e_FM_MOD_MACSEC,
+                   0,
+                   e_FM_INTR_TYPE_ERR);
+
+    if (p_FmMacsec->rxScSpinLock)
+        XX_FreeSpinlock(p_FmMacsec->rxScSpinLock);
+    if (p_FmMacsec->txScSpinLock)
+        XX_FreeSpinlock(p_FmMacsec->txScSpinLock);
+
+    XX_Free(p_FmMacsec);
+
+    return E_OK;
+}
+
+static t_Error MacsecConfigUnknownSciFrameTreatment(t_Handle h_FmMacsec, e_FmMacsecUnknownSciFrameTreatment treatMode)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    p_FmMacsec->p_FmMacsecDriverParam->unknownSciTreatMode = treatMode;
+
+    return E_OK;
+}
+
+static t_Error MacsecConfigInvalidTagsFrameTreatment(t_Handle h_FmMacsec, bool deliverUncontrolled)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    p_FmMacsec->p_FmMacsecDriverParam->invalidTagsDeliverUncontrolled = deliverUncontrolled;
+
+    return E_OK;
+}
+
+static t_Error MacsecConfigChangedTextWithNoEncryptFrameTreatment(t_Handle h_FmMacsec, bool deliverUncontrolled)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    p_FmMacsec->p_FmMacsecDriverParam->changedTextWithNoEncryptDeliverUncontrolled = deliverUncontrolled;
+
+    return E_OK;
+}
+
+static t_Error MacsecConfigOnlyScbIsSetFrameTreatment(t_Handle h_FmMacsec, bool deliverUncontrolled)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    p_FmMacsec->p_FmMacsecDriverParam->onlyScbIsSetDeliverUncontrolled = deliverUncontrolled;
+
+    return E_OK;
+}
+
+static t_Error MacsecConfigEncryptWithNoChangedTextFrameTreatment(t_Handle h_FmMacsec, bool discardUncontrolled)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    p_FmMacsec->p_FmMacsecDriverParam->encryptWithNoChangedTextDiscardUncontrolled = discardUncontrolled;
+
+    return E_OK;
+}
+
+static t_Error MacsecConfigUntagFrameTreatment(t_Handle h_FmMacsec, e_FmMacsecUntagFrameTreatment treatMode)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    p_FmMacsec->p_FmMacsecDriverParam->untagTreatMode = treatMode;
+
+    return E_OK;
+}
+
+static t_Error MacsecConfigPnExhaustionThreshold(t_Handle h_FmMacsec, uint32_t pnExhThr)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    p_FmMacsec->p_FmMacsecDriverParam->pnExhThr = pnExhThr;
+
+    return E_OK;
+}
+
+static t_Error MacsecConfigKeysUnreadable(t_Handle h_FmMacsec)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    p_FmMacsec->p_FmMacsecDriverParam->keysUnreadable = TRUE;
+
+    return E_OK;
+}
+
+static t_Error MacsecConfigSectagWithoutSCI(t_Handle h_FmMacsec)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    p_FmMacsec->p_FmMacsecDriverParam->sectagOverhead -= MACSEC_SCI_SIZE;
+    p_FmMacsec->p_FmMacsecDriverParam->mflSubtract += MACSEC_SCI_SIZE;
+
+    return E_OK;
+}
+
+static t_Error MacsecConfigException(t_Handle h_FmMacsec, e_FmMacsecExceptions exception, bool enable)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint32_t    bitMask = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    GET_USER_EXCEPTION_FLAG(bitMask, exception);
+    if (bitMask)
+    {
+        if (enable)
+            p_FmMacsec->userExceptions |= bitMask;
+        else
+            p_FmMacsec->userExceptions &= ~bitMask;
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    return E_OK;
+}
+
+static t_Error MacsecGetRevision(t_Handle h_FmMacsec, uint32_t *p_MacsecRevision)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    *p_MacsecRevision = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->ip_rev1);
+
+    return E_OK;
+}
+
+static t_Error MacsecEnable(t_Handle h_FmMacsec)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint32_t    tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    tmpReg  = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->cfg);
+    tmpReg |= CFG_BYPN;
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->cfg,tmpReg);
+
+    return E_OK;
+}
+
+static t_Error MacsecDisable(t_Handle h_FmMacsec)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint32_t    tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    tmpReg  = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->cfg);
+    tmpReg &= ~CFG_BYPN;
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->cfg,tmpReg);
+
+    return E_OK;
+}
+
+static t_Error MacsecSetException(t_Handle h_FmMacsec, e_FmMacsecExceptions exception, bool enable)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint32_t    bitMask;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    GET_USER_EXCEPTION_FLAG(bitMask, exception);
+    if (bitMask)
+    {
+        if (enable)
+            p_FmMacsec->userExceptions |= bitMask;
+        else
+            p_FmMacsec->userExceptions &= ~bitMask;
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    if (!p_FmMacsec->userExceptions)
+        p_FmMacsec->exceptions &= ~FM_MACSEC_EX_ECC;
+    else
+        p_FmMacsec->exceptions |= FM_MACSEC_EX_ECC;
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->erer, p_FmMacsec->exceptions);
+
+    return E_OK;
+}
+
+static void InitFmMacsecControllerDriver(t_FmMacsecControllerDriver *p_FmMacsecControllerDriver)
+{
+    p_FmMacsecControllerDriver->f_FM_MACSEC_Init                                            = MacsecInit;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_Free                                            = MacsecFree;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigUnknownSciFrameTreatment                  = MacsecConfigUnknownSciFrameTreatment;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigInvalidTagsFrameTreatment                 = MacsecConfigInvalidTagsFrameTreatment;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigEncryptWithNoChangedTextFrameTreatment    = MacsecConfigEncryptWithNoChangedTextFrameTreatment;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigUntagFrameTreatment                       = MacsecConfigUntagFrameTreatment;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigChangedTextWithNoEncryptFrameTreatment    = MacsecConfigChangedTextWithNoEncryptFrameTreatment;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigOnlyScbIsSetFrameTreatment                = MacsecConfigOnlyScbIsSetFrameTreatment;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigPnExhaustionThreshold                     = MacsecConfigPnExhaustionThreshold;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigKeysUnreadable                            = MacsecConfigKeysUnreadable;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigSectagWithoutSCI                          = MacsecConfigSectagWithoutSCI;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigException                                 = MacsecConfigException;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_GetRevision                                     = MacsecGetRevision;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_Enable                                          = MacsecEnable;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_Disable                                         = MacsecDisable;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_SetException                                    = MacsecSetException;
+}
+
+/****************************************/
+/*       Inter-Module functions         */
+/****************************************/
+
+void FmMacsecRegisterIntr(t_Handle                h_FmMacsec,
+                          e_FmMacsecEventModules  module,
+                          uint8_t                 modId,
+                          e_FmIntrType            intrType,
+                          void (*f_Isr) (t_Handle h_Arg, uint32_t id),
+                          t_Handle                h_Arg)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint8_t     event= 0;
+
+    SANITY_CHECK_RETURN(p_FmMacsec, E_INVALID_HANDLE);
+
+    GET_MACSEC_MODULE_EVENT(module, modId, intrType, event);
+
+    ASSERT_COND(event != e_FM_MACSEC_EV_DUMMY_LAST);
+    p_FmMacsec->intrMng[event].f_Isr = f_Isr;
+    p_FmMacsec->intrMng[event].h_SrcHandle = h_Arg;
+}
+
+void FmMacsecUnregisterIntr(t_Handle                h_FmMacsec,
+                            e_FmMacsecEventModules  module,
+                            uint8_t                 modId,
+                            e_FmIntrType            intrType)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint8_t     event= 0;
+
+    SANITY_CHECK_RETURN(p_FmMacsec, E_INVALID_HANDLE);
+
+    GET_MACSEC_MODULE_EVENT(module, modId,intrType, event);
+
+    ASSERT_COND(event != e_FM_MACSEC_EV_DUMMY_LAST);
+    p_FmMacsec->intrMng[event].f_Isr = NULL;
+    p_FmMacsec->intrMng[event].h_SrcHandle = NULL;
+}
+
+t_Error FmMacsecAllocScs(t_Handle h_FmMacsec, e_ScType type, bool isPtp, uint32_t numOfScs, uint32_t *p_ScIds)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    bool        *p_ScTable;
+    uint32_t    *p_ScAvailable,i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_ScIds, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(numOfScs, E_INVALID_HANDLE);
+
+    if (type == e_SC_RX)
+    {
+        p_ScTable       = (bool *)p_FmMacsec->rxScTable;
+        p_ScAvailable   = &p_FmMacsec->numRxScAvailable;
+        i               = (NUM_OF_RX_SC - 1);
+    }
+    else
+    {
+        p_ScTable       = (bool *)p_FmMacsec->txScTable;
+        p_ScAvailable   = &p_FmMacsec->numTxScAvailable;
+        i               = (NUM_OF_TX_SC - 1);
+
+    }
+    if (*p_ScAvailable < numOfScs)
+        RETURN_ERROR(MINOR, E_NOT_AVAILABLE, ("Not enough SCs available"));
+
+    if (isPtp)
+    {
+        i = 0;
+        if (p_ScTable[i])
+            RETURN_ERROR(MINOR, E_NOT_AVAILABLE, ("Sc 0 Not available"));
+    }
+
+    for (;numOfScs;i--)
+    {
+        if (p_ScTable[i])
+            continue;
+        numOfScs --;
+        (*p_ScAvailable)--;
+        p_ScIds[numOfScs] = i;
+        p_ScTable[i] = TRUE;
+    }
+
+    return err;
+}
+
+t_Error FmMacsecFreeScs(t_Handle h_FmMacsec, e_ScType type, uint32_t numOfScs, uint32_t *p_ScIds)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    bool        *p_ScTable;
+    uint32_t    *p_ScAvailable,maxNumOfSc,i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_ScIds, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(numOfScs, E_INVALID_HANDLE);
+
+    if (type == e_SC_RX)
+    {
+        p_ScTable       = (bool *)p_FmMacsec->rxScTable;
+        p_ScAvailable   = &p_FmMacsec->numRxScAvailable;
+        maxNumOfSc      = NUM_OF_RX_SC;
+    }
+    else
+    {
+        p_ScTable       = (bool *)p_FmMacsec->txScTable;
+        p_ScAvailable   = &p_FmMacsec->numTxScAvailable;
+        maxNumOfSc      = NUM_OF_TX_SC;
+    }
+
+    if ((*p_ScAvailable + numOfScs) > maxNumOfSc)
+        RETURN_ERROR(MINOR, E_FULL, ("Too much SCs"));
+
+    for (i=0;i<numOfScs;i++)
+    {
+        p_ScTable[p_ScIds[i]] = FALSE;
+        (*p_ScAvailable)++;
+    }
+
+    return err;
+
+}
+
+t_Error FmMacsecSetPTP(t_Handle h_FmMacsec, bool enable)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint32_t    tmpReg = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+
+    tmpReg = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->cfg);
+    if (enable && (tmpReg & CFG_S0I))
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("MACSEC already in point-to-point mode"));
+
+    if (enable)
+        tmpReg |= CFG_S0I;
+    else
+        tmpReg &= ~CFG_S0I;
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->cfg, tmpReg);
+
+    return E_OK;
+}
+
+t_Error FmMacsecCreateRxSc(t_Handle h_FmMacsec, t_RxScParams *p_RxScParams)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    tmpReg = 0, intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_RxScParams, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_RxScParams->scId < NUM_OF_RX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->rxScSpinLock);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsca, p_RxScParams->scId);
+    tmpReg = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsccfg);
+    if (tmpReg & RX_SCCFG_SCI_EN_MASK)
+    {
+        XX_UnlockIntrSpinlock(p_FmMacsec->rxScSpinLock, intFlags);
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Rx Sc %d must be disable",p_RxScParams->scId));
+    }
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsci1h, GET_SCI_FIRST_HALF(p_RxScParams->sci));
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsci2h, GET_SCI_SECOND_HALF(p_RxScParams->sci));
+    tmpReg |= ((p_RxScParams->replayProtect << RX_SCCFG_RP_SHIFT) & RX_SCCFG_RP_MASK);
+    tmpReg |= ((p_RxScParams->validateFrames << RX_SCCFG_VF_SHIFT) & RX_SCCFG_VF_MASK);
+    tmpReg |= ((p_RxScParams->confidentialityOffset << RX_SCCFG_CO_SHIFT) & RX_SCCFG_CO_MASK);
+    tmpReg |= RX_SCCFG_SCI_EN_MASK;
+    tmpReg |= (p_RxScParams->cipherSuite << RX_SCCFG_CS_SHIFT);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsccfg, tmpReg);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rpw, p_RxScParams->replayWindow);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->rxScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecDeleteRxSc(t_Handle h_FmMacsec, uint32_t scId)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    tmpReg = 0, intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(scId < NUM_OF_RX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->rxScSpinLock);
+
+    tmpReg &= ~RX_SCCFG_SCI_EN_MASK;
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsca, scId);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsccfg, tmpReg);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->rxScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecCreateTxSc(t_Handle h_FmMacsec, t_TxScParams *p_TxScParams)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    tmpReg = 0, intFlags;
+    bool        alwaysIncludeSCI = FALSE, useES = FALSE, useSCB = FALSE;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_TxScParams, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_TxScParams->scId < NUM_OF_TX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->txScSpinLock);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->txsca, p_TxScParams->scId);
+
+    tmpReg = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->txsccfg);
+    if (tmpReg & TX_SCCFG_SCE_MASK)
+    {
+        XX_UnlockIntrSpinlock(p_FmMacsec->txScSpinLock, intFlags);
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Tx Sc %d must be disable",p_TxScParams->scId));
+    }
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->txsci1h, GET_SCI_FIRST_HALF(p_TxScParams->sci));
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->txsci2h, GET_SCI_SECOND_HALF(p_TxScParams->sci));
+    alwaysIncludeSCI = (p_TxScParams->sciInsertionMode == e_FM_MACSEC_SCI_INSERTION_MODE_EXPLICIT_SECTAG);
+    useES            = (p_TxScParams->sciInsertionMode == e_FM_MACSEC_SCI_INSERTION_MODE_EXPLICIT_MAC_SA);
+
+    tmpReg |= ((p_TxScParams->protectFrames << TX_SCCFG_PF_SHIFT) & TX_SCCFG_PF_MASK);
+    tmpReg |= ((alwaysIncludeSCI << TX_SCCFG_AIS_SHIFT) & TX_SCCFG_AIS_MASK);
+    tmpReg |= ((useES << TX_SCCFG_UES_SHIFT) & TX_SCCFG_UES_MASK);
+    tmpReg |= ((useSCB << TX_SCCFG_USCB_SHIFT) & TX_SCCFG_USCB_MASK);
+    tmpReg |= ((p_TxScParams->confidentialityEnable << TX_SCCFG_CE_SHIFT) & TX_SCCFG_CE_MASK);
+    tmpReg |= ((p_TxScParams->confidentialityOffset << TX_SCCFG_CO_SHIFT) & TX_SCCFG_CO_MASK);
+    tmpReg |= TX_SCCFG_SCE_MASK;
+    tmpReg |= (p_TxScParams->cipherSuite << TX_SCCFG_CS_SHIFT);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->txsccfg, tmpReg);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->txScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecDeleteTxSc(t_Handle h_FmMacsec, uint32_t scId)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    tmpReg = 0, intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(scId < NUM_OF_TX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->txScSpinLock);
+
+    tmpReg &= ~TX_SCCFG_SCE_MASK;
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->txsca, scId);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->txsccfg, tmpReg);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->txScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecCreateRxSa(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, macsecAN_t an, uint32_t lowestPn, macsecSAKey_t key)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    tmpReg = 0, intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(scId < NUM_OF_RX_SC, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(saId < NUM_OF_SA_PER_RX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->rxScSpinLock);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsca, scId);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsanpn, DEFAULT_initNextPn);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsalpn, lowestPn);
+    Mem2IOCpy32((void*)p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsak, key, sizeof(macsecSAKey_t));
+
+    tmpReg |= RX_SACFG_ACTIVE;
+    tmpReg |= ((an << RX_SACFG_AN_SHIFT) & RX_SACFG_AN_MASK);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsacs, tmpReg);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->rxScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecCreateTxSa(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, macsecSAKey_t key)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    tmpReg = 0, intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(scId < NUM_OF_RX_SC, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(saId < NUM_OF_SA_PER_TX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->txScSpinLock);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->txsca, scId);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecTxScSa[saId].txsanpn, DEFAULT_initNextPn);
+    Mem2IOCpy32((void*)p_FmMacsec->p_FmMacsecRegs->fmMacsecTxScSa[saId].txsak, key, sizeof(macsecSAKey_t));
+
+    tmpReg |= TX_SACFG_ACTIVE;
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecTxScSa[saId].txsacs, tmpReg);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->txScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecDeleteRxSa(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    tmpReg = 0, i, intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(scId < NUM_OF_RX_SC, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(saId < NUM_OF_SA_PER_RX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->rxScSpinLock);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsca, scId);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsanpn, 0x0);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsalpn, 0x0);
+    for (i=0; i<4; i++)
+        WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsak[i], 0x0);
+
+    tmpReg |= RX_SACFG_ACTIVE;
+    tmpReg &= ~RX_SACFG_EN_MASK;
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsacs, tmpReg);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->rxScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecDeleteTxSa(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    tmpReg = 0, i, intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(scId < NUM_OF_RX_SC, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(saId < NUM_OF_SA_PER_TX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->txScSpinLock);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->txsca, scId);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecTxScSa[saId].txsanpn, 0x0);
+    for (i=0; i<4; i++)
+        WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecTxScSa[saId].txsak[i], 0x0);
+
+    tmpReg |= TX_SACFG_ACTIVE;
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecTxScSa[saId].txsacs, tmpReg);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->txScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecRxSaSetReceive(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, bool enableReceive)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    tmpReg = 0, intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(scId < NUM_OF_RX_SC, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(saId < NUM_OF_SA_PER_RX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->rxScSpinLock);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsca, scId);
+    tmpReg = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsacs);
+    if (enableReceive)
+        tmpReg |= RX_SACFG_EN_MASK;
+    else
+        tmpReg &= ~RX_SACFG_EN_MASK;
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsacs, tmpReg);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->rxScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecRxSaUpdateNextPn(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, uint32_t updtNextPN)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(scId < NUM_OF_RX_SC, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(saId < NUM_OF_SA_PER_RX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->rxScSpinLock);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsca, scId);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsanpn, updtNextPN);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->rxScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecRxSaUpdateLowestPn(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, uint32_t updtLowestPN)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(scId < NUM_OF_RX_SC, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(saId < NUM_OF_SA_PER_RX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->rxScSpinLock);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsca, scId);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsalpn, updtLowestPN);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->rxScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecTxSaSetActive(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, macsecAN_t an)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    tmpReg = 0, intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(scId < NUM_OF_RX_SC, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(saId < NUM_OF_SA_PER_TX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->txScSpinLock);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->txsca, scId);
+
+    tmpReg = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->txsccfg);
+
+    tmpReg |= ((an << TX_SCCFG_AN_SHIFT) & TX_SCCFG_AN_MASK);
+    tmpReg |= ((saId << TX_SCCFG_ASA_SHIFT) & TX_SCCFG_ASA_MASK);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->txsccfg, tmpReg);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->txScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecTxSaGetActive(t_Handle h_FmMacsec, uint32_t scId, macsecAN_t *p_An)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    tmpReg = 0, intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(scId < NUM_OF_RX_SC, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_An, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->txScSpinLock);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->txsca, scId);
+
+    tmpReg = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->txsccfg);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->txScSpinLock, intFlags);
+
+    *p_An = (macsecAN_t)((tmpReg & TX_SCCFG_AN_MASK) >> TX_SCCFG_AN_SHIFT);
+
+    return err;
+}
+
+t_Error FmMacsecSetException(t_Handle h_FmMacsec, e_FmMacsecGlobalExceptions exception, uint32_t scId, bool enable)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint32_t    bitMask;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    GET_EXCEPTION_FLAG(bitMask, exception, scId);
+    if (bitMask)
+    {
+        if (enable)
+            p_FmMacsec->exceptions |= bitMask;
+        else
+            p_FmMacsec->exceptions &= ~bitMask;
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->erer, p_FmMacsec->exceptions);
+
+    return E_OK;
+}
+
+t_Error FmMacsecSetEvent(t_Handle h_FmMacsec, e_FmMacsecGlobalEvents event, uint32_t scId, bool enable)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint32_t    bitMask;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    GET_EVENT_FLAG(bitMask, event, scId);
+    if (bitMask)
+    {
+        if (enable)
+            p_FmMacsec->events |= bitMask;
+        else
+            p_FmMacsec->events &= ~bitMask;
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined event"));
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->ever, p_FmMacsec->events);
+
+    return E_OK;
+}
+
+/****************************************/
+/*       API Init unit functions        */
+/****************************************/
+t_Handle FM_MACSEC_MASTER_Config(t_FmMacsecParams *p_FmMacsecParam)
+{
+    t_FmMacsec  *p_FmMacsec;
+    uint32_t    macId;
+
+    /* Allocate FM MACSEC structure */
+    p_FmMacsec = (t_FmMacsec *) XX_Malloc(sizeof(t_FmMacsec));
+    if (!p_FmMacsec)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM MACSEC driver structure"));
+        return NULL;
+    }
+    memset(p_FmMacsec, 0, sizeof(t_FmMacsec));
+    InitFmMacsecControllerDriver(&p_FmMacsec->fmMacsecControllerDriver);
+
+    /* Allocate the FM MACSEC driver's parameters structure */
+    p_FmMacsec->p_FmMacsecDriverParam = (t_FmMacsecDriverParam *)XX_Malloc(sizeof(t_FmMacsecDriverParam));
+    if (!p_FmMacsec->p_FmMacsecDriverParam)
+    {
+        XX_Free(p_FmMacsec);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM MACSEC driver parameters"));
+        return NULL;
+    }
+    memset(p_FmMacsec->p_FmMacsecDriverParam, 0, sizeof(t_FmMacsecDriverParam));
+
+    /* Initialize FM MACSEC parameters which will be kept by the driver */
+    p_FmMacsec->h_Fm            = p_FmMacsecParam->h_Fm;
+    p_FmMacsec->h_FmMac         = p_FmMacsecParam->nonGuestParams.h_FmMac;
+    p_FmMacsec->p_FmMacsecRegs  = (t_FmMacsecRegs *)UINT_TO_PTR(p_FmMacsecParam->nonGuestParams.baseAddr);
+    p_FmMacsec->f_Exception     = p_FmMacsecParam->nonGuestParams.f_Exception;
+    p_FmMacsec->h_App           = p_FmMacsecParam->nonGuestParams.h_App;
+    p_FmMacsec->userExceptions  = DEFAULT_userExceptions;
+    p_FmMacsec->exceptions      = DEFAULT_exceptions;
+    p_FmMacsec->events          = DEFAULT_events;
+    p_FmMacsec->rxScSpinLock    = XX_InitSpinlock();
+    p_FmMacsec->txScSpinLock    = XX_InitSpinlock();
+
+    /* Initialize FM MACSEC driver parameters parameters (for initialization phase only) */
+    p_FmMacsec->p_FmMacsecDriverParam->unknownSciTreatMode                           = DEFAULT_unknownSciFrameTreatment;
+    p_FmMacsec->p_FmMacsecDriverParam->invalidTagsDeliverUncontrolled                = DEFAULT_invalidTagsFrameTreatment;
+    p_FmMacsec->p_FmMacsecDriverParam->encryptWithNoChangedTextDiscardUncontrolled   = DEFAULT_encryptWithNoChangedTextFrameTreatment;
+    p_FmMacsec->p_FmMacsecDriverParam->untagTreatMode                                = DEFAULT_untagFrameTreatment;
+    p_FmMacsec->p_FmMacsecDriverParam->keysUnreadable                                = DEFAULT_keysUnreadable;
+    p_FmMacsec->p_FmMacsecDriverParam->reservedSc0                                   = DEFAULT_sc0ReservedForPTP;
+    p_FmMacsec->p_FmMacsecDriverParam->byPassMode                                    = !DEFAULT_normalMode;
+    p_FmMacsec->p_FmMacsecDriverParam->pnExhThr                                      = DEFAULT_pnExhThr;
+    p_FmMacsec->p_FmMacsecDriverParam->sectagOverhead                                = DEFAULT_sectagOverhead;
+    p_FmMacsec->p_FmMacsecDriverParam->mflSubtract                                   = DEFAULT_mflSubtract;
+    /* build the FM MACSEC master IPC address */
+    memset(p_FmMacsec->fmMacsecModuleName, 0, (sizeof(char))*MODULE_NAME_SIZE);
+    FM_MAC_GetId(p_FmMacsec->h_FmMac,&macId);
+    if (Sprint (p_FmMacsec->fmMacsecModuleName, "FM-%d-MAC-%d-MACSEC-Master",
+        FmGetId(p_FmMacsec->h_Fm),macId) != 24)
+    {
+        XX_Free(p_FmMacsec->p_FmMacsecDriverParam);
+        XX_Free(p_FmMacsec);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+        return NULL;
+    }
+    return p_FmMacsec;
+}
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_master.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_master.h
new file mode 100644
index 0000000..2296a0f
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_master.h
@@ -0,0 +1,479 @@
+/*
+ * Copyright 2008-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_macsec_master.h
+
+ @Description   FM MACSEC internal structures and definitions.
+*//***************************************************************************/
+#ifndef __FM_MACSEC_MASTER_H
+#define __FM_MACSEC_MASTER_H
+
+#include "error_ext.h"
+#include "std_ext.h"
+
+#include "fm_macsec.h"
+
+
+#define MACSEC_ICV_SIZE             16
+#define MACSEC_SECTAG_SIZE          16
+#define MACSEC_SCI_SIZE             8
+#define MACSEC_FCS_SIZE             4
+
+/**************************************************************************//**
+ @Description       Exceptions
+*//***************************************************************************/
+
+#define FM_MACSEC_EX_TX_SC_0       0x80000000
+#define FM_MACSEC_EX_TX_SC(sc)     (FM_MACSEC_EX_TX_SC_0 >> (sc))
+#define FM_MACSEC_EX_ECC           0x00000001
+
+#define GET_EXCEPTION_FLAG(bitMask, exception, id)  switch (exception){     \
+    case e_FM_MACSEC_EX_TX_SC:                                              \
+        bitMask = FM_MACSEC_EX_TX_SC(id); break;                            \
+    case e_FM_MACSEC_EX_ECC:                                                \
+        bitMask = FM_MACSEC_EX_ECC; break;                                  \
+    default: bitMask = 0;break;}
+
+#define FM_MACSEC_USER_EX_SINGLE_BIT_ECC            0x80000000
+#define FM_MACSEC_USER_EX_MULTI_BIT_ECC             0x40000000
+
+#define GET_USER_EXCEPTION_FLAG(bitMask, exception)     switch (exception){ \
+    case e_FM_MACSEC_EX_SINGLE_BIT_ECC:                                     \
+        bitMask = FM_MACSEC_USER_EX_SINGLE_BIT_ECC; break;                  \
+    case e_FM_MACSEC_EX_MULTI_BIT_ECC:                                      \
+        bitMask = FM_MACSEC_USER_EX_MULTI_BIT_ECC; break;                   \
+    default: bitMask = 0;break;}
+
+/**************************************************************************//**
+ @Description       Events
+*//***************************************************************************/
+
+#define FM_MACSEC_EV_TX_SC_0_NEXT_PN                  0x80000000
+#define FM_MACSEC_EV_TX_SC_NEXT_PN(sc)                (FM_MACSEC_EV_TX_SC_0_NEXT_PN >> (sc))
+
+#define GET_EVENT_FLAG(bitMask, event, id)      switch (event){     \
+    case e_FM_MACSEC_EV_TX_SC_NEXT_PN:                              \
+        bitMask = FM_MACSEC_EV_TX_SC_NEXT_PN(id); break;            \
+    default: bitMask = 0;break;}
+
+/**************************************************************************//**
+ @Description       Defaults
+*//***************************************************************************/
+#define DEFAULT_userExceptions              (FM_MACSEC_USER_EX_SINGLE_BIT_ECC     |\
+                                            FM_MACSEC_USER_EX_MULTI_BIT_ECC)
+
+#define DEFAULT_exceptions                  (FM_MACSEC_EX_TX_SC(0)     |\
+                                            FM_MACSEC_EX_TX_SC(1)      |\
+                                            FM_MACSEC_EX_TX_SC(2)      |\
+                                            FM_MACSEC_EX_TX_SC(3)      |\
+                                            FM_MACSEC_EX_TX_SC(4)      |\
+                                            FM_MACSEC_EX_TX_SC(5)      |\
+                                            FM_MACSEC_EX_TX_SC(6)      |\
+                                            FM_MACSEC_EX_TX_SC(7)      |\
+                                            FM_MACSEC_EX_TX_SC(8)      |\
+                                            FM_MACSEC_EX_TX_SC(9)      |\
+                                            FM_MACSEC_EX_TX_SC(10)     |\
+                                            FM_MACSEC_EX_TX_SC(11)     |\
+                                            FM_MACSEC_EX_TX_SC(12)     |\
+                                            FM_MACSEC_EX_TX_SC(13)     |\
+                                            FM_MACSEC_EX_TX_SC(14)     |\
+                                            FM_MACSEC_EX_TX_SC(15)     |\
+                                            FM_MACSEC_EX_ECC          )
+
+#define DEFAULT_events                      (FM_MACSEC_EV_TX_SC_NEXT_PN(0)   |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(1)    |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(2)    |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(3)    |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(4)    |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(5)    |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(6)    |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(7)    |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(8)    |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(9)    |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(10)   |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(11)   |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(12)   |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(13)   |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(14)   |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(15)   )
+
+#define DEFAULT_unknownSciFrameTreatment                e_FM_MACSEC_UNKNOWN_SCI_FRAME_TREATMENT_DISCARD_BOTH
+#define DEFAULT_invalidTagsFrameTreatment               FALSE
+#define DEFAULT_encryptWithNoChangedTextFrameTreatment  FALSE
+#define DEFAULT_untagFrameTreatment                     e_FM_MACSEC_UNTAG_FRAME_TREATMENT_DELIVER_UNCONTROLLED_DISCARD_CONTROLLED
+#define DEFAULT_changedTextWithNoEncryptFrameTreatment  FALSE
+#define DEFAULT_onlyScbIsSetFrameTreatment              FALSE
+#define DEFAULT_keysUnreadable                          FALSE
+#define DEFAULT_normalMode                              TRUE
+#define DEFAULT_sc0ReservedForPTP                       FALSE
+#define DEFAULT_initNextPn                              1
+#define DEFAULT_pnExhThr                                0xffffffff
+#define DEFAULT_sectagOverhead                          (MACSEC_ICV_SIZE + MACSEC_SECTAG_SIZE)
+#define DEFAULT_mflSubtract                             MACSEC_FCS_SIZE
+
+
+/**************************************************************************//**
+ @Description       Memory Mapped Registers
+*//***************************************************************************/
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+
+typedef _Packed struct
+{
+    /* MACsec configuration */
+    volatile uint32_t   cfg;            /**< MACsec configuration */
+    volatile uint32_t   et;             /**< MACsec EtherType */
+    volatile uint8_t    res1[56];       /**< reserved */
+    volatile uint32_t   mfl;            /**< Maximum Frame Length */
+    volatile uint32_t   tpnet;          /**< TX Packet Number exhaustion threshold */
+    volatile uint8_t    res2[56];       /**< reserved */
+    volatile uint32_t   rxsca;          /**< RX SC access select */
+    volatile uint8_t    res3[60];       /**< reserved */
+    volatile uint32_t   txsca;          /**< TX SC access select */
+    volatile uint8_t    res4[60];       /**< reserved */
+
+    /* RX configuration, status and statistic */
+    volatile uint32_t   rxsci1h;        /**< RX Secure Channel Identifier first half */
+    volatile uint32_t   rxsci2h;        /**< RX Secure Channel Identifier second half */
+    volatile uint8_t    res5[8];        /**< reserved */
+    volatile uint32_t   ifio1hs;        /**< ifInOctets first half Statistic */
+    volatile uint32_t   ifio2hs;        /**< ifInOctets second half Statistic */
+    volatile uint32_t   ifiups;         /**< ifInUcastPkts Statistic */
+    volatile uint8_t    res6[4];        /**< reserved */
+    volatile uint32_t   ifimps;         /**< ifInMulticastPkts Statistic */
+    volatile uint32_t   ifibps;         /**< ifInBroadcastPkts Statistic */
+    volatile uint32_t   rxsccfg;        /**< RX Secure Channel configuration */
+    volatile uint32_t   rpw;            /**< replayWindow */
+    volatile uint8_t    res7[16];       /**< reserved */
+    volatile uint32_t   inov1hs;        /**< InOctetsValidated first half Statistic */
+    volatile uint32_t   inov2hs;        /**< InOctetsValidated second half Statistic */
+    volatile uint32_t   inod1hs;        /**< InOctetsDecrypted first half Statistic */
+    volatile uint32_t   inod2hs;        /**< InOctetsDecrypted second half Statistic */
+    volatile uint32_t   rxscipus;       /**< RX Secure Channel InPktsUnchecked Statistic */
+    volatile uint32_t   rxscipds;       /**< RX Secure Channel InPktsDelayed Statistic */
+    volatile uint32_t   rxscipls;       /**< RX Secure Channel InPktsLate Statistic */
+    volatile uint8_t    res8[4];        /**< reserved */
+    volatile uint32_t   rxaninuss[MAX_NUM_OF_SA_PER_SC];   /**< RX AN 0-3 InNotUsingSA Statistic */
+    volatile uint32_t   rxanipuss[MAX_NUM_OF_SA_PER_SC];   /**< RX AN 0-3 InPktsUnusedSA Statistic */
+    _Packed struct
+    {
+        volatile uint32_t   rxsacs;     /**< RX Security Association configuration and status */
+        volatile uint32_t   rxsanpn;    /**< RX Security Association nextPN */
+        volatile uint32_t   rxsalpn;    /**< RX Security Association lowestPN */
+        volatile uint32_t   rxsaipos;   /**< RX Security Association InPktsOK Statistic */
+        volatile uint32_t   rxsak[4];   /**< RX Security Association key (128 bit) */
+        volatile uint32_t   rxsah[4];   /**< RX Security Association hash (128 bit) */
+        volatile uint32_t   rxsaipis;   /**< RX Security Association InPktsInvalid Statistic */
+        volatile uint32_t   rxsaipnvs;  /**< RX Security Association InPktsNotValid Statistic */
+        volatile uint8_t    res9[8];    /**< reserved */
+    } _PackedType fmMacsecRxScSa[NUM_OF_SA_PER_RX_SC];
+
+    /* TX configuration, status and statistic */
+    volatile uint32_t   txsci1h;        /**< TX Secure Channel Identifier first half */
+    volatile uint32_t   txsci2h;        /**< TX Secure Channel Identifier second half */
+    volatile uint8_t    res10[8];        /**< reserved */
+    volatile uint32_t   ifoo1hs;        /**< ifOutOctets first half Statistic */
+    volatile uint32_t   ifoo2hs;        /**< ifOutOctets second half Statistic */
+    volatile uint32_t   ifoups;         /**< ifOutUcastPkts Statistic */
+    volatile uint32_t   opus;           /**< OutPktsUntagged Statistic */
+    volatile uint32_t   ifomps;         /**< ifOutMulticastPkts Statistic */
+    volatile uint32_t   ifobps;         /**< ifOutBroadcastPkts Statistic */
+    volatile uint32_t   txsccfg;        /**< TX Secure Channel configuration */
+    volatile uint32_t   optls;          /**< OutPktsTooLong Statistic */
+    volatile uint8_t    res11[16];      /**< reserved */
+    volatile uint32_t   oop1hs;         /**< OutOctetsProtected first half Statistic */
+    volatile uint32_t   oop2hs;         /**< OutOctetsProtected second half Statistic */
+    volatile uint32_t   ooe1hs;         /**< OutOctetsEncrypted first half Statistic */
+    volatile uint32_t   ooe2hs;         /**< OutOctetsEncrypted second half Statistic */
+    volatile uint8_t    res12[48];      /**< reserved */
+    _Packed struct
+    {
+        volatile uint32_t   txsacs;     /**< TX Security Association configuration and status */
+        volatile uint32_t   txsanpn;    /**< TX Security Association nextPN */
+        volatile uint32_t   txsaopps;   /**< TX Security Association OutPktsProtected Statistic */
+        volatile uint32_t   txsaopes;   /**< TX Security Association OutPktsEncrypted Statistic */
+        volatile uint32_t   txsak[4];   /**< TX Security Association key (128 bit) */
+        volatile uint32_t   txsah[4];   /**< TX Security Association hash (128 bit) */
+        volatile uint8_t    res13[16];  /**< reserved */
+    } _PackedType fmMacsecTxScSa[NUM_OF_SA_PER_TX_SC];
+    volatile uint8_t    res14[248];     /**< reserved */
+
+    /* Global configuration and status */
+    volatile uint32_t   ip_rev1;        /**< MACsec IP Block Revision 1 register */
+    volatile uint32_t   ip_rev2;        /**< MACsec IP Block Revision 2 register */
+    volatile uint32_t   evr;            /**< MACsec Event Register */
+    volatile uint32_t   ever;           /**< MACsec Event Enable Register */
+    volatile uint32_t   evfr;           /**< MACsec Event Force Register */
+    volatile uint32_t   err;            /**< MACsec Error Register */
+    volatile uint32_t   erer;           /**< MACsec Error Enable Register */
+    volatile uint32_t   erfr;           /**< MACsec Error Force Register */
+    volatile uint8_t    res15[40];      /**< reserved */
+    volatile uint32_t   meec;           /**< MACsec Memory ECC Error Capture Register */
+    volatile uint32_t   idle;           /**< MACsec Idle status Register */
+    volatile uint8_t    res16[184];     /**< reserved */
+    /* DEBUG */
+    volatile uint32_t   rxec;           /**< MACsec RX error capture Register */
+    volatile uint8_t    res17[28];      /**< reserved */
+    volatile uint32_t   txec;           /**< MACsec TX error capture Register */
+    volatile uint8_t    res18[220];     /**< reserved */
+
+    /* Macsec Rx global statistic */
+    volatile uint32_t   ifiocp1hs;      /**< ifInOctetsCp first half Statistic */
+    volatile uint32_t   ifiocp2hs;      /**< ifInOctetsCp second half Statistic */
+    volatile uint32_t   ifiupcps;       /**< ifInUcastPktsCp Statistic */
+    volatile uint8_t    res19[4];       /**< reserved */
+    volatile uint32_t   ifioup1hs;      /**< ifInOctetsUp first half Statistic */
+    volatile uint32_t   ifioup2hs;      /**< ifInOctetsUp second half Statistic */
+    volatile uint32_t   ifiupups;       /**< ifInUcastPktsUp Statistic */
+    volatile uint8_t    res20[4];       /**< reserved */
+    volatile uint32_t   ifimpcps;       /**< ifInMulticastPktsCp Statistic */
+    volatile uint32_t   ifibpcps;       /**< ifInBroadcastPktsCp Statistic */
+    volatile uint32_t   ifimpups;       /**< ifInMulticastPktsUp Statistic */
+    volatile uint32_t   ifibpups;       /**< ifInBroadcastPktsUp Statistic */
+    volatile uint32_t   ipwts;          /**< InPktsWithoutTag Statistic */
+    volatile uint32_t   ipkays;         /**< InPktsKaY Statistic */
+    volatile uint32_t   ipbts;          /**< InPktsBadTag Statistic */
+    volatile uint32_t   ipsnfs;         /**< InPktsSCINotFound Statistic */
+    volatile uint32_t   ipuecs;         /**< InPktsUnsupportedEC Statistic */
+    volatile uint32_t   ipescbs;        /**< InPktsEponSingleCopyBroadcast Statistic */
+    volatile uint32_t   iptls;          /**< InPktsTooLong Statistic */
+    volatile uint8_t    res21[52];      /**< reserved */
+
+    /* Macsec Tx global statistic */
+    volatile uint32_t   opds;           /**< OutPktsDiscarded Statistic */
+#if (DPAA_VERSION >= 11)
+    volatile uint8_t    res22[124];     /**< reserved */
+    _Packed struct
+    {
+        volatile uint32_t   rxsak[8];   /**< RX Security Association key (128/256 bit) */
+        volatile uint8_t    res23[32];  /**< reserved */
+    } _PackedType rxScSaKey[NUM_OF_SA_PER_RX_SC];
+    _Packed struct
+    {
+        volatile uint32_t   txsak[8];   /**< TX Security Association key (128/256 bit) */
+        volatile uint8_t    res24[32];  /**< reserved */
+    } _PackedType txScSaKey[NUM_OF_SA_PER_TX_SC];
+#endif /* (DPAA_VERSION >= 11) */
+} _PackedType t_FmMacsecRegs;
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+
+/**************************************************************************//**
+ @Description       General defines
+*//***************************************************************************/
+
+#define SCI_HIGH_MASK   0xffffffff00000000LL
+#define SCI_LOW_MASK    0x00000000ffffffffLL
+
+#define LONG_SHIFT      32
+
+#define GET_SCI_FIRST_HALF(sci)     (uint32_t)((macsecSCI_t)((macsecSCI_t)(sci) & SCI_HIGH_MASK) >> LONG_SHIFT)
+#define GET_SCI_SECOND_HALF(sci)    (uint32_t)((macsecSCI_t)(sci) & SCI_LOW_MASK)
+
+/**************************************************************************//**
+ @Description       Configuration defines
+*//***************************************************************************/
+
+/* masks */
+#define CFG_UECT                        0x00000800
+#define CFG_ESCBT                       0x00000400
+#define CFG_USFT                        0x00000300
+#define CFG_ITT                         0x00000080
+#define CFG_KFT                         0x00000040
+#define CFG_UFT                         0x00000030
+#define CFG_KSS                         0x00000004
+#define CFG_BYPN                        0x00000002
+#define CFG_S0I                         0x00000001
+
+#define ET_TYPE                         0x0000ffff
+
+#define MFL_MAX_LEN                     0x0000ffff
+
+#define RXSCA_SC_SEL                    0x0000000f
+
+#define TXSCA_SC_SEL                    0x0000000f
+
+#define IP_REV_1_IP_ID                  0xffff0000
+#define IP_REV_1_IP_MJ                  0x0000ff00
+#define IP_REV_1_IP_MM                  0x000000ff
+
+#define IP_REV_2_IP_INT                 0x00ff0000
+#define IP_REV_2_IP_ERR                 0x0000ff00
+#define IP_REV_2_IP_CFG                 0x000000ff
+
+#define MECC_CAP                        0x80000000
+#define MECC_CET                        0x40000000
+#define MECC_SERCNT                     0x00ff0000
+#define MECC_MEMADDR                    0x000001ff
+
+/* shifts */
+#define CFG_UECT_SHIFT                  (31-20)
+#define CFG_ESCBT_SHIFT                 (31-21)
+#define CFG_USFT_SHIFT                  (31-23)
+#define CFG_ITT_SHIFT                   (31-24)
+#define CFG_KFT_SHIFT                   (31-25)
+#define CFG_UFT_SHIFT                   (31-27)
+#define CFG_KSS_SHIFT                   (31-29)
+#define CFG_BYPN_SHIFT                  (31-30)
+#define CFG_S0I_SHIFT                   (31-31)
+
+#define IP_REV_1_IP_ID_SHIFT            (31-15)
+#define IP_REV_1_IP_MJ_SHIFT            (31-23)
+#define IP_REV_1_IP_MM_SHIFT            (31-31)
+
+#define IP_REV_2_IP_INT_SHIFT           (31-15)
+#define IP_REV_2_IP_ERR_SHIFT           (31-23)
+#define IP_REV_2_IP_CFG_SHIFT           (31-31)
+
+#define MECC_CAP_SHIFT                  (31-0)
+#define MECC_CET_SHIFT                  (31-1)
+#define MECC_SERCNT_SHIFT               (31-15)
+#define MECC_MEMADDR_SHIFT              (31-31)
+
+/**************************************************************************//**
+ @Description       RX SC defines
+*//***************************************************************************/
+
+/* masks */
+#define RX_SCCFG_SCI_EN_MASK            0x00000800
+#define RX_SCCFG_RP_MASK                0x00000400
+#define RX_SCCFG_VF_MASK                0x00000300
+#define RX_SCCFG_CO_MASK                0x0000003f
+
+/* shifts */
+#define RX_SCCFG_SCI_EN_SHIFT           (31-20)
+#define RX_SCCFG_RP_SHIFT               (31-21)
+#define RX_SCCFG_VF_SHIFT               (31-23)
+#define RX_SCCFG_CO_SHIFT               (31-31)
+#define RX_SCCFG_CS_SHIFT               (31-7)
+
+/**************************************************************************//**
+ @Description       RX SA defines
+*//***************************************************************************/
+
+/* masks */
+#define RX_SACFG_ACTIVE                 0x80000000
+#define RX_SACFG_AN_MASK                0x00000006
+#define RX_SACFG_EN_MASK                0x00000001
+
+/* shifts */
+#define RX_SACFG_AN_SHIFT               (31-30)
+#define RX_SACFG_EN_SHIFT               (31-31)
+
+/**************************************************************************//**
+ @Description       TX SC defines
+*//***************************************************************************/
+
+/* masks */
+#define TX_SCCFG_AN_MASK                0x000c0000
+#define TX_SCCFG_ASA_MASK               0x00020000
+#define TX_SCCFG_SCE_MASK               0x00010000
+#define TX_SCCFG_CO_MASK                0x00003f00
+#define TX_SCCFG_CE_MASK                0x00000010
+#define TX_SCCFG_PF_MASK                0x00000008
+#define TX_SCCFG_AIS_MASK               0x00000004
+#define TX_SCCFG_UES_MASK               0x00000002
+#define TX_SCCFG_USCB_MASK              0x00000001
+
+/* shifts */
+#define TX_SCCFG_AN_SHIFT               (31-13)
+#define TX_SCCFG_ASA_SHIFT              (31-14)
+#define TX_SCCFG_SCE_SHIFT              (31-15)
+#define TX_SCCFG_CO_SHIFT               (31-23)
+#define TX_SCCFG_CE_SHIFT               (31-27)
+#define TX_SCCFG_PF_SHIFT               (31-28)
+#define TX_SCCFG_AIS_SHIFT              (31-29)
+#define TX_SCCFG_UES_SHIFT              (31-30)
+#define TX_SCCFG_USCB_SHIFT             (31-31)
+#define TX_SCCFG_CS_SHIFT               (31-7)
+
+/**************************************************************************//**
+ @Description       TX SA defines
+*//***************************************************************************/
+
+/* masks */
+#define TX_SACFG_ACTIVE                 0x80000000
+
+
+typedef struct
+{
+    void        (*f_Isr) (t_Handle h_Arg, uint32_t id);
+    t_Handle    h_SrcHandle;
+} t_FmMacsecIntrSrc;
+
+typedef struct
+{
+    e_FmMacsecUnknownSciFrameTreatment  unknownSciTreatMode;
+    bool                                invalidTagsDeliverUncontrolled;
+    bool                                changedTextWithNoEncryptDeliverUncontrolled;
+    bool                                onlyScbIsSetDeliverUncontrolled;
+    bool                                encryptWithNoChangedTextDiscardUncontrolled;
+    e_FmMacsecUntagFrameTreatment       untagTreatMode;
+    uint32_t                            pnExhThr;
+    bool                                keysUnreadable;
+    bool                                byPassMode;
+    bool                                reservedSc0;
+    uint32_t                            sectagOverhead;
+    uint32_t                            mflSubtract;
+} t_FmMacsecDriverParam;
+
+typedef struct
+{
+    t_FmMacsecControllerDriver      fmMacsecControllerDriver;
+    t_Handle                        h_Fm;
+    t_FmMacsecRegs                  *p_FmMacsecRegs;
+    t_Handle                        h_FmMac;            /**< A handle to the FM MAC object  related to */
+    char                            fmMacsecModuleName[MODULE_NAME_SIZE];
+    t_FmMacsecIntrSrc               intrMng[NUM_OF_INTER_MODULE_EVENTS];
+    uint32_t                        events;
+    uint32_t                        exceptions;
+    uint32_t                        userExceptions;
+    t_FmMacsecExceptionsCallback    *f_Exception;       /**< Exception Callback Routine         */
+    t_Handle                        h_App;              /**< A handle to an application layer object; This handle will
+                                                             be passed by the driver upon calling the above callbacks */
+    bool                            rxScTable[NUM_OF_RX_SC];
+    uint32_t                        numRxScAvailable;
+    bool                            txScTable[NUM_OF_TX_SC];
+    uint32_t                        numTxScAvailable;
+    t_Handle                        rxScSpinLock;
+    t_Handle                        txScSpinLock;
+    t_FmMacsecDriverParam           *p_FmMacsecDriverParam;
+} t_FmMacsec;
+
+
+#endif /* __FM_MACSEC_MASTER_H */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_secy.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_secy.c
new file mode 100644
index 0000000..4d8c6e3
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_secy.c
@@ -0,0 +1,908 @@
+/*
+ * Copyright 2008-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_macsec_secy.c
+
+ @Description   FM MACSEC SECY driver routines implementation.
+*//***************************************************************************/
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "xx_ext.h"
+#include "string_ext.h"
+#include "sprint_ext.h"
+
+#include "fm_macsec_secy.h"
+
+
+/****************************************/
+/*       static functions               */
+/****************************************/
+static void FmMacsecSecYExceptionsIsr(t_Handle h_FmMacsecSecY, uint32_t id)
+{
+    t_FmMacsecSecY *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+
+    UNUSED(id);
+    SANITY_CHECK_RETURN(p_FmMacsecSecY, E_INVALID_HANDLE);
+
+    if (p_FmMacsecSecY->exceptions & FM_MACSEC_SECY_EX_FRAME_DISCARDED)
+        p_FmMacsecSecY->f_Exception(p_FmMacsecSecY->h_App, e_FM_MACSEC_SECY_EX_FRAME_DISCARDED);
+}
+
+static void FmMacsecSecYEventsIsr(t_Handle h_FmMacsecSecY, uint32_t id)
+{
+    t_FmMacsecSecY *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+
+    UNUSED(id);
+    SANITY_CHECK_RETURN(p_FmMacsecSecY, E_INVALID_HANDLE);
+
+    if (p_FmMacsecSecY->events & FM_MACSEC_SECY_EV_NEXT_PN)
+        p_FmMacsecSecY->f_Event(p_FmMacsecSecY->h_App, e_FM_MACSEC_SECY_EV_NEXT_PN);
+}
+
+static t_Error CheckFmMacsecSecYParameters(t_FmMacsecSecY *p_FmMacsecSecY)
+{
+    if (!p_FmMacsecSecY->f_Exception)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exceptions callback not provided"));
+
+    if (!p_FmMacsecSecY->f_Event)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Events callback not provided"));
+
+    if (!p_FmMacsecSecY->numOfRxSc)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Num of Rx Scs must be greater than '0'"));
+
+
+    return E_OK;
+}
+
+static t_Handle FmMacsecSecYCreateSc(t_FmMacsecSecY             *p_FmMacsecSecY,
+                                     macsecSCI_t                sci,
+                                     e_FmMacsecSecYCipherSuite  cipherSuite,
+                                     e_ScType                   type)
+{
+    t_SecYSc        *p_ScTable;
+    void            *p_Params;
+    uint32_t        numOfSc,i;
+    t_Error         err = E_OK;
+    t_RxScParams    rxScParams;
+    t_TxScParams    txScParams;
+
+    ASSERT_COND(p_FmMacsecSecY);
+    ASSERT_COND(p_FmMacsecSecY->h_FmMacsec);
+
+    if (type == e_SC_RX)
+    {
+        memset(&rxScParams, 0, sizeof(rxScParams));
+        i                                   = (NUM_OF_RX_SC - 1);
+        p_ScTable                           = p_FmMacsecSecY->p_RxSc;
+        numOfSc                             = p_FmMacsecSecY->numOfRxSc;
+        rxScParams.confidentialityOffset    = p_FmMacsecSecY->confidentialityOffset;
+        rxScParams.replayProtect            = p_FmMacsecSecY->replayProtect;
+        rxScParams.replayWindow             = p_FmMacsecSecY->replayWindow;
+        rxScParams.validateFrames           = p_FmMacsecSecY->validateFrames;
+        rxScParams.cipherSuite              = cipherSuite;
+        p_Params = &rxScParams;
+    }
+    else
+    {
+        memset(&txScParams, 0, sizeof(txScParams));
+        i                                   = (NUM_OF_TX_SC - 1);
+        p_ScTable                           = p_FmMacsecSecY->p_TxSc;
+        numOfSc                             = p_FmMacsecSecY->numOfTxSc;
+        txScParams.sciInsertionMode         = p_FmMacsecSecY->sciInsertionMode;
+        txScParams.protectFrames            = p_FmMacsecSecY->protectFrames;
+        txScParams.confidentialityEnable    = p_FmMacsecSecY->confidentialityEnable;
+        txScParams.confidentialityOffset    = p_FmMacsecSecY->confidentialityOffset;
+        txScParams.cipherSuite              = cipherSuite;
+        p_Params = &txScParams;
+    }
+
+    for (i=0;i<numOfSc;i++)
+        if (!p_ScTable[i].inUse)
+            break;
+    if (i == numOfSc)
+    {
+        REPORT_ERROR(MAJOR, E_FULL, ("FM MACSEC SECY SC"));
+        return NULL;
+    }
+
+    if (type == e_SC_RX)
+    {
+        ((t_RxScParams *)p_Params)->scId = p_ScTable[i].scId;
+        ((t_RxScParams *)p_Params)->sci  = sci;
+        if ((err = FmMacsecCreateRxSc(p_FmMacsecSecY->h_FmMacsec, (t_RxScParams *)p_Params)) != E_OK)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM MACSEC SECY RX SC"));
+            return NULL;
+        }
+    }
+    else
+    {
+        ((t_TxScParams *)p_Params)->scId = p_ScTable[i].scId;
+        ((t_TxScParams *)p_Params)->sci  = sci;
+        if ((err = FmMacsecCreateTxSc(p_FmMacsecSecY->h_FmMacsec, (t_TxScParams *)p_Params)) != E_OK)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM MACSEC SECY TX SC"));
+            return NULL;
+        }
+    }
+
+    p_ScTable[i].inUse = TRUE;
+    return &p_ScTable[i];
+}
+
+static t_Error FmMacsecSecYDeleteSc(t_FmMacsecSecY *p_FmMacsecSecY, t_SecYSc *p_FmSecYSc, e_ScType type)
+{
+    t_Error         err = E_OK;
+
+    ASSERT_COND(p_FmMacsecSecY);
+    ASSERT_COND(p_FmMacsecSecY->h_FmMacsec);
+    ASSERT_COND(p_FmSecYSc);
+
+    if (type == e_SC_RX)
+    {
+        if ((err = FmMacsecDeleteRxSc(p_FmMacsecSecY->h_FmMacsec, p_FmSecYSc->scId)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+    else
+        if ((err = FmMacsecDeleteTxSc(p_FmMacsecSecY->h_FmMacsec, p_FmSecYSc->scId)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+
+    p_FmSecYSc->inUse = FALSE;
+
+    return err;
+}
+
+/****************************************/
+/*       API Init unit functions        */
+/****************************************/
+t_Handle FM_MACSEC_SECY_Config(t_FmMacsecSecYParams *p_FmMacsecSecYParam)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY;
+
+    /* Allocate FM MACSEC structure */
+    p_FmMacsecSecY = (t_FmMacsecSecY *) XX_Malloc(sizeof(t_FmMacsecSecY));
+    if (!p_FmMacsecSecY)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM MACSEC SECY driver structure"));
+        return NULL;
+    }
+    memset(p_FmMacsecSecY, 0, sizeof(t_FmMacsecSecY));
+
+    /* Allocate the FM MACSEC driver's parameters structure */
+    p_FmMacsecSecY->p_FmMacsecSecYDriverParam = (t_FmMacsecSecYDriverParam *)XX_Malloc(sizeof(t_FmMacsecSecYDriverParam));
+    if (!p_FmMacsecSecY->p_FmMacsecSecYDriverParam)
+    {
+        XX_Free(p_FmMacsecSecY);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM MACSEC SECY driver parameters"));
+        return NULL;
+    }
+    memset(p_FmMacsecSecY->p_FmMacsecSecYDriverParam, 0, sizeof(t_FmMacsecSecYDriverParam));
+
+    /* Initialize FM MACSEC SECY parameters which will be kept by the driver */
+    p_FmMacsecSecY->h_FmMacsec              = p_FmMacsecSecYParam->h_FmMacsec;
+    p_FmMacsecSecY->f_Event                 = p_FmMacsecSecYParam->f_Event;
+    p_FmMacsecSecY->f_Exception             = p_FmMacsecSecYParam->f_Exception;
+    p_FmMacsecSecY->h_App                   = p_FmMacsecSecYParam->h_App;
+    p_FmMacsecSecY->confidentialityEnable   = DEFAULT_confidentialityEnable;
+    p_FmMacsecSecY->confidentialityOffset   = DEFAULT_confidentialityOffset;
+    p_FmMacsecSecY->validateFrames          = DEFAULT_validateFrames;
+    p_FmMacsecSecY->replayProtect           = DEFAULT_replayEnable;
+    p_FmMacsecSecY->replayWindow            = DEFAULT_replayWindow;
+    p_FmMacsecSecY->protectFrames           = DEFAULT_protectFrames;
+    p_FmMacsecSecY->sciInsertionMode        = DEFAULT_sciInsertionMode;
+    p_FmMacsecSecY->isPointToPoint          = DEFAULT_ptp;
+    p_FmMacsecSecY->numOfRxSc               = p_FmMacsecSecYParam->numReceiveChannels;
+    p_FmMacsecSecY->numOfTxSc               = DEFAULT_numOfTxSc;
+    p_FmMacsecSecY->exceptions              = DEFAULT_exceptions;
+    p_FmMacsecSecY->events                  = DEFAULT_events;
+
+    memcpy(&p_FmMacsecSecY->p_FmMacsecSecYDriverParam->txScParams,
+           &p_FmMacsecSecYParam->txScParams,
+           sizeof(t_FmMacsecSecYSCParams));
+    return p_FmMacsecSecY;
+}
+
+t_Error FM_MACSEC_SECY_Init(t_Handle h_FmMacsecSecY)
+{
+    t_FmMacsecSecY              *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_FmMacsecSecYDriverParam   *p_FmMacsecSecYDriverParam = NULL;
+    uint32_t                    rxScIds[NUM_OF_RX_SC], txScIds[NUM_OF_TX_SC], i, j;
+    t_Error                     err;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_HANDLE);
+
+    CHECK_INIT_PARAMETERS(p_FmMacsecSecY, CheckFmMacsecSecYParameters);
+
+    p_FmMacsecSecYDriverParam = p_FmMacsecSecY->p_FmMacsecSecYDriverParam;
+
+    if ((p_FmMacsecSecY->isPointToPoint) &&
+        ((err = FmMacsecSetPTP(p_FmMacsecSecY->h_FmMacsec, TRUE)) != E_OK))
+        RETURN_ERROR(MAJOR, err, ("Can't set Poin-to-Point"));
+
+    /* Rx Sc Allocation */
+    p_FmMacsecSecY->p_RxSc = (t_SecYSc *)XX_Malloc(sizeof(t_SecYSc) * p_FmMacsecSecY->numOfRxSc);
+    if (!p_FmMacsecSecY->p_RxSc)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("FM MACSEC SECY RX SC"));
+    memset(p_FmMacsecSecY->p_RxSc, 0, sizeof(t_SecYSc) * p_FmMacsecSecY->numOfRxSc);
+    if ((err = FmMacsecAllocScs(p_FmMacsecSecY->h_FmMacsec, e_SC_RX, p_FmMacsecSecY->isPointToPoint, p_FmMacsecSecY->numOfRxSc, rxScIds)) != E_OK)
+    {
+        if (p_FmMacsecSecY->p_TxSc)
+            XX_Free(p_FmMacsecSecY->p_TxSc);
+        if (p_FmMacsecSecY->p_RxSc)
+            XX_Free(p_FmMacsecSecY->p_RxSc);
+        return ERROR_CODE(err);
+    }
+    for (i=0; i<p_FmMacsecSecY->numOfRxSc; i++)
+    {
+        p_FmMacsecSecY->p_RxSc[i].scId  = rxScIds[i];
+        p_FmMacsecSecY->p_RxSc[i].type  = e_SC_RX;
+        for (j=0; j<MAX_NUM_OF_SA_PER_SC;j++)
+            p_FmMacsecSecY->p_RxSc[i].sa[j].saId = (e_ScSaId)SECY_AN_FREE_VALUE;
+    }
+
+    /* Tx Sc Allocation */
+    p_FmMacsecSecY->p_TxSc = (t_SecYSc *)XX_Malloc(sizeof(t_SecYSc) * p_FmMacsecSecY->numOfTxSc);
+    if (!p_FmMacsecSecY->p_TxSc)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("FM MACSEC SECY TX SC"));
+    memset(p_FmMacsecSecY->p_TxSc, 0, sizeof(t_SecYSc) * p_FmMacsecSecY->numOfTxSc);
+
+    if ((err = FmMacsecAllocScs(p_FmMacsecSecY->h_FmMacsec, e_SC_TX, p_FmMacsecSecY->isPointToPoint, p_FmMacsecSecY->numOfTxSc, txScIds)) != E_OK)
+    {
+        if (p_FmMacsecSecY->p_TxSc)
+            XX_Free(p_FmMacsecSecY->p_TxSc);
+        if (p_FmMacsecSecY->p_RxSc)
+            XX_Free(p_FmMacsecSecY->p_RxSc);
+        return ERROR_CODE(err);
+    }
+    for (i=0; i<p_FmMacsecSecY->numOfTxSc; i++)
+    {
+        p_FmMacsecSecY->p_TxSc[i].scId  = txScIds[i];
+        p_FmMacsecSecY->p_TxSc[i].type  = e_SC_TX;
+        for (j=0; j<MAX_NUM_OF_SA_PER_SC;j++)
+            p_FmMacsecSecY->p_TxSc[i].sa[j].saId = (e_ScSaId)SECY_AN_FREE_VALUE;
+        FmMacsecRegisterIntr(p_FmMacsecSecY->h_FmMacsec,
+                             e_FM_MACSEC_MOD_SC_TX,
+                             (uint8_t)txScIds[i],
+                             e_FM_INTR_TYPE_ERR,
+                             FmMacsecSecYExceptionsIsr,
+                             p_FmMacsecSecY);
+        FmMacsecRegisterIntr(p_FmMacsecSecY->h_FmMacsec,
+                             e_FM_MACSEC_MOD_SC_TX,
+                             (uint8_t)txScIds[i],
+                             e_FM_INTR_TYPE_NORMAL,
+                             FmMacsecSecYEventsIsr,
+                             p_FmMacsecSecY);
+
+        if (p_FmMacsecSecY->exceptions & FM_MACSEC_SECY_EX_FRAME_DISCARDED)
+            FmMacsecSetException(p_FmMacsecSecY->h_FmMacsec, e_FM_MACSEC_EX_TX_SC, txScIds[i], TRUE);
+        if (p_FmMacsecSecY->events & FM_MACSEC_SECY_EV_NEXT_PN)
+            FmMacsecSetEvent(p_FmMacsecSecY->h_FmMacsec, e_FM_MACSEC_EV_TX_SC_NEXT_PN, txScIds[i], TRUE);
+    }
+
+    FmMacsecSecYCreateSc(p_FmMacsecSecY,
+                         p_FmMacsecSecYDriverParam->txScParams.sci,
+                         p_FmMacsecSecYDriverParam->txScParams.cipherSuite,
+                         e_SC_TX);
+    XX_Free(p_FmMacsecSecYDriverParam);
+    p_FmMacsecSecY->p_FmMacsecSecYDriverParam = NULL;
+
+    return E_OK;
+}
+
+t_Error FM_MACSEC_SECY_Free(t_Handle h_FmMacsecSecY)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_Error         err             = E_OK;
+    uint32_t        rxScIds[NUM_OF_RX_SC], txScIds[NUM_OF_TX_SC], i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+
+    if (p_FmMacsecSecY->isPointToPoint)
+        FmMacsecSetPTP(p_FmMacsecSecY->h_FmMacsec, FALSE);
+    if (p_FmMacsecSecY->p_RxSc)
+    {
+        for (i=0; i<p_FmMacsecSecY->numOfRxSc; i++)
+            rxScIds[i] = p_FmMacsecSecY->p_RxSc[i].scId;
+        if ((err = FmMacsecFreeScs(p_FmMacsecSecY->h_FmMacsec, e_SC_RX, p_FmMacsecSecY->numOfRxSc, rxScIds)) != E_OK)
+            return ERROR_CODE(err);
+        XX_Free(p_FmMacsecSecY->p_RxSc);
+    }
+    if (p_FmMacsecSecY->p_TxSc)
+    {
+       FmMacsecSecYDeleteSc(p_FmMacsecSecY, &p_FmMacsecSecY->p_TxSc[0], e_SC_TX);
+
+       for (i=0; i<p_FmMacsecSecY->numOfTxSc; i++) {
+             txScIds[i] = p_FmMacsecSecY->p_TxSc[i].scId;
+            FmMacsecUnregisterIntr(p_FmMacsecSecY->h_FmMacsec,
+                                 e_FM_MACSEC_MOD_SC_TX,
+                                 (uint8_t)txScIds[i],
+                                 e_FM_INTR_TYPE_ERR);
+            FmMacsecUnregisterIntr(p_FmMacsecSecY->h_FmMacsec,
+                                 e_FM_MACSEC_MOD_SC_TX,
+                                 (uint8_t)txScIds[i],
+                                 e_FM_INTR_TYPE_NORMAL);
+
+            if (p_FmMacsecSecY->exceptions & FM_MACSEC_SECY_EX_FRAME_DISCARDED)
+                FmMacsecSetException(p_FmMacsecSecY->h_FmMacsec, e_FM_MACSEC_EX_TX_SC, txScIds[i], FALSE);
+            if (p_FmMacsecSecY->events & FM_MACSEC_SECY_EV_NEXT_PN)
+                FmMacsecSetEvent(p_FmMacsecSecY->h_FmMacsec, e_FM_MACSEC_EV_TX_SC_NEXT_PN, txScIds[i], FALSE);
+       }
+
+        if ((err = FmMacsecFreeScs(p_FmMacsecSecY->h_FmMacsec, e_SC_TX, p_FmMacsecSecY->numOfTxSc, txScIds)) != E_OK)
+            return ERROR_CODE(err);
+        XX_Free(p_FmMacsecSecY->p_TxSc);
+    }
+
+    XX_Free(p_FmMacsecSecY);
+
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_ConfigSciInsertionMode(t_Handle h_FmMacsecSecY, e_FmMacsecSciInsertionMode sciInsertionMode)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+
+    p_FmMacsecSecY->sciInsertionMode = sciInsertionMode;
+
+    return E_OK;
+}
+
+t_Error FM_MACSEC_SECY_ConfigProtectFrames(t_Handle h_FmMacsecSecY, bool protectFrames)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+
+    p_FmMacsecSecY->protectFrames = protectFrames;
+
+    return E_OK;
+}
+
+t_Error FM_MACSEC_SECY_ConfigReplayWindow(t_Handle h_FmMacsecSecY, bool replayProtect, uint32_t replayWindow)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+
+    p_FmMacsecSecY->replayProtect   = replayProtect;
+    p_FmMacsecSecY->replayWindow    = replayWindow;
+
+    return E_OK;
+}
+
+t_Error FM_MACSEC_SECY_ConfigValidationMode(t_Handle h_FmMacsecSecY, e_FmMacsecValidFrameBehavior validateFrames)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+
+    p_FmMacsecSecY->validateFrames = validateFrames;
+
+    return E_OK;
+}
+
+t_Error FM_MACSEC_SECY_ConfigConfidentiality(t_Handle h_FmMacsecSecY, bool confidentialityEnable, uint16_t confidentialityOffset)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+
+    p_FmMacsecSecY->confidentialityEnable = confidentialityEnable;
+    p_FmMacsecSecY->confidentialityOffset = confidentialityOffset;
+
+    return E_OK;
+}
+
+t_Error FM_MACSEC_SECY_ConfigPointToPoint(t_Handle h_FmMacsecSecY)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+
+    p_FmMacsecSecY->numOfRxSc = 1;
+    p_FmMacsecSecY->isPointToPoint = TRUE;
+    p_FmMacsecSecY->sciInsertionMode = e_FM_MACSEC_SCI_INSERTION_MODE_IMPLICT_PTP;
+
+    return E_OK;
+}
+
+t_Error FM_MACSEC_SECY_ConfigException(t_Handle h_FmMacsecSecY, e_FmMacsecSecYExceptions exception, bool enable)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    uint32_t        bitMask         = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+
+    GET_EXCEPTION_FLAG(bitMask, exception);
+    if (bitMask)
+    {
+        if (enable)
+            p_FmMacsecSecY->exceptions |= bitMask;
+        else
+            p_FmMacsecSecY->exceptions &= ~bitMask;
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    return E_OK;
+}
+
+t_Error FM_MACSEC_SECY_ConfigEvent(t_Handle h_FmMacsecSecY, e_FmMacsecSecYEvents event, bool enable)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    uint32_t        bitMask         = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+
+    GET_EVENT_FLAG(bitMask, event);
+    if (bitMask)
+    {
+        if (enable)
+            p_FmMacsecSecY->events |= bitMask;
+        else
+            p_FmMacsecSecY->events &= ~bitMask;
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined event"));
+
+    return E_OK;
+}
+
+t_Handle FM_MACSEC_SECY_CreateRxSc(t_Handle h_FmMacsecSecY, t_FmMacsecSecYSCParams *p_ScParams)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmMacsecSecY, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_ScParams, E_NULL_POINTER, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE, NULL);
+
+    return FmMacsecSecYCreateSc(p_FmMacsecSecY, p_ScParams->sci, p_ScParams->cipherSuite, e_SC_RX);
+}
+
+t_Error FM_MACSEC_SECY_DeleteRxSc(t_Handle h_FmMacsecSecY, t_Handle h_Sc)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc     = (t_SecYSc *)h_Sc;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+
+    return FmMacsecSecYDeleteSc(p_FmMacsecSecY, p_FmSecYSc, e_SC_RX);
+}
+
+t_Error FM_MACSEC_SECY_CreateRxSa(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an, uint32_t lowestPn, macsecSAKey_t key)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc     = (t_SecYSc *)h_Sc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(an < MAX_NUM_OF_SA_PER_SC, E_INVALID_STATE);
+
+    if (p_FmSecYSc->sa[an].saId != SECY_AN_FREE_VALUE)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("An %d is already assigned",an));
+
+    if ((err = FmMacsecCreateRxSa(p_FmMacsecSecY->h_FmMacsec, p_FmSecYSc->scId, (e_ScSaId)p_FmSecYSc->numOfSa, an, lowestPn, key)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    p_FmSecYSc->sa[an].saId = (e_ScSaId)p_FmSecYSc->numOfSa++;
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_DeleteRxSa(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc     = (t_SecYSc *)h_Sc;
+    t_Error         err             = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(an < MAX_NUM_OF_SA_PER_SC, E_INVALID_STATE);
+
+    if (p_FmSecYSc->sa[an].saId == SECY_AN_FREE_VALUE)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("An %d is already deleted",an));
+
+    if ((err = FmMacsecDeleteRxSa(p_FmMacsecSecY->h_FmMacsec, p_FmSecYSc->scId, p_FmSecYSc->sa[an].saId)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    p_FmSecYSc->numOfSa--;
+    p_FmSecYSc->sa[an].saId = (e_ScSaId)SECY_AN_FREE_VALUE;
+    /* TODO - check if statistics need to be read*/
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_RxSaEnableReceive(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc     = (t_SecYSc *)h_Sc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(an < MAX_NUM_OF_SA_PER_SC, E_INVALID_STATE);
+
+    if (p_FmSecYSc->sa[an].saId == SECY_AN_FREE_VALUE)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("An %d is not configured",an));
+
+    if ((err = FmMacsecRxSaSetReceive(p_FmMacsecSecY->h_FmMacsec,p_FmSecYSc->scId, p_FmSecYSc->sa[an].saId, TRUE)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    p_FmSecYSc->sa[an].active = TRUE;
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_RxSaDisableReceive(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc     = (t_SecYSc *)h_Sc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(an < MAX_NUM_OF_SA_PER_SC, E_INVALID_STATE);
+
+    if (p_FmSecYSc->sa[an].saId == SECY_AN_FREE_VALUE)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("An %d is not configured",an));
+
+    if ((err = FmMacsecRxSaSetReceive(p_FmMacsecSecY->h_FmMacsec,p_FmSecYSc->scId, p_FmSecYSc->sa[an].saId, FALSE)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    p_FmSecYSc->sa[an].active = FALSE;
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_RxSaUpdateNextPn(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an, uint32_t updtNextPN)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc     = (t_SecYSc *)h_Sc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(an < MAX_NUM_OF_SA_PER_SC, E_INVALID_STATE);
+
+    if (p_FmSecYSc->sa[an].saId == SECY_AN_FREE_VALUE)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("An %d is not configured",an));
+
+    if ((err = FmMacsecRxSaUpdateNextPn(p_FmMacsecSecY->h_FmMacsec,p_FmSecYSc->scId, p_FmSecYSc->sa[an].saId, updtNextPN)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_RxSaUpdateLowestPn(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an, uint32_t updtLowestPN)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc     = (t_SecYSc *)h_Sc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(an < MAX_NUM_OF_SA_PER_SC, E_INVALID_STATE);
+
+    if (p_FmSecYSc->sa[an].saId == SECY_AN_FREE_VALUE)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("An %d is not configured",an));
+
+    if ((err = FmMacsecRxSaUpdateLowestPn(p_FmMacsecSecY->h_FmMacsec,p_FmSecYSc->scId, p_FmSecYSc->sa[an].saId, updtLowestPN)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_RxSaModifyKey(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an, macsecSAKey_t key)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc     = (t_SecYSc *)h_Sc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(an < MAX_NUM_OF_SA_PER_SC, E_INVALID_STATE);
+
+    if (p_FmSecYSc->sa[an].saId == SECY_AN_FREE_VALUE)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("An %d is not configured",an));
+
+    if (p_FmSecYSc->sa[an].active)
+        if ((err = FmMacsecRxSaSetReceive(p_FmMacsecSecY->h_FmMacsec, p_FmSecYSc->scId, p_FmSecYSc->sa[an].saId, FALSE)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+
+    /* TODO - statistics should be read */
+
+    if ((err = FmMacsecCreateRxSa(p_FmMacsecSecY->h_FmMacsec, p_FmSecYSc->scId, p_FmSecYSc->sa[an].saId, an, 1, key)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    if (p_FmSecYSc->sa[an].active)
+        if ((err = FmMacsecRxSaSetReceive(p_FmMacsecSecY->h_FmMacsec, p_FmSecYSc->scId, p_FmSecYSc->sa[an].saId, TRUE)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    return err;
+}
+
+#if 0
+t_Handle FM_MACSEC_SECY_CreateTxSc(t_Handle h_FmMacsecSecY, macsecSCI_t sci)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmMacsecSecY, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE, NULL);
+
+    return FmMacsecSecYCreateSc(p_FmMacsecSecY, sci, e_SC_TX);
+}
+
+t_Error FM_MACSEC_SECY_DeleteTxSc(t_Handle h_FmMacsecSecY, t_Handle h_Sc)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc = (t_SecYSc *)h_Sc;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+
+    return FmMacsecSecYDeleteSc(p_FmMacsecSecY, p_FmSecYSc, e_SC_TX);
+}
+#endif /* 0 */
+
+t_Error FM_MACSEC_SECY_CreateTxSa(t_Handle h_FmMacsecSecY, macsecAN_t an, macsecSAKey_t key)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    p_FmSecYSc = &p_FmMacsecSecY->p_TxSc[0];
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(an < MAX_NUM_OF_SA_PER_SC, E_INVALID_STATE);
+
+    if (p_FmSecYSc->sa[an].saId != SECY_AN_FREE_VALUE)
+        RETURN_ERROR(MINOR, err, ("An %d is already assigned",an));
+
+    if ((err = FmMacsecCreateTxSa(p_FmMacsecSecY->h_FmMacsec,p_FmSecYSc->scId, (e_ScSaId)p_FmSecYSc->numOfSa, key)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    p_FmSecYSc->sa[an].saId = (e_ScSaId)p_FmSecYSc->numOfSa++;
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_DeleteTxSa(t_Handle h_FmMacsecSecY, macsecAN_t an)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    p_FmSecYSc = &p_FmMacsecSecY->p_TxSc[0];
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(an < MAX_NUM_OF_SA_PER_SC, E_INVALID_STATE);
+
+    if (p_FmSecYSc->sa[an].saId == SECY_AN_FREE_VALUE)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("An %d is already deleted",an));
+
+    if ((err = FmMacsecDeleteTxSa(p_FmMacsecSecY->h_FmMacsec, p_FmSecYSc->scId, p_FmSecYSc->sa[an].saId)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    p_FmSecYSc->numOfSa--;
+    p_FmSecYSc->sa[an].saId = (e_ScSaId)SECY_AN_FREE_VALUE;
+    /* TODO - check if statistics need to be read*/
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_TxSaModifyKey(t_Handle h_FmMacsecSecY, macsecAN_t nextActiveAn, macsecSAKey_t key)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc;
+    macsecAN_t      currentAn;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    p_FmSecYSc = &p_FmMacsecSecY->p_TxSc[0];
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(nextActiveAn < MAX_NUM_OF_SA_PER_SC, E_INVALID_STATE);
+
+    if ((err = FmMacsecTxSaGetActive(p_FmMacsecSecY->h_FmMacsec,
+                                     p_FmSecYSc->scId,
+                                     &currentAn)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    if ((err = FmMacsecTxSaSetActive(p_FmMacsecSecY->h_FmMacsec,
+                                     p_FmSecYSc->scId,
+                                     p_FmSecYSc->sa[nextActiveAn].saId,
+                                     nextActiveAn)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    /* TODO - statistics should be read */
+
+    if ((err = FmMacsecCreateTxSa(p_FmMacsecSecY->h_FmMacsec, p_FmSecYSc->scId, p_FmSecYSc->sa[currentAn].saId, key)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_TxSaSetActive(t_Handle h_FmMacsecSecY, macsecAN_t an)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    p_FmSecYSc = &p_FmMacsecSecY->p_TxSc[0];
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(an < MAX_NUM_OF_SA_PER_SC, E_INVALID_STATE);
+
+    if (p_FmSecYSc->sa[an].saId == SECY_AN_FREE_VALUE)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("An %d is not configured",an));
+
+    if ((err = FmMacsecTxSaSetActive(p_FmMacsecSecY->h_FmMacsec,
+                                     p_FmSecYSc->scId,
+                                     p_FmSecYSc->sa[an].saId,
+                                     an)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_TxSaGetActive(t_Handle h_FmMacsecSecY, macsecAN_t *p_An)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    p_FmSecYSc = &p_FmMacsecSecY->p_TxSc[0];
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_An, E_INVALID_HANDLE);
+
+    if ((err = FmMacsecTxSaGetActive(p_FmMacsecSecY->h_FmMacsec,
+                                     p_FmSecYSc->scId,
+                                     p_An)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_GetRxScPhysId(t_Handle h_FmMacsecSecY, t_Handle h_Sc, uint32_t *p_ScPhysId)
+{
+    t_SecYSc        *p_FmSecYSc = (t_SecYSc *)h_Sc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(((t_FmMacsecSecY *)h_FmMacsecSecY)->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!((t_FmMacsecSecY *)h_FmMacsecSecY)->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+#ifdef DISABLE_SANITY_CHECKS
+    UNUSED(h_FmMacsecSecY);
+#endif /* DISABLE_SANITY_CHECKS */
+
+    *p_ScPhysId = p_FmSecYSc->scId;
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_GetTxScPhysId(t_Handle h_FmMacsecSecY, uint32_t *p_ScPhysId)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    p_FmSecYSc = &p_FmMacsecSecY->p_TxSc[0];
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+
+    *p_ScPhysId = p_FmSecYSc->scId;
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_SetException(t_Handle h_FmMacsecSecY, e_FmMacsecExceptions exception, bool enable)
+{
+   UNUSED(h_FmMacsecSecY);UNUSED(exception);UNUSED(enable);
+   RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_SECY_SetEvent(t_Handle h_FmMacsecSecY, e_FmMacsecSecYEvents event, bool enable)
+{
+    UNUSED(h_FmMacsecSecY);UNUSED(event);UNUSED(enable);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_SECY_GetStatistics(t_Handle h_FmMacsecSecY, t_FmMacsecSecYStatistics *p_Statistics)
+{
+    UNUSED(h_FmMacsecSecY);UNUSED(p_Statistics);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_SECY_RxScGetStatistics(t_Handle h_FmMacsecSecY, t_Handle h_Sc, t_FmMacsecSecYRxScStatistics *p_Statistics)
+{
+    UNUSED(h_FmMacsecSecY);UNUSED(h_Sc);UNUSED(p_Statistics);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_SECY_RxSaGetStatistics(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an, t_FmMacsecSecYRxSaStatistics *p_Statistics)
+{
+    UNUSED(h_FmMacsecSecY);UNUSED(h_Sc);UNUSED(an);UNUSED(p_Statistics);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_SECY_TxScGetStatistics(t_Handle h_FmMacsecSecY, t_FmMacsecSecYTxScStatistics *p_Statistics)
+{
+    UNUSED(h_FmMacsecSecY);UNUSED(p_Statistics);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_SECY_TxSaGetStatistics(t_Handle h_FmMacsecSecY, macsecAN_t an, t_FmMacsecSecYTxSaStatistics *p_Statistics)
+{
+    UNUSED(h_FmMacsecSecY);UNUSED(an);UNUSED(p_Statistics);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_secy.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_secy.h
new file mode 100644
index 0000000..0cf624e
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_secy.h
@@ -0,0 +1,144 @@
+/*
+ * Copyright 2008-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_macsec_secy.h
+
+ @Description   FM MACSEC SecY internal structures and definitions.
+*//***************************************************************************/
+#ifndef __FM_MACSEC_SECY_H
+#define __FM_MACSEC_SECY_H
+
+#include "error_ext.h"
+#include "std_ext.h"
+
+#include "fm_macsec.h"
+
+
+/**************************************************************************//**
+ @Description       Exceptions
+*//***************************************************************************/
+
+#define FM_MACSEC_SECY_EX_FRAME_DISCARDED           0x80000000
+
+#define GET_EXCEPTION_FLAG(bitMask, exception)  switch (exception){     \
+    case e_FM_MACSEC_SECY_EX_FRAME_DISCARDED:                           \
+        bitMask = FM_MACSEC_SECY_EX_FRAME_DISCARDED; break;             \
+    default: bitMask = 0;break;}
+
+/**************************************************************************//**
+ @Description       Events
+*//***************************************************************************/
+
+#define FM_MACSEC_SECY_EV_NEXT_PN                        0x80000000
+
+#define GET_EVENT_FLAG(bitMask, event)          switch (event){     \
+    case e_FM_MACSEC_SECY_EV_NEXT_PN:                               \
+        bitMask = FM_MACSEC_SECY_EV_NEXT_PN; break;                 \
+    default: bitMask = 0;break;}
+
+/**************************************************************************//**
+ @Description       Defaults
+*//***************************************************************************/
+
+#define DEFAULT_exceptions                  (FM_MACSEC_SECY_EX_FRAME_DISCARDED)
+#define DEFAULT_events                      (FM_MACSEC_SECY_EV_NEXT_PN)
+#define DEFAULT_numOfTxSc                   1
+#define DEFAULT_confidentialityEnable       FALSE
+#define DEFAULT_confidentialityOffset       0
+#define DEFAULT_sciInsertionMode            e_FM_MACSEC_SCI_INSERTION_MODE_EXPLICIT_SECTAG
+#define DEFAULT_validateFrames              e_FM_MACSEC_VALID_FRAME_BEHAVIOR_STRICT
+#define DEFAULT_replayEnable                FALSE
+#define DEFAULT_replayWindow                0
+#define DEFAULT_protectFrames               TRUE
+#define DEFAULT_ptp                         FALSE
+
+/**************************************************************************//**
+ @Description       General defines
+*//***************************************************************************/
+
+#define SECY_AN_FREE_VALUE              MAX_NUM_OF_SA_PER_SC
+
+
+typedef struct {
+    e_ScSaId                            saId;
+    bool                                active;
+    union {
+        t_FmMacsecSecYRxSaStatistics    rxSaStatistics;
+        t_FmMacsecSecYTxSaStatistics    txSaStatistics;
+    };
+} t_SecYSa;
+
+typedef struct {
+    bool                                inUse;
+    uint32_t                            scId;
+    e_ScType                            type;
+    uint8_t                             numOfSa;
+    t_SecYSa                            sa[MAX_NUM_OF_SA_PER_SC];
+    union {
+        t_FmMacsecSecYRxScStatistics    rxScStatistics;
+        t_FmMacsecSecYTxScStatistics    txScStatistics;
+    };
+} t_SecYSc;
+
+typedef struct {
+    t_FmMacsecSecYSCParams              txScParams;             /**< Tx SC Params */
+} t_FmMacsecSecYDriverParam;
+
+typedef struct {
+    t_Handle                            h_FmMacsec;
+    bool                                confidentialityEnable;  /**< TRUE  - confidentiality protection and integrity protection
+                                                                     FALSE - no confidentiality protection, only integrity protection*/
+    uint16_t                            confidentialityOffset;  /**< The number of initial octets of each MSDU without confidentiality protection
+                                                                     common values are 0, 30, and 50 */
+    bool                                replayProtect;          /**< replay protection function mode */
+    uint32_t                            replayWindow;           /**< the size of the replay window */
+    e_FmMacsecValidFrameBehavior        validateFrames;         /**< validation function mode */
+    e_FmMacsecSciInsertionMode          sciInsertionMode;
+    bool                                protectFrames;
+    bool                                isPointToPoint;
+    e_FmMacsecSecYCipherSuite           cipherSuite;            /**< Cipher suite to be used for this SecY */
+    uint32_t                            numOfRxSc;              /**< Number of receive channels */
+    uint32_t                            numOfTxSc;              /**< Number of transmit channels */
+    t_SecYSc                            *p_RxSc;
+    t_SecYSc                            *p_TxSc;
+    uint32_t                            events;
+    uint32_t                            exceptions;
+    t_FmMacsecSecYExceptionsCallback    *f_Exception;           /**< TODO */
+    t_FmMacsecSecYEventsCallback        *f_Event;               /**< TODO */
+    t_Handle                            h_App;
+    t_FmMacsecSecYStatistics            statistics;
+    t_FmMacsecSecYDriverParam           *p_FmMacsecSecYDriverParam;
+} t_FmMacsecSecY;
+
+
+#endif /* __FM_MACSEC_SECY_H */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Makefile b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Makefile
index e02b57e..7fbf838 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Makefile
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Makefile
@@ -1,13 +1,13 @@
 #
 # Makefile for the Freescale Ethernet controllers
 #
-EXTRA_CFLAGS           += -DVERSION=\"\"
+ccflags-y           += -DVERSION=\"\"
 #
 #Include netcomm SW specific definitions
 include $(srctree)/drivers/net/ethernet/freescale/fman/ncsw_config.mk
 NCSW_FM_INC = $(srctree)/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc
 
-EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+ccflags-y += -I$(NCSW_FM_INC)
 
 
 obj-y		+= fsl-ncsw-PFM1.o
@@ -20,3 +20,4 @@ obj-y		+= SP/
 obj-y		+= Port/
 obj-y		+= HC/
 obj-y		+= Rtc/
+obj-y		+= MACSEC/
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/Makefile b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/Makefile
index 0fde16a..74531f9 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/Makefile
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/Makefile
@@ -1,22 +1,26 @@
 #
 # Makefile for the Freescale Ethernet controllers
 #
-EXTRA_CFLAGS           += -DVERSION=\"\"
+ccflags-y           += -DVERSION=\"\"
 #
 #Include netcomm SW specific definitions
 include $(srctree)/drivers/net/ethernet/freescale/fman/ncsw_config.mk
 
 NCSW_FM_INC = $(srctree)/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc
 
-EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+ccflags-y += -I$(NCSW_FM_INC)
 
 obj-y		+= fsl-ncsw-Pcd.o
 
 fsl-ncsw-Pcd-objs	:= fman_kg.o fman_prs.o fm_cc.o fm_kg.o fm_pcd.o fm_plcr.o fm_prs.o fm_manip.o
 
-ifeq ($(CONFIG_FMAN_T4240),y)
+ifeq ($(CONFIG_FMAN_V3H),y)
 fsl-ncsw-Pcd-objs	+= fm_replic.o
 endif
+ifeq ($(CONFIG_FMAN_V3L),y)
+fsl-ncsw-Pcd-objs       += fm_replic.o
+endif
 ifeq ($(CONFIG_FMAN_LS1043),y)
-fsl-ncsw-Pcd-objs	+= fm_replic.o
+fsl-ncsw-Pcd-objs       += fm_replic.o
 endif
+
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.c
index 5f2028e..863b61d 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.c
@@ -35,7 +35,7 @@
  @File          fm_cc.c
 
  @Description   FM Coarse Classifier implementation
-*//***************************************************************************/
+ *//***************************************************************************/
 #include "std_ext.h"
 #include "error_ext.h"
 #include "string_ext.h"
@@ -49,7 +49,6 @@
 #include "fm_cc.h"
 #include "crc64.h"
 
-
 /****************************************/
 /*       static functions               */
 /****************************************/
@@ -57,7 +56,7 @@
 
 static t_Error CcRootTryLock(t_Handle h_FmPcdCcTree)
 {
-    t_FmPcdCcTree   *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
 
     ASSERT_COND(h_FmPcdCcTree);
 
@@ -69,16 +68,16 @@ static t_Error CcRootTryLock(t_Handle h_FmPcdCcTree)
 
 static void CcRootReleaseLock(t_Handle h_FmPcdCcTree)
 {
-    t_FmPcdCcTree   *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
 
     ASSERT_COND(h_FmPcdCcTree);
 
     FmPcdLockUnlock(p_FmPcdCcTree->p_Lock);
 }
 
-static void  UpdateNodeOwner(t_FmPcdCcNode *p_CcNode, bool add)
+static void UpdateNodeOwner(t_FmPcdCcNode *p_CcNode, bool add)
 {
-    uint32_t    intFlags;
+    uint32_t intFlags;
 
     ASSERT_COND(p_CcNode);
 
@@ -97,8 +96,8 @@ static void  UpdateNodeOwner(t_FmPcdCcNode *p_CcNode, bool add)
 
 static __inline__ t_FmPcdStatsObj* DequeueStatsObj(t_List *p_List)
 {
-    t_FmPcdStatsObj  *p_StatsObj = NULL;
-    t_List           *p_Next;
+    t_FmPcdStatsObj *p_StatsObj = NULL;
+    t_List *p_Next;
 
     if (!LIST_IsEmpty(p_List))
     {
@@ -111,16 +110,15 @@ static __inline__ t_FmPcdStatsObj* DequeueStatsObj(t_List *p_List)
     return p_StatsObj;
 }
 
-static __inline__ void EnqueueStatsObj(t_List              *p_List,
-                                       t_FmPcdStatsObj     *p_StatsObj)
+static __inline__ void EnqueueStatsObj(t_List *p_List,
+                                       t_FmPcdStatsObj *p_StatsObj)
 {
     LIST_AddToTail(&p_StatsObj->node, p_List);
 }
 
-static void FreeStatObjects(t_List     *p_List,
-                            t_Handle   h_FmMuram)
+static void FreeStatObjects(t_List *p_List, t_Handle h_FmMuram)
 {
-    t_FmPcdStatsObj     *p_StatsObj;
+    t_FmPcdStatsObj *p_StatsObj;
 
     while (!LIST_IsEmpty(p_List))
     {
@@ -136,13 +134,13 @@ static void FreeStatObjects(t_List     *p_List,
 
 static t_FmPcdStatsObj* GetStatsObj(t_FmPcdCcNode *p_CcNode)
 {
-    t_FmPcdStatsObj*    p_StatsObj;
-    t_Handle            h_FmMuram;
+    t_FmPcdStatsObj* p_StatsObj;
+    t_Handle h_FmMuram;
 
     ASSERT_COND(p_CcNode);
 
     /* If 'maxNumOfKeys' was passed, all statistics object were preallocated
-       upon node initialization */
+     upon node initialization */
     if (p_CcNode->maxNumOfKeys)
     {
         p_StatsObj = DequeueStatsObj(&p_CcNode->availableStatsLst);
@@ -159,9 +157,8 @@ static t_FmPcdStatsObj* GetStatsObj(t_FmPcdCcNode *p_CcNode)
             return NULL;
         }
 
-        p_StatsObj->h_StatsAd = (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
-                                                            FM_PCD_CC_AD_ENTRY_SIZE,
-                                                            FM_PCD_CC_AD_TABLE_ALIGN);
+        p_StatsObj->h_StatsAd = (t_Handle)FM_MURAM_AllocMem(
+                h_FmMuram, FM_PCD_CC_AD_ENTRY_SIZE, FM_PCD_CC_AD_TABLE_ALIGN);
         if (!p_StatsObj->h_StatsAd)
         {
             XX_Free(p_StatsObj);
@@ -170,9 +167,9 @@ static t_FmPcdStatsObj* GetStatsObj(t_FmPcdCcNode *p_CcNode)
         }
         IOMemSet32(p_StatsObj->h_StatsAd, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
-        p_StatsObj->h_StatsCounters = (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
-                                                                  p_CcNode->countersArraySize,
-                                                                  FM_PCD_CC_AD_TABLE_ALIGN);
+        p_StatsObj->h_StatsCounters = (t_Handle)FM_MURAM_AllocMem(
+                h_FmMuram, p_CcNode->countersArraySize,
+                FM_PCD_CC_AD_TABLE_ALIGN);
         if (!p_StatsObj->h_StatsCounters)
         {
             FM_MURAM_FreeMem(h_FmMuram, p_StatsObj->h_StatsAd);
@@ -186,16 +183,15 @@ static t_FmPcdStatsObj* GetStatsObj(t_FmPcdCcNode *p_CcNode)
     return p_StatsObj;
 }
 
-static void PutStatsObj(t_FmPcdCcNode       *p_CcNode,
-                        t_FmPcdStatsObj     *p_StatsObj)
+static void PutStatsObj(t_FmPcdCcNode *p_CcNode, t_FmPcdStatsObj *p_StatsObj)
 {
-    t_Handle            h_FmMuram;
+    t_Handle h_FmMuram;
 
     ASSERT_COND(p_CcNode);
     ASSERT_COND(p_StatsObj);
 
     /* If 'maxNumOfKeys' was passed, all statistics object were preallocated
-       upon node initialization and now will be enqueued back to the list */
+     upon node initialization and now will be enqueued back to the list */
     if (p_CcNode->maxNumOfKeys)
     {
         /* Nullify counters */
@@ -216,7 +212,7 @@ static void PutStatsObj(t_FmPcdCcNode       *p_CcNode,
 }
 
 static void SetStatsCounters(t_AdOfTypeStats *p_StatsAd,
-                             uint32_t        statsCountersAddr)
+                             uint32_t statsCountersAddr)
 {
     uint32_t tmp = (statsCountersAddr & FM_PCD_AD_STATS_COUNTERS_ADDR_MASK);
 
@@ -224,14 +220,13 @@ static void SetStatsCounters(t_AdOfTypeStats *p_StatsAd,
 }
 
 
-static void UpdateStatsAd(t_FmPcdCcStatsParams  *p_FmPcdCcStatsParams,
-                          t_Handle              h_Ad,
-                          uint64_t              physicalMuramBase)
+static void UpdateStatsAd(t_FmPcdCcStatsParams *p_FmPcdCcStatsParams,
+                          t_Handle h_Ad, uint64_t physicalMuramBase)
 {
     t_AdOfTypeStats *p_StatsAd;
-    uint32_t        statsCountersAddr, nextActionAddr, tmp;
+    uint32_t statsCountersAddr, nextActionAddr, tmp;
 #if (DPAA_VERSION >= 11)
-    uint32_t        frameLengthRangesAddr;
+    uint32_t frameLengthRangesAddr;
 #endif /* (DPAA_VERSION >= 11) */
 
     p_StatsAd = (t_AdOfTypeStats *)p_FmPcdCcStatsParams->h_StatsAd;
@@ -241,7 +236,8 @@ static void UpdateStatsAd(t_FmPcdCcStatsParams  *p_FmPcdCcStatsParams,
 #if (DPAA_VERSION >= 11)
     if (p_FmPcdCcStatsParams->h_StatsFLRs)
     {
-        frameLengthRangesAddr = (uint32_t)((XX_VirtToPhys(p_FmPcdCcStatsParams->h_StatsFLRs) - physicalMuramBase));
+        frameLengthRangesAddr = (uint32_t)((XX_VirtToPhys(
+                p_FmPcdCcStatsParams->h_StatsFLRs) - physicalMuramBase));
         tmp |= (frameLengthRangesAddr & FM_PCD_AD_STATS_FLR_ADDR_MASK);
     }
 #endif /* (DPAA_VERSION >= 11) */
@@ -249,7 +245,8 @@ static void UpdateStatsAd(t_FmPcdCcStatsParams  *p_FmPcdCcStatsParams,
 
     nextActionAddr = (uint32_t)((XX_VirtToPhys(h_Ad) - physicalMuramBase));
     tmp = 0;
-    tmp |= (uint32_t)((nextActionAddr << FM_PCD_AD_STATS_NEXT_ACTION_SHIFT) & FM_PCD_AD_STATS_NEXT_ACTION_MASK);
+    tmp |= (uint32_t)((nextActionAddr << FM_PCD_AD_STATS_NEXT_ACTION_SHIFT)
+            & FM_PCD_AD_STATS_NEXT_ACTION_MASK);
     tmp |= (FM_PCD_AD_STATS_NAD_EN | FM_PCD_AD_STATS_OP_CODE);
 
 #if (DPAA_VERSION >= 11)
@@ -259,23 +256,22 @@ static void UpdateStatsAd(t_FmPcdCcStatsParams  *p_FmPcdCcStatsParams,
 
     WRITE_UINT32(p_StatsAd->nextActionIndx, tmp);
 
-    statsCountersAddr = (uint32_t)((XX_VirtToPhys(p_FmPcdCcStatsParams->h_StatsCounters) - physicalMuramBase));
+    statsCountersAddr = (uint32_t)((XX_VirtToPhys(
+            p_FmPcdCcStatsParams->h_StatsCounters) - physicalMuramBase));
     SetStatsCounters(p_StatsAd, statsCountersAddr);
 }
 
-static void FillAdOfTypeContLookup(t_Handle                 h_Ad,
-                                   t_FmPcdCcStatsParams     *p_FmPcdCcStatsParams,
-                                   t_Handle                 h_FmPcd,
-                                   t_Handle                 p_CcNode,
-                                   t_Handle                 h_Manip,
-                                   t_Handle                 h_FrmReplic)
+static void FillAdOfTypeContLookup(t_Handle h_Ad,
+                                   t_FmPcdCcStatsParams *p_FmPcdCcStatsParams,
+                                   t_Handle h_FmPcd, t_Handle p_CcNode,
+                                   t_Handle h_Manip, t_Handle h_FrmReplic)
 {
-    t_FmPcdCcNode           *p_Node = (t_FmPcdCcNode *)p_CcNode;
-    t_AdOfTypeContLookup    *p_AdContLookup = (t_AdOfTypeContLookup *)h_Ad;
-    t_Handle                h_TmpAd;
-    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t                tmpReg32;
-    t_Handle                p_AdNewPtr = NULL;
+    t_FmPcdCcNode *p_Node = (t_FmPcdCcNode *)p_CcNode;
+    t_AdOfTypeContLookup *p_AdContLookup = (t_AdOfTypeContLookup *)h_Ad;
+    t_Handle h_TmpAd;
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t tmpReg32;
+    t_Handle p_AdNewPtr = NULL;
 
     UNUSED(h_Manip);
     UNUSED(h_FrmReplic);
@@ -311,33 +307,37 @@ static void FillAdOfTypeContLookup(t_Handle                 h_Ad,
         p_AdContLookup = h_Ad;
 
         /* Init statistics Ad and connect current lookup AD as 'next action' from statistics Ad */
-        UpdateStatsAd(p_FmPcdCcStatsParams,
-                      h_Ad,
-                      p_FmPcd->physicalMuramBase);
+        UpdateStatsAd(p_FmPcdCcStatsParams, h_Ad, p_FmPcd->physicalMuramBase);
     }
 
 #if DPAA_VERSION >= 11
     if (h_Manip && h_FrmReplic)
-        FmPcdManipUpdateAdContLookupForCc(h_Manip,
-                                          h_Ad,
-                                          &p_AdNewPtr,
-                                          (uint32_t)((XX_VirtToPhys(FrmReplicGroupGetSourceTableDescriptor(h_FrmReplic)) - p_FmPcd->physicalMuramBase)));
-    else if (h_FrmReplic)
-        FrmReplicGroupUpdateAd(h_FrmReplic, h_Ad, &p_AdNewPtr);
+        FmPcdManipUpdateAdContLookupForCc(
+                h_Manip,
+                h_Ad,
+                &p_AdNewPtr,
+                (uint32_t)((XX_VirtToPhys(
+                        FrmReplicGroupGetSourceTableDescriptor(h_FrmReplic))
+                        - p_FmPcd->physicalMuramBase)));
     else
+        if (h_FrmReplic)
+            FrmReplicGroupUpdateAd(h_FrmReplic, h_Ad, &p_AdNewPtr);
+        else
 #endif /* (DPAA_VERSION >= 11) */
-    if (h_Manip)
-        FmPcdManipUpdateAdContLookupForCc(h_Manip,
-                                          h_Ad,
-                                          &p_AdNewPtr,
+            if (h_Manip)
+                FmPcdManipUpdateAdContLookupForCc(
+                        h_Manip,
+                        h_Ad,
+                        &p_AdNewPtr,
 
 #ifdef FM_CAPWAP_SUPPORT
-                                          /*no check for opcode of manip - this step can be reached only with capwap_applic_specific*/
-                                          (uint32_t)((XX_VirtToPhys(p_Node->h_AdTable) - p_FmPcd->physicalMuramBase))
+                        /*no check for opcode of manip - this step can be reached only with capwap_applic_specific*/
+                        (uint32_t)((XX_VirtToPhys(p_Node->h_AdTable) - p_FmPcd->physicalMuramBase))
 #else  /* not FM_CAPWAP_SUPPORT */
-                                          (uint32_t)((XX_VirtToPhys(p_Node->h_Ad) - p_FmPcd->physicalMuramBase))
+                        (uint32_t)((XX_VirtToPhys(p_Node->h_Ad)
+                                - p_FmPcd->physicalMuramBase))
 #endif /* not FM_CAPWAP_SUPPORT */
-                                          );
+                        );
 
     /* if (p_AdNewPtr = NULL) --> Done. (case (3)) */
     if (p_AdNewPtr)
@@ -345,15 +345,20 @@ static void FillAdOfTypeContLookup(t_Handle                 h_Ad,
         /* cases (1) & (2) */
         tmpReg32 = 0;
         tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
-        tmpReg32 |= p_Node->sizeOfExtraction ? ((p_Node->sizeOfExtraction - 1) << 24) : 0;
-        tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Node->h_AdTable) - p_FmPcd->physicalMuramBase);
+        tmpReg32 |=
+                p_Node->sizeOfExtraction ? ((p_Node->sizeOfExtraction - 1) << 24) :
+                        0;
+        tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Node->h_AdTable)
+                - p_FmPcd->physicalMuramBase);
         WRITE_UINT32(p_AdContLookup->ccAdBase, tmpReg32);
 
         tmpReg32 = 0;
         tmpReg32 |= p_Node->numOfKeys << 24;
         tmpReg32 |= (p_Node->lclMask ? FM_PCD_AD_CONT_LOOKUP_LCL_MASK : 0);
-        tmpReg32 |= p_Node->h_KeysMatchTable ?
-                        (uint32_t)(XX_VirtToPhys(p_Node->h_KeysMatchTable) - p_FmPcd->physicalMuramBase) : 0;
+        tmpReg32 |=
+                p_Node->h_KeysMatchTable ? (uint32_t)(XX_VirtToPhys(
+                        p_Node->h_KeysMatchTable) - p_FmPcd->physicalMuramBase) :
+                        0;
         WRITE_UINT32(p_AdContLookup->matchTblPtr, tmpReg32);
 
         tmpReg32 = 0;
@@ -362,14 +367,15 @@ static void FillAdOfTypeContLookup(t_Handle                 h_Ad,
         tmpReg32 |= p_Node->parseCode;
         WRITE_UINT32(p_AdContLookup->pcAndOffsets, tmpReg32);
 
-        Mem2IOCpy32((void*)&p_AdContLookup->gmask, p_Node->p_GlblMask, CC_GLBL_MASK_SIZE);
+        Mem2IOCpy32((void*)&p_AdContLookup->gmask, p_Node->p_GlblMask,
+                    CC_GLBL_MASK_SIZE);
     }
 }
 
 static t_Error AllocAndFillAdForContLookupManip(t_Handle h_CcNode)
 {
-    t_FmPcdCcNode       *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    uint32_t            intFlags;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint32_t intFlags;
 
     ASSERT_COND(p_CcNode);
 
@@ -380,23 +386,20 @@ static t_Error AllocAndFillAdForContLookupManip(t_Handle h_CcNode)
         if (p_CcNode->maxNumOfKeys)
             p_CcNode->h_Ad = p_CcNode->h_TmpAd;
         else
-            p_CcNode->h_Ad = (t_Handle)FM_MURAM_AllocMem(((t_FmPcd *)(p_CcNode->h_FmPcd))->h_FmMuram,
-                                                         FM_PCD_CC_AD_ENTRY_SIZE,
-                                                         FM_PCD_CC_AD_TABLE_ALIGN);
+            p_CcNode->h_Ad = (t_Handle)FM_MURAM_AllocMem(
+                    ((t_FmPcd *)(p_CcNode->h_FmPcd))->h_FmMuram,
+                    FM_PCD_CC_AD_ENTRY_SIZE, FM_PCD_CC_AD_TABLE_ALIGN);
 
         XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
 
         if (!p_CcNode->h_Ad)
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC action descriptor"));
+            RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                         ("MURAM allocation for CC action descriptor"));
 
-        IOMemSet32(p_CcNode->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+        IOMemSet32(p_CcNode->h_Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
-        FillAdOfTypeContLookup(p_CcNode->h_Ad,
-                               NULL,
-                               p_CcNode->h_FmPcd,
-                               p_CcNode,
-                               NULL,
-                               NULL);
+        FillAdOfTypeContLookup(p_CcNode->h_Ad, NULL, p_CcNode->h_FmPcd,
+                               p_CcNode, NULL, NULL);
     }
     else
         XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
@@ -404,26 +407,23 @@ static t_Error AllocAndFillAdForContLookupManip(t_Handle h_CcNode)
     return E_OK;
 }
 
-
-static t_Error SetRequiredAction1(t_Handle                            h_FmPcd,
-                                 uint32_t                            requiredAction,
-                                 t_FmPcdCcKeyAndNextEngineParams     *p_CcKeyAndNextEngineParamsTmp,
-                                 t_Handle                            h_AdTmp,
-                                 uint16_t                            numOfEntries,
-                                 t_Handle                            h_Tree)
+static t_Error SetRequiredAction1(
+        t_Handle h_FmPcd, uint32_t requiredAction,
+        t_FmPcdCcKeyAndNextEngineParams *p_CcKeyAndNextEngineParamsTmp,
+        t_Handle h_AdTmp, uint16_t numOfEntries, t_Handle h_Tree)
 {
-    t_AdOfTypeResult    *p_AdTmp = (t_AdOfTypeResult *)h_AdTmp;
-    uint32_t            tmpReg32;
-    t_Error             err;
-    t_FmPcdCcNode       *p_CcNode;
-    int                 i = 0;
-    uint16_t            tmp = 0;
-    uint16_t            profileId;
-    uint8_t             relativeSchemeId, physicalSchemeId;
+    t_AdOfTypeResult *p_AdTmp = (t_AdOfTypeResult *)h_AdTmp;
+    uint32_t tmpReg32;
+    t_Error err;
+    t_FmPcdCcNode *p_CcNode;
+    int i = 0;
+    uint16_t tmp = 0;
+    uint16_t profileId;
+    uint8_t relativeSchemeId, physicalSchemeId;
     t_CcNodeInformation ccNodeInfo;
 
-     for (i = 0; i < numOfEntries; i++)
-     {
+    for (i = 0; i < numOfEntries; i++)
+    {
         if (i == 0)
             h_AdTmp = PTR_MOVE(h_AdTmp, i*FM_PCD_CC_AD_ENTRY_SIZE);
         else
@@ -434,138 +434,179 @@ static t_Error SetRequiredAction1(t_Handle                            h_FmPcd,
             case (e_FM_PCD_CC):
                 if (requiredAction)
                 {
-                    p_CcNode = p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.ccParams.h_CcNode;
+                    p_CcNode =
+                            p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.ccParams.h_CcNode;
                     ASSERT_COND(p_CcNode);
                     if (p_CcNode->shadowAction == requiredAction)
                         break;
-                    if ((requiredAction & UPDATE_CC_WITH_TREE) && !(p_CcNode->shadowAction & UPDATE_CC_WITH_TREE))
+                    if ((requiredAction & UPDATE_CC_WITH_TREE)
+                            && !(p_CcNode->shadowAction & UPDATE_CC_WITH_TREE))
                     {
 
                         memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                         ccNodeInfo.h_CcNode = h_Tree;
-                        EnqueueNodeInfoToRelevantLst(&p_CcNode->ccTreesLst, &ccNodeInfo, NULL);
-                        p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= UPDATE_CC_WITH_TREE;
+                        EnqueueNodeInfoToRelevantLst(&p_CcNode->ccTreesLst,
+                                                     &ccNodeInfo, NULL);
+                        p_CcKeyAndNextEngineParamsTmp[i].shadowAction |=
+                                UPDATE_CC_WITH_TREE;
                     }
-                    if ((requiredAction & UPDATE_CC_SHADOW_CLEAR) && !(p_CcNode->shadowAction & UPDATE_CC_SHADOW_CLEAR))
+                    if ((requiredAction & UPDATE_CC_SHADOW_CLEAR)
+                            && !(p_CcNode->shadowAction & UPDATE_CC_SHADOW_CLEAR))
                     {
 
-                         p_CcNode->shadowAction = 0;
+                        p_CcNode->shadowAction = 0;
                     }
 
-                   if ((requiredAction & UPDATE_CC_WITH_DELETE_TREE) && !(p_CcNode->shadowAction & UPDATE_CC_WITH_DELETE_TREE))
+                    if ((requiredAction & UPDATE_CC_WITH_DELETE_TREE)
+                            && !(p_CcNode->shadowAction
+                                    & UPDATE_CC_WITH_DELETE_TREE))
                     {
-                        DequeueNodeInfoFromRelevantLst(&p_CcNode->ccTreesLst, h_Tree, NULL);
-                        p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= UPDATE_CC_WITH_DELETE_TREE;
+                        DequeueNodeInfoFromRelevantLst(&p_CcNode->ccTreesLst,
+                                                       h_Tree, NULL);
+                        p_CcKeyAndNextEngineParamsTmp[i].shadowAction |=
+                                UPDATE_CC_WITH_DELETE_TREE;
                     }
-                    if (p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine != e_FM_PCD_INVALID)
-                        tmp  = (uint8_t)(p_CcNode->numOfKeys + 1);
+                    if (p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine
+                            != e_FM_PCD_INVALID)
+                        tmp = (uint8_t)(p_CcNode->numOfKeys + 1);
                     else
                         tmp = p_CcNode->numOfKeys;
-                    err = SetRequiredAction1(h_FmPcd,
-                                            requiredAction,
-                                            p_CcNode->keyAndNextEngineParams,
-                                            p_CcNode->h_AdTable,
-                                            tmp,
-                                            h_Tree);
+                    err = SetRequiredAction1(h_FmPcd, requiredAction,
+                                             p_CcNode->keyAndNextEngineParams,
+                                             p_CcNode->h_AdTable, tmp, h_Tree);
                     if (err != E_OK)
                         return err;
-                    if(requiredAction != UPDATE_CC_SHADOW_CLEAR)
-			p_CcNode->shadowAction |= requiredAction;
+                    if (requiredAction != UPDATE_CC_SHADOW_CLEAR)
+                        p_CcNode->shadowAction |= requiredAction;
                 }
                 break;
 
             case (e_FM_PCD_KG):
-                if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
+                if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
+                        && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction
+                                & UPDATE_NIA_ENQ_WITHOUT_DMA))
                 {
-                    physicalSchemeId = FmPcdKgGetSchemeId(p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme);
-                    relativeSchemeId = FmPcdKgGetRelativeSchemeId(h_FmPcd, physicalSchemeId);
+                    physicalSchemeId =
+                            FmPcdKgGetSchemeId(
+                                    p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme);
+                    relativeSchemeId = FmPcdKgGetRelativeSchemeId(
+                            h_FmPcd, physicalSchemeId);
                     if (relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
                         RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
-                    if (!FmPcdKgIsSchemeValidSw(p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme))
-                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid direct scheme."));
+                    if (!FmPcdKgIsSchemeValidSw(
+                            p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme))
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                                     ("Invalid direct scheme."));
                     if (!KgIsSchemeAlwaysDirect(h_FmPcd, relativeSchemeId))
-                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this action scheme has to be direct."));
-                    err = FmPcdKgCcGetSetParams(h_FmPcd, p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme, requiredAction, 0);
+                        RETURN_ERROR(
+                                MAJOR, E_INVALID_STATE,
+                                ("For this action scheme has to be direct."));
+                    err =
+                            FmPcdKgCcGetSetParams(
+                                    h_FmPcd,
+                                    p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme,
+                                    requiredAction, 0);
                     if (err != E_OK)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
-                    p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= requiredAction;
+                    p_CcKeyAndNextEngineParamsTmp[i].shadowAction |=
+                            requiredAction;
                 }
                 break;
 
             case (e_FM_PCD_PLCR):
-                if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
+                if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
+                        && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction
+                                & UPDATE_NIA_ENQ_WITHOUT_DMA))
                 {
                     if (!p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.overrideParams)
-                        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this initialization only overrideFqid can be initialized"));
+                        RETURN_ERROR(
+                                MAJOR,
+                                E_NOT_SUPPORTED,
+                                ("In this initialization only overrideFqid can be initialized"));
                     if (!p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.sharedProfile)
-                        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this initialization only overrideFqid can be initialized"));
-                    err =  FmPcdPlcrGetAbsoluteIdByProfileParams(h_FmPcd, e_FM_PCD_PLCR_SHARED, NULL, p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.newRelativeProfileId, &profileId);
-                    if (err!= E_OK)
+                        RETURN_ERROR(
+                                MAJOR,
+                                E_NOT_SUPPORTED,
+                                ("In this initialization only overrideFqid can be initialized"));
+                    err =
+                            FmPcdPlcrGetAbsoluteIdByProfileParams(
+                                    h_FmPcd,
+                                    e_FM_PCD_PLCR_SHARED,
+                                    NULL,
+                                    p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.newRelativeProfileId,
+                                    &profileId);
+                    if (err != E_OK)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
-                    err = FmPcdPlcrCcGetSetParams(h_FmPcd, profileId, requiredAction);
+                    err = FmPcdPlcrCcGetSetParams(h_FmPcd, profileId,
+                                                  requiredAction);
                     if (err != E_OK)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
-                    p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= requiredAction;
+                    p_CcKeyAndNextEngineParamsTmp[i].shadowAction |=
+                            requiredAction;
                 }
                 break;
 
             case (e_FM_PCD_DONE):
-                if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
+                if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
+                        && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction
+                                & UPDATE_NIA_ENQ_WITHOUT_DMA))
                 {
                     tmpReg32 = GET_UINT32(p_AdTmp->nia);
-                    if ((tmpReg32 & GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd)) != GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd))
-                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine was previously assigned not as PCD_DONE"));
+                    if ((tmpReg32 & GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd))
+                            != GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd))
+                        RETURN_ERROR(
+                                MAJOR,
+                                E_INVALID_STATE,
+                                ("Next engine was previously assigned not as PCD_DONE"));
                     tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
                     WRITE_UINT32(p_AdTmp->nia, tmpReg32);
-                    p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= requiredAction;
+                    p_CcKeyAndNextEngineParamsTmp[i].shadowAction |=
+                            requiredAction;
                 }
                 break;
 
             default:
                 break;
         }
-     }
+    }
 
-     return E_OK;
+    return E_OK;
 }
 
-static t_Error SetRequiredAction(t_Handle                            h_FmPcd,
-                                 uint32_t                            requiredAction,
-                                 t_FmPcdCcKeyAndNextEngineParams     *p_CcKeyAndNextEngineParamsTmp,
-                                 t_Handle                            h_AdTmp,
-                                 uint16_t                            numOfEntries,
-                                 t_Handle                            h_Tree)
+static t_Error SetRequiredAction(
+        t_Handle h_FmPcd, uint32_t requiredAction,
+        t_FmPcdCcKeyAndNextEngineParams *p_CcKeyAndNextEngineParamsTmp,
+        t_Handle h_AdTmp, uint16_t numOfEntries, t_Handle h_Tree)
 {
-    t_Error err = SetRequiredAction1(h_FmPcd, requiredAction, p_CcKeyAndNextEngineParamsTmp,
-                       h_AdTmp, numOfEntries, h_Tree);
+    t_Error err = SetRequiredAction1(h_FmPcd, requiredAction,
+                                     p_CcKeyAndNextEngineParamsTmp, h_AdTmp,
+                                     numOfEntries, h_Tree);
     if (err != E_OK)
         return err;
-    return SetRequiredAction1(h_FmPcd, UPDATE_CC_SHADOW_CLEAR, p_CcKeyAndNextEngineParamsTmp,
-                           h_AdTmp, numOfEntries, h_Tree);
+    return SetRequiredAction1(h_FmPcd, UPDATE_CC_SHADOW_CLEAR,
+                              p_CcKeyAndNextEngineParamsTmp, h_AdTmp,
+                              numOfEntries, h_Tree);
 }
 
-static t_Error ReleaseModifiedDataStructure(t_Handle                            h_FmPcd,
-                                            t_List                              *h_FmPcdOldPointersLst,
-                                            t_List                              *h_FmPcdNewPointersLst,
-                                            uint16_t                            numOfGoodChanges,
-                                            t_FmPcdModifyCcKeyAdditionalParams  *p_AdditionalParams,
-                                            bool                                useShadowStructs)
+static t_Error ReleaseModifiedDataStructure(
+        t_Handle h_FmPcd, t_List *h_FmPcdOldPointersLst,
+        t_List *h_FmPcdNewPointersLst,
+        t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalParams,
+        bool useShadowStructs)
 {
-    t_List                  *p_Pos;
-    t_Error                 err = E_OK;
-    t_CcNodeInformation     ccNodeInfo, *p_CcNodeInformation;
-    t_Handle                h_Muram;
-    t_FmPcdCcNode           *p_FmPcdCcNextNode, *p_FmPcdCcWorkingOnNode;
-    t_List                  *p_UpdateLst;
-    uint32_t                intFlags;
-
-
-    UNUSED(numOfGoodChanges);
+    t_List *p_Pos;
+    t_Error err = E_OK;
+    t_CcNodeInformation ccNodeInfo, *p_CcNodeInformation;
+    t_Handle h_Muram;
+    t_FmPcdCcNode *p_FmPcdCcNextNode, *p_FmPcdCcWorkingOnNode;
+    t_List *p_UpdateLst;
+    uint32_t intFlags;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_AdditionalParams->h_CurrentNode,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(h_FmPcdOldPointersLst,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(h_FmPcdNewPointersLst,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_AdditionalParams->h_CurrentNode,
+                              E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdOldPointersLst, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdNewPointersLst, E_INVALID_HANDLE);
 
     /* We don't update subtree of the new node with new tree because it was done in the previous stage */
     if (p_AdditionalParams->h_NodeForAdd)
@@ -577,9 +618,9 @@ static t_Error ReleaseModifiedDataStructure(t_Handle
         else
             p_UpdateLst = &p_FmPcdCcNextNode->ccTreeIdLst;
 
-        p_CcNodeInformation = FindNodeInfoInReleventLst(p_UpdateLst,
-                                                        p_AdditionalParams->h_CurrentNode,
-                                                        p_FmPcdCcNextNode->h_Spinlock);
+        p_CcNodeInformation = FindNodeInfoInReleventLst(
+                p_UpdateLst, p_AdditionalParams->h_CurrentNode,
+                p_FmPcdCcNextNode->h_Spinlock);
 
         if (p_CcNodeInformation)
             p_CcNodeInformation->index++;
@@ -588,26 +629,31 @@ static t_Error ReleaseModifiedDataStructure(t_Handle
             memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
             ccNodeInfo.h_CcNode = (t_Handle)p_AdditionalParams->h_CurrentNode;
             ccNodeInfo.index = 1;
-            EnqueueNodeInfoToRelevantLst(p_UpdateLst,
-                                         &ccNodeInfo,
+            EnqueueNodeInfoToRelevantLst(p_UpdateLst, &ccNodeInfo,
                                          p_FmPcdCcNextNode->h_Spinlock);
         }
         if (p_AdditionalParams->h_ManipForAdd)
         {
-            p_CcNodeInformation = FindNodeInfoInReleventLst(FmPcdManipGetNodeLstPointedOnThisManip(p_AdditionalParams->h_ManipForAdd),
-                                                             p_AdditionalParams->h_CurrentNode,
-                                                             FmPcdManipGetSpinlock(p_AdditionalParams->h_ManipForAdd));
+            p_CcNodeInformation = FindNodeInfoInReleventLst(
+                    FmPcdManipGetNodeLstPointedOnThisManip(
+                            p_AdditionalParams->h_ManipForAdd),
+                    p_AdditionalParams->h_CurrentNode,
+                    FmPcdManipGetSpinlock(p_AdditionalParams->h_ManipForAdd));
 
             if (p_CcNodeInformation)
                 p_CcNodeInformation->index++;
             else
             {
                 memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
-                ccNodeInfo.h_CcNode = (t_Handle)p_AdditionalParams->h_CurrentNode;
+                ccNodeInfo.h_CcNode =
+                        (t_Handle)p_AdditionalParams->h_CurrentNode;
                 ccNodeInfo.index = 1;
-                EnqueueNodeInfoToRelevantLst(FmPcdManipGetNodeLstPointedOnThisManip(p_AdditionalParams->h_ManipForAdd),
-                                            &ccNodeInfo,
-                                             FmPcdManipGetSpinlock(p_AdditionalParams->h_ManipForAdd));
+                EnqueueNodeInfoToRelevantLst(
+                        FmPcdManipGetNodeLstPointedOnThisManip(
+                                p_AdditionalParams->h_ManipForAdd),
+                        &ccNodeInfo,
+                        FmPcdManipGetSpinlock(
+                                p_AdditionalParams->h_ManipForAdd));
             }
         }
     }
@@ -619,44 +665,47 @@ static t_Error ReleaseModifiedDataStructure(t_Handle
         if (!p_AdditionalParams->tree)
         {
             p_UpdateLst = &p_FmPcdCcNextNode->ccPrevNodesLst;
-			p_FmPcdCcWorkingOnNode = (t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode);
+            p_FmPcdCcWorkingOnNode =
+                    (t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode);
 
             for (p_Pos = LIST_FIRST(&p_FmPcdCcWorkingOnNode->ccTreesLst);
-							p_Pos != (&p_FmPcdCcWorkingOnNode->ccTreesLst);
-							p_Pos = LIST_NEXT(p_Pos))
+                    p_Pos != (&p_FmPcdCcWorkingOnNode->ccTreesLst); p_Pos =
+                            LIST_NEXT(p_Pos))
             {
                 p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
 
                 ASSERT_COND(p_CcNodeInformation->h_CcNode);
 
-                err = SetRequiredAction(h_FmPcd,
-                                        UPDATE_CC_WITH_DELETE_TREE,
-                                        &((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams[p_AdditionalParams->savedKeyIndex],
-                                        PTR_MOVE(((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_AdTable, p_AdditionalParams->savedKeyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
-                                        1,
-                                        p_CcNodeInformation->h_CcNode);
+                err =
+                        SetRequiredAction(
+                                h_FmPcd,
+                                UPDATE_CC_WITH_DELETE_TREE,
+                                &((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams[p_AdditionalParams->savedKeyIndex],
+                                PTR_MOVE(((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_AdTable, p_AdditionalParams->savedKeyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
+                                1, p_CcNodeInformation->h_CcNode);
             }
         }
         else
         {
             p_UpdateLst = &p_FmPcdCcNextNode->ccTreeIdLst;
 
-            err = SetRequiredAction(h_FmPcd,
-                                    UPDATE_CC_WITH_DELETE_TREE,
-                                    &((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams[p_AdditionalParams->savedKeyIndex],
-                                    UINT_TO_PTR(((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->ccTreeBaseAddr + p_AdditionalParams->savedKeyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
-                                    1,
-                                    p_AdditionalParams->h_CurrentNode);
+            err =
+                    SetRequiredAction(
+                            h_FmPcd,
+                            UPDATE_CC_WITH_DELETE_TREE,
+                            &((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams[p_AdditionalParams->savedKeyIndex],
+                            UINT_TO_PTR(((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->ccTreeBaseAddr + p_AdditionalParams->savedKeyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
+                            1, p_AdditionalParams->h_CurrentNode);
         }
         if (err)
             return err;
 
         /* We remove from the subtree of the removed node tree because it wasn't done in the previous stage
-           Update ccPrevNodesLst or ccTreeIdLst of the removed node
-           Update of the node owner */
-        p_CcNodeInformation = FindNodeInfoInReleventLst(p_UpdateLst,
-                                                        p_AdditionalParams->h_CurrentNode,
-                                                        p_FmPcdCcNextNode->h_Spinlock);
+         Update ccPrevNodesLst or ccTreeIdLst of the removed node
+         Update of the node owner */
+        p_CcNodeInformation = FindNodeInfoInReleventLst(
+                p_UpdateLst, p_AdditionalParams->h_CurrentNode,
+                p_FmPcdCcNextNode->h_Spinlock);
 
         ASSERT_COND(p_CcNodeInformation);
         ASSERT_COND(p_CcNodeInformation->index);
@@ -664,17 +713,19 @@ static t_Error ReleaseModifiedDataStructure(t_Handle
         p_CcNodeInformation->index--;
 
         if (p_CcNodeInformation->index == 0)
-           DequeueNodeInfoFromRelevantLst(p_UpdateLst,
-                                          p_AdditionalParams->h_CurrentNode,
-                                          p_FmPcdCcNextNode->h_Spinlock);
+            DequeueNodeInfoFromRelevantLst(p_UpdateLst,
+                                           p_AdditionalParams->h_CurrentNode,
+                                           p_FmPcdCcNextNode->h_Spinlock);
 
         UpdateNodeOwner(p_FmPcdCcNextNode, FALSE);
 
         if (p_AdditionalParams->h_ManipForRmv)
         {
-             p_CcNodeInformation = FindNodeInfoInReleventLst(FmPcdManipGetNodeLstPointedOnThisManip(p_AdditionalParams->h_ManipForRmv),
-                                                             p_AdditionalParams->h_CurrentNode,
-                                                             FmPcdManipGetSpinlock(p_AdditionalParams->h_ManipForRmv));
+            p_CcNodeInformation = FindNodeInfoInReleventLst(
+                    FmPcdManipGetNodeLstPointedOnThisManip(
+                            p_AdditionalParams->h_ManipForRmv),
+                    p_AdditionalParams->h_CurrentNode,
+                    FmPcdManipGetSpinlock(p_AdditionalParams->h_ManipForRmv));
 
             ASSERT_COND(p_CcNodeInformation);
             ASSERT_COND(p_CcNodeInformation->index);
@@ -682,9 +733,12 @@ static t_Error ReleaseModifiedDataStructure(t_Handle
             p_CcNodeInformation->index--;
 
             if (p_CcNodeInformation->index == 0)
-               DequeueNodeInfoFromRelevantLst(FmPcdManipGetNodeLstPointedOnThisManip(p_AdditionalParams->h_ManipForRmv),
-                                              p_AdditionalParams->h_CurrentNode,
-                                              FmPcdManipGetSpinlock(p_AdditionalParams->h_ManipForRmv));
+                DequeueNodeInfoFromRelevantLst(
+                        FmPcdManipGetNodeLstPointedOnThisManip(
+                                p_AdditionalParams->h_ManipForRmv),
+                        p_AdditionalParams->h_CurrentNode,
+                        FmPcdManipGetSpinlock(
+                                p_AdditionalParams->h_ManipForRmv));
         }
     }
 
@@ -706,55 +760,61 @@ static t_Error ReleaseModifiedDataStructure(t_Handle
         h_Muram = FmPcdGetMuramHandle(h_FmPcd);
         ASSERT_COND(h_Muram);
 
-        if ((p_AdditionalParams->tree &&
-             !((t_FmPcd *)h_FmPcd)->p_CcShadow) ||
-            (!p_AdditionalParams->tree &&
-             !((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->maxNumOfKeys))
+        if ((p_AdditionalParams->tree && !((t_FmPcd *)h_FmPcd)->p_CcShadow)
+                || (!p_AdditionalParams->tree
+                        && !((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->maxNumOfKeys))
         {
             /* We release new AD which was allocated and updated for copy from to actual AD */
             for (p_Pos = LIST_FIRST(h_FmPcdNewPointersLst);
-						p_Pos != (h_FmPcdNewPointersLst);
-						p_Pos = LIST_NEXT(p_Pos))
+                    p_Pos != (h_FmPcdNewPointersLst); p_Pos = LIST_NEXT(p_Pos))
             {
 
-	            p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
-	            ASSERT_COND(p_CcNodeInformation->h_CcNode);
-	            FM_MURAM_FreeMem(h_Muram, p_CcNodeInformation->h_CcNode);
+                p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
+                ASSERT_COND(p_CcNodeInformation->h_CcNode);
+                FM_MURAM_FreeMem(h_Muram, p_CcNodeInformation->h_CcNode);
             }
         }
 
         /* Free Old data structure if it has to be freed - new data structure was allocated*/
         if (p_AdditionalParams->p_AdTableOld)
-            FM_MURAM_FreeMem(h_Muram,p_AdditionalParams->p_AdTableOld);
+            FM_MURAM_FreeMem(h_Muram, p_AdditionalParams->p_AdTableOld);
 
         if (p_AdditionalParams->p_KeysMatchTableOld)
-            FM_MURAM_FreeMem(h_Muram,p_AdditionalParams->p_KeysMatchTableOld);
+            FM_MURAM_FreeMem(h_Muram, p_AdditionalParams->p_KeysMatchTableOld);
     }
 
     /* Update current modified node with changed fields if it's required*/
     if (!p_AdditionalParams->tree)
     {
         if (p_AdditionalParams->p_AdTableNew)
-            ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_AdTable = p_AdditionalParams->p_AdTableNew;
+            ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_AdTable =
+                    p_AdditionalParams->p_AdTableNew;
 
         if (p_AdditionalParams->p_KeysMatchTableNew)
-            ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_KeysMatchTable = p_AdditionalParams->p_KeysMatchTableNew;
+            ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_KeysMatchTable =
+                    p_AdditionalParams->p_KeysMatchTableNew;
 
         /* Locking node's spinlock before updating 'keys and next engine' structure,
-           as it maybe used to retrieve keys statistics */
-        intFlags = XX_LockIntrSpinlock(((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_Spinlock);
+         as it maybe used to retrieve keys statistics */
+        intFlags =
+                XX_LockIntrSpinlock(
+                        ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_Spinlock);
 
-        ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->numOfKeys = p_AdditionalParams->numOfKeys;
+        ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->numOfKeys =
+                p_AdditionalParams->numOfKeys;
 
         memcpy(((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams,
-                &p_AdditionalParams->keyAndNextEngineParams,
-                sizeof(t_FmPcdCcKeyAndNextEngineParams) * (CC_MAX_NUM_OF_KEYS));
+               &p_AdditionalParams->keyAndNextEngineParams,
+               sizeof(t_FmPcdCcKeyAndNextEngineParams) * (CC_MAX_NUM_OF_KEYS));
 
-        XX_UnlockIntrSpinlock(((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_Spinlock, intFlags);
+        XX_UnlockIntrSpinlock(
+                ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_Spinlock,
+                intFlags);
     }
     else
     {
-        uint8_t numEntries = ((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->numOfEntries;
+        uint8_t numEntries =
+                ((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->numOfEntries;
         ASSERT_COND(numEntries < FM_PCD_MAX_NUM_OF_CC_GROUPS);
         memcpy(&((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams,
                &p_AdditionalParams->keyAndNextEngineParams,
@@ -769,12 +829,13 @@ static t_Error ReleaseModifiedDataStructure(t_Handle
     return E_OK;
 }
 
-static t_Handle BuildNewAd(t_Handle                             h_Ad,
-                           t_FmPcdModifyCcKeyAdditionalParams   *p_FmPcdModifyCcKeyAdditionalParams,
-                           t_FmPcdCcNode                        *p_CcNode,
-                           t_FmPcdCcNextEngineParams            *p_FmPcdCcNextEngineParams)
+static t_Handle BuildNewAd(
+        t_Handle h_Ad,
+        t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams,
+        t_FmPcdCcNode *p_CcNode,
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcdCcNode   *p_FmPcdCcNodeTmp;
+    t_FmPcdCcNode *p_FmPcdCcNodeTmp;
 
     p_FmPcdCcNodeTmp = (t_FmPcdCcNode*)XX_Malloc(sizeof(t_FmPcdCcNode));
     if (!p_FmPcdCcNodeTmp)
@@ -784,48 +845,47 @@ static t_Handle BuildNewAd(t_Handle                             h_Ad,
     }
     memset(p_FmPcdCcNodeTmp, 0, sizeof(t_FmPcdCcNode));
 
-    p_FmPcdCcNodeTmp->numOfKeys        = p_FmPcdModifyCcKeyAdditionalParams->numOfKeys;
-    p_FmPcdCcNodeTmp->h_KeysMatchTable = p_FmPcdModifyCcKeyAdditionalParams->p_KeysMatchTableNew;
-    p_FmPcdCcNodeTmp->h_AdTable        = p_FmPcdModifyCcKeyAdditionalParams->p_AdTableNew;
-
-    p_FmPcdCcNodeTmp->lclMask                = p_CcNode->lclMask;
-    p_FmPcdCcNodeTmp->parseCode              = p_CcNode->parseCode;
-    p_FmPcdCcNodeTmp->offset                 = p_CcNode->offset;
-    p_FmPcdCcNodeTmp->prsArrayOffset         = p_CcNode->prsArrayOffset;
-    p_FmPcdCcNodeTmp->ctrlFlow               = p_CcNode->ctrlFlow;
+    p_FmPcdCcNodeTmp->numOfKeys = p_FmPcdModifyCcKeyAdditionalParams->numOfKeys;
+    p_FmPcdCcNodeTmp->h_KeysMatchTable =
+            p_FmPcdModifyCcKeyAdditionalParams->p_KeysMatchTableNew;
+    p_FmPcdCcNodeTmp->h_AdTable =
+            p_FmPcdModifyCcKeyAdditionalParams->p_AdTableNew;
+
+    p_FmPcdCcNodeTmp->lclMask = p_CcNode->lclMask;
+    p_FmPcdCcNodeTmp->parseCode = p_CcNode->parseCode;
+    p_FmPcdCcNodeTmp->offset = p_CcNode->offset;
+    p_FmPcdCcNodeTmp->prsArrayOffset = p_CcNode->prsArrayOffset;
+    p_FmPcdCcNodeTmp->ctrlFlow = p_CcNode->ctrlFlow;
     p_FmPcdCcNodeTmp->ccKeySizeAccExtraction = p_CcNode->ccKeySizeAccExtraction;
-    p_FmPcdCcNodeTmp->sizeOfExtraction       = p_CcNode->sizeOfExtraction;
-    p_FmPcdCcNodeTmp->glblMaskSize           = p_CcNode->glblMaskSize;
-    p_FmPcdCcNodeTmp->p_GlblMask             = p_CcNode->p_GlblMask;
+    p_FmPcdCcNodeTmp->sizeOfExtraction = p_CcNode->sizeOfExtraction;
+    p_FmPcdCcNodeTmp->glblMaskSize = p_CcNode->glblMaskSize;
+    p_FmPcdCcNodeTmp->p_GlblMask = p_CcNode->p_GlblMask;
 
     if (p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC)
     {
         if (p_FmPcdCcNextEngineParams->h_Manip)
         {
-            if (AllocAndFillAdForContLookupManip(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)!= E_OK)
+            if (AllocAndFillAdForContLookupManip(
+                    p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)
+                    != E_OK)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+                XX_Free(p_FmPcdCcNodeTmp);
                 return NULL;
             }
         }
-        FillAdOfTypeContLookup(h_Ad,
-                               NULL,
-                               p_CcNode->h_FmPcd,
-                               p_FmPcdCcNodeTmp,
-                               p_FmPcdCcNextEngineParams->h_Manip,
-                               NULL);
+        FillAdOfTypeContLookup(h_Ad, NULL, p_CcNode->h_FmPcd, p_FmPcdCcNodeTmp,
+                               p_FmPcdCcNextEngineParams->h_Manip, NULL);
     }
 
 #if (DPAA_VERSION >= 11)
-    if ((p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_FR) &&
-        (p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic))
+    if ((p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_FR)
+            && (p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic))
     {
-        FillAdOfTypeContLookup(h_Ad,
-                               NULL,
-                               p_CcNode->h_FmPcd,
-                               p_FmPcdCcNodeTmp,
-                               p_FmPcdCcNextEngineParams->h_Manip,
-                               p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic);
+        FillAdOfTypeContLookup(
+                h_Ad, NULL, p_CcNode->h_FmPcd, p_FmPcdCcNodeTmp,
+                p_FmPcdCcNextEngineParams->h_Manip,
+                p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic);
     }
 #endif /* (DPAA_VERSION >= 11) */
 
@@ -834,17 +894,16 @@ static t_Handle BuildNewAd(t_Handle                             h_Ad,
     return E_OK;
 }
 
-static t_Error DynamicChangeHc(t_Handle                             h_FmPcd,
-                               t_List                               *h_OldPointersLst,
-                               t_List                               *h_NewPointersLst,
-                               t_FmPcdModifyCcKeyAdditionalParams   *p_AdditionalParams,
-                               bool                                 useShadowStructs)
+static t_Error DynamicChangeHc(
+        t_Handle h_FmPcd, t_List *h_OldPointersLst, t_List *h_NewPointersLst,
+        t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalParams,
+        bool useShadowStructs)
 {
-    t_List      *p_PosOld, *p_PosNew;
-    uint32_t    oldAdAddrOffset, newAdAddrOffset;
-    uint16_t    i = 0;
-    t_Error     err = E_OK;
-    uint8_t     numOfModifiedPtr;
+    t_List *p_PosOld, *p_PosNew;
+    uint32_t oldAdAddrOffset, newAdAddrOffset;
+    uint16_t i = 0;
+    t_Error err = E_OK;
+    uint8_t numOfModifiedPtr;
 
     ASSERT_COND(h_FmPcd);
     ASSERT_COND(h_OldPointersLst);
@@ -854,133 +913,131 @@ static t_Error DynamicChangeHc(t_Handle                             h_FmPcd,
 
     if (numOfModifiedPtr)
     {
-    p_PosNew = LIST_FIRST(h_NewPointersLst);
-    p_PosOld = LIST_FIRST(h_OldPointersLst);
-
-    /* Retrieve address of new AD */
-    newAdAddrOffset = FmPcdCcGetNodeAddrOffsetFromNodeInfo(h_FmPcd, p_PosNew);
-    if (newAdAddrOffset == (uint32_t)ILLEGAL_BASE)
-    {
-        ReleaseModifiedDataStructure(h_FmPcd,
-                                     h_OldPointersLst,
-                                     h_NewPointersLst,
-                                     0,
-                                     p_AdditionalParams,
-                                     useShadowStructs);
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("New AD address"));
-    }
+        p_PosNew = LIST_FIRST(h_NewPointersLst);
+        p_PosOld = LIST_FIRST(h_OldPointersLst);
 
-    for (i=0; i<numOfModifiedPtr; i++)
-    {
-        /* Retrieve address of current AD */
-        oldAdAddrOffset = FmPcdCcGetNodeAddrOffsetFromNodeInfo(h_FmPcd, p_PosOld);
-        if (oldAdAddrOffset == (uint32_t)ILLEGAL_BASE)
+        /* Retrieve address of new AD */
+        newAdAddrOffset = FmPcdCcGetNodeAddrOffsetFromNodeInfo(h_FmPcd,
+                                                               p_PosNew);
+        if (newAdAddrOffset == (uint32_t)ILLEGAL_BASE)
         {
-            ReleaseModifiedDataStructure(h_FmPcd,
-                                         h_OldPointersLst,
+            ReleaseModifiedDataStructure(h_FmPcd, h_OldPointersLst,
                                          h_NewPointersLst,
-                                         i,
-                                         p_AdditionalParams,
-                                         useShadowStructs);
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Old AD address"));
+                                         p_AdditionalParams, useShadowStructs);
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("New AD address"));
         }
 
-        /* Invoke host command to copy from new AD to old AD */
-        err = FmHcPcdCcDoDynamicChange(((t_FmPcd *)h_FmPcd)->h_Hc, oldAdAddrOffset, newAdAddrOffset);
-        if (err)
+        for (i = 0; i < numOfModifiedPtr; i++)
         {
-            ReleaseModifiedDataStructure(h_FmPcd,
-                                         h_OldPointersLst,
-                                         h_NewPointersLst,
-                                         i,
-                                         p_AdditionalParams,
-                                         useShadowStructs);
-            RETURN_ERROR(MAJOR, err, ("For part of nodes changes are done - situation is danger"));
-        }
+            /* Retrieve address of current AD */
+            oldAdAddrOffset = FmPcdCcGetNodeAddrOffsetFromNodeInfo(h_FmPcd,
+                                                                   p_PosOld);
+            if (oldAdAddrOffset == (uint32_t)ILLEGAL_BASE)
+            {
+                ReleaseModifiedDataStructure(h_FmPcd, h_OldPointersLst,
+                                             h_NewPointersLst,
+                                             p_AdditionalParams,
+                                             useShadowStructs);
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Old AD address"));
+            }
 
-        p_PosOld = LIST_NEXT(p_PosOld);
-    }
+            /* Invoke host command to copy from new AD to old AD */
+            err = FmHcPcdCcDoDynamicChange(((t_FmPcd *)h_FmPcd)->h_Hc,
+                                           oldAdAddrOffset, newAdAddrOffset);
+            if (err)
+            {
+                ReleaseModifiedDataStructure(h_FmPcd, h_OldPointersLst,
+                                             h_NewPointersLst,
+                                             p_AdditionalParams,
+                                             useShadowStructs);
+                RETURN_ERROR(
+                        MAJOR,
+                        err,
+                        ("For part of nodes changes are done - situation is danger"));
+            }
+
+            p_PosOld = LIST_NEXT(p_PosOld);
+        }
     }
     return E_OK;
 }
 
-static t_Error DoDynamicChange(t_Handle                             h_FmPcd,
-                               t_List                               *h_OldPointersLst,
-                               t_List                               *h_NewPointersLst,
-                               t_FmPcdModifyCcKeyAdditionalParams   *p_AdditionalParams,
-                               bool                                 useShadowStructs)
+static t_Error DoDynamicChange(
+        t_Handle h_FmPcd, t_List *h_OldPointersLst, t_List *h_NewPointersLst,
+        t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalParams,
+        bool useShadowStructs)
 {
-    t_FmPcdCcNode               *p_CcNode = (t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode);
-    t_List                      *p_PosNew;
-    t_CcNodeInformation         *p_CcNodeInfo;
-    t_FmPcdCcNextEngineParams   nextEngineParams;
-    t_Handle                    h_Ad;
-    uint32_t                    keySize;
-    t_Error                     err = E_OK;
-    uint8_t                     numOfModifiedPtr;
+    t_FmPcdCcNode *p_CcNode =
+            (t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode);
+    t_List *p_PosNew;
+    t_CcNodeInformation *p_CcNodeInfo;
+    t_FmPcdCcNextEngineParams nextEngineParams;
+    t_Handle h_Ad;
+    uint32_t keySize;
+    t_Error err = E_OK;
+    uint8_t numOfModifiedPtr;
 
     ASSERT_COND(h_FmPcd);
 
-
     memset(&nextEngineParams, 0, sizeof(t_FmPcdCcNextEngineParams));
 
     numOfModifiedPtr = (uint8_t)LIST_NumOfObjs(h_OldPointersLst);
 
+    if (numOfModifiedPtr)
+    {
 
-    p_PosNew = LIST_FIRST(h_NewPointersLst);
-
-    /* Invoke host-command to copy from the new Ad to existing Ads */
-    err = DynamicChangeHc(h_FmPcd, h_OldPointersLst, h_NewPointersLst, p_AdditionalParams, useShadowStructs);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+        p_PosNew = LIST_FIRST(h_NewPointersLst);
 
-    if (useShadowStructs)
-    {
-        /* When the host-command above has ended, the old structures are 'free'and we can update
-           them by copying from the new shadow structures. */
-        if (p_CcNode->lclMask)
-            keySize = (uint32_t)(2 * p_CcNode->ccKeySizeAccExtraction);
-        else
-            keySize = p_CcNode->ccKeySizeAccExtraction;
+        /* Invoke host-command to copy from the new Ad to existing Ads */
+        err = DynamicChangeHc(h_FmPcd, h_OldPointersLst, h_NewPointersLst,
+                              p_AdditionalParams, useShadowStructs);
+        if (err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
 
-        IO2IOCpy32(p_AdditionalParams->p_KeysMatchTableOld,
-                   p_AdditionalParams->p_KeysMatchTableNew,
-                   p_CcNode->maxNumOfKeys * keySize * sizeof (uint8_t));
+		if (useShadowStructs)
+		{
+			/* When the host-command above has ended, the old structures are 'free'and we can update
+			 them by copying from the new shadow structures. */
+			if (p_CcNode->lclMask)
+				keySize = (uint32_t)(2 * p_CcNode->ccKeySizeAccExtraction);
+			else
+				keySize = p_CcNode->ccKeySizeAccExtraction;
 
-        IO2IOCpy32(p_AdditionalParams->p_AdTableOld,
-                   p_AdditionalParams->p_AdTableNew,
-                   (uint32_t)((p_CcNode->maxNumOfKeys + 1) * FM_PCD_CC_AD_ENTRY_SIZE));
+			IO2IOCpy32(p_AdditionalParams->p_KeysMatchTableOld,
+					   p_AdditionalParams->p_KeysMatchTableNew,
+					   p_CcNode->maxNumOfKeys * keySize * sizeof(uint8_t));
 
+			IO2IOCpy32(
+					p_AdditionalParams->p_AdTableOld,
+					p_AdditionalParams->p_AdTableNew,
+					(uint32_t)((p_CcNode->maxNumOfKeys + 1)
+							* FM_PCD_CC_AD_ENTRY_SIZE));
 
-        p_AdditionalParams->p_KeysMatchTableNew = p_AdditionalParams->p_KeysMatchTableOld;
-        p_AdditionalParams->p_AdTableNew        = p_AdditionalParams->p_AdTableOld;
+			/* Retrieve the address of the allocated Ad */
+			p_CcNodeInfo = CC_NODE_F_OBJECT(p_PosNew);
+			h_Ad = p_CcNodeInfo->h_CcNode;
 
-        if (numOfModifiedPtr)
-        {
-        /* Retrieve the address of the allocated Ad */
-	        p_CcNodeInfo = CC_NODE_F_OBJECT(p_PosNew);
-	        h_Ad = p_CcNodeInfo->h_CcNode;
-	        nextEngineParams.nextEngine = e_FM_PCD_CC;
-	        nextEngineParams.params.ccParams.h_CcNode = (t_Handle)p_CcNode;
-
-        /* Build a new Ad that holds the old (now updated) structures */
-	        BuildNewAd(h_Ad, p_AdditionalParams, p_CcNode, &nextEngineParams);
-        }
+			/* Build a new Ad that holds the old (now updated) structures */
+			p_AdditionalParams->p_KeysMatchTableNew =
+					p_AdditionalParams->p_KeysMatchTableOld;
+			p_AdditionalParams->p_AdTableNew = p_AdditionalParams->p_AdTableOld;
 
-        /* HC to copy from the new Ad (old updated structures) to current Ad (uses shadow structures) */
-        err = DynamicChangeHc(h_FmPcd, h_OldPointersLst, h_NewPointersLst, p_AdditionalParams, useShadowStructs);
-        if (err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
+			nextEngineParams.nextEngine = e_FM_PCD_CC;
+			nextEngineParams.params.ccParams.h_CcNode = (t_Handle)p_CcNode;
 
+			BuildNewAd(h_Ad, p_AdditionalParams, p_CcNode, &nextEngineParams);
 
+			/* HC to copy from the new Ad (old updated structures) to current Ad (uses shadow structures) */
+			err = DynamicChangeHc(h_FmPcd, h_OldPointersLst, h_NewPointersLst,
+								  p_AdditionalParams, useShadowStructs);
+			if (err)
+				RETURN_ERROR(MAJOR, err, NO_MSG);
+		}
+    }
 
-    err = ReleaseModifiedDataStructure(h_FmPcd,
-                                       h_OldPointersLst,
+    err = ReleaseModifiedDataStructure(h_FmPcd, h_OldPointersLst,
                                        h_NewPointersLst,
-                                       numOfModifiedPtr,
-                                       p_AdditionalParams,
-                                       useShadowStructs);
+                                       p_AdditionalParams, useShadowStructs);
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -991,7 +1048,7 @@ static t_Error DoDynamicChange(t_Handle                             h_FmPcd,
 static bool IsCapwapApplSpecific(t_Handle h_Node)
 {
     t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_Node;
-    bool    isManipForCapwapApplSpecificBuild = FALSE;
+    bool isManipForCapwapApplSpecificBuild = FALSE;
     int i = 0;
 
     ASSERT_COND(h_Node);
@@ -999,7 +1056,7 @@ static bool IsCapwapApplSpecific(t_Handle h_Node)
     for (i = 0; i < p_CcNode->numOfKeys; i++)
     {
         if ( p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip &&
-            FmPcdManipIsCapwapApplSpecific(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip))
+                FmPcdManipIsCapwapApplSpecific(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip))
         {
             isManipForCapwapApplSpecificBuild = TRUE;
             break;
@@ -1010,84 +1067,77 @@ static bool IsCapwapApplSpecific(t_Handle h_Node)
 }
 #endif /* FM_CAPWAP_SUPPORT */
 
-static t_Error CcUpdateParam(t_Handle                           h_FmPcd,
-                             t_Handle                           h_PcdParams,
-                             t_Handle                           h_FmPort,
-                             t_FmPcdCcKeyAndNextEngineParams    *p_CcKeyAndNextEngineParams,
-                             uint16_t                           numOfEntries,
-                             t_Handle                           h_Ad,
-                             bool                               validate,
-                             uint16_t                           level,
-                             t_Handle                           h_FmTree,
-                             bool                               modify)
+static t_Error CcUpdateParam(
+        t_Handle h_FmPcd, t_Handle h_PcdParams, t_Handle h_FmPort,
+        t_FmPcdCcKeyAndNextEngineParams *p_CcKeyAndNextEngineParams,
+        uint16_t numOfEntries, t_Handle h_Ad, bool validate, uint16_t level,
+        t_Handle h_FmTree, bool modify)
 {
-    t_FmPcdCcNode       *p_CcNode;
-    t_Error             err;
-    uint16_t            tmp = 0;
-    int                 i = 0;
-    t_FmPcdCcTree       *p_CcTree = (t_FmPcdCcTree *) h_FmTree;
+    t_FmPcdCcNode *p_CcNode;
+    t_Error err;
+    uint16_t tmp = 0;
+    int i = 0;
+    t_FmPcdCcTree *p_CcTree = (t_FmPcdCcTree *)h_FmTree;
 
     level++;
 
     if (p_CcTree->h_IpReassemblyManip)
     {
-        err = FmPcdManipUpdate(h_FmPcd,
-                               h_PcdParams,
-                               h_FmPort,
-                               p_CcTree->h_IpReassemblyManip,
-                               NULL,
-                               validate,
-                               level,
-                               h_FmTree,
-                               modify);
+        err = FmPcdManipUpdate(h_FmPcd, h_PcdParams, h_FmPort,
+                               p_CcTree->h_IpReassemblyManip, NULL, validate,
+                               level, h_FmTree, modify);
+        if (err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    if (p_CcTree->h_CapwapReassemblyManip)
+    {
+        err = FmPcdManipUpdate(h_FmPcd, h_PcdParams, h_FmPort,
+                               p_CcTree->h_CapwapReassemblyManip, NULL, validate,
+                               level, h_FmTree, modify);
         if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     if (numOfEntries)
     {
-        for (i=0; i<numOfEntries; i++)
+        for (i = 0; i < numOfEntries; i++)
         {
             if (i == 0)
                 h_Ad = PTR_MOVE(h_Ad, i*FM_PCD_CC_AD_ENTRY_SIZE);
             else
                 h_Ad = PTR_MOVE(h_Ad, FM_PCD_CC_AD_ENTRY_SIZE);
 
-            if (p_CcKeyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            if (p_CcKeyAndNextEngineParams[i].nextEngineParams.nextEngine
+                    == e_FM_PCD_CC)
             {
-                p_CcNode = p_CcKeyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
+                p_CcNode =
+                        p_CcKeyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
                 ASSERT_COND(p_CcNode);
 
                 if (p_CcKeyAndNextEngineParams[i].nextEngineParams.h_Manip)
                 {
-                    err = FmPcdManipUpdate(h_FmPcd,
-                                           NULL,
-                                           h_FmPort,
-                                           p_CcKeyAndNextEngineParams[i].nextEngineParams.h_Manip,
-                                           h_Ad,
-                                           validate,
-                                           level,
-                                           h_FmTree,
-                                           modify);
+                    err =
+                            FmPcdManipUpdate(
+                                    h_FmPcd,
+                                    NULL,
+                                    h_FmPort,
+                                    p_CcKeyAndNextEngineParams[i].nextEngineParams.h_Manip,
+                                    h_Ad, validate, level, h_FmTree, modify);
                     if (err)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
                 }
 
-                if (p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine != e_FM_PCD_INVALID)
-                    tmp  = (uint8_t)(p_CcNode->numOfKeys + 1);
+                if (p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine
+                        != e_FM_PCD_INVALID)
+                    tmp = (uint8_t)(p_CcNode->numOfKeys + 1);
                 else
                     tmp = p_CcNode->numOfKeys;
 
-                err = CcUpdateParam(h_FmPcd,
-                                    h_PcdParams,
-                                    h_FmPort,
-                                    p_CcNode->keyAndNextEngineParams,
-                                    tmp,
-                                    p_CcNode->h_AdTable,
-                                    validate,
-                                    level,
-                                    h_FmTree,
-                                    modify);
+                err = CcUpdateParam(h_FmPcd, h_PcdParams, h_FmPort,
+                                    p_CcNode->keyAndNextEngineParams, tmp,
+                                    p_CcNode->h_AdTable, validate, level,
+                                    h_FmTree, modify);
                 if (err)
                     RETURN_ERROR(MAJOR, err, NO_MSG);
             }
@@ -1095,15 +1145,13 @@ static t_Error CcUpdateParam(t_Handle                           h_FmPcd,
             {
                 if (p_CcKeyAndNextEngineParams[i].nextEngineParams.h_Manip)
                 {
-                    err = FmPcdManipUpdate(h_FmPcd,
-                                           NULL,
-                                           h_FmPort,
-                                           p_CcKeyAndNextEngineParams[i].nextEngineParams.h_Manip,
-                                           h_Ad,
-                                           validate,
-                                           level,
-                                           h_FmTree,
-                                           modify);
+                    err =
+                            FmPcdManipUpdate(
+                                    h_FmPcd,
+                                    NULL,
+                                    h_FmPort,
+                                    p_CcKeyAndNextEngineParams[i].nextEngineParams.h_Manip,
+                                    h_Ad, validate, level, h_FmTree, modify);
                     if (err)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
                 }
@@ -1137,19 +1185,20 @@ static ccPrivateInfo_t IcDefineCode(t_FmPcdCcNodeParams *p_CcNodeParam)
                 case (e_FM_PCD_EXTRACT_FROM_FLOW_ID):
                     return CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP;
                 default:
-                  return  CC_PRIVATE_INFO_NONE;
+                    return CC_PRIVATE_INFO_NONE;
             }
 
-       default:
-           break;
+        default:
+            break;
     }
 
     return CC_PRIVATE_INFO_NONE;
 }
 
-static t_CcNodeInformation * DequeueAdditionalInfoFromRelevantLst(t_List *p_List)
+static t_CcNodeInformation * DequeueAdditionalInfoFromRelevantLst(
+        t_List *p_List)
 {
-    t_CcNodeInformation   *p_CcNodeInfo = NULL;
+    t_CcNodeInformation *p_CcNodeInfo = NULL;
 
     if (!LIST_IsEmpty(p_List))
     {
@@ -1162,7 +1211,7 @@ static t_CcNodeInformation * DequeueAdditionalInfoFromRelevantLst(t_List *p_List
 
 void ReleaseLst(t_List *p_List)
 {
-    t_CcNodeInformation   *p_CcNodeInfo = NULL;
+    t_CcNodeInformation *p_CcNodeInfo = NULL;
 
     if (!LIST_IsEmpty(p_List))
     {
@@ -1192,26 +1241,30 @@ static void DeleteNode(t_FmPcdCcNode *p_CcNode)
 
     if (p_CcNode->h_KeysMatchTable)
     {
-        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_CcNode->h_KeysMatchTable);
+        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd),
+                         p_CcNode->h_KeysMatchTable);
         p_CcNode->h_KeysMatchTable = NULL;
     }
 
     if (p_CcNode->h_AdTable)
     {
-        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_CcNode->h_AdTable);
+        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd),
+                         p_CcNode->h_AdTable);
         p_CcNode->h_AdTable = NULL;
     }
 
     if (p_CcNode->h_Ad)
     {
-        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_CcNode->h_Ad);
+        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd),
+                         p_CcNode->h_Ad);
         p_CcNode->h_Ad = NULL;
         p_CcNode->h_TmpAd = NULL;
     }
 
     if (p_CcNode->h_StatsFLRs)
     {
-        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_CcNode->h_StatsFLRs);
+        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd),
+                         p_CcNode->h_StatsFLRs);
         p_CcNode->h_StatsFLRs = NULL;
     }
 
@@ -1222,17 +1275,20 @@ static void DeleteNode(t_FmPcdCcNode *p_CcNode)
     }
 
     /* Restore the original counters pointer instead of the mutual pointer (mutual to all hash buckets) */
-    if (p_CcNode->isHashBucket && (p_CcNode->statisticsMode != e_FM_PCD_CC_STATS_MODE_NONE))
-        p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].p_StatsObj->h_StatsCounters = p_CcNode->h_PrivMissStatsCounters;
+    if (p_CcNode->isHashBucket
+            && (p_CcNode->statisticsMode != e_FM_PCD_CC_STATS_MODE_NONE))
+        p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].p_StatsObj->h_StatsCounters =
+                p_CcNode->h_PrivMissStatsCounters;
 
     /* Releasing all currently used statistics objects, including 'miss' entry */
     for (i = 0; i < p_CcNode->numOfKeys + 1; i++)
         if (p_CcNode->keyAndNextEngineParams[i].p_StatsObj)
-            PutStatsObj(p_CcNode, p_CcNode->keyAndNextEngineParams[i].p_StatsObj);
+            PutStatsObj(p_CcNode,
+                        p_CcNode->keyAndNextEngineParams[i].p_StatsObj);
 
     if (!LIST_IsEmpty(&p_CcNode->availableStatsLst))
     {
-        t_Handle    h_FmMuram = FmPcdGetMuramHandle(p_CcNode->h_FmPcd);
+        t_Handle h_FmMuram = FmPcdGetMuramHandle(p_CcNode->h_FmPcd);
         ASSERT_COND(h_FmMuram);
 
         FreeStatObjects(&p_CcNode->availableStatsLst, h_FmMuram);
@@ -1253,7 +1309,8 @@ static void DeleteTree(t_FmPcdCcTree *p_FmPcdTree, t_FmPcd *p_FmPcd)
     {
         if (p_FmPcdTree->ccTreeBaseAddr)
         {
-            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcd), UINT_TO_PTR(p_FmPcdTree->ccTreeBaseAddr));
+            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcd),
+                             UINT_TO_PTR(p_FmPcdTree->ccTreeBaseAddr));
             p_FmPcdTree->ccTreeBaseAddr = 0;
         }
 
@@ -1263,38 +1320,50 @@ static void DeleteTree(t_FmPcdCcTree *p_FmPcdTree, t_FmPcd *p_FmPcd)
     }
 }
 
-static void  GetCcExtractKeySize(uint8_t parseCodeRealSize, uint8_t *parseCodeCcSize)
+static void GetCcExtractKeySize(uint8_t parseCodeRealSize,
+                                uint8_t *parseCodeCcSize)
 {
     if ((parseCodeRealSize > 0) && (parseCodeRealSize < 2))
         *parseCodeCcSize = 1;
-    else if (parseCodeRealSize == 2)
-        *parseCodeCcSize = 2;
-    else if ((parseCodeRealSize > 2)    && (parseCodeRealSize <= 4))
-        *parseCodeCcSize = 4;
-    else if ((parseCodeRealSize > 4)    && (parseCodeRealSize <= 8))
-        *parseCodeCcSize = 8;
-    else if ((parseCodeRealSize > 8)    && (parseCodeRealSize <= 16))
-        *parseCodeCcSize = 16;
-    else if ((parseCodeRealSize  > 16)  && (parseCodeRealSize <= 24))
-        *parseCodeCcSize = 24;
-    else if ((parseCodeRealSize  > 24)  && (parseCodeRealSize <= 32))
-        *parseCodeCcSize = 32;
-    else if ((parseCodeRealSize  > 32)  && (parseCodeRealSize <= 40))
-        *parseCodeCcSize = 40;
-    else if ((parseCodeRealSize  > 40)  && (parseCodeRealSize <= 48))
-        *parseCodeCcSize = 48;
-    else if ((parseCodeRealSize  > 48)  && (parseCodeRealSize <= 56))
-        *parseCodeCcSize = 56;
     else
-        *parseCodeCcSize = 0;
+        if (parseCodeRealSize == 2)
+            *parseCodeCcSize = 2;
+        else
+            if ((parseCodeRealSize > 2) && (parseCodeRealSize <= 4))
+                *parseCodeCcSize = 4;
+            else
+                if ((parseCodeRealSize > 4) && (parseCodeRealSize <= 8))
+                    *parseCodeCcSize = 8;
+                else
+                    if ((parseCodeRealSize > 8) && (parseCodeRealSize <= 16))
+                        *parseCodeCcSize = 16;
+                    else
+                        if ((parseCodeRealSize > 16)
+                                && (parseCodeRealSize <= 24))
+                            *parseCodeCcSize = 24;
+                        else
+                            if ((parseCodeRealSize > 24)
+                                    && (parseCodeRealSize <= 32))
+                                *parseCodeCcSize = 32;
+                            else
+                                if ((parseCodeRealSize > 32)
+                                        && (parseCodeRealSize <= 40))
+                                    *parseCodeCcSize = 40;
+                                else
+                                    if ((parseCodeRealSize > 40)
+                                            && (parseCodeRealSize <= 48))
+                                        *parseCodeCcSize = 48;
+                                    else
+                                        if ((parseCodeRealSize > 48)
+                                                && (parseCodeRealSize <= 56))
+                                            *parseCodeCcSize = 56;
+                                        else
+                                            *parseCodeCcSize = 0;
 }
 
-static void  GetSizeHeaderField(e_NetHeaderType     hdr,
-                                e_FmPcdHdrIndex     index,
-                                t_FmPcdFields       field,
-                                uint8_t             *parseCodeRealSize)
+static void GetSizeHeaderField(e_NetHeaderType hdr, t_FmPcdFields field,
+		                       uint8_t *parseCodeRealSize)
 {
-    UNUSED(index);
     switch (hdr)
     {
         case (HEADER_TYPE_ETH):
@@ -1336,7 +1405,7 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
         case (HEADER_TYPE_VLAN):
             switch (field.vlan)
             {
-               case (NET_HEADER_FIELD_VLAN_TCI):
+                case (NET_HEADER_FIELD_VLAN_TCI):
                     *parseCodeRealSize = 2;
                     break;
 
@@ -1374,7 +1443,8 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
                     *parseCodeRealSize = 1;
                     break;
 
-                case (NET_HEADER_FIELD_IPv4_DST_IP | NET_HEADER_FIELD_IPv4_SRC_IP):
+                case (NET_HEADER_FIELD_IPv4_DST_IP
+                        | NET_HEADER_FIELD_IPv4_SRC_IP):
                     *parseCodeRealSize = 8;
                     break;
 
@@ -1392,18 +1462,34 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
         case (HEADER_TYPE_IPv6):
             switch (field.ipv6)
             {
-                case (NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
-                   *parseCodeRealSize = 4;
-                   break;
+                case (NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL
+                        | NET_HEADER_FIELD_IPv6_TC):
+                    *parseCodeRealSize = 4;
+                    break;
 
                 case (NET_HEADER_FIELD_IPv6_NEXT_HDR):
                 case (NET_HEADER_FIELD_IPv6_HOP_LIMIT):
-                   *parseCodeRealSize = 1;
+                    *parseCodeRealSize = 1;
                     break;
 
                 case (NET_HEADER_FIELD_IPv6_DST_IP):
                 case (NET_HEADER_FIELD_IPv6_SRC_IP):
-                   *parseCodeRealSize = 16;
+                    *parseCodeRealSize = 16;
+                    break;
+
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported5"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+            break;
+
+        case (HEADER_TYPE_IP):
+            switch (field.ip)
+            {
+                case (NET_HEADER_FIELD_IP_DSCP):
+                case (NET_HEADER_FIELD_IP_PROTO):
+                    *parseCodeRealSize = 1;
                     break;
 
                 default:
@@ -1413,26 +1499,11 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             }
             break;
 
-       case (HEADER_TYPE_IP):
-           switch (field.ip)
-           {
-               case (NET_HEADER_FIELD_IP_DSCP):
-               case (NET_HEADER_FIELD_IP_PROTO):
-                   *parseCodeRealSize = 1;
-                   break;
-
-               default:
-                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported5"));
-                   *parseCodeRealSize = CC_SIZE_ILLEGAL;
-                   break;
-           }
-           break;
-
-       case (HEADER_TYPE_GRE):
+        case (HEADER_TYPE_GRE):
             switch (field.gre)
             {
-                case ( NET_HEADER_FIELD_GRE_TYPE):
-                   *parseCodeRealSize = 2;
+                case (NET_HEADER_FIELD_GRE_TYPE):
+                    *parseCodeRealSize = 2;
                     break;
 
                 default:
@@ -1446,16 +1517,17 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             switch (field.minencap)
             {
                 case (NET_HEADER_FIELD_MINENCAP_TYPE):
-                   *parseCodeRealSize = 1;
+                    *parseCodeRealSize = 1;
                     break;
 
                 case (NET_HEADER_FIELD_MINENCAP_DST_IP):
                 case (NET_HEADER_FIELD_MINENCAP_SRC_IP):
-                  *parseCodeRealSize = 4;
+                    *parseCodeRealSize = 4;
                     break;
 
-                 case (NET_HEADER_FIELD_MINENCAP_SRC_IP | NET_HEADER_FIELD_MINENCAP_DST_IP):
-                  *parseCodeRealSize = 8;
+                case (NET_HEADER_FIELD_MINENCAP_SRC_IP
+                        | NET_HEADER_FIELD_MINENCAP_DST_IP):
+                    *parseCodeRealSize = 8;
                     break;
 
                 default:
@@ -1470,11 +1542,12 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             {
                 case (NET_HEADER_FIELD_TCP_PORT_SRC):
                 case (NET_HEADER_FIELD_TCP_PORT_DST):
-                   *parseCodeRealSize = 2;
+                    *parseCodeRealSize = 2;
                     break;
 
-                 case (NET_HEADER_FIELD_TCP_PORT_SRC | NET_HEADER_FIELD_TCP_PORT_DST):
-                  *parseCodeRealSize = 4;
+                case (NET_HEADER_FIELD_TCP_PORT_SRC
+                        | NET_HEADER_FIELD_TCP_PORT_DST):
+                    *parseCodeRealSize = 4;
                     break;
 
                 default:
@@ -1489,11 +1562,12 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             {
                 case (NET_HEADER_FIELD_UDP_PORT_SRC):
                 case (NET_HEADER_FIELD_UDP_PORT_DST):
-                   *parseCodeRealSize = 2;
+                    *parseCodeRealSize = 2;
                     break;
 
-                 case (NET_HEADER_FIELD_UDP_PORT_SRC | NET_HEADER_FIELD_UDP_PORT_DST):
-                  *parseCodeRealSize = 4;
+                case (NET_HEADER_FIELD_UDP_PORT_SRC
+                        | NET_HEADER_FIELD_UDP_PORT_DST):
+                    *parseCodeRealSize = 4;
                     break;
 
                 default:
@@ -1503,26 +1577,28 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             }
             break;
 
-       default:
+        default:
             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported10"));
             *parseCodeRealSize = CC_SIZE_ILLEGAL;
             break;
     }
 }
 
-t_Error ValidateNextEngineParams(t_Handle                   h_FmPcd,
-                                 t_FmPcdCcNextEngineParams  *p_FmPcdCcNextEngineParams,
-                                 e_FmPcdCcStatsMode         statsMode)
+t_Error ValidateNextEngineParams(
+        t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,
+        e_FmPcdCcStatsMode statsMode)
 {
-    uint16_t    absoluteProfileId;
-    t_Error     err = E_OK;
-    uint8_t     relativeSchemeId;
+    uint16_t absoluteProfileId;
+    t_Error err = E_OK;
+    uint8_t relativeSchemeId;
 
-    if ((statsMode == e_FM_PCD_CC_STATS_MODE_NONE) &&
-        (p_FmPcdCcNextEngineParams->statisticsEn))
-        RETURN_ERROR(MAJOR, E_CONFLICT,
-                     ("Statistics are requested for a key, but statistics mode was set"
-                      "to 'NONE' upon initialization"));
+    if ((statsMode == e_FM_PCD_CC_STATS_MODE_NONE)
+            && (p_FmPcdCcNextEngineParams->statisticsEn))
+        RETURN_ERROR(
+                MAJOR,
+                E_CONFLICT,
+                ("Statistics are requested for a key, but statistics mode was set"
+                "to 'NONE' upon initialization"));
 
     switch (p_FmPcdCcNextEngineParams->nextEngine)
     {
@@ -1531,25 +1607,40 @@ t_Error ValidateNextEngineParams(t_Handle                   h_FmPcd,
             break;
 
         case (e_FM_PCD_DONE):
-            if ((p_FmPcdCcNextEngineParams->params.enqueueParams.action == e_FM_PCD_ENQ_FRAME) &&
-                p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
+            if ((p_FmPcdCcNextEngineParams->params.enqueueParams.action
+                    == e_FM_PCD_ENQ_FRAME)
+                    && p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
             {
                 if (!p_FmPcdCcNextEngineParams->params.enqueueParams.newFqid)
-                    RETURN_ERROR(MAJOR, E_CONFLICT, ("When overrideFqid is set, newFqid must not be zero"));
-                if (p_FmPcdCcNextEngineParams->params.enqueueParams.newFqid & ~0x00FFFFFF)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidForCtrlFlow must be between 1 and 2^24-1"));
+                    RETURN_ERROR(
+                            MAJOR,
+                            E_CONFLICT,
+                            ("When overrideFqid is set, newFqid must not be zero"));
+                if (p_FmPcdCcNextEngineParams->params.enqueueParams.newFqid
+                        & ~0x00FFFFFF)
+                    RETURN_ERROR(
+                            MAJOR, E_INVALID_VALUE,
+                            ("fqidForCtrlFlow must be between 1 and 2^24-1"));
             }
             break;
 
         case (e_FM_PCD_KG):
-            relativeSchemeId = FmPcdKgGetRelativeSchemeId(h_FmPcd,
-                                                          FmPcdKgGetSchemeId(p_FmPcdCcNextEngineParams->params.kgParams.h_DirectScheme));
+            relativeSchemeId =
+                    FmPcdKgGetRelativeSchemeId(
+                            h_FmPcd,
+                            FmPcdKgGetSchemeId(
+                                    p_FmPcdCcNextEngineParams->params.kgParams.h_DirectScheme));
             if (relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
                 RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
-            if (!FmPcdKgIsSchemeValidSw(p_FmPcdCcNextEngineParams->params.kgParams.h_DirectScheme))
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("not valid schemeIndex in KG next engine param"));
+            if (!FmPcdKgIsSchemeValidSw(
+                    p_FmPcdCcNextEngineParams->params.kgParams.h_DirectScheme))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                             ("not valid schemeIndex in KG next engine param"));
             if (!KgIsSchemeAlwaysDirect(h_FmPcd, relativeSchemeId))
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("CC Node may point only to a scheme that is always direct."));
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_STATE,
+                        ("CC Node may point only to a scheme that is always direct."));
             break;
 
         case (e_FM_PCD_PLCR):
@@ -1558,15 +1649,19 @@ t_Error ValidateNextEngineParams(t_Handle                   h_FmPcd,
                 /* if private policer profile, it may be uninitialized yet, therefore no checks are done at this stage */
                 if (p_FmPcdCcNextEngineParams->params.plcrParams.sharedProfile)
                 {
-                    err = FmPcdPlcrGetAbsoluteIdByProfileParams(h_FmPcd,
-                                                        e_FM_PCD_PLCR_SHARED,
-                                                        NULL,
-                                                        p_FmPcdCcNextEngineParams->params.plcrParams.newRelativeProfileId,
-                                                        &absoluteProfileId);
+                    err =
+                            FmPcdPlcrGetAbsoluteIdByProfileParams(
+                                    h_FmPcd,
+                                    e_FM_PCD_PLCR_SHARED,
+                                    NULL,
+                                    p_FmPcdCcNextEngineParams->params.plcrParams.newRelativeProfileId,
+                                    &absoluteProfileId);
                     if (err)
-                        RETURN_ERROR(MAJOR, err, ("Shared profile offset is out of range"));
+                        RETURN_ERROR(MAJOR, err,
+                                     ("Shared profile offset is out of range"));
                     if (!FmPcdPlcrIsProfileValid(h_FmPcd, absoluteProfileId))
-                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid profile"));
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                                     ("Invalid profile"));
                 }
             }
             break;
@@ -1575,43 +1670,40 @@ t_Error ValidateNextEngineParams(t_Handle                   h_FmPcd,
             p_FmPcdCcNextEngineParams->nextEngine = e_FM_PCD_CC;
         case (e_FM_PCD_CC):
             if (!p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)
-                RETURN_ERROR(MAJOR, E_NULL_POINTER, ("handler to next Node is NULL"));
+                RETURN_ERROR(MAJOR, E_NULL_POINTER,
+                             ("handler to next Node is NULL"));
             break;
 
 #if (DPAA_VERSION >= 11)
-         case (e_FM_PCD_FR):
+        case (e_FM_PCD_FR):
             if (!p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic)
                 err = E_NOT_SUPPORTED;
             break;
 #endif /* (DPAA_VERSION >= 11) */
 
         default:
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine is not correct"));
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                         ("Next engine is not correct"));
     }
 
 
     return err;
 }
 
-static uint8_t GetGenParseCode(t_Handle             h_FmPcd,
-                               e_FmPcdExtractFrom   src,
-                               uint32_t             offset,
-                               bool                 glblMask,
-                               uint8_t              *parseArrayOffset,
-                               bool                 fromIc,
-                               ccPrivateInfo_t      icCode)
+static uint8_t GetGenParseCode(e_FmPcdExtractFrom src,
+                               uint32_t offset, bool glblMask,
+                               uint8_t *parseArrayOffset, bool fromIc,
+                               ccPrivateInfo_t icCode)
 {
-    UNUSED(h_FmPcd);
-
     if (!fromIc)
     {
         switch (src)
         {
             case (e_FM_PCD_EXTRACT_FROM_FRAME_START):
                 if (glblMask)
-                    return CC_PC_GENERIC_WITH_MASK ;
+                    return CC_PC_GENERIC_WITH_MASK;
                 else
-                  return CC_PC_GENERIC_WITHOUT_MASK;
+                    return CC_PC_GENERIC_WITHOUT_MASK;
 
             case (e_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE):
                 *parseArrayOffset = CC_PC_PR_NEXT_HEADER_OFFSET;
@@ -1630,20 +1722,20 @@ static uint8_t GetGenParseCode(t_Handle             h_FmPcd,
         switch (icCode)
         {
             case (CC_PRIVATE_INFO_IC_KEY_EXACT_MATCH):
-                 *parseArrayOffset = 0x50;
-                 return CC_PC_GENERIC_IC_GMASK;
+                *parseArrayOffset = 0x50;
+                return CC_PC_GENERIC_IC_GMASK;
 
             case (CC_PRIVATE_INFO_IC_HASH_EXACT_MATCH):
-               *parseArrayOffset = 0x48;
-               return CC_PC_GENERIC_IC_GMASK;
+                *parseArrayOffset = 0x48;
+                return CC_PC_GENERIC_IC_GMASK;
 
             case (CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP):
                 *parseArrayOffset = 0x48;
-                 return CC_PC_GENERIC_IC_HASH_INDEXED;
+                return CC_PC_GENERIC_IC_HASH_INDEXED;
 
             case (CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP):
                 *parseArrayOffset = 0x16;
-                 return CC_PC_GENERIC_IC_HASH_INDEXED;
+                return CC_PC_GENERIC_IC_HASH_INDEXED;
 
             default:
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 'extract from' src"));
@@ -1654,9 +1746,8 @@ static uint8_t GetGenParseCode(t_Handle             h_FmPcd,
     return CC_PC_ILLEGAL;
 }
 
-static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
-                                     e_FmPcdHdrIndex    index,
-                                     t_FmPcdFields      field)
+static uint8_t GetFullFieldParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex index,
+                                     t_FmPcdFields field)
 {
     switch (hdr)
     {
@@ -1682,7 +1773,8 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
             switch (field.vlan)
             {
                 case (NET_HEADER_FIELD_VLAN_TCI):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_TCI1;
                     if (index == e_FM_PCD_HDR_INDEX_LAST)
                         return CC_PC_FF_TCI2;
@@ -1697,7 +1789,8 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
             switch (field.mpls)
             {
                 case (NET_HEADER_FIELD_MPLS_LABEL_STACK):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_MPLS1;
                     if (index == e_FM_PCD_HDR_INDEX_LAST)
                         return CC_PC_FF_MPLS_LAST;
@@ -1712,35 +1805,41 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
             switch (field.ipv4)
             {
                 case (NET_HEADER_FIELD_IPv4_DST_IP):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV4DST1;
                     if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV4DST2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return CC_PC_ILLEGAL;
                 case (NET_HEADER_FIELD_IPv4_TOS):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV4IPTOS_TC1;
                     if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV4IPTOS_TC2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return CC_PC_ILLEGAL;
                 case (NET_HEADER_FIELD_IPv4_PROTO):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV4PTYPE1;
-                    if(index == e_FM_PCD_HDR_INDEX_2)
+                    if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV4PTYPE2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return CC_PC_ILLEGAL;
                 case (NET_HEADER_FIELD_IPv4_SRC_IP):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV4SRC1;
                     if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV4SRC2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return CC_PC_ILLEGAL;
-                case (NET_HEADER_FIELD_IPv4_SRC_IP | NET_HEADER_FIELD_IPv4_DST_IP):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_IPv4_SRC_IP
+                        | NET_HEADER_FIELD_IPv4_DST_IP):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV4SRC1_IPV4DST1;
                     if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV4SRC2_IPV4DST2;
@@ -1754,10 +1853,12 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
             }
 
         case (HEADER_TYPE_IPv6):
-             switch (field.ipv6)
+            switch (field.ipv6)
             {
-                case (NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL
+                        | NET_HEADER_FIELD_IPv6_TC):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1;
                     if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2;
@@ -1765,7 +1866,8 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                     return CC_PC_ILLEGAL;
 
                 case (NET_HEADER_FIELD_IPv6_NEXT_HDR):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV6PTYPE1;
                     if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV6PTYPE2;
@@ -1775,7 +1877,8 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                     return CC_PC_ILLEGAL;
 
                 case (NET_HEADER_FIELD_IPv6_DST_IP):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV6DST1;
                     if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV6DST2;
@@ -1783,7 +1886,8 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                     return CC_PC_ILLEGAL;
 
                 case (NET_HEADER_FIELD_IPv6_SRC_IP):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV6SRC1;
                     if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV6SRC2;
@@ -1798,113 +1902,115 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                     return CC_PC_ILLEGAL;
             }
 
-       case (HEADER_TYPE_IP):
-           switch (field.ip)
-           {
-               case (NET_HEADER_FIELD_IP_DSCP):
-                   if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
-                       return CC_PC_FF_IPDSCP;
-                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP index"));
-                   return CC_PC_ILLEGAL;
-
-               case (NET_HEADER_FIELD_IP_PROTO):
-                   if (index == e_FM_PCD_HDR_INDEX_LAST)
-                       return CC_PC_FF_IPPID;
-                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP index"));
-                   return CC_PC_ILLEGAL;
-
-               default:
-                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-                   return CC_PC_ILLEGAL;
-           }
-
-       case (HEADER_TYPE_GRE):
-           switch (field.gre)
-           {
-               case (NET_HEADER_FIELD_GRE_TYPE):
-                   return CC_PC_FF_GREPTYPE;
-
-               default:
-                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-                   return CC_PC_ILLEGAL;
-           }
-
-       case (HEADER_TYPE_MINENCAP):
-           switch (field.minencap)
-           {
-               case (NET_HEADER_FIELD_MINENCAP_TYPE):
-                   return CC_PC_FF_MINENCAP_PTYPE;
-
-               case (NET_HEADER_FIELD_MINENCAP_DST_IP):
-                   return CC_PC_FF_MINENCAP_IPDST;
-
-               case (NET_HEADER_FIELD_MINENCAP_SRC_IP):
-                   return CC_PC_FF_MINENCAP_IPSRC;
-
-               case (NET_HEADER_FIELD_MINENCAP_SRC_IP | NET_HEADER_FIELD_MINENCAP_DST_IP):
-                   return CC_PC_FF_MINENCAP_IPSRC_IPDST;
-
-               default:
+        case (HEADER_TYPE_IP):
+            switch (field.ip)
+            {
+                case (NET_HEADER_FIELD_IP_DSCP):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE)
+                            || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPDSCP;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP index"));
+                    return CC_PC_ILLEGAL;
+
+                case (NET_HEADER_FIELD_IP_PROTO):
+                    if (index == e_FM_PCD_HDR_INDEX_LAST)
+                        return CC_PC_FF_IPPID;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP index"));
+                    return CC_PC_ILLEGAL;
+
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
+
+        case (HEADER_TYPE_GRE):
+            switch (field.gre)
+            {
+                case (NET_HEADER_FIELD_GRE_TYPE):
+                    return CC_PC_FF_GREPTYPE;
+
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
+
+        case (HEADER_TYPE_MINENCAP):
+            switch (field.minencap)
+            {
+                case (NET_HEADER_FIELD_MINENCAP_TYPE):
+                    return CC_PC_FF_MINENCAP_PTYPE;
+
+                case (NET_HEADER_FIELD_MINENCAP_DST_IP):
+                    return CC_PC_FF_MINENCAP_IPDST;
+
+                case (NET_HEADER_FIELD_MINENCAP_SRC_IP):
+                    return CC_PC_FF_MINENCAP_IPSRC;
+
+                case (NET_HEADER_FIELD_MINENCAP_SRC_IP
+                        | NET_HEADER_FIELD_MINENCAP_DST_IP):
+                    return CC_PC_FF_MINENCAP_IPSRC_IPDST;
+
+                default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
-           }
+            }
 
-       case (HEADER_TYPE_TCP):
-           switch (field.tcp)
-           {
-               case (NET_HEADER_FIELD_TCP_PORT_SRC):
-                   return CC_PC_FF_L4PSRC;
+        case (HEADER_TYPE_TCP):
+            switch (field.tcp)
+            {
+                case (NET_HEADER_FIELD_TCP_PORT_SRC):
+                    return CC_PC_FF_L4PSRC;
 
-               case (NET_HEADER_FIELD_TCP_PORT_DST):
-                   return CC_PC_FF_L4PDST;
+                case (NET_HEADER_FIELD_TCP_PORT_DST):
+                    return CC_PC_FF_L4PDST;
 
-               case (NET_HEADER_FIELD_TCP_PORT_DST | NET_HEADER_FIELD_TCP_PORT_SRC):
-                   return CC_PC_FF_L4PSRC_L4PDST;
+                case (NET_HEADER_FIELD_TCP_PORT_DST
+                        | NET_HEADER_FIELD_TCP_PORT_SRC):
+                    return CC_PC_FF_L4PSRC_L4PDST;
 
-               default:
-                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-                   return CC_PC_ILLEGAL;
-           }
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
 
-       case (HEADER_TYPE_PPPoE):
-           switch (field.pppoe)
-           {
-               case (NET_HEADER_FIELD_PPPoE_PID):
-                   return CC_PC_FF_PPPPID;
+        case (HEADER_TYPE_PPPoE):
+            switch (field.pppoe)
+            {
+                case (NET_HEADER_FIELD_PPPoE_PID):
+                    return CC_PC_FF_PPPPID;
 
-               default:
-                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-                   return CC_PC_ILLEGAL;
-           }
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
 
-       case (HEADER_TYPE_UDP):
-           switch (field.udp)
-           {
-               case (NET_HEADER_FIELD_UDP_PORT_SRC):
-                   return CC_PC_FF_L4PSRC;
+        case (HEADER_TYPE_UDP):
+            switch (field.udp)
+            {
+                case (NET_HEADER_FIELD_UDP_PORT_SRC):
+                    return CC_PC_FF_L4PSRC;
 
-               case (NET_HEADER_FIELD_UDP_PORT_DST):
-                   return CC_PC_FF_L4PDST;
+                case (NET_HEADER_FIELD_UDP_PORT_DST):
+                    return CC_PC_FF_L4PDST;
 
-               case (NET_HEADER_FIELD_UDP_PORT_DST | NET_HEADER_FIELD_UDP_PORT_SRC):
-                   return CC_PC_FF_L4PSRC_L4PDST;
+                case (NET_HEADER_FIELD_UDP_PORT_DST
+                        | NET_HEADER_FIELD_UDP_PORT_SRC):
+                    return CC_PC_FF_L4PSRC_L4PDST;
 
-               default:
-                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-                   return CC_PC_ILLEGAL;
-           }
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
 
         default:
-           REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-           return CC_PC_ILLEGAL;
+            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+            return CC_PC_ILLEGAL;
     }
 }
 
-static uint8_t GetPrParseCode(e_NetHeaderType   hdr,
-                              e_FmPcdHdrIndex   hdrIndex,
-                              uint32_t          offset,
-                              bool              glblMask,
-                              uint8_t           *parseArrayOffset)
+static uint8_t GetPrParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex hdrIndex,
+                              uint32_t offset, bool glblMask,
+                              uint8_t *parseArrayOffset)
 {
     bool offsetRelevant = FALSE;
 
@@ -1944,28 +2050,32 @@ static uint8_t GetPrParseCode(e_NetHeaderType   hdr,
             break;
 
         case (HEADER_TYPE_MPLS):
-            if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
-                    *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
-            else if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
-                    *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
+            if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE)
+                    || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
             else
-            {
-                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS header index"));
-                return CC_PC_ILLEGAL;
-            }
+                if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                    *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
+                else
+                {
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS header index"));
+                    return CC_PC_ILLEGAL;
+                }
             break;
 
         case (HEADER_TYPE_IPv4):
         case (HEADER_TYPE_IPv6):
-            if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+            if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE)
+                    || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                 *parseArrayOffset = CC_PC_PR_IP1_OFFSET;
-            else if (hdrIndex == e_FM_PCD_HDR_INDEX_2)
-                *parseArrayOffset = CC_PC_PR_IP_LAST_OFFSET;
             else
-            {
-                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header index"));
-                return CC_PC_ILLEGAL;
-            }
+                if (hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                    *parseArrayOffset = CC_PC_PR_IP_LAST_OFFSET;
+                else
+                {
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header index"));
+                    return CC_PC_ILLEGAL;
+                }
             break;
 
         case (HEADER_TYPE_MINENCAP):
@@ -1988,7 +2098,7 @@ static uint8_t GetPrParseCode(e_NetHeaderType   hdr,
         default:
             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header for this type of operation"));
             return CC_PC_ILLEGAL;
-     }
+    }
 
     if (offsetRelevant)
         return CC_PR_OFFSET;
@@ -1996,11 +2106,9 @@ static uint8_t GetPrParseCode(e_NetHeaderType   hdr,
         return CC_PR_WITHOUT_OFFSET;
 }
 
-static uint8_t GetFieldParseCode(e_NetHeaderType    hdr,
-                                 t_FmPcdFields      field,
-                                 uint32_t           offset,
-                                 uint8_t            *parseArrayOffset,
-                                 e_FmPcdHdrIndex    hdrIndex)
+static uint8_t GetFieldParseCode(e_NetHeaderType hdr, t_FmPcdFields field,
+                                 uint32_t offset, uint8_t *parseArrayOffset,
+                                 e_FmPcdHdrIndex hdrIndex)
 {
     bool offsetRelevant = FALSE;
 
@@ -2010,7 +2118,8 @@ static uint8_t GetFieldParseCode(e_NetHeaderType    hdr,
     switch (hdr)
     {
         case (HEADER_TYPE_NONE):
-                ASSERT_COND(FALSE);
+            ASSERT_COND(FALSE);
+                break;
         case (HEADER_TYPE_ETH):
             switch (field.eth)
             {
@@ -2028,10 +2137,12 @@ static uint8_t GetFieldParseCode(e_NetHeaderType    hdr,
             switch (field.vlan)
             {
                 case (NET_HEADER_FIELD_VLAN_TCI):
-                    if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE)
+                            || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                         *parseArrayOffset = CC_PC_PR_VLAN1_OFFSET;
-                    else if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
-                        *parseArrayOffset = CC_PC_PR_VLAN2_OFFSET;
+                    else
+                        if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                            *parseArrayOffset = CC_PC_PR_VLAN2_OFFSET;
                     break;
 
                 default:
@@ -2051,16 +2162,16 @@ static uint8_t GetFieldParseCode(e_NetHeaderType    hdr,
         return CC_PR_WITHOUT_OFFSET;
 }
 
-static void FillAdOfTypeResult(t_Handle                    h_Ad,
-                               t_FmPcdCcStatsParams        *p_FmPcdCcStatsParams,
-                               t_FmPcd                     *p_FmPcd,
-                               t_FmPcdCcNextEngineParams   *p_CcNextEngineParams)
+static void FillAdOfTypeResult(t_Handle h_Ad,
+                               t_FmPcdCcStatsParams *p_FmPcdCcStatsParams,
+                               t_FmPcd *p_FmPcd,
+                               t_FmPcdCcNextEngineParams *p_CcNextEngineParams)
 {
-    t_AdOfTypeResult    *p_AdResult = (t_AdOfTypeResult *)h_Ad;
-    t_Handle            h_TmpAd;
-    uint32_t            tmp = 0, tmpNia = 0;
-    uint16_t            profileId;
-    t_Handle            p_AdNewPtr = NULL;
+    t_AdOfTypeResult *p_AdResult = (t_AdOfTypeResult *)h_Ad;
+    t_Handle h_TmpAd;
+    uint32_t tmp = 0, tmpNia = 0;
+    uint16_t profileId;
+    t_Handle p_AdNewPtr = NULL;
 
     /* There are 3 cases handled in this routine of building a "result" type AD.
      * Case 1: No Manip. The action descriptor is built within the match table.
@@ -2096,17 +2207,13 @@ static void FillAdOfTypeResult(t_Handle                    h_Ad,
         p_AdResult = h_Ad;
 
         /* Init statistics Ad and connect current lookup AD as 'next action' from statistics Ad */
-        UpdateStatsAd(p_FmPcdCcStatsParams,
-                      h_Ad,
-                      p_FmPcd->physicalMuramBase);
+        UpdateStatsAd(p_FmPcdCcStatsParams, h_Ad, p_FmPcd->physicalMuramBase);
     }
 
     /* Create manip and return p_AdNewPtr to either a new descriptor or NULL */
     if (p_CcNextEngineParams->h_Manip)
         FmPcdManipUpdateAdResultForCc(p_CcNextEngineParams->h_Manip,
-                                      p_CcNextEngineParams,
-                                      h_Ad,
-                                      &p_AdNewPtr);
+                                      p_CcNextEngineParams, h_Ad, &p_AdNewPtr);
 
     /* if (p_AdNewPtr = NULL) --> Done. (case (3)) */
     if (p_AdNewPtr)
@@ -2115,24 +2222,30 @@ static void FillAdOfTypeResult(t_Handle                    h_Ad,
         switch (p_CcNextEngineParams->nextEngine)
         {
             case (e_FM_PCD_DONE):
-                if (p_CcNextEngineParams->params.enqueueParams.action == e_FM_PCD_ENQ_FRAME)
+                if (p_CcNextEngineParams->params.enqueueParams.action
+                        == e_FM_PCD_ENQ_FRAME)
                 {
                     if (p_CcNextEngineParams->params.enqueueParams.overrideFqid)
                     {
-                       tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
-                       tmp |= p_CcNextEngineParams->params.enqueueParams.newFqid;
+                        tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
+                        tmp |=
+                                p_CcNextEngineParams->params.enqueueParams.newFqid;
 #if (DPAA_VERSION >= 11)
-                       tmp |= (p_CcNextEngineParams->params.enqueueParams.newRelativeStorageProfileId & FM_PCD_AD_RESULT_VSP_MASK) << FM_PCD_AD_RESULT_VSP_SHIFT;
+                        tmp |=
+                                (p_CcNextEngineParams->params.enqueueParams.newRelativeStorageProfileId
+                                        & FM_PCD_AD_RESULT_VSP_MASK)
+                                        << FM_PCD_AD_RESULT_VSP_SHIFT;
 #endif /* (DPAA_VERSION >= 11) */
                     }
                     else
                     {
-                       tmp = FM_PCD_AD_RESULT_DATA_FLOW_TYPE;
-                       tmp |= FM_PCD_AD_RESULT_PLCR_DIS;
+                        tmp = FM_PCD_AD_RESULT_DATA_FLOW_TYPE;
+                        tmp |= FM_PCD_AD_RESULT_PLCR_DIS;
                     }
                 }
 
-                if (p_CcNextEngineParams->params.enqueueParams.action == e_FM_PCD_DROP_FRAME)
+                if (p_CcNextEngineParams->params.enqueueParams.action
+                        == e_FM_PCD_DROP_FRAME)
                     tmpNia |= GET_NIA_BMI_AC_DISCARD_FRAME(p_FmPcd);
                 else
                     tmpNia |= GET_NIA_BMI_AC_ENQ_FRAME(p_FmPcd);
@@ -2144,7 +2257,10 @@ static void FillAdOfTypeResult(t_Handle                    h_Ad,
                     tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
                     tmp |= p_CcNextEngineParams->params.kgParams.newFqid;
 #if (DPAA_VERSION >= 11)
-                    tmp |= (p_CcNextEngineParams->params.kgParams.newRelativeStorageProfileId & FM_PCD_AD_RESULT_VSP_MASK) << FM_PCD_AD_RESULT_VSP_SHIFT;
+                    tmp |=
+                            (p_CcNextEngineParams->params.kgParams.newRelativeStorageProfileId
+                                    & FM_PCD_AD_RESULT_VSP_MASK)
+                                    << FM_PCD_AD_RESULT_VSP_SHIFT;
 #endif /* (DPAA_VERSION >= 11) */
                 }
                 else
@@ -2155,11 +2271,11 @@ static void FillAdOfTypeResult(t_Handle                    h_Ad,
                 tmpNia = NIA_KG_DIRECT;
                 tmpNia |= NIA_ENG_KG;
                 tmpNia |= NIA_KG_CC_EN;
-                tmpNia |= FmPcdKgGetSchemeId(p_CcNextEngineParams->params.kgParams.h_DirectScheme);
+                tmpNia |= FmPcdKgGetSchemeId(
+                        p_CcNextEngineParams->params.kgParams.h_DirectScheme);
                 break;
 
             case (e_FM_PCD_PLCR):
-                tmp = 0;
                 if (p_CcNextEngineParams->params.plcrParams.overrideParams)
                 {
                     tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
@@ -2168,36 +2284,45 @@ static void FillAdOfTypeResult(t_Handle                    h_Ad,
                     if (p_CcNextEngineParams->params.plcrParams.sharedProfile)
                     {
                         tmpNia |= NIA_PLCR_ABSOLUTE;
-                        FmPcdPlcrGetAbsoluteIdByProfileParams((t_Handle)p_FmPcd,
-                                                              e_FM_PCD_PLCR_SHARED,
-                                                              NULL,
-                                                              p_CcNextEngineParams->params.plcrParams.newRelativeProfileId,
-                                                              &profileId);
+                        FmPcdPlcrGetAbsoluteIdByProfileParams(
+                                (t_Handle)p_FmPcd,
+                                e_FM_PCD_PLCR_SHARED,
+                                NULL,
+                                p_CcNextEngineParams->params.plcrParams.newRelativeProfileId,
+                                &profileId);
                     }
                     else
-                        profileId = p_CcNextEngineParams->params.plcrParams.newRelativeProfileId;
+                        profileId =
+                                p_CcNextEngineParams->params.plcrParams.newRelativeProfileId;
 
                     tmp |= p_CcNextEngineParams->params.plcrParams.newFqid;
 #if (DPAA_VERSION >= 11)
-                    tmp |= (p_CcNextEngineParams->params.plcrParams.newRelativeStorageProfileId & FM_PCD_AD_RESULT_VSP_MASK)<< FM_PCD_AD_RESULT_VSP_SHIFT;
+                    tmp |=
+                            (p_CcNextEngineParams->params.plcrParams.newRelativeStorageProfileId
+                                    & FM_PCD_AD_RESULT_VSP_MASK)
+                                    << FM_PCD_AD_RESULT_VSP_SHIFT;
 #endif /* (DPAA_VERSION >= 11) */
-                    WRITE_UINT32(p_AdResult->plcrProfile,(uint32_t)((uint32_t)profileId << FM_PCD_AD_PROFILEID_FOR_CNTRL_SHIFT));
+                    WRITE_UINT32(
+                            p_AdResult->plcrProfile,
+                            (uint32_t)((uint32_t)profileId << FM_PCD_AD_PROFILEID_FOR_CNTRL_SHIFT));
                 }
                 else
-                   tmp = FM_PCD_AD_RESULT_DATA_FLOW_TYPE;
+                    tmp = FM_PCD_AD_RESULT_DATA_FLOW_TYPE;
 
-                tmpNia |= NIA_ENG_PLCR | p_CcNextEngineParams->params.plcrParams.newRelativeProfileId;
-               break;
+                tmpNia |=
+                        NIA_ENG_PLCR
+                                | p_CcNextEngineParams->params.plcrParams.newRelativeProfileId;
+                break;
 
             default:
                 return;
-        }
-        WRITE_UINT32(p_AdResult->fqid, tmp);
+        }WRITE_UINT32(p_AdResult->fqid, tmp);
 
         if (p_CcNextEngineParams->h_Manip)
         {
             tmp = GET_UINT32(p_AdResult->plcrProfile);
-            tmp |= (uint32_t)(XX_VirtToPhys(p_AdNewPtr) - (p_FmPcd->physicalMuramBase)) >> 4;
+            tmp |= (uint32_t)(XX_VirtToPhys(p_AdNewPtr)
+                    - (p_FmPcd->physicalMuramBase)) >> 4;
             WRITE_UINT32(p_AdResult->plcrProfile, tmp);
 
             tmpNia |= FM_PCD_AD_RESULT_EXTENDED_MODE;
@@ -2211,97 +2336,92 @@ static void FillAdOfTypeResult(t_Handle                    h_Ad,
     }
 }
 
-static t_Error CcUpdateParams(t_Handle      h_FmPcd,
-                              t_Handle      h_PcdParams,
-                              t_Handle      h_FmPort,
-                              t_Handle      h_FmTree,
-                              bool          validate)
+static t_Error CcUpdateParams(t_Handle h_FmPcd, t_Handle h_PcdParams,
+                              t_Handle h_FmPort, t_Handle h_FmTree,
+                              bool validate)
 {
-    t_FmPcdCcTree       *p_CcTree = (t_FmPcdCcTree *) h_FmTree;
+    t_FmPcdCcTree *p_CcTree = (t_FmPcdCcTree *)h_FmTree;
 
-    return CcUpdateParam(h_FmPcd,
-                         h_PcdParams,
-                         h_FmPort,
+    return CcUpdateParam(h_FmPcd, h_PcdParams, h_FmPort,
                          p_CcTree->keyAndNextEngineParams,
                          p_CcTree->numOfEntries,
-                         UINT_TO_PTR(p_CcTree->ccTreeBaseAddr),
-                         validate,
-                         0,
-                         h_FmTree,
-                         FALSE);
+                         UINT_TO_PTR(p_CcTree->ccTreeBaseAddr), validate, 0,
+                         h_FmTree, FALSE);
 }
 
 
-static void ReleaseNewNodeCommonPart(t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+static void ReleaseNewNodeCommonPart(
+        t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
     if (p_AdditionalInfo->p_AdTableNew)
-        FM_MURAM_FreeMem(FmPcdGetMuramHandle(((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd),
-                         p_AdditionalInfo->p_AdTableNew);
+        FM_MURAM_FreeMem(
+                FmPcdGetMuramHandle(
+                        ((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd),
+                p_AdditionalInfo->p_AdTableNew);
 
     if (p_AdditionalInfo->p_KeysMatchTableNew)
-        FM_MURAM_FreeMem(FmPcdGetMuramHandle(((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd),
-                         p_AdditionalInfo->p_KeysMatchTableNew);
+        FM_MURAM_FreeMem(
+                FmPcdGetMuramHandle(
+                        ((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd),
+                p_AdditionalInfo->p_KeysMatchTableNew);
 }
 
-static t_Error UpdateGblMask(t_FmPcdCcNode *p_CcNode,
-                             uint8_t       keySize,
-                             uint8_t       *p_Mask)
+static t_Error UpdateGblMask(t_FmPcdCcNode *p_CcNode, uint8_t keySize,
+                             uint8_t *p_Mask)
 {
     uint8_t prvGlblMaskSize = p_CcNode->glblMaskSize;
 
-    if (p_Mask &&
-        !p_CcNode->glblMaskUpdated &&
-        (keySize <= 4) &&
-        !p_CcNode->lclMask)
-    {
-        if (p_CcNode->parseCode &&
-            (p_CcNode->parseCode != CC_PC_FF_TCI1) &&
-            (p_CcNode->parseCode != CC_PC_FF_TCI2) &&
-            (p_CcNode->parseCode != CC_PC_FF_MPLS1) &&
-            (p_CcNode->parseCode != CC_PC_FF_MPLS_LAST) &&
-            (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC1) &&
-            (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC2) &&
-            (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1) &&
-            (p_CcNode->parseCode != CC_PC_FF_IPDSCP) &&
-            (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2) )
+    if (p_Mask && !p_CcNode->glblMaskUpdated && (keySize <= 4)
+            && !p_CcNode->lclMask)
+    {
+        if (p_CcNode->parseCode && (p_CcNode->parseCode != CC_PC_FF_TCI1)
+                && (p_CcNode->parseCode != CC_PC_FF_TCI2)
+                && (p_CcNode->parseCode != CC_PC_FF_MPLS1)
+                && (p_CcNode->parseCode != CC_PC_FF_MPLS_LAST)
+                && (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC1)
+                && (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC2)
+                && (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1)
+                && (p_CcNode->parseCode != CC_PC_FF_IPDSCP)
+                && (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2))
         {
             p_CcNode->glblMaskSize = 0;
             p_CcNode->lclMask = TRUE;
         }
         else
         {
-            memcpy(p_CcNode->p_GlblMask, p_Mask, (sizeof(uint8_t))*keySize);
+            memcpy(p_CcNode->p_GlblMask, p_Mask, (sizeof(uint8_t)) * keySize);
             p_CcNode->glblMaskUpdated = TRUE;
             p_CcNode->glblMaskSize = 4;
         }
     }
-    else if (p_Mask &&
-             (keySize <= 4) &&
-             !p_CcNode->lclMask)
-    {
-        if (memcmp(p_CcNode->p_GlblMask, p_Mask, keySize) != 0)
-        {
-            p_CcNode->lclMask = TRUE;
-            p_CcNode->glblMaskSize = 0;
-        }
-    }
-    else if (!p_Mask && p_CcNode->glblMaskUpdated && (keySize <= 4))
-    {
-        uint32_t tmpMask = 0xffffffff;
-        if (memcmp(p_CcNode->p_GlblMask, &tmpMask, 4) != 0)
+    else
+        if (p_Mask && (keySize <= 4) && !p_CcNode->lclMask)
         {
-            p_CcNode->lclMask = TRUE;
-            p_CcNode->glblMaskSize = 0;
+            if (memcmp(p_CcNode->p_GlblMask, p_Mask, keySize) != 0)
+            {
+                p_CcNode->lclMask = TRUE;
+                p_CcNode->glblMaskSize = 0;
+            }
         }
-    }
-    else if (p_Mask)
-    {
-        p_CcNode->lclMask = TRUE;
-        p_CcNode->glblMaskSize = 0;
-    }
+        else
+            if (!p_Mask && p_CcNode->glblMaskUpdated && (keySize <= 4))
+            {
+                uint32_t tmpMask = 0xffffffff;
+                if (memcmp(p_CcNode->p_GlblMask, &tmpMask, 4) != 0)
+                {
+                    p_CcNode->lclMask = TRUE;
+                    p_CcNode->glblMaskSize = 0;
+                }
+            }
+            else
+                if (p_Mask)
+                {
+                    p_CcNode->lclMask = TRUE;
+                    p_CcNode->glblMaskSize = 0;
+                }
 
     /* In static mode (maxNumOfKeys > 0), local mask is supported
-       only is mask support was enabled at initialization */
+     only is mask support was enabled at initialization */
     if (p_CcNode->maxNumOfKeys && (!p_CcNode->maskSupport) && p_CcNode->lclMask)
     {
         p_CcNode->lclMask = FALSE;
@@ -2312,26 +2432,26 @@ static t_Error UpdateGblMask(t_FmPcdCcNode *p_CcNode,
     return E_OK;
 }
 
-static __inline__ t_Handle GetNewAd(t_Handle  h_FmPcdCcNodeOrTree, bool isTree)
+static __inline__ t_Handle GetNewAd(t_Handle h_FmPcdCcNodeOrTree, bool isTree)
 {
-    t_FmPcd         *p_FmPcd;
-    t_Handle        h_Ad;
+    t_FmPcd *p_FmPcd;
+    t_Handle h_Ad;
 
     if (isTree)
         p_FmPcd = (t_FmPcd *)(((t_FmPcdCcTree *)h_FmPcdCcNodeOrTree)->h_FmPcd);
     else
         p_FmPcd = (t_FmPcd *)(((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->h_FmPcd);
 
-    if ((isTree && p_FmPcd->p_CcShadow) ||
-        (!isTree && ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->maxNumOfKeys))
+    if ((isTree && p_FmPcd->p_CcShadow)
+            || (!isTree && ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->maxNumOfKeys))
     {
         /* The allocated shadow is divided as follows:
-           0 . . .       16 . . .
-           ---------------------------------------------------
-           |   Shadow   |   Shadow Keys   |   Shadow Next    |
-           |     Ad     |   Match Table   |   Engine Table   |
-           | (16 bytes) | (maximal size)  |  (maximal size)  |
-           ---------------------------------------------------
+         0 . . .       16 . . .
+         ---------------------------------------------------
+         |   Shadow   |   Shadow Keys   |   Shadow Next    |
+         |     Ad     |   Match Table   |   Engine Table   |
+         | (16 bytes) | (maximal size)  |  (maximal size)  |
+         ---------------------------------------------------
          */
         if (!p_FmPcd->p_CcShadow)
         {
@@ -2356,9 +2476,9 @@ static __inline__ t_Handle GetNewAd(t_Handle  h_FmPcdCcNodeOrTree, bool isTree)
     return h_Ad;
 }
 
-static t_Error BuildNewNodeCommonPart(t_FmPcdCcNode                         *p_CcNode,
-                                      int                                   *size,
-                                      t_FmPcdModifyCcKeyAdditionalParams    *p_AdditionalInfo)
+static t_Error BuildNewNodeCommonPart(
+        t_FmPcdCcNode *p_CcNode, int *size,
+        t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
     t_FmPcd *p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
 
@@ -2369,77 +2489,92 @@ static t_Error BuildNewNodeCommonPart(t_FmPcdCcNode                         *p_C
 
     if (p_CcNode->maxNumOfKeys == 0)
     {
-        p_AdditionalInfo->p_AdTableNew =
-            (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcd),
-                                        (uint32_t)( (p_AdditionalInfo->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE),
-                                        FM_PCD_CC_AD_TABLE_ALIGN);
+        p_AdditionalInfo->p_AdTableNew = (t_Handle)FM_MURAM_AllocMem(
+                FmPcdGetMuramHandle(p_FmPcd),
+                (uint32_t)((p_AdditionalInfo->numOfKeys + 1)
+                        * FM_PCD_CC_AD_ENTRY_SIZE),
+                FM_PCD_CC_AD_TABLE_ALIGN);
         if (!p_AdditionalInfo->p_AdTableNew)
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node action descriptors table"));
-
-        p_AdditionalInfo->p_KeysMatchTableNew =
-            (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcd),
-                                        (uint32_t)(*size * sizeof(uint8_t) * (p_AdditionalInfo->numOfKeys + 1)),
-                                        FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
+            RETURN_ERROR(
+                    MAJOR, E_NO_MEMORY,
+                    ("MURAM allocation for CC node action descriptors table"));
+
+        p_AdditionalInfo->p_KeysMatchTableNew = (t_Handle)FM_MURAM_AllocMem(
+                FmPcdGetMuramHandle(p_FmPcd),
+                (uint32_t)(*size * sizeof(uint8_t)
+                        * (p_AdditionalInfo->numOfKeys + 1)),
+                FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
         if (!p_AdditionalInfo->p_KeysMatchTableNew)
         {
-            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_AdditionalInfo->p_AdTableNew);
+            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd),
+                             p_AdditionalInfo->p_AdTableNew);
             p_AdditionalInfo->p_AdTableNew = NULL;
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node key match table"));
+            RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                         ("MURAM allocation for CC node key match table"));
         }
 
-        IOMemSet32((uint8_t*)p_AdditionalInfo->p_AdTableNew, 0, (uint32_t)((p_AdditionalInfo->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE));
-        IOMemSet32((uint8_t*)p_AdditionalInfo->p_KeysMatchTableNew, 0, *size * sizeof(uint8_t) * (p_AdditionalInfo->numOfKeys + 1));
+        IOMemSet32(
+                (uint8_t*)p_AdditionalInfo->p_AdTableNew,
+                0,
+                (uint32_t)((p_AdditionalInfo->numOfKeys + 1)
+                        * FM_PCD_CC_AD_ENTRY_SIZE));
+        IOMemSet32((uint8_t*)p_AdditionalInfo->p_KeysMatchTableNew, 0,
+                   *size * sizeof(uint8_t) * (p_AdditionalInfo->numOfKeys + 1));
     }
     else
     {
         /* The allocated shadow is divided as follows:
-           0 . . .       16 . . .
-           ---------------------------------------------------
-           |   Shadow   |   Shadow Keys   |   Shadow Next    |
-           |     Ad     |   Match Table   |   Engine Table   |
-           | (16 bytes) | (maximal size)  |  (maximal size)  |
-           ---------------------------------------------------
+         0 . . .       16 . . .
+         ---------------------------------------------------
+         |   Shadow   |   Shadow Keys   |   Shadow Next    |
+         |     Ad     |   Match Table   |   Engine Table   |
+         | (16 bytes) | (maximal size)  |  (maximal size)  |
+         ---------------------------------------------------
          */
 
         if (!p_FmPcd->p_CcShadow)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("CC Shadow not allocated"));
 
-        p_AdditionalInfo->p_KeysMatchTableNew = PTR_MOVE(p_FmPcd->p_CcShadow, FM_PCD_CC_AD_ENTRY_SIZE);
-        p_AdditionalInfo->p_AdTableNew        = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, p_CcNode->keysMatchTableMaxSize);
+        p_AdditionalInfo->p_KeysMatchTableNew =
+                PTR_MOVE(p_FmPcd->p_CcShadow, FM_PCD_CC_AD_ENTRY_SIZE);
+        p_AdditionalInfo->p_AdTableNew =
+                PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, p_CcNode->keysMatchTableMaxSize);
 
-        IOMemSet32((uint8_t*)p_AdditionalInfo->p_AdTableNew, 0, (uint32_t)((p_CcNode->maxNumOfKeys + 1) * FM_PCD_CC_AD_ENTRY_SIZE));
-        IOMemSet32((uint8_t*)p_AdditionalInfo->p_KeysMatchTableNew, 0, (*size) * sizeof(uint8_t) * (p_CcNode->maxNumOfKeys));
+        IOMemSet32(
+                (uint8_t*)p_AdditionalInfo->p_AdTableNew,
+                0,
+                (uint32_t)((p_CcNode->maxNumOfKeys + 1)
+                        * FM_PCD_CC_AD_ENTRY_SIZE));
+        IOMemSet32((uint8_t*)p_AdditionalInfo->p_KeysMatchTableNew, 0,
+                   (*size) * sizeof(uint8_t) * (p_CcNode->maxNumOfKeys));
     }
 
-    p_AdditionalInfo->p_AdTableOld          = p_CcNode->h_AdTable;
-    p_AdditionalInfo->p_KeysMatchTableOld   = p_CcNode->h_KeysMatchTable;
+    p_AdditionalInfo->p_AdTableOld = p_CcNode->h_AdTable;
+    p_AdditionalInfo->p_KeysMatchTableOld = p_CcNode->h_KeysMatchTable;
 
     return E_OK;
 }
 
-static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle                           h_FmPcd,
-                                                     t_FmPcdCcNode                      *p_CcNode,
-                                                     uint16_t                           keyIndex,
-                                                     t_FmPcdCcKeyParams                 *p_KeyParams,
-                                                     t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo,
-                                                     bool                               add)
+static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(
+        t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, uint16_t keyIndex,
+        t_FmPcdCcKeyParams *p_KeyParams,
+        t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo, bool add)
 {
-    t_Error                 err = E_OK;
-    t_Handle                p_AdTableNewTmp, p_KeysMatchTableNewTmp;
-    t_Handle                p_KeysMatchTableOldTmp, p_AdTableOldTmp;
-    int                     size;
-    int                     i = 0, j = 0;
-    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t                requiredAction = 0;
-    bool                    prvLclMask;
-    t_CcNodeInformation     *p_CcNodeInformation;
-    t_FmPcdCcStatsParams    statsParams = {0};
-    t_List                  *p_Pos;
-    t_FmPcdStatsObj         *p_StatsObj;
+    t_Error err = E_OK;
+    t_Handle p_AdTableNewTmp, p_KeysMatchTableNewTmp;
+    t_Handle p_KeysMatchTableOldTmp, p_AdTableOldTmp;
+    int size;
+    int i = 0, j = 0;
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t requiredAction = 0;
+    bool prvLclMask;
+    t_CcNodeInformation *p_CcNodeInformation;
+    t_FmPcdCcStatsParams statsParams = { 0 };
+    t_List *p_Pos;
+    t_FmPcdStatsObj *p_StatsObj;
 
     /* Check that new NIA is legal */
-    err = ValidateNextEngineParams(h_FmPcd,
-                                   &p_KeyParams->ccNextEngineParams,
+    err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams,
                                    p_CcNode->statisticsMode);
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -2447,36 +2582,34 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
     prvLclMask = p_CcNode->lclMask;
 
     /* Check that new key is not require update of localMask */
-    err = UpdateGblMask(p_CcNode,
-                        p_CcNode->ccKeySizeAccExtraction,
+    err = UpdateGblMask(p_CcNode, p_CcNode->ccKeySizeAccExtraction,
                         p_KeyParams->p_Mask);
     if (err)
         RETURN_ERROR(MAJOR, err, (NO_MSG));
 
     /* Update internal data structure with new next engine for the given index */
     memcpy(&p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams,
-           &p_KeyParams->ccNextEngineParams,
-           sizeof(t_FmPcdCcNextEngineParams));
+           &p_KeyParams->ccNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
 
     memcpy(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].key,
-            p_KeyParams->p_Key,
-            p_CcNode->userSizeOfExtraction);
+           p_KeyParams->p_Key, p_CcNode->userSizeOfExtraction);
 
-    if ((p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
-        && p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
+    if ((p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine
+            == e_FM_PCD_CC)
+            && p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
     {
-        err = AllocAndFillAdForContLookupManip(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode);
+        err =
+                AllocAndFillAdForContLookupManip(
+                        p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
 
     if (p_KeyParams->p_Mask)
         memcpy(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].mask,
-               p_KeyParams->p_Mask,
-               p_CcNode->userSizeOfExtraction);
+               p_KeyParams->p_Mask, p_CcNode->userSizeOfExtraction);
     else
-        memset(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].mask,
-               0xFF,
+        memset(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].mask, 0xFF,
                p_CcNode->userSizeOfExtraction);
 
     /* Update numOfKeys */
@@ -2493,35 +2626,40 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
     /* Check that manip is legal and what requiredAction is necessary for this manip */
     if (p_KeyParams->ccNextEngineParams.h_Manip)
     {
-        err = FmPcdManipCheckParamsForCcNextEngine(&p_KeyParams->ccNextEngineParams,&requiredAction);
+        err = FmPcdManipCheckParamsForCcNextEngine(
+                &p_KeyParams->ccNextEngineParams, &requiredAction);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
 
-    p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction = requiredAction;
-    p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction |= UPDATE_CC_WITH_TREE;
+    p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction =
+            requiredAction;
+    p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction |=
+            UPDATE_CC_WITH_TREE;
 
     /* Update new Ad and new Key Table according to new requirement */
     i = 0;
     for (j = 0; j < p_AdditionalInfo->numOfKeys; j++)
     {
-        p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j*FM_PCD_CC_AD_ENTRY_SIZE);
+        p_AdTableNewTmp =
+                PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j*FM_PCD_CC_AD_ENTRY_SIZE);
 
         if (j == keyIndex)
         {
             if (p_KeyParams->ccNextEngineParams.statisticsEn)
             {
                 /* Allocate a statistics object that holds statistics AD and counters.
-                   - For added key - New statistics AD and counters pointer need to be allocated
-                     new statistics object. If statistics were enabled, we need to replace the
-                     existing descriptor with a new descriptor with nullified counters.
+                 - For added key - New statistics AD and counters pointer need to be allocated
+                 new statistics object. If statistics were enabled, we need to replace the
+                 existing descriptor with a new descriptor with nullified counters.
                  */
                 p_StatsObj = GetStatsObj(p_CcNode);
                 ASSERT_COND(p_StatsObj);
 
                 /* Store allocated statistics object */
                 ASSERT_COND(keyIndex < CC_MAX_NUM_OF_KEYS);
-                p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj = p_StatsObj;
+                p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj =
+                        p_StatsObj;
 
                 statsParams.h_StatsAd = p_StatsObj->h_StatsAd;
                 statsParams.h_StatsCounters = p_StatsObj->h_StatsCounters;
@@ -2531,24 +2669,22 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
 #endif /* (DPAA_VERSION >= 11) */
 
                 /* Building action descriptor for the received new key */
-                NextStepAd(p_AdTableNewTmp,
-                           &statsParams,
-                           &p_KeyParams->ccNextEngineParams,
-                           p_FmPcd);
+                NextStepAd(p_AdTableNewTmp, &statsParams,
+                           &p_KeyParams->ccNextEngineParams, p_FmPcd);
             }
             else
             {
                 /* Building action descriptor for the received new key */
-                NextStepAd(p_AdTableNewTmp,
-                           NULL,
-                           &p_KeyParams->ccNextEngineParams,
-                           p_FmPcd);
+                NextStepAd(p_AdTableNewTmp, NULL,
+                           &p_KeyParams->ccNextEngineParams, p_FmPcd);
             }
 
             /* Copy the received new key into keys match table */
-            p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j*size*sizeof(uint8_t));
+            p_KeysMatchTableNewTmp =
+                    PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j*size*sizeof(uint8_t));
 
-            Mem2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeyParams->p_Key, p_CcNode->userSizeOfExtraction);
+            Mem2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeyParams->p_Key,
+                        p_CcNode->userSizeOfExtraction);
 
             /* Update mask for the received new key */
             if (p_CcNode->lclMask)
@@ -2556,79 +2692,87 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
                 if (p_KeyParams->p_Mask)
                 {
                     Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
-                                p_CcNode->ccKeySizeAccExtraction),
+                            p_CcNode->ccKeySizeAccExtraction),
                                 p_KeyParams->p_Mask,
                                 p_CcNode->userSizeOfExtraction);
                 }
-                else if (p_CcNode->ccKeySizeAccExtraction > 4)
-                {
-                    IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
-                               p_CcNode->ccKeySizeAccExtraction),
-                               0xff,
-                               p_CcNode->userSizeOfExtraction);
-                }
                 else
-                {
-                    Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                    if (p_CcNode->ccKeySizeAccExtraction > 4)
+                    {
+                        IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
                                 p_CcNode->ccKeySizeAccExtraction),
-                                p_CcNode->p_GlblMask,
-                                p_CcNode->userSizeOfExtraction);
-                }
+                                   0xff, p_CcNode->userSizeOfExtraction);
+                    }
+                    else
+                    {
+                        Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                                p_CcNode->ccKeySizeAccExtraction),
+                                    p_CcNode->p_GlblMask,
+                                    p_CcNode->userSizeOfExtraction);
+                    }
             }
 
             /* If key modification requested, the old entry is omitted and replaced by the new parameters */
             if (!add)
                 i++;
-         }
-         else
-         {
-             /* Copy existing action descriptors to the newly allocated Ad table */
-             p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i*FM_PCD_CC_AD_ENTRY_SIZE);
-             IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
-
-             /* Copy existing keys and their masks to the newly allocated keys match table */
-             p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j * size * sizeof(uint8_t));
-             p_KeysMatchTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableOld, i * size * sizeof(uint8_t));
-
-             if (p_CcNode->lclMask)
-             {
-                 if (prvLclMask)
-                 {
-                     IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_CcNode->ccKeySizeAccExtraction),
-                                PTR_MOVE(p_KeysMatchTableOldTmp, p_CcNode->ccKeySizeAccExtraction),
-                                p_CcNode->ccKeySizeAccExtraction);
-                 }
-                 else
-                 {
-                     p_KeysMatchTableOldTmp = PTR_MOVE(p_CcNode->h_KeysMatchTable,
-                                                       i * p_CcNode->ccKeySizeAccExtraction*sizeof(uint8_t));
-
-                     if (p_CcNode->ccKeySizeAccExtraction > 4)
-                     {
-                         IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
-                                    p_CcNode->ccKeySizeAccExtraction),
-                                    0xff,
-                                    p_CcNode->userSizeOfExtraction);
-                     }
-                     else
-                     {
-                         IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
-                                    p_CcNode->ccKeySizeAccExtraction),
-                                    p_CcNode->p_GlblMask,
-                                    p_CcNode->userSizeOfExtraction);
-                     }
-                 }
-             }
+        }
+        else
+        {
+            /* Copy existing action descriptors to the newly allocated Ad table */
+            p_AdTableOldTmp =
+                    PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i*FM_PCD_CC_AD_ENTRY_SIZE);
+            IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,
+                       FM_PCD_CC_AD_ENTRY_SIZE);
+
+            /* Copy existing keys and their masks to the newly allocated keys match table */
+            p_KeysMatchTableNewTmp =
+                    PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j * size * sizeof(uint8_t));
+            p_KeysMatchTableOldTmp =
+                    PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableOld, i * size * sizeof(uint8_t));
+
+            if (p_CcNode->lclMask)
+            {
+                if (prvLclMask)
+                {
+                    IO2IOCpy32(
+                            PTR_MOVE(p_KeysMatchTableNewTmp, p_CcNode->ccKeySizeAccExtraction),
+                            PTR_MOVE(p_KeysMatchTableOldTmp, p_CcNode->ccKeySizeAccExtraction),
+                            p_CcNode->ccKeySizeAccExtraction);
+                }
+                else
+                {
+                    p_KeysMatchTableOldTmp =
+                            PTR_MOVE(p_CcNode->h_KeysMatchTable,
+                                    i * (int)p_CcNode->ccKeySizeAccExtraction * sizeof(uint8_t));
+
+                    if (p_CcNode->ccKeySizeAccExtraction > 4)
+                    {
+                        IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                                p_CcNode->ccKeySizeAccExtraction),
+                                   0xff, p_CcNode->userSizeOfExtraction);
+                    }
+                    else
+                    {
+                        IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                                p_CcNode->ccKeySizeAccExtraction),
+                                   p_CcNode->p_GlblMask,
+                                   p_CcNode->userSizeOfExtraction);
+                    }
+                }
+            }
 
-             IO2IOCpy32(p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp, p_CcNode->ccKeySizeAccExtraction);
+            IO2IOCpy32(p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp,
+                       p_CcNode->ccKeySizeAccExtraction);
 
-             i++;
+            i++;
         }
     }
 
     /* Miss action descriptor */
-    p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j * FM_PCD_CC_AD_ENTRY_SIZE);
-    p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i * FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableNewTmp =
+            PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j * FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableOldTmp =
+            PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i * FM_PCD_CC_AD_ENTRY_SIZE);
     IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
     if (!LIST_IsEmpty(&p_CcNode->ccTreesLst))
@@ -2639,25 +2783,27 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
             ASSERT_COND(p_CcNodeInformation->h_CcNode);
             /* Update the manipulation which has to be updated from parameters of the port */
             /* It's has to be updated with restrictions defined in the function */
-            err = SetRequiredAction(p_CcNode->h_FmPcd,
-                                    p_CcNode->shadowAction | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
-                                    &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
-                                    PTR_MOVE(p_AdditionalInfo->p_AdTableNew, keyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
-                                    1,
-                                    p_CcNodeInformation->h_CcNode);
+            err =
+                    SetRequiredAction(
+                            p_CcNode->h_FmPcd,
+                            p_CcNode->shadowAction
+                                    | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
+                            &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
+                            PTR_MOVE(p_AdditionalInfo->p_AdTableNew, keyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
+                            1, p_CcNodeInformation->h_CcNode);
             if (err)
                 RETURN_ERROR(MAJOR, err, (NO_MSG));
 
-            err = CcUpdateParam(p_CcNode->h_FmPcd,
-                                NULL,
-                                NULL,
-                                &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
-                                1,
-                                PTR_MOVE(p_AdditionalInfo->p_AdTableNew, keyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
-                                TRUE,
-                                p_CcNodeInformation->index,
-                                p_CcNodeInformation->h_CcNode,
-                                TRUE);
+            err =
+                    CcUpdateParam(
+                            p_CcNode->h_FmPcd,
+                            NULL,
+                            NULL,
+                            &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
+                            1,
+                            PTR_MOVE(p_AdditionalInfo->p_AdTableNew, keyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
+                            TRUE, p_CcNodeInformation->index,
+                            p_CcNodeInformation->h_CcNode, TRUE);
             if (err)
                 RETURN_ERROR(MAJOR, err, (NO_MSG));
         }
@@ -2667,49 +2813,58 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
         memset(p_CcNode->p_GlblMask, 0xff, CC_GLBL_MASK_SIZE * sizeof(uint8_t));
 
     if (p_KeyParams->ccNextEngineParams.nextEngine == e_FM_PCD_CC)
-        p_AdditionalInfo->h_NodeForAdd = p_KeyParams->ccNextEngineParams.params.ccParams.h_CcNode;
+        p_AdditionalInfo->h_NodeForAdd =
+                p_KeyParams->ccNextEngineParams.params.ccParams.h_CcNode;
     if (p_KeyParams->ccNextEngineParams.h_Manip)
-        p_AdditionalInfo->h_ManipForAdd = p_KeyParams->ccNextEngineParams.h_Manip;
+        p_AdditionalInfo->h_ManipForAdd =
+                p_KeyParams->ccNextEngineParams.h_Manip;
 
 #if (DPAA_VERSION >= 11)
-        if ((p_KeyParams->ccNextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_KeyParams->ccNextEngineParams.params.frParams.h_FrmReplic))
-            p_AdditionalInfo->h_FrmReplicForAdd = p_KeyParams->ccNextEngineParams.params.frParams.h_FrmReplic;
+    if ((p_KeyParams->ccNextEngineParams.nextEngine == e_FM_PCD_FR)
+            && (p_KeyParams->ccNextEngineParams.params.frParams.h_FrmReplic))
+        p_AdditionalInfo->h_FrmReplicForAdd =
+                p_KeyParams->ccNextEngineParams.params.frParams.h_FrmReplic;
 #endif /* (DPAA_VERSION >= 11) */
 
     if (!add)
     {
-        if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
-            p_AdditionalInfo->h_NodeForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
+        if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine
+                == e_FM_PCD_CC)
+            p_AdditionalInfo->h_NodeForRmv =
+                    p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
 
         if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
-            p_AdditionalInfo->h_ManipForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
+            p_AdditionalInfo->h_ManipForRmv =
+                    p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
 
         /* If statistics were previously enabled, store the old statistics object to be released */
         if (p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj)
         {
-            p_AdditionalInfo->p_StatsObjForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj;
+            p_AdditionalInfo->p_StatsObjForRmv =
+                    p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj;
         }
 
 #if (DPAA_VERSION >= 11)
-        if ((p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic))
-            p_AdditionalInfo->h_FrmReplicForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
+        if ((p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine
+                == e_FM_PCD_FR)
+                && (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic))
+            p_AdditionalInfo->h_FrmReplicForRmv =
+                    p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
 #endif /* (DPAA_VERSION >= 11) */
     }
 
     return E_OK;
 }
 
-static t_Error BuildNewNodeRemoveKey(t_FmPcdCcNode                      *p_CcNode,
-                                     uint16_t                           keyIndex,
-                                     t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+static t_Error BuildNewNodeRemoveKey(
+        t_FmPcdCcNode *p_CcNode, uint16_t keyIndex,
+        t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
-    int         i = 0, j = 0;
-    t_Handle    p_AdTableNewTmp,p_KeysMatchTableNewTmp;
-    t_Handle    p_KeysMatchTableOldTmp, p_AdTableOldTmp;
-    int         size;
-    t_Error     err = E_OK;
+    int i = 0, j = 0;
+    t_Handle p_AdTableNewTmp, p_KeysMatchTableNewTmp;
+    t_Handle p_KeysMatchTableOldTmp, p_AdTableOldTmp;
+    int size;
+    t_Error err = E_OK;
 
     /*save new numOfKeys*/
     p_AdditionalInfo->numOfKeys = (uint16_t)(p_CcNode->numOfKeys - 1);
@@ -2720,89 +2875,90 @@ static t_Error BuildNewNodeRemoveKey(t_FmPcdCcNode                      *p_CcNod
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /*update new Ad and new Key Table according to new requirement*/
-    for (i=0, j=0; j<p_CcNode->numOfKeys; i++, j++)
+    for (i = 0, j = 0; j < p_CcNode->numOfKeys; i++, j++)
     {
         if (j == keyIndex)
-        {
-            p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j * FM_PCD_CC_AD_ENTRY_SIZE);
             j++;
-        }
+
         if (j == p_CcNode->numOfKeys)
             break;
-        p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, i * FM_PCD_CC_AD_ENTRY_SIZE);
-        p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j * FM_PCD_CC_AD_ENTRY_SIZE);
+        p_AdTableNewTmp =
+                PTR_MOVE(p_AdditionalInfo->p_AdTableNew, i * FM_PCD_CC_AD_ENTRY_SIZE);
+        p_AdTableOldTmp =
+                PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j * FM_PCD_CC_AD_ENTRY_SIZE);
         IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
-        p_KeysMatchTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableOld, j * size * sizeof(uint8_t));
-        p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, i * size * sizeof(uint8_t));
-        IO2IOCpy32(p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp, size * sizeof(uint8_t));
+        p_KeysMatchTableOldTmp =
+                PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableOld, j * size * sizeof(uint8_t));
+        p_KeysMatchTableNewTmp =
+                PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, i * size * sizeof(uint8_t));
+        IO2IOCpy32(p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp,
+                   size * sizeof(uint8_t));
     }
 
-    p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, i * FM_PCD_CC_AD_ENTRY_SIZE);
-    p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j * FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableNewTmp =
+            PTR_MOVE(p_AdditionalInfo->p_AdTableNew, i * FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableOldTmp =
+            PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j * FM_PCD_CC_AD_ENTRY_SIZE);
     IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
-    if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
+    if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine
+            == e_FM_PCD_CC)
         p_AdditionalInfo->h_NodeForRmv =
-            p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
+                p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
 
     if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
         p_AdditionalInfo->h_ManipForRmv =
-            p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
+                p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
 
     /* If statistics were previously enabled, store the old statistics object to be released */
     if (p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj)
     {
-        p_AdditionalInfo->p_StatsObjForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj;
+        p_AdditionalInfo->p_StatsObjForRmv =
+                p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj;
     }
 
 #if (DPAA_VERSION >= 11)
-        if ((p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic))
-             p_AdditionalInfo->h_FrmReplicForRmv =
+    if ((p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine
+            == e_FM_PCD_FR)
+            && (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic))
+        p_AdditionalInfo->h_FrmReplicForRmv =
                 p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
 #endif /* (DPAA_VERSION >= 11) */
 
-   return E_OK;
+    return E_OK;
 }
 
-static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode                      *p_CcNode,
-                                     uint16_t                           keyIndex,
-                                     uint8_t                            *p_Key,
-                                     uint8_t                            *p_Mask,
-                                     t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+static t_Error BuildNewNodeModifyKey(
+        t_FmPcdCcNode *p_CcNode, uint16_t keyIndex, uint8_t *p_Key,
+        uint8_t *p_Mask, t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
-    t_FmPcd                 *p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
-    t_Error                 err = E_OK;
-    t_Handle                p_AdTableNewTmp, p_KeysMatchTableNewTmp;
-    t_Handle                p_KeysMatchTableOldTmp, p_AdTableOldTmp;
-    int                     size;
-    int                     i = 0, j = 0;
-    bool                    prvLclMask;
-    t_FmPcdStatsObj         *p_StatsObj, tmpStatsObj;
-    p_AdditionalInfo->numOfKeys =  p_CcNode->numOfKeys;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
+    t_Error err = E_OK;
+    t_Handle p_AdTableNewTmp, p_KeysMatchTableNewTmp;
+    t_Handle p_KeysMatchTableOldTmp, p_AdTableOldTmp;
+    int size;
+    int i = 0, j = 0;
+    bool prvLclMask;
+    t_FmPcdStatsObj *p_StatsObj, tmpStatsObj;
+    p_AdditionalInfo->numOfKeys = p_CcNode->numOfKeys;
 
     prvLclMask = p_CcNode->lclMask;
 
     /* Check that new key is not require update of localMask */
-    err = UpdateGblMask(p_CcNode,
-                        p_CcNode->ccKeySizeAccExtraction,
-                        p_Mask);
+    err = UpdateGblMask(p_CcNode, p_CcNode->ccKeySizeAccExtraction, p_Mask);
     if (err)
         RETURN_ERROR(MAJOR, err, (NO_MSG));
 
     /* Update internal data structure with new next engine for the given index */
-    memcpy(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].key,
-           p_Key,
+    memcpy(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].key, p_Key,
            p_CcNode->userSizeOfExtraction);
 
     if (p_Mask)
-        memcpy(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].mask,
-               p_Mask,
+        memcpy(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].mask, p_Mask,
                p_CcNode->userSizeOfExtraction);
     else
-        memset(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].mask,
-               0xFF,
+        memset(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].mask, 0xFF,
                p_CcNode->userSizeOfExtraction);
 
     /*function which build in the memory new KeyTbl, AdTbl*/
@@ -2811,10 +2967,12 @@ static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode                      *p_CcNod
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /*fill the New AdTable and New KeyTable*/
-    for (j=0, i=0; j<p_AdditionalInfo->numOfKeys; j++, i++)
+    for (j = 0, i = 0; j < p_AdditionalInfo->numOfKeys; j++, i++)
     {
-        p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j*FM_PCD_CC_AD_ENTRY_SIZE);
-        p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i*FM_PCD_CC_AD_ENTRY_SIZE);
+        p_AdTableNewTmp =
+                PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j*FM_PCD_CC_AD_ENTRY_SIZE);
+        p_AdTableOldTmp =
+                PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i*FM_PCD_CC_AD_ENTRY_SIZE);
 
         IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
@@ -2824,88 +2982,100 @@ static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode                      *p_CcNod
             if (p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj)
             {
                 /* As statistics were enabled, we need to update the existing
-                   statistics descriptor with a new nullified counters. */
+                 statistics descriptor with a new nullified counters. */
                 p_StatsObj = GetStatsObj(p_CcNode);
                 ASSERT_COND(p_StatsObj);
 
-                SetStatsCounters(p_AdTableNewTmp,
-                                 (uint32_t)((XX_VirtToPhys(p_StatsObj->h_StatsCounters) - p_FmPcd->physicalMuramBase)));
+                SetStatsCounters(
+                        p_AdTableNewTmp,
+                        (uint32_t)((XX_VirtToPhys(p_StatsObj->h_StatsCounters)
+                                - p_FmPcd->physicalMuramBase)));
 
                 tmpStatsObj.h_StatsAd = p_StatsObj->h_StatsAd;
                 tmpStatsObj.h_StatsCounters = p_StatsObj->h_StatsCounters;
 
                 /* As we need to replace only the counters, we build a new statistics
-                   object that holds the old AD and the new counters - this will be the
-                   currently used statistics object.
-                   The newly allocated AD is not required and may be released back to
-                   the available objects with the previous counters pointer. */
-                p_StatsObj->h_StatsAd = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsAd;
+                 object that holds the old AD and the new counters - this will be the
+                 currently used statistics object.
+                 The newly allocated AD is not required and may be released back to
+                 the available objects with the previous counters pointer. */
+                p_StatsObj->h_StatsAd =
+                        p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsAd;
 
-                p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsAd = tmpStatsObj.h_StatsAd;
+                p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsAd =
+                        tmpStatsObj.h_StatsAd;
 
                 /* Store allocated statistics object */
-                p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj = p_StatsObj;
+                p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj =
+                        p_StatsObj;
 
                 /* As statistics were previously enabled, store the old statistics object to be released */
-                p_AdditionalInfo->p_StatsObjForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj;
+                p_AdditionalInfo->p_StatsObjForRmv =
+                        p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj;
             }
 
-            p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j * size * sizeof(uint8_t));
+            p_KeysMatchTableNewTmp =
+                    PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j * size * sizeof(uint8_t));
 
-            Mem2IOCpy32(p_KeysMatchTableNewTmp, p_Key, p_CcNode->userSizeOfExtraction);
+            Mem2IOCpy32(p_KeysMatchTableNewTmp, p_Key,
+                        p_CcNode->userSizeOfExtraction);
 
             if (p_CcNode->lclMask)
             {
                 if (p_Mask)
                     Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
-                                p_CcNode->ccKeySizeAccExtraction),
-                                p_Mask,
-                                p_CcNode->userSizeOfExtraction);
-                else if (p_CcNode->ccKeySizeAccExtraction > 4)
-                    IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
-                               p_CcNode->ccKeySizeAccExtraction),
-                               0xff,
-                               p_CcNode->userSizeOfExtraction);
+                            p_CcNode->ccKeySizeAccExtraction),
+                                p_Mask, p_CcNode->userSizeOfExtraction);
                 else
-                    Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                    if (p_CcNode->ccKeySizeAccExtraction > 4)
+                        IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
                                 p_CcNode->ccKeySizeAccExtraction),
-                                p_CcNode->p_GlblMask,
-                                p_CcNode->userSizeOfExtraction);
+                                   0xff, p_CcNode->userSizeOfExtraction);
+                    else
+                        Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                                p_CcNode->ccKeySizeAccExtraction),
+                                    p_CcNode->p_GlblMask,
+                                    p_CcNode->userSizeOfExtraction);
             }
         }
         else
         {
-            p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j * size * sizeof(uint8_t));
-            p_KeysMatchTableOldTmp = PTR_MOVE(p_CcNode->h_KeysMatchTable, i * size * sizeof(uint8_t));
+            p_KeysMatchTableNewTmp =
+                    PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j * size * sizeof(uint8_t));
+            p_KeysMatchTableOldTmp =
+                    PTR_MOVE(p_CcNode->h_KeysMatchTable, i * size * sizeof(uint8_t));
 
             if (p_CcNode->lclMask)
             {
                 if (prvLclMask)
-                    IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_CcNode->ccKeySizeAccExtraction),
-                               PTR_MOVE(p_KeysMatchTableOldTmp, p_CcNode->ccKeySizeAccExtraction),
-                               p_CcNode->userSizeOfExtraction);
+                    IO2IOCpy32(
+                            PTR_MOVE(p_KeysMatchTableNewTmp, p_CcNode->ccKeySizeAccExtraction),
+                            PTR_MOVE(p_KeysMatchTableOldTmp, p_CcNode->ccKeySizeAccExtraction),
+                            p_CcNode->userSizeOfExtraction);
                 else
                 {
-                    p_KeysMatchTableOldTmp = PTR_MOVE(p_CcNode->h_KeysMatchTable, i * p_CcNode->ccKeySizeAccExtraction * sizeof(uint8_t));
+                    p_KeysMatchTableOldTmp =
+                            PTR_MOVE(p_CcNode->h_KeysMatchTable,
+                                     i * (int)p_CcNode->ccKeySizeAccExtraction * sizeof(uint8_t));
 
                     if (p_CcNode->ccKeySizeAccExtraction > 4)
                         IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
-                                   p_CcNode->ccKeySizeAccExtraction),
-                                   0xff,
-                                   p_CcNode->userSizeOfExtraction);
+                                p_CcNode->ccKeySizeAccExtraction),
+                                   0xff, p_CcNode->userSizeOfExtraction);
                     else
-                        IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_CcNode->ccKeySizeAccExtraction),
-                                   p_CcNode->p_GlblMask,
-                                   p_CcNode->userSizeOfExtraction);
+                        IO2IOCpy32(
+                                PTR_MOVE(p_KeysMatchTableNewTmp, p_CcNode->ccKeySizeAccExtraction),
+                                p_CcNode->p_GlblMask,
+                                p_CcNode->userSizeOfExtraction);
                 }
             }
-            IO2IOCpy32((void*)p_KeysMatchTableNewTmp,
-                       p_KeysMatchTableOldTmp,
+            IO2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp,
                        p_CcNode->ccKeySizeAccExtraction);
         }
     }
 
-    p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j * FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableNewTmp =
+            PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j * FM_PCD_CC_AD_ENTRY_SIZE);
     p_AdTableOldTmp = PTR_MOVE(p_CcNode->h_AdTable, i * FM_PCD_CC_AD_ENTRY_SIZE);
 
     IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
@@ -2913,48 +3083,44 @@ static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode                      *p_CcNod
     return E_OK;
 }
 
-static t_Error BuildNewNodeModifyNextEngine(t_Handle                            h_FmPcd,
-                                            t_Handle                            h_FmPcdCcNodeOrTree,
-                                            uint16_t                            keyIndex,
-                                            t_FmPcdCcNextEngineParams           *p_CcNextEngineParams,
-                                            t_List                              *h_OldLst,
-                                            t_List                              *h_NewLst,
-                                            t_FmPcdModifyCcKeyAdditionalParams  *p_AdditionalInfo)
+static t_Error BuildNewNodeModifyNextEngine(
+        t_Handle h_FmPcd, t_Handle h_FmPcdCcNodeOrTree, uint16_t keyIndex,
+        t_FmPcdCcNextEngineParams *p_CcNextEngineParams, t_List *h_OldLst,
+        t_List *h_NewLst, t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
-    t_Error                 err = E_OK;
-    uint32_t                requiredAction = 0;
-    t_List                  *p_Pos;
-    t_CcNodeInformation     *p_CcNodeInformation, ccNodeInfo;
-    t_Handle                p_Ad;
-    t_FmPcdCcNode           *p_FmPcdCcNode1 = NULL;
-    t_FmPcdCcTree           *p_FmPcdCcTree = NULL;
-    t_FmPcdStatsObj         *p_StatsObj;
-    t_FmPcdCcStatsParams    statsParams = {0};
+    t_Error err = E_OK;
+    uint32_t requiredAction = 0;
+    t_List *p_Pos;
+    t_CcNodeInformation *p_CcNodeInformation, ccNodeInfo;
+    t_Handle p_Ad;
+    t_FmPcdCcNode *p_FmPcdCcNode1 = NULL;
+    t_FmPcdCcTree *p_FmPcdCcTree = NULL;
+    t_FmPcdStatsObj *p_StatsObj;
+    t_FmPcdCcStatsParams statsParams = { 0 };
 
     ASSERT_COND(p_CcNextEngineParams);
 
     /* check that new NIA is legal */
     if (!p_AdditionalInfo->tree)
-        err = ValidateNextEngineParams(h_FmPcd,
-                                       p_CcNextEngineParams,
-                                       ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->statisticsMode);
+        err = ValidateNextEngineParams(
+                h_FmPcd, p_CcNextEngineParams,
+                ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->statisticsMode);
     else
         /* Statistics are not supported for CC root */
-        err = ValidateNextEngineParams(h_FmPcd,
-                                       p_CcNextEngineParams,
+        err = ValidateNextEngineParams(h_FmPcd, p_CcNextEngineParams,
                                        e_FM_PCD_CC_STATS_MODE_NONE);
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /* Update internal data structure for next engine per index (index - key) */
     memcpy(&p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams,
-           p_CcNextEngineParams,
-           sizeof(t_FmPcdCcNextEngineParams));
+           p_CcNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
 
     /* Check that manip is legal and what requiredAction is necessary for this manip */
     if (p_CcNextEngineParams->h_Manip)
     {
-        err = FmPcdManipCheckParamsForCcNextEngine(p_CcNextEngineParams, &requiredAction);
+        err = FmPcdManipCheckParamsForCcNextEngine(p_CcNextEngineParams,
+                                                   &requiredAction);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -2962,19 +3128,24 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
     if (!p_AdditionalInfo->tree)
     {
         p_FmPcdCcNode1 = (t_FmPcdCcNode *)h_FmPcdCcNodeOrTree;
-        p_AdditionalInfo->numOfKeys =  p_FmPcdCcNode1->numOfKeys;
+        p_AdditionalInfo->numOfKeys = p_FmPcdCcNode1->numOfKeys;
         p_Ad = p_FmPcdCcNode1->h_AdTable;
 
-        if (p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
-            p_AdditionalInfo->h_NodeForRmv = p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
+        if (p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine
+                == e_FM_PCD_CC)
+            p_AdditionalInfo->h_NodeForRmv =
+                    p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
 
         if (p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
-            p_AdditionalInfo->h_ManipForRmv = p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
+            p_AdditionalInfo->h_ManipForRmv =
+                    p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
 
 #if (DPAA_VERSION >= 11)
-        if ((p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic))
-            p_AdditionalInfo->h_FrmReplicForRmv = p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
+        if ((p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine
+                == e_FM_PCD_FR)
+                && (p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic))
+            p_AdditionalInfo->h_FrmReplicForRmv =
+                    p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
 #endif /* (DPAA_VERSION >= 11) */
     }
     else
@@ -2982,23 +3153,29 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
         p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcNodeOrTree;
         p_Ad = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
 
-        if (p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
-            p_AdditionalInfo->h_NodeForRmv = p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
+        if (p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine
+                == e_FM_PCD_CC)
+            p_AdditionalInfo->h_NodeForRmv =
+                    p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
 
         if (p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
-            p_AdditionalInfo->h_ManipForRmv = p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
+            p_AdditionalInfo->h_ManipForRmv =
+                    p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
 
 #if (DPAA_VERSION >= 11)
-        if ((p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic))
-            p_AdditionalInfo->h_FrmReplicForRmv = p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
+        if ((p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine
+                == e_FM_PCD_FR)
+                && (p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic))
+            p_AdditionalInfo->h_FrmReplicForRmv =
+                    p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
 #endif /* (DPAA_VERSION >= 11) */
     }
 
     if ((p_CcNextEngineParams->nextEngine == e_FM_PCD_CC)
-        && p_CcNextEngineParams->h_Manip)
+            && p_CcNextEngineParams->h_Manip)
     {
-        err = AllocAndFillAdForContLookupManip(p_CcNextEngineParams->params.ccParams.h_CcNode);
+        err = AllocAndFillAdForContLookupManip(
+                p_CcNextEngineParams->params.ccParams.h_CcNode);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -3009,57 +3186,57 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
     ccNodeInfo.h_CcNode = PTR_MOVE(p_Ad, keyIndex * FM_PCD_CC_AD_ENTRY_SIZE);
 
     /* If statistics were enabled, this Ad is the statistics Ad. Need to follow its
-       nextAction to retrieve the actual Nia-Ad. If statistics should remain enabled,
-       only the actual Nia-Ad should be modified. */
-    if ((!p_AdditionalInfo->tree) &&
-        (((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj) &&
-        (p_CcNextEngineParams->statisticsEn))
-        ccNodeInfo.h_CcNode = ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsAd;
+     nextAction to retrieve the actual Nia-Ad. If statistics should remain enabled,
+     only the actual Nia-Ad should be modified. */
+    if ((!p_AdditionalInfo->tree)
+            && (((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj)
+            && (p_CcNextEngineParams->statisticsEn))
+        ccNodeInfo.h_CcNode =
+                ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsAd;
 
     EnqueueNodeInfoToRelevantLst(h_OldLst, &ccNodeInfo, NULL);
 
     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
     p_Ad = GetNewAd(h_FmPcdCcNodeOrTree, p_AdditionalInfo->tree);
     if (!p_Ad)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node action descriptor"));
-    IOMemSet32((uint8_t *)p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("MURAM allocation for CC node action descriptor"));
+    IOMemSet32((uint8_t *)p_Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
     /* If statistics were not enabled before, but requested now -  Allocate a statistics
-       object that holds statistics AD and counters. */
-    if ((!p_AdditionalInfo->tree) &&
-        (!((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj) &&
-        (p_CcNextEngineParams->statisticsEn))
+     object that holds statistics AD and counters. */
+    if ((!p_AdditionalInfo->tree)
+            && (!((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj)
+            && (p_CcNextEngineParams->statisticsEn))
     {
         p_StatsObj = GetStatsObj((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree);
         ASSERT_COND(p_StatsObj);
 
         /* Store allocated statistics object */
-        p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj = p_StatsObj;
+        p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj =
+                p_StatsObj;
 
         statsParams.h_StatsAd = p_StatsObj->h_StatsAd;
         statsParams.h_StatsCounters = p_StatsObj->h_StatsCounters;
 
 #if (DPAA_VERSION >= 11)
-        statsParams.h_StatsFLRs = ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->h_StatsFLRs;
+        statsParams.h_StatsFLRs =
+                ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->h_StatsFLRs;
 
 #endif /* (DPAA_VERSION >= 11) */
 
-        NextStepAd(p_Ad,
-                   &statsParams,
-                   p_CcNextEngineParams,
-                   h_FmPcd);
+        NextStepAd(p_Ad, &statsParams, p_CcNextEngineParams, h_FmPcd);
     }
     else
-        NextStepAd(p_Ad,
-                   NULL,
-                   p_CcNextEngineParams,
-                   h_FmPcd);
+        NextStepAd(p_Ad, NULL, p_CcNextEngineParams, h_FmPcd);
 
     ccNodeInfo.h_CcNode = p_Ad;
     EnqueueNodeInfoToRelevantLst(h_NewLst, &ccNodeInfo, NULL);
 
-    p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction = requiredAction;
-    p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction |= UPDATE_CC_WITH_TREE;
+    p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction =
+            requiredAction;
+    p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction |=
+            UPDATE_CC_WITH_TREE;
 
     if (!p_AdditionalInfo->tree)
     {
@@ -3072,27 +3249,23 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
 
                 ASSERT_COND(p_CcNodeInformation->h_CcNode);
                 /* Update the manipulation which has to be updated from parameters of the port
-                   it's has to be updated with restrictions defined in the function */
-
-                err = SetRequiredAction(p_FmPcdCcNode1->h_FmPcd,
-                                        p_FmPcdCcNode1->shadowAction | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
-                                        &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
-                                        p_Ad,
-                                        1,
-                                        p_CcNodeInformation->h_CcNode);
+                 it's has to be updated with restrictions defined in the function */
+
+                err =
+                        SetRequiredAction(
+                                p_FmPcdCcNode1->h_FmPcd,
+                                p_FmPcdCcNode1->shadowAction
+                                        | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
+                                &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
+                                p_Ad, 1, p_CcNodeInformation->h_CcNode);
                 if (err)
                     RETURN_ERROR(MAJOR, err, (NO_MSG));
 
-                err = CcUpdateParam(p_FmPcdCcNode1->h_FmPcd,
-                                    NULL,
-                                    NULL,
-                                    &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
-                                    1,
-                                    p_Ad,
-                                    TRUE,
-                                    p_CcNodeInformation->index,
-                                    p_CcNodeInformation->h_CcNode,
-                                    TRUE);
+                err = CcUpdateParam(
+                        p_FmPcdCcNode1->h_FmPcd, NULL, NULL,
+                        &p_AdditionalInfo->keyAndNextEngineParams[keyIndex], 1,
+                        p_Ad, TRUE, p_CcNodeInformation->index,
+                        p_CcNodeInformation->h_CcNode, TRUE);
                 if (err)
                     RETURN_ERROR(MAJOR, err, (NO_MSG));
             }
@@ -3100,40 +3273,36 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
     }
     else
     {
-       ASSERT_COND(p_FmPcdCcTree);
+        ASSERT_COND(p_FmPcdCcTree);
 
-       err = SetRequiredAction(h_FmPcd,
-                               p_FmPcdCcTree->requiredAction | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
-                               &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
-                               p_Ad,
-                               1,
-                               (t_Handle)p_FmPcdCcTree);
+        err =
+                SetRequiredAction(
+                        h_FmPcd,
+                        p_FmPcdCcTree->requiredAction
+                                | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
+                        &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
+                        p_Ad, 1, (t_Handle)p_FmPcdCcTree);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
 
-        err = CcUpdateParam(h_FmPcd,
-                            NULL,
-                            NULL,
+        err = CcUpdateParam(h_FmPcd, NULL, NULL,
                             &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
-                            1,
-                            p_Ad,
-                            TRUE,
-                            0,
-                            (t_Handle)p_FmPcdCcTree, TRUE);
+                            1, p_Ad, TRUE, 0, (t_Handle)p_FmPcdCcTree, TRUE);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
 
     if (p_CcNextEngineParams->nextEngine == e_FM_PCD_CC)
-        p_AdditionalInfo->h_NodeForAdd = p_CcNextEngineParams->params.ccParams.h_CcNode;
+        p_AdditionalInfo->h_NodeForAdd =
+                p_CcNextEngineParams->params.ccParams.h_CcNode;
     if (p_CcNextEngineParams->h_Manip)
         p_AdditionalInfo->h_ManipForAdd = p_CcNextEngineParams->h_Manip;
 
     /* If statistics were previously enabled, but now are disabled,
-       store the old statistics object to be released */
-    if ((!p_AdditionalInfo->tree) &&
-         (((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj) &&
-         (!p_CcNextEngineParams->statisticsEn))
+     store the old statistics object to be released */
+    if ((!p_AdditionalInfo->tree)
+            && (((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj)
+            && (!p_CcNextEngineParams->statisticsEn))
     {
         p_AdditionalInfo->p_StatsObjForRmv =
                 ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj;
@@ -3142,54 +3311,60 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
         p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj = NULL;
     }
 #if (DPAA_VERSION >= 11)
-        if ((p_CcNextEngineParams->nextEngine == e_FM_PCD_FR) &&
-            (p_CcNextEngineParams->params.frParams.h_FrmReplic))
-            p_AdditionalInfo->h_FrmReplicForAdd = p_CcNextEngineParams->params.frParams.h_FrmReplic;
+    if ((p_CcNextEngineParams->nextEngine == e_FM_PCD_FR)
+            && (p_CcNextEngineParams->params.frParams.h_FrmReplic))
+        p_AdditionalInfo->h_FrmReplicForAdd =
+                p_CcNextEngineParams->params.frParams.h_FrmReplic;
 #endif /* (DPAA_VERSION >= 11) */
 
     return E_OK;
 }
 
-static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(t_FmPcdCcNode                *p_CrntMdfNode,
-                                                       t_List                       *h_OldLst,
-                                                       t_FmPcdCcNextEngineParams    **p_NextEngineParams)
+static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(
+        t_FmPcdCcNode *p_CrntMdfNode, t_List *h_OldLst,
+        t_FmPcdCcNextEngineParams **p_NextEngineParams)
 {
-    t_CcNodeInformation     *p_CcNodeInformation;
-    t_FmPcdCcNode           *p_NodePtrOnCurrentMdfNode = NULL;
-    t_List                  *p_Pos;
-    int                     i = 0;
-    t_Handle                p_AdTablePtOnCrntCurrentMdfNode/*, p_AdTableNewModified*/;
-    t_CcNodeInformation     ccNodeInfo;
+    t_CcNodeInformation *p_CcNodeInformation;
+    t_FmPcdCcNode *p_NodePtrOnCurrentMdfNode = NULL;
+    t_List *p_Pos;
+    int i = 0;
+    t_Handle p_AdTablePtOnCrntCurrentMdfNode/*, p_AdTableNewModified*/;
+    t_CcNodeInformation ccNodeInfo;
 
     LIST_FOR_EACH(p_Pos, &p_CrntMdfNode->ccPrevNodesLst)
     {
         p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
-        p_NodePtrOnCurrentMdfNode = (t_FmPcdCcNode *)p_CcNodeInformation->h_CcNode;
+        p_NodePtrOnCurrentMdfNode =
+                (t_FmPcdCcNode *)p_CcNodeInformation->h_CcNode;
 
         ASSERT_COND(p_NodePtrOnCurrentMdfNode);
 
         /* Search in the previous node which exact index points on this current modified node for getting AD */
         for (i = 0; i < p_NodePtrOnCurrentMdfNode->numOfKeys + 1; i++)
         {
-            if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine
+                    == e_FM_PCD_CC)
             {
-                if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode == (t_Handle)p_CrntMdfNode)
+                if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode
+                        == (t_Handle)p_CrntMdfNode)
                 {
                     if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip)
                         p_AdTablePtOnCrntCurrentMdfNode = p_CrntMdfNode->h_Ad;
-                    else if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].p_StatsObj)
-                        p_AdTablePtOnCrntCurrentMdfNode =
-                                p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].p_StatsObj->h_StatsAd;
                     else
-                        p_AdTablePtOnCrntCurrentMdfNode =
-                                PTR_MOVE(p_NodePtrOnCurrentMdfNode->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
+                        if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].p_StatsObj)
+                            p_AdTablePtOnCrntCurrentMdfNode =
+                                    p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].p_StatsObj->h_StatsAd;
+                        else
+                            p_AdTablePtOnCrntCurrentMdfNode =
+                                    PTR_MOVE(p_NodePtrOnCurrentMdfNode->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
 
                     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                     ccNodeInfo.h_CcNode = p_AdTablePtOnCrntCurrentMdfNode;
                     EnqueueNodeInfoToRelevantLst(h_OldLst, &ccNodeInfo, NULL);
 
                     if (!(*p_NextEngineParams))
-                        *p_NextEngineParams = &p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams;
+                        *p_NextEngineParams =
+                                &p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams;
                 }
             }
         }
@@ -3198,38 +3373,43 @@ static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(t_FmPcdCcNode
     }
 }
 
-static void UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(t_FmPcdCcNode                *p_CrntMdfNode,
-                                                       t_List                       *h_OldLst,
-                                                       t_FmPcdCcNextEngineParams    **p_NextEngineParams)
+static void UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(
+        t_FmPcdCcNode *p_CrntMdfNode, t_List *h_OldLst,
+        t_FmPcdCcNextEngineParams **p_NextEngineParams)
 {
-    t_CcNodeInformation     *p_CcNodeInformation;
-    t_FmPcdCcTree           *p_TreePtrOnCurrentMdfNode = NULL;
-    t_List                  *p_Pos;
-    int                     i = 0;
-    t_Handle                p_AdTableTmp;
-    t_CcNodeInformation     ccNodeInfo;
+    t_CcNodeInformation *p_CcNodeInformation;
+    t_FmPcdCcTree *p_TreePtrOnCurrentMdfNode = NULL;
+    t_List *p_Pos;
+    int i = 0;
+    t_Handle p_AdTableTmp;
+    t_CcNodeInformation ccNodeInfo;
 
     LIST_FOR_EACH(p_Pos, &p_CrntMdfNode->ccTreeIdLst)
     {
         p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
-        p_TreePtrOnCurrentMdfNode = (t_FmPcdCcTree *)p_CcNodeInformation->h_CcNode;
+        p_TreePtrOnCurrentMdfNode =
+                (t_FmPcdCcTree *)p_CcNodeInformation->h_CcNode;
 
         ASSERT_COND(p_TreePtrOnCurrentMdfNode);
 
         /*search in the trees which exact index points on this current modified node for getting AD */
         for (i = 0; i < p_TreePtrOnCurrentMdfNode->numOfEntries; i++)
         {
-            if (p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            if (p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine
+                    == e_FM_PCD_CC)
             {
-                if (p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode == (t_Handle)p_CrntMdfNode)
+                if (p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode
+                        == (t_Handle)p_CrntMdfNode)
                 {
-                    p_AdTableTmp = UINT_TO_PTR(p_TreePtrOnCurrentMdfNode->ccTreeBaseAddr + i*FM_PCD_CC_AD_ENTRY_SIZE);
+                    p_AdTableTmp =
+                            UINT_TO_PTR(p_TreePtrOnCurrentMdfNode->ccTreeBaseAddr + i*FM_PCD_CC_AD_ENTRY_SIZE);
                     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                     ccNodeInfo.h_CcNode = p_AdTableTmp;
                     EnqueueNodeInfoToRelevantLst(h_OldLst, &ccNodeInfo, NULL);
 
                     if (!(*p_NextEngineParams))
-                        *p_NextEngineParams = &p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams;
+                        *p_NextEngineParams =
+                                &p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams;
                 }
             }
         }
@@ -3238,20 +3418,17 @@ static void UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(t_FmPcdCcNode
     }
 }
 
-static t_FmPcdModifyCcKeyAdditionalParams * ModifyNodeCommonPart(t_Handle        h_FmPcdCcNodeOrTree,
-                                                                 uint16_t        keyIndex,
-                                                                 e_ModifyState   modifyState,
-                                                                 bool            ttlCheck,
-                                                                 bool            hashCheck,
-                                                                 bool            tree)
+static t_FmPcdModifyCcKeyAdditionalParams * ModifyNodeCommonPart(
+        t_Handle h_FmPcdCcNodeOrTree, uint16_t keyIndex,
+        e_ModifyState modifyState, bool ttlCheck, bool hashCheck, bool tree)
 {
-    t_FmPcdModifyCcKeyAdditionalParams  *p_FmPcdModifyCcKeyAdditionalParams;
-    int                                 i = 0, j = 0;
-    bool                                wasUpdate = FALSE;
-    t_FmPcdCcNode                       *p_CcNode = NULL;
-    t_FmPcdCcTree                       *p_FmPcdCcTree;
-    uint16_t                            numOfKeys;
-    t_FmPcdCcKeyAndNextEngineParams     *p_KeyAndNextEngineParams;
+    t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams;
+    int i = 0, j = 0;
+    bool wasUpdate = FALSE;
+    t_FmPcdCcNode *p_CcNode = NULL;
+    t_FmPcdCcTree *p_FmPcdCcTree;
+    uint16_t numOfKeys;
+    t_FmPcdCcKeyAndNextEngineParams *p_KeyAndNextEngineParams;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcdCcNodeOrTree, E_INVALID_HANDLE, NULL);
 
@@ -3262,21 +3439,20 @@ static t_FmPcdModifyCcKeyAdditionalParams * ModifyNodeCommonPart(t_Handle
 
         /* node has to be pointed by another node or tree */
 
-
-        p_KeyAndNextEngineParams = (t_FmPcdCcKeyAndNextEngineParams *)XX_Malloc(sizeof(t_FmPcdCcKeyAndNextEngineParams)*(numOfKeys+1));
+        p_KeyAndNextEngineParams = (t_FmPcdCcKeyAndNextEngineParams *)XX_Malloc(
+                sizeof(t_FmPcdCcKeyAndNextEngineParams) * (numOfKeys + 1));
         if (!p_KeyAndNextEngineParams)
         {
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Next engine and required action structure"));
             return NULL;
         }
-        memcpy(p_KeyAndNextEngineParams,
-               p_CcNode->keyAndNextEngineParams,
-               (numOfKeys+1) * sizeof(t_FmPcdCcKeyAndNextEngineParams));
+        memcpy(p_KeyAndNextEngineParams, p_CcNode->keyAndNextEngineParams,
+               (numOfKeys + 1) * sizeof(t_FmPcdCcKeyAndNextEngineParams));
 
         if (ttlCheck)
         {
-            if ((p_CcNode->parseCode == CC_PC_FF_IPV4TTL) ||
-               (p_CcNode->parseCode == CC_PC_FF_IPV6HOP_LIMIT))
+            if ((p_CcNode->parseCode == CC_PC_FF_IPV4TTL)
+                    || (p_CcNode->parseCode == CC_PC_FF_IPV6HOP_LIMIT))
             {
                 XX_Free(p_KeyAndNextEngineParams);
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("nodeId of CC_PC_FF_IPV4TTL or CC_PC_FF_IPV6HOP_LIMIT can not be used for this operation"));
@@ -3299,7 +3475,9 @@ static t_FmPcdModifyCcKeyAdditionalParams * ModifyNodeCommonPart(t_Handle
         p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcNodeOrTree;
         numOfKeys = p_FmPcdCcTree->numOfEntries;
 
-        p_KeyAndNextEngineParams = (t_FmPcdCcKeyAndNextEngineParams *)XX_Malloc(sizeof(t_FmPcdCcKeyAndNextEngineParams)*FM_PCD_MAX_NUM_OF_CC_GROUPS);
+        p_KeyAndNextEngineParams = (t_FmPcdCcKeyAndNextEngineParams *)XX_Malloc(
+                sizeof(t_FmPcdCcKeyAndNextEngineParams)
+                        * FM_PCD_MAX_NUM_OF_CC_GROUPS);
         if (!p_KeyAndNextEngineParams)
         {
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Next engine and required action structure"));
@@ -3307,18 +3485,21 @@ static t_FmPcdModifyCcKeyAdditionalParams * ModifyNodeCommonPart(t_Handle
         }
         memcpy(p_KeyAndNextEngineParams,
                p_FmPcdCcTree->keyAndNextEngineParams,
-               FM_PCD_MAX_NUM_OF_CC_GROUPS * sizeof(t_FmPcdCcKeyAndNextEngineParams));
+               FM_PCD_MAX_NUM_OF_CC_GROUPS
+                       * sizeof(t_FmPcdCcKeyAndNextEngineParams));
     }
 
     p_FmPcdModifyCcKeyAdditionalParams =
-        (t_FmPcdModifyCcKeyAdditionalParams *)XX_Malloc(sizeof(t_FmPcdModifyCcKeyAdditionalParams));
+            (t_FmPcdModifyCcKeyAdditionalParams *)XX_Malloc(
+                    sizeof(t_FmPcdModifyCcKeyAdditionalParams));
     if (!p_FmPcdModifyCcKeyAdditionalParams)
     {
         XX_Free(p_KeyAndNextEngineParams);
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of internal data structure FAILED"));
         return NULL;
     }
-    memset(p_FmPcdModifyCcKeyAdditionalParams, 0, sizeof(t_FmPcdModifyCcKeyAdditionalParams));
+    memset(p_FmPcdModifyCcKeyAdditionalParams, 0,
+           sizeof(t_FmPcdModifyCcKeyAdditionalParams));
 
     p_FmPcdModifyCcKeyAdditionalParams->h_CurrentNode = h_FmPcdCcNodeOrTree;
     p_FmPcdModifyCcKeyAdditionalParams->savedKeyIndex = keyIndex;
@@ -3329,8 +3510,9 @@ static t_FmPcdModifyCcKeyAdditionalParams * ModifyNodeCommonPart(t_Handle
         {
             if (modifyState == e_MODIFY_STATE_ADD)
                 j++;
-            else if (modifyState == e_MODIFY_STATE_REMOVE)
-                i++;
+            else
+                if (modifyState == e_MODIFY_STATE_REMOVE)
+                    i++;
             wasUpdate = TRUE;
         }
         else
@@ -3347,8 +3529,6 @@ static t_FmPcdModifyCcKeyAdditionalParams * ModifyNodeCommonPart(t_Handle
     {
         if (modifyState == e_MODIFY_STATE_ADD)
             j++;
-        else if (modifyState == e_MODIFY_STATE_REMOVE)
-            i++;
     }
 
     memcpy(&p_FmPcdModifyCcKeyAdditionalParams->keyAndNextEngineParams[j],
@@ -3360,39 +3540,41 @@ static t_FmPcdModifyCcKeyAdditionalParams * ModifyNodeCommonPart(t_Handle
     return p_FmPcdModifyCcKeyAdditionalParams;
 }
 
-static t_Error UpdatePtrWhichPointOnCrntMdfNode(t_FmPcdCcNode                       *p_CcNode,
-                                                t_FmPcdModifyCcKeyAdditionalParams  *p_FmPcdModifyCcKeyAdditionalParams,
-                                                t_List                              *h_OldLst,
-                                                t_List                              *h_NewLst)
+static t_Error UpdatePtrWhichPointOnCrntMdfNode(
+        t_FmPcdCcNode *p_CcNode,
+        t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams,
+        t_List *h_OldLst, t_List *h_NewLst)
 {
-    t_FmPcdCcNextEngineParams   *p_NextEngineParams = NULL;
-    t_CcNodeInformation         ccNodeInfo = {0};
-    t_Handle                    h_NewAd;
+    t_FmPcdCcNextEngineParams *p_NextEngineParams = NULL;
+    t_CcNodeInformation ccNodeInfo = { 0 };
+    t_Handle h_NewAd;
 
     /* Building a list of all action descriptors that point to the previous node */
     if (!LIST_IsEmpty(&p_CcNode->ccPrevNodesLst))
-        UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(p_CcNode, h_OldLst, &p_NextEngineParams);
+        UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(p_CcNode, h_OldLst,
+                                                   &p_NextEngineParams);
 
     if (!LIST_IsEmpty(&p_CcNode->ccTreeIdLst))
-        UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(p_CcNode, h_OldLst, &p_NextEngineParams);
+        UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(p_CcNode, h_OldLst,
+                                                   &p_NextEngineParams);
 
     /* This node must be found as next engine of one of its previous nodes or trees*/
-    if(p_NextEngineParams)
+    if (p_NextEngineParams)
     {
+        /* Building a new action descriptor that points to the modified node */
+        h_NewAd = GetNewAd(p_CcNode, FALSE);
+        if (!h_NewAd)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+        IOMemSet32(h_NewAd, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
-	    /* Building a new action descriptor that points to the modified node */
-	    h_NewAd = GetNewAd(p_CcNode, FALSE);
-	    if (!h_NewAd)
-	        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
-	    IOMemSet32(h_NewAd, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+        BuildNewAd(h_NewAd, p_FmPcdModifyCcKeyAdditionalParams, p_CcNode,
+                   p_NextEngineParams);
 
-	    BuildNewAd(h_NewAd,
-	               p_FmPcdModifyCcKeyAdditionalParams,
-	               p_CcNode,
-	               p_NextEngineParams);
+        ccNodeInfo.h_CcNode = h_NewAd;
+        EnqueueNodeInfoToRelevantLst(h_NewLst, &ccNodeInfo, NULL);
 
-	    ccNodeInfo.h_CcNode = h_NewAd;
-	    EnqueueNodeInfoToRelevantLst(h_NewLst, &ccNodeInfo, NULL);
+        if (p_NextEngineParams->h_Manip)
+            FmPcdManipUpdateOwner(p_NextEngineParams->h_Manip, FALSE);
     }
     return E_OK;
 }
@@ -3404,7 +3586,7 @@ static void UpdateCcRootOwner(t_FmPcdCcTree *p_FmPcdCcTree, bool add)
     /* this routine must be protected by the calling routine! */
 
     if (add)
-       p_FmPcdCcTree->owners++;
+        p_FmPcdCcTree->owners++;
     else
     {
         ASSERT_COND(p_FmPcdCcTree->owners);
@@ -3415,14 +3597,16 @@ static void UpdateCcRootOwner(t_FmPcdCcTree *p_FmPcdCcTree, bool add)
 static t_Error CheckAndSetManipParamsWithCcNodeParams(t_FmPcdCcNode *p_CcNode)
 {
     t_Error err = E_OK;
-    int     i = 0;
+    int i = 0;
 
     for (i = 0; i < p_CcNode->numOfKeys; i++)
     {
         if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip)
         {
-            err = FmPcdManipCheckParamsWithCcNodeParams(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip,
-                                                        (t_Handle)p_CcNode);
+            err =
+                    FmPcdManipCheckParamsWithCcNodeParams(
+                            p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip,
+                            (t_Handle)p_CcNode);
             if (err)
                 return err;
         }
@@ -3430,13 +3614,13 @@ static t_Error CheckAndSetManipParamsWithCcNodeParams(t_FmPcdCcNode *p_CcNode)
 
     return err;
 }
-static t_Error ValidateAndCalcStatsParams(t_FmPcdCcNode        *p_CcNode,
-                                          t_FmPcdCcNodeParams  *p_CcNodeParam,
-                                          uint32_t             *p_NumOfRanges,
-                                          uint32_t             *p_CountersArraySize)
+static t_Error ValidateAndCalcStatsParams(t_FmPcdCcNode *p_CcNode,
+                                          t_FmPcdCcNodeParams *p_CcNodeParam,
+                                          uint32_t *p_NumOfRanges,
+                                          uint32_t *p_CountersArraySize)
 {
-    e_FmPcdCcStatsMode  statisticsMode = p_CcNode->statisticsMode;
-    uint32_t            i;
+    e_FmPcdCcStatsMode statisticsMode = p_CcNode->statisticsMode;
+    uint32_t i;
 
     UNUSED(p_CcNodeParam);
 
@@ -3445,8 +3629,10 @@ static t_Error ValidateAndCalcStatsParams(t_FmPcdCcNode        *p_CcNode,
         case e_FM_PCD_CC_STATS_MODE_NONE:
             for (i = 0; i < p_CcNode->numOfKeys; i++)
                 if (p_CcNodeParam->keysParams.keyParams[i].ccNextEngineParams.statisticsEn)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                                 ("Statistics cannot be enabled for key %d when statistics mode was set to 'NONE'", i));
+                    RETURN_ERROR(
+                            MAJOR,
+                            E_INVALID_VALUE,
+                            ("Statistics cannot be enabled for key %d when statistics mode was set to 'NONE'", i));
             return E_OK;
 
         case e_FM_PCD_CC_STATS_MODE_FRAME:
@@ -3457,42 +3643,47 @@ static t_Error ValidateAndCalcStatsParams(t_FmPcdCcNode        *p_CcNode,
 
 #if (DPAA_VERSION >= 11)
         case e_FM_PCD_CC_STATS_MODE_RMON:
-            {
-                uint16_t    *p_FrameLengthRanges = p_CcNodeParam->keysParams.frameLengthRanges;
-                uint32_t    i;
-
-                if (p_FrameLengthRanges[0] <= 0)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Statistics mode"));
+        {
+            uint16_t *p_FrameLengthRanges =
+                    p_CcNodeParam->keysParams.frameLengthRanges;
+            uint32_t i;
 
-                if (p_FrameLengthRanges[0] == 0xFFFF)
-                {
-                    *p_NumOfRanges = 1;
-                    *p_CountersArraySize = 2 * FM_PCD_CC_STATS_COUNTER_SIZE;
-                    return E_OK;
-                }
+            if (p_FrameLengthRanges[0] <= 0)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Statistics mode"));
 
-                for (i = 1; i < FM_PCD_CC_STATS_MAX_NUM_OF_FLR; i++)
-                {
-                    if (p_FrameLengthRanges[i-1] >= p_FrameLengthRanges[i])
-                        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                                     ("Frame length range must be larger at least by 1 from preceding range"));
+            if (p_FrameLengthRanges[0] == 0xFFFF)
+            {
+                *p_NumOfRanges = 1;
+                *p_CountersArraySize = 2 * FM_PCD_CC_STATS_COUNTER_SIZE;
+                return E_OK;
+            }
 
-                    /* Stop when last range is reached */
-                    if (p_FrameLengthRanges[i] == 0xFFFF)
-                        break;
-                }
+            for (i = 1; i < FM_PCD_CC_STATS_MAX_NUM_OF_FLR; i++)
+            {
+                if (p_FrameLengthRanges[i - 1] >= p_FrameLengthRanges[i])
+                    RETURN_ERROR(
+                            MAJOR,
+                            E_INVALID_VALUE,
+                            ("Frame length range must be larger at least by 1 from preceding range"));
+
+                /* Stop when last range is reached */
+                if (p_FrameLengthRanges[i] == 0xFFFF)
+                    break;
+            }
 
-                if ((i >= FM_PCD_CC_STATS_MAX_NUM_OF_FLR) ||
-                    (p_FrameLengthRanges[i] != 0xFFFF))
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Last Frame length range must be 0xFFFF"));
+            if ((i >= FM_PCD_CC_STATS_MAX_NUM_OF_FLR)
+                    || (p_FrameLengthRanges[i] != 0xFFFF))
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                             ("Last Frame length range must be 0xFFFF"));
 
-                *p_NumOfRanges = i+1;
+            *p_NumOfRanges = i + 1;
 
-                /* Allocate an extra counter for byte count, as counters
-                   array always begins with byte count */
-                *p_CountersArraySize = (*p_NumOfRanges + 1) * FM_PCD_CC_STATS_COUNTER_SIZE;
+            /* Allocate an extra counter for byte count, as counters
+             array always begins with byte count */
+            *p_CountersArraySize = (*p_NumOfRanges + 1)
+                    * FM_PCD_CC_STATS_COUNTER_SIZE;
 
-            }
+        }
             return E_OK;
 #endif /* (DPAA_VERSION >= 11) */
 
@@ -3501,34 +3692,34 @@ static t_Error ValidateAndCalcStatsParams(t_FmPcdCcNode        *p_CcNode,
     }
 }
 
-static t_Error CheckParams(t_Handle             h_FmPcd,
-                           t_FmPcdCcNodeParams  *p_CcNodeParam,
-                           t_FmPcdCcNode        *p_CcNode,
-                           bool                 *isKeyTblAlloc)
+static t_Error CheckParams(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam,
+                           t_FmPcdCcNode *p_CcNode, bool *isKeyTblAlloc)
 {
-    int                     tmp = 0;
-    t_FmPcdCcKeyParams      *p_KeyParams;
-    t_Error                 err;
-    uint32_t                requiredAction = 0;
+    int tmp = 0;
+    t_FmPcdCcKeyParams *p_KeyParams;
+    t_Error err;
+    uint32_t requiredAction = 0;
 
     /* Validate statistics parameters */
-    err = ValidateAndCalcStatsParams(p_CcNode,
-                                     p_CcNodeParam,
+    err = ValidateAndCalcStatsParams(p_CcNode, p_CcNodeParam,
                                      &(p_CcNode->numOfStatsFLRs),
                                      &(p_CcNode->countersArraySize));
     if (err)
         RETURN_ERROR(MAJOR, err, ("Invalid statistics parameters"));
 
     /* Validate next engine parameters on Miss */
-    err = ValidateNextEngineParams(h_FmPcd,
-                                   &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
-                                   p_CcNode->statisticsMode);
+    err = ValidateNextEngineParams(
+            h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
+            p_CcNode->statisticsMode);
     if (err)
-        RETURN_ERROR(MAJOR, err, ("For this node MissNextEngineParams are not valid"));
+        RETURN_ERROR(MAJOR, err,
+                     ("For this node MissNextEngineParams are not valid"));
 
     if (p_CcNodeParam->keysParams.ccNextEngineParamsForMiss.h_Manip)
     {
-        err = FmPcdManipCheckParamsForCcNextEngine(&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, &requiredAction);
+        err = FmPcdManipCheckParamsForCcNextEngine(
+                &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
+                &requiredAction);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -3537,12 +3728,16 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
            &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
            sizeof(t_FmPcdCcNextEngineParams));
 
-    p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].requiredAction = requiredAction;
+    p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].requiredAction =
+            requiredAction;
 
-    if ((p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine == e_FM_PCD_CC)
-        && p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.h_Manip)
+    if ((p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine
+            == e_FM_PCD_CC)
+            && p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.h_Manip)
     {
-        err = AllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.params.ccParams.h_CcNode);
+        err =
+                AllocAndFillAdForContLookupManip(
+                        p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.params.ccParams.h_CcNode);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -3560,29 +3755,28 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
 
-        err = UpdateGblMask(p_CcNode,
-                            p_CcNodeParam->keysParams.keySize,
+        err = UpdateGblMask(p_CcNode, p_CcNodeParam->keysParams.keySize,
                             p_KeyParams->p_Mask);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
 
         if (p_KeyParams->ccNextEngineParams.h_Manip)
         {
-            err = FmPcdManipCheckParamsForCcNextEngine(&p_KeyParams->ccNextEngineParams, &requiredAction);
+            err = FmPcdManipCheckParamsForCcNextEngine(
+                    &p_KeyParams->ccNextEngineParams, &requiredAction);
             if (err)
                 RETURN_ERROR(MAJOR, err, (NO_MSG));
         }
 
         /* Store 'key' parameters - key, mask (if passed by the user) */
-        memcpy(p_CcNode->keyAndNextEngineParams[tmp].key, p_KeyParams->p_Key, p_CcNodeParam->keysParams.keySize);
+        memcpy(p_CcNode->keyAndNextEngineParams[tmp].key, p_KeyParams->p_Key,
+               p_CcNodeParam->keysParams.keySize);
 
         if (p_KeyParams->p_Mask)
             memcpy(p_CcNode->keyAndNextEngineParams[tmp].mask,
-                   p_KeyParams->p_Mask,
-                   p_CcNodeParam->keysParams.keySize);
+                   p_KeyParams->p_Mask, p_CcNodeParam->keysParams.keySize);
         else
-            memset((void *)(p_CcNode->keyAndNextEngineParams[tmp].mask),
-                   0xFF,
+            memset((void *)(p_CcNode->keyAndNextEngineParams[tmp].mask), 0xFF,
                    p_CcNodeParam->keysParams.keySize);
 
         /* Store next engine parameters */
@@ -3592,10 +3786,13 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
 
         p_CcNode->keyAndNextEngineParams[tmp].requiredAction = requiredAction;
 
-        if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
-            && p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
+        if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine
+                == e_FM_PCD_CC)
+                && p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
         {
-            err = AllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode);
+            err =
+                    AllocAndFillAdForContLookupManip(
+                            p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode);
             if (err)
                 RETURN_ERROR(MAJOR, err, (NO_MSG));
         }
@@ -3604,7 +3801,10 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
     if (p_CcNode->maxNumOfKeys)
     {
         if (p_CcNode->maxNumOfKeys < p_CcNode->numOfKeys)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Number of keys exceed the provided maximal number of keys"));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("Number of keys exceed the provided maximal number of keys"));
     }
 
     *isKeyTblAlloc = TRUE;
@@ -3612,40 +3812,48 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
     return E_OK;
 }
 
-static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
-                                                t_FmPcdCcNodeParams *p_CcNodeParam,
-                                                t_FmPcdCcNode       *p_CcNode,
-                                                bool                *isKeyTblAlloc)
+static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(
+        t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam,
+        t_FmPcdCcNode *p_CcNode, bool *isKeyTblAlloc)
 {
-    int                 tmp = 0;
-    t_FmPcdCcKeyParams  *p_KeyParams;
-    t_Error             err;
-    uint8_t             key = 0x01;
-    uint32_t            requiredAction = 0;
+    int tmp = 0;
+    t_FmPcdCcKeyParams *p_KeyParams;
+    t_Error err;
+    uint8_t key = 0x01;
+    uint32_t requiredAction = 0;
 
     if (p_CcNode->numOfKeys != 1)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT the maximal supported 'numOfKeys' is 1"));
-
-    if ((p_CcNodeParam->keysParams.maxNumOfKeys) && (p_CcNodeParam->keysParams.maxNumOfKeys != 1))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT the maximal supported 'maxNumOfKeys' is 1"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT the maximal supported 'numOfKeys' is 1"));
+
+    if ((p_CcNodeParam->keysParams.maxNumOfKeys)
+            && (p_CcNodeParam->keysParams.maxNumOfKeys != 1))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT the maximal supported 'maxNumOfKeys' is 1"));
 
     /* Validate statistics parameters */
-    err = ValidateAndCalcStatsParams(p_CcNode,
-                                     p_CcNodeParam,
+    err = ValidateAndCalcStatsParams(p_CcNode, p_CcNodeParam,
                                      &(p_CcNode->numOfStatsFLRs),
                                      &(p_CcNode->countersArraySize));
     if (err)
         RETURN_ERROR(MAJOR, err, ("Invalid statistics parameters"));
 
-    err = ValidateNextEngineParams(h_FmPcd,
-                                   &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
-                                   p_CcNodeParam->keysParams.statisticsMode);
+    err = ValidateNextEngineParams(
+            h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
+            p_CcNodeParam->keysParams.statisticsMode);
     if (err)
-        RETURN_ERROR(MAJOR, err, ("For this node MissNextEngineParams are not valid"));
+        RETURN_ERROR(MAJOR, err,
+                     ("For this node MissNextEngineParams are not valid"));
 
     if (p_CcNodeParam->keysParams.ccNextEngineParamsForMiss.h_Manip)
     {
-        err = FmPcdManipCheckParamsForCcNextEngine(&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, &requiredAction);
+        err = FmPcdManipCheckParamsForCcNextEngine(
+                &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
+                &requiredAction);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -3654,12 +3862,16 @@ static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
            &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
            sizeof(t_FmPcdCcNextEngineParams));
 
-    p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].requiredAction = requiredAction;
+    p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].requiredAction =
+            requiredAction;
 
-    if ((p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine == e_FM_PCD_CC)
-        && p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.h_Manip)
+    if ((p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine
+            == e_FM_PCD_CC)
+            && p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.h_Manip)
     {
-        err = AllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.params.ccParams.h_CcNode);
+        err =
+                AllocAndFillAdForContLookupManip(
+                        p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.params.ccParams.h_CcNode);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -3669,10 +3881,16 @@ static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
         p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
 
         if (p_KeyParams->p_Mask)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT p_Mask can not be initialized"));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT p_Mask can not be initialized"));
 
         if (memcmp(p_KeyParams->p_Key, &key, 1) != 0)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT p_Key has to be 1"));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT p_Key has to be 1"));
 
         err = ValidateNextEngineParams(h_FmPcd,
                                        &p_KeyParams->ccNextEngineParams,
@@ -3682,13 +3900,14 @@ static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
 
         if (p_KeyParams->ccNextEngineParams.h_Manip)
         {
-            err = FmPcdManipCheckParamsForCcNextEngine(&p_KeyParams->ccNextEngineParams, &requiredAction);
+            err = FmPcdManipCheckParamsForCcNextEngine(
+                    &p_KeyParams->ccNextEngineParams, &requiredAction);
             if (err)
                 RETURN_ERROR(MAJOR, err, (NO_MSG));
         }
 
         /* Store 'key' parameters - key (fixed to 0x01), key size of 1 byte and full mask */
-        p_CcNode->keyAndNextEngineParams[tmp].key[0]  = key;
+        p_CcNode->keyAndNextEngineParams[tmp].key[0] = key;
         p_CcNode->keyAndNextEngineParams[tmp].mask[0] = 0xFF;
 
         /* Store NextEngine parameters */
@@ -3696,10 +3915,13 @@ static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
                &p_KeyParams->ccNextEngineParams,
                sizeof(t_FmPcdCcNextEngineParams));
 
-        if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
-            && p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
+        if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine
+                == e_FM_PCD_CC)
+                && p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
         {
-            err = AllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode);
+            err =
+                    AllocAndFillAdForContLookupManip(
+                            p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode);
             if (err)
                 RETURN_ERROR(MAJOR, err, (NO_MSG));
         }
@@ -3711,20 +3933,21 @@ static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
     return E_OK;
 }
 
-static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
+static t_Error IcHashIndexedCheckParams(t_Handle h_FmPcd,
                                         t_FmPcdCcNodeParams *p_CcNodeParam,
-                                        t_FmPcdCcNode       *p_CcNode,
-                                        bool                *isKeyTblAlloc)
+                                        t_FmPcdCcNode *p_CcNode,
+                                        bool *isKeyTblAlloc)
 {
-    int                 tmp = 0, countOnes = 0;
-    t_FmPcdCcKeyParams  *p_KeyParams;
-    t_Error             err;
-    uint16_t            glblMask = p_CcNodeParam->extractCcParams.extractNonHdr.icIndxMask;
-    uint16_t            countMask = (uint16_t)(glblMask >> 4);
-    uint32_t            requiredAction = 0;
+    int tmp = 0, countOnes = 0;
+    t_FmPcdCcKeyParams *p_KeyParams;
+    t_Error err;
+    uint16_t glblMask = p_CcNodeParam->extractCcParams.extractNonHdr.icIndxMask;
+    uint16_t countMask = (uint16_t)(glblMask >> 4);
+    uint32_t requiredAction = 0;
 
     if (glblMask & 0x000f)
-       RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("icIndxMask has to be with last nibble 0"));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("icIndxMask has to be with last nibble 0"));
 
     while (countMask)
     {
@@ -3733,35 +3956,49 @@ static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
     }
 
     if (!POWER_OF_2(p_CcNode->numOfKeys))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type INDEXED numOfKeys has to be powerOfTwo"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("For Node of the type INDEXED numOfKeys has to be powerOfTwo"));
 
     if (p_CcNode->numOfKeys != ((uint32_t)1 << countOnes))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type IC_HASH_INDEXED numOfKeys has to be powerOfTwo"));
-
-    if (p_CcNodeParam->keysParams.maxNumOfKeys &&
-        (p_CcNodeParam->keysParams.maxNumOfKeys != p_CcNode->numOfKeys))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type INDEXED 'maxNumOfKeys' should be 0 or equal 'numOfKeys'"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("For Node of the type IC_HASH_INDEXED numOfKeys has to be powerOfTwo"));
+
+    if (p_CcNodeParam->keysParams.maxNumOfKeys
+            && (p_CcNodeParam->keysParams.maxNumOfKeys != p_CcNode->numOfKeys))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("For Node of the type INDEXED 'maxNumOfKeys' should be 0 or equal 'numOfKeys'"));
 
     /* Validate statistics parameters */
-    err = ValidateAndCalcStatsParams(p_CcNode,
-                                     p_CcNodeParam,
+    err = ValidateAndCalcStatsParams(p_CcNode, p_CcNodeParam,
                                      &(p_CcNode->numOfStatsFLRs),
                                      &(p_CcNode->countersArraySize));
     if (err)
         RETURN_ERROR(MAJOR, err, ("Invalid statistics parameters"));
 
-    err = ValidateNextEngineParams(h_FmPcd,
-                                   &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
-                                   p_CcNode->statisticsMode);
-    if (GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
-        RETURN_ERROR(MAJOR, err, ("MissNextEngineParams for the node of the type IC_INDEX_HASH has to be UnInitialized"));
+    err = ValidateNextEngineParams(
+            h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
+            p_CcNode->statisticsMode);
+    if (GET_ERROR_TYPE(err) != E_NOT_SUPPORTED)
+        RETURN_ERROR(
+                MAJOR,
+                err,
+                ("MissNextEngineParams for the node of the type IC_INDEX_HASH has to be UnInitialized"));
 
     for (tmp = 0; tmp < p_CcNode->numOfKeys; tmp++)
     {
         p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
 
         if (p_KeyParams->p_Mask || p_KeyParams->p_Key)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type IC_HASH_INDEXED p_Key or p_Mask has to be NULL"));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("For Node of the type IC_HASH_INDEXED p_Key or p_Mask has to be NULL"));
 
         if ((glblMask & (tmp * 16)) == (tmp * 16))
         {
@@ -3769,24 +4006,32 @@ static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
                                            &p_KeyParams->ccNextEngineParams,
                                            p_CcNode->statisticsMode);
             if (err)
-                RETURN_ERROR(MAJOR, err, ("This index has to be initialized for the node of the type IC_INDEX_HASH according to settings of GlobalMask "));
+                RETURN_ERROR(
+                        MAJOR,
+                        err,
+                        ("This index has to be initialized for the node of the type IC_INDEX_HASH according to settings of GlobalMask "));
 
             if (p_KeyParams->ccNextEngineParams.h_Manip)
             {
-                err = FmPcdManipCheckParamsForCcNextEngine(&p_KeyParams->ccNextEngineParams, &requiredAction);
+                err = FmPcdManipCheckParamsForCcNextEngine(
+                        &p_KeyParams->ccNextEngineParams, &requiredAction);
                 if (err)
                     RETURN_ERROR(MAJOR, err, (NO_MSG));
-                p_CcNode->keyAndNextEngineParams[tmp].requiredAction = requiredAction;
+                p_CcNode->keyAndNextEngineParams[tmp].requiredAction =
+                        requiredAction;
             }
 
             memcpy(&p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams,
                    &p_KeyParams->ccNextEngineParams,
                    sizeof(t_FmPcdCcNextEngineParams));
 
-            if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
-                && p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
+            if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine
+                    == e_FM_PCD_CC)
+                    && p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
             {
-                err = AllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode);
+                err =
+                        AllocAndFillAdForContLookupManip(
+                                p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode);
                 if (err)
                     RETURN_ERROR(MAJOR, err, (NO_MSG));
             }
@@ -3796,8 +4041,11 @@ static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
             err = ValidateNextEngineParams(h_FmPcd,
                                            &p_KeyParams->ccNextEngineParams,
                                            p_CcNode->statisticsMode);
-            if (GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
-                RETURN_ERROR(MAJOR, err, ("This index has to be UnInitialized for the node of the type IC_INDEX_HASH according to settings of GlobalMask"));
+            if (GET_ERROR_TYPE(err) != E_NOT_SUPPORTED)
+                RETURN_ERROR(
+                        MAJOR,
+                        err,
+                        ("This index has to be UnInitialized for the node of the type IC_INDEX_HASH according to settings of GlobalMask"));
         }
     }
 
@@ -3807,45 +4055,44 @@ static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
     return E_OK;
 }
 
-static t_Error ModifyNextEngineParamNode(t_Handle                    h_FmPcd,
-                                         t_Handle                    h_FmPcdCcNode,
-                                         uint16_t                    keyIndex,
-                                         t_FmPcdCcNextEngineParams   *p_FmPcdCcNextEngineParams)
+static t_Error ModifyNextEngineParamNode(
+        t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint16_t keyIndex,
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
-    t_FmPcd                             *p_FmPcd;
-    t_List                              h_OldPointersLst, h_NewPointersLst;
-    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
-    t_Error                             err = E_OK;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd *p_FmPcd;
+    t_List h_OldPointersLst, h_NewPointersLst;
+    t_FmPcdModifyCcKeyAdditionalParams *p_ModifyKeyParams;
+    t_Error err = E_OK;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_VALUE);
-    SANITY_CHECK_RETURN_ERROR(p_CcNode,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
 
     if (keyIndex >= p_CcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previously cleared last index + 1"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                     ("keyIndex > previously cleared last index + 1"));
 
     p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
 
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, FALSE, FALSE);
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex,
+                                             e_MODIFY_STATE_CHANGE, FALSE,
+                                             FALSE, FALSE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
-    if (p_CcNode->maxNumOfKeys &&
-        !TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+    if (p_CcNode->maxNumOfKeys
+            && !TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
     {
         XX_Free(p_ModifyKeyParams);
         return ERROR_CODE(E_BUSY);
     }
 
-    err = BuildNewNodeModifyNextEngine(h_FmPcd,
-                                       p_CcNode,
-                                       keyIndex,
+    err = BuildNewNodeModifyNextEngine(h_FmPcd, p_CcNode, keyIndex,
                                        p_FmPcdCcNextEngineParams,
-                                       &h_OldPointersLst,
-                                       &h_NewPointersLst,
+                                       &h_OldPointersLst, &h_NewPointersLst,
                                        p_ModifyKeyParams);
     if (err)
     {
@@ -3855,7 +4102,8 @@ static t_Error ModifyNextEngineParamNode(t_Handle                    h_FmPcd,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst, p_ModifyKeyParams, FALSE);
+    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst,
+                          p_ModifyKeyParams, FALSE);
 
     if (p_CcNode->maxNumOfKeys)
         RELEASE_LOCK(p_FmPcd->shadowLock);
@@ -3863,36 +4111,37 @@ static t_Error ModifyNextEngineParamNode(t_Handle                    h_FmPcd,
     return err;
 }
 
-static t_Error FindKeyIndex(t_Handle    h_CcNode,
-                            uint8_t     keySize,
-                            uint8_t     *p_Key,
-                            uint8_t     *p_Mask,
-                            uint16_t    *p_KeyIndex)
+static t_Error FindKeyIndex(t_Handle h_CcNode, uint8_t keySize, uint8_t *p_Key,
+                            uint8_t *p_Mask, uint16_t *p_KeyIndex)
 {
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    uint8_t         tmpMask[FM_PCD_MAX_SIZE_OF_KEY];
-    uint16_t        i;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint8_t tmpMask[FM_PCD_MAX_SIZE_OF_KEY];
+    uint16_t i;
 
     ASSERT_COND(p_Key);
     ASSERT_COND(p_KeyIndex);
     ASSERT_COND(keySize < FM_PCD_MAX_SIZE_OF_KEY);
 
     if (keySize != p_CcNode->userSizeOfExtraction)
-        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Key size doesn't match the extraction size of the node"));
+        RETURN_ERROR(
+                MINOR, E_INVALID_VALUE,
+                ("Key size doesn't match the extraction size of the node"));
 
     /* If user didn't pass a mask for this key, we'll look for full extraction mask */
     if (!p_Mask)
         memset(tmpMask, 0xFF, keySize);
 
-    for (i = 0 ; i < p_CcNode->numOfKeys; i++)
+    for (i = 0; i < p_CcNode->numOfKeys; i++)
     {
         /* Comparing received key */
-        if (memcmp(p_Key, p_CcNode->keyAndNextEngineParams[i].key, keySize) == 0)
+        if (memcmp(p_Key, p_CcNode->keyAndNextEngineParams[i].key, keySize)
+                == 0)
         {
             if (p_Mask)
             {
                 /* If a user passed a mask for this key, it must match to the existing key's mask for a correct match */
-                if (memcmp(p_Mask, p_CcNode->keyAndNextEngineParams[i].mask, keySize) == 0)
+                if (memcmp(p_Mask, p_CcNode->keyAndNextEngineParams[i].mask,
+                           keySize) == 0)
                 {
                     *p_KeyIndex = i;
                     return E_OK;
@@ -3901,7 +4150,8 @@ static t_Error FindKeyIndex(t_Handle    h_CcNode,
             else
             {
                 /* If user didn't pass a mask for this key, check if the existing key mask is full extraction */
-                if (memcmp(tmpMask, p_CcNode->keyAndNextEngineParams[i].mask, keySize) == 0)
+                if (memcmp(tmpMask, p_CcNode->keyAndNextEngineParams[i].mask,
+                           keySize) == 0)
                 {
                     *p_KeyIndex = i;
                     return E_OK;
@@ -3913,30 +4163,32 @@ static t_Error FindKeyIndex(t_Handle    h_CcNode,
     return ERROR_CODE(E_NOT_FOUND);
 }
 
-static t_Error CalcAndUpdateCcShadow(t_FmPcdCcNode  *p_CcNode,
-                                     bool           isKeyTblAlloc,
-                                     uint32_t       *p_MatchTableSize,
-                                     uint32_t       *p_AdTableSize)
+static t_Error CalcAndUpdateCcShadow(t_FmPcdCcNode *p_CcNode,
+                                     bool isKeyTblAlloc,
+                                     uint32_t *p_MatchTableSize,
+                                     uint32_t *p_AdTableSize)
 {
-    uint32_t    shadowSize;
-    t_Error     err;
+    uint32_t shadowSize;
+    t_Error err;
 
     /* Calculate keys table maximal size - each entry consists of a key and a mask,
-       (if local mask support is requested) */
-    *p_MatchTableSize = p_CcNode->ccKeySizeAccExtraction * sizeof(uint8_t) * p_CcNode->maxNumOfKeys;
+     (if local mask support is requested) */
+    *p_MatchTableSize = p_CcNode->ccKeySizeAccExtraction * sizeof(uint8_t)
+            * p_CcNode->maxNumOfKeys;
 
     if (p_CcNode->maskSupport)
         *p_MatchTableSize *= 2;
 
     /* Calculate next action descriptors table, including one more entry for miss */
-    *p_AdTableSize = (uint32_t)((p_CcNode->maxNumOfKeys + 1) * FM_PCD_CC_AD_ENTRY_SIZE);
+    *p_AdTableSize = (uint32_t)((p_CcNode->maxNumOfKeys + 1)
+            * FM_PCD_CC_AD_ENTRY_SIZE);
 
     /* Calculate maximal shadow size of this node.
-       All shadow structures will be used for runtime modifications host command. If
-       keys table was allocated for this node, the keys table and next engines table may
-       be modified in run time (entries added or removed), so shadow tables are requires.
-       Otherwise, the only supported runtime modification is a specific next engine update
-       and this requires shadow memory of a single AD */
+     All shadow structures will be used for runtime modifications host command. If
+     keys table was allocated for this node, the keys table and next engines table may
+     be modified in run time (entries added or removed), so shadow tables are requires.
+     Otherwise, the only supported runtime modification is a specific next engine update
+     and this requires shadow memory of a single AD */
 
     /* Shadow size should be enough to hold the following 3 structures:
      * 1 - an action descriptor */
@@ -3950,11 +4202,12 @@ static t_Error CalcAndUpdateCcShadow(t_FmPcdCcNode  *p_CcNode,
     shadowSize += *p_AdTableSize;
 
     /* Update shadow to the calculated size */
-    err = FmPcdUpdateCcShadow (p_CcNode->h_FmPcd, (uint32_t)shadowSize, FM_PCD_CC_AD_TABLE_ALIGN);
+    err = FmPcdUpdateCcShadow(p_CcNode->h_FmPcd, (uint32_t)shadowSize,
+                              FM_PCD_CC_AD_TABLE_ALIGN);
     if (err != E_OK)
     {
         DeleteNode(p_CcNode);
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node shadow"));
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node shadow"));
     }
 
     return E_OK;
@@ -3962,16 +4215,16 @@ static t_Error CalcAndUpdateCcShadow(t_FmPcdCcNode  *p_CcNode,
 
 static t_Error AllocStatsObjs(t_FmPcdCcNode *p_CcNode)
 {
-    t_FmPcdStatsObj     *p_StatsObj;
-    t_Handle            h_FmMuram, h_StatsAd, h_StatsCounters;
-    uint32_t            i;
+    t_FmPcdStatsObj *p_StatsObj;
+    t_Handle h_FmMuram, h_StatsAd, h_StatsCounters;
+    uint32_t i;
 
     h_FmMuram = FmPcdGetMuramHandle(p_CcNode->h_FmPcd);
     if (!h_FmMuram)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM MURAM"));
 
     /* Allocate statistics ADs and statistics counter. An extra pair (AD + counters)
-       will be allocated to support runtime modifications */
+     will be allocated to support runtime modifications */
     for (i = 0; i < p_CcNode->maxNumOfKeys + 2; i++)
     {
         /* Allocate list object structure */
@@ -3991,20 +4244,22 @@ static t_Error AllocStatsObjs(t_FmPcdCcNode *p_CcNode)
         {
             FreeStatObjects(&p_CcNode->availableStatsLst, h_FmMuram);
             XX_Free(p_StatsObj);
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for statistics ADs"));
+            RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                         ("MURAM allocation for statistics ADs"));
         }
         IOMemSet32(h_StatsAd, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
         /* Allocate statistics counters from MURAM */
-        h_StatsCounters = (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
-                                                      p_CcNode->countersArraySize,
-                                                      FM_PCD_CC_AD_TABLE_ALIGN);
+        h_StatsCounters = (t_Handle)FM_MURAM_AllocMem(
+                h_FmMuram, p_CcNode->countersArraySize,
+                FM_PCD_CC_AD_TABLE_ALIGN);
         if (!h_StatsCounters)
         {
             FreeStatObjects(&p_CcNode->availableStatsLst, h_FmMuram);
             FM_MURAM_FreeMem(h_FmMuram, h_StatsAd);
             XX_Free(p_StatsObj);
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for statistics counters"));
+            RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                         ("MURAM allocation for statistics counters"));
         }
         IOMemSet32(h_StatsCounters, 0, p_CcNode->countersArraySize);
 
@@ -4017,78 +4272,85 @@ static t_Error AllocStatsObjs(t_FmPcdCcNode *p_CcNode)
     return E_OK;
 }
 
-static t_Error MatchTableGetKeyStatistics(t_FmPcdCcNode           *p_CcNode,
-                                          uint16_t                keyIndex,
-                                          t_FmPcdCcKeyStatistics  *p_KeyStatistics)
+static t_Error MatchTableGetKeyStatistics(
+        t_FmPcdCcNode *p_CcNode, uint16_t keyIndex,
+        t_FmPcdCcKeyStatistics *p_KeyStatistics)
 {
-    uint32_t    *p_StatsCounters, i;
+    uint32_t *p_StatsCounters, i;
 
     if (p_CcNode->statisticsMode == e_FM_PCD_CC_STATS_MODE_NONE)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Statistics were not enabled for this match table"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                     ("Statistics were not enabled for this match table"));
 
     if (!p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Statistics were not enabled for this key"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                     ("Statistics were not enabled for this key"));
 
-    memset(p_KeyStatistics, 0, sizeof (t_FmPcdCcKeyStatistics));
+    memset(p_KeyStatistics, 0, sizeof(t_FmPcdCcKeyStatistics));
 
-    p_StatsCounters = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsCounters;
+    p_StatsCounters =
+            p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsCounters;
     ASSERT_COND(p_StatsCounters);
 
     p_KeyStatistics->byteCount = GET_UINT32(*p_StatsCounters);
 
     for (i = 1; i <= p_CcNode->numOfStatsFLRs; i++)
     {
-        p_StatsCounters = PTR_MOVE(p_StatsCounters, FM_PCD_CC_STATS_COUNTER_SIZE);
+        p_StatsCounters =
+                PTR_MOVE(p_StatsCounters, FM_PCD_CC_STATS_COUNTER_SIZE);
 
         p_KeyStatistics->frameCount += GET_UINT32(*p_StatsCounters);
 
 #if (DPAA_VERSION >= 11)
-        p_KeyStatistics->frameLengthRangeCount[i-1] = GET_UINT32(*p_StatsCounters);
+        p_KeyStatistics->frameLengthRangeCount[i - 1] =
+                GET_UINT32(*p_StatsCounters);
 #endif /* (DPAA_VERSION >= 11) */
     }
 
     return E_OK;
 }
 
-static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdCcNodeParams *p_CcNodeParam)
+static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode,
+                             t_FmPcdCcNodeParams *p_CcNodeParam)
 {
-    t_FmPcd                 *p_FmPcd = (t_FmPcd *) h_FmPcd;
-    t_FmPcdCcNode           *p_FmPcdCcNextNode;
-    t_Error                 err = E_OK;
-    uint32_t                tmp, keySize;
-    bool                    glblMask = FALSE;
-    t_FmPcdCcKeyParams      *p_KeyParams;
-    t_Handle                h_FmMuram, p_KeysMatchTblTmp, p_AdTableTmp;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdCcNode *p_FmPcdCcNextNode;
+    t_Error err = E_OK;
+    uint32_t tmp, keySize;
+    bool glblMask = FALSE;
+    t_FmPcdCcKeyParams *p_KeyParams;
+    t_Handle h_FmMuram, p_KeysMatchTblTmp, p_AdTableTmp;
 #if (DPAA_VERSION >= 11)
-    t_Handle                h_StatsFLRs;
+    t_Handle h_StatsFLRs;
 #endif /* (DPAA_VERSION >= 11) */
-    bool                    fullField = FALSE;
-    ccPrivateInfo_t         icCode = CC_PRIVATE_INFO_NONE;
-    bool                    isKeyTblAlloc, fromIc = FALSE;
-    uint32_t                matchTableSize, adTableSize;
-    t_CcNodeInformation     ccNodeInfo, *p_CcInformation;
-    t_FmPcdStatsObj         *p_StatsObj;
-    t_FmPcdCcStatsParams    statsParams = {0};
-    t_Handle                h_Manip;
+    bool fullField = FALSE;
+    ccPrivateInfo_t icCode = CC_PRIVATE_INFO_NONE;
+    bool isKeyTblAlloc, fromIc = FALSE;
+    uint32_t matchTableSize, adTableSize;
+    t_CcNodeInformation ccNodeInfo, *p_CcInformation;
+    t_FmPcdStatsObj *p_StatsObj;
+    t_FmPcdCcStatsParams statsParams = { 0 };
+    t_Handle h_Manip;
 
     ASSERT_COND(h_FmPcd);
     ASSERT_COND(p_CcNode);
     ASSERT_COND(p_CcNodeParam);
 
-    p_CcNode->p_GlblMask = (t_Handle)XX_Malloc(CC_GLBL_MASK_SIZE * sizeof(uint8_t));
+    p_CcNode->p_GlblMask = (t_Handle)XX_Malloc(
+            CC_GLBL_MASK_SIZE * sizeof(uint8_t));
     memset(p_CcNode->p_GlblMask, 0, CC_GLBL_MASK_SIZE * sizeof(uint8_t));
 
-    p_CcNode->h_FmPcd           = h_FmPcd;
-    p_CcNode->numOfKeys         = p_CcNodeParam->keysParams.numOfKeys;
-    p_CcNode->maxNumOfKeys      = p_CcNodeParam->keysParams.maxNumOfKeys;
-    p_CcNode->maskSupport       = p_CcNodeParam->keysParams.maskSupport;
-    p_CcNode->statisticsMode    = p_CcNodeParam->keysParams.statisticsMode;
+    p_CcNode->h_FmPcd = h_FmPcd;
+    p_CcNode->numOfKeys = p_CcNodeParam->keysParams.numOfKeys;
+    p_CcNode->maxNumOfKeys = p_CcNodeParam->keysParams.maxNumOfKeys;
+    p_CcNode->maskSupport = p_CcNodeParam->keysParams.maskSupport;
+    p_CcNode->statisticsMode = p_CcNodeParam->keysParams.statisticsMode;
 
     /* For backward compatibility - even if statistics mode is nullified,
-       we'll fix it to frame mode so we can support per-key request for
-       statistics using 'statisticsEn' in next engine parameters */
-    if (!p_CcNode->maxNumOfKeys &&
-        (p_CcNode->statisticsMode == e_FM_PCD_CC_STATS_MODE_NONE))
+     we'll fix it to frame mode so we can support per-key request for
+     statistics using 'statisticsEn' in next engine parameters */
+    if (!p_CcNode->maxNumOfKeys
+            && (p_CcNode->statisticsMode == e_FM_PCD_CC_STATS_MODE_NONE))
         p_CcNode->statisticsMode = e_FM_PCD_CC_STATS_MODE_FRAME;
 
     h_FmMuram = FmPcdGetMuramHandle(h_FmPcd);
@@ -4107,43 +4369,67 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("CC node spinlock"));
     }
 
-    if ((p_CcNodeParam->extractCcParams.type == e_FM_PCD_EXTRACT_BY_HDR) &&
-        ((p_CcNodeParam->extractCcParams.extractByHdr.hdr == HEADER_TYPE_IPv4) ||
-        (p_CcNodeParam->extractCcParams.extractByHdr.hdr == HEADER_TYPE_IPv6)) &&
-        (p_CcNodeParam->extractCcParams.extractByHdr.type == e_FM_PCD_EXTRACT_FULL_FIELD) &&
-        ((p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField.ipv6 == NET_HEADER_FIELD_IPv6_HOP_LIMIT) ||
-        (p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField.ipv4 == NET_HEADER_FIELD_IPv4_TTL)))
-    {
-        err = Ipv4TtlOrIpv6HopLimitCheckParams(h_FmPcd, p_CcNodeParam, p_CcNode, &isKeyTblAlloc);
+    if ((p_CcNodeParam->extractCcParams.type == e_FM_PCD_EXTRACT_BY_HDR)
+            && ((p_CcNodeParam->extractCcParams.extractByHdr.hdr
+                    == HEADER_TYPE_IPv4)
+                    || (p_CcNodeParam->extractCcParams.extractByHdr.hdr
+                            == HEADER_TYPE_IPv6))
+            && (p_CcNodeParam->extractCcParams.extractByHdr.type
+                    == e_FM_PCD_EXTRACT_FULL_FIELD)
+            && ((p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField.ipv6
+                    == NET_HEADER_FIELD_IPv6_HOP_LIMIT)
+                    || (p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField.ipv4
+                            == NET_HEADER_FIELD_IPv4_TTL)))
+    {
+        err = Ipv4TtlOrIpv6HopLimitCheckParams(h_FmPcd, p_CcNodeParam, p_CcNode,
+                                               &isKeyTblAlloc);
         glblMask = FALSE;
     }
-    else if ((p_CcNodeParam->extractCcParams.type == e_FM_PCD_EXTRACT_NON_HDR) &&
-             ((p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_KEY) ||
-              (p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_HASH) ||
-              (p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_FLOW_ID)))
-    {
-        if ((p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_FLOW_ID) &&
-            (p_CcNodeParam->extractCcParams.extractNonHdr.offset != 0))
+    else
+        if ((p_CcNodeParam->extractCcParams.type == e_FM_PCD_EXTRACT_NON_HDR)
+                && ((p_CcNodeParam->extractCcParams.extractNonHdr.src
+                        == e_FM_PCD_EXTRACT_FROM_KEY)
+                        || (p_CcNodeParam->extractCcParams.extractNonHdr.src
+                                == e_FM_PCD_EXTRACT_FROM_HASH)
+                        || (p_CcNodeParam->extractCcParams.extractNonHdr.src
+                                == e_FM_PCD_EXTRACT_FROM_FLOW_ID)))
         {
-            DeleteNode(p_CcNode);
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                         ("In the case of the extraction from e_FM_PCD_EXTRACT_FROM_FLOW_ID offset has to be 0"));
-        }
+            if ((p_CcNodeParam->extractCcParams.extractNonHdr.src
+                    == e_FM_PCD_EXTRACT_FROM_FLOW_ID)
+                    && (p_CcNodeParam->extractCcParams.extractNonHdr.offset != 0))
+            {
+                DeleteNode(p_CcNode);
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_VALUE,
+                        ("In the case of the extraction from e_FM_PCD_EXTRACT_FROM_FLOW_ID offset has to be 0"));
+            }
 
-        icCode = IcDefineCode(p_CcNodeParam);
-        fromIc = TRUE;
-        if (icCode == CC_PRIVATE_INFO_NONE)
-        {
-            DeleteNode(p_CcNode);
-            RETURN_ERROR(MAJOR, E_INVALID_STATE,
-                         ("user asked extraction from IC and field in internal context or action wasn't initialized in the right way"));
-        }
+            icCode = IcDefineCode(p_CcNodeParam);
+            fromIc = TRUE;
+            if (icCode == CC_PRIVATE_INFO_NONE)
+            {
+                DeleteNode(p_CcNode);
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_STATE,
+                        ("user asked extraction from IC and field in internal context or action wasn't initialized in the right way"));
+            }
 
-        if ((icCode == CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP) ||
-            (icCode == CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP))
-        {
-            err = IcHashIndexedCheckParams(h_FmPcd, p_CcNodeParam, p_CcNode, &isKeyTblAlloc);
-            glblMask = TRUE;
+            if ((icCode == CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP)
+                    || (icCode == CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP))
+            {
+                err = IcHashIndexedCheckParams(h_FmPcd, p_CcNodeParam, p_CcNode,
+                                               &isKeyTblAlloc);
+                glblMask = TRUE;
+            }
+            else
+            {
+                err = CheckParams(h_FmPcd, p_CcNodeParam, p_CcNode,
+                                  &isKeyTblAlloc);
+                if (p_CcNode->glblMaskSize)
+                    glblMask = TRUE;
+            }
         }
         else
         {
@@ -4151,13 +4437,6 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
             if (p_CcNode->glblMaskSize)
                 glblMask = TRUE;
         }
-    }
-    else
-    {
-        err = CheckParams(h_FmPcd, p_CcNodeParam, p_CcNode, &isKeyTblAlloc);
-        if (p_CcNode->glblMaskSize)
-            glblMask = TRUE;
-    }
 
     if (err)
     {
@@ -4172,24 +4451,27 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
             {
                 case (e_FM_PCD_EXTRACT_FULL_FIELD):
                     p_CcNode->parseCode =
-                        GetFullFieldParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr,
-                                              p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
-                                              p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField);
-                    GetSizeHeaderField(p_CcNodeParam->extractCcParams.extractByHdr.hdr,
-                                       p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
-                                       p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField,
-                                       &p_CcNode->sizeOfExtraction);
+                            GetFullFieldParseCode(
+                                    p_CcNodeParam->extractCcParams.extractByHdr.hdr,
+                                    p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
+                                    p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField);
+                    GetSizeHeaderField(
+                            p_CcNodeParam->extractCcParams.extractByHdr.hdr,
+                            p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField,
+                            &p_CcNode->sizeOfExtraction);
                     fullField = TRUE;
-                    if ((p_CcNode->parseCode != CC_PC_FF_TCI1) &&
-                        (p_CcNode->parseCode != CC_PC_FF_TCI2) &&
-                        (p_CcNode->parseCode != CC_PC_FF_MPLS1) &&
-                        (p_CcNode->parseCode != CC_PC_FF_MPLS_LAST) &&
-                        (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC1) &&
-                        (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC2) &&
-                        (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1) &&
-                        (p_CcNode->parseCode != CC_PC_FF_IPDSCP) &&
-                        (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2) &&
-                        glblMask)
+                    if ((p_CcNode->parseCode != CC_PC_FF_TCI1)
+                            && (p_CcNode->parseCode != CC_PC_FF_TCI2)
+                            && (p_CcNode->parseCode != CC_PC_FF_MPLS1)
+                            && (p_CcNode->parseCode != CC_PC_FF_MPLS_LAST)
+                            && (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC1)
+                            && (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC2)
+                            && (p_CcNode->parseCode
+                                    != CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1)
+                            && (p_CcNode->parseCode != CC_PC_FF_IPDSCP)
+                            && (p_CcNode->parseCode
+                                    != CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2)
+                            && glblMask)
                     {
                         glblMask = FALSE;
                         p_CcNode->glblMaskSize = 4;
@@ -4198,26 +4480,34 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
                     break;
 
                 case (e_FM_PCD_EXTRACT_FROM_HDR):
-                    p_CcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.size;
-                    p_CcNode->offset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
-                    p_CcNode->userOffset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
+                    p_CcNode->sizeOfExtraction =
+                            p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.size;
+                    p_CcNode->offset =
+                            p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
+                    p_CcNode->userOffset =
+                            p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
                     p_CcNode->parseCode =
-                        GetPrParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr,
-                                       p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
-                                       p_CcNode->offset,glblMask,
-                                       &p_CcNode->prsArrayOffset);
+                            GetPrParseCode(
+                                    p_CcNodeParam->extractCcParams.extractByHdr.hdr,
+                                    p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
+                                    p_CcNode->offset, glblMask,
+                                    &p_CcNode->prsArrayOffset);
                     break;
 
                 case (e_FM_PCD_EXTRACT_FROM_FIELD):
-                    p_CcNode->offset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
-                    p_CcNode->userOffset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
-                    p_CcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.size;
+                    p_CcNode->offset =
+                            p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
+                    p_CcNode->userOffset =
+                            p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
+                    p_CcNode->sizeOfExtraction =
+                            p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.size;
                     p_CcNode->parseCode =
-                        GetFieldParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr,
-                                          p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.field,
-                                          p_CcNode->offset,
-                                          &p_CcNode->prsArrayOffset,
-                                          p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex);
+                            GetFieldParseCode(
+                                    p_CcNodeParam->extractCcParams.extractByHdr.hdr,
+                                    p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.field,
+                                    p_CcNode->offset,
+                                    &p_CcNode->prsArrayOffset,
+                                    p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex);
                     break;
 
                 default:
@@ -4228,34 +4518,37 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
 
         case (e_FM_PCD_EXTRACT_NON_HDR):
             /* get the field code for the generic extract */
-            p_CcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractNonHdr.size;
-            p_CcNode->offset = p_CcNodeParam->extractCcParams.extractNonHdr.offset;
-            p_CcNode->userOffset = p_CcNodeParam->extractCcParams.extractNonHdr.offset;
-            p_CcNode->parseCode =
-                GetGenParseCode(h_FmPcd,
-                                p_CcNodeParam->extractCcParams.extractNonHdr.src,
-                                p_CcNode->offset,
-                                glblMask,
-                                &p_CcNode->prsArrayOffset,
-                                fromIc,icCode);
+            p_CcNode->sizeOfExtraction =
+                    p_CcNodeParam->extractCcParams.extractNonHdr.size;
+            p_CcNode->offset =
+                    p_CcNodeParam->extractCcParams.extractNonHdr.offset;
+            p_CcNode->userOffset =
+                    p_CcNodeParam->extractCcParams.extractNonHdr.offset;
+            p_CcNode->parseCode = GetGenParseCode(
+                    p_CcNodeParam->extractCcParams.extractNonHdr.src,
+                    p_CcNode->offset, glblMask, &p_CcNode->prsArrayOffset,
+                    fromIc, icCode);
 
             if (p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
             {
                 if ((p_CcNode->offset + p_CcNode->sizeOfExtraction) > 8)
                 {
-                     DeleteNode(p_CcNode);
-                     RETURN_ERROR(MAJOR, E_INVALID_SELECTION,("when node of the type CC_PC_GENERIC_IC_HASH_INDEXED offset + size can not be bigger then size of HASH 64 bits (8 bytes)"));
+                    DeleteNode(p_CcNode);
+                    RETURN_ERROR(
+                            MAJOR,
+                            E_INVALID_SELECTION,
+                            ("when node of the type CC_PC_GENERIC_IC_HASH_INDEXED offset + size can not be bigger then size of HASH 64 bits (8 bytes)"));
                 }
             }
-            if ((p_CcNode->parseCode == CC_PC_GENERIC_IC_GMASK) ||
-                (p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED))
+            if ((p_CcNode->parseCode == CC_PC_GENERIC_IC_GMASK)
+                    || (p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED))
             {
-                p_CcNode->offset +=  p_CcNode->prsArrayOffset;
+                p_CcNode->offset += p_CcNode->prsArrayOffset;
                 p_CcNode->prsArrayOffset = 0;
             }
             break;
 
-       default:
+        default:
             DeleteNode(p_CcNode);
             RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
     }
@@ -4266,33 +4559,37 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("illegal extraction type"));
     }
 
-    if ((p_CcNode->sizeOfExtraction > FM_PCD_MAX_SIZE_OF_KEY) ||
-        !p_CcNode->sizeOfExtraction)
+    if ((p_CcNode->sizeOfExtraction > FM_PCD_MAX_SIZE_OF_KEY)
+            || !p_CcNode->sizeOfExtraction)
     {
         DeleteNode(p_CcNode);
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("sizeOfExatrction can not be greater than 56 and not 0"));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("sizeOfExatrction can not be greater than 56 and not 0"));
     }
 
     if (p_CcNodeParam->keysParams.keySize != p_CcNode->sizeOfExtraction)
     {
         DeleteNode(p_CcNode);
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be equal to sizeOfExtraction"));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("keySize has to be equal to sizeOfExtraction"));
     }
 
     p_CcNode->userSizeOfExtraction = p_CcNode->sizeOfExtraction;
 
     if (!glblMask)
-        memset(p_CcNode->p_GlblMask, 0xff, CC_GLBL_MASK_SIZE  * sizeof(uint8_t));
+        memset(p_CcNode->p_GlblMask, 0xff, CC_GLBL_MASK_SIZE * sizeof(uint8_t));
 
     err = CheckAndSetManipParamsWithCcNodeParams(p_CcNode);
     if (err != E_OK)
     {
         DeleteNode(p_CcNode);
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be equal to sizeOfExtraction"));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("keySize has to be equal to sizeOfExtraction"));
     }
 
     /* Calculating matching table entry size by rounding up the user-defined size of extraction to valid entry size */
-    GetCcExtractKeySize(p_CcNode->sizeOfExtraction, &p_CcNode->ccKeySizeAccExtraction);
+    GetCcExtractKeySize(p_CcNode->sizeOfExtraction,
+                        &p_CcNode->ccKeySizeAccExtraction);
 
     /* If local mask is used, it is stored next to each key in the keys match table */
     if (p_CcNode->lclMask)
@@ -4303,9 +4600,7 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
     /* Update CC shadow with maximal size required by this node */
     if (p_CcNode->maxNumOfKeys)
     {
-        err = CalcAndUpdateCcShadow(p_CcNode,
-                                    isKeyTblAlloc,
-                                    &matchTableSize,
+        err = CalcAndUpdateCcShadow(p_CcNode, isKeyTblAlloc, &matchTableSize,
                                     &adTableSize);
         if (err != E_OK)
         {
@@ -4326,21 +4621,23 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
         }
 
         /* If manipulation will be initialized before this node, it will use the table
-           descriptor in the AD table of previous node and this node will need an extra
-           AD as his table descriptor. */
-        p_CcNode->h_TmpAd = (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
-                                                     FM_PCD_CC_AD_ENTRY_SIZE,
-                                                     FM_PCD_CC_AD_TABLE_ALIGN);
+         descriptor in the AD table of previous node and this node will need an extra
+         AD as his table descriptor. */
+        p_CcNode->h_TmpAd = (t_Handle)FM_MURAM_AllocMem(
+                h_FmMuram, FM_PCD_CC_AD_ENTRY_SIZE, FM_PCD_CC_AD_TABLE_ALIGN);
         if (!p_CcNode->h_TmpAd)
         {
             DeleteNode(p_CcNode);
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC action descriptor"));
+            RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                         ("MURAM allocation for CC action descriptor"));
         }
     }
     else
     {
-        matchTableSize = (uint32_t)(keySize * sizeof(uint8_t) * (p_CcNode->numOfKeys + 1));
-        adTableSize    = (uint32_t)(FM_PCD_CC_AD_ENTRY_SIZE * (p_CcNode->numOfKeys + 1));
+        matchTableSize = (uint32_t)(keySize * sizeof(uint8_t)
+                * (p_CcNode->numOfKeys + 1));
+        adTableSize = (uint32_t)(FM_PCD_CC_AD_ENTRY_SIZE
+                * (p_CcNode->numOfKeys + 1));
     }
 
 #if (DPAA_VERSION >= 11)
@@ -4349,22 +4646,26 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
 
         case e_FM_PCD_CC_STATS_MODE_RMON:
             /* If RMON statistics or RMON conditional statistics modes are requested,
-               allocate frame length ranges array */
-            p_CcNode->h_StatsFLRs =
-                    FM_MURAM_AllocMem(h_FmMuram,
-                                      (uint32_t)(p_CcNode->numOfStatsFLRs) * FM_PCD_CC_STATS_FLR_SIZE,
-                                      FM_PCD_CC_AD_TABLE_ALIGN);
+             allocate frame length ranges array */
+            p_CcNode->h_StatsFLRs = FM_MURAM_AllocMem(
+                    h_FmMuram,
+                    (uint32_t)(p_CcNode->numOfStatsFLRs)
+                            * FM_PCD_CC_STATS_FLR_SIZE,
+                    FM_PCD_CC_AD_TABLE_ALIGN);
 
             if (!p_CcNode->h_StatsFLRs)
             {
                 DeleteNode(p_CcNode);
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC frame length ranges array"));
+                RETURN_ERROR(
+                        MAJOR, E_NO_MEMORY,
+                        ("MURAM allocation for CC frame length ranges array"));
             }
 
             /* Initialize using value received from the user */
             for (tmp = 0; tmp < p_CcNode->numOfStatsFLRs; tmp++)
             {
-                h_StatsFLRs = PTR_MOVE(p_CcNode->h_StatsFLRs, tmp * FM_PCD_CC_STATS_FLR_SIZE);
+                h_StatsFLRs =
+                        PTR_MOVE(p_CcNode->h_StatsFLRs, tmp * FM_PCD_CC_STATS_FLR_SIZE);
 
                 Mem2IOCpy32(h_StatsFLRs,
                             &(p_CcNodeParam->keysParams.frameLengthRanges[tmp]),
@@ -4377,39 +4678,34 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
     }
 #endif /* (DPAA_VERSION >= 11) */
 
-
     /* Allocate keys match table. Not required for some CC nodes, for example for IPv4 TTL
-       identification, IPv6 hop count identification, etc. */
+     identification, IPv6 hop count identification, etc. */
     if (isKeyTblAlloc)
     {
-        p_CcNode->h_KeysMatchTable =
-            (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
-                                        matchTableSize,
-                                        FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
+        p_CcNode->h_KeysMatchTable = (t_Handle)FM_MURAM_AllocMem(
+                h_FmMuram, matchTableSize, FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
         if (!p_CcNode->h_KeysMatchTable)
         {
             DeleteNode(p_CcNode);
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node key match table"));
+            RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                         ("MURAM allocation for CC node key match table"));
         }
-        IOMemSet32((uint8_t *)p_CcNode->h_KeysMatchTable,
-                   0,
-                   matchTableSize);
+        IOMemSet32((uint8_t *)p_CcNode->h_KeysMatchTable, 0, matchTableSize);
     }
 
     /* Allocate action descriptors table */
-    p_CcNode->h_AdTable =
-        (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
-                                    adTableSize,
-                                    FM_PCD_CC_AD_TABLE_ALIGN);
+    p_CcNode->h_AdTable = (t_Handle)FM_MURAM_AllocMem(h_FmMuram, adTableSize,
+                                                      FM_PCD_CC_AD_TABLE_ALIGN);
     if (!p_CcNode->h_AdTable)
     {
         DeleteNode(p_CcNode);
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node action descriptors table"));
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("MURAM allocation for CC node action descriptors table"));
     }
     IOMemSet32((uint8_t *)p_CcNode->h_AdTable, 0, adTableSize);
 
     p_KeysMatchTblTmp = p_CcNode->h_KeysMatchTable;
-    p_AdTableTmp      = p_CcNode->h_AdTable;
+    p_AdTableTmp = p_CcNode->h_AdTable;
 
     /* For each key, create the key and the next step AD */
     for (tmp = 0; tmp < p_CcNode->numOfKeys; tmp++)
@@ -4419,25 +4715,26 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
         if (p_KeysMatchTblTmp)
         {
             /* Copy the key */
-            Mem2IOCpy32((void*)p_KeysMatchTblTmp, p_KeyParams->p_Key, p_CcNode->sizeOfExtraction);
+            Mem2IOCpy32((void*)p_KeysMatchTblTmp, p_KeyParams->p_Key,
+                        p_CcNode->sizeOfExtraction);
 
             /* Copy the key mask or initialize it to 0xFF..F */
             if (p_CcNode->lclMask && p_KeyParams->p_Mask)
             {
                 Mem2IOCpy32(PTR_MOVE(p_KeysMatchTblTmp,
-                                     p_CcNode->ccKeySizeAccExtraction),     /* User's size of extraction rounded up to a valid matching table entry size */
-                            p_KeyParams->p_Mask,
-                            p_CcNode->sizeOfExtraction);           /* Exact size of extraction as received from the user */
-            }
-            else if (p_CcNode->lclMask)
-            {
-                IOMemSet32(PTR_MOVE(p_KeysMatchTblTmp,
-                                    p_CcNode->ccKeySizeAccExtraction),     /* User's size of extraction rounded up to a valid matching table entry size */
-                           0xff,
-                           p_CcNode->sizeOfExtraction);           /* Exact size of extraction as received from the user */
+                        p_CcNode->ccKeySizeAccExtraction), /* User's size of extraction rounded up to a valid matching table entry size */
+                            p_KeyParams->p_Mask, p_CcNode->sizeOfExtraction); /* Exact size of extraction as received from the user */
             }
+            else
+                if (p_CcNode->lclMask)
+                {
+                    IOMemSet32(PTR_MOVE(p_KeysMatchTblTmp,
+                            p_CcNode->ccKeySizeAccExtraction), /* User's size of extraction rounded up to a valid matching table entry size */
+                               0xff, p_CcNode->sizeOfExtraction); /* Exact size of extraction as received from the user */
+                }
 
-            p_KeysMatchTblTmp = PTR_MOVE(p_KeysMatchTblTmp, keySize * sizeof(uint8_t));
+            p_KeysMatchTblTmp =
+                    PTR_MOVE(p_KeysMatchTblTmp, keySize * sizeof(uint8_t));
         }
 
         /* Create the next action descriptor in the match table */
@@ -4452,18 +4749,14 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
             statsParams.h_StatsFLRs = p_CcNode->h_StatsFLRs;
 
 #endif /* (DPAA_VERSION >= 11) */
-            NextStepAd(p_AdTableTmp,
-                       &statsParams,
-                       &p_KeyParams->ccNextEngineParams,
-                       p_FmPcd);
+            NextStepAd(p_AdTableTmp, &statsParams,
+                       &p_KeyParams->ccNextEngineParams, p_FmPcd);
 
             p_CcNode->keyAndNextEngineParams[tmp].p_StatsObj = p_StatsObj;
         }
         else
         {
-            NextStepAd(p_AdTableTmp,
-                       NULL,
-                       &p_KeyParams->ccNextEngineParams,
+            NextStepAd(p_AdTableTmp, NULL, &p_KeyParams->ccNextEngineParams,
                        p_FmPcd);
 
             p_CcNode->keyAndNextEngineParams[tmp].p_StatsObj = NULL;
@@ -4479,8 +4772,8 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
         ASSERT_COND(p_StatsObj);
 
         /* All 'bucket' nodes of a hash table should share the same statistics counters,
-           allocated by the hash table. So, if this node is a bucket of a hash table,
-           we'll replace the locally allocated counters with the shared counters. */
+         allocated by the hash table. So, if this node is a bucket of a hash table,
+         we'll replace the locally allocated counters with the shared counters. */
         if (p_CcNode->isHashBucket)
         {
             ASSERT_COND(p_CcNode->h_MissStatsCounters);
@@ -4497,8 +4790,7 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
 
 #endif /* (DPAA_VERSION >= 11) */
 
-        NextStepAd(p_AdTableTmp,
-                   &statsParams,
+        NextStepAd(p_AdTableTmp, &statsParams,
                    &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
                    p_FmPcd);
 
@@ -4506,8 +4798,7 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
     }
     else
     {
-        NextStepAd(p_AdTableTmp,
-                   NULL,
+        NextStepAd(p_AdTableTmp, NULL,
                    &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
                    p_FmPcd);
 
@@ -4515,18 +4806,20 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
     }
 
     /* This parameter will be used to initialize the "key length" field in the action descriptor
-       that points to this node and it should be 0 for full field extraction */
+     that points to this node and it should be 0 for full field extraction */
     if (fullField == TRUE)
         p_CcNode->sizeOfExtraction = 0;
 
     for (tmp = 0; tmp < MIN(p_CcNode->numOfKeys + 1, CC_MAX_NUM_OF_KEYS); tmp++)
     {
-        if (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
+        if (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine
+                == e_FM_PCD_CC)
         {
-            p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode;
-            p_CcInformation = FindNodeInfoInReleventLst(&p_FmPcdCcNextNode->ccPrevNodesLst,
-                                                        (t_Handle)p_CcNode,
-                                                        p_FmPcdCcNextNode->h_Spinlock);
+            p_FmPcdCcNextNode =
+                    (t_FmPcdCcNode*)p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode;
+            p_CcInformation = FindNodeInfoInReleventLst(
+                    &p_FmPcdCcNextNode->ccPrevNodesLst, (t_Handle)p_CcNode,
+                    p_FmPcdCcNextNode->h_Spinlock);
             if (!p_CcInformation)
             {
                 memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
@@ -4541,18 +4834,19 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
 
             if (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
             {
-                h_Manip = p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip;
-                p_CcInformation = FindNodeInfoInReleventLst(FmPcdManipGetNodeLstPointedOnThisManip(h_Manip),
-                                                             (t_Handle)p_CcNode,
-                                                             FmPcdManipGetSpinlock(h_Manip));
+                h_Manip =
+                        p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip;
+                p_CcInformation = FindNodeInfoInReleventLst(
+                        FmPcdManipGetNodeLstPointedOnThisManip(h_Manip),
+                        (t_Handle)p_CcNode, FmPcdManipGetSpinlock(h_Manip));
                 if (!p_CcInformation)
                 {
-                     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
-                     ccNodeInfo.h_CcNode = (t_Handle)p_CcNode;
-                     ccNodeInfo.index = 1;
-                     EnqueueNodeInfoToRelevantLst(FmPcdManipGetNodeLstPointedOnThisManip(h_Manip),
-                                                  &ccNodeInfo,
-                                                  FmPcdManipGetSpinlock(h_Manip));
+                    memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
+                    ccNodeInfo.h_CcNode = (t_Handle)p_CcNode;
+                    ccNodeInfo.index = 1;
+                    EnqueueNodeInfoToRelevantLst(
+                            FmPcdManipGetNodeLstPointedOnThisManip(h_Manip),
+                            &ccNodeInfo, FmPcdManipGetSpinlock(h_Manip));
                 }
                 else
                     p_CcInformation->index++;
@@ -4574,12 +4868,11 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
     {
         if (p_CcNode->keyAndNextEngineParams[tmp].requiredAction)
         {
-            err = SetRequiredAction(h_FmPcd,
-                                    p_CcNode->keyAndNextEngineParams[tmp].requiredAction,
-                                    &p_CcNode->keyAndNextEngineParams[tmp],
-                                    p_AdTableTmp,
-                                    1,
-                                    NULL);
+            err = SetRequiredAction(
+                    h_FmPcd,
+                    p_CcNode->keyAndNextEngineParams[tmp].requiredAction,
+                    &p_CcNode->keyAndNextEngineParams[tmp], p_AdTableTmp, 1,
+                    NULL);
             if (err)
             {
                 FmPcdLockUnlockAll(h_FmPcd);
@@ -4596,20 +4889,21 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode, t_FmPcdC
 }
 /************************** End of static functions **************************/
 
-
 /*****************************************************************************/
 /*              Inter-module API routines                                    */
 /*****************************************************************************/
 
-t_CcNodeInformation* FindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info, t_Handle h_Spinlock)
+t_CcNodeInformation* FindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info,
+                                               t_Handle h_Spinlock)
 {
     t_CcNodeInformation *p_CcInformation;
-    t_List              *p_Pos;
-    uint32_t            intFlags;
+    t_List *p_Pos;
+    uint32_t intFlags;
 
     intFlags = XX_LockIntrSpinlock(h_Spinlock);
 
-    for (p_Pos = LIST_FIRST(p_List); p_Pos != (p_List); p_Pos = LIST_NEXT(p_Pos))
+    for (p_Pos = LIST_FIRST(p_List); p_Pos != (p_List);
+            p_Pos = LIST_NEXT(p_Pos))
     {
         p_CcInformation = CC_NODE_F_OBJECT(p_Pos);
 
@@ -4627,12 +4921,14 @@ t_CcNodeInformation* FindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info,
     return NULL;
 }
 
-void EnqueueNodeInfoToRelevantLst(t_List *p_List, t_CcNodeInformation *p_CcInfo, t_Handle h_Spinlock)
+void EnqueueNodeInfoToRelevantLst(t_List *p_List, t_CcNodeInformation *p_CcInfo,
+                                  t_Handle h_Spinlock)
 {
     t_CcNodeInformation *p_CcInformation;
-    uint32_t            intFlags = 0;
+    uint32_t intFlags = 0;
 
-    p_CcInformation = (t_CcNodeInformation *)XX_Malloc(sizeof(t_CcNodeInformation));
+    p_CcInformation = (t_CcNodeInformation *)XX_Malloc(
+            sizeof(t_CcNodeInformation));
 
     if (p_CcInformation)
     {
@@ -4652,11 +4948,12 @@ void EnqueueNodeInfoToRelevantLst(t_List *p_List, t_CcNodeInformation *p_CcInfo,
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("CC Node Information"));
 }
 
-void DequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info, t_Handle h_Spinlock)
+void DequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info,
+                                    t_Handle h_Spinlock)
 {
     t_CcNodeInformation *p_CcInformation = NULL;
-    uint32_t            intFlags = 0;
-    t_List              *p_Pos;
+    uint32_t intFlags = 0;
+    t_List *p_Pos;
 
     if (h_Spinlock)
         intFlags = XX_LockIntrSpinlock(h_Spinlock);
@@ -4667,7 +4964,8 @@ void DequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info, t_Handle h_
         return;
     }
 
-    for (p_Pos = LIST_FIRST(p_List); p_Pos != (p_List); p_Pos = LIST_NEXT(p_Pos))
+    for (p_Pos = LIST_FIRST(p_List); p_Pos != (p_List);
+            p_Pos = LIST_NEXT(p_Pos))
     {
         p_CcInformation = CC_NODE_F_OBJECT(p_Pos);
         ASSERT_COND(p_CcInformation);
@@ -4686,10 +4984,9 @@ void DequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info, t_Handle h_
         XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
 }
 
-void NextStepAd(t_Handle                     h_Ad,
-                t_FmPcdCcStatsParams         *p_FmPcdCcStatsParams,
-                t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams,
-                t_FmPcd                      *p_FmPcd)
+void NextStepAd(t_Handle h_Ad, t_FmPcdCcStatsParams *p_FmPcdCcStatsParams,
+                t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,
+                t_FmPcd *p_FmPcd)
 {
     switch (p_FmPcdCcNextEngineParams->nextEngine)
     {
@@ -4697,57 +4994,52 @@ void NextStepAd(t_Handle                     h_Ad,
         case (e_FM_PCD_PLCR):
         case (e_FM_PCD_DONE):
             /* if NIA is not CC, create a "result" type AD */
-            FillAdOfTypeResult(h_Ad,
-                               p_FmPcdCcStatsParams,
-                               p_FmPcd,
+            FillAdOfTypeResult(h_Ad, p_FmPcdCcStatsParams, p_FmPcd,
                                p_FmPcdCcNextEngineParams);
             break;
 #if (DPAA_VERSION >= 11)
         case (e_FM_PCD_FR):
             if (p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic)
             {
-                FillAdOfTypeContLookup(h_Ad,
-                                       p_FmPcdCcStatsParams,
-                                       p_FmPcd,
-                                       p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
-                                       p_FmPcdCcNextEngineParams->h_Manip,
-                                       p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic);
-                FrmReplicGroupUpdateOwner(p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic,
-                                          TRUE/* add */);
+                FillAdOfTypeContLookup(
+                        h_Ad, p_FmPcdCcStatsParams, p_FmPcd,
+                        p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
+                        p_FmPcdCcNextEngineParams->h_Manip,
+                        p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic);
+                FrmReplicGroupUpdateOwner(
+                        p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic,
+                        TRUE/* add */);
             }
             break;
 #endif /* (DPAA_VERSION >= 11) */
 
         case (e_FM_PCD_CC):
             /* if NIA is not CC, create a TD to continue the CC lookup */
-            FillAdOfTypeContLookup(h_Ad,
-                                   p_FmPcdCcStatsParams,
-                                   p_FmPcd,
-                                   p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
-                                   p_FmPcdCcNextEngineParams->h_Manip,
-                                   NULL);
-
-            UpdateNodeOwner(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode, TRUE);
+            FillAdOfTypeContLookup(
+                    h_Ad, p_FmPcdCcStatsParams, p_FmPcd,
+                    p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
+                    p_FmPcdCcNextEngineParams->h_Manip, NULL);
+
+            UpdateNodeOwner(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
+                            TRUE);
             break;
 
-         default:
-             return;
+        default:
+            return;
     }
 }
 
-t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
-                          t_Handle  h_FmTree,
-                          t_Handle  h_NetEnv,
-                          t_Handle  h_IpReassemblyManip,
-                          bool      createSchemes)
+t_Error FmPcdCcTreeAddIPR(t_Handle h_FmPcd, t_Handle h_FmTree,
+                          t_Handle h_NetEnv, t_Handle h_IpReassemblyManip,
+                          bool createSchemes)
 {
-    t_FmPcdCcTree               *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
-    t_FmPcdCcNextEngineParams   nextEngineParams;
-    t_NetEnvParams              netEnvParams;
-    t_Handle                    h_Ad;
-    bool                        isIpv6Present;
-    uint8_t                     ipv4GroupId, ipv6GroupId;
-    t_Error                     err;
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
+    t_FmPcdCcNextEngineParams nextEngineParams;
+    t_NetEnvParams netEnvParams;
+    t_Handle h_Ad;
+    bool isIpv6Present;
+    uint8_t ipv4GroupId, ipv6GroupId;
+    t_Error err;
 
     ASSERT_COND(p_FmPcdCcTree);
 
@@ -4760,10 +5052,11 @@ t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
 
     isIpv6Present = FmPcdManipIpReassmIsIpv6Hdr(h_IpReassemblyManip);
 
-    if (isIpv6Present && (p_FmPcdCcTree->numOfEntries > (FM_PCD_MAX_NUM_OF_CC_GROUPS-2)))
+    if (isIpv6Present
+            && (p_FmPcdCcTree->numOfEntries > (FM_PCD_MAX_NUM_OF_CC_GROUPS - 2)))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("need two free entries for IPR"));
 
-    if (p_FmPcdCcTree->numOfEntries > (FM_PCD_MAX_NUM_OF_CC_GROUPS-1))
+    if (p_FmPcdCcTree->numOfEntries > (FM_PCD_MAX_NUM_OF_CC_GROUPS - 1))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("need two free entries for IPR"));
 
     nextEngineParams.nextEngine = e_FM_PCD_DONE;
@@ -4780,22 +5073,27 @@ t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
         return E_OK;
     }
 
-    if ((p_FmPcdCcTree->h_IpReassemblyManip) &&
-        (p_FmPcdCcTree->h_IpReassemblyManip != h_IpReassemblyManip))
+    if ((p_FmPcdCcTree->h_IpReassemblyManip)
+            && (p_FmPcdCcTree->h_IpReassemblyManip != h_IpReassemblyManip))
     {
         CcRootReleaseLock(p_FmPcdCcTree);
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This tree was previously updated with different IPR"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                     ("This tree was previously updated with different IPR"));
     }
 
     /* Initialize IPR for the first time for this tree */
     if (isIpv6Present)
     {
         ipv6GroupId = p_FmPcdCcTree->numOfGrps++;
-        p_FmPcdCcTree->fmPcdGroupParam[ipv6GroupId].baseGroupEntry = (FM_PCD_MAX_NUM_OF_CC_GROUPS-2);
+        p_FmPcdCcTree->fmPcdGroupParam[ipv6GroupId].baseGroupEntry =
+                (FM_PCD_MAX_NUM_OF_CC_GROUPS - 2);
 
         if (createSchemes)
         {
-            err = FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv, p_FmPcdCcTree, h_IpReassemblyManip, FALSE, ipv6GroupId);
+            err = FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv,
+                                                p_FmPcdCcTree,
+                                                h_IpReassemblyManip, FALSE,
+                                                ipv6GroupId);
             if (err)
             {
                 p_FmPcdCcTree->numOfGrps--;
@@ -4804,19 +5102,21 @@ t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
             }
         }
 
-        NextStepAd(PTR_MOVE(h_Ad, (FM_PCD_MAX_NUM_OF_CC_GROUPS-2) * FM_PCD_CC_AD_ENTRY_SIZE),
-                   NULL,
-                   &nextEngineParams,
-                   h_FmPcd);
+        NextStepAd(
+                PTR_MOVE(h_Ad, (FM_PCD_MAX_NUM_OF_CC_GROUPS-2) * FM_PCD_CC_AD_ENTRY_SIZE),
+                NULL, &nextEngineParams, h_FmPcd);
     }
 
     ipv4GroupId = p_FmPcdCcTree->numOfGrps++;
     p_FmPcdCcTree->fmPcdGroupParam[ipv4GroupId].totalBitsMask = 0;
-    p_FmPcdCcTree->fmPcdGroupParam[ipv4GroupId].baseGroupEntry = (FM_PCD_MAX_NUM_OF_CC_GROUPS-1);
+    p_FmPcdCcTree->fmPcdGroupParam[ipv4GroupId].baseGroupEntry =
+            (FM_PCD_MAX_NUM_OF_CC_GROUPS - 1);
 
     if (createSchemes)
     {
-        err = FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv, p_FmPcdCcTree, h_IpReassemblyManip, TRUE, ipv4GroupId);
+        err = FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv, p_FmPcdCcTree,
+                                            h_IpReassemblyManip, TRUE,
+                                            ipv4GroupId);
         if (err)
         {
             p_FmPcdCcTree->numOfGrps--;
@@ -4830,10 +5130,9 @@ t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
         }
     }
 
-    NextStepAd(PTR_MOVE(h_Ad, (FM_PCD_MAX_NUM_OF_CC_GROUPS-1) * FM_PCD_CC_AD_ENTRY_SIZE),
-               NULL,
-               &nextEngineParams,
-               h_FmPcd);
+    NextStepAd(
+            PTR_MOVE(h_Ad, (FM_PCD_MAX_NUM_OF_CC_GROUPS-1) * FM_PCD_CC_AD_ENTRY_SIZE),
+            NULL, &nextEngineParams, h_FmPcd);
 
     p_FmPcdCcTree->h_IpReassemblyManip = h_IpReassemblyManip;
 
@@ -4842,6 +5141,78 @@ t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
     return E_OK;
 }
 
+t_Error FmPcdCcTreeAddCPR(t_Handle h_FmPcd, t_Handle h_FmTree,
+                          t_Handle h_NetEnv, t_Handle h_ReassemblyManip,
+                          bool createSchemes)
+{
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
+    t_FmPcdCcNextEngineParams nextEngineParams;
+    t_NetEnvParams netEnvParams;
+    t_Handle h_Ad;
+    uint8_t groupId;
+    t_Error err;
+
+    ASSERT_COND(p_FmPcdCcTree);
+
+    /* this routine must be protected by the calling routine! */
+    memset(&nextEngineParams, 0, sizeof(t_FmPcdCcNextEngineParams));
+    memset(&netEnvParams, 0, sizeof(t_NetEnvParams));
+
+    h_Ad = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
+
+    if (p_FmPcdCcTree->numOfEntries > (FM_PCD_MAX_NUM_OF_CC_GROUPS - 1))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("need one free entries for CPR"));
+
+    nextEngineParams.nextEngine = e_FM_PCD_DONE;
+    nextEngineParams.h_Manip = h_ReassemblyManip;
+
+    /* Lock tree */
+    err = CcRootTryLock(p_FmPcdCcTree);
+    if (err)
+        return ERROR_CODE(E_BUSY);
+
+    if (p_FmPcdCcTree->h_CapwapReassemblyManip == h_ReassemblyManip)
+    {
+        CcRootReleaseLock(p_FmPcdCcTree);
+        return E_OK;
+    }
+
+    if ((p_FmPcdCcTree->h_CapwapReassemblyManip)
+            && (p_FmPcdCcTree->h_CapwapReassemblyManip != h_ReassemblyManip))
+    {
+        CcRootReleaseLock(p_FmPcdCcTree);
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                     ("This tree was previously updated with different CPR"));
+    }
+
+    groupId = p_FmPcdCcTree->numOfGrps++;
+    p_FmPcdCcTree->fmPcdGroupParam[groupId].baseGroupEntry =
+            (FM_PCD_MAX_NUM_OF_CC_GROUPS - 1);
+
+    if (createSchemes)
+    {
+        err = FmPcdManipBuildCapwapReassmScheme(h_FmPcd, h_NetEnv,
+                                                p_FmPcdCcTree,
+                                                h_ReassemblyManip, groupId);
+        if (err)
+        {
+            p_FmPcdCcTree->numOfGrps--;
+            CcRootReleaseLock(p_FmPcdCcTree);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+    }
+
+    NextStepAd(
+            PTR_MOVE(h_Ad, (FM_PCD_MAX_NUM_OF_CC_GROUPS-1) * FM_PCD_CC_AD_ENTRY_SIZE),
+            NULL, &nextEngineParams, h_FmPcd);
+
+    p_FmPcdCcTree->h_CapwapReassemblyManip = h_ReassemblyManip;
+
+    CcRootReleaseLock(p_FmPcdCcTree);
+
+    return E_OK;
+}
+
 t_Handle FmPcdCcTreeGetSavedManipParams(t_Handle h_FmTree)
 {
     t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
@@ -4851,7 +5222,8 @@ t_Handle FmPcdCcTreeGetSavedManipParams(t_Handle h_FmTree)
     return p_FmPcdCcTree->h_FmPcdCcSavedManipParams;
 }
 
-void   FmPcdCcTreeSetSavedManipParams(t_Handle h_FmTree, t_Handle h_SavedManipParams)
+void FmPcdCcTreeSetSavedManipParams(t_Handle h_FmTree,
+                                    t_Handle h_SavedManipParams)
 {
     t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
 
@@ -4887,25 +5259,24 @@ uint16_t FmPcdCcGetNumOfKeys(t_Handle h_CcNode)
     return p_CcNode->numOfKeys;
 }
 
-t_Error FmPcdCcModifyNextEngineParamTree(t_Handle                   h_FmPcd,
-                                         t_Handle                   h_FmPcdCcTree,
-                                         uint8_t                    grpId,
-                                         uint8_t                    index,
-                                         t_FmPcdCcNextEngineParams  *p_FmPcdCcNextEngineParams)
+t_Error FmPcdCcModifyNextEngineParamTree(
+        t_Handle h_FmPcd, t_Handle h_FmPcdCcTree, uint8_t grpId, uint8_t index,
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcdCcTree                       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
-    t_FmPcd                             *p_FmPcd;
-    t_List                              h_OldPointersLst, h_NewPointersLst;
-    uint16_t                            keyIndex;
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_FmPcd *p_FmPcd;
+    t_List h_OldPointersLst, h_NewPointersLst;
+    uint16_t keyIndex;
     t_FmPcdModifyCcKeyAdditionalParams *p_ModifyKeyParams;
-    t_Error                             err = E_OK;
+    t_Error err = E_OK;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR((grpId <= 7),E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((grpId <= 7), E_INVALID_VALUE);
 
     if (grpId >= p_FmPcdCcTree->numOfGrps)
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("grpId you asked > numOfGroup of relevant tree"));
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE,
+                     ("grpId you asked > numOfGroup of relevant tree"));
 
     if (index >= p_FmPcdCcTree->fmPcdGroupParam[grpId].numOfEntriesInGroup)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("index > numOfEntriesInGroup"));
@@ -4915,27 +5286,27 @@ t_Error FmPcdCcModifyNextEngineParamTree(t_Handle                   h_FmPcd,
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    keyIndex = (uint16_t)(p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry + index);
+    keyIndex = (uint16_t)(p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry
+            + index);
 
-    p_ModifyKeyParams = ModifyNodeCommonPart(p_FmPcdCcTree, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, FALSE, TRUE);
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_FmPcdCcTree, keyIndex,
+                                             e_MODIFY_STATE_CHANGE, FALSE,
+                                             FALSE, TRUE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
     p_ModifyKeyParams->tree = TRUE;
 
-    if (p_FmPcd->p_CcShadow &&
-        !TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+    if (p_FmPcd->p_CcShadow
+            && !TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
     {
         XX_Free(p_ModifyKeyParams);
         return ERROR_CODE(E_BUSY);
     }
 
-    err = BuildNewNodeModifyNextEngine(p_FmPcd,
-                                       p_FmPcdCcTree,
-                                       keyIndex,
+    err = BuildNewNodeModifyNextEngine(p_FmPcd, p_FmPcdCcTree, keyIndex,
                                        p_FmPcdCcNextEngineParams,
-                                       &h_OldPointersLst,
-                                       &h_NewPointersLst,
+                                       &h_OldPointersLst, &h_NewPointersLst,
                                        p_ModifyKeyParams);
     if (err)
     {
@@ -4943,7 +5314,8 @@ t_Error FmPcdCcModifyNextEngineParamTree(t_Handle                   h_FmPcd,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst, p_ModifyKeyParams, FALSE);
+    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst,
+                          p_ModifyKeyParams, FALSE);
 
     if (p_FmPcd->p_CcShadow)
         RELEASE_LOCK(p_FmPcd->shadowLock);
@@ -4952,33 +5324,35 @@ t_Error FmPcdCcModifyNextEngineParamTree(t_Handle                   h_FmPcd,
 
 }
 
-t_Error FmPcdCcRemoveKey(t_Handle   h_FmPcd,
-                         t_Handle   h_FmPcdCcNode,
-                         uint16_t   keyIndex)
+t_Error FmPcdCcRemoveKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode,
+                         uint16_t keyIndex)
 {
 
-    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *) h_FmPcdCcNode;
-    t_FmPcd                             *p_FmPcd;
-    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
-    t_List                              h_OldPointersLst, h_NewPointersLst;
-    bool                                useShadowStructs = FALSE;
-    t_Error                             err = E_OK;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdModifyCcKeyAdditionalParams *p_ModifyKeyParams;
+    t_List h_OldPointersLst, h_NewPointersLst;
+    bool useShadowStructs = FALSE;
+    t_Error err = E_OK;
 
     if (keyIndex >= p_CcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("impossible to remove key when numOfKeys <= keyIndex"));
-
-    if (!p_CcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keyIndex you asked > numOfKeys of relevant node that was initialized"));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("impossible to remove key when numOfKeys <= keyIndex"));
 
     if (p_CcNode->h_FmPcd != h_FmPcd)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("handler to FmPcd is different from the handle provided at node initialization time"));
 
     p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
 
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex, e_MODIFY_STATE_REMOVE, TRUE, TRUE, FALSE);
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex,
+                                             e_MODIFY_STATE_REMOVE, TRUE, TRUE,
+                                             FALSE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
@@ -5002,8 +5376,7 @@ t_Error FmPcdCcRemoveKey(t_Handle   h_FmPcd,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode,
-                                           p_ModifyKeyParams,
+    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode, p_ModifyKeyParams,
                                            &h_OldPointersLst,
                                            &h_NewPointersLst);
     if (err)
@@ -5015,11 +5388,8 @@ t_Error FmPcdCcRemoveKey(t_Handle   h_FmPcd,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = DoDynamicChange(p_FmPcd,
-                          &h_OldPointersLst,
-                          &h_NewPointersLst,
-                          p_ModifyKeyParams,
-                          useShadowStructs);
+    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst,
+                          p_ModifyKeyParams, useShadowStructs);
 
     if (p_CcNode->maxNumOfKeys)
         RELEASE_LOCK(p_FmPcd->shadowLock);
@@ -5027,45 +5397,49 @@ t_Error FmPcdCcRemoveKey(t_Handle   h_FmPcd,
     return err;
 }
 
-t_Error FmPcdCcModifyKey(t_Handle   h_FmPcd,
-                         t_Handle   h_FmPcdCcNode,
-                         uint16_t   keyIndex,
-                         uint8_t    keySize,
-                         uint8_t    *p_Key,
-                         uint8_t    *p_Mask)
+t_Error FmPcdCcModifyKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode,
+                         uint16_t keyIndex, uint8_t keySize, uint8_t *p_Key,
+                         uint8_t *p_Mask)
 {
-    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
-    t_FmPcd                             *p_FmPcd;
-    t_List                              h_OldPointersLst, h_NewPointersLst;
-    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
-    uint16_t                            tmpKeyIndex;
-    bool                                useShadowStructs = FALSE;
-    t_Error                             err = E_OK;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd *p_FmPcd;
+    t_List h_OldPointersLst, h_NewPointersLst;
+    t_FmPcdModifyCcKeyAdditionalParams *p_ModifyKeyParams;
+    uint16_t tmpKeyIndex;
+    bool useShadowStructs = FALSE;
+    t_Error err = E_OK;
 
     if (keyIndex >= p_CcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previously cleared last index + 1"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                     ("keyIndex > previously cleared last index + 1"));
 
     if (keySize != p_CcNode->userSizeOfExtraction)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("size for ModifyKey has to be the same as defined in SetNode"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("size for ModifyKey has to be the same as defined in SetNode"));
 
     if (p_CcNode->h_FmPcd != h_FmPcd)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("handler to FmPcd is different from the handle provided at node initialization time"));
 
-    err = FindKeyIndex(h_FmPcdCcNode,
-                       keySize,
-                       p_Key,
-                       p_Mask,
-                       &tmpKeyIndex);
+    err = FindKeyIndex(h_FmPcdCcNode, keySize, p_Key, p_Mask, &tmpKeyIndex);
     if (GET_ERROR_TYPE(err) != E_NOT_FOUND)
-        RETURN_ERROR(MINOR, E_ALREADY_EXISTS,
-                     ("The received key and mask pair was already found in the match table of the provided node"));
+        RETURN_ERROR(
+                MINOR,
+                E_ALREADY_EXISTS,
+                ("The received key and mask pair was already found in the match table of the provided node"));
 
     p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
 
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, TRUE, TRUE, FALSE);
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex,
+                                             e_MODIFY_STATE_CHANGE, TRUE, TRUE,
+                                             FALSE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
@@ -5080,10 +5454,7 @@ t_Error FmPcdCcModifyKey(t_Handle   h_FmPcd,
         useShadowStructs = TRUE;
     }
 
-    err = BuildNewNodeModifyKey(p_CcNode,
-                                keyIndex,
-                                p_Key,
-                                p_Mask,
+    err = BuildNewNodeModifyKey(p_CcNode, keyIndex, p_Key, p_Mask,
                                 p_ModifyKeyParams);
     if (err)
     {
@@ -5093,8 +5464,7 @@ t_Error FmPcdCcModifyKey(t_Handle   h_FmPcd,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode,
-                                           p_ModifyKeyParams,
+    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode, p_ModifyKeyParams,
                                            &h_OldPointersLst,
                                            &h_NewPointersLst);
     if (err)
@@ -5106,11 +5476,8 @@ t_Error FmPcdCcModifyKey(t_Handle   h_FmPcd,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = DoDynamicChange(p_FmPcd,
-                          &h_OldPointersLst,
-                          &h_NewPointersLst,
-                          p_ModifyKeyParams,
-                          useShadowStructs);
+    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst,
+                          p_ModifyKeyParams, useShadowStructs);
 
     if (p_CcNode->maxNumOfKeys)
         RELEASE_LOCK(p_FmPcd->shadowLock);
@@ -5118,18 +5485,18 @@ t_Error FmPcdCcModifyKey(t_Handle   h_FmPcd,
     return err;
 }
 
-t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle                   h_FmPcd,
-                                             t_Handle                   h_FmPcdCcNode,
-                                             t_FmPcdCcNextEngineParams  *p_FmPcdCcNextEngineParams)
+t_Error FmPcdCcModifyMissNextEngineParamNode(
+        t_Handle h_FmPcd, t_Handle h_FmPcdCcNode,
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
-    t_FmPcd                             *p_FmPcd;
-    t_List                              h_OldPointersLst, h_NewPointersLst;
-    uint16_t                            keyIndex;
-    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
-    t_Error                             err = E_OK;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd *p_FmPcd;
+    t_List h_OldPointersLst, h_NewPointersLst;
+    uint16_t keyIndex;
+    t_FmPcdModifyCcKeyAdditionalParams *p_ModifyKeyParams;
+    t_Error err = E_OK;
 
-    SANITY_CHECK_RETURN_ERROR(p_CcNode,E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_VALUE);
 
     keyIndex = p_CcNode->numOfKeys;
 
@@ -5138,23 +5505,22 @@ t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle                   h_FmPcd,
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, TRUE, FALSE);
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex,
+                                             e_MODIFY_STATE_CHANGE, FALSE, TRUE,
+                                             FALSE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
-    if (p_CcNode->maxNumOfKeys &&
-        !TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+    if (p_CcNode->maxNumOfKeys
+            && !TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
     {
         XX_Free(p_ModifyKeyParams);
         return ERROR_CODE(E_BUSY);
     }
 
-    err = BuildNewNodeModifyNextEngine(h_FmPcd,
-                                       p_CcNode,
-                                       keyIndex,
+    err = BuildNewNodeModifyNextEngine(h_FmPcd, p_CcNode, keyIndex,
                                        p_FmPcdCcNextEngineParams,
-                                       &h_OldPointersLst,
-                                       &h_NewPointersLst,
+                                       &h_OldPointersLst, &h_NewPointersLst,
                                        p_ModifyKeyParams);
     if (err)
     {
@@ -5164,7 +5530,8 @@ t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle                   h_FmPcd,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst, p_ModifyKeyParams, FALSE);
+    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst,
+                          p_ModifyKeyParams, FALSE);
 
     if (p_CcNode->maxNumOfKeys)
         RELEASE_LOCK(p_FmPcd->shadowLock);
@@ -5172,56 +5539,64 @@ t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle                   h_FmPcd,
     return err;
 }
 
-t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
-                      t_Handle              h_FmPcdCcNode,
-                      uint16_t              keyIndex,
-                      uint8_t               keySize,
-                      t_FmPcdCcKeyParams    *p_FmPcdCcKeyParams)
+t_Error FmPcdCcAddKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode,
+                      uint16_t keyIndex, uint8_t keySize,
+                      t_FmPcdCcKeyParams *p_FmPcdCcKeyParams)
 {
-    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
-    t_FmPcd                             *p_FmPcd;
-    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
-    t_List                              h_OldPointersLst, h_NewPointersLst;
-    bool                                useShadowStructs = FALSE;
-    uint16_t                            tmpKeyIndex;
-    t_Error                             err = E_OK;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdModifyCcKeyAdditionalParams *p_ModifyKeyParams;
+    t_List h_OldPointersLst, h_NewPointersLst;
+    bool useShadowStructs = FALSE;
+    uint16_t tmpKeyIndex;
+    t_Error err = E_OK;
 
     if (keyIndex > p_CcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("keyIndex > previously cleared last index + 1"));
+        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE,
+                     ("keyIndex > previously cleared last index + 1"));
 
     if (keySize != p_CcNode->userSizeOfExtraction)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be defined as it was defined in initialization step"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("keySize has to be defined as it was defined in initialization step"));
 
     if (p_CcNode->h_FmPcd != h_FmPcd)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("handler to FmPcd is different from the handle provided at node initialization time"));
 
     if (p_CcNode->maxNumOfKeys)
     {
         if (p_CcNode->numOfKeys == p_CcNode->maxNumOfKeys)
-            RETURN_ERROR(MAJOR, E_FULL, ("number of keys exceeds the maximal number of keys provided at node initialization time"));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_FULL,
+                    ("number of keys exceeds the maximal number of keys provided at node initialization time"));
     }
-    else if (p_CcNode->numOfKeys == FM_PCD_MAX_NUM_OF_KEYS)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("number of keys can not be larger than %d", FM_PCD_MAX_NUM_OF_KEYS));
-
-    err = FindKeyIndex(h_FmPcdCcNode,
-                       keySize,
-                       p_FmPcdCcKeyParams->p_Key,
-                       p_FmPcdCcKeyParams->p_Mask,
-                       &tmpKeyIndex);
+    else
+        if (p_CcNode->numOfKeys == FM_PCD_MAX_NUM_OF_KEYS)
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("number of keys can not be larger than %d", FM_PCD_MAX_NUM_OF_KEYS));
+
+    err = FindKeyIndex(h_FmPcdCcNode, keySize, p_FmPcdCcKeyParams->p_Key,
+                       p_FmPcdCcKeyParams->p_Mask, &tmpKeyIndex);
     if (GET_ERROR_TYPE(err) != E_NOT_FOUND)
-        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS,
-                     ("The received key and mask pair was already found in the match table of the provided node"));
+        RETURN_ERROR(
+                MAJOR,
+                E_ALREADY_EXISTS,
+                ("The received key and mask pair was already found in the match table of the provided node"));
 
     p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
 
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode,
-                                             keyIndex,
-                                             e_MODIFY_STATE_ADD,
-                                             TRUE,
-                                             TRUE,
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex,
+                                             e_MODIFY_STATE_ADD, TRUE, TRUE,
                                              FALSE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
@@ -5237,12 +5612,9 @@ t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
         useShadowStructs = TRUE;
     }
 
-    err = BuildNewNodeAddOrMdfyKeyAndNextEngine (h_FmPcd,
-                                                 p_CcNode,
-                                                 keyIndex,
-                                                 p_FmPcdCcKeyParams,
-                                                 p_ModifyKeyParams,
-                                                 TRUE);
+    err = BuildNewNodeAddOrMdfyKeyAndNextEngine(h_FmPcd, p_CcNode, keyIndex,
+                                                p_FmPcdCcKeyParams,
+                                                p_ModifyKeyParams, TRUE);
     if (err)
     {
         ReleaseNewNodeCommonPart(p_ModifyKeyParams);
@@ -5252,8 +5624,7 @@ t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode,
-                                           p_ModifyKeyParams,
+    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode, p_ModifyKeyParams,
                                            &h_OldPointersLst,
                                            &h_NewPointersLst);
     if (err)
@@ -5265,55 +5636,58 @@ t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = DoDynamicChange(p_FmPcd,
-                          &h_OldPointersLst,
-                          &h_NewPointersLst,
-                          p_ModifyKeyParams,
-                          useShadowStructs);
+    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst,
+                          p_ModifyKeyParams, useShadowStructs);
     if (p_CcNode->maxNumOfKeys)
         RELEASE_LOCK(p_FmPcd->shadowLock);
 
     return err;
 }
 
-t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle              h_FmPcd,
-                                      t_Handle              h_FmPcdCcNode,
-                                      uint16_t              keyIndex,
-                                      uint8_t               keySize,
-                                      t_FmPcdCcKeyParams    *p_FmPcdCcKeyParams)
+t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode,
+                                      uint16_t keyIndex, uint8_t keySize,
+                                      t_FmPcdCcKeyParams *p_FmPcdCcKeyParams)
 {
-    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
-    t_FmPcd                             *p_FmPcd;
-    t_List                              h_OldPointersLst, h_NewPointersLst;
-    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
-    uint16_t                            tmpKeyIndex;
-    bool                                useShadowStructs = FALSE;
-    t_Error                             err = E_OK;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd *p_FmPcd;
+    t_List h_OldPointersLst, h_NewPointersLst;
+    t_FmPcdModifyCcKeyAdditionalParams *p_ModifyKeyParams;
+    uint16_t tmpKeyIndex;
+    bool useShadowStructs = FALSE;
+    t_Error err = E_OK;
 
     if (keyIndex > p_CcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previously cleared last index + 1"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                     ("keyIndex > previously cleared last index + 1"));
 
     if (keySize != p_CcNode->userSizeOfExtraction)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be defined as it was defined in initialization step"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("keySize has to be defined as it was defined in initialization step"));
 
     if (p_CcNode->h_FmPcd != h_FmPcd)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("handler to FmPcd is different from the handle provided at node initialization time"));
 
-    err = FindKeyIndex(h_FmPcdCcNode,
-                       keySize,
-                       p_FmPcdCcKeyParams->p_Key,
-                       p_FmPcdCcKeyParams->p_Mask,
-                       &tmpKeyIndex);
+    err = FindKeyIndex(h_FmPcdCcNode, keySize, p_FmPcdCcKeyParams->p_Key,
+                       p_FmPcdCcKeyParams->p_Mask, &tmpKeyIndex);
     if (GET_ERROR_TYPE(err) != E_NOT_FOUND)
-        RETURN_ERROR(MINOR, E_ALREADY_EXISTS,
-                     ("The received key and mask pair was already found in the match table of the provided node"));
+        RETURN_ERROR(
+                MINOR,
+                E_ALREADY_EXISTS,
+                ("The received key and mask pair was already found in the match table of the provided node"));
 
     p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
 
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, TRUE, TRUE, FALSE);
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex,
+                                             e_MODIFY_STATE_CHANGE, TRUE, TRUE,
+                                             FALSE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
@@ -5328,12 +5702,9 @@ t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle              h_FmPcd,
         useShadowStructs = TRUE;
     }
 
-    err = BuildNewNodeAddOrMdfyKeyAndNextEngine (h_FmPcd,
-                                                 p_CcNode,
-                                                 keyIndex,
-                                                 p_FmPcdCcKeyParams,
-                                                 p_ModifyKeyParams,
-                                                 FALSE);
+    err = BuildNewNodeAddOrMdfyKeyAndNextEngine(h_FmPcd, p_CcNode, keyIndex,
+                                                p_FmPcdCcKeyParams,
+                                                p_ModifyKeyParams, FALSE);
     if (err)
     {
         ReleaseNewNodeCommonPart(p_ModifyKeyParams);
@@ -5343,8 +5714,7 @@ t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle              h_FmPcd,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode,
-                                           p_ModifyKeyParams,
+    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode, p_ModifyKeyParams,
                                            &h_OldPointersLst,
                                            &h_NewPointersLst);
     if (err)
@@ -5356,11 +5726,8 @@ t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle              h_FmPcd,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = DoDynamicChange(p_FmPcd,
-                          &h_OldPointersLst,
-                          &h_NewPointersLst,
-                          p_ModifyKeyParams,
-                          useShadowStructs);
+    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst,
+                          p_ModifyKeyParams, useShadowStructs);
 
     if (p_CcNode->maxNumOfKeys)
         RELEASE_LOCK(p_FmPcd->shadowLock);
@@ -5368,26 +5735,31 @@ t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle              h_FmPcd,
     return err;
 }
 
-uint32_t FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd, t_Handle h_Pointer)
+uint32_t FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd,
+                                              t_Handle h_Pointer)
 {
-    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_CcNodeInformation             *p_CcNodeInfo;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_CcNodeInformation *p_CcNodeInfo;
 
-    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE, (uint32_t)ILLEGAL_BASE);
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE,
+                              (uint32_t)ILLEGAL_BASE);
 
     p_CcNodeInfo = CC_NODE_F_OBJECT(h_Pointer);
 
-    return (uint32_t)(XX_VirtToPhys(p_CcNodeInfo->h_CcNode) - p_FmPcd->physicalMuramBase);
+    return (uint32_t)(XX_VirtToPhys(p_CcNodeInfo->h_CcNode)
+            - p_FmPcd->physicalMuramBase);
 }
 
-t_Error FmPcdCcGetGrpParams(t_Handle h_FmPcdCcTree, uint8_t grpId, uint32_t *p_GrpBits, uint8_t *p_GrpBase)
+t_Error FmPcdCcGetGrpParams(t_Handle h_FmPcdCcTree, uint8_t grpId,
+                            uint32_t *p_GrpBits, uint8_t *p_GrpBase)
 {
-    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *) h_FmPcdCcTree;
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree, E_INVALID_HANDLE);
 
     if (grpId >= p_FmPcdCcTree->numOfGrps)
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("grpId you asked > numOfGroup of relevant tree"));
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE,
+                     ("grpId you asked > numOfGroup of relevant tree"));
 
     *p_GrpBits = p_FmPcdCcTree->fmPcdGroupParam[grpId].totalBitsMask;
     *p_GrpBase = p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry;
@@ -5395,15 +5767,13 @@ t_Error FmPcdCcGetGrpParams(t_Handle h_FmPcdCcTree, uint8_t grpId, uint32_t *p_G
     return E_OK;
 }
 
-t_Error  FmPcdCcBindTree(t_Handle h_FmPcd,
-                         t_Handle h_PcdParams,
-                         t_Handle h_FmPcdCcTree,
-                         uint32_t *p_Offset,
-                         t_Handle h_FmPort)
+t_Error FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle h_PcdParams,
+                        t_Handle h_FmPcdCcTree, uint32_t *p_Offset,
+                        t_Handle h_FmPort)
 {
-    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdCcTree       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
-    t_Error             err = E_OK;
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree, E_INVALID_HANDLE);
@@ -5415,40 +5785,39 @@ t_Error  FmPcdCcBindTree(t_Handle h_FmPcd,
     if (err == E_OK)
         UpdateCcRootOwner(p_FmPcdCcTree, TRUE);
 
-    *p_Offset = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr)) -
-                           p_FmPcd->physicalMuramBase);
+    *p_Offset = (uint32_t)(XX_VirtToPhys(
+            UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr))
+            - p_FmPcd->physicalMuramBase);
 
     return err;
 }
 
-t_Error FmPcdCcUnbindTree(t_Handle h_FmPcd, t_Handle  h_FmPcdCcTree)
+t_Error FmPcdCcUnbindTree(t_Handle h_FmPcd, t_Handle h_FmPcdCcTree)
 {
-    t_FmPcdCcTree   *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
 
     /* this routine must be protected by the calling routine by locking all PCD modules! */
 
     UNUSED(h_FmPcd);
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree, E_INVALID_HANDLE);
 
     UpdateCcRootOwner(p_FmPcdCcTree, FALSE);
 
     return E_OK;
 }
 
-t_Error FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *p_List)
+t_Error FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode,
+                               t_List *p_List)
 {
-    t_FmPcdCcNode           *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
-    t_List                  *p_Pos, *p_Tmp;
-    t_CcNodeInformation     *p_CcNodeInfo, nodeInfo;
-    uint32_t                intFlags;
-    t_Error                 err = E_OK;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_List *p_Pos, *p_Tmp;
+    t_CcNodeInformation *p_CcNodeInfo, nodeInfo;
+    uint32_t intFlags;
+    t_Error err = E_OK;
 
     intFlags = FmPcdLock(h_FmPcd);
 
-    if (LIST_IsEmpty(&p_CcNode->ccTreesLst))
-        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("asked for more nodes in CC than MAX"));
-
     LIST_FOR_EACH(p_Pos, &p_CcNode->ccTreesLst)
     {
         p_CcNodeInfo = CC_NODE_F_OBJECT(p_Pos);
@@ -5481,10 +5850,10 @@ t_Error FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *
 
 void FmPcdCcNodeTreeReleaseLock(t_Handle h_FmPcd, t_List *p_List)
 {
-    t_List              *p_Pos;
+    t_List *p_Pos;
     t_CcNodeInformation *p_CcNodeInfo;
-    t_Handle            h_FmPcdCcTree;
-    uint32_t            intFlags;
+    t_Handle h_FmPcdCcTree;
+    uint32_t intFlags;
 
     intFlags = FmPcdLock(h_FmPcd);
 
@@ -5501,12 +5870,11 @@ void FmPcdCcNodeTreeReleaseLock(t_Handle h_FmPcd, t_List *p_List)
     CORE_MemoryBarrier();
 }
 
-
-t_Error FmPcdUpdateCcShadow (t_FmPcd *p_FmPcd, uint32_t size, uint32_t align)
+t_Error FmPcdUpdateCcShadow(t_FmPcd *p_FmPcd, uint32_t size, uint32_t align)
 {
-    uint32_t    intFlags;
-    uint32_t    newSize = 0, newAlign = 0;
-    bool        allocFail = FALSE;
+    uint32_t intFlags;
+    uint32_t newSize = 0, newAlign = 0;
+    bool allocFail = FALSE;
 
     ASSERT_COND(p_FmPcd);
 
@@ -5516,7 +5884,7 @@ t_Error FmPcdUpdateCcShadow (t_FmPcd *p_FmPcd, uint32_t size, uint32_t align)
     if (!POWER_OF_2(align))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("alignment must be power of 2"));
 
-    newSize  = p_FmPcd->ccShadowSize;
+    newSize = p_FmPcd->ccShadowSize;
     newAlign = p_FmPcd->ccShadowAlign;
 
     /* Check if current shadow is large enough to hold the requested size */
@@ -5528,38 +5896,39 @@ t_Error FmPcdUpdateCcShadow (t_FmPcd *p_FmPcd, uint32_t size, uint32_t align)
         newAlign = align;
 
     /* If a bigger shadow size or bigger shadow alignment are required,
-       a new shadow will be allocated */
-    if ((newSize != p_FmPcd->ccShadowSize) || (newAlign != p_FmPcd->ccShadowAlign))
+     a new shadow will be allocated */
+    if ((newSize != p_FmPcd->ccShadowSize)
+            || (newAlign != p_FmPcd->ccShadowAlign))
     {
         intFlags = FmPcdLock(p_FmPcd);
 
         if (p_FmPcd->p_CcShadow)
         {
             FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcd), p_FmPcd->p_CcShadow);
-            p_FmPcd->ccShadowSize  = 0;
+            p_FmPcd->ccShadowSize = 0;
             p_FmPcd->ccShadowAlign = 0;
         }
 
         p_FmPcd->p_CcShadow = FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcd),
-                                                newSize,
-                                                newAlign);
+                                                newSize, newAlign);
         if (!p_FmPcd->p_CcShadow)
         {
             allocFail = TRUE;
 
             /* If new shadow size allocation failed,
-               re-allocate with previous parameters */
-            p_FmPcd->p_CcShadow = FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcd),
-                                                    p_FmPcd->ccShadowSize,
-                                                    p_FmPcd->ccShadowAlign);
+             re-allocate with previous parameters */
+            p_FmPcd->p_CcShadow = FM_MURAM_AllocMem(
+                    FmPcdGetMuramHandle(p_FmPcd), p_FmPcd->ccShadowSize,
+                    p_FmPcd->ccShadowAlign);
         }
 
         FmPcdUnlock(p_FmPcd, intFlags);
 
         if (allocFail)
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC Shadow memory"));
+            RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                         ("MURAM allocation for CC Shadow memory"));
 
-        p_FmPcd->ccShadowSize  = newSize;
+        p_FmPcd->ccShadowSize = newSize;
         p_FmPcd->ccShadowAlign = newAlign;
     }
 
@@ -5567,15 +5936,15 @@ t_Error FmPcdUpdateCcShadow (t_FmPcd *p_FmPcd, uint32_t size, uint32_t align)
 }
 
 #if (DPAA_VERSION >= 11)
-void FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle  h_Node,
-                                              t_Handle  h_ReplicGroup,
-                                              t_List    *p_AdTables,
-                                              uint32_t  *p_NumOfAdTables)
+void FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle h_Node,
+                                              t_Handle h_ReplicGroup,
+                                              t_List *p_AdTables,
+                                              uint32_t *p_NumOfAdTables)
 {
-    t_FmPcdCcNode           *p_CurrentNode = (t_FmPcdCcNode *)h_Node;
-    int                     i = 0;
-    void *                  p_AdTable;
-    t_CcNodeInformation     ccNodeInfo;
+    t_FmPcdCcNode *p_CurrentNode = (t_FmPcdCcNode *)h_Node;
+    int i = 0;
+    void * p_AdTable;
+    t_CcNodeInformation ccNodeInfo;
 
     ASSERT_COND(h_Node);
     *p_NumOfAdTables = 0;
@@ -5583,12 +5952,15 @@ void FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle  h_Node,
     /* search in the current node which exact index points on this current replicator group for getting AD */
     for (i = 0; i < p_CurrentNode->numOfKeys + 1; i++)
     {
-        if ((p_CurrentNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            ((p_CurrentNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic == (t_Handle)h_ReplicGroup)))
+        if ((p_CurrentNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine
+                == e_FM_PCD_FR)
+                && ((p_CurrentNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic
+                        == (t_Handle)h_ReplicGroup)))
         {
             /* save the current ad table in the list */
             /* this entry uses the input replicator group */
-            p_AdTable = PTR_MOVE(p_CurrentNode->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
+            p_AdTable =
+                    PTR_MOVE(p_CurrentNode->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
             memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
             ccNodeInfo.h_CcNode = p_AdTable;
             EnqueueNodeInfoToRelevantLst(p_AdTables, &ccNodeInfo, NULL);
@@ -5601,29 +5973,29 @@ void FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle  h_Node,
 #endif /* (DPAA_VERSION >= 11) */
 /*********************** End of inter-module routines ************************/
 
-
 /****************************************/
 /*       API Init unit functions        */
 /****************************************/
 
-t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsParam)
+t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd,
+                            t_FmPcdCcTreeParams *p_PcdGroupsParam)
 {
-    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_Error                     err = E_OK;
-    int                         i = 0, j = 0, k = 0;
-    t_FmPcdCcTree               *p_FmPcdCcTree;
-    uint8_t                     numOfEntries;
-    t_Handle                    p_CcTreeTmp;
-    t_FmPcdCcGrpParams          *p_FmPcdCcGroupParams;
-    t_FmPcdCcKeyAndNextEngineParams   *p_Params, *p_KeyAndNextEngineParams;
-    t_NetEnvParams              netEnvParams;
-    uint8_t                     lastOne = 0;
-    uint32_t                    requiredAction = 0;
-    t_FmPcdCcNode               *p_FmPcdCcNextNode;
-    t_CcNodeInformation         ccNodeInfo, *p_CcInformation;
-
-    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE, NULL);
-    SANITY_CHECK_RETURN_VALUE(p_PcdGroupsParam,E_INVALID_HANDLE, NULL);
+    t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_Error err = E_OK;
+    int i = 0, j = 0, k = 0;
+    t_FmPcdCcTree *p_FmPcdCcTree;
+    uint8_t numOfEntries;
+    t_Handle p_CcTreeTmp;
+    t_FmPcdCcGrpParams *p_FmPcdCcGroupParams;
+    t_FmPcdCcKeyAndNextEngineParams *p_Params, *p_KeyAndNextEngineParams;
+    t_NetEnvParams netEnvParams;
+    uint8_t lastOne = 0;
+    uint32_t requiredAction = 0;
+    t_FmPcdCcNode *p_FmPcdCcNextNode;
+    t_CcNodeInformation ccNodeInfo, *p_CcInformation;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_PcdGroupsParam, E_INVALID_HANDLE, NULL);
 
     if (p_PcdGroupsParam->numOfGrps > FM_PCD_MAX_NUM_OF_CC_GROUPS)
     {
@@ -5640,17 +6012,22 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     memset(p_FmPcdCcTree, 0, sizeof(t_FmPcdCcTree));
     p_FmPcdCcTree->h_FmPcd = h_FmPcd;
 
-    p_Params = (t_FmPcdCcKeyAndNextEngineParams*)XX_Malloc(FM_PCD_MAX_NUM_OF_CC_GROUPS * sizeof(t_FmPcdCcKeyAndNextEngineParams));
-    memset(p_Params, 0, FM_PCD_MAX_NUM_OF_CC_GROUPS * sizeof(t_FmPcdCcKeyAndNextEngineParams));
+    p_Params = (t_FmPcdCcKeyAndNextEngineParams*)XX_Malloc(
+            FM_PCD_MAX_NUM_OF_CC_GROUPS
+                    * sizeof(t_FmPcdCcKeyAndNextEngineParams));
+    memset(p_Params,
+           0,
+           FM_PCD_MAX_NUM_OF_CC_GROUPS
+                   * sizeof(t_FmPcdCcKeyAndNextEngineParams));
 
     INIT_LIST(&p_FmPcdCcTree->fmPortsLst);
 
 #ifdef FM_CAPWAP_SUPPORT
     if ((p_PcdGroupsParam->numOfGrps == 1) &&
-        (p_PcdGroupsParam->ccGrpParams[0].numOfDistinctionUnits == 0) &&
-        (p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].nextEngine == e_FM_PCD_CC) &&
-        p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].params.ccParams.h_CcNode &&
-        IsCapwapApplSpecific(p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].params.ccParams.h_CcNode))
+            (p_PcdGroupsParam->ccGrpParams[0].numOfDistinctionUnits == 0) &&
+            (p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].nextEngine == e_FM_PCD_CC) &&
+            p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].params.ccParams.h_CcNode &&
+            IsCapwapApplSpecific(p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].params.ccParams.h_CcNode))
     {
         p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].h_Manip = FmPcdManipApplSpecificBuild();
         if (!p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].h_Manip)
@@ -5670,21 +6047,23 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     {
         p_FmPcdCcGroupParams = &p_PcdGroupsParam->ccGrpParams[i];
 
-        if (p_FmPcdCcGroupParams->numOfDistinctionUnits > FM_PCD_MAX_NUM_OF_CC_UNITS)
+        if (p_FmPcdCcGroupParams->numOfDistinctionUnits
+                > FM_PCD_MAX_NUM_OF_CC_UNITS)
         {
-            DeleteTree(p_FmPcdCcTree,p_FmPcd);
+            DeleteTree(p_FmPcdCcTree, p_FmPcd);
             XX_Free(p_Params);
             REPORT_ERROR(MAJOR, E_INVALID_VALUE,
-                         ("numOfDistinctionUnits (group %d) should not exceed %d", i, FM_PCD_MAX_NUM_OF_CC_UNITS));
+                    ("numOfDistinctionUnits (group %d) should not exceed %d", i, FM_PCD_MAX_NUM_OF_CC_UNITS));
             return NULL;
         }
 
         p_FmPcdCcTree->fmPcdGroupParam[i].baseGroupEntry = numOfEntries;
-        p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup =(uint8_t)( 0x01 << p_FmPcdCcGroupParams->numOfDistinctionUnits);
+        p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup = (uint8_t)(0x01
+                << p_FmPcdCcGroupParams->numOfDistinctionUnits);
         numOfEntries += p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup;
         if (numOfEntries > FM_PCD_MAX_NUM_OF_CC_GROUPS)
         {
-            DeleteTree(p_FmPcdCcTree,p_FmPcd);
+            DeleteTree(p_FmPcdCcTree, p_FmPcd);
             XX_Free(p_Params);
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("numOfEntries can not be larger than %d", FM_PCD_MAX_NUM_OF_CC_GROUPS));
             return NULL;
@@ -5694,7 +6073,7 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         {
             if (p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup > lastOne)
             {
-                DeleteTree(p_FmPcdCcTree,p_FmPcd);
+                DeleteTree(p_FmPcdCcTree, p_FmPcd);
                 XX_Free(p_Params);
                 REPORT_ERROR(MAJOR, E_CONFLICT, ("numOfEntries per group must be set in descending order"));
                 return NULL;
@@ -5704,30 +6083,32 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         lastOne = p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup;
 
         netEnvParams.netEnvId = p_FmPcdCcTree->netEnvId;
-        netEnvParams.numOfDistinctionUnits = p_FmPcdCcGroupParams->numOfDistinctionUnits;
+        netEnvParams.numOfDistinctionUnits =
+                p_FmPcdCcGroupParams->numOfDistinctionUnits;
 
-        memcpy(netEnvParams.unitIds,
-               &p_FmPcdCcGroupParams->unitIds,
+        memcpy(netEnvParams.unitIds, &p_FmPcdCcGroupParams->unitIds,
                (sizeof(uint8_t)) * p_FmPcdCcGroupParams->numOfDistinctionUnits);
 
         err = PcdGetUnitsVector(p_FmPcd, &netEnvParams);
         if (err)
         {
-            DeleteTree(p_FmPcdCcTree,p_FmPcd);
+            DeleteTree(p_FmPcdCcTree, p_FmPcd);
             XX_Free(p_Params);
             REPORT_ERROR(MAJOR, err, NO_MSG);
             return NULL;
         }
 
         p_FmPcdCcTree->fmPcdGroupParam[i].totalBitsMask = netEnvParams.vector;
-        for (j = 0; j < p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup; j++)
+        for (j = 0; j < p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup;
+                j++)
         {
-            err = ValidateNextEngineParams(h_FmPcd,
-                                           &p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j],
-                                           e_FM_PCD_CC_STATS_MODE_NONE);
+            err = ValidateNextEngineParams(
+                    h_FmPcd,
+                    &p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j],
+                    e_FM_PCD_CC_STATS_MODE_NONE);
             if (err)
             {
-                DeleteTree(p_FmPcdCcTree,p_FmPcd);
+                DeleteTree(p_FmPcdCcTree, p_FmPcd);
                 XX_Free(p_Params);
                 REPORT_ERROR(MAJOR, err, (NO_MSG));
                 return NULL;
@@ -5735,28 +6116,33 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
 
             if (p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j].h_Manip)
             {
-                err = FmPcdManipCheckParamsForCcNextEngine(&p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j], &requiredAction);
+                err = FmPcdManipCheckParamsForCcNextEngine(
+                        &p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j],
+                        &requiredAction);
                 if (err)
                 {
-                    DeleteTree(p_FmPcdCcTree,p_FmPcd);
+                    DeleteTree(p_FmPcdCcTree, p_FmPcd);
                     XX_Free(p_Params);
                     REPORT_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
                     return NULL;
                 }
             }
-            p_KeyAndNextEngineParams = p_Params+k;
+            p_KeyAndNextEngineParams = p_Params + k;
 
             memcpy(&p_KeyAndNextEngineParams->nextEngineParams,
                    &p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j],
                    sizeof(t_FmPcdCcNextEngineParams));
 
-            if ((p_KeyAndNextEngineParams->nextEngineParams.nextEngine == e_FM_PCD_CC)
-                && p_KeyAndNextEngineParams->nextEngineParams.h_Manip)
+            if ((p_KeyAndNextEngineParams->nextEngineParams.nextEngine
+                    == e_FM_PCD_CC)
+                    && p_KeyAndNextEngineParams->nextEngineParams.h_Manip)
             {
-                err = AllocAndFillAdForContLookupManip(p_KeyAndNextEngineParams->nextEngineParams.params.ccParams.h_CcNode);
+                err =
+                        AllocAndFillAdForContLookupManip(
+                                p_KeyAndNextEngineParams->nextEngineParams.params.ccParams.h_CcNode);
                 if (err)
                 {
-                    DeleteTree(p_FmPcdCcTree,p_FmPcd);
+                    DeleteTree(p_FmPcdCcTree, p_FmPcd);
                     XX_Free(p_Params);
                     REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC Tree"));
                     return NULL;
@@ -5774,29 +6160,28 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     p_FmPcdCcTree->numOfGrps = p_PcdGroupsParam->numOfGrps;
 
     p_FmPcdCcTree->ccTreeBaseAddr =
-        PTR_TO_UINT(FM_MURAM_AllocMem(FmPcdGetMuramHandle(h_FmPcd),
-                                      (uint32_t)( FM_PCD_MAX_NUM_OF_CC_GROUPS * FM_PCD_CC_AD_ENTRY_SIZE),
-                                      FM_PCD_CC_TREE_ADDR_ALIGN));
+            PTR_TO_UINT(FM_MURAM_AllocMem(FmPcdGetMuramHandle(h_FmPcd),
+                            (uint32_t)( FM_PCD_MAX_NUM_OF_CC_GROUPS * FM_PCD_CC_AD_ENTRY_SIZE),
+                            FM_PCD_CC_TREE_ADDR_ALIGN));
     if (!p_FmPcdCcTree->ccTreeBaseAddr)
     {
-        DeleteTree(p_FmPcdCcTree,p_FmPcd);
+        DeleteTree(p_FmPcdCcTree, p_FmPcd);
         XX_Free(p_Params);
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC Tree"));
         return NULL;
     }
-    IOMemSet32(UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr), 0, (uint32_t)(FM_PCD_MAX_NUM_OF_CC_GROUPS * FM_PCD_CC_AD_ENTRY_SIZE));
+    IOMemSet32(
+            UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr), 0,
+            (uint32_t)(FM_PCD_MAX_NUM_OF_CC_GROUPS * FM_PCD_CC_AD_ENTRY_SIZE));
 
     p_CcTreeTmp = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
 
-    j = 0;
     for (i = 0; i < numOfEntries; i++)
     {
         p_KeyAndNextEngineParams = p_Params + i;
 
-        NextStepAd(p_CcTreeTmp,
-                   NULL,
-                   &p_KeyAndNextEngineParams->nextEngineParams,
-                   p_FmPcd);
+        NextStepAd(p_CcTreeTmp, NULL,
+                   &p_KeyAndNextEngineParams->nextEngineParams, p_FmPcd);
 
         p_CcTreeTmp = PTR_MOVE(p_CcTreeTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
@@ -5804,12 +6189,14 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
                p_KeyAndNextEngineParams,
                sizeof(t_FmPcdCcKeyAndNextEngineParams));
 
-        if (p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine== e_FM_PCD_CC)
+        if (p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine
+                == e_FM_PCD_CC)
         {
-            p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
-            p_CcInformation = FindNodeInfoInReleventLst(&p_FmPcdCcNextNode->ccTreeIdLst,
-                                                        (t_Handle)p_FmPcdCcTree,
-                                                        p_FmPcdCcNextNode->h_Spinlock);
+            p_FmPcdCcNextNode =
+                    (t_FmPcdCcNode*)p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
+            p_CcInformation = FindNodeInfoInReleventLst(
+                    &p_FmPcdCcNextNode->ccTreeIdLst, (t_Handle)p_FmPcdCcTree,
+                    p_FmPcdCcNextNode->h_Spinlock);
 
             if (!p_CcInformation)
             {
@@ -5828,24 +6215,23 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     FmPcdIncNetEnvOwners(h_FmPcd, p_FmPcdCcTree->netEnvId);
     p_CcTreeTmp = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
 
-     if (!FmPcdLockTryLockAll(p_FmPcd))
+    if (!FmPcdLockTryLockAll(p_FmPcd))
     {
-         FM_PCD_CcRootDelete(p_FmPcdCcTree);
-         XX_Free(p_Params);
-         DBG(TRACE, ("FmPcdLockTryLockAll failed"));
-         return NULL;
+        FM_PCD_CcRootDelete(p_FmPcdCcTree);
+        XX_Free(p_Params);
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return NULL;
     }
 
     for (i = 0; i < numOfEntries; i++)
     {
         if (p_FmPcdCcTree->keyAndNextEngineParams[i].requiredAction)
         {
-            err = SetRequiredAction(h_FmPcd,
-                                    p_FmPcdCcTree->keyAndNextEngineParams[i].requiredAction,
-                                    &p_FmPcdCcTree->keyAndNextEngineParams[i],
-                                    p_CcTreeTmp,
-                                    1,
-                                    p_FmPcdCcTree);
+            err = SetRequiredAction(
+                    h_FmPcd,
+                    p_FmPcdCcTree->keyAndNextEngineParams[i].requiredAction,
+                    &p_FmPcdCcTree->keyAndNextEngineParams[i], p_CcTreeTmp, 1,
+                    p_FmPcdCcTree);
             if (err)
             {
                 FmPcdLockUnlockAll(p_FmPcd);
@@ -5875,51 +6261,68 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
 
 t_Error FM_PCD_CcRootDelete(t_Handle h_CcTree)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcTree   *p_CcTree = (t_FmPcdCcTree *)h_CcTree;
-    int             i= 0;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcTree *p_CcTree = (t_FmPcdCcTree *)h_CcTree;
+    int i = 0;
 
-    SANITY_CHECK_RETURN_ERROR(p_CcTree,E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_CcTree, E_INVALID_STATE);
     p_FmPcd = (t_FmPcd *)p_CcTree->h_FmPcd;
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
     FmPcdDecNetEnvOwners(p_FmPcd, p_CcTree->netEnvId);
 
     if (p_CcTree->owners)
-        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("the tree with this ID can not be removed because this tree is occupied, first - unbind this tree"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_SELECTION,
+                ("the tree with this ID can not be removed because this tree is occupied, first - unbind this tree"));
 
-    /* Delete reassembly schemes if exist */
+    /* Delete ip-reassembly schemes if exist */
     if (p_CcTree->h_IpReassemblyManip)
     {
         FmPcdManipDeleteIpReassmSchemes(p_CcTree->h_IpReassemblyManip);
         FmPcdManipUpdateOwner(p_CcTree->h_IpReassemblyManip, FALSE);
     }
 
-    for (i = 0; i <p_CcTree->numOfEntries; i++)
+    /* Delete capwap-reassembly schemes if exist */
+    if (p_CcTree->h_CapwapReassemblyManip)
+    {
+        FmPcdManipDeleteCapwapReassmSchemes(p_CcTree->h_CapwapReassemblyManip);
+        FmPcdManipUpdateOwner(p_CcTree->h_CapwapReassemblyManip, FALSE);
+    }
+
+    for (i = 0; i < p_CcTree->numOfEntries; i++)
     {
-        if (p_CcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
-            UpdateNodeOwner(p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode, FALSE);
+        if (p_CcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine
+                == e_FM_PCD_CC)
+            UpdateNodeOwner(
+                    p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode,
+                    FALSE);
 
         if (p_CcTree->keyAndNextEngineParams[i].nextEngineParams.h_Manip)
-            FmPcdManipUpdateOwner(p_CcTree->keyAndNextEngineParams[i].nextEngineParams.h_Manip, FALSE);
+            FmPcdManipUpdateOwner(
+                    p_CcTree->keyAndNextEngineParams[i].nextEngineParams.h_Manip,
+                    FALSE);
 
 #ifdef FM_CAPWAP_SUPPORT
         if ((p_CcTree->numOfGrps == 1) &&
-            (p_CcTree->fmPcdGroupParam[0].numOfEntriesInGroup == 1) &&
-            (p_CcTree->keyAndNextEngineParams[0].nextEngineParams.nextEngine == e_FM_PCD_CC) &&
-            p_CcTree->keyAndNextEngineParams[0].nextEngineParams.params.ccParams.h_CcNode &&
-            IsCapwapApplSpecific(p_CcTree->keyAndNextEngineParams[0].nextEngineParams.params.ccParams.h_CcNode))
+                (p_CcTree->fmPcdGroupParam[0].numOfEntriesInGroup == 1) &&
+                (p_CcTree->keyAndNextEngineParams[0].nextEngineParams.nextEngine == e_FM_PCD_CC) &&
+                p_CcTree->keyAndNextEngineParams[0].nextEngineParams.params.ccParams.h_CcNode &&
+                IsCapwapApplSpecific(p_CcTree->keyAndNextEngineParams[0].nextEngineParams.params.ccParams.h_CcNode))
         {
             if (FM_PCD_ManipNodeDelete(p_CcTree->keyAndNextEngineParams[0].nextEngineParams.h_Manip) != E_OK)
-                return E_INVALID_STATE;
+            return E_INVALID_STATE;
         }
 #endif /* FM_CAPWAP_SUPPORT */
 
 #if (DPAA_VERSION >= 11)
-        if ((p_CcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic))
-            FrmReplicGroupUpdateOwner(p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic,
-                                      FALSE);
+        if ((p_CcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine
+                == e_FM_PCD_FR)
+                && (p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic))
+            FrmReplicGroupUpdateOwner(
+                    p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic,
+                    FALSE);
 #endif /* (DPAA_VERSION >= 11) */
     }
 
@@ -5931,17 +6334,16 @@ t_Error FM_PCD_CcRootDelete(t_Handle h_CcTree)
     return E_OK;
 }
 
-t_Error FM_PCD_CcRootModifyNextEngine(t_Handle                  h_CcTree,
-                                      uint8_t                   grpId,
-                                      uint8_t                   index,
-                                      t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+t_Error FM_PCD_CcRootModifyNextEngine(
+        t_Handle h_CcTree, uint8_t grpId, uint8_t index,
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcTree   *p_CcTree = (t_FmPcdCcTree *)h_CcTree;
-    t_Error         err = E_OK;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcTree *p_CcTree = (t_FmPcdCcTree *)h_CcTree;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_CcTree,E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_CcTree, E_INVALID_STATE);
     p_FmPcd = (t_FmPcd *)p_CcTree->h_FmPcd;
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
@@ -5951,10 +6353,7 @@ t_Error FM_PCD_CcRootModifyNextEngine(t_Handle                  h_CcTree,
         return ERROR_CODE(E_BUSY);
     }
 
-    err = FmPcdCcModifyNextEngineParamTree(p_FmPcd,
-                                           p_CcTree,
-                                           grpId,
-                                           index,
+    err = FmPcdCcModifyNextEngineParamTree(p_FmPcd, p_CcTree, grpId, index,
                                            p_FmPcdCcNextEngineParams);
     FmPcdLockUnlockAll(p_FmPcd);
 
@@ -5966,10 +6365,11 @@ t_Error FM_PCD_CcRootModifyNextEngine(t_Handle                  h_CcTree,
     return E_OK;
 }
 
-t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
+t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd,
+                              t_FmPcdCcNodeParams *p_CcNodeParam)
 {
-    t_FmPcdCcNode   *p_CcNode;
-    t_Error         err;
+    t_FmPcdCcNode *p_CcNode;
+    t_Error err;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, NULL);
     SANITY_CHECK_RETURN_VALUE(p_CcNodeParam, E_NULL_POINTER, NULL);
@@ -5984,18 +6384,18 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
 
     err = MatchTableSet(h_FmPcd, p_CcNode, p_CcNodeParam);
 
-    switch (GET_ERROR_TYPE(err))
-    {
+    switch(GET_ERROR_TYPE(err)
+)    {
         case E_OK:
-            break;
+        break;
 
         case E_BUSY:
-            DBG(TRACE, ("E_BUSY error"));
-            return NULL;
+        DBG(TRACE, ("E_BUSY error"));
+        return NULL;
 
         default:
-            REPORT_ERROR(MAJOR, err, NO_MSG);
-            return NULL;
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        return NULL;
     }
 
     return p_CcNode;
@@ -6003,38 +6403,47 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
 
 t_Error FM_PCD_MatchTableDelete(t_Handle h_CcNode)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    int             i = 0;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    int i = 0;
 
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
-    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-
-    UNUSED(p_FmPcd);
+    SANITY_CHECK_RETURN_ERROR(p_CcNode->h_FmPcd, E_INVALID_HANDLE);
 
     if (p_CcNode->owners)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This node cannot be removed because it is occupied; first unbind this node"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_STATE,
+                ("This node cannot be removed because it is occupied; first unbind this node"));
 
     for (i = 0; i < p_CcNode->numOfKeys; i++)
-        if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
-            UpdateNodeOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode, FALSE);
-
-    if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
-        UpdateNodeOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode, FALSE);
+        if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine
+                == e_FM_PCD_CC)
+            UpdateNodeOwner(
+                    p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode,
+                    FALSE);
+
+    if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine
+            == e_FM_PCD_CC)
+        UpdateNodeOwner(
+                p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode,
+                FALSE);
 
     /* Handle also Miss entry */
     for (i = 0; i < p_CcNode->numOfKeys + 1; i++)
     {
         if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip)
-            FmPcdManipUpdateOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip, FALSE);
+            FmPcdManipUpdateOwner(
+                    p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip,
+                    FALSE);
 
 #if (DPAA_VERSION >= 11)
-        if ((p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic))
+        if ((p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine
+                == e_FM_PCD_FR)
+                && (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic))
         {
-            FrmReplicGroupUpdateOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic,
-                                      FALSE);
+            FrmReplicGroupUpdateOwner(
+                    p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic,
+                    FALSE);
         }
 #endif /* (DPAA_VERSION >= 11) */
     }
@@ -6044,14 +6453,13 @@ t_Error FM_PCD_MatchTableDelete(t_Handle h_CcNode)
     return E_OK;
 }
 
-t_Error FM_PCD_MatchTableAddKey(t_Handle            h_CcNode,
-                                uint16_t            keyIndex,
-                                uint8_t             keySize,
-                                t_FmPcdCcKeyParams  *p_KeyParams)
+t_Error FM_PCD_MatchTableAddKey(t_Handle h_CcNode, uint16_t keyIndex,
+                                uint8_t keySize,
+                                t_FmPcdCcKeyParams *p_KeyParams)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    t_Error         err = E_OK;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_KeyParams, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
@@ -6068,33 +6476,29 @@ t_Error FM_PCD_MatchTableAddKey(t_Handle            h_CcNode,
         return ERROR_CODE(E_BUSY);
     }
 
-    err = FmPcdCcAddKey(p_FmPcd,
-                        p_CcNode,
-                        keyIndex,
-                        keySize,
-                        p_KeyParams);
+    err = FmPcdCcAddKey(p_FmPcd, p_CcNode, keyIndex, keySize, p_KeyParams);
 
     FmPcdLockUnlockAll(p_FmPcd);
 
-    switch (GET_ERROR_TYPE(err))
-    {
+    switch(GET_ERROR_TYPE(err)
+)    {
         case E_OK:
-            return E_OK;
+        return E_OK;
 
         case E_BUSY:
-            DBG(TRACE, ("E_BUSY error"));
-            return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("E_BUSY error"));
+        return ERROR_CODE(E_BUSY);
 
         default:
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 }
 
 t_Error FM_PCD_MatchTableRemoveKey(t_Handle h_CcNode, uint16_t keyIndex)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    t_Error         err = E_OK;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
     p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
@@ -6111,32 +6515,30 @@ t_Error FM_PCD_MatchTableRemoveKey(t_Handle h_CcNode, uint16_t keyIndex)
 
     FmPcdLockUnlockAll(p_FmPcd);
 
-    switch (GET_ERROR_TYPE(err))
-    {
+    switch(GET_ERROR_TYPE(err)
+)    {
         case E_OK:
-            return E_OK;
+        return E_OK;
 
         case E_BUSY:
-            DBG(TRACE, ("E_BUSY error"));
-            return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("E_BUSY error"));
+        return ERROR_CODE(E_BUSY);
 
         default:
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     return E_OK;
 }
 
-t_Error FM_PCD_MatchTableModifyKey(t_Handle h_CcNode,
-                                   uint16_t keyIndex,
-                                   uint8_t  keySize,
-                                   uint8_t  *p_Key,
-                                   uint8_t  *p_Mask)
+t_Error FM_PCD_MatchTableModifyKey(t_Handle h_CcNode, uint16_t keyIndex,
+                                   uint8_t keySize, uint8_t *p_Key,
+                                   uint8_t *p_Mask)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    t_List          h_List;
-    t_Error         err = E_OK;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_List h_List;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
@@ -6153,36 +6555,31 @@ t_Error FM_PCD_MatchTableModifyKey(t_Handle h_CcNode,
         return ERROR_CODE(E_BUSY);
     }
 
-    err = FmPcdCcModifyKey(p_FmPcd,
-                           p_CcNode,
-                           keyIndex,
-                           keySize,
-                           p_Key,
-                           p_Mask);
+    err = FmPcdCcModifyKey(p_FmPcd, p_CcNode, keyIndex, keySize, p_Key, p_Mask);
 
     FmPcdCcNodeTreeReleaseLock(p_FmPcd, &h_List);
 
-    switch (GET_ERROR_TYPE(err))
-    {
+    switch(GET_ERROR_TYPE(err)
+)    {
         case E_OK:
-            return E_OK;
+        return E_OK;
 
         case E_BUSY:
-            DBG(TRACE, ("E_BUSY error"));
-            return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("E_BUSY error"));
+        return ERROR_CODE(E_BUSY);
 
         default:
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 }
 
-t_Error FM_PCD_MatchTableModifyNextEngine(t_Handle h_CcNode,
-                                          uint16_t keyIndex,
-                                          t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+t_Error FM_PCD_MatchTableModifyNextEngine(
+        t_Handle h_CcNode, uint16_t keyIndex,
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    t_Error         err = E_OK;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
@@ -6196,33 +6593,31 @@ t_Error FM_PCD_MatchTableModifyNextEngine(t_Handle h_CcNode,
         return ERROR_CODE(E_BUSY);
     }
 
-    err = ModifyNextEngineParamNode(p_FmPcd,
-                                    p_CcNode,
-                                    keyIndex,
+    err = ModifyNextEngineParamNode(p_FmPcd, p_CcNode, keyIndex,
                                     p_FmPcdCcNextEngineParams);
 
     FmPcdLockUnlockAll(p_FmPcd);
 
-    switch (GET_ERROR_TYPE(err))
-    {
+    switch(GET_ERROR_TYPE(err)
+)    {
         case E_OK:
-            return E_OK;
+        return E_OK;
 
         case E_BUSY:
-            DBG(TRACE, ("E_BUSY error"));
-            return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("E_BUSY error"));
+        return ERROR_CODE(E_BUSY);
 
         default:
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 }
 
-t_Error FM_PCD_MatchTableModifyMissNextEngine(t_Handle                      h_CcNode,
-                                              t_FmPcdCcNextEngineParams     *p_FmPcdCcNextEngineParams)
+t_Error FM_PCD_MatchTableModifyMissNextEngine(
+        t_Handle h_CcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    t_Error         err = E_OK;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
@@ -6236,34 +6631,33 @@ t_Error FM_PCD_MatchTableModifyMissNextEngine(t_Handle                      h_Cc
         return ERROR_CODE(E_BUSY);
     }
 
-    err = FmPcdCcModifyMissNextEngineParamNode(p_FmPcd,
-                                               p_CcNode,
+    err = FmPcdCcModifyMissNextEngineParamNode(p_FmPcd, p_CcNode,
                                                p_FmPcdCcNextEngineParams);
 
     FmPcdLockUnlockAll(p_FmPcd);
 
-    switch (GET_ERROR_TYPE(err))
-    {
+    switch(GET_ERROR_TYPE(err)
+)    {
         case E_OK:
-            return E_OK;
+        return E_OK;
 
         case E_BUSY:
-            DBG(TRACE, ("E_BUSY error"));
-            return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("E_BUSY error"));
+        return ERROR_CODE(E_BUSY);
 
         default:
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 }
 
-t_Error FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle    h_CcNode,
-                                                uint16_t    keyIndex,
-                                                uint8_t     keySize,
-                                                t_FmPcdCcKeyParams  *p_KeyParams)
+t_Error FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle h_CcNode,
+                                                uint16_t keyIndex,
+                                                uint8_t keySize,
+                                                t_FmPcdCcKeyParams *p_KeyParams)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    t_Error         err = E_OK;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_KeyParams, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
@@ -6277,38 +6671,32 @@ t_Error FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle    h_CcNode,
         return ERROR_CODE(E_BUSY);
     }
 
-    err = FmPcdCcModifyKeyAndNextEngine(p_FmPcd,
-                                        p_CcNode,
-                                        keyIndex,
-                                        keySize,
+    err = FmPcdCcModifyKeyAndNextEngine(p_FmPcd, p_CcNode, keyIndex, keySize,
                                         p_KeyParams);
 
     FmPcdLockUnlockAll(p_FmPcd);
 
-    switch (GET_ERROR_TYPE(err))
-    {
+    switch(GET_ERROR_TYPE(err)
+)    {
         case E_OK:
-            return E_OK;
+        return E_OK;
 
         case E_BUSY:
-            DBG(TRACE, ("E_BUSY error"));
-            return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("E_BUSY error"));
+        return ERROR_CODE(E_BUSY);
 
         default:
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 }
 
-
-t_Error FM_PCD_MatchTableFindNRemoveKey(t_Handle h_CcNode,
-                                        uint8_t  keySize,
-                                        uint8_t  *p_Key,
-                                        uint8_t  *p_Mask)
+t_Error FM_PCD_MatchTableFindNRemoveKey(t_Handle h_CcNode, uint8_t keySize,
+                                        uint8_t *p_Key, uint8_t *p_Mask)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    uint16_t        keyIndex;
-    t_Error         err;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint16_t keyIndex;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
@@ -6326,38 +6714,38 @@ t_Error FM_PCD_MatchTableFindNRemoveKey(t_Handle h_CcNode,
     if (GET_ERROR_TYPE(err) != E_OK)
     {
         FmPcdLockUnlockAll(p_FmPcd);
-        RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the match table of the provided node"));
+        RETURN_ERROR(
+                MAJOR,
+                err,
+                ("The received key and mask pair was not found in the match table of the provided node"));
     }
 
     err = FmPcdCcRemoveKey(p_FmPcd, p_CcNode, keyIndex);
 
     FmPcdLockUnlockAll(p_FmPcd);
 
-    switch (GET_ERROR_TYPE(err))
-    {
+    switch(GET_ERROR_TYPE(err)
+)    {
         case E_OK:
-            return E_OK;
+        return E_OK;
 
         case E_BUSY:
-            DBG(TRACE, ("E_BUSY error"));
-            return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("E_BUSY error"));
+        return ERROR_CODE(E_BUSY);
 
         default:
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 }
 
-
-t_Error FM_PCD_MatchTableFindNModifyNextEngine(t_Handle                  h_CcNode,
-                                               uint8_t                   keySize,
-                                               uint8_t                   *p_Key,
-                                               uint8_t                   *p_Mask,
-                                               t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+t_Error FM_PCD_MatchTableFindNModifyNextEngine(
+        t_Handle h_CcNode, uint8_t keySize, uint8_t *p_Key, uint8_t *p_Mask,
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    uint16_t        keyIndex;
-    t_Error         err;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint16_t keyIndex;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
@@ -6376,40 +6764,39 @@ t_Error FM_PCD_MatchTableFindNModifyNextEngine(t_Handle                  h_CcNod
     if (GET_ERROR_TYPE(err) != E_OK)
     {
         FmPcdLockUnlockAll(p_FmPcd);
-        RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the match table of the provided node"));
+        RETURN_ERROR(
+                MAJOR,
+                err,
+                ("The received key and mask pair was not found in the match table of the provided node"));
     }
 
-    err = ModifyNextEngineParamNode(p_FmPcd,
-                                    p_CcNode,
-                                    keyIndex,
+    err = ModifyNextEngineParamNode(p_FmPcd, p_CcNode, keyIndex,
                                     p_FmPcdCcNextEngineParams);
 
     FmPcdLockUnlockAll(p_FmPcd);
 
-    switch (GET_ERROR_TYPE(err))
-    {
+    switch(GET_ERROR_TYPE(err)
+)    {
         case E_OK:
-            return E_OK;
+        return E_OK;
 
         case E_BUSY:
-            DBG(TRACE, ("E_BUSY error"));
-            return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("E_BUSY error"));
+        return ERROR_CODE(E_BUSY);
 
         default:
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 }
 
-t_Error FM_PCD_MatchTableFindNModifyKeyAndNextEngine(t_Handle            h_CcNode,
-                                                     uint8_t             keySize,
-                                                     uint8_t             *p_Key,
-                                                     uint8_t             *p_Mask,
-                                                     t_FmPcdCcKeyParams  *p_KeyParams)
+t_Error FM_PCD_MatchTableFindNModifyKeyAndNextEngine(
+        t_Handle h_CcNode, uint8_t keySize, uint8_t *p_Key, uint8_t *p_Mask,
+        t_FmPcdCcKeyParams *p_KeyParams)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    uint16_t        keyIndex;
-    t_Error         err;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint16_t keyIndex;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_KeyParams, E_NULL_POINTER);
@@ -6428,43 +6815,40 @@ t_Error FM_PCD_MatchTableFindNModifyKeyAndNextEngine(t_Handle            h_CcNod
     if (GET_ERROR_TYPE(err) != E_OK)
     {
         FmPcdLockUnlockAll(p_FmPcd);
-        RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the match table of the provided node"));
+        RETURN_ERROR(
+                MAJOR,
+                err,
+                ("The received key and mask pair was not found in the match table of the provided node"));
     }
 
-    err = FmPcdCcModifyKeyAndNextEngine(p_FmPcd,
-                                        h_CcNode,
-                                        keyIndex,
-                                        keySize,
+    err = FmPcdCcModifyKeyAndNextEngine(p_FmPcd, h_CcNode, keyIndex, keySize,
                                         p_KeyParams);
 
     FmPcdLockUnlockAll(p_FmPcd);
 
-    switch (GET_ERROR_TYPE(err))
-    {
+    switch(GET_ERROR_TYPE(err)
+)    {
         case E_OK:
-            return E_OK;
+        return E_OK;
 
         case E_BUSY:
-            DBG(TRACE, ("E_BUSY error"));
-            return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("E_BUSY error"));
+        return ERROR_CODE(E_BUSY);
 
         default:
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 }
 
-t_Error FM_PCD_MatchTableFindNModifyKey(t_Handle h_CcNode,
-                                        uint8_t  keySize,
-                                        uint8_t  *p_Key,
-                                        uint8_t  *p_Mask,
-                                        uint8_t  *p_NewKey,
-                                        uint8_t  *p_NewMask)
+t_Error FM_PCD_MatchTableFindNModifyKey(t_Handle h_CcNode, uint8_t keySize,
+                                        uint8_t *p_Key, uint8_t *p_Mask,
+                                        uint8_t *p_NewKey, uint8_t *p_NewMask)
 {
-    t_FmPcd         *p_FmPcd;
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    t_List          h_List;
-    uint16_t        keyIndex;
-    t_Error         err;
+    t_FmPcd *p_FmPcd;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_List h_List;
+    uint16_t keyIndex;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_NewKey, E_NULL_POINTER);
@@ -6486,47 +6870,48 @@ t_Error FM_PCD_MatchTableFindNModifyKey(t_Handle h_CcNode,
     if (GET_ERROR_TYPE(err) != E_OK)
     {
         FmPcdCcNodeTreeReleaseLock(p_FmPcd, &h_List);
-        RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the "
-                                  "match table of the provided node"));
+        RETURN_ERROR(MAJOR, err,
+                     ("The received key and mask pair was not found in the "
+                     "match table of the provided node"));
     }
 
-    err = FmPcdCcModifyKey(p_FmPcd,
-                           p_CcNode,
-                           keyIndex,
-                           keySize,
-                           p_NewKey,
+    err = FmPcdCcModifyKey(p_FmPcd, p_CcNode, keyIndex, keySize, p_NewKey,
                            p_NewMask);
 
     FmPcdCcNodeTreeReleaseLock(p_FmPcd, &h_List);
 
-    switch (GET_ERROR_TYPE(err))
-    {
+    switch(GET_ERROR_TYPE(err)
+)    {
         case E_OK:
-            return E_OK;
+        return E_OK;
 
         case E_BUSY:
-            DBG(TRACE, ("E_BUSY error"));
-            return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("E_BUSY error"));
+        return ERROR_CODE(E_BUSY);
 
         default:
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 }
 
-t_Error FM_PCD_MatchTableGetNextEngine(t_Handle                     h_CcNode,
-                                       uint16_t                     keyIndex,
-                                       t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams)
+t_Error FM_PCD_MatchTableGetNextEngine(
+        t_Handle h_CcNode, uint16_t keyIndex,
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
 
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
 
     if (keyIndex >= p_CcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex exceeds current number of keys"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                     ("keyIndex exceeds current number of keys"));
 
     if (keyIndex > (FM_PCD_MAX_NUM_OF_KEYS - 1))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keyIndex can not be larger than %d", (FM_PCD_MAX_NUM_OF_KEYS - 1)));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("keyIndex can not be larger than %d", (FM_PCD_MAX_NUM_OF_KEYS - 1)));
 
     memcpy(p_FmPcdCcNextEngineParams,
            &p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams,
@@ -6538,9 +6923,9 @@ t_Error FM_PCD_MatchTableGetNextEngine(t_Handle                     h_CcNode,
 
 uint32_t FM_PCD_MatchTableGetKeyCounter(t_Handle h_CcNode, uint16_t keyIndex)
 {
-    t_FmPcdCcNode       *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    uint32_t            *p_StatsCounters, frameCount;
-    uint32_t            intFlags;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint32_t *p_StatsCounters, frameCount;
+    uint32_t intFlags;
 
     SANITY_CHECK_RETURN_VALUE(p_CcNode, E_INVALID_HANDLE, 0);
 
@@ -6550,8 +6935,9 @@ uint32_t FM_PCD_MatchTableGetKeyCounter(t_Handle h_CcNode, uint16_t keyIndex)
         return 0;
     }
 
-    if ((p_CcNode->statisticsMode != e_FM_PCD_CC_STATS_MODE_FRAME) &&
-        (p_CcNode->statisticsMode != e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME))
+    if ((p_CcNode->statisticsMode != e_FM_PCD_CC_STATS_MODE_FRAME)
+            && (p_CcNode->statisticsMode
+                    != e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME))
     {
         REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Frame count is not supported in the statistics mode of this match table"));
         return 0;
@@ -6573,25 +6959,26 @@ uint32_t FM_PCD_MatchTableGetKeyCounter(t_Handle h_CcNode, uint16_t keyIndex)
         return 0;
     }
 
-    p_StatsCounters = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsCounters;
+    p_StatsCounters =
+            p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj->h_StatsCounters;
     ASSERT_COND(p_StatsCounters);
 
     /* The first counter is byte counter, so we need to advance to the next counter */
     frameCount = GET_UINT32(*(uint32_t *)(PTR_MOVE(p_StatsCounters,
-                                                   FM_PCD_CC_STATS_COUNTER_SIZE)));
+                            FM_PCD_CC_STATS_COUNTER_SIZE)));
 
     XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
 
     return frameCount;
 }
 
-t_Error FM_PCD_MatchTableGetKeyStatistics(t_Handle                  h_CcNode,
-                                          uint16_t                  keyIndex,
-                                          t_FmPcdCcKeyStatistics    *p_KeyStatistics)
+t_Error FM_PCD_MatchTableGetKeyStatistics(
+        t_Handle h_CcNode, uint16_t keyIndex,
+        t_FmPcdCcKeyStatistics *p_KeyStatistics)
 {
-    t_FmPcdCcNode       *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    uint32_t            intFlags;
-    t_Error             err;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint32_t intFlags;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(h_CcNode, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_KeyStatistics, E_NULL_POINTER);
@@ -6599,11 +6986,12 @@ t_Error FM_PCD_MatchTableGetKeyStatistics(t_Handle                  h_CcNode,
     intFlags = XX_LockIntrSpinlock(p_CcNode->h_Spinlock);
 
     if (keyIndex >= p_CcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("The provided keyIndex exceeds the number of keys in this match table"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_STATE,
+                ("The provided keyIndex exceeds the number of keys in this match table"));
 
-    err = MatchTableGetKeyStatistics(p_CcNode,
-                                     keyIndex,
-                                     p_KeyStatistics);
+    err = MatchTableGetKeyStatistics(p_CcNode, keyIndex, p_KeyStatistics);
 
     XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
 
@@ -6613,20 +7001,19 @@ t_Error FM_PCD_MatchTableGetKeyStatistics(t_Handle                  h_CcNode,
     return E_OK;
 }
 
-t_Error FM_PCD_MatchTableGetMissStatistics(t_Handle                  h_CcNode,
-                                           t_FmPcdCcKeyStatistics    *p_MissStatistics)
+t_Error FM_PCD_MatchTableGetMissStatistics(
+        t_Handle h_CcNode, t_FmPcdCcKeyStatistics *p_MissStatistics)
 {
-    t_FmPcdCcNode       *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    uint32_t            intFlags;
-    t_Error             err;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint32_t intFlags;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(h_CcNode, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_MissStatistics, E_NULL_POINTER);
 
     intFlags = XX_LockIntrSpinlock(p_CcNode->h_Spinlock);
 
-    err = MatchTableGetKeyStatistics(p_CcNode,
-                                     p_CcNode->numOfKeys,
+    err = MatchTableGetKeyStatistics(p_CcNode, p_CcNode->numOfKeys,
                                      p_MissStatistics);
 
     XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
@@ -6637,16 +7024,14 @@ t_Error FM_PCD_MatchTableGetMissStatistics(t_Handle                  h_CcNode,
     return E_OK;
 }
 
-t_Error FM_PCD_MatchTableFindNGetKeyStatistics(t_Handle                 h_CcNode,
-                                               uint8_t                  keySize,
-                                               uint8_t                  *p_Key,
-                                               uint8_t                  *p_Mask,
-                                               t_FmPcdCcKeyStatistics   *p_KeyStatistics)
+t_Error FM_PCD_MatchTableFindNGetKeyStatistics(
+        t_Handle h_CcNode, uint8_t keySize, uint8_t *p_Key, uint8_t *p_Mask,
+        t_FmPcdCcKeyStatistics *p_KeyStatistics)
 {
-    t_FmPcdCcNode       *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    uint16_t            keyIndex;
-    uint32_t            intFlags;
-    t_Error             err;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint16_t keyIndex;
+    uint32_t intFlags;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_KeyStatistics, E_NULL_POINTER);
@@ -6657,15 +7042,14 @@ t_Error FM_PCD_MatchTableFindNGetKeyStatistics(t_Handle                 h_CcNode
     if (GET_ERROR_TYPE(err) != E_OK)
     {
         XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
-        RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the "
-                                  "match table of the provided node"));
+        RETURN_ERROR(MAJOR, err,
+                     ("The received key and mask pair was not found in the "
+                     "match table of the provided node"));
     }
 
     ASSERT_COND(keyIndex < p_CcNode->numOfKeys);
 
-    err = MatchTableGetKeyStatistics(p_CcNode,
-                                     keyIndex,
-                                     p_KeyStatistics);
+    err = MatchTableGetKeyStatistics(p_CcNode, keyIndex, p_KeyStatistics);
 
     XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
 
@@ -6675,20 +7059,21 @@ t_Error FM_PCD_MatchTableFindNGetKeyStatistics(t_Handle                 h_CcNode
     return E_OK;
 }
 
-t_Error FM_PCD_MatchTableGetIndexedHashBucket(t_Handle    h_CcNode,
-                                              uint8_t     keySize,
-                                              uint8_t     *p_Key,
-                                              uint8_t     hashShift,
-                                              t_Handle    *p_CcNodeBucketHandle,
-                                              uint8_t     *p_BucketIndex,
-                                              uint16_t    *p_LastIndex)
+t_Error FM_PCD_MatchTableGetIndexedHashBucket(t_Handle h_CcNode,
+                                              uint8_t keySize, uint8_t *p_Key,
+                                              uint8_t hashShift,
+                                              t_Handle *p_CcNodeBucketHandle,
+                                              uint8_t *p_BucketIndex,
+                                              uint16_t *p_LastIndex)
 {
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    uint16_t        glblMask;
-    uint64_t        crc64 = 0;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint16_t glblMask;
+    uint64_t crc64 = 0;
 
     SANITY_CHECK_RETURN_ERROR(h_CcNode, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(
+            p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED,
+            E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_CcNodeBucketHandle, E_NULL_POINTER);
 
@@ -6698,11 +7083,13 @@ t_Error FM_PCD_MatchTableGetIndexedHashBucket(t_Handle    h_CcNode,
     crc64 = crc64_compute(p_Key, keySize, crc64);
     crc64 >>= hashShift;
 
-    *p_BucketIndex = (uint8_t)(((crc64 >> (8 * (6 - p_CcNode->userOffset))) & glblMask) >> 4);
+    *p_BucketIndex = (uint8_t)(((crc64 >> (8 * (6 - p_CcNode->userOffset)))
+            & glblMask) >> 4);
     if (*p_BucketIndex >= p_CcNode->numOfKeys)
         RETURN_ERROR(MINOR, E_NOT_IN_RANGE, ("bucket index!"));
 
-    *p_CcNodeBucketHandle = p_CcNode->keyAndNextEngineParams[*p_BucketIndex].nextEngineParams.params.ccParams.h_CcNode;
+    *p_CcNodeBucketHandle =
+            p_CcNode->keyAndNextEngineParams[*p_BucketIndex].nextEngineParams.params.ccParams.h_CcNode;
     if (!*p_CcNodeBucketHandle)
         RETURN_ERROR(MINOR, E_NOT_FOUND, ("bucket!"));
 
@@ -6713,15 +7100,15 @@ t_Error FM_PCD_MatchTableGetIndexedHashBucket(t_Handle    h_CcNode,
 
 t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
 {
-    t_FmPcdCcNode           *p_CcNodeHashTbl;
-    t_FmPcdCcNodeParams     *p_IndxHashCcNodeParam, *p_ExactMatchCcNodeParam;
-    t_FmPcdCcNode           *p_CcNode;
-    t_Handle                h_MissStatsCounters = NULL;
-    t_FmPcdCcKeyParams      *p_HashKeyParams;
-    int                     i;
-    uint16_t                numOfSets, numOfWays, countMask, onesCount = 0;
-    bool                    statsEnForMiss = FALSE;
-    t_Error                 err;
+    t_FmPcdCcNode *p_CcNodeHashTbl;
+    t_FmPcdCcNodeParams *p_IndxHashCcNodeParam, *p_ExactMatchCcNodeParam;
+    t_FmPcdCcNode *p_CcNode;
+    t_Handle h_MissStatsCounters = NULL;
+    t_FmPcdCcKeyParams *p_HashKeyParams;
+    int i;
+    uint16_t numOfSets, numOfWays, countMask, onesCount = 0;
+    bool statsEnForMiss = FALSE;
+    t_Error err;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, NULL);
     SANITY_CHECK_RETURN_VALUE(p_Param, E_NULL_POINTER, NULL);
@@ -6742,12 +7129,13 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
     if (p_Param->statisticsMode == e_FM_PCD_CC_STATS_MODE_RMON)
     {
         REPORT_ERROR(MAJOR, E_INVALID_VALUE,
-                     ("RMON statistics mode is not supported for hash table"));
+                ("RMON statistics mode is not supported for hash table"));
         return NULL;
     }
 #endif /* (DPAA_VERSION >= 11) */
 
-    p_ExactMatchCcNodeParam = (t_FmPcdCcNodeParams*)XX_Malloc(sizeof(t_FmPcdCcNodeParams));
+    p_ExactMatchCcNodeParam = (t_FmPcdCcNodeParams*)XX_Malloc(
+            sizeof(t_FmPcdCcNodeParams));
     if (!p_ExactMatchCcNodeParam)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_ExactMatchCcNodeParam"));
@@ -6755,7 +7143,8 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
     }
     memset(p_ExactMatchCcNodeParam, 0, sizeof(t_FmPcdCcNodeParams));
 
-    p_IndxHashCcNodeParam = (t_FmPcdCcNodeParams*)XX_Malloc(sizeof(t_FmPcdCcNodeParams));
+    p_IndxHashCcNodeParam = (t_FmPcdCcNodeParams*)XX_Malloc(
+            sizeof(t_FmPcdCcNodeParams));
     if (!p_IndxHashCcNodeParam)
     {
         XX_Free(p_ExactMatchCcNodeParam);
@@ -6778,24 +7167,26 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
     if (p_Param->maxNumOfKeys % numOfSets)
         DBG(INFO, ("'maxNumOfKeys' is not a multiple of hash number of ways, so number of ways will be rounded up"));
 
-    if ((p_Param->statisticsMode == e_FM_PCD_CC_STATS_MODE_FRAME) ||
-        (p_Param->statisticsMode == e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME))
+    if ((p_Param->statisticsMode == e_FM_PCD_CC_STATS_MODE_FRAME)
+            || (p_Param->statisticsMode == e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME))
     {
         /* Allocating a statistics counters table that will be used by all
-           'miss' entries of the hash table */
-        h_MissStatsCounters = (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(h_FmPcd),
-                                                          2 * FM_PCD_CC_STATS_COUNTER_SIZE,
-                                                          FM_PCD_CC_AD_TABLE_ALIGN);
+         'miss' entries of the hash table */
+        h_MissStatsCounters = (t_Handle)FM_MURAM_AllocMem(
+                FmPcdGetMuramHandle(h_FmPcd), 2 * FM_PCD_CC_STATS_COUNTER_SIZE,
+                FM_PCD_CC_AD_TABLE_ALIGN);
         if (!h_MissStatsCounters)
         {
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for statistics table for hash miss"));
+            XX_Free(p_IndxHashCcNodeParam);
+            XX_Free(p_ExactMatchCcNodeParam);
             return NULL;
         }
         memset(h_MissStatsCounters, 0, (2 * FM_PCD_CC_STATS_COUNTER_SIZE));
 
         /* Always enable statistics for 'miss', so that a statistics AD will be
-           initialized from the start. We'll store the requested 'statistics enable'
-           value and it will be used when statistics are read by the user. */
+         initialized from the start. We'll store the requested 'statistics enable'
+         value and it will be used when statistics are read by the user. */
         statsEnForMiss = p_Param->ccNextEngineParamsForMiss.statisticsEn;
         p_Param->ccNextEngineParamsForMiss.statisticsEn = TRUE;
     }
@@ -6803,24 +7194,29 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
     /* Building exact-match node params, will be used to create the hash buckets */
     p_ExactMatchCcNodeParam->extractCcParams.type = e_FM_PCD_EXTRACT_NON_HDR;
 
-    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.src     = e_FM_PCD_EXTRACT_FROM_KEY;
-    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.action  = e_FM_PCD_ACTION_EXACT_MATCH;
-    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.offset  = 0;
-    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.size    = p_Param->matchKeySize;
-
-    p_ExactMatchCcNodeParam->keysParams.maxNumOfKeys               = numOfWays;
-    p_ExactMatchCcNodeParam->keysParams.maskSupport                = FALSE;
-    p_ExactMatchCcNodeParam->keysParams.statisticsMode             = p_Param->statisticsMode;
-    p_ExactMatchCcNodeParam->keysParams.numOfKeys                  = 0;
-    p_ExactMatchCcNodeParam->keysParams.keySize                    = p_Param->matchKeySize;
-    p_ExactMatchCcNodeParam->keysParams.ccNextEngineParamsForMiss  = p_Param->ccNextEngineParamsForMiss;
+    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.src =
+            e_FM_PCD_EXTRACT_FROM_KEY;
+    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.action =
+            e_FM_PCD_ACTION_EXACT_MATCH;
+    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.offset = 0;
+    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.size =
+            p_Param->matchKeySize;
+
+    p_ExactMatchCcNodeParam->keysParams.maxNumOfKeys = numOfWays;
+    p_ExactMatchCcNodeParam->keysParams.maskSupport = FALSE;
+    p_ExactMatchCcNodeParam->keysParams.statisticsMode =
+            p_Param->statisticsMode;
+    p_ExactMatchCcNodeParam->keysParams.numOfKeys = 0;
+    p_ExactMatchCcNodeParam->keysParams.keySize = p_Param->matchKeySize;
+    p_ExactMatchCcNodeParam->keysParams.ccNextEngineParamsForMiss =
+            p_Param->ccNextEngineParamsForMiss;
 
     p_HashKeyParams = p_IndxHashCcNodeParam->keysParams.keyParams;
 
     for (i = 0; i < numOfSets; i++)
     {
         /* Each exact-match node will be marked as a 'bucket' and provided with a pointer to statistics counters,
-           to be used for 'miss' entry statistics */
+         to be used for 'miss' entry statistics */
         p_CcNode = (t_FmPcdCcNode *)XX_Malloc(sizeof(t_FmPcdCcNode));
         if (!p_CcNode)
             break;
@@ -6833,15 +7229,17 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
         if (err)
             break;
 
-        p_HashKeyParams[i].ccNextEngineParams.nextEngine               = e_FM_PCD_CC;
-        p_HashKeyParams[i].ccNextEngineParams.statisticsEn             = FALSE;
-        p_HashKeyParams[i].ccNextEngineParams.params.ccParams.h_CcNode = p_CcNode;
+        p_HashKeyParams[i].ccNextEngineParams.nextEngine = e_FM_PCD_CC;
+        p_HashKeyParams[i].ccNextEngineParams.statisticsEn = FALSE;
+        p_HashKeyParams[i].ccNextEngineParams.params.ccParams.h_CcNode =
+                p_CcNode;
     }
 
     if (i < numOfSets)
     {
-        for (i = i-1; i >=0; i--)
-            FM_PCD_MatchTableDelete(p_HashKeyParams[i].ccNextEngineParams.params.ccParams.h_CcNode);
+        for (i = i - 1; i >= 0; i--)
+            FM_PCD_MatchTableDelete(
+                    p_HashKeyParams[i].ccNextEngineParams.params.ccParams.h_CcNode);
 
         FM_MURAM_FreeMem(FmPcdGetMuramHandle(h_FmPcd), h_MissStatsCounters);
 
@@ -6852,18 +7250,24 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
     }
 
     /* Creating indexed-hash CC node */
-    p_IndxHashCcNodeParam->extractCcParams.type                     = e_FM_PCD_EXTRACT_NON_HDR;
-    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.src        = e_FM_PCD_EXTRACT_FROM_HASH;
-    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.action     = e_FM_PCD_ACTION_INDEXED_LOOKUP;
-    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.icIndxMask = p_Param->hashResMask;
-    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.offset     = p_Param->hashShift;
-    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.size       = 2;
-
-    p_IndxHashCcNodeParam->keysParams.maxNumOfKeys   = numOfSets;
-    p_IndxHashCcNodeParam->keysParams.maskSupport    = FALSE;
-    p_IndxHashCcNodeParam->keysParams.statisticsMode = e_FM_PCD_CC_STATS_MODE_NONE;
-    p_IndxHashCcNodeParam->keysParams.numOfKeys      = numOfSets;      /* Number of keys of this node is number of sets of the hash */
-    p_IndxHashCcNodeParam->keysParams.keySize        = 2;
+    p_IndxHashCcNodeParam->extractCcParams.type = e_FM_PCD_EXTRACT_NON_HDR;
+    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.src =
+            e_FM_PCD_EXTRACT_FROM_HASH;
+    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.action =
+            e_FM_PCD_ACTION_INDEXED_LOOKUP;
+    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.icIndxMask =
+            p_Param->hashResMask;
+    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.offset =
+            p_Param->hashShift;
+    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.size = 2;
+
+    p_IndxHashCcNodeParam->keysParams.maxNumOfKeys = numOfSets;
+    p_IndxHashCcNodeParam->keysParams.maskSupport = FALSE;
+    p_IndxHashCcNodeParam->keysParams.statisticsMode =
+            e_FM_PCD_CC_STATS_MODE_NONE;
+    /* Number of keys of this node is number of sets of the hash */
+    p_IndxHashCcNodeParam->keysParams.numOfKeys = numOfSets;
+    p_IndxHashCcNodeParam->keysParams.keySize = 2;
 
     p_CcNodeHashTbl = FM_PCD_MatchTableSet(h_FmPcd, p_IndxHashCcNodeParam);
 
@@ -6872,7 +7276,7 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
         p_CcNodeHashTbl->kgHashShift = p_Param->kgHashShift;
 
         /* Storing the allocated counters for buckets 'miss' in the hash table
-        and is statistics for miss wre enabled. */
+         and if statistics for miss were enabled. */
         p_CcNodeHashTbl->h_MissStatsCounters = h_MissStatsCounters;
         p_CcNodeHashTbl->statsEnForMiss = statsEnForMiss;
     }
@@ -6885,11 +7289,11 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
 
 t_Error FM_PCD_HashTableDelete(t_Handle h_HashTbl)
 {
-    t_FmPcdCcNode   *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
-    t_Handle        h_FmPcd;
-    t_Handle        *p_HashBuckets, h_MissStatsCounters;
-    uint16_t        i, numOfBuckets;
-    t_Error         err;
+    t_FmPcdCcNode *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
+    t_Handle h_FmPcd;
+    t_Handle *p_HashBuckets, h_MissStatsCounters;
+    uint16_t i, numOfBuckets;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_HashTbl, E_INVALID_HANDLE);
 
@@ -6901,7 +7305,8 @@ t_Error FM_PCD_HashTableDelete(t_Handle h_HashTbl)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
 
     for (i = 0; i < numOfBuckets; i++)
-        p_HashBuckets[i] = p_HashTbl->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
+        p_HashBuckets[i] =
+                p_HashTbl->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
 
     h_FmPcd = p_HashTbl->h_FmPcd;
     h_MissStatsCounters = p_HashTbl->h_MissStatsCounters;
@@ -6913,135 +7318,124 @@ t_Error FM_PCD_HashTableDelete(t_Handle h_HashTbl)
     for (i = 0; i < numOfBuckets; i++)
         err |= FM_PCD_MatchTableDelete(p_HashBuckets[i]);
 
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    XX_Free(p_HashBuckets);
 
-    /* Free statistics counters for 'miss', id these were allocated */
+    /* Free statistics counters for 'miss', if these were allocated */
     if (h_MissStatsCounters)
         FM_MURAM_FreeMem(FmPcdGetMuramHandle(h_FmPcd), h_MissStatsCounters);
 
-    XX_Free(p_HashBuckets);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
     return E_OK;
 }
 
-t_Error FM_PCD_HashTableAddKey(t_Handle            h_HashTbl,
-                               uint8_t             keySize,
-                               t_FmPcdCcKeyParams  *p_KeyParams)
+t_Error FM_PCD_HashTableAddKey(t_Handle h_HashTbl, uint8_t keySize,
+                               t_FmPcdCcKeyParams *p_KeyParams)
 {
-    t_FmPcdCcNode   *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
-    t_Handle        h_HashBucket;
-    uint8_t         bucketIndex;
-    uint16_t        lastIndex;
-    t_Error         err;
+    t_FmPcdCcNode *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
+    t_Handle h_HashBucket;
+    uint8_t bucketIndex;
+    uint16_t lastIndex;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_HashTbl, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_KeyParams, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_KeyParams->p_Key, E_NULL_POINTER);
 
     if (p_KeyParams->p_Mask)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Keys masks not supported for hash table"));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("Keys masks not supported for hash table"));
 
-    err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl,
-                                                keySize,
+    err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl, keySize,
                                                 p_KeyParams->p_Key,
                                                 p_HashTbl->kgHashShift,
-                                                &h_HashBucket,
-                                                &bucketIndex,
+                                                &h_HashBucket, &bucketIndex,
                                                 &lastIndex);
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    return FM_PCD_MatchTableAddKey(h_HashBucket,
-                                   FM_PCD_LAST_KEY_INDEX,
-                                   keySize,
+    return FM_PCD_MatchTableAddKey(h_HashBucket, FM_PCD_LAST_KEY_INDEX, keySize,
                                    p_KeyParams);
 }
 
-t_Error FM_PCD_HashTableRemoveKey(t_Handle h_HashTbl,
-                                  uint8_t  keySize,
-                                  uint8_t  *p_Key)
+t_Error FM_PCD_HashTableRemoveKey(t_Handle h_HashTbl, uint8_t keySize,
+                                  uint8_t *p_Key)
 {
-    t_FmPcdCcNode   *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
-    t_Handle        h_HashBucket;
-    uint8_t         bucketIndex;
-    uint16_t        lastIndex;
-    t_Error         err;
+    t_FmPcdCcNode *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
+    t_Handle h_HashBucket;
+    uint8_t bucketIndex;
+    uint16_t lastIndex;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_HashTbl, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
 
-    err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl,
-                                                keySize,
-                                                p_Key,
+    err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl, keySize, p_Key,
                                                 p_HashTbl->kgHashShift,
-                                                &h_HashBucket,
-                                                &bucketIndex,
+                                                &h_HashBucket, &bucketIndex,
                                                 &lastIndex);
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    return FM_PCD_MatchTableFindNRemoveKey(h_HashBucket,
-                                           keySize,
-                                           p_Key,
-                                           NULL);
+    return FM_PCD_MatchTableFindNRemoveKey(h_HashBucket, keySize, p_Key, NULL);
 }
 
-t_Error FM_PCD_HashTableModifyNextEngine(t_Handle                  h_HashTbl,
-                                         uint8_t                   keySize,
-                                         uint8_t                   *p_Key,
-                                         t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+t_Error FM_PCD_HashTableModifyNextEngine(
+        t_Handle h_HashTbl, uint8_t keySize, uint8_t *p_Key,
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcdCcNode   *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
-    t_Handle        h_HashBucket;
-    uint8_t         bucketIndex;
-    uint16_t        lastIndex;
-    t_Error         err;
+    t_FmPcdCcNode *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
+    t_Handle h_HashBucket;
+    uint8_t bucketIndex;
+    uint16_t lastIndex;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_HashTbl, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
 
-    err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl,
-                                                keySize,
-                                                p_Key,
+    err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl, keySize, p_Key,
                                                 p_HashTbl->kgHashShift,
-                                                &h_HashBucket,
-                                                &bucketIndex,
+                                                &h_HashBucket, &bucketIndex,
                                                 &lastIndex);
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    return FM_PCD_MatchTableFindNModifyNextEngine(h_HashBucket,
-                                                  keySize,
-                                                  p_Key,
+    return FM_PCD_MatchTableFindNModifyNextEngine(h_HashBucket, keySize, p_Key,
                                                   NULL,
                                                   p_FmPcdCcNextEngineParams);
 }
 
-t_Error FM_PCD_HashTableModifyMissNextEngine(t_Handle                  h_HashTbl,
-                                             t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+t_Error FM_PCD_HashTableModifyMissNextEngine(
+        t_Handle h_HashTbl,
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcdCcNode   *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
-    t_Handle        h_HashBucket;
-    uint8_t         i;
-    bool            nullifyMissStats = FALSE;
-    t_Error         err;
+    t_FmPcdCcNode *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
+    t_Handle h_HashBucket;
+    uint8_t i;
+    bool nullifyMissStats = FALSE;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(h_HashTbl, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
 
-    if ((!p_HashTbl->h_MissStatsCounters) && (p_FmPcdCcNextEngineParams->statisticsEn))
-        RETURN_ERROR(MAJOR, E_CONFLICT,
-                             ("Statistics are requested for a key, but statistics mode was set"
-                              "to 'NONE' upon initialization"));
+    if ((!p_HashTbl->h_MissStatsCounters)
+            && (p_FmPcdCcNextEngineParams->statisticsEn))
+        RETURN_ERROR(
+                MAJOR,
+                E_CONFLICT,
+                ("Statistics are requested for a key, but statistics mode was set"
+                "to 'NONE' upon initialization"));
 
     if (p_HashTbl->h_MissStatsCounters)
     {
-        if ((!p_HashTbl->statsEnForMiss) && (p_FmPcdCcNextEngineParams->statisticsEn))
+        if ((!p_HashTbl->statsEnForMiss)
+                && (p_FmPcdCcNextEngineParams->statisticsEn))
             nullifyMissStats = TRUE;
 
-        if ((p_HashTbl->statsEnForMiss) && (!p_FmPcdCcNextEngineParams->statisticsEn))
+        if ((p_HashTbl->statsEnForMiss)
+                && (!p_FmPcdCcNextEngineParams->statisticsEn))
         {
             p_HashTbl->statsEnForMiss = FALSE;
             p_FmPcdCcNextEngineParams->statisticsEn = TRUE;
@@ -7050,7 +7444,8 @@ t_Error FM_PCD_HashTableModifyMissNextEngine(t_Handle                  h_HashTbl
 
     for (i = 0; i < p_HashTbl->numOfKeys; i++)
     {
-        h_HashBucket = p_HashTbl->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
+        h_HashBucket =
+                p_HashTbl->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
 
         err = FM_PCD_MatchTableModifyMissNextEngine(h_HashBucket,
                                                     p_FmPcdCcNextEngineParams);
@@ -7060,8 +7455,10 @@ t_Error FM_PCD_HashTableModifyMissNextEngine(t_Handle                  h_HashTbl
 
     if (nullifyMissStats)
     {
-        memset(p_HashTbl->h_MissStatsCounters, 0, (2 * FM_PCD_CC_STATS_COUNTER_SIZE));
-        memset(p_HashTbl->h_MissStatsCounters, 0, (2 * FM_PCD_CC_STATS_COUNTER_SIZE));
+        memset(p_HashTbl->h_MissStatsCounters, 0,
+               (2 * FM_PCD_CC_STATS_COUNTER_SIZE));
+        memset(p_HashTbl->h_MissStatsCounters, 0,
+               (2 * FM_PCD_CC_STATS_COUNTER_SIZE));
         p_HashTbl->statsEnForMiss = TRUE;
     }
 
@@ -7069,16 +7466,18 @@ t_Error FM_PCD_HashTableModifyMissNextEngine(t_Handle                  h_HashTbl
 }
 
 
-t_Error FM_PCD_HashTableGetMissNextEngine(t_Handle                     h_HashTbl,
-                                          t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams)
+t_Error FM_PCD_HashTableGetMissNextEngine(
+        t_Handle h_HashTbl,
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcdCcNode   *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
-    t_FmPcdCcNode   *p_HashBucket;
+    t_FmPcdCcNode *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
+    t_FmPcdCcNode *p_HashBucket;
 
     SANITY_CHECK_RETURN_ERROR(p_HashTbl, E_INVALID_HANDLE);
 
     /* Miss next engine of each bucket was initialized with the next engine of the hash table */
-    p_HashBucket = p_HashTbl->keyAndNextEngineParams[0].nextEngineParams.params.ccParams.h_CcNode;
+    p_HashBucket =
+            p_HashTbl->keyAndNextEngineParams[0].nextEngineParams.params.ccParams.h_CcNode;
 
     memcpy(p_FmPcdCcNextEngineParams,
            &p_HashBucket->keyAndNextEngineParams[p_HashBucket->numOfKeys].nextEngineParams,
@@ -7087,52 +7486,46 @@ t_Error FM_PCD_HashTableGetMissNextEngine(t_Handle                     h_HashTbl
     return E_OK;
 }
 
-t_Error FM_PCD_HashTableFindNGetKeyStatistics(t_Handle                 h_HashTbl,
-                                              uint8_t                  keySize,
-                                              uint8_t                  *p_Key,
-                                              t_FmPcdCcKeyStatistics   *p_KeyStatistics)
+t_Error FM_PCD_HashTableFindNGetKeyStatistics(
+        t_Handle h_HashTbl, uint8_t keySize, uint8_t *p_Key,
+        t_FmPcdCcKeyStatistics *p_KeyStatistics)
 {
-    t_FmPcdCcNode   *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
-    t_Handle        h_HashBucket;
-    uint8_t         bucketIndex;
-    uint16_t        lastIndex;
-    t_Error         err;
+    t_FmPcdCcNode *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
+    t_Handle h_HashBucket;
+    uint8_t bucketIndex;
+    uint16_t lastIndex;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_HashTbl, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_KeyStatistics, E_NULL_POINTER);
 
-    err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl,
-                                                keySize,
-                                                p_Key,
+    err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl, keySize, p_Key,
                                                 p_HashTbl->kgHashShift,
-                                                &h_HashBucket,
-                                                &bucketIndex,
+                                                &h_HashBucket, &bucketIndex,
                                                 &lastIndex);
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    return FM_PCD_MatchTableFindNGetKeyStatistics(h_HashBucket,
-                                                  keySize,
-                                                  p_Key,
-                                                  NULL,
-                                                  p_KeyStatistics);
+    return FM_PCD_MatchTableFindNGetKeyStatistics(h_HashBucket, keySize, p_Key,
+                                                  NULL, p_KeyStatistics);
 }
 
-t_Error FM_PCD_HashTableGetMissStatistics(t_Handle                 h_HashTbl,
-                                          t_FmPcdCcKeyStatistics   *p_MissStatistics)
+t_Error FM_PCD_HashTableGetMissStatistics(
+        t_Handle h_HashTbl, t_FmPcdCcKeyStatistics *p_MissStatistics)
 {
-    t_FmPcdCcNode   *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
-    t_Handle        h_HashBucket;
+    t_FmPcdCcNode *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
+    t_Handle h_HashBucket;
 
     SANITY_CHECK_RETURN_ERROR(p_HashTbl, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_MissStatistics, E_NULL_POINTER);
 
     if (!p_HashTbl->statsEnForMiss)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Statistics were not enabled for miss"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                     ("Statistics were not enabled for miss"));
 
-    h_HashBucket = p_HashTbl->keyAndNextEngineParams[0].nextEngineParams.params.ccParams.h_CcNode;
+    h_HashBucket =
+            p_HashTbl->keyAndNextEngineParams[0].nextEngineParams.params.ccParams.h_CcNode;
 
-    return FM_PCD_MatchTableGetMissStatistics(h_HashBucket,
-                                              p_MissStatistics);
+    return FM_PCD_MatchTableGetMissStatistics(h_HashBucket, p_MissStatistics);
 }
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.h
index 0461260..3bc7585 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.h
@@ -190,35 +190,35 @@ typedef uint32_t ccPrivateInfo_t; /**< private info of CC: */
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
 
-typedef _Packed struct
+typedef struct
 {
     volatile uint32_t fqid;
     volatile uint32_t plcrProfile;
     volatile uint32_t nia;
     volatile uint32_t res;
-} _PackedType t_AdOfTypeResult;
+} t_AdOfTypeResult;
 
-typedef _Packed struct
+typedef struct
 {
     volatile uint32_t ccAdBase;
     volatile uint32_t matchTblPtr;
     volatile uint32_t pcAndOffsets;
     volatile uint32_t gmask;
-} _PackedType t_AdOfTypeContLookup;
+} t_AdOfTypeContLookup;
 
-typedef _Packed struct
+typedef struct
 {
     volatile uint32_t profileTableAddr;
     volatile uint32_t reserved;
     volatile uint32_t nextActionIndx;
     volatile uint32_t statsTableAddr;
-} _PackedType t_AdOfTypeStats;
+} t_AdOfTypeStats;
 
-typedef _Packed union
+typedef union
 {
     volatile t_AdOfTypeResult        adResult;
     volatile t_AdOfTypeContLookup    adContLookup;
-} _PackedType t_Ad;
+} t_Ad;
 
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
@@ -389,6 +389,7 @@ typedef struct
     bool                modifiedState;
     uint32_t            requiredAction;
     t_Handle            h_IpReassemblyManip;
+    t_Handle            h_CapwapReassemblyManip;
 
     t_FmPcdCcKeyAndNextEngineParams keyAndNextEngineParams[FM_PCD_MAX_NUM_OF_CC_GROUPS];
 } t_FmPcdCcTree;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c
index 769a7ab..720da19 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c
@@ -114,7 +114,7 @@ static e_FmPcdKgExtractDfltSelect GetGenericSwDefault(t_FmPcdKgExtractDflt swDef
             for (i=0 ; i<numOfSwDefaults ; i++)
                 if (swDefaults[i].type == e_FM_PCD_KG_GENERIC_NOT_FROM_DATA)
                     return swDefaults[i].dfltSelect;
-            ASSERT_COND(FALSE);
+            break;
         case (KG_SCH_GEN_SHIM1):
         case (KG_SCH_GEN_SHIM2):
         case (KG_SCH_GEN_IP_PID_NO_V):
@@ -133,7 +133,7 @@ static e_FmPcdKgExtractDfltSelect GetGenericSwDefault(t_FmPcdKgExtractDflt swDef
             for (i=0 ; i<numOfSwDefaults ; i++)
                 if (swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V)
                     return swDefaults[i].dfltSelect;
-
+            break;
         case (KG_SCH_GEN_START_OF_FRM):
         case (KG_SCH_GEN_ETH):
         case (KG_SCH_GEN_SNAP):
@@ -160,9 +160,12 @@ static e_FmPcdKgExtractDfltSelect GetGenericSwDefault(t_FmPcdKgExtractDflt swDef
             for (i=0 ; i<numOfSwDefaults ; i++)
                 if (swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA)
                     return swDefaults[i].dfltSelect;
+            break;
         default:
-            return e_FM_PCD_KG_DFLT_ILLEGAL;
+            break;
     }
+
+    return e_FM_PCD_KG_DFLT_ILLEGAL;
 }
 
 static uint8_t GetGenCode(e_FmPcdExtractFrom src, uint8_t *p_Offset)
@@ -301,6 +304,7 @@ static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field,
         {
             case (HEADER_TYPE_NONE):
                 ASSERT_COND(FALSE);
+                break;
             case (HEADER_TYPE_ETH):
                 switch (field.eth)
                 {
@@ -310,6 +314,7 @@ static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field,
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                         return 0;
                 }
+                break;
             case (HEADER_TYPE_VLAN):
                 switch (field.vlan)
                 {
@@ -321,6 +326,7 @@ static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field,
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal VLAN header index"));
                         return 0;
                 }
+                break;
             case (HEADER_TYPE_MPLS):
             case (HEADER_TYPE_IPSEC_AH):
             case (HEADER_TYPE_IPSEC_ESP):
@@ -337,24 +343,27 @@ static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field,
             case (HEADER_TYPE_DCCP):
             case (HEADER_TYPE_USER_DEFINED_L4):
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-            default:
-                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header not supported"));
                 return 0;
+            default:
+                break;
+
         }
         else
             switch (hdr)
             {
                 case (HEADER_TYPE_NONE):
                     ASSERT_COND(FALSE);
+                    break;
                 case (HEADER_TYPE_ETH):
-                switch (field.eth)
-                {
-                    case (NET_HEADER_FIELD_ETH_TYPE):
-                        return KG_SCH_GEN_ETH_TYPE_NO_V;
-                    default:
-                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-                        return 0;
-                }
+                    switch (field.eth)
+                    {
+                        case (NET_HEADER_FIELD_ETH_TYPE):
+                            return KG_SCH_GEN_ETH_TYPE_NO_V;
+                        default:
+                            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                            return 0;
+                    }
+                    break;
                 case (HEADER_TYPE_VLAN):
                     switch (field.vlan)
                     {
@@ -366,6 +375,7 @@ static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field,
                             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal VLAN header index"));
                             return 0;
                     }
+                    break;
                 case (HEADER_TYPE_IPv4):
                     switch (field.ipv4)
                     {
@@ -375,6 +385,7 @@ static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field,
                             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                             return 0;
                     }
+                    break;
                 case (HEADER_TYPE_IPv6):
                    switch (field.ipv6)
                     {
@@ -384,6 +395,7 @@ static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field,
                             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                             return 0;
                     }
+                    break;
                 case (HEADER_TYPE_MPLS):
                 case (HEADER_TYPE_LLC_SNAP):
                 case (HEADER_TYPE_PPPoE):
@@ -400,9 +412,10 @@ static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field,
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
                 default:
-                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header not supported"));
-                    return 0;
+                    break;
             }
+    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header not supported"));
+    return 0;
 }
 
 static t_KnownFieldsMasks GetKnownProtMask(t_FmPcd *p_FmPcd, e_NetHeaderType hdr, e_FmPcdHdrIndex index, t_FmPcdFields field)
@@ -413,6 +426,7 @@ static t_KnownFieldsMasks GetKnownProtMask(t_FmPcd *p_FmPcd, e_NetHeaderType hdr
     {
         case (HEADER_TYPE_NONE):
             ASSERT_COND(FALSE);
+            break;
         case (HEADER_TYPE_ETH):
             switch (field.eth)
             {
@@ -658,9 +672,12 @@ static t_KnownFieldsMasks GetKnownProtMask(t_FmPcd *p_FmPcd, e_NetHeaderType hdr
                     return 0;
             }
         default:
-            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-            return 0;
+            break;
+
     }
+
+    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+    return 0;
 }
 
 
@@ -1220,8 +1237,6 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme            *p_Scheme,
                         p_SchemeRegs->kgse_ppc = ppcTmp;
                     }
                 }
-                else
-                    ppcTmp = KG_SCH_PP_NO_GEN;
             }
             break;
         case (e_FM_PCD_DONE):
@@ -1242,7 +1257,6 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme            *p_Scheme,
     {
         p_SchemeRegs->kgse_om |= KG_SCH_OM_VSPE;
 
-        tmpReg = 0;
         if (p_SchemeParams->storageProfile.direct)
         {
             profileId = p_SchemeParams->storageProfile.profileSelect.directRelativeProfileId;
@@ -1382,12 +1396,11 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme            *p_Scheme,
                 case (e_FM_PCD_EXTRACT_BY_HDR):
                     switch (p_Extract->extractByHdr.hdr)
                     {
-
-#ifdef FM_CAPWAP_SUPPORT
+#if (DPAA_VERSION >= 11) || ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
                         case (HEADER_TYPE_UDP_LITE):
                             p_Extract->extractByHdr.hdr = HEADER_TYPE_UDP;
                             break;
-#endif
+#endif /* (DPAA_VERSION >= 11) || ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT)) */
                         case (HEADER_TYPE_UDP_ENCAP_ESP):
                             switch (p_Extract->extractByHdr.type)
                             {
@@ -1417,14 +1430,12 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme            *p_Scheme,
                                         case (NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI):
                                             p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
                                             p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
-                                            p_Extract->extractByHdr.extractByHdrType.fromField.size = p_Extract->extractByHdr.extractByHdrType.fromField.size;
                                             /*p_Extract->extractByHdr.extractByHdrType.fromField.offset += ESP_SPI_OFFSET;*/
                                             p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
                                             break;
                                         case (NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM):
                                             p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
                                             p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
-                                            p_Extract->extractByHdr.extractByHdrType.fromField.size = p_Extract->extractByHdr.extractByHdrType.fromField.size;
                                             p_Extract->extractByHdr.extractByHdrType.fromField.offset += ESP_SEQ_NUM_OFFSET;
                                             p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
                                             break;
@@ -1493,17 +1504,18 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme            *p_Scheme,
                                 }
                                 else
                                     generic = TRUE;
-
                             }
                             else
                                 generic = TRUE;
                             if (generic)
                             {
                                 /* tmp - till we cover more headers under generic */
+                                XX_Free(p_LocalExtractsArray);
                                 RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Full header selection not supported"));
                             }
                             break;
                         default:
+                            XX_Free(p_LocalExtractsArray);
                             RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
                     }
                     break;
@@ -1524,15 +1536,24 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme            *p_Scheme,
             {
                 /* set generic register fields */
                 if (currGenId >= FM_KG_NUM_OF_GENERIC_REGS)
+                {
+                    XX_Free(p_LocalExtractsArray);
                     RETURN_ERROR(MAJOR, E_FULL, ("Generic registers are fully used"));
+                }
                 if (!code)
+                {
+                    XX_Free(p_LocalExtractsArray);
                     RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
+                }
 
                 genTmp = KG_SCH_GEN_VALID;
                 genTmp |= (uint32_t)(code << KG_SCH_GEN_HT_SHIFT);
                 genTmp |= offset;
                 if ((size > MAX_KG_SCH_SIZE) || (size < 1))
-                      RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal extraction (size out of range)"));
+                {
+                    XX_Free(p_LocalExtractsArray);
+                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal extraction (size out of range)"));
+                }
                 genTmp |= (uint32_t)((size - 1) << KG_SCH_GEN_SIZE_SHIFT);
                 swDefault = GetGenericSwDefault(swDefaults, numOfSwDefaults, code);
                 if (swDefault == e_FM_PCD_KG_DFLT_ILLEGAL)
@@ -1554,8 +1575,11 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme            *p_Scheme,
         maskTmp = 0xFFFFFFFF;
         /*  configure kgse_bmch, kgse_bmcl and kgse_fqb */
 
-        if (p_KeyAndHash->numOfUsedMasks >= FM_PCD_KG_NUM_OF_EXTRACT_MASKS)
+        if (p_KeyAndHash->numOfUsedMasks > FM_PCD_KG_NUM_OF_EXTRACT_MASKS)
+        {
+            XX_Free(p_LocalExtractsArray);
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Only %d masks supported", FM_PCD_KG_NUM_OF_EXTRACT_MASKS));
+        }
         for ( i=0 ;i<p_KeyAndHash->numOfUsedMasks ; i++)
         {
             /* Get the relative id of the extract (for known 0-0x1f, for generic 0-7) */
@@ -1590,9 +1614,15 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme            *p_Scheme,
 
         /*  configure kgse_hc  */
         if (p_KeyAndHash->hashShift > MAX_HASH_SHIFT)
-             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashShift must not be larger than %d", MAX_HASH_SHIFT));
+        {
+            XX_Free(p_LocalExtractsArray);
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashShift must not be larger than %d", MAX_HASH_SHIFT));
+        }
         if (p_KeyAndHash->hashDistributionFqidsShift > MAX_DIST_FQID_SHIFT)
-             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashDistributionFqidsShift must not be larger than %d", MAX_DIST_FQID_SHIFT));
+        {
+            XX_Free(p_LocalExtractsArray);
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashDistributionFqidsShift must not be larger than %d", MAX_DIST_FQID_SHIFT));
+        }
 
         tmpReg = 0;
 
@@ -1605,7 +1635,10 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme            *p_Scheme,
                     (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPSRC1) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPDST1)) ||
                     (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPSRC2) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPDST2)) ||
                     (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_L4PSRC) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_L4PDST)))
+            {
+                XX_Free(p_LocalExtractsArray);
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("symmetricHash set but src/dest extractions missing"));
+            }
             tmpReg |= KG_SCH_HASH_CONFIG_SYM;
         }
         p_SchemeRegs->kgse_hc = tmpReg;
@@ -1651,8 +1684,6 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme            *p_Scheme,
             }
         }
         XX_Free(p_LocalExtractsArray);
-        p_LocalExtractsArray = NULL;
-
     }
     else
     {
@@ -2002,7 +2033,7 @@ void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
     memset(&p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId], 0, sizeof(t_FmPcdKgClsPlanGrp));
 }
 
-t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort, uint32_t *p_SpReg, bool add)
+t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd, t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort, uint32_t *p_SpReg, bool add)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint32_t                j, schemesPerPortVector = 0;
@@ -2054,7 +2085,9 @@ t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBin
                 the match vector and the grpBits (= ccUnits) */
                 if ((p_Scheme->matchVector != SCHEME_ALWAYS_DIRECT) || p_Scheme->ccUnits)
                 {
+                    uint8_t netEnvId;
                     walking1Mask = 0x80000000;
+                    netEnvId = (p_Scheme->netEnvId == ILLEGAL_NETENV)? p_BindPort->netEnvId:p_Scheme->netEnvId;
                     tmp = (p_Scheme->matchVector == SCHEME_ALWAYS_DIRECT)? 0:p_Scheme->matchVector;
                     tmp |= p_Scheme->ccUnits;
                     while (tmp)
@@ -2062,7 +2095,7 @@ t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBin
                         if (tmp & walking1Mask)
                         {
                             tmp &= ~walking1Mask;
-                            if (!PcdNetEnvIsUnitWithoutOpts(p_FmPcd, p_Scheme->netEnvId, walking1Mask))
+                            if (!PcdNetEnvIsUnitWithoutOpts(p_FmPcd, netEnvId, walking1Mask))
                                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port (without clsPlan) may not be bound to requested scheme - uses clsPlan options"));
                         }
                         walking1Mask >>= 1;
@@ -2761,6 +2794,30 @@ uint8_t FmPcdKgGetRelativeSchemeId(t_Handle h_FmPcd, uint8_t schemeId)
     return FM_PCD_KG_NUM_OF_SCHEMES;
 }
 
+t_Handle FmPcdKgGetSchemeHandle(t_Handle h_FmPcd, uint8_t relativeSchemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    ASSERT_COND(p_FmPcd);
+
+    /* check that schemeId is in range */
+    if (relativeSchemeId >= p_FmPcd->p_FmPcdKg->numOfSchemes)
+    {
+        REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, ("relative-scheme-id %d!", relativeSchemeId));
+        return NULL;
+    }
+
+    if (!FmPcdKgIsSchemeValidSw(&p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId]))
+        return NULL;
+
+    return &p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId];
+}
+
+bool FmPcdKgIsSchemeHasOwners(t_Handle h_Scheme)
+{
+    return (((t_FmPcdKgScheme*)h_Scheme)->owners == 0)?FALSE:TRUE;
+}
+
 t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requiredAction, uint32_t value)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -3183,105 +3240,3 @@ t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value)
         WRITE_UINT32(p_Regs->fmkg_gdv1r,value);
     return E_OK;
 }
-
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
-{
-    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    int                 i = 0, j = 0;
-    uint8_t             hardwarePortId = 0;
-    uint32_t            tmpKgarReg, intFlags;
-    t_Error             err = E_OK;
-
-    DECLARE_DUMP;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(((p_FmPcd->guestId == NCSW_MASTER_ID) ||
-                               p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs), E_INVALID_OPERATION);
-
-    DUMP_SUBTITLE(("\n"));
-    DUMP_TITLE(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs, ("FmPcdKgRegs Regs"));
-
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_gcr);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_eer);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_eeer);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_seer);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_seeer);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_gsr);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_tpc);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_serc);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_fdor);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_gdv0r);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_gdv1r);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_feer);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,fmkg_ar);
-
-    DUMP_SUBTITLE(("\n"));
-    intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
-    for (j = 0;j<FM_PCD_KG_NUM_OF_SCHEMES;j++)
-    {
-        tmpKgarReg = FmPcdKgBuildReadSchemeActionReg((uint8_t)j);
-        if (WriteKgarWait(p_FmPcd, tmpKgarReg) != E_OK)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-
-        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs, ("FmPcdKgIndirectAccessSchemeRegs Scheme %d Regs", j));
-
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_mode);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_ekfc);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_ekdv);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_bmch);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_bmcl);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_fqb);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_hc);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_ppc);
-
-        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs.kgse_gec, ("kgse_gec"));
-        DUMP_SUBSTRUCT_ARRAY(i, FM_KG_NUM_OF_GENERIC_REGS)
-        {
-            DUMP_MEMORY(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs.kgse_gec[i], sizeof(uint32_t));
-        }
-
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_spc);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_dv0);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_dv1);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_ccbs);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->schemeRegs,kgse_mv);
-    }
-    DUMP_SUBTITLE(("\n"));
-
-    for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
-    {
-        SW_PORT_INDX_TO_HW_PORT_ID(hardwarePortId, i);
-
-        tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
-
-        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-        if (err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-
-        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->portRegs, ("FmPcdKgIndirectAccessPortRegs PCD Port %d regs", hardwarePortId));
-
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->portRegs, fmkg_pe_sp);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->portRegs, fmkg_pe_cpp);
-    }
-
-    DUMP_SUBTITLE(("\n"));
-    for (j=0;j<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;j++)
-    {
-        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->clsPlanRegs, ("FmPcdKgIndirectAccessClsPlanRegs Regs group %d", j));
-        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->clsPlanRegs.kgcpe, ("kgcpe"));
-
-        tmpKgarReg = ReadClsPlanBlockActionReg((uint8_t)j);
-        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-        if (err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-        DUMP_SUBSTRUCT_ARRAY(i, 8)
-            DUMP_MEMORY(&p_FmPcd->p_FmPcdKg->p_IndirectAccessRegs->clsPlanRegs.kgcpe[i], sizeof(uint32_t));
-    }
-    KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
-
-    return E_OK;
-}
-#endif /* (defined(DEBUG_ERRORS) && ... */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c
index bde073e..ba81535 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c
@@ -35,7 +35,7 @@
  @File          fm_manip.c
 
  @Description   FM PCD manip ...
-*//***************************************************************************/
+ *//***************************************************************************/
 #include "std_ext.h"
 #include "error_ext.h"
 #include "string_ext.h"
@@ -49,13 +49,12 @@
 #include "fm_hc.h"
 #include "fm_manip.h"
 
-
 /****************************************/
 /*       static functions               */
 /****************************************/
 static t_Handle GetManipInfo(t_FmPcdManip *p_Manip, e_ManipInfo manipInfo)
 {
-     t_FmPcdManip     *p_CurManip = p_Manip;
+    t_FmPcdManip *p_CurManip = p_Manip;
 
     if (!MANIP_IS_UNIFIED(p_Manip))
         p_CurManip = p_Manip;
@@ -78,10 +77,11 @@ static t_Handle GetManipInfo(t_FmPcdManip *p_Manip, e_ManipInfo manipInfo)
             return NULL;
     }
 }
-static uint16_t    GetHmctSize(t_FmPcdManip *p_Manip)
+
+static uint16_t GetHmctSize(t_FmPcdManip *p_Manip)
 {
-    uint16_t         size = 0;
-    t_FmPcdManip     *p_CurManip = p_Manip;
+    uint16_t size = 0;
+    t_FmPcdManip *p_CurManip = p_Manip;
 
     if (!MANIP_IS_UNIFIED(p_Manip))
         return p_Manip->tableSize;
@@ -97,12 +97,13 @@ static uint16_t    GetHmctSize(t_FmPcdManip *p_Manip)
     }
     size += p_CurManip->tableSize; /* add last size */
 
-    return(size);
+    return (size);
 }
-static uint16_t    GetDataSize(t_FmPcdManip *p_Manip)
+
+static uint16_t GetDataSize(t_FmPcdManip *p_Manip)
 {
-    uint16_t         size = 0;
-    t_FmPcdManip     *p_CurManip = p_Manip;
+    uint16_t size = 0;
+    t_FmPcdManip *p_CurManip = p_Manip;
 
     if (!MANIP_IS_UNIFIED(p_Manip))
         return p_Manip->dataSize;
@@ -118,111 +119,179 @@ static uint16_t    GetDataSize(t_FmPcdManip *p_Manip)
     }
     size += p_CurManip->dataSize; /* add last size */
 
-    return(size);
+    return (size);
 }
-static t_Error CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams, uint16_t *p_TableSize, uint8_t *p_DataSize)
+
+static t_Error CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams,
+                                  uint16_t *p_TableSize, uint8_t *p_DataSize)
 {
     uint8_t localDataSize, remain, tableSize = 0, dataSize = 0;
 
     if (p_FmPcdManipParams->u.hdr.rmv)
     {
-        switch (p_FmPcdManipParams->u.hdr.rmvParams.type){
+        switch (p_FmPcdManipParams->u.hdr.rmvParams.type)
+        {
             case (e_FM_PCD_MANIP_RMV_GENERIC):
+                tableSize += HMCD_BASIC_SIZE;
+                break;
             case (e_FM_PCD_MANIP_RMV_BY_HDR):
-                /* As long as the only rmv command is the L2, no check on type is required */
-                tableSize +=  HMCD_BASIC_SIZE;
-            break;
+                switch (p_FmPcdManipParams->u.hdr.rmvParams.u.byHdr.type)
+                {
+                    case (e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2):
+#if (DPAA_VERSION >= 11)
+                    case (e_FM_PCD_MANIP_RMV_BY_HDR_CAPWAP):
+                    case (e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START):
+#endif /* (DPAA_VERSION >= 11) */
+                        tableSize += HMCD_BASIC_SIZE;
+                        break;
+                    default:
+                        RETURN_ERROR(MINOR, E_INVALID_SELECTION,
+                                     ("Unknown byHdr.type"));
+                }
+                break;
             default:
-                RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown rmvParams.type"));
+                RETURN_ERROR(MINOR, E_INVALID_SELECTION,
+                             ("Unknown rmvParams.type"));
         }
     }
 
     if (p_FmPcdManipParams->u.hdr.insrt)
     {
-        switch (p_FmPcdManipParams->u.hdr.insrtParams.type){
+        switch (p_FmPcdManipParams->u.hdr.insrtParams.type)
+        {
             case (e_FM_PCD_MANIP_INSRT_GENERIC):
-                remain = (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size % 4);
+                remain =
+                        (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size
+                                % 4);
                 if (remain)
-                    localDataSize = (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size + 4 - remain);
+                    localDataSize =
+                            (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size
+                                    + 4 - remain);
                 else
-                    localDataSize = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size;
+                    localDataSize =
+                            p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size;
                 tableSize += (uint8_t)(HMCD_BASIC_SIZE + localDataSize);
-            break;
+                break;
             case (e_FM_PCD_MANIP_INSRT_BY_HDR):
-                /* As long as the only insert command is the internal L2, no check on type is required */
-                tableSize += HMCD_BASIC_SIZE+HMCD_PTR_SIZE;
-                if (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.type == e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2)
-                    switch (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.specificL2)
-                    {
-                        case (e_FM_PCD_MANIP_HDR_INSRT_MPLS):
-                            dataSize += p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.size;
+            {
+                switch (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.type)
+                {
+
+                    case (e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2):
+                        tableSize += HMCD_BASIC_SIZE + HMCD_PTR_SIZE;
+                        switch (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.specificL2)
+                        {
+                            case (e_FM_PCD_MANIP_HDR_INSRT_MPLS):
+                                dataSize +=
+                                        p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.size;
+                                break;
+                            default:
+                                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+                        }
                         break;
-                        default:
-                            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
-                    }
-            break;
+#if (DPAA_VERSION >= 11)
+                    case (e_FM_PCD_MANIP_INSRT_BY_HDR_IP):
+                        tableSize +=
+                                (HMCD_BASIC_SIZE + HMCD_PTR_SIZE
+                                        + HMCD_PARAM_SIZE
+                                        + p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.ipParams.insrt.size);
+                        dataSize += 2;
+                        break;
+
+                    case (e_FM_PCD_MANIP_INSRT_BY_HDR_UDP):
+                    case (e_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE):
+                        tableSize += (HMCD_BASIC_SIZE + HMCD_L4_HDR_SIZE);
+
+                        break;
+
+                    case (e_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP):
+                        tableSize +=
+                                (HMCD_BASIC_SIZE
+                                        + p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.insrt.size);
+                        break;
+#endif /* (DPAA_VERSION >= 11) */
+                    default:
+                        RETURN_ERROR(MINOR, E_INVALID_SELECTION,
+                                     ("Unknown byHdr.type"));
+                }
+            }
+                break;
             default:
-                RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown insrtParams.type"));
+                RETURN_ERROR(MINOR, E_INVALID_SELECTION,
+                             ("Unknown insrtParams.type"));
         }
     }
+
     if (p_FmPcdManipParams->u.hdr.fieldUpdate)
     {
-        switch (p_FmPcdManipParams->u.hdr.fieldUpdateParams.type){
+        switch (p_FmPcdManipParams->u.hdr.fieldUpdateParams.type)
+        {
             case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN):
                 tableSize += HMCD_BASIC_SIZE;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
-                   e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType
+                        == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
                 {
                     tableSize += HMCD_PTR_SIZE;
                     dataSize += DSCP_TO_VLAN_TABLE_SIZE;
                 }
-            break;
+                break;
             case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4):
                 tableSize += HMCD_BASIC_SIZE;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_ID)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV4_ID)
                 {
                     tableSize += HMCD_PARAM_SIZE;
                     dataSize += 2;
                 }
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_SRC)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV4_SRC)
                     tableSize += HMCD_IPV4_ADDR_SIZE;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_DST)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV4_DST)
                     tableSize += HMCD_IPV4_ADDR_SIZE;
-            break;
+                break;
             case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6):
                 tableSize += HMCD_BASIC_SIZE;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV6_SRC)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV6_SRC)
                     tableSize += HMCD_IPV6_ADDR_SIZE;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV6_DST)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV6_DST)
                     tableSize += HMCD_IPV6_ADDR_SIZE;
-            break;
+                break;
             case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP):
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates == HDR_MANIP_TCP_UDP_CHECKSUM)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates
+                        == HDR_MANIP_TCP_UDP_CHECKSUM)
                     /* we implement this case with the update-checksum descriptor */
                     tableSize += HMCD_BASIC_SIZE;
                 else
                     /* we implement this case with the TCP/UDP-update descriptor */
                     tableSize += HMCD_BASIC_SIZE + HMCD_PARAM_SIZE;
-            break;
+                break;
             default:
-                RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown fieldUpdateParams.type"));
+                RETURN_ERROR(MINOR, E_INVALID_SELECTION,
+                             ("Unknown fieldUpdateParams.type"));
         }
     }
 
     if (p_FmPcdManipParams->u.hdr.custom)
     {
-        switch (p_FmPcdManipParams->u.hdr.customParams.type){
+        switch (p_FmPcdManipParams->u.hdr.customParams.type)
+        {
             case (e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE):
             {
                 tableSize += HMCD_BASIC_SIZE + HMCD_PARAM_SIZE + HMCD_PARAM_SIZE;
-                dataSize += p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.hdrSize;
-                if ((p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4) &&
-                        (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.updateIpv4Id))
+                dataSize +=
+                        p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.hdrSize;
+                if ((p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType
+                        == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4)
+                        && (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.updateIpv4Id))
                     dataSize += 2;
             }
-            break;
+                break;
             default:
-                RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown customParams.type"));
+                RETURN_ERROR(MINOR, E_INVALID_SELECTION,
+                             ("Unknown customParams.type"));
         }
     }
 
@@ -232,74 +301,233 @@ static t_Error CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams, uint16
     return E_OK;
 }
 
-static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams, uint8_t *p_DestHmct, uint8_t *p_DestData, bool new)
+static t_Error GetPrOffsetByHeaderOrField(t_FmManipHdrInfo *p_HdrInfo,
+                                          uint8_t *parseArrayOffset)
+{
+    e_NetHeaderType hdr = p_HdrInfo->hdr;
+    e_FmPcdHdrIndex hdrIndex = p_HdrInfo->hdrIndex;
+    bool byField = p_HdrInfo->byField;
+    t_FmPcdFields field;
+
+    if (byField)
+        field = p_HdrInfo->fullField;
+
+    if (byField)
+    {
+        switch (hdr)
+        {
+            case (HEADER_TYPE_ETH):
+                switch (field.eth)
+                {
+                    case (NET_HEADER_FIELD_ETH_TYPE):
+                        *parseArrayOffset = CC_PC_PR_ETYPE_LAST_OFFSET;
+                        break;
+                    default:
+                        RETURN_ERROR(
+                                MAJOR,
+                                E_NOT_SUPPORTED,
+                                ("Header manipulation of the type Ethernet with this field not supported"));
+                }
+                break;
+            case (HEADER_TYPE_VLAN):
+                switch (field.vlan)
+                {
+                    case (NET_HEADER_FIELD_VLAN_TCI):
+                        if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE)
+                                || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                            *parseArrayOffset = CC_PC_PR_VLAN1_OFFSET;
+                        else
+                            if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                                *parseArrayOffset = CC_PC_PR_VLAN2_OFFSET;
+                        break;
+                    default:
+                        RETURN_ERROR(
+                                MAJOR,
+                                E_NOT_SUPPORTED,
+                                ("Header manipulation of the type VLAN with this field not supported"));
+                }
+                break;
+            default:
+                RETURN_ERROR(
+                        MAJOR,
+                        E_NOT_SUPPORTED,
+                        ("Header manipulation of this header by field not supported"));
+        }
+    }
+    else
+    {
+        switch (hdr)
+        {
+            case (HEADER_TYPE_ETH):
+                *parseArrayOffset = (uint8_t)CC_PC_PR_ETH_OFFSET;
+                break;
+            case (HEADER_TYPE_USER_DEFINED_SHIM1):
+                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM1_OFFSET;
+                break;
+            case (HEADER_TYPE_USER_DEFINED_SHIM2):
+                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM2_OFFSET;
+                break;
+            case (HEADER_TYPE_LLC_SNAP):
+                *parseArrayOffset = CC_PC_PR_USER_LLC_SNAP_OFFSET;
+                break;
+            case (HEADER_TYPE_PPPoE):
+                *parseArrayOffset = CC_PC_PR_PPPOE_OFFSET;
+                break;
+            case (HEADER_TYPE_MPLS):
+                if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE)
+                        || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
+                else
+                    if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                        *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
+                break;
+            case (HEADER_TYPE_IPv4):
+            case (HEADER_TYPE_IPv6):
+                if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE)
+                        || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    *parseArrayOffset = CC_PC_PR_IP1_OFFSET;
+                else
+                    if (hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                        *parseArrayOffset = CC_PC_PR_IP_LAST_OFFSET;
+                break;
+            case (HEADER_TYPE_MINENCAP):
+                *parseArrayOffset = CC_PC_PR_MINENC_OFFSET;
+                break;
+            case (HEADER_TYPE_GRE):
+                *parseArrayOffset = CC_PC_PR_GRE_OFFSET;
+                break;
+            case (HEADER_TYPE_TCP):
+            case (HEADER_TYPE_UDP):
+            case (HEADER_TYPE_IPSEC_AH):
+            case (HEADER_TYPE_IPSEC_ESP):
+            case (HEADER_TYPE_DCCP):
+            case (HEADER_TYPE_SCTP):
+                *parseArrayOffset = CC_PC_PR_L4_OFFSET;
+                break;
+            case (HEADER_TYPE_CAPWAP):
+            case (HEADER_TYPE_CAPWAP_DTLS):
+                *parseArrayOffset = CC_PC_PR_NEXT_HEADER_OFFSET;
+                break;
+            default:
+                RETURN_ERROR(
+                        MAJOR,
+                        E_NOT_SUPPORTED,
+                        ("Header manipulation of this header is not supported"));
+        }
+    }
+    return E_OK;
+}
+
+static t_Error BuildHmct(t_FmPcdManip *p_Manip,
+                         t_FmPcdManipParams *p_FmPcdManipParams,
+                         uint8_t *p_DestHmct, uint8_t *p_DestData, bool new)
 {
-    uint32_t        *p_TmpHmct = (uint32_t*)p_DestHmct, *p_LocalData;
-    uint32_t        tmpReg=0, *p_Last = NULL;
-    uint8_t         remain, i, size=0, origSize, *p_UsrData = NULL, *p_TmpData = p_DestData;
-    t_Handle        h_FmPcd = p_Manip->h_FmPcd;
-    uint8_t         j=0;
+    uint32_t *p_TmpHmct = (uint32_t*)p_DestHmct, *p_LocalData;
+    uint32_t tmpReg = 0, *p_Last = NULL, tmp_ipv6_addr;
+    uint8_t remain, i, size = 0, origSize, *p_UsrData = NULL, *p_TmpData =
+            p_DestData;
+    t_Handle h_FmPcd = p_Manip->h_FmPcd;
+    uint8_t j = 0;
 
     if (p_FmPcdManipParams->u.hdr.rmv)
     {
-        if (p_FmPcdManipParams->u.hdr.rmvParams.type == e_FM_PCD_MANIP_RMV_GENERIC)
+        if (p_FmPcdManipParams->u.hdr.rmvParams.type
+                == e_FM_PCD_MANIP_RMV_GENERIC)
         {
             /* initialize HMCD */
             tmpReg = (uint32_t)(HMCD_OPCODE_GENERIC_RMV) << HMCD_OC_SHIFT;
             /* tmp, should be conditional */
-            tmpReg |= p_FmPcdManipParams->u.hdr.rmvParams.u.generic.offset << HMCD_RMV_OFFSET_SHIFT;
-            tmpReg |= p_FmPcdManipParams->u.hdr.rmvParams.u.generic.size << HMCD_RMV_SIZE_SHIFT;
+            tmpReg |= p_FmPcdManipParams->u.hdr.rmvParams.u.generic.offset
+                    << HMCD_RMV_OFFSET_SHIFT;
+            tmpReg |= p_FmPcdManipParams->u.hdr.rmvParams.u.generic.size
+                    << HMCD_RMV_SIZE_SHIFT;
         }
-        else if (p_FmPcdManipParams->u.hdr.rmvParams.type == e_FM_PCD_MANIP_RMV_BY_HDR)
-        {
-            uint8_t     hmcdOpt;
-            if (!p_FmPcdManipParams->u.hdr.rmvParams.u.byHdr.type == e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2)
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+        else
+            if (p_FmPcdManipParams->u.hdr.rmvParams.type
+                    == e_FM_PCD_MANIP_RMV_BY_HDR)
+            {
+                switch (p_FmPcdManipParams->u.hdr.rmvParams.u.byHdr.type)
+                {
+                    case (e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2):
+                    {
+                        uint8_t hmcdOpt;
 
-            /* initialize HMCD */
-            tmpReg = (uint32_t)(HMCD_OPCODE_L2_RMV) << HMCD_OC_SHIFT;
+                        /* initialize HMCD */
+                        tmpReg = (uint32_t)(HMCD_OPCODE_L2_RMV) << HMCD_OC_SHIFT;
 
-            switch (p_FmPcdManipParams->u.hdr.rmvParams.u.byHdr.u.specificL2)
-            {
-                case (e_FM_PCD_MANIP_HDR_RMV_ETHERNET):
-                    hmcdOpt = HMCD_RMV_L2_ETHERNET;
-                    break;
-                case (e_FM_PCD_MANIP_HDR_RMV_STACKED_QTAGS):
-                    hmcdOpt = HMCD_RMV_L2_STACKED_QTAGS;
-                    break;
-                case (e_FM_PCD_MANIP_HDR_RMV_ETHERNET_AND_MPLS):
-                    hmcdOpt = HMCD_RMV_L2_ETHERNET_AND_MPLS;
-                    break;
-                case (e_FM_PCD_MANIP_HDR_RMV_MPLS):
-                    hmcdOpt = HMCD_RMV_L2_MPLS;
-                    break;
-                default:
-                    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+                        switch (p_FmPcdManipParams->u.hdr.rmvParams.u.byHdr.u.specificL2)
+                        {
+                            case (e_FM_PCD_MANIP_HDR_RMV_ETHERNET):
+                                hmcdOpt = HMCD_RMV_L2_ETHERNET;
+                                break;
+                            case (e_FM_PCD_MANIP_HDR_RMV_STACKED_QTAGS):
+                                hmcdOpt = HMCD_RMV_L2_STACKED_QTAGS;
+                                break;
+                            case (e_FM_PCD_MANIP_HDR_RMV_ETHERNET_AND_MPLS):
+                                hmcdOpt = HMCD_RMV_L2_ETHERNET_AND_MPLS;
+                                break;
+                            case (e_FM_PCD_MANIP_HDR_RMV_MPLS):
+                                hmcdOpt = HMCD_RMV_L2_MPLS;
+                                break;
+                            default:
+                                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+                        }
+                        tmpReg |= hmcdOpt << HMCD_L2_MODE_SHIFT;
+                        break;
+                    }
+#if (DPAA_VERSION >= 11)
+                    case (e_FM_PCD_MANIP_RMV_BY_HDR_CAPWAP):
+                        tmpReg = (uint32_t)(HMCD_OPCODE_CAPWAP_RMV)
+                                << HMCD_OC_SHIFT;
+                        break;
+                    case (e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START):
+                    {
+                        uint8_t prsArrayOffset;
+                        t_Error err = E_OK;
+
+                        tmpReg = (uint32_t)(HMCD_OPCODE_RMV_TILL)
+                                << HMCD_OC_SHIFT;
+
+                        err =
+                                GetPrOffsetByHeaderOrField(
+                                        &p_FmPcdManipParams->u.hdr.rmvParams.u.byHdr.u.hdrInfo,
+                                        &prsArrayOffset);
+                        ASSERT_COND(!err);
+                        /* was previously checked */
+
+                        tmpReg |= ((uint32_t)prsArrayOffset << 16);
+                    }
+                        break;
+#endif /* (DPAA_VERSION >= 11) */
+                    default:
+                        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                                     ("manip header remove by hdr type!"));
+                }
             }
-            tmpReg |= hmcdOpt << HMCD_L2_MODE_SHIFT;
-        }
-        else
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("manip header remove type!"));
 
         WRITE_UINT32(*p_TmpHmct, tmpReg);
         /* save a pointer to the "last" indication word */
         p_Last = p_TmpHmct;
         /* advance to next command */
-        p_TmpHmct += HMCD_BASIC_SIZE/4;
+        p_TmpHmct += HMCD_BASIC_SIZE / 4;
     }
 
     if (p_FmPcdManipParams->u.hdr.insrt)
     {
-        if (p_FmPcdManipParams->u.hdr.insrtParams.type == e_FM_PCD_MANIP_INSRT_GENERIC)
+        if (p_FmPcdManipParams->u.hdr.insrtParams.type
+                == e_FM_PCD_MANIP_INSRT_GENERIC)
         {
             /* initialize HMCD */
             if (p_FmPcdManipParams->u.hdr.insrtParams.u.generic.replace)
-                tmpReg = (uint32_t)(HMCD_OPCODE_GENERIC_REPLACE) << HMCD_OC_SHIFT;
+                tmpReg = (uint32_t)(HMCD_OPCODE_GENERIC_REPLACE)
+                        << HMCD_OC_SHIFT;
             else
                 tmpReg = (uint32_t)(HMCD_OPCODE_GENERIC_INSRT) << HMCD_OC_SHIFT;
 
-            tmpReg |= p_FmPcdManipParams->u.hdr.insrtParams.u.generic.offset << HMCD_INSRT_OFFSET_SHIFT;
-            tmpReg |= p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size << HMCD_INSRT_SIZE_SHIFT;
+            tmpReg |= p_FmPcdManipParams->u.hdr.insrtParams.u.generic.offset
+                    << HMCD_INSRT_OFFSET_SHIFT;
+            tmpReg |= p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size
+                    << HMCD_INSRT_SIZE_SHIFT;
 
             size = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size;
             p_UsrData = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.p_Data;
@@ -308,7 +536,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
             /* save a pointer to the "last" indication word */
             p_Last = p_TmpHmct;
 
-            p_TmpHmct += HMCD_BASIC_SIZE/4;
+            p_TmpHmct += HMCD_BASIC_SIZE / 4;
 
             /* initialize data to be inserted */
             /* if size is not a multiple of 4, padd with 0's */
@@ -325,232 +553,394 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                 p_LocalData = (uint32_t*)p_UsrData;
 
             /* initialize data and advance pointer to next command */
-            for (i = 0; i<size/4 ; i++, p_TmpHmct += HMCD_BASIC_SIZE/4)
+            for (i = 0; i < size / 4; i++, p_TmpHmct += HMCD_BASIC_SIZE / 4)
                 WRITE_UINT32(*p_TmpHmct, *(p_LocalData+i));
 
             if (remain)
                 XX_Free(p_LocalData);
         }
 
-        else if (p_FmPcdManipParams->u.hdr.insrtParams.type == e_FM_PCD_MANIP_INSRT_BY_HDR)
-        {
-            uint8_t     hmcdOpt;
-            if (!p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.type == e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2)
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+        else
+            if (p_FmPcdManipParams->u.hdr.insrtParams.type
+                    == e_FM_PCD_MANIP_INSRT_BY_HDR)
+            {
+                switch (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.type)
+                {
+                    case (e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2):
+                    {
+                        uint8_t hmcdOpt;
 
-            /* initialize HMCD */
-            tmpReg = (uint32_t)(HMCD_OPCODE_L2_INSRT) << HMCD_OC_SHIFT;
+                        /* initialize HMCD */
+                        tmpReg = (uint32_t)(HMCD_OPCODE_L2_INSRT)
+                                << HMCD_OC_SHIFT;
 
-            switch (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.specificL2)
-            {
-                case (e_FM_PCD_MANIP_HDR_INSRT_MPLS):
-                    if (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.update)
-                        hmcdOpt = HMCD_INSRT_N_UPDATE_L2_MPLS;
-                    else
-                        hmcdOpt = HMCD_INSRT_L2_MPLS;
-                break;
-                default:
-                    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
-            }
-            tmpReg |= hmcdOpt << HMCD_L2_MODE_SHIFT;
+                        switch (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.specificL2)
+                        {
+                            case (e_FM_PCD_MANIP_HDR_INSRT_MPLS):
+                                if (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.update)
+                                    hmcdOpt = HMCD_INSRT_N_UPDATE_L2_MPLS;
+                                else
+                                    hmcdOpt = HMCD_INSRT_L2_MPLS;
+                                break;
+                            default:
+                                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+                        }
+                        tmpReg |= hmcdOpt << HMCD_L2_MODE_SHIFT;
+
+                        WRITE_UINT32(*p_TmpHmct, tmpReg);
+                        /* save a pointer to the "last" indication word */
+                        p_Last = p_TmpHmct;
+
+                        p_TmpHmct += HMCD_BASIC_SIZE / 4;
+
+                        /* set size and pointer of user's data */
+                        size =
+                                (uint8_t)p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.size;
+
+                        ASSERT_COND(p_TmpData);
+                        Mem2IOCpy32(
+                                p_TmpData,
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.p_Data,
+                                size);
+                        tmpReg =
+                                (size << HMCD_INSRT_L2_SIZE_SHIFT)
+                                        | (uint32_t)(XX_VirtToPhys(p_TmpData)
+                                                - (((t_FmPcd*)h_FmPcd)->physicalMuramBase));
+                        WRITE_UINT32(*p_TmpHmct, tmpReg);
+                        p_TmpHmct += HMCD_PTR_SIZE / 4;
+                        p_TmpData += size;
+                    }
+                        break;
+#if (DPAA_VERSION >= 11)
+                    case (e_FM_PCD_MANIP_INSRT_BY_HDR_IP):
+                        tmpReg = (uint32_t)(HMCD_OPCODE_IP_INSRT)
+                                << HMCD_OC_SHIFT;
+                        if (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.ipParams.calcL4Checksum)
+                            tmpReg |= HMCD_IP_L4_CS_CALC;
+                        if (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.ipParams.mappingMode
+                                == e_FM_PCD_MANIP_HDR_QOS_MAPPING_AS_IS)
+                            tmpReg |= HMCD_IP_OR_QOS;
+                        tmpReg |=
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.ipParams.lastPidOffset
+                                        & HMCD_IP_LAST_PID_MASK;
+                        tmpReg |=
+                                ((p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.ipParams.insrt.size
+                                        << HMCD_IP_SIZE_SHIFT)
+                                        & HMCD_IP_SIZE_MASK);
+
+                        WRITE_UINT32(*p_TmpHmct, tmpReg);
+
+                        /* save a pointer to the "last" indication word */
+                        p_Last = p_TmpHmct;
+
+                        p_TmpHmct += HMCD_BASIC_SIZE / 4;
+
+                        /* set IP id */
+                        ASSERT_COND(p_TmpData);
+                        WRITE_UINT16(
+                                *(uint16_t*)p_TmpData,
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.ipParams.id);
+                        WRITE_UINT32(
+                                *p_TmpHmct,
+                                (uint32_t)(XX_VirtToPhys(p_TmpData) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)));
+                        p_TmpData += 2;
+                        p_TmpHmct += HMCD_PTR_SIZE / 4;
+                        p_TmpHmct += HMCD_PARAM_SIZE / 4;
+
+                        Mem2IOCpy32(
+                                p_TmpHmct,
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.ipParams.insrt.p_Data,
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.ipParams.insrt.size);
+                        p_TmpHmct +=
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.ipParams.insrt.size
+                                        / 4;
+                        break;
+                    case (e_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE):
+                        tmpReg = HMCD_INSRT_UDP_LITE;
+                    case (e_FM_PCD_MANIP_INSRT_BY_HDR_UDP):
+                        tmpReg |= (uint32_t)(HMCD_OPCODE_UDP_INSRT)
+                                << HMCD_OC_SHIFT;
+
+                        WRITE_UINT32(*p_TmpHmct, tmpReg);
+
+                        /* save a pointer to the "last" indication word */
+                        p_Last = p_TmpHmct;
+
+                        p_TmpHmct += HMCD_BASIC_SIZE / 4;
+
+                        Mem2IOCpy32(
+                                p_TmpHmct,
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.insrt.p_Data,
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.insrt.size);
+                        p_TmpHmct +=
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.insrt.size
+                                        / 4;
+                        break;
+                    case (e_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP):
+                        tmpReg = (uint32_t)(HMCD_OPCODE_CAPWAP_INSRT)
+                                << HMCD_OC_SHIFT;
+                        tmpReg |= HMCD_CAPWAP_INSRT;
 
-            WRITE_UINT32(*p_TmpHmct, tmpReg);
-            /* save a pointer to the "last" indication word */
-            p_Last = p_TmpHmct;
+                        WRITE_UINT32(*p_TmpHmct, tmpReg);
 
-            p_TmpHmct += HMCD_BASIC_SIZE/4;
+                        /* save a pointer to the "last" indication word */
+                        p_Last = p_TmpHmct;
 
-            /* set size and pointer of user's data */
-            size = (uint8_t)p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.size;
+                        p_TmpHmct += HMCD_BASIC_SIZE / 4;
 
-            ASSERT_COND(p_TmpData);
-            Mem2IOCpy32(p_TmpData, p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.p_Data, size);
-            tmpReg = (size << HMCD_INSRT_L2_SIZE_SHIFT) | (uint32_t)(XX_VirtToPhys(p_TmpData) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase));
-            WRITE_UINT32(*p_TmpHmct, tmpReg);
-            p_TmpHmct += HMCD_PTR_SIZE/4;
-            p_TmpData += size;
-        }
-        else
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("manip header insert type!"));
+                        Mem2IOCpy32(
+                                p_TmpHmct,
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.insrt.p_Data,
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.insrt.size);
+                        p_TmpHmct +=
+                                p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.insrt.size
+                                        / 4;
+                        break;
+#endif /* (DPAA_VERSION >= 11) */
+                    default:
+                        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                                     ("manip header insert by header type!"));
+
+                }
+            }
     }
 
     if (p_FmPcdManipParams->u.hdr.fieldUpdate)
     {
-        switch (p_FmPcdManipParams->u.hdr.fieldUpdateParams.type){
+        switch (p_FmPcdManipParams->u.hdr.fieldUpdateParams.type)
+        {
             case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN):
                 /* set opcode */
-                tmpReg = (uint32_t)(HMCD_OPCODE_VLAN_PRI_UPDATE) << HMCD_OC_SHIFT;
+                tmpReg = (uint32_t)(HMCD_OPCODE_VLAN_PRI_UPDATE)
+                        << HMCD_OC_SHIFT;
 
                 /* set mode & table pointer */
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
-                   e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType
+                        == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
                 {
                     /* set Mode */
-                    tmpReg |= (uint32_t)(HMCD_VLAN_PRI_UPDATE_DSCP_TO_VPRI) << HMCD_VLAN_PRI_REP_MODE_SHIFT;
+                    tmpReg |= (uint32_t)(HMCD_VLAN_PRI_UPDATE_DSCP_TO_VPRI)
+                            << HMCD_VLAN_PRI_REP_MODE_SHIFT;
                     /* set VPRI default */
-                    tmpReg |= p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.vpriDefVal;
+                    tmpReg |=
+                            p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.vpriDefVal;
                     WRITE_UINT32(*p_TmpHmct, tmpReg);
                     /* save a pointer to the "last" indication word */
                     p_Last = p_TmpHmct;
                     /* write the table pointer into the Manip descriptor */
-                    p_TmpHmct += HMCD_BASIC_SIZE/4;
+                    p_TmpHmct += HMCD_BASIC_SIZE / 4;
 
                     tmpReg = 0;
                     ASSERT_COND(p_TmpData);
-                    for (i=0; i<HMCD_DSCP_VALUES; i++)
+                    for (i = 0; i < HMCD_DSCP_VALUES; i++)
                     {
                         /* first we build from each 8 values a 32bit register */
-                        tmpReg |= (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.dscpToVpriTable[i]) << (32-4*(j+1));
+                        tmpReg |=
+                                (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.dscpToVpriTable[i])
+                                        << (32 - 4 * (j + 1));
                         j++;
                         /* Than we write this register to the next table word
                          * (i=7-->word 0, i=15-->word 1,... i=63-->word 7) */
-                        if ((i%8) == 7)
+                        if ((i % 8) == 7)
                         {
-                            WRITE_UINT32(*((uint32_t*)p_TmpData + (i+1)/8-1), tmpReg);
+                            WRITE_UINT32(*((uint32_t*)p_TmpData + (i+1)/8-1),
+                                         tmpReg);
                             tmpReg = 0;
                             j = 0;
                         }
                     }
-                    WRITE_UINT32(*p_TmpHmct, (uint32_t)(XX_VirtToPhys(p_TmpData) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase)));
-                    p_TmpHmct += HMCD_PTR_SIZE/4;
+
+                    WRITE_UINT32(
+                            *p_TmpHmct,
+                            (uint32_t)(XX_VirtToPhys(p_TmpData) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase)));
+                    p_TmpHmct += HMCD_PTR_SIZE / 4;
 
                     p_TmpData += DSCP_TO_VLAN_TABLE_SIZE;
                 }
-                else if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
-                   e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI)
-                {
-                    /* set Mode */
-                    /* line commented out as it has no-side-effect ('0' value). */
-                    /*tmpReg |= HMCD_VLAN_PRI_UPDATE << HMCD_VLAN_PRI_REP_MODE_SHIFT*/;
-                    /* set VPRI parameter */
-                    tmpReg |= p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.u.vpri;
-                    WRITE_UINT32(*p_TmpHmct, tmpReg);
-                    /* save a pointer to the "last" indication word */
-                    p_Last = p_TmpHmct;
-                    p_TmpHmct += HMCD_BASIC_SIZE/4;
-                }
+                else
+                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType
+                            == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI)
+                    {
+                        /* set Mode */
+                        /* line commented out as it has no-side-effect ('0' value). */
+                        /*tmpReg |= HMCD_VLAN_PRI_UPDATE << HMCD_VLAN_PRI_REP_MODE_SHIFT*/;
+                        /* set VPRI parameter */
+                        tmpReg |=
+                                p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.u.vpri;
+                        WRITE_UINT32(*p_TmpHmct, tmpReg);
+                        /* save a pointer to the "last" indication word */
+                        p_Last = p_TmpHmct;
+                        p_TmpHmct += HMCD_BASIC_SIZE / 4;
+                    }
                 break;
 
             case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4):
                 /* set opcode */
                 tmpReg = (uint32_t)(HMCD_OPCODE_IPV4_UPDATE) << HMCD_OC_SHIFT;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_TTL)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV4_TTL)
                     tmpReg |= HMCD_IPV4_UPDATE_TTL;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_TOS)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV4_TOS)
                 {
                     tmpReg |= HMCD_IPV4_UPDATE_TOS;
-                    tmpReg |= p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.tos << HMCD_IPV4_UPDATE_TOS_SHIFT;
+                    tmpReg |=
+                            p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.tos
+                                    << HMCD_IPV4_UPDATE_TOS_SHIFT;
                 }
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_ID)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV4_ID)
                     tmpReg |= HMCD_IPV4_UPDATE_ID;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_SRC)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV4_SRC)
                     tmpReg |= HMCD_IPV4_UPDATE_SRC;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_DST)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV4_DST)
                     tmpReg |= HMCD_IPV4_UPDATE_DST;
                 /* write the first 4 bytes of the descriptor */
                 WRITE_UINT32(*p_TmpHmct, tmpReg);
                 /* save a pointer to the "last" indication word */
                 p_Last = p_TmpHmct;
 
-                p_TmpHmct += HMCD_BASIC_SIZE/4;
+                p_TmpHmct += HMCD_BASIC_SIZE / 4;
 
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_ID)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV4_ID)
                 {
                     ASSERT_COND(p_TmpData);
-                    WRITE_UINT16(*(uint16_t*)p_TmpData, p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.id);
-                    WRITE_UINT32(*p_TmpHmct, (uint32_t)(XX_VirtToPhys(p_TmpData) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)));
+                    WRITE_UINT16(
+                            *(uint16_t*)p_TmpData,
+                            p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.id);
+                    WRITE_UINT32(
+                            *p_TmpHmct,
+                            (uint32_t)(XX_VirtToPhys(p_TmpData) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)));
                     p_TmpData += 2;
-                    p_TmpHmct += HMCD_PTR_SIZE/4;
+                    p_TmpHmct += HMCD_PTR_SIZE / 4;
                 }
 
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_SRC)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV4_SRC)
                 {
-                    WRITE_UINT32(*p_TmpHmct, p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.src);
-                    p_TmpHmct += HMCD_IPV4_ADDR_SIZE/4;
+                    WRITE_UINT32(
+                            *p_TmpHmct,
+                            p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.src);
+                    p_TmpHmct += HMCD_IPV4_ADDR_SIZE / 4;
                 }
 
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_DST)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates
+                        & HDR_MANIP_IPV4_DST)
                 {
-                    WRITE_UINT32(*p_TmpHmct, p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.dst);
-                    p_TmpHmct += HMCD_IPV4_ADDR_SIZE/4;
+                    WRITE_UINT32(
+                            *p_TmpHmct,
+                            p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.dst);
+                    p_TmpHmct += HMCD_IPV4_ADDR_SIZE / 4;
                 }
                 break;
 
             case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6):
                 /* set opcode */
                 tmpReg = (uint32_t)(HMCD_OPCODE_IPV6_UPDATE) << HMCD_OC_SHIFT;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_HL)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates
+                        & HDR_MANIP_IPV6_HL)
                     tmpReg |= HMCD_IPV6_UPDATE_HL;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_TC)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates
+                        & HDR_MANIP_IPV6_TC)
                 {
                     tmpReg |= HMCD_IPV6_UPDATE_TC;
-                    tmpReg |= p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.trafficClass << HMCD_IPV6_UPDATE_TC_SHIFT;
+                    tmpReg |=
+                            p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.trafficClass
+                                    << HMCD_IPV6_UPDATE_TC_SHIFT;
                 }
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_SRC)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates
+                        & HDR_MANIP_IPV6_SRC)
                     tmpReg |= HMCD_IPV6_UPDATE_SRC;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_DST)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates
+                        & HDR_MANIP_IPV6_DST)
                     tmpReg |= HMCD_IPV6_UPDATE_DST;
                 /* write the first 4 bytes of the descriptor */
                 WRITE_UINT32(*p_TmpHmct, tmpReg);
                 /* save a pointer to the "last" indication word */
                 p_Last = p_TmpHmct;
 
-                p_TmpHmct += HMCD_BASIC_SIZE/4;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_SRC)
-                    for (i = 0 ; i < NET_HEADER_FIELD_IPv6_ADDR_SIZE ; i+=4)
+                p_TmpHmct += HMCD_BASIC_SIZE / 4;
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates
+                        & HDR_MANIP_IPV6_SRC)
+                {
+                    for (i = 0; i < NET_HEADER_FIELD_IPv6_ADDR_SIZE; i += 4)
                     {
-                        WRITE_UINT32(*p_TmpHmct, *(uint32_t*)&p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.src[i]);
-                        p_TmpHmct += HMCD_PTR_SIZE/4;
+                        memcpy(&tmp_ipv6_addr,
+                               &p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.src[i],
+                               sizeof(uint32_t));
+                        WRITE_UINT32(*p_TmpHmct, tmp_ipv6_addr);
+                        p_TmpHmct += HMCD_PTR_SIZE / 4;
                     }
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_DST)
-                    for (i = 0 ; i < NET_HEADER_FIELD_IPv6_ADDR_SIZE ; i+=4)
+                }
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates
+                        & HDR_MANIP_IPV6_DST)
+                {
+                    for (i = 0; i < NET_HEADER_FIELD_IPv6_ADDR_SIZE; i += 4)
                     {
-                        WRITE_UINT32(*p_TmpHmct, *(uint32_t*)&p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.dst[i]);
-                        p_TmpHmct += HMCD_PTR_SIZE/4;
+                        memcpy(&tmp_ipv6_addr,
+                               &p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.dst[i],
+                               sizeof(uint32_t));
+                        WRITE_UINT32(*p_TmpHmct, tmp_ipv6_addr);
+                        p_TmpHmct += HMCD_PTR_SIZE / 4;
                     }
+                }
                 break;
 
             case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP):
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates == HDR_MANIP_TCP_UDP_CHECKSUM)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates
+                        == HDR_MANIP_TCP_UDP_CHECKSUM)
                 {
                     /* we implement this case with the update-checksum descriptor */
                     /* set opcode */
-                    tmpReg = (uint32_t)(HMCD_OPCODE_TCP_UDP_CHECKSUM) << HMCD_OC_SHIFT;
+                    tmpReg = (uint32_t)(HMCD_OPCODE_TCP_UDP_CHECKSUM)
+                            << HMCD_OC_SHIFT;
                     /* write the first 4 bytes of the descriptor */
                     WRITE_UINT32(*p_TmpHmct, tmpReg);
                     /* save a pointer to the "last" indication word */
                     p_Last = p_TmpHmct;
 
-                    p_TmpHmct += HMCD_BASIC_SIZE/4;
+                    p_TmpHmct += HMCD_BASIC_SIZE / 4;
                 }
                 else
                 {
                     /* we implement this case with the TCP/UDP update descriptor */
                     /* set opcode */
-                    tmpReg = (uint32_t)(HMCD_OPCODE_TCP_UDP_UPDATE) << HMCD_OC_SHIFT;
-                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_DST)
-                         tmpReg |= HMCD_TCP_UDP_UPDATE_DST;
-                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_SRC)
-                         tmpReg |= HMCD_TCP_UDP_UPDATE_SRC;
+                    tmpReg = (uint32_t)(HMCD_OPCODE_TCP_UDP_UPDATE)
+                            << HMCD_OC_SHIFT;
+                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates
+                            & HDR_MANIP_TCP_UDP_DST)
+                        tmpReg |= HMCD_TCP_UDP_UPDATE_DST;
+                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates
+                            & HDR_MANIP_TCP_UDP_SRC)
+                        tmpReg |= HMCD_TCP_UDP_UPDATE_SRC;
                     /* write the first 4 bytes of the descriptor */
                     WRITE_UINT32(*p_TmpHmct, tmpReg);
                     /* save a pointer to the "last" indication word */
                     p_Last = p_TmpHmct;
 
-                    p_TmpHmct += HMCD_BASIC_SIZE/4;
+                    p_TmpHmct += HMCD_BASIC_SIZE / 4;
 
                     tmpReg = 0;
-                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_SRC)
-                        tmpReg |= ((uint32_t)p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.src) << HMCD_TCP_UDP_UPDATE_SRC_SHIFT;
-                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_DST)
-                        tmpReg |= ((uint32_t)p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.dst);
+                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates
+                            & HDR_MANIP_TCP_UDP_SRC)
+                        tmpReg |=
+                                ((uint32_t)p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.src)
+                                        << HMCD_TCP_UDP_UPDATE_SRC_SHIFT;
+                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates
+                            & HDR_MANIP_TCP_UDP_DST)
+                        tmpReg |=
+                                ((uint32_t)p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.dst);
                     WRITE_UINT32(*p_TmpHmct, tmpReg);
-                    p_TmpHmct += HMCD_PTR_SIZE/4;
+                    p_TmpHmct += HMCD_PTR_SIZE / 4;
                 }
                 break;
 
             default:
-                RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown fieldUpdateParams.type"));
+                RETURN_ERROR(MINOR, E_INVALID_SELECTION,
+                             ("Unknown fieldUpdateParams.type"));
         }
     }
 
@@ -564,73 +954,88 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
 
                 if (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.decTtlHl)
                     tmpReg |= HMCD_IP_REPLACE_TTL_HL;
-                if (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV4_BY_IPV6)
+                if (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType
+                        == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV4_BY_IPV6)
                     /* line commented out as it has no-side-effect ('0' value). */
                     /*tmpReg |= HMCD_IP_REPLACE_REPLACE_IPV4*/;
-                else if (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4)
-                {
-                    tmpReg |= HMCD_IP_REPLACE_REPLACE_IPV6;
-                    if (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.updateIpv4Id)
-                        tmpReg |= HMCD_IP_REPLACE_ID;
-                }
                 else
-                    RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
-                                 ("One flag out of HDR_MANIP_IP_REPLACE_IPV4, HDR_MANIP_IP_REPLACE_IPV6 - must be set."));
+                    if (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType
+                            == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4)
+                    {
+                        tmpReg |= HMCD_IP_REPLACE_REPLACE_IPV6;
+                        if (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.updateIpv4Id)
+                            tmpReg |= HMCD_IP_REPLACE_ID;
+                    }
+                    else
+                        RETURN_ERROR(
+                                MINOR,
+                                E_NOT_SUPPORTED,
+                                ("One flag out of HDR_MANIP_IP_REPLACE_IPV4, HDR_MANIP_IP_REPLACE_IPV6 - must be set."));
 
                 /* write the first 4 bytes of the descriptor */
                 WRITE_UINT32(*p_TmpHmct, tmpReg);
                 /* save a pointer to the "last" indication word */
                 p_Last = p_TmpHmct;
 
-                p_TmpHmct += HMCD_BASIC_SIZE/4;
+                p_TmpHmct += HMCD_BASIC_SIZE / 4;
 
-                size = p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.hdrSize;
+                size =
+                        p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.hdrSize;
                 ASSERT_COND(p_TmpData);
-                Mem2IOCpy32(p_TmpData, p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.hdr, size);
+                Mem2IOCpy32(
+                        p_TmpData,
+                        p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.hdr,
+                        size);
                 tmpReg = (uint32_t)(size << HMCD_IP_REPLACE_L3HDRSIZE_SHIFT);
-                tmpReg |= (uint32_t)(XX_VirtToPhys(p_TmpData) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase));
+                tmpReg |= (uint32_t)(XX_VirtToPhys(p_TmpData)
+                        - (((t_FmPcd*)h_FmPcd)->physicalMuramBase));
                 WRITE_UINT32(*p_TmpHmct, tmpReg);
-                p_TmpHmct += HMCD_PTR_SIZE/4;
+                p_TmpHmct += HMCD_PTR_SIZE / 4;
                 p_TmpData += size;
 
-                if ((p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4) &&
-                        (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.updateIpv4Id))
+                if ((p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType
+                        == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4)
+                        && (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.updateIpv4Id))
                 {
-                    WRITE_UINT16(*(uint16_t*)p_TmpData, p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.id);
-                    WRITE_UINT32(*p_TmpHmct, (uint32_t)(XX_VirtToPhys(p_TmpData) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase)));
+                    WRITE_UINT16(
+                            *(uint16_t*)p_TmpData,
+                            p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.id);
+                    WRITE_UINT32(
+                            *p_TmpHmct,
+                            (uint32_t)(XX_VirtToPhys(p_TmpData) - (((t_FmPcd*)h_FmPcd)->physicalMuramBase)));
                     p_TmpData += 2;
                 }
-                p_TmpHmct += HMCD_PTR_SIZE/4;
-            break;
+                p_TmpHmct += HMCD_PTR_SIZE / 4;
+                break;
             default:
-                RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown customParams.type"));
+                RETURN_ERROR(MINOR, E_INVALID_SELECTION,
+                             ("Unknown customParams.type"));
         }
     }
 
 
-    /* If this node has a nextManip, and no parsing is required after it, the old table must be copied to the new table
+    /* If this node has a nextManip, and no parsing is required, the old table must be copied to the new table
        the old table and should be freed */
     if (p_FmPcdManipParams->h_NextManip &&
-        (MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip)))
+        (MANIP_DONT_REPARSE(p_Manip)))
     {
         if (new)
         {
-        /* If this is the first time this manip is created we need to free unused memory. If it
-         * is a dynamic changes case, the memory used is either the CC shadow or the existing
-         * table - no allocation, no free */
+            /* If this is the first time this manip is created we need to free unused memory. If it
+             * is a dynamic changes case, the memory used is either the CC shadow or the existing
+             * table - no allocation, no free */
             MANIP_UPDATE_UNIFIED_POSITION(p_FmPcdManipParams->h_NextManip);
 
             p_Manip->unifiedPosition = e_MANIP_UNIFIED_FIRST;
 
             /* The HMTD of the next Manip is never going to be used */
             if (((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->muramAllocate)
-                FM_MURAM_FreeMem(((t_FmPcd *)((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_FmPcd)->h_FmMuram, ((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_Ad);
+                FM_MURAM_FreeMem(
+                        ((t_FmPcd *)((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_FmPcd)->h_FmMuram,
+                        ((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_Ad);
             else
                 XX_Free(((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_Ad);
             ((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_Ad = NULL;
-
-            /* advance pointer */
-            p_TmpHmct += MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip)/4;
         }
     }
     else
@@ -643,63 +1048,71 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
     return E_OK;
 }
 
-static t_Error CreateManipActionNew(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams)
+static t_Error CreateManipActionNew(t_FmPcdManip *p_Manip,
+                                    t_FmPcdManipParams *p_FmPcdManipParams)
 {
-    t_FmPcdManip    *p_CurManip;
-    t_Error         err;
-    uint32_t        nextSize = 0, totalSize;
-    uint16_t        tmpReg;
-    uint8_t         *p_OldHmct, *p_TmpHmctPtr, *p_TmpDataPtr;
+    t_FmPcdManip *p_CurManip;
+    t_Error err;
+    uint32_t nextSize = 0, totalSize;
+    uint16_t tmpReg;
+    uint8_t *p_OldHmct, *p_TmpHmctPtr, *p_TmpDataPtr;
 
     /* set Manip structure */
     if (p_FmPcdManipParams->h_NextManip)
     {
-        if (MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip))
+        if (p_FmPcdManipParams->u.hdr.dontParseAfterManip)
             nextSize = (uint32_t)(GetHmctSize(p_FmPcdManipParams->h_NextManip) + GetDataSize(p_FmPcdManipParams->h_NextManip));
         else
             p_Manip->cascadedNext = TRUE;
     }
-    p_Manip->dontParseAfterManip = p_FmPcdManipParams->u.hdr.dontParseAfterManip;
+    p_Manip->dontParseAfterManip =
+            p_FmPcdManipParams->u.hdr.dontParseAfterManip;
 
     /* Allocate new table */
     /* calculate table size according to manip parameters */
-    err = CalculateTableSize(p_FmPcdManipParams, &p_Manip->tableSize, &p_Manip->dataSize);
+    err = CalculateTableSize(p_FmPcdManipParams, &p_Manip->tableSize,
+                             &p_Manip->dataSize);
     if (err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
-    totalSize =(uint16_t)(p_Manip->tableSize + p_Manip->dataSize + nextSize);
+    totalSize = (uint16_t)(p_Manip->tableSize + p_Manip->dataSize + nextSize);
 
-    p_Manip->p_Hmct = (uint8_t*)FM_MURAM_AllocMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, totalSize, 4);
+    p_Manip->p_Hmct = (uint8_t*)FM_MURAM_AllocMem(
+            ((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, totalSize, 4);
     if (!p_Manip->p_Hmct)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc failed"));
 
     if (p_Manip->dataSize)
-        p_Manip->p_Data = (uint8_t*)PTR_MOVE(p_Manip->p_Hmct, (p_Manip->tableSize + nextSize));
+        p_Manip->p_Data =
+                (uint8_t*)PTR_MOVE(p_Manip->p_Hmct, (p_Manip->tableSize + nextSize));
 
     /* update shadow size to allow runtime replacement of Header manipulation */
     /* The allocated shadow is divided as follows:
-       0 . . .       16 . . .
-       --------------------------------
-       |   Shadow   |   Shadow HMTD   |
-       |   HMTD     |   Match Table   |
-       | (16 bytes) | (maximal size)  |
-       --------------------------------
+     0 . . .       16 . . .
+     --------------------------------
+     |   Shadow   |   Shadow HMTD   |
+     |   HMTD     |   Match Table   |
+     | (16 bytes) | (maximal size)  |
+     --------------------------------
      */
 
-    err = FmPcdUpdateCcShadow (p_Manip->h_FmPcd, (uint32_t)(totalSize + 16), (uint16_t)FM_PCD_CC_AD_TABLE_ALIGN);
+    err = FmPcdUpdateCcShadow(p_Manip->h_FmPcd, (uint32_t)(totalSize + 16),
+                              (uint16_t)FM_PCD_CC_AD_TABLE_ALIGN);
     if (err != E_OK)
     {
         FM_MURAM_FreeMem(p_Manip->h_FmPcd, p_Manip->p_Hmct);
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for HdrManip node shadow"));
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("MURAM allocation for HdrManip node shadow"));
     }
 
 
     if (p_FmPcdManipParams->h_NextManip &&
-        (MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip)))
+        (MANIP_DONT_REPARSE(p_Manip)))
     {
-        p_OldHmct = (uint8_t *)GetManipInfo(p_FmPcdManipParams->h_NextManip, e_MANIP_HMCT);
+        p_OldHmct = (uint8_t *)GetManipInfo(p_FmPcdManipParams->h_NextManip,
+                                            e_MANIP_HMCT);
         p_CurManip = p_FmPcdManipParams->h_NextManip;
-       /* Run till the last Manip (which is the first to configure) */
+        /* Run till the last Manip (which is the first to configure) */
         while (MANIP_IS_UNIFIED_NON_LAST(p_CurManip))
             p_CurManip = p_CurManip->h_NextManip;
 
@@ -707,32 +1120,35 @@ static t_Error CreateManipActionNew(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p
         {
             /* If this is a unified table, point to the part of the table
              * which is the relative offset in HMCT.
-            */
+             */
             p_TmpHmctPtr = (uint8_t*)PTR_MOVE(p_Manip->p_Hmct,
-                                              (p_Manip->tableSize +
-                                               (PTR_TO_UINT(p_CurManip->p_Hmct) -
-                                                PTR_TO_UINT(p_OldHmct))));
+                    (p_Manip->tableSize +
+                            (PTR_TO_UINT(p_CurManip->p_Hmct) -
+                                    PTR_TO_UINT(p_OldHmct))));
             if (p_CurManip->p_Data)
                 p_TmpDataPtr = (uint8_t*)PTR_MOVE(p_Manip->p_Hmct,
-                                                  (p_Manip->tableSize +
-                                                   (PTR_TO_UINT(p_CurManip->p_Data) -
-                                                    PTR_TO_UINT(p_OldHmct))));
+                        (p_Manip->tableSize +
+                                (PTR_TO_UINT(p_CurManip->p_Data) -
+                                        PTR_TO_UINT(p_OldHmct))));
             else
                 p_TmpDataPtr = NULL;
 
-            BuildHmct(p_CurManip, &p_CurManip->manipParams, p_TmpHmctPtr, p_TmpDataPtr, FALSE);
+            BuildHmct(p_CurManip, &p_CurManip->manipParams, p_TmpHmctPtr,
+                      p_TmpDataPtr, FALSE);
             /* update old manip table pointer */
             MANIP_SET_HMCT_PTR(p_CurManip, p_TmpHmctPtr);
             MANIP_SET_DATA_PTR(p_CurManip, p_TmpDataPtr);
 
             p_CurManip = p_CurManip->h_PrevManip;
-       }
+        }
         /* We copied the HMCT to create a new large HMCT so we can free the old one */
-        FM_MURAM_FreeMem(MANIP_GET_MURAM(p_FmPcdManipParams->h_NextManip), p_OldHmct);
+        FM_MURAM_FreeMem(MANIP_GET_MURAM(p_FmPcdManipParams->h_NextManip),
+                         p_OldHmct);
     }
 
     /* Fill table */
-    err = BuildHmct(p_Manip, p_FmPcdManipParams, p_Manip->p_Hmct, p_Manip->p_Data, TRUE);
+    err = BuildHmct(p_Manip, p_FmPcdManipParams, p_Manip->p_Hmct,
+                    p_Manip->p_Data, TRUE);
     if (err)
     {
         FM_MURAM_FreeMem(p_Manip->h_FmPcd, p_Manip->p_Hmct);
@@ -746,31 +1162,33 @@ static t_Error CreateManipActionNew(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p
         tmpReg |= HMTD_CFG_PRS_AFTER_HM;
     /* create cascade */
     if (p_FmPcdManipParams->h_NextManip &&
-        !MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip))
+        !MANIP_DONT_REPARSE(p_Manip))
     {
         /* indicate that there's another HM table descriptor */
         tmpReg |= HMTD_CFG_NEXT_AD_EN;
-        WRITE_UINT16(((t_Hmtd *)p_Manip->h_Ad)->nextAdIdx,
-                     (uint16_t)((uint32_t)(XX_VirtToPhys(MANIP_GET_HMTD_PTR(p_FmPcdManipParams->h_NextManip)) -
-                                (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)) >> 4));
+        WRITE_UINT16(
+                ((t_Hmtd *)p_Manip->h_Ad)->nextAdIdx,
+                (uint16_t)((uint32_t)(XX_VirtToPhys(MANIP_GET_HMTD_PTR(p_FmPcdManipParams->h_NextManip)) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)) >> 4));
     }
 
     WRITE_UINT16(((t_Hmtd *)p_Manip->h_Ad)->cfg, tmpReg);
-    WRITE_UINT32(((t_Hmtd *)p_Manip->h_Ad)->hmcdBasePtr,
-                 (uint32_t)(XX_VirtToPhys(p_Manip->p_Hmct) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)));
+    WRITE_UINT32(
+            ((t_Hmtd *)p_Manip->h_Ad)->hmcdBasePtr,
+            (uint32_t)(XX_VirtToPhys(p_Manip->p_Hmct) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)));
 
     WRITE_UINT8(((t_Hmtd *)p_Manip->h_Ad)->opCode, HMAN_OC);
 
     return E_OK;
 }
 
-static t_Error CreateManipActionShadow(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams)
+static t_Error CreateManipActionShadow(t_FmPcdManip *p_Manip,
+                                       t_FmPcdManipParams *p_FmPcdManipParams)
 {
-    uint8_t         *p_WholeHmct, *p_TmpHmctPtr, newDataSize, *p_TmpDataPtr = NULL;
-    uint16_t        newSize;
-    t_FmPcd         *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
-    t_Error         err;
-    t_FmPcdManip    *p_CurManip = p_Manip;
+    uint8_t *p_WholeHmct, *p_TmpHmctPtr, newDataSize, *p_TmpDataPtr = NULL;
+    uint16_t newSize;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
+    t_Error err;
+    t_FmPcdManip *p_CurManip = p_Manip;
 
     err = CalculateTableSize(p_FmPcdManipParams, &newSize, &newDataSize);
     if (err)
@@ -778,29 +1196,45 @@ static t_Error CreateManipActionShadow(t_FmPcdManip *p_Manip, t_FmPcdManipParams
 
     /* check coherency of new table parameters */
     if (newSize > p_Manip->tableSize)
-        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration requires larger size than current one (command table)."));
+        RETURN_ERROR(
+                MINOR,
+                E_INVALID_VALUE,
+                ("New Hdr Manip configuration requires larger size than current one (command table)."));
     if (newDataSize > p_Manip->dataSize)
-        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration requires larger size than current one (data)."));
+        RETURN_ERROR(
+                MINOR,
+                E_INVALID_VALUE,
+                ("New Hdr Manip configuration requires larger size than current one (data)."));
     if (p_FmPcdManipParams->h_NextManip)
-        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration can not contain h_NextManip."));
+        RETURN_ERROR(
+                MINOR, E_INVALID_VALUE,
+                ("New Hdr Manip configuration can not contain h_NextManip."));
     if (MANIP_IS_UNIFIED(p_Manip) && (newSize != p_Manip->tableSize))
-        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration in a chained manipulation requires different size than current one."));
-    if (p_Manip->dontParseAfterManip != p_FmPcdManipParams->u.hdr.dontParseAfterManip)
-        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration differs in dontParseAfterManip value."));
+        RETURN_ERROR(
+                MINOR,
+                E_INVALID_VALUE,
+                ("New Hdr Manip configuration in a chained manipulation requires different size than current one."));
+    if (p_Manip->dontParseAfterManip
+            != p_FmPcdManipParams->u.hdr.dontParseAfterManip)
+        RETURN_ERROR(
+                MINOR,
+                E_INVALID_VALUE,
+                ("New Hdr Manip configuration differs in dontParseAfterManip value."));
 
     p_Manip->tableSize = newSize;
     p_Manip->dataSize = newDataSize;
 
-
     /* Build the new table in the shadow */
     if (!MANIP_IS_UNIFIED(p_Manip))
     {
         p_TmpHmctPtr = (uint8_t*)PTR_MOVE(p_FmPcd->p_CcShadow, 16);
         if (p_Manip->p_Data)
-            p_TmpDataPtr = (uint8_t*)PTR_MOVE(p_TmpHmctPtr,
-                                              (PTR_TO_UINT(p_Manip->p_Data) - PTR_TO_UINT(p_Manip->p_Hmct)));
+            p_TmpDataPtr =
+                    (uint8_t*)PTR_MOVE(p_TmpHmctPtr,
+                            (PTR_TO_UINT(p_Manip->p_Data) - PTR_TO_UINT(p_Manip->p_Hmct)));
 
-        BuildHmct(p_Manip, p_FmPcdManipParams, p_TmpHmctPtr, p_Manip->p_Data, FALSE);
+        BuildHmct(p_Manip, p_FmPcdManipParams, p_TmpHmctPtr, p_Manip->p_Data,
+                  FALSE);
     }
     else
     {
@@ -818,13 +1252,16 @@ static t_Error CreateManipActionShadow(t_FmPcdManip *p_Manip, t_FmPcdManipParams
              * else, point to the beginning of the
              * shadow table (we save 16 for the HMTD.
              */
-            p_TmpHmctPtr = (uint8_t*)PTR_MOVE(p_FmPcd->p_CcShadow,
-                                              (16 + PTR_TO_UINT(p_CurManip->p_Hmct) - PTR_TO_UINT(p_WholeHmct)));
+            p_TmpHmctPtr =
+                    (uint8_t*)PTR_MOVE(p_FmPcd->p_CcShadow,
+                            (16 + PTR_TO_UINT(p_CurManip->p_Hmct) - PTR_TO_UINT(p_WholeHmct)));
             if (p_CurManip->p_Data)
-                p_TmpDataPtr = (uint8_t*)PTR_MOVE(p_FmPcd->p_CcShadow,
-                                                  (16 + PTR_TO_UINT(p_CurManip->p_Data) - PTR_TO_UINT(p_WholeHmct)));
+                p_TmpDataPtr =
+                        (uint8_t*)PTR_MOVE(p_FmPcd->p_CcShadow,
+                                (16 + PTR_TO_UINT(p_CurManip->p_Data) - PTR_TO_UINT(p_WholeHmct)));
 
-            BuildHmct(p_CurManip, &p_CurManip->manipParams, p_TmpHmctPtr, p_TmpDataPtr, FALSE);
+            BuildHmct(p_CurManip, &p_CurManip->manipParams, p_TmpHmctPtr,
+                      p_TmpDataPtr, FALSE);
             p_CurManip = p_CurManip->h_PrevManip;
         }
     }
@@ -832,16 +1269,16 @@ static t_Error CreateManipActionShadow(t_FmPcdManip *p_Manip, t_FmPcdManipParams
     return E_OK;
 }
 
-static t_Error CreateManipActionBackToOrig(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams)
+static t_Error CreateManipActionBackToOrig(
+        t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams)
 {
-    uint8_t         *p_WholeHmct = NULL, *p_TmpHmctPtr, *p_TmpDataPtr;
-    t_FmPcdManip    *p_CurManip = p_Manip;
-
-    UNUSED(p_WholeHmct);
+    uint8_t *p_WholeHmct = NULL, *p_TmpHmctPtr, *p_TmpDataPtr;
+    t_FmPcdManip *p_CurManip = p_Manip;
 
     /* Build the new table in the shadow */
     if (!MANIP_IS_UNIFIED(p_Manip))
-        BuildHmct(p_Manip, p_FmPcdManipParams, p_Manip->p_Hmct, p_Manip->p_Data, FALSE);
+        BuildHmct(p_Manip, p_FmPcdManipParams, p_Manip->p_Hmct, p_Manip->p_Data,
+                  FALSE);
     else
     {
         p_WholeHmct = (uint8_t *)GetManipInfo(p_Manip, e_MANIP_HMCT);
@@ -859,7 +1296,8 @@ static t_Error CreateManipActionBackToOrig(t_FmPcdManip *p_Manip, t_FmPcdManipPa
             p_TmpHmctPtr = p_CurManip->p_Hmct; /*- (uint32_t)p_WholeHmct*/
             p_TmpDataPtr = p_CurManip->p_Data; /*- (uint32_t)p_WholeHmct*/
 
-            BuildHmct(p_CurManip, &p_CurManip->manipParams, p_TmpHmctPtr, p_TmpDataPtr, FALSE);
+            BuildHmct(p_CurManip, &p_CurManip->manipParams, p_TmpHmctPtr,
+                      p_TmpDataPtr, FALSE);
 
             p_CurManip = p_CurManip->h_PrevManip;
         }
@@ -868,77 +1306,86 @@ static t_Error CreateManipActionBackToOrig(t_FmPcdManip *p_Manip, t_FmPcdManipPa
     return E_OK;
 }
 
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
 static t_Error UpdateManipIc(t_Handle h_Manip, uint8_t icOffset)
 {
     t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
-    t_Handle      p_Ad;
-    uint32_t      tmpReg32 = 0;
-    SANITY_CHECK_RETURN_ERROR(h_Manip,E_INVALID_HANDLE);
+    t_Handle p_Ad;
+    uint32_t tmpReg32 = 0;
+    SANITY_CHECK_RETURN_ERROR(h_Manip, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad, E_INVALID_HANDLE);
 
     switch (p_Manip->opcode)
     {
         case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
-            p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
-           if (p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
+        p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+        if (p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
+        {
+            tmpReg32 =
+            *(uint32_t *)&((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets;
+            tmpReg32 |= (uint32_t)((uint32_t)icOffset << 16);
+            *(uint32_t *)&((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets =
+            tmpReg32;
+            p_Manip->updateParams &= ~INTERNAL_CONTEXT_OFFSET;
+            p_Manip->icOffset = icOffset;
+        }
+        else
+        {
+            if (p_Manip->icOffset != icOffset)
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("this manipulation was updated previously by different value"););
+        }
+        break;
+        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        if (p_Manip->h_Frag)
+        {
+            if (p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
             {
-                tmpReg32 = *(uint32_t *)&((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets;
-                tmpReg32 |=  (uint32_t)((uint32_t)icOffset << 16);
-                *(uint32_t *)&((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets = tmpReg32;
+                p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+                tmpReg32 |= GET_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets);
+                tmpReg32 |= (uint32_t)((uint32_t)icOffset << 16);
+                WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets, tmpReg32);
                 p_Manip->updateParams &= ~INTERNAL_CONTEXT_OFFSET;
                 p_Manip->icOffset = icOffset;
             }
             else
             {
                 if (p_Manip->icOffset != icOffset)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("this manipulation was updated previously by different value"););
-            }
-            break;
-#ifdef FM_CAPWAP_SUPPORT
-        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-            if (p_Manip->h_Frag)
-            {
-                if (p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
-                {
-                    p_Ad     = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
-                    tmpReg32 |= GET_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets);
-                    tmpReg32 |=  (uint32_t)((uint32_t)icOffset << 16);
-                    WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets, tmpReg32);
-                    p_Manip->updateParams &= ~INTERNAL_CONTEXT_OFFSET;
-                    p_Manip->icOffset = icOffset;
-                }
-                else
-                {
-                    if (p_Manip->icOffset != icOffset)
-                            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("this manipulation was updated previousely by different value"););
-                }
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("this manipulation was updated previousely by different value"););
             }
-            break;
-#endif /* FM_CAPWAP_SUPPORT */
+        }
+        break;
     }
 
     return E_OK;
 }
 
-static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPort, t_FmPcdManip *p_Manip, t_Handle h_Ad, bool validate)
+static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(
+        t_Handle h_FmPort, t_FmPcdManip *p_Manip, t_Handle h_Ad, bool validate)
 {
 
-    t_AdOfTypeContLookup    *p_Ad         = (t_AdOfTypeContLookup *)h_Ad;
-    t_FmPortGetSetCcParams  fmPortGetSetCcParams;
-    t_Error                 err;
-    uint32_t                tmpReg32;
+    t_AdOfTypeContLookup *p_Ad = (t_AdOfTypeContLookup *)h_Ad;
+    t_FmPortGetSetCcParams fmPortGetSetCcParams;
+    t_Error err;
+    uint32_t tmpReg32;
 
     memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
 
-    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR((p_Manip->opcode & HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX), E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(
+            (p_Manip->opcode & HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX),
+            E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Manip->muramAllocate, E_INVALID_STATE);
 
     if (p_Manip->updateParams)
     {
-        if ((!(p_Manip->updateParams & OFFSET_OF_PR)) ||
-           (p_Manip->shadowUpdateParams & OFFSET_OF_PR))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
+        if ((!(p_Manip->updateParams & OFFSET_OF_PR))
+                || (p_Manip->shadowUpdateParams & OFFSET_OF_PR))
+        RETURN_ERROR(
+                MAJOR, E_INVALID_STATE,
+                ("in this stage parameters from Port has not be updated"));
 
         fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
         fmPortGetSetCcParams.setCcParams.type = UPDATE_PSO;
@@ -946,27 +1393,34 @@ static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPo
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
         if (err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
         if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Parser result offset wasn't configured previousely"));
+        RETURN_ERROR(
+                MAJOR, E_INVALID_STATE,
+                ("Parser result offset wasn't configured previousely"));
 #ifdef FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
         ASSERT_COND(!(fmPortGetSetCcParams.getCcParams.prOffset % 16));
 #endif
     }
-    else if (validate)
+    else
+    if (validate)
     {
-         if ((!(p_Manip->shadowUpdateParams & OFFSET_OF_PR)) ||
-           (p_Manip->updateParams & OFFSET_OF_PR))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
+        if ((!(p_Manip->shadowUpdateParams & OFFSET_OF_PR))
+                || (p_Manip->updateParams & OFFSET_OF_PR))
+        RETURN_ERROR(
+                MAJOR, E_INVALID_STATE,
+                ("in this stage parameters from Port has be updated"));
         fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
         fmPortGetSetCcParams.setCcParams.type = UPDATE_PSO;
         fmPortGetSetCcParams.setCcParams.psoSize = 16;
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
         if (err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
         if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Parser result offset wasn't configured previousely"));
+        RETURN_ERROR(
+                MAJOR, E_INVALID_STATE,
+                ("Parser result offset wasn't configured previousely"));
 
     }
 
@@ -976,76 +1430,80 @@ static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPo
     {
         tmpReg32 = 0;
         tmpReg32 |= fmPortGetSetCcParams.getCcParams.prOffset;
-        WRITE_UINT32(p_Ad->matchTblPtr, (GET_UINT32(p_Ad->matchTblPtr) | tmpReg32));
+        WRITE_UINT32(p_Ad->matchTblPtr,
+                (GET_UINT32(p_Ad->matchTblPtr) | tmpReg32));
         p_Manip->updateParams &= ~OFFSET_OF_PR;
         p_Manip->shadowUpdateParams |= OFFSET_OF_PR;
     }
-    else if (validate)
+    else
+    if (validate)
     {
         tmpReg32 = GET_UINT32(p_Ad->matchTblPtr);
         if ((uint8_t)tmpReg32 != fmPortGetSetCcParams.getCcParams.prOffset)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"););
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_STATE,
+                ("this manipulation was updated previousely by different value"););
     }
 
     return E_OK;
 }
 
-#ifdef FM_CAPWAP_SUPPORT
 static t_Error UpdateModifyCapwapFragmenation(t_FmPcdManip *p_Manip, t_Handle h_Ad, bool validate,t_Handle h_FmTree)
 {
-    t_AdOfTypeContLookup            *p_Ad         = (t_AdOfTypeContLookup *)h_Ad;
-    t_FmPcdCcSavedManipParams       *p_SavedManipParams = NULL;
-    uint32_t                        tmpReg32 = 0;
+    t_AdOfTypeContLookup *p_Ad = (t_AdOfTypeContLookup *)h_Ad;
+    t_FmPcdCcSavedManipParams *p_SavedManipParams = NULL;
+    uint32_t tmpReg32 = 0;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Frag,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->frag,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(((p_Manip->opcode == HMAN_OC_CAPWAP_FRAGMENTATION) || (p_Manip->opcode == HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER)), E_INVALID_STATE);
 
-    p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
 
     if (p_Manip->updateParams)
     {
 
         if ((!(p_Manip->updateParams & OFFSET_OF_DATA)) ||
-           ((p_Manip->shadowUpdateParams & OFFSET_OF_DATA)))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
+                ((p_Manip->shadowUpdateParams & OFFSET_OF_DATA)))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
         p_SavedManipParams = FmPcdCcTreeGetSavedManipParams(h_FmTree);
         if (!p_SavedManipParams)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for this manipulation tree has to be configured previosely with this type"));
-        p_Manip->fragParams.dataOffset = p_SavedManipParams->capwapParams.dataOffset;
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for this manipulation tree has to be configured previosely with this type"));
+        p_Manip->capwapFragParams.dataOffset = p_SavedManipParams->capwapParams.dataOffset;
 
         tmpReg32 = GET_UINT32(p_Ad->pcAndOffsets);
-        tmpReg32 |= ((uint32_t)p_Manip->fragParams.dataOffset<< 16);
+        tmpReg32 |= ((uint32_t)p_Manip->capwapFragParams.dataOffset<< 16);
         WRITE_UINT32(p_Ad->pcAndOffsets,tmpReg32);
 
         p_Manip->updateParams &= ~OFFSET_OF_DATA;
         p_Manip->shadowUpdateParams |= OFFSET_OF_DATA;
     }
-   else if (validate)
-   {
+    else if (validate)
+    {
 
         p_SavedManipParams = FmPcdCcTreeGetSavedManipParams(h_FmTree);
         if (!p_SavedManipParams)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for this manipulation tree has to be configured previosely with this type"));
-        if (p_Manip->fragParams.dataOffset != p_SavedManipParams->capwapParams.dataOffset)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"));
-   }
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for this manipulation tree has to be configured previosely with this type"));
+        if (p_Manip->capwapFragParams.dataOffset != p_SavedManipParams->capwapParams.dataOffset)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"));
+    }
 
     return E_OK;
 }
 
-static t_Error UpdateInitCapwapFragmentation(t_Handle       h_FmPort,
-                                             t_FmPcdManip   *p_Manip,
-                                             t_Handle       h_Ad,
-                                             bool           validate,
-                                             t_Handle       h_FmTree)
+static t_Error UpdateInitCapwapFragmentation(t_Handle h_FmPort,
+        t_FmPcdManip *p_Manip,
+        t_Handle h_Ad,
+        bool validate,
+        t_Handle h_FmTree)
 {
-    t_AdOfTypeContLookup        *p_Ad;
-    t_FmPortGetSetCcParams      fmPortGetSetCcParams;
-    t_Error                     err;
-    uint32_t                    tmpReg32 = 0;
-    t_FmPcdCcSavedManipParams   *p_SavedManipParams;
+    t_AdOfTypeContLookup *p_Ad;
+    t_FmPortGetSetCcParams fmPortGetSetCcParams;
+    t_Error err;
+    uint32_t tmpReg32 = 0;
+    t_FmPcdCcSavedManipParams *p_SavedManipParams;
 
     UNUSED(h_Ad);
 
@@ -1053,15 +1511,15 @@ static t_Error UpdateInitCapwapFragmentation(t_Handle       h_FmPort,
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Frag,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->frag,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(((p_Manip->opcode == HMAN_OC_CAPWAP_FRAGMENTATION) ||
-                               (p_Manip->opcode == HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER)), E_INVALID_STATE);
+                    (p_Manip->opcode == HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER)), E_INVALID_STATE);
 
-    p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
 
     if (p_Manip->updateParams)
     {
         if ((!(p_Manip->updateParams & OFFSET_OF_DATA)) ||
-            ((p_Manip->shadowUpdateParams & OFFSET_OF_DATA)))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
+                ((p_Manip->shadowUpdateParams & OFFSET_OF_DATA)))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
         fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN | UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY;
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_POP_TO_N_STEP | NIA_ENG_FM_CTL;
@@ -1070,10 +1528,10 @@ static t_Error UpdateInitCapwapFragmentation(t_Handle       h_FmPort,
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
         if (err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
         if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Data offset wasn't configured previousely"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Data offset wasn't configured previousely"));
 
         p_SavedManipParams = (t_FmPcdCcSavedManipParams *)XX_Malloc(sizeof(t_FmPcdCcSavedManipParams));
         p_SavedManipParams->capwapParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
@@ -1087,17 +1545,17 @@ static t_Error UpdateInitCapwapFragmentation(t_Handle       h_FmPort,
     else if (validate)
     {
         if ((!(p_Manip->shadowUpdateParams & OFFSET_OF_DATA)) ||
-            ((p_Manip->updateParams & OFFSET_OF_DATA)))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
+                ((p_Manip->updateParams & OFFSET_OF_DATA)))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
         fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN | UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY;
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_POP_TO_N_STEP | NIA_ENG_FM_CTL;
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
         if (err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
         if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Data offset wasn't configured previousely"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Data offset wasn't configured previousely"));
     }
 
     if (p_Manip->updateParams)
@@ -1108,31 +1566,31 @@ static t_Error UpdateInitCapwapFragmentation(t_Handle       h_FmPort,
 
         p_Manip->updateParams &= ~OFFSET_OF_DATA;
         p_Manip->shadowUpdateParams |= OFFSET_OF_DATA;
-        p_Manip->fragParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
+        p_Manip->capwapFragParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
     }
     else if (validate)
     {
-        if (p_Manip->fragParams.dataOffset != fmPortGetSetCcParams.getCcParams.dataOffset)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"));
+        if (p_Manip->capwapFragParams.dataOffset != fmPortGetSetCcParams.getCcParams.dataOffset)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"));
     }
 
     return E_OK;
 }
 
-static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
-                                     t_Handle      h_FmPort,
-                                     t_FmPcdManip  *p_Manip,
-                                     t_Handle      h_Ad,
-                                     bool          validate)
+static t_Error UpdateInitCapwapReasm(t_Handle h_FmPcd,
+        t_Handle h_FmPort,
+        t_FmPcdManip *p_Manip,
+        t_Handle h_Ad,
+        bool validate)
 {
-    t_CapwapReasmPram                   *p_ReassmTbl;
-    t_Error                             err;
-    t_FmPortGetSetCcParams              fmPortGetSetCcParams;
-    uint8_t                             i = 0;
-    uint16_t                            size;
-    uint32_t                            tmpReg32;
-    t_FmPcd                             *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_FmPcdCcCapwapReassmTimeoutParams  ccCapwapReassmTimeoutParams;
+    t_CapwapReasmPram *p_ReassmTbl;
+    t_Error err;
+    t_FmPortGetSetCcParams fmPortGetSetCcParams;
+    uint8_t i = 0;
+    uint16_t size;
+    uint32_t tmpReg32;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdCcCapwapReassmTimeoutParams ccCapwapReassmTimeoutParams;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Frag,E_INVALID_HANDLE);
@@ -1142,24 +1600,24 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc,E_INVALID_HANDLE);
 
     if (p_Manip->h_FmPcd != h_FmPcd)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE,
-                     ("handler of PCD previously was initiated by different value"));
+    RETURN_ERROR(MAJOR, E_INVALID_STATE,
+            ("handler of PCD previously was initiated by different value"));
 
     UNUSED(h_Ad);
 
     memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
-    p_ReassmTbl  = (t_CapwapReasmPram *)p_Manip->h_Frag;
+    p_ReassmTbl = (t_CapwapReasmPram *)p_Manip->h_Frag;
 
     if (p_Manip->updateParams)
     {
         if ((!(p_Manip->updateParams & NUM_OF_TASKS) &&
-             !(p_Manip->updateParams & OFFSET_OF_DATA) &&
-             !(p_Manip->updateParams & OFFSET_OF_PR) &&
-             !(p_Manip->updateParams & HW_PORT_ID)) ||
-            ((p_Manip->shadowUpdateParams & NUM_OF_TASKS) ||
-             (p_Manip->shadowUpdateParams & OFFSET_OF_DATA) || (p_Manip->shadowUpdateParams & OFFSET_OF_PR) ||
-             (p_Manip->shadowUpdateParams & HW_PORT_ID)))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
+                        !(p_Manip->updateParams & OFFSET_OF_DATA) &&
+                        !(p_Manip->updateParams & OFFSET_OF_PR) &&
+                        !(p_Manip->updateParams & HW_PORT_ID)) ||
+                ((p_Manip->shadowUpdateParams & NUM_OF_TASKS) ||
+                        (p_Manip->shadowUpdateParams & OFFSET_OF_DATA) || (p_Manip->shadowUpdateParams & OFFSET_OF_PR) ||
+                        (p_Manip->shadowUpdateParams & HW_PORT_ID)))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
 
         fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN;
@@ -1167,28 +1625,28 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
         if (err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
         if (fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Num of tasks wasn't configured previousely"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Num of tasks wasn't configured previousely"));
         if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data  wasn't configured previousely"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data  wasn't configured previousely"));
         if (fmPortGetSetCcParams.getCcParams.type & HW_PORT_ID)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("hwPortId wasn't updated"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("hwPortId wasn't updated"));
 #ifdef FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
         ASSERT_COND((fmPortGetSetCcParams.getCcParams.dataOffset % 16) == 0);
 #endif /* FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004 */
     }
     else if (validate)
     {
-         if ((!(p_Manip->shadowUpdateParams & NUM_OF_TASKS) &&
-              !(p_Manip->shadowUpdateParams & OFFSET_OF_DATA) &&
-              !(p_Manip->shadowUpdateParams & OFFSET_OF_PR) &&
-              !(p_Manip->shadowUpdateParams & HW_PORT_ID)) &&
-             ((p_Manip->updateParams & NUM_OF_TASKS) ||
-              (p_Manip->updateParams & OFFSET_OF_DATA) || (p_Manip->updateParams & OFFSET_OF_PR) ||
-              (p_Manip->updateParams & HW_PORT_ID)))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
+        if ((!(p_Manip->shadowUpdateParams & NUM_OF_TASKS) &&
+                        !(p_Manip->shadowUpdateParams & OFFSET_OF_DATA) &&
+                        !(p_Manip->shadowUpdateParams & OFFSET_OF_PR) &&
+                        !(p_Manip->shadowUpdateParams & HW_PORT_ID)) &&
+                ((p_Manip->updateParams & NUM_OF_TASKS) ||
+                        (p_Manip->updateParams & OFFSET_OF_DATA) || (p_Manip->updateParams & OFFSET_OF_PR) ||
+                        (p_Manip->updateParams & HW_PORT_ID)))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
 
         fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN;
@@ -1196,14 +1654,14 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
         if (err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
         if (fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("NumOfTasks wasn't configured previously"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("NumOfTasks wasn't configured previously"));
         if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data  wasn't configured previously"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data  wasn't configured previously"));
         if (fmPortGetSetCcParams.getCcParams.type & HW_PORT_ID)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("hwPortId wasn't updated"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("hwPortId wasn't updated"));
     }
 
     if (p_Manip->updateParams)
@@ -1211,57 +1669,57 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
         if (p_Manip->updateParams & NUM_OF_TASKS)
         {
             /*recommendation of Microcode team - (maxNumFramesInProcess * 2) */
-            size = (uint16_t)(p_Manip->fragParams.maxNumFramesInProcess*2 + fmPortGetSetCcParams.getCcParams.numOfTasks);
-            if (size  > 255)
-                RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("numOfOpenReassmEntries + numOfTasks per port can not be greater than 256"));
+            size = (uint16_t)(p_Manip->capwapFragParams.maxNumFramesInProcess*2 + fmPortGetSetCcParams.getCcParams.numOfTasks);
+            if (size > 255)
+            RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("numOfOpenReassmEntries + numOfTasks per port can not be greater than 256"));
 
-            p_Manip->fragParams.numOfTasks = fmPortGetSetCcParams.getCcParams.numOfTasks;
+            p_Manip->capwapFragParams.numOfTasks = fmPortGetSetCcParams.getCcParams.numOfTasks;
 
             /*p_ReassmFrmDescrIndxPoolTbl*/
-            p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl =
-                (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                            (uint32_t)(size + 1),
-                                            4);
-            if (!p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl)
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly frame buffer index pool table"));
+            p_Manip->capwapFragParams.p_ReassmFrmDescrIndxPoolTbl =
+            (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                    (uint32_t)(size + 1),
+                    4);
+            if (!p_Manip->capwapFragParams.p_ReassmFrmDescrIndxPoolTbl)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly frame buffer index pool table"));
 
-            IOMemSet32(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl, 0,  (uint32_t)(size + 1));
+            IOMemSet32(p_Manip->capwapFragParams.p_ReassmFrmDescrIndxPoolTbl, 0, (uint32_t)(size + 1));
 
             for ( i = 0; i < size; i++)
-                WRITE_UINT8(*(uint8_t *)PTR_MOVE(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl, i), (uint8_t)(i+1));
+            WRITE_UINT8(*(uint8_t *)PTR_MOVE(p_Manip->capwapFragParams.p_ReassmFrmDescrIndxPoolTbl, i), (uint8_t)(i+1));
 
-            tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl) - p_FmPcd->physicalMuramBase);
+            tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->capwapFragParams.p_ReassmFrmDescrIndxPoolTbl) - p_FmPcd->physicalMuramBase);
 
             WRITE_UINT32(p_ReassmTbl->reasmFrmDescIndexPoolTblPtr, tmpReg32);
 
             /*p_ReassmFrmDescrPoolTbl*/
-            p_Manip->fragParams.p_ReassmFrmDescrPoolTbl =
-                (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                            (uint32_t)((size + 1) * FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE),
-                                            4);
+            p_Manip->capwapFragParams.p_ReassmFrmDescrPoolTbl =
+            (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                    (uint32_t)((size + 1) * FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE),
+                    4);
 
-           if (!p_Manip->fragParams.p_ReassmFrmDescrPoolTbl)
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly frame buffer pool table"));
+            if (!p_Manip->capwapFragParams.p_ReassmFrmDescrPoolTbl)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly frame buffer pool table"));
 
-            IOMemSet32(p_Manip->fragParams.p_ReassmFrmDescrPoolTbl, 0,  (uint32_t)((size +1)* FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE));
+            IOMemSet32(p_Manip->capwapFragParams.p_ReassmFrmDescrPoolTbl, 0, (uint32_t)((size +1)* FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE));
 
-            tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_ReassmFrmDescrPoolTbl) - p_FmPcd->physicalMuramBase);
+            tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->capwapFragParams.p_ReassmFrmDescrPoolTbl) - p_FmPcd->physicalMuramBase);
 
             WRITE_UINT32(p_ReassmTbl->reasmFrmDescPoolTblPtr, tmpReg32);
 
             /*p_TimeOutTbl*/
 
-            p_Manip->fragParams.p_TimeOutTbl =
-                (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                            (uint32_t)((size + 1)* FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE),
-                                            4);
+            p_Manip->capwapFragParams.p_TimeOutTbl =
+            (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                    (uint32_t)((size + 1)* FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE),
+                    4);
 
-            if (!p_Manip->fragParams.p_TimeOutTbl)
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly timeout table"));
+            if (!p_Manip->capwapFragParams.p_TimeOutTbl)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly timeout table"));
 
-            IOMemSet32(p_Manip->fragParams.p_TimeOutTbl, 0,  (uint16_t)((size + 1)*FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE));
+            IOMemSet32(p_Manip->capwapFragParams.p_TimeOutTbl, 0, (uint16_t)((size + 1)*FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE));
 
-            tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_TimeOutTbl) - p_FmPcd->physicalMuramBase);
+            tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->capwapFragParams.p_TimeOutTbl) - p_FmPcd->physicalMuramBase);
             WRITE_UINT32(p_ReassmTbl->timeOutTblPtr, tmpReg32);
 
             p_Manip->updateParams &= ~NUM_OF_TASKS;
@@ -1270,9 +1728,9 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
 
         if (p_Manip->updateParams & OFFSET_OF_DATA)
         {
-            p_Manip->fragParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
+            p_Manip->capwapFragParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
             tmpReg32 = GET_UINT32(p_ReassmTbl->mode);
-            tmpReg32|= p_Manip->fragParams.dataOffset;
+            tmpReg32|= p_Manip->capwapFragParams.dataOffset;
             WRITE_UINT32(p_ReassmTbl->mode, tmpReg32);
             p_Manip->updateParams &= ~OFFSET_OF_DATA;
             p_Manip->shadowUpdateParams |= OFFSET_OF_DATA;
@@ -1280,83 +1738,87 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
 
         if (!(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR))
         {
-            p_Manip->fragParams.prOffset = fmPortGetSetCcParams.getCcParams.prOffset;
+            p_Manip->capwapFragParams.prOffset = fmPortGetSetCcParams.getCcParams.prOffset;
 
             tmpReg32 = GET_UINT32(p_ReassmTbl->mode);
             tmpReg32|= FM_PCD_MANIP_CAPWAP_REASM_PR_COPY;
             WRITE_UINT32(p_ReassmTbl->mode, tmpReg32);
 
             tmpReg32 = GET_UINT32(p_ReassmTbl->intStatsTblPtr);
-            tmpReg32 |= (uint32_t)p_Manip->fragParams.prOffset << 24;
+            tmpReg32 |= (uint32_t)p_Manip->capwapFragParams.prOffset << 24;
             WRITE_UINT32(p_ReassmTbl->intStatsTblPtr, tmpReg32);
-           p_Manip->updateParams &= ~OFFSET_OF_PR;
-           p_Manip->shadowUpdateParams |= OFFSET_OF_PR;
-       }
-       else
-       {
-           p_Manip->fragParams.prOffset = 0xff;
-           p_Manip->updateParams &= ~OFFSET_OF_PR;
-           p_Manip->shadowUpdateParams |= OFFSET_OF_PR;
-       }
-
-       p_Manip->fragParams.hwPortId = fmPortGetSetCcParams.getCcParams.hardwarePortId;
-       p_Manip->updateParams &= ~HW_PORT_ID;
-       p_Manip->shadowUpdateParams |= HW_PORT_ID;
+            p_Manip->updateParams &= ~OFFSET_OF_PR;
+            p_Manip->shadowUpdateParams |= OFFSET_OF_PR;
+        }
+        else
+        {
+            p_Manip->capwapFragParams.prOffset = 0xff;
+            p_Manip->updateParams &= ~OFFSET_OF_PR;
+            p_Manip->shadowUpdateParams |= OFFSET_OF_PR;
+        }
+
+        p_Manip->capwapFragParams.hwPortId = fmPortGetSetCcParams.getCcParams.hardwarePortId;
+        p_Manip->updateParams &= ~HW_PORT_ID;
+        p_Manip->shadowUpdateParams |= HW_PORT_ID;
 
         /*timeout hc */
-       ccCapwapReassmTimeoutParams.fqidForTimeOutFrames = p_Manip->fragParams.fqidForTimeOutFrames;
-       ccCapwapReassmTimeoutParams.portIdAndCapwapReassmTbl = (uint32_t)p_Manip->fragParams.hwPortId << 24;
-       ccCapwapReassmTimeoutParams.portIdAndCapwapReassmTbl |= (uint32_t)((XX_VirtToPhys(p_ReassmTbl) - p_FmPcd->physicalMuramBase));
-       ccCapwapReassmTimeoutParams.timeoutRequestTime = (((uint32_t)1<<p_Manip->fragParams.bitFor1Micro) * p_Manip->fragParams.timeoutRoutineRequestTime)/2;
-       return FmHcPcdCcCapwapTimeoutReassm(p_FmPcd->h_Hc,&ccCapwapReassmTimeoutParams);
+        ccCapwapReassmTimeoutParams.fqidForTimeOutFrames = p_Manip->capwapFragParams.fqidForTimeOutFrames;
+        ccCapwapReassmTimeoutParams.portIdAndCapwapReassmTbl = (uint32_t)p_Manip->capwapFragParams.hwPortId << 24;
+        ccCapwapReassmTimeoutParams.portIdAndCapwapReassmTbl |= (uint32_t)((XX_VirtToPhys(p_ReassmTbl) - p_FmPcd->physicalMuramBase));
+        ccCapwapReassmTimeoutParams.timeoutRequestTime = (((uint32_t)1<<p_Manip->capwapFragParams.bitFor1Micro) * p_Manip->capwapFragParams.timeoutRoutineRequestTime)/2;
+        return FmHcPcdCcCapwapTimeoutReassm(p_FmPcd->h_Hc,&ccCapwapReassmTimeoutParams);
     }
 
     else if (validate)
     {
-        if (fmPortGetSetCcParams.getCcParams.hardwarePortId != p_Manip->fragParams.hwPortId)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Reassembly manipulation previously was assigned to another port"));
-        if (fmPortGetSetCcParams.getCcParams.numOfTasks != p_Manip->fragParams.numOfTasks)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfTasks for this manipulation previously was defined by another value "));
-
+        if (fmPortGetSetCcParams.getCcParams.hardwarePortId != p_Manip->capwapFragParams.hwPortId)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Reassembly manipulation previously was assigned to another port"));
+        if (fmPortGetSetCcParams.getCcParams.numOfTasks != p_Manip->capwapFragParams.numOfTasks)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfTasks for this manipulation previously was defined by another value "));
 
         if (!(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR))
         {
-            if (p_Manip->fragParams.prOffset != fmPortGetSetCcParams.getCcParams.prOffset)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));
+            if (p_Manip->capwapFragParams.prOffset != fmPortGetSetCcParams.getCcParams.prOffset)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));
         }
         else
         {
-            if (p_Manip->fragParams.prOffset != 0xff)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));
+            if (p_Manip->capwapFragParams.prOffset != 0xff)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));
         }
-        if (fmPortGetSetCcParams.getCcParams.dataOffset != p_Manip->fragParams.dataOffset)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Data offset previously was defined by another value "));
+        if (fmPortGetSetCcParams.getCcParams.dataOffset != p_Manip->capwapFragParams.dataOffset)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Data offset previously was defined by another value "));
     }
 
     return E_OK;
 }
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
 
-t_Error FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTbl)
+t_Error FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_ReasmCommonPramTbl)
 {
-    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdCcIpReassmTimeoutParams  ccIpReassmTimeoutParams = {0};
-    t_Error                         err = E_OK;
-    uint8_t                         result;
-    uint32_t                        bitFor1Micro, tsbs, log2num;
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdCcReassmTimeoutParams ccReassmTimeoutParams = { 0 };
+    t_Error err = E_OK;
+    uint8_t result;
+    uint32_t bitFor1Micro, tsbs, log2num;
 
     ASSERT_COND(p_FmPcd);
-    ASSERT_COND(h_IpReasmCommonPramTbl);
+    ASSERT_COND(h_ReasmCommonPramTbl);
 
     bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
+    if (bitFor1Micro == 0)
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Timestamp scale"));
+
     bitFor1Micro = 32 - bitFor1Micro;
-    LOG2(FM_PCD_MANIP_IP_REASSM_TIMEOUT_THREAD_THRESH, log2num);
+    LOG2(FM_PCD_MANIP_REASM_TIMEOUT_THREAD_THRESH, log2num);
     tsbs = bitFor1Micro - log2num;
 
-    ccIpReassmTimeoutParams.iprcpt      = (uint32_t)(XX_VirtToPhys(h_IpReasmCommonPramTbl) - p_FmPcd->physicalMuramBase);
-    ccIpReassmTimeoutParams.tsbs        = (uint8_t)tsbs;
-    ccIpReassmTimeoutParams.activate    = TRUE;
-    if ((err = FmHcPcdCcIpTimeoutReassm(p_FmPcd->h_Hc, &ccIpReassmTimeoutParams, &result)) != E_OK)
+    ccReassmTimeoutParams.iprcpt = (uint32_t)(XX_VirtToPhys(
+            h_ReasmCommonPramTbl) - p_FmPcd->physicalMuramBase);
+    ccReassmTimeoutParams.tsbs = (uint8_t)tsbs;
+    ccReassmTimeoutParams.activate = TRUE;
+    if ((err = FmHcPcdCcTimeoutReassm(p_FmPcd->h_Hc, &ccReassmTimeoutParams,
+                                      &result)) != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     switch (result)
@@ -1366,9 +1828,12 @@ t_Error FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTb
         case (1):
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("failed to allocate TNUM"));
         case (2):
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("failed to allocate internal buffer from the HC-Port"));
+            RETURN_ERROR(
+                    MAJOR, E_NO_MEMORY,
+                    ("failed to allocate internal buffer from the HC-Port"));
         case (3):
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("'Disable Timeout Task' with invalid IPRCPT"));
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                         ("'Disable Timeout Task' with invalid IPRCPT"));
         case (4):
             RETURN_ERROR(MAJOR, E_FULL, ("too many timeout tasks"));
         case (5):
@@ -1379,137 +1844,192 @@ t_Error FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTb
     return E_OK;
 }
 
-static t_Error CreateIpReassCommonTable(t_FmPcdManip *p_Manip)
+static t_Error CreateReassCommonTable(t_FmPcdManip *p_Manip)
 {
-    uint32_t    tmpReg32 = 0, i;
-    uint64_t    tmpReg64, size;
-    t_FmPcd     *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
-    t_Error     err = E_OK;
+    uint32_t tmpReg32 = 0, i, bitFor1Micro;
+    uint64_t tmpReg64, size;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
+    t_Error err = E_OK;
+
+    bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
+    if (bitFor1Micro == 0)
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Timestamp scale"));
 
-    /* Allocation of the IP Reassembly Common Parameters table. This table is located in the
-    MURAM. Its size is 64 bytes and its base address should be 8-byte aligned.
-    It contains parameters that are common to both the IPv4 reassembly function and IPv6
-    reassembly function.*/
-    p_Manip->ipReassmParams.p_IpReassCommonTbl =
-        (t_IpReassCommonTbl *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                                FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_SIZE,
-                                                FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_ALIGN);
+    /* Allocation of the Reassembly Common Parameters table. This table is located in the
+     MURAM. Its size is 64 bytes and its base address should be 8-byte aligned. */
+    p_Manip->reassmParams.p_ReassCommonTbl =
+            (t_ReassCommonTbl *)FM_MURAM_AllocMem(
+                    p_FmPcd->h_FmMuram,
+                    FM_PCD_MANIP_REASM_COMMON_PARAM_TABLE_SIZE,
+                    FM_PCD_MANIP_REASM_COMMON_PARAM_TABLE_ALIGN);
 
-    if (!p_Manip->ipReassmParams.p_IpReassCommonTbl)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly common parameters table"));
+    if (!p_Manip->reassmParams.p_ReassCommonTbl)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("MURAM alloc for Reassembly common parameters table"));
 
-    IOMemSet32(p_Manip->ipReassmParams.p_IpReassCommonTbl, 0,  FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_SIZE);
+    IOMemSet32(p_Manip->reassmParams.p_ReassCommonTbl, 0,
+               FM_PCD_MANIP_REASM_COMMON_PARAM_TABLE_SIZE);
 
     /* Setting the TimeOut Mode.*/
     tmpReg32 = 0;
-    if (p_Manip->ipReassmParams.timeOutMode == e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES)
-        tmpReg32 |= FM_PCD_MANIP_IP_REASM_TIME_OUT_BETWEEN_FRAMES;
+    if (p_Manip->reassmParams.timeOutMode
+            == e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES)
+        tmpReg32 |= FM_PCD_MANIP_REASM_TIME_OUT_BETWEEN_FRAMES;
 
     /* Setting TimeOut FQID - Frames that time out are enqueued to this FQID.
-    In order to cause TimeOut frames to be discarded, this queue should be configured accordingly*/
-    tmpReg32 |= p_Manip->ipReassmParams.fqidForTimeOutFrames;
-    WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->timeoutModeAndFqid, tmpReg32);
+     In order to cause TimeOut frames to be discarded, this queue should be configured accordingly*/
+    tmpReg32 |= p_Manip->reassmParams.fqidForTimeOutFrames;
+    WRITE_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->timeoutModeAndFqid,
+                 tmpReg32);
 
     /* Calculation the size of IP Reassembly Frame Descriptor - number of frames that are allowed to be reassembled simultaneously + 129.*/
-    size = p_Manip->ipReassmParams.maxNumFramesInProcess + 129;
+    size = p_Manip->reassmParams.maxNumFramesInProcess + 129;
 
     /*Allocation of IP Reassembly Frame Descriptor Indexes Pool - This pool resides in the MURAM */
-    p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr =
-         PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                       (uint32_t)(size * 2),
-                                       256));
-    if (!p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly frame descriptor indexes pool"));
-
-    IOMemSet32(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr), 0,  (uint32_t)(size * 2));
+    p_Manip->reassmParams.reassFrmDescrIndxPoolTblAddr =
+            PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                            (uint32_t)(size * 2),
+                            256));
+    if (!p_Manip->reassmParams.reassFrmDescrIndxPoolTblAddr)
+        RETURN_ERROR(
+                MAJOR, E_NO_MEMORY,
+                ("MURAM alloc for Reassembly frame descriptor indexes pool"));
+
+    IOMemSet32(UINT_TO_PTR(p_Manip->reassmParams.reassFrmDescrIndxPoolTblAddr),
+               0, (uint32_t)(size * 2));
 
     /* The entries in IP Reassembly Frame Descriptor Indexes Pool contains indexes starting with 1 up to
-    the maximum number of frames that are allowed to be reassembled simultaneously + 128.
-    The last entry in this pool must contain the index zero*/
-    for (i=0; i<(size-1); i++)
-        WRITE_UINT16(*(uint16_t *)PTR_MOVE(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr), (i<<1)),
-                     (uint16_t)(i+1));
+     the maximum number of frames that are allowed to be reassembled simultaneously + 128.
+     The last entry in this pool must contain the index zero*/
+    for (i = 0; i < (size - 1); i++)
+        WRITE_UINT16(
+                *(uint16_t *)PTR_MOVE(UINT_TO_PTR(p_Manip->reassmParams.reassFrmDescrIndxPoolTblAddr), (i<<1)),
+                (uint16_t)(i+1));
 
     /* Sets the IP Reassembly Frame Descriptor Indexes Pool offset from MURAM */
-    tmpReg32 = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr)) - p_FmPcd->physicalMuramBase);
-    WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->reassFrmDescIndexPoolTblPtr, tmpReg32);
+    tmpReg32 = (uint32_t)(XX_VirtToPhys(
+            UINT_TO_PTR(p_Manip->reassmParams.reassFrmDescrIndxPoolTblAddr))
+            - p_FmPcd->physicalMuramBase);
+    WRITE_UINT32(
+            p_Manip->reassmParams.p_ReassCommonTbl->reassFrmDescIndexPoolTblPtr,
+            tmpReg32);
 
     /* Allocation of the Reassembly Frame Descriptors Pool - This pool resides in external memory.
-    The number of entries in this pool should be equal to the number of entries in IP Reassembly Frame Descriptor Indexes Pool.*/
-    p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr =
-        PTR_TO_UINT(XX_MallocSmart((uint32_t)(size * 64), p_Manip->ipReassmParams.dataMemId, 64));
+     The number of entries in this pool should be equal to the number of entries in IP Reassembly Frame Descriptor Indexes Pool.*/
+    p_Manip->reassmParams.reassFrmDescrPoolTblAddr =
+            PTR_TO_UINT(XX_MallocSmart((uint32_t)(size * 64), p_Manip->reassmParams.dataMemId, 64));
 
-    if (!p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr)
+    if (!p_Manip->reassmParams.reassFrmDescrPoolTblAddr)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
 
-    IOMemSet32(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr), 0,  (uint32_t)(size * 64));
+    IOMemSet32(UINT_TO_PTR(p_Manip->reassmParams.reassFrmDescrPoolTblAddr), 0,
+               (uint32_t)(size * 64));
 
     /* Sets the Reassembly Frame Descriptors Pool and liodn offset*/
-    tmpReg64 = (uint64_t)(XX_VirtToPhys(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr)));
-    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT);
-    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT);
-    WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->liodnAndReassFrmDescPoolPtrHi, (uint32_t)(tmpReg64 >> 32));
-    WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->reassFrmDescPoolPtrLow, (uint32_t)tmpReg64);
+    tmpReg64 = (uint64_t)(XX_VirtToPhys(
+            UINT_TO_PTR(p_Manip->reassmParams.reassFrmDescrPoolTblAddr)));
+    tmpReg64 |= ((uint64_t)(p_Manip->reassmParams.dataLiodnOffset
+            & FM_PCD_MANIP_REASM_LIODN_MASK)
+            << (uint64_t)FM_PCD_MANIP_REASM_LIODN_SHIFT);
+    tmpReg64 |= ((uint64_t)(p_Manip->reassmParams.dataLiodnOffset
+            & FM_PCD_MANIP_REASM_ELIODN_MASK)
+            << (uint64_t)FM_PCD_MANIP_REASM_ELIODN_SHIFT);
+    WRITE_UINT32(
+            p_Manip->reassmParams.p_ReassCommonTbl->liodnAndReassFrmDescPoolPtrHi,
+            (uint32_t)(tmpReg64 >> 32));
+    WRITE_UINT32(
+            p_Manip->reassmParams.p_ReassCommonTbl->reassFrmDescPoolPtrLow,
+            (uint32_t)tmpReg64);
 
     /*Allocation of the TimeOut table - This table resides in the MURAM.
-    The number of entries in this table is identical to the number of entries in the Reassembly Frame Descriptors Pool*/
-    p_Manip->ipReassmParams.timeOutTblAddr =
-        PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram, (uint32_t)(size  * 8),8));
+     The number of entries in this table is identical to the number of entries in the Reassembly Frame Descriptors Pool*/
+    p_Manip->reassmParams.timeOutTblAddr =
+            PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram, (uint32_t)(size * 8),8));
 
-    if (!p_Manip->ipReassmParams.timeOutTblAddr)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly timeout table"));
+    if (!p_Manip->reassmParams.timeOutTblAddr)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("MURAM alloc for Reassembly timeout table"));
 
-    IOMemSet32(UINT_TO_PTR(p_Manip->ipReassmParams.timeOutTblAddr), 0,  (uint16_t)(size * 8));
+    IOMemSet32(UINT_TO_PTR(p_Manip->reassmParams.timeOutTblAddr), 0,
+               (uint16_t)(size * 8));
 
     /* Sets the TimeOut table offset from MURAM */
-    tmpReg32 = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Manip->ipReassmParams.timeOutTblAddr)) - p_FmPcd->physicalMuramBase);
-    WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->timeOutTblPtr, tmpReg32);
+    tmpReg32 = (uint32_t)(XX_VirtToPhys(
+            UINT_TO_PTR(p_Manip->reassmParams.timeOutTblAddr))
+            - p_FmPcd->physicalMuramBase);
+    WRITE_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->timeOutTblPtr,
+                 tmpReg32);
 
     /* Sets the Expiration Delay */
     tmpReg32 = 0;
-    tmpReg32 |= (((uint32_t)(1 << FmGetTimeStampScale(p_FmPcd->h_Fm))) * p_Manip->ipReassmParams.timeoutThresholdForReassmProcess);
-    WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->expirationDelay, tmpReg32);
+    tmpReg32 |= (((uint32_t)(1 << bitFor1Micro))
+            * p_Manip->reassmParams.timeoutThresholdForReassmProcess);
+    WRITE_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->expirationDelay,
+                 tmpReg32);
 
-    err = FmPcdRegisterReassmPort(p_FmPcd, p_Manip->ipReassmParams.p_IpReassCommonTbl);
+    err = FmPcdRegisterReassmPort(p_FmPcd,
+                                  p_Manip->reassmParams.p_ReassCommonTbl);
     if (err != E_OK)
     {
-        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.p_IpReassCommonTbl);
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram,
+                         p_Manip->reassmParams.p_ReassCommonTbl);
         RETURN_ERROR(MAJOR, err, ("port registration"));
     }
 
     return err;
 }
 
-static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
+static t_Error CreateReassTable(t_FmPcdManip *p_Manip, e_NetHeaderType hdr)
 {
-    t_FmPcd                 *p_FmPcd = p_Manip->h_FmPcd;
-    uint32_t                tmpReg32, autoLearnHashTblSize;
-    uint32_t                numOfWays, setSize, setSizeCode, keySize;
-    uint32_t                waySize, numOfSets, numOfEntries;
-    uint64_t                tmpReg64;
-    uint16_t                minFragSize;
-    uintptr_t               *p_AutoLearnHashTblAddr, *p_AutoLearnSetLockTblAddr;
-    t_IpReassTbl            **p_IpReassTbl;
-
-    if (ipv4)
-    {
-        p_IpReassTbl = &p_Manip->ipReassmParams.p_Ipv4ReassTbl;
-        p_AutoLearnHashTblAddr = &p_Manip->ipReassmParams.ipv4AutoLearnHashTblAddr;
-        p_AutoLearnSetLockTblAddr = &p_Manip->ipReassmParams.ipv4AutoLearnSetLockTblAddr;
-        minFragSize = p_Manip->ipReassmParams.minFragSize[0];
-        numOfWays = p_Manip->ipReassmParams.numOfFramesPerHashEntry[0];
-        keySize = 4 + 4 + 1 + 2; /* 3-tuple + IP-Id */
-    }
-    else
+    t_FmPcd *p_FmPcd = p_Manip->h_FmPcd;
+    uint32_t tmpReg32, autoLearnHashTblSize;
+    uint32_t numOfWays, setSize, setSizeCode, keySize;
+    uint32_t waySize, numOfSets, numOfEntries;
+    uint64_t tmpReg64;
+    uint16_t minFragSize;
+    uint16_t maxReassemSize;
+    uintptr_t *p_AutoLearnHashTblAddr, *p_AutoLearnSetLockTblAddr;
+    t_ReassTbl **p_ReassTbl;
+
+    switch (hdr)
     {
-        p_IpReassTbl = &p_Manip->ipReassmParams.p_Ipv6ReassTbl;
-        p_AutoLearnHashTblAddr = &p_Manip->ipReassmParams.ipv6AutoLearnHashTblAddr;
-        p_AutoLearnSetLockTblAddr = &p_Manip->ipReassmParams.ipv6AutoLearnSetLockTblAddr;
-        minFragSize = p_Manip->ipReassmParams.minFragSize[1];
-        numOfWays = p_Manip->ipReassmParams.numOfFramesPerHashEntry[1];
-        keySize = 16 + 16 + 4; /* 2-tuple + IP-Id */
-        if (numOfWays > e_FM_PCD_MANIP_SIX_WAYS_HASH)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("num of ways"));
+        case HEADER_TYPE_IPv4:
+            p_ReassTbl = &p_Manip->reassmParams.ip.p_Ipv4ReassTbl;
+            p_AutoLearnHashTblAddr =
+                    &p_Manip->reassmParams.ip.ipv4AutoLearnHashTblAddr;
+            p_AutoLearnSetLockTblAddr =
+                    &p_Manip->reassmParams.ip.ipv4AutoLearnSetLockTblAddr;
+            minFragSize = p_Manip->reassmParams.ip.minFragSize[0];
+            maxReassemSize = 0;
+            numOfWays = p_Manip->reassmParams.ip.numOfFramesPerHashEntry[0];
+            keySize = 4 + 4 + 1 + 2; /* 3-tuple + IP-Id */
+            break;
+        case HEADER_TYPE_IPv6:
+            p_ReassTbl = &p_Manip->reassmParams.ip.p_Ipv6ReassTbl;
+            p_AutoLearnHashTblAddr =
+                    &p_Manip->reassmParams.ip.ipv6AutoLearnHashTblAddr;
+            p_AutoLearnSetLockTblAddr =
+                    &p_Manip->reassmParams.ip.ipv6AutoLearnSetLockTblAddr;
+            minFragSize = p_Manip->reassmParams.ip.minFragSize[1];
+            maxReassemSize = 0;
+            numOfWays = p_Manip->reassmParams.ip.numOfFramesPerHashEntry[1];
+            keySize = 16 + 16 + 4; /* 2-tuple + IP-Id */
+            if (numOfWays > e_FM_PCD_MANIP_SIX_WAYS_HASH)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("num of ways"));
+            break;
+        case HEADER_TYPE_CAPWAP:
+            p_ReassTbl = &p_Manip->reassmParams.capwap.p_ReassTbl;
+            p_AutoLearnHashTblAddr =
+                    &p_Manip->reassmParams.capwap.autoLearnHashTblAddr;
+            p_AutoLearnSetLockTblAddr =
+                    &p_Manip->reassmParams.capwap.autoLearnSetLockTblAddr;
+            minFragSize = 0;
+            maxReassemSize = p_Manip->reassmParams.capwap.maxRessembledsSize;
+            numOfWays = p_Manip->reassmParams.capwap.numOfFramesPerHashEntry;
+            keySize = 4;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("header type"));
     }
     keySize += 2; /* 2 bytes reserved for RFDIndex */
 #if (DPAA_VERSION >= 11)
@@ -1517,17 +2037,19 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
 #endif /* (DPAA_VERSION >= 11) */
     waySize = ROUND_UP(keySize, 8);
 
-    /* Allocates the IP Reassembly Parameters Table - This table is located in the MURAM.*/
-    *p_IpReassTbl = (t_IpReassTbl *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                                      FM_PCD_MANIP_IP_REASM_TABLE_SIZE,
-                                                      FM_PCD_MANIP_IP_REASM_TABLE_ALIGN);
-    if (!*p_IpReassTbl)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly IPv4/IPv6 specific parameters table"));
-    memset(*p_IpReassTbl, 0, sizeof(t_IpReassTbl));
+    /* Allocates the Reassembly Parameters Table - This table is located in the MURAM.*/
+    *p_ReassTbl = (t_ReassTbl *)FM_MURAM_AllocMem(
+            p_FmPcd->h_FmMuram, FM_PCD_MANIP_REASM_TABLE_SIZE,
+            FM_PCD_MANIP_REASM_TABLE_ALIGN);
+    if (!*p_ReassTbl)
+        RETURN_ERROR( MAJOR, E_NO_MEMORY,
+                     ("MURAM alloc for Reassembly specific parameters table"));
+    memset(*p_ReassTbl, 0, sizeof(t_ReassTbl));
 
-    /* Sets the IP Reassembly common Parameters table offset from MURAM in the IP Reassembly Table descriptor*/
-    tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->ipReassmParams.p_IpReassCommonTbl) - p_FmPcd->physicalMuramBase);
-    WRITE_UINT32((*p_IpReassTbl)->ipReassCommonPrmTblPtr, tmpReg32);
+    /* Sets the Reassembly common Parameters table offset from MURAM in the Reassembly Table descriptor*/
+    tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->reassmParams.p_ReassCommonTbl)
+            - p_FmPcd->physicalMuramBase);
+    WRITE_UINT32((*p_ReassTbl)->reassCommonPrmTblPtr, tmpReg32);
 
     /* Calculate set size (set size is rounded-up to next power of 2) */
     NEXT_POWER_OF_2(numOfWays * waySize, setSize);
@@ -1536,12 +2058,13 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
     LOG2(setSize, setSizeCode);
 
     /* Sets ways number and set size code */
-    WRITE_UINT16((*p_IpReassTbl)->waysNumAndSetSize, (uint16_t)((numOfWays << 8) | setSizeCode));
+    WRITE_UINT16((*p_ReassTbl)->waysNumAndSetSize,
+                 (uint16_t)((numOfWays << 8) | setSizeCode));
 
     /* It is recommended that the total number of entries in this table
-    (number of sets * number of ways) will be twice the number of frames that
+     (number of sets * number of ways) will be twice the number of frames that
      are expected to be reassembled simultaneously.*/
-    numOfEntries = (uint32_t)(p_Manip->ipReassmParams.maxNumFramesInProcess * 2);
+    numOfEntries = (uint32_t)(p_Manip->reassmParams.maxNumFramesInProcess * 2);
 
     /* sets number calculation - number of entries = number of sets * number of ways */
     numOfSets = numOfEntries / numOfWays;
@@ -1549,77 +2072,92 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
     /* Sets AutoLearnHashKeyMask*/
     NEXT_POWER_OF_2(numOfSets, numOfSets);
 
-    WRITE_UINT16((*p_IpReassTbl)->autoLearnHashKeyMask, (uint16_t)(numOfSets - 1));
+    WRITE_UINT16((*p_ReassTbl)->autoLearnHashKeyMask,
+                 (uint16_t)(numOfSets - 1));
 
-    /* Allocation of IP Reassembly Automatic Learning Hash Table - This table resides in external memory.
-    The size of this table is determined by the number of sets and the set size.
-    Table size = set size * number of sets
-    This table base address should be aligned to SetSize.*/
+    /* Allocation of Reassembly Automatic Learning Hash Table - This table resides in external memory.
+     The size of this table is determined by the number of sets and the set size.
+     Table size = set size * number of sets
+     This table base address should be aligned to SetSize.*/
     autoLearnHashTblSize = numOfSets * setSize;
 
-    *p_AutoLearnHashTblAddr = PTR_TO_UINT(XX_MallocSmart(autoLearnHashTblSize, p_Manip->ipReassmParams.dataMemId, setSize));
+    *p_AutoLearnHashTblAddr =
+            PTR_TO_UINT(XX_MallocSmart(autoLearnHashTblSize, p_Manip->reassmParams.dataMemId, setSize));
     if (!*p_AutoLearnHashTblAddr)
     {
-        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_IpReassTbl);
-        *p_IpReassTbl = NULL;
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_ReassTbl);
+        *p_ReassTbl = NULL;
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
     }
-    IOMemSet32(UINT_TO_PTR(*p_AutoLearnHashTblAddr), 0,  autoLearnHashTblSize);
-
-    /* Sets the IP Reassembly Automatic Learning Hash Table and liodn offset */
-    tmpReg64 = ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT);
-    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT);
+    IOMemSet32(UINT_TO_PTR(*p_AutoLearnHashTblAddr), 0, autoLearnHashTblSize);
+
+    /* Sets the Reassembly Automatic Learning Hash Table and liodn offset */
+    tmpReg64 = ((uint64_t)(p_Manip->reassmParams.dataLiodnOffset
+            & FM_PCD_MANIP_REASM_LIODN_MASK)
+            << (uint64_t)FM_PCD_MANIP_REASM_LIODN_SHIFT);
+    tmpReg64 |= ((uint64_t)(p_Manip->reassmParams.dataLiodnOffset
+            & FM_PCD_MANIP_REASM_ELIODN_MASK)
+            << (uint64_t)FM_PCD_MANIP_REASM_ELIODN_SHIFT);
     tmpReg64 |= XX_VirtToPhys(UINT_TO_PTR(*p_AutoLearnHashTblAddr));
-    WRITE_UINT32((*p_IpReassTbl)->liodnAlAndAutoLearnHashTblPtrHi, (uint32_t)(tmpReg64 >> 32));
-    WRITE_UINT32((*p_IpReassTbl)->autoLearnHashTblPtrLow, (uint32_t)tmpReg64);
+    WRITE_UINT32( (*p_ReassTbl)->liodnAlAndAutoLearnHashTblPtrHi,
+                 (uint32_t)(tmpReg64 >> 32));
+    WRITE_UINT32((*p_ReassTbl)->autoLearnHashTblPtrLow, (uint32_t)tmpReg64);
 
     /* Allocation of the Set Lock table - This table resides in external memory
-    The size of this table is (number of sets in the IP Reassembly Automatic Learning Hash table)*4 bytes.
-    This table resides in external memory and its base address should be 4-byte aligned */
-    *p_AutoLearnSetLockTblAddr = PTR_TO_UINT(XX_MallocSmart((uint32_t)(numOfSets * 4), p_Manip->ipReassmParams.dataMemId, 4));
+     The size of this table is (number of sets in the Reassembly Automatic Learning Hash table)*4 bytes.
+     This table resides in external memory and its base address should be 4-byte aligned */
+    *p_AutoLearnSetLockTblAddr =
+            PTR_TO_UINT(XX_MallocSmart((uint32_t)(numOfSets * 4), p_Manip->reassmParams.dataMemId, 4));
     if (!*p_AutoLearnSetLockTblAddr)
     {
-        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_IpReassTbl);
-        *p_IpReassTbl = NULL;
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_ReassTbl);
+        *p_ReassTbl = NULL;
         XX_FreeSmart(UINT_TO_PTR(*p_AutoLearnHashTblAddr));
         *p_AutoLearnHashTblAddr = 0;
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
     }
-    IOMemSet32(UINT_TO_PTR(*p_AutoLearnSetLockTblAddr), 0,  (numOfSets * 4));
+    IOMemSet32(UINT_TO_PTR(*p_AutoLearnSetLockTblAddr), 0, (numOfSets * 4));
 
     /* sets Set Lock table pointer and liodn offset*/
-    tmpReg64 = ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT);
-    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT);
+    tmpReg64 = ((uint64_t)(p_Manip->reassmParams.dataLiodnOffset
+            & FM_PCD_MANIP_REASM_LIODN_MASK)
+            << (uint64_t)FM_PCD_MANIP_REASM_LIODN_SHIFT);
+    tmpReg64 |= ((uint64_t)(p_Manip->reassmParams.dataLiodnOffset
+            & FM_PCD_MANIP_REASM_ELIODN_MASK)
+            << (uint64_t)FM_PCD_MANIP_REASM_ELIODN_SHIFT);
     tmpReg64 |= XX_VirtToPhys(UINT_TO_PTR(*p_AutoLearnSetLockTblAddr));
-    WRITE_UINT32((*p_IpReassTbl)->liodnSlAndAutoLearnSetLockTblPtrHi, (uint32_t)(tmpReg64 >> 32));
-    WRITE_UINT32((*p_IpReassTbl)->autoLearnSetLockTblPtrLow, (uint32_t)tmpReg64);
+    WRITE_UINT32( (*p_ReassTbl)->liodnSlAndAutoLearnSetLockTblPtrHi,
+                 (uint32_t)(tmpReg64 >> 32));
+    WRITE_UINT32((*p_ReassTbl)->autoLearnSetLockTblPtrLow, (uint32_t)tmpReg64);
 
     /* Sets user's requested minimum fragment size (in Bytes) for First/Middle fragment */
-    WRITE_UINT16((*p_IpReassTbl)->minFragSize, minFragSize);
+    WRITE_UINT16((*p_ReassTbl)->minFragSize, minFragSize);
+
+    WRITE_UINT16((*p_ReassTbl)->maxReassemblySize, maxReassemSize);
 
     return E_OK;
 }
 
-static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
-                                 t_Handle       h_PcdParams,
-                                 t_Handle       h_FmPort,
-                                 t_FmPcdManip   *p_Manip,
-                                 t_Handle       h_Ad,
-                                 bool           validate)
+static t_Error UpdateInitReasm(t_Handle h_FmPcd, t_Handle h_PcdParams,
+                               t_Handle h_FmPort, t_FmPcdManip *p_Manip,
+                               t_Handle h_Ad, bool validate)
 {
-    t_FmPortGetSetCcParams      fmPortGetSetCcParams;
-    uint32_t                    tmpReg32;
-    t_Error                     err;
-    t_FmPortPcdParams           *p_PcdParams = (t_FmPortPcdParams *)h_PcdParams;
+    t_FmPortGetSetCcParams fmPortGetSetCcParams;
+    uint32_t tmpReg32;
+    t_Error err;
+    t_FmPortPcdParams *p_PcdParams = (t_FmPortPcdParams *)h_PcdParams;
 #if (DPAA_VERSION >= 11)
-    t_FmPcdCtrlParamsPage       *p_ParamsPage;
+    t_FmPcdCtrlParamsPage *p_ParamsPage;
 #endif /* (DPAA_VERSION >= 11) */
 
     SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Manip->frag, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR((p_Manip->opcode == HMAN_OC_IP_REASSEMBLY), E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(
+            (p_Manip->opcode == HMAN_OC_IP_REASSEMBLY) || (p_Manip->opcode == HMAN_OC_CAPWAP_REASSEMBLY),
+            E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_Manip->updateParams || h_PcdParams, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Manip->updateParams || h_PcdParams,
+                              E_INVALID_HANDLE);
 
     UNUSED(h_Ad);
 
@@ -1627,128 +2165,158 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
         return E_OK;
 
     if (p_Manip->h_FmPcd != h_FmPcd)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("handler of PCD previously was initiated by different value"));
+        RETURN_ERROR(
+                MAJOR, E_INVALID_STATE,
+                ("handler of PCD previously was initiated by different value"));
 
     if (p_Manip->updateParams)
     {
-        if ((!(p_Manip->updateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))) ||
-            ((p_Manip->shadowUpdateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
+        if ((!(p_Manip->updateParams
+                & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK)))
+                || ((p_Manip->shadowUpdateParams
+                        & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))))
+            RETURN_ERROR(
+                    MAJOR, E_INVALID_STATE,
+                    ("in this stage parameters from Port has not be updated"));
 
         fmPortGetSetCcParams.setCcParams.type = 0;
+        if (p_Manip->opcode == HMAN_OC_CAPWAP_REASSEMBLY)
+        {
+            fmPortGetSetCcParams.setCcParams.type |= UPDATE_OFP_DPTE;
+            fmPortGetSetCcParams.setCcParams.ofpDpde = 0xF;
+        }
         fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams | FM_REV;
-        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-        if (fmPortGetSetCcParams.getCcParams.type & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK | FM_REV))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data wasn't configured previously"));
-    }
-    else if (validate)
-    {
-        if ((!(p_Manip->shadowUpdateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))) ||
-            ((p_Manip->updateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
-
-        fmPortGetSetCcParams.setCcParams.type = 0;
-        fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
-        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams))
+                != E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
-        if (fmPortGetSetCcParams.getCcParams.type & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data wasn't configured previously"));
-    }
-
-    if (p_Manip->updateParams)
-    {
-        if (p_Manip->updateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))
+        if (fmPortGetSetCcParams.getCcParams.type
+                & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK | FM_REV))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                         ("offset of the data wasn't configured previously"));
+        if (p_Manip->updateParams
+                & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))
         {
-            t_FmPcd     *p_FmPcd = (t_FmPcd *)h_FmPcd;
-            uint8_t     *p_Ptr, i, totalNumOfTnums;
+            t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
+            uint8_t *p_Ptr, i, totalNumOfTnums;
 
-            totalNumOfTnums = (uint8_t)(fmPortGetSetCcParams.getCcParams.numOfTasks +
-                                        fmPortGetSetCcParams.getCcParams.numOfExtraTasks);
+            totalNumOfTnums =
+                    (uint8_t)(fmPortGetSetCcParams.getCcParams.numOfTasks
+                            + fmPortGetSetCcParams.getCcParams.numOfExtraTasks);
 
-            p_Manip->ipReassmParams.internalBufferPoolAddr =
+            p_Manip->reassmParams.internalBufferPoolAddr =
                     PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                                  (uint32_t)(totalNumOfTnums * BMI_FIFO_UNITS),
-                                                  BMI_FIFO_UNITS));
-            if (!p_Manip->ipReassmParams.internalBufferPoolAddr)
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly internal buffers pool"));
-            IOMemSet32(UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolAddr),
-                       0,
-                       (uint32_t)(totalNumOfTnums * BMI_FIFO_UNITS));
-
-            p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr =
+                                    (uint32_t)(totalNumOfTnums * BMI_FIFO_UNITS),
+                                    BMI_FIFO_UNITS));
+            if (!p_Manip->reassmParams.internalBufferPoolAddr)
+                RETURN_ERROR(
+                        MAJOR, E_NO_MEMORY,
+                        ("MURAM alloc for Reassembly internal buffers pool"));
+            IOMemSet32(
+                    UINT_TO_PTR(p_Manip->reassmParams.internalBufferPoolAddr),
+                    0, (uint32_t)(totalNumOfTnums * BMI_FIFO_UNITS));
+
+            p_Manip->reassmParams.internalBufferPoolManagementIndexAddr =
                     PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                                  (uint32_t)(5 + totalNumOfTnums),
-                                                  4));
-            if (!p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr)
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly internal buffers management"));
-
-            p_Ptr = (uint8_t*)UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr);
-            WRITE_UINT32(*(uint32_t*)p_Ptr, (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolAddr)) - p_FmPcd->physicalMuramBase));
-            for (i=0, p_Ptr += 4; i < totalNumOfTnums; i++, p_Ptr++)
+                                    (uint32_t)(5 + totalNumOfTnums),
+                                    4));
+            if (!p_Manip->reassmParams.internalBufferPoolManagementIndexAddr)
+                RETURN_ERROR(
+                        MAJOR,
+                        E_NO_MEMORY,
+                        ("MURAM alloc for Reassembly internal buffers management"));
+
+            p_Ptr =
+                    (uint8_t*)UINT_TO_PTR(p_Manip->reassmParams.internalBufferPoolManagementIndexAddr);
+            WRITE_UINT32(
+                    *(uint32_t*)p_Ptr,
+                    (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Manip->reassmParams.internalBufferPoolAddr)) - p_FmPcd->physicalMuramBase));
+            for (i = 0, p_Ptr += 4; i < totalNumOfTnums; i++, p_Ptr++)
                 WRITE_UINT8(*p_Ptr, i);
             WRITE_UINT8(*p_Ptr, 0xFF);
 
-            tmpReg32 = (4 << FM_PCD_MANIP_IP_REASM_COMMON_INT_BUFFER_IDX_SHIFT) |
-                       ((uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr)) - p_FmPcd->physicalMuramBase));
-            WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->internalBufferManagement, tmpReg32);
-
-            p_Manip->updateParams &= ~(NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK);
-            p_Manip->shadowUpdateParams |= (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK);
+            tmpReg32 =
+                    (4 << FM_PCD_MANIP_REASM_COMMON_INT_BUFFER_IDX_SHIFT)
+                            | ((uint32_t)(XX_VirtToPhys(
+                                    UINT_TO_PTR(p_Manip->reassmParams.internalBufferPoolManagementIndexAddr))
+                                    - p_FmPcd->physicalMuramBase));
+            WRITE_UINT32(
+                    p_Manip->reassmParams.p_ReassCommonTbl->internalBufferManagement,
+                    tmpReg32);
+
+            p_Manip->updateParams &= ~(NUM_OF_TASKS | NUM_OF_EXTRA_TASKS
+                    | DISCARD_MASK);
+            p_Manip->shadowUpdateParams |= (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS
+                    | DISCARD_MASK);
         }
     }
 
-    if (p_Manip->ipReassmParams.h_Ipv4Scheme)
-    {
-        p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] = p_Manip->ipReassmParams.h_Ipv4Scheme;
-        p_PcdParams->p_KgParams->numOfSchemes++;
-    }
-    if (p_Manip->ipReassmParams.h_Ipv6Scheme)
+    if (p_Manip->opcode == HMAN_OC_CAPWAP_REASSEMBLY)
     {
-        p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] = p_Manip->ipReassmParams.h_Ipv6Scheme;
-        p_PcdParams->p_KgParams->numOfSchemes++;
-    }
+        if (p_Manip->reassmParams.capwap.h_Scheme)
+        {
+            p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] =
+                    p_Manip->reassmParams.capwap.h_Scheme;
+            p_PcdParams->p_KgParams->numOfSchemes++;
+        }
 
-#if (DPAA_VERSION >= 11)
-    if (fmPortGetSetCcParams.getCcParams.revInfo.majorRev >= 6)
+    }
+    else
     {
-        if ((err = FmPortSetGprFunc(h_FmPort, e_FM_PORT_GPR_MURAM_PAGE, (void**)&p_ParamsPage)) != E_OK)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-
-        tmpReg32 = NIA_ENG_KG;
-        if (p_Manip->ipReassmParams.h_Ipv4Scheme)
+        if (p_Manip->reassmParams.ip.h_Ipv4Scheme)
         {
-            tmpReg32 |= NIA_KG_DIRECT;
-            tmpReg32 |= NIA_KG_CC_EN;
-            tmpReg32 |= FmPcdKgGetSchemeId(p_Manip->ipReassmParams.h_Ipv4Scheme);
-            WRITE_UINT32(p_ParamsPage->iprIpv4Nia, tmpReg32);
+            p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] =
+                    p_Manip->reassmParams.ip.h_Ipv4Scheme;
+            p_PcdParams->p_KgParams->numOfSchemes++;
         }
-        if (p_Manip->ipReassmParams.h_Ipv6Scheme)
+        if (p_Manip->reassmParams.ip.h_Ipv6Scheme)
         {
-            tmpReg32 &= ~NIA_AC_MASK;
-            tmpReg32 |= NIA_KG_DIRECT;
-            tmpReg32 |= NIA_KG_CC_EN;
-            tmpReg32 |= FmPcdKgGetSchemeId(p_Manip->ipReassmParams.h_Ipv6Scheme);
-            WRITE_UINT32(p_ParamsPage->iprIpv6Nia, tmpReg32);
+            p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] =
+                    p_Manip->reassmParams.ip.h_Ipv6Scheme;
+            p_PcdParams->p_KgParams->numOfSchemes++;
+        }
+#if (DPAA_VERSION >= 11)
+        if (fmPortGetSetCcParams.getCcParams.revInfo.majorRev >= 6)
+        {
+            if ((err = FmPortSetGprFunc(h_FmPort, e_FM_PORT_GPR_MURAM_PAGE,
+                                        (void**)&p_ParamsPage)) != E_OK)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+
+            tmpReg32 = NIA_ENG_KG;
+            if (p_Manip->reassmParams.ip.h_Ipv4Scheme)
+            {
+                tmpReg32 |= NIA_KG_DIRECT;
+                tmpReg32 |= NIA_KG_CC_EN;
+                tmpReg32 |= FmPcdKgGetSchemeId(
+                        p_Manip->reassmParams.ip.h_Ipv4Scheme);
+                WRITE_UINT32(p_ParamsPage->iprIpv4Nia, tmpReg32);
+            }
+            if (p_Manip->reassmParams.ip.h_Ipv6Scheme)
+            {
+                tmpReg32 &= ~NIA_AC_MASK;
+                tmpReg32 |= NIA_KG_DIRECT;
+                tmpReg32 |= NIA_KG_CC_EN;
+                tmpReg32 |= FmPcdKgGetSchemeId(
+                        p_Manip->reassmParams.ip.h_Ipv6Scheme);
+                WRITE_UINT32(p_ParamsPage->iprIpv6Nia, tmpReg32);
+            }
         }
-    }
 #else
-    if (fmPortGetSetCcParams.getCcParams.revInfo.majorRev < 6)
-    {
-        WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->discardMask,
-                     fmPortGetSetCcParams.getCcParams.discardMask);
-    }
+        if (fmPortGetSetCcParams.getCcParams.revInfo.majorRev < 6)
+        {
+            WRITE_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->discardMask,
+                    fmPortGetSetCcParams.getCcParams.discardMask);
+        }
 #endif /* (DPAA_VERSION >= 11) */
-
+    }
     return E_OK;
 }
 
 #if (DPAA_VERSION == 10)
 static t_Error FmPcdFragHcScratchPoolFill(t_Handle h_FmPcd, uint8_t scratchBpid)
 {
-    t_FmPcd                             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdCcFragScratchPoolCmdParams   fmPcdCcFragScratchPoolCmdParams;
-    t_Error                             err;
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdCcFragScratchPoolCmdParams fmPcdCcFragScratchPoolCmdParams;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
@@ -1757,21 +2325,21 @@ static t_Error FmPcdFragHcScratchPoolFill(t_Handle h_FmPcd, uint8_t scratchBpid)
     fmPcdCcFragScratchPoolCmdParams.numOfBuffers = NUM_OF_SCRATCH_POOL_BUFFERS;
     fmPcdCcFragScratchPoolCmdParams.bufferPoolId = scratchBpid;
     if ((err = FmHcPcdCcIpFragScratchPollCmd(p_FmPcd->h_Hc, TRUE, &fmPcdCcFragScratchPoolCmdParams)) != E_OK)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    RETURN_ERROR(MAJOR, err, NO_MSG);
 
     if (fmPcdCcFragScratchPoolCmdParams.numOfBuffers != 0)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Fill scratch pool failed,"
-                                              "Failed to release %d buffers to the BM (missing FBPRs)",
-                                              fmPcdCcFragScratchPoolCmdParams.numOfBuffers));
+    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Fill scratch pool failed,"
+                    "Failed to release %d buffers to the BM (missing FBPRs)",
+                    fmPcdCcFragScratchPoolCmdParams.numOfBuffers));
 
     return E_OK;
 }
 
 static t_Error FmPcdFragHcScratchPoolEmpty(t_Handle h_FmPcd, uint8_t scratchBpid)
 {
-    t_FmPcd                             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdCcFragScratchPoolCmdParams   fmPcdCcFragScratchPoolCmdParams;
-    t_Error                             err;
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdCcFragScratchPoolCmdParams fmPcdCcFragScratchPoolCmdParams;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
@@ -1779,7 +2347,7 @@ static t_Error FmPcdFragHcScratchPoolEmpty(t_Handle h_FmPcd, uint8_t scratchBpid
 
     fmPcdCcFragScratchPoolCmdParams.bufferPoolId = scratchBpid;
     if ((err = FmHcPcdCcIpFragScratchPollCmd(p_FmPcd->h_Hc, FALSE, &fmPcdCcFragScratchPoolCmdParams)) != E_OK)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    RETURN_ERROR(MAJOR, err, NO_MSG);
 
     return E_OK;
 }
@@ -1800,134 +2368,163 @@ static void ReleaseManipHandler(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->p_Template);
         p_Manip->p_Template = NULL;
     }
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
     if (p_Manip->h_Frag)
     {
-        if (p_Manip->fragParams.p_AutoLearnHashTbl)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_AutoLearnHashTbl);
-        if (p_Manip->fragParams.p_ReassmFrmDescrPoolTbl)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_ReassmFrmDescrPoolTbl);
-        if (p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl);
-        if (p_Manip->fragParams.p_TimeOutTbl)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_TimeOutTbl);
+        if (p_Manip->capwapFragParams.p_AutoLearnHashTbl)
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram,
+                p_Manip->capwapFragParams.p_AutoLearnHashTbl);
+        if (p_Manip->capwapFragParams.p_ReassmFrmDescrPoolTbl)
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram,
+                p_Manip->capwapFragParams.p_ReassmFrmDescrPoolTbl);
+        if (p_Manip->capwapFragParams.p_ReassmFrmDescrIndxPoolTbl)
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram,
+                p_Manip->capwapFragParams.p_ReassmFrmDescrIndxPoolTbl);
+        if (p_Manip->capwapFragParams.p_TimeOutTbl)
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram,
+                p_Manip->capwapFragParams.p_TimeOutTbl);
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->h_Frag);
 
     }
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
     if (p_Manip->frag)
     {
-        if (p_Manip->ipFragParams.p_Frag)
+        if (p_Manip->fragParams.p_Frag)
         {
 #if (DPAA_VERSION == 10)
-            FmPcdFragHcScratchPoolEmpty((t_Handle)p_FmPcd, p_Manip->ipFragParams.scratchBpid);
+            FmPcdFragHcScratchPoolEmpty((t_Handle)p_FmPcd, p_Manip->fragParams.scratchBpid);
 #endif /* (DPAA_VERSION == 10) */
 
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipFragParams.p_Frag);
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_Frag);
         }
     }
-    else if (p_Manip->reassm)
-    {
-        FmPcdUnregisterReassmPort(p_FmPcd, p_Manip->ipReassmParams.p_IpReassCommonTbl);
-
-        if (p_Manip->ipReassmParams.timeOutTblAddr)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_Manip->ipReassmParams.timeOutTblAddr));
-        if (p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr)
-            XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr));
-
-        if (p_Manip->ipReassmParams.ipv4AutoLearnHashTblAddr)
-            XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv4AutoLearnHashTblAddr));
-        if (p_Manip->ipReassmParams.ipv6AutoLearnHashTblAddr)
-            XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv6AutoLearnHashTblAddr));
-        if (p_Manip->ipReassmParams.ipv4AutoLearnSetLockTblAddr)
-            XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv4AutoLearnSetLockTblAddr));
-        if (p_Manip->ipReassmParams.ipv6AutoLearnSetLockTblAddr)
-            XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv6AutoLearnSetLockTblAddr));
-        if (p_Manip->ipReassmParams.p_Ipv4ReassTbl)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.p_Ipv4ReassTbl);
-        if (p_Manip->ipReassmParams.p_Ipv6ReassTbl)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.p_Ipv6ReassTbl);
-        if (p_Manip->ipReassmParams.p_IpReassCommonTbl)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.p_IpReassCommonTbl);
-        if (p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr));
-        if (p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr));
-        if (p_Manip->ipReassmParams.internalBufferPoolAddr)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolAddr));
-
-        if (p_Manip->ipReassmParams.h_Ipv6Ad)
-            XX_FreeSmart(p_Manip->ipReassmParams.h_Ipv6Ad);
-        if (p_Manip->ipReassmParams.h_Ipv4Ad)
-            XX_FreeSmart(p_Manip->ipReassmParams.h_Ipv4Ad);
-    }
+    else
+        if (p_Manip->reassm)
+        {
+            FmPcdUnregisterReassmPort(p_FmPcd,
+                                      p_Manip->reassmParams.p_ReassCommonTbl);
+
+            if (p_Manip->reassmParams.timeOutTblAddr)
+                FM_MURAM_FreeMem(
+                        p_FmPcd->h_FmMuram,
+                        UINT_TO_PTR(p_Manip->reassmParams.timeOutTblAddr));
+            if (p_Manip->reassmParams.reassFrmDescrPoolTblAddr)
+                XX_FreeSmart(
+                        UINT_TO_PTR(p_Manip->reassmParams.reassFrmDescrPoolTblAddr));
+            if (p_Manip->reassmParams.p_ReassCommonTbl)
+                FM_MURAM_FreeMem(p_FmPcd->h_FmMuram,
+                                 p_Manip->reassmParams.p_ReassCommonTbl);
+            if (p_Manip->reassmParams.reassFrmDescrIndxPoolTblAddr)
+                FM_MURAM_FreeMem(
+                        p_FmPcd->h_FmMuram,
+                        UINT_TO_PTR(p_Manip->reassmParams.reassFrmDescrIndxPoolTblAddr));
+            if (p_Manip->reassmParams.internalBufferPoolManagementIndexAddr)
+                FM_MURAM_FreeMem(
+                        p_FmPcd->h_FmMuram,
+                        UINT_TO_PTR(p_Manip->reassmParams.internalBufferPoolManagementIndexAddr));
+            if (p_Manip->reassmParams.internalBufferPoolAddr)
+                FM_MURAM_FreeMem(
+                        p_FmPcd->h_FmMuram,
+                        UINT_TO_PTR(p_Manip->reassmParams.internalBufferPoolAddr));
+            if (p_Manip->reassmParams.hdr == HEADER_TYPE_CAPWAP)
+            {
+
+            }
+            else
+            {
+                if (p_Manip->reassmParams.ip.ipv4AutoLearnHashTblAddr)
+                    XX_FreeSmart(
+                            UINT_TO_PTR(p_Manip->reassmParams.ip.ipv4AutoLearnHashTblAddr));
+                if (p_Manip->reassmParams.ip.ipv6AutoLearnHashTblAddr)
+                    XX_FreeSmart(
+                            UINT_TO_PTR(p_Manip->reassmParams.ip.ipv6AutoLearnHashTblAddr));
+                if (p_Manip->reassmParams.ip.ipv4AutoLearnSetLockTblAddr)
+                    XX_FreeSmart(
+                            UINT_TO_PTR(p_Manip->reassmParams.ip.ipv4AutoLearnSetLockTblAddr));
+                if (p_Manip->reassmParams.ip.ipv6AutoLearnSetLockTblAddr)
+                    XX_FreeSmart(
+                            UINT_TO_PTR(p_Manip->reassmParams.ip.ipv6AutoLearnSetLockTblAddr));
+                if (p_Manip->reassmParams.ip.p_Ipv4ReassTbl)
+                    FM_MURAM_FreeMem(p_FmPcd->h_FmMuram,
+                                     p_Manip->reassmParams.ip.p_Ipv4ReassTbl);
+                if (p_Manip->reassmParams.ip.p_Ipv6ReassTbl)
+                    FM_MURAM_FreeMem(p_FmPcd->h_FmMuram,
+                                     p_Manip->reassmParams.ip.p_Ipv6ReassTbl);
+                if (p_Manip->reassmParams.ip.h_Ipv6Ad)
+                    XX_FreeSmart(p_Manip->reassmParams.ip.h_Ipv6Ad);
+                if (p_Manip->reassmParams.ip.h_Ipv4Ad)
+                    XX_FreeSmart(p_Manip->reassmParams.ip.h_Ipv4Ad);
+            }
+        }
 
     if (p_Manip->p_StatsTbl)
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->p_StatsTbl);
 }
 
-#ifdef FM_CAPWAP_SUPPORT
-static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipParams *p_ManipParams)
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_ManipParams)
 {
     if (p_ManipParams->u.hdr.rmv)
     {
         switch (p_ManipParams->u.hdr.rmvParams.type)
         {
             case (e_FM_PCD_MANIP_RMV_BY_HDR):
-                switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.type)
+            switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.type)
+            {
+                case (e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START) :
+                if (p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.include)
                 {
-                    case (e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START) :
-                        if (p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.include)
-                        {
-                            switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.hdrInfo.hdr)
-                            {
-                                case (HEADER_TYPE_CAPWAP_DTLS) :
-                                    p_Manip->opcode = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
-                                    p_Manip->muramAllocate = TRUE;
-                                    if (p_ManipParams->u.hdr.insrt)
-                                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for  CAPWAP_DTLS_HDR remove can not be insrt manipualtion after"));
-                                    if (p_ManipParams->fragOrReasm)
-                                    {
-                                        if (!p_ManipParams->fragOrReasmParams.frag)
-                                        {
-                                            switch (p_ManipParams->fragOrReasmParams.hdr)
-                                            {
-                                                case (HEADER_TYPE_CAPWAP):
-                                                    p_Manip->opcode = HMAN_OC_CAPWAP_REASSEMBLY;
-                                                    break;
-                                                default:
-                                                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("unsupported header for Reassembly"));
-                                            }
-                                        }
-                                        else
-                                            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for this type of manipulation frag can not be TRUE"));
-                                    }
-                                break;
-                                default:
-                                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("non valid net header of remove location"));
-                            }
-                        }
-                        else
+                    switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.hdrInfo.hdr)
+                    {
+                        case (HEADER_TYPE_CAPWAP_DTLS) :
+                        p_Manip->opcode = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
+                        p_Manip->muramAllocate = TRUE;
+                        if (p_ManipParams->u.hdr.insrt)
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for  CAPWAP_DTLS_HDR remove can not be insrt manipualtion after"));
+                        if (p_ManipParams->fragOrReasm)
                         {
-                            switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.hdrInfo.hdr)
+                            if (!p_ManipParams->fragOrReasmParams.frag)
                             {
-                                case (HEADER_TYPE_CAPWAP_DTLS) :
-                                case (HEADER_TYPE_CAPWAP) :
-                                    if  (p_ManipParams->fragOrReasm || p_ManipParams->u.hdr.insrt)
-                                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for the type of remove e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_CAPWAP can not be insert or fragOrReasm TRUE"));
-                                    p_Manip->opcode = HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
-                                    p_Manip->muramAllocate = TRUE;
-                                    p_ManipParams->u.hdr.insrt = TRUE; //internal frame header
+                                switch (p_ManipParams->fragOrReasmParams.hdr)
+                                {
+                                    case (HEADER_TYPE_CAPWAP):
+                                    p_Manip->opcode = HMAN_OC_CAPWAP_REASSEMBLY;
                                     break;
-                                default :
-                                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
+                                    default:
+                                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("unsupported header for Reassembly"));
+                                }
                             }
+                            else
+                            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for this type of manipulation frag can not be TRUE"));
                         }
                         break;
-                    default :
-                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
-               }
-               break;
-           default:
+                        default:
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("non valid net header of remove location"));
+                    }
+                }
+                else
+                {
+                    switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.hdrInfo.hdr)
+                    {
+                        case (HEADER_TYPE_CAPWAP_DTLS) :
+                        case (HEADER_TYPE_CAPWAP) :
+                        if (p_ManipParams->fragOrReasm || p_ManipParams->u.hdr.insrt)
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for the type of remove e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_CAPWAP can not be insert or fragOrReasm TRUE"));
+                        p_Manip->opcode = HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
+                        p_Manip->muramAllocate = TRUE;
+                        p_ManipParams->u.hdr.insrt = TRUE; //internal frame header
+                        break;
+                        default :
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
+                    }
+                }
+                break;
+                default :
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
+            }
+            break;
+            default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
         }
     }
     else if (p_ManipParams->u.hdr.insrt)
@@ -1936,28 +2533,28 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
         {
             case (e_FM_PCD_MANIP_INSRT_BY_TEMPLATE) :
 
-                p_Manip->opcode = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
-                p_Manip->muramAllocate = FALSE;
-                if (p_ManipParams->fragOrReasm)
+            p_Manip->opcode = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
+            p_Manip->muramAllocate = FALSE;
+            if (p_ManipParams->fragOrReasm)
+            {
+                if (p_ManipParams->fragOrReasmParams.frag)
                 {
-                    if (p_ManipParams->fragOrReasmParams.frag)
+                    switch (p_ManipParams->fragOrReasmParams.hdr)
                     {
-                           switch (p_ManipParams->fragOrReasmParams.hdr)
-                           {
-                                case (HEADER_TYPE_CAPWAP):
-                                    p_Manip->opcode = HMAN_OC_CAPWAP_FRAGMENTATION;
-                                    break;
-                                default:
-                                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid header for fragmentation"));
-                           }
+                        case (HEADER_TYPE_CAPWAP):
+                        p_Manip->opcode = HMAN_OC_CAPWAP_FRAGMENTATION;
+                        break;
+                        default:
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid header for fragmentation"));
                     }
-                    else
-                        RETURN_ERROR(MAJOR, E_INVALID_STATE,("can not reach this point"));
                 }
-                break;
+                else
+                RETURN_ERROR(MAJOR, E_INVALID_STATE,("can not reach this point"));
+            }
+            break;
 
             default:
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for only isert manipulation unsupported type"));
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for only isert manipulation unsupported type"));
         }
     }
     else if (p_ManipParams->fragOrReasm)
@@ -1967,47 +2564,54 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
             switch (p_ManipParams->fragOrReasmParams.hdr)
             {
                 case (HEADER_TYPE_CAPWAP):
-                    p_Manip->opcode = HMAN_OC_CAPWAP_FRAGMENTATION;
-                    p_Manip->muramAllocate = FALSE;
-                    break;
+                p_Manip->opcode = HMAN_OC_CAPWAP_FRAGMENTATION;
+                p_Manip->muramAllocate = FALSE;
+                break;
                 default:
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported header for fragmentation"));
-             }
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported header for fragmentation"));
+            }
         }
         else
         {
             switch (p_ManipParams->fragOrReasmParams.hdr)
             {
                 case (HEADER_TYPE_CAPWAP):
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Reassembly has to be with additional operation - rmv = TRUE, type of remove - e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION,type = e_FM_PCD_MANIP_LOC_BY_HDR, hdr = HEADER_TYPE_CAPWAP_DTLS"));
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Reassembly has to be with additional operation - rmv = TRUE, type of remove - e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION,type = e_FM_PCD_MANIP_LOC_BY_HDR, hdr = HEADER_TYPE_CAPWAP_DTLS"));
                 default:
-                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported header for reassembly"));
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported header for reassembly"));
             }
         }
 
     }
     else
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("User didn't ask for any manipulation"));
+    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("User didn't ask for any manipulation"));
 
     p_Manip->insrt = p_ManipParams->u.hdr.insrt;
-    p_Manip->rmv   = p_ManipParams->u.hdr.rmv;
+    p_Manip->rmv = p_ManipParams->u.hdr.rmv;
 
     return E_OK;
 }
 
-#else /* not FM_CAPWAP_SUPPORT */
-static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_ManipParams)
+#else /* not (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
+static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip,
+                                          t_FmPcdManipParams *p_ManipParams)
 {
     switch (p_ManipParams->type)
     {
-        case e_FM_PCD_MANIP_HDR :
+        case e_FM_PCD_MANIP_HDR:
             /* Check that next-manip is not already used */
             if (p_ManipParams->h_NextManip)
             {
                 if (!MANIP_IS_FIRST(p_ManipParams->h_NextManip))
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("h_NextManip is already a part of another chain"));
-                if (MANIP_GET_TYPE(p_ManipParams->h_NextManip) != e_FM_PCD_MANIP_HDR)
-                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("For a Header Manipulation node - no support of h_NextManip of type other than Header Manipulation."));
+                    RETURN_ERROR(
+                            MAJOR, E_INVALID_STATE,
+                            ("h_NextManip is already a part of another chain"));
+                if (MANIP_GET_TYPE(p_ManipParams->h_NextManip)
+                        != e_FM_PCD_MANIP_HDR)
+                    RETURN_ERROR(
+                            MAJOR,
+                            E_NOT_SUPPORTED,
+                            ("For a Header Manipulation node - no support of h_NextManip of type other than Header Manipulation."));
             }
 
             if (p_ManipParams->u.hdr.rmv)
@@ -2017,136 +2621,240 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
                     case (e_FM_PCD_MANIP_RMV_BY_HDR):
                         switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.type)
                         {
-                            case (e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2) :
-                                p_Manip->opcode = HMAN_OC;
-                                p_Manip->muramAllocate = TRUE;
+                            case (e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2):
+                                break;
+#if (DPAA_VERSION >= 11)
+                            case (e_FM_PCD_MANIP_RMV_BY_HDR_CAPWAP):
+                                break;
+                            case (e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START):
+                            {
+                                t_Error err;
+                                uint8_t prsArrayOffset;
+
+                                err =
+                                        GetPrOffsetByHeaderOrField(
+                                                &p_ManipParams->u.hdr.rmvParams.u.byHdr.u.hdrInfo,
+                                                &prsArrayOffset);
+                                if (err)
+                                    RETURN_ERROR(MAJOR, err, NO_MSG);
                                 break;
-                            default :
-                                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
+                            }
+#endif /* (DPAA_VERSION >= 11) */
+                            default:
+                                RETURN_ERROR(
+                                        MAJOR,
+                                        E_INVALID_STATE,
+                                        ("invalid type of remove manipulation"));
                         }
                         break;
-                   case (e_FM_PCD_MANIP_RMV_GENERIC):
-                       p_Manip->opcode = HMAN_OC;
-                       p_Manip->muramAllocate = TRUE;
-                       break;
-                   default:
-                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
-                }
-                p_Manip->rmv = TRUE;
-            }
-            else if (p_ManipParams->u.hdr.insrt)
-            {
-                switch (p_ManipParams->u.hdr.insrtParams.type)
-                {
-                    case (e_FM_PCD_MANIP_INSRT_BY_HDR) :
-                    case (e_FM_PCD_MANIP_INSRT_GENERIC):
-                        p_Manip->opcode = HMAN_OC;
-                        p_Manip->muramAllocate = TRUE;
+                    case (e_FM_PCD_MANIP_RMV_GENERIC):
                         break;
                     default:
-                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for only isert manipulation unsupported type"));
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                                     ("invalid type of remove manipulation"));
                 }
-                p_Manip->insrt = TRUE;
+                p_Manip->opcode = HMAN_OC;
+                p_Manip->muramAllocate = TRUE;
+                p_Manip->rmv = TRUE;
             }
-            else if (p_ManipParams->u.hdr.fieldUpdate)
-            {
-                /* Check parameters */
-                if (p_ManipParams->u.hdr.fieldUpdateParams.type == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN)
+            else
+                if (p_ManipParams->u.hdr.insrt)
                 {
-                    if ((p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI)
-                        && (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.vpri > 7))
-                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("vpri should get values of 0-7 "));
-                    if (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
+                    switch (p_ManipParams->u.hdr.insrtParams.type)
                     {
-                        int i;
-
-                        if (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.vpriDefVal > 7)
-                            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("vpriDefVal should get values of 0-7 "));
-                        for (i = 0 ; i < FM_PCD_MANIP_DSCP_TO_VLAN_TRANS ; i++)
-                            if (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.dscpToVpriTable[i] & 0xf0)
-                                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dscpToVpriTabl value out of range (0-15)"));
+                        case (e_FM_PCD_MANIP_INSRT_BY_HDR):
+                        {
+                            switch (p_ManipParams->u.hdr.insrtParams.u.byHdr.type)
+                            {
+                                case (e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2):
+                                    /* nothing to check */
+                                    break;
+#if (DPAA_VERSION >= 11)
+                                case (e_FM_PCD_MANIP_INSRT_BY_HDR_IP):
+                                    if (p_ManipParams->u.hdr.insrtParams.u.byHdr.u.ipParams.insrt.size
+                                            % 4)
+                                        RETURN_ERROR(
+                                                MAJOR,
+                                                E_INVALID_VALUE,
+                                                ("IP inserted header must be of size which is a multiple of four bytes"));
+                                    break;
+                                case (e_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP):
+                                    if (p_ManipParams->u.hdr.insrtParams.u.byHdr.u.insrt.size
+                                            % 4)
+                                        RETURN_ERROR(
+                                                MAJOR,
+                                                E_INVALID_VALUE,
+                                                ("CAPWAP inserted header must be of size which is a multiple of four bytes"));
+                                    break;
+                                case (e_FM_PCD_MANIP_INSRT_BY_HDR_UDP):
+                                case (e_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE):
+                                    if (p_ManipParams->u.hdr.insrtParams.u.byHdr.u.insrt.size
+                                            != 8)
+                                        RETURN_ERROR(
+                                                MAJOR,
+                                                E_INVALID_VALUE,
+                                                ("Inserted header must be of size 8"));
+                                    break;
+#endif /* (DPAA_VERSION >= 11) */
+                                default:
+                                    RETURN_ERROR(
+                                            MAJOR,
+                                            E_INVALID_STATE,
+                                            ("unsupported insert by header type"));
+                            }
+                        }
+                        case (e_FM_PCD_MANIP_INSRT_GENERIC):
+                            break;
+                        default:
+                            RETURN_ERROR(
+                                    MAJOR,
+                                    E_INVALID_STATE,
+                                    ("for only insert manipulation unsupported type"));
                     }
-
+                    p_Manip->opcode = HMAN_OC;
+                    p_Manip->muramAllocate = TRUE;
+                    p_Manip->insrt = TRUE;
                 }
+                else
+                    if (p_ManipParams->u.hdr.fieldUpdate)
+                    {
+                        /* Check parameters */
+                        if (p_ManipParams->u.hdr.fieldUpdateParams.type
+                                == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN)
+                        {
+                            if ((p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType
+                                    == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI)
+                                    && (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.vpri
+                                            > 7))
+                                RETURN_ERROR(
+                                        MAJOR, E_INVALID_VALUE,
+                                        ("vpri should get values of 0-7 "));
+                            if (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType
+                                    == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
+                            {
+                                int i;
+
+                                if (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.vpriDefVal
+                                        > 7)
+                                    RETURN_ERROR(
+                                            MAJOR,
+                                            E_INVALID_VALUE,
+                                            ("vpriDefVal should get values of 0-7 "));
+                                for (i = 0; i < FM_PCD_MANIP_DSCP_TO_VLAN_TRANS;
+                                        i++)
+                                    if (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.dscpToVpriTable[i]
+                                            & 0xf0)
+                                        RETURN_ERROR(
+                                                MAJOR,
+                                                E_INVALID_VALUE,
+                                                ("dscpToVpriTabl value out of range (0-15)"));
+                            }
 
-                p_Manip->opcode = HMAN_OC;
-                p_Manip->muramAllocate = TRUE;
-                p_Manip->fieldUpdate = TRUE;
-            }
-            else if (p_ManipParams->u.hdr.custom)
-            {
-                p_Manip->opcode = HMAN_OC;
-                p_Manip->muramAllocate = TRUE;
-                p_Manip->custom = TRUE;
-            }
+                        }
+
+                        p_Manip->opcode = HMAN_OC;
+                        p_Manip->muramAllocate = TRUE;
+                        p_Manip->fieldUpdate = TRUE;
+                    }
+                    else
+                        if (p_ManipParams->u.hdr.custom)
+                        {
+                            p_Manip->opcode = HMAN_OC;
+                            p_Manip->muramAllocate = TRUE;
+                            p_Manip->custom = TRUE;
+                        }
             break;
-        case e_FM_PCD_MANIP_REASSEM :
+        case e_FM_PCD_MANIP_REASSEM:
             if (p_ManipParams->h_NextManip)
-                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("next manip with reassembly"));
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                             ("next manip with reassembly"));
             switch (p_ManipParams->u.reassem.hdr)
             {
                 case (HEADER_TYPE_IPv4):
-                    p_Manip->ipReassmParams.hdr = HEADER_TYPE_IPv4;
+                    p_Manip->reassmParams.hdr = HEADER_TYPE_IPv4;
+                    p_Manip->opcode = HMAN_OC_IP_REASSEMBLY;
                     break;
                 case (HEADER_TYPE_IPv6):
-                    p_Manip->ipReassmParams.hdr = HEADER_TYPE_IPv6;
+                    p_Manip->reassmParams.hdr = HEADER_TYPE_IPv6;
+                    p_Manip->opcode = HMAN_OC_IP_REASSEMBLY;
+                    break;
+#if (DPAA_VERSION >= 11)
+                case (HEADER_TYPE_CAPWAP):
+                    p_Manip->reassmParams.hdr = HEADER_TYPE_CAPWAP;
+                    p_Manip->opcode = HMAN_OC_CAPWAP_REASSEMBLY;
                     break;
+#endif /* (DPAA_VERSION >= 11) */
                 default:
-                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("header for reassembly"));
-             }
-            p_Manip->opcode = HMAN_OC_IP_REASSEMBLY;
+                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                                 ("header for reassembly"));
+            }
             break;
-        case e_FM_PCD_MANIP_FRAG :
+        case e_FM_PCD_MANIP_FRAG:
             if (p_ManipParams->h_NextManip)
-                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("next manip with fragmentation"));
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                             ("next manip with fragmentation"));
             switch (p_ManipParams->u.frag.hdr)
             {
                 case (HEADER_TYPE_IPv4):
                 case (HEADER_TYPE_IPv6):
+                    p_Manip->opcode = HMAN_OC_IP_FRAGMENTATION;
+                    break;
+#if (DPAA_VERSION >= 11)
+                case (HEADER_TYPE_CAPWAP):
+                    p_Manip->opcode = HMAN_OC_CAPWAP_FRAGMENTATION;
                     break;
+#endif /* (DPAA_VERSION >= 11) */
                 default:
-                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("header for fragmentation"));
-             }
-            p_Manip->opcode = HMAN_OC_IP_FRAGMENTATION;
+                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                                 ("header for fragmentation"));
+            }
             p_Manip->muramAllocate = TRUE;
             break;
-        case e_FM_PCD_MANIP_SPECIAL_OFFLOAD :
+        case e_FM_PCD_MANIP_SPECIAL_OFFLOAD:
             switch (p_ManipParams->u.specialOffload.type)
             {
                 case (e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC):
                     p_Manip->opcode = HMAN_OC_IPSEC_MANIP;
                     p_Manip->muramAllocate = TRUE;
                     break;
+#if (DPAA_VERSION >= 11)
+                case (e_FM_PCD_MANIP_SPECIAL_OFFLOAD_CAPWAP):
+                    p_Manip->opcode = HMAN_OC_CAPWAP_MANIP;
+                    p_Manip->muramAllocate = TRUE;
+                    break;
+#endif /* (DPAA_VERSION >= 11) */
                 default:
-                     RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("special offload type"));
+                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                                 ("special offload type"));
             }
             break;
-        default :
+        default:
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("manip type"));
     }
 
     return E_OK;
 }
-#endif /* not FM_CAPWAP_SUPPORT */
+#endif /* not (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
 
-#ifdef FM_CAPWAP_SUPPORT
-static t_Error UpdateIndxStats(t_Handle     h_FmPcd,
-                               t_Handle     h_FmPort,
-                               t_FmPcdManip *p_Manip)
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+
+static t_Error UpdateIndxStats(t_Handle h_FmPcd,
+        t_Handle h_FmPort,
+        t_FmPcdManip *p_Manip)
 {
-    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    uint32_t                tmpReg32 = 0;
-    t_AdOfTypeContLookup    *p_Ad;
-    t_FmPortGetSetCcParams  fmPortGetSetCcParams;
-    t_Error                 err;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t tmpReg32 = 0;
+    t_AdOfTypeContLookup *p_Ad;
+    t_FmPortGetSetCcParams fmPortGetSetCcParams;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
 
-    p_Ad    = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
     if (p_Manip->h_FmPcd != h_FmPcd)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE,
-                     ("handler of PCD previously was initiated by different value"));
+    RETURN_ERROR(MAJOR, E_INVALID_STATE,
+            ("handler of PCD previously was initiated by different value"));
 
     memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
 
@@ -2157,25 +2865,25 @@ static t_Error UpdateIndxStats(t_Handle     h_FmPcd,
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_CC;
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
         if (err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
         tmpReg32 = GET_UINT32(p_Ad->ccAdBase);
 
         p_Manip->p_StatsTbl =
-            (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                        (uint32_t)p_Manip->owner * FM_PCD_MANIP_INDEXED_STATS_ENTRY_SIZE,
-                                        4);
+        (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                (uint32_t)p_Manip->owner * FM_PCD_MANIP_INDEXED_STATS_ENTRY_SIZE,
+                4);
         if (!p_Manip->p_StatsTbl)
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Manipulation indexed statistics table"));
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Manipulation indexed statistics table"));
 
-        IOMemSet32(p_Manip->p_StatsTbl, 0,  (uint32_t)(p_Manip->owner * 4));
+        IOMemSet32(p_Manip->p_StatsTbl, 0, (uint32_t)(p_Manip->owner * 4));
 
         tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Manip->p_StatsTbl) - p_FmPcd->physicalMuramBase);
 
         if (p_Manip->cnia)
-            tmpReg32 |= FM_PCD_MANIP_INDEXED_STATS_CNIA;
+        tmpReg32 |= FM_PCD_MANIP_INDEXED_STATS_CNIA;
 
-        tmpReg32 |=  FM_PCD_MANIP_INDEXED_STATS_DPD;
+        tmpReg32 |= FM_PCD_MANIP_INDEXED_STATS_DPD;
         WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
     }
     else
@@ -2184,133 +2892,36 @@ static t_Error UpdateIndxStats(t_Handle     h_FmPcd,
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_CC;
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
         if (err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     return E_OK;
 }
 
-static t_Error GetPrOffsetByHeaderOrField(t_FmManipHdrInfo *p_HdrInfo, uint8_t *parseArrayOffset)
+static t_Error RmvHdrTillSpecLocNOrInsrtIntFrmHdr(t_FmPcdManipHdrRmvParams *p_ManipParams, t_FmPcdManip *p_Manip)
 {
-    e_NetHeaderType hdr         = p_HdrInfo->hdr;
-    e_FmPcdHdrIndex hdrIndex    = p_HdrInfo->hdrIndex;
-    bool            byField     = p_HdrInfo->byField;
-    t_FmPcdFields   field;
+    t_AdOfTypeContLookup *p_Ad;
+    uint32_t tmpReg32 = 0;
+    uint8_t prsArrayOffset = 0;
+    t_Error err;
 
-    if (byField)
-        field = p_HdrInfo->fullField;
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
 
-    if (byField)
-    {
-        switch (hdr)
-        {
-            case (HEADER_TYPE_ETH):
-                switch (field.eth)
-                {
-                    case (NET_HEADER_FIELD_ETH_TYPE):
-                        *parseArrayOffset = CC_PC_PR_ETYPE_LAST_OFFSET;
-                        break;
-                    default:
-                        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of the type Ethernet with this field not supported"));
-                }
-                break;
-            case (HEADER_TYPE_VLAN):
-                switch (field.vlan)
-                {
-                    case (NET_HEADER_FIELD_VLAN_TCI) :
-                        if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
-                            *parseArrayOffset = CC_PC_PR_VLAN1_OFFSET;
-                        else if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
-                             *parseArrayOffset = CC_PC_PR_VLAN2_OFFSET;
-                        break;
-                    default:
-                       RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of the type VLAN with this field not supported"));
-                }
-                break;
-           default:
-               RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of this header by field not supported"));
-        }
-    }
-    else
-    {
-        switch (hdr){
-             case (HEADER_TYPE_ETH):
-                 *parseArrayOffset = (uint8_t)CC_PC_PR_ETH_OFFSET;
-                break;
-            case (HEADER_TYPE_USER_DEFINED_SHIM1):
-                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM1_OFFSET;
-                break;
-            case (HEADER_TYPE_USER_DEFINED_SHIM2):
-                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM2_OFFSET;
-                break;
-            case (HEADER_TYPE_LLC_SNAP):
-                *parseArrayOffset = CC_PC_PR_USER_LLC_SNAP_OFFSET;
-                break;
-            case (HEADER_TYPE_PPPoE):
-                *parseArrayOffset = CC_PC_PR_PPPOE_OFFSET;
-                break;
-            case (HEADER_TYPE_MPLS):
-                 if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
-                        *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
-                else if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
-                        *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
-                break;
-            case (HEADER_TYPE_IPv4):
-            case (HEADER_TYPE_IPv6):
-              if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
-                    *parseArrayOffset = CC_PC_PR_IP1_OFFSET;
-              else if (hdrIndex == e_FM_PCD_HDR_INDEX_2)
-                    *parseArrayOffset = CC_PC_PR_IP_LAST_OFFSET;
-                break;
-            case (HEADER_TYPE_MINENCAP):
-                *parseArrayOffset = CC_PC_PR_MINENC_OFFSET;
-                break;
-            case (HEADER_TYPE_GRE):
-                *parseArrayOffset = CC_PC_PR_GRE_OFFSET;
-                break;
-            case (HEADER_TYPE_TCP):
-            case (HEADER_TYPE_UDP):
-            case (HEADER_TYPE_IPSEC_AH):
-            case (HEADER_TYPE_IPSEC_ESP):
-            case (HEADER_TYPE_DCCP):
-            case (HEADER_TYPE_SCTP):
-                *parseArrayOffset = CC_PC_PR_L4_OFFSET;
-                break;
-            case (HEADER_TYPE_CAPWAP):
-            case (HEADER_TYPE_CAPWAP_DTLS):
-                *parseArrayOffset = CC_PC_PR_NEXT_HEADER_OFFSET;
-                break;
-            default:
-                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of this header is not supported"));
-     }
-    }
-    return E_OK;
-}
-
-static t_Error RmvHdrTillSpecLocNOrInsrtIntFrmHdr(t_FmPcdManipHdrRmvParams  *p_ManipParams, t_FmPcdManip *p_Manip)
-{
-    t_AdOfTypeContLookup    *p_Ad;
-    uint32_t                tmpReg32 = 0;
-    uint8_t                 prsArrayOffset = 0;
-    t_Error                 err;
-
-    SANITY_CHECK_RETURN_ERROR(p_Manip,E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
-
-    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
-    if (p_Manip->rmv)
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    if (p_Manip->rmv)
     {
         err = GetPrOffsetByHeaderOrField(&p_ManipParams->u.byHdr.u.fromStartByHdr.hdrInfo, &prsArrayOffset);
         if (err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
         tmpReg32 |= (uint32_t)prsArrayOffset << 24;
         tmpReg32 |= HMAN_RMV_HDR;
     }
 
     if (p_Manip->insrt)
-        tmpReg32 |= HMAN_INSRT_INT_FRM_HDR;
+    tmpReg32 |= HMAN_INSRT_INT_FRM_HDR;
 
     tmpReg32 |= (uint32_t)HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
 
@@ -2322,14 +2933,14 @@ static t_Error RmvHdrTillSpecLocNOrInsrtIntFrmHdr(t_FmPcdManipHdrRmvParams  *p_M
 
     return E_OK;
 }
-#endif /* FM_CAPWAP_SUPPORT */
 
-static t_Error MvIntFrameHeaderFromFrameToBufferPrefix(t_FmPcdManip *p_Manip, bool caamUsed)
+static t_Error MvIntFrameHeaderFromFrameToBufferPrefix(t_FmPcdManip *p_Manip,
+        bool caamUsed)
 {
-    t_AdOfTypeContLookup    *p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
-    uint32_t                tmpReg32 = 0;
+    t_AdOfTypeContLookup *p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    uint32_t tmpReg32 = 0;
 
-    SANITY_CHECK_RETURN_ERROR(p_Ad,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Ad, E_INVALID_HANDLE);
 
     p_Manip->updateParams |= OFFSET_OF_PR | INTERNAL_CONTEXT_OFFSET;
 
@@ -2343,21 +2954,20 @@ static t_Error MvIntFrameHeaderFromFrameToBufferPrefix(t_FmPcdManip *p_Manip, bo
     *(uint32_t *)&p_Ad->pcAndOffsets = tmpReg32;
 
     if (caamUsed)
-        *(uint32_t *)&p_Ad->gmask = 0xf0000000;
+    *(uint32_t *)&p_Ad->gmask = 0xf0000000;
 
     return E_OK;
 }
 
-#ifdef FM_CAPWAP_SUPPORT
 static t_Error CapwapRmvDtlsHdr(t_FmPcd *p_FmPcd, t_FmPcdManip *p_Manip)
 {
-    t_AdOfTypeContLookup    *p_Ad;
-    uint32_t                tmpReg32 = 0;
-    t_Error                 err = E_OK;
+    t_AdOfTypeContLookup *p_Ad;
+    uint32_t tmpReg32 = 0;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
 
-    p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
 
     tmpReg32 = 0;
     tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
@@ -2378,17 +2988,18 @@ static t_Error CapwapRmvDtlsHdr(t_FmPcd *p_FmPcd, t_FmPcdManip *p_Manip)
     return err;
 }
 
-static t_Error CapwapReassembly(t_CapwapReassemblyParams    *p_ManipParams,
-                                t_FmPcdManip                *p_Manip,
-                                t_FmPcd                     *p_FmPcd,
-                                uint8_t                     poolId)
+static t_Error CapwapReassembly(t_CapwapReassemblyParams *p_ManipParams,
+        t_FmPcdManip *p_Manip,
+        t_FmPcd *p_FmPcd,
+        uint8_t poolId)
 {
-    t_Handle    p_Table;
-    uint32_t    tmpReg32 = 0;
-    int         i = 0;
-    uint8_t     log2Num;
-    uint8_t     numOfSets;
-    uint32_t    j = 0;
+    t_Handle p_Table;
+    uint32_t tmpReg32 = 0;
+    int i = 0;
+    uint8_t log2Num;
+    uint8_t numOfSets;
+    uint32_t j = 0;
+    uint32_t bitFor1Micro;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
@@ -2404,40 +3015,43 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams    *p_ManipParams,
     if (p_ManipParams->numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH)
     {
         if ((p_ManipParams->maxNumFramesInProcess < 4) ||
-            (p_ManipParams->maxNumFramesInProcess > 512))
-            RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("In the case of numOfFramesPerHashEntry = e_FM_PCD_MANIP_EIGHT_WAYS_HASH maxNumFramesInProcess has to be in the range 4-512"));
+                (p_ManipParams->maxNumFramesInProcess > 512))
+        RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("In the case of numOfFramesPerHashEntry = e_FM_PCD_MANIP_EIGHT_WAYS_HASH maxNumFramesInProcess has to be in the range 4-512"));
     }
     else
     {
         if ((p_ManipParams->maxNumFramesInProcess < 8) ||
-            (p_ManipParams->maxNumFramesInProcess > 2048))
-            RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("In the case of numOfFramesPerHashEntry = e_FM_PCD_MANIP_FOUR_WAYS_HASH maxNumFramesInProcess has to be in the range 8-2048"));
+                (p_ManipParams->maxNumFramesInProcess > 2048))
+        RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("In the case of numOfFramesPerHashEntry = e_FM_PCD_MANIP_FOUR_WAYS_HASH maxNumFramesInProcess has to be in the range 8-2048"));
     }
 
+    bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
+    if (bitFor1Micro == 0)
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Timestamp scale"));
+
     p_Manip->updateParams |= (NUM_OF_TASKS | OFFSET_OF_PR | OFFSET_OF_DATA | HW_PORT_ID);
 
     p_Manip->h_Frag = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                                  FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE,
-                                                  FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN);
+            FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE,
+            FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN);
     if (!p_Manip->h_Frag)
-         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc CAPWAP reassembly parameters table"));
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc CAPWAP reassembly parameters table"));
 
-    IOMemSet32(p_Manip->h_Frag, 0,  FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE);
+    IOMemSet32(p_Manip->h_Frag, 0, FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE);
 
     p_Table = (t_CapwapReasmPram *)p_Manip->h_Frag;
 
-    p_Manip->fragParams.p_AutoLearnHashTbl =
-        (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                    (uint32_t)(p_ManipParams->maxNumFramesInProcess * 2 * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE),
-                                    FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN);
+    p_Manip->capwapFragParams.p_AutoLearnHashTbl =
+    (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+            (uint32_t)(p_ManipParams->maxNumFramesInProcess * 2 * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE),
+            FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN);
 
-    if (!p_Manip->fragParams.p_AutoLearnHashTbl)
+    if (!p_Manip->capwapFragParams.p_AutoLearnHashTbl)
         RETURN_ERROR(MAJOR, E_NO_MEMORY,("MURAM alloc for CAPWAP automatic learning hash table"));
 
-    IOMemSet32(p_Manip->fragParams.p_AutoLearnHashTbl, 0,  (uint32_t)(p_ManipParams->maxNumFramesInProcess * 2 * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE));
-
+    IOMemSet32(p_Manip->capwapFragParams.p_AutoLearnHashTbl, 0, (uint32_t)(p_ManipParams->maxNumFramesInProcess * 2 * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE));
 
-    tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_AutoLearnHashTbl) - p_FmPcd->physicalMuramBase);
+    tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->capwapFragParams.p_AutoLearnHashTbl) - p_FmPcd->physicalMuramBase);
 
     WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->autoLearnHashTblPtr, tmpReg32);
 
@@ -2445,14 +3059,14 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams    *p_ManipParams,
     if (p_ManipParams->timeOutMode == e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES)
         tmpReg32 |= FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_BETWEEN_FRAMES;
     if (p_ManipParams->haltOnDuplicationFrag)
-        tmpReg32  |= FM_PCD_MANIP_CAPWAP_REASM_HALT_ON_DUPLICATE_FRAG;
+        tmpReg32 |= FM_PCD_MANIP_CAPWAP_REASM_HALT_ON_DUPLICATE_FRAG;
     if (p_ManipParams->numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH)
     {
         i = 8;
-        tmpReg32  |= FM_PCD_MANIP_CAPWAP_REASM_AUTOMATIC_LEARNIN_HASH_8_WAYS;
+        tmpReg32 |= FM_PCD_MANIP_CAPWAP_REASM_AUTOMATIC_LEARNIN_HASH_8_WAYS;
     }
     else
-        i = 4;
+    i = 4;
 
     numOfSets = (uint8_t)((p_ManipParams->maxNumFramesInProcess * 2) / i);
     LOG2(numOfSets, log2Num);
@@ -2461,8 +3075,8 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams    *p_ManipParams,
     WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->mode, tmpReg32);
 
     for (j=0; j<p_ManipParams->maxNumFramesInProcess*2; j++)
-        if (((j / i)  % 2)== 0)
-            WRITE_UINT32(*(uint32_t *)PTR_MOVE(p_Manip->fragParams.p_AutoLearnHashTbl, j * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE), 0x80000000);
+        if (((j / i) % 2)== 0)
+            WRITE_UINT32(*(uint32_t *)PTR_MOVE(p_Manip->capwapFragParams.p_AutoLearnHashTbl, j * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE), 0x80000000);
 
     tmpReg32 = 0x00008000;
     tmpReg32 |= (uint32_t)poolId << 16;
@@ -2470,28 +3084,28 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams    *p_ManipParams,
     WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->risc23SetIndexes, 0x80008000);
     WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->risc4SetIndexesAndExtendedStatsTblPtr, 0x80000000);
 
-    p_Manip->fragParams.maxNumFramesInProcess = p_ManipParams->maxNumFramesInProcess;
+    p_Manip->capwapFragParams.maxNumFramesInProcess = p_ManipParams->maxNumFramesInProcess;
 
-    p_Manip->fragParams.sgBpid =  poolId;
+    p_Manip->capwapFragParams.sgBpid = poolId;
 
-    p_Manip->fragParams.fqidForTimeOutFrames = p_ManipParams->fqidForTimeOutFrames;
-    p_Manip->fragParams.timeoutRoutineRequestTime = p_ManipParams->timeoutRoutineRequestTime;
-    p_Manip->fragParams.bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
+    p_Manip->capwapFragParams.fqidForTimeOutFrames = p_ManipParams->fqidForTimeOutFrames;
+    p_Manip->capwapFragParams.timeoutRoutineRequestTime = p_ManipParams->timeoutRoutineRequestTime;
+    p_Manip->capwapFragParams.bitFor1Micro = bitFor1Micro;
 
     tmpReg32 = 0;
-    tmpReg32 |= (((uint32_t)1<<p_Manip->fragParams.bitFor1Micro) * p_ManipParams->timeoutThresholdForReassmProcess);
+    tmpReg32 |= (((uint32_t)1<<p_Manip->capwapFragParams.bitFor1Micro) * p_ManipParams->timeoutThresholdForReassmProcess);
     WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->expirationDelay, tmpReg32);
 
     return E_OK;
 }
 
-static t_Error CapwapFragmentation(t_CapwapFragmentationParams  *p_ManipParams,
-                                   t_FmPcdManip                 *p_Manip,
-                                   t_FmPcd                      *p_FmPcd,
-                                   uint8_t                      poolId)
+static t_Error CapwapFragmentation(t_CapwapFragmentationParams *p_ManipParams,
+        t_FmPcdManip *p_Manip,
+        t_FmPcd *p_FmPcd,
+        uint8_t poolId)
 {
-    t_AdOfTypeContLookup    *p_Ad;
-    uint32_t                tmpReg32 = 0;
+    t_AdOfTypeContLookup *p_Ad;
+    uint32_t tmpReg32 = 0;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
 
@@ -2500,12 +3114,12 @@ static t_Error CapwapFragmentation(t_CapwapFragmentationParams  *p_ManipParams,
     p_Manip->frag = TRUE;
 
     p_Manip->h_Frag = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                                  FM_PCD_CC_AD_ENTRY_SIZE,
-                                                  FM_PCD_CC_AD_TABLE_ALIGN);
+            FM_PCD_CC_AD_ENTRY_SIZE,
+            FM_PCD_CC_AD_TABLE_ALIGN);
     if (!p_Manip->h_Frag)
-         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP fragmentation table descriptor"));
+    RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP fragmentation table descriptor"));
 
-    IOMemSet32(p_Manip->h_Frag, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+    IOMemSet32(p_Manip->h_Frag, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
     p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
 
@@ -2513,7 +3127,7 @@ static t_Error CapwapFragmentation(t_CapwapFragmentationParams  *p_ManipParams,
     tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_FRAGMENTATION;
 
     if (p_ManipParams->headerOptionsCompr)
-        tmpReg32 |= FM_PCD_MANIP_CAPWAP_FRAG_COMPR_OPTION_FIELD_EN;
+    tmpReg32 |= FM_PCD_MANIP_CAPWAP_FRAG_COMPR_OPTION_FIELD_EN;
     tmpReg32 |= ((uint32_t)poolId << 8);
     WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
 
@@ -2522,39 +3136,292 @@ static t_Error CapwapFragmentation(t_CapwapFragmentationParams  *p_ManipParams,
     WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
 
     p_Manip->sizeForFragmentation = p_ManipParams->sizeForFragmentation;
-    p_Manip->fragParams.sgBpid = poolId;
+    p_Manip->capwapFragParams.sgBpid = poolId;
 
     return E_OK;
 }
-#endif /* FM_CAPWAP_SUPPORT */
 
-static t_Error FillReassmManipParams(t_FmPcdManip *p_Manip, bool ipv4)
+static t_Error IndxStats(t_FmPcdStatsParams *p_StatsParams,t_FmPcdManip *p_Manip,t_FmPcd *p_FmPcd)
 {
     t_AdOfTypeContLookup *p_Ad;
-    t_FmPcd              *p_FmPcd   = (t_FmPcd *)p_Manip->h_FmPcd;
-    uint32_t             tmpReg32;
-    t_Error              err = E_OK;
+    uint32_t tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+
+    UNUSED(p_FmPcd);
+
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+
+    tmpReg32 = 0;
+    tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_INDEXED_STATS;
+    if (p_StatsParams->type == e_FM_PCD_STATS_PER_FLOWID)
+    tmpReg32 |= (uint32_t)0x16 << 16;
+    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
+
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
+
+    return E_OK;
+}
+
+static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams *p_ManipParams, t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+{
+    t_FmPcdManipHdrInsrtByTemplateParams *p_InsrtByTemplate = &p_ManipParams->u.byTemplate;
+    uint8_t tmpReg8 = 0xff;
+    t_AdOfTypeContLookup *p_Ad;
+    bool ipModify = FALSE;
+    uint32_t tmpReg32 = 0, tmpRegNia = 0;
+    uint16_t tmpReg16 = 0;
+    t_Error err = E_OK;
+    uint8_t extraAddedBytes = 0, blockSize = 0, extraAddedBytesAlignedToBlockSize = 0, log2Num = 0;
+    uint8_t *p_Template = NULL;
+
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_NULL_POINTER);
+
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    if (p_Manip->insrt)
+    {
+        if ((!p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterIp) ||
+                (!p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterVlan))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : asking for header template modifications with no template for insertion (template size)"));
+
+        if (p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterIp && (p_InsrtByTemplate->size <= p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : size of template < ipOuterOffset"));
+
+        if (p_InsrtByTemplate->size > 128)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Size of header template for insertion can not be more than 128"));
+
+        if (p_InsrtByTemplate->size)
+        {
+            p_Manip->p_Template = (uint8_t *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                    p_InsrtByTemplate->size,
+                    FM_PCD_CC_AD_TABLE_ALIGN);
+            if(!p_Manip->p_Template)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+            tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->p_Template) - (p_FmPcd->physicalMuramBase));
+            tmpReg32 |= (uint32_t)p_InsrtByTemplate->size << 24;
+            *(uint32_t *)&p_Ad->matchTblPtr = tmpReg32;
+        }
 
-    /* Creates the IP Reassembly Parameters table. It contains parameters that are specific to either the IPv4 reassembly
+        tmpReg32 = 0;
+
+        p_Template = (uint8_t *)XX_Malloc(p_InsrtByTemplate->size * sizeof(uint8_t));
+
+        if (!p_Template)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("XX_Malloc allocation FAILED"));
+
+        memcpy(p_Template, p_InsrtByTemplate->hdrTemplate, p_InsrtByTemplate->size * sizeof(uint8_t));
+
+        if (p_InsrtByTemplate->modifyOuterIp)
+        {
+            ipModify = TRUE;
+
+            tmpReg8 = (uint8_t)p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset];
+
+            if((tmpReg8 & 0xf0) == 0x40)
+            tmpReg8 = 4;
+            else if((tmpReg8 & 0xf0) == 0x60)
+            tmpReg8 = 6;
+            else
+            tmpReg8 = 0xff;
+
+            if (tmpReg8 != 0xff)
+            {
+                if(p_InsrtByTemplate->modifyOuterIpParams.dscpEcn & 0xff00)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : IPV4 present in header template, dscpEcn has to be only 1 byte"));
+                if(p_InsrtByTemplate->modifyOuterIpParams.recalculateLength)
+                {
+
+                    if((p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize) > 255)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("extra Byte added can not be more than 256 bytes"));
+                    extraAddedBytes = (uint8_t) (p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize);
+                    blockSize = p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.blockSize;
+                    extraAddedBytesAlignedToBlockSize = p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize;
+                    /*IP header template - IP totalLength -
+                     (1 byte) extraByteForIp = headerTemplateSize - ipOffset + insertedBytesAfterThisStage ,
+                     in the case of SEC insertedBytesAfterThisStage - SEC trailer (21/31) + header(13)
+                     second byte - extraByteForIp = headerTemplate - ipOffset + insertedBytesAfterThisStage*/
+                }
+                if (blockSize)
+                {
+                    if (!POWER_OF_2(blockSize))
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("inputFrmPaddingUpToBlockSize has to be power of 2"));
+                }
+
+            }
+            if (tmpReg8 == 4)
+            {
+                if ((IPv4_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset) > p_InsrtByTemplate->size)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : IP present in header template, user asked for IP modifications but ipOffset + ipTotalLengthFieldOffset in header template bigger than template size"));
+
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_DSCECN_FIELD_OFFSET_FROM_IP] = (uint8_t)p_InsrtByTemplate->modifyOuterIpParams.dscpEcn;
+
+                if (blockSize)
+                blockSize -= 1;
+
+                if ((p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes) > 255)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes has to be less than 255"));
+
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_TOTALLENGTH_FIELD_OFFSET_FROM_IP + 1] = blockSize; // IPV6 - in AD instead of SEQ IND
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_TOTALLENGTH_FIELD_OFFSET_FROM_IP] = (uint8_t)(p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes);// for IPV6 decrement additional 40 bytes of IPV6 heade size
+
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_ID_FIELD_OFFSET_FROM_IP] = 0x00;
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_ID_FIELD_OFFSET_FROM_IP + 1] = extraAddedBytesAlignedToBlockSize;
+
+                /*IP header template - relevant only for ipv4 CheckSum = 0*/
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_HDRCHECKSUM_FIELD_OFFSET_FROM_IP] = 0x00;
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + 1] = 0x00;
+
+                /*UDP checksum has to be 0*/
+                if (p_InsrtByTemplate->modifyOuterIpParams.udpPresent)
+                {
+                    if ((p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP + UDP_CHECKSUM_FIELD_SIZE) > p_InsrtByTemplate->size)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : UDP present according to user but (UDP offset + UDP header size) < size of header template"));
+
+                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP ] = 0x00;
+                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP + 1] = 0x00;
+
+                }
+
+                if (p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId > 7)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("ipIdentGenId has to be one out of 8 sequence number generators (0 - 7) for IP identification field"));
+
+                tmpRegNia |= (uint32_t)p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId<<24;
+            }
+            else if (tmpReg8 == 6)
+            {
+                /*TODO - add check for maximum value of blockSize;*/
+                if (blockSize)
+                LOG2(blockSize, log2Num);
+                tmpRegNia |= (uint32_t)log2Num << 24;
+
+                // for IPV6 decrement additional 40 bytes of IPV6 heade size - because IPV6 header size is not included in payloadLength
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv6_PAYLOAD_LENGTH_OFFSET_FROM_IP] = (uint8_t)(p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes - 40);
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv6_PAYLOAD_LENGTH_OFFSET_FROM_IP + 1] = extraAddedBytesAlignedToBlockSize;
+                if (p_InsrtByTemplate->modifyOuterIpParams.udpPresent)
+                {
+                    if ((p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP + UDP_CHECKSUM_FIELD_SIZE) > p_InsrtByTemplate->size)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : UDP present according to user but (UDP offset + UDP header size) < size of header template"));
+                    if (p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv6_NEXT_HEADER_OFFSET_FROM_IP] != 0x88)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("OUr suppport is only IPv6/UDPLite"));
+                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_LENGTH_FIELD_OFFSET_FROM_UDP] = 0x00;
+                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_LENGTH_FIELD_OFFSET_FROM_UDP + 1] = 0x08;
+                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP] = 0x00;
+                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP + 1] = 0x00;
+                }
+            }
+            else
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("IP version supported only IPV4"));
+        }
+
+        tmpReg32 = tmpReg16 = tmpReg8 = 0;
+        /*TODO - check it*/
+        if (p_InsrtByTemplate->modifyOuterVlan)
+        {
+            if (p_InsrtByTemplate->modifyOuterVlanParams.vpri & ~0x07)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,("Inconsistent parameters : user asked for VLAN modifications but VPRI more than 3 bits"));
+
+            memcpy(&tmpReg16, &p_Template[VLAN_TAG_FIELD_OFFSET_FROM_ETH], 2*(sizeof(uint8_t)));
+            if ((tmpReg16 != 0x9100) && (tmpReg16!= 0x9200) && (tmpReg16 != 0x8100))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,("Inconsistent parameters : user asked for VLAN modifications but Tag Protocol identifier is not VLAN "));
+
+            memcpy(&tmpReg8, &p_Template[14],1*(sizeof(uint8_t)));
+            tmpReg8 &= 0x1f;
+            tmpReg8 |= (uint8_t)(p_InsrtByTemplate->modifyOuterVlanParams.vpri << 5);
+
+            p_Template[14] = tmpReg8;
+        }
+
+        Mem2IOCpy32(p_Manip->p_Template, p_Template, p_InsrtByTemplate->size);
+
+        XX_Free(p_Template);
+    }
+
+    tmpReg32 = 0;
+    if (p_Manip->h_Frag)
+    {
+        tmpRegNia |= (uint32_t)(XX_VirtToPhys(p_Manip->h_Frag) - (p_FmPcd->physicalMuramBase));
+        tmpReg32 |= (uint32_t)p_Manip->sizeForFragmentation << 16;
+    }
+    else
+    tmpReg32 = 0xffff0000;
+
+    if (ipModify)
+    tmpReg32 |= (uint32_t)p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset << 8;
+    else
+    tmpReg32 |= (uint32_t)0x0000ff00;
+
+    tmpReg32 |= (uint32_t)HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
+    *(uint32_t *)&p_Ad->pcAndOffsets = tmpReg32;
+
+    tmpRegNia |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    *(uint32_t *)&p_Ad->ccAdBase = tmpRegNia;
+
+    return err;
+}
+
+static t_Error CheckStatsParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdStatsParams *p_StatsParams)
+{
+
+    switch (p_StatsParams->type)
+    {
+        case (e_FM_PCD_STATS_PER_FLOWID):
+        p_Manip->opcode = HMAN_OC_CAPWAP_INDEXED_STATS;
+        p_Manip->muramAllocate = TRUE;
+        break;
+        default:
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported statistics type"));
+    }
+
+    return E_OK;
+}
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
+
+static t_Error FillReassmManipParams(t_FmPcdManip *p_Manip, e_NetHeaderType hdr)
+{
+    t_AdOfTypeContLookup *p_Ad;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
+    uint32_t tmpReg32;
+    t_Error err = E_OK;
+
+    /* Creates the Reassembly Parameters table. It contains parameters that are specific to either the IPv4 reassembly
      function or to the IPv6 reassembly function. If both IPv4 reassembly and IPv6 reassembly are required, then
      two separate IP Reassembly Parameter tables are required.*/
-    if ((err = CreateIpReassTable(p_Manip, ipv4)) != E_OK)
+    if ((err = CreateReassTable(p_Manip, hdr)) != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    /* Sets the first Ad register (ccAdBase) - Action Descriptor Type and Pointer to the IP Reassembly Parameters Table offset from MURAM*/
+    /* Sets the first Ad register (ccAdBase) - Action Descriptor Type and Pointer to the Reassembly Parameters Table offset from MURAM*/
     tmpReg32 = 0;
     tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
 
     /* Gets the required Action descriptor table pointer */
-    if (ipv4)
-    {
-        p_Ad = (t_AdOfTypeContLookup *)p_Manip->ipReassmParams.h_Ipv4Ad;
-        tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Manip->ipReassmParams.p_Ipv4ReassTbl) - (p_FmPcd->physicalMuramBase));
-    }
-    else
+    switch (hdr)
     {
-        p_Ad = (t_AdOfTypeContLookup *)p_Manip->ipReassmParams.h_Ipv6Ad;
-        tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Manip->ipReassmParams.p_Ipv6ReassTbl) - (p_FmPcd->physicalMuramBase));
+        case HEADER_TYPE_IPv4:
+            p_Ad = (t_AdOfTypeContLookup *)p_Manip->reassmParams.ip.h_Ipv4Ad;
+            tmpReg32 |= (uint32_t)(XX_VirtToPhys(
+                    p_Manip->reassmParams.ip.p_Ipv4ReassTbl)
+                    - (p_FmPcd->physicalMuramBase));
+            break;
+        case HEADER_TYPE_IPv6:
+            p_Ad = (t_AdOfTypeContLookup *)p_Manip->reassmParams.ip.h_Ipv6Ad;
+            tmpReg32 |= (uint32_t)(XX_VirtToPhys(
+                    p_Manip->reassmParams.ip.p_Ipv6ReassTbl)
+                    - (p_FmPcd->physicalMuramBase));
+            break;
+        case HEADER_TYPE_CAPWAP:
+            p_Ad = (t_AdOfTypeContLookup *)p_Manip->reassmParams.capwap.h_Ad;
+            tmpReg32 |= (uint32_t)(XX_VirtToPhys(
+                    p_Manip->reassmParams.capwap.p_ReassTbl)
+                    - (p_FmPcd->physicalMuramBase));
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("header type"));
     }
 
     WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
@@ -2563,21 +3430,33 @@ static t_Error FillReassmManipParams(t_FmPcdManip *p_Manip, bool ipv4)
     /* mark the Scatter/Gather table offset to be set later on when the port will be known */
     p_Manip->updateParams = (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK);
 
+    if ((hdr == HEADER_TYPE_IPv6) || (hdr == HEADER_TYPE_IPv4))
+    {
 #if (DPAA_VERSION == 10)
-    tmpReg32 = (uint32_t)(p_Manip->ipReassmParams.sgBpid << 8);
-    WRITE_UINT32(p_Ad->matchTblPtr, tmpReg32);
+        tmpReg32 = (uint32_t)(p_Manip->reassmParams.sgBpid << 8);
+        WRITE_UINT32(p_Ad->matchTblPtr, tmpReg32);
 #endif /* (DPAA_VERSION == 10) */
 #if (DPAA_VERSION >= 11)
-    if (p_Manip->ipReassmParams.nonConsistentSpFqid != 0)
-    {
-        tmpReg32 = FM_PCD_AD_NCSPFQIDM_MASK | (uint32_t)(p_Manip->ipReassmParams.nonConsistentSpFqid);
-        WRITE_UINT32(p_Ad->gmask, tmpReg32);
+        if (p_Manip->reassmParams.ip.nonConsistentSpFqid != 0)
+        {
+            tmpReg32 = FM_PCD_AD_NCSPFQIDM_MASK
+                    | (uint32_t)(p_Manip->reassmParams.ip.nonConsistentSpFqid);
+            WRITE_UINT32(p_Ad->gmask, tmpReg32);
+        }
+#endif /* (DPAA_VERSION >= 11) */
+        /* Sets the third Ad register (pcAndOffsets)- IP Reassemble Operation Code*/
+        tmpReg32 = 0;
+        tmpReg32 |= (uint32_t)HMAN_OC_IP_REASSEMBLY;
     }
+#if (DPAA_VERSION >= 11)
+    else
+        if (hdr == HEADER_TYPE_CAPWAP)
+        {
+            tmpReg32 = 0;
+            tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_REASSEMBLY;
+        }
 #endif /* (DPAA_VERSION >= 11) */
 
-    /* Sets the third Ad register (pcAndOffsets)- IP Reassemble Operation Code*/
-    tmpReg32 = 0;
-    tmpReg32 |= (uint32_t)HMAN_OC_IP_REASSEMBLY;
     WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
 
     p_Manip->reassm = TRUE;
@@ -2590,20 +3469,20 @@ static t_Error SetIpv4ReassmManip(t_FmPcdManip *p_Manip)
     t_FmPcd *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
 
     /* Allocation if IPv4 Action descriptor */
-    p_Manip->ipReassmParams.h_Ipv4Ad =
-        (t_Handle)XX_MallocSmart(FM_PCD_CC_AD_ENTRY_SIZE,
-                                 p_Manip->ipReassmParams.dataMemId,
-                                 FM_PCD_CC_AD_TABLE_ALIGN);
-    if (!p_Manip->ipReassmParams.h_Ipv4Ad)
+    p_Manip->reassmParams.ip.h_Ipv4Ad = (t_Handle)XX_MallocSmart(
+            FM_PCD_CC_AD_ENTRY_SIZE, p_Manip->reassmParams.dataMemId,
+            FM_PCD_CC_AD_TABLE_ALIGN);
+    if (!p_Manip->reassmParams.ip.h_Ipv4Ad)
     {
         ReleaseManipHandler(p_Manip, p_FmPcd);
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of IPv4 table descriptor"));
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("Allocation of IPv4 table descriptor"));
     }
 
-    memset(p_Manip->ipReassmParams.h_Ipv4Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+    memset(p_Manip->reassmParams.ip.h_Ipv4Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
     /* Fill reassembly manipulation parameter in the IP Reassembly Action Descriptor */
-    return FillReassmManipParams(p_Manip, TRUE);
+    return FillReassmManipParams(p_Manip, HEADER_TYPE_IPv4);
 }
 
 static t_Error SetIpv6ReassmManip(t_FmPcdManip *p_Manip)
@@ -2611,74 +3490,90 @@ static t_Error SetIpv6ReassmManip(t_FmPcdManip *p_Manip)
     t_FmPcd *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
 
     /* Allocation if IPv6 Action descriptor */
-     p_Manip->ipReassmParams.h_Ipv6Ad =
-        (t_Handle)XX_MallocSmart(FM_PCD_CC_AD_ENTRY_SIZE,
-                                 p_Manip->ipReassmParams.dataMemId,
-                                 FM_PCD_CC_AD_TABLE_ALIGN);
-     if (!p_Manip->ipReassmParams.h_Ipv6Ad)
-     {
+    p_Manip->reassmParams.ip.h_Ipv6Ad = (t_Handle)XX_MallocSmart(
+            FM_PCD_CC_AD_ENTRY_SIZE, p_Manip->reassmParams.dataMemId,
+            FM_PCD_CC_AD_TABLE_ALIGN);
+    if (!p_Manip->reassmParams.ip.h_Ipv6Ad)
+    {
         ReleaseManipHandler(p_Manip, p_FmPcd);
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of IPv6 table descriptor"));
-     }
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("Allocation of IPv6 table descriptor"));
+    }
 
-    memset(p_Manip->ipReassmParams.h_Ipv6Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+    memset(p_Manip->reassmParams.ip.h_Ipv6Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
     /* Fill reassembly manipulation parameter in the IP Reassembly Action Descriptor */
-    return FillReassmManipParams(p_Manip, FALSE);
+    return FillReassmManipParams(p_Manip, HEADER_TYPE_IPv6);
 }
 
-static t_Error IpReassembly(t_FmPcdManipReassemParams   *p_ManipReassmParams,
-                            t_FmPcdManip                *p_Manip)
+static t_Error IpReassembly(t_FmPcdManipReassemParams *p_ManipReassmParams,
+                            t_FmPcdManip *p_Manip)
 {
-    uint32_t                    maxSetNumber = 10000;
-    t_FmPcdManipReassemIpParams reassmManipParams = p_ManipReassmParams->u.ipReassem;
-    t_Error                     res;
+    uint32_t maxSetNumber = 10000;
+    t_FmPcdManipReassemIpParams reassmManipParams =
+            p_ManipReassmParams->u.ipReassem;
+    t_Error res;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(((t_FmPcd *)p_Manip->h_FmPcd)->h_Hc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(((t_FmPcd *)p_Manip->h_FmPcd)->h_Hc,
+                              E_INVALID_HANDLE);
 
     /* Check validation of user's parameter.*/
-    if ((reassmManipParams.timeoutThresholdForReassmProcess < 1000) ||
-        (reassmManipParams.timeoutThresholdForReassmProcess > 8000000))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("timeoutThresholdForReassmProcess should be 1msec - 8sec"));
+    if ((reassmManipParams.timeoutThresholdForReassmProcess < 1000)
+            || (reassmManipParams.timeoutThresholdForReassmProcess > 8000000))
+        RETURN_ERROR(
+                MAJOR, E_INVALID_VALUE,
+                ("timeoutThresholdForReassmProcess should be 1msec - 8sec"));
     /* It is recommended that the total number of entries in this table (number of sets * number of ways)
-       will be twice the number of frames that are expected to be reassembled simultaneously.*/
-    if (reassmManipParams.maxNumFramesInProcess >
-        (reassmManipParams.maxNumFramesInProcess * maxSetNumber / 2))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxNumFramesInProcess has to be less than (maximun set number * number of ways / 2)"));
-
-    if ((p_ManipReassmParams->hdr == HEADER_TYPE_IPv6) &&
-        (reassmManipParams.minFragSize[1] < 256))
+     will be twice the number of frames that are expected to be reassembled simultaneously.*/
+    if (reassmManipParams.maxNumFramesInProcess
+            > (reassmManipParams.maxNumFramesInProcess * maxSetNumber / 2))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("maxNumFramesInProcess has to be less than (maximun set number * number of ways / 2)"));
+
+    if ((p_ManipReassmParams->hdr == HEADER_TYPE_IPv6)
+            && (reassmManipParams.minFragSize[1] < 256))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("minFragSize[1] must be >= 256"));
 
     /* Saves user's reassembly manipulation parameters */
-    p_Manip->ipReassmParams.relativeSchemeId[0] = reassmManipParams.relativeSchemeId[0];
-    p_Manip->ipReassmParams.relativeSchemeId[1] = reassmManipParams.relativeSchemeId[1];
-    p_Manip->ipReassmParams.numOfFramesPerHashEntry[0] = reassmManipParams.numOfFramesPerHashEntry[0];
-    p_Manip->ipReassmParams.numOfFramesPerHashEntry[1] = reassmManipParams.numOfFramesPerHashEntry[1];
-    p_Manip->ipReassmParams.minFragSize[0] = reassmManipParams.minFragSize[0];
-    p_Manip->ipReassmParams.minFragSize[1] = reassmManipParams.minFragSize[1];
-    p_Manip->ipReassmParams.maxNumFramesInProcess = reassmManipParams.maxNumFramesInProcess;
-    p_Manip->ipReassmParams.timeOutMode = reassmManipParams.timeOutMode;
-    p_Manip->ipReassmParams.fqidForTimeOutFrames = reassmManipParams.fqidForTimeOutFrames;
-    p_Manip->ipReassmParams.timeoutThresholdForReassmProcess = reassmManipParams.timeoutThresholdForReassmProcess;
-    p_Manip->ipReassmParams.dataMemId = reassmManipParams.dataMemId;
-    p_Manip->ipReassmParams.dataLiodnOffset = reassmManipParams.dataLiodnOffset;
+    p_Manip->reassmParams.ip.relativeSchemeId[0] =
+            reassmManipParams.relativeSchemeId[0];
+    p_Manip->reassmParams.ip.relativeSchemeId[1] =
+            reassmManipParams.relativeSchemeId[1];
+    p_Manip->reassmParams.ip.numOfFramesPerHashEntry[0] =
+            reassmManipParams.numOfFramesPerHashEntry[0];
+    p_Manip->reassmParams.ip.numOfFramesPerHashEntry[1] =
+            reassmManipParams.numOfFramesPerHashEntry[1];
+    p_Manip->reassmParams.ip.minFragSize[0] = reassmManipParams.minFragSize[0];
+    p_Manip->reassmParams.ip.minFragSize[1] = reassmManipParams.minFragSize[1];
+    p_Manip->reassmParams.maxNumFramesInProcess =
+            reassmManipParams.maxNumFramesInProcess;
+    p_Manip->reassmParams.timeOutMode = reassmManipParams.timeOutMode;
+    p_Manip->reassmParams.fqidForTimeOutFrames =
+            reassmManipParams.fqidForTimeOutFrames;
+    p_Manip->reassmParams.timeoutThresholdForReassmProcess =
+            reassmManipParams.timeoutThresholdForReassmProcess;
+    p_Manip->reassmParams.dataMemId = reassmManipParams.dataMemId;
+    p_Manip->reassmParams.dataLiodnOffset = reassmManipParams.dataLiodnOffset;
 #if (DPAA_VERSION == 10)
-    p_Manip->ipReassmParams.sgBpid = reassmManipParams.sgBpid;
+    p_Manip->reassmParams.sgBpid = reassmManipParams.sgBpid;
 #endif /* (DPAA_VERSION == 10) */
 #if (DPAA_VERSION >= 11)
     if (reassmManipParams.nonConsistentSpFqid != 0)
     {
-        p_Manip->ipReassmParams.nonConsistentSpFqid = reassmManipParams.nonConsistentSpFqid;
+        p_Manip->reassmParams.ip.nonConsistentSpFqid =
+                reassmManipParams.nonConsistentSpFqid;
     }
 #endif /* (DPAA_VERSION >= 11) */
 
     /* Creates and initializes the IP Reassembly common parameter table */
-    CreateIpReassCommonTable(p_Manip);
+    CreateReassCommonTable(p_Manip);
 
     /* Creation of IPv4 reassembly manipulation */
-    if ((p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv6) || (p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv4))
+    if ((p_Manip->reassmParams.hdr == HEADER_TYPE_IPv6)
+            || (p_Manip->reassmParams.hdr == HEADER_TYPE_IPv4))
     {
         res = SetIpv4ReassmManip(p_Manip);
         if (res != E_OK)
@@ -2686,7 +3581,7 @@ static t_Error IpReassembly(t_FmPcdManipReassemParams   *p_ManipReassmParams,
     }
 
     /* Creation of IPv6 reassembly manipulation */
-    if (p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv6)
+    if (p_Manip->reassmParams.hdr == HEADER_TYPE_IPv6)
     {
         res = SetIpv6ReassmManip(p_Manip);
         if (res != E_OK)
@@ -2696,21 +3591,30 @@ static t_Error IpReassembly(t_FmPcdManipReassemParams   *p_ManipReassmParams,
     return E_OK;
 }
 
-static void setReassmSchemeParams(t_FmPcd* p_FmPcd, t_FmPcdKgSchemeParams *p_Scheme, t_Handle h_CcTree, bool ipv4, uint8_t groupId)
+static void setIpReassmSchemeParams(t_FmPcd* p_FmPcd,
+                                    t_FmPcdKgSchemeParams *p_Scheme,
+                                    t_Handle h_CcTree, bool ipv4,
+                                    uint8_t groupId)
 {
-    uint32_t    j;
-    uint8_t     res;
+    uint32_t j;
+    uint8_t res;
 
     /* Configures scheme's network environment parameters */
     p_Scheme->netEnvParams.numOfDistinctionUnits = 2;
     if (ipv4)
-        res = FmPcdNetEnvGetUnitId(p_FmPcd, FmPcdGetNetEnvId(p_Scheme->netEnvParams.h_NetEnv), HEADER_TYPE_IPv4, FALSE, 0);
+        res = FmPcdNetEnvGetUnitId(
+                p_FmPcd, FmPcdGetNetEnvId(p_Scheme->netEnvParams.h_NetEnv),
+                HEADER_TYPE_IPv4, FALSE, 0);
     else
-        res = FmPcdNetEnvGetUnitId(p_FmPcd, FmPcdGetNetEnvId(p_Scheme->netEnvParams.h_NetEnv), HEADER_TYPE_IPv6, FALSE, 0);
+        res = FmPcdNetEnvGetUnitId(
+                p_FmPcd, FmPcdGetNetEnvId(p_Scheme->netEnvParams.h_NetEnv),
+                HEADER_TYPE_IPv6, FALSE, 0);
     ASSERT_COND(res != FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
     p_Scheme->netEnvParams.unitIds[0] = res;
 
-    res = FmPcdNetEnvGetUnitId(p_FmPcd, FmPcdGetNetEnvId(p_Scheme->netEnvParams.h_NetEnv), HEADER_TYPE_USER_DEFINED_SHIM2, FALSE, 0);
+    res = FmPcdNetEnvGetUnitId(
+            p_FmPcd, FmPcdGetNetEnvId(p_Scheme->netEnvParams.h_NetEnv),
+            HEADER_TYPE_USER_DEFINED_SHIM2, FALSE, 0);
     ASSERT_COND(res != FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
     p_Scheme->netEnvParams.unitIds[1] = res;
 
@@ -2724,455 +3628,626 @@ static void setReassmSchemeParams(t_FmPcd* p_FmPcd, t_FmPcdKgSchemeParams *p_Sch
     if (ipv4 == TRUE)
     {
         p_Scheme->keyExtractAndHashParams.numOfUsedExtracts = 4;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].type = e_FM_PCD_EXTRACT_BY_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.hdr = HEADER_TYPE_IPv4 ;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_DST_IP;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].type = e_FM_PCD_EXTRACT_BY_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.hdr = HEADER_TYPE_IPv4;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_SRC_IP;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].type = e_FM_PCD_EXTRACT_BY_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.hdr = HEADER_TYPE_IPv4;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_PROTO;
-        p_Scheme->keyExtractAndHashParams.extractArray[3].type = e_FM_PCD_EXTRACT_BY_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.hdr = HEADER_TYPE_IPv4;
-        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.ignoreProtocolValidation = FALSE;
-        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.extractByHdrType.fromHdr.size = 2;
-        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.extractByHdrType.fromHdr.offset = 4;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].type =
+                e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.type =
+                e_FM_PCD_EXTRACT_FULL_FIELD;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.hdr =
+                HEADER_TYPE_IPv4;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.extractByHdrType.fullField.ipv4 =
+                NET_HEADER_FIELD_IPv4_DST_IP;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].type =
+                e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.type =
+                e_FM_PCD_EXTRACT_FULL_FIELD;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.hdr =
+                HEADER_TYPE_IPv4;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.extractByHdrType.fullField.ipv4 =
+                NET_HEADER_FIELD_IPv4_SRC_IP;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].type =
+                e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.type =
+                e_FM_PCD_EXTRACT_FULL_FIELD;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.hdr =
+                HEADER_TYPE_IPv4;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.extractByHdrType.fullField.ipv4 =
+                NET_HEADER_FIELD_IPv4_PROTO;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].type =
+                e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.hdr =
+                HEADER_TYPE_IPv4;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.type =
+                e_FM_PCD_EXTRACT_FROM_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.ignoreProtocolValidation =
+                FALSE;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.extractByHdrType.fromHdr.size =
+                2;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.extractByHdrType.fromHdr.offset =
+                4;
     }
     else /* IPv6 */
     {
         p_Scheme->keyExtractAndHashParams.numOfUsedExtracts = 3;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].type = e_FM_PCD_EXTRACT_BY_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.hdr = HEADER_TYPE_IPv6 ;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.extractByHdrType.fullField.ipv6 = NET_HEADER_FIELD_IPv6_DST_IP;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].type = e_FM_PCD_EXTRACT_BY_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.hdr = HEADER_TYPE_IPv6;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.extractByHdrType.fullField.ipv6 = NET_HEADER_FIELD_IPv6_SRC_IP;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].type = e_FM_PCD_EXTRACT_BY_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.hdr = HEADER_TYPE_USER_DEFINED_SHIM2;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.extractByHdrType.fromHdr.size  = 4;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.extractByHdrType.fromHdr.offset = 4;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.ignoreProtocolValidation = TRUE;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].type =
+                e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.type =
+                e_FM_PCD_EXTRACT_FULL_FIELD;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.hdr =
+                HEADER_TYPE_IPv6;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.extractByHdrType.fullField.ipv6 =
+                NET_HEADER_FIELD_IPv6_DST_IP;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].type =
+                e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.type =
+                e_FM_PCD_EXTRACT_FULL_FIELD;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.hdr =
+                HEADER_TYPE_IPv6;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.extractByHdrType.fullField.ipv6 =
+                NET_HEADER_FIELD_IPv6_SRC_IP;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].type =
+                e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.hdr =
+                HEADER_TYPE_USER_DEFINED_SHIM2;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.type =
+                e_FM_PCD_EXTRACT_FROM_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.extractByHdrType.fromHdr.size =
+                4;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.extractByHdrType.fromHdr.offset =
+                4;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.ignoreProtocolValidation =
+                TRUE;
     }
 
     p_Scheme->keyExtractAndHashParams.privateDflt0 = 0x01020304;
     p_Scheme->keyExtractAndHashParams.privateDflt1 = 0x11121314;
-    p_Scheme->keyExtractAndHashParams.numOfUsedDflts = FM_PCD_KG_NUM_OF_DEFAULT_GROUPS;
-    for (j=0; j<FM_PCD_KG_NUM_OF_DEFAULT_GROUPS; j++)
+    p_Scheme->keyExtractAndHashParams.numOfUsedDflts =
+            FM_PCD_KG_NUM_OF_DEFAULT_GROUPS;
+    for (j = 0; j < FM_PCD_KG_NUM_OF_DEFAULT_GROUPS; j++)
     {
-        p_Scheme->keyExtractAndHashParams.dflts[j].type = (e_FmPcdKgKnownFieldsDfltTypes)j; /* all types */
-        p_Scheme->keyExtractAndHashParams.dflts[j].dfltSelect = e_FM_PCD_KG_DFLT_GBL_0;
+        p_Scheme->keyExtractAndHashParams.dflts[j].type =
+                (e_FmPcdKgKnownFieldsDfltTypes)j; /* all types */
+        p_Scheme->keyExtractAndHashParams.dflts[j].dfltSelect =
+                e_FM_PCD_KG_DFLT_GBL_0;
     }
 }
 
-static t_Error IpReassemblyStats(t_FmPcdManip *p_Manip, t_FmPcdManipReassemIpStats *p_Stats)
+static t_Error IpReassemblyStats(t_FmPcdManip *p_Manip,
+                                 t_FmPcdManipReassemIpStats *p_Stats)
 {
     ASSERT_COND(p_Manip);
     ASSERT_COND(p_Stats);
-    ASSERT_COND(p_Manip->ipReassmParams.p_IpReassCommonTbl);
-
-    p_Stats->timeout                = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalTimeOutCounter);
-    p_Stats->rfdPoolBusy            = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalRfdPoolBusyCounter);
-    p_Stats->internalBufferBusy     = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalInternalBufferBusy);
-    p_Stats->externalBufferBusy     = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalExternalBufferBusy);
-    p_Stats->sgFragments            = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalSgFragmentCounter);
-    p_Stats->dmaSemaphoreDepletion  = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalDmaSemaphoreDepletionCounter);
+    ASSERT_COND(p_Manip->reassmParams.p_ReassCommonTbl);
+
+    p_Stats->timeout =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalTimeOutCounter);
+    p_Stats->rfdPoolBusy =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalRfdPoolBusyCounter);
+    p_Stats->internalBufferBusy =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalInternalBufferBusy);
+    p_Stats->externalBufferBusy =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalExternalBufferBusy);
+    p_Stats->sgFragments =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalSgFragmentCounter);
+    p_Stats->dmaSemaphoreDepletion =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalDmaSemaphoreDepletionCounter);
 #if (DPAA_VERSION >= 11)
-    p_Stats->nonConsistentSp        = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalNCSPCounter);
+    p_Stats->nonConsistentSp =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalNCSPCounter);
 #endif /* (DPAA_VERSION >= 11) */
 
-    if (p_Manip->ipReassmParams.p_Ipv4ReassTbl)
+    if (p_Manip->reassmParams.ip.p_Ipv4ReassTbl)
     {
-        p_Stats->specificHdrStatistics[0].successfullyReassembled = GET_UINT32(p_Manip->ipReassmParams.p_Ipv4ReassTbl->totalSuccessfullyReasmFramesCounter);
-        p_Stats->specificHdrStatistics[0].validFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv4ReassTbl->totalValidFragmentCounter);
-        p_Stats->specificHdrStatistics[0].processedFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv4ReassTbl->totalProcessedFragCounter);
-        p_Stats->specificHdrStatistics[0].malformedFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv4ReassTbl->totalMalformdFragCounter);
-        p_Stats->specificHdrStatistics[0].autoLearnBusy = GET_UINT32(p_Manip->ipReassmParams.p_Ipv4ReassTbl->totalSetBusyCounter);
-        p_Stats->specificHdrStatistics[0].discardedFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv4ReassTbl->totalDiscardedFragsCounter);
-        p_Stats->specificHdrStatistics[0].moreThan16Fragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv4ReassTbl->totalMoreThan16FramesCounter);
+        p_Stats->specificHdrStatistics[0].successfullyReassembled =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv4ReassTbl->totalSuccessfullyReasmFramesCounter);
+        p_Stats->specificHdrStatistics[0].validFragments =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv4ReassTbl->totalValidFragmentCounter);
+        p_Stats->specificHdrStatistics[0].processedFragments =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv4ReassTbl->totalProcessedFragCounter);
+        p_Stats->specificHdrStatistics[0].malformedFragments =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv4ReassTbl->totalMalformdFragCounter);
+        p_Stats->specificHdrStatistics[0].autoLearnBusy =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv4ReassTbl->totalSetBusyCounter);
+        p_Stats->specificHdrStatistics[0].discardedFragments =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv4ReassTbl->totalDiscardedFragsCounter);
+        p_Stats->specificHdrStatistics[0].moreThan16Fragments =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv4ReassTbl->totalMoreThan16FramesCounter);
     }
-    if (p_Manip->ipReassmParams.p_Ipv6ReassTbl)
+    if (p_Manip->reassmParams.ip.p_Ipv6ReassTbl)
     {
-        p_Stats->specificHdrStatistics[1].successfullyReassembled = GET_UINT32(p_Manip->ipReassmParams.p_Ipv6ReassTbl->totalSuccessfullyReasmFramesCounter);
-        p_Stats->specificHdrStatistics[1].validFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv6ReassTbl->totalValidFragmentCounter);
-        p_Stats->specificHdrStatistics[1].processedFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv6ReassTbl->totalProcessedFragCounter);
-        p_Stats->specificHdrStatistics[1].malformedFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv6ReassTbl->totalMalformdFragCounter);
-        p_Stats->specificHdrStatistics[1].autoLearnBusy = GET_UINT32(p_Manip->ipReassmParams.p_Ipv6ReassTbl->totalSetBusyCounter);
-        p_Stats->specificHdrStatistics[1].discardedFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv6ReassTbl->totalDiscardedFragsCounter);
-        p_Stats->specificHdrStatistics[1].moreThan16Fragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv6ReassTbl->totalMoreThan16FramesCounter);
+        p_Stats->specificHdrStatistics[1].successfullyReassembled =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv6ReassTbl->totalSuccessfullyReasmFramesCounter);
+        p_Stats->specificHdrStatistics[1].validFragments =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv6ReassTbl->totalValidFragmentCounter);
+        p_Stats->specificHdrStatistics[1].processedFragments =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv6ReassTbl->totalProcessedFragCounter);
+        p_Stats->specificHdrStatistics[1].malformedFragments =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv6ReassTbl->totalMalformdFragCounter);
+        p_Stats->specificHdrStatistics[1].autoLearnBusy =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv6ReassTbl->totalSetBusyCounter);
+        p_Stats->specificHdrStatistics[1].discardedFragments =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv6ReassTbl->totalDiscardedFragsCounter);
+        p_Stats->specificHdrStatistics[1].moreThan16Fragments =
+                GET_UINT32(p_Manip->reassmParams.ip.p_Ipv6ReassTbl->totalMoreThan16FramesCounter);
     }
     return E_OK;
 }
 
-#ifdef FM_CAPWAP_SUPPORT
-static t_Error IndxStats(t_FmPcdStatsParams *p_StatsParams,t_FmPcdManip *p_Manip,t_FmPcd *p_FmPcd)
+static t_Error IpFragmentationStats(t_FmPcdManip *p_Manip,
+                                    t_FmPcdManipFragIpStats *p_Stats)
 {
-    t_AdOfTypeContLookup    *p_Ad;
-    uint32_t                tmpReg32 = 0;
-
-    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
-
-    UNUSED(p_FmPcd);
+    t_AdOfTypeContLookup *p_Ad;
 
-    p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    ASSERT_COND(p_Manip);
+    ASSERT_COND(p_Stats);
+    ASSERT_COND(p_Manip->h_Ad);
+    ASSERT_COND(p_Manip->fragParams.p_Frag);
 
-    tmpReg32 = 0;
-    tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_INDEXED_STATS;
-    if (p_StatsParams->type == e_FM_PCD_STATS_PER_FLOWID)
-        tmpReg32 |= (uint32_t)0x16 << 16;
-    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
 
-    tmpReg32 = 0;
-    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
-    WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
+    p_Stats->totalFrames = GET_UINT32(p_Ad->gmask);
+    p_Stats->fragmentedFrames = GET_UINT32(p_Manip->fragParams.p_Frag->ccAdBase)
+            & 0x00ffffff;
+    p_Stats->generatedFragments =
+            GET_UINT32(p_Manip->fragParams.p_Frag->matchTblPtr);
 
     return E_OK;
 }
 
-static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams  *p_ManipParams, t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+static t_Error IpFragmentation(t_FmPcdManipFragIpParams *p_ManipParams,
+                               t_FmPcdManip *p_Manip)
 {
-    t_FmPcdManipHdrInsrtByTemplateParams   *p_InsrtByTemplate = &p_ManipParams->u.byTemplate;
-    uint8_t                             tmpReg8 = 0xff;
-    t_AdOfTypeContLookup                *p_Ad;
-    bool                                ipModify = FALSE;
-    uint32_t                            tmpReg32 = 0, tmpRegNia = 0;
-    uint16_t                            tmpReg16 = 0;
-    t_Error                             err = E_OK;
-    uint8_t                             extraAddedBytes = 0, blockSize = 0, extraAddedBytesAlignedToBlockSize = 0, log2Num = 0;
-    uint8_t                             *p_Template = NULL;
+    uint32_t pcAndOffsetsReg = 0, ccAdBaseReg = 0, gmaskReg = 0;
+    t_FmPcd *p_FmPcd;
+#if (DPAA_VERSION == 10)
+    t_Error err = E_OK;
+#endif /* (DPAA_VERSION == 10) */
 
-    SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_Manip,E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams->sizeForFragmentation != 0xFFFF,
+                              E_INVALID_VALUE);
 
-    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
-    if (p_Manip->insrt)
-    {
-        if ((!p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterIp) ||
-             (!p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterVlan))
-             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : asking for header template modifications with no template for insertion (template size)"));
+    p_FmPcd = p_Manip->h_FmPcd;
+    /* Allocation of fragmentation Action Descriptor */
+    p_Manip->fragParams.p_Frag = (t_AdOfTypeContLookup *)FM_MURAM_AllocMem(
+            p_FmPcd->h_FmMuram, FM_PCD_CC_AD_ENTRY_SIZE,
+            FM_PCD_CC_AD_TABLE_ALIGN);
+    if (!p_Manip->fragParams.p_Frag)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("MURAM alloc for Fragmentation table descriptor"));
+    IOMemSet32(p_Manip->fragParams.p_Frag, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
-         if (p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterIp && (p_InsrtByTemplate->size <= p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset))
-             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : size of template < ipOuterOffset"));
+    /* Prepare the third Ad register (pcAndOffsets)- OperationCode */
+    pcAndOffsetsReg = (uint32_t)HMAN_OC_IP_FRAGMENTATION;
 
-         if (p_InsrtByTemplate->size > 128)
-             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Size of header template for insertion can not be more than 128"));
+    /* Prepare the first Ad register (ccAdBase) - Don't frag action and Action descriptor type*/
+    ccAdBaseReg = FM_PCD_AD_CONT_LOOKUP_TYPE;
+    ccAdBaseReg |= (p_ManipParams->dontFragAction
+            << FM_PCD_MANIP_IP_FRAG_DF_SHIFT);
 
-         if (p_InsrtByTemplate->size)
-         {
-             p_Manip->p_Template = (uint8_t *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                             p_InsrtByTemplate->size,
-                                             FM_PCD_CC_AD_TABLE_ALIGN);
-             if(!p_Manip->p_Template)
-                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
 
-             tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->p_Template) - (p_FmPcd->physicalMuramBase));
-             tmpReg32 |= (uint32_t)p_InsrtByTemplate->size << 24;
-             *(uint32_t *)&p_Ad->matchTblPtr = tmpReg32;
-         }
+    /* Set Scatter/Gather BPid */
+    if (p_ManipParams->sgBpidEn)
+    {
+        ccAdBaseReg |= FM_PCD_MANIP_IP_FRAG_SG_BDID_EN;
+        pcAndOffsetsReg |= ((p_ManipParams->sgBpid
+                << FM_PCD_MANIP_IP_FRAG_SG_BDID_SHIFT)
+                & FM_PCD_MANIP_IP_FRAG_SG_BDID_MASK);
+    }
 
-         tmpReg32 = 0;
+    /* Prepare the first Ad register (gmask) - scratch buffer pool id and Pointer to fragment ID */
+    gmaskReg = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_FmPcd->ipv6FrameIdAddr))
+            - p_FmPcd->physicalMuramBase);
+#if (DPAA_VERSION == 10)
+    gmaskReg |= p_ManipParams->scratchBpid << FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID;
+#else
+    gmaskReg |= (0xFF) << FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID;
+#endif /* (DPAA_VERSION == 10) */
 
-        p_Template = (uint8_t *)XX_Malloc(p_InsrtByTemplate->size * sizeof(uint8_t));
+    /* Set all Ad registers */
+    WRITE_UINT32(p_Manip->fragParams.p_Frag->pcAndOffsets, pcAndOffsetsReg);
+    WRITE_UINT32(p_Manip->fragParams.p_Frag->ccAdBase, ccAdBaseReg);
+    WRITE_UINT32(p_Manip->fragParams.p_Frag->gmask, gmaskReg);
 
-        if (!p_Template)
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("XX_Malloc allocation FAILED"));
+    /* Saves user's fragmentation manipulation parameters */
+    p_Manip->frag = TRUE;
+    p_Manip->sizeForFragmentation = p_ManipParams->sizeForFragmentation;
 
-        memcpy(p_Template, p_InsrtByTemplate->hdrTemplate, p_InsrtByTemplate->size * sizeof(uint8_t));
+#if (DPAA_VERSION == 10)
+    p_Manip->fragParams.scratchBpid = p_ManipParams->scratchBpid;
 
+    /* scratch buffer pool initialization */
+    if ((err = FmPcdFragHcScratchPoolFill((t_Handle)p_FmPcd, p_ManipParams->scratchBpid)) != E_OK)
+    {
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_Frag);
+        p_Manip->fragParams.p_Frag = NULL;
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+#endif /* (DPAA_VERSION == 10) */
 
-         if (p_InsrtByTemplate->modifyOuterIp)
-         {
-             ipModify = TRUE;
+    return E_OK;
+}
 
-             tmpReg8 = (uint8_t)p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset];
+static t_Error IPManip(t_FmPcdManip *p_Manip)
+{
+    t_Error err = E_OK;
+    t_FmPcd *p_FmPcd;
+    t_AdOfTypeContLookup *p_Ad;
+    uint32_t tmpReg32 = 0, tmpRegNia = 0;
 
-             if((tmpReg8 & 0xf0) == 0x40)
-                 tmpReg8 = 4;
-             else if((tmpReg8 & 0xf0) == 0x60)
-                 tmpReg8 = 6;
-             else
-                 tmpReg8 = 0xff;
+    SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
+    p_FmPcd = p_Manip->h_FmPcd;
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
-             if (tmpReg8 != 0xff)
-             {
-                if(p_InsrtByTemplate->modifyOuterIpParams.dscpEcn & 0xff00)
-                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : IPV4 present in header template, dscpEcn has to be only 1 byte"));
-                if(p_InsrtByTemplate->modifyOuterIpParams.recalculateLength)
-                 {
-
-                     if((p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize) > 255)
-                            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("extra Byte added can not be more than 256 bytes"));
-                     extraAddedBytes = (uint8_t) (p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize);
-                     blockSize = p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.blockSize;
-                     extraAddedBytesAlignedToBlockSize = p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize;
-                     /*IP header template - IP totalLength -
-                     (1 byte) extraByteForIp = headerTemplateSize - ipOffset + insertedBytesAfterThisStage ,
-                     in the case of SEC insertedBytesAfterThisStage - SEC trailer (21/31) + header(13)
-                     second byte - extraByteForIp = headerTemplate - ipOffset + insertedBytesAfterThisStage*/
-                 }
-                 if (blockSize)
-                 {
-                     if (!POWER_OF_2(blockSize))
-                         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("inputFrmPaddingUpToBlockSize has to be power of 2"));
-                 }
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+
+    tmpReg32 = FM_PCD_MANIP_IP_NO_FRAGMENTATION;
+    if (p_Manip->frag == TRUE)
+    {
+        tmpRegNia = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_Frag)
+                - (p_FmPcd->physicalMuramBase));
+        tmpReg32 = (uint32_t)p_Manip->sizeForFragmentation
+                << FM_PCD_MANIP_IP_MTU_SHIFT;
+    }
 
-             }
-             if (tmpReg8 == 4)
-             {
-                 if ((IPv4_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset) > p_InsrtByTemplate->size)
-                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : IP present in header template, user asked for IP modifications but ipOffset + ipTotalLengthFieldOffset in header template bigger than template size"));
+    tmpRegNia |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    tmpReg32 |= HMAN_OC_IP_MANIP;
 
+#if (DPAA_VERSION >= 11)
+    tmpRegNia |= FM_PCD_MANIP_IP_CNIA;
+#endif /* (DPAA_VERSION >= 11) */
 
-                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_DSCECN_FIELD_OFFSET_FROM_IP] = (uint8_t)p_InsrtByTemplate->modifyOuterIpParams.dscpEcn;
+    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
+    WRITE_UINT32(p_Ad->ccAdBase, tmpRegNia);
+    WRITE_UINT32(p_Ad->gmask, 0);
+    /* Total frame counter - MUST be initialized to zero.*/
 
-                 if (blockSize)
-                     blockSize -= 1;
+    return err;
+}
 
-                 if ((p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes) > 255)
-                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes has to be less than 255"));
+static t_Error UpdateInitIpFrag(t_Handle h_FmPcd, t_Handle h_PcdParams,
+                                t_Handle h_FmPort, t_FmPcdManip *p_Manip,
+                                t_Handle h_Ad, bool validate)
+{
+    t_FmPortGetSetCcParams fmPortGetSetCcParams;
+    t_Error err;
 
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_TOTALLENGTH_FIELD_OFFSET_FROM_IP + 1] = blockSize;// IPV6 - in AD instead of SEQ IND
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_TOTALLENGTH_FIELD_OFFSET_FROM_IP] = (uint8_t)(p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes);// for IPV6 decrement additional 40 bytes of IPV6 heade size
+    SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Manip->opcode == HMAN_OC_IP_FRAGMENTATION),
+                              E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
 
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_ID_FIELD_OFFSET_FROM_IP] = 0x00;
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_ID_FIELD_OFFSET_FROM_IP + 1] = extraAddedBytesAlignedToBlockSize;
+    UNUSED(h_FmPcd);
+    UNUSED(h_Ad);
+    UNUSED(h_PcdParams);
+    UNUSED(validate);
+    UNUSED(p_Manip);
 
+    fmPortGetSetCcParams.setCcParams.type = 0;
+    fmPortGetSetCcParams.getCcParams.type = MANIP_EXTRA_SPACE;
+    if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
+    if (!fmPortGetSetCcParams.getCcParams.internalBufferOffset)
+        DBG(WARNING, ("manipExtraSpace must be larger than '0'"));
 
-                 /*IP header template - relevant only for ipv4 CheckSum = 0*/
-                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_HDRCHECKSUM_FIELD_OFFSET_FROM_IP] = 0x00;
-                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv4_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + 1] = 0x00;
+    return E_OK;
+}
 
+static t_Error IPSecManip(t_FmPcdManipParams *p_ManipParams,
+                          t_FmPcdManip *p_Manip)
+{
+    t_AdOfTypeContLookup *p_Ad;
+    t_FmPcdManipSpecialOffloadIPSecParams *p_IPSecParams;
+    t_Error err = E_OK;
+    uint32_t tmpReg32 = 0;
 
-                 /*UDP checksum has to be 0*/
-                 if (p_InsrtByTemplate->modifyOuterIpParams.udpPresent)
-                 {
-                     if ((p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP + UDP_CHECKSUM_FIELD_SIZE) > p_InsrtByTemplate->size)
-                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : UDP present according to user but (UDP offset + UDP header size) < size of header template"));
+    SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams, E_INVALID_HANDLE);
 
-                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP ] = 0x00;
-                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP + 1] = 0x00;
+    p_IPSecParams = &p_ManipParams->u.specialOffload.u.ipsec;
 
-                 }
+    SANITY_CHECK_RETURN_ERROR(
+            !p_IPSecParams->variableIpHdrLen || p_IPSecParams->decryption,
+            E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(
+            !p_IPSecParams->variableIpVersion || !p_IPSecParams->decryption,
+            E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(
+            !p_IPSecParams->variableIpVersion || p_IPSecParams->outerIPHdrLen,
+            E_INVALID_VALUE);
 
-                 if (p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId > 7)
-                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("ipIdentGenId has to be one out of 8 sequence number generators (0 - 7) for IP identification field"));
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
 
-                 tmpRegNia |= (uint32_t)p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId<<24;
-             }
-             else if (tmpReg8 == 6)
-             {
-                /*TODO - add check for maximum value of blockSize;*/
-                 if (blockSize)
-                    LOG2(blockSize, log2Num);
-                 tmpRegNia |= (uint32_t)log2Num << 24;
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    tmpReg32 |= (p_IPSecParams->decryption) ? FM_PCD_MANIP_IPSEC_DEC : 0;
+    tmpReg32 |= (p_IPSecParams->ecnCopy) ? FM_PCD_MANIP_IPSEC_ECN_EN : 0;
+    tmpReg32 |= (p_IPSecParams->dscpCopy) ? FM_PCD_MANIP_IPSEC_DSCP_EN : 0;
+    tmpReg32 |=
+            (p_IPSecParams->variableIpHdrLen) ? FM_PCD_MANIP_IPSEC_VIPL_EN : 0;
+    tmpReg32 |=
+            (p_IPSecParams->variableIpVersion) ? FM_PCD_MANIP_IPSEC_VIPV_EN : 0;
+    WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
 
-                // for IPV6 decrement additional 40 bytes of IPV6 heade size - because IPV6 header size is not included in payloadLength
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv6_PAYLOAD_LENGTH_OFFSET_FROM_IP] = (uint8_t)(p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes - 40);
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv6_PAYLOAD_LENGTH_OFFSET_FROM_IP + 1] = extraAddedBytesAlignedToBlockSize;
-               if (p_InsrtByTemplate->modifyOuterIpParams.udpPresent)
-               {
-                 if ((p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP + UDP_CHECKSUM_FIELD_SIZE) > p_InsrtByTemplate->size)
-                      RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : UDP present according to user but (UDP offset + UDP header size) < size of header template"));
-                if (p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IPv6_NEXT_HEADER_OFFSET_FROM_IP] != 0x88)
-                      RETURN_ERROR(MAJOR, E_INVALID_STATE, ("OUr suppport is only IPv6/UDPLite"));
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_LENGTH_FIELD_OFFSET_FROM_UDP] = 0x00;
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_LENGTH_FIELD_OFFSET_FROM_UDP + 1] = 0x08;
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP] = 0x00;
-                p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_CHECKSUM_FIELD_OFFSET_FROM_UDP + 1] = 0x00;
-               }
-             }
-             else
-                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("IP version supported only IPV4"));
-         }
-
-         tmpReg32 = tmpReg16 = tmpReg8 = 0;
-         /*TODO - check it*/
-         if (p_InsrtByTemplate->modifyOuterVlan)
-         {
-             if (p_InsrtByTemplate->modifyOuterVlanParams.vpri & ~0x07)
-                 RETURN_ERROR(MAJOR, E_INVALID_STATE,("Inconsistent parameters : user asked for VLAN modifications but VPRI more than 3 bits"));
-
-             memcpy(&tmpReg16, &p_Template[VLAN_TAG_FIELD_OFFSET_FROM_ETH], 2*(sizeof(uint8_t)));
-             if ((tmpReg16  != 0x9100) && (tmpReg16!= 0x9200) && (tmpReg16 != 0x8100))
-                 RETURN_ERROR(MAJOR, E_INVALID_STATE,("Inconsistent parameters : user asked for VLAN modifications but Tag Protocol identifier is not VLAN "));
-
-             memcpy(&tmpReg8, &p_Template[14],1*(sizeof(uint8_t)));
-             tmpReg8 &= 0x1f;
-             tmpReg8 |= (uint8_t)(p_InsrtByTemplate->modifyOuterVlanParams.vpri << 5);
-
-             p_Template[14] = tmpReg8;
-         }
+    tmpReg32 = HMAN_OC_IPSEC_MANIP;
+    tmpReg32 |= p_IPSecParams->outerIPHdrLen
+            << FM_PCD_MANIP_IPSEC_IP_HDR_LEN_SHIFT;
+    if (p_ManipParams->h_NextManip)
+    {
+        WRITE_UINT32(
+                p_Ad->matchTblPtr,
+                (uint32_t)(XX_VirtToPhys(((t_FmPcdManip *)p_ManipParams->h_NextManip)->h_Ad)- (((t_FmPcd *)p_Manip->h_FmPcd)->physicalMuramBase)) >> 4);
 
-        Mem2IOCpy32(p_Manip->p_Template, p_Template, p_InsrtByTemplate->size);
+        tmpReg32 |= FM_PCD_MANIP_IPSEC_NADEN;
+    }WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
 
-        XX_Free(p_Template);
-    }
+    return err;
+}
 
-    tmpReg32 = 0;
-    if (p_Manip->h_Frag)
+static t_Error SetCapwapReassmManip(t_FmPcdManip *p_Manip)
+{
+    t_FmPcd *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
+
+    /* Allocation if CAPWAP Action descriptor */
+    p_Manip->reassmParams.capwap.h_Ad = (t_Handle)XX_MallocSmart(
+            FM_PCD_CC_AD_ENTRY_SIZE, p_Manip->reassmParams.dataMemId,
+            FM_PCD_CC_AD_TABLE_ALIGN);
+    if (!p_Manip->reassmParams.capwap.h_Ad)
     {
-        tmpRegNia |= (uint32_t)(XX_VirtToPhys(p_Manip->h_Frag) - (p_FmPcd->physicalMuramBase));
-        tmpReg32  |= (uint32_t)p_Manip->sizeForFragmentation << 16;
+        ReleaseManipHandler(p_Manip, p_FmPcd);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("Allocation of CAPWAP table descriptor"));
     }
-    else
-          tmpReg32 = 0xffff0000;
 
-    if (ipModify)
-        tmpReg32 |= (uint32_t)p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset << 8;
-    else
-        tmpReg32 |= (uint32_t)0x0000ff00;
+    memset(p_Manip->reassmParams.capwap.h_Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
-    tmpReg32 |= (uint32_t)HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
-    *(uint32_t *)&p_Ad->pcAndOffsets = tmpReg32;
+    /* Fill reassembly manipulation parameter in the Reassembly Action Descriptor */
+    return FillReassmManipParams(p_Manip, HEADER_TYPE_CAPWAP);
+}
 
-    tmpRegNia |= FM_PCD_AD_CONT_LOOKUP_TYPE;
-    *(uint32_t *)&p_Ad->ccAdBase = tmpRegNia;
+static void setCapwapReassmSchemeParams(t_FmPcd* p_FmPcd,
+                                        t_FmPcdKgSchemeParams *p_Scheme,
+                                        t_Handle h_CcTree, uint8_t groupId)
+{
+    uint8_t res;
 
-    return err;
+    /* Configures scheme's network environment parameters */
+    p_Scheme->netEnvParams.numOfDistinctionUnits = 1;
+    res = FmPcdNetEnvGetUnitId(
+            p_FmPcd, FmPcdGetNetEnvId(p_Scheme->netEnvParams.h_NetEnv),
+            HEADER_TYPE_USER_DEFINED_SHIM2, FALSE, 0);
+    ASSERT_COND(res != FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
+    p_Scheme->netEnvParams.unitIds[0] = res;
+
+    /* Configures scheme's next engine parameters*/
+    p_Scheme->nextEngine = e_FM_PCD_CC;
+    p_Scheme->kgNextEngineParams.cc.h_CcTree = h_CcTree;
+    p_Scheme->kgNextEngineParams.cc.grpId = groupId;
+    p_Scheme->useHash = TRUE;
+
+    /* Configures scheme's key*/
+    p_Scheme->keyExtractAndHashParams.numOfUsedExtracts = 2;
+    p_Scheme->keyExtractAndHashParams.extractArray[0].type =
+            e_FM_PCD_EXTRACT_NON_HDR;
+    p_Scheme->keyExtractAndHashParams.extractArray[0].extractNonHdr.src =
+            e_FM_PCD_EXTRACT_FROM_PARSE_RESULT;
+    p_Scheme->keyExtractAndHashParams.extractArray[0].extractNonHdr.action =
+            e_FM_PCD_ACTION_NONE;
+    p_Scheme->keyExtractAndHashParams.extractArray[0].extractNonHdr.offset = 20;
+    p_Scheme->keyExtractAndHashParams.extractArray[0].extractNonHdr.size = 4;
+    p_Scheme->keyExtractAndHashParams.extractArray[1].type =
+            e_FM_PCD_EXTRACT_NON_HDR;
+    p_Scheme->keyExtractAndHashParams.extractArray[1].extractNonHdr.src =
+            e_FM_PCD_EXTRACT_FROM_DFLT_VALUE;
+    p_Scheme->keyExtractAndHashParams.extractArray[1].extractNonHdr.action =
+            e_FM_PCD_ACTION_NONE;
+    p_Scheme->keyExtractAndHashParams.extractArray[1].extractNonHdr.offset = 0;
+    p_Scheme->keyExtractAndHashParams.extractArray[1].extractNonHdr.size = 1;
+
+    p_Scheme->keyExtractAndHashParams.privateDflt0 = 0x0;
+    p_Scheme->keyExtractAndHashParams.privateDflt1 = 0x0;
+    p_Scheme->keyExtractAndHashParams.numOfUsedDflts = 1;
+    p_Scheme->keyExtractAndHashParams.dflts[0].type = e_FM_PCD_KG_GENERIC_NOT_FROM_DATA;
+    p_Scheme->keyExtractAndHashParams.dflts[0].dfltSelect = e_FM_PCD_KG_DFLT_PRIVATE_0;
 }
-#endif /* FM_CAPWAP_SUPPORT */
 
-static t_Error IpFragmentationStats(t_FmPcdManip *p_Manip, t_FmPcdManipFragIpStats *p_Stats)
+#if (DPAA_VERSION >= 11)
+static t_Error CapwapReassemblyStats(t_FmPcdManip *p_Manip,
+                                     t_FmPcdManipReassemCapwapStats *p_Stats)
 {
-    t_AdOfTypeContLookup    *p_Ad;
-
     ASSERT_COND(p_Manip);
     ASSERT_COND(p_Stats);
-    ASSERT_COND(p_Manip->h_Ad);
-    ASSERT_COND(p_Manip->ipFragParams.p_Frag);
+    ASSERT_COND(p_Manip->reassmParams.p_ReassCommonTbl);
+
+    p_Stats->timeout =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalTimeOutCounter);
+    p_Stats->rfdPoolBusy =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalRfdPoolBusyCounter);
+    p_Stats->internalBufferBusy =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalInternalBufferBusy);
+    p_Stats->externalBufferBusy =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalExternalBufferBusy);
+    p_Stats->sgFragments =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalSgFragmentCounter);
+    p_Stats->dmaSemaphoreDepletion =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalDmaSemaphoreDepletionCounter);
+    p_Stats->exceedMaxReassemblyFrameLen =
+            GET_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->totalNCSPCounter);
+
+    p_Stats->successfullyReassembled =
+            GET_UINT32(p_Manip->reassmParams.capwap.p_ReassTbl->totalSuccessfullyReasmFramesCounter);
+    p_Stats->validFragments =
+            GET_UINT32(p_Manip->reassmParams.capwap.p_ReassTbl->totalValidFragmentCounter);
+    p_Stats->processedFragments =
+            GET_UINT32(p_Manip->reassmParams.capwap.p_ReassTbl->totalProcessedFragCounter);
+    p_Stats->malformedFragments =
+            GET_UINT32(p_Manip->reassmParams.capwap.p_ReassTbl->totalMalformdFragCounter);
+    p_Stats->autoLearnBusy =
+            GET_UINT32(p_Manip->reassmParams.capwap.p_ReassTbl->totalSetBusyCounter);
+    p_Stats->discardedFragments =
+            GET_UINT32(p_Manip->reassmParams.capwap.p_ReassTbl->totalDiscardedFragsCounter);
+    p_Stats->moreThan16Fragments =
+            GET_UINT32(p_Manip->reassmParams.capwap.p_ReassTbl->totalMoreThan16FramesCounter);
 
-    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    return E_OK;
+}
+
+static t_Error CapwapFragmentationStats(t_FmPcdManip *p_Manip,
+		t_FmPcdManipFragCapwapStats *p_Stats)
+{
+	t_AdOfTypeContLookup *p_Ad;
+
+	ASSERT_COND(p_Manip);
+	ASSERT_COND(p_Stats);
+	ASSERT_COND(p_Manip->h_Ad);
+	ASSERT_COND(p_Manip->fragParams.p_Frag);
+
+	p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+
+	p_Stats->totalFrames = GET_UINT32(p_Ad->gmask);
+
+	return E_OK;
+}
+
+static t_Error CapwapReassembly(t_FmPcdManipReassemParams *p_ManipReassmParams,
+                                t_FmPcdManip *p_Manip)
+{
+    uint32_t maxSetNumber = 10000;
+    t_FmPcdManipReassemCapwapParams reassmManipParams =
+            p_ManipReassmParams->u.capwapReassem;
+    t_Error res;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(((t_FmPcd *)p_Manip->h_FmPcd)->h_Hc,
+                              E_INVALID_HANDLE);
+
+    /* Check validation of user's parameter.*/
+    if ((reassmManipParams.timeoutThresholdForReassmProcess < 1000)
+            || (reassmManipParams.timeoutThresholdForReassmProcess > 8000000))
+        RETURN_ERROR(
+                MAJOR, E_INVALID_VALUE,
+                ("timeoutThresholdForReassmProcess should be 1msec - 8sec"));
+    /* It is recommended that the total number of entries in this table (number of sets * number of ways)
+     will be twice the number of frames that are expected to be reassembled simultaneously.*/
+    if (reassmManipParams.maxNumFramesInProcess
+            > (reassmManipParams.maxNumFramesInProcess * maxSetNumber / 2))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("maxNumFramesInProcess has to be less than (maximun set number * number of ways / 2)"));
 
-    p_Stats->totalFrames = GET_UINT32(p_Ad->gmask);
-    p_Stats->fragmentedFrames = GET_UINT32(p_Manip->ipFragParams.p_Frag->ccAdBase) & 0x00ffffff;
-    p_Stats->generatedFragments = GET_UINT32(p_Manip->ipFragParams.p_Frag->matchTblPtr);
+    /* Saves user's reassembly manipulation parameters */
+    p_Manip->reassmParams.capwap.relativeSchemeId =
+            reassmManipParams.relativeSchemeId;
+    p_Manip->reassmParams.capwap.numOfFramesPerHashEntry =
+            reassmManipParams.numOfFramesPerHashEntry;
+    p_Manip->reassmParams.capwap.maxRessembledsSize =
+            reassmManipParams.maxReassembledFrameLength;
+    p_Manip->reassmParams.maxNumFramesInProcess =
+            reassmManipParams.maxNumFramesInProcess;
+    p_Manip->reassmParams.timeOutMode = reassmManipParams.timeOutMode;
+    p_Manip->reassmParams.fqidForTimeOutFrames =
+            reassmManipParams.fqidForTimeOutFrames;
+    p_Manip->reassmParams.timeoutThresholdForReassmProcess =
+            reassmManipParams.timeoutThresholdForReassmProcess;
+    p_Manip->reassmParams.dataMemId = reassmManipParams.dataMemId;
+    p_Manip->reassmParams.dataLiodnOffset = reassmManipParams.dataLiodnOffset;
+
+    /* Creates and initializes the Reassembly common parameter table */
+    CreateReassCommonTable(p_Manip);
+
+    res = SetCapwapReassmManip(p_Manip);
+    if (res != E_OK)
+        return res;
 
     return E_OK;
 }
 
-static t_Error IpFragmentation(t_FmPcdManipFragIpParams *p_ManipParams, t_FmPcdManip *p_Manip)
+static t_Error CapwapFragmentation(t_FmPcdManipFragCapwapParams *p_ManipParams,
+                                   t_FmPcdManip *p_Manip)
 {
-    uint32_t    pcAndOffsetsReg = 0, ccAdBaseReg = 0, gmaskReg = 0;
-    t_FmPcd     *p_FmPcd;
-#if (DPAA_VERSION == 10)
-    t_Error     err = E_OK;
-#endif /* (DPAA_VERSION == 10) */
-
-    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_ManipParams->sizeForFragmentation != 0xFFFF, E_INVALID_VALUE);
+    t_FmPcd *p_FmPcd;
+    t_AdOfTypeContLookup *p_Ad;
+    uint32_t pcAndOffsetsReg = 0, ccAdBaseReg = 0, gmaskReg = 0;
+    uint32_t tmpReg32 = 0, tmpRegNia = 0;
 
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams->sizeForFragmentation != 0xFFFF,
+                              E_INVALID_VALUE);
     p_FmPcd = p_Manip->h_FmPcd;
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
     /* Allocation of fragmentation Action Descriptor */
-    p_Manip->ipFragParams.p_Frag = (t_AdOfTypeContLookup *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                                                             FM_PCD_CC_AD_ENTRY_SIZE,
-                                                                             FM_PCD_CC_AD_TABLE_ALIGN);
-    if (!p_Manip->ipFragParams.p_Frag)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Fragmentation table descriptor"));
-    IOMemSet32( p_Manip->ipFragParams.p_Frag, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+    p_Manip->fragParams.p_Frag = (t_AdOfTypeContLookup *)FM_MURAM_AllocMem(
+            p_FmPcd->h_FmMuram, FM_PCD_CC_AD_ENTRY_SIZE,
+            FM_PCD_CC_AD_TABLE_ALIGN);
+    if (!p_Manip->fragParams.p_Frag)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("MURAM alloc for Fragmentation table descriptor"));
+    IOMemSet32(p_Manip->fragParams.p_Frag, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
     /* Prepare the third Ad register (pcAndOffsets)- OperationCode */
-    pcAndOffsetsReg = (uint32_t)HMAN_OC_IP_FRAGMENTATION;
+    pcAndOffsetsReg = (uint32_t)HMAN_OC_CAPWAP_FRAGMENTATION;
 
     /* Prepare the first Ad register (ccAdBase) - Don't frag action and Action descriptor type*/
     ccAdBaseReg = FM_PCD_AD_CONT_LOOKUP_TYPE;
-    ccAdBaseReg |= (p_ManipParams->dontFragAction << FM_PCD_MANIP_IP_FRAG_DF_SHIFT);
-
+    ccAdBaseReg |=
+            (p_ManipParams->compressModeEn) ? FM_PCD_MANIP_CAPWAP_FRAG_COMPRESS_EN :
+                    0;
 
     /* Set Scatter/Gather BPid */
     if (p_ManipParams->sgBpidEn)
     {
-         ccAdBaseReg     |= FM_PCD_MANIP_IP_FRAG_SG_BDID_EN;
-         pcAndOffsetsReg |= ((p_ManipParams->sgBpid << FM_PCD_MANIP_IP_FRAG_SG_BDID_SHIFT) & FM_PCD_MANIP_IP_FRAG_SG_BDID_MASK);
+        ccAdBaseReg |= FM_PCD_MANIP_CAPWAP_FRAG_SG_BDID_EN;
+        pcAndOffsetsReg |= ((p_ManipParams->sgBpid
+                << FM_PCD_MANIP_CAPWAP_FRAG_SG_BDID_SHIFT)
+                & FM_PCD_MANIP_CAPWAP_FRAG_SG_BDID_MASK);
     }
 
     /* Prepare the first Ad register (gmask) - scratch buffer pool id and Pointer to fragment ID */
-    gmaskReg = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_FmPcd->ipv6FrameIdAddr)) - p_FmPcd->physicalMuramBase);
-#if (DPAA_VERSION == 10)
-    gmaskReg |= p_ManipParams->scratchBpid << FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID;
-#else
+    gmaskReg = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_FmPcd->capwapFrameIdAddr))
+            - p_FmPcd->physicalMuramBase);
     gmaskReg |= (0xFF) << FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID;
-#endif /* (DPAA_VERSION == 10) */
 
     /* Set all Ad registers */
-    WRITE_UINT32(p_Manip->ipFragParams.p_Frag->pcAndOffsets, pcAndOffsetsReg);
-    WRITE_UINT32(p_Manip->ipFragParams.p_Frag->ccAdBase, ccAdBaseReg);
-    WRITE_UINT32(p_Manip->ipFragParams.p_Frag->gmask, gmaskReg);
+    WRITE_UINT32(p_Manip->fragParams.p_Frag->pcAndOffsets, pcAndOffsetsReg);
+    WRITE_UINT32(p_Manip->fragParams.p_Frag->ccAdBase, ccAdBaseReg);
+    WRITE_UINT32(p_Manip->fragParams.p_Frag->gmask, gmaskReg);
 
     /* Saves user's fragmentation manipulation parameters */
     p_Manip->frag = TRUE;
     p_Manip->sizeForFragmentation = p_ManipParams->sizeForFragmentation;
 
-#if (DPAA_VERSION == 10)
-    p_Manip->ipFragParams.scratchBpid = p_ManipParams->scratchBpid;
-
-    /* scratch buffer pool initialization */
-    if ((err = FmPcdFragHcScratchPoolFill((t_Handle)p_FmPcd, p_ManipParams->scratchBpid)) != E_OK)
-    {
-        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipFragParams.p_Frag);
-        p_Manip->ipFragParams.p_Frag = NULL;
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
-#endif /* (DPAA_VERSION == 10) */
-
-    return E_OK;
-}
-
-static t_Error IPManip(t_FmPcdManip *p_Manip)
-{
-    t_Error                     err = E_OK;
-    t_FmPcd                     *p_FmPcd;
-    t_AdOfTypeContLookup        *p_Ad;
-    uint32_t                    tmpReg32 = 0, tmpRegNia = 0;
-
-    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
-    p_FmPcd = p_Manip->h_FmPcd;
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_INVALID_HANDLE);
-
     p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
 
-    tmpReg32 = FM_PCD_MANIP_IP_NO_FRAGMENTATION;
-    if (p_Manip->frag == TRUE)
-    {
-        tmpRegNia = (uint32_t)(XX_VirtToPhys(p_Manip->ipFragParams.p_Frag) - (p_FmPcd->physicalMuramBase));
-        tmpReg32  = (uint32_t)p_Manip->sizeForFragmentation << FM_PCD_MANIP_IP_MTU_SHIFT;
-    }
+    tmpRegNia = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_Frag)
+            - (p_FmPcd->physicalMuramBase));
+    tmpReg32 = (uint32_t)p_Manip->sizeForFragmentation
+            << FM_PCD_MANIP_CAPWAP_FRAG_CHECK_MTU_SHIFT;
 
     tmpRegNia |= FM_PCD_AD_CONT_LOOKUP_TYPE;
-    tmpReg32  |= HMAN_OC_IP_MANIP;
+    tmpReg32 |= HMAN_OC_CAPWAP_FRAG_CHECK;
 
-#if (DPAA_VERSION >= 11)
-    tmpRegNia |= FM_PCD_MANIP_IP_CNIA;
-#endif /* (DPAA_VERSION >= 11) */
+    tmpRegNia |= FM_PCD_MANIP_CAPWAP_FRAG_CHECK_CNIA;
 
     WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
     WRITE_UINT32(p_Ad->ccAdBase, tmpRegNia);
-    WRITE_UINT32(p_Ad->gmask, 0); /* Total frame counter - MUST be initialized to zero.*/
+    WRITE_UINT32(p_Ad->gmask, 0);
+    /* Total frame counter - MUST be initialized to zero.*/
 
-    return err;
+    return E_OK;
 }
 
-static t_Error UpdateInitIpFrag(t_Handle       h_FmPcd,
-                                t_Handle       h_PcdParams,
-                                t_Handle       h_FmPort,
-                                t_FmPcdManip   *p_Manip,
-                                t_Handle       h_Ad,
-                                bool           validate)
+static t_Error UpdateInitCapwapFrag(t_Handle h_FmPcd, t_Handle h_PcdParams,
+                                    t_Handle h_FmPort, t_FmPcdManip *p_Manip,
+                                    t_Handle h_Ad, bool validate)
 {
-    t_FmPortGetSetCcParams      fmPortGetSetCcParams;
-    t_Error                     err;
+    t_FmPortGetSetCcParams fmPortGetSetCcParams;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR((p_Manip->opcode == HMAN_OC_IP_FRAGMENTATION), E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR((p_Manip->opcode == HMAN_OC_CAPWAP_FRAGMENTATION),
+                              E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
 
@@ -3193,74 +4268,47 @@ static t_Error UpdateInitIpFrag(t_Handle       h_FmPcd,
     return E_OK;
 }
 
-static t_Error IPSecManip(t_FmPcdManipParams    *p_ManipParams,
-                          t_FmPcdManip          *p_Manip)
+static t_Error CapwapManip(t_FmPcdManipParams *p_ManipParams,
+                           t_FmPcdManip *p_Manip)
 {
-    t_AdOfTypeContLookup                    *p_Ad;
-    t_FmPcdManipSpecialOffloadIPSecParams   *p_IPSecParams;
-    t_Error                                 err = E_OK;
-    uint32_t                                tmpReg32 = 0;
-
-    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_INVALID_HANDLE);
+    t_AdOfTypeContLookup *p_Ad;
+    t_FmPcdManipSpecialOffloadCapwapParams *p_Params;
+    t_Error err = E_OK;
+    uint32_t tmpReg32 = 0;
 
-    p_IPSecParams = &p_ManipParams->u.specialOffload.u.ipsec;
+    SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams, E_INVALID_HANDLE);
 
-    SANITY_CHECK_RETURN_ERROR(!p_IPSecParams->variableIpHdrLen ||
-                              p_IPSecParams->decryption, E_INVALID_VALUE);
-    SANITY_CHECK_RETURN_ERROR(!p_IPSecParams->variableIpVersion ||
-                              !p_IPSecParams->decryption, E_INVALID_VALUE);
-    SANITY_CHECK_RETURN_ERROR(!p_IPSecParams->variableIpVersion ||
-                              p_IPSecParams->outerIPHdrLen, E_INVALID_VALUE);
+    p_Params = &p_ManipParams->u.specialOffload.u.capwap;
 
     p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
-
     tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
-    tmpReg32 |= (p_IPSecParams->decryption)?FM_PCD_MANIP_IPSEC_DEC:0;
-    tmpReg32 |= (p_IPSecParams->ecnCopy)?FM_PCD_MANIP_IPSEC_ECN_EN:0;
-    tmpReg32 |= (p_IPSecParams->dscpCopy)?FM_PCD_MANIP_IPSEC_DSCP_EN:0;
-    tmpReg32 |= (p_IPSecParams->variableIpHdrLen)?FM_PCD_MANIP_IPSEC_VIPL_EN:0;
-    tmpReg32 |= (p_IPSecParams->variableIpVersion)?FM_PCD_MANIP_IPSEC_VIPV_EN:0;
+    tmpReg32 |= (p_Params->dtls) ? FM_PCD_MANIP_CAPWAP_DTLS : 0;
+    /* TODO - add 'qosSrc' */
     WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
 
-    tmpReg32 = HMAN_OC_IPSEC_MANIP;
-    tmpReg32 |= p_IPSecParams->outerIPHdrLen << FM_PCD_MANIP_IPSEC_IP_HDR_LEN_SHIFT;
+    tmpReg32 = HMAN_OC_CAPWAP_MANIP;
     if (p_ManipParams->h_NextManip)
     {
-        WRITE_UINT32(p_Ad->matchTblPtr,
-                    (uint32_t)(XX_VirtToPhys(((t_FmPcdManip *)p_ManipParams->h_NextManip)->h_Ad)-
-                               (((t_FmPcd *)p_Manip->h_FmPcd)->physicalMuramBase)) >> 4);
+        WRITE_UINT32(
+                p_Ad->matchTblPtr,
+                (uint32_t)(XX_VirtToPhys(((t_FmPcdManip *)p_ManipParams->h_NextManip)->h_Ad)- (((t_FmPcd *)p_Manip->h_FmPcd)->physicalMuramBase)) >> 4);
 
-        tmpReg32 |= FM_PCD_MANIP_IPSEC_NADEN;
+        tmpReg32 |= FM_PCD_MANIP_CAPWAP_NADEN;
     }
+
     WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
 
     return err;
 }
+#endif /* (DPAA_VERSION >= 11) */
 
-#ifdef FM_CAPWAP_SUPPORT
-static t_Error CheckStatsParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdStatsParams *p_StatsParams)
-{
-
-    switch (p_StatsParams->type)
-    {
-        case (e_FM_PCD_STATS_PER_FLOWID):
-            p_Manip->opcode = HMAN_OC_CAPWAP_INDEXED_STATS;
-            p_Manip->muramAllocate = TRUE;
-            break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported statistics type"));
-    }
-
-    return E_OK;
-}
-#endif /* FM_CAPWAP_SUPPORT */
-
-static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool stats)
+static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params,
+                                    bool stats)
 {
-    t_FmPcdManip                *p_Manip;
-    t_Error                     err;
-    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdManip *p_Manip;
+    t_Error err;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
 
     p_Manip = (t_FmPcdManip*)XX_Malloc(sizeof(t_FmPcdManip));
     if (!p_Manip)
@@ -3271,59 +4319,62 @@ static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool s
     memset(p_Manip, 0, sizeof(t_FmPcdManip));
 
     p_Manip->type = ((t_FmPcdManipParams *)p_Params)->type;
-    memcpy((uint8_t*)&p_Manip->manipParams, p_Params, sizeof(p_Manip->manipParams));
+    memcpy((uint8_t*)&p_Manip->manipParams, p_Params,
+           sizeof(p_Manip->manipParams));
 
     if (!stats)
-        err = CheckManipParamsAndSetType(p_Manip, (t_FmPcdManipParams *)p_Params);
-#ifdef FM_CAPWAP_SUPPORT
+        err = CheckManipParamsAndSetType(p_Manip,
+                                         (t_FmPcdManipParams *)p_Params);
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
     else
         err = CheckStatsParamsAndSetType(p_Manip, (t_FmPcdStatsParams *)p_Params);
-#else
+#else /* not (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
     else
     {
         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Statistics node!"));
+        XX_Free(p_Manip);
         return NULL;
     }
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
     if (err)
     {
-        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("INVALID HEADER MANIPULATION TYPE"));
-        ReleaseManipHandler(p_Manip, p_FmPcd);
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Invalid header manipulation type"));
         XX_Free(p_Manip);
         return NULL;
     }
 
-    if (p_Manip->opcode != HMAN_OC_IP_REASSEMBLY)
+    if ((p_Manip->opcode != HMAN_OC_IP_REASSEMBLY) && (p_Manip->opcode != HMAN_OC_CAPWAP_REASSEMBLY))
     {
-        /* In Case of IP reassembly manipulation the IPv4/IPv6 reassembly action descriptor will
-           be defines later on */
+        /* In Case of reassembly manipulation the reassembly action descriptor will
+         be defines later on */
         if (p_Manip->muramAllocate)
         {
-            p_Manip->h_Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                                        FM_PCD_CC_AD_ENTRY_SIZE,
-                                                        FM_PCD_CC_AD_TABLE_ALIGN);
-             if (!p_Manip->h_Ad)
-             {
+            p_Manip->h_Ad = (t_Handle)FM_MURAM_AllocMem(
+                    p_FmPcd->h_FmMuram, FM_PCD_CC_AD_ENTRY_SIZE,
+                    FM_PCD_CC_AD_TABLE_ALIGN);
+            if (!p_Manip->h_Ad)
+            {
                 REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Manipulation action descriptor"));
                 ReleaseManipHandler(p_Manip, p_FmPcd);
                 XX_Free(p_Manip);
                 return NULL;
-             }
+            }
 
-            IOMemSet32(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+            IOMemSet32(p_Manip->h_Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
         }
         else
         {
-            p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
-             if (!p_Manip->h_Ad)
-             {
+            p_Manip->h_Ad = (t_Handle)XX_Malloc(
+                    FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+            if (!p_Manip->h_Ad)
+            {
                 REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of Manipulation action descriptor"));
                 ReleaseManipHandler(p_Manip, p_FmPcd);
                 XX_Free(p_Manip);
                 return NULL;
-             }
+            }
 
-            memset(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+            memset(p_Manip->h_Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
         }
     }
 
@@ -3332,29 +4383,32 @@ static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool s
     return p_Manip;
 }
 
-static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfManip(t_FmPcdManip     *p_CrntMdfManip,
-                                                       t_List            *h_NodesLst)
+static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfManip(
+        t_FmPcdManip *p_CrntMdfManip, t_List *h_NodesLst)
 {
-    t_CcNodeInformation     *p_CcNodeInformation;
-    t_FmPcdCcNode           *p_NodePtrOnCurrentMdfManip = NULL;
-    t_List                  *p_Pos;
-    int                     i = 0;
-    t_Handle                p_AdTablePtOnCrntCurrentMdfNode/*, p_AdTableNewModified*/;
-    t_CcNodeInformation     ccNodeInfo;
+    t_CcNodeInformation *p_CcNodeInformation;
+    t_FmPcdCcNode *p_NodePtrOnCurrentMdfManip = NULL;
+    t_List *p_Pos;
+    int i = 0;
+    t_Handle p_AdTablePtOnCrntCurrentMdfNode/*, p_AdTableNewModified*/;
+    t_CcNodeInformation ccNodeInfo;
 
     LIST_FOR_EACH(p_Pos, &p_CrntMdfManip->nodesLst)
     {
         p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
-        p_NodePtrOnCurrentMdfManip = (t_FmPcdCcNode *)p_CcNodeInformation->h_CcNode;
+        p_NodePtrOnCurrentMdfManip =
+                (t_FmPcdCcNode *)p_CcNodeInformation->h_CcNode;
 
         ASSERT_COND(p_NodePtrOnCurrentMdfManip);
 
         /* Search in the previous node which exact index points on this current modified node for getting AD */
         for (i = 0; i < p_NodePtrOnCurrentMdfManip->numOfKeys + 1; i++)
         {
-            if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].nextEngineParams.nextEngine
+                    == e_FM_PCD_CC)
             {
-                if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].nextEngineParams.h_Manip == (t_Handle)p_CrntMdfManip)
+                if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].nextEngineParams.h_Manip
+                        == (t_Handle)p_CrntMdfManip)
                 {
                     if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].p_StatsObj)
                         p_AdTablePtOnCrntCurrentMdfNode =
@@ -3374,67 +4428,80 @@ static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfManip(t_FmPcdManip     *p_Crnt
     }
 }
 
-static void BuildHmtd(uint8_t *p_Dest, uint8_t *p_Src, uint8_t *p_Hmcd, t_FmPcd *p_FmPcd)
+static void BuildHmtd(uint8_t *p_Dest, uint8_t *p_Src, uint8_t *p_Hmcd,
+                      t_FmPcd *p_FmPcd)
 {
     t_Error err;
 
-   /* Copy the HMTD */
+    /* Copy the HMTD */
     IO2IOCpy32(p_Dest, (uint8_t*)p_Src, 16);
     /* Replace the HMCT table pointer  */
-    WRITE_UINT32(((t_Hmtd *)p_Dest)->hmcdBasePtr,
-              (uint32_t)(XX_VirtToPhys(p_Hmcd) - ((t_FmPcd*)p_FmPcd)->physicalMuramBase));
+    WRITE_UINT32(
+            ((t_Hmtd *)p_Dest)->hmcdBasePtr,
+            (uint32_t)(XX_VirtToPhys(p_Hmcd) - ((t_FmPcd*)p_FmPcd)->physicalMuramBase));
     /* Call Host Command to replace HMTD by a new HMTD */
-    err = FmHcPcdCcDoDynamicChange(p_FmPcd->h_Hc,
-                                (uint32_t)(XX_VirtToPhys(p_Src) - p_FmPcd->physicalMuramBase),
-                                (uint32_t)(XX_VirtToPhys(p_Dest) - p_FmPcd->physicalMuramBase));
+    err = FmHcPcdCcDoDynamicChange(
+            p_FmPcd->h_Hc,
+            (uint32_t)(XX_VirtToPhys(p_Src) - p_FmPcd->physicalMuramBase),
+            (uint32_t)(XX_VirtToPhys(p_Dest) - p_FmPcd->physicalMuramBase));
     if (err)
         REPORT_ERROR(MINOR, err, ("Failed in dynamic manip change, continued to the rest of the owners."));
 }
 
-static t_Error FmPcdManipInitUpdate(t_Handle h_FmPcd,
-                                    t_Handle h_PcdParams,
-                                    t_Handle h_FmPort,
-                                    t_Handle h_Manip,
-                                    t_Handle h_Ad,
-                                    bool     validate,
-                                    int      level,
+static t_Error FmPcdManipInitUpdate(t_Handle h_FmPcd, t_Handle h_PcdParams,
+                                    t_Handle h_FmPort, t_Handle h_Manip,
+                                    t_Handle h_Ad, bool validate, int level,
                                     t_Handle h_FmTree)
 {
     t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
-    t_Error      err = E_OK;
+    t_Error err = E_OK;
 
-    SANITY_CHECK_RETURN_ERROR(h_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_Manip, E_INVALID_HANDLE);
 
     UNUSED(level);
-    UNUSED(h_FmPcd);
     UNUSED(h_FmTree);
 
     switch (p_Manip->opcode)
     {
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
         case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
-            err = UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(h_FmPort, p_Manip, h_Ad, validate);
-            break;
-#ifdef FM_CAPWAP_SUPPORT
+        err = UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(h_FmPort,
+                p_Manip,
+                h_Ad,
+                validate);
+        break;
         case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
-            if (!p_Manip->h_Frag)
-                break;
+        if (!p_Manip->h_Frag)
+        break;
         case (HMAN_OC_CAPWAP_FRAGMENTATION):
-            err = UpdateInitCapwapFragmentation(h_FmPort, p_Manip, h_Ad, validate, h_FmTree);
-            break;
+        err = UpdateInitCapwapFragmentation(h_FmPort, p_Manip, h_Ad, validate, h_FmTree);
+        break;
         case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-            if (p_Manip->h_Frag)
-                err = UpdateInitCapwapReasm(h_FmPcd, h_FmPort, p_Manip, h_Ad, validate);
-            break;
+        if (p_Manip->h_Frag)
+        err = UpdateInitCapwapReasm(h_FmPcd, h_FmPort, p_Manip, h_Ad, validate);
+        break;
         case (HMAN_OC_CAPWAP_INDEXED_STATS):
-            err = UpdateIndxStats(h_FmPcd, h_FmPort, p_Manip);
-            break;
-#endif /* FM_CAPWAP_SUPPORT */
+        err = UpdateIndxStats(h_FmPcd, h_FmPort, p_Manip);
+        break;
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
         case (HMAN_OC_IP_REASSEMBLY):
-            err = UpdateInitIpReasm(h_FmPcd, h_PcdParams, h_FmPort, p_Manip, h_Ad, validate);
+            err = UpdateInitReasm(h_FmPcd, h_PcdParams, h_FmPort, p_Manip, h_Ad,
+                                  validate);
             break;
         case (HMAN_OC_IP_FRAGMENTATION):
-            err = UpdateInitIpFrag(h_FmPcd, h_PcdParams, h_FmPort, p_Manip, h_Ad, validate);
+            err = UpdateInitIpFrag(h_FmPcd, h_PcdParams, h_FmPort, p_Manip,
+                                   h_Ad, validate);
+            break;
+#if (DPAA_VERSION >= 11)
+        case (HMAN_OC_CAPWAP_FRAGMENTATION):
+            err = UpdateInitCapwapFrag(h_FmPcd, h_PcdParams, h_FmPort, p_Manip,
+                                       h_Ad, validate);
             break;
+        case (HMAN_OC_CAPWAP_REASSEMBLY):
+            err = UpdateInitReasm(h_FmPcd, h_PcdParams, h_FmPort, p_Manip, h_Ad,
+                                  validate);
+            break;
+#endif /* (DPAA_VERSION >= 11) */
         default:
             return E_OK;
     }
@@ -3442,34 +4509,42 @@ static t_Error FmPcdManipInitUpdate(t_Handle h_FmPcd,
     return err;
 }
 
-static t_Error FmPcdManipModifyUpdate(t_Handle h_Manip, t_Handle h_Ad, bool validate, int level, t_Handle h_FmTree)
+static t_Error FmPcdManipModifyUpdate(t_Handle h_Manip, t_Handle h_Ad,
+                                      bool validate, int level,
+                                      t_Handle h_FmTree)
 {
 
-    t_FmPcdManip    *p_Manip = (t_FmPcdManip *)h_Manip;
-    t_Error         err = E_OK;
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_Error err = E_OK;
 
     UNUSED(level);
 
     switch (p_Manip->opcode)
     {
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
         case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("modify node with this type of manipulation  is not suppported"));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_STATE,
+                ("modify node with this type of manipulation  is not suppported"));
         case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
 
-           if (p_Manip->h_Frag)
-           {
-               if (!(p_Manip->shadowUpdateParams & NUM_OF_TASKS) &&
-                   !(p_Manip->shadowUpdateParams & OFFSET_OF_DATA) &&
-                   !(p_Manip->shadowUpdateParams & OFFSET_OF_PR))
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("modify node with this type of manipulation requires manipulation be updated previously in SetPcd function"));
-           }
-           break;
-#ifdef FM_CAPWAP_SUPPORT
+        if (p_Manip->h_Frag)
+        {
+            if (!(p_Manip->shadowUpdateParams & NUM_OF_TASKS)
+                    && !(p_Manip->shadowUpdateParams & OFFSET_OF_DATA)
+                    && !(p_Manip->shadowUpdateParams & OFFSET_OF_PR))
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_STATE,
+                    ("modify node with this type of manipulation requires manipulation be updated previously in SetPcd function"));
+        }
+        break;
         case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
-            if (p_Manip->h_Frag)
-                err = UpdateModifyCapwapFragmenation(p_Manip, h_Ad, validate, h_FmTree);
-            break;
-#endif /* FM_CAPWAP_SUPPORT */
+        if (p_Manip->h_Frag)
+        err = UpdateModifyCapwapFragmenation(p_Manip, h_Ad, validate, h_FmTree);
+        break;
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
         default:
             return E_OK;
     }
@@ -3481,46 +4556,26 @@ static t_Error FmPcdManipModifyUpdate(t_Handle h_Manip, t_Handle h_Ad, bool vali
 /*              Inter-module API routines                                    */
 /*****************************************************************************/
 
-t_Error FmPcdManipUpdate(t_Handle h_FmPcd,
-                         t_Handle h_PcdParams,
-                         t_Handle h_FmPort,
-                         t_Handle h_Manip,
-                         t_Handle h_Ad,
-                         bool     validate,
-                         int      level,
-                         t_Handle h_FmTree,
-                         bool    modify)
+t_Error FmPcdManipUpdate(t_Handle h_FmPcd, t_Handle h_PcdParams,
+                         t_Handle h_FmPort, t_Handle h_Manip, t_Handle h_Ad,
+                         bool validate, int level, t_Handle h_FmTree,
+                         bool modify)
 {
     t_Error err;
 
     if (!modify)
-        err = FmPcdManipInitUpdate(h_FmPcd, h_PcdParams, h_FmPort, h_Manip, h_Ad, validate, level, h_FmTree);
+        err = FmPcdManipInitUpdate(h_FmPcd, h_PcdParams, h_FmPort, h_Manip,
+                                   h_Ad, validate, level, h_FmTree);
     else
         err = FmPcdManipModifyUpdate(h_Manip, h_Ad, validate, level, h_FmTree);
 
     return err;
 }
 
-uint32_t FmPcdManipGetRequiredAction (t_Handle h_Manip)
-{
-    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
-
-    ASSERT_COND(h_Manip);
-
-    switch (p_Manip->opcode)
-    {
-        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-        case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
-            return UPDATE_NIA_ENQ_WITHOUT_DMA;
-        default:
-            return 0;
-    }
-}
-
 void FmPcdManipUpdateOwner(t_Handle h_Manip, bool add)
 {
 
-    uint32_t            intFlags;
+    uint32_t intFlags;
 
     intFlags = XX_LockIntrSpinlock(((t_FmPcdManip *)h_Manip)->h_Spinlock);
     if (add)
@@ -3542,18 +4597,22 @@ t_List *FmPcdManipGetNodeLstPointedOnThisManip(t_Handle h_Manip)
 t_List *FmPcdManipGetSpinlock(t_Handle h_Manip)
 {
     ASSERT_COND(h_Manip);
-   return ((t_FmPcdManip *)h_Manip)->h_Spinlock;
+    return ((t_FmPcdManip *)h_Manip)->h_Spinlock;
 }
 
-t_Error FmPcdManipCheckParamsForCcNextEngine(t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, uint32_t *requiredAction)
+t_Error FmPcdManipCheckParamsForCcNextEngine(
+        t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,
+        uint32_t *requiredAction)
 {
-    t_FmPcdManip             *p_Manip;
-    t_Error                   err;
-    bool                     pointFromCc = TRUE;
-
+    t_FmPcdManip *p_Manip;
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+    t_Error err = E_OK;
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))*/
+    bool pointFromCc = TRUE;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams->h_Manip, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams->h_Manip,
+                              E_NULL_POINTER);
 
     p_Manip = (t_FmPcdManip *)(p_FmPcdCcNextEngineParams->h_Manip);
     *requiredAction = 0;
@@ -3562,48 +4621,74 @@ t_Error FmPcdManipCheckParamsForCcNextEngine(t_FmPcdCcNextEngineParams *p_FmPcdC
     {
         switch (p_Manip->opcode)
         {
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
             case (HMAN_OC_CAPWAP_INDEXED_STATS):
                 if (p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
+                    RETURN_ERROR(MAJOR,	E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
                 if (p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
-                   p_Manip->cnia = TRUE;
+                    p_Manip->cnia = TRUE;
             case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
                 *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
             case (HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
                 p_Manip->ownerTmp++;
                 break;
             case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
-                if ((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE) &&
-                    !p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE with fqidForCtrlFlow FALSE"));
+                if ((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
+                    && !p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
+                    RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_STATE,
+                        ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE with fqidForCtrlFlow FALSE"));
                 p_Manip->ownerTmp++;
                 break;
             case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
-                if ((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_CC)  &&
-                    (FmPcdCcGetParseCode(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode) != CC_PC_GENERIC_IC_HASH_INDEXED))
+                if ((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_CC)
+                    && (FmPcdCcGetParseCode(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)
+                        != CC_PC_GENERIC_IC_HASH_INDEXED))
                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation next engine has to be CC and action = e_FM_PCD_ACTION_INDEXED_LOOKUP"));
-                err = UpdateManipIc(p_FmPcdCcNextEngineParams->h_Manip, FmPcdCcGetOffset(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode));
+                err = UpdateManipIc(p_FmPcdCcNextEngineParams->h_Manip,
+                                    FmPcdCcGetOffset(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode));
                 if (err)
                     RETURN_ERROR(MAJOR, err, NO_MSG);
                 *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
                 break;
+ #endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
             case (HMAN_OC_IP_FRAGMENTATION):
             case (HMAN_OC_IP_REASSEMBLY):
+#if (DPAA_VERSION >= 11)
+            case (HMAN_OC_CAPWAP_REASSEMBLY):
+            case (HMAN_OC_CAPWAP_FRAGMENTATION):
+#endif /* (DPAA_VERSION >= 11) */
                 if (p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
+                    RETURN_ERROR(
+                            MAJOR,
+                            E_INVALID_STATE,
+                            ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
                 p_Manip->ownerTmp++;
                 break;
             case (HMAN_OC_IPSEC_MANIP):
+#if (DPAA_VERSION >= 11)
+            case (HMAN_OC_CAPWAP_MANIP):
+#endif /* (DPAA_VERSION >= 11) */
                 p_Manip->ownerTmp++;
                 break;
             case (HMAN_OC):
-                if (( p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC) && MANIP_IS_CASCADE_NEXT(p_Manip))
-                    RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't have a cascaded manipulation when and Next Engine is CC"));
+                if ((p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC)
+                        && MANIP_IS_CASCADE_NEXT(p_Manip))
+                    RETURN_ERROR(
+                            MINOR,
+                            E_INVALID_STATE,
+                            ("Can't have a cascaded manipulation when and Next Engine is CC"));
                 if (!MANIP_IS_FIRST(p_Manip) && pointFromCc)
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("h_Manip is already used and may not be shared (no sharing of non-head manip nodes)"));
+                    RETURN_ERROR(
+                            MAJOR,
+                            E_INVALID_STATE,
+                            ("h_Manip is already used and may not be shared (no sharing of non-head manip nodes)"));
                 break;
             default:
-                RETURN_ERROR(MAJOR, E_INVALID_STATE,("invalid type of header manipulation for this state"));
+                RETURN_ERROR(
+                        MAJOR, E_INVALID_STATE,
+                        ("invalid type of header manipulation for this state"));
         }
         p_Manip = p_Manip->h_NextManip;
         pointFromCc = FALSE;
@@ -3612,30 +4697,39 @@ t_Error FmPcdManipCheckParamsForCcNextEngine(t_FmPcdCcNextEngineParams *p_FmPcdC
 }
 
 
-t_Error FmPcdManipCheckParamsWithCcNodeParams(t_Handle h_Manip, t_Handle h_FmPcdCcNode)
+t_Error FmPcdManipCheckParamsWithCcNodeParams(t_Handle h_Manip,
+                                              t_Handle h_FmPcdCcNode)
 {
     t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
-    t_Error         err = E_OK;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(h_Manip, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(h_FmPcdCcNode, E_INVALID_HANDLE);
 
     switch (p_Manip->opcode)
     {
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
         case (HMAN_OC_CAPWAP_INDEXED_STATS):
-            if (p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("The manipulation of the type statistics flowId if exist has to be pointed by all numOfKeys"));
-            break;
+        if (p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("The manipulation of the type statistics flowId if exist has to be pointed by all numOfKeys"));
+        break;
         case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-            if (p_Manip->h_Frag)
-            {
-                if (p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("The manipulation of the type remove DTLS if exist has to be pointed by all numOfKeys"));
-                err = UpdateManipIc(h_Manip, FmPcdCcGetOffset(h_FmPcdCcNode));
-                if (err)
-                    RETURN_ERROR(MAJOR, err, NO_MSG);
-            }
-            break;
+        if (p_Manip->h_Frag)
+        {
+            if (p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("The manipulation of the type remove DTLS if exist has to be pointed by all numOfKeys"));
+            err = UpdateManipIc(h_Manip, FmPcdCcGetOffset(h_FmPcdCcNode));
+            if (err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+        break;
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
         default:
             break;
     }
@@ -3643,13 +4737,11 @@ t_Error FmPcdManipCheckParamsWithCcNodeParams(t_Handle h_Manip, t_Handle h_FmPcd
     return err;
 }
 
-void FmPcdManipUpdateAdResultForCc(t_Handle                     h_Manip,
-                                   t_FmPcdCcNextEngineParams    *p_CcNextEngineParams,
-                                   t_Handle                     p_Ad,
-                                   t_Handle                     *p_AdNewPtr)
+void FmPcdManipUpdateAdResultForCc(
+        t_Handle h_Manip, t_FmPcdCcNextEngineParams *p_CcNextEngineParams,
+        t_Handle p_Ad, t_Handle *p_AdNewPtr)
 {
-    t_FmPcdManip            *p_Manip = (t_FmPcdManip *)h_Manip;
-
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
 
     /* This routine creates a Manip AD and can return in "p_AdNewPtr"
      * either the new descriptor or NULL if it writes the Manip AD into p_AD (into the match table) */
@@ -3665,22 +4757,42 @@ void FmPcdManipUpdateAdResultForCc(t_Handle                     h_Manip,
      * p_Ad ( the AD in the match table) and set p_AdNew = NULL. */
     switch (p_Manip->opcode)
     {
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
         case (HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
         case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
         case (HMAN_OC_CAPWAP_INDEXED_STATS):
-            *p_AdNewPtr = p_Manip->h_Ad;
-            break;
+        *p_AdNewPtr = p_Manip->h_Ad;
+        break;
+        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+        case (HMAN_OC_CAPWAP_FRAGMENTATION):
+        WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->fqid,
+                ((t_AdOfTypeResult *)(p_Manip->h_Ad))->fqid);
+        WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->plcrProfile,
+                ((t_AdOfTypeResult *)(p_Manip->h_Ad))->plcrProfile);
+        WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->nia,
+                ((t_AdOfTypeResult *)(p_Manip->h_Ad))->nia);
+        *p_AdNewPtr = NULL;
+        break;
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
         case (HMAN_OC_IPSEC_MANIP):
+#if (DPAA_VERSION >= 11)
+        case (HMAN_OC_CAPWAP_MANIP):
+#endif /* (DPAA_VERSION >= 11) */
             *p_AdNewPtr = p_Manip->h_Ad;
             break;
         case (HMAN_OC_IP_FRAGMENTATION):
-            if ((p_CcNextEngineParams->nextEngine == e_FM_PCD_DONE) &&
-                (!p_CcNextEngineParams->params.enqueueParams.overrideFqid))
+#if (DPAA_VERSION >= 11)
+        case (HMAN_OC_CAPWAP_FRAGMENTATION):
+#endif /* (DPAA_VERSION >= 11) */
+            if ((p_CcNextEngineParams->nextEngine == e_FM_PCD_DONE)
+                    && (!p_CcNextEngineParams->params.enqueueParams.overrideFqid))
             {
-                memcpy((uint8_t *)p_Ad, (uint8_t *)p_Manip->h_Ad, sizeof(t_AdOfTypeContLookup));
+                memcpy((uint8_t *)p_Ad, (uint8_t *)p_Manip->h_Ad,
+                       sizeof(t_AdOfTypeContLookup));
 #if (DPAA_VERSION >= 11)
-                WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,
-                             GET_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase) & ~FM_PCD_MANIP_IP_CNIA);
+                WRITE_UINT32(
+                        ((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,
+                        GET_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase) & ~FM_PCD_MANIP_IP_CNIA);
 #endif /* (DPAA_VERSION >= 11) */
                 *p_AdNewPtr = NULL;
             }
@@ -3690,30 +4802,32 @@ void FmPcdManipUpdateAdResultForCc(t_Handle                     h_Manip,
         case (HMAN_OC_IP_REASSEMBLY):
             if (FmPcdManipIpReassmIsIpv6Hdr(p_Manip))
             {
-                if (!p_Manip->ipReassmParams.ipv6Assigned)
+                if (!p_Manip->reassmParams.ip.ipv6Assigned)
                 {
-                    *p_AdNewPtr = p_Manip->ipReassmParams.h_Ipv6Ad;
-                    p_Manip->ipReassmParams.ipv6Assigned = TRUE;
+                    *p_AdNewPtr = p_Manip->reassmParams.ip.h_Ipv6Ad;
+                    p_Manip->reassmParams.ip.ipv6Assigned = TRUE;
                     FmPcdManipUpdateOwner(h_Manip, FALSE);
                 }
                 else
                 {
-                    *p_AdNewPtr = p_Manip->ipReassmParams.h_Ipv4Ad;
-                    p_Manip->ipReassmParams.ipv6Assigned = FALSE;
+                    *p_AdNewPtr = p_Manip->reassmParams.ip.h_Ipv4Ad;
+                    p_Manip->reassmParams.ip.ipv6Assigned = FALSE;
                 }
             }
             else
-                *p_AdNewPtr = p_Manip->ipReassmParams.h_Ipv4Ad;
-            memcpy((uint8_t *)p_Ad, (uint8_t *)*p_AdNewPtr, sizeof(t_AdOfTypeContLookup));
+                *p_AdNewPtr = p_Manip->reassmParams.ip.h_Ipv4Ad;
+            memcpy((uint8_t *)p_Ad, (uint8_t *)*p_AdNewPtr,
+                   sizeof(t_AdOfTypeContLookup));
             *p_AdNewPtr = NULL;
             break;
-        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
-        case (HMAN_OC_CAPWAP_FRAGMENTATION):
-            WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->fqid,         ((t_AdOfTypeResult *)(p_Manip->h_Ad))->fqid);
-            WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->plcrProfile,  ((t_AdOfTypeResult *)(p_Manip->h_Ad))->plcrProfile);
-            WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->nia,          ((t_AdOfTypeResult *)(p_Manip->h_Ad))->nia);
+#if (DPAA_VERSION >= 11)
+        case (HMAN_OC_CAPWAP_REASSEMBLY):
+            *p_AdNewPtr = p_Manip->reassmParams.capwap.h_Ad;
+            memcpy((uint8_t *)p_Ad, (uint8_t *)*p_AdNewPtr,
+                   sizeof(t_AdOfTypeContLookup));
             *p_AdNewPtr = NULL;
             break;
+#endif /* (DPAA_VERSION >= 11) */
         case (HMAN_OC):
             /* Allocate and initialize HMTD */
             *p_AdNewPtr = p_Manip->h_Ad;
@@ -3723,9 +4837,11 @@ void FmPcdManipUpdateAdResultForCc(t_Handle                     h_Manip,
     }
 }
 
-void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_AdNewPtr, uint32_t adTableOffset)
+void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad,
+                                       t_Handle *p_AdNewPtr,
+                                       uint32_t adTableOffset)
 {
-    t_FmPcdManip            *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
 
     /* This routine creates a Manip AD and can return in "p_AdNewPtr"
      * either the new descriptor or NULL if it writes the Manip AD into p_AD (into the match table) */
@@ -3735,25 +4851,36 @@ void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle
 
     switch (p_Manip->opcode)
     {
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
         case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
-            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,      ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->ccAdBase);
-            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->matchTblPtr,   ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->matchTblPtr);
-            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets,  ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->pcAndOffsets);
-            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->gmask,         ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->gmask);
-            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,      (GET_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase) | adTableOffset));
-            *p_AdNewPtr = NULL;
-            break;
-
+        WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,
+                ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->ccAdBase);
+        WRITE_UINT32(
+                ((t_AdOfTypeContLookup *)p_Ad)->matchTblPtr,
+                ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->matchTblPtr);
+        WRITE_UINT32(
+                ((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets,
+                ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->pcAndOffsets);
+        WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->gmask,
+                ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->gmask);
+        WRITE_UINT32(
+                ((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,
+                (GET_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase) | adTableOffset));
+        *p_AdNewPtr = NULL;
+        break;
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
         case (HMAN_OC):
             /* Initialize HMTD within the match table*/
-            IOMemSet32(p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
-            /* copy the existing HMTD */ /* ask Alla - memcpy??? */
+            IOMemSet32(p_Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+            /* copy the existing HMTD *//* ask Alla - memcpy??? */
             memcpy((uint8_t*)p_Ad, p_Manip->h_Ad, sizeof(t_Hmtd));
             /* update NADEN to be "1"*/
-            WRITE_UINT16(((t_Hmtd *)p_Ad)->cfg,
-                         (uint16_t)(GET_UINT16(((t_Hmtd *)p_Ad)->cfg) | HMTD_CFG_NEXT_AD_EN));
+            WRITE_UINT16(
+                    ((t_Hmtd *)p_Ad)->cfg,
+                    (uint16_t)(GET_UINT16(((t_Hmtd *)p_Ad)->cfg) | HMTD_CFG_NEXT_AD_EN));
             /* update next action descriptor */
-            WRITE_UINT16(((t_Hmtd *)p_Ad)->nextAdIdx, (uint16_t)(adTableOffset >> 4));
+            WRITE_UINT16(((t_Hmtd *)p_Ad)->nextAdIdx,
+                         (uint16_t)(adTableOffset >> 4));
             /* mark that Manip's HMTD is not used */
             *p_AdNewPtr = NULL;
             break;
@@ -3763,30 +4890,49 @@ void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle
     }
 }
 
-t_Error FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv, t_Handle h_CcTree, t_Handle h_Manip, bool isIpv4, uint8_t groupId)
+t_Error FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv,
+                                      t_Handle h_CcTree, t_Handle h_Manip,
+                                      bool isIpv4, uint8_t groupId)
 {
-    t_FmPcdManip            *p_Manip = (t_FmPcdManip *)h_Manip;
-    t_FmPcdKgSchemeParams   *p_SchemeParams = NULL;
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_FmPcdKgSchemeParams *p_SchemeParams = NULL;
+    t_Handle h_Scheme;
 
     ASSERT_COND(p_FmPcd);
     ASSERT_COND(h_NetEnv);
     ASSERT_COND(p_Manip);
 
     /* scheme was already build, no need to check for IPv6 */
-    if (p_Manip->ipReassmParams.h_Ipv4Scheme)
+    if (p_Manip->reassmParams.ip.h_Ipv4Scheme)
         return E_OK;
 
-    p_SchemeParams = XX_Malloc(sizeof(t_FmPcdKgSchemeParams));
+    if (isIpv4) {
+        h_Scheme = FmPcdKgGetSchemeHandle(p_FmPcd, p_Manip->reassmParams.ip.relativeSchemeId[0]);
+        if (h_Scheme) {
+            /* scheme was found */
+            p_Manip->reassmParams.ip.h_Ipv4Scheme = h_Scheme;
+            return E_OK;
+        }
+    } else {
+        h_Scheme = FmPcdKgGetSchemeHandle(p_FmPcd, p_Manip->reassmParams.ip.relativeSchemeId[1]);
+        if (h_Scheme) {
+            /* scheme was found */
+            p_Manip->reassmParams.ip.h_Ipv6Scheme = h_Scheme;
+            return E_OK;
+        }
+    }
+
+     p_SchemeParams = XX_Malloc(sizeof(t_FmPcdKgSchemeParams));
     if (!p_SchemeParams)
-       RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation failed for scheme"));
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("Memory allocation failed for scheme"));
 
     /* Configures the IPv4 or IPv6 scheme*/
     memset(p_SchemeParams, 0, sizeof(t_FmPcdKgSchemeParams));
     p_SchemeParams->netEnvParams.h_NetEnv = h_NetEnv;
-    p_SchemeParams->id.relativeSchemeId =
-        (uint8_t)((isIpv4 == TRUE) ?
-                  p_Manip->ipReassmParams.relativeSchemeId[0] :
-                  p_Manip->ipReassmParams.relativeSchemeId[1]);
+    p_SchemeParams->id.relativeSchemeId = (uint8_t)(
+            (isIpv4 == TRUE) ? p_Manip->reassmParams.ip.relativeSchemeId[0] :
+                    p_Manip->reassmParams.ip.relativeSchemeId[1]);
     p_SchemeParams->schemeCounter.update = TRUE;
 #if (DPAA_VERSION >= 11)
     p_SchemeParams->alwaysDirect = TRUE;
@@ -3796,13 +4942,15 @@ t_Error FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv, t_Han
     p_SchemeParams->baseFqid = 0xFFFFFF; /*TODO- baseFqid*/
 #endif /* (DPAA_VERSION >= 11) */
 
-    setReassmSchemeParams(p_FmPcd, p_SchemeParams, h_CcTree, isIpv4, groupId);
+    setIpReassmSchemeParams(p_FmPcd, p_SchemeParams, h_CcTree, isIpv4, groupId);
 
     /* Sets the new scheme */
     if (isIpv4)
-        p_Manip->ipReassmParams.h_Ipv4Scheme = FM_PCD_KgSchemeSet(p_FmPcd, p_SchemeParams);
+        p_Manip->reassmParams.ip.h_Ipv4Scheme = FM_PCD_KgSchemeSet(
+                p_FmPcd, p_SchemeParams);
     else
-        p_Manip->ipReassmParams.h_Ipv6Scheme = FM_PCD_KgSchemeSet(p_FmPcd, p_SchemeParams);
+        p_Manip->reassmParams.ip.h_Ipv6Scheme = FM_PCD_KgSchemeSet(
+                p_FmPcd, p_SchemeParams);
 
     XX_Free(p_SchemeParams);
 
@@ -3811,29 +4959,80 @@ t_Error FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv, t_Han
 
 t_Error FmPcdManipDeleteIpReassmSchemes(t_Handle h_Manip)
 {
-    t_FmPcdManip    *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
 
     ASSERT_COND(p_Manip);
 
-    if (p_Manip->ipReassmParams.h_Ipv4Scheme)
-        FM_PCD_KgSchemeDelete(p_Manip->ipReassmParams.h_Ipv4Scheme);
+    if ((p_Manip->reassmParams.ip.h_Ipv4Scheme) &&
+        !FmPcdKgIsSchemeHasOwners(p_Manip->reassmParams.ip.h_Ipv4Scheme))
+        FM_PCD_KgSchemeDelete(p_Manip->reassmParams.ip.h_Ipv4Scheme);
 
-    if (p_Manip->ipReassmParams.h_Ipv6Scheme)
-        FM_PCD_KgSchemeDelete(p_Manip->ipReassmParams.h_Ipv6Scheme);
+    if ((p_Manip->reassmParams.ip.h_Ipv6Scheme) &&
+        !FmPcdKgIsSchemeHasOwners(p_Manip->reassmParams.ip.h_Ipv6Scheme))
+        FM_PCD_KgSchemeDelete(p_Manip->reassmParams.ip.h_Ipv6Scheme);
 
     return E_OK;
 }
 
 bool FmPcdManipIpReassmIsIpv6Hdr(t_Handle h_Manip)
 {
-    t_FmPcdManip            *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
+
+    ASSERT_COND(p_Manip);
+
+    return (p_Manip->reassmParams.hdr == HEADER_TYPE_IPv6);
+}
+
+t_Error FmPcdManipBuildCapwapReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv,
+                                          t_Handle h_CcTree, t_Handle h_Manip,
+                                          uint8_t groupId)
+{
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_FmPcdKgSchemeParams *p_SchemeParams = NULL;
+
+    ASSERT_COND(p_FmPcd);
+    ASSERT_COND(h_NetEnv);
+    ASSERT_COND(p_Manip);
+
+    /* scheme was already build, no need to check for IPv6 */
+    if (p_Manip->reassmParams.capwap.h_Scheme)
+        return E_OK;
+
+    p_SchemeParams = XX_Malloc(sizeof(t_FmPcdKgSchemeParams));
+    if (!p_SchemeParams)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,
+                     ("Memory allocation failed for scheme"));
+
+    memset(p_SchemeParams, 0, sizeof(t_FmPcdKgSchemeParams));
+    p_SchemeParams->netEnvParams.h_NetEnv = h_NetEnv;
+    p_SchemeParams->id.relativeSchemeId =
+            (uint8_t)p_Manip->reassmParams.capwap.relativeSchemeId;
+    p_SchemeParams->schemeCounter.update = TRUE;
+    p_SchemeParams->bypassFqidGeneration = TRUE;
+
+    setCapwapReassmSchemeParams(p_FmPcd, p_SchemeParams, h_CcTree, groupId);
+
+    p_Manip->reassmParams.capwap.h_Scheme = FM_PCD_KgSchemeSet(p_FmPcd,
+                                                               p_SchemeParams);
+
+    XX_Free(p_SchemeParams);
+
+    return E_OK;
+}
+
+t_Error FmPcdManipDeleteCapwapReassmSchemes(t_Handle h_Manip)
+{
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
 
     ASSERT_COND(p_Manip);
 
-    return (p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv6);
+    if (p_Manip->reassmParams.capwap.h_Scheme)
+        FM_PCD_KgSchemeDelete(p_Manip->reassmParams.capwap.h_Scheme);
+
+    return E_OK;
 }
 
-#ifdef FM_CAPWAP_SUPPORT
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
 t_Handle FmPcdManipApplSpecificBuild(void)
 {
     t_FmPcdManip *p_Manip;
@@ -3850,18 +5049,18 @@ t_Handle FmPcdManipApplSpecificBuild(void)
     p_Manip->muramAllocate = FALSE;
 
     p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
-     if (!p_Manip->h_Ad)
-     {
+    if (!p_Manip->h_Ad)
+    {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of Manipulation action descriptor"));
         XX_Free(p_Manip);
         return NULL;
-     }
+    }
 
-    memset(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+    memset(p_Manip->h_Ad, 0, FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
 
     /*treatFdStatusFieldsAsErrors = TRUE hardcoded - assumption its always come after CAAM*/
     /*Application specific = type of flowId index, move internal frame header from data to IC,
-    SEC errors check*/
+     SEC errors check*/
     if (MvIntFrameHeaderFromFrameToBufferPrefix(p_Manip, TRUE)!= E_OK)
     {
         XX_Free(p_Manip->h_Ad);
@@ -3878,33 +5077,37 @@ bool FmPcdManipIsCapwapApplSpecific(t_Handle h_Manip)
 
     return (bool)((p_Manip->opcode == HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST) ? TRUE : FALSE);
 }
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
 /*********************** End of inter-module routines ************************/
 
-
 /****************************************/
 /*       API Init unit functions        */
 /****************************************/
 
-t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams)
+t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd,
+                             t_FmPcdManipParams *p_ManipParams)
 {
-    t_FmPcd         *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_FmPcdManip    *p_Manip;
-    t_Error         err;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdManip *p_Manip;
+    t_Error err;
 
-    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE,NULL);
-    SANITY_CHECK_RETURN_VALUE(p_ManipParams,E_INVALID_HANDLE,NULL);
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_ManipParams, E_INVALID_HANDLE, NULL);
 
-    p_Manip =  ManipOrStatsSetNode(h_FmPcd, (t_Handle)p_ManipParams, FALSE);
+    p_Manip = ManipOrStatsSetNode(h_FmPcd, (t_Handle)p_ManipParams, FALSE);
     if (!p_Manip)
         return NULL;
 
-    if (((p_Manip->opcode == HMAN_OC_IP_REASSEMBLY) ||
-         (p_Manip->opcode == HMAN_OC_IP_FRAGMENTATION) ||
-         (p_Manip->opcode == HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX) ||
-         (p_Manip->opcode == HMAN_OC) ||
-         (p_Manip->opcode == HMAN_OC_IPSEC_MANIP)) &&
-        (!FmPcdIsAdvancedOffloadSupported(p_FmPcd)))
+    if (((p_Manip->opcode == HMAN_OC_IP_REASSEMBLY)
+            || (p_Manip->opcode == HMAN_OC_IP_FRAGMENTATION)
+            || (p_Manip->opcode == HMAN_OC)
+            || (p_Manip->opcode == HMAN_OC_IPSEC_MANIP)
+#if (DPAA_VERSION >= 11)
+            || (p_Manip->opcode == HMAN_OC_CAPWAP_MANIP)
+            || (p_Manip->opcode == HMAN_OC_CAPWAP_FRAGMENTATION)
+            || (p_Manip->opcode == HMAN_OC_CAPWAP_REASSEMBLY)
+#endif /* (DPAA_VERSION >= 11) */
+            ) && (!FmPcdIsAdvancedOffloadSupported(p_FmPcd)))
     {
         REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Advanced-offload must be enabled"));
         XX_Free(p_Manip);
@@ -3917,8 +5120,7 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
         ReleaseManipHandler(p_Manip, p_FmPcd);
         XX_Free(p_Manip);
         return NULL;
-    }
-    INIT_LIST(&p_Manip->nodesLst);
+    }INIT_LIST(&p_Manip->nodesLst);
 
     switch (p_Manip->opcode)
     {
@@ -3926,26 +5128,40 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
             /* IpReassembly */
             err = IpReassembly(&p_ManipParams->u.reassem, p_Manip);
             break;
-       case (HMAN_OC_IP_FRAGMENTATION):
+        case (HMAN_OC_IP_FRAGMENTATION):
             /* IpFragmentation */
-            err = IpFragmentation(&p_ManipParams->u.frag.u.ipFrag ,p_Manip);
+            err = IpFragmentation(&p_ManipParams->u.frag.u.ipFrag, p_Manip);
             if (err)
                 break;
             err = IPManip(p_Manip);
             break;
-        case (HMAN_OC_IPSEC_MANIP) :
+        case (HMAN_OC_IPSEC_MANIP):
             err = IPSecManip(p_ManipParams, p_Manip);
             break;
-#ifdef FM_CAPWAP_SUPPORT
-        case (HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
+#if (DPAA_VERSION >= 11)
+        case (HMAN_OC_CAPWAP_REASSEMBLY):
+            /* CapwapReassembly */
+            err = CapwapReassembly(&p_ManipParams->u.reassem, p_Manip);
+            break;
+        case (HMAN_OC_CAPWAP_FRAGMENTATION):
+            /* CapwapFragmentation */
+            err = CapwapFragmentation(&p_ManipParams->u.frag.u.capwapFrag,
+                                      p_Manip);
+            break;
+        case (HMAN_OC_CAPWAP_MANIP):
+            err = CapwapManip(p_ManipParams, p_Manip);
+            break;
+#endif /* (DPAA_VERSION >= 11) */
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+            case (HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
             /* HmanType1 */
             err = RmvHdrTillSpecLocNOrInsrtIntFrmHdr(&p_ManipParams->u.hdr.rmvParams, p_Manip);
             break;
-        case (HMAN_OC_CAPWAP_FRAGMENTATION):
+            case (HMAN_OC_CAPWAP_FRAGMENTATION):
             err = CapwapFragmentation(&p_ManipParams->fragOrReasmParams.u.capwapFragParams,
-                                      p_Manip,
-                                      p_FmPcd,
-                                      p_ManipParams->fragOrReasmParams.sgBpid);
+                    p_Manip,
+                    p_FmPcd,
+                    p_ManipParams->fragOrReasmParams.sgBpid);
             if (err)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
@@ -3954,16 +5170,16 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
                 return NULL;
             }
             if (p_Manip->insrt)
-                p_Manip->opcode = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
-        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+            p_Manip->opcode = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
+            case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
             /* HmanType2 + if user asked only for fragmentation still need to allocate HmanType2 */
             err = InsrtHdrByTempl(&p_ManipParams->u.hdr.insrtParams, p_Manip, p_FmPcd);
             break;
-        case (HMAN_OC_CAPWAP_REASSEMBLY):
+            case (HMAN_OC_CAPWAP_REASSEMBLY):
             err = CapwapReassembly(&p_ManipParams->fragOrReasmParams.u.capwapReasmParams,
-                                   p_Manip,
-                                   p_FmPcd,
-                                   p_ManipParams->fragOrReasmParams.sgBpid);
+                    p_Manip,
+                    p_FmPcd,
+                    p_ManipParams->fragOrReasmParams.sgBpid);
             if (err)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
@@ -3972,21 +5188,21 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
                 return NULL;
             }
             if (p_Manip->rmv)
-                p_Manip->opcode = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
-        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+            p_Manip->opcode = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
+            case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
             /*CAPWAP decapsulation + if user asked only for reassembly still need to allocate CAPWAP decapsulation*/
             err = CapwapRmvDtlsHdr(p_FmPcd, p_Manip);
             break;
-#endif /* FM_CAPWAP_SUPPORT */
-       case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+            case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             /*Application Specific type 1*/
             err = MvIntFrameHeaderFromFrameToBufferPrefix(p_Manip, TRUE);
             break;
-       case (HMAN_OC):
-           /* New Manip */
-           err = CreateManipActionNew(p_Manip, p_ManipParams);
-           break;
-       default:
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
+        case (HMAN_OC):
+            /* New Manip */
+            err = CreateManipActionNew(p_Manip, p_ManipParams);
+            break;
+        default:
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
             ReleaseManipHandler(p_Manip, p_FmPcd);
             XX_Free(p_Manip);
@@ -4014,27 +5230,31 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
     return p_Manip;
 }
 
-t_Error FM_PCD_ManipNodeReplace(t_Handle h_Manip, t_FmPcdManipParams *p_ManipParams)
+t_Error FM_PCD_ManipNodeReplace(t_Handle h_Manip,
+                                t_FmPcdManipParams *p_ManipParams)
 {
-    t_FmPcdManip                *p_Manip = (t_FmPcdManip *)h_Manip, *p_FirstManip;
-    t_FmPcd                     *p_FmPcd = (t_FmPcd *)(p_Manip->h_FmPcd);
-    t_Error                     err;
-    uint8_t                     *p_WholeHmct = NULL, *p_ShadowHmct = NULL, *p_Hmtd = NULL;
-    t_List                      lstOfNodeshichPointsOnCrntMdfManip, *p_Pos;
-    t_CcNodeInformation         *p_CcNodeInfo;
-    SANITY_CHECK_RETURN_ERROR(h_Manip,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_INVALID_HANDLE);
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip, *p_FirstManip;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)(p_Manip->h_FmPcd);
+    t_Error err;
+    uint8_t *p_WholeHmct = NULL, *p_ShadowHmct = NULL, *p_Hmtd = NULL;
+    t_List lstOfNodeshichPointsOnCrntMdfManip, *p_Pos;
+    t_CcNodeInformation *p_CcNodeInfo;
+    SANITY_CHECK_RETURN_ERROR(h_Manip, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams, E_INVALID_HANDLE);
 
     INIT_LIST(&lstOfNodeshichPointsOnCrntMdfManip);
 
-    if ((p_ManipParams->type != e_FM_PCD_MANIP_HDR) ||
-        (p_Manip->type != e_FM_PCD_MANIP_HDR))
-        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
-                     ("FM_PCD_ManipNodeReplace Functionality supported only for Header Manipulation."));
+    if ((p_ManipParams->type != e_FM_PCD_MANIP_HDR)
+            || (p_Manip->type != e_FM_PCD_MANIP_HDR))
+        RETURN_ERROR(
+                MINOR,
+                E_NOT_SUPPORTED,
+                ("FM_PCD_ManipNodeReplace Functionality supported only for Header Manipulation."));
 
     ASSERT_COND(p_Manip->opcode == HMAN_OC);
     ASSERT_COND(p_Manip->manipParams.h_NextManip == p_Manip->h_NextManip);
-    memcpy((uint8_t*)&p_Manip->manipParams, p_ManipParams, sizeof(p_Manip->manipParams));
+    memcpy((uint8_t*)&p_Manip->manipParams, p_ManipParams,
+           sizeof(p_Manip->manipParams));
     p_Manip->manipParams.h_NextManip = p_Manip->h_NextManip;
 
     /* The replacement of the HdrManip depends on the node type.*/
@@ -4076,20 +5296,24 @@ t_Error FM_PCD_ManipNodeReplace(t_Handle h_Manip, t_FmPcdManipParams *p_ManipPar
 
     p_ShadowHmct = (uint8_t*)PTR_MOVE(p_FmPcd->p_CcShadow, 16);
 
-    p_FirstManip = (t_FmPcdManip*)GetManipInfo(p_Manip, e_MANIP_HANDLER_TABLE_OWNER);
+    p_FirstManip = (t_FmPcdManip*)GetManipInfo(p_Manip,
+                                               e_MANIP_HANDLER_TABLE_OWNER);
     ASSERT_COND(p_FirstManip);
 
     if (!LIST_IsEmpty(&p_FirstManip->nodesLst))
-        UpdateAdPtrOfNodesWhichPointsOnCrntMdfManip(p_FirstManip, &lstOfNodeshichPointsOnCrntMdfManip);
+        UpdateAdPtrOfNodesWhichPointsOnCrntMdfManip(
+                p_FirstManip, &lstOfNodeshichPointsOnCrntMdfManip);
 
     p_Hmtd = (uint8_t *)GetManipInfo(p_Manip, e_MANIP_HMTD);
     ASSERT_COND(p_Hmtd);
-    BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_Hmtd, p_ShadowHmct, ((t_FmPcd*)(p_Manip->h_FmPcd)));
+    BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_Hmtd, p_ShadowHmct,
+              ((t_FmPcd*)(p_Manip->h_FmPcd)));
 
     LIST_FOR_EACH(p_Pos, &lstOfNodeshichPointsOnCrntMdfManip)
     {
         p_CcNodeInfo = CC_NODE_F_OBJECT(p_Pos);
-        BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_CcNodeInfo->h_CcNode, p_ShadowHmct, ((t_FmPcd*)(p_Manip->h_FmPcd)));
+        BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_CcNodeInfo->h_CcNode,
+                  p_ShadowHmct, ((t_FmPcd*)(p_Manip->h_FmPcd)));
     }
 
     p_WholeHmct = (uint8_t *)GetManipInfo(p_Manip, e_MANIP_HMCT);
@@ -4105,15 +5329,16 @@ t_Error FM_PCD_ManipNodeReplace(t_Handle h_Manip, t_FmPcdManipParams *p_ManipPar
 
     p_Hmtd = (uint8_t *)GetManipInfo(p_Manip, e_MANIP_HMTD);
     ASSERT_COND(p_Hmtd);
-    BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_Hmtd, p_WholeHmct,((t_FmPcd*)p_Manip->h_FmPcd));
+    BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_Hmtd, p_WholeHmct,
+              ((t_FmPcd*)p_Manip->h_FmPcd));
 
     /* If LIST > 0, create a list of p_Ad's that point to the HMCT. Join also t_HMTD to this list.
      * For each p_Hmct (from list+fixed):
-     * call Host Command to replace HMTD by a new one */
-    LIST_FOR_EACH(p_Pos, &lstOfNodeshichPointsOnCrntMdfManip)
+     * call Host Command to replace HMTD by a new one */LIST_FOR_EACH(p_Pos, &lstOfNodeshichPointsOnCrntMdfManip)
     {
         p_CcNodeInfo = CC_NODE_F_OBJECT(p_Pos);
-        BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_CcNodeInfo->h_CcNode, p_WholeHmct, ((t_FmPcd*)(p_Manip->h_FmPcd)));
+        BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_CcNodeInfo->h_CcNode,
+                  p_WholeHmct, ((t_FmPcd*)(p_Manip->h_FmPcd)));
     }
 
 
@@ -4124,17 +5349,20 @@ t_Error FM_PCD_ManipNodeReplace(t_Handle h_Manip, t_FmPcdManipParams *p_ManipPar
     /* unlock shadow */
     RELEASE_LOCK(p_FmPcd->shadowLock);
 
-   return E_OK;
+    return E_OK;
 }
 
 t_Error FM_PCD_ManipNodeDelete(t_Handle h_ManipNode)
 {
-    t_FmPcdManip    *p_Manip = (t_FmPcdManip *)h_ManipNode;
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_ManipNode;
 
-    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
 
     if (p_Manip->owner)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This manipulation node not be removed because this node is occupied, first - unbind this node "));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_STATE,
+                ("This manipulation node not be removed because this node is occupied, first - unbind this node "));
 
     if (p_Manip->h_NextManip)
     {
@@ -4142,14 +5370,16 @@ t_Error FM_PCD_ManipNodeDelete(t_Handle h_ManipNode)
         FmPcdManipUpdateOwner(p_Manip->h_NextManip, FALSE);
     }
 
-    if (p_Manip->p_Hmct && (MANIP_IS_UNIFIED_FIRST(p_Manip) || !MANIP_IS_UNIFIED(p_Manip)))
-        FM_MURAM_FreeMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, p_Manip->p_Hmct);
+    if (p_Manip->p_Hmct
+            && (MANIP_IS_UNIFIED_FIRST(p_Manip) || !MANIP_IS_UNIFIED(p_Manip)))
+        FM_MURAM_FreeMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram,
+                         p_Manip->p_Hmct);
 
     if (p_Manip->h_Spinlock)
-     {
-         XX_FreeSpinlock(p_Manip->h_Spinlock);
-         p_Manip->h_Spinlock = NULL;
-     }
+    {
+        XX_FreeSpinlock(p_Manip->h_Spinlock);
+        p_Manip->h_Spinlock = NULL;
+    }
 
     ReleaseManipHandler(p_Manip, p_Manip->h_FmPcd);
 
@@ -4158,9 +5388,10 @@ t_Error FM_PCD_ManipNodeDelete(t_Handle h_ManipNode)
     return E_OK;
 }
 
-t_Error FM_PCD_ManipGetStatistics(t_Handle h_ManipNode, t_FmPcdManipStats *p_FmPcdManipStats)
+t_Error FM_PCD_ManipGetStatistics(t_Handle h_ManipNode,
+                                  t_FmPcdManipStats *p_FmPcdManipStats)
 {
-    t_FmPcdManip                *p_Manip = (t_FmPcdManip *)h_ManipNode;
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_ManipNode;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcdManipStats, E_NULL_POINTER);
@@ -4168,51 +5399,62 @@ t_Error FM_PCD_ManipGetStatistics(t_Handle h_ManipNode, t_FmPcdManipStats *p_FmP
     switch (p_Manip->opcode)
     {
         case (HMAN_OC_IP_REASSEMBLY):
-            return IpReassemblyStats(p_Manip, &p_FmPcdManipStats->u.reassem.u.ipReassem);
-       case (HMAN_OC_IP_FRAGMENTATION):
-            return IpFragmentationStats(p_Manip, &p_FmPcdManipStats->u.frag.u.ipFrag);
-       default:
-            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("no statistics to this type of manip"));
+            return IpReassemblyStats(p_Manip,
+                                     &p_FmPcdManipStats->u.reassem.u.ipReassem);
+        case (HMAN_OC_IP_FRAGMENTATION):
+            return IpFragmentationStats(p_Manip,
+                                        &p_FmPcdManipStats->u.frag.u.ipFrag);
+#if (DPAA_VERSION >= 11)
+        case (HMAN_OC_CAPWAP_REASSEMBLY):
+            return CapwapReassemblyStats(
+                    p_Manip, &p_FmPcdManipStats->u.reassem.u.capwapReassem);
+	case (HMAN_OC_CAPWAP_FRAGMENTATION):
+		return CapwapFragmentationStats(
+			p_Manip, &p_FmPcdManipStats->u.frag.u.capwapFrag);
+#endif /* (DPAA_VERSION >= 11) */
+        default:
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                         ("no statistics to this type of manip"));
     }
 
     return E_OK;
 }
 
-#ifdef FM_CAPWAP_SUPPORT
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
 t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_StatsParams)
 {
-    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_FmPcdManip                *p_Manip;
-    t_Error                     err;
+    t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdManip *p_Manip;
+    t_Error err;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE,NULL);
     SANITY_CHECK_RETURN_VALUE(p_StatsParams,E_INVALID_HANDLE,NULL);
 
-    p_Manip =  ManipOrStatsSetNode(h_FmPcd, (t_Handle)p_StatsParams, TRUE);
+    p_Manip = ManipOrStatsSetNode(h_FmPcd, (t_Handle)p_StatsParams, TRUE);
     if (!p_Manip)
-        return NULL;
+    return NULL;
 
-     switch (p_Manip->opcode)
-     {
+    switch (p_Manip->opcode)
+    {
         case (HMAN_OC_CAPWAP_INDEXED_STATS):
-            /* Indexed statistics */
-            err = IndxStats(p_StatsParams, p_Manip, p_FmPcd);
-            break;
+        /* Indexed statistics */
+        err = IndxStats(p_StatsParams, p_Manip, p_FmPcd);
+        break;
         default:
-            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED Statistics type"));
-            ReleaseManipHandler(p_Manip, p_FmPcd);
-            XX_Free(p_Manip);
-            return NULL;
-     }
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED Statistics type"));
+        ReleaseManipHandler(p_Manip, p_FmPcd);
+        XX_Free(p_Manip);
+        return NULL;
+    }
 
-     if (err)
-     {
-         REPORT_ERROR(MAJOR, err, NO_MSG);
-         ReleaseManipHandler(p_Manip, p_FmPcd);
-         XX_Free(p_Manip);
-         return NULL;
-     }
+    if (err)
+    {
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        ReleaseManipHandler(p_Manip, p_FmPcd);
+        XX_Free(p_Manip);
+        return NULL;
+    }
 
-     return p_Manip;
+    return p_Manip;
 }
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.h
index f770c0f..de7e4c8 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.h
@@ -52,19 +52,27 @@
 
 #define NUM_OF_SCRATCH_POOL_BUFFERS             1000 /*TODO - Change it!!*/
 
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
 #define HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR                      0x2e
 #define HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER              0x31
+#define HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX     0x2f
+#define HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST                        0x30
+#define HMAN_OC_CAPWAP_REASSEMBLY                               0x11 /* dummy */
+#define HMAN_OC_CAPWAP_INDEXED_STATS                            0x32 /* dummy */
 #define HMAN_OC_CAPWAP_FRAGMENTATION                            0x33
+#else
+#define HMAN_OC_CAPWAP_MANIP                                    0x2F
+#define HMAN_OC_CAPWAP_FRAG_CHECK                               0x2E
+#define HMAN_OC_CAPWAP_FRAGMENTATION                            0x33
+#define HMAN_OC_CAPWAP_REASSEMBLY                               0x30
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
 #define HMAN_OC_IP_MANIP                                        0x34
 #define HMAN_OC_IP_FRAGMENTATION                                0x74
 #define HMAN_OC_IP_REASSEMBLY                                   0xB4
 #define HMAN_OC_IPSEC_MANIP                                     0xF4
-#define HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX     0x2f
-#define HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST                        0x30
-#define HMAN_OC_CAPWAP_REASSEMBLY                               0x11 /* dummy */
-#define HMAN_OC_CAPWAP_INDEXED_STATS                            0x32 /* dummy */
 #define HMAN_OC                                                 0x35
 
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
 #define HMAN_RMV_HDR                               0x80000000
 #define HMAN_INSRT_INT_FRM_HDR                     0x40000000
 
@@ -98,28 +106,44 @@
 #define FM_PCD_MANIP_INDEXED_STATS_ENTRY_SIZE               4
 #define FM_PCD_MANIP_INDEXED_STATS_CNIA                     0x20000000
 #define FM_PCD_MANIP_INDEXED_STATS_DPD                      0x10000000
-
-#define FM_PCD_MANIP_IP_REASM_TABLE_SIZE                    0x40
-#define FM_PCD_MANIP_IP_REASM_TABLE_ALIGN                   8
-
-#define FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_SIZE       64
-#define FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_ALIGN      8
-#define FM_PCD_MANIP_IP_REASM_TIME_OUT_BETWEEN_FRAMES       0x80000000
-#define FM_PCD_MANIP_IP_REASM_COUPLING_ENABLE               0x40000000
-#define FM_PCD_MANIP_IP_REASM_COUPLING_MASK                 0xFF000000
-#define FM_PCD_MANIP_IP_REASM_COUPLING_SHIFT                24
-#define FM_PCD_MANIP_IP_REASM_LIODN_MASK                    0x0000003F
-#define FM_PCD_MANIP_IP_REASM_LIODN_SHIFT                   56
-#define FM_PCD_MANIP_IP_REASM_ELIODN_MASK                   0x000003c0
-#define FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT                  38
-#define FM_PCD_MANIP_IP_REASM_COMMON_INT_BUFFER_IDX_MASK    0x000000FF
-#define FM_PCD_MANIP_IP_REASM_COMMON_INT_BUFFER_IDX_SHIFT   24
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
+
+#if (DPAA_VERSION >= 11)
+#define FM_PCD_MANIP_CAPWAP_DTLS                            0x00040000
+#define FM_PCD_MANIP_CAPWAP_NADEN                           0x20000000
+
+#define FM_PCD_MANIP_CAPWAP_FRAG_CHECK_MTU_SHIFT            16
+#define FM_PCD_MANIP_CAPWAP_FRAG_CHECK_NO_FRAGMENTATION     0xFFFF0000
+#define FM_PCD_MANIP_CAPWAP_FRAG_CHECK_CNIA                 0x20000000
+
+#define FM_PCD_MANIP_CAPWAP_FRAG_COMPRESS_EN                0x04000000
+#define FM_PCD_MANIP_CAPWAP_FRAG_SCRATCH_BPID               24
+#define FM_PCD_MANIP_CAPWAP_FRAG_SG_BDID_EN                 0x08000000
+#define FM_PCD_MANIP_CAPWAP_FRAG_SG_BDID_MASK               0xFF000000
+#define FM_PCD_MANIP_CAPWAP_FRAG_SG_BDID_SHIFT              24
+#endif /* (DPAA_VERSION >= 11) */
+
+#define FM_PCD_MANIP_REASM_TABLE_SIZE                    0x40
+#define FM_PCD_MANIP_REASM_TABLE_ALIGN                   8
+
+#define FM_PCD_MANIP_REASM_COMMON_PARAM_TABLE_SIZE       64
+#define FM_PCD_MANIP_REASM_COMMON_PARAM_TABLE_ALIGN      8
+#define FM_PCD_MANIP_REASM_TIME_OUT_BETWEEN_FRAMES       0x80000000
+#define FM_PCD_MANIP_REASM_COUPLING_ENABLE               0x40000000
+#define FM_PCD_MANIP_REASM_COUPLING_MASK                 0xFF000000
+#define FM_PCD_MANIP_REASM_COUPLING_SHIFT                24
+#define FM_PCD_MANIP_REASM_LIODN_MASK                    0x0000003F
+#define FM_PCD_MANIP_REASM_LIODN_SHIFT                   56
+#define FM_PCD_MANIP_REASM_ELIODN_MASK                   0x000003c0
+#define FM_PCD_MANIP_REASM_ELIODN_SHIFT                  38
+#define FM_PCD_MANIP_REASM_COMMON_INT_BUFFER_IDX_MASK    0x000000FF
+#define FM_PCD_MANIP_REASM_COMMON_INT_BUFFER_IDX_SHIFT   24
+#define FM_PCD_MANIP_REASM_TIMEOUT_THREAD_THRESH        1024
 
 #define FM_PCD_MANIP_IP_MTU_SHIFT                           16
 #define FM_PCD_MANIP_IP_NO_FRAGMENTATION                    0xFFFF0000
 #define FM_PCD_MANIP_IP_CNIA                                0x20000000
 
-#define FM_PCD_MANIP_IP_REASSM_TIMEOUT_THREAD_THRESH        1024
 #define FM_PCD_MANIP_IP_FRAG_DF_SHIFT                       28
 #define FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID                   24
 #define FM_PCD_MANIP_IP_FRAG_SG_BDID_EN                     0x08000000
@@ -149,6 +173,13 @@
 #define HMCD_OPCODE_TCP_UDP_UPDATE              0x0E
 #define HMCD_OPCODE_TCP_UDP_CHECKSUM            0x14
 #define HMCD_OPCODE_REPLACE_IP                  0x12
+#define HMCD_OPCODE_RMV_TILL                    0x15
+#define HMCD_OPCODE_UDP_INSRT                   0x16
+#define HMCD_OPCODE_IP_INSRT                    0x17
+#define HMCD_OPCODE_CAPWAP_RMV                  0x18
+#define HMCD_OPCODE_CAPWAP_INSRT                0x18
+
+#define HMCD_LAST                               0x00800000
 
 #define HMCD_DSCP_VALUES                        64
 
@@ -157,8 +188,17 @@
 #define HMCD_PARAM_SIZE                         4
 #define HMCD_IPV4_ADDR_SIZE                     4
 #define HMCD_IPV6_ADDR_SIZE                     0x10
+#define HMCD_L4_HDR_SIZE                        8
+
+#define HMCD_CAPWAP_INSRT                       0x00010000
+#define HMCD_INSRT_UDP_LITE                     0x00010000
+#define HMCD_IP_ID_MASK                         0x0000FFFF
+#define HMCD_IP_SIZE_MASK                       0x0000FF00
+#define HMCD_IP_SIZE_SHIFT                      8
+#define HMCD_IP_LAST_PID_MASK                   0x000000FF
+#define HMCD_IP_OR_QOS                          0x00010000
+#define HMCD_IP_L4_CS_CALC                      0x00040000
 
-#define HMCD_LAST                               0x00800000
 
 #define HMCD_OC_SHIFT                           24
 
@@ -271,7 +311,8 @@ typedef enum e_ManipInfo {
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
 
-typedef _Packed struct t_CapwapReasmPram {
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+typedef struct t_CapwapReasmPram {
     volatile uint32_t mode;
     volatile uint32_t autoLearnHashTblPtr;
     volatile uint32_t intStatsTblPtr;
@@ -295,18 +336,19 @@ typedef _Packed struct t_CapwapReasmPram {
     volatile uint32_t internalBufferBusy;
     volatile uint32_t externalBufferBusy;
     volatile uint32_t reserved1[4];
-} _PackedType t_CapwapReasmPram;
+} t_CapwapReasmPram;
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
 
-typedef _Packed struct t_IpReassTbl {
+typedef _Packed struct t_ReassTbl {
     volatile uint16_t waysNumAndSetSize;
     volatile uint16_t autoLearnHashKeyMask;
-    volatile uint32_t ipReassCommonPrmTblPtr;
+    volatile uint32_t reassCommonPrmTblPtr;
     volatile uint32_t liodnAlAndAutoLearnHashTblPtrHi;
     volatile uint32_t autoLearnHashTblPtrLow;
     volatile uint32_t liodnSlAndAutoLearnSetLockTblPtrHi;
     volatile uint32_t autoLearnSetLockTblPtrLow;
-    volatile uint16_t minFragSize;
-    volatile uint16_t reserved1;
+    volatile uint16_t minFragSize; /* Not relevant for CAPWAP*/
+    volatile uint16_t maxReassemblySize; /* Only relevant for CAPWAP*/
     volatile uint32_t totalSuccessfullyReasmFramesCounter;
     volatile uint32_t totalValidFragmentCounter;
     volatile uint32_t totalProcessedFragCounter;
@@ -315,9 +357,9 @@ typedef _Packed struct t_IpReassTbl {
     volatile uint32_t totalDiscardedFragsCounter;
     volatile uint32_t totalMoreThan16FramesCounter;
     volatile uint32_t reserved2[2];
-} _PackedType t_IpReassTbl;
+} _PackedType t_ReassTbl;
 
-typedef _Packed struct t_IpReassCommonTbl {
+typedef struct t_ReassCommonTbl {
     volatile uint32_t timeoutModeAndFqid;
     volatile uint32_t reassFrmDescIndexPoolTblPtr;
     volatile uint32_t liodnAndReassFrmDescPoolPtrHi;
@@ -334,7 +376,7 @@ typedef _Packed struct t_IpReassCommonTbl {
     volatile uint32_t totalDmaSemaphoreDepletionCounter;
     volatile uint32_t totalNCSPCounter;
     volatile uint32_t discardMask;
-} _PackedType t_IpReassCommonTbl;
+} t_ReassCommonTbl;
 
 typedef _Packed struct t_Hmtd {
     volatile uint16_t   cfg;
@@ -355,6 +397,7 @@ typedef _Packed struct t_Hmtd {
 /***********************************************************************/
 /*  Driver's internal structures                                       */
 /***********************************************************************/
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
 typedef struct
 {
     t_Handle p_AutoLearnHashTbl;
@@ -371,7 +414,8 @@ typedef struct
     uint32_t fqidForTimeOutFrames;
     uint32_t timeoutRoutineRequestTime;
     uint32_t bitFor1Micro;
-} t_FragParams;
+} t_CapwapFragParams;
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
 
 typedef struct
 {
@@ -379,21 +423,12 @@ typedef struct
 #if (DPAA_VERSION == 10)
     uint8_t                 scratchBpid;
 #endif /* (DPAA_VERSION == 10) */
-} t_IpFragParams;
+} t_FragParams;
 
-typedef struct t_IpReassmParams
+typedef struct t_ReassmParams
 {
-    t_Handle                        h_Ipv4Ad;
-    t_Handle                        h_Ipv6Ad;
-    bool                            ipv6Assigned;
     e_NetHeaderType                 hdr; /* Header selection */
-    t_IpReassCommonTbl              *p_IpReassCommonTbl;
-    t_IpReassTbl                    *p_Ipv4ReassTbl;
-    t_IpReassTbl                    *p_Ipv6ReassTbl;
-    uintptr_t                       ipv4AutoLearnHashTblAddr;
-    uintptr_t                       ipv6AutoLearnHashTblAddr;
-    uintptr_t                       ipv4AutoLearnSetLockTblAddr;
-    uintptr_t                       ipv6AutoLearnSetLockTblAddr;
+    t_ReassCommonTbl              	*p_ReassCommonTbl;
     uintptr_t                       reassFrmDescrIndxPoolTblAddr;
     uintptr_t                       reassFrmDescrPoolTblAddr;
     uintptr_t                       timeOutTblAddr;
@@ -406,14 +441,36 @@ typedef struct t_IpReassmParams
     uint32_t                        fqidForTimeOutFrames;
     e_FmPcdManipReassemTimeOutMode  timeOutMode;
     uint32_t                        timeoutThresholdForReassmProcess;
-    uint16_t                        minFragSize[2];
-    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry[2];
-    uint8_t                         relativeSchemeId[2];
-    t_Handle                        h_Ipv4Scheme;
-    t_Handle                        h_Ipv6Scheme;
-    uint32_t                        nonConsistentSpFqid;
-} t_IpReassmParams;
-
+    union {
+	struct {
+		t_Handle                h_Ipv4Ad;
+	    t_Handle                h_Ipv6Ad;
+	    bool                    ipv6Assigned;
+	    t_ReassTbl				*p_Ipv4ReassTbl;
+	    t_ReassTbl              *p_Ipv6ReassTbl;
+	    uintptr_t               ipv4AutoLearnHashTblAddr;
+	    uintptr_t               ipv6AutoLearnHashTblAddr;
+	    uintptr_t               ipv4AutoLearnSetLockTblAddr;
+	    uintptr_t               ipv6AutoLearnSetLockTblAddr;
+	    uint16_t                        minFragSize[2];
+	    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry[2];
+	    uint8_t                         relativeSchemeId[2];
+	    t_Handle                        h_Ipv4Scheme;
+	    t_Handle                        h_Ipv6Scheme;
+	    uint32_t                        nonConsistentSpFqid;
+	} ip;
+	struct {
+		t_Handle                h_Ad;
+	    t_ReassTbl				*p_ReassTbl;
+	    uintptr_t               autoLearnHashTblAddr;
+	    uintptr_t               autoLearnSetLockTblAddr;
+	    uint16_t                maxRessembledsSize;
+	    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry;
+	    uint8_t                 relativeSchemeId;
+	    t_Handle                h_Scheme;
+	} capwap;
+    };
+} t_ReassmParams;
 
 typedef struct{
     e_FmPcdManipType        type;
@@ -437,17 +494,19 @@ typedef struct{
     e_ManipUnifiedPosition  unifiedPosition;
     /* end HdrManip */
     uint8_t                 *p_Template;
-    t_Handle                h_Frag;
-    bool                    frag;
-    bool                    reassm;
-    uint16_t                sizeForFragmentation;
     uint8_t                 owner;
     uint32_t                updateParams;
     uint32_t                shadowUpdateParams;
-    t_FragParams            fragParams;
+    bool                    frag;
+    bool                    reassm;
+    uint16_t                sizeForFragmentation;
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+    t_Handle                h_Frag;
+    t_CapwapFragParams      capwapFragParams;
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
     union {
-        t_IpReassmParams    ipReassmParams;
-        t_IpFragParams      ipFragParams;
+        t_ReassmParams    	reassmParams;
+        t_FragParams      	fragParams;
     };
     uint8_t                 icOffset;
     uint16_t                ownerTmp;
@@ -456,7 +515,6 @@ typedef struct{
     t_Handle                h_FmPcd;
     t_List                  nodesLst;
     t_Handle                h_Spinlock;
-
 } t_FmPcdManip;
 
 typedef struct t_FmPcdCcSavedManipParams
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.c
index 55b87ed..1534331 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.c
@@ -561,20 +561,20 @@ uint8_t FmPcdNetEnvGetUnitId(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType
     return FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS;
 }
 
-t_Error FmPcdUnregisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTbl)
+t_Error FmPcdUnregisterReassmPort(t_Handle h_FmPcd, t_Handle h_ReasmCommonPramTbl)
 {
     t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdCcIpReassmTimeoutParams  ccIpReassmTimeoutParams = {0};
+    t_FmPcdCcReassmTimeoutParams    ccReassmTimeoutParams = {0};
     uint8_t                         result;
     t_Error                         err = E_OK;
 
     ASSERT_COND(p_FmPcd);
-    ASSERT_COND(h_IpReasmCommonPramTbl);
+    ASSERT_COND(h_ReasmCommonPramTbl);
 
-    ccIpReassmTimeoutParams.iprcpt   = (uint32_t)(XX_VirtToPhys(h_IpReasmCommonPramTbl) - p_FmPcd->physicalMuramBase);
-    ccIpReassmTimeoutParams.activate = FALSE; /*Disable Timeout Task*/
+    ccReassmTimeoutParams.iprcpt   = (uint32_t)(XX_VirtToPhys(h_ReasmCommonPramTbl) - p_FmPcd->physicalMuramBase);
+    ccReassmTimeoutParams.activate = FALSE; /*Disable Timeout Task*/
 
-    if ((err = FmHcPcdCcIpTimeoutReassm(p_FmPcd->h_Hc, &ccIpReassmTimeoutParams, &result)) != E_OK)
+    if ((err = FmHcPcdCcTimeoutReassm(p_FmPcd->h_Hc, &ccReassmTimeoutParams, &result)) != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     switch (result)
@@ -848,7 +848,6 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
             return NULL;
         }
     }
-printk(">>pcd pcd 2 >> \n");
 
     if (p_FmPcdParams->plcrSupport)
     {
@@ -860,7 +859,6 @@ printk(">>pcd pcd 2 >> \n");
             return NULL;
         }
     }
-printk(">>pcd pcd 3 >> \n");
 
     if (p_FmPcdParams->prsSupport)
     {
@@ -872,7 +870,6 @@ printk(">>pcd pcd 3 >> \n");
             return NULL;
         }
     }
-printk(">>pcd pcd 4 >> \n");
 
     p_FmPcd->h_Spinlock = XX_InitSpinlock();
     if (!p_FmPcd->h_Spinlock)
@@ -901,7 +898,6 @@ printk(">>pcd pcd 4 >> \n");
         FM_PCD_Free(p_FmPcd);
         return NULL;
     }
-printk(">>pcd pcd 5 >> \n");
 
     return p_FmPcd;
 }
@@ -1001,6 +997,15 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
     }
     IOMemSet32(UINT_TO_PTR(p_FmPcd->ipv6FrameIdAddr), 0,  4);
 
+    /* CAPWAP Frame-Id used for fragmentation */
+    p_FmPcd->capwapFrameIdAddr = PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram, 2, 4));
+    if (!p_FmPcd->capwapFrameIdAddr)
+    {
+        FM_PCD_Free(p_FmPcd);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CAPWAP Frame-Id"));
+    }
+    IOMemSet32(UINT_TO_PTR(p_FmPcd->capwapFrameIdAddr), 0,  2);
+
     XX_Free(p_FmPcd->p_FmPcdDriverParam);
     p_FmPcd->p_FmPcdDriverParam = NULL;
 
@@ -1017,6 +1022,9 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd)
     if (p_FmPcd->ipv6FrameIdAddr)
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_FmPcd->ipv6FrameIdAddr));
 
+    if (p_FmPcd->capwapFrameIdAddr)
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_FmPcd->capwapFrameIdAddr));
+
     if (p_FmPcd->enabled)
         FM_PCD_Disable(p_FmPcd);
 
@@ -1036,8 +1044,7 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd)
 
     if (p_FmPcd->p_FmPcdPlcr)
     {
-        if ((err = PlcrFree(p_FmPcd)) != E_OK)
-            RETURN_ERROR(MINOR, err, NO_MSG);
+        PlcrFree(p_FmPcd);
         XX_Free(p_FmPcd->p_FmPcdPlcr);
         p_FmPcd->p_FmPcdPlcr = NULL;
     }
@@ -1355,17 +1362,16 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                 p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr = HEADER_TYPE_USER_DEFINED_SHIM1;
                 p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt = 0;
             }
-#ifdef FM_CAPWAP_SUPPORT
+#if (DPAA_VERSION >= 11) || ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
             /* UDP_LITE  */
             if (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_UDP_LITE)
             {
-                /* IPSec UDP encapsulation is currently set to use SHIM1 */
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].hdr = HEADER_TYPE_UDP_LITE;
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits++].aliasHdr = HEADER_TYPE_UDP;
                 p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr = HEADER_TYPE_UDP;
                 p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt = 0;
             }
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* (DPAA_VERSION >= 11) || ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT)) */
 
             /* IP FRAG  */
             if ((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPv4) &&
@@ -1373,7 +1379,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
             {
                 /* If IPv4+Frag, we need to set 2 units - SHIM 2 and IPv4. We first set SHIM2, and than check if
                  * IPv4 exists. If so we don't need to set an extra unit
-                 * We consider as "having IPv4" any IPv4 without interchangeable headers
+                 * We consider as "having IPv4" any IPv4 without interchangable headers
                  * but including any options.  */
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].hdr = HEADER_TYPE_IPv4;
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].opt = IPV4_FRAG_1;
@@ -1393,7 +1399,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
             {
                 /* If IPv6+Frag, we need to set 2 units - SHIM 2 and IPv6. We first set SHIM2, and than check if
                  * IPv4 exists. If so we don't need to set an extra unit
-                 * We consider as "having IPv6" any IPv6 without interchangeable headers
+                 * We consider as "having IPv6" any IPv6 without interchangable headers
                  * but including any options.  */
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].hdr = HEADER_TYPE_IPv6;
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].opt = IPV6_FRAG_1;
@@ -1408,6 +1414,18 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                     p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits++].hdrs[0].opt = 0;
                 }
             }
+#if (DPAA_VERSION >= 11)
+            /* CAPWAP FRAG  */
+            if ((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_CAPWAP) &&
+                (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt == CAPWAP_FRAG_1))
+            {
+                p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].hdr = HEADER_TYPE_CAPWAP;
+                p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].opt = CAPWAP_FRAG_1;
+                p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits++].aliasHdr = HEADER_TYPE_USER_DEFINED_SHIM2;
+                p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr = HEADER_TYPE_USER_DEFINED_SHIM2;
+                p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt = 0;
+            }
+#endif /* (DPAA_VERSION >= 11) */
         }
     }
 
@@ -1466,7 +1484,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
             for (k = 0; (k < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
                     && (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE); k++)
             {
-                GET_PRS_HDR_NUM(hdrNum, p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr);
+                hdrNum = GetPrsHdrNum(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr);
                 if ((hdrNum == ILLEGAL_HDR_NUM) || (hdrNum == NO_HDR_NUM))
                 {
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
@@ -1545,7 +1563,7 @@ t_Error FM_PCD_SetAdvancedOffloadSupport(t_Handle h_FmPcd)
         DBG(WARNING, ("FM in guest-mode without IPC, can't validate firmware revision."));
         revInfo.packageRev = IP_OFFLOAD_PACKAGE_NUMBER;
     }
-    if (revInfo.packageRev != IP_OFFLOAD_PACKAGE_NUMBER)
+    if (!IS_OFFLOAD_PACKAGE(revInfo.packageRev))
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Fman ctrl code package"));
 
     if (!p_FmPcd->h_Hc)
@@ -1730,48 +1748,10 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
                 return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_tpcnt);
         case (e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
                 return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_flmcnt);
-
-        default:
-            REPORT_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
-            return 0;
     }
+    return 0;
 }
 
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-t_Error FM_PCD_DumpRegs(t_Handle h_FmPcd)
-{
-    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_Error             err = E_OK;
-
-    DECLARE_DUMP;
-
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
-
-    if (p_FmPcd->p_FmPcdKg)
-        err |= FM_PCD_KgDumpRegs(h_FmPcd);
-    if (p_FmPcd->p_FmPcdPlcr)
-        err |= FM_PCD_PlcrDumpRegs(h_FmPcd);
-    if (p_FmPcd->p_FmPcdPrs)
-        err |= FM_PCD_PrsDumpRegs(h_FmPcd);
-
-    return err;
-}
-
-t_Error FM_PCD_HcDumpRegs(t_Handle h_FmPcd)
-{
-    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-
-    DECLARE_DUMP;
-
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_STATE);
-
-    return FmHcDumpRegs(p_FmPcd->h_Hc);
-}
-#endif /* (defined(DEBUG_ERRORS) && ... */
-
 t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable)
 {
     t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -1805,15 +1785,12 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
             case (e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
                 if (!p_FmPcd->p_FmPcdPlcr)
                     RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - policer is not working"));
-            break;
+                break;
             case (e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
             case (e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
                 if (!p_FmPcd->p_FmPcdPrs)
                     RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - parser is not working"));
-            break;
-            default:
-                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported exception"));
-
+                break;
         }
 
         switch (exception)
@@ -1882,24 +1859,20 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
                     tmpReg &= ~FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE;
                 WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier, tmpReg);
                 break;
-             default:
-                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported exception"));
         }
         /* for ECC exceptions driver automatically enables ECC mechanism, if disabled.
            Driver may disable them automatically, depending on driver's status */
-        if (enable && ( (exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
+        if (enable && ((exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC)))
             FmEnableRamsEcc(p_FmPcd->h_Fm);
-        if (!enable && ( (exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
+        if (!enable && ((exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC)))
             FmDisableRamsEcc(p_FmPcd->h_Fm);
     }
-    else
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
 
     return E_OK;
 }
@@ -1934,8 +1907,7 @@ t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception)
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt -parsrer is not working"));
             break;
         default:
-            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Invalid interrupt requested"));
-
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid interrupt requested"));
     }
     switch (exception)
     {
@@ -1977,8 +1949,6 @@ t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception)
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
             WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr, FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE);
             break;
-        default:
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception may not be forced"));
     }
 
     return E_OK;
@@ -2111,9 +2081,14 @@ t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t
         case (e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
               WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_flmcnt, value);
             break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported type of counter"));
     }
 
-return E_OK;
+    return E_OK;
+}
+
+t_Handle FM_PCD_GetHcPort(t_Handle h_FmPcd)
+{
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    return FmHcGetPort(p_FmPcd->h_Hc);
 }
+
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.h
index ca0fb81..27ec9c5 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.h
@@ -127,7 +127,7 @@ switch (exception){                                                 \
 #endif /* defined(__MWERKS__) && ... */
 
 
-typedef _Packed struct {
+typedef struct {
 /* General Configuration and Status Registers */
     volatile uint32_t fmpl_gcr;         /* 0x000 FMPL_GCR  - FM Policer General Configuration */
     volatile uint32_t fmpl_gsr;         /* 0x004 FMPL_GSR  - FM Policer Global Status Register */
@@ -158,7 +158,7 @@ typedef _Packed struct {
     volatile uint32_t fmpl_dpmr;        /* 0x200 FMPL_DPMR - FM Policer Default Mapping Register */
     volatile uint32_t fmpl_pmr[63];     /*+default 0x204-0x2FF FMPL_PMR1 - FMPL_PMR63, - FM Policer Profile Mapping Registers.
                                            (for port-ID 1-11, only for supported Port-ID registers) */
-} _PackedType t_FmPcdPlcrRegs;
+} t_FmPcdPlcrRegs;
 
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
@@ -238,11 +238,11 @@ typedef struct {
 #endif
 } t_FmPcdKgScheme;
 
-typedef _Packed union {
+typedef union {
     struct fman_kg_scheme_regs schemeRegs;
     struct fman_kg_pe_regs portRegs;
     struct fman_kg_cp_regs clsPlanRegs;
-} _PackedType u_FmPcdKgIndirectAccessRegs;
+} u_FmPcdKgIndirectAccessRegs;
 
 typedef struct {
     struct fman_kg_regs *p_FmPcdKgRegs;
@@ -371,6 +371,7 @@ typedef struct {
     t_FmPcdIdExceptionCallback  *f_FmPcdIndexedException;
     t_Handle                    h_App;
     uintptr_t                   ipv6FrameIdAddr;
+    uintptr_t                   capwapFrameIdAddr;
     bool                        advancedOffloadSupport;
 
     t_FmPcdDriverParam          *p_FmPcdDriverParam;
@@ -396,6 +397,8 @@ uint8_t     FmPcdNetEnvGetUnitId(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeader
 
 t_Error     FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv, t_Handle h_CcTree, t_Handle h_Manip, bool isIpv4, uint8_t groupId);
 t_Error     FmPcdManipDeleteIpReassmSchemes(t_Handle h_Manip);
+t_Error     FmPcdManipBuildCapwapReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv, t_Handle h_CcTree, t_Handle h_Manip, uint8_t groupId);
+t_Error     FmPcdManipDeleteCapwapReassmSchemes(t_Handle h_Manip);
 bool        FmPcdManipIpReassmIsIpv6Hdr(t_Handle h_Manip);
 
 t_Handle    KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams);
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_plcr.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_plcr.c
index e4eeddc..f0f1676 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_plcr.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_plcr.c
@@ -216,7 +216,7 @@ static void GetInfoRateReg(e_FmPcdPlcrRateMode  rateMode,
 
 /* .......... */
 
-static void CalcRates(t_Handle                              h_FmPcd,
+static void CalcRates(uint32_t                              bitFor1Micro,
                       t_FmPcdPlcrNonPassthroughAlgParams    *p_NonPassthroughAlgParam,
                       uint32_t                              *cir,
                       uint32_t                              *cbs,
@@ -224,14 +224,12 @@ static void CalcRates(t_Handle                              h_FmPcd,
                       uint32_t                              *pbs_ebs,
                       uint32_t                              *fpp)
 {
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint64_t    integer, fraction;
-    uint32_t    temp, tsuInTenthNanos, bitFor1Micro;
+    uint32_t    temp, tsuInTenthNanos;
     uint8_t     fppShift=0;
 
-    bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);  /* TimeStamp per nano seconds units */
     /* we want the tsu to count 10 nano for better precision normally tsu is 3.9 nano, now we will get 39 */
-    tsuInTenthNanos = (uint32_t)(1000*10/(1<<bitFor1Micro));
+    tsuInTenthNanos = (uint32_t)(1000*10/(1 << bitFor1Micro));
 
     /* we choose the faster rate to calibrate fpp */
     /* The meaning of this step:
@@ -337,10 +335,14 @@ static t_Error BuildProfileRegs(t_FmPcd                     *p_FmPcd,
                                 t_FmPcdPlcrProfileRegs      *p_PlcrRegs)
 {
     t_Error                 err = E_OK;
-    uint32_t                pemode, gnia, ynia, rnia;
+    uint32_t                pemode, gnia, ynia, rnia, bitFor1Micro;
 
     ASSERT_COND(p_FmPcd);
 
+    bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
+    if (bitFor1Micro == 0)
+    RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Timestamp scale"));
+
 /* Set G, Y, R Nia */
     err = SetProfileNia(p_FmPcd, p_ProfileParams->nextEngineOnGreen,  &(p_ProfileParams->paramsOnGreen), &gnia);
     if (err)
@@ -485,7 +487,7 @@ cont_rfc:
             {
                 uint32_t cir=0, cbs=0, pir_eir=0, pbs_ebs=0, fpp=0;
 
-                CalcRates(p_FmPcd, &p_ProfileParams->nonPassthroughAlgParams, &cir, &cbs, &pir_eir, &pbs_ebs, &fpp);
+                CalcRates(bitFor1Micro, &p_ProfileParams->nonPassthroughAlgParams, &cir, &cbs, &pir_eir, &pbs_ebs, &fpp);
 
                 /*  Set Committed Information Rate (CIR) */
                 p_PlcrRegs->fmpl_pecir = cir;
@@ -1530,53 +1532,6 @@ t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable)
     return E_OK;
 }
 
-/* ... */
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd)
-{
-    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    int                 i = 0;
-
-    DECLARE_DUMP;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(((p_FmPcd->guestId == NCSW_MASTER_ID) ||
-                               p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs), E_INVALID_OPERATION);
-
-    DUMP_SUBTITLE(("\n"));
-    DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FM-PCD policer regs"));
-
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gcr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gsr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_evr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ier);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ifr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eevr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eier);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eifr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rpcnt);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ypcnt);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rrpcnt);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rypcnt);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_tpcnt);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_flmcnt);
-
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_serc);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_upcr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_dpmr);
-
-    DUMP_TITLE(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr, ("fmpl_pmr"));
-    DUMP_SUBSTRUCT_ARRAY(i, 63)
-    {
-        DUMP_MEMORY(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr[i], sizeof(uint32_t));
-    }
-
-    return E_OK;
-}
-#endif /* (defined(DEBUG_ERRORS) && ... */
-
 t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
                                t_FmPcdPlcrProfileParams *p_ProfileParams)
 {
@@ -1625,6 +1580,11 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
                                                     p_ProfileParams->id.newParams.h_FmPort,
                                                     p_ProfileParams->id.newParams.relativeProfileId,
                                                     &absoluteProfileId);
+        if (err)
+        {
+             REPORT_ERROR(MAJOR, err, NO_MSG);
+             return NULL;
+        }
 
          if (absoluteProfileId >= FM_PCD_PLCR_NUM_ENTRIES)
          {
@@ -1884,54 +1844,3 @@ t_Error FM_PCD_PlcrProfileSetCounter(t_Handle h_Profile, e_FmPcdPlcrProfileCount
 
     return E_OK;
 }
-
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_Profile)
-{
-    t_FmPcdPlcrProfile                  *p_Profile = (t_FmPcdPlcrProfile*)h_Profile;
-    t_FmPcd                             *p_FmPcd;
-    t_FmPcdPlcrProfileRegs              *p_ProfilesRegs;
-    uint16_t                            profileIndx;
-    uint32_t                            tmpReg, intFlags;
-
-    DECLARE_DUMP;
-
-    SANITY_CHECK_RETURN_ERROR(p_Profile, E_INVALID_HANDLE);
-    p_FmPcd = p_Profile->h_FmPcd;
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
-
-    profileIndx = p_Profile->absoluteProfileId;
-
-    DUMP_SUBTITLE(("\n"));
-    DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FM-PCD policer-profile regs"));
-
-    p_ProfilesRegs = &p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->profileRegs;
-
-    tmpReg = FmPcdPlcrBuildReadPlcrActionReg((uint16_t)profileIndx);
-    intFlags = PlcrHwLock(p_FmPcd->p_FmPcdPlcr);
-    WritePar(p_FmPcd, tmpReg);
-
-    DUMP_TITLE(p_ProfilesRegs, ("Profile %d regs", profileIndx));
-
-    DUMP_VAR(p_ProfilesRegs, fmpl_pemode);
-    DUMP_VAR(p_ProfilesRegs, fmpl_pegnia);
-    DUMP_VAR(p_ProfilesRegs, fmpl_peynia);
-    DUMP_VAR(p_ProfilesRegs, fmpl_pernia);
-    DUMP_VAR(p_ProfilesRegs, fmpl_pecir);
-    DUMP_VAR(p_ProfilesRegs, fmpl_pecbs);
-    DUMP_VAR(p_ProfilesRegs, fmpl_pepepir_eir);
-    DUMP_VAR(p_ProfilesRegs, fmpl_pepbs_ebs);
-    DUMP_VAR(p_ProfilesRegs, fmpl_pelts);
-    DUMP_VAR(p_ProfilesRegs, fmpl_pects);
-    DUMP_VAR(p_ProfilesRegs, fmpl_pepts_ets);
-    DUMP_VAR(p_ProfilesRegs, fmpl_pegpc);
-    DUMP_VAR(p_ProfilesRegs, fmpl_peypc);
-    DUMP_VAR(p_ProfilesRegs, fmpl_perpc);
-    DUMP_VAR(p_ProfilesRegs, fmpl_perypc);
-    DUMP_VAR(p_ProfilesRegs, fmpl_perrpc);
-    PlcrHwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
-
-    return E_OK;
-}
-#endif /* (defined(DEBUG_ERRORS) && ... */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_prs.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_prs.c
index 1666865..da2fccf 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_prs.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_prs.c
@@ -118,6 +118,12 @@ t_Handle PrsConfig(t_FmPcd *p_FmPcd,t_FmPcdParams *p_FmPcdParams)
     return p_FmPcdPrs;
 }
 
+#if ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
+    static uint8_t             swPrsPatch[] = SW_PRS_UDP_LITE_PATCH;
+#else
+    static uint8_t             swPrsPatch[] = SW_PRS_OFFLOAD_PATCH;
+#endif /* FM_CAPWAP_SUPPORT */
+
 t_Error PrsInit(t_FmPcd *p_FmPcd)
 {
     t_FmPcdDriverParam  *p_Param = p_FmPcd->p_FmPcdDriverParam;
@@ -125,11 +131,6 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
     uint32_t            *p_LoadTarget = (uint32_t *)PTR_MOVE(p_FmPcd->p_FmPcdPrs->p_SwPrsCode,
                                                              FM_PCD_SW_PRS_SIZE-FM_PCD_PRS_SW_PATCHES_SIZE);
     struct fman_prs_regs *PrsRegs = (struct fman_prs_regs *)p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
-#ifdef FM_CAPWAP_SUPPORT
-    uint8_t             swPrsPatch[] = SW_PRS_UDP_LITE_PATCH;
-#else
-    uint8_t             swPrsPatch[] = SW_PRS_IP_FRAG_PATCH;
-#endif /* FM_CAPWAP_SUPPORT */
     uint32_t            i;
 
     ASSERT_COND(sizeof(swPrsPatch) <= (FM_PCD_PRS_SW_PATCHES_SIZE-FM_PCD_PRS_SW_TAIL_SIZE));
@@ -417,49 +418,3 @@ t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd,uint16_t value)
 
     return E_OK;
 }
-
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-t_Error FM_PCD_PrsDumpRegs(t_Handle h_FmPcd)
-{
-    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-
-    DECLARE_DUMP;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(((p_FmPcd->guestId == NCSW_MASTER_ID) ||
-                               p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs), E_INVALID_OPERATION);
-
-    DUMP_SUBTITLE(("\n"));
-    DUMP_TITLE(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs, ("FM-PCD parser regs"));
-
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_rpclim);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_rpimac);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pmeec);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_pevr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_pever);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_perr);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_perer);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_ppsc);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_pds);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_l2rrs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_l3rrs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_l4rrs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_srrs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_l2rres);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_l3rres);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_l4rres);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_srres);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_spcs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_spscs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_hxscs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_mrcs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_mwcs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_mrscs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_mwscs);
-    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fmpr_fcscs);
-
-    return E_OK;
-}
-#endif /* (defined(DEBUG_ERRORS) && ... */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_prs.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_prs.h
index 3e5974c5..0185717 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_prs.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_prs.h
@@ -35,30 +35,59 @@
  @File          fm_prs.h
 
  @Description   FM Parser private header
-*//***************************************************************************/
+ *//***************************************************************************/
 #ifndef __FM_PRS_H
 #define __FM_PRS_H
 
 #include "std_ext.h"
 
-
 /***********************************************************************/
 /*          SW parser IP_FRAG patch                                    */
 /***********************************************************************/
 
-
-#ifdef FM_CAPWAP_SUPPORT
+#if ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
 #define SW_PRS_UDP_LITE_PATCH   \
 {\
-    0x31,0x92,0x50,0x29,0x00,0x88,0x08,0x16,0x00,0x00, \
-    0x00,0x01,0x00,0x05,0x00,0x81,0x1C,0x0B,0x00,0x01, \
-    0x1B,0xFF,                                    \
+        0x31,0x52,0x00,0xDA,0xFC,0x00,0x00,0x00,0x00,0x00, \
+        0x00,0x00,0x50,0x2C,0x40,0x00,0x31,0x92,0x50,0x2C, \
+        0x00,0x88,0x18,0x2F,0x00,0x01,0x1B,0xFE,0x18,0x71, \
+        0x02,0x1F,0x00,0x08,0x00,0x83,0x02,0x1F,0x00,0x20, \
+        0x28,0x1B,0x00,0x05,0x29,0x1F,0x30,0xD0,0x60,0x4F, \
+        0x00,0x07,0x00,0x05,0x00,0x00,0xC3,0x8F,0x00,0x52, \
+        0x00,0x01,0x07,0x01,0x60,0x3B,0x00,0x00,0x30,0xD0, \
+        0x00,0xDA,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00, \
+        0x40,0x4C,0x00,0x00,0x02,0x8F,0x00,0x00,0x30,0xF2, \
+        0x00,0x06,0x18,0x5D,0x00,0x00,0x9F,0xFF,0x30,0xF2, \
+        0x00,0x06,0x29,0x1E,0x07,0x08,0x30,0xD0,0x00,0x52, \
+        0x00,0x08,0x28,0x1A,0x60,0x37,0x00,0x00,0x30,0xF2, \
+        0x18,0x5D,0x06,0x00,0x29,0x1E,0x30,0xF2,0x2F,0x0E, \
+        0x30,0x72,0x00,0x00,0x9B,0x8F,0x00,0x06,0x2F,0x0E, \
+        0x32,0xF1,0x32,0xB0,0x00,0x4F,0x00,0x57,0x00,0x28, \
+        0x00,0x00,0x97,0x9E,0x00,0x4E,0x30,0x72,0x00,0x06, \
+        0x2F,0x0E,0x32,0xC1,0x32,0xF0,0x00,0x4A,0x00,0x80, \
+        0x00,0x02,0x00,0x00,0x97,0x9E,0x40,0x7E,0x00,0x08, \
+        0x08,0x16,0x00,0x54,0x00,0x01,0x1B,0xFE,0x00,0x00, \
+        0x9F,0x9E,0x40,0xB3,0x00,0x00,0x02,0x1F,0x00,0x08, \
+        0x28,0x1B,0x30,0x73,0x29,0x1F,0x30,0xD0,0x60,0x9F, \
+        0x00,0x07,0x00,0x05,0x00,0x00,0xC3,0x8F,0x00,0x52, \
+        0x00,0x01,0x07,0x01,0x60,0x8B,0x00,0x00,0x30,0xD0, \
+        0x00,0xDA,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00, \
+        0x40,0x9C,0x00,0x00,0x02,0x8F,0x00,0x00,0x30,0xF2, \
+        0x00,0x06,0x18,0xAD,0x00,0x00,0x9F,0xFF,0x30,0xF2, \
+        0x00,0x06,0x29,0x1E,0x07,0x08,0x30,0xD0,0x00,0x52, \
+        0x00,0x08,0x28,0x1A,0x60,0x87,0x00,0x00,0x30,0xF2, \
+        0x18,0xAD,0x06,0x00,0x29,0x1E,0x30,0xF2,0x50,0xB3, \
+        0xFF,0xFF,0x18,0xB8,0x08,0x16,0x00,0x54,0x00,0x01, \
+        0x1B,0xFE,0x18,0xC5,0x32,0xF1,0x28,0x5D,0x32,0xF1, \
+        0x00,0x55,0x00,0x08,0x28,0x5F,0x00,0x00,0x8F,0x9F, \
+        0x29,0x33,0x08,0x16,0x00,0x49,0x00,0x01,0x1B,0xFF, \
+        0x00,0x01,0x1B,0xFF    \
 }
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT)) */
 
 #if (DPAA_VERSION == 10)
 /* Version: 106.1.9 */
-#define SW_PRS_IP_FRAG_PATCH                           \
+#define SW_PRS_OFFLOAD_PATCH                           \
 {                                                      \
     0x31,0x52,0x00,0xDA,0x0A,0x00,0x00,0x00,0x00,0x00, \
     0x00,0x00,0x43,0x0A,0x00,0x00,0x00,0x01,0x1B,0xFE, \
@@ -106,64 +135,119 @@
 
 #else
 /* version: 106.3.13 */
-#define SW_PRS_IP_FRAG_PATCH                           \
+#define SW_PRS_OFFLOAD_PATCH                           \
 {                                                      \
-    0x31,0x52,0x00,0xDA,0x0E,0x4F,0x00,0x00,0x00,0x00, \
-    0x00,0x00,0x52,0xF6,0x08,0x4B,0x31,0x53,0x00,0xFB, \
-    0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x29,0x2B, \
-    0x33,0xF1,0x00,0xFB,0x00,0xDF,0x00,0x00,0x00,0x00, \
-    0x00,0x00,0x28,0x7F,0x31,0x52,0x00,0xDA,0x0A,0x00, \
-    0x00,0x00,0x00,0x00,0x00,0x00,0x43,0x00,0x00,0x00, \
-    0x00,0x01,0x1B,0xFE,0x00,0x00,0x99,0x00,0x53,0x09, \
-    0x00,0x00,0x00,0x00,0x9F,0x98,0x53,0x09,0x00,0x00, \
-    0x1B,0x24,0x09,0x5F,0x00,0x20,0x00,0x00,0x09,0x4F, \
-    0x00,0x20,0x00,0x00,0x34,0xB7,0x00,0xF9,0x00,0x00, \
-    0x01,0x00,0x00,0x00,0x00,0x00,0x2B,0x97,0x31,0xB3, \
-    0x29,0x8F,0x33,0xF1,0x00,0xF9,0x00,0x01,0x00,0x00, \
-    0x00,0x00,0x00,0x00,0x28,0x7F,0x00,0x03,0x00,0x02, \
-    0x00,0x00,0x00,0x01,0x1B,0xFE,0x00,0x01,0x1B,0xFE, \
-    0x31,0x52,0x00,0xDA,0x0E,0x4F,0x00,0x00,0x00,0x00, \
-    0x00,0x00,0x53,0x3C,0x04,0x4B,0x31,0x53,0x00,0xFB, \
-    0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x29,0x2B, \
-    0x33,0xF1,0x00,0xFB,0x00,0xDF,0x00,0x00,0x00,0x00, \
-    0x00,0x00,0x28,0x7F,0x31,0x52,0x00,0xDA,0x06,0x00, \
-    0x00,0x00,0x00,0x00,0x00,0x00,0x43,0x46,0x00,0x00, \
-    0x00,0x01,0x1B,0xFE,0x31,0x52,0x00,0xDA,0x00,0x40, \
-    0x00,0x00,0x00,0x00,0x00,0x00,0x53,0xAC,0x00,0x00, \
-    0x00,0x00,0x9B,0x8F,0x2F,0x0F,0x32,0xC1,0x00,0x55, \
-    0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0x5C,0x00,0x00, \
-    0x30,0x7E,0x43,0x5C,0x00,0x3C,0x1B,0x74,0x32,0x11, \
-    0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F, \
-    0x2F,0x0F,0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F, \
-    0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00, \
-    0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D, \
-    0x28,0x43,0x06,0x00,0x1B,0x55,0x30,0x7E,0x53,0x90, \
-    0x00,0x2B,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x81, \
-    0x00,0x00,0x87,0x8F,0x28,0x23,0x06,0x00,0x32,0x11, \
-    0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81, \
-    0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01, \
-    0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00,0x00,0x01, \
-    0x1B,0xFE,0x00,0x00,0x9B,0x8E,0x53,0xA7,0x00,0x00, \
-    0x06,0x29,0x00,0x00,0x83,0x8F,0x28,0x23,0x06,0x00, \
-    0x06,0x29,0x32,0xC1,0x00,0x55,0x00,0x28,0x00,0x00, \
-    0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D, \
-    0x28,0x43,0x06,0x00,0x00,0x01,0x1B,0xFE,0x32,0xC1, \
-    0x00,0x55,0x00,0x28,0x28,0x43,0x1B,0xF1,0x00,0x00, \
-    0x9B,0x8F,0x2F,0x0F,0x32,0xC1,0x00,0x55,0x00,0x28, \
-    0x28,0x43,0x30,0x7E,0x43,0xD6,0x00,0x2C,0x32,0x11, \
-    0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x00,0x87,0x8F, \
-    0x28,0x23,0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F, \
-    0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F,0x06,0x00, \
-    0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01, \
-    0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50, \
-    0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00, \
-    0x1B,0xB3,0x09,0x5F,0x00,0x20,0x00,0x00,0x09,0x4F, \
-    0x00,0x20,0x00,0x00,0x34,0xB7,0x00,0xF9,0x00,0x00, \
-    0x01,0x00,0x00,0x00,0x00,0x00,0x2B,0x97,0x31,0xB3, \
-    0x29,0x8F,0x33,0xF1,0x00,0xF9,0x00,0x01,0x00,0x00, \
-    0x00,0x00,0x00,0x00,0x28,0x7F,0x00,0x03,0x00,0x02, \
-    0x00,0x00,0x00,0x01,0x1B,0xFE,0x00,0x01,0x1B,0xFE, \
+        0x31,0x52,0x00,0xDA,0x0E,0x4F,0x00,0x00,0x00,0x00, \
+        0x00,0x00,0x51,0xE6,0x08,0x4B,0x31,0x53,0x00,0xFB, \
+        0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x29,0x2B, \
+        0x33,0xF1,0x00,0xFB,0x00,0xDF,0x00,0x00,0x00,0x00, \
+        0x00,0x00,0x28,0x7F,0x31,0x52,0x00,0xDA,0x0A,0x00, \
+        0x00,0x00,0x00,0x00,0x00,0x00,0x41,0xF0,0x00,0x00, \
+        0x00,0x01,0x1B,0xFE,0x00,0x00,0x99,0x00,0x51,0xF9, \
+        0x00,0x00,0x00,0x00,0x9F,0x98,0x51,0xF9,0x00,0x00, \
+        0x1A,0x14,0x09,0x5F,0x00,0x20,0x00,0x00,0x09,0x4F, \
+        0x00,0x20,0x00,0x00,0x34,0xB7,0x00,0xF9,0x00,0x00, \
+        0x01,0x00,0x00,0x00,0x00,0x00,0x2B,0x97,0x31,0xB3, \
+        0x29,0x8F,0x33,0xF1,0x00,0xF9,0x00,0x01,0x00,0x00, \
+        0x00,0x00,0x00,0x00,0x28,0x7F,0x00,0x03,0x00,0x02, \
+        0x00,0x00,0x00,0x01,0x1B,0xFE,0x00,0x01,0x1B,0xFE, \
+        0x31,0x52,0x00,0xDA,0xFC,0x00,0x00,0x00,0x00,0x00, \
+        0x00,0x00,0x52,0x22,0x40,0x00,0x31,0x92,0x52,0x22, \
+        0x00,0x88,0x1A,0x25,0x08,0x05,0x00,0x00,0x1A,0x69, \
+        0x02,0x1F,0x00,0x08,0x00,0x83,0x02,0x1F,0x00,0x20, \
+        0x28,0x1B,0x00,0x05,0x29,0x1F,0x30,0xD0,0x62,0x45, \
+        0x00,0x07,0x00,0x05,0x00,0x00,0xC3,0x8F,0x00,0x52, \
+        0x00,0x01,0x07,0x01,0x62,0x31,0x00,0x00,0x30,0xD0, \
+        0x00,0xDA,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00, \
+        0x42,0x42,0x00,0x00,0x02,0x8F,0x00,0x00,0x30,0xF2, \
+        0x00,0x06,0x1A,0x53,0x00,0x00,0x9F,0xFF,0x30,0xF2, \
+        0x00,0x06,0x29,0x1E,0x07,0x08,0x30,0xD0,0x00,0x52, \
+        0x00,0x08,0x28,0x1A,0x62,0x2D,0x00,0x00,0x30,0xF2, \
+        0x1A,0x53,0x06,0x00,0x29,0x1E,0x30,0xF2,0x29,0x0E, \
+        0x30,0x72,0x00,0x00,0x9B,0x8F,0x00,0x06,0x29,0x0E, \
+        0x32,0xF1,0x32,0xB0,0x00,0x4F,0x00,0x57,0x00,0x28, \
+        0x00,0x00,0x97,0x9E,0x00,0x4E,0x30,0x72,0x00,0x06, \
+        0x29,0x0E,0x08,0x05,0x00,0x01,0x31,0x52,0x00,0xDA, \
+        0x0E,0x4F,0x00,0x00,0x00,0x00,0x00,0x00,0x52,0x7F, \
+        0x04,0x4B,0x31,0x53,0x00,0xFB,0xFF,0xF0,0x00,0x00, \
+        0x00,0x00,0x00,0x00,0x29,0x2B,0x33,0xF1,0x00,0xFB, \
+        0x00,0xDF,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x7F, \
+        0x31,0x52,0x00,0xDA,0x06,0x00,0x00,0x00,0x00,0x00, \
+        0x00,0x00,0x42,0x89,0x00,0x00,0x00,0x01,0x1B,0xFE, \
+        0x31,0x52,0x00,0xDA,0x00,0x40,0x00,0x00,0x00,0x00, \
+        0x00,0x00,0x52,0xED,0x00,0x00,0x00,0x00,0x9B,0x8F, \
+        0x28,0x01,0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43, \
+        0x30,0x00,0x42,0x9F,0x00,0x00,0x30,0x00,0x42,0x9F, \
+        0x00,0x3C,0x1A,0xB7,0x32,0x11,0x32,0xC0,0x00,0x4F, \
+        0x00,0x81,0x00,0x00,0x83,0x8F,0x28,0x01,0x06,0x00, \
+        0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01, \
+        0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50, \
+        0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00, \
+        0x1A,0x98,0x30,0x00,0x42,0xD5,0x00,0x2B,0x00,0x00, \
+        0x9B,0x8E,0x42,0xC3,0x00,0x00,0x32,0xC1,0x00,0x55, \
+        0x00,0x28,0x28,0x43,0x1A,0xD4,0x06,0x29,0x00,0x00, \
+        0x83,0x8F,0x28,0x23,0x06,0x00,0x06,0x29,0x32,0xC1, \
+        0x00,0x55,0x00,0x28,0x00,0x00,0x83,0x8E,0x00,0x50, \
+        0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00, \
+        0x1A,0xEC,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x81, \
+        0x00,0x00,0x87,0x8F,0x28,0x23,0x06,0x00,0x32,0x11, \
+        0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81, \
+        0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01, \
+        0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00,0x1B,0x32, \
+        0x00,0x00,0x9B,0x8F,0x28,0x01,0x32,0xC1,0x00,0x55, \
+        0x00,0x28,0x28,0x43,0x30,0x00,0x43,0x17,0x00,0x2C, \
+        0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x00, \
+        0x87,0x8F,0x28,0x23,0x06,0x00,0x32,0x11,0x32,0xC0, \
+        0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F,0x28,0x01, \
+        0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
+        0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
+        0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
+        0x06,0x00,0x1A,0xF4,0x09,0x5F,0x00,0x20,0x00,0x00, \
+        0x09,0x4F,0x00,0x20,0x00,0x00,0x34,0xB7,0x00,0xF9, \
+        0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x2B,0x97, \
+        0x31,0xB3,0x29,0x8F,0x33,0xF1,0x00,0xF9,0x00,0x01, \
+        0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x7F,0x00,0x03, \
+        0x00,0x02,0x00,0x00,0x00,0x01,0x1B,0xFE,0x30,0x50, \
+        0x53,0x37,0x00,0x00,0x00,0x01,0x1B,0xFE,0x32,0xF1, \
+        0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x02,0x00,0x00, \
+        0x97,0x9E,0x43,0x44,0x00,0x08,0x08,0x16,0x00,0x54, \
+        0x00,0x01,0x1B,0xFE,0x00,0x00,0x9F,0x9E,0x43,0x79, \
+        0x00,0x00,0x02,0x1F,0x00,0x08,0x28,0x1B,0x30,0x73, \
+        0x29,0x1F,0x30,0xD0,0x63,0x65,0x00,0x07,0x00,0x05, \
+        0x00,0x00,0xC3,0x8F,0x00,0x52,0x00,0x01,0x07,0x01, \
+        0x63,0x51,0x00,0x00,0x30,0xD0,0x00,0xDA,0x00,0x01, \
+        0x00,0x00,0x00,0x00,0x00,0x00,0x43,0x62,0x00,0x00, \
+        0x02,0x8F,0x00,0x00,0x30,0xF2,0x00,0x06,0x1B,0x73, \
+        0x00,0x00,0x9F,0xFF,0x30,0xF2,0x00,0x06,0x29,0x1E, \
+        0x07,0x08,0x30,0xD0,0x00,0x52,0x00,0x08,0x28,0x1A, \
+        0x63,0x4D,0x00,0x00,0x30,0xF2,0x1B,0x73,0x06,0x00, \
+        0x29,0x1E,0x30,0xF2,0x53,0x79,0xFF,0xFF,0x1B,0x7E, \
+        0x08,0x16,0x00,0x54,0x00,0x01,0x1B,0xFE,0x1B,0x8B, \
+        0x32,0xF1,0x28,0x5D,0x32,0xF1,0x00,0x55,0x00,0x08, \
+        0x28,0x5F,0x00,0x00,0x8F,0x9F,0x29,0x33,0x08,0x16, \
+        0x00,0x49,0x00,0x01,0x1B,0xFF,0x00,0x01,0x1B,0xFF, \
+        0x08,0x07,0x00,0x02,0x00,0x00,0x8D,0x80,0x53,0x97, \
+        0x00,0x01,0x30,0x71,0x00,0x55,0x00,0x01,0x28,0x0F, \
+        0x00,0x00,0x8D,0x00,0x53,0x9F,0x00,0x01,0x30,0x71, \
+        0x00,0x55,0x00,0x01,0x28,0x0F,0x00,0x00,0x83,0x8E, \
+        0x53,0xB4,0x00,0x00,0x00,0x00,0x86,0x08,0x30,0x71, \
+        0x00,0x7B,0x03,0xB4,0x33,0xB4,0x00,0xDA,0xFF,0xFF, \
+        0x00,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x86,0x09, \
+        0x01,0x03,0x00,0x7D,0x03,0xB4,0x1B,0xC3,0x33,0xD1, \
+        0x00,0xF9,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00, \
+        0x28,0x7B,0x09,0x5F,0x00,0x1A,0x00,0x00,0x09,0x4F, \
+        0x00,0x1A,0x00,0x00,0x00,0x01,0x1B,0xFF,0x00,0x00, \
+        0x8C,0x00,0x53,0xEB,0x00,0x01,0x34,0xF5,0x00,0xFB, \
+        0xFF,0xFF,0x00,0x7F,0x00,0x00,0x00,0x00,0x2A,0x9F, \
+        0x00,0x00,0x93,0x8F,0x28,0x49,0x00,0x00,0x97,0x8F, \
+        0x28,0x4B,0x34,0x61,0x28,0x4D,0x34,0x71,0x28,0x4F, \
+        0x34,0xB7,0x00,0xF9,0x00,0x00,0x01,0x00,0x00,0x00, \
+        0x00,0x00,0x2B,0x97,0x33,0xF1,0x00,0xF9,0x00,0x01, \
+        0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x7F,0x00,0x03, \
+        0x00,0x02,0x00,0x00,0x00,0x01,0x1B,0xFF,0x00,0x01, \
+        0x1B,0xFF, \
 }
+
 #endif /* (DPAA_VERSION == 10) */
 
 /****************************/
@@ -189,5 +273,4 @@
 #define GET_FM_PCD_INDEX_FLAG(bitMask, prsPortId)    \
     bitMask = 0x80000000>>prsPortId
 
-
 #endif /* __FM_PRS_H */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_replic.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_replic.c
index 543b9bb..ee82f73 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_replic.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_replic.c
@@ -380,10 +380,11 @@ static t_Error AllocMember(t_FmPcdFrmReplicGroup *p_ReplicGroup)
         (t_AdOfTypeResult*)FM_MURAM_AllocMem(h_Muram,
                                              FM_PCD_CC_AD_ENTRY_SIZE,
                                              FM_PCD_CC_AD_TABLE_ALIGN);
-
     if (!p_CurrentMember->p_MemberAd)
+    {
+        XX_Free(p_CurrentMember);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("member AD table"));
-
+    }
     IOMemSet32((uint8_t*)p_CurrentMember->p_MemberAd, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
     /* Add the new member to the available members list */
@@ -591,7 +592,6 @@ static void DeleteGroup(t_FmPcdFrmReplicGroup *p_ReplicGroup)
 
         /* free the replicator group */
         XX_Free(p_ReplicGroup);
-        p_ReplicGroup = NULL;
     }
 }
 
@@ -833,13 +833,8 @@ t_Error FM_PCD_FrmReplicAddMember(t_Handle                  h_ReplicGroup,
 
     /* group lock */
     err = FrmReplicGroupTryLock(p_ReplicGroup);
-    if (err)
-    {
-        if (GET_ERROR_TYPE(err) == E_BUSY)
-            return ERROR_CODE(E_BUSY);
-        else
-            RETURN_ERROR(MAJOR, err, ("try lock in Add member"));
-    }
+    if (GET_ERROR_TYPE(err) == E_BUSY)
+        return ERROR_CODE(E_BUSY);
 
     if (memberIndex > p_ReplicGroup->numOfEntries)
     {
@@ -954,13 +949,8 @@ t_Error FM_PCD_FrmReplicRemoveMember(t_Handle   h_ReplicGroup,
 
     /* lock */
     err = FrmReplicGroupTryLock(p_ReplicGroup);
-    if (err)
-    {
-        if (GET_ERROR_TYPE(err) == E_BUSY)
-            return ERROR_CODE(E_BUSY);
-        else
-            RETURN_ERROR(MAJOR, err, ("try lock in Remove member"));
-    }
+    if (GET_ERROR_TYPE(err) == E_BUSY)
+        return ERROR_CODE(E_BUSY);
 
     if (memberIndex >= p_ReplicGroup->numOfEntries)
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("member index to remove"));
@@ -990,3 +980,5 @@ t_Error FM_PCD_FrmReplicRemoveMember(t_Handle   h_ReplicGroup,
 }
 
 /*********************** End of API routines ************************/
+
+
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_replic.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_replic.h
index 7e4224b..0e8e8bc 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_replic.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_replic.h
@@ -68,13 +68,13 @@
 } e_SourceTdOption;
 */
 
-typedef _Packed struct
+typedef struct
 {
     volatile uint32_t type;
     volatile uint32_t frGroupPointer;
     volatile uint32_t operationCode;
     volatile uint32_t reserved;
-} _PackedType t_FrmReplicGroupSourceAd;
+} t_FrmReplicGroupSourceAd;
 
 typedef struct t_FmPcdFrmReplicMember
 {
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fman_kg.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fman_kg.c
index 14a680e..49b86e8 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fman_kg.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fman_kg.c
@@ -97,7 +97,7 @@ static uint8_t get_gen_ht_code(enum fman_kg_gen_extract_src src,
 	case E_FMAN_KG_GEN_EXTRACT_ETYPE:
 		code = no_validation ? 0x77 : 0x7;
 		break;
-
+ 
 	case E_FMAN_KG_GEN_EXTRACT_SNAP:
 		code = no_validation ? 0x74 : 0x4;
 		break;
@@ -324,7 +324,7 @@ void fman_kg_init(struct fman_kg_regs *regs,
 
 	tmp = 0;
 	if (exceptions & FM_EX_KG_DOUBLE_ECC)
-		tmp |= FM_EX_KG_DOUBLE_ECC;
+        	tmp |= FM_EX_KG_DOUBLE_ECC;
 
 	if (exceptions & FM_EX_KG_KEYSIZE_OVERFLOW)
 		tmp |= FM_EX_KG_KEYSIZE_OVERFLOW;
@@ -405,7 +405,7 @@ void fman_kg_get_exception(struct fman_kg_regs *regs,
 	*events = ioread32be(&regs->fmkg_eer);
 	mask = ioread32be(&regs->fmkg_eeer);
 	*events &= mask;
-
+ 
 	*scheme_ids = 0;
 
 	if (*events & FM_EX_KG_KEYSIZE_OVERFLOW) {
@@ -644,7 +644,7 @@ int fman_kg_build_scheme(struct fman_kg_scheme_params *params,
 
 	/* Policer Profile register */
 	if (params->policer_params.bypass_pp_gen) {
-		tmp_reg = FMAN_KG_SCH_PP_NO_GEN;
+		tmp_reg = 0;
 	} else {
 		/* Lower 8 bits of 24-bits extracted from hash result
 		 * are used for policer profile generation.
@@ -746,9 +746,9 @@ int fman_kg_get_scheme_counter(struct fman_kg_regs *regs,
 	int                         err;
 
 	kgse_regs = (struct fman_kg_scheme_regs *)&(regs->fmkg_indirect[0]);
-
+ 
 	tmp_reg = build_ar_scheme(scheme_id, hwport_id, TRUE, FALSE);
-	err = fman_kg_write_ar_wait(regs, tmp_reg);
+    	err = fman_kg_write_ar_wait(regs, tmp_reg);
 
 	if (err != 0)
 		return err;
@@ -774,7 +774,7 @@ int fman_kg_set_scheme_counter(struct fman_kg_regs *regs,
 	err = fman_kg_write_ar_wait(regs, tmp_reg);
 	if (err != 0)
 		return err;
-
+ 
 	/* Keygen indirect access memory contains all scheme_id registers
 	 * by now. Change only counter value. */
 	iowrite32be(counter, &kgse_regs->kgse_spc);
@@ -862,7 +862,7 @@ int fman_kg_build_bind_cls_plans(uint8_t grp_base,
 					uint32_t *bind_cls_plans)
 {
 	/* Check grp_base and grp_mask are 5-bits values */
-	if ((grp_base & ~0x0000001F) || (grp_mask & !0x0000001F))
+	if ((grp_base & ~0x0000001F) || (grp_mask & ~0x0000001F))
 		return -EINVAL;
 
 	*bind_cls_plans = (uint32_t) ((grp_mask << FMAN_KG_PE_CPP_MASK_SHIFT) | grp_base);
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/Makefile b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/Makefile
index c94c54c..4eb302d 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/Makefile
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/Makefile
@@ -1,14 +1,14 @@
 #
 # Makefile for the Freescale Ethernet controllers
 #
-EXTRA_CFLAGS           += -DVERSION=\"\"
+ccflags-y           += -DVERSION=\"\"
 #
 #Include netcomm SW specific definitions
 include $(srctree)/drivers/net/ethernet/freescale/fman/ncsw_config.mk
 
 NCSW_FM_INC = $(srctree)/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc
 
-EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+ccflags-y += -I$(NCSW_FM_INC)
 
 obj-y		+= fsl-ncsw-Pcd.o
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
index cf26089..379406e 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
@@ -35,7 +35,7 @@
  @File          fm_port.c
 
  @Description   FM driver routines implementation.
-*//***************************************************************************/
+ *//***************************************************************************/
 #include "error_ext.h"
 #include "std_ext.h"
 #include "string_ext.h"
@@ -56,15 +56,19 @@ static t_Error FmPortConfigAutoResForDeepSleepSupport1(t_FmPort *p_FmPort);
 static t_Error CheckInitParameters(t_FmPort *p_FmPort)
 {
     t_FmPortDriverParam *p_Params = p_FmPort->p_FmPortDriverParam;
-    struct fman_port_cfg    *p_DfltConfig = &p_Params->dfltCfg;
-    t_Error             ans = E_OK;
-    uint32_t            unusedMask;
+    struct fman_port_cfg *p_DfltConfig = &p_Params->dfltCfg;
+    t_Error ans = E_OK;
+    uint32_t unusedMask;
 
     if (p_FmPort->imEn)
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
-            if (p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth > 2)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoDeqPipelineDepth for IM 10G can't be larger than 2"));
+            if (p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth
+                    > 2)
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_VALUE,
+                        ("fifoDeqPipelineDepth for IM 10G can't be larger than 2"));
 
         if ((ans = FmPortImCheckInitParameters(p_FmPort)) != E_OK)
             return ERROR_CODE(ans);
@@ -74,29 +78,39 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         /****************************************/
         /*   Rx only                            */
         /****************************************/
-        if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-            (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_RX)
+                || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
         {
             /* external buffer pools */
             if (!p_Params->extBufPools.numOfPoolsUsed)
-                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("extBufPools.numOfPoolsUsed=0. At least one buffer pool must be defined"));
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_VALUE,
+                        ("extBufPools.numOfPoolsUsed=0. At least one buffer pool must be defined"));
 
             if (FmSpCheckBufPoolsParams(&p_Params->extBufPools,
                                         p_Params->p_BackupBmPools,
-                                        &p_Params->bufPoolDepletion)!= E_OK)
-                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
+                                        &p_Params->bufPoolDepletion) != E_OK)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
 
             /* Check that part of IC that needs copying is small enough to enter start margin */
-            if (p_Params->intContext.size && (p_Params->intContext.size + p_Params->intContext.extBufOffset > p_Params->bufMargins.startMargins))
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.size is larger than start margins"));
+            if (p_Params->intContext.size
+                    && (p_Params->intContext.size
+                            + p_Params->intContext.extBufOffset
+                            > p_Params->bufMargins.startMargins))
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                             ("intContext.size is larger than start margins"));
 
-            if ((p_Params->liodnOffset != DPAA_LIODN_DONT_OVERRIDE) &&
-                (p_Params->liodnOffset & ~FM_LIODN_OFFSET_MASK))
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("liodnOffset is larger than %d", FM_LIODN_OFFSET_MASK+1));
+            if ((p_Params->liodnOffset != (uint16_t)DPAA_LIODN_DONT_OVERRIDE)
+                    && (p_Params->liodnOffset & ~FM_LIODN_OFFSET_MASK))
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_VALUE,
+                        ("liodnOffset is larger than %d", FM_LIODN_OFFSET_MASK+1));
 
 #ifdef FM_NO_BACKUP_POOLS
-    if ((p_FmPort->fmRevInfo.majorRev != 4) && (p_FmPort->fmRevInfo.majorRev < 6))
-        if (p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
+            if ((p_FmPort->fmRevInfo.majorRev != 4) && (p_FmPort->fmRevInfo.majorRev < 6))
+            if (p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("BackupBmPools"));
 #endif /* FM_NO_BACKUP_POOLS */
         }
@@ -107,37 +121,50 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         else
         {
             if (p_Params->deqSubPortal >= FM_MAX_NUM_OF_SUB_PORTALS)
-                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" deqSubPortal has to be in the range of 0 - %d", FM_MAX_NUM_OF_SUB_PORTALS));
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_VALUE,
+                        (" deqSubPortal has to be in the range of 0 - %d", FM_MAX_NUM_OF_SUB_PORTALS));
 
             /* to protect HW internal-context from overwrite */
-            if ((p_Params->intContext.size) &&
-                (p_Params->intContext.intContextOffset < MIN_TX_INT_OFFSET))
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("non-Rx intContext.intContextOffset can't be smaller than %d", MIN_TX_INT_OFFSET));
-
-            if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) ||
-                (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
+            if ((p_Params->intContext.size)
+                    && (p_Params->intContext.intContextOffset
+                            < MIN_TX_INT_OFFSET))
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_VALUE,
+                        ("non-Rx intContext.intContextOffset can't be smaller than %d", MIN_TX_INT_OFFSET));
+
+            if ((p_FmPort->portType == e_FM_PORT_TYPE_TX)
+                    || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
                     /* in O/H DEFAULT_notSupported indicates that it is not supported and should not be checked */
-                    || (p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth != DEFAULT_notSupported))
+                    || (p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth
+                            != DEFAULT_notSupported))
             {
                 /* Check that not larger than 8 */
-                if ((!p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth) ||
-                    ( p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth > MAX_FIFO_PIPELINE_DEPTH))
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoDeqPipelineDepth can't be larger than %d", MAX_FIFO_PIPELINE_DEPTH));
+                if ((!p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth)
+                        || (p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth
+                                > MAX_FIFO_PIPELINE_DEPTH))
+                    RETURN_ERROR(
+                            MAJOR,
+                            E_INVALID_VALUE,
+                            ("fifoDeqPipelineDepth can't be larger than %d", MAX_FIFO_PIPELINE_DEPTH));
             }
         }
 
         /****************************************/
         /*   Rx Or Offline Parsing              */
         /****************************************/
-        if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-            (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
-            (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_RX)
+                || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+                || (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
         {
             if (!p_Params->dfltFqid)
-                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dfltFqid must be between 1 and 2^24-1"));
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                             ("dfltFqid must be between 1 and 2^24-1"));
 #if defined(FM_CAPWAP_SUPPORT) && defined(FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004)
             if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace % 16)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufferPrefixContent.manipExtraSpace has to be devidable by 16"));
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufferPrefixContent.manipExtraSpace has to be devidable by 16"));
 #endif /* defined(FM_CAPWAP_SUPPORT) && ... */
         }
 
@@ -146,50 +173,73 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         /****************************************/
         /* common BMI registers values */
         /* Check that Queue Id is not larger than 2^24, and is not 0 */
-        if ((p_Params->errFqid & ~0x00FFFFFF) || !p_Params->errFqid){
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("errFqid must be between 1 and 2^24-1"));
-
-	}
+        if ((p_Params->errFqid & ~0x00FFFFFF) || !p_Params->errFqid)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                         ("errFqid must be between 1 and 2^24-1"));
         if (p_Params->dfltFqid & ~0x00FFFFFF)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dfltFqid must be between 1 and 2^24-1"));
-
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                         ("dfltFqid must be between 1 and 2^24-1"));
     }
 
     /****************************************/
     /*   Rx only                            */
     /****************************************/
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
         if (p_DfltConfig->rx_pri_elevation % BMI_FIFO_UNITS)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoPriElevationLevel has to be divisible by %d", BMI_FIFO_UNITS));
-        if ((p_DfltConfig->rx_pri_elevation < BMI_FIFO_UNITS) || (p_DfltConfig->rx_pri_elevation > MAX_PORT_FIFO_SIZE))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoPriElevationLevel has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("rxFifoPriElevationLevel has to be divisible by %d", BMI_FIFO_UNITS));
+        if ((p_DfltConfig->rx_pri_elevation < BMI_FIFO_UNITS)
+                || (p_DfltConfig->rx_pri_elevation > MAX_PORT_FIFO_SIZE))
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("rxFifoPriElevationLevel has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
         if (p_DfltConfig->rx_fifo_thr % BMI_FIFO_UNITS)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoThreshold has to be divisible by %d", BMI_FIFO_UNITS));
-        if ((p_DfltConfig->rx_fifo_thr < BMI_FIFO_UNITS) ||(p_DfltConfig->rx_fifo_thr > MAX_PORT_FIFO_SIZE))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoThreshold has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("rxFifoThreshold has to be divisible by %d", BMI_FIFO_UNITS));
+        if ((p_DfltConfig->rx_fifo_thr < BMI_FIFO_UNITS)
+                || (p_DfltConfig->rx_fifo_thr > MAX_PORT_FIFO_SIZE))
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("rxFifoThreshold has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
 
         /* Check that not larger than 16 */
         if (p_DfltConfig->rx_cut_end_bytes > FRAME_END_DATA_SIZE)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
 
-        if (FmSpCheckBufMargins(&p_Params->bufMargins)!= E_OK)
+        if (FmSpCheckBufMargins(&p_Params->bufMargins) != E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
 
         /* extra FIFO size (allowed only to Rx ports) */
-        if (p_Params->setSizeOfFifo && (p_FmPort->fifoBufs.extra % BMI_FIFO_UNITS))
-             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.extra has to be divisible by %d", BMI_FIFO_UNITS));
-
-        if (p_Params->bufPoolDepletion.poolsGrpModeEnable &&
-           !p_Params->bufPoolDepletion.numOfPools)
-              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPools can not be 0 when poolsGrpModeEnable=TRUE"));
+        if (p_Params->setSizeOfFifo
+                && (p_FmPort->fifoBufs.extra % BMI_FIFO_UNITS))
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("fifoBufs.extra has to be divisible by %d", BMI_FIFO_UNITS));
+
+        if (p_Params->bufPoolDepletion.poolsGrpModeEnable
+                && !p_Params->bufPoolDepletion.numOfPools)
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("bufPoolDepletion.numOfPools can not be 0 when poolsGrpModeEnable=TRUE"));
 #ifdef FM_CSI_CFED_LIMIT
         if (p_FmPort->fmRevInfo.majorRev == 4)
         {
             /* Check that not larger than 16 */
             if (p_DfltConfig->rx_cut_end_bytes + p_DfltConfig->checksum_bytes_ignore > FRAME_END_DATA_SIZE)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cheksumLastBytesIgnore + cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cheksumLastBytesIgnore + cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
         }
 #endif /* FM_CSI_CFED_LIMIT */
     }
@@ -198,43 +248,64 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
     /*   Non Rx ports                       */
     /****************************************/
     /* extra FIFO size (allowed only to Rx ports) */
-    else if (p_FmPort->fifoBufs.extra)
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" No fifoBufs.extra for non Rx ports"));
+    else
+        if (p_FmPort->fifoBufs.extra)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                         (" No fifoBufs.extra for non Rx ports"));
 
     /****************************************/
     /*   Tx only                            */
     /****************************************/
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
     {
         if (p_DfltConfig->tx_fifo_min_level % BMI_FIFO_UNITS)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoMinFillLevel has to be divisible by %d", BMI_FIFO_UNITS));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("txFifoMinFillLevel has to be divisible by %d", BMI_FIFO_UNITS));
         if (p_DfltConfig->tx_fifo_min_level > (MAX_PORT_FIFO_SIZE - 256))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoMinFillLevel has to be in the range of 0 - %d", (MAX_PORT_FIFO_SIZE - 256)));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("txFifoMinFillLevel has to be in the range of 0 - %d", (MAX_PORT_FIFO_SIZE - 256)));
         if (p_DfltConfig->tx_fifo_low_comf_level % BMI_FIFO_UNITS)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoLowComfLevel has to be divisible by %d", BMI_FIFO_UNITS));
-        if ((p_DfltConfig->tx_fifo_low_comf_level < BMI_FIFO_UNITS) || (p_DfltConfig->tx_fifo_low_comf_level > MAX_PORT_FIFO_SIZE))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoLowComfLevel has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("txFifoLowComfLevel has to be divisible by %d", BMI_FIFO_UNITS));
+        if ((p_DfltConfig->tx_fifo_low_comf_level < BMI_FIFO_UNITS)
+                || (p_DfltConfig->tx_fifo_low_comf_level > MAX_PORT_FIFO_SIZE))
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("txFifoLowComfLevel has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
 
         if (p_FmPort->portType == e_FM_PORT_TYPE_TX)
-            if (p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth > 2)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoDeqPipelineDepth for 1G can't be larger than 2"));
+            if (p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth
+                    > 2)
+                RETURN_ERROR(
+                        MAJOR, E_INVALID_VALUE,
+                        ("fifoDeqPipelineDepth for 1G can't be larger than 2"));
     }
 
     /****************************************/
     /*   Non Tx Ports                       */
     /****************************************/
     /* If discard override was selected , no frames may be discarded. */
-    else if (p_DfltConfig->discard_override && p_Params->errorsToDiscard)
-        RETURN_ERROR(MAJOR, E_CONFLICT,
-                     ("errorsToDiscard is not empty, but frmDiscardOverride selected (all discarded frames to be enqueued to error queue)."));
+    else
+        if (p_DfltConfig->discard_override && p_Params->errorsToDiscard)
+            RETURN_ERROR(
+                    MAJOR,
+                    E_CONFLICT,
+                    ("errorsToDiscard is not empty, but frmDiscardOverride selected (all discarded frames to be enqueued to error queue)."));
 
     /****************************************/
     /*   Rx and Offline parsing             */
     /****************************************/
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             unusedMask = BMI_STATUS_OP_MASK_UNUSED;
@@ -243,39 +314,43 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
 
         /* Check that no common bits with BMI_STATUS_MASK_UNUSED */
         if (p_Params->errorsToDiscard & unusedMask)
-            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("errorsToDiscard contains undefined bits"));
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION,
+                         ("errorsToDiscard contains undefined bits"));
     }
 
     /****************************************/
     /*   Offline Ports                      */
     /****************************************/
 #ifdef FM_OP_OPEN_DMA_MIN_LIMIT
-    if ((p_FmPort->fmRevInfo.majorRev >= 6) &&
-        (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) &&
-        p_Params->setNumOfOpenDmas &&
-        (p_FmPort->openDmas.num < MIN_NUM_OF_OP_DMAS))
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Offline port, openDmas.num can't be smaller than %d", MIN_NUM_OF_OP_DMAS));
+    if ((p_FmPort->fmRevInfo.majorRev >= 6)
+            && (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            && p_Params->setNumOfOpenDmas
+            && (p_FmPort->openDmas.num < MIN_NUM_OF_OP_DMAS))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("For Offline port, openDmas.num can't be smaller than %d", MIN_NUM_OF_OP_DMAS));
 #endif /* FM_OP_OPEN_DMA_MIN_LIMIT */
 
     /****************************************/
     /*   Offline & HC Ports                 */
     /****************************************/
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
     {
 #ifndef FM_FRAME_END_PARAMS_FOR_OP
         if ((p_FmPort->fmRevInfo.majorRev < 6) &&
-            (p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore != DEFAULT_notSupported))
-                 /* this is an indication that user called config for this mode which is not supported in this integration */
-                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("cheksumLastBytesIgnore is available for Rx & Tx ports only"));
+                (p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore != DEFAULT_notSupported))
+        /* this is an indication that user called config for this mode which is not supported in this integration */
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("cheksumLastBytesIgnore is available for Rx & Tx ports only"));
 #endif /* !FM_FRAME_END_PARAMS_FOR_OP */
 
 #ifndef FM_DEQ_PIPELINE_PARAMS_FOR_OP
         if ((!((p_FmPort->fmRevInfo.majorRev == 4) ||
-               (p_FmPort->fmRevInfo.majorRev >= 6))) &&
-            (p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth != DEFAULT_notSupported))
-                /* this is an indication that user called config for this mode which is not supported in this integration */
-                RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("fifoDeqPipelineDepth is available for Tx ports only"));
+                                (p_FmPort->fmRevInfo.majorRev >= 6))) &&
+                (p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth != DEFAULT_notSupported))
+        /* this is an indication that user called config for this mode which is not supported in this integration */
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("fifoDeqPipelineDepth is available for Tx ports only"));
 #endif /* !FM_DEQ_PIPELINE_PARAMS_FOR_OP */
     }
 
@@ -283,32 +358,56 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
     /*   All ports                          */
     /****************************************/
     /* Check that not larger than 16 */
-    if ((p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE) &&
-        ((p_Params->cheksumLastBytesIgnore != DEFAULT_notSupported)))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cheksumLastBytesIgnore can't be larger than %d", FRAME_END_DATA_SIZE));
-
-    if (FmSpCheckIntContextParams(&p_Params->intContext)!= E_OK)
+    if ((p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE)
+            && ((p_Params->cheksumLastBytesIgnore != DEFAULT_notSupported)))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("cheksumLastBytesIgnore can't be larger than %d", FRAME_END_DATA_SIZE));
+
+    if (FmSpCheckIntContextParams(&p_Params->intContext) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
 
     /* common BMI registers values */
-    if (p_Params->setNumOfTasks && ((!p_FmPort->tasks.num) || (p_FmPort->tasks.num > MAX_NUM_OF_TASKS)))
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("tasks.num can't be larger than %d", MAX_NUM_OF_TASKS));
-    if (p_Params->setNumOfTasks && (p_FmPort->tasks.extra > MAX_NUM_OF_EXTRA_TASKS))
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("tasks.extra can't be larger than %d", MAX_NUM_OF_EXTRA_TASKS));
-    if (p_Params->setNumOfOpenDmas && ((!p_FmPort->openDmas.num) || (p_FmPort->openDmas.num > MAX_NUM_OF_DMAS)))
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas.num can't be larger than %d", MAX_NUM_OF_DMAS));
-    if (p_Params->setNumOfOpenDmas && (p_FmPort->openDmas.extra > MAX_NUM_OF_EXTRA_DMAS))
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas.extra can't be larger than %d", MAX_NUM_OF_EXTRA_DMAS));
-    if (p_Params->setSizeOfFifo && (!p_FmPort->fifoBufs.num || (p_FmPort->fifoBufs.num > MAX_PORT_FIFO_SIZE)))
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
+    if (p_Params->setNumOfTasks
+            && ((!p_FmPort->tasks.num)
+                    || (p_FmPort->tasks.num > MAX_NUM_OF_TASKS)))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("tasks.num can't be larger than %d", MAX_NUM_OF_TASKS));
+    if (p_Params->setNumOfTasks
+            && (p_FmPort->tasks.extra > MAX_NUM_OF_EXTRA_TASKS))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("tasks.extra can't be larger than %d", MAX_NUM_OF_EXTRA_TASKS));
+    if (p_Params->setNumOfOpenDmas
+            && ((!p_FmPort->openDmas.num)
+                    || (p_FmPort->openDmas.num > MAX_NUM_OF_DMAS)))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("openDmas.num can't be larger than %d", MAX_NUM_OF_DMAS));
+    if (p_Params->setNumOfOpenDmas
+            && (p_FmPort->openDmas.extra > MAX_NUM_OF_EXTRA_DMAS))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("openDmas.extra can't be larger than %d", MAX_NUM_OF_EXTRA_DMAS));
+    if (p_Params->setSizeOfFifo
+            && (!p_FmPort->fifoBufs.num
+                    || (p_FmPort->fifoBufs.num > MAX_PORT_FIFO_SIZE)))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("fifoBufs.num has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
     if (p_Params->setSizeOfFifo && (p_FmPort->fifoBufs.num % BMI_FIFO_UNITS))
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be divisible by %d", BMI_FIFO_UNITS));
+        RETURN_ERROR(
+                MAJOR, E_INVALID_VALUE,
+                ("fifoBufs.num has to be divisible by %d", BMI_FIFO_UNITS));
 
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
     if (p_FmPort->fmRevInfo.majorRev == 4)
-        if (p_FmPort->p_FmPortDriverParam->deqPrefetchOption != DEFAULT_notSupported)
-            /* this is an indication that user called config for this mode which is not supported in this integration */
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("deqPrefetchOption"));
+    if (p_FmPort->p_FmPortDriverParam->deqPrefetchOption != DEFAULT_notSupported)
+    /* this is an indication that user called config for this mode which is not supported in this integration */
+    RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("deqPrefetchOption"));
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
 
     return E_OK;
@@ -316,102 +415,116 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
 
 static t_Error VerifySizeOfFifo(t_FmPort *p_FmPort)
 {
-    uint32_t    minFifoSizeRequired = 0, optFifoSizeForB2B = 0;
+    uint32_t minFifoSizeRequired = 0, optFifoSizeForB2B = 0;
 
     /*************************/
     /*    TX PORTS           */
     /*************************/
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
     {
-        minFifoSizeRequired = (uint32_t)
-            (ROUND_UP(p_FmPort->maxFrameLength, BMI_FIFO_UNITS) + (3*BMI_FIFO_UNITS));
+        minFifoSizeRequired =
+                (uint32_t)(ROUND_UP(p_FmPort->maxFrameLength, BMI_FIFO_UNITS)
+                        + (3 * BMI_FIFO_UNITS));
         if (!p_FmPort->imEn)
-            minFifoSizeRequired += p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth * BMI_FIFO_UNITS;
+            minFifoSizeRequired +=
+                    p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth
+                            * BMI_FIFO_UNITS;
 
         optFifoSizeForB2B = minFifoSizeRequired;
 
         /* Add some margin for back-to-back capability to improve performance,
-           allows the hardware to pipeline new frame dma while the previous
-           frame not yet transmitted. */
+         allows the hardware to pipeline new frame dma while the previous
+         frame not yet transmitted. */
         if (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
-            optFifoSizeForB2B += 3*BMI_FIFO_UNITS;
+            optFifoSizeForB2B += 3 * BMI_FIFO_UNITS;
         else
-            optFifoSizeForB2B += 2*BMI_FIFO_UNITS;
+            optFifoSizeForB2B += 2 * BMI_FIFO_UNITS;
     }
 
     /*************************/
     /*    RX IM PORTS        */
     /*************************/
-    else if (((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-              (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)) &&
-             p_FmPort->imEn)
-    {
-        optFifoSizeForB2B = minFifoSizeRequired = (uint32_t)
-            (ROUND_UP(p_FmPort->maxFrameLength, BMI_FIFO_UNITS) + (4*BMI_FIFO_UNITS));
-    }
-
-    /*************************/
-    /*    RX non-IM PORTS    */
-    /*************************/
-    else if (((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-              (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)) &&
-             !p_FmPort->imEn)
-    {
-        if (p_FmPort->fmRevInfo.majorRev == 4)
+    else
+        if (((p_FmPort->portType == e_FM_PORT_TYPE_RX)
+                || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+                && p_FmPort->imEn)
         {
-            if (p_FmPort->rxPoolsParams.numOfPools == 1)
-                minFifoSizeRequired = 8*BMI_FIFO_UNITS;
-            else
-                minFifoSizeRequired = (uint32_t)
-                    (ROUND_UP(p_FmPort->rxPoolsParams.secondLargestBufSize, BMI_FIFO_UNITS) + (7*BMI_FIFO_UNITS));
+            optFifoSizeForB2B =
+                    minFifoSizeRequired =
+                            (uint32_t)(ROUND_UP(p_FmPort->maxFrameLength, BMI_FIFO_UNITS)
+                                    + (4 * BMI_FIFO_UNITS));
         }
+
+        /*************************/
+        /*    RX non-IM PORTS    */
+        /*************************/
         else
-        {
+            if (((p_FmPort->portType == e_FM_PORT_TYPE_RX)
+                    || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+                    && !p_FmPort->imEn)
+            {
+                if (p_FmPort->fmRevInfo.majorRev == 4)
+                {
+                    if (p_FmPort->rxPoolsParams.numOfPools == 1)
+                        minFifoSizeRequired = 8 * BMI_FIFO_UNITS;
+                    else
+                        minFifoSizeRequired =
+                                (uint32_t)(ROUND_UP(p_FmPort->rxPoolsParams.secondLargestBufSize, BMI_FIFO_UNITS)
+                                        + (7 * BMI_FIFO_UNITS));
+                }
+                else
+                {
 #if (DPAA_VERSION >= 11)
-            minFifoSizeRequired = (uint32_t)
-                (ROUND_UP(p_FmPort->maxFrameLength, BMI_FIFO_UNITS) + (5*BMI_FIFO_UNITS));
-                /* 4 according to spec + 1 for FOF>0 */
+                    minFifoSizeRequired =
+                            (uint32_t)(ROUND_UP(p_FmPort->maxFrameLength, BMI_FIFO_UNITS)
+                                    + (5 * BMI_FIFO_UNITS));
+                    /* 4 according to spec + 1 for FOF>0 */
 #else
-            minFifoSizeRequired = (uint32_t)
-                (ROUND_UP(MIN(p_FmPort->maxFrameLength, p_FmPort->rxPoolsParams.largestBufSize), BMI_FIFO_UNITS)
-                 + (7*BMI_FIFO_UNITS));
+                    minFifoSizeRequired = (uint32_t)
+                    (ROUND_UP(MIN(p_FmPort->maxFrameLength, p_FmPort->rxPoolsParams.largestBufSize), BMI_FIFO_UNITS)
+                            + (7*BMI_FIFO_UNITS));
 #endif /* (DPAA_VERSION >= 11) */
-        }
+                }
 
-        optFifoSizeForB2B = minFifoSizeRequired;
+                optFifoSizeForB2B = minFifoSizeRequired;
 
-        /* Add some margin for back-to-back capability to improve performance,
-           allows the hardware to pipeline new frame dma while the previous
-           frame not yet transmitted. */
-        if (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
-            optFifoSizeForB2B += 8*BMI_FIFO_UNITS;
-        else
-            optFifoSizeForB2B += 3*BMI_FIFO_UNITS;
-    }
+                /* Add some margin for back-to-back capability to improve performance,
+                 allows the hardware to pipeline new frame dma while the previous
+                 frame not yet transmitted. */
+                if (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+                    optFifoSizeForB2B += 8 * BMI_FIFO_UNITS;
+                else
+                    optFifoSizeForB2B += 3 * BMI_FIFO_UNITS;
+            }
 
-    /* For O/H ports, check fifo size and update if necessary */
-    else if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
-             (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
-    {
+            /* For O/H ports, check fifo size and update if necessary */
+            else
+                if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+                        || (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+                {
 #if (DPAA_VERSION >= 11)
-        optFifoSizeForB2B = minFifoSizeRequired = (uint32_t)
-            (ROUND_UP(p_FmPort->maxFrameLength, BMI_FIFO_UNITS) + ((p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth + 5) * BMI_FIFO_UNITS));
-            /* 4 according to spec + 1 for FOF>0 */
+                    optFifoSizeForB2B =
+                            minFifoSizeRequired =
+                                    (uint32_t)(ROUND_UP(p_FmPort->maxFrameLength, BMI_FIFO_UNITS)
+                                            + ((p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth
+                                                    + 5) * BMI_FIFO_UNITS));
+                    /* 4 according to spec + 1 for FOF>0 */
 #else
-        optFifoSizeForB2B = minFifoSizeRequired = (uint32_t)((p_FmPort->tasks.num + 2) * BMI_FIFO_UNITS);
+                    optFifoSizeForB2B = minFifoSizeRequired = (uint32_t)((p_FmPort->tasks.num + 2) * BMI_FIFO_UNITS);
 #endif /* (DPAA_VERSION >= 11) */
-    }
+                }
 
     ASSERT_COND(minFifoSizeRequired > 0);
     ASSERT_COND(optFifoSizeForB2B >= minFifoSizeRequired);
 
     /* Verify the size  */
     if (p_FmPort->fifoBufs.num < minFifoSizeRequired)
-        DBG(INFO, ("FIFO size should be enlarged to %d bytes", minFifoSizeRequired));
+        DBG(INFO,
+           ("FIFO size is %d and should be enlarged to %d bytes",p_FmPort->fifoBufs.num, minFifoSizeRequired));
     else if (p_FmPort->fifoBufs.num < optFifoSizeForB2B)
-        DBG(INFO, ("For back-to-back frames processing, FIFO size may need to be enlarged to %d bytes", optFifoSizeForB2B));
-
+        DBG(INFO,
+	    ("For back-to-back frames processing, FIFO size is %d and needs to enlarge to %d bytes", p_FmPort->fifoBufs.num, optFifoSizeForB2B));
 
     return E_OK;
 }
@@ -427,31 +540,37 @@ static void FmPortDriverParamFree(t_FmPort *p_FmPort)
 
 static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
 {
-    t_FmExtPools                *p_ExtBufPools = &p_FmPort->p_FmPortDriverParam->extBufPools;
-    t_FmBufPoolDepletion        *p_BufPoolDepletion = &p_FmPort->p_FmPortDriverParam->bufPoolDepletion;
-    uint8_t                     orderedArray[FM_PORT_MAX_NUM_OF_EXT_POOLS];
-    uint16_t                    sizesArray[BM_MAX_NUM_OF_POOLS];
-    int                         i=0, j=0, err;
-    struct fman_port_bpools     bpools;
+    t_FmExtPools *p_ExtBufPools = &p_FmPort->p_FmPortDriverParam->extBufPools;
+    t_FmBufPoolDepletion *p_BufPoolDepletion =
+            &p_FmPort->p_FmPortDriverParam->bufPoolDepletion;
+    uint8_t orderedArray[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+    uint16_t sizesArray[BM_MAX_NUM_OF_POOLS];
+    int i = 0, j = 0, err;
+    struct fman_port_bpools bpools;
 
     memset(&orderedArray, 0, sizeof(uint8_t) * FM_PORT_MAX_NUM_OF_EXT_POOLS);
     memset(&sizesArray, 0, sizeof(uint16_t) * BM_MAX_NUM_OF_POOLS);
     memcpy(&p_FmPort->extBufPools, p_ExtBufPools, sizeof(t_FmExtPools));
 
-    FmSpSetBufPoolsInAscOrderOfBufSizes(p_ExtBufPools, orderedArray, sizesArray);
+    FmSpSetBufPoolsInAscOrderOfBufSizes(p_ExtBufPools, orderedArray,
+                                        sizesArray);
 
     /* Prepare flibs bpools structure */
     memset(&bpools, 0, sizeof(struct fman_port_bpools));
     bpools.count = p_ExtBufPools->numOfPoolsUsed;
     bpools.counters_enable = TRUE;
-    for (i=0; i<p_ExtBufPools->numOfPoolsUsed; i++)
+    for (i = 0; i < p_ExtBufPools->numOfPoolsUsed; i++)
     {
         bpools.bpool[i].bpid = orderedArray[i];
         bpools.bpool[i].size = sizesArray[orderedArray[i]];
-         /* functionality available only for some derivatives (limited by config) */
+        /* functionality available only for some derivatives (limited by config) */
         if (p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
-            for (j=0; j<p_FmPort->p_FmPortDriverParam->p_BackupBmPools->numOfBackupPools; j++)
-                if (orderedArray[i] == p_FmPort->p_FmPortDriverParam->p_BackupBmPools->poolIds[j])
+            for (j = 0;
+                    j
+                            < p_FmPort->p_FmPortDriverParam->p_BackupBmPools->numOfBackupPools;
+                    j++)
+                if (orderedArray[i]
+                        == p_FmPort->p_FmPortDriverParam->p_BackupBmPools->poolIds[j])
                 {
                     bpools.bpool[i].is_backup = TRUE;
                     break;
@@ -460,18 +579,20 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
 
     /* save pools parameters for later use */
     p_FmPort->rxPoolsParams.numOfPools = p_ExtBufPools->numOfPoolsUsed;
-    p_FmPort->rxPoolsParams.largestBufSize = sizesArray[orderedArray[p_ExtBufPools->numOfPoolsUsed-1]];
-    p_FmPort->rxPoolsParams.secondLargestBufSize = sizesArray[orderedArray[p_ExtBufPools->numOfPoolsUsed-2]];
+    p_FmPort->rxPoolsParams.largestBufSize =
+            sizesArray[orderedArray[p_ExtBufPools->numOfPoolsUsed - 1]];
+    p_FmPort->rxPoolsParams.secondLargestBufSize =
+            sizesArray[orderedArray[p_ExtBufPools->numOfPoolsUsed - 2]];
 
     /* FMBM_RMPD reg. - pool depletion */
     if (p_BufPoolDepletion->poolsGrpModeEnable)
     {
         bpools.grp_bp_depleted_num = p_BufPoolDepletion->numOfPools;
-        for (i=0;i<BM_MAX_NUM_OF_POOLS;i++)
+        for (i = 0; i < BM_MAX_NUM_OF_POOLS; i++)
         {
             if (p_BufPoolDepletion->poolsToConsider[i])
             {
-                for (j=0;j<p_ExtBufPools->numOfPoolsUsed;j++)
+                for (j = 0; j < p_ExtBufPools->numOfPoolsUsed; j++)
                 {
                     if (i == orderedArray[j])
                     {
@@ -485,14 +606,14 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
 
     if (p_BufPoolDepletion->singlePoolModeEnable)
     {
-        for (i=0;i<BM_MAX_NUM_OF_POOLS;i++)
+        for (i = 0; i < BM_MAX_NUM_OF_POOLS; i++)
         {
             if (p_BufPoolDepletion->poolsToConsiderForSingleMode[i])
             {
-                for (j=0;j<p_ExtBufPools->numOfPoolsUsed;j++)
+                for (j = 0; j < p_ExtBufPools->numOfPoolsUsed; j++)
                 {
                     if (i == orderedArray[j])
-                     {
+                    {
                         bpools.bpool[j].single_bp_depleted = TRUE;
                         break;
                     }
@@ -503,10 +624,10 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
 
 #if (DPAA_VERSION >= 11)
     /* fill QbbPEV */
-    if (p_BufPoolDepletion->poolsGrpModeEnable ||
-        p_BufPoolDepletion->singlePoolModeEnable)
+    if (p_BufPoolDepletion->poolsGrpModeEnable
+            || p_BufPoolDepletion->singlePoolModeEnable)
     {
-        for (i=0; i<FM_MAX_NUM_OF_PFC_PRIORITIES; i++)
+        for (i = 0; i < FM_MAX_NUM_OF_PFC_PRIORITIES; i++)
         {
             if (p_BufPoolDepletion->pfcPrioritiesEn[i] == TRUE)
             {
@@ -537,13 +658,12 @@ static t_Error ClearPerfCnts(t_FmPort *p_FmPort)
     return E_OK;
 }
 
-
 static t_Error InitLowLevelDriver(t_FmPort *p_FmPort)
 {
-    t_FmPortDriverParam     *p_DriverParams = p_FmPort->p_FmPortDriverParam;
+    t_FmPortDriverParam *p_DriverParams = p_FmPort->p_FmPortDriverParam;
     struct fman_port_params portParams;
-    uint32_t                tmpVal;
-    t_Error                 err;
+    uint32_t tmpVal;
+    t_Error err;
 
     /* Set up flibs parameters and issue init function */
 
@@ -555,17 +675,18 @@ static t_Error InitLowLevelDriver(t_FmPort *p_FmPort)
     portParams.dont_release_buf = p_DriverParams->dontReleaseBuf;
     switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             portParams.err_mask = (RX_ERRS_TO_ENQ & ~portParams.discard_mask);
             if (!p_FmPort->imEn)
             {
                 if (p_DriverParams->forwardReuseIntContext)
-                    p_DriverParams->dfltCfg.rx_fd_bits = (uint8_t)(BMI_PORT_RFNE_FRWD_RPD >> 24);
+                    p_DriverParams->dfltCfg.rx_fd_bits =
+                            (uint8_t)(BMI_PORT_RFNE_FRWD_RPD >> 24);
             }
             break;
 
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             portParams.err_mask = (OP_ERRS_TO_ENQ & ~portParams.discard_mask);
             break;
             break;
@@ -574,54 +695,65 @@ static t_Error InitLowLevelDriver(t_FmPort *p_FmPort)
             break;
     }
 
-    tmpVal = (uint32_t)((p_FmPort->internalBufferOffset % OFFSET_UNITS) ?
-                        (p_FmPort->internalBufferOffset/OFFSET_UNITS + 1):
-                        (p_FmPort->internalBufferOffset/OFFSET_UNITS));
+    tmpVal =
+            (uint32_t)(
+                    (p_FmPort->internalBufferOffset % OFFSET_UNITS) ? (p_FmPort->internalBufferOffset
+                            / OFFSET_UNITS + 1) :
+                            (p_FmPort->internalBufferOffset / OFFSET_UNITS));
     p_FmPort->internalBufferOffset = (uint8_t)(tmpVal * OFFSET_UNITS);
-    p_DriverParams->dfltCfg.int_buf_start_margin = p_FmPort->internalBufferOffset;
-
-    p_DriverParams->dfltCfg.ext_buf_start_margin = p_DriverParams->bufMargins.startMargins;
-    p_DriverParams->dfltCfg.ext_buf_end_margin = p_DriverParams->bufMargins.endMargins;
-
-    p_DriverParams->dfltCfg.ic_ext_offset = p_DriverParams->intContext.extBufOffset;
-    p_DriverParams->dfltCfg.ic_int_offset = p_DriverParams->intContext.intContextOffset;
+    p_DriverParams->dfltCfg.int_buf_start_margin =
+            p_FmPort->internalBufferOffset;
+
+    p_DriverParams->dfltCfg.ext_buf_start_margin =
+            p_DriverParams->bufMargins.startMargins;
+    p_DriverParams->dfltCfg.ext_buf_end_margin =
+            p_DriverParams->bufMargins.endMargins;
+
+    p_DriverParams->dfltCfg.ic_ext_offset =
+            p_DriverParams->intContext.extBufOffset;
+    p_DriverParams->dfltCfg.ic_int_offset =
+            p_DriverParams->intContext.intContextOffset;
     p_DriverParams->dfltCfg.ic_size = p_DriverParams->intContext.size;
 
     p_DriverParams->dfltCfg.stats_counters_enable = TRUE;
     p_DriverParams->dfltCfg.perf_counters_enable = TRUE;
     p_DriverParams->dfltCfg.queue_counters_enable = TRUE;
 
-    p_DriverParams->dfltCfg.perf_cnt_params.task_val    = (uint8_t)p_FmPort->tasks.num;
+    p_DriverParams->dfltCfg.perf_cnt_params.task_val =
+            (uint8_t)p_FmPort->tasks.num;
     if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING ||
-        p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
-        p_DriverParams->dfltCfg.perf_cnt_params.queue_val   = 0;
+    p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)p_DriverParams->dfltCfg.perf_cnt_params.queue_val = 0;
     else
-        p_DriverParams->dfltCfg.perf_cnt_params.queue_val   = 1;
-    p_DriverParams->dfltCfg.perf_cnt_params.dma_val     =(uint8_t) p_FmPort->openDmas.num;
-    p_DriverParams->dfltCfg.perf_cnt_params.fifo_val    = p_FmPort->fifoBufs.num;
-
-    if (0 != fman_port_init(&p_FmPort->port, &p_DriverParams->dfltCfg, &portParams))
+    p_DriverParams->dfltCfg.perf_cnt_params.queue_val = 1;
+    p_DriverParams->dfltCfg.perf_cnt_params.dma_val =
+            (uint8_t)p_FmPort->openDmas.num;
+    p_DriverParams->dfltCfg.perf_cnt_params.fifo_val = p_FmPort->fifoBufs.num;
+
+    if (0
+            != fman_port_init(&p_FmPort->port, &p_DriverParams->dfltCfg,
+                              &portParams))
         RETURN_ERROR(MAJOR, E_NO_DEVICE, ("fman_port_init"));
 
     if (p_FmPort->imEn && ((err = FmPortImInit(p_FmPort)) != E_OK))
         RETURN_ERROR(MAJOR, err, NO_MSG);
     else
     {
-    //  from QMIInit
-        if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-            (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        //  from QMIInit
+        if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+                && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         {
             if (p_DriverParams->deqPrefetchOption == e_FM_PORT_DEQ_NO_PREFETCH)
-                FmSetPortPreFetchConfiguration(p_FmPort->h_Fm, p_FmPort->portId, FALSE);
+                FmSetPortPreFetchConfiguration(p_FmPort->h_Fm, p_FmPort->portId,
+                                               FALSE);
             else
-                FmSetPortPreFetchConfiguration(p_FmPort->h_Fm, p_FmPort->portId, TRUE);
+                FmSetPortPreFetchConfiguration(p_FmPort->h_Fm, p_FmPort->portId,
+                                               TRUE);
         }
     }
     /* The code bellow is a trick so the FM will not release the buffer
-       to BM nor will try to enqueue the frame to QM */
-    if (((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) ||
-         (p_FmPort->portType == e_FM_PORT_TYPE_TX)) &&
-        (!p_FmPort->imEn))
+     to BM nor will try to enqueue the frame to QM */
+    if (((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_TX)) && (!p_FmPort->imEn))
     {
         if (!p_DriverParams->dfltFqid && p_DriverParams->dontReleaseBuf)
         {
@@ -630,35 +762,35 @@ static t_Error InitLowLevelDriver(t_FmPort *p_FmPort)
              * buffers to BM regardless of fmbm_tfene
              */
             WRITE_UINT32(p_FmPort->port.bmi_regs->tx.fmbm_tcfqid, 0xFFFFFF);
-            WRITE_UINT32(p_FmPort->port.bmi_regs->tx.fmbm_tfene, NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->tx.fmbm_tfene,
+                         NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE);
         }
     }
 
     return E_OK;
 }
 
-
 static bool CheckRxBmiCounter(t_FmPort *p_FmPort, e_FmPortCounters counter)
 {
     UNUSED(p_FmPort);
 
     switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_CYCLE):
-        case(e_FM_PORT_COUNTERS_TASK_UTIL):
-        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
-        case(e_FM_PORT_COUNTERS_DMA_UTIL):
-        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
-        case(e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
-        case(e_FM_PORT_COUNTERS_FRAME):
-        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_BAD_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
-        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
-        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
-        case(e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
+        case (e_FM_PORT_COUNTERS_CYCLE):
+        case (e_FM_PORT_COUNTERS_TASK_UTIL):
+        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case (e_FM_PORT_COUNTERS_DMA_UTIL):
+        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case (e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
+        case (e_FM_PORT_COUNTERS_FRAME):
+        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_BAD_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case (e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case (e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
             return TRUE;
         default:
             return FALSE;
@@ -671,16 +803,16 @@ static bool CheckTxBmiCounter(t_FmPort *p_FmPort, e_FmPortCounters counter)
 
     switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_CYCLE):
-        case(e_FM_PORT_COUNTERS_TASK_UTIL):
-        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
-        case(e_FM_PORT_COUNTERS_DMA_UTIL):
-        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
-        case(e_FM_PORT_COUNTERS_FRAME):
-        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
-        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
-        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
-        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case (e_FM_PORT_COUNTERS_CYCLE):
+        case (e_FM_PORT_COUNTERS_TASK_UTIL):
+        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case (e_FM_PORT_COUNTERS_DMA_UTIL):
+        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case (e_FM_PORT_COUNTERS_FRAME):
+        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
             return TRUE;
         default:
             return FALSE;
@@ -691,19 +823,19 @@ static bool CheckOhBmiCounter(t_FmPort *p_FmPort, e_FmPortCounters counter)
 {
     switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_CYCLE):
-        case(e_FM_PORT_COUNTERS_TASK_UTIL):
-        case(e_FM_PORT_COUNTERS_DMA_UTIL):
-        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
-        case(e_FM_PORT_COUNTERS_FRAME):
-        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
-        case(e_FM_PORT_COUNTERS_WRED_DISCARD):
-        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
-        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
-        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case (e_FM_PORT_COUNTERS_CYCLE):
+        case (e_FM_PORT_COUNTERS_TASK_UTIL):
+        case (e_FM_PORT_COUNTERS_DMA_UTIL):
+        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case (e_FM_PORT_COUNTERS_FRAME):
+        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case (e_FM_PORT_COUNTERS_WRED_DISCARD):
+        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
             return TRUE;
-        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
             if (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
                 return FALSE;
             else
@@ -713,29 +845,28 @@ static bool CheckOhBmiCounter(t_FmPort *p_FmPort, e_FmPortCounters counter)
     }
 }
 
-static t_Error BmiPortCheckAndGetCounterType(t_FmPort                      *p_FmPort,
-                                             e_FmPortCounters              counter,
-                                             enum fman_port_stats_counters *p_StatsType,
-                                             enum fman_port_perf_counters  *p_PerfType,
-                                             bool                          *p_IsStats)
+static t_Error BmiPortCheckAndGetCounterType(
+        t_FmPort *p_FmPort, e_FmPortCounters counter,
+        enum fman_port_stats_counters *p_StatsType,
+        enum fman_port_perf_counters *p_PerfType, bool *p_IsStats)
 {
-    volatile uint32_t   *p_Reg;
-    bool                isValid;
+    volatile uint32_t *p_Reg;
+    bool isValid;
 
     switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_Reg = &p_FmPort->port.bmi_regs->rx.fmbm_rstc;
             isValid = CheckRxBmiCounter(p_FmPort, counter);
             break;
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_TX):
             p_Reg = &p_FmPort->port.bmi_regs->tx.fmbm_tstc;
             isValid = CheckTxBmiCounter(p_FmPort, counter);
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_Reg = &p_FmPort->port.bmi_regs->oh.fmbm_ostc;
             isValid = CheckOhBmiCounter(p_FmPort, counter);
             break;
@@ -745,103 +876,94 @@ static t_Error BmiPortCheckAndGetCounterType(t_FmPort                      *p_Fm
 
     if (!isValid)
         RETURN_ERROR(MINOR, E_INVALID_STATE,
-                ("Requested counter is not available for this port type"));
+                     ("Requested counter is not available for this port type"));
 
-     /* check that counters are enabled */
+    /* check that counters are enabled */
     switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_CYCLE):
-        case(e_FM_PORT_COUNTERS_TASK_UTIL):
-        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
-        case(e_FM_PORT_COUNTERS_DMA_UTIL):
-        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
-        case(e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
+        case (e_FM_PORT_COUNTERS_CYCLE):
+        case (e_FM_PORT_COUNTERS_TASK_UTIL):
+        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case (e_FM_PORT_COUNTERS_DMA_UTIL):
+        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case (e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
             /* performance counters - may be read when disabled */
+            *p_IsStats = FALSE;
             break;
-        case(e_FM_PORT_COUNTERS_FRAME):
-        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
-        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
-        case(e_FM_PORT_COUNTERS_RX_BAD_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
-        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
-        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
-        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
-        case(e_FM_PORT_COUNTERS_WRED_DISCARD):
+        case (e_FM_PORT_COUNTERS_FRAME):
+        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case (e_FM_PORT_COUNTERS_RX_BAD_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case (e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case (e_FM_PORT_COUNTERS_WRED_DISCARD):
+            *p_IsStats = TRUE;
             if (!(GET_UINT32(*p_Reg) & BMI_COUNTERS_EN))
-               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+                RETURN_ERROR(MINOR, E_INVALID_STATE,
+                             ("Requested counter was not enabled"));
             break;
-         default:
+        default:
             break;
     }
 
     /* Set counter */
     switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_CYCLE):
+        case (e_FM_PORT_COUNTERS_CYCLE):
             *p_PerfType = E_FMAN_PORT_PERF_CNT_CYCLE;
-            *p_IsStats = FALSE;
             break;
-        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case (e_FM_PORT_COUNTERS_TASK_UTIL):
             *p_PerfType = E_FMAN_PORT_PERF_CNT_TASK_UTIL;
             break;
-        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
             *p_PerfType = E_FMAN_PORT_PERF_CNT_QUEUE_UTIL;
-            *p_IsStats = FALSE;
             break;
-        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case (e_FM_PORT_COUNTERS_DMA_UTIL):
             *p_PerfType = E_FMAN_PORT_PERF_CNT_DMA_UTIL;
-            *p_IsStats = FALSE;
             break;
-        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
             *p_PerfType = E_FMAN_PORT_PERF_CNT_FIFO_UTIL;
-            *p_IsStats = FALSE;
             break;
-        case(e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
+        case (e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
             *p_PerfType = E_FMAN_PORT_PERF_CNT_RX_PAUSE;
-            *p_IsStats = FALSE;
             break;
-        case(e_FM_PORT_COUNTERS_FRAME):
+        case (e_FM_PORT_COUNTERS_FRAME):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_FRAME;
-            *p_IsStats = TRUE;
             break;
-        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_DISCARD;
-            *p_IsStats = TRUE;
             break;
-        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_DEALLOC_BUF;
-            *p_IsStats = TRUE;
             break;
-        case(e_FM_PORT_COUNTERS_RX_BAD_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_BAD_FRAME):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_RX_BAD_FRAME;
-            *p_IsStats = TRUE;
             break;
-        case(e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_RX_LARGE_FRAME;
-            *p_IsStats = TRUE;
             break;
-        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+        case (e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_RX_OUT_OF_BUF;
-            *p_IsStats = TRUE;
             break;
-        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_FILTERED_FRAME;
             break;
-        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_DMA_ERR;
-            *p_IsStats = TRUE;
             break;
-        case(e_FM_PORT_COUNTERS_WRED_DISCARD):
+        case (e_FM_PORT_COUNTERS_WRED_DISCARD):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_WRED_DISCARD;
-            *p_IsStats = TRUE;
-        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+            break;
+        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_LEN_ERR;
-            *p_IsStats = TRUE;
-        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+            break;
+        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_UNSUPPORTED_FORMAT;
-            *p_IsStats = TRUE;
+            break;
         default:
             break;
     }
@@ -849,15 +971,19 @@ static t_Error BmiPortCheckAndGetCounterType(t_FmPort                      *p_Fm
     return E_OK;
 }
 
-
-static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrParams *p_HdrParams, uint32_t *p_SoftSeqAttachReg)
+static t_Error AdditionalPrsParams(t_FmPort *p_FmPort,
+                                   t_FmPcdPrsAdditionalHdrParams *p_HdrParams,
+                                   uint32_t *p_SoftSeqAttachReg)
 {
-    uint8_t                     hdrNum, Ipv4HdrNum;
-    u_FmPcdHdrPrsOpts           *p_prsOpts;
-    uint32_t                    tmpReg = *p_SoftSeqAttachReg, tmpPrsOffset;
+    uint8_t hdrNum, Ipv4HdrNum;
+    u_FmPcdHdrPrsOpts *p_prsOpts;
+    uint32_t tmpReg = *p_SoftSeqAttachReg, tmpPrsOffset;
 
-    if (IS_PRIVATE_HEADER(p_HdrParams->hdr) || IS_SPECIAL_HEADER(p_HdrParams->hdr))
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("No additional parameters for private or special headers."));
+    if (IS_PRIVATE_HEADER(p_HdrParams->hdr)
+            || IS_SPECIAL_HEADER(p_HdrParams->hdr))
+        RETURN_ERROR(
+                MAJOR, E_NOT_SUPPORTED,
+                ("No additional parameters for private or special headers."));
 
     if (p_HdrParams->errDisable)
         tmpReg |= PRS_HDR_ERROR_DIS;
@@ -871,14 +997,15 @@ static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrPa
             case (HEADER_TYPE_MPLS):
                 if (p_prsOpts->mplsPrsOptions.labelInterpretationEnable)
                     tmpReg |= PRS_HDR_MPLS_LBL_INTER_EN;
-                GET_PRS_HDR_NUM(hdrNum, p_prsOpts->mplsPrsOptions.nextParse);
+                hdrNum = GetPrsHdrNum(p_prsOpts->mplsPrsOptions.nextParse);
                 if (hdrNum == ILLEGAL_HDR_NUM)
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
-                GET_PRS_HDR_NUM(Ipv4HdrNum, HEADER_TYPE_IPv4);
+                Ipv4HdrNum = GetPrsHdrNum(HEADER_TYPE_IPv4);
                 if (hdrNum < Ipv4HdrNum)
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                        ("Header must be equal or higher than IPv4"));
-                tmpReg |= ((uint32_t)hdrNum * PRS_HDR_ENTRY_SIZE) << PRS_HDR_MPLS_NEXT_HDR_SHIFT;
+                                 ("Header must be equal or higher than IPv4"));
+                tmpReg |= ((uint32_t)hdrNum * PRS_HDR_ENTRY_SIZE)
+                        << PRS_HDR_MPLS_NEXT_HDR_SHIFT;
                 break;
             case (HEADER_TYPE_PPPoE):
                 if (p_prsOpts->pppoePrsOptions.enableMTUCheck)
@@ -890,16 +1017,16 @@ static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrPa
                 break;
             case (HEADER_TYPE_TCP):
                 if (p_prsOpts->tcpPrsOptions.padIgnoreChecksum)
-                   tmpReg |= PRS_HDR_TCP_PAD_REMOVAL;
+                    tmpReg |= PRS_HDR_TCP_PAD_REMOVAL;
                 else
-                   tmpReg &= ~PRS_HDR_TCP_PAD_REMOVAL;
-               break;
+                    tmpReg &= ~PRS_HDR_TCP_PAD_REMOVAL;
+                break;
             case (HEADER_TYPE_UDP):
                 if (p_prsOpts->udpPrsOptions.padIgnoreChecksum)
-                   tmpReg |= PRS_HDR_UDP_PAD_REMOVAL;
+                    tmpReg |= PRS_HDR_UDP_PAD_REMOVAL;
                 else
-                   tmpReg &= ~PRS_HDR_UDP_PAD_REMOVAL;
-                 break;
+                    tmpReg &= ~PRS_HDR_UDP_PAD_REMOVAL;
+                break;
             default:
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid header"));
         }
@@ -908,7 +1035,8 @@ static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrPa
     /* set software parsing (address is divided in 2 since parser uses 2 byte access. */
     if (p_HdrParams->swPrsEnable)
     {
-        tmpPrsOffset = FmPcdGetSwPrsOffset(p_FmPort->h_FmPcd, p_HdrParams->hdr, p_HdrParams->indexPerHdr);
+        tmpPrsOffset = FmPcdGetSwPrsOffset(p_FmPort->h_FmPcd, p_HdrParams->hdr,
+                                           p_HdrParams->indexPerHdr);
         if (tmpPrsOffset == ILLEGAL_BASE)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
         tmpReg |= (PRS_HDR_SW_PRS_EN | tmpPrsOffset);
@@ -918,11 +1046,12 @@ static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrPa
     return E_OK;
 }
 
-static uint32_t GetPortSchemeBindParams(t_Handle h_FmPort, t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind)
+static uint32_t GetPortSchemeBindParams(
+        t_Handle h_FmPort, t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
-    uint32_t                    walking1Mask = 0x80000000, tmp;
-    uint8_t                     idx = 0;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t walking1Mask = 0x80000000, tmp;
+    uint8_t idx = 0;
 
     p_SchemeBind->netEnvId = p_FmPort->netEnvId;
     p_SchemeBind->hardwarePortId = p_FmPort->hardwarePortId;
@@ -949,32 +1078,35 @@ static uint32_t GetPortSchemeBindParams(t_Handle h_FmPort, t_FmPcdKgInterModuleB
 
 static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
 {
-    t_Error                             err = E_OK;
-    uint32_t                            tmpReg;
-    volatile uint32_t                   *p_BmiNia=NULL;
-    volatile uint32_t                   *p_BmiPrsNia=NULL;
-    volatile uint32_t                   *p_BmiPrsStartOffset=NULL;
-    volatile uint32_t                   *p_BmiInitPrsResult=NULL;
-    volatile uint32_t                   *p_BmiCcBase=NULL;
-    uint8_t                             hdrNum, L3HdrNum, greHdrNum;
-    int                                 i;
-    bool                                isEmptyClsPlanGrp;
-    uint32_t                            tmpHxs[FM_PCD_PRS_NUM_OF_HDRS];
-    uint16_t                            absoluteProfileId;
-    uint8_t                             physicalSchemeId;
-    uint32_t                            ccTreePhysOffset;
-    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+    t_Error err = E_OK;
+    uint32_t tmpReg;
+    volatile uint32_t *p_BmiNia = NULL;
+    volatile uint32_t *p_BmiPrsNia = NULL;
+    volatile uint32_t *p_BmiPrsStartOffset = NULL;
+    volatile uint32_t *p_BmiInitPrsResult = NULL;
+    volatile uint32_t *p_BmiCcBase = NULL;
+    uint16_t hdrNum, L3HdrNum, greHdrNum;
+    int i;
+    bool isEmptyClsPlanGrp;
+    uint32_t tmpHxs[FM_PCD_PRS_NUM_OF_HDRS];
+    uint16_t absoluteProfileId;
+    uint8_t physicalSchemeId;
+    uint32_t ccTreePhysOffset;
+    t_FmPcdKgInterModuleBindPortToSchemes schemeBind;
+    uint32_t initialSwPrs = 0;
 
     ASSERT_COND(p_FmPort);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if (p_FmPort->imEn)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for non-independant mode ports only"));
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx and offline parsing ports only"));
 
     p_FmPort->netEnvId = FmPcdGetNetEnvId(p_PcdParams->h_NetEnv);
 
@@ -984,7 +1116,10 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
     switch (p_PcdParams->pcdSupport)
     {
         case (e_FM_PORT_PCD_SUPPORT_NONE):
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No PCD configuration required if e_FM_PORT_PCD_SUPPORT_NONE selected"));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_STATE,
+                    ("No PCD configuration required if e_FM_PORT_PCD_SUPPORT_NONE selected"));
         case (e_FM_PORT_PCD_SUPPORT_PRS_ONLY):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             break;
@@ -1024,15 +1159,15 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
             p_FmPort->pcdEngines |= FM_PCD_KG;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
             break;
-#ifdef FM_CAPWAP_SUPPORT
         case (e_FM_PORT_PCD_SUPPORT_CC_ONLY):
             p_FmPort->pcdEngines |= FM_PCD_CC;
             break;
-        case (e_FM_PORT_PCD_SUPPORT_CC_AND_KG):
+#ifdef FM_CAPWAP_SUPPORT
+            case (e_FM_PORT_PCD_SUPPORT_CC_AND_KG):
             p_FmPort->pcdEngines |= FM_PCD_CC;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             break;
-        case (e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR):
+            case (e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR):
             p_FmPort->pcdEngines |= FM_PCD_CC;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
@@ -1043,15 +1178,24 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid pcdSupport"));
     }
 
-    if ((p_FmPort->pcdEngines & FM_PCD_PRS) &&
-        (p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams > FM_PCD_PRS_NUM_OF_HDRS))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Port parser numOfHdrsWithAdditionalParams may not exceed %d", FM_PCD_PRS_NUM_OF_HDRS));
+    if ((p_FmPort->pcdEngines & FM_PCD_PRS)
+            && (p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams
+                    > FM_PCD_PRS_NUM_OF_HDRS))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("Port parser numOfHdrsWithAdditionalParams may not exceed %d", FM_PCD_PRS_NUM_OF_HDRS));
 
     /* check that parameters exist for each and only each defined engine */
-    if ((!!(p_FmPort->pcdEngines & FM_PCD_PRS) != !!p_PcdParams->p_PrsParams) ||
-        (!!(p_FmPort->pcdEngines & FM_PCD_KG) != !!p_PcdParams->p_KgParams) ||
-        (!!(p_FmPort->pcdEngines & FM_PCD_CC) != !!p_PcdParams->p_CcParams))
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PCD initialization structure is not consistent with pcdSupport"));
+    if ((!!(p_FmPort->pcdEngines & FM_PCD_PRS) != !!p_PcdParams->p_PrsParams)
+            || (!!(p_FmPort->pcdEngines & FM_PCD_KG)
+                    != !!p_PcdParams->p_KgParams)
+            || (!!(p_FmPort->pcdEngines & FM_PCD_CC)
+                    != !!p_PcdParams->p_CcParams))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_STATE,
+                ("PCD initialization structure is not consistent with pcdSupport"));
 
     /* get PCD registers pointers */
     switch (p_FmPort->portType)
@@ -1064,7 +1208,7 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
             p_BmiInitPrsResult = &p_FmPort->port.bmi_regs->rx.fmbm_rprai[0];
             p_BmiCcBase = &p_FmPort->port.bmi_regs->rx.fmbm_rccb;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->port.bmi_regs->oh.fmbm_ofne;
             p_BmiPrsNia = &p_FmPort->port.bmi_regs->oh.fmbm_ofpne;
             p_BmiPrsStartOffset = &p_FmPort->port.bmi_regs->oh.fmbm_opso;
@@ -1078,11 +1222,9 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
     /* set PCD port parameter */
     if (p_FmPort->pcdEngines & FM_PCD_CC)
     {
-        err = FmPcdCcBindTree(p_FmPort->h_FmPcd,
-                              p_PcdParams,
+        err = FmPcdCcBindTree(p_FmPort->h_FmPcd, p_PcdParams,
                               p_PcdParams->p_CcParams->h_CcTree,
-                              &ccTreePhysOffset,
-                              p_FmPort);
+                              &ccTreePhysOffset, p_FmPort);
         if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -1093,7 +1235,10 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
     if (p_FmPort->pcdEngines & FM_PCD_KG)
     {
         if (p_PcdParams->p_KgParams->numOfSchemes == 0)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For ports using Keygen, at least one scheme must be bound. "));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("For ports using Keygen, at least one scheme must be bound. "));
 
         err = FmPcdKgSetOrBindToClsPlanGrp(p_FmPort->h_FmPcd,
                                            p_FmPort->hardwarePortId,
@@ -1101,10 +1246,11 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
                                            p_FmPort->optArray,
                                            &p_FmPort->clsPlanGrpId,
                                            &isEmptyClsPlanGrp);
-         if (err)
-             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("FmPcdKgSetOrBindToClsPlanGrp failed. "));
+        if (err)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                         ("FmPcdKgSetOrBindToClsPlanGrp failed. "));
 
-         p_FmPort->useClsPlan = !isEmptyClsPlanGrp;
+        p_FmPort->useClsPlan = !isEmptyClsPlanGrp;
 
         schemeBind.netEnvId = p_FmPort->netEnvId;
         schemeBind.hardwarePortId = p_FmPort->hardwarePortId;
@@ -1112,18 +1258,22 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         schemeBind.useClsPlan = p_FmPort->useClsPlan;
 
         /* for each scheme */
-        for (i=0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
+        for (i = 0; i < p_PcdParams->p_KgParams->numOfSchemes; i++)
         {
             ASSERT_COND(p_PcdParams->p_KgParams->h_Schemes[i]);
-            physicalSchemeId = FmPcdKgGetSchemeId(p_PcdParams->p_KgParams->h_Schemes[i]);
+            physicalSchemeId = FmPcdKgGetSchemeId(
+                    p_PcdParams->p_KgParams->h_Schemes[i]);
             schemeBind.schemesIds[i] = physicalSchemeId;
             /* build vector */
-            p_FmPort->schemesPerPortVector |= 1 << (31 - (uint32_t)physicalSchemeId);
+            p_FmPort->schemesPerPortVector |= 1
+                    << (31 - (uint32_t)physicalSchemeId);
 #if (DPAA_VERSION >= 11)
             /*because of the state that VSPE is defined per port - all PCD path should be according to this requirement
              if !VSPE - in port, for relevant scheme VSPE can not be set*/
-            if (!p_FmPort->vspe && FmPcdKgGetVspe((p_PcdParams->p_KgParams->h_Schemes[i])))
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("VSPE is not at port level"));
+            if (!p_FmPort->vspe
+                    && FmPcdKgGetVspe((p_PcdParams->p_KgParams->h_Schemes[i])))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                             ("VSPE is not at port level"));
 #endif /* (DPAA_VERSION >= 11) */
         }
 
@@ -1139,55 +1289,74 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
     p_FmPort->savedBmiNia = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
 
     /* If policer is used directly after BMI or PRS */
-    if ((p_FmPort->pcdEngines & FM_PCD_PLCR) &&
-        ((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PLCR_ONLY) ||
-         (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR)))
+    if ((p_FmPort->pcdEngines & FM_PCD_PLCR)
+            && ((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PLCR_ONLY)
+                    || (p_PcdParams->pcdSupport
+                            == e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR)))
     {
         if (!p_PcdParams->p_PlcrParams->h_Profile)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Profile should be initialized"));
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                         ("Profile should be initialized"));
 
-        absoluteProfileId = (uint16_t)FmPcdPlcrProfileGetAbsoluteId(p_PcdParams->p_PlcrParams->h_Profile);
+        absoluteProfileId = (uint16_t)FmPcdPlcrProfileGetAbsoluteId(
+                p_PcdParams->p_PlcrParams->h_Profile);
 
         if (!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Private port profile not valid."));
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                         ("Private port profile not valid."));
 
         tmpReg = (uint32_t)(absoluteProfileId | NIA_PLCR_ABSOLUTE);
 
         if (p_FmPort->pcdEngines & FM_PCD_PRS) /* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
             /* update BMI HPNIA */
             WRITE_UINT32(*p_BmiPrsNia, (uint32_t)(NIA_ENG_PLCR | tmpReg));
-        else /* e_FM_PCD_SUPPORT_PLCR_ONLY */
+        else
+            /* e_FM_PCD_SUPPORT_PLCR_ONLY */
             /* update BMI NIA */
             p_FmPort->savedBmiNia |= (uint32_t)(NIA_ENG_PLCR);
     }
 
-#ifdef FM_CAPWAP_SUPPORT
     /* if CC is used directly after BMI */
-    if ((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_CC_ONLY) ||
-        (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_CC_AND_KG) ||
-        (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR))
+    if ((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_CC_ONLY)
+#ifdef FM_CAPWAP_SUPPORT
+    || (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_CC_AND_KG)
+    || (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR)
+#endif /* FM_CAPWAP_SUPPORT */
+    )
     {
         if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("e_FM_PORT_PCD_SUPPORT_CC_xx available for offline parsing ports only"));
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_OPERATION,
+                    ("e_FM_PORT_PCD_SUPPORT_CC_xx available for offline parsing ports only"));
         p_FmPort->savedBmiNia |= (uint32_t)(NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC);
-         /* check that prs start offset == RIM[FOF] */
+        /* check that prs start offset == RIM[FOF] */
     }
-#endif /* FM_CAPWAP_SUPPORT */
 
     if (p_FmPort->pcdEngines & FM_PCD_PRS)
     {
         ASSERT_COND(p_PcdParams->p_PrsParams);
-        /* if PRS is used it is always first */
-        GET_PRS_HDR_NUM(hdrNum, p_PcdParams->p_PrsParams->firstPrsHdr);
-        if (hdrNum == ILLEGAL_HDR_NUM)
-            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unsupported header."));
+#if (DPAA_VERSION >= 11)
+        if (p_PcdParams->p_PrsParams->firstPrsHdr == HEADER_TYPE_CAPWAP)
+            hdrNum = OFFLOAD_CAPWAP_SW_PATCH_LABEL;
+        else
+        {
+#endif /* (DPAA_VERSION >= 11) */
+            /* if PRS is used it is always first */
+                hdrNum = GetPrsHdrNum(p_PcdParams->p_PrsParams->firstPrsHdr);
+            if (hdrNum == ILLEGAL_HDR_NUM)
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unsupported header."));
+#if (DPAA_VERSION >= 11)
+        }
+#endif /* (DPAA_VERSION >= 11) */
         p_FmPort->savedBmiNia |= (uint32_t)(NIA_ENG_PRS | (uint32_t)(hdrNum));
         /* set after parser NIA */
         tmpReg = 0;
         switch (p_PcdParams->pcdSupport)
         {
             case (e_FM_PORT_PCD_SUPPORT_PRS_ONLY):
-                WRITE_UINT32(*p_BmiPrsNia, GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd));
+                WRITE_UINT32(*p_BmiPrsNia,
+                             GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd));
                 break;
             case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC):
             case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR):
@@ -1196,20 +1365,26 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
             case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
                 if (p_PcdParams->p_KgParams->directScheme)
                 {
-                    physicalSchemeId = FmPcdKgGetSchemeId(p_PcdParams->p_KgParams->h_DirectScheme);
+                    physicalSchemeId = FmPcdKgGetSchemeId(
+                            p_PcdParams->p_KgParams->h_DirectScheme);
                     /* check that this scheme was bound to this port */
-                    for (i=0 ; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
-                        if (p_PcdParams->p_KgParams->h_DirectScheme == p_PcdParams->p_KgParams->h_Schemes[i])
+                    for (i = 0; i < p_PcdParams->p_KgParams->numOfSchemes; i++)
+                        if (p_PcdParams->p_KgParams->h_DirectScheme
+                                == p_PcdParams->p_KgParams->h_Schemes[i])
                             break;
                     if (i == p_PcdParams->p_KgParams->numOfSchemes)
-                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Direct scheme is not one of the port selected schemes."));
+                        RETURN_ERROR(
+                                MAJOR,
+                                E_INVALID_VALUE,
+                                ("Direct scheme is not one of the port selected schemes."));
                     tmpReg |= (uint32_t)(NIA_KG_DIRECT | physicalSchemeId);
                 }
                 WRITE_UINT32(*p_BmiPrsNia, NIA_ENG_KG | tmpReg);
                 break;
             case (e_FM_PORT_PCD_SUPPORT_PRS_AND_CC):
             case (e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR):
-                WRITE_UINT32(*p_BmiPrsNia, (uint32_t)(NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC));
+                WRITE_UINT32(*p_BmiPrsNia,
+                             (uint32_t)(NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC));
                 break;
             case (e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR):
                 break;
@@ -1218,7 +1393,8 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         }
 
         /* set start parsing offset */
-         WRITE_UINT32(*p_BmiPrsStartOffset, p_PcdParams->p_PrsParams->parsingOffset);
+        WRITE_UINT32(*p_BmiPrsStartOffset,
+                     p_PcdParams->p_PrsParams->parsingOffset);
 
         /************************************/
         /* Parser port parameters           */
@@ -1226,98 +1402,128 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         /* stop before configuring */
         WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, PRS_CAC_STOP);
         /* wait for parser to be in idle state */
-        while (GET_UINT32(p_FmPort->p_FmPortPrsRegs->pcac) & PRS_CAC_ACTIVE) ;
+        while (GET_UINT32(p_FmPort->p_FmPortPrsRegs->pcac) & PRS_CAC_ACTIVE)
+            ;
 
         /* set soft seq attachment register */
-        memset(tmpHxs, 0, FM_PCD_PRS_NUM_OF_HDRS*sizeof(uint32_t));
+        memset(tmpHxs, 0, FM_PCD_PRS_NUM_OF_HDRS * sizeof(uint32_t));
 
         /* set protocol options */
-        for (i=0;p_FmPort->optArray[i];i++)
+        for (i = 0; p_FmPort->optArray[i]; i++)
             switch (p_FmPort->optArray[i])
             {
                 case (ETH_BROADCAST):
-                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_ETH)
-                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_ETH_BC_SHIFT;
+                    hdrNum = GetPrsHdrNum(HEADER_TYPE_ETH);
+                    tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_ETH_BC_SHIFT;
                     break;
                 case (ETH_MULTICAST):
-                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_ETH)
-                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_ETH_MC_SHIFT;
+                    hdrNum = GetPrsHdrNum(HEADER_TYPE_ETH);
+                    tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_ETH_MC_SHIFT;
                     break;
                 case (VLAN_STACKED):
-                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_VLAN)
-                    tmpHxs[hdrNum] |= (i+1)<< PRS_HDR_VLAN_STACKED_SHIFT;
+                    hdrNum = GetPrsHdrNum(HEADER_TYPE_VLAN);
+                    tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_VLAN_STACKED_SHIFT;
                     break;
                 case (MPLS_STACKED):
-                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_MPLS)
-                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_MPLS_STACKED_SHIFT;
+                    hdrNum = GetPrsHdrNum(HEADER_TYPE_MPLS);
+                    tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_MPLS_STACKED_SHIFT;
                     break;
                 case (IPV4_BROADCAST_1):
-                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
-                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_1_BC_SHIFT;
+                    hdrNum = GetPrsHdrNum(HEADER_TYPE_IPv4);
+                    tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_IPV4_1_BC_SHIFT;
                     break;
                 case (IPV4_MULTICAST_1):
-                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
-                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_1_MC_SHIFT;
+                    hdrNum = GetPrsHdrNum(HEADER_TYPE_IPv4);
+                    tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_IPV4_1_MC_SHIFT;
                     break;
                 case (IPV4_UNICAST_2):
-                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
-                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_2_UC_SHIFT;
+					hdrNum = GetPrsHdrNum(HEADER_TYPE_IPv4);
+                    tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_IPV4_2_UC_SHIFT;
                     break;
                 case (IPV4_MULTICAST_BROADCAST_2):
-                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
-                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_2_MC_BC_SHIFT;
+					hdrNum = GetPrsHdrNum(HEADER_TYPE_IPv4);
+                    tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_IPV4_2_MC_BC_SHIFT;
                     break;
                 case (IPV6_MULTICAST_1):
-                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
-                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_1_MC_SHIFT;
+                    hdrNum = GetPrsHdrNum(HEADER_TYPE_IPv6);
+                    tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_IPV6_1_MC_SHIFT;
                     break;
                 case (IPV6_UNICAST_2):
-                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
-                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_2_UC_SHIFT;
+                    hdrNum = GetPrsHdrNum(HEADER_TYPE_IPv6);
+                    tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_IPV6_2_UC_SHIFT;
                     break;
                 case (IPV6_MULTICAST_2):
-                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
-                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_2_MC_SHIFT;
+                    hdrNum = GetPrsHdrNum(HEADER_TYPE_IPv6);
+                    tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_IPV6_2_MC_SHIFT;
                     break;
             }
 
-        if (FmPcdNetEnvIsHdrExist(p_FmPort->h_FmPcd,
-                                  p_FmPort->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP))
+        if (FmPcdNetEnvIsHdrExist(p_FmPort->h_FmPcd, p_FmPort->netEnvId,
+                                  HEADER_TYPE_UDP_ENCAP_ESP))
         {
-            p_PcdParams->p_PrsParams->additionalParams
-                [p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams].hdr = HEADER_TYPE_UDP;
-            p_PcdParams->p_PrsParams->additionalParams
-                [p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams].swPrsEnable = TRUE;
+            if (p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams == FM_PCD_PRS_NUM_OF_HDRS)
+                RETURN_ERROR(
+                         MINOR, E_INVALID_VALUE,
+                         ("If HEADER_TYPE_UDP_ENCAP_ESP is used, numOfHdrsWithAdditionalParams may be up to FM_PCD_PRS_NUM_OF_HDRS - 1"));
+
+            p_PcdParams->p_PrsParams->additionalParams[p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams].hdr =
+                    HEADER_TYPE_UDP;
+            p_PcdParams->p_PrsParams->additionalParams[p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams].swPrsEnable =
+                    TRUE;
             p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams++;
         }
 
         /* set MPLS default next header - HW reset workaround  */
-        GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_MPLS)
+        hdrNum = GetPrsHdrNum(HEADER_TYPE_MPLS);
         tmpHxs[hdrNum] |= PRS_HDR_MPLS_LBL_INTER_EN;
-        GET_PRS_HDR_NUM(L3HdrNum, HEADER_TYPE_USER_DEFINED_L3);
+        L3HdrNum = GetPrsHdrNum(HEADER_TYPE_USER_DEFINED_L3);
         tmpHxs[hdrNum] |= (uint32_t)L3HdrNum << PRS_HDR_MPLS_NEXT_HDR_SHIFT;
 
         /* for GRE, disable errors */
-        GET_PRS_HDR_NUM(greHdrNum, HEADER_TYPE_GRE);
+        greHdrNum = GetPrsHdrNum(HEADER_TYPE_GRE);
         tmpHxs[greHdrNum] |= PRS_HDR_ERROR_DIS;
 
         /* For UDP remove PAD from L4 checksum calculation */
-        GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_UDP);
+        hdrNum = GetPrsHdrNum(HEADER_TYPE_UDP);
         tmpHxs[hdrNum] |= PRS_HDR_UDP_PAD_REMOVAL;
         /* For TCP remove PAD from L4 checksum calculation */
-        GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_TCP);
+        hdrNum = GetPrsHdrNum(HEADER_TYPE_TCP);
         tmpHxs[hdrNum] |= PRS_HDR_TCP_PAD_REMOVAL;
 
         /* config additional params for specific headers */
-        for (i=0; i<p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams; i++)
+        for (i = 0; i < p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams;
+                i++)
         {
-            GET_PRS_HDR_NUM(hdrNum, p_PcdParams->p_PrsParams->additionalParams[i].hdr);
-            if (hdrNum== ILLEGAL_HDR_NUM)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
-            if (hdrNum==NO_HDR_NUM)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Private headers may not use additional parameters"));
+            /* case for using sw parser as the initial NIA address, before
+               * HW parsing
+               */
+            if ((p_PcdParams->p_PrsParams->additionalParams[i].hdr == HEADER_TYPE_NONE) && 
+                    p_PcdParams->p_PrsParams->additionalParams[i].swPrsEnable)
+            {
+                initialSwPrs = FmPcdGetSwPrsOffset(p_FmPort->h_FmPcd, HEADER_TYPE_NONE,
+                               p_PcdParams->p_PrsParams->additionalParams[i].indexPerHdr);
+                if (initialSwPrs == ILLEGAL_BASE)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
+
+                /* clear parser first HXS */
+                p_FmPort->savedBmiNia &= ~BMI_RFNE_HXS_MASK; /* 0x000000FF */
+                /* rewrite with soft parser start */
+                p_FmPort->savedBmiNia |= initialSwPrs;
+                continue;
+            }
 
-            err = AdditionalPrsParams(p_FmPort, &p_PcdParams->p_PrsParams->additionalParams[i], &tmpHxs[hdrNum]);
+            hdrNum =
+                GetPrsHdrNum(p_PcdParams->p_PrsParams->additionalParams[i].hdr);
+            if (hdrNum == ILLEGAL_HDR_NUM)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
+            if (hdrNum == NO_HDR_NUM)
+                RETURN_ERROR(
+                        MAJOR, E_INVALID_VALUE,
+                        ("Private headers may not use additional parameters"));
+
+            err = AdditionalPrsParams(
+                    p_FmPort, &p_PcdParams->p_PrsParams->additionalParams[i],
+                    &tmpHxs[hdrNum]);
             if (err)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
         }
@@ -1325,41 +1531,45 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         /* Check if ip-reassembly port - need to update NIAs */
         if (p_FmPort->h_IpReassemblyManip)
         {
-           /* link to sw parser code for IP Frag - only if no other code is applied. */
-            GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
-            if (!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
-                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IP_FRAG_SW_PATCH_IPv4_LABEL);
-            GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+            /* link to sw parser code for IP Frag - only if no other code is applied. */
+            hdrNum = GetPrsHdrNum(HEADER_TYPE_IPv4);
             if (!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
-                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IP_FRAG_SW_PATCH_IPv6_LABEL);
+                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN
+                        | OFFLOAD_SW_PATCH_IPv4_LABEL);
         }
 
-        if (FmPcdIsAdvancedOffloadSupported(p_FmPort->h_FmPcd) &&
-            (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        if ((p_FmPort->h_IpReassemblyManip)
+                || (FmPcdNetEnvIsHdrExist(p_FmPort->h_FmPcd, p_FmPort->netEnvId,
+                                          HEADER_TYPE_UDP_LITE))
+                || (FmPcdIsAdvancedOffloadSupported(p_FmPort->h_FmPcd)
+                        && (p_FmPort->portType
+                                == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)))
         {
-            /* link to sw parser code for IP Frag - only if no other code is applied. */
-            GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+            hdrNum = GetPrsHdrNum(HEADER_TYPE_IPv6);
             if (!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
-                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IP_FRAG_SW_PATCH_IPv6_LABEL);
+                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN
+                        | OFFLOAD_SW_PATCH_IPv6_LABEL);
         }
 
-#ifdef FM_CAPWAP_SUPPORT
-        if (FmPcdNetEnvIsHdrExist(p_FmPort->h_FmPcd,
-                                  p_FmPort->netEnvId, HEADER_TYPE_UDP_LITE))
+#if ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
+        if (FmPcdNetEnvIsHdrExist(p_FmPort->h_FmPcd, p_FmPort->netEnvId,
+                        HEADER_TYPE_UDP_LITE))
         {
-           /* link to sw parser code for udp lite - only if no other code is applied. */
-            GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_USER_DEFINED_L4)
+            /* link to sw parser code for udp lite - only if no other code is applied. */
+            hdrNum = GetPrsHdrNum(HEADER_TYPE_IPv6);
             if (!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
-                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | UDP_LITE_SW_PATCH_LABEL);
+            tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | UDP_LITE_SW_PATCH_LABEL);
         }
-#endif /* FM_CAPWAP_SUPPORT */
-        for (i=0 ; i<FM_PCD_PRS_NUM_OF_HDRS ; i++)
+#endif /* ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT)) */
+        for (i = 0; i < FM_PCD_PRS_NUM_OF_HDRS; i++)
         {
             /* For all header set LCV as taken from netEnv*/
-            WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[i].lcv,
-                         FmPcdGetLcv(p_FmPort->h_FmPcd, p_FmPort->netEnvId, (uint8_t)i));
+            WRITE_UINT32(
+                    p_FmPort->p_FmPortPrsRegs->hdrs[i].lcv,
+                    FmPcdGetLcv(p_FmPort->h_FmPcd, p_FmPort->netEnvId, (uint8_t)i));
             /* set HXS register according to default+Additional params+protocol options */
-            WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[i].softSeqAttach,  tmpHxs[i]);
+            WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[i].softSeqAttach,
+                         tmpHxs[i]);
         }
 
         /* set tpid. */
@@ -1367,37 +1577,51 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         if (p_PcdParams->p_PrsParams->setVlanTpid1)
         {
             tmpReg &= PRS_TPID2_MASK;
-            tmpReg |= (uint32_t)p_PcdParams->p_PrsParams->vlanTpid1 << PRS_PCTPID_SHIFT;
+            tmpReg |= (uint32_t)p_PcdParams->p_PrsParams->vlanTpid1
+                    << PRS_PCTPID_SHIFT;
         }
         if (p_PcdParams->p_PrsParams->setVlanTpid2)
         {
             tmpReg &= PRS_TPID1_MASK;
             tmpReg |= (uint32_t)p_PcdParams->p_PrsParams->vlanTpid2;
-        }
-        WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pctpid, tmpReg);
+        }WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pctpid, tmpReg);
 
         /* enable parser */
         WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, 0);
 
         if (p_PcdParams->p_PrsParams->prsResultPrivateInfo)
-            p_FmPort->privateInfo = p_PcdParams->p_PrsParams->prsResultPrivateInfo;
+            p_FmPort->privateInfo =
+                    p_PcdParams->p_PrsParams->prsResultPrivateInfo;
 
     } /* end parser */
-    else
+    else {
+        if (FmPcdIsAdvancedOffloadSupported(p_FmPort->h_FmPcd)
+            && (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        {
+            hdrNum = GetPrsHdrNum(HEADER_TYPE_IPv6);
+            WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[hdrNum].softSeqAttach,
+                         (PRS_HDR_SW_PRS_EN | OFFLOAD_SW_PATCH_IPv6_LABEL));
+        }
+
+        WRITE_UINT32(*p_BmiPrsStartOffset, 0);
+
         p_FmPort->privateInfo = 0;
+    }
 
-    WRITE_UINT32(*p_BmiPrsStartOffset, GET_UINT32(*p_BmiPrsStartOffset) + p_FmPort->internalBufferOffset);
+    WRITE_UINT32(
+            *p_BmiPrsStartOffset,
+            GET_UINT32(*p_BmiPrsStartOffset) + p_FmPort->internalBufferOffset);
 
     /* set initial parser result - used for all engines */
-    for (i=0;i<FM_PORT_PRS_RESULT_NUM_OF_WORDS;i++)
+    for (i = 0; i < FM_PORT_PRS_RESULT_NUM_OF_WORDS; i++)
     {
         if (!i)
-            WRITE_UINT32(*(p_BmiInitPrsResult),
-                         (uint32_t)(((uint32_t)p_FmPort->privateInfo << BMI_PR_PORTID_SHIFT)
-                                    | BMI_PRS_RESULT_HIGH));
+            WRITE_UINT32(
+                    *(p_BmiInitPrsResult),
+                    (uint32_t)(((uint32_t)p_FmPort->privateInfo << BMI_PR_PORTID_SHIFT) | BMI_PRS_RESULT_HIGH));
         else
         {
-            if (i< FM_PORT_PRS_RESULT_NUM_OF_WORDS/2)
+            if (i < FM_PORT_PRS_RESULT_NUM_OF_WORDS / 2)
                 WRITE_UINT32(*(p_BmiInitPrsResult+i), BMI_PRS_RESULT_HIGH);
             else
                 WRITE_UINT32(*(p_BmiInitPrsResult+i), BMI_PRS_RESULT_LOW);
@@ -1409,20 +1633,22 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
 
 static t_Error DeletePcd(t_FmPort *p_FmPort)
 {
-    t_Error                             err = E_OK;
-    volatile uint32_t                   *p_BmiNia=NULL;
-    volatile uint32_t                   *p_BmiPrsStartOffset = NULL;
+    t_Error err = E_OK;
+    volatile uint32_t *p_BmiNia = NULL;
+    volatile uint32_t *p_BmiPrsStartOffset = NULL;
 
     ASSERT_COND(p_FmPort);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if (p_FmPort->imEn)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for non-independant mode ports only"));
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx and offline parsing ports only"));
 
     if (!p_FmPort->pcdEngines)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("called for non PCD port"));
@@ -1443,35 +1669,40 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
     }
 
-    if ((GET_UINT32(*p_BmiNia) & GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME()) !=
-        GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME())
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("port has to be detached previousely"));
+    if ((GET_UINT32(*p_BmiNia) & GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME())
+            != GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME())
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("port has to be detached previousely"));
+
+    WRITE_UINT32(*p_BmiPrsStartOffset, 0);
 
     /* "cut" PCD out of the port's flow - go to BMI */
     /* WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)); */
 
-    if (p_FmPort->pcdEngines | FM_PCD_PRS)
+    if (p_FmPort->pcdEngines & FM_PCD_PRS)
     {
-        WRITE_UINT32(*p_BmiPrsStartOffset, 0);
-
         /* stop parser */
         WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, PRS_CAC_STOP);
         /* wait for parser to be in idle state */
-        while (GET_UINT32(p_FmPort->p_FmPortPrsRegs->pcac) & PRS_CAC_ACTIVE) ;
+        while (GET_UINT32(p_FmPort->p_FmPortPrsRegs->pcac) & PRS_CAC_ACTIVE)
+            ;
     }
 
     if (p_FmPort->pcdEngines & FM_PCD_KG)
     {
-        t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+        t_FmPcdKgInterModuleBindPortToSchemes schemeBind;
 
         /* unbind all schemes */
-        p_FmPort->schemesPerPortVector = GetPortSchemeBindParams(p_FmPort, &schemeBind);
+        p_FmPort->schemesPerPortVector = GetPortSchemeBindParams(p_FmPort,
+                                                                 &schemeBind);
 
         err = FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
         if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
-        err = FmPcdKgDeleteOrUnbindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, p_FmPort->clsPlanGrpId);
+        err = FmPcdKgDeleteOrUnbindPortToClsPlanGrp(p_FmPort->h_FmPcd,
+                                                    p_FmPort->hardwarePortId,
+                                                    p_FmPort->clsPlanGrpId);
         if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
         p_FmPort->useClsPlan = FALSE;
@@ -1480,7 +1711,7 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
     if (p_FmPort->pcdEngines & FM_PCD_CC)
     {
         /* unbind - we need to get the treeId too */
-        err = FmPcdCcUnbindTree(p_FmPort->h_FmPcd,  p_FmPort->ccTreeId);
+        err = FmPcdCcUnbindTree(p_FmPort->h_FmPcd, p_FmPort->ccTreeId);
         if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
@@ -1492,7 +1723,7 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
 
 static t_Error AttachPCD(t_FmPort *p_FmPort)
 {
-    volatile uint32_t                   *p_BmiNia=NULL;
+    volatile uint32_t *p_BmiNia = NULL;
 
     ASSERT_COND(p_FmPort);
 
@@ -1503,47 +1734,66 @@ static t_Error AttachPCD(t_FmPort *p_FmPort)
         p_BmiNia = &p_FmPort->port.bmi_regs->rx.fmbm_rfne;
 
     /* check that current NIA is BMI to BMI */
-    if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME())
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+    if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK)
+            != GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME())
+        RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
                      ("may be called only for ports in BMI-to-BMI state."));
 
     if (p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
-        if (FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 1, p_FmPort->orFmanCtrl)!= E_OK)
+        if (FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 1,
+                                   p_FmPort->orFmanCtrl) != E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
     if (p_FmPort->requiredAction & UPDATE_NIA_CMNE)
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            WRITE_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ocmne, p_FmPort->savedBmiCmne);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ocmne,
+                         p_FmPort->savedBmiCmne);
         else
-            WRITE_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rcmne, p_FmPort->savedBmiCmne);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rcmne,
+                         p_FmPort->savedBmiCmne);
     }
 
     if (p_FmPort->requiredAction & UPDATE_NIA_PNEN)
-        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, p_FmPort->savedQmiPnen);
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen,
+                     p_FmPort->savedQmiPnen);
 
     if (p_FmPort->requiredAction & UPDATE_NIA_FENE)
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            WRITE_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofene, p_FmPort->savedBmiFene);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofene,
+                         p_FmPort->savedBmiFene);
         else
-            WRITE_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rfene, p_FmPort->savedBmiFene);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rfene,
+                         p_FmPort->savedBmiFene);
     }
 
     if (p_FmPort->requiredAction & UPDATE_NIA_FPNE)
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            WRITE_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofpne, p_FmPort->savedBmiFpne);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofpne,
+                         p_FmPort->savedBmiFpne);
         else
-            WRITE_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rfpne, p_FmPort->savedBmiFpne);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rfpne,
+                         p_FmPort->savedBmiFpne);
+    }
+
+    if (p_FmPort->requiredAction & UPDATE_OFP_DPTE)
+    {
+        ASSERT_COND(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING);
+
+        WRITE_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofp,
+                     p_FmPort->savedBmiOfp);
     }
 
     WRITE_UINT32(*p_BmiNia, p_FmPort->savedBmiNia);
 
     if (p_FmPort->requiredAction & UPDATE_NIA_PNDN)
     {
-        p_FmPort->origNonRxQmiRegsPndn = GET_UINT32(p_FmPort->port.qmi_regs->fmqm_pndn);
-        WRITE_UINT32(p_FmPort->port.qmi_regs->fmqm_pndn, p_FmPort->savedNonRxQmiRegsPndn);
+        p_FmPort->origNonRxQmiRegsPndn =
+                GET_UINT32(p_FmPort->port.qmi_regs->fmqm_pndn);
+        WRITE_UINT32(p_FmPort->port.qmi_regs->fmqm_pndn,
+                     p_FmPort->savedNonRxQmiRegsPndn);
     }
 
     return E_OK;
@@ -1551,21 +1801,23 @@ static t_Error AttachPCD(t_FmPort *p_FmPort)
 
 static t_Error DetachPCD(t_FmPort *p_FmPort)
 {
-    volatile uint32_t                   *p_BmiNia=NULL;
+    volatile uint32_t *p_BmiNia = NULL;
 
     ASSERT_COND(p_FmPort);
 
     /* get PCD registers pointers */
     if (p_FmPort->requiredAction & UPDATE_NIA_PNDN)
-        WRITE_UINT32(p_FmPort->port.qmi_regs->fmqm_pndn, p_FmPort->origNonRxQmiRegsPndn);
+        WRITE_UINT32(p_FmPort->port.qmi_regs->fmqm_pndn,
+                     p_FmPort->origNonRxQmiRegsPndn);
 
     if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         p_BmiNia = &p_FmPort->port.bmi_regs->oh.fmbm_ofne;
     else
         p_BmiNia = &p_FmPort->port.bmi_regs->rx.fmbm_rfne;
 
-    WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) |
-                            GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME());
+    WRITE_UINT32(
+            *p_BmiNia,
+            (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME());
 
     if (FmPcdGetHcHandle(p_FmPort->h_FmPcd))
         FmPcdHcSync(p_FmPort->h_FmPcd);
@@ -1573,16 +1825,20 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
     if (p_FmPort->requiredAction & UPDATE_NIA_FENE)
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            WRITE_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofene,
+                         NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
         else
-            WRITE_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+            WRITE_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rfene,
+                         NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
     }
 
     if (p_FmPort->requiredAction & UPDATE_NIA_PNEN)
-        WRITE_UINT32(p_FmPort->port.qmi_regs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
+        WRITE_UINT32(p_FmPort->port.qmi_regs->fmqm_pnen,
+                     NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
 
     if (p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
-        if (FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 2, p_FmPort->orFmanCtrl)!= E_OK)
+        if (FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 2,
+                                   p_FmPort->orFmanCtrl) != E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
     p_FmPort->requiredAction = 0;
@@ -1590,23 +1846,23 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
     return E_OK;
 }
 
-
 /*****************************************************************************/
 /*              Inter-module API routines                                    */
 /*****************************************************************************/
 
 void FmPortSetMacsecLcv(t_Handle h_FmPort)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
-    volatile uint32_t           *p_BmiCfgReg = NULL;
-    uint32_t                    macsecEn = BMI_PORT_CFG_EN_MACSEC;
-    uint32_t                    lcv, walking1Mask = 0x80000000;
-    uint8_t                     cnt = 0;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t *p_BmiCfgReg = NULL;
+    uint32_t macsecEn = BMI_PORT_CFG_EN_MACSEC;
+    uint32_t lcv, walking1Mask = 0x80000000;
+    uint8_t cnt = 0;
 
     SANITY_CHECK_RETURN(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
     {
         REPORT_ERROR(MAJOR, E_INVALID_OPERATION, ("The routine is relevant for Rx ports only"));
         return;
@@ -1614,7 +1870,9 @@ void FmPortSetMacsecLcv(t_Handle h_FmPort)
 
     p_BmiCfgReg = &p_FmPort->port.bmi_regs->rx.fmbm_rcfg;
     /* get LCV for MACSEC */
-    if ((p_FmPort->h_FmPcd) && ((lcv = FmPcdGetMacsecLcv(p_FmPort->h_FmPcd, p_FmPort->netEnvId))!= 0))
+    if ((p_FmPort->h_FmPcd)
+            && ((lcv = FmPcdGetMacsecLcv(p_FmPort->h_FmPcd, p_FmPort->netEnvId))
+                    != 0))
     {
         while (!(lcv & walking1Mask))
         {
@@ -1623,21 +1881,22 @@ void FmPortSetMacsecLcv(t_Handle h_FmPort)
         }
 
         macsecEn |= (uint32_t)cnt << BMI_PORT_CFG_MS_SEL_SHIFT;
-     }
+    }
 
-     WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) | macsecEn);
+    WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) | macsecEn);
 }
 
 void FmPortSetMacsecCmd(t_Handle h_FmPort, uint8_t dfltSci)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
-    volatile uint32_t           *p_BmiCfgReg = NULL;
-    uint32_t                    tmpReg;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t *p_BmiCfgReg = NULL;
+    uint32_t tmpReg;
 
     SANITY_CHECK_RETURN(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN(p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
     {
         REPORT_ERROR(MAJOR, E_INVALID_OPERATION, ("The routine is relevant for Tx ports only"));
         return;
@@ -1646,7 +1905,8 @@ void FmPortSetMacsecCmd(t_Handle h_FmPort, uint8_t dfltSci)
     p_BmiCfgReg = &p_FmPort->port.bmi_regs->tx.fmbm_tfca;
     tmpReg = GET_UINT32(*p_BmiCfgReg) & ~BMI_CMD_ATTR_MACCMD_MASK;
     tmpReg |= BMI_CMD_ATTR_MACCMD_SECURED;
-    tmpReg |= (((uint32_t)dfltSci << BMI_CMD_ATTR_MACCMD_SC_SHIFT) & BMI_CMD_ATTR_MACCMD_SC_MASK);
+    tmpReg |= (((uint32_t)dfltSci << BMI_CMD_ATTR_MACCMD_SC_SHIFT)
+            & BMI_CMD_ATTR_MACCMD_SC_MASK);
 
     WRITE_UINT32(*p_BmiCfgReg, tmpReg);
 }
@@ -1667,10 +1927,11 @@ uint32_t FmPortGetPcdEngines(t_Handle h_FmPort)
 }
 
 #if (DPAA_VERSION >= 11)
-t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **p_Value)
+t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc,
+                         void **p_Value)
 {
-    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    uint32_t            muramPageOffset;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t muramPageOffset;
 
     ASSERT_COND(p_FmPort);
     ASSERT_COND(p_Value);
@@ -1678,7 +1939,8 @@ t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **
     if (p_FmPort->gprFunc != e_FM_PORT_GPR_EMPTY)
     {
         if (p_FmPort->gprFunc != gprFunc)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("gpr was assigned with different func"));
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                         ("gpr was assigned with different func"));
     }
     else
     {
@@ -1686,25 +1948,30 @@ t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **
         {
             case (e_FM_PORT_GPR_MURAM_PAGE):
                 p_FmPort->p_ParamsPage = FM_MURAM_AllocMem(p_FmPort->h_FmMuram,
-                                                           256,
-                                                           8);
+                                                           256, 8);
                 if (!p_FmPort->p_ParamsPage)
                     RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for page"));
 
                 IOMemSet32(p_FmPort->p_ParamsPage, 0, 256);
-                muramPageOffset = (uint32_t)(XX_VirtToPhys(p_FmPort->p_ParamsPage) -
-                                             p_FmPort->fmMuramPhysBaseAddr);
+                muramPageOffset =
+                        (uint32_t)(XX_VirtToPhys(p_FmPort->p_ParamsPage)
+                                - p_FmPort->fmMuramPhysBaseAddr);
                 switch (p_FmPort->portType)
                 {
                     case (e_FM_PORT_TYPE_RX_10G):
                     case (e_FM_PORT_TYPE_RX):
-                        WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rgpr, muramPageOffset);
+                        WRITE_UINT32(
+                                p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rgpr,
+                                muramPageOffset);
                         break;
                     case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-                        WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ogpr, muramPageOffset);
+                        WRITE_UINT32(
+                                p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ogpr,
+                                muramPageOffset);
                         break;
                     default:
-                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                                     ("Invalid port type"));
                 }
                 break;
             default:
@@ -1726,29 +1993,33 @@ t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **
 }
 #endif /* (DPAA_VERSION >= 11) */
 
-t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcParams)
+t_Error FmPortGetSetCcParams(t_Handle h_FmPort,
+                             t_FmPortGetSetCcParams *p_CcParams)
 {
-    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    int                 tmpInt;
-    volatile uint32_t   *p_BmiPrsStartOffset = NULL;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    int tmpInt;
+    volatile uint32_t *p_BmiPrsStartOffset = NULL;
 
     /* this function called from Cc for pass and receive parameters port params between CC and PORT*/
 
-    if ((p_CcParams->getCcParams.type & OFFSET_OF_PR) &&
-        (p_FmPort->bufferOffsets.prsResultOffset != ILLEGAL_BASE))
+    if ((p_CcParams->getCcParams.type & OFFSET_OF_PR)
+            && (p_FmPort->bufferOffsets.prsResultOffset != ILLEGAL_BASE))
     {
-        p_CcParams->getCcParams.prOffset = (uint8_t)p_FmPort->bufferOffsets.prsResultOffset;
+        p_CcParams->getCcParams.prOffset =
+                (uint8_t)p_FmPort->bufferOffsets.prsResultOffset;
         p_CcParams->getCcParams.type &= ~OFFSET_OF_PR;
     }
     if (p_CcParams->getCcParams.type & HW_PORT_ID)
     {
-        p_CcParams->getCcParams.hardwarePortId = (uint8_t)p_FmPort->hardwarePortId;
+        p_CcParams->getCcParams.hardwarePortId =
+                (uint8_t)p_FmPort->hardwarePortId;
         p_CcParams->getCcParams.type &= ~HW_PORT_ID;
     }
-    if ((p_CcParams->getCcParams.type & OFFSET_OF_DATA) &&
-        (p_FmPort->bufferOffsets.dataOffset != ILLEGAL_BASE))
+    if ((p_CcParams->getCcParams.type & OFFSET_OF_DATA)
+            && (p_FmPort->bufferOffsets.dataOffset != ILLEGAL_BASE))
     {
-        p_CcParams->getCcParams.dataOffset = (uint16_t)p_FmPort->bufferOffsets.dataOffset;
+        p_CcParams->getCcParams.dataOffset =
+                (uint16_t)p_FmPort->bufferOffsets.dataOffset;
         p_CcParams->getCcParams.type &= ~OFFSET_OF_DATA;
     }
     if (p_CcParams->getCcParams.type & NUM_OF_TASKS)
@@ -1758,7 +2029,8 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
     if (p_CcParams->getCcParams.type & NUM_OF_EXTRA_TASKS)
     {
-        p_CcParams->getCcParams.numOfExtraTasks = (uint8_t)p_FmPort->tasks.extra;
+        p_CcParams->getCcParams.numOfExtraTasks =
+                (uint8_t)p_FmPort->tasks.extra;
         p_CcParams->getCcParams.type &= ~NUM_OF_EXTRA_TASKS;
     }
     if (p_CcParams->getCcParams.type & FM_REV)
@@ -1771,103 +2043,117 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             p_CcParams->getCcParams.discardMask =
-                GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm);
+                    GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm);
         else
             p_CcParams->getCcParams.discardMask =
-                GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm);
+                    GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm);
         p_CcParams->getCcParams.type &= ~DISCARD_MASK;
     }
     if (p_CcParams->getCcParams.type & MANIP_EXTRA_SPACE)
     {
-        p_CcParams->getCcParams.internalBufferOffset = p_FmPort->internalBufferOffset;
+        p_CcParams->getCcParams.internalBufferOffset =
+                p_FmPort->internalBufferOffset;
         p_CcParams->getCcParams.type &= ~MANIP_EXTRA_SPACE;
     }
     if (p_CcParams->getCcParams.type & GET_NIA_FPNE)
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            p_CcParams->getCcParams.nia = GET_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofpne);
+            p_CcParams->getCcParams.nia =
+                    GET_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofpne);
         else
-            p_CcParams->getCcParams.nia = GET_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rfpne);
+            p_CcParams->getCcParams.nia =
+                    GET_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rfpne);
         p_CcParams->getCcParams.type &= ~GET_NIA_FPNE;
     }
     if (p_CcParams->getCcParams.type & GET_NIA_PNDN)
     {
         if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
-        p_CcParams->getCcParams.nia = GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn);
+        p_CcParams->getCcParams.nia =
+                GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn);
         p_CcParams->getCcParams.type &= ~GET_NIA_PNDN;
     }
 
-    if ((p_CcParams->setCcParams.type & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY) &&
-        !(p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY))
+    if ((p_CcParams->setCcParams.type & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
+            && !(p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY))
     {
         p_FmPort->requiredAction |= UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY;
         p_FmPort->orFmanCtrl = p_CcParams->setCcParams.orFmanCtrl;
     }
 
-    if ((p_CcParams->setCcParams.type & UPDATE_NIA_PNEN) &&
-        !(p_FmPort->requiredAction & UPDATE_NIA_PNEN))
+    if ((p_CcParams->setCcParams.type & UPDATE_NIA_PNEN)
+            && !(p_FmPort->requiredAction & UPDATE_NIA_PNEN))
     {
         p_FmPort->savedQmiPnen = p_CcParams->setCcParams.nia;
         p_FmPort->requiredAction |= UPDATE_NIA_PNEN;
     }
-    else if (p_CcParams->setCcParams.type & UPDATE_NIA_PNEN)
-    {
-       if (p_FmPort->savedQmiPnen != p_CcParams->setCcParams.nia)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PNEN was defined previously different"));
-    }
+    else
+        if (p_CcParams->setCcParams.type & UPDATE_NIA_PNEN)
+        {
+            if (p_FmPort->savedQmiPnen != p_CcParams->setCcParams.nia)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                             ("PNEN was defined previously different"));
+        }
 
-    if ((p_CcParams->setCcParams.type & UPDATE_NIA_PNDN) &&
-        !(p_FmPort->requiredAction & UPDATE_NIA_PNDN))
+    if ((p_CcParams->setCcParams.type & UPDATE_NIA_PNDN)
+            && !(p_FmPort->requiredAction & UPDATE_NIA_PNDN))
     {
         p_FmPort->savedNonRxQmiRegsPndn = p_CcParams->setCcParams.nia;
         p_FmPort->requiredAction |= UPDATE_NIA_PNDN;
     }
-    else if (p_CcParams->setCcParams.type & UPDATE_NIA_PNDN)
-    {
-        if (p_FmPort->savedNonRxQmiRegsPndn != p_CcParams->setCcParams.nia)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PNDN was defined previously different"));
-    }
+    else
+        if (p_CcParams->setCcParams.type & UPDATE_NIA_PNDN)
+        {
+            if (p_FmPort->savedNonRxQmiRegsPndn != p_CcParams->setCcParams.nia)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                             ("PNDN was defined previously different"));
+        }
 
-    if ((p_CcParams->setCcParams.type & UPDATE_NIA_FENE) &&
-        (p_CcParams->setCcParams.overwrite ||
-         !(p_FmPort->requiredAction & UPDATE_NIA_FENE)))
+    if ((p_CcParams->setCcParams.type & UPDATE_NIA_FENE)
+            && (p_CcParams->setCcParams.overwrite
+                    || !(p_FmPort->requiredAction & UPDATE_NIA_FENE)))
     {
         p_FmPort->savedBmiFene = p_CcParams->setCcParams.nia;
         p_FmPort->requiredAction |= UPDATE_NIA_FENE;
     }
-    else if (p_CcParams->setCcParams.type & UPDATE_NIA_FENE)
-    {
-       if (p_FmPort->savedBmiFene != p_CcParams->setCcParams.nia)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("xFENE was defined previously different"));
-    }
+    else
+        if (p_CcParams->setCcParams.type & UPDATE_NIA_FENE)
+        {
+            if (p_FmPort->savedBmiFene != p_CcParams->setCcParams.nia)
+                RETURN_ERROR( MAJOR, E_INVALID_STATE,
+                             ("xFENE was defined previously different"));
+        }
 
-    if ((p_CcParams->setCcParams.type & UPDATE_NIA_FPNE) &&
-        !(p_FmPort->requiredAction & UPDATE_NIA_FPNE))
+    if ((p_CcParams->setCcParams.type & UPDATE_NIA_FPNE)
+            && !(p_FmPort->requiredAction & UPDATE_NIA_FPNE))
     {
         p_FmPort->savedBmiFpne = p_CcParams->setCcParams.nia;
         p_FmPort->requiredAction |= UPDATE_NIA_FPNE;
     }
-    else if (p_CcParams->setCcParams.type & UPDATE_NIA_FPNE)
-    {
-       if (p_FmPort->savedBmiFpne != p_CcParams->setCcParams.nia)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("xFPNE was defined previously different"));
-    }
+    else
+        if (p_CcParams->setCcParams.type & UPDATE_NIA_FPNE)
+        {
+            if (p_FmPort->savedBmiFpne != p_CcParams->setCcParams.nia)
+                RETURN_ERROR( MAJOR, E_INVALID_STATE,
+                             ("xFPNE was defined previously different"));
+        }
 
-    if ((p_CcParams->setCcParams.type & UPDATE_NIA_CMNE) &&
-        !(p_FmPort->requiredAction & UPDATE_NIA_CMNE))
+    if ((p_CcParams->setCcParams.type & UPDATE_NIA_CMNE)
+            && !(p_FmPort->requiredAction & UPDATE_NIA_CMNE))
     {
         p_FmPort->savedBmiCmne = p_CcParams->setCcParams.nia;
         p_FmPort->requiredAction |= UPDATE_NIA_CMNE;
     }
-    else if (p_CcParams->setCcParams.type & UPDATE_NIA_CMNE)
-    {
-       if (p_FmPort->savedBmiCmne != p_CcParams->setCcParams.nia)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("xCMNE was defined previously different"));
-    }
+    else
+        if (p_CcParams->setCcParams.type & UPDATE_NIA_CMNE)
+        {
+            if (p_FmPort->savedBmiCmne != p_CcParams->setCcParams.nia)
+                RETURN_ERROR( MAJOR, E_INVALID_STATE,
+                             ("xCMNE was defined previously different"));
+        }
 
-    if ((p_CcParams->setCcParams.type & UPDATE_PSO) &&
-        !(p_FmPort->requiredAction & UPDATE_PSO))
+    if ((p_CcParams->setCcParams.type & UPDATE_PSO)
+            && !(p_FmPort->requiredAction & UPDATE_PSO))
     {
         /* get PCD registers pointers */
         switch (p_FmPort->portType)
@@ -1884,36 +2170,53 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
         }
 
         /* set start parsing offset */
-        tmpInt = (int)GET_UINT32(*p_BmiPrsStartOffset)+ p_CcParams->setCcParams.psoSize;
-        if (tmpInt>0)
+        tmpInt = (int)GET_UINT32(*p_BmiPrsStartOffset)
+                + p_CcParams->setCcParams.psoSize;
+        if (tmpInt > 0)
             WRITE_UINT32(*p_BmiPrsStartOffset, (uint32_t)tmpInt);
 
         p_FmPort->requiredAction |= UPDATE_PSO;
         p_FmPort->savedPrsStartOffset = p_CcParams->setCcParams.psoSize;
     }
-    else if (p_CcParams->setCcParams.type & UPDATE_PSO)
+    else
+        if (p_CcParams->setCcParams.type & UPDATE_PSO)
+        {
+            if (p_FmPort->savedPrsStartOffset
+                    != p_CcParams->setCcParams.psoSize)
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_STATE,
+                        ("parser start offset was defoned previousley different"));
+        }
+
+    if ((p_CcParams->setCcParams.type & UPDATE_OFP_DPTE)
+            && !(p_FmPort->requiredAction & UPDATE_OFP_DPTE))
     {
-        if (p_FmPort->savedPrsStartOffset != p_CcParams->setCcParams.psoSize)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("parser start offset was defoned previousley different"));
+        if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+        p_FmPort->savedBmiOfp = GET_UINT32(p_FmPort->port.bmi_regs->oh.fmbm_ofp);
+        p_FmPort->savedBmiOfp &= ~BMI_FIFO_PIPELINE_DEPTH_MASK;
+        p_FmPort->savedBmiOfp |= p_CcParams->setCcParams.ofpDpde
+                << BMI_FIFO_PIPELINE_DEPTH_SHIFT;
+        p_FmPort->requiredAction |= UPDATE_OFP_DPTE;
     }
 
     return E_OK;
 }
 /*********************** End of inter-module routines ************************/
 
-
 /****************************************/
 /*       API Init unit functions        */
 /****************************************/
 
 t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
 {
-    t_FmPort            *p_FmPort;
-    uintptr_t           baseAddr = p_FmPortParams->baseAddr;
-    uint32_t            tmpReg;
+    t_FmPort *p_FmPort;
+    uintptr_t baseAddr = p_FmPortParams->baseAddr;
+    uint32_t tmpReg;
 
     /* Allocate FM structure */
-    p_FmPort = (t_FmPort *) XX_Malloc(sizeof(t_FmPort));
+    p_FmPort = (t_FmPort *)XX_Malloc(sizeof(t_FmPort));
     if (!p_FmPort)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Port driver structure"));
@@ -1922,7 +2225,8 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     memset(p_FmPort, 0, sizeof(t_FmPort));
 
     /* Allocate the FM driver's parameters structure */
-    p_FmPort->p_FmPortDriverParam = (t_FmPortDriverParam *)XX_Malloc(sizeof(t_FmPortDriverParam));
+    p_FmPort->p_FmPortDriverParam = (t_FmPortDriverParam *)XX_Malloc(
+            sizeof(t_FmPortDriverParam));
     if (!p_FmPort->p_FmPortDriverParam)
     {
         XX_Free(p_FmPort);
@@ -1932,46 +2236,53 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     memset(p_FmPort->p_FmPortDriverParam, 0, sizeof(t_FmPortDriverParam));
 
     /* Initialize FM port parameters which will be kept by the driver */
-    p_FmPort->portType      = p_FmPortParams->portType;
-    p_FmPort->portId        = p_FmPortParams->portId;
-    p_FmPort->pcdEngines    = FM_PCD_NONE;
-    p_FmPort->f_Exception   = p_FmPortParams->f_Exception;
-    p_FmPort->h_App         = p_FmPortParams->h_App;
-    p_FmPort->h_Fm          = p_FmPortParams->h_Fm;
+    p_FmPort->portType = p_FmPortParams->portType;
+    p_FmPort->portId = p_FmPortParams->portId;
+    p_FmPort->pcdEngines = FM_PCD_NONE;
+    p_FmPort->f_Exception = p_FmPortParams->f_Exception;
+    p_FmPort->h_App = p_FmPortParams->h_App;
+    p_FmPort->h_Fm = p_FmPortParams->h_Fm;
 
     /* get FM revision */
     FM_GetRevision(p_FmPort->h_Fm, &p_FmPort->fmRevInfo);
 
     /* calculate global portId number */
-    SW_PORT_ID_TO_HW_PORT_ID(p_FmPort->hardwarePortId, p_FmPort->portType, p_FmPortParams->portId);
+    p_FmPort->hardwarePortId = SwPortIdToHwPortId(p_FmPort->portType,
+                                    p_FmPortParams->portId,
+                                    p_FmPort->fmRevInfo.majorRev,
+                                    p_FmPort->fmRevInfo.minorRev);
 
     if (p_FmPort->fmRevInfo.majorRev >= 6)
     {
-        if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND) &&
-            (p_FmPortParams->portId != FM_OH_PORT_ID))
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
+                && (p_FmPortParams->portId != FM_OH_PORT_ID))
             DBG(WARNING,
-                ("Port ID %d is recommended for HC port. Overwriting HW defaults to be suitable for HC.",
-                 FM_OH_PORT_ID));
+                    ("Port ID %d is recommended for HC port. Overwriting HW defaults to be suitable for HC.",
+                            FM_OH_PORT_ID));
 
-        if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) &&
-            (p_FmPortParams->portId == FM_OH_PORT_ID))
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+                && (p_FmPortParams->portId == FM_OH_PORT_ID))
             DBG(WARNING, ("Use non-zero portId for OP port due to insufficient resources on portId 0."));
     }
 
     /* Set up FM port parameters for initialization phase only */
 
     /* First, fill in flibs struct */
-    fman_port_defconfig(&p_FmPort->p_FmPortDriverParam->dfltCfg, (enum fman_port_type)p_FmPort->portType);
+    fman_port_defconfig(&p_FmPort->p_FmPortDriverParam->dfltCfg,
+                        (enum fman_port_type)p_FmPort->portType);
     /* Overwrite some integration specific parameters */
-    p_FmPort->p_FmPortDriverParam->dfltCfg.rx_pri_elevation = DEFAULT_PORT_rxFifoPriElevationLevel;
-    p_FmPort->p_FmPortDriverParam->dfltCfg.rx_fifo_thr = DEFAULT_PORT_rxFifoThreshold;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.rx_pri_elevation =
+            DEFAULT_PORT_rxFifoPriElevationLevel;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.rx_fifo_thr =
+            DEFAULT_PORT_rxFifoThreshold;
 
 #if defined(FM_OP_NO_VSP_NO_RELEASE_ERRATA_FMAN_A006675) || defined(FM_ERROR_VSP_NO_MATCH_SW006)
     p_FmPort->p_FmPortDriverParam->dfltCfg.errata_A006675 = TRUE;
 #else
     p_FmPort->p_FmPortDriverParam->dfltCfg.errata_A006675 = FALSE;
 #endif
-    if ((p_FmPort->fmRevInfo.majorRev == 6) && (p_FmPort->fmRevInfo.minorRev == 0))
+    if ((p_FmPort->fmRevInfo.majorRev == 6)
+            && (p_FmPort->fmRevInfo.minorRev == 0))
         p_FmPort->p_FmPortDriverParam->dfltCfg.errata_A006320 = TRUE;
     else
         p_FmPort->p_FmPortDriverParam->dfltCfg.errata_A006320 = FALSE;
@@ -1980,14 +2291,16 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     if (p_FmPort->fmRevInfo.majorRev < 6)
     {
 #ifdef FM_NO_RESTRICT_ON_ACCESS_RSRC
-        p_FmPort->p_FmPortDriverParam->dfltCfg.excessive_threshold_register = TRUE;
+        p_FmPort->p_FmPortDriverParam->dfltCfg.excessive_threshold_register =
+                TRUE;
 #endif
         p_FmPort->p_FmPortDriverParam->dfltCfg.fmbm_rebm_has_sgd = FALSE;
         p_FmPort->p_FmPortDriverParam->dfltCfg.fmbm_tfne_has_features = FALSE;
     }
     else
     {
-        p_FmPort->p_FmPortDriverParam->dfltCfg.excessive_threshold_register = FALSE;
+        p_FmPort->p_FmPortDriverParam->dfltCfg.excessive_threshold_register =
+                FALSE;
         p_FmPort->p_FmPortDriverParam->dfltCfg.fmbm_rebm_has_sgd = TRUE;
         p_FmPort->p_FmPortDriverParam->dfltCfg.fmbm_tfne_has_features = TRUE;
     }
@@ -1997,246 +2310,236 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         p_FmPort->p_FmPortDriverParam->dfltCfg.qmi_deq_options_support = TRUE;
 
     /* Continue with other parameters */
-    p_FmPort->p_FmPortDriverParam->baseAddr                         = baseAddr;
+    p_FmPort->p_FmPortDriverParam->baseAddr = baseAddr;
     /* set memory map pointers */
-    p_FmPort->p_FmPortQmiRegs     = (t_FmPortQmiRegs *)UINT_TO_PTR(baseAddr + QMI_PORT_REGS_OFFSET);
-    p_FmPort->p_FmPortBmiRegs     = (u_FmPortBmiRegs *)UINT_TO_PTR(baseAddr + BMI_PORT_REGS_OFFSET);
-    p_FmPort->p_FmPortPrsRegs     = (t_FmPortPrsRegs *)UINT_TO_PTR(baseAddr + PRS_PORT_REGS_OFFSET);
-
-    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize = DEFAULT_PORT_bufferPrefixContent_privDataSize;
-    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult= DEFAULT_PORT_bufferPrefixContent_passPrsResult;
-    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp= DEFAULT_PORT_bufferPrefixContent_passTimeStamp;
-    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passAllOtherPCDInfo
-                                                                    = DEFAULT_PORT_bufferPrefixContent_passTimeStamp;
-    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign    = DEFAULT_PORT_bufferPrefixContent_dataAlign;
-/*    p_FmPort->p_FmPortDriverParam->dmaSwapData                      = (e_FmDmaSwapOption)DEFAULT_PORT_dmaSwapData;
-    p_FmPort->p_FmPortDriverParam->dmaIntContextCacheAttr           = (e_FmDmaCacheOption)DEFAULT_PORT_dmaIntContextCacheAttr;
-    p_FmPort->p_FmPortDriverParam->dmaHeaderCacheAttr               = (e_FmDmaCacheOption)DEFAULT_PORT_dmaHeaderCacheAttr;
-    p_FmPort->p_FmPortDriverParam->dmaScatterGatherCacheAttr        = (e_FmDmaCacheOption)DEFAULT_PORT_dmaScatterGatherCacheAttr;
-    p_FmPort->p_FmPortDriverParam->dmaWriteOptimize                 = DEFAULT_PORT_dmaWriteOptimize;
-*/    p_FmPort->p_FmPortDriverParam->liodnBase                        = p_FmPortParams->liodnBase;
-    p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore           = DEFAULT_PORT_cheksumLastBytesIgnore;
-
-    p_FmPort->maxFrameLength                                        = DEFAULT_PORT_maxFrameLength;
+    p_FmPort->p_FmPortQmiRegs =
+            (t_FmPortQmiRegs *)UINT_TO_PTR(baseAddr + QMI_PORT_REGS_OFFSET);
+    p_FmPort->p_FmPortBmiRegs =
+            (u_FmPortBmiRegs *)UINT_TO_PTR(baseAddr + BMI_PORT_REGS_OFFSET);
+    p_FmPort->p_FmPortPrsRegs =
+            (t_FmPortPrsRegs *)UINT_TO_PTR(baseAddr + PRS_PORT_REGS_OFFSET);
+
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize =
+            DEFAULT_PORT_bufferPrefixContent_privDataSize;
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult =
+            DEFAULT_PORT_bufferPrefixContent_passPrsResult;
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp =
+            DEFAULT_PORT_bufferPrefixContent_passTimeStamp;
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passAllOtherPCDInfo =
+            DEFAULT_PORT_bufferPrefixContent_passTimeStamp;
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign =
+            DEFAULT_PORT_bufferPrefixContent_dataAlign;
+    /*    p_FmPort->p_FmPortDriverParam->dmaSwapData                      = (e_FmDmaSwapOption)DEFAULT_PORT_dmaSwapData;
+     p_FmPort->p_FmPortDriverParam->dmaIntContextCacheAttr           = (e_FmDmaCacheOption)DEFAULT_PORT_dmaIntContextCacheAttr;
+     p_FmPort->p_FmPortDriverParam->dmaHeaderCacheAttr               = (e_FmDmaCacheOption)DEFAULT_PORT_dmaHeaderCacheAttr;
+     p_FmPort->p_FmPortDriverParam->dmaScatterGatherCacheAttr        = (e_FmDmaCacheOption)DEFAULT_PORT_dmaScatterGatherCacheAttr;
+     p_FmPort->p_FmPortDriverParam->dmaWriteOptimize                 = DEFAULT_PORT_dmaWriteOptimize;
+     */
+    p_FmPort->p_FmPortDriverParam->liodnBase = p_FmPortParams->liodnBase;
+    p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore =
+            DEFAULT_PORT_cheksumLastBytesIgnore;
+
+    p_FmPort->maxFrameLength = DEFAULT_PORT_maxFrameLength;
     /* resource distribution. */
-#ifdef FM_NO_GUARANTEED_RESET_VALUES
-    if (1) /* if (p_FmPort->fmRevInfo.majorRev < 6) */
-    {
-        p_FmPort->fifoBufs.num                                      = DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)*BMI_FIFO_UNITS;
-        p_FmPort->fifoBufs.extra                                    = DEFAULT_PORT_extraNumOfFifoBufs*BMI_FIFO_UNITS;
-        p_FmPort->openDmas.num                                      = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType);
-        p_FmPort->openDmas.extra                                    = DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
-        p_FmPort->tasks.num                                         = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
-        p_FmPort->tasks.extra                                       = DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
-    }
-    else
-#endif /* FM_NO_GUARANTEED_RESET_VALUES */
-    {
-        if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND) &&
-            (p_FmPortParams->portId != FM_OH_PORT_ID))
-        {
-            /* Overwrite HC defaults */
-            p_FmPort->fifoBufs.num      = DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)*BMI_FIFO_UNITS;
-            p_FmPort->fifoBufs.extra    = DEFAULT_PORT_extraNumOfFifoBufs*BMI_FIFO_UNITS;
-            p_FmPort->openDmas.num      = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType);
-            p_FmPort->openDmas.extra    = DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
-            p_FmPort->tasks.num         = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
-            p_FmPort->tasks.extra       = DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
-        }
-        else
-        {
-            p_FmPort->fifoBufs.num                                      = 0;
-            p_FmPort->fifoBufs.extra                                    = 0;
-            p_FmPort->openDmas.num                                      = 0;
-            p_FmPort->openDmas.extra                                    = 0;
-            p_FmPort->tasks.num                                         = 0;
-            p_FmPort->tasks.extra                                       = 0;
-        }
-    }
+	p_FmPort->fifoBufs.num = DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)
+			* BMI_FIFO_UNITS;
+	p_FmPort->fifoBufs.extra = DEFAULT_PORT_extraNumOfFifoBufs
+			* BMI_FIFO_UNITS;
+	p_FmPort->openDmas.num = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType);
+	p_FmPort->openDmas.extra =
+			DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
+	p_FmPort->tasks.num = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
+	p_FmPort->tasks.extra = DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
+
 
 #ifdef FM_HEAVY_TRAFFIC_SEQUENCER_HANG_ERRATA_FMAN_A006981
-    if ((p_FmPort->fmRevInfo.majorRev == 6) &&
-        (p_FmPort->fmRevInfo.minorRev == 0) &&
-        ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
-         (p_FmPort->portType == e_FM_PORT_TYPE_TX)))
-        {
-            p_FmPort->openDmas.num = 16;
-            p_FmPort->openDmas.extra = 0;
-        }
+    if ((p_FmPort->fmRevInfo.majorRev == 6)
+            && (p_FmPort->fmRevInfo.minorRev == 0)
+            && ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+                    || (p_FmPort->portType == e_FM_PORT_TYPE_TX)))
+    {
+        p_FmPort->openDmas.num = 16;
+        p_FmPort->openDmas.extra = 0;
+    }
 #endif /* FM_HEAVY_TRAFFIC_SEQUENCER_HANG_ERRATA_FMAN_A006981 */
 
     /* Port type specific initialization: */
     switch (p_FmPort->portType)
     {
-    case (e_FM_PORT_TYPE_RX):
-    case (e_FM_PORT_TYPE_RX_10G):
-        /* Initialize FM port parameters for initialization phase only */
-        p_FmPort->p_FmPortDriverParam->cutBytesFromEnd              = DEFAULT_PORT_cutBytesFromEnd;
-        p_FmPort->p_FmPortDriverParam->enBufPoolDepletion           = FALSE;
-        p_FmPort->p_FmPortDriverParam->frmDiscardOverride           = DEFAULT_PORT_frmDiscardOverride;
-#ifdef FM_NO_GUARANTEED_RESET_VALUES
-    if (1) /* if (p_FmPort->fmRevInfo.majorRev < 6) */
-    {
-        p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel      = DEFAULT_PORT_rxFifoPriElevationLevel;
-        p_FmPort->p_FmPortDriverParam->rxFifoThreshold              = DEFAULT_PORT_rxFifoThreshold;
-    }
-    else
-#endif /* FM_NO_GUARANTEED_RESET_VALUES */
-    {
-        tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfp);
-        p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel      = (((tmpReg & BMI_RX_FIFO_PRI_ELEVATION_MASK) >> BMI_RX_FIFO_PRI_ELEVATION_SHIFT) + 1) * BMI_FIFO_UNITS ;
-        p_FmPort->p_FmPortDriverParam->rxFifoThreshold              = (((tmpReg  & BMI_RX_FIFO_THRESHOLD_MASK) >> BMI_RX_FIFO_THRESHOLD_SHIFT) + 1) * BMI_FIFO_UNITS;
-    }
-
-        p_FmPort->p_FmPortDriverParam->bufMargins.endMargins        = DEFAULT_PORT_BufMargins_endMargins;
-        p_FmPort->p_FmPortDriverParam->errorsToDiscard              = DEFAULT_PORT_errorsToDiscard;
-        p_FmPort->p_FmPortDriverParam->forwardReuseIntContext       = DEFAULT_PORT_forwardIntContextReuse;
+        case (e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+            /* Initialize FM port parameters for initialization phase only */
+            p_FmPort->p_FmPortDriverParam->cutBytesFromEnd =
+                    DEFAULT_PORT_cutBytesFromEnd;
+            p_FmPort->p_FmPortDriverParam->enBufPoolDepletion = FALSE;
+            p_FmPort->p_FmPortDriverParam->frmDiscardOverride =
+                    DEFAULT_PORT_frmDiscardOverride;
+
+                tmpReg =
+                        GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfp);
+			p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel =
+                        (((tmpReg & BMI_RX_FIFO_PRI_ELEVATION_MASK)
+                                >> BMI_RX_FIFO_PRI_ELEVATION_SHIFT) + 1)
+                                * BMI_FIFO_UNITS;
+                p_FmPort->p_FmPortDriverParam->rxFifoThreshold = (((tmpReg
+                        & BMI_RX_FIFO_THRESHOLD_MASK)
+                        >> BMI_RX_FIFO_THRESHOLD_SHIFT) + 1) * BMI_FIFO_UNITS;
+
+            p_FmPort->p_FmPortDriverParam->bufMargins.endMargins =
+                    DEFAULT_PORT_BufMargins_endMargins;
+            p_FmPort->p_FmPortDriverParam->errorsToDiscard =
+                    DEFAULT_PORT_errorsToDiscard;
+            p_FmPort->p_FmPortDriverParam->forwardReuseIntContext =
+                    DEFAULT_PORT_forwardIntContextReuse;
 #if (DPAA_VERSION >= 11)
-        p_FmPort->p_FmPortDriverParam->noScatherGather              = DEFAULT_PORT_noScatherGather;
+            p_FmPort->p_FmPortDriverParam->noScatherGather =
+                    DEFAULT_PORT_noScatherGather;
 #endif /* (DPAA_VERSION >= 11) */
-        break;
+            break;
 
-    case (e_FM_PORT_TYPE_TX):
-        p_FmPort->p_FmPortDriverParam->dontReleaseBuf               = FALSE;
+        case (e_FM_PORT_TYPE_TX):
+            p_FmPort->p_FmPortDriverParam->dontReleaseBuf = FALSE;
 #ifdef FM_WRONG_RESET_VALUES_ERRATA_FMAN_A005127
-        tmpReg = 0x00001013;
-        WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tfp, tmpReg);
+            tmpReg = 0x00001013;
+            WRITE_UINT32( p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tfp,
+                         tmpReg);
 #endif /* FM_WRONG_RESET_VALUES_ERRATA_FMAN_A005127 */
-    case (e_FM_PORT_TYPE_TX_10G):
-#ifdef FM_NO_GUARANTEED_RESET_VALUES
-        if (1) /* if (p_FmPort->fmRevInfo.majorRev < 6) */
-        {
-            p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel       = DEFAULT_PORT_txFifoMinFillLevel;
-            p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth                          =
-                (uint8_t)((p_FmPort->portType == e_FM_PORT_TYPE_TX) ?
-                          DEFAULT_PORT_fifoDeqPipelineDepth_1G :
-                          DEFAULT_PORT_fifoDeqPipelineDepth_10G);
-            p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel       = DEFAULT_PORT_txFifoLowComfLevel;
-        }
-        else
-#endif /* FM_NO_GUARANTEED_RESET_VALUES */
-        {
-            tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tfp);
-            p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel =
-                ((tmpReg & BMI_TX_FIFO_MIN_FILL_MASK) >> BMI_TX_FIFO_MIN_FILL_SHIFT) * BMI_FIFO_UNITS ;
-            p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
-                (uint8_t)(((tmpReg & BMI_FIFO_PIPELINE_DEPTH_MASK) >> BMI_FIFO_PIPELINE_DEPTH_SHIFT) + 1);
-            p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel =
-                (((tmpReg & BMI_TX_LOW_COMF_MASK) >> BMI_TX_LOW_COMF_SHIFT) + 1) * BMI_FIFO_UNITS;
-        }
-
-        p_FmPort->p_FmPortDriverParam->deqType                      = DEFAULT_PORT_deqType;
-        p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption;
-        p_FmPort->p_FmPortDriverParam->deqHighPriority              =
-            (bool)((p_FmPort->portType == e_FM_PORT_TYPE_TX) ?
-                   DEFAULT_PORT_deqHighPriority_1G :
-                   DEFAULT_PORT_deqHighPriority_10G);
-        p_FmPort->p_FmPortDriverParam->deqByteCnt                   =
-            (uint16_t)((p_FmPort->portType == e_FM_PORT_TYPE_TX) ?
-                       DEFAULT_PORT_deqByteCnt_1G :
-                       DEFAULT_PORT_deqByteCnt_10G);
-        break;
-    case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        p_FmPort->p_FmPortDriverParam->errorsToDiscard              = DEFAULT_PORT_errorsToDiscard;
+        case (e_FM_PORT_TYPE_TX_10G):
+                tmpReg =
+                        GET_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tfp);
+                p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel = ((tmpReg
+                        & BMI_TX_FIFO_MIN_FILL_MASK)
+                        >> BMI_TX_FIFO_MIN_FILL_SHIFT) * BMI_FIFO_UNITS;
+			p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
+                        (uint8_t)(((tmpReg & BMI_FIFO_PIPELINE_DEPTH_MASK)
+                                >> BMI_FIFO_PIPELINE_DEPTH_SHIFT) + 1);
+                p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel = (((tmpReg
+                        & BMI_TX_LOW_COMF_MASK) >> BMI_TX_LOW_COMF_SHIFT) + 1)
+                        * BMI_FIFO_UNITS;
+
+            p_FmPort->p_FmPortDriverParam->deqType = DEFAULT_PORT_deqType;
+            p_FmPort->p_FmPortDriverParam->deqPrefetchOption =
+                    DEFAULT_PORT_deqPrefetchOption;
+            p_FmPort->p_FmPortDriverParam->deqHighPriority =
+                    (bool)((p_FmPort->portType == e_FM_PORT_TYPE_TX) ? DEFAULT_PORT_deqHighPriority_1G :
+                            DEFAULT_PORT_deqHighPriority_10G);
+            p_FmPort->p_FmPortDriverParam->deqByteCnt =
+                    (uint16_t)(
+                            (p_FmPort->portType == e_FM_PORT_TYPE_TX) ? DEFAULT_PORT_deqByteCnt_1G :
+                                    DEFAULT_PORT_deqByteCnt_10G);
+            break;
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            p_FmPort->p_FmPortDriverParam->errorsToDiscard =
+                    DEFAULT_PORT_errorsToDiscard;
 #if (DPAA_VERSION >= 11)
-        p_FmPort->p_FmPortDriverParam->noScatherGather              = DEFAULT_PORT_noScatherGather;
+            p_FmPort->p_FmPortDriverParam->noScatherGather =
+                    DEFAULT_PORT_noScatherGather;
 #endif /* (DPAA_VERSION >= 11) */
-    case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
-        p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption_HC;
-        p_FmPort->p_FmPortDriverParam->deqHighPriority              = DEFAULT_PORT_deqHighPriority_1G;
-        p_FmPort->p_FmPortDriverParam->deqType                      = DEFAULT_PORT_deqType;
-        p_FmPort->p_FmPortDriverParam->deqByteCnt                   = DEFAULT_PORT_deqByteCnt_1G;
-
-#ifdef FM_NO_GUARANTEED_RESET_VALUES
-    if (1) /* if (p_FmPort->fmRevInfo.majorRev < 6) */
-        p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth                              = DEFAULT_PORT_fifoDeqPipelineDepth_OH;
-    else
-#endif /* FM_NO_GUARANTEED_RESET_VALUES */
-    {
-        tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofp);
-        p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
-            (uint8_t)(((tmpReg & BMI_FIFO_PIPELINE_DEPTH_MASK) >> BMI_FIFO_PIPELINE_DEPTH_SHIFT) + 1);
-        if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND) &&
-            (p_FmPortParams->portId != FM_OH_PORT_ID))
-        {
-            /* Overwrite HC defaults */
-            p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth = DEFAULT_PORT_fifoDeqPipelineDepth_OH;
-        }
-    }
+        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            p_FmPort->p_FmPortDriverParam->deqPrefetchOption =
+                    DEFAULT_PORT_deqPrefetchOption_HC;
+            p_FmPort->p_FmPortDriverParam->deqHighPriority =
+                    DEFAULT_PORT_deqHighPriority_1G;
+            p_FmPort->p_FmPortDriverParam->deqType = DEFAULT_PORT_deqType;
+            p_FmPort->p_FmPortDriverParam->deqByteCnt =
+                    DEFAULT_PORT_deqByteCnt_1G;
+
+                tmpReg =
+                        GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofp);
+                p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
+                        (uint8_t)(((tmpReg & BMI_FIFO_PIPELINE_DEPTH_MASK)
+                                >> BMI_FIFO_PIPELINE_DEPTH_SHIFT) + 1);
+                if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
+                        && (p_FmPortParams->portId != FM_OH_PORT_ID))
+                {
+                    /* Overwrite HC defaults */
+			p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
+					DEFAULT_PORT_fifoDeqPipelineDepth_OH;
+                }
 
 #ifndef FM_FRAME_END_PARAMS_FOR_OP
-        if (p_FmPort->fmRevInfo.majorRev < 6)
-            p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore   = DEFAULT_notSupported;
+            if (p_FmPort->fmRevInfo.majorRev < 6)
+            p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore = DEFAULT_notSupported;
 #endif /* !FM_FRAME_END_PARAMS_FOR_OP */
 
 #ifndef FM_DEQ_PIPELINE_PARAMS_FOR_OP
-    if (!((p_FmPort->fmRevInfo.majorRev == 4) ||
-          (p_FmPort->fmRevInfo.majorRev >= 6)))
-            p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth                          = DEFAULT_notSupported;
+            if (!((p_FmPort->fmRevInfo.majorRev == 4) ||
+                            (p_FmPort->fmRevInfo.majorRev >= 6)))
+            p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth = DEFAULT_notSupported;
 #endif /* !FM_DEQ_PIPELINE_PARAMS_FOR_OP */
-        break;
+            break;
 
-    default:
-        XX_Free(p_FmPort->p_FmPortDriverParam);
-        XX_Free(p_FmPort);
-        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
-        return NULL;
+        default:
+            XX_Free(p_FmPort->p_FmPortDriverParam);
+            XX_Free(p_FmPort);
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+            return NULL;
     }
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
     if (p_FmPort->fmRevInfo.majorRev == 4)
-        p_FmPort->p_FmPortDriverParam->deqPrefetchOption = (e_FmPortDeqPrefetchOption)DEFAULT_notSupported;
+    p_FmPort->p_FmPortDriverParam->deqPrefetchOption = (e_FmPortDeqPrefetchOption)DEFAULT_notSupported;
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
 
     p_FmPort->imEn = p_FmPortParams->independentModeEnable;
 
     if (p_FmPort->imEn)
     {
-        if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) ||
-            (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
-            p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth = DEFAULT_PORT_fifoDeqPipelineDepth_IM;
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_TX)
+                || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
+            p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
+                    DEFAULT_PORT_fifoDeqPipelineDepth_IM;
         FmPortConfigIM(p_FmPort, p_FmPortParams);
     }
     else
     {
         switch (p_FmPort->portType)
         {
-        case (e_FM_PORT_TYPE_RX):
-        case (e_FM_PORT_TYPE_RX_10G):
-            /* Initialize FM port parameters for initialization phase only */
-            memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools,
-                   &p_FmPortParams->specificParams.rxParams.extBufPools,
-                   sizeof(t_FmExtPools));
-            p_FmPort->p_FmPortDriverParam->errFqid                      = p_FmPortParams->specificParams.rxParams.errFqid;
-            p_FmPort->p_FmPortDriverParam->dfltFqid                     = p_FmPortParams->specificParams.rxParams.dfltFqid;
-            p_FmPort->p_FmPortDriverParam->liodnOffset                  = p_FmPortParams->specificParams.rxParams.liodnOffset;
-            break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case (e_FM_PORT_TYPE_TX):
-        case (e_FM_PORT_TYPE_TX_10G):
-        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            p_FmPort->p_FmPortDriverParam->errFqid                      = p_FmPortParams->specificParams.nonRxParams.errFqid;
-            p_FmPort->p_FmPortDriverParam->deqSubPortal                 =
-                (uint8_t)(p_FmPortParams->specificParams.nonRxParams.qmChannel & QMI_DEQ_CFG_SUBPORTAL_MASK);
-            p_FmPort->p_FmPortDriverParam->dfltFqid                     = p_FmPortParams->specificParams.nonRxParams.dfltFqid;
-            break;
-        default:
-            XX_Free(p_FmPort->p_FmPortDriverParam);
-            XX_Free(p_FmPort);
-            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
-            return NULL;
+            case (e_FM_PORT_TYPE_RX):
+            case (e_FM_PORT_TYPE_RX_10G):
+                /* Initialize FM port parameters for initialization phase only */
+                memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools,
+                       &p_FmPortParams->specificParams.rxParams.extBufPools,
+                       sizeof(t_FmExtPools));
+                p_FmPort->p_FmPortDriverParam->errFqid =
+                        p_FmPortParams->specificParams.rxParams.errFqid;
+                p_FmPort->p_FmPortDriverParam->dfltFqid =
+                        p_FmPortParams->specificParams.rxParams.dfltFqid;
+                p_FmPort->p_FmPortDriverParam->liodnOffset =
+                        p_FmPortParams->specificParams.rxParams.liodnOffset;
+                break;
+            case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case (e_FM_PORT_TYPE_TX):
+            case (e_FM_PORT_TYPE_TX_10G):
+            case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
+                p_FmPort->p_FmPortDriverParam->errFqid =
+                        p_FmPortParams->specificParams.nonRxParams.errFqid;
+                p_FmPort->p_FmPortDriverParam->deqSubPortal =
+                        (uint8_t)(p_FmPortParams->specificParams.nonRxParams.qmChannel
+                                & QMI_DEQ_CFG_SUBPORTAL_MASK);
+                p_FmPort->p_FmPortDriverParam->dfltFqid =
+                        p_FmPortParams->specificParams.nonRxParams.dfltFqid;
+                break;
+            default:
+                XX_Free(p_FmPort->p_FmPortDriverParam);
+                XX_Free(p_FmPort);
+                REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
+                return NULL;
         }
     }
 
     memset(p_FmPort->name, 0, (sizeof(char)) * MODULE_NAME_SIZE);
-    if (Sprint (p_FmPort->name, "FM-%d-port-%s-%d",
-               FmGetId(p_FmPort->h_Fm),
-               ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING ||
-                 (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)) ?
-                "OH" : (p_FmPort->portType == e_FM_PORT_TYPE_RX ?
-                        "1g-RX" : (p_FmPort->portType == e_FM_PORT_TYPE_TX ?
-                                   "1g-TX" : (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G ?
-                                              "10g-RX" : "10g-TX")))),
-               p_FmPort->portId) == 0)
+    if (Sprint(
+            p_FmPort->name,
+            "FM-%d-port-%s-%d",
+            FmGetId(p_FmPort->h_Fm),
+            ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING
+                    || (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)) ? "OH" :
+                    (p_FmPort->portType == e_FM_PORT_TYPE_RX ? "1g-RX" :
+                            (p_FmPort->portType == e_FM_PORT_TYPE_TX ? "1g-TX" :
+                                    (p_FmPort->portType
+                                            == e_FM_PORT_TYPE_RX_10G ? "10g-RX" :
+                                            "10g-TX")))),
+            p_FmPort->portId) == 0)
     {
         XX_Free(p_FmPort->p_FmPortDriverParam);
         XX_Free(p_FmPort);
@@ -2267,39 +2570,38 @@ t_FmPort *tx_port = 0;
  @Param[in]     h_FmPort - FM module descriptor
 
  @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
+ *//***************************************************************************/
 t_Error FM_PORT_Init(t_Handle h_FmPort)
 {
-    t_FmPort                        *p_FmPort = (t_FmPort*)h_FmPort;
-    t_FmPortDriverParam             *p_DriverParams;
-    t_Error                         errCode;
-    t_FmInterModulePortInitParams   fmParams;
-    t_FmRevisionInfo                revInfo;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPortDriverParam *p_DriverParams;
+    t_Error errCode;
+    t_FmInterModulePortInitParams fmParams;
+    t_FmRevisionInfo revInfo;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    errCode = FmSpBuildBufferStructure(&p_FmPort->p_FmPortDriverParam->intContext,
-                                       &p_FmPort->p_FmPortDriverParam->bufferPrefixContent,
-                                       &p_FmPort->p_FmPortDriverParam->bufMargins,
-                                       &p_FmPort->bufferOffsets,
-                                       &p_FmPort->internalBufferOffset);
+    errCode = FmSpBuildBufferStructure(
+            &p_FmPort->p_FmPortDriverParam->intContext,
+            &p_FmPort->p_FmPortDriverParam->bufferPrefixContent,
+            &p_FmPort->p_FmPortDriverParam->bufMargins,
+            &p_FmPort->bufferOffsets, &p_FmPort->internalBufferOffset);
     if (errCode != E_OK)
         RETURN_ERROR(MAJOR, errCode, NO_MSG);
 #ifdef FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669
     if ((p_FmPort->p_FmPortDriverParam->bcbWorkaround) &&
-           (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+            (p_FmPort->portType == e_FM_PORT_TYPE_RX))
     {
         p_FmPort->p_FmPortDriverParam->errorsToDiscard |= FM_PORT_FRM_ERR_PHYSICAL;
         if (!p_FmPort->fifoBufs.num)
-            p_FmPort->fifoBufs.num = DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)*BMI_FIFO_UNITS;
+        p_FmPort->fifoBufs.num = DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)*BMI_FIFO_UNITS;
         p_FmPort->fifoBufs.num += 4*KILOBYTE;
     }
 #endif /* FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669 */
 
     CHECK_INIT_PARAMETERS(p_FmPort, CheckInitParameters);
 
-
     p_DriverParams = p_FmPort->p_FmPortDriverParam;
 
     /* Set up flibs port structure */
@@ -2308,38 +2610,38 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     FM_GetRevision(p_FmPort->h_Fm, &revInfo);
     p_FmPort->port.fm_rev_maj = revInfo.majorRev;
     p_FmPort->port.fm_rev_min = revInfo.minorRev;
-    p_FmPort->port.bmi_regs = (union fman_port_bmi_regs *)
-            UINT_TO_PTR(p_DriverParams->baseAddr + BMI_PORT_REGS_OFFSET);
-    p_FmPort->port.qmi_regs = (struct fman_port_qmi_regs *)
-            UINT_TO_PTR(p_DriverParams->baseAddr + QMI_PORT_REGS_OFFSET);
+    p_FmPort->port.bmi_regs =
+            (union fman_port_bmi_regs *)UINT_TO_PTR(p_DriverParams->baseAddr + BMI_PORT_REGS_OFFSET);
+    p_FmPort->port.qmi_regs =
+            (struct fman_port_qmi_regs *)UINT_TO_PTR(p_DriverParams->baseAddr + QMI_PORT_REGS_OFFSET);
     p_FmPort->port.ext_pools_num = (uint8_t)((revInfo.majorRev == 4) ? 4 : 8);
     p_FmPort->port.im_en = p_FmPort->imEn;
-    p_FmPort->p_FmPortPrsRegs     = (t_FmPortPrsRegs *)UINT_TO_PTR(p_DriverParams->baseAddr + PRS_PORT_REGS_OFFSET);
-
-    if  (((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
-         (p_FmPort->portType == e_FM_PORT_TYPE_RX))
-        && !p_FmPort->imEn)
-    {
-            /* Call the external Buffer routine which also checks fifo
-             size and updates it if necessary */
-            /* define external buffer pools and pool depletion*/
-            errCode = SetExtBufferPools(p_FmPort);
-            if (errCode)
-                RETURN_ERROR(MAJOR, errCode, NO_MSG);
-            /* check if the largest external buffer pool is large enough */
-            if (p_DriverParams->bufMargins.startMargins + MIN_EXT_BUF_SIZE + p_DriverParams->bufMargins.endMargins >
-                p_FmPort->rxPoolsParams.largestBufSize)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                             ("bufMargins.startMargins (%d) + minimum buf size (64) + bufMargins.endMargins (%d) is larger than maximum external buffer size (%d)",
-                              p_DriverParams->bufMargins.startMargins,
-                              p_DriverParams->bufMargins.endMargins,
-                              p_FmPort->rxPoolsParams.largestBufSize));
+    p_FmPort->p_FmPortPrsRegs =
+            (t_FmPortPrsRegs *)UINT_TO_PTR(p_DriverParams->baseAddr + PRS_PORT_REGS_OFFSET);
+
+    if (((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX)) && !p_FmPort->imEn)
+    {
+        /* Call the external Buffer routine which also checks fifo
+         size and updates it if necessary */
+        /* define external buffer pools and pool depletion*/
+        errCode = SetExtBufferPools(p_FmPort);
+        if (errCode)
+            RETURN_ERROR(MAJOR, errCode, NO_MSG);
+        /* check if the largest external buffer pool is large enough */
+        if (p_DriverParams->bufMargins.startMargins + MIN_EXT_BUF_SIZE
+                + p_DriverParams->bufMargins.endMargins
+                > p_FmPort->rxPoolsParams.largestBufSize)
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("bufMargins.startMargins (%d) + minimum buf size (64) + bufMargins.endMargins (%d) is larger than maximum external buffer size (%d)", p_DriverParams->bufMargins.startMargins, p_DriverParams->bufMargins.endMargins, p_FmPort->rxPoolsParams.largestBufSize));
     }
     if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
     {
         {
 #ifdef FM_NO_OP_OBSERVED_POOLS
-            t_FmRevisionInfo        revInfo;
+            t_FmRevisionInfo revInfo;
 
             FM_GetRevision(p_FmPort->h_Fm, &revInfo);
             if ((revInfo.majorRev == 4) && (p_DriverParams->enBufPoolDepletion))
@@ -2357,11 +2659,11 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     /* Call FM module routine for communicating parameters      */
     /************************************************************/
     memset(&fmParams, 0, sizeof(fmParams));
-    fmParams.hardwarePortId     = p_FmPort->hardwarePortId;
-    fmParams.portType           = (e_FmPortType)p_FmPort->portType;
-    fmParams.numOfTasks         = (uint8_t)p_FmPort->tasks.num;
-    fmParams.numOfExtraTasks    = (uint8_t)p_FmPort->tasks.extra;
-    fmParams.numOfOpenDmas      = (uint8_t)p_FmPort->openDmas.num;
+    fmParams.hardwarePortId = p_FmPort->hardwarePortId;
+    fmParams.portType = (e_FmPortType)p_FmPort->portType;
+    fmParams.numOfTasks = (uint8_t)p_FmPort->tasks.num;
+    fmParams.numOfExtraTasks = (uint8_t)p_FmPort->tasks.extra;
+    fmParams.numOfOpenDmas = (uint8_t)p_FmPort->openDmas.num;
     fmParams.numOfExtraOpenDmas = (uint8_t)p_FmPort->openDmas.extra;
 
     if (p_FmPort->fifoBufs.num)
@@ -2370,49 +2672,37 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
         if (errCode != E_OK)
             RETURN_ERROR(MAJOR, errCode, NO_MSG);
     }
-    fmParams.sizeOfFifo         = p_FmPort->fifoBufs.num;
-    fmParams.extraSizeOfFifo    = p_FmPort->fifoBufs.extra;
-    fmParams.independentMode    = p_FmPort->imEn;
-    fmParams.liodnOffset        = p_DriverParams->liodnOffset;
-    fmParams.liodnBase          = p_DriverParams->liodnBase;
-    fmParams.deqPipelineDepth   = p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth;
-    fmParams.maxFrameLength     = p_FmPort->maxFrameLength;
+    fmParams.sizeOfFifo = p_FmPort->fifoBufs.num;
+    fmParams.extraSizeOfFifo = p_FmPort->fifoBufs.extra;
+    fmParams.independentMode = p_FmPort->imEn;
+    fmParams.liodnOffset = p_DriverParams->liodnOffset;
+    fmParams.liodnBase = p_DriverParams->liodnBase;
+    fmParams.deqPipelineDepth =
+            p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth;
+    fmParams.maxFrameLength = p_FmPort->maxFrameLength;
 #ifndef FM_DEQ_PIPELINE_PARAMS_FOR_OP
     if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+            (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
     {
         if (!((p_FmPort->fmRevInfo.majorRev == 4) ||
-                (p_FmPort->fmRevInfo.majorRev >= 6)))
-            /* HC ports do not have fifoDeqPipelineDepth, but it is needed only
-             * for deq threshold calculation.
-             */
-            fmParams.deqPipelineDepth = 2;
+                        (p_FmPort->fmRevInfo.majorRev >= 6)))
+        /* HC ports do not have fifoDeqPipelineDepth, but it is needed only
+         * for deq threshold calculation.
+         */
+        fmParams.deqPipelineDepth = 2;
     }
 #endif /* !FM_DEQ_PIPELINE_PARAMS_FOR_OP */
 
-
     errCode = FmGetSetPortParams(p_FmPort->h_Fm, &fmParams);
     if (errCode)
         RETURN_ERROR(MAJOR, errCode, NO_MSG);
 
     /* get params for use in init */
     p_FmPort->fmMuramPhysBaseAddr =
-        (uint64_t)((uint64_t)(fmParams.fmMuramPhysBaseAddr.low) |
-                   ((uint64_t)(fmParams.fmMuramPhysBaseAddr.high) << 32));
+            (uint64_t)((uint64_t)(fmParams.fmMuramPhysBaseAddr.low)
+                    | ((uint64_t)(fmParams.fmMuramPhysBaseAddr.high) << 32));
     p_FmPort->h_FmMuram = FmGetMuramHandle(p_FmPort->h_Fm);
 
-#ifndef FM_NO_GUARANTEED_RESET_VALUES
-    if (p_FmPort->fmRevInfo.majorRev >= 6)
-    {
-        p_FmPort->tasks.num = fmParams.numOfTasks;
-        p_FmPort->tasks.extra = fmParams.numOfExtraTasks;
-        p_FmPort->openDmas.num = fmParams.numOfOpenDmas;
-        p_FmPort->openDmas.extra = fmParams.numOfExtraOpenDmas;
-        p_FmPort->fifoBufs.num = fmParams.sizeOfFifo;
-        p_FmPort->fifoBufs.extra = fmParams.extraSizeOfFifo;
-    }
-#endif /* FM_NO_GUARANTEED_RESET_VALUES */
-
     errCode = InitLowLevelDriver(p_FmPort);
     if (errCode != E_OK)
         RETURN_ERROR(MAJOR, errCode, NO_MSG);
@@ -2420,41 +2710,43 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     FmPortDriverParamFree(p_FmPort);
 
 #if (DPAA_VERSION >= 11)
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
     {
-        t_FmPcdCtrlParamsPage   *p_ParamsPage;
+        t_FmPcdCtrlParamsPage *p_ParamsPage;
 
-        FmPortSetGprFunc(p_FmPort, e_FM_PORT_GPR_MURAM_PAGE, (void**)&p_ParamsPage);
+        FmPortSetGprFunc(p_FmPort, e_FM_PORT_GPR_MURAM_PAGE,
+                         (void**)&p_ParamsPage);
         ASSERT_COND(p_ParamsPage);
 
         WRITE_UINT32(p_ParamsPage->misc, FM_CTL_PARAMS_PAGE_ALWAYS_ON);
 #ifdef FM_OP_NO_VSP_NO_RELEASE_ERRATA_FMAN_A006675
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         {
-            WRITE_UINT32(p_ParamsPage->misc,
-                         (GET_UINT32(p_ParamsPage->misc) | FM_CTL_PARAMS_PAGE_OP_FIX_EN));
-            WRITE_UINT32(p_ParamsPage->discardMask,
-                         GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm));
+            WRITE_UINT32(
+                    p_ParamsPage->misc,
+                    (GET_UINT32(p_ParamsPage->misc) | FM_CTL_PARAMS_PAGE_OP_FIX_EN));
+            WRITE_UINT32(
+                    p_ParamsPage->discardMask,
+                    GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm));
         }
 #endif /* FM_OP_NO_VSP_NO_RELEASE_ERRATA_FMAN_A006675 */
 #ifdef FM_ERROR_VSP_NO_MATCH_SW006
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            WRITE_UINT32(p_ParamsPage->errorsDiscardMask,
-                         (GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm) |
-                          GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsem)));
+            WRITE_UINT32(
+                    p_ParamsPage->errorsDiscardMask,
+                    (GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm) | GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsem)));
         else
-            WRITE_UINT32(p_ParamsPage->errorsDiscardMask,
-                         (GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm) |
-                          GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsem)));
+            WRITE_UINT32(
+                    p_ParamsPage->errorsDiscardMask,
+                    (GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm) | GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsem)));
 #endif /* FM_ERROR_VSP_NO_MATCH_SW006 */
     }
 #endif /* (DPAA_VERSION >= 11) */
 
     if (p_FmPort->deepSleepVars.autoResMaxSizes)
         FmPortConfigAutoResForDeepSleepSupport1(p_FmPort);
-
     return E_OK;
 }
 
@@ -2463,21 +2755,24 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
 
  @Description   Frees all resources that were assigned to FM module.
 
-                Calling this routine invalidates the descriptor.
+ Calling this routine invalidates the descriptor.
 
  @Param[in]     h_FmPort - FM module descriptor
 
  @Return        E_OK on success; Error code otherwise.
-*//***************************************************************************/
+ *//***************************************************************************/
 t_Error FM_PORT_Free(t_Handle h_FmPort)
 {
-    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
-    t_FmInterModulePortFreeParams       fmParams;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmInterModulePortFreeParams fmParams;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
     if (p_FmPort->pcdEngines)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Trying to free a port with PCD. FM_PORT_DeletePCD must be called first."));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_STATE,
+                ("Trying to free a port with PCD. FM_PORT_DeletePCD must be called first."));
 
     if (p_FmPort->enabled)
     {
@@ -2490,16 +2785,17 @@ t_Error FM_PORT_Free(t_Handle h_FmPort)
 
     FmPortDriverParamFree(p_FmPort);
 
+    memset(&fmParams, 0, sizeof(fmParams));
     fmParams.hardwarePortId = p_FmPort->hardwarePortId;
     fmParams.portType = (e_FmPortType)p_FmPort->portType;
-    fmParams.deqPipelineDepth = p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth;
+    fmParams.deqPipelineDepth =
+            p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth;
 
     FmFreePortParams(p_FmPort->h_Fm, &fmParams);
 
 #if (DPAA_VERSION >= 11)
-    if (FmVSPFreeForPort(p_FmPort->h_Fm,
-                        p_FmPort->portType,
-                        p_FmPort->portId) != E_OK)
+    if (FmVSPFreeForPort(p_FmPort->h_Fm, p_FmPort->portType, p_FmPort->portId)
+            != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("VSP free of port FAILED"));
 
     if (p_FmPort->p_ParamsPage)
@@ -2514,7 +2810,6 @@ t_Error FM_PORT_Free(t_Handle h_FmPort)
     return E_OK;
 }
 
-
 /*************************************************/
 /*       API Advanced Init unit functions        */
 /*************************************************/
@@ -2563,7 +2858,8 @@ t_Error FM_PORT_ConfigDeqHighPriority(t_Handle h_FmPort, bool highPri)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("not available for Rx ports"));
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.deq_high_pri = highPri;
@@ -2577,40 +2873,52 @@ t_Error FM_PORT_ConfigDeqType(t_Handle h_FmPort, e_FmPortDeqType deqType)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("not available for Rx ports"));
 
-    p_FmPort->p_FmPortDriverParam->dfltCfg.deq_type = (enum fman_port_deq_type)deqType;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.deq_type =
+            (enum fman_port_deq_type)deqType;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOption deqPrefetchOption)
+t_Error FM_PORT_ConfigDeqPrefetchOption(
+        t_Handle h_FmPort, e_FmPortDeqPrefetchOption deqPrefetchOption)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
-    p_FmPort->p_FmPortDriverParam->dfltCfg.deq_prefetch_opt = (enum fman_port_deq_prefetch)deqPrefetchOption;
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("not available for Rx ports"));
+    p_FmPort->p_FmPortDriverParam->dfltCfg.deq_prefetch_opt =
+            (enum fman_port_deq_prefetch)deqPrefetchOption;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigBackupPools(t_Handle h_FmPort, t_FmBackupBmPools *p_BackupBmPools)
+t_Error FM_PORT_ConfigBackupPools(t_Handle h_FmPort,
+                                  t_FmBackupBmPools *p_BackupBmPools)
 {
-    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx ports only"));
 
-    p_FmPort->p_FmPortDriverParam->p_BackupBmPools = (t_FmBackupBmPools *)XX_Malloc(sizeof(t_FmBackupBmPools));
+    p_FmPort->p_FmPortDriverParam->p_BackupBmPools =
+            (t_FmBackupBmPools *)XX_Malloc(sizeof(t_FmBackupBmPools));
     if (!p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_BackupBmPools allocation failed"));
-    memcpy(p_FmPort->p_FmPortDriverParam->p_BackupBmPools, p_BackupBmPools, sizeof(t_FmBackupBmPools));
+    memcpy(p_FmPort->p_FmPortDriverParam->p_BackupBmPools, p_BackupBmPools,
+           sizeof(t_FmBackupBmPools));
 
     return E_OK;
 }
@@ -2621,78 +2929,95 @@ t_Error FM_PORT_ConfigDeqByteCnt(t_Handle h_FmPort, uint16_t deqByteCnt)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("not available for Rx ports"));
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.deq_byte_cnt = deqByteCnt;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigBufferPrefixContent(t_Handle h_FmPort, t_FmBufferPrefixContent *p_FmBufferPrefixContent)
+t_Error FM_PORT_ConfigBufferPrefixContent(
+        t_Handle h_FmPort, t_FmBufferPrefixContent *p_FmBufferPrefixContent)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    memcpy(&p_FmPort->p_FmPortDriverParam->bufferPrefixContent, p_FmBufferPrefixContent, sizeof(t_FmBufferPrefixContent));
+    memcpy(&p_FmPort->p_FmPortDriverParam->bufferPrefixContent,
+           p_FmBufferPrefixContent, sizeof(t_FmBufferPrefixContent));
     /* if dataAlign was not initialized by user, we return to driver's default */
     if (!p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign)
-        p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign = DEFAULT_PORT_bufferPrefixContent_dataAlign;
+        p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign =
+                DEFAULT_PORT_bufferPrefixContent_dataAlign;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigCheksumLastBytesIgnore(t_Handle h_FmPort, uint8_t checksumLastBytesIgnore)
+t_Error FM_PORT_ConfigCheksumLastBytesIgnore(t_Handle h_FmPort,
+                                             uint8_t checksumLastBytesIgnore)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    p_FmPort->p_FmPortDriverParam->dfltCfg.checksum_bytes_ignore = checksumLastBytesIgnore;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.checksum_bytes_ignore =
+            checksumLastBytesIgnore;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigCutBytesFromEnd(t_Handle h_FmPort, uint8_t cutBytesFromEnd)
+t_Error FM_PORT_ConfigCutBytesFromEnd(t_Handle h_FmPort,
+                                      uint8_t cutBytesFromEnd)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.rx_cut_end_bytes = cutBytesFromEnd;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmBufPoolDepletion *p_BufPoolDepletion)
+t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort,
+                                    t_FmBufPoolDepletion *p_BufPoolDepletion)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->enBufPoolDepletion = TRUE;
-    memcpy(&p_FmPort->p_FmPortDriverParam->bufPoolDepletion, p_BufPoolDepletion, sizeof(t_FmBufPoolDepletion));
+    memcpy(&p_FmPort->p_FmPortDriverParam->bufPoolDepletion, p_BufPoolDepletion,
+           sizeof(t_FmBufPoolDepletion));
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigObservedPoolDepletion(t_Handle h_FmPort, t_FmPortObservedBufPoolDepletion *p_FmPortObservedBufPoolDepletion)
+t_Error FM_PORT_ConfigObservedPoolDepletion(
+        t_Handle h_FmPort,
+        t_FmPortObservedBufPoolDepletion *p_FmPortObservedBufPoolDepletion)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
     if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for OP ports only"));
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for OP ports only"));
 
     p_FmPort->p_FmPortDriverParam->enBufPoolDepletion = TRUE;
     memcpy(&p_FmPort->p_FmPortDriverParam->bufPoolDepletion,
@@ -2713,9 +3038,11 @@ t_Error FM_PORT_ConfigExtBufPools(t_Handle h_FmPort, t_FmExtPools *p_FmExtPools)
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
     if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for OP ports only"));
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for OP ports only"));
 
-    memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools, p_FmExtPools, sizeof(t_FmExtPools));
+    memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools, p_FmExtPools,
+           sizeof(t_FmExtPools));
 
     return E_OK;
 }
@@ -2726,8 +3053,10 @@ t_Error FM_PORT_ConfigDontReleaseTxBufToBM(t_Handle h_FmPort)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Tx ports only"));
 
     p_FmPort->p_FmPortDriverParam->dontReleaseBuf = TRUE;
 
@@ -2752,38 +3081,44 @@ t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Tx ports"));
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("Not available for Tx ports"));
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.sync_req = syncReq;
 
     return E_OK;
 }
 
-
 t_Error FM_PORT_ConfigFrmDiscardOverride(t_Handle h_FmPort, bool override)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Tx ports"));
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("Not available for Tx ports"));
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.discard_override = override;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort, fmPortFrameErrSelect_t errs)
+t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort,
+                                      fmPortFrameErrSelect_t errs)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-                                                            (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx and offline parsing ports only"));
 
     p_FmPort->p_FmPortDriverParam->errorsToDiscard = errs;
 
@@ -2797,12 +3132,14 @@ t_Error FM_PORT_ConfigDmaSwapData(t_Handle h_FmPort, e_FmDmaSwapOption swapData)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    p_FmPort->p_FmPortDriverParam->dfltCfg.dma_swap_data = (enum fman_port_dma_swap)swapData;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.dma_swap_data =
+            (enum fman_port_dma_swap)swapData;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort, e_FmDmaCacheOption intContextCacheAttr)
+t_Error FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort,
+                                     e_FmDmaCacheOption intContextCacheAttr)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
@@ -2810,12 +3147,13 @@ t_Error FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort, e_FmDmaCacheOption intCo
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.dma_ic_stash_on =
-        (bool)(intContextCacheAttr == e_FM_DMA_STASH);
+            (bool)(intContextCacheAttr == e_FM_DMA_STASH);
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort, e_FmDmaCacheOption headerCacheAttr)
+t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort,
+                                 e_FmDmaCacheOption headerCacheAttr)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
@@ -2823,12 +3161,13 @@ t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort, e_FmDmaCacheOption headerCac
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.dma_header_stash_on =
-        (bool)(headerCacheAttr == e_FM_DMA_STASH);
+            (bool)(headerCacheAttr == e_FM_DMA_STASH);
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmDmaCacheOption scatterGatherCacheAttr)
+t_Error FM_PORT_ConfigDmaScatterGatherAttr(
+        t_Handle h_FmPort, e_FmDmaCacheOption scatterGatherCacheAttr)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
@@ -2836,7 +3175,7 @@ t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmDmaCacheOption
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.dma_sg_stash_on =
-        (bool)(scatterGatherCacheAttr == e_FM_DMA_STASH);
+            (bool)(scatterGatherCacheAttr == e_FM_DMA_STASH);
 
     return E_OK;
 }
@@ -2848,8 +3187,10 @@ t_Error FM_PORT_ConfigDmaWriteOptimize(t_Handle h_FmPort, bool optimize)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_TX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Tx ports"));
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("Not available for Tx ports"));
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.dma_write_optimize = optimize;
 
@@ -2873,15 +3214,18 @@ t_Error FM_PORT_ConfigNoScatherGather(t_Handle h_FmPort, bool noScatherGather)
 }
 #endif /* (DPAA_VERSION >= 11) */
 
-t_Error FM_PORT_ConfigForwardReuseIntContext(t_Handle h_FmPort, bool forwardReuse)
+t_Error FM_PORT_ConfigForwardReuseIntContext(t_Handle h_FmPort,
+                                             bool forwardReuse)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->forwardReuseIntContext = forwardReuse;
 
@@ -2918,48 +3262,60 @@ t_Error FM_PORT_ConfigBCBWorkaround(t_Handle h_FmPort)
 /*       Hidden-DEBUG Only API                      */
 /****************************************************/
 
-t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLevel)
+t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort,
+                                         uint32_t minFillLevel)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Tx ports only"));
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_min_level = minFillLevel;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipelineDepth)
+t_Error FM_PORT_ConfigFifoDeqPipelineDepth(t_Handle h_FmPort,
+                                           uint8_t deqPipelineDepth)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Rx ports"));
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("Not available for Rx ports"));
 
     if (p_FmPort->imEn)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for IM ports!"));
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("Not available for IM ports!"));
 
-    p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth = deqPipelineDepth;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
+            deqPipelineDepth;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComfLevel)
+t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort,
+                                         uint32_t fifoLowComfLevel)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Tx ports only"));
 
-    p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_low_comf_level = fifoLowComfLevel;
+    p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_low_comf_level =
+            fifoLowComfLevel;
 
     return E_OK;
 }
@@ -2970,22 +3326,27 @@ t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.rx_fifo_thr = fifoThreshold;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priElevationLevel)
+t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort,
+                                              uint32_t priElevationLevel)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.rx_pri_elevation = priElevationLevel;
 
@@ -2995,19 +3356,26 @@ t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priEle
 /*       API Run-time Control unit functions        */
 /****************************************************/
 
-t_Error FM_PORT_SetNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfOpenDmas)
+t_Error FM_PORT_SetNumOfOpenDmas(t_Handle h_FmPort,
+                                 t_FmPortRsrc *p_NumOfOpenDmas)
 {
-    t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error     err;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
     if ((!p_NumOfOpenDmas->num) || (p_NumOfOpenDmas->num > MAX_NUM_OF_DMAS))
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas-num can't be larger than %d", MAX_NUM_OF_DMAS));
+        RETURN_ERROR( MAJOR, E_INVALID_VALUE,
+                     ("openDmas-num can't be larger than %d", MAX_NUM_OF_DMAS));
     if (p_NumOfOpenDmas->extra > MAX_NUM_OF_EXTRA_DMAS)
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas-extra can't be larger than %d", MAX_NUM_OF_EXTRA_DMAS));
-    err = FmSetNumOfOpenDmas(p_FmPort->h_Fm, p_FmPort->hardwarePortId, (uint8_t*)&p_NumOfOpenDmas->num, (uint8_t*)&p_NumOfOpenDmas->extra, FALSE);
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("openDmas-extra can't be larger than %d", MAX_NUM_OF_EXTRA_DMAS));
+    err = FmSetNumOfOpenDmas(p_FmPort->h_Fm, p_FmPort->hardwarePortId,
+                             (uint8_t*)&p_NumOfOpenDmas->num,
+                             (uint8_t*)&p_NumOfOpenDmas->extra, FALSE);
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -3018,8 +3386,8 @@ t_Error FM_PORT_SetNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfOpenDma
 
 t_Error FM_PORT_SetNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks)
 {
-    t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error     err;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
@@ -3028,11 +3396,18 @@ t_Error FM_PORT_SetNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks)
     ASSERT_COND(p_FmPort->portType != e_FM_PORT_TYPE_OH_HOST_COMMAND);
 
     if ((!p_NumOfTasks->num) || (p_NumOfTasks->num > MAX_NUM_OF_TASKS))
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("NumOfTasks-num can't be larger than %d", MAX_NUM_OF_TASKS));
+        RETURN_ERROR(
+                MAJOR, E_INVALID_VALUE,
+                ("NumOfTasks-num can't be larger than %d", MAX_NUM_OF_TASKS));
     if (p_NumOfTasks->extra > MAX_NUM_OF_EXTRA_TASKS)
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("NumOfTasks-extra can't be larger than %d", MAX_NUM_OF_EXTRA_TASKS));
-
-    err = FmSetNumOfTasks(p_FmPort->h_Fm, p_FmPort->hardwarePortId, (uint8_t*)&p_NumOfTasks->num, (uint8_t*)&p_NumOfTasks->extra, FALSE);
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("NumOfTasks-extra can't be larger than %d", MAX_NUM_OF_EXTRA_TASKS));
+
+    err = FmSetNumOfTasks(p_FmPort->h_Fm, p_FmPort->hardwarePortId,
+                          (uint8_t*)&p_NumOfTasks->num,
+                          (uint8_t*)&p_NumOfTasks->extra, FALSE);
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -3043,25 +3418,35 @@ t_Error FM_PORT_SetNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks)
 
 t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
 {
-    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error                             err;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
     if (!p_SizeOfFifo->num || (p_SizeOfFifo->num > MAX_PORT_FIFO_SIZE))
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SizeOfFifo-num has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("SizeOfFifo-num has to be in the range of 256 - %d", MAX_PORT_FIFO_SIZE));
     if (p_SizeOfFifo->num % BMI_FIFO_UNITS)
-         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SizeOfFifo-num has to be divisible by %d", BMI_FIFO_UNITS));
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+        RETURN_ERROR(
+                MAJOR, E_INVALID_VALUE,
+                ("SizeOfFifo-num has to be divisible by %d", BMI_FIFO_UNITS));
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
         /* extra FIFO size (allowed only to Rx ports) */
-         if (p_SizeOfFifo->extra % BMI_FIFO_UNITS)
-              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SizeOfFifo-extra has to be divisible by %d", BMI_FIFO_UNITS));
+        if (p_SizeOfFifo->extra % BMI_FIFO_UNITS)
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("SizeOfFifo-extra has to be divisible by %d", BMI_FIFO_UNITS));
     }
     else
         if (p_SizeOfFifo->extra)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" No SizeOfFifo-extra for non Rx ports"));
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                         (" No SizeOfFifo-extra for non Rx ports"));
 
     memcpy(&p_FmPort->fifoBufs, p_SizeOfFifo, sizeof(t_FmPortRsrc));
 
@@ -3070,11 +3455,8 @@ t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    err = FmSetSizeOfFifo(p_FmPort->h_Fm,
-                          p_FmPort->hardwarePortId,
-                          &p_SizeOfFifo->num,
-                          &p_SizeOfFifo->extra,
-                          FALSE);
+    err = FmSetSizeOfFifo(p_FmPort->h_Fm, p_FmPort->hardwarePortId,
+                          &p_SizeOfFifo->num, &p_SizeOfFifo->extra, FALSE);
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -3083,20 +3465,22 @@ t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
 
 uint32_t FM_PORT_GetBufferDataOffset(t_Handle h_FmPort)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE,
+                              0);
 
     return p_FmPort->bufferOffsets.dataOffset;
 }
 
 uint8_t * FM_PORT_GetBufferICInfo(t_Handle h_FmPort, char *p_Data)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE,
+                              NULL);
 
     if (p_FmPort->bufferOffsets.pcdInfoOffset == ILLEGAL_BASE)
         return NULL;
@@ -3106,10 +3490,11 @@ uint8_t * FM_PORT_GetBufferICInfo(t_Handle h_FmPort, char *p_Data)
 
 t_FmPrsResult * FM_PORT_GetBufferPrsResult(t_Handle h_FmPort, char *p_Data)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE,
+                              NULL);
 
     if (p_FmPort->bufferOffsets.prsResultOffset == ILLEGAL_BASE)
         return NULL;
@@ -3119,10 +3504,11 @@ t_FmPrsResult * FM_PORT_GetBufferPrsResult(t_Handle h_FmPort, char *p_Data)
 
 uint64_t * FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE,
+                              NULL);
 
     if (p_FmPort->bufferOffsets.timeStampOffset == ILLEGAL_BASE)
         return NULL;
@@ -3132,10 +3518,11 @@ uint64_t * FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data)
 
 uint8_t * FM_PORT_GetBufferHashResult(t_Handle h_FmPort, char *p_Data)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE,
+                              NULL);
 
     if (p_FmPort->bufferOffsets.hashResultOffset == ILLEGAL_BASE)
         return NULL;
@@ -3157,37 +3544,35 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
     err = fman_port_disable(&p_FmPort->port);
     if (err == -EBUSY)
     {
-        fman_port_enable(&p_FmPort->port);
-        RETURN_ERROR(MINOR, E_BUSY, ("%s: can't disable! BMI or QMI is Busy", p_FmPort->name));
+        DBG(WARNING, ("%s: BMI or QMI is Busy. Port forced down",
+               p_FmPort->name));
+        err = E_OK;
     }
     else if (err != 0)
-    {
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_disable"));
-    }
+        {
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_disable"));
+        }
 
     p_FmPort->enabled = FALSE;
 
     return E_OK;
 }
 
-t_FmPort* opXX;
 t_Error FM_PORT_Enable(t_Handle h_FmPort)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
     int err;
-    if (p_FmPort->portId == 0) // save HC port for DSAR disable
-	opXX = p_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     /* Used by FM_PORT_Free routine as indication
-       if to disable port. Thus set it to TRUE prior
-       to enabling itself. This way if part of enable
-       process fails there will be still things
-       to disable during Free. For example, if BMI
-       enable succeeded but QMI failed, still  BMI
-       needs to be disabled by Free. */
+     if to disable port. Thus set it to TRUE prior
+     to enabling itself. This way if part of enable
+     process fails there will be still things
+     to disable during Free. For example, if BMI
+     enable succeeded but QMI failed, still  BMI
+     needs to be disabled by Free. */
     p_FmPort->enabled = TRUE;
 
     if (p_FmPort->imEn)
@@ -3202,47 +3587,52 @@ t_Error FM_PORT_Enable(t_Handle h_FmPort)
 
 t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
 {
-    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    uint8_t             factor, countUnitBit;
-    uint16_t            baseGran;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    uint8_t factor, countUnitBit;
+    uint16_t baseGran;
     struct fman_port_rate_limiter params;
-    int                 err;
+    int err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_TX):
             baseGran = BMI_RATE_LIMIT_GRAN_TX;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             baseGran = BMI_RATE_LIMIT_GRAN_OP;
-           break;
+            break;
         default:
-           RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx and Offline parsing ports only"));
+            RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                         ("available for Tx and Offline parsing ports only"));
     }
 
-    countUnitBit = (uint8_t)FmGetTimeStampScale(p_FmPort->h_Fm);  /* TimeStamp per nano seconds units */
+    countUnitBit = (uint8_t)FmGetTimeStampScale(p_FmPort->h_Fm); /* TimeStamp per nano seconds units */
     /* normally, we use 1 usec as the reference count */
     factor = 1;
     /* if ratelimit is too small for a 1usec factor, multiply the factor */
-    while (p_RateLimit->rateLimit < baseGran/factor)
+    while (p_RateLimit->rateLimit < baseGran / factor)
     {
-        if (countUnitBit==31)
+        if (countUnitBit == 31)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Rate limit is too small"));
 
         countUnitBit++;
         factor <<= 1;
     }
     /* if ratelimit is too large for a 1usec factor, it is also larger than max rate*/
-    if (p_RateLimit->rateLimit > ((uint32_t)baseGran * (1<<10) * (uint32_t)factor))
+    if (p_RateLimit->rateLimit
+            > ((uint32_t)baseGran * (1 << 10) * (uint32_t)factor))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Rate limit is too large"));
 
-    if (!p_RateLimit->maxBurstSize || (p_RateLimit->maxBurstSize > BMI_RATE_LIMIT_MAX_BURST_SIZE))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                     ("maxBurstSize must be between 1K and %dk", BMI_RATE_LIMIT_MAX_BURST_SIZE));
+    if (!p_RateLimit->maxBurstSize
+            || (p_RateLimit->maxBurstSize > BMI_RATE_LIMIT_MAX_BURST_SIZE))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("maxBurstSize must be between 1K and %dk", BMI_RATE_LIMIT_MAX_BURST_SIZE));
 
     params.count_1micro_bit = (uint8_t)FmGetTimeStampScale(p_FmPort->h_Fm);
     params.high_burst_size_gran = FALSE;
@@ -3254,25 +3644,31 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
     {
 #ifndef FM_NO_ADVANCED_RATE_LIMITER
 
-        if ((p_FmPort->fmRevInfo.majorRev == 4) || (p_FmPort->fmRevInfo.majorRev >= 6))
+        if ((p_FmPort->fmRevInfo.majorRev == 4)
+                || (p_FmPort->fmRevInfo.majorRev >= 6))
         {
             params.high_burst_size_gran = TRUE;
         }
         else
 #endif /* ! FM_NO_ADVANCED_RATE_LIMITER */
         {
-            if (p_RateLimit->rateLimitDivider != e_FM_PORT_DUAL_RATE_LIMITER_NONE)
-                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PORT_ConfigDualRateLimitScaleDown"));
+            if (p_RateLimit->rateLimitDivider
+                    != e_FM_PORT_DUAL_RATE_LIMITER_NONE)
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                             ("FM_PORT_ConfigDualRateLimitScaleDown"));
 
             if (p_RateLimit->maxBurstSize % 1000)
             {
-                p_RateLimit->maxBurstSize = (uint16_t)((p_RateLimit->maxBurstSize/1000)+1);
+                p_RateLimit->maxBurstSize =
+                        (uint16_t)((p_RateLimit->maxBurstSize / 1000) + 1);
                 DBG(WARNING, ("rateLimit.maxBurstSize rounded up to %d", (p_RateLimit->maxBurstSize/1000+1)*1000));
             }
             else
-                p_RateLimit->maxBurstSize = (uint16_t)(p_RateLimit->maxBurstSize/1000);
+                p_RateLimit->maxBurstSize = (uint16_t)(p_RateLimit->maxBurstSize
+                        / 1000);
         }
-        params.rate_factor = (enum fman_port_rate_limiter_scale_down)p_RateLimit->rateLimitDivider;
+        params.rate_factor =
+                (enum fman_port_rate_limiter_scale_down)p_RateLimit->rateLimitDivider;
         params.burst_size = p_RateLimit->maxBurstSize;
     }
 
@@ -3285,17 +3681,17 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
 
 t_Error FM_PORT_DeleteRateLimit(t_Handle h_FmPort)
 {
-    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    int                 err;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    int err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
-       (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-       (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
-                ("available for Tx and Offline parsing ports only"));
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+        RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                     ("available for Tx and Offline parsing ports only"));
 
     err = fman_port_delete_rate_limiter(&p_FmPort->port);
     if (err != 0)
@@ -3303,51 +3699,55 @@ t_Error FM_PORT_DeleteRateLimit(t_Handle h_FmPort)
     return E_OK;
 }
 
-t_Error FM_PORT_SetPfcPrioritiesMappingToQmanWQ(t_Handle h_FmPort, uint8_t prio, uint8_t wq)
+t_Error FM_PORT_SetPfcPrioritiesMappingToQmanWQ(t_Handle h_FmPort, uint8_t prio,
+                                                uint8_t wq)
 {
-    t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
-    uint32_t    tmpReg;
-    uint32_t    wqTmpReg;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t tmpReg;
+    uint32_t wqTmpReg;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX) && (p_FmPort->portType != e_FM_PORT_TYPE_TX_10G))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("PFC mapping is available for Tx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_TX_10G))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("PFC mapping is available for Tx ports only"));
 
     if (prio > 7)
-        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("PFC priority (%d) is out of range (0-7)", prio));
+        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE,
+                     ("PFC priority (%d) is out of range (0-7)", prio));
     if (wq > 7)
-        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("WQ (%d) is out of range (0-7)", wq));
+        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE,
+                     ("WQ (%d) is out of range (0-7)", wq));
 
     tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpfcm[0]);
-    tmpReg &= ~(0xf << ((7-prio)*4));
-    wqTmpReg = ((uint32_t)wq << ((7-prio)*4));
+    tmpReg &= ~(0xf << ((7 - prio) * 4));
+    wqTmpReg = ((uint32_t)wq << ((7 - prio) * 4));
     tmpReg |= wqTmpReg;
 
-    WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpfcm[0], tmpReg);
+    WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpfcm[0],
+                 tmpReg);
 
     return E_OK;
 }
 
 t_Error FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable)
 {
-    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-    int                     err;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    err = fman_port_set_queue_cnt_mode(&p_FmPort->port, enable);
-    if (err != 0)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_set_perf_cnt_mode"));
+    fman_port_set_queue_cnt_mode(&p_FmPort->port, enable);
+
     return E_OK;
 }
 
 t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, bool enable)
 {
-    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-    int                     err;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    int err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
@@ -3358,70 +3758,78 @@ t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, bool enable)
     return E_OK;
 }
 
-t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerformanceCnt *p_FmPortPerformanceCnt)
+t_Error FM_PORT_SetPerformanceCountersParams(
+        t_Handle h_FmPort, t_FmPortPerformanceCnt *p_FmPortPerformanceCnt)
 {
-    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-    struct fman_port_perf_cnt_params    params;
-    int                                 err;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    struct fman_port_perf_cnt_params params;
+    int err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
     /* check parameters */
-    if (!p_FmPortPerformanceCnt->taskCompVal ||
-        (p_FmPortPerformanceCnt->taskCompVal > p_FmPort->tasks.num))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                     ("taskCompVal (%d) has to be in the range of 1 - %d (current value)!",
-                      p_FmPortPerformanceCnt->taskCompVal,
-                      p_FmPort->tasks.num));
-    if (!p_FmPortPerformanceCnt->dmaCompVal ||
-        (p_FmPortPerformanceCnt->dmaCompVal > p_FmPort->openDmas.num))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                     ("dmaCompVal (%d) has to be in the range of 1 - %d (current value)!",
-                      p_FmPortPerformanceCnt->dmaCompVal,
-                      p_FmPort->openDmas.num));
-    if (!p_FmPortPerformanceCnt->fifoCompVal ||
-        (p_FmPortPerformanceCnt->fifoCompVal > p_FmPort->fifoBufs.num))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                     ("fifoCompVal (%d) has to be in the range of 256 - %d (current value)!",
-                      p_FmPortPerformanceCnt->fifoCompVal,
-                      p_FmPort->fifoBufs.num));
+    if (!p_FmPortPerformanceCnt->taskCompVal
+            || (p_FmPortPerformanceCnt->taskCompVal > p_FmPort->tasks.num))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("taskCompVal (%d) has to be in the range of 1 - %d (current value)!", p_FmPortPerformanceCnt->taskCompVal, p_FmPort->tasks.num));
+    if (!p_FmPortPerformanceCnt->dmaCompVal
+            || (p_FmPortPerformanceCnt->dmaCompVal > p_FmPort->openDmas.num))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("dmaCompVal (%d) has to be in the range of 1 - %d (current value)!", p_FmPortPerformanceCnt->dmaCompVal, p_FmPort->openDmas.num));
+    if (!p_FmPortPerformanceCnt->fifoCompVal
+            || (p_FmPortPerformanceCnt->fifoCompVal > p_FmPort->fifoBufs.num))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("fifoCompVal (%d) has to be in the range of 256 - %d (current value)!", p_FmPortPerformanceCnt->fifoCompVal, p_FmPort->fifoBufs.num));
     if (p_FmPortPerformanceCnt->fifoCompVal % BMI_FIFO_UNITS)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                     ("fifoCompVal (%d) has to be divisible by %d",
-                      p_FmPortPerformanceCnt->fifoCompVal,
-                      BMI_FIFO_UNITS));
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("fifoCompVal (%d) has to be divisible by %d", p_FmPortPerformanceCnt->fifoCompVal, BMI_FIFO_UNITS));
 
     switch (p_FmPort->portType)
     {
         case (e_FM_PORT_TYPE_RX_10G):
         case (e_FM_PORT_TYPE_RX):
-            if (!p_FmPortPerformanceCnt->queueCompVal ||
-                (p_FmPortPerformanceCnt->queueCompVal > MAX_PERFORMANCE_RX_QUEUE_COMP))
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                             ("performanceCnt.queueCompVal for Rx has to be in the range of 1 - %d",
-                              MAX_PERFORMANCE_RX_QUEUE_COMP));
+            if (!p_FmPortPerformanceCnt->queueCompVal
+                    || (p_FmPortPerformanceCnt->queueCompVal
+                            > MAX_PERFORMANCE_RX_QUEUE_COMP))
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_VALUE,
+                        ("performanceCnt.queueCompVal for Rx has to be in the range of 1 - %d", MAX_PERFORMANCE_RX_QUEUE_COMP));
             break;
         case (e_FM_PORT_TYPE_TX_10G):
         case (e_FM_PORT_TYPE_TX):
-            if (!p_FmPortPerformanceCnt->queueCompVal ||
-                (p_FmPortPerformanceCnt->queueCompVal > MAX_PERFORMANCE_TX_QUEUE_COMP))
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                             ("performanceCnt.queueCompVal for Tx has to be in the range of 1 - %d",
-                              MAX_PERFORMANCE_TX_QUEUE_COMP));
+            if (!p_FmPortPerformanceCnt->queueCompVal
+                    || (p_FmPortPerformanceCnt->queueCompVal
+                            > MAX_PERFORMANCE_TX_QUEUE_COMP))
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_VALUE,
+                        ("performanceCnt.queueCompVal for Tx has to be in the range of 1 - %d", MAX_PERFORMANCE_TX_QUEUE_COMP));
             break;
         case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
         case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
             if (p_FmPortPerformanceCnt->queueCompVal)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.queueCompVal is not relevant for H/O ports."));
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_VALUE,
+                        ("performanceCnt.queueCompVal is not relevant for H/O ports."));
             break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
     }
 
-    params.task_val     = p_FmPortPerformanceCnt->taskCompVal;
-    params.queue_val    = p_FmPortPerformanceCnt->queueCompVal;
-    params.dma_val      = p_FmPortPerformanceCnt->dmaCompVal;
-    params.fifo_val     = p_FmPortPerformanceCnt->fifoCompVal;
+    params.task_val = p_FmPortPerformanceCnt->taskCompVal;
+    params.queue_val = p_FmPortPerformanceCnt->queueCompVal;
+    params.dma_val = p_FmPortPerformanceCnt->dmaCompVal;
+    params.fifo_val = p_FmPortPerformanceCnt->fifoCompVal;
 
     err = fman_port_set_perf_cnt_params(&p_FmPort->port, &params);
     if (err != 0)
@@ -3432,45 +3840,52 @@ t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerforma
 
 t_Error FM_PORT_AnalyzePerformanceParams(t_Handle h_FmPort)
 {
-    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-    t_FmPortPerformanceCnt  currParams, savedParams;
-    t_Error                 err;
-    bool                    underTest, failed = FALSE;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPortPerformanceCnt currParams, savedParams;
+    t_Error err;
+    bool underTest, failed = FALSE;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
     XX_Print("Analyzing Performance parameters for port (type %d, id%d)\n",
              p_FmPort->portType, p_FmPort->portId);
 
-    currParams.taskCompVal    = (uint8_t)p_FmPort->tasks.num;
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
-        currParams.queueCompVal   = 0;
+    currParams.taskCompVal = (uint8_t)p_FmPort->tasks.num;
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+        currParams.queueCompVal = 0;
     else
-        currParams.queueCompVal   = 1;
-    currParams.dmaCompVal     =(uint8_t) p_FmPort->openDmas.num;
-    currParams.fifoCompVal    = p_FmPort->fifoBufs.num;
+        currParams.queueCompVal = 1;
+    currParams.dmaCompVal = (uint8_t)p_FmPort->openDmas.num;
+    currParams.fifoCompVal = p_FmPort->fifoBufs.num;
 
     FM_PORT_SetPerformanceCounters(p_FmPort, FALSE);
     ClearPerfCnts(p_FmPort);
-    if ((err = FM_PORT_SetPerformanceCountersParams(p_FmPort, &currParams)) != E_OK)
+    if ((err = FM_PORT_SetPerformanceCountersParams(p_FmPort, &currParams))
+            != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
     FM_PORT_SetPerformanceCounters(p_FmPort, TRUE);
     XX_UDelay(1000000);
     FM_PORT_SetPerformanceCounters(p_FmPort, FALSE);
     if (FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_TASK_UTIL))
     {
-        XX_Print ("Max num of defined port tasks (%d) utilized - Please enlarge\n",p_FmPort->tasks.num);
+        XX_Print(
+                "Max num of defined port tasks (%d) utilized - Please enlarge\n",
+                p_FmPort->tasks.num);
         failed = TRUE;
     }
     if (FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_DMA_UTIL))
     {
-        XX_Print ("Max num of defined port openDmas (%d) utilized - Please enlarge\n",p_FmPort->openDmas.num);
+        XX_Print(
+                "Max num of defined port openDmas (%d) utilized - Please enlarge\n",
+                p_FmPort->openDmas.num);
         failed = TRUE;
     }
     if (FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_FIFO_UTIL))
     {
-        XX_Print("Max size of defined port fifo (%d) utilized - Please enlarge\n",p_FmPort->fifoBufs.num);
+        XX_Print(
+                "Max size of defined port fifo (%d) utilized - Please enlarge\n",
+                p_FmPort->fifoBufs.num);
         failed = TRUE;
     }
     if (failed)
@@ -3490,7 +3905,8 @@ t_Error FM_PORT_AnalyzePerformanceParams(t_Handle h_FmPort)
             currParams.dmaCompVal--;
             underTest = TRUE;
         }
-        if ((currParams.fifoCompVal != BMI_FIFO_UNITS) && !savedParams.fifoCompVal)
+        if ((currParams.fifoCompVal != BMI_FIFO_UNITS)
+                && !savedParams.fifoCompVal)
         {
             currParams.fifoCompVal -= BMI_FIFO_UNITS;
             underTest = TRUE;
@@ -3499,29 +3915,35 @@ t_Error FM_PORT_AnalyzePerformanceParams(t_Handle h_FmPort)
             break;
 
         ClearPerfCnts(p_FmPort);
-        if ((err = FM_PORT_SetPerformanceCountersParams(p_FmPort, &currParams)) != E_OK)
+        if ((err = FM_PORT_SetPerformanceCountersParams(p_FmPort, &currParams))
+                != E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
         FM_PORT_SetPerformanceCounters(p_FmPort, TRUE);
         XX_UDelay(1000000);
         FM_PORT_SetPerformanceCounters(p_FmPort, FALSE);
 
-        if (!savedParams.taskCompVal && FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_TASK_UTIL))
-            savedParams.taskCompVal = (uint8_t)(currParams.taskCompVal+2);
-        if (!savedParams.dmaCompVal && FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_DMA_UTIL))
-            savedParams.dmaCompVal = (uint8_t)(currParams.dmaCompVal+2);
-        if (!savedParams.fifoCompVal && FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_FIFO_UTIL))
-            savedParams.fifoCompVal = currParams.fifoCompVal+(2*BMI_FIFO_UNITS);
+        if (!savedParams.taskCompVal
+                && FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_TASK_UTIL))
+            savedParams.taskCompVal = (uint8_t)(currParams.taskCompVal + 2);
+        if (!savedParams.dmaCompVal
+                && FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_DMA_UTIL))
+            savedParams.dmaCompVal = (uint8_t)(currParams.dmaCompVal + 2);
+        if (!savedParams.fifoCompVal
+                && FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_FIFO_UTIL))
+            savedParams.fifoCompVal = currParams.fifoCompVal
+                    + (2 * BMI_FIFO_UNITS);
     }
 
     XX_Print("best vals: tasks %d, dmas %d, fifos %d\n",
-             savedParams.taskCompVal, savedParams.dmaCompVal, savedParams.fifoCompVal);
+             savedParams.taskCompVal, savedParams.dmaCompVal,
+             savedParams.fifoCompVal);
     return E_OK;
 }
 
 t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable)
 {
-    t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
-    int         err;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    int err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
@@ -3534,9 +3956,9 @@ t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable)
 
 t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs)
 {
-    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-    volatile uint32_t       *p_ErrDiscard = NULL;
-    int                     err;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t *p_ErrDiscard = NULL;
+    int err;
 
     UNUSED(p_ErrDiscard);
     err = fman_port_set_err_mask(&p_FmPort->port, (uint32_t)errs);
@@ -3546,40 +3968,49 @@ t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs)
 #ifdef FM_ERROR_VSP_NO_MATCH_SW006
     if (p_FmPort->fmRevInfo.majorRev >= 6)
     {
-        t_FmPcdCtrlParamsPage   *p_ParamsPage;
+        t_FmPcdCtrlParamsPage *p_ParamsPage;
 
-        FmPortSetGprFunc(p_FmPort, e_FM_PORT_GPR_MURAM_PAGE, (void**)&p_ParamsPage);
+        FmPortSetGprFunc(p_FmPort, e_FM_PORT_GPR_MURAM_PAGE,
+                         (void**)&p_ParamsPage);
         ASSERT_COND(p_ParamsPage);
         switch (p_FmPort->portType)
         {
             case (e_FM_PORT_TYPE_RX_10G):
             case (e_FM_PORT_TYPE_RX):
-                p_ErrDiscard = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm;
+                p_ErrDiscard =
+                        &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm;
                 break;
             case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-                p_ErrDiscard = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm;
+                p_ErrDiscard =
+                        &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm;
                 break;
             default:
-               RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+                RETURN_ERROR(
+                        MAJOR, E_INVALID_OPERATION,
+                        ("available for Rx and offline parsing ports only"));
         }
-        WRITE_UINT32(p_ParamsPage->errorsDiscardMask, GET_UINT32(*p_ErrDiscard) | errs);
+        WRITE_UINT32(p_ParamsPage->errorsDiscardMask,
+                     GET_UINT32(*p_ErrDiscard) | errs);
     }
 #endif /* FM_ERROR_VSP_NO_MATCH_SW006 */
 
     return E_OK;
 }
 
-t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enable)
+t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId,
+                                   bool enable)
 {
-    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-    int                     err;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    int err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(poolId<BM_MAX_NUM_OF_POOLS, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx ports only"));
 
     err = fman_port_set_bpool_cnt_mode(&p_FmPort->port, poolId, enable);
     if (err != 0)
@@ -3587,34 +4018,175 @@ t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enabl
     return E_OK;
 }
 
+t_Error FM_PORT_GetBmiCounters(t_Handle h_FmPort, t_FmPortBmiStats *p_BmiStats)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX)
+            || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)){
+        p_BmiStats->cntCycle =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_CYCLE);
+            /* fmbm_rccn */
+        p_BmiStats->cntTaskUtil =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_TASK_UTIL);
+            /* fmbm_rtuc */
+        p_BmiStats->cntQueueUtil =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_QUEUE_UTIL);
+            /* fmbm_rrquc */
+        p_BmiStats->cntDmaUtil =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_DMA_UTIL);
+            /* fmbm_rduc */
+        p_BmiStats->cntFifoUtil =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_FIFO_UTIL);
+            /* fmbm_rfuc */
+        p_BmiStats->cntRxPauseActivation =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION);
+            /* fmbm_rpac */
+        p_BmiStats->cntFrame =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_FRAME);
+            /* fmbm_rfrc */
+        p_BmiStats->cntDiscardFrame =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_DISCARD_FRAME);
+            /* fmbm_rfdc */
+        p_BmiStats->cntDeallocBuf =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_DEALLOC_BUF);
+            /* fmbm_rbdc */
+        p_BmiStats->cntRxBadFrame =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_RX_BAD_FRAME);
+            /* fmbm_rfbc */
+        p_BmiStats->cntRxLargeFrame =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_RX_LARGE_FRAME);
+            /* fmbm_rlfc */
+        p_BmiStats->cntRxFilterFrame =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_RX_FILTER_FRAME);
+            /* fmbm_rffc */
+        p_BmiStats->cntRxListDmaErr =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR);
+            /* fmbm_rfldec */
+        p_BmiStats->cntRxOutOfBuffersDiscard =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD);
+            /* fmbm_rodc */
+        p_BmiStats->cntWredDiscard = 0;
+        p_BmiStats->cntLengthErr = 0;
+        p_BmiStats->cntUnsupportedFormat = 0;
+    }
+    else if ((p_FmPort->portType == e_FM_PORT_TYPE_TX)
+                || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)){
+        p_BmiStats->cntCycle =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_CYCLE);
+            /* fmbm_tccn */
+        p_BmiStats->cntTaskUtil =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_TASK_UTIL);
+            /* fmbm_ttuc */
+        p_BmiStats->cntQueueUtil =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_QUEUE_UTIL);
+            /* fmbm_ttcquc */
+        p_BmiStats->cntDmaUtil =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_DMA_UTIL);
+            /* fmbm_tduc */
+        p_BmiStats->cntFifoUtil =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_FIFO_UTIL);
+            /* fmbm_tfuc */
+        p_BmiStats->cntRxPauseActivation = 0;
+        p_BmiStats->cntFrame =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_FRAME);
+            /* fmbm_tfrc */
+        p_BmiStats->cntDiscardFrame =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_DISCARD_FRAME);
+            /* fmbm_tfdc */
+        p_BmiStats->cntDeallocBuf =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_DEALLOC_BUF);
+            /* fmbm_tbdc */
+        p_BmiStats->cntRxBadFrame = 0;
+        p_BmiStats->cntRxLargeFrame = 0;
+        p_BmiStats->cntRxFilterFrame = 0;
+        p_BmiStats->cntRxListDmaErr = 0;
+        p_BmiStats->cntRxOutOfBuffersDiscard = 0;
+        p_BmiStats->cntWredDiscard = 0;
+        p_BmiStats->cntLengthErr =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_LENGTH_ERR);
+            /* fmbm_tfledc */
+        p_BmiStats->cntUnsupportedFormat =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT);
+            /* fmbm_tfufdc */
+    }
+    else if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) {
+        p_BmiStats->cntCycle =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_CYCLE);
+            /* fmbm_occn */
+        p_BmiStats->cntTaskUtil =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_TASK_UTIL);
+            /* fmbm_otuc */
+        p_BmiStats->cntQueueUtil = 0;
+        p_BmiStats->cntDmaUtil =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_DMA_UTIL);
+            /* fmbm_oduc */
+        p_BmiStats->cntFifoUtil =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_FIFO_UTIL);
+            /* fmbm_ofuc*/
+        p_BmiStats->cntRxPauseActivation = 0;
+        p_BmiStats->cntFrame =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_FRAME);
+            /* fmbm_ofrc */
+        p_BmiStats->cntDiscardFrame =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_DISCARD_FRAME);
+            /* fmbm_ofdc */
+        p_BmiStats->cntDeallocBuf =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_DEALLOC_BUF);
+            /* fmbm_obdc*/
+        p_BmiStats->cntRxBadFrame = 0;
+        p_BmiStats->cntRxLargeFrame = 0;
+        p_BmiStats->cntRxFilterFrame =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_RX_FILTER_FRAME);
+            /* fmbm_offc */
+        p_BmiStats->cntRxListDmaErr =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR);
+            /* fmbm_ofldec */
+        p_BmiStats->cntRxOutOfBuffersDiscard =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD);
+            /* fmbm_rodc */
+        p_BmiStats->cntWredDiscard =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_WRED_DISCARD);
+            /* fmbm_ofwdc */
+        p_BmiStats->cntLengthErr =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_LENGTH_ERR);
+            /* fmbm_ofledc */
+        p_BmiStats->cntUnsupportedFormat =
+            FM_PORT_GetCounter(h_FmPort, e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT);
+            /* fmbm_ofufdc */
+    }
+    return E_OK;
+}
+
 uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
 {
-    t_FmPort                        *p_FmPort = (t_FmPort*)h_FmPort;
-    bool                            bmiCounter = FALSE;
-    enum fman_port_stats_counters   statsType;
-    enum fman_port_perf_counters    perfType;
-    enum fman_port_qmi_counters   queueType;
-    bool                            isStats;
-    t_Error                         errCode;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    bool bmiCounter = FALSE;
+    enum fman_port_stats_counters statsType;
+    enum fman_port_perf_counters perfType;
+    enum fman_port_qmi_counters queueType;
+    bool isStats;
+    t_Error errCode;
 
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
-        case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
-        case(e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
+        case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
+        case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+        case (e_FM_PORT_COUNTERS_DEQ_CONFIRM):
             /* check that counter is available for the port type */
-            if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-               (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+            if ((p_FmPort->portType == e_FM_PORT_TYPE_RX)
+                    || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
             {
                 REPORT_ERROR(MINOR, E_INVALID_STATE,
                         ("Requested counter is not available for Rx ports"));
                 return 0;
             }
             bmiCounter = FALSE;
-        case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+            break;
+        case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
             bmiCounter = FALSE;
             break;
         default: /* BMI counters (or error - will be checked in BMI routine )*/
@@ -3624,7 +4196,8 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
 
     if (bmiCounter)
     {
-        errCode = BmiPortCheckAndGetCounterType(p_FmPort, counter, &statsType, &perfType, &isStats);
+        errCode = BmiPortCheckAndGetCounterType(p_FmPort, counter, &statsType,
+                                                &perfType, &isStats);
         if (errCode != E_OK)
         {
             REPORT_ERROR(MINOR, errCode, NO_MSG);
@@ -3638,7 +4211,8 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
     else /* QMI counter */
     {
         /* check that counters are enabled */
-        if (!(GET_UINT32(p_FmPort->port.qmi_regs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
+        if (!(GET_UINT32(p_FmPort->port.qmi_regs->fmqm_pnc)
+                & QMI_PORT_CFG_EN_COUNTERS))
 
         {
             REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
@@ -3648,21 +4222,20 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
         /* Set counter */
         switch (counter)
         {
-           case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+            case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
                 queueType = E_FMAN_PORT_ENQ_TOTAL;
-               break;
-            case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+                break;
+            case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
                 queueType = E_FMAN_PORT_DEQ_TOTAL;
-               break;
-            case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+                break;
+            case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
                 queueType = E_FMAN_PORT_DEQ_FROM_DFLT;
-               break;
-            case(e_FM_PORT_COUNTERS_DEQ_CONFIRM):
+                break;
+            case (e_FM_PORT_COUNTERS_DEQ_CONFIRM):
                 queueType = E_FMAN_PORT_DEQ_CONFIRM;
-               break;
+                break;
             default:
-               REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available"));
-               return 0;
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available"));
         }
 
         return fman_port_get_qmi_counter(&p_FmPort->port, queueType);
@@ -3671,29 +4244,32 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
     return 0;
 }
 
-t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint32_t value)
+t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter,
+                              uint32_t value)
 {
-    t_FmPort                        *p_FmPort = (t_FmPort*)h_FmPort;
-    bool                            bmiCounter = FALSE;
-    enum fman_port_stats_counters   statsType;
-    enum fman_port_perf_counters    perfType;
-    enum fman_port_qmi_counters   queueType;
-    bool                            isStats;
-    t_Error                         errCode;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    bool bmiCounter = FALSE;
+    enum fman_port_stats_counters statsType;
+    enum fman_port_perf_counters perfType;
+    enum fman_port_qmi_counters queueType;
+    bool isStats;
+    t_Error errCode;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
-        case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
-        case(e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
+        case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
+        case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+        case (e_FM_PORT_COUNTERS_DEQ_CONFIRM):
             /* check that counter is available for the port type */
-            if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-               (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
-                        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
-        case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+            if ((p_FmPort->portType == e_FM_PORT_TYPE_RX)
+                    || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+                RETURN_ERROR(
+                        MINOR, E_INVALID_STATE,
+                        ("Requested counter is not available for Rx ports"));
+        case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
             bmiCounter = FALSE;
             break;
         default: /* BMI counters (or error - will be checked in BMI routine )*/
@@ -3703,7 +4279,8 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
 
     if (bmiCounter)
     {
-        errCode = BmiPortCheckAndGetCounterType(p_FmPort, counter, &statsType, &perfType, &isStats);
+        errCode = BmiPortCheckAndGetCounterType(p_FmPort, counter, &statsType,
+                                                &perfType, &isStats);
         if (errCode != E_OK)
         {
             RETURN_ERROR(MINOR, errCode, NO_MSG);
@@ -3716,28 +4293,31 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
     else /* QMI counter */
     {
         /* check that counters are enabled */
-        if (!(GET_UINT32(p_FmPort->port.qmi_regs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
+        if (!(GET_UINT32(p_FmPort->port.qmi_regs->fmqm_pnc)
+                & QMI_PORT_CFG_EN_COUNTERS))
         {
-            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            RETURN_ERROR(MINOR, E_INVALID_STATE,
+                         ("Requested counter was not enabled"));
         }
 
         /* Set counter */
         switch (counter)
         {
-           case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+            case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
                 queueType = E_FMAN_PORT_ENQ_TOTAL;
-               break;
-            case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+                break;
+            case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
                 queueType = E_FMAN_PORT_DEQ_TOTAL;
-               break;
-            case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+                break;
+            case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
                 queueType = E_FMAN_PORT_DEQ_FROM_DFLT;
-               break;
-            case(e_FM_PORT_COUNTERS_DEQ_CONFIRM):
+                break;
+            case (e_FM_PORT_COUNTERS_DEQ_CONFIRM):
                 queueType = E_FMAN_PORT_DEQ_CONFIRM;
-               break;
+                break;
             default:
-               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available"));
+                RETURN_ERROR(MINOR, E_INVALID_STATE,
+                             ("Requested counter is not available"));
         }
 
         fman_port_set_qmi_counter(&p_FmPort->port, queueType, value);
@@ -3746,15 +4326,15 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
     return E_OK;
 }
 
-
 uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId)
 {
-    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX)
+            && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
         REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
         return 0;
@@ -3762,27 +4342,31 @@ uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId)
     return fman_port_get_bpool_counter(&p_FmPort->port, poolId);
 }
 
-t_Error FM_PORT_ModifyAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, uint32_t value)
+t_Error FM_PORT_ModifyAllocBufCounter(t_Handle h_FmPort, uint8_t poolId,
+                                      uint32_t value)
 {
-    t_FmPort        *p_FmPort = (t_FmPort *)h_FmPort;
+    t_FmPort *p_FmPort = (t_FmPort *)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
-        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX)
+            && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+        RETURN_ERROR( MINOR, E_INVALID_STATE,
+                     ("Requested counter is not available for non-Rx ports"));
 
     fman_port_set_bpool_counter(&p_FmPort->port, poolId, value);
     return E_OK;
 }
 bool FM_PORT_IsStalled(t_Handle h_FmPort)
 {
-    t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error     err;
-    bool        isStalled;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err;
+    bool isStalled;
 
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, FALSE);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, FALSE);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE,
+                              FALSE);
 
     err = FmIsPortStalled(p_FmPort->h_Fm, p_FmPort->hardwarePortId, &isStalled);
     if (err != E_OK)
@@ -3795,7 +4379,7 @@ bool FM_PORT_IsStalled(t_Handle h_FmPort)
 
 t_Error FM_PORT_ReleaseStalled(t_Handle h_FmPort)
 {
-    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
@@ -3811,18 +4395,19 @@ t_Error FM_PORT_SetRxL4ChecksumVerify(t_Handle h_FmPort, bool l4Checksum)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx ports only"));
 
     if (l4Checksum)
-        err = fman_port_modify_rx_fd_bits(&p_FmPort->port,
-                                          (uint8_t)(BMI_PORT_RFNE_FRWD_DCL4C >> 24),
-                                          TRUE);
+        err = fman_port_modify_rx_fd_bits(
+                &p_FmPort->port, (uint8_t)(BMI_PORT_RFNE_FRWD_DCL4C >> 24),
+                TRUE);
     else
-        err = fman_port_modify_rx_fd_bits(&p_FmPort->port,
-                                          (uint8_t)(BMI_PORT_RFNE_FRWD_DCL4C >> 24),
-                                          FALSE);
+        err = fman_port_modify_rx_fd_bits(
+                &p_FmPort->port, (uint8_t)(BMI_PORT_RFNE_FRWD_DCL4C >> 24),
+                FALSE);
     if (err != 0)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_modify_rx_fd_bits"));
 
@@ -3836,86 +4421,91 @@ t_Error FM_PORT_SetRxL4ChecksumVerify(t_Handle h_FmPort, bool l4Checksum)
 #if (DPAA_VERSION >= 11)
 t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_VSPParams)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error                     err = E_OK;
-    volatile uint32_t           *p_BmiStorageProfileId = NULL, *p_BmiVspe = NULL;
-    uint32_t                    tmpReg = 0, tmp = 0;
-    uint16_t                    hwStoragePrflId;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err = E_OK;
+    volatile uint32_t *p_BmiStorageProfileId = NULL, *p_BmiVspe = NULL;
+    uint32_t tmpReg = 0, tmp = 0;
+    uint16_t hwStoragePrflId;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->h_Fm, E_INVALID_HANDLE);
     /*for numOfProfiles = 0 don't call this function*/
     SANITY_CHECK_RETURN_ERROR(p_VSPParams->numOfProfiles, E_INVALID_VALUE);
     /*dfltRelativeId should be in the range of numOfProfiles*/
-    SANITY_CHECK_RETURN_ERROR(IN_RANGE(0, p_VSPParams->dfltRelativeId, (p_VSPParams->numOfProfiles - 1)), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(
+            p_VSPParams->dfltRelativeId < p_VSPParams->numOfProfiles,
+            E_INVALID_VALUE);
     /*p_FmPort should be from Rx type or OP*/
-    SANITY_CHECK_RETURN_ERROR(((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
-                               (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-                               (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(
+            ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)),
+            E_INVALID_VALUE);
     /*port should be disabled*/
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->enabled, E_INVALID_STATE);
     /*if its called for Rx port relevant Tx Port should be passed (initialized) too and it should be disabled*/
-    SANITY_CHECK_RETURN_ERROR(((p_VSPParams->h_FmTxPort &&
-                                !((t_FmPort *)(p_VSPParams->h_FmTxPort))->enabled) ||
-                               (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(
+            ((p_VSPParams->h_FmTxPort && !((t_FmPort *)(p_VSPParams->h_FmTxPort))->enabled) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)),
+            E_INVALID_VALUE);
     /*should be called before SetPCD - this port should be without PCD*/
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->pcdEngines, E_INVALID_STATE);
 
     /*alloc window of VSPs for this port*/
-    err = FmVSPAllocForPort(p_FmPort->h_Fm,
-                            p_FmPort->portType,
-                            p_FmPort->portId,
-                            p_VSPParams->numOfProfiles);
+    err = FmVSPAllocForPort(p_FmPort->h_Fm, p_FmPort->portType,
+                            p_FmPort->portId, p_VSPParams->numOfProfiles);
     if (err != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /*get absolute VSP ID for dfltRelative*/
-    err = FmVSPGetAbsoluteProfileId(p_FmPort->h_Fm,
-                                    p_FmPort->portType,
+    err = FmVSPGetAbsoluteProfileId(p_FmPort->h_Fm, p_FmPort->portType,
                                     p_FmPort->portId,
                                     p_VSPParams->dfltRelativeId,
                                     &hwStoragePrflId);
     if (err != E_OK)
-        RETURN_ERROR(MAJOR, err,NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /*fill relevant registers for p_FmPort and relative TxPort in the case p_FmPort from Rx type*/
     switch (p_FmPort->portType)
     {
         case (e_FM_PORT_TYPE_RX_10G):
         case (e_FM_PORT_TYPE_RX):
-            p_BmiStorageProfileId = &(((t_FmPort *)(p_VSPParams->h_FmTxPort))->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfqid);
-            p_BmiVspe = &(((t_FmPort *)(p_VSPParams->h_FmTxPort))->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tfne);
+            p_BmiStorageProfileId =
+                    &(((t_FmPort *)(p_VSPParams->h_FmTxPort))->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfqid);
+            p_BmiVspe =
+                    &(((t_FmPort *)(p_VSPParams->h_FmTxPort))->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tfne);
 
             tmpReg = GET_UINT32(*p_BmiStorageProfileId) & ~BMI_SP_ID_MASK;
-            tmpReg |= (uint32_t)hwStoragePrflId<<BMI_SP_ID_SHIFT;
+            tmpReg |= (uint32_t)hwStoragePrflId << BMI_SP_ID_SHIFT;
             WRITE_UINT32(*p_BmiStorageProfileId, tmpReg);
 
             tmpReg = GET_UINT32(*p_BmiVspe);
             WRITE_UINT32(*p_BmiVspe, tmpReg | BMI_SP_EN);
 
-            p_BmiStorageProfileId = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfqid;
+            p_BmiStorageProfileId =
+                    &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfqid;
             p_BmiVspe = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpp;
             hwStoragePrflId = p_VSPParams->dfltRelativeId;
             break;
 
         case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             tmpReg = NIA_ENG_BMI | NIA_BMI_AC_FETCH_ALL_FRAME;
-            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn,tmpReg);
+            WRITE_UINT32( p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn,
+                         tmpReg);
 
-            p_BmiStorageProfileId = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofqid;
+            p_BmiStorageProfileId =
+                    &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofqid;
             p_BmiVspe = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opp;
             tmp |= BMI_EBD_EN;
             break;
 
         default:
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+            RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                         ("available for Rx and offline parsing ports only"));
     }
 
     p_FmPort->vspe = TRUE;
     p_FmPort->dfltRelativeId = p_VSPParams->dfltRelativeId;
 
     tmpReg = GET_UINT32(*p_BmiStorageProfileId) & ~BMI_SP_ID_MASK;
-    tmpReg |= (uint32_t)hwStoragePrflId<<BMI_SP_ID_SHIFT;
+    tmpReg |= (uint32_t)hwStoragePrflId << BMI_SP_ID_SHIFT;
     WRITE_UINT32(*p_BmiStorageProfileId, tmpReg);
 
     tmpReg = GET_UINT32(*p_BmiVspe);
@@ -3926,21 +4516,22 @@ t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_VSPParams)
 
 t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error                     err = E_OK;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err = E_OK;
 
     p_FmPort->h_FmPcd = FmGetPcdHandle(p_FmPort->h_Fm);
     ASSERT_COND(p_FmPort->h_FmPcd);
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-         DBG(TRACE, ("FM Port Try Lock - BUSY"));
-         return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("FM Port Try Lock - BUSY"));
+        return ERROR_CODE(E_BUSY);
     }
 
     if (numOfProfiles)
     {
-        err = FmPcdPlcrAllocProfiles(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, numOfProfiles);
+        err = FmPcdPlcrAllocProfiles(p_FmPort->h_FmPcd,
+                                     p_FmPort->hardwarePortId, numOfProfiles);
         if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
@@ -3954,13 +4545,13 @@ t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles)
 
 t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error                     err = E_OK;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err = E_OK;
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-         DBG(TRACE, ("FM Port Try Lock - BUSY"));
-         return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("FM Port Try Lock - BUSY"));
+        return ERROR_CODE(E_BUSY);
     }
 
     err = FmPcdPlcrFreeProfiles(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId);
@@ -3968,24 +4559,26 @@ t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort)
     RELEASE_LOCK(p_FmPort->lock);
 
     if (err)
-        RETURN_ERROR(MAJOR, err,NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
     return E_OK;
 }
 
-t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSelect *p_FmPcdKgScheme)
+t_Error FM_PORT_PcdKgModifyInitialScheme(t_Handle h_FmPort,
+                                         t_FmPcdKgSchemeSelect *p_FmPcdKgScheme)
 {
-    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-    volatile uint32_t       *p_BmiHpnia = NULL;
-    uint32_t                tmpReg;
-    uint8_t                 relativeSchemeId;
-    uint8_t                 physicalSchemeId;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t *p_BmiHpnia = NULL;
+    uint32_t tmpReg;
+    uint8_t relativeSchemeId;
+    uint8_t physicalSchemeId;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG , E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG,
+                              E_INVALID_STATE);
 
-    tmpReg = (uint32_t)((p_FmPort->pcdEngines & FM_PCD_CC)? NIA_KG_CC_EN:0);
+    tmpReg = (uint32_t)((p_FmPort->pcdEngines & FM_PCD_CC) ? NIA_KG_CC_EN : 0);
     switch (p_FmPort->portType)
     {
         case (e_FM_PORT_TYPE_RX_10G):
@@ -3996,13 +4589,14 @@ t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSele
             p_BmiHpnia = &p_FmPort->port.bmi_regs->oh.fmbm_ofpne;
             break;
         default:
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+            RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                         ("available for Rx and offline parsing ports only"));
     }
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-         DBG(TRACE, ("FM Port Try Lock - BUSY"));
-         return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("FM Port Try Lock - BUSY"));
+        return ERROR_CODE(E_BUSY);
     }
 
     /* if we want to change to direct scheme, we need to check that this scheme is valid */
@@ -4010,50 +4604,65 @@ t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSele
     {
         physicalSchemeId = FmPcdKgGetSchemeId(p_FmPcdKgScheme->h_DirectScheme);
         /* check that this scheme is bound to this port */
-        if (!(p_FmPort->schemesPerPortVector &  (uint32_t)(1 << (31 - (uint32_t)physicalSchemeId))))
+        if (!(p_FmPort->schemesPerPortVector
+                & (uint32_t)(1 << (31 - (uint32_t)physicalSchemeId))))
         {
             RELEASE_LOCK(p_FmPort->lock);
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("called with a scheme that is not bound to this port"));
+            RETURN_ERROR(
+                    MAJOR, E_INVALID_STATE,
+                    ("called with a scheme that is not bound to this port"));
         }
 
-        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPort->h_FmPcd, physicalSchemeId);
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPort->h_FmPcd,
+                                                      physicalSchemeId);
         if (relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
         {
             RELEASE_LOCK(p_FmPort->lock);
-            RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("called with invalid Scheme "));
+            RETURN_ERROR(MAJOR, E_NOT_IN_RANGE,
+                         ("called with invalid Scheme "));
         }
 
         if (!FmPcdKgIsSchemeValidSw(p_FmPcdKgScheme->h_DirectScheme))
         {
             RELEASE_LOCK(p_FmPort->lock);
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("called with uninitialized Scheme "));
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                         ("called with uninitialized Scheme "));
         }
 
-        WRITE_UINT32(*p_BmiHpnia, NIA_ENG_KG | tmpReg | NIA_KG_DIRECT | (uint32_t)physicalSchemeId);
+        WRITE_UINT32(
+                *p_BmiHpnia,
+                NIA_ENG_KG | tmpReg | NIA_KG_DIRECT | (uint32_t)physicalSchemeId);
     }
-    else /* change to indirect scheme */
+    else
+        /* change to indirect scheme */
         WRITE_UINT32(*p_BmiHpnia, NIA_ENG_KG | tmpReg);
     RELEASE_LOCK(p_FmPort->lock);
 
     return E_OK;
 }
 
-t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_Profile)
+t_Error FM_PORT_PcdPlcrModifyInitialProfile(t_Handle h_FmPort,
+                                            t_Handle h_Profile)
 {
-    t_FmPort                        *p_FmPort = (t_FmPort*)h_FmPort;
-    volatile uint32_t               *p_BmiNia;
-    volatile uint32_t               *p_BmiHpnia;
-    uint32_t                        tmpReg;
-    uint16_t                        absoluteProfileId = FmPcdPlcrProfileGetAbsoluteId(h_Profile);
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t *p_BmiNia;
+    volatile uint32_t *p_BmiHpnia;
+    uint32_t tmpReg;
+    uint16_t absoluteProfileId = FmPcdPlcrProfileGetAbsoluteId(h_Profile);
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_PLCR , E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_PLCR,
+                              E_INVALID_STATE);
 
     /* check relevance of this routine  - only when policer is used
-    directly after BMI or Parser */
-    if ((p_FmPort->pcdEngines & FM_PCD_KG) || (p_FmPort->pcdEngines & FM_PCD_CC))
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("relevant only when PCD support mode is e_FM_PCD_SUPPORT_PLCR_ONLY or e_FM_PCD_SUPPORT_PRS_AND_PLCR"));
+     directly after BMI or Parser */
+    if ((p_FmPort->pcdEngines & FM_PCD_KG)
+            || (p_FmPort->pcdEngines & FM_PCD_CC))
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_STATE,
+                ("relevant only when PCD support mode is e_FM_PCD_SUPPORT_PLCR_ONLY or e_FM_PCD_SUPPORT_PRS_AND_PLCR"));
 
     switch (p_FmPort->portType)
     {
@@ -4069,13 +4678,14 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
             tmpReg = 0;
             break;
         default:
-           RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+            RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                         ("available for Rx and offline parsing ports only"));
     }
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-         DBG(TRACE, ("FM Port Try Lock - BUSY"));
-         return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("FM Port Try Lock - BUSY"));
+        return ERROR_CODE(E_BUSY);
     }
 
     if (!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
@@ -4084,7 +4694,7 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Invalid profile"));
     }
 
-    tmpReg = (uint32_t)(NIA_ENG_PLCR | NIA_PLCR_ABSOLUTE | absoluteProfileId);
+    tmpReg |= (uint32_t)(NIA_ENG_PLCR | NIA_PLCR_ABSOLUTE | absoluteProfileId);
 
     if (p_FmPort->pcdEngines & FM_PCD_PRS) /* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
     {
@@ -4097,24 +4707,24 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
         tmpReg |= (GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK);
         /* update BMI NIA */
         WRITE_UINT32(*p_BmiNia, tmpReg);
-    }
-    RELEASE_LOCK(p_FmPort->lock);
+    }RELEASE_LOCK(p_FmPort->lock);
 
     return E_OK;
 }
 
-t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
+t_Error FM_PORT_PcdCcModifyTree(t_Handle h_FmPort, t_Handle h_CcTree)
 {
-    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error                             err = E_OK;
-    volatile uint32_t                   *p_BmiCcBase=NULL;
-    volatile uint32_t                   *p_BmiNia=NULL;
-    uint32_t                            ccTreePhysOffset;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err = E_OK;
+    volatile uint32_t *p_BmiCcBase = NULL;
+    volatile uint32_t *p_BmiNia = NULL;
+    uint32_t ccTreePhysOffset;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_VALUE);
 
     if (p_FmPort->imEn)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independent mode ports only"));
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for non-independent mode ports only"));
 
     /* get PCD registers pointers */
     switch (p_FmPort->portType)
@@ -4127,27 +4737,38 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
             p_BmiNia = &p_FmPort->port.bmi_regs->oh.fmbm_ofne;
             break;
         default:
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+            RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                         ("available for Rx and offline parsing ports only"));
     }
 
     /* check that current NIA is BMI to BMI */
-    if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd))
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
+    if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK)
+            != GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd))
+        RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                     ("may be called only for ports in BMI-to-BMI state."));
 
     if (p_FmPort->pcdEngines & FM_PCD_CC)
     {
         if (p_FmPort->h_IpReassemblyManip)
         {
-            err = FmPcdCcTreeAddIPR(p_FmPort->h_FmPcd,
-                                    h_CcTree,
-                                    NULL,
-                                    p_FmPort->h_IpReassemblyManip,
-                                    FALSE);
+            err = FmPcdCcTreeAddIPR(p_FmPort->h_FmPcd, h_CcTree, NULL,
+                                    p_FmPort->h_IpReassemblyManip, FALSE);
             if (err != E_OK)
             {
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             }
         }
+        else
+            if (p_FmPort->h_CapwapReassemblyManip)
+            {
+                err = FmPcdCcTreeAddCPR(p_FmPort->h_FmPcd, h_CcTree, NULL,
+                                        p_FmPort->h_CapwapReassemblyManip,
+                                        FALSE);
+                if (err != E_OK)
+                {
+                    RETURN_ERROR(MAJOR, err, NO_MSG);
+                }
+            }
         switch (p_FmPort->portType)
         {
             case (e_FM_PORT_TYPE_RX_10G):
@@ -4163,49 +4784,52 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
 
         if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
         {
-             DBG(TRACE, ("FM Port Try Lock - BUSY"));
-             return ERROR_CODE(E_BUSY);
+            DBG(TRACE, ("FM Port Try Lock - BUSY"));
+            return ERROR_CODE(E_BUSY);
         }
-        err = FmPcdCcBindTree(p_FmPort->h_FmPcd, NULL, h_CcTree, &ccTreePhysOffset, h_FmPort);
+        err = FmPcdCcBindTree(p_FmPort->h_FmPcd, NULL, h_CcTree,
+                              &ccTreePhysOffset, h_FmPort);
         if (err)
         {
             RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, err, NO_MSG);
-        }
-        WRITE_UINT32(*p_BmiCcBase, ccTreePhysOffset);
+        }WRITE_UINT32(*p_BmiCcBase, ccTreePhysOffset);
 
         p_FmPort->ccTreeId = h_CcTree;
         RELEASE_LOCK(p_FmPort->lock);
     }
     else
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Coarse Classification not defined for this port."));
+        RETURN_ERROR( MAJOR, E_INVALID_STATE,
+                     ("Coarse Classification not defined for this port."));
 
     return E_OK;
 }
 
 t_Error FM_PORT_AttachPCD(t_Handle h_FmPort)
 {
-    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error         err = E_OK;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if (p_FmPort->imEn)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independent mode ports only"));
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for non-independent mode ports only"));
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx and offline parsing ports only"));
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-         DBG(TRACE, ("FM Port Try Lock - BUSY"));
-         return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("FM Port Try Lock - BUSY"));
+        return ERROR_CODE(E_BUSY);
     }
 
-    if (p_FmPort->h_IpReassemblyTree)
+    if (p_FmPort->h_ReassemblyTree)
         p_FmPort->pcdEngines |= FM_PCD_CC;
 
     err = AttachPCD(h_FmPort);
@@ -4216,24 +4840,26 @@ t_Error FM_PORT_AttachPCD(t_Handle h_FmPort)
 
 t_Error FM_PORT_DetachPCD(t_Handle h_FmPort)
 {
-    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error         err = E_OK;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if (p_FmPort->imEn)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independent mode ports only"));
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for non-independent mode ports only"));
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx and offline parsing ports only"));
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-         DBG(TRACE, ("FM Port Try Lock - BUSY"));
-         return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("FM Port Try Lock - BUSY"));
+        return ERROR_CODE(E_BUSY);
     }
 
     err = DetachPCD(h_FmPort);
@@ -4243,7 +4869,7 @@ t_Error FM_PORT_DetachPCD(t_Handle h_FmPort)
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    if (p_FmPort->h_IpReassemblyTree)
+    if (p_FmPort->h_ReassemblyTree)
         p_FmPort->pcdEngines &= ~FM_PCD_CC;
     RELEASE_LOCK(p_FmPort->lock);
 
@@ -4252,28 +4878,30 @@ t_Error FM_PORT_DetachPCD(t_Handle h_FmPort)
 
 t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
 {
-    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error                 err = E_OK;
-    t_FmPortPcdParams       modifiedPcdParams, *p_PcdParams;
-    t_FmPcdCcTreeParams     *p_FmPcdCcTreeParams;
-    t_FmPortPcdCcParams     fmPortPcdCcParams;
-    t_FmPortGetSetCcParams  fmPortGetSetCcParams;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err = E_OK;
+    t_FmPortPcdParams modifiedPcdParams, *p_PcdParams;
+    t_FmPcdCcTreeParams *p_FmPcdCcTreeParams;
+    t_FmPortPcdCcParams fmPortPcdCcParams;
+    t_FmPortGetSetCcParams fmPortGetSetCcParams;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if (p_FmPort->imEn)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independent mode ports only"));
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for non-independent mode ports only"));
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx and offline parsing ports only"));
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-         DBG(TRACE, ("FM Port Try Lock - BUSY"));
-         return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("FM Port Try Lock - BUSY"));
+        return ERROR_CODE(E_BUSY);
     }
 
     p_FmPort->h_FmPcd = FmGetPcdHandle(p_FmPort->h_Fm);
@@ -4281,76 +4909,115 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
 
     memcpy(&modifiedPcdParams, p_PcdParam, sizeof(t_FmPortPcdParams));
     p_PcdParams = &modifiedPcdParams;
-    if (p_PcdParams->h_IpReassemblyManip)
-    {
-        if ((p_PcdParams->pcdSupport != e_FM_PORT_PCD_SUPPORT_PRS_AND_KG) &&
-            (p_PcdParams->pcdSupport != e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC) &&
-            (p_PcdParams->pcdSupport != e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR) &&
-            (p_PcdParams->pcdSupport != e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR))
+    if ((p_PcdParams->h_IpReassemblyManip)
+#if (DPAA_VERSION >= 11)
+            || (p_PcdParams->h_CapwapReassemblyManip)
+#endif /* (DPAA_VERSION >= 11) */
+            )
+    {
+        if ((p_PcdParams->pcdSupport != e_FM_PORT_PCD_SUPPORT_PRS_AND_KG)
+                && (p_PcdParams->pcdSupport
+                        != e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC)
+                && (p_PcdParams->pcdSupport
+                        != e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR)
+                && (p_PcdParams->pcdSupport
+                        != e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR))
         {
             RELEASE_LOCK(p_FmPort->lock);
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("pcdSupport must have KG for supporting IPR"));
+            RETURN_ERROR( MAJOR, E_INVALID_STATE,
+                         ("pcdSupport must have KG for supporting Reassembly"));
         }
         p_FmPort->h_IpReassemblyManip = p_PcdParams->h_IpReassemblyManip;
+#if (DPAA_VERSION >= 11)
+        if ((p_PcdParams->h_IpReassemblyManip)
+                && (p_PcdParams->h_CapwapReassemblyManip))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                         ("Either IP-R or CAPWAP-R is allowed"));
+        if ((p_PcdParams->h_CapwapReassemblyManip)
+                && (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                         ("CAPWAP-R is allowed only on offline-port"));
+        if (p_PcdParams->h_CapwapReassemblyManip)
+            p_FmPort->h_CapwapReassemblyManip =
+                    p_PcdParams->h_CapwapReassemblyManip;
+#endif /* (DPAA_VERSION >= 11) */
+
         if (!p_PcdParams->p_CcParams)
         {
-            if (!((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_KG) ||
-                  (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR)))
+            if (!((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_KG)
+                    || (p_PcdParams->pcdSupport
+                            == e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR)))
             {
                 RELEASE_LOCK(p_FmPort->lock);
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PCD initialization structure is not consistent with pcdSupport"));
+                RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_STATE,
+                        ("PCD initialization structure is not consistent with pcdSupport"));
             }
 
             /* No user-tree, need to build internal tree */
-            p_FmPcdCcTreeParams = (t_FmPcdCcTreeParams*)XX_Malloc(sizeof(t_FmPcdCcTreeParams));
+            p_FmPcdCcTreeParams = (t_FmPcdCcTreeParams*)XX_Malloc(
+                    sizeof(t_FmPcdCcTreeParams));
             if (!p_FmPcdCcTreeParams)
                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_FmPcdCcTreeParams"));
             memset(p_FmPcdCcTreeParams, 0, sizeof(t_FmPcdCcTreeParams));
             p_FmPcdCcTreeParams->h_NetEnv = p_PcdParams->h_NetEnv;
-            p_FmPort->h_IpReassemblyTree = FM_PCD_CcRootBuild(p_FmPort->h_FmPcd, p_FmPcdCcTreeParams);
+            p_FmPort->h_ReassemblyTree = FM_PCD_CcRootBuild(
+                    p_FmPort->h_FmPcd, p_FmPcdCcTreeParams);
 
-            if (!p_FmPort->h_IpReassemblyTree)
+            if (!p_FmPort->h_ReassemblyTree)
             {
                 RELEASE_LOCK(p_FmPort->lock);
                 XX_Free(p_FmPcdCcTreeParams);
-                RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM_PCD_CcBuildTree for IPR failed"));
+                RETURN_ERROR( MAJOR, E_INVALID_HANDLE,
+                             ("FM_PCD_CcBuildTree for Reassembly failed"));
             }
             if (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_KG)
-                p_PcdParams->pcdSupport = e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC;
+                p_PcdParams->pcdSupport =
+                        e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC;
             else
-                p_PcdParams->pcdSupport = e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR;
+                p_PcdParams->pcdSupport =
+                        e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR;
 
             memset(&fmPortPcdCcParams, 0, sizeof(t_FmPortPcdCcParams));
-            fmPortPcdCcParams.h_CcTree = p_FmPort->h_IpReassemblyTree;
+            fmPortPcdCcParams.h_CcTree = p_FmPort->h_ReassemblyTree;
             p_PcdParams->p_CcParams = &fmPortPcdCcParams;
             XX_Free(p_FmPcdCcTreeParams);
         }
 
-        err = FmPcdCcTreeAddIPR(p_FmPort->h_FmPcd,
-                                p_PcdParams->p_CcParams->h_CcTree,
-                                p_PcdParams->h_NetEnv,
-                                p_FmPort->h_IpReassemblyManip,
-                                TRUE);
+        if (p_FmPort->h_IpReassemblyManip)
+            err = FmPcdCcTreeAddIPR(p_FmPort->h_FmPcd,
+                                    p_PcdParams->p_CcParams->h_CcTree,
+                                    p_PcdParams->h_NetEnv,
+                                    p_FmPort->h_IpReassemblyManip, TRUE);
+#if (DPAA_VERSION >= 11)
+        else
+            if (p_FmPort->h_CapwapReassemblyManip)
+                err = FmPcdCcTreeAddCPR(p_FmPort->h_FmPcd,
+                                        p_PcdParams->p_CcParams->h_CcTree,
+                                        p_PcdParams->h_NetEnv,
+                                        p_FmPort->h_CapwapReassemblyManip,
+                                        TRUE);
+#endif /* (DPAA_VERSION >= 11) */
+
         if (err != E_OK)
         {
-            if (p_FmPort->h_IpReassemblyTree)
+            if (p_FmPort->h_ReassemblyTree)
             {
-                FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
-                p_FmPort->h_IpReassemblyTree = NULL;
-            }
-            RELEASE_LOCK(p_FmPort->lock);
+                FM_PCD_CcRootDelete(p_FmPort->h_ReassemblyTree);
+                p_FmPort->h_ReassemblyTree = NULL;
+            }RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, err, NO_MSG);
         }
     }
 
     if (!FmPcdLockTryLockAll(p_FmPort->h_FmPcd))
     {
-        if (p_FmPort->h_IpReassemblyTree)
+        if (p_FmPort->h_ReassemblyTree)
         {
-            FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
-            p_FmPort->h_IpReassemblyTree = NULL;
-        }
-        RELEASE_LOCK(p_FmPort->lock);
+            FM_PCD_CcRootDelete(p_FmPort->h_ReassemblyTree);
+            p_FmPort->h_ReassemblyTree = NULL;
+        }RELEASE_LOCK(p_FmPort->lock);
         DBG(TRACE, ("Try LockAll - BUSY"));
         return ERROR_CODE(E_BUSY);
     }
@@ -4358,27 +5025,28 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
     err = SetPcd(h_FmPort, p_PcdParams);
     if (err)
     {
-        if (p_FmPort->h_IpReassemblyTree)
+        if (p_FmPort->h_ReassemblyTree)
         {
-            FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
-            p_FmPort->h_IpReassemblyTree = NULL;
+            FM_PCD_CcRootDelete(p_FmPort->h_ReassemblyTree);
+            p_FmPort->h_ReassemblyTree = NULL;
         }
         FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
         RELEASE_LOCK(p_FmPort->lock);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    if ((p_FmPort->pcdEngines & FM_PCD_PRS) &&
-        (p_PcdParams->p_PrsParams->includeInPrsStatistics))
+    if ((p_FmPort->pcdEngines & FM_PCD_PRS)
+            && (p_PcdParams->p_PrsParams->includeInPrsStatistics))
     {
-        err = FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, TRUE);
+        err = FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd,
+                                              p_FmPort->hardwarePortId, TRUE);
         if (err)
         {
             DeletePcd(p_FmPort);
-            if (p_FmPort->h_IpReassemblyTree)
+            if (p_FmPort->h_ReassemblyTree)
             {
-                FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
-                p_FmPort->h_IpReassemblyTree = NULL;
+                FM_PCD_CcRootDelete(p_FmPort->h_ReassemblyTree);
+                p_FmPort->h_ReassemblyTree = NULL;
             }
             FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
             RELEASE_LOCK(p_FmPort->lock);
@@ -4397,36 +5065,51 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
         {
 #ifdef FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
             if ((p_FmPort->fmRevInfo.majorRev < 6) &&
-                (p_FmPort->pcdEngines & FM_PCD_KG))
+                    (p_FmPort->pcdEngines & FM_PCD_KG))
             {
                 int i;
                 for (i = 0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
-                    /* The following function must be locked */
-                    FmPcdKgCcGetSetParams(p_FmPort->h_FmPcd,
-                                          p_PcdParams->p_KgParams->h_Schemes[i],
-                                          UPDATE_KG_NIA_CC_WA,
-                                          0);
+                /* The following function must be locked */
+                FmPcdKgCcGetSetParams(p_FmPort->h_FmPcd,
+                        p_PcdParams->p_KgParams->h_Schemes[i],
+                        UPDATE_KG_NIA_CC_WA,
+                        0);
             }
 #endif /* FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004 */
 
+#if (DPAA_VERSION >= 11)
+            {
+                t_FmPcdCtrlParamsPage *p_ParamsPage;
+
+                FmPortSetGprFunc(p_FmPort, e_FM_PORT_GPR_MURAM_PAGE,
+                                 (void**)&p_ParamsPage);
+                ASSERT_COND(p_ParamsPage);
+                WRITE_UINT32(p_ParamsPage->postBmiFetchNia,
+                             p_FmPort->savedBmiNia);
+            }
+#endif /* (DPAA_VERSION >= 11) */
+
             /* Set post-bmi-fetch nia */
             p_FmPort->savedBmiNia &= BMI_RFNE_FDCS_MASK;
-            p_FmPort->savedBmiNia |= (NIA_FM_CTL_AC_POST_BMI_FETCH | NIA_ENG_FM_CTL);
+            p_FmPort->savedBmiNia |= (NIA_FM_CTL_AC_POST_BMI_FETCH
+                    | NIA_ENG_FM_CTL);
 
             /* Set pre-bmi-fetch nia */
             fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNDN;
 #if (DPAA_VERSION >= 11)
-            fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_PRE_BMI_FETCH_FULL_FRAME | NIA_ENG_FM_CTL);
+            fmPortGetSetCcParams.setCcParams.nia =
+                    (NIA_FM_CTL_AC_PRE_BMI_FETCH_FULL_FRAME | NIA_ENG_FM_CTL);
 #else
             fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_PRE_BMI_FETCH_HEADER | NIA_ENG_FM_CTL);
 #endif /* (DPAA_VERSION >= 11) */
-            if ((err = FmPortGetSetCcParams(p_FmPort, &fmPortGetSetCcParams)) != E_OK)
+            if ((err = FmPortGetSetCcParams(p_FmPort, &fmPortGetSetCcParams))
+                    != E_OK)
             {
                 DeletePcd(p_FmPort);
-                if (p_FmPort->h_IpReassemblyTree)
+                if (p_FmPort->h_ReassemblyTree)
                 {
-                    FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
-                    p_FmPort->h_IpReassemblyTree = NULL;
+                    FM_PCD_CcRootDelete(p_FmPort->h_ReassemblyTree);
+                    p_FmPort->h_ReassemblyTree = NULL;
                 }
                 FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
                 RELEASE_LOCK(p_FmPort->lock);
@@ -4448,36 +5131,38 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
 #endif /* (DPAA_VERSION == 10) */
         fmPortGetSetCcParams.getCcParams.type = GET_NIA_FPNE;
 #if (DPAA_VERSION == 10)
-        }
+    }
 #endif /* (DPAA_VERSION == 10) */
-        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams))
+                != E_OK)
         {
             DeletePcd(p_FmPort);
-            if (p_FmPort->h_IpReassemblyTree)
+            if (p_FmPort->h_ReassemblyTree)
             {
-                FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
-                p_FmPort->h_IpReassemblyTree = NULL;
-            }
-            RELEASE_LOCK(p_FmPort->lock);
+                FM_PCD_CcRootDelete(p_FmPort->h_ReassemblyTree);
+                p_FmPort->h_ReassemblyTree = NULL;
+            }RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, err, NO_MSG);
         }
 
         /* Set post-bmi-prepare-to-enq nia */
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_FENE;
-        fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_POST_BMI_ENQ | NIA_ENG_FM_CTL);
-        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+        fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_POST_BMI_ENQ
+                | NIA_ENG_FM_CTL);
+        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams))
+                != E_OK)
         {
             DeletePcd(p_FmPort);
-            if (p_FmPort->h_IpReassemblyTree)
+            if (p_FmPort->h_ReassemblyTree)
             {
-                FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
-                p_FmPort->h_IpReassemblyTree = NULL;
-            }
-            RELEASE_LOCK(p_FmPort->lock);
+                FM_PCD_CcRootDelete(p_FmPort->h_ReassemblyTree);
+                p_FmPort->h_ReassemblyTree = NULL;
+            }RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, err, NO_MSG);
         }
 
-        if (p_FmPort->h_IpReassemblyManip)
+        if ((p_FmPort->h_IpReassemblyManip)
+                || (p_FmPort->h_CapwapReassemblyManip))
         {
 #if (DPAA_VERSION == 10)
             if (p_FmPort->fmRevInfo.majorRev < 6)
@@ -4492,19 +5177,20 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
 #endif /* (DPAA_VERSION == 10) */
             /* Set the ORR bit (for order-restoration) */
             fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_FPNE;
-            fmPortGetSetCcParams.setCcParams.nia = fmPortGetSetCcParams.getCcParams.nia | NIA_ORDER_RESTOR;
+            fmPortGetSetCcParams.setCcParams.nia =
+                    fmPortGetSetCcParams.getCcParams.nia | NIA_ORDER_RESTOR;
 #if (DPAA_VERSION == 10)
-            }
+        }
 #endif /* (DPAA_VERSION == 10) */
-            if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+            if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams))
+                    != E_OK)
             {
                 DeletePcd(p_FmPort);
-                if (p_FmPort->h_IpReassemblyTree)
+                if (p_FmPort->h_ReassemblyTree)
                 {
-                    FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
-                    p_FmPort->h_IpReassemblyTree = NULL;
-                }
-                RELEASE_LOCK(p_FmPort->lock);
+                    FM_PCD_CcRootDelete(p_FmPort->h_ReassemblyTree);
+                    p_FmPort->h_ReassemblyTree = NULL;
+                }RELEASE_LOCK(p_FmPort->lock);
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             }
         }
@@ -4514,46 +5200,55 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
 
 #if (DPAA_VERSION >= 11)
     {
-        t_FmPcdCtrlParamsPage   *p_ParamsPage;
+        t_FmPcdCtrlParamsPage *p_ParamsPage;
 
         memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
 
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_CMNE;
         if (FmPcdIsAdvancedOffloadSupported(p_FmPort->h_FmPcd))
-            fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_POP_TO_N_STEP | NIA_ENG_FM_CTL;
+            fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_POP_TO_N_STEP
+                    | NIA_ENG_FM_CTL;
         else
-            fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_NO_IPACC_POP_TO_N_STEP | NIA_ENG_FM_CTL;
-        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+            fmPortGetSetCcParams.setCcParams.nia =
+                    NIA_FM_CTL_AC_NO_IPACC_POP_TO_N_STEP | NIA_ENG_FM_CTL;
+        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams))
+                != E_OK)
         {
             DeletePcd(p_FmPort);
-            if (p_FmPort->h_IpReassemblyTree)
+            if (p_FmPort->h_ReassemblyTree)
             {
-                FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
-                p_FmPort->h_IpReassemblyTree = NULL;
-            }
-            RELEASE_LOCK(p_FmPort->lock);
+                FM_PCD_CcRootDelete(p_FmPort->h_ReassemblyTree);
+                p_FmPort->h_ReassemblyTree = NULL;
+            }RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, err, NO_MSG);
-         }
+        }
 
-        FmPortSetGprFunc(p_FmPort, e_FM_PORT_GPR_MURAM_PAGE, (void**)&p_ParamsPage);
+        FmPortSetGprFunc(p_FmPort, e_FM_PORT_GPR_MURAM_PAGE,
+                         (void**)&p_ParamsPage);
         ASSERT_COND(p_ParamsPage);
 
         if (FmPcdIsAdvancedOffloadSupported(p_FmPort->h_FmPcd))
-            WRITE_UINT32(p_ParamsPage->misc, GET_UINT32(p_ParamsPage->misc) | FM_CTL_PARAMS_PAGE_OFFLOAD_SUPPORT_EN);
+            WRITE_UINT32(
+                    p_ParamsPage->misc,
+                    GET_UINT32(p_ParamsPage->misc) | FM_CTL_PARAMS_PAGE_OFFLOAD_SUPPORT_EN);
 
-        if (p_FmPort->h_IpReassemblyManip)
+        if ((p_FmPort->h_IpReassemblyManip)
+                || (p_FmPort->h_CapwapReassemblyManip))
         {
             if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-                WRITE_UINT32(p_ParamsPage->discardMask,
-                             GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm));
+                WRITE_UINT32(
+                        p_ParamsPage->discardMask,
+                        GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm));
             else
-                WRITE_UINT32(p_ParamsPage->discardMask,
-                             GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm));
+                WRITE_UINT32(
+                        p_ParamsPage->discardMask,
+                        GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm));
         }
 #ifdef FM_ERROR_VSP_NO_MATCH_SW006
         if (p_FmPort->vspe)
-            WRITE_UINT32(p_ParamsPage->misc,
-                         GET_UINT32(p_ParamsPage->misc) | (p_FmPort->dfltRelativeId & FM_CTL_PARAMS_PAGE_ERROR_VSP_MASK));
+            WRITE_UINT32(
+                    p_ParamsPage->misc,
+                    GET_UINT32(p_ParamsPage->misc) | (p_FmPort->dfltRelativeId & FM_CTL_PARAMS_PAGE_ERROR_VSP_MASK));
 #endif /* FM_ERROR_VSP_NO_MATCH_SW006 */
     }
 #endif /* (DPAA_VERSION >= 11) */
@@ -4562,12 +5257,11 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
     if (err)
     {
         DeletePcd(p_FmPort);
-        if (p_FmPort->h_IpReassemblyTree)
+        if (p_FmPort->h_ReassemblyTree)
         {
-            FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
-            p_FmPort->h_IpReassemblyTree = NULL;
-        }
-        RELEASE_LOCK(p_FmPort->lock);
+            FM_PCD_CcRootDelete(p_FmPort->h_ReassemblyTree);
+            p_FmPort->h_ReassemblyTree = NULL;
+        }RELEASE_LOCK(p_FmPort->lock);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
@@ -4578,24 +5272,26 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
 
 t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
 {
-    t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error                                 err = E_OK;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if (p_FmPort->imEn)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("available for non-independant mode ports only"));
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                     ("available for Rx and offline parsing ports only"));
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-         DBG(TRACE, ("FM Port Try Lock - BUSY"));
-         return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("FM Port Try Lock - BUSY"));
+        return ERROR_CODE(E_BUSY);
     }
 
     err = DetachPCD(h_FmPort);
@@ -4608,10 +5304,10 @@ t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
     FmPcdDecNetEnvOwners(p_FmPort->h_FmPcd, p_FmPort->netEnvId);
 
     /* we do it anyway, instead of checking if included */
-    if ((p_FmPort->pcdEngines & FM_PCD_PRS) &&
-        p_FmPort->includeInPrsStatistics)
+    if ((p_FmPort->pcdEngines & FM_PCD_PRS) && p_FmPort->includeInPrsStatistics)
     {
-        FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, FALSE);
+        FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd,
+                                        p_FmPort->hardwarePortId, FALSE);
         p_FmPort->includeInPrsStatistics = FALSE;
     }
 
@@ -4630,48 +5326,50 @@ t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    if (p_FmPort->h_IpReassemblyTree)
+    if (p_FmPort->h_ReassemblyTree)
     {
-        err = FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+        err = FM_PCD_CcRootDelete(p_FmPort->h_ReassemblyTree);
         if (err)
         {
             RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, err, NO_MSG);
         }
-        p_FmPort->h_IpReassemblyTree = NULL;
-    }
-    RELEASE_LOCK(p_FmPort->lock);
+        p_FmPort->h_ReassemblyTree = NULL;
+    }RELEASE_LOCK(p_FmPort->lock);
 
     return err;
 }
 
-t_Error  FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme)
+t_Error FM_PORT_PcdKgBindSchemes(t_Handle h_FmPort,
+                                 t_FmPcdPortSchemesParams *p_PortScheme)
 {
-    t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
-    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
-    t_Error                                 err = E_OK;
-    uint32_t                                tmpScmVec=0;
-    int                                     i;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPcdKgInterModuleBindPortToSchemes schemeBind;
+    t_Error err = E_OK;
+    uint32_t tmpScmVec = 0;
+    int i;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG , E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG,
+                              E_INVALID_STATE);
 
     schemeBind.netEnvId = p_FmPort->netEnvId;
     schemeBind.hardwarePortId = p_FmPort->hardwarePortId;
     schemeBind.numOfSchemes = p_PortScheme->numOfSchemes;
     schemeBind.useClsPlan = p_FmPort->useClsPlan;
-    for (i=0; i<schemeBind.numOfSchemes; i++)
+    for (i = 0; i < schemeBind.numOfSchemes; i++)
     {
-        schemeBind.schemesIds[i] = FmPcdKgGetSchemeId(p_PortScheme->h_Schemes[i]);
+        schemeBind.schemesIds[i] = FmPcdKgGetSchemeId(
+                p_PortScheme->h_Schemes[i]);
         /* build vector */
         tmpScmVec |= 1 << (31 - (uint32_t)schemeBind.schemesIds[i]);
     }
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-         DBG(TRACE, ("FM Port Try Lock - BUSY"));
-         return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("FM Port Try Lock - BUSY"));
+        return ERROR_CODE(E_BUSY);
     }
 
     err = FmPcdKgBindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
@@ -4680,11 +5378,11 @@ t_Error  FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *
 
 #ifdef FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
     if ((FmPcdIsAdvancedOffloadSupported(p_FmPort->h_FmPcd)) &&
-        (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) &&
-        (p_FmPort->fmRevInfo.majorRev < 6))
+            (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) &&
+            (p_FmPort->fmRevInfo.majorRev < 6))
     {
         for (i=0; i<p_PortScheme->numOfSchemes; i++)
-            FmPcdKgCcGetSetParams(p_FmPort->h_FmPcd, p_PortScheme->h_Schemes[i], UPDATE_KG_NIA_CC_WA, 0);
+        FmPcdKgCcGetSetParams(p_FmPort->h_FmPcd, p_PortScheme->h_Schemes[i], UPDATE_KG_NIA_CC_WA, 0);
     }
 #endif /* FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004 */
 
@@ -4693,32 +5391,35 @@ t_Error  FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *
     return err;
 }
 
-t_Error FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme)
+t_Error FM_PORT_PcdKgUnbindSchemes(t_Handle h_FmPort,
+                                   t_FmPcdPortSchemesParams *p_PortScheme)
 {
-    t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
-    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
-    t_Error                                 err = E_OK;
-    uint32_t                                tmpScmVec=0;
-    int                                     i;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPcdKgInterModuleBindPortToSchemes schemeBind;
+    t_Error err = E_OK;
+    uint32_t tmpScmVec = 0;
+    int i;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG , E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG,
+                              E_INVALID_STATE);
 
     schemeBind.netEnvId = p_FmPort->netEnvId;
     schemeBind.hardwarePortId = p_FmPort->hardwarePortId;
     schemeBind.numOfSchemes = p_PortScheme->numOfSchemes;
-    for (i=0; i<schemeBind.numOfSchemes; i++)
+    for (i = 0; i < schemeBind.numOfSchemes; i++)
     {
-        schemeBind.schemesIds[i] = FmPcdKgGetSchemeId(p_PortScheme->h_Schemes[i]);
+        schemeBind.schemesIds[i] = FmPcdKgGetSchemeId(
+                p_PortScheme->h_Schemes[i]);
         /* build vector */
         tmpScmVec |= 1 << (31 - (uint32_t)schemeBind.schemesIds[i]);
     }
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-         DBG(TRACE, ("FM Port Try Lock - BUSY"));
-         return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("FM Port Try Lock - BUSY"));
+        return ERROR_CODE(E_BUSY);
     }
 
     err = FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
@@ -4729,361 +5430,108 @@ t_Error FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams
     return err;
 }
 
-t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_FmPcdPrsStart)
+t_Error FM_PORT_PcdPrsModifyStartOffset(t_Handle h_FmPort,
+                                        t_FmPcdPrsStart *p_FmPcdPrsStart)
 {
-    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    volatile uint32_t   *p_BmiPrsStartOffset = NULL;
-    volatile uint32_t   *p_BmiNia = NULL;
-    uint32_t            tmpReg;
-    uint8_t             hdrNum;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t *p_BmiPrsStartOffset = NULL;
+    volatile uint32_t *p_BmiNia = NULL;
+    uint32_t tmpReg;
+    uint8_t hdrNum;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_PRS , E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_PRS,
+                              E_INVALID_STATE);
 
     switch (p_FmPort->portType)
     {
         case (e_FM_PORT_TYPE_RX_10G):
         case (e_FM_PORT_TYPE_RX):
-            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
+            p_BmiPrsStartOffset =
+                    &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             tmpReg = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
             break;
         case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
+            p_BmiPrsStartOffset =
+                    &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             tmpReg = 0;
             break;
         default:
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+            RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                         ("available for Rx and offline parsing ports only"));
     }
 
     /* check that current NIA is BMI to BMI */
-    if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) !=
-        GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd))
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
+    if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK)
+            != GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd))
+        RETURN_ERROR( MAJOR, E_INVALID_OPERATION,
+                     ("may be called only for ports in BMI-to-BMI state."));
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-         DBG(TRACE, ("FM Port Try Lock - BUSY"));
-         return ERROR_CODE(E_BUSY);
+        DBG(TRACE, ("FM Port Try Lock - BUSY"));
+        return ERROR_CODE(E_BUSY);
     }
 
     /* set the first header */
-    GET_PRS_HDR_NUM(hdrNum, p_FmPcdPrsStart->firstPrsHdr);
+    hdrNum = GetPrsHdrNum(p_FmPcdPrsStart->firstPrsHdr);
     if ((hdrNum == ILLEGAL_HDR_NUM) || (hdrNum == NO_HDR_NUM))
     {
         RELEASE_LOCK(p_FmPort->lock);
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unsupported header."));
     }
-    WRITE_UINT32(*p_BmiNia, (uint32_t)(NIA_ENG_PRS | (uint32_t)hdrNum | tmpReg));
+
+    WRITE_UINT32(*p_BmiNia,
+                 (uint32_t)(NIA_ENG_PRS | (uint32_t)hdrNum | tmpReg));
 
     /* set start parsing offset */
-    WRITE_UINT32(*p_BmiPrsStartOffset,
-                 (uint32_t)(p_FmPcdPrsStart->parsingOffset +
-                            p_FmPort->internalBufferOffset));
+    WRITE_UINT32(
+            *p_BmiPrsStartOffset,
+            (uint32_t)(p_FmPcdPrsStart->parsingOffset + p_FmPort->internalBufferOffset));
     RELEASE_LOCK(p_FmPort->lock);
 
     return E_OK;
 }
 
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
-{
-    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error             err = E_OK;
-    char                arr[20];
-    uint8_t             flag;
-    int                 i=0;
-
-    DECLARE_DUMP;
-
-    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortQmiRegs, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortBmiRegs, E_INVALID_HANDLE);
-
-    memset(arr, 0, sizeof(arr));
-    switch (p_FmPort->portType)
-    {
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            strcpy(arr, "OFFLINE-PARSING");
-            flag = 0;
-            break;
-        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            strcpy(arr, "HOST-COMMAND");
-            flag = 0;
-            break;
-        case (e_FM_PORT_TYPE_RX):
-            strcpy(arr, "RX");
-            flag = 1;
-            break;
-        case (e_FM_PORT_TYPE_RX_10G):
-            strcpy(arr, "RX-10G");
-            flag = 1;
-            break;
-        case (e_FM_PORT_TYPE_TX):
-            strcpy(arr, "TX");
-            flag = 2;
-            break;
-        case (e_FM_PORT_TYPE_TX_10G):
-            strcpy(arr, "TX-10G");
-            flag = 2;
-            break;
-        default:
-            return ERROR_CODE(E_INVALID_VALUE);
-    }
-
-    DUMP_TITLE(NULL,
-               ("FMan-Port (%s #%d) registers:",
-                arr, p_FmPort->portId));
-
-    err = FmDumpPortRegs(p_FmPort->h_Fm, p_FmPort->hardwarePortId);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-
-    DUMP_TITLE(p_FmPort->p_FmPortBmiRegs, ("Bmi Port Regs"));
-
-    switch (flag)
-    {
-        case (0):
-
-        DUMP_SUBTITLE(("\n"));
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ocfg);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ost);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oda);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oicp);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofdne);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofne);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofca);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofpne);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opso);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opp);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_occb);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oim);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofp);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofed);
-
-        DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oprai), ("fmbm_oprai"));
-        DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_PRS_RESULT_NUM_OF_WORDS)
-        {
-            DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oprai[i]), sizeof(uint32_t));
-        }
-        DUMP_SUBTITLE(("\n"));
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofqid );
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oefqid);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofsdm );
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofsem );
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofene );
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_orlmts);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_orlmt);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ocmne);
-        {
-#ifndef FM_NO_OP_OBSERVED_POOLS
-            if (p_FmPort->fmRevInfo.majorRev == 4)
-            {
-                DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oebmpi, ("fmbm_oebmpi"));
-
-                DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS)
-                {
-                    DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oebmpi[i], sizeof(uint32_t));
-                }
-                DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ocgm);
-            }
-#endif /* !FM_NO_OP_OBSERVED_POOLS */
-        }
-
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ostc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofrc );
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofdc );
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofledc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofufdc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_offc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofwdc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofldec);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opcp);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_occn);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_otuc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oduc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofuc);
-        DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_odcfg), ("fmbm_odcfg"));
-        DUMP_SUBSTRUCT_ARRAY(i, 3)
-        {
-            DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_odcfg[i]), sizeof(uint32_t));
-        }
-        DUMP_SUBTITLE(("\n"));
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ogpr);
-        break;
-    case (1):
-        DUMP_SUBTITLE(("\n"));
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rcfg);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rst);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rda);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfp);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_reth);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfed);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_ricp);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rebm);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfne);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfca);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfpne);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpso);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpp);
-
-        DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rprai), ("fmbm_rprai"));
-        DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_PRS_RESULT_NUM_OF_WORDS)
-        {
-            DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rprai[i]), sizeof(uint32_t));
-        }
-        DUMP_SUBTITLE(("\n"));
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfqid);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_refqid);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfsdm);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfsem);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfene);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rcmne);
-        DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi, ("fmbm_ebmpi"));
-        DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_MAX_NUM_OF_EXT_POOLS)
-        {
-            DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i], sizeof(uint32_t));
-        }
-        DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt, ("fmbm_acnt"));
-        DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_MAX_NUM_OF_EXT_POOLS)
-        {
-            DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt[i], sizeof(uint32_t));
-        }
-        DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm, ("fmbm_rcgm"));
-        DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_NUM_OF_CONGESTION_GRPS/32)
-        {
-            DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[i], sizeof(uint32_t));
-        }
-        DUMP_SUBTITLE(("\n"));
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rmpd);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rstc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfrc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfbc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rlfc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rffc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfcd);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfldec);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rodc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpcp);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rccn);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rtuc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rrquc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rduc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfuc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpac);
-        DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rdcfg), ("fmbm_rdcfg"));
-        DUMP_SUBSTRUCT_ARRAY(i, 3)
-        {
-            DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rdcfg[i]), sizeof(uint32_t));
-        }
-        DUMP_SUBTITLE(("\n"));
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rgpr);
-        break;
-    case (2):
-
-        DUMP_SUBTITLE(("\n"));
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tcfg);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tst);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tda);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfp);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfed);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_ticp);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfdne);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfca);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tcfqid);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfeqid);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfene);
-#if (DPAA_VERSION >= 11)
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfne);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tcmne);
-#endif /* (DPAA_VERSION >= 11) */
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_trlmts);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_trlmt);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tstc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfrc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfdc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfledc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfufdc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tpc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tpcp);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tccn);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_ttuc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_ttcquc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tduc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfuc);
-        DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tdcfg), ("fmbm_tdcfg"));
-        DUMP_SUBSTRUCT_ARRAY(i, 3)
-        {
-            DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tdcfg[i]), sizeof(uint32_t));
-        }
-        DUMP_SUBTITLE(("\n"));
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tgpr);
-        break;
-
-   default:
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid flag"));
-    }
-
-    DUMP_TITLE(p_FmPort->p_FmPortQmiRegs, ("Qmi Port Regs"));
-
-    DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pnc);
-    DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pns);
-    DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pnts);
-    DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pnen);
-    DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pnetfc);
-
-    if (flag !=1)
-    {
-        DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndn);
-        DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndc);
-        DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndtfc);
-        DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndfdc);
-        DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndcc);
-    }
-
-    return E_OK;
-}
-#endif /* (defined(DEBUG_ERRORS) && ... */
-
-t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps)
+t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort,
+                                  t_FmPortCongestionGrps *p_CongestionGrps)
 {
-    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    uint8_t             priorityTmpArray[FM_PORT_NUM_OF_CONGESTION_GRPS];
-    uint8_t             mod, index;
-    uint32_t            i, grpsMap[FMAN_PORT_CG_MAP_NUM];
-    int                 err;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    uint8_t priorityTmpArray[FM_PORT_NUM_OF_CONGESTION_GRPS];
+    uint8_t mod, index;
+    uint32_t i, grpsMap[FMAN_PORT_CG_MAP_NUM];
+    int err;
 #if (DPAA_VERSION >= 11)
-    int                 j;
+    int j;
 #endif /* (DPAA_VERSION >= 11) */
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
     /* un-necessary check of the indexes; probably will be needed in the future when there
-       will be more CGs available ....
-    for (i=0; i<p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
-        if (p_CongestionGrps->congestionGrpsToConsider[i] >= FM_PORT_NUM_OF_CONGESTION_GRPS)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("CG id!"));
-    */
+     will be more CGs available ....
+     for (i=0; i<p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
+     if (p_CongestionGrps->congestionGrpsToConsider[i] >= FM_PORT_NUM_OF_CONGESTION_GRPS)
+     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("CG id!"));
+     */
 
 #ifdef FM_NO_OP_OBSERVED_CGS
     if ((p_FmPort->fmRevInfo.majorRev != 4) &&
-        (p_FmPort->fmRevInfo.majorRev < 6))
+            (p_FmPort->fmRevInfo.majorRev < 6))
     {
         if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-            (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx ports only"));
+                (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx ports only"));
     }
     else
 #endif /* FM_NO_OP_OBSERVED_CGS */
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx & OP ports only"));
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_RX)
+            && (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                     ("Available for Rx & OP ports only"));
 
     /* Prepare groups map array */
     memset(grpsMap, 0, FMAN_PORT_CG_MAP_NUM * sizeof(uint32_t));
@@ -5097,60 +5545,64 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
             grpsMap[0] |= (uint32_t)(1 << mod);
     }
 
-    memset(&priorityTmpArray, 0, FM_PORT_NUM_OF_CONGESTION_GRPS*sizeof(uint8_t));
+    memset(&priorityTmpArray, 0,
+           FM_PORT_NUM_OF_CONGESTION_GRPS * sizeof(uint8_t));
 
-    for (i=0; i<p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
+    for (i = 0; i < p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
     {
 #if (DPAA_VERSION >= 11)
-        for (j=0;j<FM_MAX_NUM_OF_PFC_PRIORITIES;j++)
+        for (j = 0; j < FM_MAX_NUM_OF_PFC_PRIORITIES; j++)
             if (p_CongestionGrps->pfcPrioritiesEn[i][j])
-                priorityTmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] |= (0x01 <<(FM_MAX_NUM_OF_PFC_PRIORITIES-j-1));
+                priorityTmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] |=
+                        (0x01 << (FM_MAX_NUM_OF_PFC_PRIORITIES - j - 1));
 #endif /* (DPAA_VERSION >= 11) */
     }
 
 #if (DPAA_VERSION >= 11)
-    for (i=0; i<FM_PORT_NUM_OF_CONGESTION_GRPS; i++)
+    for (i = 0; i < FM_PORT_NUM_OF_CONGESTION_GRPS; i++)
     {
-            err = FmSetCongestionGroupPFCpriority(p_FmPort->h_Fm,i,priorityTmpArray[i]);
-            if (err)
-                return err;
-     }
+        err = FmSetCongestionGroupPFCpriority(p_FmPort->h_Fm, i,
+                                              priorityTmpArray[i]);
+        if (err)
+            return err;
+    }
 #endif /* (DPAA_VERSION >= 11) */
 
     err = fman_port_add_congestion_grps(&p_FmPort->port, grpsMap);
     if (err != 0)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_add_congestion_grps"));
 
-    return  E_OK;
+    return E_OK;
 }
 
-t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps)
+t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort,
+                                     t_FmPortCongestionGrps *p_CongestionGrps)
 {
-    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    uint8_t             mod, index;
-    uint32_t            i, grpsMap[FMAN_PORT_CG_MAP_NUM];
-    int                 err;
-
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+    uint8_t mod, index;
+    uint32_t i, grpsMap[FMAN_PORT_CG_MAP_NUM];
+    int err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
     {
 #ifdef FM_NO_OP_OBSERVED_CGS
-        t_FmRevisionInfo    revInfo;
+        t_FmRevisionInfo revInfo;
 
         FM_GetRevision(p_FmPort->h_Fm, &revInfo);
         if (revInfo.majorRev != 4)
         {
             if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-               (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx ports only"));
+                    (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx ports only"));
         }
         else
 #endif /* FM_NO_OP_OBSERVED_CGS */
-        if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-           (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-           (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx & OP ports only"));
+        if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G)
+                && (p_FmPort->portType != e_FM_PORT_TYPE_RX)
+                && (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
+                         ("Available for Rx & OP ports only"));
     }
 
     /* Prepare groups map array */
@@ -5166,28 +5618,33 @@ t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *
     }
 
 #if (DPAA_VERSION >= 11)
-    for (i=0; i<p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
+    for (i = 0; i < p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
     {
-    t_Error err = FmSetCongestionGroupPFCpriority(p_FmPort->h_Fm,
-        p_CongestionGrps->congestionGrpsToConsider[i], 0);
-    if (err)
-        return err;
+        t_Error err = FmSetCongestionGroupPFCpriority(
+                p_FmPort->h_Fm, p_CongestionGrps->congestionGrpsToConsider[i],
+                0);
+        if (err)
+            return err;
     }
 #endif /* (DPAA_VERSION >= 11) */
 
     err = fman_port_remove_congestion_grps(&p_FmPort->port, grpsMap);
     if (err != 0)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_remove_congestion_grps"));
-    return  E_OK;
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("fman_port_remove_congestion_grps"));
+    return E_OK;
 }
 
 #if (DPAA_VERSION >= 11)
-t_Error FM_PORT_GetIPv4OptionsCount(t_Handle h_FmPort, uint32_t *p_Ipv4OptionsCount)
+t_Error FM_PORT_GetIPv4OptionsCount(t_Handle h_FmPort,
+                                    uint32_t *p_Ipv4OptionsCount)
 {
-    t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(
+            (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING),
+            E_INVALID_VALUE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_ParamsPage, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_Ipv4OptionsCount, E_NULL_POINTER);
 
@@ -5197,11 +5654,14 @@ t_Error FM_PORT_GetIPv4OptionsCount(t_Handle h_FmPort, uint32_t *p_Ipv4OptionsCo
 }
 #endif /* (DPAA_VERSION >= 11) */
 
-t_Error FM_PORT_ConfigDsarSupport(t_Handle h_FmPortRx, t_FmPortDsarTablesSizes *params)
+t_Error FM_PORT_ConfigDsarSupport(t_Handle h_FmPortRx,
+                                  t_FmPortDsarTablesSizes *params)
 {
-    t_FmPort *p_FmPort= (t_FmPort *)h_FmPortRx;
-    p_FmPort->deepSleepVars.autoResMaxSizes = XX_Malloc(sizeof(struct t_FmPortDsarTablesSizes));
-    memcpy(p_FmPort->deepSleepVars.autoResMaxSizes, params, sizeof(struct t_FmPortDsarTablesSizes));
+    t_FmPort *p_FmPort = (t_FmPort *)h_FmPortRx;
+    p_FmPort->deepSleepVars.autoResMaxSizes = XX_Malloc(
+            sizeof(struct t_FmPortDsarTablesSizes));
+    memcpy(p_FmPort->deepSleepVars.autoResMaxSizes, params,
+           sizeof(struct t_FmPortDsarTablesSizes));
     return E_OK;
 }
 
@@ -5235,8 +5695,10 @@ static t_Error FmPortConfigAutoResForDeepSleepSupport1(t_FmPort *p_FmPort)
     //SNMP
     size = ROUND_UP(size,4);
     size += sizeof(t_DsarSnmpDescriptor);
-    size += sizeof(t_DsarSnmpIpv4AddrTblEntry) * params->maxNumOfSnmpIPV4Entries;
-    size += sizeof(t_DsarSnmpIpv6AddrTblEntry) * params->maxNumOfSnmpIPV6Entries;
+    size += sizeof(t_DsarSnmpIpv4AddrTblEntry)
+            * params->maxNumOfSnmpIPV4Entries;
+    size += sizeof(t_DsarSnmpIpv6AddrTblEntry)
+            * params->maxNumOfSnmpIPV6Entries;
     size += sizeof(t_OidsTblEntry) * params->maxNumOfSnmpOidEntries;
     size += params->maxNumOfSnmpOidChar;
     size += sizeof(t_DsarIcmpV6Statistics);
@@ -5256,15 +5718,19 @@ static t_Error FmPortConfigAutoResForDeepSleepSupport1(t_FmPort *p_FmPort)
 
     ArCommonDescPtr = FM_MURAM_AllocMem(p_FmPort->h_FmMuram, size, 0x10);
 
-    param_page = XX_PhysToVirt(p_FmPort->fmMuramPhysBaseAddr + GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rgpr));
-    WRITE_UINT32(*param_page,
+    param_page =
+            XX_PhysToVirt(
+                    p_FmPort->fmMuramPhysBaseAddr
+                            + GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rgpr));
+    WRITE_UINT32(
+            *param_page,
             (uint32_t)(XX_VirtToPhys(ArCommonDescPtr) - p_FmPort->fmMuramPhysBaseAddr));
     return E_OK;
 }
 
 t_FmPortDsarTablesSizes* FM_PORT_GetDsarTablesMaxSizes(t_Handle h_FmPortRx)
 {
-    t_FmPort *p_FmPort= (t_FmPort *)h_FmPortRx;
+    t_FmPort *p_FmPort = (t_FmPort *)h_FmPortRx;
     return p_FmPort->deepSleepVars.autoResMaxSizes;
 }
 
@@ -5281,7 +5747,9 @@ struct arOffsets
     uint32_t filtTcp;
 };
 
-static uint32_t AR_ComputeOffsets(struct arOffsets* of, struct t_FmPortDsarParams *params, t_FmPort *p_FmPort)
+static uint32_t AR_ComputeOffsets(struct arOffsets* of,
+                                  struct t_FmPortDsarParams *params,
+                                  t_FmPort *p_FmPort)
 {
     uint32_t size = sizeof(t_ArCommonDesc);
     // ARP
@@ -5290,7 +5758,8 @@ static uint32_t AR_ComputeOffsets(struct arOffsets* of, struct t_FmPortDsarParam
         size = ROUND_UP(size,4);
         of->arp = size;
         size += sizeof(t_DsarArpDescriptor);
-        size += sizeof(t_DsarArpBindingEntry) * params->p_AutoResArpInfo->tableSize;
+        size += sizeof(t_DsarArpBindingEntry)
+                * params->p_AutoResArpInfo->tableSize;
         size += sizeof(t_DsarArpStatistics);
     }
     // ICMPV4
@@ -5299,7 +5768,8 @@ static uint32_t AR_ComputeOffsets(struct arOffsets* of, struct t_FmPortDsarParam
         size = ROUND_UP(size,4);
         of->icmpv4 = size;
         size += sizeof(t_DsarIcmpV4Descriptor);
-        size += sizeof(t_DsarIcmpV4BindingEntry) * params->p_AutoResEchoIpv4Info->tableSize;
+        size += sizeof(t_DsarIcmpV4BindingEntry)
+                * params->p_AutoResEchoIpv4Info->tableSize;
         size += sizeof(t_DsarIcmpV4Statistics);
     }
     // ICMPV6
@@ -5308,7 +5778,8 @@ static uint32_t AR_ComputeOffsets(struct arOffsets* of, struct t_FmPortDsarParam
         size = ROUND_UP(size,4);
         of->icmpv6 = size;
         size += sizeof(t_DsarIcmpV6Descriptor);
-        size += sizeof(t_DsarIcmpV6BindingEntry) * params->p_AutoResEchoIpv6Info->tableSize;
+        size += sizeof(t_DsarIcmpV6BindingEntry)
+                * params->p_AutoResEchoIpv6Info->tableSize;
         size += sizeof(t_DsarIcmpV6Statistics);
     }
     // ND
@@ -5317,8 +5788,9 @@ static uint32_t AR_ComputeOffsets(struct arOffsets* of, struct t_FmPortDsarParam
         size = ROUND_UP(size,4);
         of->nd = size;
         size += sizeof(t_DsarNdDescriptor);
-        size += sizeof(t_DsarIcmpV6BindingEntry) *
-            (params->p_AutoResNdpInfo->tableSizeAssigned + params->p_AutoResNdpInfo->tableSizeTmp);
+        size += sizeof(t_DsarIcmpV6BindingEntry)
+                * (params->p_AutoResNdpInfo->tableSizeAssigned
+                        + params->p_AutoResNdpInfo->tableSizeTmp);
         size += sizeof(t_DsarIcmpV6Statistics);
     }
     // SNMP
@@ -5327,8 +5799,10 @@ static uint32_t AR_ComputeOffsets(struct arOffsets* of, struct t_FmPortDsarParam
         size = ROUND_UP(size,4);
         of->snmp = size;
         size += sizeof(t_DsarSnmpDescriptor);
-        size += sizeof(t_DsarSnmpIpv4AddrTblEntry) * params->p_AutoResSnmpInfo->numOfIpv4Addresses;
-        size += sizeof(t_DsarSnmpIpv6AddrTblEntry) * params->p_AutoResSnmpInfo->numOfIpv6Addresses;
+        size += sizeof(t_DsarSnmpIpv4AddrTblEntry)
+                * params->p_AutoResSnmpInfo->numOfIpv4Addresses;
+        size += sizeof(t_DsarSnmpIpv6AddrTblEntry)
+                * params->p_AutoResSnmpInfo->numOfIpv6Addresses;
         size += sizeof(t_OidsTblEntry) * params->p_AutoResSnmpInfo->oidsTblSize;
         size += p_FmPort->deepSleepVars.autoResMaxSizes->maxNumOfSnmpOidChar;
         size += sizeof(t_DsarIcmpV6Statistics);
@@ -5341,10 +5815,12 @@ static uint32_t AR_ComputeOffsets(struct arOffsets* of, struct t_FmPortDsarParam
         size += params->p_AutoResFilteringInfo->ipProtTableSize;
         size = ROUND_UP(size,4);
         of->filtUdp = size;
-        size += params->p_AutoResFilteringInfo->udpPortsTableSize * sizeof(t_PortTblEntry);
+        size += params->p_AutoResFilteringInfo->udpPortsTableSize
+                * sizeof(t_PortTblEntry);
         size = ROUND_UP(size,4);
         of->filtTcp = size;
-        size += params->p_AutoResFilteringInfo->tcpPortsTableSize * sizeof(t_PortTblEntry);
+        size += params->p_AutoResFilteringInfo->tcpPortsTableSize
+                * sizeof(t_PortTblEntry);
     }
     // add here for more protocols
     // statistics
@@ -5358,102 +5834,165 @@ uint32_t* ARDesc;
 void PrsEnable(t_Handle p_FmPcd);
 void PrsDisable(t_Handle p_FmPcd);
 int PrsIsEnabled(t_Handle p_FmPcd);
+t_Handle FM_PCD_GetHcPort(t_Handle h_FmPcd);
 
-static t_Error DsarCheckParams(t_FmPortDsarParams *params, t_FmPortDsarTablesSizes *sizes)
+static t_Error DsarCheckParams(t_FmPortDsarParams *params,
+                               t_FmPortDsarTablesSizes *sizes)
 {
     bool macInit = FALSE;
     uint8_t mac[6];
-    int i;
+    int i = 0;
 
     // check table sizes
-    if (params->p_AutoResArpInfo && sizes->maxNumOfArpEntries < params->p_AutoResArpInfo->tableSize)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: Arp table size exceeds the configured maximum size."));
-    if (params->p_AutoResEchoIpv4Info && sizes->maxNumOfEchoIpv4Entries < params->p_AutoResEchoIpv4Info->tableSize)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: EchoIpv4 table size exceeds the configured maximum size."));
-    if (params->p_AutoResNdpInfo && sizes->maxNumOfNdpEntries < params->p_AutoResNdpInfo->tableSizeAssigned + params->p_AutoResNdpInfo->tableSizeTmp)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: NDP table size exceeds the configured maximum size."));
-    if (params->p_AutoResEchoIpv6Info && sizes->maxNumOfEchoIpv6Entries < params->p_AutoResEchoIpv6Info->tableSize)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: EchoIpv6 table size exceeds the configured maximum size."));
-    if (params->p_AutoResSnmpInfo && sizes->maxNumOfSnmpOidEntries < params->p_AutoResSnmpInfo->oidsTblSize)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: Snmp Oid table size exceeds the configured maximum size."));
-    if (params->p_AutoResSnmpInfo && sizes->maxNumOfSnmpIPV4Entries < params->p_AutoResSnmpInfo->numOfIpv4Addresses)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: Snmp ipv4 table size exceeds the configured maximum size."));
-    if (params->p_AutoResSnmpInfo && sizes->maxNumOfSnmpIPV6Entries < params->p_AutoResSnmpInfo->numOfIpv6Addresses)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: Snmp ipv6 table size exceeds the configured maximum size."));
+    if (params->p_AutoResArpInfo
+            && sizes->maxNumOfArpEntries < params->p_AutoResArpInfo->tableSize)
+        RETURN_ERROR(
+                MAJOR, E_INVALID_VALUE,
+                ("DSAR: Arp table size exceeds the configured maximum size."));
+    if (params->p_AutoResEchoIpv4Info
+            && sizes->maxNumOfEchoIpv4Entries
+                    < params->p_AutoResEchoIpv4Info->tableSize)
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("DSAR: EchoIpv4 table size exceeds the configured maximum size."));
+    if (params->p_AutoResNdpInfo
+            && sizes->maxNumOfNdpEntries
+                    < params->p_AutoResNdpInfo->tableSizeAssigned
+                            + params->p_AutoResNdpInfo->tableSizeTmp)
+        RETURN_ERROR(
+                MAJOR, E_INVALID_VALUE,
+                ("DSAR: NDP table size exceeds the configured maximum size."));
+    if (params->p_AutoResEchoIpv6Info
+            && sizes->maxNumOfEchoIpv6Entries
+                    < params->p_AutoResEchoIpv6Info->tableSize)
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("DSAR: EchoIpv6 table size exceeds the configured maximum size."));
+    if (params->p_AutoResSnmpInfo
+            && sizes->maxNumOfSnmpOidEntries
+                    < params->p_AutoResSnmpInfo->oidsTblSize)
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("DSAR: Snmp Oid table size exceeds the configured maximum size."));
+    if (params->p_AutoResSnmpInfo
+            && sizes->maxNumOfSnmpIPV4Entries
+                    < params->p_AutoResSnmpInfo->numOfIpv4Addresses)
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("DSAR: Snmp ipv4 table size exceeds the configured maximum size."));
+    if (params->p_AutoResSnmpInfo
+            && sizes->maxNumOfSnmpIPV6Entries
+                    < params->p_AutoResSnmpInfo->numOfIpv6Addresses)
+        RETURN_ERROR(
+                MAJOR,
+                E_INVALID_VALUE,
+                ("DSAR: Snmp ipv6 table size exceeds the configured maximum size."));
     if (params->p_AutoResFilteringInfo)
     {
-        if (sizes->maxNumOfIpProtFiltering < params->p_AutoResFilteringInfo->ipProtTableSize)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: ip filter table size exceeds the configured maximum size."));
-        if (sizes->maxNumOfTcpPortFiltering < params->p_AutoResFilteringInfo->udpPortsTableSize)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: udp filter table size exceeds the configured maximum size."));
-        if (sizes->maxNumOfUdpPortFiltering < params->p_AutoResFilteringInfo->tcpPortsTableSize)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: tcp filter table size exceeds the configured maximum size."));
-    }
-    // check only 1 MAC address is configured (this is what ucode currently supports)
+        if (sizes->maxNumOfIpProtFiltering
+                < params->p_AutoResFilteringInfo->ipProtTableSize)
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("DSAR: ip filter table size exceeds the configured maximum size."));
+        if (sizes->maxNumOfTcpPortFiltering
+                < params->p_AutoResFilteringInfo->udpPortsTableSize)
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("DSAR: udp filter table size exceeds the configured maximum size."));
+        if (sizes->maxNumOfUdpPortFiltering
+                < params->p_AutoResFilteringInfo->tcpPortsTableSize)
+            RETURN_ERROR(
+                    MAJOR,
+                    E_INVALID_VALUE,
+                    ("DSAR: tcp filter table size exceeds the configured maximum size."));
+    }
+    /* check only 1 MAC address is configured (this is what ucode currently supports) */
     if (params->p_AutoResArpInfo && params->p_AutoResArpInfo->tableSize)
     {
-	i = 0;
-        if (!macInit)
-	{
-            memcpy(mac, params->p_AutoResArpInfo->p_AutoResTable[0].mac, 6);
-	    i = 1;
-	    macInit = TRUE;
-	}
-	for (; i < params->p_AutoResArpInfo->tableSize; i++)
-	    if (memcmp(mac, params->p_AutoResArpInfo->p_AutoResTable[i].mac, 6))
-	        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: Only 1 mac address is currently supported."));
+        memcpy(mac, params->p_AutoResArpInfo->p_AutoResTable[0].mac, 6);
+        i = 1;
+        macInit = TRUE;
+
+        for (; i < params->p_AutoResArpInfo->tableSize; i++)
+            if (memcmp(mac, params->p_AutoResArpInfo->p_AutoResTable[i].mac, 6))
+                RETURN_ERROR(
+                        MAJOR, E_INVALID_VALUE,
+                        ("DSAR: Only 1 mac address is currently supported."));
     }
-    if (params->p_AutoResEchoIpv4Info && params->p_AutoResEchoIpv4Info->tableSize)
+    if (params->p_AutoResEchoIpv4Info
+            && params->p_AutoResEchoIpv4Info->tableSize)
     {
-	i = 0;
+        i = 0;
         if (!macInit)
-	{
-            memcpy(mac, params->p_AutoResEchoIpv4Info->p_AutoResTable[0].mac, 6);
-	    i = 1;
-	    macInit = TRUE;
-	}
-	for (; i < params->p_AutoResEchoIpv4Info->tableSize; i++)
-	    if (memcmp(mac, params->p_AutoResEchoIpv4Info->p_AutoResTable[i].mac, 6))
-	        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: Only 1 mac address is currently supported."));
+        {
+            memcpy(mac, params->p_AutoResEchoIpv4Info->p_AutoResTable[0].mac,
+                   6);
+            i = 1;
+            macInit = TRUE;
+        }
+        for (; i < params->p_AutoResEchoIpv4Info->tableSize; i++)
+            if (memcmp(mac,
+                       params->p_AutoResEchoIpv4Info->p_AutoResTable[i].mac, 6))
+                RETURN_ERROR(
+                        MAJOR, E_INVALID_VALUE,
+                        ("DSAR: Only 1 mac address is currently supported."));
     }
-    if (params->p_AutoResEchoIpv6Info && params->p_AutoResEchoIpv6Info->tableSize)
+    if (params->p_AutoResEchoIpv6Info
+            && params->p_AutoResEchoIpv6Info->tableSize)
     {
-	i = 0;
+        i = 0;
         if (!macInit)
-	{
-            memcpy(mac, params->p_AutoResEchoIpv6Info->p_AutoResTable[0].mac, 6);
-	    i = 1;
-	    macInit = TRUE;
-	}
-	for (; i < params->p_AutoResEchoIpv6Info->tableSize; i++)
-	    if (memcmp(mac, params->p_AutoResEchoIpv6Info->p_AutoResTable[i].mac, 6))
-	        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: Only 1 mac address is currently supported."));
+        {
+            memcpy(mac, params->p_AutoResEchoIpv6Info->p_AutoResTable[0].mac,
+                   6);
+            i = 1;
+            macInit = TRUE;
+        }
+        for (; i < params->p_AutoResEchoIpv6Info->tableSize; i++)
+            if (memcmp(mac,
+                       params->p_AutoResEchoIpv6Info->p_AutoResTable[i].mac, 6))
+                RETURN_ERROR(
+                        MAJOR, E_INVALID_VALUE,
+                        ("DSAR: Only 1 mac address is currently supported."));
     }
     if (params->p_AutoResNdpInfo && params->p_AutoResNdpInfo->tableSizeAssigned)
     {
-	i = 0;
+        i = 0;
         if (!macInit)
-	{
-            memcpy(mac, params->p_AutoResNdpInfo->p_AutoResTableAssigned[0].mac, 6);
-	    i = 1;
-	    macInit = TRUE;
-	}
-	for (; i < params->p_AutoResNdpInfo->tableSizeAssigned; i++)
-	    if (memcmp(mac, params->p_AutoResNdpInfo->p_AutoResTableAssigned[i].mac, 6))
-	        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: Only 1 mac address is currently supported."));
+        {
+            memcpy(mac, params->p_AutoResNdpInfo->p_AutoResTableAssigned[0].mac,
+                   6);
+            i = 1;
+            macInit = TRUE;
+        }
+        for (; i < params->p_AutoResNdpInfo->tableSizeAssigned; i++)
+            if (memcmp(mac,
+                       params->p_AutoResNdpInfo->p_AutoResTableAssigned[i].mac,
+                       6))
+                RETURN_ERROR(
+                        MAJOR, E_INVALID_VALUE,
+                        ("DSAR: Only 1 mac address is currently supported."));
     }
     if (params->p_AutoResNdpInfo && params->p_AutoResNdpInfo->tableSizeTmp)
     {
-	i = 0;
+        i = 0;
         if (!macInit)
-	{
+        {
             memcpy(mac, params->p_AutoResNdpInfo->p_AutoResTableTmp[0].mac, 6);
-	    i = 1;
-	    macInit = TRUE;
-	}
-	for (; i < params->p_AutoResNdpInfo->tableSizeTmp; i++)
-	    if (memcmp(mac, params->p_AutoResNdpInfo->p_AutoResTableTmp[i].mac, 6))
-	        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("DSAR: Only 1 mac address is currently supported."));
+            i = 1;
+        }
+        for (; i < params->p_AutoResNdpInfo->tableSizeTmp; i++)
+            if (memcmp(mac, params->p_AutoResNdpInfo->p_AutoResTableTmp[i].mac,
+                       6))
+                RETURN_ERROR(
+                        MAJOR, E_INVALID_VALUE,
+                        ("DSAR: Only 1 mac address is currently supported."));
     }
     return E_OK;
 }
@@ -5482,21 +6021,32 @@ static int fm_soc_suspend(void)
 	tmp32 = GET_UINT32(*fmclk);
 	WRITE_UINT32(*fmclk, SCFG_FMCLKDPSLPCR_DS_VAL);
 	tmp32 = GET_UINT32(*fmclk);
+	iounmap(fmclk);
 	return 0;
 }
 
-t_FmPort *g_DsarFmPortRx, *g_DsarFmPortTx;
+void fm_clk_down(void)
+{
+	uint32_t *fmclk, tmp32;
+	fmclk = ioremap(SCFG_FMCLKDPSLPCR_ADDR, 4);
+	tmp32 = GET_UINT32(*fmclk);
+	WRITE_UINT32(*fmclk, SCFG_FMCLKDPSLPCR_DS_VAL | 0x40000000);
+	tmp32 = GET_UINT32(*fmclk);
+	iounmap(fmclk);
+}
+
 t_Error FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params)
 {
-    int i,j;
+    int i, j;
     t_Error err;
     uint32_t nia;
-    t_FmPort            *p_FmPort= (t_FmPort *)h_FmPortRx;
-    t_FmPort            *p_FmPortTx = (t_FmPort *)params->h_FmPortTx;
+    t_FmPort *p_FmPort = (t_FmPort *)h_FmPortRx;
+    t_FmPort *p_FmPortTx = (t_FmPort *)params->h_FmPortTx;
     t_DsarArpDescriptor *ArpDescriptor;
     t_DsarIcmpV4Descriptor* ICMPV4Descriptor;
     t_DsarIcmpV6Descriptor* ICMPV6Descriptor;
     t_DsarNdDescriptor* NDDescriptor;
+
     uint64_t fmMuramVirtBaseAddr = (uint64_t)PTR_TO_UINT(XX_PhysToVirt(p_FmPort->fmMuramPhysBaseAddr));
     uint32_t *param_page = XX_PhysToVirt(p_FmPort->fmMuramPhysBaseAddr + GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rgpr));
     t_ArCommonDesc *ArCommonDescPtr = (t_ArCommonDesc*)(XX_PhysToVirt(p_FmPort->fmMuramPhysBaseAddr + GET_UINT32(*param_page)));
@@ -5505,14 +6055,11 @@ t_Error FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params)
     t_FmGetSetParams fmGetSetParams;
     memset(&fmGetSetParams, 0, sizeof (t_FmGetSetParams));
     fmGetSetParams.setParams.type = UPDATE_FPM_BRKC_SLP;
-    fmGetSetParams.setParams.sleep = 1;
-
-    g_DsarFmPortRx = p_FmPort;
-    g_DsarFmPortTx = p_FmPortTx;
+    fmGetSetParams.setParams.sleep = 1;    
 
     err = DsarCheckParams(params, p_FmPort->deepSleepVars.autoResMaxSizes);
     if (err != E_OK)
-	return err;
+        return err;
 
     p_FmPort->deepSleepVars.autoResOffsets = XX_Malloc(sizeof(struct arOffsets));
     of = (struct arOffsets *)p_FmPort->deepSleepVars.autoResOffsets;
@@ -5530,10 +6077,13 @@ t_Error FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params)
     // ARP
     if (params->p_AutoResArpInfo)
     {
-	t_DsarArpBindingEntry* arp_bindings;
+        t_DsarArpBindingEntry* arp_bindings;
         ArpDescriptor = (t_DsarArpDescriptor*)(PTR_TO_UINT(ArCommonDescPtr) + of->arp);
         WRITE_UINT32(ArCommonDescPtr->p_ArpDescriptor, PTR_TO_UINT(ArpDescriptor) - fmMuramVirtBaseAddr);
         arp_bindings = (t_DsarArpBindingEntry*)(PTR_TO_UINT(ArpDescriptor) + sizeof(t_DsarArpDescriptor));
+	if (params->p_AutoResArpInfo->enableConflictDetection)
+	        WRITE_UINT16(ArpDescriptor->control, 1);
+	else
         WRITE_UINT16(ArpDescriptor->control, 0);
         if (params->p_AutoResArpInfo->tableSize)
         {
@@ -5557,7 +6107,7 @@ t_Error FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params)
     // ICMPV4
     if (params->p_AutoResEchoIpv4Info)
     {
-	t_DsarIcmpV4BindingEntry* icmpv4_bindings;
+        t_DsarIcmpV4BindingEntry* icmpv4_bindings;
         ICMPV4Descriptor = (t_DsarIcmpV4Descriptor*)(PTR_TO_UINT(ArCommonDescPtr) + of->icmpv4);
         WRITE_UINT32(ArCommonDescPtr->p_IcmpV4Descriptor, PTR_TO_UINT(ICMPV4Descriptor) - fmMuramVirtBaseAddr);
         icmpv4_bindings = (t_DsarIcmpV4BindingEntry*)(PTR_TO_UINT(ICMPV4Descriptor) + sizeof(t_DsarIcmpV4Descriptor));
@@ -5584,7 +6134,7 @@ t_Error FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params)
     // ICMPV6
     if (params->p_AutoResEchoIpv6Info)
     {
-	t_DsarIcmpV6BindingEntry* icmpv6_bindings;
+        t_DsarIcmpV6BindingEntry* icmpv6_bindings;
         ICMPV6Descriptor = (t_DsarIcmpV6Descriptor*)(PTR_TO_UINT(ArCommonDescPtr) + of->icmpv6);
         WRITE_UINT32(ArCommonDescPtr->p_IcmpV6Descriptor, PTR_TO_UINT(ICMPV6Descriptor) - fmMuramVirtBaseAddr);
         icmpv6_bindings = (t_DsarIcmpV6BindingEntry*)(PTR_TO_UINT(ICMPV6Descriptor) + sizeof(t_DsarIcmpV6Descriptor));
@@ -5612,10 +6162,13 @@ t_Error FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params)
     // ND
     if (params->p_AutoResNdpInfo)
     {
-	t_DsarIcmpV6BindingEntry* icmpv6_bindings;
+        t_DsarIcmpV6BindingEntry* icmpv6_bindings;
         NDDescriptor = (t_DsarNdDescriptor*)(PTR_TO_UINT(ArCommonDescPtr) + of->nd);
         WRITE_UINT32(ArCommonDescPtr->p_NdDescriptor, PTR_TO_UINT(NDDescriptor) - fmMuramVirtBaseAddr);
         icmpv6_bindings = (t_DsarIcmpV6BindingEntry*)(PTR_TO_UINT(NDDescriptor) + sizeof(t_DsarNdDescriptor));
+	if (params->p_AutoResNdpInfo->enableConflictDetection)
+	        WRITE_UINT16(NDDescriptor->control, 1);
+	else
         WRITE_UINT16(NDDescriptor->control, 0);
         if (params->p_AutoResNdpInfo->tableSizeAssigned + params->p_AutoResNdpInfo->tableSizeTmp)
         {
@@ -5707,14 +6260,14 @@ t_Error FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params)
         {
             WRITE_UINT16(snmpOid->oidSize, snmpSrc->p_OidsTbl[i].oidSize);
             WRITE_UINT16(snmpOid->resSize, snmpSrc->p_OidsTbl[i].resSize);
-            Mem2IOCpy32(charPointer, snmpSrc->p_OidsTbl[i].p_Oid, snmpSrc->p_OidsTbl[i].oidSize);
+            Mem2IOCpy32(charPointer, snmpSrc->p_OidsTbl[i].oidVal, snmpSrc->p_OidsTbl[i].oidSize);
             WRITE_UINT32(snmpOid->p_Oid, PTR_TO_UINT(charPointer) - fmMuramVirtBaseAddr);
             charPointer += snmpSrc->p_OidsTbl[i].oidSize;
             if (snmpSrc->p_OidsTbl[i].resSize <= 4)
-                WRITE_UINT32(snmpOid->resValOrPtr, snmpSrc->p_OidsTbl[i].resValOrPtr);
+                WRITE_UINT32(snmpOid->resValOrPtr, *snmpSrc->p_OidsTbl[i].resVal);
             else
             {
-                Mem2IOCpy32(charPointer, UINT_TO_PTR(snmpSrc->p_OidsTbl[i].resValOrPtr), snmpSrc->p_OidsTbl[i].resSize);
+                Mem2IOCpy32(charPointer, snmpSrc->p_OidsTbl[i].resVal, snmpSrc->p_OidsTbl[i].resSize);
                 WRITE_UINT32(snmpOid->resValOrPtr, PTR_TO_UINT(charPointer) - fmMuramVirtBaseAddr);
                 charPointer += snmpSrc->p_OidsTbl[i].resSize;
             }
@@ -5727,13 +6280,14 @@ t_Error FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params)
     // filtering
     if (params->p_AutoResFilteringInfo)
     {
-        if (params->p_AutoResFilteringInfo->ipProtDropOnHit)
+        if (params->p_AutoResFilteringInfo->ipProtPassOnHit)
             tmp |= IP_PROT_TBL_PASS_MASK;
-        if (params->p_AutoResFilteringInfo->udpPortDropOnHit)
+        if (params->p_AutoResFilteringInfo->udpPortPassOnHit)
             tmp |= UDP_PORT_TBL_PASS_MASK;
-        if (params->p_AutoResFilteringInfo->tcpPortDropOnHit)
+        if (params->p_AutoResFilteringInfo->tcpPortPassOnHit)
             tmp |= TCP_PORT_TBL_PASS_MASK;
         WRITE_UINT8(ArCommonDescPtr->filterControl, tmp);
+        WRITE_UINT16(ArCommonDescPtr->tcpControlPass, params->p_AutoResFilteringInfo->tcpFlagsMask);
 
         // ip filtering
         if (params->p_AutoResFilteringInfo->ipProtTableSize)
@@ -5793,28 +6347,30 @@ t_Error FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params)
 
 }
 
-void FM_PORT_Dsar_enter_final(void)
+void FM_ChangeClock(t_Handle h_Fm, int hardwarePortId);
+t_Error FM_PORT_EnterDsarFinal(t_Handle h_DsarRxPort, t_Handle h_DsarTxPort)
 {
-    t_Handle *h_FmPcd;
-    t_FmGetSetParams fmGetSetParams;
+	t_FmGetSetParams fmGetSetParams;
+	t_FmPort *p_FmPort = (t_FmPort *)h_DsarRxPort;
+	t_FmPort *p_FmPortTx = (t_FmPort *)h_DsarTxPort;
+	t_Handle *h_FmPcd = FmGetPcd(p_FmPort->h_Fm);
+	t_FmPort *p_FmPortHc = FM_PCD_GetHcPort(h_FmPcd);
+	memset(&fmGetSetParams, 0, sizeof (t_FmGetSetParams));
+        fmGetSetParams.setParams.type = UPDATE_FM_CLD;
+        FmGetSetParams(p_FmPort->h_Fm, &fmGetSetParams);
 
-	t_FmPort *p_FmPort = g_DsarFmPortRx;
-	t_FmPort *p_FmPortTx = g_DsarFmPortTx;
-	// Issue graceful stop to HC port
-	FM_PORT_Disable(opXX);
+	/* Issue graceful stop to HC port */
+	FM_PORT_Disable(p_FmPortHc);
 
 	// config tx port
     p_FmPort->deepSleepVars.fmbm_tcfg = GET_UINT32(p_FmPortTx->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg);
-    WRITE_UINT32(p_FmPortTx->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tfdne, 0x005000C0);
     WRITE_UINT32(p_FmPortTx->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg, GET_UINT32(p_FmPortTx->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg) | BMI_PORT_CFG_IM | BMI_PORT_CFG_EN);
     // ????
     p_FmPort->deepSleepVars.fmbm_tcmne = GET_UINT32(p_FmPortTx->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcmne);
     WRITE_UINT32(p_FmPortTx->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcmne, 0xE);
     // Stage 7:echo
-    p_FmPort->deepSleepVars.fmbm_rfne = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne);
-    WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne, 0x440000);
     p_FmPort->deepSleepVars.fmbm_rfpne = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne);
-    h_FmPcd = FmGetPcd(p_FmPort->h_Fm);
+    WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne, 0x2E);
     if (!PrsIsEnabled(h_FmPcd))
     {
         p_FmPort->deepSleepVars.dsarEnabledParser = TRUE;
@@ -5823,11 +6379,17 @@ void FM_PORT_Dsar_enter_final(void)
     else
         p_FmPort->deepSleepVars.dsarEnabledParser = FALSE;
 
-    WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne, 0x2E);
+    p_FmPort->deepSleepVars.fmbm_rfne = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne);
+    WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne, 0x440000);
 
     // save rcfg for restoring: accumulate mode is changed by ucode
     p_FmPort->deepSleepVars.fmbm_rcfg = GET_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rcfg);
     WRITE_UINT32(p_FmPort->port.bmi_regs->rx.fmbm_rcfg, p_FmPort->deepSleepVars.fmbm_rcfg | BMI_PORT_CFG_AM);
+        memset(&fmGetSetParams, 0, sizeof (t_FmGetSetParams));
+        fmGetSetParams.setParams.type = UPDATE_FPM_BRKC_SLP;
+        fmGetSetParams.setParams.sleep = 1;
+        FmGetSetParams(p_FmPort->h_Fm, &fmGetSetParams);
+
 // ***** issue external request sync command
         memset(&fmGetSetParams, 0, sizeof (t_FmGetSetParams));
         fmGetSetParams.setParams.type = UPDATE_FPM_EXTC;
@@ -5842,7 +6404,7 @@ void FM_PORT_Dsar_enter_final(void)
 		memset(&fmGetSetParams, 0, sizeof (t_FmGetSetParams));
 		fmGetSetParams.setParams.type = UPDATE_FPM_EXTC_CLEAR;
 		FmGetSetParams(p_FmPort->h_Fm, &fmGetSetParams);
-	}
+}
 
 	memset(&fmGetSetParams, 0, sizeof (t_FmGetSetParams));
 	fmGetSetParams.getParams.type = GET_FMFP_EXTC | GET_FM_NPI;
@@ -5861,9 +6423,12 @@ void FM_PORT_Dsar_enter_final(void)
 	        FmGetSetParams(p_FmPort->h_Fm, &fmGetSetParams);
 	if (fmGetSetParams.getParams.fmqm_gs == 0 && fmGetSetParams.getParams.fm_npi == 0)
 		XX_Print("FM: Sleeping\n");
+//	FM_ChangeClock(p_FmPort->h_Fm, p_FmPort->hardwarePortId);
+
+    return E_OK;
 }
 
-EXPORT_SYMBOL(FM_PORT_Dsar_enter_final);
+EXPORT_SYMBOL(FM_PORT_EnterDsarFinal);
 
 void FM_PORT_Dsar_DumpRegs()
 {
@@ -5875,6 +6440,8 @@ void FM_PORT_ExitDsar(t_Handle h_FmPortRx, t_Handle h_FmPortTx)
 {
     t_FmPort *p_FmPort = (t_FmPort *)h_FmPortRx;
     t_FmPort *p_FmPortTx = (t_FmPort *)h_FmPortTx;
+    t_Handle *h_FmPcd = FmGetPcd(p_FmPort->h_Fm);
+    t_FmPort *p_FmPortHc = FM_PCD_GetHcPort(h_FmPcd);
     t_FmGetSetParams fmGetSetParams;
     memset(&fmGetSetParams, 0, sizeof (t_FmGetSetParams));
     fmGetSetParams.setParams.type = UPDATE_FPM_BRKC_SLP;
@@ -5884,11 +6451,6 @@ void FM_PORT_ExitDsar(t_Handle h_FmPortRx, t_Handle h_FmPortTx)
         XX_Free(p_FmPort->deepSleepVars.autoResOffsets);
         p_FmPort->deepSleepVars.autoResOffsets = 0;
     }
-    if (p_FmPort->deepSleepVars.autoResMaxSizes)
-    {
-        XX_Free(p_FmPort->deepSleepVars.autoResMaxSizes);
-        p_FmPort->deepSleepVars.autoResMaxSizes = 0;
-    }
 
     if (p_FmPort->deepSleepVars.dsarEnabledParser)
         PrsDisable(FmGetPcd(p_FmPort->h_Fm));
@@ -5898,7 +6460,7 @@ void FM_PORT_ExitDsar(t_Handle h_FmPortRx, t_Handle h_FmPortTx)
     FmGetSetParams(p_FmPort->h_Fm, &fmGetSetParams);
     WRITE_UINT32(p_FmPortTx->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcmne, p_FmPort->deepSleepVars.fmbm_tcmne);
     WRITE_UINT32(p_FmPortTx->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg, p_FmPort->deepSleepVars.fmbm_tcfg);
-    FM_PORT_Enable(opXX);
+    FM_PORT_Enable(p_FmPortHc);
 }
 
 bool FM_PORT_IsInDsar(t_Handle h_FmPort)
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h
index 75f117f..bd06b9b 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h
@@ -211,21 +211,28 @@ typedef uint32_t fmPcdEngines_t; /**< options as defined below: */
 #define FM_OH_PORT_ID                               0
 
 /***********************************************************************/
-/*          SW parser IP-fragmentation labels (offsets)                */
+/*          SW parser OFFLOAD labels (offsets)                         */
 /***********************************************************************/
 #if (DPAA_VERSION == 10)
-#define IP_FRAG_SW_PATCH_IPv4_SIZE              0x025
-#define IP_FRAG_SW_PATCH_IPv4_LABEL             0x300
+#define OFFLOAD_SW_PATCH_IPv4_SIZE              0x025
+#define OFFLOAD_SW_PATCH_IPv4_LABEL             0x300
 #else
-#define IP_FRAG_SW_PATCH_IPv4_SIZE              0x046
-#define IP_FRAG_SW_PATCH_IPv4_LABEL             0x2E0
+#define OFFLOAD_SW_PATCH_IPv4_SIZE              0x046
+#define OFFLOAD_SW_PATCH_IPv4_LABEL             0x1D0
+#define OFFLOAD_CAPWAP_SW_PATCH_LABEL           0x38d
 #endif /* (DPAA_VERSION == 10) */
-#define IP_FRAG_SW_PATCH_IPv6_LABEL             \
-    (IP_FRAG_SW_PATCH_IPv4_LABEL + IP_FRAG_SW_PATCH_IPv4_SIZE)
+/* Will be used for:
+ * 1. identify fragments
+ * 2. if no fragment, will identify the fragmentable are
+ * 3. udp-lite
+ */
+#define OFFLOAD_SW_PATCH_IPv6_LABEL             \
+    (OFFLOAD_SW_PATCH_IPv4_LABEL + OFFLOAD_SW_PATCH_IPv4_SIZE)
 
-#ifdef FM_CAPWAP_SUPPORT
+#if ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
 #define UDP_LITE_SW_PATCH_LABEL                 0x2E0
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT)) */
+
 
 /**************************************************************************//**
  @Description       Memory Mapped Registers
@@ -235,7 +242,7 @@ typedef uint32_t fmPcdEngines_t; /**< options as defined below: */
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
 
-typedef _Packed struct
+typedef struct
 {
     volatile uint32_t   fmbm_rcfg;      /**< Rx Configuration */
     volatile uint32_t   fmbm_rst;       /**< Rx Status */
@@ -296,9 +303,9 @@ typedef _Packed struct
     volatile uint32_t   fmbm_rdcfg[0x3];/**< Rx Debug-*/
     volatile uint32_t   fmbm_rgpr;      /**< Rx General Purpose Register. */
     volatile uint32_t   reserved8[0x3a];/**< (0x310-0x3FF) */
-} _PackedType t_FmPortRxBmiRegs;
+} t_FmPortRxBmiRegs;
 
-typedef _Packed struct
+typedef struct
 {
     volatile uint32_t   fmbm_tcfg;      /**< Tx Configuration */
     volatile uint32_t   fmbm_tst;       /**< Tx Status */
@@ -337,9 +344,9 @@ typedef _Packed struct
     volatile uint32_t   fmbm_tdcfg[0x3];/**< Tx Debug-*/
     volatile uint32_t   fmbm_tgpr;      /**< O/H General Purpose Register */
     volatile uint32_t   reserved5[0x3a];/**< (0x310-0x3FF) */
-} _PackedType t_FmPortTxBmiRegs;
+} t_FmPortTxBmiRegs;
 
-typedef _Packed struct
+typedef struct
 {
     volatile uint32_t   fmbm_ocfg;      /**< O/H Configuration  */
     volatile uint32_t   fmbm_ost;       /**< O/H Status */
@@ -395,16 +402,16 @@ typedef _Packed struct
     volatile uint32_t   fmbm_odcfg[0x3];/**< O/H Debug (only 1 in P1023) */
     volatile uint32_t   fmbm_ogpr;      /**< O/H General Purpose Register. */
     volatile uint32_t   reserved7[0x3a];/**< (0x310 0x3FF) */
-} _PackedType t_FmPortOhBmiRegs;
+} t_FmPortOhBmiRegs;
 
-typedef _Packed union
+typedef union
 {
     t_FmPortRxBmiRegs rxPortBmiRegs;
     t_FmPortTxBmiRegs txPortBmiRegs;
     t_FmPortOhBmiRegs ohPortBmiRegs;
-} _PackedType u_FmPortBmiRegs;
+} u_FmPortBmiRegs;
 
-typedef _Packed struct
+typedef struct
 {
     volatile uint32_t   reserved1[2];   /**<   0xn024 - 0x02B */
     volatile uint32_t   fmqm_pndn;      /**<   PortID n Dequeue NIA Register */
@@ -412,9 +419,9 @@ typedef _Packed struct
     volatile uint32_t   fmqm_pndtfc;    /**<   PortID n Dequeue Total Frame Counter */
     volatile uint32_t   fmqm_pndfdc;    /**<   PortID n Dequeue FQID from Default Counter */
     volatile uint32_t   fmqm_pndcc;     /**<   PortID n Dequeue Confirm Counter */
-} _PackedType t_FmPortNonRxQmiRegs;
+} t_FmPortNonRxQmiRegs;
 
-typedef _Packed struct
+typedef struct
 {
     volatile uint32_t   fmqm_pnc;       /**<   PortID n Configuration Register */
     volatile uint32_t   fmqm_pns;       /**<   PortID n Status Register */
@@ -423,19 +430,19 @@ typedef _Packed struct
     volatile uint32_t   fmqm_pnen;      /**<   PortID n Enqueue NIA Register */
     volatile uint32_t   fmqm_pnetfc;    /**<   PortID n Enqueue Total Frame Counter */
     t_FmPortNonRxQmiRegs    nonRxQmiRegs;  /**<   Registers for Tx Hc & Op ports */
-} _PackedType t_FmPortQmiRegs;
+} t_FmPortQmiRegs;
 
-typedef _Packed struct
+typedef struct
 {
-    _Packed struct
+     struct
     {
         volatile uint32_t   softSeqAttach;  /**<   Soft Sequence Attachment */
         volatile uint32_t   lcv;            /**<   Line-up Enable Confirmation Mask */
-    } _PackedType hdrs[FM_PCD_PRS_NUM_OF_HDRS];
+    } hdrs[FM_PCD_PRS_NUM_OF_HDRS];
     volatile uint8_t    reserved0[0x378];
     volatile uint32_t   pcac;               /**<   Parse Internal Memory Configuration Access Control Register */
     volatile uint32_t   pctpid;             /**<   Parse Internal Memory Configured TPID Register */
-} _PackedType t_FmPortPrsRegs;
+} t_FmPortPrsRegs;
 
 /**************************************************************************//*
  @Description   Basic buffer descriptor (BD) structure
@@ -502,6 +509,7 @@ typedef _Packed struct
 #define BMI_PORT_RFNE_FRWD_DCL4C                0x10000000
 #define BMI_PORT_RFNE_FRWD_RPD                  0x40000000
 #define BMI_RFNE_FDCS_MASK                      0xFF000000
+#define BMI_RFNE_HXS_MASK                       0x000000FF
 
 #define BMI_CMD_MR_LEAC                         0x00200000
 #define BMI_CMD_MR_SLEAC                        0x00100000
@@ -728,7 +736,6 @@ typedef _Packed struct
 #define BD_RX_OV                                0x00010000
 
 #define BD_RX_ERRORS                            (BD_RX_CRE | BD_RX_FTL | BD_RX_FTS | BD_RX_OV)
-#define BD_ERROR_PASS_FRAME                     BD_RX_ERRORS
 
 #define FM_IM_SIZEOF_BD                         sizeof(t_FmImBd)
 
@@ -910,6 +917,7 @@ typedef struct {
     uint32_t                    savedBmiFene;
     uint32_t                    savedBmiFpne;
     uint32_t                    savedBmiCmne;
+    uint32_t                    savedBmiOfp;
     uint32_t                    savedNonRxQmiRegsPndn;
     uint32_t                    origNonRxQmiRegsPndn;
     int                         savedPrsStartOffset;
@@ -922,7 +930,8 @@ typedef struct {
     t_FmPortRxPoolsParams       rxPoolsParams;
 //    bool                        explicitUserSizeOfFifo;
     t_Handle                    h_IpReassemblyManip;
-    t_Handle                    h_IpReassemblyTree;
+    t_Handle                    h_CapwapReassemblyManip;
+    t_Handle                    h_ReassemblyTree;
     uint64_t                    fmMuramPhysBaseAddr;
 #if (DPAA_VERSION >= 11)
     bool                        vspe;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port_dsar.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port_dsar.h
index 42eb7f8..6b6c1da 100755
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port_dsar.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port_dsar.h
@@ -33,10 +33,10 @@
 /**************************************************************************//**
  @File          fm_port_dsar.h
 
- @Description   Deep Sleep Auto Response project - common module header file.
+ @Description   Deep Sleep Auto Response project - common module header file.               
 
                 Author - Eyal Harari
-
+                
  @Cautions      See the FMan Controller spec and design document for more information.
 *//***************************************************************************/
 
@@ -47,7 +47,7 @@
 
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
-#endif /* defined(__MWERKS__) && ... */
+#endif /* defined(__MWERKS__) && ... */ 
 
 /**************************************************************************//**
  @Description   Deep Sleep Auto Response VLAN-IPv4 Binding Table (for ARP/ICMPv4)
@@ -112,7 +112,7 @@ typedef _Packed struct
  @Description   Deep Sleep Auto Response VLAN-IPv4 Binding Table (for ARP/ICMPv4)
                 Refer to the FMan Controller spec for more details.
 *//***************************************************************************/
-typedef _Packed struct
+typedef _Packed struct 
 {
     uint32_t ipv4Addr; /*!< 32 bit IPv4 Address. */
 	uint16_t vlanId;   /*!< 12 bits VLAN ID. The 4 left-most bits should be cleared                      */
@@ -173,11 +173,11 @@ typedef _Packed struct
                 The 4 left-most bits (15:12) of the VlanId parameter are control flags.
                 Flags[3:1] (VlanId[15:13]): Reserved, should be cleared.
                 Flags[0] (VlanId[12]): Temporary address.
-                 0 - Assigned IP address.
-                 1- Temporary (tentative) IP address.
+                 0 - Assigned IP address.
+                 1- Temporary (tentative) IP address.
                 Refer to the FMan Controller spec for more details.
 *//***************************************************************************/
-typedef _Packed struct
+typedef _Packed struct 
 {
     uint32_t ipv6Addr[4];  /*!< 3 * 32 bit IPv4 Address.                                                    */
 	uint16_t resFlags:4;   /*!< reserved flags. should be cleared                                           */
@@ -281,7 +281,7 @@ typedef _Packed struct
 } _PackedType t_IcmpV6EchoHdr;
 
 /**************************************************************************//**
- @Description   Internet Control Message Protocol (ICMPv6)
+ @Description   Internet Control Message Protocol (ICMPv6) 
                 Neighbor Solicitation/Advertisement header
                 The fields names are taken from RFC 4861.
                 The R/S/O fields are valid for Neighbor Advertisement only
@@ -351,7 +351,7 @@ typedef _Packed struct
 
 /**************************************************************************//**
 @Description    Deep Sleep Auto Response SNMP OIDs table entry
-
+                 
 *//***************************************************************************/
 typedef struct {
     uint16_t oidSize;     /**< Size in octets of the OID. */
@@ -389,7 +389,7 @@ typedef struct
 
 /**************************************************************************//**
 @Description    Deep Sleep Auto Response SNMP statistics table
-
+                 
 *//***************************************************************************/
 typedef struct {
     uint32_t snmpErrCnt;  /**< Counts SNMP errors (wrong version, BER encoding, format). */
@@ -420,7 +420,7 @@ typedef struct
 
 /**************************************************************************//**
 @Description    Deep Sleep Auto Response (Common) Statistics
-
+                 
 *//***************************************************************************/
 typedef _Packed struct {
 	uint32_t dsarDiscarded;
@@ -439,7 +439,7 @@ typedef _Packed struct {
 
 /**************************************************************************//**
 @Description    Deep Sleep Auto Response TCP/UDP port filter table entry
-
+                 
 *//***************************************************************************/
 typedef _Packed struct {
 	uint32_t	Ports;
@@ -447,10 +447,10 @@ typedef _Packed struct {
 } _PackedType t_PortTblEntry;
 
 
-
+					
 /**************************************************************************//**
 @Description    Deep Sleep Auto Response Common Parameters Descriptor
-
+                 
 *//***************************************************************************/
 typedef _Packed struct {
 	uint8_t   arTxPort;            /* 0x00 0-7 Auto Response Transmit Port number            */
@@ -480,7 +480,7 @@ typedef _Packed struct {
 
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
-#endif /* defined(__MWERKS__) && ... */
+#endif /* defined(__MWERKS__) && ... */ 
 
 /* t_ArCommonDesc.filterControl bits */
 #define	IP_PROT_TBL_PASS_MASK	0x08
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port_im.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port_im.c
index 7f70cc9..8de8f5f 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port_im.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port_im.c
@@ -39,6 +39,7 @@
 #include "std_ext.h"
 #include "string_ext.h"
 #include "error_ext.h"
+#include "memcpy_ext.h"
 #include "fm_muram_ext.h"
 
 #include "fm_port.h"
@@ -140,7 +141,7 @@ t_Error FmPortImRx(t_FmPort *p_FmPort)
     uint32_t                bdStatus;
     volatile uint8_t        buffPos;
     uint16_t                length;
-    uint16_t                errors/*, reportErrors*/;
+    uint16_t                errors;
     uint8_t                 *p_CurData, *p_Data;
     uint32_t                flags;
 
@@ -168,7 +169,6 @@ t_Error FmPortImRx(t_FmPort *p_FmPort)
         if (p_FmPort->im.firstBdOfFrameId == IM_ILEGAL_BD_ID)
             p_FmPort->im.firstBdOfFrameId = p_FmPort->im.currBdId;
 
-        errors = 0;
         p_CurData = BdBufferGet(p_FmPort->im.rxPool.f_PhysToVirt, BD_GET(p_FmPort->im.currBdId));
         h_CurrUserPriv = p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId];
         length = (uint16_t)((bdStatus & BD_L) ?
@@ -199,9 +199,8 @@ t_Error FmPortImRx(t_FmPort *p_FmPort)
         WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.offsetOut, (uint16_t)(p_FmPort->im.currBdId<<4));
         /* Pass the buffer if one of the conditions is true:
         - There are no errors
-        - This is a part of a larger frame ( the application has already received some buffers )
-        - There is an error, but it was defined to be passed anyway. */
-        if ((buffPos != SINGLE_BUF) || !errors || (errors & (uint16_t)(BD_ERROR_PASS_FRAME>>16)))
+        - This is a part of a larger frame ( the application has already received some buffers ) */
+        if ((buffPos != SINGLE_BUF) || !errors)
         {
             if (p_FmPort->im.f_RxStore(p_FmPort->h_App,
                                        p_CurData,
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fman_port.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fman_port.c
index ec261c4..60acbf3 100755
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fman_port.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fman_port.c
@@ -856,8 +856,6 @@ int fman_port_disable(const struct fman_port *port)
         if (count == 0)
         {
             /* Timeout */
-            iowrite32be(ioread32be(&port->qmi_regs->fmqm_pnc) |
-                QMI_PORT_CFG_EN, &port->qmi_regs->fmqm_pnc);
             failure = TRUE;
         }
     }
@@ -876,10 +874,6 @@ int fman_port_disable(const struct fman_port *port)
     if (count == 0)
     {
         /* Timeout */
-        iowrite32be(ioread32be(&port->qmi_regs->fmqm_pnc) |
-            QMI_PORT_CFG_EN, &port->qmi_regs->fmqm_pnc);
-        iowrite32be(ioread32be(bmi_cfg_reg) | BMI_PORT_CFG_EN,
-            bmi_cfg_reg);
         failure = TRUE;
     }
 
@@ -1520,7 +1514,7 @@ int fman_port_add_congestion_grps(struct fman_port *port,
         max_grp_map_num = 1;
         if (port->fm_rev_maj != 4)
             return -EINVAL;
-        grp_map_reg = &port->bmi_regs->oh.fmbm_ocgm;
+        grp_map_reg = port->bmi_regs->oh.fmbm_ocgm;
         break;
     default:
         return -EINVAL;
@@ -1557,7 +1551,7 @@ int fman_port_remove_congestion_grps(struct fman_port *port,
         max_grp_map_num = 1;
         if (port->fm_rev_maj != 4)
             return -EINVAL;
-        grp_map_reg = &port->bmi_regs->oh.fmbm_ocgm;
+        grp_map_reg = port->bmi_regs->oh.fmbm_ocgm;
         break;
     default:
         return -EINVAL;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/Makefile b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/Makefile
index f804c51..e7dfc59 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/Makefile
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/Makefile
@@ -1,14 +1,14 @@
 #
 # Makefile for the Freescale Ethernet controllers
 #
-EXTRA_CFLAGS           += -DVERSION=\"\"
+ccflags-y           += -DVERSION=\"\"
 #
 #Include netcomm SW specific definitions
 include $(srctree)/drivers/net/ethernet/freescale/fman/ncsw_config.mk
 
 NCSW_FM_INC = $(srctree)/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc
 
-EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+ccflags-y += -I$(NCSW_FM_INC)
 
 obj-y		+= fsl-ncsw-RTC.o
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fm_rtc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fm_rtc.c
index 2745dc4..727d5c8 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fm_rtc.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fm_rtc.c
@@ -209,9 +209,9 @@ t_Error FM_RTC_Init(t_Handle h_FmRtc)
 
     /* find source clock frequency in Mhz */
     if (p_Rtc->p_RtcDriverParam->src_clk != E_FMAN_RTC_SOURCE_CLOCK_SYSTEM)
-         p_Rtc->srcClkFreqMhz = p_Rtc->p_RtcDriverParam->ext_src_clk_freq;
+        p_Rtc->srcClkFreqMhz = p_Rtc->p_RtcDriverParam->ext_src_clk_freq;
     else
-        p_Rtc->srcClkFreqMhz = (uint32_t)(FmGetClockFreq(p_Rtc->h_Fm)/2);
+        p_Rtc->srcClkFreqMhz = (uint32_t)(FmGetMacClockFreq(p_Rtc->h_Fm));
 
     /* if timer in Master mode Initialize TMR_CTRL */
     /* We want the counter (TMR_CNT) to count in nano-seconds */
@@ -629,7 +629,7 @@ t_Error FM_RTC_SetCurrentTime(t_Handle h_FmRtc, uint64_t ts)
     SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
 
     ts = ts/p_Rtc->clockPeriodNanoSec;
-    fman_rtc_set_timer(p_Rtc->p_MemMap, (unsigned long)ts);
+    fman_rtc_set_timer(p_Rtc->p_MemMap, (int64_t)ts);
 
     return E_OK;
 }
@@ -690,52 +690,3 @@ t_Error FM_RTC_DisableInterrupt(t_Handle h_FmRtc, uint32_t events)
 	return E_OK;
 }
 #endif
-
-/*****************************************************************************/
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-t_Error FM_RTC_DumpRegs(t_Handle h_FmRtc)
-{
-    t_FmRtc         *p_Rtc = (t_FmRtc *)h_FmRtc;
-    struct rtc_regs   *p_MemMap = p_Rtc->p_MemMap;
-    int             i = 0;
-
-    DECLARE_DUMP;
-
-    if (p_MemMap)
-    {
-
-        DUMP_TITLE(p_MemMap, ("RTC:"));
-        DUMP_VAR(p_MemMap, tmr_id);
-        DUMP_VAR(p_MemMap, tmr_id2);
-        DUMP_VAR(p_MemMap, tmr_ctrl);
-        DUMP_VAR(p_MemMap, tmr_tevent);
-        DUMP_VAR(p_MemMap, tmr_temask);
-        DUMP_VAR(p_MemMap, tmr_cnt_h);
-        DUMP_VAR(p_MemMap, tmr_cnt_l);
-        DUMP_VAR(p_MemMap, tmr_ctrl);
-        DUMP_VAR(p_MemMap, tmr_add);
-        DUMP_VAR(p_MemMap, tmr_acc);
-        DUMP_VAR(p_MemMap, tmr_prsc);
-        DUMP_VAR(p_MemMap, tmr_off_h);
-        DUMP_VAR(p_MemMap, tmr_off_l);
-
-        DUMP_SUBSTRUCT_ARRAY(i, 2)
-        {
-            DUMP_VAR(p_MemMap, tmr_alarm[i].tmr_alarm_h);
-            DUMP_VAR(p_MemMap, tmr_alarm[i].tmr_alarm_l);
-        }
-        DUMP_SUBSTRUCT_ARRAY(i, 2)
-        {
-            DUMP_VAR(p_MemMap, tmr_fiper[i]);
-            DUMP_VAR(p_MemMap, tmr_fiper[i]);
-        }
-        DUMP_SUBSTRUCT_ARRAY(i, 2)
-        {
-            DUMP_VAR(p_MemMap, tmr_etts[i].tmr_etts_l);
-            DUMP_VAR(p_MemMap, tmr_etts[i].tmr_etts_l);
-        }
-    }
-
-    return E_OK;
-}
-#endif /* (defined(DEBUG_ERRORS) && ... */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/Makefile b/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/Makefile
index 669e940..47feae7 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/Makefile
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/Makefile
@@ -1,14 +1,14 @@
 #
 # Makefile for the Freescale Ethernet controllers
 #
-EXTRA_CFLAGS           += -DVERSION=\"\"
+ccflags-y           += -DVERSION=\"\"
 #
 #Include netcomm SW specific definitions
 include $(srctree)/drivers/net/ethernet/freescale/fman/ncsw_config.mk
 
 NCSW_FM_INC = $(srctree)/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc
 
-EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+ccflags-y += -I$(NCSW_FM_INC)
 
 obj-y		+= fsl-ncsw-sp.o
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fm_sp.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fm_sp.c
index 910874e..0994f34 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fm_sp.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fm_sp.c
@@ -525,7 +525,7 @@ t_Error FM_VSP_Init(t_Handle h_FmVsp)
     }
     else
         fm_vsp_params.buf_pool_depletion.buf_pool_depletion_enabled = FALSE;
-
+ 
     if (p_FmVspEntry->p_FmVspEntryDriverParams->p_BackupBmPools)
     {
         fm_vsp_params.backup_pools.num_backup_pools = p_FmVspEntry->p_FmVspEntryDriverParams->p_BackupBmPools->numOfBackupPools;
@@ -549,7 +549,7 @@ t_Error FM_VSP_Init(t_Handle h_FmVsp)
     ASSERT_COND(p_FmVspEntry->p_FmSpRegsBase);
     ASSERT_COND(fm_vsp_params.int_context);
     ASSERT_COND(fm_vsp_params.buf_margins);
-    ASSERT_COND(IN_RANGE(0, absoluteProfileId, FM_VSP_MAX_NUM_OF_ENTRIES));
+    ASSERT_COND((absoluteProfileId <= FM_VSP_MAX_NUM_OF_ENTRIES));
 
     /* Set all registers related to VSP */
     fman_vsp_init(p_FmVspEntry->p_FmSpRegsBase, absoluteProfileId, &fm_vsp_params,FM_PORT_MAX_NUM_OF_EXT_POOLS, BM_MAX_NUM_OF_POOLS, FM_MAX_NUM_OF_PFC_PRIORITIES);
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
index 2bdaf113..a322233 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
@@ -47,6 +47,9 @@
 #include "fm_common.h"
 #include "fm_ipc.h"
 #include "fm.h"
+#ifndef CONFIG_ARM64
+#include <asm/mpc85xx.h>
+#endif /* !CONFIG_ARM64*/
 #include "fsl_fman.h"
 
 
@@ -152,7 +155,7 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
     if (!p_Fm->p_FmStateStruct->totalFifoSize ||
         (p_Fm->p_FmStateStruct->totalFifoSize > BMI_MAX_FIFO_SIZE))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                     ("totalFifoSize (curr - %d) has to be in the range 256 - %d",
+                     ("totalFifoSize (currently defined as %d) has to be in the range of 256 to %d",
                       p_Fm->p_FmStateStruct->totalFifoSize,
                       BMI_MAX_FIFO_SIZE));
     if (!p_Fm->p_FmStateStruct->totalNumOfTasks ||
@@ -296,6 +299,7 @@ static void    DmaErrEvent(t_Fm *p_Fm)
     {
         com_id = fman_get_dma_com_id(dma_rg);
         hardwarePortId = (uint8_t)(((com_id & DMA_TRANSFER_PORTID_MASK) >> DMA_TRANSFER_PORTID_SHIFT));
+        ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
         HW_PORT_ID_TO_SW_PORT_ID(relativePortId, hardwarePortId);
         tnum = (uint8_t)((com_id & DMA_TRANSFER_TNUM_MASK) >> DMA_TRANSFER_TNUM_SHIFT);
         liodn = (uint16_t)(com_id & DMA_TRANSFER_LIODN_MASK);
@@ -395,18 +399,20 @@ static t_Error ClearIRam(t_Fm *p_Fm)
 {
     t_FMIramRegs    *p_Iram;
     int             i;
+    int             iram_size;
 
     ASSERT_COND(p_Fm);
     p_Iram = (t_FMIramRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_IMEM);
+    iram_size = FM_IRAM_SIZE(p_Fm->p_FmStateStruct->revInfo.majorRev,p_Fm->p_FmStateStruct->revInfo.minorRev);
 
     /* Enable the auto-increment */
     WRITE_UINT32(p_Iram->iadd, IRAM_IADD_AIE);
     while (GET_UINT32(p_Iram->iadd) != IRAM_IADD_AIE) ;
 
-    for (i=0; i < (FM_IRAM_SIZE/4); i++)
+    for (i=0; i < (iram_size/4); i++)
         WRITE_UINT32(p_Iram->idata, 0xffffffff);
 
-    WRITE_UINT32(p_Iram->iadd, FM_IRAM_SIZE - 4);
+    WRITE_UINT32(p_Iram->iadd, iram_size - 4);
     CORE_MemoryBarrier();
     while (GET_UINT32(p_Iram->idata) != 0xffffffff) ;
 
@@ -511,8 +517,7 @@ static t_Error FwNotResetErratumBugzilla6173WA(t_Fm *p_Fm)
     /*************************************/
     /* Load FMan-Controller code to IRAM */
     /*************************************/
-    if (ClearIRam(p_Fm) != E_OK)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+    ClearIRam(p_Fm);
     if (p_Fm->firmware.p_Code &&
         (LoadFmanCtrlCode(p_Fm) != E_OK))
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
@@ -699,7 +704,7 @@ static uint8_t AllocVSPsForPartition(t_Handle  h_Fm, uint8_t base, uint8_t numOf
             RETURN_ERROR(MAJOR, err, NO_MSG);
         else
             memcpy((uint8_t*)&p_Fm->partVSPBase, reply.replyBody, sizeof(uint8_t));
-        if (p_Fm->partVSPBase == ILLEGAL_BASE)
+        if (p_Fm->partVSPBase == (uint8_t)(ILLEGAL_BASE))
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
     if (p_Fm->guestId != NCSW_MASTER_ID)
@@ -976,7 +981,7 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
             t_FmIpcResourceAllocParams  ipcAllocParams;
             uint8_t                     vspBase;
             memcpy(&ipcAllocParams, p_IpcMsg->msgBody, sizeof(t_FmIpcResourceAllocParams));
-            vspBase =  AllocVSPsForPartition(h_Fm, ipcAllocParams.base, ipcAllocParams.num, ipcAllocParams.guestId);
+            vspBase =  AllocVSPsForPartition(h_Fm, (uint8_t)ipcAllocParams.base, (uint8_t)ipcAllocParams.num, ipcAllocParams.guestId);
             memcpy(p_IpcReply->replyBody, (uint8_t*)&vspBase, sizeof(uint8_t));
             *p_ReplyLength = sizeof(uint32_t) + sizeof(uint8_t);
             break;
@@ -985,7 +990,7 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
         {
             t_FmIpcResourceAllocParams   ipcAllocParams;
             memcpy(&ipcAllocParams, p_IpcMsg->msgBody, sizeof(t_FmIpcResourceAllocParams));
-            FreeVSPsForPartition(h_Fm, ipcAllocParams.base, ipcAllocParams.num, ipcAllocParams.guestId);
+            FreeVSPsForPartition(h_Fm, (uint8_t)ipcAllocParams.base, (uint8_t)ipcAllocParams.num, ipcAllocParams.guestId);
             break;
         }
         case (FM_VSP_SET_PORT_WINDOW) :
@@ -1035,6 +1040,7 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
 
             /* Get clock frequency */
             ipcParams.fmClkFreq = p_Fm->p_FmStateStruct->fmClkFreq;
+            ipcParams.fmMacClkFreq = p_Fm->p_FmStateStruct->fmMacClkFreq;
 
             fman_get_revision(p_Fm->p_FmFpmRegs,&ipcParams.majorRev,&ipcParams.minorRev);
 
@@ -1217,8 +1223,14 @@ t_Error Fm10GTxEccWorkaround(t_Handle h_Fm, uint8_t macId)
     SANITY_CHECK_RETURN_ERROR((macId == 0), E_NOT_SUPPORTED);
     SANITY_CHECK_RETURN_ERROR(IsFmanCtrlCodeLoaded(p_Fm), E_INVALID_STATE);
 
-    SW_PORT_ID_TO_HW_PORT_ID(rxHardwarePortId, e_FM_PORT_TYPE_RX_10G, macId);
-    SW_PORT_ID_TO_HW_PORT_ID(txHardwarePortId, e_FM_PORT_TYPE_TX_10G, macId);
+    rxHardwarePortId = SwPortIdToHwPortId(e_FM_PORT_TYPE_RX_10G,
+                                    macId,
+                                    p_Fm->p_FmStateStruct->revInfo.majorRev,
+                                    p_Fm->p_FmStateStruct->revInfo.minorRev);
+    txHardwarePortId = SwPortIdToHwPortId(e_FM_PORT_TYPE_TX_10G,
+                                    macId,
+                                    p_Fm->p_FmStateStruct->revInfo.majorRev,
+                                    p_Fm->p_FmStateStruct->revInfo.minorRev);
     if ((p_Fm->p_FmStateStruct->portsTypes[rxHardwarePortId] != e_FM_PORT_TYPE_DUMMY) ||
         (p_Fm->p_FmStateStruct->portsTypes[txHardwarePortId] != e_FM_PORT_TYPE_DUMMY))
         RETURN_ERROR(MAJOR, E_INVALID_STATE,
@@ -1517,7 +1529,10 @@ t_Error FmVSPAllocForPort (t_Handle        h_Fm,
         RETURN_ERROR(MINOR, E_FULL, ("No profiles."));
     }
 
-    SW_PORT_ID_TO_HW_PORT_ID(hardwarePortId, portType, portId)
+    hardwarePortId = SwPortIdToHwPortId(portType,
+                                    portId,
+                                    p_Fm->p_FmStateStruct->revInfo.majorRev,
+                                    p_Fm->p_FmStateStruct->revInfo.minorRev);
     HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
 
     p_Fm->p_FmSp->portsMapping[swPortIndex].numOfProfiles = numOfVSPs;
@@ -1542,11 +1557,14 @@ t_Error FmVSPFreeForPort(t_Handle        h_Fm,
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
 
-    SW_PORT_ID_TO_HW_PORT_ID(hardwarePortId, portType, portId)
+    hardwarePortId = SwPortIdToHwPortId(portType,
+                                    portId,
+                                    p_Fm->p_FmStateStruct->revInfo.majorRev,
+                                    p_Fm->p_FmStateStruct->revInfo.minorRev);
     HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
 
-    numOfVSPs = p_Fm->p_FmSp->portsMapping[swPortIndex].numOfProfiles;
-    first = p_Fm->p_FmSp->portsMapping[swPortIndex].profilesBase;
+    numOfVSPs = (uint8_t)p_Fm->p_FmSp->portsMapping[swPortIndex].numOfProfiles;
+    first = (uint8_t)p_Fm->p_FmSp->portsMapping[swPortIndex].profilesBase;
 
     intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
     for (i = first; i < first + numOfVSPs; i++)
@@ -2004,7 +2022,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm, t_FmInterModulePortInitParams *p_PortP
     }
     p_Fm->p_FmStateStruct->portsTypes[hardwarePortId] = p_PortParams->portType;
 
-    err = FmSetNumOfTasks(p_Fm, p_PortParams->hardwarePortId, &p_PortParams->numOfTasks, &p_PortParams->numOfExtraTasks, TRUE);
+    err = FmSetNumOfTasks(p_Fm, hardwarePortId, &p_PortParams->numOfTasks, &p_PortParams->numOfExtraTasks, TRUE);
     if (err)
     {
         XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
@@ -2055,7 +2073,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm, t_FmInterModulePortInitParams *p_PortP
 #endif /* FM_LOW_END_RESTRICTION */
 
     err = FmSetSizeOfFifo(p_Fm,
-                          p_PortParams->hardwarePortId,
+                          hardwarePortId,
                           &p_PortParams->sizeOfFifo,
                           &p_PortParams->extraSizeOfFifo,
                           TRUE);
@@ -2066,7 +2084,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm, t_FmInterModulePortInitParams *p_PortP
     }
 
     err = FmSetNumOfOpenDmas(p_Fm,
-                             p_PortParams->hardwarePortId,
+                             hardwarePortId,
                              &p_PortParams->numOfOpenDmas,
                              &p_PortParams->numOfExtraOpenDmas,
                              TRUE);
@@ -2381,10 +2399,10 @@ t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
 
     err = (t_Error)fman_reset_mac(fpm_rg, macId, !!(type == e_FM_MAC_10G));
 
-    if (err == E_INVALID_VALUE)
-                RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Illegal MAC Id"));
-    else if (err == E_TIMEOUT)
+    if (err == -EBUSY)
         return ERROR_CODE(E_TIMEOUT);
+    else if (err)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal MAC ID"));
 
     return E_OK;
 }
@@ -2457,6 +2475,13 @@ uint16_t FmGetClockFreq(t_Handle h_Fm)
     return p_Fm->p_FmStateStruct->fmClkFreq;
 }
 
+uint16_t FmGetMacClockFreq(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    return p_Fm->p_FmStateStruct->fmMacClkFreq;
+}
+
 uint32_t FmGetTimeStampScale(t_Handle h_Fm)
 {
     t_Fm                *p_Fm = (t_Fm*)h_Fm;
@@ -2481,7 +2506,8 @@ uint32_t FmGetTimeStampScale(t_Handle h_Fm)
                                      &replyLength,
                                      NULL,
                                      NULL)) != E_OK)
-            RETURN_ERROR(MINOR, err, NO_MSG);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+
         if (replyLength != (sizeof(uint32_t) + sizeof(uint32_t)))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
 
@@ -2492,9 +2518,7 @@ uint32_t FmGetTimeStampScale(t_Handle h_Fm)
              p_Fm->baseAddr)
     {
         if (!(GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_tsc1) & FPM_TS_CTL_EN))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("timestamp is not enabled!"));
-
-        return p_Fm->p_FmStateStruct->count1MicroBit;
+             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("timestamp is not enabled!"));
     }
     else if (p_Fm->guestId != NCSW_MASTER_ID)
         DBG(WARNING, ("No IPC - can't validate FM if timestamp enabled."));
@@ -2559,8 +2583,6 @@ t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
     uint32_t                sizeOfFifo = *p_SizeOfFifo, extraSizeOfFifo = *p_ExtraSizeOfFifo;
     uint16_t                currentVal = 0, currentExtraVal = 0;
 
-    ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
-
     if ((p_Fm->guestId != NCSW_MASTER_ID) &&
         !p_Fm->baseAddr &&
         p_Fm->h_IpcSessions[0])
@@ -2595,18 +2617,6 @@ t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
              p_Fm->baseAddr)
     {
         DBG(WARNING, ("No IPC - can't validate FM total-fifo size."));
-
-#ifndef FM_NO_GUARANTEED_RESET_VALUES
-        if (!sizeOfFifo)
-        /* first config without explicit value: Do Nothing - reset value shouldn't be
-           changed, read register for port save */
-    {
-            *p_ExtraSizeOfFifo = fman_get_size_of_extra_fifo(bmi_rg, hardwarePortId);
-            *p_SizeOfFifo = fman_get_size_of_fifo(bmi_rg, hardwarePortId);
-    }
-    else
-            /* whether it is the first time with explicit value, or runtime "set" - write register */
-#endif /* !FM_NO_GUARANTEED_RESET_VALUES */
         fman_set_size_of_fifo(bmi_rg, hardwarePortId, sizeOfFifo, extraSizeOfFifo);
     }
     else if (p_Fm->guestId != NCSW_MASTER_ID)
@@ -2621,63 +2631,35 @@ t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
         currentVal = fman_get_size_of_fifo(bmi_rg, hardwarePortId);
     }
 
-#ifndef FM_NO_GUARANTEED_RESET_VALUES
-    /* it's illegal to be in a state where this is not the first set and no value is specified */
-    ASSERT_COND(initialConfig || sizeOfFifo);
-    if (!sizeOfFifo)
+    if (extraSizeOfFifo > currentExtraVal)
     {
-        /* !sizeOfFifo - first configuration according to values in regs.
-         * - read the current FIFO  and extra FIFO size  */
-        currentExtraVal = fman_get_size_of_extra_fifo(bmi_rg, hardwarePortId);
-        currentVal = fman_get_size_of_fifo(bmi_rg, hardwarePortId);
-        /* This is the first configuration and user did not specify value (!numOfTasks),
-         * reset values will be used and we just save these values for resource management */
-        if (currentExtraVal)
-        {
-            if (!p_Fm->p_FmStateStruct->extraFifoPoolSize)
-                /* if this is the first time a port requires extraFifoPoolSize, the total extraFifoPoolSize
-                 * must be initialized to 1 buffer per port
-                 */
-                p_Fm->p_FmStateStruct->extraFifoPoolSize = FM_MAX_NUM_OF_RX_PORTS*BMI_FIFO_UNITS;
+        if (extraSizeOfFifo && !p_Fm->p_FmStateStruct->extraFifoPoolSize)
+            /* if this is the first time a port requires extraFifoPoolSize, the total extraFifoPoolSize
+             * must be initialized to 1 buffer per port
+             */
+            p_Fm->p_FmStateStruct->extraFifoPoolSize = FM_MAX_NUM_OF_RX_PORTS*BMI_FIFO_UNITS;
 
-            p_Fm->p_FmStateStruct->extraFifoPoolSize = MAX(p_Fm->p_FmStateStruct->extraFifoPoolSize, extraSizeOfFifo);
-        }
-        if ((p_Fm->p_FmStateStruct->accumulatedFifoSize + currentVal) >
-            (p_Fm->p_FmStateStruct->totalFifoSize - p_Fm->p_FmStateStruct->extraFifoPoolSize))
-            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Total port's fifo size and extra size exceed total available FIFO size."));
+        p_Fm->p_FmStateStruct->extraFifoPoolSize = MAX(p_Fm->p_FmStateStruct->extraFifoPoolSize, extraSizeOfFifo);
 
-        p_Fm->p_FmStateStruct->accumulatedFifoSize += currentVal;
-
-        *p_SizeOfFifo = currentVal;
-        *p_ExtraSizeOfFifo = currentExtraVal;
-        return E_OK;
     }
-    /* else: user requires a specific value.
-         * If this is the first configuration call, (numOfTasks != 0) currentVal & currentExtraVal are set to "0",
-         * otherwise they hold the value written in the register.
-         */
-#endif /* !FM_NO_GUARANTEED_RESET_VALUES */
-        if (extraSizeOfFifo > currentExtraVal)
-        {
-            if (extraSizeOfFifo && !p_Fm->p_FmStateStruct->extraFifoPoolSize)
-                /* if this is the first time a port requires extraFifoPoolSize, the total extraFifoPoolSize
-                 * must be initialized to 1 buffer per port
-                 */
-                p_Fm->p_FmStateStruct->extraFifoPoolSize = FM_MAX_NUM_OF_RX_PORTS*BMI_FIFO_UNITS;
 
-            p_Fm->p_FmStateStruct->extraFifoPoolSize = MAX(p_Fm->p_FmStateStruct->extraFifoPoolSize, extraSizeOfFifo);
-        }
-
-        /* check that there are enough uncommitted fifo size */
-        if ((p_Fm->p_FmStateStruct->accumulatedFifoSize - currentVal + sizeOfFifo) >
-            (p_Fm->p_FmStateStruct->totalFifoSize - p_Fm->p_FmStateStruct->extraFifoPoolSize))
-            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested fifo size and extra size exceed total FIFO size."));
-        else
-        {
-            /* update accumulated */
-            ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedFifoSize >= currentVal);
-            p_Fm->p_FmStateStruct->accumulatedFifoSize -= currentVal;
-            p_Fm->p_FmStateStruct->accumulatedFifoSize += sizeOfFifo;
+    /* check that there are enough uncommitted fifo size */
+    if ((p_Fm->p_FmStateStruct->accumulatedFifoSize - currentVal + sizeOfFifo) >
+        (p_Fm->p_FmStateStruct->totalFifoSize - p_Fm->p_FmStateStruct->extraFifoPoolSize)){
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE,
+            ("Port request fifo size + accumulated size > total FIFO size:"));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+            ("port 0x%x requested %d bytes, extra size = %d, accumulated size = %d total size = %d",
+                hardwarePortId, sizeOfFifo, p_Fm->p_FmStateStruct->extraFifoPoolSize,
+                p_Fm->p_FmStateStruct->accumulatedFifoSize,
+                p_Fm->p_FmStateStruct->totalFifoSize));
+    }
+    else
+    {
+        /* update accumulated */
+        ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedFifoSize >= currentVal);
+        p_Fm->p_FmStateStruct->accumulatedFifoSize -= currentVal;
+        p_Fm->p_FmStateStruct->accumulatedFifoSize += sizeOfFifo;
         fman_set_size_of_fifo(bmi_rg, hardwarePortId, sizeOfFifo, extraSizeOfFifo);
     }
 
@@ -2733,17 +2715,6 @@ t_Error FmSetNumOfTasks(t_Handle    h_Fm,
     {
         DBG(WARNING, ("No IPC - can't validate FM total-num-of-tasks."));
 
-#ifndef FM_NO_GUARANTEED_RESET_VALUES
-        if (!numOfTasks)
-        /* first config without explicit value: Do Nothing - reset value shouldn't be
-           changed, read register for port save */
-    {
-           *p_NumOfTasks = fman_get_num_of_tasks(bmi_rg, hardwarePortId);
-           *p_NumOfExtraTasks = fman_get_num_extra_tasks(bmi_rg, hardwarePortId);
-    }
-    else
-            /* whether it is the first time with explicit value, or runtime "set" - write register */
-#endif /* !FM_NO_GUARANTEED_RESET_VALUES */
         fman_set_num_of_tasks(bmi_rg, hardwarePortId, numOfTasks, numOfExtraTasks);
     }
     else if (p_Fm->guestId != NCSW_MASTER_ID)
@@ -2758,50 +2729,22 @@ t_Error FmSetNumOfTasks(t_Handle    h_Fm,
         currentExtraVal = fman_get_num_extra_tasks(bmi_rg, hardwarePortId);
     }
 
-#ifndef FM_NO_GUARANTEED_RESET_VALUES
-    /* it's illegal to be in a state where this is not the first set and no value is specified */
-    ASSERT_COND(initialConfig || numOfTasks);
-    if (!numOfTasks)
-    {
-        /* !numOfTasks - first configuration according to values in regs.
-         * - read the current number of tasks */
-        currentVal = fman_get_num_of_tasks(bmi_rg, hardwarePortId);
-        currentExtraVal = fman_get_num_extra_tasks(bmi_rg, hardwarePortId);
-        /* This is the first configuration and user did not specify value (!numOfTasks),
-         * reset values will be used and we just save these values for resource management */
+    if (numOfExtraTasks > currentExtraVal)
          p_Fm->p_FmStateStruct->extraTasksPoolSize =
-                    (uint8_t)MAX(p_Fm->p_FmStateStruct->extraTasksPoolSize, currentExtraVal);
-         if ((p_Fm->p_FmStateStruct->accumulatedNumOfTasks + currentVal) >
-                 (p_Fm->p_FmStateStruct->totalNumOfTasks - p_Fm->p_FmStateStruct->extraTasksPoolSize))
-             RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
-                                      ("Total ports' numOfTasks and extra tasks pool for fm%d exceed total available numOfTasks.",
-                                       p_Fm->p_FmStateStruct->fmId));
-        p_Fm->p_FmStateStruct->accumulatedNumOfTasks += currentVal;
-        *p_NumOfTasks = currentVal;
-        *p_NumOfExtraTasks = currentExtraVal;
-        return E_OK;
-    }
-    /* else - user requires a specific value.
-         * If this is the first configuration call, (numOfTasks != 0) currentVal & currentExtraVal are set to "0",
-         * otherwise they hold the value written in the register.
-         */
-#endif /* !FM_NO_GUARANTEED_RESET_VALUES */
-        if (numOfExtraTasks > currentExtraVal)
-             p_Fm->p_FmStateStruct->extraTasksPoolSize =
-                 (uint8_t)MAX(p_Fm->p_FmStateStruct->extraTasksPoolSize, numOfExtraTasks);
-
-        /* check that there are enough uncommitted tasks */
-        if ((p_Fm->p_FmStateStruct->accumulatedNumOfTasks - currentVal + numOfTasks) >
-           (p_Fm->p_FmStateStruct->totalNumOfTasks - p_Fm->p_FmStateStruct->extraTasksPoolSize))
-            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
-                         ("Requested numOfTasks and extra tasks pool for fm%d exceed total numOfTasks.",
-                          p_Fm->p_FmStateStruct->fmId));
-        else
-        {
-            ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedNumOfTasks >= currentVal);
+             (uint8_t)MAX(p_Fm->p_FmStateStruct->extraTasksPoolSize, numOfExtraTasks);
+
+    /* check that there are enough uncommitted tasks */
+    if ((p_Fm->p_FmStateStruct->accumulatedNumOfTasks - currentVal + numOfTasks) >
+       (p_Fm->p_FmStateStruct->totalNumOfTasks - p_Fm->p_FmStateStruct->extraTasksPoolSize))
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
+                     ("Requested numOfTasks and extra tasks pool for fm%d exceed total numOfTasks.",
+                      p_Fm->p_FmStateStruct->fmId));
+    else
+    {
+        ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedNumOfTasks >= currentVal);
         /* update accumulated */
-            p_Fm->p_FmStateStruct->accumulatedNumOfTasks -= currentVal;
-            p_Fm->p_FmStateStruct->accumulatedNumOfTasks += numOfTasks;
+        p_Fm->p_FmStateStruct->accumulatedNumOfTasks -= currentVal;
+        p_Fm->p_FmStateStruct->accumulatedNumOfTasks += numOfTasks;
         fman_set_num_of_tasks(bmi_rg, hardwarePortId, numOfTasks, numOfExtraTasks);
     }
 
@@ -2856,8 +2799,8 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
     }
 #ifdef FM_HAS_TOTAL_DMAS
     else if (p_Fm->guestId != NCSW_MASTER_ID)
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
-                     ("running in guest-mode without IPC!"));
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("running in guest-mode without IPC!"));
+
 #else
     else if ((p_Fm->guestId != NCSW_MASTER_ID) &&
              p_Fm->baseAddr &&
@@ -2865,22 +2808,20 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
     {
         /*DBG(WARNING, ("No IPC - can't validate FM total-num-of-dmas."));*/
 
-#ifdef FM_NO_GUARANTEED_RESET_VALUES
         if (!numOfOpenDmas)
-    {
-         /* first config without explic it value: Do Nothing - reset value shouldn't be
-            changed, read register for port save */
-            *p_NumOfOpenDmas = fman_get_num_of_dmas(bmi_rg, hardwarePortId);
-            *p_NumOfExtraOpenDmas = fman_get_num_extra_dmas(bmi_rg, hardwarePortId);
-    }
-    else
+        {
+             /* first config without explic it value: Do Nothing - reset value shouldn't be
+                changed, read register for port save */
+                *p_NumOfOpenDmas = fman_get_num_of_dmas(bmi_rg, hardwarePortId);
+                *p_NumOfExtraOpenDmas = fman_get_num_extra_dmas(bmi_rg, hardwarePortId);
+        }
+        else
             /* whether it is the first time with explicit value, or runtime "set" - write register */
-#endif /* FM_NO_GUARANTEED_RESET_VALUES */
-        fman_set_num_of_open_dmas(bmi_rg,
-                               hardwarePortId,
-                               numOfOpenDmas,
-                               numOfExtraOpenDmas,
-                               p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas + p_Fm->p_FmStateStruct->extraOpenDmasPoolSize);
+            fman_set_num_of_open_dmas(bmi_rg,
+                                   hardwarePortId,
+                                   numOfOpenDmas,
+                                   numOfExtraOpenDmas,
+                                   p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas + p_Fm->p_FmStateStruct->extraOpenDmasPoolSize);
     }
     else if (p_Fm->guestId != NCSW_MASTER_ID)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
@@ -2948,7 +2889,7 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
             if (p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
             totalNumDmas = (uint8_t)(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas + p_Fm->p_FmStateStruct->extraOpenDmasPoolSize);
 #endif /* FM_HAS_TOTAL_DMAS */
-        fman_set_num_of_open_dmas(bmi_rg,
+            fman_set_num_of_open_dmas(bmi_rg,
                                hardwarePortId,
                                numOfOpenDmas,
                                numOfExtraOpenDmas,
@@ -2971,7 +2912,10 @@ t_Error FmVSPCheckRelativeProfile(t_Handle        h_Fm,
     ASSERT_COND(h_Fm);
     p_Fm = (t_Fm*)h_Fm;
 
-    SW_PORT_ID_TO_HW_PORT_ID(hardwarePortId, portType, portId)
+    hardwarePortId = SwPortIdToHwPortId(portType,
+                                    portId,
+                                    p_Fm->p_FmStateStruct->revInfo.majorRev,
+                                    p_Fm->p_FmStateStruct->revInfo.minorRev);
     ASSERT_COND(hardwarePortId);
     HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
 
@@ -3004,7 +2948,10 @@ t_Error FmVSPGetAbsoluteProfileId(t_Handle        h_Fm,
     if (err != E_OK)
         return err;
 
-    SW_PORT_ID_TO_HW_PORT_ID(hardwarePortId, portType, portId)
+    hardwarePortId = SwPortIdToHwPortId(portType,
+                                    portId,
+                                    p_Fm->p_FmStateStruct->revInfo.majorRev,
+                                    p_Fm->p_FmStateStruct->revInfo.minorRev);
     ASSERT_COND(hardwarePortId);
     HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
 
@@ -3163,6 +3110,7 @@ static t_Error InitGuestMode(t_Fm *p_Fm)
         memcpy((uint8_t*)&ipcParams, reply.replyBody, sizeof(t_FmIpcParams));
 
         p_Fm->p_FmStateStruct->fmClkFreq = ipcParams.fmClkFreq;
+        p_Fm->p_FmStateStruct->fmMacClkFreq = ipcParams.fmMacClkFreq;
         p_Fm->p_FmStateStruct->revInfo.majorRev = ipcParams.majorRev;
         p_Fm->p_FmStateStruct->revInfo.minorRev = ipcParams.minorRev;
     }
@@ -3182,7 +3130,7 @@ static t_Error InitGuestMode(t_Fm *p_Fm)
 
 #if (DPAA_VERSION >= 11)
     p_Fm->partVSPBase = AllocVSPsForPartition(p_Fm, p_Fm->partVSPBase, p_Fm->partNumOfVSPs, p_Fm->guestId);
-    if (p_Fm->partVSPBase == ILLEGAL_BASE)
+    if (p_Fm->partVSPBase == (uint8_t)(ILLEGAL_BASE))
         DBG(WARNING, ("partition VSPs allocation is FAILED"));
 #endif /* (DPAA_VERSION >= 11) */
 
@@ -3205,6 +3153,94 @@ static t_Error InitGuestMode(t_Fm *p_Fm)
     return E_OK;
 }
 
+static __inline__ enum fman_exceptions FmanExceptionTrans(e_FmExceptions exception)
+{
+    switch (exception) {
+            case  e_FM_EX_DMA_BUS_ERROR:
+                return E_FMAN_EX_DMA_BUS_ERROR;
+            case  e_FM_EX_DMA_READ_ECC:
+                return E_FMAN_EX_DMA_READ_ECC;
+            case  e_FM_EX_DMA_SYSTEM_WRITE_ECC:
+                return E_FMAN_EX_DMA_SYSTEM_WRITE_ECC;
+            case  e_FM_EX_DMA_FM_WRITE_ECC:
+                return E_FMAN_EX_DMA_FM_WRITE_ECC;
+            case  e_FM_EX_FPM_STALL_ON_TASKS:
+                return E_FMAN_EX_FPM_STALL_ON_TASKS;
+            case  e_FM_EX_FPM_SINGLE_ECC:
+                return E_FMAN_EX_FPM_SINGLE_ECC;
+            case  e_FM_EX_FPM_DOUBLE_ECC:
+                return E_FMAN_EX_FPM_DOUBLE_ECC;
+            case  e_FM_EX_QMI_SINGLE_ECC:
+                return E_FMAN_EX_QMI_SINGLE_ECC;
+            case  e_FM_EX_QMI_DOUBLE_ECC:
+                return E_FMAN_EX_QMI_DOUBLE_ECC;
+            case  e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID:
+                return E_FMAN_EX_QMI_DEQ_FROM_UNKNOWN_PORTID;
+            case  e_FM_EX_BMI_LIST_RAM_ECC:
+                return E_FMAN_EX_BMI_LIST_RAM_ECC;
+            case  e_FM_EX_BMI_STORAGE_PROFILE_ECC:
+                return E_FMAN_EX_BMI_STORAGE_PROFILE_ECC;
+            case  e_FM_EX_BMI_STATISTICS_RAM_ECC:
+                return E_FMAN_EX_BMI_STATISTICS_RAM_ECC;
+            case  e_FM_EX_BMI_DISPATCH_RAM_ECC:
+                return E_FMAN_EX_BMI_DISPATCH_RAM_ECC;
+            case  e_FM_EX_IRAM_ECC:
+                return E_FMAN_EX_IRAM_ECC;
+            case  e_FM_EX_MURAM_ECC:
+                return E_FMAN_EX_MURAM_ECC;
+            default:
+                return E_FMAN_EX_DMA_BUS_ERROR;
+        }
+}
+
+uint8_t SwPortIdToHwPortId(e_FmPortType type, uint8_t relativePortId, uint8_t majorRev, uint8_t minorRev)
+{
+	switch (type)
+	{
+		case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+		case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
+			CHECK_PORT_ID_OH_PORTS(relativePortId);
+			return (uint8_t)(BASE_OH_PORTID + (relativePortId));
+		case (e_FM_PORT_TYPE_RX):
+			CHECK_PORT_ID_1G_RX_PORTS(relativePortId);
+			return (uint8_t)(BASE_1G_RX_PORTID + (relativePortId));
+		case (e_FM_PORT_TYPE_RX_10G):
+                       /* The 10G port in T1024 (FMan Version 6.4) is the first port.
+                        * This is the reason why the 1G port offset is used.
+                        */
+                       if (majorRev == 6 && minorRev == 4)
+                       {
+                               CHECK_PORT_ID_1G_RX_PORTS(relativePortId);
+                               return (uint8_t)(BASE_1G_RX_PORTID + (relativePortId));
+                       }
+                       else
+                       {
+                               CHECK_PORT_ID_10G_RX_PORTS(relativePortId);
+                               return (uint8_t)(BASE_10G_RX_PORTID + (relativePortId));
+                       }
+		case (e_FM_PORT_TYPE_TX):
+			CHECK_PORT_ID_1G_TX_PORTS(relativePortId);
+			return (uint8_t)(BASE_1G_TX_PORTID + (relativePortId));
+		case (e_FM_PORT_TYPE_TX_10G):
+                       /* The 10G port in T1024 (FMan Version 6.4) is the first port.
+                        * This is the reason why the 1G port offset is used.
+                        */
+                       if (majorRev == 6 && minorRev == 4)
+                       {
+                               CHECK_PORT_ID_1G_TX_PORTS(relativePortId);
+                               return (uint8_t)(BASE_1G_TX_PORTID + (relativePortId));
+                       }
+                       else
+                       {
+                               CHECK_PORT_ID_10G_TX_PORTS(relativePortId);
+                               return (uint8_t)(BASE_10G_TX_PORTID + (relativePortId));
+                       }
+		default:
+			REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port type"));
+			return 0;
+	}
+}
+
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 t_Error FmDumpPortRegs (t_Handle h_Fm, uint8_t hardwarePortId)
 {
@@ -3212,6 +3248,8 @@ t_Error FmDumpPortRegs (t_Handle h_Fm, uint8_t hardwarePortId)
 
     DECLARE_DUMP;
 
+    ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
+
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(((p_Fm->guestId == NCSW_MASTER_ID) ||
                                p_Fm->baseAddr), E_INVALID_OPERATION);
@@ -3309,10 +3347,10 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->h_FmMuram                             = p_FmParam->h_FmMuram;
     p_Fm->h_App                                 = p_FmParam->h_App;
     p_Fm->p_FmStateStruct->fmClkFreq            = p_FmParam->fmClkFreq;
+    p_Fm->p_FmStateStruct->fmMacClkFreq         = p_FmParam->fmClkFreq / ((!p_FmParam->fmMacClkRatio)? 2: p_FmParam->fmMacClkRatio);
     p_Fm->f_Exception                           = p_FmParam->f_Exception;
     p_Fm->f_BusError                            = p_FmParam->f_BusError;
     p_Fm->p_FmFpmRegs = (struct fman_fpm_regs *)UINT_TO_PTR(baseAddr + FM_MM_FPM);
-
     p_Fm->p_FmBmiRegs = (struct fman_bmi_regs *)UINT_TO_PTR(baseAddr + FM_MM_BMI);
     p_Fm->p_FmQmiRegs = (struct fman_qmi_regs *)UINT_TO_PTR(baseAddr + FM_MM_QMI);
     p_Fm->p_FmDmaRegs = (struct fman_dma_regs *)UINT_TO_PTR(baseAddr + FM_MM_DMA);
@@ -3388,11 +3426,12 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
    if (p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
         p_Fm->p_FmDriverParam->qmi_def_tnums_thresh = QMI_DEF_TNUMS_THRESH;
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
-#ifdef FM_NO_GUARANTEED_RESET_VALUES
-    if (1)//p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
-    {
+
         p_Fm->p_FmStateStruct->totalFifoSize        = 0;
-        p_Fm->p_FmStateStruct->totalNumOfTasks      = DEFAULT_totalNumOfTasks;
+        p_Fm->p_FmStateStruct->totalNumOfTasks      = 
+            DEFAULT_totalNumOfTasks(p_Fm->p_FmStateStruct->revInfo.majorRev,
+                                    p_Fm->p_FmStateStruct->revInfo.minorRev);
+
 #ifdef FM_HAS_TOTAL_DMAS
         p_Fm->p_FmStateStruct->maxNumOfOpenDmas     = BMI_MAX_NUM_OF_DMAS;
 #endif /* FM_HAS_TOTAL_DMAS */
@@ -3406,25 +3445,6 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
         p_Fm->p_FmDriverParam->dma_write_buf_tsh_asrt_emer    = DEFAULT_dmaWriteIntBufHigh;
         p_Fm->p_FmDriverParam->dma_axi_dbg_num_of_beats       = DEFAULT_axiDbgNumOfBeats;
 #endif /* (DPAA_VERSION < 11) */
-    }
-    else
-#endif /* FM_NO_GUARANTEED_RESET_VALUES */
-    {
-        struct fman_rg          fman_rg;
-
-        fman_rg.bmi_rg = p_Fm->p_FmBmiRegs;
-        fman_rg.qmi_rg = p_Fm->p_FmQmiRegs;
-        fman_rg.fpm_rg = p_Fm->p_FmFpmRegs;
-        fman_rg.dma_rg = p_Fm->p_FmDmaRegs;
-
-#ifdef FM_WRONG_RESET_VALUES_ERRATA_FMAN_A005127
-        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2, 0x007B0000);
-#endif /* FM_WRONG_RESET_VALUES_ERRATA_FMAN_A005127 */
-        fman_regconfig(&fman_rg, p_Fm->p_FmDriverParam);
-
-        p_Fm->p_FmStateStruct->totalFifoSize = p_Fm->p_FmDriverParam->total_fifo_size;
-        p_Fm->p_FmStateStruct->totalNumOfTasks = p_Fm->p_FmDriverParam->total_num_of_tasks;
-    }
 #ifdef FM_NO_TNUM_AGING
     p_Fm->p_FmDriverParam->tnum_aging_period = 0;
 #endif
@@ -3465,15 +3485,13 @@ t_Error FM_Init(t_Handle h_Fm)
     if (p_Fm->guestId != NCSW_MASTER_ID)
         return InitGuestMode(p_Fm);
 
-#ifdef FM_NO_GUARANTEED_RESET_VALUES
-    if (1)//p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
-        /* if user didn't configured totalFifoSize - (totalFifoSize=0) we configure default
-         * according to chip. otherwise, we use user's configuration.
-         */
-        if (p_Fm->p_FmStateStruct->totalFifoSize == 0)
-            p_Fm->p_FmStateStruct->totalFifoSize = DEFAULT_totalFifoSize(p_Fm->p_FmStateStruct->revInfo.majorRev,
-                                                                         p_Fm->p_FmStateStruct->revInfo.minorRev);
-#endif  /* FM_NO_GUARANTEED_RESET_VALUES */
+    /* if user didn't configured totalFifoSize - (totalFifoSize=0) we configure default
+    * according to chip. otherwise, we use user's configuration.
+    */
+    if (p_Fm->p_FmStateStruct->totalFifoSize == 0)
+        p_Fm->p_FmStateStruct->totalFifoSize = DEFAULT_totalFifoSize(p_Fm->p_FmStateStruct->revInfo.majorRev,
+                                                                     p_Fm->p_FmStateStruct->revInfo.minorRev);
+
 
     CHECK_INIT_PARAMETERS(p_Fm, CheckFmParameters);
 
@@ -3547,17 +3565,15 @@ t_Error FM_Init(t_Handle h_Fm)
 
     if (ClearIRam(p_Fm) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
 #warning for verification only
 #if 1
 p_Fm->firmware.p_Code = &T2080_R1_1_FmCtrlCode;
 p_Fm->firmware.size = sizeof(T2080_R1_1_FmCtrlCode);
 #endif
-    if (p_Fm->firmware.p_Code &&
-        (LoadFmanCtrlCode(p_Fm) != E_OK))
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-
-
 
+    if (p_Fm->firmware.p_Code && (LoadFmanCtrlCode(p_Fm) != E_OK))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 #ifdef FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173
     }
 #endif /* FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173 */
@@ -3573,7 +3589,7 @@ p_Fm->firmware.size = sizeof(T2080_R1_1_FmCtrlCode);
 
 #if (DPAA_VERSION >= 11)
     p_Fm->partVSPBase = AllocVSPsForPartition(h_Fm, p_Fm->partVSPBase, p_Fm->partNumOfVSPs, p_Fm->guestId);
-    if (p_Fm->partVSPBase == ILLEGAL_BASE)
+    if (p_Fm->partVSPBase == (uint8_t)(ILLEGAL_BASE))
         DBG(WARNING, ("partition VSPs allocation is FAILED"));
 #endif /* (DPAA_VERSION >= 11) */
 
@@ -3869,10 +3885,11 @@ t_Error FM_ConfigDmaAxiDbgNumOfBeats(t_Handle h_Fm, uint8_t axiDbgNumOfBeats)
 
 #if (DPAA_VERSION >= 11)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Not available for this FM revision!"));
-#endif /* (DPAA_VERSION >= 11) */
+#else
     p_Fm->p_FmDriverParam->dma_axi_dbg_num_of_beats = axiDbgNumOfBeats;
 
     return E_OK;
+#endif /* (DPAA_VERSION >= 11) */
 }
 
 t_Error FM_ConfigDmaCamNumOfEntries(t_Handle h_Fm, uint8_t numOfEntries)
@@ -4054,7 +4071,7 @@ t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
             p_Fm->userSetExceptions |= bitMask;
         else
             p_Fm->p_FmStateStruct->exceptions &= ~bitMask;
-   }
+    }
     else
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
 
@@ -4137,11 +4154,12 @@ t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDma
 
 #if (DPAA_VERSION >= 11)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Not available for this FM revision!"));
-#endif
+#else
     p_Fm->p_FmDriverParam->dma_write_buf_tsh_asrt_emer = p_FmDmaThresholds->assertEmergency;
     p_Fm->p_FmDriverParam->dma_write_buf_tsh_clr_emer  = p_FmDmaThresholds->clearEmergency;
 
     return E_OK;
+#endif
 }
 
 t_Error FM_ConfigDmaCommQThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
@@ -4168,11 +4186,12 @@ t_Error FM_ConfigDmaReadBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaT
 
 #if (DPAA_VERSION >= 11)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Not available for this FM revision!"));
-#endif
+#else
     p_Fm->p_FmDriverParam->dma_read_buf_tsh_clr_emer   = p_FmDmaThresholds->clearEmergency;
     p_Fm->p_FmDriverParam->dma_read_buf_tsh_asrt_emer  = p_FmDmaThresholds->assertEmergency;
 
     return E_OK;
+#endif
 }
 
 t_Error FM_ConfigDmaWatchdog(t_Handle h_Fm, uint32_t watchdogValue)
@@ -4202,13 +4221,22 @@ UNUSED(p_Fm);
 t_Error FmGetSetParams(t_Handle h_Fm, t_FmGetSetParams *p_Params)
 {
 	t_Fm* p_Fm = (t_Fm*)h_Fm;
-
+	if (p_Params->setParams.type & UPDATE_FM_CLD)
+	{
+		WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_cld, GET_UINT32(
+				p_Fm->p_FmFpmRegs->fm_cld) | 0x00000800);
+	}
+	if (p_Params->setParams.type & CLEAR_IRAM_READY)
+	{
+	    t_FMIramRegs *p_Iram = (t_FMIramRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_IMEM);
+		WRITE_UINT32(p_Iram->iready,GET_UINT32(p_Iram->iready) & ~IRAM_READY);
+	}
 	if (p_Params->setParams.type & UPDATE_FPM_EXTC)
 		WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_extc,0x80000000);
 	if (p_Params->setParams.type & UPDATE_FPM_EXTC_CLEAR)
 		WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_extc,0x00800000);
 	if (p_Params->setParams.type & UPDATE_FPM_BRKC_SLP)
-	{
+	{	
 		if (p_Params->setParams.sleep)
 			WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_brkc, GET_UINT32(
 				p_Fm->p_FmFpmRegs->fmfp_brkc) | FPM_BRKC_SLP);
@@ -4216,6 +4244,8 @@ t_Error FmGetSetParams(t_Handle h_Fm, t_FmGetSetParams *p_Params)
 			WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_brkc, GET_UINT32(
 				p_Fm->p_FmFpmRegs->fmfp_brkc) & ~FPM_BRKC_SLP);
 	}
+	if (p_Params->getParams.type & GET_FM_CLD)
+		p_Params->getParams.fm_cld = GET_UINT32(p_Fm->p_FmFpmRegs->fm_cld);
 	if (p_Params->getParams.type & GET_FMQM_GS)
 		p_Params->getParams.fmqm_gs = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gs);
 	if (p_Params->getParams.type & GET_FM_NPI)
@@ -4259,7 +4289,7 @@ void FM_EventIsr(t_Handle h_Fm)
     pending = fman_get_normal_pending(fpm_rg);
     if (!pending)
         return;
-    if (pending & 0x10000000) // this is a wake up from sleep interrupt
+    if (pending & INTR_EN_WAKEUP) // this is a wake up from sleep interrupt
     {
         t_FmGetSetParams fmGetSetParams;
         memset(&fmGetSetParams, 0, sizeof (t_FmGetSetParams));
@@ -4453,25 +4483,28 @@ t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBan
     bmi_rg = p_Fm->p_FmBmiRegs;
 
     memset(weights, 0, (sizeof(uint8_t) * 64));
+
     /* check that all ports add up to 100% */
     sum = 0;
-    for (i=0;i<p_PortsBandwidth->numOfPorts;i++)
+    for (i=0; i < p_PortsBandwidth->numOfPorts; i++)
         sum +=p_PortsBandwidth->portsBandwidths[i].bandwidth;
     if (sum != 100)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Sum of ports bandwidth differ from 100%"));
 
     /* find highest percent */
-    for (i=0;i<p_PortsBandwidth->numOfPorts;i++)
+    for (i=0; i < p_PortsBandwidth->numOfPorts; i++)
     {
         if (p_PortsBandwidth->portsBandwidths[i].bandwidth > maxPercent)
             maxPercent = p_PortsBandwidth->portsBandwidths[i].bandwidth;
     }
 
+    ASSERT_COND(maxPercent > 0); /* guaranteed by sum = 100 */
+
     /* calculate weight for each port */
-    for (i=0;i<p_PortsBandwidth->numOfPorts;i++)
+    for (i=0; i < p_PortsBandwidth->numOfPorts; i++)
     {
-        weight = (uint8_t)((p_PortsBandwidth->portsBandwidths[i].bandwidth * PORT_MAX_WEIGHT )/maxPercent);
-        /* we want even division between 1-to-PORT_MAX_WEIGHT. so if exect division
+        weight = (uint8_t)((p_PortsBandwidth->portsBandwidths[i].bandwidth * PORT_MAX_WEIGHT ) / maxPercent);
+        /* we want even division between 1-to-PORT_MAX_WEIGHT. so if exact division
            is not reached, we round up so that:
            0 until maxPercent/PORT_MAX_WEIGHT get "1"
            maxPercent/PORT_MAX_WEIGHT+1 until (maxPercent/PORT_MAX_WEIGHT)*2 get "2"
@@ -4481,9 +4514,11 @@ t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBan
             weight++;
 
         /* find the location of this port within the register */
-        SW_PORT_ID_TO_HW_PORT_ID(hardwarePortId,
-                                 p_PortsBandwidth->portsBandwidths[i].type,
-                                 p_PortsBandwidth->portsBandwidths[i].relativePortId);
+        hardwarePortId =
+            SwPortIdToHwPortId(p_PortsBandwidth->portsBandwidths[i].type,
+                               p_PortsBandwidth->portsBandwidths[i].relativePortId,
+                               p_Fm->p_FmStateStruct->revInfo.majorRev,
+                               p_Fm->p_FmStateStruct->revInfo.minorRev);
 
         ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
         weights[hardwarePortId] = weight;
@@ -4613,9 +4648,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
         else
             p_Fm->p_FmStateStruct->exceptions &= ~bitMask;
 
-        FMAN_EXCEPTION_TRANS(fslException, exception);
-
-
+        fslException = FmanExceptionTrans(exception);
 
         return (t_Error)fman_set_exception(&fman_rg,
                                   fslException,
@@ -4753,7 +4786,8 @@ uint32_t FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
         case (e_FM_COUNTERS_DEQ_1):
         case (e_FM_COUNTERS_DEQ_2):
         case (e_FM_COUNTERS_DEQ_3):
-            if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+            if ((p_Fm->p_FmStateStruct->revInfo.majorRev == 4) ||
+                (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6))
             {
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Requested counter not supported"));
                 return 0;
@@ -4938,37 +4972,43 @@ t_Error FM_GetSpecialOperationCoding(t_Handle               h_Fm,
 
     if (revInfo.packageRev == IP_OFFLOAD_PACKAGE_NUMBER)
     {
-        switch (spOper)
-        {
-            case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN|FM_SP_OP_IPSEC_MANIP):
-            case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN|FM_SP_OP_IPSEC_MANIP|FM_SP_OP_RPD):
-                    *p_SpOperCoding = 5;
-                    break;
-            case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_MANIP):
-            case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_MANIP|FM_SP_OP_RPD):
-                    *p_SpOperCoding = 6;
-                    break;
-            case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN|FM_SP_OP_RPD):
-                    *p_SpOperCoding = 3;
-                    break;
-            case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN):
-                    *p_SpOperCoding = 1;
-                    break;
-            case (FM_SP_OP_IPSEC|FM_SP_OP_RPD):
-                    *p_SpOperCoding = 4;
-                    break;
-            case (FM_SP_OP_IPSEC):
-                    *p_SpOperCoding = 2;
-                    break;
-            case (FM_SP_OP_DCL4C):
-                    *p_SpOperCoding = 7;
-                    break;
-            case (FM_SP_OP_CLEAR_RPD):
-                    *p_SpOperCoding = 8;
-                    break;
-            default:
-                RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
-        }
+    switch (spOper)
+    {
+        case (FM_SP_OP_CAPWAP_DTLS_DEC):
+                *p_SpOperCoding = 9;
+                break;
+        case (FM_SP_OP_CAPWAP_DTLS_ENC):
+                *p_SpOperCoding = 10;
+                break;
+        case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN|FM_SP_OP_IPSEC_MANIP):
+        case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN|FM_SP_OP_IPSEC_MANIP|FM_SP_OP_RPD):
+                *p_SpOperCoding = 5;
+                break;
+        case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_MANIP):
+        case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_MANIP|FM_SP_OP_RPD):
+                *p_SpOperCoding = 6;
+                break;
+        case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN|FM_SP_OP_RPD):
+                *p_SpOperCoding = 3;
+                break;
+        case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN):
+                *p_SpOperCoding = 1;
+                break;
+        case (FM_SP_OP_IPSEC|FM_SP_OP_RPD):
+                *p_SpOperCoding = 4;
+                break;
+        case (FM_SP_OP_IPSEC):
+                *p_SpOperCoding = 2;
+                break;
+        case (FM_SP_OP_DCL4C):
+                *p_SpOperCoding = 7;
+                break;
+        case (FM_SP_OP_CLEAR_RPD):
+                *p_SpOperCoding = 8;
+                break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
+    }
     }
     return E_OK;
 }
@@ -5061,141 +5101,6 @@ t_Error FM_CtrlMonGetCounters(t_Handle h_Fm, uint8_t fmCtrlIndex, t_FmCtrlMon *p
     return E_OK;
 }
 
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-t_Error FM_DumpRegs(t_Handle h_Fm)
-{
-    t_Fm            *p_Fm = (t_Fm *)h_Fm;
-    uint8_t         i,j = 0;
-
-    DECLARE_DUMP;
-
-    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(((p_Fm->guestId == NCSW_MASTER_ID) ||
-                               p_Fm->baseAddr), E_INVALID_OPERATION);
-
-    DUMP_SUBTITLE(("\n"));
-
-    DUMP_TITLE(p_Fm->p_FmFpmRegs, ("FM-FPM Regs"));
-
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_tnc);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_prc);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_brkc);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_mxd);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_dist1);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_dist2);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fm_epi);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fm_rie);
-
-    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fmfp_fcev, ("fmfp_fcev"));
-    DUMP_SUBSTRUCT_ARRAY(i, 4)
-    {
-        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfp_fcev[i], sizeof(uint32_t));
-    }
-
-    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fmfp_cee, ("fmfp_cee"));
-    DUMP_SUBSTRUCT_ARRAY(i, 4)
-    {
-        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfp_cee[i], sizeof(uint32_t));
-    }
-
-    DUMP_SUBTITLE(("\n"));
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_tsc1);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_tsc2);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_tsp);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_tsf);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fm_rcr);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_extc);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_ext1);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_ext2);
-
-    DUMP_SUBTITLE(("\n"));
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_dra, 0);
-    CORE_MemoryBarrier();
-    for (j=0; j<128; j++)
-    {
-        DUMP_TITLE(j, ("fmfp_dra"));
-        DUMP_SUBSTRUCT_ARRAY(i, 4)
-        {
-            DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfp_drd[i], sizeof(uint32_t));
-        }
-        DUMP_TITLE(j, ("fmfp_ts"));
-        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfp_ts[j], sizeof(uint32_t));
-    }
-
-    DUMP_SUBTITLE(("\n"));
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fm_ip_rev_1);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fm_ip_rev_2);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fm_rstc);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fm_cld);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fm_npi);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_ee);
-
-    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fmfp_cev, ("fmfp_cev"));
-    DUMP_SUBSTRUCT_ARRAY(i, 4)
-    {
-        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfp_cev[i], sizeof(uint32_t));
-    }
-
-    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fmfp_ps, ("fmfp_ps"));
-    DUMP_SUBSTRUCT_ARRAY(i, 64)
-    {
-        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfp_ps[i], sizeof(uint32_t));
-    }
-
-    DUMP_TITLE(p_Fm->p_FmDmaRegs, ("FM-DMA Regs"));
-    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmsr);
-    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmemsr);
-    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmmr);
-    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmtr);
-    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmhy);
-    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmsetr);
-    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmtah);
-    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmtal);
-    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmtcid);
-    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmra);
-    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmrd);
-    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmwcr);
-    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmebcr);
-    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmdcr);
-
-    DUMP_TITLE(&p_Fm->p_FmDmaRegs->fmdmplr, ("fmdmplr"));
-
-    DUMP_SUBSTRUCT_ARRAY(i, FM_MAX_NUM_OF_HW_PORT_IDS/2)
-    {
-        DUMP_MEMORY(&p_Fm->p_FmDmaRegs->fmdmplr[i], sizeof(uint32_t));
-    }
-
-    DUMP_TITLE(p_Fm->p_FmBmiRegs, ("FM-BMI COMMON Regs"));
-    DUMP_VAR(p_Fm->p_FmBmiRegs,fmbm_init);
-    DUMP_VAR(p_Fm->p_FmBmiRegs,fmbm_cfg1);
-    DUMP_VAR(p_Fm->p_FmBmiRegs,fmbm_cfg2);
-    DUMP_VAR(p_Fm->p_FmBmiRegs,fmbm_ievr);
-    DUMP_VAR(p_Fm->p_FmBmiRegs,fmbm_ier);
-
-    DUMP_TITLE(&p_Fm->p_FmBmiRegs->fmbm_arb, ("fmbm_arb"));
-    DUMP_SUBSTRUCT_ARRAY(i, 8)
-    {
-        DUMP_MEMORY(&p_Fm->p_FmBmiRegs->fmbm_arb[i], sizeof(uint32_t));
-    }
-
-    DUMP_TITLE(p_Fm->p_FmQmiRegs, ("FM-QMI COMMON Regs"));
-    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_gc);
-    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_eie);
-    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_eien);
-    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_eif);
-    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_ie);
-    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_ien);
-    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_if);
-    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_gs);
-    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_etfc);
-    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_tapc);
-
-    return E_OK;
-}
-#endif /* (defined(DEBUG_ERRORS) && ... */
-
-
 
 /****************************************************/
 /*       Hidden-DEBUG Only API                      */
@@ -5252,7 +5157,7 @@ t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception)
             RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception may not be forced"));
     }
 
-    FMAN_EXCEPTION_TRANS(fslException, exception);
+    fslException = FmanExceptionTrans(exception);
     fman_force_intr (&fman_rg, fslException);
 
     return E_OK;
@@ -5262,3 +5167,27 @@ t_Handle FmGetPcd(t_Handle h_Fm)
 {
 	return ((t_Fm*)h_Fm)->h_Pcd;
 }
+#if (DPAA_VERSION >= 11)
+extern void *g_MemacRegs;
+void fm_clk_down(void);
+uint32_t fman_memac_get_event(void *regs, uint32_t ev_mask);
+void FM_ChangeClock(t_Handle h_Fm, int hardwarePortId)
+{
+	int macId;
+	uint32_t    event, rcr;
+	t_Fm *p_Fm = (t_Fm*)h_Fm;
+	rcr = GET_UINT32(p_Fm->p_FmFpmRegs->fm_rcr);
+	rcr |= 0x04000000;
+	WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rcr, rcr);
+
+	HW_PORT_ID_TO_SW_PORT_ID(macId, hardwarePortId);
+	do
+	{
+		event = fman_memac_get_event(g_MemacRegs, 0xFFFFFFFF);
+	} while ((event & 0x00000020) == 0);
+	fm_clk_down();
+	rcr = GET_UINT32(p_Fm->p_FmFpmRegs->fm_rcr);
+	rcr &= ~0x04000000;
+	WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rcr, rcr);
+}
+#endif
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
index 07431c3..72121f3 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
@@ -157,44 +157,6 @@ switch (exception){                                         \
         break;                                                                                      \
     }
 
-#define FMAN_EXCEPTION_TRANS(fsl_exception, _exception) \
-    switch (_exception) {\
-        case  e_FM_EX_DMA_BUS_ERROR:                    \
-            fsl_exception =  E_FMAN_EX_DMA_BUS_ERROR; break;    \
-        case  e_FM_EX_DMA_READ_ECC:                    \
-            fsl_exception =  E_FMAN_EX_DMA_READ_ECC; break;        \
-        case  e_FM_EX_DMA_SYSTEM_WRITE_ECC:                \
-            fsl_exception =  E_FMAN_EX_DMA_SYSTEM_WRITE_ECC; break;    \
-        case  e_FM_EX_DMA_FM_WRITE_ECC:                    \
-            fsl_exception =  E_FMAN_EX_DMA_FM_WRITE_ECC; break;    \
-        case  e_FM_EX_FPM_STALL_ON_TASKS:                \
-            fsl_exception =  E_FMAN_EX_FPM_STALL_ON_TASKS; break;    \
-        case  e_FM_EX_FPM_SINGLE_ECC:                    \
-            fsl_exception =  E_FMAN_EX_FPM_SINGLE_ECC; break;    \
-        case  e_FM_EX_FPM_DOUBLE_ECC:                    \
-            fsl_exception =  E_FMAN_EX_FPM_DOUBLE_ECC; break;    \
-        case  e_FM_EX_QMI_SINGLE_ECC:                    \
-            fsl_exception =  E_FMAN_EX_QMI_SINGLE_ECC; break;    \
-        case  e_FM_EX_QMI_DOUBLE_ECC:                    \
-            fsl_exception =  E_FMAN_EX_QMI_DOUBLE_ECC; break;    \
-        case  e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID:            \
-            fsl_exception =  E_FMAN_EX_QMI_DEQ_FROM_UNKNOWN_PORTID; break; \
-        case  e_FM_EX_BMI_LIST_RAM_ECC:                    \
-            fsl_exception =  E_FMAN_EX_BMI_LIST_RAM_ECC; break;    \
-        case  e_FM_EX_BMI_STORAGE_PROFILE_ECC:                    \
-            fsl_exception =  E_FMAN_EX_BMI_STORAGE_PROFILE_ECC; break;    \
-        case  e_FM_EX_BMI_STATISTICS_RAM_ECC:                \
-            fsl_exception =  E_FMAN_EX_BMI_STATISTICS_RAM_ECC; break; \
-        case  e_FM_EX_BMI_DISPATCH_RAM_ECC:                \
-            fsl_exception =  E_FMAN_EX_BMI_DISPATCH_RAM_ECC; break;    \
-        case  e_FM_EX_IRAM_ECC:                        \
-            fsl_exception =  E_FMAN_EX_IRAM_ECC; break;        \
-        case  e_FM_EX_MURAM_ECC:                    \
-            fsl_exception =  E_FMAN_EX_MURAM_ECC; break;        \
-        default: \
-            fsl_exception =  E_FMAN_EX_DMA_BUS_ERROR; break;    \
-    }
-
 #define FMAN_CACHE_OVERRIDE_TRANS(fsl_cache_override, _cache_override) \
     switch (_cache_override){ \
         case  e_FM_DMA_NO_CACHE_OR:                    \
@@ -344,7 +306,8 @@ switch (exception){                                         \
     (((major == 2) || (major == 5)) ?           \
      (100*KILOBYTE) : ((major == 4) ?           \
      (49*KILOBYTE) : (122*KILOBYTE)))
-#define DEFAULT_totalNumOfTasks             BMI_MAX_NUM_OF_TASKS
+#define DEFAULT_totalNumOfTasks(major, minor)   \
+            BMI_MAX_NUM_OF_TASKS
 
 #define DEFAULT_dmaCommQLow                 ((DMA_THRESH_MAX_COMMQ+1)/2)
 #define DEFAULT_dmaCommQHigh                ((DMA_THRESH_MAX_COMMQ+1)*3/4)
@@ -369,10 +332,13 @@ switch (exception){                                         \
 
 #else  /* (DPAA_VERSION < 11) */
 /* Defaults are registers' reset values */
-#define DEFAULT_totalFifoSize(major, minor)	\
-    (((major == 6) && (minor == 1)) ? (142*KILOBYTE) : (295*KILOBYTE))
+#define DEFAULT_totalFifoSize(major, minor)			\
+	(((major == 6) && ((minor == 1) || (minor == 4))) ?	\
+	(156*KILOBYTE) : (295*KILOBYTE))
 
-#define DEFAULT_totalNumOfTasks             124
+/* According to the default value of FMBM_CFG2[TNTSKS] */
+#define DEFAULT_totalNumOfTasks(major, minor)   \
+      (((major == 6) && ((minor == 1) || (minor == 4))) ? 59 : 124)
 
 #define DEFAULT_dmaCommQLow                 0x2A
 #define DEFAULT_dmaCommQHigh                0x3F
@@ -425,6 +391,7 @@ switch (exception){                                         \
 
 #define INTR_EN_QMI             0x40000000
 #define INTR_EN_PRS             0x20000000
+#define INTR_EN_WAKEUP          0x10000000
 #define INTR_EN_PLCR            0x08000000
 #define INTR_EN_1G_MAC0         0x00080000
 #define INTR_EN_1G_MAC1         0x00040000
@@ -470,18 +437,19 @@ switch (exception){                                         \
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
-typedef _Packed struct
+
+typedef struct
 {
     volatile uint32_t   iadd;           /**< FM IRAM instruction address register */
     volatile uint32_t   idata;          /**< FM IRAM instruction data register */
     volatile uint32_t   itcfg;          /**< FM IRAM timing config register */
     volatile uint32_t   iready;         /**< FM IRAM ready register */
-    volatile uint8_t    res[0x80000-0x10];
-} _PackedType t_FMIramRegs;
+    volatile uint32_t   res[0x1FFFC];
+} t_FMIramRegs;
 
 /* Trace buffer registers -
    each FM Controller has its own trace buffer residing at FM_MM_TRB(fmCtrlIndex) offset */
-typedef _Packed struct t_FmTrbRegs
+typedef struct t_FmTrbRegs
 {
     volatile uint32_t   tcrh;
     volatile uint32_t   tcrl;
@@ -508,11 +476,12 @@ typedef _Packed struct t_FmTrbRegs
     volatile uint32_t   tsnum2;
     volatile uint32_t   tsnum3;
     volatile uint32_t   tsnum4;
-} _PackedType t_FmTrbRegs;
+} t_FmTrbRegs;
 
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
+
 /**************************************************************************//**
  @Description       General defines
 *//***************************************************************************/
@@ -574,6 +543,7 @@ typedef struct
     uint8_t                     fmId;
     e_FmPortType                portsTypes[FM_MAX_NUM_OF_HW_PORT_IDS];
     uint16_t                    fmClkFreq;
+    uint16_t                    fmMacClkFreq;
     t_FmRevisionInfo            revInfo;
 /**************************/
 /* Master Only parameters */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm_ipc.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm_ipc.h
index f39d5d9..7ce36a7 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm_ipc.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm_ipc.h
@@ -192,6 +192,7 @@ typedef _Packed struct t_FmIpcIsr
 *//***************************************************************************/
 typedef _Packed struct t_FmIpcParams {
     uint16_t        fmClkFreq;              /**< OUT: FM Clock frequency */
+    uint16_t        fmMacClkFreq;           /**< OUT: FM MAC clock frequence */
     uint8_t         majorRev;               /**< OUT: FM Major revision */
     uint8_t         minorRev;               /**< OUT: FM Minor revision */
 } _PackedType t_FmIpcParams;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm_muram.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm_muram.c
index a1cbe3f..0bc67cb 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm_muram.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm_muram.c
@@ -44,7 +44,6 @@
 #include "fm_muram_ext.h"
 #include "fm_common.h"
 
-
 #define __ERR_MODULE__  MODULE_FM_MURAM
 
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fman.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fman.c
index e80982a..9e59062 100755
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fman.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fman.c
@@ -186,7 +186,8 @@ void fman_enable_time_stamp(struct fman_fpm_regs *fpm_rg,
 	 * we do not div back, since we write this value as a fraction
 	 * see spec */
 
-	frac = ((ts_freq << 16) - (intgr << 16) * fm_clk_freq) / fm_clk_freq;
+	frac = (((uint64_t)ts_freq << 16) - ((uint64_t)intgr << 16) * fm_clk_freq)
+		/ fm_clk_freq;
 	/* we check remainder of the division in order to round up if not int */
 	if (((ts_freq << 16) - (intgr << 16)*fm_clk_freq) % fm_clk_freq)
 		frac++;
@@ -549,7 +550,7 @@ void fman_set_num_of_open_dmas(struct fman_bmi_regs *bmi_rg,
 }
 
 void fman_set_vsp_window(struct fman_bmi_regs *bmi_rg,
-				     uint8_t port_id,
+			    	     uint8_t port_id,
 				         uint8_t base_storage_profile,
 				         uint8_t log2_num_of_profiles)
 {
@@ -564,18 +565,18 @@ void fman_set_vsp_window(struct fman_bmi_regs *bmi_rg,
 }
 
 void fman_set_congestion_group_pfc_priority(uint32_t *cpg_rg,
-				                        uint32_t congestion_group_id,
+			    	                        uint32_t congestion_group_id,
 				                            uint8_t priority_bit_map)
 {
 	uint32_t reg_num, offset, tmp = 0;
-
+ 
     reg_num = (FM_PORT_NUM_OF_CONGESTION_GRPS-1-congestion_group_id)/4;
     offset  = (congestion_group_id%4)*8;
 
     tmp = ioread32be(&cpg_rg[reg_num]);
     tmp &= ~(0xFF<<offset);
     tmp |= (uint32_t)priority_bit_map << offset;
-
+ 
     iowrite32be(tmp,&cpg_rg[reg_num]);
 }
 
@@ -618,7 +619,7 @@ void fman_defconfig(struct fman_cfg *cfg, bool is_master)
     cfg->qmi_deq_disp_tsh               = DEFAULT_QMI_DEQ_DISP_TH;
     cfg->fm_ctl1_disp_tsh               = DEFAULT_FM_CTL1_DISP_TH;
     cfg->fm_ctl2_disp_tsh               = DEFAULT_FM_CTL2_DISP_TH;
-
+ 
 	cfg->pedantic_dma                   = FALSE;
 	cfg->tnum_aging_period              = DEFAULT_TNUM_AGING_PERIOD;
 	cfg->dma_stop_on_bus_error          = FALSE;
@@ -822,7 +823,7 @@ int fman_fpm_init(struct fman_fpm_regs *fpm_rg, struct fman_cfg *cfg)
 	/* RAM ECC -  enable and clear events*/
 	/* first we need to clear all parser memory,
 	 * as it is uninitialized and may cause ECC errors */
-	tmp_reg = 0;
+
 	/* event bits */
 	tmp_reg = (FPM_RAM_MURAM_ECC | FPM_RAM_IRAM_ECC);
 	/* Rams enable not effected by RCR bit, but by a COP configuration */
@@ -904,7 +905,6 @@ int fman_qmi_init(struct fman_qmi_regs *qmi_rg, struct fman_cfg *cfg)
 
 	iowrite32be(QMI_ERR_INTR_EN_DOUBLE_ECC | QMI_ERR_INTR_EN_DEQ_FROM_DEF,
 			&qmi_rg->fmqm_eie);
-
 	tmp_reg = 0;
 	if (cfg->exceptions & FMAN_EX_QMI_DEQ_FROM_UNKNOWN_PORTID)
 		tmp_reg |= QMI_ERR_INTR_EN_DEQ_FROM_DEF;
@@ -914,12 +914,12 @@ int fman_qmi_init(struct fman_qmi_regs *qmi_rg, struct fman_cfg *cfg)
 	iowrite32be(tmp_reg, &qmi_rg->fmqm_eien);
 
 	if (cfg->tnum_aging_period) {
-		/* tnumAgingPeriod is in units of usec, p_FmClockFreq in Mhz */
+		/* tnum_aging_period is in units of usec, p_FmClockFreq in Mhz */
 		period_in_fm_clocks = (uint16_t)
 				(cfg->tnum_aging_period * cfg->clk_freq);
-		/* periodInFmClocks must be a 64 multiply */
+		/* period_in_fm_clocks must be a 64 multiply */
 		remainder = (uint8_t)(period_in_fm_clocks % 64);
-		if (remainder > 64)
+		if (remainder)
 			tmp_reg = (uint32_t)((period_in_fm_clocks / 64) + 1);
 		else{
 			tmp_reg = (uint32_t)(period_in_fm_clocks / 64);
@@ -1195,9 +1195,9 @@ void fman_get_revision(struct fman_fpm_regs *fpm_rg,
 	uint32_t tmp;
 
 	tmp = ioread32be(&fpm_rg->fm_ip_rev_1);
-
 	*major = (uint8_t)((tmp & FPM_REV1_MAJOR_MASK) >> FPM_REV1_MAJOR_SHIFT);
 	*minor = (uint8_t)((tmp & FPM_REV1_MINOR_MASK) >> FPM_REV1_MINOR_SHIFT);
+
 }
 
 uint32_t fman_get_counter(struct fman_rg *fman_rg,
@@ -1383,9 +1383,8 @@ void fman_force_intr(struct fman_rg *fman_rg,
 
 bool fman_is_qmi_halt_not_busy_state(struct fman_qmi_regs *qmi_rg)
 {
-    return (bool)!!(ioread32be(&qmi_rg->fmqm_gs) & QMI_GS_HALT_NOT_BUSY);
+	return (bool)!!(ioread32be(&qmi_rg->fmqm_gs) & QMI_GS_HALT_NOT_BUSY);
 }
-
 void fman_resume(struct fman_fpm_regs *fpm_rg)
 {
 	uint32_t tmp;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
index d1f5b11..30eae1b 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
@@ -51,6 +51,10 @@
 #define CLS_PLAN_NUM_PER_GRP                        8
 
 #define IP_OFFLOAD_PACKAGE_NUMBER                   106
+#define CAPWAP_OFFLOAD_PACKAGE_NUMBER               108
+#define IS_OFFLOAD_PACKAGE(num) ((num == IP_OFFLOAD_PACKAGE_NUMBER) || (num == CAPWAP_OFFLOAD_PACKAGE_NUMBER))
+
+
 
 
 /**************************************************************************//**
@@ -165,7 +169,9 @@ typedef _Packed struct t_FmPcdCtrlParamsPage {
     volatile uint32_t misc;
     volatile uint32_t errorsDiscardMask;
     volatile uint32_t discardMask;
-    volatile uint8_t  reserved3[180];
+    volatile uint8_t  reserved3[4];
+    volatile uint32_t postBmiFetchNia;
+    volatile uint8_t  reserved4[172];
 } _PackedType t_FmPcdCtrlParamsPage;
 
 
@@ -188,11 +194,11 @@ typedef struct t_FmPcdCcFragScratchPoolCmdParams {
     uint8_t     bufferPoolId;
 } t_FmPcdCcFragScratchPoolCmdParams;
 
-typedef struct t_FmPcdCcIpReassmTimeoutParams {
+typedef struct t_FmPcdCcReassmTimeoutParams {
     bool        activate;
     uint8_t     tsbs;
     uint32_t    iprcpt;
-} t_FmPcdCcIpReassmTimeoutParams;
+} t_FmPcdCcReassmTimeoutParams;
 
 typedef struct {
     uint8_t             baseEntry;
@@ -235,7 +241,6 @@ typedef struct {
     uint32_t            type;
     uint8_t             prOffset;
     uint16_t            dataOffset;
-  //  uint8_t             poolIndex;
     uint8_t             internalBufferOffset;
     uint8_t             numOfTasks;
     uint8_t             numOfExtraTasks;
@@ -251,6 +256,7 @@ typedef struct {
     uint32_t        nia;
     t_FmFmanCtrl    orFmanCtrl;
     bool            overwrite;
+    uint8_t         ofpDpde;
 } t_SetCcParams;
 
 typedef struct {
@@ -267,6 +273,7 @@ typedef struct {
     uint32_t    type;
     uint32_t    fmqm_gs;
     uint32_t    fm_npi;
+    uint32_t    fm_cld;
     uint32_t    fmfp_extc;
 } t_FmGetParams;
 
@@ -325,6 +332,7 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 #define UPDATE_PSO                              0x40000000
 #define UPDATE_NIA_PNDN                         0x20000000
 #define UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY      0x10000000
+#define UPDATE_OFP_DPTE                         0x08000000
 #define UPDATE_NIA_FENE                         0x04000000
 #define UPDATE_NIA_CMNE                         0x02000000
 #define UPDATE_NIA_FPNE                         0x01000000
@@ -340,7 +348,7 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 #define UPDATE_KG_NIA_CC_WA                     0x10000000
 #define UPDATE_KG_OPT_MODE                      0x08000000
 #define UPDATE_KG_NIA                           0x04000000
-#define UPDATE_CC_SHADOW_CLEAR					0x02000000
+#define UPDATE_CC_SHADOW_CLEAR                    0x02000000
 /* @} */
 
 #define UPDATE_FPM_BRKC_SLP                     0x80000000
@@ -349,6 +357,9 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 #define GET_FMQM_GS		                0x10000000
 #define GET_FM_NPI		                0x08000000
 #define GET_FMFP_EXTC		                0x04000000
+#define CLEAR_IRAM_READY	                0x02000000
+#define UPDATE_FM_CLD		                0x01000000
+#define GET_FM_CLD		                0x00800000
 #define FM_MAX_NUM_OF_PORTS     (FM_MAX_NUM_OF_OH_PORTS +     \
                                  FM_MAX_NUM_OF_1G_RX_PORTS +  \
                                  FM_MAX_NUM_OF_10G_RX_PORTS + \
@@ -501,35 +512,7 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 10G_TX_PORT port id"))
 #endif
 
-
-#define SW_PORT_ID_TO_HW_PORT_ID(_port, _type, _relativePortId)         \
-switch (_type) {                                                        \
-    case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):                           \
-    case (e_FM_PORT_TYPE_OH_HOST_COMMAND):                              \
-        CHECK_PORT_ID_OH_PORTS(_relativePortId);                        \
-        _port = (uint8_t)(BASE_OH_PORTID + (_relativePortId));          \
-        break;                                                          \
-    case (e_FM_PORT_TYPE_RX):                                           \
-        CHECK_PORT_ID_1G_RX_PORTS(_relativePortId);                     \
-        _port = (uint8_t)(BASE_1G_RX_PORTID + (_relativePortId));       \
-        break;                                                          \
-    case (e_FM_PORT_TYPE_RX_10G):                                       \
-        CHECK_PORT_ID_10G_RX_PORTS(_relativePortId);                    \
-        _port = (uint8_t)(BASE_10G_RX_PORTID + (_relativePortId));      \
-        break;                                                          \
-    case (e_FM_PORT_TYPE_TX):                                           \
-        CHECK_PORT_ID_1G_TX_PORTS(_relativePortId);                     \
-        _port = (uint8_t)(BASE_1G_TX_PORTID + (_relativePortId));       \
-        break;                                                          \
-    case (e_FM_PORT_TYPE_TX_10G):                                       \
-        CHECK_PORT_ID_10G_TX_PORTS(_relativePortId);                    \
-        _port = (uint8_t)(BASE_10G_TX_PORTID + (_relativePortId));      \
-        break;                                                          \
-    default:                                                            \
-        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port type"));    \
-        _port = 0;                                                      \
-        break;                                                          \
-}
+uint8_t SwPortIdToHwPortId(e_FmPortType type, uint8_t relativePortId, uint8_t majorRev, uint8_t minorRev);
 
 #define HW_PORT_ID_TO_SW_PORT_ID(_relativePortId, hardwarePortId)                   \
 {   if (((hardwarePortId) >= BASE_OH_PORTID) &&                                     \
@@ -603,33 +586,33 @@ typedef struct {
                                              ((hdr) == HEADER_TYPE_USER_DEFINED_SHIM2))
 #define IS_SPECIAL_HEADER(hdr)              ((hdr) == HEADER_TYPE_MACSEC)
 
-#define GET_PRS_HDR_NUM(num, hdr)                           \
-switch (hdr)                                                \
-{   case (HEADER_TYPE_ETH):              num = 0;  break;   \
-    case (HEADER_TYPE_LLC_SNAP):         num = 1;  break;   \
-    case (HEADER_TYPE_VLAN):             num = 2;  break;   \
-    case (HEADER_TYPE_PPPoE):            num = 3;  break;   \
-    case (HEADER_TYPE_PPP):              num = 3;  break;   \
-    case (HEADER_TYPE_MPLS):             num = 4;  break;   \
-    case (HEADER_TYPE_IPv4):             num = 5;  break;   \
-    case (HEADER_TYPE_IPv6):             num = 6;  break;   \
-    case (HEADER_TYPE_GRE):              num = 7;  break;   \
-    case (HEADER_TYPE_MINENCAP):         num = 8;  break;   \
-    case (HEADER_TYPE_USER_DEFINED_L3):  num = 9;  break;   \
-    case (HEADER_TYPE_TCP):              num = 10; break;   \
-    case (HEADER_TYPE_UDP):              num = 11; break;   \
-    case (HEADER_TYPE_IPSEC_AH):                            \
-    case (HEADER_TYPE_IPSEC_ESP):        num = 12; break;   \
-    case (HEADER_TYPE_SCTP):             num = 13; break;   \
-    case (HEADER_TYPE_DCCP):             num = 14; break;   \
-    case (HEADER_TYPE_USER_DEFINED_L4):  num = 15; break;   \
-    case (HEADER_TYPE_USER_DEFINED_SHIM1):                  \
-    case (HEADER_TYPE_USER_DEFINED_SHIM2):                  \
-    case (HEADER_TYPE_MACSEC):                              \
-        num = NO_HDR_NUM; break;                            \
-    default:                                                \
-        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unsupported header for parser"));\
-        num = ILLEGAL_HDR_NUM; break;                       \
+static __inline__ uint8_t GetPrsHdrNum(e_NetHeaderType hdr)
+{
+	 switch (hdr)
+	 {   case (HEADER_TYPE_ETH):              return 0;
+	     case (HEADER_TYPE_LLC_SNAP):         return 1;
+	     case (HEADER_TYPE_VLAN):             return 2;
+	     case (HEADER_TYPE_PPPoE):            return 3;
+	     case (HEADER_TYPE_PPP):              return 3;
+	     case (HEADER_TYPE_MPLS):             return 4;
+	     case (HEADER_TYPE_IPv4):             return 5;
+	     case (HEADER_TYPE_IPv6):             return 6;
+	     case (HEADER_TYPE_GRE):              return 7;
+	     case (HEADER_TYPE_MINENCAP):         return 8;
+	     case (HEADER_TYPE_USER_DEFINED_L3):  return 9;
+	     case (HEADER_TYPE_TCP):              return 10;
+	     case (HEADER_TYPE_UDP):              return 11;
+	     case (HEADER_TYPE_IPSEC_AH):
+	     case (HEADER_TYPE_IPSEC_ESP):        return 12;
+	     case (HEADER_TYPE_SCTP):             return 13;
+	     case (HEADER_TYPE_DCCP):             return 14;
+	     case (HEADER_TYPE_USER_DEFINED_L4):  return 15;
+	     case (HEADER_TYPE_USER_DEFINED_SHIM1):
+	     case (HEADER_TYPE_USER_DEFINED_SHIM2):
+	     case (HEADER_TYPE_MACSEC):           return NO_HDR_NUM;
+	     default:
+	         return ILLEGAL_HDR_NUM;
+	 }
 }
 
 #define FM_PCD_MAX_NUM_OF_OPTIONS(clsPlanEntries)   ((clsPlanEntries==256)? 8:((clsPlanEntries==128)? 7: ((clsPlanEntries==64)? 6: ((clsPlanEntries==32)? 5:0))))
@@ -718,6 +701,8 @@ void        FmPcdKgUpdateRequiredAction(t_Handle h_Scheme, uint32_t requiredActi
 bool        FmPcdKgIsDirectPlcr(t_Handle h_FmPcd, uint8_t schemeId);
 bool        FmPcdKgIsDistrOnPlcrProfile(t_Handle h_FmPcd, uint8_t schemeId);
 uint16_t    FmPcdKgGetRelativeProfileId(t_Handle h_FmPcd, uint8_t schemeId);
+t_Handle    FmPcdKgGetSchemeHandle(t_Handle h_FmPcd, uint8_t relativeSchemeId);
+bool        FmPcdKgIsSchemeHasOwners(t_Handle h_Scheme);
 t_Error     FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle  h_Scheme, uint32_t requiredAction, uint32_t value);
 t_Error     FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t netEnvId, protocolOpt_t *p_OptArray, uint8_t *p_ClsPlanGrpId, bool *p_IsEmptyClsPlanGrp);
 t_Error     FmPcdKgDeleteOrUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId);
@@ -768,7 +753,8 @@ t_Error     FmPcdCcModifyNextEngineParamTree(t_Handle h_FmPcd, t_Handle h_FmPcdC
 uint32_t    FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd, t_Handle h_Pointer);
 t_Handle    FmPcdCcTreeGetSavedManipParams(t_Handle h_FmTree);
 void        FmPcdCcTreeSetSavedManipParams(t_Handle h_FmTree, t_Handle h_SavedManipParams);
-t_Error     FmPcdCcTreeAddIPR(t_Handle h_FmPcd, t_Handle h_FmTree, t_Handle h_NetEnv, t_Handle h_IpReassemblyManip, bool schemes);
+t_Error     FmPcdCcTreeAddIPR(t_Handle h_FmPcd, t_Handle h_FmTree, t_Handle h_NetEnv, t_Handle h_ReassemblyManip, bool schemes);
+t_Error     FmPcdCcTreeAddCPR(t_Handle h_FmPcd, t_Handle h_FmTree, t_Handle h_NetEnv, t_Handle h_ReassemblyManip, bool schemes);
 t_Error     FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle h_PcdParams, t_Handle h_CcTree,  uint32_t  *p_Offset,t_Handle h_FmPort);
 t_Error     FmPcdCcUnbindTree(t_Handle h_FmPcd, t_Handle h_CcTree);
 
@@ -1033,6 +1019,19 @@ t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId);
 uint16_t FmGetClockFreq(t_Handle h_Fm);
 
 /**************************************************************************//**
+ @Function      FmGetMacClockFreq
+
+ @Description   Used by MAC driver to get the MAC clock frequency
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        clock-freq on success; 0 otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+uint16_t FmGetMacClockFreq(t_Handle h_Fm);
+
+/**************************************************************************//**
  @Function      FmGetId
 
  @Description   Used by PCD driver to read rhe FM id
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_hc.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_hc.h
index f6a1bb2..492aa8a 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_hc.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_hc.h
@@ -63,7 +63,7 @@ t_Error     FmHcPcdKgSetScheme(t_Handle                   h_FmHc,
 t_Error     FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme);
 t_Error     FmHcPcdCcCapwapTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcCapwapReassmTimeoutParams *p_CcCapwapReassmTimeoutParams );
 t_Error     FmHcPcdCcIpFragScratchPollCmd(t_Handle h_FmHc, bool fill, t_FmPcdCcFragScratchPoolCmdParams *p_FmPcdCcFragScratchPoolCmdParams);
-t_Error     FmHcPcdCcIpTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcIpReassmTimeoutParams *p_CcIpReassmTimeoutParams, uint8_t *p_Result);
+t_Error     FmHcPcdCcTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcReassmTimeoutParams *p_CcReassmTimeoutParams, uint8_t *p_Result);
 t_Error     FmHcPcdKgSetClsPlan(t_Handle h_FmHc, t_FmPcdKgInterModuleClsPlanSet *p_Set);
 t_Error     FmHcPcdKgDeleteClsPlan(t_Handle h_FmHc, uint8_t clsPlanGrpId);
 
@@ -85,6 +85,8 @@ t_Error     FmHcPcdKgCcGetSetParams(t_Handle h_FmHc, t_Handle  h_Scheme, uint32_
 t_Error     FmHcPcdPlcrCcGetSetParams(t_Handle h_FmHc,uint16_t absoluteProfileId, uint32_t requiredAction);
 
 t_Error     FmHcPcdSync(t_Handle h_FmHc);
+t_Handle    FmHcGetPort(t_Handle h_FmHc);
+
 
 
 
diff --git a/drivers/net/ethernet/freescale/fman/etc/Makefile b/drivers/net/ethernet/freescale/fman/etc/Makefile
index 5e7c382..427762f 100644
--- a/drivers/net/ethernet/freescale/fman/etc/Makefile
+++ b/drivers/net/ethernet/freescale/fman/etc/Makefile
@@ -1,7 +1,7 @@
 #
 # Makefile for the Freescale Ethernet controllers
 #
-EXTRA_CFLAGS           += -DVERSION=\"\"
+ccflags-y           += -DVERSION=\"\"
 #
 #Include netcomm SW specific definitions
 
diff --git a/drivers/net/ethernet/freescale/fman/etc/mm.c b/drivers/net/ethernet/freescale/fman/etc/mm.c
index 7b9d201..9fcc46e 100644
--- a/drivers/net/ethernet/freescale/fman/etc/mm.c
+++ b/drivers/net/ethernet/freescale/fman/etc/mm.c
@@ -246,6 +246,7 @@ static t_Error AddFree(t_MM *p_MM, uint64_t base, uint64_t end)
                     else
                         p_MM->freeBlocks[i] = p_CurrB->p_Next;
                     XX_Free(p_CurrB);
+                    p_CurrB = NULL;
                 }
                 break;
             }
@@ -575,7 +576,10 @@ static uint64_t MmGetGreaterAlignment(t_MM *p_MM, uint64_t size, uint64_t alignm
 
     /* calls Update routine to update a lists of free blocks */
     if ( CutFree ( p_MM, holdBase, holdEnd ) != E_OK )
+    {
+        XX_Free(p_NewBusyB);
         return (uint64_t)(ILLEGAL_BASE);
+    }
 
     /* insert the new busy block into the list of busy blocks */
     AddBusy ( p_MM, p_NewBusyB );
@@ -617,12 +621,15 @@ t_Error MM_Init(t_Handle *h_MM, uint64_t base, uint64_t size)
     /* Initializes counter of free memory to total size */
     p_MM->freeMemSize = size;
 
+    /* A busy list is empty */
+    p_MM->busyBlocks = 0;
+
     /* Initializes a new memory block */
     if ((p_MM->memBlocks = CreateNewBlock(base, size)) == NULL)
+    {
+        MM_Free(p_MM);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
-
-    /* A busy list is empty */
-    p_MM->busyBlocks = 0;
+    }
 
     /* Initializes a new free block for each free list*/
     for (i=0; i <= MM_MAX_ALIGNMENT; i++)
@@ -631,7 +638,10 @@ t_Error MM_Init(t_Handle *h_MM, uint64_t base, uint64_t size)
         newSize = size - (newBase - base);
 
         if ((p_MM->freeBlocks[i] = CreateFreeBlock(newBase, newSize)) == NULL)
+        {
+            MM_Free(p_MM);
             RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+        }
     }
 
     *h_MM = p_MM;
@@ -754,6 +764,7 @@ uint64_t MM_Get(t_Handle h_MM, uint64_t size, uint64_t alignment, char* name)
     if ( CutFree ( p_MM, holdBase, holdEnd ) != E_OK )
     {
         XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        XX_Free(p_NewBusyB);
         return (uint64_t)(ILLEGAL_BASE);
     }
 
@@ -810,6 +821,7 @@ uint64_t MM_GetForce(t_Handle h_MM, uint64_t base, uint64_t size, char* name)
     if ( CutFree ( p_MM, base, base+size ) != E_OK )
     {
         XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        XX_Free(p_NewBusyB);
         return (uint64_t)(ILLEGAL_BASE);
     }
 
@@ -898,6 +910,7 @@ uint64_t MM_GetForceMin(t_Handle h_MM, uint64_t size, uint64_t alignment, uint64
     if ( CutFree( p_MM, holdBase, holdEnd ) != E_OK )
     {
         XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        XX_Free(p_NewBusyB);
         return (uint64_t)(ILLEGAL_BASE);
     }
 
diff --git a/drivers/net/ethernet/freescale/fman/fmanv3h_dflags.h b/drivers/net/ethernet/freescale/fman/fmanv3h_dflags.h
new file mode 100644
index 0000000..435b0d2
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/fmanv3h_dflags.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __dflags_h
+#define __dflags_h
+
+
+#define NCSW_LINUX
+
+#define T4240
+#define NCSW_PPC_CORE
+
+#define DEBUG_ERRORS        1
+
+#if defined(DEBUG)
+#define DEBUG_GLOBAL_LEVEL  REPORT_LEVEL_INFO
+
+#define DEBUG_XX_MALLOC
+#define DEBUG_MEM_LEAKS
+
+#else
+#define DEBUG_GLOBAL_LEVEL  REPORT_LEVEL_WARNING
+#endif /* (DEBUG) */
+
+#define REPORT_EVENTS       1
+#define EVENT_GLOBAL_LEVEL  REPORT_LEVEL_MINOR
+
+#endif /* __dflags_h */
diff --git a/drivers/net/ethernet/freescale/fman/fmanv3l_dflags.h b/drivers/net/ethernet/freescale/fman/fmanv3l_dflags.h
new file mode 100644
index 0000000..789eb87
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/fmanv3l_dflags.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __dflags_h
+#define __dflags_h
+
+
+#define NCSW_LINUX
+
+#define NCSW_PPC_CORE
+
+#define DEBUG_ERRORS        1
+
+#if defined(DEBUG)
+#define DEBUG_GLOBAL_LEVEL  REPORT_LEVEL_INFO
+
+#define DEBUG_XX_MALLOC
+#define DEBUG_MEM_LEAKS
+
+#else
+#define DEBUG_GLOBAL_LEVEL  REPORT_LEVEL_WARNING
+#endif /* (DEBUG) */
+
+#define REPORT_EVENTS       1
+#define EVENT_GLOBAL_LEVEL  REPORT_LEVEL_MINOR
+
+#endif /* __dflags_h */
diff --git a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_ext.h b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_ext.h
index 0fc25ac..00951b1 100644
--- a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_ext.h
@@ -236,6 +236,8 @@ typedef uint32_t fmSpecialOperations_t;                 /**< typedef for definin
 #define  FM_SP_OP_DCL4C                     0x08000000  /**< Set the DCL4C bit */
 #define  FM_SP_OP_CHECK_SEC_ERRORS          0x04000000  /**< Check SEC errors */
 #define  FM_SP_OP_CLEAR_RPD                 0x02000000  /**< Clear the RPD bit */
+#define  FM_SP_OP_CAPWAP_DTLS_ENC           0x01000000  /**< activate features that related to CAPWAP-DTLS post Encryption */
+#define  FM_SP_OP_CAPWAP_DTLS_DEC           0x00800000  /**< activate features that related to CAPWAP-DTLS post Decryption */
 /* @} */
 
 /**************************************************************************//**
@@ -310,19 +312,19 @@ typedef enum e_FmExceptions {
  @Description   Enum for defining port DMA swap mode
 *//***************************************************************************/
 typedef enum e_FmDmaSwapOption {
-    e_FM_DMA_NO_SWP = FMAN_DMA_NO_SWP, 			/**< No swap, transfer data as is.*/
-    e_FM_DMA_SWP_PPC_LE = FMAN_DMA_SWP_PPC_LE, 	/**< The transferred data should be swapped
-							in PowerPc Little Endian mode. */
-    e_FM_DMA_SWP_BE = FMAN_DMA_SWP_BE 			/**< The transferred data should be swapped
-							in Big Endian mode */
+    e_FM_DMA_NO_SWP = FMAN_DMA_NO_SWP,          /**< No swap, transfer data as is.*/
+    e_FM_DMA_SWP_PPC_LE = FMAN_DMA_SWP_PPC_LE,  /**< The transferred data should be swapped
+                                                in PowerPc Little Endian mode. */
+    e_FM_DMA_SWP_BE = FMAN_DMA_SWP_BE           /**< The transferred data should be swapped
+                                                in Big Endian mode */
 } e_FmDmaSwapOption;
 
 /**************************************************************************//**
  @Description   Enum for defining port DMA cache attributes
 *//***************************************************************************/
 typedef enum e_FmDmaCacheOption {
-    e_FM_DMA_NO_STASH = FMAN_DMA_NO_STASH,     	/**< Cacheable, no Allocate (No Stashing) */
-    e_FM_DMA_STASH = FMAN_DMA_STASH         	/**< Cacheable and Allocate (Stashing on) */
+    e_FM_DMA_NO_STASH = FMAN_DMA_NO_STASH,      /**< Cacheable, no Allocate (No Stashing) */
+    e_FM_DMA_STASH = FMAN_DMA_STASH             /**< Cacheable and Allocate (Stashing on) */
 } e_FmDmaCacheOption;
 
 
@@ -481,6 +483,9 @@ typedef struct t_FmParams {
                                                          to be used by the FM. */
     uint16_t                fmClkFreq;              /**< In Mhz;
                                                          Relevant when FM not runs in "guest-mode". */
+    uint16_t                fmMacClkRatio;          /**< FM MAC Clock ratio, for backward comparability:
+                                                                     when fmMacClkRatio = 0, ratio is 2:1
+                                                                     when fmMacClkRatio = 1, ratio is 1:1  */
     t_FmExceptionsCallback  *f_Exception;           /**< An application callback routine to handle exceptions;
                                                          Relevant when FM not runs in "guest-mode". */
     t_FmBusErrorCallback    *f_BusError;            /**< An application callback routine to handle exceptions;
diff --git a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_macsec_ext.h b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_macsec_ext.h
new file mode 100644
index 0000000..57925f1
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_macsec_ext.h
@@ -0,0 +1,1271 @@
+/*
+ * Copyright 2008-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_macsec_ext.h
+
+ @Description   FM MACSEC ...
+*//***************************************************************************/
+#ifndef __FM_MACSEC_EXT_H
+#define __FM_MACSEC_EXT_H
+
+#include "std_ext.h"
+
+
+/**************************************************************************//**
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_MACSEC_grp FM MACSEC
+
+ @Description   FM MACSEC API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   MACSEC Exceptions
+*//***************************************************************************/
+typedef enum e_FmMacsecExceptions {
+    e_FM_MACSEC_EX_SINGLE_BIT_ECC,          /**< Single bit ECC error */
+    e_FM_MACSEC_EX_MULTI_BIT_ECC            /**< Multi bit ECC error */
+} e_FmMacsecExceptions;
+
+
+/**************************************************************************//**
+ @Group         FM_MACSEC_init_grp FM-MACSEC Initialization Unit
+
+ @Description   FM MACSEC Initialization Unit
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      t_FmMacsecExceptionsCallback
+
+ @Description   Exceptions user callback routine, will be called upon an
+                exception passing the exception identification.
+
+ @Param[in]     h_App       A handle to an application layer object; This handle
+                            will be passed by the driver upon calling this callback.
+ @Param[in]     exception   The exception.
+*//***************************************************************************/
+typedef void (t_FmMacsecExceptionsCallback) ( t_Handle                  h_App,
+                                              e_FmMacsecExceptions      exception);
+
+
+/**************************************************************************//**
+ @Description   FM MACSEC config input
+*//***************************************************************************/
+typedef struct t_FmMacsecParams {
+    t_Handle                                h_Fm;               /**< A handle to the FM object related to */
+    bool                                    guestMode;          /**< Partition-id */
+    union {
+        struct {
+            uint8_t                         fmMacId;            /**< FM MAC id */
+        } guestParams;
+
+        struct {
+            uintptr_t                       baseAddr;           /**< Base of memory mapped FM MACSEC registers */
+            t_Handle                        h_FmMac;            /**< A handle to the FM MAC object  related to */
+            t_FmMacsecExceptionsCallback    *f_Exception;       /**< Exception Callback Routine         */
+            t_Handle                        h_App;              /**< A handle to an application layer object; This handle will
+                                                                     be passed by the driver upon calling the above callbacks */
+        } nonGuestParams;
+    };
+} t_FmMacsecParams;
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_Config
+
+ @Description   Creates descriptor for the FM MACSEC module;
+
+                The routine returns a handle (descriptor) to the FM MACSEC object;
+                This descriptor must be passed as first parameter to all other
+                FM MACSEC function calls;
+
+                No actual initialization or configuration of FM MACSEC hardware is
+                done by this routine.
+
+ @Param[in]     p_FmMacsecParam     Pointer to data structure of parameters.
+
+ @Retval        Handle to FM MACSEC object, or NULL for Failure.
+*//***************************************************************************/
+t_Handle FM_MACSEC_Config(t_FmMacsecParams *p_FmMacsecParam);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_Init
+
+ @Description   Initializes the FM MACSEC module.
+
+ @Param[in]     h_FmMacsec      FM MACSEC module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_MACSEC_Init(t_Handle h_FmMacsec);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_Free
+
+ @Description   Frees all resources that were assigned to FM MACSEC module;
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmMacsec      FM MACSEC module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_MACSEC_Free(t_Handle h_FmMacsec);
+
+
+/**************************************************************************//**
+ @Group         FM_MACSEC_advanced_init_grp    FM-MACSEC Advanced Configuration Unit
+
+ @Description   Configuration functions used to change default values.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   enum for unknown sci frame treatment
+*//***************************************************************************/
+typedef enum e_FmMacsecUnknownSciFrameTreatment {
+    e_FM_MACSEC_UNKNOWN_SCI_FRAME_TREATMENT_DISCARD_BOTH = 0,                                               /**< Controlled port - Strict mode */
+    e_FM_MACSEC_UNKNOWN_SCI_FRAME_TREATMENT_DISCARD_UNCONTROLLED_DELIVER_OR_DISCARD_CONTROLLED,             /**< If C bit clear deliver on controlled port, else discard
+                                                                                                                 Controlled port - Check or Disable mode */
+    e_FM_MACSEC_UNKNOWN_SCI_FRAME_TREATMENT_DELIVER_UNCONTROLLED_DISCARD_CONTROLLED,                        /**< Controlled port - Strict mode */
+    e_FM_MACSEC_UNKNOWN_SCI_FRAME_TREATMENT_DELIVER_OR_DISCARD_UNCONTROLLED_DELIVER_OR_DISCARD_CONTROLLED   /**< If C bit set deliver on uncontrolled port and discard on controlled port,
+                                                                                                                 else discard on uncontrolled port and deliver on controlled port
+                                                                                                                 Controlled port - Check or Disable mode */
+} e_FmMacsecUnknownSciFrameTreatment;
+
+/**************************************************************************//**
+ @Description   enum for untag frame treatment
+*//***************************************************************************/
+typedef enum e_FmMacsecUntagFrameTreatment {
+    e_FM_MACSEC_UNTAG_FRAME_TREATMENT_DELIVER_UNCONTROLLED_DISCARD_CONTROLLED = 0,                    /**< Controlled port - Strict mode */
+    e_FM_MACSEC_UNTAG_FRAME_TREATMENT_DISCARD_BOTH,                                                   /**< Controlled port - Strict mode */
+    e_FM_MACSEC_UNTAG_FRAME_TREATMENT_DISCARD_UNCONTROLLED_DELIVER_CONTROLLED_UNMODIFIED              /**< Controlled port - Strict mode */
+} e_FmMacsecUntagFrameTreatment;
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_ConfigUnknownSciFrameTreatment
+
+ @Description   Change the treatment for received frames with unknown sci from its default
+                configuration [DEFAULT_unknownSciFrameTreatment].
+
+ @Param[in]     h_FmMacsec      FM MACSEC module descriptor.
+ @Param[in]     treatMode       The selected mode.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Config() and before FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_ConfigUnknownSciFrameTreatment(t_Handle h_FmMacsec, e_FmMacsecUnknownSciFrameTreatment treatMode);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_ConfigInvalidTagsFrameTreatment
+
+ @Description   Change the treatment for received frames with invalid tags or
+                a zero value PN or an invalid ICV from its default configuration
+                [DEFAULT_invalidTagsFrameTreatment].
+
+ @Param[in]     h_FmMacsec              FM MACSEC module descriptor.
+ @Param[in]     deliverUncontrolled     If True deliver on the uncontrolled port, else discard;
+                                        In both cases discard on the controlled port;
+                                        this provide Strict, Check or Disable mode.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Config() and before FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_ConfigInvalidTagsFrameTreatment(t_Handle h_FmMacsec, bool deliverUncontrolled);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_ConfigEncryptWithNoChangedTextFrameTreatment
+
+ @Description   Change the treatment for received frames with the Encryption bit
+                set and the Changed Text bit clear from its default configuration
+                [DEFAULT_encryptWithNoChangedTextFrameTreatment].
+
+ @Param[in]     h_FmMacsec              FM MACSEC module descriptor.
+ @Param[in]     discardUncontrolled     If True discard on the uncontrolled port, else deliver;
+                                        In both cases discard on the controlled port;
+                                        this provide Strict, Check or Disable mode.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Config() and before FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_ConfigEncryptWithNoChangedTextFrameTreatment(t_Handle h_FmMacsec, bool discardUncontrolled);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_ConfigChangedTextWithNoEncryptFrameTreatment
+
+ @Description   Change the treatment for received frames with the Encryption bit
+                clear and the Changed Text bit set from its default configuration
+                [DEFAULT_changedTextWithNoEncryptFrameTreatment].
+
+ @Param[in]     h_FmMacsec              FM MACSEC module descriptor.
+ @Param[in]     deliverUncontrolled     If True deliver on the uncontrolled port, else discard;
+                                        In both cases discard on the controlled port;
+                                        this provide Strict, Check or Disable mode.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Config() and before FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_ConfigChangedTextWithNoEncryptFrameTreatment(t_Handle h_FmMacsec, bool deliverUncontrolled);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_ConfigUntagFrameTreatment
+
+ @Description   Change the treatment for received frames without the MAC security tag (SecTAG)
+                from its default configuration [DEFAULT_untagFrameTreatment].
+
+ @Param[in]     h_FmMacsec     FM MACSEC module descriptor.
+ @Param[in]     treatMode      The selected mode.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Config() and before FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_ConfigUntagFrameTreatment(t_Handle h_FmMacsec, e_FmMacsecUntagFrameTreatment treatMode);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_ConfigOnlyScbIsSetFrameTreatment
+
+ @Description   Change the treatment for received frames with only SCB bit set
+                from its default configuration [DEFAULT_onlyScbIsSetFrameTreatment].
+
+ @Param[in]     h_FmMacsec              FM MACSEC module descriptor.
+ @Param[in]     deliverUncontrolled     If True deliver on the uncontrolled port, else discard;
+                                        In both cases discard on the controlled port;
+                                        this provide Strict, Check or Disable mode.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Config() and before FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_ConfigOnlyScbIsSetFrameTreatment(t_Handle h_FmMacsec, bool deliverUncontrolled);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_ConfigPnExhaustionThreshold
+
+ @Description   It's provide the ability to configure a PN exhaustion threshold;
+                When the NextPn crosses this value an interrupt event
+                is asserted to warn that the active SA should re-key.
+
+ @Param[in]     h_FmMacsec     FM MACSEC module descriptor.
+ @Param[in]     pnExhThr       If the threshold is reached, an interrupt event
+                               is asserted to re-key.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Config() and before FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_ConfigPnExhaustionThreshold(t_Handle h_FmMacsec, uint32_t pnExhThr);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_ConfigKeysUnreadable
+
+ @Description   Turn on privacy mode; All the keys and their hash values can't be read any more;
+                Can not be cleared unless hard reset.
+
+ @Param[in]     h_FmMacsec         FM MACSEC module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Config() and before FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_ConfigKeysUnreadable(t_Handle h_FmMacsec);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_ConfigSectagWithoutSCI
+
+ @Description   Promise that all generated Sectag will be without SCI included.
+
+ @Param[in]     h_FmMacsec         FM MACSEC module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Config() and before FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_ConfigSectagWithoutSCI(t_Handle h_FmMacsec);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_ConfigException
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of exceptions enablement;
+                By default all exceptions are enabled.
+
+ @Param[in]     h_FmMacsec      FM MACSEC module descriptor.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Config() and before FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_ConfigException(t_Handle h_FmMacsec, e_FmMacsecExceptions exception, bool enable);
+
+/** @} */ /* end of FM_MACSEC_advanced_init_grp group */
+/** @} */ /* end of FM_MACSEC_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_MACSEC_runtime_control_grp FM-MACSEC Runtime Control Data Unit
+
+ @Description   FM MACSEC runtime control data unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_GetRevision
+
+ @Description   Return MACSEC HW chip revision
+
+ @Param[in]     h_FmMacsec         FM MACSEC module descriptor.
+ @Param[out]    p_MacsecRevision   MACSEC revision as defined by the chip.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_GetRevision(t_Handle h_FmMacsec, uint32_t *p_MacsecRevision);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_Enable
+
+ @Description   This routine should be called after MACSEC is initialized for enabling all
+                MACSEC engines according to their existing configuration.
+
+ @Param[in]     h_FmMacsec         FM MACSEC module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Init() and when MACSEC is disabled.
+*//***************************************************************************/
+t_Error FM_MACSEC_Enable(t_Handle h_FmMacsec);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_Disable
+
+ @Description   This routine may be called when MACSEC is enabled in order to
+                disable all MACSEC engines; The MACSEC is working in bypass mode.
+
+ @Param[in]     h_FmMacsec         FM MACSEC module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Init() and when MACSEC is enabled.
+*//***************************************************************************/
+t_Error FM_MACSEC_Disable(t_Handle h_FmMacsec);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SetException
+
+ @Description   Calling this routine enables/disables the specified exception.
+
+ @Param[in]     h_FmMacsec      FM MACSEC module descriptor.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SetException(t_Handle h_FmMacsec, e_FmMacsecExceptions exception, bool enable);
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//**
+ @Function      FM_MACSEC_DumpRegs
+
+ @Description   Dump internal registers.
+
+ @Param[in]     h_FmMacsec  - FM MACSEC module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_DumpRegs(t_Handle h_FmMacsec);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+#ifdef VERIFICATION_SUPPORT
+/********************* VERIFICATION ONLY ********************************/
+/**************************************************************************//**
+ @Function      FM_MACSEC_BackdoorSet
+
+ @Description   Set register of the MACSEC memory map
+
+ @Param[in]     h_FmMacsec          FM MACSEC module descriptor.
+ @Param[out]    offset              Register offset.
+ @Param[out]    value               Value to write.
+
+
+ @Return        None
+
+ @Cautions      Allowed only following FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_BackdoorSet(t_Handle h_FmMacsec, uint32_t offset, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_BackdoorGet
+
+ @Description   Read from register of the MACSEC memory map.
+
+ @Param[in]     h_FmMacsec          FM MACSEC module descriptor.
+ @Param[out]    offset              Register offset.
+
+ @Return        Value read
+
+ @Cautions      Allowed only following FM_MACSEC_Init().
+*//***************************************************************************/
+uint32_t FM_MACSEC_BackdoorGet(t_Handle h_FmMacsec, uint32_t offset);
+#endif /* VERIFICATION_SUPPORT */
+
+/** @} */ /* end of FM_MACSEC_runtime_control_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_MACSEC_SECY_grp FM-MACSEC SecY
+
+ @Description   FM-MACSEC SecY API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+typedef uint8_t     macsecSAKey_t[32];
+typedef uint64_t    macsecSCI_t;
+typedef uint8_t     macsecAN_t;
+
+/**************************************************************************//**
+@Description   MACSEC SECY Cipher Suite
+*//***************************************************************************/
+typedef enum e_FmMacsecSecYCipherSuite {
+    e_FM_MACSEC_SECY_GCM_AES_128 = 0,       /**< GCM-AES-128 */
+#if (DPAA_VERSION >= 11)
+    e_FM_MACSEC_SECY_GCM_AES_256            /**< GCM-AES-256 */
+#endif /* (DPAA_VERSION >= 11) */
+} e_FmMacsecSecYCipherSuite;
+
+/**************************************************************************//**
+ @Description   MACSEC SECY Exceptions
+*//***************************************************************************/
+typedef enum e_FmMacsecSecYExceptions {
+    e_FM_MACSEC_SECY_EX_FRAME_DISCARDED     /**< Frame  Discarded */
+} e_FmMacsecSecYExceptions;
+
+/**************************************************************************//**
+ @Description   MACSEC SECY Events
+*//***************************************************************************/
+typedef enum e_FmMacsecSecYEvents {
+    e_FM_MACSEC_SECY_EV_NEXT_PN             /**< Next Packet Number exhaustion threshold reached */
+} e_FmMacsecSecYEvents;
+
+/**************************************************************************//**
+ @Collection   MACSEC SECY Frame Discarded Descriptor error
+*//***************************************************************************/
+typedef uint8_t    macsecTxScFrameDiscardedErrSelect_t; /**< typedef for defining Frame Discarded Descriptor errors */
+
+#define FM_MACSEC_SECY_TX_SC_FRM_DISCAR_ERR_NEXT_PN_ZERO              0x8000  /**< NextPn == 0 */
+#define FM_MACSEC_SECY_TX_SC_FRM_DISCAR_ERR_SC_DISBALE                0x4000  /**< SC is disable */
+/* @} */
+
+/**************************************************************************//**
+ @Function      t_FmMacsecSecYExceptionsCallback
+
+ @Description   Exceptions user callback routine, will be called upon an
+                exception passing the exception identification.
+
+ @Param[in]     h_App       A handle to an application layer object; This handle
+                            will be passed by the driver upon calling this callback.
+ @Param[in]     exception   The exception.
+*//***************************************************************************/
+typedef void (t_FmMacsecSecYExceptionsCallback) ( t_Handle                  h_App,
+                                                  e_FmMacsecSecYExceptions  exception);
+
+/**************************************************************************//**
+ @Function      t_FmMacsecSecYEventsCallback
+
+ @Description   Events user callback routine, will be called upon an
+                event passing the event identification.
+
+ @Param[in]     h_App       A handle to an application layer object; This handle
+                            will be passed by the driver upon calling this callback.
+ @Param[in]     event       The event.
+*//***************************************************************************/
+typedef void (t_FmMacsecSecYEventsCallback) ( t_Handle                  h_App,
+                                              e_FmMacsecSecYEvents      event);
+
+/**************************************************************************//**
+ @Description   RFC2863 MIB
+*//***************************************************************************/
+typedef struct t_MIBStatistics {
+    uint64_t  ifInOctets;              /**< Total number of byte received */
+    uint64_t  ifInPkts;                /**< Total number of packets received */
+    uint64_t  ifInMcastPkts;           /**< Total number of multicast frame received */
+    uint64_t  ifInBcastPkts;           /**< Total number of broadcast frame received */
+    uint64_t  ifInDiscards;            /**< Frames received, but discarded due to problems within the MAC RX :
+                                               - InPktsNoTag,
+                                               - InPktsLate,
+                                               - InPktsOverrun */
+    uint64_t  ifInErrors;              /**< Number of frames received with error:
+                                               - InPktsBadTag,
+                                               - InPktsNoSCI,
+                                               - InPktsNotUsingSA
+                                               - InPktsNotValid */
+    uint64_t  ifOutOctets;             /**< Total number of byte sent */
+    uint64_t  ifOutPkts;               /**< Total number of packets sent */
+    uint64_t  ifOutMcastPkts;          /**< Total number of multicast frame sent */
+    uint64_t  ifOutBcastPkts;          /**< Total number of multicast frame sent */
+    uint64_t  ifOutDiscards;           /**< Frames received, but discarded due to problems within the MAC TX N/A! */
+    uint64_t  ifOutErrors;             /**< Number of frames transmitted with error:
+                                               - FIFO Overflow Error
+                                               - FIFO Underflow Error
+                                               - Other */
+} t_MIBStatistics;
+
+/**************************************************************************//**
+ @Description   MACSEC SecY Rx SA Statistics
+*//***************************************************************************/
+typedef struct t_FmMacsecSecYRxSaStatistics {
+    uint32_t            inPktsOK;               /**< The number of frames with resolved SCI, have passed all
+                                                     frame validation frame validation with the validateFrame not set to disable */
+    uint32_t            inPktsInvalid;          /**< The number of frames with resolved SCI, that have failed frame
+                                                     validation with the validateFrame set to check */
+    uint32_t            inPktsNotValid;         /**< The number of frames with resolved SCI, discarded on the controlled port,
+                                                     that have failed frame validation with the validateFrame set to strict or the c bit is set */
+    uint32_t            inPktsNotUsingSA;       /**< The number of frames received with resolved SCI and discarded on disabled or
+                                                     not provisioned SA with validateFrame in the strict mode or the C bit is set */
+    uint32_t            inPktsUnusedSA;         /**< The number of frames received with resolved SCI on disabled or not provisioned SA
+                                                     with validateFrame not in the strict mode and the C bit is cleared */
+} t_FmMacsecSecYRxSaStatistics;
+
+/**************************************************************************//**
+ @Description   MACSEC SecY Tx SA Statistics
+*//***************************************************************************/
+typedef struct t_FmMacsecSecYTxSaStatistics {
+    uint64_t            outPktsProtected;       /**< The number of frames, that the user of the controlled port requested to
+                                                     be transmitted, which were integrity protected */
+    uint64_t            outPktsEncrypted;       /**< The number of frames, that the user of the controlled port requested to
+                                                     be transmitted, which were confidentiality protected */
+} t_FmMacsecSecYTxSaStatistics;
+
+/**************************************************************************//**
+ @Description   MACSEC SecY Rx SC Statistics
+*//***************************************************************************/
+typedef struct t_FmMacsecSecYRxScStatistics {
+    uint64_t            inPktsUnchecked;        /**< The number of frames with resolved SCI, delivered to the user of a controlled port,
+                                                     that are not validated with the validateFrame set to disable */
+    uint64_t            inPktsDelayed;          /**< The number of frames with resolved SCI, delivered to the user of a controlled port,
+                                                     that have their PN smaller than the lowest_PN with the validateFrame set to
+                                                     disable or replayProtect disabled */
+    uint64_t            inPktsLate;             /**< The number of frames with resolved SCI, discarded on the controlled port,
+                                                     that have their PN smaller than the lowest_PN with the validateFrame set to
+                                                     Check or Strict and replayProtect enabled */
+    uint64_t            inPktsOK;               /**< The number of frames with resolved SCI, have passed all
+                                                     frame validation frame validation with the validateFrame not set to disable */
+    uint64_t            inPktsInvalid;          /**< The number of frames with resolved SCI, that have failed frame
+                                                     validation with the validateFrame set to check */
+    uint64_t            inPktsNotValid;         /**< The number of frames with resolved SCI, discarded on the controlled port,
+                                                     that have failed frame validation with the validateFrame set to strict or the c bit is set */
+    uint64_t            inPktsNotUsingSA;       /**< The number of frames received with resolved SCI and discarded on disabled or
+                                                     not provisioned SA with validateFrame in the strict mode or the C bit is set */
+    uint64_t            inPktsUnusedSA;         /**< The number of frames received with resolved SCI on disabled or not provisioned SA
+                                                     with validateFrame not in the strict mode and the C bit is cleared */
+} t_FmMacsecSecYRxScStatistics;
+
+/**************************************************************************//**
+ @Description   MACSEC SecY Tx SC Statistics
+*//***************************************************************************/
+typedef struct t_FmMacsecSecYTxScStatistics {
+    uint64_t            outPktsProtected;       /**< The number of frames, that the user of the controlled port requested to
+                                                     be transmitted, which were integrity protected */
+    uint64_t            outPktsEncrypted;       /**< The number of frames, that the user of the controlled port requested to
+                                                     be transmitted, which were confidentiality protected */
+} t_FmMacsecSecYTxScStatistics;
+
+/**************************************************************************//**
+ @Description   MACSEC SecY Statistics
+*//***************************************************************************/
+typedef struct t_FmMacsecSecYStatistics {
+    t_MIBStatistics     mibCtrlStatistics;      /**< Controlled port MIB statistics */
+    t_MIBStatistics     mibNonCtrlStatistics;   /**< Uncontrolled port MIB statistics */
+/* Frame verification statistics */
+    uint64_t            inPktsUntagged;         /**< The number of received packets without the MAC security tag
+                                                     (SecTAG) with validateFrames which is not in the strict mode */
+    uint64_t            inPktsNoTag;            /**< The number of received packets discarded without the
+                                                     MAC security tag (SecTAG) with validateFrames which is in the strict mode */
+    uint64_t            inPktsBadTag;           /**< The number of received packets discarded with an invalid
+                                                     SecTAG or a zero value PN or an invalid ICV */
+    uint64_t            inPktsUnknownSCI;       /**< The number of received packets with unknown SCI with the
+                                                     condition : validateFrames is not in the strict mode and the
+                                                     C bit in the SecTAG is not set */
+    uint64_t            inPktsNoSCI;            /**< The number of received packets discarded with unknown SCI
+                                                     information with the condition : validateFrames is in the strict mode
+                                                     or the C bit in the SecTAG is set */
+    uint64_t            inPktsOverrun;          /**< The number of packets discarded because the number of
+                                                     received packets exceeded the cryptographic performance capabilities */
+/* Frame validation statistics */
+    uint64_t            inOctetsValidated;      /**< The number of octets of plaintext recovered from received frames with
+                                                     resolved SCI that were integrity protected but not encrypted */
+    uint64_t            inOctetsDecrypted;      /**< The number of octets of plaintext recovered from received frames with
+                                                     resolved SCI that were integrity protected and encrypted */
+/* Frame generation statistics */
+    uint64_t            outPktsUntagged;        /**< The number of frames, that the user of the controlled port requested to
+                                                     be transmitted, with protectFrame false */
+    uint64_t            outPktsTooLong;         /**< The number of frames, that the user of the controlled port requested to
+                                                     be transmitted, discarded due to length being larger than Maximum Frame Length (MACSEC_MFL) */
+/* Frame protection statistics */
+    uint64_t            outOctetsProtected;     /**< The number of octets of User Data in transmitted frames that were
+                                                     integrity protected but not encrypted */
+    uint64_t            outOctetsEncrypted;     /**< The number of octets of User Data in transmitted frames that were
+                                                     both integrity protected and encrypted */
+} t_FmMacsecSecYStatistics;
+
+
+/**************************************************************************//**
+ @Description   MACSEC SecY SC Params
+*//***************************************************************************/
+typedef struct t_FmMacsecSecYSCParams {
+    macsecSCI_t                 sci;            /**< The secure channel identification of the SC */
+    e_FmMacsecSecYCipherSuite   cipherSuite;    /**< Cipher suite to be used for the SC */
+} t_FmMacsecSecYSCParams;
+
+/**************************************************************************//**
+ @Group         FM_MACSEC_SECY_init_grp FM-MACSEC SecY Initialization Unit
+
+ @Description   FM-MACSEC SecY Initialization Unit
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   enum for validate frames
+*//***************************************************************************/
+typedef enum e_FmMacsecValidFrameBehavior {
+    e_FM_MACSEC_VALID_FRAME_BEHAVIOR_DISABLE = 0,   /**< disable the validation function */
+    e_FM_MACSEC_VALID_FRAME_BEHAVIOR_CHECK,         /**< enable the validation function but only for checking
+                                                         without filtering out invalid frames */
+    e_FM_MACSEC_VALID_FRAME_BEHAVIOR_STRICT         /**< enable the validation function and also strictly filter
+                                                         out those invalid frames */
+} e_FmMacsecValidFrameBehavior;
+
+/**************************************************************************//**
+ @Description   enum for sci insertion
+*//***************************************************************************/
+typedef enum e_FmMacsecSciInsertionMode {
+    e_FM_MACSEC_SCI_INSERTION_MODE_EXPLICIT_SECTAG = 0, /**< explicit sci in the sectag */
+    e_FM_MACSEC_SCI_INSERTION_MODE_EXPLICIT_MAC_SA,     /**< mac sa is overwritten with the sci*/
+    e_FM_MACSEC_SCI_INSERTION_MODE_IMPLICT_PTP          /**< implicit point-to-point sci (pre-shared) */
+} e_FmMacsecSciInsertionMode;
+
+/**************************************************************************//**
+ @Description   FM MACSEC SecY config input
+*//***************************************************************************/
+typedef struct t_FmMacsecSecYParams {
+    t_Handle                                    h_FmMacsec;             /**< A handle to the FM MACSEC object */
+    t_FmMacsecSecYSCParams                      txScParams;             /**< Tx SC Params */
+    uint32_t                                    numReceiveChannels;     /**< Number of receive channels dedicated to this SecY */
+    t_FmMacsecSecYExceptionsCallback            *f_Exception;           /**< Callback routine to be called by the driver upon SecY exception */
+    t_FmMacsecSecYEventsCallback                *f_Event;               /**< Callback routine to be called by the driver upon SecY event */
+    t_Handle                                    h_App;                  /**< A handle to an application layer object; This handle will
+                                                                             be passed by the driver upon calling the above callbacks */
+} t_FmMacsecSecYParams;
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_Config
+
+ @Description   Creates descriptor for the FM MACSEC SECY module;
+
+                The routine returns a handle (descriptor) to the FM MACSEC SECY object;
+                This descriptor must be passed as first parameter to all other
+                FM MACSEC SECY function calls;
+                No actual initialization or configuration of FM MACSEC SecY hardware is
+                done by this routine.
+
+ @Param[in]     p_FmMacsecSecYParam     Pointer to data structure of parameters.
+
+ @Return        Handle to FM MACSEC SECY object, or NULL for Failure.
+*//***************************************************************************/
+t_Handle FM_MACSEC_SECY_Config(t_FmMacsecSecYParams *p_FmMacsecSecYParam);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_Init
+
+ @Description   Initializes the FM MACSEC SECY module.
+
+ @Param[in]     h_FmMacsecSecY  FM MACSEC SECY module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_Init(t_Handle h_FmMacsecSecY);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_Free
+
+ @Description   Frees all resources that were assigned to FM MACSEC SECY module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmMacsecSecY  FM MACSEC SECY module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_Free(t_Handle h_FmMacsecSecY);
+
+/**************************************************************************//**
+ @Group         FM_MACSEC_SECY_advanced_init_grp  FM-MACSEC SecY Advanced Configuration Unit
+
+ @Description   Configuration functions used to change default values.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_ConfigSciInsertionMode
+
+ @Description   Calling this routine changes the SCI-insertion-mode in the
+                internal driver data base from its default configuration
+                [DEFAULT_sciInsertionMode]
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     sciInsertionMode    Sci insertion mode
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Config() and before FM_MACSEC_SECY_Init();
+
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_ConfigSciInsertionMode(t_Handle h_FmMacsecSecY, e_FmMacsecSciInsertionMode sciInsertionMode);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_ConfigProtectFrames
+
+ @Description   Calling this routine changes the protect-frame mode in the
+                internal driver data base from its default configuration
+                [DEFAULT_protectFrames]
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     protectFrames       If FALSE, frames are transmitted without modification
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Config() and before FM_MACSEC_SECY_Init();
+
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_ConfigProtectFrames(t_Handle h_FmMacsecSecY, bool protectFrames);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_ConfigReplayWindow
+
+ @Description   Calling this routine changes the replay-window settings in the
+                internal driver data base from its default configuration
+                [DEFAULT_replayEnable], [DEFAULT_replayWindow]
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     replayProtect;      Replay protection function mode
+ @Param[in]     replayWindow;       The size of the replay window
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Config() and before FM_MACSEC_SECY_Init();
+
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_ConfigReplayWindow(t_Handle h_FmMacsecSecY, bool replayProtect, uint32_t replayWindow);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_ConfigValidationMode
+
+ @Description   Calling this routine changes the frame-validation-behavior mode
+                in the internal driver data base from its default configuration
+                [DEFAULT_validateFrames]
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     validateFrames      Validation function mode
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Config() and before FM_MACSEC_SECY_Init();
+
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_ConfigValidationMode(t_Handle h_FmMacsecSecY, e_FmMacsecValidFrameBehavior validateFrames);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_ConfigConfidentiality
+
+ @Description   Calling this routine changes the confidentiality settings in the
+                internal driver data base from its default configuration
+                [DEFAULT_confidentialityEnable], [DEFAULT_confidentialityOffset]
+
+ @Param[in]     h_FmMacsecSecY          FM MACSEC SECY module descriptor.
+ @Param[in]     confidentialityEnable   TRUE  - confidentiality protection and integrity protection
+                                        FALSE - no confidentiality protection, only integrity protection
+ @Param[in]     confidentialityOffset   The number of initial octets of each MSDU without confidentiality protection
+                                        common values are 0, 30, and 50
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Config() and before FM_MACSEC_SECY_Init();
+
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_ConfigConfidentiality(t_Handle h_FmMacsecSecY, bool confidentialityEnable, uint16_t confidentialityOffset);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_ConfigPointToPoint
+
+ @Description   configure this SecY to work in point-to-point mode, means that
+                it will have only one rx sc;
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Config() and before FM_MACSEC_SECY_Init();
+                Can be called only once in a system; only the first secY that will call this
+                routine will be able to operate in Point-To-Point mode.
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_ConfigPointToPoint(t_Handle h_FmMacsecSecY);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_ConfigException
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of exceptions enablement;
+                By default all exceptions are enabled.
+
+ @Param[in]     h_FmMacsecSecY  FM MACSEC SECY module descriptor.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Config() and before FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_ConfigException(t_Handle h_FmMacsecSecY, e_FmMacsecSecYExceptions exception, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_ConfigEvent
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of events enablement;
+                By default all events are enabled.
+
+ @Param[in]     h_FmMacsecSecY  FM MACSEC SECY module descriptor.
+ @Param[in]     event           The event to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Config() and before FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_ConfigEvent(t_Handle h_FmMacsecSecY, e_FmMacsecSecYEvents event, bool enable);
+
+/** @} */ /* end of FM_MACSEC_SECY_advanced_init_grp group */
+/** @} */ /* end of FM_MACSEC_SECY_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_MACSEC_SECY_runtime_control_grp FM-MACSEC SecY Runtime Control Unit
+
+ @Description   FM MACSEC SECY Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_CreateRxSc
+
+ @Description   Create a receive secure channel.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     scParams            secure channel params.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Handle FM_MACSEC_SECY_CreateRxSc(t_Handle h_FmMacsecSecY, t_FmMacsecSecYSCParams *p_ScParams);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_DeleteRxSc
+
+ @Description   Deleting an initialized secure channel.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     h_Sc                SC handle as returned by FM_MACSEC_SECY_CreateRxSc.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_CreateRxSc().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_DeleteRxSc(t_Handle h_FmMacsecSecY, t_Handle h_Sc);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_CreateRxSa
+
+ @Description   Create a receive secure association for the secure channel;
+                the SA cannot be used to receive frames until FM_MACSEC_SECY_RxSaEnableReceive is called.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     h_Sc                SC handle as returned by FM_MACSEC_SECY_CreateRxSc.
+ @Param[in]     an                  association number represent the SA.
+ @Param[in]     lowestPn            the lowest acceptable PN value for a received frame.
+ @Param[in]     key                 the desired key for this SA.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_CreateRxSc().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_CreateRxSa(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an, uint32_t lowestPn, macsecSAKey_t key);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_DeleteRxSa
+
+ @Description   Deleting an initialized secure association.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     h_Sc                SC handle as returned by FM_MACSEC_SECY_CreateRxSc.
+ @Param[in]     an                  association number represent the SA.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_DeleteRxSa(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_RxSaEnableReceive
+
+ @Description   Enabling the SA to receive frames.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     h_Sc                SC handle as returned by FM_MACSEC_SECY_CreateRxSc.
+ @Param[in]     an                  association number represent the SA.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_CreateRxSa().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_RxSaEnableReceive(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_RxSaDisableReceive
+
+ @Description   Disabling the SA from receive frames.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     h_Sc                SC handle as returned by FM_MACSEC_SECY_CreateRxSc.
+ @Param[in]     an                  association number represent the SA.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_CreateRxSa().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_RxSaDisableReceive(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_RxSaUpdateNextPn
+
+ @Description   Update the next packet number expected on RX;
+                The value of nextPN shall be set to the greater of its existing value and the
+                supplied of updtNextPN (802.1AE-2006 10.7.15).
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     h_Sc                SC handle as returned by FM_MACSEC_SECY_CreateRxSc.
+ @Param[in]     an                  association number represent the SA.
+ @Param[in]     updtNextPN          the next PN value for a received frame.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_CreateRxSa().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_RxSaUpdateNextPn(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an, uint32_t updtNextPN);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_RxSaUpdateLowestPn
+
+ @Description   Update the lowest packet number expected on RX;
+                The value of lowestPN shall be set to the greater of its existing value and the
+                supplied of updtLowestPN (802.1AE-2006 10.7.15).
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     h_Sc                SC handle as returned by FM_MACSEC_SECY_CreateRxSc.
+ @Param[in]     an                  association number represent the SA.
+ @Param[in]     updtLowestPN        the lowest PN acceptable value for a received frame.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_CreateRxSa().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_RxSaUpdateLowestPn(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an, uint32_t updtLowestPN);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_RxSaModifyKey
+
+ @Description   Modify the current key of the SA with a new one.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     h_Sc                SC handle as returned by FM_MACSEC_SECY_CreateRxSc.
+ @Param[in]     an                  association number represent the SA.
+ @Param[in]     key                 new key to replace the current key.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_CreateRxSa().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_RxSaModifyKey(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an, macsecSAKey_t key);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_CreateTxSa
+
+ @Description   Create a transmit secure association for the secure channel;
+                the SA cannot be used to transmit frames until FM_MACSEC_SECY_TxSaSetActivate is called;
+                Only one SA can be active at a time.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     an                  association number represent the SA.
+ @Param[in]     key                 the desired key for this SA.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_CreateTxSa(t_Handle h_FmMacsecSecY, macsecAN_t an, macsecSAKey_t key);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_DeleteTxSa
+
+ @Description   Deleting an initialized secure association.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     an                  association number represent the SA.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_DeleteTxSa(t_Handle h_FmMacsecSecY, macsecAN_t an);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_TxSaModifyKey
+
+ @Description   Modify the key of the inactive SA with a new one.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     nextActiveAn        association number represent the next SA to be activated.
+ @Param[in]     key                 new key to replace the current key.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_TxSaModifyKey(t_Handle h_FmMacsecSecY, macsecAN_t nextActiveAn, macsecSAKey_t key);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_TxSaSetActive
+
+ @Description   Set this SA to the active SA to be used on TX for SC;
+                only one SA can be active at a time.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     an                  association number represent the SA.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_TxSaSetActive(t_Handle h_FmMacsecSecY, macsecAN_t an);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_TxSaGetActive
+
+ @Description   Get the active SA that being used for TX.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[out]    p_An                the active an.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_TxSaGetActive(t_Handle h_FmMacsecSecY, macsecAN_t *p_An);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_GetStatistics
+
+ @Description   get all statistics counters.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     p_Statistics        Structure with statistics.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_GetStatistics(t_Handle h_FmMacsecSecY, t_FmMacsecSecYStatistics *p_Statistics);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_RxScGetStatistics
+
+ @Description   get all statistics counters.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     h_Sc                Rx Sc handle.
+ @Param[in]     p_Statistics        Structure with statistics.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_RxScGetStatistics(t_Handle h_FmMacsecSecY, t_Handle h_Sc, t_FmMacsecSecYRxScStatistics *p_Statistics);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_RxSaGetStatistics
+
+ @Description   get all statistics counters
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     h_Sc                Rx Sc handle.
+ @Param[in]     an                  association number represent the SA.
+ @Param[in]     p_Statistics        Structure with statistics.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_RxSaGetStatistics(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an, t_FmMacsecSecYRxSaStatistics *p_Statistics);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_TxScGetStatistics
+
+ @Description   get all statistics counters.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     p_Statistics        Structure with statistics.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_TxScGetStatistics(t_Handle h_FmMacsecSecY, t_FmMacsecSecYTxScStatistics *p_Statistics);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_TxSaGetStatistics
+
+ @Description   get all statistics counters.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     an                  association number represent the SA.
+ @Param[in]     p_Statistics        Structure with statistics.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_TxSaGetStatistics(t_Handle h_FmMacsecSecY, macsecAN_t an, t_FmMacsecSecYTxSaStatistics *p_Statistics);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_SetException
+
+ @Description   Calling this routine enables/disables the specified exception.
+
+ @Param[in]     h_FmMacsecSecY  FM MACSEC SECY module descriptor.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_SetException(t_Handle h_FmMacsecSecY, e_FmMacsecExceptions exception, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_SetEvent
+
+ @Description   Calling this routine enables/disables the specified event.
+
+ @Param[in]     h_FmMacsecSecY  FM MACSEC SECY module descriptor.
+ @Param[in]     event           The event to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Config() and before FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_SetEvent(t_Handle h_FmMacsecSecY, e_FmMacsecSecYEvents event, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_GetRxScPhysId
+
+ @Description   return the physical id of the Secure Channel.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     h_Sc                SC handle as returned by FM_MACSEC_SECY_CreateRxSc.
+ @Param[out]    p_ScPhysId          the SC physical id.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_CreateRxSc().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_GetRxScPhysId(t_Handle h_FmMacsecSecY, t_Handle h_Sc, uint32_t *p_ScPhysId);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_GetTxScPhysId
+
+ @Description   return the physical id of the Secure Channel.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[out]    p_ScPhysId          the SC physical id.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_GetTxScPhysId(t_Handle h_FmMacsecSecY, uint32_t *p_ScPhysId);
+
+/** @} */ /* end of FM_MACSEC_SECY_runtime_control_grp group */
+/** @} */ /* end of FM_MACSEC_SECY_grp group */
+/** @} */ /* end of FM_MACSEC_grp group */
+/** @} */ /* end of FM_grp group */
+
+
+#endif /* __FM_MACSEC_EXT_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_pcd_ext.h b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_pcd_ext.h
index b4671d0..e4519cc 100644
--- a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_pcd_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_pcd_ext.h
@@ -434,7 +434,10 @@ typedef struct t_FmPcdPrsLabelParams {
     uint32_t                instructionOffset;              /**< SW parser label instruction offset (2 bytes
                                                                  resolution), relative to Parser RAM. */
     e_NetHeaderType         hdr;                            /**< The existence of this header will invoke
-                                                                 the SW parser code. */
+                                                                 the SW parser code; Use  HEADER_TYPE_NONE
+                                                                 to indicate that sw parser is to run
+                                                                 independent of the existence of any protocol
+                                                                 (run before HW parser). */
     uint8_t                 indexPerHdr;                    /**< Normally 0, if more than one SW parser
                                                                  attachments for the same header, use this
                                                                  index to distinguish between them. */
@@ -839,6 +842,16 @@ typedef protocolOpt_t   ipv6ProtocolOpt_t;      /**< IPv6 protocol options. */
                                                      environment with IPV6 header and IPV6_FRAG_1 option;
                                                      in case where fragment found, the fragment-extension offset
                                                      may be found at 'shim2' (in parser-result). */
+#if (DPAA_VERSION >= 11)
+typedef protocolOpt_t   capwapProtocolOpt_t;      /**< CAPWAP protocol options. */
+#define CAPWAP_FRAG_1               0x00000008  /**< CAPWAP reassembly option.
+                                                     CAPWAP Reassembly manipulation requires network
+                                                     environment with CAPWAP header and CAPWAP_FRAG_1 option;
+                                                     in case where fragment found, the fragment-extension offset
+                                                     may be found at 'shim2' (in parser-result). */
+#endif /* (DPAA_VERSION >= 11) */
+
+
 /* @} */
 
 #define FM_PCD_MANIP_MAX_HDR_SIZE               256
@@ -1137,11 +1150,42 @@ typedef enum e_FmPcdManipHdrInsrtSpecificL2 {
     e_FM_PCD_MANIP_HDR_INSRT_MPLS                   /**< Insert MPLS header (Unlimited MPLS labels) */
 } e_FmPcdManipHdrInsrtSpecificL2;
 
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Enumeration type for selecting QoS mapping mode
+
+                Note: In all cases except 'e_FM_PCD_MANIP_HDR_QOS_MAPPING_NONE'
+                User should instruct the port to read the parser-result
+*//***************************************************************************/
+typedef enum e_FmPcdManipHdrQosMappingMode {
+    e_FM_PCD_MANIP_HDR_QOS_MAPPING_NONE = 0,   /**< No mapping, QoS field will not be changed */
+    e_FM_PCD_MANIP_HDR_QOS_MAPPING_AS_IS, /**< QoS field will be overwritten by the last byte in the parser-result. */
+} e_FmPcdManipHdrQosMappingMode;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting QoS source
+
+                Note: In all cases except 'e_FM_PCD_MANIP_HDR_QOS_SRC_NONE'
+                User should left room for the parser-result on input/output buffer
+                and instruct the port to read/write the parser-result to the buffer (RPD should be set)
+*//***************************************************************************/
+typedef enum e_FmPcdManipHdrQosSrc {
+    e_FM_PCD_MANIP_HDR_QOS_SRC_NONE = 0,        /**< TODO */
+    e_FM_PCD_MANIP_HDR_QOS_SRC_USER_DEFINED,    /**< QoS will be taken from the last byte in the parser-result. */
+} e_FmPcdManipHdrQosSrc;
+#endif /* (DPAA_VERSION >= 11) */
+
 /**************************************************************************//**
  @Description   Enumeration type for selecting type of header insertion
 *//***************************************************************************/
 typedef enum e_FmPcdManipHdrInsrtByHdrType {
-    e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2         /**< Specific L2 fields insertion */
+    e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2,        /**< Specific L2 fields insertion */
+#if (DPAA_VERSION >= 11)
+    e_FM_PCD_MANIP_INSRT_BY_HDR_IP,                 /**< IP insertion */
+    e_FM_PCD_MANIP_INSRT_BY_HDR_UDP,                /**< UDP insertion */
+    e_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE,             /**< UDP lite insertion */
+    e_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP                 /**< CAPWAP insertion */
+#endif /* (DPAA_VERSION >= 11) */
 } e_FmPcdManipHdrInsrtByHdrType;
 
 /**************************************************************************//**
@@ -1164,9 +1208,12 @@ typedef enum e_FmPcdManipHdrCustomIpReplace {
 *//***************************************************************************/
 typedef enum e_FmPcdManipHdrRmvByHdrType {
     e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2 = 0,      /**< Specific L2 fields removal */
-#ifdef FM_CAPWAP_SUPPORT
+#if (DPAA_VERSION >= 11)
+    e_FM_PCD_MANIP_RMV_BY_HDR_CAPWAP,                  /**< CAPWAP removal */
+#endif /* (DPAA_VERSION >= 11) */
+#if (DPAA_VERSION >= 11) || ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
     e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START,           /**< Locate from data that is not the header */
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* (DPAA_VERSION >= 11) || ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT)) */
 } e_FmPcdManipHdrRmvByHdrType;
 
 /**************************************************************************//**
@@ -1242,7 +1289,10 @@ typedef enum e_FmPcdManipDontFragAction {
  @Description   Enumeration type for selecting type of special offload manipulation
 *//***************************************************************************/
 typedef enum e_FmPcdManipSpecialOffloadType {
-    e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC    /**< IPSec offload manipulation */
+    e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC,    /**< IPSec offload manipulation */
+#if (DPAA_VERSION >= 11)
+    e_FM_PCD_MANIP_SPECIAL_OFFLOAD_CAPWAP    /**< CAPWAP offload manipulation */
+#endif /* (DPAA_VERSION >= 11) */
 } e_FmPcdManipSpecialOffloadType;
 
 
@@ -1255,6 +1305,9 @@ typedef union u_FmPcdHdrProtocolOpt {
     mplsProtocolOpt_t   mplsOpt;    /**< MPLS options */
     ipv4ProtocolOpt_t   ipv4Opt;    /**< IPv4 options */
     ipv6ProtocolOpt_t   ipv6Opt;    /**< IPv6 options */
+#if (DPAA_VERSION >= 11)
+    capwapProtocolOpt_t capwapOpt;  /**< CAPWAP options */
+#endif /* (DPAA_VERSION >= 11) */
 } u_FmPcdHdrProtocolOpt;
 
 /**************************************************************************//**
@@ -1330,7 +1383,7 @@ typedef union u_FmPcdHdrProtocolOpt {
                         NET_HEADER_FIELD_UDP_PORT_SRC
                         NET_HEADER_FIELD_UDP_PORT_DST
 
-                    HEADER_TYPE_UDP_LITE: - relevant only if FM_CAPWAP_SUPPORT define
+                    HEADER_TYPE_UDP_LITE:
                         NET_HEADER_FIELD_UDP_LITE_PORT_SRC
                         NET_HEADER_FIELD_UDP_LITE_PORT_DST
 
@@ -2177,13 +2230,16 @@ typedef struct t_FmPcdManipFragOrReasmParams {
 typedef struct t_FmPcdManipHdrRmvByHdrParams {
     e_FmPcdManipHdrRmvByHdrType         type;           /**< Selection of header removal location */
     union {
-#ifdef FM_CAPWAP_SUPPORT
+#if ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
         struct {
             bool                        include;        /**< If FALSE, remove until the specified header (not including the header);
                                                              If TRUE, remove also the specified header. */
             t_FmManipHdrInfo            hdrInfo;
         } fromStartByHdr;                               /**< Relevant when type = e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START */
 #endif /* FM_CAPWAP_SUPPORT */
+#if (DPAA_VERSION >= 11)
+        t_FmManipHdrInfo                hdrInfo;        /**< Relevant when type = e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START */
+#endif /* (DPAA_VERSION >= 11) */
         e_FmPcdManipHdrRmvSpecificL2    specificL2;     /**< Relevant when type = e_FM_PCD_MANIP_BY_HDR_SPECIFIC_L2;
                                                              Defines which L2 headers to remove. */
     } u;
@@ -2298,6 +2354,84 @@ typedef struct t_FmPcdManipSpecialOffloadIPSecParams {
                                                      corresponding SA. */
 } t_FmPcdManipSpecialOffloadIPSecParams;
 
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Parameters for configuring CAPWAP fragmentation manipulation
+
+ Restrictions:
+     - Maximum number of fragments per frame is 16.
+     - Transmit confirmation is not supported.
+     - Fragmentation nodes must be set as the last PCD action (i.e. the
+       corresponding CC node key must have next engine set to e_FM_PCD_DONE).
+     - Only BMan buffers shall be used for frames to be fragmented.
+     - NOTE: The following comment is relevant only for FMAN v3 devices: IPF
+       does not support VSP. Therefore, on the same port where we have IPF we
+       cannot support VSP.
+*//***************************************************************************/
+typedef struct t_FmPcdManipFragCapwapParams {
+    uint16_t                    sizeForFragmentation;   /**< If length of the frame is greater than this value,
+                                                             CAPWAP fragmentation will be executed.*/
+    bool                        sgBpidEn;               /**< Enable a dedicated buffer pool id for the Scatter/Gather buffer allocation;
+                                                             If disabled, the Scatter/Gather buffer will be allocated from the same pool as the
+                                                             received frame's buffer. */
+    uint8_t                     sgBpid;                 /**< Scatter/Gather buffer pool id;
+                                                             This parameters is relevant when 'sgBpidEn=TRUE';
+                                                             Same LIODN number is used for these buffers as for the received frames buffers, so buffers
+                                                             of this pool need to be allocated in the same memory area as the received buffers.
+                                                             If the received buffers arrive from different sources, the Scatter/Gather BP id should be
+                                                             mutual to all these sources. */
+    bool                        compressModeEn;         /**< CAPWAP Header Options Compress Enable mode;
+                                                             When this mode is enabled then only the first fragment include the CAPWAP header options
+                                                             field (if user provides it in the input frame) and all other fragments exclude the CAPWAP
+                                                             options field (CAPWAP header is updated accordingly).*/
+} t_FmPcdManipFragCapwapParams;
+
+/**************************************************************************//**
+ @Description   Parameters for configuring CAPWAP reassembly manipulation.
+
+ Restrictions:
+    - Application must define one scheme to catch the reassembled frames.
+    - Maximum number of fragments per frame is 16.
+
+*//***************************************************************************/
+typedef struct t_FmPcdManipReassemCapwapParams {
+    uint8_t                         relativeSchemeId;    /**< Partition relative scheme id;
+                                                                 NOTE: this id must be smaller than the user schemes id to ensure that the reassembly scheme will be first match;
+                                                                 Rest schemes, if defined, should have higher relative scheme ID. */
+    uint8_t                         dataMemId;              /**< Memory partition ID for the IPR's external tables structure */
+    uint16_t                        dataLiodnOffset;        /**< LIODN offset for access the IPR's external tables structure. */
+    uint16_t                        maxReassembledFrameLength;/**< The maximum CAPWAP reassembled frame length in bytes;
+                                                                   If maxReassembledFrameLength == 0, any successful reassembled frame length is
+                                                                   considered as a valid length;
+                                                                   if maxReassembledFrameLength > 0, a successful reassembled frame which its length
+                                                                   exceeds this value is considered as an error frame (FD status[CRE] bit is set). */
+    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry;
+                                                            /**< Number of frames per hash entry needed for reassembly process */
+    uint16_t                        maxNumFramesInProcess;  /**< Number of frames which can be processed by reassembly in the same time;
+                                                                 Must be power of 2;
+                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 4 - 512;
+                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 8 - 2048. */
+    e_FmPcdManipReassemTimeOutMode  timeOutMode;            /**< Expiration delay initialized by Reassembly process */
+    uint32_t                        fqidForTimeOutFrames;   /**< FQID in which time out frames will enqueue during Time Out Process;
+                                                                 Recommended value for this field is 0; in this way timed-out frames will be discarded */
+    uint32_t                        timeoutThresholdForReassmProcess;
+                                                            /**< Represents the time interval in microseconds which defines
+                                                                 if opened frame (at least one fragment was processed but not all the fragments)is found as too old*/
+} t_FmPcdManipReassemCapwapParams;
+
+/**************************************************************************//**
+ @Description   structure for defining CAPWAP manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipSpecialOffloadCapwapParams {
+    bool                    dtls;   /**< TRUE if continue to SEC DTLS encryption */
+    e_FmPcdManipHdrQosSrc   qosSrc; /**< TODO */
+} t_FmPcdManipSpecialOffloadCapwapParams;
+
+#endif /* (DPAA_VERSION >= 11) */
+
+
 /**************************************************************************//**
  @Description   Parameters for defining special offload manipulation
 *//***************************************************************************/
@@ -2307,10 +2441,23 @@ typedef struct t_FmPcdManipSpecialOffloadParams {
     {
         t_FmPcdManipSpecialOffloadIPSecParams   ipsec;      /**< Parameters for IPSec; Relevant when
                                                                  type = e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC */
+#if (DPAA_VERSION >= 11)
+        t_FmPcdManipSpecialOffloadCapwapParams  capwap;     /**< Parameters for CAPWAP; Relevant when
+                                                                 type = e_FM_PCD_MANIP_SPECIAL_OFFLOAD_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
     } u;
 } t_FmPcdManipSpecialOffloadParams;
 
 /**************************************************************************//**
+ @Description   Parameters for defining insertion manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrInsrt {
+    uint8_t size;           /**< size of inserted section */
+    uint8_t *p_Data;        /**< data to be inserted */
+} t_FmPcdManipHdrInsrt;
+
+
+/**************************************************************************//**
  @Description   Parameters for defining generic removal manipulation
 *//***************************************************************************/
 typedef struct t_FmPcdManipHdrRmvGenericParams {
@@ -2452,6 +2599,20 @@ typedef struct t_FmPcdManipHdrInsrtSpecificL2Params {
     uint8_t                         *p_Data;        /**< data to be inserted */
 } t_FmPcdManipHdrInsrtSpecificL2Params;
 
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Parameters for defining IP insertion manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrInsrtIpParams {
+    bool    calcL4Checksum; /**< Calculate L4 checksum. */
+    e_FmPcdManipHdrQosMappingMode   mappingMode; /**< TODO */
+    uint8_t lastPidOffset;     /**< the offset of the last Protocol within
+                                 the inserted header */
+    uint16_t  id;           /**< 16 bit New IP ID */
+    t_FmPcdManipHdrInsrt insrt; /**< size and data to be inserted. */
+} t_FmPcdManipHdrInsrtIpParams;
+#endif /* (DPAA_VERSION >= 11) */
+
 /**************************************************************************//**
  @Description   Parameters for defining header insertion manipulation by header type
 *//***************************************************************************/
@@ -2459,9 +2620,15 @@ typedef struct t_FmPcdManipHdrInsrtByHdrParams {
     e_FmPcdManipHdrInsrtByHdrType               type;   /**< Selects manipulation type */
     union {
 
-       t_FmPcdManipHdrInsrtSpecificL2Params     specificL2Params;
-                                                        /**< Used when type = e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2:
-                                                             Selects which L2 headers to remove */
+        t_FmPcdManipHdrInsrtSpecificL2Params    specificL2Params;
+                                                             /**< Used when type = e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2:
+                                                              Selects which L2 headers to insert */
+#if (DPAA_VERSION >= 11)
+        t_FmPcdManipHdrInsrtIpParams             ipParams;  /**< Used when type = e_FM_PCD_MANIP_INSRT_BY_HDR_IP */
+        t_FmPcdManipHdrInsrt                    insrt;     /**< Used when type is one of e_FM_PCD_MANIP_INSRT_BY_HDR_UDP,
+                                                                e_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE, or
+                                                                e_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
     } u;
 } t_FmPcdManipHdrInsrtByHdrParams;
 
@@ -2521,6 +2688,10 @@ typedef struct t_FmPcdManipHdrParams {
 typedef struct t_FmPcdManipFragParams {
     e_NetHeaderType                     hdr;          /**< Header selection */
     union {
+#if (DPAA_VERSION >= 11)
+        t_FmPcdManipFragCapwapParams    capwapFrag;   /**< Parameters for defining CAPWAP fragmentation,
+                                                           relevant if 'hdr' = HEADER_TYPE_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
         t_FmPcdManipFragIpParams        ipFrag;       /**< Parameters for defining IP fragmentation,
                                                            relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
     } u;
@@ -2532,12 +2703,16 @@ typedef struct t_FmPcdManipFragParams {
 typedef struct t_FmPcdManipReassemParams {
     e_NetHeaderType                     hdr;          /**< Header selection */
     union {
+#if (DPAA_VERSION >= 11)
+        t_FmPcdManipReassemCapwapParams capwapReassem;  /**< Parameters for defining CAPWAP reassembly,
+                                                           relevant if 'hdr' = HEADER_TYPE_CAPWAP */
+#endif /* (DPAA_VERSION >= 11) */
+
         t_FmPcdManipReassemIpParams     ipReassem;    /**< Parameters for defining IP reassembly,
                                                            relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
     } u;
 } t_FmPcdManipReassemParams;
 
-
 /**************************************************************************//**
  @Description   Parameters for defining a manipulation node
 *//***************************************************************************/
@@ -2601,12 +2776,55 @@ typedef struct t_FmPcdManipFragIpStats {
     uint32_t    generatedFragments;     /**< Number of fragments that were generated */
 } t_FmPcdManipFragIpStats;
 
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Structure for retrieving CAPWAP reassembly statistics
+*//***************************************************************************/
+typedef struct t_FmPcdManipReassemCapwapStats {
+    uint32_t    timeout;                    /**< Counts the number of timeout occurrences */
+    uint32_t    rfdPoolBusy;                /**< Counts the number of failed attempts to allocate
+                                                 a Reassembly Frame Descriptor */
+    uint32_t    internalBufferBusy;         /**< Counts the number of times an internal buffer busy occurred */
+    uint32_t    externalBufferBusy;         /**< Counts the number of times external buffer busy occurred */
+    uint32_t    sgFragments;                /**< Counts the number of Scatter/Gather fragments */
+    uint32_t    dmaSemaphoreDepletion;      /**< Counts the number of failed attempts to allocate a DMA semaphore */
+    uint32_t    successfullyReassembled;    /**< Counts the number of successfully reassembled frames */
+    uint32_t    validFragments;             /**< Counts the total number of valid fragments that
+                                                 have been processed for all frames */
+    uint32_t    processedFragments;         /**< Counts the number of processed fragments
+                                                 (valid and error fragments) for all frames */
+    uint32_t    malformedFragments;         /**< Counts the number of malformed fragments processed for all frames */
+    uint32_t    autoLearnBusy;              /**< Counts the number of times a busy condition occurs when attempting
+                                                 to access an Reassembly Automatic Learning Hash set */
+    uint32_t    discardedFragments;         /**< Counts the number of fragments discarded by the reassembly process */
+    uint32_t    moreThan16Fragments;        /**< Counts the fragment occurrences in which the number of fragments-per-frame
+                                                 exceeds 16 */
+    uint32_t    exceedMaxReassemblyFrameLen;/**< ounts the number of times that a successful reassembled frame
+                                                 length exceeds MaxReassembledFrameLength value */
+} t_FmPcdManipReassemCapwapStats;
+
+/**************************************************************************//**
+ @Description   Structure for retrieving CAPWAP fragmentation statistics
+*//***************************************************************************/
+typedef struct t_FmPcdManipFragCapwapStats {
+    uint32_t    totalFrames;            /**< Number of frames that passed through the manipulation node */
+    uint32_t    fragmentedFrames;       /**< Number of frames that were fragmented */
+    uint32_t    generatedFragments;     /**< Number of fragments that were generated */
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    uint8_t     sgAllocationFailure;    /**< Number of allocation failure of s/g buffers */
+#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+} t_FmPcdManipFragCapwapStats;
+#endif /* (DPAA_VERSION >= 11) */
+
 /**************************************************************************//**
  @Description   Structure for retrieving reassembly statistics
 *//***************************************************************************/
 typedef struct t_FmPcdManipReassemStats {
     union {
         t_FmPcdManipReassemIpStats  ipReassem;  /**< Structure for IP reassembly statistics */
+#if (DPAA_VERSION >= 11)
+        t_FmPcdManipReassemCapwapStats  capwapReassem;  /**< Structure for CAPWAP reassembly statistics */
+#endif /* (DPAA_VERSION >= 11) */
     } u;
 } t_FmPcdManipReassemStats;
 
@@ -2616,6 +2834,9 @@ typedef struct t_FmPcdManipReassemStats {
 typedef struct t_FmPcdManipFragStats {
     union {
         t_FmPcdManipFragIpStats     ipFrag;     /**< Structure for IP fragmentation statistics */
+#if (DPAA_VERSION >= 11)
+        t_FmPcdManipFragCapwapStats capwapFrag; /**< Structure for CAPWAP fragmentation statistics */
+#endif /* (DPAA_VERSION >= 11) */
     } u;
 } t_FmPcdManipFragStats;
 
diff --git a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h
index a9986b9..dbade61 100644
--- a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h
@@ -45,6 +45,7 @@
 #include "fm_ext.h"
 #include "net_ext.h"
 
+
 /**************************************************************************//**
 
  @Group         FM_grp Frame Manager API
@@ -100,8 +101,8 @@ typedef enum e_FmPortPcdSupport {
     , e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR     /**< Use Parser, Keygen and Policer */
     , e_FM_PORT_PCD_SUPPORT_PRS_AND_CC              /**< Use Parser and Coarse Classification */
     , e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR     /**< Use Parser and Coarse Classification and Policer */
-#ifdef FM_CAPWAP_SUPPORT
     , e_FM_PORT_PCD_SUPPORT_CC_ONLY                 /**< Use only Coarse Classification */
+#ifdef FM_CAPWAP_SUPPORT
     , e_FM_PORT_PCD_SUPPORT_CC_AND_KG               /**< Use Coarse Classification,and Keygen */
     , e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR      /**< Use Coarse Classification, Keygen and Policer */
 #endif /* FM_CAPWAP_SUPPORT */
@@ -434,6 +435,7 @@ typedef struct t_FmPortPerformanceCnt {
     uint32_t    fifoCompVal;            /**< Fifo compare value (in bytes) */
 } t_FmPortPerformanceCnt;
 
+
 /**************************************************************************//**
  @Description   A structure for defining the sizes of the Deep Sleep
                 the Auto Response tables
@@ -1292,6 +1294,25 @@ typedef enum e_FmPortCounters {
     e_FM_PORT_COUNTERS_DEQ_CONFIRM                  /**< QMI counter */
 } e_FmPortCounters;
 
+typedef struct t_FmPortBmiStats {
+    uint32_t cntCycle;
+    uint32_t cntTaskUtil;
+    uint32_t cntQueueUtil;
+    uint32_t cntDmaUtil;
+    uint32_t cntFifoUtil;
+    uint32_t cntRxPauseActivation;
+    uint32_t cntFrame;
+    uint32_t cntDiscardFrame;
+    uint32_t cntDeallocBuf;
+    uint32_t cntRxBadFrame;
+    uint32_t cntRxLargeFrame;
+    uint32_t cntRxFilterFrame;
+    uint32_t cntRxListDmaErr;
+    uint32_t cntRxOutOfBuffersDiscard;
+    uint32_t cntWredDiscard;
+    uint32_t cntLengthErr;
+    uint32_t cntUnsupportedFormat;
+} t_FmPortBmiStats;
 
 /**************************************************************************//**
  @Description   Structure for Port id parameters.
@@ -1389,10 +1410,11 @@ typedef struct t_FmPortDsarEchoIpv6Info
 
 *//***************************************************************************/
 typedef struct {
-    uint16_t oidSize;     /**< Size in octets of the OID. */
-    uint16_t resSize;     /**< Size in octets of the value that is attached to the OID. */
-    uint8_t *p_Oid;       /**< Pointer to the OID. OID is encoded in BER but type and length are excluded. */
-    uint64_t resValOrPtr; /**< Value (for up to 4 octets) or pointer to the Value. Encoded in BER. */
+	uint16_t     oidSize;
+	uint8_t      *oidVal; /* only the oid string */
+	uint16_t     resSize;
+	uint8_t      *resVal; /* resVal will be the entire reply,
+				i.e. "Type|Length|Value" */
 } t_FmPortDsarOidsEntry;
 
 /**************************************************************************//**
@@ -1456,16 +1478,16 @@ typedef struct t_FmPortDsarFilteringInfo
     /* IP protocol filtering parameters */
     uint8_t     ipProtTableSize;
     uint8_t     *p_IpProtTablePtr;
-    bool        ipProtDropOnHit;  /* when TRUE, hit in the table will cause the packet to be droped,
-                                         miss will pass the packet to UDP/TCP filters if needed and if not
+    bool        ipProtPassOnHit;  /* when TRUE, miss in the table will cause the packet to be droped,
+                                         hit will pass the packet to UDP/TCP filters if needed and if not
                                          to the classification tree. If the classification tree will pass
                                          the packet to a queue it will cause a wake interupt.
                                          When FALSE it the other way around. */
     /* UDP port filtering parameters */
     uint8_t     udpPortsTableSize;
     t_FmPortDsarFilteringEntry *p_UdpPortsTablePtr;
-    bool        udpPortDropOnHit; /* when TRUE, hit in the table will cause the packet to be droped,
-                                         miss will pass the packet to classification tree.
+    bool        udpPortPassOnHit; /* when TRUE, miss in the table will cause the packet to be droped,
+                                         hit will pass the packet to classification tree.
                                          If the classification tree will pass the packet to a queue it
                                          will cause a wake interupt.
                                          When FALSE it the other way around. */
@@ -1473,8 +1495,8 @@ typedef struct t_FmPortDsarFilteringInfo
     uint16_t    tcpFlagsMask;
     uint8_t     tcpPortsTableSize;
     t_FmPortDsarFilteringEntry *p_TcpPortsTablePtr;
-    bool        tcpPortDropOnHit; /* when TRUE, hit in the table will cause the packet to be droped,
-                                         miss will pass the packet to classification tree.
+    bool        tcpPortPassOnHit; /* when TRUE, miss in the table will cause the packet to be droped,
+                                         hit will pass the packet to classification tree.
                                          If the classification tree will pass the packet to a queue it
                                          will cause a wake interupt.
                                          When FALSE it the other way around. */
@@ -1499,11 +1521,7 @@ typedef struct t_FmPortDsarParams
 
  @Description   Enter Deep Sleep Auto Response mode.
                 This function write the apropriate values to in the relevant
-                tables in the MURAM. It then set the Tx port in independent
-                mode as needed and redirect the receive flow to go through the
-                Dsar Fman-ctrl code
-
-                Calling this routine invalidates the descriptor.
+                tables in the MURAM.
 
  @Param[in]     h_FmPortRx - FM PORT module descriptor
  @Param[in]     params - Auto Response parameters
@@ -1515,6 +1533,23 @@ typedef struct t_FmPortDsarParams
 t_Error FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params);
 
 /**************************************************************************//**
+ @Function      FM_PORT_EnterDsarFinal
+
+ @Description   Enter Deep Sleep Auto Response mode.
+                This function sets the Tx port in independent mode as needed
+                and redirect the receive flow to go through the
+                Dsar Fman-ctrl code
+
+ @Param[in]     h_DsarRxPort - FM Rx PORT module descriptor
+ @Param[in]     h_DsarTxPort - FM Tx PORT module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_EnterDsarFinal(t_Handle h_DsarRxPort, t_Handle h_DsarTxPort);
+
+/**************************************************************************//**
  @Function      FM_PORT_ExitDsar
 
  @Description   Exit Deep Sleep Auto Response mode.
@@ -1559,7 +1594,7 @@ typedef struct t_FmPortDsarStats
  @Description   Return statistics for Deep Sleep Auto Response
 
  @Param[in]     h_FmPortRx - FM PORT module descriptor
- @Param[out]	stats - structure containing the statistics counters
+ @Param[out]    stats - structure containing the statistics counters
 
  @Return        E_OK on success; Error code otherwise.
 *//***************************************************************************/
@@ -1826,6 +1861,21 @@ t_Error FM_PORT_AnalyzePerformanceParams(t_Handle h_FmPort);
 t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enable);
 
 /**************************************************************************//**
+ @Function      FM_PORT_GetBmiCounters
+
+ @Description   Read port's BMI stat counters and place them into
+                a designated structure of counters.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[out]    p_BmiStats  counters structure
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_GetBmiCounters(t_Handle h_FmPort, t_FmPortBmiStats *p_BmiStats);
+
+/**************************************************************************//**
  @Function      FM_PORT_GetCounter
 
  @Description   Reads one of the FM PORT counters.
@@ -2126,7 +2176,12 @@ typedef union u_FmPcdHdrPrsOpts {
  @Description   A structure for defining each header for the parser
 *//***************************************************************************/
 typedef struct t_FmPcdPrsAdditionalHdrParams {
-    e_NetHeaderType         hdr;            /**< Selected header */
+    e_NetHeaderType         hdr;            /**< Selected header; use  HEADER_TYPE_NONE
+                                                 to indicate that sw parser is to run first
+                                                 (before HW parser, and independent of the
+                                                 existence of any protocol), in this case,
+                                                 swPrsEnable must be set, and all other
+                                                 parameters are irrelevant.  */
     bool                    errDisable;     /**< TRUE to disable error indication */
     bool                    swPrsEnable;    /**< Enable jump to SW parser when this
                                                  header is recognized by the HW parser. */
@@ -2215,7 +2270,10 @@ typedef struct t_FmPortPcdParams {
                                                      or if any flow uses a KG scheme were policer
                                                      profile is not generated
                                                      ('bypassPlcrProfileGeneration selected'). */
-    t_Handle                h_IpReassemblyManip;/**< IP Reassembly manipulation */
+    t_Handle                h_IpReassemblyManip;    /**< IP Reassembly manipulation */
+#if (DPAA_VERSION >= 11)
+    t_Handle                h_CapwapReassemblyManip;/**< CAPWAP Reassembly manipulation */
+#endif /* (DPAA_VERSION >= 11) */
 } t_FmPortPcdParams;
 
 /**************************************************************************//**
diff --git a/drivers/net/ethernet/freescale/fman/inc/core_ext.h b/drivers/net/ethernet/freescale/fman/inc/core_ext.h
index 59a9e17..077da79 100644
--- a/drivers/net/ethernet/freescale/fman/inc/core_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/core_ext.h
@@ -44,13 +44,32 @@
 #define __CORE_EXT_H
 
 
+#ifdef CONFIG_ARM64
 #include "arm_ext.h"
 #include <linux/smp.h>
+#endif /* CONFIG_ARM64 */
+
+#ifndef CONFIG_ARM64
+#ifdef NCSW_PPC_CORE
+#include "ppc_ext.h"
+#elif defined(NCSW_VXWORKS)
+#include "core_vxw_ext.h"
+#else
+#error "Core is not defined!"
+#endif /* NCSW_CORE */
+#endif /* !CONFIG_ARM64 */
 
 #if (!defined(CORE_IS_LITTLE_ENDIAN) && !defined(CORE_IS_BIG_ENDIAN))
 #error "Must define core as little-endian or big-endian!"
 #endif /* (!defined(CORE_IS_LITTLE_ENDIAN) && ... */
 
+#ifndef CONFIG_ARM64
+#ifndef CORE_CACHELINE_SIZE
+#error "Must define the core cache-line size!"
+#endif /* !CORE_CACHELINE_SIZE */
+#endif /* !CONFIG_ARM64 */
+
+
 /**************************************************************************//**
  @Function      CORE_GetId
 
@@ -58,7 +77,9 @@
 
  @Return        Core ID.
 *//***************************************************************************/
-//uint32_t CORE_GetId(void);
+#ifndef CONFIG_ARM64
+uint32_t CORE_GetId(void);
+#endif /* !CONFIG_ARM64 */
 
 /**************************************************************************//**
  @Function      CORE_MemoryBarrier
diff --git a/drivers/net/ethernet/freescale/fman/inc/ddr_std_ext.h b/drivers/net/ethernet/freescale/fman/inc/ddr_std_ext.h
index 3d8906d..8bb343fc 100644
--- a/drivers/net/ethernet/freescale/fman/inc/ddr_std_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/ddr_std_ext.h
@@ -74,3 +74,4 @@ typedef enum e_DdrMode
 
 
 #endif /* __DDR_SDT_EXT_H */
+
diff --git a/drivers/net/ethernet/freescale/fman/inc/debug_ext.h b/drivers/net/ethernet/freescale/fman/inc/debug_ext.h
index 00ae748..57db0a1 100644
--- a/drivers/net/ethernet/freescale/fman/inc/debug_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/debug_ext.h
@@ -55,24 +55,26 @@
 
 #define DUMP_Print          XX_Print
 #define DUMP_MAX_LEVELS     6
+#define DUMP_IDX_LEN        6
 #define DUMP_MAX_STR        64
 
 
 #define _CREATE_DUMP_SUBSTR(phrase) \
     dumpTmpLevel = 0; dumpSubStr[0] = '\0'; \
-    sprintf(dumpTmpStr, "%s", #phrase); \
+    snprintf(dumpTmpStr, DUMP_MAX_STR, "%s", #phrase); \
     p_DumpToken = strtok(dumpTmpStr, (dumpIsArr[0] ? "[" : ".")); \
-    while (p_DumpToken != NULL) \
+    while ((p_DumpToken != NULL) && (dumpTmpLevel < DUMP_MAX_LEVELS)) \
     { \
-        strcat(dumpSubStr, p_DumpToken); \
+        strlcat(dumpSubStr, p_DumpToken, DUMP_MAX_STR); \
         if (dumpIsArr[dumpTmpLevel]) \
         { \
-            strcat(dumpSubStr, dumpIdxStr[dumpTmpLevel]); \
+            strlcat(dumpSubStr, dumpIdxStr[dumpTmpLevel], DUMP_MAX_STR); \
             p_DumpToken = strtok(NULL, "."); \
         } \
-        if ((p_DumpToken = strtok(NULL, (dumpIsArr[++dumpTmpLevel] ? "[" : "."))) != 0) \
-            strcat(dumpSubStr, "."); \
-    }\
+        if ((p_DumpToken != NULL) && \
+            ((p_DumpToken = strtok(NULL, (dumpIsArr[++dumpTmpLevel] ? "[" : "."))) != NULL)) \
+            strlcat(dumpSubStr, ".", DUMP_MAX_STR); \
+    }
 
 
 /**************************************************************************//**
@@ -99,11 +101,11 @@
                 starts.
 *//***************************************************************************/
 #define DECLARE_DUMP \
-    char    dumpIdxStr[DUMP_MAX_LEVELS + 1][6] = { "", }; \
+    char    dumpIdxStr[DUMP_MAX_LEVELS + 1][DUMP_IDX_LEN] = { "", }; \
     char    dumpSubStr[DUMP_MAX_STR] = ""; \
     char    dumpTmpStr[DUMP_MAX_STR] = ""; \
     char    *p_DumpToken = NULL; \
-    int     dumpArrIdx = 0, dumpArrSize = 0, dumpVarSize = 0, dumpLevel = 0, dumpTmpLevel = 0; \
+    int     dumpArrIdx = 0, dumpArrSize = 0, dumpLevel = 0, dumpTmpLevel = 0; \
     uint8_t dumpIsArr[DUMP_MAX_LEVELS + 1] = { 0 }; \
     /* Prevent warnings if not all used */ \
     UNUSED(dumpIdxStr[0][0]); \
@@ -112,7 +114,6 @@
     UNUSED(p_DumpToken); \
     UNUSED(dumpArrIdx); \
     UNUSED(dumpArrSize); \
-    UNUSED(dumpVarSize); \
     UNUSED(dumpLevel); \
     UNUSED(dumpTmpLevel); \
     UNUSED(dumpIsArr[0]);
@@ -164,8 +165,8 @@
 *//***************************************************************************/
 #define DUMP_SUBSTRUCT_ARRAY(idx, cnt) \
     for (idx=0, dumpIsArr[dumpLevel++] = 1; \
-         (idx < cnt) && sprintf(dumpIdxStr[dumpLevel-1], "[%d]", idx); \
-         idx++, ((idx < cnt) || ((dumpIsArr[--dumpLevel] = 0) == 0)))
+         (idx < cnt) && (dumpLevel > 0) && snprintf(dumpIdxStr[dumpLevel-1], DUMP_IDX_LEN, "[%d]", idx); \
+         idx++, ((idx < cnt) || (dumpIsArr[--dumpLevel] = 0)))
 
 
 /**************************************************************************//**
@@ -189,19 +190,8 @@
         void            *addr = (void *)&((st)->phrase); \
         physAddress_t   physAddr = XX_VirtToPhys(addr); \
         _CREATE_DUMP_SUBSTR(phrase); \
-        dumpVarSize = sizeof((st)->phrase); \
-        switch (dumpVarSize) \
-        { \
-            case 1:  DUMP_Print("0x%010llX: 0x%02x%14s\t%s\r\n", \
-                                physAddr, GET_UINT8(*(uint8_t*)addr), "", dumpSubStr); break; \
-            case 2:  DUMP_Print("0x%010llX: 0x%04x%12s\t%s\r\n", \
-                                physAddr, GET_UINT16(*(uint16_t*)addr), "", dumpSubStr); break; \
-            case 4:  DUMP_Print("0x%010llX: 0x%08x%8s\t%s\r\n", \
-                                physAddr, GET_UINT32(*(uint32_t*)addr), "", dumpSubStr); break; \
-            case 8:  DUMP_Print("0x%010llX: 0x%016llx\t%s\r\n", \
-                                physAddr, GET_UINT64(*(uint64_t*)addr), dumpSubStr); break; \
-            default: DUMP_Print("Bad size %d (" #st "->" #phrase ")\r\n", dumpVarSize); \
-        } \
+        DUMP_Print("0x%010llX: 0x%08x%8s\t%s\r\n", \
+                   physAddr, GET_UINT32(*(uint32_t*)addr), "", dumpSubStr); \
     } while (0)
 
 
@@ -223,38 +213,15 @@
         physAddress_t physAddr; \
         _CREATE_DUMP_SUBSTR(phrase); \
         dumpArrSize = ARRAY_SIZE((st)->phrase); \
-        dumpVarSize = sizeof((st)->phrase[0]); \
-        switch (dumpVarSize) \
-        { \
-            case 1: \
-                for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
-                    physAddr = XX_VirtToPhys((void *)&((st)->phrase[dumpArrIdx])); \
-                    DUMP_Print("0x%010llX: 0x%02x%14s\t%s[%d]\r\n", \
-                               physAddr, GET_UINT8((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
-                } break; \
-            case 2: \
-                for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
-                    physAddr = XX_VirtToPhys((void *)&((st)->phrase[dumpArrIdx])); \
-                    DUMP_Print("0x%010llX: 0x%04x%12s\t%s[%d]\r\n", \
-                               physAddr, GET_UINT16((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
-                } break; \
-            case 4: \
-                for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
-                    physAddr = XX_VirtToPhys((void *)&((st)->phrase[dumpArrIdx])); \
-                    DUMP_Print("0x%010llX: 0x%08x%8s\t%s[%d]\r\n", \
-                               physAddr, GET_UINT32((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
-                } break; \
-            case 8: \
-                for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
-                    physAddr = XX_VirtToPhys((void *)&((st)->phrase[dumpArrIdx])); \
-                    DUMP_Print("0x%010llX: 0x%016llx\t%s[%d]\r\n", \
-                               physAddr, GET_UINT64((st)->phrase[dumpArrIdx]), dumpSubStr, dumpArrIdx); \
-                } break; \
-            default: DUMP_Print("Bad size %d (" #st "->" #phrase "[0])\r\n", dumpVarSize); \
+        for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
+            physAddr = XX_VirtToPhys((void *)&((st)->phrase[dumpArrIdx])); \
+            DUMP_Print("0x%010llX: 0x%08x%8s\t%s[%d]\r\n", \
+                       physAddr, GET_UINT32((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
         } \
     } while (0)
 
 
+
 #endif /* DEBUG_ERRORS > 0 */
 
 
@@ -263,3 +230,4 @@
 
 
 #endif /* __DEBUG_EXT_H */
+
diff --git a/drivers/net/ethernet/freescale/fman/inc/endian_ext.h b/drivers/net/ethernet/freescale/fman/inc/endian_ext.h
index 252f89b..5cdec66 100644
--- a/drivers/net/ethernet/freescale/fman/inc/endian_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/endian_ext.h
@@ -444,3 +444,4 @@ static __inline__ void SwapUint64P(uint64_t *p_Val)
 
 
 #endif /* __ENDIAN_EXT_H */
+
diff --git a/drivers/net/ethernet/freescale/fman/inc/error_ext.h b/drivers/net/ethernet/freescale/fman/inc/error_ext.h
index 0bbaafb..d746db7 100644
--- a/drivers/net/ethernet/freescale/fman/inc/error_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/error_ext.h
@@ -327,7 +327,13 @@ int ERROR_DYNAMIC_LEVEL = ERROR_GLOBAL_LEVEL;
 #endif /* !ERROR_DYNAMIC_LEVEL */
 
 #define PRINT_FORMAT        "[CPU%02d, %s:%d %s]"
+
+#ifdef CONFIG_ARM64
 #define PRINT_FMT_PARAMS    raw_smp_processor_id(), __FILE__, __LINE__, __FUNCTION__
+#else
+#define PRINT_FMT_PARAMS    CORE_GetId(), __FILE__, __LINE__, __FUNCTION__
+#endif /* CONFIG_ARM64 */
+
 
 #if (!(defined(DEBUG_ERRORS)) || (DEBUG_ERRORS == 0))
 /* No debug/error/event messages at all */
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/common/arch/ppc_access.h b/drivers/net/ethernet/freescale/fman/inc/flib/common/arch/ppc_access.h
index c3953bb..c7b9b46 100644
--- a/drivers/net/ethernet/freescale/fman/inc/flib/common/arch/ppc_access.h
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/common/arch/ppc_access.h
@@ -34,3 +34,4 @@
 #define FL_E500_MACROS_H
 
 #endif /* FL_E500_MACROS_H */
+
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/common/general.h b/drivers/net/ethernet/freescale/fman/inc/flib/common/general.h
index 0bcb2f9..7f63db5 100644
--- a/drivers/net/ethernet/freescale/fman/inc/flib/common/general.h
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/common/general.h
@@ -41,6 +41,10 @@
 
 extern uint32_t get_mac_addr_crc(uint64_t _addr);
 
+#ifndef CONFIG_ARM64
+#define iowrite32be(val, addr)  WRITE_UINT32(*addr, val)
+#define ioread32be(addr)        GET_UINT32(*addr)
+#endif /* !CONFIG_ARM64 */
 
 #define ether_crc(len, addr)    get_mac_addr_crc(*(uint64_t *)(addr)>>16)
 
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman.h
index 68b323a..cec4e10 100755
--- a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman.h
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman.h
@@ -158,8 +158,7 @@ struct fman_fpm_regs {
 	uint32_t fmfp_ee;	/**< FPM Event & Mask 0xdc */
 	uint32_t fmfp_cev[4];	/**< FPM CPU Event 1-4 0xe0-0xef */
 	uint32_t res00f0[4];	/**< res 0xf0-0xff */
-	uint32_t fmfp_ps[50];	/**< FPM Port Status 0x100-0x1c7 */
-	uint32_t res01c8[14];	/**< res 0x1c8-0x1ff */
+	uint32_t fmfp_ps[64];	/**< FPM Port Status 0x100-0x1ff */
 	uint32_t fmfp_clfabc;	/**< FPM CLFABC 0x200 */
 	uint32_t fmfp_clfcc;	/**< FPM CLFCC 0x204 */
 	uint32_t fmfp_clfaval;	/**< FPM CLFAVAL 0x208 */
@@ -754,7 +753,7 @@ void fman_set_dma_emergency(struct fman_dma_regs *dma_rg, bool is_write,
 				bool enable);
 void fman_set_dma_ext_bus_pri(struct fman_dma_regs *dma_rg, uint32_t pri);
 void fman_set_congestion_group_pfc_priority(uint32_t *cpg_rg,
-				                        uint32_t congestion_group_id,
+			    	                        uint32_t congestion_group_id,
 				                            uint8_t priority_bit_map);
 
 
@@ -787,7 +786,7 @@ int fman_modify_counter(struct fman_rg *fman_rg,
 void fman_force_intr(struct fman_rg *fman_rg,
 				enum fman_exceptions exception);
 void fman_set_vsp_window(struct fman_bmi_regs *bmi_rg,
-				     uint8_t port_id,
+			    	     uint8_t port_id,
 				         uint8_t base_storage_profile,
 				         uint8_t log2_num_of_profiles);
 
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_kg.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_kg.h
index dd981bb..010e4b7 100644
--- a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_kg.h
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_kg.h
@@ -461,7 +461,7 @@ void fman_kg_set_dflt_val(struct fman_kg_regs *regs,
 void fman_kg_set_data_after_prs(struct fman_kg_regs *regs, uint8_t offset);
 
 
-
+	
 /**************************************************************************//**
   @Description       NIA Description
 *//***************************************************************************/
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac.h
index 2d2e795..0dd8286 100644
--- a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac.h
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac.h
@@ -71,6 +71,7 @@
 #define TX_FIFO_SECTIONS_TX_EMPTY_PFC_1G		0x00040000
 #define TX_FIFO_SECTIONS_TX_AVAIL_10G			0x00000019
 #define TX_FIFO_SECTIONS_TX_AVAIL_1G			0x00000020
+#define TX_FIFO_SECTIONS_TX_AVAIL_SLOW_10G		0x00000060
 
 #define GET_TX_EMPTY_DEFAULT_VALUE(_val)					\
 _val &= ~TX_FIFO_SECTIONS_TX_EMPTY_MASK;					\
@@ -369,6 +370,7 @@ int fman_memac_init(struct memac_regs *regs,
 	struct memac_cfg *cfg,
 	enum enet_interface enet_interface,
 	enum enet_speed enet_speed,
+	bool slow_10g_if,
 	uint32_t exceptions);
 
 void fman_memac_enable(struct memac_regs *regs, bool apply_rx, bool apply_tx);
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_port.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_port.h
index 292d37d..080a23e 100755
--- a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_port.h
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_port.h
@@ -274,8 +274,7 @@ struct fman_port_oh_bmi_regs {
 	uint32_t reserved0080[0x20];	/**< 0x080 - 0x0FF Reserved */
 	uint32_t fmbm_oebmpi[2];	/**< Buf Mngr Observed Pool Info */
 	uint32_t reserved0108[0x16];	/**< 0x108 - 0x15F Reserved */
-	uint32_t fmbm_ocgm;		/**< Observed Congestion Group Map */
-	uint32_t reserved0164[0x7];	/**< 0x164 - 0x17F Reserved */
+	uint32_t fmbm_ocgm[FMAN_PORT_CG_MAP_NUM]; /**< Observed Congestion Group Map */
 	uint32_t fmbm_ompd;		/**< Observed BMan Pool Depletion */
 	uint32_t reserved0184[0x1F];	/**< 0x184 - 0x1FF Reserved */
 	uint32_t fmbm_ostc;		/**< O/H Statistics Counters  */
diff --git a/drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3H/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3H/dpaa_integration_ext.h
new file mode 100644
index 0000000..ce9c3e7
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3H/dpaa_integration_ext.h
@@ -0,0 +1,290 @@
+/*
+ * Copyright 2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+
+ @File          dpaa_integration_ext.h
+
+ @Description   T4240 FM external definitions and structures.
+*//***************************************************************************/
+#ifndef __DPAA_INTEGRATION_EXT_H
+#define __DPAA_INTEGRATION_EXT_H
+
+#include "std_ext.h"
+
+
+#define DPAA_VERSION    11
+
+/**************************************************************************//**
+ @Description   DPAA SW Portals Enumeration.
+*//***************************************************************************/
+typedef enum
+{
+    e_DPAA_SWPORTAL0 = 0,
+    e_DPAA_SWPORTAL1,
+    e_DPAA_SWPORTAL2,
+    e_DPAA_SWPORTAL3,
+    e_DPAA_SWPORTAL4,
+    e_DPAA_SWPORTAL5,
+    e_DPAA_SWPORTAL6,
+    e_DPAA_SWPORTAL7,
+    e_DPAA_SWPORTAL8,
+    e_DPAA_SWPORTAL9,
+    e_DPAA_SWPORTAL10,
+    e_DPAA_SWPORTAL11,
+    e_DPAA_SWPORTAL12,
+    e_DPAA_SWPORTAL13,
+    e_DPAA_SWPORTAL14,
+    e_DPAA_SWPORTAL15,
+    e_DPAA_SWPORTAL16,
+    e_DPAA_SWPORTAL17,
+    e_DPAA_SWPORTAL18,
+    e_DPAA_SWPORTAL19,
+    e_DPAA_SWPORTAL20,
+    e_DPAA_SWPORTAL21,
+    e_DPAA_SWPORTAL22,
+    e_DPAA_SWPORTAL23,
+    e_DPAA_SWPORTAL24,
+    e_DPAA_SWPORTAL_DUMMY_LAST
+} e_DpaaSwPortal;
+
+/**************************************************************************//**
+ @Description   DPAA Direct Connect Portals Enumeration.
+*//***************************************************************************/
+typedef enum
+{
+    e_DPAA_DCPORTAL0 = 0,
+    e_DPAA_DCPORTAL1,
+    e_DPAA_DCPORTAL2,
+    e_DPAA_DCPORTAL_DUMMY_LAST
+} e_DpaaDcPortal;
+
+#define DPAA_MAX_NUM_OF_SW_PORTALS      e_DPAA_SWPORTAL_DUMMY_LAST
+#define DPAA_MAX_NUM_OF_DC_PORTALS      e_DPAA_DCPORTAL_DUMMY_LAST
+
+/*****************************************************************************
+ QMan INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define QM_MAX_NUM_OF_POOL_CHANNELS     15      /**< Total number of channels, dedicated and pool */
+#define QM_MAX_NUM_OF_WQ                8       /**< Number of work queues per channel */
+#define QM_MAX_NUM_OF_CGS               256     /**< Congestion groups number */
+#define QM_MAX_NUM_OF_FQIDS             (16 * MEGABYTE)
+                                                /**< FQIDs range - 24 bits */
+
+/**************************************************************************//**
+ @Description   Work Queue Channel assignments in QMan.
+*//***************************************************************************/
+typedef enum
+{
+    e_QM_FQ_CHANNEL_SWPORTAL0 = 0x0,              /**< Dedicated channels serviced by software portals 0 to 24 */
+    e_QM_FQ_CHANNEL_SWPORTAL1,
+    e_QM_FQ_CHANNEL_SWPORTAL2,
+    e_QM_FQ_CHANNEL_SWPORTAL3,
+    e_QM_FQ_CHANNEL_SWPORTAL4,
+    e_QM_FQ_CHANNEL_SWPORTAL5,
+    e_QM_FQ_CHANNEL_SWPORTAL6,
+    e_QM_FQ_CHANNEL_SWPORTAL7,
+    e_QM_FQ_CHANNEL_SWPORTAL8,
+    e_QM_FQ_CHANNEL_SWPORTAL9,
+    e_QM_FQ_CHANNEL_SWPORTAL10,
+    e_QM_FQ_CHANNEL_SWPORTAL11,
+    e_QM_FQ_CHANNEL_SWPORTAL12,
+    e_QM_FQ_CHANNEL_SWPORTAL13,
+    e_QM_FQ_CHANNEL_SWPORTAL14,
+    e_QM_FQ_CHANNEL_SWPORTAL15,
+    e_QM_FQ_CHANNEL_SWPORTAL16,
+    e_QM_FQ_CHANNEL_SWPORTAL17,
+    e_QM_FQ_CHANNEL_SWPORTAL18,
+    e_QM_FQ_CHANNEL_SWPORTAL19,
+    e_QM_FQ_CHANNEL_SWPORTAL20,
+    e_QM_FQ_CHANNEL_SWPORTAL21,
+    e_QM_FQ_CHANNEL_SWPORTAL22,
+    e_QM_FQ_CHANNEL_SWPORTAL23,
+    e_QM_FQ_CHANNEL_SWPORTAL24,
+
+    e_QM_FQ_CHANNEL_POOL1 = 0x401,               /**< Pool channels that can be serviced by any of the software portals */
+    e_QM_FQ_CHANNEL_POOL2,
+    e_QM_FQ_CHANNEL_POOL3,
+    e_QM_FQ_CHANNEL_POOL4,
+    e_QM_FQ_CHANNEL_POOL5,
+    e_QM_FQ_CHANNEL_POOL6,
+    e_QM_FQ_CHANNEL_POOL7,
+    e_QM_FQ_CHANNEL_POOL8,
+    e_QM_FQ_CHANNEL_POOL9,
+    e_QM_FQ_CHANNEL_POOL10,
+    e_QM_FQ_CHANNEL_POOL11,
+    e_QM_FQ_CHANNEL_POOL12,
+    e_QM_FQ_CHANNEL_POOL13,
+    e_QM_FQ_CHANNEL_POOL14,
+    e_QM_FQ_CHANNEL_POOL15,
+
+    e_QM_FQ_CHANNEL_FMAN0_SP0 = 0x800,           /**< Dedicated channels serviced by Direct Connect Portal 0:
+                                                      connected to FMan 0; assigned in incrementing order to
+                                                      each sub-portal (SP) in the portal */
+    e_QM_FQ_CHANNEL_FMAN0_SP1,
+    e_QM_FQ_CHANNEL_FMAN0_SP2,
+    e_QM_FQ_CHANNEL_FMAN0_SP3,
+    e_QM_FQ_CHANNEL_FMAN0_SP4,
+    e_QM_FQ_CHANNEL_FMAN0_SP5,
+    e_QM_FQ_CHANNEL_FMAN0_SP6,
+    e_QM_FQ_CHANNEL_FMAN0_SP7,
+    e_QM_FQ_CHANNEL_FMAN0_SP8,
+    e_QM_FQ_CHANNEL_FMAN0_SP9,
+    e_QM_FQ_CHANNEL_FMAN0_SP10,
+    e_QM_FQ_CHANNEL_FMAN0_SP11,
+    e_QM_FQ_CHANNEL_FMAN0_SP12,
+    e_QM_FQ_CHANNEL_FMAN0_SP13,
+    e_QM_FQ_CHANNEL_FMAN0_SP14,
+    e_QM_FQ_CHANNEL_FMAN0_SP15,
+
+    e_QM_FQ_CHANNEL_RMAN_SP0 = 0x820,            /**< Dedicated channels serviced by Direct Connect Portal 1: connected to RMan */
+    e_QM_FQ_CHANNEL_RMAN_SP1,
+
+    e_QM_FQ_CHANNEL_CAAM = 0x840                 /**< Dedicated channel serviced by Direct Connect Portal 2:
+                                                      connected to SEC */
+} e_QmFQChannel;
+
+/*****************************************************************************
+ BMan INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define BM_MAX_NUM_OF_POOLS         64          /**< Number of buffers pools */
+
+/*****************************************************************************
+ SEC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define SEC_NUM_OF_DECOS            3
+#define SEC_ALL_DECOS_MASK          0x00000003
+
+
+/*****************************************************************************
+ FM INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define INTG_MAX_NUM_OF_FM          2
+/* Ports defines */
+#define FM_MAX_NUM_OF_1G_MACS       6
+#define FM_MAX_NUM_OF_10G_MACS      2
+#define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS + FM_MAX_NUM_OF_10G_MACS)
+#define FM_MAX_NUM_OF_OH_PORTS      6
+
+#define FM_MAX_NUM_OF_1G_RX_PORTS   FM_MAX_NUM_OF_1G_MACS
+#define FM_MAX_NUM_OF_10G_RX_PORTS  FM_MAX_NUM_OF_10G_MACS
+#define FM_MAX_NUM_OF_RX_PORTS      (FM_MAX_NUM_OF_10G_RX_PORTS + FM_MAX_NUM_OF_1G_RX_PORTS)
+
+#define FM_MAX_NUM_OF_1G_TX_PORTS   FM_MAX_NUM_OF_1G_MACS
+#define FM_MAX_NUM_OF_10G_TX_PORTS  FM_MAX_NUM_OF_10G_MACS
+#define FM_MAX_NUM_OF_TX_PORTS      (FM_MAX_NUM_OF_10G_TX_PORTS + FM_MAX_NUM_OF_1G_TX_PORTS)
+
+#define FM_PORT_MAX_NUM_OF_EXT_POOLS            4           /**< Number of external BM pools per Rx port */
+#define FM_PORT_NUM_OF_CONGESTION_GRPS          256         /**< Total number of congestion groups in QM */
+#define FM_MAX_NUM_OF_SUB_PORTALS               16
+#define FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS   0
+
+#define FM_VSP_MAX_NUM_OF_ENTRIES               64
+#define FM_MAX_NUM_OF_PFC_PRIORITIES            8
+
+/* RAMs defines */
+#define FM_MURAM_SIZE                   (384 * KILOBYTE)
+#define FM_IRAM_SIZE(major, minor)      (64 * KILOBYTE)
+#define FM_NUM_OF_CTRL                  4
+
+/* PCD defines */
+#define FM_PCD_PLCR_NUM_ENTRIES         256                 /**< Total number of policer profiles */
+#define FM_PCD_KG_NUM_OF_SCHEMES        32                  /**< Total number of KG schemes */
+#define FM_PCD_MAX_NUM_OF_CLS_PLANS     256                 /**< Number of classification plan entries. */
+#define FM_PCD_PRS_SW_PATCHES_SIZE      0x00000460          /**< Number of bytes saved for patches */
+#define FM_PCD_SW_PRS_SIZE              0x00000800          /**< Total size of SW parser area */
+
+/* RTC defines */
+#define FM_RTC_NUM_OF_ALARMS            2                   /**< RTC number of alarms */
+#define FM_RTC_NUM_OF_PERIODIC_PULSES   3                   /**< RTC number of periodic pulses */
+#define FM_RTC_NUM_OF_EXT_TRIGGERS      2                   /**< RTC number of external triggers */
+
+/* QMI defines */
+#define QMI_MAX_NUM_OF_TNUMS            64
+#define QMI_DEF_TNUMS_THRESH            32
+/* FPM defines */
+#define FM_NUM_OF_FMAN_CTRL_EVENT_REGS  4
+
+/* DMA defines */
+#define DMA_THRESH_MAX_COMMQ            83
+#define DMA_THRESH_MAX_BUF              127
+
+/* BMI defines */
+#define BMI_MAX_NUM_OF_TASKS            128
+#define BMI_MAX_NUM_OF_DMAS             84
+
+#define BMI_MAX_FIFO_SIZE               (FM_MURAM_SIZE)
+#define PORT_MAX_WEIGHT                 16
+
+#define FM_CHECK_PORT_RESTRICTIONS(__validPorts, __newPortIndx)   TRUE
+
+/* Unique T4240 */
+#define FM_OP_OPEN_DMA_MIN_LIMIT
+#define FM_NO_RESTRICT_ON_ACCESS_RSRC
+#define FM_NO_OP_OBSERVED_POOLS
+#define FM_FRAME_END_PARAMS_FOR_OP
+#define FM_DEQ_PIPELINE_PARAMS_FOR_OP
+#define FM_QMI_NO_SINGLE_ECC_EXCEPTION
+
+#define FM_NO_GUARANTEED_RESET_VALUES
+
+/* FM errata */
+#define FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669
+#define FM_WRONG_RESET_VALUES_ERRATA_FMAN_A005127
+#define FM_RX_FIFO_CORRUPT_ERRATA_10GMAC_A006320
+#define FM_OP_NO_VSP_NO_RELEASE_ERRATA_FMAN_A006675
+#define FM_HEAVY_TRAFFIC_SEQUENCER_HANG_ERRATA_FMAN_A006981
+
+#define FM_BCB_ERRATA_BMI_SW001
+#define FM_LEN_CHECK_ERRATA_FMAN_SW002
+#define FM_AID_MODE_NO_TNUM_SW005 /* refer to pdm TKT068794 - only support of port_id on aid */
+#define FM_ERROR_VSP_NO_MATCH_SW006 /* refer to pdm TKT174304 - no match between errorQ and VSP */
+
+/*****************************************************************************
+ RMan INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define RM_MAX_NUM_OF_IB        4           /**< Number of inbound blocks */
+#define RM_NUM_OF_IBCU          8           /**< NUmber of classification units in an inbound block */
+
+/* RMan erratas */
+#define RM_ERRONEOUS_ACK_ERRATA_RMAN_A006756
+
+/*****************************************************************************
+ FM MACSEC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define NUM_OF_RX_SC                16
+#define NUM_OF_TX_SC                16
+
+#define NUM_OF_SA_PER_RX_SC         2
+#define NUM_OF_SA_PER_TX_SC         2
+
+#endif /* __DPAA_INTEGRATION_EXT_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3H/part_ext.h b/drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3H/part_ext.h
new file mode 100644
index 0000000..0d62dd1
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3H/part_ext.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+
+ @File          part_ext.h
+
+ @Description   Definitions for the part (integration) module.
+*//***************************************************************************/
+
+#ifndef __PART_EXT_H
+#define __PART_EXT_H
+
+#include "std_ext.h"
+#include "part_integration_ext.h"
+
+#if !(defined(P1023) || \
+      defined(P2041) || \
+      defined(P3041) || \
+      defined(P4080) || \
+      defined(P5020) || \
+      defined(P5040) || \
+      defined(B4860) || \
+      defined(T4240))
+#error "unable to proceed without chip-definition"
+#endif
+
+
+/**************************************************************************//*
+ @Description   Part data structure - must be contained in any integration
+                data structure.
+*//***************************************************************************/
+typedef struct t_Part
+{
+    uintptr_t   (* f_GetModuleBase)(t_Handle h_Part, e_ModuleId moduleId);
+                /**< Returns the address of the module's memory map base. */
+    e_ModuleId  (* f_GetModuleIdByBase)(t_Handle h_Part, uintptr_t baseAddress);
+                /**< Returns the module's ID according to its memory map base. */
+} t_Part;
+
+
+#endif /* __PART_EXT_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3H/part_integration_ext.h b/drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3H/part_integration_ext.h
new file mode 100644
index 0000000..3254c76
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3H/part_integration_ext.h
@@ -0,0 +1,304 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+
+ @File          part_integration_ext.h
+
+ @Description   T4240 external definitions and structures.
+*//***************************************************************************/
+#ifndef __PART_INTEGRATION_EXT_H
+#define __PART_INTEGRATION_EXT_H
+
+#include "std_ext.h"
+#include "ddr_std_ext.h"
+#include "enet_ext.h"
+#include "dpaa_integration_ext.h"
+
+
+/**************************************************************************//**
+ @Group         T4240_chip_id T4240 Application Programming Interface
+
+ @Description   T4240 Chip functions,definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+#define CORE_E6500
+
+#define INTG_MAX_NUM_OF_CORES   24
+
+
+/**************************************************************************//**
+ @Description   Module types.
+*//***************************************************************************/
+typedef enum e_ModuleId
+{
+    e_MODULE_ID_DUART_1 = 0,
+    e_MODULE_ID_DUART_2,
+    e_MODULE_ID_DUART_3,
+    e_MODULE_ID_DUART_4,
+    e_MODULE_ID_LAW,
+    e_MODULE_ID_IFC,
+    e_MODULE_ID_PAMU,
+    e_MODULE_ID_QM,                 /**< Queue manager module */
+    e_MODULE_ID_BM,                 /**< Buffer manager module */
+    e_MODULE_ID_QM_CE_PORTAL_0,
+    e_MODULE_ID_QM_CI_PORTAL_0,
+    e_MODULE_ID_QM_CE_PORTAL_1,
+    e_MODULE_ID_QM_CI_PORTAL_1,
+    e_MODULE_ID_QM_CE_PORTAL_2,
+    e_MODULE_ID_QM_CI_PORTAL_2,
+    e_MODULE_ID_QM_CE_PORTAL_3,
+    e_MODULE_ID_QM_CI_PORTAL_3,
+    e_MODULE_ID_QM_CE_PORTAL_4,
+    e_MODULE_ID_QM_CI_PORTAL_4,
+    e_MODULE_ID_QM_CE_PORTAL_5,
+    e_MODULE_ID_QM_CI_PORTAL_5,
+    e_MODULE_ID_QM_CE_PORTAL_6,
+    e_MODULE_ID_QM_CI_PORTAL_6,
+    e_MODULE_ID_QM_CE_PORTAL_7,
+    e_MODULE_ID_QM_CI_PORTAL_7,
+    e_MODULE_ID_QM_CE_PORTAL_8,
+    e_MODULE_ID_QM_CI_PORTAL_8,
+    e_MODULE_ID_QM_CE_PORTAL_9,
+    e_MODULE_ID_QM_CI_PORTAL_9,
+    e_MODULE_ID_BM_CE_PORTAL_0,
+    e_MODULE_ID_BM_CI_PORTAL_0,
+    e_MODULE_ID_BM_CE_PORTAL_1,
+    e_MODULE_ID_BM_CI_PORTAL_1,
+    e_MODULE_ID_BM_CE_PORTAL_2,
+    e_MODULE_ID_BM_CI_PORTAL_2,
+    e_MODULE_ID_BM_CE_PORTAL_3,
+    e_MODULE_ID_BM_CI_PORTAL_3,
+    e_MODULE_ID_BM_CE_PORTAL_4,
+    e_MODULE_ID_BM_CI_PORTAL_4,
+    e_MODULE_ID_BM_CE_PORTAL_5,
+    e_MODULE_ID_BM_CI_PORTAL_5,
+    e_MODULE_ID_BM_CE_PORTAL_6,
+    e_MODULE_ID_BM_CI_PORTAL_6,
+    e_MODULE_ID_BM_CE_PORTAL_7,
+    e_MODULE_ID_BM_CI_PORTAL_7,
+    e_MODULE_ID_BM_CE_PORTAL_8,
+    e_MODULE_ID_BM_CI_PORTAL_8,
+    e_MODULE_ID_BM_CE_PORTAL_9,
+    e_MODULE_ID_BM_CI_PORTAL_9,
+    e_MODULE_ID_FM,                 /**< Frame manager module */
+    e_MODULE_ID_FM_RTC,             /**< FM Real-Time-Clock */
+    e_MODULE_ID_FM_MURAM,           /**< FM Multi-User-RAM */
+    e_MODULE_ID_FM_BMI,             /**< FM BMI block */
+    e_MODULE_ID_FM_QMI,             /**< FM QMI block */
+    e_MODULE_ID_FM_PARSER,          /**< FM parser block */
+    e_MODULE_ID_FM_PORT_HO1,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO2,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO3,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO4,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO5,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO6,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO7,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_1GRx1,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GRx2,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GRx3,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GRx4,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GRx5,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GRx6,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_10GRx1,     /**< FM Rx 10G MAC port block */
+    e_MODULE_ID_FM_PORT_10GRx2,     /**< FM Rx 10G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx1,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx2,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx3,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx4,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx5,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx6,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_10GTx1,     /**< FM Tx 10G MAC port block */
+    e_MODULE_ID_FM_PORT_10GTx2,     /**< FM Tx 10G MAC port block */
+    e_MODULE_ID_FM_PLCR,            /**< FM Policer */
+    e_MODULE_ID_FM_KG,              /**< FM Keygen */
+    e_MODULE_ID_FM_DMA,             /**< FM DMA */
+    e_MODULE_ID_FM_FPM,             /**< FM FPM */
+    e_MODULE_ID_FM_IRAM,            /**< FM Instruction-RAM */
+    e_MODULE_ID_FM_1GMDIO,          /**< FM 1G MDIO MAC */
+    e_MODULE_ID_FM_10GMDIO,         /**< FM 10G MDIO */
+    e_MODULE_ID_FM_PRS_IRAM,        /**< FM SW-parser Instruction-RAM */
+    e_MODULE_ID_FM_1GMAC1,          /**< FM 1G MAC #1 */
+    e_MODULE_ID_FM_1GMAC2,          /**< FM 1G MAC #2 */
+    e_MODULE_ID_FM_1GMAC3,          /**< FM 1G MAC #3 */
+    e_MODULE_ID_FM_1GMAC4,          /**< FM 1G MAC #4 */
+    e_MODULE_ID_FM_1GMAC5,          /**< FM 1G MAC #5 */
+    e_MODULE_ID_FM_1GMAC6,          /**< FM 1G MAC #6 */
+    e_MODULE_ID_FM_10GMAC1,         /**< FM 10G MAC */
+    e_MODULE_ID_FM_10GMAC2,         /**< FM 10G MAC */
+
+    e_MODULE_ID_SEC_GEN,            /**< SEC 4.0 General registers      */
+    e_MODULE_ID_SEC_QI,             /**< SEC 4.0 QI registers           */
+    e_MODULE_ID_SEC_JQ0,            /**< SEC 4.0 JQ-0 registers         */
+    e_MODULE_ID_SEC_JQ1,            /**< SEC 4.0 JQ-1 registers         */
+    e_MODULE_ID_SEC_JQ2,            /**< SEC 4.0 JQ-2 registers         */
+    e_MODULE_ID_SEC_JQ3,            /**< SEC 4.0 JQ-3 registers         */
+    e_MODULE_ID_SEC_RTIC,           /**< SEC 4.0 RTIC registers         */
+    e_MODULE_ID_SEC_DECO0_CCB0,     /**< SEC 4.0 DECO-0/CCB-0 registers */
+    e_MODULE_ID_SEC_DECO1_CCB1,     /**< SEC 4.0 DECO-1/CCB-1 registers */
+    e_MODULE_ID_SEC_DECO2_CCB2,     /**< SEC 4.0 DECO-2/CCB-2 registers */
+    e_MODULE_ID_SEC_DECO3_CCB3,     /**< SEC 4.0 DECO-3/CCB-3 registers */
+    e_MODULE_ID_SEC_DECO4_CCB4,     /**< SEC 4.0 DECO-4/CCB-4 registers */
+
+    e_MODULE_ID_PIC,                /**< PIC */
+    e_MODULE_ID_GPIO,               /**< GPIO */
+    e_MODULE_ID_SERDES,             /**< SERDES */
+    e_MODULE_ID_CPC_1,              /**< CoreNet-Platform-Cache 1 */
+    e_MODULE_ID_CPC_2,              /**< CoreNet-Platform-Cache 2 */
+
+    e_MODULE_ID_SRIO_PORTS,         /**< RapidIO controller */
+
+    e_MODULE_ID_DUMMY_LAST
+} e_ModuleId;
+
+#define NUM_OF_MODULES  e_MODULE_ID_DUMMY_LAST
+
+#if 0 /* using unified values */
+/*****************************************************************************
+ INTEGRATION-SPECIFIC MODULE CODES
+******************************************************************************/
+#define MODULE_UNKNOWN          0x00000000
+#define MODULE_MEM              0x00010000
+#define MODULE_MM               0x00020000
+#define MODULE_CORE             0x00030000
+#define MODULE_T4240            0x00040000
+#define MODULE_T4240_PLATFORM   0x00050000
+#define MODULE_PM               0x00060000
+#define MODULE_MMU              0x00070000
+#define MODULE_PIC              0x00080000
+#define MODULE_CPC              0x00090000
+#define MODULE_DUART            0x000a0000
+#define MODULE_SERDES           0x000b0000
+#define MODULE_PIO              0x000c0000
+#define MODULE_QM               0x000d0000
+#define MODULE_BM               0x000e0000
+#define MODULE_SEC              0x000f0000
+#define MODULE_LAW              0x00100000
+#define MODULE_LBC              0x00110000
+#define MODULE_PAMU             0x00120000
+#define MODULE_FM               0x00130000
+#define MODULE_FM_MURAM         0x00140000
+#define MODULE_FM_PCD           0x00150000
+#define MODULE_FM_RTC           0x00160000
+#define MODULE_FM_MAC           0x00170000
+#define MODULE_FM_PORT          0x00180000
+#define MODULE_FM_SP            0x00190000
+#define MODULE_DPA_PORT         0x001a0000
+#define MODULE_MII              0x001b0000
+#define MODULE_I2C              0x001c0000
+#define MODULE_DMA              0x001d0000
+#define MODULE_DDR              0x001e0000
+#define MODULE_ESPI             0x001f0000
+#define MODULE_DPAA_IPSEC       0x00200000
+#endif /* using unified values */
+
+/*****************************************************************************
+ PAMU INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define PAMU_NUM_OF_PARTITIONS  4
+
+/*****************************************************************************
+ LAW INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define LAW_NUM_OF_WINDOWS      32
+#define LAW_MIN_WINDOW_SIZE     0x0000000000001000LL    /**< 4 Kbytes */
+#define LAW_MAX_WINDOW_SIZE     0x0000010000000000LL    /**< 1 Tbytes for 40-bit address space */
+
+
+/*****************************************************************************
+ LBC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+/**************************************************************************//**
+ @Group         lbc_exception_grp LBC Exception Unit
+
+ @Description   LBC Exception unit API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Anchor        lbc_exbm
+
+ @Collection    LBC Errors Bit Mask
+
+                These errors are reported through the exceptions callback..
+                The values can be or'ed in any combination in the errors mask
+                parameter of the errors report structure.
+
+                These errors can also be passed as a bit-mask to
+                LBC_EnableErrorChecking() or LBC_DisableErrorChecking(),
+                for enabling or disabling error checking.
+ @{
+*//***************************************************************************/
+#define LBC_ERR_BUS_MONITOR     0x80000000  /**< Bus monitor error */
+#define LBC_ERR_PARITY_ECC      0x20000000  /**< Parity error for GPCM/UPM */
+#define LBC_ERR_WRITE_PROTECT   0x04000000  /**< Write protection error */
+#define LBC_ERR_CHIP_SELECT     0x00080000  /**< Unrecognized chip select */
+
+#define LBC_ERR_ALL             (LBC_ERR_BUS_MONITOR | LBC_ERR_PARITY_ECC | \
+                                 LBC_ERR_WRITE_PROTECT | LBC_ERR_CHIP_SELECT)
+                                            /**< All possible errors */
+/* @} */
+/** @} */ /* end of lbc_exception_grp group */
+
+#define LBC_INCORRECT_ERROR_REPORT_ERRATA
+
+#define LBC_NUM_OF_BANKS            8
+#define LBC_MAX_CS_SIZE             0x0000000100000000LL  /* Up to 4G memory block size */
+#define LBC_PARITY_SUPPORT
+#define LBC_ADDRESS_HOLD_TIME_CTRL
+#define LBC_HIGH_CLK_DIVIDERS
+#define LBC_FCM_AVAILABLE
+
+/*****************************************************************************
+ GPIO INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define GPIO_PORT_OFFSET_0x1000
+
+#define GPIO_NUM_OF_PORTS   3   /**< Number of ports in GPIO module;
+                                     Each port contains up to 32 I/O pins. */
+
+#define GPIO_VALID_PIN_MASKS   \
+    { /* Port A */ 0xFFFFFFFF, \
+      /* Port B */ 0xFFFFFFFF, \
+      /* Port C */ 0xFFFFFFFF }
+
+#define GPIO_VALID_INTR_MASKS  \
+    { /* Port A */ 0xFFFFFFFF, \
+      /* Port B */ 0xFFFFFFFF, \
+      /* Port C */ 0xFFFFFFFF }
+
+
+
+#endif /* __PART_INTEGRATION_EXT_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3L/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3L/dpaa_integration_ext.h
new file mode 100644
index 0000000..be3fcb1
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3L/dpaa_integration_ext.h
@@ -0,0 +1,290 @@
+/*
+ * Copyright 2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+
+ @File          dpaa_integration_ext.h
+
+ @Description   T4240 FM external definitions and structures.
+*//***************************************************************************/
+#ifndef __DPAA_INTEGRATION_EXT_H
+#define __DPAA_INTEGRATION_EXT_H
+
+#include "std_ext.h"
+
+
+#define DPAA_VERSION    11
+
+/**************************************************************************//**
+ @Description   DPAA SW Portals Enumeration.
+*//***************************************************************************/
+typedef enum
+{
+    e_DPAA_SWPORTAL0 = 0,
+    e_DPAA_SWPORTAL1,
+    e_DPAA_SWPORTAL2,
+    e_DPAA_SWPORTAL3,
+    e_DPAA_SWPORTAL4,
+    e_DPAA_SWPORTAL5,
+    e_DPAA_SWPORTAL6,
+    e_DPAA_SWPORTAL7,
+    e_DPAA_SWPORTAL8,
+    e_DPAA_SWPORTAL9,
+    e_DPAA_SWPORTAL10,
+    e_DPAA_SWPORTAL11,
+    e_DPAA_SWPORTAL12,
+    e_DPAA_SWPORTAL13,
+    e_DPAA_SWPORTAL14,
+    e_DPAA_SWPORTAL15,
+    e_DPAA_SWPORTAL16,
+    e_DPAA_SWPORTAL17,
+    e_DPAA_SWPORTAL18,
+    e_DPAA_SWPORTAL19,
+    e_DPAA_SWPORTAL20,
+    e_DPAA_SWPORTAL21,
+    e_DPAA_SWPORTAL22,
+    e_DPAA_SWPORTAL23,
+    e_DPAA_SWPORTAL24,
+    e_DPAA_SWPORTAL_DUMMY_LAST
+} e_DpaaSwPortal;
+
+/**************************************************************************//**
+ @Description   DPAA Direct Connect Portals Enumeration.
+*//***************************************************************************/
+typedef enum
+{
+    e_DPAA_DCPORTAL0 = 0,
+    e_DPAA_DCPORTAL1,
+    e_DPAA_DCPORTAL2,
+    e_DPAA_DCPORTAL_DUMMY_LAST
+} e_DpaaDcPortal;
+
+#define DPAA_MAX_NUM_OF_SW_PORTALS      e_DPAA_SWPORTAL_DUMMY_LAST
+#define DPAA_MAX_NUM_OF_DC_PORTALS      e_DPAA_DCPORTAL_DUMMY_LAST
+
+/*****************************************************************************
+ QMan INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define QM_MAX_NUM_OF_POOL_CHANNELS     15      /**< Total number of channels, dedicated and pool */
+#define QM_MAX_NUM_OF_WQ                8       /**< Number of work queues per channel */
+#define QM_MAX_NUM_OF_CGS               256     /**< Congestion groups number */
+#define QM_MAX_NUM_OF_FQIDS             (16 * MEGABYTE)
+                                                /**< FQIDs range - 24 bits */
+
+/**************************************************************************//**
+ @Description   Work Queue Channel assignments in QMan.
+*//***************************************************************************/
+typedef enum
+{
+    e_QM_FQ_CHANNEL_SWPORTAL0 = 0x0,              /**< Dedicated channels serviced by software portals 0 to 24 */
+    e_QM_FQ_CHANNEL_SWPORTAL1,
+    e_QM_FQ_CHANNEL_SWPORTAL2,
+    e_QM_FQ_CHANNEL_SWPORTAL3,
+    e_QM_FQ_CHANNEL_SWPORTAL4,
+    e_QM_FQ_CHANNEL_SWPORTAL5,
+    e_QM_FQ_CHANNEL_SWPORTAL6,
+    e_QM_FQ_CHANNEL_SWPORTAL7,
+    e_QM_FQ_CHANNEL_SWPORTAL8,
+    e_QM_FQ_CHANNEL_SWPORTAL9,
+    e_QM_FQ_CHANNEL_SWPORTAL10,
+    e_QM_FQ_CHANNEL_SWPORTAL11,
+    e_QM_FQ_CHANNEL_SWPORTAL12,
+    e_QM_FQ_CHANNEL_SWPORTAL13,
+    e_QM_FQ_CHANNEL_SWPORTAL14,
+    e_QM_FQ_CHANNEL_SWPORTAL15,
+    e_QM_FQ_CHANNEL_SWPORTAL16,
+    e_QM_FQ_CHANNEL_SWPORTAL17,
+    e_QM_FQ_CHANNEL_SWPORTAL18,
+    e_QM_FQ_CHANNEL_SWPORTAL19,
+    e_QM_FQ_CHANNEL_SWPORTAL20,
+    e_QM_FQ_CHANNEL_SWPORTAL21,
+    e_QM_FQ_CHANNEL_SWPORTAL22,
+    e_QM_FQ_CHANNEL_SWPORTAL23,
+    e_QM_FQ_CHANNEL_SWPORTAL24,
+
+    e_QM_FQ_CHANNEL_POOL1 = 0x401,               /**< Pool channels that can be serviced by any of the software portals */
+    e_QM_FQ_CHANNEL_POOL2,
+    e_QM_FQ_CHANNEL_POOL3,
+    e_QM_FQ_CHANNEL_POOL4,
+    e_QM_FQ_CHANNEL_POOL5,
+    e_QM_FQ_CHANNEL_POOL6,
+    e_QM_FQ_CHANNEL_POOL7,
+    e_QM_FQ_CHANNEL_POOL8,
+    e_QM_FQ_CHANNEL_POOL9,
+    e_QM_FQ_CHANNEL_POOL10,
+    e_QM_FQ_CHANNEL_POOL11,
+    e_QM_FQ_CHANNEL_POOL12,
+    e_QM_FQ_CHANNEL_POOL13,
+    e_QM_FQ_CHANNEL_POOL14,
+    e_QM_FQ_CHANNEL_POOL15,
+
+    e_QM_FQ_CHANNEL_FMAN0_SP0 = 0x800,           /**< Dedicated channels serviced by Direct Connect Portal 0:
+                                                      connected to FMan 0; assigned in incrementing order to
+                                                      each sub-portal (SP) in the portal */
+    e_QM_FQ_CHANNEL_FMAN0_SP1,
+    e_QM_FQ_CHANNEL_FMAN0_SP2,
+    e_QM_FQ_CHANNEL_FMAN0_SP3,
+    e_QM_FQ_CHANNEL_FMAN0_SP4,
+    e_QM_FQ_CHANNEL_FMAN0_SP5,
+    e_QM_FQ_CHANNEL_FMAN0_SP6,
+    e_QM_FQ_CHANNEL_FMAN0_SP7,
+    e_QM_FQ_CHANNEL_FMAN0_SP8,
+    e_QM_FQ_CHANNEL_FMAN0_SP9,
+    e_QM_FQ_CHANNEL_FMAN0_SP10,
+    e_QM_FQ_CHANNEL_FMAN0_SP11,
+    e_QM_FQ_CHANNEL_FMAN0_SP12,
+    e_QM_FQ_CHANNEL_FMAN0_SP13,
+    e_QM_FQ_CHANNEL_FMAN0_SP14,
+    e_QM_FQ_CHANNEL_FMAN0_SP15,
+
+    e_QM_FQ_CHANNEL_RMAN_SP0 = 0x820,            /**< Dedicated channels serviced by Direct Connect Portal 1: connected to RMan */
+    e_QM_FQ_CHANNEL_RMAN_SP1,
+
+    e_QM_FQ_CHANNEL_CAAM = 0x840                 /**< Dedicated channel serviced by Direct Connect Portal 2:
+                                                      connected to SEC */
+} e_QmFQChannel;
+
+/*****************************************************************************
+ BMan INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define BM_MAX_NUM_OF_POOLS         64          /**< Number of buffers pools */
+
+/*****************************************************************************
+ SEC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define SEC_NUM_OF_DECOS            3
+#define SEC_ALL_DECOS_MASK          0x00000003
+
+
+/*****************************************************************************
+ FM INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define INTG_MAX_NUM_OF_FM	    1
+/* Ports defines */
+#define FM_MAX_NUM_OF_1G_MACS	    5
+#define FM_MAX_NUM_OF_10G_MACS	    1
+#define FM_MAX_NUM_OF_MACS	    (FM_MAX_NUM_OF_1G_MACS + FM_MAX_NUM_OF_10G_MACS)
+#define FM_MAX_NUM_OF_OH_PORTS	    4
+
+#define FM_MAX_NUM_OF_1G_RX_PORTS   FM_MAX_NUM_OF_1G_MACS
+#define FM_MAX_NUM_OF_10G_RX_PORTS  FM_MAX_NUM_OF_10G_MACS
+#define FM_MAX_NUM_OF_RX_PORTS      (FM_MAX_NUM_OF_10G_RX_PORTS + FM_MAX_NUM_OF_1G_RX_PORTS)
+
+#define FM_MAX_NUM_OF_1G_TX_PORTS   FM_MAX_NUM_OF_1G_MACS
+#define FM_MAX_NUM_OF_10G_TX_PORTS  FM_MAX_NUM_OF_10G_MACS
+#define FM_MAX_NUM_OF_TX_PORTS      (FM_MAX_NUM_OF_10G_TX_PORTS + FM_MAX_NUM_OF_1G_TX_PORTS)
+
+#define FM_PORT_MAX_NUM_OF_EXT_POOLS            4           /**< Number of external BM pools per Rx port */
+#define FM_PORT_NUM_OF_CONGESTION_GRPS          256         /**< Total number of congestion groups in QM */
+#define FM_MAX_NUM_OF_SUB_PORTALS               16
+#define FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS   0
+
+#define FM_VSP_MAX_NUM_OF_ENTRIES               32
+#define FM_MAX_NUM_OF_PFC_PRIORITIES            8
+
+/* RAMs defines */
+#define FM_MURAM_SIZE                   (192 * KILOBYTE)
+#define FM_IRAM_SIZE(major, minor)      \
+    (((major == 6) && ((minor == 4) )) ? (64 * KILOBYTE) : (32 * KILOBYTE))
+#define FM_NUM_OF_CTRL                  2
+
+/* PCD defines */
+#define FM_PCD_PLCR_NUM_ENTRIES         256                 /**< Total number of policer profiles */
+#define FM_PCD_KG_NUM_OF_SCHEMES        32                  /**< Total number of KG schemes */
+#define FM_PCD_MAX_NUM_OF_CLS_PLANS     256                 /**< Number of classification plan entries. */
+#define FM_PCD_PRS_SW_PATCHES_SIZE      0x00000460          /**< Number of bytes saved for patches */
+#define FM_PCD_SW_PRS_SIZE              0x00000800          /**< Total size of SW parser area */
+
+/* RTC defines */
+#define FM_RTC_NUM_OF_ALARMS            2                   /**< RTC number of alarms */
+#define FM_RTC_NUM_OF_PERIODIC_PULSES   3                   /**< RTC number of periodic pulses */
+#define FM_RTC_NUM_OF_EXT_TRIGGERS      2                   /**< RTC number of external triggers */
+
+/* QMI defines */
+#define QMI_MAX_NUM_OF_TNUMS            64
+#define QMI_DEF_TNUMS_THRESH            32
+/* FPM defines */
+#define FM_NUM_OF_FMAN_CTRL_EVENT_REGS  4
+
+/* DMA defines */
+#define DMA_THRESH_MAX_COMMQ            83
+#define DMA_THRESH_MAX_BUF              127
+
+/* BMI defines */
+#define BMI_MAX_NUM_OF_TASKS            64
+#define BMI_MAX_NUM_OF_DMAS             32
+
+#define BMI_MAX_FIFO_SIZE               (FM_MURAM_SIZE)
+#define PORT_MAX_WEIGHT                 16
+
+#define FM_CHECK_PORT_RESTRICTIONS(__validPorts, __newPortIndx)   TRUE
+
+/* Unique T4240 */
+#define FM_OP_OPEN_DMA_MIN_LIMIT
+#define FM_NO_RESTRICT_ON_ACCESS_RSRC
+#define FM_NO_OP_OBSERVED_POOLS
+#define FM_FRAME_END_PARAMS_FOR_OP
+#define FM_DEQ_PIPELINE_PARAMS_FOR_OP
+#define FM_QMI_NO_SINGLE_ECC_EXCEPTION
+
+#define FM_NO_GUARANTEED_RESET_VALUES
+
+/* FM errata */
+#define FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669
+#define FM_RX_FIFO_CORRUPT_ERRATA_10GMAC_A006320
+#define FM_OP_NO_VSP_NO_RELEASE_ERRATA_FMAN_A006675
+#define FM_HEAVY_TRAFFIC_SEQUENCER_HANG_ERRATA_FMAN_A006981
+
+#define FM_BCB_ERRATA_BMI_SW001
+#define FM_LEN_CHECK_ERRATA_FMAN_SW002
+#define FM_AID_MODE_NO_TNUM_SW005 /* refer to pdm TKT068794 - only support of port_id on aid */
+#define FM_ERROR_VSP_NO_MATCH_SW006 /* refer to pdm TKT174304 - no match between errorQ and VSP */
+
+/*****************************************************************************
+ RMan INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define RM_MAX_NUM_OF_IB        4           /**< Number of inbound blocks */
+#define RM_NUM_OF_IBCU          8           /**< NUmber of classification units in an inbound block */
+
+/* RMan erratas */
+#define RM_ERRONEOUS_ACK_ERRATA_RMAN_A006756
+
+/*****************************************************************************
+ FM MACSEC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define NUM_OF_RX_SC                16
+#define NUM_OF_TX_SC                16
+
+#define NUM_OF_SA_PER_RX_SC         2
+#define NUM_OF_SA_PER_TX_SC         2
+
+#endif /* __DPAA_INTEGRATION_EXT_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3L/part_ext.h b/drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3L/part_ext.h
new file mode 100644
index 0000000..ba9732e
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3L/part_ext.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+
+ @File          part_ext.h
+
+ @Description   Definitions for the part (integration) module.
+*//***************************************************************************/
+
+#ifndef __PART_EXT_H
+#define __PART_EXT_H
+
+#include "std_ext.h"
+#include "part_integration_ext.h"
+
+/**************************************************************************//*
+ @Description   Part data structure - must be contained in any integration
+                data structure.
+*//***************************************************************************/
+typedef struct t_Part
+{
+    uintptr_t   (* f_GetModuleBase)(t_Handle h_Part, e_ModuleId moduleId);
+                /**< Returns the address of the module's memory map base. */
+    e_ModuleId  (* f_GetModuleIdByBase)(t_Handle h_Part, uintptr_t baseAddress);
+                /**< Returns the module's ID according to its memory map base. */
+} t_Part;
+
+
+#endif /* __PART_EXT_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3L/part_integration_ext.h b/drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3L/part_integration_ext.h
new file mode 100644
index 0000000..3254c76
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/inc/integrations/FMANV3L/part_integration_ext.h
@@ -0,0 +1,304 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+
+ @File          part_integration_ext.h
+
+ @Description   T4240 external definitions and structures.
+*//***************************************************************************/
+#ifndef __PART_INTEGRATION_EXT_H
+#define __PART_INTEGRATION_EXT_H
+
+#include "std_ext.h"
+#include "ddr_std_ext.h"
+#include "enet_ext.h"
+#include "dpaa_integration_ext.h"
+
+
+/**************************************************************************//**
+ @Group         T4240_chip_id T4240 Application Programming Interface
+
+ @Description   T4240 Chip functions,definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+#define CORE_E6500
+
+#define INTG_MAX_NUM_OF_CORES   24
+
+
+/**************************************************************************//**
+ @Description   Module types.
+*//***************************************************************************/
+typedef enum e_ModuleId
+{
+    e_MODULE_ID_DUART_1 = 0,
+    e_MODULE_ID_DUART_2,
+    e_MODULE_ID_DUART_3,
+    e_MODULE_ID_DUART_4,
+    e_MODULE_ID_LAW,
+    e_MODULE_ID_IFC,
+    e_MODULE_ID_PAMU,
+    e_MODULE_ID_QM,                 /**< Queue manager module */
+    e_MODULE_ID_BM,                 /**< Buffer manager module */
+    e_MODULE_ID_QM_CE_PORTAL_0,
+    e_MODULE_ID_QM_CI_PORTAL_0,
+    e_MODULE_ID_QM_CE_PORTAL_1,
+    e_MODULE_ID_QM_CI_PORTAL_1,
+    e_MODULE_ID_QM_CE_PORTAL_2,
+    e_MODULE_ID_QM_CI_PORTAL_2,
+    e_MODULE_ID_QM_CE_PORTAL_3,
+    e_MODULE_ID_QM_CI_PORTAL_3,
+    e_MODULE_ID_QM_CE_PORTAL_4,
+    e_MODULE_ID_QM_CI_PORTAL_4,
+    e_MODULE_ID_QM_CE_PORTAL_5,
+    e_MODULE_ID_QM_CI_PORTAL_5,
+    e_MODULE_ID_QM_CE_PORTAL_6,
+    e_MODULE_ID_QM_CI_PORTAL_6,
+    e_MODULE_ID_QM_CE_PORTAL_7,
+    e_MODULE_ID_QM_CI_PORTAL_7,
+    e_MODULE_ID_QM_CE_PORTAL_8,
+    e_MODULE_ID_QM_CI_PORTAL_8,
+    e_MODULE_ID_QM_CE_PORTAL_9,
+    e_MODULE_ID_QM_CI_PORTAL_9,
+    e_MODULE_ID_BM_CE_PORTAL_0,
+    e_MODULE_ID_BM_CI_PORTAL_0,
+    e_MODULE_ID_BM_CE_PORTAL_1,
+    e_MODULE_ID_BM_CI_PORTAL_1,
+    e_MODULE_ID_BM_CE_PORTAL_2,
+    e_MODULE_ID_BM_CI_PORTAL_2,
+    e_MODULE_ID_BM_CE_PORTAL_3,
+    e_MODULE_ID_BM_CI_PORTAL_3,
+    e_MODULE_ID_BM_CE_PORTAL_4,
+    e_MODULE_ID_BM_CI_PORTAL_4,
+    e_MODULE_ID_BM_CE_PORTAL_5,
+    e_MODULE_ID_BM_CI_PORTAL_5,
+    e_MODULE_ID_BM_CE_PORTAL_6,
+    e_MODULE_ID_BM_CI_PORTAL_6,
+    e_MODULE_ID_BM_CE_PORTAL_7,
+    e_MODULE_ID_BM_CI_PORTAL_7,
+    e_MODULE_ID_BM_CE_PORTAL_8,
+    e_MODULE_ID_BM_CI_PORTAL_8,
+    e_MODULE_ID_BM_CE_PORTAL_9,
+    e_MODULE_ID_BM_CI_PORTAL_9,
+    e_MODULE_ID_FM,                 /**< Frame manager module */
+    e_MODULE_ID_FM_RTC,             /**< FM Real-Time-Clock */
+    e_MODULE_ID_FM_MURAM,           /**< FM Multi-User-RAM */
+    e_MODULE_ID_FM_BMI,             /**< FM BMI block */
+    e_MODULE_ID_FM_QMI,             /**< FM QMI block */
+    e_MODULE_ID_FM_PARSER,          /**< FM parser block */
+    e_MODULE_ID_FM_PORT_HO1,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO2,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO3,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO4,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO5,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO6,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_HO7,        /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM_PORT_1GRx1,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GRx2,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GRx3,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GRx4,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GRx5,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GRx6,      /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_10GRx1,     /**< FM Rx 10G MAC port block */
+    e_MODULE_ID_FM_PORT_10GRx2,     /**< FM Rx 10G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx1,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx2,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx3,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx4,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx5,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_1GTx6,      /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM_PORT_10GTx1,     /**< FM Tx 10G MAC port block */
+    e_MODULE_ID_FM_PORT_10GTx2,     /**< FM Tx 10G MAC port block */
+    e_MODULE_ID_FM_PLCR,            /**< FM Policer */
+    e_MODULE_ID_FM_KG,              /**< FM Keygen */
+    e_MODULE_ID_FM_DMA,             /**< FM DMA */
+    e_MODULE_ID_FM_FPM,             /**< FM FPM */
+    e_MODULE_ID_FM_IRAM,            /**< FM Instruction-RAM */
+    e_MODULE_ID_FM_1GMDIO,          /**< FM 1G MDIO MAC */
+    e_MODULE_ID_FM_10GMDIO,         /**< FM 10G MDIO */
+    e_MODULE_ID_FM_PRS_IRAM,        /**< FM SW-parser Instruction-RAM */
+    e_MODULE_ID_FM_1GMAC1,          /**< FM 1G MAC #1 */
+    e_MODULE_ID_FM_1GMAC2,          /**< FM 1G MAC #2 */
+    e_MODULE_ID_FM_1GMAC3,          /**< FM 1G MAC #3 */
+    e_MODULE_ID_FM_1GMAC4,          /**< FM 1G MAC #4 */
+    e_MODULE_ID_FM_1GMAC5,          /**< FM 1G MAC #5 */
+    e_MODULE_ID_FM_1GMAC6,          /**< FM 1G MAC #6 */
+    e_MODULE_ID_FM_10GMAC1,         /**< FM 10G MAC */
+    e_MODULE_ID_FM_10GMAC2,         /**< FM 10G MAC */
+
+    e_MODULE_ID_SEC_GEN,            /**< SEC 4.0 General registers      */
+    e_MODULE_ID_SEC_QI,             /**< SEC 4.0 QI registers           */
+    e_MODULE_ID_SEC_JQ0,            /**< SEC 4.0 JQ-0 registers         */
+    e_MODULE_ID_SEC_JQ1,            /**< SEC 4.0 JQ-1 registers         */
+    e_MODULE_ID_SEC_JQ2,            /**< SEC 4.0 JQ-2 registers         */
+    e_MODULE_ID_SEC_JQ3,            /**< SEC 4.0 JQ-3 registers         */
+    e_MODULE_ID_SEC_RTIC,           /**< SEC 4.0 RTIC registers         */
+    e_MODULE_ID_SEC_DECO0_CCB0,     /**< SEC 4.0 DECO-0/CCB-0 registers */
+    e_MODULE_ID_SEC_DECO1_CCB1,     /**< SEC 4.0 DECO-1/CCB-1 registers */
+    e_MODULE_ID_SEC_DECO2_CCB2,     /**< SEC 4.0 DECO-2/CCB-2 registers */
+    e_MODULE_ID_SEC_DECO3_CCB3,     /**< SEC 4.0 DECO-3/CCB-3 registers */
+    e_MODULE_ID_SEC_DECO4_CCB4,     /**< SEC 4.0 DECO-4/CCB-4 registers */
+
+    e_MODULE_ID_PIC,                /**< PIC */
+    e_MODULE_ID_GPIO,               /**< GPIO */
+    e_MODULE_ID_SERDES,             /**< SERDES */
+    e_MODULE_ID_CPC_1,              /**< CoreNet-Platform-Cache 1 */
+    e_MODULE_ID_CPC_2,              /**< CoreNet-Platform-Cache 2 */
+
+    e_MODULE_ID_SRIO_PORTS,         /**< RapidIO controller */
+
+    e_MODULE_ID_DUMMY_LAST
+} e_ModuleId;
+
+#define NUM_OF_MODULES  e_MODULE_ID_DUMMY_LAST
+
+#if 0 /* using unified values */
+/*****************************************************************************
+ INTEGRATION-SPECIFIC MODULE CODES
+******************************************************************************/
+#define MODULE_UNKNOWN          0x00000000
+#define MODULE_MEM              0x00010000
+#define MODULE_MM               0x00020000
+#define MODULE_CORE             0x00030000
+#define MODULE_T4240            0x00040000
+#define MODULE_T4240_PLATFORM   0x00050000
+#define MODULE_PM               0x00060000
+#define MODULE_MMU              0x00070000
+#define MODULE_PIC              0x00080000
+#define MODULE_CPC              0x00090000
+#define MODULE_DUART            0x000a0000
+#define MODULE_SERDES           0x000b0000
+#define MODULE_PIO              0x000c0000
+#define MODULE_QM               0x000d0000
+#define MODULE_BM               0x000e0000
+#define MODULE_SEC              0x000f0000
+#define MODULE_LAW              0x00100000
+#define MODULE_LBC              0x00110000
+#define MODULE_PAMU             0x00120000
+#define MODULE_FM               0x00130000
+#define MODULE_FM_MURAM         0x00140000
+#define MODULE_FM_PCD           0x00150000
+#define MODULE_FM_RTC           0x00160000
+#define MODULE_FM_MAC           0x00170000
+#define MODULE_FM_PORT          0x00180000
+#define MODULE_FM_SP            0x00190000
+#define MODULE_DPA_PORT         0x001a0000
+#define MODULE_MII              0x001b0000
+#define MODULE_I2C              0x001c0000
+#define MODULE_DMA              0x001d0000
+#define MODULE_DDR              0x001e0000
+#define MODULE_ESPI             0x001f0000
+#define MODULE_DPAA_IPSEC       0x00200000
+#endif /* using unified values */
+
+/*****************************************************************************
+ PAMU INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define PAMU_NUM_OF_PARTITIONS  4
+
+/*****************************************************************************
+ LAW INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define LAW_NUM_OF_WINDOWS      32
+#define LAW_MIN_WINDOW_SIZE     0x0000000000001000LL    /**< 4 Kbytes */
+#define LAW_MAX_WINDOW_SIZE     0x0000010000000000LL    /**< 1 Tbytes for 40-bit address space */
+
+
+/*****************************************************************************
+ LBC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+/**************************************************************************//**
+ @Group         lbc_exception_grp LBC Exception Unit
+
+ @Description   LBC Exception unit API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Anchor        lbc_exbm
+
+ @Collection    LBC Errors Bit Mask
+
+                These errors are reported through the exceptions callback..
+                The values can be or'ed in any combination in the errors mask
+                parameter of the errors report structure.
+
+                These errors can also be passed as a bit-mask to
+                LBC_EnableErrorChecking() or LBC_DisableErrorChecking(),
+                for enabling or disabling error checking.
+ @{
+*//***************************************************************************/
+#define LBC_ERR_BUS_MONITOR     0x80000000  /**< Bus monitor error */
+#define LBC_ERR_PARITY_ECC      0x20000000  /**< Parity error for GPCM/UPM */
+#define LBC_ERR_WRITE_PROTECT   0x04000000  /**< Write protection error */
+#define LBC_ERR_CHIP_SELECT     0x00080000  /**< Unrecognized chip select */
+
+#define LBC_ERR_ALL             (LBC_ERR_BUS_MONITOR | LBC_ERR_PARITY_ECC | \
+                                 LBC_ERR_WRITE_PROTECT | LBC_ERR_CHIP_SELECT)
+                                            /**< All possible errors */
+/* @} */
+/** @} */ /* end of lbc_exception_grp group */
+
+#define LBC_INCORRECT_ERROR_REPORT_ERRATA
+
+#define LBC_NUM_OF_BANKS            8
+#define LBC_MAX_CS_SIZE             0x0000000100000000LL  /* Up to 4G memory block size */
+#define LBC_PARITY_SUPPORT
+#define LBC_ADDRESS_HOLD_TIME_CTRL
+#define LBC_HIGH_CLK_DIVIDERS
+#define LBC_FCM_AVAILABLE
+
+/*****************************************************************************
+ GPIO INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define GPIO_PORT_OFFSET_0x1000
+
+#define GPIO_NUM_OF_PORTS   3   /**< Number of ports in GPIO module;
+                                     Each port contains up to 32 I/O pins. */
+
+#define GPIO_VALID_PIN_MASKS   \
+    { /* Port A */ 0xFFFFFFFF, \
+      /* Port B */ 0xFFFFFFFF, \
+      /* Port C */ 0xFFFFFFFF }
+
+#define GPIO_VALID_INTR_MASKS  \
+    { /* Port A */ 0xFFFFFFFF, \
+      /* Port B */ 0xFFFFFFFF, \
+      /* Port C */ 0xFFFFFFFF }
+
+
+
+#endif /* __PART_INTEGRATION_EXT_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/integrations/LS1043/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/fman/inc/integrations/LS1043/dpaa_integration_ext.h
index d1b0701..ce9c3e7 100644
--- a/drivers/net/ethernet/freescale/fman/inc/integrations/LS1043/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/integrations/LS1043/dpaa_integration_ext.h
@@ -188,24 +188,12 @@ typedef enum
 /*****************************************************************************
  FM INTEGRATION-SPECIFIC DEFINITIONS
 ******************************************************************************/
-/* Add T1 Port constraint:T1040, T1042, T1020, T1022 (T1040RM Rev D, 04/2014) */
-#ifdef CONFIG_FMAN_V3L
-#define INTG_MAX_NUM_OF_FM	1
-
-/* Ports defines */
-#define FM_MAX_NUM_OF_1G_MACS	5
-#define FM_MAX_NUM_OF_10G_MACS	0
-#define FM_MAX_NUM_OF_MACS	(FM_MAX_NUM_OF_1G_MACS + FM_MAX_NUM_OF_10G_MACS)
-#define FM_MAX_NUM_OF_OH_PORTS	4
-#else
 #define INTG_MAX_NUM_OF_FM          2
-
 /* Ports defines */
 #define FM_MAX_NUM_OF_1G_MACS       6
 #define FM_MAX_NUM_OF_10G_MACS      2
 #define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS + FM_MAX_NUM_OF_10G_MACS)
 #define FM_MAX_NUM_OF_OH_PORTS      6
-#endif
 
 #define FM_MAX_NUM_OF_1G_RX_PORTS   FM_MAX_NUM_OF_1G_MACS
 #define FM_MAX_NUM_OF_10G_RX_PORTS  FM_MAX_NUM_OF_10G_MACS
@@ -225,14 +213,14 @@ typedef enum
 
 /* RAMs defines */
 #define FM_MURAM_SIZE                   (384 * KILOBYTE)
-#define FM_IRAM_SIZE                    ( 64 * KILOBYTE)
+#define FM_IRAM_SIZE(major, minor)      (64 * KILOBYTE)
 #define FM_NUM_OF_CTRL                  4
 
 /* PCD defines */
 #define FM_PCD_PLCR_NUM_ENTRIES         256                 /**< Total number of policer profiles */
 #define FM_PCD_KG_NUM_OF_SCHEMES        32                  /**< Total number of KG schemes */
 #define FM_PCD_MAX_NUM_OF_CLS_PLANS     256                 /**< Number of classification plan entries. */
-#define FM_PCD_PRS_SW_PATCHES_SIZE      0x00000440          /**< Number of bytes saved for patches */
+#define FM_PCD_PRS_SW_PATCHES_SIZE      0x00000460          /**< Number of bytes saved for patches */
 #define FM_PCD_SW_PRS_SIZE              0x00000800          /**< Total size of SW parser area */
 
 /* RTC defines */
@@ -253,6 +241,7 @@ typedef enum
 /* BMI defines */
 #define BMI_MAX_NUM_OF_TASKS            128
 #define BMI_MAX_NUM_OF_DMAS             84
+
 #define BMI_MAX_FIFO_SIZE               (FM_MURAM_SIZE)
 #define PORT_MAX_WEIGHT                 16
 
@@ -289,4 +278,13 @@ typedef enum
 /* RMan erratas */
 #define RM_ERRONEOUS_ACK_ERRATA_RMAN_A006756
 
+/*****************************************************************************
+ FM MACSEC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define NUM_OF_RX_SC                16
+#define NUM_OF_TX_SC                16
+
+#define NUM_OF_SA_PER_RX_SC         2
+#define NUM_OF_SA_PER_TX_SC         2
+
 #endif /* __DPAA_INTEGRATION_EXT_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/integrations/LS1043/part_integration_ext.h b/drivers/net/ethernet/freescale/fman/inc/integrations/LS1043/part_integration_ext.h
index a1ca740..85ba2a4 100644
--- a/drivers/net/ethernet/freescale/fman/inc/integrations/LS1043/part_integration_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/integrations/LS1043/part_integration_ext.h
@@ -60,7 +60,56 @@
 *//***************************************************************************/
 typedef enum e_ModuleId
 {
-    e_MODULE_ID_FM = 0,             /**< Frame manager module */
+    e_MODULE_ID_DUART_1 = 0,
+    e_MODULE_ID_DUART_2,
+    e_MODULE_ID_DUART_3,
+    e_MODULE_ID_DUART_4,
+    e_MODULE_ID_LAW,
+    e_MODULE_ID_IFC,
+    e_MODULE_ID_PAMU,
+    e_MODULE_ID_QM,                 /**< Queue manager module */
+    e_MODULE_ID_BM,                 /**< Buffer manager module */
+    e_MODULE_ID_QM_CE_PORTAL_0,
+    e_MODULE_ID_QM_CI_PORTAL_0,
+    e_MODULE_ID_QM_CE_PORTAL_1,
+    e_MODULE_ID_QM_CI_PORTAL_1,
+    e_MODULE_ID_QM_CE_PORTAL_2,
+    e_MODULE_ID_QM_CI_PORTAL_2,
+    e_MODULE_ID_QM_CE_PORTAL_3,
+    e_MODULE_ID_QM_CI_PORTAL_3,
+    e_MODULE_ID_QM_CE_PORTAL_4,
+    e_MODULE_ID_QM_CI_PORTAL_4,
+    e_MODULE_ID_QM_CE_PORTAL_5,
+    e_MODULE_ID_QM_CI_PORTAL_5,
+    e_MODULE_ID_QM_CE_PORTAL_6,
+    e_MODULE_ID_QM_CI_PORTAL_6,
+    e_MODULE_ID_QM_CE_PORTAL_7,
+    e_MODULE_ID_QM_CI_PORTAL_7,
+    e_MODULE_ID_QM_CE_PORTAL_8,
+    e_MODULE_ID_QM_CI_PORTAL_8,
+    e_MODULE_ID_QM_CE_PORTAL_9,
+    e_MODULE_ID_QM_CI_PORTAL_9,
+    e_MODULE_ID_BM_CE_PORTAL_0,
+    e_MODULE_ID_BM_CI_PORTAL_0,
+    e_MODULE_ID_BM_CE_PORTAL_1,
+    e_MODULE_ID_BM_CI_PORTAL_1,
+    e_MODULE_ID_BM_CE_PORTAL_2,
+    e_MODULE_ID_BM_CI_PORTAL_2,
+    e_MODULE_ID_BM_CE_PORTAL_3,
+    e_MODULE_ID_BM_CI_PORTAL_3,
+    e_MODULE_ID_BM_CE_PORTAL_4,
+    e_MODULE_ID_BM_CI_PORTAL_4,
+    e_MODULE_ID_BM_CE_PORTAL_5,
+    e_MODULE_ID_BM_CI_PORTAL_5,
+    e_MODULE_ID_BM_CE_PORTAL_6,
+    e_MODULE_ID_BM_CI_PORTAL_6,
+    e_MODULE_ID_BM_CE_PORTAL_7,
+    e_MODULE_ID_BM_CI_PORTAL_7,
+    e_MODULE_ID_BM_CE_PORTAL_8,
+    e_MODULE_ID_BM_CI_PORTAL_8,
+    e_MODULE_ID_BM_CE_PORTAL_9,
+    e_MODULE_ID_BM_CI_PORTAL_9,
+    e_MODULE_ID_FM,                 /**< Frame manager module */
     e_MODULE_ID_FM_RTC,             /**< FM Real-Time-Clock */
     e_MODULE_ID_FM_MURAM,           /**< FM Multi-User-RAM */
     e_MODULE_ID_FM_BMI,             /**< FM BMI block */
@@ -106,6 +155,27 @@ typedef enum e_ModuleId
     e_MODULE_ID_FM_10GMAC1,         /**< FM 10G MAC */
     e_MODULE_ID_FM_10GMAC2,         /**< FM 10G MAC */
 
+    e_MODULE_ID_SEC_GEN,            /**< SEC 4.0 General registers      */
+    e_MODULE_ID_SEC_QI,             /**< SEC 4.0 QI registers           */
+    e_MODULE_ID_SEC_JQ0,            /**< SEC 4.0 JQ-0 registers         */
+    e_MODULE_ID_SEC_JQ1,            /**< SEC 4.0 JQ-1 registers         */
+    e_MODULE_ID_SEC_JQ2,            /**< SEC 4.0 JQ-2 registers         */
+    e_MODULE_ID_SEC_JQ3,            /**< SEC 4.0 JQ-3 registers         */
+    e_MODULE_ID_SEC_RTIC,           /**< SEC 4.0 RTIC registers         */
+    e_MODULE_ID_SEC_DECO0_CCB0,     /**< SEC 4.0 DECO-0/CCB-0 registers */
+    e_MODULE_ID_SEC_DECO1_CCB1,     /**< SEC 4.0 DECO-1/CCB-1 registers */
+    e_MODULE_ID_SEC_DECO2_CCB2,     /**< SEC 4.0 DECO-2/CCB-2 registers */
+    e_MODULE_ID_SEC_DECO3_CCB3,     /**< SEC 4.0 DECO-3/CCB-3 registers */
+    e_MODULE_ID_SEC_DECO4_CCB4,     /**< SEC 4.0 DECO-4/CCB-4 registers */
+
+    e_MODULE_ID_PIC,                /**< PIC */
+    e_MODULE_ID_GPIO,               /**< GPIO */
+    e_MODULE_ID_SERDES,             /**< SERDES */
+    e_MODULE_ID_CPC_1,              /**< CoreNet-Platform-Cache 1 */
+    e_MODULE_ID_CPC_2,              /**< CoreNet-Platform-Cache 2 */
+
+    e_MODULE_ID_SRIO_PORTS,         /**< RapidIO controller */
+
     e_MODULE_ID_DUMMY_LAST
 } e_ModuleId;
 
diff --git a/drivers/net/ethernet/freescale/fman/inc/integrations/P1023/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/fman/inc/integrations/P1023/dpaa_integration_ext.h
index 92906db..7b5390d 100644
--- a/drivers/net/ethernet/freescale/fman/inc/integrations/P1023/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/integrations/P1023/dpaa_integration_ext.h
@@ -136,7 +136,7 @@ typedef enum {
 
 /* Rams defines */
 #define FM_MURAM_SIZE                   (64*KILOBYTE)
-#define FM_IRAM_SIZE                    (32*KILOBYTE)
+#define FM_IRAM_SIZE(major, minor)      (32 * KILOBYTE)
 #define FM_NUM_OF_CTRL                  2
 
 /* PCD defines */
@@ -180,31 +180,6 @@ typedef enum {
  @Description   Enum for inter-module interrupts registration
 *//***************************************************************************/
 
-typedef enum e_FmMacsecEventModules{
-    e_FM_MACSEC_MOD_SC_TX,
-    e_FM_MACSEC_MOD_DUMMY_LAST
-} e_FmMacsecEventModules;
-
-typedef enum e_FmMacsecInterModuleEvent {
-    e_FM_MACSEC_EV_SC_TX,
-    e_FM_MACSEC_EV_ERR_SC_TX,
-    e_FM_MACSEC_EV_DUMMY_LAST
-} e_FmMacsecInterModuleEvent;
-
-#define NUM_OF_INTER_MODULE_EVENTS (NUM_OF_TX_SC * 2)
-
-#define GET_MACSEC_MODULE_EVENT(mod, id, intrType, event) \
-    switch(mod){                                          \
-        case e_FM_MACSEC_MOD_SC_TX:                       \
-             event = (intrType == e_FM_INTR_TYPE_ERR) ?   \
-                        e_FM_MACSEC_EV_ERR_SC_TX:         \
-                        e_FM_MACSEC_EV_SC_TX;             \
-             event += (uint8_t)(2 * id);break;            \
-            break;                                        \
-        default:event = e_FM_MACSEC_EV_DUMMY_LAST;        \
-        break;}
-
-
 /* 1023 unique features */
 #define FM_QMI_NO_ECC_EXCEPTIONS
 #define FM_CSI_CFED_LIMIT
diff --git a/drivers/net/ethernet/freescale/fman/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/fman/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
index 257acb0..6e2b925 100644
--- a/drivers/net/ethernet/freescale/fman/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
@@ -179,7 +179,7 @@ typedef enum
 
 /* Rams defines */
 #define FM_MURAM_SIZE                   (160*KILOBYTE)
-#define FM_IRAM_SIZE                    ( 64*KILOBYTE)
+#define FM_IRAM_SIZE(major, minor)      (64 * KILOBYTE)
 #define FM_NUM_OF_CTRL                  2
 
 /* PCD defines */
@@ -263,4 +263,14 @@ typedef enum
 #define FM_NO_CTXA_COPY_ERRATA_FMAN_SW001
 #define FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
 
+/*****************************************************************************
+ FM MACSEC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define NUM_OF_RX_SC                16
+#define NUM_OF_TX_SC                16
+
+#define NUM_OF_SA_PER_RX_SC         2
+#define NUM_OF_SA_PER_TX_SC         2
+
+
 #endif /* __DPAA_INTEGRATION_EXT_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/ncsw_ext.h b/drivers/net/ethernet/freescale/fman/inc/ncsw_ext.h
index e7964ad..8de7f5c 100644
--- a/drivers/net/ethernet/freescale/fman/inc/ncsw_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/ncsw_ext.h
@@ -40,11 +40,11 @@
 #ifndef __NCSW_EXT_H
 #define __NCSW_EXT_H
 
-#include "memcpy_ext.h"
 
+#include "memcpy_ext.h"
 
-#define WRITE_BLOCK                 IOMemSet32
-#define COPY_BLOCK                  Mem2IOCpy32
+#define WRITE_BLOCK                 IOMemSet32   /* include memcpy_ext.h */
+#define COPY_BLOCK                  Mem2IOCpy32  /* include memcpy_ext.h */
 
 #define PTR_TO_UINT(_ptr)           ((uintptr_t)(_ptr))
 #define UINT_TO_PTR(_val)           ((void*)(uintptr_t)(_val))
@@ -52,8 +52,10 @@
 #define PTR_MOVE(_ptr, _offset)     (void*)((uint8_t*)(_ptr) + (_offset))
 
 
-#define WRITE_UINT8_UINT24(arg, data08, data24) WRITE_UINT32(arg,((uint32_t)(data08)<<24)|((uint32_t)(data24)&0x00FFFFFF))
-#define WRITE_UINT24_UINT8(arg, data24, data08) WRITE_UINT32(arg,((uint32_t)(data24)<< 8)|((uint32_t)(data08)&0x000000FF))
+#define WRITE_UINT8_UINT24(arg, data08, data24) \
+    WRITE_UINT32(arg,((uint32_t)(data08)<<24)|((uint32_t)(data24)&0x00FFFFFF))
+#define WRITE_UINT24_UINT8(arg, data24, data08) \
+    WRITE_UINT32(arg,((uint32_t)(data24)<< 8)|((uint32_t)(data08)&0x000000FF))
 
 /* Little-Endian access macros */
 
@@ -94,7 +96,7 @@
 /* Miscellaneous macros */
 /*----------------------*/
 
-#define UNUSED(X) (X=X)
+#define UNUSED(_x)		((void)(_x))
 
 #define KILOBYTE            0x400UL                 /* 1024 */
 #define MEGABYTE            (KILOBYTE * KILOBYTE)   /* 1024*1024 */
diff --git a/drivers/net/ethernet/freescale/fman/inc/types_ext.h b/drivers/net/ethernet/freescale/fman/inc/types_ext.h
index 373f388..6c92d6d 100644
--- a/drivers/net/ethernet/freescale/fman/inc/types_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/types_ext.h
@@ -59,10 +59,18 @@
 #include "types_dflt.h"
 #endif /* defined (__ROCOO__) */
 
-#if 0
+#ifndef CONFIG_ARM64
 static __inline__ void TypesChecker(void)
 {
-
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+     _Packed struct strct {
+        __volatile__ int vi;
+    } _PackedType;
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
     size_t          size = 0;
     bool            tr = TRUE, fls = FALSE;
     struct strct    *p_Struct = NULL;
@@ -93,5 +101,5 @@ static __inline__ void TypesChecker(void)
     WRITE_UINT64(*((uint64_t*)((size_t)(INT64_MAX))),
                  GET_UINT64(*((uint64_t*)((size_t)(INT64_MIN)))));
 }
-#endif /* 0 */
+#endif /* !CONFIG_ARM64 */
 #endif /* __TYPES_EXT_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/xx_common.h b/drivers/net/ethernet/freescale/fman/inc/xx_common.h
index 1c45177..8e81094 100644
--- a/drivers/net/ethernet/freescale/fman/inc/xx_common.h
+++ b/drivers/net/ethernet/freescale/fman/inc/xx_common.h
@@ -52,5 +52,5 @@
 #define MODULE_FM_PORT          0x00060000
 #define MODULE_MM               0x00070000
 #define MODULE_FM_SP            0x00080000
-
+#define MODULE_FM_MACSEC        0x00090000
 #endif /* __XX_COMMON_H */
diff --git a/drivers/net/ethernet/freescale/fman/ncsw_config.mk b/drivers/net/ethernet/freescale/fman/ncsw_config.mk
index 3933ac2..9b1bd0d 100644
--- a/drivers/net/ethernet/freescale/fman/ncsw_config.mk
+++ b/drivers/net/ethernet/freescale/fman/ncsw_config.mk
@@ -6,43 +6,48 @@ DRV_DPA     = $(srctree)/drivers/net/ethernet/freescale/dpa
 FMAN        = $(srctree)/drivers/net/ethernet/freescale/fman
 
 ifeq ("$(CONFIG_FMAN_P3040_P4080_P5020)", "y")
-EXTRA_CFLAGS +=-include $(FMAN)/p3040_4080_5020_dflags.h
+ccflags-y +=-include $(FMAN)/p3040_4080_5020_dflags.h
 endif
 ifeq ("$(CONFIG_FMAN_P1023)", "y")
-EXTRA_CFLAGS +=-include $(FMAN)/p1023_dflags.h
+ccflags-y +=-include $(FMAN)/p1023_dflags.h
 endif
-ifdef CONFIG_FMAN_T4240
-EXTRA_CFLAGS +=-include $(FMAN)/t4240_dflags.h
+ifdef CONFIG_FMAN_V3H
+ccflags-y +=-include $(FMAN)/fmanv3h_dflags.h
+endif
+ifdef CONFIG_FMAN_V3L
+ccflags-y +=-include $(FMAN)/fmanv3l_dflags.h
 endif
 ifdef CONFIG_FMAN_LS1043
 EXTRA_CFLAGS +=-include $(FMAN)/ls1043_dflags.h
 endif
 
-EXTRA_CFLAGS += -I$(DRV_DPA)/
-EXTRA_CFLAGS += -I$(FMAN)/inc
-EXTRA_CFLAGS += -I$(FMAN)/inc/cores
-EXTRA_CFLAGS += -I$(FMAN)/inc/etc
-EXTRA_CFLAGS += -I$(FMAN)/inc/Peripherals
-EXTRA_CFLAGS += -I$(FMAN)/inc/flib
+ccflags-y += -I$(DRV_DPA)/
+ccflags-y += -I$(FMAN)/inc
+ccflags-y += -I$(FMAN)/inc/cores
+ccflags-y += -I$(FMAN)/inc/etc
+ccflags-y += -I$(FMAN)/inc/Peripherals
+ccflags-y += -I$(FMAN)/inc/flib
 
 ifeq ("$(CONFIG_FMAN_P3040_P4080_P5020)", "y")
-EXTRA_CFLAGS += -I$(FMAN)/inc/integrations/P3040_P4080_P5020
+ccflags-y += -I$(FMAN)/inc/integrations/P3040_P4080_P5020
 endif
 ifeq ("$(CONFIG_FMAN_P1023)", "y")
-EXTRA_CFLAGS += -I$(FMAN)/inc/integrations/P1023
+ccflags-y += -I$(FMAN)/inc/integrations/P1023
+endif
+ifdef CONFIG_FMAN_V3H
+ccflags-y += -I$(FMAN)/inc/integrations/FMANV3H
 endif
-ifdef CONFIG_FMAN_T4240
-EXTRA_CFLAGS += -I$(FMAN)/inc/integrations/T4240
+ifdef CONFIG_FMAN_V3L
+ccflags-y += -I$(FMAN)/inc/integrations/FMANV3L
 endif
 ifdef CONFIG_FMAN_LS1043
 EXTRA_CFLAGS += -I$(FMAN)/inc/integrations/LS1043
 endif
 
-
-EXTRA_CFLAGS += -I$(FMAN)/src/inc
-EXTRA_CFLAGS += -I$(FMAN)/src/inc/system
-EXTRA_CFLAGS += -I$(FMAN)/src/inc/wrapper
-EXTRA_CFLAGS += -I$(FMAN)/src/inc/xx
-EXTRA_CFLAGS += -I$(srctree)/include/uapi/linux/fmd
-EXTRA_CFLAGS += -I$(srctree)/include/uapi/linux/fmd/Peripherals
-EXTRA_CFLAGS += -I$(srctree)/include/uapi/linux/fmd/integrations
+ccflags-y += -I$(FMAN)/src/inc
+ccflags-y += -I$(FMAN)/src/inc/system
+ccflags-y += -I$(FMAN)/src/inc/wrapper
+ccflags-y += -I$(FMAN)/src/inc/xx
+ccflags-y += -I$(srctree)/include/uapi/linux/fmd
+ccflags-y += -I$(srctree)/include/uapi/linux/fmd/Peripherals
+ccflags-y += -I$(srctree)/include/uapi/linux/fmd/integrations
diff --git a/drivers/net/ethernet/freescale/fman/src/Makefile b/drivers/net/ethernet/freescale/fman/src/Makefile
index af5d2e7..b047ea7 100644
--- a/drivers/net/ethernet/freescale/fman/src/Makefile
+++ b/drivers/net/ethernet/freescale/fman/src/Makefile
@@ -1,7 +1,7 @@
 #
 # Makefile for the Freescale Ethernet controllers
 #
-EXTRA_CFLAGS           += -DVERSION=\"\"
+ccflags-y           += -DVERSION=\"\"
 #
 #Include netcomm SW specific definitions
 include $(srctree)/drivers/net/ethernet/freescale/fman/ncsw_config.mk
diff --git a/drivers/net/ethernet/freescale/fman/src/inc/types_linux.h b/drivers/net/ethernet/freescale/fman/src/inc/types_linux.h
index 3c9fa45..28a86b7 100644
--- a/drivers/net/ethernet/freescale/fman/src/inc/types_linux.h
+++ b/drivers/net/ethernet/freescale/fman/src/inc/types_linux.h
@@ -45,7 +45,10 @@
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <asm/io.h>
+
+#ifdef CONFIG_ARM64
 #include <asm/delay.h>
+#endif /* CONFIG_ARM64 */
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
     #error "This kernel is probably not supported!!!"
diff --git a/drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fsl_fman.h b/drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fsl_fman.h
index 00ec9f1..f068499 100644
--- a/drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fsl_fman.h
+++ b/drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fsl_fman.h
@@ -45,6 +45,7 @@
 #include "dpaa_integration_ext.h"
 #include "fm_port_ext.h"
 #include "fm_mac_ext.h"
+#include "fm_macsec_ext.h"
 #include "fm_rtc_ext.h"
 
 /**************************************************************************//**
@@ -69,6 +70,162 @@
 /*****************************************************************************/
 
 /**************************************************************************//**
+ @Description   MACSEC Exceptions wrapper
+*//***************************************************************************/
+typedef enum fm_macsec_exception {
+	SINGLE_BIT_ECC = e_FM_MACSEC_EX_SINGLE_BIT_ECC,
+	MULTI_BIT_ECC = e_FM_MACSEC_EX_MULTI_BIT_ECC
+} fm_macsec_exception;
+
+/**************************************************************************//**
+ @Description   Unknown sci frame treatment wrapper
+*//***************************************************************************/
+typedef enum fm_macsec_unknown_sci_frame_treatment {
+	SCI_DISCARD_BOTH = e_FM_MACSEC_UNKNOWN_SCI_FRAME_TREATMENT_DISCARD_BOTH,
+	SCI_DISCARD_UNCTRL_DELIVER_DISCARD_CTRL = \
+		e_FM_MACSEC_UNKNOWN_SCI_FRAME_TREATMENT_DISCARD_UNCONTROLLED_DELIVER_OR_DISCARD_CONTROLLED,
+	SCI_DELIVER_UNCTRL_DISCARD_CTRL = \
+		e_FM_MACSEC_UNKNOWN_SCI_FRAME_TREATMENT_DELIVER_UNCONTROLLED_DISCARD_CONTROLLED,
+	SCI_DELIVER_DISCARD_UNCTRL_DELIVER_DISCARD_CTRL = \
+		e_FM_MACSEC_UNKNOWN_SCI_FRAME_TREATMENT_DELIVER_OR_DISCARD_UNCONTROLLED_DELIVER_OR_DISCARD_CONTROLLED
+} fm_macsec_unknown_sci_frame_treatment;
+
+/**************************************************************************//**
+ @Description   Untag frame treatment wrapper
+*//***************************************************************************/
+typedef enum fm_macsec_untag_frame_treatment {
+	UNTAG_DELIVER_UNCTRL_DISCARD_CTRL = \
+		e_FM_MACSEC_UNTAG_FRAME_TREATMENT_DELIVER_UNCONTROLLED_DISCARD_CONTROLLED,
+	UNTAG_DISCARD_BOTH = e_FM_MACSEC_UNTAG_FRAME_TREATMENT_DISCARD_BOTH,
+	UNTAG_DISCARD_UNCTRL_DELIVER_CTRL_UNMODIFIED = \
+		e_FM_MACSEC_UNTAG_FRAME_TREATMENT_DISCARD_UNCONTROLLED_DELIVER_CONTROLLED_UNMODIFIED
+} fm_macsec_untag_frame_treatment;
+
+/**************************************************************************//**
+@Description   MACSEC SECY Cipher Suite wrapper
+*//***************************************************************************/
+typedef enum fm_macsec_secy_cipher_suite {
+	SECY_GCM_AES_128 = e_FM_MACSEC_SECY_GCM_AES_128,    /**< GCM-AES-128 */
+#if (DPAA_VERSION >= 11)
+	SECY_GCM_AES_256 = e_FM_MACSEC_SECY_GCM_AES_256     /**< GCM-AES-256 */
+#endif /* (DPAA_VERSION >= 11) */
+} fm_macsec_secy_cipher_suite;
+
+/**************************************************************************//**
+ @Description   MACSEC SECY Exceptions wrapper
+*//***************************************************************************/
+typedef enum fm_macsec_secy_exception {
+	SECY_EX_FRAME_DISCARDED = e_FM_MACSEC_SECY_EX_FRAME_DISCARDED
+} fm_macsec_secy_exception;
+
+/**************************************************************************//**
+ @Description   MACSEC SECY Events wrapper
+*//***************************************************************************/
+typedef enum fm_macsec_secy_event {
+	SECY_EV_NEXT_PN = e_FM_MACSEC_SECY_EV_NEXT_PN
+} fm_macsec_secy_event;
+
+/**************************************************************************//**
+ @Description   Valid frame behaviors wrapper
+*//***************************************************************************/
+typedef enum fm_macsec_valid_frame_behavior {
+	VALID_FRAME_BEHAVIOR_DISABLE = e_FM_MACSEC_VALID_FRAME_BEHAVIOR_DISABLE,
+	VALID_FRAME_BEHAVIOR_CHECK = e_FM_MACSEC_VALID_FRAME_BEHAVIOR_CHECK,
+	VALID_FRAME_BEHAVIOR_STRICT = e_FM_MACSEC_VALID_FRAME_BEHAVIOR_STRICT
+} fm_macsec_valid_frame_behavior;
+
+/**************************************************************************//**
+ @Description   SCI insertion modes wrapper
+*//***************************************************************************/
+typedef enum fm_macsec_sci_insertion_mode {
+	SCI_INSERTION_MODE_EXPLICIT_SECTAG = \
+		e_FM_MACSEC_SCI_INSERTION_MODE_EXPLICIT_SECTAG,
+	SCI_INSERTION_MODE_EXPLICIT_MAC_SA = \
+		e_FM_MACSEC_SCI_INSERTION_MODE_EXPLICIT_MAC_SA,
+	SCI_INSERTION_MODE_IMPLICT_PTP = e_FM_MACSEC_SCI_INSERTION_MODE_IMPLICT_PTP
+} fm_macsec_sci_insertion_mode;
+
+typedef macsecSAKey_t macsec_sa_key_t;
+typedef macsecSCI_t macsec_sci_t;
+typedef macsecAN_t macsec_an_t;
+typedef t_Handle handle_t;
+
+/**************************************************************************//**
+ @Function      fm_macsec_secy_exception_callback wrapper
+ @Description   Exceptions user callback routine, will be called upon an
+                exception passing the exception identification.
+ @Param[in]     app_h       A handle to an application layer object; This handle
+                            will be passed by the driver upon calling this callback.
+ @Param[in]     exception   The exception.
+*//***************************************************************************/
+typedef void (fm_macsec_secy_exception_callback) (handle_t app_h,
+				fm_macsec_secy_exception exception);
+
+/**************************************************************************//**
+ @Function      fm_macsec_secy_event_callback wrapper
+ @Description   Events user callback routine, will be called upon an
+                event passing the event identification.
+ @Param[in]     app_h       A handle to an application layer object; This handle
+                            will be passed by the driver upon calling this callback.
+ @Param[in]     event       The event.
+*//***************************************************************************/
+typedef void (fm_macsec_secy_event_callback) (handle_t app_h,
+				fm_macsec_secy_event event);
+
+/**************************************************************************//**
+ @Function      fm_macsec_exception_callback wrapper
+ @Description   Exceptions user callback routine, will be called upon an
+                exception passing the exception identification.
+ @Param[in]     app_h       A handle to an application layer object; This handle
+                            will be passed by the driver upon calling this callback.
+ @Param[in]     exception   The exception.
+*//***************************************************************************/
+typedef void (fm_macsec_exception_callback) (handle_t app_h,
+				fm_macsec_exception exception);
+
+/**************************************************************************//**
+ @Description   MACSEC SecY SC Params wrapper
+*//***************************************************************************/
+struct fm_macsec_secy_sc_params {
+	macsec_sci_t sci;
+	fm_macsec_secy_cipher_suite cipher_suite;
+};
+
+/**************************************************************************//**
+ @Description   FM MACSEC SecY config input wrapper
+*//***************************************************************************/
+struct fm_macsec_secy_params {
+	handle_t fm_macsec_h;
+	struct fm_macsec_secy_sc_params tx_sc_params;
+	uint32_t num_receive_channels;
+	fm_macsec_secy_exception_callback *exception_f;
+	fm_macsec_secy_event_callback *event_f;
+	handle_t app_h;
+};
+
+/**************************************************************************//**
+ @Description   FM MACSEC config input wrapper
+*//***************************************************************************/
+struct fm_macsec_params {
+	handle_t fm_h;
+	bool guest_mode;
+
+	union {
+		struct {
+			uint8_t fm_mac_id;
+		} guest_params;
+
+		struct {
+			uintptr_t base_addr;
+			handle_t fm_mac_h;
+			fm_macsec_exception_callback *exception_f;
+			handle_t app_h;
+		} non_guest_params;
+	};
+
+};
+
+/**************************************************************************//**
  @Description	FM device opaque structure used for type checking
 *//***************************************************************************/
 struct fm;
@@ -79,6 +236,12 @@ struct fm;
 struct fm_mac_dev;
 
 /**************************************************************************//**
+ @Description	FM MACSEC device opaque structure used for type checking
+*//***************************************************************************/
+struct fm_macsec_dev;
+struct fm_macsec_secy_dev;
+
+/**************************************************************************//**
  @Description	A structure ..,
 *//***************************************************************************/
 struct fm_port;
@@ -231,7 +394,7 @@ void fm_port_get_buff_layout_ext_params(struct fm_port *port, struct fm_port_par
 
  @Cautions	Allowed only after the port is binded.
 *//***************************************************************************/
-int fm_get_tx_port_channel(struct fm_port *port);
+uint16_t fm_get_tx_port_channel(struct fm_port *port);
 
 /**************************************************************************//**
  @Function	fm_set_tx_port_params
@@ -484,8 +647,8 @@ struct   auto_res_filtering_info
 	/* IP protocol filtering parameters */
 	uint8_t     ip_prot_table_size;
 	uint8_t     *ip_prot_table_ptr;
-	bool        ip_prot_drop_on_hit;  /* when TRUE, hit in the table will
-		cause the packet to be droped, miss will pass the packet to
+	bool        ip_prot_pass_on_hit;  /* when TRUE, miss in the table will
+		cause the packet to be droped, hit will pass the packet to
 		UDP/TCP filters if needed and if not to the classification
 		tree. If the classification tree will pass the packet to a
 		queue it will cause a wake interupt. When FALSE it the other
@@ -493,8 +656,8 @@ struct   auto_res_filtering_info
 	/* UDP port filtering parameters */
 	uint8_t     udp_ports_table_size;
 	struct auto_res_port_filtering_entry *udp_ports_table_ptr;
-	bool        udp_port_drop_on_hit; /* when TRUE, hit in the table will
-		cause the packet to be droped, miss will pass the packet to
+	bool        udp_port_pass_on_hit; /* when TRUE, miss in the table will
+		cause the packet to be droped, hit will pass the packet to
 		classification tree. If the classification tree will pass the
 		packet to a queue it will cause a wake interupt. When FALSE it
 		the other way around. */
@@ -502,8 +665,8 @@ struct   auto_res_filtering_info
 	uint16_t    tcp_flags_mask;
 	uint8_t     tcp_ports_table_size;
 	struct auto_res_port_filtering_entry *tcp_ports_table_ptr;
-	bool        tcp_port_drop_on_hit; /* when TRUE, hit in the table will
-		cause the packet to be droped, miss will pass the packet to
+	bool        tcp_port_pass_on_hit; /* when TRUE, miss in the table will
+		cause the packet to be droped, hit will pass the packet to
 		classification tree. If the classification tree will pass the
 		packet to a queue it will cause a wake interupt. When FALSE it
 		the other way around. */
@@ -648,6 +811,104 @@ int fm_rtc_set_fiper(struct fm *fm_dev, uint32_t id,
 int fm_mac_set_wol(struct fm_port *port, struct fm_mac_dev *fm_mac_dev,
 			bool en);
 
+/**************************************************************************//**
+@Function     fm_macsec_set_exception
+
+@Description  Set MACSEC exception state.
+
+@Param[in]    fm_macsec_dev   - A handle of the FM MACSEC device.
+@Param[in]    exception    - FM MACSEC exception type.
+@Param[in]    enable       - new state.
+
+*//***************************************************************************/
+
+int fm_macsec_set_exception(struct fm_macsec_dev *fm_macsec_dev,
+			fm_macsec_exception exception, bool enable);
+int fm_macsec_free(struct fm_macsec_dev *fm_macsec_dev);
+struct fm_macsec_dev *fm_macsec_config(struct fm_macsec_params *fm_params);
+int fm_macsec_init(struct fm_macsec_dev *fm_macsec_dev);
+int fm_macsec_config_unknown_sci_frame_treatment(struct fm_macsec_dev
+				*fm_macsec_dev,
+				fm_macsec_unknown_sci_frame_treatment treat_mode);
+int fm_macsec_config_invalid_tags_frame_treatment(struct fm_macsec_dev *fm_macsec_dev,
+				bool deliver_uncontrolled);
+int fm_macsec_config_kay_frame_treatment(struct fm_macsec_dev *fm_macsec_dev,
+				bool discard_uncontrolled);
+int fm_macsec_config_untag_frame_treatment(struct fm_macsec_dev *fm_macsec_dev,
+				    fm_macsec_untag_frame_treatment treat_mode);
+int fm_macsec_config_pn_exhaustion_threshold(struct fm_macsec_dev *fm_macsec_dev,
+					uint32_t pnExhThr);
+int fm_macsec_config_keys_unreadable(struct fm_macsec_dev *fm_macsec_dev);
+int fm_macsec_config_sectag_without_sci(struct fm_macsec_dev *fm_macsec_dev);
+int fm_macsec_config_exception(struct fm_macsec_dev *fm_macsec_dev,
+			    fm_macsec_exception exception, bool enable);
+int fm_macsec_get_revision(struct fm_macsec_dev *fm_macsec_dev,
+			    int *macsec_revision);
+int fm_macsec_enable(struct fm_macsec_dev *fm_macsec_dev);
+int fm_macsec_disable(struct fm_macsec_dev *fm_macsec_dev);
+
+
+int fm_macsec_secy_config_exception(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				    fm_macsec_secy_exception exception,
+				    bool enable);
+int fm_macsec_secy_free(struct fm_macsec_secy_dev *fm_macsec_secy_dev);
+struct fm_macsec_secy_dev *fm_macsec_secy_config(struct fm_macsec_secy_params *secy_params);
+int fm_macsec_secy_init(struct fm_macsec_secy_dev *fm_macsec_secy_dev);
+int fm_macsec_secy_config_sci_insertion_mode(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				fm_macsec_sci_insertion_mode sci_insertion_mode);
+int fm_macsec_secy_config_protect_frames(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				bool protect_frames);
+int fm_macsec_secy_config_replay_window(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				bool replay_protect, uint32_t replay_window);
+int fm_macsec_secy_config_validation_mode(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				fm_macsec_valid_frame_behavior validate_frames);
+int fm_macsec_secy_config_confidentiality(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				bool confidentiality_enable,
+				uint32_t confidentiality_offset);
+int fm_macsec_secy_config_point_to_point(struct fm_macsec_secy_dev *fm_macsec_secy_dev);
+int fm_macsec_secy_config_event(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				    fm_macsec_secy_event event,
+				    bool enable);
+struct rx_sc_dev *fm_macsec_secy_create_rxsc(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				struct fm_macsec_secy_sc_params *params);
+int fm_macsec_secy_delete_rxsc(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				struct rx_sc_dev *sc);
+int fm_macsec_secy_create_rx_sa(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				struct rx_sc_dev *sc, macsec_an_t an,
+				uint32_t lowest_pn, macsec_sa_key_t key);
+int fm_macsec_secy_delete_rx_sa(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				struct rx_sc_dev *sc, macsec_an_t an);
+int fm_macsec_secy_rxsa_enable_receive(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					struct rx_sc_dev *sc,
+					macsec_an_t an);
+int fm_macsec_secy_rxsa_disable_receive(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					struct rx_sc_dev *sc,
+					macsec_an_t an);
+int fm_macsec_secy_rxsa_update_next_pn(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					struct rx_sc_dev *sc,
+					macsec_an_t an, uint32_t updt_next_pn);
+int fm_macsec_secy_rxsa_update_lowest_pn(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					struct rx_sc_dev *sc,
+					macsec_an_t an, uint32_t updt_lowest_pn);
+int fm_macsec_secy_rxsa_modify_key(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					struct rx_sc_dev *sc,
+					macsec_an_t an, macsec_sa_key_t key);
+int fm_macsec_secy_create_tx_sa(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				macsec_an_t an, macsec_sa_key_t key);
+int fm_macsec_secy_delete_tx_sa(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				macsec_an_t an);
+int fm_macsec_secy_txsa_modify_key(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					macsec_an_t next_active_an,
+					macsec_sa_key_t key);
+int fm_macsec_secy_txsa_set_active(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					macsec_an_t an);
+int fm_macsec_secy_txsa_get_active(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					macsec_an_t *p_an);
+int fm_macsec_secy_get_rxsc_phys_id(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				struct rx_sc_dev *sc, uint32_t *sc_phys_id);
+int fm_macsec_secy_get_txsc_phys_id(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				    uint32_t *sc_phys_id);
+
 /** @} */ /* end of FM_LnxKern_ctrl_grp group */
 /** @} */ /* end of FM_LnxKern_grp group */
 
diff --git a/drivers/net/ethernet/freescale/fman/src/system/Makefile b/drivers/net/ethernet/freescale/fman/src/system/Makefile
index f1aa763..142490b 100644
--- a/drivers/net/ethernet/freescale/fman/src/system/Makefile
+++ b/drivers/net/ethernet/freescale/fman/src/system/Makefile
@@ -1,7 +1,7 @@
 #
 # Makefile for the Freescale Ethernet controllers
 #
-EXTRA_CFLAGS           += -DVERSION=\"\"
+ccflags-y           += -DVERSION=\"\"
 #
 #Include netcomm SW specific definitions
 include $(srctree)/drivers/net/ethernet/freescale/fman/ncsw_config.mk
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/Makefile b/drivers/net/ethernet/freescale/fman/src/wrapper/Makefile
index c2b7bb8..5af801c 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/Makefile
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/Makefile
@@ -1,19 +1,21 @@
 #
 # Makefile for the Freescale Ethernet controllers
 #
-EXTRA_CFLAGS           += -DVERSION=\"\"
+ccflags-y           += -DVERSION=\"\"
 #
 #Include netcomm SW specific definitions
 include $(srctree)/drivers/net/ethernet/freescale/fman/ncsw_config.mk
 
 NCSW_FM_INC = $(srctree)/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc
 
-EXTRA_CFLAGS += -I$(NCSW_FM_INC)
-EXTRA_CFLAGS += -I$(NET_DPA)
+ccflags-y += -I$(NCSW_FM_INC)
+ccflags-y += -I$(NET_DPA)
+
+EXTRA_CFLAGS += -Wno-error=date-time
 
 obj-y		+= fsl-ncsw-PFM.o
 obj-$(CONFIG_FSL_FMAN_TEST)	+= fman_test.o
 
 fsl-ncsw-PFM-objs	:=	lnxwrp_fm.o lnxwrp_fm_port.o lnxwrp_ioctls_fm.o \
-				lnxwrp_sysfs.o lnxwrp_sysfs_fm.o lnxwrp_sysfs_fm_port.o
+				lnxwrp_sysfs.o lnxwrp_sysfs_fm.o lnxwrp_sysfs_fm_port.o 
 obj-$(CONFIG_COMPAT)     +=   lnxwrp_ioctls_fm_compat.o
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
index c4ab684..c2f7fc7 100755
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
@@ -58,10 +58,14 @@
 #include <linux/of_irq.h>
 #include <asm/uaccess.h>
 #include <asm/errno.h>
-/*
+#include <linux/fsl/qe.h>        /* For struct qe_firmware */
+
+#ifndef CONFIG_ARM64
 #include <sysdev/fsl_soc.h>
 #include <asm/fsl_pm.h>
-*/
+#include <asm/fsl_guts.h>
+#endif /* !CONFIG_ARM64 */
+
 #include <linux/stat.h>	   /* For file access mask */
 #include <linux/skbuff.h>
 #include <linux/proc_fs.h>
@@ -80,7 +84,8 @@
 #include "lnxwrp_sysfs_fm.h"
 #include "lnxwrp_sysfs_fm_port.h"
 #include "lnxwrp_exp_sym.h"
-
+#include "fm_common.h"
+#include "../../fman/Peripherals/FM/fm.h"
 #define __ERR_MODULE__  MODULE_FM
 
 extern struct device_node *GetFmPortAdvArgsDevTreeNode (struct device_node *fm_node,
@@ -156,11 +161,13 @@ int fm_get_max_frm()
 {
 	return fsl_fm_max_frm;
 }
+EXPORT_SYMBOL(fm_get_max_frm);
 
 int fm_get_rx_extra_headroom()
 {
 	return ALIGN(fsl_fm_rx_extra_headroom, 16);
 }
+EXPORT_SYMBOL(fm_get_rx_extra_headroom);
 
 static int __init fm_set_max_frm(char *str)
 {
@@ -237,12 +244,19 @@ early_param(FSL_FM_RX_EXTRA_HEADROOM_BOOTARG, fm_set_rx_extra_headroom);
 static irqreturn_t fm_irq(int irq, void *_dev)
 {
     t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)_dev;
-
+#ifdef CONFIG_PM_SLEEP
+    t_Fm               *p_Fm = (t_Fm*)p_LnxWrpFmDev->h_Dev;
+#endif
     if (!p_LnxWrpFmDev || !p_LnxWrpFmDev->h_Dev)
         return IRQ_NONE;
 
+#ifdef CONFIG_PM_SLEEP
+    if (fman_get_normal_pending(p_Fm->p_FmFpmRegs) & INTR_EN_WAKEUP)
+    {
+        pm_wakeup_event(p_LnxWrpFmDev->dev, 200);        
+    }
+#endif
     FM_EventIsr(p_LnxWrpFmDev->h_Dev);
-
     return IRQ_HANDLED;
 }
 
@@ -453,7 +467,6 @@ typedef _Packed struct {
  * information any more, so we assume that there is only one firmware node in
  * the device tree, and that all Fmen use the same firmware.
  */
-
 static const struct qe_firmware *FindFmanMicrocode(void)
 {
     static const struct qe_firmware *P4080_UCPatch;
@@ -476,13 +489,17 @@ static const struct qe_firmware *FindFmanMicrocode(void)
     /* Returning NULL here forces the reuse of the IRAM content */
     return NULL;
 }
-
 #define SVR_SECURITY_MASK    0x00080000
 #define SVR_PERSONALITY_MASK 0x0000FF00
 #define SVR_VER_IGNORE_MASK (SVR_SECURITY_MASK | SVR_PERSONALITY_MASK)
 #define SVR_B4860_REV1_VALUE 0x86800010
 #define SVR_B4860_REV2_VALUE 0x86800020
-
+#define SVR_T4240_VALUE      0x82400000
+#define SVR_T4120_VALUE      0x82400100
+#define SVR_T4160_VALUE      0x82410000
+#define SVR_T4080_VALUE      0x82410200
+#define SVR_T4_DEVICE_ID     0x82400000
+#define SVR_DEVICE_ID_MASK   0xFFF00000
 
 static t_LnxWrpFmDev * ReadFmDevTreeNode (struct platform_device *of_dev)
 {
@@ -497,7 +514,6 @@ static t_LnxWrpFmDev * ReadFmDevTreeNode (struct platform_device *of_dev)
     fm_node = of_node_get(of_dev->dev.of_node);
 
     uint32_prop = (uint32_t *)of_get_property(fm_node, "cell-index", &lenp);
-
     if (unlikely(uint32_prop == NULL)) {
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, cell-index) failed", fm_node->full_name));
         return NULL;
@@ -541,13 +557,12 @@ static t_LnxWrpFmDev * ReadFmDevTreeNode (struct platform_device *of_dev)
         return NULL;
     }
 
+
     p_LnxWrpFmDev->fmBaseAddr = 0;
     p_LnxWrpFmDev->fmPhysBaseAddr = res.start;
     p_LnxWrpFmDev->fmMemSize = res.end + 1 - res.start;
 
     uint32_prop = (uint32_t *)of_get_property(fm_node, "clock-frequency", &lenp);
-
-
     if (unlikely(uint32_prop == NULL)) {
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, clock-frequency) failed", fm_node->full_name));
         return NULL;
@@ -612,8 +627,7 @@ printk("\n DBG: CCCCCCCCCCCCCCC recv clk-feq %d \n",tmp_prop);
             p_LnxWrpFmDev->fmRtcBaseAddr = 0;
             p_LnxWrpFmDev->fmRtcPhysBaseAddr = res.start;
             p_LnxWrpFmDev->fmRtcMemSize = res.end + 1 - res.start;
-
-	}
+        }
     }
 
 #if (DPAA_VERSION >= 11)
@@ -713,8 +727,7 @@ struct device_node *GetFmAdvArgsDevTreeNode (uint8_t fmIndx)
 
     for_each_compatible_node(dev_node, NULL, "fsl,fman-extended-args") {
         uint32_prop = (uint32_t *)of_get_property(dev_node, "cell-index", &lenp);
-
-	if (unlikely(uint32_prop == NULL)) {
+        if (unlikely(uint32_prop == NULL)) {
             REPORT_ERROR(MAJOR, E_INVALID_VALUE,
                          ("of_get_property(%s, cell-index) failed",
                           dev_node->full_name));
@@ -772,9 +785,7 @@ static t_Error CheckNConfigFmAdvArgs (t_LnxWrpFmDev *p_LnxWrpFmDev)
     }
 
     uint32_prop = (uint32_t *)of_get_property(dev_node, "tnum-aging-period",
-        &lenp);
-
-
+	&lenp);
     if (uint32_prop) {
         tmp_prop = be32_to_cpu(uint32_prop[0]/*tnumAgingPeriod*/);
         if (WARN_ON(lenp != sizeof(uint32_t)))
@@ -853,7 +864,6 @@ static t_Error ConfigureFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("request_mem_region() failed"));
 
     p_LnxWrpFmDev->fmBaseAddr = PTR_TO_UINT(devm_ioremap(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->fmPhysBaseAddr, p_LnxWrpFmDev->fmMemSize));
-
     if (unlikely(p_LnxWrpFmDev->fmBaseAddr == 0))
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("devm_ioremap() failed"));
 
@@ -911,6 +921,40 @@ printk("<<>><<< p_LnxWrpFmDev->fmBaseAddr = 0x%llx\n",(u64)p_LnxWrpFmDev->fmBase
     return FillRestFmInfo(p_LnxWrpFmDev);
 }
 
+/*
+ * Table for matching compatible strings, for device tree
+ * guts node, for QorIQ SOCs.
+ * "fsl,qoriq-device-config-2.0" corresponds to T4 & B4
+ * SOCs. For the older SOCs "fsl,qoriq-device-config-1.0"
+ * string would be used.
+*/
+static const struct of_device_id guts_device_ids[] = {
+        { .compatible = "fsl,qoriq-device-config-1.0", },
+        { .compatible = "fsl,qoriq-device-config-2.0", },
+        {}
+};
+#ifndef CONFIG_ARM64
+static unsigned int get_rcwsr(int regnum)
+{
+	struct ccsr_guts __iomem *guts_regs = NULL;
+	struct device_node *guts_node;
+
+	guts_node = of_find_matching_node(NULL, guts_device_ids);
+	if (!guts_node) {
+		pr_err("could not find GUTS node\n");
+		return 0;
+	}
+	guts_regs = of_iomap(guts_node, 0);
+	of_node_put(guts_node);
+	if (!guts_regs) {
+		pr_err("ioremap of GUTS node failed\n");
+		return 0;
+	}
+
+	return ioread32be(&guts_regs->rcwsr[regnum]);
+}
+#endif /* !CONFIG_ARM64 */
+
 static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
 {
     const struct qe_firmware *fw;
@@ -921,7 +965,6 @@ static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
     if ((p_LnxWrpFmDev->h_MuramDev = FM_MURAM_ConfigAndInit(p_LnxWrpFmDev->fmMuramBaseAddr, p_LnxWrpFmDev->fmMuramMemSize)) == NULL)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM-MURAM!"));
 
-
     /* Loading the fman-controller code */
     fw = FindFmanMicrocode();
 
@@ -950,6 +993,26 @@ static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
     }
 #endif
 
+#ifdef CONFIG_ARM64
+    p_LnxWrpFmDev->fmDevSettings.param.fmMacClkRatio = 1;
+#else
+    if(p_LnxWrpFmDev->fmDevSettings.param.fmId == 0)
+        p_LnxWrpFmDev->fmDevSettings.param.fmMacClkRatio =
+            !!(get_rcwsr(4) & 0x2); /* RCW[FM_MAC_RAT0] */
+    else
+        p_LnxWrpFmDev->fmDevSettings.param.fmMacClkRatio =
+            !!(get_rcwsr(4) & 0x1); /* RCW[FM_MAC_RAT1] */
+
+    {   
+    /* T4 Devices ClkRatio is always 1 regardless of RCW[FM_MAC_RAT1] */
+        uint32_t svr;
+        svr = mfspr(SPRN_SVR);
+
+        if ((svr & SVR_DEVICE_ID_MASK) == SVR_T4_DEVICE_ID)
+            p_LnxWrpFmDev->fmDevSettings.param.fmMacClkRatio = 1;
+    }
+#endif /* CONFIG_ARM64 */
+
     if ((p_LnxWrpFmDev->h_Dev = FM_Config(&p_LnxWrpFmDev->fmDevSettings.param)) == NULL)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM"));
 
@@ -1061,12 +1124,9 @@ static int /*__devinit*/ fm_probe(struct platform_device *of_dev)
         return -EIO;
     if (ConfigureFmDev(p_LnxWrpFmDev) != E_OK)
         return -EIO;
-
-
     if (InitFmDev(p_LnxWrpFmDev) != E_OK)
         return -EIO;
 
-
     /* IOCTL ABI checking */
     LnxWrpPCDIOCTLEnumChecking();
     LnxWrpPCDIOCTLTypeChecking();
@@ -1103,6 +1163,10 @@ static int /*__devinit*/ fm_probe(struct platform_device *of_dev)
         return -EIO;
     }
 
+#ifdef CONFIG_PM
+    device_set_wakeup_capable(p_LnxWrpFmDev->dev, true);
+#endif
+
     DBG(TRACE, ("FM%d probed", p_LnxWrpFmDev->id));
 
     return 0;
@@ -1150,38 +1214,52 @@ MODULE_DEVICE_TABLE(of, fm_match);
 #define SCFG_FMCLKDPSLPCR_ADDR 0xFFE0FC00C
 #define SCFG_FMCLKDPSLPCR_DS_VAL 0x48402000
 #define SCFG_FMCLKDPSLPCR_NORMAL_VAL 0x00402000
-void FM_PORT_Dsar_enter_final(void);
-static bool started_ar_enter = false;
+
+struct device *g_fm_dev;
+
 static int fm_soc_suspend(struct device *dev)
 {
-	if (started_ar_enter)
+	int err = 0;
+	uint32_t *fmclk;
+	t_LnxWrpFmDev *p_LnxWrpFmDev = dev_get_drvdata(get_device(dev));
+	g_fm_dev = dev;
+	fmclk = ioremap(SCFG_FMCLKDPSLPCR_ADDR, 4);
+	WRITE_UINT32(*fmclk, SCFG_FMCLKDPSLPCR_DS_VAL);
+	if (p_LnxWrpFmDev->h_DsarRxPort)
 	{
-		uint32_t *fmclk;
 #ifdef CONFIG_FSL_QORIQ_PM
+		device_set_wakeup_enable(p_LnxWrpFmDev->dev, 1);
 		fsl_set_power_except(dev,1);
 #endif
-		FM_PORT_Dsar_enter_final();
-		fmclk = ioremap(SCFG_FMCLKDPSLPCR_ADDR, 4);
-		WRITE_UINT32(*fmclk, SCFG_FMCLKDPSLPCR_DS_VAL);
+		err = FM_PORT_EnterDsarFinal(p_LnxWrpFmDev->h_DsarRxPort,
+			p_LnxWrpFmDev->h_DsarTxPort);
 	}
-	return 0;
+	return err;
 }
 
 static int fm_soc_resume(struct device *dev)
 {
-	if (started_ar_enter)
+	t_LnxWrpFmDev *p_LnxWrpFmDev = dev_get_drvdata(get_device(dev));
+	uint32_t *fmclk;
+	fmclk = ioremap(SCFG_FMCLKDPSLPCR_ADDR, 4);
+	WRITE_UINT32(*fmclk, SCFG_FMCLKDPSLPCR_NORMAL_VAL);
+	if (p_LnxWrpFmDev->h_DsarRxPort)
 	{
-		uint32_t *fmclk;
-		fmclk = ioremap(SCFG_FMCLKDPSLPCR_ADDR, 4);
-		WRITE_UINT32(*fmclk, SCFG_FMCLKDPSLPCR_NORMAL_VAL);
-		started_ar_enter = false;
+#ifdef CONFIG_FSL_QORIQ_PM
+		fsl_set_power_except(dev,0);
+		device_set_wakeup_enable(p_LnxWrpFmDev->dev, 0);
+#endif
+		FM_PORT_ExitDsar(p_LnxWrpFmDev->h_DsarRxPort,
+			p_LnxWrpFmDev->h_DsarTxPort);
+		p_LnxWrpFmDev->h_DsarRxPort = 0;
+		p_LnxWrpFmDev->h_DsarTxPort = 0;
 	}
 	return 0;
 }
 
 static const struct dev_pm_ops fm_pm_ops = {
-	.suspend_noirq = fm_soc_suspend,
-	.resume_noirq = fm_soc_resume,
+	.suspend = fm_soc_suspend,
+	.resume = fm_soc_resume,
 };
 
 #define FM_PM_OPS (&fm_pm_ops)
@@ -1343,7 +1421,7 @@ void fm_port_get_buff_layout_ext_params(struct fm_port *port, struct fm_port_par
 }
 EXPORT_SYMBOL(fm_port_get_buff_layout_ext_params);
 
-int fm_get_tx_port_channel(struct fm_port *port)
+uint16_t fm_get_tx_port_channel(struct fm_port *port)
 {
     t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)port;
 
@@ -1415,14 +1493,15 @@ int fm_port_enter_autores_for_deepsleep(struct fm_port *port,
 	struct auto_res_port_params *params)
 {
 	t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev *)port;
+	t_LnxWrpFmDev* p_LnxWrpFmDev = (t_LnxWrpFmDev*)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
+	p_LnxWrpFmDev->h_DsarRxPort = p_LnxWrpFmPortDev->h_Dev;
+	p_LnxWrpFmDev->h_DsarTxPort = params->h_FmPortTx;
+
 		/*Register other under /proc/autoresponse */
-	if (WARN_ON(sizeof(t_FmPortDsarParams) != sizeof(struct auto_res_port_params)))
+    	if (WARN_ON(sizeof(t_FmPortDsarParams) != sizeof(struct auto_res_port_params)))
             return -EFAULT;
 
 	FM_PORT_EnterDsar(p_LnxWrpFmPortDev->h_Dev, (t_FmPortDsarParams*)params);
-#ifdef CONFIG_PM
-	started_ar_enter = true;
-#endif
 	return 0;
 }
 EXPORT_SYMBOL(fm_port_enter_autores_for_deepsleep);
@@ -1430,9 +1509,6 @@ EXPORT_SYMBOL(fm_port_enter_autores_for_deepsleep);
 void fm_port_exit_auto_res_for_deep_sleep(struct fm_port *port_rx,
 	struct fm_port *port_tx)
 {
-	t_LnxWrpFmPortDev   *p_LnxWrpFmPortDevRx = (t_LnxWrpFmPortDev *)port_rx;
-	t_LnxWrpFmPortDev   *p_LnxWrpFmPortDevTx = (t_LnxWrpFmPortDev *)port_tx;
-	FM_PORT_ExitDsar(p_LnxWrpFmPortDevRx->h_Dev, p_LnxWrpFmPortDevTx->h_Dev);
 }
 EXPORT_SYMBOL(fm_port_exit_auto_res_for_deep_sleep);
 
@@ -1440,7 +1516,7 @@ int fm_port_get_autores_stats(struct fm_port *port,
 	struct auto_res_port_stats *stats)
 {
 	t_LnxWrpFmPortDev *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev *)port;
-	if (WARN_ON(sizeof(t_FmPortDsarStats) != sizeof(struct auto_res_port_stats)))
+    	if (WARN_ON(sizeof(t_FmPortDsarStats) != sizeof(struct auto_res_port_stats)))
             return -EFAULT;
 	return FM_PORT_GetDsarStats(p_LnxWrpFmPortDev->h_Dev, (t_FmPortDsarStats*)stats);
 }
@@ -2022,6 +2098,665 @@ void fm_mutex_unlock(void)
 }
 EXPORT_SYMBOL(fm_mutex_unlock);
 
+/*Macsec wrapper functions*/
+struct fm_macsec_dev *fm_macsec_config(struct fm_macsec_params *fm_params)
+{
+	struct fm_macsec_dev *fm_macsec_dev;
+
+	fm_macsec_dev = FM_MACSEC_Config((t_FmMacsecParams *)fm_params);
+	if (unlikely(fm_macsec_dev == NULL))
+		pr_err("FM_MACSEC_Config() failed\n");
+
+	return fm_macsec_dev;
+}
+EXPORT_SYMBOL(fm_macsec_config);
+
+int fm_macsec_init(struct fm_macsec_dev *fm_macsec_dev)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_Init(fm_macsec_dev);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_Init() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_init);
+
+int fm_macsec_free(struct fm_macsec_dev *fm_macsec_dev)
+{
+	int err;
+	int _error;
+
+	err = FM_MACSEC_Free(fm_macsec_dev);
+	_error = -GET_ERROR_TYPE(err);
+
+	if (unlikely(_error < 0))
+		pr_err("FM_MACSEC_Free() = 0x%08x\n", err);
+
+	return _error;
+}
+EXPORT_SYMBOL(fm_macsec_free);
+
+int fm_macsec_config_unknown_sci_frame_treatment(struct fm_macsec_dev
+				*fm_macsec_dev,
+				fm_macsec_unknown_sci_frame_treatment treat_mode)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_ConfigUnknownSciFrameTreatment(fm_macsec_dev,
+		treat_mode);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_ConfigUnknownSciFrameTreatmen() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_config_unknown_sci_frame_treatment);
+
+int fm_macsec_config_invalid_tags_frame_treatment(struct fm_macsec_dev *fm_macsec_dev,
+				bool deliver_uncontrolled)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_ConfigInvalidTagsFrameTreatment(fm_macsec_dev,
+						deliver_uncontrolled);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MAC_ConfigMaxFrameLength() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_config_invalid_tags_frame_treatment);
+
+int fm_macsec_config_kay_frame_treatment(struct fm_macsec_dev *fm_macsec_dev,
+				bool discard_uncontrolled)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_ConfigEncryptWithNoChangedTextFrameTreatment(fm_macsec_dev,
+						discard_uncontrolled);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_ConfigEncryptWithNoChangedTextFrameTreatmen() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_config_kay_frame_treatment);
+
+int fm_macsec_config_untag_frame_treatment(struct fm_macsec_dev *fm_macsec_dev,
+				    fm_macsec_untag_frame_treatment treat_mode)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_ConfigUntagFrameTreatment(fm_macsec_dev, treat_mode);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_ConfigUntagFrameTreatment() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_config_untag_frame_treatment);
+
+int fm_macsec_config_pn_exhaustion_threshold(struct fm_macsec_dev *fm_macsec_dev,
+					uint32_t pn_exh_thr)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_ConfigPnExhaustionThreshold(fm_macsec_dev, pn_exh_thr);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_ConfigPnExhaustionThreshold() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_config_pn_exhaustion_threshold);
+
+int fm_macsec_config_keys_unreadable(struct fm_macsec_dev *fm_macsec_dev)
+{
+	int err;
+	int _errno;
+
+	err =  FM_MACSEC_ConfigKeysUnreadable(fm_macsec_dev);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_ConfigKeysUnreadable() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_config_keys_unreadable);
+
+int fm_macsec_config_sectag_without_sci(struct fm_macsec_dev *fm_macsec_dev)
+{
+	int err;
+	int _errno;
+
+	err =  FM_MACSEC_ConfigSectagWithoutSCI(fm_macsec_dev);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_ConfigSectagWithoutSCI() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_config_sectag_without_sci);
+
+int fm_macsec_config_exception(struct fm_macsec_dev *fm_macsec_dev,
+			    fm_macsec_exception exception, bool enable)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_ConfigException(fm_macsec_dev, exception, enable);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_ConfigException() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_config_exception);
+
+int fm_macsec_get_revision(struct fm_macsec_dev *fm_macsec_dev,
+			    int *macsec_revision)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_GetRevision(fm_macsec_dev, macsec_revision);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_GetRevision() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_get_revision);
+
+int fm_macsec_enable(struct fm_macsec_dev *fm_macsec_dev)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_Enable(fm_macsec_dev);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_Enable() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_enable);
+
+int fm_macsec_disable(struct fm_macsec_dev *fm_macsec_dev)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_Disable(fm_macsec_dev);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_Disable() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_disable);
+
+int fm_macsec_set_exception(struct fm_macsec_dev *fm_macsec_dev,
+			fm_macsec_exception exception, bool enable)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SetException(fm_macsec_dev, exception, enable);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SetException() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_set_exception);
+
+/* Macsec SECY wrapper API */
+struct fm_macsec_secy_dev *fm_macsec_secy_config(struct fm_macsec_secy_params *secy_params)
+{
+	struct fm_macsec_secy_dev *fm_macsec_secy;
+
+	fm_macsec_secy = FM_MACSEC_SECY_Config((t_FmMacsecSecYParams *)secy_params);
+	if (unlikely(fm_macsec_secy < 0))
+		pr_err("FM_MACSEC_SECY_Config() failed\n");
+
+	return fm_macsec_secy;
+}
+EXPORT_SYMBOL(fm_macsec_secy_config);
+
+int fm_macsec_secy_init(struct fm_macsec_secy_dev *fm_macsec_secy_dev)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_Init(fm_macsec_secy_dev);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_Init() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_init);
+
+int fm_macsec_secy_free(struct fm_macsec_secy_dev *fm_macsec_secy_dev)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_Free(fm_macsec_secy_dev);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_Free() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_free);
+
+int fm_macsec_secy_config_sci_insertion_mode(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				fm_macsec_sci_insertion_mode sci_insertion_mode)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_ConfigSciInsertionMode(fm_macsec_secy_dev,
+					sci_insertion_mode);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_ConfigSciInsertionMode() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_config_sci_insertion_mode);
+
+int fm_macsec_secy_config_protect_frames(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				bool protect_frames)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_ConfigProtectFrames(fm_macsec_secy_dev,
+						protect_frames);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_ConfigProtectFrames() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_config_protect_frames);
+
+int fm_macsec_secy_config_replay_window(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				bool replay_protect, uint32_t replay_window)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_ConfigReplayWindow(fm_macsec_secy_dev,
+						replay_protect, replay_window);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_ConfigReplayWindow() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_config_replay_window);
+
+int fm_macsec_secy_config_validation_mode(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				fm_macsec_valid_frame_behavior validate_frames)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_ConfigValidationMode(fm_macsec_secy_dev,
+						    validate_frames);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_ConfigValidationMode() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_config_validation_mode);
+
+int fm_macsec_secy_config_confidentiality(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				bool confidentiality_enable,
+				uint32_t confidentiality_offset)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_ConfigConfidentiality(fm_macsec_secy_dev,
+						    confidentiality_enable,
+						    confidentiality_offset);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_ConfigConfidentiality() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_config_confidentiality);
+
+int fm_macsec_secy_config_point_to_point(struct fm_macsec_secy_dev *fm_macsec_secy_dev)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_ConfigPointToPoint(fm_macsec_secy_dev);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_ConfigPointToPoint() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_config_point_to_point);
+
+int fm_macsec_secy_config_exception(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				    fm_macsec_secy_exception exception,
+				    bool enable)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_ConfigException(fm_macsec_secy_dev, exception,
+					    enable);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_ConfigException() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_config_exception);
+
+int fm_macsec_secy_config_event(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				    fm_macsec_secy_event event,
+				    bool enable)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_ConfigEvent(fm_macsec_secy_dev, event, enable);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_ConfigEvent() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_config_event);
+
+struct rx_sc_dev *fm_macsec_secy_create_rxsc(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				struct fm_macsec_secy_sc_params  *params)
+{
+	struct rx_sc_dev *rx_sc_dev;
+
+	rx_sc_dev = FM_MACSEC_SECY_CreateRxSc(fm_macsec_secy_dev, (t_FmMacsecSecYSCParams *)params);
+	if (unlikely(rx_sc_dev == NULL))
+		pr_err("FM_MACSEC_SECY_CreateRxSc() failed\n");
+
+	return rx_sc_dev;
+}
+EXPORT_SYMBOL(fm_macsec_secy_create_rxsc);
+
+int fm_macsec_secy_delete_rxsc(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				struct rx_sc_dev *sc)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_DeleteRxSc(fm_macsec_secy_dev, sc);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_DeleteRxSc() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_delete_rxsc);
+
+int fm_macsec_secy_create_rx_sa(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				struct rx_sc_dev *sc, macsec_an_t an,
+				uint32_t lowest_pn, macsec_sa_key_t key)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_CreateRxSa(fm_macsec_secy_dev, sc, an,
+					lowest_pn, key);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_CreateRxSa() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_create_rx_sa);
+
+int fm_macsec_secy_delete_rx_sa(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				struct rx_sc_dev *sc, macsec_an_t an)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_DeleteRxSa(fm_macsec_secy_dev, sc, an);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_DeleteRxSa() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_delete_rx_sa);
+
+int fm_macsec_secy_rxsa_enable_receive(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					struct rx_sc_dev *sc,
+					macsec_an_t an)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_RxSaEnableReceive(fm_macsec_secy_dev, sc, an);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_RxSaEnableReceive() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_rxsa_enable_receive);
+
+int fm_macsec_secy_rxsa_disable_receive(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					struct rx_sc_dev *sc,
+					macsec_an_t an)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_RxSaDisableReceive(fm_macsec_secy_dev, sc, an);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_RxSaDisableReceive() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_rxsa_disable_receive);
+
+int fm_macsec_secy_rxsa_update_next_pn(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					struct rx_sc_dev *sc,
+					macsec_an_t an, uint32_t updt_next_pn)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_RxSaUpdateNextPn(fm_macsec_secy_dev, sc, an,
+						updt_next_pn);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_RxSaUpdateNextPn() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_rxsa_update_next_pn);
+
+int fm_macsec_secy_rxsa_update_lowest_pn(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					struct rx_sc_dev *sc,
+					macsec_an_t an, uint32_t updt_lowest_pn)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_RxSaUpdateLowestPn(fm_macsec_secy_dev, sc, an,
+						updt_lowest_pn);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_RxSaUpdateLowestPn() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_rxsa_update_lowest_pn);
+
+int fm_macsec_secy_rxsa_modify_key(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					struct rx_sc_dev *sc,
+					macsec_an_t an, macsec_sa_key_t key)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_RxSaModifyKey(fm_macsec_secy_dev, sc, an, key);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_RxSaModifyKey() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_rxsa_modify_key);
+
+int fm_macsec_secy_create_tx_sa(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				macsec_an_t an, macsec_sa_key_t key)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_CreateTxSa(fm_macsec_secy_dev, an, key);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_CreateTxSa() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_create_tx_sa);
+
+int fm_macsec_secy_delete_tx_sa(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				macsec_an_t an)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_DeleteTxSa(fm_macsec_secy_dev, an);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_DeleteTxSa() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_delete_tx_sa);
+
+int fm_macsec_secy_txsa_modify_key(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					macsec_an_t next_active_an,
+					macsec_sa_key_t key)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_TxSaModifyKey(fm_macsec_secy_dev, next_active_an,
+					    key);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_TxSaModifyKey() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_txsa_modify_key);
+
+int fm_macsec_secy_txsa_set_active(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					macsec_an_t an)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_TxSaSetActive(fm_macsec_secy_dev, an);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_TxSaSetActive() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_txsa_set_active);
+
+int fm_macsec_secy_txsa_get_active(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					macsec_an_t *p_an)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_TxSaGetActive(fm_macsec_secy_dev, p_an);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_TxSaGetActive() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_txsa_get_active);
+
+int fm_macsec_secy_get_rxsc_phys_id(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				struct rx_sc_dev *sc, uint32_t *sc_phys_id)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_GetRxScPhysId(fm_macsec_secy_dev, sc, sc_phys_id);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_GetRxScPhysId() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_get_rxsc_phys_id);
+
+int fm_macsec_secy_get_txsc_phys_id(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				    uint32_t *sc_phys_id)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_GetTxScPhysId(fm_macsec_secy_dev, sc_phys_id);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_GetTxScPhysId() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_get_txsc_phys_id);
+
 static t_Handle h_FmLnxWrp;
 
 static int __init __cold fm_load (void)
@@ -2031,7 +2766,13 @@ static int __init __cold fm_load (void)
         printk("Failed to init FM wrapper!\n");
         return -ENODEV;
     }
-	return 0;
+
+	printk(KERN_CRIT "Freescale FM module ("__DATE__ ":"__TIME__")," \
+		" FMD API version %d.%d.%d\n",
+		FMD_API_VERSION_MAJOR,
+		FMD_API_VERSION_MINOR,
+		FMD_API_VERSION_RESPIN);
+    return 0;
 }
 
 static void __exit __cold fm_unload (void)
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.h b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.h
index 4a83110..05202a2 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.h
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.h
@@ -217,6 +217,9 @@ typedef struct {
     t_Handle                    h_PcdDev;
     t_Handle                    h_RtcDev;
 
+    t_Handle			h_DsarRxPort;
+    t_Handle			h_DsarTxPort;
+
     t_LnxWrpFmPortDev           hcPort;
     t_LnxWrpFmPortDev           opPorts[FM_MAX_NUM_OF_OH_PORTS-1];
     t_LnxWrpFmPortDev           rxPorts[FM_MAX_NUM_OF_RX_PORTS];
@@ -287,52 +290,4 @@ static __inline__ t_Error AllocSchemesForPort(t_LnxWrpFmDev *p_LnxWrpFmDev, uint
 void LnxWrpPCDIOCTLTypeChecking(void);
 void LnxWrpPCDIOCTLEnumChecking(void);
 
-/* Structure that defines QE firmware binary files.
- *
- * See Documentation/powerpc/qe_firmware.txt for a description of these
- * fields.
- */
-struct qe_firmware {
-        struct qe_header {
-                __be32 length;  /* Length of the entire structure, in bytes */
-                u8 magic[3];    /* Set to { 'Q', 'E', 'F' } */
-                u8 version;     /* Version of this layout. First ver is '1' */
-        } header;
-        u8 id[62];      /* Null-terminated identifier string */
-        u8 split;       /* 0 = shared I-RAM, 1 = split I-RAM */
-        u8 count;       /* Number of microcode[] structures */
-        struct {
-                __be16 model;           /* The SOC model  */
-                u8 major;               /* The SOC revision major */
-                u8 minor;               /* The SOC revision minor */
-        } __attribute__ ((packed)) soc;
-        u8 padding[4];                  /* Reserved, for alignment */
-        __be64 extended_modes;          /* Extended modes */
-        __be32 vtraps[8];               /* Virtual trap addresses */
-        u8 reserved[4];                 /* Reserved, for future expansion */
-        struct qe_microcode {
-                u8 id[32];              /* Null-terminated identifier */
-                __be32 traps[16];       /* Trap addresses, 0 == ignore */
-                __be32 eccr;            /* The value for the ECCR register */
-                __be32 iram_offset;     /* Offset into I-RAM for the code */
-                __be32 count;           /* Number of 32-bit words of the code */
-                __be32 code_offset;     /* Offset of the actual microcode */
-                u8 major;               /* The microcode version major */
-                u8 minor;               /* The microcode version minor */
-                u8 revision;            /* The microcode version revision */
-                u8 padding;             /* Reserved, for alignment */
-                u8 reserved[4];         /* Reserved, for future expansion */
-        } __attribute__ ((packed)) microcode[1];
-        /* All microcode binaries should be located here */
-        /* CRC32 should be located here, after the microcode binaries */
-} __attribute__ ((packed));
-
-struct qe_firmware_info {
-        char id[64];            /* Firmware name */
-        u32 vtraps[8];          /* Virtual trap addresses */
-        u64 extended_modes;     /* Extended modes */
-};
-
-
-
 #endif /* __LNXWRP_FM_H__ */
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c
index e1a0074..5ebe427 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c
@@ -51,7 +51,13 @@
 #include <linux/cdev.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
+#ifndef CONFIG_ARM64
+#include <asm/mpc85xx.h>
+#endif /* !CONFIG_ARM64 */
+#ifdef CONFIG_ARM64
 #include <linux/io.h>
+#endif /* CONFIG_ARM64 */
+
 
 #include "sprint_ext.h"
 #include "fm_common.h"
@@ -82,6 +88,12 @@ do {\
 	} \
 } while (0)
 
+#ifndef CONFIG_ARM64
+#define IS_T1023_T1024	(SVR_SOC_VER(mfspr(SPRN_SVR)) == SVR_T1024 || \
+			SVR_SOC_VER(mfspr(SPRN_SVR)) == SVR_T1023)
+#else
+#define IS_T1023_T1024 0
+#endif /* !CONFIG_ARM64 */
 
 static volatile int hcFrmRcv/* = 0 */;
 static spinlock_t lock;
@@ -205,6 +217,7 @@ static struct qman_fq *FqAlloc(t_LnxWrpFmDev * p_LnxWrpFmDev,
 static void FqFree(struct qman_fq *fq)
 {
 	int _errno;
+
 	_errno = qman_retire_fq(fq, NULL);
 	if (unlikely(_errno < 0))
 		printk(KERN_WARNING "qman_retire_fq(%u) = %d\n", qman_fq_fqid(fq), _errno);
@@ -309,7 +322,6 @@ static t_LnxWrpFmPortDev *ReadFmPortDevTreeNode(struct platform_device
 
 	uint32_prop =
 		(uint32_t *) of_get_property(port_node, "cell-index", &lenp);
-
 	if (unlikely(uint32_prop == NULL)) {
 		REPORT_ERROR(MAJOR, E_INVALID_VALUE,
 			     ("of_get_property(%s, cell-index) failed",
@@ -391,7 +403,6 @@ static t_LnxWrpFmPortDev *ReadFmPortDevTreeNode(struct platform_device
 
 		uint32_prop = (uint32_t *) of_get_property(port_node,
 				"fsl,qman-channel-id", &lenp);
-
 		if (uint32_prop == NULL) {
 			REPORT_ERROR(MAJOR, E_INVALID_VALUE,
 					("missing fsl,qman-channel-id"));
@@ -413,16 +424,16 @@ static t_LnxWrpFmPortDev *ReadFmPortDevTreeNode(struct platform_device
 		}
 		p_LnxWrpFmPortDev = &p_LnxWrpFmDev->txPorts[tmp_prop +
 			FM_MAX_NUM_OF_1G_TX_PORTS];
+		if (IS_T1023_T1024)
+			p_LnxWrpFmPortDev = &p_LnxWrpFmDev->txPorts[*uint32_prop];
 
 		p_LnxWrpFmPortDev->id = tmp_prop;
 		p_LnxWrpFmPortDev->settings.param.portId =
 			p_LnxWrpFmPortDev->id;
 		p_LnxWrpFmPortDev->settings.param.portType =
 			e_FM_PORT_TYPE_TX_10G;
-
 		uint32_prop = (uint32_t *) of_get_property(port_node,
 				"fsl,qman-channel-id", &lenp);
-
 		if (uint32_prop == NULL) {
 			REPORT_ERROR(MAJOR, E_INVALID_VALUE,
 					("missing fsl,qman-channel-id"));
@@ -459,6 +470,9 @@ static t_LnxWrpFmPortDev *ReadFmPortDevTreeNode(struct platform_device
 		p_LnxWrpFmPortDev = &p_LnxWrpFmDev->rxPorts[tmp_prop +
 			FM_MAX_NUM_OF_1G_RX_PORTS];
 
+		if (IS_T1023_T1024)
+			p_LnxWrpFmPortDev = &p_LnxWrpFmDev->rxPorts[*uint32_prop];
+		
 		p_LnxWrpFmPortDev->id = tmp_prop;
 		p_LnxWrpFmPortDev->settings.param.portId =
 			p_LnxWrpFmPortDev->id;
@@ -531,7 +545,6 @@ struct device_node * GetFmPortAdvArgsDevTreeNode (struct device_node *fm_node,
 
     for_each_child_of_node(fm_node, port_node) {
         uint32_prop = (uint32_t *)of_get_property(port_node, "cell-index", &lenp);
-
         if (unlikely(uint32_prop == NULL)) {
             REPORT_ERROR(MAJOR, E_INVALID_VALUE,
                          ("of_get_property(%s, cell-index) failed",
@@ -544,7 +557,7 @@ struct device_node * GetFmPortAdvArgsDevTreeNode (struct device_node *fm_node,
 	if ((portId == tmp_prop) &&
 	    (of_device_is_compatible(port_node, portTypeString))) {
             return port_node;
-	}
+    	}
     }
 
     return NULL;
@@ -558,7 +571,6 @@ static t_Error CheckNConfigFmPortAdvArgs (t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
     const uint32_t          *uint32_prop;
     /*const char              *str_prop;*/
     int                     lenp;
-
 #ifdef CONFIG_FMAN_PFC
     uint8_t i, id, num_pools;
     t_FmBufPoolDepletion poolDepletion;
@@ -596,7 +608,6 @@ static t_Error CheckNConfigFmPortAdvArgs (t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
         return E_OK;
 
     uint32_prop = (uint32_t *)of_get_property(port_node, "num-tnums", &lenp);
-
     if (uint32_prop) {
 	if (WARN_ON(lenp != sizeof(uint32_t)*2))
             RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
@@ -752,9 +763,11 @@ static t_Error CheckNSetFmPortAdvArgs (t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
         if (p_LnxWrpFmPortDev->settings.param.portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         {
             portId = fmVspParams.portParams.portId;
-            if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX_10G)
-                portId += FM_MAX_NUM_OF_1G_RX_PORTS;
-            portVSPAllocParams.h_FmTxPort =
+            if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX_10G){
+		if (!(IS_T1023_T1024))
+                    portId += FM_MAX_NUM_OF_1G_RX_PORTS;
+	    }
+	    portVSPAllocParams.h_FmTxPort =
                 p_LnxWrpFmDev->txPorts[portId].h_Dev;
             fmVspParams.liodnOffset =
                 p_LnxWrpFmDev->rxPorts[portId].settings.param.specificParams.rxParams.liodnOffset;
@@ -818,7 +831,7 @@ static t_Error ConfigureFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 		RETURN_ERROR(MAJOR, E_INVALID_STATE,
 			     ("__devm_request_region() failed"));
 	p_LnxWrpFmPortDev->baseAddr =
-		PTR_TO_UINT (devm_ioremap
+		PTR_TO_UINT(devm_ioremap
 			    (p_LnxWrpFmDev->dev,
 			     p_LnxWrpFmPortDev->phys_baseAddr,
 			     p_LnxWrpFmPortDev->memSize));
@@ -871,7 +884,7 @@ static t_Error InitFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 	}
 #endif  /* !FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
 
-#if 0
+#ifndef CONFIG_ARM64
 #ifdef FM_BCB_ERRATA_BMI_SW001
 /* Configure BCB workaround on Rx ports, only for B4860 rev1 */
 #define SVR_SECURITY_MASK    0x00080000
@@ -891,7 +904,7 @@ static t_Error InitFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 			FM_PORT_ConfigBCBWorkaround(p_LnxWrpFmPortDev->h_Dev);
 	}
 #endif /* FM_BCB_ERRATA_BMI_SW001 */
-#endif /* 0 */
+#endif /* !CONFIG_ARM64 */
 
 /* Call the driver's advanced configuration routines, if requested:
    Compare the function pointer of each entry to the available routines,
@@ -936,14 +949,12 @@ static t_Error InitFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
     if (CheckNConfigFmPortAdvArgs(p_LnxWrpFmPortDev) != E_OK)
 		RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
-
     if (FM_PORT_Init(p_LnxWrpFmPortDev->h_Dev) != E_OK)
 		RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
     if (CheckNSetFmPortAdvArgs(p_LnxWrpFmPortDev) != E_OK)
 		RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
-
 /* FMan Fifo sizes behind the scene":
  * Using the following formulae (*), under a set of simplifying assumptions (.):
  *  . all ports are configured in Normal Mode (rather than Independent Mode)
@@ -1170,13 +1181,11 @@ static t_Error InitFmPcdDev(t_LnxWrpFmDev *p_LnxWrpFmDev)
 #endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 		fmPcdParams.useHostCommand = TRUE;
 
-
 		p_LnxWrpFmDev->hc_tx_fq =
-		FqAlloc(p_LnxWrpFmDev,
+			FqAlloc(p_LnxWrpFmDev,
 				0,
 				QMAN_FQ_FLAG_TO_DCPORTAL,
 				p_LnxWrpFmPortDev->txCh, 0);
-
 		if (!p_LnxWrpFmDev->hc_tx_fq)
 			RETURN_ERROR(MAJOR, E_NULL_POINTER,
 				     ("Frame queue allocation failed..."));
@@ -1186,17 +1195,15 @@ static t_Error InitFmPcdDev(t_LnxWrpFmDev *p_LnxWrpFmDev)
 				0,
 				QMAN_FQ_FLAG_NO_ENQUEUE,
 				p_LnxWrpFmDev->hcCh, 7);
-
 		if (!p_LnxWrpFmDev->hc_tx_conf_fq)
 			RETURN_ERROR(MAJOR, E_NULL_POINTER,
 				     ("Frame queue allocation failed..."));
 
-		p_LnxWrpFmDev->hc_tx_err_fq = 
+		p_LnxWrpFmDev->hc_tx_err_fq =
 			FqAlloc(p_LnxWrpFmDev,
 				0,
 				QMAN_FQ_FLAG_NO_ENQUEUE,
 				p_LnxWrpFmDev->hcCh, 7);
-		
 		if (!p_LnxWrpFmDev->hc_tx_err_fq)
 			RETURN_ERROR(MAJOR, E_NULL_POINTER,
 				     ("Frame queue allocation failed..."));
@@ -1204,20 +1211,17 @@ static t_Error InitFmPcdDev(t_LnxWrpFmDev *p_LnxWrpFmDev)
 		fmPcdParams.hc.portBaseAddr = p_LnxWrpFmPortDev->baseAddr;
 		fmPcdParams.hc.portId =
 			p_LnxWrpFmPortDev->settings.param.portId;
-
-		fmPcdParams.hc.qmChannel = p_LnxWrpFmPortDev->txCh;
 		fmPcdParams.hc.liodnBase =
 			p_LnxWrpFmPortDev->settings.param.liodnBase;
-
 		fmPcdParams.hc.errFqid =
 			qman_fq_fqid(p_LnxWrpFmDev->hc_tx_err_fq);
 		fmPcdParams.hc.confFqid =
 			qman_fq_fqid(p_LnxWrpFmDev->hc_tx_conf_fq);
+		fmPcdParams.hc.qmChannel = p_LnxWrpFmPortDev->txCh;
 		fmPcdParams.hc.f_QmEnqueue = QmEnqueueCB;
 		fmPcdParams.hc.h_QmArg = (t_Handle) p_LnxWrpFmDev;
 
 		p_LnxWrpFmDev->h_PcdDev = FM_PCD_Config(&fmPcdParams);
-
 		if (!p_LnxWrpFmDev->h_PcdDev)
 			RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM PCD!"));
 
@@ -1311,12 +1315,12 @@ static int /*__devinit*/ fm_port_probe(struct platform_device *of_dev)
 	   - in performance mode, OH ports are disabled
 	   ...
 	 */
-
 	if (!p_LnxWrpFmPortDev->active)
 		return 0;
 
 	if (ConfigureFmPortDev(p_LnxWrpFmPortDev) != E_OK)
 		return -EIO;
+
 	dev_set_drvdata(dev, p_LnxWrpFmPortDev);
 
 	if (p_LnxWrpFmPortDev->settings.param.portType ==
@@ -1325,7 +1329,6 @@ static int /*__devinit*/ fm_port_probe(struct platform_device *of_dev)
 
 	p_LnxWrpFmDev = (t_LnxWrpFmDev *) p_LnxWrpFmPortDev->h_LnxWrpFmDev;
 
-
 	if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX) {
 		Sprint(p_LnxWrpFmPortDev->name, "%s-port-rx%d",
 		       p_LnxWrpFmDev->name, p_LnxWrpFmPortDev->id);
@@ -1339,6 +1342,14 @@ static int /*__devinit*/ fm_port_probe(struct platform_device *of_dev)
 		p_LnxWrpFmPortDev->minor =
 			p_LnxWrpFmPortDev->id + FM_MAX_NUM_OF_1G_RX_PORTS +
 			DEV_FM_RX_PORTS_MINOR_BASE;
+		if (IS_T1023_T1024) {
+			Sprint(p_LnxWrpFmPortDev->name, "%s-port-rx%d",
+				p_LnxWrpFmDev->name,
+				p_LnxWrpFmPortDev->id);
+			p_LnxWrpFmPortDev->minor =
+				p_LnxWrpFmPortDev->id +
+				DEV_FM_RX_PORTS_MINOR_BASE;
+		}
 	} else if (p_LnxWrpFmPortDev->settings.param.portType ==
 		 e_FM_PORT_TYPE_TX) {
 		Sprint(p_LnxWrpFmPortDev->name, "%s-port-tx%d",
@@ -1353,6 +1364,14 @@ static int /*__devinit*/ fm_port_probe(struct platform_device *of_dev)
 		p_LnxWrpFmPortDev->minor =
 			p_LnxWrpFmPortDev->id + FM_MAX_NUM_OF_1G_TX_PORTS +
 			DEV_FM_TX_PORTS_MINOR_BASE;
+		if (IS_T1023_T1024) {
+			Sprint(p_LnxWrpFmPortDev->name, "%s-port-tx%d",
+				p_LnxWrpFmDev->name,
+				p_LnxWrpFmPortDev->id);
+			p_LnxWrpFmPortDev->minor =
+				p_LnxWrpFmPortDev->id +
+				DEV_FM_TX_PORTS_MINOR_BASE;
+		}
 	} else if (p_LnxWrpFmPortDev->settings.param.portType ==
 		 e_FM_PORT_TYPE_OH_HOST_COMMAND) {
 		Sprint(p_LnxWrpFmPortDev->name, "%s-port-oh%d",
@@ -1445,10 +1464,8 @@ static struct platform_driver fm_port_driver = {
 t_Error LNXWRP_FM_Port_Init(void)
 {
 	/* Register to the DTB for basic FM port API */
-	if (platform_driver_register(&fm_port_driver)){
-
-	    return E_NO_DEVICE;
-	}
+	if (platform_driver_register(&fm_port_driver))
+		return E_NO_DEVICE;
 
 	return E_OK;
 }
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
index 3cb53ac..a6c01f3 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
@@ -59,7 +59,11 @@
 #include <linux/of_platform.h>
 #include <asm/uaccess.h>
 #include <asm/errno.h>
-//#include <sysdev/fsl_soc.h>
+
+#ifndef CONFIG_ARM64
+#include <sysdev/fsl_soc.h>
+#include <asm/mpc85xx.h>
+#endif /* !CONFIG_ARM64 */
 
 #if defined(CONFIG_COMPAT)
 #include <linux/compat.h>
@@ -71,6 +75,14 @@
 #include "fm_port_ioctls.h"
 #include "fm_vsp_ext.h"
 
+#ifndef CONFIG_ARM64
+#define IS_T1023_T1024	(SVR_SOC_VER(mfspr(SPRN_SVR)) == SVR_T1024 || \
+			SVR_SOC_VER(mfspr(SPRN_SVR)) == SVR_T1023)
+#else
+#define IS_T1023_T1024 0
+#endif /* !CONFIG_ARM64 */
+
+
 #define __ERR_MODULE__  MODULE_FM
 
 #if defined(CONFIG_COMPAT)
@@ -323,6 +335,20 @@ void LnxWrpPCDIOCTLTypeChecking(void)
     /* fm_pcd_ext.h == fm_pcd_ioctls.h */
     /*ioc_fm_pcd_counters_params_t  : NOT USED */
     /*ioc_fm_pcd_exception_params_t : private */
+#if (DPAA_VERSION >= 11)
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_frag_capwap_params_t) == sizeof(t_FmPcdManipFragCapwapParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_reassem_capwap_params_t) == sizeof(t_FmPcdManipReassemCapwapParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_hdr_insrt_by_hdr_params_t) == sizeof(t_FmPcdManipHdrInsrtByHdrParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_hdr_insrt_ip_params_t) == sizeof(t_FmPcdManipHdrInsrtIpParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_hdr_insrt_t) == sizeof(t_FmPcdManipHdrInsrt));
+    ASSERT_COND(sizeof(ioc_fm_manip_hdr_info_t) == sizeof(t_FmManipHdrInfo));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_hdr_rmv_by_hdr_params_t) == sizeof(t_FmPcdManipHdrRmvByHdrParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_special_offload_capwap_params_t) == sizeof(t_FmPcdManipSpecialOffloadCapwapParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_frag_capwap_stats_t) == sizeof(t_FmPcdManipFragCapwapStats));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_reassem_capwap_stats_t) == sizeof(t_FmPcdManipReassemCapwapStats));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_frag_params_t) == sizeof(t_FmPcdManipFragParams));
+#endif /* (DPAA_VERSION >= 11) */
+
     ASSERT_COND(sizeof(ioc_fm_pcd_prs_label_params_t) == sizeof(t_FmPcdPrsLabelParams));
     ASSERT_COND(sizeof(ioc_fm_pcd_prs_sw_params_t) == sizeof(t_FmPcdPrsSwParams));
     /*ioc_fm_pcd_kg_dflt_value_params_t : private */
@@ -332,7 +358,7 @@ void LnxWrpPCDIOCTLTypeChecking(void)
     ASSERT_COND(sizeof(ioc_fm_pcd_from_field_t) == sizeof(t_FmPcdFromField));
     ASSERT_COND(sizeof(ioc_fm_pcd_distinction_unit_t) == sizeof(t_FmPcdDistinctionUnit));
 
-#if defined(CONFIG_FMAN_LS1043)
+#if defined(CONFIG_ARM64)
     /* different alignment */
     ASSERT_COND(sizeof(ioc_fm_pcd_net_env_params_t) == sizeof(t_FmPcdNetEnvParams) + sizeof(void *) + 4);
 #else
@@ -386,8 +412,6 @@ void LnxWrpPCDIOCTLTypeChecking(void)
     ASSERT_COND(sizeof(TODO) == sizeof(t_FmPcdManipHdrInsrtByTemplateParams));
     ASSERT_COND(sizeof(TODO) == sizeof(t_CapwapFragmentationParams));
     ASSERT_COND(sizeof(TODO) == sizeof(t_CapwapReassemblyParams));
-    ASSERT_COND(sizeof(TODO) == sizeof(t_FmPcdManipFragOrReasmParams));
-    ASSERT_COND(sizeof(TODO) == sizeof(t_FmPcdManipHdrRmvByHdrParams));
 */
 #endif
 
@@ -1438,12 +1462,16 @@ Status: feature not supported
 
                     case (e_IOC_FM_PORT_TYPE_RX_10G):
                         if (port_params->port_id < FM_MAX_NUM_OF_10G_RX_PORTS) {
-                            h_Port = p_LnxWrpFmDev->rxPorts[port_params->port_id + FM_MAX_NUM_OF_1G_RX_PORTS].h_Dev;
+                            if (IS_T1023_T1024) {
+                                h_Port = p_LnxWrpFmDev->rxPorts[port_params->port_id].h_Dev;
+                            } else {
+                                h_Port = p_LnxWrpFmDev->rxPorts[port_params->port_id + FM_MAX_NUM_OF_1G_RX_PORTS].h_Dev;
+                            }
                             break;
                         }
                         goto invalid_port_id;
 
-                    case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+                    case (e_IOC_FM_PORT_TYPE_OH_OFFLINE_PARSING):
                         if (port_params->port_id && port_params->port_id < FM_MAX_NUM_OF_OH_PORTS) {
                             h_Port = p_LnxWrpFmDev->opPorts[port_params->port_id - 1].h_Dev;
                             break;
@@ -1941,6 +1969,82 @@ invalid_port_id:
             XX_Free(param);
             break;
         }
+        
+        
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_MATCH_TABLE_GET_KEY_STAT_COMPAT:
+#endif
+        case FM_PCD_IOC_MATCH_TABLE_GET_KEY_STAT:
+        {
+            ioc_fm_pcd_cc_tbl_get_stats_t param;
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_cc_tbl_get_stats_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_cc_tbl_get_stats_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_cc_tbl_get_stats_t));
+                if (!compat_param)
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_tbl_get_stats_t));
+                if (copy_from_user(compat_param,
+                            (ioc_compat_fm_pcd_cc_tbl_get_stats_t *)compat_ptr(arg),
+                            sizeof(ioc_compat_fm_pcd_cc_tbl_get_stats_t)))
+                {
+                    XX_Free(compat_param);
+                    RETURN_ERROR(MINOR, E_WRITE_FAILED, NO_MSG);
+                }
+
+                compat_copy_fm_pcd_cc_tbl_get_stats(compat_param, &param, COMPAT_US_TO_K);
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(&param, (ioc_fm_pcd_cc_tbl_get_stats_t *)arg,
+                            sizeof(ioc_fm_pcd_cc_tbl_get_stats_t)))
+                    RETURN_ERROR(MINOR, E_WRITE_FAILED, NO_MSG);
+            }
+
+  
+            err = FM_PCD_MatchTableGetKeyStatistics((t_Handle) param.id,
+                                                     param.key_index,
+                                                     (t_FmPcdCcKeyStatistics *) &param.statistics);
+         
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_cc_tbl_get_stats_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_cc_tbl_get_stats_t*) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_cc_tbl_get_stats_t));
+                if (!compat_param)
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_tbl_get_stats_t));
+                compat_copy_fm_pcd_cc_tbl_get_stats(compat_param, &param, COMPAT_K_TO_US);
+                if (copy_to_user((ioc_compat_fm_pcd_cc_tbl_get_stats_t*) compat_ptr(arg),
+                            compat_param,
+                            sizeof(ioc_compat_fm_pcd_cc_tbl_get_stats_t))){
+                    XX_Free(compat_param);
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
+                }
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (copy_to_user((ioc_fm_pcd_cc_tbl_get_stats_t *)arg,
+                                  &param,
+                                  sizeof(ioc_fm_pcd_cc_tbl_get_stats_t)))
+                    RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
+            }
+
+            break;
+        }
 
 
 #if defined(CONFIG_COMPAT)
@@ -1948,148 +2052,150 @@ invalid_port_id:
 #endif
         case FM_PCD_IOC_MATCH_TABLE_GET_MISS_STAT:
         {
-            ioc_fm_pcd_cc_tbl_get_miss_params_t param;
+            ioc_fm_pcd_cc_tbl_get_stats_t param;
 
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
-                ioc_compat_fm_pcd_cc_tbl_get_miss_params_t *compat_param;
+                ioc_compat_fm_pcd_cc_tbl_get_stats_t *compat_param;
 
-                compat_param = (ioc_compat_fm_pcd_cc_tbl_get_miss_params_t *) XX_Malloc(
-                        sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t));
+                compat_param = (ioc_compat_fm_pcd_cc_tbl_get_stats_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_cc_tbl_get_stats_t));
                 if (!compat_param)
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
 
-                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t));
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_tbl_get_stats_t));
                 if (copy_from_user(compat_param,
-                            (ioc_compat_fm_pcd_cc_tbl_get_miss_params_t *)compat_ptr(arg),
-                            sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t)))
+                            (ioc_compat_fm_pcd_cc_tbl_get_stats_t *)compat_ptr(arg),
+                            sizeof(ioc_compat_fm_pcd_cc_tbl_get_stats_t)))
                 {
                     XX_Free(compat_param);
                     RETURN_ERROR(MINOR, E_WRITE_FAILED, NO_MSG);
                 }
 
-                compat_copy_fm_pcd_cc_tbl_get_miss(compat_param, &param, COMPAT_US_TO_K);
+                compat_copy_fm_pcd_cc_tbl_get_stats(compat_param, &param, COMPAT_US_TO_K);
 
                 XX_Free(compat_param);
             }
             else
 #endif
             {
-                if (copy_from_user(&param, (ioc_fm_pcd_cc_tbl_get_miss_params_t *)arg,
-                            sizeof(ioc_fm_pcd_cc_tbl_get_miss_params_t)))
+                if (copy_from_user(&param, (ioc_fm_pcd_cc_tbl_get_stats_t *)arg,
+                            sizeof(ioc_fm_pcd_cc_tbl_get_stats_t)))
                     RETURN_ERROR(MINOR, E_WRITE_FAILED, NO_MSG);
             }
 
-
+  
             err = FM_PCD_MatchTableGetMissStatistics((t_Handle) param.id,
-                                                     (t_FmPcdCcKeyStatistics *) &param.miss_statistics);
-
+                                                     (t_FmPcdCcKeyStatistics *) &param.statistics);
+         
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
-                ioc_compat_fm_pcd_cc_tbl_get_miss_params_t *compat_param;
+                ioc_compat_fm_pcd_cc_tbl_get_stats_t *compat_param;
 
-                compat_param = (ioc_compat_fm_pcd_cc_tbl_get_miss_params_t*) XX_Malloc(
-                        sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t));
+                compat_param = (ioc_compat_fm_pcd_cc_tbl_get_stats_t*) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_cc_tbl_get_stats_t));
                 if (!compat_param)
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
 
-                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t));
-                compat_copy_fm_pcd_cc_tbl_get_miss(compat_param, &param, COMPAT_K_TO_US);
-                if (copy_to_user((ioc_compat_fm_pcd_cc_tbl_get_miss_params_t*) compat_ptr(arg),
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_tbl_get_stats_t));
+                compat_copy_fm_pcd_cc_tbl_get_stats(compat_param, &param, COMPAT_K_TO_US);
+                if (copy_to_user((ioc_compat_fm_pcd_cc_tbl_get_stats_t*) compat_ptr(arg),
                             compat_param,
-                            sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t)))
+                            sizeof(ioc_compat_fm_pcd_cc_tbl_get_stats_t))){
+                    XX_Free(compat_param);
                     RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
-
+                }
                 XX_Free(compat_param);
             }
             else
 #endif
             {
-                if (copy_to_user((ioc_fm_pcd_hash_table_params_t *)arg,
+                if (copy_to_user((ioc_fm_pcd_cc_tbl_get_stats_t *)arg,
                                   &param,
-                                  sizeof(ioc_fm_pcd_cc_tbl_get_miss_params_t)))
+                                  sizeof(ioc_fm_pcd_cc_tbl_get_stats_t)))
                     RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
             }
 
             break;
         }
-
+        
 
 #if defined(CONFIG_COMPAT)
         case FM_PCD_IOC_HASH_TABLE_GET_MISS_STAT_COMPAT:
 #endif
         case FM_PCD_IOC_HASH_TABLE_GET_MISS_STAT:
         {
-            ioc_fm_pcd_cc_tbl_get_miss_params_t param;
+            ioc_fm_pcd_cc_tbl_get_stats_t param;
 
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
-                ioc_compat_fm_pcd_cc_tbl_get_miss_params_t *compat_param;
+                ioc_compat_fm_pcd_cc_tbl_get_stats_t *compat_param;
 
-                compat_param = (ioc_compat_fm_pcd_cc_tbl_get_miss_params_t *) XX_Malloc(
-                        sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t));
+                compat_param = (ioc_compat_fm_pcd_cc_tbl_get_stats_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_cc_tbl_get_stats_t));
                 if (!compat_param)
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
 
-                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t));
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_tbl_get_stats_t));
                 if (copy_from_user(compat_param,
-                            (ioc_compat_fm_pcd_cc_tbl_get_miss_params_t *)compat_ptr(arg),
-                            sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t)))
+                            (ioc_compat_fm_pcd_cc_tbl_get_stats_t *)compat_ptr(arg),
+                            sizeof(ioc_compat_fm_pcd_cc_tbl_get_stats_t)))
                 {
                     XX_Free(compat_param);
                     RETURN_ERROR(MINOR, E_WRITE_FAILED, NO_MSG);
                 }
 
-                compat_copy_fm_pcd_cc_tbl_get_miss(compat_param, &param, COMPAT_US_TO_K);
+                compat_copy_fm_pcd_cc_tbl_get_stats(compat_param, &param, COMPAT_US_TO_K);
 
                 XX_Free(compat_param);
             }
             else
 #endif
             {
-                if (copy_from_user(&param, (ioc_fm_pcd_cc_tbl_get_miss_params_t *)arg,
-                            sizeof(ioc_fm_pcd_cc_tbl_get_miss_params_t)))
+                if (copy_from_user(&param, (ioc_fm_pcd_cc_tbl_get_stats_t *)arg,
+                            sizeof(ioc_fm_pcd_cc_tbl_get_stats_t)))
                     RETURN_ERROR(MINOR, E_WRITE_FAILED, NO_MSG);
             }
 
-
+  
             err = FM_PCD_HashTableGetMissStatistics((t_Handle) param.id,
-                                                     (t_FmPcdCcKeyStatistics *) &param.miss_statistics);
-
+                                                     (t_FmPcdCcKeyStatistics *) &param.statistics);
+         
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
-                ioc_compat_fm_pcd_cc_tbl_get_miss_params_t *compat_param;
+                ioc_compat_fm_pcd_cc_tbl_get_stats_t *compat_param;
 
-                compat_param = (ioc_compat_fm_pcd_cc_tbl_get_miss_params_t*) XX_Malloc(
-                        sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t));
+                compat_param = (ioc_compat_fm_pcd_cc_tbl_get_stats_t*) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_cc_tbl_get_stats_t));
                 if (!compat_param)
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
 
-                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t));
-                compat_copy_fm_pcd_cc_tbl_get_miss(compat_param, &param, COMPAT_K_TO_US);
-                if (copy_to_user((ioc_compat_fm_pcd_cc_tbl_get_miss_params_t*) compat_ptr(arg),
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_tbl_get_stats_t));
+                compat_copy_fm_pcd_cc_tbl_get_stats(compat_param, &param, COMPAT_K_TO_US);
+                if (copy_to_user((ioc_compat_fm_pcd_cc_tbl_get_stats_t*) compat_ptr(arg),
                             compat_param,
-                            sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t)))
+                            sizeof(ioc_compat_fm_pcd_cc_tbl_get_stats_t))){
+                    XX_Free(compat_param);
                     RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
-
+                }
                 XX_Free(compat_param);
             }
             else
 #endif
             {
-                if (copy_to_user((ioc_fm_pcd_hash_table_params_t *)arg,
+                if (copy_to_user((ioc_fm_pcd_cc_tbl_get_stats_t *)arg,
                                   &param,
-                                  sizeof(ioc_fm_pcd_cc_tbl_get_miss_params_t)))
+                                  sizeof(ioc_fm_pcd_cc_tbl_get_stats_t)))
                     RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
             }
 
             break;
         }
-
+      
 #if defined(CONFIG_COMPAT)
         case FM_PCD_IOC_HASH_TABLE_SET_COMPAT:
 #endif
@@ -2266,6 +2372,7 @@ invalid_port_id:
                 else
                 {
                     XX_Free(compat_param);
+                    XX_Free(param);
                     err = E_INVALID_VALUE;
                     break;
                 }
@@ -3249,18 +3356,21 @@ t_Error LnxwrpFmIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned l
             {
                 if (copy_to_user((ioc_fm_revision_info_t *)compat_ptr(arg),
                             param,
-                            sizeof(ioc_fm_revision_info_t)))
+                            sizeof(ioc_fm_revision_info_t))){
+                    XX_Free(param);
                     RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
+                 }
             }
             else
 #endif
             {
                 if (copy_to_user((ioc_fm_revision_info_t *)arg,
                             param,
-                            sizeof(ioc_fm_revision_info_t)))
+                            sizeof(ioc_fm_revision_info_t))){
+                    XX_Free(param);
                     RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
+                }
             }
-
             XX_Free(param);
             break;
         }
@@ -3428,7 +3538,7 @@ t_Error LnxwrpFmIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned l
             else
 #endif
             {
-                if (copy_from_user(&param, (void *)arg, sizeof(ioc_fm_counters_params_t)))
+                if (copy_from_user(&param, (void *)arg, sizeof(ioc_fm_ctrl_mon_counters_params_t)))
                     RETURN_ERROR(MINOR, E_WRITE_FAILED, NO_MSG);
             }
 
@@ -3455,7 +3565,7 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
     t_Error err = E_OK;
 
     _fm_ioctl_dbg("cmd:0x%08x(type:0x%02x, nr:%u).\n",
-        cmd, _IOC_TYPE(cmd), _IOC_NR(cmd) - 50);
+        cmd, _IOC_TYPE(cmd), _IOC_NR(cmd) - 70);
 
     switch (cmd)
     {
@@ -3695,7 +3805,9 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
                     port_pcd_params->p_kg_params           = compat_ptr(compat_port_pcd_params->p_kg_params);
                     port_pcd_params->p_plcr_params         = compat_ptr(compat_port_pcd_params->p_plcr_params);
                     port_pcd_params->p_ip_reassembly_manip = compat_ptr(compat_port_pcd_params->p_ip_reassembly_manip);
-
+#if (DPAA_VERSION >= 11)
+                    port_pcd_params->p_capwap_reassembly_manip = compat_ptr(compat_port_pcd_params->p_capwap_reassembly_manip);
+#endif
                     /* the prs member is the same, no compat structure...memcpy only */
                     if (port_pcd_params->p_prs_params)
                     {
@@ -4378,6 +4490,27 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
             break;
         }
 
+        case FM_PORT_IOC_GET_BMI_COUNTERS:
+        {
+            t_LnxWrpFmDev *p_LnxWrpFmDev =
+                    (t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
+            ioc_fm_port_bmi_stats_t param;
+            int port_id = p_LnxWrpFmPortDev->id;
+
+            if (!p_LnxWrpFmDev)
+                RETURN_ERROR(MINOR, E_NOT_AVAILABLE, ("Port not initialized or other error!"));
+
+            if (FM_PORT_GetBmiCounters(p_LnxWrpFmPortDev->h_Dev,
+                        (t_FmPortBmiStats *)&param))
+                RETURN_ERROR(MINOR, E_WRITE_FAILED, NO_MSG);
+
+            if (copy_to_user((ioc_fm_port_bmi_stats_t *)arg, &param,
+                        sizeof(ioc_fm_port_bmi_stats_t)))
+                RETURN_ERROR(MINOR, E_WRITE_FAILED, NO_MSG);
+
+            break;
+        }
+
         default:
             RETURN_ERROR(MINOR, E_INVALID_SELECTION,
                 ("invalid ioctl: cmd:0x%08x(type:0x%02x, nr:0x%02x.\n",
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.c
index 10aadad..0305826 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.c
@@ -53,7 +53,10 @@
 #include <linux/ioport.h>
 #include <asm/uaccess.h>
 #include <asm/errno.h>
-/* #include <sysdev/fsl_soc.h> */
+
+#ifndef CONFIG_ARM64
+#include <sysdev/fsl_soc.h> 
+#endif /* !CONFIG_ARM64 */
 
 #include "part_ext.h"
 #include "fm_ioctls.h"
@@ -310,12 +313,18 @@ static inline void compat_copy_fm_pcd_cc_next_kg(
     {
         param->new_fqid         = compat_param->new_fqid;
         param->override_fqid    = compat_param->override_fqid;
+#if DPAA_VERSION >= 11
+        param->new_relative_storage_profile_id = compat_param->new_relative_storage_profile_id;
+#endif
         param->p_direct_scheme  = compat_pcd_id2ptr(compat_param->p_direct_scheme);
     }
     else
     {
         compat_param->new_fqid          = param->new_fqid;
         compat_param->override_fqid     = param->override_fqid;
+#if DPAA_VERSION >= 11
+        compat_param->new_relative_storage_profile_id = param->new_relative_storage_profile_id;
+#endif
         compat_param->p_direct_scheme   = compat_pcd_ptr2id(param->p_direct_scheme);
     }
 
@@ -804,7 +813,9 @@ void compat_copy_fm_port_pcd(
         _fm_cpt_dbg(compat," param->p_kg_params=%p  \n", param->p_kg_params);
         _fm_cpt_dbg(compat," param->p_plcr_params=%p  \n", param->p_plcr_params);
         _fm_cpt_dbg(compat," param->p_ip_reassembly_manip=%p  \n", param->p_ip_reassembly_manip);
-
+#if (DPAA_VERSION >= 11)
+        _fm_cpt_dbg(compat," param->p_capwap_reassembly_manip=%p  \n", param->p_capwap_reassembly_manip);
+#endif
         param->pcd_support = compat_param->pcd_support;
         param->net_env_id = compat_pcd_id2ptr(compat_param->net_env_id);
 
@@ -815,6 +826,9 @@ void compat_copy_fm_port_pcd(
         if (param->p_plcr_params)
             param->p_plcr_params->plcr_profile_id = compat_pcd_id2ptr(compat_port_pcd_plcr_params->plcr_profile_id);
         param->p_ip_reassembly_manip = compat_pcd_id2ptr(compat_param->p_ip_reassembly_manip);
+#if (DPAA_VERSION >= 11)
+        param->p_capwap_reassembly_manip = compat_pcd_id2ptr(compat_param->p_capwap_reassembly_manip);
+#endif
     }
 }
 
@@ -844,22 +858,24 @@ void compat_copy_fm_port_vsp_alloc_params(
 }
 #endif /* (DPAA_VERSION >= 11) */
 
-void compat_copy_fm_pcd_cc_tbl_get_miss(
-        ioc_compat_fm_pcd_cc_tbl_get_miss_params_t *compat_param,
-        ioc_fm_pcd_cc_tbl_get_miss_params_t *param,
+void compat_copy_fm_pcd_cc_tbl_get_stats(
+        ioc_compat_fm_pcd_cc_tbl_get_stats_t *compat_param,
+        ioc_fm_pcd_cc_tbl_get_stats_t *param,
         uint8_t compat)
 {
     if (compat == COMPAT_US_TO_K)
     {
         param->id = compat_pcd_id2ptr(compat_param->id);
-        memcpy(&param->miss_statistics, &compat_param->miss_statistics, sizeof(ioc_fm_pcd_cc_key_statistics_t));
+	param->key_index = compat_param->key_index;
+        memcpy(&param->statistics, &compat_param->statistics, sizeof(ioc_fm_pcd_cc_key_statistics_t));
     } else {
         compat_param->id = compat_add_ptr2id(param->id, FM_MAP_TYPE_PCD_NODE);
-        memcpy(&compat_param->miss_statistics, &param->miss_statistics, sizeof(ioc_fm_pcd_cc_key_statistics_t));
+	compat_param->key_index = param->key_index;
+        memcpy(&compat_param->statistics, &param->statistics, sizeof(ioc_fm_pcd_cc_key_statistics_t));
     }
 }
 
-
+  
 void compat_copy_fm_pcd_net_env(
         ioc_compat_fm_pcd_net_env_params_t *compat_param,
         ioc_fm_pcd_net_env_params_t *param,
@@ -938,8 +954,8 @@ void compat_copy_keys(
 #if (DPAA_VERSION >= 11)
         memcpy(&compat_param->frame_length_ranges,
             &param->frame_length_ranges,
-            sizeof(compat_param->frame_length_ranges[0] *
-                IOC_FM_PCD_CC_STATS_MAX_NUM_OF_FLR));
+            sizeof(compat_param->frame_length_ranges[0]) *
+                IOC_FM_PCD_CC_STATS_MAX_NUM_OF_FLR);
 #endif /* (DPAA_VERSION >= 11) */
     }
 
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.h b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.h
index ae19b68..d89a64d 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.h
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.h
@@ -350,6 +350,9 @@ typedef struct ioc_compat_fm_port_pcd_params_t {
     compat_uptr_t                    p_kg_params;
     compat_uptr_t                    p_plcr_params;
     compat_uptr_t                    p_ip_reassembly_manip;
+#if DPAA_VERSION >= 11
+    compat_uptr_t                    p_capwap_reassembly_manip;
+#endif
 } ioc_compat_fm_port_pcd_params_t;
 
 typedef struct ioc_compat_fm_pcd_kg_cc_t {
@@ -413,10 +416,30 @@ typedef struct ioc_compat_fm_pcd_manip_hdr_insrt_specific_l2_params_t {
     compat_uptr_t                           p_data;
 } ioc_compat_fm_pcd_manip_hdr_insrt_specific_l2_params_t;
 
+typedef struct ioc_compat_fm_pcd_manip_hdr_insrt_t {
+    uint8_t       size;          /**< size of inserted section */
+    compat_uptr_t p_data;        /**< data to be inserted */
+} ioc_compat_fm_pcd_manip_hdr_insrt_t;
+
+#if (DPAA_VERSION >= 11)
+typedef struct ioc_compat_fm_pcd_manip_hdr_insrt_ip_params_t {
+    bool    calc_l4_checksum; /**< Calculate L4 checksum. */
+    ioc_fm_pcd_manip_hdr_qos_mapping_mode   mapping_mode; /**< TODO */
+    uint8_t last_pid_offset;     /**< the offset of the last Protocol within
+                                 the inserted header */
+    uint16_t  id;           /**< 16 bit New IP ID */
+    ioc_compat_fm_pcd_manip_hdr_insrt_t insrt; /**< size and data to be inserted. */
+} ioc_compat_fm_pcd_manip_hdr_insrt_ip_params_t;
+#endif /* (DPAA_VERSION >= 11) */
+
 typedef struct ioc_compat_fm_pcd_manip_hdr_insrt_by_hdr_params_t {
     ioc_fm_pcd_manip_hdr_insrt_by_hdr_type                      type;
     union {
        ioc_compat_fm_pcd_manip_hdr_insrt_specific_l2_params_t   specific_l2_params;
+#if (DPAA_VERSION >= 11)
+        ioc_compat_fm_pcd_manip_hdr_insrt_ip_params_t          ip_params;
+        ioc_compat_fm_pcd_manip_hdr_insrt_t             insrt;
+#endif /* (DPAA_VERSION >= 11) */
     } u;
 } ioc_compat_fm_pcd_manip_hdr_insrt_by_hdr_params_t;
 
@@ -425,8 +448,8 @@ typedef struct ioc_compat_fm_pcd_manip_hdr_insrt_params_t {
     union {
         ioc_compat_fm_pcd_manip_hdr_insrt_by_hdr_params_t   by_hdr;
         ioc_compat_fm_pcd_manip_hdr_insrt_generic_params_t  generic;
-#ifdef FM_CAPWAP_SUPPORT
-#error CAPWAP not supported!
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
+#error "FM_CAPWAP_SUPPORT feature not supported!"
         ioc_fm_pcd_manip_hdr_insrt_by_template_params_t     by_template;
 #endif /* FM_CAPWAP_SUPPORT */
     } u;
@@ -453,7 +476,7 @@ typedef struct ioc_compat_fm_pcd_manip_params_t {
         ioc_fm_pcd_manip_special_offload_params_t special_offload;
     } u;
     compat_uptr_t                                 p_next_manip;
-#ifdef FM_CAPWAP_SUPPORT
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
 #error "FM_CAPWAP_SUPPORT feature not supported!"
     bool                                          frag_or_reasm;
     ioc_fm_pcd_manip_frag_or_reasm_params_t       frag_or_reasm_params;
@@ -521,10 +544,11 @@ typedef struct ioc_compat_fm_ctrl_mon_counters_params_t {
     compat_uptr_t p_mon;
 } ioc_compat_fm_ctrl_mon_counters_params_t;
 
-typedef struct ioc_compat_fm_pcd_cc_tbl_get_miss_params_t {
+typedef struct ioc_compat_fm_pcd_cc_tbl_get_stats_t {
     compat_uptr_t                   id;
-    ioc_fm_pcd_cc_key_statistics_t  miss_statistics;
-} ioc_compat_fm_pcd_cc_tbl_get_miss_params_t;
+    uint16_t                        key_index;
+    ioc_fm_pcd_cc_key_statistics_t  statistics;
+} ioc_compat_fm_pcd_cc_tbl_get_stats_t;
 
 
 /* } pcd compat structures */
@@ -574,9 +598,9 @@ void compat_copy_fm_pcd_cc_tree(
         ioc_fm_pcd_cc_tree_params_t *param,
         uint8_t compat);
 
-void compat_copy_fm_pcd_cc_tbl_get_miss(
-        ioc_compat_fm_pcd_cc_tbl_get_miss_params_t *compat_param,
-        ioc_fm_pcd_cc_tbl_get_miss_params_t *param,
+void compat_copy_fm_pcd_cc_tbl_get_stats(
+        ioc_compat_fm_pcd_cc_tbl_get_stats_t *compat_param,
+        ioc_fm_pcd_cc_tbl_get_stats_t *param,
         uint8_t compat);
 
 void compat_fm_pcd_prs_sw(
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c
index 0ea6d1c..dd3bc3e 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c
@@ -1736,7 +1736,7 @@ int fm_plcr_dump_regs(void *h_fm_pcd, char *buf, int nn)
 			&p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr,
 			"fmpl_pmr");
 
-	for (i = 0; i < 64; ++i)
+	for (i = 0; i < 63; ++i)
 		FM_DMP_MEM_32(buf, n,
 			&p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr[i]);
 
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.h b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.h
index e6bf83e..137653e 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.h
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.h
@@ -126,7 +126,7 @@ int fm_profile_dump_regs(void *h_pcd, int ppnum, char *buf, int nn);
 		int k, m = n; \
 		phys_addr_t pa = virt_to_phys(&((st)->phrase)); \
 		k = snprintf(&buf[m], PAGE_SIZE - m, \
-		"0x%010llX: 0x%08x%8s\t%s\n", pa, \
+		"0x%010llX: 0x%08x%8s\t%s\n", (unsigned long long) pa, \
 		ioread32be((uint32_t *)&((st)->phrase)), "", #phrase); \
 		if (k < 0 || m > PAGE_SIZE - 90) \
 			FM_DMP_PGSZ_ERR \
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.c
index ad167ac..ff575b1 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.c
@@ -366,7 +366,7 @@ static int fm_port_dsar_dump_regs(void *h_dev, char *buf, int nn)
 		FM_DMP_LN(buf, n, "DSAR_ICMPv6_Checksum_Err:  0x%x\n", arStatistics->dsarIcmpV6ChecksumErr);
 		FM_DMP_LN(buf, n, "DSAR_ICMPv6_Other_Type:    0x%x\n", arStatistics->dsarIcmpV6OtherType);
 		FM_DMP_LN(buf, n, "DSAR_ICMPv4_Other_Type:    0x%x\n", arStatistics->dsarIcmpV4OtherType);
-
+		
 		iounmap(arStatistics);
 	}
 	if (ArCommonDescPtr->p_ArpDescriptor)
@@ -380,7 +380,7 @@ static int fm_port_dsar_dump_regs(void *h_dev, char *buf, int nn)
 		FM_DMP_LN(buf, n, "control bits 0x%04x\n", ArpDescriptor->control);
 		if (ArpDescriptor->numOfBindings)
 		{
-			char ip_str[20];
+			char ip_str[100];
 			t_DsarArpBindingEntry* bindings = ioremap(
 				ioread32be(&ArpDescriptor->p_Bindings) +
 				p_FmPort->fmMuramPhysBaseAddr,
@@ -390,8 +390,11 @@ static int fm_port_dsar_dump_regs(void *h_dev, char *buf, int nn)
 			FM_DMP_LN(buf, n, "      ip          vlan id\n");
 			for (i = 0; i < ArpDescriptor->numOfBindings; i++)
 			{
-				n += sprintf(ip_str, "%d:%d:%d:%d", ip_addr[0], ip_addr[1], ip_addr[2], ip_addr[3]);
-				FM_DMP_LN(buf, n, "%-15s     0x%x\n", ip_str, bindings->vlanId);
+				n += snprintf(ip_str, 100, "%d.%d.%d.%d",
+					ip_addr[0], ip_addr[1],
+					ip_addr[2], ip_addr[3]);
+				FM_DMP_LN(buf, n, "%-15s     0x%x\n",
+					ip_str, bindings->vlanId);
 			}
 			iounmap(bindings);
 		}
@@ -412,7 +415,7 @@ static int fm_port_dsar_dump_regs(void *h_dev, char *buf, int nn)
 			FM_DMP_LN(buf, n, "NMVLAN_CNT: 0x%x\n", arpStats->nmVlanCnt);
 			iounmap(arpStats);
 		}
-
+		
 		iounmap(ArpDescriptor);
 	}
 	if (ArCommonDescPtr->p_IcmpV4Descriptor)
@@ -427,7 +430,7 @@ static int fm_port_dsar_dump_regs(void *h_dev, char *buf, int nn)
 		FM_DMP_LN(buf, n, "control bits 0x%04x\n", ICMPV4Descriptor->control);
 		if (ICMPV4Descriptor->numOfBindings)
 		{
-			char ip_str[20];
+			char ip_str[100];
 			t_DsarArpBindingEntry* bindings = ioremap(
 				ioread32be(&ICMPV4Descriptor->p_Bindings) +
 				p_FmPort->fmMuramPhysBaseAddr,
@@ -437,8 +440,11 @@ static int fm_port_dsar_dump_regs(void *h_dev, char *buf, int nn)
 			FM_DMP_LN(buf, n, "      ip          vlan id\n");
 			for (i = 0; i < ICMPV4Descriptor->numOfBindings; i++)
 			{
-				n += sprintf(ip_str, "%d:%d:%d:%d", ip_addr[0], ip_addr[1], ip_addr[2], ip_addr[3]);
-				FM_DMP_LN(buf, n, "%-15s     0x%x\n", ip_str, bindings->vlanId);
+				n += snprintf(ip_str, 100, "%d.%d.%d.%d",
+					ip_addr[0], ip_addr[1],
+					ip_addr[2], ip_addr[3]);
+				FM_DMP_LN(buf, n, "%-15s     0x%x\n",
+					ip_str, bindings->vlanId);
 			}
 			iounmap(bindings);
 		}
@@ -470,7 +476,7 @@ static int fm_port_dsar_dump_regs(void *h_dev, char *buf, int nn)
 		FM_DMP_LN(buf, n, "solicited address 0x%08x\n", NDDescriptor->solicitedAddr);
 		if (NDDescriptor->numOfBindings)
 		{
-			char ip_str[20];
+			char ip_str[100];
 			t_DsarIcmpV6BindingEntry* bindings = ioremap(
 				ioread32be(&NDDescriptor->p_Bindings) +
 				p_FmPort->fmMuramPhysBaseAddr,
@@ -480,7 +486,8 @@ static int fm_port_dsar_dump_regs(void *h_dev, char *buf, int nn)
 			FM_DMP_LN(buf, n, "                  ip                        vlan id\n");
 			for (i = 0; i < NDDescriptor->numOfBindings; i++)
 			{
-				n += sprintf(ip_str, "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x",
+				n += snprintf(ip_str, 100,
+					"%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x",
 				ip_addr[0], ip_addr[1], ip_addr[2], ip_addr[3],
 				ip_addr[4], ip_addr[5], ip_addr[6], ip_addr[7]);
 				FM_DMP_LN(buf, n, "%s     0x%x\n", ip_str, bindings->vlanId);
@@ -516,7 +523,7 @@ static int fm_port_dsar_dump_regs(void *h_dev, char *buf, int nn)
 		FM_DMP_LN(buf, n, "control bits 0x%04x\n", ICMPV6Descriptor->control);
 		if (ICMPV6Descriptor->numOfBindings)
 		{
-			char ip_str[20];
+			char ip_str[100];
 			t_DsarIcmpV6BindingEntry* bindings = ioremap(
 				ioread32be(&ICMPV6Descriptor->p_Bindings) +
 				p_FmPort->fmMuramPhysBaseAddr,
@@ -526,7 +533,8 @@ static int fm_port_dsar_dump_regs(void *h_dev, char *buf, int nn)
 			FM_DMP_LN(buf, n, "                  ip                        vlan id\n");
 			for (i = 0; i < ICMPV6Descriptor->numOfBindings; i++)
 			{
-				n += sprintf(ip_str, "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x",
+				n += snprintf(ip_str, 100,
+					"%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x",
 				ip_addr[0], ip_addr[1], ip_addr[2], ip_addr[3],
 				ip_addr[4], ip_addr[5], ip_addr[6], ip_addr[7]);
 				FM_DMP_LN(buf, n, "%s     0x%x\n", ip_str, bindings->vlanId);
@@ -560,7 +568,7 @@ static int fm_port_dsar_dump_regs(void *h_dev, char *buf, int nn)
 		FM_DMP_LN(buf, n, "max message length 0x%04x\n", SnmpDescriptor->maxSnmpMsgLength);
 		if (SnmpDescriptor->numOfIpv4Addresses)
 		{
-			char ip_str[20];
+			char ip_str[100];
 			t_DsarSnmpIpv4AddrTblEntry* addrs = ioremap(
 				ioread32be(&SnmpDescriptor->p_Ipv4AddrTbl) +
 				p_FmPort->fmMuramPhysBaseAddr,
@@ -570,7 +578,9 @@ static int fm_port_dsar_dump_regs(void *h_dev, char *buf, int nn)
 			FM_DMP_LN(buf, n, "      ip          vlan id\n");
 			for (i = 0; i < SnmpDescriptor->numOfIpv4Addresses; i++)
 			{
-				n += sprintf(ip_str, "%d:%d:%d:%d", ip_addr[0], ip_addr[1], ip_addr[2], ip_addr[3]);
+				n += snprintf(ip_str, 100, "%d.%d.%d.%d",
+					ip_addr[0], ip_addr[1],
+					ip_addr[2], ip_addr[3]);
 				FM_DMP_LN(buf, n, "%-15s     0x%x\n", ip_str, addrs->vlanId);
 			}
 			iounmap(addrs);
@@ -692,6 +702,11 @@ static ssize_t show_fm_port_ipv4_options(struct device *dev,
 	if (!p_LnxWrpFmPortDev->h_Dev) {
 		n = snprintf(buf, PAGE_SIZE, "\tFM Port not configured...\n");
 		return n;
+	} else if (((t_FmPort *)p_LnxWrpFmPortDev->h_Dev)->p_ParamsPage
+					== NULL) {
+		n = snprintf(buf, PAGE_SIZE,
+			"\tPort: FMan-controller params page not set\n");
+		return n;
 	} else {
 		n = snprintf(buf, PAGE_SIZE,
 			"Counter for fragmented pkt with IP header options\n");
@@ -836,7 +851,7 @@ int fm_port_sysfs_create(struct device *dev)
 		return -EIO;
 	if (device_create_file(dev, &dev_attr_fm_port_dsar_mem) != 0)
 		return -EIO;
-
+		
 	/* FM Ports statistics */
 	switch (p_LnxWrpFmPortDev->settings.param.portType) {
 	case e_FM_PORT_TYPE_TX:
@@ -1201,8 +1216,6 @@ int fm_port_dump_regs_bmi(void *h_dev, char *buf, int nn)
 		FM_DMP_SUBTITLE(buf, n, "\n");
 		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tgpr);
 		break;
-	default:
-		return -EINVAL;
 	}
 
 	FM_DMP_SUBTITLE(buf, n, "\n");
@@ -1239,3 +1252,4 @@ int fm_port_dump_regs_qmi(void *h_dev, char *buf, int nn)
 
 	return n;
 }
+
diff --git a/drivers/net/ethernet/freescale/fman/src/xx/Makefile b/drivers/net/ethernet/freescale/fman/src/xx/Makefile
index 55be302..01218f2 100644
--- a/drivers/net/ethernet/freescale/fman/src/xx/Makefile
+++ b/drivers/net/ethernet/freescale/fman/src/xx/Makefile
@@ -1,7 +1,7 @@
 #
 # Makefile for the Freescale Ethernet controllers
 #
-EXTRA_CFLAGS           += -DVERSION=\"\"
+ccflags-y           += -DVERSION=\"\"
 #
 #Include netcomm SW specific definitions
 include $(srctree)/drivers/net/ethernet/freescale/fman/ncsw_config.mk
diff --git a/drivers/net/ethernet/freescale/fman/src/xx/xx_linux.c b/drivers/net/ethernet/freescale/fman/src/xx/xx_linux.c
index 270cf02..d0cf89e 100644
--- a/drivers/net/ethernet/freescale/fman/src/xx/xx_linux.c
+++ b/drivers/net/ethernet/freescale/fman/src/xx/xx_linux.c
@@ -169,7 +169,7 @@ void XX_Print(char *str, ...)
 #ifdef CONFIG_SMP
     if (vsnprintf (buf, BUF_SIZE, str, args) >= BUF_SIZE)
         printk(KERN_WARNING "Illegal string to print!\n    more than %d characters.\n\tString was not printed completelly.\n", BUF_SIZE);
-    printk(KERN_CRIT "cpu %d: %s",  raw_smp_processor_id(), buf);
+    printk(KERN_CRIT "cpu%d/%d: %s", get_hard_smp_processor_id(raw_smp_processor_id()), raw_smp_processor_id(), buf);
 #else
     vprintk(str, args);
 #endif /* CONFIG_SMP */
@@ -187,7 +187,7 @@ void XX_Fprint(void *file, char *str, ...)
 #ifdef CONFIG_SMP
     if (vsnprintf (buf, BUF_SIZE, str, args) >= BUF_SIZE)
         printk(KERN_WARNING "Illegal string to print!\n    more than %d characters.\n\tString was not printed completelly.\n", BUF_SIZE);
-    printk (KERN_CRIT "cpu %d: %s", smp_processor_id(), buf);
+    printk (KERN_CRIT "cpu%d/%d: %s",hard_smp_processor_id(), smp_processor_id(), buf);
 
 #else
     vprintk(str, args);
@@ -401,33 +401,10 @@ typedef struct {
 
 t_Handle interruptHandlers[0x00010000];
 
-static irqreturn_t LinuxInterruptHandler (int irq, void *dev_id)
-{
-    t_InterruptHandler *p_IntrHndl = (t_InterruptHandler *)dev_id;
-    p_IntrHndl->f_Isr(p_IntrHndl->handle);
-    return IRQ_HANDLED;
-}
 
 t_Error XX_SetIntr(int irq, t_Isr *f_Isr, t_Handle handle)
 {
-    const char *device;
-    t_InterruptHandler *p_IntrHndl;
-
-    device = GetDeviceName(irq);
-    if (device == NULL)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Interrupt source - %d", irq));
-
-    p_IntrHndl = (t_InterruptHandler *)XX_Malloc(sizeof(t_InterruptHandler));
-    if (p_IntrHndl == NULL)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
-    p_IntrHndl->f_Isr = f_Isr;
-    p_IntrHndl->handle = handle;
-    interruptHandlers[irq] = p_IntrHndl;
-
-    if (request_irq(GetDeviceIrqNum(irq), LinuxInterruptHandler, 0, device, p_IntrHndl) < 0)
-        RETURN_ERROR(MAJOR, E_BUSY, ("Can't get IRQ %s\n", device));
-    disable_irq(GetDeviceIrqNum(irq));
-
+/* not used */
     return E_OK;
 }
 
diff --git a/include/uapi/linux/fmd/Peripherals/fm_ioctls.h b/include/uapi/linux/fmd/Peripherals/fm_ioctls.h
index 5134830..e0c2dd3 100644
--- a/include/uapi/linux/fmd/Peripherals/fm_ioctls.h
+++ b/include/uapi/linux/fmd/Peripherals/fm_ioctls.h
@@ -328,7 +328,7 @@ typedef struct ioc_fm_vsp_prs_result_params_t {
 #endif
 
 typedef struct fm_ctrl_mon_t {
-    uint8_t     percent_cnt[1];
+    uint8_t     percent_cnt[2];
 } fm_ctrl_mon_t;
 
 typedef struct ioc_fm_ctrl_mon_counters_params_t {
@@ -622,7 +622,7 @@ typedef struct ioc_fm_ctrl_mon_counters_params_t {
 /** @} */ /* end of lnx_ioctl_FM_grp */
 
 #define FMD_API_VERSION_MAJOR 21
-#define FMD_API_VERSION_MINOR 1
+#define FMD_API_VERSION_MINOR 1 
 #define FMD_API_VERSION_RESPIN 0
 
 #endif /* __FM_IOCTLS_H */
diff --git a/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h b/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h
index daa3345..bc920fb 100644
--- a/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h
+++ b/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h
@@ -708,7 +708,7 @@ typedef enum ioc_fm_pcd_action {
 typedef enum ioc_fm_pcd_manip_hdr_insrt_type {
     e_IOC_FM_PCD_MANIP_INSRT_GENERIC,                   /**< Insert according to offset & size */
     e_IOC_FM_PCD_MANIP_INSRT_BY_HDR,                    /**< Insert according to protocol */
-#ifdef FM_CAPWAP_SUPPORT
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
     e_IOC_FM_PCD_MANIP_INSRT_BY_TEMPLATE                /**< Insert template to start of frame */
 #endif /* FM_CAPWAP_SUPPORT */
 } ioc_fm_pcd_manip_hdr_insrt_type;
@@ -846,7 +846,7 @@ typedef enum ioc_fm_pcd_manip_reassem_ways_number {
     e_IOC_FM_PCD_MANIP_EIGHT_WAYS_HASH      /**< Eight ways hash */
 } ioc_fm_pcd_manip_reassem_ways_number;
 
-#ifdef FM_CAPWAP_SUPPORT
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
 /**************************************************************************//**
  @Description   Enumeration type for selecting type of statistics mode
 *//***************************************************************************/
@@ -929,6 +929,7 @@ typedef union ioc_fm_pcd_fields_u {
     ioc_header_field_ipv4_t             ipv4;           /**< IPv4                   */
     ioc_header_field_ipv6_t             ipv6;           /**< IPv6                   */
     ioc_header_field_udp_t              udp;            /**< UDP                    */
+    ioc_header_field_udp_lite_t         udp_lite;       /**< UDP_Lite               */
     ioc_header_field_tcp_t              tcp;            /**< TCP                    */
     ioc_header_field_sctp_t             sctp;           /**< SCTP                   */
     ioc_header_field_dccp_t             dccp;           /**< DCCP                   */
@@ -1908,10 +1909,10 @@ typedef struct ioc_fm_pcd_manip_hdr_rmv_generic_params_t {
 /**************************************************************************//**
  @Description   Parameters for defining insertion manipulation
 *//***************************************************************************/
-typedef struct fm_pcd_manip_hdr_insrt_t {
+typedef struct ioc_fm_pcd_manip_hdr_insrt_t {
     uint8_t size;           /**< size of inserted section */
     uint8_t *p_data;        /**< data to be inserted */
-} fm_pcd_manip_hdr_insrt_t;
+} ioc_fm_pcd_manip_hdr_insrt_t;
 
 /**************************************************************************//**
  @Description   Parameters for defining generic insertion manipulation
@@ -2052,14 +2053,14 @@ typedef struct ioc_fm_pcd_manip_hdr_insrt_specific_l2_params_t {
 /**************************************************************************//**
  @Description   Parameters for defining IP insertion manipulation
 *//***************************************************************************/
-typedef struct fm_pcd_manip_hdr_insrt_ip_params_t {
+typedef struct ioc_fm_pcd_manip_hdr_insrt_ip_params_t {
     bool    calc_l4_checksum; /**< Calculate L4 checksum. */
     ioc_fm_pcd_manip_hdr_qos_mapping_mode   mapping_mode; /**< TODO */
     uint8_t last_pid_offset;     /**< the offset of the last Protocol within
                                  the inserted header */
     uint16_t  id;           /**< 16 bit New IP ID */
-    fm_pcd_manip_hdr_insrt_t insrt; /**< size and data to be inserted. */
-} fm_pcd_manip_hdr_insrt_ip_params_t;
+    ioc_fm_pcd_manip_hdr_insrt_t insrt; /**< size and data to be inserted. */
+} ioc_fm_pcd_manip_hdr_insrt_ip_params_t;
 #endif /* (DPAA_VERSION >= 11) */
 
 /**************************************************************************//**
@@ -2072,8 +2073,8 @@ typedef struct ioc_fm_pcd_manip_hdr_insrt_by_hdr_params_t {
                                                             /**< Used when type = e_IOC_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2:
                                                                  Selects which L2 headers to remove */
 #if (DPAA_VERSION >= 11)
-        fm_pcd_manip_hdr_insrt_ip_params_t          ip_params;  /**< Used when type = e_FM_PCD_MANIP_INSRT_BY_HDR_IP */
-        fm_pcd_manip_hdr_insrt_t                    insrt;     /**< Used when type is one of e_FM_PCD_MANIP_INSRT_BY_HDR_UDP,
+        ioc_fm_pcd_manip_hdr_insrt_ip_params_t      ip_params;  /**< Used when type = e_FM_PCD_MANIP_INSRT_BY_HDR_IP */
+        ioc_fm_pcd_manip_hdr_insrt_t                insrt;     /**< Used when type is one of e_FM_PCD_MANIP_INSRT_BY_HDR_UDP,
                                                                 e_FM_PCD_MANIP_INSRT_BY_HDR_UDP_LITE, or
                                                                 e_FM_PCD_MANIP_INSRT_BY_HDR_CAPWAP */
 #endif /* (DPAA_VERSION >= 11) */
@@ -2090,7 +2091,7 @@ typedef struct ioc_fm_pcd_manip_hdr_insrt_params_t {
                                                                      relevant if 'type' = e_IOC_FM_PCD_MANIP_INSRT_BY_HDR */
         ioc_fm_pcd_manip_hdr_insrt_generic_params_t     generic;/**< Parameters for defining generic header insertion manipulation,
                                                                      relevant if type = e_IOC_FM_PCD_MANIP_INSRT_GENERIC */
-#ifdef FM_CAPWAP_SUPPORT
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
         ioc_fm_pcd_manip_hdr_insrt_by_template_params_t by_template;
                                                                 /**< Parameters for defining header insertion manipulation by template,
                                                                      relevant if 'type' = e_IOC_FM_PCD_MANIP_INSRT_BY_TEMPLATE */
@@ -2176,8 +2177,7 @@ typedef struct ioc_fm_pcd_manip_params_t {
     void                                            *p_next_manip;/**< Handle to another (previously defined) manipulation node;
                                                                  Allows concatenation of manipulation actions
                                                                  This parameter is optional and may be NULL. */
-#ifdef FM_CAPWAP_SUPPORT
-#error "FM_CAPWAP_SUPPORT feature not supported!"
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
     bool                                            frag_or_reasm;/**< TRUE, if defined fragmentation/reassembly manipulation */
     ioc_fm_pcd_manip_frag_or_reasm_params_t         frag_or_reasm_params;/**< Parameters for fragmentation/reassembly manipulation,
                                                                             relevant if frag_or_reasm = TRUE */
@@ -2229,7 +2229,7 @@ typedef struct ioc_fm_pcd_manip_frag_ip_stats_t {
 /**************************************************************************//**
  @Description   Structure for retrieving CAPWAP reassembly statistics
 *//***************************************************************************/
-typedef struct fm_pcd_manip_reassem_capwap_stats_t {
+typedef struct ioc_fm_pcd_manip_reassem_capwap_stats_t {
     uint32_t    timeout;                    /**< Counts the number of timeout occurrences */
     uint32_t    rfd_pool_busy;                /**< Counts the number of failed attempts to allocate
                                                  a Reassembly Frame Descriptor */
@@ -2250,19 +2250,19 @@ typedef struct fm_pcd_manip_reassem_capwap_stats_t {
                                                  exceeds 16 */
     uint32_t    exceed_max_reassembly_frame_len;/**< ounts the number of times that a successful reassembled frame
                                                  length exceeds MaxReassembledFrameLength value */
-} fm_pcd_manip_reassem_capwap_stats_t;
+} ioc_fm_pcd_manip_reassem_capwap_stats_t;
 
 /**************************************************************************//**
  @Description   Structure for retrieving CAPWAP fragmentation statistics
 *//***************************************************************************/
-typedef struct fm_pcd_manip_frag_capwap_stats_t {
+typedef struct ioc_fm_pcd_manip_frag_capwap_stats_t {
     uint32_t    total_frames;            /**< Number of frames that passed through the manipulation node */
     uint32_t    fragmented_frames;       /**< Number of frames that were fragmented */
     uint32_t    generated_fragments;     /**< Number of fragments that were generated */
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
     uint8_t     sg_allocation_failure;    /**< Number of allocation failure of s/g buffers */
 #endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
-} fm_pcd_manip_frag_capwap_stats_t;
+} ioc_fm_pcd_manip_frag_capwap_stats_t;
 #endif /* (DPAA_VERSION >= 11) */
 
 /**************************************************************************//**
@@ -2272,7 +2272,7 @@ typedef struct ioc_fm_pcd_manip_reassem_stats_t {
     union {
         ioc_fm_pcd_manip_reassem_ip_stats_t  ip_reassem;  /**< Structure for IP reassembly statistics */
 #if (DPAA_VERSION >= 11)
-        fm_pcd_manip_reassem_capwap_stats_t  capwap_reassem;  /**< Structure for CAPWAP reassembly statistics */
+        ioc_fm_pcd_manip_reassem_capwap_stats_t  capwap_reassem;  /**< Structure for CAPWAP reassembly statistics */
 #endif /* (DPAA_VERSION >= 11) */
     } u;
 } ioc_fm_pcd_manip_reassem_stats_t;
@@ -2284,7 +2284,7 @@ typedef struct ioc_fm_pcd_manip_frag_stats_t {
     union {
         ioc_fm_pcd_manip_frag_ip_stats_t     ip_frag;     /**< Structure for IP fragmentation statistics */
 #if (DPAA_VERSION >= 11)
-        fm_pcd_manip_frag_capwap_stats_t capwap_frag; /**< Structure for CAPWAP fragmentation statistics */
+        ioc_fm_pcd_manip_frag_capwap_stats_t capwap_frag; /**< Structure for CAPWAP fragmentation statistics */
 #endif /* (DPAA_VERSION >= 11) */
     } u;
 } ioc_fm_pcd_manip_frag_stats_t;
@@ -2339,11 +2339,40 @@ typedef struct ioc_fm_pcd_cc_key_statistics_t {
 } ioc_fm_pcd_cc_key_statistics_t;
 
 
-typedef struct ioc_fm_pcd_cc_tbl_get_miss_params_t {
+typedef struct ioc_fm_pcd_cc_tbl_get_stats_t {
     void                            *id;
-    ioc_fm_pcd_cc_key_statistics_t  miss_statistics;
-} ioc_fm_pcd_cc_tbl_get_miss_params_t;
+    uint16_t                        key_index;
+    ioc_fm_pcd_cc_key_statistics_t  statistics;
+} ioc_fm_pcd_cc_tbl_get_stats_t;
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableGetKeyStatistics
+
+ @Description   This routine may be used to get statistics counters of specific key
+                in a CC Node.
 
+                If 'e_FM_PCD_CC_STATS_MODE_FRAME' and
+                'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME' were set for this node,
+                these counters reflect how many frames passed that were matched
+                this key; The total frames count will be returned in the counter
+                of the first range (as only one frame length range was defined).
+                If 'e_FM_PCD_CC_STATS_MODE_RMON' was set for this node, the total
+                frame count will be separated to frame length counters, based on
+                provided frame length ranges.
+
+ @Param[in]     h_CcNode        A handle to the node
+ @Param[in]     keyIndex        Key index for adding
+ @Param[out]    p_KeyStatistics Key statistics counters
+
+ @Return        The specific key statistics.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet().
+*//***************************************************************************/
+
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MATCH_TABLE_GET_KEY_STAT_COMPAT   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(12), ioc_compat_fm_pcd_cc_tbl_get_stats_t)
+#endif
+#define FM_PCD_IOC_MATCH_TABLE_GET_KEY_STAT  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(12), ioc_fm_pcd_cc_tbl_get_stats_t)
 
 /**************************************************************************//**
  @Function      FM_PCD_MatchTableGetMissStatistics
@@ -2367,9 +2396,9 @@ typedef struct ioc_fm_pcd_cc_tbl_get_miss_params_t {
 *//***************************************************************************/
 
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_MATCH_TABLE_GET_MISS_STAT_COMPAT   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(12), ioc_compat_fm_pcd_cc_tbl_get_miss_params_t)
+#define FM_PCD_IOC_MATCH_TABLE_GET_MISS_STAT_COMPAT   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(13), ioc_compat_fm_pcd_cc_tbl_get_stats_t)
 #endif
-#define FM_PCD_IOC_MATCH_TABLE_GET_MISS_STAT  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(12), ioc_fm_pcd_cc_tbl_get_miss_params_t)
+#define FM_PCD_IOC_MATCH_TABLE_GET_MISS_STAT  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(13), ioc_fm_pcd_cc_tbl_get_stats_t)
 
 /**************************************************************************//**
  @Function      FM_PCD_HashTableGetMissStatistics
@@ -2391,9 +2420,9 @@ typedef struct ioc_fm_pcd_cc_tbl_get_miss_params_t {
 *//***************************************************************************/
 
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_HASH_TABLE_GET_MISS_STAT_COMPAT   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(13), ioc_compat_fm_pcd_cc_tbl_get_miss_params_t)
+#define FM_PCD_IOC_HASH_TABLE_GET_MISS_STAT_COMPAT   _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(14), ioc_compat_fm_pcd_cc_tbl_get_stats_t)
 #endif
-#define FM_PCD_IOC_HASH_TABLE_GET_MISS_STAT  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(13), ioc_fm_pcd_cc_tbl_get_miss_params_t)
+#define FM_PCD_IOC_HASH_TABLE_GET_MISS_STAT  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(14), ioc_fm_pcd_cc_tbl_get_stats_t)
 
 
 /**************************************************************************//**
@@ -2921,8 +2950,7 @@ typedef struct ioc_fm_pcd_cc_tbl_get_miss_params_t {
 
 #endif
 
-#ifdef FM_CAPWAP_SUPPORT
-#warning "CAPWAP IOCTL not implemented"
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
 /**************************************************************************//**
  @Function      FM_PCD_StatisticsSetNode
 
diff --git a/include/uapi/linux/fmd/Peripherals/fm_port_ioctls.h b/include/uapi/linux/fmd/Peripherals/fm_port_ioctls.h
index dc7cc32..0d5965e 100644
--- a/include/uapi/linux/fmd/Peripherals/fm_port_ioctls.h
+++ b/include/uapi/linux/fmd/Peripherals/fm_port_ioctls.h
@@ -104,8 +104,8 @@ typedef enum ioc_fm_port_pcd_support {
     , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR     /**< Use Parser, Keygen and Policer */
     , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_CC              /**< Use Parser and Coarse Classification */
     , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR     /**< Use Parser and Coarse Classification and Policer */
-#ifdef FM_CAPWAP_SUPPORT
     , e_IOC_FM_PORT_PCD_SUPPORT_CC_ONLY                 /**< Use only Coarse Classification */
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
     , e_IOC_FM_PORT_PCD_SUPPORT_CC_AND_KG               /**< Use Coarse Classification,and Keygen */
     , e_IOC_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR      /**< Use Coarse Classification, Keygen and Policer */
 #endif /* FM_CAPWAP_SUPPORT */
@@ -186,6 +186,26 @@ typedef enum ioc_fm_port_counters {
     e_IOC_FM_PORT_COUNTERS_DEQ_CONFIRM                  /**< QMI counter */
 } ioc_fm_port_counters;
 
+typedef struct ioc_fm_port_bmi_stats_t {
+    uint32_t cnt_cycle;
+    uint32_t cnt_task_util;
+    uint32_t cnt_queue_util;
+    uint32_t cnt_dma_util;
+    uint32_t cnt_fifo_util;
+    uint32_t cnt_rx_pause_activation;
+    uint32_t cnt_frame;
+    uint32_t cnt_discard_frame;
+    uint32_t cnt_dealloc_buf;
+    uint32_t cnt_rx_bad_frame;
+    uint32_t cnt_rx_large_frame;
+    uint32_t cnt_rx_filter_frame;
+    uint32_t cnt_rx_list_dma_err;
+    uint32_t cnt_rx_out_of_buffers_discard;
+    uint32_t cnt_wred_discard;
+    uint32_t cnt_length_err;
+    uint32_t cnt_unsupported_format;
+} ioc_fm_port_bmi_stats_t;
+
 /**************************************************************************//**
  @Description   Structure for Port id parameters.
                 (Description may be inaccurate;
@@ -915,6 +935,23 @@ typedef struct ioc_fm_port_vsp_alloc_params_t {
 #define FM_PORT_IOC_VSP_ALLOC _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(38), ioc_fm_port_vsp_alloc_params_t)
 #endif /* (DPAA_VERSION >= 11) */
 
+/**************************************************************************//**
+ @Function      FM_PORT_GetBmiCounters
+
+ @Description   Read port's BMI stat counters and place them into
+                a designated structure of counters.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[out]    p_BmiStats  counters structure
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+
+#define FM_PORT_IOC_GET_BMI_COUNTERS _IOR(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(42), ioc_fm_port_bmi_stats_t)
+
+
 /** @} */ /* end of lnx_ioctl_FM_PORT_pcd_runtime_control_grp group */
 /** @} */ /* end of lnx_ioctl_FM_PORT_runtime_control_grp group */
 
-- 
1.7.5.4

