From 401da7111b39bc06a86209cf9764a86dfa3cc4ca Mon Sep 17 00:00:00 2001
From: Roy Pledge <Roy.Pledge@freescale.com>
Date: Thu, 8 Jan 2015 16:49:08 -0500
Subject: [PATCH 136/451] fsl_qbman: Fix some QBMan issues and add USDPAA
 support

Signed-off-by: Roy Pledge <Roy.Pledge@freescale.com>
Change-Id: I9988e11d2a13ea6030f14c12e8fa5a5a6c48940b
Reviewed-on: http://git.am.freescale.net:8181/28086
Reviewed-by: Yang Li <LeoLi@freescale.com>
Tested-by: Yang Li <LeoLi@freescale.com>
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 .../boot/dts/freescale/qoriq-bman1-portals.dtsi    |    4 +-
 .../boot/dts/freescale/qoriq-qman1-portals.dtsi    |    4 +-
 drivers/staging/fsl_qbman/Makefile                 |    2 +-
 drivers/staging/fsl_qbman/bman_config.c            |   10 +++-
 drivers/staging/fsl_qbman/bman_high.c              |    2 +-
 drivers/staging/fsl_qbman/dpa_sys_arm64.h          |    1 +
 drivers/staging/fsl_qbman/fsl_usdpaa.c             |   28 ++++++---
 drivers/staging/fsl_qbman/fsl_usdpaa_irq.c         |    7 ++-
 drivers/staging/fsl_qbman/qman_config.c            |    4 +
 drivers/staging/fsl_qbman/qman_driver.c            |   25 +++++---
 drivers/staging/fsl_qbman/qman_high.c              |   63 +++++++++++++++++---
 drivers/staging/fsl_qbman/qman_test_high.c         |    2 +
 include/linux/fsl_qman.h                           |   46 ++++++++++++++
 include/linux/fsl_usdpaa.h                         |    2 +-
 14 files changed, 164 insertions(+), 36 deletions(-)

diff --git a/arch/arm64/boot/dts/freescale/qoriq-bman1-portals.dtsi b/arch/arm64/boot/dts/freescale/qoriq-bman1-portals.dtsi
index fd322e8..f85b96c 100644
--- a/arch/arm64/boot/dts/freescale/qoriq-bman1-portals.dtsi
+++ b/arch/arm64/boot/dts/freescale/qoriq-bman1-portals.dtsi
@@ -90,12 +90,12 @@
 		reg = <0x80000 0x4000 0x4080000 0x4000>;
 		interrupts = <0 189 0x4>;
 	};
-	bportal9: bman-portal@90000 {
+/*	bportal9: bman-portal@90000 {
 		cell-index = <9>;
 		compatible = "fsl,bman-portal";
 		reg = <0x90000 0x4000 0x4090000 0x4000>;
 		interrupts = <0 191 0x4>;
-	};
+	}; */
 	 bman-bpids@0 {
                 compatible = "fsl,bpid-range";
                 fsl,bpid-range = <32 32>;
diff --git a/arch/arm64/boot/dts/freescale/qoriq-qman1-portals.dtsi b/arch/arm64/boot/dts/freescale/qoriq-qman1-portals.dtsi
index b1d6cfc..7ff41a1 100644
--- a/arch/arm64/boot/dts/freescale/qoriq-qman1-portals.dtsi
+++ b/arch/arm64/boot/dts/freescale/qoriq-qman1-portals.dtsi
@@ -108,13 +108,13 @@
 		fsl,qman-channel-id = <8>;
 	};
 
-	qportal9: qman-portal@90000 {
+/*	qportal9: qman-portal@90000 {
 		cell-index = <9>;
 		compatible = "fsl,qman-portal";
 		reg = <0x90000 0x4000 0x4090000 0x4000>;
 		interrupts = <0 190 0x4>;
 		fsl,qman-channel-id = <9>;
-	};
+	}; */
 
 	qman-fqids@0 {
                 compatible = "fsl,fqid-range";
diff --git a/drivers/staging/fsl_qbman/Makefile b/drivers/staging/fsl_qbman/Makefile
index 8e23efb..8606233 100644
--- a/drivers/staging/fsl_qbman/Makefile
+++ b/drivers/staging/fsl_qbman/Makefile
@@ -23,6 +23,6 @@ obj-$(CONFIG_FSL_QMAN_DEBUGFS)	+= qman_debugfs_interface.o
 qman_debugfs_interface-y	 = qman_debugfs.o
 
 # USDPAA
-#obj-$(CONFIG_FSL_USDPAA)	+= fsl_usdpaa.o fsl_usdpaa_irq.o
+obj-$(CONFIG_FSL_USDPAA)	+= fsl_usdpaa.o fsl_usdpaa_irq.o
 
 GCOV_PROFILE := y
diff --git a/drivers/staging/fsl_qbman/bman_config.c b/drivers/staging/fsl_qbman/bman_config.c
index df9ac90..273b989 100644
--- a/drivers/staging/fsl_qbman/bman_config.c
+++ b/drivers/staging/fsl_qbman/bman_config.c
@@ -267,8 +267,14 @@ static __init int parse_mem_property(struct device_node *node, const char *name,
 	if (!pint || (ret != 16)) {
 		pr_info("No %s property '%s', using memblock_alloc(%016zx)\n",
 				node->full_name, name, *sz);
-		*addr = memblock_alloc(*sz, *sz);
-		vaddr = (unsigned long)phys_to_virt(*addr);
+		/* TODO: memblock_alloc isn't working as expected
+		   on ARM - revert to kmalloc() until it gets
+		   resolved
+		   *addr = memblock_alloc(*sz, *sz);
+		   vaddr = (unsigned long)phys_to_virt(*addr);
+		*/
+		vaddr = kmalloc(*sz, GFP_KERNEL);
+		*addr = virt_to_phys(vaddr);
 		if (zero)
 			memset((void *)vaddr, 0, *sz);
 		flush_dcache_range(vaddr, vaddr + *sz);
diff --git a/drivers/staging/fsl_qbman/bman_high.c b/drivers/staging/fsl_qbman/bman_high.c
index 49654cd..dfca3e0 100644
--- a/drivers/staging/fsl_qbman/bman_high.c
+++ b/drivers/staging/fsl_qbman/bman_high.c
@@ -852,7 +852,7 @@ static inline int __bman_release(struct bman_pool *pool,
 	r->bufs[0].opaque =  r->bufs[0].opaque |
 		((cpu_to_be64((bufs[0].opaque |
 			      ((u64)pool->params.bpid<<48))
-			      & 0x0fffffffffffffff)));
+			      & 0x00ffffffffffffff)));
 	if (i) {
 		for (i = 1; i < num; i++)
 			r->bufs[i].opaque =
diff --git a/drivers/staging/fsl_qbman/dpa_sys_arm64.h b/drivers/staging/fsl_qbman/dpa_sys_arm64.h
index 9ca2ab88..5ae07e3 100644
--- a/drivers/staging/fsl_qbman/dpa_sys_arm64.h
+++ b/drivers/staging/fsl_qbman/dpa_sys_arm64.h
@@ -102,6 +102,7 @@ static inline void flush_dcache_range(unsigned long start, unsigned long stop)
 
 /* TBD - may need to deal with this for ARM */
 #define ioremap_prot(addr, sz, prot) ioremap(addr, sz)
+#define pgprot_cached_noncoherent(prot)  pgprot_dmacoherent(prot)
 
 #define hard_smp_processor_id() raw_smp_processor_id()
 
diff --git a/drivers/staging/fsl_qbman/fsl_usdpaa.c b/drivers/staging/fsl_qbman/fsl_usdpaa.c
index 5f2459f..7678db2 100644
--- a/drivers/staging/fsl_qbman/fsl_usdpaa.c
+++ b/drivers/staging/fsl_qbman/fsl_usdpaa.c
@@ -8,9 +8,6 @@
  * kind, whether express or implied.
  */
 
-#include <linux/fsl_usdpaa.h>
-#include "bman_low.h"
-#include "qman_low.h"
 
 #include <linux/miscdevice.h>
 #include <linux/fs.h>
@@ -21,6 +18,11 @@
 #include <linux/slab.h>
 #include <linux/mman.h>
 
+#include "dpa_sys.h"
+#include <linux/fsl_usdpaa.h>
+#include "bman_low.h"
+#include "qman_low.h"
+
 /* Physical address range of the memory reservation, exported for mm/mem.c */
 static u64 phys_start;
 static u64 phys_size;
@@ -1794,32 +1796,42 @@ static __init int usdpaa_mem(char *arg)
 }
 early_param("usdpaa_mem", usdpaa_mem);
 
-__init void fsl_usdpaa_init_early(void)
+__init int fsl_usdpaa_init_early(void)
 {
+	void *virt;
 	if (!phys_size) {
 		pr_info("No USDPAA memory, no 'usdpaa_mem' bootarg\n");
-		return;
+		return 0;
 	}
 	if (phys_size % PAGE_SIZE) {
 		pr_err("'usdpaa_mem' bootarg must be a multiple of page size\n");
 		phys_size = 0;
-		return;
+		return 0;
 	}
-	phys_start = __memblock_alloc_base(phys_size,
+	/* phys_start = __memblock_alloc_base(phys_size,
 					   largest_page_size(phys_size),
 					   MEMBLOCK_ALLOC_ACCESSIBLE);
+	*/
+	virt = kmalloc(phys_size, GFP_KERNEL);
+	if (virt)
+		phys_start = virt_to_phys(virt);
 	if (!phys_start) {
 		pr_err("Failed to reserve USDPAA region (sz:%llx)\n",
 		       phys_size);
-		return;
+		return 0;
 	}
 	pfn_start = phys_start >> PAGE_SHIFT;
 	pfn_size = phys_size >> PAGE_SHIFT;
+#ifdef CONFIG_PPC
 	first_tlb = current_tlb = tlbcam_index;
 	tlbcam_index += num_tlb;
+#endif
 	pr_info("USDPAA region at %llx:%llx(%lx:%lx), %d TLB1 entries)\n",
 		phys_start, phys_size, pfn_start, pfn_size, num_tlb);
+	return 0;
 }
+subsys_initcall(fsl_usdpaa_init_early);
+
 
 static int __init usdpaa_init(void)
 {
diff --git a/drivers/staging/fsl_qbman/fsl_usdpaa_irq.c b/drivers/staging/fsl_qbman/fsl_usdpaa_irq.c
index 1f8260b..b13ba32 100644
--- a/drivers/staging/fsl_qbman/fsl_usdpaa_irq.c
+++ b/drivers/staging/fsl_qbman/fsl_usdpaa_irq.c
@@ -59,6 +59,7 @@ struct usdpaa_irq_ctx {
 	spinlock_t lock;
 	void *inhibit_addr; /* inhibit register address */
 	struct file *usdpaa_filp;
+	char irq_name[128];
 };
 
 static int usdpaa_irq_open(struct inode *inode, struct file *filp)
@@ -101,6 +102,7 @@ static irqreturn_t usdpaa_irq_handler(int irq, void *_ctx)
 	/* Set the inhibit register.  This will be reenabled
 	   once the USDPAA code handles the IRQ */
 	out_be32(ctx->inhibit_addr, 0x1);
+	pr_info("Inhibit at %p count %d", ctx->inhibit_addr, ctx->irq_count);
 	return IRQ_HANDLED;
 }
 
@@ -131,8 +133,11 @@ static int map_irq(struct file *fp, struct usdpaa_ioctl_irq_map *irq_map)
 
 	ctx->irq_set = 1;
 
+	snprintf(ctx->irq_name, sizeof(ctx->irq_name),
+		 "usdpaa_irq %d", ctx->irq_num);
+
 	ret = request_irq(ctx->irq_num, usdpaa_irq_handler, 0,
-			  "usdpaa_irq", ctx);
+			  ctx->irq_name, ctx);
 	if (ret) {
 		pr_err("USDPAA request_irq(%d) failed, ret= %d\n",
 		       ctx->irq_num, ret);
diff --git a/drivers/staging/fsl_qbman/qman_config.c b/drivers/staging/fsl_qbman/qman_config.c
index 60ce2e9..069b5a9 100644
--- a/drivers/staging/fsl_qbman/qman_config.c
+++ b/drivers/staging/fsl_qbman/qman_config.c
@@ -709,6 +709,10 @@ int qman_init_ccsr(struct device_node *node)
 		return 0;
 	if (node != qm_node)
 		return -EINVAL;
+	/* TEMP for LS1043 : should be done in uboot */
+	qm_out(QCSP_BARE, 0x5);
+	qm_out(QCSP_BAR, 0x0);
+
 	/* FQD memory */
 	qm_set_memory(qm, qm_memory_fqd, fqd_a, 1, 0, 0, fqd_sz);
 	/* PFDR memory */
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index 48ab5cf..0cba7e2 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -364,7 +364,8 @@ static void qman_get_ip_revision(struct device_node *dn)
 static struct qm_portal_config * __init parse_pcfg(struct device_node *node)
 {
 	struct qm_portal_config *pcfg;
-	const u32 *index, *channel;
+	const u32 *index_p, *channel_p;
+	u32 index, channel;
 	int irq, ret;
 
 	pcfg = kmalloc(sizeof(*pcfg), GFP_KERNEL);
@@ -401,25 +402,30 @@ static struct qm_portal_config * __init parse_pcfg(struct device_node *node)
 			"reg::CI");
 		goto err;
 	}
-	index = of_get_property(node, "cell-index", &ret);
-	if (!index || (ret != 4)) {
+	index_p = of_get_property(node, "cell-index", &ret);
+	if (!index_p || (ret != 4)) {
 		pr_err("Can't get %s property '%s'\n", node->full_name,
 			"cell-index");
 		goto err;
 	}
-	if (*index >= qman_portal_max)
+	index = be32_to_cpu(*index_p);
+	if (index >= qman_portal_max) {
+		pr_err("QMan portal index %d is beyond max (%d)\n",
+		       index, qman_portal_max);
 		goto err;
+	}
 
-	channel = of_get_property(node, "fsl,qman-channel-id", &ret);
-	if (!channel || (ret != 4)) {
+	channel_p = of_get_property(node, "fsl,qman-channel-id", &ret);
+	if (!channel_p || (ret != 4)) {
 		pr_err("Can't get %s property '%s'\n", node->full_name,
 			"fsl,qman-channel-id");
 		goto err;
 	}
-	if (*channel != (*index + QM_CHANNEL_SWPORTAL0))
+	channel = be32_to_cpu(*channel_p);
+	if (channel != (index + QM_CHANNEL_SWPORTAL0))
 		pr_err("Warning: node %s has mismatched %s and %s\n",
 			node->full_name, "cell-index", "fsl,qman-channel-id");
-	pcfg->public_cfg.channel = *channel;
+	pcfg->public_cfg.channel = channel;
 	pcfg->public_cfg.cpu = -1;
 	irq = irq_of_parse_and_map(node, 0);
 	if (irq == 0) {
@@ -428,7 +434,7 @@ static struct qm_portal_config * __init parse_pcfg(struct device_node *node)
 		goto err;
 	}
 	pcfg->public_cfg.irq = irq;
-	pcfg->public_cfg.index = *index;
+	pcfg->public_cfg.index = index;
 #ifdef CONFIG_FSL_QMAN_CONFIG
 	/* We need the same LIODN offset for all portals */
 	qman_liodn_fixup(pcfg->public_cfg.channel);
@@ -786,6 +792,7 @@ __init int qman_init(void)
 		if (!of_device_is_available(dn))
 			continue;
 		pcfg = parse_pcfg(dn);
+		pr_info("Parse QMan portal irq %d\n", pcfg->public_cfg.irq);
 		if (pcfg) {
 			pcfg->public_cfg.pools = pools_sdqcr;
 			list_add_tail(&pcfg->list, &unused_pcfgs);
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index d6f50a4..83e8ad8 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -302,7 +302,7 @@ static inline void hw_fqd_to_cpu(struct qm_fqd *fqd)
 /* Swap a 40 bit address */
 static inline u64 cpu_to_be40(u64 in)
 {
-	u64 out;
+	u64 out = 0;
 	u8 *p = (u8 *) &out;
 	p[0] = in >> 32;
 	p[1] = in >> 24;
@@ -324,6 +324,28 @@ static inline u64 be40_to_cpu(u64 in)
 	return out;
 }
 
+/* Swap a 24 bit value */
+static inline u32 cpu_to_be24(u32 in)
+{
+	u32 out = 0;
+	u8 *p = (u8 *) &out;
+	p[0] = in >> 16;
+	p[1] = in >> 8;
+	p[2] = in >> 0;
+	return out;
+}
+
+static inline u32 be24_to_cpu(u32 in)
+{
+	u32 out = 0;
+	u8 *pout = (u8 *) &out;
+	u8 *pin = (u8 *) &in;
+	pout[0] = pin[2];
+	pout[1] = pin[1];
+	pout[2] = pin[0];
+	return out;
+}
+
 static inline void cpu_to_hw_fd(struct qm_fd *fd)
 {
 	fd->addr = cpu_to_be40(fd->addr);
@@ -1913,14 +1935,15 @@ int qman_query_fq(struct qman_fq *fq, struct qm_fqd *fqd)
 
 	PORTAL_IRQ_LOCK(p, irqflags);
 	mcc = qm_mc_start(&p->p);
-	mcc->queryfq.fqid = fq->fqid;
+	mcc->queryfq.fqid = cpu_to_be32(fq->fqid);
 	qm_mc_commit(&p->p, QM_MCC_VERB_QUERYFQ);
 	while (!(mcr = qm_mc_result(&p->p)))
 		cpu_relax();
 	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) == QM_MCR_VERB_QUERYFQ);
 	res = mcr->result;
 	if (res == QM_MCR_RESULT_OK)
-		*fqd = mcr->queryfq.fqd;
+		memcpy_fromio(fqd, &mcr->queryfq.fqd, sizeof(*fqd));
+	hw_fqd_to_cpu(fqd);
 	PORTAL_IRQ_UNLOCK(p, irqflags);
 	put_affine_portal();
 	if (res != QM_MCR_RESULT_OK)
@@ -1945,8 +1968,29 @@ int qman_query_fq_np(struct qman_fq *fq, struct qm_mcr_queryfq_np *np)
 		cpu_relax();
 	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) == QM_MCR_VERB_QUERYFQ_NP);
 	res = mcr->result;
-	if (res == QM_MCR_RESULT_OK)
-		*np = mcr->queryfq_np;
+	if (res == QM_MCR_RESULT_OK) {
+		memcpy_fromio(np, &mcr->queryfq_np, sizeof(*np));
+		np->fqd_link = be24_to_cpu(np->fqd_link);
+		np->odp_seq = be16_to_cpu(np->odp_seq);
+		np->orp_nesn = be16_to_cpu(np->orp_nesn);
+		np->orp_ea_hseq  = be16_to_cpu(np->orp_ea_hseq);
+		np->orp_ea_tseq  = be16_to_cpu(np->orp_ea_tseq);
+		np->orp_ea_hptr = be24_to_cpu(np->orp_ea_hptr);
+		np->orp_ea_tptr = be24_to_cpu(np->orp_ea_tptr);
+		np->pfdr_hptr = be24_to_cpu(np->pfdr_hptr);
+		np->pfdr_tptr = be24_to_cpu(np->pfdr_tptr);
+		np->ics_surp = be16_to_cpu(np->ics_surp);
+		np->byte_cnt = be32_to_cpu(np->byte_cnt);
+		np->frm_cnt = be24_to_cpu(np->frm_cnt);
+		np->ra1_sfdr = be16_to_cpu(np->ra1_sfdr);
+		np->ra2_sfdr = be16_to_cpu(np->ra2_sfdr);
+		np->od1_sfdr = be16_to_cpu(np->od1_sfdr);
+		np->od2_sfdr = be16_to_cpu(np->od2_sfdr);
+		np->od3_sfdr = be16_to_cpu(np->od3_sfdr);
+
+
+	}
+
 	PORTAL_IRQ_UNLOCK(p, irqflags);
 	put_affine_portal();
 	if (res == QM_MCR_RESULT_ERR_FQID)
@@ -1976,7 +2020,7 @@ int qman_query_wq(u8 query_dedicated, struct qm_mcr_querywq *wq)
 	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) == myverb);
 	res = mcr->result;
 	if (res == QM_MCR_RESULT_OK)
-		*wq = mcr->querywq;
+		memcpy_fromio(wq, &mcr->querywq, sizeof(*wq));
 	PORTAL_IRQ_UNLOCK(p, irqflags);
 	put_affine_portal();
 	if (res != QM_MCR_RESULT_OK) {
@@ -2007,7 +2051,7 @@ int qman_testwrite_cgr(struct qman_cgr *cgr, u64 i_bcnt,
 	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) == QM_MCC_VERB_CGRTESTWRITE);
 	res = mcr->result;
 	if (res == QM_MCR_RESULT_OK)
-		*result = mcr->cgrtestwrite;
+		memcpy_fromio(result,  &mcr->cgrtestwrite, sizeof(*result));
 	PORTAL_IRQ_UNLOCK(p, irqflags);
 	put_affine_portal();
 	if (res != QM_MCR_RESULT_OK) {
@@ -2035,7 +2079,7 @@ int qman_query_cgr(struct qman_cgr *cgr, struct qm_mcr_querycgr *cgrd)
 	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) == QM_MCC_VERB_QUERYCGR);
 	res = mcr->result;
 	if (res == QM_MCR_RESULT_OK)
-		*cgrd = mcr->querycgr;
+		memcpy_fromio(cgrd, &mcr->querycgr, sizeof(*cgrd));
 	PORTAL_IRQ_UNLOCK(p, irqflags);
 	put_affine_portal();
 	if (res != QM_MCR_RESULT_OK) {
@@ -2062,7 +2106,8 @@ int qman_query_congestion(struct qm_mcr_querycongestion *congestion)
 			QM_MCC_VERB_QUERYCONGESTION);
 	res = mcr->result;
 	if (res == QM_MCR_RESULT_OK)
-		*congestion = mcr->querycongestion;
+		memcpy_fromio(congestion, &mcr->querycongestion,
+			      sizeof(*congestion));
 	PORTAL_IRQ_UNLOCK(p, irqflags);
 	put_affine_portal();
 	if (res != QM_MCR_RESULT_OK) {
diff --git a/drivers/staging/fsl_qbman/qman_test_high.c b/drivers/staging/fsl_qbman/qman_test_high.c
index 45a459b..a9462f1 100644
--- a/drivers/staging/fsl_qbman/qman_test_high.c
+++ b/drivers/staging/fsl_qbman/qman_test_high.c
@@ -185,6 +185,8 @@ static enum qman_cb_dqrr_result cb_dqrr(struct qman_portal *p,
 {
 	if (fd_cmp(&fd_dq, &dq->fd)) {
 		pr_err("BADNESS: dequeued frame doesn't match;\n");
+		pr_err("Expected 0x%llx, got 0x%llx\n",
+		       fd_dq.length29, dq->fd.length29);
 		BUG();
 	}
 	fd_inc(&fd_dq);
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index 205af44..ddcc877 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -1076,6 +1076,7 @@ struct qm_mcr_queryfq {
 struct qm_mcr_queryfq_np {
 	u8 __reserved1;
 	u8 state;	/* QM_MCR_NP_STATE_*** */
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 	u8 __reserved2;
 	u32 fqd_link:24;
 	u16 __reserved3:2;
@@ -1108,7 +1109,52 @@ struct qm_mcr_queryfq_np {
 	u16 od1_sfdr;	/* QM_MCR_NP_OD1_*** */
 	u16 od2_sfdr;	/* QM_MCR_NP_OD2_*** */
 	u16 od3_sfdr;	/* QM_MCR_NP_OD3_*** */
+#else
+	u8 __reserved2;
+	u32 fqd_link:24;
+
+	u16 odp_seq:14;
+	u16 __reserved3:2;
+
+	u16 orp_nesn:14;
+	u16 __reserved4:2;
+
+	u16 orp_ea_hseq:15;
+	u16 __reserved5:1;
+
+	u16 orp_ea_tseq:15;
+	u16 __reserved6:1;
+
+	u8 __reserved7;
+	u32 orp_ea_hptr:24;
+
+	u8 __reserved8;
+	u32 orp_ea_tptr:24;
+
+	u8 __reserved9;
+	u32 pfdr_hptr:24;
+
+	u8 __reserved10;
+	u32 pfdr_tptr:24;
+
+	u8 __reserved11[5];
+	u8 is:1;
+	u8 __reserved12:7;
+	u16 ics_surp;
+	u32 byte_cnt;
+	u8 __reserved13;
+	u32 frm_cnt:24;
+	u32 __reserved14;
+	u16 ra1_sfdr;	/* QM_MCR_NP_RA1_*** */
+	u16 ra2_sfdr;	/* QM_MCR_NP_RA2_*** */
+	u16 __reserved15;
+	u16 od1_sfdr;	/* QM_MCR_NP_OD1_*** */
+	u16 od2_sfdr;	/* QM_MCR_NP_OD2_*** */
+	u16 od3_sfdr;	/* QM_MCR_NP_OD3_*** */
+#endif
 } __packed;
+
+
 struct qm_mcr_alterfq {
 	u8 fqs;		/* Frame Queue Status */
 	u8 __reserved1[61];
diff --git a/include/linux/fsl_usdpaa.h b/include/linux/fsl_usdpaa.h
index 896c03a..381853d 100644
--- a/include/linux/fsl_usdpaa.h
+++ b/include/linux/fsl_usdpaa.h
@@ -311,7 +311,7 @@ struct compat_ioctl_raw_portal {
 #ifdef __KERNEL__
 
 /* Early-boot hook */
-void __init fsl_usdpaa_init_early(void);
+int __init fsl_usdpaa_init_early(void);
 
 /* Fault-handling in arch/powerpc/mm/mem.c gives USDPAA an opportunity to detect
  * faults within its ranges via this hook. */
-- 
1.7.5.4

