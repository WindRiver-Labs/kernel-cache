From a84d81136970c0d345fddb5f8a8d3c60cfabf4ff Mon Sep 17 00:00:00 2001
From: Yuan Yao <yao.yuan@freescale.com>
Date: Fri, 23 Jan 2015 17:16:24 +0800
Subject: [PATCH 109/451] serial: fsl-lpuart: disable interrupt when suspend

commit 2fe605df325abfa2d36f63469fa960cd40d8cf50 upstream

For power management support, we should disable TX and
TX interrupt so that kernel can prepare for deep sleep.

Retain RX and RX interrupt for wakeup the kernel when
receive the input character.

Signed-off-by: Yuan Yao <yao.yuan@freescale.com>
Change-Id: I5fd917c5c68da9a2ba16c3d1237f3f38e343539d
Reviewed-on: http://git.am.freescale.net:8181/28842
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Zhengxiong Jin <Jason.Jin@freescale.com>
Signed-off-by: Shaohui Xie <Shaohui.Xie@freescale.com>
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/tty/serial/fsl_lpuart.c |   25 ++++++++++++++++++++++++-
 1 files changed, 24 insertions(+), 1 deletions(-)

diff --git a/drivers/tty/serial/fsl_lpuart.c b/drivers/tty/serial/fsl_lpuart.c
index 501c465..02c3972 100644
--- a/drivers/tty/serial/fsl_lpuart.c
+++ b/drivers/tty/serial/fsl_lpuart.c
@@ -383,7 +383,7 @@ static int lpuart_startup(struct uart_port *port)
 	unsigned long flags;
 	unsigned char temp;
 
-	ret = devm_request_irq(port->dev, port->irq, lpuart_int, 0,
+	ret = devm_request_irq(port->dev, port->irq, lpuart_int, IRQF_NO_SUSPEND,
 				DRIVER_NAME, sport);
 	if (ret)
 		return ret;
@@ -805,6 +805,12 @@ static int lpuart_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	/*
+	 * Make device's PM flags reflect the wake-up capability, but
+	 * let the user space enable it to wake up the system as needed.
+	 */
+	device_set_wakeup_capable(&pdev->dev, true);
+
 	return 0;
 }
 
@@ -823,6 +829,23 @@ static int lpuart_remove(struct platform_device *pdev)
 static int lpuart_suspend(struct device *dev)
 {
 	struct lpuart_port *sport = dev_get_drvdata(dev);
+	unsigned long temp;
+
+	if (sport->lpuart32) {
+		/* disable Rx/Tx and interrupts */
+		temp = lpuart32_read(sport->port.membase + UARTCTRL);
+		temp &= ~(UARTCTRL_TE | UARTCTRL_TIE | UARTCTRL_TCIE);
+		if (!device_may_wakeup(dev))
+			temp &= ~(UARTCTRL_RIE | UARTCTRL_RE);
+		lpuart32_write(temp, sport->port.membase + UARTCTRL);
+	} else {
+		/* disable Rx/Tx and interrupts */
+		temp = readb(sport->port.membase + UARTCR2);
+		temp &= ~(UARTCR2_TE | UARTCR2_TIE | UARTCR2_TCIE);
+		if (!device_may_wakeup(dev))
+			temp &= ~(UARTCR2_RIE | UARTCR2_RE);
+		writeb(temp, sport->port.membase + UARTCR2);
+	}
 
 	uart_suspend_port(&lpuart_reg, &sport->port);
 
-- 
1.7.5.4

