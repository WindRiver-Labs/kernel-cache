From 8a3f85df5abcb6ec0c4f8a781bd527cceaa5ffc2 Mon Sep 17 00:00:00 2001
From: Alex Porosanu <alexandru.porosanu@freescale.com>
Date: Wed, 22 Apr 2015 13:05:56 +0300
Subject: [PATCH 267/451] crypto: caam - add endianness support in DCL

DCL was designed to work for SEC which runs descriptors
written in the same endianness as the core. There are
parts where this no longer holds true, so some changes
are required in the DCL.

Change-Id: I2ed86665c0a60e889f9f05a221225b399f15512c
Signed-off-by: Alex Porosanu <alexandru.porosanu@freescale.com>
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/crypto/caam/desc_constr.h |   41 ++++++++++++++++++++++++++----------
 1 files changed, 29 insertions(+), 12 deletions(-)

diff --git a/drivers/crypto/caam/desc_constr.h b/drivers/crypto/caam/desc_constr.h
index 1a20bb7..2e51242 100644
--- a/drivers/crypto/caam/desc_constr.h
+++ b/drivers/crypto/caam/desc_constr.h
@@ -7,6 +7,7 @@
 #ifndef _DESC_CONSTR_H_
 #define _DESC_CONSTR_H_
 #include "desc.h"
+#include "regs.h" /* Needed for mixed endianness support */
 
 #define IMMEDIATE (1 << 23)
 #define CAAM_CMD_SZ sizeof(u32)
@@ -34,7 +35,7 @@
 
 static inline int desc_len(u32 *desc)
 {
-	return *desc & HDR_DESCLEN_MASK;
+	return rd_en_val32(*desc) & HDR_DESCLEN_MASK;
 }
 
 static inline int desc_bytes(void *desc)
@@ -54,7 +55,7 @@ static inline void *sh_desc_pdb(u32 *desc)
 
 static inline void init_desc(u32 *desc, u32 options)
 {
-	*desc = (options | HDR_ONE) + 1;
+	*desc = wr_en_val32((options | HDR_ONE) + 1);
 }
 
 static inline void init_sh_desc(u32 *desc, u32 options)
@@ -80,9 +81,10 @@ static inline void append_ptr(u32 *desc, dma_addr_t ptr)
 {
 	dma_addr_t *offset = (dma_addr_t *)desc_end(desc);
 
-	*offset = ptr;
+	*offset = wr_en_val64(ptr);
 
-	(*desc) += CAAM_PTR_SZ / CAAM_CMD_SZ;
+	(*desc) = wr_en_val32(rd_en_val32(*desc) +
+			       CAAM_PTR_SZ / CAAM_CMD_SZ);
 }
 
 static inline void init_job_desc_shared(u32 *desc, dma_addr_t ptr, int len,
@@ -101,16 +103,17 @@ static inline void append_data(u32 *desc, void *data, int len)
 	if (len) /* avoid sparse warning: memcpy with byte count of 0 */
 		memcpy(offset, data, len);
 
-	(*desc) += (len + CAAM_CMD_SZ - 1) / CAAM_CMD_SZ;
+	(*desc) = wr_en_val32(rd_en_val32(*desc) +
+			      (len + CAAM_CMD_SZ - 1) / CAAM_CMD_SZ);
 }
 
 static inline void append_cmd(u32 *desc, u32 command)
 {
 	u32 *cmd = desc_end(desc);
 
-	*cmd = command;
+	*cmd = wr_en_val32(command);
 
-	(*desc)++;
+	(*desc) = wr_en_val32(rd_en_val32(*desc) + 1);
 }
 
 #define append_u32 append_cmd
@@ -118,17 +121,20 @@ static inline void append_cmd(u32 *desc, u32 command)
 static inline void append_u64(u32 *desc, u64 data)
 {
 	u32 *offset = desc_end(desc);
-
+#ifdef __BIG_ENDIAN
 	*offset = upper_32_bits(data);
 	*(++offset) = lower_32_bits(data);
-
-	(*desc) += 2;
+#else
+	*offset = lower_32_bits(data);
+	*(++offset) = upper_32_bits(data);
+#endif
+	(*desc) = wr_en_val32(rd_en_val32(*desc) + 2);
 }
 
 /* Write command without affecting header, and return pointer to next word */
 static inline u32 *write_cmd(u32 *desc, u32 command)
 {
-	*desc = command;
+	*desc = wr_en_val32(command);
 
 	return desc + 1;
 }
@@ -169,9 +175,20 @@ static inline u32 *append_jump(u32 *desc, u32 options)
 
 static inline void set_jump_tgt_here(u32 *desc, u32 *jump_cmd)
 {
-	*jump_cmd = *jump_cmd | (desc_len(desc) - (jump_cmd - desc));
+	*jump_cmd = wr_en_val32(rd_en_val32(*jump_cmd) |
+				(desc_len(desc) - (jump_cmd - desc)));
 }
 
+static inline void set_move_tgt_here(u32 *desc, u32 *move_cmd)
+{
+	u32 val = rd_en_val32(*move_cmd);
+
+	val &= ~MOVE_OFFSET_MASK;
+	val |= (desc_len(desc) << (MOVE_OFFSET_SHIFT + 2)) &
+				    MOVE_OFFSET_MASK;
+	*move_cmd = wr_en_val32(val);
+}
+ 
 #define APPEND_CMD(cmd, op) \
 static inline void append_##cmd(u32 *desc, u32 options) \
 { \
-- 
1.7.5.4

