From fc73c75f94a361b66d997047134b7b102fdc34e6 Mon Sep 17 00:00:00 2001
From: Roy Pledge <Roy.Pledge@freescale.com>
Date: Thu, 28 May 2015 16:03:22 -0400
Subject: [PATCH 166/451] fsl_qbman: Update cache operations for ARM

Ensure QBMan portals are mapped with the correct cache attributes
and that the correct cache manipulation instructions are in place

Signed-off-by: Roy Pledge <Roy.Pledge@freescale.com>
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/staging/fsl_qbman/bman_driver.c   |   10 ++++------
 drivers/staging/fsl_qbman/dpa_sys_arm64.h |   24 ++++++++----------------
 drivers/staging/fsl_qbman/qman_driver.c   |   11 +++++------
 3 files changed, 17 insertions(+), 28 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_driver.c b/drivers/staging/fsl_qbman/bman_driver.c
index 4f68a62..50df524 100644
--- a/drivers/staging/fsl_qbman/bman_driver.c
+++ b/drivers/staging/fsl_qbman/bman_driver.c
@@ -185,14 +185,12 @@ static struct bm_portal_config * __init parse_pcfg(struct device_node *node)
 	pcfg->public_cfg.index = be32_to_cpu(*index);
 	bman_depletion_fill(&pcfg->public_cfg.mask);
 
-	pcfg->addr_virt[DPA_PORTAL_CE] = ioremap_prot(
+	pcfg->addr_virt[DPA_PORTAL_CE] = ioremap_cache_ns(
 				pcfg->addr_phys[DPA_PORTAL_CE].start,
-				resource_size(&pcfg->addr_phys[DPA_PORTAL_CE]),
-				0);
-	pcfg->addr_virt[DPA_PORTAL_CI] = ioremap_prot(
+				resource_size(&pcfg->addr_phys[DPA_PORTAL_CE]));
+	pcfg->addr_virt[DPA_PORTAL_CI] = ioremap(
 				pcfg->addr_phys[DPA_PORTAL_CI].start,
-				resource_size(&pcfg->addr_phys[DPA_PORTAL_CI]),
-				_PAGE_GUARDED | _PAGE_NO_CACHE);
+				resource_size(&pcfg->addr_phys[DPA_PORTAL_CI]));
 	/* disable bp depletion */
 	__raw_writel(0x0, pcfg->addr_virt[DPA_PORTAL_CI] + BM_REG_SCN(0));
 	__raw_writel(0x0, pcfg->addr_virt[DPA_PORTAL_CI] + BM_REG_SCN(1));
diff --git a/drivers/staging/fsl_qbman/dpa_sys_arm64.h b/drivers/staging/fsl_qbman/dpa_sys_arm64.h
index 9ca2ab88..0f32db4 100644
--- a/drivers/staging/fsl_qbman/dpa_sys_arm64.h
+++ b/drivers/staging/fsl_qbman/dpa_sys_arm64.h
@@ -41,33 +41,28 @@
  * barriers and that dcb*() won't fall victim to compiler or execution
  * reordering with respect to other code/instructions that manipulate the same
  * cacheline. */
-#define hwsync() smp_mb()
-#define lwsync() hwsync()
-#define dcbf(p) __flush_dcache_area((void *) p, 64)
-#define dcbt_ro(p) prefetch((void *)p)
-#define dcbt_rw(p) prefetch((void *)p)
-#define dcbi(p) dcbf(p)
-
-#define dcbz(p) memset((void *) p, 0, 32);
+#define hwsync() { asm volatile("dmb st" : : : "memory"); }
+#define lwsync() { asm volatile("dmb st" : : : "memory"); }
+#define dcbf(p) { asm volatile("dc cvac, %0;" : : "r" (p) : "memory"); }
+#define dcbt_ro(p) { asm volatile("prfm pldl1keep, [%0, #64]" : : "r" (p)); }
+#define dcbt_rw(p) { asm volatile("prfm pldl1keep, [%0, #64]" : : "r" (p)); }
+#define dcbi(p) { asm volatile("dc ivac, %0" : : "r"(p) : "memory"); }
+#define dcbz(p) { asm volatile("dc zva, %0" : : "r" (p) : "memory"); }
 
 #define dcbz_64(p) \
 	do { \
-		dcbz((void *)p + 32);	\
 		dcbz(p);	\
 	} while (0)
 
 #define dcbf_64(p) \
 	do { \
-		dcbf((void *)p + 32); \
 		dcbf(p); \
 	} while (0)
 /* Commonly used combo */
 #define dcbit_ro(p) \
 	do { \
 		dcbi(p); \
-		dcbi((const void *)p + 32); \
 		dcbt_ro(p); \
-		dcbt_ro((const void *)p + 32); \
 	} while (0)
 
 static inline u64 mfatb(void)
@@ -97,12 +92,9 @@ static inline void clear_bits(unsigned long mask, volatile unsigned long *p)
 
 static inline void flush_dcache_range(unsigned long start, unsigned long stop)
 {
-	/* TBD: Need to imlempent for ARM */
+	__flush_dcache_area((void *) start, stop - start + 1);
 }
 
-/* TBD - may need to deal with this for ARM */
-#define ioremap_prot(addr, sz, prot) ioremap(addr, sz)
-
 #define hard_smp_processor_id() raw_smp_processor_id()
 
 
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index 2007382..e072afe 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -444,14 +444,13 @@ static struct qm_portal_config * __init parse_pcfg(struct device_node *node)
 	qman_liodn_fixup(pcfg->public_cfg.channel);
 #endif
 
-	pcfg->addr_virt[DPA_PORTAL_CE] = ioremap_prot(
+	pcfg->addr_virt[DPA_PORTAL_CE] = ioremap_cache_ns(
 				pcfg->addr_phys[DPA_PORTAL_CE].start,
-				resource_size(&pcfg->addr_phys[DPA_PORTAL_CE]),
-				0);
-	pcfg->addr_virt[DPA_PORTAL_CI] = ioremap_prot(
+				resource_size(&pcfg->addr_phys[DPA_PORTAL_CE]));
+
+	pcfg->addr_virt[DPA_PORTAL_CI] = ioremap(
 				pcfg->addr_phys[DPA_PORTAL_CI].start,
-				resource_size(&pcfg->addr_phys[DPA_PORTAL_CI]),
-				_PAGE_GUARDED | _PAGE_NO_CACHE);
+				resource_size(&pcfg->addr_phys[DPA_PORTAL_CI]));
 
 	return pcfg;
 err:
-- 
1.7.5.4

