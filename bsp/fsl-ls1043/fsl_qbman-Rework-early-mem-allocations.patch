From 7e2d1db31e0662b6725e76c69ec50c18b7aaba9a Mon Sep 17 00:00:00 2001
From: Roy Pledge <Roy.Pledge@freescale.com>
Date: Fri, 22 May 2015 12:16:06 -0400
Subject: [PATCH 156/451] fsl_qbman: Rework early mem allocations

Change the early memory allocations done for QBMan to use the
of_reserved_mem Linux system. This resolves some issues related
to memory setup on ARM as well as aligns the code with the
mechanisms that are being upstreamed

Signed-off-by: Roy Pledge <Roy.Pledge@freescale.com>
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 arch/arm64/boot/dts/freescale/fsl-ls1043a.dtsi |   35 ++++++++++
 drivers/staging/fsl_qbman/bman_config.c        |   76 ++++------------------
 drivers/staging/fsl_qbman/fsl_usdpaa.c         |    7 +--
 drivers/staging/fsl_qbman/qbman_driver.c       |    3 -
 drivers/staging/fsl_qbman/qman_config.c        |   80 ++++++++++-------------
 5 files changed, 85 insertions(+), 116 deletions(-)

diff --git a/arch/arm64/boot/dts/freescale/fsl-ls1043a.dtsi b/arch/arm64/boot/dts/freescale/fsl-ls1043a.dtsi
index b1ee7b1..6f1e65a 100644
--- a/arch/arm64/boot/dts/freescale/fsl-ls1043a.dtsi
+++ b/arch/arm64/boot/dts/freescale/fsl-ls1043a.dtsi
@@ -711,6 +711,41 @@
 	bportals: bman-portals@508000000 {
 		   ranges = <0x0 0x5 0x08000000 0x8000000>;
         };
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		bman_fbpr: bman-fbpr {
+			size = <0 0x1000000>;
+			alignment = <0 0x1000000>;
+		};
+		qman_fqd: qman-fqd {
+			size = <0 0x400000>;
+			alignment = <0 0x400000>;
+		};
+		qman_pfdr: qman-pfdr {
+			size = <0 0x2000000>;
+			alignment = <0 0x2000000>;
+		};
+	};
 };
+
+&bman_fbpr {
+	compatible = "fsl,bman-fbpr";
+	alloc-ranges = <0 0 0x10000 0>;
+};
+
+&qman_fqd {
+	compatible = "fsl,qman-fqd";
+	alloc-ranges = <0 0 0x10000 0>;
+};
+
+&qman_pfdr {
+	compatible = "fsl,qman-pfdr";
+	alloc-ranges = <0 0 0x10000 0>;
+};
+
+
 /include/ "qoriq-qman1-portals.dtsi"
 /include/ "qoriq-bman1-portals.dtsi"
diff --git a/drivers/staging/fsl_qbman/bman_config.c b/drivers/staging/fsl_qbman/bman_config.c
index 273b989..e3c92c4 100644
--- a/drivers/staging/fsl_qbman/bman_config.c
+++ b/drivers/staging/fsl_qbman/bman_config.c
@@ -31,6 +31,7 @@
 
 #include <asm/cacheflush.h>
 #include "bman_private.h"
+#include <linux/of_reserved_mem.h>
 
 /* Last updated for v00.79 of the BG */
 
@@ -251,65 +252,16 @@ static struct device_node *bm_node;
 static dma_addr_t fbpr_a;
 static size_t fbpr_sz = DEFAULT_FBPR_SZ;
 
-/* Parse the <name> property to extract the memory location and size and
- * memblock_reserve() it. If it isn't supplied, memblock_alloc() the default
- * size. Also flush this memory range from data cache so that BMAN originated
- * transactions for this memory region could be marked non-coherent.
- */
-static __init int parse_mem_property(struct device_node *node, const char *name,
-				dma_addr_t *addr, size_t *sz, int zero)
+static int bman_fbpr(struct reserved_mem *rmem)
 {
-	const u32 *pint;
-	int ret;
-	unsigned long vaddr;
-
-	pint = of_get_property(node, name, &ret);
-	if (!pint || (ret != 16)) {
-		pr_info("No %s property '%s', using memblock_alloc(%016zx)\n",
-				node->full_name, name, *sz);
-		/* TODO: memblock_alloc isn't working as expected
-		   on ARM - revert to kmalloc() until it gets
-		   resolved
-		   *addr = memblock_alloc(*sz, *sz);
-		   vaddr = (unsigned long)phys_to_virt(*addr);
-		*/
-		vaddr = kmalloc(*sz, GFP_KERNEL);
-		*addr = virt_to_phys(vaddr);
-		if (zero)
-			memset((void *)vaddr, 0, *sz);
-		flush_dcache_range(vaddr, vaddr + *sz);
-		return 0;
-	}
-	pr_info("Using %s property '%s'\n", node->full_name, name);
-	/* If using a "zero-pma", don't try to zero it, even if you asked */
-	if (zero && of_find_property(node, "zero-pma", &ret)) {
-		pr_info("  it's a 'zero-pma', not zeroing from s/w\n");
-		zero = 0;
-	}
-	*addr = ((u64)pint[0] << 32) | (u64)pint[1];
-	*sz = ((u64)pint[2] << 32) | (u64)pint[3];
-	/* Keep things simple, it's either all in the DRAM range or it's all
-	 * outside. */
-	if (*addr < memblock_end_of_DRAM()) {
-		BUG_ON((u64)*addr + (u64)*sz > memblock_end_of_DRAM());
-		if (memblock_reserve(*addr, *sz) < 0) {
-			pr_err("Failed to reserve %s\n", name);
-			return -ENOMEM;
-		}
-		vaddr = (unsigned long)phys_to_virt(*addr);
-		if (zero)
-			memset((void *)vaddr, 0, *sz);
-		flush_dcache_range(vaddr, vaddr + *sz);
-	} else if (zero) {
-		/* map as cacheable, non-guarded */
-		void __iomem *tmpp = ioremap_prot(*addr, *sz, 0);
-		memset_io(tmpp, 0, *sz);
-		vaddr = (unsigned long)tmpp;
-		flush_dcache_range(vaddr, vaddr + *sz);
-		iounmap(tmpp);
-	}
+	fbpr_a = rmem->base;
+	fbpr_sz = rmem->size;
+
+	WARN_ON(!(fbpr_a && fbpr_sz));
+
 	return 0;
 }
+RESERVEDMEM_OF_DECLARE(bman_fbpr, "fsl,bman-fbpr", bman_fbpr);
 
 static int __init fsl_bman_init(struct device_node *node)
 {
@@ -329,11 +281,6 @@ static int __init fsl_bman_init(struct device_node *node)
 	s = of_get_property(node, "fsl,hv-claimable", &ret);
 	if (s && !strcmp(s, "standby"))
 		standby = 1;
-	if (!standby) {
-		ret = parse_mem_property(node, "fsl,bman-fbpr",
-					&fbpr_a, &fbpr_sz, 0);
-		BUG_ON(ret);
-	}
 	/* Global configuration */
 	regs = ioremap(res.start, res.end - res.start + 1);
 	bm = bm_create(regs);
@@ -377,7 +324,7 @@ int bm_pool_set(u32 bpid, const u32 *thresholds)
 }
 EXPORT_SYMBOL(bm_pool_set);
 
-__init void bman_init_early(void)
+__init int bman_init_early(void)
 {
 	struct device_node *dn;
 	int ret;
@@ -394,7 +341,10 @@ __init void bman_init_early(void)
 			BUG_ON(ret);
 		}
 	}
+	return 0;
 }
+postcore_initcall_sync(bman_init_early);
+
 
 static void log_edata_bits(u32 bit_count)
 {
@@ -502,6 +452,8 @@ int bman_init_ccsr(struct device_node *node)
 		return -EINVAL;
 	/* FBPR memory */
 	bm_set_memory(bm, fbpr_a, 0, fbpr_sz);
+	pr_info("bman-fbpr addr 0x%llx size 0x%lx\n", fbpr_a, fbpr_sz);
+
 	ret = __bind_irq();
 	if (ret)
 		return ret;
diff --git a/drivers/staging/fsl_qbman/fsl_usdpaa.c b/drivers/staging/fsl_qbman/fsl_usdpaa.c
index 09d5b5c..5c6acf9 100644
--- a/drivers/staging/fsl_qbman/fsl_usdpaa.c
+++ b/drivers/staging/fsl_qbman/fsl_usdpaa.c
@@ -1798,7 +1798,6 @@ early_param("usdpaa_mem", usdpaa_mem);
 
 __init int fsl_usdpaa_init_early(void)
 {
-	void *virt;
 	if (!phys_size) {
 		pr_info("No USDPAA memory, no 'usdpaa_mem' bootarg\n");
 		return 0;
@@ -1808,13 +1807,9 @@ __init int fsl_usdpaa_init_early(void)
 		phys_size = 0;
 		return 0;
 	}
-	/* phys_start = __memblock_alloc_base(phys_size,
+	phys_start = __memblock_alloc_base(phys_size,
 					   largest_page_size(phys_size),
 					   MEMBLOCK_ALLOC_ACCESSIBLE);
-	*/
-	virt = kmalloc(phys_size, GFP_KERNEL);
-	if (virt)
-		phys_start = virt_to_phys(virt);
 	if (!phys_start) {
 		pr_err("Failed to reserve USDPAA region (sz:%llx)\n",
 		       phys_size);
diff --git a/drivers/staging/fsl_qbman/qbman_driver.c b/drivers/staging/fsl_qbman/qbman_driver.c
index 4b7e799..ab487d5 100644
--- a/drivers/staging/fsl_qbman/qbman_driver.c
+++ b/drivers/staging/fsl_qbman/qbman_driver.c
@@ -40,9 +40,6 @@ static __init int qbman_init(void)
 	struct device_node *dn;
 	u32 is_portal_available;
 
-	qman_init_early();
-	bman_init_early();
-
 	bman_init();
 	qman_init();
 
diff --git a/drivers/staging/fsl_qbman/qman_config.c b/drivers/staging/fsl_qbman/qman_config.c
index 069b5a9..34c12c4 100644
--- a/drivers/staging/fsl_qbman/qman_config.c
+++ b/drivers/staging/fsl_qbman/qman_config.c
@@ -32,6 +32,7 @@
 #include <asm/cacheflush.h>
 #include "qman_private.h"
 #include <linux/highmem.h>
+#include <linux/of_reserved_mem.h>
 
 /* Last updated for v00.800 of the BG */
 
@@ -428,6 +429,28 @@ static struct device_node *qm_node;
 static dma_addr_t fqd_a, pfdr_a;
 static size_t fqd_sz = DEFAULT_FQD_SZ, pfdr_sz = DEFAULT_PFDR_SZ;
 
+static int qman_fqd(struct reserved_mem *rmem)
+{
+	fqd_a = rmem->base;
+	fqd_sz = rmem->size;
+
+	WARN_ON(!(fqd_a && fqd_sz));
+
+	return 0;
+}
+RESERVEDMEM_OF_DECLARE(qman_fqd, "fsl,qman-fqd", qman_fqd);
+
+static int qman_pfdr(struct reserved_mem *rmem)
+{
+	pfdr_a = rmem->base;
+	pfdr_sz = rmem->size;
+
+	WARN_ON(!(pfdr_a && pfdr_sz));
+
+	return 0;
+}
+RESERVEDMEM_OF_DECLARE(qman_fbpr, "fsl,qman-pfdr", qman_pfdr);
+
 /* Parse the <name> property to extract the memory location and size and
  * memblock_reserve() it. If it isn't supplied, memblock_alloc() the default
  * size. Also flush this memory range from data cache so that QMAN originated
@@ -436,58 +459,23 @@ static size_t fqd_sz = DEFAULT_FQD_SZ, pfdr_sz = DEFAULT_PFDR_SZ;
 static __init int parse_mem_property(struct device_node *node, const char *name,
 				dma_addr_t *addr, size_t *sz, int zero)
 {
-	const u32 *pint;
 	int ret;
-	void *vaddr;
-
-	pint = of_get_property(node, name, &ret);
-	if (!pint || (ret != 16)) {
-		pr_info("No %s property '%s', using memblock_alloc(%016zx)\n",
-				node->full_name, name, *sz);
-		/* TODO: memblock_alloc memory isn't working on ARM
-		   (not sure why).  Revert to using kmalloc() for now
-		*addr = memblock_alloc(*sz, *sz);
-		vaddr = (unsigned long)phys_to_virt(*addr);
-		*/
-		vaddr = kmalloc(*sz, GFP_KERNEL);
-		*addr = __pa(vaddr);
-		if (zero)
-			memset((void *)vaddr, 0, *sz);
-
-		flush_dcache_range((unsigned long) vaddr,
-				   (unsigned long)vaddr + *sz);
-		return 0;
-	}
-	pr_info("Using %s property '%s'\n", node->full_name, name);
+
 	/* If using a "zero-pma", don't try to zero it, even if you asked */
 	if (zero && of_find_property(node, "zero-pma", &ret)) {
 		pr_info("  it's a 'zero-pma', not zeroing from s/w\n");
 		zero = 0;
 	}
-	*addr = ((u64)pint[0] << 32) | (u64)pint[1];
-	*sz = ((u64)pint[2] << 32) | (u64)pint[3];
-	/* Keep things simple, it's either all in the DRAM range or it's all
-	 * outside. */
-	if (*addr < memblock_end_of_DRAM()) {
-		BUG_ON((u64)*addr + (u64)*sz > memblock_end_of_DRAM());
-		if (memblock_reserve(*addr, *sz) < 0) {
-			pr_err("Failed to reserve %s\n", name);
-			return -ENOMEM;
-		}
-		vaddr = phys_to_virt(*addr);
-		if (zero)
-			memset(phys_to_virt(*addr), 0, *sz);
-		flush_dcache_range((unsigned long) vaddr,
-				   (unsigned long) vaddr + *sz);
-	} else if (zero) {
+
+	if (zero) {
 		/* map as cacheable, non-guarded */
-		void __iomem *tmpp = ioremap_prot(*addr, *sz, 0);
+		void __iomem *tmpp = ioremap_cache(*addr, *sz);
 		memset_io(tmpp, 0, *sz);
-		vaddr = (void *)tmpp;
-		flush_dcache_range((unsigned long) vaddr,
-				   (unsigned long) vaddr + *sz);
+		flush_dcache_range((unsigned long)tmpp,
+				   (unsigned long)tmpp + *sz);
 		iounmap(tmpp);
 	}
+
 	return 0;
 }
 
@@ -515,10 +503,11 @@ static int __init fsl_qman_init(struct device_node *node)
 	if (!standby) {
 		ret = parse_mem_property(node, "fsl,qman-fqd",
 					&fqd_a, &fqd_sz, 1);
-		pr_info("qman-fqd ret is %d", ret);
+		pr_info("qman-fqd addr 0x%llx size 0x%lx\n", fqd_a, fqd_sz);
 		BUG_ON(ret);
 		ret = parse_mem_property(node, "fsl,qman-pfdr",
 					&pfdr_a, &pfdr_sz, 0);
+		pr_info("qman-pfdr addr 0x%llx size 0x%lx\n", pfdr_a, pfdr_sz);
 		BUG_ON(ret);
 	}
 	/* Global configuration */
@@ -560,7 +549,7 @@ int qman_have_ccsr(void)
 	return qm ? 1 : 0;
 }
 
-__init void qman_init_early(void)
+__init int qman_init_early(void)
 {
 	struct device_node *dn;
 	int ret;
@@ -577,8 +566,9 @@ __init void qman_init_early(void)
 			BUG_ON(ret);
 		}
 	}
+	return 0;
 }
-
+postcore_initcall_sync(qman_init_early);
 
 static void log_edata_bits(u32 bit_count)
 {
-- 
1.7.5.4

