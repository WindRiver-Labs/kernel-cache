From a2a5b41071bf25ac1fac99b95f862d8a5af008f5 Mon Sep 17 00:00:00 2001
From: Mingkai Hu <Mingkai.Hu@freescale.com>
Date: Sat, 6 Jun 2015 14:27:31 +0800
Subject: [PATCH 181/451] armv8/ls1043a: fix endianess issue for reading the
 LTSSM

Signed-off-by: Minghuan Lian <Minghuan.Lian@freescale.com>
Signed-off-by: Mingkai Hu <Mingkai.Hu@freescale.com>
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/pci/host/pci-layerscape.c |   51 ++++++++++++++++++++++++++++++++++++-
 1 files changed, 50 insertions(+), 1 deletions(-)

diff --git a/drivers/pci/host/pci-layerscape.c b/drivers/pci/host/pci-layerscape.c
index 6818f45..bee7429 100644
--- a/drivers/pci/host/pci-layerscape.c
+++ b/drivers/pci/host/pci-layerscape.c
@@ -40,6 +40,9 @@
 #define PCIE_LUT_BASE		0x80000
 #define PCIE_LUT_DBG		0x7FC /* PEX LUT Debug register */
 
+#define PCIE_LUT_LS1043A_BASE	0x10000 /* Finally it will be got from DTS */
+#define LS1043A_LTSSM_STATE_SHIFT	24
+
 struct ls_pcie {
 	struct list_head node;
 	struct device *dev;
@@ -94,6 +97,47 @@ static void ls1_pcie_host_init(struct pcie_port *pp)
 	iowrite32(val, pcie->dbi + PCIE_STRFMR1);
 }
 
+static int ls1043a_pcie_link_up(struct pcie_port *pp)
+{
+	u32 state;
+	struct ls_pcie *pcie = to_ls_pcie(pp);
+
+	state = (ioread32(pcie->lut + PCIE_LUT_DBG) >>
+		LS1043A_LTSSM_STATE_SHIFT) & LTSSM_STATE_MASK;
+
+	if (state < LTSSM_PCIE_L0)
+		return 0;
+
+	return 1;
+}
+
+static void ls1043a_pcie_host_init(struct pcie_port *pp)
+{
+	int count = 0;
+	struct ls_pcie *pcie = to_ls_pcie(pp);
+
+	dw_pcie_setup_rc(pp);
+
+	/* Fix class value and clean multi-func bit */
+	writel(1, pcie->dbi + PCIE_DBI_RO_WR_EN);
+	dw_pcie_cfg_write(pcie->dbi + (PCI_CLASS_DEVICE & ~0x3),
+			  PCI_CLASS_DEVICE, 2,
+			  PCI_CLASS_BRIDGE_PCI);
+	dw_pcie_cfg_write(pcie->dbi + (PCI_HEADER_TYPE & ~0x3),
+			  PCI_HEADER_TYPE, 1,
+			  PCI_HEADER_TYPE_BRIDGE);
+	writel(0, pcie->dbi + PCIE_DBI_RO_WR_EN);
+
+	while (!ls1043a_pcie_link_up(pp)) {
+		usleep_range(100, 1000);
+		count++;
+		if (count >= 200) {
+			dev_err(pp->dev, "phy link never came up\n");
+			return;
+		}
+	}
+}
+
 static int ls2_pcie_link_up(struct pcie_port *pp)
 {
 	u32 state;
@@ -192,7 +236,7 @@ static int __init ls_pcie_probe(struct platform_device *pdev)
 		return PTR_ERR(pcie->dbi);
 
 	if (of_device_is_compatible(pcie->dev->of_node, "fsl,ls1043a-pcie"))
-		pcie->lut = pcie->dbi + 0x10000;
+		pcie->lut = pcie->dbi + PCIE_LUT_LS1043A_BASE;
 	else
 		pcie->lut = pcie->dbi + PCIE_LUT_BASE;
 
@@ -217,6 +261,11 @@ static int __init ls_pcie_probe(struct platform_device *pdev)
 		ls_pcie_host_ops.host_init = ls1_pcie_host_init;
 	}
 
+	if (of_device_is_compatible(pcie->dev->of_node, "fsl,ls1043a-pcie")) {
+		ls_pcie_host_ops.link_up = ls1043a_pcie_link_up;
+		ls_pcie_host_ops.host_init = ls1043a_pcie_host_init;
+	}
+
 	ret = ls_add_pcie_port(pcie);
 	if (ret < 0)
 		return ret;
-- 
1.7.5.4

