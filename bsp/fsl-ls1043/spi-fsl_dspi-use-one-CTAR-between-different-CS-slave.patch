From 8bacf5d72ffc144d351eec6d81bf5fb2a02fcabd Mon Sep 17 00:00:00 2001
From: Haikun Wang <Haikun.Wang@freescale.com>
Date: Wed, 11 Feb 2015 22:22:11 +0800
Subject: [PATCH 367/451] spi: fsl_dspi: use one CTAR between different CS
 slaves

Every DSPI slave device using a unique CTAR register now.
DSPI works correctlly in this mode because DSPI only has one slave
device and it has more than one CTAR registers usually.
So there is no conflict.
There are three DSPI slaves and DSPI controller only has two CTAR
registers on LS2085AQDS board.
So slave device in CS2 can't be accessed.
This patch fix this problem.
All slave devices using the same CTAR0 register.

Signed-off-by: Haikun Wang <B53464@freescale.com>
Change-Id: Ie4656713e1e7c26261f782b7bfa944fb015adfe9
Reviewed-on: http://git.am.freescale.net:8181/34983
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/spi/spi-fsl-dspi.c |   16 ++++++++--------
 1 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/drivers/spi/spi-fsl-dspi.c b/drivers/spi/spi-fsl-dspi.c
index bf8f37c..bc77771 100644
--- a/drivers/spi/spi-fsl-dspi.c
+++ b/drivers/spi/spi-fsl-dspi.c
@@ -143,7 +143,7 @@ static inline int is_double_byte_mode(struct fsl_dspi *dspi)
 {
 	unsigned int val;
 
-	regmap_read(dspi->regmap, SPI_CTAR(dspi->cs), &val);
+	regmap_read(dspi->regmap, SPI_CTAR(0), &val);
 
 	return ((val & SPI_FRAME_BITS_MASK) == SPI_FRAME_BITS(8)) ? 0 : 1;
 }
@@ -193,7 +193,7 @@ static u32 dspi_data_to_pushr(struct fsl_dspi *dspi, int tx_word)
 
 		return	SPI_PUSHR_TXDATA(d16) |
 			SPI_PUSHR_PCS(dspi->cs) |
-			SPI_PUSHR_CTAS(dspi->cs) |
+			SPI_PUSHR_CTAS(0) |
 			SPI_PUSHR_CONT;
 	} else {
 		if (!(dspi->dataflags & TRAN_STATE_TX_VOID)) {
@@ -208,7 +208,7 @@ static u32 dspi_data_to_pushr(struct fsl_dspi *dspi, int tx_word)
 
 		return SPI_PUSHR_TXDATA(d8) |
 			SPI_PUSHR_PCS(dspi->cs) |
-			SPI_PUSHR_CTAS(dspi->cs) |
+			SPI_PUSHR_CTAS(0) |
 			SPI_PUSHR_CONT;
 	}
 }
@@ -249,7 +249,7 @@ static int dspi_eoq_write(struct fsl_dspi *dspi)
 	 */
 	if (tx_word && (dspi->len == 1)) {
 		dspi->dataflags |= TRAN_STATE_WORD_ODD_NUM;
-		regmap_update_bits(dspi->regmap, SPI_CTAR(dspi->cs),
+		regmap_update_bits(dspi->regmap, SPI_CTAR(0),
 				SPI_FRAME_BITS_MASK, SPI_FRAME_BITS(8));
 		tx_word = 0;
 	}
@@ -301,7 +301,7 @@ static int dspi_tcfq_write(struct fsl_dspi *dspi)
 
 	if (tx_word && (dspi->len == 1)) {
 		dspi->dataflags |= TRAN_STATE_WORD_ODD_NUM;
-		regmap_update_bits(dspi->regmap, SPI_CTAR(dspi->cs),
+		regmap_update_bits(dspi->regmap, SPI_CTAR(0),
 				SPI_FRAME_BITS_MASK, SPI_FRAME_BITS(8));
 		tx_word = 0;
 	}
@@ -361,10 +361,10 @@ static int dspi_transfer_one_message(struct spi_master *master,
 		regmap_update_bits(dspi->regmap, SPI_MCR,
 				SPI_MCR_CLR_TXF | SPI_MCR_CLR_RXF,
 				SPI_MCR_CLR_TXF | SPI_MCR_CLR_RXF);
-		regmap_write(dspi->regmap, SPI_CTAR(dspi->cs),
+		regmap_write(dspi->regmap, SPI_CTAR(0),
 				dspi->cur_chip->ctar_val);
 		if (transfer->speed_hz)
-			regmap_write(dspi->regmap, SPI_CTAR(dspi->cs),
+			regmap_write(dspi->regmap, SPI_CTAR(0),
 					dspi->cur_chip->ctar_val);
 
 		if (dspi->trans_mode == DSPI_EOQ_MODE) {
@@ -456,7 +456,7 @@ static irqreturn_t dspi_interrupt(int irq, void *dev_id)
 
 	if (!dspi->len) {
 		if (dspi->dataflags & TRAN_STATE_WORD_ODD_NUM)
-			regmap_update_bits(dspi->regmap, SPI_CTAR(dspi->cs),
+			regmap_update_bits(dspi->regmap, SPI_CTAR(0),
 				SPI_FRAME_BITS_MASK, SPI_FRAME_BITS(16));
 
 		dspi->waitflags = 1;
-- 
1.7.5.4

