From d78591733e97bda7f1c8c8b393bdee4885bf7231 Mon Sep 17 00:00:00 2001
From: Alex Porosanu <alexandru.porosanu@freescale.com>
Date: Tue, 4 Aug 2015 23:26:56 +0300
Subject: [PATCH 436/451] fsl_qman: fix CGR structures & initialization

CGR initialization needs to be done taking into account
the endianness of the core vs. the endianness of the
DPAA block. This patch adds the necessary structure
members in order to keep the code the same among the
different core variations (PPC & ARM).

Signed-off-by: Alex Porosanu <alexandru.porosanu@freescale.com>
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/staging/fsl_qbman/qman_high.c |   17 ++++++++++++++++-
 include/linux/fsl_qman.h              |   11 ++++++++++-
 2 files changed, 26 insertions(+), 2 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 784df1b..51d140f 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -2082,7 +2082,7 @@ int qman_query_cgr(struct qman_cgr *cgr, struct qm_mcr_querycgr *cgrd)
 
 	PORTAL_IRQ_LOCK(p, irqflags);
 	mcc = qm_mc_start(&p->p);
-	mcc->querycgr.cgid = cpu_to_be32(cgr->cgrid);
+	mcc->querycgr.cgid = cgr->cgrid;
 	qm_mc_commit(&p->p, QM_MCC_VERB_QUERYCGR);
 	while (!(mcr = qm_mc_result(&p->p)))
 		cpu_relax();
@@ -2096,6 +2096,15 @@ int qman_query_cgr(struct qman_cgr *cgr, struct qm_mcr_querycgr *cgrd)
 		pr_err("QUERY_CGR failed: %s\n", mcr_result_str(res));
 		return -EIO;
 	}
+	cgrd->cgr.wr_parm_g.word =
+		be32_to_cpu(cgrd->cgr.wr_parm_g.word);
+	cgrd->cgr.wr_parm_y.word =
+		be32_to_cpu(cgrd->cgr.wr_parm_y.word);
+	cgrd->cgr.wr_parm_r.word =
+		be32_to_cpu(cgrd->cgr.wr_parm_r.word);
+	cgrd->cgr.cscn_targ =  be32_to_cpu(cgrd->cgr.cscn_targ);
+	cgrd->cgr.__cs_thres = be16_to_cpu(cgrd->cgr.__cs_thres);
+
 	return 0;
 }
 EXPORT_SYMBOL(qman_query_cgr);
@@ -2106,6 +2115,7 @@ int qman_query_congestion(struct qm_mcr_querycongestion *congestion)
 	struct qman_portal *p = get_affine_portal();
 	unsigned long irqflags __maybe_unused;
 	u8 res;
+	int i;
 
 	PORTAL_IRQ_LOCK(p, irqflags);
 	qm_mc_start(&p->p);
@@ -2124,6 +2134,9 @@ int qman_query_congestion(struct qm_mcr_querycongestion *congestion)
 		pr_err("QUERY_CONGESTION failed: %s\n", mcr_result_str(res));
 		return -EIO;
 	}
+
+	for (i = 0; i < ARRAY_SIZE(congestion->state.__state); i++)
+			be32_to_cpus(&congestion->state.__state[i]);
 	return 0;
 }
 EXPORT_SYMBOL(qman_query_congestion);
@@ -2698,6 +2711,8 @@ int qman_modify_cgr(struct qman_cgr *cgr, u32 flags,
 		cpu_to_be32(mcc->initcgr.cgr.wr_parm_y.word);
 	mcc->initcgr.cgr.wr_parm_r.word =
 		cpu_to_be32(mcc->initcgr.cgr.wr_parm_r.word);
+	mcc->initcgr.cgr.cscn_targ =  cpu_to_be32(mcc->initcgr.cgr.cscn_targ);
+	mcc->initcgr.cgr.__cs_thres = cpu_to_be16(mcc->initcgr.cgr.__cs_thres);
 
 	mcc->initcgr.cgid = cgr->cgrid;
 	if (flags & QMAN_CGR_FLAG_USE_INIT)
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index 092cbf9..8628e1c 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -773,14 +773,23 @@ struct __qm_mc_cgr {
 	u8 cscn_en;	/* boolean, use QM_CGR_EN */
 	union {
 		struct {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
 			u16 cscn_targ_upd_ctrl; /* use QM_CSCN_TARG_UDP_ */
 			u16 cscn_targ_dcp_low;  /* CSCN_TARG_DCP low-16bits */
+#else
+			u16 cscn_targ_dcp_low;  /* CSCN_TARG_DCP low-16bits */
+			u16 cscn_targ_upd_ctrl; /* use QM_CSCN_TARG_UDP_ */
+#endif
 		};
 		u32 cscn_targ;	/* use QM_CGR_TARG_* */
 	};
 	u8 cstd_en;	/* boolean, use QM_CGR_EN */
 	u8 cs;		/* boolean, only used in query response */
-	struct qm_cgr_cs_thres cs_thres; /* use qm_cgr_cs_thres_set64() */
+	union {
+		/* use qm_cgr_cs_thres_set64() */
+		struct qm_cgr_cs_thres cs_thres;
+		u16 __cs_thres;
+	};
 	u8 mode;	/* QMAN_CGR_MODE_FRAME not supported in rev1.0 */
 } __packed;
 #define QM_CGR_EN		0x01 /* For wr_en_*, cscn_en, cstd_en */
-- 
1.7.5.4

