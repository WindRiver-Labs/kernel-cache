From 34a24757f3feed82e03c9413d5940f963292a25b Mon Sep 17 00:00:00 2001
From: Priyanka Jain <Priyanka.Jain@freescale.com>
Date: Fri, 26 Jun 2015 15:11:19 +0530
Subject: [PATCH 310/451] fsl,ls2085a:Update handling of ARM generic timer
 errata ERR008585

LS2 Errata ERR008585 Workaround says
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
--------------------------------------
Use ARM Generic Timer and ignore spurious interrupts. Any time in
software reading registers CNTHP_TVAL, CNTP_TVAL, CNTPS_TVAL, CNTV_TVAL,
CNTPCT, or CNTVCT), have software read the register twice. If the
value read differs, then re-read the register, and continue to read
until two consecutive reads return the same value.

This patch
------------
-adds errata workaround in vdso/gettimeofday.S driver.
-Update current workaround implementation
	In current implementation, there can be some delay in
	between two reads. Update the implementation to have
	immediate consecutive reads to avoid extra delay.

Signed-off-by: Priyanka Jain <Priyanka.Jain@freescale.com>
Signed-off-by: Bogdan Purcareata <bogdan.purcareata@freescale.com>
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>

Signed-off-by: Diana Craciun <Diana.Craciun@freescale.com>
---
 arch/arm64/include/asm/arch_timer.h   |   25 +++++++++++++++++++++++++
 arch/arm64/kernel/vdso/gettimeofday.S |   12 +++++++++++-
 drivers/clocksource/arm_arch_timer.c  |   13 ++-----------
 3 files changed, 38 insertions(+), 12 deletions(-)

diff --git a/arch/arm64/include/asm/arch_timer.h b/arch/arm64/include/asm/arch_timer.h
index 644ae0d..c9daba1 100644
--- a/arch/arm64/include/asm/arch_timer.h
+++ b/arch/arm64/include/asm/arch_timer.h
@@ -61,6 +61,9 @@ static __always_inline
 u32 arch_timer_reg_read_cp15(int access, enum arch_timer_reg reg)
 {
 	u32 val;
+#ifdef CONFIG_LS2085A_ERRATA_ERR008585
+	u64 val_new, timeout = 200;
+#endif
 
 	if (access == ARCH_TIMER_PHYS_ACCESS) {
 		switch (reg) {
@@ -69,6 +72,17 @@ u32 arch_timer_reg_read_cp15(int access, enum arch_timer_reg reg)
 			break;
 		case ARCH_TIMER_REG_TVAL:
 			asm volatile("mrs %0, cntp_tval_el0" : "=r" (val));
+#ifdef CONFIG_LS2085A_ERRATA_ERR008585
+			asm volatile("mrs %0, cntp_tval_el0" : "=r" (val_new));
+			while (val != val_new && timeout) {
+				asm volatile("mrs %0, cntp_tval_el0" \
+					     : "=r" (val));
+				asm volatile("mrs %0, cntp_tval_el0" \
+					     : "=r" (val_new));
+				timeout--;
+			}
+			BUG_ON((timeout <= 0) && (val != val_new));
+#endif
 			break;
 		}
 	} else if (access == ARCH_TIMER_VIRT_ACCESS) {
@@ -78,6 +92,17 @@ u32 arch_timer_reg_read_cp15(int access, enum arch_timer_reg reg)
 			break;
 		case ARCH_TIMER_REG_TVAL:
 			asm volatile("mrs %0, cntv_tval_el0" : "=r" (val));
+#ifdef CONFIG_LS2085A_ERRATA_ERR008585
+			asm volatile("mrs %0, cntv_tval_el0" : "=r" (val_new));
+			while (val != val_new && timeout) {
+				asm volatile("mrs %0, cntv_tval_el0" \
+					     : "=r" (val));
+				asm volatile("mrs %0, cntv_tval_el0" \
+					     : "=r" (val_new));
+				timeout--;
+			}
+			BUG_ON((timeout <= 0) && (val != val_new));
+#endif
 			break;
 		}
 	}
diff --git a/arch/arm64/kernel/vdso/gettimeofday.S b/arch/arm64/kernel/vdso/gettimeofday.S
index fe652ff..e61f2bd 100644
--- a/arch/arm64/kernel/vdso/gettimeofday.S
+++ b/arch/arm64/kernel/vdso/gettimeofday.S
@@ -225,7 +225,17 @@ ENTRY(__do_get_tspec)
 
 	/* Read the virtual counter. */
 	isb
-	mrs	x15, cntvct_el0
+1:	mrs	x15, cntvct_el0
+#ifdef CONFIG_LS2085A_ERRATA_ERR008585
+	/*
+	 * ERR008585 workaround says to read register twice till
+	 * two conecutive read return same value
+	 * TODO: Add check for maximum number of read.
+	 */
+	mrs	x16, cntvct_el0
+	cmp	x16, x15
+	b.ne	1b
+#endif
 
 	/* Calculate cycle delta and convert to ns. */
 	sub	x10, x15, x10
diff --git a/drivers/clocksource/arm_arch_timer.c b/drivers/clocksource/arm_arch_timer.c
index e542db3..1c12888 100644
--- a/drivers/clocksource/arm_arch_timer.c
+++ b/drivers/clocksource/arm_arch_timer.c
@@ -123,7 +123,7 @@ u32 arch_timer_reg_read(int access, enum arch_timer_reg reg,
 #ifdef CONFIG_LS2085A_ERRATA_ERR008585
 			val_new = readl_relaxed(timer->base + CNTP_TVAL);
 			while (val != val_new && timeout) {
-				val = val_new;
+				val = readl_relaxed(timer->base + CNTP_TVAL);
 				val_new = readl_relaxed(timer->base +
 							CNTP_TVAL);
 				timeout--;
@@ -144,7 +144,7 @@ u32 arch_timer_reg_read(int access, enum arch_timer_reg reg,
 #ifdef CONFIG_LS2085A_ERRATA_ERR008585
 			val_new = readl_relaxed(timer->base + CNTV_TVAL);
 			while (val != val_new && timeout) {
-				val = val_new;
+				val = readl_relaxed(timer->base + CNTV_TVAL);
 				val_new = readl_relaxed(timer->base +
 							CNTV_TVAL);
 				timeout--;
@@ -156,15 +156,6 @@ u32 arch_timer_reg_read(int access, enum arch_timer_reg reg,
 		}
 	} else {
 		val = arch_timer_reg_read_cp15(access, reg);
-#ifdef CONFIG_LS2085A_ERRATA_ERR008585
-		val_new = arch_timer_reg_read_cp15(access, reg);
-		while (val != val_new && timeout) {
-			val = val_new;
-			val_new = arch_timer_reg_read_cp15(access, reg);
-			timeout--;
-		}
-		BUG_ON((timeout <= 0) && (val != val_new));
-#endif
 	}
 
 	return val;
-- 
1.7.5.4

