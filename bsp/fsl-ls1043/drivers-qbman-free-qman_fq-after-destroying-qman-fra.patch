From ff381837f01f5b81aeb9818176695cab7b7f1af6 Mon Sep 17 00:00:00 2001
From: Xulin Sun <xulin.sun@windriver.com>
Date: Fri, 7 Jul 2017 06:26:41 +0000
Subject: [PATCH] drivers/qbman: free qman_fq after destroying qman frame
 queue

qman_destroy_fq() destroys a complete frame queue, it needs to free the qman_fq
in the last. Else kmemleak will report the below warning:

unreferenced object 0xffff800074c7c480 (size 128):
  comm "cryptomgr_test", pid 196, jiffies 4294937869 (age 87.700s)
  hex dump (first 32 bytes):
    00 00 00 00 00 00 00 00 20 81 7e 00 00 80 ff ff
    00 00 00 00 00 00 00 00 03 00 03 00 5b 01 00 00
  backtrace:
    [<ffff8000001e57a0>] create_object+0xf8/0x258
    [<ffff800000994eb8>] kmemleak_alloc+0x58/0xa0
    [<ffff8000001d5f58>] kmem_cache_alloc_trace+0x2c8/0x358
    [<ffff8000007e8490>] create_caam_req_fq+0x40/0x170
    [<ffff8000007e8ac8>] caam_drv_ctx_init+0x148/0x358
    [<ffff8000007fce98>] get_drv_ctx.part.0+0x98/0xa8
    [<ffff8000007fd384>] aead_encrypt+0x104/0x138
    [<ffff80000045b310>] __test_aead+0x798/0x1028
    [<ffff80000045c2ac>] test_aead+0x44/0xc8
    [<ffff80000045c388>] alg_test_aead+0x58/0xd0
    [<ffff80000045bdd4>] alg_test+0x14c/0x308
    [<ffff800000458908>] cryptomgr_test+0x50/0x58
    [<ffff8000000c3b2c>] kthread+0xdc/0xf0
    [<ffff800000083c00>] ret_from_fork+0x10/0x50

And check where the function qman_destroy_fq() is called to remove
the additional kfree to qman_fq.

Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/crypto/caam/qi.c              |    7 ++-----
 drivers/staging/fsl_qbman/qman_high.c |    1 +
 2 files changed, 3 insertions(+), 5 deletions(-)

diff --git a/drivers/crypto/caam/qi.c b/drivers/crypto/caam/qi.c
index e4e7465..bcb0079 100644
--- a/drivers/crypto/caam/qi.c
+++ b/drivers/crypto/caam/qi.c
@@ -194,7 +194,8 @@ static struct qman_fq *create_caam_req_fq(struct device *qidev,
 	ret = qman_create_fq(0, flags, req_fq);
 	if (ret) {
 		dev_err(qidev, "Failed to create session REQ FQ\n");
-		goto create_req_fq_fail;
+		kfree(req_fq);
+		return ERR_PTR(ret);
 	}
 
 	flags = fq_sched_flag;
@@ -224,8 +225,6 @@ static struct qman_fq *create_caam_req_fq(struct device *qidev,
 init_req_fq_fail:
 	qman_destroy_fq(req_fq, 0);
 
-create_req_fq_fail:
-	kfree(req_fq);
 	return ERR_PTR(ret);
 }
 
@@ -557,8 +556,6 @@ int caam_qi_shutdown(struct device *qidev)
 
 		if (kill_fq(qidev, per_cpu(pcpu_qipriv.rsp_fq, i)))
 			dev_err(qidev, "Rsp FQ kill failed, cpu: %d\n", i);
-
-		kfree(per_cpu(pcpu_qipriv.rsp_fq, i));
 	}
 
 	/*
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 09064b4..581027c 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -1753,6 +1753,7 @@ void qman_destroy_fq(struct qman_fq *fq, u32 flags __maybe_unused)
 #ifdef CONFIG_FSL_QMAN_FQ_LOOKUP
 		clear_fq_table_entry(fq->key);
 #endif
+		kfree(fq);
 		return;
 	default:
 		break;
-- 
1.7.5.4

