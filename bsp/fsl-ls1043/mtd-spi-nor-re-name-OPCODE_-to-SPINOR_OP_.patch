From 2ebea1c8b11e88984f48367045ff0e0c160c6ef5 Mon Sep 17 00:00:00 2001
From: Brian Norris <computersforpeace@gmail.com>
Date: Tue, 8 Apr 2014 18:15:31 -0700
Subject: [PATCH 371/451] mtd: spi-nor: re-name OPCODE_* to SPINOR_OP_*

Qualify these with a better namespace, and prepare them for use in more
drivers.

Signed-off-by: Brian Norris <computersforpeace@gmail.com>
Reviewed-by: Marek Vasut <marex@denx.de>
Acked-by: Huang Shijie <b32955@freescale.com>
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/mtd/spi-nor/fsl-quadspi.c |   58 +++++++++++++++++-----------------
 drivers/mtd/spi-nor/spi-nor.c     |   64 ++++++++++++++++++------------------
 include/linux/mtd/spi-nor.h       |   54 +++++++++++++++---------------
 3 files changed, 88 insertions(+), 88 deletions(-)

diff --git a/drivers/mtd/spi-nor/fsl-quadspi.c b/drivers/mtd/spi-nor/fsl-quadspi.c
index ab11348..123cae5 100644
--- a/drivers/mtd/spi-nor/fsl-quadspi.c
+++ b/drivers/mtd/spi-nor/fsl-quadspi.c
@@ -294,12 +294,12 @@ static void fsl_qspi_init_lut(struct fsl_qspi *q)
 	lut_base = SEQID_QUAD_READ * 4;
 
 	if (q->nor_size <= SZ_16M) {
-		cmd = OPCODE_QUAD_READ;
+		cmd = SPINOR_OP_QUAD_READ;
 		addrlen = ADDR24BIT;
 		dummy = 8;
 	} else {
 		/* use the 4-byte address */
-		cmd = OPCODE_QUAD_READ;
+		cmd = SPINOR_OP_QUAD_READ;
 		addrlen = ADDR32BIT;
 		dummy = 8;
 	}
@@ -311,17 +311,17 @@ static void fsl_qspi_init_lut(struct fsl_qspi *q)
 
 	/* Write enable */
 	lut_base = SEQID_WREN * 4;
-	writel(LUT0(CMD, PAD1, OPCODE_WREN), base + QUADSPI_LUT(lut_base));
+	writel(LUT0(CMD, PAD1, SPINOR_OP_WREN), base + QUADSPI_LUT(lut_base));
 
 	/* Page Program */
 	lut_base = SEQID_PP * 4;
 
 	if (q->nor_size <= SZ_16M) {
-		cmd = OPCODE_PP;
+		cmd = SPINOR_OP_PP;
 		addrlen = ADDR24BIT;
 	} else {
 		/* use the 4-byte address */
-		cmd = OPCODE_PP;
+		cmd = SPINOR_OP_PP;
 		addrlen = ADDR32BIT;
 	}
 
@@ -331,18 +331,18 @@ static void fsl_qspi_init_lut(struct fsl_qspi *q)
 
 	/* Read Status */
 	lut_base = SEQID_RDSR * 4;
-	writel(LUT0(CMD, PAD1, OPCODE_RDSR) | LUT1(READ, PAD1, 0x1),
+	writel(LUT0(CMD, PAD1, SPINOR_OP_RDSR) | LUT1(READ, PAD1, 0x1),
 			base + QUADSPI_LUT(lut_base));
 
 	/* Erase a sector */
 	lut_base = SEQID_SE * 4;
 
 	if (q->nor_size <= SZ_16M) {
-		cmd = OPCODE_SE;
+		cmd = SPINOR_OP_SE;
 		addrlen = ADDR24BIT;
 	} else {
 		/* use the 4-byte address */
-		cmd = OPCODE_SE;
+		cmd = SPINOR_OP_SE;
 		addrlen = ADDR32BIT;
 	}
 
@@ -351,35 +351,35 @@ static void fsl_qspi_init_lut(struct fsl_qspi *q)
 
 	/* Erase the whole chip */
 	lut_base = SEQID_CHIP_ERASE * 4;
-	writel(LUT0(CMD, PAD1, OPCODE_CHIP_ERASE),
+	writel(LUT0(CMD, PAD1, SPINOR_OP_CHIP_ERASE),
 			base + QUADSPI_LUT(lut_base));
 
 	/* READ ID */
 	lut_base = SEQID_RDID * 4;
-	writel(LUT0(CMD, PAD1, OPCODE_RDID) | LUT1(READ, PAD1, 0x8),
+	writel(LUT0(CMD, PAD1, SPINOR_OP_RDID) | LUT1(READ, PAD1, 0x8),
 			base + QUADSPI_LUT(lut_base));
 
 	/* Write Register */
 	lut_base = SEQID_WRSR * 4;
-	writel(LUT0(CMD, PAD1, OPCODE_WRSR) | LUT1(WRITE, PAD1, 0x2),
+	writel(LUT0(CMD, PAD1, SPINOR_OP_WRSR) | LUT1(WRITE, PAD1, 0x2),
 			base + QUADSPI_LUT(lut_base));
 
 	/* Read Configuration Register */
 	lut_base = SEQID_RDCR * 4;
-	writel(LUT0(CMD, PAD1, OPCODE_RDCR) | LUT1(READ, PAD1, 0x1),
+	writel(LUT0(CMD, PAD1, SPINOR_OP_RDCR) | LUT1(READ, PAD1, 0x1),
 			base + QUADSPI_LUT(lut_base));
 
 	/* Write disable */
 	lut_base = SEQID_WRDI * 4;
-	writel(LUT0(CMD, PAD1, OPCODE_WRDI), base + QUADSPI_LUT(lut_base));
+	writel(LUT0(CMD, PAD1, SPINOR_OP_WRDI), base + QUADSPI_LUT(lut_base));
 
 	/* Enter 4 Byte Mode (Micron) */
 	lut_base = SEQID_EN4B * 4;
-	writel(LUT0(CMD, PAD1, OPCODE_EN4B), base + QUADSPI_LUT(lut_base));
+	writel(LUT0(CMD, PAD1, SPINOR_OP_EN4B), base + QUADSPI_LUT(lut_base));
 
 	/* Enter 4 Byte Mode (Spansion) */
 	lut_base = SEQID_BRWR * 4;
-	writel(LUT0(CMD, PAD1, OPCODE_BRWR), base + QUADSPI_LUT(lut_base));
+	writel(LUT0(CMD, PAD1, SPINOR_OP_BRWR), base + QUADSPI_LUT(lut_base));
 
 	fsl_qspi_lock_lut(q);
 }
@@ -388,29 +388,29 @@ static void fsl_qspi_init_lut(struct fsl_qspi *q)
 static int fsl_qspi_get_seqid(struct fsl_qspi *q, u8 cmd)
 {
 	switch (cmd) {
-	case OPCODE_QUAD_READ:
+	case SPINOR_OP_QUAD_READ:
 		return SEQID_QUAD_READ;
-	case OPCODE_WREN:
+	case SPINOR_OP_WREN:
 		return SEQID_WREN;
-	case OPCODE_WRDI:
+	case SPINOR_OP_WRDI:
 		return SEQID_WRDI;
-	case OPCODE_RDSR:
+	case SPINOR_OP_RDSR:
 		return SEQID_RDSR;
-	case OPCODE_SE:
+	case SPINOR_OP_SE:
 		return SEQID_SE;
-	case OPCODE_CHIP_ERASE:
+	case SPINOR_OP_CHIP_ERASE:
 		return SEQID_CHIP_ERASE;
-	case OPCODE_PP:
+	case SPINOR_OP_PP:
 		return SEQID_PP;
-	case OPCODE_RDID:
+	case SPINOR_OP_RDID:
 		return SEQID_RDID;
-	case OPCODE_WRSR:
+	case SPINOR_OP_WRSR:
 		return SEQID_WRSR;
-	case OPCODE_RDCR:
+	case SPINOR_OP_RDCR:
 		return SEQID_RDCR;
-	case OPCODE_EN4B:
+	case SPINOR_OP_EN4B:
 		return SEQID_EN4B;
-	case OPCODE_BRWR:
+	case SPINOR_OP_BRWR:
 		return SEQID_BRWR;
 	default:
 		dev_err(q->dev, "Unsupported cmd 0x%.2x\n", cmd);
@@ -688,7 +688,7 @@ static int fsl_qspi_write_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len,
 		if (ret)
 			return ret;
 
-		if (opcode == OPCODE_CHIP_ERASE)
+		if (opcode == SPINOR_OP_CHIP_ERASE)
 			fsl_qspi_invalid(q);
 
 	} else if (len > 0) {
@@ -750,7 +750,7 @@ static int fsl_qspi_erase(struct spi_nor *nor, loff_t offs)
 		return ret;
 
 	/* Send write enable, then erase commands. */
-	ret = nor->write_reg(nor, OPCODE_WREN, NULL, 0, 0);
+	ret = nor->write_reg(nor, SPINOR_OP_WREN, NULL, 0, 0);
 	if (ret)
 		return ret;
 
diff --git a/drivers/mtd/spi-nor/spi-nor.c b/drivers/mtd/spi-nor/spi-nor.c
index 1daac7b..30b07b8 100644
--- a/drivers/mtd/spi-nor/spi-nor.c
+++ b/drivers/mtd/spi-nor/spi-nor.c
@@ -38,7 +38,7 @@ static int read_sr(struct spi_nor *nor)
 	int ret;
 	u8 val;
 
-	ret = nor->read_reg(nor, OPCODE_RDSR, &val, 1);
+	ret = nor->read_reg(nor, SPINOR_OP_RDSR, &val, 1);
 	if (ret < 0) {
 		pr_err("error %d reading SR\n", (int) ret);
 		return ret;
@@ -57,7 +57,7 @@ static int read_cr(struct spi_nor *nor)
 	int ret;
 	u8 val;
 
-	ret = nor->read_reg(nor, OPCODE_RDCR, &val, 1);
+	ret = nor->read_reg(nor, SPINOR_OP_RDCR, &val, 1);
 	if (ret < 0) {
 		dev_err(nor->dev, "error %d reading CR\n", ret);
 		return ret;
@@ -91,7 +91,7 @@ static inline int spi_nor_read_dummy_cycles(struct spi_nor *nor)
 static inline int write_sr(struct spi_nor *nor, u8 val)
 {
 	nor->cmd_buf[0] = val;
-	return nor->write_reg(nor, OPCODE_WRSR, nor->cmd_buf, 1, 0);
+	return nor->write_reg(nor, SPINOR_OP_WRSR, nor->cmd_buf, 1, 0);
 }
 
 /*
@@ -100,7 +100,7 @@ static inline int write_sr(struct spi_nor *nor, u8 val)
  */
 static inline int write_enable(struct spi_nor *nor)
 {
-	return nor->write_reg(nor, OPCODE_WREN, NULL, 0, 0);
+	return nor->write_reg(nor, SPINOR_OP_WREN, NULL, 0, 0);
 }
 
 /*
@@ -108,7 +108,7 @@ static inline int write_enable(struct spi_nor *nor)
  */
 static inline int write_disable(struct spi_nor *nor)
 {
-	return nor->write_reg(nor, OPCODE_WRDI, NULL, 0, 0);
+	return nor->write_reg(nor, SPINOR_OP_WRDI, NULL, 0, 0);
 }
 
 static inline struct spi_nor *mtd_to_spi_nor(struct mtd_info *mtd)
@@ -132,7 +132,7 @@ static inline int set_4byte(struct spi_nor *nor, u32 jedec_id, int enable)
 		if (need_wren)
 			write_enable(nor);
 
-		cmd = enable ? OPCODE_EN4B : OPCODE_EX4B;
+		cmd = enable ? SPINOR_OP_EN4B : SPINOR_OP_EX4B;
 		status = nor->write_reg(nor, cmd, NULL, 0, 0);
 		if (need_wren)
 			write_disable(nor);
@@ -141,7 +141,7 @@ static inline int set_4byte(struct spi_nor *nor, u32 jedec_id, int enable)
 	default:
 		/* Spansion style */
 		nor->cmd_buf[0] = enable << 7;
-		return nor->write_reg(nor, OPCODE_BRWR, nor->cmd_buf, 1, 0);
+		return nor->write_reg(nor, SPINOR_OP_BRWR, nor->cmd_buf, 1, 0);
 	}
 }
 
@@ -193,7 +193,7 @@ static int erase_chip(struct spi_nor *nor)
 	/* Send write enable, then erase commands. */
 	write_enable(nor);
 
-	return nor->write_reg(nor, OPCODE_CHIP_ERASE, NULL, 0, 0);
+	return nor->write_reg(nor, SPINOR_OP_CHIP_ERASE, NULL, 0, 0);
 }
 
 static int spi_nor_lock_and_prep(struct spi_nor *nor, enum spi_nor_ops ops)
@@ -253,7 +253,7 @@ static int spi_nor_erase(struct mtd_info *mtd, struct erase_info *instr)
 		}
 
 	/* REVISIT in some cases we could speed up erasing large regions
-	 * by using OPCODE_SE instead of OPCODE_BE_4K.  We may have set up
+	 * by using SPINOR_OP_SE instead of SPINOR_OP_BE_4K.  We may have set up
 	 * to use "small sector erase", but that's not always optimal.
 	 */
 
@@ -385,7 +385,7 @@ struct flash_info {
 	u32		jedec_id;
 	u16             ext_id;
 
-	/* The size listed here is what works with OPCODE_SE, which isn't
+	/* The size listed here is what works with SPINOR_OP_SE, which isn't
 	 * necessarily called a "sector" by the vendor.
 	 */
 	unsigned	sector_size;
@@ -395,11 +395,11 @@ struct flash_info {
 	u16		addr_width;
 
 	u16		flags;
-#define	SECT_4K			0x01	/* OPCODE_BE_4K works uniformly */
+#define	SECT_4K			0x01	/* SPINOR_OP_BE_4K works uniformly */
 #define	SPI_NOR_NO_ERASE	0x02	/* No erase command needed */
 #define	SST_WRITE		0x04	/* use SST byte programming */
 #define	SPI_NOR_NO_FR		0x08	/* Can't do fastread */
-#define	SECT_4K_PMC		0x10	/* OPCODE_BE_4K_PMC works uniformly */
+#define	SECT_4K_PMC		0x10	/* SPINOR_OP_BE_4K_PMC works uniformly */
 #define	SPI_NOR_DUAL_READ	0x20    /* Flash supports Dual Read */
 #define	SPI_NOR_QUAD_READ	0x40    /* Flash supports Quad Read */
 };
@@ -598,7 +598,7 @@ static const struct spi_device_id *spi_nor_read_id(struct spi_nor *nor)
 	u16                     ext_jedec;
 	struct flash_info	*info;
 
-	tmp = nor->read_reg(nor, OPCODE_RDID, id, 5);
+	tmp = nor->read_reg(nor, SPINOR_OP_RDID, id, 5);
 	if (tmp < 0) {
 		dev_dbg(nor->dev, " error %d reading JEDEC ID\n", tmp);
 		return ERR_PTR(tmp);
@@ -670,7 +670,7 @@ static int sst_write(struct mtd_info *mtd, loff_t to, size_t len,
 	actual = to % 2;
 	/* Start write from odd address. */
 	if (actual) {
-		nor->program_opcode = OPCODE_BP;
+		nor->program_opcode = SPINOR_OP_BP;
 
 		/* write one byte. */
 		nor->write(nor, to, 1, retlen, buf);
@@ -682,7 +682,7 @@ static int sst_write(struct mtd_info *mtd, loff_t to, size_t len,
 
 	/* Write out most of the data here. */
 	for (; actual < len - 1; actual += 2) {
-		nor->program_opcode = OPCODE_AAI_WP;
+		nor->program_opcode = SPINOR_OP_AAI_WP;
 
 		/* write two bytes. */
 		nor->write(nor, to, 2, retlen, buf + actual);
@@ -703,7 +703,7 @@ static int sst_write(struct mtd_info *mtd, loff_t to, size_t len,
 	if (actual != len) {
 		write_enable(nor);
 
-		nor->program_opcode = OPCODE_BP;
+		nor->program_opcode = SPINOR_OP_BP;
 		nor->write(nor, to, 1, retlen, buf + actual);
 
 		ret = wait_till_ready(nor);
@@ -777,7 +777,7 @@ static int macronix_quad_enable(struct spi_nor *nor)
 	write_enable(nor);
 
 	nor->cmd_buf[0] = val | SR_QUAD_EN_MX;
-	nor->write_reg(nor, OPCODE_WRSR, nor->cmd_buf, 1, 0);
+	nor->write_reg(nor, SPINOR_OP_WRSR, nor->cmd_buf, 1, 0);
 
 	if (wait_till_ready(nor))
 		return 1;
@@ -802,7 +802,7 @@ static int write_sr_cr(struct spi_nor *nor, u16 val)
 	nor->cmd_buf[0] = val & 0xff;
 	nor->cmd_buf[1] = (val >> 8);
 
-	return nor->write_reg(nor, OPCODE_WRSR, nor->cmd_buf, 2, 0);
+	return nor->write_reg(nor, SPINOR_OP_WRSR, nor->cmd_buf, 2, 0);
 }
 
 static int spansion_quad_enable(struct spi_nor *nor)
@@ -969,13 +969,13 @@ int spi_nor_scan(struct spi_nor *nor, const struct spi_device_id *id,
 
 	/* prefer "small sector" erase if possible */
 	if (info->flags & SECT_4K) {
-		nor->erase_opcode = OPCODE_BE_4K;
+		nor->erase_opcode = SPINOR_OP_BE_4K;
 		mtd->erasesize = 4096;
 	} else if (info->flags & SECT_4K_PMC) {
-		nor->erase_opcode = OPCODE_BE_4K_PMC;
+		nor->erase_opcode = SPINOR_OP_BE_4K_PMC;
 		mtd->erasesize = 4096;
 	} else {
-		nor->erase_opcode = OPCODE_SE;
+		nor->erase_opcode = SPINOR_OP_SE;
 		mtd->erasesize = info->sector_size;
 	}
 
@@ -1016,23 +1016,23 @@ int spi_nor_scan(struct spi_nor *nor, const struct spi_device_id *id,
 	/* Default commands */
 	switch (nor->flash_read) {
 	case SPI_NOR_QUAD:
-		nor->read_opcode = OPCODE_QUAD_READ;
+		nor->read_opcode = SPINOR_OP_QUAD_READ;
 		break;
 	case SPI_NOR_DUAL:
-		nor->read_opcode = OPCODE_DUAL_READ;
+		nor->read_opcode = SPINOR_OP_DUAL_READ;
 		break;
 	case SPI_NOR_FAST:
-		nor->read_opcode = OPCODE_FAST_READ;
+		nor->read_opcode = SPINOR_OP_FAST_READ;
 		break;
 	case SPI_NOR_NORMAL:
-		nor->read_opcode = OPCODE_NORM_READ;
+		nor->read_opcode = SPINOR_OP_NORM_READ;
 		break;
 	default:
 		dev_err(dev, "No Read opcode defined\n");
 		return -EINVAL;
 	}
 
-	nor->program_opcode = OPCODE_PP;
+	nor->program_opcode = SPINOR_OP_PP;
 
 	if (info->addr_width)
 		nor->addr_width = info->addr_width;
@@ -1043,21 +1043,21 @@ int spi_nor_scan(struct spi_nor *nor, const struct spi_device_id *id,
 			/* Dedicated 4-byte command set */
 			switch (nor->flash_read) {
 			case SPI_NOR_QUAD:
-				nor->read_opcode = OPCODE_QUAD_READ_4B;
+				nor->read_opcode = SPINOR_OP_QUAD_READ_4B;
 				break;
 			case SPI_NOR_DUAL:
-				nor->read_opcode = OPCODE_DUAL_READ_4B;
+				nor->read_opcode = SPINOR_OP_DUAL_READ_4B;
 				break;
 			case SPI_NOR_FAST:
-				nor->read_opcode = OPCODE_FAST_READ_4B;
+				nor->read_opcode = SPINOR_OP_FAST_READ_4B;
 				break;
 			case SPI_NOR_NORMAL:
-				nor->read_opcode = OPCODE_NORM_READ_4B;
+				nor->read_opcode = SPINOR_OP_NORM_READ_4B;
 				break;
 			}
-			nor->program_opcode = OPCODE_PP_4B;
+			nor->program_opcode = SPINOR_OP_PP_4B;
 			/* No small sector erase for 4-byte command set */
-			nor->erase_opcode = OPCODE_SE_4B;
+			nor->erase_opcode = SPINOR_OP_SE_4B;
 			mtd->erasesize = info->sector_size;
 		} else
 			set_4byte(nor, info->jedec_id, 1);
diff --git a/include/linux/mtd/spi-nor.h b/include/linux/mtd/spi-nor.h
index a6e8719..f1fe1a6 100644
--- a/include/linux/mtd/spi-nor.h
+++ b/include/linux/mtd/spi-nor.h
@@ -11,41 +11,41 @@
 #define __LINUX_MTD_SPI_NOR_H
 
 /* Flash opcodes. */
-#define OPCODE_WREN		0x06	/* Write enable */
-#define OPCODE_RDSR		0x05	/* Read status register */
-#define OPCODE_WRSR		0x01	/* Write status register 1 byte */
-#define OPCODE_NORM_READ	0x03	/* Read data bytes (low frequency) */
-#define OPCODE_FAST_READ	0x0b	/* Read data bytes (high frequency) */
-#define OPCODE_DUAL_READ	0x3b	/* Read data bytes (Dual SPI) */
-#define OPCODE_QUAD_READ	0x6b	/* Read data bytes (Quad SPI) */
-#define OPCODE_PP		0x02	/* Page program (up to 256 bytes) */
-#define OPCODE_BE_4K		0x20	/* Erase 4KiB block */
-#define OPCODE_BE_4K_PMC	0xd7	/* Erase 4KiB block on PMC chips */
-#define OPCODE_BE_32K		0x52	/* Erase 32KiB block */
-#define OPCODE_CHIP_ERASE	0xc7	/* Erase whole flash chip */
-#define OPCODE_SE		0xd8	/* Sector erase (usually 64KiB) */
-#define OPCODE_RDID		0x9f	/* Read JEDEC ID */
-#define OPCODE_RDCR		0x35	/* Read configuration register */
+#define SPINOR_OP_WREN		0x06	/* Write enable */
+#define SPINOR_OP_RDSR		0x05	/* Read status register */
+#define SPINOR_OP_WRSR		0x01	/* Write status register 1 byte */
+#define SPINOR_OP_NORM_READ	0x03	/* Read data bytes (low frequency) */
+#define SPINOR_OP_FAST_READ	0x0b	/* Read data bytes (high frequency) */
+#define SPINOR_OP_DUAL_READ	0x3b	/* Read data bytes (Dual SPI) */
+#define SPINOR_OP_QUAD_READ	0x6b	/* Read data bytes (Quad SPI) */
+#define SPINOR_OP_PP		0x02	/* Page program (up to 256 bytes) */
+#define SPINOR_OP_BE_4K		0x20	/* Erase 4KiB block */
+#define SPINOR_OP_BE_4K_PMC	0xd7	/* Erase 4KiB block on PMC chips */
+#define SPINOR_OP_BE_32K	0x52	/* Erase 32KiB block */
+#define SPINOR_OP_CHIP_ERASE	0xc7	/* Erase whole flash chip */
+#define SPINOR_OP_SE		0xd8	/* Sector erase (usually 64KiB) */
+#define SPINOR_OP_RDID		0x9f	/* Read JEDEC ID */
+#define SPINOR_OP_RDCR		0x35	/* Read configuration register */
 
 /* 4-byte address opcodes - used on Spansion and some Macronix flashes. */
-#define OPCODE_NORM_READ_4B	0x13	/* Read data bytes (low frequency) */
-#define OPCODE_FAST_READ_4B	0x0c	/* Read data bytes (high frequency) */
-#define OPCODE_DUAL_READ_4B	0x3c	/* Read data bytes (Dual SPI) */
-#define OPCODE_QUAD_READ_4B	0x6c	/* Read data bytes (Quad SPI) */
-#define OPCODE_PP_4B		0x12	/* Page program (up to 256 bytes) */
-#define OPCODE_SE_4B		0xdc	/* Sector erase (usually 64KiB) */
+#define SPINOR_OP_NORM_READ_4B	0x13	/* Read data bytes (low frequency) */
+#define SPINOR_OP_FAST_READ_4B	0x0c	/* Read data bytes (high frequency) */
+#define SPINOR_OP_DUAL_READ_4B	0x3c	/* Read data bytes (Dual SPI) */
+#define SPINOR_OP_QUAD_READ_4B	0x6c	/* Read data bytes (Quad SPI) */
+#define SPINOR_OP_PP_4B		0x12	/* Page program (up to 256 bytes) */
+#define SPINOR_OP_SE_4B		0xdc	/* Sector erase (usually 64KiB) */
 
 /* Used for SST flashes only. */
-#define OPCODE_BP		0x02	/* Byte program */
-#define OPCODE_WRDI		0x04	/* Write disable */
-#define OPCODE_AAI_WP		0xad	/* Auto address increment word program */
+#define SPINOR_OP_BP		0x02	/* Byte program */
+#define SPINOR_OP_WRDI		0x04	/* Write disable */
+#define SPINOR_OP_AAI_WP	0xad	/* Auto address increment word program */
 
 /* Used for Macronix and Winbond flashes. */
-#define OPCODE_EN4B		0xb7	/* Enter 4-byte mode */
-#define OPCODE_EX4B		0xe9	/* Exit 4-byte mode */
+#define SPINOR_OP_EN4B		0xb7	/* Enter 4-byte mode */
+#define SPINOR_OP_EX4B		0xe9	/* Exit 4-byte mode */
 
 /* Used for Spansion flashes only. */
-#define OPCODE_BRWR		0x17	/* Bank register write */
+#define SPINOR_OP_BRWR		0x17	/* Bank register write */
 
 /* Status Register bits. */
 #define SR_WIP			1	/* Write in progress */
-- 
1.7.5.4

