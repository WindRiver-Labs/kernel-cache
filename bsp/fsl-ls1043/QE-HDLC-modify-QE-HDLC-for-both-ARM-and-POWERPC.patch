From f72260a9db8149ced21e9d16f13d36b0d11568ca Mon Sep 17 00:00:00 2001
From: Zhao Qiang <B45475@freescale.com>
Date: Tue, 16 Jun 2015 14:24:48 +0800
Subject: [PATCH 256/451] QE/HDLC: modify QE-HDLC for both ARM and POWERPC

ls1021 support QE IP block and it is arm,
So modify QE-HDLC code to adapt bothe arm and powerpc

Signed-off-by: Zhao Qiang <B45475@freescale.com>
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/net/wan/fsl_ucc_hdlc.c |  243 ++++++++++++++++++++--------------------
 drivers/net/wan/fsl_ucc_hdlc.h |    8 +-
 drivers/soc/qe/Kconfig         |    2 +-
 3 files changed, 126 insertions(+), 127 deletions(-)

diff --git a/drivers/net/wan/fsl_ucc_hdlc.c b/drivers/net/wan/fsl_ucc_hdlc.c
index eeba7f7..06f4b86 100644
--- a/drivers/net/wan/fsl_ucc_hdlc.c
+++ b/drivers/net/wan/fsl_ucc_hdlc.c
@@ -27,7 +27,6 @@
 #include <linux/of_address.h>
 #include <linux/of_irq.h>
 #include <linux/of_platform.h>
-#include <sysdev/fsl_soc.h>
 #include <linux/slab.h>
 #include "fsl_ucc_hdlc.h"
 
@@ -136,27 +135,27 @@ static void dump_ucc(struct ucc_hdlc_private *priv)
 	ucc_fast_dump_regs(priv->uccf);
 	dev_info(priv->dev, "Dumping UCC %d Parameter RAM\n",
 			priv->uh_info->uf_info.ucc_num);
-	dev_info(priv->dev, "rbase = 0x%x\n", in_be32(&ucc_pram->rbase));
-	dev_info(priv->dev, "rbptr = 0x%x\n", in_be32(&ucc_pram->rbptr));
-	dev_info(priv->dev, "mrblr = 0x%x\n", in_be16(&ucc_pram->mrblr));
-	dev_info(priv->dev, "rbdlen = 0x%x\n", in_be16(&ucc_pram->rbdlen));
-	dev_info(priv->dev, "rbdstat = 0x%x\n", in_be16(&ucc_pram->rbdstat));
-	dev_info(priv->dev, "rstate = 0x%x\n", in_be32(&ucc_pram->rstate));
-	dev_info(priv->dev, "rdptr = 0x%x\n", in_be32(&ucc_pram->rdptr));
-	dev_info(priv->dev, "riptr = 0x%x\n", in_be16(&ucc_pram->riptr));
-	dev_info(priv->dev, "tbase = 0x%x\n", in_be32(&ucc_pram->tbase));
-	dev_info(priv->dev, "tbptr = 0x%x\n", in_be32(&ucc_pram->tbptr));
-	dev_info(priv->dev, "tbdlen = 0x%x\n", in_be16(&ucc_pram->tbdlen));
-	dev_info(priv->dev, "tbdstat = 0x%x\n", in_be16(&ucc_pram->tbdstat));
-	dev_info(priv->dev, "tstate = 0x%x\n", in_be32(&ucc_pram->tstate));
-	dev_info(priv->dev, "tdptr = 0x%x\n", in_be32(&ucc_pram->tdptr));
-	dev_info(priv->dev, "tiptr = 0x%x\n", in_be16(&ucc_pram->tiptr));
-	dev_info(priv->dev, "rcrc = 0x%x\n", in_be32(&ucc_pram->rcrc));
-	dev_info(priv->dev, "tcrc = 0x%x\n", in_be32(&ucc_pram->tcrc));
-	dev_info(priv->dev, "c_mask = 0x%x\n", in_be32(&ucc_pram->c_mask));
-	dev_info(priv->dev, "c_pers = 0x%x\n", in_be32(&ucc_pram->c_pres));
-	dev_info(priv->dev, "disfc = 0x%x\n", in_be16(&ucc_pram->disfc));
-	dev_info(priv->dev, "crcec = 0x%x\n", in_be16(&ucc_pram->crcec));
+	dev_info(priv->dev, "rbase = 0x%x\n", ioread32be(&ucc_pram->rbase));
+	dev_info(priv->dev, "rbptr = 0x%x\n", ioread32be(&ucc_pram->rbptr));
+	dev_info(priv->dev, "mrblr = 0x%x\n", ioread16be(&ucc_pram->mrblr));
+	dev_info(priv->dev, "rbdlen = 0x%x\n", ioread16be(&ucc_pram->rbdlen));
+	dev_info(priv->dev, "rbdstat = 0x%x\n", ioread16be(&ucc_pram->rbdstat));
+	dev_info(priv->dev, "rstate = 0x%x\n", ioread32be(&ucc_pram->rstate));
+	dev_info(priv->dev, "rdptr = 0x%x\n", ioread32be(&ucc_pram->rdptr));
+	dev_info(priv->dev, "riptr = 0x%x\n", ioread16be(&ucc_pram->riptr));
+	dev_info(priv->dev, "tbase = 0x%x\n", ioread32be(&ucc_pram->tbase));
+	dev_info(priv->dev, "tbptr = 0x%x\n", ioread32be(&ucc_pram->tbptr));
+	dev_info(priv->dev, "tbdlen = 0x%x\n", ioread16be(&ucc_pram->tbdlen));
+	dev_info(priv->dev, "tbdstat = 0x%x\n", ioread16be(&ucc_pram->tbdstat));
+	dev_info(priv->dev, "tstate = 0x%x\n", ioread32be(&ucc_pram->tstate));
+	dev_info(priv->dev, "tdptr = 0x%x\n", ioread32be(&ucc_pram->tdptr));
+	dev_info(priv->dev, "tiptr = 0x%x\n", ioread16be(&ucc_pram->tiptr));
+	dev_info(priv->dev, "rcrc = 0x%x\n", ioread32be(&ucc_pram->rcrc));
+	dev_info(priv->dev, "tcrc = 0x%x\n", ioread32be(&ucc_pram->tcrc));
+	dev_info(priv->dev, "c_mask = 0x%x\n", ioread32be(&ucc_pram->c_mask));
+	dev_info(priv->dev, "c_pers = 0x%x\n", ioread32be(&ucc_pram->c_pres));
+	dev_info(priv->dev, "disfc = 0x%x\n", ioread16be(&ucc_pram->disfc));
+	dev_info(priv->dev, "crcec = 0x%x\n", ioread16be(&ucc_pram->crcec));
 }
 
 static void dump_bds(struct ucc_hdlc_private *priv)
@@ -238,18 +237,18 @@ static void init_si(struct ucc_hdlc_private *priv)
 		mask = 0x01 << i;
 
 		if (priv->tx_ts_mask & mask)
-			out_be16(&siram[siram_entry_id * 32 + i],
-					siram_entry_valid);
+			iowrite16be(siram_entry_valid,
+					&siram[siram_entry_id * 32 + i]);
 		else
-			out_be16(&siram[siram_entry_id * 32 + i],
-					siram_entry_closed);
+			iowrite16be(siram_entry_closed,
+					&siram[siram_entry_id * 32 + i]);
 
 		if (priv->rx_ts_mask & mask)
-			out_be16(&siram[siram_entry_id * 32 + 0x200 +  i],
-					siram_entry_valid);
+			iowrite16be(siram_entry_valid,
+				&siram[siram_entry_id * 32 + 0x200 +  i]);
 		else
-			out_be16(&siram[siram_entry_id * 32 + 0x200 +  i],
-					siram_entry_closed);
+			iowrite16be(siram_entry_closed,
+				&siram[siram_entry_id * 32 + 0x200 +  i]);
 	}
 
 	setbits16(&siram[(siram_entry_id * 32) + (priv->num_of_ts - 1)],
@@ -283,16 +282,16 @@ static void init_si(struct ucc_hdlc_private *priv)
 
 	switch (tdm_port) {
 	case 0:
-		out_be16(&si_regs->sixmr1[0], sixmr);
+		iowrite16be(sixmr, &si_regs->sixmr1[0]);
 		break;
 	case 1:
-		out_be16(&si_regs->sixmr1[1], sixmr);
+		iowrite16be(sixmr, &si_regs->sixmr1[1]);
 		break;
 	case 2:
-		out_be16(&si_regs->sixmr1[2], sixmr);
+		iowrite16be(sixmr, &si_regs->sixmr1[2]);
 		break;
 	case 3:
-		out_be16(&si_regs->sixmr1[3], sixmr);
+		iowrite16be(sixmr, &si_regs->sixmr1[3]);
 		break;
 	default:
 		dev_err(priv->dev, "can not find tdm sixmr reg\n");
@@ -337,10 +336,10 @@ static int uhdlc_init(struct ucc_hdlc_private *priv)
 
 	/* Loopback mode */
 	if (priv->loopback) {
-		gumr = in_be32(&priv->uf_regs->gumr);
+		gumr = ioread32be(&priv->uf_regs->gumr);
 		gumr |= (0x40000000 | UCC_FAST_GUMR_CDS | UCC_FAST_GUMR_TCI);
 		gumr &= ~(UCC_FAST_GUMR_CTSP | UCC_FAST_GUMR_RSYN);
-		out_be32(&priv->uf_regs->gumr, gumr);
+		iowrite32be(gumr, &priv->uf_regs->gumr);
 	}
 
 	/* Initialize SI */
@@ -353,7 +352,7 @@ static int uhdlc_init(struct ucc_hdlc_private *priv)
 		(u8) QE_CR_PROTOCOL_UNSPECIFIED, 0);
 
 	/* Set UPSMR normal mode (need fixed)*/
-	out_be32(&priv->uf_regs->upsmr, 0);
+	iowrite32be(0, &priv->uf_regs->upsmr);
 
 	priv->rx_ring_size = RX_BD_RING_LEN;
 	priv->tx_ring_size = TX_BD_RING_LEN;
@@ -430,32 +429,32 @@ static int uhdlc_init(struct ucc_hdlc_private *priv)
 	}
 
 	/* Set RIPTR, TIPTR */
-	out_be16(&priv->ucc_pram->riptr, (u16)riptr);
-	out_be16(&priv->ucc_pram->tiptr, (u16)tiptr);
+	iowrite16be((u16)riptr, &priv->ucc_pram->riptr);
+	iowrite16be((u16)tiptr, &priv->ucc_pram->tiptr);
 
 	/* Set MRBLR */
-	out_be16(&priv->ucc_pram->mrblr, (u16)MAX_RX_BUF_LENGTH);
+	iowrite16be((u16)MAX_RX_BUF_LENGTH, &priv->ucc_pram->mrblr);
 
 		/* Set RBASE, TBASE */
-	out_be32(&priv->ucc_pram->rbase, (u32)priv->dma_rx_bd);
-	out_be32(&priv->ucc_pram->tbase, (u32)priv->dma_tx_bd);
+	iowrite32be((u32)priv->dma_rx_bd, &priv->ucc_pram->rbase);
+	iowrite32be((u32)priv->dma_tx_bd, &priv->ucc_pram->tbase);
 
 	/* Set RSTATE, TSTATE */
-	out_be32(&priv->ucc_pram->rstate, 0x30000000);
-	out_be32(&priv->ucc_pram->tstate, 0x30000000);
+	iowrite32be(0x30000000, &priv->ucc_pram->rstate);
+	iowrite32be(0x30000000, &priv->ucc_pram->tstate);
 
 	/* Set C_MASK, C_PRES for 16bit CRC */
-	out_be32(&priv->ucc_pram->c_mask, 0x0000F0B8);
-	out_be32(&priv->ucc_pram->c_pres, 0x0000FFFF);
-
-	out_be16(&priv->ucc_pram->mflr, MAX_RX_BUF_LENGTH + 8);
-	out_be16(&priv->ucc_pram->rfthr, 1);
-	out_be16(&priv->ucc_pram->rfcnt, 1);
-	out_be16(&priv->ucc_pram->hmask, DEFAULT_ADDR_MASK);
-	out_be16(&priv->ucc_pram->haddr2, DEFAULT_BROAD_ADDR);
-	out_be16(&priv->ucc_pram->haddr1, DEFAULT_HDLC_ADDR);
-	out_be16(&priv->ucc_pram->haddr3, DEFAULT_HDLC_ADDR);
-	out_be16(&priv->ucc_pram->haddr4, DEFAULT_HDLC_ADDR);
+	iowrite32be(0x0000F0B8, &priv->ucc_pram->c_mask);
+	iowrite32be(0x0000FFFF, &priv->ucc_pram->c_pres);
+
+	iowrite16be(MAX_RX_BUF_LENGTH + 8, &priv->ucc_pram->mflr);
+	iowrite16be(1, &priv->ucc_pram->rfthr);
+	iowrite16be(1, &priv->ucc_pram->rfcnt);
+	iowrite16be(DEFAULT_ADDR_MASK, &priv->ucc_pram->hmask);
+	iowrite16be(DEFAULT_BROAD_ADDR, &priv->ucc_pram->haddr2);
+	iowrite16be(DEFAULT_HDLC_ADDR, &priv->ucc_pram->haddr1);
+	iowrite16be(DEFAULT_HDLC_ADDR, &priv->ucc_pram->haddr3);
+	iowrite16be(DEFAULT_HDLC_ADDR, &priv->ucc_pram->haddr4);
 
 	/* Get BD buffer */
 	bd_buffer = dma_alloc_coherent(priv->dev,
@@ -479,9 +478,9 @@ static int uhdlc_init(struct ucc_hdlc_private *priv)
 		else
 			bd_status = R_E | R_I | R_W;
 
-		out_be32((u32 *)(priv->rx_bd_base + i), bd_status);
-		out_be32(&priv->rx_bd_base[i].buf, priv->dma_rx_addr
-				+ i * MAX_RX_BUF_LENGTH);
+		iowrite32be(bd_status, (u32 *)(priv->rx_bd_base + i));
+		iowrite32be(priv->dma_rx_addr + i * MAX_RX_BUF_LENGTH,
+				&priv->rx_bd_base[i].buf);
 	}
 
 	for (i = 0; i < TX_BD_RING_LEN; i++) {
@@ -490,7 +489,7 @@ static int uhdlc_init(struct ucc_hdlc_private *priv)
 		else
 			bd_status =  T_I | T_TC | T_W;
 
-		out_be32((u32 *)(priv->tx_bd_base + i), bd_status);
+		iowrite32be(bd_status, (u32 *)(priv->tx_bd_base + i));
 	}
 
 	return 0;
@@ -533,7 +532,7 @@ static netdev_tx_t ucc_hdlc_tx(struct sk_buff *skb, struct net_device *dev)
 
 	hdlc_head = (u32 *)skb->data;
 	tmp_head = *hdlc_head;
-	tmp_head = (tmp_head & HDLC_HEAD_MASK) | DEFAULT_HDLC_HEAD;
+	tmp_head = (tmp_head & HDLC_HEAD_MASK) | cpu_to_be32(DEFAULT_HDLC_HEAD);
 	*hdlc_head = tmp_head;
 
 	dev->stats.tx_bytes += skb->len;
@@ -548,7 +547,7 @@ static netdev_tx_t ucc_hdlc_tx(struct sk_buff *skb, struct net_device *dev)
 
 	/* Start from the next BD that should be filled */
 	bd = priv->curtx_bd;
-	bd_status = in_be32((u32 __iomem *)bd);
+	bd_status = ioread32be((u32 __iomem *)bd);
 	/* Save the skb pointer so we can free it later */
 	priv->tx_skbuff[priv->skb_curtx] = skb;
 
@@ -557,14 +556,14 @@ static netdev_tx_t ucc_hdlc_tx(struct sk_buff *skb, struct net_device *dev)
 	priv->skb_curtx =
 	    (priv->skb_curtx + 1) & TX_RING_MOD_MASK(TX_BD_RING_LEN);
 	/* set up the buffer descriptor */
-	out_be32(&((struct qe_bd __iomem *)bd)->buf,
-		      dma_map_single(priv->dev, skb->data,
-			      skb->len, DMA_TO_DEVICE));
+	iowrite32be(dma_map_single(priv->dev, skb->data, skb->len,
+			DMA_TO_DEVICE),
+			&((struct qe_bd __iomem *)bd)->buf);
 
 	bd_status = (bd_status & T_W) | T_R | T_I | T_L | T_TC | skb->len;
 
 	/* set bd status and length */
-	out_be32((u32 __iomem *)bd, bd_status);
+	iowrite32be(bd_status, (u32 __iomem *)bd);
 
 	/* Move to next BD in the ring */
 	if (!(bd_status & T_W))
@@ -584,7 +583,7 @@ static int hdlc_tx_done(struct ucc_hdlc_private *priv)
 	u32 bd_status;
 
 	bd = priv->dirty_tx;
-	bd_status = in_be32((u32 __iomem *)bd);
+	bd_status = ioread32be((u32 __iomem *)bd);
 
 	/* Normal processing. */
 	while ((bd_status & T_R) == 0) {
@@ -600,7 +599,7 @@ static int hdlc_tx_done(struct ucc_hdlc_private *priv)
 
 		dev->stats.tx_packets++;
 		dma_unmap_single(priv->dev,
-				in_be32(&((struct qe_bd __iomem *)bd)->buf),
+				ioread32be(&((struct qe_bd __iomem *)bd)->buf),
 				skb->len, DMA_TO_DEVICE);
 		dev_kfree_skb_irq(skb);
 
@@ -618,7 +617,7 @@ static int hdlc_tx_done(struct ucc_hdlc_private *priv)
 			bd += 1;
 		else
 			bd = priv->tx_bd_base;
-		bd_status = in_be32((u32 __iomem *)bd);
+		bd_status = ioread32be((u32 __iomem *)bd);
 	}
 	priv->dirty_tx = bd;
 
@@ -637,7 +636,7 @@ static int hdlc_rx_done(struct ucc_hdlc_private *priv, int rx_work_limit)
 	int i;
 
 	bd = priv->currx_bd;
-	bd_status = in_be32((u32 __iomem *)bd);
+	bd_status = ioread32be((u32 __iomem *)bd);
 
 	/* while there are received buffers and BD is full (~R_E) */
 	while (!((bd_status & (R_E)) || (--rx_work_limit < 0))) {
@@ -684,7 +683,7 @@ static int hdlc_rx_done(struct ucc_hdlc_private *priv, int rx_work_limit)
 		else
 			priv->currx_bdnum = RX_BD_RING_LEN - 1;
 
-		bd_status = in_be32((u32 __iomem *)bd);
+		bd_status = ioread32be((u32 __iomem *)bd);
 	}
 
 	priv->currx_bd = bd;
@@ -702,8 +701,8 @@ static irqreturn_t ucc_hdlc_irq_handler(int irq, void *dev_id)
 	uh_info = priv->uh_info;
 	uccf = priv->uccf;
 
-	ucce = in_be32(uccf->p_ucce);
-	uccm = in_be32(uccf->p_uccm);
+	ucce = ioread32be(uccf->p_ucce);
+	uccm = ioread32be(uccf->p_uccm);
 
 	if ((ucce >> 16) & (UCC_HDLC_UCCE_RXF | UCC_HDLC_UCCE_RXB))
 		hdlc_rx_done(priv, RX_CLEAN_MAX);
@@ -711,7 +710,7 @@ static irqreturn_t ucc_hdlc_irq_handler(int irq, void *dev_id)
 	if ((ucce >> 16) & UCC_HDLC_UCCE_TXB)
 		hdlc_tx_done(priv);
 
-	out_be32(uccf->p_ucce, ucce);
+	iowrite32be(ucce, uccf->p_ucce);
 
 	return IRQ_HANDLED;
 }
@@ -884,9 +883,9 @@ static void set_si_param(struct ucc_hdlc_private *priv)
 static int of_parse_hdlc_tdm(struct device_node *np,
 		struct ucc_hdlc_private *priv, struct ucc_hdlc_info *uh_info)
 {
-	const unsigned int *prop;
 	const char *sprop;
 	int ret = 0;
+	u32 val;
 
 	sprop = of_get_property(np, "fsl,rx-sync-clock", NULL);
 	if (sprop) {
@@ -914,54 +913,54 @@ static int of_parse_hdlc_tdm(struct device_node *np,
 		return -EINVAL;
 	}
 
-	prop = of_get_property(np, "fsl,tx-timeslot", NULL);
-	if (!prop) {
+	ret = of_property_read_u32_index(np, "fsl,tx-timeslot", 0, &val);
+	if (ret) {
 		ret = -EINVAL;
 		dev_err(priv->dev, "Invalid tx-timeslot property\n");
 		return ret;
 	}
-	priv->tx_ts_mask = *prop;
+	priv->tx_ts_mask = val;
 
-	prop = of_get_property(np, "fsl,rx-timeslot", NULL);
-	if (!prop) {
+	ret = of_property_read_u32_index(np, "fsl,rx-timeslot", 0, &val);
+	if (ret) {
 		ret = -EINVAL;
 		dev_err(priv->dev, "Invalid rx-timeslot property\n");
 		return ret;
 	}
-	priv->rx_ts_mask = *prop;
+	priv->rx_ts_mask = val;
 
-	prop = of_get_property(np, "fsl,tdm-id", NULL);
-	if (!prop) {
+	ret = of_property_read_u32_index(np, "fsl,tdm-id", 0, &val);
+	if (ret) {
 		ret = -EINVAL;
 		dev_err(priv->dev, "No fsl,tdm-id property for this UCC\n");
 		return ret;
 	}
-	priv->tdm_port = *prop;
+	priv->tdm_port = val;
 	uh_info->uf_info.tdm_num = priv->tdm_port;
 
-	prop = of_get_property(np, "fsl,tdm-mode", NULL);
-	if (!prop) {
+	sprop = of_get_property(np, "fsl,tdm-mode", NULL);
+	if (!sprop) {
 		ret = -EINVAL;
 		dev_err(priv->dev, "No tdm-mode property for UCC\n");
 		return ret;
 	}
-	priv->tdm_mode = set_tdm_mode((const char *)prop);
+	priv->tdm_mode = set_tdm_mode(sprop);
 
-	prop = of_get_property(np, "fsl,tdm-framer-type", NULL);
-	if (!prop) {
+	sprop = of_get_property(np, "fsl,tdm-framer-type", NULL);
+	if (!sprop) {
 		ret = -EINVAL;
 		dev_err(priv->dev, "No tdm-framer-type property for UCC\n");
 		return ret;
 	}
-	priv->tdm_framer_type = set_tdm_framer((const char *)prop);
+	priv->tdm_framer_type = set_tdm_framer(sprop);
 
-	prop = of_get_property(np, "fsl,siram-entry-id", NULL);
-	if (!prop) {
+	ret = of_property_read_u32_index(np, "fsl,siram-entry-id", 0, &val);
+	if (ret) {
 		ret = -EINVAL;
 		dev_err(priv->dev, "No siram entry id for UCC\n");
 		return ret;
 	}
-	priv->siram_entry_id = *(const u32 *)prop;
+	priv->siram_entry_id = val;
 
 	set_si_param(priv);
 
@@ -994,11 +993,11 @@ static void store_clk_config(struct ucc_hdlc_private *priv)
 	struct qe_mux *qe_mux_reg = &qe_immr->qmx;
 
 	/* store si clk */
-	priv->cmxsi1cr_h = in_be32(&qe_mux_reg->cmxsi1cr_h);
-	priv->cmxsi1cr_l = in_be32(&qe_mux_reg->cmxsi1cr_l);
+	priv->cmxsi1cr_h = ioread32be(&qe_mux_reg->cmxsi1cr_h);
+	priv->cmxsi1cr_l = ioread32be(&qe_mux_reg->cmxsi1cr_l);
 
 	/* store si sync */
-	priv->cmxsi1syr = in_be32(&qe_mux_reg->cmxsi1syr);
+	priv->cmxsi1syr = ioread32be(&qe_mux_reg->cmxsi1syr);
 
 	/* store ucc clk */
 	memcpy_fromio(priv->cmxucr, qe_mux_reg->cmxucr, 4 * sizeof(u32));
@@ -1010,10 +1009,10 @@ static void resume_clk_config(struct ucc_hdlc_private *priv)
 
 	memcpy_toio(qe_mux_reg->cmxucr, priv->cmxucr, 4 * sizeof(u32));
 
-	out_be32(&qe_mux_reg->cmxsi1cr_h, priv->cmxsi1cr_h);
-	out_be32(&qe_mux_reg->cmxsi1cr_l, priv->cmxsi1cr_l);
+	iowrite32be(priv->cmxsi1cr_h, &qe_mux_reg->cmxsi1cr_h);
+	iowrite32be(priv->cmxsi1cr_l, &qe_mux_reg->cmxsi1cr_l);
 
-	out_be32(&qe_mux_reg->cmxsi1syr, priv->cmxsi1syr);
+	iowrite32be(priv->cmxsi1syr, &qe_mux_reg->cmxsi1syr);
 
 }
 
@@ -1030,8 +1029,8 @@ static int uhdlc_suspend(struct device *dev)
 	uf_regs = priv->uf_regs;
 
 	/* backup gumr guemr*/
-	priv->gumr = in_be32(&uf_regs->gumr);
-	priv->guemr = in_8(&uf_regs->guemr);
+	priv->gumr = ioread32be(&uf_regs->gumr);
+	priv->guemr = ioread8(&uf_regs->guemr);
 
 	priv->ucc_pram_bak = kmalloc(sizeof(struct ucc_hdlc_param),
 					GFP_KERNEL);
@@ -1071,25 +1070,25 @@ static int uhdlc_resume(struct device *dev)
 	uccf = priv->uccf;
 
 	/* restore gumr guemr */
-	out_8(&uf_regs->guemr, priv->guemr);
-	out_be32(&uf_regs->gumr, priv->gumr);
+	iowrite8(priv->guemr, &uf_regs->guemr);
+	iowrite32be(priv->gumr, &uf_regs->gumr);
 
 	/* Set Virtual Fifo registers */
-	out_be16(&uf_regs->urfs, uf_info->urfs);
-	out_be16(&uf_regs->urfet, uf_info->urfet);
-	out_be16(&uf_regs->urfset, uf_info->urfset);
-	out_be16(&uf_regs->utfs, uf_info->utfs);
-	out_be16(&uf_regs->utfet, uf_info->utfet);
-	out_be16(&uf_regs->utftt, uf_info->utftt);
+	iowrite16be(uf_info->urfs, &uf_regs->urfs);
+	iowrite16be(uf_info->urfet, &uf_regs->urfet);
+	iowrite16be(uf_info->urfset, &uf_regs->urfset);
+	iowrite16be(uf_info->utfs, &uf_regs->utfs);
+	iowrite16be(uf_info->utfet, &uf_regs->utfet);
+	iowrite16be(uf_info->utftt, &uf_regs->utftt);
 	/* utfb, urfb are offsets from MURAM base */
-	out_be32(&uf_regs->utfb, uccf->ucc_fast_tx_virtual_fifo_base_offset);
-	out_be32(&uf_regs->urfb, uccf->ucc_fast_rx_virtual_fifo_base_offset);
+	iowrite32be(uccf->ucc_fast_tx_virtual_fifo_base_offset, &uf_regs->utfb);
+	iowrite32be(uccf->ucc_fast_rx_virtual_fifo_base_offset, &uf_regs->urfb);
 
 	/* Rx Tx and sync clock routing */
 	resume_clk_config(priv);
 
-	out_be32(&uf_regs->uccm, uf_info->uccm_mask);
-	out_be32(&uf_regs->ucce, 0xffffffff);
+	iowrite32be(uf_info->uccm_mask, &uf_regs->uccm);
+	iowrite32be(0xffffffff, &uf_regs->ucce);
 
 	ucc_fast_disable(priv->uccf, COMM_DIR_RX | COMM_DIR_TX);
 
@@ -1103,7 +1102,7 @@ static int uhdlc_resume(struct device *dev)
 		(u8)QE_CR_PROTOCOL_UNSPECIFIED, 0);
 
 	/* Set UPSMR normal mode */
-	out_be32(&uf_regs->upsmr, 0);
+	iowrite32be(0, &uf_regs->upsmr);
 
 	/* init parameter base */
 	cecr_subblock = ucc_fast_get_qe_cr_subblock(uf_info->ucc_num);
@@ -1125,9 +1124,9 @@ static int uhdlc_resume(struct device *dev)
 		else
 			bd_status = R_E | R_I | R_W;
 
-		out_be32((u32 *)(priv->rx_bd_base + i), bd_status);
-		out_be32(&priv->rx_bd_base[i].buf, priv->dma_rx_addr
-				+ i * MAX_RX_BUF_LENGTH);
+		iowrite32be(bd_status, (u32 *)(priv->rx_bd_base + i));
+		iowrite32be(priv->dma_rx_addr + i * MAX_RX_BUF_LENGTH,
+				&priv->rx_bd_base[i].buf);
 	}
 
 	for (i = 0; i < TX_BD_RING_LEN; i++) {
@@ -1136,7 +1135,7 @@ static int uhdlc_resume(struct device *dev)
 		else
 			bd_status =  T_I | T_TC | T_W;
 
-		out_be32((u32 *)(priv->tx_bd_base + i), bd_status);
+		iowrite32be(bd_status, (u32 *)(priv->tx_bd_base + i));
 	}
 
 	/* if hdlc is busy enable TX and RX */
@@ -1189,17 +1188,17 @@ static int ucc_hdlc_probe(struct platform_device *pdev)
 	struct net_device *dev;
 	hdlc_device *hdlc;
 	int ucc_num;
-	const unsigned int *prop;
 	const char *sprop;
 	int ret;
+	u32 val;
 
-	prop = of_get_property(np, "cell-index", NULL);
-	if (!prop) {
+	ret = of_property_read_u32_index(np, "cell-index", 0, &val);
+	if (ret) {
 		dev_err(&pdev->dev, "Invalid ucc property\n");
 		return -ENODEV;
 	}
 
-	ucc_num = *prop - 1;
+	ucc_num = val - 1;
 	if ((ucc_num > 3) || (ucc_num < 0)) {
 		dev_err(&pdev->dev, ": Invalid UCC num\n");
 		return -EINVAL;
@@ -1291,7 +1290,7 @@ static int ucc_hdlc_probe(struct platform_device *pdev)
 		of_node_put(np2);
 
 		if (siram_init_flag == 0) {
-			memset(uhdlc_priv->siram, 0,  res.end - res.start + 1);
+			memset_io(uhdlc_priv->siram, 0,  res.end - res.start + 1);
 			siram_init_flag = 1;
 		}
 	}
diff --git a/drivers/net/wan/fsl_ucc_hdlc.h b/drivers/net/wan/fsl_ucc_hdlc.h
index e0c8a4a..93cc20cc 100644
--- a/drivers/net/wan/fsl_ucc_hdlc.h
+++ b/drivers/net/wan/fsl_ucc_hdlc.h
@@ -14,11 +14,11 @@
 #include <linux/kernel.h>
 #include <linux/list.h>
 
-#include <asm/immap_qe.h>
-#include <asm/qe.h>
+#include <linux/fsl/immap_qe.h>
+#include <linux/fsl/qe.h>
 
-#include <asm/ucc.h>
-#include <asm/ucc_fast.h>
+#include <linux/fsl/ucc.h>
+#include <linux/fsl/ucc_fast.h>
 
 /* SI RAM entries */
 #define SIR_LAST	0x0001
diff --git a/drivers/soc/qe/Kconfig b/drivers/soc/qe/Kconfig
index 0924f4c..43b984b 100644
--- a/drivers/soc/qe/Kconfig
+++ b/drivers/soc/qe/Kconfig
@@ -30,7 +30,7 @@ config UCC_SLOW
 
 config UCC_FAST
 	bool
-	default y if UCC_GETH || FSL_UCC_TDM
+	default y if UCC_GETH || FSL_UCC_TDM || FSL_UCC_HDLC
 	help
 	  This option provides qe_lib support to UCC fast
 	  protocols: HDLC, Ethernet, ATM, transparent
-- 
1.7.5.4

