From 1e43eb3dcf36dec23d4e6399b6e6c8c00aa57bbe Mon Sep 17 00:00:00 2001
From: Alex Porosanu <alexandru.porosanu@freescale.com>
Date: Fri, 17 Jul 2015 15:00:38 +0300
Subject: [PATCH 450/451] arch/arm64: add ioread64be and iowrite64be and fix
 warnings

Add add ioread64be and iowrite64be and fix building warnings.

Signed-off-by: Alex Porosanu <alexandru.porosanu@freescale.com>
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 arch/arm64/include/asm/io.h                        |   35 +++++--
 drivers/crypto/caam/regs.h                         |    2 +
 drivers/mtd/devices/m25p80.c                       |    2 +-
 drivers/mtd/nand/fsl_ifc_nand.c                    |    5 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_kg.c      |   16 ---
 .../ethernet/freescale/fman/Peripherals/FM/fm.c    |   10 +-
 .../freescale/fman/src/wrapper/lnxwrp_fm.c         |    9 +-
 .../freescale/fman/src/wrapper/lnxwrp_fm_port.c    |    7 +-
 .../freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c  |    5 +-
 .../freescale/fman/src/wrapper/lnxwrp_sysfs.h      |   10 ++
 drivers/staging/fsl_qbman/qman_high.c              |  112 --------------------
 11 files changed, 54 insertions(+), 159 deletions(-)

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index b4b17ee..4f915a5 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -34,26 +34,31 @@
 /*
  * Generic IO read/write.  These perform native-endian accesses.
  */
+#define __raw_writeb __raw_writeb
 static inline void __raw_writeb(u8 val, volatile void __iomem *addr)
 {
 	asm volatile("strb %w0, [%1]" : : "r" (val), "r" (addr));
 }
 
+#define __raw_writew __raw_writew
 static inline void __raw_writew(u16 val, volatile void __iomem *addr)
 {
 	asm volatile("strh %w0, [%1]" : : "r" (val), "r" (addr));
 }
 
+#define __raw_writel __raw_writel
 static inline void __raw_writel(u32 val, volatile void __iomem *addr)
 {
 	asm volatile("str %w0, [%1]" : : "r" (val), "r" (addr));
 }
 
+#define __raw_writeq __raw_writeq
 static inline void __raw_writeq(u64 val, volatile void __iomem *addr)
 {
 	asm volatile("str %0, [%1]" : : "r" (val), "r" (addr));
 }
 
+#define __raw_readb __raw_readb
 static inline u8 __raw_readb(const volatile void __iomem *addr)
 {
 	u8 val;
@@ -61,6 +66,7 @@ static inline u8 __raw_readb(const volatile void __iomem *addr)
 	return val;
 }
 
+#define __raw_readw __raw_readw
 static inline u16 __raw_readw(const volatile void __iomem *addr)
 {
 	u16 val;
@@ -68,6 +74,7 @@ static inline u16 __raw_readw(const volatile void __iomem *addr)
 	return val;
 }
 
+#define __raw_readl __raw_readl
 static inline u32 __raw_readl(const volatile void __iomem *addr)
 {
 	u32 val;
@@ -75,6 +82,7 @@ static inline u32 __raw_readl(const volatile void __iomem *addr)
 	return val;
 }
 
+#define __raw_readq __raw_readq
 static inline u64 __raw_readq(const volatile void __iomem *addr)
 {
 	u64 val;
@@ -238,19 +246,13 @@ extern void __iomem *ioremap_cache(phys_addr_t phys_addr, size_t size);
 						 __pgprot(PROT_NORMAL_NS))
 #define iounmap				__iounmap
 
-#define ARCH_HAS_IOREMAP_WC
-#include <asm-generic/iomap.h>
-
 /*
- * More restrictive address range checking than the default implementation
- * (PHYS_OFFSET and PHYS_MASK taken into account).
+ * io{read,write}{16,32}be() macros
  */
-#define ARCH_HAS_VALID_PHYS_ADDR_RANGE
-extern int valid_phys_addr_range(unsigned long addr, size_t size);
-extern int valid_mmap_phys_addr_range(unsigned long pfn, size_t size);
-
-extern int devmem_is_allowed(unsigned long pfn);
  
+#define ioread64be(p)		({__u64 __v = be64_to_cpu((__force __be64)__raw_readq(p)); __iormb(); __v;})
+#define iowrite64be(v,p)	({ __iowmb(); __raw_writeq((__force __u64)cpu_to_be64(v), p);})
+
 /* access ports */
 #define setbits32(_addr, _v) iowrite32be(ioread32be(_addr) |  (_v), (_addr))
 #define clrbits32(_addr, _v) iowrite32be(ioread32be(_addr) & ~(_v), (_addr))
@@ -289,6 +291,19 @@ extern int devmem_is_allowed(unsigned long pfn);
  */
 #define xlate_dev_kmem_ptr(p)	p
 
+#define ARCH_HAS_IOREMAP_WC
+#include <asm-generic/iomap.h>
+ 
+/*
+ * More restrictive address range checking than the default implementation
+ * (PHYS_OFFSET and PHYS_MASK taken into account).
+ */
+#define ARCH_HAS_VALID_PHYS_ADDR_RANGE
+extern int valid_phys_addr_range(unsigned long addr, size_t size);
+extern int valid_mmap_phys_addr_range(unsigned long pfn, size_t size);
+
+extern int devmem_is_allowed(unsigned long pfn);
+ 
 struct bio_vec;
 extern bool xen_biovec_phys_mergeable(const struct bio_vec *vec1,
 				      const struct bio_vec *vec2);
diff --git a/drivers/crypto/caam/regs.h b/drivers/crypto/caam/regs.h
index 461cb99..0a0fa8f 100644
--- a/drivers/crypto/caam/regs.h
+++ b/drivers/crypto/caam/regs.h
@@ -112,6 +112,8 @@
 
 #if defined(CONFIG_ARM) || defined(CONFIG_ARM64)
 /* These are common macros for Power, put here for ARMs */
+#undef setbits32
+#undef clrbits32
 #define setbits32(_addr, _v) wr_reg32((_addr), rd_reg32(_addr) | (_v))
 #define clrbits32(_addr, _v) wr_reg32((_addr), rd_reg32(_addr) & ~(_v))
 
diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index 76a6c6e..00e5f95 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -328,7 +328,7 @@ static int m25p_resume(struct device *dev)
 	else if (spi->mode & SPI_RX_DUAL)
 		mode = SPI_NOR_DUAL;
 
-	return spi_nor_scan(nor, spi_get_device_id(spi), mode);
+	return spi_nor_scan(nor, (const char *)spi_get_device_id(spi), mode);
 }
 #endif /* CONFIG_PM_SLEEP */
 
diff --git a/drivers/mtd/nand/fsl_ifc_nand.c b/drivers/mtd/nand/fsl_ifc_nand.c
index b0e8baf..e07da34 100644
--- a/drivers/mtd/nand/fsl_ifc_nand.c
+++ b/drivers/mtd/nand/fsl_ifc_nand.c
@@ -55,7 +55,7 @@ struct fsl_ifc_nand_ctrl {
 	struct nand_hw_control controller;
 	struct fsl_ifc_mtd *chips[FSL_IFC_BANK_COUNT];
 
-	void __iomem *addr;	/* Address of assigned IFC buffer	*/
+	u8 __iomem *addr;	/* Address of assigned IFC buffer	*/
 	unsigned int page;	/* Last page written to / read from	*/
 	unsigned int read_bytes;/* Number of bytes read during command	*/
 	unsigned int column;	/* Saved column from SEQIN		*/
@@ -684,8 +684,7 @@ static uint8_t fsl_ifc_read_byte16(struct mtd_info *mtd)
 	 * next byte.
 	 */
 	if (ifc_nand_ctrl->index < ifc_nand_ctrl->read_bytes) {
-		data = ifc_in16((uint16_t __iomem *)&ifc_nand_ctrl->
-			       addr[ifc_nand_ctrl->index]);
+		data = ifc_in16(&ifc_nand_ctrl->addr[ifc_nand_ctrl->index]);
 		ifc_nand_ctrl->index += 2;
 		return (uint8_t) data;
 	}
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c
index 720da19..e9fdc6f 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c
@@ -872,22 +872,6 @@ static void UnbindPortToClsPlanGrp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId)
     KgWriteCpp(p_FmPcd, hardwarePortId, 0);
 }
 
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-static uint32_t ReadClsPlanBlockActionReg(uint8_t grpId)
-{
-    return (uint32_t)(FM_KG_KGAR_GO |
-                      FM_KG_KGAR_READ |
-                      FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY |
-                      DUMMY_PORT_ID |
-                      ((uint32_t)grpId << FM_PCD_KG_KGAR_NUM_SHIFT) |
-                      FM_PCD_KG_KGAR_WSEL_MASK);
-
-    /* if we ever want to write 1 by 1, use:
-       sel = (uint8_t)(0x01 << (7- (entryId % CLS_PLAN_NUM_PER_GRP)));
-     */
-}
-#endif /* (defined(DEBUG_ERRORS) && ... */
-
 static void PcdKgErrorException(t_Handle h_FmPcd)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
index a322233..6499e3f 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
@@ -418,7 +418,7 @@ static t_Error ClearIRam(t_Fm *p_Fm)
 
     return E_OK;
 }
-#warning for verification only
+
 #if 1
 #include "t2080_r1.1.h"
 
@@ -3537,7 +3537,7 @@ t_Error FM_Init(t_Handle h_Fm)
     /* Reset the FM if required. */
     if (p_Fm->resetOnInit)
     {
-#warning check the lines below if required
+
 //	u32 svr = mfspr(SPRN_SVR);
 
 //	if (((SVR_SOC_VER(svr) == SVR_T4240 && SVR_REV(svr) > 0x10)) ||
@@ -3566,9 +3566,9 @@ t_Error FM_Init(t_Handle h_Fm)
     if (ClearIRam(p_Fm) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
-#warning for verification only
+
 #if 1
-p_Fm->firmware.p_Code = &T2080_R1_1_FmCtrlCode;
+p_Fm->firmware.p_Code = (uint32_t *)&T2080_R1_1_FmCtrlCode;
 p_Fm->firmware.size = sizeof(T2080_R1_1_FmCtrlCode);
 #endif
 
@@ -3692,7 +3692,7 @@ p_Fm->firmware.size = sizeof(T2080_R1_1_FmCtrlCode);
         return err; /* FIXME */
 
     EnableTimeStamp(p_Fm);
-#warning remove the if 0 below after ucode load is fixed to work from u-boot
+
 #if 0
     if (p_Fm->firmware.p_Code)
     {
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
index 8f6bbbd..1e2be3b 100755
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
@@ -591,7 +591,7 @@ static t_LnxWrpFmDev * ReadFmDevTreeNode (struct platform_device *of_dev)
             p_LnxWrpFmDev->fmMuramBaseAddr = 0;
             p_LnxWrpFmDev->fmMuramPhysBaseAddr = res.start;
             p_LnxWrpFmDev->fmMuramMemSize = res.end + 1 - res.start;
-#warning check the line below if required
+
 #if 0
 	    {
                uint32_t svr;
@@ -703,7 +703,7 @@ static t_LnxWrpFmDev * ReadFmDevTreeNode (struct platform_device *of_dev)
     }
 
     of_node_put(fm_node);
-#warning: Check retuned value for hcCh
+
 //     p_LnxWrpFmDev->hcCh = 17;
     p_LnxWrpFmDev->hcCh =
         qman_affine_channel(cpumask_first(qman_affine_cpus()));
@@ -865,7 +865,7 @@ static t_Error ConfigureFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
 
     if (SYS_RegisterIoMap((uint64_t)p_LnxWrpFmDev->fmBaseAddr, (uint64_t)p_LnxWrpFmDev->fmPhysBaseAddr, p_LnxWrpFmDev->fmMemSize) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM memory map"));
-#warning remove printk
+
 printk("<<>><<< p_LnxWrpFmDev->fmPhysBaseAddr = 0x%llx\n",(u64)p_LnxWrpFmDev->fmPhysBaseAddr);
 printk("<<>><<< p_LnxWrpFmDev->fmBaseAddr = 0x%llx\n",(u64)p_LnxWrpFmDev->fmBaseAddr);
 
@@ -2763,8 +2763,7 @@ static int __init __cold fm_load (void)
         return -ENODEV;
     }
 
-	printk(KERN_CRIT "Freescale FM module ("__DATE__ ":"__TIME__")," \
-		" FMD API version %d.%d.%d\n",
+	printk(KERN_CRIT "Freescale FM module, FMD API version %d.%d.%d\n",
 		FMD_API_VERSION_MAJOR,
 		FMD_API_VERSION_MINOR,
 		FMD_API_VERSION_RESPIN);
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c
index 5ebe427..5da832a 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c
@@ -109,7 +109,7 @@ static enum qman_cb_dqrr_result qm_tx_conf_dqrr_cb(struct qman_portal *portal,
 #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
 {
 	/* extract the HC frame address */
-	uint64_t hcf_va = XX_PhysToVirt(((struct qm_fd *)&dq->fd)->addr);
+	uint64_t hcf_va = (uint64_t)XX_PhysToVirt(((struct qm_fd *)&dq->fd)->addr);
 	int hcf_l = ((struct qm_fd *)&dq->fd)->length20;
 	int i;
 
@@ -256,7 +256,7 @@ static t_Error QmEnqueueCB(t_Handle h_Arg, void *p_Fd)
 }
 {
 	/* extract the HC frame address */
-	uint64_t hcf_va = XX_PhysToVirt(((struct qm_fd *) p_Fd)->addr);
+	uint64_t hcf_va = (uint64_t)XX_PhysToVirt(((struct qm_fd *) p_Fd)->addr);
 	int hcf_l = ((struct qm_fd *)p_Fd)->length20;
 	int i;
 
@@ -1482,8 +1482,7 @@ static int __init __cold fm_port_load(void)
 		return -ENODEV;
 	}
 
-	printk(KERN_CRIT "Freescale FM Ports module (" __DATE__ ":" __TIME__
-	       ")\n");
+	printk(KERN_CRIT "Freescale FM Ports module \n");
 
 	return 0;
 }
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
index a6c01f3..d79e250 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
@@ -421,7 +421,7 @@ void LnxWrpPCDIOCTLTypeChecking(void)
     /*ioc_fm_pcd_cc_node_modify_key_params_t : private */
     /*ioc_fm_manip_hdr_info_t : private */
     /*ioc_fm_pcd_hash_table_set_t : private */
-#warning "ls1043 temporary remove size validation"
+#if 0
     ASSERT_COND(sizeof(ioc_fm_pcd_manip_frag_ip_params_t) == sizeof(t_FmPcdManipFragIpParams));
     ASSERT_COND(sizeof(ioc_fm_pcd_manip_reassem_ip_params_t) == sizeof(t_FmPcdManipReassemIpParams));
     ASSERT_COND(sizeof(ioc_fm_pcd_manip_special_offload_ipsec_params_t) == sizeof(t_FmPcdManipSpecialOffloadIPSecParams));
@@ -452,7 +452,7 @@ void LnxWrpPCDIOCTLTypeChecking(void)
     ASSERT_COND(sizeof(ioc_fm_pcd_kg_scheme_select_t) == sizeof(t_FmPcdKgSchemeSelect));
     ASSERT_COND(sizeof(ioc_fm_pcd_port_schemes_params_t) == sizeof(t_FmPcdPortSchemesParams));
     ASSERT_COND(sizeof(ioc_fm_pcd_prs_start_t) == sizeof(t_FmPcdPrsStart));
-
+#endif
     return;
 }
 
@@ -4495,7 +4495,6 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
             t_LnxWrpFmDev *p_LnxWrpFmDev =
                     (t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
             ioc_fm_port_bmi_stats_t param;
-            int port_id = p_LnxWrpFmPortDev->id;
 
             if (!p_LnxWrpFmDev)
                 RETURN_ERROR(MINOR, E_NOT_AVAILABLE, ("Port not initialized or other error!"));
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs.h b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs.h
index 2098b24..bcca482 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs.h
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs.h
@@ -53,6 +53,16 @@ struct sysfs_stats_t {
 	uint8_t stat_counter;
 };
 
+#undef ioread16be
+#undef ioread32be
+#undef iowrite16be
+#undef iowrite32be
+#define ioread16be(p)		({ __u16 __v = be16_to_cpu((__force __be16)__raw_readw(p)); __iormb(); __v; })
+#define ioread32be(p)		({ __u32 __v = be32_to_cpu((__force __be32)__raw_readl(p)); __iormb(); __v; })
+
+#define iowrite16be(v,p)	({ __iowmb(); __raw_writew((__force __u16)cpu_to_be16(v), p); })
+#define iowrite32be(v,p)	({ __iowmb(); __raw_writel((__force __u32)cpu_to_be32(v), p); })
+
 uint8_t fm_find_statistic_counter_by_name(const char *attr_name,
 				const struct sysfs_stats_t *sysfs_stats,
 				uint8_t *offset);
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 51d140f..10dfe57 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -2987,37 +2987,6 @@ static int qman_ceetm_configure_lfqmt(struct qm_mcc_ceetm_lfqmt_config *opts)
 	return 0;
 }
 
-static int qman_ceetm_query_lfqmt(int lfqid,
-			struct qm_mcr_ceetm_lfqmt_query *lfqmt_query)
-{
-	struct qm_mc_command *mcc;
-	struct qm_mc_result *mcr;
-	struct qman_portal *p;
-	unsigned long irqflags __maybe_unused;
-	u8 res;
-
-	p = get_affine_portal();
-	PORTAL_IRQ_LOCK(p, irqflags);
-
-	mcc = qm_mc_start(&p->p);
-	mcc->lfqmt_query.lfqid = lfqid;
-	qm_mc_commit(&p->p, QM_CEETM_VERB_LFQMT_QUERY);
-	while (!(mcr = qm_mc_result(&p->p)))
-		cpu_relax();
-	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) == QM_CEETM_VERB_LFQMT_QUERY);
-	res = mcr->result;
-	if (res == QM_MCR_RESULT_OK)
-		*lfqmt_query = mcr->lfqmt_query;
-
-	PORTAL_IRQ_UNLOCK(p, irqflags);
-	put_affine_portal();
-	if (res != QM_MCR_RESULT_OK) {
-		pr_err("CEETM: QUERY LFQMT failed\n");
-		return -EIO;
-	}
-	return 0;
-}
-
 static int qman_ceetm_configure_cq(struct qm_mcc_ceetm_cq_config *opts)
 {
 	struct qm_mc_command *mcc;
@@ -3333,51 +3302,6 @@ int qman_ceetm_query_ccgr(struct qm_mcc_ceetm_ccgr_query *ccgr_query,
 }
 EXPORT_SYMBOL(qman_ceetm_query_ccgr);
 
-static int qman_ceetm_cq_peek_pop_xsfdrread(struct qm_ceetm_cq *cq,
-			u8 command_type, u16 xsfdr,
-			struct qm_mcr_ceetm_cq_peek_pop_xsfdrread *cq_ppxr)
-{
-	struct qm_mc_command *mcc;
-	struct qm_mc_result *mcr;
-	struct qman_portal *p;
-	unsigned long irqflags __maybe_unused;
-	u8 res;
-
-	p = get_affine_portal();
-	PORTAL_IRQ_LOCK(p, irqflags);
-
-	mcc = qm_mc_start(&p->p);
-	switch (command_type) {
-	case 0:
-	case 1:
-		mcc->cq_ppxr.cqid = (cq->parent->idx << 4) | cq->idx;
-		break;
-	case 2:
-		mcc->cq_ppxr.xsfdr = xsfdr;
-		break;
-	default:
-		break;
-	}
-	mcc->cq_ppxr.ct = command_type;
-	mcc->cq_ppxr.dcpid = cq->parent->dcp_idx;
-	qm_mc_commit(&p->p, QM_CEETM_VERB_CQ_PEEK_POP_XFDRREAD);
-	while (!(mcr = qm_mc_result(&p->p)))
-		cpu_relax();
-	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) ==
-				QM_CEETM_VERB_CQ_PEEK_POP_XFDRREAD);
-
-	PORTAL_IRQ_UNLOCK(p, irqflags);
-	put_affine_portal();
-
-	res = mcr->result;
-	if (res != QM_MCR_RESULT_OK) {
-		pr_err("CEETM: CQ PEEK/POP/XSFDR READ failed\n");
-		return -EIO;
-	}
-	*cq_ppxr = mcr->cq_ppxr;
-	return 0;
-}
-
 static int qman_ceetm_query_statistics(u16 cid,
 			enum qm_dc_portal dcp_idx,
 			u16 command_type,
@@ -3415,42 +3339,6 @@ static int qman_ceetm_query_statistics(u16 cid,
 	return 0;
 }
 
-static int qman_ceetm_write_statistics(u16 cid, enum qm_dc_portal dcp_idx,
-			u16 command_type, u64 frame_count, u64 byte_count)
-{
-	struct qm_mc_command *mcc;
-	struct qm_mc_result *mcr;
-	struct qman_portal *p;
-	unsigned long irqflags __maybe_unused;
-	u8 res;
-
-	p = get_affine_portal();
-	PORTAL_IRQ_LOCK(p, irqflags);
-
-	mcc = qm_mc_start(&p->p);
-	mcc->stats_query_write.cid = cid;
-	mcc->stats_query_write.dcpid = dcp_idx;
-	mcc->stats_query_write.ct = command_type;
-	mcc->stats_query_write.frm_cnt = frame_count;
-	mcc->stats_query_write.byte_cnt = byte_count;
-	qm_mc_commit(&p->p, QM_CEETM_VERB_STATISTICS_QUERY_WRITE);
-
-	while (!(mcr = qm_mc_result(&p->p)))
-		cpu_relax();
-	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) ==
-					 QM_CEETM_VERB_STATISTICS_QUERY_WRITE);
-
-	PORTAL_IRQ_UNLOCK(p, irqflags);
-	put_affine_portal();
-
-	res = mcr->result;
-	if (res != QM_MCR_RESULT_OK) {
-		pr_err("CEETM: STATISTICS WRITE failed\n");
-		return -EIO;
-	}
-	return 0;
-}
-
 int qman_ceetm_bps2tokenrate(u32 bps, struct qm_ceetm_rate *token_rate,
 							int rounding)
 {
-- 
1.7.5.4

