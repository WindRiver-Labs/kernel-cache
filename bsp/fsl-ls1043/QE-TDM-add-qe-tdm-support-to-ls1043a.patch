From e092928d346a6c3669bdde68c13070d88bc457fe Mon Sep 17 00:00:00 2001
From: Zhao Qiang <B45475@freescale.com>
Date: Fri, 26 Jun 2015 15:27:17 +0800
Subject: [PATCH 249/451] QE/TDM:add qe-tdm support to ls1043a

qe-tdm has support powerpc and arm32, now it can run on ls1043a, it is
arm64, so modify the code to support arm64.

Signed-off-by: Zhao Qiang <B45475@freescale.com>
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 arch/arm64/include/asm/io.h      |   27 +++++++++++++++++++++++++++
 arch/arm64/include/asm/irq.h     |    1 +
 arch/arm64/kernel/irq.c          |    8 ++++++++
 drivers/soc/qe/qe.c              |    1 -
 drivers/soc/qe/qe_common.c       |    2 +-
 drivers/soc/qe/qe_ic.c           |    1 -
 drivers/soc/qe/qe_io.c           |    1 -
 drivers/tdm/device/fsl_ucc_tdm.c |    2 +-
 include/asm-generic/delay.h      |   16 ++++++++++++++++
 9 files changed, 54 insertions(+), 5 deletions(-)

diff --git a/arch/arm64/include/asm/io.h b/arch/arm64/include/asm/io.h
index 9da8073..b4b17ee 100644
--- a/arch/arm64/include/asm/io.h
+++ b/arch/arm64/include/asm/io.h
@@ -250,6 +250,33 @@ extern int valid_phys_addr_range(unsigned long addr, size_t size);
 extern int valid_mmap_phys_addr_range(unsigned long pfn, size_t size);
 
 extern int devmem_is_allowed(unsigned long pfn);
+ 
+/* access ports */
+#define setbits32(_addr, _v) iowrite32be(ioread32be(_addr) |  (_v), (_addr))
+#define clrbits32(_addr, _v) iowrite32be(ioread32be(_addr) & ~(_v), (_addr))
+
+#define setbits16(_addr, _v) iowrite16be(ioread16be(_addr) |  (_v), (_addr))
+#define clrbits16(_addr, _v) iowrite16be(ioread16be(_addr) & ~(_v), (_addr))
+
+#define setbits8(_addr, _v) iowrite8(ioread8(_addr) |  (_v), (_addr))
+#define clrbits8(_addr, _v) iowrite8(ioread8(_addr) & ~(_v), (_addr))
+/* Clear and set bits in one shot.  These macros can be used to clear and
+ * set multiple bits in a register using a single read-modify-write.  These
+ * macros can also be used to set a multiple-bit bit pattern using a mask,
+ * by specifying the mask in the 'clear' parameter and the new bit pattern
+ * in the 'set' parameter.
+ */
+
+#define clrsetbits_be32(addr, clear, set) \
+	iowrite32be((ioread32be(addr) & ~(clear)) | (set), (addr))
+#define clrsetbits_le32(addr, clear, set) \
+	iowrite32le((ioread32le(addr) & ~(clear)) | (set), (addr))
+#define clrsetbits_be16(addr, clear, set) \
+	iowrite16be((ioread16be(addr) & ~(clear)) | (set), (addr))
+#define clrsetbits_le16(addr, clear, set) \
+	iowrite16le((ioread16le(addr) & ~(clear)) | (set), (addr))
+#define clrsetbits_8(addr, clear, set) \
+	iowrite8((ioread8(addr) & ~(clear)) | (set), (addr))
 
 /*
  * Convert a physical pointer to a virtual kernel pointer for /dev/mem
diff --git a/arch/arm64/include/asm/irq.h b/arch/arm64/include/asm/irq.h
index 5e0a946..0d259f7 100644
--- a/arch/arm64/include/asm/irq.h
+++ b/arch/arm64/include/asm/irq.h
@@ -14,5 +14,6 @@
 extern void (*handle_arch_irq)(struct pt_regs *);
 extern void migrate_irqs(void);
 extern void set_handle_irq(void (*handle_irq)(struct pt_regs *));
+extern irq_hw_number_t virq_to_hw(unsigned int virq);
 
 #endif
diff --git a/arch/arm64/kernel/irq.c b/arch/arm64/kernel/irq.c
index 3d5ab8d..7f9e8a4 100644
--- a/arch/arm64/kernel/irq.c
+++ b/arch/arm64/kernel/irq.c
@@ -66,6 +66,14 @@ void __init init_IRQ(void)
 		panic("No interrupt controller found.");
 }
 
+irq_hw_number_t virq_to_hw(unsigned int virq)
+{
+	struct irq_data *irq_data = irq_get_irq_data(virq);
+
+	return WARN_ON(!irq_data) ? 0 : irq_data->hwirq;
+}
+EXPORT_SYMBOL_GPL(virq_to_hw);
+
 #ifdef CONFIG_HOTPLUG_CPU
 static bool migrate_one_irq(struct irq_desc *desc)
 {
diff --git a/drivers/soc/qe/qe.c b/drivers/soc/qe/qe.c
index 6d2687d..1ab803d 100644
--- a/drivers/soc/qe/qe.c
+++ b/drivers/soc/qe/qe.c
@@ -35,7 +35,6 @@
 #include <asm/pgtable.h>
 #include <linux/fsl/immap_qe.h>
 #include <linux/fsl/qe.h>
-#include <asm/prom.h>
 #include <linux/fsl/rheap.h>
 
 static void qe_snums_init(void);
diff --git a/drivers/soc/qe/qe_common.c b/drivers/soc/qe/qe_common.c
index 6bc9b18..d7b724e 100644
--- a/drivers/soc/qe/qe_common.c
+++ b/drivers/soc/qe/qe_common.c
@@ -111,7 +111,7 @@ unsigned long qe_muram_alloc(unsigned long size, unsigned long align)
 	spin_lock_irqsave(&qe_muram_lock, flags);
 	qe_muram_info.alignment = align;
 	start = rh_alloc(&qe_muram_info, size, "commproc");
-	memset(qe_muram_addr(start), 0, size);
+	memset_io(qe_muram_addr(start), 0, size);
 	spin_unlock_irqrestore(&qe_muram_lock, flags);
 
 	return start;
diff --git a/drivers/soc/qe/qe_ic.c b/drivers/soc/qe/qe_ic.c
index 11fe98c..097f8c4 100644
--- a/drivers/soc/qe/qe_ic.c
+++ b/drivers/soc/qe/qe_ic.c
@@ -30,7 +30,6 @@
 #include <linux/spinlock.h>
 #include <asm/irq.h>
 #include <linux/io.h>
-#include <asm/prom.h>
 #include <linux/fsl/qe_ic.h>
 
 #include "qe_ic.h"
diff --git a/drivers/soc/qe/qe_io.c b/drivers/soc/qe/qe_io.c
index 7f40d3c..becdd48 100644
--- a/drivers/soc/qe/qe_io.c
+++ b/drivers/soc/qe/qe_io.c
@@ -23,7 +23,6 @@
 
 #include <linux/io.h>
 #include <linux/fsl/qe.h>
-#include <asm/prom.h>
 
 #undef DEBUG
 
diff --git a/drivers/tdm/device/fsl_ucc_tdm.c b/drivers/tdm/device/fsl_ucc_tdm.c
index bb93572..5000ba8 100644
--- a/drivers/tdm/device/fsl_ucc_tdm.c
+++ b/drivers/tdm/device/fsl_ucc_tdm.c
@@ -929,7 +929,7 @@ static int ucc_tdm_probe(struct platform_device *pdev)
 	of_node_put(np2);
 
 	if (siram_init_flag == 0) {
-		memset(utdm_priv->siram, 0,  res.end - res.start + 1);
+		memset_io(utdm_priv->siram, 0,  res.end - res.start + 1);
 		siram_init_flag = 1;
 	}
 
diff --git a/include/asm-generic/delay.h b/include/asm-generic/delay.h
index 0f79054..3e61200 100644
--- a/include/asm-generic/delay.h
+++ b/include/asm-generic/delay.h
@@ -42,3 +42,19 @@ extern void __delay(unsigned long loops);
 	})
 
 #endif /* __ASM_GENERIC_DELAY_H */
+
+#define spin_event_timeout(condition, timeout, delay)                          \
+({                                                                             \
+	typeof(condition) __ret;                                               \
+	int i = 0;							       \
+	while (!(__ret = (condition)) && (i++ < timeout)) {		       \
+		if (delay)                                                     \
+			udelay(delay);                                         \
+		else                                                           \
+			cpu_relax();					       \
+		udelay(1);						       \
+	}								       \
+	if (!__ret)                                                            \
+		__ret = (condition);                                           \
+	__ret;		                                                       \
+})
-- 
1.7.5.4

