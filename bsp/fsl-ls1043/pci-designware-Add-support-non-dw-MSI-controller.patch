From 48fdfb176251fd0963411e121d87eb22259c025e Mon Sep 17 00:00:00 2001
From: Minghuan Lian <Minghuan.Lian@freescale.com>
Date: Mon, 8 Jun 2015 09:46:43 +0800
Subject: [PATCH 189/451] pci/designware: Add support non-dw MSI controller

Signed-off-by: Minghuan Lian <Minghuan.Lian@freescale.com>
Signed-off-by: Mingkai Hu <Mingkai.Hu@freescale.com>
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 arch/arm64/include/asm/pci.h       |    2 +
 drivers/pci/host/pcie-designware.c |   78 ++++++++++++++++++++++++++++++++++--
 drivers/pci/host/pcie-designware.h |    1 +
 3 files changed, 77 insertions(+), 4 deletions(-)

diff --git a/arch/arm64/include/asm/pci.h b/arch/arm64/include/asm/pci.h
index 9a261f0..af0b684 100644
--- a/arch/arm64/include/asm/pci.h
+++ b/arch/arm64/include/asm/pci.h
@@ -35,6 +35,7 @@ struct hw_pci {
 #ifdef CONFIG_PCI_DOMAINS
 	int		domain;
 #endif
+	struct msi_controller *msi_ctrl;
 	struct pci_ops	*ops;
 	int		nr_controllers;
 	void		**private_data;
@@ -61,6 +62,7 @@ struct pci_sys_data {
 #ifdef CONFIG_PCI_DOMAINS
 	int		domain;
 #endif
+	struct msi_controller *msi_ctrl;
 	struct list_head node;
 	int		busnr;	    /* primary bus number		*/
 	u64		mem_offset; /* bus->cpu memory mapping offset	*/
diff --git a/drivers/pci/host/pcie-designware.c b/drivers/pci/host/pcie-designware.c
index c6068ea..467559b 100644
--- a/drivers/pci/host/pcie-designware.c
+++ b/drivers/pci/host/pcie-designware.c
@@ -319,10 +319,9 @@ static void dw_msi_teardown_irq(struct msi_chip *chip, unsigned int irq)
 }
 
 static struct msi_chip dw_pcie_msi_chip = {
-	.setup_irq = dw_msi_setup_irq,
-	.teardown_irq = dw_msi_teardown_irq,
+	.setup_irq = NULL,
+	.teardown_irq = NULL,
 };
-#endif
 
 int dw_pcie_link_up(struct pcie_port *pp)
 {
@@ -348,6 +347,62 @@ static const struct irq_domain_ops msi_domain_ops = {
 };
 #endif
 
+static int dw_msi_ctrl_init(struct pcie_port *pp)
+{
+#if 0
+	int i;
+
+	pp->irq_domain = irq_domain_add_linear(pp->dev->of_node,
+					       MAX_MSI_IRQS,
+					       &msi_domain_ops,
+					       &dw_pcie_msi_chip);
+	if (!pp->irq_domain) {
+		dev_err(pp->dev, "irq domain init failed\n");
+		return -ENXIO;
+	}
+
+	for (i = 0; i < MAX_MSI_IRQS; i++)
+		irq_create_mapping(pp->irq_domain, i);
+
+	dw_pcie_msi_chip.dev = pp->dev;
+	pp->msi_ctrl = &dw_pcie_msi_chip;
+#endif
+
+	return 0;
+}
+
+static int dw_pcie_msi_ctrl_init(struct pcie_port *pp)
+{
+	struct device_node *msi_node;
+	int ret;
+
+	if (!IS_ENABLED(CONFIG_PCI_MSI)) {
+		pp->msi_ctrl = NULL;
+		return 0;
+	}
+
+	if (pp->msi_ctrl)
+		return 0;
+
+	msi_node = of_parse_phandle(pp->dev->of_node, "msi-parent", 0);
+	if (msi_node) {
+		pp->msi_ctrl = of_pci_find_msi_chip_by_node(msi_node);
+		if (!pp->msi_ctrl) {
+			dev_err(pp->dev, "Cannot find msi chip of %s\n",
+				msi_node->full_name);
+			return -ENODEV;
+		} else
+			return 0;
+	}
+
+	if (pp->ops->msi_host_init)
+		ret = pp->ops->msi_host_init(pp, &dw_pcie_msi_chip);
+	else
+		ret = dw_msi_ctrl_init(pp);
+
+	return ret;
+}
+
 int __init dw_pcie_host_init(struct pcie_port *pp)
 {
 	struct device_node *np = pp->dev->of_node;
@@ -357,7 +412,7 @@ int __init dw_pcie_host_init(struct pcie_port *pp)
 	struct resource *cfg_res;
 	u32 num_atus = 2, val, na, ns;
 	const __be32 *addrp;
-	int i, index, ret;
+	int index, ret;
 
 	/* Find the address cell size and the number of cells in order to get
 	 * the untranslated address.
@@ -527,7 +582,12 @@ int __init dw_pcie_host_init(struct pcie_port *pp)
 	dw_pci.msi_ctrl = &dw_pcie_msi_chip;
 #endif
 #endif
+	ret = dw_pcie_msi_ctrl_init(pp);
+	if (ret)
+		return ret;
 
+	dw_pci.msi_ctrl = pp->msi_ctrl;
+ 
 	dw_pci.nr_controllers = 1;
 	dw_pci.private_data = (void **)&pp;
 
@@ -785,10 +845,20 @@ static int dw_pcie_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 	return irq;
 }
 
+static void dw_pcie_add_bus(struct pci_bus *bus)
+{
+	if (IS_ENABLED(CONFIG_PCI_MSI)) {
+		struct pcie_port *pp = sys_to_pcie(bus->sysdata);
+
+		bus->msi = pp->msi_ctrl;
+	}
+}
+
 static struct hw_pci dw_pci = {
 	.setup		= dw_pcie_setup,
 	.scan		= dw_pcie_scan_bus,
 	.map_irq	= dw_pcie_map_irq,
+	.add_bus	= dw_pcie_add_bus,
 };
 
 void dw_pcie_setup_rc(struct pcie_port *pp)
diff --git a/drivers/pci/host/pcie-designware.h b/drivers/pci/host/pcie-designware.h
index 37604f9..92af902 100644
--- a/drivers/pci/host/pcie-designware.h
+++ b/drivers/pci/host/pcie-designware.h
@@ -57,6 +57,7 @@ struct pcie_port {
 	int			irq;
 	u32			lanes;
 	struct pcie_host_ops	*ops;
+	struct msi_controller	*msi_ctrl;
 	int			msi_irq;
 	struct irq_domain	*irq_domain;
 	unsigned long		msi_data;
-- 
1.7.5.4

