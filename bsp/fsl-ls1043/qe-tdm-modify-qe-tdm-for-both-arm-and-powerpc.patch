From 65b1a3ae00c83aedc64c45f819a6a6388985f061 Mon Sep 17 00:00:00 2001
From: Zhao Qiang <B45475@freescale.com>
Date: Tue, 21 Oct 2014 16:19:08 +0800
Subject: [PATCH 231/451] qe-tdm: modify qe-tdm for both arm and powerpc

ls1021 support qe ip block and it is arm,
so modify qe-tdm code to adapt both arm and powerpc

Signed-off-by: Zhao Qiang <B45475@freescale.com>
Change-Id: Ie64cef1dc6cd915388c089d1359c681da67c6fba
Reviewed-on: http://git.am.freescale.net:8181/21869
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Xiaobo Xie <X.Xie@freescale.com>
Reviewed-by: Zhengxiong Jin <Jason.Jin@freescale.com>
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/soc/qe/qe.c              |    2 -
 drivers/soc/qe/ucc_fast.c        |   68 ++++++------
 drivers/tdm/device/Kconfig       |    4 +-
 drivers/tdm/device/fsl_ucc_tdm.c |  221 +++++++++++++++++++-------------------
 drivers/tdm/test/Kconfig         |    2 +-
 include/linux/fsl/qe.h           |    2 -
 6 files changed, 147 insertions(+), 152 deletions(-)

diff --git a/drivers/soc/qe/qe.c b/drivers/soc/qe/qe.c
index bfea0f8..6d2687d 100644
--- a/drivers/soc/qe/qe.c
+++ b/drivers/soc/qe/qe.c
@@ -41,8 +41,6 @@
 static void qe_snums_init(void);
 static int qe_sdma_init(void);
 
-int siram_init_flag;
-
 static DEFINE_SPINLOCK(qe_lock);
 DEFINE_SPINLOCK(cmxgcr_lock);
 EXPORT_SYMBOL(cmxgcr_lock);
diff --git a/drivers/soc/qe/ucc_fast.c b/drivers/soc/qe/ucc_fast.c
index 8088852..3ed8d22 100644
--- a/drivers/soc/qe/ucc_fast.c
+++ b/drivers/soc/qe/ucc_fast.c
@@ -34,41 +34,41 @@ void ucc_fast_dump_regs(struct ucc_fast_private *uccf)
 	pr_info("Base address: 0x%p\n", uccf->uf_regs);
 
 	pr_info("gumr  : addr=0x%p, val=0x%08x\n",
-		  &uccf->uf_regs->gumr, in_be32(&uccf->uf_regs->gumr));
+		  &uccf->uf_regs->gumr, ioread32be(&uccf->uf_regs->gumr));
 	pr_info("upsmr : addr=0x%p, val=0x%08x\n",
-		  &uccf->uf_regs->upsmr, in_be32(&uccf->uf_regs->upsmr));
+		  &uccf->uf_regs->upsmr, ioread32be(&uccf->uf_regs->upsmr));
 	pr_info("utodr : addr=0x%p, val=0x%04x\n",
-		  &uccf->uf_regs->utodr, in_be16(&uccf->uf_regs->utodr));
+		  &uccf->uf_regs->utodr, ioread16be(&uccf->uf_regs->utodr));
 	pr_info("udsr  : addr=0x%p, val=0x%04x\n",
-		  &uccf->uf_regs->udsr, in_be16(&uccf->uf_regs->udsr));
+		  &uccf->uf_regs->udsr, ioread16be(&uccf->uf_regs->udsr));
 	pr_info("ucce  : addr=0x%p, val=0x%08x\n",
-		  &uccf->uf_regs->ucce, in_be32(&uccf->uf_regs->ucce));
+		  &uccf->uf_regs->ucce, ioread32be(&uccf->uf_regs->ucce));
 	pr_info("uccm  : addr=0x%p, val=0x%08x\n",
-		  &uccf->uf_regs->uccm, in_be32(&uccf->uf_regs->uccm));
+		  &uccf->uf_regs->uccm, ioread32be(&uccf->uf_regs->uccm));
 	pr_info("uccs  : addr=0x%p, val=0x%02x\n",
-		  &uccf->uf_regs->uccs, in_8(&uccf->uf_regs->uccs));
+		  &uccf->uf_regs->uccs, ioread8(&uccf->uf_regs->uccs));
 	pr_info("urfb  : addr=0x%p, val=0x%08x\n",
-		  &uccf->uf_regs->urfb, in_be32(&uccf->uf_regs->urfb));
+		  &uccf->uf_regs->urfb, ioread32be(&uccf->uf_regs->urfb));
 	pr_info("urfs  : addr=0x%p, val=0x%04x\n",
-		  &uccf->uf_regs->urfs, in_be16(&uccf->uf_regs->urfs));
+		  &uccf->uf_regs->urfs, ioread16be(&uccf->uf_regs->urfs));
 	pr_info("urfet : addr=0x%p, val=0x%04x\n",
-		  &uccf->uf_regs->urfet, in_be16(&uccf->uf_regs->urfet));
+		  &uccf->uf_regs->urfet, ioread16be(&uccf->uf_regs->urfet));
 	pr_info("urfset: addr=0x%p, val=0x%04x\n",
-		  &uccf->uf_regs->urfset, in_be16(&uccf->uf_regs->urfset));
+		  &uccf->uf_regs->urfset, ioread16be(&uccf->uf_regs->urfset));
 	pr_info("utfb  : addr=0x%p, val=0x%08x\n",
-		  &uccf->uf_regs->utfb, in_be32(&uccf->uf_regs->utfb));
+		  &uccf->uf_regs->utfb, ioread32be(&uccf->uf_regs->utfb));
 	pr_info("utfs  : addr=0x%p, val=0x%04x\n",
-		  &uccf->uf_regs->utfs, in_be16(&uccf->uf_regs->utfs));
+		  &uccf->uf_regs->utfs, ioread16be(&uccf->uf_regs->utfs));
 	pr_info("utfet : addr=0x%p, val=0x%04x\n",
-		  &uccf->uf_regs->utfet, in_be16(&uccf->uf_regs->utfet));
+		  &uccf->uf_regs->utfet, ioread16be(&uccf->uf_regs->utfet));
 	pr_info("utftt : addr=0x%p, val=0x%04x\n",
-		  &uccf->uf_regs->utftt, in_be16(&uccf->uf_regs->utftt));
+		  &uccf->uf_regs->utftt, ioread16be(&uccf->uf_regs->utftt));
 	pr_info("utpt  : addr=0x%p, val=0x%04x\n",
-		  &uccf->uf_regs->utpt, in_be16(&uccf->uf_regs->utpt));
+		  &uccf->uf_regs->utpt, ioread16be(&uccf->uf_regs->utpt));
 	pr_info("urtry : addr=0x%p, val=0x%08x\n",
-		  &uccf->uf_regs->urtry, in_be32(&uccf->uf_regs->urtry));
+		  &uccf->uf_regs->urtry, ioread32be(&uccf->uf_regs->urtry));
 	pr_info("guemr : addr=0x%p, val=0x%02x\n",
-		  &uccf->uf_regs->guemr, in_8(&uccf->uf_regs->guemr));
+		  &uccf->uf_regs->guemr, ioread8(&uccf->uf_regs->guemr));
 }
 EXPORT_SYMBOL(ucc_fast_dump_regs);
 
@@ -90,7 +90,7 @@ EXPORT_SYMBOL(ucc_fast_get_qe_cr_subblock);
 
 void ucc_fast_transmit_on_demand(struct ucc_fast_private *uccf)
 {
-	out_be16(&uccf->uf_regs->utodr, UCC_FAST_TOD);
+	iowrite16be(UCC_FAST_TOD, &uccf->uf_regs->utodr);
 }
 EXPORT_SYMBOL(ucc_fast_transmit_on_demand);
 
@@ -102,7 +102,7 @@ void ucc_fast_enable(struct ucc_fast_private *uccf, enum comm_dir mode)
 	uf_regs = uccf->uf_regs;
 
 	/* Enable reception and/or transmission on this UCC. */
-	gumr = in_be32(&uf_regs->gumr);
+	gumr = ioread32be(&uf_regs->gumr);
 	if (mode & COMM_DIR_TX) {
 		gumr |= UCC_FAST_GUMR_ENT;
 		uccf->enabled_tx = 1;
@@ -111,7 +111,7 @@ void ucc_fast_enable(struct ucc_fast_private *uccf, enum comm_dir mode)
 		gumr |= UCC_FAST_GUMR_ENR;
 		uccf->enabled_rx = 1;
 	}
-	out_be32(&uf_regs->gumr, gumr);
+	iowrite32be(gumr, &uf_regs->gumr);
 }
 EXPORT_SYMBOL(ucc_fast_enable);
 
@@ -123,7 +123,7 @@ void ucc_fast_disable(struct ucc_fast_private *uccf, enum comm_dir mode)
 	uf_regs = uccf->uf_regs;
 
 	/* Disable reception and/or transmission on this UCC. */
-	gumr = in_be32(&uf_regs->gumr);
+	gumr = ioread32be(&uf_regs->gumr);
 	if (mode & COMM_DIR_TX) {
 		gumr &= ~UCC_FAST_GUMR_ENT;
 		uccf->enabled_tx = 0;
@@ -132,7 +132,7 @@ void ucc_fast_disable(struct ucc_fast_private *uccf, enum comm_dir mode)
 		gumr &= ~UCC_FAST_GUMR_ENR;
 		uccf->enabled_rx = 0;
 	}
-	out_be32(&uf_regs->gumr, gumr);
+	iowrite32be(gumr, &uf_regs->gumr);
 }
 EXPORT_SYMBOL(ucc_fast_disable);
 
@@ -265,7 +265,7 @@ int ucc_fast_init(struct ucc_fast_info *uf_info,
 	gumr |= uf_info->tenc;
 	gumr |= uf_info->tcrc;
 	gumr |= uf_info->mode;
-	out_be32(&uf_regs->gumr, gumr);
+	iowrite32be(gumr, &uf_regs->gumr);
 
 	/* Allocate memory for Tx Virtual Fifo */
 	uccf->ucc_fast_tx_virtual_fifo_base_offset =
@@ -292,15 +292,15 @@ int ucc_fast_init(struct ucc_fast_info *uf_info,
 	}
 
 	/* Set Virtual Fifo registers */
-	out_be16(&uf_regs->urfs, uf_info->urfs);
-	out_be16(&uf_regs->urfet, uf_info->urfet);
-	out_be16(&uf_regs->urfset, uf_info->urfset);
-	out_be16(&uf_regs->utfs, uf_info->utfs);
-	out_be16(&uf_regs->utfet, uf_info->utfet);
-	out_be16(&uf_regs->utftt, uf_info->utftt);
+	iowrite16be(uf_info->urfs, &uf_regs->urfs);
+	iowrite16be(uf_info->urfet, &uf_regs->urfet);
+	iowrite16be(uf_info->urfset, &uf_regs->urfset);
+	iowrite16be(uf_info->utfs, &uf_regs->utfs);
+	iowrite16be(uf_info->utfet, &uf_regs->utfet);
+	iowrite16be(uf_info->utftt, &uf_regs->utftt);
 	/* utfb, urfb are offsets from MURAM base */
-	out_be32(&uf_regs->utfb, uccf->ucc_fast_tx_virtual_fifo_base_offset);
-	out_be32(&uf_regs->urfb, uccf->ucc_fast_rx_virtual_fifo_base_offset);
+	iowrite32be(uccf->ucc_fast_tx_virtual_fifo_base_offset, &uf_regs->utfb);
+	iowrite32be(uccf->ucc_fast_rx_virtual_fifo_base_offset, &uf_regs->urfb);
 
 	/* Mux clocking */
 	/* Grant Support */
@@ -368,14 +368,14 @@ int ucc_fast_init(struct ucc_fast_info *uf_info,
 	}
 
 	/* Set interrupt mask register at UCC level. */
-	out_be32(&uf_regs->uccm, uf_info->uccm_mask);
+	iowrite32be(uf_info->uccm_mask, &uf_regs->uccm);
 
 	/* First, clear anything pending at UCC level,
 	 * otherwise, old garbage may come through
 	 * as soon as the dam is opened. */
 
 	/* Writing '1' clears */
-	out_be32(&uf_regs->ucce, 0xffffffff);
+	iowrite32be(0xffffffff, &uf_regs->ucce);
 
 	*uccf_ret = uccf;
 	return 0;
diff --git a/drivers/tdm/device/Kconfig b/drivers/tdm/device/Kconfig
index af6a710..5490e1d 100644
--- a/drivers/tdm/device/Kconfig
+++ b/drivers/tdm/device/Kconfig
@@ -6,7 +6,7 @@ menu "TDM Device support"
 
 config TDM_FSL
         tristate "Driver for Freescale TDM controller"
-        depends on FSL_SOC
+        depends on FSL_SOC || ARCH_MXC
         ---help---
           This is a driver for Freescale TDM controller. The controller
           is found in various Freescale SOCs viz MPC8315, P1020. The TDM driver
@@ -15,7 +15,7 @@ config TDM_FSL
 
 config FSL_UCC_TDM
        tristate "UCC TDM driver for Freescale QE engine"
-       depends on FSL_SOC || CONFIG_QE
+       depends on FSL_SOC || QUICC_ENGINE
        ---help---
          This is a driver for Freescale QE UCC working with TDM interface.
 
diff --git a/drivers/tdm/device/fsl_ucc_tdm.c b/drivers/tdm/device/fsl_ucc_tdm.c
index c383ec4..bb93572 100644
--- a/drivers/tdm/device/fsl_ucc_tdm.c
+++ b/drivers/tdm/device/fsl_ucc_tdm.c
@@ -29,6 +29,7 @@
 #include <linux/stddef.h>
 #include <linux/sched.h>
 #include <linux/init.h>
+#include <linux/of_irq.h>
 #include <linux/platform_device.h>
 #include <linux/io.h>
 #include <linux/tdm.h>
@@ -37,8 +38,6 @@
 #include <linux/dma-mapping.h>
 #include <linux/spinlock.h>
 #include <linux/delay.h>
-#include <sysdev/fsl_soc.h>
-#include <sysdev/fsl_soc.h>
 #include <linux/slab.h>
 #include "fsl_ucc_tdm.h"
 
@@ -144,27 +143,27 @@ static void dump_ucc(struct ucc_tdm_private *priv)
 	ucc_fast_dump_regs(priv->uccf);
 	dev_info(priv->dev, "Dumping UCC %d Parameter RAM\n",
 			priv->ut_info->uf_info.ucc_num);
-	dev_info(priv->dev, "rbase = 0x%x\n", in_be32(&ucc_pram->rbase));
-	dev_info(priv->dev, "rbptr = 0x%x\n", in_be32(&ucc_pram->rbptr));
-	dev_info(priv->dev, "mrblr = 0x%x\n", in_be16(&ucc_pram->mrblr));
-	dev_info(priv->dev, "rbdlen = 0x%x\n", in_be16(&ucc_pram->rbdlen));
-	dev_info(priv->dev, "rbdstat = 0x%x\n", in_be16(&ucc_pram->rbdstat));
-	dev_info(priv->dev, "rstate = 0x%x\n", in_be32(&ucc_pram->rstate));
-	dev_info(priv->dev, "rdptr = 0x%x\n", in_be32(&ucc_pram->rdptr));
-	dev_info(priv->dev, "riptr = 0x%x\n", in_be16(&ucc_pram->riptr));
-	dev_info(priv->dev, "tbase = 0x%x\n", in_be32(&ucc_pram->tbase));
-	dev_info(priv->dev, "tbptr = 0x%x\n", in_be32(&ucc_pram->tbptr));
-	dev_info(priv->dev, "tbdlen = 0x%x\n", in_be16(&ucc_pram->tbdlen));
-	dev_info(priv->dev, "tbdstat = 0x%x\n", in_be16(&ucc_pram->tbdstat));
-	dev_info(priv->dev, "tstate = 0x%x\n", in_be32(&ucc_pram->tstate));
-	dev_info(priv->dev, "tdptr = 0x%x\n", in_be32(&ucc_pram->tdptr));
-	dev_info(priv->dev, "tiptr = 0x%x\n", in_be16(&ucc_pram->tiptr));
-	dev_info(priv->dev, "rcrc = 0x%x\n", in_be32(&ucc_pram->rcrc));
-	dev_info(priv->dev, "tcrc = 0x%x\n", in_be32(&ucc_pram->tcrc));
-	dev_info(priv->dev, "c_mask = 0x%x\n", in_be32(&ucc_pram->c_mask));
-	dev_info(priv->dev, "c_pers = 0x%x\n", in_be32(&ucc_pram->c_pres));
-	dev_info(priv->dev, "disfc = 0x%x\n", in_be16(&ucc_pram->disfc));
-	dev_info(priv->dev, "crcec = 0x%x\n", in_be16(&ucc_pram->crcec));
+	dev_info(priv->dev, "rbase = 0x%x\n", ioread32be(&ucc_pram->rbase));
+	dev_info(priv->dev, "rbptr = 0x%x\n", ioread32be(&ucc_pram->rbptr));
+	dev_info(priv->dev, "mrblr = 0x%x\n", ioread16be(&ucc_pram->mrblr));
+	dev_info(priv->dev, "rbdlen = 0x%x\n", ioread16be(&ucc_pram->rbdlen));
+	dev_info(priv->dev, "rbdstat = 0x%x\n", ioread16be(&ucc_pram->rbdstat));
+	dev_info(priv->dev, "rstate = 0x%x\n", ioread32be(&ucc_pram->rstate));
+	dev_info(priv->dev, "rdptr = 0x%x\n", ioread32be(&ucc_pram->rdptr));
+	dev_info(priv->dev, "riptr = 0x%x\n", ioread16be(&ucc_pram->riptr));
+	dev_info(priv->dev, "tbase = 0x%x\n", ioread32be(&ucc_pram->tbase));
+	dev_info(priv->dev, "tbptr = 0x%x\n", ioread32be(&ucc_pram->tbptr));
+	dev_info(priv->dev, "tbdlen = 0x%x\n", ioread16be(&ucc_pram->tbdlen));
+	dev_info(priv->dev, "tbdstat = 0x%x\n", ioread16be(&ucc_pram->tbdstat));
+	dev_info(priv->dev, "tstate = 0x%x\n", ioread32be(&ucc_pram->tstate));
+	dev_info(priv->dev, "tdptr = 0x%x\n", ioread32be(&ucc_pram->tdptr));
+	dev_info(priv->dev, "tiptr = 0x%x\n", ioread16be(&ucc_pram->tiptr));
+	dev_info(priv->dev, "rcrc = 0x%x\n", ioread32be(&ucc_pram->rcrc));
+	dev_info(priv->dev, "tcrc = 0x%x\n", ioread32be(&ucc_pram->tcrc));
+	dev_info(priv->dev, "c_mask = 0x%x\n", ioread32be(&ucc_pram->c_mask));
+	dev_info(priv->dev, "c_pers = 0x%x\n", ioread32be(&ucc_pram->c_pres));
+	dev_info(priv->dev, "disfc = 0x%x\n", ioread16be(&ucc_pram->disfc));
+	dev_info(priv->dev, "crcec = 0x%x\n", ioread16be(&ucc_pram->crcec));
 }
 
 static void dump_bds(struct ucc_tdm_private *priv)
@@ -244,18 +243,18 @@ static void init_si(struct ucc_tdm_private *priv)
 		mask = 0x01 << i;
 
 		if (priv->tx_ts_mask & mask)
-			out_be16(&siram[siram_entry_id * 32 + i],
-					siram_entry_valid);
+			iowrite16be(siram_entry_valid,
+				    &siram[siram_entry_id * 32 + i]);
 		else
-			out_be16(&siram[siram_entry_id * 32 + i],
-					siram_entry_closed);
+			iowrite16be(siram_entry_closed,
+				    &siram[siram_entry_id * 32 + i]);
 
 		if (priv->rx_ts_mask & mask)
-			out_be16(&siram[siram_entry_id * 32 + 0x200 +  i],
-					siram_entry_valid);
+			iowrite16be(siram_entry_valid,
+				    &siram[siram_entry_id * 32 + 0x200 +  i]);
 		else
-			out_be16(&siram[siram_entry_id * 32 + 0x200 +  i],
-					siram_entry_closed);
+			iowrite16be(siram_entry_closed,
+				    &siram[siram_entry_id * 32 + 0x200 +  i]);
 	}
 
 	setbits16(&siram[(siram_entry_id * 32) + (priv->num_of_ts - 1)],
@@ -289,16 +288,16 @@ static void init_si(struct ucc_tdm_private *priv)
 
 	switch (tdm_port) {
 	case 0:
-		out_be16(&si_regs->sixmr1[0], sixmr);
+		iowrite16be(sixmr, &si_regs->sixmr1[0]);
 		break;
 	case 1:
-		out_be16(&si_regs->sixmr1[1], sixmr);
+		iowrite16be(sixmr, &si_regs->sixmr1[1]);
 		break;
 	case 2:
-		out_be16(&si_regs->sixmr1[2], sixmr);
+		iowrite16be(sixmr, &si_regs->sixmr1[2]);
 		break;
 	case 3:
-		out_be16(&si_regs->sixmr1[3], sixmr);
+		iowrite16be(sixmr, &si_regs->sixmr1[3]);
 		break;
 	default:
 		dev_err(priv->dev, "can not find tdm sixmr reg\n");
@@ -349,7 +348,7 @@ static int utdm_init(struct ucc_tdm_private *priv)
 		(u8) QE_CR_PROTOCOL_UNSPECIFIED, 0);
 
 	/* Set UPSMR normal mode */
-	out_be32(&priv->uf_regs->upsmr, 0);
+	iowrite32be(0, &priv->uf_regs->upsmr);
 
 	priv->tx_bd = dma_alloc_coherent(priv->dev,
 			NUM_OF_BUF * MAX_RX_BUF_LENGTH,
@@ -409,27 +408,27 @@ static int utdm_init(struct ucc_tdm_private *priv)
 	}
 
 	/* Set RIPTR, TIPTR */
-	out_be16(&priv->ucc_pram->riptr, (u16)riptr);
-	out_be16(&priv->ucc_pram->tiptr, (u16)tiptr);
+	iowrite16be((u16)riptr, &priv->ucc_pram->riptr);
+	iowrite16be((u16)tiptr, &priv->ucc_pram->tiptr);
 
 	/* Set MRBLR */
-	out_be16(&priv->ucc_pram->mrblr, (u16)MAX_RX_BUF_LENGTH);
+	iowrite16be((u16)MAX_RX_BUF_LENGTH, &priv->ucc_pram->mrblr);
 
 	/* Set RBASE, TBASE */
-	out_be32(&priv->ucc_pram->rbase, (u32)priv->dma_rx_bd);
-	out_be32(&priv->ucc_pram->tbase, (u32)priv->dma_tx_bd);
+	iowrite32be((u32)priv->dma_rx_bd, &priv->ucc_pram->rbase);
+	iowrite32be((u32)priv->dma_tx_bd, &priv->ucc_pram->tbase);
 
 	/* Set RSTATE, TSTATE */
-	out_be32(&priv->ucc_pram->rstate, 0x30000000);
-	out_be32(&priv->ucc_pram->tstate, 0x30000000);
+	iowrite32be(0x30000000, &priv->ucc_pram->rstate);
+	iowrite32be(0x30000000, &priv->ucc_pram->tstate);
 
 	/* Set C_MASK, C_PRES for 16bit CRC */
-	out_be32(&priv->ucc_pram->c_mask, 0x0000F0B8);
-	out_be32(&priv->ucc_pram->c_pres, 0x0000FFFF);
+	iowrite32be(0x0000F0B8, &priv->ucc_pram->c_mask);
+	iowrite32be(0x0000FFFF, &priv->ucc_pram->c_pres);
 
-	out_be16(&priv->ucc_pram->res0, 0);
+	iowrite16be(0, &priv->ucc_pram->res0);
 	for (i = 0; i < 4; i++)
-		out_be32(&priv->ucc_pram->res4[i], 0x0);
+		iowrite32be(0x0, &priv->ucc_pram->res4[i]);
 
 	/* Get BD buffer */
 	bd_buffer = dma_alloc_coherent(priv->dev,
@@ -455,18 +454,18 @@ static int utdm_init(struct ucc_tdm_private *priv)
 		else
 			bd_status = R_E | R_I | R_W | R_CM;
 
-		out_be32((u32 *)(priv->rx_bd + i), bd_status);
-		out_be32(&priv->rx_bd[i].buf, priv->dma_rx_addr
-				+ i * MAX_RX_BUF_LENGTH);
+		iowrite32be(bd_status, (u32 *)(priv->rx_bd + i));
+		iowrite32be(priv->dma_rx_addr + i * MAX_RX_BUF_LENGTH,
+			    &priv->rx_bd[i].buf);
 
 		if (i < (NUM_OF_BUF - 1))
 			bd_status =  T_I;
 		else
 			bd_status =  T_I | T_W;
 
-		out_be32((u32 *)(priv->tx_bd + i), bd_status);
-		out_be32(&priv->tx_bd[i].buf, priv->dma_tx_addr
-				+ i * MAX_RX_BUF_LENGTH);
+		iowrite32be(bd_status, (u32 *)(priv->tx_bd + i));
+		iowrite32be(priv->dma_tx_addr + i * MAX_RX_BUF_LENGTH,
+			    &priv->tx_bd[i].buf);
 	}
 
 	priv->phase_rx = 0;
@@ -547,7 +546,7 @@ static int ucc_tdm_write(struct tdm_adapter *adap, u8 *write_buf,
 			priv->phase_tx = 0;
 
 		bd = (priv->tx_bd + priv->phase_tx);
-		bd_stat_len = in_be32((u32 __iomem *)bd);
+		bd_stat_len = ioread32be((u32 __iomem *)bd);
 		tdm_send_buf = priv->tx_buffer +
 				priv->phase_tx * MAX_RX_BUF_LENGTH;
 
@@ -558,7 +557,7 @@ static int ucc_tdm_write(struct tdm_adapter *adap, u8 *write_buf,
 			copy_len = MAX_RX_BUF_LENGTH;
 
 		ret = spin_event_timeout(((bd_stat_len =
-				in_be32((u32 __iomem *)bd)) & T_R) != T_R ,
+				ioread32be((u32 __iomem *)bd)) & T_R) != T_R ,
 				1000000, 500);
 		if (!ret) {
 			dev_err(priv->dev, "TDM write data error!\n");
@@ -571,11 +570,11 @@ static int ucc_tdm_write(struct tdm_adapter *adap, u8 *write_buf,
 
 		bd_stat_len &= ~(T_L | BD_LEN_MASK);
 		if (i == (buf_num - 1))
-			out_be32((u32 __iomem *)(bd),
-				bd_stat_len | T_R | T_L | T_I | copy_len);
+			iowrite32be(bd_stat_len | T_R | T_L | T_I | copy_len,
+				    (u32 __iomem *)(bd));
 		else
-			out_be32((u32 __iomem *)(bd),
-				bd_stat_len | T_R | T_I | copy_len);
+			iowrite32be(bd_stat_len | T_R | T_I | copy_len,
+				    (u32 __iomem *)(bd));
 
 		priv->phase_tx++;
 	}
@@ -594,8 +593,8 @@ static irqreturn_t ucc_tdm_irq_handler(int irq, void *dev_id)
 	ut_info = priv->ut_info;
 	uccf = priv->uccf;
 
-	ucce = in_be32(uccf->p_ucce);
-	uccm = in_be32(uccf->p_uccm);
+	ucce = ioread32be(uccf->p_ucce);
+	uccm = ioread32be(uccf->p_uccm);
 
 	if ((ucce >> 16) & UCC_TRANS_UCCE_RXB) {
 		if (priv->phase_rx  == NUM_OF_BUF - 1)
@@ -608,7 +607,7 @@ static irqreturn_t ucc_tdm_irq_handler(int irq, void *dev_id)
 
 	}
 
-	out_be32(uccf->p_ucce, ucce);
+	iowrite32be(ucce, uccf->p_ucce);
 
 	return IRQ_HANDLED;
 
@@ -764,18 +763,18 @@ static int ucc_tdm_probe(struct platform_device *pdev)
 	struct ucc_tdm_info *ut_info;
 	struct resource res;
 	int ucc_num;
-	const unsigned int *prop;
+	u32 val;
 	const char *sprop;
 	struct device_node *np2;
 	int ret;
 
-	prop = of_get_property(np, "cell-index", NULL);
-	if (!prop) {
+	ret = of_property_read_u32_index(np, "cell-index", 0, &val);
+	if (ret) {
 		dev_err(&pdev->dev, "Invalid ucc property\n");
 		return -ENODEV;
 	}
 
-	ucc_num = *prop - 1;
+	ucc_num = val - 1;
 	if ((ucc_num > 7) || (ucc_num < 0)) {
 		dev_err(&pdev->dev, ": Invalid UCC num\n");
 		return -EINVAL;
@@ -860,54 +859,54 @@ static int ucc_tdm_probe(struct platform_device *pdev)
 	dev_set_drvdata(&pdev->dev, utdm_priv);
 	utdm_priv->dev = &pdev->dev;
 
-	prop = of_get_property(np, "fsl,tx-timeslot", NULL);
-	if (!prop) {
+	ret = of_property_read_u32_index(np, "fsl,tx-timeslot", 0, &val);
+	if (ret) {
 		ret = -EINVAL;
 		dev_err(&pdev->dev, "Invalid tx-timeslot property\n");
 		goto err_miss_property;
 	}
-	utdm_priv->tx_ts_mask = *prop;
+	utdm_priv->tx_ts_mask = val;
 
-	prop = of_get_property(np, "fsl,rx-timeslot", NULL);
-	if (!prop) {
+	ret = of_property_read_u32_index(np, "fsl,rx-timeslot", 0, &val);
+	if (ret) {
 		ret = -EINVAL;
 		dev_err(&pdev->dev, "Invalid rx-timeslot property\n");
 		goto err_miss_property;
 	}
-	utdm_priv->rx_ts_mask = *prop;
+	utdm_priv->rx_ts_mask = val;
 
-	prop = of_get_property(np, "fsl,tdm-id", NULL);
-	if (!prop) {
+	ret = of_property_read_u32_index(np, "fsl,tdm-id", 0, &val);
+	if (ret) {
 		ret = -EINVAL;
 		dev_err(&pdev->dev, "No fsl,tdm-id property for this UCC\n");
 		goto err_miss_property;
 	}
-	utdm_priv->tdm_port = *prop;
+	utdm_priv->tdm_port = val;
 	ut_info->uf_info.tdm_num = utdm_priv->tdm_port ;
 
-	prop = of_get_property(np, "fsl,tdm-mode", NULL);
-	if (!prop) {
+	sprop = of_get_property(np, "fsl,tdm-mode", NULL);
+	if (!sprop) {
 		ret = -EINVAL;
 		dev_err(&pdev->dev, "No tdm-mode property for UCC\n");
 		goto err_miss_property;
 	}
-	utdm_priv->tdm_mode = set_tdm_mode((const char *)prop);
+	utdm_priv->tdm_mode = set_tdm_mode(sprop);
 
-	prop = of_get_property(np, "fsl,tdm-framer-type", NULL);
-	if (!prop) {
+	sprop = of_get_property(np, "fsl,tdm-framer-type", NULL);
+	if (!sprop) {
 		ret = -EINVAL;
 		dev_err(&pdev->dev, "No tdm-framer-type property for UCC\n");
 		goto err_miss_property;
 	}
-	utdm_priv->tdm_framer_type = set_tdm_framer((const char *)prop);
+	utdm_priv->tdm_framer_type = set_tdm_framer(sprop);
 
-	prop = of_get_property(np, "fsl,siram-entry-id", NULL);
-	if (!prop) {
+	ret = of_property_read_u32_index(np, "fsl,siram-entry-id", 0, &val);
+	if (ret) {
 		ret = -EINVAL;
 		dev_err(&pdev->dev, "No siram entry id for UCC\n");
 		goto err_miss_property;
 	}
-	utdm_priv->siram_entry_id = *(const u32 *)prop;
+	utdm_priv->siram_entry_id = val;
 
 	np2 = of_find_node_by_name(NULL, "si");
 	if (!np2) {
@@ -1009,11 +1008,11 @@ static void store_clk_config(struct ucc_tdm_private *utdm_priv)
 	struct qe_mux *qe_mux_reg = &qe_immr->qmx;
 
 	/* store si clk */
-	utdm_priv->cmxsi1cr_h = in_be32(&qe_mux_reg->cmxsi1cr_h);
-	utdm_priv->cmxsi1cr_l = in_be32(&qe_mux_reg->cmxsi1cr_l);
+	utdm_priv->cmxsi1cr_h = ioread32be(&qe_mux_reg->cmxsi1cr_h);
+	utdm_priv->cmxsi1cr_l = ioread32be(&qe_mux_reg->cmxsi1cr_l);
 
 	/* store si sync */
-	utdm_priv->cmxsi1syr = in_be32(&qe_mux_reg->cmxsi1syr);
+	utdm_priv->cmxsi1syr = ioread32be(&qe_mux_reg->cmxsi1syr);
 
 	/* store ucc clk */
 	memcpy_fromio(utdm_priv->cmxucr, qe_mux_reg->cmxucr, 4 * sizeof(u32));
@@ -1025,10 +1024,10 @@ static void resume_clk_config(struct ucc_tdm_private *utdm_priv)
 
 	memcpy_toio(qe_mux_reg->cmxucr, utdm_priv->cmxucr, 4 * sizeof(u32));
 
-	out_be32(&qe_mux_reg->cmxsi1cr_h, utdm_priv->cmxsi1cr_h);
-	out_be32(&qe_mux_reg->cmxsi1cr_l, utdm_priv->cmxsi1cr_l);
+	iowrite32be(utdm_priv->cmxsi1cr_h, &qe_mux_reg->cmxsi1cr_h);
+	iowrite32be(utdm_priv->cmxsi1cr_l, &qe_mux_reg->cmxsi1cr_l);
 
-	out_be32(&qe_mux_reg->cmxsi1syr, utdm_priv->cmxsi1syr);
+	iowrite32be(utdm_priv->cmxsi1syr, &qe_mux_reg->cmxsi1syr);
 
 }
 
@@ -1045,8 +1044,8 @@ static int ucc_tdm_suspend(struct device *dev)
 	uf_regs = utdm_priv->uf_regs;
 
 	/* backup gumr guemr*/
-	utdm_priv->gumr = in_be32(&uf_regs->gumr);
-	utdm_priv->guemr = in_8(&uf_regs->guemr);
+	utdm_priv->gumr = ioread32be(&uf_regs->gumr);
+	utdm_priv->guemr = ioread8(&uf_regs->guemr);
 
 	utdm_priv->ucc_pram_bak = kmalloc(sizeof(struct ucc_transparent_param),
 					GFP_KERNEL);
@@ -1087,25 +1086,25 @@ static int ucc_tdm_resume(struct device *dev)
 	uccf = utdm_priv->uccf;
 
 	/* restore gumr guemr */
-	out_8(&uf_regs->guemr, utdm_priv->guemr);
-	out_be32(&uf_regs->gumr, utdm_priv->gumr);
+	iowrite8(utdm_priv->guemr, &uf_regs->guemr);
+	iowrite32be(utdm_priv->gumr, &uf_regs->gumr);
 
 	/* Set Virtual Fifo registers */
-	out_be16(&uf_regs->urfs, uf_info->urfs);
-	out_be16(&uf_regs->urfet, uf_info->urfet);
-	out_be16(&uf_regs->urfset, uf_info->urfset);
-	out_be16(&uf_regs->utfs, uf_info->utfs);
-	out_be16(&uf_regs->utfet, uf_info->utfet);
-	out_be16(&uf_regs->utftt, uf_info->utftt);
+	iowrite16be(uf_info->urfs, &uf_regs->urfs);
+	iowrite16be(uf_info->urfet, &uf_regs->urfet);
+	iowrite16be(uf_info->urfset, &uf_regs->urfset);
+	iowrite16be(uf_info->utfs, &uf_regs->utfs);
+	iowrite16be(uf_info->utfet, &uf_regs->utfet);
+	iowrite16be(uf_info->utftt, &uf_regs->utftt);
 	/* utfb, urfb are offsets from MURAM base */
-	out_be32(&uf_regs->utfb, uccf->ucc_fast_tx_virtual_fifo_base_offset);
-	out_be32(&uf_regs->urfb, uccf->ucc_fast_rx_virtual_fifo_base_offset);
+	iowrite32be(uccf->ucc_fast_tx_virtual_fifo_base_offset, &uf_regs->utfb);
+	iowrite32be(uccf->ucc_fast_rx_virtual_fifo_base_offset, &uf_regs->urfb);
 
 	/* tdm Rx Tx and sync clock routing */
 	resume_clk_config(utdm_priv);
 
-	out_be32(&uf_regs->uccm, uf_info->uccm_mask);
-	out_be32(&uf_regs->ucce, 0xffffffff);
+	iowrite32be(uf_info->uccm_mask, &uf_regs->uccm);
+	iowrite32be(0xffffffff, &uf_regs->ucce);
 
 	ucc_fast_disable(utdm_priv->uccf, COMM_DIR_RX | COMM_DIR_TX);
 
@@ -1118,7 +1117,7 @@ static int ucc_tdm_resume(struct device *dev)
 		(u8)QE_CR_PROTOCOL_UNSPECIFIED, 0);
 
 	/* Set UPSMR normal mode */
-	out_be32(&uf_regs->upsmr, 0);
+	iowrite32be(0, &uf_regs->upsmr);
 
 	/* init parameter base */
 	cecr_subblock = ucc_fast_get_qe_cr_subblock(uf_info->ucc_num);
@@ -1140,18 +1139,18 @@ static int ucc_tdm_resume(struct device *dev)
 		else
 			bd_status = R_E | R_I | R_W | R_CM;
 
-		out_be32((u32 *)(utdm_priv->rx_bd + i), bd_status);
-		out_be32(&utdm_priv->rx_bd[i].buf, utdm_priv->dma_rx_addr
-				+ i * MAX_RX_BUF_LENGTH);
+		iowrite32be(bd_status, (u32 *)(utdm_priv->rx_bd + i));
+		iowrite32be(utdm_priv->dma_rx_addr + i * MAX_RX_BUF_LENGTH,
+			    &utdm_priv->rx_bd[i].buf);
 
 		if (i < (NUM_OF_BUF - 1))
 			bd_status =  T_I;
 		else
 			bd_status =  T_I | T_W;
 
-		out_be32((u32 *)(utdm_priv->tx_bd + i), bd_status);
-		out_be32(&utdm_priv->tx_bd[i].buf, utdm_priv->dma_tx_addr
-				+ i * MAX_RX_BUF_LENGTH);
+		iowrite32be(bd_status, (u32 *)(utdm_priv->tx_bd + i));
+		iowrite32be(utdm_priv->dma_tx_addr + i * MAX_RX_BUF_LENGTH,
+			    &utdm_priv->tx_bd[i].buf);
 	}
 
 	/* if tdm is busy enable TX and RX */
diff --git a/drivers/tdm/test/Kconfig b/drivers/tdm/test/Kconfig
index 39f9581..243c934 100644
--- a/drivers/tdm/test/Kconfig
+++ b/drivers/tdm/test/Kconfig
@@ -14,7 +14,7 @@ config TDM_TEST
 
 config UCC_TDM_TEST
 	tristate "UCC TDM test Module"
-	depends on FSL_SOC || CONFIG_QE
+	depends on FSL_SOC || QUICC_ENGINE
 	---help---
 	  This UCC TDM test module is a small test module to test
 	  ucc tdm transfer and receive data via ucc1.
diff --git a/include/linux/fsl/qe.h b/include/linux/fsl/qe.h
index ef4422c..f3836be 100644
--- a/include/linux/fsl/qe.h
+++ b/include/linux/fsl/qe.h
@@ -33,8 +33,6 @@
 #define MEM_PART_SECONDARY	1
 #define MEM_PART_MURAM		2
 
-extern int siram_init_flag;
-
 /* Clocks and BRGs */
 enum qe_clock {
 	QE_CLK_NONE = 0,
-- 
1.7.5.4

