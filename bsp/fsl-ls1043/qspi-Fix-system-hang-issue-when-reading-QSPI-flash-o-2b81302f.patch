From 26fd3e7af29eb9f934a768ce91077c430cd71976 Mon Sep 17 00:00:00 2001
From: Alison Wang <b18965@freescale.com>
Date: Fri, 28 Nov 2014 14:12:17 +0800
Subject: [PATCH 418/451] qspi: Fix system hang issue when reading QSPI flash
 on LS1021A TWR board

For the QuadSPI SPI NOR flash driver, quad reading is used. This patch will
add quad reading support for ST's flash n25q128a13 on LS1021A TWR board.

Signed-off-by: Alison Wang <alison.wang@freescale.com>
Change-Id: Icf3c1334825fb9a0fe957bc6b75fa4dfd54c6960
Reviewed-on: http://git.am.freescale.net:8181/24670
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Zhengxiong Jin <Jason.Jin@freescale.com>
Reviewed-by: Richard Schmitt <richard.schmitt@freescale.com>
Signed-off-by: Shaohui Xie <Shaohui.Xie@freescale.com>
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/mtd/spi-nor/spi-nor.c |   33 ++++++---------------------------
 1 files changed, 6 insertions(+), 27 deletions(-)

diff --git a/drivers/mtd/spi-nor/spi-nor.c b/drivers/mtd/spi-nor/spi-nor.c
index 006fb7c..a0a2d4f 100644
--- a/drivers/mtd/spi-nor/spi-nor.c
+++ b/drivers/mtd/spi-nor/spi-nor.c
@@ -125,20 +125,7 @@ static int read_cr(struct spi_nor *nor)
  */
 static inline int spi_nor_read_dummy_cycles(struct spi_nor *nor)
 {
-	u32 dummy;
-
 	switch (nor->flash_read) {
-	case SPI_NOR_DDR_QUAD:
-		/*
-		 * The m25p80.c can not support the DDR quad read.
-		 * We set the dummy cycles to 8 by default. The SPI NOR
-		 * controller driver can set it in its child DT node.
-		 * We parse it out here.
-		 */
-		if (nor->np && !of_property_read_u32(nor->np,
-				"spi-nor,ddr-quad-read-dummy", &dummy)) {
-			return dummy;
-		}
 	case SPI_NOR_FAST:
 	case SPI_NOR_DUAL:
 	case SPI_NOR_QUAD:
@@ -579,7 +566,8 @@ static const struct spi_device_id spi_nor_ids[] = {
 	{ "n25q032",     INFO(0x20ba16, 0, 64 * 1024,   64, 0) },
 	{ "n25q064",     INFO(0x20ba17, 0, 64 * 1024,  128, 0) },
 	{ "n25q128a11",  INFO(0x20bb18, 0, 64 * 1024,  256, 0) },
-	{ "n25q128a13",  INFO(0x20ba18, 0, 64 * 1024,  256, SPI_NOR_QUAD_READ) },
+	{ "n25q128a13",  INFO(0x20ba18, 0, 64 * 1024,  256,
+			SPI_NOR_QUAD_READ) },
 	{ "n25q256a",    INFO(0x20ba19, 0, 64 * 1024,  512, SECT_4K) },
 	{ "n25q512a",    INFO(0x20bb20, 0, 64 * 1024, 1024,
 	  SECT_4K | USE_FSR) },
@@ -834,7 +822,7 @@ static int spi_nor_write(struct mtd_info *mtd, loff_t to, size_t len,
 			if (page_size > nor->page_size)
 				page_size = nor->page_size;
 
-			ret = wait_till_ready(nor);
+			ret = spi_nor_wait_till_ready(nor);
 			if (ret)
 				goto write_err;
 
@@ -976,7 +964,7 @@ int spi_nor_scan(struct spi_nor *nor, const char *name, enum read_mode mode)
 	if (name && info->id_len) {
 		const struct spi_device_id *jid;
 
-		jid = nor->read_id(nor);
+		jid = spi_nor_read_id(nor);
 		if (IS_ERR(jid)) {
 			return PTR_ERR(jid);
 		} else if (jid != id) {
@@ -1083,16 +1071,6 @@ int spi_nor_scan(struct spi_nor *nor, const char *name, enum read_mode mode)
 
 	/* Default commands */
 	switch (nor->flash_read) {
-	case SPI_NOR_DDR_QUAD:
-		if (JEDEC_MFR(info->jedec_id) == CFI_MFR_AMD) { /* Spansion */
-			nor->read_opcode = SPINOR_OP_READ_1_4_4_D;
-		} else if (JEDEC_MFR(info->jedec_id) == CFI_MFR_ST) {
-			nor->read_opcode = SPINOR_OP_READ_1_1_4_D;
-		} else {
-			dev_err(dev, "DDR Quad Read is not supported.\n");
-			return -EINVAL;
-		}
-		break;
 	case SPI_NOR_QUAD:
 		nor->read_opcode = SPINOR_OP_READ_1_1_4;
 		break;
@@ -1166,8 +1144,9 @@ int spi_nor_scan(struct spi_nor *nor, const char *name, enum read_mode mode)
 				mtd->eraseregions[i].numblocks);
 	return 0;
 }
+EXPORT_SYMBOL_GPL(spi_nor_scan);
 
-const struct spi_device_id *spi_nor_match_id(char *name)
+static const struct spi_device_id *spi_nor_match_id(const char *name)
 {
 	const struct spi_device_id *id = spi_nor_ids;
 
-- 
1.7.5.4

