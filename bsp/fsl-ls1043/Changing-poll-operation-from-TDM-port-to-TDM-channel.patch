From 4a2b2ea37ef400afe4241e70e40c16bfc55ceff0 Mon Sep 17 00:00:00 2001
From: Sandeep Singh <Sandeep@freescale.com>
Date: Thu, 10 May 2012 14:41:42 +0000
Subject: [PATCH 213/451] Changing poll operation from TDM port to TDM channel

Since all read/write operations are in TDM are channel based, polling on TDM channel
for data instead of TDM port before going for read/write.

Also corrected a faulty error leg.

Signed-off-by: Sandeep Singh <Sandeep@freescale.com>
(cherry picked from commit 304c5cc5f167d1ac8990e36579cc2f87851f0cdd)
Change-Id: I5c0ec540c0db8e538e2b650ac0a0d5bdffaca336
Reviewed-on: http://git.am.freescale.net:8181/1159
Reviewed-by: Xu Jiucheng-B37781 <Jiucheng.Xu@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Xulin: Original patch taken from
Linux-LS1043A-SDK-V0.4-SOURCE-20150826-yocto.iso]
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/tdm/tdm-core.c      |   51 +++++++++++++-----------------------------
 drivers/tdm/test/tdm_test.c |    4 +-
 include/linux/tdm.h         |    4 +-
 3 files changed, 20 insertions(+), 39 deletions(-)

diff --git a/drivers/tdm/tdm-core.c b/drivers/tdm/tdm-core.c
index 3fd3242..97bd338 100644
--- a/drivers/tdm/tdm-core.c
+++ b/drivers/tdm/tdm-core.c
@@ -88,10 +88,11 @@ static int tdm_attach_driver_adap(struct tdm_driver *driver,
 
 	if (driver->attach_adapter) {
 		ret = driver->attach_adapter(adap);
-		if (ret < 0)
+		if (ret < 0) {
 			pr_err("attach_adapter failed for driver [%s] err:%d\n"
 				, driver->name, ret);
 			return ret;
+		}
 	}
 	adap->drv_count++;
 
@@ -574,9 +575,6 @@ unsigned int tdm_port_open(struct tdm_driver *driver, void **h_port)
 		goto out;
 	}
 
-	init_waitqueue_head(&port->ch_wait_queue);
-
-
 	port->rx_max_frames = NUM_SAMPLES_PER_FRAME;
 	port->port_cfg.port_mode = e_TDM_PORT_CHANNELIZED;
 
@@ -786,53 +784,34 @@ unsigned int tdm_channel_write(void *h_port, void *h_channel,
 }
 EXPORT_SYMBOL(tdm_channel_write);
 
-wait_queue_head_t *tdm_port_get_wait_queue(void  *h_port)
-{
-	struct tdm_port *port;
-	port = (struct tdm_port *)h_port;
-
-	if (port == NULL) { /* invalid handle*/
-		pr_err("Invalid Handle");
-		return NULL;
-	}
-
-	return &port->ch_wait_queue;
-
-}
-EXPORT_SYMBOL(tdm_port_get_wait_queue);
-
-/* Driver Function for select and poll. Based on Port no, it sleeps on
+/* Driver Function for select and poll. Based on Channel, it sleeps on
  * waitqueue */
-unsigned int tdm_port_poll(void *h_port, unsigned int wait_time)
+unsigned int tdm_ch_poll(void *h_channel, unsigned int wait_time)
 {
-	struct tdm_port *port;
+	struct tdm_channel *channel;
 	unsigned long timeout = msecs_to_jiffies(wait_time);
-	port = (struct tdm_port *)h_port;
+	channel = h_channel;
 
-	if (port == NULL) { /* invalid handle*/
-		pr_err("%s: Invalid Handle\n", __func__);
-		return -ENXIO;
-	}
-	if (!port->p_port_data || !port->in_use)
+	if (!channel->p_ch_data || !channel->in_use)
 		return -EIO;
 
-	if (port->p_port_data->rx_out_data->flag) {
+	if (channel->p_ch_data->rx_out_data->flag) {
 		pr_debug("Data Available");
 		return TDM_E_OK;
 	}
 	if (timeout) {
-		wait_event_interruptible_timeout(port->ch_wait_queue,
-					  port->p_port_data->rx_out_data->flag,
+		wait_event_interruptible_timeout(channel->ch_wait_queue,
+					  channel->p_ch_data->rx_out_data->flag,
 					  timeout);
 
-		if (port->p_port_data->rx_out_data->flag) {
+		if (channel->p_ch_data->rx_out_data->flag) {
 			pr_debug("Data Available");
 			return TDM_E_OK;
 		}
 	}
 	return -EAGAIN;
 }
-EXPORT_SYMBOL(tdm_port_poll);
+EXPORT_SYMBOL(tdm_ch_poll);
 
 unsigned int tdm_port_get_stats(void *h_port, struct tdm_port_stats *portStat)
 {
@@ -938,6 +917,8 @@ static int tdm_data_rx_deinterleave(struct tdm_adapter *adap)
 						channel->p_ch_data->rx_data_fifo
 						: ch_bd+1;
 					ch_data = 1;
+					wake_up_interruptible
+						(&channel->ch_wait_queue);
 				}
 			} else {
 				port->port_stat.rx_pkt_drop_count++;
@@ -947,7 +928,6 @@ static int tdm_data_rx_deinterleave(struct tdm_adapter *adap)
 
 		if (ch_data) {
 			/*	Wake up the Port Data Poll event */
-			wake_up_interruptible(&port->ch_wait_queue);
 #ifdef	TDM_CORE_DEBUG
 			pr_info("Port RX-%d-%d\n", channel->ch_id, ch_data_len);
 			for (i = 0; i < ch_data_len; i++)
@@ -1100,7 +1080,8 @@ int tdm_channel_open(u16 chanid, u16 ch_width, struct tdm_port *port,
 		goto out;
 	}
 
-	p_ch_data = kzalloc(sizeof(struct tdm_port_data), GFP_KERNEL);
+	init_waitqueue_head(&channel->ch_wait_queue);
+	p_ch_data = kzalloc(sizeof(struct tdm_ch_data), GFP_KERNEL);
 	if (!p_ch_data) {
 		res = -ENOMEM;
 		goto outdata;
diff --git a/drivers/tdm/test/tdm_test.c b/drivers/tdm/test/tdm_test.c
index 243936e..40ea699 100644
--- a/drivers/tdm/test/tdm_test.c
+++ b/drivers/tdm/test/tdm_test.c
@@ -109,7 +109,7 @@ static int tdm_thread(void *ptr)
 	while ((poll < poll_count) && !kthread_should_stop()) {
 
 		poll++;
-		while (tdm_port_poll(h_port, 10) != TDM_E_OK)
+		while (tdm_ch_poll(h_channel1, 10) != TDM_E_OK)
 				continue;
 
 		ret = tdm_channel_read(h_port, h_channel1, p_data1, &size);
@@ -214,7 +214,7 @@ static int test_detach_adapter(struct tdm_adapter *adap)
 }
 
 static const struct tdm_device_id test_id[] = {
-	{ "fsl", 0 },
+	{ "fsl_tdm", 0 },
 	{ }
 };
 
diff --git a/include/linux/tdm.h b/include/linux/tdm.h
index 646ebc2..93ec1c0 100644
--- a/include/linux/tdm.h
+++ b/include/linux/tdm.h
@@ -177,7 +177,6 @@ struct tdm_port {
 					 TDM port statistics. */
 	struct tdm_port_data *p_port_data;	/* a structure parameters
 						defining tdm channelised data */
-	wait_queue_head_t ch_wait_queue;	/* waitQueue for RX Port Data */
 
 	struct tdm_driver *driver;	/* driver for this port */
 	struct tdm_adapter *adapter;	/* adapter for this port */
@@ -220,6 +219,7 @@ struct tdm_channel {
 	u16 in_use;			/* channel is enabled? */
 	struct tdm_ch_cfg ch_cfg;	/* channel configuration */
 	struct tdm_ch_data *p_ch_data;	/* data storage space for channel */
+	wait_queue_head_t ch_wait_queue;/* waitQueue for RX Channel Data */
 };
 
 /* tdm_adapt_algorithm is for accessing the routines of device */
@@ -334,7 +334,7 @@ extern unsigned int tdm_port_close(void *);
 extern unsigned int tdm_port_ioctl(void *, unsigned int, unsigned long);
 extern unsigned int tdm_channel_read(void *, void *, void *, u16 *);
 extern unsigned int tdm_channel_write(void *, void * , void *, u16);
-extern unsigned int tdm_port_poll(void *, unsigned int);
+extern unsigned int tdm_ch_poll(void *, unsigned int);
 
 extern int tdm_channel_open(u16, u16, struct tdm_port *, void **);
 extern int tdm_channel_close(u16, u16, struct tdm_port *,
-- 
1.7.5.4

