From d38113d8e11665349ca49fd9547ffa99c5288b5a Mon Sep 17 00:00:00 2001
From: WRS Support <support@windriver.com>
Date: Fri, 2 Oct 2009 16:41:51 -0400
Subject: [PATCH 3/3] 8250: guest/hypervisor changes for 8250 UART (FIXME FIXME)

This needs to be pushed down into the non-branch specific
patches since it undoes some of the crap that was erroneously
plopped down in there.

Signed-off-by: Dev Null <dev.null@windriver.com>
---
 drivers/serial/8250.c |   23 +++--------------------
 1 files changed, 3 insertions(+), 20 deletions(-)

diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index 093864a..137cd5f 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -44,11 +44,6 @@
 
 #include "8250.h"
 
-#include <linux/wrhv.h>
-#if defined(CONFIG_WRHV) && defined(CONFIG_PPC) && !defined(CONFIG_WRHV_8572)
-#define WRHV_PPC_DUART 1
-#endif
-
 /*
  * Configuration:
  *   share_irqs - whether we pass IRQF_SHARED to request_irq().  This option
@@ -945,10 +940,6 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 		return;
 	}
 
-#ifdef WRHV_PPC_DUART
-	/* This doesn't co-operate very well with the DUART being
-	 * used from another guest OS */
-#else
 	/*
 	 * Try writing and reading the UART_IER_UUE bit (b6).
 	 * If it works, this is probably one of the Xscale platform's
@@ -983,7 +974,6 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 		DEBUG_AUTOCONF("Couldn't force IER_UUE to 0 ");
 	}
 	serial_outp(up, UART_IER, iersave);
-#endif /* WRHV_PPC_DUART */
 }
 
 /*
@@ -1249,9 +1239,8 @@ static void serial8250_start_tx(struct uart_port *port)
 
 	if (!(up->ier & UART_IER_THRI)) {
 		up->ier |= UART_IER_THRI;
-#ifndef WRHV_PPC_DUART
 		serial_out(up, UART_IER, up->ier);
-#endif
+
 		if (up->bugs & UART_BUG_TXEN) {
 			unsigned char lsr, iir;
 			lsr = serial_in(up, UART_LSR);
@@ -1638,9 +1627,7 @@ static void serial8250_timeout(unsigned long data)
 	unsigned int iir;
 
 	iir = serial_in(up, UART_IIR);
-#ifndef WRHV_PPC_DUART
 	if (!(iir & UART_IIR_NO_INT))
-#endif
 		serial8250_handle_port(up);
 	mod_timer(&up->timer, jiffies + poll_timeout(up->port.timeout));
 }
@@ -2016,9 +2003,6 @@ static int serial8250_startup(struct uart_port *port)
 	if (up->port.flags & UPF_NO_TXEN_TEST)
 		goto dont_test_tx_en;
 
-#ifdef WRHV_PPC_DUART
-	up->bugs |= UART_BUG_TXEN;
-#else
 	/*
 	 * Do a quick test to see if we receive an
 	 * interrupt when we enable the TX irq.
@@ -2037,7 +2021,6 @@ static int serial8250_startup(struct uart_port *port)
 	} else {
 		up->bugs &= ~UART_BUG_TXEN;
 	}
-#endif /* WRHV_PPC_DUART */
 
 dont_test_tx_en:
 	spin_unlock_irqrestore(&up->port.lock, flags);
@@ -2059,10 +2042,8 @@ dont_test_tx_en:
 	 * are set via set_termios(), which will be occurring imminently
 	 * anyway, so we don't enable them here.
 	 */
-#ifndef WRHV_PPC_DUART
 	up->ier = UART_IER_RLSI | UART_IER_RDI;
 	serial_outp(up, UART_IER, up->ier);
-#endif
 
 	if (up->port.flags & UPF_FOURPORT) {
 		unsigned int icp;
@@ -2293,7 +2274,9 @@ serial8250_set_termios(struct uart_port *port, struct ktermios *termios,
 		/* Switch to bank 2 not bank 1, to avoid resetting EXCR2 */
 		serial_outp(up, UART_LCR, 0xe0);
 	} else {
+#if !defined(CONFIG_WRHV) && !defined(CONFIG_PPC)
 		serial_outp(up, UART_LCR, cval | UART_LCR_DLAB);/* set DLAB */
+#endif
 	}
 
 	serial_dl_write(up, quot);
-- 
1.6.3.3

