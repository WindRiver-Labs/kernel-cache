From 6a2ba8f59092bae737f2bbb8f532cb179084f0b0 Mon Sep 17 00:00:00 2001
From: WRS Support <support@windriver.com>
Date: Fri, 2 Oct 2009 16:41:51 -0400
Subject: [PATCH] 8250: guest/hypervisor changes for 8250 UART (FIXME FIXME)

This needs to be pushed down into the non-branch specific
patches since it undoes some of the crap that was erroneously
plopped down in there.

Signed-off-by: Dev Null <dev.null@windriver.com>
---
 drivers/serial/8250.c |   24 +++---------------------
 1 files changed, 3 insertions(+), 21 deletions(-)

diff --git a/drivers/serial/8250.c b/drivers/serial/8250.c
index 4e5fdf3..03f9659 100644
--- a/drivers/serial/8250.c
+++ b/drivers/serial/8250.c
@@ -44,11 +44,6 @@
 
 #include "8250.h"
 
-#include <linux/wrhv.h>
-#if defined(CONFIG_WRHV) && defined(CONFIG_PPC) && !defined(CONFIG_WRHV_8572)
-#define WRHV_PPC_DUART 1
-#endif
-
 /*
  * Configuration:
  *   share_irqs - whether we pass IRQF_SHARED to request_irq().  This option
@@ -946,11 +941,6 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 	}
 
 	/*
-	 * The below code doesn't cooperate very well with the DUART
-	 * being used from another guest OS
-	 */
-#ifndef WRHV_PPC_DUART
-	/*
 	 * Try writing and reading the UART_IER_UUE bit (b6).
 	 * If it works, this is probably one of the Xscale platform's
 	 * internal UARTs.
@@ -984,7 +974,6 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 		DEBUG_AUTOCONF("Couldn't force IER_UUE to 0 ");
 	}
 	serial_outp(up, UART_IER, iersave);
-#endif /* WRHV_PPC_DUART */
 }
 
 /*
@@ -1250,9 +1239,8 @@ static void serial8250_start_tx(struct uart_port *port)
 
 	if (!(up->ier & UART_IER_THRI)) {
 		up->ier |= UART_IER_THRI;
-#ifndef WRHV_PPC_DUART
 		serial_out(up, UART_IER, up->ier);
-#endif
+
 		if (up->bugs & UART_BUG_TXEN) {
 			unsigned char lsr, iir;
 			lsr = serial_in(up, UART_LSR);
@@ -1620,9 +1608,7 @@ static void serial8250_timeout(unsigned long data)
 	unsigned int iir;
 
 	iir = serial_in(up, UART_IIR);
-#ifndef WRHV_PPC_DUART
 	if (!(iir & UART_IIR_NO_INT))
-#endif
 		serial8250_handle_port(up);
 	mod_timer(&up->timer, jiffies + poll_timeout(up->port.timeout));
 }
@@ -1998,9 +1984,6 @@ static int serial8250_startup(struct uart_port *port)
 	if (up->port.flags & UPF_NO_TXEN_TEST)
 		goto dont_test_tx_en;
 
-#ifdef WRHV_PPC_DUART
-	up->bugs |= UART_BUG_TXEN;
-#else
 	/*
 	 * Do a quick test to see if we receive an
 	 * interrupt when we enable the TX irq.
@@ -2019,7 +2002,6 @@ static int serial8250_startup(struct uart_port *port)
 	} else {
 		up->bugs &= ~UART_BUG_TXEN;
 	}
-#endif /* WRHV_PPC_DUART */
 
 dont_test_tx_en:
 	spin_unlock_irqrestore(&up->port.lock, flags);
@@ -2041,10 +2023,8 @@ dont_test_tx_en:
 	 * are set via set_termios(), which will be occurring imminently
 	 * anyway, so we don't enable them here.
 	 */
-#ifndef WRHV_PPC_DUART
 	up->ier = UART_IER_RLSI | UART_IER_RDI;
 	serial_outp(up, UART_IER, up->ier);
-#endif
 
 	if (up->port.flags & UPF_FOURPORT) {
 		unsigned int icp;
@@ -2275,7 +2255,9 @@ serial8250_set_termios(struct uart_port *port, struct ktermios *termios,
 		/* Switch to bank 2 not bank 1, to avoid resetting EXCR2 */
 		serial_outp(up, UART_LCR, 0xe0);
 	} else {
+#if !defined(CONFIG_WRHV) && !defined(CONFIG_PPC)
 		serial_outp(up, UART_LCR, cval | UART_LCR_DLAB);/* set DLAB */
+#endif
 	}
 
 	serial_dl_write(up, quot);
-- 
1.6.3.3

