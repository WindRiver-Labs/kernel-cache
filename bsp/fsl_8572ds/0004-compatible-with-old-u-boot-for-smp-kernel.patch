From c2540bea7c9a7746eef0ee4a3dad40ff22e0b062 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Thu, 18 Dec 2008 17:27:13 +0800
Subject: [PATCH] compatible with old u-boot for smp kernel

Old u-boot doesn't support multiprocessors, so we have to
release the secondary cpu in kernel code. This code come from
mpc8572ds smp patch in wrlinux-2.0.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/include/asm/pgalloc-32.h |    4 +-
 arch/powerpc/include/asm/reg_booke.h  |    2 +
 arch/powerpc/kernel/head_fsl_booke.S  |   88 +++++++++++++++++++++++++++++++++
 arch/powerpc/mm/pgtable_32.c          |   23 +++++---
 arch/powerpc/platforms/85xx/Kconfig   |    8 +++
 arch/powerpc/platforms/85xx/smp.c     |   46 +++++++++++++++++-
 6 files changed, 159 insertions(+), 12 deletions(-)

diff --git a/arch/powerpc/include/asm/pgalloc-32.h b/arch/powerpc/include/asm/pgalloc-32.h
index 1cb9245..d6c43a0 100644
--- a/arch/powerpc/include/asm/pgalloc-32.h
+++ b/arch/powerpc/include/asm/pgalloc-32.h
@@ -36,14 +36,14 @@ extern pgtable_t pte_alloc_one(struct mm_struct *mm, unsigned long addr);
 extern void pte_free_kernel(struct mm_struct *mm, pte_t *pte);
 extern void pte_free(struct mm_struct *mm, pgtable_t pte);
 
-#ifdef CONFIG_SMP
+#if defined(CONFIG_BOOKE) && defined(CONFIG_SMP)
 extern void pgtable_free_tlb(struct mmu_gather *tlb, struct page *pte);
 
 #define __pte_free_tlb(tlb, pte)	pgtable_free_tlb(tlb, pte)
 
 #else
 #define __pte_free_tlb(tlb, pte)	pte_free((tlb)->mm, (pte))
-#endif	/* CONFIG_SMP */
+#endif
 
 #define check_pgt_cache()	do { } while (0)
 
diff --git a/arch/powerpc/include/asm/reg_booke.h b/arch/powerpc/include/asm/reg_booke.h
index be980f4..a5aba02 100644
--- a/arch/powerpc/include/asm/reg_booke.h
+++ b/arch/powerpc/include/asm/reg_booke.h
@@ -386,12 +386,14 @@
 #define ICCR_CACHE	1		/* Cacheable */
 
 /* Bit definitions for L1CSR0. */
+#define L1CSR0_DCPE	0x00010000	/* Data Cache Parity Enable */
 #define L1CSR0_CLFC	0x00000100	/* Cache Lock Bits Flash Clear */
 #define L1CSR0_DCFI	0x00000002	/* Data Cache Flash Invalidate */
 #define L1CSR0_CFI	0x00000002	/* Cache Flash Invalidate */
 #define L1CSR0_DCE	0x00000001	/* Data Cache Enable */
 
 /* Bit definitions for L1CSR1. */
+#define L1CSR1_ICPE	0x00010000	/* Instr Cache Parity Enable */
 #define L1CSR1_ICLFR	0x00000100	/* Instr Cache Lock Bits Flash Reset */
 #define L1CSR1_ICFI	0x00000002	/* Instr Cache Flash Invalidate */
 #define L1CSR1_ICE	0x00000001	/* Instr Cache Enable */
diff --git a/arch/powerpc/kernel/head_fsl_booke.S b/arch/powerpc/kernel/head_fsl_booke.S
index d697d9c..bf0f352 100644
--- a/arch/powerpc/kernel/head_fsl_booke.S
+++ b/arch/powerpc/kernel/head_fsl_booke.S
@@ -1314,6 +1314,85 @@ _GLOBAL(flush_dcache_L1)
 	blr
 
 #ifdef CONFIG_SMP
+#ifdef CONFIG_MPC8572DS_UBOOT_COMPAT
+/* To boot secondary cpus, we need a place for them to start up.
+ * Normally, they start at 0xfffffffc, but that's usually the
+ * firmware, and we don't want to have to run the firmware again.
+ * Instead, the primary cpu will set the BPTR to point here to
+ * this page.  We then set up the core, and head to
+ * start_secondary.  Note that this means that the code below
+ * must never exceed 1023 instructions (the branch at the end
+ * would then be the 1024th).
+ */
+	.globl	__secondary_start_page
+	.align	12
+__secondary_start_page:
+/* First do some preliminary setup */
+	lis	r3, HID0_EMCP@h /* Enable machine check */
+	ori	r3,r3,0x4000	/* Enable the Time Base */
+#ifdef CONFIG_PHYS_64BIT
+	ori	r3,r3,0x0080	/* Enable MAS7 updates */
+#endif
+	mtspr	SPRN_HID0,r3
+
+	mfspr	r3, SPRN_TCR
+	oris	r3,r3, TCR_DIE@h /* Enable the Decrementer Interrupt */
+	mtspr	SPRN_TCR,r3
+
+	li	r3,0x3000
+	mtspr	SPRN_HID1,r3
+
+	/* Enable branch prediction */
+	li	r3,0x201
+	mtspr	SPRN_BUCSR,r3
+
+	/* Enable/invalidate the I-Cache */
+	mfspr	r0,SPRN_L1CSR1
+	ori	r0,r0,(L1CSR1_ICFI|L1CSR1_ICE)
+	oris	r0,r0,L1CSR1_ICPE@h
+	mtspr	SPRN_L1CSR1,r0
+	isync
+
+	/* Enable/invalidate the D-Cache */
+	mfspr	r0,SPRN_L1CSR0
+	ori	r0,r0,(L1CSR0_DCFI|L1CSR0_DCE)
+	oris	r0,r0,L1CSR0_DCPE@h
+	msync
+	isync
+	mtspr	SPRN_L1CSR0,r0
+	isync
+
+
+/*
+ * Coming here, we know the cpu has one TLB mapping in TLB1[0]
+ * which maps 0xfffff000-0xffffffff one-to-one.  We set up a
+ * second mapping that maps 0 to 0 for 16M, and then we jump to
+ * __early_start
+ */
+	lis	r6,0x1001	/* Set TLB=1 and ESEL=1 */
+	mtspr	SPRN_MAS0,r6
+	lis	r6,(MAS1_VALID|MAS1_IPROT)@h
+	ori	r6,r6,(MAS1_TSIZE(BOOKE_PAGESZ_16M))@l
+	mtspr	SPRN_MAS1,r6
+	li	r6,0
+	mtspr	SPRN_MAS2,r6	/* EPN is 0 */
+	lis	r7,0	/* RPN is 0*/
+	ori	r7,r7,(MAS3_SX|MAS3_SW|MAS3_SR)
+	mtspr	SPRN_MAS3,r7
+	tlbwe
+
+/* Now we have another mapping for this page, so we jump to that
+ * mapping
+ */
+	mfmsr	r4
+	lis	r7,__early_start@h
+	ori	r7,r7,__early_start@l
+	rlwinm	r7,r7,0,20,31
+	mtspr	SPRN_SRR0,r7
+	mtspr	SPRN_SRR1,r4
+	rfi
+#endif  /* CONFIG_MPC8572DS_UBOOT_COMPAT */
+
 /* When we get here, r24 needs to hold the CPU # */
 	.globl __secondary_start
 __secondary_start:
@@ -1378,6 +1457,15 @@ __secondary_start:
 	.globl __secondary_hold_acknowledge
 __secondary_hold_acknowledge:
 	.long	-1
+
+#ifdef CONFIG_MPC8572DS_UBOOT_COMPAT
+	/* Fill in the empty space.  The actual reset vector is
+	 * the last word of the page */
+__secondary_start_code_end:
+	.space 4092 - (__secondary_start_code_end - __secondary_start_page)
+__secondary_reset_vector:
+	b	__secondary_start_page
+#endif
 #endif
 
 /*
diff --git a/arch/powerpc/mm/pgtable_32.c b/arch/powerpc/mm/pgtable_32.c
index 153f59f..3775a5b 100644
--- a/arch/powerpc/mm/pgtable_32.c
+++ b/arch/powerpc/mm/pgtable_32.c
@@ -85,13 +85,12 @@ extern unsigned long p_mapped_by_tlbcam(unsigned long pa);
 #define PGDIR_ORDER	0
 #endif
 
-#ifdef CONFIG_SMP
+#if defined(CONFIG_BOOKE) && defined(CONFIG_SMP)
 struct pte_freelist_batch
 {
 	struct rcu_head	rcu;
 	unsigned int	index;
 	struct page *	tables[0];
-	struct mm_struct *mm;
 };
 
 #define PTE_FREELIST_SIZE \
@@ -100,6 +99,13 @@ struct pte_freelist_batch
 
 DEFINE_PER_CPU(struct pte_freelist_batch *, pte_freelist_cur);
 
+static inline void pgtable_free(struct page *pte)
+{
+	pgtable_page_dtor(pte);
+	if (page_address(pte))
+		__free_page(pte);
+}
+
 static void pte_free_smp_sync(void *arg)
 {
 	/* Do nothing, just ensure we sync with all CPUs */
@@ -108,11 +114,11 @@ static void pte_free_smp_sync(void *arg)
 /* This is only called when we are critically out of memory
  * (and fail to get a page in pte_free_tlb).
  */
-static void pgtable_free_now(struct mm_struct *mm, struct page *pte)
+static void pgtable_free_now(struct page *pte)
 {
 	smp_call_function(pte_free_smp_sync, NULL, 1);
 
-	pte_free(mm, pte);
+	pgtable_free(pte);
 }
 
 static void pte_free_rcu_callback(struct rcu_head *head)
@@ -122,7 +128,7 @@ static void pte_free_rcu_callback(struct rcu_head *head)
 	unsigned int i;
 
 	for (i = 0; i < batch->index; i++)
-		pte_free(batch->mm, batch->tables[i]);
+		pgtable_free(batch->tables[i]);
 
 	free_page((unsigned long)batch);
 }
@@ -141,27 +147,26 @@ void pgtable_free_tlb(struct mmu_gather *tlb, struct page *pte)
 
 	if (atomic_read(&tlb->mm->mm_users) < 2 ||
 	    cpus_equal(tlb->mm->cpu_vm_mask, local_cpumask)) {
-		pte_free(tlb->mm, pte);
+		pgtable_free(pte);
 		return;
 	}
 
 	if (*batchp == NULL) {
 		*batchp = (struct pte_freelist_batch *)__get_free_page(GFP_ATOMIC);
 		if (*batchp == NULL) {
-			pgtable_free_now(tlb->mm, pte);
+			pgtable_free_now(pte);
 			return;
 		}
 		(*batchp)->index = 0;
 	}
 	(*batchp)->tables[(*batchp)->index++] = pte;
 	if ((*batchp)->index == PTE_FREELIST_SIZE) {
-		(*batchp)->mm = tlb->mm;
 		pte_free_submit(*batchp);
 		*batchp = NULL;
 	}
 }
 
-#endif	/* CONFIG_SMP */
+#endif
 
 pgd_t *pgd_alloc(struct mm_struct *mm)
 {
diff --git a/arch/powerpc/platforms/85xx/Kconfig b/arch/powerpc/platforms/85xx/Kconfig
index 291675b..68bef27 100644
--- a/arch/powerpc/platforms/85xx/Kconfig
+++ b/arch/powerpc/platforms/85xx/Kconfig
@@ -120,3 +120,11 @@ endif # MPC85xx
 
 config TQM85xx
 	bool
+
+config MPC8572DS_UBOOT_COMPAT
+	bool "Compatible with old u-boot"
+	depends on MPC85xx_DS && SMP
+	default n
+	help
+	  Old u-boot does not support multiprocessor, so we have to release
+	  the secondary cpu in kernel code.
diff --git a/arch/powerpc/platforms/85xx/smp.c b/arch/powerpc/platforms/85xx/smp.c
index c91576a..246fdc5 100644
--- a/arch/powerpc/platforms/85xx/smp.c
+++ b/arch/powerpc/platforms/85xx/smp.c
@@ -26,6 +26,33 @@
 extern volatile unsigned long __secondary_hold_acknowledge;
 extern void __early_start(void);
 
+#ifdef CONFIG_MPC8572DS_UBOOT_COMPAT
+extern void __secondary_start_page(void);
+#define EEBPCR_CPU1_EN	0x02000000
+#define EEBPCR_CPU0_EN	0x01000000
+#define MPC85xx_ECM_OFFSET 0x1000
+#define MPC85xx_ECM_SIZE 0xf00
+#define ECM_PORT_CONFIG_OFFSET 0x0010
+#define MPC85xx_BPTR_OFFSET 0x20
+#define BPTR_EN	0x80000000
+
+static void __init
+smp_85xx_release_core(int nr)
+{
+	__iomem u32 *ecm_vaddr;
+	unsigned long pcr;
+
+	/*
+	 * Startup Core #nr.
+	 */
+	ecm_vaddr = ioremap(get_immrbase() + MPC85xx_ECM_OFFSET,
+			    MPC85xx_ECM_SIZE);
+	pcr = in_be32(ecm_vaddr + (ECM_PORT_CONFIG_OFFSET >> 2));
+	pcr |= EEBPCR_CPU1_EN;
+	out_be32(ecm_vaddr + (ECM_PORT_CONFIG_OFFSET >> 2), pcr);
+}
+#endif
+
 #define BOOT_ENTRY_ADDR_UPPER	0
 #define BOOT_ENTRY_ADDR_LOWER	1
 #define BOOT_ENTRY_R3_UPPER	2
@@ -41,9 +68,13 @@ static void __init
 smp_85xx_kick_cpu(int nr)
 {
 	unsigned long flags;
-	const u64 *cpu_rel_addr;
 	__iomem u32 *bptr_vaddr;
+#ifdef CONFIG_MPC8572DS_UBOOT_COMPAT
+	u32 bptr, oldbptr;
+#else
+	const u64 *cpu_rel_addr;
 	struct device_node *np;
+#endif
 	int n = 0;
 
 	WARN_ON (nr < 0 || nr >= NR_CPUS);
@@ -52,6 +83,16 @@ smp_85xx_kick_cpu(int nr)
 
 	local_irq_save(flags);
 
+#ifdef CONFIG_MPC8572DS_UBOOT_COMPAT
+	/* Get the BPTR */
+	bptr_vaddr = ioremap(get_immrbase() + MPC85xx_BPTR_OFFSET, 4);
+	/* Set the BPTR to the secondary boot page */
+	oldbptr = in_be32(bptr_vaddr);
+	bptr = (BPTR_EN | (__pa((unsigned)__secondary_start_page) >> 12));
+	out_be32(bptr_vaddr, bptr);
+	/* Kick that CPU */
+	smp_85xx_release_core(nr);
+#else
 	np = of_get_cpu_node(nr, NULL);
 	cpu_rel_addr = of_get_property(np, "cpu-release-addr", NULL);
 
@@ -65,6 +106,7 @@ smp_85xx_kick_cpu(int nr)
 
 	out_be32(bptr_vaddr + BOOT_ENTRY_PIR, nr);
 	out_be32(bptr_vaddr + BOOT_ENTRY_ADDR_LOWER, __pa(__early_start));
+#endif
 
 	/* Wait a bit for the CPU to ack. */
 	while ((__secondary_hold_acknowledge != nr) && (++n < 1000))
@@ -94,6 +136,8 @@ struct smp_ops_t smp_85xx_ops = {
 	.probe = smp_mpic_probe,
 	.kick_cpu = smp_85xx_kick_cpu,
 	.setup_cpu = smp_85xx_setup_cpu,
+	.take_timebase = smp_generic_take_timebase,
+	.give_timebase = smp_generic_give_timebase,
 };
 
 void __init
-- 
1.6.0.3

