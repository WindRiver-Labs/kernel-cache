From 6f4f65f3f72287418336c779604ed20a1863b636 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Thu, 18 Dec 2008 17:27:13 +0800
Subject: [PATCH] compatible with old u-boot for smp kernel

Old u-boot doesn't support multiprocessors, so we have to
release the secondary cpu in kernel code. This code come from
mpc8572ds smp patch in wrlinux-2.0.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/include/asm/reg_booke.h |    2 +
 arch/powerpc/kernel/head_fsl_booke.S |   88 ++++++++++++++++++++++++++++++++++
 arch/powerpc/platforms/85xx/Kconfig  |    8 +++
 arch/powerpc/platforms/85xx/smp.c    |   46 +++++++++++++++++-
 4 files changed, 143 insertions(+), 1 deletions(-)

diff --git a/arch/powerpc/include/asm/reg_booke.h b/arch/powerpc/include/asm/reg_booke.h
index be980f4..a5aba02 100644
--- a/arch/powerpc/include/asm/reg_booke.h
+++ b/arch/powerpc/include/asm/reg_booke.h
@@ -386,12 +386,14 @@
 #define ICCR_CACHE	1		/* Cacheable */
 
 /* Bit definitions for L1CSR0. */
+#define L1CSR0_DCPE	0x00010000	/* Data Cache Parity Enable */
 #define L1CSR0_CLFC	0x00000100	/* Cache Lock Bits Flash Clear */
 #define L1CSR0_DCFI	0x00000002	/* Data Cache Flash Invalidate */
 #define L1CSR0_CFI	0x00000002	/* Cache Flash Invalidate */
 #define L1CSR0_DCE	0x00000001	/* Data Cache Enable */
 
 /* Bit definitions for L1CSR1. */
+#define L1CSR1_ICPE	0x00010000	/* Instr Cache Parity Enable */
 #define L1CSR1_ICLFR	0x00000100	/* Instr Cache Lock Bits Flash Reset */
 #define L1CSR1_ICFI	0x00000002	/* Instr Cache Flash Invalidate */
 #define L1CSR1_ICE	0x00000001	/* Instr Cache Enable */
diff --git a/arch/powerpc/kernel/head_fsl_booke.S b/arch/powerpc/kernel/head_fsl_booke.S
index d697d9c..bf0f352 100644
--- a/arch/powerpc/kernel/head_fsl_booke.S
+++ b/arch/powerpc/kernel/head_fsl_booke.S
@@ -1314,6 +1314,85 @@ _GLOBAL(flush_dcache_L1)
 	blr
 
 #ifdef CONFIG_SMP
+#ifdef CONFIG_MPC8572DS_UBOOT_COMPAT
+/* To boot secondary cpus, we need a place for them to start up.
+ * Normally, they start at 0xfffffffc, but that's usually the
+ * firmware, and we don't want to have to run the firmware again.
+ * Instead, the primary cpu will set the BPTR to point here to
+ * this page.  We then set up the core, and head to
+ * start_secondary.  Note that this means that the code below
+ * must never exceed 1023 instructions (the branch at the end
+ * would then be the 1024th).
+ */
+	.globl	__secondary_start_page
+	.align	12
+__secondary_start_page:
+/* First do some preliminary setup */
+	lis	r3, HID0_EMCP@h /* Enable machine check */
+	ori	r3,r3,0x4000	/* Enable the Time Base */
+#ifdef CONFIG_PHYS_64BIT
+	ori	r3,r3,0x0080	/* Enable MAS7 updates */
+#endif
+	mtspr	SPRN_HID0,r3
+
+	mfspr	r3, SPRN_TCR
+	oris	r3,r3, TCR_DIE@h /* Enable the Decrementer Interrupt */
+	mtspr	SPRN_TCR,r3
+
+	li	r3,0x3000
+	mtspr	SPRN_HID1,r3
+
+	/* Enable branch prediction */
+	li	r3,0x201
+	mtspr	SPRN_BUCSR,r3
+
+	/* Enable/invalidate the I-Cache */
+	mfspr	r0,SPRN_L1CSR1
+	ori	r0,r0,(L1CSR1_ICFI|L1CSR1_ICE)
+	oris	r0,r0,L1CSR1_ICPE@h
+	mtspr	SPRN_L1CSR1,r0
+	isync
+
+	/* Enable/invalidate the D-Cache */
+	mfspr	r0,SPRN_L1CSR0
+	ori	r0,r0,(L1CSR0_DCFI|L1CSR0_DCE)
+	oris	r0,r0,L1CSR0_DCPE@h
+	msync
+	isync
+	mtspr	SPRN_L1CSR0,r0
+	isync
+
+
+/*
+ * Coming here, we know the cpu has one TLB mapping in TLB1[0]
+ * which maps 0xfffff000-0xffffffff one-to-one.  We set up a
+ * second mapping that maps 0 to 0 for 16M, and then we jump to
+ * __early_start
+ */
+	lis	r6,0x1001	/* Set TLB=1 and ESEL=1 */
+	mtspr	SPRN_MAS0,r6
+	lis	r6,(MAS1_VALID|MAS1_IPROT)@h
+	ori	r6,r6,(MAS1_TSIZE(BOOKE_PAGESZ_16M))@l
+	mtspr	SPRN_MAS1,r6
+	li	r6,0
+	mtspr	SPRN_MAS2,r6	/* EPN is 0 */
+	lis	r7,0	/* RPN is 0*/
+	ori	r7,r7,(MAS3_SX|MAS3_SW|MAS3_SR)
+	mtspr	SPRN_MAS3,r7
+	tlbwe
+
+/* Now we have another mapping for this page, so we jump to that
+ * mapping
+ */
+	mfmsr	r4
+	lis	r7,__early_start@h
+	ori	r7,r7,__early_start@l
+	rlwinm	r7,r7,0,20,31
+	mtspr	SPRN_SRR0,r7
+	mtspr	SPRN_SRR1,r4
+	rfi
+#endif  /* CONFIG_MPC8572DS_UBOOT_COMPAT */
+
 /* When we get here, r24 needs to hold the CPU # */
 	.globl __secondary_start
 __secondary_start:
@@ -1378,6 +1457,15 @@ __secondary_start:
 	.globl __secondary_hold_acknowledge
 __secondary_hold_acknowledge:
 	.long	-1
+
+#ifdef CONFIG_MPC8572DS_UBOOT_COMPAT
+	/* Fill in the empty space.  The actual reset vector is
+	 * the last word of the page */
+__secondary_start_code_end:
+	.space 4092 - (__secondary_start_code_end - __secondary_start_page)
+__secondary_reset_vector:
+	b	__secondary_start_page
+#endif
 #endif
 
 /*
diff --git a/arch/powerpc/platforms/85xx/Kconfig b/arch/powerpc/platforms/85xx/Kconfig
index 291675b..68bef27 100644
--- a/arch/powerpc/platforms/85xx/Kconfig
+++ b/arch/powerpc/platforms/85xx/Kconfig
@@ -120,3 +120,11 @@ endif # MPC85xx
 
 config TQM85xx
 	bool
+
+config MPC8572DS_UBOOT_COMPAT
+	bool "Compatible with old u-boot"
+	depends on MPC85xx_DS && SMP
+	default n
+	help
+	  Old u-boot does not support multiprocessor, so we have to release
+	  the secondary cpu in kernel code.
diff --git a/arch/powerpc/platforms/85xx/smp.c b/arch/powerpc/platforms/85xx/smp.c
index c91576a..246fdc5 100644
--- a/arch/powerpc/platforms/85xx/smp.c
+++ b/arch/powerpc/platforms/85xx/smp.c
@@ -26,6 +26,33 @@
 extern volatile unsigned long __secondary_hold_acknowledge;
 extern void __early_start(void);
 
+#ifdef CONFIG_MPC8572DS_UBOOT_COMPAT
+extern void __secondary_start_page(void);
+#define EEBPCR_CPU1_EN	0x02000000
+#define EEBPCR_CPU0_EN	0x01000000
+#define MPC85xx_ECM_OFFSET 0x1000
+#define MPC85xx_ECM_SIZE 0xf00
+#define ECM_PORT_CONFIG_OFFSET 0x0010
+#define MPC85xx_BPTR_OFFSET 0x20
+#define BPTR_EN	0x80000000
+
+static void __init
+smp_85xx_release_core(int nr)
+{
+	__iomem u32 *ecm_vaddr;
+	unsigned long pcr;
+
+	/*
+	 * Startup Core #nr.
+	 */
+	ecm_vaddr = ioremap(get_immrbase() + MPC85xx_ECM_OFFSET,
+			    MPC85xx_ECM_SIZE);
+	pcr = in_be32(ecm_vaddr + (ECM_PORT_CONFIG_OFFSET >> 2));
+	pcr |= EEBPCR_CPU1_EN;
+	out_be32(ecm_vaddr + (ECM_PORT_CONFIG_OFFSET >> 2), pcr);
+}
+#endif
+
 #define BOOT_ENTRY_ADDR_UPPER	0
 #define BOOT_ENTRY_ADDR_LOWER	1
 #define BOOT_ENTRY_R3_UPPER	2
@@ -41,9 +68,13 @@ static void __init
 smp_85xx_kick_cpu(int nr)
 {
 	unsigned long flags;
-	const u64 *cpu_rel_addr;
 	__iomem u32 *bptr_vaddr;
+#ifdef CONFIG_MPC8572DS_UBOOT_COMPAT
+	u32 bptr, oldbptr;
+#else
+	const u64 *cpu_rel_addr;
 	struct device_node *np;
+#endif
 	int n = 0;
 
 	WARN_ON (nr < 0 || nr >= NR_CPUS);
@@ -52,6 +83,16 @@ smp_85xx_kick_cpu(int nr)
 
 	local_irq_save(flags);
 
+#ifdef CONFIG_MPC8572DS_UBOOT_COMPAT
+	/* Get the BPTR */
+	bptr_vaddr = ioremap(get_immrbase() + MPC85xx_BPTR_OFFSET, 4);
+	/* Set the BPTR to the secondary boot page */
+	oldbptr = in_be32(bptr_vaddr);
+	bptr = (BPTR_EN | (__pa((unsigned)__secondary_start_page) >> 12));
+	out_be32(bptr_vaddr, bptr);
+	/* Kick that CPU */
+	smp_85xx_release_core(nr);
+#else
 	np = of_get_cpu_node(nr, NULL);
 	cpu_rel_addr = of_get_property(np, "cpu-release-addr", NULL);
 
@@ -65,6 +106,7 @@ smp_85xx_kick_cpu(int nr)
 
 	out_be32(bptr_vaddr + BOOT_ENTRY_PIR, nr);
 	out_be32(bptr_vaddr + BOOT_ENTRY_ADDR_LOWER, __pa(__early_start));
+#endif
 
 	/* Wait a bit for the CPU to ack. */
 	while ((__secondary_hold_acknowledge != nr) && (++n < 1000))
@@ -94,6 +136,8 @@ struct smp_ops_t smp_85xx_ops = {
 	.probe = smp_mpic_probe,
 	.kick_cpu = smp_85xx_kick_cpu,
 	.setup_cpu = smp_85xx_setup_cpu,
+	.take_timebase = smp_generic_take_timebase,
+	.give_timebase = smp_generic_give_timebase,
 };
 
 void __init
-- 
1.6.0.2.GIT

