From 2b52350f52b13fc2e499ae2406c4e5493882c9ba Mon Sep 17 00:00:00 2001
From: Benjamin Walsh <benjamin.walsh@windriver.com>
Date: Tue, 30 Mar 2010 18:27:42 -0400
Subject: [PATCH] PPC32/8572ds/kexec: add KEXEC_SMP_BOOTABLE option

The 8572ds code currently supports two ways of waking up a secondary
CPU. The older uboot is not aware of multiple CPUs and thus leaves
the CPU off and then the kernel starts it; the newer uboot knows
about them and wakes them up and spins them on a tight loop, leaving
the kernel to make them enter the kernel by writing a start address
in the spin loop variable. The kexec-bootable kernel takes an
approach that is similar to the latter, with one more step.

When the secondary CPU goes down in the original kernel, it first
spins in a tight loop in the control code page, which is randomly
allocated, until the copy of the new kernel is done. At that point,
the primary CPU jumps to the new kernel. It then has to bring the
secondary CPU into the second kernel as well since the control code
page has a high chance of being reused by the new kernel before the
primary CPU hits the secondary wakeup code. To achieve this, the
primary CPU writes the address of a new loop in the second kernel
at which the secondary jumps to. When the wakeup code is hit by the
primary, it finally instructs the secondary to run __early_start.

Signed-off-by: Benjamin Walsh <benjamin.walsh@windriver.com>
---
 arch/powerpc/platforms/85xx/smp.c |   18 ++++++++++++++++++
 1 files changed, 18 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/platforms/85xx/smp.c b/arch/powerpc/platforms/85xx/smp.c
index 33a0ff5..6a2749d 100644
--- a/arch/powerpc/platforms/85xx/smp.c
+++ b/arch/powerpc/platforms/85xx/smp.c
@@ -71,6 +71,20 @@ static void __init __smp_85xx_kick_cpu(int nr)
 	iounmap(bptr_vaddr);
 }
 
+#elif defined(CONFIG_KEXEC_POWERPC_SMP_BOOTABLE)
+
+extern u32 kexec_secondary_hold_addr;
+static void __init __smp_85xx_kick_cpu(int nr)
+{
+	/* a kexec-bootable kernel has its secondary CPU spinning on
+	 * kexec_secondary_hold_addr in the new kernel text/data at this
+	 * point: release it and make it start its true kernel execution,
+	 * at __early_start() */
+
+	kexec_secondary_hold_addr = (u32)__pa(__early_start);
+	mb();
+}
+
 #else  /* latest u-boot way of bringing CPU1 into the kernel */
 
 #define BOOT_ENTRY_ADDR_UPPER	0
@@ -160,6 +174,7 @@ smp_85xx_setup_cpu(int cpu_nr)
 	mtspr(SPRN_TCR, TCR_DIE);
 }
 
+extern void default_kexec_stop_cpus(void *arg);
 struct smp_ops_t smp_85xx_ops = {
 	.message_pass = smp_mpic_message_pass,
 	.probe = smp_mpic_probe,
@@ -167,6 +182,9 @@ struct smp_ops_t smp_85xx_ops = {
 	.setup_cpu = smp_85xx_setup_cpu,
 	.take_timebase = smp_generic_take_timebase,
 	.give_timebase = smp_generic_give_timebase,
+#ifdef CONFIG_KEXEC
+	.kexec_stop_cpus = default_kexec_stop_cpus,
+#endif
 };
 
 void __init
-- 
1.6.2

