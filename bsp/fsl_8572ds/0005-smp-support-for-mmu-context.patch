From a0573d9657be239d65610e27e631dcf9bbd0f710 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Thu, 18 Dec 2008 17:27:14 +0800
Subject: [PATCH] smp support for mmu context

Based on the patch committed by Benjamin Herrenschmidt. It adds
support for SMP by implementing a concept of stale context map
to lazily flush the TLB on processors where a context may have
been invalidated.

http://www.nabble.com/-PATCH-6-9--powerpc:-Rework-context-management-for-CPUs-with-no-hash-table-p20889864.html

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/include/asm/mmu-fsl-booke.h |    5 +
 arch/powerpc/include/asm/mmu_context.h   |   41 +++++++-
 arch/powerpc/kernel/ppc_ksyms.c          |    4 +
 arch/powerpc/kernel/swsusp.c             |    4 +
 arch/powerpc/mm/mmu_context_32.c         |  167 +++++++++++++++++++++++++++++-
 5 files changed, 219 insertions(+), 2 deletions(-)

diff --git a/arch/powerpc/include/asm/mmu-fsl-booke.h b/arch/powerpc/include/asm/mmu-fsl-booke.h
index 925d93c..6b7f5cb 100644
--- a/arch/powerpc/include/asm/mmu-fsl-booke.h
+++ b/arch/powerpc/include/asm/mmu-fsl-booke.h
@@ -74,7 +74,12 @@
 #ifndef __ASSEMBLY__
 
 typedef struct {
+#ifdef CONFIG_MPC85xx_DS
+	unsigned short	id;
+	unsigned short	active;
+#else
 	unsigned long id;
+#endif
 	unsigned long vdso_base;
 } mm_context_t;
 #endif /* !__ASSEMBLY__ */
diff --git a/arch/powerpc/include/asm/mmu_context.h b/arch/powerpc/include/asm/mmu_context.h
index 6b993ef..249ae7f 100644
--- a/arch/powerpc/include/asm/mmu_context.h
+++ b/arch/powerpc/include/asm/mmu_context.h
@@ -110,11 +110,19 @@ extern unsigned long next_mmu_context;
  */
 #if LAST_CONTEXT < 30000
 #define FEW_CONTEXTS	1
-extern atomic_t nr_free_contexts;
 extern struct mm_struct *context_mm[LAST_CONTEXT+1];
+#ifdef CONFIG_MPC85xx_DS
+extern unsigned int nr_free_contexts;
+#else
+extern atomic_t nr_free_contexts;
 extern void steal_context(void);
 #endif
+#endif
 
+#ifdef CONFIG_MPC85xx_DS
+extern spinlock_t context_lock;
+void switch_mmu_context(struct mm_struct *, struct mm_struct *);
+#else
 /*
  * Get a new mmu context for the address space described by `mm'.
  */
@@ -140,6 +148,7 @@ static inline void get_mmu_context(struct mm_struct *mm)
 	context_mm[ctx] = mm;
 #endif
 }
+#endif	/* CONFIG_MPC85xx_DS */
 
 /*
  * Set up the context for a new address space.
@@ -147,12 +156,33 @@ static inline void get_mmu_context(struct mm_struct *mm)
 static inline int init_new_context(struct task_struct *t, struct mm_struct *mm)
 {
 	mm->context.id = NO_CONTEXT;
+#ifdef CONFIG_MPC85xx_DS
+	mm->context.active = 0;
+#endif
 	return 0;
 }
 
 /*
  * We're finished using the context for an address space.
  */
+#ifdef CONFIG_MPC85xx_DS
+static inline void destroy_context(struct mm_struct *mm)
+{
+	unsigned int id;
+
+	if (mm->context.id == NO_CONTEXT)
+		return;
+
+	spin_lock(&context_lock);
+	id = mm->context.id;
+	if (id != NO_CONTEXT) {
+		__clear_bit(id, context_map);
+		mm->context.id = NO_CONTEXT;
+		nr_free_contexts++;
+	}
+	spin_unlock(&context_lock);
+}
+#else
 static inline void destroy_context(struct mm_struct *mm)
 {
 	preempt_disable();
@@ -165,10 +195,15 @@ static inline void destroy_context(struct mm_struct *mm)
 	}
 	preempt_enable();
 }
+#endif /* CONFIG_MPC85xx_DS */
 
 static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,
 			     struct task_struct *tsk)
 {
+#ifdef CONFIG_MPC85xx_DS
+	if (!cpu_isset(smp_processor_id(), next->cpu_vm_mask))
+		cpu_set(smp_processor_id(), next->cpu_vm_mask);
+#endif
 #ifdef CONFIG_ALTIVEC
 	if (cpu_has_feature(CPU_FTR_ALTIVEC))
 	asm volatile ("dssall;\n"
@@ -185,8 +220,12 @@ static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,
 		return;
 
 	/* Setup new userspace context */
+#ifdef CONFIG_MPC85xx_DS
+	switch_mmu_context(prev, next);
+#else
 	get_mmu_context(next);
 	set_context(next->context.id, next->pgd);
+#endif
 }
 
 #define deactivate_mm(tsk,mm)	do { } while (0)
diff --git a/arch/powerpc/kernel/ppc_ksyms.c b/arch/powerpc/kernel/ppc_ksyms.c
index 33272d8..f9f5a9a 100644
--- a/arch/powerpc/kernel/ppc_ksyms.c
+++ b/arch/powerpc/kernel/ppc_ksyms.c
@@ -170,9 +170,13 @@ EXPORT_SYMBOL(cacheable_memcpy);
 #endif
 
 #ifdef CONFIG_PPC32
+#ifdef CONFIG_MPC85xx_DS
+EXPORT_SYMBOL(switch_mmu_context);
+#else
 EXPORT_SYMBOL(next_mmu_context);
 EXPORT_SYMBOL(set_context);
 #endif
+#endif
 
 #ifdef CONFIG_PPC_STD_MMU_32
 extern long mol_trampoline;
diff --git a/arch/powerpc/kernel/swsusp.c b/arch/powerpc/kernel/swsusp.c
index 77b7b34..a277040 100644
--- a/arch/powerpc/kernel/swsusp.c
+++ b/arch/powerpc/kernel/swsusp.c
@@ -34,6 +34,10 @@ void save_processor_state(void)
 void restore_processor_state(void)
 {
 #ifdef CONFIG_PPC32
+#ifdef CONFIG_MPC85xx_DS
+	switch_mmu_context(NULL, current->active_mm);
+#else
 	set_context(current->active_mm->context.id, current->active_mm->pgd);
 #endif
+#endif
 }
diff --git a/arch/powerpc/mm/mmu_context_32.c b/arch/powerpc/mm/mmu_context_32.c
index cc32ba4..349cecf 100644
--- a/arch/powerpc/mm/mmu_context_32.c
+++ b/arch/powerpc/mm/mmu_context_32.c
@@ -31,9 +31,15 @@
 unsigned long next_mmu_context;
 unsigned long context_map[LAST_CONTEXT / BITS_PER_LONG + 1];
 #ifdef FEW_CONTEXTS
-atomic_t nr_free_contexts;
 struct mm_struct *context_mm[LAST_CONTEXT+1];
+#ifdef CONFIG_MPC85xx_DS
+DEFINE_SPINLOCK(context_lock);
+unsigned int nr_free_contexts;
+static unsigned long stale_map[NR_CPUS][LAST_CONTEXT / BITS_PER_LONG + 1];
+#else
+atomic_t nr_free_contexts;
 void steal_context(void);
+#endif
 #endif /* FEW_CONTEXTS */
 
 /*
@@ -51,7 +57,16 @@ mmu_context_init(void)
 	context_map[0] = (1 << FIRST_CONTEXT) - 1;
 	next_mmu_context = FIRST_CONTEXT;
 #ifdef FEW_CONTEXTS
+#ifdef CONFIG_MPC85xx_DS
+	/* Mark init_mm as being active on all possible CPUs since
+	 * we'll get called with prev == init_mm the first time
+	 * we schedule on a given CPU
+	 */
+	init_mm.context.active = NR_CPUS;
+	nr_free_contexts = LAST_CONTEXT - FIRST_CONTEXT + 1;
+#else
 	atomic_set(&nr_free_contexts, LAST_CONTEXT - FIRST_CONTEXT + 1);
+#endif
 #endif /* FEW_CONTEXTS */
 }
 
@@ -68,6 +83,155 @@ mmu_context_init(void)
  * place to implement an LRU scheme if anyone was motivated to do it.
  *  -- paulus
  */
+#ifdef CONFIG_MPC85xx_DS
+#include <asm/udbg.h>
+
+/*
+ * For context stealing, we use a slightly different approach for
+ * SMP and UP. Basically, the UP one is simpler and doesn't use
+ * the stale map as we can just flush the local CPU
+ */
+#ifdef CONFIG_SMP
+static unsigned int steal_context_smp(unsigned int id)
+{
+	struct mm_struct *mm;
+	unsigned int cpu, max;
+
+ again:
+	max = LAST_CONTEXT - FIRST_CONTEXT;
+
+	while (max--) {
+		/* Pick up the victim mm */
+		mm = context_mm[id];
+
+		/* We have a candidate victim, check if it's active, on SMP
+		 * we cannot steal active contexts
+		 */
+		if (mm->context.active) {
+			id++;
+			if (id > LAST_CONTEXT)
+				id = FIRST_CONTEXT;
+			continue;
+		}
+		pr_debug("[%d] steal context %d from mm @%p\n",
+			 smp_processor_id(), id, mm);
+
+		/* Mark this mm has having no context anymore */
+		mm->context.id = NO_CONTEXT;
+
+		/* Mark it stale on all CPUs that used this mm */
+		for_each_cpu_mask_nr(cpu, mm->cpu_vm_mask)
+			__set_bit(id, stale_map[cpu]);
+		return id;
+	}
+
+	/* This will happen if you have more CPUs than available contexts,
+	 * all we can do here is wait a bit and try again
+	 */
+	spin_unlock(&context_lock);
+	cpu_relax();
+	spin_lock(&context_lock);
+	goto again;
+}
+#endif  /* CONFIG_SMP */
+
+/* Note that this will also be called on SMP if all other CPUs are
+ * offlined, which means that it may be called for cpu != 0. For
+ * this to work, we somewhat assume that CPUs that are onlined
+ * come up with a fully clean TLB (or are cleaned when offlined)
+  */
+static unsigned int steal_context_up(unsigned int id)
+{
+	struct mm_struct *mm;
+	int cpu = smp_processor_id();
+
+	/* Pick up the victim mm */
+	mm = context_mm[id];
+
+	pr_debug("[%d] steal context %d from mm @%p\n", cpu, id, mm);
+
+	/* Mark this mm has having no context anymore */
+	mm->context.id = NO_CONTEXT;
+
+	/* Flush the TLB for that context */
+	flush_tlb_mm(mm);
+
+	/* XXX This clear should ultimately be part of local_flush_tlb_mm */
+	__clear_bit(id, stale_map[cpu]);
+
+	return id;
+}
+
+void switch_mmu_context(struct mm_struct *prev,
+				struct mm_struct *next)
+{
+	unsigned int id, cpu = smp_processor_id();
+	unsigned long *map;
+
+	/* No lockless fast path .. yet */
+	spin_lock(&context_lock);
+
+#ifdef CONFIG_SMP
+	/* Mark us active and the previous one not anymore */
+	next->context.active++;
+	if (prev)
+		prev->context.active--;
+#endif /* CONFIG_SMP */
+
+	/* If we already have a valid assigned context, skip all that */
+	id = next->context.id;
+	if (likely(id != NO_CONTEXT))
+		goto ctxt_ok;
+
+	/* We really don't have a context, let's try to acquire one */
+	id = next_mmu_context;
+	if (id > LAST_CONTEXT)
+		id = FIRST_CONTEXT;
+	map = context_map;
+
+	/* No more free contexts, let's try to steal one */
+	if (nr_free_contexts == 0) {
+#ifdef CONFIG_SMP
+		if (num_online_cpus() > 1) {
+			id = steal_context_smp(id);
+			goto stolen;
+		}
+#endif /* CONFIG_SMP */
+		id = steal_context_up(id);
+		goto stolen;
+	}
+	nr_free_contexts--;
+
+	/* We know there's at least one free context, try to find it */
+	while (__test_and_set_bit(id, map)) {
+		id = find_next_zero_bit(map, LAST_CONTEXT+1, id);
+		if (id > LAST_CONTEXT)
+			id = FIRST_CONTEXT;
+	}
+ stolen:
+	next_mmu_context = id + 1;
+	context_mm[id] = next;
+	next->context.id = id;
+
+ ctxt_ok:
+
+	/* If that context got marked stale on this CPU, then flush the
+	 * local TLB for it and unmark it before we use it
+	 */
+	if (test_bit(id, stale_map[cpu])) {
+		pr_debug("[%d] flushing stale context %d for mm @%p !\n",
+			 cpu, id, next);
+		flush_tlb_mm(next);
+
+		/* XXX This clear should ultimately be part of flush_tlb_mm */
+		__clear_bit(id, stale_map[cpu]);
+	}
+
+	/* Flick the MMU and release lock */
+	set_context(id, next->pgd);
+	spin_unlock(&context_lock);
+}
+#else
 void
 steal_context(void)
 {
@@ -81,4 +245,5 @@ steal_context(void)
 	flush_tlb_mm(mm);
 	destroy_context(mm);
 }
+#endif  /* CONFIG_MPC85xx_DS */
 #endif /* FEW_CONTEXTS */
-- 
1.6.0.3

