From 706f1168b3f41306e230329a4f15d5b11013244c Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Tue, 1 Mar 2011 10:39:42 +0800
Subject: [PATCH 2/4] Fixed 8360 gadget panic issue

When we plug the usb cable kernel output:

Oops: Kernel access of bad area, sig: 11 [#1]
NIP: c02a0d04LR: c02a0cd8 CTR: c029976c
REGS: c051bcc0 TRAP: 0300   Not tainted  (2.6.34.6-WR4.0.0.0_standard)
MSR: 00001032 <ME,IR,DR>  CR: 22008042  XER: 20000000
DAR: 00000000, DSISR: 20000000
TASK = c04ee450[0] 'swapper' THREAD: c051a000
GPR00: 00000003 c051bd70 c04ee450 0000003f 000022f5 ffffffff c0260f98 0000000
GPR08: 00000000 cf9679c0 00000000 c051a000 22008044 9a6c7e8a 00000001 2000000
GPR16: 40000000 00800000 00400000 cf98c0f0 0c000000 cf98c0d8 00000000 0000000
GPR24: c050d560 00000000 cf98c000 00000000 c050d560 cf98c000 cf9785c0 cf97860
NIP [c02a0d04] composite_setup+0xa68/0xb58
LR [c02a0cd8] composite_setup+0xa3c/0xb58
Call Trace:
[c051bd70] [c02a0cd8] composite_setup+0xa3c/0xb58 (unreliable)
[c051bdb0] [c029d23c] qe_udc_irq+0xbbc/0xe10
[c051be20] [c0092e48] handle_IRQ_event+0xb8/0x30c
[c051be70] [c0095f7c] handle_level_irq+0xb8/0x184
[c051be90] [c0030138] qe_ic_cascade_low_ipic+0x3c/0x50
[c051bea0] [c00064e4] native_do_IRQ+0x98/0xb4
[c051bec0] [c0005164] do_IRQ+0x10/0x20
[c051bed0] [c0015bb4] ret_from_except+0x0/0x14

This is caused by gadget driver not in correct mode.

The usb of 8360 is only support fullspeed and lowspeed mode. But fsl_qe_udc set the
mode to high speed by default. And this make the driver access the incorrect pointer
f->hs_descriptors which is NULL. The correct pointer is f->descriptors.

Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 drivers/usb/gadget/fsl_qe_udc.c |    4 ++++
 1 files changed, 4 insertions(+), 0 deletions(-)

diff --git a/drivers/usb/gadget/fsl_qe_udc.c b/drivers/usb/gadget/fsl_qe_udc.c
index 3537d51..fb5a051 100644
--- a/drivers/usb/gadget/fsl_qe_udc.c
+++ b/drivers/usb/gadget/fsl_qe_udc.c
@@ -2328,7 +2328,11 @@ int usb_gadget_register_driver(struct usb_gadget_driver *driver)
 	/* hook up the driver */
 	udc_controller->driver = driver;
 	udc_controller->gadget.dev.driver = &driver->driver;
+#ifdef CONFIG_MPC836x_MDS
+	udc_controller->gadget.speed = USB_SPEED_FULL;
+#else
 	udc_controller->gadget.speed = (enum usb_device_speed)(driver->speed);
+#endif
 	spin_unlock_irqrestore(&udc_controller->lock, flags);
 
 	retval = driver->bind(&udc_controller->gadget);
-- 
1.7.0.4

