From d83420a2fe384ec031e8f96848345ddb24a45464 Mon Sep 17 00:00:00 2001
From: Jack Tan <jack.tan@windriver.com>
Date: Wed, 26 Jan 2011 16:20:09 +0800
Subject: [PATCH 1/4] SPI flash (M25PXX) support for fsl_mpc8360e

Add platform specific code to properly initialize
SPI bus and SPI (M25PXX) flash.

According to the board pkgs from the Freescale m25p40 is used on
MPC836x_MDS, not m25p80.

Signed-off-by: Andrei Dolnikov <adolnikov@embeddedalley.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
Signed-off-by: Jack Tan <jack.tan@windriver.com>
---
 arch/powerpc/boot/dts/mpc836x_mds.dts     |    4 +-
 arch/powerpc/platforms/83xx/mpc836x_mds.c |  163 +++++++++++++++++++++++++++++
 drivers/mtd/devices/m25p80.c              |    5 +
 3 files changed, 170 insertions(+), 2 deletions(-)

diff --git a/arch/powerpc/boot/dts/mpc836x_mds.dts b/arch/powerpc/boot/dts/mpc836x_mds.dts
index 5145659..5a298ff 100644
--- a/arch/powerpc/boot/dts/mpc836x_mds.dts
+++ b/arch/powerpc/boot/dts/mpc836x_mds.dts
@@ -370,7 +370,7 @@
 			reg = <0x4c0 0x40>;
 			interrupts = <2>;
 			interrupt-parent = <&qeic>;
-			mode = "cpu";
+			mode = "cpu-qe";
 		};
 
 		spi@500 {
@@ -379,7 +379,7 @@
 			reg = <0x500 0x40>;
 			interrupts = <1>;
 			interrupt-parent = <&qeic>;
-			mode = "cpu";
+			mode = "cpu-qe";
 		};
 
 		usb@6c0 {
diff --git a/arch/powerpc/platforms/83xx/mpc836x_mds.c b/arch/powerpc/platforms/83xx/mpc836x_mds.c
index 09e9d6f..78e532a 100644
--- a/arch/powerpc/platforms/83xx/mpc836x_mds.c
+++ b/arch/powerpc/platforms/83xx/mpc836x_mds.c
@@ -32,6 +32,10 @@
 #include <linux/initrd.h>
 #include <linux/of_platform.h>
 #include <linux/of_device.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/mtd/partitions.h>
+#include <linux/fsl_devices.h>
 
 #include <asm/system.h>
 #include <asm/atomic.h>
@@ -57,6 +61,165 @@
 #define DBG(fmt...)
 #endif
 
+#ifdef CONFIG_SPI
+static struct mtd_partition mpc836x_spi_flash_partitions[] = {
+	{
+		.name = "SPI Flash",
+		.size = MTDPART_SIZ_FULL,
+		.offset = 0,
+	},
+};
+
+static struct flash_platform_data mpc836x_spi_flash_data = {
+	.name = "m25p80",
+	.parts = mpc836x_spi_flash_partitions,
+	.nr_parts = ARRAY_SIZE(mpc836x_spi_flash_partitions),
+	.type = "m25p40",
+};
+
+static void mpc836x_spi_cs_control(struct spi_device *spi, bool on)
+{
+	pr_debug("%s %d %d\n", __func__, spi->chip_select, on);
+	par_io_data_set(4, 31, on);
+}
+
+static struct spi_board_info mpc836x_spi_boardinfo[] = {
+	{
+		.bus_num = 0x4c0,
+		.chip_select = 0,
+		.max_speed_hz = 250000,
+		.modalias = "mpc83xx_spi",
+	},
+	{
+		.modalias = "m25p80",
+		.max_speed_hz = 250000,
+		.bus_num = 0x4c0,
+		.chip_select = 1,
+		.platform_data = &mpc836x_spi_flash_data,
+	},
+};
+
+static int __init of_fsl_spi_probe(char *type, char *compatible, u32 sysclk,
+				   struct spi_board_info *board_infos,
+				   unsigned int num_board_infos,
+				   void (*cs_control)(struct spi_device *dev,
+						      bool on))
+{
+	struct device_node *np;
+	unsigned int i = 0;
+
+	for_each_compatible_node(np, type, compatible) {
+		int ret;
+		unsigned int j;
+		const void *prop;
+		struct resource res[2];
+		struct platform_device *pdev;
+		struct fsl_spi_platform_data pdata = {
+			.cs_control = cs_control,
+		};
+
+		memset(res, 0, sizeof(res));
+
+		pdata.sysclk = sysclk;
+
+		prop = of_get_property(np, "reg", NULL);
+		if (!prop)
+			goto err;
+		pdata.bus_num = *(u32 *)prop;
+
+		prop = of_get_property(np, "cell-index", NULL);
+		if (prop)
+			i = *(u32 *)prop;
+
+		prop = of_get_property(np, "mode", NULL);
+		if (prop && !strcmp(prop, "cpu-qe"))
+			pdata.flags = SPI_QE_CPU_MODE;
+
+		for (j = 0; j < num_board_infos; j++) {
+			if (board_infos[j].bus_num == pdata.bus_num)
+				pdata.max_chipselect++;
+		}
+
+		if (!pdata.max_chipselect)
+			continue;
+
+		ret = of_address_to_resource(np, 0, &res[0]);
+		if (ret)
+			goto err;
+
+		ret = of_irq_to_resource(np, 0, &res[1]);
+		if (ret == NO_IRQ)
+			goto err;
+
+		pdev = platform_device_alloc("mpc83xx_spi", i);
+		if (!pdev)
+			goto err;
+
+		ret = platform_device_add_data(pdev, &pdata, sizeof(pdata));
+		if (ret)
+			goto unreg;
+
+		ret = platform_device_add_resources(pdev, res,
+						    ARRAY_SIZE(res));
+		if (ret)
+			goto unreg;
+
+		ret = platform_device_add(pdev);
+		if (ret)
+			goto unreg;
+
+		goto next;
+unreg:
+		platform_device_del(pdev);
+err:
+		pr_err("%s: registration failed\n", np->full_name);
+next:
+		i++;
+	}
+
+	return i;
+}
+
+static int __init fsl_spi_init(struct spi_board_info *board_infos,
+			       unsigned int num_board_infos,
+			       void (*cs_control)(struct spi_device *spi,
+						  bool on))
+{
+	u32 sysclk = -1;
+	int ret;
+
+	/* SPI controller is either clocked from QE or SoC clock */
+	sysclk = get_brgfreq();
+	if (sysclk == -1) {
+		sysclk = fsl_get_sys_freq();
+		if (sysclk == -1)
+			return -ENODEV;
+	}
+
+	ret = of_fsl_spi_probe(NULL, "fsl,spi", sysclk, board_infos,
+			       num_board_infos, cs_control);
+	if (!ret)
+		of_fsl_spi_probe("spi", "fsl_spi", sysclk, board_infos,
+				 num_board_infos, cs_control);
+
+	return spi_register_board_info(board_infos, num_board_infos);
+}
+
+static int __init mpc836x_spi_init(void)
+{
+	par_io_config_pin(4, 28, 3, 0, 3, 0); /* SPI1MOSI */
+	par_io_config_pin(4, 29, 3, 0, 3, 0); /* SPI1MISO */
+	par_io_config_pin(4, 30, 3, 0, 3, 0); /* SPI1CLK */
+	par_io_config_pin(4, 31, 1, 0, 0, 0); /* !SD_CS, O */
+
+	return fsl_spi_init(mpc836x_spi_boardinfo,
+			    ARRAY_SIZE(mpc836x_spi_boardinfo),
+			    mpc836x_spi_cs_control);
+}
+
+machine_device_initcall(mpc836x_mds, mpc836x_spi_init);
+#endif /* CONFIG_SPI */
+
 /* ************************************************************************
  *
  * Setup the architecture
diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index 81e49a9..a9d18b4 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -673,7 +673,12 @@ static const struct spi_device_id m25p_ids[] = {
 	{ "m25p05",  INFO(0x202010,  0,  32 * 1024,   2, 0) },
 	{ "m25p10",  INFO(0x202011,  0,  32 * 1024,   4, 0) },
 	{ "m25p20",  INFO(0x202012,  0,  64 * 1024,   4, 0) },
+#ifdef CONFIG_MPC836x_MDS
+	/* Use m25p40 as the default on MPC836x_MDS by setting jedec_id to 0 */
+	{ "m25p40",  INFO(0,  0,  64 * 1024,   8, 0) },
+#else
 	{ "m25p40",  INFO(0x202013,  0,  64 * 1024,   8, 0) },
+#endif
 	{ "m25p80",  INFO(0x202014,  0,  64 * 1024,  16, 0) },
 	{ "m25p16",  INFO(0x202015,  0,  64 * 1024,  32, 0) },
 	{ "m25p32",  INFO(0x202016,  0,  64 * 1024,  64, 0) },
-- 
1.7.0.4

