From c9bc73e9b7e62e3d23f3406a837a54b09f6a4295 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Mon, 1 Jul 2013 09:39:48 +0800
Subject: [PATCH 3/4] MTD: m25p80: Add support for N25Q00 QSPI chip

Original commit ID ae508134 comes from:

git://git.rocketboards.org/linux-socfpga.git

Add read-delay device tree parameter.
Add flag status read/write.
Add check of flag status register on all erase/write commands.
Add volatile configuration register setup for 8 dummy clocks.

Signed-off-by: graham <grmoore@altera.com>
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/boot/dts/socfpga_cyclone5.dts |   15 ++--
 drivers/mtd/devices/m25p80.c           |  152 +++++++++++++++++++++++++++++---
 2 files changed, 147 insertions(+), 20 deletions(-)

diff --git a/arch/arm/boot/dts/socfpga_cyclone5.dts b/arch/arm/boot/dts/socfpga_cyclone5.dts
index b90670f..b4f5af5 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5.dts
@@ -109,13 +109,14 @@
 					compatible = "n25q00";
 					reg = <0>;	/* chip select */
 					spi-max-frequency = <100000000>;
+					m25p,fast-read;
 					page-size = <256>;
 					block-size = <16>; /* 2^16, 64KB */
-					quad = <1>;	   /* 1-support quad */
-					tshsl-ns = <200>;
-					tsd2d-ns = <255>;
-					tchsh-ns = <20>;
-					tslch-ns = <20>;
+					read-delay = <4>;  /* delay value in read data capture register */
+					tshsl-ns = <50>;
+					tsd2d-ns = <50>;
+					tchsh-ns = <4>;
+					tslch-ns = <4>;
 
 					partition@0 {
 						/* 8MB for raw data. */
@@ -123,9 +124,9 @@
 						reg = <0x0 0x800000>;
 					};
 					partition@800000 {
-						/* 8MB for jffs2 data. */
+						/* 120MB for jffs2 data. */
 						label = "Flash 0 jffs2 Filesystem";
-						reg = <0x800000 0x800000>;
+						reg = <0x800000 0x7800000>;
 					};
 				};
 
diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index 353f6a4..cdb13bd 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -35,13 +35,16 @@
 #include <linux/spi/spi.h>
 #include <linux/spi/flash.h>
 
+#define N25Q00_JEDEC_ID (0x20ba21)
+
 /* Flash opcodes. */
 #define	OPCODE_WREN		0x06	/* Write enable */
 #define	OPCODE_RDSR		0x05	/* Read status register */
 #define	OPCODE_WRSR		0x01	/* Write status register 1 byte */
+#define	OPCODE_RFSR		0x70	/* read flag status register */
 #define	OPCODE_NORM_READ	0x03	/* Read data bytes (low frequency) */
 #define	OPCODE_FAST_READ	0x0b	/* Read data bytes (high frequency) */
-#define  OPCODE_FAST_READ_QUAD_OUTPUT   0x6b    /* Read data bytes (quad) */
+#define	OPCODE_FAST_READ_QUAD_OUTPUT	0x6b	/* Read data bytes (quad) */
 #define	OPCODE_PP		0x02	/* Page program (up to 256 bytes) */
 #define	OPCODE_BE_4K		0x20	/* Erase 4KiB block */
 #define	OPCODE_BE_32K		0x52	/* Erase 32KiB block */
@@ -79,6 +82,16 @@
 #define	SR_BP2			0x10	/* Block protect 2 */
 #define	SR_SRWD			0x80	/* SR write protect */
 
+/* Flag Status Register bits */
+#define	FSR_READY         (1 << 7)
+#define	FSR_ERASE_SUSPEND (1 << 6)
+#define	FSR_ERASE_ERROR   (1 << 5)
+#define	FSR_PGM_ERROR     (1 << 4)
+#define	FSR_VPP_INVALID   (1 << 3)
+#define	FSR_PGM_SUSPEND   (1 << 2)
+#define	FSR_PROTECT_ERROR (1 << 1)
+#define	FSR_4BYTE_ADDR    (1 << 0)
+
 /* Define max times to check status register before we give up. */
 #define	MAX_READY_WAIT_JIFFIES	(40 * HZ)	/* M25P16 specs 40s max chip erase */
 #define	MAX_CMD_SIZE		5
@@ -107,6 +120,7 @@ struct m25p {
 	u8			erase_opcode;
 	u8			*command;
 	bool			fast_read;
+	int (*wait_till_ready)(struct m25p *flash);
 };
 
 static inline struct m25p *mtd_to_m25p(struct mtd_info *mtd)
@@ -143,6 +157,61 @@ static int read_sr(struct m25p *flash)
 }
 
 /*
+* Read the flagstatus register, returning its value in the location
+* Return the status register value.
+* Returns negative if error occurred.
+*/
+static int read_fsr(struct m25p *flash)
+{
+	ssize_t retval;
+	u8 code = OPCODE_RFSR;
+	u8 val;
+
+	retval = spi_write_then_read(flash->spi, &code, 1, &val, 1);
+
+	if (retval < 0) {
+		dev_err(&flash->spi->dev, "error %d reading SR\n",
+				(int) retval);
+		return retval;
+	}
+
+	return val;
+}
+
+/*
+ * Write volatile config register
+ * Returns negative if error occurred.
+ */
+static int write_vcr(struct m25p *flash, u8 val)
+{
+	flash->command[0] = OPCODE_WVCR;
+	flash->command[1] = val;
+
+	return spi_write(flash->spi, flash->command, 2);
+}
+
+/*
+ * Read volatile config register
+ * Returns negative if error occurred.
+ */
+static int read_vcr(struct m25p *flash)
+{
+	ssize_t retval;
+	u8 code = OPCODE_RVCR;
+	u8 val;
+
+	retval = spi_write_then_read(flash->spi, &code, 1, &val, 1);
+
+	if (retval < 0) {
+		dev_err(&flash->spi->dev, "error %d reading VCR\n",
+				(int) retval);
+		return retval;
+	}
+
+	return val;
+}
+
+/*
  * Write status register 1 byte
  * Returns negative if error occurred.
  */
@@ -183,8 +252,10 @@ static inline int set_4byte(struct m25p *flash, u32 jedec_id, int enable)
 	switch (JEDEC_MFR(jedec_id)) {
 	case CFI_MFR_MACRONIX:
 	case 0xEF /* winbond */:
+	case CFI_MFR_ST:
 		flash->command[0] = enable ? OPCODE_EN4B : OPCODE_EX4B;
 		return spi_write(flash->spi, flash->command, 1);
+
 	default:
 		/* Spansion style */
 		flash->command[0] = OPCODE_BRWR;
@@ -197,7 +268,7 @@ static inline int set_4byte(struct m25p *flash, u32 jedec_id, int enable)
  * Service routine to read status register until ready, or timeout occurs.
  * Returns non-zero if error.
  */
-static int wait_till_ready(struct m25p *flash)
+static int _wait_till_ready(struct m25p *flash)
 {
 	unsigned long deadline;
 	int sr;
@@ -218,6 +289,38 @@ static int wait_till_ready(struct m25p *flash)
 }
 
 /*
+ * Service routine to read flag status register until ready, or timeout occurs.
+ * Returns non-zero if error.
+ */
+static int _wait_till_fsr_ready(struct m25p *flash)
+{
+	unsigned long deadline;
+	int fsr;
+	int sr;
+
+	deadline = jiffies + MAX_READY_WAIT_JIFFIES;
+
+	do {
+		sr = read_sr(flash);
+		if (sr < 0)
+			break;
+		/* only check fsr if sr not busy */
+		if (!(sr & SR_WIP)) {
+			fsr = read_fsr(flash);
+			if (fsr < 0)
+				break;
+			if (fsr & FSR_READY)
+				return 0;
+		}
+
+		cond_resched();
+
+	} while (!time_after_eq(jiffies, deadline));
+
+	return 1;
+}
+
+/*
  * Erase the whole flash memory
  *
  * Returns 0 if successful, non-zero otherwise.
@@ -228,7 +331,7 @@ static int erase_chip(struct m25p *flash)
 			(long long)(flash->mtd.size >> 10));
 
 	/* Wait until finished previous write command. */
-	if (wait_till_ready(flash))
+	if (flash->wait_till_ready(flash))
 		return 1;
 
 	/* Send write enable, then erase commands. */
@@ -239,6 +342,8 @@ static int erase_chip(struct m25p *flash)
 
 	spi_write(flash->spi, flash->command, 1);
 
+	flash->wait_till_ready(flash);
+
 	return 0;
 }
 
@@ -268,7 +373,7 @@ static int erase_sector(struct m25p *flash, u32 offset)
 			__func__, flash->mtd.erasesize / 1024, offset);
 
 	/* Wait until finished previous write command. */
-	if (wait_till_ready(flash))
+	if (flash->wait_till_ready(flash))
 		return 1;
 
 	/* Send write enable, then erase commands. */
@@ -280,6 +385,8 @@ static int erase_sector(struct m25p *flash, u32 offset)
 
 	spi_write(flash->spi, flash->command, m25p_cmdsz(flash));
 
+	flash->wait_till_ready(flash);
+
 	return 0;
 }
 
@@ -380,7 +487,7 @@ static int m25p80_read(struct mtd_info *mtd, loff_t from, size_t len,
 	mutex_lock(&flash->lock);
 
 	/* Wait till previous write/erase is done. */
-	if (wait_till_ready(flash)) {
+	if (flash->wait_till_ready(flash)) {
 		/* REVISIT status return?? */
 		mutex_unlock(&flash->lock);
 		return 1;
@@ -435,7 +542,7 @@ static int m25p80_write(struct mtd_info *mtd, loff_t to, size_t len,
 	mutex_lock(&flash->lock);
 
 	/* Wait until finished previous write command. */
-	if (wait_till_ready(flash)) {
+	if (flash->wait_till_ready(flash)) {
 		mutex_unlock(&flash->lock);
 		return 1;
 	}
@@ -478,7 +585,7 @@ static int m25p80_write(struct mtd_info *mtd, loff_t to, size_t len,
 			t[1].tx_buf = buf + i;
 			t[1].len = page_size;
 
-			wait_till_ready(flash);
+			flash->wait_till_ready(flash);
 
 			write_enable(flash);
 
@@ -488,6 +595,7 @@ static int m25p80_write(struct mtd_info *mtd, loff_t to, size_t len,
 		}
 	}
 
+	flash->wait_till_ready(flash);
 	mutex_unlock(&flash->lock);
 
 	return 0;
@@ -518,7 +626,7 @@ static int sst_write(struct mtd_info *mtd, loff_t to, size_t len,
 	mutex_lock(&flash->lock);
 
 	/* Wait until finished previous write command. */
-	ret = wait_till_ready(flash);
+	ret = flash->wait_till_ready(flash);
 	if (ret)
 		goto time_out;
 
@@ -533,7 +641,7 @@ static int sst_write(struct mtd_info *mtd, loff_t to, size_t len,
 		/* write one byte. */
 		t[1].len = 1;
 		spi_sync(flash->spi, &m);
-		ret = wait_till_ready(flash);
+		ret = flash->wait_till_ready(flash);
 		if (ret)
 			goto time_out;
 		*retlen += m.actual_length - m25p_cmdsz(flash);
@@ -552,7 +660,7 @@ static int sst_write(struct mtd_info *mtd, loff_t to, size_t len,
 		t[1].tx_buf = buf + actual;
 
 		spi_sync(flash->spi, &m);
-		ret = wait_till_ready(flash);
+		ret = flash->wait_till_ready(flash);
 		if (ret)
 			goto time_out;
 		*retlen += m.actual_length - cmd_sz;
@@ -560,7 +668,7 @@ static int sst_write(struct mtd_info *mtd, loff_t to, size_t len,
 		to += 2;
 	}
 	write_disable(flash);
-	ret = wait_till_ready(flash);
+	ret = flash->wait_till_ready(flash);
 	if (ret)
 		goto time_out;
 
@@ -574,7 +682,7 @@ static int sst_write(struct mtd_info *mtd, loff_t to, size_t len,
 		t[1].tx_buf = buf + actual;
 
 		spi_sync(flash->spi, &m);
-		ret = wait_till_ready(flash);
+		ret = flash->wait_till_ready(flash);
 		if (ret)
 			goto time_out;
 		*retlen += m.actual_length - m25p_cmdsz(flash);
@@ -649,6 +757,7 @@ struct flash_info {
 	u16		flags;
 #define	SECT_4K		0x01		/* OPCODE_BE_4K works uniformly */
 #define	M25P_NO_ERASE	0x02		/* No erase command needed */
+#define	USE_FSR   0x04    /* use flag status register */
 };
 
 #define INFO(_jedec_id, _ext_id, _sector_size, _n_sectors, _flags)	\
@@ -725,7 +834,7 @@ static const struct spi_device_id m25p_ids[] = {
 	{ "n25q128a11",  INFO(0x20bb18, 0, 64 * 1024, 256, 0) },
 	{ "n25q128a13",  INFO(0x20ba18, 0, 64 * 1024, 256, 0) },
 	{ "n25q256a", INFO(0x20ba19, 0, 64 * 1024, 512, SECT_4K) },
-	{ "n25q00",   INFO(0x20ba21, 0, 64 * 1024, 256, SECT_4K) },
+	{ "n25q00",   INFO(0x20ba21, 0, 64 * 1024, 2048, USE_FSR) },
 
 	/* Spansion -- single (large) sector size only, at least
 	 * for the chips listed here (without boot sectors).
@@ -990,6 +1099,11 @@ static int __devinit m25p_probe(struct spi_device *spi)
 	if (info->flags & M25P_NO_ERASE)
 		flash->mtd.flags |= MTD_NO_ERASE;
 
+	if (info->flags & USE_FSR)
+		flash->wait_till_ready = &_wait_till_fsr_ready;
+	else
+		flash->wait_till_ready = &_wait_till_ready;
+
 	ppdata.of_node = spi->dev.of_node;
 	flash->mtd.dev.parent = &spi->dev;
 	flash->page_size = info->page_size;
@@ -1011,11 +1125,23 @@ static int __devinit m25p_probe(struct spi_device *spi)
 		/* enable 4-byte addressing if the device exceeds 16MiB */
 		if (flash->mtd.size > 0x1000000) {
 			flash->addr_width = 4;
+			write_enable(flash);
 			set_4byte(flash, info->jedec_id, 1);
 		} else
 			flash->addr_width = 3;
 	}
 
+	/* set up the VCR for 8 dummy cycles (instead of the default 15) */
+	if (info->jedec_id == N25Q00_JEDEC_ID) {
+		int vcr = read_vcr(flash);
+		if (vcr >= 0) {
+			vcr &= ~(VCR_DUMMY_CLK_CYCLES_MASK | VCR_XIP_MASK);
+			vcr |= (8 << VCR_DUMMY_CLK_CYCLES_SHIFT);
+			write_enable(flash);
+			write_vcr(flash, vcr);
+		}
+	}
+
 	spi->addr_width = flash->addr_width;
 
 	dev_info(&spi->dev, "%s (%lld Kbytes)\n", id->name,
-- 
1.7.6

