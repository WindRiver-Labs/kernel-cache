From 398fcb983f3855638ccca797b14febbcfacf5244 Mon Sep 17 00:00:00 2001
From: Zumeng Chen <zumeng.chen@windriver.com>
Date: Fri, 14 Jun 2013 15:39:27 +0800
Subject: [PATCH 252/254] arm: socfpga: pcie: ATS 702, PCIe root port
 reference design

Upstream: git://git.rocketboards.org/linux-socfpga.git

Altera PCIe Root Port Driver
v2 -
    Move to \drivers\bus\altera_pcie.c
    Add Documentation\devicetree\bindings\bus\altera-pcie.txt
    Updated header to include mach-tegra\pcie.c
    Change __raw_readl/writel to readl/writel
    Use ~0UL instead of 0xFFFFFFFF
    Optimized reg read once instead of twice

Signed-off-by: Simon Yap <dsyap@altera.com>
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 .../devicetree/bindings/bus/altera-pcie.txt        |   21 +
 arch/arm/Kconfig                                   |    1 +
 arch/arm/boot/dts/socfpga_cyclone5.dts             |   48 ++
 arch/arm/mach-socfpga/Makefile                     |    3 +
 arch/arm/mach-socfpga/altera_pcie.c                |  507 ++++++++++++++++++++
 5 files changed, 580 insertions(+), 0 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/bus/altera-pcie.txt
 create mode 100644 arch/arm/mach-socfpga/altera_pcie.c

diff --git a/Documentation/devicetree/bindings/bus/altera-pcie.txt b/Documentation/devicetree/bindings/bus/altera-pcie.txt
new file mode 100644
index 0000000..369dcf3
--- /dev/null
+++ b/Documentation/devicetree/bindings/bus/altera-pcie.txt
@@ -0,0 +1,21 @@
+* Altera PCI Express Root Port
+
+Altera FPGA include of PCIe RP IP
+
+properties:
+- compatible : "altr,pcie-root-port-1.0"
+- reg, cra or txs : bases for CTA and TXS
+- interrupts : interrupt connection
+
+Example
+	pcie_cv_hip_avmm_0: pcie@0x0 {
+		compatible = "altr,pcie-root-port-1.0";
+		reg = < 0x00000000 0x20000000 >;
+		cra = < 0xFF240000 0x00004000 >;
+		/* txs = < 0xC0000000 0x20000000 >; */
+		interrupt-parent = < &hps_0_arm_gic_0 >;
+		interrupts = < 0 43 4 >;
+		interrupt-controller;
+		#interrupt-cells = < 1 >;
+	}; //end pcie@0x0 (pcie_cv_hip_avmm_0)
+
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 19fbef3..1135b48 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -293,6 +293,7 @@ config ARCH_SOCFPGA
 	select HAVE_ARM_SCU
 	select HAVE_SMP
 	select MIGHT_HAVE_CACHE_L2X0
+	select MIGHT_HAVE_PCI
 	select SPARSE_IRQ
 	select USE_OF
 	select SOC_BUS
diff --git a/arch/arm/boot/dts/socfpga_cyclone5.dts b/arch/arm/boot/dts/socfpga_cyclone5.dts
index d640b80..b90670f 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5.dts
@@ -171,6 +171,54 @@
 			speed-mode = <0>;
 		};
 
+		hps_0_h2f: bridge@0xc0000000 {
+			compatible = "altr,h2f_bridge-1.0";
+			reg = < 0xC0000000 0x20000000 >;
+			#address-cells = < 1 >;
+			#size-cells = < 1 >;
+			ranges = < 0x00000000 0xC0000000 0x20000000 >;
+
+			mm_clock_crossing_bridge_H2F: bridge@0x0 {
+				compatible = "ALTR,avalon-13.0";
+				reg = < 0x00000000 0x20000000 >;
+				#address-cells = < 1 >;
+				#size-cells = < 1 >;
+				ranges = < 0x00000000 0x00000000 0x20000000 >;
+
+				pcie_cv_hip_avmm_0: pcie@0x0 {
+					compatible = "ALTR,root-port-13.0";
+					reg = < 0x00000000 0x20000000 >;
+					cra = < 0xFF240000 0x00004000 >;
+					/* txs = < 0xC0000000 0x20000000 >; */
+					interrupts = < 0 43 4 >;
+				}; //end pcie@0x0 (pcie_cv_hip_avmm_0)
+			}; //end bridge@0x0 (mm_clock_crossing_bridge_H2F)
+		}; //end bridge@0xc0000000 (hps_0_h2f)
+
+		hps_0_h2f_lw: bridge@0xff200000 {
+			compatible = "altr,h2f_lw_bridge-1.0";
+			reg = < 0xFF200000 0x00050000 >;
+			#address-cells = < 1 >;
+			#size-cells = < 1 >;
+			ranges = < 0x00040000 0xFF240000 0x00008000 >;
+
+			mm_clock_crossing_bridge_LW: bridge@0x40000 {
+				compatible = "ALTR,avalon-13.0";
+				reg = < 0x00040000 0x00008000 >;
+				#address-cells = < 1 >;
+				#size-cells = < 1 >;
+				ranges = < 0x00004000 0x00044000 0x00000020
+					0x00004020 0x00044020 0x00000010 >;
+
+				msgdma_0_modular_sgdma_dispatcher_0: msgdma@0x4000 {
+					compatible = "ALTR,msgdma-1.0";
+					reg = < 0x00004000 0x00000020
+						0x00004020 0x00000010 >;
+					interrupts = < 0 44 4 >;
+				}; //msgdma@0x4000 (msgdma_0_modular_sgdma_dispatcher_0)
+			}; //end bridge@0x40000 (mm_clock_crossing_bridge_LW)
+		}; //end bridge@0xff200000 (hps_0_h2f_lw)
+
 		leds {
 			compatible = "gpio-leds";
 			hps0 {
diff --git a/arch/arm/mach-socfpga/Makefile b/arch/arm/mach-socfpga/Makefile
index 6dd7a93..b33b01c 100644
--- a/arch/arm/mach-socfpga/Makefile
+++ b/arch/arm/mach-socfpga/Makefile
@@ -4,3 +4,6 @@
 
 obj-y					:= socfpga.o
 obj-$(CONFIG_SMP)	+= headsmp.o platsmp.o
+
+# Interconnect pcie bus driver for Altera SoCs.
+obj-$(CONFIG_ALTERA_PCIE_RP) += altera_pcie.o
diff --git a/arch/arm/mach-socfpga/altera_pcie.c b/arch/arm/mach-socfpga/altera_pcie.c
new file mode 100644
index 0000000..0e09d79
--- /dev/null
+++ b/arch/arm/mach-socfpga/altera_pcie.c
@@ -0,0 +1,507 @@
+/*
+ *  Copyright (C) 2013 Altera Corporation
+ *
+ * Bits taken from arch/arm/mach-tegra/pcie.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+
+/* Registers offset */
+#define A2P_ADDR_MAP_LO0  0x1000
+#define A2P_ADDR_MAP_HI0  0x1004
+#define RP_TX_REG0        0x2000
+#define RP_TX_REG1        0x2004
+#define RP_TX_CNTRL       0x2008
+#define RP_TX_EOP         0x2
+#define RP_TX_SOP         0x1
+#define RP_RXCPL_STATUS   0x2010
+#define RP_RXCPL_EOP      0x2
+#define RP_RXCPL_SOP      0x1
+#define RP_RXCPL_REG0     0x2014
+#define RP_RXCPL_REG1     0x2018
+#define P2A_INT_STATUS    0x3060
+#define P2A_INT_STS_ALL   0x0F
+#define RPRX_CPL_REV      0x10
+#define P2A_INT_ENABLE    0x3070
+#define P2A_INT_ENA_ALL   0x0F
+
+/* TLP CFG RD WR */
+#define TLP_FMTTYPE_CFGRD0 0x04  /* Configuration Read  Type 0 */
+#define TLP_FMTTYPE_CFGWR0 0x44  /* Configuration Write Type 0 */
+#define TLP_FMTTYPE_CFGRD1 0x05  /* Configuration Read  Type 1 */
+#define TLP_FMTTYPE_CFGWR1 0x45  /* Configuration Write Type 1 */
+#define TLP_PAYLOAD_SIZE   0x01  /* TLP Data Payload Size      */
+#define TLP_CFG_DW0(fmttype)            ((fmttype << 24) | TLP_PAYLOAD_SIZE)
+#define TLP_CFG_DW1(reqid, tag)         ((reqid << 16) | (tag << 8) | 0xF)
+#define TLP_READ_TAG       0x1D  /* statically define */
+#define TLP_WRITE_TAG      0x10  /* statically define */
+#define TLP_CFG_DW2(bus, devfn, offset) ((bus << 24) | (devfn << 16) | offset)
+
+struct altrpcierp_info_t {
+	void __iomem	*pcie_hip_avmm_cra_base;
+	u32		pcie_hip_avmm_txs_base_raw;
+	u32		pcie_hip_avmm_txs_size_raw;
+	int		hwirq;
+};
+
+struct tlp_rp_regpair_t {
+	u32 rp_ctrl;
+	u32 rp_reg0;
+	u32 rp_reg1;
+};
+
+/*
+ * The Root Port is boot/initialized with bus 0 device 0
+ * pribus use TYPE0 CFG, secbus use TYPE1 CFG, subbus use TYPE1 CFG
+ */
+#define ALTRPCIERP_DEVFN 0
+static u8 rp_pribus;
+static u8 rp_secbus;
+static struct altrpcierp_info_t altrpcierp_info;
+
+/* TLP packet RX pair */
+static void tlp_read_rp_rx(struct tlp_rp_regpair_t *tlp_rp_regdata)
+{
+	tlp_rp_regdata->rp_ctrl = readl(
+		altrpcierp_info.pcie_hip_avmm_cra_base + RP_RXCPL_STATUS);
+	tlp_rp_regdata->rp_reg0 = readl(
+		altrpcierp_info.pcie_hip_avmm_cra_base + RP_RXCPL_REG0);
+	tlp_rp_regdata->rp_reg1 = readl(
+		altrpcierp_info.pcie_hip_avmm_cra_base + RP_RXCPL_REG1);
+}
+
+/* TLP packet TX pair */
+static void tlp_write_rp_tx(struct tlp_rp_regpair_t *tlp_rp_regdata)
+{
+	writel(tlp_rp_regdata->rp_reg0,
+		altrpcierp_info.pcie_hip_avmm_cra_base + RP_TX_REG0);
+	writel(tlp_rp_regdata->rp_reg1,
+		altrpcierp_info.pcie_hip_avmm_cra_base + RP_TX_REG1);
+	writel(tlp_rp_regdata->rp_ctrl,
+		altrpcierp_info.pcie_hip_avmm_cra_base + RP_TX_CNTRL);
+}
+
+/* TLP packet detect SOP and EOP */
+static int tlp_read_packet(u32 *value)
+{
+	int err = 0;
+	u8 loop;
+	struct tlp_rp_regpair_t *tlp_rp_regdata;
+
+	/* allocate tlp_rp_regdata */
+	tlp_rp_regdata = kzalloc(sizeof(struct tlp_rp_regpair_t), GFP_KERNEL);
+	if (!tlp_rp_regdata) {
+		pr_err("altrpcierp out of memory !!!\n");
+		err = -ENOMEM;
+		goto ret_error;
+	}
+
+	/*
+	 * Detect RP_RXCPL_SOP is not require,
+	 * read till EOP to avoid completion packet misalignment.
+	 * Detect RP_RXCPL_EOP with loop of
+	 * TLP_PAYLOAD_SIZE + 1(SOP) + 2(header) + 3(detection loop)
+	 */
+	for (loop = (TLP_PAYLOAD_SIZE+1+2+3); loop > 0; loop--) {
+		tlp_read_rp_rx(tlp_rp_regdata);
+		/* detect EOP */
+		if (tlp_rp_regdata->rp_ctrl & RP_RXCPL_EOP)
+			break;
+	}
+	/* if no EOP detected */
+	if (loop == 0) {
+		err = -ENOENT;
+		goto ret_freemem;
+	}
+
+	/* read data */
+	if (value)
+		*value = tlp_rp_regdata->rp_reg0;
+
+ret_freemem:
+	kfree(tlp_rp_regdata);
+ret_error:
+	return err;
+}
+
+/* pci_ops read using TLP packet receive */
+static int tlp_cfg_dword_read(u8 bus, unsigned int devfn,
+			      int where, u32 *value)
+{
+	struct tlp_rp_regpair_t *tlp_rp_regdata;
+
+	/* if not DWORD align */
+	if ((where & 0x3) != 0) {
+		pr_err("altrpcierp data not DWORD align\n");
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	}
+
+	/*
+	 * Implement the device number filtering at the lowest level layer.
+	 * Per PCIe spec section 7.3.1 - Configuration Requests
+	 * targeting the Bus Number associated with a Link specifying
+	 * Device Number 0 are delivered to the device attached to the Link;
+	 * Configuration Requests specifying all other Device Numbers (1-31)
+	 * must be terminated by the Switch Downstream Port or the Root Port
+	 * with an Unsupported Request Completion Status.
+	 */
+	if (((bus == rp_pribus) || (bus == rp_secbus)) && ((devfn >> 3) > 0)) {
+		*value = ~0UL;
+		return PCIBIOS_SUCCESSFUL;
+	}
+
+	/* allocate tlp_rp_regdata */
+	tlp_rp_regdata = kzalloc(sizeof(struct tlp_rp_regpair_t), GFP_KERNEL);
+	if (!tlp_rp_regdata) {
+		pr_err("altrpcierp out of memory !!!\n");
+		return -ENOMEM;
+	}
+
+	/* sending TLP packet */
+	if (bus == rp_pribus)
+		tlp_rp_regdata->rp_reg0 = TLP_CFG_DW0(TLP_FMTTYPE_CFGRD0);
+	else
+		tlp_rp_regdata->rp_reg0 = TLP_CFG_DW0(TLP_FMTTYPE_CFGRD1);
+	tlp_rp_regdata->rp_reg1 = TLP_CFG_DW1(
+				  ((rp_pribus << 8) | ALTRPCIERP_DEVFN),
+				  TLP_READ_TAG);
+	tlp_rp_regdata->rp_ctrl = RP_TX_SOP;
+	tlp_write_rp_tx(tlp_rp_regdata);
+	tlp_rp_regdata->rp_reg0 = TLP_CFG_DW2(bus, devfn, where);
+	tlp_rp_regdata->rp_reg1 = 0x0;
+	tlp_rp_regdata->rp_ctrl = RP_TX_EOP;
+	tlp_write_rp_tx(tlp_rp_regdata);
+
+	/* read data from completion package, return 0xFFFFFFFF if error */
+	if (tlp_read_packet(value))
+		*value = ~0UL;
+
+	kfree(tlp_rp_regdata);
+	return PCIBIOS_SUCCESSFUL;
+}
+
+/* pci_ops write using TLP packet send */
+static int tlp_cfg_dword_write(u8 bus, unsigned int devfn,
+			       int where, u32 value)
+{
+	struct tlp_rp_regpair_t *tlp_rp_regdata;
+
+	/* if not DWORD align */
+	if ((where & 0x3) != 0) {
+		pr_err("altrpcierp data not DWORD align\n");
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	}
+
+	/*
+	 * Implement the device number filtering at the lowest level layer.
+	 * Per PCIe spec section 7.3.1 - Configuration Requests
+	 * targeting the Bus Number associated with a Link specifying
+	 * Device Number 0 are delivered to the device attached to the Link;
+	 * Configuration Requests specifying all other Device Numbers (1-31)
+	 * must be terminated by the Switch Downstream Port or the Root Port
+	 * with an Unsupported Request Completion Status.
+	 */
+	if (((bus == rp_pribus) || (bus == rp_secbus)) && ((devfn >> 3) > 0))
+		return PCIBIOS_SET_FAILED;
+
+	/* allocate tlp_rp_regdata */
+	tlp_rp_regdata = kzalloc(sizeof(struct tlp_rp_regpair_t), GFP_KERNEL);
+	if (!tlp_rp_regdata) {
+		pr_err("altrpcierp out of memory !!!\n");
+		return -ENOMEM;
+	}
+
+	/* sending TLP packet */
+	if (bus == rp_pribus)
+		tlp_rp_regdata->rp_reg0 = TLP_CFG_DW0(TLP_FMTTYPE_CFGWR0);
+	else
+		tlp_rp_regdata->rp_reg0 = TLP_CFG_DW0(TLP_FMTTYPE_CFGWR1);
+	tlp_rp_regdata->rp_reg1 = TLP_CFG_DW1(
+				  ((rp_pribus << 8) | ALTRPCIERP_DEVFN),
+				  TLP_WRITE_TAG);
+	tlp_rp_regdata->rp_ctrl = RP_TX_SOP;
+	tlp_write_rp_tx(tlp_rp_regdata);
+	tlp_rp_regdata->rp_reg0 = TLP_CFG_DW2(bus, devfn, where);
+	tlp_rp_regdata->rp_reg1 = value;
+	tlp_rp_regdata->rp_ctrl = RP_TX_EOP;
+	tlp_write_rp_tx(tlp_rp_regdata);
+
+	/* TLP read response */
+	tlp_read_packet(NULL);
+
+	/* if change altrpcierp bus number, update variable... */
+	if ((bus == rp_pribus) && (devfn == ALTRPCIERP_DEVFN) &&
+	    (where == PCI_PRIMARY_BUS)) {
+		rp_pribus = (u8)(value);
+		rp_secbus = (u8)(value >> 8);
+	}
+
+	kfree(tlp_rp_regdata);
+	return PCIBIOS_SUCCESSFUL;
+}
+
+/* pci_ops read */
+static int altrpcierp_cfg_read(struct pci_bus *bus, unsigned int devfn,
+			       int where, int size, u32 *value)
+{
+	/* if cross DWORD boundary */
+	if (((where & 0x3) + size) > 4) {
+		pr_err("Data cross DWORD boundary\n");
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	}
+
+	/* TLP read */
+	tlp_cfg_dword_read(bus->number, devfn, (where & ~0x3), value);
+	*value = *value >> ((where & 0x3) << 3);  /* position */
+	*value = *value & (~0UL >> ((4 - size) << 3));  /* mask */
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+/* pci_ops write */
+static int altrpcierp_cfg_write(struct pci_bus *bus, unsigned int devfn,
+				int where, int size, u32 value)
+{
+	u32 data32 = value;
+
+	/* if cross DWORD boundary */
+	if (((where & 0x3) + size) > 4) {
+		pr_err("Data cross DWORD boundary\n");
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	}
+
+	/* TLP read and merge DWORD */
+	if ((where & 0x3) || (size != 4)) {
+		tlp_cfg_dword_read(bus->number, devfn, where & ~0x3, &data32);
+		data32 = data32 & ~((~0UL >> ((4 - size) << 3))
+				    << ((where & 0x3) << 3));
+		data32 = data32 | (value << ((where & 0x3) << 3));
+	}
+
+	/* TLP write */
+	tlp_cfg_dword_write(bus->number, devfn, (where & ~0x3), data32);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+/* pci_ops */
+static struct pci_ops altrpcierp_ops = {
+	.read = altrpcierp_cfg_read,
+	.write = altrpcierp_cfg_write,
+};
+
+/* hw_pci setup */
+static int altrpcierp_setup(int nr, struct pci_sys_data *sys)
+{
+	int err;
+	u8  pages;
+	u32 translation_size;
+	struct resource *res;
+
+	/* get translation table size */
+	writel(~0UL,
+		altrpcierp_info.pcie_hip_avmm_cra_base + A2P_ADDR_MAP_LO0);
+	translation_size = (~(readl(
+		altrpcierp_info.pcie_hip_avmm_cra_base + A2P_ADDR_MAP_LO0)
+		& 0xFFFFFFFC)) + 1;
+
+	/* get number of translation table pages */
+	pages = altrpcierp_info.pcie_hip_avmm_txs_size_raw / translation_size;
+
+	/* allocate resource memory */
+	res = kzalloc(sizeof(struct resource) * pages, GFP_KERNEL);
+	if (!res) {
+		pr_err("altrpcierp out of memory !!!\n");
+		err = -ENOMEM;
+		goto ret_error;
+	}
+
+	/* IORESOURCE_MEM use A2P_ADDR_MAP_LO0 */
+	if (pages >= 1) {
+		res[0].name  = "ALTERA PCIE RP MEM";
+		res[0].start = altrpcierp_info.pcie_hip_avmm_txs_base_raw;
+		res[0].end   = res[0].start + translation_size - 1;
+		res[0].flags = IORESOURCE_MEM;
+		if (request_resource(&iomem_resource, &res[0])) {
+			pr_err("altrpcierp out of memory !!!\n");
+			err = -ENOMEM;
+			goto ret_freeres;
+		}
+		pci_add_resource_offset(&sys->resources, &res[0],
+					sys->mem_offset);
+	}
+
+	/* IORESOURCE_MEM | IORESOURCE_PREFETCH */
+	if (pages >= 2) {
+		res[1].name  = "ALTERA PCIE RP PREF MEM";
+		res[1].start = res[0].end + 1;
+		res[1].end   = res[1].start + translation_size - 1;
+		res[1].flags = IORESOURCE_MEM | IORESOURCE_PREFETCH;
+		if (request_resource(&iomem_resource, &res[1])) {
+			pr_err("altrpcierp out of memory !!!\n");
+			err = -ENOMEM;
+			goto ret_relres;
+		}
+		pci_add_resource_offset(&sys->resources, &res[1],
+					sys->mem_offset);
+	}
+
+	/* Configure Avalon-MM-to-PCI Express Address Translation Table */
+	writel(res[0].start,
+		altrpcierp_info.pcie_hip_avmm_cra_base + A2P_ADDR_MAP_LO0);
+	writel(0x0,
+		altrpcierp_info.pcie_hip_avmm_cra_base + A2P_ADDR_MAP_HI0);
+	writel(res[1].start,
+		altrpcierp_info.pcie_hip_avmm_cra_base + A2P_ADDR_MAP_LO0 + 8);
+	writel(0x0,
+		altrpcierp_info.pcie_hip_avmm_cra_base + A2P_ADDR_MAP_HI0 + 8);
+
+	return 1;
+
+ret_relres:
+	release_resource(res);
+ret_freeres:
+	kfree(res);
+ret_error:
+	return err;
+}
+
+/* hw_pci map_irq */
+static int altrpcierp_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return altrpcierp_info.hwirq;
+}
+
+/* hw_pci */
+static struct hw_pci altrpcierp_hw __initdata = {
+#ifdef CONFIG_PCI_DOMAINS
+	.domain			= 0,
+#endif
+	.ops			= &altrpcierp_ops,
+	.nr_controllers		= 1,
+	.setup			= altrpcierp_setup,
+	.map_irq		= altrpcierp_map_irq,
+};
+
+/* RP ISR - clear status */
+static irqreturn_t altrpcierp_isr(int irq, void *arg)
+{
+	__raw_writel(P2A_INT_STS_ALL,
+		altrpcierp_info.pcie_hip_avmm_cra_base + P2A_INT_STATUS);
+	return IRQ_HANDLED;
+}
+
+/* RP device init and resources, based on Device Tree */
+static int altrpcierp_devinit(struct device_node *node)
+{
+	u32 dtdata[2];
+	const u32 *regaddr_p;
+	u64 address64, size64;
+
+	/* read from "reg" */
+	regaddr_p = of_get_address(node, 0, &size64, NULL);
+
+	/* get CRA TXS base and size from DT */
+	if (!of_property_read_u32_array(node, "cra", dtdata, 2)) {
+		/* TXS read from "reg" */
+		if (regaddr_p == NULL) {
+			pr_err("altrpcierp fail to get TXS register\n");
+			return -EIO;
+		}
+		address64 = of_translate_address(node, regaddr_p);
+		altrpcierp_info.pcie_hip_avmm_txs_base_raw = (u32)address64;
+		altrpcierp_info.pcie_hip_avmm_txs_size_raw = (u32)size64;
+		/* CRA read from "cra" */
+		altrpcierp_info.pcie_hip_avmm_cra_base = ioremap_nocache(
+			(phys_addr_t)dtdata[0], (unsigned long)dtdata[1]);
+		if (altrpcierp_info.pcie_hip_avmm_cra_base == NULL) {
+			pr_err("altrpcierp fail to map CRA register\n");
+			return -ENOMEM;
+		}
+	} else {
+		/* TXS read from "txs" */
+		if (!of_property_read_u32_array(node, "txs", dtdata, 2)) {
+			altrpcierp_info.pcie_hip_avmm_txs_base_raw =
+				(u32)dtdata[0];
+			altrpcierp_info.pcie_hip_avmm_txs_size_raw =
+				(u32)dtdata[1];
+		} else {
+			pr_err("altrpcierp fail to get TXS register\n");
+			return -EIO;
+		}
+		/* CRA read from "reg" */
+		if (regaddr_p == NULL) {
+			pr_err("altrpcierp fail to get CRA register\n");
+			return -EIO;
+		}
+		address64 = of_translate_address(node, regaddr_p);
+		altrpcierp_info.pcie_hip_avmm_cra_base = ioremap_nocache(
+			(phys_addr_t)address64, (unsigned long)size64);
+		if (altrpcierp_info.pcie_hip_avmm_cra_base == NULL) {
+			pr_err("altrpcierp fail to map CRA register\n");
+			return -ENOMEM;
+		}
+	}
+
+	/* setup IRQ */
+	altrpcierp_info.hwirq = irq_of_parse_and_map(node, 0);
+	if (request_irq(altrpcierp_info.hwirq, altrpcierp_isr,
+			IRQF_SHARED, "PCIE", &altrpcierp_info))
+		pr_err("altrpcierp failed to register legacy IRQ\n");
+	else
+		set_irq_flags(altrpcierp_info.hwirq, IRQF_VALID);
+
+	/* clear PCIe to AvMM IRQ status */
+	writel(P2A_INT_STS_ALL,
+		altrpcierp_info.pcie_hip_avmm_cra_base + P2A_INT_STATUS);
+	/* enable PCIe to AvMM IRQ */
+	writel(P2A_INT_ENA_ALL,
+		altrpcierp_info.pcie_hip_avmm_cra_base + P2A_INT_ENABLE);
+
+	return 0;
+}
+
+static const struct of_device_id altrpcie_ids[] = {
+	{ .compatible = "ALTR,root-port-13.0", },
+	{ .compatible = "ALTR,pcie-root-port-13.0", },
+	{ .compatible = "altr,pcie-root-port-1.0", },
+	{},
+};
+
+static int __init altrpcie_init(void)
+{
+	struct device_node *node = NULL;
+
+	node = of_find_matching_node(NULL, altrpcie_ids);
+	if (node) {
+		if (altrpcierp_devinit(node))
+			return -ENOMEM;
+		pci_common_init(&altrpcierp_hw);
+	} else {
+		pr_err("altrpcierp failed to find device node\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+subsys_initcall(altrpcie_init);
-- 
1.7.5.4

