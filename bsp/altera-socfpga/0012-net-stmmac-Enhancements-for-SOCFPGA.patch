From c517a6e85d2a24902262375bc432e1a269d7e1e8 Mon Sep 17 00:00:00 2001
From: Dinh Nguyen <dinguyen@altera.com>
Date: Wed, 17 Oct 2012 07:17:48 -0500
Subject: [PATCH 012/248] net: stmmac: Enhancements for SOCFPGA

Modified the driver to support HW without a PHY.

[Original patch taken from
git://git.rocketboards.org/linux-socfpga.git socfpga-3.14]

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
Signed-off-by: Dinh Nguyen <dinguyen@altera.com>
---
 drivers/net/ethernet/stmicro/stmmac/Kconfig       | 60 +++++++++++++++++++++++
 drivers/net/ethernet/stmicro/stmmac/stmmac_main.c | 11 +++++
 2 files changed, 71 insertions(+)

diff --git a/drivers/net/ethernet/stmicro/stmmac/Kconfig b/drivers/net/ethernet/stmicro/stmmac/Kconfig
index f2d7c70..4c4288d 100644
--- a/drivers/net/ethernet/stmicro/stmmac/Kconfig
+++ b/drivers/net/ethernet/stmicro/stmmac/Kconfig
@@ -77,4 +77,64 @@ config STMMAC_DA
 	  By default, the DMA arbitration scheme is based on Round-robin
 	  (rx:tx priority is 1:1).
 
+config STMMAC_PHY_ID_ZERO_WORKAROUND
+	bool "STMMAC work around for non-existant phys returning 0"
+	default y
+	depends on STMMAC_ETH && ARCH_SOCFPGA
+	help
+	  Broken HW is sometimes missing the pull-up resistor on the
+	  MDIO line, which results in reads to non-existent devices returning
+	  0 rather than 0xffff.
+
+config STMMAC_SHARED_PHY_IRQ
+	bool "STMMAC and Phy have or'd IRQ"
+	default n
+	depends on STMMAC_ETH && ARCH_SOCFPGA
+	help
+	  Selecting this option means the IRQ lines for the STMMAC
+	  and its phy are hooked up to an or gate.
+
+config STMMAC_TIMER
+	bool "STMMAC Timer optimisation"
+	default n
+	depends on RTC_HCTOSYS_DEVICE
+	---help---
+	  Use an external timer for mitigating the number of network
+	  interrupts. Currently, for SH architectures, it is possible
+	  to use the TMU channel 2 and the SH-RTC device.
+
+choice
+        prompt "Select Timer device"
+        depends on STMMAC_TIMER
+
+config STMMAC_TMU_TIMER
+        bool "TMU channel 2"
+        depends on CPU_SH4
+	---help---
+
+config STMMAC_RTC_TIMER
+        bool "Real time clock"
+        depends on RTC_CLASS
+	---help---
+
+endchoice
+
+choice
+	prompt "Select the DMA TX/RX descriptor operating modes"
+	depends on STMMAC_ETH
+	---help---
+	  This driver supports DMA descriptor to operate both in dual buffer
+	  (RING) and linked-list(CHAINED) mode. In RING mode each descriptor
+	  points to two data buffer pointers whereas in CHAINED mode they
+	  points to only one data buffer pointer.
+
+config STMMAC_RING
+	bool "Enable Descriptor Ring Mode"
+
+config STMMAC_CHAINED
+	bool "Enable Descriptor Chained Mode"
+
+endchoice
+
+
 endif
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 8543e1c..565d536 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -815,6 +815,13 @@ static int stmmac_init_phy(struct net_device *dev)
 		return PTR_ERR(phydev);
 	}
 
+#ifdef CONFIG_ARCH_SOCFPGA
+	if (priv->plat->has_gmac) {
+		phydev->supported |= PHY_GBIT_FEATURES;
+		phydev->advertising |= PHY_GBIT_FEATURES;
+	}
+#endif
+
 	/* Stop Advertising 1000BASE Capability if interface is not GMII */
 	if ((interface == PHY_INTERFACE_MODE_MII) ||
 	    (interface == PHY_INTERFACE_MODE_RMII) ||
@@ -822,6 +829,7 @@ static int stmmac_init_phy(struct net_device *dev)
 		phydev->advertising &= ~(SUPPORTED_1000baseT_Half |
 					 SUPPORTED_1000baseT_Full);
 
+#ifdef CONFIG_STMMAC_PHY_ID_ZERO_WORKAROUND
 	/*
 	 * Broken HW is sometimes missing the pull-up resistor on the
 	 * MDIO line, which results in reads to non-existent devices returning
@@ -833,6 +841,7 @@ static int stmmac_init_phy(struct net_device *dev)
 		phy_disconnect(phydev);
 		return -ENODEV;
 	}
+#endif
 	pr_debug("stmmac_init_phy:  %s: attached to PHY (UID 0x%x)"
 		 " Link = %d\n", dev->name, phydev->phy_id, phydev->link);
 
@@ -1732,6 +1741,7 @@ static int stmmac_open(struct net_device *dev)
 	if (priv->phydev)
 		phy_start(priv->phydev);
 
+#ifndef CONFIG_STMMAC_SHARED_PHY_IRQ
 	/* Request the IRQ lines */
 	ret = request_irq(dev->irq, stmmac_interrupt,
 			  IRQF_SHARED, dev->name, dev);
@@ -1740,6 +1750,7 @@ static int stmmac_open(struct net_device *dev)
 		       __func__, dev->irq, ret);
 		goto init_error;
 	}
+#endif
 
 	/* Request the Wake IRQ in case of another line is used for WoL */
 	if (priv->wol_irq != dev->irq) {
-- 
1.9.1

