From 550604f7240517763d2c0b963ba6a2610d522d43 Mon Sep 17 00:00:00 2001
From: Dinh Nguyen <dinguyen@altera.com>
Date: Mon, 4 Aug 2014 16:36:47 -0500
Subject: [PATCH 058/172] Revert "FogBugz #111740: [PATCH] Integrates Nios II
 kernel (FDT)"

This reverts commit aecabdb990d138237d19e1ac13f3ad37176a4917.
[czou:Original patch taken from
https://github.com/altera-opensource/linux-socfpga.git socfpga-4.1]
Signed-off-by: czou <cao.zou@windriver.com>
---
 drivers/of/fdt.c       | 187 -------------------------------------------------
 include/linux/of_fdt.h |  12 ----
 2 files changed, 199 deletions(-)

diff --git a/drivers/of/fdt.c b/drivers/of/fdt.c
index ae35312..d91f721 100644
--- a/drivers/of/fdt.c
+++ b/drivers/of/fdt.c
@@ -953,193 +953,6 @@ int __init early_init_dt_scan_chosen(unsigned long node, const char *uname,
 	/* break now */
 	return 1;
 }
-/**
- * flat_dt_translate_address - Translate an address using the ranges property
- *
- * This function converts address from "node address-space" to "parent address-
- * space"
- */
-static int __init flat_dt_translate_address(unsigned long node,
-		unsigned long parent, u64 *address)
-{
-	unsigned long size = 0;
-	__be32 *prop;
-	__be32 *ranges;
-	int size_cells = 0;
-	int addr_cells = 0;
-	int paddr_cells = OF_ROOT_NODE_ADDR_CELLS_DEFAULT;
-
-	ranges = of_get_flat_dt_prop(node, "ranges", &size);
-
-	if (!ranges) {
-		pr_warn("Address cannot be translated\n");
-		return -EINVAL;
-	}
-
-	if (!size) {
-		pr_debug("No translation possible/necessary\n");
-		return 0;
-	}
-
-	prop = of_get_flat_dt_prop(node, "#size-cells", NULL);
-	if (!prop)
-		return -EINVAL;
-		size_cells = be32_to_cpup(prop);
-
-	prop = of_get_flat_dt_prop(node, "#address-cells", NULL);
-	if (!prop)
-		return -EINVAL;
-		addr_cells = be32_to_cpup(prop);
-
-	if (parent) {
-		prop = of_get_flat_dt_prop(parent, "#address-cells", NULL);
-		if (prop)
-			paddr_cells = be32_to_cpup(prop);
-	}
-	if ((addr_cells <= 0) || (size_cells <= 0) ||
-		(addr_cells > 2) || (size_cells > 2) || (paddr_cells > 2)) {
-		pr_warn("Translation not possible in fdt. Invalid address.\n");
-		*address = 0;
-		return -1;
-	}
-
-	while (size > 0) {
-		u64 from, to, tsize;
-		from = be32_to_cpup(ranges++);
-		size -= 4;
-		if (addr_cells == 2) {
-			from += (((u64)be32_to_cpup(ranges++)) << 32);
-			size -= 4;
-		}
-		to = be32_to_cpup(ranges++);
-		size -= 4;
-		if (paddr_cells == 2) {
-			to += (((u64)be32_to_cpup(ranges++)) << 32);
-			size -= 4;
-		}
-		tsize = be32_to_cpup(ranges++);
-		size -= 4;
-		if (size_cells == 2) {
-			tsize += (((u64)be32_to_cpup(ranges++)) << 32);
-			size -= 4;
-		}
-		pr_debug("  From %llX To %llX Size %llX\n", from, to, tsize);
-		if ((*address >= from) && (*address < (from + tsize)))
-			*address += (to - from);
-	}
-	return 1;
-}
-
-static int __init of_scan_flat_dt_ranges(unsigned long *pnode,
-				unsigned long parent, unsigned long target,
-				u64 *address, int ignore)
-{
-	int rc = 0;
-	int depth = -1;
-	char *pathp;
-	unsigned long p = *pnode;
-	do {
-		u32 tag = be32_to_cpup((__be32 *)p);
-
-		p += 4;
-		if (tag == OF_DT_END_NODE) {
-			if (depth--)
-				break;
-			else
-				continue;
-		}
-		if (tag == OF_DT_NOP)
-			continue;
-		if (tag == OF_DT_END)
-			break;
-		if (tag == OF_DT_PROP) {
-			u32 sz = be32_to_cpup((__be32 *)p);
-			p += 8;
-			if (be32_to_cpu(initial_boot_params->version) < 0x10)
-				p = ALIGN(p, sz >= 8 ? 8 : 4);
-			p += sz;
-			p = ALIGN(p, 4);
-			continue;
-		}
-		if (tag != OF_DT_BEGIN_NODE) {
-			pr_err("Invalid tag %x in flat device tree!\n", tag);
-			return -EINVAL;
-		}
-		pathp = (char *)p;
-		p = ALIGN(p + strlen(pathp) + 1, 4);
-		if ((*pathp) == '/') {
-			char *lp, *np;
-			for (lp = NULL, np = pathp; *np; np++)
-				if ((*np) == '/')
-					lp = np+1;
-			if (lp != NULL)
-				pathp = lp;
-		}
-		if ((ignore == 0) && (p == target)) {
-			rc = 1;
-			ignore++;
-			pr_debug("Found target. Start address translation\n");
-		}
-		if (depth) {
-			int res;
-			*pnode = p;
-			res = of_scan_flat_dt_ranges(pnode, p, target,
-							address, ignore);
-			if (res < 0) {
-				/* Something bad happened */
-				return -1;
-			} else if (res > 0) {
-				/* Something gooed happened. Translate. */
-				rc++;
-				pr_debug("translate %08lX %s\n", p, pathp);
-				if (flat_dt_translate_address(p, parent,
-						address) < 0)
-					return -1;
-			}
-			p = *pnode;
-		} else
-			depth++;
-	} while (1);
-	*pnode = p;
-	return rc;
-}
-/**
- * of_get_flat_dt_address - get address from a node
- * @node: targeted node
- *
- * Returns address or -1 if error.
- */
-__be32 __init of_get_flat_dt_address(unsigned long node)
-{
-	u32 *addr;
-
-	addr = of_get_flat_dt_prop(node, "reg", NULL);
-	if (!addr)
-		return -1;
-
-	return be32_to_cpup(addr);
-}
-
-/**
- * of_get_flat_dt_translate_address - get translated address from a node
- * @node: targeted node
- *
- * Returns translated address or OF_BAD_ADDR if error.
- */
-u64 __init of_get_flat_dt_translate_address(unsigned long node)
-{
-	unsigned long p = of_get_flat_dt_root();
-	u64 addr64;
-	int rc;
-
-	addr64 = (u64) of_get_flat_dt_address(node);
-	if (addr64 == -1)
-		return OF_BAD_ADDR;
-	rc = of_scan_flat_dt_ranges(&p, 0, node, &addr64, 0);
-	if (rc > 0)
-		return addr64;
-	return OF_BAD_ADDR;
-}
 
 #ifdef CONFIG_HAVE_MEMBLOCK
 #ifndef MAX_MEMBLOCK_ADDR
diff --git a/include/linux/of_fdt.h b/include/linux/of_fdt.h
index 0fd644c..587ee50 100644
--- a/include/linux/of_fdt.h
+++ b/include/linux/of_fdt.h
@@ -70,18 +70,6 @@ extern int early_init_dt_reserve_memory_arch(phys_addr_t base, phys_addr_t size,
 extern void * early_init_dt_alloc_memory_arch(u64 size, u64 align);
 extern u64 dt_mem_next_cell(int s, const __be32 **cellp);
 
-extern __be32 __init of_get_flat_dt_address(unsigned long node);
-extern u64 __init of_get_flat_dt_translate_address(unsigned long node);
-
-/*
- * If BLK_DEV_INITRD, the fdt early init code will call this function,
- * to be provided by the arch code. start and end are specified as
- * physical addresses.
- */
-#ifdef CONFIG_BLK_DEV_INITRD
-extern void early_init_dt_setup_initrd_arch(u64 start, u64 end);
-#endif
-
 /* Early flat tree scan hooks */
 extern int early_init_dt_scan_root(unsigned long node, const char *uname,
 				   int depth, void *data);
-- 
1.9.1

