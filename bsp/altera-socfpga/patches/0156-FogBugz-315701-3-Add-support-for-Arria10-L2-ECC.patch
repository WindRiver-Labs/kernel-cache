From e9c589c15e260c98d9fdbd40afe85fcc02a984af Mon Sep 17 00:00:00 2001
From: Roman Bulgakov <roman.bulgakov@globallogic.com>
Date: Mon, 3 Aug 2015 16:26:38 -0500
Subject: [PATCH 156/172] FogBugz #315701-3: Add support for Arria10 L2 ECC

Refactor the L2 ECC driver to support Arria10.

Signed-off-by: Roman Bulgakov <roman.bulgakov@globallogic.com>
Signed-off-by: Dinh Nguyen <dinguyen@opensource.altera.com>
[czou:Original patch taken from
https://github.com/altera-opensource/linux-socfpga.git socfpga-4.1]
Signed-off-by: czou <cao.zou@windriver.com>
---
 drivers/edac/altera_ecc_l2.c       | 69 ++++++++++++++++++++++++++++++++++----
 drivers/edac/altera_ecc_mgr_edac.c | 46 ++++++++++++++++++++-----
 drivers/edac/altera_edac.h         | 41 ++++++++++++++++++++++
 3 files changed, 141 insertions(+), 15 deletions(-)

diff --git a/drivers/edac/altera_ecc_l2.c b/drivers/edac/altera_ecc_l2.c
index faba91e..4084f9c 100644
--- a/drivers/edac/altera_ecc_l2.c
+++ b/drivers/edac/altera_ecc_l2.c
@@ -20,6 +20,7 @@
 #include <linux/edac.h>
 #include <linux/kernel.h>
 #include <linux/mfd/syscon.h>
+#include <linux/of_address.h>
 #include <linux/of_platform.h>
 #include <linux/platform_device.h>
 #include <linux/regmap.h>
@@ -39,6 +40,22 @@
 #define ALTR_L2_ECC_INJS_MASK		0x00000002
 #define ALTR_L2_ECC_INJD_MASK		0x00000004
 
+/* Arria 10 L2 ECC Management Group Defines */
+#define ALTR_A10_L2_ECC_CTL_OFFSET	0x10
+#define ALTR_A10_L2_ECC_EN_CTL_MASK	0x00000001
+
+#define ALTR_A10_L2_ECC_STAT_OFFSET	0xa4
+#define ALTR_A10_L2_ECC_CE_STAT_MASK	0x00008000
+#define ALTR_A10_L2_ECC_UE_STAT_MASK	0x80000000
+
+#define ALTR_A10_L2_ECC_CLR_OFFSET	0xa8
+#define ALTR_A10_L2_ECC_CE_CLR_MASK	0x00008000
+#define ALTR_A10_L2_ECC_UE_CLR_MASK	0x80000000
+
+#define ALTR_A10_L2_ECC_INJ_OFFSET	0x10
+#define ALTR_A10_L2_ECC_CE_INJ_MASK	0x00000101
+#define ALTR_A10_L2_ECC_UE_INJ_MASK	0x00010101
+
 #ifdef CONFIG_EDAC_DEBUG
 static void *l2_init_mem(size_t size, void **other)
 {
@@ -87,22 +104,42 @@ static int altr_l2_dependencies(struct platform_device *pdev,
 				void __iomem *base)
 {
 	u32 control;
-	struct regmap *l2_vbase;
+	struct device_node *np;
+	void __iomem *l2_vbase;
+	void __iomem *en_addr;
+	u32 en_mask;
+
+	if (of_machine_is_compatible("altr,socfpga-arria10")) {
+		en_addr = (void __iomem *)((uintptr_t)base +
+					   ALTR_A10_L2_ECC_CTL_OFFSET);
+		en_mask = ALTR_A10_L2_ECC_EN_CTL_MASK;
+	} else {
+		en_addr = (void __iomem *)((uintptr_t)base +
+					   ALTR_MAN_GRP_L2_ECC_OFFSET);
+		en_mask = ALTR_L2_ECC_EN_MASK;
+	}
 
-	control = readl(base) & ALTR_L2_ECC_EN_MASK;
+	control = readl(en_addr) & en_mask;
 	if (!control) {
 		dev_err(&pdev->dev, "L2: No ECC present, or ECC disabled\n");
 		return -ENODEV;
 	}
 
-	l2_vbase = syscon_regmap_lookup_by_compatible("arm,pl310-cache");
-	if (IS_ERR(l2_vbase)) {
+	np = of_find_compatible_node(NULL, NULL, "arm,pl310-cache");
+	if (!np) {
+		dev_err(&pdev->dev,
+			"L2 ECC: Unable to find arm,pl310-cache in dtb\n");
+		return -ENODEV;
+	}
+
+	l2_vbase = of_iomap(np, 0);
+	if (!l2_vbase) {
 		dev_err(&pdev->dev,
-			"L2 ECC:regmap for arm,pl310-cache lookup failed.\n");
+			"L2 ECC: Unable to find arm,pl310-cache mapping in dtb\n");
 		return -ENODEV;
 	}
 
-	regmap_read(l2_vbase, ALTR_MPUL2_CONTROL_OFFSET, &control);
+	control = readl(l2_vbase + ALTR_MPUL2_CONTROL_OFFSET);
 	if (!(control & ALTR_MPUL2_CTL_CACHE_EN_MASK)) {
 		dev_err(&pdev->dev, "L2: Cache disabled\n");
 		return -ENODEV;
@@ -126,3 +163,23 @@ const struct ecc_mgr_prv_data l2ecc_data = {
 #endif
 };
 
+const struct ecc_mgr_prv_data a10_l2ecc_data = {
+	.setup = altr_l2_dependencies,
+	.ce_clear_mask = ALTR_A10_L2_ECC_CE_CLR_MASK,
+	.ue_clear_mask = ALTR_A10_L2_ECC_UE_CLR_MASK,
+	.clear_mask_offs = ALTR_A10_L2_ECC_CLR_OFFSET,
+	.ce_status_mask = ALTR_A10_L2_ECC_CE_STAT_MASK,
+	.ue_status_mask = ALTR_A10_L2_ECC_UE_STAT_MASK,
+	.status_mask_offs = ALTR_A10_L2_ECC_STAT_OFFSET,
+#ifdef CONFIG_EDAC_DEBUG
+	.eccmgr_sysfs_attr = altr_l2_sysfs_attributes,
+	.init_mem = l2_init_mem,
+	.free_mem = l2_free_mem,
+	.ecc_enable_mask = ALTR_A10_L2_ECC_EN_CTL_MASK,
+	.enable_mask_offs = ALTR_A10_L2_ECC_CTL_OFFSET,
+	.ce_set_mask = ALTR_A10_L2_ECC_CE_INJ_MASK,
+	.ue_set_mask = ALTR_A10_L2_ECC_UE_INJ_MASK,
+	.set_mask_offs = ALTR_A10_L2_ECC_INJ_OFFSET,
+	.trig_alloc_sz = 5000,
+#endif
+};
diff --git a/drivers/edac/altera_ecc_mgr_edac.c b/drivers/edac/altera_ecc_mgr_edac.c
index 5551691..548801d 100644
--- a/drivers/edac/altera_ecc_mgr_edac.c
+++ b/drivers/edac/altera_ecc_mgr_edac.c
@@ -36,20 +36,44 @@ static irqreturn_t altr_ecc_mgr_handler(int irq, void *dev_id)
 	struct edac_device_ctl_info *dci = dev_id;
 	struct altr_ecc_mgr_dev *drvdata = dci->pvt_info;
 	const struct ecc_mgr_prv_data *priv = drvdata->data;
+	void __iomem *clear_addr = ecc_clear_addr(drvdata);
+	void __iomem *stat_addr = ecc_status_addr(drvdata);
+	bool handle_ce = false;
+	bool handle_ue = false;
 
 	if (irq == drvdata->sb_irq) {
+		if (priv->ce_status_mask) {
+			if (readl(stat_addr) & priv->ce_status_mask)
+				handle_ce = true;
+		} else {
+			/* Cyclone V implementation */
+			handle_ce = true;
+		}
+	}
+
+	if (irq == drvdata->db_irq) {
+		if (priv->ue_status_mask) {
+			if (readl(stat_addr) & priv->ue_status_mask)
+				handle_ue = true;
+		} else {
+			/* Cyclone V implementation */
+			handle_ue = true;
+		}
+	}
+
+	if (handle_ce) {
 		if (priv->ce_clear_mask)
-			writel(priv->ce_clear_mask, drvdata->base);
+			writel(priv->ce_clear_mask, clear_addr);
 		edac_device_handle_ce(dci, 0, 0, drvdata->edac_dev_name);
 	}
-	if (irq == drvdata->db_irq) {
+
+	if (handle_ue) {
 		if (priv->ue_clear_mask)
-			writel(priv->ue_clear_mask, drvdata->base);
+			writel(priv->ue_clear_mask, clear_addr);
 		edac_device_handle_ue(dci, 0, 0, drvdata->edac_dev_name);
-		panic("\nEDAC:ECC_MGR[Uncorrectable errors]\n");
 	}
 
-	return IRQ_HANDLED;
+	return IRQ_RETVAL(handle_ce | handle_ue);
 }
 
 #ifdef CONFIG_EDAC_DEBUG
@@ -62,6 +86,8 @@ ssize_t altr_ecc_mgr_trig(struct edac_device_ctl_info *edac_dci,
 	struct altr_ecc_mgr_dev *drvdata = edac_dci->pvt_info;
 	const struct ecc_mgr_prv_data *priv = drvdata->data;
 	void *generic_ptr = edac_dci->dev;
+	void __iomem *set_addr = ecc_set_addr(drvdata);
+	void __iomem *en_addr = ecc_enable_addr(drvdata);
 
 	if (!priv->init_mem)
 		return -ENOMEM;
@@ -91,8 +117,8 @@ ssize_t altr_ecc_mgr_trig(struct edac_device_ctl_info *edac_dci,
 			result = -1;
 		rmb();
 		/* Toggle Error bit (it is latched), leave ECC enabled */
-		writel(error_mask, drvdata->base);
-		writel(priv->ecc_enable_mask, drvdata->base);
+		writel(error_mask, set_addr);
+		writel(priv->ecc_enable_mask, en_addr);
 		ptemp[i] = i;
 	}
 	wmb();
@@ -134,6 +160,7 @@ static void altr_set_sysfs_attr(struct edac_device_ctl_info *edac_dci,
 static const struct of_device_id altr_ecc_mgr_of_match[] = {
 #ifdef CONFIG_EDAC_ALTERA_L2_ECC
 	{ .compatible = "altr,l2-edac", .data = (void *)&l2ecc_data },
+	{ .compatible = "altr,a10-l2-edac", .data = (void *)&a10_l2ecc_data },
 #endif
 #ifdef CONFIG_EDAC_ALTERA_OCRAM_ECC
 	{ .compatible = "altr,ocram-edac", .data = (void *)&ocramecc_data },
@@ -168,6 +195,7 @@ static int altr_ecc_mgr_probe(struct platform_device *pdev)
 
 	drvdata = dci->pvt_info;
 	dci->dev = &pdev->dev;
+	dci->panic_on_ue = 1;
 	platform_set_drvdata(pdev, dci);
 	drvdata->edac_dev_name = ecc_name;
 
@@ -208,14 +236,14 @@ static int altr_ecc_mgr_probe(struct platform_device *pdev)
 	drvdata->sb_irq = platform_get_irq(pdev, 0);
 	res = devm_request_irq(&pdev->dev, drvdata->sb_irq,
 			       altr_ecc_mgr_handler,
-			       0, dev_name(&pdev->dev), dci);
+			       IRQF_SHARED, dev_name(&pdev->dev), dci);
 	if (res < 0)
 		goto err;
 
 	drvdata->db_irq = platform_get_irq(pdev, 1);
 	res = devm_request_irq(&pdev->dev, drvdata->db_irq,
 			       altr_ecc_mgr_handler,
-			       0, dev_name(&pdev->dev), dci);
+			       IRQF_SHARED, dev_name(&pdev->dev), dci);
 	if (res < 0)
 		goto err;
 
diff --git a/drivers/edac/altera_edac.h b/drivers/edac/altera_edac.h
index a6e334f..beef15e 100644
--- a/drivers/edac/altera_edac.h
+++ b/drivers/edac/altera_edac.h
@@ -204,13 +204,19 @@ struct ecc_mgr_prv_data {
 	int (*setup)(struct platform_device *pdev, void __iomem *base);
 	int ce_clear_mask;
 	int ue_clear_mask;
+	uintptr_t clear_mask_offs;
+	int ce_status_mask;
+	int ue_status_mask;
+	uintptr_t status_mask_offs;
 #ifdef CONFIG_EDAC_DEBUG
 	struct edac_dev_sysfs_attribute *eccmgr_sysfs_attr;
 	void * (*init_mem)(size_t size, void **other);
 	void (*free_mem)(void *p, size_t size, void *other);
 	int ecc_enable_mask;
+	uintptr_t enable_mask_offs;
 	int ce_set_mask;
 	int ue_set_mask;
+	uintptr_t set_mask_offs;
 	int trig_alloc_sz;
 #endif
 };
@@ -224,9 +230,44 @@ struct altr_ecc_mgr_dev {
 };
 
 extern const struct ecc_mgr_prv_data l2ecc_data;
+extern const struct ecc_mgr_prv_data a10_l2ecc_data;
 extern const struct ecc_mgr_prv_data ocramecc_data;
 
 ssize_t altr_ecc_mgr_trig(struct edac_device_ctl_info *edac_dci,
 			  const char *buffer, size_t count);
 
+static inline void __iomem *ecc_clear_addr(const struct altr_ecc_mgr_dev *dev)
+{
+	void __iomem *addr = (void __iomem *)((uintptr_t)dev->base +
+			      dev->data->clear_mask_offs);
+
+       return addr;
+}
+
+static inline void __iomem *ecc_status_addr(const struct altr_ecc_mgr_dev *dev)
+{
+	void __iomem *addr = (void __iomem *)((uintptr_t)dev->base +
+			      dev->data->status_mask_offs);
+
+       return addr;
+}
+
+#ifdef CONFIG_EDAC_DEBUG
+static inline void __iomem *ecc_enable_addr(const struct altr_ecc_mgr_dev *dev)
+{
+	void __iomem *addr = (void __iomem *)((uintptr_t)dev->base +
+			      dev->data->enable_mask_offs);
+
+       return addr;
+}
+
+static inline void __iomem *ecc_set_addr(const struct altr_ecc_mgr_dev *dev)
+{
+	void __iomem *addr = (void __iomem *)((uintptr_t)dev->base +
+			      dev->data->set_mask_offs);
+
+	return addr;
+}
+#endif
+
 #endif	/* #ifndef _ALTERA_EDAC_H */
-- 
1.9.1

