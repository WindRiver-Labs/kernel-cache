From 3c910071707df358820a1146379e94473696294d Mon Sep 17 00:00:00 2001
From: Thor Thayer <tthayer@altera.com>
Date: Thu, 19 Dec 2013 17:33:11 -0600
Subject: [PATCH 082/172] FogBugz #173185: OCRAM ECC addition for Altera
 SOCFPGA.

Add On-Chip RAM ECC to the Error Detection And Correction module for
tracking ECC errors in Altera's SOCFPGA OCRAM.
This patch adds code to the kernel startup that initializes OCRAM
and ensures the ECC is enabled. The generic EDAC Manager driver
handles the addition of OCRAM to the driver when the OCRAM "compatible"
field in the device tree matches.
Specific data is loaded depending upon which type of ECC (L2 or OCRAM)
is being initalized.

V2 Changes:
- Fix error message in OCRAM initialization.
- Document the device tree bindings for OCRAM & OCRAM ECC.
- Change variable name from sram to iram for clarity.
- Resync with main since EDAC L2 trigger was added.

V3 Changes:
- Remove OCRAM device tree binding file.
- Add conditional compile statements for L2 clear in socfpga.c

V4 Changes:
- Add OCRAM only config.
- Split OCRAM initialization into own files (ocram.c & ocram.h)
- Conditionally compile OCRAM matching tag.

V5 Changes:
- Cleanup of ocramedac address in socfpga.dtsi
- Use pr_err() consistently in ocram.c

V6 Changes:
- Cleanup of ocramedac address in socfpga-ocram-ecc.txt.
- Remove unused .setup function pointer.

Signed-off-by: Thor Thayer <tthayer@altera.com>
[czou:Original patch taken from
https://github.com/altera-opensource/linux-socfpga.git socfpga-4.1]
Signed-off-by: czou <cao.zou@windriver.com>
---
 .../bindings/arm/altera/socfpga-ocram-ecc.txt      | 16 ++++
 arch/arm/boot/dts/socfpga.dtsi                     |  7 ++
 arch/arm/mach-socfpga/Makefile                     |  1 +
 arch/arm/mach-socfpga/ocram.c                      | 85 ++++++++++++++++++++++
 arch/arm/mach-socfpga/ocram.h                      | 30 ++++++++
 arch/arm/mach-socfpga/socfpga.c                    |  2 +
 drivers/edac/Kconfig                               |  7 ++
 drivers/edac/altera_ecc_mgr_edac.c                 | 32 +++++++-
 8 files changed, 176 insertions(+), 4 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/arm/altera/socfpga-ocram-ecc.txt
 create mode 100644 arch/arm/mach-socfpga/ocram.c
 create mode 100644 arch/arm/mach-socfpga/ocram.h

diff --git a/Documentation/devicetree/bindings/arm/altera/socfpga-ocram-ecc.txt b/Documentation/devicetree/bindings/arm/altera/socfpga-ocram-ecc.txt
new file mode 100644
index 0000000..31ab205
--- /dev/null
+++ b/Documentation/devicetree/bindings/arm/altera/socfpga-ocram-ecc.txt
@@ -0,0 +1,16 @@
+Altera SoCFPGA On-Chip RAM Error Detection and Correction [EDAC]
+
+OCRAM ECC Required Properties:
+- compatible : Should be "altr,ocram-edac"
+- reg : Address and size for ECC error interrupt clear registers.
+- iram : phandle to On-Chip RAM definition.
+- interrupts : Should be single bit error interrupt, then double bit error
+	interrupt. Note the rising edge type.
+
+Example:
+	ocramedac@ffd08144 {
+		compatible = "altr,ocram-edac";
+		reg = <0xffd08144 0x4>;
+		iram = <&ocram>;
+		interrupts = <0 178 1>, <0 179 1>;
+	};
diff --git a/arch/arm/boot/dts/socfpga.dtsi b/arch/arm/boot/dts/socfpga.dtsi
index cdb3e45..bf8b756 100644
--- a/arch/arm/boot/dts/socfpga.dtsi
+++ b/arch/arm/boot/dts/socfpga.dtsi
@@ -774,6 +774,13 @@
 			interrupts = <0 36 1>, <0 37 1>;
                 };
 
+		ocramedac@ffd08144 {
+			compatible = "altr,ocram-edac";
+			reg = <0xffd08144 0x4>;
+			iram = <&ocram>;
+			interrupts = <0 178 1>, <0 179 1>;
+		};
+
 		l3regs@0xff800000 {
 			compatible = "altr,l3regs", "syscon";
 			reg = <0xff800000 0x1000>;
diff --git a/arch/arm/mach-socfpga/Makefile b/arch/arm/mach-socfpga/Makefile
index 1ada39d..4e31896 100644
--- a/arch/arm/mach-socfpga/Makefile
+++ b/arch/arm/mach-socfpga/Makefile
@@ -6,3 +6,4 @@ obj-y					:= socfpga.o
 obj-$(CONFIG_SMP)	+= headsmp.o platsmp.o
 obj-$(CONFIG_HW_PERF_EVENTS) += socfpga_cti.o
 obj-$(CONFIG_FPGADMA)	+= fpga-dma.o
+obj-$(CONFIG_EDAC_ALTERA_OCRAM_ECC) += ocram.o
diff --git a/arch/arm/mach-socfpga/ocram.c b/arch/arm/mach-socfpga/ocram.c
new file mode 100644
index 0000000..24d60c2
--- /dev/null
+++ b/arch/arm/mach-socfpga/ocram.c
@@ -0,0 +1,85 @@
+/*
+ *  Copyright (C) 2014 Altera Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/clk-provider.h>
+#include <linux/genalloc.h>
+#include <linux/of_platform.h>
+
+void socfpga_init_ocram_ecc(void)
+{
+	struct device_node *np;
+	const __be32 *prop;
+	u32 ocr_edac_addr, iram_addr, len;
+	void __iomem  *mapped_ocr_edac_addr;
+	size_t size;
+	struct gen_pool *gp;
+
+	np = of_find_compatible_node(NULL, NULL, "altr,ocram-edac");
+	if (!np) {
+		pr_err("SOCFPGA: Unable to find altr,ocram-edac in dtb\n");
+		return;
+	}
+
+	prop = of_get_property(np, "reg", &size);
+	ocr_edac_addr = be32_to_cpup(prop++);
+	len = be32_to_cpup(prop);
+	if (!prop || size < sizeof(*prop)) {
+		pr_err("SOCFPGA: Unable to find OCRAM ECC mapping in dtb\n");
+		return;
+	}
+
+	gp = of_get_named_gen_pool(np, "iram", 0);
+	if (!gp) {
+		pr_err("SOCFPGA: OCRAM cannot find gen pool\n");
+		return;
+	}
+
+	np = of_find_compatible_node(NULL, NULL, "mmio-sram");
+	if (!np) {
+		pr_err("SOCFPGA: Unable to find mmio-sram in dtb\n");
+		return;
+	}
+	/* Determine the OCRAM address and size */
+	prop = of_get_property(np, "reg", &size);
+	iram_addr = be32_to_cpup(prop++);
+	len = be32_to_cpup(prop);
+
+	if (!prop || size < sizeof(*prop)) {
+		pr_err("SOCFPGA: Unable to find OCRAM mapping in dtb\n");
+		return;
+	}
+
+	iram_addr = gen_pool_alloc(gp, len);
+	if (iram_addr == 0) {
+		pr_err("SOCFPGA: cannot alloc from gen pool\n");
+		return;
+	}
+
+	memset((void *)iram_addr, 0, len);
+
+	mapped_ocr_edac_addr = ioremap(ocr_edac_addr, 4);
+
+	gen_pool_free(gp, iram_addr, len);
+
+	/* Clear any pending OCRAM ECC interrupts, then enable ECC */
+	writel(0x18, mapped_ocr_edac_addr);
+	writel(0x19, mapped_ocr_edac_addr);
+
+	pr_alert("SOCFPGA: Success Initializing OCRAM");
+
+	return;
+}
+
diff --git a/arch/arm/mach-socfpga/ocram.h b/arch/arm/mach-socfpga/ocram.h
new file mode 100644
index 0000000..3c6eb69
--- /dev/null
+++ b/arch/arm/mach-socfpga/ocram.h
@@ -0,0 +1,30 @@
+/*
+ *  arch/arm/mach-socfpga/ocram.h
+ *
+ * Copyright (C) 2014 Altera Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MACH_SOCFPGA_OCRAM_H
+#define MACH_SOCFPGA_OCRAM_H
+
+#ifdef CONFIG_EDAC_ALTERA_OCRAM_ECC
+void socfpga_init_ocram_ecc(void);
+#else
+inline void socfpga_init_ocram_ecc(void)
+{
+}
+#endif
+
+#endif /* #ifndef MACH_SOCFPGA_OCRAM_H */
diff --git a/arch/arm/mach-socfpga/socfpga.c b/arch/arm/mach-socfpga/socfpga.c
index 62bba42..3d1bd6a 100644
--- a/arch/arm/mach-socfpga/socfpga.c
+++ b/arch/arm/mach-socfpga/socfpga.c
@@ -30,6 +30,7 @@
 
 #include "core.h"
 #include "socfpga_cti.h"
+#include "ocram.h"
 
 void __iomem *socfpga_scu_base_addr = ((void __iomem *)(SOCFPGA_SCU_VIRT_BASE));
 void __iomem *sys_manager_base_addr;
@@ -215,6 +216,7 @@ static void __init socfpga_cyclone5_init(void)
 				socfpga_auxdata_lookup, NULL);
 	enable_periphs();
 	socfpga_soc_device_init();
+	socfpga_init_ocram_ecc();
 }
 
 static const char *altera_dt_match[] = {
diff --git a/drivers/edac/Kconfig b/drivers/edac/Kconfig
index a5f8fbc..d8cf2c4 100644
--- a/drivers/edac/Kconfig
+++ b/drivers/edac/Kconfig
@@ -410,4 +410,11 @@ config EDAC_ALTERA_L2_ECC
 	  the L2 memory & enable the L2 ECC before loading
 	  the kernel.
 
+config EDAC_ALTERA_OCRAM_ECC
+	bool "Altera On-Chip RAM EDAC"
+	depends on EDAC_ALTERA_ECC_MGR
+	help
+	  Support for error detection and correction on the
+	  Altera On-Chip RAM Memory.
+
 endif # EDAC
diff --git a/drivers/edac/altera_ecc_mgr_edac.c b/drivers/edac/altera_ecc_mgr_edac.c
index c083b60..851ce2a 100644
--- a/drivers/edac/altera_ecc_mgr_edac.c
+++ b/drivers/edac/altera_ecc_mgr_edac.c
@@ -42,8 +42,16 @@
 #define ALTR_L2_ECC_INJS_MASK		0x00000002
 #define ALTR_L2_ECC_INJD_MASK		0x00000004
 
+/* OCRAM ECC Management Group Defines */
+#define ALTR_MAN_GRP_OCRAM_ECC_OFFSET	0x04
+#define ALTR_OCR_ECC_EN_MASK		0x00000001
+#define ALTR_OCR_ECC_SERR_MASK		0x00000008
+#define ALTR_OCR_ECC_DERR_MASK		0x00000010
+
 struct ecc_mgr_of_data {
 	int (*setup)(struct platform_device *pdev, void __iomem *base);
+	int ce_clear_mask;
+	int ue_clear_mask;
 };
 
 struct altr_ecc_mgr_dev {
@@ -59,9 +67,14 @@ static irqreturn_t altr_ecc_mgr_handler(int irq, void *dev_id)
 	struct edac_device_ctl_info *dci = dev_id;
 	struct altr_ecc_mgr_dev *drvdata = dci->pvt_info;
 
-	if (irq == drvdata->sb_irq)
+	if (irq == drvdata->sb_irq) {
+		if (drvdata->data->ce_clear_mask)
+			writel(drvdata->data->ce_clear_mask, drvdata->base);
 		edac_device_handle_ce(dci, 0, 0, drvdata->edac_dev_name);
+	}
 	if (irq == drvdata->db_irq) {
+		if (drvdata->data->ue_clear_mask)
+			writel(drvdata->data->ue_clear_mask, drvdata->base);
 		edac_device_handle_ue(dci, 0, 0, drvdata->edac_dev_name);
 		panic("\nEDAC:ECC_MGR[Uncorrectable errors]\n");
 	}
@@ -193,12 +206,22 @@ static int altr_l2_dependencies(struct platform_device *pdev,
 
 static const struct ecc_mgr_of_data l2ecc_data = {
 	.setup = altr_l2_dependencies,
+	.ce_clear_mask = 0,
+	.ue_clear_mask = 0,
+};
+
+static const struct ecc_mgr_of_data ocramecc_data = {
+	.ce_clear_mask = (ALTR_OCR_ECC_EN_MASK | ALTR_OCR_ECC_SERR_MASK),
+	.ue_clear_mask = (ALTR_OCR_ECC_EN_MASK | ALTR_OCR_ECC_DERR_MASK),
 };
 
 static const struct of_device_id altr_ecc_mgr_of_match[] = {
 #ifdef CONFIG_EDAC_ALTERA_L2_ECC
 	{ .compatible = "altr,l2-edac", .data = (void *)&l2ecc_data },
 #endif
+#ifdef CONFIG_EDAC_ALTERA_OCRAM_ECC
+	{ .compatible = "altr,ocram-edac", .data = (void *)&ocramecc_data },
+#endif
 	{},
 };
 
@@ -218,9 +241,10 @@ static int altr_ecc_mgr_probe(struct platform_device *pdev)
 	int res = 0;
 	struct device_node *np = pdev->dev.of_node;
 	char *ecc_name = (char *)np->name;
+	static int dev_instance;
 
-	dci = edac_device_alloc_ctl_info(sizeof(*drvdata), "ecc",
-			1, ecc_name, 1, 0, NULL, 0, 0);
+	dci = edac_device_alloc_ctl_info(sizeof(*drvdata), ecc_name,
+			1, ecc_name, 1, 0, NULL, 0, dev_instance++);
 
 	if (!dci)
 		return -ENOMEM;
@@ -321,4 +345,4 @@ module_platform_driver(altr_ecc_mgr_driver);
 
 MODULE_LICENSE("GPL v2");
 MODULE_AUTHOR("Altera Corporation");
-MODULE_DESCRIPTION("EDAC Driver for Altera SoC L2 Cache");
+MODULE_DESCRIPTION("EDAC Driver for Altera SoC ECC Manager");
-- 
1.9.1

