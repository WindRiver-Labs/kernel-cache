From f9862c8d544b0bbd8454b160e697fb5e3ce5a3b3 Mon Sep 17 00:00:00 2001
From: Yang Wei <Wei.Yang@windriver.com>
Date: Fri, 30 May 2014 14:23:44 +0800
Subject: [PATCH 3/6] pci:drivers:altera-msi: Use a cascade irq handler
 instead of registering irq action handler

In RT kernel, the irq action handler is threaded, it also means that the
irq handler is executed with irq enabled. Accordingly if we invokes in
generic_handle_irq to handle these cascade msi irqs. it would trigger the
following calltrace. In order to fix it, the more reasonable way is that
we define a cascade irq handler instead of resgistering irq action handler,
just like that freescale handles msi irq.

Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/pci/host/pci-altera-msi.c |   33 +++++++++++++++++++++++----------
 1 files changed, 23 insertions(+), 10 deletions(-)

diff --git a/drivers/pci/host/pci-altera-msi.c b/drivers/pci/host/pci-altera-msi.c
index ef7496e..3e55169 100644
--- a/drivers/pci/host/pci-altera-msi.c
+++ b/drivers/pci/host/pci-altera-msi.c
@@ -18,8 +18,10 @@
 #include <linux/pci.h>
 #include <linux/interrupt.h>
 #include <linux/of_irq.h>
+#include <asm/mach/irq.h>
 #include <linux/of_address.h>
 #include <linux/platform_device.h>
+#include <linux/irqchip/chained_irq.h>
 #include <linux/msi.h>
 #include "pci-altera.h"
 
@@ -77,14 +79,24 @@ static void altera_pci_msi_irq_free(struct altera_pci_msi *msi,
 	mutex_unlock(&msi->lock);
 }
 
-static irqreturn_t altera_pci_msi_isr(int irq, void *data)
+static void altera_pci_msi_cascade(unsigned int irq, struct irq_desc *desc)
 {
-	struct altera_pci_msi *msi = data;
+	struct altera_pci_msi *msi = irq_get_handler_data(irq);
+	struct irq_chip *chip = irq_get_chip(irq);
+	struct irq_data *idata = irq_desc_get_irq_data(desc);
 	unsigned long status;
 	u32 num_of_vectors = msi->num_of_vectors;
 	u32 processed = 0;
 	u32 offset;
 
+	raw_spin_lock(&desc->lock);
+
+	if (unlikely(irqd_irq_inprogress(idata)))
+			goto unlock;
+
+	irqd_set_chained_irq_inprogress(idata);
+	chained_irq_enter(chip, desc);
+
 	do {
 		status = msi_readl(msi, MSI_STATUS);
 		if (!status)
@@ -95,7 +107,7 @@ static irqreturn_t altera_pci_msi_isr(int irq, void *data)
 			/* Dummy read from vector to clear the interrupt */
 			readl(msi->vector_base + (offset * sizeof(u32)));
 
-			irq = irq_find_mapping(msi->domain, offset);
+			irq = irq_linear_revmap(msi->domain, offset);
 			if (irq) {
 				if (test_bit(offset, msi->used))
 					generic_handle_irq(irq);
@@ -108,7 +120,12 @@ static irqreturn_t altera_pci_msi_isr(int irq, void *data)
 		} while (status);
 	} while (1);
 
-	return processed > 0 ? IRQ_HANDLED : IRQ_NONE;
+	irqd_clr_chained_irq_inprogress(idata);
+	chained_irq_exit(chip, desc);
+
+unlock:
+	raw_spin_unlock(&desc->lock);
+	return;
 }
 
 static struct irq_chip altera_pci_msi_irq_chip = {
@@ -185,12 +202,8 @@ int altera_pci_msi_probe(struct platform_device *pdev)
 		goto err;
 	}
 
-	ret = devm_request_irq(&pdev->dev, msi->irq, altera_pci_msi_isr, 0,
-				altera_pci_msi_irq_chip.name, msi);
-	if (ret) {
-		dev_err(&pdev->dev, "failed to request IRQ: %d\n", ret);
-		goto err;
-	}
+	irq_set_handler_data(msi->irq, msi);
+	irq_set_chained_handler(msi->irq, altera_pci_msi_cascade);
 
 	spin_lock(&list_lock);
 	list_add_tail(&msi->list, &msi_list);
-- 
1.7.5.4

