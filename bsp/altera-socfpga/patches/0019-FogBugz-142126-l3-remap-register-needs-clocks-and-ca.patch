From f570057b44caae6c15eb9bb729621478f8f892df Mon Sep 17 00:00:00 2001
From: Alan Tull <atull@altera.com>
Date: Wed, 31 Jul 2013 09:35:54 -0500
Subject: [PATCH 019/172] FogBugz #142126: l3 remap register needs clocks and
 caching

* Add clock so that we can reliably write to L3 remap register.

* The L3 remap register is write only.  So keep a cached copy
  of what we write to it.

* Remove confusing 'enable' device tree property.  This was
  intended for future support of dynamic device trees and
  is causing more trouble than is worth in the present moment.

Signed-off-by: Alan Tull <atull@altera.com>

V2:
 * Removed 'enable' device tree property.
[czou:Original patch taken from
https://github.com/altera-opensource/linux-socfpga.git socfpga-4.1]
Signed-off-by: czou <cao.zou@windriver.com>
---
 .../bindings/fpga/altera-fpga-bridge.txt           | 13 +++----
 arch/arm/boot/dts/socfpga.dtsi                     |  3 ++
 drivers/misc/fpga-bridge/altera-hps2fpga.c         | 44 ++++++++++++++++------
 drivers/misc/fpga-bridge/fpga-bridge.c             |  5 +--
 4 files changed, 42 insertions(+), 23 deletions(-)

diff --git a/Documentation/devicetree/bindings/fpga/altera-fpga-bridge.txt b/Documentation/devicetree/bindings/fpga/altera-fpga-bridge.txt
index 60960a9..569d898 100644
--- a/Documentation/devicetree/bindings/fpga/altera-fpga-bridge.txt
+++ b/Documentation/devicetree/bindings/fpga/altera-fpga-bridge.txt
@@ -15,30 +15,30 @@ Required for fpga2sdram bridge only:
                     index 0 is first port # (0-5)
 		    index 1 is number of ports used (1-2)
 
+Required for hps2fpga, lwhps2fpga, and fpga2hps:
+  - clocks     : clocks used by this module
+
 Optional properties:
   - label      : name that you want this bridge to show up as under /sys
                  Default is br<device#> if this is not specified
 
-  - enable     : If 'enable' is specified, the bridge will be enabled or
-                 disabled upon load, depending on the value of this parameter.
-		 if 'enable' is not specified, the driver will not enable
-		 or disable the bridge by default.
-
 Example:
 	hps_fpgabridge0: fpgabridge@0 {
 		compatible = "altr,socfpga-hps2fpga-bridge";
 		label = "hps2fpga";
-		enable = <1>;
+		clocks = <&l4_main_clk>;
 	};
 
 	hps_fpgabridge1: fpgabridge@1 {
 		compatible = "altr,socfpga-lwhps2fpga-bridge";
 		label = "lwhps2fpga";
+		clocks = <&l4_main_clk>;
 	};
 
 	hps_fpgabridge2: fpgabridge@2 {
 		compatible = "altr,socfpga-fpga2hps-bridge";
 		label = "fpga2hps";
+		clocks = <&l4_main_clk>;
 	};
 
 	hps_fpgabridge3: fpgabridge@3 {
@@ -47,7 +47,6 @@ Example:
 		read-port = <0>;
 		write-port = <0>;
 		control-ports = <0 2>; /* ports 0 and 1 */
-		enable = <1>;
 	};
 
 	hps_fpgabridge4: fpgabridge@4 {
diff --git a/arch/arm/boot/dts/socfpga.dtsi b/arch/arm/boot/dts/socfpga.dtsi
index a44bbe2..4a1e88f 100644
--- a/arch/arm/boot/dts/socfpga.dtsi
+++ b/arch/arm/boot/dts/socfpga.dtsi
@@ -518,16 +518,19 @@
 		hps_fpgabridge0: fpgabridge@0 {
 			compatible = "altr,socfpga-hps2fpga-bridge";
 			label = "hps2fpga";
+			clocks = <&l4_main_clk>;
 		};
 
 		hps_fpgabridge1: fpgabridge@1 {
 			compatible = "altr,socfpga-lwhps2fpga-bridge";
 			label = "lwhps2fpga";
+			clocks = <&l4_main_clk>;
 		};
 
 		hps_fpgabridge2: fpgabridge@2 {
 			compatible = "altr,socfpga-fpga2hps-bridge";
 			label = "fpga2hps";
+			clocks = <&l4_main_clk>;
 		};
 
 		i2c0: i2c@ffc04000 {
diff --git a/drivers/misc/fpga-bridge/altera-hps2fpga.c b/drivers/misc/fpga-bridge/altera-hps2fpga.c
index 13af155..4e5dd38 100644
--- a/drivers/misc/fpga-bridge/altera-hps2fpga.c
+++ b/drivers/misc/fpga-bridge/altera-hps2fpga.c
@@ -22,6 +22,7 @@
 #include <linux/of_address.h>
 #include <linux/mfd/syscon.h>
 #include <linux/module.h>
+#include <linux/clk.h>
 #include <linux/io.h>
 #include <linux/err.h>
 #include <linux/regmap.h>
@@ -39,14 +40,17 @@
 
 static struct of_device_id altera_fpga_of_match[];
 
+/* The L3 REMAP register is write only, so keep a cached value. */
+static unsigned int l3_remap_value;
+
 struct altera_hps2fpga_data {
 	char	name[48];
 	struct platform_device *pdev;
 	struct device_node *np;
 	struct regmap *rstreg;
 	struct regmap *l3reg;
-	int mask;
-	int remap_mask;
+	unsigned int reset_mask;
+	unsigned int remap_mask;
 };
 
 static int alt_hps2fpga_enable_show(struct fpga_bridge *bridge)
@@ -56,31 +60,33 @@ static int alt_hps2fpga_enable_show(struct fpga_bridge *bridge)
 
 	regmap_read(priv->rstreg, SOCFPGA_RSTMGR_BRGMODRST, &value);
 
-	return ((value & priv->mask) == 0);
+	return ((value & priv->reset_mask) == 0);
 }
 
 static void alt_hps2fpga_enable_set(struct fpga_bridge *bridge, bool enable)
 {
 	struct altera_hps2fpga_data *priv = bridge->priv;
-	int value;
+	unsigned int value;
 
 	/* bring bridge out of reset */
 	if (enable)
 		value = 0;
 	else
-		value = priv->mask;
+		value = priv->reset_mask;
 
 	regmap_update_bits(priv->rstreg, SOCFPGA_RSTMGR_BRGMODRST,
-			   priv->mask, value);
+			   priv->reset_mask, value);
 
 	/* Allow bridge to be visible to L3 masters or not */
 	if (priv->remap_mask) {
-		value = ALT_L3_REMAP_MPUZERO_MSK;
+		l3_remap_value |= ALT_L3_REMAP_MPUZERO_MSK;
 
 		if (enable)
-			value |= priv->remap_mask;
+			l3_remap_value |= priv->remap_mask;
+		else
+			l3_remap_value &= ~priv->remap_mask;
 
-		regmap_write(priv->l3reg, ALT_L3_REMAP_OFST, value);
+		regmap_write(priv->l3reg, ALT_L3_REMAP_OFST, l3_remap_value);
 	}
 }
 
@@ -91,25 +97,27 @@ struct fpga_bridge_ops altera_hps2fpga_br_ops = {
 
 static struct altera_hps2fpga_data hps2fpga_data  = {
 	.name = "hps2fpga",
-	.mask = ALT_RSTMGR_BRGMODRST_H2F_MSK,
+	.reset_mask = ALT_RSTMGR_BRGMODRST_H2F_MSK,
 	.remap_mask = ALT_L3_REMAP_H2F_MSK,
 };
 
 static struct altera_hps2fpga_data lwhps2fpga_data  = {
 	.name = "lshps2fpga",
-	.mask = ALT_RSTMGR_BRGMODRST_LWH2F_MSK,
+	.reset_mask = ALT_RSTMGR_BRGMODRST_LWH2F_MSK,
 	.remap_mask = ALT_L3_REMAP_LWH2F_MSK,
 };
 
 static struct altera_hps2fpga_data fpga2hps_data  = {
 	.name = "fpga2hps",
-	.mask = ALT_RSTMGR_BRGMODRST_F2H_MSK,
+	.reset_mask = ALT_RSTMGR_BRGMODRST_F2H_MSK,
 };
 
 static int alt_fpga_bridge_probe(struct platform_device *pdev)
 {
 	struct altera_hps2fpga_data *priv;
 	const struct of_device_id *of_id;
+	int rc;
+	struct clk *clk;
 
 	of_id = of_match_device(altera_fpga_of_match, &pdev->dev);
 	priv = (struct altera_hps2fpga_data *)of_id->data;
@@ -132,6 +140,18 @@ static int alt_fpga_bridge_probe(struct platform_device *pdev)
 		return PTR_ERR(priv->l3reg);
 	}
 
+	clk = of_clk_get(pdev->dev.of_node, 0);
+	if (IS_ERR(clk)) {
+		dev_err(&pdev->dev, "no clock specified\n");
+		return PTR_ERR(clk);
+	}
+
+	rc = clk_prepare_enable(clk);
+	if (rc) {
+		dev_err(&pdev->dev, "could not enable clock\n");
+		return -EBUSY;
+	}
+
 	return register_fpga_bridge(pdev, &altera_hps2fpga_br_ops,
 				    priv->name, priv);
 }
diff --git a/drivers/misc/fpga-bridge/fpga-bridge.c b/drivers/misc/fpga-bridge/fpga-bridge.c
index a8fd7a1..96bf4e4 100644
--- a/drivers/misc/fpga-bridge/fpga-bridge.c
+++ b/drivers/misc/fpga-bridge/fpga-bridge.c
@@ -131,7 +131,7 @@ int register_fpga_bridge(struct platform_device *pdev,
 {
 	struct fpga_bridge *bridge;
 	const char *dt_label;
-	int enable, ret;
+	int ret;
 
 	if (!br_ops || !br_ops->enable_set || !br_ops->enable_show) {
 		dev_err(&pdev->dev,
@@ -173,9 +173,6 @@ int register_fpga_bridge(struct platform_device *pdev,
 		goto error_device;
 	}
 
-	if (!of_property_read_u32(bridge->np, "enable", &enable))
-		br_ops->enable_set(bridge, enable);
-
 	dev_info(bridge->parent, "fpga bridge [%s] registered as device %s\n",
 		 bridge->name, bridge->label);
 
-- 
1.9.1

