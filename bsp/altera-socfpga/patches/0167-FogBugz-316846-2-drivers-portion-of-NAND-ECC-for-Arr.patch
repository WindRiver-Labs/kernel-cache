From a90b524e00a4b3df10aaa276dd7f16ee9d24dabe Mon Sep 17 00:00:00 2001
From: Dinh Nguyen <dinguyen@opensource.altera.com>
Date: Tue, 11 Aug 2015 14:22:12 -0500
Subject: [PATCH 167/172] FogBugz #316846-2: drivers portion of NAND ECC for
 Arria10

Add the NAND ECC driver.

Signed-off-by: Roman Bulgakov <roman.bulgakov@globallogic.com>
Signed-off-by: Dinh Nguyen <dinguyen@opensource.altera.com>
[czou:Original patch taken from
https://github.com/altera-opensource/linux-socfpga.git socfpga-4.1]
Signed-off-by: czou <cao.zou@windriver.com>
---
 drivers/edac/Kconfig               |  7 ++++++
 drivers/edac/Makefile              |  1 +
 drivers/edac/altera_ecc_mgr_edac.c | 51 ++++++++++++++++++++++++++++++++++++++
 drivers/edac/altera_ecc_nand.c     | 49 ++++++++++++++++++++++++++++++++++++
 drivers/edac/altera_edac.h         | 16 ++++++++++++
 5 files changed, 124 insertions(+)
 create mode 100644 drivers/edac/altera_ecc_nand.c

diff --git a/drivers/edac/Kconfig b/drivers/edac/Kconfig
index d713613..ff01c32 100644
--- a/drivers/edac/Kconfig
+++ b/drivers/edac/Kconfig
@@ -417,4 +417,11 @@ config EDAC_ALTERA_OCRAM_ECC
 	  Support for error detection and correction on the
 	  Altera On-Chip RAM Memory.
 
+config EDAC_ALTERA_NAND_ECC
+	bool "Altera NAND Flash Controller FIFOs EDAC"
+	depends on EDAC_ALTERA_ECC_MGR
+	help
+	  Support for error detection and correction on the
+	  Altera NAND Flash Controller FIFO memories.
+
 endif # EDAC
diff --git a/drivers/edac/Makefile b/drivers/edac/Makefile
index ea51909..bf0f4bf 100644
--- a/drivers/edac/Makefile
+++ b/drivers/edac/Makefile
@@ -70,4 +70,5 @@ obj-$(CONFIG_EDAC_ALTERA_MC)		+= altera_edac.o
 obj-$(CONFIG_EDAC_ALTERA_ECC_MGR)       += altera_ecc_mgr_edac.o
 obj-$(CONFIG_EDAC_ALTERA_L2_ECC)        += altera_ecc_l2.o
 obj-$(CONFIG_EDAC_ALTERA_OCRAM_ECC)     += altera_ecc_ocram.o
+obj-$(CONFIG_EDAC_ALTERA_NAND_ECC)      += altera_ecc_nand.o
 obj-$(CONFIG_EDAC_SYNOPSYS)		+= synopsys_edac.o
diff --git a/drivers/edac/altera_ecc_mgr_edac.c b/drivers/edac/altera_ecc_mgr_edac.c
index 070aad6..715d53f 100644
--- a/drivers/edac/altera_ecc_mgr_edac.c
+++ b/drivers/edac/altera_ecc_mgr_edac.c
@@ -76,7 +76,50 @@ static irqreturn_t altr_ecc_mgr_handler(int irq, void *dev_id)
 	return IRQ_RETVAL(handle_ce | handle_ue);
 }
 
+/*
+ * Test for Arria 10 ECC dependencies upon entry because
+ * the kernel startup code should have initialized the module
+ * memory and enabled the ECC.
+ * Test for ECC is enabled. Fail if ECC is not on.
+ */
+int altr_a10_ecc_dependencies(struct platform_device *pdev, void __iomem *base)
+{
+	u32 control;
+	void __iomem *en_addr = (void __iomem *)((uintptr_t)base +
+						 ALTR_A10_ECC_CTL_OFFSET);
+	int ret = 0;
+
+	control = readl(en_addr) & ALTR_A10_ECC_EN_CTL_MASK;
+	if (!control) {
+		dev_err(&pdev->dev, "No ECC present, or ECC disabled\n");
+		ret = -ENODEV;
+	}
+
+	return ret;
+}
+
 #ifdef CONFIG_EDAC_DEBUG
+/*
+ * User controllable interrupt assertion for test purposes of the
+ * Altera Arria 10 ECC controller.
+ */
+ssize_t altr_a10_ecc_mgr_trig(struct edac_device_ctl_info *edac_dci,
+			      const char *buffer, size_t count)
+{
+	struct altr_ecc_mgr_dev *drvdata = edac_dci->pvt_info;
+	const struct ecc_mgr_prv_data *priv = drvdata->data;
+	void __iomem *set_addr = ecc_set_addr(drvdata);
+	unsigned long flags;
+
+	local_irq_save(flags);
+	writel(priv->ce_set_mask, set_addr);
+	/* Ensure the interrupt test bits are set */
+	wmb();
+	local_irq_restore(flags);
+
+	return count;
+}
+
 ssize_t altr_ecc_mgr_trig(struct edac_device_ctl_info *edac_dci,
 			  const char *buffer, size_t count)
 {
@@ -167,6 +210,14 @@ static const struct of_device_id altr_ecc_mgr_of_match[] = {
 	{ .compatible = "altr,a10-ocram-edac",
 	  .data = (void *)&a10_ocramecc_data },
 #endif
+#ifdef CONFIG_EDAC_ALTERA_NAND_ECC
+	{ .compatible = "altr,a10-nand-buf-edac",
+	  .data = (void *)&a10_nandecc_data },
+	{ .compatible = "altr,a10-nand-rd-edac",
+	  .data = (void *)&a10_nandecc_data },
+	{ .compatible = "altr,a10-nand-wr-edac",
+	  .data = (void *)&a10_nandecc_data },
+#endif
 	{},
 };
 
diff --git a/drivers/edac/altera_ecc_nand.c b/drivers/edac/altera_ecc_nand.c
new file mode 100644
index 0000000..59bd50d
--- /dev/null
+++ b/drivers/edac/altera_ecc_nand.c
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2015 Altera Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "altera_edac.h"
+
+#ifdef CONFIG_EDAC_DEBUG
+static struct edac_dev_sysfs_attribute altr_a10_nand_sysfs_attributes[] = {
+	{
+		.attr = { .name = "altr_nand_trigger",
+			  .mode = (S_IRUGO | S_IWUSR) },
+		.show = NULL,
+		.store = altr_a10_ecc_mgr_trig
+	},
+	{
+		.attr = { .name = NULL }
+	}
+};
+#endif	/* #ifdef CONFIG_EDAC_DEBUG */
+
+const struct ecc_mgr_prv_data a10_nandecc_data = {
+	.setup = altr_a10_ecc_dependencies,
+	.ce_clear_mask = ALTR_A10_ECC_CEA_INTSTAT_MASK,
+	.ue_clear_mask = ALTR_A10_ECC_UEA_INTSTAT_MASK,
+	.clear_mask_offs = ALTR_A10_ECC_INTSTAT_OFFSET,
+	.ce_status_mask = ALTR_A10_ECC_CEA_INTSTAT_MASK,
+	.ue_status_mask = ALTR_A10_ECC_UEA_INTSTAT_MASK,
+	.status_mask_offs = ALTR_A10_ECC_INTSTAT_OFFSET,
+#ifdef CONFIG_EDAC_DEBUG
+	.eccmgr_sysfs_attr = altr_a10_nand_sysfs_attributes,
+	.ecc_enable_mask = ALTR_A10_ECC_EN_CTL_MASK,
+	.enable_mask_offs = ALTR_A10_ECC_CTL_OFFSET,
+	.ce_set_mask = ALTR_A10_ECC_CEA_INTTEST_MASK,
+	.ue_set_mask = ALTR_A10_ECC_UEA_INTTEST_MASK,
+	.set_mask_offs = ALTR_A10_ECC_INTTEST_OFFSET,
+#endif
+};
diff --git a/drivers/edac/altera_edac.h b/drivers/edac/altera_edac.h
index d523553..39b0515 100644
--- a/drivers/edac/altera_edac.h
+++ b/drivers/edac/altera_edac.h
@@ -166,6 +166,18 @@
 #define A10_INTMASK_CLR_OFST       0x10
 #define A10_DDR0_IRQ_MASK          BIT(17)
 
+/* Altera Arria 10 ECC Controller Management Group Defines */
+#define ALTR_A10_ECC_CTL_OFFSET		0x08
+#define ALTR_A10_ECC_EN_CTL_MASK	BIT(0)
+
+#define ALTR_A10_ECC_INTSTAT_OFFSET	0x20
+#define ALTR_A10_ECC_CEA_INTSTAT_MASK	BIT(0)
+#define ALTR_A10_ECC_UEA_INTSTAT_MASK	BIT(8)
+
+#define ALTR_A10_ECC_INTTEST_OFFSET	0x24
+#define ALTR_A10_ECC_CEA_INTTEST_MASK	BIT(0)
+#define ALTR_A10_ECC_UEA_INTTEST_MASK	BIT(8)
+
 struct altr_sdram_prv_data {
 	int ecc_ctrl_offset;
 	int ecc_ctl_en_mask;
@@ -232,9 +244,13 @@ extern const struct ecc_mgr_prv_data l2ecc_data;
 extern const struct ecc_mgr_prv_data a10_l2ecc_data;
 extern const struct ecc_mgr_prv_data ocramecc_data;
 extern const struct ecc_mgr_prv_data a10_ocramecc_data;
+extern const struct ecc_mgr_prv_data a10_nandecc_data;
 
 ssize_t altr_ecc_mgr_trig(struct edac_device_ctl_info *edac_dci,
 			  const char *buffer, size_t count);
+ssize_t altr_a10_ecc_mgr_trig(struct edac_device_ctl_info *edac_dci,
+			      const char *buffer, size_t count);
+int altr_a10_ecc_dependencies(struct platform_device *pdev, void __iomem *base);
 
 static inline void __iomem *ecc_clear_addr(const struct altr_ecc_mgr_dev *dev)
 {
-- 
1.9.1

