From d60f681becabda4d24bb47f23945a9509d44ff25 Mon Sep 17 00:00:00 2001
From: Thor Thayer <tthayer@opensource.altera.com>
Date: Mon, 22 Dec 2014 10:21:43 -0600
Subject: [PATCH 100/172] gpio: Altera Arria10 System Controller - GPIO

This patch adds the GPIO functionality the Arria10 System Controller.
The GPIO framework is used by other frameworks (keys and LEDs).

Signed-off-by: Thor Thayer <tthayer@opensource.altera.com>
[czou:Original patch taken from
https://github.com/altera-opensource/linux-socfpga.git socfpga-4.1]
Signed-off-by: czou <cao.zou@windriver.com>

Conflicts:
	drivers/gpio/Makefile
---
 drivers/gpio/Kconfig         |   8 +++
 drivers/gpio/Makefile        |   1 +
 drivers/gpio/gpio-a10sycon.c | 162 ++++++++++++++++++++++++++++++++++++++++++
 drivers/mfd/Makefile         |   4 +-
 drivers/mfd/a10sycon-core.c  |  11 +++
 drivers/mfd/a10sycon-irq.c   | 165 +++++++++++++++++++++++++++++++++++++++++++
 6 files changed, 349 insertions(+), 2 deletions(-)
 create mode 100644 drivers/gpio/gpio-a10sycon.c
 create mode 100644 drivers/mfd/a10sycon-irq.c

diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index caefe80..876dd2a 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -970,6 +970,14 @@ config GPIO_MC33880
 	  SPI driver for Freescale MC33880 high-side/low-side switch.
 	  This provides GPIO interface supporting inputs and outputs.
 
+config GPIO_A10SYCON
+	tristate "Altera Arria10 System Controller GPIO"
+	depends on ARCH_SOCFPGA
+	select MFD_A10SYCON
+	help
+	  Driver for Arria10 GPIO expansion which includes reads of
+	  pushbuttons and DIP switches as well as writes to LEDs and
+	  peripheral reset.
 endmenu
 
 menu "USB GPIO expanders"
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index f71bb97..c8ba12b 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -14,6 +14,7 @@ obj-$(CONFIG_GPIO_GENERIC)	+= gpio-generic.o
 
 obj-$(CONFIG_GPIO_74X164)	+= gpio-74x164.o
 obj-$(CONFIG_GPIO_74XX_MMIO)	+= gpio-74xx-mmio.o
+obj-$(CONFIG_GPIO_A10SYCON)	+= gpio-a10sycon.o
 obj-$(CONFIG_GPIO_ADNP)		+= gpio-adnp.o
 obj-$(CONFIG_GPIO_ADP5520)	+= gpio-adp5520.o
 obj-$(CONFIG_GPIO_ADP5588)	+= gpio-adp5588.o
diff --git a/drivers/gpio/gpio-a10sycon.c b/drivers/gpio/gpio-a10sycon.c
new file mode 100644
index 0000000..bd913f7
--- /dev/null
+++ b/drivers/gpio/gpio-a10sycon.c
@@ -0,0 +1,162 @@
+/*
+ *  Copyright (C) 2014 Altera Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * GPIO driver for Altera MAX5 Arria10 System Control
+ * Adapted from DA9052
+ */
+
+#include <linux/fs.h>
+#include <linux/gpio.h>
+#include <linux/mfd/a10sycon.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/seq_file.h>
+#include <linux/syscalls.h>
+#include <linux/uaccess.h>
+
+struct a10sycon_gpio {
+	struct a10sycon *a10sc;
+	struct gpio_chip gp;
+};
+
+static inline struct a10sycon_gpio *to_a10sycon_gpio(struct gpio_chip *chip)
+{
+	return container_of(chip, struct a10sycon_gpio, gp);
+}
+
+static int a10sycon_gpio_get(struct gpio_chip *gc, unsigned nr)
+{
+	struct a10sycon_gpio *gpio = to_a10sycon_gpio(gc);
+	int ret;
+
+	ret = a10sycon_reg_read(gpio->a10sc,
+				A10SYCON_REG_OFFSET(nr >> 1));
+	if (ret < 0)
+		return ret;
+
+	if (ret & (1 << A10SYCON_REG_BIT(nr)))
+		return 1;
+
+	return 0;
+}
+
+static void a10sycon_gpio_set(struct gpio_chip *gc, unsigned nr, int value)
+{
+	struct a10sycon_gpio *gpio = to_a10sycon_gpio(gc);
+	int ret;
+	unsigned char reg = A10SYCON_LED_WR_REG + A10SYCON_REG_OFFSET(nr);
+
+	ret = a10sycon_reg_update(gpio->a10sc, reg,
+				  A10SYCON_REG_BIT_MASK(nr),
+				  A10SYCON_REG_BIT_CHG(value, nr));
+	if (ret != 0)
+		dev_err(gpio->a10sc->dev,
+			"Failed to update gpio reg : %d", ret);
+}
+
+static int a10sycon_gpio_direction_input(struct gpio_chip *gc, unsigned nr)
+{
+	if ((nr >= A10SC_IN_VALID_RANGE_LO) &&
+	    (nr <= A10SC_IN_VALID_RANGE_HI))
+		return 0;
+	return -EINVAL;
+}
+
+static int a10sycon_gpio_direction_output(struct gpio_chip *gc,
+					  unsigned nr, int value)
+{
+	if ((nr >= A10SC_OUT_VALID_RANGE_LO) &&
+	    (nr <= A10SC_OUT_VALID_RANGE_HI))
+		return 0;
+	return -EINVAL;
+}
+
+static int a10sycon_gpio_to_irq(struct gpio_chip *gc, u32 nr)
+{
+	struct a10sycon_gpio *gpio = to_a10sycon_gpio(gc);
+
+	nr -= A10SC_IN_VALID_RANGE_LO;
+
+	return a10sycon_map_irq(gpio->a10sc, nr);
+}
+
+static struct gpio_chip a10sycon_gc = {
+	.label = "a10sycon-gpio",
+	.owner = THIS_MODULE,
+	.get = a10sycon_gpio_get,
+	.set = a10sycon_gpio_set,
+	.direction_input = a10sycon_gpio_direction_input,
+	.direction_output = a10sycon_gpio_direction_output,
+	.to_irq =  a10sycon_gpio_to_irq,
+	.can_sleep = true,
+	.ngpio = 16,
+	.base = -1,
+};
+
+static const struct of_device_id a10sycon_gpio_of_match[];
+
+static int a10sycon_gpio_probe(struct platform_device *pdev)
+{
+	struct a10sycon_gpio *gpio;
+	int ret;
+
+	gpio = devm_kzalloc(&pdev->dev, sizeof(*gpio), GFP_KERNEL);
+	if (gpio == NULL)
+		return -ENOMEM;
+
+	gpio->a10sc = dev_get_drvdata(pdev->dev.parent);
+
+	gpio->gp = a10sycon_gc;
+
+	gpio->gp.of_node = pdev->dev.of_node;
+
+	ret = gpiochip_add(&gpio->gp);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Could not register gpiochip, %d\n", ret);
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, gpio);
+
+	return 0;
+}
+
+static int a10sycon_gpio_remove(struct platform_device *pdev)
+{
+	struct a10sycon_gpio *gpio = platform_get_drvdata(pdev);
+
+	return gpiochip_remove(&gpio->gp);
+}
+
+static const struct of_device_id a10sycon_gpio_of_match[] = {
+	{ .compatible = "altr,a10sycon-gpio" },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, a10sycon_gpio_of_match);
+
+static struct platform_driver a10sycon_gpio_driver = {
+	.probe = a10sycon_gpio_probe,
+	.remove = a10sycon_gpio_remove,
+	.driver = {
+		.name	= "a10sycon-gpio",
+		.of_match_table = a10sycon_gpio_of_match,
+	},
+};
+
+module_platform_driver(a10sycon_gpio_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Thor Thayer");
+MODULE_DESCRIPTION("Altera Arria10 System Control Chip GPIO");
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index 421e265..fa42717 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -186,5 +186,5 @@ intel-soc-pmic-objs		:= intel_soc_pmic_core.o intel_soc_pmic_crc.o
 obj-$(CONFIG_INTEL_SOC_PMIC)	+= intel-soc-pmic.o
 obj-$(CONFIG_MFD_MT6397)	+= mt6397-core.o
 
-a10sycon-objs          := a10sycon-core.o a10sycon-spi.o
-obj-$(CONFIG_MFD_A10SYCON)     += a10sycon.o
+a10sycon-objs		:= a10sycon-core.o a10sycon-spi.o a10sycon-irq.o
+obj-$(CONFIG_MFD_A10SYCON)	+= a10sycon.o
diff --git a/drivers/mfd/a10sycon-core.c b/drivers/mfd/a10sycon-core.c
index fc53c85..24fa03c 100644
--- a/drivers/mfd/a10sycon-core.c
+++ b/drivers/mfd/a10sycon-core.c
@@ -106,9 +106,20 @@ int a10sycon_device_init(struct a10sycon *a10sc)
 
 	init_completion(&a10sc->done);
 
+	ret = a10sycon_irq_init(a10sc);
+	if (ret != 0) {
+		dev_err(a10sc->dev, "a10sycon_irq_init failed: %d\n", ret);
+		return ret;
+	}
+
 	return 0;
 }
 
+void a10sycon_device_exit(struct a10sycon *a10sc)
+{
+	a10sycon_irq_exit(a10sc);
+}
+
 MODULE_LICENSE("GPL v2");
 MODULE_AUTHOR("Thor Thayer");
 MODULE_DESCRIPTION("Altera Arria10 System Control Chip");
diff --git a/drivers/mfd/a10sycon-irq.c b/drivers/mfd/a10sycon-irq.c
new file mode 100644
index 0000000..bffb6f5
--- /dev/null
+++ b/drivers/mfd/a10sycon-irq.c
@@ -0,0 +1,165 @@
+/*
+ *  Copyright (C) 2014 Altera Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * IRQ support for Altera MAX5 Arria10 System Control
+ * Adapted from DA9052
+ */
+
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/mfd/a10sycon.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+
+#define A10SYCON_NUM_IRQ_REGS		1
+
+static struct regmap_irq a10sycon_irqs[] = {
+	[0] = {
+		.reg_offset = 0,
+		.mask = BIT(A10SC_IRQ_DSW_O_SHIFT),
+	},
+	[1] = {
+		.reg_offset = 0,
+		.mask = BIT(A10SC_IRQ_DSW_1_SHIFT),
+	},
+	[2] = {
+		.reg_offset = 0,
+		.mask = BIT(A10SC_IRQ_DSW_2_SHIFT),
+	},
+	[3] = {
+		.reg_offset = 0,
+		.mask = BIT(A10SC_IRQ_DSW_3_SHIFT),
+	},
+	[4] = {
+		.reg_offset = 0,
+		.mask = BIT(A10SC_IRQ_PB_0_SHIFT),
+	},
+	[5] = {
+		.reg_offset = 0,
+		.mask = BIT(A10SC_IRQ_PB_1_SHIFT),
+	},
+	[6] = {
+		.reg_offset = 0,
+		.mask = BIT(A10SC_IRQ_PB_2_SHIFT),
+	},
+	[7] = {
+		.reg_offset = 0,
+		.mask = BIT(A10SC_IRQ_PB_3_SHIFT),
+	},
+};
+
+static struct regmap_irq_chip a10sycon_regmap_irq_chip = {
+	.name = "a10sycon_irq",
+	.status_base = A10SYCON_PBDSW_IRQ_RD_REG,
+	.mask_base   = A10SYCON_PBDSW_CLR_REG,
+	.ack_base    = A10SYCON_PBDSW_CLR_REG,
+	.num_regs    = A10SYCON_NUM_IRQ_REGS,
+	.irqs        = a10sycon_irqs,
+	.num_irqs    = ARRAY_SIZE(a10sycon_irqs),
+};
+
+int a10sycon_map_irq(struct a10sycon *a10sc, int irq)
+{
+	return regmap_irq_get_virq(a10sc->irq_data, irq);
+}
+EXPORT_SYMBOL_GPL(a10sycon_map_irq);
+
+int a10sycon_enable_irq(struct a10sycon *a10sc, int irq)
+{
+	irq = a10sycon_map_irq(a10sc, irq);
+	if (irq < 0)
+		return irq;
+
+	enable_irq(irq);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(a10sycon_enable_irq);
+
+int a10sycon_disable_irq(struct a10sycon *a10sc, int irq)
+{
+	irq = a10sycon_map_irq(a10sc, irq);
+	if (irq < 0)
+		return irq;
+
+	disable_irq(irq);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(a10sycon_disable_irq);
+
+int a10sycon_disable_irq_nosync(struct a10sycon *a10sc, int irq)
+{
+	irq = a10sycon_map_irq(a10sc, irq);
+	if (irq < 0)
+		return irq;
+
+	disable_irq_nosync(irq);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(a10sycon_disable_irq_nosync);
+
+int a10sycon_request_irq(struct a10sycon *a10sc, int irq, const char *name,
+			 irq_handler_t handler, void *data)
+{
+	irq = a10sycon_map_irq(a10sc, irq);
+	if (irq < 0)
+		return irq;
+
+	return request_threaded_irq(irq, NULL, handler,
+				     IRQF_TRIGGER_LOW | IRQF_ONESHOT,
+				     name, data);
+}
+EXPORT_SYMBOL_GPL(a10sycon_request_irq);
+
+void a10sycon_free_irq(struct a10sycon *a10sc, int irq, void *data)
+{
+	irq = a10sycon_map_irq(a10sc, irq);
+	if (irq < 0)
+		return;
+
+	free_irq(irq, data);
+}
+EXPORT_SYMBOL_GPL(a10sycon_free_irq);
+
+int a10sycon_irq_init(struct a10sycon *a10sc)
+{
+	int ret;
+
+	ret = regmap_add_irq_chip(a10sc->regmap, a10sc->chip_irq,
+				  IRQF_TRIGGER_LOW | IRQF_ONESHOT | IRQF_SHARED,
+				  -1, &a10sycon_regmap_irq_chip,
+				  &a10sc->irq_data);
+
+	if (ret < 0) {
+		dev_err(a10sc->dev, "regmap_add_irq_chip err: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+int a10sycon_irq_exit(struct a10sycon *a10sc)
+{
+	regmap_del_irq_chip(a10sc->chip_irq, a10sc->irq_data);
+
+	return 0;
+}
-- 
1.9.1

