From 132fdb480fdd7e303fc2d3291e0216d14c07cf90 Mon Sep 17 00:00:00 2001
From: Alan Tull <atull@altera.com>
Date: Tue, 15 Jan 2013 15:28:52 -0600
Subject: [PATCH 014/172] FogBugz #92330-1: fpga manager framework

Add a class driver for supporting FPGA managers.

This class supports multiple FPGAs, providing a standard ops for
them.  Various manufacturor's families of FPGAs can be supported
by adding drivers to the fpga-mgrs/ folder.  Each driver needs
to register its ops using register_fpga_manager().

FPGA managers will show up as char devices in the sysfs
class /sys/class/fpga and as /dev/fpga* devnodes.

To get a FPGA's status:
 cat /sys/class/fpga/fpag0/status

To program a FPGA:
 cat bitstream-file > /dev/fpga0

Signed-off-by: Alan Tull <atull@altera.com>

V3: Add raw readl/writel support for interrupt handlers
    Disable interrupts before initializing completion
    Return value in fgpa_mgr_release()
    Use safer snprintf instead of sprintf.
    Delete a debug statement
    Allow initializing priv in register_fpga_manager()
    Fix cleanup code in two functions

V2: Fixes to read fpga_mgr_op function
    Make function names more uniform
    Clean up error checking
[czou:Original patch taken from
https://github.com/altera-opensource/linux-socfpga.git socfpga-4.1]
Signed-off-by: czou <cao.zou@windriver.com>
---
 drivers/Kconfig                    |   2 +
 drivers/Makefile                   |   1 +
 drivers/fpga/Kconfig               |  14 ++
 drivers/fpga/Makefile              |   8 ++
 drivers/fpga/fpga-mgr-fops.c       | 124 ++++++++++++++++++
 drivers/fpga/fpga-mgr.c            | 258 +++++++++++++++++++++++++++++++++++++
 drivers/fpga/fpga-mgr.h            |  24 ++++
 drivers/fpga/fpga-transport-mmio.c | 120 +++++++++++++++++
 drivers/fpga/fpga-transport.c      |  63 +++++++++
 include/linux/fpga.h               | 184 ++++++++++++++++++++++++++
 10 files changed, 798 insertions(+)
 create mode 100644 drivers/fpga/Kconfig
 create mode 100644 drivers/fpga/Makefile
 create mode 100644 drivers/fpga/fpga-mgr-fops.c
 create mode 100644 drivers/fpga/fpga-mgr.c
 create mode 100644 drivers/fpga/fpga-mgr.h
 create mode 100644 drivers/fpga/fpga-transport-mmio.c
 create mode 100644 drivers/fpga/fpga-transport.c
 create mode 100644 include/linux/fpga.h

diff --git a/drivers/Kconfig b/drivers/Kconfig
index c0cc96b..4febe22 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -36,6 +36,8 @@ source "drivers/message/fusion/Kconfig"
 
 source "drivers/firewire/Kconfig"
 
+source "drivers/fpga/Kconfig"
+
 source "drivers/macintosh/Kconfig"
 
 source "drivers/net/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index 46d2554..2f43de1 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -49,6 +49,7 @@ obj-$(CONFIG_RESET_CONTROLLER)	+= reset/
 # default.
 obj-y				+= tty/
 obj-y				+= char/
+obj-$(CONFIG_FPGA)		+= fpga/
 
 # iommu/ comes before gpu as gpu are using iommu controllers
 obj-$(CONFIG_IOMMU_SUPPORT)	+= iommu/
diff --git a/drivers/fpga/Kconfig b/drivers/fpga/Kconfig
new file mode 100644
index 0000000..a706f63
--- /dev/null
+++ b/drivers/fpga/Kconfig
@@ -0,0 +1,14 @@
+#
+# FPGA framework configuration
+#
+
+menu "FPGA devices"
+
+config FPGA
+	tristate "FPGA Framework"
+	help
+	  Say Y here if you want support for configuring FPGAs from the
+	  kernel.  The FPGA framework adds a FPGA manager class and FPGA
+	  manager drivers.
+endmenu
+
diff --git a/drivers/fpga/Makefile b/drivers/fpga/Makefile
new file mode 100644
index 0000000..fd3cfb4
--- /dev/null
+++ b/drivers/fpga/Makefile
@@ -0,0 +1,8 @@
+#
+# Makefile for the fpga framework and fpga manager drivers.
+#
+
+fpga-mgr-core-y += fpga-mgr.o fpga-mgr-fops.o fpga-transport.o fpga-transport-mmio.o
+
+obj-$(CONFIG_FPGA)			+= fpga-mgr-core.o
+obj-y					+= fpga-mgrs/
diff --git a/drivers/fpga/fpga-mgr-fops.c b/drivers/fpga/fpga-mgr-fops.c
new file mode 100644
index 0000000..b0096cd
--- /dev/null
+++ b/drivers/fpga/fpga-mgr-fops.c
@@ -0,0 +1,124 @@
+/*
+ * FPGA Framework file operations
+ *
+ *  Copyright (C) 2013 Altera Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/fpga.h>
+#include <linux/vmalloc.h>
+#include "fpga-mgr.h"
+
+static ssize_t fpga_mgr_read(struct file *file, char __user *buf, size_t count,
+		loff_t *offset)
+{
+	char *tmp;
+	int ret = -EFAULT;
+	struct fpga_manager *mgr = file->private_data;
+
+	tmp = vmalloc(count);
+	if (tmp == NULL)
+		return -ENOMEM;
+
+	ret = mgr->mops->read(mgr, tmp, count);
+	if ((ret > 0) && copy_to_user(buf, tmp, ret))
+		ret = -EFAULT;
+
+	vfree(tmp);
+	return ret;
+}
+
+static ssize_t fpga_mgr_write(struct file *file, const char __user *buf,
+		size_t count, loff_t *offset)
+{
+	struct fpga_manager *mgr = file->private_data;
+	char *kern_buf;
+	int ret;
+
+	kern_buf = memdup_user(buf, count);
+	if (IS_ERR(kern_buf))
+		return PTR_ERR(kern_buf);
+
+	ret = mgr->mops->write(mgr, kern_buf, count);
+	kfree(kern_buf);
+	return ret;
+}
+
+static int fpga_mgr_open(struct inode *inode, struct file *file)
+{
+	struct fpga_manager *mgr;
+	struct fpga_manager_ops *mops;
+	bool fmode_wr = (file->f_mode & FMODE_WRITE) != 0;
+	bool fmode_rd = (file->f_mode & FMODE_READ) != 0;
+	int ret = 0;
+
+	mgr = container_of(inode->i_cdev, struct fpga_manager, cdev);
+	if (!mgr)
+		return -ENODEV;
+
+	mops = mgr->mops;
+
+	/* Don't allow read or write if we don't have read/write fns. */
+	if ((fmode_wr && !mops->write) || (fmode_rd && !mops->read))
+		return -EPERM;
+
+	/* Need to know if we are going to read or write. Can't be both. */
+	if (fmode_wr && fmode_rd)
+		return -EPERM;
+
+	if (test_and_set_bit_lock(FPGA_MGR_DEV_BUSY, &mgr->flags))
+		return -EBUSY;
+
+	file->private_data = mgr;
+
+	if (fmode_wr && mops->write_init)
+		ret = mops->write_init(mgr);
+	else if (fmode_rd && mops->read_init)
+		ret = mops->read_init(mgr);
+
+	return ret;
+}
+
+static int fpga_mgr_release(struct inode *inode, struct file *file)
+{
+	struct fpga_manager *mgr = file->private_data;
+	struct fpga_manager_ops *mops = mgr->mops;
+	bool fmode_wr = (file->f_mode & FMODE_WRITE) != 0;
+	bool fmode_rd = (file->f_mode & FMODE_READ) != 0;
+	int ret = 0;
+
+	if (fmode_wr && mops->write_complete)
+		ret = mops->write_complete(mgr);
+	else if (fmode_rd && mops->read_complete)
+		ret = mops->read_complete(mgr);
+
+	file->private_data = NULL;
+	clear_bit_unlock(FPGA_MGR_DEV_BUSY, &mgr->flags);
+
+	return ret;
+}
+
+const struct file_operations fpga_mgr_fops = {
+	.owner		= THIS_MODULE,
+	.llseek		= no_llseek,
+	.read		= fpga_mgr_read,
+	.write		= fpga_mgr_write,
+	.open		= fpga_mgr_open,
+	.release	= fpga_mgr_release,
+};
diff --git a/drivers/fpga/fpga-mgr.c b/drivers/fpga/fpga-mgr.c
new file mode 100644
index 0000000..0a72e72
--- /dev/null
+++ b/drivers/fpga/fpga-mgr.c
@@ -0,0 +1,258 @@
+/*
+ * FPGA Framework
+ *
+ *  Copyright (C) 2013 Altera Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/idr.h>
+#include <linux/slab.h>
+#include <linux/fpga.h>
+#include <linux/interrupt.h>
+#include <linux/of_irq.h>
+#include "fpga-mgr.h"
+
+static DEFINE_IDA(fpga_mgr_ida);
+static int fpga_mgr_major;
+static struct class *fpga_mgr_class;
+
+#define FPGA_MAX_MINORS	256
+
+/*
+ * class attributes
+ */
+static ssize_t fpga_mgr_name_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct fpga_manager *mgr = dev_get_drvdata(dev);
+
+	if (!mgr)
+		return -ENODEV;
+
+	return snprintf(buf, sizeof(mgr->name), "%s\n", mgr->name);
+}
+
+static ssize_t fpga_mgr_status_show(struct device *dev,
+				    struct device_attribute *attr, char *buf)
+{
+	struct fpga_manager *mgr = dev_get_drvdata(dev);
+
+	if (!mgr || !mgr->mops || !mgr->mops->status)
+		return -ENODEV;
+
+	return mgr->mops->status(mgr, buf);
+}
+
+static DEVICE_ATTR(name, S_IRUGO, fpga_mgr_name_show, NULL);
+static DEVICE_ATTR(status, S_IRUGO, fpga_mgr_status_show, NULL);
+
+static struct attribute *fpga_mgr_attrs[] = {
+	&dev_attr_name.attr,
+	&dev_attr_status.attr,
+	NULL,
+};
+
+static const struct attribute_group fpga_mgr_group = {
+	.attrs = fpga_mgr_attrs,
+};
+
+const struct attribute_group *fpga_mgr_groups[] = {
+	&fpga_mgr_group,
+	NULL,
+};
+
+static int fpga_mgr_get_new_minor(struct fpga_manager *mgr, int request_nr)
+{
+	int nr, start;
+
+	/* check specified minor number */
+	if (request_nr >= FPGA_MAX_MINORS) {
+		dev_err(mgr->parent, "Out of device minors (%d)\n", request_nr);
+		return -ENODEV;
+	}
+
+	/*
+	 * If request_nr == -1, dynamically allocate number.
+	 * If request_nr >= 0, attempt to get specific number.
+	 */
+	if (request_nr == -1)
+		start = 0;
+	else
+		start = request_nr;
+
+	nr = ida_simple_get(&fpga_mgr_ida, start, FPGA_MAX_MINORS, GFP_KERNEL);
+
+	/* return error code */
+	if (nr < 0)
+		return nr;
+
+	if ((request_nr != -1) && (request_nr != nr)) {
+		dev_err(mgr->parent,
+			"Could not get requested device minor (%d)\n", nr);
+		ida_simple_remove(&fpga_mgr_ida, nr);
+		return -ENODEV;
+	}
+
+	mgr->nr = nr;
+
+	return 0;
+}
+
+static void fpga_mgr_free_minor(int nr)
+{
+	ida_simple_remove(&fpga_mgr_ida, nr);
+}
+
+int register_fpga_manager(struct platform_device *pdev,
+			struct fpga_manager_ops *mops, char *name, void *priv)
+{
+	struct fpga_manager *mgr;
+	int ret;
+
+	if (!mops) {
+		dev_err(&pdev->dev,
+			"Attempt to register with no fpga_manager_ops\n");
+		return -EINVAL;
+	}
+	if (!name || (name[0] == '\0')) {
+		dev_err(&pdev->dev, "Attempt to register with no name!\n");
+		return -EINVAL;
+	}
+
+	mgr = kzalloc(sizeof(struct fpga_manager), GFP_KERNEL);
+	if (!mgr)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, mgr);
+	mgr->mops = mops;
+	mgr->np = pdev->dev.of_node;
+	mgr->parent = get_device(&pdev->dev);
+	mgr->priv = priv;
+	strlcpy(mgr->name, name, sizeof(mgr->name));
+	init_completion(&mgr->status_complete);
+
+	ret = fpga_mgr_get_new_minor(mgr, pdev->id);
+	if (ret)
+		goto error_kfree;
+
+	ret = fpga_mgr_attach_transport(mgr);
+	if (ret)
+		goto error_attach;
+
+	if (mops->isr) {
+		mgr->irq = irq_of_parse_and_map(mgr->np, 0);
+		if (mgr->irq == NO_IRQ) {
+			dev_err(mgr->parent, "failed to map interrupt\n");
+			goto error_irq_map;
+		}
+
+		ret = request_irq(mgr->irq, mops->isr, 0, "fpga-mgr", mgr);
+		if (ret < 0) {
+			dev_err(mgr->parent, "error requesting interrupt\n");
+			goto error_irq_req;
+		}
+	}
+
+	cdev_init(&mgr->cdev, &fpga_mgr_fops);
+	ret = cdev_add(&mgr->cdev, MKDEV(fpga_mgr_major, mgr->nr), 1);
+	if (ret)
+		goto error_cdev;
+
+	mgr->dev = device_create(fpga_mgr_class, mgr->parent,
+				 MKDEV(fpga_mgr_major, mgr->nr), mgr,
+				 "fpga%d", mgr->nr);
+	if (IS_ERR(mgr->dev)) {
+		ret = PTR_ERR(mgr->dev);
+		goto error_device;
+	}
+
+	dev_info(mgr->parent, "fpga manager [%s] registered as minor %d\n",
+		 mgr->name, mgr->nr);
+
+	return 0;
+
+error_device:
+	cdev_del(&mgr->cdev);
+error_cdev:
+	free_irq(mgr->irq, mgr);
+error_irq_req:
+	irq_dispose_mapping(mgr->irq);
+error_irq_map:
+	fpga_mgr_detach_transport(mgr);
+error_attach:
+	fpga_mgr_free_minor(mgr->nr);
+error_kfree:
+	put_device(mgr->parent);
+	kfree(mgr);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(register_fpga_manager);
+
+void remove_fpga_manager(struct platform_device *pdev)
+{
+	struct fpga_manager *mgr = platform_get_drvdata(pdev);
+
+	if (mgr && mgr->mops && mgr->mops->fpga_remove)
+		mgr->mops->fpga_remove(mgr);
+
+	device_destroy(fpga_mgr_class, MKDEV(fpga_mgr_major, mgr->nr));
+	cdev_del(&mgr->cdev);
+	free_irq(mgr->irq, mgr);
+	irq_dispose_mapping(mgr->irq);
+	fpga_mgr_detach_transport(mgr);
+	fpga_mgr_free_minor(mgr->nr);
+	put_device(mgr->parent);
+	kfree(mgr);
+}
+EXPORT_SYMBOL_GPL(remove_fpga_manager);
+
+static int __init fpga_mgr_dev_init(void)
+{
+	dev_t fpga_mgr_dev;
+	int ret;
+
+	pr_info("FPGA Mangager framework driver\n");
+
+	fpga_mgr_class = class_create(THIS_MODULE, "fpga");
+	if (IS_ERR(fpga_mgr_class))
+		return PTR_ERR(fpga_mgr_class);
+
+	fpga_mgr_class->dev_groups = fpga_mgr_groups;
+
+	ret = alloc_chrdev_region(&fpga_mgr_dev, 0, FPGA_MAX_MINORS, "fpga");
+	if (ret) {
+		class_destroy(fpga_mgr_class);
+		return ret;
+	}
+
+	fpga_mgr_major = MAJOR(fpga_mgr_dev);
+
+	return 0;
+}
+
+static void __exit fpga_mgr_dev_exit(void)
+{
+	unregister_chrdev_region(MKDEV(fpga_mgr_major, 0), FPGA_MAX_MINORS);
+	class_destroy(fpga_mgr_class);
+	ida_destroy(&fpga_mgr_ida);
+}
+
+MODULE_DESCRIPTION("FPGA Manager framework driver");
+MODULE_LICENSE("GPL v2");
+
+subsys_initcall(fpga_mgr_dev_init);
+module_exit(fpga_mgr_dev_exit);
diff --git a/drivers/fpga/fpga-mgr.h b/drivers/fpga/fpga-mgr.h
new file mode 100644
index 0000000..2c72da3
--- /dev/null
+++ b/drivers/fpga/fpga-mgr.h
@@ -0,0 +1,24 @@
+/*
+ * FPGA Framework
+ *
+ *  Copyright (C) 2013 Altera Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef __FPGA_CORE_H
+#define __FPGA_CORE_H
+
+extern const struct file_operations fpga_mgr_fops;
+
+#endif /* __FPGA_CORE_H */
diff --git a/drivers/fpga/fpga-transport-mmio.c b/drivers/fpga/fpga-transport-mmio.c
new file mode 100644
index 0000000..5a373cd
--- /dev/null
+++ b/drivers/fpga/fpga-transport-mmio.c
@@ -0,0 +1,120 @@
+/*
+ * FPGA Framework Transport
+ *
+ *  Copyright (C) 2013 Altera Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/kernel.h>
+#include <linux/of_address.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/fpga.h>
+
+static u32 fpga_reg_readl(struct fpga_mgr_transport *transp, u32 reg_offset)
+{
+	return readl(transp->fpga_base_addr + reg_offset);
+}
+
+static void fpga_reg_writel(struct fpga_mgr_transport *transp, u32 reg_offset,
+			    u32 value)
+{
+	writel(value, transp->fpga_base_addr + reg_offset);
+}
+
+static u32 fpga_reg_raw_readl(struct fpga_mgr_transport *transp, u32 reg_offset)
+{
+	return __raw_readl(transp->fpga_base_addr + reg_offset);
+}
+
+static void fpga_reg_raw_writel(struct fpga_mgr_transport *transp, u32 reg_offset,
+			    u32 value)
+{
+	__raw_writel(value, transp->fpga_base_addr + reg_offset);
+}
+
+static u32 fpga_data_readl(struct fpga_mgr_transport *transp)
+{
+	return readl(transp->fpga_data_addr);
+}
+
+static void fpga_data_writel(struct fpga_mgr_transport *transp, u32 value)
+{
+	writel(value, transp->fpga_data_addr);
+}
+
+int fpga_attach_mmio_transport(struct fpga_manager *mgr)
+{
+	struct device_node *np = mgr->np;
+	struct fpga_mgr_transport *transp;
+	static void __iomem *fpga_base_addr;
+	static void __iomem *fpga_data_addr;
+	int ret = 0;
+
+	fpga_base_addr = of_iomap(np, 0);
+	if (!fpga_base_addr) {
+		dev_err(mgr->parent,
+			"Need to specify fpga manager register address.\n");
+		return -EINVAL;
+	}
+
+	fpga_data_addr = of_iomap(np, 1);
+	if (!fpga_data_addr) {
+		dev_err(mgr->parent,
+			"Need to specify fpga manager data address.\n");
+		ret = -ENOMEM;
+		goto err_baddr;
+	}
+
+	transp = kzalloc(sizeof(struct fpga_mgr_transport), GFP_KERNEL);
+	if (!transp) {
+		dev_err(mgr->parent, "Could not allocate transport\n");
+		ret = -ENOMEM;
+		goto err_daddr;
+	}
+
+	transp->fpga_base_addr = fpga_base_addr;
+	transp->fpga_data_addr = fpga_data_addr;
+
+	transp->reg_readl = fpga_reg_readl;
+	transp->reg_writel = fpga_reg_writel;
+	transp->reg_raw_readl = fpga_reg_raw_readl;
+	transp->reg_raw_writel = fpga_reg_raw_writel;
+	transp->data_writel = fpga_data_writel;
+	transp->data_readl = fpga_data_readl;
+	strlcpy(transp->type, "mmio", sizeof(transp->type));
+
+	transp->mgr = mgr;
+	mgr->transp = transp;
+
+	return 0;
+
+err_daddr:
+	iounmap(fpga_data_addr);
+err_baddr:
+	iounmap(fpga_base_addr);
+	return ret;
+}
+EXPORT_SYMBOL(fpga_attach_mmio_transport);
+
+void fpga_detach_mmio_transport(struct fpga_manager *mgr)
+{
+	struct fpga_mgr_transport *transp = mgr->transp;
+
+	iounmap(transp->fpga_base_addr);
+	iounmap(transp->fpga_data_addr);
+	kfree(transp);
+}
+EXPORT_SYMBOL(fpga_detach_mmio_transport);
diff --git a/drivers/fpga/fpga-transport.c b/drivers/fpga/fpga-transport.c
new file mode 100644
index 0000000..7f68ad4
--- /dev/null
+++ b/drivers/fpga/fpga-transport.c
@@ -0,0 +1,63 @@
+/*
+ * FPGA Framework Transport
+ *
+ *  Copyright (C) 2013 Altera Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/kernel.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/fpga.h>
+
+int fpga_mgr_attach_transport(struct fpga_manager *mgr)
+{
+	struct device_node *np = mgr->np;
+	const char *string;
+	int ret;
+
+	ret = of_property_read_string(np, "transport", &string);
+	if (ret) {
+		dev_err(mgr->parent,
+			"Transport not specified for fpga manager %s\n",
+			mgr->name);
+		return -ENODEV;
+	}
+
+	if (strcmp(string, "mmio") == 0)
+		ret = fpga_attach_mmio_transport(mgr);
+	else {
+		dev_err(mgr->parent,
+			"Invalid transport specified for fpga manager %s (%s)\n",
+			mgr->name, string);
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL(fpga_mgr_attach_transport);
+
+void fpga_mgr_detach_transport(struct fpga_manager *mgr)
+{
+	struct fpga_mgr_transport *transp = mgr->transp;
+	const char *type = transp->type;
+
+	if (!strncmp(type, "mmio", strlen(type)))
+		fpga_detach_mmio_transport(mgr);
+	else
+		BUG();
+}
+EXPORT_SYMBOL(fpga_mgr_detach_transport);
diff --git a/include/linux/fpga.h b/include/linux/fpga.h
new file mode 100644
index 0000000..37f8e42
--- /dev/null
+++ b/include/linux/fpga.h
@@ -0,0 +1,184 @@
+/*
+ * FPGA Framework
+ *
+ *  Copyright (C) 2013 Altera Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/cdev.h>
+#include <linux/of.h>
+#include <linux/interrupt.h>
+#include <linux/completion.h>
+
+#ifndef _LINUX_FPGA_H
+#define _LINUX_FPGA_H
+
+struct fpga_manager;
+struct fpga_mgr_transport;
+
+/*---------------------------------------------------------------------------*/
+
+struct fpga_mgr_transport {
+	struct fpga_manager *mgr;
+	char type[16];
+
+	u32 (*reg_readl)(struct fpga_mgr_transport *transp, u32 reg_offset);
+	void (*reg_writel)(struct fpga_mgr_transport *transp, u32 reg_offset,
+			   u32 value);
+	u32 (*reg_raw_readl)(struct fpga_mgr_transport *transp, u32 reg_offset);
+	void (*reg_raw_writel)(struct fpga_mgr_transport *transp, u32 reg_offset,
+			   u32 value);
+	u32 (*data_readl)(struct fpga_mgr_transport *transp);
+	void (*data_writel)(struct fpga_mgr_transport *transp, u32 value);
+
+	void __iomem *fpga_base_addr;
+	void __iomem *fpga_data_addr;
+};
+
+extern int fpga_mgr_attach_transport(struct fpga_manager *mgr);
+extern void fpga_mgr_detach_transport(struct fpga_manager *mgr);
+
+extern int fpga_attach_mmio_transport(struct fpga_manager *mgr);
+extern void fpga_detach_mmio_transport(struct fpga_manager *mgr);
+
+/*---------------------------------------------------------------------------*/
+
+/*
+ * fpga_manager_ops are the low level functions implemented by a specific
+ * fpga manager driver.  Leaving any of these out that aren't needed is fine
+ * as they are all tested for NULL before being called.
+ */
+struct fpga_manager_ops {
+	/* Returns a string of the FPGA's status */
+	int (*status)(struct fpga_manager *mgr, char *buf);
+
+	/* Prepare the FPGA for reading its confuration data */
+	int (*read_init)(struct fpga_manager *mgr);
+
+	/* Read count bytes configuration data from the FPGA */
+	ssize_t (*read)(struct fpga_manager *mgr, char *buf, size_t count);
+
+	/* Return FPGA to a default state after reading is done */
+	int (*read_complete)(struct fpga_manager *mgr);
+
+	/* Prepare the FPGA to receive confuration data */
+	int (*write_init)(struct fpga_manager *mgr);
+
+	/* Write count bytes of configuration data to the FPGA */
+	ssize_t (*write)(struct fpga_manager *mgr, char *buf, size_t count);
+
+	/* Return FPGA to default state after writing is done */
+	int (*write_complete)(struct fpga_manager *mgr);
+
+	/* Set FPGA into a specific state during driver remove */
+	void (*fpga_remove)(struct fpga_manager *mgr);
+
+	/* FPGA mangager isr */
+	irqreturn_t (*isr)(int irq, void *dev_id);
+};
+
+/* flag bits */
+#define FPGA_MGR_DEV_BUSY 0
+
+struct fpga_manager {
+	struct device_node *np;
+	struct device *parent;
+	struct device *dev;
+	struct cdev cdev;
+	int irq;
+	struct completion status_complete;
+
+	int nr;
+	char name[48];
+	unsigned long flags;
+	struct fpga_manager_ops *mops;
+	struct fpga_mgr_transport *transp;
+
+	void *priv;
+};
+
+#if defined(CONFIG_FPGA) || defined(CONFIG_FPGA_MODULE)
+
+extern int register_fpga_manager(struct platform_device *pdev,
+				 struct fpga_manager_ops *mops,
+				 char *name, void *priv);
+
+extern void remove_fpga_manager(struct platform_device *pdev);
+
+/*
+ * Read/write FPGA manager registers
+ */
+static inline u32 fpga_mgr_reg_readl(struct fpga_manager *mgr, u32 offset)
+{
+	struct fpga_mgr_transport *transp = mgr->transp;
+	return transp->reg_readl(transp, offset);
+}
+
+static inline void fpga_mgr_reg_writel(struct fpga_manager *mgr, u32 offset,
+				       u32 value)
+{
+	struct fpga_mgr_transport *transp = mgr->transp;
+	transp->reg_writel(transp, offset, value);
+}
+
+static inline u32 fpga_mgr_reg_raw_readl(struct fpga_manager *mgr, u32 offset)
+{
+	struct fpga_mgr_transport *transp = mgr->transp;
+	return transp->reg_raw_readl(transp, offset);
+}
+
+static inline void fpga_mgr_reg_raw_writel(struct fpga_manager *mgr, u32 offset,
+				       u32 value)
+{
+	struct fpga_mgr_transport *transp = mgr->transp;
+	transp->reg_raw_writel(transp, offset, value);
+}
+
+static inline void fpga_mgr_reg_set_bitsl(struct fpga_manager *mgr,
+					  u32 offset, u32 bits)
+{
+	u32 val;
+	val = fpga_mgr_reg_readl(mgr, offset);
+	val |= bits;
+	fpga_mgr_reg_writel(mgr, offset, val);
+}
+
+static inline void fpga_mgr_reg_clr_bitsl(struct fpga_manager *mgr,
+					  u32 offset, u32 bits)
+{
+	u32 val;
+	val = fpga_mgr_reg_readl(mgr, offset);
+	val &= ~bits;
+	fpga_mgr_reg_writel(mgr, offset, val);
+}
+
+/*
+ * Read/write FPGA configuration data
+ */
+static inline u32 fpga_mgr_data_readl(struct fpga_manager *mgr)
+{
+	struct fpga_mgr_transport *transp = mgr->transp;
+	return transp->data_readl(transp);
+}
+
+static inline void fpga_mgr_data_writel(struct fpga_manager *mgr, u32 value)
+{
+	struct fpga_mgr_transport *transp = mgr->transp;
+	transp->data_writel(transp, value);
+}
+
+#endif /* CONFIG_FPGA */
+#endif /*_LINUX_FPGA_H */
-- 
1.9.1

