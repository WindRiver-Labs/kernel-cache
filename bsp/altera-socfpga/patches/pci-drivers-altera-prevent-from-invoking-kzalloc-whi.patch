From 6ac51d472a069be22b38f972412e0108b005ac6a Mon Sep 17 00:00:00 2001
From: Yang Wei <Wei.Yang@windriver.com>
Date: Tue, 1 Jul 2014 13:34:53 +0800
Subject: [PATCH 5/6] pci:drivers:altera: prevent from invoking kzalloc while
 configuring pci

It is the worst way to allocate memory for temporary variable
by kzalloc back and forth, especially on the low-level read/write ops,
so we should avoid it as far as possible. Additionally, it also
probably triggers the following call trace. because even through we
invoke kzalloc with GFP_ATOMIC flag, it also probably results in sleeping,
as spin lock becomes to have ability to sleep inside RT kernel. pci ops
is protected by pci_lock, so in order to get a better performance and
fix this call trace on RT kernel,we should prevent from invoking kzalloc
in pci ops.

[<8001830c>] (unwind_backtrace+0x0/0x104) from [<8068d234>] (dump_stack+0x20/0x24)
[<8068d234>] (dump_stack+0x20/0x24) from [<8005b578>] (__might_sleep+0x12c/0x130)
[<8005b578>] (__might_sleep+0x12c/0x130) from [<80697a64>] (rt_spin_lock+0x34/0x6c)
[<80697a64>] (rt_spin_lock+0x34/0x6c) from [<8012ba64>] (kmem_cache_alloc_trace+0x9c/0x304)
[<8012ba64>] (kmem_cache_alloc_trace+0x9c/0x304) from [<803b2cdc>] (tlp_cfg_dword_read+0x68/0x148)
[<803b2cdc>] (tlp_cfg_dword_read+0x68/0x148) from [<803b301c>] (altera_pcie_cfg_read+0x74/0xa0)
[<803b301c>] (altera_pcie_cfg_read+0x74/0xa0) from [<8039cb94>] (pci_user_read_config_dword+0x7c/0xb4)
[<8039cb94>] (pci_user_read_config_dword+0x7c/0xb4) from [<803a6dcc>] (pci_read_config+0x108/0x3ec)
[<803a6dcc>] (pci_read_config+0x108/0x3ec) from [<801a1400>] (read+0xdc/0x1e8)
[<801a1400>] (read+0xdc/0x1e8) from [<80138a14>] (vfs_read+0xb4/0x144)
[<80138a14>] (vfs_read+0xb4/0x144) from [<80138d70>] (sys_pread64+0x84/0x14c)
[<80138d70>] (sys_pread64+0x84/0x14c) from [<8000e7e0>] (ret_fast_syscall+0x0/0x48)

Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 drivers/pci/host/pci-altera.c |   80 +++++++++++++----------------------------
 1 files changed, 25 insertions(+), 55 deletions(-)

diff --git a/drivers/pci/host/pci-altera.c b/drivers/pci/host/pci-altera.c
index 843de5c..0039e37 100644
--- a/drivers/pci/host/pci-altera.c
+++ b/drivers/pci/host/pci-altera.c
@@ -111,16 +111,8 @@ static void tlp_write_rp_tx(struct altera_pcie *pcie,
 static int tlp_read_packet(struct altera_pcie *pcie, u32 *value)
 {
 	int err = PCIBIOS_SUCCESSFUL;
+	struct tlp_rp_regpair_t tlp_rp_regdata;
 	u8 loop;
-	struct tlp_rp_regpair_t *tlp_rp_regdata;
-
-	/* allocate tlp_rp_regdata */
-	tlp_rp_regdata = kzalloc(sizeof(struct tlp_rp_regpair_t), GFP_ATOMIC);
-	if (!tlp_rp_regdata) {
-		dev_err(pcie->dev, "out of memory !!!\n");
-		err = -ENOMEM;
-		goto ret_error;
-	}
 
 	/*
 	 * Detect RP_RXCPL_SOP is not require,
@@ -130,24 +122,19 @@ static int tlp_read_packet(struct altera_pcie *pcie, u32 *value)
 	 */
 	for (loop = (TLP_PAYLOAD_SIZE + SOP_LOOP + HEADER_LOOP +
 		DETECTION_LOOP); loop > 0; loop--) {
-		tlp_read_rp_rx(pcie, tlp_rp_regdata);
+		tlp_read_rp_rx(pcie, &tlp_rp_regdata);
 		/* detect EOP */
-		if (tlp_rp_regdata->rp_ctrl & RP_RXCPL_EOP)
+		if (tlp_rp_regdata.rp_ctrl & RP_RXCPL_EOP)
 			break;
 	}
 	/* if no EOP detected */
-	if (loop == 0) {
+	if (loop == 0)
 		err = -ENOENT;
-		goto ret_freemem;
-	}
 
 	/* read data */
 	if (value)
-		*value = tlp_rp_regdata->rp_reg0;
+		*value = tlp_rp_regdata.rp_reg0;
 
-ret_freemem:
-	kfree(tlp_rp_regdata);
-ret_error:
 	return err;
 }
 
@@ -155,8 +142,8 @@ ret_error:
 static int tlp_cfg_dword_read(struct altera_pcie *pcie, u8 bus, u32 devfn,
 			      int where, u32 *value)
 {
-	struct tlp_rp_regpair_t *tlp_rp_regdata;
 	int ret;
+	struct tlp_rp_regpair_t tlp_rp_regdata;
 
 	/* if not DWORD align */
 	if (!IS_ALIGNED(where, sizeof(u32))) {
@@ -179,34 +166,26 @@ static int tlp_cfg_dword_read(struct altera_pcie *pcie, u8 bus, u32 devfn,
 		return PCIBIOS_SUCCESSFUL;
 	}
 
-	/* allocate tlp_rp_regdata */
-	tlp_rp_regdata = kzalloc(sizeof(struct tlp_rp_regpair_t), GFP_ATOMIC);
-	if (!tlp_rp_regdata) {
-		dev_err(pcie->dev, "out of memory !!!\n");
-		return -ENOMEM;
-	}
-
 	/* sending TLP packet */
 	if (bus == rp_pribus)
-		tlp_rp_regdata->rp_reg0 = TLP_CFG_DW0(TLP_FMTTYPE_CFGRD0);
+		tlp_rp_regdata.rp_reg0 = TLP_CFG_DW0(TLP_FMTTYPE_CFGRD0);
 	else
-		tlp_rp_regdata->rp_reg0 = TLP_CFG_DW0(TLP_FMTTYPE_CFGRD1);
-	tlp_rp_regdata->rp_reg1 = TLP_CFG_DW1(
+		tlp_rp_regdata.rp_reg0 = TLP_CFG_DW0(TLP_FMTTYPE_CFGRD1);
+	tlp_rp_regdata.rp_reg1 = TLP_CFG_DW1(
 				  ((rp_pribus << 8) | ALTRPCIERP_DEVFN),
 				  TLP_READ_TAG);
-	tlp_rp_regdata->rp_ctrl = RP_TX_SOP;
-	tlp_write_rp_tx(pcie, tlp_rp_regdata);
-	tlp_rp_regdata->rp_reg0 = TLP_CFG_DW2(bus, devfn, where);
-	tlp_rp_regdata->rp_reg1 = 0x0;
-	tlp_rp_regdata->rp_ctrl = RP_TX_EOP;
-	tlp_write_rp_tx(pcie, tlp_rp_regdata);
+	tlp_rp_regdata.rp_ctrl = RP_TX_SOP;
+	tlp_write_rp_tx(pcie, &tlp_rp_regdata);
+	tlp_rp_regdata.rp_reg0 = TLP_CFG_DW2(bus, devfn, where);
+	tlp_rp_regdata.rp_reg1 = 0x0;
+	tlp_rp_regdata.rp_ctrl = RP_TX_EOP;
+	tlp_write_rp_tx(pcie, &tlp_rp_regdata);
 
 	/* read data from completion package */
 	ret = tlp_read_packet(pcie, value);
 	if (ret)
 		*value = ~0UL;	/* return 0xFFFFFFFF if error */
 
-	kfree(tlp_rp_regdata);
 	return ret;
 }
 
@@ -214,7 +193,7 @@ static int tlp_cfg_dword_read(struct altera_pcie *pcie, u8 bus, u32 devfn,
 static int tlp_cfg_dword_write(struct altera_pcie *pcie, u8 bus, u32 devfn,
 			       int where, u32 value)
 {
-	struct tlp_rp_regpair_t *tlp_rp_regdata;
+	struct tlp_rp_regpair_t tlp_rp_regdata;
 
 	/* if not DWORD align */
 	if (!IS_ALIGNED(where, sizeof(u32))) {
@@ -235,27 +214,20 @@ static int tlp_cfg_dword_write(struct altera_pcie *pcie, u8 bus, u32 devfn,
 		(PCI_SLOT(devfn) > 0))
 		return PCIBIOS_SET_FAILED;
 
-	/* allocate tlp_rp_regdata */
-	tlp_rp_regdata = kzalloc(sizeof(struct tlp_rp_regpair_t), GFP_ATOMIC);
-	if (!tlp_rp_regdata) {
-		dev_err(pcie->dev, "out of memory !!!\n");
-		return -ENOMEM;
-	}
-
 	/* sending TLP packet */
 	if (bus == rp_pribus)
-		tlp_rp_regdata->rp_reg0 = TLP_CFG_DW0(TLP_FMTTYPE_CFGWR0);
+		tlp_rp_regdata.rp_reg0 = TLP_CFG_DW0(TLP_FMTTYPE_CFGWR0);
 	else
-		tlp_rp_regdata->rp_reg0 = TLP_CFG_DW0(TLP_FMTTYPE_CFGWR1);
-	tlp_rp_regdata->rp_reg1 = TLP_CFG_DW1(
+		tlp_rp_regdata.rp_reg0 = TLP_CFG_DW0(TLP_FMTTYPE_CFGWR1);
+	tlp_rp_regdata.rp_reg1 = TLP_CFG_DW1(
 				  ((rp_pribus << 8) | ALTRPCIERP_DEVFN),
 				  TLP_WRITE_TAG);
-	tlp_rp_regdata->rp_ctrl = RP_TX_SOP;
-	tlp_write_rp_tx(pcie, tlp_rp_regdata);
-	tlp_rp_regdata->rp_reg0 = TLP_CFG_DW2(bus, devfn, where);
-	tlp_rp_regdata->rp_reg1 = value;
-	tlp_rp_regdata->rp_ctrl = RP_TX_EOP;
-	tlp_write_rp_tx(pcie, tlp_rp_regdata);
+	tlp_rp_regdata.rp_ctrl = RP_TX_SOP;
+	tlp_write_rp_tx(pcie, &tlp_rp_regdata);
+	tlp_rp_regdata.rp_reg0 = TLP_CFG_DW2(bus, devfn, where);
+	tlp_rp_regdata.rp_reg1 = value;
+	tlp_rp_regdata.rp_ctrl = RP_TX_EOP;
+	tlp_write_rp_tx(pcie, &tlp_rp_regdata);
 
 	/* TLP read response */
 	tlp_read_packet(pcie, NULL);
@@ -267,7 +239,6 @@ static int tlp_cfg_dword_write(struct altera_pcie *pcie, u8 bus, u32 devfn,
 		rp_secbus = (u8)(value >> 8);
 	}
 
-	kfree(tlp_rp_regdata);
 	return PCIBIOS_SUCCESSFUL;
 }
 
@@ -466,7 +437,6 @@ static int altera_pcie_probe(struct platform_device *pdev)
 	}
 	ret = devm_request_irq(&pdev->dev, pcie->hwirq, altera_pcie_isr,
 			IRQF_SHARED, pdev->name, pcie);
-
 	if (ret) {
 		dev_err(&pdev->dev, "failed to register legacy IRQ\n");
 		return ret;
-- 
1.7.5.4

