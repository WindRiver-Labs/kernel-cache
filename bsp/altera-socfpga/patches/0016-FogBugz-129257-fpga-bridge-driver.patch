From 01fede3e13114fed71215ce058e0b69958749234 Mon Sep 17 00:00:00 2001
From: Alan Tull <atull@altera.com>
Date: Thu, 11 Jul 2013 15:47:04 -0500
Subject: [PATCH 016/172] FogBugz #129257: fpga bridge driver

Support for bringing bridges out of reset.  Bridges show up in sysfs
under /sys/class/fpga-bridge and can be enabled/disabled from sysfs
or from the device tree.

Supports enabling the following hps/fpga bridges:
 * fpga2sdram
 * fpga2hps
 * hps2fpga
 * lwhps2fpga

Enable:
 $ echo 1 > /sys/class/fpga-bridge/fpga2hps/enable

Disable:
 $ echo 0 > /sys/class/fpga-bridge/fpga2hps/enable

Check enable/disable status (checks for all bits set):
 $ cat /sys/class/fpga-bridge/fpga2hps/enable
 (will print '0' or '1')

Signed-off-by: Alan Tull <atull@altera.com>
[czou:Original patch taken from
https://github.com/altera-opensource/linux-socfpga.git socfpga-4.1]
Signed-off-by: czou <cao.zou@windriver.com>

V2:
  * Instead of enabling all fpga2sdram paths (some unused), break up
    into separate fpga2sdram bridges, configured by the device tree.
  * Break the altera specific bridges into two file to keep code more
    straightforward.
  * remove fpga2sdram bridges from socfpga.dtsi as they are confiration-
    specific.

V3:
  * use devm_kzalloc
  * rename Documentation file to 'altera-fpga-bridge.txt'
  * make L3 interconnect visable/invisable for hps2fpga, lwhps2fpga
    bridges

V4:
  * more bindings documentation

Conflicts:

	arch/arm/boot/dts/socfpga.dtsi
	arch/arm/configs/socfpga_defconfig
	arch/arm/mach-socfpga/socfpga.c
	drivers/misc/Kconfig
---
 .../devicetree/bindings/arm/altera/socfpga-l3.txt  |  14 ++
 .../bindings/arm/altera/socfpga-sdram.txt          |  14 ++
 .../bindings/arm/altera/socfpga-system.txt         |   7 +-
 .../bindings/fpga/altera-fpga-bridge.txt           |  75 +++++++
 .../devicetree/bindings/reset/socfpga-reset.txt    |   7 +-
 arch/arm/boot/dts/socfpga.dtsi                     |  43 +++-
 arch/arm/configs/socfpga_defconfig                 |   2 +
 arch/arm/mach-socfpga/socfpga.c                    |  21 ++
 drivers/misc/Kconfig                               |   2 +
 drivers/misc/Makefile                              |   1 +
 drivers/misc/fpga-bridge/Kconfig                   |  20 ++
 drivers/misc/fpga-bridge/Makefile                  |   6 +
 drivers/misc/fpga-bridge/altera-fpga2sdram.c       | 216 +++++++++++++++++++
 drivers/misc/fpga-bridge/altera-hps2fpga.c         | 178 ++++++++++++++++
 drivers/misc/fpga-bridge/fpga-bridge.c             | 232 +++++++++++++++++++++
 drivers/misc/fpga-bridge/fpga-bridge.h             |  51 +++++
 16 files changed, 876 insertions(+), 13 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/arm/altera/socfpga-l3.txt
 create mode 100644 Documentation/devicetree/bindings/arm/altera/socfpga-sdram.txt
 create mode 100644 Documentation/devicetree/bindings/fpga/altera-fpga-bridge.txt
 create mode 100644 drivers/misc/fpga-bridge/Kconfig
 create mode 100644 drivers/misc/fpga-bridge/Makefile
 create mode 100644 drivers/misc/fpga-bridge/altera-fpga2sdram.c
 create mode 100644 drivers/misc/fpga-bridge/altera-hps2fpga.c
 create mode 100644 drivers/misc/fpga-bridge/fpga-bridge.c
 create mode 100644 drivers/misc/fpga-bridge/fpga-bridge.h

diff --git a/Documentation/devicetree/bindings/arm/altera/socfpga-l3.txt b/Documentation/devicetree/bindings/arm/altera/socfpga-l3.txt
new file mode 100644
index 0000000..c99094a
--- /dev/null
+++ b/Documentation/devicetree/bindings/arm/altera/socfpga-l3.txt
@@ -0,0 +1,14 @@
+Altera SOCFPGA L3 Interconnect (NIC-301)
+
+Required properties:
+- compatible : "altr,l3regs", "syscon";
+                Note that syscon is invoked for this device to support the FPGA
+		bridge driver and possibly other devices in the future.  See
+		also Documentation/devicetree/bindings/mfd/syscon.txt
+- reg : Should contain 1 register ranges(address and length)
+
+Example:
+	l3regs@0xff800000 {
+		compatible = "altr,l3regs", "syscon";
+		reg = <0xff800000 0x1000>;
+	};
diff --git a/Documentation/devicetree/bindings/arm/altera/socfpga-sdram.txt b/Documentation/devicetree/bindings/arm/altera/socfpga-sdram.txt
new file mode 100644
index 0000000..351ab7b
--- /dev/null
+++ b/Documentation/devicetree/bindings/arm/altera/socfpga-sdram.txt
@@ -0,0 +1,14 @@
+Altera SOCFPGA SDRAM Controller
+
+Required properties:
+- compatible : "altr,sdr-ctl", "syscon";
+                Note that syscon is invoked for this device to support the FPGA
+		bridge driver and possibly other devices in the future.  See
+		also Documentation/devicetree/bindings/mfd/syscon.txt
+- reg : Should contain 1 register ranges(address and length)
+
+Example:
+	sdrctl@0xffc25000 {
+		compatible = "altr,sdr-ctl", "syscon";
+		reg = <0xffc25000 0x1000>;
+	};
diff --git a/Documentation/devicetree/bindings/arm/altera/socfpga-system.txt b/Documentation/devicetree/bindings/arm/altera/socfpga-system.txt
index f4d04a0..a17c582 100644
--- a/Documentation/devicetree/bindings/arm/altera/socfpga-system.txt
+++ b/Documentation/devicetree/bindings/arm/altera/socfpga-system.txt
@@ -1,13 +1,16 @@
 Altera SOCFPGA System Manager
 
 Required properties:
-- compatible : "altr,sys-mgr"
+- compatible : "altr,sys-mgr", "syscon";
+
 - reg : Should contain 1 register ranges(address and length)
+                Note that syscon is invoked for this device. See
+		also Documentation/devicetree/bindings/mfd/syscon.txt
 - cpu1-start-addr : CPU1 start address in hex.
 
 Example:
 	 sysmgr@ffd08000 {
-		compatible = "altr,sys-mgr";
+		compatible = "altr,sys-mgr", "syscon";
 		reg = <0xffd08000 0x1000>;
 		cpu1-start-addr = <0xffd080c4>;
 	};
diff --git a/Documentation/devicetree/bindings/fpga/altera-fpga-bridge.txt b/Documentation/devicetree/bindings/fpga/altera-fpga-bridge.txt
new file mode 100644
index 0000000..60960a9
--- /dev/null
+++ b/Documentation/devicetree/bindings/fpga/altera-fpga-bridge.txt
@@ -0,0 +1,75 @@
+Altera FPGA Bridge Driver
+
+Required properties:
+
+  - compatible : should be "<manufacturer>,<type>"
+                 "altr,socfpga-fpga2sdram-bridge"
+		 "altr,socfpga-hps2fpga-bridge"
+		 "altr,socfpga-lwhps2fpga-bridge"
+		 "altr,socfpga-fpga2hps-bridge"
+
+Required for fpga2sdram bridge only:
+  - read-port  : which read port is used for this bridge (0-3)
+  - write-port : which write port is used for this bridge (0-3)
+  - control-ports : which conrtol port(s) are used for this bridge.
+                    index 0 is first port # (0-5)
+		    index 1 is number of ports used (1-2)
+
+Optional properties:
+  - label      : name that you want this bridge to show up as under /sys
+                 Default is br<device#> if this is not specified
+
+  - enable     : If 'enable' is specified, the bridge will be enabled or
+                 disabled upon load, depending on the value of this parameter.
+		 if 'enable' is not specified, the driver will not enable
+		 or disable the bridge by default.
+
+Example:
+	hps_fpgabridge0: fpgabridge@0 {
+		compatible = "altr,socfpga-hps2fpga-bridge";
+		label = "hps2fpga";
+		enable = <1>;
+	};
+
+	hps_fpgabridge1: fpgabridge@1 {
+		compatible = "altr,socfpga-lwhps2fpga-bridge";
+		label = "lwhps2fpga";
+	};
+
+	hps_fpgabridge2: fpgabridge@2 {
+		compatible = "altr,socfpga-fpga2hps-bridge";
+		label = "fpga2hps";
+	};
+
+	hps_fpgabridge3: fpgabridge@3 {
+		compatible = "altr,socfpga-fpga2sdram-bridge";
+		label = "fpga2sdram0";
+		read-port = <0>;
+		write-port = <0>;
+		control-ports = <0 2>; /* ports 0 and 1 */
+		enable = <1>;
+	};
+
+	hps_fpgabridge4: fpgabridge@4 {
+		compatible = "altr,socfpga-fpga2sdram-bridge";
+		label = "fpga2sdram1";
+		read-port = <1>;
+		write-port = <1>;
+		control-ports = <2 1>; /* port 2 only */
+	};
+
+	hps_fpgabridge5: fpgabridge@5 {
+		compatible = "altr,socfpga-fpga2sdram-bridge";
+		label = "fpga2sdram2";
+		read-port = <2>;
+		write-port = <2>;
+		control-ports = <3 1>; /* port 3 only */
+	};
+
+	hps_fpgabridge6: fpgabridge@6 {
+		compatible = "altr,socfpga-fpga2sdram-bridge";
+		label = "fpga2sdram3";
+		read-port = <3>;
+		write-port = <3>;
+		control-ports = <4 2>; /* ports 4 and 5 */
+	};
diff --git a/Documentation/devicetree/bindings/reset/socfpga-reset.txt b/Documentation/devicetree/bindings/reset/socfpga-reset.txt
index 32c1c8b..c338638 100644
--- a/Documentation/devicetree/bindings/reset/socfpga-reset.txt
+++ b/Documentation/devicetree/bindings/reset/socfpga-reset.txt
@@ -1,13 +1,16 @@
 Altera SOCFPGA Reset Manager
 
 Required properties:
-- compatible : "altr,rst-mgr"
+- compatible : "altr,rst-mgr", "syscon";
+                Note that syscon is invoked for this device to support the FPGA
+		bridge driver and possibly other devices in the future.  See
+		also Documentation/devicetree/bindings/mfd/syscon.txt
 - reg : Should contain 1 register ranges(address and length)
 - #reset-cells: 1
 
 Example:
 	 rstmgr@ffd05000 {
 		#reset-cells = <1>;
-		compatible = "altr,rst-mgr";
+		compatible = "altr,rst-mgr", "syscon";
 		reg = <0xffd05000 0x1000>;
 	};
diff --git a/arch/arm/boot/dts/socfpga.dtsi b/arch/arm/boot/dts/socfpga.dtsi
index 13efb93..a44bbe2 100644
--- a/arch/arm/boot/dts/socfpga.dtsi
+++ b/arch/arm/boot/dts/socfpga.dtsi
@@ -507,6 +507,29 @@
 			status = "disabled";
 		};
 
+		hps_0_fpgamgr: fpgamgr@0xff706000 {
+			compatible = "altr,fpga-mgr-1.0", "altr,fpga-mgr";
+			transport = "mmio";
+			reg = <0xFF706000 0x1000
+			0xFFB90000 0x1000>;
+			interrupts = <0 175 4>;
+		};
+
+		hps_fpgabridge0: fpgabridge@0 {
+			compatible = "altr,socfpga-hps2fpga-bridge";
+			label = "hps2fpga";
+		};
+
+		hps_fpgabridge1: fpgabridge@1 {
+			compatible = "altr,socfpga-lwhps2fpga-bridge";
+			label = "lwhps2fpga";
+		};
+
+		hps_fpgabridge2: fpgabridge@2 {
+			compatible = "altr,socfpga-fpga2hps-bridge";
+			label = "fpga2hps";
+		};
+
 		i2c0: i2c@ffc04000 {
 			#address-cells = <1>;
 			#size-cells = <0>;
@@ -697,6 +720,16 @@
 			};
 		};
 
+		sdrctl@0xffc25000 {
+			compatible = "altr,sdr-ctl", "syscon";
+			reg = <0xffc25000 0x1000>;
+		};
+
+		l3regs@0xff800000 {
+			compatible = "altr,l3regs", "syscon";
+			reg = <0xff800000 0x1000>;
+		};
+
 		spi0: spi@fff00000 {
 			compatible = "snps,dw-spi-mmio";
 			#address-cells = <1>;
@@ -805,7 +838,7 @@
 
 		rst: rstmgr@ffd05000 {
 			#reset-cells = <1>;
-			compatible = "altr,rst-mgr";
+			compatible = "altr,rst-mgr", "syscon";
 			reg = <0xffd05000 0x1000>;
 		};
 
@@ -857,13 +890,5 @@
 			compatible = "altr,sys-mgr", "syscon";
 			reg = <0xffd08000 0x4000>;
 		};
-
-		hps_0_fpgamgr: fpgamgr@0xff706000 {
-			compatible = "altr,fpga-mgr-1.0", "altr,fpga-mgr";
-			transport = "mmio";
-			reg = <0xFF706000 0x1000
-			       0xFFB90000 0x1000>;
-			interrupts = <0 175 4>;
-		};
 	};
 };
diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index 59b621b..338bc33 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -127,3 +127,5 @@ CONFIG_DEBUG_USER=y
 CONFIG_XZ_DEC=y
 CONFIG_FPGA=y
 CONFIG_FPGA_MGR_ALTERA=y
+CONFIG_FPGA_BRIDGE=y
+CONFIG_ALTERA_SOCFPGA_BRIDGE=y
diff --git a/arch/arm/mach-socfpga/socfpga.c b/arch/arm/mach-socfpga/socfpga.c
index 87ce1d5..7e9db6c 100644
--- a/arch/arm/mach-socfpga/socfpga.c
+++ b/arch/arm/mach-socfpga/socfpga.c
@@ -35,6 +35,8 @@ void __iomem *socfpga_scu_base_addr = ((void __iomem *)(SOCFPGA_SCU_VIRT_BASE));
 void __iomem *sys_manager_base_addr;
 void __iomem *rst_manager_base_addr;
 unsigned long socfpga_cpu1start_addr;
+void __iomem *sdr_ctl_base_addr;
+void __iomem *l3regs_base_addr;
 
 #ifdef CONFIG_HW_PERF_EVENTS
 static struct arm_pmu_platdata socfpga_pmu_platdata = {
@@ -156,6 +158,25 @@ void __init socfpga_sysmgr_init(void)
 
 	np = of_find_compatible_node(NULL, NULL, "altr,rst-mgr");
 	rst_manager_base_addr = of_iomap(np, 0);
+	WARN_ON(!rst_manager_base_addr);
+
+	np = of_find_compatible_node(NULL, NULL, "altr,sdr-ctl");
+	if (!np) {
+		pr_err("SOCFPGA: Unable to find sdr-ctl\n");
+		return;
+	}
+
+	sdr_ctl_base_addr = of_iomap(np, 0);
+	WARN_ON(!sdr_ctl_base_addr);
+
+	np = of_find_compatible_node(NULL, NULL, "altr,l3regs");
+	if (!np) {
+		pr_err("SOCFPGA: Unable to find l3regs\n");
+		return;
+	}
+
+	l3regs_base_addr = of_iomap(np, 0);
+	WARN_ON(!l3regs_base_addr);
 }
 
 static void __init socfpga_init_irq(void)
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 453a616..17fb257 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -566,4 +566,6 @@ source "drivers/misc/mic/Kconfig"
 source "drivers/misc/genwqe/Kconfig"
 source "drivers/misc/echo/Kconfig"
 source "drivers/misc/cxl/Kconfig"
+source "drivers/misc/fpga-bridge/Kconfig"
+
 endmenu
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 6a8e393..0b689aa 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -42,6 +42,7 @@ obj-$(CONFIG_HWLAT_DETECTOR)	+= hwlat_detector.o
 obj-$(CONFIG_SPEAR13XX_PCIE_GADGET)	+= spear13xx_pcie_gadget.o
 obj-$(CONFIG_VMWARE_BALLOON)	+= vmw_balloon.o
 obj-$(CONFIG_ARM_CHARLCD)	+= arm-charlcd.o
+obj-$(CONFIG_FPGA_BRIDGE)	+= fpga-bridge/
 obj-$(CONFIG_PCH_PHUB)		+= pch_phub.o
 obj-y				+= ti-st/
 obj-y				+= lis3lv02d/
diff --git a/drivers/misc/fpga-bridge/Kconfig b/drivers/misc/fpga-bridge/Kconfig
new file mode 100644
index 0000000..725474e
--- /dev/null
+++ b/drivers/misc/fpga-bridge/Kconfig
@@ -0,0 +1,20 @@
+#
+# FPGA bridge manager configuration
+#
+
+menu "FPGA Bridges"
+
+config FPGA_BRIDGE
+       tristate "FPGA Bridge Drivers"
+       depends on OF
+       help
+         Say Y here if you want to support bridges connected between host
+	 processors and FPGAs or between FPGAs.
+
+config ALTERA_SOCFPGA_BRIDGE
+       tristate "Altera SoCFPGA Bridges"
+       depends on FPGA_BRIDGE
+       help
+         Say Y to enable drivers for FPGA bridges for Altera socfpga
+	 devices.
+endmenu
diff --git a/drivers/misc/fpga-bridge/Makefile b/drivers/misc/fpga-bridge/Makefile
new file mode 100644
index 0000000..3700f8a
--- /dev/null
+++ b/drivers/misc/fpga-bridge/Makefile
@@ -0,0 +1,6 @@
+#
+# Makefile for the fpga-bridge drivers
+#
+
+obj-$(CONFIG_FPGA_BRIDGE)	+= fpga-bridge.o
+obj-$(CONFIG_ALTERA_SOCFPGA_BRIDGE) += altera-fpga2sdram.o altera-hps2fpga.o
\ No newline at end of file
diff --git a/drivers/misc/fpga-bridge/altera-fpga2sdram.c b/drivers/misc/fpga-bridge/altera-fpga2sdram.c
new file mode 100644
index 0000000..413fc09
--- /dev/null
+++ b/drivers/misc/fpga-bridge/altera-fpga2sdram.c
@@ -0,0 +1,216 @@
+/*
+ * FPGA to sdram Bridge Driver for Altera SoCFPGA Devices
+ *
+ *  Copyright (C) 2013 Altera Corporation, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/regmap.h>
+#include "fpga-bridge.h"
+
+#define ALT_SDR_CTL_FPGAPORTRST_OFST		0x80
+#define ALT_SDR_CTL_FPGAPORTRST_PORTRSTN_MSK	0x00003fff
+#define ALT_SDR_CTL_FPGAPORTRST_RD_SHIFT	0
+#define ALT_SDR_CTL_FPGAPORTRST_WR_SHIFT	4
+#define ALT_SDR_CTL_FPGAPORTRST_CTRL_SHIFT	8
+
+static struct of_device_id altera_fpga_of_match[];
+
+struct alt_fpga2sdram_data {
+	char	name[48];
+	struct platform_device *pdev;
+	struct device_node *np;
+	struct regmap *sdrctl;
+	int mask;
+};
+
+static int alt_fpga2sdram_enable_show(struct fpga_bridge *bridge)
+{
+	struct alt_fpga2sdram_data *priv = bridge->priv;
+	int value;
+
+	regmap_read(priv->sdrctl, ALT_SDR_CTL_FPGAPORTRST_OFST, &value);
+
+	return ((value & priv->mask) != 0);
+}
+
+static void alt_fpga2sdram_enable_set(struct fpga_bridge *bridge, bool enable)
+{
+	struct alt_fpga2sdram_data *priv = bridge->priv;
+	int value;
+
+	if (enable)
+		value = priv->mask;
+	else
+		value = 0;
+
+	regmap_update_bits(priv->sdrctl, ALT_SDR_CTL_FPGAPORTRST_OFST,
+			   priv->mask, value);
+}
+
+static int alt_fpga2sdram_get_mask(struct alt_fpga2sdram_data *priv)
+{
+	struct device_node *np = priv->np;
+	int mask, ctrl_shift, ctrl_mask;
+	u32 read, write, control[2];
+
+	if (of_property_read_u32(np, "read-port", &read)) {
+		dev_err(&priv->pdev->dev,
+			"read-port property missing\n");
+		return -EINVAL;
+	}
+	if ((read < 0) || (read > 3)) {
+		dev_err(&priv->pdev->dev,
+			"read-port property out of bounds\n");
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32(np, "write-port", &write)) {
+		dev_err(&priv->pdev->dev,
+			"write-port property invalid or missing\n");
+		return -EINVAL;
+	}
+	if ((write < 0) || (write > 3)) {
+		dev_err(&priv->pdev->dev,
+			"write-port property out of bounds\n");
+		return -EINVAL;
+	}
+
+	/* There can be 1 or 2 control ports specified */
+	if (of_property_read_u32_array(np, "control-ports", control,
+				       ARRAY_SIZE(control))) {
+		dev_err(&priv->pdev->dev,
+			"control-ports property missing\n");
+		return -EINVAL;
+	}
+	if ((control[0] < 0) || (control[0] > 5) ||
+	    (control[1] < 1) || (control[1] > 2)) {
+		dev_err(&priv->pdev->dev,
+			"control-ports property out of bounds\n");
+		return -EINVAL;
+	}
+
+	ctrl_shift = ALT_SDR_CTL_FPGAPORTRST_CTRL_SHIFT + control[0];
+
+	if (control[1] == 1)
+		ctrl_mask = 0x1;
+	else
+		ctrl_mask = 0x3;
+
+	mask = (1 << (ALT_SDR_CTL_FPGAPORTRST_RD_SHIFT + read)) |
+		(1 << (ALT_SDR_CTL_FPGAPORTRST_WR_SHIFT + write)) |
+		(ctrl_mask << ctrl_shift);
+
+	WARN_ON((mask & ALT_SDR_CTL_FPGAPORTRST_PORTRSTN_MSK) != mask);
+	priv->mask = mask;
+
+	return 0;
+}
+
+struct fpga_bridge_ops altera_fpga2sdram_br_ops = {
+	.enable_set = alt_fpga2sdram_enable_set,
+	.enable_show = alt_fpga2sdram_enable_show,
+};
+
+static struct alt_fpga2sdram_data fpga2sdram_data  = {
+	.name = "fpga2sdram",
+};
+
+static int alt_fpga_bridge_probe(struct platform_device *pdev)
+{
+	struct alt_fpga2sdram_data *priv;
+	struct alt_fpga2sdram_data *data;
+	const struct of_device_id *of_id = of_match_device(altera_fpga_of_match,
+						     &pdev->dev);
+	int ret = 0;
+
+	data = (struct alt_fpga2sdram_data *)of_id->data;
+	WARN_ON(!data);
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(struct alt_fpga2sdram_data),
+		       GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->np = pdev->dev.of_node;
+	priv->pdev = pdev;
+	priv->mask = data->mask;
+	strncpy(priv->name, data->name, ARRAY_SIZE(priv->name));
+
+	priv->sdrctl = syscon_regmap_lookup_by_compatible("altr,sdr-ctl");
+	if (IS_ERR(priv->sdrctl)) {
+		devm_kfree(&pdev->dev, priv);
+		dev_err(&priv->pdev->dev,
+			"regmap for altr,sdr-ctl lookup failed.\n");
+		return PTR_ERR(priv->sdrctl);
+	}
+
+	ret = alt_fpga2sdram_get_mask(priv);
+	if (ret) {
+		devm_kfree(&pdev->dev, priv);
+		return ret;
+	}
+
+	return register_fpga_bridge(pdev, &altera_fpga2sdram_br_ops,
+				    priv->name, priv);
+}
+
+static int alt_fpga_bridge_remove(struct platform_device *pdev)
+{
+	remove_fpga_bridge(pdev);
+	return 0;
+}
+
+static struct of_device_id altera_fpga_of_match[] = {
+	{ .compatible = "altr,socfpga-fpga2sdram-bridge", .data = &fpga2sdram_data },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, altera_fpga_of_match);
+
+static struct platform_driver altera_fpga_driver = {
+	.remove = alt_fpga_bridge_remove,
+	.driver = {
+		.name	= "altera_fpga2sdram_bridge",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(altera_fpga_of_match),
+	},
+};
+
+static int __init alt_fpga_bridge_init(void)
+{
+	return platform_driver_probe(&altera_fpga_driver,
+				     alt_fpga_bridge_probe);
+}
+
+static void __exit alt_fpga_bridge_exit(void)
+{
+	platform_driver_unregister(&altera_fpga_driver);
+}
+
+module_init(alt_fpga_bridge_init);
+module_exit(alt_fpga_bridge_exit);
+
+MODULE_DESCRIPTION("Altera SoCFPGA FPGA to SDRAM Bridge");
+MODULE_AUTHOR("Alan Tull <atull@altera.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/misc/fpga-bridge/altera-hps2fpga.c b/drivers/misc/fpga-bridge/altera-hps2fpga.c
new file mode 100644
index 0000000..76f2542
--- /dev/null
+++ b/drivers/misc/fpga-bridge/altera-hps2fpga.c
@@ -0,0 +1,178 @@
+/*
+ * FPGA to/from HPS Bridge Driver for Altera SoCFPGA Devices
+ *
+ *  Copyright (C) 2013 Altera Corporation, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/kernel.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/regmap.h>
+#include "fpga-bridge.h"
+
+#define SOCFPGA_RSTMGR_BRGMODRST		0x1c
+#define ALT_RSTMGR_BRGMODRST_H2F_MSK		0x00000001
+#define ALT_RSTMGR_BRGMODRST_LWH2F_MSK		0x00000002
+#define ALT_RSTMGR_BRGMODRST_F2H_MSK		0x00000004
+
+#define ALT_L3_REMAP_OFST			0x0
+#define ALT_L3_REMAP_H2F_MSK			0x00000008
+#define ALT_L3_REMAP_LWH2F_MSK			0x00000010
+
+static struct of_device_id altera_fpga_of_match[];
+
+struct altera_hps2fpga_data {
+	char	name[48];
+	struct platform_device *pdev;
+	struct device_node *np;
+	struct regmap *rstreg;
+	struct regmap *l3reg;
+	int mask;
+	int remap_mask;
+};
+
+static int alt_hps2fpga_enable_show(struct fpga_bridge *bridge)
+{
+	struct altera_hps2fpga_data *priv = bridge->priv;
+	unsigned int value;
+
+	regmap_read(priv->rstreg, SOCFPGA_RSTMGR_BRGMODRST, &value);
+
+	return ((value & priv->mask) == 0);
+}
+
+static void alt_hps2fpga_enable_set(struct fpga_bridge *bridge, bool enable)
+{
+	struct altera_hps2fpga_data *priv = bridge->priv;
+	int value;
+
+	if (enable)
+		value = 0;
+	else
+		value = priv->mask;
+
+	regmap_update_bits(priv->rstreg, SOCFPGA_RSTMGR_BRGMODRST,
+			   priv->mask, value);
+
+	/* Allow bridge to be visible to L3 masters or not */
+	if (priv->remap_mask) {
+		if (enable)
+			value = 0;
+		else
+			value = priv->remap_mask;
+
+		regmap_update_bits(priv->l3reg, ALT_L3_REMAP_OFST,
+				priv->remap_mask, value);
+	}
+}
+
+struct fpga_bridge_ops altera_hps2fpga_br_ops = {
+	.enable_set = alt_hps2fpga_enable_set,
+	.enable_show = alt_hps2fpga_enable_show,
+};
+
+static struct altera_hps2fpga_data hps2fpga_data  = {
+	.name = "hps2fpga",
+	.mask = ALT_RSTMGR_BRGMODRST_H2F_MSK,
+	.remap_mask = ALT_L3_REMAP_H2F_MSK,
+};
+
+static struct altera_hps2fpga_data lwhps2fpga_data  = {
+	.name = "lshps2fpga",
+	.mask = ALT_RSTMGR_BRGMODRST_LWH2F_MSK,
+	.remap_mask = ALT_L3_REMAP_LWH2F_MSK,
+};
+
+static struct altera_hps2fpga_data fpga2hps_data  = {
+	.name = "fpga2hps",
+	.mask = ALT_RSTMGR_BRGMODRST_F2H_MSK,
+};
+
+static int alt_fpga_bridge_probe(struct platform_device *pdev)
+{
+	struct altera_hps2fpga_data *priv;
+	const struct of_device_id *of_id;
+
+	of_id = of_match_device(altera_fpga_of_match, &pdev->dev);
+	priv = (struct altera_hps2fpga_data *)of_id->data;
+	WARN_ON(!priv);
+
+	priv->np = pdev->dev.of_node;
+	priv->pdev = pdev;
+
+	priv->rstreg = syscon_regmap_lookup_by_compatible("altr,rst-mgr");
+	if (IS_ERR(priv->rstreg)) {
+		dev_err(&priv->pdev->dev,
+			"regmap for altr,rst-mgr lookup failed.\n");
+		return PTR_ERR(priv->rstreg);
+	}
+
+	priv->l3reg = syscon_regmap_lookup_by_compatible("altr,l3regs");
+	if (IS_ERR(priv->l3reg)) {
+		dev_err(&priv->pdev->dev,
+			"regmap for altr,l3regs lookup failed.\n");
+		return PTR_ERR(priv->l3reg);
+	}
+
+	return register_fpga_bridge(pdev, &altera_hps2fpga_br_ops,
+				    priv->name, priv);
+}
+
+static int alt_fpga_bridge_remove(struct platform_device *pdev)
+{
+	remove_fpga_bridge(pdev);
+	return 0;
+}
+
+static struct of_device_id altera_fpga_of_match[] = {
+	{ .compatible = "altr,socfpga-hps2fpga-bridge", .data = &hps2fpga_data },
+	{ .compatible = "altr,socfpga-lwhps2fpga-bridge", .data = &lwhps2fpga_data },
+	{ .compatible = "altr,socfpga-fpga2hps-bridge", .data = &fpga2hps_data },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, altera_fpga_of_match);
+
+static struct platform_driver altera_fpga_driver = {
+	.remove = alt_fpga_bridge_remove,
+	.driver = {
+		.name	= "altera_hps2fpga_bridge",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(altera_fpga_of_match),
+	},
+};
+
+static int __init alt_fpga_bridge_init(void)
+{
+	return platform_driver_probe(&altera_fpga_driver,
+				     alt_fpga_bridge_probe);
+}
+
+static void __exit alt_fpga_bridge_exit(void)
+{
+	platform_driver_unregister(&altera_fpga_driver);
+}
+
+module_init(alt_fpga_bridge_init);
+module_exit(alt_fpga_bridge_exit);
+
+MODULE_DESCRIPTION("Altera SoCFPGA HPS to FPGA Bridge");
+MODULE_AUTHOR("Alan Tull <atull@altera.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/misc/fpga-bridge/fpga-bridge.c b/drivers/misc/fpga-bridge/fpga-bridge.c
new file mode 100644
index 0000000..a8fd7a1
--- /dev/null
+++ b/drivers/misc/fpga-bridge/fpga-bridge.c
@@ -0,0 +1,232 @@
+/*
+ * fpga bridge driver
+ *
+ *  Copyright (C) 2013 Altera Corporation, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/fs.h>
+#include <linux/idr.h>
+#include <linux/slab.h>
+#include "fpga-bridge.h"
+
+static DEFINE_IDA(fpga_bridge_ida);
+static struct class *fpga_bridge_class;
+
+#define FPGA_MAX_DEVICES	256
+
+/*
+ * class attributes
+ */
+static ssize_t fpga_bridge_enable_show(struct device *dev,
+				       struct device_attribute *attr,
+				       char *buf)
+{
+	struct fpga_bridge *bridge = dev_get_drvdata(dev);
+	int enabled;
+
+	enabled = bridge->br_ops->enable_show(bridge);
+
+	return sprintf(buf, "%d\n", enabled);
+}
+
+static ssize_t fpga_bridge_enable_set(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct fpga_bridge *bridge = dev_get_drvdata(dev);
+	bool enable;
+
+	if ((count != 1) && (count != 2))
+		return -EINVAL;
+
+	if ((count == 2) && (buf[1] != '\n'))
+		return -EINVAL;
+
+	if ((buf[0] != '0') && (buf[0] != '1'))
+		return -EINVAL;
+
+	enable = (buf[0] == '1');
+	bridge->br_ops->enable_set(bridge, enable);
+
+	return count;
+}
+
+static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR, fpga_bridge_enable_show,
+	fpga_bridge_enable_set);
+
+static struct attribute *fpga_bridge_attrs[] = {
+	&dev_attr_enable.attr,
+	NULL,
+};
+
+static const struct attribute_group fpga_bridge_group = {
+	.attrs = fpga_bridge_attrs,
+};
+
+const struct attribute_group *fpga_bridge_groups[] = {
+	&fpga_bridge_group,
+	NULL,
+};
+
+static int fpga_bridge_alloc_id(struct fpga_bridge *bridge, int request_nr)
+{
+	int nr, start;
+
+	/* check specified minor number */
+	if (request_nr >= FPGA_MAX_DEVICES) {
+		dev_err(bridge->parent,
+			"Out of device ids (%d)\n", request_nr);
+		return -ENODEV;
+	}
+
+	/*
+	 * If request_nr == -1, dynamically allocate number.
+	 * If request_nr >= 0, attempt to get specific number.
+	 */
+	if (request_nr == -1)
+		start = 0;
+	else
+		start = request_nr;
+
+	nr = ida_simple_get(&fpga_bridge_ida, start, FPGA_MAX_DEVICES,
+			    GFP_KERNEL);
+
+	/* return error code */
+	if (nr < 0)
+		return nr;
+
+	if ((request_nr != -1) && (request_nr != nr)) {
+		dev_err(bridge->parent,
+			"Could not get requested device number (%d)\n", nr);
+		ida_simple_remove(&fpga_bridge_ida, nr);
+		return -ENODEV;
+	}
+
+	bridge->nr = nr;
+
+	return 0;
+}
+
+static void fpga_bridge_free_id(int nr)
+{
+	ida_simple_remove(&fpga_bridge_ida, nr);
+}
+
+int register_fpga_bridge(struct platform_device *pdev,
+			struct fpga_bridge_ops *br_ops, char *name, void *priv)
+{
+	struct fpga_bridge *bridge;
+	const char *dt_label;
+	int enable, ret;
+
+	if (!br_ops || !br_ops->enable_set || !br_ops->enable_show) {
+		dev_err(&pdev->dev,
+			"Attempt to register without fpga_bridge_ops\n");
+		return -EINVAL;
+	}
+	if (!name || (name[0] == '\0')) {
+		dev_err(&pdev->dev, "Attempt to register with no name!\n");
+		return -EINVAL;
+	}
+
+	bridge = kzalloc(sizeof(struct fpga_bridge), GFP_KERNEL);
+	if (!bridge)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, bridge);
+	bridge->br_ops = br_ops;
+	bridge->np = pdev->dev.of_node;
+	bridge->parent = get_device(&pdev->dev);
+	bridge->priv = priv;
+
+	strlcpy(bridge->name, name, sizeof(bridge->name));
+
+	ret = fpga_bridge_alloc_id(bridge, pdev->id);
+	if (ret)
+		goto error_kfree;
+
+	dt_label = of_get_property(bridge->np, "label", NULL);
+	if (dt_label)
+		snprintf(bridge->label, sizeof(bridge->label), "%s", dt_label);
+	else
+		snprintf(bridge->label, sizeof(bridge->label),
+			 "br%d", bridge->nr);
+
+	bridge->dev = device_create(fpga_bridge_class, bridge->parent, 0,
+				    bridge, bridge->label);
+	if (IS_ERR(bridge->dev)) {
+		ret = PTR_ERR(bridge->dev);
+		goto error_device;
+	}
+
+	if (!of_property_read_u32(bridge->np, "enable", &enable))
+		br_ops->enable_set(bridge, enable);
+
+	dev_info(bridge->parent, "fpga bridge [%s] registered as device %s\n",
+		 bridge->name, bridge->label);
+
+	return 0;
+
+error_device:
+	fpga_bridge_free_id(bridge->nr);
+error_kfree:
+	put_device(bridge->parent);
+	kfree(bridge);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(register_fpga_bridge);
+
+void remove_fpga_bridge(struct platform_device *pdev)
+{
+	struct fpga_bridge *bridge = platform_get_drvdata(pdev);
+
+	if (bridge && bridge->br_ops && bridge->br_ops->fpga_bridge_remove)
+		bridge->br_ops->fpga_bridge_remove(bridge);
+
+	platform_set_drvdata(pdev, NULL);
+	device_unregister(bridge->dev);
+	fpga_bridge_free_id(bridge->nr);
+	put_device(bridge->parent);
+	kfree(bridge);
+}
+EXPORT_SYMBOL_GPL(remove_fpga_bridge);
+
+static int __init fpga_bridge_dev_init(void)
+{
+	pr_info("fpga bridge driver\n");
+
+	fpga_bridge_class = class_create(THIS_MODULE, "fpga-bridge");
+	if (IS_ERR(fpga_bridge_class))
+		return PTR_ERR(fpga_bridge_class);
+
+	fpga_bridge_class->dev_groups = fpga_bridge_groups;
+
+	return 0;
+}
+
+static void __exit fpga_bridge_dev_exit(void)
+{
+	class_destroy(fpga_bridge_class);
+	ida_destroy(&fpga_bridge_ida);
+}
+
+MODULE_DESCRIPTION("FPGA Bridge Driver");
+MODULE_AUTHOR("Alan Tull <atull@altera.com>");
+MODULE_LICENSE("GPL v2");
+
+subsys_initcall(fpga_bridge_dev_init);
+module_exit(fpga_bridge_dev_exit);
diff --git a/drivers/misc/fpga-bridge/fpga-bridge.h b/drivers/misc/fpga-bridge/fpga-bridge.h
new file mode 100644
index 0000000..58fba4d
--- /dev/null
+++ b/drivers/misc/fpga-bridge/fpga-bridge.h
@@ -0,0 +1,51 @@
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/cdev.h>
+
+#ifndef _LINUX_FPGA_BRIDGE_H
+#define _LINUX_FPGA_BRIDGE_H
+
+struct fpga_bridge;
+
+/*---------------------------------------------------------------------------*/
+
+/*
+ * fpga_bridge_ops are the low level functions implemented by a specific
+ * fpga bridge driver.
+ */
+struct fpga_bridge_ops {
+	/* Returns the FPGA bridge's status */
+	int (*enable_show)(struct fpga_bridge *bridge);
+
+	/* Enable a FPGA bridge */
+	void (*enable_set)(struct fpga_bridge *bridge, bool enable);
+
+	/* Set FPGA into a specific state during driver remove */
+	void (*fpga_bridge_remove)(struct fpga_bridge *bridge);
+};
+
+struct fpga_bridge {
+	struct device_node *np;
+	struct device *parent;
+	struct device *dev;
+	struct cdev cdev;
+
+	int nr;
+	char name[48];
+	char label[48];
+	unsigned long flags;
+	struct fpga_bridge_ops *br_ops;
+
+	void *priv;
+};
+
+#if defined(CONFIG_FPGA_BRIDGE) || defined(CONFIG_FPGA_BRIDGE_MODULE)
+
+extern int register_fpga_bridge(struct platform_device *pdev,
+				 struct fpga_bridge_ops *br_ops,
+				 char *name, void *priv);
+
+extern void remove_fpga_bridge(struct platform_device *pdev);
+
+#endif /* CONFIG_FPGA_BRIDGE */
+#endif /* _LINUX_FPGA_BRIDGE_H */
-- 
1.9.1

