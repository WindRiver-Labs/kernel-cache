From 3ed0d040160b38cc1d0311e2c58041e97ba57bec Mon Sep 17 00:00:00 2001
From: Dinh Nguyen <dinguyen@opensource.altera.com>
Date: Thu, 5 Mar 2015 15:46:40 -0600
Subject: [PATCH 112/172] FogBugz #282531-1: Add "pwr-en" dts property to
 enable the PWREN bit

The "pwr-en" property can be used to determine if the SD power enable line
should be turned on. In order to support the Arria10 Rev. A devkit, we
should be turning on/off PWREN that is cued off of "pwr-en".

This patch will assume that "pwr-en" is 1 when the property is not
populated, which will be the case for Cyclone5/Arria5 based devkits. For
the Arria10 Revision A devkit, which has a reverse PWREN logic, so we want
to leave the PWREN bit to 0, thus we need "pwr-en = <0>".

Signed-off-by: Dinh Nguyen <dinguyen@opensource.altera.com>
[czou:Original patch taken from
https://github.com/altera-opensource/linux-socfpga.git socfpga-4.1]
Signed-off-by: czou <cao.zou@windriver.com>
---
 drivers/mmc/host/dw_mmc.c  | 22 +++++++++++++++++-----
 include/linux/mmc/dw_mmc.h |  1 +
 2 files changed, 18 insertions(+), 5 deletions(-)

diff --git a/drivers/mmc/host/dw_mmc.c b/drivers/mmc/host/dw_mmc.c
index 66c2c0f..b96182a 100644
--- a/drivers/mmc/host/dw_mmc.c
+++ b/drivers/mmc/host/dw_mmc.c
@@ -1151,6 +1151,7 @@ static void dw_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 {
 	struct dw_mci_slot *slot = mmc_priv(mmc);
 	const struct dw_mci_drv_data *drv_data = slot->host->drv_data;
+	struct dw_mci *host = slot->host;
 	u32 regs;
 	int ret;
 
@@ -1202,8 +1203,11 @@ static void dw_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 		set_bit(DW_MMC_CARD_NEED_INIT, &slot->flags);
 		regs = mci_readl(slot->host, PWREN);
 		regs |= (1 << slot->id);
-		/* TEMP HACK for A10. Don't turn on the PWREN. */
-		/* mci_writel(slot->host, PWREN, regs);*/
+		if (host->pdata->pwr_en) {
+			regs = mci_readl(slot->host, PWREN);
+			regs |= (1 << slot->id);
+			mci_writel(slot->host, PWREN, regs);
+		}
 		break;
 	case MMC_POWER_ON:
 		if (!slot->host->vqmmc_enabled) {
@@ -1240,9 +1244,11 @@ static void dw_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 			regulator_disable(mmc->supply.vqmmc);
 		slot->host->vqmmc_enabled = false;
 
-		regs = mci_readl(slot->host, PWREN);
-		regs &= ~(1 << slot->id);
-		mci_writel(slot->host, PWREN, regs);
+		if (host->pdata->pwr_en) {
+			regs = mci_readl(slot->host, PWREN);
+			regs &= ~(1 << slot->id);
+			mci_writel(slot->host, PWREN, regs);
+		}
 		break;
 	default:
 		break;
@@ -2669,6 +2675,7 @@ static struct dw_mci_board *dw_mci_parse_dt(struct dw_mci *host)
 	const struct dw_mci_drv_data *drv_data = host->drv_data;
 	int idx, ret;
 	u32 clock_frequency;
+	int pwr_en;
 
 	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
 	if (!pdata)
@@ -2705,6 +2712,11 @@ static struct dw_mci_board *dw_mci_parse_dt(struct dw_mci *host)
 	if (of_find_property(np, "supports-highspeed", NULL))
 		pdata->caps |= MMC_CAP_SD_HIGHSPEED | MMC_CAP_MMC_HIGHSPEED;
 
+	if (of_property_read_u32(dev->of_node, "pwr-en", &pwr_en)) {
+		dev_dbg(dev, "couldn't determine pwr-en, assuming pwr-en = 1\n");
+		pdata->pwr_en = 1;
+	}
+
 	return pdata;
 }
 
diff --git a/include/linux/mmc/dw_mmc.h b/include/linux/mmc/dw_mmc.h
index 1211199..8c27980 100644
--- a/include/linux/mmc/dw_mmc.h
+++ b/include/linux/mmc/dw_mmc.h
@@ -259,6 +259,7 @@ struct dw_mci_board {
 	 * it.
 	 */
 	unsigned int fifo_depth;
+	int pwr_en;
 
 	/* delay in mS before detecting cards after interrupt */
 	u32 detect_delay_ms;
-- 
1.9.1

