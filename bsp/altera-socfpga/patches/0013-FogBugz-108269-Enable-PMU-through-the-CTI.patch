From b3bdd0466a9c346887b3d3e0ca59849d8b40ba76 Mon Sep 17 00:00:00 2001
From: Dinh Nguyen <dinguyen@altera.com>
Date: Wed, 20 Mar 2013 08:23:53 -0500
Subject: [PATCH 013/172] FogBugz #108269: Enable PMU through the CTI

SocFPGA has a PMU(Performance Measurement Unit) that has its
IRQs routed through Coresight using the CTI(Cross-Trigger Interface).

This patch enables the PMU and initializes the CTI for usage by
oprofile/perfmon.

Signed-off-by: Dinh Nguyen <dinguyen@altera.com>

v6:
- Reworked socfpga_pmu_handler to be bounded
- Switched from pr_err/pr_info to dev_err/dev_info
- Use np=pdev
- Add defines for CTI channels

v5:
- Add error tags to free_irq and iounmap

v4:
- Add CTI_MPU_IRQ_TRIG_IN and CTI_MPU_IRQ_TRIG_OUT defines
- Use cortex-a9-pmu as the parent node
- Wrap socfpga_pmu_platdata around CONFIG_HW_PERF_EVENTS

v3:
- Add platform functions to stop and start the CTI

V2:
- Add device tree entries for CTI
- Use platform_get_irq(pdev,1) for 2nd CTI irq
[czou:Original patch taken from
https://github.com/altera-opensource/linux-socfpga.git socfpga-4.1]
Signed-off-by: czou <cao.zou@windriver.com>
---
 arch/arm/boot/dts/socfpga.dtsi      |  18 ++++++
 arch/arm/include/asm/pmu.h          |   3 +
 arch/arm/kernel/perf_event.c        |  16 +++++
 arch/arm/mach-socfpga/Makefile      |   1 +
 arch/arm/mach-socfpga/socfpga.c     |  20 ++++++
 arch/arm/mach-socfpga/socfpga_cti.c | 125 ++++++++++++++++++++++++++++++++++++
 arch/arm/mach-socfpga/socfpga_cti.h |  16 +++++
 7 files changed, 199 insertions(+)
 create mode 100644 arch/arm/mach-socfpga/socfpga_cti.c
 create mode 100644 arch/arm/mach-socfpga/socfpga_cti.h

diff --git a/arch/arm/boot/dts/socfpga.dtsi b/arch/arm/boot/dts/socfpga.dtsi
index 02b99d0..bdf2785 100644
--- a/arch/arm/boot/dts/socfpga.dtsi
+++ b/arch/arm/boot/dts/socfpga.dtsi
@@ -679,6 +679,24 @@
 			};
 		};
 
+		pmu {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "arm,cortex-a9-pmu";
+			interrupts = <0 176 4>, <0 177 4>;
+			ranges;
+
+			cti0: cti0@ff118000 {
+				compatible = "arm,coresight-cti";
+				reg = <0xff118000 0x100>;
+			};
+
+			cti1: cti1@ff119000 {
+				compatible = "arm,coresight-cti";
+				reg = <0xff119000 0x100>;
+			};
+		};
+
 		spi0: spi@fff00000 {
 			compatible = "snps,dw-spi-mmio";
 			#address-cells = <1>;
diff --git a/arch/arm/include/asm/pmu.h b/arch/arm/include/asm/pmu.h
index 675e4ab..c5ddfa9 100644
--- a/arch/arm/include/asm/pmu.h
+++ b/arch/arm/include/asm/pmu.h
@@ -40,6 +40,9 @@ struct arm_pmu_platdata {
 				  irq_handler_t pmu_handler);
 	int (*runtime_resume)(struct device *dev);
 	int (*runtime_suspend)(struct device *dev);
+	int (*init)(struct platform_device *pdev);
+	int (*start)(struct platform_device *pdev);
+	int (*stop)(struct platform_device *pdev);
 };
 
 #ifdef CONFIG_HW_PERF_EVENTS
diff --git a/arch/arm/kernel/perf_event.c b/arch/arm/kernel/perf_event.c
index 4a86a01..47976cd 100644
--- a/arch/arm/kernel/perf_event.c
+++ b/arch/arm/kernel/perf_event.c
@@ -343,6 +343,11 @@ static irqreturn_t armpmu_dispatch_irq(int irq, void *dev)
 static void
 armpmu_release_hardware(struct arm_pmu *armpmu)
 {
+	struct platform_device *plat_device = armpmu->plat_device;
+	struct arm_pmu_platdata *plat = dev_get_platdata(&plat_device->dev);
+
+	if (plat->stop)
+		plat->stop(plat_device);
 	armpmu->free_irq(armpmu);
 	pm_runtime_put_sync(&armpmu->plat_device->dev);
 }
@@ -352,6 +357,7 @@ armpmu_reserve_hardware(struct arm_pmu *armpmu)
 {
 	int err;
 	struct platform_device *pmu_device = armpmu->plat_device;
+	struct arm_pmu_platdata *plat = dev_get_platdata(&pmu_device->dev);
 
 	if (!pmu_device)
 		return -ENODEV;
@@ -362,6 +368,8 @@ armpmu_reserve_hardware(struct arm_pmu *armpmu)
 		armpmu_release_hardware(armpmu);
 		return err;
 	}
+	if (plat->start)
+		plat->start(pmu_device);
 
 	return 0;
 }
@@ -544,10 +552,18 @@ static void armpmu_init(struct arm_pmu *armpmu)
 
 int armpmu_register(struct arm_pmu *armpmu, int type)
 {
+	struct platform_device *plat_device = armpmu->plat_device;
+	struct arm_pmu_platdata *plat = dev_get_platdata(&plat_device->dev);
+
 	armpmu_init(armpmu);
 	pm_runtime_enable(&armpmu->plat_device->dev);
 	pr_info("enabled with %s PMU driver, %d counters available\n",
 			armpmu->name, armpmu->num_events);
+
+	/* Platform specific initialization. ie. CTI enable */
+	if (plat->init)
+		plat->init(plat_device);
+
 	return perf_pmu_register(&armpmu->pmu, armpmu->name, type);
 }
 
diff --git a/arch/arm/mach-socfpga/Makefile b/arch/arm/mach-socfpga/Makefile
index 6dd7a93..c7401d3 100644
--- a/arch/arm/mach-socfpga/Makefile
+++ b/arch/arm/mach-socfpga/Makefile
@@ -4,3 +4,4 @@
 
 obj-y					:= socfpga.o
 obj-$(CONFIG_SMP)	+= headsmp.o platsmp.o
+obj-$(CONFIG_HW_PERF_EVENTS) += socfpga_cti.o
diff --git a/arch/arm/mach-socfpga/socfpga.c b/arch/arm/mach-socfpga/socfpga.c
index 49537b0..87ce1d5 100644
--- a/arch/arm/mach-socfpga/socfpga.c
+++ b/arch/arm/mach-socfpga/socfpga.c
@@ -26,14 +26,32 @@
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
 #include <asm/cacheflush.h>
+#include <asm/pmu.h>
 
 #include "core.h"
+#include "socfpga_cti.h"
 
 void __iomem *socfpga_scu_base_addr = ((void __iomem *)(SOCFPGA_SCU_VIRT_BASE));
 void __iomem *sys_manager_base_addr;
 void __iomem *rst_manager_base_addr;
 unsigned long socfpga_cpu1start_addr;
 
+#ifdef CONFIG_HW_PERF_EVENTS
+static struct arm_pmu_platdata socfpga_pmu_platdata = {
+	.handle_irq = socfpga_pmu_handler,
+	.init = socfpga_init_cti,
+	.start = socfpga_start_cti,
+	.stop = socfpga_stop_cti,
+};
+#endif
+
+static const struct of_dev_auxdata socfpga_auxdata_lookup[] __initconst = {
+#ifdef CONFIG_HW_PERF_EVENTS
+	OF_DEV_AUXDATA("arm,cortex-a9-pmu", 0, "arm-pmu", &socfpga_pmu_platdata),
+#endif
+	{ /* sentinel */ }
+};
+
 static struct map_desc scu_io_desc __initdata = {
 	.virtual	= SOCFPGA_SCU_VIRT_BASE,
 	.pfn		= 0, /* run-time */
@@ -161,6 +179,8 @@ static void socfpga_cyclone5_restart(enum reboot_mode mode, const char *cmd)
 
 static void __init socfpga_cyclone5_init(void)
 {
+	of_platform_populate(NULL, of_default_bus_match_table,
+				socfpga_auxdata_lookup, NULL);
 	enable_periphs();
 	socfpga_soc_device_init();
 }
diff --git a/arch/arm/mach-socfpga/socfpga_cti.c b/arch/arm/mach-socfpga/socfpga_cti.c
new file mode 100644
index 0000000..10072c8
--- /dev/null
+++ b/arch/arm/mach-socfpga/socfpga_cti.c
@@ -0,0 +1,125 @@
+/*
+ *  Copyright (C) 2013 Altera Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/platform_device.h>
+#include <linux/of_address.h>
+#include <asm/mach/map.h>
+#include <asm/cti.h>
+#include <asm/pmu.h>
+
+#include "core.h"
+#include "socfpga_cti.h"
+
+#define SOCFPGA_NUM_CTI	2
+
+struct cti socfpga_cti_data[SOCFPGA_NUM_CTI];
+
+irqreturn_t socfpga_pmu_handler(int irq, void *dev, irq_handler_t handler)
+{
+	unsigned int handled = 0;
+	int i;
+
+	for (i = 0; i < SOCFPGA_NUM_CTI; i++)
+		if (irq == socfpga_cti_data[i].irq) {
+			cti_irq_ack(&socfpga_cti_data[i]);
+			handled = handler(irq, dev);
+		}
+
+	return IRQ_RETVAL(handled);
+}
+
+int socfpga_init_cti(struct platform_device *pdev)
+{
+	struct device_node *np, *np2;
+	void __iomem *cti0_addr;
+	void __iomem *cti1_addr;
+	u32 irq0, irq1;
+
+	np = pdev->dev.of_node;
+	np2 = of_find_compatible_node(np, NULL, "arm,coresight-cti");
+	if (!np2) {
+		dev_err(&pdev->dev, "PMU: Unable to find coresight-cti\n");
+		return -1;
+	}
+	cti0_addr = of_iomap(np2, 0);
+	if (!cti0_addr) {
+		dev_err(&pdev->dev, "PMU: ioremap for CTI failed\n");
+		return -1;
+	}
+
+	irq0 = platform_get_irq(pdev, 0);
+	if (irq0 < 0)
+		goto free_irq0;
+
+	np2 = of_find_compatible_node(np2, NULL, "arm,coresight-cti");
+	if (!np2) {
+		dev_err(&pdev->dev, "PMU: Unable to find coresight-cti\n");
+		goto err_iounmap;
+	}
+	cti1_addr = of_iomap(np2, 0);
+	if (!cti1_addr)
+		goto err_iounmap;
+
+	irq1 = platform_get_irq(pdev, 1);
+	if (irq1 < 0)
+		goto free_irq1;
+
+	/*configure CTI0 for pmu irq routing*/
+	cti_init(&socfpga_cti_data[0], cti0_addr,
+		irq0, CTI_MPU_IRQ_TRIG_OUT);
+	cti_unlock(&socfpga_cti_data[0]);
+	cti_map_trigger(&socfpga_cti_data[0],
+		CTI_MPU_IRQ_TRIG_IN, CTI_MPU_IRQ_TRIG_OUT, PMU_CHANNEL_0);
+
+	/*configure CTI1 for pmu irq routing*/
+	cti_init(&socfpga_cti_data[1], cti1_addr,
+		irq1, CTI_MPU_IRQ_TRIG_OUT);
+	cti_unlock(&socfpga_cti_data[1]);
+	cti_map_trigger(&socfpga_cti_data[1],
+		CTI_MPU_IRQ_TRIG_IN, CTI_MPU_IRQ_TRIG_OUT, PMU_CHANNEL_1);
+
+	dev_info(&pdev->dev, "PMU:CTI successfully enabled\n");
+	return 0;
+
+free_irq1:
+	iounmap(cti1_addr);
+err_iounmap:
+	free_irq(irq0, pdev);
+free_irq0:
+	iounmap(cti0_addr);
+	return -1;
+}
+
+int socfpga_start_cti(struct platform_device *pdev)
+{
+	int i;
+
+	for (i = 0; i < SOCFPGA_NUM_CTI; i++)
+		cti_enable(&socfpga_cti_data[i]);
+
+	return 0;
+}
+
+int socfpga_stop_cti(struct platform_device *pdev)
+{
+	int i;
+
+	for (i = 0; i < SOCFPGA_NUM_CTI; i++)
+		cti_disable(&socfpga_cti_data[i]);
+
+	return 0;
+}
+
diff --git a/arch/arm/mach-socfpga/socfpga_cti.h b/arch/arm/mach-socfpga/socfpga_cti.h
new file mode 100644
index 0000000..cbeb063
--- /dev/null
+++ b/arch/arm/mach-socfpga/socfpga_cti.h
@@ -0,0 +1,16 @@
+#ifndef __SOCFPGA_CTI_H
+#define __SOCFPGA_CTI_H
+
+#define CTI_MPU_IRQ_TRIG_IN	1
+#define CTI_MPU_IRQ_TRIG_OUT	6
+
+#define PMU_CHANNEL_0	0
+#define PMU_CHANNEL_1	1
+
+#ifdef CONFIG_HW_PERF_EVENTS
+extern irqreturn_t socfpga_pmu_handler(int irq, void *dev, irq_handler_t handler);
+extern int socfpga_init_cti(struct platform_device *pdev);
+extern int socfpga_start_cti(struct platform_device *pdev);
+extern int socfpga_stop_cti(struct platform_device *pdev);
+#endif
+#endif /* __SOCFPGA_CTI_H */
-- 
1.9.1

