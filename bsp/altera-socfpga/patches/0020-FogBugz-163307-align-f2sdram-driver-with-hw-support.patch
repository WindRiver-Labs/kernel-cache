From 7212c60a88c4d8532c096a37d064cece9d9c3234 Mon Sep 17 00:00:00 2001
From: Matthew Gerlach <mgerlach@altera.com>
Date: Wed, 23 Oct 2013 14:11:47 -0700
Subject: [PATCH 020/172] FogBugz #163307: align f2sdram driver with hw support

The read, write, and command ports on the fpga2sdram
bridge can only be reconfigured if there are no
transactions to the sdram during the reconfiguration.
Currently, this guarantee can only be made by code
running out of onchip ram before Linux is started.  Therefore,
this driver only supports enabling and disabling of the
ports that have already been configured.  Since the
driver cannot determine the port configuration in all
cases, the device tree must be populated with masks for
all of the ports.

Signed-off-by: Matthew Gerlach <mgerlach@altera.com>
[czou:Original patch taken from
https://github.com/altera-opensource/linux-socfpga.git socfpga-4.1]
Signed-off-by: czou <cao.zou@windriver.com>
---
 .../bindings/fpga/altera-fpga-bridge.txt           | 74 ----------------
 .../bindings/fpga/altera-fpga2sdram-bridge.txt     | 47 ++++++++++
 .../bindings/fpga/altera-hps2fpga-bridge.txt       | 39 +++++++++
 drivers/misc/fpga-bridge/altera-fpga2sdram.c       | 99 ++++++++++------------
 4 files changed, 132 insertions(+), 127 deletions(-)
 delete mode 100644 Documentation/devicetree/bindings/fpga/altera-fpga-bridge.txt
 create mode 100644 Documentation/devicetree/bindings/fpga/altera-fpga2sdram-bridge.txt
 create mode 100644 Documentation/devicetree/bindings/fpga/altera-hps2fpga-bridge.txt

diff --git a/Documentation/devicetree/bindings/fpga/altera-fpga-bridge.txt b/Documentation/devicetree/bindings/fpga/altera-fpga-bridge.txt
deleted file mode 100644
index 569d898..0000000
--- a/Documentation/devicetree/bindings/fpga/altera-fpga-bridge.txt
+++ /dev/null
@@ -1,74 +0,0 @@
-Altera FPGA Bridge Driver
-
-Required properties:
-
-  - compatible : should be "<manufacturer>,<type>"
-                 "altr,socfpga-fpga2sdram-bridge"
-		 "altr,socfpga-hps2fpga-bridge"
-		 "altr,socfpga-lwhps2fpga-bridge"
-		 "altr,socfpga-fpga2hps-bridge"
-
-Required for fpga2sdram bridge only:
-  - read-port  : which read port is used for this bridge (0-3)
-  - write-port : which write port is used for this bridge (0-3)
-  - control-ports : which conrtol port(s) are used for this bridge.
-                    index 0 is first port # (0-5)
-		    index 1 is number of ports used (1-2)
-
-Required for hps2fpga, lwhps2fpga, and fpga2hps:
-  - clocks     : clocks used by this module
-
-Optional properties:
-  - label      : name that you want this bridge to show up as under /sys
-                 Default is br<device#> if this is not specified
-
-Example:
-	hps_fpgabridge0: fpgabridge@0 {
-		compatible = "altr,socfpga-hps2fpga-bridge";
-		label = "hps2fpga";
-		clocks = <&l4_main_clk>;
-	};
-
-	hps_fpgabridge1: fpgabridge@1 {
-		compatible = "altr,socfpga-lwhps2fpga-bridge";
-		label = "lwhps2fpga";
-		clocks = <&l4_main_clk>;
-	};
-
-	hps_fpgabridge2: fpgabridge@2 {
-		compatible = "altr,socfpga-fpga2hps-bridge";
-		label = "fpga2hps";
-		clocks = <&l4_main_clk>;
-	};
-
-	hps_fpgabridge3: fpgabridge@3 {
-		compatible = "altr,socfpga-fpga2sdram-bridge";
-		label = "fpga2sdram0";
-		read-port = <0>;
-		write-port = <0>;
-		control-ports = <0 2>; /* ports 0 and 1 */
-	};
-
-	hps_fpgabridge4: fpgabridge@4 {
-		compatible = "altr,socfpga-fpga2sdram-bridge";
-		label = "fpga2sdram1";
-		read-port = <1>;
-		write-port = <1>;
-		control-ports = <2 1>; /* port 2 only */
-	};
-
-	hps_fpgabridge5: fpgabridge@5 {
-		compatible = "altr,socfpga-fpga2sdram-bridge";
-		label = "fpga2sdram2";
-		read-port = <2>;
-		write-port = <2>;
-		control-ports = <3 1>; /* port 3 only */
-	};
-
-	hps_fpgabridge6: fpgabridge@6 {
-		compatible = "altr,socfpga-fpga2sdram-bridge";
-		label = "fpga2sdram3";
-		read-port = <3>;
-		write-port = <3>;
-		control-ports = <4 2>; /* ports 4 and 5 */
-	};
diff --git a/Documentation/devicetree/bindings/fpga/altera-fpga2sdram-bridge.txt b/Documentation/devicetree/bindings/fpga/altera-fpga2sdram-bridge.txt
new file mode 100644
index 0000000..ce7184b0
--- /dev/null
+++ b/Documentation/devicetree/bindings/fpga/altera-fpga2sdram-bridge.txt
@@ -0,0 +1,47 @@
+Altera FPGA To SDRAM Bridge Driver
+
+    This driver manages a bridge between an FPGA and the SDRAM used by an
+    host processor system (HPS). The bridge contains a number read ports,
+    write ports, and command ports.  Reconfiguring these ports requires
+    that no SDRAM transactions occur during reconfiguration.  In other words,
+    the code reconfiguring the ports cannot be run out of SDRAM nor can the
+    FPGA access the SDRAM during the reconfiguration.  This driver does not
+    support reconfiguring the ports.  Typcially, the ports are configured by
+    code running out of onchip ram before Linux is started.
+
+    This driver supports enabling and disabling of the configured ports all
+    at once, which allows for safe reprogramming of the FPGA from user space,
+    provided the new FPGA image uses the same port configuration.
+    User space can enable/disable the bridge by writing a "1" or a "0",
+    respectively, to its enable file under bridge's entry in
+    /sys/class/fpga-bridge. Typically, one disables the bridges before
+    reprogramming the FPGA.  Once the FPGA is reprogrammed, the bridges
+    are reenabled.
+
+Required properties:
+
+    - compatible : "altr,socfpga-fpga2sdram-bridge"
+
+    - read-ports-mask : Bits 0 to 3 corresponds read ports 0 to 3. A
+	bit set to 1 indicates the corresponding read port should be enabled.
+
+    - write-ports-mask : Bits 0 to 3 corresponds write ports 0 to 3. A
+	bit set to 1 indicates the corresponding write port should be enabled.
+
+    - cmd-ports-mask : Bits 0 to 5 correspond to command ports 0 to 5. A
+	bit set to 1 indicates the corresponding command port should be enabled.
+
+Optional properties:
+
+    - label : name that you want this bridge to show up as under
+	/sys/class/fpga-bridge.
+	Default is br<device#> if this is not specified
+
+Example:
+	fpga2sdram_br: fpgabridge@3 {
+		compatible = "altr,socfpga-fpga2sdram-bridge";
+		label = "fpga2sdram";
+		read-ports-mask = <3>;
+		write-ports-mask = <3>;
+		cmd-ports-mask = <0xd>;
+	};
diff --git a/Documentation/devicetree/bindings/fpga/altera-hps2fpga-bridge.txt b/Documentation/devicetree/bindings/fpga/altera-hps2fpga-bridge.txt
new file mode 100644
index 0000000..6b365ef
--- /dev/null
+++ b/Documentation/devicetree/bindings/fpga/altera-hps2fpga-bridge.txt
@@ -0,0 +1,39 @@
+Altera FPGA/HPS  Bridge Driver
+
+    This driver manages a bridge between a FPGA and a host processor system
+    (HPS).  User space can enable/disable the bridge by writing a "1" or a "0",
+    respectively, to its enable file under bridge's entry in
+    /sys/class/fpga-bridge.  Typically, one disables the bridges before
+    reprogramming the FPGA.  Once the FPGA is reprogrammed, the bridges
+    are reenabled.
+
+Required properties:
+
+  - compatible : "altr,socfpga-hps2fpga-bridge"
+		 "altr,socfpga-lwhps2fpga-bridge"
+		 "altr,socfpga-fpga2hps-bridge"
+
+  - clocks : clocks used by this module
+
+Optional properties:
+  - label : name that you want this bridge to show up as under
+	/sys/class/fpga-bridge.  Default is br<device#> if this is not specified
+
+Example:
+	hps_fpgabridge0: fpgabridge@0 {
+		compatible = "altr,socfpga-hps2fpga-bridge";
+		label = "hps2fpga";
+		clocks = <&l4_main_clk>;
+	};
+
+	hps_fpgabridge1: fpgabridge@1 {
+		compatible = "altr,socfpga-lwhps2fpga-bridge";
+		label = "lwhps2fpga";
+		clocks = <&l4_main_clk>;
+	};
+
+	hps_fpgabridge2: fpgabridge@2 {
+		compatible = "altr,socfpga-fpga2hps-bridge";
+		label = "fpga2hps";
+		clocks = <&l4_main_clk>;
+	};
diff --git a/drivers/misc/fpga-bridge/altera-fpga2sdram.c b/drivers/misc/fpga-bridge/altera-fpga2sdram.c
index 413fc09..213dcf7 100644
--- a/drivers/misc/fpga-bridge/altera-fpga2sdram.c
+++ b/drivers/misc/fpga-bridge/altera-fpga2sdram.c
@@ -34,6 +34,9 @@
 #define ALT_SDR_CTL_FPGAPORTRST_WR_SHIFT	4
 #define ALT_SDR_CTL_FPGAPORTRST_CTRL_SHIFT	8
 
+#define FOUR_BIT_MASK 0xf
+#define SIX_BIT_MASK 0x3f
+
 static struct of_device_id altera_fpga_of_match[];
 
 struct alt_fpga2sdram_data {
@@ -44,6 +47,8 @@ struct alt_fpga2sdram_data {
 	int mask;
 };
 
+static atomic_t instances;
+
 static int alt_fpga2sdram_enable_show(struct fpga_bridge *bridge)
 {
 	struct alt_fpga2sdram_data *priv = bridge->priv;
@@ -51,7 +56,7 @@ static int alt_fpga2sdram_enable_show(struct fpga_bridge *bridge)
 
 	regmap_read(priv->sdrctl, ALT_SDR_CTL_FPGAPORTRST_OFST, &value);
 
-	return ((value & priv->mask) != 0);
+	return ((value & priv->mask) == priv->mask);
 }
 
 static void alt_fpga2sdram_enable_set(struct fpga_bridge *bridge, bool enable)
@@ -68,61 +73,41 @@ static void alt_fpga2sdram_enable_set(struct fpga_bridge *bridge, bool enable)
 			   priv->mask, value);
 }
 
+struct prop_map {
+	char *prop_name;
+	uint32_t *prop_value;
+	uint32_t prop_max;
+};
 static int alt_fpga2sdram_get_mask(struct alt_fpga2sdram_data *priv)
 {
-	struct device_node *np = priv->np;
-	int mask, ctrl_shift, ctrl_mask;
-	u32 read, write, control[2];
-
-	if (of_property_read_u32(np, "read-port", &read)) {
-		dev_err(&priv->pdev->dev,
-			"read-port property missing\n");
-		return -EINVAL;
-	}
-	if ((read < 0) || (read > 3)) {
-		dev_err(&priv->pdev->dev,
-			"read-port property out of bounds\n");
-		return -EINVAL;
+	int i;
+	uint32_t read, write, cmd;
+	struct prop_map map[] = {
+		{"read-ports-mask", &read, FOUR_BIT_MASK},
+		{"write-ports-mask", &write, FOUR_BIT_MASK},
+		{"cmd-ports-mask", &cmd, SIX_BIT_MASK},
+	};
+	for (i = 0; i < ARRAY_SIZE(map); i++) {
+		if (of_property_read_u32(priv->np, map[i].prop_name,
+			map[i].prop_value)) {
+			dev_err(&priv->pdev->dev,
+				"failed to find property, %s\n",
+				map[i].prop_name);
+			return -EINVAL;
+		} else if (*map[i].prop_value > map[i].prop_max) {
+			dev_err(&priv->pdev->dev,
+				"%s value 0x%x > than max 0x%x\n",
+				map[i].prop_name,
+				*map[i].prop_value,
+				map[i].prop_max);
+			return -EINVAL;
+		}
 	}
 
-	if (of_property_read_u32(np, "write-port", &write)) {
-		dev_err(&priv->pdev->dev,
-			"write-port property invalid or missing\n");
-		return -EINVAL;
-	}
-	if ((write < 0) || (write > 3)) {
-		dev_err(&priv->pdev->dev,
-			"write-port property out of bounds\n");
-		return -EINVAL;
-	}
-
-	/* There can be 1 or 2 control ports specified */
-	if (of_property_read_u32_array(np, "control-ports", control,
-				       ARRAY_SIZE(control))) {
-		dev_err(&priv->pdev->dev,
-			"control-ports property missing\n");
-		return -EINVAL;
-	}
-	if ((control[0] < 0) || (control[0] > 5) ||
-	    (control[1] < 1) || (control[1] > 2)) {
-		dev_err(&priv->pdev->dev,
-			"control-ports property out of bounds\n");
-		return -EINVAL;
-	}
-
-	ctrl_shift = ALT_SDR_CTL_FPGAPORTRST_CTRL_SHIFT + control[0];
-
-	if (control[1] == 1)
-		ctrl_mask = 0x1;
-	else
-		ctrl_mask = 0x3;
-
-	mask = (1 << (ALT_SDR_CTL_FPGAPORTRST_RD_SHIFT + read)) |
-		(1 << (ALT_SDR_CTL_FPGAPORTRST_WR_SHIFT + write)) |
-		(ctrl_mask << ctrl_shift);
-
-	WARN_ON((mask & ALT_SDR_CTL_FPGAPORTRST_PORTRSTN_MSK) != mask);
-	priv->mask = mask;
+	priv->mask =
+		(read << ALT_SDR_CTL_FPGAPORTRST_RD_SHIFT) |
+		(write << ALT_SDR_CTL_FPGAPORTRST_WR_SHIFT) |
+		(cmd << ALT_SDR_CTL_FPGAPORTRST_CTRL_SHIFT);
 
 	return 0;
 }
@@ -143,6 +128,12 @@ static int alt_fpga_bridge_probe(struct platform_device *pdev)
 	const struct of_device_id *of_id = of_match_device(altera_fpga_of_match,
 						     &pdev->dev);
 	int ret = 0;
+	if (atomic_inc_return(&instances) > 1) {
+		atomic_dec(&instances);
+		dev_err(&pdev->dev,
+			"already one instance of driver\n");
+		return -ENODEV;
+	}
 
 	data = (struct alt_fpga2sdram_data *)of_id->data;
 	WARN_ON(!data);
@@ -160,7 +151,7 @@ static int alt_fpga_bridge_probe(struct platform_device *pdev)
 	priv->sdrctl = syscon_regmap_lookup_by_compatible("altr,sdr-ctl");
 	if (IS_ERR(priv->sdrctl)) {
 		devm_kfree(&pdev->dev, priv);
-		dev_err(&priv->pdev->dev,
+		dev_err(&pdev->dev,
 			"regmap for altr,sdr-ctl lookup failed.\n");
 		return PTR_ERR(priv->sdrctl);
 	}
@@ -178,6 +169,7 @@ static int alt_fpga_bridge_probe(struct platform_device *pdev)
 static int alt_fpga_bridge_remove(struct platform_device *pdev)
 {
 	remove_fpga_bridge(pdev);
+	atomic_dec(&instances);
 	return 0;
 }
 
@@ -199,6 +191,7 @@ static struct platform_driver altera_fpga_driver = {
 
 static int __init alt_fpga_bridge_init(void)
 {
+	atomic_set(&instances, 0);
 	return platform_driver_probe(&altera_fpga_driver,
 				     alt_fpga_bridge_probe);
 }
-- 
1.9.1

