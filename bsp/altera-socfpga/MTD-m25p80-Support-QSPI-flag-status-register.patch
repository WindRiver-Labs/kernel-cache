From 6c43c08bca64d65ed52294d9820129aeb9d5faaa Mon Sep 17 00:00:00 2001
From: graham <grmoore@altera.com>
Date: Fri, 28 Jun 2013 10:33:30 -0500
Subject: [PATCH 2/4] MTD: m25p80: Support QSPI flag status register

The original commit comes from:

git://git.rocketboards.org/linux-socfpga.git

Support the flag status register.
Loadable module support.
Configurable read delay.

Signed-off-by: graham <grmoore@altera.com>
(cherry picked from commit 58ee0066fc6761d3f818fe7f6cbd3accc15f5497)

Conflicts:
	drivers/spi/Makefile
---
 drivers/spi/Makefile               |    3 +-
 drivers/spi/spi-cadence-qspi-apb.c |  161 +++++++++++++++++++++++++++++++-----
 drivers/spi/spi-cadence-qspi-apb.h |    1 +
 drivers/spi/spi-cadence-qspi.c     |   23 +++++-
 drivers/spi/spi-cadence-qspi.h     |    1 +
 5 files changed, 163 insertions(+), 26 deletions(-)

diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 2c0b2d5..eb24d58c 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -20,7 +20,8 @@ obj-$(CONFIG_SPI_BFIN_SPORT)		+= spi-bfin-sport.o
 obj-$(CONFIG_SPI_BITBANG)		+= spi-bitbang.o
 obj-$(CONFIG_SPI_BUTTERFLY)		+= spi-butterfly.o
 obj-$(CONFIG_SPI_CLPS711X)		+= spi-clps711x.o
-obj-$(CONFIG_SPI_CADENCE_QSPI)		+= spi-cadence-qspi-apb.o spi-cadence-qspi.o
+obj-$(CONFIG_SPI_CADENCE_QSPI)		+= spi-cadence-qspi-mod.o
+spi-cadence-qspi-mod-objs		:= spi-cadence-qspi-apb.o spi-cadence-qspi.o
 obj-$(CONFIG_SPI_COLDFIRE_QSPI)		+= spi-coldfire-qspi.o
 obj-$(CONFIG_SPI_DAVINCI)		+= spi-davinci.o
 obj-$(CONFIG_SPI_DESIGNWARE)		+= spi-dw.o
diff --git a/drivers/spi/spi-cadence-qspi-apb.c b/drivers/spi/spi-cadence-qspi-apb.c
index 275ef28..921d550 100644
--- a/drivers/spi/spi-cadence-qspi-apb.c
+++ b/drivers/spi/spi-cadence-qspi-apb.c
@@ -39,11 +39,70 @@
 #include "spi-cadence-qspi.h"
 #include "spi-cadence-qspi-apb.h"
 
+/****************************************************************************/
+
+#include <linux/ctype.h>
+
+typedef int (*PRINTF_FUNC)(const char *fmt, ...);
+
+#ifdef DEBUG
+static void __hex_dump(unsigned int address_to_print,
+	const unsigned char *buffer,
+	int length,
+	PRINTF_FUNC _printfunc)
+{
+	int i;
+	int j;
+	for (i = 0; i < length; i += 16) {
+		_printfunc("%08x: ", address_to_print+i);
+		for (j = 0; j < 8; j++) {
+			if ((i+j) < length)
+				_printfunc("%02x ", buffer[i+j]);
+			else
+				_printfunc("   ");
+		}
+		_printfunc(" ");
+		for (j = 8; j < 16; j++) {
+			if ((i+j) < length)
+				_printfunc("%02x ", buffer[i+j]);
+			else
+				_printfunc("   ");
+		}
+		_printfunc("  ");
+		for (j = 0; j < 16; j++) {
+			if ((i+j) < length)
+				_printfunc("%c",
+					isprint(buffer[i+j]) ?
+					buffer[i+j] : '.');
+			else
+				break;
+		}
+		_printfunc("\n");
+	}
+}
+#endif /* #ifdef DEBUG */
+
+#ifdef DEBUG
+#define hex_dump(a, b, c) __hex_dump(a, b, c, (PRINTF_FUNC)&printk)
+#else
+#define hex_dump(a, b, c)
+#endif
+
+
+/****************************************************************************/
+
+
+void cadence_qspi_apb_delay(struct struct_cqspi *cadence_qspi,
+	unsigned int ref_clk, unsigned int sclk_hz);
+
 static unsigned int cadence_qspi_apb_cmd2addr(const unsigned char* addr_buf,
 	unsigned int addr_width)
 {
 	unsigned int addr;
 
+	pr_debug("%s addr_buf %p addr_width %d\n",
+		__func__, addr_buf, addr_width);
+
 	addr = (addr_buf[0] << 16) | (addr_buf[1] << 8) | addr_buf[2];
 
 	if (addr_width == 4)
@@ -129,7 +188,7 @@ static void cadence_qspi_apb_readdata_capture(void *reg_base,
 {
 	unsigned int reg;
 
-	cadence_qspi_apb_controller_disable(reg_base);
+	pr_debug("%s %d %d\n", __func__, bypass, delay);
 	reg = CQSPI_READL(reg_base + CQSPI_REG_READCAPTURE);
 
 	if (bypass) {
@@ -146,7 +205,6 @@ static void cadence_qspi_apb_readdata_capture(void *reg_base,
 
 	CQSPI_WRITEL(reg, reg_base + CQSPI_REG_READCAPTURE);
 
-	cadence_qspi_apb_controller_enable(reg_base);
 	return;
 }
 
@@ -156,7 +214,8 @@ static void cadence_qspi_apb_config_baudrate_div(void *reg_base,
 	unsigned int reg;
 	unsigned int div;
 
-	cadence_qspi_apb_controller_disable(reg_base);
+	pr_debug("%s %d %d\n", __func__, ref_clk_hz, sclk_hz);
+
 	reg = CQSPI_READL(reg_base + CQSPI_REG_CONFIG);
 	reg &= ~(CQSPI_REG_CONFIG_BAUD_MASK << CQSPI_REG_CONFIG_BAUD_LSB);
 
@@ -179,7 +238,6 @@ static void cadence_qspi_apb_config_baudrate_div(void *reg_base,
 	reg |= div;
 	CQSPI_WRITEL(reg, reg_base + CQSPI_REG_CONFIG);
 
-	cadence_qspi_apb_controller_enable(reg_base);
 	return;
 }
 
@@ -188,7 +246,7 @@ static void cadence_qspi_apb_chipselect(void * reg_base,
 {
 	unsigned int reg;
 
-	cadence_qspi_apb_controller_disable(reg_base);
+	pr_debug("%s\n", __func__);
 
 	pr_debug("QSPI: chipselect %d decode %d\n", chip_select,
 		decoder_enable);
@@ -215,7 +273,6 @@ static void cadence_qspi_apb_chipselect(void * reg_base,
 			<< CQSPI_REG_CONFIG_CHIPSELECT_LSB;
 	CQSPI_WRITEL(reg, reg_base + CQSPI_REG_CONFIG);
 
-	cadence_qspi_apb_controller_enable(reg_base);
 	return;
 }
 
@@ -259,6 +316,10 @@ static int cadence_qspi_apb_command_read(void *reg_base,
 	unsigned int read_len;
 	int status;
 
+	pr_debug("%s txlen %d txbuf %p rxlen %d rxbuf %p\n",
+		__func__, txlen, txbuf, rxlen, rxbuf);
+	hex_dump((unsigned int)txbuf, txbuf, txlen);
+
 	if (!rxlen || rxlen > CQSPI_STIG_DATA_LEN_MAX || rxbuf == NULL) {
 		pr_err("QSPI: Invalid input argument, len %d rxbuf 0x%08x\n",
 			rxlen, (unsigned int)rxbuf);
@@ -281,6 +342,7 @@ static int cadence_qspi_apb_command_read(void *reg_base,
 	/* Put the read value into rx_buf */
 	read_len = (rxlen > 4) ? 4 : rxlen;
 	memcpy(rxbuf, &reg, read_len);
+	hex_dump((unsigned int)rxbuf, rxbuf, read_len);
 	rxbuf += read_len;
 
 	if (rxlen > 4) {
@@ -288,6 +350,7 @@ static int cadence_qspi_apb_command_read(void *reg_base,
 
 		read_len = rxlen - read_len;
 		memcpy(rxbuf, &reg, read_len);
+		hex_dump((unsigned int)rxbuf, rxbuf, read_len);
 	}
 
 	return 0;
@@ -301,6 +364,9 @@ static int cadence_qspi_apb_command_write(void *reg_base, unsigned txlen,
 	unsigned int addr_value;
 	unsigned int data;
 
+	pr_debug("%s txlen %d txbuf %p\n", __func__, txlen, txbuf);
+	hex_dump((unsigned int)txbuf, txbuf, txlen);
+
 	if (!txlen || txlen > 5 || txbuf == NULL) {
 		pr_err("QSPI: Invalid input argument, cmdlen %d txbuf 0x%08x\n",
 			txlen, (unsigned int)txbuf);
@@ -343,6 +409,10 @@ static int cadence_qspi_apb_indirect_read_setup(void *reg_base,
 	unsigned int dummy_clk;
 	unsigned int dummy_bytes;
 
+	pr_debug("%s txlen %d txbuf %p addr_bytes %d\n",
+		__func__, txlen, txbuf, addr_bytes);
+	hex_dump((unsigned int)txbuf, txbuf, txlen);
+
 	if ((addr_bytes == 3 && txlen < 4) || (addr_bytes == 4 && txlen < 5)) {
 		pr_err("QSPI: Invalid txbuf length, length %d\n", txlen);
 		return -EINVAL;
@@ -354,6 +424,7 @@ static int cadence_qspi_apb_indirect_read_setup(void *reg_base,
 	reg = txbuf[0] << CQSPI_REG_RD_INSTR_OPCODE_LSB;
 
 #ifdef CONFIG_M25PXX_USE_FAST_READ_QUAD_OUTPUT
+#error WTFO
 	reg |= (CQSPI_INST_TYPE_QUAD << CQSPI_REG_RD_INSTR_TYPE_DATA_LSB);
 #endif /* CONFIG_M25PXX_USE_FAST_READ_QUAD_OUTPUT */
 
@@ -409,6 +480,12 @@ static int cadence_qspi_apb_indirect_read_execute(
 	int remaining = (int)rxlen;
 	int ret = 0;
 
+#ifdef DEBUG
+	unsigned char *saverxbuf = rxbuf;
+	unsigned saverxlen = rxlen;
+#endif /* #ifdef DEBUG */
+
+	pr_debug("%s rxlen %d rxbuf %p\n", __func__, rxlen, rxbuf);
 	if (remaining < watermark)
 		watermark = remaining;
 
@@ -477,6 +554,7 @@ static int cadence_qspi_apb_indirect_read_execute(
 	/* Clear indirect completion status */
 	CQSPI_WRITEL(CQSPI_REG_INDIRECTRD_DONE_MASK,
 		reg_base + CQSPI_REG_INDIRECTRD);
+	hex_dump((unsigned int)saverxbuf, saverxbuf, saverxlen);
 	return 0;
 
 failrd:
@@ -495,13 +573,17 @@ static int cadence_qspi_apb_indirect_write_setup(void *reg_base,
 	unsigned int reg;
 	unsigned int addr_bytes = (txlen >= 5) ? 4: 3;
 
+	pr_debug("%s txlen %d txbuf %p addr_bytes %d\n",
+		__func__, txlen, txbuf, addr_bytes);
+	hex_dump((unsigned int)txbuf, txbuf, txlen);
+
 	if (txlen < 4 || txbuf == NULL) {
 		pr_err("QSPI: Invalid input argument, txlen %d txbuf 0x%08x\n",
 			txlen, (unsigned int)txbuf);
 		return -EINVAL;
 	}
 
-	CQSPI_WRITEL( (ahb_phy_addr & CQSPI_INDIRECTTRIGGER_ADDR_MASK),
+	CQSPI_WRITEL((ahb_phy_addr & CQSPI_INDIRECTTRIGGER_ADDR_MASK),
 		reg_base + CQSPI_REG_INDIRECTTRIGGER);
 
 	/* Set opcode. */
@@ -537,6 +619,8 @@ static int cadence_qspi_apb_indirect_write_execute(
 	int remaining = (int)txlen;
 	unsigned int write_bytes;
 
+	pr_debug("%s txlen %d txbuf %p\n", __func__, txlen, txbuf);
+	hex_dump((unsigned int)txbuf, txbuf, txlen);
 	CQSPI_WRITEL(remaining, reg_base + CQSPI_REG_INDIRECTWRBYTES);
 
 	CQSPI_WRITEL(CQSPI_REG_SRAM_THRESHOLD_BYTES, reg_base +
@@ -626,6 +710,7 @@ failwr:
 void cadence_qspi_apb_controller_enable(void *reg_base)
 {
 	unsigned int reg;
+	pr_debug("%s\n", __func__);
 	reg = CQSPI_READL(reg_base + CQSPI_REG_CONFIG);
 	reg |= CQSPI_REG_CONFIG_ENABLE_MASK;
 	CQSPI_WRITEL(reg, reg_base + CQSPI_REG_CONFIG);
@@ -635,6 +720,7 @@ void cadence_qspi_apb_controller_enable(void *reg_base)
 void cadence_qspi_apb_controller_disable(void *reg_base)
 {
 	unsigned int reg;
+	pr_debug("%s\n", __func__);
 	reg = CQSPI_READL(reg_base + CQSPI_REG_CONFIG);
 	reg &= ~CQSPI_REG_CONFIG_ENABLE_MASK;
 	CQSPI_WRITEL(reg, reg_base + CQSPI_REG_CONFIG);
@@ -656,13 +742,22 @@ void cadence_qspi_apb_controller_init(struct struct_cqspi *cadence_qspi)
 	/* Disable all interrupts. */
 	CQSPI_WRITEL(0, cadence_qspi->iobase + CQSPI_REG_IRQMASK);
 
-	/* Set read data capture to default. */
-	cadence_qspi_apb_readdata_capture(cadence_qspi->iobase, 1, 0);
-
 	cadence_qspi_apb_controller_enable(cadence_qspi->iobase);
 	return;
 }
 
+unsigned int calculate_ticks_for_ns(unsigned int ref_clk_hz,
+	unsigned int ns_val)
+{
+	unsigned int ticks;
+	ticks = ref_clk_hz;
+	ticks /= 1000;
+	ticks *= ns_val;
+	ticks +=  999999;
+	ticks /= 1000000;
+	return ticks;
+}
+
 void cadence_qspi_apb_delay(struct struct_cqspi *cadence_qspi,
 	unsigned int ref_clk, unsigned int sclk_hz)
 {
@@ -675,8 +770,9 @@ void cadence_qspi_apb_delay(struct struct_cqspi *cadence_qspi,
 	unsigned int sclk_ns;
 	unsigned int tshsl, tchsh, tslch, tsd2d;
 	unsigned int reg;
+	unsigned int tsclk;
 
-	cadence_qspi_apb_controller_disable(iobase);
+	pr_debug("%s %d %d\n", __func__, ref_clk, sclk_hz);
 
 	/* Convert to ns. */
 	ref_clk_ns = (1000000000) / pdata->master_ref_clk_hz;
@@ -684,11 +780,24 @@ void cadence_qspi_apb_delay(struct struct_cqspi *cadence_qspi,
 	/* Convert to ns. */
 	sclk_ns = (1000000000) / sclk_hz;
 
-	/* Plus 1 to round up 1 clock cycle. */
-	tshsl = CQSPI_CAL_DELAY(f_pdata->tshsl_ns, ref_clk_ns, sclk_ns) + 1;
-	tchsh = CQSPI_CAL_DELAY(f_pdata->tchsh_ns, ref_clk_ns, sclk_ns) + 1;
-	tslch = CQSPI_CAL_DELAY(f_pdata->tslch_ns, ref_clk_ns, sclk_ns) + 1;
-	tsd2d = CQSPI_CAL_DELAY(f_pdata->tsd2d_ns, ref_clk_ns, sclk_ns) + 1;
+	/* calculate the number of ref ticks for one sclk tick */
+	tsclk = (pdata->master_ref_clk_hz + sclk_hz - 1) / sclk_hz;
+
+	tshsl = calculate_ticks_for_ns(pdata->master_ref_clk_hz,
+		f_pdata->tshsl_ns);
+	/* this particular value must be at least one sclk */
+	if (tshsl < tsclk)
+		tshsl = tsclk;
+
+	tchsh = calculate_ticks_for_ns(pdata->master_ref_clk_hz,
+		f_pdata->tchsh_ns);
+	tslch = calculate_ticks_for_ns(pdata->master_ref_clk_hz,
+		f_pdata->tslch_ns);
+	tsd2d = calculate_ticks_for_ns(pdata->master_ref_clk_hz,
+		f_pdata->tsd2d_ns);
+
+	pr_debug("%s tshsl %d tsd2d %d tchsh %d tslch %d\n",
+		__func__, tshsl, tsd2d, tchsh, tslch);
 
 	reg = ((tshsl & CQSPI_REG_DELAY_TSHSL_MASK)
 			<< CQSPI_REG_DELAY_TSHSL_LSB);
@@ -700,7 +809,6 @@ void cadence_qspi_apb_delay(struct struct_cqspi *cadence_qspi,
 			<< CQSPI_REG_DELAY_TSD2D_LSB);
 	CQSPI_WRITEL(reg, iobase + CQSPI_REG_DELAY);
 
-	cadence_qspi_apb_controller_enable(iobase);
 	return;
 }
 
@@ -713,6 +821,7 @@ void cadence_qspi_switch_cs(struct struct_cqspi *cadence_qspi,
 	struct cqspi_flash_pdata *f_pdata = &(pdata->f_pdata[cs]);
 	void __iomem *iobase = cadence_qspi->iobase;
 
+	pr_debug("%s\n", __func__);
 	cadence_qspi_apb_controller_disable(iobase);
 
 	/* Configure page size and block size. */
@@ -741,16 +850,27 @@ int cadence_qspi_apb_process_queue(struct struct_cqspi *cadence_qspi,
 	void __iomem *iobase = cadence_qspi->iobase;
 	unsigned int sclk;
 	int ret = 0;
+	struct cqspi_flash_pdata *f_pdata;
+
+	pr_debug("%s %d\n", __func__, n_trans);
 
 	if (!cmd_xfer->len) {
 		pr_err("QSPI: SPI transfer length is 0.\n");
 		return -EINVAL;
 	}
 
-	/* Setup baudrate divisor. */
-	sclk = cmd_xfer->speed_hz ? cmd_xfer->speed_hz : spi->max_speed_hz;
+	/* Setup baudrate divisor and delays */
+	f_pdata = &(pdata->f_pdata[cadence_qspi->current_cs]);
+	sclk = cmd_xfer->speed_hz ?
+		cmd_xfer->speed_hz : spi->max_speed_hz;
+	cadence_qspi_apb_controller_disable(iobase);
 	cadence_qspi_apb_config_baudrate_div(iobase,
 		pdata->master_ref_clk_hz, sclk);
+	cadence_qspi_apb_delay(cadence_qspi,
+		pdata->master_ref_clk_hz, sclk);
+	cadence_qspi_apb_readdata_capture(iobase, 1,
+		f_pdata->read_delay);
+	cadence_qspi_apb_controller_enable(iobase);
 
 	/* Switch chip select. */
 	if (cadence_qspi->current_cs != spi->chip_select) {
@@ -758,9 +878,6 @@ int cadence_qspi_apb_process_queue(struct struct_cqspi *cadence_qspi,
 		cadence_qspi_switch_cs(cadence_qspi, spi->chip_select);
 	}
 
-	/* Configure device delay if we change device clock. */
-	cadence_qspi_apb_delay(cadence_qspi, pdata->master_ref_clk_hz, sclk);
-
 	/*
 	 * Use STIG command to send if the transfer length is less than
 	 * 4 or if only one transfer.
diff --git a/drivers/spi/spi-cadence-qspi-apb.h b/drivers/spi/spi-cadence-qspi-apb.h
index ff7f56b..9f481d5 100644
--- a/drivers/spi/spi-cadence-qspi-apb.h
+++ b/drivers/spi/spi-cadence-qspi-apb.h
@@ -223,4 +223,5 @@ int cadence_qspi_apb_process_queue(struct struct_cqspi *cadence_qspi,
 	struct spi_transfer **spi_xfer);
 void cadence_qspi_apb_controller_enable(void *reg_base_addr);
 void cadence_qspi_apb_controller_disable(void *reg_base_addr);
+
 #endif /* __CADENCE_QSPI_APB_H__ */
diff --git a/drivers/spi/spi-cadence-qspi.c b/drivers/spi/spi-cadence-qspi.c
index 56fb69b..8984356 100644
--- a/drivers/spi/spi-cadence-qspi.c
+++ b/drivers/spi/spi-cadence-qspi.c
@@ -65,6 +65,8 @@ static void cadence_qspi_work(struct work_struct *work)
 		= container_of(work, struct struct_cqspi, work);
 	unsigned long flags;
 
+	pr_debug("%s\n", __func__);
+
 	spin_lock_irqsave(&cadence_qspi->lock, flags);
 	while ((!list_empty(&cadence_qspi->msg_queue)) &&
 		cadence_qspi->running) {
@@ -124,6 +126,8 @@ static int cadence_qspi_transfer(struct spi_device *spi, struct spi_message *msg
 	struct cqspi_platform_data *pdata = pdev->dev.platform_data;
 	unsigned long flags;
 
+	pr_debug("%s\n", __func__);
+
 	list_for_each_entry(spi_xfer, &msg->transfers, transfer_list) {
 		if (spi_xfer->speed_hz > (pdata->master_ref_clk_hz / 2)) {
 			dev_err(&spi->dev, "speed_hz%d greater than "
@@ -153,6 +157,8 @@ static int cadence_qspi_transfer(struct spi_device *spi, struct spi_message *msg
 
 static int cadence_qspi_setup(struct spi_device *spi)
 {
+	pr_debug("%s\n", __func__);
+
 	if (spi->chip_select > spi->master->num_chipselect) {
 		dev_err(&spi->dev, "%d chip select is out of range\n",
 			spi->chip_select);
@@ -168,6 +174,7 @@ static int cadence_qspi_start_queue(struct struct_cqspi *cadence_qspi)
 {
 	unsigned long flags;
 
+	pr_debug("%s\n", __func__);
 	spin_lock_irqsave(&cadence_qspi->lock, flags);
 
 	if (cadence_qspi->running) {
@@ -274,6 +281,12 @@ static int cadence_qspi_of_get_pdata(struct platform_device *pdev)
 		}
 		f_pdata->block_size = prop;
 
+		if (of_property_read_u32(nc, "read-delay", &prop)) {
+			dev_err(&pdev->dev, "couldn't determine read-delay\n");
+			return -ENXIO;
+		}
+		f_pdata->read_delay = prop;
+
 		if (of_property_read_u32(nc, "tshsl-ns", &prop)) {
 			dev_err(&pdev->dev, "couldn't determine tshsl-ns\n");
 			return -ENXIO;
@@ -310,6 +323,10 @@ static int __devinit cadence_qspi_probe(struct platform_device *pdev)
 	struct cqspi_platform_data *pdata;
 	int status;
 
+	pr_debug("%s\n", __func__);
+	pr_debug("%s %s %s\n", __func__,
+		pdev->name, pdev->id_entry->name);
+
 	master = spi_alloc_master(&pdev->dev, sizeof(*cadence_qspi));
 	if (master == NULL) {
 		dev_err(&pdev->dev, "spi_alloc_master failed\n");
@@ -422,15 +439,15 @@ static int __devinit cadence_qspi_probe(struct platform_device *pdev)
 	master->num_chipselect = pdata->num_chipselect;
 
 	platform_set_drvdata(pdev, master);
+	cadence_qspi_apb_controller_init(cadence_qspi);
+	cadence_qspi->current_cs = -1;
+	pr_debug("%s call spi_register_master\n", __func__);
 	status = spi_register_master(master);
 	if (status) {
 		dev_err(&pdev->dev, "spi_register_master failed\n");
 		goto err_of;
 	}
 
-	cadence_qspi_apb_controller_init(cadence_qspi);
-	cadence_qspi->current_cs = -1;
-
 	dev_info(&pdev->dev, "Cadence QSPI controller driver\n");
 	return 0;
 
diff --git a/drivers/spi/spi-cadence-qspi.h b/drivers/spi/spi-cadence-qspi.h
index 86f5d65..ce9b360 100644
--- a/drivers/spi/spi-cadence-qspi.h
+++ b/drivers/spi/spi-cadence-qspi.h
@@ -29,6 +29,7 @@ struct cqspi_flash_pdata {
 	unsigned int page_size;
 	unsigned int block_size;
 	unsigned int quad;
+	unsigned int read_delay;
 	unsigned int tshsl_ns;
 	unsigned int tsd2d_ns;
 	unsigned int tchsh_ns;
-- 
1.7.6

