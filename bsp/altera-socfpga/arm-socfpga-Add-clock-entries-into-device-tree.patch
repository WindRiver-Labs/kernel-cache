From 260c4d770754cadc986211252f3c48b9e155809e Mon Sep 17 00:00:00 2001
From: Dinh Nguyen <dinguyen@altera.com>
Date: Mon, 4 Mar 2013 10:18:23 -0600
Subject: [PATCH 208/254] arm: socfpga: Add clock entries into device tree

Upstream: git://git.rocketboards.org/linux-socfpga.git
 file.

Current clock support for SoCFPGA is statically enabled. By moving the clock
entries into device tree files, the Linux common clock framework can
dynamically return the correct clock rates.

To test this patch:
1) Need to recompile kernel with CONFIG_COMMON_CLK_DEBUG turned on
2) $cat /sys/kernel/debug/clk/osc1/main_pll/mpuclk/clk_rate
3) Should return 800 MHz.
4) $cat /sys/kernel/debug/clk/clk_summary   will show something like this:

$cat /sys/kernel/debug/clk/clk_summary
   clock                        enable_cnt  prepare_cnt  rate
---------------------------------------------------------------------
 osc1                           2           2            25000000
    sdram_pll                   0           0            400000000
       s2f_usr2_clk             0           0            66666666
       ddr_dq_clk               0           0            200000000
       ddr_2x_dqs_clk           0           0            400000000
       ddr_dqs_clk              0           0            200000000
    periph_pll                  2           2            500000000
       s2f_usr1_clk             0           0            50000000
       per_base_clk             4           4            100000000
       per_nand_mmc_clk         0           0            25000000
       per_qsi_clk              0           0            250000000
       emac1_clk                1           1            125000000
       emac0_clk                0           0            125000000
    main_pll                    1           1            1600000000
       cfg_s2f_usr0_clk         0           0            100000000
       main_nand_sdmmc_clk      0           0            100000000
       main_qspi_clk            0           0            400000000
       dbg_base_clk             0           0            400000000
       mainclk                  0           0            400000000
       mpuclk                   1           1            800000000
          smp_twd               1           1            200000000

This is a first in series of future patches to add proper clock support for
SoCFPGA. This patch does NOT have defines for the additional clocks that are
gated for peripherals. This patch only addresses the main PLL groups.

Signed-off-by: Dinh Nguyen <dinguyen@altera.com>

V5:
- Add error protection for !np and WARN_ON of_iomap() calls

V4:
- use device tree entries for fixed-divider clocks

V3:
- Renamed socfpga-clk-manager2.txt -> socfpga-clk-manager.txt
- Renamed altr_socfpga2.txt -> altr_socfpga.txt

V2:
- Added Documentation/devicetree/bindings/arm/altera/socfpga-clk-manager2.txt
- Added Documentation/devicetree/bindings/clock/altr_socfpga2.txt
- Added reading for the correct divider value for all clocks
- Added clock values for SDRAM PLL
- Added error checking for clk_register_clkdev()
(cherry picked from commit c789c047004aae47fd74efbded226e2e4d438621)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 .../bindings/arm/altera/socfpga-clk-manager.txt    |   11 +
 .../devicetree/bindings/clock/altr_socfpga.txt     |   19 ++
 arch/arm/boot/dts/socfpga.dtsi                     |  163 ++++++++++++
 arch/arm/boot/dts/socfpga_cyclone5.dts             |    8 +
 arch/arm/boot/dts/socfpga_ice.dts                  |    8 +
 arch/arm/boot/dts/socfpga_vt.dts                   |    8 +
 arch/arm/mach-socfpga/socfpga.c                    |   21 ++
 drivers/clk/socfpga/clk.c                          |  278 ++++++++++++--------
 8 files changed, 406 insertions(+), 110 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/arm/altera/socfpga-clk-manager.txt
 create mode 100644 Documentation/devicetree/bindings/clock/altr_socfpga.txt

diff --git a/Documentation/devicetree/bindings/arm/altera/socfpga-clk-manager.txt b/Documentation/devicetree/bindings/arm/altera/socfpga-clk-manager.txt
new file mode 100644
index 0000000..38cf62b
--- /dev/null
+++ b/Documentation/devicetree/bindings/arm/altera/socfpga-clk-manager.txt
@@ -0,0 +1,11 @@
+Altera SOCFPGA Clock Manager
+
+Required properties:
+- compatible : "altr,clk-mgr"
+- reg : Should contain 1 register ranges(address and length)
+
+Example:
+	 clkmgr@ffd04000 {
+		compatible = "altr,clk-mgr";
+		reg = <0xffd04000 0x1000>;
+	};
diff --git a/Documentation/devicetree/bindings/clock/altr_socfpga.txt b/Documentation/devicetree/bindings/clock/altr_socfpga.txt
new file mode 100644
index 0000000..f954c72
--- /dev/null
+++ b/Documentation/devicetree/bindings/clock/altr_socfpga.txt
@@ -0,0 +1,19 @@
+Device Tree Clock bindings for Altera's SoCFPGA platform
+
+This binding uses the common clock binding[1].
+
+[1] Documentation/devicetree/bindings/clock/clock-bindings.txt
+
+Required properties:
+- compatible : shall be one of the following:
+	"altr,socfpga-pll-clock" - for a PLL clock
+	"altr,socfpga-perip-clock" - The peripheral clock divided from the
+		PLL clock.
+- reg : shall be the control register offset from CLOCK_MANAGER's base for the clock.
+- clocks : shall be the input parent clock phandle for the clock. This is
+	either an oscillator or a pll output.
+- #clock-cells : from common clock binding; shall be set to 0.
+
+Optional properties:
+- fixed-divider : If clocks have a fixed divider value, use this property.
+
diff --git a/arch/arm/boot/dts/socfpga.dtsi b/arch/arm/boot/dts/socfpga.dtsi
index b8ab1b3..120a398 100644
--- a/arch/arm/boot/dts/socfpga.dtsi
+++ b/arch/arm/boot/dts/socfpga.dtsi
@@ -97,6 +97,158 @@
 		clkmgr@ffd04000 {
 				compatible = "altr,clk-mgr";
 				reg = <0xffd04000 0x1000>;
+
+				clocks {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					osc: osc1 {
+						#clock-cells = <0>;
+						compatible = "fixed-clock";
+					};
+
+					main_pll: main_pll {
+						#address-cells = <1>;
+						#size-cells = <0>;
+						#clock-cells = <0>;
+						compatible = "altr,socfpga-pll-clock";
+						clocks = <&osc>;
+						reg = <0x40>;
+
+						mpuclk: mpuclk {
+							#clock-cells = <0>;
+							compatible = "altr,socfpga-perip-clk";
+							clocks = <&main_pll>;
+							fixed-divider = <2>;
+							reg = <0x48>;
+						};
+
+						mainclk: mainclk {
+							#clock-cells = <0>;
+							compatible = "altr,socfpga-perip-clk";
+							clocks = <&main_pll>;
+							fixed-divider = <4>;
+							reg = <0x4C>;
+						};
+
+						dbg_base_clk: dbg_base_clk {
+							#clock-cells = <0>;
+							compatible = "altr,socfpga-perip-clk";
+							clocks = <&main_pll>;
+							fixed-divider = <4>;
+							reg = <0x50>;
+						};
+
+						main_qspi_clk: main_qspi_clk {
+							#clock-cells = <0>;
+							compatible = "altr,socfpga-perip-clk";
+							clocks = <&main_pll>;
+							reg = <0x54>;
+						};
+
+						main_nand_sdmmc_clk: main_nand_sdmmc_clk {
+							#clock-cells = <0>;
+							compatible = "altr,socfpga-perip-clk";
+							clocks = <&main_pll>;
+							reg = <0x58>;
+						};
+
+						cfg_s2f_usr0_clk: cfg_s2f_usr0_clk {
+							#clock-cells = <0>;
+							compatible = "altr,socfpga-perip-clk";
+							clocks = <&main_pll>;
+							reg = <0x5C>;
+						};
+					};
+
+					periph_pll: periph_pll {
+						#address-cells = <1>;
+						#size-cells = <0>;
+						#clock-cells = <0>;
+						compatible = "altr,socfpga-pll-clock";
+						clocks = <&osc>;
+						reg = <0x80>;
+
+						emac0_clk: emac0_clk {
+							#clock-cells = <0>;
+							compatible = "altr,socfpga-perip-clk";
+							clocks = <&periph_pll>;
+							reg = <0x88>;
+						};
+
+						emac1_clk: emac1_clk {
+							#clock-cells = <0>;
+							compatible = "altr,socfpga-perip-clk";
+							clocks = <&periph_pll>;
+							reg = <0x8C>;
+						};
+
+						per_qspi_clk: per_qsi_clk {
+							#clock-cells = <0>;
+							compatible = "altr,socfpga-perip-clk";
+							clocks = <&periph_pll>;
+							reg = <0x90>;
+						};
+
+						per_nand_mmc_clk: per_nand_mmc_clk {
+							#clock-cells = <0>;
+							compatible = "altr,socfpga-perip-clk";
+							clocks = <&periph_pll>;
+							reg = <0x94>;
+						};
+
+						per_base_clk: per_base_clk {
+							#clock-cells = <0>;
+							compatible = "altr,socfpga-perip-clk";
+							clocks = <&periph_pll>;
+							reg = <0x98>;
+						};
+
+						s2f_usr1_clk: s2f_usr1_clk {
+							#clock-cells = <0>;
+							compatible = "altr,socfpga-perip-clk";
+							clocks = <&periph_pll>;
+							reg = <0x9C>;
+						};
+					};
+
+					sdram_pll: sdram_pll {
+						#address-cells = <1>;
+						#size-cells = <0>;
+						#clock-cells = <0>;
+						compatible = "altr,socfpga-pll-clock";
+						clocks = <&osc>;
+						reg = <0xC0>;
+
+						ddr_dqs_clk: ddr_dqs_clk {
+							#clock-cells = <0>;
+							compatible = "altr,socfpga-perip-clk";
+							clocks = <&sdram_pll>;
+							reg = <0xC8>;
+						};
+
+						ddr_2x_dqs_clk: ddr_2x_dqs_clk {
+							#clock-cells = <0>;
+							compatible = "altr,socfpga-perip-clk";
+							clocks = <&sdram_pll>;
+							reg = <0xCC>;
+						};
+
+						ddr_dq_clk: ddr_dq_clk {
+							#clock-cells = <0>;
+							compatible = "altr,socfpga-perip-clk";
+							clocks = <&sdram_pll>;
+							reg = <0xD0>;
+						};
+
+						s2f_usr2_clk: s2f_usr2_clk {
+							#clock-cells = <0>;
+							compatible = "altr,socfpga-perip-clk";
+							clocks = <&sdram_pll>;
+							reg = <0xD4>;
+						};
+					};
+				};
 			};
 
 
@@ -106,6 +258,8 @@
 			interrupts = <0 115 4>;
 			interrupt-names = "macirq";
 			mac-address = [00 00 00 00 00 00];/* Filled in by U-Boot */
+			clocks = <&emac0_clk>;
+			clock-names = "stmmaceth";
 		};
 
 		gmac1: ethernet@ff702000 {
@@ -114,6 +268,8 @@
 			interrupts = <0 120 4>;
 			interrupt-names = "macirq";
 			mac-address = [00 00 00 00 00 00];/* Filled in by U-Boot */
+			clocks = <&emac1_clk>;
+			clock-names = "stmmaceth";
 		};
 
 		gpio0: gpio@ff708000 {
@@ -126,6 +282,7 @@
 			#interrupt-cells = <2>;
 			gpio-controller;
 			#gpio-cells = <2>;
+			clocks = <&per_base_clk>;
 		};
 
 		gpio1: gpio@ff709000 {
@@ -138,6 +295,7 @@
 			#interrupt-cells = <2>;
 			gpio-controller;
 			#gpio-cells = <2>;
+			clocks = <&per_base_clk>;
 		};
 
 		gpio2: gpio@ff70a000 {
@@ -150,6 +308,7 @@
 			#interrupt-cells = <2>;
 			gpio-controller;
 			#gpio-cells = <2>;
+			clocks = <&per_base_clk>;
 		};
 
 		L2: l2-cache@fffef000 {
@@ -204,6 +363,7 @@
 			bus-num = <0>;
 			tx-dma-channel = <&pdma 16>;
 			rx-dma-channel = <&pdma 17>;
+			clocks = <&per_base_clk>;
 
 			spidev@0 {
 				compatible = "spidev";
@@ -223,6 +383,7 @@
 			bus-num = <1>;
 			tx-dma-channel = <&pdma 20>;
 			rx-dma-channel = <&pdma 21>;
+			clocks = <&per_base_clk>;
 
 			spidev@0 {
 				compatible = "spidev";
@@ -319,6 +480,7 @@
 			reg = <0xffc04000 0x1000>;
 			interrupts = <0 158 4>;
 			emptyfifo_hold_master = <1>;
+			clocks = <&per_base_clk>;
 		};
 
 		i2c1: i2c@ffc05000 {
@@ -328,6 +490,7 @@
 			reg = <0xffc05000 0x1000>;
 			interrupts = <0 159 4>;
 			emptyfifo_hold_master = <1>;
+			clocks = <&per_base_clk>;
 		};
 	};
 };
diff --git a/arch/arm/boot/dts/socfpga_cyclone5.dts b/arch/arm/boot/dts/socfpga_cyclone5.dts
index dd04f9f..674741b 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5.dts
@@ -40,6 +40,14 @@
 	};
 
 	soc {
+		clkmgr@ffd04000 {
+			clocks {
+				osc1 {
+					clock-frequency = <25000000>;
+				};
+			};
+		};
+
 		ethernet@ff700000 {
 			status = "disabled";
 		};
diff --git a/arch/arm/boot/dts/socfpga_ice.dts b/arch/arm/boot/dts/socfpga_ice.dts
index 4522181..f406e1e 100644
--- a/arch/arm/boot/dts/socfpga_ice.dts
+++ b/arch/arm/boot/dts/socfpga_ice.dts
@@ -33,6 +33,14 @@
 	};
 
 	soc {
+		clkmgr@ffd04000 {
+			clocks {
+				osc1 {
+					clock-frequency = <10000000>;
+				};
+			};
+		};
+
 		qspi: spi@ff705000 {
 				compatible = "cadence,qspi";
 				#address-cells = <1>;
diff --git a/arch/arm/boot/dts/socfpga_vt.dts b/arch/arm/boot/dts/socfpga_vt.dts
index 04090c5..d1b2847 100644
--- a/arch/arm/boot/dts/socfpga_vt.dts
+++ b/arch/arm/boot/dts/socfpga_vt.dts
@@ -27,6 +27,14 @@
 	};
 
 	soc {
+		clkmgr@ffd04000 {
+			clocks {
+				osc1 {
+					clock-frequency = <10000000>;
+				};
+			};
+		};
+
 		dwmmc0@ff704000 {
 			pwr-en = <1>;
 		};
diff --git a/arch/arm/mach-socfpga/socfpga.c b/arch/arm/mach-socfpga/socfpga.c
index a6b8880..6788c39 100644
--- a/arch/arm/mach-socfpga/socfpga.c
+++ b/arch/arm/mach-socfpga/socfpga.c
@@ -38,6 +38,7 @@
 void __iomem *socfpga_scu_base_addr = ((void __iomem *)(SOCFPGA_SCU_VIRT_BASE));
 void __iomem *sys_manager_base_addr;
 void __iomem *rst_manager_base_addr;
+void __iomem *clk_mgr_base_addr;
 unsigned long	cpu1start_addr;
 
 static int socfpga_phy_reset_mii(struct mii_bus *bus, int phyaddr);
@@ -264,15 +265,35 @@ static void __init socfpga_sysmgr_init(void)
 	struct device_node *np;
 
 	np = of_find_compatible_node(NULL, NULL, "altr,sys-mgr");
+	if (!np) {
+		pr_err("SOCFPGA: Unable to find sys-magr in dtb\n");
+		return;
+	}
 
 	if (of_property_read_u32(np, "cpu1-start-addr",
 			(u32 *) &cpu1start_addr))
 		pr_err("SMP: Need cpu1-start-addr in device tree.\n");
 
 	sys_manager_base_addr = of_iomap(np, 0);
+	WARN_ON(!sys_manager_base_addr);
 
 	np = of_find_compatible_node(NULL, NULL, "altr,rst-mgr");
+	if (!np) {
+		pr_err("SOCFPGA: Unable to find rst-mgr in dtb\n");
+		return;
+	}
+
 	rst_manager_base_addr = of_iomap(np, 0);
+	WARN_ON(!rst_manager_base_addr);
+
+	np = of_find_compatible_node(NULL, NULL, "altr,clk-mgr");
+	if (!np) {
+		pr_err("SOCFPGA: Unable to find clk-mgr\n");
+		return;
+	}
+
+	clk_mgr_base_addr = of_iomap(np, 0);
+	WARN_ON(!clk_mgr_base_addr);
 }
 
 static void __init socfpga_map_io(void)
diff --git a/drivers/clk/socfpga/clk.c b/drivers/clk/socfpga/clk.c
index 30c76c4..648debb 100644
--- a/drivers/clk/socfpga/clk.c
+++ b/drivers/clk/socfpga/clk.c
@@ -1,5 +1,5 @@
 /*
- *  Copyright (C) 2012 Altera Corporation <www.altera.com>
+ *  Copyright (C) 2012-2013 Altera Corporation <www.altera.com>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -11,6 +11,8 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
+ * Based from clk-highbank.c
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
@@ -21,18 +23,6 @@
 #include <linux/of.h>
 #include <linux/of_address.h>
 
-static DEFINE_SPINLOCK(_lock);
-
-#define SOCFPGA_OSC1_CLK	10000000
-#define SOCFPGA_MPU_CLK		800000000
-#define SOCFPGA_MAIN_QSPI_CLK		432000000
-#define SOCFPGA_MAIN_NAND_SDMMC_CLK	250000000
-#define SOCFPGA_S2F_USR_CLK		125000000
-
-#define SOCFPGA_MAIN_PLL_CLK		1200000000
-#define SOCFPGA_PER_PLL_CLK		900000000
-#define SOCFPGA_SDRAM_PLL_CLK		800000000
-
 #define CLKMGR_PERPLLGRP_EN	0xA0
 
 #define CLKMGR_QSPI_CLK_EN				11
@@ -48,105 +38,173 @@ static DEFINE_SPINLOCK(_lock);
 #define CLKMGR_EMAC1_CLK_EN			1
 #define CLKMGR_EMAC0_CLK_EN			0
 
-void __iomem *clk_mgr_base_addr;
+/* Clock Manager offsets */
+#define CLKMGR_CTRL	0x0
+#define CLKMGR_BYPASS 0x4
+
+/* Clock bypass bits */
+#define MAINPLL_BYPASS (1<<0)
+#define SDRAMPLL_BYPASS (1<<1)
+#define SDRAMPLL_SRC_BYPASS (1<<2)
+#define PERPLL_BYPASS (1<<3)
+#define PERPLL_SRC_BYPASS (1<<4)
+
+#define SOCFPGA_PLL_BG_PWRDWN	0x00000001
+#define SOCFPGA_PLL_EXT_ENA	0x00000002
+#define SOCFPGA_PLL_PWR_DOWN	0x00000004
+#define SOCFPGA_PLL_DIVF_MASK 0x0000FFF8
+#define SOCFPGA_PLL_DIVF_SHIFT 3
+#define SOCFPGA_PLL_DIVQ_MASK 0x003F0000
+#define SOCFPGA_PLL_DIVQ_SHIFT 15
+
+extern void __iomem *clk_mgr_base_addr;
+
+struct socfpga_clk {
+	struct clk_hw hw;
+	void __iomem	*reg;
+	char *parent_name;
+	u32 fixed_div;
+};
+#define to_socfpga_clk(p) container_of(p, struct socfpga_clk, hw)
+
+static int clk_pll_enable(struct clk_hw *hwclk)
+{
+	struct socfpga_clk *socfpgaclk = to_socfpga_clk(hwclk);
+	u32 reg;
+
+	reg = readl(socfpgaclk->reg);
+	reg |= SOCFPGA_PLL_EXT_ENA;
+	writel(reg, socfpgaclk->reg);
+
+	return 0;
+}
+
+static void clk_pll_disable(struct clk_hw *hwclk)
+{
+	struct socfpga_clk *socfpgaclk = to_socfpga_clk(hwclk);
+	u32 reg;
+
+	reg = readl(socfpgaclk->reg);
+	reg &= ~SOCFPGA_PLL_EXT_ENA;
+	writel(reg, socfpgaclk->reg);
+}
+
+static unsigned long clk_pll_recalc_rate(struct clk_hw *hwclk,
+					 unsigned long parent_rate)
+{
+	struct socfpga_clk *socfpgaclk = to_socfpga_clk(hwclk);
+	unsigned long divf, divq, vco_freq, reg;
+	unsigned long bypass;
+
+	reg = readl(socfpgaclk->reg);
+	bypass = readl(clk_mgr_base_addr + CLKMGR_BYPASS);
+	if (bypass & MAINPLL_BYPASS)
+		return parent_rate;
+
+	divf = (reg & SOCFPGA_PLL_DIVF_MASK) >> SOCFPGA_PLL_DIVF_SHIFT;
+	divq = (reg & SOCFPGA_PLL_DIVQ_MASK) >> SOCFPGA_PLL_DIVQ_SHIFT;
+	vco_freq = parent_rate * (divf + 1);
+	return vco_freq / (1 << divq);
+}
+
+
+static const struct clk_ops clk_pll_ops = {
+	.enable = clk_pll_enable,
+	.disable = clk_pll_disable,
+	.recalc_rate = clk_pll_recalc_rate,
+};
+
+static unsigned long clk_periclk_recalc_rate(struct clk_hw *hwclk,
+					     unsigned long parent_rate)
+{
+	struct socfpga_clk *socfpgaclk = to_socfpga_clk(hwclk);
+	u32 div;
+
+	if (socfpgaclk->fixed_div)
+		div = socfpgaclk->fixed_div;
+	else
+		div = ((readl(socfpgaclk->reg) & 0x1ff) + 1);
+
+	return parent_rate / div;
+}
+
+static const struct clk_ops periclk_ops = {
+	.recalc_rate = clk_periclk_recalc_rate,
+};
+
+static __init struct clk *socfpga_clk_init(struct device_node *node, const struct clk_ops *ops)
+{
+	u32 reg;
+	struct clk *clk;
+	struct socfpga_clk *socfpga_clk;
+	const char *clk_name = node->name;
+	const char *parent_name;
+	struct clk_init_data init;
+	int rc;
+	u32 fixed_div;
+
+	rc = of_property_read_u32(node, "reg", &reg);
+	if (WARN_ON(rc))
+		return NULL;
+
+	socfpga_clk = kzalloc(sizeof(*socfpga_clk), GFP_KERNEL);
+	if (WARN_ON(!socfpga_clk))
+		return NULL;
+
+	socfpga_clk->reg = clk_mgr_base_addr + reg;
+
+	rc = of_property_read_u32(node, "fixed-divider", &fixed_div);
+	if (rc)
+		socfpga_clk->fixed_div = 0;
+	else
+		socfpga_clk->fixed_div = fixed_div;
+
+	of_property_read_string(node, "clock-output-names", &clk_name);
+
+	init.name = clk_name;
+	init.ops = ops;
+	init.flags = 0;
+	parent_name = of_clk_get_parent_name(node, 0);
+	init.parent_names = &parent_name;
+	init.num_parents = 1;
+
+	socfpga_clk->hw.init = &init;
+
+	clk = clk_register(NULL, &socfpga_clk->hw);
+	if (WARN_ON(IS_ERR(clk))) {
+		kfree(socfpga_clk);
+		return NULL;
+	}
+	rc = of_clk_add_provider(node, of_clk_src_simple_get, clk);
+	return clk;
+}
+
+static void __init socfpga_pll_init(struct device_node *node)
+{
+	socfpga_clk_init(node, &clk_pll_ops);
+}
+
+static void __init socfpga_periph_init(struct device_node *node)
+{
+	socfpga_clk_init(node, &periclk_ops);
+}
+
+static const __initconst struct of_device_id clk_match[] = {
+	{ .compatible = "fixed-clock", .data = of_fixed_clk_setup, },
+	{ .compatible = "altr,socfpga-pll-clock", .data = socfpga_pll_init, },
+	{ .compatible = "altr,socfpga-perip-clk", .data = socfpga_periph_init, },
+	{}
+};
 
 void __init socfpga_init_clocks(void)
 {
 	struct clk *clk;
-	struct device_node *np;
-
-	np = of_find_compatible_node(NULL, NULL, "altr,clk-mgr");
-	clk_mgr_base_addr = of_iomap(np, 0);
-
-	clk = clk_register_fixed_rate(NULL, "main_pll_clk", NULL, CLK_IS_ROOT,
-			SOCFPGA_MAIN_PLL_CLK);
-	clk_register_clkdev(clk, "main_pll_clk", NULL);
-
-	clk = clk_register_fixed_rate(NULL, "per_pll_clk", NULL, CLK_IS_ROOT,
-			SOCFPGA_PER_PLL_CLK);
-	clk_register_clkdev(clk, "per_pll_clk", NULL);
-
-	clk = clk_register_fixed_rate(NULL, "sdram_pll_clk", NULL, CLK_IS_ROOT,
-			SOCFPGA_SDRAM_PLL_CLK);
-	clk_register_clkdev(clk, "sdram_pll_clk", NULL);
-
-	clk = clk_register_fixed_rate(NULL, "osc1_clk", NULL, CLK_IS_ROOT,
-			SOCFPGA_OSC1_CLK);
-	clk_register_clkdev(clk, "osc1_clk", NULL);
-
-	clk = clk_register_fixed_rate(NULL, "mpu_clk", NULL, CLK_IS_ROOT,
-			SOCFPGA_MPU_CLK);
-	clk_register_clkdev(clk, "mpu_clk", NULL);
-
-	clk = clk_register_fixed_rate(NULL, "main_clk", NULL, CLK_IS_ROOT,
-			SOCFPGA_MPU_CLK/2);
-	clk_register_clkdev(clk, "main_clk", NULL);
-
-	clk = clk_register_fixed_rate(NULL, "dbg_base_clk", NULL, CLK_IS_ROOT,
-			SOCFPGA_MPU_CLK/2);
-	clk_register_clkdev(clk, "dbg_base_clk", NULL);
-
-	clk = clk_register_fixed_rate(NULL, "smp_twd", NULL, CLK_IS_ROOT,
-			SOCFPGA_MPU_CLK/4);
-	clk_register_clkdev(clk, NULL, "smp_twd");
-
-	clk = clk_register_fixed_rate(NULL, "main_qspi_clk", NULL, CLK_IS_ROOT,
-			SOCFPGA_MAIN_QSPI_CLK);
-	clk_register_clkdev(clk, "main_qspi_clk", NULL);
-
-	clk = clk_register_fixed_rate(NULL, "main_nand_sdmmc_clk", NULL,
-			CLK_IS_ROOT, SOCFPGA_MAIN_NAND_SDMMC_CLK);
-	clk_register_clkdev(clk, "main_nand_sdmmc_clk", NULL);
-
-	clk = clk_register_fixed_rate(NULL, "s2f_usr_clk", NULL, CLK_IS_ROOT,
-			SOCFPGA_S2F_USR_CLK);
-	clk_register_clkdev(clk, "s2f_usr_clk", NULL);
-
-	clk = clk_register_fixed_rate(NULL, "i2c0_clk", NULL, CLK_IS_ROOT,
-			SOCFPGA_PER_PLL_CLK);
-	clk_register_clkdev(clk, NULL, "ffc04000.i2c");
-
-	clk = clk_register_fixed_rate(NULL, "i2c1_clk", NULL, CLK_IS_ROOT,
-			SOCFPGA_PER_PLL_CLK);
-	clk_register_clkdev(clk, NULL, "ffc05000.i2c");
-
-	clk = clk_register_gate(NULL, "gmac0_clk", "per_pll_clk", 0,
-			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
-			CLKMGR_EMAC0_CLK_EN, 0, &_lock);
-	clk_register_clkdev(clk, NULL, "ff700000.ethernet");
-
-	clk = clk_register_gate(NULL, "gmac1_clk", "per_pll_clk", 0,
-			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
-			CLKMGR_EMAC1_CLK_EN, 0, &_lock);
-	clk_register_clkdev(clk, NULL, "ff702000.ethernet");
-
-	clk = clk_register_gate(NULL, "spi0_clk", "per_pll_clk", 0,
-			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
-			CLKMGR_SPI_M_CLK_EN, 0, &_lock);
-	clk_register_clkdev(clk, NULL, "fff00000.spi");
-
-	clk = clk_register_gate(NULL, "spi1_clk", "per_pll_clk", 0,
-			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
-			CLKMGR_SPI_M_CLK_EN, 0, &_lock);
-	clk_register_clkdev(clk, NULL, "fff01000.spi");
-
-	clk = clk_register_gate(NULL, "gpio0_clk", "per_pll_clk", 0,
-			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
-			CLKMGR_GPIO_CLK_EN, 0, &_lock);
-	clk_register_clkdev(clk, NULL, "ff708000.gpio");
-
-	clk = clk_register_gate(NULL, "gpio1_clk", "per_pll_clk", 0,
-			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
-			CLKMGR_GPIO_CLK_EN, 0, &_lock);
-	clk_register_clkdev(clk, NULL, "ff709000.gpio");
-
-	clk = clk_register_gate(NULL, "gpio2_clk", "per_pll_clk", 0,
-			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
-			CLKMGR_GPIO_CLK_EN, 0, &_lock);
-	clk_register_clkdev(clk, NULL, "ff70a000.gpio");
-
-	clk = clk_register_gate(NULL, "nand_clk", "main_nand_sdmmc_clk", 0,
-			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
-			CLKMGR_NAND_CLK_EN, 0, &_lock);
-	clk_register_clkdev(clk, NULL, "ff900000.nand");
+	int ret;
+
+	of_clk_init(clk_match);
+
+	clk = clk_register_fixed_factor(NULL, "smp_twd", "mpuclk", 0, 1, 4);
+	ret = clk_register_clkdev(clk, NULL, "smp_twd");
+	if (ret)
+		pr_err("smp_twd alias not registered\n");
 }
-- 
1.7.5.4

