From 80fa915d836f7a644bfe16335fc8a4da561dfa00 Mon Sep 17 00:00:00 2001
From: Dinh Nguyen <dinguyen@altera.com>
Date: Tue, 16 Oct 2012 10:40:32 -0600
Subject: [PATCH 071/254] spi: qspi: cadence: Add spi and qspi driver

Upstream: git://git.rocketboards.org/linux-socfpga.git

-Add spi-dw and Cadence QSPI driver.
-Add entry in clock driver.

Signed-off-by: Dinh Nguyen <dinguyen@altera.com>
(cherry picked from commit e383144d98ab17dd0567223068759f4ff740fe1b)

Conflicts:
	drivers/spi/Makefile
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/clk/socfpga/clk.c          |    8 +
 drivers/spi/Kconfig                |   10 +
 drivers/spi/Makefile               |    3 +
 drivers/spi/spi-cadence-qspi-apb.c |  806 ++++++++++++++++++++++++++++++++++++
 drivers/spi/spi-cadence-qspi-apb.h |  226 ++++++++++
 drivers/spi/spi-cadence-qspi.c     |  562 +++++++++++++++++++++++++
 drivers/spi/spi-cadence-qspi.h     |   82 ++++
 drivers/spi/spi-dw-mmio.c          |   48 ++-
 drivers/spi/spi-dw-pl330.c         |  223 ++++++++++
 drivers/spi/spi-dw.c               |   82 ++++
 drivers/spi/spi-dw.h               |    3 +
 include/linux/spi/spi-dw.h         |   38 ++
 include/linux/spi/spi.h            |    2 +
 13 files changed, 2090 insertions(+), 3 deletions(-)
 create mode 100644 drivers/spi/spi-cadence-qspi-apb.c
 create mode 100644 drivers/spi/spi-cadence-qspi-apb.h
 create mode 100644 drivers/spi/spi-cadence-qspi.c
 create mode 100644 drivers/spi/spi-cadence-qspi.h
 create mode 100644 drivers/spi/spi-dw-pl330.c
 create mode 100644 include/linux/spi/spi-dw.h

diff --git a/drivers/clk/socfpga/clk.c b/drivers/clk/socfpga/clk.c
index aeaed7f..9f04f69 100644
--- a/drivers/clk/socfpga/clk.c
+++ b/drivers/clk/socfpga/clk.c
@@ -98,4 +98,12 @@ void __init socfpga_init_clocks(void)
 	clk = clk_register_gate(NULL, "gmac_clk", "per_pll_clk", 0, clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
 			CLKMGR_EMAC0_CLK_EN, 0, &_lock);
 	clk_register_clkdev(clk, NULL, "ff700000.stmmac");
+
+	clk = clk_register_gate(NULL, "spi0_clk", "per_pll_clk", 0, clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
+			CLKMGR_SPI_M_CLK_EN, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "fff00000.spi");
+
+	clk = clk_register_gate(NULL, "spi1_clk", "per_pll_clk", 0, clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
+			CLKMGR_SPI_M_CLK_EN, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "fff01000.spi");
 }
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index 00c0240..e5ecab5 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -59,6 +59,12 @@ config SPI_ALTERA
 	help
 	  This is the driver for the Altera SPI Controller.
 
+config SPI_CADENCE_QSPI
+	tristate "Cadence QSPI Controller"
+	depends on ARCH_SOCFPGA
+	help
+	  This is the driver for the Cadence QSPI Controller.
+
 config SPI_ATH79
 	tristate "Atheros AR71XX/AR724X/AR913X SPI controller driver"
 	depends on ATH79 && GENERIC_GPIO
@@ -412,6 +418,10 @@ config SPI_DESIGNWARE
 	help
 	  general driver for SPI controller core from DesignWare
 
+config SPI_DW_PL330_DMA
+	bool "DMA support for DW SPI controller through DMA PL330 controller"
+	depends on SPI_DESIGNWARE && PL330_DMA
+
 config SPI_DW_PCI
 	tristate "PCI interface driver for DW SPI core"
 	depends on SPI_DESIGNWARE && PCI
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 9d75d21..2c0b2d5 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -19,10 +19,13 @@ obj-$(CONFIG_SPI_BFIN5XX)		+= spi-bfin5xx.o
 obj-$(CONFIG_SPI_BFIN_SPORT)		+= spi-bfin-sport.o
 obj-$(CONFIG_SPI_BITBANG)		+= spi-bitbang.o
 obj-$(CONFIG_SPI_BUTTERFLY)		+= spi-butterfly.o
+obj-$(CONFIG_SPI_CLPS711X)		+= spi-clps711x.o
+obj-$(CONFIG_SPI_CADENCE_QSPI)		+= spi-cadence-qspi-apb.o spi-cadence-qspi.o
 obj-$(CONFIG_SPI_COLDFIRE_QSPI)		+= spi-coldfire-qspi.o
 obj-$(CONFIG_SPI_DAVINCI)		+= spi-davinci.o
 obj-$(CONFIG_SPI_DESIGNWARE)		+= spi-dw.o
 obj-$(CONFIG_SPI_DW_MMIO)		+= spi-dw-mmio.o
+obj-$(CONFIG_SPI_DW_PL330_DMA)          += spi-dw-pl330.o
 obj-$(CONFIG_SPI_DW_PCI)		+= spi-dw-midpci.o
 spi-dw-midpci-objs			:= spi-dw-pci.o spi-dw-mid.o
 obj-$(CONFIG_SPI_EP93XX)		+= spi-ep93xx.o
diff --git a/drivers/spi/spi-cadence-qspi-apb.c b/drivers/spi/spi-cadence-qspi-apb.c
new file mode 100644
index 0000000..275ef28
--- /dev/null
+++ b/drivers/spi/spi-cadence-qspi-apb.c
@@ -0,0 +1,806 @@
+/*
+ * Driver for Cadence QSPI Controller
+ *
+ * Copyright (C) 2012 Altera Corporation
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/spi/spi.h>
+#include "spi-cadence-qspi.h"
+#include "spi-cadence-qspi-apb.h"
+
+static unsigned int cadence_qspi_apb_cmd2addr(const unsigned char* addr_buf,
+	unsigned int addr_width)
+{
+	unsigned int addr;
+
+	addr = (addr_buf[0] << 16) | (addr_buf[1] << 8) | addr_buf[2];
+
+	if (addr_width == 4)
+		addr = (addr << 8) | addr_buf[3];
+
+	return addr;
+}
+
+static void cadence_qspi_apb_read_fifo_data(void *dest, const void *src_ahb_addr,
+			 unsigned int bytes)
+{
+	unsigned int temp;
+	int remaining = bytes;
+	unsigned int *dest_ptr = (unsigned int *)dest;
+	unsigned int *src_ptr = (unsigned int *)src_ahb_addr;
+
+	while (remaining > 0) {
+		if (remaining >= CQSPI_FIFO_WIDTH) {
+			*dest_ptr = CQSPI_READL(src_ptr);
+			remaining -= CQSPI_FIFO_WIDTH;
+		} else {
+			/* dangling bytes */
+			temp = CQSPI_READL(src_ptr);
+			memcpy(dest_ptr, &temp, remaining);
+			break;
+		}
+		dest_ptr++;
+	}
+
+	return;
+}
+
+static void cadence_qspi_apb_write_fifo_data(void *dest_ahb_addr,
+					const void *src, unsigned int bytes)
+{
+	unsigned int temp;
+	int remaining = bytes;
+	unsigned int *dest_ptr = (unsigned int *)dest_ahb_addr;
+	unsigned int *src_ptr = (unsigned int *)src;
+
+	while (remaining > 0) {
+		if (remaining >= CQSPI_FIFO_WIDTH) {
+			CQSPI_WRITEL(*src_ptr, dest_ptr);
+			remaining -= CQSPI_FIFO_WIDTH;
+		} else {
+			/* dangling bytes */
+			memcpy(&temp, src_ptr, remaining);
+			CQSPI_WRITEL(temp, dest_ptr);
+			break;
+		}
+		src_ptr++;
+	}
+
+	return;
+}
+
+/* Return 1 if idle, otherwise return 0 (busy). */
+static unsigned int cadence_qspi_wait_idle(void * reg_base) {
+	unsigned int count = 0;
+	unsigned timeout;
+
+	timeout = cadence_qspi_init_timeout(CQSPI_TIMEOUT_MS);
+	while (cadence_qspi_check_timeout(timeout)) {
+		if (CQSPI_REG_IS_IDLE(reg_base)) {
+			/* Read few times in succession to ensure it does
+			not transition low again */
+			count++;
+			if (count >= CQSPI_POLL_IDLE_RETRY)
+				return 1;
+		} else {
+			count = 0;
+		}
+	}
+
+	/* Timeout, in busy mode. */
+	pr_err("QSPI: QSPI is still busy after %dms timeout.\n",
+		CQSPI_TIMEOUT_MS);
+	return 0;
+}
+
+static void cadence_qspi_apb_readdata_capture(void *reg_base,
+			unsigned int bypass, unsigned int delay)
+{
+	unsigned int reg;
+
+	cadence_qspi_apb_controller_disable(reg_base);
+	reg = CQSPI_READL(reg_base + CQSPI_REG_READCAPTURE);
+
+	if (bypass) {
+		reg |= (1 << CQSPI_REG_READCAPTURE_BYPASS_LSB);
+	} else {
+		reg &= ~(1 << CQSPI_REG_READCAPTURE_BYPASS_LSB);
+	}
+
+	reg &= ~(CQSPI_REG_READCAPTURE_DELAY_MASK
+		<< CQSPI_REG_READCAPTURE_DELAY_LSB);
+
+	reg |= ((delay & CQSPI_REG_READCAPTURE_DELAY_MASK)
+		<< CQSPI_REG_READCAPTURE_DELAY_LSB);
+
+	CQSPI_WRITEL(reg, reg_base + CQSPI_REG_READCAPTURE);
+
+	cadence_qspi_apb_controller_enable(reg_base);
+	return;
+}
+
+static void cadence_qspi_apb_config_baudrate_div(void *reg_base,
+		unsigned int ref_clk_hz, unsigned int sclk_hz)
+{
+	unsigned int reg;
+	unsigned int div;
+
+	cadence_qspi_apb_controller_disable(reg_base);
+	reg = CQSPI_READL(reg_base + CQSPI_REG_CONFIG);
+	reg &= ~(CQSPI_REG_CONFIG_BAUD_MASK << CQSPI_REG_CONFIG_BAUD_LSB);
+
+	div = ref_clk_hz / sclk_hz;
+
+	/* Recalculate the baudrate divisor based on QSPI specification. */
+	if (div > 32)
+		div = 32;
+
+	/* Check if even number. */
+	if (div & 1)
+		div = (div / 2);
+	else
+		div = (div / 2) - 1;
+
+	pr_debug("QSPI: ref_clk %dHz sclk %dHz div 0x%x\n", ref_clk_hz,
+		sclk_hz, div);
+
+	div = (div & CQSPI_REG_CONFIG_BAUD_MASK) << CQSPI_REG_CONFIG_BAUD_LSB;
+	reg |= div;
+	CQSPI_WRITEL(reg, reg_base + CQSPI_REG_CONFIG);
+
+	cadence_qspi_apb_controller_enable(reg_base);
+	return;
+}
+
+static void cadence_qspi_apb_chipselect(void * reg_base,
+	unsigned int chip_select, unsigned int decoder_enable)
+{
+	unsigned int reg;
+
+	cadence_qspi_apb_controller_disable(reg_base);
+
+	pr_debug("QSPI: chipselect %d decode %d\n", chip_select,
+		decoder_enable);
+
+	reg = CQSPI_READL(reg_base + CQSPI_REG_CONFIG);
+	/* docoder */
+	if (decoder_enable)
+		reg |= CQSPI_REG_CONFIG_DECODE_MASK;
+	else {
+		reg &= ~CQSPI_REG_CONFIG_DECODE_MASK;
+
+		/* Convert CS if without decoder.
+		 * CS0 to 4b'1110
+		 * CS1 to 4b'1101
+		 * CS2 to 4b'1011
+		 * CS3 to 4b'0111
+		 */
+		chip_select = 0xF & ~(1 << chip_select);
+	}
+
+	reg &= ~(CQSPI_REG_CONFIG_CHIPSELECT_MASK
+			<< CQSPI_REG_CONFIG_CHIPSELECT_LSB);
+	reg |= (chip_select & CQSPI_REG_CONFIG_CHIPSELECT_MASK)
+			<< CQSPI_REG_CONFIG_CHIPSELECT_LSB;
+	CQSPI_WRITEL(reg, reg_base + CQSPI_REG_CONFIG);
+
+	cadence_qspi_apb_controller_enable(reg_base);
+	return;
+}
+
+static int cadence_qspi_apb_exec_flash_cmd(void *reg_base, unsigned int reg)
+{
+	unsigned int timeout;
+
+	/* Write the CMDCTRL without start execution. */
+	CQSPI_WRITEL(reg, reg_base + CQSPI_REG_CMDCTRL);
+	/* Start execute */
+	reg |= CQSPI_REG_CMDCTRL_EXECUTE_MASK;
+	CQSPI_WRITEL(reg, reg_base + CQSPI_REG_CMDCTRL);
+
+	/* Polling for completion. */
+	timeout = cadence_qspi_init_timeout(CQSPI_TIMEOUT_MS);
+	while (cadence_qspi_check_timeout(timeout)) {
+		reg = CQSPI_READL(reg_base + CQSPI_REG_CMDCTRL) &
+			CQSPI_REG_CMDCTRL_INPROGRESS_MASK;
+		if (!reg)
+			break;
+	}
+
+	if (reg != 0) {
+		pr_err("QSPI: flash cmd execute time out\n");
+		return -EIO;
+	}
+
+	/* Polling QSPI idle status. */
+	if (!cadence_qspi_wait_idle(reg_base))
+		return -EIO;
+
+	return 0;
+}
+
+/* For command RDID, RDSR. */
+static int cadence_qspi_apb_command_read(void *reg_base,
+	unsigned int txlen, const unsigned char *txbuf,
+	unsigned rxlen, unsigned char *rxbuf)
+{
+	unsigned int reg;
+	unsigned int read_len;
+	int status;
+
+	if (!rxlen || rxlen > CQSPI_STIG_DATA_LEN_MAX || rxbuf == NULL) {
+		pr_err("QSPI: Invalid input argument, len %d rxbuf 0x%08x\n",
+			rxlen, (unsigned int)rxbuf);
+		return -EINVAL;
+	}
+
+	reg = txbuf[0] << CQSPI_REG_CMDCTRL_OPCODE_LSB;
+
+	reg |= (0x1 << CQSPI_REG_CMDCTRL_RD_EN_LSB);
+
+	/* 0 means 1 byte. */
+	reg |= (((rxlen - 1) & CQSPI_REG_CMDCTRL_RD_BYTES_MASK)
+		<< CQSPI_REG_CMDCTRL_RD_BYTES_LSB);
+	status = cadence_qspi_apb_exec_flash_cmd(reg_base, reg);
+	if (status != 0)
+		return status;
+
+	reg = CQSPI_READL(reg_base + CQSPI_REG_CMDREADDATALOWER);
+
+	/* Put the read value into rx_buf */
+	read_len = (rxlen > 4) ? 4 : rxlen;
+	memcpy(rxbuf, &reg, read_len);
+	rxbuf += read_len;
+
+	if (rxlen > 4) {
+		reg = CQSPI_READL(reg_base + CQSPI_REG_CMDREADDATAUPPER);
+
+		read_len = rxlen - read_len;
+		memcpy(rxbuf, &reg, read_len);
+	}
+
+	return 0;
+}
+
+/* For commands: WRSR, WREN, WRDI, CHIP_ERASE, BE, etc. */
+static int cadence_qspi_apb_command_write(void *reg_base, unsigned txlen,
+	const unsigned char *txbuf)
+{
+	unsigned int reg;
+	unsigned int addr_value;
+	unsigned int data;
+
+	if (!txlen || txlen > 5 || txbuf == NULL) {
+		pr_err("QSPI: Invalid input argument, cmdlen %d txbuf 0x%08x\n",
+			txlen, (unsigned int)txbuf);
+		return -EINVAL;
+	}
+
+	reg = txbuf[0] << CQSPI_REG_CMDCTRL_OPCODE_LSB;
+	if (txlen == 2 || txlen == 3) {
+		/* Command with data only. */
+		reg |= (0x1 << CQSPI_REG_CMDCTRL_WR_EN_LSB);
+		reg |= ((txlen - 2) & CQSPI_REG_CMDCTRL_WR_BYTES_MASK)
+			<< CQSPI_REG_CMDCTRL_WR_BYTES_LSB;
+
+		memcpy(&data, &txbuf[1], txlen - 1);
+		/* Write the data */
+		CQSPI_WRITEL(data, reg_base + CQSPI_REG_CMDWRITEDATALOWER);
+	}
+	else if (txlen == 4 || txlen == 5) {
+		/* Command with address */
+		reg |= (0x1 << CQSPI_REG_CMDCTRL_ADDR_EN_LSB);
+		/* Number of bytes to write. */
+		reg |= ((txlen - 2) & CQSPI_REG_CMDCTRL_ADD_BYTES_MASK)
+			<< CQSPI_REG_CMDCTRL_ADD_BYTES_LSB;
+		/* Get address */
+		addr_value = cadence_qspi_apb_cmd2addr(&txbuf[1],
+			txlen >=5 ? 4 : 3);
+
+		CQSPI_WRITEL(addr_value, reg_base + CQSPI_REG_CMDADDRESS);
+	}
+
+	return cadence_qspi_apb_exec_flash_cmd(reg_base, reg);
+}
+
+static int cadence_qspi_apb_indirect_read_setup(void *reg_base,
+	unsigned int ahb_phy_addr, unsigned txlen, const unsigned char *txbuf,
+	unsigned int addr_bytes)
+{
+	unsigned int reg;
+	unsigned int addr_value;
+	unsigned int dummy_clk;
+	unsigned int dummy_bytes;
+
+	if ((addr_bytes == 3 && txlen < 4) || (addr_bytes == 4 && txlen < 5)) {
+		pr_err("QSPI: Invalid txbuf length, length %d\n", txlen);
+		return -EINVAL;
+	}
+
+	CQSPI_WRITEL((ahb_phy_addr & CQSPI_INDIRECTTRIGGER_ADDR_MASK),
+		reg_base + CQSPI_REG_INDIRECTTRIGGER);
+
+	reg = txbuf[0] << CQSPI_REG_RD_INSTR_OPCODE_LSB;
+
+#ifdef CONFIG_M25PXX_USE_FAST_READ_QUAD_OUTPUT
+	reg |= (CQSPI_INST_TYPE_QUAD << CQSPI_REG_RD_INSTR_TYPE_DATA_LSB);
+#endif /* CONFIG_M25PXX_USE_FAST_READ_QUAD_OUTPUT */
+
+	/* Get address */
+	addr_value = cadence_qspi_apb_cmd2addr(&txbuf[1], addr_bytes);
+	CQSPI_WRITEL(addr_value, reg_base + CQSPI_REG_INDIRECTRDSTARTADDR);
+
+	/* The remaining lenght is dummy bytes. */
+	dummy_bytes = txlen - addr_bytes - 1;
+
+	/* Setup dummy clock cycles */
+	if (dummy_bytes) {
+
+		if (dummy_bytes > CQSPI_DUMMY_BYTES_MAX)
+			dummy_bytes = CQSPI_DUMMY_BYTES_MAX;
+
+		reg |= (1 << CQSPI_REG_RD_INSTR_MODE_EN_LSB);
+		/* Set all high to ensure chip doesn't enter XIP */
+		CQSPI_WRITEL(0xFF, reg_base + CQSPI_REG_MODE_BIT);
+
+		/* Convert to clock cycles. */
+		dummy_clk = dummy_bytes * CQSPI_DUMMY_CLKS_PER_BYTE;
+		/* Need to minus the mode byte (8 clocks). */
+		dummy_clk -= CQSPI_DUMMY_CLKS_PER_BYTE;
+
+		if (dummy_clk)
+			reg |= (dummy_clk & CQSPI_REG_RD_INSTR_DUMMY_MASK)
+				<< CQSPI_REG_RD_INSTR_DUMMY_LSB;
+	}
+
+	CQSPI_WRITEL(reg, reg_base + CQSPI_REG_RD_INSTR);
+
+	/* Set device size */
+	reg = CQSPI_READL(reg_base + CQSPI_REG_SIZE);
+	reg &= ~CQSPI_REG_SIZE_ADDRESS_MASK;
+	reg |= (addr_bytes - 1);
+	CQSPI_WRITEL(reg, reg_base + CQSPI_REG_SIZE);
+	return 0;
+}
+
+static int cadence_qspi_apb_indirect_read_execute(
+	struct struct_cqspi *cadence_qspi, unsigned rxlen,
+	unsigned char *rxbuf)
+{
+	unsigned int reg = 0;
+	unsigned int timeout;
+	unsigned int watermark = CQSPI_REG_SRAM_THRESHOLD_BYTES;
+	unsigned int *irq_status = &(cadence_qspi->irq_status);
+	struct platform_device *pdev = cadence_qspi->pdev;
+	struct cqspi_platform_data *pdata = pdev->dev.platform_data;
+	void *reg_base = cadence_qspi->iobase;
+	void *ahb_base = cadence_qspi->qspi_ahb_virt;
+	int remaining = (int)rxlen;
+	int ret = 0;
+
+	if (remaining < watermark)
+		watermark = remaining;
+
+	CQSPI_WRITEL(watermark, reg_base + CQSPI_REG_INDIRECTRDWATERMARK);
+	CQSPI_WRITEL(remaining, reg_base + CQSPI_REG_INDIRECTRDBYTES);
+	CQSPI_WRITEL(pdata->fifo_depth - CQSPI_REG_SRAM_RESV_WORDS,
+		reg_base + CQSPI_REG_SRAMPARTITION);
+
+	/* Clear all interrupts. */
+	CQSPI_WRITEL(CQSPI_IRQ_STATUS_MASK, reg_base + CQSPI_REG_IRQSTATUS);
+
+	CQSPI_WRITEL(CQSPI_IRQ_MASK_RD, reg_base + CQSPI_REG_IRQMASK);
+
+	CQSPI_WRITEL(CQSPI_REG_INDIRECTRD_START_MASK,
+			reg_base + CQSPI_REG_INDIRECTRD);
+
+	while (remaining > 0) {
+		ret = wait_event_interruptible_timeout(cadence_qspi->waitqueue,
+			*irq_status, CQSPI_TIMEOUT_MS);
+		if (!ret) {
+			pr_err("QSPI: Indirect read timeout\n");
+			ret = -ETIMEDOUT;
+			goto failrd;
+		}
+
+		if (*irq_status & CQSPI_IRQ_STATUS_ERR) {
+			/* Error occurred */
+			pr_err("QSPI: Indirect read error IRQ status 0x%08x\n",
+				*irq_status);
+			ret = -EPERM;
+			goto failrd;
+		}
+
+		if (*irq_status & (CQSPI_REG_IRQ_IND_RD_OVERFLOW |
+			CQSPI_REG_IRQ_IND_COMP | CQSPI_REG_IRQ_WATERMARK)) {
+
+			reg = CQSPI_GET_RD_SRAM_LEVEL(reg_base);
+			/* convert to bytes */
+			reg *= CQSPI_FIFO_WIDTH;
+			reg = reg > remaining ? remaining : reg;
+			/* Read data from FIFO. */
+			cadence_qspi_apb_read_fifo_data(rxbuf, ahb_base, reg);
+			rxbuf += reg;
+			remaining -= reg;
+		}
+	}
+
+	/* Check indirect done status */
+	timeout = cadence_qspi_init_timeout(CQSPI_TIMEOUT_MS);
+	while (cadence_qspi_check_timeout(timeout)) {
+		reg = CQSPI_READL(reg_base + CQSPI_REG_INDIRECTRD);
+		if (reg & CQSPI_REG_INDIRECTRD_DONE_MASK)
+			break;
+	}
+
+	if (!(reg & CQSPI_REG_INDIRECTRD_DONE_MASK)) {
+		pr_err("QSPI : Indirect read completion status error with "
+			"reg 0x%08x\n", reg);
+		ret = -ETIMEDOUT;
+		goto failrd;
+	}
+
+	/* Disable interrupt */
+	CQSPI_WRITEL(0, reg_base + CQSPI_REG_IRQMASK);
+
+	/* Clear indirect completion status */
+	CQSPI_WRITEL(CQSPI_REG_INDIRECTRD_DONE_MASK,
+		reg_base + CQSPI_REG_INDIRECTRD);
+	return 0;
+
+failrd:
+	/* Disable interrupt */
+	CQSPI_WRITEL(0, reg_base + CQSPI_REG_IRQMASK);
+
+	/* Cancel the indirect read */
+	CQSPI_WRITEL(CQSPI_REG_INDIRECTWR_CANCEL_MASK,
+			reg_base + CQSPI_REG_INDIRECTRD);
+	return ret;
+}
+
+static int cadence_qspi_apb_indirect_write_setup(void *reg_base,
+	unsigned int ahb_phy_addr, unsigned txlen, const unsigned char *txbuf)
+{
+	unsigned int reg;
+	unsigned int addr_bytes = (txlen >= 5) ? 4: 3;
+
+	if (txlen < 4 || txbuf == NULL) {
+		pr_err("QSPI: Invalid input argument, txlen %d txbuf 0x%08x\n",
+			txlen, (unsigned int)txbuf);
+		return -EINVAL;
+	}
+
+	CQSPI_WRITEL( (ahb_phy_addr & CQSPI_INDIRECTTRIGGER_ADDR_MASK),
+		reg_base + CQSPI_REG_INDIRECTTRIGGER);
+
+	/* Set opcode. */
+	reg = txbuf[0] << CQSPI_REG_WR_INSTR_OPCODE_LSB;
+	CQSPI_WRITEL(reg, reg_base + CQSPI_REG_WR_INSTR);
+
+	/* Setup write address. */
+	reg = cadence_qspi_apb_cmd2addr(&txbuf[1], addr_bytes);
+	CQSPI_WRITEL(reg, reg_base + CQSPI_REG_INDIRECTWRSTARTADDR);
+
+	reg = CQSPI_READL(reg_base + CQSPI_REG_SIZE);
+	reg &= ~CQSPI_REG_SIZE_ADDRESS_MASK;
+	reg |= (addr_bytes - 1);
+	CQSPI_WRITEL(reg, reg_base +  CQSPI_REG_SIZE);
+	return 0;
+}
+
+static int cadence_qspi_apb_indirect_write_execute(
+	struct struct_cqspi *cadence_qspi, unsigned txlen,
+	const unsigned char *txbuf)
+{
+	int ret;
+	unsigned int timeout;
+	unsigned int reg = 0;
+	unsigned int *irq_status = &(cadence_qspi->irq_status);
+	void *reg_base = cadence_qspi->iobase;
+	void *ahb_base = cadence_qspi->qspi_ahb_virt;
+	struct platform_device *pdev = cadence_qspi->pdev;
+	struct cqspi_platform_data *pdata = pdev->dev.platform_data;
+	struct cqspi_flash_pdata *f_pdata =
+			&(pdata->f_pdata[cadence_qspi->current_cs]);
+	unsigned int page_size = f_pdata->page_size;
+	int remaining = (int)txlen;
+	unsigned int write_bytes;
+
+	CQSPI_WRITEL(remaining, reg_base + CQSPI_REG_INDIRECTWRBYTES);
+
+	CQSPI_WRITEL(CQSPI_REG_SRAM_THRESHOLD_BYTES, reg_base +
+			CQSPI_REG_INDIRECTWRWATERMARK);
+
+	CQSPI_WRITEL(CQSPI_REG_SRAM_PARTITION_WR,
+			reg_base + CQSPI_REG_SRAMPARTITION);
+
+	/* Clear all interrupts. */
+	CQSPI_WRITEL(CQSPI_IRQ_STATUS_MASK, reg_base + CQSPI_REG_IRQSTATUS);
+
+	CQSPI_WRITEL(CQSPI_IRQ_MASK_WR, reg_base + CQSPI_REG_IRQMASK);
+
+	CQSPI_WRITEL(CQSPI_REG_INDIRECTWR_START_MASK,
+			reg_base + CQSPI_REG_INDIRECTWR);
+
+	/* Write a page or remaining bytes. */
+	write_bytes = remaining > page_size ? page_size : remaining;
+	/* Fill up the data at the begining */
+	cadence_qspi_apb_write_fifo_data(ahb_base, txbuf, write_bytes);
+	txbuf += write_bytes;
+	remaining -= write_bytes;
+
+	while (remaining > 0) {
+		ret = wait_event_interruptible_timeout(cadence_qspi->waitqueue,
+			*irq_status, CQSPI_TIMEOUT_MS);
+		if (!ret) {
+			pr_err("QSPI: Indirect write timeout\n");
+			ret = -ETIMEDOUT;
+			goto failwr;
+		}
+
+		if (*irq_status & CQSPI_IRQ_STATUS_ERR) {
+			/* Error occurred */
+			pr_err("QSPI : Indirect write error"
+				"IRQ status 0x%08x\n", *irq_status);
+			ret = -EPERM;
+			goto failwr;
+		}
+
+		if (*irq_status & (CQSPI_REG_IRQ_UNDERFLOW |
+			CQSPI_REG_IRQ_IND_COMP | CQSPI_REG_IRQ_WATERMARK)){
+			/* Calculate number of bytes to write. */
+			write_bytes = remaining > page_size ?
+				page_size : remaining;
+
+			cadence_qspi_apb_write_fifo_data(ahb_base, txbuf,
+				write_bytes);
+			txbuf  += write_bytes;
+			remaining -= write_bytes;
+		}
+	}
+
+	/* Check indirect done status */
+	timeout = cadence_qspi_init_timeout(CQSPI_TIMEOUT_MS);
+	while (cadence_qspi_check_timeout(timeout)) {
+		reg = CQSPI_READL(reg_base + CQSPI_REG_INDIRECTWR);
+		if (reg & CQSPI_REG_INDIRECTWR_DONE_MASK)
+			break;
+	}
+
+	if (!(reg & CQSPI_REG_INDIRECTWR_DONE_MASK)) {
+		pr_err("QSPI: Indirect write completion status error with "
+			"reg 0x%08x\n", reg);
+		ret = -ETIMEDOUT;
+		goto failwr;
+	}
+
+	/* Disable interrupt. */
+	CQSPI_WRITEL(0, reg_base + CQSPI_REG_IRQMASK);
+
+	/* Clear indirect completion status */
+	CQSPI_WRITEL(CQSPI_REG_INDIRECTWR_DONE_MASK,
+		reg_base + CQSPI_REG_INDIRECTWR);
+	return 0;
+
+failwr:
+	/* Disable interrupt. */
+	CQSPI_WRITEL(0, reg_base + CQSPI_REG_IRQMASK);
+
+	/* Cancel the indirect write */
+	CQSPI_WRITEL(CQSPI_REG_INDIRECTWR_CANCEL_MASK,
+		reg_base + CQSPI_REG_INDIRECTWR);
+	return ret;
+}
+
+void cadence_qspi_apb_controller_enable(void *reg_base)
+{
+	unsigned int reg;
+	reg = CQSPI_READL(reg_base + CQSPI_REG_CONFIG);
+	reg |= CQSPI_REG_CONFIG_ENABLE_MASK;
+	CQSPI_WRITEL(reg, reg_base + CQSPI_REG_CONFIG);
+	return;
+}
+
+void cadence_qspi_apb_controller_disable(void *reg_base)
+{
+	unsigned int reg;
+	reg = CQSPI_READL(reg_base + CQSPI_REG_CONFIG);
+	reg &= ~CQSPI_REG_CONFIG_ENABLE_MASK;
+	CQSPI_WRITEL(reg, reg_base + CQSPI_REG_CONFIG);
+	return;
+}
+
+unsigned int cadence_qspi_apb_is_controller_ready(void *reg_base)
+{
+	return cadence_qspi_wait_idle(reg_base);
+}
+
+void cadence_qspi_apb_controller_init(struct struct_cqspi *cadence_qspi)
+{
+	cadence_qspi_apb_controller_disable(cadence_qspi->iobase);
+
+	/* Configure the remap address register, no remap */
+	CQSPI_WRITEL(0, cadence_qspi->iobase + CQSPI_REG_REMAP);
+
+	/* Disable all interrupts. */
+	CQSPI_WRITEL(0, cadence_qspi->iobase + CQSPI_REG_IRQMASK);
+
+	/* Set read data capture to default. */
+	cadence_qspi_apb_readdata_capture(cadence_qspi->iobase, 1, 0);
+
+	cadence_qspi_apb_controller_enable(cadence_qspi->iobase);
+	return;
+}
+
+void cadence_qspi_apb_delay(struct struct_cqspi *cadence_qspi,
+	unsigned int ref_clk, unsigned int sclk_hz)
+{
+	void __iomem *iobase = cadence_qspi->iobase;
+	struct platform_device *pdev = cadence_qspi->pdev;
+	struct cqspi_platform_data *pdata = pdev->dev.platform_data;
+	struct cqspi_flash_pdata *f_pdata =
+			&(pdata->f_pdata[cadence_qspi->current_cs]);
+	unsigned int ref_clk_ns;
+	unsigned int sclk_ns;
+	unsigned int tshsl, tchsh, tslch, tsd2d;
+	unsigned int reg;
+
+	cadence_qspi_apb_controller_disable(iobase);
+
+	/* Convert to ns. */
+	ref_clk_ns = (1000000000) / pdata->master_ref_clk_hz;
+
+	/* Convert to ns. */
+	sclk_ns = (1000000000) / sclk_hz;
+
+	/* Plus 1 to round up 1 clock cycle. */
+	tshsl = CQSPI_CAL_DELAY(f_pdata->tshsl_ns, ref_clk_ns, sclk_ns) + 1;
+	tchsh = CQSPI_CAL_DELAY(f_pdata->tchsh_ns, ref_clk_ns, sclk_ns) + 1;
+	tslch = CQSPI_CAL_DELAY(f_pdata->tslch_ns, ref_clk_ns, sclk_ns) + 1;
+	tsd2d = CQSPI_CAL_DELAY(f_pdata->tsd2d_ns, ref_clk_ns, sclk_ns) + 1;
+
+	reg = ((tshsl & CQSPI_REG_DELAY_TSHSL_MASK)
+			<< CQSPI_REG_DELAY_TSHSL_LSB);
+	reg |= ((tchsh & CQSPI_REG_DELAY_TCHSH_MASK)
+			<< CQSPI_REG_DELAY_TCHSH_LSB);
+	reg |= ((tslch & CQSPI_REG_DELAY_TSLCH_MASK)
+			<< CQSPI_REG_DELAY_TSLCH_LSB);
+	reg |= ((tsd2d & CQSPI_REG_DELAY_TSD2D_MASK)
+			<< CQSPI_REG_DELAY_TSD2D_LSB);
+	CQSPI_WRITEL(reg, iobase + CQSPI_REG_DELAY);
+
+	cadence_qspi_apb_controller_enable(iobase);
+	return;
+}
+
+void cadence_qspi_switch_cs(struct struct_cqspi *cadence_qspi,
+	unsigned int cs)
+{
+	unsigned int reg;
+	struct platform_device *pdev = cadence_qspi->pdev;
+	struct cqspi_platform_data *pdata = pdev->dev.platform_data;
+	struct cqspi_flash_pdata *f_pdata = &(pdata->f_pdata[cs]);
+	void __iomem *iobase = cadence_qspi->iobase;
+
+	cadence_qspi_apb_controller_disable(iobase);
+
+	/* Configure page size and block size. */
+	reg = CQSPI_READL(iobase + CQSPI_REG_SIZE);
+	/* clear the previous value */
+	reg &= ~(CQSPI_REG_SIZE_PAGE_MASK << CQSPI_REG_SIZE_PAGE_LSB);
+	reg &= ~(CQSPI_REG_SIZE_BLOCK_MASK << CQSPI_REG_SIZE_BLOCK_LSB);
+	reg |= (f_pdata->page_size << CQSPI_REG_SIZE_PAGE_LSB);
+	reg |= (f_pdata->block_size << CQSPI_REG_SIZE_BLOCK_LSB);
+	CQSPI_WRITEL(reg, iobase + CQSPI_REG_SIZE);
+
+	/* configure the chip select */
+	cadence_qspi_apb_chipselect (iobase, cs, pdata->ext_decoder);
+	cadence_qspi_apb_controller_enable(iobase);
+	return;
+}
+
+int cadence_qspi_apb_process_queue(struct struct_cqspi *cadence_qspi,
+				  struct spi_device *spi, unsigned int n_trans,
+				  struct spi_transfer **spi_xfer)
+{
+	struct platform_device *pdev = cadence_qspi->pdev;
+	struct cqspi_platform_data *pdata = pdev->dev.platform_data;
+	struct spi_transfer *cmd_xfer = spi_xfer[0];
+	struct spi_transfer *data_xfer = (n_trans >= 2) ? spi_xfer[1] : NULL;
+	void __iomem *iobase = cadence_qspi->iobase;
+	unsigned int sclk;
+	int ret = 0;
+
+	if (!cmd_xfer->len) {
+		pr_err("QSPI: SPI transfer length is 0.\n");
+		return -EINVAL;
+	}
+
+	/* Setup baudrate divisor. */
+	sclk = cmd_xfer->speed_hz ? cmd_xfer->speed_hz : spi->max_speed_hz;
+	cadence_qspi_apb_config_baudrate_div(iobase,
+		pdata->master_ref_clk_hz, sclk);
+
+	/* Switch chip select. */
+	if (cadence_qspi->current_cs != spi->chip_select) {
+		cadence_qspi->current_cs = spi->chip_select;
+		cadence_qspi_switch_cs(cadence_qspi, spi->chip_select);
+	}
+
+	/* Configure device delay if we change device clock. */
+	cadence_qspi_apb_delay(cadence_qspi, pdata->master_ref_clk_hz, sclk);
+
+	/*
+	 * Use STIG command to send if the transfer length is less than
+	 * 4 or if only one transfer.
+	 */
+	 if ((cmd_xfer->len < 4) || (n_trans == 1)) {
+		 /* STIG command */
+		 if (data_xfer && data_xfer->rx_buf) {
+			 /* STIG read */
+			 ret = cadence_qspi_apb_command_read(iobase,
+				cmd_xfer->len, cmd_xfer->tx_buf,
+				data_xfer->len, data_xfer->rx_buf);
+		 } else {
+			 /* STIG write */
+			 ret = cadence_qspi_apb_command_write(iobase,
+				 cmd_xfer->len, cmd_xfer->tx_buf);
+		 }
+	 } else if (cmd_xfer->len >= 4 && (n_trans == 2)){
+		 /* Indirect operation */
+		 if (data_xfer->rx_buf) {
+			 /* Indirect read */
+			 ret = cadence_qspi_apb_indirect_read_setup(iobase,
+				 pdata->qspi_ahb_phy, cmd_xfer->len,
+				 cmd_xfer->tx_buf, spi->addr_width);
+			 ret = cadence_qspi_apb_indirect_read_execute(
+				cadence_qspi, data_xfer->len,
+				data_xfer->rx_buf);
+		 } else {
+			 /* Indirect write */
+			 ret = cadence_qspi_apb_indirect_write_setup(
+				 iobase, pdata->qspi_ahb_phy,
+				 cmd_xfer->len, cmd_xfer->tx_buf);
+			ret = cadence_qspi_apb_indirect_write_execute(
+				cadence_qspi, data_xfer->len,
+				data_xfer->tx_buf);
+		 }
+	 } else {
+		pr_err("QSPI : Unknown SPI transfer.\n");
+		return -EINVAL;
+	 }
+	return ret;
+}
+
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/spi/spi-cadence-qspi-apb.h b/drivers/spi/spi-cadence-qspi-apb.h
new file mode 100644
index 0000000..ff7f56b
--- /dev/null
+++ b/drivers/spi/spi-cadence-qspi-apb.h
@@ -0,0 +1,226 @@
+/*
+ * Driver for Cadence QSPI Controller
+ *
+ * Copyright (C) 2012 Altera Corporation
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the
+ * OpenIB.org BSD license below:
+ *
+ *     Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *      - Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *
+ *      - Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+#ifndef __CADENCE_QSPI_APB_H__
+#define __CADENCE_QSPI_APB_H__
+
+#include "spi-cadence-qspi.h"
+
+/* Operation timeout value */
+#define CQSPI_TIMEOUT_MS			(5000)
+#define CQSPI_POLL_IDLE_RETRY			(3)
+
+#define CQSPI_FIFO_WIDTH			(4)
+
+/* Controller sram size in word */
+#define CQSPI_REG_SRAM_RESV_WORDS		(2)
+#define CQSPI_REG_SRAM_PARTITION_WR		(1)
+
+#define CQSPI_REG_SRAM_THRESHOLD_BYTES		(50)
+
+/* Instruction type */
+#define CQSPI_INST_TYPE_SINGLE			(0)
+#define CQSPI_INST_TYPE_DUAL			(1)
+#define CQSPI_INST_TYPE_QUAD			(2)
+
+#define CQSPI_DUMMY_CLKS_PER_BYTE		(8)
+#define CQSPI_DUMMY_BYTES_MAX			(4)
+
+#define CQSPI_STIG_DATA_LEN_MAX			(8)
+
+#define CQSPI_INDIRECTTRIGGER_ADDR_MASK		(0xFFFFF)
+
+/* Register map */
+#define	CQSPI_REG_CONFIG			0x00
+#define	CQSPI_REG_CONFIG_ENABLE_MASK		(1 << 0)
+#define	CQSPI_REG_CONFIG_DECODE_MASK		(1 << 9)
+#define	CQSPI_REG_CONFIG_CHIPSELECT_LSB		10
+#define	CQSPI_REG_CONFIG_DMA_MASK		(1 << 15)
+#define	CQSPI_REG_CONFIG_BAUD_LSB		19
+#define	CQSPI_REG_CONFIG_IDLE_LSB		31
+#define	CQSPI_REG_CONFIG_CHIPSELECT_MASK	0xF
+#define	CQSPI_REG_CONFIG_BAUD_MASK		0xF
+
+#define	CQSPI_REG_RD_INSTR			0x04
+#define	CQSPI_REG_RD_INSTR_OPCODE_LSB		0
+#define	CQSPI_REG_RD_INSTR_TYPE_INSTR_LSB	8
+#define	CQSPI_REG_RD_INSTR_TYPE_ADDR_LSB	12
+#define	CQSPI_REG_RD_INSTR_TYPE_DATA_LSB	16
+#define	CQSPI_REG_RD_INSTR_MODE_EN_LSB		20
+#define	CQSPI_REG_RD_INSTR_DUMMY_LSB		24
+#define	CQSPI_REG_RD_INSTR_TYPE_INSTR_MASK	0x3
+#define	CQSPI_REG_RD_INSTR_TYPE_ADDR_MASK	0x3
+#define	CQSPI_REG_RD_INSTR_TYPE_DATA_MASK	0x3
+#define	CQSPI_REG_RD_INSTR_DUMMY_MASK		0x1F
+
+#define	CQSPI_REG_WR_INSTR			0x08
+#define	CQSPI_REG_WR_INSTR_OPCODE_LSB		0
+
+#define	CQSPI_REG_DELAY				0x0C
+#define	CQSPI_REG_DELAY_TSLCH_LSB		0
+#define	CQSPI_REG_DELAY_TCHSH_LSB		8
+#define	CQSPI_REG_DELAY_TSD2D_LSB		16
+#define	CQSPI_REG_DELAY_TSHSL_LSB		24
+#define	CQSPI_REG_DELAY_TSLCH_MASK		0xFF
+#define	CQSPI_REG_DELAY_TCHSH_MASK		0xFF
+#define	CQSPI_REG_DELAY_TSD2D_MASK		0xFF
+#define	CQSPI_REG_DELAY_TSHSL_MASK		0xFF
+
+#define	CQSPI_REG_READCAPTURE			0x10
+#define	CQSPI_REG_READCAPTURE_BYPASS_LSB	0
+#define	CQSPI_REG_READCAPTURE_DELAY_LSB		1
+#define	CQSPI_REG_READCAPTURE_DELAY_MASK	0xF
+
+#define	CQSPI_REG_SIZE				0x14
+#define	CQSPI_REG_SIZE_ADDRESS_LSB		0
+#define	CQSPI_REG_SIZE_PAGE_LSB			4
+#define	CQSPI_REG_SIZE_BLOCK_LSB		16
+#define	CQSPI_REG_SIZE_ADDRESS_MASK		0xF
+#define	CQSPI_REG_SIZE_PAGE_MASK		0xFFF
+#define	CQSPI_REG_SIZE_BLOCK_MASK		0x3F
+
+#define	CQSPI_REG_SRAMPARTITION			0x18
+#define	CQSPI_REG_INDIRECTTRIGGER		0x1C
+
+#define	CQSPI_REG_DMA				0x20
+#define	CQSPI_REG_DMA_SINGLE_LSB		0
+#define	CQSPI_REG_DMA_BURST_LSB			8
+#define	CQSPI_REG_DMA_SINGLE_MASK		0xFF
+#define	CQSPI_REG_DMA_BURST_MASK		0xFF
+
+#define	CQSPI_REG_REMAP				0x24
+#define	CQSPI_REG_MODE_BIT			0x28
+
+#define	CQSPI_REG_SDRAMLEVEL			0x2C
+#define	CQSPI_REG_SDRAMLEVEL_RD_LSB		0
+#define	CQSPI_REG_SDRAMLEVEL_WR_LSB		16
+#define	CQSPI_REG_SDRAMLEVEL_RD_MASK		0xFFFF
+#define	CQSPI_REG_SDRAMLEVEL_WR_MASK		0xFFFF
+
+#define	CQSPI_REG_IRQSTATUS			0x40
+#define	CQSPI_REG_IRQMASK			0x44
+
+#define	CQSPI_REG_INDIRECTRD			0x60
+#define	CQSPI_REG_INDIRECTRD_START_MASK		(1 << 0)
+#define	CQSPI_REG_INDIRECTRD_CANCEL_MASK	(1 << 1)
+#define	CQSPI_REG_INDIRECTRD_DONE_MASK		(1 << 5)
+
+#define	CQSPI_REG_INDIRECTRDWATERMARK		0x64
+#define	CQSPI_REG_INDIRECTRDSTARTADDR		0x68
+#define	CQSPI_REG_INDIRECTRDBYTES		0x6C
+
+#define	CQSPI_REG_CMDCTRL			0x90
+#define	CQSPI_REG_CMDCTRL_EXECUTE_MASK		(1 << 0)
+#define	CQSPI_REG_CMDCTRL_INPROGRESS_MASK	(1 << 1)
+#define	CQSPI_REG_CMDCTRL_WR_BYTES_LSB		12
+#define	CQSPI_REG_CMDCTRL_WR_EN_LSB		15
+#define	CQSPI_REG_CMDCTRL_ADD_BYTES_LSB		16
+#define	CQSPI_REG_CMDCTRL_ADDR_EN_LSB		19
+#define	CQSPI_REG_CMDCTRL_RD_BYTES_LSB		20
+#define	CQSPI_REG_CMDCTRL_RD_EN_LSB		23
+#define	CQSPI_REG_CMDCTRL_OPCODE_LSB		24
+#define	CQSPI_REG_CMDCTRL_WR_BYTES_MASK		0x7
+#define	CQSPI_REG_CMDCTRL_ADD_BYTES_MASK	0x3
+#define	CQSPI_REG_CMDCTRL_RD_BYTES_MASK		0x7
+
+#define	CQSPI_REG_INDIRECTWR			0x70
+#define	CQSPI_REG_INDIRECTWR_START_MASK		(1 << 0)
+#define	CQSPI_REG_INDIRECTWR_CANCEL_MASK	(1 << 1)
+#define	CQSPI_REG_INDIRECTWR_DONE_MASK		(1 << 5)
+
+#define	CQSPI_REG_INDIRECTWRWATERMARK		0x74
+#define	CQSPI_REG_INDIRECTWRSTARTADDR		0x78
+#define	CQSPI_REG_INDIRECTWRBYTES		0x7C
+
+#define	CQSPI_REG_CMDADDRESS			0x94
+#define	CQSPI_REG_CMDREADDATALOWER		0xA0
+#define	CQSPI_REG_CMDREADDATAUPPER		0xA4
+#define	CQSPI_REG_CMDWRITEDATALOWER		0xA8
+#define	CQSPI_REG_CMDWRITEDATAUPPER		0xAC
+
+/* Interrupt status bits */
+#define CQSPI_REG_IRQ_MODE_ERR			(1 << 0)
+#define CQSPI_REG_IRQ_UNDERFLOW			(1 << 1)
+#define CQSPI_REG_IRQ_IND_COMP			(1 << 2)
+#define CQSPI_REG_IRQ_IND_RD_REJECT		(1 << 3)
+#define CQSPI_REG_IRQ_WR_PROTECTED_ERR		(1 << 4)
+#define CQSPI_REG_IRQ_ILLEGAL_AHB_ERR		(1 << 5)
+#define CQSPI_REG_IRQ_WATERMARK			(1 << 6)
+#define CQSPI_REG_IRQ_IND_RD_OVERFLOW		(1 << 12)
+
+#define CQSPI_IRQ_STATUS_ERR		(CQSPI_REG_IRQ_MODE_ERR		| \
+					 CQSPI_REG_IRQ_IND_RD_REJECT	| \
+					 CQSPI_REG_IRQ_WR_PROTECTED_ERR	| \
+					 CQSPI_REG_IRQ_ILLEGAL_AHB_ERR)
+
+#define CQSPI_IRQ_MASK_RD		(CQSPI_REG_IRQ_MODE_ERR		| \
+					 CQSPI_REG_IRQ_IND_RD_REJECT	| \
+					 CQSPI_REG_IRQ_WATERMARK	| \
+					 CQSPI_REG_IRQ_IND_RD_OVERFLOW	| \
+					 CQSPI_REG_IRQ_IND_COMP)
+
+#define CQSPI_IRQ_MASK_WR		(CQSPI_REG_IRQ_MODE_ERR		| \
+					 CQSPI_REG_IRQ_WR_PROTECTED_ERR	| \
+					 CQSPI_REG_IRQ_IND_COMP		| \
+					 CQSPI_REG_IRQ_WATERMARK	| \
+					 CQSPI_REG_IRQ_UNDERFLOW)
+
+#define CQSPI_IRQ_STATUS_MASK		(0xFFFFFFFF)
+
+#define CQSPI_REG_IS_IDLE(base)						\
+		((CQSPI_READL(base + CQSPI_REG_CONFIG) >>		\
+			CQSPI_REG_CONFIG_IDLE_LSB) & 0x1)
+
+#define CQSPI_CAL_DELAY(tdelay_ns, tref_ns, tsclk_ns)			\
+		((((tdelay_ns) - (tsclk_ns)) / (tref_ns)))
+
+#define CQSPI_GET_RD_SRAM_LEVEL(reg_basse)				\
+		(((CQSPI_READL(reg_base + CQSPI_REG_SDRAMLEVEL)) >>	\
+		CQSPI_REG_SDRAMLEVEL_RD_LSB) & CQSPI_REG_SDRAMLEVEL_RD_MASK)
+
+#define CQSPI_READ_IRQ_STATUS(reg_base)					\
+		CQSPI_READL(reg_base + CQSPI_REG_IRQSTATUS)
+
+#define CQSPI_CLEAR_IRQ(reg_base, status)				\
+		CQSPI_WRITEL(status, reg_base + CQSPI_REG_IRQSTATUS)
+
+/* Functions call declaration */
+unsigned int cadence_qspi_apb_is_controller_ready(void *reg_base_addr);
+void cadence_qspi_apb_controller_init(struct struct_cqspi *cadence_qspi);
+int cadence_qspi_apb_process_queue(struct struct_cqspi *cadence_qspi,
+	struct spi_device *spi, unsigned int n_trans,
+	struct spi_transfer **spi_xfer);
+void cadence_qspi_apb_controller_enable(void *reg_base_addr);
+void cadence_qspi_apb_controller_disable(void *reg_base_addr);
+#endif /* __CADENCE_QSPI_APB_H__ */
diff --git a/drivers/spi/spi-cadence-qspi.c b/drivers/spi/spi-cadence-qspi.c
new file mode 100644
index 0000000..56fb69b
--- /dev/null
+++ b/drivers/spi/spi-cadence-qspi.c
@@ -0,0 +1,562 @@
+/*
+ * Driver for Cadence QSPI Controller
+ *
+ * Copyright (C) 2012 Altera Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/spi/spi.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include "spi-cadence-qspi.h"
+#include "spi-cadence-qspi-apb.h"
+
+#define CADENCE_QSPI_NAME			"cadence-qspi"
+
+unsigned int cadence_qspi_init_timeout(const unsigned long timeout_in_ms)
+{
+	return (jiffies + msecs_to_jiffies(timeout_in_ms));
+}
+
+unsigned int cadence_qspi_check_timeout(const unsigned long timeout)
+{
+	return (time_before(jiffies, timeout));
+}
+
+static irqreturn_t cadence_qspi_irq_handler(int this_irq, void *dev)
+{
+	struct struct_cqspi *cadence_qspi = dev;
+
+	/* Read interrupt status */
+	cadence_qspi->irq_status = CQSPI_READ_IRQ_STATUS(cadence_qspi->iobase);
+
+	/* Clear interrupt */
+	CQSPI_CLEAR_IRQ(cadence_qspi->iobase, cadence_qspi->irq_status);
+
+	wake_up(&cadence_qspi->waitqueue);
+
+	return IRQ_HANDLED;
+}
+
+static void cadence_qspi_work(struct work_struct *work)
+{
+	struct struct_cqspi *cadence_qspi
+		= container_of(work, struct struct_cqspi, work);
+	unsigned long flags;
+
+	spin_lock_irqsave(&cadence_qspi->lock, flags);
+	while ((!list_empty(&cadence_qspi->msg_queue)) &&
+		cadence_qspi->running) {
+		struct spi_message *spi_msg;
+		struct spi_device *spi;
+		struct spi_transfer *spi_xfer;
+		struct spi_transfer *xfer[CQSPI_MAX_TRANS];
+		int status = 0;
+		int n_trans = 0;
+		int next_in_queue = 0;
+
+		spi_msg = container_of(cadence_qspi->msg_queue.next,
+			struct spi_message, queue);
+		list_del_init(&spi_msg->queue);
+		spin_unlock_irqrestore(&cadence_qspi->lock, flags);
+		spi = spi_msg->spi;
+		list_for_each_entry(spi_xfer, &spi_msg->transfers,
+				transfer_list) {
+			if (n_trans >= CQSPI_MAX_TRANS) {
+				dev_err(&spi->dev,"ERROR: Number of SPI "
+					"transfer is more than %d.\n",
+					CQSPI_MAX_TRANS);
+				/* Skip process the queue if number of
+				 * transaction is greater than max 2. */
+				next_in_queue = 1;
+				break;
+			}
+			xfer[n_trans++] = spi_xfer;
+		}
+
+		/* Continue to next queue if next_in_queue is set. */
+		if (next_in_queue)
+			continue;
+
+		status = cadence_qspi_apb_process_queue(cadence_qspi, spi,
+					n_trans, xfer);
+
+		if (!status) {
+			spi_msg->actual_length += xfer[0]->len;
+			if (n_trans > 1)
+				spi_msg->actual_length += xfer[1]->len;
+		}
+
+		spi_msg->status = status;
+		spi_msg->complete(spi_msg->context);
+		spin_lock_irqsave(&cadence_qspi->lock, flags);
+	}
+	spin_unlock_irqrestore(&cadence_qspi->lock, flags);
+}
+
+static int cadence_qspi_transfer(struct spi_device *spi, struct spi_message *msg)
+{
+	struct struct_cqspi *cadence_qspi =
+		spi_master_get_devdata(spi->master);
+	struct spi_transfer *spi_xfer;
+	struct platform_device *pdev = cadence_qspi->pdev;
+	struct cqspi_platform_data *pdata = pdev->dev.platform_data;
+	unsigned long flags;
+
+	list_for_each_entry(spi_xfer, &msg->transfers, transfer_list) {
+		if (spi_xfer->speed_hz > (pdata->master_ref_clk_hz / 2)) {
+			dev_err(&spi->dev, "speed_hz%d greater than "
+				"maximum %dHz\n",
+				spi_xfer->speed_hz,
+				(pdata->master_ref_clk_hz / 2));
+			msg->status = -EINVAL;
+			return -EINVAL;
+		}
+	}
+
+	spin_lock_irqsave(&cadence_qspi->lock, flags);
+
+	if (!cadence_qspi->running) {
+		spin_unlock_irqrestore(&cadence_qspi->lock, flags);
+		return -ESHUTDOWN;
+	}
+
+	msg->status = -EINPROGRESS;
+	msg->actual_length = 0;
+
+	list_add_tail(&msg->queue, &cadence_qspi->msg_queue);
+	queue_work(cadence_qspi->workqueue, &cadence_qspi->work);
+	spin_unlock_irqrestore(&cadence_qspi->lock, flags);
+	return 0;
+}
+
+static int cadence_qspi_setup(struct spi_device *spi)
+{
+	if (spi->chip_select > spi->master->num_chipselect) {
+		dev_err(&spi->dev, "%d chip select is out of range\n",
+			spi->chip_select);
+		return -EINVAL;
+	}
+	pr_debug("cadence_qspi : bits per word %d, chip select %d, "
+		"speed %d KHz\n", spi->bits_per_word, spi->chip_select,
+		spi->max_speed_hz);
+	return 0;
+}
+
+static int cadence_qspi_start_queue(struct struct_cqspi *cadence_qspi)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&cadence_qspi->lock, flags);
+
+	if (cadence_qspi->running) {
+		spin_unlock_irqrestore(&cadence_qspi->lock, flags);
+		return -EBUSY;
+	}
+
+	if (!cadence_qspi_apb_is_controller_ready (cadence_qspi->iobase) ) {
+		spin_unlock_irqrestore(&cadence_qspi->lock, flags);
+		return -EBUSY;
+	}
+
+	cadence_qspi->running = true;
+
+	spin_unlock_irqrestore(&cadence_qspi->lock, flags);
+
+	queue_work(cadence_qspi->workqueue, &cadence_qspi->work);
+	return 0;
+}
+
+static int cadence_qspi_stop_queue(struct struct_cqspi *cadence_qspi)
+{
+	unsigned long flags;
+	unsigned limit = 500;
+	int status = 0;
+
+	spin_lock_irqsave(&cadence_qspi->lock, flags);
+	cadence_qspi->running = false;
+	/* We will wait until controller process all the queue and ensure the
+	 * controller is not busy. */
+	while ((!list_empty(&cadence_qspi->msg_queue) ||
+		!cadence_qspi_apb_is_controller_ready(cadence_qspi->iobase))
+		&& limit--) {
+		spin_unlock_irqrestore(&cadence_qspi->lock, flags);
+		msleep(10);
+		spin_lock_irqsave(&cadence_qspi->lock, flags);
+	}
+
+	if (!list_empty(&cadence_qspi->msg_queue) ||
+		!cadence_qspi_apb_is_controller_ready(cadence_qspi->iobase))
+		status = -EBUSY;
+
+	spin_unlock_irqrestore(&cadence_qspi->lock, flags);
+	return status;
+}
+
+static int cadence_qspi_of_get_pdata(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct device_node *nc;
+	struct cqspi_platform_data *pdata = pdev->dev.platform_data;
+	struct cqspi_flash_pdata *f_pdata;
+	unsigned int cs;
+	unsigned int prop;
+
+	if (of_property_read_u32(np, "bus-num", &prop)) {
+		dev_err(&pdev->dev, "couldn't determine bus-num\n");
+		return -ENXIO;
+	}
+	pdata->bus_num = prop;
+
+	if (of_property_read_u32(np, "num-chipselect", &prop)) {
+		dev_err(&pdev->dev, "couldn't determine num-chipselect\n");
+		return -ENXIO;
+	}
+	pdata->num_chipselect = prop;
+
+	if (of_property_read_u32(np, "master-ref-clk", &prop)) {
+		dev_err(&pdev->dev, "couldn't determine master-ref-clk\n");
+		return -ENXIO;
+	}
+	pdata->master_ref_clk_hz = prop;
+
+	if (of_property_read_u32(np, "ext-decoder", &prop)) {
+		dev_err(&pdev->dev, "couldn't determine ext-decoder\n");
+		return -ENXIO;
+	}
+	pdata->ext_decoder = prop;
+
+	if (of_property_read_u32(np, "fifo-depth", &prop)) {
+		dev_err(&pdev->dev, "couldn't determine fifo-depth\n");
+		return -ENXIO;
+	}
+	pdata->fifo_depth = prop;
+
+	/* Get flash devices platform data */
+	for_each_child_of_node(np, nc) {
+		if (of_property_read_u32(nc, "reg", &cs)) {
+			dev_err(&pdev->dev, "couldn't determine reg\n");
+			return -ENXIO;
+		}
+
+		f_pdata = &(pdata->f_pdata[cs]);
+
+		if (of_property_read_u32(nc, "page-size", &prop)) {
+			dev_err(&pdev->dev, "couldn't determine page-size\n");
+			return -ENXIO;
+		}
+		f_pdata->page_size = prop;
+
+		if (of_property_read_u32(nc, "block-size", &prop)) {
+			dev_err(&pdev->dev, "couldn't determine block-size\n");
+			return -ENXIO;
+		}
+		f_pdata->block_size = prop;
+
+		if (of_property_read_u32(nc, "tshsl-ns", &prop)) {
+			dev_err(&pdev->dev, "couldn't determine tshsl-ns\n");
+			return -ENXIO;
+		}
+		f_pdata->tshsl_ns = prop;
+
+		if (of_property_read_u32(nc, "tsd2d-ns", &prop)) {
+			dev_err(&pdev->dev, "couldn't determine tsd2d-ns\n");
+			return -ENXIO;
+		}
+		f_pdata->tsd2d_ns = prop;
+
+		if (of_property_read_u32(nc, "tchsh-ns", &prop)) {
+			dev_err(&pdev->dev, "couldn't determine tchsh-ns\n");
+			return -ENXIO;
+		}
+		f_pdata->tchsh_ns = prop;
+
+		if (of_property_read_u32(nc, "tslch-ns", &prop)) {
+			dev_err(&pdev->dev, "couldn't determine tslch-ns\n");
+			return -ENXIO;
+		}
+		f_pdata->tslch_ns = prop;
+	}
+	return 0;
+}
+
+static int __devinit cadence_qspi_probe(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct struct_cqspi *cadence_qspi;
+	struct resource *res;
+	struct resource *res_ahb;
+	struct cqspi_platform_data *pdata;
+	int status;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(*cadence_qspi));
+	if (master == NULL) {
+		dev_err(&pdev->dev, "spi_alloc_master failed\n");
+		return -ENOMEM;
+	}
+
+	master->mode_bits = SPI_CS_HIGH | SPI_CPOL | SPI_CPHA;
+	master->setup = cadence_qspi_setup;
+	master->transfer = cadence_qspi_transfer;
+	master->dev.of_node = pdev->dev.of_node;
+
+	cadence_qspi = spi_master_get_devdata(master);
+	cadence_qspi->pdev = pdev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "platform_get_resource failed\n");
+		status = -ENXIO;
+		goto err_iomem;
+	}
+
+	cadence_qspi->res = res;
+
+	if (!request_mem_region(res->start, resource_size(res), pdev->name)) {
+		dev_err(&pdev->dev, "request_mem_region failed\n");
+		status = -EBUSY;
+		goto err_iomem;
+	}
+
+	cadence_qspi->iobase = ioremap(res->start, resource_size(res));
+	if (!cadence_qspi->iobase) {
+		dev_err(&pdev->dev, "ioremap failed\n");
+		status = -ENOMEM;
+		goto err_ioremap;
+	}
+
+	res_ahb = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!res_ahb) {
+		dev_err(&pdev->dev, "platform_get_resource failed\n");
+		status = -ENXIO;
+		goto err_ahbmem;
+	}
+	cadence_qspi->res_ahb = res_ahb;
+
+	if (!request_mem_region(res_ahb->start, resource_size(res_ahb),
+		pdev->name)) {
+		dev_err(&pdev->dev, "request_mem_region failed\n");
+		status = -EBUSY;
+		goto err_ahbmem;
+	}
+
+	cadence_qspi->qspi_ahb_virt = ioremap(res_ahb->start,
+		resource_size(res_ahb));
+	if (!cadence_qspi->qspi_ahb_virt) {
+		dev_err(&pdev->dev, "ioremap res_ahb failed\n");
+		status = -ENOMEM;
+		goto err_ahbremap;
+	}
+
+	cadence_qspi->workqueue =
+		create_singlethread_workqueue(dev_name(master->dev.parent));
+	if (!cadence_qspi->workqueue) {
+		dev_err(&pdev->dev, "create_workqueue failed\n");
+		status = -ENOMEM;
+		goto err_wq;
+	}
+
+	cadence_qspi->running = false;
+	INIT_WORK(&cadence_qspi->work, cadence_qspi_work);
+	spin_lock_init(&cadence_qspi->lock);
+	INIT_LIST_HEAD(&cadence_qspi->msg_queue);
+	init_waitqueue_head(&cadence_qspi->waitqueue);
+	status = cadence_qspi_start_queue(cadence_qspi);
+	if (status) {
+		dev_err(&pdev->dev, "problem starting queue.\n");
+		goto err_start_q;
+	}
+
+	cadence_qspi->irq = platform_get_irq(pdev, 0);
+
+	if (cadence_qspi->irq < 0) {
+		dev_err(&pdev->dev, "platform_get_irq failed\n");
+		status = -ENXIO;
+		goto err_irq;
+	}
+
+	status = request_irq(cadence_qspi->irq, cadence_qspi_irq_handler,
+		0, pdev->name, cadence_qspi);
+	if (status) {
+		dev_err(&pdev->dev, "request_irq failed\n");
+		goto err_irq;
+	}
+
+	pdata = kmalloc(sizeof(struct cqspi_platform_data), GFP_KERNEL);
+	if (!pdata) {
+		status = -ENOMEM;
+		goto err_pdata;
+	}
+
+	pdev->dev.platform_data = pdata;
+	pdata->qspi_ahb_phy = res_ahb->start;
+
+	status = cadence_qspi_of_get_pdata(pdev);
+	if (status) {
+		dev_err(&pdev->dev, "Get platform data failed.\n");
+		goto err_of;
+	}
+
+	master->bus_num = pdata->bus_num;
+	master->num_chipselect = pdata->num_chipselect;
+
+	platform_set_drvdata(pdev, master);
+	status = spi_register_master(master);
+	if (status) {
+		dev_err(&pdev->dev, "spi_register_master failed\n");
+		goto err_of;
+	}
+
+	cadence_qspi_apb_controller_init(cadence_qspi);
+	cadence_qspi->current_cs = -1;
+
+	dev_info(&pdev->dev, "Cadence QSPI controller driver\n");
+	return 0;
+
+err_of:
+	kfree(pdata);
+err_pdata:
+	free_irq(cadence_qspi->irq, cadence_qspi);
+err_start_q:
+err_irq:
+	destroy_workqueue(cadence_qspi->workqueue);
+err_wq:
+	iounmap(cadence_qspi->qspi_ahb_virt);
+err_ahbremap:
+	release_mem_region(res_ahb->start, resource_size(res_ahb));
+err_ahbmem:
+	iounmap(cadence_qspi->iobase);
+err_ioremap:
+	release_mem_region(res->start, resource_size(res));
+err_iomem:
+	spi_master_put(master);
+	dev_err(&pdev->dev, "Cadence QSPI controller probe failed\n");
+	return status;
+}
+
+static int __devexit cadence_qspi_remove(struct platform_device *pdev)
+{
+	struct spi_master *master = platform_get_drvdata(pdev);
+	struct struct_cqspi *cadence_qspi = spi_master_get_devdata(master);
+
+	cadence_qspi_apb_controller_disable(cadence_qspi->iobase);
+
+	platform_set_drvdata(pdev, NULL);
+	destroy_workqueue(cadence_qspi->workqueue);
+	free_irq(cadence_qspi->irq, cadence_qspi);
+	iounmap(cadence_qspi->iobase);
+	iounmap(cadence_qspi->qspi_ahb_virt);
+	release_mem_region(cadence_qspi->res->start,
+		resource_size(cadence_qspi->res));
+	release_mem_region(cadence_qspi->res_ahb->start,
+		resource_size(cadence_qspi->res_ahb));
+	kfree(pdev->dev.platform_data);
+	spi_unregister_master(master);
+	spi_master_put(master);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+
+static int cadence_qspi_suspend(struct device *dev)
+{
+	struct spi_master	*master = dev_get_drvdata(dev);
+	struct struct_cqspi *cadence_qspi = spi_master_get_devdata(master);
+	int status=0;
+
+	/* Stop the queue */
+	status = cadence_qspi_stop_queue(cadence_qspi);
+	if (status != 0)
+		return status;
+	/* Disable the controller to conserve the power */
+	cadence_qspi_apb_controller_disable(cadence_qspi->iobase);
+	return 0;
+}
+
+static int cadence_qspi_resume(struct device *dev)
+{
+	struct spi_master	*master = dev_get_drvdata(dev);
+	struct struct_cqspi *cadence_qspi = spi_master_get_devdata(master);
+	int status = 0;
+
+	cadence_qspi_apb_controller_enable(cadence_qspi->iobase);
+	/* Start the queue running */
+	status = cadence_qspi_start_queue(cadence_qspi);
+	if (status != 0) {
+		cadence_qspi_apb_controller_disable(cadence_qspi->iobase);
+		dev_err(dev, "problem starting queue (%d)\n", status);
+		return status;
+	}
+	return 0;
+}
+static struct dev_pm_ops cadence_qspi__dev_pm_ops =
+{
+	.suspend	= cadence_qspi_suspend,
+	.resume		= cadence_qspi_resume,
+};
+#define	CADENCE_QSPI_DEV_PM_OPS	(&cadence_qspi__dev_pm_ops)
+#else
+#define	CADENCE_QSPI_DEV_PM_OPS	NULL
+#endif
+
+#ifdef CONFIG_OF
+static struct of_device_id cadence_qspi_of_match[] __devinitdata = {
+	{ .compatible = "cadence,qspi",},
+	{ /* end of table */}
+};
+MODULE_DEVICE_TABLE(of, cadence_qspi_of_match);
+#else
+#define cadence_qspi_of_match NULL
+#endif /* CONFIG_OF */
+
+
+static struct platform_driver cadence_qspi_platform_driver =
+{
+	.probe		= cadence_qspi_probe,
+	.remove		= __devexit_p(cadence_qspi_remove),
+	.driver = {
+		.name	= CADENCE_QSPI_NAME,
+		.owner	= THIS_MODULE,
+		.pm	= CADENCE_QSPI_DEV_PM_OPS,
+		.of_match_table = cadence_qspi_of_match,
+	},
+};
+
+static int __init cadence_qspi_init(void)
+{
+	return platform_driver_register(&cadence_qspi_platform_driver);
+}
+static void __exit cadence_qspi_exit(void)
+{
+	platform_driver_unregister(&cadence_qspi_platform_driver);
+}
+
+module_init(cadence_qspi_init);
+module_exit(cadence_qspi_exit);
+
+MODULE_AUTHOR("Ley Foon Tan <lftan@altera.com>");
+MODULE_DESCRIPTION("Cadence QSPI Controller Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" CADENCE_QSPI_NAME);
diff --git a/drivers/spi/spi-cadence-qspi.h b/drivers/spi/spi-cadence-qspi.h
new file mode 100644
index 0000000..86f5d65
--- /dev/null
+++ b/drivers/spi/spi-cadence-qspi.h
@@ -0,0 +1,82 @@
+/*
+ * Driver for Cadence QSPI Controller
+ *
+ * Copyright (C) 2012 Altera Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __CADENCE_QSPI_H__
+#define __CADENCE_QSPI_H__
+
+#define CQSPI_MAX_TRANS				(2)
+
+#define CQSPI_MAX_CHIP_SELECT			(16)
+
+struct cqspi_flash_pdata {
+	unsigned int page_size;
+	unsigned int block_size;
+	unsigned int quad;
+	unsigned int tshsl_ns;
+	unsigned int tsd2d_ns;
+	unsigned int tchsh_ns;
+	unsigned int tslch_ns;
+};
+
+struct cqspi_platform_data {
+	unsigned int bus_num;
+	unsigned int num_chipselect;
+	unsigned int qspi_ahb_phy;
+	unsigned int master_ref_clk_hz;
+	unsigned int ext_decoder;
+	unsigned int fifo_depth;
+	struct cqspi_flash_pdata f_pdata[CQSPI_MAX_CHIP_SELECT];
+};
+
+struct struct_cqspi
+{
+	struct work_struct work;
+	struct workqueue_struct *workqueue;
+	wait_queue_head_t waitqueue;
+	struct list_head msg_queue;
+	struct platform_device *pdev;
+
+	/* lock protects queue and registers */
+	spinlock_t lock;
+	/* Virtual base address of the controller */
+	void __iomem *iobase;
+	/* QSPI AHB virtual address */
+	void __iomem *qspi_ahb_virt;
+	/* phys mem */
+	struct resource *res;
+	/* AHB phys mem */
+	struct resource *res_ahb;
+	/* Interrupt */
+	int irq;
+	/* Interrupt status */
+	unsigned int irq_status;
+	/* Current chip select */
+	int current_cs;
+	/* Is queue running */
+	bool running;
+};
+
+/* Kernel function hook */
+#define CQSPI_WRITEL		__raw_writel
+#define CQSPI_READL		__raw_readl
+unsigned int cadence_qspi_init_timeout(const unsigned long timeout_in_ms);
+unsigned int cadence_qspi_check_timeout(const unsigned long timeout);
+
+#endif /* __CADENCE_QSPI_H__ */
diff --git a/drivers/spi/spi-dw-mmio.c b/drivers/spi/spi-dw-mmio.c
index db2f1ba..0bc8a14 100644
--- a/drivers/spi/spi-dw-mmio.c
+++ b/drivers/spi/spi-dw-mmio.c
@@ -16,6 +16,10 @@
 #include <linux/spi/spi.h>
 #include <linux/scatterlist.h>
 #include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
 
 #include "spi-dw.h"
 
@@ -32,7 +36,9 @@ static int __devinit dw_spi_mmio_probe(struct platform_device *pdev)
 	struct dw_spi *dws;
 	struct resource *mem, *ioarea;
 	int ret;
-
+#ifdef CONFIG_OF
+	unsigned int prop;
+#endif
 	dwsmmio = kzalloc(sizeof(struct dw_spi_mmio), GFP_KERNEL);
 	if (!dwsmmio) {
 		ret = -ENOMEM;
@@ -58,6 +64,7 @@ static int __devinit dw_spi_mmio_probe(struct platform_device *pdev)
 	}
 
 	dws->regs = ioremap_nocache(mem->start, resource_size(mem));
+	dws->paddr = mem->start;
 	if (!dws->regs) {
 		dev_err(&pdev->dev, "SPI region already mapped\n");
 		ret = -ENOMEM;
@@ -76,13 +83,37 @@ static int __devinit dw_spi_mmio_probe(struct platform_device *pdev)
 		ret = PTR_ERR(dwsmmio->clk);
 		goto err_irq;
 	}
+	clk_prepare(dwsmmio->clk);
 	clk_enable(dwsmmio->clk);
 
-	dws->parent_dev = &pdev->dev;
-	dws->bus_num = 0;
+#ifdef CONFIG_OF
+	if(of_property_read_u32(pdev->dev.of_node, "num-chipselect", &prop)) {
+		ret = -ENXIO;
+		dev_err(&pdev->dev, "couldn't determine num-chipselect\n");
+		goto err_irq;
+	}
+	dws->num_cs = prop;
+
+	if(of_property_read_u32(pdev->dev.of_node, "bus-num", &prop)) {
+		ret = -ENXIO;
+		dev_err(&pdev->dev, "couldn't determine bus-num\n");
+		goto err_irq;
+	}
+	dws->bus_num = prop;
+#else
 	dws->num_cs = 4;
+	dws->bus_num = 0;
+#endif
+
+	dws->parent_dev = &pdev->dev;
 	dws->max_freq = clk_get_rate(dwsmmio->clk);
 
+#ifdef CONFIG_SPI_DW_PL330_DMA
+	ret = dw_spi_pl330_init(dws);
+	if (ret)
+		goto err_clk;
+#endif
+
 	ret = dw_spi_add_host(dws);
 	if (ret)
 		goto err_clk;
@@ -127,12 +158,23 @@ static int __devexit dw_spi_mmio_remove(struct platform_device *pdev)
 	return 0;
 }
 
+#ifdef CONFIG_OF
+static struct of_device_id dw_spi_mmio_of_match[] __devinitdata = {
+	{ .compatible = "snps,dw-spi-mmio", },
+	{ /* end of table */}
+};
+MODULE_DEVICE_TABLE(of, dw_spi_mmio_of_match);
+#else
+#define dw_spi_mmio_of_match NULL
+#endif /* CONFIG_OF */
+
 static struct platform_driver dw_spi_mmio_driver = {
 	.probe		= dw_spi_mmio_probe,
 	.remove		= __devexit_p(dw_spi_mmio_remove),
 	.driver		= {
 		.name	= DRIVER_NAME,
 		.owner	= THIS_MODULE,
+		.of_match_table = dw_spi_mmio_of_match,
 	},
 };
 module_platform_driver(dw_spi_mmio_driver);
diff --git a/drivers/spi/spi-dw-pl330.c b/drivers/spi/spi-dw-pl330.c
new file mode 100644
index 0000000..050b9b4
--- /dev/null
+++ b/drivers/spi/spi-dw-pl330.c
@@ -0,0 +1,223 @@
+/*
+ * DMA handling for DW core with DMA PL330 controller
+ *
+ * Modified from linux/driver/spi/spi-dw-mid.c
+ *
+ * Copyright (c) 2012, Altera Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/amba/pl330.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/delay.h>
+#include "spi-dw.h"
+#include <linux/spi/spi-dw.h>
+#include <linux/of.h>
+
+
+/*Burst size configuration*/
+enum spi_pl330_brst_sz {
+	PL330_DMA_BRSTSZ_1B = 0x1,
+	PL330_DMA_BRSTSZ_2B = 0x2,
+};
+
+/* TX & RX FIFO depth supported by HW */
+#define SSI_FIFO_DEPTH		0xFF
+
+/* Maximum burst length
+   Note: Can be up to 16, but now is default to 1 in the PL330 driver.
+         Burst transfer is not supported in PL330 driver     */
+#define SSI_DMA_MAXBURST	16
+
+
+static int spi_pl330_dma_chan_alloc(struct dw_spi *dws)
+{
+	struct device_node *np = dws->master->dev.of_node;
+	void *filter_param_rx, *filter_param_tx;
+	dma_cap_mask_t mask;
+	int lenp;
+
+
+	/* If DMA channel already allocated */
+	if (dws->rxchan && dws->txchan)
+		return 0;
+
+	filter_param_tx = of_find_property(np, "tx-dma-channel", &lenp);
+	if (!filter_param_tx)
+		return -1;
+	filter_param_rx = of_find_property(np, "rx-dma-channel", &lenp);
+	if (!filter_param_rx)
+		return -1;
+
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+
+	/* 1. Init rx channel */
+	dws->rxchan = dma_request_channel(mask, pl330_filter, filter_param_rx);
+	while (!dws->rxchan) {
+		/* all DMA channels are busy, try again */
+		msleep(10);
+		dws->rxchan = dma_request_channel(mask, pl330_filter, filter_param_rx);
+	}
+
+	/* 2. Init tx channel */
+	dws->txchan = dma_request_channel(mask, pl330_filter, filter_param_tx);
+	while (!dws->txchan) {
+		/* all DMA channels are busy, try again */
+		msleep(10);
+		dws->txchan = dma_request_channel(mask, pl330_filter, filter_param_tx);
+	}
+
+	dws->dma_inited = 1;
+
+	return 0;
+}
+
+static void spi_pl330_dma_chan_release(struct dw_spi *dws)
+{
+	dma_release_channel(dws->txchan);
+	dma_release_channel(dws->rxchan);
+	dws->txchan = 0;
+	dws->rxchan = 0;
+	dws->dma_inited = 0;
+}
+
+/*
+ * dws->dma_chan_done is cleared before the dma transfer starts,
+ * callback for rx/tx channel will each increment it by 1.
+ * Reaching 2 means the whole spi transaction is done.
+ */
+static void spi_pl330_dma_done(void *arg)
+{
+	struct dw_spi *dws = arg;
+
+	if (++dws->dma_chan_done != 2)
+		return;
+	dw_spi_xfer_done(dws);
+}
+
+static int spi_pl330_dma_transfer(struct dw_spi *dws, int cs_change)
+{
+	struct dma_async_tx_descriptor *txdesc = NULL, *rxdesc = NULL;
+	struct dma_chan *txchan, *rxchan;
+	struct dma_slave_config txconf, rxconf;
+	u16 dma_ctrl = 0;
+
+	/* 1. setup DMA related registers */
+	if (cs_change) {
+		spi_enable_chip(dws, 0);
+		/* Setup peripheral's burst watermark for TX and RX FIFO */
+		dw_writew(dws, DW_SPI_DMARDLR, SSI_DMA_MAXBURST - 1);
+		dw_writew(dws, DW_SPI_DMATDLR, SSI_FIFO_DEPTH - SSI_DMA_MAXBURST);
+
+		if (dws->tx_dma)
+			dma_ctrl |= 0x2;
+		if (dws->rx_dma)
+			dma_ctrl |= 0x1;
+		dw_writew(dws, DW_SPI_DMACR, dma_ctrl);
+		spi_enable_chip(dws, 1);
+	}
+
+	dws->dma_chan_done = 0;
+	txchan = dws->txchan;
+	rxchan = dws->rxchan;
+
+	/* 2. Prepare the TX dma transfer */
+	txconf.direction = DMA_MEM_TO_DEV;
+	txconf.dst_addr = dws->dma_addr;
+	/* Note: By default the burst_len (dst_maxburst) for DMA_MEM_TO_DEV is set
+			 to 1 and the burst_size (src_addr_width) for memory is set to
+			 peripheral's configuration in PL330 driver (driver/dma/pl330.c).
+			 Therefore the config listed below can be skipped
+				i. txconf.dst_maxburst
+				ii. txconf.src_addr_width
+			 Max DMA width is 16-bit
+	*/
+	if (dws->dma_width == 1)
+		txconf.dst_addr_width = PL330_DMA_BRSTSZ_1B;
+	else
+		txconf.dst_addr_width = PL330_DMA_BRSTSZ_2B;
+
+	txchan->device->device_control(txchan, DMA_SLAVE_CONFIG,
+				       (unsigned long) &txconf);
+
+	memset(&dws->tx_sgl, 0, sizeof(dws->tx_sgl));
+	dws->tx_sgl.dma_address = dws->tx_dma;
+	dws->tx_sgl.length = dws->len;
+
+	txdesc = txchan->device->device_prep_slave_sg(txchan,
+				&dws->tx_sgl,
+				1,
+				DMA_MEM_TO_DEV,
+				DMA_PREP_INTERRUPT);
+	txdesc->callback = spi_pl330_dma_done;
+	txdesc->callback_param = dws;
+
+	/* 3. Prepare the RX dma transfer */
+	rxconf.direction = DMA_DEV_TO_MEM;
+	rxconf.src_addr = dws->dma_addr;
+	/* Note: By default the burst_len (src_maxburst) for DMA_DEV_TO_MEM is set
+			 to 1 and the burst_size (dst_addr_width) for memory is set to
+			 peripheral's configuration in PL330 driver (driver/dma/pl330.c).
+			 Therefore the config listed below can be skipped
+		txconf.src_maxburst
+		txconf.dst_addr_width
+	*/
+	if (dws->dma_width == 1)
+		rxconf.src_addr_width = PL330_DMA_BRSTSZ_1B;
+	else
+		rxconf.src_addr_width = PL330_DMA_BRSTSZ_2B;
+
+	rxchan->device->device_control(rxchan, DMA_SLAVE_CONFIG,
+				       (unsigned long) &rxconf);
+
+	memset(&dws->rx_sgl, 0, sizeof(dws->rx_sgl));
+	dws->rx_sgl.dma_address = dws->rx_dma;
+	dws->rx_sgl.length = dws->len;
+
+	rxdesc = rxchan->device->device_prep_slave_sg(rxchan,
+				&dws->rx_sgl,
+				1,
+				DMA_DEV_TO_MEM,
+				DMA_PREP_INTERRUPT);
+	rxdesc->callback = spi_pl330_dma_done;
+	rxdesc->callback_param = dws;
+
+	/* rx must be started before tx due to spi instinct */
+	rxdesc->tx_submit(rxdesc);
+	dma_async_issue_pending(rxchan);
+	txdesc->tx_submit(txdesc);
+	dma_async_issue_pending(txchan);
+
+	return 0;
+}
+
+static struct dw_spi_dma_ops pl330_dma_ops = {
+	.dma_transfer	= spi_pl330_dma_transfer,
+	.dma_chan_alloc = spi_pl330_dma_chan_alloc,
+	.dma_chan_release = spi_pl330_dma_chan_release,
+};
+
+int dw_spi_pl330_init(struct dw_spi *dws)
+{
+	dws->fifo_len = SSI_FIFO_DEPTH;
+	dws->dma_ops = &pl330_dma_ops;
+
+	return 0;
+}
diff --git a/drivers/spi/spi-dw.c b/drivers/spi/spi-dw.c
index d1a495f..3f534df 100644
--- a/drivers/spi/spi-dw.c
+++ b/drivers/spi/spi-dw.c
@@ -24,6 +24,8 @@
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/spi/spi.h>
+#include <linux/of.h>
+#include <linux/spi/spi-dw.h>
 
 #include "spi-dw.h"
 
@@ -244,6 +246,43 @@ static void *next_transfer(struct dw_spi *dws)
  */
 static int map_dma_buffers(struct dw_spi *dws)
 {
+#ifdef CONFIG_SPI_DW_PL330_DMA
+	if (!dws->dma_inited
+		|| !dws->cur_chip->enable_dma
+		|| !dws->dma_ops)
+		return 0;
+
+	if (dws->cur_msg->is_dma_mapped) {
+		if (dws->cur_transfer->tx_dma)
+			dws->tx_dma = dws->cur_transfer->tx_dma;
+
+		if (dws->cur_transfer->rx_dma)
+			dws->rx_dma = dws->cur_transfer->rx_dma;
+	} else {
+		if (dws->cur_transfer->tx_buf != NULL) {
+			dws->tx_dma = dma_map_single(dws->parent_dev,
+					(void *)dws->cur_transfer->tx_buf,
+					dws->cur_transfer->len,
+					DMA_TO_DEVICE);
+			if (dma_mapping_error(dws->parent_dev, dws->tx_dma)) {
+				dev_err(dws->parent_dev, "dma_map_single Tx failed\n");
+				return 0;
+			}
+		}
+
+		if (dws->cur_transfer->rx_buf != NULL) {
+			dws->rx_dma = dma_map_single(dws->parent_dev,
+					dws->cur_transfer->rx_buf,
+					dws->cur_transfer->len, DMA_FROM_DEVICE);
+			if (dma_mapping_error(dws->parent_dev, dws->rx_dma)) {
+				dev_err(dws->parent_dev, "dma_map_single Rx failed\n");
+				dma_unmap_single(dws->parent_dev, dws->tx_dma,
+						dws->cur_transfer->len, DMA_TO_DEVICE);
+				return 0;
+			}
+		}
+	}
+#else
 	if (!dws->cur_msg->is_dma_mapped
 		|| !dws->dma_inited
 		|| !dws->cur_chip->enable_dma
@@ -255,6 +294,7 @@ static int map_dma_buffers(struct dw_spi *dws)
 
 	if (dws->cur_transfer->rx_dma)
 		dws->rx_dma = dws->cur_transfer->rx_dma;
+#endif
 
 	return 1;
 }
@@ -303,6 +343,15 @@ void dw_spi_xfer_done(struct dw_spi *dws)
 	/* Update total byte transferred return count actual bytes read */
 	dws->cur_msg->actual_length += dws->len;
 
+	if (dws->dma_mapped) {
+		if (!dws->cur_msg->is_dma_mapped) {
+			dma_unmap_single(dws->parent_dev, dws->rx_dma,
+						dws->cur_transfer->len, DMA_FROM_DEVICE);
+			dma_unmap_single(dws->parent_dev, dws->tx_dma,
+						dws->cur_transfer->len, DMA_TO_DEVICE);
+		}
+	}
+
 	/* Move to next transfer */
 	dws->cur_msg->state = next_transfer(dws);
 
@@ -560,6 +609,9 @@ static void pump_messages(struct work_struct *work)
 	if (list_empty(&dws->queue) || dws->run == QUEUE_STOPPED) {
 		dws->busy = 0;
 		spin_unlock_irqrestore(&dws->lock, flags);
+		if (dws->dma_inited && dws->dma_ops && dws->dma_ops->dma_chan_release) {
+			dws->dma_ops->dma_chan_release(dws);
+		}
 		return;
 	}
 
@@ -592,6 +644,7 @@ static int dw_spi_transfer(struct spi_device *spi, struct spi_message *msg)
 {
 	struct dw_spi *dws = spi_master_get_devdata(spi->master);
 	unsigned long flags;
+	struct chip_data *chip = spi_get_ctldata(spi);
 
 	spin_lock_irqsave(&dws->lock, flags);
 
@@ -607,6 +660,13 @@ static int dw_spi_transfer(struct spi_device *spi, struct spi_message *msg)
 	list_add_tail(&msg->queue, &dws->queue);
 
 	if (dws->run == QUEUE_RUNNING && !dws->busy) {
+		if (chip->enable_dma &&
+			dws->dma_ops && dws->dma_ops->dma_chan_alloc) {
+			if (dws->dma_ops->dma_chan_alloc(dws)) {
+				dev_warn(&dws->master->dev, "DMA chan alloc failed\n");
+				dws->dma_inited = 0;
+			}
+		}
 
 		if (dws->cur_transfer || dws->cur_msg)
 			queue_work(dws->workqueue,
@@ -629,6 +689,12 @@ static int dw_spi_setup(struct spi_device *spi)
 	struct dw_spi_chip *chip_info = NULL;
 	struct chip_data *chip;
 
+#ifdef CONFIG_OF
+	struct device_node *nc = spi->dev.of_node;
+	unsigned int prop;
+#endif
+
+
 	if (spi->bits_per_word != 8 && spi->bits_per_word != 16)
 		return -EINVAL;
 
@@ -660,6 +726,20 @@ static int dw_spi_setup(struct spi_device *spi)
 		chip->enable_dma = chip_info->enable_dma;
 	}
 
+#ifdef CONFIG_OF
+	if(of_property_read_u32(nc, "enable-dma", &prop) == 0) {
+		chip->enable_dma = prop;
+	}
+
+	if(of_property_read_u32(nc, "poll-mode", &prop) == 0) {
+		chip->poll_mode = prop;
+	}
+
+	if(of_property_read_u32(nc, "type", &prop) == 0) {
+		chip->type = prop;
+	}
+#endif
+
 	if (spi->bits_per_word <= 8) {
 		chip->n_bytes = 1;
 		chip->dma_width = 1;
@@ -687,6 +767,7 @@ static int dw_spi_setup(struct spi_device *spi)
 			| (chip->tmode << SPI_TMOD_OFFSET);
 
 	spi_set_ctldata(spi, chip);
+
 	return 0;
 }
 
@@ -829,6 +910,7 @@ int __devinit dw_spi_add_host(struct dw_spi *dws)
 	master->cleanup = dw_spi_cleanup;
 	master->setup = dw_spi_setup;
 	master->transfer = dw_spi_transfer;
+	master->dev.of_node = dws->parent_dev->of_node;
 
 	/* Basic HW init */
 	spi_hw_init(dws);
diff --git a/drivers/spi/spi-dw.h b/drivers/spi/spi-dw.h
index 9c57c07..8b4e613 100644
--- a/drivers/spi/spi-dw.h
+++ b/drivers/spi/spi-dw.h
@@ -87,6 +87,8 @@ struct dw_spi_dma_ops {
 	int (*dma_init)(struct dw_spi *dws);
 	void (*dma_exit)(struct dw_spi *dws);
 	int (*dma_transfer)(struct dw_spi *dws, int cs_change);
+	int (*dma_chan_alloc)(struct dw_spi *dws);
+	void (*dma_chan_release)(struct dw_spi *dws);
 };
 
 struct dw_spi {
@@ -239,4 +241,5 @@ extern void dw_spi_xfer_done(struct dw_spi *dws);
 
 /* platform related setup */
 extern int dw_spi_mid_init(struct dw_spi *dws); /* Intel MID platforms */
+extern int dw_spi_pl330_init(struct dw_spi *dws); /* PL330 support setup */
 #endif /* DW_SPI_HEADER_H */
diff --git a/include/linux/spi/spi-dw.h b/include/linux/spi/spi-dw.h
new file mode 100644
index 0000000..fb904f1
--- /dev/null
+++ b/include/linux/spi/spi-dw.h
@@ -0,0 +1,38 @@
+/* linux/include/linux/spi/spi-dw.h
+ *
+ * Copyright (C) 2012 Altera Corporation
+ *
+ * Maintainer: Lee Booi Lim <lblim@altera.com>
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef LINUX_DW_SPI_H
+#define LINUX_DW_SPI_H
+
+#include <linux/spi/spi.h>
+
+
+#define DW_SPI_OF_COMPATIBLE	"snps,dw-spi-mmio"
+#define MAX_SPI_DEVICES		16
+
+enum dw_spi_dma_resources {
+	DW_SPI_DMA_CH_RX = 0,
+	DW_SPI_DMA_CH_TX,
+	DW_SPI_DMA_CH_MAX,
+};
+
+
+
+struct dw_spi_pdata {
+	struct resource dwi_spi_dma_res[DW_SPI_DMA_CH_MAX];
+};
+
+#endif /* LINUX_DW_SPI_H */
diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index f629189..9666a35 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -91,6 +91,8 @@ struct spi_device {
 	void			*controller_data;
 	char			modalias[SPI_NAME_SIZE];
 	int			cs_gpio;	/* chip select gpio */
+	u32			enable_4b_addr; /* Uses 4 bytes address mode */
+	u32			addr_width;
 
 	/*
 	 * likely need more hooks for more protocol options affecting how
-- 
1.7.5.4

