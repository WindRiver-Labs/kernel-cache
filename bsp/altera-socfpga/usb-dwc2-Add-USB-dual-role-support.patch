From 1deff48c4f7cbcff0dd2e05f222e92aec8910e54 Mon Sep 17 00:00:00 2001
From: Dinh Nguyen <dinguyen@altera.com>
Date: Fri, 24 Jan 2014 10:28:53 -0600
Subject: [PATCH 15/24] usb/dwc2: Add USB dual-role support

commit acfc887d1c4d69eafd1d0017004317ce14b5b76b
git://git.rocketboards.org/linux-socfpga.git

This commit enables the DWC2 USB driver to be a dual-role OTG driver.
This means that the driver can be in host or peripheral mode when the appropriate
connector is used. When an A-cable is plugged in, the driver behaves in host
mode, and when a B-cable is used, the driver will be in peripheral mode.

This commit:
- Unifies the dwc2 and s3c-hsotg driver into a single driver.
- Deletes the defines in s3c-hsotg.
- Adds a aingle IRQ handler for both drivers.

Signed-off-by: Dinh Nguyen <dinguyen@altera.com>
[We also remove kernel option from gadget/Kconfig]
Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 drivers/usb/dwc2/Kconfig       |   29 +
 drivers/usb/dwc2/Makefile      |    2 +
 drivers/usb/dwc2/core.h        |  175 ++
 drivers/usb/dwc2/core_intr.c   |  131 ++-
 drivers/usb/dwc2/hcd.c         |    7 +-
 drivers/usb/dwc2/hcd.h         |    1 +
 drivers/usb/dwc2/hw.h          |   22 +-
 drivers/usb/dwc2/platform.c    |   38 +-
 drivers/usb/dwc2/s3c-hsotg.c   | 3361 ++++++++++++++++++++++++++++++++++++++
 drivers/usb/gadget/Kconfig     |    8 -
 drivers/usb/gadget/Makefile    |    1 -
 drivers/usb/gadget/s3c-hsotg.c | 3478 ----------------------------------------
 drivers/usb/gadget/s3c-hsotg.h |  379 -----
 13 files changed, 3733 insertions(+), 3899 deletions(-)
 create mode 100644 drivers/usb/dwc2/s3c-hsotg.c
 delete mode 100644 drivers/usb/gadget/s3c-hsotg.c
 delete mode 100644 drivers/usb/gadget/s3c-hsotg.h

diff --git a/drivers/usb/dwc2/Kconfig b/drivers/usb/dwc2/Kconfig
index be947d6..299227a 100644
--- a/drivers/usb/dwc2/Kconfig
+++ b/drivers/usb/dwc2/Kconfig
@@ -20,6 +20,35 @@ config USB_DWC2
 
 if USB_DWC2
 
+choice
+	bool "DWC2 Mode Selection"
+	default USB_DWC2_DUAL_ROLE if (USB && USB_GADGET)
+	default USB_DWC2_HOST if (USB && !USB_GADGET)
+	default USB_DWC2_GADGET if (!USB && USB_GADGET)
+
+config USB_DWC2_HOST
+	bool "Host only mode"
+	depends on USB=y || USB=USB_DWC2
+	help
+	  Select this when you want to use DWC2 in host mode only,
+	  thereby the gadget feature will be regressed.
+
+config USB_DWC2_GADGET
+	bool "Gadget only mode"
+	depends on USB_GADGET=y || USB_GADGET=USB_DWC2
+	help
+	  Select this when you want to use DWC2 in gadget mode only,
+	  thereby the host feature will be regressed.
+
+config USB_DWC2_DUAL_ROLE
+	bool "Dual Role mode"
+	depends on ((USB=y || USB=USB_DWC2) && (USB_GADGET=y || USB_GADGET=USB_DWC2))
+	help
+	  This is the default mode of working of DWC2 controller where
+	  both host and gadget features are enabled.
+
+endchoice
+
 config USB_DWC2_DEBUG
 	bool "Enable Debugging Messages"
 	help
diff --git a/drivers/usb/dwc2/Makefile b/drivers/usb/dwc2/Makefile
index 11529d3..4d147ad 100644
--- a/drivers/usb/dwc2/Makefile
+++ b/drivers/usb/dwc2/Makefile
@@ -16,6 +16,8 @@ dwc2-y					+= core.o core_intr.o
 dwc2-y					+= hcd.o hcd_intr.o
 dwc2-y					+= hcd_queue.o hcd_ddma.o
 
+dwc2-y					+= s3c-hsotg.o
+
 ifneq ($(CONFIG_PCI),)
 	obj-$(CONFIG_USB_DWC2)		+= dwc2_pci.o
 endif
diff --git a/drivers/usb/dwc2/core.h b/drivers/usb/dwc2/core.h
index fab718d..fb662e4 100644
--- a/drivers/usb/dwc2/core.h
+++ b/drivers/usb/dwc2/core.h
@@ -37,6 +37,10 @@
 #ifndef __DWC2_CORE_H__
 #define __DWC2_CORE_H__
 
+#include <linux/phy/phy.h>
+#include <linux/regulator/consumer.h>
+#include <linux/usb/gadget.h>
+#include <linux/usb/otg.h>
 #include <linux/usb/phy.h>
 #include "hw.h"
 
@@ -54,9 +58,150 @@ static inline void do_write(u32 value, void *addr)
 /* Maximum number of Endpoints/HostChannels */
 #define MAX_EPS_CHANNELS	16
 
+static const char * const s3c_hsotg_supply_names[] = {
+	"vusb_d",		/* digital USB supply, 1.2V */
+	"vusb_a",		/* analog USB supply, 1.1V */
+};
+
+struct s3c_hsotg;
+struct s3c_hsotg_req;
 struct dwc2_hsotg;
 struct dwc2_host_chan;
 
+/**
+ * struct s3c_hsotg_ep - driver endpoint definition.
+ * @ep: The gadget layer representation of the endpoint.
+ * @name: The driver generated name for the endpoint.
+ * @queue: Queue of requests for this endpoint.
+ * @parent: Reference back to the parent device structure.
+ * @req: The current request that the endpoint is processing. This is
+ *       used to indicate an request has been loaded onto the endpoint
+ *       and has yet to be completed (maybe due to data move, or simply
+ *	 awaiting an ack from the core all the data has been completed).
+ * @debugfs: File entry for debugfs file for this endpoint.
+ * @lock: State lock to protect contents of endpoint.
+ * @dir_in: Set to true if this endpoint is of the IN direction, which
+ *	    means that it is sending data to the Host.
+ * @index: The index for the endpoint registers.
+ * @mc: Multi Count - number of transactions per microframe
+ * @interval - Interval for periodic endpoints
+ * @name: The name array passed to the USB core.
+ * @halted: Set if the endpoint has been halted.
+ * @periodic: Set if this is a periodic ep, such as Interrupt
+ * @isochronous: Set if this is a isochronous ep
+ * @sent_zlp: Set if we've sent a zero-length packet.
+ * @total_data: The total number of data bytes done.
+ * @fifo_size: The size of the FIFO (for periodic IN endpoints)
+ * @fifo_load: The amount of data loaded into the FIFO (periodic IN)
+ * @last_load: The offset of data for the last start of request.
+ * @size_loaded: The last loaded size for DxEPTSIZE for periodic IN
+ *
+ * This is the driver's state for each registered enpoint, allowing it
+ * to keep track of transactions that need doing. Each endpoint has a
+ * lock to protect the state, to try and avoid using an overall lock
+ * for the host controller as much as possible.
+ *
+ * For periodic IN endpoints, we have fifo_size and fifo_load to try
+ * and keep track of the amount of data in the periodic FIFO for each
+ * of these as we don't have a status register that tells us how much
+ * is in each of them. (note, this may actually be useless information
+ * as in shared-fifo mode periodic in acts like a single-frame packet
+ * buffer than a fifo)
+ */
+struct s3c_hsotg_ep {
+	struct usb_ep		ep;
+	struct list_head	queue;
+	struct dwc2_hsotg	*parent;
+	struct s3c_hsotg_req	*req;
+	struct dentry		*debugfs;
+
+
+	unsigned long		total_data;
+	unsigned int		size_loaded;
+	unsigned int		last_load;
+	unsigned int		fifo_load;
+	unsigned short		fifo_size;
+
+	unsigned char		dir_in;
+	unsigned char		index;
+	unsigned char		mc;
+	unsigned char		interval;
+
+	unsigned int		halted:1;
+	unsigned int		periodic:1;
+	unsigned int		isochronous:1;
+	unsigned int		sent_zlp:1;
+
+	char			name[10];
+
+	void __iomem		*regs;
+};
+
+/**
+ * struct s3c_hsotg - driver state.
+ * @dev: The parent device supplied to the probe function
+ * @driver: USB gadget driver
+ * @phy: The otg phy transceiver structure for phy control.
+ * @uphy: The otg phy transceiver structure for old USB phy control.
+ * @plat: The platform specific configuration data. This can be removed once
+ * all SoCs support usb transceiver.
+ * @regs: The memory area mapped for accessing registers.
+ * @irq: The IRQ number we are using
+ * @supplies: Definition of USB power supplies
+ * @phyif: PHY interface width
+ * @dedicated_fifos: Set if the hardware has dedicated IN-EP fifos.
+ * @num_of_eps: Number of available EPs (excluding EP0)
+ * @debug_root: root directrory for debugfs.
+ * @debug_file: main status file for debugfs.
+ * @debug_fifo: FIFO status file for debugfs.
+ * @ep0_reply: Request used for ep0 reply.
+ * @ep0_buff: Buffer for EP0 reply data, if needed.
+ * @ctrl_buff: Buffer for EP0 control requests.
+ * @ctrl_req: Request for EP0 control packets.
+ * @setup: NAK management for EP0 SETUP
+ * @last_rst: Time of last reset
+ * @eps: The endpoints being supplied to the gadget framework
+ */
+struct s3c_hsotg {
+	struct usb_phy		 *phy;
+	struct phy		 *gphy;
+	struct s3c_hsotg_plat	 *plat;
+
+	int			irq;
+	struct clk		*clk;
+
+	struct regulator_bulk_data supplies[ARRAY_SIZE(s3c_hsotg_supply_names)];
+
+	unsigned int		dedicated_fifos:1;
+	unsigned char           num_of_eps;
+
+	struct dentry		*debug_root;
+	struct dentry		*debug_file;
+	struct dentry		*debug_fifo;
+
+	struct usb_request	*ep0_reply;
+	struct usb_request	*ctrl_req;
+	u8			ep0_buff[8];
+	u8			ctrl_buff[8];
+
+	unsigned int		setup;
+	unsigned long           last_rst;
+};
+
+/**
+ * struct s3c_hsotg_req - data transfer request
+ * @req: The USB gadget request
+ * @queue: The list of requests for the endpoint this is queued for.
+ * @in_progress: Has already had size/packets written to core
+ * @mapped: DMA buffer for this request has been mapped via dma_map_single().
+ */
+struct s3c_hsotg_req {
+	struct usb_request	req;
+	struct list_head	queue;
+	unsigned char		in_progress;
+	unsigned char		mapped;
+};
+
 /* Device States */
 enum dwc2_lx_state {
 	DWC2_L0,	/* On state */
@@ -419,6 +564,11 @@ struct dwc2_hsotg {
 	struct timer_list wkp_timer;
 	enum dwc2_lx_state lx_state;
 
+	struct s3c_hsotg *s3c_hsotg;
+	struct usb_gadget       gadget;
+	struct usb_gadget_driver *driver;
+	struct s3c_hsotg_ep	*eps;
+
 	union dwc2_hcd_internal_flags {
 		u32 d32;
 		struct {
@@ -765,4 +915,29 @@ extern void dwc2_dump_global_registers(struct dwc2_hsotg *hsotg);
  */
 extern u16 dwc2_get_otg_version(struct dwc2_hsotg *hsotg);
 
+/* Gadget defines */
+extern void s3c_hsotg_disconnect(struct dwc2_hsotg *dwc2);
+extern void s3c_hsotg_irq_enumdone(struct dwc2_hsotg *dwc2);
+extern void s3c_hsotg_epint(struct dwc2_hsotg *dwc2, unsigned int idx,
+					int dir_in);
+extern void kill_all_requests(struct dwc2_hsotg *dwc2,
+			struct s3c_hsotg_ep *ep, int result, bool force);
+extern void s3c_hsotg_core_init(struct dwc2_hsotg *dwc2);
+extern void s3c_hsotg_disable_gsint(struct dwc2_hsotg *dwc2, u32 ints);
+extern void s3c_hsotg_irq_fifoempty(struct dwc2_hsotg *dwc2, bool periodic);
+extern void s3c_hsotg_handle_rx(struct dwc2_hsotg *dwc2);
+extern void s3c_hsotg_dump(struct dwc2_hsotg *dwc2);
+extern void s3c_hsotg_remove(struct dwc2_hsotg *dwc2);
+
+
+#define call_gadget(_hs, _entry) \
+do { \
+	if ((_hs)->gadget.speed != USB_SPEED_UNKNOWN && \
+		(_hs)->driver && (_hs)->driver->_entry) { \
+			spin_unlock(&_hs->lock); \
+			(_hs)->driver->_entry(&(_hs)->gadget); \
+			spin_lock(&_hs->lock); \
+	} \
+} while (0)
+
 #endif /* __DWC2_CORE_H__ */
diff --git a/drivers/usb/dwc2/core_intr.c b/drivers/usb/dwc2/core_intr.c
index 07cfa2f..e8d0c6e 100644
--- a/drivers/usb/dwc2/core_intr.c
+++ b/drivers/usb/dwc2/core_intr.c
@@ -321,6 +321,7 @@ static void dwc2_handle_wakeup_detected_intr(struct dwc2_hsotg *hsotg)
 		}
 		/* Change to L0 state */
 		hsotg->lx_state = DWC2_L0;
+		call_gadget(hsotg, resume);
 	} else {
 		if (hsotg->lx_state != DWC2_L1) {
 			u32 pcgcctl = readl(hsotg->regs + PCGCTL);
@@ -370,6 +371,9 @@ static void dwc2_handle_usb_suspend_intr(struct dwc2_hsotg *hsotg)
 
 	dev_dbg(hsotg->dev, "USB SUSPEND\n");
 
+	/* Clear interrupt */
+	writel(GINTSTS_USBSUSP, hsotg->regs + GINTSTS);
+
 	if (dwc2_is_device_mode(hsotg)) {
 		/*
 		 * Check the Device status register to determine if the Suspend
@@ -381,6 +385,8 @@ static void dwc2_handle_usb_suspend_intr(struct dwc2_hsotg *hsotg)
 			"DSTS.Suspend Status=%d HWCFG4.Power Optimize=%d\n",
 			!!(dsts & DSTS_SUSPSTS),
 			hsotg->hw_params.power_optimized);
+
+		call_gadget(hsotg, suspend);
 	} else {
 		if (hsotg->op_state == OTG_STATE_A_PERIPHERAL) {
 			dev_dbg(hsotg->dev, "a_peripheral->a_host\n");
@@ -395,15 +401,11 @@ static void dwc2_handle_usb_suspend_intr(struct dwc2_hsotg *hsotg)
 
 	/* Change to L2 (suspend) state */
 	hsotg->lx_state = DWC2_L2;
-
-	/* Clear interrupt */
-	writel(GINTSTS_USBSUSP, hsotg->regs + GINTSTS);
 }
-
-#define GINTMSK_COMMON	(GINTSTS_WKUPINT | GINTSTS_SESSREQINT |		\
-			 GINTSTS_CONIDSTSCHNG | GINTSTS_OTGINT |	\
-			 GINTSTS_MODEMIS | GINTSTS_DISCONNINT |		\
-			 GINTSTS_USBSUSP | GINTSTS_PRTINT)
+/* IRQ flags which will trigger a retry around the IRQ loop */
+#define IRQ_RETRY_MASK (GINTSTS_NPTXFEMP | \
+			GINTSTS_PTXFEMP |  \
+			GINTSTS_RXFLVL)
 
 /*
  * This function returns the Core Interrupt register
@@ -413,7 +415,6 @@ static u32 dwc2_read_common_intr(struct dwc2_hsotg *hsotg)
 	u32 gintsts;
 	u32 gintmsk;
 	u32 gahbcfg;
-	u32 gintmsk_common = GINTMSK_COMMON;
 
 	gintsts = readl(hsotg->regs + GINTSTS);
 	gintmsk = readl(hsotg->regs + GINTMSK);
@@ -421,13 +422,13 @@ static u32 dwc2_read_common_intr(struct dwc2_hsotg *hsotg)
 
 #ifdef DEBUG
 	/* If any common interrupts set */
-	if (gintsts & gintmsk_common)
+	if (gintsts)
 		dev_dbg(hsotg->dev, "gintsts=%08x  gintmsk=%08x\n",
 			gintsts, gintmsk);
 #endif
 
 	if (gahbcfg & GAHBCFG_GLBL_INTR_EN)
-		return gintsts & gintmsk & gintmsk_common;
+		return gintsts & gintmsk;
 	else
 		return 0;
 }
@@ -449,7 +450,8 @@ irqreturn_t dwc2_handle_common_intr(int irq, void *dev)
 {
 	struct dwc2_hsotg *hsotg = dev;
 	u32 gintsts;
-	irqreturn_t retval = IRQ_NONE;
+	int retry_count = 8;
+	irqreturn_t retval = IRQ_HANDLED;
 
 	if (dwc2_check_core_status(hsotg) < 0) {
 		dev_warn(hsotg->dev, "Controller is disconnected\n");
@@ -457,17 +459,91 @@ irqreturn_t dwc2_handle_common_intr(int irq, void *dev)
 	}
 
 	spin_lock(&hsotg->lock);
-
+irq_retry:
 	gintsts = dwc2_read_common_intr(hsotg);
 	if (gintsts & ~GINTSTS_PRTINT)
 		retval = IRQ_HANDLED;
 
+	if (gintsts & GINTSTS_ENUMDONE) {
+		writel(GINTSTS_ENUMDONE, hsotg->regs + GINTSTS);
+		s3c_hsotg_irq_enumdone(hsotg);
+	}
+
 	if (gintsts & GINTSTS_MODEMIS)
 		dwc2_handle_mode_mismatch_intr(hsotg);
 	if (gintsts & GINTSTS_OTGINT)
 		dwc2_handle_otg_intr(hsotg);
 	if (gintsts & GINTSTS_CONIDSTSCHNG)
 		dwc2_handle_conn_id_status_change_intr(hsotg);
+
+	if (gintsts & (GINTSTS_OEPINT | GINTSTS_IEPINT)) {
+		u32 daint = readl(hsotg->regs + DAINT);
+		u32 daint_out = daint >> DAINT_OUTEP_SHIFT;
+		u32 daint_in = daint & ~(daint_out << DAINT_OUTEP_SHIFT);
+		int ep;
+
+		dev_dbg(hsotg->dev, "%s: daint=%08x\n", __func__, daint);
+		for (ep = 0; ep < 15 && daint_out; ep++, daint_out >>= 1) {
+			if (daint_out & 1)
+				s3c_hsotg_epint(hsotg, ep, 0);
+		}
+
+		for (ep = 0; ep < 15 && daint_in; ep++, daint_in >>= 1) {
+			if (daint_in & 1)
+				s3c_hsotg_epint(hsotg, ep, 1);
+		}
+	}
+
+	if (gintsts & GINTSTS_USBRST) {
+		u32 usb_status = readl(hsotg->regs + GOTGCTL);
+
+		dev_dbg(hsotg->dev, "%s: USBRST\n", __func__);
+		dev_dbg(hsotg->dev, "GNPTXSTS=%08x\n",
+			readl(hsotg->regs + GNPTXSTS));
+
+		writel(GINTSTS_USBRST, hsotg->regs + GINTSTS);
+
+		if (usb_status & GOTGCTL_BSESVLD) {
+			if (time_after(jiffies, hsotg->s3c_hsotg->last_rst +
+				msecs_to_jiffies(200))) {
+				kill_all_requests(hsotg, &hsotg->eps[0],
+					-ECONNRESET, true);
+				s3c_hsotg_core_init(hsotg);
+				hsotg->s3c_hsotg->last_rst = jiffies;
+			}
+		}
+	}
+
+	if (gintsts & GINTSTS_NPTXFEMP) {
+		dev_dbg(hsotg->dev, "NPTXFEMP\n");
+
+		/*
+		 * Disable the interrupt to stop it happening again
+		 * unless one of these endpoint routines decides that
+		 * it needs re-enabling
+		 */
+		s3c_hsotg_disable_gsint(hsotg, GINTSTS_NPTXFEMP);
+		s3c_hsotg_irq_fifoempty(hsotg, false);
+	}
+
+	if (gintsts & GINTSTS_PTXFEMP) {
+		dev_dbg(hsotg->dev, "PTXFEMP\n");
+
+		/* See note in GINTSTS_NPTxFEmp */
+		s3c_hsotg_disable_gsint(hsotg, GINTSTS_PTXFEMP);
+		s3c_hsotg_irq_fifoempty(hsotg, true);
+	}
+
+	if (gintsts & GINTSTS_RXFLVL) {
+		/*
+		 * note, since GINTSTS_RXFLVL doubles as FIFO-not-empty,
+		 * we need to retry s3c_hsotg_handle_rx if this is still
+		 * set.
+		 */
+		s3c_hsotg_handle_rx(hsotg);
+	}
+
+
 	if (gintsts & GINTSTS_DISCONNINT)
 		dwc2_handle_disconnect_intr(hsotg);
 	if (gintsts & GINTSTS_SESSREQINT)
@@ -477,6 +553,28 @@ irqreturn_t dwc2_handle_common_intr(int irq, void *dev)
 	if (gintsts & GINTSTS_USBSUSP)
 		dwc2_handle_usb_suspend_intr(hsotg);
 
+	if (gintsts & GINTSTS_ERLYSUSP) {
+		dev_dbg(hsotg->dev, "GINTSTS_ERLYSUSP\n");
+		writel(GINTSTS_ERLYSUSP, hsotg->regs + GINTSTS);
+	}
+
+	/*
+	 * these next two seem to crop-up occasionally causing the core
+	 * to shutdown the USB transfer, so try clearing them and logging
+	 * the occurrence.
+	 */
+	if (gintsts & GINTSTS_GOUTNAKEFF) {
+		dev_dbg(hsotg->dev, "GOUTNAKEFF triggered\n");
+		writel(DCTL_CGOUTNAK, hsotg->regs + DCTL);
+		s3c_hsotg_dump(hsotg);
+	}
+
+	if (gintsts & GINTSTS_GINNAKEFF) {
+		dev_dbg(hsotg->dev, "GINNAKEFF triggered\n");
+		writel(DCTL_CGNPINNAK, hsotg->regs + DCTL);
+		s3c_hsotg_dump(hsotg);
+	}
+
 	if (gintsts & GINTSTS_PRTINT) {
 		/*
 		 * The port interrupt occurs while in device mode with HPRT0
@@ -491,6 +589,13 @@ irqreturn_t dwc2_handle_common_intr(int irq, void *dev)
 		}
 	}
 
+	/*
+	 * if we've had fifo events, we should try and go around the
+	 * loop again to see if there's any point in returning yet.
+	 */
+	if (gintsts & IRQ_RETRY_MASK && --retry_count > 0)
+		goto irq_retry;
+
 	spin_unlock(&hsotg->lock);
 out:
 	return retval;
diff --git a/drivers/usb/dwc2/hcd.c b/drivers/usb/dwc2/hcd.c
index 3cfd2d5..3fd436c 100644
--- a/drivers/usb/dwc2/hcd.c
+++ b/drivers/usb/dwc2/hcd.c
@@ -1341,6 +1341,7 @@ static void dwc2_conn_id_status_change(struct work_struct *work)
 		hsotg->op_state = OTG_STATE_B_PERIPHERAL;
 		dwc2_core_init(hsotg, false, -1);
 		dwc2_enable_global_interrupts(hsotg);
+		s3c_hsotg_core_init(hsotg);
 	} else {
 		/* A-Device connector (Host Mode) */
 		dev_dbg(hsotg->dev, "connId A\n");
@@ -2784,11 +2785,6 @@ int dwc2_hcd_init(struct dwc2_hsotg *hsotg, int irq,
 		goto error1;
 	hsotg->last_frame_num = HFNUM_MAX_FRNUM;
 #endif
-
-	hsotg->core_params = kzalloc(sizeof(*hsotg->core_params), GFP_KERNEL);
-	if (!hsotg->core_params)
-		goto error1;
-
 	dwc2_set_all_params(hsotg->core_params, -1);
 
 	/* Validate parameter values */
@@ -2820,7 +2816,6 @@ int dwc2_hcd_init(struct dwc2_hsotg *hsotg, int irq,
 
 	hcd->has_tt = 1;
 
-	spin_lock_init(&hsotg->lock);
 	((struct wrapper_priv_data *) &hcd->hcd_priv)->hsotg = hsotg;
 	hsotg->priv = hcd;
 
diff --git a/drivers/usb/dwc2/hcd.h b/drivers/usb/dwc2/hcd.h
index 89a5484..b1c17d5 100644
--- a/drivers/usb/dwc2/hcd.h
+++ b/drivers/usb/dwc2/hcd.h
@@ -449,6 +449,7 @@ static inline u8 dwc2_hcd_is_pipe_out(struct dwc2_hcd_pipe_info *pipe)
 	return !dwc2_hcd_is_pipe_in(pipe);
 }
 
+extern int dwc2_gadget_init(struct dwc2_hsotg *hsotg, int irq);
 extern int dwc2_hcd_init(struct dwc2_hsotg *hsotg, int irq,
 			 const struct dwc2_core_params *params);
 extern void dwc2_hcd_remove(struct dwc2_hsotg *hsotg);
diff --git a/drivers/usb/dwc2/hw.h b/drivers/usb/dwc2/hw.h
index 9c92a3c..2bdbeab 100644
--- a/drivers/usb/dwc2/hw.h
+++ b/drivers/usb/dwc2/hw.h
@@ -169,14 +169,14 @@
 #define GRXSTS_FN_SHIFT			25
 #define GRXSTS_PKTSTS_MASK		(0xf << 17)
 #define GRXSTS_PKTSTS_SHIFT		17
-#define GRXSTS_PKTSTS_GLOBALOUTNAK	1
-#define GRXSTS_PKTSTS_OUTRX		2
+#define GRXSTS_PKTSTS_GLOBALOUTNAK	(0x1 << 17)
+#define GRXSTS_PKTSTS_OUTRX		(0x2 << 17)
 #define GRXSTS_PKTSTS_HCHIN		2
-#define GRXSTS_PKTSTS_OUTDONE		3
+#define GRXSTS_PKTSTS_OUTDONE		(0x3 << 17)
 #define GRXSTS_PKTSTS_HCHIN_XFER_COMP	3
-#define GRXSTS_PKTSTS_SETUPDONE		4
+#define GRXSTS_PKTSTS_SETUPDONE		(0x4 << 17)
 #define GRXSTS_PKTSTS_DATATOGGLEERR	5
-#define GRXSTS_PKTSTS_SETUPRX		6
+#define GRXSTS_PKTSTS_SETUPRX		(0x6 << 17)
 #define GRXSTS_PKTSTS_HCHHALTED		7
 #define GRXSTS_HCHNUM_MASK		(0xf << 0)
 #define GRXSTS_HCHNUM_SHIFT		0
@@ -403,6 +403,9 @@
 #define FIFOSIZE_DEPTH_SHIFT		16
 #define FIFOSIZE_STARTADDR_MASK		(0xffff << 0)
 #define FIFOSIZE_STARTADDR_SHIFT	0
+#define DPTXFSIZN_DPTXFSIZE_GET(_v)	(((_v) >> 16) & 0xffff)
+#define DPTXFSIZN_DPTXFSIZE(_x)		((_x) << 16)
+#define DPTXFSIZN_DPTXFADDR(_x)		((_x) << 0)
 
 /* Device mode registers */
 
@@ -520,10 +523,11 @@
 #define DXEPCTL_SNP			(1 << 20)
 #define DXEPCTL_EPTYPE_MASK		(0x3 << 18)
 #define DXEPCTL_EPTYPE_SHIFT		18
-#define DXEPCTL_EPTYPE_CONTROL		0
-#define DXEPCTL_EPTYPE_ISO		1
-#define DXEPCTL_EPTYPE_BULK		2
-#define DXEPCTL_EPTYPE_INTTERUPT	3
+#define DXEPCTL_EPTYPE_CONTROL		(0x0 << 18)
+#define DXEPCTL_EPTYPE_ISO		(0x1 << 18)
+#define DXEPCTL_EPTYPE_BULK		(0x2 << 18)
+#define DXEPCTL_EPTYPE_INTERRUPT	(0x3 << 18)
+
 #define DXEPCTL_NAKSTS			(1 << 17)
 #define DXEPCTL_DPID			(1 << 16)
 #define DXEPCTL_EOFRNUM			(1 << 16)
diff --git a/drivers/usb/dwc2/platform.c b/drivers/usb/dwc2/platform.c
index d434c9d..27ca397 100644
--- a/drivers/usb/dwc2/platform.c
+++ b/drivers/usb/dwc2/platform.c
@@ -41,6 +41,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/of_platform.h>
 #include <linux/platform_device.h>
+#include <linux/usb/otg.h>
 #include <linux/usb.h>
 
 #include "core.h"
@@ -63,7 +64,14 @@ static int dwc2_driver_remove(struct platform_device *dev)
 {
 	struct dwc2_hsotg *hsotg = platform_get_drvdata(dev);
 
-	dwc2_hcd_remove(hsotg);
+	if (IS_ENABLED(CONFIG_USB_DWC2_GADGET))
+		s3c_hsotg_remove(hsotg);
+	else if (IS_ENABLED(CONFIG_USB_DWC2_HOST))
+		dwc2_hcd_remove(hsotg);
+	else { /* dual role */
+		s3c_hsotg_remove(hsotg);
+		dwc2_hcd_remove(hsotg);
+	}
 
 	return 0;
 }
@@ -96,6 +104,10 @@ static int dwc2_driver_probe(struct platform_device *dev)
 	if (!hsotg)
 		return -ENOMEM;
 
+	hsotg->core_params = kzalloc(sizeof(*hsotg->core_params), GFP_KERNEL);
+	if (!hsotg->core_params)
+		return -ENOMEM;
+
 	hsotg->dev = &dev->dev;
 
 	/*
@@ -146,12 +158,28 @@ static int dwc2_driver_probe(struct platform_device *dev)
 		params.dma_desc_enable = prop;
 	}
 
-	retval = dwc2_hcd_init(hsotg, irq, &params);
-	if (retval)
-		return retval;
+	if (IS_ENABLED(CONFIG_USB_DWC2_HOST)) {
+		retval = dwc2_hcd_init(hsotg, irq, &params);
+		if (retval)
+			return retval;
+	} else if (IS_ENABLED(CONFIG_USB_DWC2_GADGET)) {
+		retval = dwc2_gadget_init(hsotg, irq);
+		if (retval)
+			return retval;
+		retval = dwc2_core_init(hsotg, true, irq);
+		if (retval)
+			return retval;
+	} else { /* dual role */
+		retval = dwc2_gadget_init(hsotg, irq);
+		if (retval)
+			return retval;
+		retval = dwc2_hcd_init(hsotg, irq, &params);
+		if (retval)
+			return retval;
+	}
+	spin_lock_init(&hsotg->lock);
 
 	platform_set_drvdata(dev, hsotg);
-
 	return retval;
 }
 
diff --git a/drivers/usb/dwc2/s3c-hsotg.c b/drivers/usb/dwc2/s3c-hsotg.c
new file mode 100644
index 0000000..4b28d2e
--- /dev/null
+++ b/drivers/usb/dwc2/s3c-hsotg.c
@@ -0,0 +1,3361 @@
+/**
+ * linux/drivers/usb/gadget/s3c-hsotg.c
+ *
+ * Copyright (c) 2011 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ *
+ * Copyright 2008 Openmoko, Inc.
+ * Copyright 2008 Simtec Electronics
+ *      Ben Dooks <ben@simtec.co.uk>
+ *      http://armlinux.simtec.co.uk/
+ *
+ * S3C USB2.0 High-speed / OtG driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/clk.h>
+#include <linux/regulator/consumer.h>
+#include <linux/of_platform.h>
+
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include <linux/usb/phy.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_data/s3c-hsotg.h>
+
+#include "hw.h"
+#include "core.h"
+
+/*
+ * EP0_MPS_LIMIT
+ *
+ * Unfortunately there seems to be a limit of the amount of data that can
+ * be transferred by IN transactions on EP0. This is either 127 bytes or 3
+ * packets (which practically means 1 packet and 63 bytes of data) when the
+ * MPS is set to 64.
+ *
+ * This means if we are wanting to move >127 bytes of data, we need to
+ * split the transactions up, but just doing one packet at a time does
+ * not work (this may be an implicit DATA0 PID on first packet of the
+ * transaction) and doing 2 packets is outside the controller's limits.
+ *
+ * If we try to lower the MPS size for EP0, then no transfers work properly
+ * for EP0, and the system will fail basic enumeration. As no cause for this
+ * has currently been found, we cannot support any large IN transfers for
+ * EP0.
+ */
+#define EP0_MPS_LIMIT	64
+
+/* conversion functions */
+static inline struct s3c_hsotg_req *our_req(struct usb_request *req)
+{
+	return container_of(req, struct s3c_hsotg_req, req);
+}
+
+static inline struct s3c_hsotg_ep *our_ep(struct usb_ep *ep)
+{
+	return container_of(ep, struct s3c_hsotg_ep, ep);
+}
+
+static inline struct dwc2_hsotg *to_hsotg(struct usb_gadget *gadget)
+{
+	return container_of(gadget, struct dwc2_hsotg, gadget);
+}
+
+static inline void __orr32(void __iomem *ptr, u32 val)
+{
+	writel(readl(ptr) | val, ptr);
+}
+
+static inline void __bic32(void __iomem *ptr, u32 val)
+{
+	writel(readl(ptr) & ~val, ptr);
+}
+
+/* forward decleration of functions */
+
+/**
+ * using_dma - return the DMA status of the driver.
+ * @hsotg: The driver state.
+ *
+ * Return true if we're using DMA.
+ *
+ * Currently, we have the DMA support code worked into everywhere
+ * that needs it, but the AMBA DMA implementation in the hardware can
+ * only DMA from 32bit aligned addresses. This means that gadgets such
+ * as the CDC Ethernet cannot work as they often pass packets which are
+ * not 32bit aligned.
+ *
+ * Unfortunately the choice to use DMA or not is global to the controller
+ * and seems to be only settable when the controller is being put through
+ * a core reset. This means we either need to fix the gadgets to take
+ * account of DMA alignment, or add bounce buffers (yuerk).
+ *
+ * Until this issue is sorted out, we always return 'false'.
+ */
+static inline bool using_dma(struct s3c_hsotg *hsotg)
+{
+	return false;	/* support is not complete */
+}
+
+/**
+ * s3c_hsotg_en_gsint - enable one or more of the general interrupt
+ * @hsotg: The device state
+ * @ints: A bitmask of the interrupts to enable
+ */
+static void s3c_hsotg_en_gsint(struct dwc2_hsotg *dwc2, u32 ints)
+{
+	u32 gsintmsk = readl(dwc2->regs + GINTMSK);
+	u32 new_gsintmsk;
+
+	new_gsintmsk = gsintmsk | ints;
+
+	if (new_gsintmsk != gsintmsk) {
+		dev_dbg(dwc2->dev, "gsintmsk now 0x%08x\n", new_gsintmsk);
+		writel(new_gsintmsk, dwc2->regs + GINTMSK);
+	}
+}
+
+/**
+ * s3c_hsotg_disable_gsint - disable one or more of the general interrupt
+ * @hsotg: The device state
+ * @ints: A bitmask of the interrupts to enable
+ */
+void s3c_hsotg_disable_gsint(struct dwc2_hsotg *dwc2, u32 ints)
+{
+	u32 gsintmsk = readl(dwc2->regs + GINTMSK);
+	u32 new_gsintmsk;
+
+	new_gsintmsk = gsintmsk & ~ints;
+
+	if (new_gsintmsk != gsintmsk)
+		writel(new_gsintmsk, dwc2->regs + GINTMSK);
+}
+
+/**
+ * s3c_hsotg_ctrl_epint - enable/disable an endpoint irq
+ * @hsotg: The device state
+ * @ep: The endpoint index
+ * @dir_in: True if direction is in.
+ * @en: The enable value, true to enable
+ *
+ * Set or clear the mask for an individual endpoint's interrupt
+ * request.
+ */
+static void s3c_hsotg_ctrl_epint(struct dwc2_hsotg *dwc2,
+				 unsigned int ep, unsigned int dir_in,
+				 unsigned int en)
+{
+	unsigned long flags;
+	u32 bit = 1 << ep;
+	u32 daint;
+
+	if (!dir_in)
+		bit <<= 16;
+
+	local_irq_save(flags);
+	daint = readl(dwc2->regs + DAINTMSK);
+	if (en)
+		daint |= bit;
+	else
+		daint &= ~bit;
+	writel(daint, dwc2->regs + DAINTMSK);
+	local_irq_restore(flags);
+}
+
+/**
+ * s3c_hsotg_init_fifo - initialise non-periodic FIFOs
+ * @hsotg: The device instance.
+ */
+static void s3c_hsotg_init_fifo(struct dwc2_hsotg *dwc2)
+{
+	unsigned int ep;
+	unsigned int addr;
+	unsigned int size;
+	int timeout;
+	u32 val;
+
+	/* set FIFO sizes to 2048/1024 */
+
+	writel(2048, dwc2->regs + GRXFSIZ);
+	writel(DPTXFSIZN_DPTXFADDR(2048) |
+	       DPTXFSIZN_DPTXFSIZE(1024),
+	       dwc2->regs + GNPTXFSIZ);
+
+	/*
+	 * arange all the rest of the TX FIFOs, as some versions of this
+	 * block have overlapping default addresses. This also ensures
+	 * that if the settings have been changed, then they are set to
+	 * known values.
+	 */
+
+	/* start at the end of the GNPTXFSIZ, rounded up */
+	addr = 2048 + 1024;
+	size = 768;
+
+	/*
+	 * currently we allocate TX FIFOs for all possible endpoints,
+	 * and assume that they are all the same size.
+	 */
+
+	for (ep = 1; ep <= 15; ep++) {
+		val = addr;
+		val |= size << FIFOSIZE_DEPTH_SHIFT;
+		addr += size;
+
+		writel(val, dwc2->regs + DPTXFSIZN(ep));
+	}
+
+	/*
+	 * according to p428 of the design guide, we need to ensure that
+	 * all fifos are flushed before continuing
+	 */
+
+	writel(GRSTCTL_TXFNUM(0x10) | GRSTCTL_TXFFLSH |
+	       GRSTCTL_RXFFLSH, dwc2->regs + GRSTCTL);
+
+	/* wait until the fifos are both flushed */
+	timeout = 100;
+	while (1) {
+		val = readl(dwc2->regs + GRSTCTL);
+
+		if ((val & (GRSTCTL_TXFFLSH | GRSTCTL_RXFFLSH)) == 0)
+			break;
+
+		if (--timeout == 0) {
+			dev_err(dwc2->dev,
+				"%s: timeout flushing fifos (GRSTCTL=%08x)\n",
+				__func__, val);
+		}
+
+		udelay(1);
+	}
+
+	dev_dbg(dwc2->dev, "FIFOs reset, timeout at %d\n", timeout);
+}
+
+/**
+ * @ep: USB endpoint to allocate request for.
+ * @flags: Allocation flags
+ *
+ * Allocate a new USB request structure appropriate for the specified endpoint
+ */
+static struct usb_request *s3c_hsotg_ep_alloc_request(struct usb_ep *ep,
+						      gfp_t flags)
+{
+	struct s3c_hsotg_req *req;
+
+	req = kzalloc(sizeof(struct s3c_hsotg_req), flags);
+	if (!req)
+		return NULL;
+
+	INIT_LIST_HEAD(&req->queue);
+
+	return &req->req;
+}
+
+/**
+ * is_ep_periodic - return true if the endpoint is in periodic mode.
+ * @hs_ep: The endpoint to query.
+ *
+ * Returns true if the endpoint is in periodic mode, meaning it is being
+ * used for an Interrupt or ISO transfer.
+ */
+static inline int is_ep_periodic(struct s3c_hsotg_ep *hs_ep)
+{
+	return hs_ep->periodic;
+}
+
+/**
+ * s3c_hsotg_unmap_dma - unmap the DMA memory being used for the request
+ * @hsotg: The device state.
+ * @hs_ep: The endpoint for the request
+ * @hs_req: The request being processed.
+ *
+ * This is the reverse of s3c_hsotg_map_dma(), called for the completion
+ * of a request to ensure the buffer is ready for access by the caller.
+ */
+static void s3c_hsotg_unmap_dma(struct dwc2_hsotg *dwc2,
+				struct s3c_hsotg_ep *hs_ep,
+				struct s3c_hsotg_req *hs_req)
+{
+	struct usb_request *req = &hs_req->req;
+
+	/* ignore this if we're not moving any data */
+	if (hs_req->req.length == 0)
+		return;
+
+	usb_gadget_unmap_request(&dwc2->gadget, req, hs_ep->dir_in);
+}
+
+/**
+ * s3c_hsotg_write_fifo - write packet Data to the TxFIFO
+ * @hsotg: The controller state.
+ * @hs_ep: The endpoint we're going to write for.
+ * @hs_req: The request to write data for.
+ *
+ * This is called when the TxFIFO has some space in it to hold a new
+ * transmission and we have something to give it. The actual setup of
+ * the data size is done elsewhere, so all we have to do is to actually
+ * write the data.
+ *
+ * The return value is zero if there is more space (or nothing was done)
+ * otherwise -ENOSPC is returned if the FIFO space was used up.
+ *
+ * This routine is only needed for PIO
+ */
+static int s3c_hsotg_write_fifo(struct dwc2_hsotg *dwc2,
+				struct s3c_hsotg_ep *hs_ep,
+				struct s3c_hsotg_req *hs_req)
+{
+	bool periodic = is_ep_periodic(hs_ep);
+	u32 gnptxsts = readl(dwc2->regs + GNPTXSTS);
+	int buf_pos = hs_req->req.actual;
+	int to_write = hs_ep->size_loaded;
+	void *data;
+	int can_write;
+	int pkt_round;
+	int max_transfer;
+
+	to_write -= (buf_pos - hs_ep->last_load);
+
+	/* if there's nothing to write, get out early */
+	if (to_write == 0)
+		return 0;
+
+	if (periodic && !dwc2->s3c_hsotg->dedicated_fifos) {
+		u32 epsize = readl(dwc2->regs + DIEPTSIZ(hs_ep->index));
+		int size_left;
+		int size_done;
+
+		/*
+		 * work out how much data was loaded so we can calculate
+		 * how much data is left in the fifo.
+		 */
+
+		size_left = DXEPTSIZ_XFERSIZE_GET(epsize);
+
+		/*
+		 * if shared fifo, we cannot write anything until the
+		 * previous data has been completely sent.
+		 */
+		if (hs_ep->fifo_load != 0) {
+			s3c_hsotg_en_gsint(dwc2, GINTSTS_PTXFEMP);
+			return -ENOSPC;
+		}
+
+		dev_dbg(dwc2->dev, "%s: left=%d, load=%d, fifo=%d, size %d\n",
+			__func__, size_left,
+			hs_ep->size_loaded, hs_ep->fifo_load, hs_ep->fifo_size);
+
+		/* how much of the data has moved */
+		size_done = hs_ep->size_loaded - size_left;
+
+		/* how much data is left in the fifo */
+		can_write = hs_ep->fifo_load - size_done;
+		dev_dbg(dwc2->dev, "%s: => can_write1=%d\n",
+			__func__, can_write);
+
+		can_write = hs_ep->fifo_size - can_write;
+		dev_dbg(dwc2->dev, "%s: => can_write2=%d\n",
+			__func__, can_write);
+
+		if (can_write <= 0) {
+			s3c_hsotg_en_gsint(dwc2, GINTSTS_PTXFEMP);
+			return -ENOSPC;
+		}
+	} else if (dwc2->s3c_hsotg->dedicated_fifos && hs_ep->index != 0) {
+		can_write = readl(dwc2->regs + DTXFSTS(hs_ep->index));
+
+		can_write &= 0xffff;
+		can_write *= 4;
+	} else {
+		if (GNPTXSTS_NP_TXQ_SPC_AVAIL_GET(gnptxsts) == 0) {
+			dev_dbg(dwc2->dev,
+				"%s: no queue slots available (0x%08x)\n",
+				__func__, gnptxsts);
+
+			s3c_hsotg_en_gsint(dwc2, GINTSTS_NPTXFEMP);
+			return -ENOSPC;
+		}
+
+		can_write = GNPTXSTS_NP_TXF_SPC_AVAIL_GET(gnptxsts);
+		can_write *= 4;	/* fifo size is in 32bit quantities. */
+	}
+
+	max_transfer = hs_ep->ep.maxpacket * hs_ep->mc;
+
+	dev_dbg(dwc2->dev, "%s: GNPTXSTS=%08x, can=%d, to=%d, max_transfer %d\n",
+		 __func__, gnptxsts, can_write, to_write, max_transfer);
+
+	/*
+	 * limit to 512 bytes of data, it seems at least on the non-periodic
+	 * FIFO, requests of >512 cause the endpoint to get stuck with a
+	 * fragment of the end of the transfer in it.
+	 */
+	if (can_write > 512 && !periodic)
+		can_write = 512;
+
+	/*
+	 * limit the write to one max-packet size worth of data, but allow
+	 * the transfer to return that it did not run out of fifo space
+	 * doing it.
+	 */
+	if (to_write > max_transfer) {
+		to_write = max_transfer;
+
+		/* it's needed only when we do not use dedicated fifos */
+		if (!dwc2->s3c_hsotg->dedicated_fifos)
+			s3c_hsotg_en_gsint(dwc2,
+					   periodic ? GINTSTS_PTXFEMP :
+					   GINTSTS_NPTXFEMP);
+	}
+
+	/* see if we can write data */
+
+	if (to_write > can_write) {
+		to_write = can_write;
+		pkt_round = to_write % max_transfer;
+
+		/*
+		 * Round the write down to an
+		 * exact number of packets.
+		 *
+		 * Note, we do not currently check to see if we can ever
+		 * write a full packet or not to the FIFO.
+		 */
+
+		if (pkt_round)
+			to_write -= pkt_round;
+
+		/*
+		 * enable correct FIFO interrupt to alert us when there
+		 * is more room left.
+		 */
+
+		/* it's needed only when we do not use dedicated fifos */
+		if (!dwc2->s3c_hsotg->dedicated_fifos)
+			s3c_hsotg_en_gsint(dwc2,
+					   periodic ? GINTSTS_PTXFEMP :
+					   GINTSTS_NPTXFEMP);
+	}
+
+	dev_dbg(dwc2->dev, "write %d/%d, can_write %d, done %d\n",
+		 to_write, hs_req->req.length, can_write, buf_pos);
+
+	if (to_write <= 0)
+		return -ENOSPC;
+
+	hs_req->req.actual = buf_pos + to_write;
+	hs_ep->total_data += to_write;
+
+	if (periodic)
+		hs_ep->fifo_load += to_write;
+
+	to_write = DIV_ROUND_UP(to_write, 4);
+	data = hs_req->req.buf + buf_pos;
+
+	writesl(dwc2->regs + EPFIFO(hs_ep->index), data, to_write);
+
+	return (to_write >= can_write) ? -ENOSPC : 0;
+}
+
+/**
+ * get_ep_limit - get the maximum data legnth for this endpoint
+ * @hs_ep: The endpoint
+ *
+ * Return the maximum data that can be queued in one go on a given endpoint
+ * so that transfers that are too long can be split.
+ */
+static unsigned get_ep_limit(struct s3c_hsotg_ep *hs_ep)
+{
+	int index = hs_ep->index;
+	unsigned maxsize;
+	unsigned maxpkt;
+
+	if (index != 0) {
+		maxsize = DXEPTSIZ_XFERSIZE_LIMIT + 1;
+		maxpkt = DXEPTSIZ_PKTCNT_LIMIT + 1;
+	} else {
+		maxsize = 64+64;
+		if (hs_ep->dir_in)
+			maxpkt = DIEPTSIZ0_PKTCNT_LIMIT + 1;
+		else
+			maxpkt = 2;
+	}
+
+	/* we made the constant loading easier above by using +1 */
+	maxpkt--;
+	maxsize--;
+
+	/*
+	 * constrain by packet count if maxpkts*pktsize is greater
+	 * than the length register size.
+	 */
+
+	if ((maxpkt * hs_ep->ep.maxpacket) < maxsize)
+		maxsize = maxpkt * hs_ep->ep.maxpacket;
+
+	return maxsize;
+}
+
+/**
+ * s3c_hsotg_start_req - start a USB request from an endpoint's queue
+ * @hsotg: The controller state.
+ * @hs_ep: The endpoint to process a request for
+ * @hs_req: The request to start.
+ * @continuing: True if we are doing more for the current request.
+ *
+ * Start the given request running by setting the endpoint registers
+ * appropriately, and writing any data to the FIFOs.
+ */
+static void s3c_hsotg_start_req(struct dwc2_hsotg *dwc2,
+				struct s3c_hsotg_ep *hs_ep,
+				struct s3c_hsotg_req *hs_req,
+				bool continuing)
+{
+	struct usb_request *ureq = &hs_req->req;
+	int index = hs_ep->index;
+	int dir_in = hs_ep->dir_in;
+	u32 epctrl_reg;
+	u32 epsize_reg;
+	u32 epsize;
+	u32 ctrl;
+	unsigned length;
+	unsigned packets;
+	unsigned maxreq;
+
+	if (index != 0) {
+		if (hs_ep->req && !continuing) {
+			dev_err(dwc2->dev, "%s: active request\n", __func__);
+			WARN_ON(1);
+			return;
+		} else if (hs_ep->req != hs_req && continuing) {
+			dev_err(dwc2->dev,
+				"%s: continue different req\n", __func__);
+			WARN_ON(1);
+			return;
+		}
+	}
+
+	epctrl_reg = dir_in ? DIEPCTL(index) : DOEPCTL(index);
+	epsize_reg = dir_in ? DIEPTSIZ(index) : DOEPTSIZ(index);
+
+	dev_dbg(dwc2->dev, "%s: DXEPCTL=0x%08x, ep %d, dir %s\n",
+		__func__, readl(dwc2->regs + epctrl_reg), index,
+		hs_ep->dir_in ? "in" : "out");
+
+	/* If endpoint is stalled, we will restart request later */
+	ctrl = readl(dwc2->regs + epctrl_reg);
+
+	if (ctrl & DXEPCTL_STALL) {
+		dev_warn(dwc2->dev, "%s: ep%d is stalled\n", __func__, index);
+		return;
+	}
+
+	length = ureq->length - ureq->actual;
+	dev_dbg(dwc2->dev, "ureq->length:%d ureq->actual:%d\n",
+		ureq->length, ureq->actual);
+	if (0)
+		dev_dbg(dwc2->dev,
+			"REQ buf %p len %d dma 0x%08x noi=%d zp=%d snok=%d\n",
+			ureq->buf, length, ureq->dma,
+			ureq->no_interrupt, ureq->zero, ureq->short_not_ok);
+
+	maxreq = get_ep_limit(hs_ep);
+	if (length > maxreq) {
+		int round = maxreq % hs_ep->ep.maxpacket;
+
+		dev_dbg(dwc2->dev, "%s: length %d, max-req %d, r %d\n",
+			__func__, length, maxreq, round);
+
+		/* round down to multiple of packets */
+		if (round)
+			maxreq -= round;
+
+		length = maxreq;
+	}
+
+	if (length)
+		packets = DIV_ROUND_UP(length, hs_ep->ep.maxpacket);
+	else
+		packets = 1;	/* send one packet if length is zero. */
+
+	if (hs_ep->isochronous && length > (hs_ep->mc * hs_ep->ep.maxpacket)) {
+		dev_err(dwc2->dev, "req length > maxpacket*mc\n");
+		return;
+	}
+
+	if (dir_in && index != 0)
+		if (hs_ep->isochronous)
+			epsize = DXEPTSIZ_MC(packets);
+		else
+			epsize = DXEPTSIZ_MC(1);
+	else
+		epsize = 0;
+
+	if (index != 0 && ureq->zero) {
+		/*
+		 * test for the packets being exactly right for the
+		 * transfer
+		 */
+
+		if (length == (packets * hs_ep->ep.maxpacket))
+			packets++;
+	}
+
+	epsize |= DXEPTSIZ_PKTCNT(packets);
+	epsize |= DXEPTSIZ_XFERSIZE(length);
+
+	dev_dbg(dwc2->dev, "%s: %d@%d/%d, 0x%08x => 0x%08x\n",
+		__func__, packets, length, ureq->length, epsize, epsize_reg);
+
+	/* store the request as the current one we're doing */
+	hs_ep->req = hs_req;
+
+	/* write size / packets */
+	writel(epsize, dwc2->regs + epsize_reg);
+
+	if (using_dma(dwc2->s3c_hsotg) && !continuing) {
+		unsigned int dma_reg;
+
+		/*
+		 * write DMA address to control register, buffer already
+		 * synced by s3c_hsotg_ep_queue().
+		 */
+
+		dma_reg = dir_in ? DIEPDMA(index) : DOEPDMA(index);
+		writel(ureq->dma, dwc2->regs + dma_reg);
+
+		dev_dbg(dwc2->dev, "%s: 0x%08x => 0x%08x\n",
+			__func__, ureq->dma, dma_reg);
+	}
+
+	ctrl |= DXEPCTL_EPENA;	/* ensure ep enabled */
+	ctrl |= DXEPCTL_USBACTEP;
+
+	dev_dbg(dwc2->dev, "setup req:%d\n", dwc2->s3c_hsotg->setup);
+
+	/* For Setup request do not clear NAK */
+	if (dwc2->s3c_hsotg->setup && index == 0)
+		dwc2->s3c_hsotg->setup = 0;
+	else
+		ctrl |= DXEPCTL_CNAK;	/* clear NAK set by core */
+
+
+	dev_dbg(dwc2->dev, "%s: DXEPCTL=0x%08x\n", __func__, ctrl);
+	writel(ctrl, dwc2->regs + epctrl_reg);
+
+	/*
+	 * set these, it seems that DMA support increments past the end
+	 * of the packet buffer so we need to calculate the length from
+	 * this information.
+	 */
+	hs_ep->size_loaded = length;
+	hs_ep->last_load = ureq->actual;
+
+	if (dir_in && !using_dma(dwc2->s3c_hsotg)) {
+		/* set these anyway, we may need them for non-periodic in */
+		hs_ep->fifo_load = 0;
+
+		s3c_hsotg_write_fifo(dwc2, hs_ep, hs_req);
+	}
+
+	/*
+	 * clear the INTknTXFEmpMsk when we start request, more as a aide
+	 * to debugging to see what is going on.
+	 */
+	if (dir_in)
+		writel(DIEPMSK_INTKNTXFEMPMSK,
+		       dwc2->regs + DIEPINT(index));
+
+	/*
+	 * Note, trying to clear the NAK here causes problems with transmit
+	 * on the S3C6400 ending up with the TXFIFO becoming full.
+	 */
+
+	/* check ep is enabled */
+	if (!(readl(dwc2->regs + epctrl_reg) & DXEPCTL_EPENA))
+		dev_warn(dwc2->dev,
+			 "ep%d: failed to become enabled (DXEPCTL=0x%08x)?\n",
+			 index, readl(dwc2->regs + epctrl_reg));
+
+	dev_dbg(dwc2->dev, "%s: DXEPCTL=0x%08x\n",
+		__func__, readl(dwc2->regs + epctrl_reg));
+
+	/* enable ep interrupts */
+	s3c_hsotg_ctrl_epint(dwc2, hs_ep->index, hs_ep->dir_in, 1);
+}
+
+/**
+ * s3c_hsotg_map_dma - map the DMA memory being used for the request
+ * @hsotg: The device state.
+ * @hs_ep: The endpoint the request is on.
+ * @req: The request being processed.
+ *
+ * We've been asked to queue a request, so ensure that the memory buffer
+ * is correctly setup for DMA. If we've been passed an extant DMA address
+ * then ensure the buffer has been synced to memory. If our buffer has no
+ * DMA memory, then we map the memory and mark our request to allow us to
+ * cleanup on completion.
+ */
+static int s3c_hsotg_map_dma(struct dwc2_hsotg *dwc2,
+			     struct s3c_hsotg_ep *hs_ep,
+			     struct usb_request *req)
+{
+	struct s3c_hsotg_req *hs_req = our_req(req);
+	int ret;
+
+	/* if the length is zero, ignore the DMA data */
+	if (hs_req->req.length == 0)
+		return 0;
+
+	ret = usb_gadget_map_request(&dwc2->gadget, req, hs_ep->dir_in);
+	if (ret)
+		goto dma_error;
+
+	return 0;
+
+dma_error:
+	dev_err(dwc2->dev, "%s: failed to map buffer %p, %d bytes\n",
+		__func__, req->buf, req->length);
+
+	return -EIO;
+}
+
+static int s3c_hsotg_ep_queue(struct usb_ep *ep, struct usb_request *req,
+			      gfp_t gfp_flags)
+{
+	struct s3c_hsotg_req *hs_req = our_req(req);
+	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
+	struct dwc2_hsotg *dwc2 = hs_ep->parent;
+	bool first;
+
+	dev_dbg(dwc2->dev, "%s: req %p: %d@%p, noi=%d, zero=%d, snok=%d\n",
+		ep->name, req, req->length, req->buf, req->no_interrupt,
+		req->zero, req->short_not_ok);
+
+	/* initialise status of the request */
+	INIT_LIST_HEAD(&hs_req->queue);
+	req->actual = 0;
+	req->status = -EINPROGRESS;
+
+	/* if we're using DMA, sync the buffers as necessary */
+	if (using_dma(dwc2->s3c_hsotg)) {
+		int ret = s3c_hsotg_map_dma(dwc2, hs_ep, req);
+		if (ret)
+			return ret;
+	}
+
+	first = list_empty(&hs_ep->queue);
+	list_add_tail(&hs_req->queue, &hs_ep->queue);
+
+	if (first)
+		s3c_hsotg_start_req(dwc2, hs_ep, hs_req, false);
+
+	return 0;
+}
+
+static int s3c_hsotg_ep_queue_lock(struct usb_ep *ep, struct usb_request *req,
+			      gfp_t gfp_flags)
+{
+	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
+	struct dwc2_hsotg *dwc2 = hs_ep->parent;
+	unsigned long flags = 0;
+	int ret = 0;
+
+	spin_lock_irqsave(&dwc2->lock, flags);
+	ret = s3c_hsotg_ep_queue(ep, req, gfp_flags);
+	spin_unlock_irqrestore(&dwc2->lock, flags);
+
+	return ret;
+}
+
+static void s3c_hsotg_ep_free_request(struct usb_ep *ep,
+				      struct usb_request *req)
+{
+	struct s3c_hsotg_req *hs_req = our_req(req);
+
+	kfree(hs_req);
+}
+
+/**
+ * s3c_hsotg_complete_oursetup - setup completion callback
+ * @ep: The endpoint the request was on.
+ * @req: The request completed.
+ *
+ * Called on completion of any requests the driver itself
+ * submitted that need cleaning up.
+ */
+static void s3c_hsotg_complete_oursetup(struct usb_ep *ep,
+					struct usb_request *req)
+{
+	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
+	struct dwc2_hsotg *dwc2 = hs_ep->parent;
+
+	dev_dbg(dwc2->dev, "%s: ep %p, req %p\n", __func__, ep, req);
+
+	s3c_hsotg_ep_free_request(ep, req);
+}
+
+/**
+ * ep_from_windex - convert control wIndex value to endpoint
+ * @hsotg: The driver state.
+ * @windex: The control request wIndex field (in host order).
+ *
+ * Convert the given wIndex into a pointer to an driver endpoint
+ * structure, or return NULL if it is not a valid endpoint.
+ */
+static struct s3c_hsotg_ep *ep_from_windex(struct dwc2_hsotg *dwc2,
+					   u32 windex)
+{
+	struct s3c_hsotg_ep *ep = &dwc2->eps[windex & 0x7F];
+	int dir = (windex & USB_DIR_IN) ? 1 : 0;
+	int idx = windex & 0x7F;
+
+	if (windex >= 0x100)
+		return NULL;
+
+	if (idx > dwc2->s3c_hsotg->num_of_eps)
+		return NULL;
+
+	if (idx && ep->dir_in != dir)
+		return NULL;
+
+	return ep;
+}
+
+/**
+ * s3c_hsotg_send_reply - send reply to control request
+ * @hsotg: The device state
+ * @ep: Endpoint 0
+ * @buff: Buffer for request
+ * @length: Length of reply.
+ *
+ * Create a request and queue it on the given endpoint. This is useful as
+ * an internal method of sending replies to certain control requests, etc.
+ */
+static int s3c_hsotg_send_reply(struct dwc2_hsotg *dwc2,
+				struct s3c_hsotg_ep *ep,
+				void *buff,
+				int length)
+{
+	struct usb_request *req;
+	int ret;
+
+	dev_dbg(dwc2->dev, "%s: buff %p, len %d\n", __func__, buff, length);
+
+	req = s3c_hsotg_ep_alloc_request(&ep->ep, GFP_ATOMIC);
+	dwc2->s3c_hsotg->ep0_reply = req;
+	if (!req) {
+		dev_warn(dwc2->dev, "%s: cannot alloc req\n", __func__);
+		return -ENOMEM;
+	}
+
+	req->buf = dwc2->s3c_hsotg->ep0_buff;
+	req->length = length;
+	req->zero = 1; /* always do zero-length final transfer */
+	req->complete = s3c_hsotg_complete_oursetup;
+
+	if (length)
+		memcpy(req->buf, buff, length);
+	else
+		ep->sent_zlp = 1;
+
+	ret = s3c_hsotg_ep_queue(&ep->ep, req, GFP_ATOMIC);
+	if (ret) {
+		dev_warn(dwc2->dev, "%s: cannot queue req\n", __func__);
+		return ret;
+	}
+
+	return 0;
+}
+
+/**
+ * s3c_hsotg_process_req_status - process request GET_STATUS
+ * @hsotg: The device state
+ * @ctrl: USB control request
+ */
+static int s3c_hsotg_process_req_status(struct dwc2_hsotg *dwc2,
+					struct usb_ctrlrequest *ctrl)
+{
+	struct s3c_hsotg_ep *ep0 = &dwc2->eps[0];
+	struct s3c_hsotg_ep *ep;
+	__le16 reply;
+	int ret;
+
+	dev_dbg(dwc2->dev, "%s: USB_REQ_GET_STATUS\n", __func__);
+
+	if (!ep0->dir_in) {
+		dev_warn(dwc2->dev, "%s: direction out?\n", __func__);
+		return -EINVAL;
+	}
+
+	switch (ctrl->bRequestType & USB_RECIP_MASK) {
+	case USB_RECIP_DEVICE:
+		reply = cpu_to_le16(0); /* bit 0 => self powered,
+					 * bit 1 => remote wakeup */
+		break;
+
+	case USB_RECIP_INTERFACE:
+		/* currently, the data result should be zero */
+		reply = cpu_to_le16(0);
+		break;
+
+	case USB_RECIP_ENDPOINT:
+		ep = ep_from_windex(dwc2, le16_to_cpu(ctrl->wIndex));
+		if (!ep)
+			return -ENOENT;
+
+		reply = cpu_to_le16(ep->halted ? 1 : 0);
+		break;
+
+	default:
+		return 0;
+	}
+
+	if (le16_to_cpu(ctrl->wLength) != 2)
+		return -EINVAL;
+
+	ret = s3c_hsotg_send_reply(dwc2, ep0, &reply, 2);
+	if (ret) {
+		dev_err(dwc2->dev, "%s: failed to send reply\n", __func__);
+		return ret;
+	}
+
+	return 1;
+}
+
+static int s3c_hsotg_ep_sethalt(struct usb_ep *ep, int value);
+
+/**
+ * get_ep_head - return the first request on the endpoint
+ * @hs_ep: The controller endpoint to get
+ *
+ * Get the first request on the endpoint.
+ */
+static struct s3c_hsotg_req *get_ep_head(struct s3c_hsotg_ep *hs_ep)
+{
+	if (list_empty(&hs_ep->queue))
+		return NULL;
+
+	return list_first_entry(&hs_ep->queue, struct s3c_hsotg_req, queue);
+}
+
+/**
+ * s3c_hsotg_process_req_featire - process request {SET,CLEAR}_FEATURE
+ * @hsotg: The device state
+ * @ctrl: USB control request
+ */
+static int s3c_hsotg_process_req_feature(struct dwc2_hsotg *dwc2,
+					 struct usb_ctrlrequest *ctrl)
+{
+	struct s3c_hsotg_ep *ep0 = &dwc2->eps[0];
+	struct s3c_hsotg_req *hs_req;
+	bool restart;
+	bool set = (ctrl->bRequest == USB_REQ_SET_FEATURE);
+	struct s3c_hsotg_ep *ep;
+	int ret;
+	bool halted;
+
+	dev_dbg(dwc2->dev, "%s: %s_FEATURE\n",
+		__func__, set ? "SET" : "CLEAR");
+
+	if (ctrl->bRequestType == USB_RECIP_ENDPOINT) {
+		ep = ep_from_windex(dwc2, le16_to_cpu(ctrl->wIndex));
+		if (!ep) {
+			dev_dbg(dwc2->dev, "%s: no endpoint for 0x%04x\n",
+				__func__, le16_to_cpu(ctrl->wIndex));
+			return -ENOENT;
+		}
+
+		switch (le16_to_cpu(ctrl->wValue)) {
+		case USB_ENDPOINT_HALT:
+			halted = ep->halted;
+
+			s3c_hsotg_ep_sethalt(&ep->ep, set);
+
+			ret = s3c_hsotg_send_reply(dwc2, ep0, NULL, 0);
+			if (ret) {
+				dev_err(dwc2->dev,
+					"%s: failed to send reply\n", __func__);
+				return ret;
+			}
+
+			/*
+			 * we have to complete all requests for ep if it was
+			 * halted, and the halt was cleared by CLEAR_FEATURE
+			 */
+
+			if (!set && halted) {
+				/*
+				 * If we have request in progress,
+				 * then complete it
+				 */
+				if (ep->req) {
+					hs_req = ep->req;
+					ep->req = NULL;
+					list_del_init(&hs_req->queue);
+					hs_req->req.complete(&ep->ep,
+							     &hs_req->req);
+				}
+
+				/* If we have pending request, then start it */
+				restart = !list_empty(&ep->queue);
+				if (restart) {
+					hs_req = get_ep_head(ep);
+					s3c_hsotg_start_req(dwc2, ep,
+							    hs_req, false);
+				}
+			}
+
+			break;
+
+		default:
+			return -ENOENT;
+		}
+	} else
+		return -ENOENT;  /* currently only deal with endpoint */
+
+	return 1;
+}
+
+static void s3c_hsotg_enqueue_setup(struct dwc2_hsotg *dwc2);
+
+/**
+ * s3c_hsotg_process_control - process a control request
+ * @hsotg: The device state
+ * @ctrl: The control request received
+ *
+ * The controller has received the SETUP phase of a control request, and
+ * needs to work out what to do next (and whether to pass it on to the
+ * gadget driver).
+ */
+static void s3c_hsotg_process_control(struct dwc2_hsotg *dwc2,
+				      struct usb_ctrlrequest *ctrl)
+{
+	struct s3c_hsotg_ep *ep0 = &dwc2->eps[0];
+	int ret = 0;
+	u32 dcfg;
+
+	ep0->sent_zlp = 0;
+
+	dev_dbg(dwc2->dev, "ctrl Req=%02x, Type=%02x, V=%04x, L=%04x\n",
+		 ctrl->bRequest, ctrl->bRequestType,
+		 ctrl->wValue, ctrl->wLength);
+
+	/*
+	 * record the direction of the request, for later use when enquing
+	 * packets onto EP0.
+	 */
+
+	ep0->dir_in = (ctrl->bRequestType & USB_DIR_IN) ? 1 : 0;
+	dev_dbg(dwc2->dev, "ctrl: dir_in=%d\n", ep0->dir_in);
+
+	/*
+	 * if we've no data with this request, then the last part of the
+	 * transaction is going to implicitly be IN.
+	 */
+	if (ctrl->wLength == 0)
+		ep0->dir_in = 1;
+
+	if ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {
+		switch (ctrl->bRequest) {
+		case USB_REQ_SET_ADDRESS:
+			s3c_hsotg_disconnect(dwc2);
+			dcfg = readl(dwc2->regs + DCFG);
+			dcfg &= ~DCFG_DEVADDR_MASK;
+			dcfg |= ctrl->wValue << DCFG_DEVADDR_SHIFT;
+			writel(dcfg, dwc2->regs + DCFG);
+
+			dev_info(dwc2->dev, "new address %d\n", ctrl->wValue);
+
+			ret = s3c_hsotg_send_reply(dwc2, ep0, NULL, 0);
+			return;
+
+		case USB_REQ_GET_STATUS:
+			ret = s3c_hsotg_process_req_status(dwc2, ctrl);
+			break;
+
+		case USB_REQ_CLEAR_FEATURE:
+		case USB_REQ_SET_FEATURE:
+			ret = s3c_hsotg_process_req_feature(dwc2, ctrl);
+			break;
+		}
+	}
+
+	/* as a fallback, try delivering it to the driver to deal with */
+
+	if (ret == 0 && dwc2->driver) {
+		spin_unlock(&dwc2->lock);
+		ret = dwc2->driver->setup(&dwc2->gadget, ctrl);
+		spin_lock(&dwc2->lock);
+		if (ret < 0)
+			dev_dbg(dwc2->dev, "driver->setup() ret %d\n", ret);
+	}
+
+	/*
+	 * the request is either unhandlable, or is not formatted correctly
+	 * so respond with a STALL for the status stage to indicate failure.
+	 */
+
+	if (ret < 0) {
+		u32 reg;
+		u32 ctrl;
+
+		dev_dbg(dwc2->dev, "ep0 stall (dir=%d)\n", ep0->dir_in);
+		reg = (ep0->dir_in) ? DIEPCTL0 : DOEPCTL0;
+
+		/*
+		 * DXEPCTL_Stall will be cleared by EP once it has
+		 * taken effect, so no need to clear later.
+		 */
+
+		ctrl = readl(dwc2->regs + reg);
+		ctrl |= DXEPCTL_STALL;
+		ctrl |= DXEPCTL_CNAK;
+		writel(ctrl, dwc2->regs + reg);
+
+		dev_dbg(dwc2->dev,
+			"written DXEPCTL=0x%08x to %08x (DXEPCTL=0x%08x)\n",
+			ctrl, reg, readl(dwc2->regs + reg));
+
+		/*
+		 * don't believe we need to anything more to get the EP
+		 * to reply with a STALL packet
+		 */
+
+		 /*
+		  * complete won't be called, so we enqueue
+		  * setup request here
+		  */
+		 s3c_hsotg_enqueue_setup(dwc2);
+	}
+}
+
+/**
+ * s3c_hsotg_complete_setup - completion of a setup transfer
+ * @ep: The endpoint the request was on.
+ * @req: The request completed.
+ *
+ * Called on completion of any requests the driver itself submitted for
+ * EP0 setup packets
+ */
+static void s3c_hsotg_complete_setup(struct usb_ep *ep,
+				     struct usb_request *req)
+{
+	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
+	struct dwc2_hsotg *dwc2 = hs_ep->parent;
+
+	if (req->status < 0) {
+		dev_dbg(dwc2->dev, "%s: failed %d\n", __func__, req->status);
+		return;
+	}
+
+	spin_lock(&dwc2->lock);
+	if (req->actual == 0)
+		s3c_hsotg_enqueue_setup(dwc2);
+	else
+		s3c_hsotg_process_control(dwc2, req->buf);
+	spin_unlock(&dwc2->lock);
+}
+
+/**
+ * s3c_hsotg_enqueue_setup - start a request for EP0 packets
+ * @hsotg: The device state.
+ *
+ * Enqueue a request on EP0 if necessary to received any SETUP packets
+ * received from the host.
+ */
+static void s3c_hsotg_enqueue_setup(struct dwc2_hsotg *dwc2)
+{
+	struct usb_request *req = dwc2->s3c_hsotg->ctrl_req;
+	struct s3c_hsotg_req *hs_req = our_req(req);
+	int ret;
+
+	dev_dbg(dwc2->dev, "%s: queueing setup request\n", __func__);
+
+	req->zero = 0;
+	req->length = 8;
+	req->buf = dwc2->s3c_hsotg->ctrl_buff;
+	req->complete = s3c_hsotg_complete_setup;
+
+	if (!list_empty(&hs_req->queue)) {
+		dev_dbg(dwc2->dev, "%s already queued???\n", __func__);
+		return;
+	}
+
+	dwc2->eps[0].dir_in = 0;
+
+	ret = s3c_hsotg_ep_queue(&dwc2->eps[0].ep, req, GFP_ATOMIC);
+	if (ret < 0) {
+		dev_err(dwc2->dev, "%s: failed queue (%d)\n", __func__, ret);
+		/*
+		 * Don't think there's much we can do other than watch the
+		 * driver fail.
+		 */
+	}
+}
+
+/**
+ * s3c_hsotg_complete_request - complete a request given to us
+ * @hsotg: The device state.
+ * @hs_ep: The endpoint the request was on.
+ * @hs_req: The request to complete.
+ * @result: The result code (0 => Ok, otherwise errno)
+ *
+ * The given request has finished, so call the necessary completion
+ * if it has one and then look to see if we can start a new request
+ * on the endpoint.
+ *
+ * Note, expects the ep to already be locked as appropriate.
+ */
+static void s3c_hsotg_complete_request(struct dwc2_hsotg *dwc2,
+				       struct s3c_hsotg_ep *hs_ep,
+				       struct s3c_hsotg_req *hs_req,
+				       int result)
+{
+	bool restart;
+
+	if (!hs_req) {
+		dev_dbg(dwc2->dev, "%s: nothing to complete?\n", __func__);
+		return;
+	}
+
+	dev_dbg(dwc2->dev, "complete: ep %p %s, req %p, %d => %p\n",
+		hs_ep, hs_ep->ep.name, hs_req, result, hs_req->req.complete);
+
+	/*
+	 * only replace the status if we've not already set an error
+	 * from a previous transaction
+	 */
+
+	if (hs_req->req.status == -EINPROGRESS)
+		hs_req->req.status = result;
+
+	hs_ep->req = NULL;
+	list_del_init(&hs_req->queue);
+
+	if (using_dma(dwc2->s3c_hsotg))
+		s3c_hsotg_unmap_dma(dwc2, hs_ep, hs_req);
+
+	/*
+	 * call the complete request with the locks off, just in case the
+	 * request tries to queue more work for this endpoint.
+	 */
+
+	if (hs_req->req.complete) {
+		spin_unlock(&dwc2->lock);
+		hs_req->req.complete(&hs_ep->ep, &hs_req->req);
+		spin_lock(&dwc2->lock);
+	}
+
+	/*
+	 * Look to see if there is anything else to do. Note, the completion
+	 * of the previous request may have caused a new request to be started
+	 * so be careful when doing this.
+	 */
+
+	if (!hs_ep->req && result >= 0) {
+		restart = !list_empty(&hs_ep->queue);
+		if (restart) {
+			hs_req = get_ep_head(hs_ep);
+			s3c_hsotg_start_req(dwc2, hs_ep, hs_req, false);
+		}
+	}
+}
+
+/**
+ * s3c_hsotg_rx_data - receive data from the FIFO for an endpoint
+ * @hsotg: The device state.
+ * @ep_idx: The endpoint index for the data
+ * @size: The size of data in the fifo, in bytes
+ *
+ * The FIFO status shows there is data to read from the FIFO for a given
+ * endpoint, so sort out whether we need to read the data into a request
+ * that has been made for that endpoint.
+ */
+static void s3c_hsotg_rx_data(struct dwc2_hsotg *dwc2, int ep_idx, int size)
+{
+	struct s3c_hsotg_ep *hs_ep = &dwc2->eps[ep_idx];
+	struct s3c_hsotg_req *hs_req = hs_ep->req;
+	void __iomem *fifo = dwc2->regs + EPFIFO(ep_idx);
+	int to_read;
+	int max_req;
+	int read_ptr;
+
+
+	if (!hs_req) {
+		u32 epctl = readl(dwc2->regs + DOEPCTL(ep_idx));
+		int ptr;
+
+		dev_warn(dwc2->dev,
+			 "%s: FIFO %d bytes on ep%d but no req (DXEPCTl=0x%08x)\n",
+			 __func__, size, ep_idx, epctl);
+
+		/* dump the data from the FIFO, we've nothing we can do */
+		for (ptr = 0; ptr < size; ptr += 4)
+			(void)readl(fifo);
+
+		return;
+	}
+
+	to_read = size;
+	read_ptr = hs_req->req.actual;
+	max_req = hs_req->req.length - read_ptr;
+
+	dev_dbg(dwc2->dev, "%s: read %d/%d, done %d/%d\n",
+		__func__, to_read, max_req, read_ptr, hs_req->req.length);
+
+	if (to_read > max_req) {
+		/*
+		 * more data appeared than we where willing
+		 * to deal with in this request.
+		 */
+
+		/* currently we don't deal this */
+		WARN_ON_ONCE(1);
+	}
+
+	hs_ep->total_data += to_read;
+	hs_req->req.actual += to_read;
+	to_read = DIV_ROUND_UP(to_read, 4);
+
+	/*
+	 * note, we might over-write the buffer end by 3 bytes depending on
+	 * alignment of the data.
+	 */
+	readsl(fifo, hs_req->req.buf + read_ptr, to_read);
+}
+
+/**
+ * s3c_hsotg_send_zlp - send zero-length packet on control endpoint
+ * @hsotg: The device instance
+ * @req: The request currently on this endpoint
+ *
+ * Generate a zero-length IN packet request for terminating a SETUP
+ * transaction.
+ *
+ * Note, since we don't write any data to the TxFIFO, then it is
+ * currently believed that we do not need to wait for any space in
+ * the TxFIFO.
+ */
+static void s3c_hsotg_send_zlp(struct dwc2_hsotg *dwc2,
+			       struct s3c_hsotg_req *req)
+{
+	u32 ctrl;
+
+	if (!req) {
+		dev_warn(dwc2->dev, "%s: no request?\n", __func__);
+		return;
+	}
+
+	if (req->req.length == 0) {
+		dwc2->eps[0].sent_zlp = 1;
+		s3c_hsotg_enqueue_setup(dwc2);
+		return;
+	}
+
+	dwc2->eps[0].dir_in = 1;
+	dwc2->eps[0].sent_zlp = 1;
+
+	dev_dbg(dwc2->dev, "sending zero-length packet\n");
+
+	/* issue a zero-sized packet to terminate this */
+	writel(DXEPTSIZ_MC(1) | DXEPTSIZ_PKTCNT(1) |
+	       DXEPTSIZ_XFERSIZE(0), dwc2->regs + DIEPTSIZ(0));
+
+	ctrl = readl(dwc2->regs + DIEPCTL0);
+	ctrl |= DXEPCTL_CNAK;  /* clear NAK set by core */
+	ctrl |= DXEPCTL_EPENA; /* ensure ep enabled */
+	ctrl |= DXEPCTL_USBACTEP;
+	writel(ctrl, dwc2->regs + DIEPCTL0);
+}
+
+/**
+ * s3c_hsotg_handle_outdone - handle receiving OutDone/SetupDone from RXFIFO
+ * @hsotg: The device instance
+ * @epnum: The endpoint received from
+ * @was_setup: Set if processing a SetupDone event.
+ *
+ * The RXFIFO has delivered an OutDone event, which means that the data
+ * transfer for an OUT endpoint has been completed, either by a short
+ * packet or by the finish of a transfer.
+ */
+static void s3c_hsotg_handle_outdone(struct dwc2_hsotg *dwc2,
+				     int epnum, bool was_setup)
+{
+	u32 epsize = readl(dwc2->regs + DOEPTSIZ(epnum));
+	struct s3c_hsotg_ep *hs_ep = &dwc2->eps[epnum];
+	struct s3c_hsotg_req *hs_req = hs_ep->req;
+	struct usb_request *req = &hs_req->req;
+	unsigned size_left = DXEPTSIZ_XFERSIZE_GET(epsize);
+	int result = 0;
+
+	if (!hs_req) {
+		dev_dbg(dwc2->dev, "%s: no request active\n", __func__);
+		return;
+	}
+
+	if (using_dma(dwc2->s3c_hsotg)) {
+		unsigned size_done;
+
+		/*
+		 * Calculate the size of the transfer by checking how much
+		 * is left in the endpoint size register and then working it
+		 * out from the amount we loaded for the transfer.
+		 *
+		 * We need to do this as DMA pointers are always 32bit aligned
+		 * so may overshoot/undershoot the transfer.
+		 */
+
+		size_done = hs_ep->size_loaded - size_left;
+		size_done += hs_ep->last_load;
+
+		req->actual = size_done;
+	}
+
+	/* if there is more request to do, schedule new transfer */
+	if (req->actual < req->length && size_left == 0) {
+		s3c_hsotg_start_req(dwc2, hs_ep, hs_req, true);
+		return;
+	} else if (epnum == 0) {
+		/*
+		 * After was_setup = 1 =>
+		 * set CNAK for non Setup requests
+		 */
+		dwc2->s3c_hsotg->setup = was_setup ? 0 : 1;
+	}
+
+	if (req->actual < req->length && req->short_not_ok) {
+		dev_dbg(dwc2->dev, "%s: got %d/%d (short not ok) => error\n",
+			__func__, req->actual, req->length);
+
+		/*
+		 * todo - what should we return here? there's no one else
+		 * even bothering to check the status.
+		 */
+	}
+
+	if (epnum == 0) {
+		/*
+		 * Condition req->complete != s3c_hsotg_complete_setup says:
+		 * send ZLP when we have an asynchronous request from gadget
+		 */
+		if (!was_setup && req->complete != s3c_hsotg_complete_setup)
+			s3c_hsotg_send_zlp(dwc2, hs_req);
+	}
+
+	s3c_hsotg_complete_request(dwc2, hs_ep, hs_req, result);
+}
+
+/**
+ * s3c_hsotg_read_frameno - read current frame number
+ * @hsotg: The device instance
+ *
+ * Return the current frame number
+ */
+static u32 s3c_hsotg_read_frameno(struct dwc2_hsotg *dwc2)
+{
+	u32 dsts;
+
+	dsts = readl(dwc2->regs + DSTS);
+	dsts &= DSTS_SOFFN_MASK;
+	dsts >>= DSTS_SOFFN_SHIFT;
+
+	return dsts;
+}
+
+/**
+ * s3c_hsotg_handle_rx - RX FIFO has data
+ * @hsotg: The device instance
+ *
+ * The IRQ handler has detected that the RX FIFO has some data in it
+ * that requires processing, so find out what is in there and do the
+ * appropriate read.
+ *
+ * The RXFIFO is a true FIFO, the packets coming out are still in packet
+ * chunks, so if you have x packets received on an endpoint you'll get x
+ * FIFO events delivered, each with a packet's worth of data in it.
+ *
+ * When using DMA, we should not be processing events from the RXFIFO
+ * as the actual data should be sent to the memory directly and we turn
+ * on the completion interrupts to get notifications of transfer completion.
+ */
+void s3c_hsotg_handle_rx(struct dwc2_hsotg *dwc2)
+{
+	u32 grxstsr = readl(dwc2->regs + GRXSTSP);
+	u32 epnum, status, size;
+
+	WARN_ON(using_dma(dwc2->s3c_hsotg));
+
+	epnum = grxstsr & GRXSTS_EPNUM_MASK;
+	status = grxstsr & GRXSTS_PKTSTS_MASK;
+
+	size = grxstsr & GRXSTS_BYTECNT_MASK;
+	size >>= GRXSTS_BYTECNT_SHIFT;
+
+	if (1)
+		dev_dbg(dwc2->dev, "%s: GRXSTSP=0x%08x (%d@%d)\n",
+			__func__, grxstsr, size, epnum);
+
+#define __status(x) ((x) >> GRXSTS_PKTSTS_SHIFT)
+
+	switch (status >> GRXSTS_PKTSTS_SHIFT) {
+	case __status(GRXSTS_PKTSTS_GLOBALOUTNAK):
+		dev_dbg(dwc2->dev, "GLOBALOUTNAK\n");
+		break;
+
+	case __status(GRXSTS_PKTSTS_OUTDONE):
+		dev_dbg(dwc2->dev, "OutDone (Frame=0x%08x)\n",
+			s3c_hsotg_read_frameno(dwc2));
+
+		if (!using_dma(dwc2->s3c_hsotg))
+			s3c_hsotg_handle_outdone(dwc2, epnum, false);
+		break;
+
+	case __status(GRXSTS_PKTSTS_SETUPDONE):
+		dev_dbg(dwc2->dev,
+			"SetupDone (Frame=0x%08x, DOPEPCTL=0x%08x)\n",
+			s3c_hsotg_read_frameno(dwc2),
+			readl(dwc2->regs + DOEPCTL(0)));
+
+		s3c_hsotg_handle_outdone(dwc2, epnum, true);
+		break;
+
+	case __status(GRXSTS_PKTSTS_OUTRX):
+		s3c_hsotg_rx_data(dwc2, epnum, size);
+		break;
+
+	case __status(GRXSTS_PKTSTS_SETUPRX):
+		dev_dbg(dwc2->dev,
+			"SetupRX (Frame=0x%08x, DOPEPCTL=0x%08x)\n",
+			s3c_hsotg_read_frameno(dwc2),
+			readl(dwc2->regs + DOEPCTL(0)));
+
+		s3c_hsotg_rx_data(dwc2, epnum, size);
+		break;
+
+	default:
+		dev_warn(dwc2->dev, "%s: unknown status %08x\n",
+			 __func__, grxstsr);
+
+		s3c_hsotg_dump(dwc2);
+		break;
+	}
+}
+
+/**
+ * s3c_hsotg_ep0_mps - turn max packet size into register setting
+ * @mps: The maximum packet size in bytes.
+ */
+static u32 s3c_hsotg_ep0_mps(unsigned int mps)
+{
+	switch (mps) {
+	case 64:
+		return D0EPCTL_MPS_64;
+	case 32:
+		return D0EPCTL_MPS_32;
+	case 16:
+		return D0EPCTL_MPS_16;
+	case 8:
+		return D0EPCTL_MPS_8;
+	}
+
+	/* bad max packet size, warn and return invalid result */
+	WARN_ON(1);
+	return (u32)-1;
+}
+
+/**
+ * s3c_hsotg_set_ep_maxpacket - set endpoint's max-packet field
+ * @hsotg: The driver state.
+ * @ep: The index number of the endpoint
+ * @mps: The maximum packet size in bytes
+ *
+ * Configure the maximum packet size for the given endpoint, updating
+ * the hardware control registers to reflect this.
+ */
+static void s3c_hsotg_set_ep_maxpacket(struct dwc2_hsotg *dwc2,
+				       unsigned int ep, unsigned int mps)
+{
+	struct s3c_hsotg_ep *hs_ep = &dwc2->eps[ep];
+	void __iomem *regs = dwc2->regs;
+	u32 mpsval;
+	u32 mcval;
+	u32 reg;
+
+	if (ep == 0) {
+		/* EP0 is a special case */
+		mpsval = s3c_hsotg_ep0_mps(mps);
+		if (mpsval > 3)
+			goto bad_mps;
+		hs_ep->ep.maxpacket = mps;
+		hs_ep->mc = 1;
+	} else {
+		mpsval = mps & DXEPCTL_MPS_MASK;
+		if (mpsval > 1024)
+			goto bad_mps;
+		mcval = ((mps >> 11) & 0x3) + 1;
+		hs_ep->mc = mcval;
+		if (mcval > 3)
+			goto bad_mps;
+		hs_ep->ep.maxpacket = mpsval;
+	}
+
+	/*
+	 * update both the in and out endpoint controldir_ registers, even
+	 * if one of the directions may not be in use.
+	 */
+
+	reg = readl(regs + DIEPCTL(ep));
+	reg &= ~DXEPCTL_MPS_MASK;
+	reg |= mpsval;
+	writel(reg, regs + DIEPCTL(ep));
+
+	if (ep) {
+		reg = readl(regs + DOEPCTL(ep));
+		reg &= ~DXEPCTL_MPS_MASK;
+		reg |= mpsval;
+		writel(reg, regs + DOEPCTL(ep));
+	}
+
+	return;
+
+bad_mps:
+	dev_err(dwc2->dev, "ep%d: bad mps of %d\n", ep, mps);
+}
+
+/**
+ * s3c_hsotg_txfifo_flush - flush Tx FIFO
+ * @hsotg: The driver state
+ * @idx: The index for the endpoint (0..15)
+ */
+static void s3c_hsotg_txfifo_flush(struct dwc2_hsotg *dwc2, unsigned int idx)
+{
+	int timeout;
+	int val;
+
+	writel(GRSTCTL_TXFNUM(idx) | GRSTCTL_TXFFLSH,
+		dwc2->regs + GRSTCTL);
+
+	/* wait until the fifo is flushed */
+	timeout = 100;
+
+	while (1) {
+		val = readl(dwc2->regs + GRSTCTL);
+
+		if ((val & (GRSTCTL_TXFFLSH)) == 0)
+			break;
+
+		if (--timeout == 0) {
+			dev_err(dwc2->dev,
+				"%s: timeout flushing fifo (GRSTCTL=%08x)\n",
+				__func__, val);
+		}
+
+		udelay(1);
+	}
+}
+
+/**
+ * s3c_hsotg_trytx - check to see if anything needs transmitting
+ * @hsotg: The driver state
+ * @hs_ep: The driver endpoint to check.
+ *
+ * Check to see if there is a request that has data to send, and if so
+ * make an attempt to write data into the FIFO.
+ */
+static int s3c_hsotg_trytx(struct dwc2_hsotg *dwc2,
+			   struct s3c_hsotg_ep *hs_ep)
+{
+	struct s3c_hsotg_req *hs_req = hs_ep->req;
+
+	if (!hs_ep->dir_in || !hs_req) {
+		/**
+		 * if request is not enqueued, we disable interrupts
+		 * for endpoints, excepting ep0
+		 */
+		if (hs_ep->index != 0)
+			s3c_hsotg_ctrl_epint(dwc2, hs_ep->index,
+					     hs_ep->dir_in, 0);
+		return 0;
+	}
+
+	if (hs_req->req.actual < hs_req->req.length) {
+		dev_dbg(dwc2->dev, "trying to write more for ep%d\n",
+			hs_ep->index);
+		return s3c_hsotg_write_fifo(dwc2, hs_ep, hs_req);
+	}
+
+	return 0;
+}
+
+/**
+ * s3c_hsotg_complete_in - complete IN transfer
+ * @hsotg: The device state.
+ * @hs_ep: The endpoint that has just completed.
+ *
+ * An IN transfer has been completed, update the transfer's state and then
+ * call the relevant completion routines.
+ */
+static void s3c_hsotg_complete_in(struct dwc2_hsotg *dwc2,
+				  struct s3c_hsotg_ep *hs_ep)
+{
+	struct s3c_hsotg_req *hs_req = hs_ep->req;
+	u32 epsize = readl(dwc2->regs + DIEPTSIZ(hs_ep->index));
+	int size_left, size_done;
+
+	if (!hs_req) {
+		dev_dbg(dwc2->dev, "XferCompl but no req\n");
+		return;
+	}
+
+	/* Finish ZLP handling for IN EP0 transactions */
+	if (dwc2->eps[0].sent_zlp) {
+		dev_dbg(dwc2->dev, "zlp packet received\n");
+		s3c_hsotg_complete_request(dwc2, hs_ep, hs_req, 0);
+		return;
+	}
+
+	/*
+	 * Calculate the size of the transfer by checking how much is left
+	 * in the endpoint size register and then working it out from
+	 * the amount we loaded for the transfer.
+	 *
+	 * We do this even for DMA, as the transfer may have incremented
+	 * past the end of the buffer (DMA transfers are always 32bit
+	 * aligned).
+	 */
+
+	size_left = DXEPTSIZ_XFERSIZE_GET(epsize);
+
+	size_done = hs_ep->size_loaded - size_left;
+	size_done += hs_ep->last_load;
+
+	if (hs_req->req.actual != size_done)
+		dev_dbg(dwc2->dev, "%s: adjusting size done %d => %d\n",
+			__func__, hs_req->req.actual, size_done);
+
+	hs_req->req.actual = size_done;
+	dev_dbg(dwc2->dev, "req->length:%d req->actual:%d req->zero:%d\n",
+		hs_req->req.length, hs_req->req.actual, hs_req->req.zero);
+
+	/*
+	 * Check if dealing with Maximum Packet Size(MPS) IN transfer at EP0
+	 * When sent data is a multiple MPS size (e.g. 64B ,128B ,192B
+	 * ,256B ... ), after last MPS sized packet send IN ZLP packet to
+	 * inform the host that no more data is available.
+	 * The state of req.zero member is checked to be sure that the value to
+	 * send is smaller than wValue expected from host.
+	 * Check req.length to NOT send another ZLP when the current one is
+	 * under completion (the one for which this completion has been called).
+	 */
+	if (hs_req->req.length && hs_ep->index == 0 && hs_req->req.zero &&
+	    hs_req->req.length == hs_req->req.actual &&
+	    !(hs_req->req.length % hs_ep->ep.maxpacket)) {
+
+		dev_dbg(dwc2->dev, "ep0 zlp IN packet sent\n");
+		s3c_hsotg_send_zlp(dwc2, hs_req);
+
+		return;
+	}
+
+	if (!size_left && hs_req->req.actual < hs_req->req.length) {
+		dev_dbg(dwc2->dev, "%s trying more for req...\n", __func__);
+		s3c_hsotg_start_req(dwc2, hs_ep, hs_req, true);
+	} else
+		s3c_hsotg_complete_request(dwc2, hs_ep, hs_req, 0);
+}
+
+/**
+ * s3c_hsotg_epint - handle an in/out endpoint interrupt
+ * @hsotg: The driver state
+ * @idx: The index for the endpoint (0..15)
+ * @dir_in: Set if this is an IN endpoint
+ *
+ * Process and clear any interrupt pending for an individual endpoint
+ */
+void s3c_hsotg_epint(struct dwc2_hsotg *dwc2, unsigned int idx,
+			    int dir_in)
+{
+	struct s3c_hsotg_ep *hs_ep = &dwc2->eps[idx];
+	u32 epint_reg = dir_in ? DIEPINT(idx) : DOEPINT(idx);
+	u32 epctl_reg = dir_in ? DIEPCTL(idx) : DOEPCTL(idx);
+	u32 epsiz_reg = dir_in ? DIEPTSIZ(idx) : DOEPTSIZ(idx);
+	u32 ints;
+	u32 ctrl;
+
+	ints = readl(dwc2->regs + epint_reg);
+	ctrl = readl(dwc2->regs + epctl_reg);
+
+	/* Clear endpoint interrupts */
+	writel(ints, dwc2->regs + epint_reg);
+
+	dev_dbg(dwc2->dev, "%s: ep%d(%s) DXEPINT=0x%08x\n",
+		__func__, idx, dir_in ? "in" : "out", ints);
+
+	if (ints & DXEPINT_XFERCOMPL) {
+		if (hs_ep->isochronous && hs_ep->interval == 1) {
+			if (ctrl & DXEPCTL_EOFRNUM)
+				ctrl |= DXEPCTL_SETEVENFR;
+			else
+				ctrl |= DXEPCTL_SETODDFR;
+			writel(ctrl, dwc2->regs + epctl_reg);
+		}
+
+		dev_dbg(dwc2->dev,
+			"%s: XferCompl: DXEPCTL=0x%08x, DXEPTSIZ=%08x\n",
+			__func__, readl(dwc2->regs + epctl_reg),
+			readl(dwc2->regs + epsiz_reg));
+
+		/*
+		 * we get OutDone from the FIFO, so we only need to look
+		 * at completing IN requests here
+		 */
+		if (dir_in) {
+			s3c_hsotg_complete_in(dwc2, hs_ep);
+
+			if (idx == 0 && !hs_ep->req)
+				s3c_hsotg_enqueue_setup(dwc2);
+		} else if (using_dma(dwc2->s3c_hsotg)) {
+			/*
+			 * We're using DMA, we need to fire an OutDone here
+			 * as we ignore the RXFIFO.
+			 */
+
+			s3c_hsotg_handle_outdone(dwc2, idx, false);
+		}
+	}
+
+	if (ints & DXEPINT_EPDISBLD) {
+		dev_dbg(dwc2->dev, "%s: EPDisbld\n", __func__);
+
+		if (dir_in) {
+			int epctl = readl(dwc2->regs + epctl_reg);
+
+			s3c_hsotg_txfifo_flush(dwc2, idx);
+
+			if ((epctl & DXEPCTL_STALL) &&
+				(epctl & DXEPCTL_EPTYPE_BULK)) {
+				int dctl = readl(dwc2->regs + DCTL);
+
+				dctl |= DCTL_CGNPINNAK;
+				writel(dctl, dwc2->regs + DCTL);
+			}
+		}
+	}
+
+	if (ints & DXEPINT_AHBERR)
+		dev_dbg(dwc2->dev, "%s: AHBErr\n", __func__);
+
+	if (ints & DXEPINT_SETUP) {  /* Setup or Timeout */
+		dev_dbg(dwc2->dev, "%s: Setup/Timeout\n",  __func__);
+
+		if (using_dma(dwc2->s3c_hsotg) && idx == 0) {
+			/*
+			 * this is the notification we've received a
+			 * setup packet. In non-DMA mode we'd get this
+			 * from the RXFIFO, instead we need to process
+			 * the setup here.
+			 */
+
+			if (dir_in)
+				WARN_ON_ONCE(1);
+			else
+				s3c_hsotg_handle_outdone(dwc2, 0, true);
+		}
+	}
+
+	if (ints & DXEPINT_BACK2BACKSETUP)
+		dev_dbg(dwc2->dev, "%s: B2BSetup/INEPNakEff\n", __func__);
+
+	if (dir_in && !hs_ep->isochronous) {
+		/* not sure if this is important, but we'll clear it anyway */
+		if (ints & DIEPMSK_INTKNTXFEMPMSK) {
+			dev_dbg(dwc2->dev, "%s: ep%d: INTKNTXFEMPMSK\n",
+				__func__, idx);
+		}
+
+		/* this probably means something bad is happening */
+		if (ints & DIEPMSK_INTKNEPMISMSK) {
+			dev_warn(dwc2->dev, "%s: ep%d: INTKNEP\n",
+				 __func__, idx);
+		}
+
+		/* FIFO has space or is empty (see GAHBCFG) */
+		if (dwc2->s3c_hsotg->dedicated_fifos &&
+		    ints & DIEPMSK_TXFIFOEMPTY) {
+			dev_dbg(dwc2->dev, "%s: ep%d: TXFIFOEMPTY\n",
+				__func__, idx);
+			if (!using_dma(dwc2->s3c_hsotg))
+				s3c_hsotg_trytx(dwc2, hs_ep);
+		}
+	}
+}
+
+/**
+ * s3c_hsotg_irq_enumdone - Handle EnumDone interrupt (enumeration done)
+ * @hsotg: The device state.
+ *
+ * Handle updating the device settings after the enumeration phase has
+ * been completed.
+ */
+void s3c_hsotg_irq_enumdone(struct dwc2_hsotg *dwc2)
+{
+	u32 dsts = readl(dwc2->regs + DSTS);
+	int ep0_mps = 0, ep_mps;
+
+	/*
+	 * This should signal the finish of the enumeration phase
+	 * of the USB handshaking, so we should now know what rate
+	 * we connected at.
+	 */
+
+	dev_dbg(dwc2->dev, "EnumDone (DSTS=0x%08x)\n", dsts);
+
+	/*
+	 * note, since we're limited by the size of transfer on EP0, and
+	 * it seems IN transfers must be a even number of packets we do
+	 * not advertise a 64byte MPS on EP0.
+	 */
+
+	/* catch both EnumSpd_FS and EnumSpd_FS48 */
+	switch (dsts & DSTS_ENUMSPD_MASK) {
+	case DSTS_ENUMSPD_FS:
+	case DSTS_ENUMSPD_FS48:
+		dwc2->gadget.speed = USB_SPEED_FULL;
+		ep0_mps = EP0_MPS_LIMIT;
+		ep_mps = 64;
+		break;
+
+	case DSTS_ENUMSPD_HS:
+		dwc2->gadget.speed = USB_SPEED_HIGH;
+		ep0_mps = EP0_MPS_LIMIT;
+		ep_mps = 512;
+		break;
+
+	case DSTS_ENUMSPD_LS:
+		dwc2->gadget.speed = USB_SPEED_LOW;
+		/*
+		 * note, we don't actually support LS in this driver at the
+		 * moment, and the documentation seems to imply that it isn't
+		 * supported by the PHYs on some of the devices.
+		 */
+		break;
+	}
+	dev_info(dwc2->dev, "new device is %s\n",
+		 usb_speed_string(dwc2->gadget.speed));
+
+	/*
+	 * we should now know the maximum packet size for an
+	 * endpoint, so set the endpoints to a default value.
+	 */
+
+	if (ep0_mps) {
+		int i;
+		s3c_hsotg_set_ep_maxpacket(dwc2, 0, ep0_mps);
+		for (i = 1; i < dwc2->s3c_hsotg->num_of_eps; i++)
+			s3c_hsotg_set_ep_maxpacket(dwc2, i, ep_mps);
+	}
+
+	/* ensure after enumeration our EP0 is active */
+
+	s3c_hsotg_enqueue_setup(dwc2);
+
+	dev_dbg(dwc2->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",
+		readl(dwc2->regs + DIEPCTL0),
+		readl(dwc2->regs + DOEPCTL0));
+}
+
+/**
+ * kill_all_requests - remove all requests from the endpoint's queue
+ * @hsotg: The device state.
+ * @ep: The endpoint the requests may be on.
+ * @result: The result code to use.
+ * @force: Force removal of any current requests
+ *
+ * Go through the requests on the given endpoint and mark them
+ * completed with the given result code.
+ */
+void kill_all_requests(struct dwc2_hsotg *dwc2,
+			      struct s3c_hsotg_ep *ep,
+			      int result, bool force)
+{
+	struct s3c_hsotg_req *req, *treq;
+
+	list_for_each_entry_safe(req, treq, &ep->queue, queue) {
+		/*
+		 * currently, we can't do much about an already
+		 * running request on an in endpoint
+		 */
+
+		if (ep->req == req && ep->dir_in && !force)
+			continue;
+
+		s3c_hsotg_complete_request(dwc2, ep, req,
+					   result);
+	}
+}
+
+/**
+ * s3c_hsotg_disconnect - disconnect service
+ * @hsotg: The device state.
+ *
+ * The device has been disconnected. Remove all current
+ * transactions and signal the gadget driver that this
+ * has happened.
+ */
+void s3c_hsotg_disconnect(struct dwc2_hsotg *dwc2)
+{
+	unsigned ep;
+
+	for (ep = 0; ep < dwc2->s3c_hsotg->num_of_eps; ep++)
+		kill_all_requests(dwc2, &dwc2->eps[ep], -ESHUTDOWN, true);
+
+	call_gadget(dwc2, disconnect);
+}
+
+/**
+ * s3c_hsotg_irq_fifoempty - TX FIFO empty interrupt handler
+ * @hsotg: The device state:
+ * @periodic: True if this is a periodic FIFO interrupt
+ */
+void s3c_hsotg_irq_fifoempty(struct dwc2_hsotg *dwc2, bool periodic)
+{
+	struct s3c_hsotg_ep *ep;
+	int epno, ret;
+
+	/* look through for any more data to transmit */
+
+	for (epno = 0; epno < dwc2->s3c_hsotg->num_of_eps; epno++) {
+		ep = &dwc2->eps[epno];
+
+		if (!ep->dir_in)
+			continue;
+
+		if ((periodic && !ep->periodic) ||
+		    (!periodic && ep->periodic))
+			continue;
+
+		ret = s3c_hsotg_trytx(dwc2, ep);
+		if (ret < 0)
+			break;
+	}
+}
+
+/* IRQ flags which will trigger a retry around the IRQ loop */
+#define IRQ_RETRY_MASK (GINTSTS_NPTXFEMP | \
+			GINTSTS_PTXFEMP |  \
+			GINTSTS_RXFLVL)
+
+/**
+ * s3c_hsotg_corereset - issue softreset to the core
+ * @hsotg: The device state
+ *
+ * Issue a soft reset to the core, and await the core finishing it.
+ */
+static int s3c_hsotg_corereset(struct dwc2_hsotg *dwc2)
+{
+	int timeout;
+	u32 grstctl;
+
+	dev_dbg(dwc2->dev, "resetting core\n");
+
+	/* issue soft reset */
+	writel(GRSTCTL_CSFTRST, dwc2->regs + GRSTCTL);
+
+	timeout = 10000;
+	do {
+		grstctl = readl(dwc2->regs + GRSTCTL);
+	} while ((grstctl & GRSTCTL_CSFTRST) && timeout-- > 0);
+
+	if (grstctl & GRSTCTL_CSFTRST) {
+		dev_err(dwc2->dev, "Failed to get CSftRst asserted\n");
+		return -EINVAL;
+	}
+
+	timeout = 10000;
+
+	while (1) {
+		u32 grstctl = readl(dwc2->regs + GRSTCTL);
+
+		if (timeout-- < 0) {
+			dev_info(dwc2->dev,
+				 "%s: reset failed, GRSTCTL=%08x\n",
+				 __func__, grstctl);
+			return -ETIMEDOUT;
+		}
+
+		if (!(grstctl & GRSTCTL_AHBIDLE))
+			continue;
+
+		break;		/* reset done */
+	}
+
+	dev_dbg(dwc2->dev, "reset successful\n");
+	return 0;
+}
+
+/**
+ * s3c_hsotg_core_init - issue softreset to the core
+ * @hsotg: The device state
+ *
+ * Issue a soft reset to the core, and await the core finishing it.
+ */
+#if defined(CONFIG_USB_DWC2_DUAL_ROLE) || defined(CONFIG_USB_DWC2_GADGET)
+void s3c_hsotg_core_init(struct dwc2_hsotg *dwc2)
+{
+	s3c_hsotg_corereset(dwc2);
+
+	/*
+	 * we must now enable ep0 ready for host detection and then
+	 * set configuration.
+	 */
+
+	/* set the PLL on, remove the HNP/SRP and set the PHY */
+	writel(GUSBCFG_PHYIF16 | GUSBCFG_TOUTCAL(7) |
+	       (0x5 << 10), dwc2->regs + GUSBCFG);
+
+	s3c_hsotg_init_fifo(dwc2);
+
+	__orr32(dwc2->regs + DCTL, DCTL_SFTDISCON);
+
+	writel(1 << 18 | DCFG_DEVSPD_HS,  dwc2->regs + DCFG);
+
+	/* Clear any pending OTG interrupts */
+	writel(0xffffffff, dwc2->regs + GOTGINT);
+
+	/* Clear any pending interrupts */
+	writel(0xffffffff, dwc2->regs + GINTSTS);
+
+	writel(GINTSTS_ERLYSUSP | GINTSTS_SESSREQINT |
+	       GINTSTS_GOUTNAKEFF | GINTSTS_GINNAKEFF |
+	       GINTSTS_CONIDSTSCHNG | GINTSTS_USBRST |
+	       GINTSTS_ENUMDONE | GINTSTS_OTGINT |
+	       GINTSTS_USBSUSP | GINTSTS_WKUPINT,
+	       dwc2->regs + GINTMSK);
+
+	if (using_dma(dwc2->s3c_hsotg))
+		writel(GAHBCFG_GLBL_INTR_EN | GAHBCFG_DMA_EN |
+		       GAHBCFG_HBSTLEN_INCR4,
+		       dwc2->regs + GAHBCFG);
+	else
+		writel(((dwc2->s3c_hsotg->dedicated_fifos) ? (GAHBCFG_NP_TXF_EMP_LVL |
+						    GAHBCFG_P_TXF_EMP_LVL) : 0) |
+		       GAHBCFG_GLBL_INTR_EN,
+		       dwc2->regs + GAHBCFG);
+
+	/*
+	 * If INTknTXFEmpMsk is enabled, it's important to disable ep interrupts
+	 * when we have no data to transfer. Otherwise we get being flooded by
+	 * interrupts.
+	 */
+
+	writel(((dwc2->s3c_hsotg->dedicated_fifos) ? DIEPMSK_TXFIFOEMPTY |
+		DIEPMSK_INTKNTXFEMPMSK : 0) |
+		DIEPMSK_EPDISBLDMSK | DIEPMSK_XFERCOMPLMSK |
+		DIEPMSK_TIMEOUTMSK | DIEPMSK_AHBERRMSK |
+		DIEPMSK_INTKNEPMISMSK,
+		dwc2->regs + DIEPMSK);
+
+	/*
+	 * don't need XferCompl, we get that from RXFIFO in slave mode. In
+	 * DMA mode we may need this.
+	 */
+	writel((using_dma(dwc2->s3c_hsotg) ? (DIEPMSK_XFERCOMPLMSK |
+				    DIEPMSK_TIMEOUTMSK) : 0) |
+	       DOEPMSK_EPDISBLDMSK | DOEPMSK_AHBERRMSK |
+	       DOEPMSK_SETUPMSK,
+	       dwc2->regs + DOEPMSK);
+
+	writel(0, dwc2->regs + DAINTMSK);
+
+	dev_dbg(dwc2->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",
+		readl(dwc2->regs + DIEPCTL0),
+		readl(dwc2->regs + DOEPCTL0));
+
+	/* enable in and out endpoint interrupts */
+	s3c_hsotg_en_gsint(dwc2, GINTSTS_OEPINT | GINTSTS_IEPINT);
+
+	/*
+	 * Enable the RXFIFO when in slave mode, as this is how we collect
+	 * the data. In DMA mode, we get events from the FIFO but also
+	 * things we cannot process, so do not use it.
+	 */
+	if (!using_dma(dwc2->s3c_hsotg))
+		s3c_hsotg_en_gsint(dwc2, GINTSTS_RXFLVL);
+
+	/* Enable interrupts for EP0 in and out */
+	s3c_hsotg_ctrl_epint(dwc2, 0, 0, 1);
+	s3c_hsotg_ctrl_epint(dwc2, 0, 1, 1);
+
+	__orr32(dwc2->regs + DCTL, DCTL_PWRONPRGDONE);
+	udelay(10);  /* see openiboot */
+	__bic32(dwc2->regs + DCTL, DCTL_PWRONPRGDONE);
+
+	dev_dbg(dwc2->dev, "DCTL=0x%08x\n", readl(dwc2->regs + DCTL));
+
+	/*
+	 * DXEPCTL_USBActEp says RO in manual, but seems to be set by
+	 * writing to the EPCTL register..
+	 */
+
+	/* set to read 1 8byte packet */
+	writel(DXEPTSIZ_MC(1) | DXEPTSIZ_PKTCNT(1) |
+	       DXEPTSIZ_XFERSIZE(8), dwc2->regs + DOEPTSIZ0);
+
+	writel(s3c_hsotg_ep0_mps(dwc2->eps[0].ep.maxpacket) |
+	       DXEPCTL_CNAK | DXEPCTL_EPENA |
+	       DXEPCTL_USBACTEP,
+	       dwc2->regs + DOEPCTL0);
+
+	/* enable, but don't activate EP0in */
+	writel(s3c_hsotg_ep0_mps(dwc2->eps[0].ep.maxpacket) |
+	       DXEPCTL_USBACTEP, dwc2->regs + DIEPCTL0);
+
+	s3c_hsotg_enqueue_setup(dwc2);
+
+	dev_dbg(dwc2->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",
+		readl(dwc2->regs + DIEPCTL0),
+		readl(dwc2->regs + DOEPCTL0));
+
+	/* clear global NAKs */
+	writel(DCTL_CGOUTNAK | DCTL_CGNPINNAK,
+	       dwc2->regs + DCTL);
+
+	/* must be at-least 3ms to allow bus to see disconnect */
+	mdelay(3);
+
+	/* remove the soft-disconnect and let's go */
+	__bic32(dwc2->regs + DCTL, DCTL_SFTDISCON);
+}
+#else
+void s3c_hsotg_core_init(struct dwc2_hsotg *dwc2)
+{
+}
+#endif
+
+/**
+ * s3c_hsotg_ep_enable - enable the given endpoint
+ * @ep: The USB endpint to configure
+ * @desc: The USB endpoint descriptor to configure with.
+ *
+ * This is called from the USB gadget code's usb_ep_enable().
+ */
+static int s3c_hsotg_ep_enable(struct usb_ep *ep,
+			       const struct usb_endpoint_descriptor *desc)
+{
+	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
+	struct dwc2_hsotg *dwc2 = hs_ep->parent;
+	unsigned long flags;
+	int index = hs_ep->index;
+	u32 epctrl_reg;
+	u32 epctrl;
+	u32 mps;
+	int dir_in;
+	int ret = 0;
+
+	/*dev_info(dwc2->dev,
+		"%s: ep %s: a 0x%02x, attr 0x%02x, mps 0x%04x, intr %d\n",
+		__func__, ep->name, desc->bEndpointAddress, desc->bmAttributes,
+		desc->wMaxPacketSize, desc->bInterval);
+	*/
+	/* not to be called for EP0 */
+	WARN_ON(index == 0);
+
+	dir_in = (desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK) ? 1 : 0;
+	if (dir_in != hs_ep->dir_in) {
+		dev_err(dwc2->dev, "%s: direction mismatch!\n", __func__);
+		return -EINVAL;
+	}
+
+	mps = usb_endpoint_maxp(desc);
+
+	/* note, we handle this here instead of s3c_hsotg_set_ep_maxpacket */
+
+	epctrl_reg = dir_in ? DIEPCTL(index) : DOEPCTL(index);
+	epctrl = readl(dwc2->regs + epctrl_reg);
+
+	/*dev_info(dwc2->dev, "%s: read DXEPCTL=0x%08x from 0x%08x\n",
+		__func__, epctrl, epctrl_reg);
+	*/
+	spin_lock_irqsave(&dwc2->lock, flags);
+
+	epctrl &= ~(DXEPCTL_EPTYPE_MASK | DXEPCTL_MPS_MASK);
+	epctrl |= DXEPCTL_MPS(mps);
+
+	/*
+	 * mark the endpoint as active, otherwise the core may ignore
+	 * transactions entirely for this endpoint
+	 */
+	epctrl |= DXEPCTL_USBACTEP;
+
+	/*
+	 * set the NAK status on the endpoint, otherwise we might try and
+	 * do something with data that we've yet got a request to process
+	 * since the RXFIFO will take data for an endpoint even if the
+	 * size register hasn't been set.
+	 */
+
+	epctrl |= DXEPCTL_SNAK;
+
+	/* update the endpoint state */
+	s3c_hsotg_set_ep_maxpacket(dwc2, hs_ep->index, mps);
+
+	/* default, set to non-periodic */
+	hs_ep->isochronous = 0;
+	hs_ep->periodic = 0;
+	hs_ep->halted = 0;
+	hs_ep->interval = desc->bInterval;
+
+	if (hs_ep->interval > 1 && hs_ep->mc > 1)
+		dev_err(dwc2->dev, "MC > 1 when interval is not 1\n");
+
+	switch (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {
+	case USB_ENDPOINT_XFER_ISOC:
+		epctrl |= DXEPCTL_EPTYPE_ISO;
+		epctrl |= DXEPCTL_SETEVENFR;
+		hs_ep->isochronous = 1;
+		if (dir_in)
+			hs_ep->periodic = 1;
+		break;
+
+	case USB_ENDPOINT_XFER_BULK:
+		epctrl |= DXEPCTL_EPTYPE_BULK;
+		break;
+
+	case USB_ENDPOINT_XFER_INT:
+		if (dir_in) {
+			/*
+			 * Allocate our TxFNum by simply using the index
+			 * of the endpoint for the moment. We could do
+			 * something better if the host indicates how
+			 * many FIFOs we are expecting to use.
+			 */
+
+			hs_ep->periodic = 1;
+			epctrl |= DXEPCTL_TXFNUM(index);
+		}
+
+		epctrl |= DXEPCTL_EPTYPE_INTERRUPT;
+		break;
+
+	case USB_ENDPOINT_XFER_CONTROL:
+		epctrl |= DXEPCTL_EPTYPE_CONTROL;
+		break;
+	}
+
+	/*
+	 * if the hardware has dedicated fifos, we must give each IN EP
+	 * a unique tx-fifo even if it is non-periodic.
+	 */
+	if (dir_in && dwc2->s3c_hsotg->dedicated_fifos)
+		epctrl |= DXEPCTL_TXFNUM(index);
+
+	/* for non control endpoints, set PID to D0 */
+	if (index)
+		epctrl |= DXEPCTL_SETD0PID;
+
+	/*dev_info(dwc2->dev, "%s: write DXEPCTL=0x%08x\n",
+		__func__, epctrl);
+	*/
+	writel(epctrl, dwc2->regs + epctrl_reg);
+	/*dev_info(dwc2->dev, "%s: read DXEPCTL=0x%08x\n",
+		__func__, readl(dwc2->regs + epctrl_reg));
+	*/
+	/* enable the endpoint interrupt */
+	s3c_hsotg_ctrl_epint(dwc2, index, dir_in, 1);
+
+	spin_unlock_irqrestore(&dwc2->lock, flags);
+	return ret;
+}
+
+/**
+ * s3c_hsotg_ep_disable - disable given endpoint
+ * @ep: The endpoint to disable.
+ */
+static int s3c_hsotg_ep_disable(struct usb_ep *ep)
+{
+	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
+	struct dwc2_hsotg *dwc2 = hs_ep->parent;
+	int dir_in = hs_ep->dir_in;
+	int index = hs_ep->index;
+	unsigned long flags;
+	u32 epctrl_reg;
+	u32 ctrl;
+
+	dev_info(dwc2->dev, "%s(ep %p)\n", __func__, ep);
+
+	if (ep == &dwc2->eps[0].ep) {
+		dev_err(dwc2->dev, "%s: called for ep0\n", __func__);
+		return -EINVAL;
+	}
+
+	epctrl_reg = dir_in ? DIEPCTL(index) : DOEPCTL(index);
+
+	spin_lock_irqsave(&dwc2->lock, flags);
+	/* terminate all requests with shutdown */
+	kill_all_requests(dwc2, hs_ep, -ESHUTDOWN, false);
+
+
+	ctrl = readl(dwc2->regs + epctrl_reg);
+	ctrl &= ~DXEPCTL_EPENA;
+	ctrl &= ~DXEPCTL_USBACTEP;
+	ctrl |= DXEPCTL_SNAK;
+
+	dev_dbg(dwc2->dev, "%s: DXEPCTL=0x%08x\n", __func__, ctrl);
+	writel(ctrl, dwc2->regs + epctrl_reg);
+
+	/* disable endpoint interrupts */
+	s3c_hsotg_ctrl_epint(dwc2, hs_ep->index, hs_ep->dir_in, 0);
+
+	spin_unlock_irqrestore(&dwc2->lock, flags);
+	return 0;
+}
+
+/**
+ * on_list - check request is on the given endpoint
+ * @ep: The endpoint to check.
+ * @test: The request to test if it is on the endpoint.
+ */
+static bool on_list(struct s3c_hsotg_ep *ep, struct s3c_hsotg_req *test)
+{
+	struct s3c_hsotg_req *req, *treq;
+
+	list_for_each_entry_safe(req, treq, &ep->queue, queue) {
+		if (req == test)
+			return true;
+	}
+
+	return false;
+}
+
+/**
+ * s3c_hsotg_ep_dequeue - dequeue given endpoint
+ * @ep: The endpoint to dequeue.
+ * @req: The request to be removed from a queue.
+ */
+static int s3c_hsotg_ep_dequeue(struct usb_ep *ep, struct usb_request *req)
+{
+	struct s3c_hsotg_req *hs_req = our_req(req);
+	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
+	struct dwc2_hsotg *dwc2 = hs_ep->parent;
+	unsigned long flags;
+
+	dev_info(dwc2->dev, "ep_dequeue(%p,%p)\n", ep, req);
+
+	spin_lock_irqsave(&dwc2->lock, flags);
+
+	if (!on_list(hs_ep, hs_req)) {
+		spin_unlock_irqrestore(&dwc2->lock, flags);
+		return -EINVAL;
+	}
+
+	s3c_hsotg_complete_request(dwc2, hs_ep, hs_req, -ECONNRESET);
+	spin_unlock_irqrestore(&dwc2->lock, flags);
+
+	return 0;
+}
+
+/**
+ * s3c_hsotg_ep_sethalt - set halt on a given endpoint
+ * @ep: The endpoint to set halt.
+ * @value: Set or unset the halt.
+ */
+static int s3c_hsotg_ep_sethalt(struct usb_ep *ep, int value)
+{
+	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
+	struct dwc2_hsotg *dwc2 = hs_ep->parent;
+	int index = hs_ep->index;
+	u32 epreg;
+	u32 epctl;
+	u32 xfertype;
+
+	dev_dbg(dwc2->dev, "%s(ep %p %s, %d)\n", __func__, ep, ep->name, value);
+
+	/* write both IN and OUT control registers */
+
+	epreg = DIEPCTL(index);
+	epctl = readl(dwc2->regs + epreg);
+
+	if (value) {
+		epctl |= DXEPCTL_STALL + DXEPCTL_SNAK;
+		if (epctl & DXEPCTL_EPENA)
+			epctl |= DXEPCTL_EPDIS;
+	} else {
+		epctl &= ~DXEPCTL_STALL;
+		xfertype = epctl & DXEPCTL_EPTYPE_MASK;
+		if (xfertype == DXEPCTL_EPTYPE_BULK ||
+			xfertype == DXEPCTL_EPTYPE_INTERRUPT)
+				epctl |= DXEPCTL_SETD0PID;
+	}
+
+	writel(epctl, dwc2->regs + epreg);
+
+	epreg = DOEPCTL(index);
+	epctl = readl(dwc2->regs + epreg);
+
+	if (value)
+		epctl |= DXEPCTL_STALL;
+	else {
+		epctl &= ~DXEPCTL_STALL;
+		xfertype = epctl & DXEPCTL_EPTYPE_MASK;
+		if (xfertype == DXEPCTL_EPTYPE_BULK ||
+			xfertype == DXEPCTL_EPTYPE_INTERRUPT)
+				epctl |= DXEPCTL_SETD0PID;
+	}
+
+	writel(epctl, dwc2->regs + epreg);
+
+	hs_ep->halted = value;
+
+	return 0;
+}
+
+/**
+ * s3c_hsotg_ep_sethalt_lock - set halt on a given endpoint with lock held
+ * @ep: The endpoint to set halt.
+ * @value: Set or unset the halt.
+ */
+static int s3c_hsotg_ep_sethalt_lock(struct usb_ep *ep, int value)
+{
+	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
+	struct dwc2_hsotg *dwc2 = hs_ep->parent;
+	unsigned long flags = 0;
+	int ret = 0;
+
+	spin_lock_irqsave(&dwc2->lock, flags);
+	ret = s3c_hsotg_ep_sethalt(ep, value);
+	spin_unlock_irqrestore(&dwc2->lock, flags);
+
+	return ret;
+}
+
+static struct usb_ep_ops s3c_hsotg_ep_ops = {
+	.enable		= s3c_hsotg_ep_enable,
+	.disable	= s3c_hsotg_ep_disable,
+	.alloc_request	= s3c_hsotg_ep_alloc_request,
+	.free_request	= s3c_hsotg_ep_free_request,
+	.queue		= s3c_hsotg_ep_queue_lock,
+	.dequeue	= s3c_hsotg_ep_dequeue,
+	.set_halt	= s3c_hsotg_ep_sethalt_lock,
+	/* note, don't believe we have any call for the fifo routines */
+};
+
+/**
+ * s3c_hsotg_phy_enable - enable platform phy dev
+ * @hsotg: The driver state
+ *
+ * A wrapper for platform code responsible for controlling
+ * low-level USB code
+ */
+static void s3c_hsotg_phy_enable(struct dwc2_hsotg *dwc2)
+{
+	struct platform_device *pdev = to_platform_device(dwc2->dev);
+
+	dev_dbg(dwc2->dev, "pdev 0x%p\n", pdev);
+
+	if (dwc2->s3c_hsotg->gphy) {
+		phy_init(dwc2->s3c_hsotg->gphy);
+		phy_power_on(dwc2->s3c_hsotg->gphy);
+	} else if (dwc2->s3c_hsotg->phy) {
+		usb_phy_init(dwc2->s3c_hsotg->phy);
+	} else if (dwc2->s3c_hsotg->plat->phy_init)
+		dwc2->s3c_hsotg->plat->phy_init(pdev, dwc2->s3c_hsotg->plat->phy_type);
+}
+
+/**
+ * s3c_hsotg_phy_disable - disable platform phy dev
+ * @hsotg: The driver state
+ *
+ * A wrapper for platform code responsible for controlling
+ * low-level USB code
+ */
+static void s3c_hsotg_phy_disable(struct dwc2_hsotg *dwc2)
+{
+	struct platform_device *pdev = to_platform_device(dwc2->dev);
+
+	if (dwc2->s3c_hsotg->gphy) {
+		phy_power_off(dwc2->s3c_hsotg->gphy);
+		phy_exit(dwc2->s3c_hsotg->gphy);
+	} else if (dwc2->s3c_hsotg->phy) {
+		usb_phy_shutdown(dwc2->s3c_hsotg->phy);
+	} else if (dwc2->s3c_hsotg->plat->phy_exit)
+		dwc2->s3c_hsotg->plat->phy_exit(pdev, dwc2->s3c_hsotg->plat->phy_type);
+}
+
+/**
+ * s3c_hsotg_init - initalize the usb core
+ * @hsotg: The driver state
+ */
+static void s3c_hsotg_init(struct dwc2_hsotg *dwc2)
+{
+	/* unmask subset of endpoint interrupts */
+
+	writel(DIEPMSK_TIMEOUTMSK | DIEPMSK_AHBERRMSK |
+	       DIEPMSK_EPDISBLDMSK | DIEPMSK_XFERCOMPLMSK,
+	       dwc2->regs + DIEPMSK);
+
+	writel(DOEPMSK_SETUPMSK | DOEPMSK_AHBERRMSK |
+	       DOEPMSK_EPDISBLDMSK | DOEPMSK_XFERCOMPLMSK,
+	       dwc2->regs + DOEPMSK);
+
+	writel(0, dwc2->regs + DAINTMSK);
+
+	/* Be in disconnected state until gadget is registered */
+	__orr32(dwc2->regs + DCTL, DCTL_SFTDISCON);
+
+	if (0) {
+		/* post global nak until we're ready */
+		writel(DCTL_SGNPINNAK | DCTL_SGOUTNAK,
+		       dwc2->regs + DCTL);
+	}
+
+	/* setup fifos */
+
+	dev_dbg(dwc2->dev, "GRXFSIZ=0x%08x, GNPTXFSIZ=0x%08x\n",
+		readl(dwc2->regs + GRXFSIZ),
+		readl(dwc2->regs + GNPTXFSIZ));
+
+	s3c_hsotg_init_fifo(dwc2);
+
+	/* set the PLL on, remove the HNP/SRP and set the PHY */
+	writel(GUSBCFG_PHYIF16 | GUSBCFG_TOUTCAL(7) | (0x5 << 10),
+	       dwc2->regs + GUSBCFG);
+
+	writel(using_dma(dwc2->s3c_hsotg) ? GAHBCFG_DMA_EN : 0x0,
+	       dwc2->regs + GAHBCFG);
+}
+
+/**
+ * s3c_hsotg_udc_start - prepare the udc for work
+ * @gadget: The usb gadget state
+ * @driver: The usb gadget driver
+ *
+ * Perform initialization to prepare udc device and driver
+ * to work.
+ */
+static int s3c_hsotg_udc_start(struct usb_gadget *gadget,
+			   struct usb_gadget_driver *driver)
+{
+	struct dwc2_hsotg *dwc2 = to_hsotg(gadget);
+	int ret;
+
+	if (!dwc2) {
+		pr_err("%s: called with no device\n", __func__);
+		return -ENODEV;
+	}
+
+	if (!driver) {
+		dev_err(dwc2->dev, "%s: no driver\n", __func__);
+		return -EINVAL;
+	}
+
+	if (driver->max_speed < USB_SPEED_FULL)
+		dev_err(dwc2->dev, "%s: bad speed\n", __func__);
+
+	if (!driver->setup) {
+		dev_err(dwc2->dev, "%s: missing entry points\n", __func__);
+		return -EINVAL;
+	}
+
+	WARN_ON(dwc2->driver);
+
+	driver->driver.bus = NULL;
+	dwc2->driver = driver;
+	dwc2->gadget.dev.of_node = dwc2->dev->of_node;
+	dwc2->gadget.speed = USB_SPEED_UNKNOWN;
+	ret = regulator_bulk_enable(ARRAY_SIZE(dwc2->s3c_hsotg->supplies),
+				    dwc2->s3c_hsotg->supplies);
+
+	if (ret) {
+		dev_err(dwc2->dev, "failed to enable supplies: %d\n", ret);
+		goto err;
+	}
+
+	dwc2->s3c_hsotg->last_rst = jiffies;
+	dev_info(dwc2->dev, "bound driver %s\n", driver->driver.name);
+	return 0;
+
+err:
+	dwc2->driver = NULL;
+	return ret;
+}
+
+/**
+ * s3c_hsotg_udc_stop - stop the udc
+ * @gadget: The usb gadget state
+ * @driver: The usb gadget driver
+ *
+ * Stop udc hw block and stay tunned for future transmissions
+ */
+static int s3c_hsotg_udc_stop(struct usb_gadget *gadget,
+			  struct usb_gadget_driver *driver)
+{
+	struct dwc2_hsotg *dwc2 = to_hsotg(gadget);
+	unsigned long flags = 0;
+	int ep;
+
+	if (!dwc2)
+		return -ENODEV;
+
+	/* all endpoints should be shutdown */
+	for (ep = 0; ep < dwc2->s3c_hsotg->num_of_eps; ep++)
+		s3c_hsotg_ep_disable(&dwc2->eps[ep].ep);
+
+	spin_lock_irqsave(&dwc2->lock, flags);
+
+	s3c_hsotg_phy_disable(dwc2);
+
+	if (!driver)
+		dwc2->driver = NULL;
+
+	dwc2->gadget.speed = USB_SPEED_UNKNOWN;
+
+	spin_unlock_irqrestore(&dwc2->lock, flags);
+
+	regulator_bulk_disable(ARRAY_SIZE(dwc2->s3c_hsotg->supplies), dwc2->s3c_hsotg->supplies);
+
+	return 0;
+}
+
+/**
+ * s3c_hsotg_gadget_getframe - read the frame number
+ * @gadget: The usb gadget state
+ *
+ * Read the {micro} frame number
+ */
+static int s3c_hsotg_gadget_getframe(struct usb_gadget *gadget)
+{
+	return s3c_hsotg_read_frameno(to_hsotg(gadget));
+}
+
+/**
+ * s3c_hsotg_pullup - connect/disconnect the USB PHY
+ * @gadget: The usb gadget state
+ * @is_on: Current state of the USB PHY
+ *
+ * Connect/Disconnect the USB PHY pullup
+ */
+static int s3c_hsotg_pullup(struct usb_gadget *gadget, int is_on)
+{
+	struct dwc2_hsotg *dwc2 = to_hsotg(gadget);
+	unsigned long flags = 0;
+
+	dev_dbg(dwc2->dev, "%s: is_in: %d\n", __func__, is_on);
+
+	spin_lock_irqsave(&dwc2->lock, flags);
+	if (is_on) {
+		s3c_hsotg_phy_enable(dwc2);
+		s3c_hsotg_core_init(dwc2);
+	} else {
+		s3c_hsotg_disconnect(dwc2);
+		s3c_hsotg_phy_disable(dwc2);
+	}
+
+	dwc2->gadget.speed = USB_SPEED_UNKNOWN;
+	spin_unlock_irqrestore(&dwc2->lock, flags);
+
+	return 0;
+}
+
+static const struct usb_gadget_ops s3c_hsotg_gadget_ops = {
+	.get_frame	= s3c_hsotg_gadget_getframe,
+	.udc_start		= s3c_hsotg_udc_start,
+	.udc_stop		= s3c_hsotg_udc_stop,
+	.pullup                 = s3c_hsotg_pullup,
+};
+
+/**
+ * s3c_hsotg_initep - initialise a single endpoint
+ * @hsotg: The device state.
+ * @hs_ep: The endpoint to be initialised.
+ * @epnum: The endpoint number
+ *
+ * Initialise the given endpoint (as part of the probe and device state
+ * creation) to give to the gadget driver. Setup the endpoint name, any
+ * direction information and other state that may be required.
+ */
+static void s3c_hsotg_initep(struct dwc2_hsotg *dwc2,
+				       struct s3c_hsotg_ep *hs_ep,
+				       int epnum)
+{
+	u32 ptxfifo;
+	char *dir;
+
+	if (epnum == 0)
+		dir = "";
+	else if ((epnum % 2) == 0) {
+		dir = "out";
+	} else {
+		dir = "in";
+		hs_ep->dir_in = 1;
+	}
+
+	hs_ep->index = epnum;
+
+	snprintf(hs_ep->name, sizeof(hs_ep->name), "ep%d%s", epnum, dir);
+
+	INIT_LIST_HEAD(&hs_ep->queue);
+	INIT_LIST_HEAD(&hs_ep->ep.ep_list);
+
+	/* add to the list of endpoints known by the gadget driver */
+	if (epnum)
+		list_add_tail(&hs_ep->ep.ep_list, &dwc2->gadget.ep_list);
+
+	hs_ep->parent = dwc2;
+	hs_ep->ep.name = hs_ep->name;
+	hs_ep->ep.maxpacket = epnum ? 1024 : EP0_MPS_LIMIT;
+	hs_ep->ep.ops = &s3c_hsotg_ep_ops;
+
+	/*
+	 * Read the FIFO size for the Periodic TX FIFO, even if we're
+	 * an OUT endpoint, we may as well do this if in future the
+	 * code is changed to make each endpoint's direction changeable.
+	 */
+
+	ptxfifo = readl(dwc2->regs + DPTXFSIZN(epnum));
+	hs_ep->fifo_size = DPTXFSIZN_DPTXFSIZE_GET(ptxfifo) * 4;
+
+	/*
+	 * if we're using dma, we need to set the next-endpoint pointer
+	 * to be something valid.
+	 */
+
+	if (using_dma(dwc2->s3c_hsotg)) {
+		u32 next = DXEPCTL_NEXTEP((epnum + 1) % 15);
+		writel(next, dwc2->regs + DIEPCTL(epnum));
+		writel(next, dwc2->regs + DOEPCTL(epnum));
+	}
+}
+
+/**
+ * s3c_hsotg_hw_cfg - read HW configuration registers
+ * @param: The device state
+ *
+ * Read the USB core HW configuration registers
+ */
+static void s3c_hsotg_hw_cfg(struct dwc2_hsotg *dwc2)
+{
+	u32 cfg2, cfg4;
+	/* check hardware configuration */
+
+	cfg2 = readl(dwc2->regs + 0x48);
+	dwc2->s3c_hsotg->num_of_eps = (cfg2 >> 10) & 0xF;
+
+	dev_info(dwc2->dev, "EPs:%d\n", dwc2->s3c_hsotg->num_of_eps);
+
+	cfg4 = readl(dwc2->regs + 0x50);
+	dwc2->s3c_hsotg->dedicated_fifos = (cfg4 >> 25) & 1;
+
+	dev_info(dwc2->dev, "%s fifos\n",
+		 dwc2->s3c_hsotg->dedicated_fifos ? "dedicated" : "shared");
+}
+
+/**
+ * s3c_hsotg_dump - dump state of the udc
+ * @param: The device state
+ */
+void s3c_hsotg_dump(struct dwc2_hsotg *dwc2)
+{
+#ifdef DEBUG
+	struct device *dev = dwc2->dev;
+	void __iomem *regs = dwc2->regs;
+	u32 val;
+	int idx;
+
+	dev_info(dev, "DCFG=0x%08x, DCTL=0x%08x, DIEPMSK=%08x\n",
+		 readl(regs + DCFG), readl(regs + DCTL),
+		 readl(regs + DIEPMSK));
+
+	dev_info(dev, "GAHBCFG=0x%08x, 0x44=0x%08x\n",
+		 readl(regs + GAHBCFG), readl(regs + 0x44));
+
+	dev_info(dev, "GRXFSIZ=0x%08x, GNPTXFSIZ=0x%08x\n",
+		 readl(regs + GRXFSIZ), readl(regs + GNPTXFSIZ));
+
+	/* show periodic fifo settings */
+
+	for (idx = 1; idx <= 15; idx++) {
+		val = readl(regs + DPTXFSIZN(idx));
+		dev_info(dev, "DPTx[%d] FSize=%d, StAddr=0x%08x\n", idx,
+			 val >> FIFOSIZE_DEPTH_SHIFT,
+			 val & FIFOSIZE_STARTADDR_MASK);
+	}
+
+	for (idx = 0; idx < 15; idx++) {
+		dev_info(dev,
+			 "ep%d-in: EPCTL=0x%08x, SIZ=0x%08x, DMA=0x%08x\n", idx,
+			 readl(regs + DIEPCTL(idx)),
+			 readl(regs + DIEPTSIZ(idx)),
+			 readl(regs + DIEPDMA(idx)));
+
+		val = readl(regs + DOEPCTL(idx));
+		dev_info(dev,
+			 "ep%d-out: EPCTL=0x%08x, SIZ=0x%08x, DMA=0x%08x\n",
+			 idx, readl(regs + DOEPCTL(idx)),
+			 readl(regs + DOEPTSIZ(idx)),
+			 readl(regs + DOEPDMA(idx)));
+
+	}
+
+	dev_info(dev, "DVBUSDIS=0x%08x, DVBUSPULSE=%08x\n",
+		 readl(regs + DVBUSDIS), readl(regs + DVBUSPULSE));
+#endif
+}
+
+/**
+ * state_show - debugfs: show overall driver and device state.
+ * @seq: The seq file to write to.
+ * @v: Unused parameter.
+ *
+ * This debugfs entry shows the overall state of the hardware and
+ * some general information about each of the endpoints available
+ * to the system.
+ */
+static int state_show(struct seq_file *seq, void *v)
+{
+	struct dwc2_hsotg *dwc2 = seq->private;
+	void __iomem *regs = dwc2->regs;
+	int idx;
+
+	seq_printf(seq, "DCFG=0x%08x, DCTL=0x%08x, DSTS=0x%08x\n",
+		 readl(regs + DCFG),
+		 readl(regs + DCTL),
+		 readl(regs + DSTS));
+
+	seq_printf(seq, "DIEPMSK=0x%08x, DOEPMASK=0x%08x\n",
+		   readl(regs + DIEPMSK), readl(regs + DOEPMSK));
+
+	seq_printf(seq, "GINTMSK=0x%08x, GINTSTS=0x%08x\n",
+		   readl(regs + GINTMSK),
+		   readl(regs + GINTSTS));
+
+	seq_printf(seq, "DAINTMSK=0x%08x, DAINT=0x%08x\n",
+		   readl(regs + DAINTMSK),
+		   readl(regs + DAINT));
+
+	seq_printf(seq, "GNPTXSTS=0x%08x, GRXSTSR=%08x\n",
+		   readl(regs + GNPTXSTS),
+		   readl(regs + GRXSTSR));
+
+	seq_puts(seq, "\nEndpoint status:\n");
+
+	for (idx = 0; idx < 15; idx++) {
+		u32 in, out;
+
+		in = readl(regs + DIEPCTL(idx));
+		out = readl(regs + DOEPCTL(idx));
+
+		seq_printf(seq, "ep%d: DIEPCTL=0x%08x, DOEPCTL=0x%08x",
+			   idx, in, out);
+
+		in = readl(regs + DIEPTSIZ(idx));
+		out = readl(regs + DOEPTSIZ(idx));
+
+		seq_printf(seq, ", DIEPTSIZ=0x%08x, DOEPTSIZ=0x%08x",
+			   in, out);
+
+		seq_puts(seq, "\n");
+	}
+
+	return 0;
+}
+
+static int state_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, state_show, inode->i_private);
+}
+
+static const struct file_operations state_fops = {
+	.owner		= THIS_MODULE,
+	.open		= state_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+/**
+ * fifo_show - debugfs: show the fifo information
+ * @seq: The seq_file to write data to.
+ * @v: Unused parameter.
+ *
+ * Show the FIFO information for the overall fifo and all the
+ * periodic transmission FIFOs.
+ */
+static int fifo_show(struct seq_file *seq, void *v)
+{
+	struct dwc2_hsotg *dwc2 = seq->private;
+	void __iomem *regs = dwc2->regs;
+	u32 val;
+	int idx;
+
+	seq_puts(seq, "Non-periodic FIFOs:\n");
+	seq_printf(seq, "RXFIFO: Size %d\n", readl(regs + GRXFSIZ));
+
+	val = readl(regs + GNPTXFSIZ);
+	seq_printf(seq, "NPTXFIFO: Size %d, Start 0x%08x\n",
+		   val >> FIFOSIZE_DEPTH_SHIFT,
+		   val & FIFOSIZE_DEPTH_MASK);
+
+	seq_puts(seq, "\nPeriodic TXFIFOs:\n");
+
+	for (idx = 1; idx <= 15; idx++) {
+		val = readl(regs + DPTXFSIZN(idx));
+
+		seq_printf(seq, "\tDPTXFIFO%2d: Size %d, Start 0x%08x\n", idx,
+			   val >> FIFOSIZE_DEPTH_SHIFT,
+			   val & FIFOSIZE_STARTADDR_MASK);
+	}
+
+	return 0;
+}
+
+static int fifo_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, fifo_show, inode->i_private);
+}
+
+static const struct file_operations fifo_fops = {
+	.owner		= THIS_MODULE,
+	.open		= fifo_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+
+static const char *decode_direction(int is_in)
+{
+	return is_in ? "in" : "out";
+}
+
+/**
+ * ep_show - debugfs: show the state of an endpoint.
+ * @seq: The seq_file to write data to.
+ * @v: Unused parameter.
+ *
+ * This debugfs entry shows the state of the given endpoint (one is
+ * registered for each available).
+ */
+static int ep_show(struct seq_file *seq, void *v)
+{
+	struct s3c_hsotg_ep *ep = seq->private;
+	struct dwc2_hsotg *dwc2 = ep->parent;
+	struct s3c_hsotg_req *req;
+	void __iomem *regs = dwc2->regs;
+	int index = ep->index;
+	int show_limit = 15;
+	unsigned long flags;
+
+	seq_printf(seq, "Endpoint index %d, named %s,  dir %s:\n",
+		   ep->index, ep->ep.name, decode_direction(ep->dir_in));
+
+	/* first show the register state */
+
+	seq_printf(seq, "\tDIEPCTL=0x%08x, DOEPCTL=0x%08x\n",
+		   readl(regs + DIEPCTL(index)),
+		   readl(regs + DOEPCTL(index)));
+
+	seq_printf(seq, "\tDIEPDMA=0x%08x, DOEPDMA=0x%08x\n",
+		   readl(regs + DIEPDMA(index)),
+		   readl(regs + DOEPDMA(index)));
+
+	seq_printf(seq, "\tDIEPINT=0x%08x, DOEPINT=0x%08x\n",
+		   readl(regs + DIEPINT(index)),
+		   readl(regs + DOEPINT(index)));
+
+	seq_printf(seq, "\tDIEPTSIZ=0x%08x, DOEPTSIZ=0x%08x\n",
+		   readl(regs + DIEPTSIZ(index)),
+		   readl(regs + DOEPTSIZ(index)));
+
+	seq_puts(seq, "\n");
+	seq_printf(seq, "mps %d\n", ep->ep.maxpacket);
+	seq_printf(seq, "total_data=%ld\n", ep->total_data);
+
+	seq_printf(seq, "request list (%p,%p):\n",
+		   ep->queue.next, ep->queue.prev);
+
+	spin_lock_irqsave(&dwc2->lock, flags);
+
+	list_for_each_entry(req, &ep->queue, queue) {
+		if (--show_limit < 0) {
+			seq_puts(seq, "not showing more requests...\n");
+			break;
+		}
+
+		seq_printf(seq, "%c req %p: %d bytes @%p, ",
+			   req == ep->req ? '*' : ' ',
+			   req, req->req.length, req->req.buf);
+		seq_printf(seq, "%d done, res %d\n",
+			   req->req.actual, req->req.status);
+	}
+
+	spin_unlock_irqrestore(&dwc2->lock, flags);
+
+	return 0;
+}
+
+static int ep_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ep_show, inode->i_private);
+}
+
+static const struct file_operations ep_fops = {
+	.owner		= THIS_MODULE,
+	.open		= ep_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+/**
+ * s3c_hsotg_create_debug - create debugfs directory and files
+ * @hsotg: The driver state
+ *
+ * Create the debugfs files to allow the user to get information
+ * about the state of the system. The directory name is created
+ * with the same name as the device itself, in case we end up
+ * with multiple blocks in future systems.
+ */
+static void s3c_hsotg_create_debug(struct dwc2_hsotg *dwc2)
+{
+	struct dentry *root;
+	unsigned epidx;
+
+	root = debugfs_create_dir(dev_name(dwc2->dev), NULL);
+	dwc2->s3c_hsotg->debug_root = root;
+	if (IS_ERR(root)) {
+		dev_err(dwc2->dev, "cannot create debug root\n");
+		return;
+	}
+
+	/* create general state file */
+
+	dwc2->s3c_hsotg->debug_file = debugfs_create_file("state", 0444, root,
+						dwc2, &state_fops);
+
+	if (IS_ERR(dwc2->s3c_hsotg->debug_file))
+		dev_err(dwc2->dev, "%s: failed to create state\n", __func__);
+
+	dwc2->s3c_hsotg->debug_fifo = debugfs_create_file("fifo", 0444, root,
+						dwc2, &fifo_fops);
+
+	if (IS_ERR(dwc2->s3c_hsotg->debug_fifo))
+		dev_err(dwc2->dev, "%s: failed to create fifo\n", __func__);
+
+	/* create one file for each endpoint */
+
+	for (epidx = 0; epidx < dwc2->s3c_hsotg->num_of_eps; epidx++) {
+		struct s3c_hsotg_ep *ep = &dwc2->eps[epidx];
+
+		ep->debugfs = debugfs_create_file(ep->name, 0444,
+						  root, ep, &ep_fops);
+
+		if (IS_ERR(ep->debugfs))
+			dev_err(dwc2->dev, "failed to create %s debug file\n",
+				ep->name);
+	}
+}
+
+/**
+ * s3c_hsotg_delete_debug - cleanup debugfs entries
+ * @hsotg: The driver state
+ *
+ * Cleanup (remove) the debugfs files for use on module exit.
+ */
+static void s3c_hsotg_delete_debug(struct dwc2_hsotg *dwc2)
+{
+	unsigned epidx;
+
+	for (epidx = 0; epidx < dwc2->s3c_hsotg->num_of_eps; epidx++) {
+		struct s3c_hsotg_ep *ep = &dwc2->eps[epidx];
+		debugfs_remove(ep->debugfs);
+	}
+
+	debugfs_remove(dwc2->s3c_hsotg->debug_file);
+	debugfs_remove(dwc2->s3c_hsotg->debug_fifo);
+	debugfs_remove(dwc2->s3c_hsotg->debug_root);
+}
+
+/**
+ * dwc2_gadget_init - probe function for hsotg driver
+ * @pdev: The platform information for the driver
+ */
+
+int dwc2_gadget_init(struct dwc2_hsotg *dwc2, int irq)
+{
+	struct s3c_hsotg_plat *plat = dwc2->dev->platform_data;
+	struct usb_phy *phy;
+	struct phy *gphy;
+	struct device *dev = dwc2->dev;
+	struct s3c_hsotg_ep *eps;
+	int epnum;
+	int ret;
+	int i;
+
+	dwc2->s3c_hsotg = devm_kzalloc(dwc2->dev, sizeof(struct s3c_hsotg), GFP_KERNEL);
+	if (!dwc2->s3c_hsotg) {
+		dev_err(dev, "cannot get memory\n");
+		return -ENOMEM;
+	}
+
+	/*
+	 * Attempt to find a generic PHY, then look for an old style
+	 *  USB PHY, finally fall back to pdata
+	 */
+	gphy = devm_phy_get(dev, "usb2-phy");
+	if (IS_ERR(gphy)) {
+		phy = devm_usb_get_phy(dev, USB_PHY_TYPE_USB2);
+		if (IS_ERR(phy)) {
+			/* Fallback for pdata */
+			plat = dev_get_platdata(dwc2->dev);
+			if (!plat) {
+				dev_err(dwc2->dev,
+					"no platform data or transceiver defined\n");
+				return -EPROBE_DEFER;
+			} else {
+				dwc2->s3c_hsotg->plat = plat;
+			}
+		} else
+			dwc2->s3c_hsotg->phy = phy;
+	} else
+		dwc2->s3c_hsotg->gphy = gphy;
+
+	dwc2->s3c_hsotg->clk = devm_clk_get(dwc2->dev, "otg");
+	if (IS_ERR(dwc2->s3c_hsotg->clk)) {
+		dev_err(dev, "cannot get otg clock\n");
+		return PTR_ERR(dwc2->s3c_hsotg->clk);
+	}
+
+	dwc2->gadget.max_speed = USB_SPEED_HIGH;
+	dwc2->gadget.ops = &s3c_hsotg_gadget_ops;
+	dwc2->gadget.name = dev_name(dev);
+
+	/* reset the system */
+
+	clk_prepare_enable(dwc2->s3c_hsotg->clk);
+	/* regulators */
+
+	for (i = 0; i < ARRAY_SIZE(dwc2->s3c_hsotg->supplies); i++)
+		dwc2->s3c_hsotg->supplies[i].supply = s3c_hsotg_supply_names[i];
+
+	ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(dwc2->s3c_hsotg->supplies),
+				 dwc2->s3c_hsotg->supplies);
+	if (ret) {
+		dev_err(dev, "failed to request supplies: %d\n", ret);
+		goto err_clk;
+	}
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(dwc2->s3c_hsotg->supplies),
+				    dwc2->s3c_hsotg->supplies);
+
+	if (ret) {
+		dev_err(dwc2->dev, "failed to enable supplies: %d\n", ret);
+		goto err_supplies;
+	}
+
+	/* usb phy enable */
+	s3c_hsotg_phy_enable(dwc2);
+
+	s3c_hsotg_corereset(dwc2);
+	s3c_hsotg_init(dwc2);
+	s3c_hsotg_hw_cfg(dwc2);
+
+	/* hsotg->num_of_eps holds number of EPs other than ep0 */
+
+	if (dwc2->s3c_hsotg->num_of_eps == 0) {
+		dev_err(dev, "wrong number of EPs (zero)\n");
+		ret = -EINVAL;
+		goto err_supplies;
+	}
+
+	eps = kcalloc(dwc2->s3c_hsotg->num_of_eps + 1, sizeof(struct s3c_hsotg_ep),
+		      GFP_KERNEL);
+	if (!eps) {
+		dev_err(dev, "cannot get memory\n");
+		ret = -ENOMEM;
+		goto err_supplies;
+	}
+
+	dwc2->eps = eps;
+
+	/* setup endpoint information */
+
+	INIT_LIST_HEAD(&dwc2->gadget.ep_list);
+	dwc2->gadget.ep0 = &dwc2->eps[0].ep;
+
+	/* allocate EP0 request */
+
+	dwc2->s3c_hsotg->ctrl_req = s3c_hsotg_ep_alloc_request(&dwc2->eps[0].ep,
+						     GFP_KERNEL);
+	if (!dwc2->s3c_hsotg->ctrl_req) {
+		dev_err(dev, "failed to allocate ctrl req\n");
+		ret = -ENOMEM;
+		goto err_ep_mem;
+	}
+
+	/* initialise the endpoints now the core has been initialised */
+	for (epnum = 0; epnum < dwc2->s3c_hsotg->num_of_eps; epnum++)
+		s3c_hsotg_initep(dwc2, &dwc2->eps[epnum], epnum);
+
+	/* disable power and clock */
+
+	ret = regulator_bulk_disable(ARRAY_SIZE(dwc2->s3c_hsotg->supplies),
+				    dwc2->s3c_hsotg->supplies);
+	if (ret) {
+		dev_err(dwc2->dev, "failed to disable supplies: %d\n", ret);
+		goto err_ep_mem;
+	}
+
+	s3c_hsotg_phy_disable(dwc2);
+
+	ret = usb_add_gadget_udc(dwc2->dev, &dwc2->gadget);
+	if (ret)
+		goto err_ep_mem;
+
+	s3c_hsotg_create_debug(dwc2);
+
+	s3c_hsotg_dump(dwc2);
+
+	return 0;
+
+err_ep_mem:
+	kfree(eps);
+err_supplies:
+	s3c_hsotg_phy_disable(dwc2);
+err_clk:
+	clk_disable_unprepare(dwc2->s3c_hsotg->clk);
+
+	return ret;
+}
+
+void s3c_hsotg_remove(struct dwc2_hsotg *dwc2)
+{
+	usb_del_gadget_udc(&dwc2->gadget);
+
+	s3c_hsotg_delete_debug(dwc2);
+
+	if (dwc2->driver) {
+		/* should have been done already by driver model core */
+		usb_gadget_unregister_driver(dwc2->driver);
+	}
+
+	s3c_hsotg_phy_disable(dwc2);
+	clk_disable_unprepare(dwc2->s3c_hsotg->clk);
+}
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 9359cc3..cbadaa5 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -285,14 +285,6 @@ config USB_PXA27X
 	   dynamically linked module called "pxa27x_udc" and force all
 	   gadget drivers to also be dynamically linked.
 
-config USB_S3C_HSOTG
-	tristate "S3C HS/OtG USB Device controller"
-	depends on S3C_DEV_USB_HSOTG
-	select USB_GADGET_DUALSPEED
-	help
-	  The Samsung S3C64XX USB2.0 high-speed gadget controller
-	  integrated into the S3C64XX series SoC.
-
 config USB_IMX
 	tristate "Freescale i.MX1 USB Peripheral Controller"
 	depends on ARCH_MXC
diff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile
index 7dd2e21..e3e439c 100644
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -23,7 +23,6 @@ obj-$(CONFIG_USB_M66592)	+= m66592-udc.o
 obj-$(CONFIG_USB_R8A66597)	+= r8a66597-udc.o
 obj-$(CONFIG_USB_FSL_QE)	+= fsl_qe_udc.o
 obj-$(CONFIG_USB_CI13XXX_PCI)	+= ci13xxx_pci.o
-obj-$(CONFIG_USB_S3C_HSOTG)	+= s3c-hsotg.o
 obj-$(CONFIG_USB_S3C_HSUDC)	+= s3c-hsudc.o
 obj-$(CONFIG_USB_LANGWELL)	+= langwell_udc.o
 obj-$(CONFIG_USB_EG20T)		+= pch_udc.o
diff --git a/drivers/usb/gadget/s3c-hsotg.c b/drivers/usb/gadget/s3c-hsotg.c
deleted file mode 100644
index 70c6f3b..0000000
--- a/drivers/usb/gadget/s3c-hsotg.c
+++ /dev/null
@@ -1,3478 +0,0 @@
-/* linux/drivers/usb/gadget/s3c-hsotg.c
- *
- * Copyright (c) 2011 Samsung Electronics Co., Ltd.
- *		http://www.samsung.com
- *
- * Copyright 2008 Openmoko, Inc.
- * Copyright 2008 Simtec Electronics
- *      Ben Dooks <ben@simtec.co.uk>
- *      http://armlinux.simtec.co.uk/
- *
- * S3C USB2.0 High-speed / OtG driver
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
-*/
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/spinlock.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/dma-mapping.h>
-#include <linux/debugfs.h>
-#include <linux/seq_file.h>
-#include <linux/delay.h>
-#include <linux/io.h>
-#include <linux/slab.h>
-#include <linux/clk.h>
-
-#include <linux/usb/ch9.h>
-#include <linux/usb/gadget.h>
-
-#include <mach/map.h>
-
-#include <plat/regs-usb-hsotg-phy.h>
-#include "s3c-hsotg.h"
-#include <linux/platform_data/s3c-hsotg.h>
-#include <mach/regs-sys.h>
-#include <plat/cpu.h>
-
-#define DMA_ADDR_INVALID (~((dma_addr_t)0))
-
-/* EP0_MPS_LIMIT
- *
- * Unfortunately there seems to be a limit of the amount of data that can
- * be transferred by IN transactions on EP0. This is either 127 bytes or 3
- * packets (which practically means 1 packet and 63 bytes of data) when the
- * MPS is set to 64.
- *
- * This means if we are wanting to move >127 bytes of data, we need to
- * split the transactions up, but just doing one packet at a time does
- * not work (this may be an implicit DATA0 PID on first packet of the
- * transaction) and doing 2 packets is outside the controller's limits.
- *
- * If we try to lower the MPS size for EP0, then no transfers work properly
- * for EP0, and the system will fail basic enumeration. As no cause for this
- * has currently been found, we cannot support any large IN transfers for
- * EP0.
- */
-#define EP0_MPS_LIMIT	64
-
-struct s3c_hsotg;
-struct s3c_hsotg_req;
-
-/**
- * struct s3c_hsotg_ep - driver endpoint definition.
- * @ep: The gadget layer representation of the endpoint.
- * @name: The driver generated name for the endpoint.
- * @queue: Queue of requests for this endpoint.
- * @parent: Reference back to the parent device structure.
- * @req: The current request that the endpoint is processing. This is
- *       used to indicate an request has been loaded onto the endpoint
- *       and has yet to be completed (maybe due to data move, or simply
- *	 awaiting an ack from the core all the data has been completed).
- * @debugfs: File entry for debugfs file for this endpoint.
- * @lock: State lock to protect contents of endpoint.
- * @dir_in: Set to true if this endpoint is of the IN direction, which
- *	    means that it is sending data to the Host.
- * @index: The index for the endpoint registers.
- * @name: The name array passed to the USB core.
- * @halted: Set if the endpoint has been halted.
- * @periodic: Set if this is a periodic ep, such as Interrupt
- * @sent_zlp: Set if we've sent a zero-length packet.
- * @total_data: The total number of data bytes done.
- * @fifo_size: The size of the FIFO (for periodic IN endpoints)
- * @fifo_load: The amount of data loaded into the FIFO (periodic IN)
- * @last_load: The offset of data for the last start of request.
- * @size_loaded: The last loaded size for DxEPTSIZE for periodic IN
- *
- * This is the driver's state for each registered enpoint, allowing it
- * to keep track of transactions that need doing. Each endpoint has a
- * lock to protect the state, to try and avoid using an overall lock
- * for the host controller as much as possible.
- *
- * For periodic IN endpoints, we have fifo_size and fifo_load to try
- * and keep track of the amount of data in the periodic FIFO for each
- * of these as we don't have a status register that tells us how much
- * is in each of them. (note, this may actually be useless information
- * as in shared-fifo mode periodic in acts like a single-frame packet
- * buffer than a fifo)
- */
-struct s3c_hsotg_ep {
-	struct usb_ep		ep;
-	struct list_head	queue;
-	struct s3c_hsotg	*parent;
-	struct s3c_hsotg_req	*req;
-	struct dentry		*debugfs;
-
-	spinlock_t		lock;
-
-	unsigned long		total_data;
-	unsigned int		size_loaded;
-	unsigned int		last_load;
-	unsigned int		fifo_load;
-	unsigned short		fifo_size;
-
-	unsigned char		dir_in;
-	unsigned char		index;
-
-	unsigned int		halted:1;
-	unsigned int		periodic:1;
-	unsigned int		sent_zlp:1;
-
-	char			name[10];
-};
-
-#define S3C_HSOTG_EPS	(8+1)	/* limit to 9 for the moment */
-
-/**
- * struct s3c_hsotg - driver state.
- * @dev: The parent device supplied to the probe function
- * @driver: USB gadget driver
- * @plat: The platform specific configuration data.
- * @regs: The memory area mapped for accessing registers.
- * @regs_res: The resource that was allocated when claiming register space.
- * @irq: The IRQ number we are using
- * @dedicated_fifos: Set if the hardware has dedicated IN-EP fifos.
- * @debug_root: root directrory for debugfs.
- * @debug_file: main status file for debugfs.
- * @debug_fifo: FIFO status file for debugfs.
- * @ep0_reply: Request used for ep0 reply.
- * @ep0_buff: Buffer for EP0 reply data, if needed.
- * @ctrl_buff: Buffer for EP0 control requests.
- * @ctrl_req: Request for EP0 control packets.
- * @eps: The endpoints being supplied to the gadget framework
- */
-struct s3c_hsotg {
-	struct device		 *dev;
-	struct usb_gadget_driver *driver;
-	struct s3c_hsotg_plat	 *plat;
-
-	void __iomem		*regs;
-	struct resource		*regs_res;
-	int			irq;
-	struct clk		*clk;
-
-	unsigned int		dedicated_fifos:1;
-
-	struct dentry		*debug_root;
-	struct dentry		*debug_file;
-	struct dentry		*debug_fifo;
-
-	struct usb_request	*ep0_reply;
-	struct usb_request	*ctrl_req;
-	u8			ep0_buff[8];
-	u8			ctrl_buff[8];
-
-	struct usb_gadget	gadget;
-	struct s3c_hsotg_ep	eps[];
-};
-
-/**
- * struct s3c_hsotg_req - data transfer request
- * @req: The USB gadget request
- * @queue: The list of requests for the endpoint this is queued for.
- * @in_progress: Has already had size/packets written to core
- * @mapped: DMA buffer for this request has been mapped via dma_map_single().
- */
-struct s3c_hsotg_req {
-	struct usb_request	req;
-	struct list_head	queue;
-	unsigned char		in_progress;
-	unsigned char		mapped;
-};
-
-/* conversion functions */
-static inline struct s3c_hsotg_req *our_req(struct usb_request *req)
-{
-	return container_of(req, struct s3c_hsotg_req, req);
-}
-
-static inline struct s3c_hsotg_ep *our_ep(struct usb_ep *ep)
-{
-	return container_of(ep, struct s3c_hsotg_ep, ep);
-}
-
-static inline struct s3c_hsotg *to_hsotg(struct usb_gadget *gadget)
-{
-	return container_of(gadget, struct s3c_hsotg, gadget);
-}
-
-static inline void __orr32(void __iomem *ptr, u32 val)
-{
-	writel(readl(ptr) | val, ptr);
-}
-
-static inline void __bic32(void __iomem *ptr, u32 val)
-{
-	writel(readl(ptr) & ~val, ptr);
-}
-
-/* forward decleration of functions */
-static void s3c_hsotg_dump(struct s3c_hsotg *hsotg);
-
-/**
- * using_dma - return the DMA status of the driver.
- * @hsotg: The driver state.
- *
- * Return true if we're using DMA.
- *
- * Currently, we have the DMA support code worked into everywhere
- * that needs it, but the AMBA DMA implementation in the hardware can
- * only DMA from 32bit aligned addresses. This means that gadgets such
- * as the CDC Ethernet cannot work as they often pass packets which are
- * not 32bit aligned.
- *
- * Unfortunately the choice to use DMA or not is global to the controller
- * and seems to be only settable when the controller is being put through
- * a core reset. This means we either need to fix the gadgets to take
- * account of DMA alignment, or add bounce buffers (yuerk).
- *
- * Until this issue is sorted out, we always return 'false'.
- */
-static inline bool using_dma(struct s3c_hsotg *hsotg)
-{
-	return false;	/* support is not complete */
-}
-
-/**
- * s3c_hsotg_en_gsint - enable one or more of the general interrupt
- * @hsotg: The device state
- * @ints: A bitmask of the interrupts to enable
- */
-static void s3c_hsotg_en_gsint(struct s3c_hsotg *hsotg, u32 ints)
-{
-	u32 gsintmsk = readl(hsotg->regs + S3C_GINTMSK);
-	u32 new_gsintmsk;
-
-	new_gsintmsk = gsintmsk | ints;
-
-	if (new_gsintmsk != gsintmsk) {
-		dev_dbg(hsotg->dev, "gsintmsk now 0x%08x\n", new_gsintmsk);
-		writel(new_gsintmsk, hsotg->regs + S3C_GINTMSK);
-	}
-}
-
-/**
- * s3c_hsotg_disable_gsint - disable one or more of the general interrupt
- * @hsotg: The device state
- * @ints: A bitmask of the interrupts to enable
- */
-static void s3c_hsotg_disable_gsint(struct s3c_hsotg *hsotg, u32 ints)
-{
-	u32 gsintmsk = readl(hsotg->regs + S3C_GINTMSK);
-	u32 new_gsintmsk;
-
-	new_gsintmsk = gsintmsk & ~ints;
-
-	if (new_gsintmsk != gsintmsk)
-		writel(new_gsintmsk, hsotg->regs + S3C_GINTMSK);
-}
-
-/**
- * s3c_hsotg_ctrl_epint - enable/disable an endpoint irq
- * @hsotg: The device state
- * @ep: The endpoint index
- * @dir_in: True if direction is in.
- * @en: The enable value, true to enable
- *
- * Set or clear the mask for an individual endpoint's interrupt
- * request.
- */
-static void s3c_hsotg_ctrl_epint(struct s3c_hsotg *hsotg,
-				 unsigned int ep, unsigned int dir_in,
-				 unsigned int en)
-{
-	unsigned long flags;
-	u32 bit = 1 << ep;
-	u32 daint;
-
-	if (!dir_in)
-		bit <<= 16;
-
-	local_irq_save(flags);
-	daint = readl(hsotg->regs + S3C_DAINTMSK);
-	if (en)
-		daint |= bit;
-	else
-		daint &= ~bit;
-	writel(daint, hsotg->regs + S3C_DAINTMSK);
-	local_irq_restore(flags);
-}
-
-/**
- * s3c_hsotg_init_fifo - initialise non-periodic FIFOs
- * @hsotg: The device instance.
- */
-static void s3c_hsotg_init_fifo(struct s3c_hsotg *hsotg)
-{
-	unsigned int ep;
-	unsigned int addr;
-	unsigned int size;
-	int timeout;
-	u32 val;
-
-	/* the ryu 2.6.24 release ahs
-	   writel(0x1C0, hsotg->regs + S3C_GRXFSIZ);
-	   writel(S3C_GNPTXFSIZ_NPTxFStAddr(0x200) |
-		S3C_GNPTXFSIZ_NPTxFDep(0x1C0),
-		hsotg->regs + S3C_GNPTXFSIZ);
-	*/
-
-	/* set FIFO sizes to 2048/1024 */
-
-	writel(2048, hsotg->regs + S3C_GRXFSIZ);
-	writel(S3C_GNPTXFSIZ_NPTxFStAddr(2048) |
-	       S3C_GNPTXFSIZ_NPTxFDep(1024),
-	       hsotg->regs + S3C_GNPTXFSIZ);
-
-	/* arange all the rest of the TX FIFOs, as some versions of this
-	 * block have overlapping default addresses. This also ensures
-	 * that if the settings have been changed, then they are set to
-	 * known values. */
-
-	/* start at the end of the GNPTXFSIZ, rounded up */
-	addr = 2048 + 1024;
-	size = 768;
-
-	/* currently we allocate TX FIFOs for all possible endpoints,
-	 * and assume that they are all the same size. */
-
-	for (ep = 1; ep <= 15; ep++) {
-		val = addr;
-		val |= size << S3C_DPTXFSIZn_DPTxFSize_SHIFT;
-		addr += size;
-
-		writel(val, hsotg->regs + S3C_DPTXFSIZn(ep));
-	}
-
-	/* according to p428 of the design guide, we need to ensure that
-	 * all fifos are flushed before continuing */
-
-	writel(S3C_GRSTCTL_TxFNum(0x10) | S3C_GRSTCTL_TxFFlsh |
-	       S3C_GRSTCTL_RxFFlsh, hsotg->regs + S3C_GRSTCTL);
-
-	/* wait until the fifos are both flushed */
-	timeout = 100;
-	while (1) {
-		val = readl(hsotg->regs + S3C_GRSTCTL);
-
-		if ((val & (S3C_GRSTCTL_TxFFlsh | S3C_GRSTCTL_RxFFlsh)) == 0)
-			break;
-
-		if (--timeout == 0) {
-			dev_err(hsotg->dev,
-				"%s: timeout flushing fifos (GRSTCTL=%08x)\n",
-				__func__, val);
-		}
-
-		udelay(1);
-	}
-
-	dev_dbg(hsotg->dev, "FIFOs reset, timeout at %d\n", timeout);
-}
-
-/**
- * @ep: USB endpoint to allocate request for.
- * @flags: Allocation flags
- *
- * Allocate a new USB request structure appropriate for the specified endpoint
- */
-static struct usb_request *s3c_hsotg_ep_alloc_request(struct usb_ep *ep,
-						      gfp_t flags)
-{
-	struct s3c_hsotg_req *req;
-
-	req = kzalloc(sizeof(struct s3c_hsotg_req), flags);
-	if (!req)
-		return NULL;
-
-	INIT_LIST_HEAD(&req->queue);
-
-	req->req.dma = DMA_ADDR_INVALID;
-	return &req->req;
-}
-
-/**
- * is_ep_periodic - return true if the endpoint is in periodic mode.
- * @hs_ep: The endpoint to query.
- *
- * Returns true if the endpoint is in periodic mode, meaning it is being
- * used for an Interrupt or ISO transfer.
- */
-static inline int is_ep_periodic(struct s3c_hsotg_ep *hs_ep)
-{
-	return hs_ep->periodic;
-}
-
-/**
- * s3c_hsotg_unmap_dma - unmap the DMA memory being used for the request
- * @hsotg: The device state.
- * @hs_ep: The endpoint for the request
- * @hs_req: The request being processed.
- *
- * This is the reverse of s3c_hsotg_map_dma(), called for the completion
- * of a request to ensure the buffer is ready for access by the caller.
-*/
-static void s3c_hsotg_unmap_dma(struct s3c_hsotg *hsotg,
-				struct s3c_hsotg_ep *hs_ep,
-				struct s3c_hsotg_req *hs_req)
-{
-	struct usb_request *req = &hs_req->req;
-	enum dma_data_direction dir;
-
-	dir = hs_ep->dir_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
-
-	/* ignore this if we're not moving any data */
-	if (hs_req->req.length == 0)
-		return;
-
-	if (hs_req->mapped) {
-		/* we mapped this, so unmap and remove the dma */
-
-		dma_unmap_single(hsotg->dev, req->dma, req->length, dir);
-
-		req->dma = DMA_ADDR_INVALID;
-		hs_req->mapped = 0;
-	} else {
-		dma_sync_single_for_cpu(hsotg->dev, req->dma, req->length, dir);
-	}
-}
-
-/**
- * s3c_hsotg_write_fifo - write packet Data to the TxFIFO
- * @hsotg: The controller state.
- * @hs_ep: The endpoint we're going to write for.
- * @hs_req: The request to write data for.
- *
- * This is called when the TxFIFO has some space in it to hold a new
- * transmission and we have something to give it. The actual setup of
- * the data size is done elsewhere, so all we have to do is to actually
- * write the data.
- *
- * The return value is zero if there is more space (or nothing was done)
- * otherwise -ENOSPC is returned if the FIFO space was used up.
- *
- * This routine is only needed for PIO
-*/
-static int s3c_hsotg_write_fifo(struct s3c_hsotg *hsotg,
-				struct s3c_hsotg_ep *hs_ep,
-				struct s3c_hsotg_req *hs_req)
-{
-	bool periodic = is_ep_periodic(hs_ep);
-	u32 gnptxsts = readl(hsotg->regs + S3C_GNPTXSTS);
-	int buf_pos = hs_req->req.actual;
-	int to_write = hs_ep->size_loaded;
-	void *data;
-	int can_write;
-	int pkt_round;
-
-	to_write -= (buf_pos - hs_ep->last_load);
-
-	/* if there's nothing to write, get out early */
-	if (to_write == 0)
-		return 0;
-
-	if (periodic && !hsotg->dedicated_fifos) {
-		u32 epsize = readl(hsotg->regs + S3C_DIEPTSIZ(hs_ep->index));
-		int size_left;
-		int size_done;
-
-		/* work out how much data was loaded so we can calculate
-		 * how much data is left in the fifo. */
-
-		size_left = S3C_DxEPTSIZ_XferSize_GET(epsize);
-
-		/* if shared fifo, we cannot write anything until the
-		 * previous data has been completely sent.
-		 */
-		if (hs_ep->fifo_load != 0) {
-			s3c_hsotg_en_gsint(hsotg, S3C_GINTSTS_PTxFEmp);
-			return -ENOSPC;
-		}
-
-		dev_dbg(hsotg->dev, "%s: left=%d, load=%d, fifo=%d, size %d\n",
-			__func__, size_left,
-			hs_ep->size_loaded, hs_ep->fifo_load, hs_ep->fifo_size);
-
-		/* how much of the data has moved */
-		size_done = hs_ep->size_loaded - size_left;
-
-		/* how much data is left in the fifo */
-		can_write = hs_ep->fifo_load - size_done;
-		dev_dbg(hsotg->dev, "%s: => can_write1=%d\n",
-			__func__, can_write);
-
-		can_write = hs_ep->fifo_size - can_write;
-		dev_dbg(hsotg->dev, "%s: => can_write2=%d\n",
-			__func__, can_write);
-
-		if (can_write <= 0) {
-			s3c_hsotg_en_gsint(hsotg, S3C_GINTSTS_PTxFEmp);
-			return -ENOSPC;
-		}
-	} else if (hsotg->dedicated_fifos && hs_ep->index != 0) {
-		can_write = readl(hsotg->regs + S3C_DTXFSTS(hs_ep->index));
-
-		can_write &= 0xffff;
-		can_write *= 4;
-	} else {
-		if (S3C_GNPTXSTS_NPTxQSpcAvail_GET(gnptxsts) == 0) {
-			dev_dbg(hsotg->dev,
-				"%s: no queue slots available (0x%08x)\n",
-				__func__, gnptxsts);
-
-			s3c_hsotg_en_gsint(hsotg, S3C_GINTSTS_NPTxFEmp);
-			return -ENOSPC;
-		}
-
-		can_write = S3C_GNPTXSTS_NPTxFSpcAvail_GET(gnptxsts);
-		can_write *= 4;	/* fifo size is in 32bit quantities. */
-	}
-
-	dev_dbg(hsotg->dev, "%s: GNPTXSTS=%08x, can=%d, to=%d, mps %d\n",
-		 __func__, gnptxsts, can_write, to_write, hs_ep->ep.maxpacket);
-
-	/* limit to 512 bytes of data, it seems at least on the non-periodic
-	 * FIFO, requests of >512 cause the endpoint to get stuck with a
-	 * fragment of the end of the transfer in it.
-	 */
-	if (can_write > 512)
-		can_write = 512;
-
-	/* limit the write to one max-packet size worth of data, but allow
-	 * the transfer to return that it did not run out of fifo space
-	 * doing it. */
-	if (to_write > hs_ep->ep.maxpacket) {
-		to_write = hs_ep->ep.maxpacket;
-
-		s3c_hsotg_en_gsint(hsotg,
-				   periodic ? S3C_GINTSTS_PTxFEmp :
-				   S3C_GINTSTS_NPTxFEmp);
-	}
-
-	/* see if we can write data */
-
-	if (to_write > can_write) {
-		to_write = can_write;
-		pkt_round = to_write % hs_ep->ep.maxpacket;
-
-		/* Not sure, but we probably shouldn't be writing partial
-		 * packets into the FIFO, so round the write down to an
-		 * exact number of packets.
-		 *
-		 * Note, we do not currently check to see if we can ever
-		 * write a full packet or not to the FIFO.
-		 */
-
-		if (pkt_round)
-			to_write -= pkt_round;
-
-		/* enable correct FIFO interrupt to alert us when there
-		 * is more room left. */
-
-		s3c_hsotg_en_gsint(hsotg,
-				   periodic ? S3C_GINTSTS_PTxFEmp :
-				   S3C_GINTSTS_NPTxFEmp);
-	}
-
-	dev_dbg(hsotg->dev, "write %d/%d, can_write %d, done %d\n",
-		 to_write, hs_req->req.length, can_write, buf_pos);
-
-	if (to_write <= 0)
-		return -ENOSPC;
-
-	hs_req->req.actual = buf_pos + to_write;
-	hs_ep->total_data += to_write;
-
-	if (periodic)
-		hs_ep->fifo_load += to_write;
-
-	to_write = DIV_ROUND_UP(to_write, 4);
-	data = hs_req->req.buf + buf_pos;
-
-	writesl(hsotg->regs + S3C_EPFIFO(hs_ep->index), data, to_write);
-
-	return (to_write >= can_write) ? -ENOSPC : 0;
-}
-
-/**
- * get_ep_limit - get the maximum data legnth for this endpoint
- * @hs_ep: The endpoint
- *
- * Return the maximum data that can be queued in one go on a given endpoint
- * so that transfers that are too long can be split.
- */
-static unsigned get_ep_limit(struct s3c_hsotg_ep *hs_ep)
-{
-	int index = hs_ep->index;
-	unsigned maxsize;
-	unsigned maxpkt;
-
-	if (index != 0) {
-		maxsize = S3C_DxEPTSIZ_XferSize_LIMIT + 1;
-		maxpkt = S3C_DxEPTSIZ_PktCnt_LIMIT + 1;
-	} else {
-		maxsize = 64+64;
-		if (hs_ep->dir_in)
-			maxpkt = S3C_DIEPTSIZ0_PktCnt_LIMIT + 1;
-		else
-			maxpkt = 2;
-	}
-
-	/* we made the constant loading easier above by using +1 */
-	maxpkt--;
-	maxsize--;
-
-	/* constrain by packet count if maxpkts*pktsize is greater
-	 * than the length register size. */
-
-	if ((maxpkt * hs_ep->ep.maxpacket) < maxsize)
-		maxsize = maxpkt * hs_ep->ep.maxpacket;
-
-	return maxsize;
-}
-
-/**
- * s3c_hsotg_start_req - start a USB request from an endpoint's queue
- * @hsotg: The controller state.
- * @hs_ep: The endpoint to process a request for
- * @hs_req: The request to start.
- * @continuing: True if we are doing more for the current request.
- *
- * Start the given request running by setting the endpoint registers
- * appropriately, and writing any data to the FIFOs.
- */
-static void s3c_hsotg_start_req(struct s3c_hsotg *hsotg,
-				struct s3c_hsotg_ep *hs_ep,
-				struct s3c_hsotg_req *hs_req,
-				bool continuing)
-{
-	struct usb_request *ureq = &hs_req->req;
-	int index = hs_ep->index;
-	int dir_in = hs_ep->dir_in;
-	u32 epctrl_reg;
-	u32 epsize_reg;
-	u32 epsize;
-	u32 ctrl;
-	unsigned length;
-	unsigned packets;
-	unsigned maxreq;
-
-	if (index != 0) {
-		if (hs_ep->req && !continuing) {
-			dev_err(hsotg->dev, "%s: active request\n", __func__);
-			WARN_ON(1);
-			return;
-		} else if (hs_ep->req != hs_req && continuing) {
-			dev_err(hsotg->dev,
-				"%s: continue different req\n", __func__);
-			WARN_ON(1);
-			return;
-		}
-	}
-
-	epctrl_reg = dir_in ? S3C_DIEPCTL(index) : S3C_DOEPCTL(index);
-	epsize_reg = dir_in ? S3C_DIEPTSIZ(index) : S3C_DOEPTSIZ(index);
-
-	dev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x, ep %d, dir %s\n",
-		__func__, readl(hsotg->regs + epctrl_reg), index,
-		hs_ep->dir_in ? "in" : "out");
-
-	/* If endpoint is stalled, we will restart request later */
-	ctrl = readl(hsotg->regs + epctrl_reg);
-
-	if (ctrl & S3C_DxEPCTL_Stall) {
-		dev_warn(hsotg->dev, "%s: ep%d is stalled\n", __func__, index);
-		return;
-	}
-
-	length = ureq->length - ureq->actual;
-
-	if (0)
-		dev_dbg(hsotg->dev,
-			"REQ buf %p len %d dma 0x%08x noi=%d zp=%d snok=%d\n",
-			ureq->buf, length, ureq->dma,
-			ureq->no_interrupt, ureq->zero, ureq->short_not_ok);
-
-	maxreq = get_ep_limit(hs_ep);
-	if (length > maxreq) {
-		int round = maxreq % hs_ep->ep.maxpacket;
-
-		dev_dbg(hsotg->dev, "%s: length %d, max-req %d, r %d\n",
-			__func__, length, maxreq, round);
-
-		/* round down to multiple of packets */
-		if (round)
-			maxreq -= round;
-
-		length = maxreq;
-	}
-
-	if (length)
-		packets = DIV_ROUND_UP(length, hs_ep->ep.maxpacket);
-	else
-		packets = 1;	/* send one packet if length is zero. */
-
-	if (dir_in && index != 0)
-		epsize = S3C_DxEPTSIZ_MC(1);
-	else
-		epsize = 0;
-
-	if (index != 0 && ureq->zero) {
-		/* test for the packets being exactly right for the
-		 * transfer */
-
-		if (length == (packets * hs_ep->ep.maxpacket))
-			packets++;
-	}
-
-	epsize |= S3C_DxEPTSIZ_PktCnt(packets);
-	epsize |= S3C_DxEPTSIZ_XferSize(length);
-
-	dev_dbg(hsotg->dev, "%s: %d@%d/%d, 0x%08x => 0x%08x\n",
-		__func__, packets, length, ureq->length, epsize, epsize_reg);
-
-	/* store the request as the current one we're doing */
-	hs_ep->req = hs_req;
-
-	/* write size / packets */
-	writel(epsize, hsotg->regs + epsize_reg);
-
-	if (using_dma(hsotg) && !continuing) {
-		unsigned int dma_reg;
-
-		/* write DMA address to control register, buffer already
-		 * synced by s3c_hsotg_ep_queue().  */
-
-		dma_reg = dir_in ? S3C_DIEPDMA(index) : S3C_DOEPDMA(index);
-		writel(ureq->dma, hsotg->regs + dma_reg);
-
-		dev_dbg(hsotg->dev, "%s: 0x%08x => 0x%08x\n",
-			__func__, ureq->dma, dma_reg);
-	}
-
-	ctrl |= S3C_DxEPCTL_EPEna;	/* ensure ep enabled */
-	ctrl |= S3C_DxEPCTL_USBActEp;
-	ctrl |= S3C_DxEPCTL_CNAK;	/* clear NAK set by core */
-
-	dev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x\n", __func__, ctrl);
-	writel(ctrl, hsotg->regs + epctrl_reg);
-
-	/* set these, it seems that DMA support increments past the end
-	 * of the packet buffer so we need to calculate the length from
-	 * this information. */
-	hs_ep->size_loaded = length;
-	hs_ep->last_load = ureq->actual;
-
-	if (dir_in && !using_dma(hsotg)) {
-		/* set these anyway, we may need them for non-periodic in */
-		hs_ep->fifo_load = 0;
-
-		s3c_hsotg_write_fifo(hsotg, hs_ep, hs_req);
-	}
-
-	/* clear the INTknTXFEmpMsk when we start request, more as a aide
-	 * to debugging to see what is going on. */
-	if (dir_in)
-		writel(S3C_DIEPMSK_INTknTXFEmpMsk,
-		       hsotg->regs + S3C_DIEPINT(index));
-
-	/* Note, trying to clear the NAK here causes problems with transmit
-	 * on the S3C6400 ending up with the TXFIFO becoming full. */
-
-	/* check ep is enabled */
-	if (!(readl(hsotg->regs + epctrl_reg) & S3C_DxEPCTL_EPEna))
-		dev_warn(hsotg->dev,
-			 "ep%d: failed to become enabled (DxEPCTL=0x%08x)?\n",
-			 index, readl(hsotg->regs + epctrl_reg));
-
-	dev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x\n",
-		__func__, readl(hsotg->regs + epctrl_reg));
-}
-
-/**
- * s3c_hsotg_map_dma - map the DMA memory being used for the request
- * @hsotg: The device state.
- * @hs_ep: The endpoint the request is on.
- * @req: The request being processed.
- *
- * We've been asked to queue a request, so ensure that the memory buffer
- * is correctly setup for DMA. If we've been passed an extant DMA address
- * then ensure the buffer has been synced to memory. If our buffer has no
- * DMA memory, then we map the memory and mark our request to allow us to
- * cleanup on completion.
-*/
-static int s3c_hsotg_map_dma(struct s3c_hsotg *hsotg,
-			     struct s3c_hsotg_ep *hs_ep,
-			     struct usb_request *req)
-{
-	enum dma_data_direction dir;
-	struct s3c_hsotg_req *hs_req = our_req(req);
-
-	dir = hs_ep->dir_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
-
-	/* if the length is zero, ignore the DMA data */
-	if (hs_req->req.length == 0)
-		return 0;
-
-	if (req->dma == DMA_ADDR_INVALID) {
-		dma_addr_t dma;
-
-		dma = dma_map_single(hsotg->dev, req->buf, req->length, dir);
-
-		if (unlikely(dma_mapping_error(hsotg->dev, dma)))
-			goto dma_error;
-
-		if (dma & 3) {
-			dev_err(hsotg->dev, "%s: unaligned dma buffer\n",
-				__func__);
-
-			dma_unmap_single(hsotg->dev, dma, req->length, dir);
-			return -EINVAL;
-		}
-
-		hs_req->mapped = 1;
-		req->dma = dma;
-	} else {
-		dma_sync_single_for_cpu(hsotg->dev, req->dma, req->length, dir);
-		hs_req->mapped = 0;
-	}
-
-	return 0;
-
-dma_error:
-	dev_err(hsotg->dev, "%s: failed to map buffer %p, %d bytes\n",
-		__func__, req->buf, req->length);
-
-	return -EIO;
-}
-
-static int s3c_hsotg_ep_queue(struct usb_ep *ep, struct usb_request *req,
-			      gfp_t gfp_flags)
-{
-	struct s3c_hsotg_req *hs_req = our_req(req);
-	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
-	struct s3c_hsotg *hs = hs_ep->parent;
-	unsigned long irqflags;
-	bool first;
-
-	dev_dbg(hs->dev, "%s: req %p: %d@%p, noi=%d, zero=%d, snok=%d\n",
-		ep->name, req, req->length, req->buf, req->no_interrupt,
-		req->zero, req->short_not_ok);
-
-	/* initialise status of the request */
-	INIT_LIST_HEAD(&hs_req->queue);
-	req->actual = 0;
-	req->status = -EINPROGRESS;
-
-	/* if we're using DMA, sync the buffers as necessary */
-	if (using_dma(hs)) {
-		int ret = s3c_hsotg_map_dma(hs, hs_ep, req);
-		if (ret)
-			return ret;
-	}
-
-	spin_lock_irqsave(&hs_ep->lock, irqflags);
-
-	first = list_empty(&hs_ep->queue);
-	list_add_tail(&hs_req->queue, &hs_ep->queue);
-
-	if (first)
-		s3c_hsotg_start_req(hs, hs_ep, hs_req, false);
-
-	spin_unlock_irqrestore(&hs_ep->lock, irqflags);
-
-	return 0;
-}
-
-static void s3c_hsotg_ep_free_request(struct usb_ep *ep,
-				      struct usb_request *req)
-{
-	struct s3c_hsotg_req *hs_req = our_req(req);
-
-	kfree(hs_req);
-}
-
-/**
- * s3c_hsotg_complete_oursetup - setup completion callback
- * @ep: The endpoint the request was on.
- * @req: The request completed.
- *
- * Called on completion of any requests the driver itself
- * submitted that need cleaning up.
- */
-static void s3c_hsotg_complete_oursetup(struct usb_ep *ep,
-					struct usb_request *req)
-{
-	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
-	struct s3c_hsotg *hsotg = hs_ep->parent;
-
-	dev_dbg(hsotg->dev, "%s: ep %p, req %p\n", __func__, ep, req);
-
-	s3c_hsotg_ep_free_request(ep, req);
-}
-
-/**
- * ep_from_windex - convert control wIndex value to endpoint
- * @hsotg: The driver state.
- * @windex: The control request wIndex field (in host order).
- *
- * Convert the given wIndex into a pointer to an driver endpoint
- * structure, or return NULL if it is not a valid endpoint.
-*/
-static struct s3c_hsotg_ep *ep_from_windex(struct s3c_hsotg *hsotg,
-					   u32 windex)
-{
-	struct s3c_hsotg_ep *ep = &hsotg->eps[windex & 0x7F];
-	int dir = (windex & USB_DIR_IN) ? 1 : 0;
-	int idx = windex & 0x7F;
-
-	if (windex >= 0x100)
-		return NULL;
-
-	if (idx > S3C_HSOTG_EPS)
-		return NULL;
-
-	if (idx && ep->dir_in != dir)
-		return NULL;
-
-	return ep;
-}
-
-/**
- * s3c_hsotg_send_reply - send reply to control request
- * @hsotg: The device state
- * @ep: Endpoint 0
- * @buff: Buffer for request
- * @length: Length of reply.
- *
- * Create a request and queue it on the given endpoint. This is useful as
- * an internal method of sending replies to certain control requests, etc.
- */
-static int s3c_hsotg_send_reply(struct s3c_hsotg *hsotg,
-				struct s3c_hsotg_ep *ep,
-				void *buff,
-				int length)
-{
-	struct usb_request *req;
-	int ret;
-
-	dev_dbg(hsotg->dev, "%s: buff %p, len %d\n", __func__, buff, length);
-
-	req = s3c_hsotg_ep_alloc_request(&ep->ep, GFP_ATOMIC);
-	hsotg->ep0_reply = req;
-	if (!req) {
-		dev_warn(hsotg->dev, "%s: cannot alloc req\n", __func__);
-		return -ENOMEM;
-	}
-
-	req->buf = hsotg->ep0_buff;
-	req->length = length;
-	req->zero = 1; /* always do zero-length final transfer */
-	req->complete = s3c_hsotg_complete_oursetup;
-
-	if (length)
-		memcpy(req->buf, buff, length);
-	else
-		ep->sent_zlp = 1;
-
-	ret = s3c_hsotg_ep_queue(&ep->ep, req, GFP_ATOMIC);
-	if (ret) {
-		dev_warn(hsotg->dev, "%s: cannot queue req\n", __func__);
-		return ret;
-	}
-
-	return 0;
-}
-
-/**
- * s3c_hsotg_process_req_status - process request GET_STATUS
- * @hsotg: The device state
- * @ctrl: USB control request
- */
-static int s3c_hsotg_process_req_status(struct s3c_hsotg *hsotg,
-					struct usb_ctrlrequest *ctrl)
-{
-	struct s3c_hsotg_ep *ep0 = &hsotg->eps[0];
-	struct s3c_hsotg_ep *ep;
-	__le16 reply;
-	int ret;
-
-	dev_dbg(hsotg->dev, "%s: USB_REQ_GET_STATUS\n", __func__);
-
-	if (!ep0->dir_in) {
-		dev_warn(hsotg->dev, "%s: direction out?\n", __func__);
-		return -EINVAL;
-	}
-
-	switch (ctrl->bRequestType & USB_RECIP_MASK) {
-	case USB_RECIP_DEVICE:
-		reply = cpu_to_le16(0); /* bit 0 => self powered,
-					 * bit 1 => remote wakeup */
-		break;
-
-	case USB_RECIP_INTERFACE:
-		/* currently, the data result should be zero */
-		reply = cpu_to_le16(0);
-		break;
-
-	case USB_RECIP_ENDPOINT:
-		ep = ep_from_windex(hsotg, le16_to_cpu(ctrl->wIndex));
-		if (!ep)
-			return -ENOENT;
-
-		reply = cpu_to_le16(ep->halted ? 1 : 0);
-		break;
-
-	default:
-		return 0;
-	}
-
-	if (le16_to_cpu(ctrl->wLength) != 2)
-		return -EINVAL;
-
-	ret = s3c_hsotg_send_reply(hsotg, ep0, &reply, 2);
-	if (ret) {
-		dev_err(hsotg->dev, "%s: failed to send reply\n", __func__);
-		return ret;
-	}
-
-	return 1;
-}
-
-static int s3c_hsotg_ep_sethalt(struct usb_ep *ep, int value);
-
-/**
- * get_ep_head - return the first request on the endpoint
- * @hs_ep: The controller endpoint to get
- *
- * Get the first request on the endpoint.
- */
-static struct s3c_hsotg_req *get_ep_head(struct s3c_hsotg_ep *hs_ep)
-{
-	if (list_empty(&hs_ep->queue))
-		return NULL;
-
-	return list_first_entry(&hs_ep->queue, struct s3c_hsotg_req, queue);
-}
-
-/**
- * s3c_hsotg_process_req_featire - process request {SET,CLEAR}_FEATURE
- * @hsotg: The device state
- * @ctrl: USB control request
- */
-static int s3c_hsotg_process_req_feature(struct s3c_hsotg *hsotg,
-					 struct usb_ctrlrequest *ctrl)
-{
-	struct s3c_hsotg_ep *ep0 = &hsotg->eps[0];
-	struct s3c_hsotg_req *hs_req;
-	bool restart;
-	bool set = (ctrl->bRequest == USB_REQ_SET_FEATURE);
-	struct s3c_hsotg_ep *ep;
-	int ret;
-
-	dev_dbg(hsotg->dev, "%s: %s_FEATURE\n",
-		__func__, set ? "SET" : "CLEAR");
-
-	if (ctrl->bRequestType == USB_RECIP_ENDPOINT) {
-		ep = ep_from_windex(hsotg, le16_to_cpu(ctrl->wIndex));
-		if (!ep) {
-			dev_dbg(hsotg->dev, "%s: no endpoint for 0x%04x\n",
-				__func__, le16_to_cpu(ctrl->wIndex));
-			return -ENOENT;
-		}
-
-		switch (le16_to_cpu(ctrl->wValue)) {
-		case USB_ENDPOINT_HALT:
-			s3c_hsotg_ep_sethalt(&ep->ep, set);
-
-			ret = s3c_hsotg_send_reply(hsotg, ep0, NULL, 0);
-			if (ret) {
-				dev_err(hsotg->dev,
-					"%s: failed to send reply\n", __func__);
-				return ret;
-			}
-
-			if (!set) {
-				/*
-				 * If we have request in progress,
-				 * then complete it
-				 */
-				if (ep->req) {
-					hs_req = ep->req;
-					ep->req = NULL;
-					list_del_init(&hs_req->queue);
-					hs_req->req.complete(&ep->ep,
-							     &hs_req->req);
-				}
-
-				/* If we have pending request, then start it */
-				restart = !list_empty(&ep->queue);
-				if (restart) {
-					hs_req = get_ep_head(ep);
-					s3c_hsotg_start_req(hsotg, ep,
-							    hs_req, false);
-				}
-			}
-
-			break;
-
-		default:
-			return -ENOENT;
-		}
-	} else
-		return -ENOENT;  /* currently only deal with endpoint */
-
-	return 1;
-}
-
-/**
- * s3c_hsotg_process_control - process a control request
- * @hsotg: The device state
- * @ctrl: The control request received
- *
- * The controller has received the SETUP phase of a control request, and
- * needs to work out what to do next (and whether to pass it on to the
- * gadget driver).
- */
-static void s3c_hsotg_process_control(struct s3c_hsotg *hsotg,
-				      struct usb_ctrlrequest *ctrl)
-{
-	struct s3c_hsotg_ep *ep0 = &hsotg->eps[0];
-	int ret = 0;
-	u32 dcfg;
-
-	ep0->sent_zlp = 0;
-
-	dev_dbg(hsotg->dev, "ctrl Req=%02x, Type=%02x, V=%04x, L=%04x\n",
-		 ctrl->bRequest, ctrl->bRequestType,
-		 ctrl->wValue, ctrl->wLength);
-
-	/* record the direction of the request, for later use when enquing
-	 * packets onto EP0. */
-
-	ep0->dir_in = (ctrl->bRequestType & USB_DIR_IN) ? 1 : 0;
-	dev_dbg(hsotg->dev, "ctrl: dir_in=%d\n", ep0->dir_in);
-
-	/* if we've no data with this request, then the last part of the
-	 * transaction is going to implicitly be IN. */
-	if (ctrl->wLength == 0)
-		ep0->dir_in = 1;
-
-	if ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {
-		switch (ctrl->bRequest) {
-		case USB_REQ_SET_ADDRESS:
-			dcfg = readl(hsotg->regs + S3C_DCFG);
-			dcfg &= ~S3C_DCFG_DevAddr_MASK;
-			dcfg |= ctrl->wValue << S3C_DCFG_DevAddr_SHIFT;
-			writel(dcfg, hsotg->regs + S3C_DCFG);
-
-			dev_info(hsotg->dev, "new address %d\n", ctrl->wValue);
-
-			ret = s3c_hsotg_send_reply(hsotg, ep0, NULL, 0);
-			return;
-
-		case USB_REQ_GET_STATUS:
-			ret = s3c_hsotg_process_req_status(hsotg, ctrl);
-			break;
-
-		case USB_REQ_CLEAR_FEATURE:
-		case USB_REQ_SET_FEATURE:
-			ret = s3c_hsotg_process_req_feature(hsotg, ctrl);
-			break;
-		}
-	}
-
-	/* as a fallback, try delivering it to the driver to deal with */
-
-	if (ret == 0 && hsotg->driver) {
-		ret = hsotg->driver->setup(&hsotg->gadget, ctrl);
-		if (ret < 0)
-			dev_dbg(hsotg->dev, "driver->setup() ret %d\n", ret);
-	}
-
-	/* the request is either unhandlable, or is not formatted correctly
-	 * so respond with a STALL for the status stage to indicate failure.
-	 */
-
-	if (ret < 0) {
-		u32 reg;
-		u32 ctrl;
-
-		dev_dbg(hsotg->dev, "ep0 stall (dir=%d)\n", ep0->dir_in);
-		reg = (ep0->dir_in) ? S3C_DIEPCTL0 : S3C_DOEPCTL0;
-
-		/* S3C_DxEPCTL_Stall will be cleared by EP once it has
-		 * taken effect, so no need to clear later. */
-
-		ctrl = readl(hsotg->regs + reg);
-		ctrl |= S3C_DxEPCTL_Stall;
-		ctrl |= S3C_DxEPCTL_CNAK;
-		writel(ctrl, hsotg->regs + reg);
-
-		dev_dbg(hsotg->dev,
-			"written DxEPCTL=0x%08x to %08x (DxEPCTL=0x%08x)\n",
-			ctrl, reg, readl(hsotg->regs + reg));
-
-		/* don't believe we need to anything more to get the EP
-		 * to reply with a STALL packet */
-	}
-}
-
-static void s3c_hsotg_enqueue_setup(struct s3c_hsotg *hsotg);
-
-/**
- * s3c_hsotg_complete_setup - completion of a setup transfer
- * @ep: The endpoint the request was on.
- * @req: The request completed.
- *
- * Called on completion of any requests the driver itself submitted for
- * EP0 setup packets
- */
-static void s3c_hsotg_complete_setup(struct usb_ep *ep,
-				     struct usb_request *req)
-{
-	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
-	struct s3c_hsotg *hsotg = hs_ep->parent;
-
-	if (req->status < 0) {
-		dev_dbg(hsotg->dev, "%s: failed %d\n", __func__, req->status);
-		return;
-	}
-
-	if (req->actual == 0)
-		s3c_hsotg_enqueue_setup(hsotg);
-	else
-		s3c_hsotg_process_control(hsotg, req->buf);
-}
-
-/**
- * s3c_hsotg_enqueue_setup - start a request for EP0 packets
- * @hsotg: The device state.
- *
- * Enqueue a request on EP0 if necessary to received any SETUP packets
- * received from the host.
- */
-static void s3c_hsotg_enqueue_setup(struct s3c_hsotg *hsotg)
-{
-	struct usb_request *req = hsotg->ctrl_req;
-	struct s3c_hsotg_req *hs_req = our_req(req);
-	int ret;
-
-	dev_dbg(hsotg->dev, "%s: queueing setup request\n", __func__);
-
-	req->zero = 0;
-	req->length = 8;
-	req->buf = hsotg->ctrl_buff;
-	req->complete = s3c_hsotg_complete_setup;
-
-	if (!list_empty(&hs_req->queue)) {
-		dev_dbg(hsotg->dev, "%s already queued???\n", __func__);
-		return;
-	}
-
-	hsotg->eps[0].dir_in = 0;
-
-	ret = s3c_hsotg_ep_queue(&hsotg->eps[0].ep, req, GFP_ATOMIC);
-	if (ret < 0) {
-		dev_err(hsotg->dev, "%s: failed queue (%d)\n", __func__, ret);
-		/* Don't think there's much we can do other than watch the
-		 * driver fail. */
-	}
-}
-
-/**
- * s3c_hsotg_complete_request - complete a request given to us
- * @hsotg: The device state.
- * @hs_ep: The endpoint the request was on.
- * @hs_req: The request to complete.
- * @result: The result code (0 => Ok, otherwise errno)
- *
- * The given request has finished, so call the necessary completion
- * if it has one and then look to see if we can start a new request
- * on the endpoint.
- *
- * Note, expects the ep to already be locked as appropriate.
-*/
-static void s3c_hsotg_complete_request(struct s3c_hsotg *hsotg,
-				       struct s3c_hsotg_ep *hs_ep,
-				       struct s3c_hsotg_req *hs_req,
-				       int result)
-{
-	bool restart;
-
-	if (!hs_req) {
-		dev_dbg(hsotg->dev, "%s: nothing to complete?\n", __func__);
-		return;
-	}
-
-	dev_dbg(hsotg->dev, "complete: ep %p %s, req %p, %d => %p\n",
-		hs_ep, hs_ep->ep.name, hs_req, result, hs_req->req.complete);
-
-	/* only replace the status if we've not already set an error
-	 * from a previous transaction */
-
-	if (hs_req->req.status == -EINPROGRESS)
-		hs_req->req.status = result;
-
-	hs_ep->req = NULL;
-	list_del_init(&hs_req->queue);
-
-	if (using_dma(hsotg))
-		s3c_hsotg_unmap_dma(hsotg, hs_ep, hs_req);
-
-	/* call the complete request with the locks off, just in case the
-	 * request tries to queue more work for this endpoint. */
-
-	if (hs_req->req.complete) {
-		spin_unlock(&hs_ep->lock);
-		hs_req->req.complete(&hs_ep->ep, &hs_req->req);
-		spin_lock(&hs_ep->lock);
-	}
-
-	/* Look to see if there is anything else to do. Note, the completion
-	 * of the previous request may have caused a new request to be started
-	 * so be careful when doing this. */
-
-	if (!hs_ep->req && result >= 0) {
-		restart = !list_empty(&hs_ep->queue);
-		if (restart) {
-			hs_req = get_ep_head(hs_ep);
-			s3c_hsotg_start_req(hsotg, hs_ep, hs_req, false);
-		}
-	}
-}
-
-/**
- * s3c_hsotg_complete_request_lock - complete a request given to us (locked)
- * @hsotg: The device state.
- * @hs_ep: The endpoint the request was on.
- * @hs_req: The request to complete.
- * @result: The result code (0 => Ok, otherwise errno)
- *
- * See s3c_hsotg_complete_request(), but called with the endpoint's
- * lock held.
-*/
-static void s3c_hsotg_complete_request_lock(struct s3c_hsotg *hsotg,
-					    struct s3c_hsotg_ep *hs_ep,
-					    struct s3c_hsotg_req *hs_req,
-					    int result)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&hs_ep->lock, flags);
-	s3c_hsotg_complete_request(hsotg, hs_ep, hs_req, result);
-	spin_unlock_irqrestore(&hs_ep->lock, flags);
-}
-
-/**
- * s3c_hsotg_rx_data - receive data from the FIFO for an endpoint
- * @hsotg: The device state.
- * @ep_idx: The endpoint index for the data
- * @size: The size of data in the fifo, in bytes
- *
- * The FIFO status shows there is data to read from the FIFO for a given
- * endpoint, so sort out whether we need to read the data into a request
- * that has been made for that endpoint.
- */
-static void s3c_hsotg_rx_data(struct s3c_hsotg *hsotg, int ep_idx, int size)
-{
-	struct s3c_hsotg_ep *hs_ep = &hsotg->eps[ep_idx];
-	struct s3c_hsotg_req *hs_req = hs_ep->req;
-	void __iomem *fifo = hsotg->regs + S3C_EPFIFO(ep_idx);
-	int to_read;
-	int max_req;
-	int read_ptr;
-
-	if (!hs_req) {
-		u32 epctl = readl(hsotg->regs + S3C_DOEPCTL(ep_idx));
-		int ptr;
-
-		dev_warn(hsotg->dev,
-			 "%s: FIFO %d bytes on ep%d but no req (DxEPCTl=0x%08x)\n",
-			 __func__, size, ep_idx, epctl);
-
-		/* dump the data from the FIFO, we've nothing we can do */
-		for (ptr = 0; ptr < size; ptr += 4)
-			(void)readl(fifo);
-
-		return;
-	}
-
-	spin_lock(&hs_ep->lock);
-
-	to_read = size;
-	read_ptr = hs_req->req.actual;
-	max_req = hs_req->req.length - read_ptr;
-
-	dev_dbg(hsotg->dev, "%s: read %d/%d, done %d/%d\n",
-		__func__, to_read, max_req, read_ptr, hs_req->req.length);
-
-	if (to_read > max_req) {
-		/* more data appeared than we where willing
-		 * to deal with in this request.
-		 */
-
-		/* currently we don't deal this */
-		WARN_ON_ONCE(1);
-	}
-
-	hs_ep->total_data += to_read;
-	hs_req->req.actual += to_read;
-	to_read = DIV_ROUND_UP(to_read, 4);
-
-	/* note, we might over-write the buffer end by 3 bytes depending on
-	 * alignment of the data. */
-	readsl(fifo, hs_req->req.buf + read_ptr, to_read);
-
-	spin_unlock(&hs_ep->lock);
-}
-
-/**
- * s3c_hsotg_send_zlp - send zero-length packet on control endpoint
- * @hsotg: The device instance
- * @req: The request currently on this endpoint
- *
- * Generate a zero-length IN packet request for terminating a SETUP
- * transaction.
- *
- * Note, since we don't write any data to the TxFIFO, then it is
- * currently believed that we do not need to wait for any space in
- * the TxFIFO.
- */
-static void s3c_hsotg_send_zlp(struct s3c_hsotg *hsotg,
-			       struct s3c_hsotg_req *req)
-{
-	u32 ctrl;
-
-	if (!req) {
-		dev_warn(hsotg->dev, "%s: no request?\n", __func__);
-		return;
-	}
-
-	if (req->req.length == 0) {
-		hsotg->eps[0].sent_zlp = 1;
-		s3c_hsotg_enqueue_setup(hsotg);
-		return;
-	}
-
-	hsotg->eps[0].dir_in = 1;
-	hsotg->eps[0].sent_zlp = 1;
-
-	dev_dbg(hsotg->dev, "sending zero-length packet\n");
-
-	/* issue a zero-sized packet to terminate this */
-	writel(S3C_DxEPTSIZ_MC(1) | S3C_DxEPTSIZ_PktCnt(1) |
-	       S3C_DxEPTSIZ_XferSize(0), hsotg->regs + S3C_DIEPTSIZ(0));
-
-	ctrl = readl(hsotg->regs + S3C_DIEPCTL0);
-	ctrl |= S3C_DxEPCTL_CNAK;  /* clear NAK set by core */
-	ctrl |= S3C_DxEPCTL_EPEna; /* ensure ep enabled */
-	ctrl |= S3C_DxEPCTL_USBActEp;
-	writel(ctrl, hsotg->regs + S3C_DIEPCTL0);
-}
-
-/**
- * s3c_hsotg_handle_outdone - handle receiving OutDone/SetupDone from RXFIFO
- * @hsotg: The device instance
- * @epnum: The endpoint received from
- * @was_setup: Set if processing a SetupDone event.
- *
- * The RXFIFO has delivered an OutDone event, which means that the data
- * transfer for an OUT endpoint has been completed, either by a short
- * packet or by the finish of a transfer.
-*/
-static void s3c_hsotg_handle_outdone(struct s3c_hsotg *hsotg,
-				     int epnum, bool was_setup)
-{
-	u32 epsize = readl(hsotg->regs + S3C_DOEPTSIZ(epnum));
-	struct s3c_hsotg_ep *hs_ep = &hsotg->eps[epnum];
-	struct s3c_hsotg_req *hs_req = hs_ep->req;
-	struct usb_request *req = &hs_req->req;
-	unsigned size_left = S3C_DxEPTSIZ_XferSize_GET(epsize);
-	int result = 0;
-
-	if (!hs_req) {
-		dev_dbg(hsotg->dev, "%s: no request active\n", __func__);
-		return;
-	}
-
-	if (using_dma(hsotg)) {
-		unsigned size_done;
-
-		/* Calculate the size of the transfer by checking how much
-		 * is left in the endpoint size register and then working it
-		 * out from the amount we loaded for the transfer.
-		 *
-		 * We need to do this as DMA pointers are always 32bit aligned
-		 * so may overshoot/undershoot the transfer.
-		 */
-
-		size_done = hs_ep->size_loaded - size_left;
-		size_done += hs_ep->last_load;
-
-		req->actual = size_done;
-	}
-
-	/* if there is more request to do, schedule new transfer */
-	if (req->actual < req->length && size_left == 0) {
-		s3c_hsotg_start_req(hsotg, hs_ep, hs_req, true);
-		return;
-	}
-
-	if (req->actual < req->length && req->short_not_ok) {
-		dev_dbg(hsotg->dev, "%s: got %d/%d (short not ok) => error\n",
-			__func__, req->actual, req->length);
-
-		/* todo - what should we return here? there's no one else
-		 * even bothering to check the status. */
-	}
-
-	if (epnum == 0) {
-		if (!was_setup && req->complete != s3c_hsotg_complete_setup)
-			s3c_hsotg_send_zlp(hsotg, hs_req);
-	}
-
-	s3c_hsotg_complete_request_lock(hsotg, hs_ep, hs_req, result);
-}
-
-/**
- * s3c_hsotg_read_frameno - read current frame number
- * @hsotg: The device instance
- *
- * Return the current frame number
-*/
-static u32 s3c_hsotg_read_frameno(struct s3c_hsotg *hsotg)
-{
-	u32 dsts;
-
-	dsts = readl(hsotg->regs + S3C_DSTS);
-	dsts &= S3C_DSTS_SOFFN_MASK;
-	dsts >>= S3C_DSTS_SOFFN_SHIFT;
-
-	return dsts;
-}
-
-/**
- * s3c_hsotg_handle_rx - RX FIFO has data
- * @hsotg: The device instance
- *
- * The IRQ handler has detected that the RX FIFO has some data in it
- * that requires processing, so find out what is in there and do the
- * appropriate read.
- *
- * The RXFIFO is a true FIFO, the packets coming out are still in packet
- * chunks, so if you have x packets received on an endpoint you'll get x
- * FIFO events delivered, each with a packet's worth of data in it.
- *
- * When using DMA, we should not be processing events from the RXFIFO
- * as the actual data should be sent to the memory directly and we turn
- * on the completion interrupts to get notifications of transfer completion.
- */
-static void s3c_hsotg_handle_rx(struct s3c_hsotg *hsotg)
-{
-	u32 grxstsr = readl(hsotg->regs + S3C_GRXSTSP);
-	u32 epnum, status, size;
-
-	WARN_ON(using_dma(hsotg));
-
-	epnum = grxstsr & S3C_GRXSTS_EPNum_MASK;
-	status = grxstsr & S3C_GRXSTS_PktSts_MASK;
-
-	size = grxstsr & S3C_GRXSTS_ByteCnt_MASK;
-	size >>= S3C_GRXSTS_ByteCnt_SHIFT;
-
-	if (1)
-		dev_dbg(hsotg->dev, "%s: GRXSTSP=0x%08x (%d@%d)\n",
-			__func__, grxstsr, size, epnum);
-
-#define __status(x) ((x) >> S3C_GRXSTS_PktSts_SHIFT)
-
-	switch (status >> S3C_GRXSTS_PktSts_SHIFT) {
-	case __status(S3C_GRXSTS_PktSts_GlobalOutNAK):
-		dev_dbg(hsotg->dev, "GlobalOutNAK\n");
-		break;
-
-	case __status(S3C_GRXSTS_PktSts_OutDone):
-		dev_dbg(hsotg->dev, "OutDone (Frame=0x%08x)\n",
-			s3c_hsotg_read_frameno(hsotg));
-
-		if (!using_dma(hsotg))
-			s3c_hsotg_handle_outdone(hsotg, epnum, false);
-		break;
-
-	case __status(S3C_GRXSTS_PktSts_SetupDone):
-		dev_dbg(hsotg->dev,
-			"SetupDone (Frame=0x%08x, DOPEPCTL=0x%08x)\n",
-			s3c_hsotg_read_frameno(hsotg),
-			readl(hsotg->regs + S3C_DOEPCTL(0)));
-
-		s3c_hsotg_handle_outdone(hsotg, epnum, true);
-		break;
-
-	case __status(S3C_GRXSTS_PktSts_OutRX):
-		s3c_hsotg_rx_data(hsotg, epnum, size);
-		break;
-
-	case __status(S3C_GRXSTS_PktSts_SetupRX):
-		dev_dbg(hsotg->dev,
-			"SetupRX (Frame=0x%08x, DOPEPCTL=0x%08x)\n",
-			s3c_hsotg_read_frameno(hsotg),
-			readl(hsotg->regs + S3C_DOEPCTL(0)));
-
-		s3c_hsotg_rx_data(hsotg, epnum, size);
-		break;
-
-	default:
-		dev_warn(hsotg->dev, "%s: unknown status %08x\n",
-			 __func__, grxstsr);
-
-		s3c_hsotg_dump(hsotg);
-		break;
-	}
-}
-
-/**
- * s3c_hsotg_ep0_mps - turn max packet size into register setting
- * @mps: The maximum packet size in bytes.
-*/
-static u32 s3c_hsotg_ep0_mps(unsigned int mps)
-{
-	switch (mps) {
-	case 64:
-		return S3C_D0EPCTL_MPS_64;
-	case 32:
-		return S3C_D0EPCTL_MPS_32;
-	case 16:
-		return S3C_D0EPCTL_MPS_16;
-	case 8:
-		return S3C_D0EPCTL_MPS_8;
-	}
-
-	/* bad max packet size, warn and return invalid result */
-	WARN_ON(1);
-	return (u32)-1;
-}
-
-/**
- * s3c_hsotg_set_ep_maxpacket - set endpoint's max-packet field
- * @hsotg: The driver state.
- * @ep: The index number of the endpoint
- * @mps: The maximum packet size in bytes
- *
- * Configure the maximum packet size for the given endpoint, updating
- * the hardware control registers to reflect this.
- */
-static void s3c_hsotg_set_ep_maxpacket(struct s3c_hsotg *hsotg,
-				       unsigned int ep, unsigned int mps)
-{
-	struct s3c_hsotg_ep *hs_ep = &hsotg->eps[ep];
-	void __iomem *regs = hsotg->regs;
-	u32 mpsval;
-	u32 reg;
-
-	if (ep == 0) {
-		/* EP0 is a special case */
-		mpsval = s3c_hsotg_ep0_mps(mps);
-		if (mpsval > 3)
-			goto bad_mps;
-	} else {
-		if (mps >= S3C_DxEPCTL_MPS_LIMIT+1)
-			goto bad_mps;
-
-		mpsval = mps;
-	}
-
-	hs_ep->ep.maxpacket = mps;
-
-	/* update both the in and out endpoint controldir_ registers, even
-	 * if one of the directions may not be in use. */
-
-	reg = readl(regs + S3C_DIEPCTL(ep));
-	reg &= ~S3C_DxEPCTL_MPS_MASK;
-	reg |= mpsval;
-	writel(reg, regs + S3C_DIEPCTL(ep));
-
-	if (ep) {
-		reg = readl(regs + S3C_DOEPCTL(ep));
-		reg &= ~S3C_DxEPCTL_MPS_MASK;
-		reg |= mpsval;
-		writel(reg, regs + S3C_DOEPCTL(ep));
-	}
-
-	return;
-
-bad_mps:
-	dev_err(hsotg->dev, "ep%d: bad mps of %d\n", ep, mps);
-}
-
-/**
- * s3c_hsotg_txfifo_flush - flush Tx FIFO
- * @hsotg: The driver state
- * @idx: The index for the endpoint (0..15)
- */
-static void s3c_hsotg_txfifo_flush(struct s3c_hsotg *hsotg, unsigned int idx)
-{
-	int timeout;
-	int val;
-
-	writel(S3C_GRSTCTL_TxFNum(idx) | S3C_GRSTCTL_TxFFlsh,
-		hsotg->regs + S3C_GRSTCTL);
-
-	/* wait until the fifo is flushed */
-	timeout = 100;
-
-	while (1) {
-		val = readl(hsotg->regs + S3C_GRSTCTL);
-
-		if ((val & (S3C_GRSTCTL_TxFFlsh)) == 0)
-			break;
-
-		if (--timeout == 0) {
-			dev_err(hsotg->dev,
-				"%s: timeout flushing fifo (GRSTCTL=%08x)\n",
-				__func__, val);
-		}
-
-		udelay(1);
-	}
-}
-
-/**
- * s3c_hsotg_trytx - check to see if anything needs transmitting
- * @hsotg: The driver state
- * @hs_ep: The driver endpoint to check.
- *
- * Check to see if there is a request that has data to send, and if so
- * make an attempt to write data into the FIFO.
- */
-static int s3c_hsotg_trytx(struct s3c_hsotg *hsotg,
-			   struct s3c_hsotg_ep *hs_ep)
-{
-	struct s3c_hsotg_req *hs_req = hs_ep->req;
-
-	if (!hs_ep->dir_in || !hs_req)
-		return 0;
-
-	if (hs_req->req.actual < hs_req->req.length) {
-		dev_dbg(hsotg->dev, "trying to write more for ep%d\n",
-			hs_ep->index);
-		return s3c_hsotg_write_fifo(hsotg, hs_ep, hs_req);
-	}
-
-	return 0;
-}
-
-/**
- * s3c_hsotg_complete_in - complete IN transfer
- * @hsotg: The device state.
- * @hs_ep: The endpoint that has just completed.
- *
- * An IN transfer has been completed, update the transfer's state and then
- * call the relevant completion routines.
- */
-static void s3c_hsotg_complete_in(struct s3c_hsotg *hsotg,
-				  struct s3c_hsotg_ep *hs_ep)
-{
-	struct s3c_hsotg_req *hs_req = hs_ep->req;
-	u32 epsize = readl(hsotg->regs + S3C_DIEPTSIZ(hs_ep->index));
-	int size_left, size_done;
-
-	if (!hs_req) {
-		dev_dbg(hsotg->dev, "XferCompl but no req\n");
-		return;
-	}
-
-	/* Calculate the size of the transfer by checking how much is left
-	 * in the endpoint size register and then working it out from
-	 * the amount we loaded for the transfer.
-	 *
-	 * We do this even for DMA, as the transfer may have incremented
-	 * past the end of the buffer (DMA transfers are always 32bit
-	 * aligned).
-	 */
-
-	size_left = S3C_DxEPTSIZ_XferSize_GET(epsize);
-
-	size_done = hs_ep->size_loaded - size_left;
-	size_done += hs_ep->last_load;
-
-	if (hs_req->req.actual != size_done)
-		dev_dbg(hsotg->dev, "%s: adjusting size done %d => %d\n",
-			__func__, hs_req->req.actual, size_done);
-
-	hs_req->req.actual = size_done;
-
-	/* if we did all of the transfer, and there is more data left
-	 * around, then try restarting the rest of the request */
-
-	if (!size_left && hs_req->req.actual < hs_req->req.length) {
-		dev_dbg(hsotg->dev, "%s trying more for req...\n", __func__);
-		s3c_hsotg_start_req(hsotg, hs_ep, hs_req, true);
-	} else
-		s3c_hsotg_complete_request_lock(hsotg, hs_ep, hs_req, 0);
-}
-
-/**
- * s3c_hsotg_epint - handle an in/out endpoint interrupt
- * @hsotg: The driver state
- * @idx: The index for the endpoint (0..15)
- * @dir_in: Set if this is an IN endpoint
- *
- * Process and clear any interrupt pending for an individual endpoint
-*/
-static void s3c_hsotg_epint(struct s3c_hsotg *hsotg, unsigned int idx,
-			    int dir_in)
-{
-	struct s3c_hsotg_ep *hs_ep = &hsotg->eps[idx];
-	u32 epint_reg = dir_in ? S3C_DIEPINT(idx) : S3C_DOEPINT(idx);
-	u32 epctl_reg = dir_in ? S3C_DIEPCTL(idx) : S3C_DOEPCTL(idx);
-	u32 epsiz_reg = dir_in ? S3C_DIEPTSIZ(idx) : S3C_DOEPTSIZ(idx);
-	u32 ints;
-
-	ints = readl(hsotg->regs + epint_reg);
-
-	/* Clear endpoint interrupts */
-	writel(ints, hsotg->regs + epint_reg);
-
-	dev_dbg(hsotg->dev, "%s: ep%d(%s) DxEPINT=0x%08x\n",
-		__func__, idx, dir_in ? "in" : "out", ints);
-
-	if (ints & S3C_DxEPINT_XferCompl) {
-		dev_dbg(hsotg->dev,
-			"%s: XferCompl: DxEPCTL=0x%08x, DxEPTSIZ=%08x\n",
-			__func__, readl(hsotg->regs + epctl_reg),
-			readl(hsotg->regs + epsiz_reg));
-
-		/* we get OutDone from the FIFO, so we only need to look
-		 * at completing IN requests here */
-		if (dir_in) {
-			s3c_hsotg_complete_in(hsotg, hs_ep);
-
-			if (idx == 0 && !hs_ep->req)
-				s3c_hsotg_enqueue_setup(hsotg);
-		} else if (using_dma(hsotg)) {
-			/* We're using DMA, we need to fire an OutDone here
-			 * as we ignore the RXFIFO. */
-
-			s3c_hsotg_handle_outdone(hsotg, idx, false);
-		}
-	}
-
-	if (ints & S3C_DxEPINT_EPDisbld) {
-		dev_dbg(hsotg->dev, "%s: EPDisbld\n", __func__);
-
-		if (dir_in) {
-			int epctl = readl(hsotg->regs + epctl_reg);
-
-			s3c_hsotg_txfifo_flush(hsotg, idx);
-
-			if ((epctl & S3C_DxEPCTL_Stall) &&
-				(epctl & S3C_DxEPCTL_EPType_Bulk)) {
-				int dctl = readl(hsotg->regs + S3C_DCTL);
-
-				dctl |= S3C_DCTL_CGNPInNAK;
-				writel(dctl, hsotg->regs + S3C_DCTL);
-			}
-		}
-	}
-
-	if (ints & S3C_DxEPINT_AHBErr)
-		dev_dbg(hsotg->dev, "%s: AHBErr\n", __func__);
-
-	if (ints & S3C_DxEPINT_Setup) {  /* Setup or Timeout */
-		dev_dbg(hsotg->dev, "%s: Setup/Timeout\n",  __func__);
-
-		if (using_dma(hsotg) && idx == 0) {
-			/* this is the notification we've received a
-			 * setup packet. In non-DMA mode we'd get this
-			 * from the RXFIFO, instead we need to process
-			 * the setup here. */
-
-			if (dir_in)
-				WARN_ON_ONCE(1);
-			else
-				s3c_hsotg_handle_outdone(hsotg, 0, true);
-		}
-	}
-
-	if (ints & S3C_DxEPINT_Back2BackSetup)
-		dev_dbg(hsotg->dev, "%s: B2BSetup/INEPNakEff\n", __func__);
-
-	if (dir_in) {
-		/* not sure if this is important, but we'll clear it anyway
-		 */
-		if (ints & S3C_DIEPMSK_INTknTXFEmpMsk) {
-			dev_dbg(hsotg->dev, "%s: ep%d: INTknTXFEmpMsk\n",
-				__func__, idx);
-		}
-
-		/* this probably means something bad is happening */
-		if (ints & S3C_DIEPMSK_INTknEPMisMsk) {
-			dev_warn(hsotg->dev, "%s: ep%d: INTknEP\n",
-				 __func__, idx);
-		}
-
-		/* FIFO has space or is empty (see GAHBCFG) */
-		if (hsotg->dedicated_fifos &&
-		    ints & S3C_DIEPMSK_TxFIFOEmpty) {
-			dev_dbg(hsotg->dev, "%s: ep%d: TxFIFOEmpty\n",
-				__func__, idx);
-			if (!using_dma(hsotg))
-				s3c_hsotg_trytx(hsotg, hs_ep);
-		}
-	}
-}
-
-/**
- * s3c_hsotg_irq_enumdone - Handle EnumDone interrupt (enumeration done)
- * @hsotg: The device state.
- *
- * Handle updating the device settings after the enumeration phase has
- * been completed.
-*/
-static void s3c_hsotg_irq_enumdone(struct s3c_hsotg *hsotg)
-{
-	u32 dsts = readl(hsotg->regs + S3C_DSTS);
-	int ep0_mps = 0, ep_mps;
-
-	/* This should signal the finish of the enumeration phase
-	 * of the USB handshaking, so we should now know what rate
-	 * we connected at. */
-
-	dev_dbg(hsotg->dev, "EnumDone (DSTS=0x%08x)\n", dsts);
-
-	/* note, since we're limited by the size of transfer on EP0, and
-	 * it seems IN transfers must be a even number of packets we do
-	 * not advertise a 64byte MPS on EP0. */
-
-	/* catch both EnumSpd_FS and EnumSpd_FS48 */
-	switch (dsts & S3C_DSTS_EnumSpd_MASK) {
-	case S3C_DSTS_EnumSpd_FS:
-	case S3C_DSTS_EnumSpd_FS48:
-		hsotg->gadget.speed = USB_SPEED_FULL;
-		ep0_mps = EP0_MPS_LIMIT;
-		ep_mps = 64;
-		break;
-
-	case S3C_DSTS_EnumSpd_HS:
-		hsotg->gadget.speed = USB_SPEED_HIGH;
-		ep0_mps = EP0_MPS_LIMIT;
-		ep_mps = 512;
-		break;
-
-	case S3C_DSTS_EnumSpd_LS:
-		hsotg->gadget.speed = USB_SPEED_LOW;
-		/* note, we don't actually support LS in this driver at the
-		 * moment, and the documentation seems to imply that it isn't
-		 * supported by the PHYs on some of the devices.
-		 */
-		break;
-	}
-	dev_info(hsotg->dev, "new device is %s\n",
-		 usb_speed_string(hsotg->gadget.speed));
-
-	/* we should now know the maximum packet size for an
-	 * endpoint, so set the endpoints to a default value. */
-
-	if (ep0_mps) {
-		int i;
-		s3c_hsotg_set_ep_maxpacket(hsotg, 0, ep0_mps);
-		for (i = 1; i < S3C_HSOTG_EPS; i++)
-			s3c_hsotg_set_ep_maxpacket(hsotg, i, ep_mps);
-	}
-
-	/* ensure after enumeration our EP0 is active */
-
-	s3c_hsotg_enqueue_setup(hsotg);
-
-	dev_dbg(hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",
-		readl(hsotg->regs + S3C_DIEPCTL0),
-		readl(hsotg->regs + S3C_DOEPCTL0));
-}
-
-/**
- * kill_all_requests - remove all requests from the endpoint's queue
- * @hsotg: The device state.
- * @ep: The endpoint the requests may be on.
- * @result: The result code to use.
- * @force: Force removal of any current requests
- *
- * Go through the requests on the given endpoint and mark them
- * completed with the given result code.
- */
-static void kill_all_requests(struct s3c_hsotg *hsotg,
-			      struct s3c_hsotg_ep *ep,
-			      int result, bool force)
-{
-	struct s3c_hsotg_req *req, *treq;
-	unsigned long flags;
-
-	spin_lock_irqsave(&ep->lock, flags);
-
-	list_for_each_entry_safe(req, treq, &ep->queue, queue) {
-		/* currently, we can't do much about an already
-		 * running request on an in endpoint */
-
-		if (ep->req == req && ep->dir_in && !force)
-			continue;
-
-		s3c_hsotg_complete_request(hsotg, ep, req,
-					   result);
-	}
-
-	spin_unlock_irqrestore(&ep->lock, flags);
-}
-
-#define call_gadget(_hs, _entry) \
-	if ((_hs)->gadget.speed != USB_SPEED_UNKNOWN &&	\
-	    (_hs)->driver && (_hs)->driver->_entry)	\
-		(_hs)->driver->_entry(&(_hs)->gadget);
-
-/**
- * s3c_hsotg_disconnect_irq - disconnect irq service
- * @hsotg: The device state.
- *
- * A disconnect IRQ has been received, meaning that the host has
- * lost contact with the bus. Remove all current transactions
- * and signal the gadget driver that this has happened.
-*/
-static void s3c_hsotg_disconnect_irq(struct s3c_hsotg *hsotg)
-{
-	unsigned ep;
-
-	for (ep = 0; ep < S3C_HSOTG_EPS; ep++)
-		kill_all_requests(hsotg, &hsotg->eps[ep], -ESHUTDOWN, true);
-
-	call_gadget(hsotg, disconnect);
-}
-
-/**
- * s3c_hsotg_irq_fifoempty - TX FIFO empty interrupt handler
- * @hsotg: The device state:
- * @periodic: True if this is a periodic FIFO interrupt
- */
-static void s3c_hsotg_irq_fifoempty(struct s3c_hsotg *hsotg, bool periodic)
-{
-	struct s3c_hsotg_ep *ep;
-	int epno, ret;
-
-	/* look through for any more data to transmit */
-
-	for (epno = 0; epno < S3C_HSOTG_EPS; epno++) {
-		ep = &hsotg->eps[epno];
-
-		if (!ep->dir_in)
-			continue;
-
-		if ((periodic && !ep->periodic) ||
-		    (!periodic && ep->periodic))
-			continue;
-
-		ret = s3c_hsotg_trytx(hsotg, ep);
-		if (ret < 0)
-			break;
-	}
-}
-
-static struct s3c_hsotg *our_hsotg;
-
-/* IRQ flags which will trigger a retry around the IRQ loop */
-#define IRQ_RETRY_MASK (S3C_GINTSTS_NPTxFEmp | \
-			S3C_GINTSTS_PTxFEmp |  \
-			S3C_GINTSTS_RxFLvl)
-
-/**
- * s3c_hsotg_irq - handle device interrupt
- * @irq: The IRQ number triggered
- * @pw: The pw value when registered the handler.
- */
-static irqreturn_t s3c_hsotg_irq(int irq, void *pw)
-{
-	struct s3c_hsotg *hsotg = pw;
-	int retry_count = 8;
-	u32 gintsts;
-	u32 gintmsk;
-
-irq_retry:
-	gintsts = readl(hsotg->regs + S3C_GINTSTS);
-	gintmsk = readl(hsotg->regs + S3C_GINTMSK);
-
-	dev_dbg(hsotg->dev, "%s: %08x %08x (%08x) retry %d\n",
-		__func__, gintsts, gintsts & gintmsk, gintmsk, retry_count);
-
-	gintsts &= gintmsk;
-
-	if (gintsts & S3C_GINTSTS_OTGInt) {
-		u32 otgint = readl(hsotg->regs + S3C_GOTGINT);
-
-		dev_info(hsotg->dev, "OTGInt: %08x\n", otgint);
-
-		writel(otgint, hsotg->regs + S3C_GOTGINT);
-	}
-
-	if (gintsts & S3C_GINTSTS_DisconnInt) {
-		dev_dbg(hsotg->dev, "%s: DisconnInt\n", __func__);
-		writel(S3C_GINTSTS_DisconnInt, hsotg->regs + S3C_GINTSTS);
-
-		s3c_hsotg_disconnect_irq(hsotg);
-	}
-
-	if (gintsts & S3C_GINTSTS_SessReqInt) {
-		dev_dbg(hsotg->dev, "%s: SessReqInt\n", __func__);
-		writel(S3C_GINTSTS_SessReqInt, hsotg->regs + S3C_GINTSTS);
-	}
-
-	if (gintsts & S3C_GINTSTS_EnumDone) {
-		writel(S3C_GINTSTS_EnumDone, hsotg->regs + S3C_GINTSTS);
-
-		s3c_hsotg_irq_enumdone(hsotg);
-	}
-
-	if (gintsts & S3C_GINTSTS_ConIDStsChng) {
-		dev_dbg(hsotg->dev, "ConIDStsChg (DSTS=0x%08x, GOTCTL=%08x)\n",
-			readl(hsotg->regs + S3C_DSTS),
-			readl(hsotg->regs + S3C_GOTGCTL));
-
-		writel(S3C_GINTSTS_ConIDStsChng, hsotg->regs + S3C_GINTSTS);
-	}
-
-	if (gintsts & (S3C_GINTSTS_OEPInt | S3C_GINTSTS_IEPInt)) {
-		u32 daint = readl(hsotg->regs + S3C_DAINT);
-		u32 daint_out = daint >> S3C_DAINT_OutEP_SHIFT;
-		u32 daint_in = daint & ~(daint_out << S3C_DAINT_OutEP_SHIFT);
-		int ep;
-
-		dev_dbg(hsotg->dev, "%s: daint=%08x\n", __func__, daint);
-
-		for (ep = 0; ep < 15 && daint_out; ep++, daint_out >>= 1) {
-			if (daint_out & 1)
-				s3c_hsotg_epint(hsotg, ep, 0);
-		}
-
-		for (ep = 0; ep < 15 && daint_in; ep++, daint_in >>= 1) {
-			if (daint_in & 1)
-				s3c_hsotg_epint(hsotg, ep, 1);
-		}
-	}
-
-	if (gintsts & S3C_GINTSTS_USBRst) {
-		dev_info(hsotg->dev, "%s: USBRst\n", __func__);
-		dev_dbg(hsotg->dev, "GNPTXSTS=%08x\n",
-			readl(hsotg->regs + S3C_GNPTXSTS));
-
-		writel(S3C_GINTSTS_USBRst, hsotg->regs + S3C_GINTSTS);
-
-		kill_all_requests(hsotg, &hsotg->eps[0], -ECONNRESET, true);
-
-		/* it seems after a reset we can end up with a situation
-		 * where the TXFIFO still has data in it... the docs
-		 * suggest resetting all the fifos, so use the init_fifo
-		 * code to relayout and flush the fifos.
-		 */
-
-		s3c_hsotg_init_fifo(hsotg);
-
-		s3c_hsotg_enqueue_setup(hsotg);
-	}
-
-	/* check both FIFOs */
-
-	if (gintsts & S3C_GINTSTS_NPTxFEmp) {
-		dev_dbg(hsotg->dev, "NPTxFEmp\n");
-
-		/* Disable the interrupt to stop it happening again
-		 * unless one of these endpoint routines decides that
-		 * it needs re-enabling */
-
-		s3c_hsotg_disable_gsint(hsotg, S3C_GINTSTS_NPTxFEmp);
-		s3c_hsotg_irq_fifoempty(hsotg, false);
-	}
-
-	if (gintsts & S3C_GINTSTS_PTxFEmp) {
-		dev_dbg(hsotg->dev, "PTxFEmp\n");
-
-		/* See note in S3C_GINTSTS_NPTxFEmp */
-
-		s3c_hsotg_disable_gsint(hsotg, S3C_GINTSTS_PTxFEmp);
-		s3c_hsotg_irq_fifoempty(hsotg, true);
-	}
-
-	if (gintsts & S3C_GINTSTS_RxFLvl) {
-		/* note, since GINTSTS_RxFLvl doubles as FIFO-not-empty,
-		 * we need to retry s3c_hsotg_handle_rx if this is still
-		 * set. */
-
-		s3c_hsotg_handle_rx(hsotg);
-	}
-
-	if (gintsts & S3C_GINTSTS_ModeMis) {
-		dev_warn(hsotg->dev, "warning, mode mismatch triggered\n");
-		writel(S3C_GINTSTS_ModeMis, hsotg->regs + S3C_GINTSTS);
-	}
-
-	if (gintsts & S3C_GINTSTS_USBSusp) {
-		dev_info(hsotg->dev, "S3C_GINTSTS_USBSusp\n");
-		writel(S3C_GINTSTS_USBSusp, hsotg->regs + S3C_GINTSTS);
-
-		call_gadget(hsotg, suspend);
-	}
-
-	if (gintsts & S3C_GINTSTS_WkUpInt) {
-		dev_info(hsotg->dev, "S3C_GINTSTS_WkUpIn\n");
-		writel(S3C_GINTSTS_WkUpInt, hsotg->regs + S3C_GINTSTS);
-
-		call_gadget(hsotg, resume);
-	}
-
-	if (gintsts & S3C_GINTSTS_ErlySusp) {
-		dev_dbg(hsotg->dev, "S3C_GINTSTS_ErlySusp\n");
-		writel(S3C_GINTSTS_ErlySusp, hsotg->regs + S3C_GINTSTS);
-	}
-
-	/* these next two seem to crop-up occasionally causing the core
-	 * to shutdown the USB transfer, so try clearing them and logging
-	 * the occurrence. */
-
-	if (gintsts & S3C_GINTSTS_GOUTNakEff) {
-		dev_info(hsotg->dev, "GOUTNakEff triggered\n");
-
-		writel(S3C_DCTL_CGOUTNak, hsotg->regs + S3C_DCTL);
-
-		s3c_hsotg_dump(hsotg);
-	}
-
-	if (gintsts & S3C_GINTSTS_GINNakEff) {
-		dev_info(hsotg->dev, "GINNakEff triggered\n");
-
-		writel(S3C_DCTL_CGNPInNAK, hsotg->regs + S3C_DCTL);
-
-		s3c_hsotg_dump(hsotg);
-	}
-
-	/* if we've had fifo events, we should try and go around the
-	 * loop again to see if there's any point in returning yet. */
-
-	if (gintsts & IRQ_RETRY_MASK && --retry_count > 0)
-			goto irq_retry;
-
-	return IRQ_HANDLED;
-}
-
-/**
- * s3c_hsotg_ep_enable - enable the given endpoint
- * @ep: The USB endpint to configure
- * @desc: The USB endpoint descriptor to configure with.
- *
- * This is called from the USB gadget code's usb_ep_enable().
-*/
-static int s3c_hsotg_ep_enable(struct usb_ep *ep,
-			       const struct usb_endpoint_descriptor *desc)
-{
-	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
-	struct s3c_hsotg *hsotg = hs_ep->parent;
-	unsigned long flags;
-	int index = hs_ep->index;
-	u32 epctrl_reg;
-	u32 epctrl;
-	u32 mps;
-	int dir_in;
-	int ret = 0;
-
-	dev_dbg(hsotg->dev,
-		"%s: ep %s: a 0x%02x, attr 0x%02x, mps 0x%04x, intr %d\n",
-		__func__, ep->name, desc->bEndpointAddress, desc->bmAttributes,
-		desc->wMaxPacketSize, desc->bInterval);
-
-	/* not to be called for EP0 */
-	WARN_ON(index == 0);
-
-	dir_in = (desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK) ? 1 : 0;
-	if (dir_in != hs_ep->dir_in) {
-		dev_err(hsotg->dev, "%s: direction mismatch!\n", __func__);
-		return -EINVAL;
-	}
-
-	mps = usb_endpoint_maxp(desc);
-
-	/* note, we handle this here instead of s3c_hsotg_set_ep_maxpacket */
-
-	epctrl_reg = dir_in ? S3C_DIEPCTL(index) : S3C_DOEPCTL(index);
-	epctrl = readl(hsotg->regs + epctrl_reg);
-
-	dev_dbg(hsotg->dev, "%s: read DxEPCTL=0x%08x from 0x%08x\n",
-		__func__, epctrl, epctrl_reg);
-
-	spin_lock_irqsave(&hs_ep->lock, flags);
-
-	epctrl &= ~(S3C_DxEPCTL_EPType_MASK | S3C_DxEPCTL_MPS_MASK);
-	epctrl |= S3C_DxEPCTL_MPS(mps);
-
-	/* mark the endpoint as active, otherwise the core may ignore
-	 * transactions entirely for this endpoint */
-	epctrl |= S3C_DxEPCTL_USBActEp;
-
-	/* set the NAK status on the endpoint, otherwise we might try and
-	 * do something with data that we've yet got a request to process
-	 * since the RXFIFO will take data for an endpoint even if the
-	 * size register hasn't been set.
-	 */
-
-	epctrl |= S3C_DxEPCTL_SNAK;
-
-	/* update the endpoint state */
-	hs_ep->ep.maxpacket = mps;
-
-	/* default, set to non-periodic */
-	hs_ep->periodic = 0;
-
-	switch (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {
-	case USB_ENDPOINT_XFER_ISOC:
-		dev_err(hsotg->dev, "no current ISOC support\n");
-		ret = -EINVAL;
-		goto out;
-
-	case USB_ENDPOINT_XFER_BULK:
-		epctrl |= S3C_DxEPCTL_EPType_Bulk;
-		break;
-
-	case USB_ENDPOINT_XFER_INT:
-		if (dir_in) {
-			/* Allocate our TxFNum by simply using the index
-			 * of the endpoint for the moment. We could do
-			 * something better if the host indicates how
-			 * many FIFOs we are expecting to use. */
-
-			hs_ep->periodic = 1;
-			epctrl |= S3C_DxEPCTL_TxFNum(index);
-		}
-
-		epctrl |= S3C_DxEPCTL_EPType_Intterupt;
-		break;
-
-	case USB_ENDPOINT_XFER_CONTROL:
-		epctrl |= S3C_DxEPCTL_EPType_Control;
-		break;
-	}
-
-	/* if the hardware has dedicated fifos, we must give each IN EP
-	 * a unique tx-fifo even if it is non-periodic.
-	 */
-	if (dir_in && hsotg->dedicated_fifos)
-		epctrl |= S3C_DxEPCTL_TxFNum(index);
-
-	/* for non control endpoints, set PID to D0 */
-	if (index)
-		epctrl |= S3C_DxEPCTL_SetD0PID;
-
-	dev_dbg(hsotg->dev, "%s: write DxEPCTL=0x%08x\n",
-		__func__, epctrl);
-
-	writel(epctrl, hsotg->regs + epctrl_reg);
-	dev_dbg(hsotg->dev, "%s: read DxEPCTL=0x%08x\n",
-		__func__, readl(hsotg->regs + epctrl_reg));
-
-	/* enable the endpoint interrupt */
-	s3c_hsotg_ctrl_epint(hsotg, index, dir_in, 1);
-
-out:
-	spin_unlock_irqrestore(&hs_ep->lock, flags);
-	return ret;
-}
-
-static int s3c_hsotg_ep_disable(struct usb_ep *ep)
-{
-	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
-	struct s3c_hsotg *hsotg = hs_ep->parent;
-	int dir_in = hs_ep->dir_in;
-	int index = hs_ep->index;
-	unsigned long flags;
-	u32 epctrl_reg;
-	u32 ctrl;
-
-	dev_info(hsotg->dev, "%s(ep %p)\n", __func__, ep);
-
-	if (ep == &hsotg->eps[0].ep) {
-		dev_err(hsotg->dev, "%s: called for ep0\n", __func__);
-		return -EINVAL;
-	}
-
-	epctrl_reg = dir_in ? S3C_DIEPCTL(index) : S3C_DOEPCTL(index);
-
-	/* terminate all requests with shutdown */
-	kill_all_requests(hsotg, hs_ep, -ESHUTDOWN, false);
-
-	spin_lock_irqsave(&hs_ep->lock, flags);
-
-	ctrl = readl(hsotg->regs + epctrl_reg);
-	ctrl &= ~S3C_DxEPCTL_EPEna;
-	ctrl &= ~S3C_DxEPCTL_USBActEp;
-	ctrl |= S3C_DxEPCTL_SNAK;
-
-	dev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x\n", __func__, ctrl);
-	writel(ctrl, hsotg->regs + epctrl_reg);
-
-	/* disable endpoint interrupts */
-	s3c_hsotg_ctrl_epint(hsotg, hs_ep->index, hs_ep->dir_in, 0);
-
-	spin_unlock_irqrestore(&hs_ep->lock, flags);
-	return 0;
-}
-
-/**
- * on_list - check request is on the given endpoint
- * @ep: The endpoint to check.
- * @test: The request to test if it is on the endpoint.
-*/
-static bool on_list(struct s3c_hsotg_ep *ep, struct s3c_hsotg_req *test)
-{
-	struct s3c_hsotg_req *req, *treq;
-
-	list_for_each_entry_safe(req, treq, &ep->queue, queue) {
-		if (req == test)
-			return true;
-	}
-
-	return false;
-}
-
-static int s3c_hsotg_ep_dequeue(struct usb_ep *ep, struct usb_request *req)
-{
-	struct s3c_hsotg_req *hs_req = our_req(req);
-	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
-	struct s3c_hsotg *hs = hs_ep->parent;
-	unsigned long flags;
-
-	dev_info(hs->dev, "ep_dequeue(%p,%p)\n", ep, req);
-
-	spin_lock_irqsave(&hs_ep->lock, flags);
-
-	if (!on_list(hs_ep, hs_req)) {
-		spin_unlock_irqrestore(&hs_ep->lock, flags);
-		return -EINVAL;
-	}
-
-	s3c_hsotg_complete_request(hs, hs_ep, hs_req, -ECONNRESET);
-	spin_unlock_irqrestore(&hs_ep->lock, flags);
-
-	return 0;
-}
-
-static int s3c_hsotg_ep_sethalt(struct usb_ep *ep, int value)
-{
-	struct s3c_hsotg_ep *hs_ep = our_ep(ep);
-	struct s3c_hsotg *hs = hs_ep->parent;
-	int index = hs_ep->index;
-	unsigned long irqflags;
-	u32 epreg;
-	u32 epctl;
-	u32 xfertype;
-
-	dev_info(hs->dev, "%s(ep %p %s, %d)\n", __func__, ep, ep->name, value);
-
-	spin_lock_irqsave(&hs_ep->lock, irqflags);
-
-	/* write both IN and OUT control registers */
-
-	epreg = S3C_DIEPCTL(index);
-	epctl = readl(hs->regs + epreg);
-
-	if (value) {
-		epctl |= S3C_DxEPCTL_Stall + S3C_DxEPCTL_SNAK;
-		if (epctl & S3C_DxEPCTL_EPEna)
-			epctl |= S3C_DxEPCTL_EPDis;
-	} else {
-		epctl &= ~S3C_DxEPCTL_Stall;
-		xfertype = epctl & S3C_DxEPCTL_EPType_MASK;
-		if (xfertype == S3C_DxEPCTL_EPType_Bulk ||
-			xfertype == S3C_DxEPCTL_EPType_Intterupt)
-				epctl |= S3C_DxEPCTL_SetD0PID;
-	}
-
-	writel(epctl, hs->regs + epreg);
-
-	epreg = S3C_DOEPCTL(index);
-	epctl = readl(hs->regs + epreg);
-
-	if (value)
-		epctl |= S3C_DxEPCTL_Stall;
-	else {
-		epctl &= ~S3C_DxEPCTL_Stall;
-		xfertype = epctl & S3C_DxEPCTL_EPType_MASK;
-		if (xfertype == S3C_DxEPCTL_EPType_Bulk ||
-			xfertype == S3C_DxEPCTL_EPType_Intterupt)
-				epctl |= S3C_DxEPCTL_SetD0PID;
-	}
-
-	writel(epctl, hs->regs + epreg);
-
-	spin_unlock_irqrestore(&hs_ep->lock, irqflags);
-
-	return 0;
-}
-
-static struct usb_ep_ops s3c_hsotg_ep_ops = {
-	.enable		= s3c_hsotg_ep_enable,
-	.disable	= s3c_hsotg_ep_disable,
-	.alloc_request	= s3c_hsotg_ep_alloc_request,
-	.free_request	= s3c_hsotg_ep_free_request,
-	.queue		= s3c_hsotg_ep_queue,
-	.dequeue	= s3c_hsotg_ep_dequeue,
-	.set_halt	= s3c_hsotg_ep_sethalt,
-	/* note, don't believe we have any call for the fifo routines */
-};
-
-/**
- * s3c_hsotg_corereset - issue softreset to the core
- * @hsotg: The device state
- *
- * Issue a soft reset to the core, and await the core finishing it.
-*/
-static int s3c_hsotg_corereset(struct s3c_hsotg *hsotg)
-{
-	int timeout;
-	u32 grstctl;
-
-	dev_dbg(hsotg->dev, "resetting core\n");
-
-	/* issue soft reset */
-	writel(S3C_GRSTCTL_CSftRst, hsotg->regs + S3C_GRSTCTL);
-
-	timeout = 1000;
-	do {
-		grstctl = readl(hsotg->regs + S3C_GRSTCTL);
-	} while ((grstctl & S3C_GRSTCTL_CSftRst) && timeout-- > 0);
-
-	if (grstctl & S3C_GRSTCTL_CSftRst) {
-		dev_err(hsotg->dev, "Failed to get CSftRst asserted\n");
-		return -EINVAL;
-	}
-
-	timeout = 1000;
-
-	while (1) {
-		u32 grstctl = readl(hsotg->regs + S3C_GRSTCTL);
-
-		if (timeout-- < 0) {
-			dev_info(hsotg->dev,
-				 "%s: reset failed, GRSTCTL=%08x\n",
-				 __func__, grstctl);
-			return -ETIMEDOUT;
-		}
-
-		if (!(grstctl & S3C_GRSTCTL_AHBIdle))
-			continue;
-
-		break;		/* reset done */
-	}
-
-	dev_dbg(hsotg->dev, "reset successful\n");
-	return 0;
-}
-
-static int s3c_hsotg_start(struct usb_gadget_driver *driver,
-		int (*bind)(struct usb_gadget *))
-{
-	struct s3c_hsotg *hsotg = our_hsotg;
-	int ret;
-
-	if (!hsotg) {
-		printk(KERN_ERR "%s: called with no device\n", __func__);
-		return -ENODEV;
-	}
-
-	if (!driver) {
-		dev_err(hsotg->dev, "%s: no driver\n", __func__);
-		return -EINVAL;
-	}
-
-	if (driver->max_speed < USB_SPEED_FULL)
-		dev_err(hsotg->dev, "%s: bad speed\n", __func__);
-
-	if (!bind || !driver->setup) {
-		dev_err(hsotg->dev, "%s: missing entry points\n", __func__);
-		return -EINVAL;
-	}
-
-	WARN_ON(hsotg->driver);
-
-	driver->driver.bus = NULL;
-	hsotg->driver = driver;
-	hsotg->gadget.dev.driver = &driver->driver;
-	hsotg->gadget.dev.dma_mask = hsotg->dev->dma_mask;
-	hsotg->gadget.speed = USB_SPEED_UNKNOWN;
-
-	ret = device_add(&hsotg->gadget.dev);
-	if (ret) {
-		dev_err(hsotg->dev, "failed to register gadget device\n");
-		goto err;
-	}
-
-	ret = bind(&hsotg->gadget);
-	if (ret) {
-		dev_err(hsotg->dev, "failed bind %s\n", driver->driver.name);
-
-		hsotg->gadget.dev.driver = NULL;
-		hsotg->driver = NULL;
-		goto err;
-	}
-
-	/* we must now enable ep0 ready for host detection and then
-	 * set configuration. */
-
-	s3c_hsotg_corereset(hsotg);
-
-	/* set the PLL on, remove the HNP/SRP and set the PHY */
-	writel(S3C_GUSBCFG_PHYIf16 | S3C_GUSBCFG_TOutCal(7) |
-	       (0x5 << 10), hsotg->regs + S3C_GUSBCFG);
-
-	/* looks like soft-reset changes state of FIFOs */
-	s3c_hsotg_init_fifo(hsotg);
-
-	__orr32(hsotg->regs + S3C_DCTL, S3C_DCTL_SftDiscon);
-
-	writel(1 << 18 | S3C_DCFG_DevSpd_HS,  hsotg->regs + S3C_DCFG);
-
-	/* Clear any pending OTG interrupts */
-	writel(0xffffffff, hsotg->regs + S3C_GOTGINT);
-
-	/* Clear any pending interrupts */
-	writel(0xffffffff, hsotg->regs + S3C_GINTSTS);
-
-	writel(S3C_GINTSTS_DisconnInt | S3C_GINTSTS_SessReqInt |
-	       S3C_GINTSTS_ConIDStsChng | S3C_GINTSTS_USBRst |
-	       S3C_GINTSTS_EnumDone | S3C_GINTSTS_OTGInt |
-	       S3C_GINTSTS_USBSusp | S3C_GINTSTS_WkUpInt |
-	       S3C_GINTSTS_GOUTNakEff | S3C_GINTSTS_GINNakEff |
-	       S3C_GINTSTS_ErlySusp,
-	       hsotg->regs + S3C_GINTMSK);
-
-	if (using_dma(hsotg))
-		writel(S3C_GAHBCFG_GlblIntrEn | S3C_GAHBCFG_DMAEn |
-		       S3C_GAHBCFG_HBstLen_Incr4,
-		       hsotg->regs + S3C_GAHBCFG);
-	else
-		writel(S3C_GAHBCFG_GlblIntrEn, hsotg->regs + S3C_GAHBCFG);
-
-	/* Enabling INTknTXFEmpMsk here seems to be a big mistake, we end
-	 * up being flooded with interrupts if the host is polling the
-	 * endpoint to try and read data. */
-
-	writel(S3C_DIEPMSK_TimeOUTMsk | S3C_DIEPMSK_AHBErrMsk |
-	       S3C_DIEPMSK_INTknEPMisMsk |
-	       S3C_DIEPMSK_EPDisbldMsk | S3C_DIEPMSK_XferComplMsk |
-	       ((hsotg->dedicated_fifos) ? S3C_DIEPMSK_TxFIFOEmpty : 0),
-	       hsotg->regs + S3C_DIEPMSK);
-
-	/* don't need XferCompl, we get that from RXFIFO in slave mode. In
-	 * DMA mode we may need this. */
-	writel(S3C_DOEPMSK_SetupMsk | S3C_DOEPMSK_AHBErrMsk |
-	       S3C_DOEPMSK_EPDisbldMsk |
-	       (using_dma(hsotg) ? (S3C_DIEPMSK_XferComplMsk |
-				   S3C_DIEPMSK_TimeOUTMsk) : 0),
-	       hsotg->regs + S3C_DOEPMSK);
-
-	writel(0, hsotg->regs + S3C_DAINTMSK);
-
-	dev_dbg(hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",
-		readl(hsotg->regs + S3C_DIEPCTL0),
-		readl(hsotg->regs + S3C_DOEPCTL0));
-
-	/* enable in and out endpoint interrupts */
-	s3c_hsotg_en_gsint(hsotg, S3C_GINTSTS_OEPInt | S3C_GINTSTS_IEPInt);
-
-	/* Enable the RXFIFO when in slave mode, as this is how we collect
-	 * the data. In DMA mode, we get events from the FIFO but also
-	 * things we cannot process, so do not use it. */
-	if (!using_dma(hsotg))
-		s3c_hsotg_en_gsint(hsotg, S3C_GINTSTS_RxFLvl);
-
-	/* Enable interrupts for EP0 in and out */
-	s3c_hsotg_ctrl_epint(hsotg, 0, 0, 1);
-	s3c_hsotg_ctrl_epint(hsotg, 0, 1, 1);
-
-	__orr32(hsotg->regs + S3C_DCTL, S3C_DCTL_PWROnPrgDone);
-	udelay(10);  /* see openiboot */
-	__bic32(hsotg->regs + S3C_DCTL, S3C_DCTL_PWROnPrgDone);
-
-	dev_dbg(hsotg->dev, "DCTL=0x%08x\n", readl(hsotg->regs + S3C_DCTL));
-
-	/* S3C_DxEPCTL_USBActEp says RO in manual, but seems to be set by
-	   writing to the EPCTL register.. */
-
-	/* set to read 1 8byte packet */
-	writel(S3C_DxEPTSIZ_MC(1) | S3C_DxEPTSIZ_PktCnt(1) |
-	       S3C_DxEPTSIZ_XferSize(8), hsotg->regs + DOEPTSIZ0);
-
-	writel(s3c_hsotg_ep0_mps(hsotg->eps[0].ep.maxpacket) |
-	       S3C_DxEPCTL_CNAK | S3C_DxEPCTL_EPEna |
-	       S3C_DxEPCTL_USBActEp,
-	       hsotg->regs + S3C_DOEPCTL0);
-
-	/* enable, but don't activate EP0in */
-	writel(s3c_hsotg_ep0_mps(hsotg->eps[0].ep.maxpacket) |
-	       S3C_DxEPCTL_USBActEp, hsotg->regs + S3C_DIEPCTL0);
-
-	s3c_hsotg_enqueue_setup(hsotg);
-
-	dev_dbg(hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",
-		readl(hsotg->regs + S3C_DIEPCTL0),
-		readl(hsotg->regs + S3C_DOEPCTL0));
-
-	/* clear global NAKs */
-	writel(S3C_DCTL_CGOUTNak | S3C_DCTL_CGNPInNAK,
-	       hsotg->regs + S3C_DCTL);
-
-	/* must be at-least 3ms to allow bus to see disconnect */
-	msleep(3);
-
-	/* remove the soft-disconnect and let's go */
-	__bic32(hsotg->regs + S3C_DCTL, S3C_DCTL_SftDiscon);
-
-	/* report to the user, and return */
-
-	dev_info(hsotg->dev, "bound driver %s\n", driver->driver.name);
-	return 0;
-
-err:
-	hsotg->driver = NULL;
-	hsotg->gadget.dev.driver = NULL;
-	return ret;
-}
-
-static int s3c_hsotg_stop(struct usb_gadget_driver *driver)
-{
-	struct s3c_hsotg *hsotg = our_hsotg;
-	int ep;
-
-	if (!hsotg)
-		return -ENODEV;
-
-	if (!driver || driver != hsotg->driver || !driver->unbind)
-		return -EINVAL;
-
-	/* all endpoints should be shutdown */
-	for (ep = 0; ep < S3C_HSOTG_EPS; ep++)
-		s3c_hsotg_ep_disable(&hsotg->eps[ep].ep);
-
-	call_gadget(hsotg, disconnect);
-
-	driver->unbind(&hsotg->gadget);
-	hsotg->driver = NULL;
-	hsotg->gadget.speed = USB_SPEED_UNKNOWN;
-
-	device_del(&hsotg->gadget.dev);
-
-	dev_info(hsotg->dev, "unregistered gadget driver '%s'\n",
-		 driver->driver.name);
-
-	return 0;
-}
-
-static int s3c_hsotg_gadget_getframe(struct usb_gadget *gadget)
-{
-	return s3c_hsotg_read_frameno(to_hsotg(gadget));
-}
-
-static struct usb_gadget_ops s3c_hsotg_gadget_ops = {
-	.get_frame	= s3c_hsotg_gadget_getframe,
-	.start		= s3c_hsotg_start,
-	.stop		= s3c_hsotg_stop,
-};
-
-/**
- * s3c_hsotg_initep - initialise a single endpoint
- * @hsotg: The device state.
- * @hs_ep: The endpoint to be initialised.
- * @epnum: The endpoint number
- *
- * Initialise the given endpoint (as part of the probe and device state
- * creation) to give to the gadget driver. Setup the endpoint name, any
- * direction information and other state that may be required.
- */
-static void __devinit s3c_hsotg_initep(struct s3c_hsotg *hsotg,
-				       struct s3c_hsotg_ep *hs_ep,
-				       int epnum)
-{
-	u32 ptxfifo;
-	char *dir;
-
-	if (epnum == 0)
-		dir = "";
-	else if ((epnum % 2) == 0) {
-		dir = "out";
-	} else {
-		dir = "in";
-		hs_ep->dir_in = 1;
-	}
-
-	hs_ep->index = epnum;
-
-	snprintf(hs_ep->name, sizeof(hs_ep->name), "ep%d%s", epnum, dir);
-
-	INIT_LIST_HEAD(&hs_ep->queue);
-	INIT_LIST_HEAD(&hs_ep->ep.ep_list);
-
-	spin_lock_init(&hs_ep->lock);
-
-	/* add to the list of endpoints known by the gadget driver */
-	if (epnum)
-		list_add_tail(&hs_ep->ep.ep_list, &hsotg->gadget.ep_list);
-
-	hs_ep->parent = hsotg;
-	hs_ep->ep.name = hs_ep->name;
-	hs_ep->ep.maxpacket = epnum ? 512 : EP0_MPS_LIMIT;
-	hs_ep->ep.ops = &s3c_hsotg_ep_ops;
-
-	/* Read the FIFO size for the Periodic TX FIFO, even if we're
-	 * an OUT endpoint, we may as well do this if in future the
-	 * code is changed to make each endpoint's direction changeable.
-	 */
-
-	ptxfifo = readl(hsotg->regs + S3C_DPTXFSIZn(epnum));
-	hs_ep->fifo_size = S3C_DPTXFSIZn_DPTxFSize_GET(ptxfifo) * 4;
-
-	/* if we're using dma, we need to set the next-endpoint pointer
-	 * to be something valid.
-	 */
-
-	if (using_dma(hsotg)) {
-		u32 next = S3C_DxEPCTL_NextEp((epnum + 1) % 15);
-		writel(next, hsotg->regs + S3C_DIEPCTL(epnum));
-		writel(next, hsotg->regs + S3C_DOEPCTL(epnum));
-	}
-}
-
-/**
- * s3c_hsotg_otgreset - reset the OtG phy block
- * @hsotg: The host state.
- *
- * Power up the phy, set the basic configuration and start the PHY.
- */
-static void s3c_hsotg_otgreset(struct s3c_hsotg *hsotg)
-{
-	struct clk *xusbxti;
-	u32 pwr, osc;
-
-	pwr = readl(S3C_PHYPWR);
-	pwr &= ~0x19;
-	writel(pwr, S3C_PHYPWR);
-	mdelay(1);
-
-	osc = hsotg->plat->is_osc ? S3C_PHYCLK_EXT_OSC : 0;
-
-	xusbxti = clk_get(hsotg->dev, "xusbxti");
-	if (xusbxti && !IS_ERR(xusbxti)) {
-		switch (clk_get_rate(xusbxti)) {
-		case 12*MHZ:
-			osc |= S3C_PHYCLK_CLKSEL_12M;
-			break;
-		case 24*MHZ:
-			osc |= S3C_PHYCLK_CLKSEL_24M;
-			break;
-		default:
-		case 48*MHZ:
-			/* default reference clock */
-			break;
-		}
-		clk_put(xusbxti);
-	}
-
-	writel(osc | 0x10, S3C_PHYCLK);
-
-	/* issue a full set of resets to the otg and core */
-
-	writel(S3C_RSTCON_PHY, S3C_RSTCON);
-	udelay(20);	/* at-least 10uS */
-	writel(0, S3C_RSTCON);
-}
-
-
-static void s3c_hsotg_init(struct s3c_hsotg *hsotg)
-{
-	u32 cfg4;
-
-	/* unmask subset of endpoint interrupts */
-
-	writel(S3C_DIEPMSK_TimeOUTMsk | S3C_DIEPMSK_AHBErrMsk |
-	       S3C_DIEPMSK_EPDisbldMsk | S3C_DIEPMSK_XferComplMsk,
-	       hsotg->regs + S3C_DIEPMSK);
-
-	writel(S3C_DOEPMSK_SetupMsk | S3C_DOEPMSK_AHBErrMsk |
-	       S3C_DOEPMSK_EPDisbldMsk | S3C_DOEPMSK_XferComplMsk,
-	       hsotg->regs + S3C_DOEPMSK);
-
-	writel(0, hsotg->regs + S3C_DAINTMSK);
-
-	/* Be in disconnected state until gadget is registered */
-	__orr32(hsotg->regs + S3C_DCTL, S3C_DCTL_SftDiscon);
-
-	if (0) {
-		/* post global nak until we're ready */
-		writel(S3C_DCTL_SGNPInNAK | S3C_DCTL_SGOUTNak,
-		       hsotg->regs + S3C_DCTL);
-	}
-
-	/* setup fifos */
-
-	dev_dbg(hsotg->dev, "GRXFSIZ=0x%08x, GNPTXFSIZ=0x%08x\n",
-		readl(hsotg->regs + S3C_GRXFSIZ),
-		readl(hsotg->regs + S3C_GNPTXFSIZ));
-
-	s3c_hsotg_init_fifo(hsotg);
-
-	/* set the PLL on, remove the HNP/SRP and set the PHY */
-	writel(S3C_GUSBCFG_PHYIf16 | S3C_GUSBCFG_TOutCal(7) | (0x5 << 10),
-	       hsotg->regs + S3C_GUSBCFG);
-
-	writel(using_dma(hsotg) ? S3C_GAHBCFG_DMAEn : 0x0,
-	       hsotg->regs + S3C_GAHBCFG);
-
-	/* check hardware configuration */
-
-	cfg4 = readl(hsotg->regs + 0x50);
-	hsotg->dedicated_fifos = (cfg4 >> 25) & 1;
-
-	dev_info(hsotg->dev, "%s fifos\n",
-		 hsotg->dedicated_fifos ? "dedicated" : "shared");
-}
-
-static void s3c_hsotg_dump(struct s3c_hsotg *hsotg)
-{
-#ifdef DEBUG
-	struct device *dev = hsotg->dev;
-	void __iomem *regs = hsotg->regs;
-	u32 val;
-	int idx;
-
-	dev_info(dev, "DCFG=0x%08x, DCTL=0x%08x, DIEPMSK=%08x\n",
-		 readl(regs + S3C_DCFG), readl(regs + S3C_DCTL),
-		 readl(regs + S3C_DIEPMSK));
-
-	dev_info(dev, "GAHBCFG=0x%08x, 0x44=0x%08x\n",
-		 readl(regs + S3C_GAHBCFG), readl(regs + 0x44));
-
-	dev_info(dev, "GRXFSIZ=0x%08x, GNPTXFSIZ=0x%08x\n",
-		 readl(regs + S3C_GRXFSIZ), readl(regs + S3C_GNPTXFSIZ));
-
-	/* show periodic fifo settings */
-
-	for (idx = 1; idx <= 15; idx++) {
-		val = readl(regs + S3C_DPTXFSIZn(idx));
-		dev_info(dev, "DPTx[%d] FSize=%d, StAddr=0x%08x\n", idx,
-			 val >> S3C_DPTXFSIZn_DPTxFSize_SHIFT,
-			 val & S3C_DPTXFSIZn_DPTxFStAddr_MASK);
-	}
-
-	for (idx = 0; idx < 15; idx++) {
-		dev_info(dev,
-			 "ep%d-in: EPCTL=0x%08x, SIZ=0x%08x, DMA=0x%08x\n", idx,
-			 readl(regs + S3C_DIEPCTL(idx)),
-			 readl(regs + S3C_DIEPTSIZ(idx)),
-			 readl(regs + S3C_DIEPDMA(idx)));
-
-		val = readl(regs + S3C_DOEPCTL(idx));
-		dev_info(dev,
-			 "ep%d-out: EPCTL=0x%08x, SIZ=0x%08x, DMA=0x%08x\n",
-			 idx, readl(regs + S3C_DOEPCTL(idx)),
-			 readl(regs + S3C_DOEPTSIZ(idx)),
-			 readl(regs + S3C_DOEPDMA(idx)));
-
-	}
-
-	dev_info(dev, "DVBUSDIS=0x%08x, DVBUSPULSE=%08x\n",
-		 readl(regs + S3C_DVBUSDIS), readl(regs + S3C_DVBUSPULSE));
-#endif
-}
-
-
-/**
- * state_show - debugfs: show overall driver and device state.
- * @seq: The seq file to write to.
- * @v: Unused parameter.
- *
- * This debugfs entry shows the overall state of the hardware and
- * some general information about each of the endpoints available
- * to the system.
- */
-static int state_show(struct seq_file *seq, void *v)
-{
-	struct s3c_hsotg *hsotg = seq->private;
-	void __iomem *regs = hsotg->regs;
-	int idx;
-
-	seq_printf(seq, "DCFG=0x%08x, DCTL=0x%08x, DSTS=0x%08x\n",
-		 readl(regs + S3C_DCFG),
-		 readl(regs + S3C_DCTL),
-		 readl(regs + S3C_DSTS));
-
-	seq_printf(seq, "DIEPMSK=0x%08x, DOEPMASK=0x%08x\n",
-		   readl(regs + S3C_DIEPMSK), readl(regs + S3C_DOEPMSK));
-
-	seq_printf(seq, "GINTMSK=0x%08x, GINTSTS=0x%08x\n",
-		   readl(regs + S3C_GINTMSK),
-		   readl(regs + S3C_GINTSTS));
-
-	seq_printf(seq, "DAINTMSK=0x%08x, DAINT=0x%08x\n",
-		   readl(regs + S3C_DAINTMSK),
-		   readl(regs + S3C_DAINT));
-
-	seq_printf(seq, "GNPTXSTS=0x%08x, GRXSTSR=%08x\n",
-		   readl(regs + S3C_GNPTXSTS),
-		   readl(regs + S3C_GRXSTSR));
-
-	seq_printf(seq, "\nEndpoint status:\n");
-
-	for (idx = 0; idx < 15; idx++) {
-		u32 in, out;
-
-		in = readl(regs + S3C_DIEPCTL(idx));
-		out = readl(regs + S3C_DOEPCTL(idx));
-
-		seq_printf(seq, "ep%d: DIEPCTL=0x%08x, DOEPCTL=0x%08x",
-			   idx, in, out);
-
-		in = readl(regs + S3C_DIEPTSIZ(idx));
-		out = readl(regs + S3C_DOEPTSIZ(idx));
-
-		seq_printf(seq, ", DIEPTSIZ=0x%08x, DOEPTSIZ=0x%08x",
-			   in, out);
-
-		seq_printf(seq, "\n");
-	}
-
-	return 0;
-}
-
-static int state_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, state_show, inode->i_private);
-}
-
-static const struct file_operations state_fops = {
-	.owner		= THIS_MODULE,
-	.open		= state_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-/**
- * fifo_show - debugfs: show the fifo information
- * @seq: The seq_file to write data to.
- * @v: Unused parameter.
- *
- * Show the FIFO information for the overall fifo and all the
- * periodic transmission FIFOs.
-*/
-static int fifo_show(struct seq_file *seq, void *v)
-{
-	struct s3c_hsotg *hsotg = seq->private;
-	void __iomem *regs = hsotg->regs;
-	u32 val;
-	int idx;
-
-	seq_printf(seq, "Non-periodic FIFOs:\n");
-	seq_printf(seq, "RXFIFO: Size %d\n", readl(regs + S3C_GRXFSIZ));
-
-	val = readl(regs + S3C_GNPTXFSIZ);
-	seq_printf(seq, "NPTXFIFO: Size %d, Start 0x%08x\n",
-		   val >> S3C_GNPTXFSIZ_NPTxFDep_SHIFT,
-		   val & S3C_GNPTXFSIZ_NPTxFStAddr_MASK);
-
-	seq_printf(seq, "\nPeriodic TXFIFOs:\n");
-
-	for (idx = 1; idx <= 15; idx++) {
-		val = readl(regs + S3C_DPTXFSIZn(idx));
-
-		seq_printf(seq, "\tDPTXFIFO%2d: Size %d, Start 0x%08x\n", idx,
-			   val >> S3C_DPTXFSIZn_DPTxFSize_SHIFT,
-			   val & S3C_DPTXFSIZn_DPTxFStAddr_MASK);
-	}
-
-	return 0;
-}
-
-static int fifo_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, fifo_show, inode->i_private);
-}
-
-static const struct file_operations fifo_fops = {
-	.owner		= THIS_MODULE,
-	.open		= fifo_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-
-static const char *decode_direction(int is_in)
-{
-	return is_in ? "in" : "out";
-}
-
-/**
- * ep_show - debugfs: show the state of an endpoint.
- * @seq: The seq_file to write data to.
- * @v: Unused parameter.
- *
- * This debugfs entry shows the state of the given endpoint (one is
- * registered for each available).
-*/
-static int ep_show(struct seq_file *seq, void *v)
-{
-	struct s3c_hsotg_ep *ep = seq->private;
-	struct s3c_hsotg *hsotg = ep->parent;
-	struct s3c_hsotg_req *req;
-	void __iomem *regs = hsotg->regs;
-	int index = ep->index;
-	int show_limit = 15;
-	unsigned long flags;
-
-	seq_printf(seq, "Endpoint index %d, named %s,  dir %s:\n",
-		   ep->index, ep->ep.name, decode_direction(ep->dir_in));
-
-	/* first show the register state */
-
-	seq_printf(seq, "\tDIEPCTL=0x%08x, DOEPCTL=0x%08x\n",
-		   readl(regs + S3C_DIEPCTL(index)),
-		   readl(regs + S3C_DOEPCTL(index)));
-
-	seq_printf(seq, "\tDIEPDMA=0x%08x, DOEPDMA=0x%08x\n",
-		   readl(regs + S3C_DIEPDMA(index)),
-		   readl(regs + S3C_DOEPDMA(index)));
-
-	seq_printf(seq, "\tDIEPINT=0x%08x, DOEPINT=0x%08x\n",
-		   readl(regs + S3C_DIEPINT(index)),
-		   readl(regs + S3C_DOEPINT(index)));
-
-	seq_printf(seq, "\tDIEPTSIZ=0x%08x, DOEPTSIZ=0x%08x\n",
-		   readl(regs + S3C_DIEPTSIZ(index)),
-		   readl(regs + S3C_DOEPTSIZ(index)));
-
-	seq_printf(seq, "\n");
-	seq_printf(seq, "mps %d\n", ep->ep.maxpacket);
-	seq_printf(seq, "total_data=%ld\n", ep->total_data);
-
-	seq_printf(seq, "request list (%p,%p):\n",
-		   ep->queue.next, ep->queue.prev);
-
-	spin_lock_irqsave(&ep->lock, flags);
-
-	list_for_each_entry(req, &ep->queue, queue) {
-		if (--show_limit < 0) {
-			seq_printf(seq, "not showing more requests...\n");
-			break;
-		}
-
-		seq_printf(seq, "%c req %p: %d bytes @%p, ",
-			   req == ep->req ? '*' : ' ',
-			   req, req->req.length, req->req.buf);
-		seq_printf(seq, "%d done, res %d\n",
-			   req->req.actual, req->req.status);
-	}
-
-	spin_unlock_irqrestore(&ep->lock, flags);
-
-	return 0;
-}
-
-static int ep_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, ep_show, inode->i_private);
-}
-
-static const struct file_operations ep_fops = {
-	.owner		= THIS_MODULE,
-	.open		= ep_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-/**
- * s3c_hsotg_create_debug - create debugfs directory and files
- * @hsotg: The driver state
- *
- * Create the debugfs files to allow the user to get information
- * about the state of the system. The directory name is created
- * with the same name as the device itself, in case we end up
- * with multiple blocks in future systems.
-*/
-static void __devinit s3c_hsotg_create_debug(struct s3c_hsotg *hsotg)
-{
-	struct dentry *root;
-	unsigned epidx;
-
-	root = debugfs_create_dir(dev_name(hsotg->dev), NULL);
-	hsotg->debug_root = root;
-	if (IS_ERR(root)) {
-		dev_err(hsotg->dev, "cannot create debug root\n");
-		return;
-	}
-
-	/* create general state file */
-
-	hsotg->debug_file = debugfs_create_file("state", 0444, root,
-						hsotg, &state_fops);
-
-	if (IS_ERR(hsotg->debug_file))
-		dev_err(hsotg->dev, "%s: failed to create state\n", __func__);
-
-	hsotg->debug_fifo = debugfs_create_file("fifo", 0444, root,
-						hsotg, &fifo_fops);
-
-	if (IS_ERR(hsotg->debug_fifo))
-		dev_err(hsotg->dev, "%s: failed to create fifo\n", __func__);
-
-	/* create one file for each endpoint */
-
-	for (epidx = 0; epidx < S3C_HSOTG_EPS; epidx++) {
-		struct s3c_hsotg_ep *ep = &hsotg->eps[epidx];
-
-		ep->debugfs = debugfs_create_file(ep->name, 0444,
-						  root, ep, &ep_fops);
-
-		if (IS_ERR(ep->debugfs))
-			dev_err(hsotg->dev, "failed to create %s debug file\n",
-				ep->name);
-	}
-}
-
-/**
- * s3c_hsotg_delete_debug - cleanup debugfs entries
- * @hsotg: The driver state
- *
- * Cleanup (remove) the debugfs files for use on module exit.
-*/
-static void __devexit s3c_hsotg_delete_debug(struct s3c_hsotg *hsotg)
-{
-	unsigned epidx;
-
-	for (epidx = 0; epidx < S3C_HSOTG_EPS; epidx++) {
-		struct s3c_hsotg_ep *ep = &hsotg->eps[epidx];
-		debugfs_remove(ep->debugfs);
-	}
-
-	debugfs_remove(hsotg->debug_file);
-	debugfs_remove(hsotg->debug_fifo);
-	debugfs_remove(hsotg->debug_root);
-}
-
-/**
- * s3c_hsotg_gate - set the hardware gate for the block
- * @pdev: The device we bound to
- * @on: On or off.
- *
- * Set the hardware gate setting into the block. If we end up on
- * something other than an S3C64XX, then we might need to change this
- * to using a platform data callback, or some other mechanism.
- */
-static void s3c_hsotg_gate(struct platform_device *pdev, bool on)
-{
-	unsigned long flags;
-	u32 others;
-
-	local_irq_save(flags);
-
-	others = __raw_readl(S3C64XX_OTHERS);
-	if (on)
-		others |= S3C64XX_OTHERS_USBMASK;
-	else
-		others &= ~S3C64XX_OTHERS_USBMASK;
-	__raw_writel(others, S3C64XX_OTHERS);
-
-	local_irq_restore(flags);
-}
-
-static struct s3c_hsotg_plat s3c_hsotg_default_pdata;
-
-static int __devinit s3c_hsotg_probe(struct platform_device *pdev)
-{
-	struct s3c_hsotg_plat *plat = pdev->dev.platform_data;
-	struct device *dev = &pdev->dev;
-	struct s3c_hsotg *hsotg;
-	struct resource *res;
-	int epnum;
-	int ret;
-
-	if (!plat)
-		plat = &s3c_hsotg_default_pdata;
-
-	hsotg = kzalloc(sizeof(struct s3c_hsotg) +
-			sizeof(struct s3c_hsotg_ep) * S3C_HSOTG_EPS,
-			GFP_KERNEL);
-	if (!hsotg) {
-		dev_err(dev, "cannot get memory\n");
-		return -ENOMEM;
-	}
-
-	hsotg->dev = dev;
-	hsotg->plat = plat;
-
-	hsotg->clk = clk_get(&pdev->dev, "otg");
-	if (IS_ERR(hsotg->clk)) {
-		dev_err(dev, "cannot get otg clock\n");
-		ret = PTR_ERR(hsotg->clk);
-		goto err_mem;
-	}
-
-	platform_set_drvdata(pdev, hsotg);
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(dev, "cannot find register resource 0\n");
-		ret = -EINVAL;
-		goto err_clk;
-	}
-
-	hsotg->regs_res = request_mem_region(res->start, resource_size(res),
-					     dev_name(dev));
-	if (!hsotg->regs_res) {
-		dev_err(dev, "cannot reserve registers\n");
-		ret = -ENOENT;
-		goto err_clk;
-	}
-
-	hsotg->regs = ioremap(res->start, resource_size(res));
-	if (!hsotg->regs) {
-		dev_err(dev, "cannot map registers\n");
-		ret = -ENXIO;
-		goto err_regs_res;
-	}
-
-	ret = platform_get_irq(pdev, 0);
-	if (ret < 0) {
-		dev_err(dev, "cannot find IRQ\n");
-		goto err_regs;
-	}
-
-	hsotg->irq = ret;
-
-	ret = request_irq(ret, s3c_hsotg_irq, 0, dev_name(dev), hsotg);
-	if (ret < 0) {
-		dev_err(dev, "cannot claim IRQ\n");
-		goto err_regs;
-	}
-
-	dev_info(dev, "regs %p, irq %d\n", hsotg->regs, hsotg->irq);
-
-	device_initialize(&hsotg->gadget.dev);
-
-	dev_set_name(&hsotg->gadget.dev, "gadget");
-
-	hsotg->gadget.max_speed = USB_SPEED_HIGH;
-	hsotg->gadget.ops = &s3c_hsotg_gadget_ops;
-	hsotg->gadget.name = dev_name(dev);
-
-	hsotg->gadget.dev.parent = dev;
-	hsotg->gadget.dev.dma_mask = dev->dma_mask;
-
-	/* setup endpoint information */
-
-	INIT_LIST_HEAD(&hsotg->gadget.ep_list);
-	hsotg->gadget.ep0 = &hsotg->eps[0].ep;
-
-	/* allocate EP0 request */
-
-	hsotg->ctrl_req = s3c_hsotg_ep_alloc_request(&hsotg->eps[0].ep,
-						     GFP_KERNEL);
-	if (!hsotg->ctrl_req) {
-		dev_err(dev, "failed to allocate ctrl req\n");
-		goto err_regs;
-	}
-
-	/* reset the system */
-
-	clk_enable(hsotg->clk);
-
-	s3c_hsotg_gate(pdev, true);
-
-	s3c_hsotg_otgreset(hsotg);
-	s3c_hsotg_corereset(hsotg);
-	s3c_hsotg_init(hsotg);
-
-	/* initialise the endpoints now the core has been initialised */
-	for (epnum = 0; epnum < S3C_HSOTG_EPS; epnum++)
-		s3c_hsotg_initep(hsotg, &hsotg->eps[epnum], epnum);
-
-	ret = usb_add_gadget_udc(&pdev->dev, &hsotg->gadget);
-	if (ret)
-		goto err_add_udc;
-
-	s3c_hsotg_create_debug(hsotg);
-
-	s3c_hsotg_dump(hsotg);
-
-	our_hsotg = hsotg;
-	return 0;
-
-err_add_udc:
-	s3c_hsotg_gate(pdev, false);
-	clk_disable(hsotg->clk);
-	clk_put(hsotg->clk);
-
-err_regs:
-	iounmap(hsotg->regs);
-
-err_regs_res:
-	release_resource(hsotg->regs_res);
-	kfree(hsotg->regs_res);
-err_clk:
-	clk_put(hsotg->clk);
-err_mem:
-	kfree(hsotg);
-	return ret;
-}
-
-static int __devexit s3c_hsotg_remove(struct platform_device *pdev)
-{
-	struct s3c_hsotg *hsotg = platform_get_drvdata(pdev);
-
-	usb_del_gadget_udc(&hsotg->gadget);
-
-	s3c_hsotg_delete_debug(hsotg);
-
-	usb_gadget_unregister_driver(hsotg->driver);
-
-	free_irq(hsotg->irq, hsotg);
-	iounmap(hsotg->regs);
-
-	release_resource(hsotg->regs_res);
-	kfree(hsotg->regs_res);
-
-	s3c_hsotg_gate(pdev, false);
-
-	clk_disable(hsotg->clk);
-	clk_put(hsotg->clk);
-
-	kfree(hsotg);
-	return 0;
-}
-
-#if 1
-#define s3c_hsotg_suspend NULL
-#define s3c_hsotg_resume NULL
-#endif
-
-static struct platform_driver s3c_hsotg_driver = {
-	.driver		= {
-		.name	= "s3c-hsotg",
-		.owner	= THIS_MODULE,
-	},
-	.probe		= s3c_hsotg_probe,
-	.remove		= __devexit_p(s3c_hsotg_remove),
-	.suspend	= s3c_hsotg_suspend,
-	.resume		= s3c_hsotg_resume,
-};
-
-module_platform_driver(s3c_hsotg_driver);
-
-MODULE_DESCRIPTION("Samsung S3C USB High-speed/OtG device");
-MODULE_AUTHOR("Ben Dooks <ben@simtec.co.uk>");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:s3c-hsotg");
diff --git a/drivers/usb/gadget/s3c-hsotg.h b/drivers/usb/gadget/s3c-hsotg.h
deleted file mode 100644
index 4c4ccc4..0000000
--- a/drivers/usb/gadget/s3c-hsotg.h
+++ /dev/null
@@ -1,379 +0,0 @@
-/* arch/arm/plat-s3c/include/plat/regs-usb-hsotg.h
- *
- * Copyright 2008 Openmoko, Inc.
- * Copyright 2008 Simtec Electronics
- *      http://armlinux.simtec.co.uk/
- *      Ben Dooks <ben@simtec.co.uk>
- *
- * S3C - USB2.0 Highspeed/OtG device block registers
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
-*/
-
-#ifndef __PLAT_S3C64XX_REGS_USB_HSOTG_H
-#define __PLAT_S3C64XX_REGS_USB_HSOTG_H __FILE__
-
-#define S3C_HSOTG_REG(x) (x)
-
-#define S3C_GOTGCTL				S3C_HSOTG_REG(0x000)
-#define S3C_GOTGCTL_BSESVLD			(1 << 19)
-#define S3C_GOTGCTL_ASESVLD			(1 << 18)
-#define S3C_GOTGCTL_DBNC_SHORT			(1 << 17)
-#define S3C_GOTGCTL_CONID_B			(1 << 16)
-#define S3C_GOTGCTL_DEVHNPEN			(1 << 11)
-#define S3C_GOTGCTL_HSSETHNPEN			(1 << 10)
-#define S3C_GOTGCTL_HNPREQ			(1 << 9)
-#define S3C_GOTGCTL_HSTNEGSCS			(1 << 8)
-#define S3C_GOTGCTL_SESREQ			(1 << 1)
-#define S3C_GOTGCTL_SESREQSCS			(1 << 0)
-
-#define S3C_GOTGINT				S3C_HSOTG_REG(0x004)
-#define S3C_GOTGINT_DbnceDone			(1 << 19)
-#define S3C_GOTGINT_ADevTOUTChg			(1 << 18)
-#define S3C_GOTGINT_HstNegDet			(1 << 17)
-#define S3C_GOTGINT_HstnegSucStsChng		(1 << 9)
-#define S3C_GOTGINT_SesReqSucStsChng		(1 << 8)
-#define S3C_GOTGINT_SesEndDet			(1 << 2)
-
-#define S3C_GAHBCFG				S3C_HSOTG_REG(0x008)
-#define S3C_GAHBCFG_PTxFEmpLvl			(1 << 8)
-#define S3C_GAHBCFG_NPTxFEmpLvl			(1 << 7)
-#define S3C_GAHBCFG_DMAEn			(1 << 5)
-#define S3C_GAHBCFG_HBstLen_MASK		(0xf << 1)
-#define S3C_GAHBCFG_HBstLen_SHIFT		(1)
-#define S3C_GAHBCFG_HBstLen_Single		(0x0 << 1)
-#define S3C_GAHBCFG_HBstLen_Incr		(0x1 << 1)
-#define S3C_GAHBCFG_HBstLen_Incr4		(0x3 << 1)
-#define S3C_GAHBCFG_HBstLen_Incr8		(0x5 << 1)
-#define S3C_GAHBCFG_HBstLen_Incr16		(0x7 << 1)
-#define S3C_GAHBCFG_GlblIntrEn			(1 << 0)
-
-#define S3C_GUSBCFG				S3C_HSOTG_REG(0x00C)
-#define S3C_GUSBCFG_PHYLPClkSel			(1 << 15)
-#define S3C_GUSBCFG_HNPCap			(1 << 9)
-#define S3C_GUSBCFG_SRPCap			(1 << 8)
-#define S3C_GUSBCFG_PHYIf16			(1 << 3)
-#define S3C_GUSBCFG_TOutCal_MASK		(0x7 << 0)
-#define S3C_GUSBCFG_TOutCal_SHIFT		(0)
-#define S3C_GUSBCFG_TOutCal_LIMIT		(0x7)
-#define S3C_GUSBCFG_TOutCal(_x)			((_x) << 0)
-
-#define S3C_GRSTCTL				S3C_HSOTG_REG(0x010)
-
-#define S3C_GRSTCTL_AHBIdle			(1 << 31)
-#define S3C_GRSTCTL_DMAReq			(1 << 30)
-#define S3C_GRSTCTL_TxFNum_MASK			(0x1f << 6)
-#define S3C_GRSTCTL_TxFNum_SHIFT		(6)
-#define S3C_GRSTCTL_TxFNum_LIMIT		(0x1f)
-#define S3C_GRSTCTL_TxFNum(_x)			((_x) << 6)
-#define S3C_GRSTCTL_TxFFlsh			(1 << 5)
-#define S3C_GRSTCTL_RxFFlsh			(1 << 4)
-#define S3C_GRSTCTL_INTknQFlsh			(1 << 3)
-#define S3C_GRSTCTL_FrmCntrRst			(1 << 2)
-#define S3C_GRSTCTL_HSftRst			(1 << 1)
-#define S3C_GRSTCTL_CSftRst			(1 << 0)
-
-#define S3C_GINTSTS				S3C_HSOTG_REG(0x014)
-#define S3C_GINTMSK				S3C_HSOTG_REG(0x018)
-
-#define S3C_GINTSTS_WkUpInt			(1 << 31)
-#define S3C_GINTSTS_SessReqInt			(1 << 30)
-#define S3C_GINTSTS_DisconnInt			(1 << 29)
-#define S3C_GINTSTS_ConIDStsChng		(1 << 28)
-#define S3C_GINTSTS_PTxFEmp			(1 << 26)
-#define S3C_GINTSTS_HChInt			(1 << 25)
-#define S3C_GINTSTS_PrtInt			(1 << 24)
-#define S3C_GINTSTS_FetSusp			(1 << 22)
-#define S3C_GINTSTS_incompIP			(1 << 21)
-#define S3C_GINTSTS_IncomplSOIN			(1 << 20)
-#define S3C_GINTSTS_OEPInt			(1 << 19)
-#define S3C_GINTSTS_IEPInt			(1 << 18)
-#define S3C_GINTSTS_EPMis			(1 << 17)
-#define S3C_GINTSTS_EOPF			(1 << 15)
-#define S3C_GINTSTS_ISOutDrop			(1 << 14)
-#define S3C_GINTSTS_EnumDone			(1 << 13)
-#define S3C_GINTSTS_USBRst			(1 << 12)
-#define S3C_GINTSTS_USBSusp			(1 << 11)
-#define S3C_GINTSTS_ErlySusp			(1 << 10)
-#define S3C_GINTSTS_GOUTNakEff			(1 << 7)
-#define S3C_GINTSTS_GINNakEff			(1 << 6)
-#define S3C_GINTSTS_NPTxFEmp			(1 << 5)
-#define S3C_GINTSTS_RxFLvl			(1 << 4)
-#define S3C_GINTSTS_SOF				(1 << 3)
-#define S3C_GINTSTS_OTGInt			(1 << 2)
-#define S3C_GINTSTS_ModeMis			(1 << 1)
-#define S3C_GINTSTS_CurMod_Host			(1 << 0)
-
-#define S3C_GRXSTSR				S3C_HSOTG_REG(0x01C)
-#define S3C_GRXSTSP				S3C_HSOTG_REG(0x020)
-
-#define S3C_GRXSTS_FN_MASK			(0x7f << 25)
-#define S3C_GRXSTS_FN_SHIFT			(25)
-
-#define S3C_GRXSTS_PktSts_MASK			(0xf << 17)
-#define S3C_GRXSTS_PktSts_SHIFT			(17)
-#define S3C_GRXSTS_PktSts_GlobalOutNAK		(0x1 << 17)
-#define S3C_GRXSTS_PktSts_OutRX			(0x2 << 17)
-#define S3C_GRXSTS_PktSts_OutDone		(0x3 << 17)
-#define S3C_GRXSTS_PktSts_SetupDone		(0x4 << 17)
-#define S3C_GRXSTS_PktSts_SetupRX		(0x6 << 17)
-
-#define S3C_GRXSTS_DPID_MASK			(0x3 << 15)
-#define S3C_GRXSTS_DPID_SHIFT			(15)
-#define S3C_GRXSTS_ByteCnt_MASK			(0x7ff << 4)
-#define S3C_GRXSTS_ByteCnt_SHIFT		(4)
-#define S3C_GRXSTS_EPNum_MASK			(0xf << 0)
-#define S3C_GRXSTS_EPNum_SHIFT			(0)
-
-#define S3C_GRXFSIZ				S3C_HSOTG_REG(0x024)
-
-#define S3C_GNPTXFSIZ				S3C_HSOTG_REG(0x028)
-
-#define S3C_GNPTXFSIZ_NPTxFDep_MASK		(0xffff << 16)
-#define S3C_GNPTXFSIZ_NPTxFDep_SHIFT		(16)
-#define S3C_GNPTXFSIZ_NPTxFDep_LIMIT		(0xffff)
-#define S3C_GNPTXFSIZ_NPTxFDep(_x)		((_x) << 16)
-#define S3C_GNPTXFSIZ_NPTxFStAddr_MASK		(0xffff << 0)
-#define S3C_GNPTXFSIZ_NPTxFStAddr_SHIFT		(0)
-#define S3C_GNPTXFSIZ_NPTxFStAddr_LIMIT		(0xffff)
-#define S3C_GNPTXFSIZ_NPTxFStAddr(_x)		((_x) << 0)
-
-#define S3C_GNPTXSTS				S3C_HSOTG_REG(0x02C)
-
-#define S3C_GNPTXSTS_NPtxQTop_MASK		(0x7f << 24)
-#define S3C_GNPTXSTS_NPtxQTop_SHIFT		(24)
-
-#define S3C_GNPTXSTS_NPTxQSpcAvail_MASK		(0xff << 16)
-#define S3C_GNPTXSTS_NPTxQSpcAvail_SHIFT	(16)
-#define S3C_GNPTXSTS_NPTxQSpcAvail_GET(_v)	(((_v) >> 16) & 0xff)
-
-#define S3C_GNPTXSTS_NPTxFSpcAvail_MASK		(0xffff << 0)
-#define S3C_GNPTXSTS_NPTxFSpcAvail_SHIFT	(0)
-#define S3C_GNPTXSTS_NPTxFSpcAvail_GET(_v)	(((_v) >> 0) & 0xffff)
-
-
-#define S3C_HPTXFSIZ				S3C_HSOTG_REG(0x100)
-
-#define S3C_DPTXFSIZn(_a)		S3C_HSOTG_REG(0x104 + (((_a) - 1) * 4))
-
-#define S3C_DPTXFSIZn_DPTxFSize_MASK		(0xffff << 16)
-#define S3C_DPTXFSIZn_DPTxFSize_SHIFT		(16)
-#define S3C_DPTXFSIZn_DPTxFSize_GET(_v)		(((_v) >> 16) & 0xffff)
-#define S3C_DPTXFSIZn_DPTxFSize_LIMIT		(0xffff)
-#define S3C_DPTXFSIZn_DPTxFSize(_x)		((_x) << 16)
-
-#define S3C_DPTXFSIZn_DPTxFStAddr_MASK		(0xffff << 0)
-#define S3C_DPTXFSIZn_DPTxFStAddr_SHIFT		(0)
-
-/* Device mode registers */
-#define S3C_DCFG				S3C_HSOTG_REG(0x800)
-
-#define S3C_DCFG_EPMisCnt_MASK			(0x1f << 18)
-#define S3C_DCFG_EPMisCnt_SHIFT			(18)
-#define S3C_DCFG_EPMisCnt_LIMIT			(0x1f)
-#define S3C_DCFG_EPMisCnt(_x)			((_x) << 18)
-
-#define S3C_DCFG_PerFrInt_MASK			(0x3 << 11)
-#define S3C_DCFG_PerFrInt_SHIFT			(11)
-#define S3C_DCFG_PerFrInt_LIMIT			(0x3)
-#define S3C_DCFG_PerFrInt(_x)			((_x) << 11)
-
-#define S3C_DCFG_DevAddr_MASK			(0x7f << 4)
-#define S3C_DCFG_DevAddr_SHIFT			(4)
-#define S3C_DCFG_DevAddr_LIMIT			(0x7f)
-#define S3C_DCFG_DevAddr(_x)			((_x) << 4)
-
-#define S3C_DCFG_NZStsOUTHShk			(1 << 2)
-
-#define S3C_DCFG_DevSpd_MASK			(0x3 << 0)
-#define S3C_DCFG_DevSpd_SHIFT			(0)
-#define S3C_DCFG_DevSpd_HS			(0x0 << 0)
-#define S3C_DCFG_DevSpd_FS			(0x1 << 0)
-#define S3C_DCFG_DevSpd_LS			(0x2 << 0)
-#define S3C_DCFG_DevSpd_FS48			(0x3 << 0)
-
-#define S3C_DCTL				S3C_HSOTG_REG(0x804)
-
-#define S3C_DCTL_PWROnPrgDone			(1 << 11)
-#define S3C_DCTL_CGOUTNak			(1 << 10)
-#define S3C_DCTL_SGOUTNak			(1 << 9)
-#define S3C_DCTL_CGNPInNAK			(1 << 8)
-#define S3C_DCTL_SGNPInNAK			(1 << 7)
-#define S3C_DCTL_TstCtl_MASK			(0x7 << 4)
-#define S3C_DCTL_TstCtl_SHIFT			(4)
-#define S3C_DCTL_GOUTNakSts			(1 << 3)
-#define S3C_DCTL_GNPINNakSts			(1 << 2)
-#define S3C_DCTL_SftDiscon			(1 << 1)
-#define S3C_DCTL_RmtWkUpSig			(1 << 0)
-
-#define S3C_DSTS				S3C_HSOTG_REG(0x808)
-
-#define S3C_DSTS_SOFFN_MASK			(0x3fff << 8)
-#define S3C_DSTS_SOFFN_SHIFT			(8)
-#define S3C_DSTS_SOFFN_LIMIT			(0x3fff)
-#define S3C_DSTS_SOFFN(_x)			((_x) << 8)
-#define S3C_DSTS_ErraticErr			(1 << 3)
-#define S3C_DSTS_EnumSpd_MASK			(0x3 << 1)
-#define S3C_DSTS_EnumSpd_SHIFT			(1)
-#define S3C_DSTS_EnumSpd_HS			(0x0 << 1)
-#define S3C_DSTS_EnumSpd_FS			(0x1 << 1)
-#define S3C_DSTS_EnumSpd_LS			(0x2 << 1)
-#define S3C_DSTS_EnumSpd_FS48			(0x3 << 1)
-
-#define S3C_DSTS_SuspSts			(1 << 0)
-
-#define S3C_DIEPMSK				S3C_HSOTG_REG(0x810)
-
-#define S3C_DIEPMSK_TxFIFOEmpty			(1 << 7)
-#define S3C_DIEPMSK_INEPNakEffMsk		(1 << 6)
-#define S3C_DIEPMSK_INTknEPMisMsk		(1 << 5)
-#define S3C_DIEPMSK_INTknTXFEmpMsk		(1 << 4)
-#define S3C_DIEPMSK_TimeOUTMsk			(1 << 3)
-#define S3C_DIEPMSK_AHBErrMsk			(1 << 2)
-#define S3C_DIEPMSK_EPDisbldMsk			(1 << 1)
-#define S3C_DIEPMSK_XferComplMsk		(1 << 0)
-
-#define S3C_DOEPMSK				S3C_HSOTG_REG(0x814)
-
-#define S3C_DOEPMSK_Back2BackSetup		(1 << 6)
-#define S3C_DOEPMSK_OUTTknEPdisMsk		(1 << 4)
-#define S3C_DOEPMSK_SetupMsk			(1 << 3)
-#define S3C_DOEPMSK_AHBErrMsk			(1 << 2)
-#define S3C_DOEPMSK_EPDisbldMsk			(1 << 1)
-#define S3C_DOEPMSK_XferComplMsk		(1 << 0)
-
-#define S3C_DAINT				S3C_HSOTG_REG(0x818)
-#define S3C_DAINTMSK				S3C_HSOTG_REG(0x81C)
-
-#define S3C_DAINT_OutEP_SHIFT			(16)
-#define S3C_DAINT_OutEP(x)			(1 << ((x) + 16))
-#define S3C_DAINT_InEP(x)			(1 << (x))
-
-#define S3C_DTKNQR1				S3C_HSOTG_REG(0x820)
-#define S3C_DTKNQR2				S3C_HSOTG_REG(0x824)
-#define S3C_DTKNQR3				S3C_HSOTG_REG(0x830)
-#define S3C_DTKNQR4				S3C_HSOTG_REG(0x834)
-
-#define S3C_DVBUSDIS				S3C_HSOTG_REG(0x828)
-#define S3C_DVBUSPULSE				S3C_HSOTG_REG(0x82C)
-
-#define S3C_DIEPCTL0				S3C_HSOTG_REG(0x900)
-#define S3C_DOEPCTL0				S3C_HSOTG_REG(0xB00)
-#define S3C_DIEPCTL(_a)			S3C_HSOTG_REG(0x900 + ((_a) * 0x20))
-#define S3C_DOEPCTL(_a)			S3C_HSOTG_REG(0xB00 + ((_a) * 0x20))
-
-/* EP0 specialness:
- * bits[29..28] - reserved (no SetD0PID, SetD1PID)
- * bits[25..22] - should always be zero, this isn't a periodic endpoint
- * bits[10..0] - MPS setting differenct for EP0
-*/
-#define S3C_D0EPCTL_MPS_MASK			(0x3 << 0)
-#define S3C_D0EPCTL_MPS_SHIFT			(0)
-#define S3C_D0EPCTL_MPS_64			(0x0 << 0)
-#define S3C_D0EPCTL_MPS_32			(0x1 << 0)
-#define S3C_D0EPCTL_MPS_16			(0x2 << 0)
-#define S3C_D0EPCTL_MPS_8			(0x3 << 0)
-
-#define S3C_DxEPCTL_EPEna			(1 << 31)
-#define S3C_DxEPCTL_EPDis			(1 << 30)
-#define S3C_DxEPCTL_SetD1PID			(1 << 29)
-#define S3C_DxEPCTL_SetOddFr			(1 << 29)
-#define S3C_DxEPCTL_SetD0PID			(1 << 28)
-#define S3C_DxEPCTL_SetEvenFr			(1 << 28)
-#define S3C_DxEPCTL_SNAK			(1 << 27)
-#define S3C_DxEPCTL_CNAK			(1 << 26)
-#define S3C_DxEPCTL_TxFNum_MASK			(0xf << 22)
-#define S3C_DxEPCTL_TxFNum_SHIFT		(22)
-#define S3C_DxEPCTL_TxFNum_LIMIT		(0xf)
-#define S3C_DxEPCTL_TxFNum(_x)			((_x) << 22)
-
-#define S3C_DxEPCTL_Stall			(1 << 21)
-#define S3C_DxEPCTL_Snp				(1 << 20)
-#define S3C_DxEPCTL_EPType_MASK			(0x3 << 18)
-#define S3C_DxEPCTL_EPType_SHIFT		(18)
-#define S3C_DxEPCTL_EPType_Control		(0x0 << 18)
-#define S3C_DxEPCTL_EPType_Iso			(0x1 << 18)
-#define S3C_DxEPCTL_EPType_Bulk			(0x2 << 18)
-#define S3C_DxEPCTL_EPType_Intterupt		(0x3 << 18)
-
-#define S3C_DxEPCTL_NAKsts			(1 << 17)
-#define S3C_DxEPCTL_DPID			(1 << 16)
-#define S3C_DxEPCTL_EOFrNum			(1 << 16)
-#define S3C_DxEPCTL_USBActEp			(1 << 15)
-#define S3C_DxEPCTL_NextEp_MASK			(0xf << 11)
-#define S3C_DxEPCTL_NextEp_SHIFT		(11)
-#define S3C_DxEPCTL_NextEp_LIMIT		(0xf)
-#define S3C_DxEPCTL_NextEp(_x)			((_x) << 11)
-
-#define S3C_DxEPCTL_MPS_MASK			(0x7ff << 0)
-#define S3C_DxEPCTL_MPS_SHIFT			(0)
-#define S3C_DxEPCTL_MPS_LIMIT			(0x7ff)
-#define S3C_DxEPCTL_MPS(_x)			((_x) << 0)
-
-#define S3C_DIEPINT(_a)			S3C_HSOTG_REG(0x908 + ((_a) * 0x20))
-#define S3C_DOEPINT(_a)			S3C_HSOTG_REG(0xB08 + ((_a) * 0x20))
-
-#define S3C_DxEPINT_INEPNakEff			(1 << 6)
-#define S3C_DxEPINT_Back2BackSetup		(1 << 6)
-#define S3C_DxEPINT_INTknEPMis			(1 << 5)
-#define S3C_DxEPINT_INTknTXFEmp			(1 << 4)
-#define S3C_DxEPINT_OUTTknEPdis			(1 << 4)
-#define S3C_DxEPINT_Timeout			(1 << 3)
-#define S3C_DxEPINT_Setup			(1 << 3)
-#define S3C_DxEPINT_AHBErr			(1 << 2)
-#define S3C_DxEPINT_EPDisbld			(1 << 1)
-#define S3C_DxEPINT_XferCompl			(1 << 0)
-
-#define S3C_DIEPTSIZ0				S3C_HSOTG_REG(0x910)
-
-#define S3C_DIEPTSIZ0_PktCnt_MASK		(0x3 << 19)
-#define S3C_DIEPTSIZ0_PktCnt_SHIFT		(19)
-#define S3C_DIEPTSIZ0_PktCnt_LIMIT		(0x3)
-#define S3C_DIEPTSIZ0_PktCnt(_x)		((_x) << 19)
-
-#define S3C_DIEPTSIZ0_XferSize_MASK		(0x7f << 0)
-#define S3C_DIEPTSIZ0_XferSize_SHIFT		(0)
-#define S3C_DIEPTSIZ0_XferSize_LIMIT		(0x7f)
-#define S3C_DIEPTSIZ0_XferSize(_x)		((_x) << 0)
-
-
-#define DOEPTSIZ0				S3C_HSOTG_REG(0xB10)
-#define S3C_DOEPTSIZ0_SUPCnt_MASK		(0x3 << 29)
-#define S3C_DOEPTSIZ0_SUPCnt_SHIFT		(29)
-#define S3C_DOEPTSIZ0_SUPCnt_LIMIT		(0x3)
-#define S3C_DOEPTSIZ0_SUPCnt(_x)		((_x) << 29)
-
-#define S3C_DOEPTSIZ0_PktCnt			(1 << 19)
-#define S3C_DOEPTSIZ0_XferSize_MASK		(0x7f << 0)
-#define S3C_DOEPTSIZ0_XferSize_SHIFT		(0)
-
-#define S3C_DIEPTSIZ(_a)		S3C_HSOTG_REG(0x910 + ((_a) * 0x20))
-#define S3C_DOEPTSIZ(_a)		S3C_HSOTG_REG(0xB10 + ((_a) * 0x20))
-
-#define S3C_DxEPTSIZ_MC_MASK			(0x3 << 29)
-#define S3C_DxEPTSIZ_MC_SHIFT			(29)
-#define S3C_DxEPTSIZ_MC_LIMIT			(0x3)
-#define S3C_DxEPTSIZ_MC(_x)			((_x) << 29)
-
-#define S3C_DxEPTSIZ_PktCnt_MASK		(0x3ff << 19)
-#define S3C_DxEPTSIZ_PktCnt_SHIFT		(19)
-#define S3C_DxEPTSIZ_PktCnt_GET(_v)		(((_v) >> 19) & 0x3ff)
-#define S3C_DxEPTSIZ_PktCnt_LIMIT		(0x3ff)
-#define S3C_DxEPTSIZ_PktCnt(_x)			((_x) << 19)
-
-#define S3C_DxEPTSIZ_XferSize_MASK		(0x7ffff << 0)
-#define S3C_DxEPTSIZ_XferSize_SHIFT		(0)
-#define S3C_DxEPTSIZ_XferSize_GET(_v)		(((_v) >> 0) & 0x7ffff)
-#define S3C_DxEPTSIZ_XferSize_LIMIT		(0x7ffff)
-#define S3C_DxEPTSIZ_XferSize(_x)		((_x) << 0)
-
-
-#define S3C_DIEPDMA(_a)			S3C_HSOTG_REG(0x914 + ((_a) * 0x20))
-#define S3C_DOEPDMA(_a)			S3C_HSOTG_REG(0xB14 + ((_a) * 0x20))
-#define S3C_DTXFSTS(_a)			S3C_HSOTG_REG(0x918 + ((_a) * 0x20))
-
-#define S3C_EPFIFO(_a)			S3C_HSOTG_REG(0x1000 + ((_a) * 0x1000))
-
-#endif /* __PLAT_S3C64XX_REGS_USB_HSOTG_H */
-- 
1.7.5.4

