From 3637885d5905ecc897504ea5369c86b3ccb2d243 Mon Sep 17 00:00:00 2001
From: Tien Hock Loh <thloh@altera.com>
Date: Fri, 1 Feb 2013 19:35:01 +0800
Subject: [PATCH 037/248] FogBugz #95976: Altera GPIO soft IP driver

Port Altera GPIO soft IP driver from mpc8xxx so that IRQ is supported for Altera GPIO driver

[Original patch taken from
git://git.rocketboards.org/linux-socfpga.git socfpga-3.14]

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
Signed-off-by: Tien Hock Loh <thloh@altera.com>
---
 .../devicetree/bindings/gpio/gpio-altera.txt       |  33 ++
 drivers/gpio/Makefile                              |   2 +-
 drivers/gpio/gpio-altera.c                         | 402 +++++++++++++--------
 3 files changed, 277 insertions(+), 160 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/gpio/gpio-altera.txt

diff --git a/Documentation/devicetree/bindings/gpio/gpio-altera.txt b/Documentation/devicetree/bindings/gpio/gpio-altera.txt
new file mode 100644
index 0000000..39cead5
--- /dev/null
+++ b/Documentation/devicetree/bindings/gpio/gpio-altera.txt
@@ -0,0 +1,33 @@
+Altera GPIO controller bindings
+
+Required properties:
+- compatible:
+  - "altr,pio-1.0"
+- #gpio-cells : Should be two.
+  - first cell is the pin number
+  - second cell is used to specify optional parameters (unused)
+- gpio-controller : Marks the device node as a GPIO controller.
+- #interrupt-cells : Should be 1.
+- interrupt-controller: Mark the device node as an interrupt controller
+  The first cell is the GPIO number.
+
+Altera GPIO specific properties:
+- width: Width of the GPIO bank, range from 1-32
+- level_trigger: Specifies whether the GPIO interrupt is level trigger.
+  This field is required if the Altera GPIO controller used has IRQ enabled.
+
+Note: If the Altera GPIO is set to be built as a module, peripherals that uses
+Altera GPIO as interrupt-parent should be a module so that the peripheral
+doesn't get initialized before Altera GPIO is initialized.
+
+Example:
+
+gpio_altr: gpio_altr {
+    compatible = "altr,pio-1.0";
+    width = <32>;
+    level_trigger = <0>;
+    #gpio-cells = <2>;
+    gpio-controller;
+    #interrupt-cells = <1>;
+    interrupt-controller;
+};
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index b730fdf..3e67d33 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -15,7 +15,7 @@ obj-$(CONFIG_GPIO_74X164)	+= gpio-74x164.o
 obj-$(CONFIG_GPIO_ADNP)		+= gpio-adnp.o
 obj-$(CONFIG_GPIO_ADP5520)	+= gpio-adp5520.o
 obj-$(CONFIG_GPIO_ADP5588)	+= gpio-adp5588.o
-obj-$(CONFIG_GPIO_ALTERA)  += gpio-altera.o
+obj-$(CONFIG_GPIO_ALTERA)  	+= gpio-altera.o
 obj-$(CONFIG_GPIO_AMD8111)	+= gpio-amd8111.o
 obj-$(CONFIG_GPIO_ARIZONA)	+= gpio-arizona.o
 obj-$(CONFIG_GPIO_BCM_KONA)	+= gpio-bcm-kona.o
diff --git a/drivers/gpio/gpio-altera.c b/drivers/gpio/gpio-altera.c
index 42842d9..763aa2f 100644
--- a/drivers/gpio/gpio-altera.c
+++ b/drivers/gpio/gpio-altera.c
@@ -1,243 +1,329 @@
 /*
- * Altera GPIO driver
+ * Copyright (C) 2013 Altera Corporation
+ * Based on gpio-mpc8xxx.c
  *
- * Copyright (C) 2012 Tobias Klauser <tklauser@distanz.ch>
- * Copyright (C) 2011 Thomas Chou <thomas@wytron.com.tw>
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
  *
- * Based on Xilinx gpio driver, which is
- * Copyright 2008 Xilinx, Inc.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation.
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>
  */
 
-#include <linux/module.h>
 #include <linux/gpio.h>
+#include <linux/kernel.h>
 #include <linux/slab.h>
+#include <linux/module.h>
 #include <linux/io.h>
-#include <linux/of_gpio.h>
+#include <linux/irq.h>
 #include <linux/of_irq.h>
+#include <linux/irqdomain.h>
+#include <linux/interrupt.h>
+#include <linux/of_gpio.h>
 #include <linux/platform_device.h>
 
-#define DRV_NAME "altera_gpio"
-
-/* Register Offset Definitions */
-#define ALTERA_GPIO_DATA_OFFSET		0x0	/* Data register  */
-#define ALTERA_GPIO_DIR_OFFSET		0x4	/* I/O direction register  */
+#define ALTERA_GPIO_DATA		0x0
+#define ALTERA_GPIO_DIR			0x4
 #define ALTERA_GPIO_IRQ_MASK		0x8
 #define ALTERA_GPIO_EDGE_CAP		0xc
+#define ALTERA_GPIO_OUTSET		0x10
+#define ALTERA_GPIO_OUTCLEAR		0x14
 
-struct altera_gpio_instance {
+struct altera_gpio_chip {
 	struct of_mm_gpio_chip mmchip;
-	u32 gpio_state;		/* GPIO state shadow register */
-	u32 gpio_dir;		/* GPIO direction shadow register */
-	int irq;		/* GPIO controller IRQ number */
-	int irq_base;		/* base number for the "virtual" GPIO IRQs */
-	u32 irq_mask;		/* IRQ mask */
+	struct irq_domain *irq;	/* GPIO controller IRQ number */
 	spinlock_t gpio_lock;	/* Lock used for synchronization */
+	int level_trigger;
+	int hwirq;
 };
 
-static inline struct altera_gpio_instance *to_altera_gpio(
-	struct of_mm_gpio_chip *mm_gc)
+static void altera_gpio_irq_unmask(struct irq_data *d)
 {
-	return container_of(mm_gc, struct altera_gpio_instance, mmchip);
+	struct altera_gpio_chip *altera_gc = irq_data_get_irq_chip_data(d);
+	struct of_mm_gpio_chip *mm_gc = &altera_gc->mmchip;
+	unsigned long flags;
+	unsigned int intmask;
+
+	spin_lock_irqsave(&altera_gc->gpio_lock, flags);
+	intmask = readl(mm_gc->regs + ALTERA_GPIO_IRQ_MASK);
+	/* Set ALTERA_GPIO_IRQ_MASK bit to unmask */
+	intmask |= (1 << irqd_to_hwirq(d));
+	writel(intmask, mm_gc->regs + ALTERA_GPIO_IRQ_MASK);
+	spin_unlock_irqrestore(&altera_gc->gpio_lock, flags);
 }
 
-/*
- * altera_gpio_get - Read the specified signal of the GPIO device.
- * @gc:     Pointer to gpio_chip device structure.
- * @gpio:   GPIO signal number.
- *
- * This function reads the specified signal of the GPIO device. It returns 0 if
- * the signal clear, 1 if signal is set or negative value on error.
- */
-static int altera_gpio_get(struct gpio_chip *gc, unsigned int gpio)
+static void altera_gpio_irq_mask(struct irq_data *d)
 {
-	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
-	struct altera_gpio_instance *chip = to_altera_gpio(mm_gc);
-	void __iomem *edge_cap = mm_gc->regs + ALTERA_GPIO_EDGE_CAP;
-	unsigned long value;
-
-	if (chip->irq >= 0) {
-		if (__raw_readl(edge_cap) & (1 << gpio))
-			__raw_writel(1 << gpio, edge_cap);
-	}
+	struct altera_gpio_chip *altera_gc = irq_data_get_irq_chip_data(d);
+	struct of_mm_gpio_chip *mm_gc = &altera_gc->mmchip;
+	unsigned long flags;
+	unsigned int intmask;
+
+	spin_lock_irqsave(&altera_gc->gpio_lock, flags);
+	intmask = readl(mm_gc->regs + ALTERA_GPIO_IRQ_MASK);
+	/* Clear ALTERA_GPIO_IRQ_MASK bit to mask */
+	intmask &= ~(1 << irqd_to_hwirq(d));
+	writel(intmask, mm_gc->regs + ALTERA_GPIO_IRQ_MASK);
+	spin_unlock_irqrestore(&altera_gc->gpio_lock, flags);
+}
 
-	value = __raw_readl(mm_gc->regs + ALTERA_GPIO_DATA_OFFSET);
-	return (value >> gpio) & 1;
+static int altera_gpio_irq_set_type(struct irq_data *d,
+				unsigned int type)
+{
+	if (type == IRQ_TYPE_NONE)
+		return 0;
+	return -EINVAL;
 }
 
-/*
- * altera_gpio_set - Write the specified signal of the GPIO device.
- * @gc:     Pointer to gpio_chip device structure.
- * @gpio:   GPIO signal number.
- * @val:    Value to be written to specified signal.
- *
- * This function writes the specified value in to the specified signal of the
- * GPIO device.
- */
-static void altera_gpio_set(struct gpio_chip *gc, unsigned int gpio, int val)
+static struct irq_chip altera_irq_chip = {
+	.name		= "altera-gpio",
+	.irq_mask	= altera_gpio_irq_mask,
+	.irq_unmask	= altera_gpio_irq_unmask,
+	.irq_set_type	= altera_gpio_irq_set_type,
+};
+
+static int altera_gpio_get(struct gpio_chip *gc, unsigned offset)
 {
-	unsigned long flags;
 	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
-	struct altera_gpio_instance *chip = to_altera_gpio(mm_gc);
 
-	spin_lock_irqsave(&chip->gpio_lock, flags);
+	return (readl(mm_gc->regs + ALTERA_GPIO_DATA) >> offset) & 1;
+}
 
-	/* Write to shadow register and output */
-	if (val)
-		chip->gpio_state |= 1 << gpio;
-	else
-		chip->gpio_state &= ~(1 << gpio);
-	__raw_writel(chip->gpio_state, mm_gc->regs + ALTERA_GPIO_DATA_OFFSET);
+static void altera_gpio_set(struct gpio_chip *gc, unsigned offset, int value)
+{
+	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
+	struct altera_gpio_chip *chip = container_of(mm_gc,
+				struct altera_gpio_chip, mmchip);
+	unsigned long flags;
+	unsigned int data_reg;
 
+	spin_lock_irqsave(&chip->gpio_lock, flags);
+	data_reg = readl(mm_gc->regs + ALTERA_GPIO_DATA);
+	data_reg = (data_reg & ~(1 << offset)) | (value << offset);
+	writel(data_reg, mm_gc->regs + ALTERA_GPIO_DATA);
 	spin_unlock_irqrestore(&chip->gpio_lock, flags);
 }
 
-/*
- * altera_gpio_dir_in - Set the direction of the specified GPIO signal as input.
- * @gc:     Pointer to gpio_chip device structure.
- * @gpio:   GPIO signal number.
- *
- * This function sets the direction of specified GPIO signal as input.
- * It returns 0 if direction of GPIO signals is set as input otherwise it
- * returns negative error value.
- */
-static int altera_gpio_dir_in(struct gpio_chip *gc, unsigned int gpio)
+static int altera_gpio_direction_input(struct gpio_chip *gc, unsigned offset)
 {
-	unsigned long flags;
 	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
-	struct altera_gpio_instance *chip = to_altera_gpio(mm_gc);
+	struct altera_gpio_chip *chip = container_of(mm_gc,
+				struct altera_gpio_chip, mmchip);
+	unsigned long flags;
+	unsigned int gpio_ddr;
 
 	spin_lock_irqsave(&chip->gpio_lock, flags);
-
-	/* Clear the GPIO bit in shadow register and set direction as input */
-	chip->gpio_dir &= ~(1 << gpio);
-	__raw_writel(chip->gpio_dir, mm_gc->regs + ALTERA_GPIO_DIR_OFFSET);
-
+	/* Set pin as input, assumes software controlled IP */
+	gpio_ddr = readl(mm_gc->regs + ALTERA_GPIO_DIR);
+	gpio_ddr &= ~(1 << offset);
+	writel(gpio_ddr, mm_gc->regs + ALTERA_GPIO_DIR);
 	spin_unlock_irqrestore(&chip->gpio_lock, flags);
 
 	return 0;
 }
 
-/*
- * altera_gpio_dir_out - Set the direction of the specified GPIO as output.
- * @gc:     Pointer to gpio_chip device structure.
- * @gpio:   GPIO signal number.
- * @val:    Value to be written to specified signal.
- *
- * This function sets the direction of specified GPIO signal as output. If all
- * GPIO signals of GPIO chip is configured as input then it returns
- * error otherwise it returns 0.
- */
-static int altera_gpio_dir_out(struct gpio_chip *gc, unsigned int gpio, int val)
+static int altera_gpio_direction_output(struct gpio_chip *gc,
+		unsigned offset, int value)
 {
-	unsigned long flags;
 	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
-	struct altera_gpio_instance *chip = to_altera_gpio(mm_gc);
+	struct altera_gpio_chip *chip = container_of(mm_gc,
+				struct altera_gpio_chip, mmchip);
+	unsigned long flags;
+	unsigned int data_reg, gpio_ddr;
 
 	spin_lock_irqsave(&chip->gpio_lock, flags);
-
-	/* Write state of GPIO signal */
-	if (val)
-		chip->gpio_state |= 1 << gpio;
-	else
-		chip->gpio_state &= ~(1 << gpio);
-	__raw_writel(chip->gpio_state, mm_gc->regs + ALTERA_GPIO_DATA_OFFSET);
-
-	/* Set the GPIO bit in shadow register and set direction as output */
-	chip->gpio_dir |= (1 << gpio);
-	__raw_writel(chip->gpio_dir, mm_gc->regs + ALTERA_GPIO_DIR_OFFSET);
-
+	/* Sets the GPIO value */
+	data_reg = readl(mm_gc->regs + ALTERA_GPIO_DATA);
+	data_reg = (data_reg & ~(1 << offset)) | (value << offset);
+	 writel(data_reg, mm_gc->regs + ALTERA_GPIO_DATA);
+
+	/* Set pin as output, assumes software controlled IP */
+	gpio_ddr = readl(mm_gc->regs + ALTERA_GPIO_DIR);
+	gpio_ddr |= (1 << offset);
+	writel(gpio_ddr, mm_gc->regs + ALTERA_GPIO_DIR);
 	spin_unlock_irqrestore(&chip->gpio_lock, flags);
 
 	return 0;
 }
 
-/*
- * altera_gpio_save_regs - Set initial values of GPIO pins
- * @mm_gc: pointer to memory mapped GPIO chip structure
- */
-static void altera_gpio_save_regs(struct of_mm_gpio_chip *mm_gc)
+static int altera_gpio_to_irq(struct gpio_chip *gc, unsigned offset)
 {
-	struct altera_gpio_instance *chip = to_altera_gpio(mm_gc);
+	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
+	struct altera_gpio_chip *altera_gc = container_of(mm_gc,
+				struct altera_gpio_chip, mmchip);
 
-	__raw_writel(chip->gpio_state, mm_gc->regs + ALTERA_GPIO_DATA_OFFSET);
-	__raw_writel(chip->gpio_dir, mm_gc->regs + ALTERA_GPIO_DIR_OFFSET);
+	if (altera_gc->irq == 0)
+		return -ENXIO;
+	if ((altera_gc->irq && offset) < altera_gc->mmchip.gc.ngpio)
+		return irq_create_mapping(altera_gc->irq, offset);
+	else
+		return -ENXIO;
 }
 
+static void altera_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
+{
+	struct altera_gpio_chip *altera_gc = irq_desc_get_handler_data(desc);
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	struct of_mm_gpio_chip *mm_gc = &altera_gc->mmchip;
+	unsigned long status;
+
+	int base;
+	chip->irq_mask(&desc->irq_data);
+
+	if (altera_gc->level_trigger)
+		status = readl(mm_gc->regs + ALTERA_GPIO_DATA);
+	else {
+		status = readl(mm_gc->regs + ALTERA_GPIO_EDGE_CAP);
+		writel(status, mm_gc->regs + ALTERA_GPIO_EDGE_CAP);
+	}
+
+	status &= readl(mm_gc->regs + ALTERA_GPIO_IRQ_MASK);
 
+	for (base = 0; base < mm_gc->gc.ngpio; base++) {
+		if ((1 << base) & status) {
+			generic_handle_irq(
+				irq_linear_revmap(altera_gc->irq, base));
+		}
+	}
+	chip->irq_eoi(irq_desc_get_irq_data(desc));
+	chip->irq_unmask(&desc->irq_data);
+}
 
-/*
- * altera_gpio_of_probe - Probe method for the GPIO device.
- * @np: pointer to device tree node
- *
- * This function probes the GPIO device in the device tree. It initializes the
- * driver data structure. It returns 0, if the driver is bound to the GPIO
- * device, or a negative value if there is an error.
- */
-static int __devinit altera_gpio_probe(struct platform_device *pdev)
+static int altera_gpio_irq_map(struct irq_domain *h, unsigned int virq,
+				irq_hw_number_t hw_irq_num)
 {
-	struct device_node *np = pdev->dev.of_node;
-	struct altera_gpio_instance *chip;
-	int status = 0;
-	u32 reg;
+	irq_set_chip_data(virq, h->host_data);
+	irq_set_chip_and_handler(virq, &altera_irq_chip, handle_level_irq);
+	irq_set_irq_type(virq, IRQ_TYPE_NONE);
+
+	return 0;
+}
+
+static struct irq_domain_ops altera_gpio_irq_ops = {
+	.map	= altera_gpio_irq_map,
+	.xlate = irq_domain_xlate_twocell,
+};
 
-	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
-	if (!chip)
-		return -ENOMEM;
+int __devinit altera_gpio_probe(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	int id, reg, ret;
+	struct altera_gpio_chip *altera_gc = devm_kzalloc(&pdev->dev,
+				sizeof(*altera_gc), GFP_KERNEL);
+	if (altera_gc == NULL) {
+		ret = -ENOMEM;
+		pr_err("%s: registration failed with status %d\n",
+			node->full_name, ret);
+		return ret;
+	}
+	altera_gc->irq = 0;
 
-	/* Update GPIO state shadow register with default value */
-	if (of_property_read_u32(np, "resetvalue", &reg) == 0)
-		chip->gpio_state = reg;
+	spin_lock_init(&altera_gc->gpio_lock);
 
-	/* Update GPIO direction shadow register with default value */
-	chip->gpio_dir = 0; /* By default, all pins are inputs */
+	id = pdev->id;
 
-	/* Check device node for device width. Default to full width. */
-	if (of_property_read_u32(np, "width", &reg) == 0)
-		chip->mmchip.gc.ngpio = reg;
+	if (of_property_read_u32(node, "width", &reg))
+		/*By default assume full GPIO controller*/
+		altera_gc->mmchip.gc.ngpio = 32;
 	else
-		chip->mmchip.gc.ngpio = 32;
+		altera_gc->mmchip.gc.ngpio = reg;
 
-	spin_lock_init(&chip->gpio_lock);
+	if (altera_gc->mmchip.gc.ngpio > 32) {
+		pr_warn("%s: ngpio is greater than 32, defaulting to 32\n",
+			node->full_name);
+		altera_gc->mmchip.gc.ngpio = 32;
+	}
 
-	chip->mmchip.gc.direction_input = altera_gpio_dir_in;
-	chip->mmchip.gc.direction_output = altera_gpio_dir_out;
-	chip->mmchip.gc.get = altera_gpio_get;
-	chip->mmchip.gc.set = altera_gpio_set;
+	altera_gc->mmchip.gc.direction_input	= altera_gpio_direction_input;
+	altera_gc->mmchip.gc.direction_output	= altera_gpio_direction_output;
+	altera_gc->mmchip.gc.get		= altera_gpio_get;
+	altera_gc->mmchip.gc.set		= altera_gpio_set;
+	altera_gc->mmchip.gc.to_irq		= altera_gpio_to_irq;
+	altera_gc->mmchip.gc.owner		= THIS_MODULE;
 
-	chip->mmchip.save_regs = altera_gpio_save_regs;
+	ret = of_mm_gpiochip_add(node, &altera_gc->mmchip);
+	if (ret)
+		goto err;
 
-	/* Call the OF gpio helper to setup and register the GPIO device */
-	status = of_mm_gpiochip_add(np, &chip->mmchip);
-	if (status) {
-		kfree(chip);
-		pr_err("%s: error in probe function with status %d\n",
-		       np->full_name, status);
-		return status;
+	platform_set_drvdata(pdev, altera_gc);
+
+	if (of_get_property(node, "interrupts", &reg) == NULL)
+		goto skip_irq;
+	altera_gc->hwirq = irq_of_parse_and_map(node, 0);
+
+	if (altera_gc->hwirq == NO_IRQ)
+		goto skip_irq;
+
+	altera_gc->irq = irq_domain_add_linear(node, altera_gc->mmchip.gc.ngpio,
+				&altera_gpio_irq_ops, altera_gc);
+
+	if (!altera_gc->irq) {
+		ret = -ENODEV;
+		goto dispose_irq;
+	}
+
+	if (of_property_read_u32(node, "level_trigger", &reg)) {
+		ret = -EINVAL;
+		pr_err("%s: level_trigger value not set in device tree\n",
+			node->full_name);
+		goto teardown;
 	}
+	altera_gc->level_trigger = reg;
+
+	irq_set_handler_data(altera_gc->hwirq, altera_gc);
+	irq_set_chained_handler(altera_gc->hwirq, altera_gpio_irq_handler);
+
+	return 0;
+
+teardown:
+	irq_domain_remove(altera_gc->irq);
+dispose_irq:
+	irq_dispose_mapping(altera_gc->hwirq);
+	WARN_ON(gpiochip_remove(&altera_gc->mmchip.gc) < 0);
 
-	platform_set_drvdata(pdev, chip);
+err:
+	pr_err("%s: registration failed with status %d\n",
+		node->full_name, ret);
+	devm_kfree(&pdev->dev, altera_gc);
 
+	return ret;
+skip_irq:
 	return 0;
 }
 
 static int altera_gpio_remove(struct platform_device *pdev)
 {
+	unsigned int irq, i;
 	int status;
+	struct altera_gpio_chip *altera_gc = platform_get_drvdata(pdev);
+
+	status = gpiochip_remove(&altera_gc->mmchip.gc);
 	
-	struct altera_gpio_instance *chip = platform_get_drvdata(pdev);
-	status = gpiochip_remove(&chip->mmchip.gc);
 	if (status < 0)
 		return status;
+
+	if (altera_gc->irq) {
+		irq_dispose_mapping(altera_gc->hwirq);
 	
-	kfree(chip);
+		for (i = 0; i < altera_gc->mmchip.gc.ngpio; i++) {
+			irq = irq_find_mapping(altera_gc->irq, i);
+			if (irq > 0)
+				irq_dispose_mapping(irq);
+		}
+
+		irq_domain_remove(altera_gc->irq);
+	}
+
+	irq_set_handler_data(altera_gc->hwirq, NULL);
+	irq_set_chained_handler(altera_gc->hwirq, NULL);
+	devm_kfree(&pdev->dev, altera_gc);
 	return -EIO;
 }
 
@@ -274,6 +360,4 @@ static void __exit altera_gpio_exit(void)
 module_exit(altera_gpio_exit);
 
 MODULE_DESCRIPTION("Altera GPIO driver");
-MODULE_AUTHOR("Thomas Chou <thomas@wytron.com.tw>");
 MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:" DRV_NAME);
-- 
1.9.1

