From 8a86d3d6b451e28af9cb11c4388dcb1ca626ec4c Mon Sep 17 00:00:00 2001
From: graham <grmoore@altera.com>
Date: Mon, 22 Jul 2013 15:43:01 -0500
Subject: [PATCH 117/248] FogBugz #139359: Code changes for PL330 DMA driver to
 support socfpga CycloneV

Increased number of amba device irqs to support 8 DMA channels.
Fixed NULL pointer error.
Added check for aborted DMA transactions.
Added code to read copy-align parameter from device tree.

[Original patch taken from
git://git.rocketboards.org/linux-socfpga.git socfpga-3.14]

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
Signed-off-by: graham <grmoore@altera.com>

V2:

Add #ifdef CONFIG_ARCH_SOCFPGA to include/linux/amba/bus.h so that
these changes do not affect other platforms

We tried integrating Lee Booi's code for 8-1 irq mapping, but were unable
to get it working in time for the code freeze.  We will file a FogBugz
immediately which flags this commit as an incorrect implemention.  Then we
will get Lee Booi's code working.

V3:

Added comment at line 1752 in pl330.c to explain need for id == -1 check.
---
 drivers/dma/pl330.c      | 43 +++++++++++++++++++++++++++++++++----------
 include/linux/amba/bus.h |  6 +++++-
 2 files changed, 38 insertions(+), 11 deletions(-)

diff --git a/drivers/dma/pl330.c b/drivers/dma/pl330.c
index 3d8e498..e67ca66 100755
--- a/drivers/dma/pl330.c
+++ b/drivers/dma/pl330.c
@@ -1735,6 +1735,10 @@ static int pl330_update(const struct pl330_info *pi)
 			ret = 1;
 
 			id = pl330->events[ev];
+			/* If error occurs when running dmatest, then id is -1,
+				which causes crash below, so skip to next event */
+			if (id == -1)
+				continue;
 
 			thrd = &pl330->channels[id];
 
@@ -2925,18 +2929,15 @@ pl330_probe(struct amba_device *adev, const struct amba_id *id)
 
 	for (i = 0; i < AMBA_NR_IRQS; i++) {
 		irq = adev->irq[i];
-		if (irq) {
-			ret = devm_request_irq(&adev->dev, irq,
-					       pl330_irq_handler, 0,
-					       dev_name(&adev->dev), pi);
-			if (ret)
-				return ret;
-		} else {
+		if (irq == 0)
 			break;
-		}
+		ret = request_irq(irq, pl330_irq_handler, 0,
+				dev_name(&adev->dev), pi);
+		if (ret)
+			goto probe_err1;
 	}
 
-	if (pdat->init) {
+	if (pdat && pdat->init) {
 		ret = pdat->init(adev);
 		if (ret)
 			goto probe_err3;
@@ -3013,6 +3014,13 @@ pl330_probe(struct amba_device *adev, const struct amba_id *id)
 	pd->device_issue_pending = pl330_issue_pending;
 	pd->device_slave_caps = pl330_dma_device_slave_caps;
 
+	if (adev->dev.of_node) {
+		u32 val;
+		if (!of_property_read_u32(adev->dev.of_node,
+			"copy-align", &val))
+			pd->copy_align = val;
+	}
+
 	ret = dma_async_device_register(pd);
 	if (ret) {
 		dev_err(&adev->dev, "unable to register DMAC\n");
@@ -3062,6 +3070,13 @@ probe_err3:
 	}
 probe_err2:
 	pl330_del(pi);
+probe_err1:
+	for (i = 0; i < AMBA_NR_IRQS; i++) {
+		irq = adev->irq[i];
+		if (irq == 0)
+			break;
+		free_irq(irq, pi);
+	}
 
 	return ret;
 }
@@ -3069,9 +3084,10 @@ probe_err2:
 static int pl330_remove(struct amba_device *adev)
 {
 	struct dma_pl330_dmac *pdmac = amba_get_drvdata(adev);
-	struct dma_pl330_platdata *pdat = adev->dev.platform_data;
 	struct dma_pl330_chan *pch, *_p;
 	struct pl330_info *pi;
+	int irq;
+	int i;
 
 	if (!pdmac)
 		return 0;
@@ -3097,6 +3113,13 @@ static int pl330_remove(struct amba_device *adev)
 
 	pl330_del(pi);
 
+	for (i = 0; i < AMBA_NR_IRQS; i++) {
+		irq = adev->irq[i];
+		if (irq == 0)
+			break;
+		free_irq(irq, pi);
+	}
+
 	return 0;
 }
 
diff --git a/include/linux/amba/bus.h b/include/linux/amba/bus.h
index 63b5eff..f47b8d7 100644
--- a/include/linux/amba/bus.h
+++ b/include/linux/amba/bus.h
@@ -21,7 +21,11 @@
 #include <linux/resource.h>
 #include <linux/regulator/consumer.h>
 
-#define AMBA_NR_IRQS	9
+#ifdef CONFIG_ARCH_SOCFPGA
+#define AMBA_NR_IRQS	8
+#else
+#define AMBA_NR_IRQS	2
+#endif
 #define AMBA_CID	0xb105f00d
 
 struct clk;
-- 
1.9.1

