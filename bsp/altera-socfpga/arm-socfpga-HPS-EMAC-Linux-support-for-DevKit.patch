From fece00e8a040efd9d3d42c471b9e54ee7fb620ac Mon Sep 17 00:00:00 2001
From: Matthew Gerlach <mgerlach@altera.com>
Date: Fri, 25 Jan 2013 10:30:21 -0800
Subject: [PATCH 181/254] arm: socfpga: HPS EMAC Linux support for DevKit

Upstream: git://git.rocketboards.org/linux-socfpga.git

Setup phy type in System Manager. Set clock skew for micrel phy.

Signed-off-by: Matthew Gerlach <mgerlach@altera.com>
(cherry picked from commit 29dff07511e921316719dc960f143eda64827315)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/boot/dts/socfpga.dtsi                     |   11 ++-
 arch/arm/boot/dts/socfpga_cyclone5.dts             |   18 ++-
 arch/arm/boot/dts/socfpga_vt.dts                   |   13 +-
 arch/arm/mach-socfpga/core.h                       |    8 ++
 arch/arm/mach-socfpga/socfpga.c                    |  133 ++++++++++++++++++++
 drivers/clk/socfpga/clk.c                          |   59 ++++++---
 drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c  |    8 +-
 .../net/ethernet/stmicro/stmmac/stmmac_platform.c  |   24 +++-
 include/linux/micrel_phy.h                         |    1 +
 include/linux/stmmac.h                             |    3 +
 10 files changed, 238 insertions(+), 40 deletions(-)

diff --git a/arch/arm/boot/dts/socfpga.dtsi b/arch/arm/boot/dts/socfpga.dtsi
index f074aaa..9bb6d7a 100644
--- a/arch/arm/boot/dts/socfpga.dtsi
+++ b/arch/arm/boot/dts/socfpga.dtsi
@@ -23,6 +23,7 @@
 
 	aliases {
 		ethernet0 = &gmac0;
+		ethernet1 = &gmac1;
 		serial0 = &uart0;
 		serial1 = &uart1;
 		timer0 = &timer0;
@@ -96,13 +97,21 @@
 				reg = <0xffd04000 0x1000>;
 			};
 
+
 		gmac0: stmmac@ff700000 {
 			compatible = "altr,socfpga-stmmac", "snps,dwmac-3.70a", "snps,dwmac";
 			reg = <0xff700000 0x2000>;
 			interrupts = <0 115 4>;
 			interrupt-names = "macirq";
 			mac-address = [00 00 00 00 00 00];/* Filled in by U-Boot */
-			phy-mode = "gmii";
+		};
+
+		gmac1: stmmac@ff702000 {
+			compatible = "altr,socfpga-stmmac", "snps,dwmac-3.70a", "snps,dwmac";
+			reg = <0xff702000 0x2000>;
+			interrupts = <0 120 4>;
+			interrupt-names = "macirq";
+			mac-address = [00 00 00 00 00 00];/* Filled in by U-Boot */
 		};
 
 		gpio0: gpio@ff708000 {
diff --git a/arch/arm/boot/dts/socfpga_cyclone5.dts b/arch/arm/boot/dts/socfpga_cyclone5.dts
index 578dfbf..9a84a58 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5.dts
@@ -26,13 +26,23 @@
 		bootargs = "console=ttyS0,57600";
 	};
 
-	memory {
-		name = "memory";
-		device_type = "memory";
-		reg = <0xC0000000 0x20000000>; /* 512MB */
+	aliases {
+		/* this allow the ethaddr uboot environmnet variable contents
+		 * to be added to the gmac1 device tree blob.
+		 */
+		ethernet0 = &gmac1;
 	};
 
 	soc {
+		stmmac@ff700000 {
+			status = "disabled";
+		};
+
+		stmmac@ff702000 {
+			phy-mode = "rgmii";
+			phy-addr = <0xffffffff>; /* probe for phy addr */
+		};
+
 		qspi: spi@ff705000 {
 				compatible = "cadence,qspi";
 				#address-cells = <1>;
diff --git a/arch/arm/boot/dts/socfpga_vt.dts b/arch/arm/boot/dts/socfpga_vt.dts
index 80cf65b..927c5b4 100644
--- a/arch/arm/boot/dts/socfpga_vt.dts
+++ b/arch/arm/boot/dts/socfpga_vt.dts
@@ -26,13 +26,14 @@
 		bootargs = "console=ttyS0,57600";
 	};
 
-	memory {
-		name = "memory";
-		device_type = "memory";
-		reg = <0x0 0x40000000>; /* 1 GB */
-	};
-
 	soc {
+		stmmac@ff700000 {
+			phy-mode = "gmii";
+		};
+		stmmac@ff702000 {
+			phy-mode = "gmii";
+		};
+
 		qspi: spi@ff705000 {
 				compatible = "cadence,qspi";
 				#address-cells = <1>;
diff --git a/arch/arm/mach-socfpga/core.h b/arch/arm/mach-socfpga/core.h
index 485a23d..80b5fe3 100644
--- a/arch/arm/mach-socfpga/core.h
+++ b/arch/arm/mach-socfpga/core.h
@@ -28,6 +28,14 @@
 #define RSTMGR_CTRL_SWCOLDRSTREQ	0x1	/* Cold Reset */
 #define RSTMGR_CTRL_SWWARMRSTREQ	0x2	/* Warm Reset */
 
+#define SYSMGR_EMACGRP_CTRL_OFFSET 0x60
+#define SYSMGR_EMACGRP_CTRL_PHYSEL_ENUM_GMII_MII 0x0
+#define SYSMGR_EMACGRP_CTRL_PHYSEL_ENUM_RGMII 0x1
+#define SYSMGR_EMACGRP_CTRL_PHYSEL_ENUM_RMII 0x2
+#define SYSMGR_EMACGRP_CTRL_PHYSEL_WIDTH 2
+
+#define SYSMGR_EMACGRP_CTRL_PHYSEL_MASK 0x00000003
+
 extern void secondary_startup(void);
 extern void __iomem *socfpga_scu_base_addr;
 extern void __iomem *sys_manager_base_addr;
diff --git a/arch/arm/mach-socfpga/socfpga.c b/arch/arm/mach-socfpga/socfpga.c
index 47e0589..556e5e1 100644
--- a/arch/arm/mach-socfpga/socfpga.c
+++ b/arch/arm/mach-socfpga/socfpga.c
@@ -19,6 +19,10 @@
 #include <linux/of_irq.h>
 #include <linux/of_address.h>
 #include <linux/of_platform.h>
+#include <linux/of_net.h>
+#include <linux/stmmac.h>
+#include <linux/phy.h>
+#include <linux/micrel_phy.h>
 
 #include <asm/hardware/cache-l2x0.h>
 #include <asm/hardware/gic.h>
@@ -35,7 +39,26 @@ void __iomem *sys_manager_base_addr;
 void __iomem *rst_manager_base_addr;
 unsigned long	cpu1start_addr;
 
+static int socfpga_phy_reset_mii(struct mii_bus *bus, int phyaddr);
+static int stmmac_plat_init(struct platform_device *pdev);
+
+static struct stmmac_mdio_bus_data stmmacenet_mdio_bus_data = {
+	.phy_reset_mii = socfpga_phy_reset_mii,
+};
+
+static struct plat_stmmacenet_data stmmacenet0_data = {
+	.mdio_bus_data = &stmmacenet_mdio_bus_data,
+	.init = &stmmac_plat_init,
+};
+
+static struct plat_stmmacenet_data stmmacenet1_data = {
+	.mdio_bus_data = &stmmacenet_mdio_bus_data,
+	.init = &stmmac_plat_init,
+};
+
 static const struct of_dev_auxdata socfpga_auxdata_lookup[] __initconst = {
+	OF_DEV_AUXDATA("snps,dwmac-3.70a", 0xff700000, NULL, &stmmacenet0_data),
+	OF_DEV_AUXDATA("snps,dwmac-3.70a", 0xff702000, NULL, &stmmacenet1_data),
 	{ /* sentinel */ }
 };
 
@@ -88,6 +111,116 @@ static void __init enable_periphs(void)
 	__raw_writel(0, rst_manager_base_addr + SOCFPGA_RSTMGR_BRGMODRST);
 }
 
+static int stmmac_mdio_write_null(struct mii_bus *bus, int phyaddr, int phyreg,
+			     u16 phydata)
+{
+	return 0;
+}
+
+#define MICREL_KSZ9021_EXTREG_CTRL 11
+#define MICREL_KSZ9021_EXTREG_DATA_WRITE 12
+#define MICREL_KSZ9021_RGMII_CLK_CTRL_PAD_SCEW 260
+#define MICREL_KSZ9021_RGMII_RX_DATA_PAD_SCEW 261
+
+static int stmmac_emdio_write(struct mii_bus *bus, int phyaddr, int phyreg,
+			     u16 phydata)
+{
+	int ret = (bus->write)(bus, phyaddr,
+		MICREL_KSZ9021_EXTREG_CTRL, 0x8000|phyreg);
+	if (ret) {
+		pr_warn("stmmac_emdio_write write1 failed %d\n", ret);
+		return ret;
+	}
+
+	ret = (bus->write)(bus, phyaddr,
+		MICREL_KSZ9021_EXTREG_DATA_WRITE, phydata);
+	if (ret) {
+		pr_warn("stmmac_emdio_write write2 failed %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int socfpga_phy_reset_mii(struct mii_bus *bus, int phyaddr)
+{
+	struct phy_device *phydev;
+
+	if (of_machine_is_compatible("altr,socfpga-vt"))
+		return 0;
+
+	phydev = bus->phy_map[phyaddr];
+
+	if (NULL == phydev) {
+		pr_err("%s no phydev found\n", __func__);
+		return -EINVAL;
+	}
+
+	if (PHY_ID_KSZ9021RLRN != phydev->phy_id) {
+		pr_err("%s unexpected PHY ID %08x\n", __func__, phydev->phy_id);
+		return -EINVAL;
+	}
+
+	pr_info("%s writing extended registers to phyaddr %d\n",
+		__func__, phyaddr);
+
+	/* add 2 ns of RXC PAD Skew and 2.6 ns of TXC PAD Skew */
+	stmmac_emdio_write(bus, phyaddr,
+		MICREL_KSZ9021_RGMII_CLK_CTRL_PAD_SCEW, 0xa0d0);
+
+	/* set no PAD skew for data */
+	stmmac_emdio_write(bus, phyaddr,
+		MICREL_KSZ9021_RGMII_RX_DATA_PAD_SCEW, 0x0000);
+
+	bus->write = &stmmac_mdio_write_null;
+	return 0;
+}
+
+static int stmmac_plat_init(struct platform_device *pdev)
+{
+	u32 ctrl, val, shift;
+	int phymode;
+
+	if (of_machine_is_compatible("altr,socfpga-vt"))
+		return 0;
+
+	phymode = of_get_phy_mode(pdev->dev.of_node);
+
+	switch (phymode) {
+	case PHY_INTERFACE_MODE_RGMII:
+		val = SYSMGR_EMACGRP_CTRL_PHYSEL_ENUM_RGMII;
+		break;
+	case PHY_INTERFACE_MODE_MII:
+	case PHY_INTERFACE_MODE_GMII:
+		val = SYSMGR_EMACGRP_CTRL_PHYSEL_ENUM_GMII_MII;
+		break;
+	default:
+		pr_err("%s bad phy mode %d", __func__, phymode);
+		return -EINVAL;
+	}
+
+	if (&stmmacenet1_data == pdev->dev.platform_data)
+		shift = SYSMGR_EMACGRP_CTRL_PHYSEL_WIDTH;
+	else if (&stmmacenet0_data == pdev->dev.platform_data)
+		shift = 0;
+	else {
+		pr_err("%s unexpected platform data pointer\n", __func__);
+		return -EINVAL;
+	}
+
+	ctrl =  __raw_readl(sys_manager_base_addr +
+		SYSMGR_EMACGRP_CTRL_OFFSET);
+
+	ctrl &= ~(SYSMGR_EMACGRP_CTRL_PHYSEL_MASK << shift);
+
+	ctrl |= (val << shift);
+
+	__raw_writel(ctrl, (sys_manager_base_addr +
+		SYSMGR_EMACGRP_CTRL_OFFSET));
+
+	return 0;
+}
+
 static void __init socfpga_sysmgr_init(void)
 {
 	struct device_node *np;
diff --git a/drivers/clk/socfpga/clk.c b/drivers/clk/socfpga/clk.c
index b1c2c5e..f7f8b1a 100644
--- a/drivers/clk/socfpga/clk.c
+++ b/drivers/clk/socfpga/clk.c
@@ -61,65 +61,84 @@ void __init socfpga_init_clocks(void)
 	clk = clk_register_fixed_rate(NULL, "main_pll_clk", NULL, CLK_IS_ROOT,
 			SOCFPGA_MAIN_PLL_CLK);
 	clk_register_clkdev(clk, "main_pll_clk", NULL);
-	
+
 	clk = clk_register_fixed_rate(NULL, "per_pll_clk", NULL, CLK_IS_ROOT,
 			SOCFPGA_PER_PLL_CLK);
 	clk_register_clkdev(clk, "per_pll_clk", NULL);
-	
+
 	clk = clk_register_fixed_rate(NULL, "sdram_pll_clk", NULL, CLK_IS_ROOT,
 			SOCFPGA_SDRAM_PLL_CLK);
 	clk_register_clkdev(clk, "sdram_pll_clk", NULL);
-	
-	clk = clk_register_fixed_rate(NULL, "osc1_clk", NULL, CLK_IS_ROOT, SOCFPGA_OSC1_CLK);
+
+	clk = clk_register_fixed_rate(NULL, "osc1_clk", NULL, CLK_IS_ROOT,
+			SOCFPGA_OSC1_CLK);
 	clk_register_clkdev(clk, "osc1_clk", NULL);
 
-	clk = clk_register_fixed_rate(NULL, "mpu_clk", NULL, CLK_IS_ROOT, SOCFPGA_MPU_CLK);
+	clk = clk_register_fixed_rate(NULL, "mpu_clk", NULL, CLK_IS_ROOT,
+			SOCFPGA_MPU_CLK);
 	clk_register_clkdev(clk, "mpu_clk", NULL);
 
-	clk = clk_register_fixed_rate(NULL, "main_clk", NULL, CLK_IS_ROOT, SOCFPGA_MPU_CLK/2);
+	clk = clk_register_fixed_rate(NULL, "main_clk", NULL, CLK_IS_ROOT,
+			SOCFPGA_MPU_CLK/2);
 	clk_register_clkdev(clk, "main_clk", NULL);
 
-	clk = clk_register_fixed_rate(NULL, "dbg_base_clk", NULL, CLK_IS_ROOT, SOCFPGA_MPU_CLK/2);
+	clk = clk_register_fixed_rate(NULL, "dbg_base_clk", NULL, CLK_IS_ROOT,
+			SOCFPGA_MPU_CLK/2);
 	clk_register_clkdev(clk, "dbg_base_clk", NULL);
 
-	clk = clk_register_fixed_rate(NULL, "smp_twd", NULL, CLK_IS_ROOT, SOCFPGA_MPU_CLK/4);
+	clk = clk_register_fixed_rate(NULL, "smp_twd", NULL, CLK_IS_ROOT,
+			SOCFPGA_MPU_CLK/4);
 	clk_register_clkdev(clk, NULL, "smp_twd");
 
-	clk = clk_register_fixed_rate(NULL, "main_qspi_clk", NULL, CLK_IS_ROOT, SOCFPGA_MAIN_QSPI_CLK);
+	clk = clk_register_fixed_rate(NULL, "main_qspi_clk", NULL, CLK_IS_ROOT,
+			SOCFPGA_MAIN_QSPI_CLK);
 	clk_register_clkdev(clk, "main_qspi_clk", NULL);
 
-	clk = clk_register_fixed_rate(NULL, "main_nand_sdmmc_clk", NULL, CLK_IS_ROOT, SOCFPGA_MAIN_NAND_SDMMC_CLK);
+	clk = clk_register_fixed_rate(NULL, "main_nand_sdmmc_clk", NULL,
+			CLK_IS_ROOT, SOCFPGA_MAIN_NAND_SDMMC_CLK);
 	clk_register_clkdev(clk, "main_nand_sdmmc_clk", NULL);
 
-	clk = clk_register_fixed_rate(NULL, "s2f_usr_clk", NULL, CLK_IS_ROOT, SOCFPGA_S2F_USR_CLK);
+	clk = clk_register_fixed_rate(NULL, "s2f_usr_clk", NULL, CLK_IS_ROOT,
+			SOCFPGA_S2F_USR_CLK);
 	clk_register_clkdev(clk, "s2f_usr_clk", NULL);
-	
-	clk = clk_register_gate(NULL, "gmac_clk", "per_pll_clk", 0, clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
+
+	clk = clk_register_gate(NULL, "gmac0_clk", "per_pll_clk", 0,
+			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
 			CLKMGR_EMAC0_CLK_EN, 0, &_lock);
 	clk_register_clkdev(clk, NULL, "ff700000.stmmac");
 
-	clk = clk_register_gate(NULL, "spi0_clk", "per_pll_clk", 0, clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
+	clk = clk_register_gate(NULL, "gmac1_clk", "per_pll_clk", 0,
+			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
+			CLKMGR_EMAC1_CLK_EN, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "ff702000.stmmac");
+
+	clk = clk_register_gate(NULL, "spi0_clk", "per_pll_clk", 0,
+			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
 			CLKMGR_SPI_M_CLK_EN, 0, &_lock);
 	clk_register_clkdev(clk, NULL, "fff00000.spi");
 
-	clk = clk_register_gate(NULL, "spi1_clk", "per_pll_clk", 0, clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
+	clk = clk_register_gate(NULL, "spi1_clk", "per_pll_clk", 0,
+			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
 			CLKMGR_SPI_M_CLK_EN, 0, &_lock);
 	clk_register_clkdev(clk, NULL, "fff01000.spi");
 
-	clk = clk_register_gate(NULL, "gpio0_clk", "per_pll_clk", 0, clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
+	clk = clk_register_gate(NULL, "gpio0_clk", "per_pll_clk", 0,
+			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
 			CLKMGR_GPIO_CLK_EN, 0, &_lock);
 	clk_register_clkdev(clk, NULL, "ff708000.gpio");
 
-	clk = clk_register_gate(NULL, "gpio1_clk", "per_pll_clk", 0, clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
+	clk = clk_register_gate(NULL, "gpio1_clk", "per_pll_clk", 0,
+			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
 			CLKMGR_GPIO_CLK_EN, 0, &_lock);
 	clk_register_clkdev(clk, NULL, "ff709000.gpio");
 
-	clk = clk_register_gate(NULL, "gpio2_clk", "per_pll_clk", 0, clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
+	clk = clk_register_gate(NULL, "gpio2_clk", "per_pll_clk", 0,
+			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
 			CLKMGR_GPIO_CLK_EN, 0, &_lock);
 	clk_register_clkdev(clk, NULL, "ff70a000.gpio");
 
 	clk = clk_register_gate(NULL, "nand_clk", "main_nand_sdmmc_clk", 0,
-			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN, CLKMGR_NAND_CLK_EN, 0,
-			 &_lock);
+			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
+			CLKMGR_NAND_CLK_EN, 0, &_lock);
 	clk_register_clkdev(clk, NULL, "ff900000.nand");
 }
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c
index 1f190d3..897f036 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c
@@ -219,13 +219,11 @@ int stmmac_mdio_register(struct net_device *ndev)
 
 	if (!found) {
 		pr_warning("%s: No PHY found\n", ndev->name);
-		mdiobus_unregister(new_bus);
-		mdiobus_free(new_bus);
-		return -ENODEV;
+	} else if (priv->plat->mdio_bus_data->phy_reset_mii) {
+		priv->plat->mdio_bus_data->phy_reset_mii(new_bus,
+			priv->plat->phy_addr);
 	}
 
-	priv->mii = new_bus;
-
 	return 0;
 
 bus_register_fail:
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
index ed112b5..2f55bc7 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
@@ -34,15 +34,18 @@ static int __devinit stmmac_probe_config_dt(struct platform_device *pdev,
 					    const char **mac)
 {
 	struct device_node *np = pdev->dev.of_node;
+	u32 phyaddr;
 
 	if (!np)
 		return -ENODEV;
 
 	*mac = of_get_mac_address(np);
 	plat->interface = of_get_phy_mode(np);
-	plat->mdio_bus_data = devm_kzalloc(&pdev->dev,
+	if (NULL == plat->mdio_bus_data) {
+		plat->mdio_bus_data = devm_kzalloc(&pdev->dev,
 					   sizeof(struct stmmac_mdio_bus_data),
 					   GFP_KERNEL);
+	}
 
 	/*
 	 * Currently only the properties needed on SPEAr600
@@ -56,6 +59,17 @@ static int __devinit stmmac_probe_config_dt(struct platform_device *pdev,
 		plat->pmt = 1;
 	}
 
+	if (0 == of_property_read_u32(np, "phy-addr", &phyaddr)) {
+		if ((-1 == phyaddr) ||
+			((phyaddr >= 0) && (phyaddr < PHY_MAX_ADDR))) {
+			plat->phy_addr = phyaddr;
+		} else {
+			pr_err("%s: ERROR: bad phy address: %d\n",
+				__func__, phyaddr);
+			return -EINVAL;
+		}
+	}
+
 	return 0;
 }
 #else
@@ -94,10 +108,14 @@ static int __devinit stmmac_pltfr_probe(struct platform_device *pdev)
 		return -ENOMEM;
 	}
 
+	plat_dat = pdev->dev.platform_data;
+
 	if (pdev->dev.of_node) {
-		plat_dat = devm_kzalloc(&pdev->dev,
+		if (NULL == plat_dat) {
+			plat_dat = devm_kzalloc(&pdev->dev,
 					sizeof(struct plat_stmmacenet_data),
 					GFP_KERNEL);
+		}
 		if (!plat_dat) {
 			pr_err("%s: ERROR: no memory", __func__);
 			return  -ENOMEM;
@@ -108,8 +126,6 @@ static int __devinit stmmac_pltfr_probe(struct platform_device *pdev)
 			pr_err("%s: main dt probe failed", __func__);
 			return ret;
 		}
-	} else {
-		plat_dat = pdev->dev.platform_data;
 	}
 
 	/* Custom initialisation (if needed)*/
diff --git a/include/linux/micrel_phy.h b/include/linux/micrel_phy.h
index 61f0905..381b0bc 100644
--- a/include/linux/micrel_phy.h
+++ b/include/linux/micrel_phy.h
@@ -4,6 +4,7 @@
 #define MICREL_PHY_ID_MASK	0x00fffff0
 
 #define PHY_ID_KSZ9021		0x00221610
+#define PHY_ID_KSZ9021RLRN	0x00221611
 #define PHY_ID_KS8737		0x00221720
 #define PHY_ID_KS8041		0x00221510
 #define PHY_ID_KS8051		0x00221550
diff --git a/include/linux/stmmac.h b/include/linux/stmmac.h
index de5b2f8..bef19b3 100644
--- a/include/linux/stmmac.h
+++ b/include/linux/stmmac.h
@@ -27,6 +27,8 @@
 #define __STMMAC_PLATFORM_DATA
 
 #include <linux/platform_device.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
 
 #define STMMAC_RX_COE_NONE	0
 #define STMMAC_RX_COE_TYPE1	1
@@ -77,6 +79,7 @@
 
 struct stmmac_mdio_bus_data {
 	int (*phy_reset)(void *priv);
+	int (*phy_reset_mii)(struct mii_bus *bus, int phyaddr);
 	unsigned int phy_mask;
 	int *irqs;
 	int probed_phy_irq;
-- 
1.7.5.4

