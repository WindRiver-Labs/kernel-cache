From 8a4933bf0a3c3a65a6f05213304002de4fef175f Mon Sep 17 00:00:00 2001
From: Lisa Treweek <ltreweek@altera.com>
Date: Mon, 4 Feb 2013 15:20:10 -0600
Subject: [PATCH 194/254] net: stammac masked out gmac mmc interrupts.

Upstream: git://git.rocketboards.org/linux-socfpga.git

The gmac mmc interrupts are not handled.  This causes an infinite loop
on transfers larger then 2G.  These interrupts were from the gmac
checksum offset counter and other rx/tx counters.

So, we masked these interrupts so they will not trigger.

Signed-off-by: Lisa Treweek <ltreweek@altera.com>
(cherry picked from commit c97484c2af63de3bec8cebbc28d7d603d4acddb8)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/stmicro/stmmac/dwmac1000.h    |    3 +++
 .../net/ethernet/stmicro/stmmac/dwmac1000_core.c   |   11 +++++++++++
 2 files changed, 14 insertions(+), 0 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h b/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h
index 7ad56af..03846dc 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h
@@ -228,6 +228,9 @@ enum rtc_control {
 #define GMAC_MMC_CTRL      0x100
 #define GMAC_MMC_RX_INTR   0x104
 #define GMAC_MMC_TX_INTR   0x108
+#define GMAC_MMC_INTR_MASK_RX		  0x10C
+#define GMAC_MMC_INTR_MASK_TX		  0x110
+#define GMAC_MMC_IPC_INTR_MASK_RX  0x200
 #define GMAC_MMC_RX_CSUM_OFFLOAD   0x208
 
 extern const struct stmmac_dma_ops dwmac1000_dma_ops;
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
index bfe0226..ade7bfb 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
@@ -40,6 +40,11 @@ static void dwmac1000_core_init(void __iomem *ioaddr)
 	/* Mask GMAC interrupts */
 	writel(0x207, ioaddr + GMAC_INT_MASK);
 
+	/* mask out interrupts because we don't handle them yet */
+	writel(~0UL, ioaddr + GMAC_MMC_INTR_MASK_RX);
+	writel(~0UL, ioaddr + GMAC_MMC_INTR_MASK_TX);
+	writel(~0UL, ioaddr + GMAC_MMC_IPC_INTR_MASK_RX);
+
 #ifdef STMMAC_VLAN_TAG_USED
 	/* Tag detection without filtering */
 	writel(0x0, ioaddr + GMAC_VLAN_TAG);
@@ -198,6 +203,7 @@ static int dwmac1000_irq_status(void __iomem *ioaddr)
 {
 	u32 intr_status = readl(ioaddr + GMAC_INT_STATUS);
 	int status = 0;
+	u32 value;
 
 	/* Not used events (e.g. MMC interrupts) are not handled. */
 	if ((intr_status & mmc_tx_irq)) {
@@ -222,6 +228,11 @@ static int dwmac1000_irq_status(void __iomem *ioaddr)
 		readl(ioaddr + GMAC_PMT);
 		status |= core_irq_receive_pmt_irq;
 	}
+	if (unlikely(intr_status & rgmii_irq)) {
+		CHIP_DBG(KERN_INFO "GMAC: Interrupt Status\n");
+		/* clear this link change interrupt because we are not handling it yet. */
+		value = readl(ioaddr + GMAC_GMII_STATUS);
+	}
 	/* MAC trx/rx EEE LPI entry/exit interrupts */
 	if (intr_status & lpiis_irq) {
 		/* Clean LPI interrupt by reading the Reg 12 */
-- 
1.7.5.4

