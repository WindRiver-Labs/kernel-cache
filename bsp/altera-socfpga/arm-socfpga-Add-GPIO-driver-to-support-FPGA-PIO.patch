From ebb211f435fbc1444baacacde5819cf8d61b1419 Mon Sep 17 00:00:00 2001
From: Dinh Nguyen <dinguyen@altera.com>
Date: Fri, 21 Dec 2012 14:07:14 -0600
Subject: [PATCH 174/254] arm: socfpga: Add GPIO driver to support FPGA PIO

Upstream: git://git.rocketboards.org/linux-socfpga.git

Clean up gpio-dw and gpio-altera drivers.
Release the FPGA bridges out of reset.

Signed-off-by: Dinh Nguyen <dinguyen@altera.com>

Conflicts:
	drivers/gpio/Makefile
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/boot/dts/socfpga.dtsi     |   22 ++-
 arch/arm/configs/socfpga_defconfig |    3 +-
 arch/arm/mach-socfpga/core.h       |    1 +
 arch/arm/mach-socfpga/socfpga.c    |    3 +
 drivers/gpio/Kconfig               |    8 +-
 drivers/gpio/Makefile              |    1 +
 drivers/gpio/gpio-altera.c         |  279 +++++++++++++++++++++
 drivers/gpio/gpio-dw.c             |  468 ++++++++++--------------------------
 8 files changed, 433 insertions(+), 352 deletions(-)
 create mode 100644 drivers/gpio/gpio-altera.c

diff --git a/arch/arm/boot/dts/socfpga.dtsi b/arch/arm/boot/dts/socfpga.dtsi
index 2f8907e..3cd2916 100644
--- a/arch/arm/boot/dts/socfpga.dtsi
+++ b/arch/arm/boot/dts/socfpga.dtsi
@@ -61,6 +61,19 @@
 		interrupt-parent = <&intc>;
 		ranges;
 
+		agpio0: gpio@0xc0000000 {
+			compatible = "altr,pio-1.0";
+			/* Register base 0xff200000 is for a light-weight bridge */
+			reg = <0xff200000 0x10>;
+			/* There are 64 interrupts from the FPGA start at 72, so 45 has to be wrong */
+			interrupts = <0 45 4>;
+			interrupt-controller;
+			#interrupt-cells = <2>;
+			gpio-controller;
+			#gpio-cells = <2>;
+		};
+
+
 		amba {
 			compatible = "arm,amba-bus";
 			#address-cells = <1>;
@@ -92,8 +105,7 @@
 			compatible = "snps,dw-gpio";
 			reg = <0xff708000 0x1000>;
 			interrupts = <0 164 4>;
-			porta_width = <29>;
-			bank_width = <29>;
+			width = <29>;
 			virtual_irq_start = <257>;
 			interrupt-controller;
 			#interrupt-cells = <2>;
@@ -105,8 +117,7 @@
 			compatible = "snps,dw-gpio";
 			reg = <0xff709000 0x1000>;
 			interrupts = <0 165 4>;
-			porta_width = <29>;
-			bank_width = <29>;
+			width = <29>;
 			virtual_irq_start = <286>;
 			interrupt-controller;
 			#interrupt-cells = <2>;
@@ -118,8 +129,7 @@
 			compatible = "snps,dw-gpio";
 			reg = <0xff70a000 0x1000>;
 			interrupts = <0 166 4>;
-			porta_width = <27>;
-			bank_width = <27>;
+			width = <27>;
 			virtual_irq_start = <315>;
 			interrupt-controller;
 			#interrupt-cells = <2>;
diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index bd512f6..c543cf3 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -84,7 +84,8 @@ CONFIG_SPI_DW_MMIO=y
 CONFIG_SPI_SPIDEV=y
 CONFIG_GPIOLIB=y
 CONFIG_GPIO_SYSFS=y
-CONFIG_GPIO_DW=y
+CONFIG_GPIO_DW=m
+CONFIG_GPIO_ALTERA=m
 # CONFIG_RTC_HCTOSYS is not set
 CONFIG_EXT2_FS=y
 CONFIG_EXT2_FS_XATTR=y
diff --git a/arch/arm/mach-socfpga/core.h b/arch/arm/mach-socfpga/core.h
index 8fd51d7..31507ba 100644
--- a/arch/arm/mach-socfpga/core.h
+++ b/arch/arm/mach-socfpga/core.h
@@ -21,6 +21,7 @@
 #define __MACH_CORE_H
 
 #define SOCFPGA_MODPERRST	0x14
+#define SOCFPGA_BRGMODRST	0x1c
 
 extern void secondary_startup(void);
 extern void __iomem *socfpga_scu_base_addr;
diff --git a/arch/arm/mach-socfpga/socfpga.c b/arch/arm/mach-socfpga/socfpga.c
index 3fa1ca7..678148c 100644
--- a/arch/arm/mach-socfpga/socfpga.c
+++ b/arch/arm/mach-socfpga/socfpga.c
@@ -83,6 +83,9 @@ static void __init enable_periphs(void)
 {
 	/* Release all peripherals from reset.*/
 	__raw_writel(0, rst_manager_base_addr + SOCFPGA_MODPERRST);
+
+	/* Release all FPGA bridges from reset.*/
+	__raw_writel(0, rst_manager_base_addr + SOCFPGA_BRGMODRST);
 }
 
 static void __init socfpga_sysmgr_init(void)
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index fc70e4c..b528fa9 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -85,8 +85,14 @@ config GPIO_GENERIC_PLATFORM
 	help
 	  Say yes here to support basic platform_device memory-mapped GPIO controllers.
 
+config GPIO_ALTERA
+       tristate "Altera GPIO"
+       depends on OF_GPIO
+       help
+         Say yes here to support the Altera PIO device.
+
 config GPIO_DW
-	bool "Synopsys DesignWare GPIO driver"
+	tristate "Synopsys DesignWare GPIO driver"
 	select GPIO_GENERIC
 	select GENERIC_IRQ_CHIP
 	depends on OF_GPIO
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index a4d1358..87a601f 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -12,6 +12,7 @@ obj-$(CONFIG_GPIO_74X164)	+= gpio-74x164.o
 obj-$(CONFIG_GPIO_AB8500)	+= gpio-ab8500.o
 obj-$(CONFIG_GPIO_ADP5520)	+= gpio-adp5520.o
 obj-$(CONFIG_GPIO_ADP5588)	+= gpio-adp5588.o
+obj-$(CONFIG_GPIO_ALTERA)  	+= gpio-altera.o
 obj-$(CONFIG_GPIO_BT8XX)	+= gpio-bt8xx.o
 obj-$(CONFIG_GPIO_CS5535)	+= gpio-cs5535.o
 obj-$(CONFIG_GPIO_DA9052)	+= gpio-da9052.o
diff --git a/drivers/gpio/gpio-altera.c b/drivers/gpio/gpio-altera.c
new file mode 100644
index 0000000..42842d9
--- /dev/null
+++ b/drivers/gpio/gpio-altera.c
@@ -0,0 +1,279 @@
+/*
+ * Altera GPIO driver
+ *
+ * Copyright (C) 2012 Tobias Klauser <tklauser@distanz.ch>
+ * Copyright (C) 2011 Thomas Chou <thomas@wytron.com.tw>
+ *
+ * Based on Xilinx gpio driver, which is
+ * Copyright 2008 Xilinx, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+
+#define DRV_NAME "altera_gpio"
+
+/* Register Offset Definitions */
+#define ALTERA_GPIO_DATA_OFFSET		0x0	/* Data register  */
+#define ALTERA_GPIO_DIR_OFFSET		0x4	/* I/O direction register  */
+#define ALTERA_GPIO_IRQ_MASK		0x8
+#define ALTERA_GPIO_EDGE_CAP		0xc
+
+struct altera_gpio_instance {
+	struct of_mm_gpio_chip mmchip;
+	u32 gpio_state;		/* GPIO state shadow register */
+	u32 gpio_dir;		/* GPIO direction shadow register */
+	int irq;		/* GPIO controller IRQ number */
+	int irq_base;		/* base number for the "virtual" GPIO IRQs */
+	u32 irq_mask;		/* IRQ mask */
+	spinlock_t gpio_lock;	/* Lock used for synchronization */
+};
+
+static inline struct altera_gpio_instance *to_altera_gpio(
+	struct of_mm_gpio_chip *mm_gc)
+{
+	return container_of(mm_gc, struct altera_gpio_instance, mmchip);
+}
+
+/*
+ * altera_gpio_get - Read the specified signal of the GPIO device.
+ * @gc:     Pointer to gpio_chip device structure.
+ * @gpio:   GPIO signal number.
+ *
+ * This function reads the specified signal of the GPIO device. It returns 0 if
+ * the signal clear, 1 if signal is set or negative value on error.
+ */
+static int altera_gpio_get(struct gpio_chip *gc, unsigned int gpio)
+{
+	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
+	struct altera_gpio_instance *chip = to_altera_gpio(mm_gc);
+	void __iomem *edge_cap = mm_gc->regs + ALTERA_GPIO_EDGE_CAP;
+	unsigned long value;
+
+	if (chip->irq >= 0) {
+		if (__raw_readl(edge_cap) & (1 << gpio))
+			__raw_writel(1 << gpio, edge_cap);
+	}
+
+	value = __raw_readl(mm_gc->regs + ALTERA_GPIO_DATA_OFFSET);
+	return (value >> gpio) & 1;
+}
+
+/*
+ * altera_gpio_set - Write the specified signal of the GPIO device.
+ * @gc:     Pointer to gpio_chip device structure.
+ * @gpio:   GPIO signal number.
+ * @val:    Value to be written to specified signal.
+ *
+ * This function writes the specified value in to the specified signal of the
+ * GPIO device.
+ */
+static void altera_gpio_set(struct gpio_chip *gc, unsigned int gpio, int val)
+{
+	unsigned long flags;
+	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
+	struct altera_gpio_instance *chip = to_altera_gpio(mm_gc);
+
+	spin_lock_irqsave(&chip->gpio_lock, flags);
+
+	/* Write to shadow register and output */
+	if (val)
+		chip->gpio_state |= 1 << gpio;
+	else
+		chip->gpio_state &= ~(1 << gpio);
+	__raw_writel(chip->gpio_state, mm_gc->regs + ALTERA_GPIO_DATA_OFFSET);
+
+	spin_unlock_irqrestore(&chip->gpio_lock, flags);
+}
+
+/*
+ * altera_gpio_dir_in - Set the direction of the specified GPIO signal as input.
+ * @gc:     Pointer to gpio_chip device structure.
+ * @gpio:   GPIO signal number.
+ *
+ * This function sets the direction of specified GPIO signal as input.
+ * It returns 0 if direction of GPIO signals is set as input otherwise it
+ * returns negative error value.
+ */
+static int altera_gpio_dir_in(struct gpio_chip *gc, unsigned int gpio)
+{
+	unsigned long flags;
+	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
+	struct altera_gpio_instance *chip = to_altera_gpio(mm_gc);
+
+	spin_lock_irqsave(&chip->gpio_lock, flags);
+
+	/* Clear the GPIO bit in shadow register and set direction as input */
+	chip->gpio_dir &= ~(1 << gpio);
+	__raw_writel(chip->gpio_dir, mm_gc->regs + ALTERA_GPIO_DIR_OFFSET);
+
+	spin_unlock_irqrestore(&chip->gpio_lock, flags);
+
+	return 0;
+}
+
+/*
+ * altera_gpio_dir_out - Set the direction of the specified GPIO as output.
+ * @gc:     Pointer to gpio_chip device structure.
+ * @gpio:   GPIO signal number.
+ * @val:    Value to be written to specified signal.
+ *
+ * This function sets the direction of specified GPIO signal as output. If all
+ * GPIO signals of GPIO chip is configured as input then it returns
+ * error otherwise it returns 0.
+ */
+static int altera_gpio_dir_out(struct gpio_chip *gc, unsigned int gpio, int val)
+{
+	unsigned long flags;
+	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
+	struct altera_gpio_instance *chip = to_altera_gpio(mm_gc);
+
+	spin_lock_irqsave(&chip->gpio_lock, flags);
+
+	/* Write state of GPIO signal */
+	if (val)
+		chip->gpio_state |= 1 << gpio;
+	else
+		chip->gpio_state &= ~(1 << gpio);
+	__raw_writel(chip->gpio_state, mm_gc->regs + ALTERA_GPIO_DATA_OFFSET);
+
+	/* Set the GPIO bit in shadow register and set direction as output */
+	chip->gpio_dir |= (1 << gpio);
+	__raw_writel(chip->gpio_dir, mm_gc->regs + ALTERA_GPIO_DIR_OFFSET);
+
+	spin_unlock_irqrestore(&chip->gpio_lock, flags);
+
+	return 0;
+}
+
+/*
+ * altera_gpio_save_regs - Set initial values of GPIO pins
+ * @mm_gc: pointer to memory mapped GPIO chip structure
+ */
+static void altera_gpio_save_regs(struct of_mm_gpio_chip *mm_gc)
+{
+	struct altera_gpio_instance *chip = to_altera_gpio(mm_gc);
+
+	__raw_writel(chip->gpio_state, mm_gc->regs + ALTERA_GPIO_DATA_OFFSET);
+	__raw_writel(chip->gpio_dir, mm_gc->regs + ALTERA_GPIO_DIR_OFFSET);
+}
+
+
+
+/*
+ * altera_gpio_of_probe - Probe method for the GPIO device.
+ * @np: pointer to device tree node
+ *
+ * This function probes the GPIO device in the device tree. It initializes the
+ * driver data structure. It returns 0, if the driver is bound to the GPIO
+ * device, or a negative value if there is an error.
+ */
+static int __devinit altera_gpio_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct altera_gpio_instance *chip;
+	int status = 0;
+	u32 reg;
+
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	/* Update GPIO state shadow register with default value */
+	if (of_property_read_u32(np, "resetvalue", &reg) == 0)
+		chip->gpio_state = reg;
+
+	/* Update GPIO direction shadow register with default value */
+	chip->gpio_dir = 0; /* By default, all pins are inputs */
+
+	/* Check device node for device width. Default to full width. */
+	if (of_property_read_u32(np, "width", &reg) == 0)
+		chip->mmchip.gc.ngpio = reg;
+	else
+		chip->mmchip.gc.ngpio = 32;
+
+	spin_lock_init(&chip->gpio_lock);
+
+	chip->mmchip.gc.direction_input = altera_gpio_dir_in;
+	chip->mmchip.gc.direction_output = altera_gpio_dir_out;
+	chip->mmchip.gc.get = altera_gpio_get;
+	chip->mmchip.gc.set = altera_gpio_set;
+
+	chip->mmchip.save_regs = altera_gpio_save_regs;
+
+	/* Call the OF gpio helper to setup and register the GPIO device */
+	status = of_mm_gpiochip_add(np, &chip->mmchip);
+	if (status) {
+		kfree(chip);
+		pr_err("%s: error in probe function with status %d\n",
+		       np->full_name, status);
+		return status;
+	}
+
+	platform_set_drvdata(pdev, chip);
+
+	return 0;
+}
+
+static int altera_gpio_remove(struct platform_device *pdev)
+{
+	int status;
+	
+	struct altera_gpio_instance *chip = platform_get_drvdata(pdev);
+	status = gpiochip_remove(&chip->mmchip.gc);
+	if (status < 0)
+		return status;
+	
+	kfree(chip);
+	return -EIO;
+}
+
+#ifdef CONFIG_OF
+static struct of_device_id altera_gpio_of_match[] __devinitdata = {
+	{ .compatible = "altr,pio-1.0", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, altera_gpio_of_match);
+#else
+#define altera_gpio_of_match NULL
+#endif
+
+static struct platform_driver altera_gpio_driver = {
+	.driver = {
+		.name	= "altera_gpio",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(altera_gpio_of_match),
+	},
+	.probe		= altera_gpio_probe,
+	.remove		= altera_gpio_remove,
+};
+
+static int __init altera_gpio_init(void)
+{
+	return platform_driver_register(&altera_gpio_driver);
+}
+subsys_initcall(altera_gpio_init);
+
+static void __exit altera_gpio_exit(void)
+{
+	platform_driver_unregister(&altera_gpio_driver);
+}
+module_exit(altera_gpio_exit);
+
+MODULE_DESCRIPTION("Altera GPIO driver");
+MODULE_AUTHOR("Thomas Chou <thomas@wytron.com.tw>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
diff --git a/drivers/gpio/gpio-dw.c b/drivers/gpio/gpio-dw.c
index 8c02800..802bd14 100644
--- a/drivers/gpio/gpio-dw.c
+++ b/drivers/gpio/gpio-dw.c
@@ -26,6 +26,9 @@
 #include <linux/interrupt.h>
 #include <linux/platform_device.h>
 #include <linux/platform_data/gpio-dw.h>
+#include <linux/of_gpio.h>
+#include <linux/slab.h>
+#include <linux/of_platform.h>
 
 #define GPIO_INT_EN_REG_OFFSET 		(0x30)
 #define GPIO_INT_MASK_REG_OFFSET 	(0x34)
@@ -34,383 +37,147 @@
 #define GPIO_INT_STATUS_REG_OFFSET 	(0x40)
 #define GPIO_PORT_A_EOI_REG_OFFSET 	(0x4c)
 
-#define GPIO_DDR_OFFSET_PORT(p) 	(0x4  + ((p) * 0xc))
-#define DW_GPIO_EXT(p) 			(0x50 + ((p) * 0x4))
-#define DW_GPIO_DR(p) 			(0x0  + ((p) * 0xc))
-
-#define CHIP_BASE (-1)
-
-struct gpio_bank {
-	u32 irq;
-	u32 virtual_irq_start;
-	spinlock_t lock;
-	u32 width;
-	u32 porta_width;
-	u32 portb_width;
-	u32 portc_width;
-	u32 portd_width;
-	void __iomem *regs;
-	struct gpio_chip chip;
-	struct device *dev;
-};
-
-static void dw_gpio_irq_disable(struct irq_data *d)
-{
-	struct gpio_bank *bank = irq_data_get_irq_chip_data(d);
-	u32 gpio_irq_number = d->irq - bank->virtual_irq_start;
-	unsigned long flags;
-	u32 port_inten;
-
-	spin_lock_irqsave(&bank->lock, flags);
-	port_inten = readl(bank->regs + GPIO_INT_EN_REG_OFFSET);
-	port_inten &= ~(1 << gpio_irq_number);
-	writel(port_inten, bank->regs + GPIO_INT_EN_REG_OFFSET);
-	spin_unlock_irqrestore(&bank->lock, flags);
-}
-
-static void dw_gpio_irq_enable(struct irq_data *d) {
-	struct gpio_bank *bank = irq_data_get_irq_chip_data(d);
-	u32 gpio_irq_number = d->irq - bank->virtual_irq_start;
-	unsigned long flags;
-	u32 port_inten;
-
-	spin_lock_irqsave(&bank->lock, flags);
-	port_inten = readl(bank->regs + GPIO_INT_EN_REG_OFFSET);
-	port_inten |= (1 << gpio_irq_number);
-	writel(port_inten, bank->regs + GPIO_INT_EN_REG_OFFSET);
-	spin_unlock_irqrestore(&bank->lock, flags);
-}
-
-static void dw_gpio_irq_unmask(struct irq_data *d) {
-	struct gpio_bank *bank = irq_data_get_irq_chip_data(d);
-	u32 gpio_irq_number = d->irq - bank->virtual_irq_start;
-	unsigned long flags;
-	u32 intmask;
-
-	spin_lock_irqsave(&bank->lock, flags);
-	intmask = readl(bank->regs + GPIO_INT_MASK_REG_OFFSET);
-	intmask &= ~(1 << gpio_irq_number);
-	writel(intmask, bank->regs + GPIO_INT_MASK_REG_OFFSET);
-	spin_unlock_irqrestore(&bank->lock, flags);
-}
-
-static void dw_gpio_irq_mask(struct irq_data *d) {
-	struct gpio_bank *bank = irq_data_get_irq_chip_data(d);
-	u32 gpio_irq_number = d->irq - bank->virtual_irq_start;
-	unsigned long flags;
-	u32 intmask;
-
-	spin_lock_irqsave(&bank->lock, flags);
-	intmask = readl(bank->regs + GPIO_INT_MASK_REG_OFFSET);
-	intmask |= (1 << gpio_irq_number);
-	writel(intmask, bank->regs + GPIO_INT_MASK_REG_OFFSET);
-	spin_unlock_irqrestore(&bank->lock, flags);
-}
-
-static void dw_gpio_irq_ack(struct irq_data *d) {
-	struct gpio_bank *bank = irq_data_get_irq_chip_data(d);
-	u32 gpio_irq_number = d->irq - bank->virtual_irq_start;
-	unsigned long flags;
-	u32 val;
-
-	spin_lock_irqsave(&bank->lock, flags);
-	val = readl(bank->regs + GPIO_PORT_A_EOI_REG_OFFSET);
-	val |= (1 << gpio_irq_number);
-	writel(val, bank->regs + GPIO_PORT_A_EOI_REG_OFFSET);
-	spin_unlock_irqrestore(&bank->lock, flags);
-}
-
-static int dw_gpio_irq_set_type(struct irq_data *d,
-				unsigned int type)
-{
-	struct gpio_bank *bank = irq_data_get_irq_chip_data(d);
-	u32 gpio_irq_number = d->irq - bank->virtual_irq_start;
-	u32 level, polarity;
-	u32 intmask;
-	unsigned long flags;
-
-	spin_lock_irqsave(&bank->lock, flags);
-
-	intmask = readl(bank->regs + GPIO_INT_MASK_REG_OFFSET);
-	writel(~(1 << gpio_irq_number) & (intmask),
-		bank->regs + GPIO_INT_MASK_REG_OFFSET);
-
-	level = readl(bank->regs + GPIO_INT_TYPE_LEVEL_REG_OFFSET);
-	polarity = readl(bank->regs + GPIO_INT_POLARITY_REG_OFFSET);
-
-	switch (type & IRQ_TYPE_SENSE_MASK) {
-	case IRQ_TYPE_EDGE_RISING:
-		level 		|= (1 << gpio_irq_number);
-		polarity 	|= (1 << gpio_irq_number);
-		break;
-
-	case IRQ_TYPE_EDGE_FALLING:
-		level 		|= (1 << gpio_irq_number);
-		polarity 	&= ~(1 << gpio_irq_number);
-		break;
-
-	case IRQ_TYPE_LEVEL_HIGH:
-		level 		&= ~(1 << gpio_irq_number);
-		polarity 	|= (1 << gpio_irq_number);
-		break;
-
-	case IRQ_TYPE_LEVEL_LOW:
-		level	 	&= ~(1 << gpio_irq_number);
-		polarity 	&= ~(1 << gpio_irq_number);
-		break;
-
-	default:
-		writel(intmask, bank->regs + GPIO_INT_MASK_REG_OFFSET);
-		return -EINVAL;
-	}
-
-	writel(level, bank->regs + GPIO_INT_TYPE_LEVEL_REG_OFFSET);
-	writel(polarity, bank->regs + GPIO_INT_POLARITY_REG_OFFSET);
-	writel(intmask, bank->regs + GPIO_INT_MASK_REG_OFFSET);
-	spin_unlock_irqrestore(&bank->lock, flags);
-
-	return 0;
-}
-
-static struct irq_chip gpio_irq_chip = {
-	.name		= "GPIO",
-	.irq_enable	= dw_gpio_irq_enable,
-	.irq_disable	= dw_gpio_irq_disable,
-	.irq_ack	= dw_gpio_irq_ack,
-	.irq_mask	= dw_gpio_irq_mask,
-	.irq_unmask	= dw_gpio_irq_unmask,
-	.irq_set_type	= dw_gpio_irq_set_type,
+#define GPIO_DDR_OFFSET_PORT	 	(0x4)
+#define DW_GPIO_EXT 			(0x50)
+#define DW_GPIO_DR 			(0x0)
+#define DRV_NAME "dw gpio"
+
+struct dw_gpio_instance {
+	struct of_mm_gpio_chip mmchip;
+	u32 gpio_state;		/* GPIO state shadow register */
+	u32 gpio_dir;		/* GPIO direction shadow register */
+	int irq;		/* GPIO controller IRQ number */
+	int irq_base;		/* base number for the "virtual" GPIO IRQs */
+	u32 irq_mask;		/* IRQ mask */
+	spinlock_t gpio_lock;	/* Lock used for synchronization */
 };
 
-enum DW_GPIO_PORT {
-	PORTA = 0,
-	PORTB = 1,
-	PORTC = 2,
-	PORTD = 3,
-	PORT_INVALID,
-};
-
-static int get_port(struct gpio_bank *bank, unsigned offset) {
-	int port_offset = offset;
-	port_offset -= bank->porta_width;
-	if (port_offset < 0)
-		return PORTA;
-
-	port_offset -= bank->portb_width;
-	if (port_offset < 0)
-		return PORTB;
-
-	port_offset -= bank->portc_width;
-	if (port_offset < 0)
-		return PORTC;
-
-	port_offset -= bank->portd_width;
-	if (port_offset < 0)
-		return PORTD;
-
-	dev_warn(bank->dev, "Invalid offset specified\n");
-	return PORT_INVALID;
-}
-
-static int dw_gpio_get(struct gpio_chip *chip, unsigned offset)
+static int dw_gpio_get(struct gpio_chip *gc, unsigned offset)
 {
-	struct gpio_bank *bank = container_of(chip, struct gpio_bank, chip);
-	enum DW_GPIO_PORT port = get_port(bank, offset);
-
-	if(port == PORT_INVALID)
-		return 0;
+	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
 
-	return (readl(bank->regs + DW_GPIO_EXT(port)) >> offset) & 1;
+	return (__raw_readl(mm_gc->regs + DW_GPIO_EXT) >> offset) & 1;
 }
 
-static void dw_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+static void dw_gpio_set(struct gpio_chip *gc, unsigned offset, int value)
 {
-	struct gpio_bank *bank = container_of(chip, struct gpio_bank, chip);
-	enum DW_GPIO_PORT port = get_port(bank, offset);
+	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
+	struct dw_gpio_instance *chip = container_of(mm_gc, struct dw_gpio_instance, mmchip);
 	unsigned long flags;
 	u32 data_reg;
 
-	if(port == PORT_INVALID)
-		return;
-
-	spin_lock_irqsave(&bank->lock, flags);
-	data_reg = readl(bank->regs + DW_GPIO_DR(port));
-	data_reg = (data_reg & ~(1<<offset)) | (!!value << offset);
-	writel(data_reg, bank->regs + DW_GPIO_DR(port));
-	spin_unlock_irqrestore(&bank->lock, flags);
+	spin_lock_irqsave(&chip->gpio_lock, flags);
+	data_reg = __raw_readl(mm_gc->regs + DW_GPIO_DR);
+	data_reg = (data_reg & ~(1<<offset)) | (value << offset);
+	__raw_writel(data_reg, mm_gc->regs + DW_GPIO_DR);
+	spin_unlock_irqrestore(&chip->gpio_lock, flags);
 }
 
-static int dw_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
+static int dw_gpio_direction_input(struct gpio_chip *gc, unsigned offset)
 {
-	struct gpio_bank *bank = container_of(chip, struct gpio_bank, chip);
+	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
+	struct dw_gpio_instance *chip = container_of(mm_gc, struct dw_gpio_instance, mmchip);
 	unsigned long flags;
 	u32 gpio_ddr;
-	enum DW_GPIO_PORT port = get_port(bank, offset);
-
-	if(port == PORT_INVALID)
-		return -EINVAL;
 
-	spin_lock_irqsave(&bank->lock, flags);
+	spin_lock_irqsave(&chip->gpio_lock, flags);
 	/* Set pin as input, assumes software controlled IP */
-	gpio_ddr = readl(bank->regs + GPIO_DDR_OFFSET_PORT(port));
+	gpio_ddr = __raw_readl(mm_gc->regs + GPIO_DDR_OFFSET_PORT);
 	gpio_ddr &= ~(1 << offset);
-	writel(gpio_ddr, bank->regs + GPIO_DDR_OFFSET_PORT(port));
-	spin_unlock_irqrestore(&bank->lock, flags);
+	__raw_writel(gpio_ddr, mm_gc->regs + GPIO_DDR_OFFSET_PORT);
+	spin_unlock_irqrestore(&chip->gpio_lock, flags);
 
 	return 0;
 }
 
-static int dw_gpio_direction_output(struct gpio_chip *chip,
+static int dw_gpio_direction_output(struct gpio_chip *gc,
 		unsigned offset, int value)
 {
-	struct gpio_bank *bank = container_of(chip, struct gpio_bank, chip);
+	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
+	struct dw_gpio_instance *chip = container_of(mm_gc, struct dw_gpio_instance, mmchip);
 	unsigned long flags;
 	u32 gpio_ddr;
-	enum DW_GPIO_PORT port = get_port(bank, offset);
-
-	if(port == PORT_INVALID)
-		return -EINVAL;
-
-	dw_gpio_set(chip, offset, value);
 
-	spin_lock_irqsave(&bank->lock, flags);
+	dw_gpio_set(gc, offset, value);
+	
+	spin_lock_irqsave(&chip->gpio_lock, flags);
 	/* Set pin as output, assumes software controlled IP */
-	gpio_ddr = readl(bank->regs + GPIO_DDR_OFFSET_PORT(port));
+	gpio_ddr = __raw_readl(mm_gc->regs + GPIO_DDR_OFFSET_PORT);
 	gpio_ddr |= (1 << offset);
-	writel(gpio_ddr, bank->regs + GPIO_DDR_OFFSET_PORT(port));
-	spin_unlock_irqrestore(&bank->lock, flags);
-
+	__raw_writel(gpio_ddr, mm_gc->regs + GPIO_DDR_OFFSET_PORT);
+	spin_unlock_irqrestore(&chip->gpio_lock, flags);
 	return 0;
 }
 
-static int dw_gpio_to_irq(struct gpio_chip *chip, unsigned offset) {
-	struct gpio_bank *bank = container_of(chip, struct gpio_bank, chip);
-
-	return bank->virtual_irq_start + offset;
-}
-
-static void gpio_irq_handler(unsigned int irq, struct irq_desc *desc)
-{
-	struct irq_chip *chip = irq_desc_get_chip(desc);
-	struct gpio_bank *bank = irq_get_handler_data(irq);
-	unsigned long status;
-
-	int i;
-	chip->irq_mask(&desc->irq_data);
-
-	status = readl(bank->regs +
-		GPIO_INT_STATUS_REG_OFFSET);
-
-	for_each_set_bit(i, &status, bank->porta_width) {
-		generic_handle_irq(bank->virtual_irq_start + i);
-	}
-	writel(status, bank->regs + GPIO_PORT_A_EOI_REG_OFFSET);
-	chip->irq_eoi(irq_desc_get_irq_data(desc));
-	chip->irq_unmask(&desc->irq_data);
-}
-
-static struct lock_class_key gpio_lock_class;
-
-static void __devinit dw_gpio_chip_init(struct gpio_bank *bank, u32 gpio_base) {
-	int i;
-
-	bank->chip.direction_input	= dw_gpio_direction_input;
-	bank->chip.direction_output	= dw_gpio_direction_output;
-	bank->chip.get			= dw_gpio_get;
-	bank->chip.set			= dw_gpio_set;
-	bank->chip.to_irq		= dw_gpio_to_irq;
-	bank->chip.owner		= THIS_MODULE;
-	bank->chip.base			= gpio_base;
-	bank->chip.ngpio		= bank->width;
-
-	gpiochip_add(&bank->chip);
-
-	for (i = bank->virtual_irq_start;
-		i < bank->virtual_irq_start + bank->porta_width; i++) {
-		irq_set_lockdep_class(i, &gpio_lock_class);
-		irq_set_chip_data(i, bank);
-		irq_set_chip(i, &gpio_irq_chip);
-		irq_set_handler(i, handle_simple_irq);
-		set_irq_flags(i, IRQF_VALID);
-	}
-	irq_set_chained_handler(bank->irq, gpio_irq_handler);
-	irq_set_handler_data(bank->irq, bank);
-}
-
+/* 
+ * dw_gpio_probe - Probe method for the GPIO device.
+ * @np: pointer to device tree node
+ *
+ * This function probes the GPIO device in the device tree. It initializes the
+ * driver data structure. It returns 0, if the driver is bound to the GPIO
+ * device, or a negative value if there is an error.
+ */
 static int __devinit dw_gpio_probe(struct platform_device *pdev)
 {
-	struct resource *res;
-	struct resource *mem;
-	struct device_node *node = pdev->dev.of_node;
-	int id;
-	struct gpio_bank *bank = devm_kzalloc(&pdev->dev, sizeof(*bank),
-					GFP_KERNEL);
-	bank->dev = &pdev->dev;
-
-	id = pdev->id;
-
-	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	if (unlikely(!res)) {
-		dev_err(&pdev->dev, "GPIO Bank %i has an Invalid IRQ Resource\n"
-			, id);
-		return -ENODEV;
-	}
-
-	bank->irq = res->start; /* IRQ base number */
-
-	if (of_property_read_u32(node,
-			"virtual_irq_start", &bank->virtual_irq_start)) {
-		dev_err(&pdev->dev, "No virtual irq specified\n");
-		return -EINVAL;
-	}
-
-	if (of_property_read_u32(node,
-			"bank_width", &bank->width)) {
-		dev_err(&pdev->dev, "Bank width not specified\n");
-		return -EINVAL;
-	}
-
-	bank->porta_width = 0;
-	bank->portb_width = 0;
-	bank->portc_width = 0;
-	bank->portd_width = 0;
-
-	of_property_read_u32(node,
-			"porta_width", &bank->porta_width);
-
-	of_property_read_u32(node,
-			"portb_width", &bank->portb_width);
-
-	of_property_read_u32(node,
-			"portc_width", &bank->portc_width);
-
-	of_property_read_u32(node,
-			"portd_width", &bank->portd_width);
-
-
-	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (unlikely(!mem)) {
-		dev_err(&pdev->dev,
-			"GPIO Bank %i has an Invalid Memory Resource\n", id);
-		return -ENODEV;
+	struct device_node *np = pdev->dev.of_node;
+	struct dw_gpio_instance *chip;
+	int status = 0;
+	u32 reg;
+
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+	{
+		printk(KERN_ERR "%s 2 ERROR allocating memory", __func__);
+		return -ENOMEM;
 	}
 
-	bank->regs = devm_ioremap(&pdev->dev, mem->start, resource_size(mem));
-	if (unlikely(!bank->regs)) {
-		dev_err(&pdev->dev,
-			"Failed IO remap for GPIO resource\n");
-		return -ENODEV;
+	/* Update GPIO state shadow register with default value */
+	if (of_property_read_u32(np, "resetvalue", &reg) == 0)
+		chip->gpio_state = reg;
+
+	/* Update GPIO direction shadow register with default value */
+	chip->gpio_dir = 0; /* By default, all pins are inputs */
+
+	/* Check device node for device width */
+	if (of_property_read_u32(np, "width", &reg) == 0)
+		chip->mmchip.gc.ngpio = reg;
+	else
+		chip->mmchip.gc.ngpio = 32; /* By default assume full GPIO controller */
+
+	spin_lock_init(&chip->gpio_lock);
+
+	chip->mmchip.gc.direction_input = dw_gpio_direction_input;
+	chip->mmchip.gc.direction_output = dw_gpio_direction_output;
+	chip->mmchip.gc.get = dw_gpio_get;
+	chip->mmchip.gc.set = dw_gpio_set;
+
+	/* Call the OF gpio helper to setup and register the GPIO device */
+	status = of_mm_gpiochip_add(np, &chip->mmchip);
+	if (status) {
+		kfree(chip);
+		pr_err("%s: error in probe function with status %d\n",
+		       np->full_name, status);
+		return status;
 	}
 
-	bank->chip.of_node = of_node_get(node);
-	irq_domain_add_legacy(node, bank->porta_width,
-		bank->virtual_irq_start, 0, &irq_domain_simple_ops, NULL);
-
-	dw_gpio_chip_init(bank, CHIP_BASE);
-
+	platform_set_drvdata(pdev, chip);
 	return 0;
 }
 
+static int dw_gpio_remove(struct platform_device *pdev)
+{
+	/* todo check this and see that we don't have a memory leak */
+	int status;
+	
+	struct dw_gpio_instance *chip = platform_get_drvdata(pdev);
+	status = gpiochip_remove(&chip->mmchip.gc);
+	if (status < 0)
+		return status;
+	
+	kfree(chip);
+	return -EIO;
+}
+
 #ifdef CONFIG_OF
 static const struct of_device_id dwgpio_match[] = {
 	{.compatible = DW_GPIO_COMPATIBLE,},
@@ -421,17 +188,30 @@ MODULE_DEVICE_TABLE(of, dwgpio_match);
 #define dwgpio_match NULL
 #endif
 
-static struct platform_driver dw_gpio_driver = {
-	.probe          = dw_gpio_probe,
-	.driver         = {
-		.owner  = THIS_MODULE,
-		.name   = "dwgpio",
-		.of_match_table = dwgpio_match,
+static struct platform_driver dwgpio_driver = {
+	.driver = {
+		.name	= "dw_gpio",
+		.owner	= THIS_MODULE,
+		.of_match_table = of_match_ptr(dwgpio_match),
 	},
+	.probe		= dw_gpio_probe,
+	.remove		= dw_gpio_remove,
 };
 
 static int __init dwgpio_init(void)
 {
-	return platform_driver_register(&dw_gpio_driver);
+	return platform_driver_register(&dwgpio_driver);
+}
+subsys_initcall(dwgpio_init);
+
+static void __exit dwgpio_exit(void)
+{
+	platform_driver_unregister(&dwgpio_driver);
 }
-core_initcall(dwgpio_init);
+module_exit(dwgpio_exit);
+
+
+MODULE_DESCRIPTION("Altera GPIO driver");
+MODULE_AUTHOR("Thomas Chou <thomas@wytron.com.tw>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:" DRV_NAME);
-- 
1.7.5.4

