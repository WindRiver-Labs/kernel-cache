From 3dd8d56b55e7c4364658e23d5d2fab046bf1350e Mon Sep 17 00:00:00 2001
From: Dinh Nguyen <dinguyen@altera.com>
Date: Mon, 22 Apr 2013 11:13:59 -0500
Subject: [PATCH 240/254] arm: socfpga: Add support to gate peripheral clocks

Upstream: git://git.rocketboards.org/linux-socfpga.git

Add support to gate the clocks that directly feed peripherals. For clocks
with multiple parents, add the ability to determine the correct parent,
and also set parents. Also add support to calculate and set the clocks'
rate.

Signed-off-by: Dinh Nguyen <dinguyen@altera.com>

v4:
- Add defines for more clocks

v3:
- Clean up from code reviews of get_parent/set_parent

V2:
- No longer needs to return clk in socfpga_gate_clk_init funtion
- Add recalc_rate and set_rate functionality
- nand_x_clk and nand_clk have the same parent
- Add define for l4_mp_clk
- All clocks that be gated/divided are entered
(cherry picked from commit 84dfe1bb7b42525ff04b5afe0ea0b14d86a0d571)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 .../devicetree/bindings/clock/altr_socfpga.txt     |    9 +-
 arch/arm/boot/dts/socfpga.dtsi                     |  199 ++++++++++++++++++++
 drivers/clk/socfpga/clk.c                          |  177 +++++++++++++++++
 3 files changed, 383 insertions(+), 2 deletions(-)

diff --git a/Documentation/devicetree/bindings/clock/altr_socfpga.txt b/Documentation/devicetree/bindings/clock/altr_socfpga.txt
index f954c72..fa845d7 100644
--- a/Documentation/devicetree/bindings/clock/altr_socfpga.txt
+++ b/Documentation/devicetree/bindings/clock/altr_socfpga.txt
@@ -9,11 +9,16 @@ Required properties:
 	"altr,socfpga-pll-clock" - for a PLL clock
 	"altr,socfpga-perip-clock" - The peripheral clock divided from the
 		PLL clock.
+	"altr,socfpga-gate-clk" - Clocks that directly feed peripherals and
+		can get gated.
+
 - reg : shall be the control register offset from CLOCK_MANAGER's base for the clock.
-- clocks : shall be the input parent clock phandle for the clock. This is
-	either an oscillator or a pll output.
 - #clock-cells : from common clock binding; shall be set to 0.
 
 Optional properties:
 - fixed-divider : If clocks have a fixed divider value, use this property.
+- clk-gate : For "socfpga-gate-clk", clk-gate contains the gating register
+        and the bit index.
+- div-reg : For "socfpga-gate-clk", div-reg contains the divider register, bit shift,
+        and width.
 
diff --git a/arch/arm/boot/dts/socfpga.dtsi b/arch/arm/boot/dts/socfpga.dtsi
index e7c5fdb..ce72de0 100644
--- a/arch/arm/boot/dts/socfpga.dtsi
+++ b/arch/arm/boot/dts/socfpga.dtsi
@@ -107,6 +107,12 @@
 						compatible = "fixed-clock";
 					};
 
+					f2s_periph_ref_clk: f2s_periph_ref_clk {
+						#clock-cells = <0>;
+						compatible = "fixed-clock";
+						clock-frequency = <10000000>;
+					};
+
 					main_pll: main_pll {
 						#address-cells = <1>;
 						#size-cells = <0>;
@@ -248,6 +254,199 @@
 							reg = <0xD4>;
 						};
 					};
+
+				mpu_periph_clk: mpu_periph_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&mpuclk>;
+					fixed-divider = <4>;
+					};
+
+				mpu_l2_ram_clk: mpu_l2_ram_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&mpuclk>;
+					fixed-divider = <2>;
+					};
+
+				l4_main_clk: l4_main_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&mainclk>;
+					clk-gate = <0x60 0>;
+					};
+
+				l3_main_clk: l3_main_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&mainclk>;
+					};
+
+				l3_mp_clk: l3_mp_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&mainclk>;
+					div-reg = <0x64 0 2>;
+					clk-gate = <0x60 1>;
+					};
+
+				l3_sp_clk: l3_sp_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&mainclk>;
+					div-reg = <0x64 2 2>;
+				};
+
+				l4_mp_clk: l4_mp_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&mainclk>, <&per_base_clk>;
+					div-reg = <0x64 4 3>;
+					clk-gate = <0x60 2>;
+					};
+
+				l4_sp_clk: l4_sp_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&mainclk>, <&per_base_clk>;
+					div-reg = <0x64 7 3>;
+					clk-gate = <0x60 3>;
+					};
+
+				dbg_at_clk: dbg_at_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&dbg_base_clk>;
+					div-reg = <0x68 0 2>;
+					clk-gate = <0x60 4>;
+					};
+
+				dbg_clk: dbg_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&dbg_base_clk>;
+					div-reg = <0x68 2 2>;
+					clk-gate = <0x60 5>;
+					};
+
+				dbg_trace_clk: dbg_trace_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&dbg_base_clk>;
+					div-reg = <0x6C 0 3>;
+					clk-gate = <0x60 6>;
+					};
+
+				dbg_timer_clk: dbg_timer_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&dbg_base_clk>;
+					clk-gate = <0x60 7>;
+					};
+
+				cfg_clk: cfg_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&cfg_s2f_usr0_clk>;
+					clk-gate = <0x60 8>;
+					};
+
+				s2f_user0_clk: s2f_user0_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&cfg_s2f_usr0_clk>;
+					clk-gate = <0x60 9>;
+					};
+
+				emac_0_clk: emac_0_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&emac0_clk>;
+					clk-gate = <0xa0 0>;
+					};
+
+				emac_1_clk: emac_1_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&emac1_clk>;
+					clk-gate = <0xa0 1>;
+					};
+
+				usb_mp_clk: usb_mp_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&per_base_clk>;
+					clk-gate = <0xa0 2>;
+					div-reg = <0xa4 0 3>;
+					};
+
+				spi_m_clk: spi_m_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&per_base_clk>;
+					clk-gate = <0xa0 3>;
+					div-reg = <0xa4 3 3>;
+					};
+
+				can0_clk: can0_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&per_base_clk>;
+					clk-gate = <0xa0 4>;
+					div-reg = <0xa4 6 3>;
+					};
+
+				can1_clk: can1_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&per_base_clk>;
+					clk-gate = <0xa0 5>;
+					div-reg = <0xa4 9 3>;
+					};
+
+				gpio_db_clk: gpio_db_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&per_base_clk>;
+					clk-gate = <0xa0 6>;
+					div-reg = <0xa8 0 24>;
+					};
+
+				s2f_user1_clk: s2f_user1_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&s2f_usr1_clk>;
+					clk-gate = <0xa0 7>;
+					};
+
+				sdmmc_clk: sdmmc_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&f2s_periph_ref_clk>, <&main_nand_sdmmc_clk>, <&per_nand_mmc_clk>;
+					clk-gate = <0xa0 8>;
+					};
+
+				nand_x_clk: nand_x_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&f2s_periph_ref_clk>, <&main_nand_sdmmc_clk>, <&per_nand_mmc_clk>;
+					clk-gate = <0xa0 9>;
+					};
+
+				nand_clk: nand_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&f2s_periph_ref_clk>, <&main_nand_sdmmc_clk>, <&per_nand_mmc_clk>;
+					clk-gate = <0xa0 10>;
+					fixed-divider = <4>;
+					};
+
+				qspi_clk: qspi_clk {
+					#clock-cells = <0>;
+					compatible = "altr,socfpga-gate-clk";
+					clocks = <&f2s_periph_ref_clk>, <&main_qspi_clk>, <&per_qspi_clk>;
+					clk-gate = <0xa0 11>;
+					};
 				};
 			};
 
diff --git a/drivers/clk/socfpga/clk.c b/drivers/clk/socfpga/clk.c
index ebb29ee..a40bfdd 100644
--- a/drivers/clk/socfpga/clk.c
+++ b/drivers/clk/socfpga/clk.c
@@ -27,6 +27,8 @@
 /* Clock Manager offsets */
 #define CLKMGR_CTRL    0x0
 #define CLKMGR_BYPASS 0x4
+#define CLKMGR_L4SRC	0x70
+#define CLKMGR_PERPLL_SRC	0xAC
 
 /* Clock bypass bits */
 #define MAINPLL_BYPASS (1<<0)
@@ -42,6 +44,16 @@
 #define SOCFPGA_PLL_DIVF_SHIFT	3
 #define SOCFPGA_PLL_DIVQ_MASK		0x003F0000
 #define SOCFPGA_PLL_DIVQ_SHIFT	16
+#define SOCFGPA_MAX_PARENTS	3
+
+#define SOCFPGA_L4_MP_CLK			"l4_mp_clk"
+#define SOCFPGA_L4_SP_CLK			"l4_sp_clk"
+#define SOCFPGA_NAND_CLK		"nand_clk"
+#define SOCFPGA_NAND_X_CLK		"nand_x_clk"
+#define SOCFPGA_MMC_CLK			"mmc_clk"
+#define SOCFPGA_DB_CLK			"gpio_db_clk"
+
+#define div_mask(width)	((1 << (width)) - 1)
 
 extern void __iomem *clk_mgr_base_addr;
 
@@ -50,6 +62,9 @@ struct socfpga_clk {
 	char *parent_name;
 	char *clk_name;
 	u32 fixed_div;
+	void __iomem *div_reg;
+	u32 width;
+	u32 shift;
 };
 #define to_socfpga_clk(p) container_of(p, struct socfpga_clk, hw.hw)
 
@@ -149,6 +164,162 @@ static __init struct clk *socfpga_clk_init(struct device_node *node,
 	return clk;
 }
 
+static u8 socfpga_clk_get_parent(struct clk_hw *hwclk)
+{
+	u32 l4_src;
+	u32 perpll_src;
+	u8 parent;
+
+	if (strcmp(hwclk->init->name, SOCFPGA_L4_MP_CLK) == 0) {
+		l4_src = readl(clk_mgr_base_addr + CLKMGR_L4SRC);
+		l4_src &= 0x1;
+		parent = l4_src;
+	} else if (strcmp(hwclk->init->name, SOCFPGA_L4_SP_CLK) == 0) {
+		l4_src = readl(clk_mgr_base_addr + CLKMGR_L4SRC);
+		l4_src = ((l4_src & 0x2) >> 1);
+		parent = l4_src;
+	} else {
+		perpll_src = readl(clk_mgr_base_addr + CLKMGR_PERPLL_SRC);
+		if (strcmp(hwclk->init->name, SOCFPGA_MMC_CLK) == 0)
+			perpll_src &= 0x3;
+		else if (strcmp(hwclk->init->name, SOCFPGA_NAND_CLK) == 0 ||
+				strcmp(hwclk->init->name, SOCFPGA_NAND_X_CLK) == 0)
+			perpll_src = ((perpll_src & 0xC) >> 2);
+		else /*QSPI clock */
+			perpll_src = ((perpll_src & 0x30) >> 4);
+		parent = perpll_src;
+	}
+
+	return parent;
+}
+
+static int socfpga_clk_set_parent(struct clk_hw *hwclk, u8 parent)
+{
+	u32 src_reg;
+
+	if (strcmp(hwclk->init->name, SOCFPGA_L4_MP_CLK) == 0) {
+		src_reg = readl(clk_mgr_base_addr + CLKMGR_L4SRC);
+		src_reg &= ~0x1;
+		src_reg |= parent;
+		writel(src_reg, clk_mgr_base_addr + CLKMGR_L4SRC);
+	} else if (strcmp(hwclk->init->name, SOCFPGA_L4_SP_CLK) == 0) {
+		src_reg = readl(clk_mgr_base_addr + CLKMGR_L4SRC);
+		src_reg &= ~0x2;
+		src_reg |= (parent << 1);
+		writel(src_reg, clk_mgr_base_addr + CLKMGR_L4SRC);
+	} else {
+		src_reg = readl(clk_mgr_base_addr + CLKMGR_PERPLL_SRC);
+		if (strcmp(hwclk->init->name, SOCFPGA_MMC_CLK) == 0) {
+			src_reg &= ~0x3;
+			src_reg |= parent;
+		} else if (strcmp(hwclk->init->name, SOCFPGA_NAND_CLK) == 0 ||
+			strcmp(hwclk->init->name, SOCFPGA_NAND_X_CLK) == 0) {
+			src_reg &= ~0xC;
+			src_reg |= (parent << 2);
+		} else {/*QSPI clock */
+			src_reg &= ~0x30;
+			src_reg |= (parent << 4);
+		}
+		writel(src_reg, clk_mgr_base_addr + CLKMGR_PERPLL_SRC);
+	}
+
+	return 0;
+}
+
+static unsigned long socfpga_clk_recalc_rate(struct clk_hw *hwclk,
+	unsigned long parent_rate)
+{
+	struct socfpga_clk *socfpgaclk = to_socfpga_clk(hwclk);
+	u32 div = 1, val;
+
+	if (socfpgaclk->fixed_div)
+		div = socfpgaclk->fixed_div;
+	else if (socfpgaclk->div_reg) {
+		val = readl(socfpgaclk->div_reg) >> socfpgaclk->shift;
+		val &= div_mask(socfpgaclk->width);
+		if (strcmp(hwclk->init->name, SOCFPGA_DB_CLK) == 0)
+			div = val + 1;
+		else
+			div = (1 << val);
+	}
+
+	return parent_rate / div;
+}
+
+static struct clk_ops gateclk_ops = {
+	.recalc_rate = socfpga_clk_recalc_rate,
+	.get_parent = socfpga_clk_get_parent,
+	.set_parent = socfpga_clk_set_parent,
+};
+
+static void __init socfpga_gate_clk_init(struct device_node *node,
+	const struct clk_ops *ops)
+{
+	u32 clk_gate[2];
+	u32 div_reg[3];
+	u32 fixed_div;
+	struct clk *clk;
+	struct socfpga_clk *socfpga_clk;
+	const char *clk_name = node->name;
+	const char *parent_name[SOCFGPA_MAX_PARENTS];
+	struct clk_init_data init;
+	int rc;
+	int i = 0;
+
+	socfpga_clk = kzalloc(sizeof(*socfpga_clk), GFP_KERNEL);
+	if (WARN_ON(!socfpga_clk))
+		return;
+
+	rc = of_property_read_u32_array(node, "clk-gate", clk_gate, 2);
+	if (rc)
+		clk_gate[0] = 0;
+
+	rc = of_property_read_u32(node, "fixed-divider", &fixed_div);
+	if (rc)
+		socfpga_clk->fixed_div = 0;
+	else
+		socfpga_clk->fixed_div = fixed_div;
+
+	if (clk_gate[0]) {
+		socfpga_clk->hw.reg = clk_mgr_base_addr + clk_gate[0];
+		socfpga_clk->hw.bit_idx = clk_gate[1];
+
+		gateclk_ops.enable = clk_gate_ops.enable;
+		gateclk_ops.disable = clk_gate_ops.disable;
+	}
+
+	rc = of_property_read_u32_array(node, "div-reg", div_reg, 3);
+	if (!rc) {
+		socfpga_clk->div_reg = clk_mgr_base_addr + div_reg[0];
+		socfpga_clk->shift = div_reg[1];
+		socfpga_clk->width = div_reg[2];
+	} else {
+		socfpga_clk->div_reg = 0;
+	}
+
+	of_property_read_string(node, "clock-output-names", &clk_name);
+
+	init.name = clk_name;
+	init.ops = ops;
+	init.flags = 0;
+	while (i < SOCFGPA_MAX_PARENTS && (parent_name[i] =
+			of_clk_get_parent_name(node, i)) != NULL)
+		i++;
+
+	init.parent_names = parent_name;
+	init.num_parents = i;
+	socfpga_clk->hw.hw.init = &init;
+
+	clk = clk_register(NULL, &socfpga_clk->hw.hw);
+	if (WARN_ON(IS_ERR(clk))) {
+		kfree(socfpga_clk);
+		return;
+	}
+	rc = of_clk_add_provider(node, of_clk_src_simple_get, clk);
+	if (WARN_ON(rc))
+		return;
+}
+
 static void __init socfpga_pll_init(struct device_node *node)
 {
 	socfpga_clk_init(node, &clk_pll_ops);
@@ -159,10 +330,16 @@ static void __init socfpga_periph_init(struct device_node *node)
 	socfpga_clk_init(node, &periclk_ops);
 }
 
+static void __init socfpga_gate_init(struct device_node *node)
+{
+	socfpga_gate_clk_init(node, &gateclk_ops);
+}
+
 static const __initconst struct of_device_id clk_match[] = {
 	{ .compatible = "fixed-clock", .data = of_fixed_clk_setup, },
 	{ .compatible = "altr,socfpga-pll-clock", .data = socfpga_pll_init, },
 	{ .compatible = "altr,socfpga-perip-clk", .data = socfpga_periph_init, },
+	{ .compatible = "altr,socfpga-gate-clk", .data = socfpga_gate_init, },
 	{}
 };
 
-- 
1.7.5.4

