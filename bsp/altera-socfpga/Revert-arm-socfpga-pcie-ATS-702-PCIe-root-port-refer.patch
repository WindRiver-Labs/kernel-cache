From f40033a6f5f1e01174697af8e878a592dad627f1 Mon Sep 17 00:00:00 2001
From: Yang Wei <Wei.Yang@windriver.com>
Date: Thu, 22 May 2014 16:46:04 +0800
Subject: [PATCH 2/7] Revert "arm: socfpga: pcie: ATS 702, PCIe root port
 reference design"

This reverts commit 398fcb983f3855638ccca797b14febbcfacf5244.

Conflicts:

	arch/arm/boot/dts/socfpga_cyclone5.dts
	arch/arm/mach-socfpga/Makefile

We need to upgrade pcie driver to 13.1, so firstly revert the
previous 13.0 pcie driver.

Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 .../devicetree/bindings/bus/altera-pcie.txt        |   21 -
 arch/arm/Kconfig                                   |    1 -
 arch/arm/boot/dts/socfpga_cyclone5.dts             |   48 --
 arch/arm/mach-socfpga/Makefile                     |    3 -
 arch/arm/mach-socfpga/altera_pcie.c                |  507 --------------------
 5 files changed, 0 insertions(+), 580 deletions(-)
 delete mode 100644 Documentation/devicetree/bindings/bus/altera-pcie.txt
 delete mode 100644 arch/arm/mach-socfpga/altera_pcie.c

diff --git a/Documentation/devicetree/bindings/bus/altera-pcie.txt b/Documentation/devicetree/bindings/bus/altera-pcie.txt
deleted file mode 100644
index 369dcf3..0000000
--- a/Documentation/devicetree/bindings/bus/altera-pcie.txt
+++ /dev/null
@@ -1,21 +0,0 @@
-* Altera PCI Express Root Port
-
-Altera FPGA include of PCIe RP IP
-
-properties:
-- compatible : "altr,pcie-root-port-1.0"
-- reg, cra or txs : bases for CTA and TXS
-- interrupts : interrupt connection
-
-Example
-	pcie_cv_hip_avmm_0: pcie@0x0 {
-		compatible = "altr,pcie-root-port-1.0";
-		reg = < 0x00000000 0x20000000 >;
-		cra = < 0xFF240000 0x00004000 >;
-		/* txs = < 0xC0000000 0x20000000 >; */
-		interrupt-parent = < &hps_0_arm_gic_0 >;
-		interrupts = < 0 43 4 >;
-		interrupt-controller;
-		#interrupt-cells = < 1 >;
-	}; //end pcie@0x0 (pcie_cv_hip_avmm_0)
-
diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 801a574..d29f240 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -293,7 +293,6 @@ config ARCH_SOCFPGA
 	select HAVE_ARM_SCU
 	select HAVE_SMP
 	select MIGHT_HAVE_CACHE_L2X0
-	select MIGHT_HAVE_PCI
 	select SPARSE_IRQ
 	select USE_OF
 	select SOC_BUS
diff --git a/arch/arm/boot/dts/socfpga_cyclone5.dts b/arch/arm/boot/dts/socfpga_cyclone5.dts
index 3d84d1b..f4c17af 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5.dts
+++ b/arch/arm/boot/dts/socfpga_cyclone5.dts
@@ -165,54 +165,6 @@
 			speed-mode = <0>;
 		};
 
-		hps_0_h2f: bridge@0xc0000000 {
-			compatible = "altr,h2f_bridge-1.0";
-			reg = < 0xC0000000 0x20000000 >;
-			#address-cells = < 1 >;
-			#size-cells = < 1 >;
-			ranges = < 0x00000000 0xC0000000 0x20000000 >;
-
-			mm_clock_crossing_bridge_H2F: bridge@0x0 {
-				compatible = "ALTR,avalon-13.0";
-				reg = < 0x00000000 0x20000000 >;
-				#address-cells = < 1 >;
-				#size-cells = < 1 >;
-				ranges = < 0x00000000 0x00000000 0x20000000 >;
-
-				pcie_cv_hip_avmm_0: pcie@0x0 {
-					compatible = "ALTR,root-port-13.0";
-					reg = < 0x00000000 0x20000000 >;
-					cra = < 0xFF240000 0x00004000 >;
-					/* txs = < 0xC0000000 0x20000000 >; */
-					interrupts = < 0 43 4 >;
-				}; //end pcie@0x0 (pcie_cv_hip_avmm_0)
-			}; //end bridge@0x0 (mm_clock_crossing_bridge_H2F)
-		}; //end bridge@0xc0000000 (hps_0_h2f)
-
-		hps_0_h2f_lw: bridge@0xff200000 {
-			compatible = "altr,h2f_lw_bridge-1.0";
-			reg = < 0xFF200000 0x00050000 >;
-			#address-cells = < 1 >;
-			#size-cells = < 1 >;
-			ranges = < 0x00040000 0xFF240000 0x00008000 >;
-
-			mm_clock_crossing_bridge_LW: bridge@0x40000 {
-				compatible = "ALTR,avalon-13.0";
-				reg = < 0x00040000 0x00008000 >;
-				#address-cells = < 1 >;
-				#size-cells = < 1 >;
-				ranges = < 0x00004000 0x00044000 0x00000020
-					0x00004020 0x00044020 0x00000010 >;
-
-				msgdma_0_modular_sgdma_dispatcher_0: msgdma@0x4000 {
-					compatible = "ALTR,msgdma-1.0";
-					reg = < 0x00004000 0x00000020
-						0x00004020 0x00000010 >;
-					interrupts = < 0 44 4 >;
-				}; //msgdma@0x4000 (msgdma_0_modular_sgdma_dispatcher_0)
-			}; //end bridge@0x40000 (mm_clock_crossing_bridge_LW)
-		}; //end bridge@0xff200000 (hps_0_h2f_lw)
-
 		watchdog0: wd@ffd02000 {
 			status = "okay";
 		};
diff --git a/arch/arm/mach-socfpga/Makefile b/arch/arm/mach-socfpga/Makefile
index 37a69e0..92ee8bb 100644
--- a/arch/arm/mach-socfpga/Makefile
+++ b/arch/arm/mach-socfpga/Makefile
@@ -5,6 +5,3 @@
 obj-y					:= socfpga.o dma.o
 obj-$(CONFIG_SMP)	+= headsmp.o platsmp.o
 obj-$(CONFIG_HW_PERF_EVENTS) += socfpga_cti.o
-
-# Interconnect pcie bus driver for Altera SoCs.
-obj-$(CONFIG_ALTERA_PCIE_RP) += altera_pcie.o
diff --git a/arch/arm/mach-socfpga/altera_pcie.c b/arch/arm/mach-socfpga/altera_pcie.c
deleted file mode 100644
index 0e09d79..0000000
--- a/arch/arm/mach-socfpga/altera_pcie.c
+++ /dev/null
@@ -1,507 +0,0 @@
-/*
- *  Copyright (C) 2013 Altera Corporation
- *
- * Bits taken from arch/arm/mach-tegra/pcie.c
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/pci.h>
-#include <linux/interrupt.h>
-#include <linux/irq.h>
-#include <linux/of_irq.h>
-#include <linux/of_address.h>
-
-/* Registers offset */
-#define A2P_ADDR_MAP_LO0  0x1000
-#define A2P_ADDR_MAP_HI0  0x1004
-#define RP_TX_REG0        0x2000
-#define RP_TX_REG1        0x2004
-#define RP_TX_CNTRL       0x2008
-#define RP_TX_EOP         0x2
-#define RP_TX_SOP         0x1
-#define RP_RXCPL_STATUS   0x2010
-#define RP_RXCPL_EOP      0x2
-#define RP_RXCPL_SOP      0x1
-#define RP_RXCPL_REG0     0x2014
-#define RP_RXCPL_REG1     0x2018
-#define P2A_INT_STATUS    0x3060
-#define P2A_INT_STS_ALL   0x0F
-#define RPRX_CPL_REV      0x10
-#define P2A_INT_ENABLE    0x3070
-#define P2A_INT_ENA_ALL   0x0F
-
-/* TLP CFG RD WR */
-#define TLP_FMTTYPE_CFGRD0 0x04  /* Configuration Read  Type 0 */
-#define TLP_FMTTYPE_CFGWR0 0x44  /* Configuration Write Type 0 */
-#define TLP_FMTTYPE_CFGRD1 0x05  /* Configuration Read  Type 1 */
-#define TLP_FMTTYPE_CFGWR1 0x45  /* Configuration Write Type 1 */
-#define TLP_PAYLOAD_SIZE   0x01  /* TLP Data Payload Size      */
-#define TLP_CFG_DW0(fmttype)            ((fmttype << 24) | TLP_PAYLOAD_SIZE)
-#define TLP_CFG_DW1(reqid, tag)         ((reqid << 16) | (tag << 8) | 0xF)
-#define TLP_READ_TAG       0x1D  /* statically define */
-#define TLP_WRITE_TAG      0x10  /* statically define */
-#define TLP_CFG_DW2(bus, devfn, offset) ((bus << 24) | (devfn << 16) | offset)
-
-struct altrpcierp_info_t {
-	void __iomem	*pcie_hip_avmm_cra_base;
-	u32		pcie_hip_avmm_txs_base_raw;
-	u32		pcie_hip_avmm_txs_size_raw;
-	int		hwirq;
-};
-
-struct tlp_rp_regpair_t {
-	u32 rp_ctrl;
-	u32 rp_reg0;
-	u32 rp_reg1;
-};
-
-/*
- * The Root Port is boot/initialized with bus 0 device 0
- * pribus use TYPE0 CFG, secbus use TYPE1 CFG, subbus use TYPE1 CFG
- */
-#define ALTRPCIERP_DEVFN 0
-static u8 rp_pribus;
-static u8 rp_secbus;
-static struct altrpcierp_info_t altrpcierp_info;
-
-/* TLP packet RX pair */
-static void tlp_read_rp_rx(struct tlp_rp_regpair_t *tlp_rp_regdata)
-{
-	tlp_rp_regdata->rp_ctrl = readl(
-		altrpcierp_info.pcie_hip_avmm_cra_base + RP_RXCPL_STATUS);
-	tlp_rp_regdata->rp_reg0 = readl(
-		altrpcierp_info.pcie_hip_avmm_cra_base + RP_RXCPL_REG0);
-	tlp_rp_regdata->rp_reg1 = readl(
-		altrpcierp_info.pcie_hip_avmm_cra_base + RP_RXCPL_REG1);
-}
-
-/* TLP packet TX pair */
-static void tlp_write_rp_tx(struct tlp_rp_regpair_t *tlp_rp_regdata)
-{
-	writel(tlp_rp_regdata->rp_reg0,
-		altrpcierp_info.pcie_hip_avmm_cra_base + RP_TX_REG0);
-	writel(tlp_rp_regdata->rp_reg1,
-		altrpcierp_info.pcie_hip_avmm_cra_base + RP_TX_REG1);
-	writel(tlp_rp_regdata->rp_ctrl,
-		altrpcierp_info.pcie_hip_avmm_cra_base + RP_TX_CNTRL);
-}
-
-/* TLP packet detect SOP and EOP */
-static int tlp_read_packet(u32 *value)
-{
-	int err = 0;
-	u8 loop;
-	struct tlp_rp_regpair_t *tlp_rp_regdata;
-
-	/* allocate tlp_rp_regdata */
-	tlp_rp_regdata = kzalloc(sizeof(struct tlp_rp_regpair_t), GFP_KERNEL);
-	if (!tlp_rp_regdata) {
-		pr_err("altrpcierp out of memory !!!\n");
-		err = -ENOMEM;
-		goto ret_error;
-	}
-
-	/*
-	 * Detect RP_RXCPL_SOP is not require,
-	 * read till EOP to avoid completion packet misalignment.
-	 * Detect RP_RXCPL_EOP with loop of
-	 * TLP_PAYLOAD_SIZE + 1(SOP) + 2(header) + 3(detection loop)
-	 */
-	for (loop = (TLP_PAYLOAD_SIZE+1+2+3); loop > 0; loop--) {
-		tlp_read_rp_rx(tlp_rp_regdata);
-		/* detect EOP */
-		if (tlp_rp_regdata->rp_ctrl & RP_RXCPL_EOP)
-			break;
-	}
-	/* if no EOP detected */
-	if (loop == 0) {
-		err = -ENOENT;
-		goto ret_freemem;
-	}
-
-	/* read data */
-	if (value)
-		*value = tlp_rp_regdata->rp_reg0;
-
-ret_freemem:
-	kfree(tlp_rp_regdata);
-ret_error:
-	return err;
-}
-
-/* pci_ops read using TLP packet receive */
-static int tlp_cfg_dword_read(u8 bus, unsigned int devfn,
-			      int where, u32 *value)
-{
-	struct tlp_rp_regpair_t *tlp_rp_regdata;
-
-	/* if not DWORD align */
-	if ((where & 0x3) != 0) {
-		pr_err("altrpcierp data not DWORD align\n");
-		return PCIBIOS_BAD_REGISTER_NUMBER;
-	}
-
-	/*
-	 * Implement the device number filtering at the lowest level layer.
-	 * Per PCIe spec section 7.3.1 - Configuration Requests
-	 * targeting the Bus Number associated with a Link specifying
-	 * Device Number 0 are delivered to the device attached to the Link;
-	 * Configuration Requests specifying all other Device Numbers (1-31)
-	 * must be terminated by the Switch Downstream Port or the Root Port
-	 * with an Unsupported Request Completion Status.
-	 */
-	if (((bus == rp_pribus) || (bus == rp_secbus)) && ((devfn >> 3) > 0)) {
-		*value = ~0UL;
-		return PCIBIOS_SUCCESSFUL;
-	}
-
-	/* allocate tlp_rp_regdata */
-	tlp_rp_regdata = kzalloc(sizeof(struct tlp_rp_regpair_t), GFP_KERNEL);
-	if (!tlp_rp_regdata) {
-		pr_err("altrpcierp out of memory !!!\n");
-		return -ENOMEM;
-	}
-
-	/* sending TLP packet */
-	if (bus == rp_pribus)
-		tlp_rp_regdata->rp_reg0 = TLP_CFG_DW0(TLP_FMTTYPE_CFGRD0);
-	else
-		tlp_rp_regdata->rp_reg0 = TLP_CFG_DW0(TLP_FMTTYPE_CFGRD1);
-	tlp_rp_regdata->rp_reg1 = TLP_CFG_DW1(
-				  ((rp_pribus << 8) | ALTRPCIERP_DEVFN),
-				  TLP_READ_TAG);
-	tlp_rp_regdata->rp_ctrl = RP_TX_SOP;
-	tlp_write_rp_tx(tlp_rp_regdata);
-	tlp_rp_regdata->rp_reg0 = TLP_CFG_DW2(bus, devfn, where);
-	tlp_rp_regdata->rp_reg1 = 0x0;
-	tlp_rp_regdata->rp_ctrl = RP_TX_EOP;
-	tlp_write_rp_tx(tlp_rp_regdata);
-
-	/* read data from completion package, return 0xFFFFFFFF if error */
-	if (tlp_read_packet(value))
-		*value = ~0UL;
-
-	kfree(tlp_rp_regdata);
-	return PCIBIOS_SUCCESSFUL;
-}
-
-/* pci_ops write using TLP packet send */
-static int tlp_cfg_dword_write(u8 bus, unsigned int devfn,
-			       int where, u32 value)
-{
-	struct tlp_rp_regpair_t *tlp_rp_regdata;
-
-	/* if not DWORD align */
-	if ((where & 0x3) != 0) {
-		pr_err("altrpcierp data not DWORD align\n");
-		return PCIBIOS_BAD_REGISTER_NUMBER;
-	}
-
-	/*
-	 * Implement the device number filtering at the lowest level layer.
-	 * Per PCIe spec section 7.3.1 - Configuration Requests
-	 * targeting the Bus Number associated with a Link specifying
-	 * Device Number 0 are delivered to the device attached to the Link;
-	 * Configuration Requests specifying all other Device Numbers (1-31)
-	 * must be terminated by the Switch Downstream Port or the Root Port
-	 * with an Unsupported Request Completion Status.
-	 */
-	if (((bus == rp_pribus) || (bus == rp_secbus)) && ((devfn >> 3) > 0))
-		return PCIBIOS_SET_FAILED;
-
-	/* allocate tlp_rp_regdata */
-	tlp_rp_regdata = kzalloc(sizeof(struct tlp_rp_regpair_t), GFP_KERNEL);
-	if (!tlp_rp_regdata) {
-		pr_err("altrpcierp out of memory !!!\n");
-		return -ENOMEM;
-	}
-
-	/* sending TLP packet */
-	if (bus == rp_pribus)
-		tlp_rp_regdata->rp_reg0 = TLP_CFG_DW0(TLP_FMTTYPE_CFGWR0);
-	else
-		tlp_rp_regdata->rp_reg0 = TLP_CFG_DW0(TLP_FMTTYPE_CFGWR1);
-	tlp_rp_regdata->rp_reg1 = TLP_CFG_DW1(
-				  ((rp_pribus << 8) | ALTRPCIERP_DEVFN),
-				  TLP_WRITE_TAG);
-	tlp_rp_regdata->rp_ctrl = RP_TX_SOP;
-	tlp_write_rp_tx(tlp_rp_regdata);
-	tlp_rp_regdata->rp_reg0 = TLP_CFG_DW2(bus, devfn, where);
-	tlp_rp_regdata->rp_reg1 = value;
-	tlp_rp_regdata->rp_ctrl = RP_TX_EOP;
-	tlp_write_rp_tx(tlp_rp_regdata);
-
-	/* TLP read response */
-	tlp_read_packet(NULL);
-
-	/* if change altrpcierp bus number, update variable... */
-	if ((bus == rp_pribus) && (devfn == ALTRPCIERP_DEVFN) &&
-	    (where == PCI_PRIMARY_BUS)) {
-		rp_pribus = (u8)(value);
-		rp_secbus = (u8)(value >> 8);
-	}
-
-	kfree(tlp_rp_regdata);
-	return PCIBIOS_SUCCESSFUL;
-}
-
-/* pci_ops read */
-static int altrpcierp_cfg_read(struct pci_bus *bus, unsigned int devfn,
-			       int where, int size, u32 *value)
-{
-	/* if cross DWORD boundary */
-	if (((where & 0x3) + size) > 4) {
-		pr_err("Data cross DWORD boundary\n");
-		return PCIBIOS_BAD_REGISTER_NUMBER;
-	}
-
-	/* TLP read */
-	tlp_cfg_dword_read(bus->number, devfn, (where & ~0x3), value);
-	*value = *value >> ((where & 0x3) << 3);  /* position */
-	*value = *value & (~0UL >> ((4 - size) << 3));  /* mask */
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-/* pci_ops write */
-static int altrpcierp_cfg_write(struct pci_bus *bus, unsigned int devfn,
-				int where, int size, u32 value)
-{
-	u32 data32 = value;
-
-	/* if cross DWORD boundary */
-	if (((where & 0x3) + size) > 4) {
-		pr_err("Data cross DWORD boundary\n");
-		return PCIBIOS_BAD_REGISTER_NUMBER;
-	}
-
-	/* TLP read and merge DWORD */
-	if ((where & 0x3) || (size != 4)) {
-		tlp_cfg_dword_read(bus->number, devfn, where & ~0x3, &data32);
-		data32 = data32 & ~((~0UL >> ((4 - size) << 3))
-				    << ((where & 0x3) << 3));
-		data32 = data32 | (value << ((where & 0x3) << 3));
-	}
-
-	/* TLP write */
-	tlp_cfg_dword_write(bus->number, devfn, (where & ~0x3), data32);
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-/* pci_ops */
-static struct pci_ops altrpcierp_ops = {
-	.read = altrpcierp_cfg_read,
-	.write = altrpcierp_cfg_write,
-};
-
-/* hw_pci setup */
-static int altrpcierp_setup(int nr, struct pci_sys_data *sys)
-{
-	int err;
-	u8  pages;
-	u32 translation_size;
-	struct resource *res;
-
-	/* get translation table size */
-	writel(~0UL,
-		altrpcierp_info.pcie_hip_avmm_cra_base + A2P_ADDR_MAP_LO0);
-	translation_size = (~(readl(
-		altrpcierp_info.pcie_hip_avmm_cra_base + A2P_ADDR_MAP_LO0)
-		& 0xFFFFFFFC)) + 1;
-
-	/* get number of translation table pages */
-	pages = altrpcierp_info.pcie_hip_avmm_txs_size_raw / translation_size;
-
-	/* allocate resource memory */
-	res = kzalloc(sizeof(struct resource) * pages, GFP_KERNEL);
-	if (!res) {
-		pr_err("altrpcierp out of memory !!!\n");
-		err = -ENOMEM;
-		goto ret_error;
-	}
-
-	/* IORESOURCE_MEM use A2P_ADDR_MAP_LO0 */
-	if (pages >= 1) {
-		res[0].name  = "ALTERA PCIE RP MEM";
-		res[0].start = altrpcierp_info.pcie_hip_avmm_txs_base_raw;
-		res[0].end   = res[0].start + translation_size - 1;
-		res[0].flags = IORESOURCE_MEM;
-		if (request_resource(&iomem_resource, &res[0])) {
-			pr_err("altrpcierp out of memory !!!\n");
-			err = -ENOMEM;
-			goto ret_freeres;
-		}
-		pci_add_resource_offset(&sys->resources, &res[0],
-					sys->mem_offset);
-	}
-
-	/* IORESOURCE_MEM | IORESOURCE_PREFETCH */
-	if (pages >= 2) {
-		res[1].name  = "ALTERA PCIE RP PREF MEM";
-		res[1].start = res[0].end + 1;
-		res[1].end   = res[1].start + translation_size - 1;
-		res[1].flags = IORESOURCE_MEM | IORESOURCE_PREFETCH;
-		if (request_resource(&iomem_resource, &res[1])) {
-			pr_err("altrpcierp out of memory !!!\n");
-			err = -ENOMEM;
-			goto ret_relres;
-		}
-		pci_add_resource_offset(&sys->resources, &res[1],
-					sys->mem_offset);
-	}
-
-	/* Configure Avalon-MM-to-PCI Express Address Translation Table */
-	writel(res[0].start,
-		altrpcierp_info.pcie_hip_avmm_cra_base + A2P_ADDR_MAP_LO0);
-	writel(0x0,
-		altrpcierp_info.pcie_hip_avmm_cra_base + A2P_ADDR_MAP_HI0);
-	writel(res[1].start,
-		altrpcierp_info.pcie_hip_avmm_cra_base + A2P_ADDR_MAP_LO0 + 8);
-	writel(0x0,
-		altrpcierp_info.pcie_hip_avmm_cra_base + A2P_ADDR_MAP_HI0 + 8);
-
-	return 1;
-
-ret_relres:
-	release_resource(res);
-ret_freeres:
-	kfree(res);
-ret_error:
-	return err;
-}
-
-/* hw_pci map_irq */
-static int altrpcierp_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
-{
-	return altrpcierp_info.hwirq;
-}
-
-/* hw_pci */
-static struct hw_pci altrpcierp_hw __initdata = {
-#ifdef CONFIG_PCI_DOMAINS
-	.domain			= 0,
-#endif
-	.ops			= &altrpcierp_ops,
-	.nr_controllers		= 1,
-	.setup			= altrpcierp_setup,
-	.map_irq		= altrpcierp_map_irq,
-};
-
-/* RP ISR - clear status */
-static irqreturn_t altrpcierp_isr(int irq, void *arg)
-{
-	__raw_writel(P2A_INT_STS_ALL,
-		altrpcierp_info.pcie_hip_avmm_cra_base + P2A_INT_STATUS);
-	return IRQ_HANDLED;
-}
-
-/* RP device init and resources, based on Device Tree */
-static int altrpcierp_devinit(struct device_node *node)
-{
-	u32 dtdata[2];
-	const u32 *regaddr_p;
-	u64 address64, size64;
-
-	/* read from "reg" */
-	regaddr_p = of_get_address(node, 0, &size64, NULL);
-
-	/* get CRA TXS base and size from DT */
-	if (!of_property_read_u32_array(node, "cra", dtdata, 2)) {
-		/* TXS read from "reg" */
-		if (regaddr_p == NULL) {
-			pr_err("altrpcierp fail to get TXS register\n");
-			return -EIO;
-		}
-		address64 = of_translate_address(node, regaddr_p);
-		altrpcierp_info.pcie_hip_avmm_txs_base_raw = (u32)address64;
-		altrpcierp_info.pcie_hip_avmm_txs_size_raw = (u32)size64;
-		/* CRA read from "cra" */
-		altrpcierp_info.pcie_hip_avmm_cra_base = ioremap_nocache(
-			(phys_addr_t)dtdata[0], (unsigned long)dtdata[1]);
-		if (altrpcierp_info.pcie_hip_avmm_cra_base == NULL) {
-			pr_err("altrpcierp fail to map CRA register\n");
-			return -ENOMEM;
-		}
-	} else {
-		/* TXS read from "txs" */
-		if (!of_property_read_u32_array(node, "txs", dtdata, 2)) {
-			altrpcierp_info.pcie_hip_avmm_txs_base_raw =
-				(u32)dtdata[0];
-			altrpcierp_info.pcie_hip_avmm_txs_size_raw =
-				(u32)dtdata[1];
-		} else {
-			pr_err("altrpcierp fail to get TXS register\n");
-			return -EIO;
-		}
-		/* CRA read from "reg" */
-		if (regaddr_p == NULL) {
-			pr_err("altrpcierp fail to get CRA register\n");
-			return -EIO;
-		}
-		address64 = of_translate_address(node, regaddr_p);
-		altrpcierp_info.pcie_hip_avmm_cra_base = ioremap_nocache(
-			(phys_addr_t)address64, (unsigned long)size64);
-		if (altrpcierp_info.pcie_hip_avmm_cra_base == NULL) {
-			pr_err("altrpcierp fail to map CRA register\n");
-			return -ENOMEM;
-		}
-	}
-
-	/* setup IRQ */
-	altrpcierp_info.hwirq = irq_of_parse_and_map(node, 0);
-	if (request_irq(altrpcierp_info.hwirq, altrpcierp_isr,
-			IRQF_SHARED, "PCIE", &altrpcierp_info))
-		pr_err("altrpcierp failed to register legacy IRQ\n");
-	else
-		set_irq_flags(altrpcierp_info.hwirq, IRQF_VALID);
-
-	/* clear PCIe to AvMM IRQ status */
-	writel(P2A_INT_STS_ALL,
-		altrpcierp_info.pcie_hip_avmm_cra_base + P2A_INT_STATUS);
-	/* enable PCIe to AvMM IRQ */
-	writel(P2A_INT_ENA_ALL,
-		altrpcierp_info.pcie_hip_avmm_cra_base + P2A_INT_ENABLE);
-
-	return 0;
-}
-
-static const struct of_device_id altrpcie_ids[] = {
-	{ .compatible = "ALTR,root-port-13.0", },
-	{ .compatible = "ALTR,pcie-root-port-13.0", },
-	{ .compatible = "altr,pcie-root-port-1.0", },
-	{},
-};
-
-static int __init altrpcie_init(void)
-{
-	struct device_node *node = NULL;
-
-	node = of_find_matching_node(NULL, altrpcie_ids);
-	if (node) {
-		if (altrpcierp_devinit(node))
-			return -ENOMEM;
-		pci_common_init(&altrpcierp_hw);
-	} else {
-		pr_err("altrpcierp failed to find device node\n");
-		return -EIO;
-	}
-
-	return 0;
-}
-subsys_initcall(altrpcie_init);
-- 
1.7.5.4

