From b8f71eaa95d57298723b8036a67f024835741b19 Mon Sep 17 00:00:00 2001
From: Dinh Nguyen <dinguyen@altera.com>
Date: Tue, 16 Oct 2012 11:04:56 -0600
Subject: [PATCH 091/254] mtd: devices: Add support for n25q128 MTD flash
 device

Upstream: git://git.rocketboards.org/linux-socfpga.git

Add entries to the m25p80 flash device to support the n25q128 device.

Signed-off-by: Dinh Nguyen <dinguyen@altera.com>
(cherry picked from commit fcba0962e8baa9bbd8771f9ece46fe963d5b4a3e)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/mtd/devices/m25p80.c |   74 ++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 74 insertions(+), 0 deletions(-)

diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index 91f8de0..dfb98ea 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -41,6 +41,7 @@
 #define	OPCODE_WRSR		0x01	/* Write status register 1 byte */
 #define	OPCODE_NORM_READ	0x03	/* Read data bytes (low frequency) */
 #define	OPCODE_FAST_READ	0x0b	/* Read data bytes (high frequency) */
+#define  OPCODE_FAST_READ_QUAD_OUTPUT   0x6b    /* Read data bytes (quad) */
 #define	OPCODE_PP		0x02	/* Page program (up to 256 bytes) */
 #define	OPCODE_BE_4K		0x20	/* Erase 4KiB block */
 #define	OPCODE_BE_32K		0x52	/* Erase 32KiB block */
@@ -60,6 +61,15 @@
 /* Used for Spansion flashes only. */
 #define	OPCODE_BRWR		0x17	/* Bank register write */
 
+/* Used for Numonyx flashes only */
+#define NUMONYX_ID             0x20
+#define OPCODE_RVCR            0x85    /* Read volatile configuration register */
+#define OPCODE_WVCR            0x81    /* Write volatile configuration register */
+#define VCR_XIP_SHIFT                  0x03
+#define VCR_XIP_MASK                   0x08
+#define VCR_DUMMY_CLK_CYCLES_SHIFT     0x04
+#define VCR_DUMMY_CLK_CYCLES_MASK      0xf0
+
 /* Status Register bits. */
 #define	SR_WIP			1	/* Write in progress */
 #define	SR_WEL			2	/* Write enable latch */
@@ -73,6 +83,17 @@
 #define	MAX_READY_WAIT_JIFFIES	(40 * HZ)	/* M25P16 specs 40s max chip erase */
 #define	MAX_CMD_SIZE		5
 
+#ifdef CONFIG_M25PXX_USE_FAST_READ_QUAD_OUTPUT
+#define OPCODE_READ    OPCODE_FAST_READ_QUAD_OUTPUT
+#define FAST_READ_DUMMY_BYTE 1
+#elif defined CONFIG_M25PXX_USE_FAST_READ
+#define OPCODE_READ 	OPCODE_FAST_READ
+#define FAST_READ_DUMMY_BYTE 1
+#else
+#define OPCODE_READ 	OPCODE_NORM_READ
+#define FAST_READ_DUMMY_BYTE 0
+#endif
+
 #define JEDEC_MFR(_jedec_id)	((_jedec_id) >> 16)
 
 /****************************************************************************/
@@ -565,6 +586,43 @@ time_out:
 	return ret;
 }
 
+/* Numonyx set VCR register */
+#if (defined CONFIG_M25PXX_USE_FAST_READ ||    \
+       defined CONFIG_M25PXX_USE_FAST_READ_QUAD_OUTPUT)
+static int numonyx_set_vcr(struct m25p *flash, unsigned char clk_cycles,
+       unsigned char xip)
+{
+       ssize_t retval;
+       u8 code = OPCODE_RVCR;
+       u8 val;
+
+       write_enable(flash);
+
+       retval = spi_write_then_read(flash->spi, &code, 1, &val, 1);
+
+       if (retval < 0) {
+               dev_err(&flash->spi->dev, "error %d reading SR\n",
+                               (int) retval);
+               return retval;
+       }
+
+       val &= ~VCR_DUMMY_CLK_CYCLES_MASK;
+       val |=  (clk_cycles << VCR_DUMMY_CLK_CYCLES_SHIFT) &
+                       VCR_DUMMY_CLK_CYCLES_MASK;
+
+       if (xip) {
+               val |= VCR_XIP_MASK;
+       } else {
+               val &= ~VCR_XIP_MASK;
+       }
+
+       flash->command[0] = OPCODE_WVCR;
+       flash->command[1] = val;
+
+       return spi_write(flash->spi, flash->command, 2);
+}
+#endif
+
 /****************************************************************************/
 
 /*
@@ -647,6 +705,9 @@ static const struct spi_device_id m25p_ids[] = {
 	{ "320s33b",  INFO(0x898912, 0, 64 * 1024,  64, 0) },
 	{ "640s33b",  INFO(0x898913, 0, 64 * 1024, 128, 0) },
 	{ "n25q064",  INFO(0x20ba17, 0, 64 * 1024, 128, 0) },
+	
+	/* Micron/Numonyx */
+	{ "n25q128",  INFO(0x20ba18, 0, 64 * 1024, 256, 0) },
 
 	/* Macronix */
 	{ "mx25l2005a",  INFO(0xc22012, 0, 64 * 1024,   4, SECT_4K) },
@@ -887,6 +948,17 @@ static int __devinit m25p_probe(struct spi_device *spi)
 		write_sr(flash, 0);
 	}
 
+#if (defined CONFIG_M25PXX_USE_FAST_READ ||            \
+       defined CONFIG_M25PXX_USE_FAST_READ_QUAD_OUTPUT)
+       /* Set VCR register dummy clocks if fast read and quad read is enabled.
+        * Numonyx flash has default 15 dummy clock cycles. Change dummy clock
+        * to 8 clock cycles (byte aligned). */
+       if (JEDEC_MFR(info->jedec_id) == NUMONYX_ID) {
+               /* Multiply 8 to convert dummy bytes to dummy clocks. */
+               numonyx_set_vcr(flash, FAST_READ_DUMMY_BYTE * 8, 0);
+       }
+#endif
+
 	if (data && data->name)
 		flash->mtd.name = data->name;
 	else
@@ -943,6 +1015,8 @@ static int __devinit m25p_probe(struct spi_device *spi)
 			flash->addr_width = 3;
 	}
 
+	spi->addr_width = flash->addr_width;
+
 	dev_info(&spi->dev, "%s (%lld Kbytes)\n", id->name,
 			(long long)flash->mtd.size >> 10);
 
-- 
1.7.5.4

