From 31b11ba02f39fb7d0eddeb7258feba908bf511d8 Mon Sep 17 00:00:00 2001
From: Dinh Nguyen <dinguyen@altera.com>
Date: Wed, 10 Oct 2012 13:09:25 -0500
Subject: [PATCH 049/254] arm: socfpga: Add SMP, sdmmmc platform data, and

Upstream: git://git.rocketboards.org/linux-socfpga.git
 clock entries.

-Add more clock entries to the common clock framework.
-Enable SMP
-Add SD/MMC platform data for SDMMC driver.

Signed-off-by: Dinh Nguyen <dinguyen@altera.com>
(cherry picked from commit 0b4709dc164bd616b959af19cb58a7685fec9ead)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 arch/arm/boot/dts/socfpga.dtsi     |   31 ++++++++
 arch/arm/configs/socfpga_defconfig |    3 +
 arch/arm/mach-socfpga/headsmp.S    |   35 ++++++---
 arch/arm/mach-socfpga/hotplug.c    |   53 +++++++++++++
 arch/arm/mach-socfpga/platsmp.c    |   15 +++-
 arch/arm/mach-socfpga/sdmmc.c      |  151 ++++++++++++++++++++++++++++++++++++
 arch/arm/mach-socfpga/socfpga.c    |    4 +-
 drivers/clk/socfpga/clk.c          |   50 ++++++++++++
 8 files changed, 327 insertions(+), 15 deletions(-)
 create mode 100644 arch/arm/mach-socfpga/hotplug.c
 create mode 100644 arch/arm/mach-socfpga/sdmmc.c

diff --git a/arch/arm/boot/dts/socfpga.dtsi b/arch/arm/boot/dts/socfpga.dtsi
index 19aec42..00b3a76 100644
--- a/arch/arm/boot/dts/socfpga.dtsi
+++ b/arch/arm/boot/dts/socfpga.dtsi
@@ -74,6 +74,11 @@
 			};
 		};
 
+		clkmgr@ffd04000 {
+				compatible = "altr,clk-mgr";
+				reg = <0xffd04000 0x1000>;
+			};
+
 		gmac0: stmmac@ff700000 {
 			compatible = "altr,socfpga-stmmac", "snps,dwmac-3.70a", "snps,dwmac";
 			reg = <0xff700000 0x2000>;
@@ -91,6 +96,32 @@
 			cache-level = <2>;
 		};
 
+		mmc: sdmmc@ff704000 {
+			compatible = "snps,dw-mmc";
+			reg = <0xff704000 0x1000>;
+			interrupts = <0 139 4>;
+			bus-hz = <50000000>; /*50MHz*/
+			num-slots = <1>;
+			bus-width = <8>;
+			fifo-depth = <1024>;
+			voltage-switch = <0>;	/* 0-No support */
+
+			/* First cell: smpl_sel, second cell: drv_sel*/
+			mmc-hs-timing = <7 4>;
+			sdr12-timing = <0 4>;
+			sdr25-timing = <7 3>;
+			};
+
+		rstmgr@ffd05000 {
+				compatible = "altr,rst-mgr";
+				reg = <0xffd05000 0x1000>;
+			};
+		
+		sysmgr@ffd08000 {
+				compatible = "altr,sys-mgr";
+				reg = <0xffd08000 0x4000>;
+			};
+
 		/* Local timer */
 		timer@fffec600 {
 			compatible = "arm,cortex-a9-twd-timer";
diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index 4e1ce21..22c96e7 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -62,6 +62,9 @@ CONFIG_SERIAL_8250_CONSOLE=y
 CONFIG_SERIAL_8250_NR_UARTS=2
 CONFIG_SERIAL_8250_RUNTIME_UARTS=2
 CONFIG_SERIAL_8250_DW=y
+CONFIG_MMC=y
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_IDMAC=y
 # CONFIG_RTC_HCTOSYS is not set
 CONFIG_EXT2_FS=y
 CONFIG_EXT2_FS_XATTR=y
diff --git a/arch/arm/mach-socfpga/headsmp.S b/arch/arm/mach-socfpga/headsmp.S
index f09b128..952a648 100644
--- a/arch/arm/mach-socfpga/headsmp.S
+++ b/arch/arm/mach-socfpga/headsmp.S
@@ -10,16 +10,31 @@
 #include <linux/linkage.h>
 #include <linux/init.h>
 
-	__CPUINIT
-	.arch	armv7-a
+	__INIT
 
-#define CPU1_START_ADDR 	        0xffd08010
-
-ENTRY(secondary_trampoline)
-	movw	r0, #:lower16:CPU1_START_ADDR
-	movt  r0, #:upper16:CPU1_START_ADDR
+/*
+ * Entry point for secondary CPUs.
+ * This provides a "holding pen" into which all secondary cores are held
+ * until we're ready for them to initialise.
+ */
+ENTRY(socfpga_secondary_startup)
+	mrc	p15, 0, r0, c0, c0, 5
+	and	r0, r0, #15
+	adr	r4, 1f
+	ldmia	r4, {r5, r6}
+	sub	r4, r4, r5
+	add	r6, r6, r4
+pen:	ldr	r7, [r6]
+	cmp	r7, r0
+	bne	pen
 
-	ldr	r1, [r0]
-	bx	r1
+	/*
+	 * we've been released from the holding pen: secondary_stack
+	 * should now contain the SVC stack for this core
+	 */
+	b	secondary_startup
 
-ENTRY(secondary_trampoline_end)
+	.align
+1:	.long	.
+	.long	pen_release
+ENDPROC(socfpga_secondary_startup)
diff --git a/arch/arm/mach-socfpga/hotplug.c b/arch/arm/mach-socfpga/hotplug.c
new file mode 100644
index 0000000..e04dcca
--- /dev/null
+++ b/arch/arm/mach-socfpga/hotplug.c
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/errno.h>
+#include <asm/cacheflush.h>
+#include <asm/cp15.h>
+
+static inline void cpu_enter_lowpower(void)
+{
+}
+
+static inline void cpu_leave_lowpower(void)
+{
+}
+
+int platform_cpu_kill(unsigned int cpu)
+{
+	return 1;
+}
+
+/*
+ * platform-specific code to shutdown a CPU
+ *
+ * Called with IRQs disabled
+ */
+void __ref platform_cpu_die(unsigned int cpu)
+{
+	cpu_enter_lowpower();
+
+	cpu_do_idle();
+	cpu_leave_lowpower();
+
+	/* We should never return from idle */
+	panic("cpu %d unexpectedly exit from shutdown\n", cpu);
+}
+
+int platform_cpu_disable(unsigned int cpu)
+{
+	/*
+	 * CPU0 should not be shut down via hotplug.  cpu_idle can WFI
+	 * or a proper shutdown or hibernate should be used.
+	 */
+	return cpu == 0 ? -EPERM : 0;
+}
diff --git a/arch/arm/mach-socfpga/platsmp.c b/arch/arm/mach-socfpga/platsmp.c
index 68dd1b6..69a84d9 100644
--- a/arch/arm/mach-socfpga/platsmp.c
+++ b/arch/arm/mach-socfpga/platsmp.c
@@ -28,12 +28,19 @@
 #include <asm/smp_scu.h>
 #include <asm/smp_plat.h>
 
-#include "core.h"
+volatile int pen_release = -1;
 
-extern void __iomem *sys_manager_base_addr;
-extern void __iomem *rst_manager_base_addr;
+extern void secondary_startup(void);
+extern void __iomem *socfpga_scu_base_addr;
+static void __iomem *sys_manager_base_addr;
+static void __iomem *rst_manager_base_addr;
 
-static void __cpuinit socfpga_secondary_init(unsigned int cpu)
+extern void socfpga_secondary_startup(void);
+extern void socfpga_cpu_die(unsigned int cpu);
+
+static DEFINE_SPINLOCK(boot_lock);
+
+void __cpuinit platform_secondary_init(unsigned int cpu)
 {
 	/*
 	 * if any interrupts are already enabled for the primary
diff --git a/arch/arm/mach-socfpga/sdmmc.c b/arch/arm/mach-socfpga/sdmmc.c
new file mode 100644
index 0000000..bb3a776
--- /dev/null
+++ b/arch/arm/mach-socfpga/sdmmc.c
@@ -0,0 +1,151 @@
+/*
+ *  linux/arch/arm/mach-socfpga5xs1/sdmmc.c
+ *
+ *  Copyright (C) 2011 Altera Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/mmc/dw_mmc.h>
+#include <linux/mmc/host.h>
+#include <linux/dma-mapping.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <asm/errno.h>/* Clock Manager */
+
+#define PWREN		(0x4)
+
+#define mci_writel(base, value, reg)			 \
+	__raw_writel((value), base + reg)
+
+#define mci_readl(base, reg)				\
+	__raw_readl(base + reg)
+
+static void __iomem *sdmmc_base = 0;
+
+static void __iomem* sdmmc_get_base_addr(void)
+{
+	struct device_node *np;
+
+	np = of_find_compatible_node(NULL, NULL, "snps,dw-mmc");
+	if (np) {
+		return of_iomap(np, 0);
+	}
+
+	return NULL;
+}
+
+void sdmmc_setpower(unsigned int slot_id, unsigned int volt)
+{
+	unsigned int power;
+
+	if (sdmmc_base == NULL) {
+		sdmmc_base = sdmmc_get_base_addr();
+		if (!sdmmc_base)
+			return;
+	}
+
+	power = mci_readl(sdmmc_base, PWREN);
+
+	if (volt == 0) {
+		/* turn off */
+		power &= ~(1 << slot_id);
+	}
+	else {
+		/* turn on */
+		power |= (1 << slot_id);
+	}
+
+	mci_writel(sdmmc_base, power, PWREN);
+
+	return;
+}
+
+int sdmmc_get_bus_width(unsigned int slot_id)
+{
+	struct device_node *np;
+	unsigned int bus_width;
+
+	np = of_find_compatible_node(NULL, NULL, "snps,dw-mmc");
+	if (np) {
+		if (!(of_property_read_u32(np, "bus-width", &bus_width)))
+			return bus_width;
+	}
+
+	/* Default 1-bit */
+	return 1;
+}
+
+int sdmmc_get_ocr(unsigned int slot_id)
+{
+	struct device_node *np;
+	unsigned int voltages = MMC_VDD_32_33 | MMC_VDD_33_34;
+	unsigned int vol_switch;
+
+	np = of_find_compatible_node(NULL, NULL, "snps,dw-mmc");
+	if (np) {
+		if (!of_property_read_u32(np, "voltage-switch", &vol_switch) &&
+			vol_switch)
+			voltages |= MMC_VDD_165_195;
+	}
+
+	return voltages;
+}
+
+int sdmmc_init (unsigned int slot_id, irq_handler_t handler, void *p)
+{
+	return 0;
+}
+
+void sdmmc_exit(unsigned int slot_id)
+{
+	if (sdmmc_base) {
+		iounmap(sdmmc_base);
+		sdmmc_base = NULL;
+	}
+	return;
+}
+
+struct dw_mci_board sdmmc_platform_data = {
+	.quirks = 0,				/* Workaround / Quirk flags */
+	.caps = (MMC_CAP_MMC_HIGHSPEED |
+		 MMC_CAP_SD_HIGHSPEED),		/* Capabilities */
+
+	/* delay in ms before detecting cards after interrupt */
+	.detect_delay_ms = 25,
+
+	.init = sdmmc_init,
+	.get_ro = NULL,
+	.get_cd = NULL,
+	.get_ocr = sdmmc_get_ocr,
+	.get_bus_wd = sdmmc_get_bus_width,	/* Get bus width */
+	/*
+	 * Enable power to selected slot and set voltage to desired level.
+	 * Voltage levels are specified using MMC_VDD_xxx defines defined
+	 * in linux/mmc/host.h file.
+	 */
+	.setpower = sdmmc_setpower,
+	.exit = sdmmc_exit,
+	.select_slot = NULL,		/* Nothing to select, we only have one
+					   slot */
+
+	.dma_ops = NULL,		/* support IDMA only */
+	.data = NULL,
+	.blk_settings = NULL, 		/* Use default setting for IDMAC */
+
+};
diff --git a/arch/arm/mach-socfpga/socfpga.c b/arch/arm/mach-socfpga/socfpga.c
index 6732924..be3e6b7 100644
--- a/arch/arm/mach-socfpga/socfpga.c
+++ b/arch/arm/mach-socfpga/socfpga.c
@@ -92,7 +92,9 @@ static void socfpga_cyclone5_restart(char mode, const char *cmd)
 static void __init socfpga_cyclone5_init(void)
 {
 	l2x0_of_init(0, ~0UL);
-	of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
+	of_platform_populate(NULL, of_default_bus_match_table,
+		socfpga_auxdata_lookup, NULL);
+
 	socfpga_init_clocks();
 }
 
diff --git a/drivers/clk/socfpga/clk.c b/drivers/clk/socfpga/clk.c
index 2c855a6..aeaed7f 100644
--- a/drivers/clk/socfpga/clk.c
+++ b/drivers/clk/socfpga/clk.c
@@ -17,6 +17,11 @@
 #include <linux/clk.h>
 #include <linux/clkdev.h>
 #include <linux/clk-provider.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+
+static DEFINE_SPINLOCK(_lock);
 
 #define SOCFPGA_OSC1_CLK	10000000
 #define SOCFPGA_MPU_CLK		800000000
@@ -24,10 +29,47 @@
 #define SOCFPGA_MAIN_NAND_SDMMC_CLK	250000000
 #define SOCFPGA_S2F_USR_CLK		125000000
 
+#define SOCFPGA_MAIN_PLL_CLK		1200000000
+#define SOCFPGA_PER_PLL_CLK		900000000
+#define SOCFPGA_SDRAM_PLL_CLK		800000000
+
+#define CLKMGR_PERPLLGRP_EN	0xA0
+
+#define CLKMGR_QSPI_CLK_EN				11
+#define CLKMGR_NAND_CLK_EN				10
+#define CLKMGR_NAND_X_CLK_EN			9
+#define CLKMGR_SDMMC_CLK_EN			8
+#define CLKMGR_S2FUSR_CLK_EN			7
+#define CLKMGR_GPIO_CLK_EN				6
+#define CLKMGR_CAN1_CLK_EN				5
+#define CLKMGR_CAN0_CLK_EN				4
+#define CLKMGR_SPI_M_CLK_EN			3
+#define CLKMGR_USB_MP_CLK_EN			2
+#define CLKMGR_EMAC1_CLK_EN			1
+#define CLKMGR_EMAC0_CLK_EN			0
+
+void __iomem *clk_mgr_base_addr;
+
 void __init socfpga_init_clocks(void)
 {
 	struct clk *clk;
+	struct device_node *np;
+
+	np = of_find_compatible_node(NULL, NULL, "altr,clk-mgr");
+	clk_mgr_base_addr = of_iomap(np, 0);
 
+	clk = clk_register_fixed_rate(NULL, "main_pll_clk", NULL, CLK_IS_ROOT,
+			SOCFPGA_MAIN_PLL_CLK);
+	clk_register_clkdev(clk, "main_pll_clk", NULL);
+	
+	clk = clk_register_fixed_rate(NULL, "per_pll_clk", NULL, CLK_IS_ROOT,
+			SOCFPGA_PER_PLL_CLK);
+	clk_register_clkdev(clk, "per_pll_clk", NULL);
+	
+	clk = clk_register_fixed_rate(NULL, "sdram_pll_clk", NULL, CLK_IS_ROOT,
+			SOCFPGA_SDRAM_PLL_CLK);
+	clk_register_clkdev(clk, "sdram_pll_clk", NULL);
+	
 	clk = clk_register_fixed_rate(NULL, "osc1_clk", NULL, CLK_IS_ROOT, SOCFPGA_OSC1_CLK);
 	clk_register_clkdev(clk, "osc1_clk", NULL);
 
@@ -48,4 +90,12 @@ void __init socfpga_init_clocks(void)
 
 	clk = clk_register_fixed_rate(NULL, "s2f_usr_clk", NULL, CLK_IS_ROOT, SOCFPGA_S2F_USR_CLK);
 	clk_register_clkdev(clk, "s2f_usr_clk", NULL);
+
+	clk = clk_register_gate(NULL, "mmc_clk", "main_nand_sdmmc_clk", 0, clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
+			CLKMGR_SDMMC_CLK_EN, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "ff704000.sdmmc");
+	
+	clk = clk_register_gate(NULL, "gmac_clk", "per_pll_clk", 0, clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
+			CLKMGR_EMAC0_CLK_EN, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "ff700000.stmmac");
 }
-- 
1.7.5.4

