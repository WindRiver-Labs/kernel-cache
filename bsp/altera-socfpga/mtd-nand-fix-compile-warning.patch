From 55d76e5294f1cd53168ec85ca7f181cbe5b01830 Mon Sep 17 00:00:00 2001
From: Wenlin Kang <wenlin.kang@windriver.com>
Date: Fri, 2 Jun 2017 17:58:45 +0800
Subject: [PATCH] mtd: nand: fix compile warning

Fix the follow compile warning:
/.../drivers/mtd/nand/nand_base.c: In function 'nand_unlock':
/.../drivers/mtd/nand/nand_base.c:1031:1: warning: control reaches end of non-void function [-Wreturn-type]
 {}
 ^

This issue was introduced by commit 8de9a7582dfc(mtd: nand: avoid calling
nand_unlock() for nandsim on socfpga platform), it fixed the follow error
that was introduced by commit fbba09808aae(FogBugz #163905: Support Denali
NAND driver on socfpga platform).

root@cyclone5:~# ubiformat /dev/mtd0 -y
ubiformat: mtd0 (nand), size 134217728 bytes (128.0 MiB), 8192 eraseblocks of 16384 bytes (16.0 KiB), min. I/O size 512 bytes
libscan: scanning eraseblock 813[nandsim] error: write_byte: unknown command 0x23
libscan: scanning eraseblock 8171 -- 99 % co[nandsim] error: write_byte: address (0x0) isn't expected, expected state is STATE_READY, switch to STATE_READY
libscan: scan[nandsim] error: write_byte: unknown command 0x24

Signed-off-by: Wenlin Kang <wenlin.kang@windriver.com>
---
 drivers/mtd/nand/nand_base.c |   11 ++++++-----
 1 files changed, 6 insertions(+), 5 deletions(-)

diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c
index c907f3a..adffe6d 100644
--- a/drivers/mtd/nand/nand_base.c
+++ b/drivers/mtd/nand/nand_base.c
@@ -977,7 +977,6 @@ static int __nand_unlock(struct mtd_info *mtd, loff_t ofs,
  *
  * Returns unlock status.
  */
-#ifdef CONFIG_MTD_NAND_DENALI
 int nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 {
 	int ret = 0;
@@ -1026,10 +1025,6 @@ out:
 
 	return ret;
 }
-#else
-int nand_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
-{}
-#endif
 EXPORT_SYMBOL(nand_unlock);
 
 /**
@@ -2559,7 +2554,9 @@ static int nand_write(struct mtd_info *mtd, loff_t to, size_t len,
 	struct mtd_oob_ops ops;
 	int ret;
 
+#ifdef CONFIG_MTD_NAND_DENALI
 	nand_unlock(mtd, to, len);
+#endif
 
 	nand_get_device(mtd, FL_WRITING);
 	memset(&ops, 0, sizeof(ops));
@@ -2678,7 +2675,9 @@ static int nand_write_oob(struct mtd_info *mtd, loff_t to,
 		return -EINVAL;
 	}
 
+#ifdef CONFIG_MTD_NAND_DENALI
 	nand_unlock(mtd, to, ops->len);
+#endif
 
 	nand_get_device(mtd, FL_WRITING);
 
@@ -2753,7 +2752,9 @@ int nand_erase_nand(struct mtd_info *mtd, struct erase_info *instr,
 	if (check_offs_len(mtd, instr->addr, instr->len))
 		return -EINVAL;
 
+#ifdef CONFIG_MTD_NAND_DENALI
 	nand_unlock(mtd, instr->addr, instr->len);
+#endif
 
 	/* Grab the lock and see if the device is available */
 	nand_get_device(mtd, FL_ERASING);
-- 
1.7.5.4

