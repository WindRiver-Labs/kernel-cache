From eea17b9f16e37aadffcb8e53fcaed7bdf6046586 Mon Sep 17 00:00:00 2001
From: Alan Tull <atull@altera.com>
Date: Thu, 24 Oct 2013 17:17:59 -0500
Subject: [PATCH 217/248] FogBugz #99945-1: Remove gpio-dw driver

To support the DesignWare gpio with interrupts, we are moving to
the upstreamed gpio-dwapb driver.

[Original patch taken from
git://git.rocketboards.org/linux-socfpga.git socfpga-3.14]

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
Signed-off-by: Alan Tull <atull@altera.com>
---
 arch/arm/boot/dts/socfpga.dtsi     |  39 -------
 arch/arm/configs/socfpga_defconfig |   1 -
 drivers/gpio/Kconfig               |   9 --
 drivers/gpio/Makefile              |   1 -
 drivers/gpio/gpio-dw.c             | 217 -------------------------------------
 5 files changed, 267 deletions(-)
 delete mode 100644 drivers/gpio/gpio-dw.c

diff --git a/arch/arm/boot/dts/socfpga.dtsi b/arch/arm/boot/dts/socfpga.dtsi
index 063b5fd..51194d0 100644
--- a/arch/arm/boot/dts/socfpga.dtsi
+++ b/arch/arm/boot/dts/socfpga.dtsi
@@ -516,45 +516,6 @@
 			status = "disabled";
 		};
 
-		gpio0: gpio@ff708000 {
-			compatible = "snps,dw-gpio";
-			reg = <0xff708000 0x1000>;
-			interrupts = <0 164 4>;
-			width = <29>;
-			virtual_irq_start = <257>;
-			interrupt-controller;
-			#interrupt-cells = <2>;
-			gpio-controller;
-			#gpio-cells = <2>;
-			clocks = <&per_base_clk>;
-		};
-
-		gpio1: gpio@ff709000 {
-			compatible = "snps,dw-gpio";
-			reg = <0xff709000 0x1000>;
-			interrupts = <0 165 4>;
-			width = <29>;
-			virtual_irq_start = <286>;
-			interrupt-controller;
-			#interrupt-cells = <2>;
-			gpio-controller;
-			#gpio-cells = <2>;
-			clocks = <&per_base_clk>;
-		};
-
-		gpio2: gpio@ff70a000 {
-			compatible = "snps,dw-gpio";
-			reg = <0xff70a000 0x1000>;
-			interrupts = <0 166 4>;
-			width = <27>;
-			virtual_irq_start = <315>;
-			interrupt-controller;
-			#interrupt-cells = <2>;
-			gpio-controller;
-			#gpio-cells = <2>;
-			clocks = <&per_base_clk>;
-		};
-
 		hps_0_fpgamgr: fpgamgr@0xff706000 {
 			compatible = "altr,fpga-mgr-1.0", "altr,fpga-mgr";
 			transport = "mmio";
diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index 8629cfd..1aea1ed 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -104,7 +104,6 @@ CONFIG_SPI_DW_MMIO=y
 CONFIG_SPI_SPIDEV=y
 CONFIG_GPIOLIB=y
 CONFIG_GPIO_SYSFS=y
-CONFIG_GPIO_DW=y
 CONFIG_GPIO_ALTERA=m
 # CONFIG_RTC_HCTOSYS is not set
 CONFIG_WATCHDOG=y
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index 9d88acc..8d583fb 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -134,15 +134,6 @@ config GPIO_ALTERA
        help
          Say yes here to support the Altera PIO device.
 
-config GPIO_DW
-	tristate "Synopsys DesignWare GPIO driver"
-	select GPIO_GENERIC
-	select GENERIC_IRQ_CHIP
-	depends on OF_GPIO
-	help
-	  Say Y or M here to build support for the Synopsys DesignWare APB
-	  GPIO block.  This requires device tree support.
-
 config GPIO_IT8761E
 	tristate "IT8761E GPIO support"
 	depends on X86  # unconditional access to IO space.
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 3e67d33..88374d2 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -10,7 +10,6 @@ obj-$(CONFIG_GPIO_ACPI)		+= gpiolib-acpi.o
 # Device drivers. Generally keep list sorted alphabetically
 obj-$(CONFIG_GPIO_GENERIC)	+= gpio-generic.o
 
-obj-$(CONFIG_GPIO_DW)		+= gpio-dw.o
 obj-$(CONFIG_GPIO_74X164)	+= gpio-74x164.o
 obj-$(CONFIG_GPIO_ADNP)		+= gpio-adnp.o
 obj-$(CONFIG_GPIO_ADP5520)	+= gpio-adp5520.o
diff --git a/drivers/gpio/gpio-dw.c b/drivers/gpio/gpio-dw.c
deleted file mode 100644
index c87d57a..0000000
--- a/drivers/gpio/gpio-dw.c
+++ /dev/null
@@ -1,217 +0,0 @@
-/*
- * Designware GPIO support functions
- *
- * Copyright (C) 2012 Altera
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <linux/gpio.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/io.h>
-#include <linux/irq.h>
-#include <linux/irqdomain.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/platform_data/gpio-dw.h>
-#include <linux/of_gpio.h>
-#include <linux/slab.h>
-#include <linux/of_platform.h>
-
-#define GPIO_INT_EN_REG_OFFSET 		(0x30)
-#define GPIO_INT_MASK_REG_OFFSET 	(0x34)
-#define GPIO_INT_TYPE_LEVEL_REG_OFFSET 	(0x38)
-#define GPIO_INT_POLARITY_REG_OFFSET 	(0x3c)
-#define GPIO_INT_STATUS_REG_OFFSET 	(0x40)
-#define GPIO_PORT_A_EOI_REG_OFFSET 	(0x4c)
-
-#define GPIO_DDR_OFFSET_PORT	 	(0x4)
-#define DW_GPIO_EXT 			(0x50)
-#define DW_GPIO_DR 			(0x0)
-#define DRV_NAME "dw gpio"
-
-struct dw_gpio_instance {
-	struct of_mm_gpio_chip mmchip;
-	u32 gpio_state;		/* GPIO state shadow register */
-	u32 gpio_dir;		/* GPIO direction shadow register */
-	int irq;		/* GPIO controller IRQ number */
-	int irq_base;		/* base number for the "virtual" GPIO IRQs */
-	u32 irq_mask;		/* IRQ mask */
-	spinlock_t gpio_lock;	/* Lock used for synchronization */
-};
-
-static int dw_gpio_get(struct gpio_chip *gc, unsigned offset)
-{
-	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
-
-	return (__raw_readl(mm_gc->regs + DW_GPIO_EXT) >> offset) & 1;
-}
-
-static void dw_gpio_set(struct gpio_chip *gc, unsigned offset, int value)
-{
-	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
-	struct dw_gpio_instance *chip = container_of(mm_gc, struct dw_gpio_instance, mmchip);
-	unsigned long flags;
-	u32 data_reg;
-
-	spin_lock_irqsave(&chip->gpio_lock, flags);
-	data_reg = __raw_readl(mm_gc->regs + DW_GPIO_DR);
-	data_reg = (data_reg & ~(1<<offset)) | (value << offset);
-	__raw_writel(data_reg, mm_gc->regs + DW_GPIO_DR);
-	spin_unlock_irqrestore(&chip->gpio_lock, flags);
-}
-
-static int dw_gpio_direction_input(struct gpio_chip *gc, unsigned offset)
-{
-	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
-	struct dw_gpio_instance *chip = container_of(mm_gc, struct dw_gpio_instance, mmchip);
-	unsigned long flags;
-	u32 gpio_ddr;
-
-	spin_lock_irqsave(&chip->gpio_lock, flags);
-	/* Set pin as input, assumes software controlled IP */
-	gpio_ddr = __raw_readl(mm_gc->regs + GPIO_DDR_OFFSET_PORT);
-	gpio_ddr &= ~(1 << offset);
-	__raw_writel(gpio_ddr, mm_gc->regs + GPIO_DDR_OFFSET_PORT);
-	spin_unlock_irqrestore(&chip->gpio_lock, flags);
-
-	return 0;
-}
-
-static int dw_gpio_direction_output(struct gpio_chip *gc,
-		unsigned offset, int value)
-{
-	struct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);
-	struct dw_gpio_instance *chip = container_of(mm_gc, struct dw_gpio_instance, mmchip);
-	unsigned long flags;
-	u32 gpio_ddr;
-
-	dw_gpio_set(gc, offset, value);
-	
-	spin_lock_irqsave(&chip->gpio_lock, flags);
-	/* Set pin as output, assumes software controlled IP */
-	gpio_ddr = __raw_readl(mm_gc->regs + GPIO_DDR_OFFSET_PORT);
-	gpio_ddr |= (1 << offset);
-	__raw_writel(gpio_ddr, mm_gc->regs + GPIO_DDR_OFFSET_PORT);
-	spin_unlock_irqrestore(&chip->gpio_lock, flags);
-	return 0;
-}
-
-/* 
- * dw_gpio_probe - Probe method for the GPIO device.
- * @np: pointer to device tree node
- *
- * This function probes the GPIO device in the device tree. It initializes the
- * driver data structure. It returns 0, if the driver is bound to the GPIO
- * device, or a negative value if there is an error.
- */
-static int dw_gpio_probe(struct platform_device *pdev)
-{
-	struct device_node *np = pdev->dev.of_node;
-	struct dw_gpio_instance *chip;
-	int status = 0;
-	u32 reg;
-
-	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
-	if (!chip)
-	{
-		printk(KERN_ERR "%s 2 ERROR allocating memory", __func__);
-		return -ENOMEM;
-	}
-
-	/* Update GPIO state shadow register with default value */
-	if (of_property_read_u32(np, "resetvalue", &reg) == 0)
-		chip->gpio_state = reg;
-
-	/* Update GPIO direction shadow register with default value */
-	chip->gpio_dir = 0; /* By default, all pins are inputs */
-
-	/* Check device node for device width */
-	if (of_property_read_u32(np, "width", &reg) == 0)
-		chip->mmchip.gc.ngpio = reg;
-	else
-		chip->mmchip.gc.ngpio = 32; /* By default assume full GPIO controller */
-
-	spin_lock_init(&chip->gpio_lock);
-
-	chip->mmchip.gc.direction_input = dw_gpio_direction_input;
-	chip->mmchip.gc.direction_output = dw_gpio_direction_output;
-	chip->mmchip.gc.get = dw_gpio_get;
-	chip->mmchip.gc.set = dw_gpio_set;
-
-	/* Call the OF gpio helper to setup and register the GPIO device */
-	status = of_mm_gpiochip_add(np, &chip->mmchip);
-	if (status) {
-		kfree(chip);
-		pr_err("%s: error in probe function with status %d\n",
-		       np->full_name, status);
-		return status;
-	}
-
-	platform_set_drvdata(pdev, chip);
-	return 0;
-}
-
-static int dw_gpio_remove(struct platform_device *pdev)
-{
-	/* todo check this and see that we don't have a memory leak */
-	int status;
-	
-	struct dw_gpio_instance *chip = platform_get_drvdata(pdev);
-	status = gpiochip_remove(&chip->mmchip.gc);
-	if (status < 0)
-		return status;
-	
-	kfree(chip);
-	return -EIO;
-}
-
-#ifdef CONFIG_OF
-static const struct of_device_id dwgpio_match[] = {
-	{.compatible = DW_GPIO_COMPATIBLE,},
-	{}
-};
-MODULE_DEVICE_TABLE(of, dwgpio_match);
-#else
-#define dwgpio_match NULL
-#endif
-
-static struct platform_driver dwgpio_driver = {
-	.driver = {
-		.name	= "dw_gpio",
-		.owner	= THIS_MODULE,
-		.of_match_table = of_match_ptr(dwgpio_match),
-	},
-	.probe		= dw_gpio_probe,
-	.remove		= dw_gpio_remove,
-};
-
-static int __init dwgpio_init(void)
-{
-	return platform_driver_register(&dwgpio_driver);
-}
-subsys_initcall(dwgpio_init);
-
-static void __exit dwgpio_exit(void)
-{
-	platform_driver_unregister(&dwgpio_driver);
-}
-module_exit(dwgpio_exit);
-
-
-MODULE_DESCRIPTION("Altera GPIO driver");
-MODULE_AUTHOR("Thomas Chou <thomas@wytron.com.tw>");
-MODULE_LICENSE("GPL");
-MODULE_ALIAS("platform:" DRV_NAME);
-- 
1.9.1

