From d4f48026306be9b04d1b5c224dd1bee993f849ba Mon Sep 17 00:00:00 2001
From: Ley Foon Tan <lftan@altera.com>
Date: Wed, 24 Jul 2013 20:15:49 +0800
Subject: [PATCH 115/248] FogBugz #138164: Add Altera mailbox driver

Altera mailbox specific driver that uses the mailbox
common framework.

v2:
- Updated documentation to include mailbox client node.
- Checked NULL pointer
- Read PTR register first.
- Changed full and pending functions to inline.
- Used macro for Pending and full mask/offset.

[Original patch taken from
git://git.rocketboards.org/linux-socfpga.git socfpga-3.14]

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
Signed-off-by: Ley Foon Tan <lftan@altera.com>
---
 .../devicetree/bindings/mailbox/mailbox-altera.txt |  30 ++
 drivers/mailbox/Kconfig                            |   7 +
 drivers/mailbox/Makefile                           |   1 +
 drivers/mailbox/mailbox-altera.c                   | 411 +++++++++++++++++++++
 drivers/mailbox/mailbox.c                          |   7 +-
 5 files changed, 454 insertions(+), 2 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/mailbox/mailbox-altera.txt
 create mode 100644 drivers/mailbox/mailbox-altera.c

diff --git a/Documentation/devicetree/bindings/mailbox/mailbox-altera.txt b/Documentation/devicetree/bindings/mailbox/mailbox-altera.txt
new file mode 100644
index 0000000..dbfcfb6
--- /dev/null
+++ b/Documentation/devicetree/bindings/mailbox/mailbox-altera.txt
@@ -0,0 +1,30 @@
+Altera mailbox (simple) soft IP
+
+Required properties:
+- compatible : "altr,mailbox-1.0".
+- reg : physical base address of the mailbox and length of memory mapped
+     region.
+
+Optional properties:
+- interrupt-parent : interrupt source phandle.
+- interrupts : interrupt number. The interrupt specifier format depends on the
+	       interrupt controller parent.
+
+The name of mailbox device node must be unique. This name will be used as
+controller name in driver to identify the controller and the mailbox client will
+use this name when requesting a mailbox channel.
+
+Example:
+	mailbox0: mailbox0@0x100 {
+		compatible = "altr,mailbox-1.0";
+		reg = <0x100 0x8>;
+		interrupt-parent = < &gic_0 >;
+		interrupts = <5>;
+	};
+
+Example of mailbox's client node that includes mailbox phandle.
+	mclient0: mclient0@0x200 {
+		compatible = "client-1.0";
+		reg = <0x200 0x10>;
+		mailbox = <&mailbox0>;
+	};
diff --git a/drivers/mailbox/Kconfig b/drivers/mailbox/Kconfig
index c8b5c13..88544dc 100644
--- a/drivers/mailbox/Kconfig
+++ b/drivers/mailbox/Kconfig
@@ -50,4 +50,11 @@ config OMAP_MBOX_KFIFO_SIZE
 	  Specify the default size of mailbox's kfifo buffers (bytes).
 	  This can also be changed at runtime (via the mbox_kfifo_size
 	  module parameter).
+
+config ALTERA_MBOX
+	tristate "Altera Mailbox"
+	help
+	  An implementation of the Altera Mailbox (simple) soft core. Is is used
+	  to send message between processors. Say Y here if you want to use the
+	  Altera mailbox support.
 endif
diff --git a/drivers/mailbox/Makefile b/drivers/mailbox/Makefile
index 2fa343a..c8f7039 100644
--- a/drivers/mailbox/Makefile
+++ b/drivers/mailbox/Makefile
@@ -9,3 +9,4 @@ obj-$(CONFIG_OMAP1_MBOX)	+= mailbox_omap1.o
 mailbox_omap1-objs		:= mailbox-omap1.o
 obj-$(CONFIG_OMAP2PLUS_MBOX)	+= mailbox_omap2.o
 mailbox_omap2-objs		:= mailbox-omap2.o
+obj-$(CONFIG_ALTERA_MBOX)	+= mailbox-altera.o
diff --git a/drivers/mailbox/mailbox-altera.c b/drivers/mailbox/mailbox-altera.c
new file mode 100644
index 0000000..b23113c
--- /dev/null
+++ b/drivers/mailbox/mailbox-altera.c
@@ -0,0 +1,411 @@
+/*
+ * Copyright Altera Corporation (C) 2013. All rights reserved
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program.  If not, see <http://www.gnu.org/licenses/>.
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/mailbox_controller.h>
+
+#define MAILBOX_CMD_REG			0x00
+#define MAILBOX_PTR_REG			0x04
+#define MAILBOX_STS_REG			0x08
+#define MAILBOX_INTMASK_REG		0x0C
+
+#define INT_PENDING_MSK			0x1
+#define INT_SPACE_MSK			0x2
+
+#define STS_PENDING_MSK			0x1
+#define STS_FULL_MSK			0x2
+#define STS_FULL_OFT			0x1
+
+#define MBOX_PENDING(status)	(((status) & STS_PENDING_MSK))
+#define MBOX_FULL(status)	(((status) & STS_FULL_MSK) >> STS_FULL_OFT)
+
+enum altera_mbox_msg {
+	MBOX_CMD = 0,
+	MBOX_PTR,
+};
+
+#define MBOX_POLLING_MS		1	/* polling interval 1ms */
+
+struct altera_mbox {
+	bool is_sender;		/* 1-sender, 0-receiver */
+	bool intr_mode;
+	int irq;
+	int use_count;
+	void __iomem *mbox_base;
+	struct device *dev;
+	struct ipc_link link;
+	struct ipc_controller ipc_con;
+	struct mutex lock;
+	/* If the controller supports only RX polling mode */
+	struct timer_list rxpoll_timer;
+};
+
+static inline struct altera_mbox *to_altera_mbox(struct ipc_link *link)
+{
+	if (!link)
+		return NULL;
+
+	return container_of(link, struct altera_mbox, link);
+}
+
+static inline int altera_mbox_full(struct altera_mbox *mbox)
+{
+	u32 status;
+	status = __raw_readl(mbox->mbox_base + MAILBOX_STS_REG);
+	return MBOX_FULL(status);
+}
+
+static inline int altera_mbox_pending(struct altera_mbox *mbox)
+{
+	u32 status;
+	status = __raw_readl(mbox->mbox_base + MAILBOX_STS_REG);
+	return MBOX_PENDING(status);
+}
+
+static void altera_mbox_rx_intmask(struct altera_mbox *mbox, bool enable)
+{
+	u32 mask;
+	mask = __raw_readl(mbox->mbox_base + MAILBOX_INTMASK_REG);
+	if (enable)
+		mask |= INT_PENDING_MSK;
+	else
+		mask &= ~INT_PENDING_MSK;
+	__raw_writel(mask, mbox->mbox_base + MAILBOX_INTMASK_REG);
+}
+
+static void altera_mbox_tx_intmask(struct altera_mbox *mbox, bool enable)
+{
+	u32 mask;
+	mask = __raw_readl(mbox->mbox_base + MAILBOX_INTMASK_REG);
+	if (enable)
+		mask |= INT_SPACE_MSK;
+	else
+		mask &= ~INT_SPACE_MSK;
+	__raw_writel(mask, mbox->mbox_base + MAILBOX_INTMASK_REG);
+}
+
+static bool altera_mbox_is_sender(struct altera_mbox *mbox)
+{
+	u32 reg;
+	/* Write a magic number to PTR register and read back this register.
+	 * This register is read-write if it is a sender.
+	 */
+	#define MBOX_MAGIC	0xA5A5AA55
+	__raw_writel(MBOX_MAGIC, mbox->mbox_base + MAILBOX_PTR_REG);
+	reg = __raw_readl(mbox->mbox_base + MAILBOX_PTR_REG);
+	if (reg == MBOX_MAGIC) {
+		/* Clear to 0 */
+		__raw_writel(0, mbox->mbox_base + MAILBOX_PTR_REG);
+		return true;
+	}
+	return false;
+}
+
+static void altera_mbox_rx_data(struct ipc_link *link)
+{
+	struct altera_mbox *mbox = to_altera_mbox(link);
+	u32 data[2];
+
+	if (altera_mbox_pending(mbox)) {
+		data[MBOX_PTR] = __raw_readl(mbox->mbox_base + MAILBOX_PTR_REG);
+		data[MBOX_CMD] = __raw_readl(mbox->mbox_base + MAILBOX_CMD_REG);
+		ipc_link_received_data(link, (void *)data);
+	}
+
+	return;
+}
+
+static void altera_mbox_poll_rx(unsigned long data)
+{
+	struct ipc_link *link = (struct ipc_link *)data;
+	struct altera_mbox *mbox = to_altera_mbox(link);
+
+	altera_mbox_rx_data(link);
+
+	mod_timer(&mbox->rxpoll_timer,
+		jiffies + msecs_to_jiffies(MBOX_POLLING_MS));
+}
+
+static irqreturn_t altera_mbox_tx_interrupt(int irq, void *p)
+{
+	struct ipc_link *link = (struct ipc_link *)p;
+	struct altera_mbox *mbox = to_altera_mbox(link);
+
+	altera_mbox_tx_intmask(mbox, false);
+	ipc_link_txdone(link, XFER_OK);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t altera_mbox_rx_interrupt(int irq, void *p)
+{
+	struct ipc_link *link = (struct ipc_link *)p;
+	altera_mbox_rx_data(link);
+	return IRQ_HANDLED;
+}
+
+static int altera_mbox_startup_sender(struct ipc_link *link)
+{
+	int ret;
+	struct altera_mbox *mbox = to_altera_mbox(link);
+
+	if (mbox->intr_mode) {
+		ret = request_irq(mbox->irq, altera_mbox_tx_interrupt, 0,
+			mbox->ipc_con.controller_name, link);
+		if (ret) {
+			dev_err(mbox->dev,
+				"failed to register mailbox interrupt:%d\n",
+				ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int altera_mbox_startup_receiver(struct ipc_link *link)
+{
+	int ret;
+	struct altera_mbox *mbox = to_altera_mbox(link);
+
+	if (mbox->intr_mode) {
+		ret = request_irq(mbox->irq, altera_mbox_rx_interrupt, 0,
+			mbox->ipc_con.controller_name, link);
+		if (ret) {
+			dev_err(mbox->dev,
+				"failed to register mailbox interrupt:%d\n",
+				ret);
+			return ret;
+		}
+		altera_mbox_rx_intmask(mbox, true);
+	} else {
+		/* Setup polling timer */
+		setup_timer(&mbox->rxpoll_timer, altera_mbox_poll_rx,
+			(unsigned long)link);
+		mod_timer(&mbox->rxpoll_timer,
+			jiffies + msecs_to_jiffies(MBOX_POLLING_MS));
+	}
+
+	return 0;
+}
+
+static int altera_mbox_send_data(struct ipc_link *link, void *data)
+{
+	struct altera_mbox *mbox = to_altera_mbox(link);
+	u32 *udata = (u32 *)data;
+
+	if (!mbox || !data)
+		return -EINVAL;
+	if (!mbox->is_sender) {
+		dev_warn(mbox->dev,
+				"failed to send. This is receiver mailbox.\n");
+		return -EINVAL;
+	}
+
+	if (altera_mbox_full(mbox))
+		return -EBUSY;
+
+	/* Enable interrupt before send */
+	altera_mbox_tx_intmask(mbox, true);
+
+	/* Pointer register must write before command register */
+	__raw_writel(udata[MBOX_PTR], mbox->mbox_base + MAILBOX_PTR_REG);
+	__raw_writel(udata[MBOX_CMD], mbox->mbox_base + MAILBOX_CMD_REG);
+
+	return 0;
+}
+
+static bool altera_mbox_is_ready(struct ipc_link *link)
+{
+	struct altera_mbox *mbox = to_altera_mbox(link);
+
+	if (WARN_ON(!mbox))
+		return false;
+
+	/* Return false if mailbox is full */
+	return altera_mbox_full(mbox) ? false : true;
+}
+
+static int altera_mbox_startup(struct ipc_link *link, void *ignored)
+{
+	struct altera_mbox *mbox = to_altera_mbox(link);
+	int ret = 0;
+
+	if (!mbox)
+		return -EINVAL;
+
+	mutex_lock(&mbox->lock);
+	if (!mbox->use_count) {
+		if (mbox->is_sender)
+			ret = altera_mbox_startup_sender(link);
+		else
+			ret = altera_mbox_startup_receiver(link);
+
+		if (!ret)
+			mbox->use_count++;
+	}
+	mutex_unlock(&mbox->lock);
+	return ret;
+}
+
+static void altera_mbox_shutdown(struct ipc_link *link)
+{
+	struct altera_mbox *mbox = to_altera_mbox(link);
+
+	if (WARN_ON(!mbox))
+		return;
+
+	mutex_lock(&mbox->lock);
+	if (!--mbox->use_count) {
+		if (mbox->intr_mode) {
+			/* Unmask all interrupt masks */
+			__raw_writel(~0, mbox->mbox_base + MAILBOX_INTMASK_REG);
+			free_irq(mbox->irq, link);
+		} else if (!mbox->is_sender)
+			del_timer_sync(&mbox->rxpoll_timer);
+	}
+	mutex_unlock(&mbox->lock);
+}
+
+static struct ipc_link_ops altera_mbox_ops = {
+	.send_data = altera_mbox_send_data,
+	.startup = altera_mbox_startup,
+	.shutdown = altera_mbox_shutdown,
+	.is_ready = altera_mbox_is_ready,
+};
+
+static int altera_mbox_probe(struct platform_device *pdev)
+{
+	struct altera_mbox *mbox;
+	struct ipc_link *links[2] = {NULL, NULL};
+	struct resource	*regs;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	mbox = devm_kzalloc(&pdev->dev, sizeof(struct altera_mbox),
+		GFP_KERNEL);
+	if (!mbox)
+		return -ENOMEM;
+
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!regs)
+		return -ENXIO;
+
+	mbox->mbox_base = devm_request_and_ioremap(&pdev->dev, regs);
+	if (!mbox->mbox_base)
+		return -EADDRNOTAVAIL;
+
+	mbox->dev = &pdev->dev;
+	mutex_init(&mbox->lock);
+
+	/* Check is it a sender or receiver? */
+	mbox->is_sender = altera_mbox_is_sender(mbox);
+
+	mbox->irq = platform_get_irq(pdev, 0);
+	if (mbox->irq >= 0)
+		mbox->intr_mode = true;
+
+	/* Hardware supports only one channel, link_name always set to "0". */
+	snprintf(mbox->link.link_name, sizeof(mbox->link.link_name), "0");
+	links[0] = &mbox->link;
+	mbox->ipc_con.links = links;
+	mbox->ipc_con.ops = &altera_mbox_ops;
+
+	if ((strlen(np->name) + 1) > sizeof(mbox->ipc_con.controller_name))
+		dev_warn(&pdev->dev, "Length of mailbox controller name is greater than %d\n",
+		sizeof(mbox->ipc_con.controller_name));
+
+	snprintf(mbox->ipc_con.controller_name,
+		sizeof(mbox->ipc_con.controller_name), "%s", np->name);
+
+	dev_info(&pdev->dev, "Mailbox controller name is %s\n",
+		mbox->ipc_con.controller_name);
+
+	if (mbox->is_sender) {
+		if (mbox->intr_mode)
+			mbox->ipc_con.txdone_irq = true;
+		else {
+			mbox->ipc_con.txdone_poll = true;
+			mbox->ipc_con.txpoll_period = MBOX_POLLING_MS;
+		}
+	}
+
+	ret = ipc_links_register(&mbox->ipc_con);
+	if (ret) {
+		dev_err(&pdev->dev, "Register mailbox failed\n");
+		goto err;
+	}
+
+	platform_set_drvdata(pdev, mbox);
+	return 0;
+err:
+	return ret;
+}
+
+static int altera_mbox_remove(struct platform_device *pdev)
+{
+	struct altera_mbox *mbox = platform_get_drvdata(pdev);
+	if (!mbox)
+		return -EINVAL;
+
+	ipc_links_unregister(&mbox->ipc_con);
+
+	platform_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+static const struct of_device_id altera_mbox_match[] = {
+	{ .compatible = "altr,mailbox-1.0" },
+	{ /* Sentinel */ }
+};
+
+MODULE_DEVICE_TABLE(of, altera_mbox_match);
+
+static struct platform_driver altera_mbox_driver = {
+	.probe	= altera_mbox_probe,
+	.remove	= altera_mbox_remove,
+	.driver	= {
+		.name	= "altera-mailbox",
+		.owner	= THIS_MODULE,
+		.of_match_table	= altera_mbox_match,
+	},
+};
+
+static int altera_mbox_init(void)
+{
+	return platform_driver_register(&altera_mbox_driver);
+}
+
+static void altera_mbox_exit(void)
+{
+	platform_driver_unregister(&altera_mbox_driver);
+}
+
+module_init(altera_mbox_init);
+module_exit(altera_mbox_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Altera mailbox specific functions");
+MODULE_AUTHOR("Ley Foon Tan <lftan@altera.com>");
+MODULE_ALIAS("platform:altera-mailbox");
diff --git a/drivers/mailbox/mailbox.c b/drivers/mailbox/mailbox.c
index c4ef608..0888be5 100644
--- a/drivers/mailbox/mailbox.c
+++ b/drivers/mailbox/mailbox.c
@@ -198,6 +198,9 @@ request_token_t ipc_send_message(void *channel, void *mssg)
 	if (!chan || !chan->assigned)
 		return 0;
 
+	if (chan->tx_block)
+		init_completion(&chan->tx_complete);
+
 	t = _add_to_rbuf(chan, mssg);
 	if (!t)
 		pr_err("Try increasing MBOX_TX_QUEUE_LEN\n");
@@ -209,7 +212,6 @@ request_token_t ipc_send_message(void *channel, void *mssg)
 
 	if (chan->tx_block && chan->active_req) {
 		int ret;
-		init_completion(&chan->tx_complete);
 		ret = wait_for_completion_timeout(&chan->tx_complete,
 			chan->tx_tout);
 		if (ret == 0) {
@@ -467,7 +469,8 @@ void ipc_links_unregister(struct ipc_controller *ipc)
 	list_for_each_entry(chan, &con->channels, node)
 		ipc_free_channel((void *)chan);
 
-	del_timer_sync(&con->poll);
+	if (ipc->txdone_poll)
+		del_timer_sync(&con->poll);
 
 	kfree(con);
 }
-- 
1.9.1

