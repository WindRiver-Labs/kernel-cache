From 1ccc1d84269e344774684d2b91998bd8ca8adaf1 Mon Sep 17 00:00:00 2001
From: Dinh Nguyen <dinguyen@altera.com>
Date: Wed, 17 Oct 2012 07:17:48 -0500
Subject: [PATCH 144/254] net: stmmac: Enhancements for SOCFPGA

Upstream: git://git.rocketboards.org/linux-socfpga.git

Modified the driver to support HW without a PHY.

Signed-off-by: Dinh Nguyen <dinguyen@altera.com>
(cherry picked from commit be8e210ff0ef355ec69decf882617165c5957d8e)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/net/ethernet/stmicro/stmmac/Kconfig       |   42 +++++++++++++++++++++
 drivers/net/ethernet/stmicro/stmmac/enh_desc.c    |    4 ++
 drivers/net/ethernet/stmicro/stmmac/stmmac_main.c |   11 +++++
 3 files changed, 57 insertions(+), 0 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/Kconfig b/drivers/net/ethernet/stmicro/stmmac/Kconfig
index 1164930..98ca1d0 100644
--- a/drivers/net/ethernet/stmicro/stmmac/Kconfig
+++ b/drivers/net/ethernet/stmicro/stmmac/Kconfig
@@ -54,6 +54,48 @@ config STMMAC_DA
 	  By default, the DMA arbitration scheme is based on Round-robin
 	  (rx:tx priority is 1:1).
 
+config STMMAC_PHY_ID_ZERO_WORKAROUND
+	bool "STMMAC work around for non-existant phys returning 0"
+	default y
+	depends on STMMAC_ETH && ARCH_SOCFPGA
+	help
+	  Broken HW is sometimes missing the pull-up resistor on the
+	  MDIO line, which results in reads to non-existent devices returning
+	  0 rather than 0xffff.
+
+config STMMAC_SHARED_PHY_IRQ
+	bool "STMMAC and Phy have or'd IRQ"
+	default n
+	depends on STMMAC_ETH && ARCH_SOCFPGA
+	help
+	  Selecting this option means the IRQ lines for the STMMAC
+	  and its phy are hooked up to an or gate.
+
+config STMMAC_TIMER
+	bool "STMMAC Timer optimisation"
+	default n
+	depends on RTC_HCTOSYS_DEVICE
+	---help---
+	  Use an external timer for mitigating the number of network
+	  interrupts. Currently, for SH architectures, it is possible
+	  to use the TMU channel 2 and the SH-RTC device.
+
+choice
+        prompt "Select Timer device"
+        depends on STMMAC_TIMER
+
+config STMMAC_TMU_TIMER
+        bool "TMU channel 2"
+        depends on CPU_SH4
+	---help---
+
+config STMMAC_RTC_TIMER
+        bool "Real time clock"
+        depends on RTC_CLASS
+	---help---
+
+endchoice
+
 choice
 	prompt "Select the DMA TX/RX descriptor operating modes"
 	depends on STMMAC_ETH
diff --git a/drivers/net/ethernet/stmicro/stmmac/enh_desc.c b/drivers/net/ethernet/stmicro/stmmac/enh_desc.c
index 2fc8ef9..6996b2e 100644
--- a/drivers/net/ethernet/stmicro/stmmac/enh_desc.c
+++ b/drivers/net/ethernet/stmicro/stmmac/enh_desc.c
@@ -145,7 +145,11 @@ static int enh_desc_coe_rdes0(int ipc_err, int type, int payload_err)
 		ret = discard_frame;
 	} else if (status == 0x3) {
 		CHIP_DBG(KERN_ERR "RX Des0 status: No IPv4, IPv6 frame.\n");
+#ifdef CONFIG_ARCH_SOCFPGA
+		ret = csum_none;
+#else
 		ret = discard_frame;
+#endif
 	}
 	return ret;
 }
diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index 7704469..391659a 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -436,12 +436,20 @@ static int stmmac_init_phy(struct net_device *dev)
 		return PTR_ERR(phydev);
 	}
 
+#ifdef CONFIG_ARCH_SOCFPGA
+	if (priv->plat->has_gmac) {
+		phydev->supported |= PHY_GBIT_FEATURES;
+		phydev->advertising |= PHY_GBIT_FEATURES;
+	}
+#endif
+
 	/* Stop Advertising 1000BASE Capability if interface is not GMII */
 	if ((interface == PHY_INTERFACE_MODE_MII) ||
 	    (interface == PHY_INTERFACE_MODE_RMII))
 		phydev->advertising &= ~(SUPPORTED_1000baseT_Half |
 					 SUPPORTED_1000baseT_Full);
 
+#ifdef CONFIG_STMMAC_PHY_ID_ZERO_WORKAROUND
 	/*
 	 * Broken HW is sometimes missing the pull-up resistor on the
 	 * MDIO line, which results in reads to non-existent devices returning
@@ -453,6 +461,7 @@ static int stmmac_init_phy(struct net_device *dev)
 		phy_disconnect(phydev);
 		return -ENODEV;
 	}
+#endif
 	pr_debug("stmmac_init_phy:  %s: attached to PHY (UID 0x%x)"
 		 " Link = %d\n", dev->name, phydev->phy_id, phydev->link);
 
@@ -1052,6 +1061,7 @@ static int stmmac_open(struct net_device *dev)
 	/* Initialize the MAC Core */
 	priv->hw->mac->core_init(priv->ioaddr);
 
+#ifndef CONFIG_STMMAC_SHARED_PHY_IRQ
 	/* Request the IRQ lines */
 	ret = request_irq(dev->irq, stmmac_interrupt,
 			 IRQF_SHARED, dev->name, dev);
@@ -1060,6 +1070,7 @@ static int stmmac_open(struct net_device *dev)
 		       __func__, dev->irq, ret);
 		goto open_error;
 	}
+#endif
 
 	/* Request the Wake IRQ in case of another line is used for WoL */
 	if (priv->wol_irq != dev->irq) {
-- 
1.7.5.4

