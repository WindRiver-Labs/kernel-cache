From 65068609771d6e56b3daffa2e09c0d3bb983ed9c Mon Sep 17 00:00:00 2001
From: Dinh Nguyen <dinguyen@altera.com>
Date: Wed, 31 Jul 2013 15:45:36 -0500
Subject: [PATCH 123/248] Upgrade to v3.10

* Don't print out EEE init
* Align drivers/clk/socfpga/clk.c with kernel.org
* Clean up gpio-dw.c
* Align dw_mmc-socfpga with kernel.org

[Original patch taken from
git://git.rocketboards.org/linux-socfpga.git socfpga-3.14]

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
Signed-off-by: Dinh Nguyen <dinguyen@altera.com>
---
 arch/arm/mach-socfpga/Kconfig     |   6 --
 arch/arm/mach-socfpga/platsmp.c   |  12 +--
 arch/arm/mach-socfpga/socfpga.c   |  34 ++++----
 drivers/clk/socfpga/clk.c         | 165 ++++++++------------------------------
 drivers/mmc/host/dw_mmc-socfpga.c |  10 +--
 drivers/mtd/devices/m25p80.c      |   1 +
 drivers/usb/otg/dwc/Kconfig       |   1 +
 drivers/usb/otg/dwc/hcd.c         |   2 +-
 8 files changed, 61 insertions(+), 170 deletions(-)

diff --git a/arch/arm/mach-socfpga/Kconfig b/arch/arm/mach-socfpga/Kconfig
index 876b512..56ae9bd 100644
--- a/arch/arm/mach-socfpga/Kconfig
+++ b/arch/arm/mach-socfpga/Kconfig
@@ -24,9 +24,3 @@ config ARCH_SOCFPGA
 	select PL310_ERRATA_727915
 	select PL310_ERRATA_753970
 	select PL310_ERRATA_769419
-
-config FPGA_SDRAM
-	bool "Enables FPGA SDRAM"
-	depends on ARCH_SOCFPGA
-	help
-		This enables the SDRAM controller that is connected to the FGPA.
diff --git a/arch/arm/mach-socfpga/platsmp.c b/arch/arm/mach-socfpga/platsmp.c
index b29f2c1..47e36c3 100644
--- a/arch/arm/mach-socfpga/platsmp.c
+++ b/arch/arm/mach-socfpga/platsmp.c
@@ -29,16 +29,6 @@
 
 #include "core.h"
 
-static void __cpuinit socfpga_secondary_init(unsigned int cpu)
-{
-	/*
-	 * if any interrupts are already enabled for the primary
-	 * core (e.g. timer irq), then they will not have been enabled
-	 * for us: do so
-	 */
-	gic_secondary_init(0);
-}
-
 static int socfpga_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
 	int trampoline_size = &secondary_trampoline_end - &secondary_trampoline;
@@ -47,7 +37,7 @@ static int socfpga_boot_secondary(unsigned int cpu, struct task_struct *idle)
 		memcpy(phys_to_virt(0), &secondary_trampoline, trampoline_size);
 
 		__raw_writel(virt_to_phys(socfpga_secondary_startup),
-			(sys_manager_base_addr+(cpu1start_addr & 0x000000ff)));
+			(sys_manager_base_addr + (cpu1start_addr & 0x000000ff)));
 
 		flush_cache_all();
 		smp_wmb();
diff --git a/arch/arm/mach-socfpga/socfpga.c b/arch/arm/mach-socfpga/socfpga.c
index 29896f2..4c656cd 100644
--- a/arch/arm/mach-socfpga/socfpga.c
+++ b/arch/arm/mach-socfpga/socfpga.c
@@ -29,7 +29,6 @@
 #include <asm/hardware/cache-l2x0.h>
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
-#include <asm/smp_twd.h>
 #include <asm/pmu.h>
 
 #include "core.h"
@@ -42,7 +41,7 @@ void __iomem *sdr_ctl_base_addr;
 void __iomem *l3regs_base_addr;
 
 void __iomem *clk_mgr_base_addr;
-unsigned long	cpu1start_addr;
+unsigned long cpu1start_addr;
 
 static int stmmac_plat_init(struct platform_device *pdev);
 
@@ -79,6 +78,13 @@ static struct map_desc scu_io_desc __initdata = {
 	.type		= MT_DEVICE,
 };
 
+static struct map_desc uart_io_desc __initdata = {
+	.virtual        = 0xfec02000,
+	.pfn            = __phys_to_pfn(0xffc02000),
+	.length         = SZ_8K,
+	.type           = MT_DEVICE,
+};
+
 static void __init socfpga_soc_device_init(void)
 {
 	struct device_node *root;
@@ -147,7 +153,7 @@ static void __init socfpga_scu_map_io(void)
 static void __init enable_periphs(void)
 {
 	/* Release all peripherals from reset.*/
-	__raw_writel(0, rst_manager_base_addr + SOCFPGA_RSTMGR_MODPERRST);
+	writel(0, rst_manager_base_addr + SOCFPGA_RSTMGR_MODPERRST);
 }
 
 #define MICREL_KSZ9021_EXTREG_CTRL 11
@@ -205,15 +211,11 @@ static int stmmac_plat_init(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
-	ctrl =  __raw_readl(sys_manager_base_addr +
-		SYSMGR_EMACGRP_CTRL_OFFSET);
-
+	ctrl = readl(sys_manager_base_addr + SYSMGR_EMACGRP_CTRL_OFFSET);
 	ctrl &= ~(SYSMGR_EMACGRP_CTRL_PHYSEL_MASK << shift);
-
 	ctrl |= (val << shift);
 
-	__raw_writel(ctrl, (sys_manager_base_addr +
-		SYSMGR_EMACGRP_CTRL_OFFSET));
+	writel(ctrl, (sys_manager_base_addr + SYSMGR_EMACGRP_CTRL_OFFSET));
 
 	return 0;
 }
@@ -221,7 +223,7 @@ static int stmmac_plat_init(struct platform_device *pdev)
 static void __init socfpga_map_io(void)
 {
 	socfpga_scu_map_io();
-	debug_ll_io_init();
+	iotable_init(&uart_io_desc, 1);
 	early_printk("Early printk initialized\n");
 }
 
@@ -284,21 +286,22 @@ static void __init socfpga_init_irq(void)
 	irqchip_init();
 	socfpga_sysmgr_init();
 
+	of_clk_init(NULL);
 	socfpga_init_clocks();
-	twd_local_timer_of_register();
+	clocksource_of_init();
 }
 
 static void socfpga_cyclone5_restart(enum reboot_mode mode, const char *cmd)
 {
 	u32 temp;
 
-	temp = __raw_readl(rst_manager_base_addr + SOCFPGA_RSTMGR_CTRL);
+	temp = readl(rst_manager_base_addr + SOCFPGA_RSTMGR_CTRL);
 
 	if (mode == REBOOT_HARD)
 		temp |= RSTMGR_CTRL_SWCOLDRSTREQ;
 	else
 		temp |= RSTMGR_CTRL_SWWARMRSTREQ;
-	__raw_writel(temp, rst_manager_base_addr + SOCFPGA_RSTMGR_CTRL);
+	writel(temp, rst_manager_base_addr + SOCFPGA_RSTMGR_CTRL);
 }
 
 static void __init socfpga_cyclone5_init(void)
@@ -312,13 +315,12 @@ static void __init socfpga_cyclone5_init(void)
 #endif
 	of_platform_populate(NULL, of_default_bus_match_table,
 		socfpga_auxdata_lookup, NULL);
-	socfpga_init_clocks();
 	enable_periphs();
 
 	socfpga_soc_device_init();
 	if (IS_BUILTIN(CONFIG_PHYLIB))
-		phy_register_fixup_for_uid(PHY_ID_KSZ9021RLRN, MICREL_PHY_ID_MASK,
-			ksz9021rlrn_phy_fixup);
+		phy_register_fixup_for_uid(PHY_ID_KSZ9021RLRN,
+			MICREL_PHY_ID_MASK, ksz9021rlrn_phy_fixup);
 }
 
 static const char *altera_dt_match[] = {
diff --git a/drivers/clk/socfpga/clk.c b/drivers/clk/socfpga/clk.c
index f482cb6..d5a7a3f 100644
--- a/drivers/clk/socfpga/clk.c
+++ b/drivers/clk/socfpga/clk.c
@@ -24,8 +24,6 @@
 #include <linux/of.h>
 #include <linux/of_address.h>
 
-static DEFINE_SPINLOCK(_lock);
-
 /* Clock Manager offsets */
 #define CLKMGR_CTRL	0x0
 #define CLKMGR_BYPASS	0x4
@@ -71,50 +69,6 @@ struct socfpga_clk {
 };
 #define to_socfpga_clk(p) container_of(p, struct socfpga_clk, hw.hw)
 
-/* Clock Manager offsets */
-#define CLKMGR_CTRL    0x0
-#define CLKMGR_BYPASS 0x4
-#define CLKMGR_L4SRC	0x70
-#define CLKMGR_PERPLL_SRC	0xAC
-
-/* Clock bypass bits */
-#define MAINPLL_BYPASS (1<<0)
-#define SDRAMPLL_BYPASS (1<<1)
-#define SDRAMPLL_SRC_BYPASS (1<<2)
-#define PERPLL_BYPASS (1<<3)
-#define PERPLL_SRC_BYPASS (1<<4)
-
-#define SOCFPGA_PLL_BG_PWRDWN		0
-#define SOCFPGA_PLL_EXT_ENA		1
-#define SOCFPGA_PLL_PWR_DOWN		2
-#define SOCFPGA_PLL_DIVF_MASK		0x0000FFF8
-#define SOCFPGA_PLL_DIVF_SHIFT	3
-#define SOCFPGA_PLL_DIVQ_MASK		0x003F0000
-#define SOCFPGA_PLL_DIVQ_SHIFT	16
-#define SOCFGPA_MAX_PARENTS	3
-
-#define SOCFPGA_L4_MP_CLK			"l4_mp_clk"
-#define SOCFPGA_L4_SP_CLK			"l4_sp_clk"
-#define SOCFPGA_NAND_CLK		"nand_clk"
-#define SOCFPGA_NAND_X_CLK		"nand_x_clk"
-#define SOCFPGA_MMC_CLK			"mmc_clk"
-#define SOCFPGA_DB_CLK			"gpio_db_clk"
-
-#define div_mask(width)	((1 << (width)) - 1)
-
-extern void __iomem *clk_mgr_base_addr;
-
-struct socfpga_clk {
-	struct clk_gate hw;
-	char *parent_name;
-	char *clk_name;
-	u32 fixed_div;
-	void __iomem *div_reg;
-	u32 width;
-	u32 shift;
-};
-#define to_socfpga_clk(p) container_of(p, struct socfpga_clk, hw.hw)
-
 static unsigned long clk_pll_recalc_rate(struct clk_hw *hwclk,
 					 unsigned long parent_rate)
 {
@@ -195,8 +149,9 @@ static __init struct clk *socfpga_clk_init(struct device_node *node,
 
 	socfpga_clk->hw.hw.init = &init;
 
-	if ((strcmp(clk_name, "main_pll") == 0) || (strcmp(clk_name, "periph_pll") == 0)||
-			(strcmp(clk_name, "sdram_pll") == 0))  {
+	if (streq(clk_name, "main_pll") ||
+		streq(clk_name, "periph_pll") ||
+		streq(clk_name, "sdram_pll")) {
 		socfpga_clk->hw.bit_idx = SOCFPGA_PLL_EXT_ENA;
 		clk_pll_ops.enable = clk_gate_ops.enable;
 		clk_pll_ops.disable = clk_gate_ops.disable;
@@ -215,55 +170,52 @@ static u8 socfpga_clk_get_parent(struct clk_hw *hwclk)
 {
 	u32 l4_src;
 	u32 perpll_src;
-	u8 parent;
 
-	if (strcmp(hwclk->init->name, SOCFPGA_L4_MP_CLK) == 0) {
+	if (streq(hwclk->init->name, SOCFPGA_L4_MP_CLK)) {
 		l4_src = readl(clk_mgr_base_addr + CLKMGR_L4SRC);
-		l4_src &= 0x1;
-		parent = l4_src;
-	} else if (strcmp(hwclk->init->name, SOCFPGA_L4_SP_CLK) == 0) {
+		return l4_src &= 0x1;
+	}
+	if (streq(hwclk->init->name, SOCFPGA_L4_SP_CLK)) {
 		l4_src = readl(clk_mgr_base_addr + CLKMGR_L4SRC);
-		l4_src = ((l4_src & 0x2) >> 1);
-		parent = l4_src;
-	} else {
-		perpll_src = readl(clk_mgr_base_addr + CLKMGR_PERPLL_SRC);
-		if (strcmp(hwclk->init->name, SOCFPGA_MMC_CLK) == 0)
-			perpll_src &= 0x3;
-		else if (strcmp(hwclk->init->name, SOCFPGA_NAND_CLK) == 0 ||
-				strcmp(hwclk->init->name, SOCFPGA_NAND_X_CLK) == 0)
-			perpll_src = ((perpll_src & 0xC) >> 2);
-		else /*QSPI clock */
-			perpll_src = ((perpll_src & 0x30) >> 4);
-		parent = perpll_src;
+		return !!(l4_src & 2);
 	}
 
-	return parent;
+	perpll_src = readl(clk_mgr_base_addr + CLKMGR_PERPLL_SRC);
+	if (streq(hwclk->init->name, SOCFPGA_MMC_CLK))
+		return perpll_src &= 0x3;
+	if (streq(hwclk->init->name, SOCFPGA_NAND_CLK) ||
+			streq(hwclk->init->name, SOCFPGA_NAND_X_CLK))
+			return (perpll_src >> 2) & 3;
+
+	/* QSPI clock */
+	return (perpll_src >> 4) & 3;
+
 }
 
 static int socfpga_clk_set_parent(struct clk_hw *hwclk, u8 parent)
 {
 	u32 src_reg;
 
-	if (strcmp(hwclk->init->name, SOCFPGA_L4_MP_CLK) == 0) {
+	if (streq(hwclk->init->name, SOCFPGA_L4_MP_CLK)) {
 		src_reg = readl(clk_mgr_base_addr + CLKMGR_L4SRC);
 		src_reg &= ~0x1;
 		src_reg |= parent;
 		writel(src_reg, clk_mgr_base_addr + CLKMGR_L4SRC);
-	} else if (strcmp(hwclk->init->name, SOCFPGA_L4_SP_CLK) == 0) {
+	} else if (streq(hwclk->init->name, SOCFPGA_L4_SP_CLK)) {
 		src_reg = readl(clk_mgr_base_addr + CLKMGR_L4SRC);
 		src_reg &= ~0x2;
 		src_reg |= (parent << 1);
 		writel(src_reg, clk_mgr_base_addr + CLKMGR_L4SRC);
 	} else {
 		src_reg = readl(clk_mgr_base_addr + CLKMGR_PERPLL_SRC);
-		if (strcmp(hwclk->init->name, SOCFPGA_MMC_CLK) == 0) {
+		if (streq(hwclk->init->name, SOCFPGA_MMC_CLK)) {
 			src_reg &= ~0x3;
 			src_reg |= parent;
-		} else if (strcmp(hwclk->init->name, SOCFPGA_NAND_CLK) == 0 ||
-			strcmp(hwclk->init->name, SOCFPGA_NAND_X_CLK) == 0) {
+		} else if (streq(hwclk->init->name, SOCFPGA_NAND_CLK) ||
+			streq(hwclk->init->name, SOCFPGA_NAND_X_CLK)) {
 			src_reg &= ~0xC;
 			src_reg |= (parent << 2);
-		} else {/*QSPI clock */
+		} else {/* QSPI clock */
 			src_reg &= ~0x30;
 			src_reg |= (parent << 4);
 		}
@@ -284,7 +236,7 @@ static unsigned long socfpga_clk_recalc_rate(struct clk_hw *hwclk,
 	else if (socfpgaclk->div_reg) {
 		val = readl(socfpgaclk->div_reg) >> socfpgaclk->shift;
 		val &= div_mask(socfpgaclk->width);
-		if (strcmp(hwclk->init->name, SOCFPGA_DB_CLK) == 0)
+		if (streq(hwclk->init->name, SOCFPGA_DB_CLK))
 			div = val + 1;
 		else
 			div = (1 << val);
@@ -321,12 +273,6 @@ static void __init socfpga_gate_clk_init(struct device_node *node,
 	if (rc)
 		clk_gate[0] = 0;
 
-	rc = of_property_read_u32(node, "fixed-divider", &fixed_div);
-	if (rc)
-		socfpga_clk->fixed_div = 0;
-	else
-		socfpga_clk->fixed_div = fixed_div;
-
 	if (clk_gate[0]) {
 		socfpga_clk->hw.reg = clk_mgr_base_addr + clk_gate[0];
 		socfpga_clk->hw.bit_idx = clk_gate[1];
@@ -335,6 +281,12 @@ static void __init socfpga_gate_clk_init(struct device_node *node,
 		gateclk_ops.disable = clk_gate_ops.disable;
 	}
 
+	rc = of_property_read_u32(node, "fixed-divider", &fixed_div);
+	if (rc)
+		socfpga_clk->fixed_div = 0;
+	else
+		socfpga_clk->fixed_div = fixed_div;
+
 	rc = of_property_read_u32_array(node, "div-reg", div_reg, 3);
 	if (!rc) {
 		socfpga_clk->div_reg = clk_mgr_base_addr + div_reg[0];
@@ -371,74 +323,25 @@ static void __init socfpga_pll_init(struct device_node *node)
 {
 	socfpga_clk_init(node, &clk_pll_ops);
 }
+CLK_OF_DECLARE(socfpga_pll, "altr,socfpga-pll-clock", socfpga_pll_init);
 
 static void __init socfpga_periph_init(struct device_node *node)
 {
 	socfpga_clk_init(node, &periclk_ops);
 }
+CLK_OF_DECLARE(socfpga_periph, "altr,socfpga-perip-clk", socfpga_periph_init);
 
 static void __init socfpga_gate_init(struct device_node *node)
 {
 	socfpga_gate_clk_init(node, &gateclk_ops);
 }
-
-static const __initconst struct of_device_id clk_match[] = {
-	{ .compatible = "fixed-clock", .data = of_fixed_clk_setup, },
-	{ .compatible = "altr,socfpga-pll-clock", .data = socfpga_pll_init, },
-	{ .compatible = "altr,socfpga-perip-clk", .data = socfpga_periph_init, },
-	{ .compatible = "altr,socfpga-gate-clk", .data = socfpga_gate_init, },
-	{}
-};
+CLK_OF_DECLARE(socfpga_gate, "altr,socfpga-gate-clk", socfpga_gate_init);
 
 void __init socfpga_init_clocks(void)
 {
-	struct socfpga_clk *socfpgaclk = to_socfpga_clk(hwclk);
-	unsigned long divf, divq, vco_freq, reg;
-	unsigned long bypass;
-
-	reg = readl(socfpgaclk->hw.reg);
-	bypass = readl(clk_mgr_base_addr + CLKMGR_BYPASS);
-	if (bypass & MAINPLL_BYPASS)
-		return parent_rate;
-
-	divf = (reg & SOCFPGA_PLL_DIVF_MASK) >> SOCFPGA_PLL_DIVF_SHIFT;
-	divq = (reg & SOCFPGA_PLL_DIVQ_MASK) >> SOCFPGA_PLL_DIVQ_SHIFT;
-	vco_freq = parent_rate * (divf + 1);
-	return vco_freq / (1 + divq);
-}
-
-
-static struct clk_ops clk_pll_ops = {
-	.recalc_rate = clk_pll_recalc_rate,
-};
-
-static unsigned long clk_periclk_recalc_rate(struct clk_hw *hwclk,
-					     unsigned long parent_rate)
-{
-	struct socfpga_clk *socfpgaclk = to_socfpga_clk(hwclk);
-	u32 div;
-
-	if (socfpgaclk->fixed_div)
-		div = socfpgaclk->fixed_div;
-	else
-		div = ((readl(socfpgaclk->hw.reg) & 0x1ff) + 1);
-
-	return parent_rate / div;
-}
-
-static const struct clk_ops periclk_ops = {
-	.recalc_rate = clk_periclk_recalc_rate,
-};
-
-static __init struct clk *socfpga_clk_init(struct device_node *node,
-	const struct clk_ops *ops)
-{
-	u32 reg;
 	struct clk *clk;
 	int ret;
 
-	of_clk_init(clk_match);
-
 	clk = clk_register_fixed_factor(NULL, "smp_twd", "mpuclk", 0, 1, 4);
 	ret = clk_register_clkdev(clk, NULL, "smp_twd");
 	if (ret)
diff --git a/drivers/mmc/host/dw_mmc-socfpga.c b/drivers/mmc/host/dw_mmc-socfpga.c
index 8cfb301..3f6f166 100644
--- a/drivers/mmc/host/dw_mmc-socfpga.c
+++ b/drivers/mmc/host/dw_mmc-socfpga.c
@@ -26,14 +26,14 @@
 
 #define SYSMGR_SDMMCGRP_CTRL_OFFSET		0x108
 #define DRV_CLK_PHASE_SHIFT_SEL_MASK	0x7
-#define SYSMGR_SDMMC_CTRL_SET(smplsel, drvsel)		\
-	((((drvsel) << 0) & 0x7) | (((smplsel) << 3) & 0x38))
+#define SYSMGR_SDMMC_CTRL_SET(smplsel, drvsel)\ 
+	((((smplsel) & 0x7) << 3) | (((drvsel) & 0x7) << 0))
 
 /* SOCFPGA implementation specific driver private data */
 struct dw_mci_socfpga_priv_data {
-	u8	ciu_div;
-	u32	hs_timing;
-	struct regmap   *sysreg;
+	u8      ciu_div; /* card interface unit divisor */
+	u32     hs_timing; /* bitmask for CIU clock phase shift */
+	struct regmap   *sysreg; /* regmap for system manager register */
 };
 
 static int dw_mci_socfpga_priv_init(struct dw_mci *host)
diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index 43a59e4..9aa01d8 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -970,6 +970,7 @@ struct flash_info {
 #define	M25P_NO_FR	0x08		/* Can't do fastread */
 #define	SECT_4K_PMC	0x10		/* OPCODE_BE_4K_PMC works uniformly */
 #define	M25P80_QUAD_READ	0x20    /* Flash supports Quad Read */
+#define	USE_FSR   0x04    /* use flag status register */
 };
 
 #define INFO(_jedec_id, _ext_id, _sector_size, _n_sectors, _flags)	\
diff --git a/drivers/usb/otg/dwc/Kconfig b/drivers/usb/otg/dwc/Kconfig
index a056b4c..b88c619 100644
--- a/drivers/usb/otg/dwc/Kconfig
+++ b/drivers/usb/otg/dwc/Kconfig
@@ -8,6 +8,7 @@ comment "Enable Host or Gadget support for DesignWare OTG controller"
 
 config USB_DWC_OTG
 	depends on (USB || USB_GADGET)
+	select USB_PHY
 	select NOP_USB_XCEIV
 	select USB_OTG_UTILS
 	tristate "Synopsys DWC OTG Controller"
diff --git a/drivers/usb/otg/dwc/hcd.c b/drivers/usb/otg/dwc/hcd.c
index fd336e0..d31e7bc 100644
--- a/drivers/usb/otg/dwc/hcd.c
+++ b/drivers/usb/otg/dwc/hcd.c
@@ -209,7 +209,7 @@ static void dwc_otg_core_host_init(struct core_if *core_if)
 
 	/* Turn on the vbus power. */
 	pr_info("Init: Port Power? op_state=%s\n",
-		otg_state_string(core_if->xceiv->state));
+		usb_otg_state_string(core_if->xceiv->state));
 
 	if (core_if->xceiv->state == OTG_STATE_A_HOST) {
 		hprt0 = dwc_otg_read_hprt0(core_if);
-- 
1.9.1

