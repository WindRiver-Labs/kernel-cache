From 8fe076f3a0fa6786bebdad9ab73479714c346976 Mon Sep 17 00:00:00 2001
From: Dinh Nguyen <dinguyen@altera.com>
Date: Wed, 10 Oct 2012 13:09:25 -0500
Subject: [PATCH 003/248] arm: socfpga: Add SMP, sdmmmc platform data, and
 clock entries.

-Add more clock entries to the common clock framework.
-Enable SMP
-Add SD/MMC platform data for SDMMC driver.

[Original patch taken from
git://git.rocketboards.org/linux-socfpga.git socfpga-3.14]

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
Signed-off-by: Dinh Nguyen <dinguyen@altera.com>
---
 arch/arm/boot/dts/socfpga.dtsi     |  26 +++++++
 arch/arm/configs/socfpga_defconfig |   3 +
 arch/arm/mach-socfpga/hotplug.c    |  53 +++++++++++++
 arch/arm/mach-socfpga/platsmp.c    |  22 +++++-
 arch/arm/mach-socfpga/sdmmc.c      | 151 +++++++++++++++++++++++++++++++++++++
 drivers/clk/socfpga/clk.c          |  72 +++++++++---------
 6 files changed, 289 insertions(+), 38 deletions(-)
 create mode 100644 arch/arm/mach-socfpga/hotplug.c
 create mode 100644 arch/arm/mach-socfpga/sdmmc.c

diff --git a/arch/arm/boot/dts/socfpga.dtsi b/arch/arm/boot/dts/socfpga.dtsi
index 537f1a5..f0aca3b 100644
--- a/arch/arm/boot/dts/socfpga.dtsi
+++ b/arch/arm/boot/dts/socfpga.dtsi
@@ -473,6 +473,32 @@
 			arm,data-latency = <2 1 1>;
 		};
 
+		mmc: sdmmc@ff704000 {
+			compatible = "snps,dw-mmc";
+			reg = <0xff704000 0x1000>;
+			interrupts = <0 139 4>;
+			bus-hz = <50000000>; /*50MHz*/
+			num-slots = <1>;
+			bus-width = <8>;
+			fifo-depth = <1024>;
+			voltage-switch = <0>;	/* 0-No support */
+
+			/* First cell: smpl_sel, second cell: drv_sel*/
+			mmc-hs-timing = <7 4>;
+			sdr12-timing = <0 4>;
+			sdr25-timing = <7 3>;
+			};
+
+		rstmgr@ffd05000 {
+				compatible = "altr,rst-mgr";
+				reg = <0xffd05000 0x1000>;
+			};
+		
+		sysmgr@ffd08000 {
+				compatible = "altr,sys-mgr";
+				reg = <0xffd08000 0x4000>;
+			};
+
 		/* Local timer */
 		timer@fffec600 {
 			compatible = "arm,cortex-a9-twd-timer";
diff --git a/arch/arm/configs/socfpga_defconfig b/arch/arm/configs/socfpga_defconfig
index 4e1ce21..22c96e7 100644
--- a/arch/arm/configs/socfpga_defconfig
+++ b/arch/arm/configs/socfpga_defconfig
@@ -62,6 +62,9 @@ CONFIG_SERIAL_8250_CONSOLE=y
 CONFIG_SERIAL_8250_NR_UARTS=2
 CONFIG_SERIAL_8250_RUNTIME_UARTS=2
 CONFIG_SERIAL_8250_DW=y
+CONFIG_MMC=y
+CONFIG_MMC_DW=y
+CONFIG_MMC_DW_IDMAC=y
 # CONFIG_RTC_HCTOSYS is not set
 CONFIG_EXT2_FS=y
 CONFIG_EXT2_FS_XATTR=y
diff --git a/arch/arm/mach-socfpga/hotplug.c b/arch/arm/mach-socfpga/hotplug.c
new file mode 100644
index 0000000..e04dcca
--- /dev/null
+++ b/arch/arm/mach-socfpga/hotplug.c
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2011 Freescale Semiconductor, Inc.
+ * Copyright 2011 Linaro Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/errno.h>
+#include <asm/cacheflush.h>
+#include <asm/cp15.h>
+
+static inline void cpu_enter_lowpower(void)
+{
+}
+
+static inline void cpu_leave_lowpower(void)
+{
+}
+
+int platform_cpu_kill(unsigned int cpu)
+{
+	return 1;
+}
+
+/*
+ * platform-specific code to shutdown a CPU
+ *
+ * Called with IRQs disabled
+ */
+void __ref platform_cpu_die(unsigned int cpu)
+{
+	cpu_enter_lowpower();
+
+	cpu_do_idle();
+	cpu_leave_lowpower();
+
+	/* We should never return from idle */
+	panic("cpu %d unexpectedly exit from shutdown\n", cpu);
+}
+
+int platform_cpu_disable(unsigned int cpu)
+{
+	/*
+	 * CPU0 should not be shut down via hotplug.  cpu_idle can WFI
+	 * or a proper shutdown or hibernate should be used.
+	 */
+	return cpu == 0 ? -EPERM : 0;
+}
diff --git a/arch/arm/mach-socfpga/platsmp.c b/arch/arm/mach-socfpga/platsmp.c
index 5356a72..ce6264e 100644
--- a/arch/arm/mach-socfpga/platsmp.c
+++ b/arch/arm/mach-socfpga/platsmp.c
@@ -27,7 +27,27 @@
 #include <asm/smp_scu.h>
 #include <asm/smp_plat.h>
 
-#include "core.h"
+volatile int pen_release = -1;
+
+extern void secondary_startup(void);
+extern void __iomem *socfpga_scu_base_addr;
+static void __iomem *sys_manager_base_addr;
+static void __iomem *rst_manager_base_addr;
+
+extern void socfpga_secondary_startup(void);
+extern void socfpga_cpu_die(unsigned int cpu);
+
+static DEFINE_SPINLOCK(boot_lock);
+
+void __cpuinit platform_secondary_init(unsigned int cpu)
+{
+	/*
+	 * if any interrupts are already enabled for the primary
+	 * core (e.g. timer irq), then they will not have been enabled
+	 * for us: do so
+	 */
+	gic_secondary_init(0);
+}
 
 static int socfpga_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
diff --git a/arch/arm/mach-socfpga/sdmmc.c b/arch/arm/mach-socfpga/sdmmc.c
new file mode 100644
index 0000000..bb3a776
--- /dev/null
+++ b/arch/arm/mach-socfpga/sdmmc.c
@@ -0,0 +1,151 @@
+/*
+ *  linux/arch/arm/mach-socfpga5xs1/sdmmc.c
+ *
+ *  Copyright (C) 2011 Altera Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/mmc/dw_mmc.h>
+#include <linux/mmc/host.h>
+#include <linux/dma-mapping.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <asm/errno.h>/* Clock Manager */
+
+#define PWREN		(0x4)
+
+#define mci_writel(base, value, reg)			 \
+	__raw_writel((value), base + reg)
+
+#define mci_readl(base, reg)				\
+	__raw_readl(base + reg)
+
+static void __iomem *sdmmc_base = 0;
+
+static void __iomem* sdmmc_get_base_addr(void)
+{
+	struct device_node *np;
+
+	np = of_find_compatible_node(NULL, NULL, "snps,dw-mmc");
+	if (np) {
+		return of_iomap(np, 0);
+	}
+
+	return NULL;
+}
+
+void sdmmc_setpower(unsigned int slot_id, unsigned int volt)
+{
+	unsigned int power;
+
+	if (sdmmc_base == NULL) {
+		sdmmc_base = sdmmc_get_base_addr();
+		if (!sdmmc_base)
+			return;
+	}
+
+	power = mci_readl(sdmmc_base, PWREN);
+
+	if (volt == 0) {
+		/* turn off */
+		power &= ~(1 << slot_id);
+	}
+	else {
+		/* turn on */
+		power |= (1 << slot_id);
+	}
+
+	mci_writel(sdmmc_base, power, PWREN);
+
+	return;
+}
+
+int sdmmc_get_bus_width(unsigned int slot_id)
+{
+	struct device_node *np;
+	unsigned int bus_width;
+
+	np = of_find_compatible_node(NULL, NULL, "snps,dw-mmc");
+	if (np) {
+		if (!(of_property_read_u32(np, "bus-width", &bus_width)))
+			return bus_width;
+	}
+
+	/* Default 1-bit */
+	return 1;
+}
+
+int sdmmc_get_ocr(unsigned int slot_id)
+{
+	struct device_node *np;
+	unsigned int voltages = MMC_VDD_32_33 | MMC_VDD_33_34;
+	unsigned int vol_switch;
+
+	np = of_find_compatible_node(NULL, NULL, "snps,dw-mmc");
+	if (np) {
+		if (!of_property_read_u32(np, "voltage-switch", &vol_switch) &&
+			vol_switch)
+			voltages |= MMC_VDD_165_195;
+	}
+
+	return voltages;
+}
+
+int sdmmc_init (unsigned int slot_id, irq_handler_t handler, void *p)
+{
+	return 0;
+}
+
+void sdmmc_exit(unsigned int slot_id)
+{
+	if (sdmmc_base) {
+		iounmap(sdmmc_base);
+		sdmmc_base = NULL;
+	}
+	return;
+}
+
+struct dw_mci_board sdmmc_platform_data = {
+	.quirks = 0,				/* Workaround / Quirk flags */
+	.caps = (MMC_CAP_MMC_HIGHSPEED |
+		 MMC_CAP_SD_HIGHSPEED),		/* Capabilities */
+
+	/* delay in ms before detecting cards after interrupt */
+	.detect_delay_ms = 25,
+
+	.init = sdmmc_init,
+	.get_ro = NULL,
+	.get_cd = NULL,
+	.get_ocr = sdmmc_get_ocr,
+	.get_bus_wd = sdmmc_get_bus_width,	/* Get bus width */
+	/*
+	 * Enable power to selected slot and set voltage to desired level.
+	 * Voltage levels are specified using MMC_VDD_xxx defines defined
+	 * in linux/mmc/host.h file.
+	 */
+	.setpower = sdmmc_setpower,
+	.exit = sdmmc_exit,
+	.select_slot = NULL,		/* Nothing to select, we only have one
+					   slot */
+
+	.dma_ops = NULL,		/* support IDMA only */
+	.data = NULL,
+	.blk_settings = NULL, 		/* Use default setting for IDMAC */
+
+};
diff --git a/drivers/clk/socfpga/clk.c b/drivers/clk/socfpga/clk.c
index 5983a26..8e7f61e 100644
--- a/drivers/clk/socfpga/clk.c
+++ b/drivers/clk/socfpga/clk.c
@@ -22,6 +22,9 @@
 #include <linux/clk-provider.h>
 #include <linux/io.h>
 #include <linux/of.h>
+#include <linux/of_address.h>
+
+static DEFINE_SPINLOCK(_lock);
 
 /* Clock Manager offsets */
 #define CLKMGR_CTRL	0x0
@@ -68,8 +71,9 @@ struct socfpga_clk {
 };
 #define to_socfpga_clk(p) container_of(p, struct socfpga_clk, hw.hw)
 
-static unsigned long clk_pll_recalc_rate(struct clk_hw *hwclk,
-					 unsigned long parent_rate)
+void __iomem *clk_mgr_base_addr;
+
+void __init socfpga_init_clocks(void)
 {
 	struct socfpga_clk *socfpgaclk = to_socfpga_clk(hwclk);
 	unsigned long divf, divq, vco_freq, reg;
@@ -114,37 +118,25 @@ static __init struct clk *socfpga_clk_init(struct device_node *node,
 {
 	u32 reg;
 	struct clk *clk;
-	struct socfpga_clk *socfpga_clk;
-	const char *clk_name = node->name;
-	const char *parent_name;
-	struct clk_init_data init;
-	int rc;
-	u32 fixed_div;
-
-	of_property_read_u32(node, "reg", &reg);
-
-	socfpga_clk = kzalloc(sizeof(*socfpga_clk), GFP_KERNEL);
-	if (WARN_ON(!socfpga_clk))
-		return NULL;
-
-	socfpga_clk->hw.reg = clk_mgr_base_addr + reg;
-
-	rc = of_property_read_u32(node, "fixed-divider", &fixed_div);
-	if (rc)
-		socfpga_clk->fixed_div = 0;
-	else
-		socfpga_clk->fixed_div = fixed_div;
-
-	of_property_read_string(node, "clock-output-names", &clk_name);
-
-	init.name = clk_name;
-	init.ops = ops;
-	init.flags = 0;
-	parent_name = of_clk_get_parent_name(node, 0);
-	init.parent_names = &parent_name;
-	init.num_parents = 1;
-
-	socfpga_clk->hw.hw.init = &init;
+	struct device_node *np;
+
+	np = of_find_compatible_node(NULL, NULL, "altr,clk-mgr");
+	clk_mgr_base_addr = of_iomap(np, 0);
+
+	clk = clk_register_fixed_rate(NULL, "main_pll_clk", NULL, CLK_IS_ROOT,
+			SOCFPGA_MAIN_PLL_CLK);
+	clk_register_clkdev(clk, "main_pll_clk", NULL);
+	
+	clk = clk_register_fixed_rate(NULL, "per_pll_clk", NULL, CLK_IS_ROOT,
+			SOCFPGA_PER_PLL_CLK);
+	clk_register_clkdev(clk, "per_pll_clk", NULL);
+	
+	clk = clk_register_fixed_rate(NULL, "sdram_pll_clk", NULL, CLK_IS_ROOT,
+			SOCFPGA_SDRAM_PLL_CLK);
+	clk_register_clkdev(clk, "sdram_pll_clk", NULL);
+	
+	clk = clk_register_fixed_rate(NULL, "osc1_clk", NULL, CLK_IS_ROOT, SOCFPGA_OSC1_CLK);
+	clk_register_clkdev(clk, "osc1_clk", NULL);
 
 	if (streq(clk_name, "main_pll") ||
 		streq(clk_name, "periph_pll") ||
@@ -339,8 +331,14 @@ void __init socfpga_init_clocks(void)
 	struct clk *clk;
 	int ret;
 
-	clk = clk_register_fixed_factor(NULL, "smp_twd", "mpuclk", 0, 1, 4);
-	ret = clk_register_clkdev(clk, NULL, "smp_twd");
-	if (ret)
-		pr_err("smp_twd alias not registered\n");
+	clk = clk_register_fixed_rate(NULL, "s2f_usr_clk", NULL, CLK_IS_ROOT, SOCFPGA_S2F_USR_CLK);
+	clk_register_clkdev(clk, "s2f_usr_clk", NULL);
+
+	clk = clk_register_gate(NULL, "mmc_clk", "main_nand_sdmmc_clk", 0, clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
+			CLKMGR_SDMMC_CLK_EN, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "ff704000.sdmmc");
+	
+	clk = clk_register_gate(NULL, "gmac_clk", "per_pll_clk", 0, clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
+			CLKMGR_EMAC0_CLK_EN, 0, &_lock);
+	clk_register_clkdev(clk, NULL, "ff700000.stmmac");
 }
-- 
1.9.1

