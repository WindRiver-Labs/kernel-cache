From 53e74cc51f6f882e7b01d6528384ae90616f1d90 Mon Sep 17 00:00:00 2001
From: Dinh Nguyen <dinguyen@altera.com>
Date: Wed, 10 Oct 2012 12:51:26 -0500
Subject: [PATCH 048/254] mmc: dw_mmc: Enable device tree for dw-mmc driver

Upstream: git://git.rocketboards.org/linux-socfpga.git

Enable the dw-mmc driver to be device tree capable.

Signed-off-by: Dinh Nguyen <dinguyen@altera.com>
(cherry picked from commit 439e99b45cec6b1696cc1404ed6f21d498eb4ff5)
Signed-off-by: Zumeng Chen <zumeng.chen@windriver.com>
---
 drivers/mmc/host/dw_mmc-pltfm.c |   11 +++++++++++
 drivers/mmc/host/dw_mmc.c       |   30 ++++++++++++++++++++++++++++++
 2 files changed, 41 insertions(+), 0 deletions(-)

diff --git a/drivers/mmc/host/dw_mmc-pltfm.c b/drivers/mmc/host/dw_mmc-pltfm.c
index eeeb35b8..b00f930 100644
--- a/drivers/mmc/host/dw_mmc-pltfm.c
+++ b/drivers/mmc/host/dw_mmc-pltfm.c
@@ -118,6 +118,16 @@ static const struct of_device_id dw_mci_pltfm_match[] = {
 };
 MODULE_DEVICE_TABLE(of, dw_mci_pltfm_match);
 
+#ifdef CONFIG_OF
+static struct of_device_id dw_mci_of_match[] __devinitdata = {
+       { .compatible = "snps,dw-mmc", },
+       { /* end of table */}
+};
+MODULE_DEVICE_TABLE(of, dw_mci_of_match);
+#else
+#define dw_mci_of_match NULL
+#endif /* CONFIG_OF */
+
 static struct platform_driver dw_mci_pltfm_driver = {
 	.probe		= dw_mci_pltfm_probe,
 	.remove		= __devexit_p(dw_mci_pltfm_remove),
@@ -125,6 +135,7 @@ static struct platform_driver dw_mci_pltfm_driver = {
 		.name		= "dw_mmc",
 		.of_match_table	= of_match_ptr(dw_mci_pltfm_match),
 		.pm		= &dw_mci_pltfm_pmops,
+		.of_match_table = dw_mci_of_match,
 	},
 };
 
diff --git a/drivers/mmc/host/dw_mmc.c b/drivers/mmc/host/dw_mmc.c
index 26be744..0ac919b 100644
--- a/drivers/mmc/host/dw_mmc.c
+++ b/drivers/mmc/host/dw_mmc.c
@@ -2108,6 +2108,36 @@ int dw_mci_probe(struct dw_mci *host)
 		}
 	}
 
+#ifdef CONFIG_OF
+	if (of_property_read_u32(host->dev.of_node, "bus-hz", &prop)) {
+		dev_err(&host->dev, "couldn't determine bus-hz\n");
+		return -ENODEV;
+	}
+	host->pdata->bus_hz = prop;
+
+	if (of_property_read_u32(host->dev.of_node, "num-slots", &prop)) {
+		dev_err(&host->dev, "couldn't determine num-slots\n");
+		return -ENODEV;
+	}
+	host->pdata->num_slots = prop;
+
+	/* Optional parameter. */
+	if (!of_property_read_u32(host->dev.of_node, "fifo-depth", &prop)) {
+		host->pdata->fifo_depth = prop;
+	}
+
+	if (of_property_read_u32(host->dev.of_node, "bus-width", &prop)) {
+		dev_err(&host->dev, "couldn't determine bus-width\n");
+		return -ENODEV;
+	}
+
+	if (prop == 8)
+		host->pdata->caps |= (MMC_CAP_4_BIT_DATA |
+					MMC_CAP_8_BIT_DATA);
+	else if (prop == 4)
+		host->pdata->caps |= MMC_CAP_4_BIT_DATA;
+#endif
+
 	if (!host->pdata->select_slot && host->pdata->num_slots > 1) {
 		dev_err(host->dev,
 			"Platform data must supply select_slot function\n");
-- 
1.7.5.4

