From 7db5bc400fb32a8e93d516a17540dd5cfce2b7e5 Mon Sep 17 00:00:00 2001
From: Dinh Nguyen <dinguyen@altera.com>
Date: Mon, 22 Apr 2013 11:13:59 -0500
Subject: [PATCH 085/248] FogBugz #117096: Add support to gate peripheral
 clocks

Add support to gate the clocks that directly feed peripherals. For clocks
with multiple parents, add the ability to determine the correct parent,
and also set parents. Also add support to calculate and set the clocks'
rate.

[Original patch taken from
git://git.rocketboards.org/linux-socfpga.git socfpga-3.14]

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
Signed-off-by: Dinh Nguyen <dinguyen@altera.com>

v4:
- Add defines for more clocks

v3:
- Clean up from code reviews of get_parent/set_parent

V2:
- No longer needs to return clk in socfpga_gate_clk_init funtion
- Add recalc_rate and set_rate functionality
- nand_x_clk and nand_clk have the same parent
- Add define for l4_mp_clk
- All clocks that be gated/divided are entered
---
 .../devicetree/bindings/clock/altr_socfpga.txt     |   4 -
 drivers/clk/socfpga/clk.c                          | 177 +++++++++++++++++++++
 2 files changed, 177 insertions(+), 4 deletions(-)

diff --git a/Documentation/devicetree/bindings/clock/altr_socfpga.txt b/Documentation/devicetree/bindings/clock/altr_socfpga.txt
index 70c591b..c6695b1 100644
--- a/Documentation/devicetree/bindings/clock/altr_socfpga.txt
+++ b/Documentation/devicetree/bindings/clock/altr_socfpga.txt
@@ -23,8 +23,4 @@ Optional properties:
         and the bit index.
 - div-reg : For "socfpga-gate-clk", div-reg contains the divider register, bit shift,
         and width.
-- #clock-cells : from common clock binding; shall be set to 0.
-
-Optional properties:
-- fixed-divider : If clocks have a fixed divider value, use this property.
 
diff --git a/drivers/clk/socfpga/clk.c b/drivers/clk/socfpga/clk.c
index 04a1e4d..f482cb6 100644
--- a/drivers/clk/socfpga/clk.c
+++ b/drivers/clk/socfpga/clk.c
@@ -74,6 +74,8 @@ struct socfpga_clk {
 /* Clock Manager offsets */
 #define CLKMGR_CTRL    0x0
 #define CLKMGR_BYPASS 0x4
+#define CLKMGR_L4SRC	0x70
+#define CLKMGR_PERPLL_SRC	0xAC
 
 /* Clock bypass bits */
 #define MAINPLL_BYPASS (1<<0)
@@ -89,6 +91,16 @@ struct socfpga_clk {
 #define SOCFPGA_PLL_DIVF_SHIFT	3
 #define SOCFPGA_PLL_DIVQ_MASK		0x003F0000
 #define SOCFPGA_PLL_DIVQ_SHIFT	16
+#define SOCFGPA_MAX_PARENTS	3
+
+#define SOCFPGA_L4_MP_CLK			"l4_mp_clk"
+#define SOCFPGA_L4_SP_CLK			"l4_sp_clk"
+#define SOCFPGA_NAND_CLK		"nand_clk"
+#define SOCFPGA_NAND_X_CLK		"nand_x_clk"
+#define SOCFPGA_MMC_CLK			"mmc_clk"
+#define SOCFPGA_DB_CLK			"gpio_db_clk"
+
+#define div_mask(width)	((1 << (width)) - 1)
 
 extern void __iomem *clk_mgr_base_addr;
 
@@ -97,6 +109,9 @@ struct socfpga_clk {
 	char *parent_name;
 	char *clk_name;
 	u32 fixed_div;
+	void __iomem *div_reg;
+	u32 width;
+	u32 shift;
 };
 #define to_socfpga_clk(p) container_of(p, struct socfpga_clk, hw.hw)
 
@@ -196,6 +211,162 @@ static __init struct clk *socfpga_clk_init(struct device_node *node,
 	return clk;
 }
 
+static u8 socfpga_clk_get_parent(struct clk_hw *hwclk)
+{
+	u32 l4_src;
+	u32 perpll_src;
+	u8 parent;
+
+	if (strcmp(hwclk->init->name, SOCFPGA_L4_MP_CLK) == 0) {
+		l4_src = readl(clk_mgr_base_addr + CLKMGR_L4SRC);
+		l4_src &= 0x1;
+		parent = l4_src;
+	} else if (strcmp(hwclk->init->name, SOCFPGA_L4_SP_CLK) == 0) {
+		l4_src = readl(clk_mgr_base_addr + CLKMGR_L4SRC);
+		l4_src = ((l4_src & 0x2) >> 1);
+		parent = l4_src;
+	} else {
+		perpll_src = readl(clk_mgr_base_addr + CLKMGR_PERPLL_SRC);
+		if (strcmp(hwclk->init->name, SOCFPGA_MMC_CLK) == 0)
+			perpll_src &= 0x3;
+		else if (strcmp(hwclk->init->name, SOCFPGA_NAND_CLK) == 0 ||
+				strcmp(hwclk->init->name, SOCFPGA_NAND_X_CLK) == 0)
+			perpll_src = ((perpll_src & 0xC) >> 2);
+		else /*QSPI clock */
+			perpll_src = ((perpll_src & 0x30) >> 4);
+		parent = perpll_src;
+	}
+
+	return parent;
+}
+
+static int socfpga_clk_set_parent(struct clk_hw *hwclk, u8 parent)
+{
+	u32 src_reg;
+
+	if (strcmp(hwclk->init->name, SOCFPGA_L4_MP_CLK) == 0) {
+		src_reg = readl(clk_mgr_base_addr + CLKMGR_L4SRC);
+		src_reg &= ~0x1;
+		src_reg |= parent;
+		writel(src_reg, clk_mgr_base_addr + CLKMGR_L4SRC);
+	} else if (strcmp(hwclk->init->name, SOCFPGA_L4_SP_CLK) == 0) {
+		src_reg = readl(clk_mgr_base_addr + CLKMGR_L4SRC);
+		src_reg &= ~0x2;
+		src_reg |= (parent << 1);
+		writel(src_reg, clk_mgr_base_addr + CLKMGR_L4SRC);
+	} else {
+		src_reg = readl(clk_mgr_base_addr + CLKMGR_PERPLL_SRC);
+		if (strcmp(hwclk->init->name, SOCFPGA_MMC_CLK) == 0) {
+			src_reg &= ~0x3;
+			src_reg |= parent;
+		} else if (strcmp(hwclk->init->name, SOCFPGA_NAND_CLK) == 0 ||
+			strcmp(hwclk->init->name, SOCFPGA_NAND_X_CLK) == 0) {
+			src_reg &= ~0xC;
+			src_reg |= (parent << 2);
+		} else {/*QSPI clock */
+			src_reg &= ~0x30;
+			src_reg |= (parent << 4);
+		}
+		writel(src_reg, clk_mgr_base_addr + CLKMGR_PERPLL_SRC);
+	}
+
+	return 0;
+}
+
+static unsigned long socfpga_clk_recalc_rate(struct clk_hw *hwclk,
+	unsigned long parent_rate)
+{
+	struct socfpga_clk *socfpgaclk = to_socfpga_clk(hwclk);
+	u32 div = 1, val;
+
+	if (socfpgaclk->fixed_div)
+		div = socfpgaclk->fixed_div;
+	else if (socfpgaclk->div_reg) {
+		val = readl(socfpgaclk->div_reg) >> socfpgaclk->shift;
+		val &= div_mask(socfpgaclk->width);
+		if (strcmp(hwclk->init->name, SOCFPGA_DB_CLK) == 0)
+			div = val + 1;
+		else
+			div = (1 << val);
+	}
+
+	return parent_rate / div;
+}
+
+static struct clk_ops gateclk_ops = {
+	.recalc_rate = socfpga_clk_recalc_rate,
+	.get_parent = socfpga_clk_get_parent,
+	.set_parent = socfpga_clk_set_parent,
+};
+
+static void __init socfpga_gate_clk_init(struct device_node *node,
+	const struct clk_ops *ops)
+{
+	u32 clk_gate[2];
+	u32 div_reg[3];
+	u32 fixed_div;
+	struct clk *clk;
+	struct socfpga_clk *socfpga_clk;
+	const char *clk_name = node->name;
+	const char *parent_name[SOCFGPA_MAX_PARENTS];
+	struct clk_init_data init;
+	int rc;
+	int i = 0;
+
+	socfpga_clk = kzalloc(sizeof(*socfpga_clk), GFP_KERNEL);
+	if (WARN_ON(!socfpga_clk))
+		return;
+
+	rc = of_property_read_u32_array(node, "clk-gate", clk_gate, 2);
+	if (rc)
+		clk_gate[0] = 0;
+
+	rc = of_property_read_u32(node, "fixed-divider", &fixed_div);
+	if (rc)
+		socfpga_clk->fixed_div = 0;
+	else
+		socfpga_clk->fixed_div = fixed_div;
+
+	if (clk_gate[0]) {
+		socfpga_clk->hw.reg = clk_mgr_base_addr + clk_gate[0];
+		socfpga_clk->hw.bit_idx = clk_gate[1];
+
+		gateclk_ops.enable = clk_gate_ops.enable;
+		gateclk_ops.disable = clk_gate_ops.disable;
+	}
+
+	rc = of_property_read_u32_array(node, "div-reg", div_reg, 3);
+	if (!rc) {
+		socfpga_clk->div_reg = clk_mgr_base_addr + div_reg[0];
+		socfpga_clk->shift = div_reg[1];
+		socfpga_clk->width = div_reg[2];
+	} else {
+		socfpga_clk->div_reg = 0;
+	}
+
+	of_property_read_string(node, "clock-output-names", &clk_name);
+
+	init.name = clk_name;
+	init.ops = ops;
+	init.flags = 0;
+	while (i < SOCFGPA_MAX_PARENTS && (parent_name[i] =
+			of_clk_get_parent_name(node, i)) != NULL)
+		i++;
+
+	init.parent_names = parent_name;
+	init.num_parents = i;
+	socfpga_clk->hw.hw.init = &init;
+
+	clk = clk_register(NULL, &socfpga_clk->hw.hw);
+	if (WARN_ON(IS_ERR(clk))) {
+		kfree(socfpga_clk);
+		return;
+	}
+	rc = of_clk_add_provider(node, of_clk_src_simple_get, clk);
+	if (WARN_ON(rc))
+		return;
+}
+
 static void __init socfpga_pll_init(struct device_node *node)
 {
 	socfpga_clk_init(node, &clk_pll_ops);
@@ -206,10 +377,16 @@ static void __init socfpga_periph_init(struct device_node *node)
 	socfpga_clk_init(node, &periclk_ops);
 }
 
+static void __init socfpga_gate_init(struct device_node *node)
+{
+	socfpga_gate_clk_init(node, &gateclk_ops);
+}
+
 static const __initconst struct of_device_id clk_match[] = {
 	{ .compatible = "fixed-clock", .data = of_fixed_clk_setup, },
 	{ .compatible = "altr,socfpga-pll-clock", .data = socfpga_pll_init, },
 	{ .compatible = "altr,socfpga-perip-clk", .data = socfpga_periph_init, },
+	{ .compatible = "altr,socfpga-gate-clk", .data = socfpga_gate_init, },
 	{}
 };
 
-- 
1.9.1

