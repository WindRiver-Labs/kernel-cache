From f4a64fbffc565919298df867d33514d3646fa4a1 Mon Sep 17 00:00:00 2001
From: Dinh Nguyen <dinguyen@altera.com>
Date: Mon, 4 Mar 2013 10:18:23 -0600
Subject: [PATCH 062/248] FogBugz #106533: Add clock entries into device tree
 file.

Current clock support for SoCFPGA is statically enabled. By moving the clock
entries into device tree files, the Linux common clock framework can
dynamically return the correct clock rates.

To test this patch:
1) Need to recompile kernel with CONFIG_COMMON_CLK_DEBUG turned on
2) $cat /sys/kernel/debug/clk/osc1/main_pll/mpuclk/clk_rate
3) Should return 800 MHz.
4) $cat /sys/kernel/debug/clk/clk_summary   will show something like this:

$cat /sys/kernel/debug/clk/clk_summary
   clock                        enable_cnt  prepare_cnt  rate
---------------------------------------------------------------------
 osc1                           2           2            25000000
    sdram_pll                   0           0            400000000
       s2f_usr2_clk             0           0            66666666
       ddr_dq_clk               0           0            200000000
       ddr_2x_dqs_clk           0           0            400000000
       ddr_dqs_clk              0           0            200000000
    periph_pll                  2           2            500000000
       s2f_usr1_clk             0           0            50000000
       per_base_clk             4           4            100000000
       per_nand_mmc_clk         0           0            25000000
       per_qsi_clk              0           0            250000000
       emac1_clk                1           1            125000000
       emac0_clk                0           0            125000000
    main_pll                    1           1            1600000000
       cfg_s2f_usr0_clk         0           0            100000000
       main_nand_sdmmc_clk      0           0            100000000
       main_qspi_clk            0           0            400000000
       dbg_base_clk             0           0            400000000
       mainclk                  0           0            400000000
       mpuclk                   1           1            800000000
          smp_twd               1           1            200000000

This is a first in series of future patches to add proper clock support for
SoCFPGA. This patch does NOT have defines for the additional clocks that are
gated for peripherals. This patch only addresses the main PLL groups.

[Original patch taken from
git://git.rocketboards.org/linux-socfpga.git socfpga-3.14]

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
Signed-off-by: Dinh Nguyen <dinguyen@altera.com>

V5:
- Add error protection for !np and WARN_ON of_iomap() calls

V4:
- use device tree entries for fixed-divider clocks

V3:
- Renamed socfpga-clk-manager2.txt -> socfpga-clk-manager.txt
- Renamed altr_socfpga2.txt -> altr_socfpga.txt

V2:
- Added Documentation/devicetree/bindings/arm/altera/socfpga-clk-manager2.txt
- Added Documentation/devicetree/bindings/clock/altr_socfpga2.txt
- Added reading for the correct divider value for all clocks
- Added clock values for SDRAM PLL
- Added error checking for clk_register_clkdev()
---
 .../bindings/arm/altera/socfpga-clk-manager.txt    |   4 +
 .../devicetree/bindings/clock/altr_socfpga.txt     |   5 +
 arch/arm/boot/dts/socfpga.dtsi                     |  11 +
 arch/arm/boot/dts/socfpga_ice.dts                  |   8 +
 arch/arm/mach-socfpga/socfpga.c                    |  21 ++
 drivers/clk/socfpga/clk.c                          | 262 +++++++++++++--------
 6 files changed, 214 insertions(+), 97 deletions(-)

diff --git a/Documentation/devicetree/bindings/arm/altera/socfpga-clk-manager.txt b/Documentation/devicetree/bindings/arm/altera/socfpga-clk-manager.txt
index 2c28f1d..a9df91f 100644
--- a/Documentation/devicetree/bindings/arm/altera/socfpga-clk-manager.txt
+++ b/Documentation/devicetree/bindings/arm/altera/socfpga-clk-manager.txt
@@ -2,7 +2,11 @@ Altera SOCFPGA Clock Manager
 
 Required properties:
 - compatible : "altr,clk-mgr"
+<<<<<<< HEAD
 - reg : Should contain base address and length for Clock Manager
+=======
+- reg : Should contain 1 register ranges(address and length)
+>>>>>>> FogBugz #106533: Add clock entries into device tree file.
 
 Example:
 	 clkmgr@ffd04000 {
diff --git a/Documentation/devicetree/bindings/clock/altr_socfpga.txt b/Documentation/devicetree/bindings/clock/altr_socfpga.txt
index 0045433..70c591b 100644
--- a/Documentation/devicetree/bindings/clock/altr_socfpga.txt
+++ b/Documentation/devicetree/bindings/clock/altr_socfpga.txt
@@ -23,3 +23,8 @@ Optional properties:
         and the bit index.
 - div-reg : For "socfpga-gate-clk", div-reg contains the divider register, bit shift,
         and width.
+- #clock-cells : from common clock binding; shall be set to 0.
+
+Optional properties:
+- fixed-divider : If clocks have a fixed divider value, use this property.
+
diff --git a/arch/arm/boot/dts/socfpga.dtsi b/arch/arm/boot/dts/socfpga.dtsi
index 50d13aa..7885cec 100644
--- a/arch/arm/boot/dts/socfpga.dtsi
+++ b/arch/arm/boot/dts/socfpga.dtsi
@@ -465,6 +465,8 @@
 			clocks = <&emac0_clk>;
 			clock-names = "stmmaceth";
 			status = "disabled";
+			clocks = <&emac0_clk>;
+			clock-names = "stmmaceth";
 		};
 
 		gmac1: ethernet@ff702000 {
@@ -476,6 +478,8 @@
 			clocks = <&emac1_clk>;
 			clock-names = "stmmaceth";
 			status = "disabled";
+			clocks = <&emac1_clk>;
+			clock-names = "stmmaceth";
 		};
 
 		gpio0: gpio@ff708000 {
@@ -488,6 +492,7 @@
 			#interrupt-cells = <2>;
 			gpio-controller;
 			#gpio-cells = <2>;
+			clocks = <&per_base_clk>;
 		};
 
 		gpio1: gpio@ff709000 {
@@ -500,6 +505,7 @@
 			#interrupt-cells = <2>;
 			gpio-controller;
 			#gpio-cells = <2>;
+			clocks = <&per_base_clk>;
 		};
 
 		gpio2: gpio@ff70a000 {
@@ -512,6 +518,7 @@
 			#interrupt-cells = <2>;
 			gpio-controller;
 			#gpio-cells = <2>;
+			clocks = <&per_base_clk>;
 		};
 
 		L2: l2-cache@fffef000 {
@@ -566,6 +573,7 @@
 			bus-num = <0>;
 			tx-dma-channel = <&pdma 16>;
 			rx-dma-channel = <&pdma 17>;
+			clocks = <&per_base_clk>;
 
 			spidev@0 {
 				compatible = "spidev";
@@ -585,6 +593,7 @@
 			bus-num = <1>;
 			tx-dma-channel = <&pdma 20>;
 			rx-dma-channel = <&pdma 21>;
+			clocks = <&per_base_clk>;
 
 			spidev@0 {
 				compatible = "spidev";
@@ -673,6 +682,7 @@
 			reg = <0xffc04000 0x1000>;
 			interrupts = <0 158 4>;
 			emptyfifo_hold_master = <1>;
+			clocks = <&per_base_clk>;
 		};
 
 		i2c1: i2c@ffc05000 {
@@ -682,6 +692,7 @@
 			reg = <0xffc05000 0x1000>;
 			interrupts = <0 159 4>;
 			emptyfifo_hold_master = <1>;
+			clocks = <&per_base_clk>;
 		};
 	};
 };
diff --git a/arch/arm/boot/dts/socfpga_ice.dts b/arch/arm/boot/dts/socfpga_ice.dts
index 4522181..f406e1e 100644
--- a/arch/arm/boot/dts/socfpga_ice.dts
+++ b/arch/arm/boot/dts/socfpga_ice.dts
@@ -33,6 +33,14 @@
 	};
 
 	soc {
+		clkmgr@ffd04000 {
+			clocks {
+				osc1 {
+					clock-frequency = <10000000>;
+				};
+			};
+		};
+
 		qspi: spi@ff705000 {
 				compatible = "cadence,qspi";
 				#address-cells = <1>;
diff --git a/arch/arm/mach-socfpga/socfpga.c b/arch/arm/mach-socfpga/socfpga.c
index e4c6e1d..090ca41 100644
--- a/arch/arm/mach-socfpga/socfpga.c
+++ b/arch/arm/mach-socfpga/socfpga.c
@@ -39,6 +39,7 @@ void __iomem *socfpga_scu_base_addr = ((void __iomem *)(SOCFPGA_SCU_VIRT_BASE));
 void __iomem *sys_manager_base_addr;
 void __iomem *rst_manager_base_addr;
 
+void __iomem *clk_mgr_base_addr;
 unsigned long	cpu1start_addr;
 
 static int socfpga_phy_reset_mii(struct mii_bus *bus, int phyaddr);
@@ -265,15 +266,35 @@ static void __init socfpga_sysmgr_init(void)
 	struct device_node *np;
 
 	np = of_find_compatible_node(NULL, NULL, "altr,sys-mgr");
+	if (!np) {
+		pr_err("SOCFPGA: Unable to find sys-magr in dtb\n");
+		return;
+	}
 
 	if (of_property_read_u32(np, "cpu1-start-addr",
 			(u32 *) &cpu1start_addr))
 		pr_err("SMP: Need cpu1-start-addr in device tree.\n");
 
 	sys_manager_base_addr = of_iomap(np, 0);
+	WARN_ON(!sys_manager_base_addr);
 
 	np = of_find_compatible_node(NULL, NULL, "altr,rst-mgr");
+	if (!np) {
+		pr_err("SOCFPGA: Unable to find rst-mgr in dtb\n");
+		return;
+	}
+
 	rst_manager_base_addr = of_iomap(np, 0);
+	WARN_ON(!rst_manager_base_addr);
+
+	np = of_find_compatible_node(NULL, NULL, "altr,clk-mgr");
+	if (!np) {
+		pr_err("SOCFPGA: Unable to find clk-mgr\n");
+		return;
+	}
+
+	clk_mgr_base_addr = of_iomap(np, 0);
+	WARN_ON(!clk_mgr_base_addr);
 }
 
 static void __init socfpga_map_io(void)
diff --git a/drivers/clk/socfpga/clk.c b/drivers/clk/socfpga/clk.c
index e73b366..2a9a4bc 100644
--- a/drivers/clk/socfpga/clk.c
+++ b/drivers/clk/socfpga/clk.c
@@ -71,7 +71,163 @@ struct socfpga_clk {
 };
 #define to_socfpga_clk(p) container_of(p, struct socfpga_clk, hw.hw)
 
-void __iomem *clk_mgr_base_addr;
+/* Clock Manager offsets */
+#define CLKMGR_CTRL	0x0
+#define CLKMGR_BYPASS 0x4
+
+/* Clock bypass bits */
+#define MAINPLL_BYPASS (1<<0)
+#define SDRAMPLL_BYPASS (1<<1)
+#define SDRAMPLL_SRC_BYPASS (1<<2)
+#define PERPLL_BYPASS (1<<3)
+#define PERPLL_SRC_BYPASS (1<<4)
+
+#define SOCFPGA_PLL_BG_PWRDWN	0x00000001
+#define SOCFPGA_PLL_EXT_ENA	0x00000002
+#define SOCFPGA_PLL_PWR_DOWN	0x00000004
+#define SOCFPGA_PLL_DIVF_MASK 0x0000FFF8
+#define SOCFPGA_PLL_DIVF_SHIFT 3
+#define SOCFPGA_PLL_DIVQ_MASK 0x003F0000
+#define SOCFPGA_PLL_DIVQ_SHIFT 15
+
+extern void __iomem *clk_mgr_base_addr;
+
+struct socfpga_clk {
+	struct clk_hw hw;
+	void __iomem	*reg;
+	char *parent_name;
+	u32 fixed_div;
+};
+#define to_socfpga_clk(p) container_of(p, struct socfpga_clk, hw)
+
+static int clk_pll_enable(struct clk_hw *hwclk)
+{
+	struct socfpga_clk *socfpgaclk = to_socfpga_clk(hwclk);
+	u32 reg;
+
+	reg = readl(socfpgaclk->reg);
+	reg |= SOCFPGA_PLL_EXT_ENA;
+	writel(reg, socfpgaclk->reg);
+
+	return 0;
+}
+
+static void clk_pll_disable(struct clk_hw *hwclk)
+{
+	struct socfpga_clk *socfpgaclk = to_socfpga_clk(hwclk);
+	u32 reg;
+
+	reg = readl(socfpgaclk->reg);
+	reg &= ~SOCFPGA_PLL_EXT_ENA;
+	writel(reg, socfpgaclk->reg);
+}
+
+static unsigned long clk_pll_recalc_rate(struct clk_hw *hwclk,
+					 unsigned long parent_rate)
+{
+	struct socfpga_clk *socfpgaclk = to_socfpga_clk(hwclk);
+	unsigned long divf, divq, vco_freq, reg;
+	unsigned long bypass;
+
+	reg = readl(socfpgaclk->reg);
+	bypass = readl(clk_mgr_base_addr + CLKMGR_BYPASS);
+	if (bypass & MAINPLL_BYPASS)
+		return parent_rate;
+
+	divf = (reg & SOCFPGA_PLL_DIVF_MASK) >> SOCFPGA_PLL_DIVF_SHIFT;
+	divq = (reg & SOCFPGA_PLL_DIVQ_MASK) >> SOCFPGA_PLL_DIVQ_SHIFT;
+	vco_freq = parent_rate * (divf + 1);
+	return vco_freq / (1 << divq);
+}
+
+
+static const struct clk_ops clk_pll_ops = {
+	.enable = clk_pll_enable,
+	.disable = clk_pll_disable,
+	.recalc_rate = clk_pll_recalc_rate,
+};
+
+static unsigned long clk_periclk_recalc_rate(struct clk_hw *hwclk,
+					     unsigned long parent_rate)
+{
+	struct socfpga_clk *socfpgaclk = to_socfpga_clk(hwclk);
+	u32 div;
+
+	if (socfpgaclk->fixed_div)
+		div = socfpgaclk->fixed_div;
+	else
+		div = ((readl(socfpgaclk->reg) & 0x1ff) + 1);
+
+	return parent_rate / div;
+}
+
+static const struct clk_ops periclk_ops = {
+	.recalc_rate = clk_periclk_recalc_rate,
+};
+
+static __init struct clk *socfpga_clk_init(struct device_node *node, const struct clk_ops *ops)
+{
+	u32 reg;
+	struct clk *clk;
+	struct socfpga_clk *socfpga_clk;
+	const char *clk_name = node->name;
+	const char *parent_name;
+	struct clk_init_data init;
+	int rc;
+	u32 fixed_div;
+
+	rc = of_property_read_u32(node, "reg", &reg);
+	if (WARN_ON(rc))
+		return NULL;
+
+	socfpga_clk = kzalloc(sizeof(*socfpga_clk), GFP_KERNEL);
+	if (WARN_ON(!socfpga_clk))
+		return NULL;
+
+	socfpga_clk->reg = clk_mgr_base_addr + reg;
+
+	rc = of_property_read_u32(node, "fixed-divider", &fixed_div);
+	if (rc)
+		socfpga_clk->fixed_div = 0;
+	else
+		socfpga_clk->fixed_div = fixed_div;
+
+	of_property_read_string(node, "clock-output-names", &clk_name);
+
+	init.name = clk_name;
+	init.ops = ops;
+	init.flags = 0;
+	parent_name = of_clk_get_parent_name(node, 0);
+	init.parent_names = &parent_name;
+	init.num_parents = 1;
+
+	socfpga_clk->hw.init = &init;
+
+	clk = clk_register(NULL, &socfpga_clk->hw);
+	if (WARN_ON(IS_ERR(clk))) {
+		kfree(socfpga_clk);
+		return NULL;
+	}
+	rc = of_clk_add_provider(node, of_clk_src_simple_get, clk);
+	return clk;
+}
+
+static void __init socfpga_pll_init(struct device_node *node)
+{
+	socfpga_clk_init(node, &clk_pll_ops);
+}
+
+static void __init socfpga_periph_init(struct device_node *node)
+{
+	socfpga_clk_init(node, &periclk_ops);
+}
+
+static const __initconst struct of_device_id clk_match[] = {
+	{ .compatible = "fixed-clock", .data = of_fixed_clk_setup, },
+	{ .compatible = "altr,socfpga-pll-clock", .data = socfpga_pll_init, },
+	{ .compatible = "altr,socfpga-perip-clk", .data = socfpga_periph_init, },
+	{}
+};
 
 void __init socfpga_init_clocks(void)
 {
@@ -118,100 +274,12 @@ static __init struct clk *socfpga_clk_init(struct device_node *node,
 {
 	u32 reg;
 	struct clk *clk;
-	struct device_node *np;
-
-	np = of_find_compatible_node(NULL, NULL, "altr,clk-mgr");
-	clk_mgr_base_addr = of_iomap(np, 0);
-
-	clk = clk_register_fixed_rate(NULL, "main_pll_clk", NULL, CLK_IS_ROOT,
-			SOCFPGA_MAIN_PLL_CLK);
-	clk_register_clkdev(clk, "main_pll_clk", NULL);
-
-	clk = clk_register_fixed_rate(NULL, "per_pll_clk", NULL, CLK_IS_ROOT,
-			SOCFPGA_PER_PLL_CLK);
-	clk_register_clkdev(clk, "per_pll_clk", NULL);
-
-	clk = clk_register_fixed_rate(NULL, "sdram_pll_clk", NULL, CLK_IS_ROOT,
-			SOCFPGA_SDRAM_PLL_CLK);
-	clk_register_clkdev(clk, "sdram_pll_clk", NULL);
-
-	clk = clk_register_fixed_rate(NULL, "osc1_clk", NULL, CLK_IS_ROOT,
-			SOCFPGA_OSC1_CLK);
-	clk_register_clkdev(clk, "osc1_clk", NULL);
-
-	clk = clk_register_fixed_rate(NULL, "mpu_clk", NULL, CLK_IS_ROOT,
-			SOCFPGA_MPU_CLK);
-	clk_register_clkdev(clk, "mpu_clk", NULL);
-
-	clk = clk_register_fixed_rate(NULL, "main_clk", NULL, CLK_IS_ROOT,
-			SOCFPGA_MPU_CLK/2);
-	clk_register_clkdev(clk, "main_clk", NULL);
-
-	clk = clk_register_fixed_rate(NULL, "dbg_base_clk", NULL, CLK_IS_ROOT,
-			SOCFPGA_MPU_CLK/2);
-	clk_register_clkdev(clk, "dbg_base_clk", NULL);
-
-	clk = clk_register_fixed_rate(NULL, "smp_twd", NULL, CLK_IS_ROOT,
-			SOCFPGA_MPU_CLK/4);
-	clk_register_clkdev(clk, NULL, "smp_twd");
-
-	clk = clk_register_fixed_rate(NULL, "main_qspi_clk", NULL, CLK_IS_ROOT,
-			SOCFPGA_MAIN_QSPI_CLK);
-	clk_register_clkdev(clk, "main_qspi_clk", NULL);
-
-	clk = clk_register_fixed_rate(NULL, "main_nand_sdmmc_clk", NULL,
-			CLK_IS_ROOT, SOCFPGA_MAIN_NAND_SDMMC_CLK);
-	clk_register_clkdev(clk, "main_nand_sdmmc_clk", NULL);
-
-	clk = clk_register_fixed_rate(NULL, "s2f_usr_clk", NULL, CLK_IS_ROOT,
-			SOCFPGA_S2F_USR_CLK);
-	clk_register_clkdev(clk, "s2f_usr_clk", NULL);
-
-	clk = clk_register_fixed_rate(NULL, "i2c0_clk", NULL, CLK_IS_ROOT,
-			SOCFPGA_PER_PLL_CLK);
-	clk_register_clkdev(clk, NULL, "ffc04000.i2c");
-
-	clk = clk_register_fixed_rate(NULL, "i2c1_clk", NULL, CLK_IS_ROOT,
-			SOCFPGA_PER_PLL_CLK);
-	clk_register_clkdev(clk, NULL, "ffc05000.i2c");
-
-	clk = clk_register_gate(NULL, "gmac0_clk", "per_pll_clk", 0,
-			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
-			CLKMGR_EMAC0_CLK_EN, 0, &_lock);
-	clk_register_clkdev(clk, NULL, "ff700000.ethernet");
-
-	clk = clk_register_gate(NULL, "gmac1_clk", "per_pll_clk", 0,
-			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
-			CLKMGR_EMAC1_CLK_EN, 0, &_lock);
-	clk_register_clkdev(clk, NULL, "ff702000.ethernet");
-
-	clk = clk_register_gate(NULL, "spi0_clk", "per_pll_clk", 0,
-			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
-			CLKMGR_SPI_M_CLK_EN, 0, &_lock);
-	clk_register_clkdev(clk, NULL, "fff00000.spi");
-
-	clk = clk_register_gate(NULL, "spi1_clk", "per_pll_clk", 0,
-			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
-			CLKMGR_SPI_M_CLK_EN, 0, &_lock);
-	clk_register_clkdev(clk, NULL, "fff01000.spi");
-
-	clk = clk_register_gate(NULL, "gpio0_clk", "per_pll_clk", 0,
-			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
-			CLKMGR_GPIO_CLK_EN, 0, &_lock);
-	clk_register_clkdev(clk, NULL, "ff708000.gpio");
-
-	clk = clk_register_gate(NULL, "gpio1_clk", "per_pll_clk", 0,
-			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
-			CLKMGR_GPIO_CLK_EN, 0, &_lock);
-	clk_register_clkdev(clk, NULL, "ff709000.gpio");
-
-	clk = clk_register_gate(NULL, "gpio2_clk", "per_pll_clk", 0,
-			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
-			CLKMGR_GPIO_CLK_EN, 0, &_lock);
-	clk_register_clkdev(clk, NULL, "ff70a000.gpio");
-
-	clk = clk_register_gate(NULL, "nand_clk", "main_nand_sdmmc_clk", 0,
-			clk_mgr_base_addr + CLKMGR_PERPLLGRP_EN,
-			CLKMGR_NAND_CLK_EN, 0, &_lock);
-	clk_register_clkdev(clk, NULL, "ff900000.nand");
+	int ret;
+
+	of_clk_init(clk_match);
+
+	clk = clk_register_fixed_factor(NULL, "smp_twd", "mpuclk", 0, 1, 4);
+	ret = clk_register_clkdev(clk, NULL, "smp_twd");
+	if (ret)
+		pr_err("smp_twd alias not registered\n");
 }
-- 
1.9.1

