From 4a4912bee9d12a6c556a7a654cbbd56517a75b03 Mon Sep 17 00:00:00 2001
From: Thor Thayer <tthayer@altera.com>
Date: Thu, 31 Oct 2013 10:48:11 -0500
Subject: [PATCH 148/248] FogBugz #165063: SDRAM ECC Error Injection for
 Testing

The current SDRAM ECC testing was performed by shorting an address
line to ground. In the case of an uncorrectable error (2 bit error)
2 address lines had to be shorted to ground.
The Altera SDRAM controller has the ability to inject ECC errors
(single or double bit) during write operations. This change
implements the injection of SDRAM ECC errors in software.
- Requires that EDAC debugging (CONFIG_EDAC_DEBUG) is defined.
- Single or double bit errors are generated depending upon
  string size sent (1 character = 1 bit error/2 char=2bit)
- To inject a single bit error (correctable)
       echo "1" > /sys/kernel/debug/edac/mc0/inject_ctl
- To inject a double bit error (uncorrectable - panic)
       echo "12" > /sys/kernel/debug/edac/mc0/inject_ctl

V2:
- Make double bit error case very restrictive

[Original patch taken from
git://git.rocketboards.org/linux-socfpga.git socfpga-3.14]

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
Signed-off-by: Thor Thayer <tthayer@altera.com>
---
 drivers/edac/altera_mc_edac.c | 63 +++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 63 insertions(+)

diff --git a/drivers/edac/altera_mc_edac.c b/drivers/edac/altera_mc_edac.c
index 8fa0001..db4b950 100644
--- a/drivers/edac/altera_mc_edac.c
+++ b/drivers/edac/altera_mc_edac.c
@@ -128,6 +128,67 @@ static irqreturn_t altr_sdram_mc_err_handler(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+#ifdef CONFIG_EDAC_DEBUG
+static ssize_t altr_sdr_mc_err_inject_write(struct file *file,
+					const char __user *data,
+					size_t count, loff_t *ppos)
+{
+	struct mem_ctl_info *mci = file->private_data;
+	struct altr_sdram_mc_data *drvdata = mci->pvt_info;
+	u32 *ptemp;
+	dma_addr_t dma_handle;
+	u32 reg, read_reg = 0;
+
+	ptemp = dma_alloc_coherent(mci->pdev, 16, &dma_handle, GFP_KERNEL);
+	if (IS_ERR(ptemp)) {
+		dma_free_coherent(mci->pdev, 16, ptemp, dma_handle);
+		dev_err(mci->pdev, "**EDAC Inject: Buffer Allocation error\n");
+		return -ENOMEM;
+	}
+
+	regmap_read(drvdata->mc_vbase, ALTR_SDR_CTLCFG, &read_reg);
+	read_reg &= ~(ALTR_SDR_CTLCFG_GEN_SB_ERR | ALTR_SDR_CTLCFG_GEN_DB_ERR);
+
+	if (count == 3) {
+		dev_alert(mci->pdev, "** EDAC Inject Double bit error\n");
+		regmap_write(drvdata->mc_vbase, ALTR_SDR_CTLCFG,
+				(read_reg | ALTR_SDR_CTLCFG_GEN_DB_ERR));
+	} else {
+		dev_alert(mci->pdev, "** EDAC Inject Single bit error\n");
+		regmap_write(drvdata->mc_vbase,	ALTR_SDR_CTLCFG,
+				(read_reg | ALTR_SDR_CTLCFG_GEN_SB_ERR));
+	}
+
+	ptemp[0] = 0x5A5A5A5A;
+	ptemp[1] = 0xA5A5A5A5;
+	regmap_write(drvdata->mc_vbase,	ALTR_SDR_CTLCFG, read_reg);
+	wmb();
+
+	reg = ptemp[0];
+	read_reg = ptemp[1];
+
+	dma_free_coherent(mci->pdev, 16, ptemp, dma_handle);
+
+	return count;
+}
+
+static const struct file_operations altr_sdr_mc_debug_inject_fops = {
+	.open = simple_open,
+	.write = altr_sdr_mc_err_inject_write,
+	.llseek = generic_file_llseek,
+};
+
+static void altr_sdr_mc_create_debugfs_nodes(struct mem_ctl_info *mci)
+{
+	if (mci->debugfs)
+		debugfs_create_file("inject_ctrl", S_IWUSR, mci->debugfs, mci,
+			&altr_sdr_mc_debug_inject_fops);
+}
+#else
+static void altr_sdr_mc_create_debugfs_nodes(struct mem_ctl_info *mci)
+{}
+#endif
+
 /* Get total memory size from Open Firmware DTB */
 static u32 altr_sdram_get_total_mem_size(void)
 {
@@ -250,6 +311,8 @@ static int altr_sdram_mc_probe(struct platform_device *pdev)
 		goto err;
 	}
 
+	altr_sdr_mc_create_debugfs_nodes(mci);
+
 	devres_close_group(&pdev->dev, NULL);
 
 	return 0;
-- 
1.9.1

