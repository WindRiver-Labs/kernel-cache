From 1f704d75328915400e5351ae1bd17a5343e87dba Mon Sep 17 00:00:00 2001
From: Lisa Treweek <ltreweek@altera.com>
Date: Mon, 4 Feb 2013 15:20:10 -0600
Subject: [PATCH 048/248] FogBugz #97997: masked out gmac mmc interrupts.

The gmac mmc interrupts are not handled.  This causes an infinite loop
on transfers larger then 2G.  These interrupts were from the gmac
checksum offset counter and other rx/tx counters.

So, we masked these interrupts so they will not trigger.

[Original patch taken from
git://git.rocketboards.org/linux-socfpga.git socfpga-3.14]

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
Signed-off-by: Lisa Treweek <ltreweek@altera.com>
---
 drivers/net/ethernet/stmicro/stmmac/dwmac1000.h      |  3 +++
 drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c | 10 ++++++++++
 2 files changed, 13 insertions(+)

diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h b/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h
index f37d90f..8587804 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac1000.h
@@ -260,6 +260,9 @@ enum rtc_control {
 #define GMAC_MMC_CTRL      0x100
 #define GMAC_MMC_RX_INTR   0x104
 #define GMAC_MMC_TX_INTR   0x108
+#define GMAC_MMC_INTR_MASK_RX		  0x10C
+#define GMAC_MMC_INTR_MASK_TX		  0x110
+#define GMAC_MMC_IPC_INTR_MASK_RX  0x200
 #define GMAC_MMC_RX_CSUM_OFFLOAD   0x208
 
 extern const struct stmmac_dma_ops dwmac1000_dma_ops;
diff --git a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
index b3e148e..5019ee0 100644
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac1000_core.c
@@ -46,6 +46,11 @@ static void dwmac1000_core_init(void __iomem *ioaddr, int mtu)
 	/* Mask GMAC interrupts */
 	writel(0x207, ioaddr + GMAC_INT_MASK);
 
+	/* mask out interrupts because we don't handle them yet */
+	writel(~0UL, ioaddr + GMAC_MMC_INTR_MASK_RX);
+	writel(~0UL, ioaddr + GMAC_MMC_INTR_MASK_TX);
+	writel(~0UL, ioaddr + GMAC_MMC_IPC_INTR_MASK_RX);
+
 #ifdef STMMAC_VLAN_TAG_USED
 	/* Tag detection without filtering */
 	writel(0x0, ioaddr + GMAC_VLAN_TAG);
@@ -206,6 +211,7 @@ static int dwmac1000_irq_status(void __iomem *ioaddr,
 {
 	u32 intr_status = readl(ioaddr + GMAC_INT_STATUS);
 	int ret = 0;
+	u32 value;
 
 	/* Not used events (e.g. MMC interrupts) are not handled. */
 	if ((intr_status & mmc_tx_irq))
@@ -219,6 +225,10 @@ static int dwmac1000_irq_status(void __iomem *ioaddr,
 		readl(ioaddr + GMAC_PMT);
 		x->irq_receive_pmt_irq_n++;
 	}
+	if (unlikely(intr_status & rgmii_irq)) {
+		/* clear this link change interrupt because we are not handling it yet. */
+		value = readl(ioaddr + GMAC_S_R_GMII);
+	}
 	/* MAC trx/rx EEE LPI entry/exit interrupts */
 	if (intr_status & lpiis_irq) {
 		/* Clean LPI interrupt by reading the Reg 12 */
-- 
1.9.1

