From 76c144772ee5accab15554f1549e4b5b1955dd49 Mon Sep 17 00:00:00 2001
From: Dinh Nguyen <dinguyen@altera.com>
Date: Wed, 20 Mar 2013 08:23:53 -0500
Subject: [PATCH 12/12] arm/perf: Enable PMU through the CTI

commit 7f22064e964314939cbd8ff0b10fa718de06c890
git://git.rocketboards.org/linux-socfpga.git socfpga-3.10-ltsi branch

SocFPGA has a PMU(Performance Measurement Unit) that has its
IRQs routed through Coresight using the CTI(Cross-Trigger Interface).

This patch enables the PMU and initializes the CTI for usage by
oprofile/perfmon.

Signed-off-by: Dinh Nguyen <dinguyen@altera.com>

v6:
- Reworked socfpga_pmu_handler to be bounded
- Switched from pr_err/pr_info to dev_err/dev_info
- Use np=pdev
- Add defines for CTI channels

v5:
- Add error tags to free_irq and iounmap

v4:
- Add CTI_MPU_IRQ_TRIG_IN and CTI_MPU_IRQ_TRIG_OUT defines
- Use cortex-a9-pmu as the parent node
- Wrap socfpga_pmu_platdata around CONFIG_HW_PERF_EVENTS

v3:
- Add platform functions to stop and start the CTI

V2:
- Add device tree entries for CTI
- Use platform_get_irq(pdev,1) for 2nd CTI irq
[Add a condition to check if plat is not equal to NULL]
Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 arch/arm/boot/dts/socfpga.dtsi      |   18 +++++
 arch/arm/include/asm/pmu.h          |    3 +
 arch/arm/kernel/perf_event.c        |   16 +++++
 arch/arm/mach-socfpga/Makefile      |    1 +
 arch/arm/mach-socfpga/socfpga.c     |   14 ++++
 arch/arm/mach-socfpga/socfpga_cti.c |  125 +++++++++++++++++++++++++++++++++++
 arch/arm/mach-socfpga/socfpga_cti.h |   16 +++++
 7 files changed, 193 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-socfpga/socfpga_cti.c
 create mode 100644 arch/arm/mach-socfpga/socfpga_cti.h

diff --git a/arch/arm/boot/dts/socfpga.dtsi b/arch/arm/boot/dts/socfpga.dtsi
index 131ade8..6d5a5a2 100644
--- a/arch/arm/boot/dts/socfpga.dtsi
+++ b/arch/arm/boot/dts/socfpga.dtsi
@@ -598,6 +598,24 @@
 			clocks = <&nand_clk>;
 			};
 
+		pmu {
+			#address-cells = <1>;
+			#size-cells = <1>;
+			compatible = "arm,cortex-a9-pmu";
+			interrupts = <0 176 4>, <0 177 4>;
+			ranges;
+
+			cti0: cti0@ff118000 {
+				compatible = "arm,coresight-cti";
+				reg = <0xff118000 0x100>;
+			};
+
+			cti1: cti1@ff119000 {
+				compatible = "arm,coresight-cti";
+				reg = <0xff119000 0x100>;
+			};
+		};
+
 		rstmgr@ffd05000 {
 			compatible = "altr,rst-mgr";
 			reg = <0xffd05000 0x1000>;
diff --git a/arch/arm/include/asm/pmu.h b/arch/arm/include/asm/pmu.h
index 08ccd57..229ceb1 100644
--- a/arch/arm/include/asm/pmu.h
+++ b/arch/arm/include/asm/pmu.h
@@ -47,6 +47,9 @@ struct arm_pmu_platdata {
 				  irq_handler_t pmu_handler);
 	int (*runtime_resume)(struct device *dev);
 	int (*runtime_suspend)(struct device *dev);
+	int (*init)(struct platform_device *pdev);
+	int (*start)(struct platform_device *pdev);
+	int (*stop)(struct platform_device *pdev);
 };
 
 #ifdef CONFIG_HW_PERF_EVENTS
diff --git a/arch/arm/kernel/perf_event.c b/arch/arm/kernel/perf_event.c
index 0354bf0..ed5c462 100644
--- a/arch/arm/kernel/perf_event.c
+++ b/arch/arm/kernel/perf_event.c
@@ -315,6 +315,11 @@ static irqreturn_t armpmu_dispatch_irq(int irq, void *dev)
 static void
 armpmu_release_hardware(struct arm_pmu *armpmu)
 {
+	struct platform_device *plat_device = armpmu->plat_device;
+	struct arm_pmu_platdata *plat = dev_get_platdata(&plat_device->dev);
+
+	if (plat && plat->stop)
+		plat->stop(plat_device);
 	armpmu->free_irq();
 	pm_runtime_put_sync(&armpmu->plat_device->dev);
 }
@@ -324,6 +329,7 @@ armpmu_reserve_hardware(struct arm_pmu *armpmu)
 {
 	int err;
 	struct platform_device *pmu_device = armpmu->plat_device;
+	struct arm_pmu_platdata *plat = dev_get_platdata(&pmu_device->dev);
 
 	if (!pmu_device)
 		return -ENODEV;
@@ -334,6 +340,8 @@ armpmu_reserve_hardware(struct arm_pmu *armpmu)
 		armpmu_release_hardware(armpmu);
 		return err;
 	}
+	if (plat && plat->start)
+		plat->start(pmu_device);
 
 	return 0;
 }
@@ -518,9 +526,17 @@ static void __init armpmu_init(struct arm_pmu *armpmu)
 
 int armpmu_register(struct arm_pmu *armpmu, char *name, int type)
 {
+	struct platform_device *plat_device = armpmu->plat_device;
+	struct arm_pmu_platdata *plat = dev_get_platdata(&plat_device->dev);
+
 	armpmu_init(armpmu);
 	pr_info("enabled with %s PMU driver, %d counters available\n",
 			armpmu->name, armpmu->num_events);
+
+	/* Platform specific initialization. ie. CTI enable */
+	if (plat && plat->init)
+		plat->init(plat_device);
+
 	return perf_pmu_register(&armpmu->pmu, name, type);
 }
 
diff --git a/arch/arm/mach-socfpga/Makefile b/arch/arm/mach-socfpga/Makefile
index e50957b..37a69e0 100644
--- a/arch/arm/mach-socfpga/Makefile
+++ b/arch/arm/mach-socfpga/Makefile
@@ -4,6 +4,7 @@
 
 obj-y					:= socfpga.o dma.o
 obj-$(CONFIG_SMP)	+= headsmp.o platsmp.o
+obj-$(CONFIG_HW_PERF_EVENTS) += socfpga_cti.o
 
 # Interconnect pcie bus driver for Altera SoCs.
 obj-$(CONFIG_ALTERA_PCIE_RP) += altera_pcie.o
diff --git a/arch/arm/mach-socfpga/socfpga.c b/arch/arm/mach-socfpga/socfpga.c
index 958a5d9..91cb79a 100644
--- a/arch/arm/mach-socfpga/socfpga.c
+++ b/arch/arm/mach-socfpga/socfpga.c
@@ -30,8 +30,10 @@
 #include <asm/mach/arch.h>
 #include <asm/mach/map.h>
 #include <asm/smp_twd.h>
+#include <asm/pmu.h>
 
 #include "core.h"
+#include "socfpga_cti.h"
 #include "dma.h"
 
 void __iomem *socfpga_scu_base_addr = ((void __iomem *)(SOCFPGA_SCU_VIRT_BASE));
@@ -52,6 +54,15 @@ static struct plat_stmmacenet_data stmmacenet1_data = {
 	.bus_id = 1,
 };
 
+#ifdef CONFIG_HW_PERF_EVENTS
+static struct arm_pmu_platdata socfpga_pmu_platdata = {
+	.handle_irq = socfpga_pmu_handler,
+	.init = socfpga_init_cti,
+	.start = socfpga_start_cti,
+	.stop = socfpga_stop_cti,
+};
+#endif
+
 static const struct of_dev_auxdata socfpga_auxdata_lookup[] __initconst = {
 	OF_DEV_AUXDATA("snps,dwmac-3.70a", 0xff700000, NULL, &stmmacenet0_data),
 	OF_DEV_AUXDATA("snps,dwmac-3.70a", 0xff702000, NULL, &stmmacenet1_data),
@@ -59,6 +70,9 @@ static const struct of_dev_auxdata socfpga_auxdata_lookup[] __initconst = {
 		&dma_platform_data),
 	OF_DEV_AUXDATA("arm,pl330", 0xffe01000, "dma-pl330",
 		&dma_platform_data),
+#ifdef CONFIG_HW_PERF_EVENTS
+	OF_DEV_AUXDATA("arm,cortex-a9-pmu", 0, "arm-pmu", &socfpga_pmu_platdata),
+#endif
 	{ /* sentinel */ }
 };
 
diff --git a/arch/arm/mach-socfpga/socfpga_cti.c b/arch/arm/mach-socfpga/socfpga_cti.c
new file mode 100644
index 0000000..10072c8
--- /dev/null
+++ b/arch/arm/mach-socfpga/socfpga_cti.c
@@ -0,0 +1,125 @@
+/*
+ *  Copyright (C) 2013 Altera Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/platform_device.h>
+#include <linux/of_address.h>
+#include <asm/mach/map.h>
+#include <asm/cti.h>
+#include <asm/pmu.h>
+
+#include "core.h"
+#include "socfpga_cti.h"
+
+#define SOCFPGA_NUM_CTI	2
+
+struct cti socfpga_cti_data[SOCFPGA_NUM_CTI];
+
+irqreturn_t socfpga_pmu_handler(int irq, void *dev, irq_handler_t handler)
+{
+	unsigned int handled = 0;
+	int i;
+
+	for (i = 0; i < SOCFPGA_NUM_CTI; i++)
+		if (irq == socfpga_cti_data[i].irq) {
+			cti_irq_ack(&socfpga_cti_data[i]);
+			handled = handler(irq, dev);
+		}
+
+	return IRQ_RETVAL(handled);
+}
+
+int socfpga_init_cti(struct platform_device *pdev)
+{
+	struct device_node *np, *np2;
+	void __iomem *cti0_addr;
+	void __iomem *cti1_addr;
+	u32 irq0, irq1;
+
+	np = pdev->dev.of_node;
+	np2 = of_find_compatible_node(np, NULL, "arm,coresight-cti");
+	if (!np2) {
+		dev_err(&pdev->dev, "PMU: Unable to find coresight-cti\n");
+		return -1;
+	}
+	cti0_addr = of_iomap(np2, 0);
+	if (!cti0_addr) {
+		dev_err(&pdev->dev, "PMU: ioremap for CTI failed\n");
+		return -1;
+	}
+
+	irq0 = platform_get_irq(pdev, 0);
+	if (irq0 < 0)
+		goto free_irq0;
+
+	np2 = of_find_compatible_node(np2, NULL, "arm,coresight-cti");
+	if (!np2) {
+		dev_err(&pdev->dev, "PMU: Unable to find coresight-cti\n");
+		goto err_iounmap;
+	}
+	cti1_addr = of_iomap(np2, 0);
+	if (!cti1_addr)
+		goto err_iounmap;
+
+	irq1 = platform_get_irq(pdev, 1);
+	if (irq1 < 0)
+		goto free_irq1;
+
+	/*configure CTI0 for pmu irq routing*/
+	cti_init(&socfpga_cti_data[0], cti0_addr,
+		irq0, CTI_MPU_IRQ_TRIG_OUT);
+	cti_unlock(&socfpga_cti_data[0]);
+	cti_map_trigger(&socfpga_cti_data[0],
+		CTI_MPU_IRQ_TRIG_IN, CTI_MPU_IRQ_TRIG_OUT, PMU_CHANNEL_0);
+
+	/*configure CTI1 for pmu irq routing*/
+	cti_init(&socfpga_cti_data[1], cti1_addr,
+		irq1, CTI_MPU_IRQ_TRIG_OUT);
+	cti_unlock(&socfpga_cti_data[1]);
+	cti_map_trigger(&socfpga_cti_data[1],
+		CTI_MPU_IRQ_TRIG_IN, CTI_MPU_IRQ_TRIG_OUT, PMU_CHANNEL_1);
+
+	dev_info(&pdev->dev, "PMU:CTI successfully enabled\n");
+	return 0;
+
+free_irq1:
+	iounmap(cti1_addr);
+err_iounmap:
+	free_irq(irq0, pdev);
+free_irq0:
+	iounmap(cti0_addr);
+	return -1;
+}
+
+int socfpga_start_cti(struct platform_device *pdev)
+{
+	int i;
+
+	for (i = 0; i < SOCFPGA_NUM_CTI; i++)
+		cti_enable(&socfpga_cti_data[i]);
+
+	return 0;
+}
+
+int socfpga_stop_cti(struct platform_device *pdev)
+{
+	int i;
+
+	for (i = 0; i < SOCFPGA_NUM_CTI; i++)
+		cti_disable(&socfpga_cti_data[i]);
+
+	return 0;
+}
+
diff --git a/arch/arm/mach-socfpga/socfpga_cti.h b/arch/arm/mach-socfpga/socfpga_cti.h
new file mode 100644
index 0000000..cbeb063
--- /dev/null
+++ b/arch/arm/mach-socfpga/socfpga_cti.h
@@ -0,0 +1,16 @@
+#ifndef __SOCFPGA_CTI_H
+#define __SOCFPGA_CTI_H
+
+#define CTI_MPU_IRQ_TRIG_IN	1
+#define CTI_MPU_IRQ_TRIG_OUT	6
+
+#define PMU_CHANNEL_0	0
+#define PMU_CHANNEL_1	1
+
+#ifdef CONFIG_HW_PERF_EVENTS
+extern irqreturn_t socfpga_pmu_handler(int irq, void *dev, irq_handler_t handler);
+extern int socfpga_init_cti(struct platform_device *pdev);
+extern int socfpga_start_cti(struct platform_device *pdev);
+extern int socfpga_stop_cti(struct platform_device *pdev);
+#endif
+#endif /* __SOCFPGA_CTI_H */
-- 
1.7.5.4

