From a3bfb1480d659c80f05f3108f78e3753210ae476 Mon Sep 17 00:00:00 2001
From: Li Zhou <li.zhou@windriver.com>
Date: Fri, 16 Oct 2015 14:37:28 +0800
Subject: [PATCH] arm: socfpga: fix fetching cpu1start_addr for SMP

commit 3a4356c0c042a5f340c8d6ee1a4feaa1c8e51ea2 upstream

When CPU1 is brought out of reset, it's MMU is not turned on yet, so it will
only be able to use physical addresses. For systems with that have the
MMU page configured for 0xC0000000, 0x80000000, or 0x40000000
"BIC 0x40000000" will work just fine, as it was just converting the
virtual address of &cpu1start_addr into a physical address, ie. 0xC0000000
became 0x80000000. So for systems where the SDRAM controller was able to do a
wrap-around access, this was working fine, as it was just dropping the MSB,
but for systems where out of bounds memory access is not allowed, this would
not allow CPU1 to correctly fetch &cpu1start_addr.

This patch fixes the secondary_trampoline code to correctly fetch the
physical address of cpu1start_addr directly. The patch will subtract the
correct PAGE_OFFSET from &cpu1start_addr. And since on this platform, the
physical memory will always start at 0x0, subtracting PAGE_OFFSET from
&cpu1start_addr will allow CPU1 to correctly fetch the value of cpu1start_addr.

While at it, change the name of cpu1start_addr to socfpga_cpu1start_addr
to avoid any future naming collisions for multiplatform image.

Signed-off-by: Dinh Nguyen <dinguyen@opensource.altera.com>
[lz: adapted the patch to solve context issues]
Signed-off-by: Li Zhou <li.zhou@windriver.com>
---
 arch/arm/mach-socfpga/core.h    |    2 +-
 arch/arm/mach-socfpga/headsmp.S |   25 +++++++++++++++----------
 arch/arm/mach-socfpga/platsmp.c |    4 ++--
 arch/arm/mach-socfpga/socfpga.c |    4 ++--
 4 files changed, 20 insertions(+), 15 deletions(-)

diff --git a/arch/arm/mach-socfpga/core.h b/arch/arm/mach-socfpga/core.h
index 2033189..6355746 100644
--- a/arch/arm/mach-socfpga/core.h
+++ b/arch/arm/mach-socfpga/core.h
@@ -74,7 +74,7 @@ extern struct smp_operations socfpga_smp_ops;
 extern char secondary_trampoline, secondary_trampoline_end;
 
 extern struct dw_mci_board sdmmc_platform_data;
-extern unsigned long cpu1start_addr;
+extern unsigned long socfpga_cpu1start_addr;
 
 #define SOCFPGA_SCU_VIRT_BASE   0xfee00000
 
diff --git a/arch/arm/mach-socfpga/headsmp.S b/arch/arm/mach-socfpga/headsmp.S
index 95c115d..f65ea0a 100644
--- a/arch/arm/mach-socfpga/headsmp.S
+++ b/arch/arm/mach-socfpga/headsmp.S
@@ -9,21 +9,26 @@
  */
 #include <linux/linkage.h>
 #include <linux/init.h>
+#include <asm/memory.h>
 
 	.arch	armv7-a
 
 ENTRY(secondary_trampoline)
-	movw	r2, #:lower16:cpu1start_addr
-	movt  r2, #:upper16:cpu1start_addr
-
-	/* The socfpga VT cannot handle a 0xC0000000 page offset when loading
-		the cpu1start_addr, we bit clear it. Tested on HW and VT. */
-	bic	r2, r2, #0x40000000
-
-	ldr	r0, [r2]
-	ldr	r1, [r0]
-	bx	r1
+	/* CPU1 will always fetch from 0x0 when it is brought out of reset.
+	 * Thus, we can just subtract the PAGE_OFFSET to get the physical
+	 * address of &cpu1start_addr. This would not work for platforms
+	 * where the physical memory does not start at 0x0.
+	 */
+	adr	r0, 1f
+	ldmia	r0, {r1, r2}
+	sub	r2, r2, #PAGE_OFFSET
+	ldr	r3, [r2]
+	ldr	r4, [r3]
+	bx	r4
 
+	.align
+1:	.long	.
+	.long	socfpga_cpu1start_addr
 ENTRY(secondary_trampoline_end)
 
 ENTRY(socfpga_secondary_startup)
diff --git a/arch/arm/mach-socfpga/platsmp.c b/arch/arm/mach-socfpga/platsmp.c
index 37b7b96..49f0602 100644
--- a/arch/arm/mach-socfpga/platsmp.c
+++ b/arch/arm/mach-socfpga/platsmp.c
@@ -33,7 +33,7 @@ static int socfpga_boot_secondary(unsigned int cpu, struct task_struct *idle)
 {
 	int trampoline_size = &secondary_trampoline_end - &secondary_trampoline;
 
-	if (cpu1start_addr) {
+	if (socfpga_cpu1start_addr) {
 		/* This will put CPU #1 into reset.*/
 		__raw_writel(RSTMGR_MPUMODRST_CPU1,
 			     rst_manager_base_addr + 0x10);
@@ -41,7 +41,7 @@ static int socfpga_boot_secondary(unsigned int cpu, struct task_struct *idle)
 		memcpy(phys_to_virt(0), &secondary_trampoline, trampoline_size);
 
 		__raw_writel(virt_to_phys(socfpga_secondary_startup),
-			(sys_manager_base_addr + (cpu1start_addr & 0x000000ff)));
+			(sys_manager_base_addr + (socfpga_cpu1start_addr & 0x000000ff)));
 
 		flush_cache_all();
 		smp_wmb();
diff --git a/arch/arm/mach-socfpga/socfpga.c b/arch/arm/mach-socfpga/socfpga.c
index 7c221ab..c0d891f 100644
--- a/arch/arm/mach-socfpga/socfpga.c
+++ b/arch/arm/mach-socfpga/socfpga.c
@@ -44,7 +44,7 @@ void __iomem *sdr_ctl_base_addr;
 void __iomem *l3regs_base_addr;
 
 void __iomem *clk_mgr_base_addr;
-unsigned long cpu1start_addr;
+unsigned long socfpga_cpu1start_addr;
 
 static int stmmac_plat_init(struct platform_device *pdev, void *priv);
 
@@ -230,7 +230,7 @@ static void __init socfpga_sysmgr_init(void)
 	}
 
 	if (of_property_read_u32(np, "cpu1-start-addr",
-			(u32 *) &cpu1start_addr))
+			(u32 *) &socfpga_cpu1start_addr))
 		pr_err("SMP: Need cpu1-start-addr in device tree.\n");
 
 	sys_manager_base_addr = of_iomap(np, 0);
-- 
1.7.5.4

