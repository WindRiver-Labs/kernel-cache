From d6a6937b23b729c0f72a3c6ed58c70a45fec36a5 Mon Sep 17 00:00:00 2001
From: graham <grmoore@altera.com>
Date: Fri, 28 Jun 2013 10:32:03 -0500
Subject: [PATCH 101/248] FogBugz #132611-1: Support N25Q00 QSPI chip

Add read-delay device tree parameter.
Add flag status read/write.
Add check of flag status register on all erase/write commands.
Add volatile configuration register setup for 8 dummy clocks.

[Original patch taken from
git://git.rocketboards.org/linux-socfpga.git socfpga-3.14]

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
Signed-off-by: graham <grmoore@altera.com>
---
 arch/arm/boot/dts/socfpga_cyclone5.dtsi |  36 ++------
 drivers/mtd/devices/m25p80.c            | 155 ++++++++++++++++++++++++++++----
 2 files changed, 147 insertions(+), 44 deletions(-)

diff --git a/arch/arm/boot/dts/socfpga_cyclone5.dtsi b/arch/arm/boot/dts/socfpga_cyclone5.dtsi
index 41ac1ec..db1bfc9 100644
--- a/arch/arm/boot/dts/socfpga_cyclone5.dtsi
+++ b/arch/arm/boot/dts/socfpga_cyclone5.dtsi
@@ -91,13 +91,14 @@
 				compatible = "n25q00";
 				reg = <0>;      /* chip select */
 				spi-max-frequency = <100000000>;
+				m25p,fast-read;
 				page-size = <256>;
 				block-size = <16>; /* 2^16, 64KB */
-				quad = <1>;        /* 1-support quad */
-				tshsl-ns = <200>;
-				tsd2d-ns = <255>;
-				tchsh-ns = <20>;
-				tslch-ns = <20>;
+				read-delay = <4>;  /* delay value in read data capture register */
+				tshsl-ns = <50>;
+				tsd2d-ns = <50>;
+				tchsh-ns = <4>;
+				tslch-ns = <4>;
 
 				partition@0 {
 					/* 8MB for raw data. */
@@ -105,30 +106,9 @@
 					reg = <0x0 0x800000>;
 				};
 				partition@800000 {
-					/* 8MB for jffs2 data. */
+					/* 120MB for jffs2 data. */
 					label = "Flash 0 jffs2 Filesystem";
-					reg = <0x800000 0x800000>;
-				};
-			};
-
-			flash1: n25q128@1 {
-				#address-cells = <1>;
-				#size-cells = <1>;
-				compatible = "n25q128";
-				reg = <1>;      /* chip select */
-				spi-max-frequency = <100000000>;
-				page-size = <256>;
-				block-size = <16>; /* 2^16, 64KB */
-				quad = <1>;
-				tshsl-ns = <200>;
-				tsd2d-ns = <255>;
-				tchsh-ns = <20>;
-				tslch-ns = <20>;
-
-				partition@0 {
-					/* 16MB for user data. */
-					label = "Flash 1 User Data";
-					reg = <0x0 0x1000000>;
+					reg = <0x800000 0x7800000>;
 				};
 			};
 		};
diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index cc0c2a9..43a59e4 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -39,9 +39,10 @@
 #define	OPCODE_WREN		0x06	/* Write enable */
 #define	OPCODE_RDSR		0x05	/* Read status register */
 #define	OPCODE_WRSR		0x01	/* Write status register 1 byte */
+#define	OPCODE_RFSR		0x70  /* read flag status register */
 #define	OPCODE_NORM_READ	0x03	/* Read data bytes (low frequency) */
 #define	OPCODE_FAST_READ	0x0b	/* Read data bytes (high frequency) */
-#define  OPCODE_FAST_READ_QUAD_OUTPUT   0x6b    /* Read data bytes (quad) */
+#define	OPCODE_QUAD_READ	0x6b    /* Read data bytes (quad) */
 #define	OPCODE_PP		0x02	/* Page program (up to 256 bytes) */
 #define	OPCODE_BE_4K		0x20	/* Erase 4KiB block */
 #define	OPCODE_BE_4K_PMC	0xd7	/* Erase 4KiB block on PMC chips */
@@ -92,6 +93,15 @@
 
 /* Configuration Register bits. */
 #define CR_QUAD_EN_SPAN		0x2     /* Spansion Quad I/O */
+/* Flag Status Register bits */
+#define	FSR_READY         (1 << 7)
+#define	FSR_ERASE_SUSPEND (1 << 6)
+#define	FSR_ERASE_ERROR   (1 << 5)
+#define	FSR_PGM_ERROR     (1 << 4)
+#define	FSR_VPP_INVALID   (1 << 3)
+#define	FSR_PGM_SUSPEND   (1 << 2)
+#define	FSR_PROTECT_ERROR (1 << 1)
+#define	FSR_4BYTE_ADDR    (1 << 0)
 
 /* Define max times to check status register before we give up. */
 #define	MAX_READY_WAIT_JIFFIES	(40 * HZ)	/* M25P16 specs 40s max chip erase */
@@ -118,6 +128,8 @@ struct m25p {
 	u8			program_opcode;
 	u8			*command;
 	enum read_type		flash_read;
+	bool			fast_read;
+	int (*wait_till_ready)(struct m25p *flash);
 };
 
 static inline struct m25p *mtd_to_m25p(struct mtd_info *mtd)
@@ -174,6 +186,28 @@ static int read_cr(struct m25p *flash)
 }
 
 /*
+ * Read the flagstatus register, returning its value in the location
+ * Return the status register value.
+ * Returns negative if error occurred.
+ */
+static int read_fsr(struct m25p *flash)
+{
+	ssize_t retval;
+	u8 code = OPCODE_RFSR;
+	u8 val;
+
+	retval = spi_write_then_read(flash->spi, &code, 1, &val, 1);
+
+	if (retval < 0) {
+		dev_err(&flash->spi->dev, "error %d reading SR\n",
+				(int) retval);
+		return retval;
+	}
+
+	return val;
+}
+
+/*
  * Write status register 1 byte
  * Returns negative if error occurred.
  */
@@ -186,6 +220,39 @@ static int write_sr(struct m25p *flash, u8 val)
 }
 
 /*
+ * Write volatile config register
+ * Returns negative if error occurred.
+ */
+static int write_vcr(struct m25p *flash, u8 val)
+{
+	flash->command[0] = OPCODE_WVCR;
+	flash->command[1] = val;
+
+	return spi_write(flash->spi, flash->command, 2);
+}
+
+/*
+ * Read volatile config register
+ * Returns negative if error occurred.
+ */
+static int read_vcr(struct m25p *flash)
+{
+	ssize_t retval;
+	u8 code = OPCODE_RVCR;
+	u8 val;
+
+	retval = spi_write_then_read(flash->spi, &code, 1, &val, 1);
+
+	if (retval < 0) {
+		dev_err(&flash->spi->dev, "error %d reading VCR\n",
+				(int) retval);
+		return retval;
+	}
+
+	return val;
+}
+
+/*
  * Set write enable latch with Write Enable command.
  * Returns negative if error occurred.
  */
@@ -242,7 +309,7 @@ static inline int set_4byte(struct m25p *flash, u32 jedec_id, int enable)
  * Service routine to read status register until ready, or timeout occurs.
  * Returns non-zero if error.
  */
-static int wait_till_ready(struct m25p *flash)
+static int _wait_till_ready(struct m25p *flash)
 {
 	unsigned long deadline;
 	int sr;
@@ -289,7 +356,7 @@ static int macronix_quad_enable(struct m25p *flash)
 
 	spi_write(flash->spi, &cmd, 2);
 
-	if (wait_till_ready(flash))
+	if (flash->wait_till_ready(flash))
 		return 1;
 
 	ret = read_sr(flash);
@@ -350,6 +417,38 @@ static int set_quad_mode(struct m25p *flash, u32 jedec_id)
 }
 
 /*
+ * Service routine to read flag status register until ready, or timeout occurs.
+ * Returns non-zero if error.
+ */
+static int _wait_till_fsr_ready(struct m25p *flash)
+{
+	unsigned long deadline;
+	int fsr;
+	int sr;
+
+	deadline = jiffies + MAX_READY_WAIT_JIFFIES;
+
+	do {
+		sr = read_sr(flash);
+		if (sr < 0)
+			break;
+		/* only check fsr if sr not busy */
+		if (!(sr & SR_WIP)) {
+			fsr = read_fsr(flash);
+			if (fsr < 0)
+				break;
+			if (fsr & FSR_READY)
+				return 0;
+		}
+
+		cond_resched();
+
+	} while (!time_after_eq(jiffies, deadline));
+
+	return 1;
+}
+
+/*
  * Erase the whole flash memory
  *
  * Returns 0 if successful, non-zero otherwise.
@@ -360,7 +459,7 @@ static int erase_chip(struct m25p *flash)
 			(long long)(flash->mtd.size >> 10));
 
 	/* Wait until finished previous write command. */
-	if (wait_till_ready(flash))
+	if (flash->wait_till_ready(flash))
 		return 1;
 
 	/* Send write enable, then erase commands. */
@@ -371,6 +470,8 @@ static int erase_chip(struct m25p *flash)
 
 	spi_write(flash->spi, flash->command, 1);
 
+	flash->wait_till_ready(flash);
+
 	return 0;
 }
 
@@ -400,7 +501,7 @@ static int erase_sector(struct m25p *flash, u32 offset)
 			__func__, flash->mtd.erasesize / 1024, offset);
 
 	/* Wait until finished previous write command. */
-	if (wait_till_ready(flash))
+	if (flash->wait_till_ready(flash))
 		return 1;
 
 	/* Send write enable, then erase commands. */
@@ -412,6 +513,8 @@ static int erase_sector(struct m25p *flash, u32 offset)
 
 	spi_write(flash->spi, flash->command, m25p_cmdsz(flash));
 
+	flash->wait_till_ready(flash);
+
 	return 0;
 }
 
@@ -545,7 +648,7 @@ static int m25p80_read(struct mtd_info *mtd, loff_t from, size_t len,
 	mutex_lock(&flash->lock);
 
 	/* Wait till previous write/erase is done. */
-	if (wait_till_ready(flash)) {
+	if (flash->wait_till_ready(flash)) {
 		/* REVISIT status return?? */
 		mutex_unlock(&flash->lock);
 		return 1;
@@ -594,7 +697,7 @@ static int m25p80_write(struct mtd_info *mtd, loff_t to, size_t len,
 	mutex_lock(&flash->lock);
 
 	/* Wait until finished previous write command. */
-	if (wait_till_ready(flash)) {
+	if (flash->wait_till_ready(flash)) {
 		mutex_unlock(&flash->lock);
 		return 1;
 	}
@@ -637,7 +740,7 @@ static int m25p80_write(struct mtd_info *mtd, loff_t to, size_t len,
 			t[1].tx_buf = buf + i;
 			t[1].len = page_size;
 
-			wait_till_ready(flash);
+			flash->wait_till_ready(flash);
 
 			write_enable(flash);
 
@@ -647,6 +750,8 @@ static int m25p80_write(struct mtd_info *mtd, loff_t to, size_t len,
 		}
 	}
 
+	flash->wait_till_ready(flash);
+
 	mutex_unlock(&flash->lock);
 
 	return 0;
@@ -677,7 +782,7 @@ static int sst_write(struct mtd_info *mtd, loff_t to, size_t len,
 	mutex_lock(&flash->lock);
 
 	/* Wait until finished previous write command. */
-	ret = wait_till_ready(flash);
+	ret = flash->wait_till_ready(flash);
 	if (ret)
 		goto time_out;
 
@@ -692,7 +797,7 @@ static int sst_write(struct mtd_info *mtd, loff_t to, size_t len,
 		/* write one byte. */
 		t[1].len = 1;
 		spi_sync(flash->spi, &m);
-		ret = wait_till_ready(flash);
+		ret = flash->wait_till_ready(flash);
 		if (ret)
 			goto time_out;
 		*retlen += m.actual_length - m25p_cmdsz(flash);
@@ -711,7 +816,7 @@ static int sst_write(struct mtd_info *mtd, loff_t to, size_t len,
 		t[1].tx_buf = buf + actual;
 
 		spi_sync(flash->spi, &m);
-		ret = wait_till_ready(flash);
+		ret = flash->wait_till_ready(flash);
 		if (ret)
 			goto time_out;
 		*retlen += m.actual_length - cmd_sz;
@@ -719,7 +824,7 @@ static int sst_write(struct mtd_info *mtd, loff_t to, size_t len,
 		to += 2;
 	}
 	write_disable(flash);
-	ret = wait_till_ready(flash);
+	ret = flash->wait_till_ready(flash);
 	if (ret)
 		goto time_out;
 
@@ -733,7 +838,7 @@ static int sst_write(struct mtd_info *mtd, loff_t to, size_t len,
 		t[1].tx_buf = buf + actual;
 
 		spi_sync(flash->spi, &m);
-		ret = wait_till_ready(flash);
+		ret = flash->wait_till_ready(flash);
 		if (ret)
 			goto time_out;
 		*retlen += m.actual_length - m25p_cmdsz(flash);
@@ -754,7 +859,7 @@ static int m25p80_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 
 	mutex_lock(&flash->lock);
 	/* Wait until finished previous command */
-	if (wait_till_ready(flash)) {
+	if (flash->wait_till_ready(flash)) {
 		res = 1;
 		goto err;
 	}
@@ -799,7 +904,7 @@ static int m25p80_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
 
 	mutex_lock(&flash->lock);
 	/* Wait until finished previous command */
-	if (wait_till_ready(flash)) {
+	if (flash->wait_till_ready(flash)) {
 		res = 1;
 		goto err;
 	}
@@ -954,7 +1059,7 @@ static const struct spi_device_id m25p_ids[] = {
 	{ "n25q128a13",  INFO(0x20ba18, 0, 64 * 1024,  256, 0) },
 	{ "n25q256a",    INFO(0x20ba19, 0, 64 * 1024,  512, SECT_4K) },
 	{ "n25q512a",    INFO(0x20bb20, 0, 64 * 1024, 1024, SECT_4K) },
-	{ "n25q00",   INFO(0x20ba21, 0, 64 * 1024, 256, SECT_4K) },
+	{ "n25q00",   INFO(0x20ba21, 0, 64 * 1024, 2048, USE_FSR) },
 
 	/* PMC */
 	{ "pm25lv512",   INFO(0,        0, 32 * 1024,    2, SECT_4K_PMC) },
@@ -1220,6 +1325,12 @@ static int m25p_probe(struct spi_device *spi)
 	if (info->flags & M25P_NO_ERASE)
 		flash->mtd.flags |= MTD_NO_ERASE;
 
+	if (info->flags & USE_FSR)
+		flash->wait_till_ready = &_wait_till_fsr_ready;
+	else
+		flash->wait_till_ready = &_wait_till_ready;
+
+
 	ppdata.of_node = spi->dev.of_node;
 	flash->mtd.dev.parent = &spi->dev;
 	flash->page_size = info->page_size;
@@ -1296,6 +1407,18 @@ static int m25p_probe(struct spi_device *spi)
 		flash->addr_width = 3;
 	}
 
+	/* set up the VCR for 8 dummy cycles (instead of the default 15) */
+#define N25Q00_JEDEC_ID (0x20ba21)
+	if (info->jedec_id == N25Q00_JEDEC_ID) {
+		int vcr = read_vcr(flash);
+		if (vcr >= 0) {
+			vcr &= ~(VCR_DUMMY_CLK_CYCLES_MASK | VCR_XIP_MASK);
+			vcr |= (8 << VCR_DUMMY_CLK_CYCLES_SHIFT);
+			write_enable(flash);
+			write_vcr(flash, vcr);
+		}
+	}
+
 	spi->addr_width = flash->addr_width;
 
 	dev_info(&spi->dev, "%s (%lld Kbytes)\n", id->name,
-- 
1.9.1

