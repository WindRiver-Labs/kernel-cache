From ea5926bf759e83ce554c742dce9e6add4d4a2720 Mon Sep 17 00:00:00 2001
From: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
Date: Mon, 7 Sep 2009 09:55:34 +0900
Subject: [PATCH 2/2] nec_emma3slp: NEC EMMA3SLx evaluation board

The EMMA3SLx is a development platform for EMMA3SLxx SoCs, manufactured
by NEC Electronics.  This patch adds its board support with a few system
peripherals; UART, USB HCs, and ethernet MAC.  On-board NOR flash device
is also available.

Signed-off-by: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
---
 arch/mips/Kconfig                      |    7 +
 arch/mips/Makefile                     |    6 +
 arch/mips/emma/nec-emma3slx/Makefile   |   11 ++
 arch/mips/emma/nec-emma3slx/init.c     |   38 +++++
 arch/mips/emma/nec-emma3slx/irq.c      |   96 +++++++++++
 arch/mips/emma/nec-emma3slx/platform.c |  276 ++++++++++++++++++++++++++++++++
 arch/mips/emma/nec-emma3slx/setup.c    |  160 ++++++++++++++++++
 7 files changed, 594 insertions(+), 0 deletions(-)
 create mode 100644 arch/mips/emma/nec-emma3slx/Makefile
 create mode 100644 arch/mips/emma/nec-emma3slx/init.c
 create mode 100644 arch/mips/emma/nec-emma3slx/irq.c
 create mode 100644 arch/mips/emma/nec-emma3slx/platform.c
 create mode 100644 arch/mips/emma/nec-emma3slx/setup.c

diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig
index 061c298..105ce0d 100644
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -257,6 +257,13 @@ config MARKEINS
 	  This enables support for the R5432-based NEC Mark-eins
 	  boards with R5500 CPU.
 
+config NEC_EMMA3SLX
+	bool "NEC EMMA3SLx eval board"
+	select SOC_EMMA3SLP
+	help
+	  This enables support for the NEC Electronics EMMA3SLx evaluation
+	  board.
+
 config MACH_VR41XX
 	bool "NEC VR4100 series based machines"
 	select CEVT_R4K
diff --git a/arch/mips/Makefile b/arch/mips/Makefile
index 9ee1d32..9219fda 100644
--- a/arch/mips/Makefile
+++ b/arch/mips/Makefile
@@ -417,6 +417,12 @@ core-$(CONFIG_MARKEINS)         += arch/mips/emma2rh/markeins/
 load-$(CONFIG_MARKEINS)         += 0xffffffff88100000
 
 #
+# NEC EMMA3SLx board
+#
+core-$(CONFIG_NEC_EMMA3SLX)	+= arch/mips/emma/nec-emma3slx/
+load-$(CONFIG_NEC_EMMA3SLX)	+= 0xffffffff8d000000
+
+#
 # SGI IP22 (Indy/Indigo2)
 #
 # Set the load address to >= 0xffffffff88069000 if you want to leave space for
diff --git a/arch/mips/emma/nec-emma3slx/Makefile b/arch/mips/emma/nec-emma3slx/Makefile
new file mode 100644
index 0000000..0b9bf7c
--- /dev/null
+++ b/arch/mips/emma/nec-emma3slx/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for NEC EMMA3SLx evaluation board.
+#
+# Copyright (C) 2009  NEC Electronics Corporation
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+#
+
+obj-y		:= init.o irq.o platform.o setup.o
diff --git a/arch/mips/emma/nec-emma3slx/init.c b/arch/mips/emma/nec-emma3slx/init.c
new file mode 100644
index 0000000..0af4c4b
--- /dev/null
+++ b/arch/mips/emma/nec-emma3slx/init.c
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2009  NEC Electronics Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * (version 2) as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#include <linux/init.h>
+
+#include <asm/bootinfo.h>
+#include <asm/emma/emmaxxx.h>
+#include <asm/emma/prom.h>
+
+const char *get_system_type(void)
+{
+	return "NEC EMMA3SLx";
+}
+
+void __init prom_init(void)
+{
+	prom_argc = (int)fw_arg0;
+	prom_argv = (char **)fw_arg1;
+	prom_envp = (char **)fw_arg2;
+
+	prom_init_cmdline();
+
+	add_memory_region(EMMA_RAM_BASE, EMMA_RAM_SIZE, BOOT_MEM_RAM);
+}
diff --git a/arch/mips/emma/nec-emma3slx/irq.c b/arch/mips/emma/nec-emma3slx/irq.c
new file mode 100644
index 0000000..728c3a0
--- /dev/null
+++ b/arch/mips/emma/nec-emma3slx/irq.c
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2009  NEC Electronics Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * (version 2) as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include <asm/mipsregs.h>
+#include <asm/irq_cpu.h>
+#include <asm/emma/emmaxxx.h>
+#include <asm/emma/bhif.h>
+#include <asm/emma/irq.h>
+
+void emma_irq_dispatch(void)
+{
+	u32 status;
+	u32 bitmask;
+	u32 i;
+
+	status = emma_in32(EMMA_BHIF_INT_ST_0) &
+		 emma_in32(EMMA_BHIF_INT_EN_0);
+#ifdef EMMA_SW_CASCADE
+	if (status & (1UL << (EMMA_SW_CASCADE - EMMA_IRQ_BASE))) {
+		u32 sw_int_status;
+
+		sw_int_status = emma_in32(EMMA_BHIF_SW_INT) &
+				emma_in32(EMMA_BHIF_SW_INT_EN);
+		for (i = 0, bitmask = 1UL; i < 32; i++, bitmask <<= 1) {
+			if (sw_int_status & bitmask) {
+				do_IRQ(EMMA_SW_IRQ_BASE + i);
+				return;
+			}
+		}
+	}
+	/* ignoring SW interrupt */
+	status &= ~(1UL << (EMMA_SW_CASCADE - EMMA_IRQ_BASE));
+#endif
+	for (i = 0, bitmask = 1UL; i < 32; i++, bitmask <<= 1) {
+		if (status & bitmask) {
+			do_IRQ(EMMA_IRQ_BASE + i);
+			return;
+		}
+	}
+
+	status = emma_in32(EMMA_BHIF_INT_ST_1) &
+		 emma_in32(EMMA_BHIF_INT_EN_1);
+	for (i = 32, bitmask = 1UL; i < 64; i++, bitmask <<= 1) {
+		if (status & bitmask) {
+			do_IRQ(EMMA_IRQ_BASE + i);
+			return;
+		}
+	}
+
+	status = emma_in32(EMMA_BHIF_INT_ST_2) &
+		 emma_in32(EMMA_BHIF_INT_EN_2);
+	for (i = 64, bitmask = 1UL; i < 96; i++, bitmask <<= 1) {
+		if (status & bitmask) {
+			do_IRQ(EMMA_IRQ_BASE + i);
+			return;
+		}
+	}
+}
+
+void __init arch_init_irq(void)
+{
+	/* by default, interrupts are disabled. */
+	emma_out32(EMMA_BHIF_INT_EN_0, 0);
+	emma_out32(EMMA_BHIF_INT_EN_1, 0);
+	emma_out32(EMMA_BHIF_INT_EN_2, 0);
+	emma_out32(EMMA_BHIF_SW_INT_EN, 0);
+
+	clear_c0_status(0xff00);
+	set_c0_status(0x0400);
+
+	/* init all controllers */
+	mips_cpu_irq_init();
+	bhif_irq_init();
+	bhif_sw_irq_init();
+
+	/* setup cascade interrupts */
+	setup_irq(MIPS_CPU_IRQ_BASE + 2, &irq_cascade);
+	setup_irq(EMMA_SW_CASCADE, &irq_cascade);
+}
diff --git a/arch/mips/emma/nec-emma3slx/platform.c b/arch/mips/emma/nec-emma3slx/platform.c
new file mode 100644
index 0000000..d23eba3
--- /dev/null
+++ b/arch/mips/emma/nec-emma3slx/platform.c
@@ -0,0 +1,276 @@
+/*
+ * Platform devices for EMMA3SL/P and EMMA3SLx evaluation board.
+ *
+ * Copyright (C) 2009  NEC Electronics Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * (version 2) as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/irq.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/physmap.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/addrspace.h>
+#include <asm/emma/emmaxxx.h>
+#include <asm/emma/prom.h>
+#include <linux/nec_candy_pd.h>
+
+#define I2C_EMMA	"emma-iic" /* must be in sync with IIC driver */
+
+static struct resource i2c_emma_resources_0[] = {
+	{
+		.start	= EMMA_IRQ_PIIC0,
+		.end	= EMMA_IRQ_PIIC0,
+		.flags	= IORESOURCE_IRQ
+	}, {
+		.start	= CKSEG1ADDR(EMMA_PIIC0_BASE),
+		.end	= CKSEG1ADDR(EMMA_PIIC0_BASE + 0x1000 - 1),
+	}, {
+		.start	= CKSEG1ADDR(EMMA_PBRD_BASE),
+		.end	= CKSEG1ADDR(EMMA_PBRD_BASE + 0x1000 - 1),
+		.name	= "pbrd",
+	}
+};
+
+static struct resource i2c_emma_resources_1[] = {
+	{
+		.start	= EMMA_IRQ_PIIC1,
+		.end	= EMMA_IRQ_PIIC1,
+		.flags	= IORESOURCE_IRQ
+	}, {
+		.start	= CKSEG1ADDR(EMMA_PIIC1_BASE),
+		.end	= CKSEG1ADDR(EMMA_PIIC1_BASE + 0x1000 - 1),
+	}, {
+		.start	= CKSEG1ADDR(EMMA_PBRD_BASE),
+		.end	= CKSEG1ADDR(EMMA_PBRD_BASE + 0x1000 - 1),
+		.name	= "pbrd",
+	}
+};
+
+static struct platform_device i2c_emma_devices[] = {
+	[0] = {
+		.name		= I2C_EMMA,
+		.id		= 0,
+		.resource	= i2c_emma_resources_0,
+		.num_resources	= ARRAY_SIZE(i2c_emma_resources_0),
+	},
+	[1] = {
+		.name		= I2C_EMMA,
+		.id		= 1,
+		.resource	= i2c_emma_resources_1,
+		.num_resources	= ARRAY_SIZE(i2c_emma_resources_1),
+	},
+};
+
+
+static struct nec_candy_platform_data nec_candy_pdata = {
+	.pmd_addr	= 0x01,
+	.rmii		= 1,
+	.clks		= MIIC_CLKS100,
+};
+
+static struct platform_device nec_candy_device = {
+	.name			= "nec_candy",
+	.id			= 0,
+	.dev.platform_data	= &nec_candy_pdata,
+	.num_resources		= 2,
+	.resource = (struct resource[]) {
+		{
+			.name	= "nec_candy_regs",
+			.start	= EMMA_ETHER_BASE,
+			.end	= EMMA_ETHER_BASE + 0x400 - 1,
+			.flags	= IORESOURCE_MEM,
+		},
+		{
+			.name	= "nec_candy_irq",
+			.start	= EMMA_IRQ_ETHER,
+			.end	= EMMA_IRQ_ETHER,
+			.flags	= IORESOURCE_IRQ,
+		},
+	},
+};
+
+static u64 ohci_dmamask = DMA_BIT_MASK(32);
+
+static struct platform_device emma_ohci = {
+	.name = "emma-ohci",
+	.id = 0,
+	.dev = {
+		.dma_mask		= &ohci_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+	},
+	.num_resources = 3,
+	.resource = (struct resource[]) {
+		{
+			.start	= EMMA_OHCI_BASE,
+			.end	= EMMA_OHCI_BASE + 0xff,
+			.flags	= IORESOURCE_MEM,
+		},
+		{
+			.start	= EMMA_IRQ_USB,
+			.end	= EMMA_IRQ_USB,
+			.flags	= IORESOURCE_IRQ,
+		},
+		{
+			.start	= EMMA_OHCI_CONFIG_BASE,
+			.end	= EMMA_OHCI_CONFIG_BASE + 0xff,
+			.flags	= IORESOURCE_MEM,
+		},
+	},
+};
+
+static u64 ehci_dmamask = DMA_BIT_MASK(32);
+
+static struct platform_device emma_ehci = {
+	.name = "emma-ehci",
+	.id = 0,
+	.dev = {
+		.dma_mask		= &ehci_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+	},
+	.num_resources = 3,
+	.resource = (struct resource[]) {
+		{
+			.start	= EMMA_EHCI_BASE,
+			.end	= EMMA_EHCI_BASE + 0xff,
+			.flags	= IORESOURCE_MEM,
+		},
+		{
+			.start	= EMMA_IRQ_USB,
+			.end	= EMMA_IRQ_USB,
+			.flags	= IORESOURCE_IRQ,
+		},
+		{
+			.start	= EMMA_EHCI_CONFIG_BASE,
+			.end	= EMMA_EHCI_CONFIG_BASE + 0xff,
+			.flags	= IORESOURCE_MEM,
+		},
+	},
+};
+
+#ifdef CONFIG_MTD_NAND
+
+static struct mtd_partition nand_parts[] = {
+	[0] = {
+		.name		= "boot code",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 0x00700000,
+		.mask_flags	= MTD_WRITEABLE, /* force read-only */
+	},
+	[1] = {
+		.name		= "boot env area 1",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 0x00004000,
+		.mask_flags	= MTD_WRITEABLE, /* force read-only */
+	},
+	[2] = {
+		.name		= "boot env area 2",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 0x00004000,
+		.mask_flags	= MTD_WRITEABLE, /* force read-only */
+	},
+	[3] = {
+		.name		= "Root FS",
+		.offset		= MTDPART_OFS_APPEND,
+		.size		= 0x018F8000,
+	},
+};
+
+static struct emma_nand_platform_data emma_nand_pdata = {
+	.parts			= nand_parts,
+	.nr_parts		= ARRAY_SIZE(nand_parts),
+	.large_page		= 0,
+	.cachprg_support	= 0,
+	.use_dma		= 1,
+	.nand_cs		= EMMA_NAND_CS1,
+	.dma_channel		= EMMA_DMA_MEM_CHANNEL_0,
+};
+
+static struct resource nand_emma_resources[] = {
+	{
+		.start	= EMMA_NAND_BASE,
+		.end	= EMMA_NAND_BASE + EMMA_NAND_SIZE - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= EMMA_IRQ_NAND,
+		.end	= EMMA_IRQ_NAND,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device nand_emma_devices = {
+	.name			= "nand_emma",
+	.dev.platform_data	= &emma_nand_pdata,
+	.resource		= nand_emma_resources,
+	.num_resources		= ARRAY_SIZE(nand_emma_resources),
+};
+
+#endif /* CONFIG_MTD_NAND */
+
+static struct platform_device *devices[] = {
+	&i2c_emma_devices[0],
+	&i2c_emma_devices[1],
+	&emma_ohci,
+	&emma_ehci,
+	&nec_candy_device,
+#ifdef CONFIG_MTD_NAND
+	&nand_emma_devices,
+#endif
+};
+
+#ifdef CONFIG_MTD_CFI
+
+static struct mtd_partition emma3slx_parts[] = {
+	[0] = {
+		.name	= "kernel image",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= 0x00400000,
+	},
+	[1] = {
+		.name	= "boot code area",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= 0x00200000,
+	},
+	[2] = {
+		.name	= "boot env area",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= 0x00040000,
+		.mask_flags = MTD_WRITEABLE,  /* force read-only */
+	},
+	[3] = {
+		.name	= "Free Area",
+		.offset	= MTDPART_OFS_APPEND,
+		.size	= 0x001C0000,
+	},
+};
+
+#endif /* CONFIG_MTD_CFI */
+
+static int __init platform_devices_setup(void)
+{
+#ifdef CONFIG_MTD_CFI
+	physmap_set_partitions(emma3slx_parts, ARRAY_SIZE(emma3slx_parts));
+#endif
+	get_ethernet_addr(nec_candy_pdata.mac_addr);
+
+	return platform_add_devices(devices, ARRAY_SIZE(devices));
+}
+
+arch_initcall(platform_devices_setup);
diff --git a/arch/mips/emma/nec-emma3slx/setup.c b/arch/mips/emma/nec-emma3slx/setup.c
new file mode 100644
index 0000000..3ab1c96
--- /dev/null
+++ b/arch/mips/emma/nec-emma3slx/setup.c
@@ -0,0 +1,160 @@
+/*
+ * EMMA3SLx evaluation board setups
+ *
+ * Copyright (C) 2009  NEC Electronics Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * (version 2) as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/serial_8250.h>
+#include <linux/kgdb.h>
+
+#include <asm/addrspace.h>
+#include <asm/io.h>
+#include <asm/time.h>
+#include <asm/reboot.h>
+
+#include <asm/emma/emmaxxx.h>
+#include <asm/emma/flip.h>
+
+static int bus_frequency;
+
+static void emma3slx_machine_restart(char *command)
+{
+	static void (*back_to_prom) (void) = (void (*)(void))0xbfc00000;
+
+	printk(KERN_INFO "EMMA3SLx restart.\n");
+	back_to_prom();
+}
+
+static void emma3slx_machine_halt(void)
+{
+	printk(KERN_INFO "EMMA3SLx halted.\n");
+	while (1)
+		;
+}
+
+static void emma3slx_machine_power_off(void)
+{
+	printk(KERN_INFO "EMMA3SLx halted. Please turn off the power.\n");
+	while (1)
+		;
+}
+
+static unsigned long emma_clock[4] = { 324000000, 250000000, 216000000, 0 };
+
+static unsigned int __init detect_bus_frequency(void)
+{
+	u32 reg;
+
+	/* detect from boot strap */
+	reg = emma_in32(EMMA_BHIF_STRAP_0);
+	reg = (reg >> 4) & 0x3;
+
+	return emma_clock[reg];
+}
+
+void __init plat_time_init(void)
+{
+	if (bus_frequency == 0)
+		bus_frequency = detect_bus_frequency();
+
+	mips_hpt_frequency = bus_frequency / 2;
+}
+
+/*
+ * EMMA[23]Sxx SoCs have mask bits for UART interrupts in the peripheral
+ * bus bridge registers for historical reasons, which turned out to be
+ * useless/worthless these days, sigh...
+ */
+#define PBRD_INT_MASK		(EMMA_PBRD_BASE + 0x10)
+#define PBRD_FUART0_INTEN	0x80
+#define PBRD_FUART1_INTEN	0x40
+
+static void __init emma3slx_sio_setup(void)
+{
+	struct uart_port up;
+#ifdef CONFIG_KGDB
+	int emma_uart;
+#endif
+	u32 __iomem *pbrd_int_mask;
+
+	/* Pbrd: unmask UART interrupts */
+	pbrd_int_mask = ioremap(PBRD_INT_MASK, sizeof(u32));
+	writel(PBRD_FUART0_INTEN | PBRD_FUART1_INTEN, pbrd_int_mask);
+	iounmap(pbrd_int_mask);
+
+	memset(&up, 0, sizeof(up));
+
+	up.flags	= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST;
+	up.iotype	= UPIO_DWAPB;
+	up.regshift	= 4;
+	up.uartclk	= 18432000;
+
+	up.line		= 0;
+	up.mapbase	= EMMA_PUART0_BASE + 3;
+	up.membase	= ioremap_nocache(up.mapbase, 0x40 << up.regshift);
+	up.irq		= EMMA_IRQ_PUART0;
+	up.private_data	= (void *)(up.membase + (0x1F << up.regshift));
+
+	early_serial_setup(&up);
+
+#ifdef CONFIG_KGDB
+	emma_uart	= 1;
+	up.line		= emma_uart;
+	up.mapbase	= EMMA_PUART0_BASE + 0x1000 * emma_uart + 3;
+	up.membase	= ioremap_nocache(up.mapbase, 0x40 << up.regshift);
+	up.irq		= EMMA_IRQ_PUART0 + emma_uart;
+	up.private_data	= (void *)(up.membase + (0x1F << up.regshift));
+
+	early_serial_setup(&up);
+#endif
+}
+
+static void __init flip_init(void)
+{
+	struct flip_regs *flip;
+
+	flip = ioremap(EMMA_FLIP_BASE + 0x100, sizeof(struct flip_regs));
+
+	/* For USB HCs */
+	emma_out(flip->m_ctr[0], SWAP1_BYTE);
+	emma_out(flip->usb_ctr,
+		 PPON2_EN | PPON1_EN | OCI2_EN | OCI1_EN |
+		 PPON2 | PPON1 | OCI2 | OCI1 | INTB_EN | INTA_EN);
+	emma_sync();
+
+	iounmap((void __iomem *)flip);
+}
+
+void __init plat_mem_setup(void)
+{
+	set_io_port_base(CKSEG1);
+
+	_machine_restart = emma3slx_machine_restart;
+	_machine_halt = emma3slx_machine_halt;
+	pm_power_off = emma3slx_machine_power_off;
+
+	/* setup resource limits */
+	ioport_resource.end = ~0;
+
+	/* Reboot on panic */
+	panic_timeout = 50;
+
+	emma3slx_sio_setup();
+	flip_init();
+}
-- 
1.6.3.3

