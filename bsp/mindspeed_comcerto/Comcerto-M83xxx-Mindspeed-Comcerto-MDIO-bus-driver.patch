From 07269088031de3e73f5b256e6c2b2bb97462a499 Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Tue, 19 Oct 2010 13:25:00 +0800
Subject: [PATCH 07/26] Comcerto: M83xxx: Mindspeed Comcerto MDIO bus driver

Original codes came from Mindspeed's vendor drop sdk-comcerto-openwrt-6.0.

The Comcerto M83xxx device has two MDIO bus. Now add the mdio buses driver.

Integrated-by: Stanley.Miao <stanley.miao@windriver.com>
---
 drivers/net/comcerto/comcerto_mii.c |  289 +++++++++++++++++++++++++++++++++++
 drivers/net/comcerto/comcerto_mii.h |   30 ++++
 2 files changed, 319 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/comcerto/comcerto_mii.c
 create mode 100644 drivers/net/comcerto/comcerto_mii.h

diff --git a/drivers/net/comcerto/comcerto_mii.c b/drivers/net/comcerto/comcerto_mii.c
new file mode 100644
index 0000000..4b787f9
--- /dev/null
+++ b/drivers/net/comcerto/comcerto_mii.c
@@ -0,0 +1,289 @@
+/*
+  *  linux/drivers/net/comcerto/comcerto_mii.c
+  *
+  *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2 of the License, or
+  * (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/unistd.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/crc32.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/mutex.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/uaccess.h>
+
+#include "comcerto_gemac.h"
+#include "comcerto_mii.h"
+
+static void comcerto_gem_set_mdc_div(struct comcerto_mii *mii, int mdc_div)
+{
+	u32 val = readl(mii->baseaddr + GEM_NET_CONFIG) & ~GEM_MDC_DIV_MASK;
+	u32 div;
+
+	switch (mdc_div) {
+	case 8:
+		div = 0;
+		break;
+
+	case 16:
+		div = 1;
+		break;
+
+	case 32:
+		div = 2;
+		break;
+
+	case 48:
+		div = 3;
+		break;
+
+	case 64:
+		div = 4;
+		break;
+
+	case 96:
+		div = 5;
+		break;
+
+	case 128:
+		div = 6;
+		break;
+
+	case 224:
+		div = 7;
+		break;
+	default:
+		div = 4;
+		break;
+	}
+
+	val |= div << 18;
+
+	__raw_writel(val, mii->baseaddr + GEM_NET_CONFIG);
+}
+
+
+static int comcerto_mdio_write(struct mii_bus *bus, int mii_id, int devad,
+						int regnum, u16 value)
+{
+	struct comcerto_mii *mii = (struct comcerto_mii *)bus->priv;
+	u32 write_data;
+
+	write_data = 0x50020000;
+	write_data |= ((mii_id << 23) | (regnum << 18) | value);
+	__raw_writel(write_data, mii->baseaddr + GEM_PHY_MAN);
+
+	while (!(__raw_readl(mii->baseaddr + GEM_NET_STATUS) & GEM_PHY_IDLE));
+
+	return 0;
+}
+
+
+static int comcerto_mdio_read(struct mii_bus *bus, int mii_id,
+					int devad, int regnum)
+{
+	struct comcerto_mii *mii = (struct comcerto_mii *)bus->priv;
+	u16 value;
+	u32 write_data;
+
+	write_data = 0x60020000;
+	write_data |= ((mii_id << 23) | (regnum << 18));
+	__raw_writel(write_data, mii->baseaddr + GEM_PHY_MAN);
+
+	while (!(__raw_readl(mii->baseaddr + GEM_NET_STATUS) & GEM_PHY_IDLE));
+	value = __raw_readl(mii->baseaddr + GEM_PHY_MAN) & 0xFFFF;
+
+	return value;
+}
+
+
+static int comcerto_mdio_reset(struct mii_bus *bus)
+{
+	struct comcerto_mii *mii = (struct comcerto_mii *)bus->priv;
+	volatile int delay_count;
+	unsigned int tmp;
+
+	mutex_lock(&bus->mdio_lock);
+
+	/* get GEMAC out of reset */
+	*(volatile u32 *)(COMCERTO_BLOCK_RESET_REG) |= (u32)GEMAC0_RST;
+	/* 20 ops delay */
+	delay_count = 20;
+	while (delay_count--);
+
+	/* Setup the MII Mgmt clock speed */
+	comcerto_gem_set_mdc_div(mii, mii->mdc_div);
+
+	/* Reset the management interface */
+	tmp = __raw_readl(mii->baseaddr + GEM_NET_CONTROL);
+	__raw_writel(tmp | GEM_MDIO_EN, mii->baseaddr + GEM_NET_CONTROL);
+
+	/* Wait until the bus is free */
+	while (!(__raw_readl(mii->baseaddr + GEM_NET_STATUS) & GEM_PHY_IDLE));
+
+	mutex_unlock(&bus->mdio_lock);
+
+	return 0;
+}
+
+
+static int comcerto_mdio_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct comcerto_mdio_data *pdata;
+	struct comcerto_mii *mii;
+	struct mii_bus *bus;
+	struct resource *r;
+	int rc;
+
+	bus = mdiobus_alloc();
+	if (!bus) {
+		printk(KERN_ERR "comcerto mdio %d: kzalloc() failed\n", pdev->id);
+		rc = -ENOMEM;
+		goto err0;
+	}
+
+	mii = kzalloc(sizeof(struct comcerto_mii), GFP_KERNEL);
+	if (!mii) {
+		printk(KERN_ERR "comcerto mdio %d: kzalloc() failed\n", pdev->id);
+		rc = -ENOMEM;
+		goto err1;
+	}
+
+	bus->name = "Comcerto MDIO Bus";
+	bus->read = &comcerto_mdio_read;
+	bus->write = &comcerto_mdio_write;
+	bus->reset = &comcerto_mdio_reset;
+	snprintf(bus->id, MII_BUS_ID_SIZE, "%x", pdev->id);
+	bus->priv = mii;
+
+	pdata = (struct comcerto_mdio_data *)pdev->dev.platform_data;
+	if (!pdata) {
+		printk(KERN_ERR "comcerto mdio %d: missing platform data\n", pdev->id);
+		rc = -EINVAL;
+		goto err2;
+	}
+
+	bus->phy_mask = pdata->phy_mask;
+	mii->mdc_div = pdata->mdc_div;
+
+	if (!mii->mdc_div)
+		mii->mdc_div = 64;
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!r) {
+		printk(KERN_ERR "comcerto mdio %d: missing platform resource\n", pdev->id);
+		rc = -EINVAL;
+		goto err2;
+	}
+	/* Set the PHY base address */
+#if defined(USE_IOREMAP)
+	mii->baseaddr = ioremap(r->start, r->end - r->start + 1);
+#else
+	mii->baseaddr = (void *)APB_VADDR(r->start);
+#endif
+
+	if (!mii->baseaddr) {
+		printk(KERN_ERR "comcerto mdio %d: ioremap() failed\n", pdev->id);
+		rc = -ENOMEM;
+		goto err2;
+	}
+
+	/* we don't have specific mdio irqs */
+	bus->irq = pdata->irq;
+	memset(bus->irq, 0, 32 * sizeof(int));
+
+	bus->parent = &pdev->dev;
+
+	rc = mdiobus_register(bus);
+	if (rc) {
+		printk(KERN_ERR "%s: Cannot register as MDIO bus\n", bus->name);
+		goto err3;
+	}
+	dev_set_drvdata(dev, bus);
+
+	return 0;
+
+err3:
+#if defined(USE_IOREMAP)
+	iounmap(mii->baseaddr);
+#endif
+err2:
+	kfree(mii);
+
+err1:
+	mdiobus_free(bus);
+
+err0:
+	return rc;
+}
+
+
+static int comcerto_mdio_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct mii_bus *bus = dev_get_drvdata(dev);
+
+	mdiobus_unregister(bus);
+
+	dev_set_drvdata(dev, NULL);
+#if defined(USE_IOREMAP)
+	iounmap(((struct comcerto_mii *)bus->priv)->baseaddr);
+#endif
+	kfree(bus->priv);
+	mdiobus_free(bus);
+
+	return 0;
+}
+
+/* Structure for a device driver */
+static struct platform_driver comcerto_mdio_driver = {
+	.probe = comcerto_mdio_probe,
+	.remove = comcerto_mdio_remove,
+	.driver	= {
+		.name = "comcerto-mdio",
+	},
+};
+
+int __init comcerto_mdio_init(void)
+{
+	return platform_driver_register(&comcerto_mdio_driver);
+}
+
+void  __exit comcerto_mdio_exit(void)
+{
+	platform_driver_unregister(&comcerto_mdio_driver);
+}
+
+module_init(comcerto_mdio_init);
+module_exit(comcerto_mdio_exit);
diff --git a/drivers/net/comcerto/comcerto_mii.h b/drivers/net/comcerto/comcerto_mii.h
new file mode 100644
index 0000000..dbd56d5
--- /dev/null
+++ b/drivers/net/comcerto/comcerto_mii.h
@@ -0,0 +1,30 @@
+/*
+  *  linux/drivers/net/comcerto/comcerto_mii.h
+  *
+  *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2 of the License, or
+  * (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  */
+#ifndef __COMCERTO_MII_H
+#define __COMCERTO_MII_H
+
+struct comcerto_mii {
+	void *baseaddr;
+	int mdc_div;
+};
+
+int __init comcerto_mdio_init(void);
+void __exit comcerto_mdio_exit(void);
+#endif
-- 
1.6.5.2

