From 3b9a583570bb6e687f52b37cc45a32673a67c4a0 Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Tue, 19 Oct 2010 15:25:02 +0800
Subject: [PATCH 09/26] Comcerto: M83xxx: Comcerto GEMAC driver

Original codes came from Mindspeed's vendor drop sdk-comcerto-openwrt-6.0.

The GEMAC driver consist of functions needed for GEMAC intialization, set
speed, and interrupt handler.

Integrated-by: Stanley.Miao <stanley.miao@windriver.com>
---
 drivers/net/comcerto/c1000_gemac.c |  215 ++++++++++++++++++++++++++++++++++++
 1 files changed, 215 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/comcerto/c1000_gemac.c

diff --git a/drivers/net/comcerto/c1000_gemac.c b/drivers/net/comcerto/c1000_gemac.c
new file mode 100644
index 0000000..f715fb9
--- /dev/null
+++ b/drivers/net/comcerto/c1000_gemac.c
@@ -0,0 +1,215 @@
+/*
+ *  linux/drivers/net/comcerto/c1000_gemac.c
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#include <linux/delay.h>
+#include <linux/io.h>
+
+
+#include "c1000_eth.h"
+#include "comcerto_gemac.h"
+
+int gem_add_arc_entry(GEM_DEVICE *gemdev, char *MAC_address)
+{
+	MAC_ADDR enet_addr;
+
+	gem_enet_addr_byte_mac(MAC_address, &enet_addr);
+	gem_set_laddr1(gemdev, &enet_addr);
+
+	return 0;
+}
+
+/* Initializes data structures and registers for the controller,
+ * and brings the interface up.	 Returns the link status, meaning
+ * that it returns success if the link is up, failure otherwise.
+ * This allows u-boot to find the first active controller. */
+static int gemac_init(struct eth_c1k_priv *priv)
+{
+	GEM_DEVICE *gemdev = &priv->gemdev;
+	struct comcerto_eth_platform_data *einfo = priv->einfo;
+
+	/* software config */
+	switch (einfo->mii_config) {
+	case CONFIG_COMCERTO_USE_GMII:
+		writel(einfo->gemac_mode | GEM_CONF_MODE_SEL_GEM | GEM_CONF_MODE_GEM_GMII, priv->baseaddr + GEM_CFG);
+		printk(KERN_DEBUG "comcerto gemac%d software config using GMII\n", einfo->gem_id);
+		break;
+
+	case CONFIG_COMCERTO_USE_RGMII:
+		writel(einfo->gemac_mode | GEM_CONF_MODE_SEL_GEM | GEM_CONF_MODE_GEM_RGMII, priv->baseaddr + GEM_CFG);
+		printk(KERN_DEBUG "comcerto gemac%d software config using RGMII\n", einfo->gem_id);
+		break;
+
+	case CONFIG_COMCERTO_USE_RMII:
+		writel(einfo->gemac_mode | GEM_CONF_MODE_SEL_GEM | GEM_CONF_MODE_GEM_RMII, priv->baseaddr + GEM_CFG);
+		printk(KERN_DEBUG "comcerto gemac%d software config using RMII\n", einfo->gem_id);
+		break;
+
+	case CONFIG_COMCERTO_USE_MII:
+		writel(einfo->gemac_mode | GEM_CONF_MODE_SEL_GEM | GEM_CONF_MODE_GEM_MII, priv->baseaddr + GEM_CFG);
+		printk(KERN_DEBUG "comcerto gemac%d software config using MII\n", einfo->gem_id);
+		break;
+
+	default:
+		if (einfo->gemac_mode & (GEMAC_SW_CONF)) {
+			printk(KERN_DEBUG "comcerto gemac software config requires one MII mode defined \n");
+			BUG();
+		} else {
+			writel(einfo->gemac_mode | GEM_CONF_MODE_SEL_GEM | GEM_CONF_MODE_GEM_MII, priv->baseaddr + GEM_CFG);
+			printk(KERN_DEBUG "comcerto gemac%d hardware MII config \n", einfo->gem_id);
+		}
+
+		break;
+	}
+
+	/* Reset the MAC */
+	gem_reset(gemdev);
+
+	gem_disable_copy_all(gemdev);
+	gem_allow_broadcast(gemdev);
+	gem_disable_unicast(gemdev);
+	gem_disable_multicast(gemdev);
+	gem_disable_fcs_rx(gemdev);
+	gem_enable_1536_rx(gemdev);
+
+	/*GEM will perform checksum verifications*/
+	if (priv->flags & RX_CSUM_OFFLOAD_ENABLED)
+		gem_enable_rx_checksum_offload(gemdev);
+	else
+		gem_disable_rx_checksum_offload(gemdev);
+
+	if (priv->flags & TX_CSUM_OFFLOAD_ENABLED)
+		gem_enable_tx_checksum_offload(gemdev);
+	else
+		gem_disable_tx_checksum_offload(gemdev);
+
+	/* enable Pause frame reception */
+	gem_enable_pause_rx(gemdev);
+
+	return 1;
+}
+
+
+irqreturn_t c1k_gemac_interrupt(int irq, void *dev_id)
+{
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct eth_c1k_priv *priv = netdev_priv(dev);
+	GEM_DEVICE *gem = &priv->gemdev;
+	unsigned long statusword;
+
+	statusword = gem_get_irq_stat(gem);
+	return IRQ_HANDLED;
+}
+
+void c1k_gemac_setduplex(struct net_device *dev, int duplex)
+{
+	struct eth_c1k_priv *priv = netdev_priv(dev);
+	GEM_DEVICE *gemdev = &priv->gemdev;
+
+	if (duplex == DUPLEX_HALF)
+		gem_half_duplex(gemdev);
+	else
+		gem_full_duplex(gemdev);
+}
+
+void c1k_gemac_setspeed(struct net_device *dev, int speed)
+{
+	struct eth_c1k_priv *priv = netdev_priv(dev);
+	GEM_DEVICE *gemdev = &priv->gemdev;
+
+	switch (speed) {
+	case 10:
+		writel(readl(priv->baseaddr + GEM_IP + GEM_NET_CONFIG) | GEM_RX_BAD_PREAMBLE, priv->baseaddr + GEM_IP + GEM_NET_CONFIG);
+		gem_set_speed(gemdev, SPEED_10M);
+		break;
+	case 100:
+		writel(readl(priv->baseaddr + GEM_IP + GEM_NET_CONFIG) & ~GEM_RX_BAD_PREAMBLE, priv->baseaddr + GEM_IP + GEM_NET_CONFIG);
+		gem_set_speed(gemdev, SPEED_100M);
+		break;
+	case 1000:
+	default:
+		writel(readl(priv->baseaddr + GEM_IP + GEM_NET_CONFIG) & ~GEM_RX_BAD_PREAMBLE, priv->baseaddr + GEM_IP + GEM_NET_CONFIG);
+		gem_set_speed(gemdev, SPEED_1000M);
+		break;
+	}
+}
+
+int c1k_gemac_init(struct net_device *dev)
+{
+	struct eth_c1k_priv *priv = netdev_priv(dev);
+	GEM_DEVICE *gemdev = &priv->gemdev;
+	u32 dma_cfg;
+
+	dma_cfg = readl(priv->baseaddr + GEM_IP + GEM_DMA_CONFIG);
+
+	dma_cfg |= (1UL<<31); /* enable scheduler */
+	dma_cfg &= ~((1UL<<26) | (1UL<<25)); /* hardware buffer allocation */
+	dma_cfg |= (1UL<<12); /* enable scheduler */
+	dma_cfg &= ~(0x00FF001F); /* enable admittance manager */
+	dma_cfg |= 0x00200000; /* set buffer size to 2048 bytes */
+	dma_cfg |= 0x00000010; /* Attempt to use INCR16 AHB bursts */
+	dma_cfg |=  GEM_RX_SW_ALLOC;
+
+	if (priv->einfo->device_flags & COMCERTO_GEM_DELAY) {
+		/* Removing the RGMII delay in gem */
+		printk(KERN_DEBUG "Disabling GEM%d delay\n", priv->einfo->gem_id);
+		writel(0x0, priv->baseaddr + 0xF00C);
+	}
+
+	writel(dma_cfg, priv->baseaddr + GEM_IP + GEM_DMA_CONFIG);
+
+	gemac_init(priv);
+
+	gem_enable_irq(gemdev, GEM_IRQ_RX_ORUN);
+
+	return 0;
+}
+
+int c1k_emac_checksum(struct eth_c1k_priv *priv, u32 status, u8 *ip_summed)
+{
+	if (!(priv->flags & RX_CSUM_OFFLOAD_ENABLED)) {
+		*ip_summed = CHECKSUM_NONE;
+
+		return 0;
+	}
+
+	/* Checksums checked and correct */
+	if ((status & RX_STA_CKSUM_MASK) == RX_STA_CKSUM_MASK) {
+		*ip_summed = CHECKSUM_UNNECESSARY;
+
+		return 0;
+	}
+
+	/* At least one checksum failure */
+	if ((status & (RX_STA_L3_CKSUM | RX_STA_L4_CKSUM)) == (RX_STA_L3_CKSUM | RX_STA_L4_CKSUM))
+		return -1;
+
+	/* L3 checksum failure */
+	if ((status & (RX_STA_L3_CKSUM | RX_STA_L3_GOOD)) == RX_STA_L3_CKSUM)
+		return -1;
+
+	/* L4 checksum failure */
+	if ((status & (RX_STA_L4_CKSUM | RX_STA_L4_GOOD)) == RX_STA_L4_CKSUM)
+		return -1;
+
+	/* one or both checksums were not checked */
+	*ip_summed = CHECKSUM_NONE;
+
+	return 0;
+}
-- 
1.6.5.2

