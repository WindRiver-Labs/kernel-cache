From 45bee40cb1ecb0d04f4e31912d11249907200064 Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Sun, 26 Sep 2010 16:48:29 +0800
Subject: [PATCH 25/26] Comcerto: M83xxx: comcerto spi bus support

Original codes came from Mindspeed's vendor drop sdk-comcerto-openwrt-6.0.

Mindspeed implemented a different spi driver for their comcerto spi bus.

Integrated-by: Stanley.Miao <stanley.miao@windriver.com>
---
 drivers/Kconfig                    |    4 +
 drivers/Makefile                   |    1 +
 drivers/spi2/Kconfig               |   15 +
 drivers/spi2/Makefile              |    7 +
 drivers/spi2/busses/Kconfig        |    9 +
 drivers/spi2/busses/Makefile       |    1 +
 drivers/spi2/busses/comcerto_spi.c |  592 ++++++++++++++++++++++++++++++++++++
 drivers/spi2/busses/comcerto_spi.h |   82 +++++
 drivers/spi2/spi-core.c            |  395 ++++++++++++++++++++++++
 include/linux/spi2/spi.h           |  134 ++++++++
 10 files changed, 1240 insertions(+), 0 deletions(-)
 create mode 100644 drivers/spi2/Kconfig
 create mode 100644 drivers/spi2/Makefile
 create mode 100644 drivers/spi2/busses/Kconfig
 create mode 100644 drivers/spi2/busses/Makefile
 create mode 100644 drivers/spi2/busses/comcerto_spi.c
 create mode 100644 drivers/spi2/busses/comcerto_spi.h
 create mode 100644 drivers/spi2/spi-core.c
 create mode 100644 include/linux/spi2/spi.h

diff --git a/drivers/Kconfig b/drivers/Kconfig
index a2b902f..90992d4 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -50,6 +50,10 @@ source "drivers/i2c/Kconfig"
 
 source "drivers/spi/Kconfig"
 
+if ARCH_COMCERTO
+source "drivers/spi2/Kconfig"
+endif
+
 source "drivers/pps/Kconfig"
 
 source "drivers/gpio/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index 6280b72..e4e0ecb 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -46,6 +46,7 @@ obj-$(CONFIG_SCSI)		+= scsi/
 obj-$(CONFIG_ATA)		+= ata/
 obj-$(CONFIG_MTD)		+= mtd/
 obj-$(CONFIG_SPI)		+= spi/
+obj-$(CONFIG_SPI_MSPD)		+= spi2/
 obj-y				+= net/
 obj-$(CONFIG_ATM)		+= atm/
 obj-$(CONFIG_FUSION)		+= message/
diff --git a/drivers/spi2/Kconfig b/drivers/spi2/Kconfig
new file mode 100644
index 0000000..56db7f5
--- /dev/null
+++ b/drivers/spi2/Kconfig
@@ -0,0 +1,15 @@
+#
+# Character device configuration
+#
+
+menu "SPI2 support"
+	depends on (ARCH_COMCERTO)
+config SPI_MSPD
+	tristate "Mindspeed SPI support"
+	help
+	  Mindspeed SPI (Serial Pheripheral Interface bus) core support
+
+source drivers/spi2/busses/Kconfig
+
+endmenu
+
diff --git a/drivers/spi2/Makefile b/drivers/spi2/Makefile
new file mode 100644
index 0000000..cf3456f
--- /dev/null
+++ b/drivers/spi2/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for the spi core.
+#
+
+obj-$(CONFIG_SPI_MSPD) += spi-core.o
+obj-y		  += busses/
+
diff --git a/drivers/spi2/busses/Kconfig b/drivers/spi2/busses/Kconfig
new file mode 100644
index 0000000..aeea3be
--- /dev/null
+++ b/drivers/spi2/busses/Kconfig
@@ -0,0 +1,9 @@
+
+menu "SPI Hardware Bus support"
+	depends on SPI_MSPD
+
+config COMCERTO_SPI
+	tristate "Comcerto"
+	depends on SPI_MSPD
+
+endmenu
diff --git a/drivers/spi2/busses/Makefile b/drivers/spi2/busses/Makefile
new file mode 100644
index 0000000..c183ca8
--- /dev/null
+++ b/drivers/spi2/busses/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_COMCERTO_SPI)        += comcerto_spi.o
diff --git a/drivers/spi2/busses/comcerto_spi.c b/drivers/spi2/busses/comcerto_spi.c
new file mode 100644
index 0000000..020af0d
--- /dev/null
+++ b/drivers/spi2/busses/comcerto_spi.c
@@ -0,0 +1,592 @@
+/*
+ *  drivers/spi2/busses/comcerto_spi.c
+ *
+ *  Copyright (C) 2004,2005 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <asm/io.h>
+#include <asm/sizes.h>
+#include <mach/irqs.h>
+
+#include <linux/platform_device.h>
+#include "comcerto_spi.h"
+
+/*
+ * do_write_read_transfer8 -
+ */
+static int do_write_read_transfer8(struct comcerto_spi *spi, u8 *wbuf, unsigned int *wlen, u8 *rbuf, unsigned int *rlen)
+{
+	unsigned int len_now;
+	int rc = 0;
+	unsigned int wtmp = *wlen, rtmp = *rlen;
+	u32 dr = spi->membase + COMCERTO_SPI_DR;
+	u32 txflr = spi->membase + COMCERTO_SPI_TXFLR;
+	u32 rxflr = spi->membase + COMCERTO_SPI_RXFLR;
+
+	while (wtmp || rtmp) {
+		len_now = 8 - __raw_readl(txflr);
+		if (len_now > wtmp)
+			len_now = wtmp;
+
+		wtmp -= len_now;
+
+		/* warm-up write fifo to avoid underruns */
+		while (len_now--)
+			__raw_writew(cpu_to_le16((u16) *wbuf++), dr);
+
+
+		len_now = __raw_readl(rxflr);
+		if (len_now > rtmp)
+			len_now = rtmp;
+
+		rtmp -= len_now;
+
+		while (len_now--) {
+			*rbuf = (u8) (le16_to_cpu(__raw_readw(dr)) & 0xff);
+			rbuf++;
+		}
+	}
+
+	*rlen -= rtmp;
+	*wlen -= wtmp;
+
+	return rc;
+}
+
+/*
+ * do_write_read_transfer16 -
+ */
+static int do_write_read_transfer16(struct comcerto_spi *spi, u16 *wbuf, unsigned int *wlen, u16 *rbuf, unsigned int *rlen)
+{
+	unsigned int len_now;
+	int rc = 0;
+	unsigned int wtmp = *wlen, rtmp = *rlen;
+	unsigned int wpadding, rpadding;
+	u32 dr = spi->membase + COMCERTO_SPI_DR;
+	u32 txflr = spi->membase + COMCERTO_SPI_TXFLR;
+	u32 rxflr = spi->membase + COMCERTO_SPI_RXFLR;
+
+	if (wtmp > rtmp) {
+		wpadding  = 0;
+		rpadding = wtmp - rtmp;
+	} else {
+		wpadding = rtmp - wtmp;
+		rpadding = 0;
+	}
+
+	while (wtmp || rtmp) {
+		len_now = 8 - __raw_readl(txflr);
+
+		if (wtmp) {
+			if (len_now > wtmp)
+				len_now = wtmp;
+
+			wtmp -= len_now;
+
+			while (len_now--)
+				__raw_writew(cpu_to_le16(*wbuf++), dr);
+
+		} else if (wpadding) {
+			if (len_now > wpadding)
+				len_now = wpadding;
+
+			wpadding -= len_now;
+
+			while (len_now--)
+				__raw_writew(0, dr);
+		}
+
+		len_now = __raw_readl(rxflr);
+		if (rtmp) {
+			if (len_now > rtmp)
+				len_now = rtmp;
+
+			rtmp -= len_now;
+
+			while (len_now--) {
+				*rbuf = le16_to_cpu(__raw_readw(dr));
+				rbuf++;
+			}
+		} else if (rpadding) {
+			if (len_now > rpadding)
+				len_now = rpadding;
+
+			rpadding -= len_now;
+
+			while (len_now--)
+				__raw_readw(dr);
+		}
+	}
+
+	*rlen -= rtmp;
+	*wlen -= wtmp;
+
+	return rc;
+}
+
+
+/**
+ * do_write_only_transfer8 -
+ *
+ *
+ */
+static int do_write_only_transfer8(struct comcerto_spi *spi, u8 *buf, unsigned int *len)
+{
+	unsigned int len_now;
+	int rc = 0;
+	unsigned int tmp = *len;
+	u32 dr = spi->membase + COMCERTO_SPI_DR;
+	u32 txflr = spi->membase + COMCERTO_SPI_TXFLR;
+
+	while (tmp) {
+		len_now = 8 - __raw_readl(txflr);
+		if (len_now > tmp)
+			len_now = tmp;
+
+		tmp -= len_now;
+
+		while (len_now--)
+			__raw_writew(cpu_to_le16((u16) *buf++), dr);
+	}
+
+	*len -= tmp;
+
+	return rc;
+}
+
+/**
+ * do_write_only_transfer -
+ *
+ *
+ */
+static int do_write_only_transfer16(struct comcerto_spi *spi, u16 *buf, unsigned int *len)
+{
+	unsigned int len_now;
+	int rc = 0;
+	unsigned int tmp = *len;
+	u32 dr = spi->membase + COMCERTO_SPI_DR;
+	u32 txflr = spi->membase + COMCERTO_SPI_TXFLR;
+
+	while (tmp) {
+		len_now = 8 - __raw_readl(txflr);
+		if (len_now > tmp)
+			len_now = tmp;
+
+		tmp -= len_now;
+
+		while (len_now--)
+			__raw_writew(cpu_to_le16(*buf++), dr);
+	}
+
+	*len -= tmp;
+
+	return rc;
+}
+
+
+/**
+ * do_read_only_transfer -
+ *
+ *
+ */
+static int do_read_only_transfer8(struct comcerto_spi *spi, u8 *buf, unsigned int *len)
+{
+	unsigned int len_now;
+	int rc = 0;
+	unsigned int tmp = *len;
+	u32 dr = spi->membase + COMCERTO_SPI_DR;
+	u32 rxflr = spi->membase + COMCERTO_SPI_RXFLR;
+
+	/* start the serial clock */
+	__raw_writew(0, dr);
+
+	while (tmp) {
+		len_now = __raw_readl(rxflr);
+		if (len_now > tmp)
+			len_now = tmp;
+
+		tmp -= len_now;
+
+		while (len_now--) {
+			*buf = (u8) (le16_to_cpu(__raw_readw(dr)) & 0xff);
+			buf++;
+		}
+	}
+
+	*len -= tmp;
+
+	return rc;
+}
+
+/*
+ * do_read_only_transfer -
+ */
+static int do_read_only_transfer16(struct comcerto_spi *spi, u16 *buf, unsigned int *len)
+{
+	unsigned int len_now;
+	int rc = 0;
+	unsigned int tmp = *len;
+	u32 dr = spi->membase + COMCERTO_SPI_DR;
+	u32 rxflr = spi->membase + COMCERTO_SPI_RXFLR;
+
+	/* start the serial clock */
+	__raw_writew(0, dr);
+
+	while (tmp) {
+		len_now = __raw_readl(rxflr);
+		if (len_now > tmp)
+			len_now = tmp;
+
+		tmp -= len_now;
+
+		while (len_now--) {
+			*buf = le16_to_cpu(__raw_readw(dr));
+			buf++;
+		}
+	}
+
+	*len -= tmp;
+
+	return rc;
+}
+
+
+/**
+ * comcerto_spi_do_transfer -
+ *
+ *
+ */
+int comcerto_spi_do_transfer(struct spi_adapter *adapter, struct spi_transfer *transfer, struct spi_client_config *config)
+{
+	struct comcerto_spi *spi = (struct comcerto_spi *)adapter->data;
+	u32 ctrlr0, ctrlr1, baudr, ser;
+	int rc;
+
+	/* make sure last transaction is finished */
+	while (__raw_readl(spi->membase + COMCERTO_SPI_SR) & BUSY);
+
+	ctrlr0 = ((config->sc_polarity & 0x1) << 7) | ((config->sc_phase & 0x1) << 6) | (((transfer->fs - 1) & 0xf) << 0);
+
+	baudr = spi->clock_rate / config->sc_rate;
+
+	ser = config->cs_msk & adapter->caps.cs_msk;
+
+	__raw_writel(0, spi->membase + COMCERTO_SPI_SSIENR);
+
+	switch (transfer->mode & 0x0f) {
+	case SPI_TRANSFER_MODE_WRITE_ONLY:
+		ctrlr0 |= (0x0001 << 8);
+		__raw_writel(ctrlr0, spi->membase + COMCERTO_SPI_CTRLR0);
+		__raw_writel(baudr, spi->membase + COMCERTO_SPI_BAUDR);
+		__raw_writel(ser, spi->membase + COMCERTO_SPI_SER);
+		__raw_writel(8, spi->membase + COMCERTO_SPI_RXFTLR);
+		__raw_writel(0, spi->membase + COMCERTO_SPI_TXFTLR);
+		__raw_writel(0, spi->membase + COMCERTO_SPI_IMR);
+		__raw_writel(1, spi->membase + COMCERTO_SPI_SSIENR);
+
+		if (transfer->fs <= 8)
+			rc = do_write_only_transfer8(spi, transfer->wbuf, &transfer->wlen);
+		else
+			rc = do_write_only_transfer16(spi, (u16 *) transfer->wbuf, &transfer->wlen);
+		break;
+
+	case SPI_TRANSFER_MODE_READ_ONLY:
+		ctrlr0 |= (0x0002 << 8);
+		ctrlr1 = transfer->rlen - 1;
+
+		__raw_writel(ctrlr0, spi->membase + COMCERTO_SPI_CTRLR0);
+		__raw_writel(ctrlr1, spi->membase + COMCERTO_SPI_CTRLR1);
+		__raw_writel(baudr, spi->membase + COMCERTO_SPI_BAUDR);
+		__raw_writel(ser, spi->membase + COMCERTO_SPI_SER);
+		__raw_writel(8, spi->membase + COMCERTO_SPI_RXFTLR);
+		__raw_writel(0, spi->membase + COMCERTO_SPI_TXFTLR);
+		__raw_writel(0, spi->membase + COMCERTO_SPI_IMR);
+		__raw_writel(1, spi->membase + COMCERTO_SPI_SSIENR);
+
+		if (transfer->fs <= 8)
+			rc = do_read_only_transfer8(spi, transfer->rbuf, &transfer->rlen);
+		else
+			rc = do_read_only_transfer16(spi, (u16 *) transfer->rbuf, &transfer->rlen);
+		break;
+
+	case SPI_TRANSFER_MODE_WRITE_READ:
+		ctrlr0 |= (0x0000 << 8);
+
+		__raw_writel(ctrlr0, spi->membase + COMCERTO_SPI_CTRLR0);
+		__raw_writel(baudr, spi->membase + COMCERTO_SPI_BAUDR);
+		__raw_writel(ser, spi->membase + COMCERTO_SPI_SER);
+		__raw_writel(8, spi->membase + COMCERTO_SPI_RXFTLR);
+		__raw_writel(0, spi->membase + COMCERTO_SPI_TXFTLR);
+		__raw_writel(0, spi->membase + COMCERTO_SPI_IMR);
+		__raw_writel(1, spi->membase + COMCERTO_SPI_SSIENR);
+
+		if (transfer->fs <= 8)
+			rc = do_write_read_transfer8(spi, transfer->wbuf, &transfer->wlen, transfer->rbuf, &transfer->rlen);
+		else
+			rc = do_write_read_transfer16(spi, (u16 *) transfer->wbuf, &transfer->wlen, (u16 *) transfer->rbuf, &transfer->rlen);
+		break;
+	default:
+		rc = -1;
+		break;
+	}
+
+	return rc;
+}
+
+/*
+ * comcerto_spi_hw_init -
+ */
+static void comcerto_spi_hw_init(struct comcerto_spi *spi)
+{
+
+#ifndef CONFIG_ARCH_M83XXX
+	/* enable SPI bus */
+	comcerto_gpio_ctrl(0x3 << 4, 0x3 << 4);
+#endif
+
+	/* disable SPI operation */
+	writel(0, spi->membase + COMCERTO_SPI_SSIENR);
+
+	/* mask all SPI irq's */
+	writel(0, spi->membase + COMCERTO_SPI_IMR);
+}
+
+/*
+ * comcerto_spi_hw_reset -
+ */
+static void comcerto_spi_hw_reset(struct comcerto_spi *spi)
+{
+	/* disable SPI operation */
+	writel(0, spi->membase + COMCERTO_SPI_SSIENR);
+
+	/* mask all SPI irq's */
+	writel(0, spi->membase + COMCERTO_SPI_IMR);
+
+#ifndef CONFIG_ARCH_M83XXX
+	/* disable SPI bus */
+	comcerto_gpio_ctrl(0x0 << 4, 0x3 << 4);
+#endif
+}
+
+struct spi_adapter comcerto_spi_adapter = {
+	.name = "comcerto-spi",
+	.do_transfer = comcerto_spi_do_transfer,
+};
+
+/*
+ * comcerto_spi_probe -
+ */
+static int __init comcerto_spi_probe(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct comcerto_spi *spi;
+	unsigned long base, len;
+
+	spi = kmalloc(sizeof(struct comcerto_spi), GFP_KERNEL);
+	if (spi == NULL) {
+		printk(KERN_INFO "comcerto_spi: error allocating memory");
+		goto err0;
+	}
+
+	base = pdev->resource[0].start;
+	len = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+	if (!request_mem_region(base, len, COMCERTO_SPI_DRIVER_NAME)) {
+		printk(KERN_INFO "comcerto_spi: error requesting memory region %#lx - %#lx", base, base + len);
+		goto err1;
+	}
+
+	/* io-remaped in arch/arm/mm.c */
+	spi->membase = APB_VADDR(pdev->resource[0].start);
+	spi->irq = pdev->resource[1].start;
+
+	comcerto_spi_hw_init(spi);
+	spi->adapter = &comcerto_spi_adapter;
+
+	comcerto_spi_adapter.dev.parent = &pdev->dev;
+	comcerto_spi_adapter.data = spi;
+	comcerto_spi_adapter.caps.max_sc_rate = (COMCERTO_DEFAULTAHBCLK * 1000000) / 2;
+	comcerto_spi_adapter.caps.min_sc_rate = (COMCERTO_DEFAULTAHBCLK * 1000000) / 0xffff;
+	comcerto_spi_adapter.caps.max_fs = 16;
+	comcerto_spi_adapter.caps.min_fs = 4;
+	comcerto_spi_adapter.caps.max_nframe = 0xffff;
+	comcerto_spi_adapter.caps.min_nframe = 1;
+	comcerto_spi_adapter.caps.cs_msk = 0xf;
+
+	if (spi_add_adapter(&comcerto_spi_adapter)) {
+		printk(KERN_INFO "comcerto_spi: error adding adapter\n");
+		goto err3;
+	}
+
+	spi->clock_rate = (COMCERTO_DEFAULTAHBCLK * 1000000);
+	dev_set_drvdata(&pdev->dev, spi);
+	return 0;
+
+err3:
+	release_mem_region(base, len);
+
+err1:
+	kfree(spi);
+
+err0:
+	return -1;
+}
+
+/*
+ * comcerto_spi_remove -
+ */
+static int comcerto_spi_remove(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct comcerto_spi *spi = dev_get_drvdata(&pdev->dev);
+	unsigned long base, len;
+
+	dev_set_drvdata(&pdev->dev, NULL);
+
+	spi_del_adapter(spi->adapter);
+
+	comcerto_spi_hw_reset(spi);
+
+	base = pdev->resource[0].start;
+	len = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+	release_mem_region(base, len);
+
+	kfree(spi);
+
+	return 0;
+}
+
+static struct resource comcerto_spi_resources[] = {
+	{
+	 .start = COMCERTO_APB_SPI_BASE,
+	 .end   = COMCERTO_APB_SPI_BASE + SZ_4K - 1,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	 .start = IRQ_SPI,
+	 .flags = IORESOURCE_IRQ,
+	 }
+};
+
+#ifdef CONFIG_PM
+static int spi_suspend(struct device *dev, pm_message_t state)
+{
+	int ret;
+	struct spi_client *client;
+	struct list_head *item, *_n;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct comcerto_spi *spi = dev_get_drvdata(&pdev->dev);
+	state.event = PM_EVENT_SUSPEND;
+	list_for_each_safe(item, _n, &spi->adapter->clients) {
+		client = list_entry(item, struct spi_client, list);
+		if (client->driver->suspend != NULL)
+			ret = client->driver->suspend(client, state);
+	}
+
+	if (ret == 0)
+		pwr_mgmt_clk_down(COMPONENT_SPI);
+
+	return 0;
+}
+
+static int spi_resume(struct device *dev)
+{
+	struct spi_client *client;
+	struct list_head *item, *_n;
+	struct platform_device *pdev = to_platform_device(dev);
+	struct comcerto_spi *spi = dev_get_drvdata(&pdev->dev);
+
+	pwr_mgmt_clk_restore(COMPONENT_SPI);
+
+	list_for_each_safe(item, _n, &spi->adapter->clients) {
+		client = list_entry(item, struct spi_client, list);
+		if (client->driver->resume != NULL)
+			client->driver->resume(client);
+	}
+
+	return 0;
+}
+#endif
+
+static struct device_driver comcerto_spi_driver = {
+	.name    = "comcerto-spi",
+	.bus     = &platform_bus_type,
+	.probe   = comcerto_spi_probe,
+	.remove  = comcerto_spi_remove,
+#ifdef CONFIG_PM
+	.suspend = spi_suspend,
+	.resume  = spi_resume,
+#endif
+};
+
+static void comcerto_spi_release(struct device *dev)
+{
+	/* Just to keep driver model happy */
+}
+
+static struct platform_device comcerto_spi_device = {
+	.name = "comcerto-spi",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(comcerto_spi_resources),
+	.resource = comcerto_spi_resources,
+	.dev = {
+		.release = comcerto_spi_release,
+	},
+};
+
+/*
+ * comcerto_spi_init -
+ */
+static int __init comcerto_spi_init(void)
+{
+	if (driver_register(&comcerto_spi_driver)) {
+		printk(KERN_INFO "comcerto_spi: error registering driver\n");
+		goto err0;
+	}
+
+	if (platform_device_register(&comcerto_spi_device)) {
+		printk(KERN_INFO "comcerto_spi: error registering device\n");
+		goto err1;
+	}
+
+	return 0;
+
+err1:
+	driver_unregister(&comcerto_spi_driver);
+
+err0:
+	return -1;
+}
+
+/*
+ * comcerto_spi_exit -
+ */
+static void __exit comcerto_spi_exit(void)
+{
+	platform_device_unregister(&comcerto_spi_device);
+	driver_unregister(&comcerto_spi_driver);
+}
+
+MODULE_AUTHOR("Mindspeed Technologies, Inc.");
+MODULE_DESCRIPTION("Comcerto SPI bus driver");
+MODULE_LICENSE("GPL");
+
+module_init(comcerto_spi_init);
+module_exit(comcerto_spi_exit);
diff --git a/drivers/spi2/busses/comcerto_spi.h b/drivers/spi2/busses/comcerto_spi.h
new file mode 100644
index 0000000..7aebe24
--- /dev/null
+++ b/drivers/spi2/busses/comcerto_spi.h
@@ -0,0 +1,82 @@
+/*
+ *  linux/drivers/spi2/busses/comcerto_spi.h
+ *
+ *  Copyright (C) Mindspeed Technologies
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef _COMCERTO_SPI_H
+#define _COMCERTO_SPI_H
+
+#include <linux/spi2/spi.h>
+
+#define COMCERTO_SPI_DRIVER_NAME	"Comcerto SPI"
+
+#define COMCERTO_SPI_CTRLR0               0x00
+#define COMCERTO_SPI_CTRLR1               0x04
+#define COMCERTO_SPI_SSIENR               0x08
+#define COMCERTO_SPI_MWCR                 0x0C
+#define COMCERTO_SPI_SER                  0x10
+#define COMCERTO_SPI_BAUDR                0x14
+#define COMCERTO_SPI_TXFTLR               0x18
+#define COMCERTO_SPI_RXFTLR               0x1C
+#define COMCERTO_SPI_TXFLR                0x20
+#define COMCERTO_SPI_RXFLR                0x24
+#define COMCERTO_SPI_SR                   0x28
+#define COMCERTO_SPI_IMR                  0x2C
+#define COMCERTO_SPI_ISR                  0x30
+#define COMCERTO_SPI_RISR                 0x34
+#define COMCERTO_SPI_TXOICR               0x38
+#define COMCERTO_SPI_RXOICR               0x3C
+#define COMCERTO_SPI_RXUICR               0x40
+#define COMCERTO_SPI_MSTICR               0x44
+#define COMCERTO_SPI_ICR                  0x48
+#define COMCERTO_SPI_IDR                  0x58
+#define COMCERTO_SPI_DR                   0x60
+
+
+/* SR - status register bits */
+#define BUSY		(1<<0)	/* SSI busy flag, serial transfer in progress */
+#define TFNF		(1<<1)	/* Transmit FIFO not full */
+#define TFE		(1<<2)	/* Transmit FIFO empty */
+#define RFNE		(1<<3)	/* Receive FIFO not empty */
+#define RFF		(1<<4)	/* Receive FIFO full */
+#define TXE		(1<<5)	/* Transmission error */
+#define DCOL		(1<<6)	/* Data collision error */
+
+/* Interrupt status after being masked */
+#define TXEIS		(1<<0)	/* Transmit FIFO empty interrupt status */
+#define TXOIS		(1<<1)	/* Transmit FIFO overflow interrupt status */
+#define RXUIS		(1<<2)	/* Receive FIFO underflow interrupt status */
+#define RXOIS		(1<<3)	/* Receive FIFO overflow interrupt status */
+#define RXFIS		(1<<4)	/* Receive FIFO full interrupt status */
+#define MSTIS		(1<<5)	/* Multi-Master contention interrupt status */
+
+/* Interrupt status before being masked */
+#define TXEIR		(1<<0)	/* Transmit FIFO empty interrupt status */
+#define TXOIR		(1<<1)	/* Transmit FIFO overflow interrupt status */
+#define RXUIR		(1<<2)	/* Receive FIFO underflow interrupt status */
+#define RXOIR		(1<<3)	/* Receive FIFO overflow interrupt status */
+#define RXFIR		(1<<4)	/* Receive FIFO full interrupt status */
+#define MSTIR		(1<<5)	/* Multi-Master contention interrupt status */
+
+
+/* Interrupt mask register */
+#define TXEIM		(1<<0)	/* Transmit FIFO empty interrupt status */
+#define TXOIM		(1<<1)	/* Transmit FIFO overflow interrupt status */
+#define RXUIM		(1<<2)	/* Receive FIFO underflow interrupt status */
+#define RXOIM		(1<<3)	/* Receive FIFO overflow interrupt status */
+#define RXFIM		(1<<4)	/* Receive FIFO full interrupt status */
+#define MSTIM		(1<<5)	/* Multi-Master contention interrupt status */
+
+struct comcerto_spi {
+	struct spi_adapter *adapter;
+	unsigned long membase;
+	int irq;
+	unsigned long clock_rate;
+};
+
+#endif /* _COMCERTO_SPI_H */
diff --git a/drivers/spi2/spi-core.c b/drivers/spi2/spi-core.c
new file mode 100644
index 0000000..b396933
--- /dev/null
+++ b/drivers/spi2/spi-core.c
@@ -0,0 +1,395 @@
+/*
+ *  linux/drivers/spi2/spi-core.c
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/uaccess.h>
+#include <linux/delay.h>
+#include <linux/spi2/spi.h>
+
+static LIST_HEAD(spi_adapters);
+static LIST_HEAD(spi_drivers);
+
+/*
+ * spi_write_mem -
+ */
+int spi_write_mem(struct spi_client *client, u8 fs, u8 *buffer, int len)
+{
+	struct spi_transfer transfer;
+	struct spi_adapter *adapter = client->adapter;
+	unsigned long flags;
+	int rc;
+
+	memset(&transfer, 0, sizeof(struct spi_transfer));
+
+	transfer.fs = fs;
+	transfer.mode = SPI_TRANSFER_MODE_WRITE_ONLY;
+	transfer.wbuf = buffer;
+	transfer.wlen = len;
+
+	spin_lock_irqsave(&adapter->lock, flags);
+	rc = adapter->do_transfer(adapter, &transfer, &client->config);
+	spin_unlock_irqrestore(&adapter->lock, flags);
+
+	/* deassert the chip select at least for this long */
+	udelay(1 + ((1000000 * client->config.cs_delay) / client->config.sc_rate));
+
+	return rc;
+}
+EXPORT_SYMBOL(spi_write_mem);
+
+/**
+ * spi_write_single -
+ */
+int spi_write_single(struct spi_client *client, u8 fs, u16 value)
+{
+	return spi_write_mem(client, fs, (u8 *)&value, 1);
+}
+EXPORT_SYMBOL(spi_write_single);
+
+/*
+ * spi_writen -
+ */
+int spi_writen(struct spi_client *client, u4 value)
+{
+	return spi_write_mem(client, 4, (u8 *)&value, 1);
+}
+EXPORT_SYMBOL(spi_writen);
+
+/*
+ * spi_writeb -
+ */
+int spi_writeb(struct spi_client *client, u8 value)
+{
+	return spi_write_mem(client, 8, &value, 1);
+}
+EXPORT_SYMBOL(spi_writeb);
+
+/*
+ * spi_writew -
+ */
+int spi_writew(struct spi_client *client, u16 value)
+{
+	return spi_write_mem(client, 16, (u8 *)&value, 1);
+}
+EXPORT_SYMBOL(spi_writew);
+
+/*
+ * spi_read_mem -
+ */
+int spi_read_mem(struct spi_client *client, u8 fs, u8 *buffer, int len)
+{
+	struct spi_transfer transfer;
+	struct spi_adapter *adapter = client->adapter;
+	unsigned long flags;
+	int rc;
+
+	memset(&transfer, 0, sizeof (struct spi_transfer));
+
+	transfer.fs = fs;
+	transfer.mode = SPI_TRANSFER_MODE_READ_ONLY;
+	transfer.rbuf = buffer;
+	transfer.rlen = len;
+
+	spin_lock_irqsave(&adapter->lock, flags);
+	rc = adapter->do_transfer(adapter, &transfer, &client->config);
+	spin_unlock_irqrestore(&adapter->lock, flags);
+
+	/* deassert the chip select at least for this long */
+	udelay(1 + ((1000000 * client->config.cs_delay) / client->config.sc_rate));
+
+	return rc;
+}
+EXPORT_SYMBOL(spi_read_mem);
+
+/*
+ * spi_read_single -
+ */
+int spi_read_single(struct spi_client *client, u8 fs, u16 *value)
+{
+	return spi_read_mem(client, fs, (u8 *) value, 1);
+}
+EXPORT_SYMBOL(spi_read_single);
+
+/*
+ * spi_readn -
+ */
+int spi_readn(struct spi_client *client, u4 *value)
+{
+	return spi_read_mem(client, 4, (u8 *)value, 1);
+}
+EXPORT_SYMBOL(spi_readn);
+
+/*
+ * spi_readb -
+ */
+int spi_readb(struct spi_client *client, u8 *value)
+{
+	return spi_read_mem(client, 8, value, 1);
+}
+EXPORT_SYMBOL(spi_readb);
+
+/*
+ * spi_readw -
+ */
+int spi_readw(struct spi_client *client, u16 *value)
+{
+	return spi_read_mem(client, 16, (u8 *)value, 1);
+}
+EXPORT_SYMBOL(spi_readw);
+
+/**
+ * spi_read_mem -
+ *
+ *
+ */
+int spi_writeread_mem(struct spi_client *client, u8 fs, u8 *rbuffer, int rlen, u8 *wbuffer, int wlen)
+{
+	struct spi_transfer transfer;
+	struct spi_adapter *adapter = client->adapter;
+	unsigned long flags;
+	int rc;
+
+	memset(&transfer, 0, sizeof (struct spi_transfer));
+
+	transfer.fs = fs;
+	transfer.mode = SPI_TRANSFER_MODE_WRITE_READ;
+	transfer.rbuf = rbuffer;
+	transfer.rlen = rlen;
+	transfer.wbuf = wbuffer;
+	transfer.wlen = wlen;
+
+	spin_lock_irqsave(&adapter->lock, flags);
+	rc = adapter->do_transfer(adapter, &transfer, &client->config);
+	spin_unlock_irqrestore(&adapter->lock, flags);
+
+	/* deassert the chip select at least for this long */
+	udelay(1 + ((1000000 * client->config.cs_delay) / client->config.sc_rate));
+
+	return rc;
+}
+EXPORT_SYMBOL(spi_writeread_mem);
+
+/**
+ * spi_add_adapter -
+ *
+ *
+ */
+int spi_add_adapter(struct spi_adapter *adapter)
+{
+	struct spi_driver *driver;
+	struct list_head *item;
+
+	printk(KERN_INFO "SPI core: add adapter %s\n", adapter->name);
+
+	list_add(&adapter->list, &spi_adapters);
+	INIT_LIST_HEAD(&adapter->clients);
+
+	adapter->lock = SPIN_LOCK_UNLOCKED;
+
+	list_for_each(item, &spi_drivers) {
+		driver = list_entry(item, struct spi_driver, list);
+
+		/* We ignore the return code; if it fails, too bad */
+		driver->attach_adapter(adapter);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(spi_add_adapter);
+
+/**
+ * spi_del_adapter -
+ *
+ *
+ */
+int spi_del_adapter(struct spi_adapter *adapter)
+{
+	struct spi_client *client;
+	struct list_head *item, *_n;
+
+	printk(KERN_INFO "SPI core: del adapter %s\n", adapter->name);
+
+	list_for_each_safe(item, _n, &adapter->clients) {
+		client = list_entry(item, struct spi_client, list);
+
+		if (client->driver->detach_client(client))
+			goto out;
+	}
+
+	list_del(&adapter->list);
+
+out:
+	return 0;
+}
+EXPORT_SYMBOL(spi_del_adapter);
+
+/**
+ * spi_attach_client -
+ *
+ *
+ */
+int spi_attach_client(struct spi_client *client)
+{
+	struct spi_adapter *adapter = client->adapter;
+	struct spi_client_config *config = &client->config;
+	struct spi_adapter_caps *caps = &adapter->caps;
+
+	printk(KERN_INFO "SPI core: attach client to adapter %s\n", client->adapter->name);
+
+	if ((config->sc_rate >= caps->max_sc_rate) || (config->sc_rate < caps->min_sc_rate)) {
+		printk(KERN_INFO "SPI core: client serial clock rate %ld out of range [%ld, %ld]", config->sc_rate,
+		       caps->min_sc_rate, caps->max_sc_rate);
+
+		goto err;
+	}
+
+	if (config->cs_msk & ~caps->cs_msk) {
+		printk(KERN_INFO "SPI core: client cs mask %#x not supported %#x", config->cs_msk,
+		       caps->cs_msk);
+
+		goto err;
+	}
+
+	list_add(&client->list, &adapter->clients);
+
+	return 0;
+
+err:
+	return -1;
+}
+EXPORT_SYMBOL(spi_attach_client);
+
+/**
+ * spi_dettach_client -
+ *
+ *
+ */
+int spi_detach_client(struct spi_client *client)
+{
+	printk(KERN_INFO "SPI core: client detach from adapter %s\n", client->adapter->name);
+
+	list_del(&client->list);
+
+	return 0;
+}
+EXPORT_SYMBOL(spi_detach_client);
+
+/**
+ * spi_add_driver -
+ *
+ *
+ */
+int spi_add_driver(struct spi_driver *driver)
+{
+	struct spi_adapter *adapter;
+	struct list_head *item;
+
+	printk(KERN_INFO "SPI core: add driver %s\n", driver->name);
+
+	list_add(&driver->list, &spi_drivers);
+
+	list_for_each(item, &spi_adapters) {
+		adapter = list_entry(item, struct spi_adapter, list);
+		driver->attach_adapter(adapter);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(spi_add_driver);
+
+/**
+ * spi_del_driver -
+ *
+ *
+ */
+int spi_del_driver(struct spi_driver *driver)
+{
+	struct list_head *item1, *item2, *_n;
+	struct spi_adapter *adapter;
+	struct spi_client *client;
+
+	printk(KERN_INFO "SPI core: delete driver %s\n", driver->name);
+
+	list_for_each(item1, &spi_adapters) {
+		adapter = list_entry(item1, struct spi_adapter, list);
+
+		list_for_each_safe(item2, _n, &adapter->clients) {
+			client = list_entry(item2, struct spi_client, list);
+			if (client->driver != driver)
+				continue;
+
+			if (driver->detach_client(client))
+				goto err;
+		}
+	}
+	list_del(&driver->list);
+
+	return 0;
+
+err:
+	return -1;
+}
+EXPORT_SYMBOL(spi_del_driver);
+
+/* match always succeeds, as we want the probe() to tell if we really accept this match */
+static int spi2_device_match(struct device *dev, struct device_driver *drv)
+{
+	return 1;
+}
+
+struct bus_type spi2_bus_type = {
+	.name = "spi2",
+	.match = spi2_device_match,
+};
+
+/**
+ * spi_driver_init -
+ *
+ *
+ */
+static int __init spi_driver_init(void)
+{
+	printk(KERN_INFO "SPI core: loaded version 0.2\n");
+
+	return bus_register(&spi2_bus_type);
+}
+subsys_initcall(spi_driver_init);
+
+/**
+ * spi_driver_exit -
+ *
+ *
+ */
+static void __exit spi_driver_exit(void)
+{
+	bus_unregister(&spi2_bus_type);
+}
+module_exit(spi_driver_exit);
+
+
+
+
+MODULE_AUTHOR("Rui Sousa <rui.sousa@mindspeed.com>");
+MODULE_DESCRIPTION("SPI core");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/spi2/spi.h b/include/linux/spi2/spi.h
new file mode 100644
index 0000000..812ff2c
--- /dev/null
+++ b/include/linux/spi2/spi.h
@@ -0,0 +1,134 @@
+/*
+ *  linux/include/linux/spi.h
+ *
+ *  Copyright (C) Mindspeed Technologies
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef _SPI_H
+#define _SPI_H
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/device.h>
+
+#define SPI_TRANSFER_MODE_WRITE_ONLY	0x01
+#define SPI_TRANSFER_MODE_READ_ONLY	0x02
+#define SPI_TRANSFER_MODE_WRITE_READ	0x03
+
+typedef u8 u4;
+
+struct spi_transfer {
+	u8 *wbuf;
+	unsigned int wlen;
+
+	u8 *rbuf;
+	unsigned int rlen;
+
+	u8 mode;
+
+	u8 fs;				/* transfer frame size (in bits) */
+};
+
+struct spi_adapter_caps {
+	unsigned long min_sc_rate;	/* maximum supported serial clock rate (in MHz) */
+	unsigned long max_sc_rate;	/* minimum supported serial clock rate (in MHz) */
+
+	u8 max_fs;			/* maximum supported frame size (in bits) */
+	u8 min_fs;			/* minimum supported frame size (in bits) */
+
+	u16 cs_msk;			/* mask of supported chip selects */
+
+	u16 max_nframe;			/* maximum supported transfer frame number */
+	u16 min_nframe;			/* minimum supported transfer frame number */
+};
+
+struct spi_client_config {
+	u16 cs_msk;			/* chip select mask for this client */
+	u8 sc_polarity;			/* serial clock polarity */
+	u8 sc_phase;			/* serial clock phase */
+	unsigned long sc_rate;		/* serial clock rate (in MHz)*/
+	u8 cs_delay;			/* chip select deassert time (in serial clock cycles) */
+};
+
+/* A SPI bus adapter instance */
+struct spi_adapter {
+	char *name;
+
+	int (*do_transfer)(struct spi_adapter *adapter, struct spi_transfer *transfer, struct spi_client_config *config);
+
+	void *data;
+	struct device dev;
+	struct list_head list;
+	struct list_head clients;
+
+	struct spi_adapter_caps caps;
+
+	spinlock_t lock;
+};
+
+/* A SPI device instance */
+struct spi_client {
+	struct spi_client_config config;
+
+	struct spi_driver *driver;
+
+	struct spi_adapter *adapter;
+	struct device dev;
+	struct list_head list;
+};
+
+/* A SPI device driver */
+struct spi_driver {
+	char *name;
+
+	int (*attach_adapter)(struct spi_adapter *adapter);
+	int (*detach_client)(struct spi_client *client);
+#ifdef CONFIG_PM
+	int (*suspend)(struct spi_client *client, pm_message_t state);
+	int (*resume)(struct spi_client *client);
+#endif
+
+	struct device_driver driver;
+	struct list_head list;
+};
+
+static inline void *spi_get_clientdata(struct spi_client *dev)
+{
+	return dev_get_drvdata(&dev->dev);
+}
+
+static inline void spi_set_clientdata(struct spi_client *dev, void *data)
+{
+	dev_set_drvdata(&dev->dev, data);
+}
+
+int spi_add_adapter(struct spi_adapter *adapter);
+int spi_del_adapter(struct spi_adapter *adapter);
+
+int spi_add_driver(struct spi_driver *driver);
+int spi_del_driver(struct spi_driver *driver);
+
+int spi_attach_client(struct spi_client *client);
+int spi_detach_client(struct spi_client *client);
+
+int spi_write_mem(struct spi_client *client, u8 fs, u8 *buffer, int len);
+int spi_write_single(struct spi_client *client, u8 fs, u16 value);
+
+int spi_writen(struct spi_client *client, u4 value);
+int spi_writeb(struct spi_client *client, u8 value);
+int spi_writew(struct spi_client *client, u16 value);
+
+int spi_read_mem(struct spi_client *client, u8 fs, u8 *buffer, int len);
+int spi_read_single(struct spi_client *client, u8 fs, u16 *value);
+int spi_writeread_mem(struct spi_client *client, u8 fs, u8 *rbuffer, int rlen, u8 *wbuffer, int wlen);
+
+int spi_readn(struct spi_client *client, u4 *value);
+int spi_readb(struct spi_client *client, u8 *value);
+int spi_readw(struct spi_client *client, u16 *value);
+
+#endif /* _SPI_H */
-- 
1.5.4.3

