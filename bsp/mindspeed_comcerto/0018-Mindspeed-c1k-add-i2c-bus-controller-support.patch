From a87b5501b710571e89b3c034fbb6090304ca2074 Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Wed, 27 Oct 2010 09:31:01 +0800
Subject: [PATCH 18/26] Mindspeed-c1k: add i2c bus controller support

Add i2c bus controller support for mindspeed c1k board.
[Original code taken from sdk-comcerto-openwrt-6.0.tar.bz2]

Integrated-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 arch/arm/mach-comcerto/board-c1kmfcn_evm.c         |   25 +
 .../mach-comcerto/include/mach/comcerto-1000/i2c.h |   58 ++
 arch/arm/mach-comcerto/include/mach/i2c.h          |   35 +
 drivers/i2c/busses/Kconfig                         |   10 +
 drivers/i2c/busses/Makefile                        |    1 +
 drivers/i2c/busses/i2c-comcerto.c                  |  772 ++++++++++++++++++++
 6 files changed, 901 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-comcerto/include/mach/comcerto-1000/i2c.h
 create mode 100644 arch/arm/mach-comcerto/include/mach/i2c.h
 create mode 100644 drivers/i2c/busses/i2c-comcerto.c

diff --git a/arch/arm/mach-comcerto/board-c1kmfcn_evm.c b/arch/arm/mach-comcerto/board-c1kmfcn_evm.c
index 6f736cf..751fbfd 100644
--- a/arch/arm/mach-comcerto/board-c1kmfcn_evm.c
+++ b/arch/arm/mach-comcerto/board-c1kmfcn_evm.c
@@ -20,6 +20,7 @@
 #include <linux/sched.h>
 #include <linux/device.h>
 #include <linux/serial_8250.h>
+#include <linux/i2c.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/partitions.h>
 #include <asm/sizes.h>
@@ -369,6 +370,27 @@ static struct platform_device comcerto_fbpoolB_device = {
 	.resource = fbpoolB_resources,
 };
 
+#if defined(CONFIG_I2C_COMCERTO) || defined(CONFIG_I2C_COMCERTO_MODULE)
+static struct resource comcerto_i2c_resources[] = {
+	{
+		.start  = COMCERTO_APB_I2C_BASE,
+		.end    = COMCERTO_APB_I2C_BASE + SZ_4K - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	{
+		.start  = IRQ_I2C,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device comcerto_i2c = {
+	.name           = "comcerto_i2c",
+	.id             = -1,
+	.num_resources  = ARRAY_SIZE(comcerto_i2c_resources),
+	.resource       = comcerto_i2c_resources,
+};
+#endif
+
 static struct platform_device *comcerto_devices[] __initdata = {
 	&comcerto_uart,
 	&comcerto_nand,
@@ -378,6 +400,9 @@ static struct platform_device *comcerto_devices[] __initdata = {
 	&comcerto_eth0_device,
 	&comcerto_mdio1_device,
 	&comcerto_eth2_device,
+#if defined(CONFIG_I2C_COMCERTO) || defined(CONFIG_I2C_COMCERTO_MODULE)
+	&comcerto_i2c,
+#endif
 };
 
 /************************************************************************
diff --git a/arch/arm/mach-comcerto/include/mach/comcerto-1000/i2c.h b/arch/arm/mach-comcerto/include/mach/comcerto-1000/i2c.h
new file mode 100644
index 0000000..8155945
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/comcerto-1000/i2c.h
@@ -0,0 +1,58 @@
+/*
+ *  arch/arm/mach-comcerto/include/mach/comcerto1000/i2c.h
+ *
+ *  Copyright (C) 2008 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#ifndef __ASM_ARCH_COMCERTO1000_I2C_H
+#define __ASM_ARCH_COMCERTO1000_I2C_H
+
+#define COMCERTO_I2C_ADDR		(0x00*4)
+#define COMCERTO_I2C_DATA		(0x01*4)
+#define COMCERTO_I2C_CNTR		(0x02*4)
+#define COMCERTO_I2C_STAT		(0x03*4)
+#define COMCERTO_I2C_CCRFS		(0x03*4)
+#define COMCERTO_I2C_XADDR		(0x04*4)
+#define COMCERTO_I2C_CCRH		(0x05*4)
+#define COMCERTO_I2C_RESET		(0x07*4)
+
+/* CNTR - Control register bits */
+#define CNTR_IEN			(1<<7)
+#define CNTR_ENAB			(1<<6)
+#define CNTR_STA			(1<<5)
+#define CNTR_STP			(1<<4)
+#define CNTR_IFLG			(1<<3)
+#define CNTR_AAK			(1<<2)
+
+/* STAT - Status codes */
+#define STAT_BUS_ERROR			0x00
+#define STAT_START			0x08
+#define STAT_START_REPEATED		0x10
+#define STAT_ADDR_WR_ACK		0x18
+#define STAT_ADDR_WR_NACK		0x20
+#define STAT_DATA_WR_ACK		0x28
+#define STAT_DATA_WR_NACK		0x30
+#define STAT_ARBIT_LOST			0x38
+#define STAT_ADDR_RD_ACK		0x40
+#define STAT_ADDR_RD_NACK		0x48
+#define STAT_DATA_RD_ACK		0x50
+#define STAT_DATA_RD_NACK		0x58
+#define STAT_ARBIT_LOST_ADDR		0x68
+#define STAT_GENERAL_CALL		0x70
+#define STAT_NO_RELEVANT_INFO		0xF8
+
+#endif /* __ASM_ARCH_COMCERTO1000_I2C_H */
diff --git a/arch/arm/mach-comcerto/include/mach/i2c.h b/arch/arm/mach-comcerto/include/mach/i2c.h
new file mode 100644
index 0000000..466e8f6
--- /dev/null
+++ b/arch/arm/mach-comcerto/include/mach/i2c.h
@@ -0,0 +1,35 @@
+/*
+ *  arch/arm/mach-comcerto/include/mach/i2c.h
+ *
+ *  Copyright (C) 2008 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __ASM_ARCH_I2C_H
+#define __ASM_ARCH_I2C_H
+
+
+
+#if defined(CONFIG_ARCH_M821XX) || defined(CONFIG_ARCH_M822XX)
+	#include <mach/comcerto-100/i2c.h>
+#elif defined(CONFIG_ARCH_M83XXX)
+	#include <mach/comcerto-1000/i2c.h>
+#else
+	#error "Unsupported CPU"
+#endif
+
+#endif  /* __ASM_ARCH_I2C_H */
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index 9c6170c..05a0cd0 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -305,6 +305,16 @@ config I2C_AU1550
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-au1550.
 
+config I2C_COMCERTO
+        tristate "Comcerto I2C interface"
+        depends on ARCH_COMCERTO
+        help
+          If you say yes to this option, support will be included for the
+          Comcerto I2C interface.
+
+          This driver can also be built as a module.  If so, the module
+          will be called i2c-comcerto.
+
 config I2C_BLACKFIN_TWI
 	tristate "Blackfin TWI I2C support"
 	depends on BLACKFIN
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index 097236f..239eed4 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -30,6 +30,7 @@ obj-$(CONFIG_I2C_POWERMAC)	+= i2c-powermac.o
 # Embebbed system I2C/SMBus host controller drivers
 obj-$(CONFIG_I2C_AT91)		+= i2c-at91.o
 obj-$(CONFIG_I2C_AU1550)	+= i2c-au1550.o
+obj-$(CONFIG_I2C_COMCERTO)      += i2c-comcerto.o
 obj-$(CONFIG_I2C_BLACKFIN_TWI)	+= i2c-bfin-twi.o
 obj-$(CONFIG_I2C_CPM)		+= i2c-cpm.o
 obj-$(CONFIG_I2C_DAVINCI)	+= i2c-davinci.o
diff --git a/drivers/i2c/busses/i2c-comcerto.c b/drivers/i2c/busses/i2c-comcerto.c
new file mode 100644
index 0000000..c9ad08e
--- /dev/null
+++ b/drivers/i2c/busses/i2c-comcerto.c
@@ -0,0 +1,772 @@
+/*
+ *  drivers/i2c/busses/i2c-comcerto.c
+ *
+ *  Copyright (C) 2008 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <asm/io.h>
+#include <asm/sizes.h>
+#include <mach/i2c.h>
+#include <mach/irqs.h>
+
+
+MODULE_AUTHOR("Mindspeed Technologies, Inc.");
+MODULE_DESCRIPTION("Comcerto I2C bus driver");
+MODULE_LICENSE("GPL");
+
+
+#define SPEED_HIGH_KHZ		3400
+#define SPEED_FULL_KHZ		400
+#define SPEED_NORMAL_KHZ	100
+
+static int force_poll;
+module_param(force_poll, bool, S_IRUGO);
+MODULE_PARM_DESC(force_poll, "Force polling mode: 0=interrupt mode, \
+				polling mode otherwise");
+
+static int speed;
+module_param(speed, int, S_IRUGO);
+MODULE_PARM_DESC(speed, "I2C speed: 0=standard, 1=fast, 2=high speed");
+
+
+struct comcerto_i2c {
+	struct i2c_adapter	*adapter;
+	struct device		*dev;
+	unsigned long		membase;
+	struct resource		*io;
+	int			irq;
+	u32			speed_khz;
+
+	wait_queue_head_t	wait;
+	struct i2c_msg		*msg;
+	int			msg_state;
+
+	/* < 0: error, == 0: success, > 0: message in progress */
+	int			msg_status;
+
+	int			msg_len;
+	int			msg_retries;
+};
+
+
+#define REG_ADDR(i2c, offset)		((i2c)->membase + (offset))
+#define RD_REG(i2c, offset)		__raw_readb(REG_ADDR(i2c, offset))
+#define WR_REG(i2c, offset, byte)	__raw_writeb(byte,\
+							REG_ADDR(i2c, offset))
+#define RD_DATA(i2c)			RD_REG(i2c, COMCERTO_I2C_DATA)
+#define WR_DATA(i2c, byte)		WR_REG(i2c, COMCERTO_I2C_DATA, byte)
+#define RD_CNTR(i2c)			RD_REG(i2c, COMCERTO_I2C_CNTR)
+#define WR_CNTR(i2c, byte)		WR_REG(i2c, COMCERTO_I2C_CNTR, byte)
+#define RD_STAT(i2c)			RD_REG(i2c, COMCERTO_I2C_STAT)
+#define WR_CCRFS(i2c, byte)		WR_REG(i2c, COMCERTO_I2C_CCRFS, byte)
+#define WR_CCRH(i2c, byte)		WR_REG(i2c, COMCERTO_I2C_CCRH, byte)
+#define WR_RESET(i2c, byte)		WR_REG(i2c, COMCERTO_I2C_RESET, byte)
+
+
+enum {
+	TR_IDLE = 0,
+	TR_START_ACK,
+	TR_ADDR_ACK,
+	TR_DATA_ACK,
+	RX_DATA_NACK,
+};
+
+
+static u8 comcerto_i2c_calculate_dividers(struct comcerto_i2c *i2c)
+{
+	int m, n, hz, speed_hz;
+	int saved_n, saved_m, saved_hz;
+	u8 dividers;
+
+	speed_hz = i2c->speed_khz*1000;
+	saved_hz = saved_n = saved_m = 0;
+
+	for (m = 0; m < 16; m++) {
+		for (n = 0; n < 8; n++) {
+			hz = (COMCERTO_DEFAULTAHBCLK * 1000 * 1000) /
+						((1 << n) * (m + 1) * 10);
+			if (!saved_hz || abs(speed_hz - hz) <
+						abs(speed_hz - saved_hz)) {
+				saved_n = n;
+				saved_m = m;
+				saved_hz = hz;
+			}
+		}
+	}
+
+	dividers = (saved_m << 3) | saved_n;
+
+	dev_dbg(i2c->dev, "%s: speed=%dkHz, M=%d, N=%d, dividers=0x%02x\n",
+		__func__, saved_hz/1000, saved_m, saved_n, dividers);
+
+	return dividers;
+}
+
+/*
+ * Returns the timeout (in jiffies) for the given message.
+ */
+static int comcerto_i2c_calculate_timeout(struct comcerto_i2c *i2c,
+						struct i2c_msg *msg)
+{
+	int timeout;
+
+	/* if no timeout was specified, calculate it */
+	if (i2c->adapter->timeout <= 0) {
+		if (i2c->irq >= 0) {
+			/* for the interrupt mode calculate timeout
+						for 'full' message */
+			/* convert approx. to bits */
+			timeout = ((int)msg->len) * 10;
+
+			/* convert to bits per ms (note of kHz scale) */
+			timeout /= i2c->speed_khz;
+
+			/* add 50% */
+			timeout += timeout >> 1;
+
+			/* convert to jiffies */
+			timeout = timeout * HZ / 1000;
+
+			/* at least 200ms */
+			if (timeout < HZ / 5)
+				timeout = HZ / 5;
+		} else
+			timeout = HZ;	/* 1 second for the polling mode */
+	} else
+		timeout = i2c->adapter->timeout;
+
+	return timeout;
+}
+
+/*
+ * Initialize I2C core. Zero CNTR and DATA, try RESET. Short
+ * busy wait and check core status. After that set dividers for
+ * choosen speed.
+ */
+static void comcerto_i2c_reset(struct comcerto_i2c *i2c)
+{
+	u8 status, dividers;
+
+	dev_dbg(i2c->dev, "%s\n", __func__);
+
+	WR_CNTR(i2c, 0);
+	WR_DATA(i2c, 0);
+	WR_RESET(i2c, 1);
+
+	udelay(10);
+
+	status = RD_STAT(i2c);
+	if (status != STAT_NO_RELEVANT_INFO)
+		dev_warn(i2c->dev, "%s:unexpected status after reset: 0x%02x\n",
+					__func__, status);
+
+	/* dividers should be placed in CCRH for high-sped mode and in CCRFS
+			for standard/full modes */
+	dividers = comcerto_i2c_calculate_dividers(i2c);
+	if (i2c->speed_khz == SPEED_HIGH_KHZ)
+		WR_CCRH(i2c, dividers);
+	else
+		WR_CCRFS(i2c, dividers);
+}
+
+static inline void comcerto_i2c_message_complete(struct comcerto_i2c *i2c,
+							int status)
+{
+	i2c->msg_status = status;
+	WR_CNTR(i2c, CNTR_STP);
+}
+
+static inline int comcerto_i2c_message_in_progress(struct comcerto_i2c *i2c)
+{
+	return i2c->msg_status > 0;
+}
+
+/*
+ * Wait event. This function sleeps in polling mode, in interrupt
+ * mode it enables IRQ from I2C core and exits immediately.
+ */
+static int comcerto_i2c_wait(struct comcerto_i2c *i2c, u8 cntr)
+{
+	cntr &= ~(CNTR_IFLG | CNTR_IEN);	/* clear both IFLG and IEN */
+
+	if (i2c->irq < 0) {
+		ulong jiffies_mark = jiffies +
+				comcerto_i2c_calculate_timeout(i2c, i2c->msg);
+
+		WR_CNTR(i2c, cntr);
+		while ((RD_CNTR(i2c) & CNTR_IFLG) == 0) {
+			if (need_resched())
+				schedule();
+
+			if (time_after(jiffies, jiffies_mark)) {
+				dev_dbg(i2c->dev,
+				"%s: polling transfer timeout\n", __func__);
+				comcerto_i2c_message_complete(i2c, -ETIME);
+				comcerto_i2c_reset(i2c);
+				return -EIO;
+			}
+		}
+	} else {
+		/* enable interrupt */
+		WR_CNTR(i2c, cntr | CNTR_IEN);
+	}
+
+	return 0;
+}
+
+static void comcerto_i2c_state_idle(struct comcerto_i2c *i2c, u8 *cntr)
+{
+	if (unlikely(i2c->msg->flags & I2C_M_NOSTART)) {
+		i2c->msg_state = TR_ADDR_ACK;
+	} else {
+		/* SPT|STA to auto recover from bus error state transparently
+				at the start of the transfer */
+		*cntr = CNTR_STP | CNTR_STA;
+
+		i2c->msg_state = TR_START_ACK;
+	}
+}
+
+static void comcerto_i2c_state_start_ack(struct comcerto_i2c *i2c, u8 *cntr)
+{
+	u8 status, addr;
+
+	/* zero IFLG, IEN (for the interrupt mode it will be
+			enabled in wait function) */
+	*cntr = 0;
+
+	status = RD_STAT(i2c);
+
+	if (status == STAT_START || status == STAT_START_REPEATED) {
+		i2c->msg_state = TR_ADDR_ACK;
+
+		addr = i2c->msg->addr << 1;
+		if (i2c->msg->flags & I2C_M_RD)
+			addr |= 1;
+		if (i2c->msg->flags & I2C_M_REV_DIR_ADDR)
+			addr ^= 1;	/* invert RW bit if it's requested */
+
+		WR_DATA(i2c, addr);	/* write address and read/write bit */
+	} else {
+		dev_dbg(i2c->dev, "%s: unexpected state (%#x) on start phase, \
+			%s\n",
+			__func__, status,
+			i2c->msg_retries > 1 ? "retrying" : "aborting");
+
+		if (--i2c->msg_retries < 0)
+			comcerto_i2c_message_complete(i2c, -1);
+		else
+			comcerto_i2c_state_idle(i2c, cntr);
+	}
+}
+
+static void comcerto_i2c_rx(struct comcerto_i2c *i2c)
+{
+	u8 status, cntr = 0;
+
+restart:
+	switch (i2c->msg_state) {
+	case TR_IDLE:
+		comcerto_i2c_state_idle(i2c, &cntr);
+		if (unlikely(i2c->msg->flags & I2C_M_NOSTART))
+			/* needed to avoid event loss in interrupt mode */
+			goto restart;
+		break;
+
+	case TR_START_ACK:
+		comcerto_i2c_state_start_ack(i2c, &cntr);
+		break;
+
+	case TR_ADDR_ACK:
+		if (unlikely(i2c->msg->flags & I2C_M_NOSTART)) {
+			/* we can enter this state if skip start/addr flag
+						is set, so fake good ack */
+			status = STAT_ADDR_RD_ACK;
+		} else {
+			status = RD_STAT(i2c);
+			/* check whether we should ignore NACK */
+			if (status == STAT_DATA_RD_NACK &&
+					(i2c->msg->flags & I2C_M_IGNORE_NAK))
+				status = STAT_DATA_RD_ACK;
+		}
+
+		if (likely(status == STAT_ADDR_RD_ACK)) {
+			/* start reception phase - wait until data is ready
+			 * and loop in RX_DATA_ACK state until we read all the
+			 * data, sending ACK after each byte (but the last)
+			 */
+			i2c->msg_len = 0;
+			if (i2c->msg->len > 1) {
+				i2c->msg_state = TR_DATA_ACK;
+				cntr = CNTR_AAK;
+			} else if (i2c->msg->len == 1)
+				i2c->msg_state = RX_DATA_NACK;
+			else
+				/* nothing to receive, send STOP and
+						signal success */
+				comcerto_i2c_message_complete(i2c, 0);
+		} else {
+			dev_dbg(i2c->dev,
+				"%s: unexpected state (%#x) on address phase, \
+				%s\n",
+				__func__, status,
+				i2c->msg_retries > 1 ? "retrying" : "aborting");
+
+			if (--i2c->msg_retries < 0)
+				comcerto_i2c_message_complete(i2c, -1);
+			else
+				comcerto_i2c_state_idle(i2c, &cntr);
+		}
+		break;
+
+	case TR_DATA_ACK:
+		status = RD_STAT(i2c);
+
+		if (likely(status == STAT_DATA_RD_ACK)) {
+			i2c->msg->buf[i2c->msg_len++] = RD_DATA(i2c);
+
+			if (likely(i2c->msg->len - i2c->msg_len > 1))
+				cntr = CNTR_AAK;
+			else
+				i2c->msg_state = RX_DATA_NACK;
+		} else {
+			dev_dbg(i2c->dev, "%s: unexpected state (%#x) on read \
+						phase\n", __func__, status);
+			comcerto_i2c_message_complete(i2c, -1);
+		}
+		break;
+
+	case RX_DATA_NACK:
+		status = RD_STAT(i2c);
+		if (likely(status == STAT_DATA_RD_NACK)) {
+			i2c->msg->buf[i2c->msg_len++] = RD_DATA(i2c);
+			comcerto_i2c_message_complete(i2c, 0);
+		} else {
+			dev_dbg(i2c->dev, "%s: unexpected state (%#x) \
+				on finishing read phase\n", __func__, status);
+			comcerto_i2c_message_complete(i2c, -1);
+		}
+	}
+
+	/* no wait if we completed message */
+	if (comcerto_i2c_message_in_progress(i2c))
+		comcerto_i2c_wait(i2c, cntr);
+}
+
+static void comcerto_i2c_tx(struct comcerto_i2c *i2c)
+{
+	u8 status, cntr = 0;
+
+restart:
+	switch (i2c->msg_state) {
+	case TR_IDLE:
+		comcerto_i2c_state_idle(i2c, &cntr);
+		if (unlikely(i2c->msg->flags & I2C_M_NOSTART))
+			/* needed to avoid event loss in interrupt mode */
+			goto restart;
+		break;
+
+	case TR_START_ACK:
+		comcerto_i2c_state_start_ack(i2c, &cntr);
+		break;
+
+	case TR_ADDR_ACK:
+		if (unlikely(i2c->msg->flags & I2C_M_NOSTART)) {
+			/* we can enter this state if skip start/addr flag is
+						set, so fake good ack */
+			status = STAT_ADDR_WR_ACK;
+		} else {
+			status = RD_STAT(i2c);
+			if (status == STAT_DATA_WR_NACK &&
+					(i2c->msg->flags & I2C_M_IGNORE_NAK))
+				status = STAT_DATA_WR_ACK;
+		}
+
+		if (likely(status == STAT_ADDR_WR_ACK)) {
+			/* start reception phase - wait until data is ready and
+			 * loop in TX_DATA_ACK state until we read all the data
+			 * , sending ACK after each byte (but the last)
+			 */
+			i2c->msg_state = TR_DATA_ACK;
+			i2c->msg_len = 0;
+			if (likely(i2c->msg->len != 0)) {
+				WR_DATA(i2c, i2c->msg->buf[i2c->msg_len++]);
+			} else
+				/* nothing to transmit, send STOP and
+							signal success */
+				comcerto_i2c_message_complete(i2c, 0);
+		} else {
+			dev_dbg(i2c->dev, "%s: unexpected state (%#x) \
+				on address phase, %s\n",
+				__func__, status,
+				i2c->msg_retries > 1 ? "retrying" : "aborting");
+
+			if (--i2c->msg_retries < 0)
+				comcerto_i2c_message_complete(i2c, -1);
+			else
+				comcerto_i2c_state_idle(i2c, &cntr);
+		}
+		break;
+
+	case TR_DATA_ACK:
+		status = RD_STAT(i2c);
+		if (status == STAT_DATA_WR_NACK &&
+					(i2c->msg->flags & I2C_M_IGNORE_NAK))
+			status = STAT_DATA_WR_ACK;
+
+		if (likely(status == STAT_DATA_WR_ACK)) {
+			if (i2c->msg->len > i2c->msg_len)
+				WR_DATA(i2c, i2c->msg->buf[i2c->msg_len++]);
+			else
+				comcerto_i2c_message_complete(i2c, 0);
+		} else {
+			dev_dbg(i2c->dev, "%s: unexpected state (%#x) on read \
+					data phase\n", __func__, status);
+			comcerto_i2c_message_complete(i2c, -1);
+		}
+		break;
+	}
+
+	if (comcerto_i2c_message_in_progress(i2c))
+		comcerto_i2c_wait(i2c, cntr);
+}
+
+static irqreturn_t comcerto_i2c_interrupt(int irq, void *dev_id)
+{
+	struct comcerto_i2c *i2c = dev_id;
+
+	if (!(RD_CNTR(i2c) & CNTR_IFLG))
+		return IRQ_NONE;
+
+	/* IRQ enable/disable logic is hidden in state handlers, all we need is
+	 * to wake process when message completed.
+	 */
+	if (i2c->msg->flags & I2C_M_RD)
+		comcerto_i2c_rx(i2c);
+	else
+		comcerto_i2c_tx(i2c);
+
+	if (!comcerto_i2c_message_in_progress(i2c)) {
+		/* disable interrupt unconditionally */
+		WR_CNTR(i2c, RD_CNTR(i2c) & ~CNTR_IEN);
+		wake_up(&i2c->wait);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void comcerto_i2c_message_process(struct comcerto_i2c *i2c,
+						struct i2c_msg *msg)
+{
+	i2c->msg = msg;
+	i2c->msg_state = TR_IDLE;
+	i2c->msg_status = 1;
+	i2c->msg_retries = i2c->adapter->retries;
+
+polling_mode:
+	if (msg->flags & I2C_M_RD)
+		comcerto_i2c_rx(i2c);
+	else
+		comcerto_i2c_tx(i2c);
+
+	if (i2c->irq < 0) {
+		/*if (i2c->msg != NULL)*/
+			goto polling_mode;
+	} else {
+		int timeout, res;
+		ulong flags;
+
+		timeout = comcerto_i2c_calculate_timeout(i2c, msg);
+
+		res = wait_event_timeout(i2c->wait,
+					i2c->msg_status <= 0, timeout);
+
+		local_irq_save(flags);
+
+		/* check if we timed out and set respective error codes */
+		if (res == 0) {
+			if (comcerto_i2c_message_in_progress(i2c)) {
+				dev_dbg(i2c->dev, "%s: interrupt \
+						transfer timeout\n", __func__);
+				comcerto_i2c_message_complete(i2c, -ETIME);
+				comcerto_i2c_reset(i2c);
+			}
+		}
+
+		local_irq_restore(flags);
+	}
+}
+
+/*
+ * Generic master transfer entrypoint.
+ * Returns the number of processed messages or error value
+ */
+static int comcerto_i2c_master_xfer(struct i2c_adapter *adapter,
+					struct i2c_msg msgs[], int num)
+{
+	struct comcerto_i2c *i2c = i2c_get_adapdata(adapter);
+	int i;
+
+	dev_dbg(i2c->dev, "%s: %d messages to process\n", __func__, num);
+
+	for (i = 0; i < num; i++) {
+		dev_dbg(i2c->dev,
+			"%s: message #%d: addr=%#x, flags=%#x, len=%u\n",
+			__func__, i, msgs[i].addr, msgs[i].flags, msgs[i].len);
+
+		comcerto_i2c_message_process(i2c, &msgs[i]);
+
+		if (i2c->msg_status < 0) {
+			dev_dbg(i2c->dev, "%s: transfer failed on message #%d \
+				(addr=%#x, flags=%#x, len=%u)\n",
+				__func__, i,
+				msgs[i].addr, msgs[i].flags, msgs[i].len);
+			break;
+		}
+	}
+
+	if (i2c->msg_status == -1)
+		i2c->msg_status = -EIO;
+
+	if (i2c->msg_status == 0)
+		i2c->msg_status = num;
+
+	return i2c->msg_status;
+}
+
+static u32 comcerto_i2c_functionality(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+static struct i2c_algorithm comcerto_i2c_algo = {
+	.master_xfer	= comcerto_i2c_master_xfer,
+	.functionality	= comcerto_i2c_functionality,
+};
+
+static struct i2c_adapter comcerto_i2c_adapter = {
+	.owner		= THIS_MODULE,
+	.algo		=  &comcerto_i2c_algo,
+
+	/* <= zero means that we calculate timeout in run-time,
+				can be changed with ioctl call */
+	.timeout	= 0,
+
+	/* no retries by default - let the user decide what's the best,
+				can be changed with ioctl call */
+	.retries	= 0,
+
+	.class          = I2C_CLASS_SPD,
+};
+
+static int comcerto_i2c_probe(struct platform_device *pdev)
+{
+	struct comcerto_i2c *i2c;
+	struct resource *irq;
+	int res = -1;
+
+	dev_dbg(&pdev->dev, "%s\n", __func__);
+
+	i2c = kzalloc(sizeof(*i2c), GFP_KERNEL);
+	if (i2c == NULL) {
+		dev_err(&pdev->dev, "%s: failed allocate memory\n", __func__);
+		res = -ENOMEM;
+		goto err0;
+	}
+
+	i2c->adapter = &comcerto_i2c_adapter;
+	i2c->adapter->dev.parent = &pdev->dev;
+	i2c->dev = &pdev->dev;
+
+	init_waitqueue_head(&i2c->wait);
+
+	platform_set_drvdata(pdev, i2c);
+	i2c_set_adapdata(&comcerto_i2c_adapter, i2c);
+
+	i2c->io = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (i2c->io == NULL) {
+		dev_err(&pdev->dev, "%s: no IO region specified\n", __func__);
+		res = -ENOENT;
+		goto err1;
+	}
+
+	if (!request_mem_region(i2c->io->start,
+				i2c->io->end - i2c->io->start + 1, "I2C")) {
+		dev_err(i2c->dev, "%s: failed to request memory region\n",
+					__func__);
+		goto err1;
+	}
+
+	/* io-remaped in arch/arm/mach-comcerto/comcerto-xxx.c */
+	i2c->membase = APB_VADDR(i2c->io->start);
+
+	irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (irq == NULL && !force_poll) {
+		dev_warn(i2c->dev, "%s: no IRQ specified in resources, \
+					polling mode forced\n", __func__);
+		force_poll = 1;
+		i2c->irq = -1;
+	}
+
+	if (speed == 0)
+		i2c->speed_khz = SPEED_NORMAL_KHZ;
+	else if (speed == 1)
+		i2c->speed_khz = SPEED_FULL_KHZ;
+	else if (speed == 2)
+		i2c->speed_khz = SPEED_HIGH_KHZ;
+	else {
+		dev_err(i2c->dev, "%s: invalid 'speed' module option provided \
+			(%d, must be 0,1,2 for normal/full/high modes)\n",
+			__func__, speed);
+		goto err2;
+	}
+
+	comcerto_i2c_reset(i2c);
+
+	if (!force_poll) {
+		i2c->irq = irq->start;
+
+		res = request_irq(i2c->irq, comcerto_i2c_interrupt,
+					IRQF_SHARED, "I2C", i2c);
+		if (res < 0) {
+			dev_warn(i2c->dev, "%s: failed to request IRQ%d, \
+				polling mode forced\n", __func__, i2c->irq);
+			force_poll = 1;
+			i2c->irq = -1;
+		}
+	} else
+		i2c->irq = -1;
+
+	if (i2c_add_adapter(&comcerto_i2c_adapter) != 0) {
+		dev_err(i2c->dev, "%s: failed to add I2C adapter\n", __func__);
+		goto err3;
+	}
+
+	dev_dbg(&pdev->dev, "%s: I2C adapter registered\n", __func__);
+
+	return 0;
+
+err3:
+	if (i2c->irq >= 0)
+		free_irq(i2c->irq, i2c);
+
+err2:
+	release_mem_region(i2c->io->start, i2c->io->end - i2c->io->end + 1);
+
+err1:
+	kfree(i2c);
+
+err0:
+	return res;
+}
+
+static int comcerto_i2c_remove(struct platform_device *pdev)
+{
+	struct comcerto_i2c *i2c = platform_get_drvdata(pdev);
+
+	dev_dbg(i2c->dev, "%s\n", __func__);
+
+	platform_set_drvdata(pdev, NULL);
+
+	i2c_del_adapter(i2c->adapter);
+
+	if (i2c->irq >= 0)
+		free_irq(i2c->irq, i2c);
+
+	release_mem_region(i2c->io->start, i2c->io->end - i2c->io->start + 1);
+
+	kfree(i2c);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int comcerto_i2c_suspend(struct platform_device *pdev,
+					pm_message_t state)
+{
+	struct list_head *item, *_n;
+	struct i2c_client *client;
+	struct comcerto_i2c *i2c = dev_get_drvdata(&pdev->dev);
+
+	state.event = PM_EVENT_SUSPEND;
+	/* No need to suspend client drivers here. Because clients are
+	 * children, client drivers get suspended before adapter driver
+
+	list_for_each_safe(item, _n, &i2c->adapter->clients) {
+		client = list_entry(item, struct i2c_client, list);
+		client->driver->suspend(client,state);
+	}
+	*/
+	pwr_mgmt_clk_down(COMPONENT_I2C);
+
+	return 0;
+}
+
+static int comcerto_i2c_resume(struct platform_device *pdev)
+{
+	struct list_head *item, *_n;
+	struct i2c_client *client;
+	struct comcerto_i2c *i2c = dev_get_drvdata(&pdev->dev);
+
+	pwr_mgmt_clk_restore(COMPONENT_I2C);
+	/* No need to resume client drivers here. Because clients are
+	 * children, client drivers get resumed after adapter driver
+
+	list_for_each_safe(item, _n, &i2c->adapter->clients) {
+		client = list_entry(item, struct i2c_client, list);
+		client->driver->resume(client);
+	}
+	*/
+
+	return 0;
+}
+#endif
+
+static struct platform_driver comcerto_i2c_driver = {
+	.driver = {
+		.name	= "comcerto_i2c",
+		.owner	= THIS_MODULE,
+	},
+	.probe	= comcerto_i2c_probe,
+	.remove	= comcerto_i2c_remove,
+#ifdef CONFIG_PM
+	.suspend = comcerto_i2c_suspend,
+	.resume = comcerto_i2c_resume,
+#endif
+};
+
+static int __init comcerto_i2c_init(void)
+{
+	printk(KERN_DEBUG "%s: module loaded\n", __func__);
+
+	return platform_driver_register(&comcerto_i2c_driver);
+}
+
+static void __exit comcerto_i2c_exit(void)
+{
+	printk(KERN_DEBUG "%s: module unloaded\n", __func__);
+
+	platform_driver_unregister(&comcerto_i2c_driver);
+}
+
+module_init(comcerto_i2c_init);
+module_exit(comcerto_i2c_exit);
-- 
1.5.4.3

