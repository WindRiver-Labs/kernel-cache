From 94b3def219c85656a6e5b5b469f465916a70e941 Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Fri, 22 Oct 2010 11:22:41 +0800
Subject: [PATCH 16/26] Comcerto: M83xxx: nand driver

Original codes came from Mindspeed's vendor drop sdk-comcerto-openwrt-6.0.
Little modification to apply to wrlinux-4.0.

Add Comcerto nand driver

Signed-off-by: Stanley.Miao <stanley.miao@windriver.com>
---
 drivers/mtd/nand/Kconfig         |    4 +
 drivers/mtd/nand/Makefile        |    1 +
 drivers/mtd/nand/comcerto-nand.c |  232 ++++++++++++++++++++++++++++++++++++++
 3 files changed, 237 insertions(+), 0 deletions(-)
 create mode 100644 drivers/mtd/nand/comcerto-nand.c

diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index 42e5ea4..88fa31c 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -104,6 +104,10 @@ config MTD_NAND_TS7250
 config MTD_NAND_IDS
 	tristate
 
+config MTD_NAND_COMCERTO
+	tristate "SmartMedia Card on Comcerto boards"
+	depends on MTD_NAND && ARCH_COMCERTO
+
 config MTD_NAND_AU1550
 	tristate "Au1550/1200 NAND support"
 	depends on SOC_AU1200 || SOC_AU1550
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 1407bd1..31c8c33 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -42,5 +42,6 @@ obj-$(CONFIG_MTD_NAND_TXX9NDFMC)	+= txx9ndfmc.o
 obj-$(CONFIG_MTD_NAND_W90P910)		+= w90p910_nand.o
 obj-$(CONFIG_MTD_NAND_NOMADIK)		+= nomadik_nand.o
 obj-$(CONFIG_MTD_NAND_BCM_UMI)		+= bcm_umi_nand.o nand_bcm_umi.o
+obj-$(CONFIG_MTD_NAND_COMCERTO)		+= comcerto-nand.o
 
 nand-objs := nand_base.o nand_bbt.o
diff --git a/drivers/mtd/nand/comcerto-nand.c b/drivers/mtd/nand/comcerto-nand.c
new file mode 100644
index 0000000..ec5966b
--- /dev/null
+++ b/drivers/mtd/nand/comcerto-nand.c
@@ -0,0 +1,232 @@
+/*
+ *  linux/drivers/mtd/nand/comcerto-nand.c
+ *
+ *  Copyright (C) Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ *  Overview:
+ *   This is a device driver for the NAND flash device found on the
+ *   Comcerto board which utilizes the Toshiba TC58V64AFT part. This is
+ *   a 128Mibit (8MiB x 8 bits) NAND flash device.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <mach/nand.h>
+#include <mach/gpio.h>
+
+/*
+ * MTD structure for Comcerto board
+ */
+struct comcerto_nand_info {
+	struct mtd_info		mtd;
+	struct nand_chip	chip;
+	bool			partitioned;
+};
+
+/*********************************************************************
+ * NAND Hardware functions
+ *
+ *********************************************************************/
+
+/*
+ *	hardware specific access to control-lines
+*/
+void comcerto_nand_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl)
+{
+	struct nand_chip *chip = mtd->priv;
+
+	if (ctrl & NAND_CTRL_CHANGE) {
+		if (ctrl & NAND_NCE)
+			comcerto_gpio_set_0(COMCERTO_NAND_CE);
+		else
+			comcerto_gpio_set_1(COMCERTO_NAND_CE);
+
+		if (ctrl & NAND_CLE)
+			comcerto_gpio_set_1(COMCERTO_NAND_CLE);
+		else
+			comcerto_gpio_set_0(COMCERTO_NAND_CLE);
+
+		if (ctrl & NAND_ALE)
+			comcerto_gpio_set_1(COMCERTO_NAND_ALE);
+		else
+			comcerto_gpio_set_0(COMCERTO_NAND_ALE);
+	}
+
+	if (cmd != NAND_CMD_NONE)
+		writeb(cmd, chip->IO_ADDR_W);
+	mdelay(1);
+}
+
+int comcerto_nand_ready(struct mtd_info *mtd)
+{
+	return comcerto_gpio_read(COMCERTO_NAND_BR) ? 1 : 0;
+}
+
+/*********************************************************************
+ * NAND Probe
+ *
+ *********************************************************************/
+static int comcerto_nand_probe(struct platform_device *pdev)
+{
+	struct comcerto_nand_pdata *pdata = pdev->dev.platform_data;
+	struct comcerto_nand_info *info;
+	int err = 0;
+
+	if (!pdata)
+		return -ENODEV;
+
+	/* Allocate memory for info structure */
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	if (!info) {
+		printk(KERN_ERR
+		       "comcerto nand: unable to allocate info structure\n");
+		err = -ENOMEM;
+		goto out;
+	}
+	platform_set_drvdata(pdev, info);
+
+	info->mtd.priv          = &info->chip;
+	info->mtd.name          = dev_name(&pdev->dev);
+	info->mtd.owner         = THIS_MODULE;
+	info->mtd.dev.parent    = &pdev->dev;
+
+	/*Map physical address of nand into virtual space */
+	info->chip.IO_ADDR_R =
+	    ioremap_nocache(pdev->resource->start,
+			    pdev->resource->end - pdev->resource->start + 1);
+	if (info->chip.IO_ADDR_R == NULL) {
+		printk(KERN_ERR "comcerto nand: cannot map nand memory\n");
+		err = -EIO;
+		goto out_info;
+	}
+	/* This is the same address to read and write */
+	info->chip.IO_ADDR_W = info->chip.IO_ADDR_R;
+
+	/* Set address of hardware control function */
+	info->chip.cmd_ctrl = comcerto_nand_hwcontrol;
+	info->chip.dev_ready = comcerto_nand_ready;
+
+	/* 20 us command delay time */
+	info->chip.chip_delay = 20;
+	info->chip.ecc.mode = NAND_ECC_SOFT;
+
+	info->chip.options = pdata->options;
+
+	/* Scan to find existence of the device */
+	if (nand_scan(&info->mtd, 1)) {
+		err = -ENXIO;
+		goto out_ior;
+	}
+
+	/* Register the partitions */
+	if (mtd_has_partitions()) {
+		struct mtd_partition    *mtd_parts = NULL;
+		int                     mtd_parts_nb = 0;
+
+		if (mtd_has_cmdlinepart()) {
+			static const char *probes[] __initconst = {"cmdlinepart", NULL};
+
+			mtd_parts_nb = parse_mtd_partitions(&info->mtd, probes,
+					&mtd_parts, 0);
+		}
+
+		if (mtd_parts_nb <= 0) {
+			mtd_parts = pdata->parts;
+			mtd_parts_nb = pdata->nr_parts;
+		}
+
+		/* Register any partitions */
+		if (mtd_parts_nb > 0) {
+			err = add_mtd_partitions(&info->mtd,
+					mtd_parts, mtd_parts_nb);
+			if (err == 0)
+				info->partitioned = true;
+		}
+	} else if (pdata->nr_parts) {
+		dev_warn(&pdev->dev, "ignoring %d default partitions on %s\n",
+				pdata->nr_parts, info->mtd.name);
+	}
+
+	if (!info->partitioned)
+		add_mtd_device(&info->mtd);
+
+	err = 0;
+
+	/* Link the info stucture with platform_device */
+	platform_set_drvdata(pdev, info);
+
+	goto out;
+
+out_ior:
+	iounmap(info->chip.IO_ADDR_R);
+out_info:
+	kfree(info);
+out:
+	return err;
+}
+
+/*********************************************************************
+ * NAND Remove
+ *
+ *********************************************************************/
+static int comcerto_nand_remove(struct platform_device *pdev)
+{
+	struct comcerto_nand_info *info =
+	    (struct comcerto_nand_info *)platform_get_drvdata(pdev);
+
+	platform_set_drvdata(pdev, NULL);
+
+	/* Unregister the device */
+	if (mtd_has_partitions() && info->partitioned)
+		del_mtd_partitions(&info->mtd);
+	else
+		del_mtd_device(&info->mtd);
+
+	/*Deregister virtual address */
+	iounmap(info->chip.IO_ADDR_R);
+
+	kfree(info);
+
+	return 0;
+}
+
+/*********************************************************************
+ * Driver Registration
+ *
+ *********************************************************************/
+
+static struct platform_driver comcerto_nand_driver = {
+	.probe = comcerto_nand_probe,
+	.remove = __devexit_p(comcerto_nand_remove),
+	.driver = {
+		   .name = "comcertonand",
+		   },
+};
+
+int __init comcerto_nand_init(void)
+{
+	return platform_driver_register(&comcerto_nand_driver);
+}
+
+static void __exit comcerto_nand_exit(void)
+{
+	platform_driver_unregister(&comcerto_nand_driver);
+}
+
+module_init(comcerto_nand_init);
+module_exit(comcerto_nand_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Board-specific glue layer for NAND flash on Comcerto board");
-- 
1.6.5.2

