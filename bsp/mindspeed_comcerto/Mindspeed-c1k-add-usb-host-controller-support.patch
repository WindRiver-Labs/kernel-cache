From 2b19138a351f90f6f1726d45ddbffe0ccc67efcb Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Wed, 27 Oct 2010 09:31:04 +0800
Subject: [PATCH 20/26] Mindspeed-c1k: add usb host controller support

Add usb host controller support for mindspeed c1k board.
[Original code taken from sdk-comcerto-openwrt-6.0.tar.bz2]

Integrated-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 arch/arm/mach-comcerto/board-c1kmfcn_evm.c |   32 +++
 drivers/usb/Kconfig                        |    1 +
 drivers/usb/host/Kconfig                   |    6 +
 drivers/usb/host/ehci-comcerto.c           |  407 ++++++++++++++++++++++++++++
 drivers/usb/host/ehci-hcd.c                |    5 +
 5 files changed, 451 insertions(+), 0 deletions(-)
 create mode 100644 drivers/usb/host/ehci-comcerto.c

diff --git a/arch/arm/mach-comcerto/board-c1kmfcn_evm.c b/arch/arm/mach-comcerto/board-c1kmfcn_evm.c
index b986534..ab602bf 100644
--- a/arch/arm/mach-comcerto/board-c1kmfcn_evm.c
+++ b/arch/arm/mach-comcerto/board-c1kmfcn_evm.c
@@ -399,6 +399,34 @@ static struct platform_device comcerto_wdt = {
 };
 #endif
 
+#if defined(CONFIG_USB_EHCI_COMCERTO_83XX) || \
+				defined(CONFIG_USB_EHCI_COMCERTO_83XX_MODULE)
+static u64 ehci_dmamask = 0xfffff000;
+static struct resource comcerto_usb0_resources[] = {
+	[0] = {
+		.start  = COMCERTO_AHB_USB0_BASE,
+		.end    = COMCERTO_AHB_USB0_BASE + SZ_8M - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = IRQ_USB0,
+		.end  = IRQ_USB0,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device comcerto_usb0_device = {
+	.name           = "comcerto-ehci",
+	.id             = 1,
+	.dev = {
+		.dma_mask               = &ehci_dmamask,
+		.coherent_dma_mask      = 0xffffffff,
+	},
+	.num_resources  = ARRAY_SIZE(comcerto_usb0_resources),
+	.resource       = comcerto_usb0_resources,
+};
+#endif
+
 static struct platform_device *comcerto_devices[] __initdata = {
 	&comcerto_uart,
 	&comcerto_nand,
@@ -415,6 +443,10 @@ static struct platform_device *comcerto_devices[] __initdata = {
 				defined(CONFIG_COMCERTO_WATCHDOG_MODULE)
 	&comcerto_wdt,
 #endif
+#if defined(CONFIG_USB_EHCI_COMCERTO_83XX) || \
+				defined(CONFIG_USB_EHCI_COMCERTO_83XX_MODULE)
+	&comcerto_usb0_device,
+#endif
 };
 
 #if defined(CONFIG_CONFIG_I2C_BOARDINFO)
diff --git a/drivers/usb/Kconfig b/drivers/usb/Kconfig
index 6a58cb1..1cb1e91 100644
--- a/drivers/usb/Kconfig
+++ b/drivers/usb/Kconfig
@@ -64,6 +64,7 @@ config USB_ARCH_HAS_EHCI
 	default y if ARCH_AT91SAM9G45
 	default y if ARCH_MXC
 	default y if ARCH_OMAP3
+	default y if ARCH_COMCERTO
 	default PCI
 
 # ARM SA1111 chips have a non-PCI based "OHCI-compatible" USB host interface.
diff --git a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
index 8d3df03..f3f3e47 100644
--- a/drivers/usb/host/Kconfig
+++ b/drivers/usb/host/Kconfig
@@ -59,6 +59,12 @@ config USB_EHCI_HCD
 	  To compile this driver as a module, choose M here: the
 	  module will be called ehci-hcd.
 
+config USB_EHCI_COMCERTO_83XX
+	bool "Support for Mindspeed 83xx controller"
+	depends on USB_EHCI_HCD && ARCH_COMCERTO
+	---help---
+	  Enables support for the USB controller on the Mindspeed 83xx chip.
+
 config USB_EHCI_ROOT_HUB_TT
 	bool "Root Hub Transaction Translators"
 	depends on USB_EHCI_HCD
diff --git a/drivers/usb/host/ehci-comcerto.c b/drivers/usb/host/ehci-comcerto.c
new file mode 100644
index 0000000..24db4a6
--- /dev/null
+++ b/drivers/usb/host/ehci-comcerto.c
@@ -0,0 +1,407 @@
+/*
+ *  linux/drivers/usb/host/ehci-comcerto.c
+ *
+ *  Copyright (C) Mindspeed Technologies
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/platform_device.h>
+#include <asm/mach-types.h>
+
+#include <asm/irq.h>
+#include <asm/sizes.h>
+
+
+extern int usb_disabled(void);
+
+/*-------------------------------------------------------------------------*/
+
+static void comcerto_start_ehc(struct platform_device *pdev)
+{
+	u32 val;
+
+	dev_dbg(&pdev->dev, "Starting comcerto EHCI USB Controller\n");
+
+	/* Enable Clock to USB Controller */
+	if (pdev->id == 1) {
+#if defined(CONFIG_ARCH_M83XXX)
+		/* Power up clocks */
+
+#ifdef CONFIG_PM
+		pwr_mgmt_clk_restore(COMPONENT_USB0);
+#else
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) &
+				~(USB_REFCLK_PD | USB_AHBCLK_PD),
+				COMCERTO_CLK_CLK_PWR_DWN);
+#endif
+
+		/* Switch to refclk */
+		writel(readl(COMCERTO_CLK_DDR_PCIE_CLK_CNTRL) & ~USB_MUX_SEL,
+				COMCERTO_CLK_DDR_PCIE_CLK_CNTRL);
+
+		/* Use refclk / 2 */
+		val = readl(COMCERTO_CLK_DDR_PCIE_CLK_CNTRL);
+		val &= ~USB_DIV_VAL_MASK;
+		val |= 2 << USB_DIV_VAL_OFFSET;
+
+		writel(val, COMCERTO_CLK_DDR_PCIE_CLK_CNTRL);
+
+		writel(val & ~USB_DIV_BYPASS, COMCERTO_CLK_DDR_PCIE_CLK_CNTRL);
+
+		/* De-activate USB and USB phy reset */
+		writel(readl(COMCERTO_BLOCK_RESET_REG) | USB_REF_RESET_N |
+				USB_AHB_RESET_N, COMCERTO_BLOCK_RESET_REG);
+
+		writel(readl(COMCERTO_GPIO_GENERAL_CONTROL_REG) &
+				~USB_FORCE_SUSPEND,
+				COMCERTO_GPIO_GENERAL_CONTROL_REG);
+#else
+		/* Enable Clock to USB Port 0 */
+
+#ifdef CONFIG_PM
+		pwr_mgmt_clk_restore(COMPONENT_USB0);
+#else
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) & ~USB0_AHBCLK_PD,
+				COMCERTO_CLK_CLK_PWR_DWN);
+#endif
+
+		/* de-activate USB port 0 reset */
+		writel(readl(COMCERTO_BLOCK_RESET_REG) | USB0_RST,
+				COMCERTO_BLOCK_RESET_REG);
+		/* de-activate USB phy 0 reset */
+		writel(readl(COMCERTO_BLOCK_RESET_REG) | USB0_PHY_RST,
+				COMCERTO_BLOCK_RESET_REG);
+#endif
+		/* taking usb phy out of suspend */
+		/* *(volatile int *)COMCERTO_GPIO_GENERAL_CONTOL_REG  &= 0x2; */
+	}
+#if defined(CONFIG_ARCH_M821XX)
+	else if (pdev->id == 2) {
+		/* Enable Clock to USB Port 1 */
+
+#ifdef CONFIG_PM
+		pwr_mgmt_clk_restore(COMPONENT_USB1);
+#else
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) & ~USB1_AHBCLK_PD,
+				COMCERTO_CLK_CLK_PWR_DWN);
+#endif
+
+		/* de-activate USB port 1 reset */
+		writel(readl(COMCERTO_BLOCK_RESET_REG) | USB1_RST,
+				COMCERTO_BLOCK_RESET_REG);
+		/* de-activate USB phy 1 reset */
+		writel(readl(COMCERTO_BLOCK_RESET_REG) | USB1_PHY_RST,
+				COMCERTO_BLOCK_RESET_REG);
+
+		/* taking usb phy out of suspend */
+		/* *(volatile int *)COMCERTO_GPIO_GENERAL_CONTOL_REG &= ~0x8; */
+	}
+#endif
+}
+
+static void comcerto_stop_ehc(struct platform_device *pdev)
+{
+	dev_dbg(&pdev->dev, "Stopping comcerto EHCI USB Controller\n");
+
+	/* Disable Clock to USB Controller */
+	if (pdev->id == 1) {
+
+#if defined(CONFIG_ARCH_M83XXX)
+		writel(readl(COMCERTO_BLOCK_RESET_REG) &
+				~(USB_REF_RESET_N | USB_AHB_RESET_N),
+				COMCERTO_BLOCK_RESET_REG);
+
+#ifdef CONFIG_PM
+		pwr_mgmt_clk_down(COMPONENT_USB0);
+#else
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) |
+			(USB_REFCLK_PD | USB_AHBCLK_PD),
+			COMCERTO_CLK_CLK_PWR_DWN);
+#endif
+
+#else
+		/* disable Clock to USB Port 0 */
+#ifdef CONFIG_PM
+		pwr_mgmt_clk_down(COMPONENT_USB0);
+#else
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) | USB0_AHBCLK_PD,
+			COMCERTO_CLK_CLK_PWR_DWN);
+#endif
+
+		/* activate USB port 0 reset */
+		writel(readl(COMCERTO_BLOCK_RESET_REG) & ~USB0_RST,
+			COMCERTO_BLOCK_RESET_REG);
+		/* activate USB phy 0 reset */
+		writel(readl(COMCERTO_BLOCK_RESET_REG) & ~USB0_PHY_RST,
+			COMCERTO_BLOCK_RESET_REG);
+#endif
+	}
+#if defined(CONFIG_ARCH_M821xx)
+	else if (pdev->id == 2) {
+		/* disable Clock to USB Port 1 */
+#ifdef CONFIG_PM
+		pwr_mgmt_clk_down(COMPONENT_USB1);
+#else
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) | USB1_AHBCLK_PD,
+			COMCERTO_CLK_CLK_PWR_DWN);
+#endif
+
+		/* activate USB port 1 reset */
+		writel(readl(COMCERTO_BLOCK_RESET_REG) & ~USB1_RST,
+			COMCERTO_BLOCK_RESET_REG);
+		/* activate USB phy 1 reset */
+		writel(readl(COMCERTO_BLOCK_RESET_REG) & ~USB1_PHY_RST,
+			COMCERTO_BLOCK_RESET_REG);
+	}
+#endif
+}
+
+/*-------------------------------------------------------------------------*/
+
+/* configure so an HC device and id are always provided */
+/* always called with process context; sleeping is OK */
+
+/**
+ * usb_ehci_comcerto_probe - initialize comcerto HCDs
+ * Context: !in_interrupt()
+ *
+ * Allocates basic resources for this USB host controller, and
+ * then invokes the start() method for the HCD associated with it
+ * through the hotplug entry's driver_data.
+ *
+ */
+int usb_ehci_comcerto_probe(const struct hc_driver *driver,
+			  struct platform_device *pdev)
+{
+	int retval;
+	struct usb_hcd *hcd;
+	struct ehci_hcd *ehci;
+
+	if (pdev->num_resources != 2) {
+		dev_err(&pdev->dev, "HCD %s probe: invalid num_resources: %i\n",
+		       dev_name(&pdev->dev), pdev->num_resources);
+		return -ENODEV;
+	}
+
+	if (pdev->resource[0].flags != IORESOURCE_MEM
+	    || pdev->resource[1].flags != IORESOURCE_IRQ) {
+		dev_err(&pdev->dev, "HCD %s probe: invalid resource type\n",
+			dev_name(&pdev->dev));
+		return -ENODEV;
+	}
+
+	comcerto_start_ehc(pdev);
+
+	hcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));
+	if (!hcd)
+		return -ENOMEM;
+
+	hcd->rsrc_start = pdev->resource[0].start;
+	hcd->rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;
+
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,
+						driver->description)) {
+		dev_dbg(&pdev->dev, "request_mem_region failed");
+		retval = -EBUSY;
+		goto err1;
+	}
+
+	hcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);
+	if (!hcd->regs) {
+		dev_dbg(&pdev->dev, "ioremap failed");
+		retval = -ENOMEM;
+		goto err2;
+	}
+
+	ehci = hcd_to_ehci(hcd);
+	ehci->caps = hcd->regs + 0x100;
+	ehci->regs = hcd->regs + 0x100 +
+				HC_LENGTH(readl(&ehci->caps->hc_capbase));
+	/* cache this readonly data; minimize chip reads */
+	ehci->hcs_params = readl(&ehci->caps->hcs_params);
+
+	hcd->has_tt = 1;
+
+	tdi_reset(ehci);
+	ehci_reset(ehci);
+	ehci->sbrn = 0x20; /* just fool it */
+
+	ehci_port_power(ehci, 1);
+
+	retval = usb_add_hcd(hcd, pdev->resource[1].start,
+				IRQF_DISABLED | IRQF_SHARED);
+	if (retval == 0)
+		return retval;
+
+	comcerto_stop_ehc(pdev);
+	iounmap(hcd->regs);
+err2:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+err1:
+	usb_put_hcd(hcd);
+	return retval;
+}
+
+/* may be called without controller electrically present */
+/* may be called with controller, bus, and devices active */
+
+/**
+ * usb_ehci_hcd_comcerto_remove - shutdown processing for comcerto-based HCDs
+ * @dev: USB Host Controller being removed
+ * Context: !in_interrupt()
+ *
+ * Reverses the effect of usb_ehci_hcd_comcerto_probe(), first invoking
+ * the HCD's stop() method.  It is always called from a thread
+ * context, normally "rmmod", "apmd", or something similar.
+ *
+ */
+void usb_ehci_comcerto_remove(struct usb_hcd *hcd, struct platform_device *pdev)
+{
+	usb_remove_hcd(hcd);
+	iounmap(hcd->regs);
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+	usb_put_hcd(hcd);
+	comcerto_stop_ehc(pdev);
+}
+
+/*-------------------------------------------------------------------------*/
+
+static const struct hc_driver ehci_comcerto_hc_driver = {
+	.description = hcd_name,
+	.product_desc = "comcerto EHCI",
+	.hcd_priv_size = sizeof(struct ehci_hcd),
+
+	/*
+	 * generic hardware linkage
+	 */
+	.irq = ehci_irq,
+	.flags = HCD_MEMORY | HCD_USB2,
+
+	/*
+	 * basic lifecycle operations
+	 */
+	.reset = ehci_init,
+	.start = ehci_run,
+	.stop = ehci_stop,
+
+	/*
+	 * managing i/o requests and associated device resources
+	 */
+	.urb_enqueue = ehci_urb_enqueue,
+	.urb_dequeue = ehci_urb_dequeue,
+	.endpoint_disable = ehci_endpoint_disable,
+	.endpoint_reset = ehci_endpoint_reset,
+
+	/*
+	 * scheduling support
+	 */
+	.get_frame_number = ehci_get_frame,
+
+	/*
+	 * root hub support
+	 */
+	.hub_status_data = ehci_hub_status_data,
+	.hub_control = ehci_hub_control,
+	.relinquish_port = ehci_relinquish_port,
+	.port_handed_over = ehci_port_handed_over,
+
+	.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,
+#ifdef CONFIG_PM
+	.bus_suspend = ehci_bus_suspend,
+	.bus_resume = ehci_bus_resume,
+#endif
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int ehci_hcd_comcerto_drv_probe(struct platform_device *dev)
+{
+	pr_debug("In ehci_hcd_comcerto_drv_probe\n");
+
+	if (usb_disabled())
+		return -ENODEV;
+
+	return usb_ehci_comcerto_probe(&ehci_comcerto_hc_driver, dev);
+}
+
+static int ehci_hcd_comcerto_drv_remove(struct platform_device *dev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(dev);
+
+	usb_ehci_comcerto_remove(hcd, dev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int ehci_hcd_comcerto_drv_suspend(struct platform_device *dev,
+					pm_message_t state)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(dev);
+	int ret = 0;
+
+	ret = hcd->driver->bus_suspend(hcd);
+	if (ret)
+		goto out;
+
+#if defined(CONFIG_ARCH_M83XXX)
+	pwr_mgmt_clk_down(COMPONENT_USB0);
+#else
+	if (dev->id == 1)
+		pwr_mgmt_clk_down(COMPONENT_USB0);
+	else
+		pwr_mgmt_clk_down(COMPONENT_USB1);
+#endif
+
+out:
+	return ret;
+}
+
+static int ehci_hcd_comcerto_drv_resume(struct platform_device *dev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(dev);
+	int ret = 0;
+
+#if defined(CONFIG_ARCH_M83XXX)
+	pwr_mgmt_clk_restore(COMPONENT_USB0);
+#else
+	if (dev->id == 1)
+		pwr_mgmt_clk_restore(COMPONENT_USB0);
+	else
+		pwr_mgmt_clk_restore(COMPONENT_USB1);
+#endif
+
+	ret = hcd->driver->bus_resume(hcd);
+	if (ret) {
+#if defined(CONFIG_ARCH_M83XXX)
+		pwr_mgmt_clk_down(COMPONENT_USB0);
+#else
+	if (dev->id == 1)
+		pwr_mgmt_clk_down(COMPONENT_USB0);
+	else
+		pwr_mgmt_clk_down(COMPONENT_USB1);
+#endif
+	}
+
+	return ret;
+}
+#endif
+MODULE_ALIAS("comcerto-ehci");
+static struct platform_driver ehci_hcd_comcerto_driver = {
+	.probe = ehci_hcd_comcerto_drv_probe,
+	.remove = ehci_hcd_comcerto_drv_remove,
+	.shutdown = usb_hcd_platform_shutdown,
+#ifdef CONFIG_PM
+	.suspend = ehci_hcd_comcerto_drv_suspend,
+	.resume = ehci_hcd_comcerto_drv_resume,
+#endif
+	.driver = {
+		.name = "comcerto-ehci",
+		.bus = &platform_bus_type,
+	}
+};
+
diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c
index 13ead00..621d79d 100644
--- a/drivers/usb/host/ehci-hcd.c
+++ b/drivers/usb/host/ehci-hcd.c
@@ -1124,6 +1124,11 @@ MODULE_LICENSE ("GPL");
 #define        PLATFORM_DRIVER         ehci_hcd_omap_driver
 #endif
 
+#if defined(CONFIG_ARCH_COMCERTO)
+#include "ehci-comcerto.c"
+#define PLATFORM_DRIVER         ehci_hcd_comcerto_driver
+#endif
+
 #ifdef CONFIG_PPC_PS3
 #include "ehci-ps3.c"
 #define	PS3_SYSTEM_BUS_DRIVER	ps3_ehci_driver
-- 
1.6.5.2

