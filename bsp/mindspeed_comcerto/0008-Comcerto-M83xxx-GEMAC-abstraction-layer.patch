From 51e1a2b0e7b2eb1bf67bec7aaf73d5c9ce41225a Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Tue, 19 Oct 2010 15:04:27 +0800
Subject: [PATCH 08/26] Comcerto: M83xxx: GEMAC abstraction layer

Original codes came from Mindspeed's vendor drop sdk-comcerto-openwrt-6.0.

Add the abstraction layer functions for all the various GEMAC configuration
parameters.

Integrated-by: Stanley.Miao <stanley.miao@windriver.com>
---
 drivers/net/comcerto/comcerto_gem_AL.c | 1238 ++++++++++++++++++++++++++++++++
 drivers/net/comcerto/comcerto_gemac.h  |  781 ++++++++++++++++++++
 2 files changed, 2019 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/comcerto/comcerto_gem_AL.c
 create mode 100644 drivers/net/comcerto/comcerto_gemac.h

diff --git a/drivers/net/comcerto/comcerto_gem_AL.c b/drivers/net/comcerto/comcerto_gem_AL.c
new file mode 100644
index 0000000..a503718
--- /dev/null
+++ b/drivers/net/comcerto/comcerto_gem_AL.c
@@ -0,0 +1,1238 @@
+/*
+ *  linux/drivers/net/comcerto/comcerto_gem_AL.c
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <mach/hardware.h>
+#include "comcerto_gemac.h"
+
+/* Some functions to set/reset and get specific bits in the MAC registers
+ * Note that all functions operate on a read-modify-write basis
+ */
+
+/*
+ * Function to start transmission on the specified device.  The parameter to
+ * this function is simply a pointer to the GEM_DEVICE structure.
+ * This function should be called after the relevant queues and data has been
+ * set up, however it will check if the number of queue elements is zero first.
+ * Note that this function will also enable tx even if it was previously not set
+ *
+ * Return value:
+ *  0   :   OK
+ *  -1  :   Transmit queue not valid.
+ */
+int gem_start_tx(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONTROL) |= (GEM_TX_START | GEM_TX_EN);
+	return 0;
+}
+
+/*
+ * Halt transmission after current frame has completed.  This is accomplished
+ * simply by writing to the GEM_TX_HALT bit in the network control register,
+ * which should cause the MAC to complete its current frame then stop.
+ *
+ * There is no return value for this function.
+ */
+void gem_stop_tx(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONTROL) |= GEM_TX_HALT;
+}
+
+/*
+ * Abort transmission immediately WITHOUT waiting for completion of any current
+ * frame.
+ * Note that after this operation, the transmit buffer descriptor will be reset
+ * to point to the first buffer in the descriptor list!
+ *
+ * There is no return value.
+ */
+void gem_abort_tx(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONTROL) &= (~GEM_TX_EN);
+}
+
+/*
+ * Obtains status of transmission circuitry, whether it is transmitting or idle.
+ *
+ * Return value:
+ *  0   :   Transmitter is idle.
+ *  1   :   Transmitter active.
+ */
+int gem_transmitting(GEM_DEVICE *mac)
+{
+	return ((*(volatile u32 *)(mac->registers + GEM_TX_STATUS) & GEM_TX_GO) == GEM_TX_GO);
+}
+
+#if defined(CONFIG_ARCH_M83XXX)
+int gem_set_rx_offset(GEM_DEVICE *mac, unsigned short offset)
+{
+	*(volatile u32 *)(mac->registers + GEM_RX_OFFSET) = offset;
+	return 0;
+}
+#endif
+/*
+ * Enable the receive circuitry.  This should be performed only after the
+ * buffers and the descriptor queues have been set up, otherwise unpredictable
+ * results may occur.
+ *
+ * Return value:
+ *  0   :   OK
+ *  -1  :   Receive queue not valid.
+ */
+int gem_enable_rx(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONTROL) |= GEM_RX_EN;
+	return 0;
+}
+
+/*
+ * Disable the receive circuitry.  This will stop reception of any frame
+ * immediately, note that the descriptor pointer is not changed.
+ *
+ * There is no return value for this function.
+ */
+void gem_disable_rx(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONTROL) &= (~GEM_RX_EN);
+}
+
+/*
+ * Enable the transmit circuitry.  This should be performed only after the
+ * buffers and the descriptor queues have been set up, otherwise unpredictable
+ * results may occur.
+ *
+ * Return value:
+ *  0   :   OK
+ *  -1  :   Receive queue not valid.
+ */
+int gem_enable_tx(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONTROL) |= GEM_TX_EN;
+	return 0;
+}
+
+/*
+ * Disable the transmit circuitry.  This will stop reception of any frame
+ * immediately, note that the descriptor pointer is not changed.
+ *
+ * There is no return value for this function.
+ */
+void gem_disable_tx(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONTROL) &= (~GEM_TX_EN);
+}
+
+/*
+ * Obtain the status of the receive circuitry, whether it is enabled.
+ *
+ * Return value:
+ *  0   :   Receive circuitry disabled.
+ *  -1  :   Receive circuits enabled.
+ */
+int gem_receive_on(GEM_DEVICE *mac)
+{
+	return ((*(volatile u32 *)(mac->registers + GEM_NET_CONTROL) & GEM_RX_EN) == GEM_RX_EN);
+}
+
+/*
+ * Set the loopback mode of the MAC.  This can be either no loopback for normal
+ * operation, local loopback through MAC internal loopback module or PHY
+ * loopback for external loopback through a PHY.  This asserts the external loop
+ * pin.
+ * The function parameters are a pointer to the device and an enumerated type
+ * specifying the type of loopback required.
+ *
+ * Note: if an invalid loopback mode is specified, loop back will be disabled.
+ *
+ * There is no return value for this function.
+ */
+void gem_set_loop(GEM_DEVICE  *mac, MAC_LOOP    gem_loop)
+{
+	switch (gem_loop) {
+	case LB_LOCAL:
+		*(volatile u32 *)(mac->registers + GEM_NET_CONTROL) &= (~GEM_LB_PHY);
+		*(volatile u32 *)(mac->registers + GEM_NET_CONTROL) |= (GEM_LB_MAC);
+		break;
+	case LB_EXT:
+		*(volatile u32 *)(mac->registers + GEM_NET_CONTROL) &= (~GEM_LB_MAC);
+		*(volatile u32 *)(mac->registers + GEM_NET_CONTROL) |= (GEM_LB_PHY);
+		break;
+	default:
+		*(volatile u32 *)(mac->registers + GEM_NET_CONTROL) &= (~(GEM_LB_MAC | GEM_LB_PHY));
+	}
+}
+
+/*
+ * Get the loopback mode of the MAC.  This can be either no loopback for normal
+ * operation, local loopback through MAC internal loopback module or PHY
+ * loopback for external loopback through a PHY.  This asserts the external loop
+ * pin.
+ * The function parameters are a pointer to the device.
+ *
+ * Return value:
+ *  LB_LOCAL    :   Local loop back active.
+ *  LB_EXT      :   External loop back active.
+ *  LB_NONE     :   Loop back disabled.
+ *  -1          :   Unknown mode.
+ */
+MAC_LOOP gem_get_loop(GEM_DEVICE  *mac)
+{
+	u32 lb_mode;
+
+	lb_mode = *(volatile u32 *)(mac->registers + GEM_NET_CONTROL) & (GEM_LB_PHY | GEM_LB_MAC);
+	switch (lb_mode) {
+	case GEM_LB_MAC:
+		return LB_LOCAL;
+	case GEM_LB_PHY:
+		return LB_EXT;
+	case 0:
+		return LB_NONE;
+	default:
+		return -1;
+	}
+}
+
+/*
+ * Enable pause frame reception.  With this enabled, if a valid pause frame is
+ * received, transmission will halt for the specified time after the current
+ * frame has completed transmission.
+ *
+ * There is no return value for this function.
+ */
+void gem_enable_pause_rx(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) |= GEM_RX_PAUSE_EN;
+}
+
+/*
+ * Disable pause frame reception.  Incoming pause frames are ignored.
+ *
+ * There is no return value for this function.
+ */
+void gem_disable_pause_rx(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) &= (~GEM_RX_PAUSE_EN);
+}
+
+/*
+ * Enable Checksum Engine.
+ * With this enabled, Frame with bad IP, TCP or UDP checksums are discarded
+ * There is no return value for this function.
+ */
+void gem_enable_rx_checksum_offload(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) |= GEM_CKSUM_OFFLOAD;
+
+#if defined(CONFIG_ARCH_M83XXX)
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) |= GEM_ENABLE_L4_CKSUM | GEM_ENABLE_L3_CKSUM;
+#endif
+}
+
+/*
+ * Disable Checksum Engine.
+ *
+ * There is no return value for this function.
+ */
+void gem_disable_rx_checksum_offload(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) &= (~GEM_CKSUM_OFFLOAD);
+
+#if defined(CONFIG_ARCH_M83XXX)
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) &= ~(GEM_ENABLE_L4_CKSUM | GEM_ENABLE_L3_CKSUM);
+#endif
+}
+
+#if defined(CONFIG_ARCH_M83XXX)
+void gem_enable_tx_checksum_offload(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_DMA_CONFIG) |= GEM_TX_CSUM_OFFLOAD;
+}
+
+void gem_disable_tx_checksum_offload(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_DMA_CONFIG) &= ~GEM_TX_CSUM_OFFLOAD;
+}
+#endif
+/*
+ * Enable copy of received pause frame.
+ *
+ * There is no return value for this function.
+ */
+void gem_enable_pause_cpy(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) &= (~GEM_RX_NO_PAUSE);
+}
+
+/*
+ * Disable copy of received pause frame.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_disable_pause_cpy(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONTROL) |= GEM_RX_NO_PAUSE;
+}
+
+
+
+
+/*
+ * Send a pause frame with zero quantum.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_send_0q_pause(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONTROL) |= GEM_TX_0Q_PAUSE;
+}
+
+
+
+
+/*
+ * Send a normal pause frame.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_send_pause(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONTROL) |= GEM_TX_PAUSE;
+}
+
+/*
+ * Set transmit pause quantum.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_set_tx_pause_q(GEM_DEVICE *mac, u32 gem_pause)
+{
+	*(volatile u32 *)(mac->registers + GEM_TX_PAUSE_QUANT) = gem_pause;
+}
+
+/*
+ * Read transmit pause quantum.
+ *
+ * Return values:
+ * 0-65535: transmit pause quantum.
+ */
+
+u32 gem_get_tx_pause_q(GEM_DEVICE *mac)
+{
+	return *(volatile u32 *)(mac->registers + GEM_TX_PAUSE_QUANT);
+}
+
+/*
+ * Set retry test bit, this is used for debug purposes only to speed up testing.
+ * This should not be enabled for normal operation.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_en_retry_test(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) |= GEM_RETRY_TEST;
+}
+
+/*
+ * Disable retry test bit.  For normal operation this bit should not be set.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_dis_retry_test(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) &= (~GEM_RETRY_TEST);
+}
+
+/*
+ * Enable external address match via the eam pin, which when active will copy
+ * the current frame to memory.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_enable_eam(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) |= GEM_EAM_EN;
+}
+
+/*
+ * Disable external address match capability.  The MAC will ignore the status of
+ * the eam pin.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_disable_eam(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) &= (~GEM_EAM_EN);
+}
+
+/*
+ * Enable storing of the receive frame check sequence into memory.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_enable_fcs_rx(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) &= (~GEM_RX_NO_FCS);
+}
+
+/*
+ * Disable storing of the receive frame check sequence into memory.  The last 4
+ * bytes from the incoming frame will be checked for valid CRC, however this
+ * will not be stored into memory.  The frame length will be updated
+ * accordingly.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_disable_fcs_rx(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) |= GEM_RX_NO_FCS;
+}
+
+/*
+ * Enable reception of long frames up to 1536 bytes in length.
+ * These are not standard IEEE 802.3 frames.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_enable_1536_rx(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) |= GEM_FRAME_1536;
+}
+
+/*
+ * Disable reception of frames greater than 1518 bytes in length.
+ * This is normal operation mode for the MAC for compatibility with IEEE 802.3
+ *
+ * There is no return value for this function.
+ */
+
+void gem_disable_1536_rx(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) &= (~GEM_FRAME_1536);
+}
+
+/*
+ * Enable reception of unicast hashed frames.  The frame will be received when
+ * the 6 bit hash function of the frame's destination address points a bit that
+ * is set in the 64-bit hash register and is signalled as a unicast frame.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_enable_unicast(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) |= GEM_UNICAST_EN;
+}
+
+/*
+ * Disable reception of unicast hashed frames.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_disable_unicast(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) &= (~GEM_UNICAST_EN);
+}
+
+/*
+ * Enable reception of multicast hashed frames.  The frame will be received when
+ * the 6 bit hash function of the frame's destination address points a bit that
+ * is set in the 64-bit hash register and is signalled as a multicast frame.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_enable_multicast(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) |= GEM_MULTICAST_EN;
+}
+
+/*
+ * Disable reception of multicast hashed frames.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_disable_multicast(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) &= (~GEM_MULTICAST_EN);
+}
+
+/*
+ * Allow reception of broadcast frames (frames with address set to all 1's)
+ * This is normal operating mode for the MAC.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_allow_broadcast(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) &= (~GEM_NO_BROADCAST);
+}
+
+/*
+ * Do not allow reception of broadcast frames, such frames will be ignored.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_no_broadcast(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) |= GEM_NO_BROADCAST;
+}
+
+/*
+ * Enable copy all frames.  In this mode, the MAC will copy all valid received
+ * frames to memory regardless of the destination address.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_enable_copy_all(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) |= GEM_COPY_ALL;
+}
+
+/*
+ * Do not copy all frames.  Normal operating mode for the MAC, frames will only
+ * be copied to memory if it matches one of the specific or hash addresses.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_disable_copy_all(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) &= (~GEM_COPY_ALL);
+}
+
+/*
+ * Set MAC into full duplex mode.  The crs and col signals will be ignored in
+ * this mode.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_full_duplex(GEM_DEVICE *mac)
+{
+	u32 tmp;
+
+	tmp = *(volatile u32 *)(mac->gemac_baseaddr + GEM_CFG);
+	tmp = (tmp | GEM_CONF_DUPLEX_SEL_GEM) | GEM_CONF_DUPLEX_GEM_FULL;
+	*(volatile u32 *)(mac->gemac_baseaddr + GEM_CFG) = tmp;
+}
+
+/*
+ * Set MAC into half duplex mode.  The crs and col signals are used to detect
+ * collisions and perform deference where necessary.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_half_duplex(GEM_DEVICE *mac)
+{
+	u32 tmp;
+
+	tmp = *(volatile u32 *)(mac->gemac_baseaddr + GEM_CFG);
+	tmp = (tmp | GEM_CONF_DUPLEX_SEL_GEM) & ~GEM_CONF_DUPLEX_GEM_FULL;
+	*(volatile u32 *)(mac->gemac_baseaddr + GEM_CFG) = tmp;
+}
+
+/*
+ * Set the operating speed of the MAC, for 10 and 100Mb modes, this has no
+ * effect on the MAC functionality, but simply asserts an external speed pin
+ * accordingly.
+ * For 1G modes, this will set the MAC into the appropriate operating mode by
+ * switching to either the GMII or TBI interface depending on required mode.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_set_speed(GEM_DEVICE *mac, MAC_SPEED gem_speed)
+{
+	u32 tmp;
+
+	tmp = *(volatile u32 *)(mac->gemac_baseaddr + GEM_CFG);
+	tmp = (tmp & ~GEM_CONF_SPEED_MASK) | GEM_CONF_SPEED_SEL_GEM;
+
+	switch (gem_speed) {
+	case SPEED_10M:
+		tmp |= GEM_CONF_SPEED_GEM_10M;
+		break;
+	case SPEED_100M:
+		tmp |= GEM_CONF_SPEED_GEM_100M;
+		break;
+	case SPEED_1000M:
+	case SPEED_1000M_PCS:
+		tmp |= GEM_CONF_SPEED_GEM_1G;
+		break;
+	default:
+		tmp |= GEM_CONF_SPEED_GEM_100M;
+	}
+
+	*(volatile u32 *)(mac->gemac_baseaddr + GEM_CFG) = tmp;
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) &= (~GEM_PCS_SEL);
+}
+
+/*
+ * Get the operating speed of the MAC, currently this has no functional effect
+ * on the MAC.
+ *
+ * This function returns an enumerated value cast into an int.  This is for
+ * backward compatibility with the macb driver.
+ *
+ * Return value:
+ *  SPEED_10M   :   MAC in 10Mb/s mode.
+ *  SPEED_100M  :   MAC in 100Mb/s mode.
+ *  SPEED_1000M :   MAC in 1G mode with GMII interface.
+ *  SPEED_1000M_PCS :   MAC in 1G mode with PCS interface.
+ */
+
+MAC_SPEED gem_get_speed(GEM_DEVICE *mac)
+{
+	u32 gem_cfg, net_config;
+
+	gem_cfg = *(volatile u32 *)(mac->gemac_baseaddr + GEM_CFG);
+	net_config = *(volatile u32 *)(mac->registers + GEM_NET_CONFIG);
+
+	if (gem_cfg & GEM_CONF_SPEED_SEL_GEM) {
+		if (gem_cfg & GEM_CONF_SPEED_GEM_1G) {
+			if (net_config & GEM_PCS_SEL)
+				return SPEED_1000M_PCS;
+			else
+				return SPEED_1000M;
+		} else {
+			if (gem_cfg & GEM_CONF_SPEED_GEM_100M)
+				return SPEED_100M;
+			else
+				return SPEED_10M;
+		}
+	} else {
+		if (gem_cfg & GEM_CONF_SPEED_PHY_1G) {
+			if (net_config & GEM_PCS_SEL)
+				return SPEED_1000M_PCS;
+			else
+				return SPEED_1000M;
+		} else {
+			if (gem_cfg & GEM_CONF_SPEED_PHY_100M)
+				return SPEED_100M;
+			else
+				return SPEED_10M;
+		}
+	}
+}
+
+
+#if !defined(CONFIG_ARCH_M83XXX)
+
+/*
+ * Set AMBA AHB bus width.
+ * AMBA_AHB_32:
+ * AMBA_AHB_64:
+ * AMBA_AHB_128:
+ * There is no return value for this function.
+ */
+
+void gem_set_ahb_width(GEM_DEVICE *mac, MAC_AHB_WIDTH gem_buswidth)
+{
+	switch (gem_buswidth) {
+	case AMBA_AHB_128:
+		*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) |= GEM_AHB_WIDTH1;
+		break;
+	case AMBA_AHB_64:
+		*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) &= (~GEM_AHB_WIDTH1);
+		*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) |= GEM_AHB_WIDTH0;
+		break;
+	case AMBA_AHB_32:
+	default:
+		*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) &= ((~GEM_AHB_WIDTH1) & (~GEM_AHB_WIDTH0));
+	}
+}
+
+/*
+ * Get AMBA AHB bus width.
+ * It returns one of the following values:
+ * AMBA_AHB_32, AMBA_AHB_64, AMBA_AHB_128,
+ */
+
+MAC_AHB_WIDTH gem_get_ahb_width(GEM_DEVICE *mac)
+{
+	if (*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) & GEM_AHB_WIDTH1)
+		return AMBA_AHB_128;
+	else {
+		if (*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) & GEM_AHB_WIDTH0)
+			return AMBA_AHB_64;
+		else
+			return AMBA_AHB_32;
+	}
+}
+#endif
+
+
+/*
+ * Enable to read snapshot values of statistic registers.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_enable_rd_snap(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONTROL) |= GEM_READ_SNAP;
+}
+
+/*
+ * Disable to read snapshot values of statistic registers.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_disable_rd_snap(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONTROL) &= (~GEM_READ_SNAP);
+}
+
+/*
+ * Take snapshot of statistic registers. Writing a one will record the current
+ * value of all statistics registers in the snapshot registers and clear the
+ * statistics registers.
+ *
+ * There is no return value for this function.
+ */
+
+void gem_take_snap(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONTROL) |= GEM_TAKE_SNAP;
+}
+
+/*
+ * Get the value of the transmit status register.
+ * The return value is an unsigned 32-bit integer containing the contents of the
+ * register.  This should be masked appropriately to obtain the relevant status.
+ *
+ * Return value:
+ * Returns current value of transmit status register.
+ */
+
+u32 gem_get_tx_stat(GEM_DEVICE *mac)
+{
+	return *(volatile u32 *)(mac->registers + GEM_TX_STATUS);
+}
+
+/*
+ * Reset the specified bits of the transmit status register.
+ *
+ * There is no return value.
+ */
+
+void gem_reset_tx_stat(GEM_DEVICE  *mac, u32 rst_status)
+{
+	*(volatile u32 *)(mac->registers + GEM_TX_STATUS) |= rst_status;
+}
+
+/*
+ * Get the value of the receive status register.
+ * The return value is an unsigned 32-bit integer containing the contents of the
+ * register.  This should be masked appropriately to obtain the relevant status.
+ *
+ * Returns current receive status.
+ */
+
+u32 gem_get_rx_stat(GEM_DEVICE *mac)
+{
+	return *(volatile u32 *)(mac->registers + GEM_RX_STATUS);
+}
+
+/*
+ * Reset the specified bits of the receive status register.
+ *
+ * There is no return value.
+ */
+
+void gem_reset_rx_stat(GEM_DEVICE  *mac, u32 rst_status)
+{
+	*(volatile u32 *)(mac->registers + GEM_RX_STATUS) |= rst_status;
+}
+
+/*
+ * Enable jumbo frames to be accepted.
+ *
+ * There is no return value.
+ */
+
+void gem_enable_rx_jmb(GEM_DEVICE  *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) |= GEM_RX_JUMBO;
+}
+
+/*
+ * Disable jumbo frames to be accepted.
+ *
+ * There is no return value.
+ */
+
+void gem_disable_rx_jmb(GEM_DEVICE  *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) &= (~GEM_RX_JUMBO);
+}
+
+/*
+ * Enable only VLAN frames to be accepted, all other frames will be discarded.
+ *
+ * There is no return value.
+ */
+
+void gem_enable_vlan_only(GEM_DEVICE  *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) |= GEM_VLAN_ONLY;
+}
+
+/*
+ * Disable VLAN frame only mode. All frames will be accepted.
+ *
+ * There is no return value.
+ */
+
+void gem_disable_vlan_only(GEM_DEVICE  *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) &= (~GEM_VLAN_ONLY);
+}
+
+/*
+ * Read the interrupt status register.
+ * This returns an unsigned 32-bit integer with the current interrupt status,
+ * this should be masked appropriately to get the required status.
+ * Note that the interrupt status register is automatically reset on read, so
+ * the returned value should be stored if further processing required.
+ *
+ * Returns the current interrupt status.
+ */
+
+u32 gem_get_irq_stat(GEM_DEVICE *mac)
+{
+	return *(volatile u32 *)(mac->registers + GEM_IRQ_STATUS);
+}
+
+/*
+ * Set specified bits in the interrupt status register.
+ * This can be used for debug purposes to manually activate an interrupt.
+ *
+ * There is no return value.
+ */
+
+void gem_set_irq_stat(GEM_DEVICE *mac, u32 irq_status)
+{
+	*(volatile u32 *)(mac->registers + GEM_IRQ_STATUS) |= irq_status;
+}
+
+/*
+ * Enable specified interrupts.
+ * The specified interrupt bits are enabled by unmasking them.
+ * Note that this appends to the existing interrupt enable list.
+ *
+ * There is no return value.
+ */
+
+void gem_enable_irq(GEM_DEVICE *mac, u32 irq_en)
+{
+	*(volatile u32 *)(mac->registers + GEM_IRQ_ENABLE) |= irq_en;
+}
+
+/*
+ * Disable specified interrupts.
+ * The specified interrupts are masked out so that they do not generate an
+ * interrupt.
+ * Note that this appends to the existing interrupt mask list.
+ *
+ * There is no return value.
+ */
+
+void gem_mask_irq(GEM_DEVICE *mac, u32 irq_mask)
+{
+	*(volatile u32 *)(mac->registers + GEM_IRQ_DISABLE) |= irq_mask;
+}
+
+/*
+ * Obtain the current interrupt mask value.
+ * The return value indicates which interrupts are currently masked out i.e. do
+ * not generate an interrupt.
+ *
+ * Returns the interrupt mask status.
+ */
+
+u32 gem_get_irq_mask(GEM_DEVICE *mac)
+{
+	return *(volatile u32 *)(mac->registers + GEM_IRQ_MASK);
+}
+
+/*
+ * Read the pause time register.
+ *
+ * Returns the current value in the pause time register which will
+ * decrement when the MAC has gone into pause mode.
+ */
+
+u32 gem_pause_time(GEM_DEVICE *mac)
+{
+	return *(volatile u32 *)(mac->registers + GEM_RX_PAUSE_TIME);
+}
+
+/*
+ * Set the id-check registers of the MAC.
+ * These registers are used to check the type-id field of the incoming frames,
+ * if matched, the appropriate status bit will be set in word 1 of the receive
+ * descriptor for that frame.
+ * The input parameter is truncated to 16-bits.
+ *
+ * There is no return value.
+ */
+
+void gem_set_id_check1(GEM_DEVICE *mac, u32 id_check)
+{
+	*(volatile u32 *)(mac->registers + GEM_ID_CHECK1) = (id_check & 0xFFFF) | 0x80000000;
+}
+void gem_set_id_check2(GEM_DEVICE *mac, u32 id_check)
+{
+	*(volatile u32 *)(mac->registers + GEM_ID_CHECK2) = (id_check & 0xFFFF) | 0x80000000;
+}
+void gem_set_id_check3(GEM_DEVICE *mac, u32 id_check)
+{
+	*(volatile u32 *)(mac->registers + GEM_ID_CHECK3) = (id_check & 0xFFFF) | 0x80000000;
+}
+void gem_set_id_check4(GEM_DEVICE *mac, u32 id_check)
+{
+	*(volatile u32 *)(mac->registers + GEM_ID_CHECK4) = (id_check & 0xFFFF) | 0x80000000;
+}
+
+/*
+ * Get the value of the id-check registers in the MAC.
+ *
+ * Return value:
+ *  Value of ID check register.
+ */
+
+u32 gem_get_id_check1(GEM_DEVICE *mac)
+{
+	return *(volatile u32 *)(mac->registers + GEM_ID_CHECK1);
+}
+u32 gem_get_id_check2(GEM_DEVICE *mac)
+{
+	return *(volatile u32 *)(mac->registers + GEM_ID_CHECK2);
+}
+u32 gem_get_id_check3(GEM_DEVICE *mac)
+{
+	return *(volatile u32 *)(mac->registers + GEM_ID_CHECK3);
+}
+u32 gem_get_id_check4(GEM_DEVICE *mac)
+{
+	return *(volatile u32 *)(mac->registers + GEM_ID_CHECK4);
+}
+
+/*
+ * Set the hash register of the MAC.
+ * This register is used for matching unicast and multicast frames.
+ * The parameter of this function should be a pointer to type MAC_ADDR as
+ * defined in the header file.
+ *
+ * There is no return value.
+ */
+
+void gem_set_hash(GEM_DEVICE *mac, MAC_ADDR *hash_addr)
+{
+	*(volatile u32 *)(mac->registers + GEM_HASH_BOT) = hash_addr->bottom;
+	*(volatile u32 *)(mac->registers + GEM_HASH_TOP) = hash_addr->top;
+}
+
+/*
+ * Get the current value of the hash registers of the MAC.
+ *
+ * This function returns a value of type MAC_ADDR
+ */
+
+MAC_ADDR gem_get_hash(GEM_DEVICE *mac)
+{
+	MAC_ADDR addr;
+	addr.bottom = *(volatile u32 *)(mac->registers + GEM_HASH_BOT) ;
+	addr.top = *(volatile u32 *)(mac->registers + GEM_HASH_TOP) ;
+	return addr;
+}
+
+/*
+ * Set specific local addresses of the MAC.
+ * Rather than setting up all four specific addresses, this function sets them
+ * up individually.  The input parameter should be a pointer to type MAC_ADDR.
+ *
+ * There are no return values.
+ */
+
+void gem_set_laddr1(GEM_DEVICE *mac, MAC_ADDR *address)
+{
+	*(volatile u32 *)(mac->registers + GEM_LADDR1_BOT) = address->bottom;
+	*(volatile u32 *)(mac->registers + GEM_LADDR1_TOP) = address->top;
+}
+void gem_set_laddr2(GEM_DEVICE *mac, MAC_ADDR *address)
+{
+	*(volatile u32 *)(mac->registers + GEM_LADDR2_BOT) = address->bottom;
+	*(volatile u32 *)(mac->registers + GEM_LADDR2_TOP) = address->top;
+}
+void gem_set_laddr3(GEM_DEVICE *mac, MAC_ADDR *address)
+{
+	*(volatile u32 *)(mac->registers + GEM_LADDR3_BOT) = address->bottom;
+	*(volatile u32 *)(mac->registers + GEM_LADDR3_TOP) = address->top;
+}
+void gem_set_laddr4(GEM_DEVICE *mac, MAC_ADDR *address)
+{
+	*(volatile u32 *)(mac->registers + GEM_LADDR4_BOT) = address->bottom;
+	*(volatile u32 *)(mac->registers + GEM_LADDR4_TOP) = address->top;
+}
+
+/*
+ * Disable specific local addresses of the MAC.
+ */
+
+void gem_clear_laddr1(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_LADDR1_BOT) = 0;
+}
+void gem_clear_laddr2(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_LADDR2_BOT)  = 0;
+}
+void gem_clear_laddr3(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_LADDR3_BOT) = 0;
+}
+void gem_clear_laddr4(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_LADDR4_BOT) = 0;
+}
+
+/*
+ * Get specific local addresses of the MAC.
+ * This allows returning of a single specific address stored in the MAC.
+ *
+ * Return value if of type MAC_ADDR as defined in the header file.
+ */
+
+MAC_ADDR gem_get_laddr1(GEM_DEVICE *mac)
+{
+	MAC_ADDR addr;
+	addr.bottom = *(volatile u32 *)(mac->registers + GEM_LADDR1_BOT) ;
+	addr.top = *(volatile u32 *)(mac->registers + GEM_LADDR1_TOP) ;
+	return addr;
+}
+MAC_ADDR gem_get_laddr2(GEM_DEVICE *mac)
+{
+	MAC_ADDR addr;
+	addr.bottom = *(volatile u32 *)(mac->registers + GEM_LADDR2_BOT) ;
+	addr.top = *(volatile u32 *)(mac->registers + GEM_LADDR2_TOP) ;
+	return addr;
+}
+MAC_ADDR gem_get_laddr3(GEM_DEVICE *mac)
+{
+	MAC_ADDR addr;
+	addr.bottom = *(volatile u32 *)(mac->registers + GEM_LADDR3_BOT) ;
+	addr.top = *(volatile u32 *)(mac->registers + GEM_LADDR3_TOP) ;
+	return addr;
+}
+MAC_ADDR gem_get_laddr4(GEM_DEVICE *mac)
+{
+	MAC_ADDR addr;
+	addr.bottom = *(volatile u32 *)(mac->registers + GEM_LADDR3_BOT) ;
+	addr.top = *(volatile u32 *)(mac->registers + GEM_LADDR3_TOP) ;
+	return addr;
+}
+
+/*
+ * Reset the MAC device to its default value and load up the MAC address stored
+ * in the header file into specific address 1.  The MAC will be held in
+ * quiescent state.
+ * This function should be called to initialise and check the device prior to
+ * setting up the buffer queues and enabling the MAC.  If it is called mid way
+ * through operation, the MAC is reset to default value and any pending frames
+ * will be lost.
+ * Note that the values in the GEM_DEVICE software structure are not reset, only
+ * the MAC registers are reset.  This is to allow, if necessary to recover the
+ * buffers and reload them into the MAC, however prior to doing this, they
+ * should be cleared first.
+ *
+ * Return value:
+ *  0   :   OK
+ *  -1  :   Error in write/read check on initialisation.
+ */
+
+int gem_reset(GEM_DEVICE *mac)
+{
+	MAC_ADDR zero_address = {0x00000000, 0x00000000};
+	MAC_ADDR enet_address = zero_address;
+	u32 mdc_div;
+	u32 mdio_enable;
+
+
+	/* Write to registers and set default values but preserve MDIO settings
+	   which are controlled by a different driver */
+	mdio_enable = readl(mac->registers + GEM_NET_CONTROL) & GEM_MDIO_EN;
+	mdc_div = readl(mac->registers + GEM_NET_CONFIG) & GEM_MDC_DIV_MASK;
+
+	*(volatile u32 *)(mac->registers + GEM_NET_CONTROL) = GEM_STATS_CLR | mdio_enable;
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) = GEM_DEF_DUPLEX | mdc_div;
+
+	gem_set_loop(mac, GEM_DEF_LOOP);
+	gem_set_speed (mac, GEM_DEF_SPEED);
+#if !defined(CONFIG_ARCH_M83XXX)
+	gem_set_ahb_width(mac, GEM_DEF_AHB_WIDTH);
+#endif
+
+	*(volatile u32 *)(mac->registers + GEM_TX_STATUS) = 0xFFFFFFFF;
+	*(volatile u32 *)(mac->registers + GEM_RX_QPTR) = 0x00000000;
+#if !defined(CONFIG_ARCH_M83XXX)
+	*(volatile u32 *)(mac->registers + GEM_TX_QPTR) = 0x00000000;
+#endif
+	*(volatile u32 *)(mac->registers + GEM_RX_STATUS) = 0xFFFFFFFF;
+	*(volatile u32 *)(mac->registers + GEM_IRQ_DISABLE) = 0xFFFFFFFF;
+	*(volatile u32 *)(mac->registers + GEM_IRQ_STATUS) = 0x00000000;
+
+	gem_set_hash(mac, &zero_address);
+	gem_set_laddr1(mac, &enet_address);
+	gem_set_laddr2(mac, &zero_address);
+	gem_set_laddr3(mac, &zero_address);
+	gem_set_laddr4(mac, &zero_address);
+
+	/* Now read back values and return if not correct. */
+	if (
+		(*(volatile u32 *)(mac->registers + GEM_LADDR4_BOT) != zero_address.bottom) ||
+		(*(volatile u32 *)(mac->registers + GEM_LADDR4_TOP) != zero_address.top) ||
+		(*(volatile u32 *)(mac->registers + GEM_LADDR3_BOT) != zero_address.bottom) ||
+		(*(volatile u32 *)(mac->registers + GEM_LADDR3_TOP) != zero_address.top) ||
+		(*(volatile u32 *)(mac->registers + GEM_LADDR2_BOT) != zero_address.bottom) ||
+		(*(volatile u32 *)(mac->registers + GEM_LADDR2_TOP)  != zero_address.top) ||
+		(*(volatile u32 *)(mac->registers + GEM_LADDR1_BOT)  != enet_address.bottom) ||
+		(*(volatile u32 *)(mac->registers + GEM_LADDR1_TOP)  != enet_address.top) ||
+		(*(volatile u32 *)(mac->registers + GEM_HASH_BOT) != zero_address.bottom) ||
+		(*(volatile u32 *)(mac->registers + GEM_HASH_TOP) != zero_address.top) ||
+		(*(volatile u32 *)(mac->registers + GEM_IRQ_STATUS) != 0x00000000) ||
+		(*(volatile u32 *)(mac->registers + GEM_IRQ_MASK) != 0x0003FFFF) ||
+		(*(volatile u32 *)(mac->registers + GEM_RX_STATUS) != 0x00000000) ||
+#if !defined(CONFIG_ARCH_M83XXX)
+		(*(volatile u32 *)(mac->registers + GEM_TX_QPTR) != 0x00000000) ||
+#endif
+		(*(volatile u32 *)(mac->registers + GEM_RX_QPTR) != 0x00000000) ||
+		(*(volatile u32 *)(mac->registers + GEM_TX_STATUS) != 0x00000000)
+	  )
+		return -1;
+	else if (((*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) & GEM_FULL_DUPLEX) !=
+				(0x00000000 | GEM_DEF_DUPLEX)) ||
+			(gem_get_loop(mac) != GEM_DEF_LOOP)
+#if !defined(CONFIG_ARCH_M83XXX)
+			|| (gem_get_ahb_width(mac) != GEM_DEF_AHB_WIDTH)
+#endif
+		)
+		return -1;
+	else
+		return 0;
+}
+
+/*
+ * Enable length field checking feature.
+ * The length field check feature automatically discards frames that has a frame
+ * length smaller than that reported in the length field of the header.
+ *
+ * Note that in accordance with the IEEE spec, frames that are longer than that
+ * reported in length field is still accepted as a valid frame.
+ *
+ * This function has no return value.
+ */
+
+void gem_enable_len_check(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) |= GEM_RX_LEN_CHK;
+}
+
+/*
+ * Disable length field checking feature.
+ *
+ * This function has no return value.
+ */
+
+void gem_disable_len_check(GEM_DEVICE *mac)
+{
+	*(volatile u32 *)(mac->registers + GEM_NET_CONFIG) &= (~GEM_RX_LEN_CHK);
+}
+
+/*
+ * Convert standard byte style ethernet address to format compatible with MAC.
+ *
+ * Input    :   Pointer to beginning of 6 byte address.
+ *              Pointer to MAC_ADDR structure.
+ * Return values:
+ *  0   :   OK
+ *  -1  :   Invalid inputs.
+ */
+
+int gem_enet_addr_byte_mac(u8 *enet_byte_addr, MAC_ADDR *enet_addr)
+{
+	if ((enet_byte_addr == NULL) || (enet_addr == NULL))
+		return -1;
+	else {
+		enet_addr->bottom = enet_byte_addr[0] |
+			(enet_byte_addr[1] << 8) |
+			(enet_byte_addr[2] << 16) |
+			(enet_byte_addr[3] << 24);
+		enet_addr->top = enet_byte_addr[4] |
+			(enet_byte_addr[5] << 8);
+		return 0;
+	}
+}
+
+/*
+ * Convert MAC type ethernet address to standard byte style ethernet address.
+ *
+ * Input    :   Pointer to beginning of free space for 6 byte address.
+ *              Pointer to MAC_ADDR structure.
+ * Return values:
+ *  0   :   OK
+ *  -1  :   Invalid inputs.
+ */
+
+int gem_enet_addr_mac_byte(u8 *enet_byte_addr, MAC_ADDR *enet_addr)
+{
+	if ((enet_byte_addr == NULL) || (enet_addr == NULL))
+		return -1;
+	else {
+		enet_byte_addr[0] = enet_addr->bottom & 0xFF;
+		enet_byte_addr[1] = (enet_addr->bottom >> 8) & 0xFF;
+		enet_byte_addr[2] = (enet_addr->bottom >> 16) & 0xFF;
+		enet_byte_addr[3] = (enet_addr->bottom >> 24) & 0xFF;
+
+		enet_byte_addr[4] = enet_addr->top & 0xFF;
+		enet_byte_addr[5] = (enet_addr->top >> 8) & 0xFF;
+
+		return 0;
+	}
+}
+
diff --git a/drivers/net/comcerto/comcerto_gemac.h b/drivers/net/comcerto/comcerto_gemac.h
new file mode 100644
index 0000000..7930d0d
--- /dev/null
+++ b/drivers/net/comcerto/comcerto_gemac.h
@@ -0,0 +1,781 @@
+/*
+ *  linux/drivers/net/comcerto/comcerto_gemac.h
+ *
+ *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef _COMCERTO_GEMAC_H
+#define _COMCERTO_GEMAC_H
+
+#include <linux/io.h>
+#include <mach/hardware.h>
+
+#define CONFIG_COMCERTO_GEMAC	1
+#define COMCERTO_GEM_DELAY      2
+
+/* An enumerated type for loopback values.  This can be one of three values, no
+ * loopback -normal operation, local loopback with internal loopback module of
+ * MAC or PHY loopback which is through the external PHY.
+ */
+typedef enum {LB_NONE, LB_EXT, LB_LOCAL} MAC_LOOP;
+
+/* The possible operating speeds of the MAC, currently supporting 10, 100 and
+ * 1000Mb modes.
+ */
+typedef enum {SPEED_10M, SPEED_100M, SPEED_1000M, SPEED_1000M_PCS} MAC_SPEED;
+
+#if !defined(CONFIG_ARCH_M83XXX)
+/* The possible AMBA AHB bus width of the MAC, currently supporting 32, 64 and
+ * 128 bits.
+ */
+typedef enum {AMBA_AHB_32, AMBA_AHB_64, AMBA_AHB_128} MAC_AHB_WIDTH;
+
+/* Specify the default AMBA AHB bus width.  This simply defines
+ * which of the bus width control bits are active.  By default, the bus
+ * width is 32.
+ */
+#define GEM_DEF_AHB_WIDTH (AMBA_AHB_32)
+
+#endif
+
+#define GEM_HASH_REG_BITS	64
+/* Specify whether the MDIO should be available, this is set so that for reset
+ * function, appropriate options are setup.  To disable, use 0.
+ */
+#define GEM_MDIO_ENABLED (GEM_MDIO_EN)
+
+/* Specify default duplex mode, for half duplex - specify 0. */
+#ifndef GEM_DEF_DUPLEX
+/* Allow the value to be specified as compiler option
+   0 - half-duplex,
+   GEM_FULL_DUPLEX - full-duplex
+*/
+#define GEM_DEF_DUPLEX (GEM_FULL_DUPLEX)
+#endif
+
+/* Specify default operating speed, 1 for 100Mb.  Note that this is left
+ * shifted.  Also note that this simply asserts a signal to the PHY and has no
+ * effect on the operation of the MAC.
+ * For 10Mb/s mode, specify         SPEED_10M
+ * For 100Mb/s mode, specify        SPEED_100M
+ * For 1Gb/s mode, specify          SPEED_1000M
+ * For 1Gb/s with PCS mode, specify SPEED_1000M_PCS
+ */
+#ifndef GEM_DEF_SPEED
+/* Allow the value to be specified as compiler option */
+#define GEM_DEF_SPEED (SPEED_1000M)
+#endif
+
+/* Specify default loopback mode.  LB_NONE for no loopback,
+ * other values are LB_MAC and LB_PHY
+ */
+#define GEM_DEF_LOOP (LB_NONE)
+
+/*	GEMAC IP wrapper        */
+#define GEM_ARM_FIFO_CTRL		0x0000
+#define GEM_ARM_TX_FIFO_SIZE		0x0014
+#define GEM_ARM_RX_FIFO_SIZE		0x0024
+#define GEM_ARM_RX_FIFO_HIGH		0x0028
+#define GEM_ARM_RX_FIFO_LOW		0x002C
+
+#if defined(CONFIG_ARCH_M83XXX)
+#define GEM_ADM_BLOCK			0x4000
+/* admittance block */
+#define	ADM_STATUS			0x0
+#define	ADM_PKTDQ			0x4
+#define	ADM_CNFG			0x8
+#define	ADM_CONTROL			0xC
+#define ADM_QUEUEDEPTH		0x80
+#define	ADM_QFULLTHR		0x88
+#define	ADM_QDROPMAXTHR		0x8c
+#define	ADM_QDROPMINTHR		0x90
+#define	ADM_DECAYTIMER		0x98
+#define	ADM_BATCHINTRPKTCNT	0x100
+#define	ADM_BATCHINTRPKTTHRES	0x104
+#define	ADM_BATCHINTRTIMER	0x108
+#define	ADM_BATCHINTRTIMERINIT	0x10C
+#define	ADM_BATCHINTRSTAT	0x110
+
+#define GEM_ADM_BLOCK			0x4000
+#define GEM_SCH_BLOCK			0x8000
+
+#define SCH_STATUS			0x00
+#define SCH_CONTROL			0x04
+#define SCH_PACKET_QUEUED		0x08
+#define SCH_PORT_BYTE_COUNTER		0x0C
+#define SCH_PORT_PACKET_COUNTER		0x10
+#define SCH_PACKET_OVERHEAD		0x14
+#define SCH_HW_FAULT_STATUS		0x18
+#define SCH_HW_FAULT_MASK		0x1C
+#define SCH_PORT_SHAPER_QBYTES		0x40
+#define SCH_PORT_SHAPER_QPACKETS	0x44
+#define SCH_PORT_SHAPER_RATE			0x50
+#define SCH_PORT_SHAPER_MAx_CREDIT	0x54
+#define SCH_PORT_SHAPER_CREDIT		0x58
+#define SCH_PORT_SHAPER_CONTROL		0x5C
+#define SCH_GROUP_SHAPER_QBYTES		0x60
+#define SCH_GROUP_SHAPER_QPACKETS	0x64
+#define SCH_GROUP_SHAPER_RATE			0x70
+#define SCH_GROUP_SHAPER_MAx_CREDIT	0x74
+#define SCH_GROUP_SHAPER_CREDIT		0x78
+#define SCH_GROUP_SHAPER_CONTROL	0x7C
+#define SCH_IOB_BASE			0x80
+
+/* scheduler Queus */
+#define SCH_BYTES_Q0			0x80
+#define SCH_PACKETS_Q0			0x84
+#define SCH_IDLE_Q0			0x88
+#define SCH_BYTES_Q1			0xa0
+#define SCH_PACKETS_Q1			0xa4
+#define SCH_IDLE_Q1			0xa8
+#define SCH_BYTES_Q2			0xc0
+#define SCH_PACKETS_Q2			0xc4
+#define SCH_IDLE_Q2			0xc8
+#define SCH_BYTES_Q3			0xe0
+#define SCH_PACKETS_Q3			0xe4
+#define SCH_IDLE_Q3			0xe8
+#define SCH_BYTES_Q4			0x100
+#define SCH_PACKETS_Q4			0x104
+#define SCH_IDLE_Q4			0x108
+#define SCH_BYTES_Q5			0x120
+#define SCH_PACKETS_Q5			0x124
+#define SCH_IDLE_Q5			0x128
+#define SCH_BYTES_Q6			0x140
+#define SCH_PACKETS_Q6			0x144
+#define SCH_IDLE_Q6			0x148
+#define SCH_BYTES_Q7			0x160
+#define SCH_PACKETS_Q7			0x164
+#define SCH_IDLE_Q7			0x168
+
+#endif
+
+
+#define GEM_FIFO_CTRL			0xD000
+#define GEM_RX_FIFO_HIGH		0xD024
+#define GEM_RX_FIFO_LOW			0xD028
+#define GEM_IP				0xE000
+#define GEM_CFG				0xF000
+#define GEM_TX_CTRL			0xF004
+#define GEM_TX_COLL			0xF008
+#define GEM_RX_CTRL			0xF010
+#define GEM_RX_STAT_PKTSIZE		0xF014
+#define GEM_RX_STAT_FIFODEPTH		0xF018
+#define GEM_RX_STAT_FIFODATA		0xF01C
+
+
+#define DEFAULT_RX_STAT_PKTSIZE		0x100
+#define DEFAULT_TX_GEM_THR_LO		0x00D
+
+#if defined(CONFIG_ARCH_M822XX)
+#define DEFAULT_TX_GEM_THR_HI		0x1C0
+#else
+#define DEFAULT_TX_GEM_THR_HI		0x100
+#endif
+
+#define DEFAULT_RX_DMA_THR_LO		0x180
+#define DEFAULT_RX_DMA_THR_HI		0x1D0
+
+
+
+#define	GEM_FIFO_CTRL_TXFF_EN				(1 << 0)
+#define	GEM_FIFO_CTRL_HBTXRQ_EN				(1 << 1)
+#define	GEM_FIFO_CTRL_RXFF_EN				(1 << 3)
+#define	GEM_FIFO_CTRL_HBRXRQ_EN				(1 << 4)
+#define	GEM_FIFO_CTRL_TXCP_INH				(1 << 5)
+#define	GEM_FIFO_CTRL_RXCMPLTIE				(1 << 11)
+
+#if defined(CONFIG_ARCH_M83XXX)
+#define GEM_CONF_MODE_SEL_PIN				(0 << 0)
+#define GEM_CONF_MODE_SEL_GEM				(1 << 0)
+#define GEM_CONF_MODE_GEM_MASK				(7 << 1)
+#define GEM_CONF_MODE_GEM_RGMII				(0 << 1)
+#define GEM_CONF_MODE_GEM_RMII				(1 << 1)
+#define GEM_CONF_MODE_GEM_MII				(2 << 1)
+#define GEM_CONF_MODE_GEM_GMII				(3 << 1)
+#define GEM_CONF_MODE_PIN_MASK				(7 << 4)
+#define GEM_CONF_MODE_PIN_RGMII				(0 << 4)
+#define GEM_CONF_MODE_PIN_RMII				(1 << 4)
+#define GEM_CONF_MODE_PIN_MII				(2 << 4)
+#define GEM_CONF_MODE_PIN_GMII				(3 << 4)
+#define GEM_CONF_DUPLEX_SEL_PHY				(0 << 8)
+#define GEM_CONF_DUPLEX_SEL_GEM				(1 << 8)
+#define GEM_CONF_DUPLEX_GEM_HALF			(0 << 9)
+#define GEM_CONF_DUPLEX_GEM_FULL			(1 << 9)
+#define GEM_CONF_DUPLEX_PHY_HALF			(0 << 10)
+#define GEM_CONF_DUPLEX_PHY_FULL			(1 << 10)
+#define GEM_CONF_SPEED_SEL_PHY				(0 << 11)
+#define GEM_CONF_SPEED_SEL_GEM				(1 << 11)
+#define GEM_CONF_SPEED_MASK				(3 << 12)
+#define GEM_CONF_SPEED_GEM_10M				(0 << 12)
+#define GEM_CONF_SPEED_GEM_100M				(1 << 12)
+#define GEM_CONF_SPEED_GEM_1G				(2 << 12)
+#define GEM_CONF_SPEED_PHY_10M				(0 << 14)
+#define GEM_CONF_SPEED_PHY_100M				(1 << 14)
+#define GEM_CONF_SPEED_PHY_1G				(2 << 14)
+#define GEM_CONF_PHY_LINK_DOWN				(0 << 16)
+#define GEM_CONF_PHY_LINK_UP				(1 << 16)
+#define GEM_CONF_GEM_LOOPBACK				(1 << 17)
+#else
+#define GEM_CONF_MODE_SEL_PIN				(0 << 0)
+#define GEM_CONF_MODE_SEL_GEM				(1 << 0)
+#define GEM_CONF_MODE_GEM_MASK				(7 << 1)
+#define GEM_CONF_MODE_GEM_MII				(0 << 1)
+#define GEM_CONF_MODE_GEM_GMII				(1 << 1)
+#define GEM_CONF_MODE_GEM_RMII				(2 << 1)
+#define GEM_CONF_MODE_GEM_RGMII				(3 << 1)
+#define GEM_CONF_MODE_GEM_SMII				(6 << 1)
+#define GEM_CONF_MODE_PIN_MASK				(7 << 4)
+#define GEM_CONF_MODE_PIN_MII				(0 << 4)
+#define GEM_CONF_MODE_PIN_GMII				(1 << 4)
+#define GEM_CONF_MODE_PIN_RMII				(2 << 4)
+#define GEM_CONF_MODE_PIN_RGMII				(3 << 4)
+#define GEM_CONF_MODE_PIN_SMII				(6 << 4)
+#define GEM_CONF_DUPLEX_SEL_PHY				(0 << 8)
+#define GEM_CONF_DUPLEX_SEL_GEM				(1 << 8)
+#define GEM_CONF_DUPLEX_GEM_HALF			(0 << 9)
+#define GEM_CONF_DUPLEX_GEM_FULL			(1 << 9)
+#define GEM_CONF_DUPLEX_PHY_HALF			(0 << 10)
+#define GEM_CONF_DUPLEX_PHY_FULL			(1 << 10)
+#define GEM_CONF_SPEED_SEL_PHY				(0 << 11)
+#define GEM_CONF_SPEED_SEL_GEM				(1 << 11)
+#define GEM_CONF_SPEED_MASK				(3 << 12)
+#define GEM_CONF_SPEED_GEM_10M				(0 << 12)
+#define GEM_CONF_SPEED_GEM_100M				(1 << 12)
+#define GEM_CONF_SPEED_GEM_1G				(2 << 12)
+#define GEM_CONF_SPEED_PHY_10M				(0 << 14)
+#define GEM_CONF_SPEED_PHY_100M				(1 << 14)
+#define GEM_CONF_SPEED_PHY_1G				(2 << 14)
+#define GEM_CONF_PHY_LINK_DOWN				(0 << 16)
+#define GEM_CONF_PHY_LINK_UP				(1 << 16)
+#define GEM_CONF_GEM_LOOPBACK				(1 << 17)
+#endif
+
+#define GEM_TXCTRL_DMAIF_EN					(1 << 0)
+#define GEM_TXCTRL_CRC_EN					(1 << 1)
+#define GEM_TXCTRL_RETR_EN					(1 << 2)
+#define GEM_TXCTRL_TX_STATE					0xf0000
+
+
+#define GEM_RXCTRL_DMAIF_EN					(1 << 0)
+#define GEM_RXCTRL_RX_STATE					0xf0000
+
+
+/* Host fifo control bits */
+#define ARM_FIFO_RXDREQWE					(1 << 2)
+#define ARM_FIFO_TXDREQRE					(1 << 3)
+#define ARM_FIFO_TXFF_RES					(1 << 12)
+#define ARM_FIFO_RXFF_RES					(1 << 13)
+#define ARM_FIFO_RXCP_INH					(1 << 15)
+
+/* Define some bit positions for registers. */
+
+/* Bit positions for network control register */
+#define GEM_READ_SNAP       (1<<14)     /* Read snapshot register */
+#define GEM_TAKE_SNAP       (1<<13)     /* Take a snapshot */
+#define GEM_TX_0Q_PAUSE     (1<<12)     /* Transmit zero quantum pause frame */
+#define GEM_TX_PAUSE        (1<<11)     /* Transmit pause frame */
+#define GEM_TX_HALT         (1<<10)     /* Halt transmission after curr frame */
+#define GEM_TX_START        (1<<9)      /* Start tx (tx_go) */
+#define GEM_STATS_WR_EN     (1<<7)      /* Enable writing to stat registers */
+#define GEM_STATS_INC       (1<<6)      /* Increment statistic registers */
+#define GEM_STATS_CLR       (1<<5)      /* Clear statistic registers */
+#define GEM_MDIO_EN         (1<<4)      /* Enable MDIO port */
+#define GEM_TX_EN           (1<<3)      /* Enable transmit circuits */
+#define GEM_RX_EN           (1<<2)      /* Enable receive circuits */
+#define GEM_LB_MAC          (1<<1)      /* Perform local loopback at MAC */
+#define GEM_LB_PHY          (1<<0)      /* Perform ext loopback through PHY */
+
+/* Bit positions for network configuration register */
+#define GEM_RX_BAD_PREAMBLE (1<<29)     /* Receive frames with bad preamble */
+#define GEM_CKSUM_OFFLOAD   (1<<24)     /* Enable Checksum Engine*/
+#define GEM_RX_NO_PAUSE     (1<<23)     /* Do not copy pause frames to memory */
+#if defined(CONFIG_ARCH_M83XXX)
+#define GEM_ENABLE_L4_DROP      (1<<22)     /* Drop packets if error in L4 checksum */
+#define GEM_ENABLE_L4_CKSUM	(1<<21)     /* Enable L4 checksum check */
+#else
+#define GEM_AHB_WIDTH1      (1<<22)     /* Bit 1 for defining AHB width */
+#define GEM_AHB_WIDTH0      (1<<21)     /* Bit 0 for defining AHB width */
+#endif
+#define GEM_MDC_DIV_MASK    (0x7 << 18) /* PCLK divisor for MDC */
+#define GEM_RX_NO_FCS       (1<<17)     /* Discard FCS from received frames. */
+#define GEM_RX_LEN_CHK      (1<<16)     /* Receive length check. */
+#if defined(CONFIG_ARCH_M83XXX)
+#define GEM_ENABLE_L3_DROP      (1<<15)     /* Drop packets if error in L3 checksum */
+#define GEM_ENABLE_L3_CKSUM	(1<<14)     /* Enable L3 checksum check */
+#else
+#define GEM_RX_OFFSET_BASE  14          /* Pos of LSB for rx buffer offsets. */
+#define GEM_RX_OFFSET1      (1<<(GEM_RX_OFFSET_BASE + 1)) /* RX offset bit 1 */
+#define GEM_RX_OFFSET0      (1<<GEM_RX_OFFSET_BASE)       /* RX offset bit 0 */
+#endif
+#define GEM_RX_PAUSE_EN     (1<<13)     /* Enable pause reception */
+#define GEM_RETRY_TEST      (1<<12)     /* Retry test for speeding up debug */
+#define GEM_PCS_SEL         (1<<11)     /* Select PCS */
+#define GEM_GIG_MODE        (1<<10)     /* Gigabit mode enable */
+#define GEM_EAM_EN          (1<<9)      /* External address match enable */
+#define GEM_FRAME_1536      (1<<8)      /* Enable 1536 byte frames reception */
+#define GEM_UNICAST_EN      (1<<7)      /* Receive unicast hash frames */
+#define GEM_MULTICAST_EN    (1<<6)      /* Receive multicast hash frames */
+#define GEM_NO_BROADCAST    (1<<5)      /* Do not receive broadcast frames */
+#define GEM_COPY_ALL        (1<<4)      /* Copy all frames */
+#define GEM_RX_JUMBO        (1<<3)      /* Allow jumbo frame reception */
+#define GEM_VLAN_ONLY       (1<<2)      /* Receive only VLAN frames */
+#define GEM_FULL_DUPLEX     (1<<1)      /* Enable full duplex */
+#define GEM_SPEED_100       (1<<0)      /* Set to 100Mb mode */
+
+/* Bit positions for network status register */
+#define GEM_PHY_IDLE        (1<<2)      /* PHY management is idle */
+#define GEM_MDIO_IN         (1<<1)      /* Status of mdio_in pin */
+#define GEM_LINK_STATUS     (1<<0)      /* Status of link pin */
+
+#if defined(CONFIG_ARCH_M83XXX)
+/* Bit positions for dma configuration register */
+#define GEM_TX_CSUM_OFFLOAD	(1 << 11)
+#define GEM_RX_SW_ALLOC	(1<<25)
+#define GEM_TX_SW_ALLOC	(1<<26)
+
+#endif
+/* Bit positions for transmit status register */
+#define GEM_TX_HRESP        (1<<8)      /* Transmit hresp not OK */
+#define GEM_LATE_COL        (1<<7)      /* Late collision */
+#define GEM_TX_URUN         (1<<6)      /* Transmit underrun occurred */
+#define GEM_TX_COMPLETE     (1<<5)      /* Transmit completed OK */
+#define GEM_TX_BUF_EXH      (1<<4)      /* Transmit buffs exhausted mid frame */
+#define GEM_TX_GO           (1<<3)      /* Status of tx_go internal variable */
+#define GEM_TX_RETRY_EXC    (1<<2)      /* Retry limit exceeded */
+#define GEM_TX_COL          (1<<1)      /* Collision occurred during frame tx */
+#define GEM_TX_USED         (1<<0)      /* Used bit read in tx buffer */
+
+/* Bit positions for receive status register */
+#define GEM_RX_HRESP        (1<<3)      /* Receive hresp not OK */
+#define GEM_RX_ORUN         (1<<2)      /* Receive overrun occurred */
+#define GEM_RX_DONE         (1<<1)      /* Frame successfully received */
+#define GEM_RX_BUF_USED     (1<<0)      /* Receive buffer used bit read */
+
+/* Bit positions for interrupts */
+#define GEM_IRQ_PCS_AN      (1<<16)     /* PCS autonegotiation complete */
+#define GEM_IRQ_EXT_INT     (1<<15)     /* External interrupt pin triggered */
+#define GEM_IRQ_PAUSE_TX    (1<<14)     /* Pause frame transmitted */
+#define GEM_IRQ_PAUSE_0     (1<<13)     /* Pause time has reached zero */
+#define GEM_IRQ_PAUSE_RX    (1<<12)     /* Pause frame received */
+#define GEM_IRQ_HRESP       (1<<11)     /* hresp not ok */
+#define GEM_IRQ_RX_ORUN     (1<<10)     /* Receive overrun occurred */
+#define GEM_IRQ_PCS_LINK    (1<<9)      /* Status of PCS link changed */
+#define GEM_IRQ_TX_DONE     (1<<7)      /* Frame transmitted ok */
+#define GEM_IRQ_TX_ERROR    (1<<6)      /* Transmit err occurred or no buffers*/
+#define GEM_IRQ_RETRY_EXC   (1<<5)      /* Retry limit exceeded */
+#define GEM_IRQ_TX_URUN     (1<<4)      /* Transmit underrun occurred */
+#define GEM_IRQ_TX_USED     (1<<3)      /* Tx buffer used bit read */
+#define GEM_IRQ_RX_USED     (1<<2)      /* Rx buffer used bit read */
+#define GEM_IRQ_RX_DONE     (1<<1)      /* Frame received ok */
+#define GEM_IRQ_MAN_DONE    (1<<0)      /* PHY management operation complete */
+#define GEM_IRQ_ALL         (0xFFFFFFFF)/* Everything! */
+
+/* Transmit buffer descriptor status words bit positions. */
+#define GEM_TBQE_USED       (1<<31)     /* Used bit. */
+#define GEM_TBQE_WRAP       (1<<30)     /* Wrap bit */
+#define GEM_TBQE_RETRY_EXC  (1<<29)     /* Retry limit exceeded. */
+#define GEM_TBQE_URUN       (1<<28)     /* Transmit underrun occurred. */
+#define GEM_TBQE_BUF_EXH    (1<<27)     /* Buffers exhausted mid frame. */
+#define GEM_TBQE_LATE_COL   (1<<26)     /* Late collision. */
+#define GEM_TBQE_NO_CRC     (1<<16)     /* No CRC */
+#define GEM_TBQE_LAST_BUF   (1<<15)     /* Last buffer */
+#define GEM_TBQE_LEN_MASK   (0x3FFF)    /* Mask for length field */
+#define GEM_TX_MAX_LEN      (0x3FFF)    /* Maximum transmit length value */
+#define GEM_TBQE_DUMMY      (0x8000BFFF)/* Dummy value to check for free buffer*/
+/* Receive buffer descriptor status words bit positions. */
+#define GEM_RBQE_BROADCAST  (1<<31)     /* Broadcast frame */
+#define GEM_RBQE_MULTICAST  (1<<30)     /* Multicast hashed frame */
+#define GEM_RBQE_UNICAST    (1<<29)     /* Unicast hashed frame */
+#define GEM_RBQE_EXT_ADDR   (1<<28)     /* External address match */
+#define GEM_RBQE_SPEC_MATCH (1<<27)     /* Specific address matched */
+#define GEM_RBQE_SPEC_BASE  (25)        /* Pos for base of specific match */
+#define GEM_RBQE_SPEC_MAT1  (1<<(RBQE_SPEC_BASE + 1))
+#define GEM_RBQE_SPEC_MAT0  (1<<RBQE_SPEC_BASE)
+#define GEM_RBQE_TYPE_MATCH (1<<24)     /* Type ID matched */
+#define GEM_RBQE_TYPE_BASE  (22)        /* Position for base of type id match */
+#define GEM_RBQE_TYPE_MAT1  (1<<(RBQE_TYPE_BASE + 1))
+#define GEM_RBQE_TYPE_MAT0  (1<<RBQE_TYPE_BASE)
+#define GEM_RBQE_VLAN       (1<<21)     /* VLAN tagged */
+#define GEM_RBQE_PRIORITY   (1<<20)     /* Priority tagged */
+#define GEM_RBQE_VLAN_BASE  (17)        /* Position for base of VLAN priority */
+#define GEM_RBQE_VLAN_P2    (1<<(RBQE_VLAN_BASE+2))
+#define GEM_RBQE_VLAN_P1    (1<<(RBQE_VLAN_BASE+1))
+#define GEM_RBQE_VLAN_P0    (1<<RBQE_VLAN_BASE)
+#define GEM_RBQE_CFI        (1<<16)     /* CFI frame */
+#define GEM_RBQE_EOF        (1<<15)     /* End of frame. */
+#define GEM_RBQE_SOF        (1<<14)     /* Start of frame. */
+#define GEM_RBQE_LEN_MASK   (0x3FFF)    /* Mask for the length field. */
+#define GEM_RBQE_WRAP       (1<<1)      /* Wrap bit.. */
+#define GEM_RBQE_USED       (1<<0)      /* Used bit.. */
+#define GEM_RBQE_ADD_MASK   (0xFFFFFFFC)/* Mask for address */
+
+/* Revision ID Register */
+#define GEM_REV_ID_MODEL_MASK   (0x000F0000)    /* Model ID */
+#define GEM_REV_ID_MODEL_BASE   (16)            /* For Shifting */
+#define GEM_REV_ID_REG_MODEL    (0x00020000)    /* GEM module ID */
+#define GEM_REV_ID_REV_MASK     (0x0000FFFF)    /* Revision ID */
+
+/* Define some memory offsets for easier direct access to memory map. */
+#define GEM_NET_CONTROL         (0x00)
+#define GEM_NET_CONFIG          (0x04)
+#define GEM_NET_STATUS          (0x08)
+#define GEM_USER_IO             (0x0C)
+#if defined(CONFIG_ARCH_M83XXX)
+#define GEM_DMA_CONFIG		(0x10)
+#endif
+#define GEM_TX_STATUS           (0x14)
+#define GEM_RX_QPTR             (0x18)
+#if defined(CONFIG_ARCH_M83XXX)
+#define	GEM_RX_OFFSET		(0x1C)
+#else
+#define GEM_TX_QPTR             (0x1C)
+#endif
+#define GEM_RX_STATUS           (0x20)
+#define GEM_IRQ_STATUS          (0x24)
+#define GEM_IRQ_ENABLE          (0x28)
+#define GEM_IRQ_DISABLE         (0x2C)
+#define GEM_IRQ_MASK            (0x30)
+#define GEM_PHY_MAN             (0x34)
+#define GEM_RX_PAUSE_TIME       (0x38)
+#define GEM_TX_PAUSE_QUANT      (0x3C)
+
+#define GEM_HASH_BOT            (0x80)
+#define GEM_HASH_TOP            (0x84)
+#define GEM_LADDR1_BOT          (0x88)
+#define GEM_LADDR1_TOP          (0x8C)
+#define GEM_LADDR2_BOT          (0x90)
+#define GEM_LADDR2_TOP          (0x94)
+#define GEM_LADDR3_BOT          (0x98)
+#define GEM_LADDR3_TOP          (0x9C)
+#define GEM_LADDR4_BOT          (0xA0)
+#define GEM_LADDR4_TOP          (0xA4)
+#define GEM_ID_CHECK1           (0xA8)
+#define GEM_ID_CHECK2           (0xAC)
+#define GEM_ID_CHECK3           (0xB0)
+#define GEM_ID_CHECK4           (0xB4)
+#define GEM_REV_ID              (0xFC)
+
+#define GEM_OCT_TX_BOT          (0x100)
+#define GEM_OCT_TX_TOP          (0x104)
+#define GEM_STATS_FRAMES_TX     (0x108)
+#define GEM_BROADCAST_TX        (0x10C)
+#define GEM_MULTICAST_TX        (0x110)
+#define GEM_STATS_PAUSE_TX      (0x114)
+#define GEM_FRAME64_TX          (0x118)
+#define GEM_FRAME65_TX          (0x11C)
+#define GEM_FRAME128_TX         (0x120)
+#define GEM_FRAME256_TX         (0x124)
+#define GEM_FRAME512_TX         (0x128)
+#define GEM_FRAME1024_TX        (0x12C)
+#define GEM_FRAME1519_TX        (0x130)
+#define GEM_STATS_TX_URUN       (0x134)
+#define GEM_STATS_SINGLE_COL    (0x138)
+#define GEM_STATS_MULTI_COL     (0x13C)
+#define GEM_STATS_EXCESS_COL    (0x140)
+#define GEM_STATS_LATE_COL      (0x144)
+#define GEM_STATS_DEF_TX        (0x148)
+#define GEM_STATS_CRS_ERRORS    (0x14C)
+#define GEM_OCT_RX_BOT          (0x150)
+#define GEM_OCT_RX_TOP          (0x154)
+#define GEM_STATS_FRAMES_RX     (0x158)
+#define GEM_BROADCAST_RX        (0x15C)
+#define GEM_MULTICAST_RX        (0x160)
+#define GEM_STATS_PAUSE_RX      (0x164)
+#define GEM_FRAME64_RX          (0x168)
+#define GEM_FRAME65_RX          (0x16C)
+#define GEM_FRAME128_RX         (0x170)
+#define GEM_FRAME256_RX         (0x174)
+#define GEM_FRAME512_RX         (0x178)
+#define GEM_FRAME1024_RX        (0x17C)
+#define GEM_FRAME1519_RX        (0x180)
+#define GEM_STATS_USIZE_FRAMES  (0x184)
+#define GEM_STATS_EXCESS_LEN    (0x188)
+#define GEM_STATS_JABBERS       (0x18C)
+#define GEM_STATS_FCS_ERRORS    (0x190)
+#define GEM_STATS_LENGTH_ERRORS (0x194)
+#define GEM_STATS_RX_SYM_ERR    (0x198)
+#define GEM_STATS_ALIGN_ERRORS  (0x19C)
+#define GEM_STATS_RX_RES_ERR    (0x1a0)
+#define GEM_STATS_RX_ORUN       (0x1a4)
+
+#define GEM_REG_TOP             (0x23C)
+
+#if defined(CONFIG_ARCH_M83XXX)
+#define	GEM_QUEUE_BASE0		(0x300)
+#define	GEM_QUEUE_BASE1		(0x304)
+#define	GEM_QUEUE_BASE2		(0x308)
+#define	GEM_QUEUE_BASE3		(0x30C)
+#define	GEM_QUEUE_BASE4		(0x310)
+#define	GEM_QUEUE_BASE5		(0x314)
+#define	GEM_QUEUE_BASE6		(0x318)
+#define	GEM_QUEUE_BASE7		(0x31C)
+
+#define GEM_ID_CHECK5           (0x320)
+#define GEM_ID_CHECK6           (0x324)
+#define GEM_ID_CHECK7           (0x328)
+#define GEM_ID_CHECK8           (0x32C)
+
+#define	GEM_SCH_PKT_QUEUED	(0x8008)
+#endif
+
+/* Define some types for using with the HAL.  These types correspond to the
+ * memory map and programming structure of the MAC device.
+ * All structures are 'volatile' to indicate they can be changed by some non-
+ * programming means - i.e. by the hardware itself.  This prevents the compiler
+ * from making false assumptions on how to optimise the code.  Some elements
+ * are also defined as 'const' to enforce some checks on the programmer.  These
+ * are only for register fields that can only be changed by the hardware and are
+ * not writable.
+ */
+
+
+/* The Address organisation for the MAC device.  All addresses are split into
+ * two 32-bit register fields.  The first one (bottom) is the lower 32-bits of
+ * the address and the other field are the high order bits - this may be 16-bits
+ * in the case of MAC addresses, or 32-bits for the hash address.
+ * In terms of memory storage, the first item (bottom) is assumed to be at a
+ * lower address location than 'top'. i.e. top should be at address location of
+ * 'bottom' + 4 bytes.
+ */
+typedef struct {
+   u32  bottom;     /* Lower 32-bits of address. */
+   u32  top;        /* Upper 32-bits of address. */
+} volatile MAC_ADDR;
+
+#define MAC_ADDR_LEN 6
+
+/* The set of statistics registers implemented in the Cadence MAC.
+ * The statistics registers implemented are a subset of all the statistics
+ * available, but contains all the compulsory ones.
+ * For full descriptions on the registers, refer to the Cadence MAC programmers
+ * guide or the IEEE 802.3 specifications.
+ */
+typedef struct gem_stats{
+    u32 octets_tx_bot;      /* Lower 32-bits for number of octets tx'd */
+    u32 octets_tx_top;      /* Upper 16-bits for number of octets tx'd */
+    u32 frames_tx;          /* Number of frames transmitted OK */
+    u32 broadcast_tx;       /* Number of broadcast frames transmitted */
+    u32 multicast_tx;       /* Number of multicast frames transmitted */
+    u32 pause_tx;           /* Number of pause frames transmitted. */
+    u32 frame64_tx;         /* Number of 64byte frames transmitted */
+    u32 frame65_127_tx;     /* Number of 65-127 byte frames transmitted */
+    u32 frame128_255_tx;    /* Number of 128-255 byte frames transmitted */
+    u32 frame256_511_tx;    /* Number of 256-511 byte frames transmitted */
+    u32 frame512_1023_tx;   /* Number of 512-1023 byte frames transmitted */
+    u32 frame1024_1518_tx;  /* Number of 1024-1518 byte frames transmitted*/
+    u32 frame1519_tx;       /* Number of frames greater than 1518 bytes tx*/
+    u32 tx_urun;            /* Transmit underrun errors due to DMA */
+    u32 single_col;         /* Number of single collision frames */
+    u32 multi_col;          /* Number of multi collision frames */
+    u32 excess_col;         /* Number of excessive collision frames. */
+    u32 late_col;           /* Collisions occuring after slot time */
+    u32 def_tx;             /* Frames deferred due to crs */
+    u32 crs_errors;         /* Errors caused by crs not being asserted. */
+    u32 octets_rx_bot;      /* Lower 32-bits for number of octets rx'd */
+    u32 octets_rx_top;      /* Upper 16-bits for number of octets rx'd */
+    u32 frames_rx;          /* Number of frames received OK */
+    u32 broadcast_rx;       /* Number of broadcast frames received */
+    u32 multicast_rx;       /* Number of multicast frames received */
+    u32 pause_rx;           /* Number of pause frames received. */
+    u32 frame64_rx;         /* Number of 64byte frames received */
+    u32 frame65_127_rx;     /* Number of 65-127 byte frames received */
+    u32 frame128_255_rx;    /* Number of 128-255 byte frames received */
+    u32 frame256_511_rx;    /* Number of 256-511 byte frames received */
+    u32 frame512_1023_rx;   /* Number of 512-1023 byte frames received */
+    u32 frame1024_1518_rx;  /* Number of 1024-1518 byte frames received*/
+    u32 frame1519_rx;       /* Number of frames greater than 1518 bytes rx*/
+    u32 usize_frames;       /* Frames received less than min of 64 bytes */
+    u32 excess_length;      /* Number of excessive length frames rx */
+    u32 jabbers;            /* Excessive length + crc or align errors. */
+    u32 fcs_errors;         /* Number of frames received with crc errors */
+    u32 length_check_errors;/* Number of frames with incorrect length */
+    u32 rx_symbol_errors;   /* Number of times rx_er asserted during rx */
+    u32 align_errors;       /* Frames received without integer no. bytes */
+    u32 rx_res_errors;      /* Number of times buffers ran out during rx */
+    u32 rx_orun;            /* Receive overrun errors due to DMA */
+    u32 ip_cksum;           /* IP header checksum errors */
+    u32 tcp_cksum;           /* TCP checksum errors */
+    u32 udp_cksum;           /* UDP checksum errors */
+} volatile GEM_STATS;
+
+#define GEMAC_RMON_LEN (sizeof(struct gem_stats)/sizeof(u32))
+
+
+/* This is a structure that will be passed and used for all HAL operations, it
+ * consists of pointers to the various MAC structures such as the MAC register
+ * block and the first descriptor element for the rx and tx buffer queues.
+ * Other internal variables declared for use in function calls and to keep track
+ * of where things are.
+ */
+typedef struct {
+	void	*registers;	/* Pointer to the MAC address space. */
+	void	*gemac_baseaddr;
+} GEM_DEVICE;
+
+/*
+ * Prototypes for functions of HAL
+*/
+
+
+/* Re-initialise device and check reset values. */
+int gem_reset(GEM_DEVICE *mac);
+
+/* Device setup. */
+
+void gem_set_loop(GEM_DEVICE *mac, MAC_LOOP gem_loop);
+MAC_LOOP gem_get_loop(GEM_DEVICE *mac);
+
+
+void gem_enable_eam(GEM_DEVICE *mac);
+void gem_disable_eam(GEM_DEVICE *mac);
+
+void gem_enable_fcs_rx(GEM_DEVICE *mac);
+void gem_disable_fcs_rx(GEM_DEVICE *mac);
+
+void gem_enable_1536_rx(GEM_DEVICE *mac);
+void gem_disable_1536_rx(GEM_DEVICE *mac);
+
+void gem_full_duplex(GEM_DEVICE *mac);
+void gem_half_duplex(GEM_DEVICE *mac);
+
+void gem_set_speed(GEM_DEVICE *mac, MAC_SPEED gem_speed);
+MAC_SPEED gem_get_speed(GEM_DEVICE *mac);
+
+#if !defined(CONFIG_ARCH_M83XXX)
+void gem_set_ahb_width(GEM_DEVICE *mac, MAC_AHB_WIDTH gem_buswidth);
+MAC_AHB_WIDTH gem_get_ahb_width(GEM_DEVICE *mac);
+#endif
+
+/* Pause control. */
+void gem_enable_pause_rx(GEM_DEVICE *mac);
+void gem_disable_pause_rx(GEM_DEVICE *mac);
+
+void gem_enable_rx_checksum_offload(GEM_DEVICE *mac);
+void gem_disable_rx_checksum_offload(GEM_DEVICE *mac);
+void gem_enable_tx_checksum_offload(GEM_DEVICE *mac);
+void gem_disable_tx_checksum_offload(GEM_DEVICE *mac);
+
+u32 gem_pause_time(GEM_DEVICE *mac);
+
+void gem_enable_pause_cpy(GEM_DEVICE *mac);
+void gem_disable_pause_cpy(GEM_DEVICE *mac);
+
+void gem_send_0q_pause(GEM_DEVICE *mac);
+void gem_send_pause(GEM_DEVICE *mac);
+
+void gem_set_tx_pause_q(GEM_DEVICE *mac, u32 gem_pause);
+u32 gem_get_tx_pause_q(GEM_DEVICE *mac);
+
+/* Address setup and control. */
+void gem_enable_unicast(GEM_DEVICE *mac);
+void gem_disable_unicast(GEM_DEVICE *mac);
+
+void gem_enable_multicast(GEM_DEVICE *mac);
+void gem_disable_multicast(GEM_DEVICE *mac);
+
+void gem_allow_broadcast(GEM_DEVICE *mac);
+void gem_no_broadcast(GEM_DEVICE *mac);
+
+void gem_enable_copy_all(GEM_DEVICE *mac);
+void gem_disable_copy_all(GEM_DEVICE *mac);
+
+void gem_set_hash(GEM_DEVICE *mac, MAC_ADDR *hash_addr);
+MAC_ADDR gem_get_hash(GEM_DEVICE *mac);
+
+int gem_add_arc_entry(GEM_DEVICE *gemdev, char *MAC_address);
+
+
+/* Functions to convert between address formats. */
+int gem_enet_addr_byte_mac(u8 *enet_byte_addr, MAC_ADDR *enet_addr);
+int gem_enet_addr_mac_byte(u8 *enet_byte_addr, MAC_ADDR *enet_addr);
+
+void gem_set_laddr1(GEM_DEVICE *mac, MAC_ADDR *address);
+void gem_set_laddr2(GEM_DEVICE *mac, MAC_ADDR *address);
+void gem_set_laddr3(GEM_DEVICE *mac, MAC_ADDR *address);
+void gem_set_laddr4(GEM_DEVICE *mac, MAC_ADDR *address);
+void gem_clear_laddr1(GEM_DEVICE *mac);
+void gem_clear_laddr2(GEM_DEVICE *mac);
+void gem_clear_laddr3(GEM_DEVICE *mac);
+void gem_clear_laddr4(GEM_DEVICE *mac);
+
+MAC_ADDR gem_get_laddr1(GEM_DEVICE *mac);
+MAC_ADDR gem_get_laddr2(GEM_DEVICE *mac);
+MAC_ADDR gem_get_laddr3(GEM_DEVICE *mac);
+MAC_ADDR gem_get_laddr4(GEM_DEVICE *mac);
+
+void gem_set_id_check1(GEM_DEVICE *mac, u32 id_check);
+void gem_set_id_check2(GEM_DEVICE *mac, u32 id_check);
+void gem_set_id_check3(GEM_DEVICE *mac, u32 id_check);
+void gem_set_id_check4(GEM_DEVICE *mac, u32 id_check);
+u32 gem_get_id_check1(GEM_DEVICE *mac);
+u32 gem_get_id_check2(GEM_DEVICE *mac);
+u32 gem_get_id_check3(GEM_DEVICE *mac);
+u32 gem_get_id_check4(GEM_DEVICE *mac);
+
+void gem_enable_len_check(GEM_DEVICE *mac);
+void gem_disable_len_check(GEM_DEVICE *mac);
+
+/* Interrupt handling and masking. */
+void gem_set_irq_stat(GEM_DEVICE *mac, u32 irq_status);
+u32 gem_get_irq_stat(GEM_DEVICE *mac);
+
+void gem_enable_irq(GEM_DEVICE *mac, u32 irq_en);
+void gem_mask_irq(GEM_DEVICE *mac, u32 irq_mask);
+u32 gem_get_irq_mask(GEM_DEVICE *mac);
+
+/* Transmit control. */
+int gem_enable_tx(GEM_DEVICE *mac);
+void gem_disable_tx(GEM_DEVICE *mac);
+int gem_start_tx(GEM_DEVICE *mac);
+void gem_stop_tx(GEM_DEVICE *mac) ;
+void gem_abort_tx(GEM_DEVICE *mac);
+int gem_restart_tx(GEM_DEVICE *mac);
+int gem_transmitting(GEM_DEVICE *mac);
+u32 gem_get_tx_stat(GEM_DEVICE *mac);
+void gem_reset_tx_stat(GEM_DEVICE *mac, u32 rst_status);
+void gem_reset_tx_q(GEM_DEVICE *mac);
+
+/* Receive control. */
+int gem_enable_rx(GEM_DEVICE *mac);
+void gem_disable_rx(GEM_DEVICE *mac);
+#if defined(CONFIG_ARCH_M83XXX)
+int gem_set_rx_offset(GEM_DEVICE *mac, unsigned short offset);
+#endif
+void gem_reset_rx_q(GEM_DEVICE *mac);
+
+int gem_receive_on(GEM_DEVICE *mac);
+u32 gem_get_rx_stat(GEM_DEVICE *mac);
+void gem_reset_rx_stat(GEM_DEVICE *mac, u32 rst_status);
+
+void gem_enable_rx_jmb(GEM_DEVICE *mac);
+void gem_disable_rx_jmb(GEM_DEVICE *mac);
+
+void gem_enable_vlan_only(GEM_DEVICE *mac);
+void gem_disable_vlan_only(GEM_DEVICE *mac);
+
+/* Snapshot of statistic registers */
+void gem_enable_rd_snap(GEM_DEVICE *mac);
+void gem_disable_rd_snap(GEM_DEVICE *mac);
+void gem_take_snap(GEM_DEVICE *mac);
+
+void gem_enable_bp(GEM_DEVICE *mac);
+void gem_disable_bp(GEM_DEVICE *mac);
+
+void gem_en_retry_test(GEM_DEVICE *mac);
+void gem_dis_retry_test(GEM_DEVICE *mac);
+
+#endif /* __GEMAC_H__ */
-- 
1.5.4.3

