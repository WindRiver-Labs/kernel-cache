From 605c16fe378d2916c7ead3ab6f71ee0d2b5d4b7e Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Sun, 26 Sep 2010 17:04:20 +0800
Subject: [PATCH 24/26] Comcerto: spi2: Add bcm53115m chip support.

Original codes came from Mindspeed's vendor drop sdk-comcerto-openwrt-6.0.

bcm53115m is a Ethernet switch, and it is a client of spi2 bus too.

Integrated-by: Stanley.Miao <stanley.miao@windriver.com>
---
 drivers/spi2/Kconfig                |    1 +
 drivers/spi2/Makefile               |    2 +-
 drivers/spi2/chips/Kconfig          |    8 +
 drivers/spi2/chips/Makefile         |    3 +
 drivers/spi2/chips/bcm53115m.h      |   61 ++
 drivers/spi2/chips/bcm53115m_itf.c  |  351 +++++++++++
 drivers/spi2/chips/bcm53115m_main.c | 1104 +++++++++++++++++++++++++++++++++++
 drivers/spi2/chips/bcm53115m_regs.h |  110 ++++
 8 files changed, 1639 insertions(+), 1 deletions(-)
 create mode 100644 drivers/spi2/chips/Kconfig
 create mode 100644 drivers/spi2/chips/Makefile
 create mode 100644 drivers/spi2/chips/bcm53115m.h
 create mode 100644 drivers/spi2/chips/bcm53115m_itf.c
 create mode 100644 drivers/spi2/chips/bcm53115m_main.c
 create mode 100644 drivers/spi2/chips/bcm53115m_regs.h

diff --git a/drivers/spi2/Kconfig b/drivers/spi2/Kconfig
index 56db7f5..2526de4 100644
--- a/drivers/spi2/Kconfig
+++ b/drivers/spi2/Kconfig
@@ -10,6 +10,7 @@ config SPI_MSPD
 	  Mindspeed SPI (Serial Pheripheral Interface bus) core support
 
 source drivers/spi2/busses/Kconfig
+source drivers/spi2/chips/Kconfig
 
 endmenu
 
diff --git a/drivers/spi2/Makefile b/drivers/spi2/Makefile
index cf3456f..dedcb81 100644
--- a/drivers/spi2/Makefile
+++ b/drivers/spi2/Makefile
@@ -3,5 +3,5 @@
 #
 
 obj-$(CONFIG_SPI_MSPD) += spi-core.o
-obj-y		  += busses/
+obj-y		  += busses/ chips/
 
diff --git a/drivers/spi2/chips/Kconfig b/drivers/spi2/chips/Kconfig
new file mode 100644
index 0000000..cb304d6
--- /dev/null
+++ b/drivers/spi2/chips/Kconfig
@@ -0,0 +1,8 @@
+
+menu "SPI devices support"
+	depends on SPI_MSPD
+
+config SPI_BCM53115M
+	tristate "BCM53115M"
+	depends on SPI_MSPD
+endmenu
diff --git a/drivers/spi2/chips/Makefile b/drivers/spi2/chips/Makefile
new file mode 100644
index 0000000..328f275
--- /dev/null
+++ b/drivers/spi2/chips/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_SPI_BCM53115M)        += bcm53115m.o
+
+bcm53115m-objs := bcm53115m_main.o bcm53115m_itf.o
diff --git a/drivers/spi2/chips/bcm53115m.h b/drivers/spi2/chips/bcm53115m.h
new file mode 100644
index 0000000..d97135b
--- /dev/null
+++ b/drivers/spi2/chips/bcm53115m.h
@@ -0,0 +1,61 @@
+/*
+ * bcm53115m.h
+ *
+ * Copyright (C) Mindspeed Technologies
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef __BCM53115M_H__
+#define __BCM53115M_H__
+
+#include <linux/version.h>
+#include <asm/system.h>
+#include <linux/timer.h>
+#include <linux/spi2/spi.h>
+#include <linux/workqueue.h>
+
+#include "bcm53115m_regs.h"
+
+#define BCM53115M_DRIVER_NAME "bcm53115"
+#define BCM53115M_DRIVER_VERSION "$Name: bcm53115m_2_00_1 $"
+
+#define BCM53115M_PHY_POLL_GAP 1  /* Polling PHYs gap in seconds */
+
+#ifdef BCM53115M_DEBUG
+#define BCM53115M_debug(str, args...) printk(KERN_INFO str, ## args)
+#else
+#define BCM53115M_debug(str, args...)
+#endif
+#define BCM53115M_info(str, args...) printk(KERN_INFO str, ## args)
+#define BCM53115M_err(str, args...) printk(KERN_ERR str, ## args)
+
+struct bcm53115m_phy_state {
+	enum { LINK_DOWN = 0, LINK_UP} link_state;
+	enum { LINK_10MB, LINK_100MB, LINK_1000MB} link_speed;
+	enum { LINK_HALF_DUPLEX, LINK_FULL_DUPLEX} link_duplex;
+};
+
+struct bcm53115m_data {
+	struct spi_client client;
+	struct bcm53115m_phy_state phy_state[5];
+	u32 mii_base_addr;
+	u32 spi_if_enabled;
+	struct delayed_work watchdog_task;
+	unsigned char vlan_mode;
+	unsigned int port[6];
+	unsigned int pvlan_id[6];
+#ifdef CONFIG_PM
+	u32                        suspend;
+#endif
+};
+
+int bcm53115m_read(struct spi_client *client, u8 page_num, u8 addr, void *data,  u8 size);
+int bcm53115m_write(struct spi_client *client, u8 page_num, u8 addr, void *data, u8 size);
+int bcm53115m_mii_read(struct bcm53115m_data *bcm, u8 page_num, u8 addr, void *data,  u8 size);
+int bcm53115m_mii_write(struct bcm53115m_data *bcm, u8 page_num, u8 addr, void *data, u8 size);
+#endif
+
diff --git a/drivers/spi2/chips/bcm53115m_itf.c b/drivers/spi2/chips/bcm53115m_itf.c
new file mode 100644
index 0000000..6d700d2
--- /dev/null
+++ b/drivers/spi2/chips/bcm53115m_itf.c
@@ -0,0 +1,351 @@
+
+/*
+ *  bcm53115m_itf.c
+ *
+ *  Copyright (C) Mindspeed Technologies
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/io.h>
+#include <mach/hardware.h>
+#include <mach/memory.h>
+#include <asm/sizes.h>
+#include <linux/uaccess.h>
+
+
+#include "bcm53115m.h"
+static int prev_page_num = -1;
+static int c1k_gmac_mii_write(u32 base_addr, int phyAd, int regnum, u16 value);
+static int c1k_gmac_mii_read(u32 base_addr, int phyAd, int regnum);
+
+/*
+ * bcm53115m_write
+ *
+ */
+int bcm53115m_write(struct spi_client *client, u8 page_num, u8 addr, void *vdata, u8 size)
+{
+	u8 wdata[16];
+	u8 rdata[8];
+	u8 *data = (u8 *)vdata;
+	u32 retry = 0;
+
+	do {
+		rdata[0] = 0;
+		rdata[1] = 0;
+		rdata[2] = 0;
+		rdata[3] = 0;
+		/* Poll the SPIF bit of SPI Status register to start the new opretion */
+		wdata[0] = 0x60;
+		wdata[1] = 0xFE;
+		wdata[2] = 0x00;
+		wdata[3] = 0x00;
+
+		spi_writeread_mem(client, 8, rdata, 4, wdata, 4);
+
+		if (retry++ > 100) {
+			BCM53115M_err("%s : Switch register read Failed, SPIF bit not cleared\n", __func__);
+			return 1;
+		}
+	} while (rdata[3] & BCM_SPIIF_STAT_SPIF);
+
+	/* If previous accessed page is not same as current, write the page numger register */
+	if (prev_page_num != page_num) {
+		wdata[0] = 0x61;
+		wdata[1] = 0xFF;
+		wdata[2] = page_num;
+		spi_write_mem(client, 8, wdata, 3);
+		prev_page_num = page_num;
+	}
+
+	/* Now write the data into register */
+	wdata[0] = 0x61;
+	wdata[1] = addr;
+	memcpy(&wdata[2], &data[0], size);
+	spi_write_mem(client, 8, wdata, size + 2);
+
+	return 0;
+}
+
+
+/*
+ * bcm53115m_read
+ *
+ */
+int bcm53115m_read(struct spi_client *client, u8 page_num, u8 addr, void *vdata, u8 size)
+{
+	u8 wdata[8];
+	u8 rdata[8];
+	u8 *data = (u8 *)vdata;
+	u32 retry = 0;
+	u8 i;
+
+	do {
+		rdata[0] = 0;
+		rdata[1] = 0;
+		rdata[2] = 0;
+		rdata[3] = 0;
+		/* Poll the SPIF bit of SPI Status register to start the new opretion */
+		wdata[0] = 0x60;
+		wdata[1] = 0xFE;
+		wdata[2] = 0x00; /* Dummy to keep cs active during read */
+		wdata[3] = 0x00; /* Dummy to keep cs active during read */
+
+		spi_writeread_mem(client, 8, rdata, 4, wdata, 4);
+
+		if (retry++ > 100) {
+			BCM53115M_err("%s : Switch register read Failed, SPIF bit not cleared\n", __func__);
+			return 1;
+		}
+	} while (rdata[3] & BCM_SPIIF_STAT_SPIF);
+
+
+	/* If previous accessed page is not same as current, write the page numger register */
+	if (prev_page_num != page_num) {
+		wdata[0] = 0x61;
+		wdata[1] = 0xFF;
+		wdata[2] = page_num;
+		spi_write_mem(client, 8, wdata, 3);
+		prev_page_num = page_num;
+	}
+
+	/* Now read the actual register */
+	rdata[0] = 0;
+	rdata[1] = 0;
+	rdata[2] = 0;
+	rdata[3] = 0;
+	/* issue a read command to register and read a dummy byte and discard it */
+	wdata[0] = 0x60;
+	wdata[1] = addr;
+	wdata[2] = 0x00; /* Dummy to keep cs active during read */
+	wdata[3] = 0x00; /* Dummy to keep cs active during read */
+	spi_writeread_mem(client, 8, rdata, 4, wdata, 4);
+
+	retry = 0;
+	/* Read status register and wait for ack bit */
+	do {
+		rdata[0] = 0;
+		rdata[1] = 0;
+		rdata[2] = 0;
+		rdata[3] = 0;
+		wdata[0] = 0x60;
+		wdata[1] = 0xFE;
+		wdata[2] = 0x00;
+		wdata[3] = 0x00;
+		spi_writeread_mem(client, 8, rdata, 4, wdata, 4);
+
+		if (retry++ > 100) {
+			BCM53115M_err("%s : Switch register read Failed, RACK bit not set\n", __func__);
+			return 1;
+		}
+
+	} while (!(rdata[3] & BCM_SPIIF_STAT_RACK));
+
+	/* Now data is ready at device, read it from data register */
+	rdata[0] = 0;
+	rdata[1] = 0;
+	rdata[2] = 0;
+	rdata[3] = 0;
+	rdata[4] = 0;
+	rdata[5] = 0;
+	wdata[0] = 0x60;
+	wdata[1] = 0xF0;
+	wdata[2] = 0x00;
+	wdata[3] = 0x00;
+
+	spi_writeread_mem(client, 8, rdata, size+3, wdata, size+3);
+
+	for (i = 0; i < size; i++)
+		data[i] = rdata[i+2];
+
+	return 0;
+
+}
+
+#define  MII_MAX_RETRY         100
+
+#define GEM_PHY_MAN             (0x34)
+#define GEM_NET_STATUS          (0x08)
+
+/* Bit positions for network status register */
+#define GEM_PHY_IDLE        (1<<2)      /* PHY management is idle */
+#define GEM_MDIO_IN         (1<<1)      /* Status of mdio_in pin */
+#define GEM_LINK_STATUS     (1<<0)      /* Status of link pin */
+static int c1k_gmac_mii_write(u32 base_addr, int phyAd, int regnum, u16 value)
+{
+	u32 write_data;
+
+	printk (KERN_ERR "mii write %d %d %x\n",  phyAd, regnum, value);
+
+	write_data = 0x50020000;
+	write_data |= ((phyAd << 23) | (regnum << 18) | value);
+	__raw_writel(write_data, base_addr + GEM_PHY_MAN);
+
+	while (!(__raw_readl(base_addr + GEM_NET_STATUS) & GEM_PHY_IDLE)) ;
+
+	return 0;
+}
+
+
+static int c1k_gmac_mii_read(u32 base_addr, int phyAd, int regnum)
+{
+	u16 value;
+	u32 write_data;
+
+	write_data = 0x60020000;
+	write_data |= ((phyAd << 23) | (regnum << 18));
+	__raw_writel(write_data, base_addr + GEM_PHY_MAN);
+
+	while (!(__raw_readl(base_addr + GEM_NET_STATUS) & GEM_PHY_IDLE)) ;
+	value = __raw_readl(base_addr + GEM_PHY_MAN) & 0xFFFF;
+
+	printk (KERN_ERR "mii read %d %d %x\n", phyAd, regnum, value);
+
+	return value;
+}
+
+
+
+/*
+ * bcm53115m_mii_read
+ *
+ */
+int bcm53115m_mii_read(struct bcm53115m_data *bcm, u8 page, u8 reg, void *val, u8 len)
+{
+	u16 cmd16, val16;
+	int i;
+	u8 *ptr = (u8 *)val;
+
+	/* set page number - MII register 0x10 */
+	if (prev_page_num != page) {
+		cmd16 = ((page << 8) |          /* page number */
+				1);                    /* mdc/mdio access enable */
+		c1k_gmac_mii_write(bcm->mii_base_addr, PSEUDO_PHYAD, REG_MII_PAGE, cmd16);
+		prev_page_num = page;
+	}
+
+	/* set register address - MII register 0x11 */
+	cmd16 = ((reg << 8) |           /* register address */
+			2);                    /* opcode read */
+	c1k_gmac_mii_write(bcm->mii_base_addr, PSEUDO_PHYAD, REG_MII_ADDR, cmd16);
+
+	/* is operation finished? */
+	for (i = MII_MAX_RETRY; i > 0; i--) {
+		val16 = c1k_gmac_mii_read(bcm->mii_base_addr, PSEUDO_PHYAD, REG_MII_ADDR);
+		if ((val16 & 3) == 0)
+			break;
+	}
+	/* timed out */
+	if (!i) {
+		printk("mii_rreg: timeout\n");
+		return -1;
+	}
+
+	printk("%s: [0x%x-0x%x] => 0x%x (len %d)\n", __func__, page, reg, val16, len);
+
+	switch (len) {
+
+	case 6:
+		val16 = c1k_gmac_mii_read(bcm->mii_base_addr, PSEUDO_PHYAD, REG_MII_DATA2);
+		ptr[5] = (val16 >> 8);
+		ptr[4] = (val16 & 0xff);
+		val16 = c1k_gmac_mii_read(bcm->mii_base_addr, PSEUDO_PHYAD, REG_MII_DATA1);
+		ptr[3] = (val16 >> 8);
+		ptr[2] = (val16 & 0xff);
+		val16 = c1k_gmac_mii_read(bcm->mii_base_addr, PSEUDO_PHYAD, REG_MII_DATA0);
+		ptr[1] = (val16 >> 8);
+		ptr[0] = (val16 & 0xff);
+		break;
+
+	case 4:
+		val16 = c1k_gmac_mii_read(bcm->mii_base_addr, PSEUDO_PHYAD, REG_MII_DATA1);
+		*(u32 *)val = (((u32)val16) << 16);
+		val16 = c1k_gmac_mii_read(bcm->mii_base_addr, PSEUDO_PHYAD, REG_MII_DATA0);
+		*(u32 *)val |= val16;
+		break;
+
+	case 2:
+		val16 = c1k_gmac_mii_read(bcm->mii_base_addr, PSEUDO_PHYAD, REG_MII_DATA0);
+		*(u16 *)val = val16;
+		break;
+	case 1:
+		val16 = c1k_gmac_mii_read(bcm->mii_base_addr, PSEUDO_PHYAD, REG_MII_DATA0);
+		*(u8 *)val = (u8)(val16 & 0xff);
+		break;
+	}
+
+	return 0;
+}
+
+int bcm53115m_mii_write(struct bcm53115m_data *bcm, u8 page, u8 reg, void *val, u8 len)
+{
+	u16 cmd16, val16;
+	int i;
+	u8 *ptr = (u8 *)val;
+
+	printk("%s: [0x%x-0x%x] := 0x%x (len %d)\n", __func__, page, reg,
+			*(u16 *)val, len);
+
+	/* set page number - MII register 0x10 */
+	if (prev_page_num != page) {
+		cmd16 = ((page << 8) |          /* page number */
+				1);                    /* mdc/mdio access enable */
+		c1k_gmac_mii_write(bcm->mii_base_addr, PSEUDO_PHYAD, REG_MII_PAGE, cmd16);
+		prev_page_num = page;
+	}
+
+	switch (len) {
+
+	case 6:
+		val16 = ptr[5];
+		val16 = ((val16 << 8) | ptr[4]);
+		c1k_gmac_mii_write(bcm->mii_base_addr, PSEUDO_PHYAD, REG_MII_DATA2, val16);
+		val16 = ptr[3];
+		val16 = ((val16 << 8) | ptr[2]);
+		c1k_gmac_mii_write(bcm->mii_base_addr, PSEUDO_PHYAD, REG_MII_DATA1, val16);
+		val16 = ptr[1];
+		val16 = ((val16 << 8) | ptr[0]);
+		c1k_gmac_mii_write(bcm->mii_base_addr, PSEUDO_PHYAD, REG_MII_DATA0, val16);
+		break;
+	case 4:
+		val16 = (u16)((*(u32 *)val) >> 16);
+		c1k_gmac_mii_write(bcm->mii_base_addr, PSEUDO_PHYAD, REG_MII_DATA1, val16);
+		val16 = (u16)(*(u32 *)val);
+		c1k_gmac_mii_write(bcm->mii_base_addr, PSEUDO_PHYAD, REG_MII_DATA0, val16);
+		break;
+
+	case 2:
+		val16 = *(u16 *)val;
+		c1k_gmac_mii_write(bcm->mii_base_addr, PSEUDO_PHYAD, REG_MII_DATA0, val16);
+		break;
+
+	case 1:
+		val16 = *(u8 *)val;
+		c1k_gmac_mii_write(bcm->mii_base_addr, PSEUDO_PHYAD, REG_MII_DATA0, val16);
+		break;
+	}
+
+	/* set register address - MII register 0x11 */
+	cmd16 = ((reg << 8) |           /* register address */
+			1);            /* opcode write */
+	c1k_gmac_mii_write(bcm->mii_base_addr, PSEUDO_PHYAD, REG_MII_ADDR, cmd16);
+
+	/* is operation finished? */
+	for (i = MII_MAX_RETRY; i > 0; i--) {
+		val16 = c1k_gmac_mii_read(bcm->mii_base_addr, PSEUDO_PHYAD, REG_MII_ADDR);
+		if ((val16 & 3) == 0)
+			break;
+	}
+
+	/* timed out */
+	if (!i) {
+		printk(("mii_wreg: timeout"));
+		return -1;
+	}
+	return 0;
+}
+
diff --git a/drivers/spi2/chips/bcm53115m_main.c b/drivers/spi2/chips/bcm53115m_main.c
new file mode 100644
index 0000000..5164c39
--- /dev/null
+++ b/drivers/spi2/chips/bcm53115m_main.c
@@ -0,0 +1,1104 @@
+/*
+ *  bcm53115m_main.c
+ *
+ *  Copyright (C) Mindspeed Technologies
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/slab.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+
+
+#include "bcm53115m.h"
+#include "bcm53115m_regs.h"
+
+static struct bcm53115m_data *bcm53115m;
+
+static void bcm53115_proc_init(struct spi_client *client);
+static struct proc_dir_entry *l2sw_vlan_mapping_port_proc[PORT_MAX];
+static struct proc_dir_entry *l2sw_vlan_mapping_proc;
+static struct proc_dir_entry *l2sw_vlan_mode_proc;
+static struct proc_dir_entry *l2sw_stats_proc;
+static struct proc_dir_entry *l2sw_conf_proc;
+static struct proc_dir_entry *l2sw_proc;
+
+static int spi_cs = 1;
+
+module_param(spi_cs, int, 0);
+
+/*
+ * bcm53115m_watchdog_task
+ *
+ */
+	static void
+bcm53115m_watchdog_task(struct work_struct *work)
+{
+	u32 ii, port_stat, stat_change, port_speed, port_duplex;
+	struct spi_client *client = (struct spi_client *)container_of(work, struct bcm53115m_data, watchdog_task.work);
+	BCM53115M_debug("bcm53115m_watchdog_task\n");
+
+	bcm53115m_read(client, BCM_PAGE_STAT, BCM_STAT_REG_LINK_STAT_CHNG, (u8 *)&stat_change, 2);
+	bcm53115m_read(client, BCM_PAGE_STAT, BCM_STAT_REG_LINK_STAT, (u8 *)&port_stat, 2);
+
+	for (ii = 0; ii < 5; ii++) {
+		if (stat_change & (1 << ii)) {
+			if ((bcm53115m->phy_state[ii].link_state == LINK_DOWN) && (port_stat & 1 << ii))	{
+				bcm53115m->phy_state[ii].link_state = LINK_UP;
+
+				BCM53115M_info("BCM53115M: Switch port %i is up.\n", ii);
+				bcm53115m_read(client, BCM_PAGE_STAT, BCM_STAT_REG_SPEED, (u8 *)&port_speed, 4);
+
+				switch ((port_speed >> (ii * 2)) & 3) {
+				case 0:
+					BCM53115M_info("BCM53115M: Switch port %i speed is 10Mbps.\n", ii);
+					bcm53115m->phy_state[ii].link_speed = LINK_10MB;
+					break;
+
+				case 1:
+					BCM53115M_info("BCM53115M: Switch port %i speed is 100Mbps.\n", ii);
+					bcm53115m->phy_state[ii].link_speed = LINK_100MB;
+					break;
+
+				case 2:
+					BCM53115M_info("BCM53115M: Switch port %i speed is 1Gbps.\n", ii);
+					bcm53115m->phy_state[ii].link_speed = LINK_1000MB;
+					break;
+				}
+
+				bcm53115m_read(client, BCM_PAGE_STAT, BCM_STAT_REG_DUPLEX, (u8 *)&port_duplex, 2);
+
+				if (port_stat & (1 << ii)) {
+					BCM53115M_info("BCM53115M: Switch port %i speed is Full Duplex.\n", ii);
+					bcm53115m->phy_state[ii].link_speed = LINK_FULL_DUPLEX;
+				} else {
+					BCM53115M_info("BCM53115M: Switch port %i speed is Half Duplex.\n", ii);
+					bcm53115m->phy_state[ii].link_speed = LINK_HALF_DUPLEX;
+				}
+			} else if ((bcm53115m->phy_state[ii].link_state == LINK_UP) && !(port_stat & 1 << ii)) {
+				bcm53115m->phy_state[ii].link_state = LINK_DOWN;
+
+				BCM53115M_info("BCM53115M: Switch port %i is down.\n", ii);
+			}
+		}
+	}
+
+	/* Re-schedule work */
+	schedule_delayed_work(&bcm53115m->watchdog_task, BCM53115M_PHY_POLL_GAP * HZ);
+
+}
+
+static void bcm53115m_read_vlan_table(struct spi_client *client, int vlan_id, u32 *data_entry)
+{
+	u8  val8 = 0;
+
+	/* Configure the Index register */
+	bcm53115m_write(client, BCM_PAGE_VTBL, BCM_REG_VTBL_INDX, (u8 *)&vlan_id, 2);
+
+	/* Configuring the Access register to start the read operation to VLAN table */
+	val8 = 0x81;
+	bcm53115m_write(client, BCM_PAGE_VTBL, BCM_REG_VTBL_ACCESS, (u8 *)&val8, 1);
+
+	/* Wait for the completion of the Read operation */
+	do {
+		bcm53115m_read(client, BCM_PAGE_VTBL, BCM_REG_VTBL_ACCESS, (u8 *)&val8, 1);
+		/* BCM53115M_info ("%s : Reading VLANs : Access Control Value read is: 0x%x. \n", __func__, val8); */
+	} while (val8 != 1);
+
+	/* Store the value read from the VLAN table */
+	bcm53115m_read(client, BCM_PAGE_VTBL, BCM_REG_VTBL_ENTRY, (u8 *)data_entry, 4);
+	BCM53115M_info("%s : VLAN Entry at 0x%x is: %x. \n", __func__, vlan_id, *data_entry);
+}
+
+static void bcm53115m_write_vlan_table(struct spi_client *client, int vlan_id, u32 *data_entry)
+{
+	u8  val8 = 0;
+
+	/* Configure the Index register */
+	bcm53115m_write(client, BCM_PAGE_VTBL, BCM_REG_VTBL_INDX, (u8 *)&vlan_id, 2);
+	/* Configure the Data Entry register */
+	bcm53115m_write(client, BCM_PAGE_VTBL, BCM_REG_VTBL_ENTRY, (u8 *)data_entry, 4);
+
+	/* Configuring the Access register to start the Write operation to VLAN table */
+	val8 = 0x80;
+	bcm53115m_write(client, BCM_PAGE_VTBL, BCM_REG_VTBL_ACCESS, (u8 *)&val8, 1);
+
+	/* Wait for the completion of the Write operation */
+	do {
+		bcm53115m_read(client, BCM_PAGE_VTBL, BCM_REG_VTBL_ACCESS, (u8 *)&val8, 1);
+	} while (val8 != 0);
+}
+
+/*
+ * bcm53115m_add_port_to_vlan
+ */
+static void bcm53115m_add_port_to_vlan(struct spi_client *client, int vlan_id, int port, int untag_mode)
+{
+	u32 data_entry = 0;
+
+	/* Read the VLAN table for this specific VLAN id */
+	bcm53115m_read_vlan_table(client, vlan_id, &data_entry);
+
+	/* Check if the port is IMP_PORT */
+	if (port == PORT_IMP)
+		/* Only program the FWD field */
+		data_entry |= (1 << 8);
+	else {
+		/* Program the FWD field */
+		data_entry |= (1 << port);
+		/* Program the Untag field */
+		if (untag_mode == BCM_UNTAG_VLAN)
+			data_entry |= ((1 << port) << 9);
+		else
+			data_entry &= ~((1 << port) << 9);
+	}
+
+	BCM53115M_info("%s: Value written to vlan_id 0x%x is 0x%x\n", __func__, vlan_id, data_entry);
+
+	/* Update the VLAN table for this specific VLAN id */
+	bcm53115m_write_vlan_table(client, vlan_id, &data_entry);
+}
+
+/*
+ * bcm53115m_rem_port_from_vlan
+ */
+static void bcm53115m_rem_port_from_vlan(struct spi_client *client, int vlan_id, int port)
+{
+	u32 data_entry = 0;
+
+	/* Read the VLAN table for this specific VLAN id */
+	bcm53115m_read_vlan_table(client, vlan_id, &data_entry);
+
+	/* Check if the port is IMP_PORT */
+	if (port == PORT_IMP)
+		/* Unset the concerned bit in FWD field */
+		data_entry &= ~(1 << 8);
+	else {
+		if (data_entry & (1 << port)) {
+			/* Unset the concerned bit in FWD field */
+			data_entry &= ~(1 << port);
+			/* Program the Untag field */
+			data_entry &= ~((1 << port) << 9);
+		}
+	}
+
+	if (data_entry == 0x100)
+		data_entry = 0; /* As only IMP_PORT is there in Forward list */
+
+	BCM53115M_info("%s: Value written to vlan_id 0x%x is 0x%x\n", __func__, vlan_id, data_entry);
+
+	/* Update the VLAN table for this specific VLAN id */
+	bcm53115m_write_vlan_table(client, vlan_id, &data_entry);
+}
+
+#define SET_MODE   1
+#define UNSET_MODE 0
+/*
+ * bcm53115m_port_based_vlan
+ */
+static void bcm53115m_port_based_vlan(struct spi_client *client, int mode, int port, int vlan_id)
+{
+	u32 tag_addr[6] = {BCM_IEEE_802_1Q_TAG_P0,
+			   BCM_IEEE_802_1Q_TAG_P1,
+			   BCM_IEEE_802_1Q_TAG_P2,
+			   BCM_IEEE_802_1Q_TAG_P3,
+			   BCM_IEEE_802_1Q_TAG_P4,
+			   BCM_IEEE_802_1Q_TAG_P5};
+	u32 pvlan_addr[6] = {BCM_PORT_VLAN_CTRL_P0,
+			     BCM_PORT_VLAN_CTRL_P1,
+			     BCM_PORT_VLAN_CTRL_P2,
+			     BCM_PORT_VLAN_CTRL_P3,
+			     BCM_PORT_VLAN_CTRL_P4,
+			     BCM_PORT_VLAN_CTRL_P5};
+	u32 data, port_vlan_data, i;
+	struct bcm53115m_data *bcm53115m = spi_get_clientdata(client);
+
+	BCM53115M_info("%s: mode %d, port %d, vlan_id %d\n", __func__, mode, port, vlan_id);
+	if (mode == SET_MODE) {
+		/* Configure the 802.1q Tag register for this port */
+		bcm53115m_write(client, BCM_PAGE_IEEE_VLAN, tag_addr[port], &vlan_id, 2);
+
+		/* Configure the port to this vlan id */
+		bcm53115m_add_port_to_vlan(client, vlan_id, port, BCM_UNTAG_VLAN);
+		bcm53115m_add_port_to_vlan(client, vlan_id, PORT_IMP, BCM_UNTAG_VLAN);
+
+		/* Check if the VLAN id's of any two ports are similar, if so add them to the port_vlan_data */
+		port_vlan_data = 0;
+		for (i = 0; i < 6; i++) {
+			data = 0;
+			bcm53115m_read(client, BCM_PAGE_IEEE_VLAN, tag_addr[i], &data, 2);
+			if ((data & 0xfff) == vlan_id)
+				port_vlan_data |= (1 << i);
+		}
+		port_vlan_data |= (1 << 8); /* IMP port */
+		BCM53115M_info("%s: Configured Port Based VLAN register of port %d to value 0x%x\n", __func__, port, port_vlan_data);
+		/* Configure the Port Based VLAN control register */
+		bcm53115m_write(client, BCM_PAGE_PVLAN, pvlan_addr[port], (u8 *)&port_vlan_data, 2);
+
+		/* Store the Port VLAN id for future use */
+		bcm53115m->pvlan_id[port] = vlan_id;
+	} else if (mode == UNSET_MODE) {
+		/* Remove the port for this vlan id */
+		bcm53115m_rem_port_from_vlan(client, vlan_id, port);
+		mdelay(50);
+
+		/* Configure the Port Based VLAN control register with default value */
+		data = 0x1FF;
+		bcm53115m_write(client, BCM_PAGE_PVLAN, pvlan_addr[port], (u8 *) &data, 2);
+
+		/* Set the pvlan_id variable to 0 */
+		bcm53115m->pvlan_id[port] = 0;
+	}
+}
+
+
+int bcm53115m_device_init(struct spi_client *client)
+{
+	u32 devid = 0, val = 0, ii;
+	u8 temp[3];
+
+	/* Read device id register */
+	bcm53115m_read(client, BCM_PAGE_MGMT, BCM_MGMT_REG_DEVID, temp, 3);
+	devid = (u32)temp[0];
+	devid |= (u32) (temp[1]<<8);
+	devid |= (u32) (temp[2]<<16);
+
+	if (devid != BCM_DEVID_53115M) {
+		BCM53115M_err("%s : Broadcom 53115M switch not found... device id read: %x \n", __func__, devid);
+		return 1;
+	}
+
+	BCM53115M_info("%s : Broadcom 53115M switch found, devid: %x. \n", __func__, devid);
+
+	/* Reset the switch */
+	val = 0x93;
+	bcm53115m_write(client, BCM_PAGE_CTRL, BCM_CTRL_REG_SWRST, (u8 *)&val, 1);
+	mdelay(500);
+	val = 0x00;
+	bcm53115m_write(client, BCM_PAGE_CTRL, BCM_CTRL_REG_SWRST, (u8 *)&val, 1);
+
+	/* Set unmanaged mode */
+	bcm53115m_read(client, BCM_PAGE_CTRL, BCM_CTRL_REG_SWTC_MODE, (u8 *)&val, 1);
+	val &= ~1;
+	val = bcm53115m_write(client, BCM_PAGE_CTRL, BCM_CTRL_REG_SWTC_MODE, (u8 *)&val, 1);
+
+
+	/* No spanning tree for unmanaged mode */
+	val = 0;
+	for (ii = BCM_CTRL_REG_PORT0_CTRL; ii <= BCM_CTRL_REG_PORT4_CTRL; ii++)
+		bcm53115m_write(client, BCM_PAGE_CTRL, ii, (u8 *)&val, 1);
+
+	/* Set IMP port also no spanning tree*/
+	bcm53115m_write(client, BCM_PAGE_CTRL, BCM_CTRL_REG_IMP_PORT_CTRL, (u8 *)&val, 1);
+
+
+	/* Enable IMP port */
+	val = 0x8B;
+	/* Force IMP port status to link-pass and full-duplex and 1G speed*/
+	bcm53115m_write(client, BCM_PAGE_CTRL,  BCM_CTRL_REG_IMP_STAT_OVWR, (u8 *)&val, 1);
+
+
+	val = 0x1C;
+	/* Enable traffic forwarding to IMP port */
+	bcm53115m_write(client, BCM_PAGE_CTRL, BCM_CTRL_REG_IMP_PORT_CTRL, (u8 *)&val, 1);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int bcm53115m_suspend(struct spi_client *client, pm_message_t state)
+{
+	bcm53115m->suspend = 1;
+	cancel_delayed_work(&bcm53115m->watchdog_task);
+
+	return 0;
+}
+
+static int bcm53115m_resume(struct spi_client *client)
+{
+	bcm53115m->suspend = 0;
+	schedule_delayed_work(&bcm53115m->watchdog_task, BCM53115M_PHY_POLL_GAP * HZ);
+
+	return 0;
+}
+#endif
+
+static int bcm53115m_attach_adapter(struct spi_adapter *adapter);
+static int bcm53115m_detach_client(struct spi_client *client);
+static struct spi_driver bcm53115m_driver = {
+	.name = BCM53115M_DRIVER_NAME,
+	.attach_adapter = bcm53115m_attach_adapter,
+	.detach_client  = bcm53115m_detach_client,
+#ifdef CONFIG_PM
+	.suspend = bcm53115m_suspend,
+	.resume = bcm53115m_resume,
+#endif
+};
+
+/*
+ * bcm53115m_attach_adapter
+ *
+ */
+static int bcm53115m_attach_adapter(struct spi_adapter *adapter)
+{
+	struct spi_client *client;
+	int portid;
+
+	BCM53115M_debug("bcm53115_attach_adapter\n");
+
+	/*Allocate memory for driver*/
+	bcm53115m = kmalloc(sizeof (struct bcm53115m_data), GFP_KERNEL);
+	if (bcm53115m == NULL) {
+		BCM53115M_err("bcm53115m: Error while allocating memory\n");
+		goto err0;
+	}
+
+	memset(bcm53115m, 0, sizeof(struct bcm53115m_data));
+
+	client = &bcm53115m->client;
+	spi_set_clientdata(client, bcm53115m);
+
+	/*SPI Informations*/
+	client->adapter = adapter;
+	client->driver = &bcm53115m_driver;
+
+	if ((spi_cs < 0) || (spi_cs > 3))
+		spi_cs = 1;
+
+	client->config.cs_msk = 1 << spi_cs;
+	client->config.sc_polarity = 1;         /* inactive state of serial clock is high */
+	client->config.sc_phase = 1;            /* serial clock toggles at the start of first data bit */
+	client->config.sc_rate = 2000000;       /* 2 Mhz */
+	client->config.cs_delay = 2;            /* 2 bits, This will be 1us gap between two CS */
+
+	if (spi_attach_client(client)) {
+		BCM53115M_err("bcm53115m: Error while registering to SPI bus\n");
+		goto err1;
+	}
+
+	/*Initialize the device*/
+	if (bcm53115m_device_init(client)) {
+		BCM53115M_err("bcm53115m: Error while initializing device\n");
+		goto err2;
+	}
+
+
+	bcm53115m->mii_base_addr = APB_VADDR(0x1019E000);
+	bcm53115m->spi_if_enabled = 1;
+#ifdef CONFIG_PM
+	bcm53115m->suspend = 0;
+#endif
+	BCM53115M_info("%s : Broadcom 53115M switch initialization is successful. \n", __func__);
+
+
+	bcm53115_proc_init(client);
+
+	/*Start workqueue used to poll PHYs state*/
+	INIT_DELAYED_WORK(&bcm53115m->watchdog_task, bcm53115m_watchdog_task);
+	schedule_delayed_work(&bcm53115m->watchdog_task, BCM53115M_PHY_POLL_GAP * HZ);
+
+	/* Initialize the Port VLAN entries */
+	for (portid = 0; portid < 6; portid++)
+		bcm53115m->pvlan_id[portid] = 0;
+
+
+	return 0;
+
+err2:
+	/*Detach driver from SPI bus*/
+	spi_detach_client(client);
+
+err1:
+	/*Free allocated memory*/
+	kfree(bcm53115m);
+
+err0:
+	return -1;
+}
+
+/*
+ * bcm53115m_detach_client
+ *
+ */
+static int bcm53115m_detach_client(struct spi_client *client)
+{
+	struct bcm53115m_data *bcm53115m = spi_get_clientdata(client);
+	int portid;
+	char s[30];
+
+	BCM53115M_debug("bcm53115_detach_client\n");
+
+	cancel_delayed_work(&bcm53115m->watchdog_task);
+
+	/*Detach driver from SPI bus*/
+	spi_detach_client(client);
+
+	/*Free allocated memory*/
+	kfree(bcm53115m);
+
+#ifdef BCM53115M_DEBUG
+	remove_proc_entry("driver/bcm53115m/read_data", NULL);
+	remove_proc_entry("driver/bcm53115m/write_data", NULL);
+	remove_proc_entry("driver/bcm53115m/reg_desc", NULL);
+#endif
+	remove_proc_entry("driver/bcm53115m/read_port0", NULL);
+	remove_proc_entry("driver/bcm53115m/read_port1", NULL);
+	remove_proc_entry("driver/bcm53115m/read_port2", NULL);
+	remove_proc_entry("driver/bcm53115m/read_port3", NULL);
+	remove_proc_entry("driver/bcm53115m/read_port4", NULL);
+	remove_proc_entry("driver/bcm53115m/read_imp_port", NULL);
+	remove_proc_entry("driver/bcm53115m/spi_if_enable", NULL);
+	remove_proc_entry("driver/bcm53115m", NULL);
+
+	remove_proc_entry("conf", l2sw_proc);
+	remove_proc_entry("stats", l2sw_proc);
+	for (portid = 0; portid <= PORT_4; portid++) {
+		snprintf(s, 30, "port%d", portid);
+		remove_proc_entry(s, l2sw_vlan_mapping_proc);
+	}
+	remove_proc_entry("vlan_mapping", l2sw_proc);
+	remove_proc_entry("vlan_mode", l2sw_proc);
+	remove_proc_entry("l2sw", NULL);
+
+
+	return 0;
+}
+
+static int bcm53115m_proc_read_port(int port, char *page, char **start, off_t off,
+		int count, int *eof, void *data)
+{
+	int TxBytes = 0, TxDrop = 0, TxBroadcasts = 0, TxUnicasts = 0, TxCollisions = 0, TxFrameInDisc = 0;
+	int RxBytes = 0, RxBroadcasts = 0, RxUnicasts = 0, RxDropped = 0, RxFCSErrors = 0, RxAlignErrors = 0;
+	int MiiStatus = 0, PhyExtStatus = 0;
+	int len = 0;
+	char *p = page;
+
+#ifdef CONFIG_PM
+	if (bcm53115m->suspend) {
+		p += sprintf(p, "bcm53115m is in power down state.\n");
+		goto spnd;
+	}
+#endif
+
+	if (port < 5) {
+		bcm53115m_read(&bcm53115m->client, 0x10 + port, 0x22, &PhyExtStatus, 2);
+		bcm53115m_read(&bcm53115m->client, 0x10 + port, 0x2, &MiiStatus, 2);
+	}
+
+	/* Transmit counters */
+	bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x00, &TxBytes, 4);
+	bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x08, &TxDrop, 4);
+	bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x10, &TxBroadcasts, 4);
+	bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x18, &TxUnicasts, 4);
+	bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x1C, &TxCollisions, 4);
+	bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x34, &TxFrameInDisc, 4);
+
+	/* Receive counters */
+	bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x50, &RxBytes, 4);
+	bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x9c, &RxBroadcasts, 4);
+	bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x94, &RxUnicasts, 4);
+	bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x90, &RxDropped, 4);
+	bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x84, &RxFCSErrors, 4);
+	bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x80, &RxAlignErrors, 4);
+
+
+	p += sprintf(p, "TX Counters:\n");
+	p += sprintf(p, "  Tx Bytes      : %x\n", TxBytes);
+	p += sprintf(p, "  Tx Droped     : %x\n", TxDrop);
+	p += sprintf(p, "  Tx Broadcasts : %x\n", TxBroadcasts);
+	p += sprintf(p, "  Tx Unicasts   : %x\n", TxUnicasts);
+	p += sprintf(p, "  Tx Collisions : %x\n", TxCollisions);
+	p += sprintf(p, "  Tx FrameInDisc: %x\n", TxFrameInDisc);
+
+	p += sprintf(p, "RX Counters:\n");
+	p += sprintf(p, "  Rx Bytes      : %x\n", RxBytes);
+	p += sprintf(p, "  Rx Dropped    : %x\n", RxDropped);
+	p += sprintf(p, "  Rx Broadcasts : %x\n", RxBroadcasts);
+	p += sprintf(p, "  Rx Unicasts   : %x\n", RxUnicasts);
+	p += sprintf(p, "  Rx FCS Errors : %x\n", RxFCSErrors);
+	p += sprintf(p, "  Rx Align Error: %x\n", RxAlignErrors);
+
+	p += sprintf(p, "Phy Extended status:\n");
+	p += sprintf(p, "  Phy Extended status  %x\n", PhyExtStatus);
+
+	if (PhyExtStatus & (1 << 15))
+		p += sprintf(p, "    %s\n", "bit'15: Mismatch detected");
+
+	if (PhyExtStatus & (1 << 14))
+		p += sprintf(p, "    %s\n", "bit'14: Auto-neg Speed degraded");
+
+	if (PhyExtStatus & (1 << 13))
+		p += sprintf(p, "    %s\n", "bit'13: Crossover MDI Mode");
+
+	if (PhyExtStatus & (1 << 9))
+		p += sprintf(p, "    %s\n", "bit'9: Descrambler is locked");
+
+	p += sprintf(p, "    %s\n", (PhyExtStatus & (1<<8)) ? "bit'8: Link pass" : "bit'8:Link Fail");
+
+	if (PhyExtStatus & (1 << 7))
+		p += sprintf(p, "    %s\n", "bit'7: CRC Error detected");
+
+	if (PhyExtStatus & (1 << 6))
+		p += sprintf(p, "    %s\n", "bit'6: Carrier Ext Error detected");
+
+	if (PhyExtStatus & (1 << 5))
+		p += sprintf(p, "    %s\n", "bit'5: Bad SSD Err detected");
+
+	if (PhyExtStatus & (1 << 4))
+		p += sprintf(p, "    %s\n", "bit'4: Bad ESD Error detected");
+
+	if (PhyExtStatus & (1 << 3))
+		p += sprintf(p, "    %s\n", "bit'3: Receive Err detected");
+
+	if (PhyExtStatus & (1 << 2))
+		p += sprintf(p, "    %s\n", "bit'2: Transmit Err detected");
+
+	if (PhyExtStatus & (1 << 1))
+		p += sprintf(p, "    %s\n", "bit'1: Lock Err detected");
+
+	if (PhyExtStatus & (1 << 0))
+		p += sprintf(p, "    %s\n", "bit'0: MLT3 code Err detected");
+
+	len = p - page;
+
+	if (len <= off+count)
+		*eof = 1;
+
+	*start = page + off;
+	len -= off;
+	if (len > count)
+		len = count;
+	if (len < 0)
+		len = 0;
+
+	return len;
+}
+
+
+/*
+ * bcm53115m_proc_read_port0
+ *
+ */
+static int bcm53115m_proc_read_port0(char *page, char **start, off_t off,
+		int count, int *eof, void *data)
+{
+	return  bcm53115m_proc_read_port(0, page, start, off, count, eof, data);
+}
+/*
+ * bcm53115m_proc_read_port0
+ *
+ */
+static int bcm53115m_proc_read_port1(char *page, char **start, off_t off,
+		int count, int *eof, void *data)
+{
+	return  bcm53115m_proc_read_port(1, page, start, off, count, eof, data);
+}
+/*
+ * bcm53115m_proc_read_port0
+ *
+ */
+static int bcm53115m_proc_read_port2(char *page, char **start, off_t off,
+		int count, int *eof, void *data)
+{
+	return  bcm53115m_proc_read_port(2, page, start, off, count, eof, data);
+}
+/*
+ * bcm53115m_proc_read_port0
+ *
+ */
+static int bcm53115m_proc_read_port3(char *page, char **start, off_t off,
+		int count, int *eof, void *data)
+{
+	return  bcm53115m_proc_read_port(3, page, start, off, count, eof, data);
+}
+/*
+ * bcm53115m_proc_read_port0
+ *
+ */
+static int bcm53115m_proc_read_port4(char *page, char **start, off_t off,
+		int count, int *eof, void *data)
+{
+	return  bcm53115m_proc_read_port(4, page, start, off, count, eof, data);
+}
+/*
+ * bcm53115m_proc_read_port0
+ *
+ */
+static int bcm53115m_proc_read_port8(char *page, char **start, off_t off,
+		int count, int *eof, void *data)
+{
+	return  bcm53115m_proc_read_port(8, page, start, off, count, eof, data);
+
+}
+
+
+
+
+#ifdef BCM53115M_DEBUG
+
+/*
+ * bcm53115m_proc_read_data
+ *
+ */
+static int bcm53115m_proc_read_data(char *page, char **start, off_t off,
+		int count, int *eof, void *data)
+{
+	char *p;
+	int len = 0;
+
+#ifdef CONFIG_PM
+	if (bcm53115m->suspend) {
+		len += sprintf(page, "bcm53115m is in power down state.\n");
+		goto spnd;
+	}
+#endif
+
+	reg_read_data = 0;
+
+	if (bcm53115m->spi_if_enabled)
+		bcm53115m_read(&bcm53115m->client, reg_page, reg_offst, (u8 *)&reg_read_data, reg_size);
+	else
+		bcm53115m_mii_read(bcm53115m, reg_page, reg_offst, (u8 *)&reg_read_data, reg_size);
+
+	len = sprintf(page, "%x\n", reg_read_data);
+
+spnd:
+	if (len <= off+count)
+		*eof = 1;
+
+	*start = page + off;
+	len -= off;
+	if (len > count)
+		len = count;
+	if (len < 0)
+		len = 0;
+	return len;
+}
+
+
+/*
+ * bcm53115m_proc_write_reg_desc
+ *
+ */
+static bcm53115m_proc_write_reg_desc(struct file *file, const char __user *buffer,
+		unsigned long count, void *data)
+{
+	char value[32];
+
+#ifdef CONFIG_PM
+	if (bcm53115m->suspend) {
+		printk(KERN_INFO "[%s]: bcm53115m is in power down state.\n", __FUCTION__);
+		return count;
+	}
+#endif
+
+	if (!count)
+		return 0;
+
+	if (copy_from_user(value, buffer, count))
+		return -EFAULT;
+
+	value[count] = 0;
+
+	sscanf(value, "%x%x%x", &reg_page, &reg_offst, &reg_size);
+
+	if (reg_size > 4) /* Right now not suported */
+		reg_size = 4;
+
+	return count;
+}
+#endif
+
+/*
+ * bcm53115m_spi_interface_enable
+ *
+ */
+static int bcm53115m_spi_interface_enable(struct file *file, const char __user *buffer,
+		unsigned long count, void *data)
+{
+	char value[16];
+
+	if (!count)
+		return 0;
+
+	if (copy_from_user(value, buffer, count))
+		return -EFAULT;
+
+	sscanf(value, "%x", &bcm53115m->spi_if_enabled);
+
+	return count;
+}
+
+#ifdef BCM53115M_DEBUG
+
+/*
+ * bcm53115m_proc_write_data
+ *
+ */
+static int bcm53115m_proc_write_data(struct file *file, const char __user *buffer,
+		unsigned long count, void *data)
+{
+	char value[12];
+
+#ifdef CONFIG_PM
+	if (bcm53115m->suspend) {
+		printk(KERN_INFO "[%s]: bcm53115m is in power down state.\n", __FUCTION__);
+		return count;
+	}
+#endif
+
+	reg_write_data = 0;
+
+	if (!count)
+		return 0;
+
+	if (count > 4)
+		return count;
+
+	if (copy_from_user(value, buffer, count))
+		return -EFAULT;
+
+	value[count] = 0;
+
+	sscanf(value, "%x", &reg_write_data);
+
+	if (bcm53115m->spi_if_enabled)
+		bcm53115m_write(&bcm53115m->client, reg_page, reg_offst, (u8 *)&reg_write_data, reg_size);
+	else
+		bcm53115m_mii_write(bcm53115m, reg_page, reg_offst, (u8 *)&reg_write_data, reg_size);
+
+
+	return count;
+}
+#endif
+
+/********************************************
+ * l2sw_vlan_mapping_write -
+ *
+ ********************************************/
+static ssize_t l2sw_vlan_mapping_write(struct file *filp, const char *buf, unsigned long len, void *data)
+{
+	unsigned char portid = *(unsigned char *)data;
+	unsigned int vlanid;
+
+	char* mybuf = (char *)kmalloc(len+1, GFP_KERNEL);
+	if (!mybuf)
+		return 0;
+
+	if (copy_from_user(mybuf, (unsigned char *)buf, len)) {
+		BCM53115M_info("%s : Error copying from user\n", __func__);
+		return 0;
+	}
+	mybuf[len] = '\0';
+	vlanid = simple_strtoul(mybuf, NULL, 10);
+	BCM53115M_info("%s: Vlan id read is %d\n", __func__, vlanid);
+
+	bcm53115m_port_based_vlan(&bcm53115m->client, SET_MODE, portid, vlanid);
+
+	return len;
+}
+
+static int l2sw_vlan_mapping_read(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	unsigned char portid = *(unsigned char *)data;
+	int len = 0;
+
+	if (bcm53115m->pvlan_id[portid])
+		len += sprintf(page+len, "0x%x is the VLAN configured for port %d\n", bcm53115m->pvlan_id[portid], portid);
+	else
+		len += sprintf(page+len, "No VLAN configured for port %d\n", portid);
+
+	return len;
+}
+
+static ssize_t l2sw_vlan_mode_write(struct file *filp, const char *buf, unsigned long len, void *data)
+{
+	struct spi_client *client = (struct spi_client *)data;
+	struct bcm53115m_data *bcm53115m = spi_get_clientdata(client);
+	unsigned char mode;
+	u8 val;
+	int portid;
+
+	char* mybuf = (char *)kmalloc(len+1, GFP_KERNEL);
+	if (!mybuf)
+		return 0;
+
+	BCM53115M_info("%s\n", __func__);
+	if (copy_from_user(mybuf, (unsigned char *)buf, len)) {
+		BCM53115M_info("error copying from user");
+		return 0;
+	}
+	mybuf[len] = '\0';
+	mode = simple_strtoul(mybuf, NULL, 10);
+
+	BCM53115M_info("%s: mode read is %d\n", __func__, mode);
+	if (mode > VLAN_AWARE) {
+		BCM53115M_info("Vlan mode %d is not supported - default mode 0 (VLAN_UNAWARE) is set\n", mode);
+		mode = VLAN_UNAWARE;
+	}
+
+	/* Setup the VLAN global variable */
+	val = 0;
+	bcm53115m_read(client, BCM_PAGE_IEEE_VLAN, BCM_GLBL_IEEE_802_1Q, (u8 *)&val, 1);
+	if (mode == VLAN_AWARE)
+		val |= (1 << 7);
+	else
+		val &= ~(1 << 7);
+	bcm53115m_write(client, BCM_PAGE_IEEE_VLAN, BCM_GLBL_IEEE_802_1Q, (u8 *)&val, 1);
+	BCM53115M_info("%s: Value written to VLAN Global register is 0x%x\n", __func__, val);
+	mdelay(100);
+
+	if (mode == VLAN_UNAWARE) {
+		for (portid = 0; portid < 6; portid++) {
+			if (bcm53115m->pvlan_id[portid]) { /* If pvlan_id is set initially */
+				BCM53115M_info("%s: Calling bcm53115M_port_based_vlan for port %d\n", __func__, portid);
+				bcm53115m_port_based_vlan(client, UNSET_MODE, portid, bcm53115m->pvlan_id[portid]);
+			}
+		}
+	}
+
+	bcm53115m->vlan_mode = mode;
+
+	return len;
+}
+
+static int l2sw_vlan_mode_read(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	int len = 0;
+	struct spi_client *client = (struct spi_client *)data;
+	struct bcm53115m_data *bcm53115m = spi_get_clientdata(client);
+
+	if (bcm53115m->vlan_mode == VLAN_AWARE)
+		len += sprintf(page+len, "1\n");
+	else
+		len += sprintf(page+len, "0\n");
+
+	return len;
+}
+
+static int l2sw_stats_read(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	int port;
+	int len = 0;
+	int TxBytes = 0, TxDrop = 0, TxBroadcasts = 0, TxUnicasts = 0, TxCollisions = 0, TxFrameInDisc = 0;
+	int RxBytes = 0, RxBroadcasts = 0, RxUnicasts = 0, RxDropped = 0, RxFCSErrors = 0, RxAlignErrors = 0;
+	len += sprintf(page+len, "l2sw stats\n");
+
+	for (port = 0; port < PORT_MAX; port++) {
+		if (port > PORT_4 && port < PORT_IMP)
+			continue;
+
+		if (port <= PORT_4 && bcm53115m->phy_state[port].link_state == LINK_DOWN) {
+			len += sprintf(page+len, "Port %d is DOWN\n", port);
+			continue;
+		}
+
+		if (port != PORT_IMP)
+			len += sprintf(page+len, "Port %d\n", port);
+		else
+			len += sprintf(page+len, "Host Port %d\n", port);
+
+		/* Transmit counters */
+		bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x00, &TxBytes, 4);
+		bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x08, &TxDrop, 4);
+		bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x10, &TxBroadcasts, 4);
+		bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x18, &TxUnicasts, 4);
+		bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x1C, &TxCollisions, 4);
+		bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x34, &TxFrameInDisc, 4);
+
+		/* Receive counters */
+		bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x50, &RxBytes, 4);
+		bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x9c, &RxBroadcasts, 4);
+		bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x94, &RxUnicasts, 4);
+		bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x90, &RxDropped, 4);
+		bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x84, &RxFCSErrors, 4);
+		bcm53115m_read(&bcm53115m->client, 0x20 + port, 0x80, &RxAlignErrors, 4);
+
+		len += sprintf(page+len, "TX Counters:\n");
+		len += sprintf(page+len, "  Bytes      : %x", TxBytes);
+		len += sprintf(page+len, "  Droped     : %x", TxDrop);
+		len += sprintf(page+len, "  Broadcasts : %x", TxBroadcasts);
+		len += sprintf(page+len, "  Unicasts   : %x", TxUnicasts);
+		len += sprintf(page+len, "  Collisions : %x", TxCollisions);
+		len += sprintf(page+len, "  Frame Discarded: %x\n", TxFrameInDisc);
+
+		len += sprintf(page+len, "RX Counters:\n");
+		len += sprintf(page+len, "  Bytes      : %x", RxBytes);
+		len += sprintf(page+len, "  Dropped    : %x", RxDropped);
+		len += sprintf(page+len, "  Broadcasts : %x", RxBroadcasts);
+		len += sprintf(page+len, "  Unicasts   : %x", RxUnicasts);
+		len += sprintf(page+len, "  FCS Errors : %x", RxFCSErrors);
+		len += sprintf(page+len, "  Align Error: %x\n", RxAlignErrors);
+	}
+
+	len += sprintf(page+len, "\n");
+	return len;
+}
+
+static int l2sw_conf_read(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	int i, len = 0;
+	unsigned int vid, reg_value, tag_value = 0, pvlan_val = 0;
+	struct spi_client *client = (struct spi_client *)data;
+	len += sprintf(page+len, "l2sw global configuration\n");
+
+	if (bcm53115m->vlan_mode == VLAN_AWARE)
+		len += sprintf(page+len, "VLAN-aware\n");
+	else
+		len += sprintf(page+len, "VLAN-unaware\n");
+
+	len += sprintf(page+len, "l2sw per port configuration\n");
+	for (i = PORT_0; i < PORT_5; i++) {
+		len += sprintf(page+len, "Port %d:\n", i);
+		bcm53115m_read(client, BCM_PAGE_PVLAN, BCM_PORT_VLAN_CTRL_P0 + (i * 2), &pvlan_val, 2);
+		len += sprintf(page+len, "Port VLAN reg: 0x%x,", pvlan_val);
+		bcm53115m_read(client, BCM_PAGE_IEEE_VLAN, BCM_IEEE_802_1Q_TAG_P0 + (i * 2), &tag_value, 1);
+		len += sprintf(page+len, "  IEEE 802.1Q Tag reg: 0x%x\n", tag_value);
+	}
+
+	len += sprintf(page+len, "VLANACCESS (32 entries):\n");
+	for (vid = 1; vid <= 32; vid++) {
+		bcm53115m_read_vlan_table(client, vid, &reg_value);
+		len += sprintf(page+len, "vlanid %d -> 0x%08x\n", vid, reg_value);
+	}
+
+	len += sprintf(page+len, "\n");
+	return len;
+}
+
+/*
+ * bcm53115_proc_init
+ *
+ */
+static void bcm53115_proc_init(struct spi_client *client)
+{
+	struct bcm53115m_data *bcm53115m = spi_get_clientdata(client);
+	struct proc_dir_entry *entry = NULL;
+	int portid;
+	char s[30];
+
+	proc_mkdir("driver/bcm53115m", NULL);
+	create_proc_read_entry("driver/bcm53115m/read_port0", 0, NULL, bcm53115m_proc_read_port0, bcm53115m);
+	create_proc_read_entry("driver/bcm53115m/read_port1", 0, NULL, bcm53115m_proc_read_port1, bcm53115m);
+	create_proc_read_entry("driver/bcm53115m/read_port2", 0, NULL, bcm53115m_proc_read_port2, bcm53115m);
+	create_proc_read_entry("driver/bcm53115m/read_port3", 0, NULL, bcm53115m_proc_read_port3, bcm53115m);
+	create_proc_read_entry("driver/bcm53115m/read_port4", 0, NULL, bcm53115m_proc_read_port4, bcm53115m);
+	create_proc_read_entry("driver/bcm53115m/read_imp_port", 0, NULL, bcm53115m_proc_read_port8, bcm53115m);
+
+#ifdef BCM53115M_DEBUG
+	entry = create_proc_entry("driver/bcm53115m/reg_desc", S_IFREG | S_IWUSR, NULL);
+
+	if (entry) {
+		entry->write_proc = bcm53115m_proc_write_reg_desc;
+		entry->data = &reg_offst;
+	}
+
+	create_proc_read_entry("driver/bcm53115m/read_data", 0, NULL, bcm53115m_proc_read_data, bcm53115m);
+
+	entry = create_proc_entry("driver/bcm53115m/write_data", S_IFREG | S_IWUSR, NULL);
+
+	if (entry) {
+		entry->write_proc = bcm53115m_proc_write_data;
+		entry->data = &reg_write_data;
+	}
+#endif
+
+	entry = create_proc_entry("driver/bcm53115m/spi_if_enable", S_IFREG | S_IWUSR, NULL);
+
+	if (entry) {
+		entry->write_proc = bcm53115m_spi_interface_enable;
+		entry->data = &bcm53115m->spi_if_enabled;
+	}
+
+	/* Create /proc/l2sw entry */
+	l2sw_proc = proc_mkdir("l2sw", NULL);
+	if (l2sw_proc) {
+		l2sw_vlan_mapping_proc = proc_mkdir("vlan_mapping", l2sw_proc);
+		if (l2sw_vlan_mapping_proc == NULL)
+			printk("can't create /proc/l2sw/vlan_mapping entry");
+		else {
+			for (portid = 0; portid <= PORT_5; portid++) {
+				bcm53115m->port[portid] = portid;
+				snprintf(s, 30, "port%d", portid);
+
+				l2sw_vlan_mapping_port_proc[portid] = create_proc_entry(s, 0644, l2sw_vlan_mapping_proc);
+				if (l2sw_vlan_mapping_port_proc[portid] == NULL)
+					printk("can't create /proc/l2sw/vlan_mapping/%s entry", s);
+				else {
+					l2sw_vlan_mapping_port_proc[portid]->read_proc = l2sw_vlan_mapping_read;
+					l2sw_vlan_mapping_port_proc[portid]->write_proc = l2sw_vlan_mapping_write;
+					l2sw_vlan_mapping_port_proc[portid]->data = (void *)&bcm53115m->port[portid];
+				}
+			}
+		}
+
+		l2sw_stats_proc = create_proc_entry("stats", 0644, l2sw_proc);
+		if (l2sw_stats_proc == NULL)
+			printk("can't create /proc/l2sw/stats entry");
+		else {
+			l2sw_stats_proc->read_proc = l2sw_stats_read;
+			l2sw_stats_proc->data = client;
+		}
+
+		l2sw_conf_proc = create_proc_entry("conf", 0644, l2sw_proc);
+		if (l2sw_conf_proc == NULL)
+			printk("can't create /proc/l2sw/conf entry");
+		else {
+			l2sw_conf_proc->read_proc = l2sw_conf_read;
+			l2sw_conf_proc->data = client;
+		}
+
+		l2sw_vlan_mode_proc = create_proc_entry("vlan_mode", 0644, l2sw_proc);
+		if (l2sw_vlan_mode_proc == NULL)
+			printk("can't create /proc/l2sw/vlan_mode entry");
+		else {
+			l2sw_vlan_mode_proc->read_proc = l2sw_vlan_mode_read;
+			l2sw_vlan_mode_proc->write_proc = l2sw_vlan_mode_write;
+			l2sw_vlan_mode_proc->data = client;
+		}
+	} else
+		printk("can't create /proc/l2sw entry");
+
+}
+
+/*
+ * bcm53115m_driver_init
+ *
+ */
+static int __init bcm53115m_driver_init(void)
+{
+	BCM53115M_info("Broadcom bcm53115m Switch Linux driver version: %s\n", BCM53115M_DRIVER_VERSION);
+	spi_add_driver(&bcm53115m_driver);
+
+	return 0;
+}
+
+/*
+ * bcm53115m_driver_exit
+ *
+ */
+static void __exit bcm53115m_driver_exit(void)
+{
+	BCM53115M_info("bcm53115m driver exit\n");
+	spi_del_driver(&bcm53115m_driver);
+}
+
+MODULE_AUTHOR("Mindspeed Technologies");
+MODULE_DESCRIPTION("Broadcom BCM53115M device driver");
+MODULE_LICENSE("GPL");
+
+module_init(bcm53115m_driver_init);
+module_exit(bcm53115m_driver_exit);
+
diff --git a/drivers/spi2/chips/bcm53115m_regs.h b/drivers/spi2/chips/bcm53115m_regs.h
new file mode 100644
index 0000000..1c5944d
--- /dev/null
+++ b/drivers/spi2/chips/bcm53115m_regs.h
@@ -0,0 +1,110 @@
+/*
+ * bcm53115m_regs.h
+ *
+ * Copyright (C) Mindspeed Technologies
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef __BCM53115M_REG_H__
+#define __BCM53115M_REG_H__
+
+#define  BCM_DEVID_53115M  0x00053115
+/* BCM53115M SPI Interface register */
+#define BCM_SPIIF_REG_PAGE_ADDR 0xFF
+#define BCM_SPIIF_REG_DATA      0xF0
+#define BCM_SPIIF_REG_STAT      0xFE
+
+/* Bit definition of BCM_REG_SPIIF_STAT register */
+#define BCM_SPIIF_STAT_SPIF 0x80
+#define BCM_SPIIF_STAT_RACK 0x20
+
+
+/* MII access registers */
+#define PSEUDO_PHYAD    0x1E    /* MII Pseudo PHY address */
+#define REG_MII_PAGE    0x10    /* MII Page register */
+#define REG_MII_ADDR    0x11    /* MII Address register */
+#define REG_MII_DATA0   0x18    /* MII Data register 0 */
+#define REG_MII_DATA1   0x19    /* MII Data register 1 */
+#define REG_MII_DATA2   0x1a    /* MII Data register 2 */
+#define REG_MII_DATA3   0x1b    /* MII Data register 3 */
+
+
+/* Page numbers */
+#define BCM_PAGE_CTRL         0x00
+#define BCM_PAGE_STAT         0x01
+#define BCM_PAGE_MGMT         0x02
+#define BCM_PAGE_VTBL         0x05
+#define BCM_PAGE_INTRNL_PHY0  0x10
+#define BCM_PAGE_INTRNL_PHY1  0x11
+#define BCM_PAGE_INTRNL_PHY2  0x12
+#define BCM_PAGE_INTRNL_PHY3  0x13
+#define BCM_PAGE_INTRNL_PHY4  0x14
+#define BCM_PAGE_PVLAN        0x31
+#define BCM_PAGE_IEEE_VLAN    0x34
+
+
+/* Registers in page BCM_PAGE_CTRL */
+
+#define BCM_CTRL_REG_PORT0_CTRL    0x00
+#define BCM_CTRL_REG_PORT1_CTRL    0x01
+#define BCM_CTRL_REG_PORT2_CTRL    0x02
+#define BCM_CTRL_REG_PORT3_CTRL    0x03
+#define BCM_CTRL_REG_PORT4_CTRL    0x04
+#define BCM_CTRL_REG_PORT5_CTRL    0x05
+#define BCM_CTRL_REG_IMP_PORT_CTRL 0x08
+#define BCM_CTRL_REG_SWTC_MODE     0x0B
+#define BCM_CTRL_REG_IMP_STAT_OVWR 0x0E
+#define BCM_CTRL_REG_SWRST         0x79
+
+/* Registers in page BCM_PAGE_STAT */
+#define BCM_STAT_REG_LINK_STAT       0x00
+#define BCM_STAT_REG_LINK_STAT_CHNG  0x02
+#define BCM_STAT_REG_SPEED           0x04
+#define BCM_STAT_REG_DUPLEX          0x08
+
+
+/* Registers in page BCM_PAGE_MGMT */
+#define BCM_MGMT_REG_GLBL_CNF      0x00
+#define BCM_MGMT_REG_DEVID         0x30
+
+#define BCM_REG_VTBL_ACCESS        0x80
+#define BCM_REG_VTBL_INDX          0x81
+#define BCM_REG_VTBL_ENTRY         0x83
+
+#define BCM_GLBL_IEEE_802_1Q       0x00
+#define BCM_IEEE_802_1Q_TAG_P0     0x10
+#define BCM_IEEE_802_1Q_TAG_P1     0x12
+#define BCM_IEEE_802_1Q_TAG_P2     0x14
+#define BCM_IEEE_802_1Q_TAG_P3     0x16
+#define BCM_IEEE_802_1Q_TAG_P4     0x18
+#define BCM_IEEE_802_1Q_TAG_P5     0x1A
+
+#define BCM_PORT_VLAN_CTRL_P0      0x00
+#define BCM_PORT_VLAN_CTRL_P1      0x02
+#define BCM_PORT_VLAN_CTRL_P2      0x04
+#define BCM_PORT_VLAN_CTRL_P3      0x06
+#define BCM_PORT_VLAN_CTRL_P4      0x08
+#define BCM_PORT_VLAN_CTRL_P5      0x0A
+
+enum ePORT_ID {
+	PORT_0 = 0,
+	PORT_1,
+	PORT_2,
+	PORT_3,
+	PORT_4,
+	PORT_5,
+	PORT_IMP = 8,
+	PORT_MAX
+};
+
+
+#define VLAN_UNAWARE		0
+#define VLAN_AWARE		1
+#define BCM_TAG_VLAN            1
+#define BCM_UNTAG_VLAN          0
+
+#endif
+
-- 
1.6.5.2

