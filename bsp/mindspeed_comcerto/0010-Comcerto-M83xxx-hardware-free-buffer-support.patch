From deedb6beb8c6ecda47f12d326918fc69370c599d Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Tue, 19 Oct 2010 17:05:52 +0800
Subject: [PATCH 10/26] Comcerto: M83xxx: hardware free buffer support

Original codes came from Mindspeed's vendor drop sdk-comcerto-openwrt-6.0.

The Comcerto M883xxx provides two hardware free buffer pools for GEMAC to
perform allocation and release of processed buffers.

Integrated-by: Stanley.Miao <stanley.miao@windriver.com>
---
 drivers/net/comcerto/c1000_fbpool.c |  484 +++++++++++++++++++++++++++++++++++
 drivers/net/comcerto/c1000_fbpool.h |   68 +++++
 2 files changed, 552 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/comcerto/c1000_fbpool.c
 create mode 100644 drivers/net/comcerto/c1000_fbpool.h

diff --git a/drivers/net/comcerto/c1000_fbpool.c b/drivers/net/comcerto/c1000_fbpool.c
new file mode 100644
index 0000000..2268514
--- /dev/null
+++ b/drivers/net/comcerto/c1000_fbpool.c
@@ -0,0 +1,484 @@
+/*
+  *  linux/drivers/net/comcerto/c1000_fbpool.c
+  *
+  *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2 of the License, or
+  * (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  */
+
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <mach/hardware.h>
+
+#include "c1000_fbpool.h"
+
+static spinlock_t fbpool_lock;
+
+#define FBPOOL_STAGGER_SIZE	14
+
+static u16 fbpool_stagger_offsets[FBPOOL_STAGGER_SIZE] = {
+	0, 64, 128, 192, 256, 320, 384,
+	1024, 1088, 1152, 1216, 1280, 1344, 1408
+};
+
+#define FBPOOL_MAX	2
+static struct c1k_fbpool *fbpool_dev[FBPOOL_MAX] = {NULL, NULL};
+
+
+static ssize_t fbpool_data_read(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct c1k_fbpool *fbpool = dev_get_drvdata(dev);
+
+	if (strcmp("lowthres", attr->attr.name) == 0)
+		return sprintf(buf, "%d\n", readl(fbpool->lthres_reg));
+	else if (strcmp("highthres", attr->attr.name) == 0)
+		return sprintf(buf, "%d\n", readl(fbpool->hthres_reg));
+	else if (strcmp("depth", attr->attr.name) == 0)
+		return sprintf(buf, "%d\n", readl(fbpool->depth_reg));
+	else if (strcmp("underrun", attr->attr.name) == 0)
+		return sprintf(buf, "%ld\n", fbpool->underrun);
+	else if (strcmp("overflow", attr->attr.name) == 0)
+		return sprintf(buf, "%ld\n", fbpool->overflow);
+	else {
+		printk(KERN_ERR "fbpool_data_read: Unknown file attribute\n");
+		return -1;
+	}
+}
+
+static ssize_t fbpool_data_write(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	unsigned long data = simple_strtoul(buf, NULL, 0);
+	struct c1k_fbpool *fbpool = dev_get_drvdata(dev);
+
+	if (strcmp("lowthres", attr->attr.name) == 0) {
+		if ((data > fbpool->high_thr) || (data > (fbpool->length - 1))) {
+			printk(KERN_ERR "fbpool_data_write: invalid low threshold value\n");
+			return -1;
+		}
+
+		fbpool->low_thr = data;
+		writel(data, fbpool->lthres_reg);
+	} else if (strcmp("highthres", attr->attr.name) == 0) {
+		if ((data < fbpool->low_thr) || (data > (fbpool->length - 1))) {
+			printk(KERN_ERR "fbpool_data_write: invalid high threshold value\n");
+			return -1;
+		}
+
+		fbpool->high_thr = data;
+		writel(data, fbpool->hthres_reg);
+	} else {
+		printk(KERN_ERR "fbpool_data_write: Unknown file attribute\n");
+		return -1;
+	}
+
+	return count;
+}
+
+static struct device_attribute fbpool_lthres_attr = __ATTR(lowthres, 0644, fbpool_data_read, fbpool_data_write);
+static struct device_attribute fbpool_hthres_attr = __ATTR(highthres, 0644, fbpool_data_read, fbpool_data_write);
+static struct device_attribute fbpool_depth_attr = __ATTR(depth, 0644, fbpool_data_read, NULL);
+static struct device_attribute fbpool_underrun_attr = __ATTR(underrun, 0644, fbpool_data_read, NULL);
+static struct device_attribute fbpool_overflow_attr = __ATTR(overflow, 0644, fbpool_data_read, NULL);
+
+int c1k_fbpool_put(struct c1k_fbpool *fbpool, void *ptr)
+{
+	/*TODO:
+	 * should we check buffer full or rely on overflow interrupt?
+	 * */
+	writel(virt_to_phys(ptr), fbpool->base_addr);
+
+	return 0;
+}
+EXPORT_SYMBOL(c1k_fbpool_put);
+
+
+void *c1k_fbpool_get(struct c1k_fbpool *fbpool)
+{
+	u32 phys = readl(fbpool->base_addr);
+
+	if (phys)
+		return phys_to_virt(phys);
+	else
+		return NULL;
+}
+EXPORT_SYMBOL(c1k_fbpool_get);
+
+
+void c1k_fbpool_flush(struct c1k_fbpool *fbpool)
+{
+	fbpool->cb(fbpool);
+
+	fbpool->full = 0;
+}
+EXPORT_SYMBOL(c1k_fbpool_flush);
+
+static void c1k_fbpool_timer(unsigned long data)
+{
+	struct c1k_fbpool *fbpool = (struct c1k_fbpool *)data;
+
+	c1k_fbpool_flush(fbpool);
+
+	fbpool->timer.expires = jiffies + (C1K_FBPOOL_TIMEOUT_MS * HZ) / 1000;
+	add_timer(&fbpool->timer);
+}
+
+static void c1k_fbpool_hthres_task(struct work_struct *work)
+{
+	struct c1k_fbpool *fbpool = container_of(work, struct c1k_fbpool, fbpool_hthres_task);
+	unsigned long flags;
+
+	c1k_fbpool_flush(fbpool);
+
+	spin_lock_irqsave(&fbpool_lock, flags);
+	/* re-enable interrupt */
+	writel(readl(fbpool->int_en_reg) | ((HTHRES_A_INT_EN | HTHRES_B_INT_EN) & fbpool->int_mask), fbpool->int_en_reg);
+	fbpool->int_en_mask |= (HTHRES_A_INT_EN | HTHRES_B_INT_EN) & fbpool->int_mask;
+	spin_unlock_irqrestore(&fbpool_lock, flags);
+}
+
+static irqreturn_t c1k_fbpool_interrupt(int irq, void *dev_id)
+{
+	struct c1k_fbpool *fbpool = dev_id;
+	int status = readl(fbpool->int_stat_reg) & fbpool->int_en_mask;
+	unsigned long flags;
+	int handled = 1;
+
+	if (!status) {
+		handled = 0;
+		goto out;
+	}
+
+	if (status & (OVR_A_INT_STAT | OVR_B_INT_STAT))
+		fbpool->overflow++;
+
+	if (status & (UDR_A_INT_STAT | UDR_B_INT_STAT))
+		fbpool->underrun++;
+
+	if (status & (HTHRES_A_INT_STAT | HTHRES_B_INT_STAT)) {
+		/* disable int */
+
+		spin_lock_irqsave(&fbpool_lock, flags);
+		writel(readl(fbpool->int_en_reg) & ~((HTHRES_A_INT_EN | HTHRES_B_INT_EN) & fbpool->int_mask), fbpool->int_en_reg);
+		fbpool->int_en_mask &= ~((HTHRES_A_INT_EN | HTHRES_B_INT_EN) & fbpool->int_mask);
+		spin_unlock_irqrestore(&fbpool_lock, flags);
+
+		schedule_work(&fbpool->fbpool_hthres_task);
+	}
+
+out:
+	/* clear all interrupts */
+	writel(status, fbpool->int_stat_reg);
+
+	return IRQ_RETVAL(handled);
+}
+
+int c1k_fbpool_fill(struct c1k_fbpool *fbpool, size_t size, int flags, int staggered)
+{
+	int i;
+	int ret = 0;
+	void *data;
+
+	if (fbpool->full)
+		goto done;
+
+	fbpool->full = 1;
+
+	/* Pool can only hold (length - 1) total pointers */
+	for (i = 0; i < fbpool->length - 1; i++) {
+
+		data = kmalloc(size, flags);
+		if (!data) {
+			printk(KERN_ERR "c1k_fbpool_fill: unable to allocate buffers\n");
+			ret = -ENOMEM;
+			goto err;
+		}
+
+		__dma_single_cpu_to_dev(data, size, DMA_FROM_DEVICE);
+
+		if (staggered)
+			data += fbpool_stagger_offsets[i % FBPOOL_STAGGER_SIZE];
+
+		if (c1k_fbpool_put(fbpool, data)) /* fbpool full */
+			break;
+	}
+
+done:
+	return 0;
+
+err:
+	c1k_fbpool_flush(fbpool);
+	return ret;
+}
+EXPORT_SYMBOL(c1k_fbpool_fill);
+
+
+struct c1k_fbpool *c1k_fbpool_open(int id, void (*cb)(struct c1k_fbpool *))
+{
+	struct c1k_fbpool *fbpool;
+	unsigned long flags;
+
+	if (id >= FBPOOL_MAX) {
+		printk(KERN_ERR "c1k_fbpool_open: fbpool(%d) out of range\n", id);
+		goto err0;
+	}
+
+	fbpool = fbpool_dev[id];
+	if (!fbpool) {
+		printk(KERN_ERR "c1k_fbpool_open: fbpool(%d) not initialized yet\n", id);
+		goto err0;
+	}
+
+	if (fbpool->cb && (fbpool->cb != cb)) {
+		printk(KERN_ERR "c1k_fbpool_open: fbpool(%d) already open\n", id);
+		goto err0;
+	}
+
+	/* skip the rest of the initialization if it's not
+	   the first user */
+	if (fbpool->users++)
+		goto done;
+
+	fbpool->cb = cb;
+
+	/* setup hw registers */
+	writel(fbpool->base_addr_phys, fbpool->base_addr_reg);
+	writel(fbpool->length, fbpool->length_reg);
+	writel(fbpool->low_thr, fbpool->lthres_reg);
+	writel(fbpool->high_thr, fbpool->hthres_reg);
+
+	if (request_irq(fbpool->irq, c1k_fbpool_interrupt, IRQF_SHARED, "c1k_fbpool", fbpool)) {
+		printk(KERN_ERR "c1k_fbpool_open: fbpool(%d) failed to get irq(%d)\n", fbpool->id, fbpool->irq);
+		goto err1;
+	}
+
+	spin_lock_irqsave(&fbpool_lock, flags);
+	writel(readl(fbpool->int_en_reg) | fbpool->int_mask, fbpool->int_en_reg);
+	fbpool->int_en_mask |= fbpool->int_mask;
+	spin_unlock_irqrestore(&fbpool_lock, flags);
+
+	if (fbpool->id) {
+		fbpool->timer.function = c1k_fbpool_timer;
+		fbpool->timer.data = (unsigned long)fbpool;
+		fbpool->timer.expires = jiffies + (C1K_FBPOOL_TIMEOUT_MS * HZ) / 1000;
+		add_timer(&fbpool->timer);
+	}
+
+done:
+	return fbpool;
+
+err1:
+	fbpool->users--;
+	fbpool->cb = NULL;
+err0:
+	return NULL;
+}
+
+EXPORT_SYMBOL(c1k_fbpool_open);
+
+
+void c1k_fbpool_close(struct c1k_fbpool *fbpool)
+{
+	unsigned long flags;
+
+	fbpool->users--;
+	if (!fbpool->users) {
+		spin_lock_irqsave(&fbpool_lock, flags);
+		writel(readl(fbpool->int_en_reg) & ~fbpool->int_mask, fbpool->int_en_reg);
+		fbpool->int_en_mask &= ~fbpool->int_mask;
+		spin_unlock_irqrestore(&fbpool_lock, flags);
+
+		free_irq(fbpool->irq, fbpool);
+
+		if (fbpool->id)
+			del_timer_sync(&fbpool->timer);
+
+		c1k_fbpool_flush(fbpool);
+
+		fbpool->cb = NULL;
+	} else if (fbpool->id)
+		/* Always flush poolB on close to free pending tx packets */
+		c1k_fbpool_flush(fbpool);
+}
+
+EXPORT_SYMBOL(c1k_fbpool_close);
+
+
+static int c1k_fbpool_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct comcerto_fbpool_platform_data *pdata;
+	struct c1k_fbpool *fbpool;
+	struct resource *r;
+	void *regs;
+	int ret = 0;
+
+	if (pdev->id >= FBPOOL_MAX) {
+		printk(KERN_ERR "c1k_fbpool_probe: pdev(%d) out of range\n", pdev->id);
+		ret = -EINVAL;
+		goto err0;
+	}
+
+	pdata = (struct comcerto_fbpool_platform_data *)pdev->dev.platform_data;
+	if (!pdata) {
+		printk(KERN_ERR "c1k_fbpool_probe: pdev(%d) missing platform data\n", pdev->id);
+		ret = -ENODEV;
+		goto err0;
+	}
+
+	if (fbpool_dev[pdev->id]) {
+		printk(KERN_ERR "c1k_fbpool_probe: pdev(%d) already exists\n", pdev->id);
+		ret = -ENODEV;
+		goto err0;
+	}
+
+	fbpool = kzalloc(sizeof(struct c1k_fbpool), GFP_KERNEL);
+	if (!fbpool) {
+		printk(KERN_ERR "c1k_fbpool %d: memory allocation failed\n", pdev->id);
+		ret = -ENOMEM;
+		goto err0;
+	}
+
+	fbpool->irq = platform_get_irq_byname(pdev, "irq");
+	if (fbpool->irq < 0) {
+		printk(KERN_ERR "c1k fbpool %d: missing int resource\n", pdev->id);
+		ret = -EINVAL;
+		goto err1;
+	}
+
+	r = platform_get_resource_byname(pdev, IORESOURCE_MEM, "regs");
+	if (!r) {
+		printk(KERN_ERR "c1k fbpool %d: missing regs resource\n", pdev->id);
+		ret = -EINVAL;
+		goto err1;
+	}
+
+	regs = (void *)APB_VADDR(r->start);
+
+	r = platform_get_resource_byname(pdev, IORESOURCE_MEM, "aram");
+	if (!r) {
+		printk(KERN_ERR "c1k fbpool %d: missing aram resource\n", pdev->id);
+		ret = -EINVAL;
+		goto err1;
+	}
+
+	fbpool->base_addr_phys = r->start;
+	fbpool->base_addr = aram_to_virt(r->start);
+
+	fbpool->id = pdev->id;
+
+	if (fbpool->id == 0) {
+		fbpool->base_addr_reg = regs + FPOOL_A_BASE;
+		fbpool->length_reg = regs + FPOOL_A_LENG;
+		fbpool->lthres_reg = regs + FPOOL_A_LTHRES;
+		fbpool->hthres_reg = regs + FPOOL_A_HTHRES;
+		fbpool->rdptr_reg = regs + FPOOL_A_RDPTR;
+		fbpool->wrptr_reg = regs + FPOOL_A_WRPTR;
+		fbpool->depth_reg = regs + FPOOL_A_DEPTH;
+		fbpool->int_stat_reg = regs + INT_STAT;
+		fbpool->int_en_reg =  regs + INT_EN;
+
+		fbpool->int_mask = OVR_A_INT_EN | UDR_A_INT_EN;
+
+	} else {
+		fbpool->base_addr_reg = regs + FPOOL_B_BASE;
+		fbpool->length_reg = regs + FPOOL_B_LENG;
+		fbpool->lthres_reg = regs + FPOOL_B_LTHRES;
+		fbpool->hthres_reg = regs + FPOOL_B_HTHRES;
+		fbpool->rdptr_reg = regs + FPOOL_B_RDPTR;
+		fbpool->wrptr_reg = regs + FPOOL_B_WRPTR;
+		fbpool->depth_reg = regs + FPOOL_B_DEPTH;
+		fbpool->int_stat_reg = regs + INT_STAT;
+		fbpool->int_en_reg =  regs + INT_EN;
+
+		fbpool->int_mask = OVR_B_INT_EN | HTHRES_B_INT_EN;
+	}
+
+	fbpool->length = pdata->length;
+	fbpool->low_thr = pdata->low_threshold;
+	fbpool->high_thr = pdata->high_threshold;
+
+	INIT_WORK(&fbpool->fbpool_hthres_task, c1k_fbpool_hthres_task);
+	init_timer(&fbpool->timer);
+	dev_set_drvdata(dev, fbpool);
+
+	/* Creating sysfs files */
+	ret |= device_create_file(dev, &fbpool_lthres_attr);
+	ret |= device_create_file(dev, &fbpool_hthres_attr);
+	ret |= device_create_file(dev, &fbpool_depth_attr);
+	ret |= device_create_file(dev, &fbpool_underrun_attr);
+	ret |= device_create_file(dev, &fbpool_overflow_attr);
+
+	fbpool_dev[fbpool->id] = fbpool;
+
+	return 0;
+
+err1:
+	kfree(fbpool);
+
+err0:
+	return ret;
+}
+
+
+static int c1k_fbpool_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct c1k_fbpool *fbpool = dev_get_drvdata(dev);
+
+	fbpool_dev[fbpool->id] = NULL;
+
+	device_remove_file(dev, &fbpool_lthres_attr);
+	device_remove_file(dev, &fbpool_hthres_attr);
+	device_remove_file(dev, &fbpool_depth_attr);
+	device_remove_file(dev, &fbpool_underrun_attr);
+	device_remove_file(dev, &fbpool_overflow_attr);
+
+	c1k_fbpool_flush(fbpool);
+
+	dev_set_drvdata(dev, NULL);
+	kfree(fbpool);
+
+	return 0;
+}
+
+/* Structure for a device driver */
+static struct platform_driver c1k_fbpool_driver = {
+	.probe = c1k_fbpool_probe,
+	.remove = c1k_fbpool_remove,
+	.driver	= {
+		.name = "c1000-fbpool",
+	},
+};
+
+static int __init c1k_fbpool_init(void)
+{
+	spin_lock_init(&fbpool_lock);
+
+	return platform_driver_register(&c1k_fbpool_driver);
+}
+
+static void  __exit c1k_fbpool_exit(void)
+{
+	platform_driver_unregister(&c1k_fbpool_driver);
+}
+
+module_init(c1k_fbpool_init);
+module_exit(c1k_fbpool_exit);
diff --git a/drivers/net/comcerto/c1000_fbpool.h b/drivers/net/comcerto/c1000_fbpool.h
new file mode 100644
index 0000000..36ecf75
--- /dev/null
+++ b/drivers/net/comcerto/c1000_fbpool.h
@@ -0,0 +1,68 @@
+/*
+  *  linux/drivers/net/comcerto/c1000_fbpool.h
+  *
+  *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2 of the License, or
+  * (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  */
+#ifndef __C1000_FPOOL_H
+#define __C1000_FPOOL_H
+
+#define C1K_FBPOOL_TIMEOUT_MS	500
+
+struct c1k_fbpool {
+	int	id;		/* 0 poolA, 1 poolB */
+
+	int	users;
+	u8	full;
+	void	*base_addr;
+	unsigned long base_addr_phys;
+	u16	length;
+	u16	low_thr;
+	u16	high_thr;
+	u32	int_mask;	/* mask of interrupts we want to handle */
+	u32	int_en_mask;	/* mask of currently enabled interrupts */
+
+	void	(*cb)(struct c1k_fbpool *);
+	struct work_struct fbpool_hthres_task;
+
+	struct timer_list timer;
+
+	int	irq;
+
+	/* stats */
+	unsigned long underrun;
+	unsigned long overflow;
+
+	/* registers */
+	void	*base_addr_reg;
+	void	*length_reg;
+	void	*lthres_reg;
+	void	*hthres_reg;
+	void	*rdptr_reg;
+	void	*wrptr_reg;
+	void	*depth_reg;
+	void	*int_stat_reg;
+	void	*int_en_reg;
+};
+
+void *c1k_fbpool_get(struct c1k_fbpool *fbpool);
+int c1k_fbpool_put(struct c1k_fbpool *fbpool, void *ptr);
+void c1k_fbpool_flush(struct c1k_fbpool *fbpool);
+int c1k_fbpool_fill(struct c1k_fbpool *fbpool, size_t size, int flags, int staggered);
+struct c1k_fbpool *c1k_fbpool_open(int id, void (*cb)(struct c1k_fbpool *));
+void c1k_fbpool_close(struct c1k_fbpool *fbpool);
+
+#endif
-- 
1.5.4.3

