From 752016bb133311d0efb8a3d4ba9e13ee4f37f82f Mon Sep 17 00:00:00 2001
From: Stanley.Miao <stanley.miao@windriver.com>
Date: Tue, 19 Oct 2010 17:32:25 +0800
Subject: [PATCH 11/26] Comcerto: M83xxx: ethtool support

Original codes came from Mindspeed's vendor drop sdk-comcerto-openwrt-6.0.

The goal of this ethtool utility, is to provide detailed information about
the interface, like link status, GEMAC statistics, GEMAC register dumps,
ring buffer sizes, and so on.

Integrated-by: Stanley.Miao <stanley.miao@windriver.com>
---
 drivers/net/comcerto/c1000_ethtool.c |  350 ++++++++++++++++++++++++++++++++++
 1 files changed, 350 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/comcerto/c1000_ethtool.c

diff --git a/drivers/net/comcerto/c1000_ethtool.c b/drivers/net/comcerto/c1000_ethtool.c
new file mode 100644
index 0000000..da60df8
--- /dev/null
+++ b/drivers/net/comcerto/c1000_ethtool.c
@@ -0,0 +1,350 @@
+/*
+  *  linux/drivers/net/comcerto/comcerto_ethtool.c
+  *
+  *  Copyright (C) 2006 Mindspeed Technologies, Inc.
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2 of the License, or
+  * (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  */
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+
+#include <linux/io.h>
+#include <asm/irq.h>
+#include <linux/uaccess.h>
+#include <linux/module.h>
+#include <linux/crc32.h>
+#include <linux/types.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+
+#include "c1000_eth.h"
+#include "comcerto_gemac.h"
+
+
+extern const char comcerto_eth_driver_version[];
+extern int c1k_eth_start(struct net_device *dev);
+extern void c1k_eth_stop(struct net_device *dev);
+
+
+static char stat_gstrings[][ETH_GSTRING_LEN] = {
+	"tx- octets  (Lower 32-bits)",
+	"tx- octets  (Upper 16-bits)",
+	"tx- packets",
+	"tx- broadcast",
+	"tx- multicast",
+	"tx- pause",
+	"tx- 64 bytes packets",
+	"tx- 64 - 127 bytes packets",
+	"tx- 128 - 255 bytes packets",
+	"tx- 256 - 511 bytes packets",
+	"tx- 512 - 1023 bytes packets",
+	"tx- 1024 - 1518 bytes packets",
+	"tx- > 1518 bytes packets",
+	"tx- underruns  - errors",
+	"tx- single collision",
+	"tx- multi collision",
+	"tx- exces. collision  - errors",
+	"tx- late collision  - errors",
+	"tx- deferred",
+	"tx- carrier sense - errors",
+	"rx- octets (Lower 32-bits)",
+	"rx- octets (Upper 16-bits)",
+	"rx- packets",
+	"rx- broadcast",
+	"rx- multicast",
+	"rx- pause",
+	"rx- 64 bytes packets",
+	"rx- 64 - 127 bytes packets",
+	"rx- 128 - 255 bytes packets",
+	"rx- 256 - 511 bytes packets",
+	"rx- 512 - 1023 bytes packets",
+	"rx- 1024 - 1518 bytes packets",
+	"rx- > 1518 bytes packets",
+	"rx- undersize -errors",
+	"rx- oversize  - errors ",
+	"rx- jabbers - errors",
+	"rx- fcs - errors",
+	"rx- length - errors",
+	"rx- symbol - errors",
+	"rx- align - errors",
+	"rx- ressource - errors",
+	"rx- overrun - errors",
+	"rx- IP cksum - errors",
+	"rx- TCP cksum - errors",
+	"rx- UDP cksum - errors"
+};
+
+/* Fill in a buffer with the strings which correspond to the
+ * stats */
+static void c1k_gstrings(struct net_device *dev, u32 stringset, u8 * buf)
+{
+	switch (stringset) {
+	case ETH_SS_STATS:
+		memcpy(buf, stat_gstrings, GEMAC_RMON_LEN * ETH_GSTRING_LEN);
+		break;
+
+	default:
+		 WARN_ON(1);
+		break;
+	}
+}
+
+/* Fill in an array of 64-bit statistics from various sources.
+ * This array will be appended to the end of the ethtool_stats
+ * structure, and returned to user space
+ */
+static void c1k_fill_stats(struct net_device *dev, struct ethtool_stats *dummy, u64 * buf)
+{
+	struct eth_c1k_priv *priv = netdev_priv(dev);
+	u32 *pstat = (u32 *)(priv->gemdev.registers + GEM_OCT_TX_BOT);
+	int i;
+	for (i = 0; i < GEMAC_RMON_LEN; i++)
+		*buf++ = *pstat++;
+}
+
+/* Returns the number of stats (and their corresponding strings) */
+static int c1k_stats_count(struct net_device *dev, int sset)
+{
+	switch (sset) {
+	case ETH_SS_STATS:
+		return GEMAC_RMON_LEN;
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+/* Fills in the drvinfo structure with some basic info */
+static void c1k_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *drvinfo)
+{
+	strncpy(drvinfo->driver, DRV_NAME, COMCERTO_INFOSTR_LEN);
+	strncpy(drvinfo->version, comcerto_eth_driver_version, COMCERTO_INFOSTR_LEN);
+	strncpy(drvinfo->fw_version, "N/A", COMCERTO_INFOSTR_LEN);
+	strncpy(drvinfo->bus_info, "N/A", COMCERTO_INFOSTR_LEN);
+	drvinfo->testinfo_len = 0;
+	drvinfo->regdump_len = 0;
+	drvinfo->eedump_len = 0;
+}
+
+
+static int c1k_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct eth_c1k_priv *priv = netdev_priv(dev);
+	struct phy_device *phydev = priv->phydev;
+
+	if (NULL == phydev)
+		return -ENODEV;
+
+	return phy_ethtool_sset(phydev, cmd);
+}
+
+
+/* Return the current settings in the ethtool_cmd structure */
+static int c1k_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	struct eth_c1k_priv *priv = netdev_priv(dev);
+	struct phy_device *phydev = priv->phydev;
+
+	if (NULL == phydev)
+		return -ENODEV;
+
+	return phy_ethtool_gset(phydev, cmd);
+}
+
+static void c1k_gringparam(struct net_device *dev, struct ethtool_ringparam *rvals)
+{
+	struct eth_c1k_priv *priv = netdev_priv(dev);
+
+	rvals->rx_max_pending = priv->RxRingSize;
+	rvals->rx_mini_max_pending = priv->RxRingSize;
+	rvals->rx_jumbo_max_pending = priv->RxRingSize;
+	rvals->tx_max_pending = priv->TxRingSize;
+
+	rvals->rx_pending = priv->RxRingSize;
+	rvals->rx_mini_pending = priv->RxRingSize;
+	rvals->rx_jumbo_pending = priv->RxRingSize;
+	rvals->tx_pending = priv->TxRingSize;
+}
+
+static int c1k_set_rx_csum(struct net_device *dev, uint32_t data)
+{
+	struct eth_c1k_priv *priv = netdev_priv(dev);
+
+	if (data) {
+		gem_enable_rx_checksum_offload(&priv->gemdev);
+		priv->flags |= RX_CSUM_OFFLOAD_ENABLED;
+	} else {
+		gem_disable_rx_checksum_offload(&priv->gemdev);
+		priv->flags &= ~RX_CSUM_OFFLOAD_ENABLED;
+	}
+
+	return 0;
+}
+
+static uint32_t c1k_get_rx_csum(struct net_device *dev)
+{
+	struct eth_c1k_priv *priv = netdev_priv(dev);
+
+	return (priv->flags & RX_CSUM_OFFLOAD_ENABLED) ? 1 : 0;
+}
+
+int c1k_set_tx_csum(struct net_device *dev, uint32_t data)
+{
+	struct eth_c1k_priv *priv = netdev_priv(dev);
+	unsigned long flags;
+	int rc = 0;
+
+	spin_lock_irqsave(&priv->txlock, flags);
+
+	if (data) {
+		if (priv->fast_path_enabled) {
+			rc = -EINVAL;
+			goto out;
+		}
+
+		gem_enable_tx_checksum_offload(&priv->gemdev);
+		dev->features |= NETIF_F_IP_CSUM;
+		priv->flags |= TX_CSUM_OFFLOAD_ENABLED;
+	} else {
+		gem_disable_tx_checksum_offload(&priv->gemdev);
+		dev->features &= ~NETIF_F_IP_CSUM;
+		priv->flags &= ~TX_CSUM_OFFLOAD_ENABLED;
+	}
+
+out:
+	spin_unlock_irqrestore(&priv->txlock, flags);
+
+	return rc;
+}
+
+static uint32_t c1k_get_tx_csum(struct net_device *dev)
+{
+	struct eth_c1k_priv *priv = netdev_priv(dev);
+
+	return (priv->flags & TX_CSUM_OFFLOAD_ENABLED) ? 1 : 0;
+}
+
+static uint32_t c1k_get_msglevel(struct net_device *dev)
+{
+	struct eth_c1k_priv *priv = netdev_priv(dev);
+
+	return priv->msg_enable;
+}
+
+static void c1k_set_msglevel(struct net_device *dev, uint32_t data)
+{
+	struct eth_c1k_priv *priv = netdev_priv(dev);
+
+	priv->msg_enable = data;
+}
+
+
+/* Get the coalescing parameters, and put them in the cvals
+ * structure.  */
+static int c1k_gcoalesce(struct net_device *dev, struct ethtool_coalesce *cvals)
+{
+	struct eth_c1k_priv *priv = netdev_priv(dev);
+
+	if (priv->fast_path_enabled)
+		return -ENOTSUPP;
+
+	cvals->rx_coalesce_usecs = priv->rx_coal_time;
+	cvals->rx_max_coalesced_frames = priv->rx_coal_count;
+
+	cvals->tx_coalesce_usecs = 0;
+	cvals->tx_max_coalesced_frames = 0;
+
+	cvals->use_adaptive_rx_coalesce = 0;
+	cvals->use_adaptive_tx_coalesce = 0;
+
+	cvals->pkt_rate_low = 0;
+	cvals->rx_coalesce_usecs_low = 0;
+	cvals->rx_max_coalesced_frames_low = 0;
+	cvals->tx_coalesce_usecs_low = 0;
+	cvals->tx_max_coalesced_frames_low = 0;
+
+	/* When the packet rate is below pkt_rate_high but above
+	 * pkt_rate_low (both measured in packets per second) the
+	 * normal {rx,tx}_* coalescing parameters are used.
+	 */
+
+	/* When the packet rate is (measured in packets per second)
+	 * is above pkt_rate_high, the {rx,tx}_*_high parameters are
+	 * used.
+	 */
+	cvals->pkt_rate_high = 0;
+	cvals->rx_coalesce_usecs_high = 0;
+	cvals->rx_max_coalesced_frames_high = 0;
+	cvals->tx_coalesce_usecs_high = 0;
+	cvals->tx_max_coalesced_frames_high = 0;
+
+	/* How often to do adaptive coalescing packet rate sampling,
+	 * measured in seconds.  Must not be zero.
+	 */
+	cvals->rate_sample_interval = 0;
+
+	return 0;
+}
+
+/* Change the coalescing values.
+ * Both cvals->*_usecs and cvals->*_frames have to be > 0
+ * in order for coalescing to be active
+ */
+static int c1k_scoalesce(struct net_device *dev, struct ethtool_coalesce *cvals)
+{
+	struct eth_c1k_priv *priv = netdev_priv(dev);
+
+	if (priv->fast_path_enabled)
+		return -ENOTSUPP;
+
+	priv->rx_coal_time = cvals->rx_coalesce_usecs;
+	priv->rx_coal_count = cvals->rx_max_coalesced_frames;
+
+	writel(priv->rx_coal_time * 125, priv->baseaddr + GEM_ADM_BLOCK + ADM_BATCHINTRTIMERINIT);
+	writel(priv->rx_coal_count, priv->baseaddr + GEM_ADM_BLOCK + ADM_BATCHINTRPKTTHRES);
+
+	return 0;
+}
+
+struct ethtool_ops c1k_ethtool_ops = {
+	.get_settings = c1k_get_settings,
+	.set_settings = c1k_set_settings,
+	.get_drvinfo = c1k_get_drvinfo,
+	.get_link = ethtool_op_get_link,
+	.get_ringparam = c1k_gringparam,
+	.get_coalesce = c1k_gcoalesce,
+	.set_coalesce = c1k_scoalesce,
+	.get_strings = c1k_gstrings,
+	.get_sset_count = c1k_stats_count,
+	.get_ethtool_stats = c1k_fill_stats,
+	.get_rx_csum = c1k_get_rx_csum,
+	.get_tx_csum = c1k_get_tx_csum,
+	.set_rx_csum = c1k_set_rx_csum,
+	.set_tx_csum = c1k_set_tx_csum,
+	.get_msglevel = c1k_get_msglevel,
+	.set_msglevel = c1k_set_msglevel,
+};
-- 
1.6.5.2

