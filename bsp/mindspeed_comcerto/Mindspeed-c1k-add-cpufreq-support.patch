From dc344b9a6f871de4b2f3606d4bd8e9de0f0eb9d1 Mon Sep 17 00:00:00 2001
From: Guoqing Jiang <Guoqing.Jiang@windriver.com>
Date: Wed, 27 Oct 2010 09:31:05 +0800
Subject: [PATCH 21/26] Mindspeed-c1k: add cpufreq support

Add cpufreq support for mindspeed c1k board.
[Original code taken from sdk-comcerto-openwrt-6.0.tar.bz2]

Integrated-by: Guoqing Jiang <Guoqing.Jiang@windriver.com>
---
 arch/arm/Kconfig                                   |    2 +
 arch/arm/mach-comcerto/Makefile                    |    4 +-
 arch/arm/mach-comcerto/comcerto-1000.c             |   56 ++
 arch/arm/mach-comcerto/cpufreq.c                   |  190 +++++++
 arch/arm/mach-comcerto/cpufreq1.c                  |  112 ++++
 .../arm/mach-comcerto/include/mach/comcerto-1000.h |   27 +
 arch/arm/mach-comcerto/pwrmgmt_c1000.c             |  570 ++++++++++++++++++++
 7 files changed, 960 insertions(+), 1 deletions(-)
 create mode 100644 arch/arm/mach-comcerto/cpufreq.c
 create mode 100644 arch/arm/mach-comcerto/cpufreq1.c
 create mode 100644 arch/arm/mach-comcerto/pwrmgmt_c1000.c

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 98cb1dd..ebe94e5 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -333,6 +333,8 @@ config ARCH_EP93XX
 config ARCH_COMCERTO
 	bool "Mindspeed Comcerto"
 	select CPU_V6
+	select ARCH_HAS_CPUFREQ
+	select CPU_FREQ
 	help
 	  This enables support for Mindspeed's Comcerto development boards.
 	  If you would like to build your kernel to run on one of these boards
diff --git a/arch/arm/mach-comcerto/Makefile b/arch/arm/mach-comcerto/Makefile
index b4c369d..7683715 100644
--- a/arch/arm/mach-comcerto/Makefile
+++ b/arch/arm/mach-comcerto/Makefile
@@ -6,5 +6,7 @@
 
 obj-y := irq.o time.o
 
-obj-$(CONFIG_ARCH_M83XXX)			+= comcerto-1000.o
+obj-$(CONFIG_ARCH_M83XXX)			+= comcerto-1000.o pwrmgmt_c1000.o
 obj-$(CONFIG_EVM_C1KMFCN_EVM)			+= board-c1kmfcn_evm.o
+
+obj-$(CONFIG_CPU_FREQ)                          += cpufreq.o cpufreq1.o
diff --git a/arch/arm/mach-comcerto/comcerto-1000.c b/arch/arm/mach-comcerto/comcerto-1000.c
index 4e3f14e..02b5a99 100644
--- a/arch/arm/mach-comcerto/comcerto-1000.c
+++ b/arch/arm/mach-comcerto/comcerto-1000.c
@@ -221,6 +221,62 @@ static __init void exp_bus_init(void)
 	__raw_writel(EXP_CLK_EN | EXP_CS0_EN | EXP_CS4_EN, COMCERTO_EXP_CS_EN_R);
 }
 
+unsigned long get_arm_pll(void)
+{
+	u32 NR;
+	u32 OD;
+	u32 NF;
+	u32 reg = readl(COMCERTO_CLK_ARM_CLK_CNTRL);
+
+	NR = (reg & 0x003F0000) >> 16;
+	NF = (reg & 0x00001FFF);
+	reg = readl(COMCERTO_CLK_ARM_CLK_CNTRL2);
+	OD = (reg & 0x70000000) >> 28;
+
+	return REFCLKFREQ * (NF + 1) / (NR  + 1) / (OD  + 1);
+}
+
+unsigned long get_ahb_pll(void)
+{
+	u32 NR;
+	u32 OD;
+	u32 NF;
+	u32 reg = readl(COMCERTO_CLK_AHB_CLK_CNTRL);
+
+	NR = (reg & 0x003F0000) >> 16;
+	NF = (reg & 0x00001FFF);
+	reg = readl(COMCERTO_CLK_AHB_CLK_CNTRL2);
+	OD = (reg & 0x70000000) >> 28;
+
+	return REFCLKFREQ * (NF + 1) / (NR  + 1) / (OD  + 1);
+}
+
+unsigned long comcerto_get_ahb_clk(void)
+{
+	u32 sync_mode = readl(COMCERTO_CLK_AHB_CLK_CNTRL);
+
+	if (sync_mode & AHB_CLK_CNTRL_SYNC_MODE) {
+		u32 arm_pll = get_arm_pll();
+		if (sync_mode & AHB_CLK_CNTRL_SYNC_DIV_BYPASS) {
+			return arm_pll;
+		} else {
+			u32 div = (sync_mode >> 26) & 0x7;
+			return arm_pll / div;
+		}
+	} else {
+		u32 ahb_pll = get_ahb_pll();
+		u32 mode = readl(COMCERTO_CLK_AHB_CLK_CNTRL2);
+		u32 div = 1;
+
+		if (!(mode & AHB_CLK_CNTRL2_AHB_DIV0_BYPASS))
+			div = div * (mode & 0xF);
+		if (!(mode & AHB_CLK_CNTRL2_AHB_DIV1_BYPASS))
+			div = div * ((mode >> 4) & 0xF);
+
+		return ahb_pll / div;
+	}
+}
+
 void __init device_init(void)
 {
 	exp_bus_init();
diff --git a/arch/arm/mach-comcerto/cpufreq.c b/arch/arm/mach-comcerto/cpufreq.c
new file mode 100644
index 0000000..ce86b6f
--- /dev/null
+++ b/arch/arm/mach-comcerto/cpufreq.c
@@ -0,0 +1,190 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/cpufreq.h>
+#include <asm/system.h>
+
+#include <mach/hardware.h>
+#include <linux/netdevice.h>
+
+extern void pwr_mgmt_divide_frq(int component, int divider);
+extern void pwr_mgmt_restore_frq(int component);
+extern int pwr_mgmt_get_frq(int component);
+
+#define NR_FREQS        15
+
+#if defined(CONFIG_ARCH_M83XXX)
+static const unsigned short comcerto_clk_frqs[NR_FREQS] = {
+	433,   /*  43.3 MHz */
+	464,   /*  46.4 MHz */
+	500,   /*  50.0 MHz */
+	542,   /* 54.2 MHz */
+	591,   /* 59.1 MHz */
+	650,   /* 65.0 MHz */
+	722,   /* 72.2 MHz */
+	813,   /* 81.3 MHz */
+	929,   /* 92.9 MHz */
+	1083,   /* 108.3 MHz */
+	1300,   /* 130.0 MHz */
+	1625,   /* 162.5 MHz */
+	2167,   /* 216.7 MHz */
+	3250,   /* 325.0 MHz */
+	6500   /* 650.0 MHz */
+};
+#else
+static const unsigned short comcerto_clk_frqs[NR_FREQS] = {
+	300,   /*  30.0 MHz */
+	321,   /*  32.1 MHz */
+	346,   /*  34.6 MHz */
+	375,   /* 37.5 MHz */
+	409,   /* 40.9 MHz */
+	450,   /* 45.0 MHz */
+	500,   /* 50.0 MHz */
+	563,   /* 56.3 MHz */
+	643,   /* 64.3 MHz */
+	750,   /* 75.0 MHz */
+	900,   /* 90.0 MHz */
+	1125,   /* 112.5 MHz */
+	1500,   /* 150.0 MHz */
+	2250,   /* 225.0 MHz */
+	4500   /* 450.0 MHz */
+};
+#endif
+
+unsigned int comcerto_freq_to_indx(unsigned int khz)
+{
+	int i;
+
+	khz /= 100;
+
+	for (i = 0; i < NR_FREQS; i++)
+		if (comcerto_clk_frqs[i] >= khz)
+			break;
+
+	return i;
+}
+
+unsigned int comcerto_indx_to_freq(unsigned int idx)
+{
+	unsigned int freq = 0;
+
+	if (idx < NR_FREQS)
+		freq = comcerto_clk_frqs[idx] * 100;
+
+	return freq;
+}
+
+static int comcerto_verify_speed(struct cpufreq_policy *policy)
+{
+	unsigned int tmp;
+
+	cpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,
+					policy->cpuinfo.max_freq);
+
+	/* make sure that at least one frequency is within the policy */
+	tmp = comcerto_clk_frqs[comcerto_freq_to_indx(policy->min)] * 100;
+	if (tmp > policy->max)
+		policy->max = tmp;
+
+	cpufreq_verify_within_limits(policy, policy->cpuinfo.min_freq,
+					policy->cpuinfo.max_freq);
+
+	return 0;
+}
+
+static unsigned int comcerto_getspeed(unsigned int cpu)
+{
+	return pwr_mgmt_get_frq(cpu);
+}
+
+static int comcerto_set_target(struct cpufreq_policy *policy,
+				unsigned int target_freq,
+				unsigned int relation)
+{
+	struct cpufreq_freqs freqs;
+	unsigned int i, new_indx = 14;
+
+	switch (relation) {
+	case CPUFREQ_RELATION_L:
+		new_indx = comcerto_freq_to_indx(target_freq);
+		if (comcerto_indx_to_freq(new_indx) > policy->max)
+			new_indx--;
+		break;
+	case CPUFREQ_RELATION_H:
+		new_indx = comcerto_freq_to_indx(target_freq);
+		if ((comcerto_indx_to_freq(new_indx) > target_freq) &&
+			(comcerto_indx_to_freq(new_indx - 1) >=
+							policy->min))
+			new_indx--;
+		break;
+	}
+
+	freqs.cpu = 0;
+	freqs.old = comcerto_getspeed(freqs.cpu) * 1000;
+	freqs.new = comcerto_indx_to_freq(new_indx);
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+
+	policy->cur = freqs.new;
+	i = NR_FREQS - new_indx;
+
+	if (i > 1)
+		/* pwr_mgmt_divide_frq(COMPONENT_ARM1,i); */
+		pwr_mgmt_divide_frq(COMPONENT_ARM0, i);
+	else
+		/* pwr_mgmt_restore_frq(COMPONENT_ARM1); */
+		pwr_mgmt_restore_frq(COMPONENT_ARM0);
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+
+	return 0;
+}
+
+static int __init comcerto_cpu_init(struct cpufreq_policy *policy)
+{
+	policy->cur =  policy->max = comcerto_indx_to_freq(NR_FREQS - 1);
+	policy->min = comcerto_indx_to_freq(0);
+	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
+	policy->cpuinfo.min_freq = comcerto_indx_to_freq(0);
+	policy->cpuinfo.max_freq = comcerto_indx_to_freq(NR_FREQS - 1);
+	policy->cpuinfo.transition_latency = CPUFREQ_ETERNAL;
+
+	return 0;
+}
+
+static struct cpufreq_driver comcerto_driver = {
+	.flags = CPUFREQ_STICKY,
+	.verify = comcerto_verify_speed,
+	.target = comcerto_set_target,
+	.get = comcerto_getspeed,
+	.init = comcerto_cpu_init,
+	.name = "comcerto",
+};
+
+static int __init comcerto_cpufreq_init(void)
+{
+	int ret = 0;
+
+	ret = cpufreq_register_driver(&comcerto_driver);
+
+	return ret;
+}
+
+arch_initcall(comcerto_cpufreq_init);
+
+
diff --git a/arch/arm/mach-comcerto/cpufreq1.c b/arch/arm/mach-comcerto/cpufreq1.c
new file mode 100644
index 0000000..d6e9dd9
--- /dev/null
+++ b/arch/arm/mach-comcerto/cpufreq1.c
@@ -0,0 +1,112 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+
+extern void pwr_mgmt_divide_frq(int component, int divider);
+extern void pwr_mgmt_restore_frq(int component);
+extern int pwr_mgmt_get_frq(int component);
+
+#if defined(CONFIG_ARCH_M83XXX)
+/* TODO: Need to add support for SKUs */
+#define MAX_CPUFREQ 650000
+#define MIN_CPUFREQ 43300
+#else
+#define MAX_CPUFREQ 450000
+#define MIN_CPUFREQ 30000
+#endif
+
+static struct proc_dir_entry *arm1_proc_dir, *arm1_proc_file;
+ssize_t freq_write(struct file *filp, const char __user *buff,
+			unsigned long len, void *data)
+{
+	char info[10], *endp;
+	int freq, div = 1;
+
+	if (len > sizeof(info))
+		return -EINVAL;
+	if (copy_from_user(info, buff, len))
+		return -EFAULT;
+	freq = simple_strtol(info, &endp, 10);
+
+	if (freq > MAX_CPUFREQ || freq < MIN_CPUFREQ)
+		printk(KERN_ALERT "\nWarning: %d is not a valid CPU \
+					frequency\n", freq);
+	else {
+		div = MAX_CPUFREQ/freq;
+
+		if (div == 1)
+			pwr_mgmt_restore_frq(COMPONENT_ARM1);
+		else
+			pwr_mgmt_divide_frq(COMPONENT_ARM1, div);
+	}
+
+	return len;
+}
+
+int freq_read(char *page, char **start, off_t off,
+			int count, int *eof, void *data)
+{
+	int stat = 0;
+
+	stat += sprintf(page+stat, "ARM1 clock speed: %d Hz.\n",
+				pwr_mgmt_get_frq(COMPONENT_ARM1) * 1000);
+
+	return stat;
+}
+
+int procfile(void)
+{
+	arm1_proc_file = create_proc_entry("scaling_setspeed", 0644,
+						arm1_proc_dir);
+	if (arm1_proc_file == NULL) {
+		remove_proc_entry("arm1", arm1_proc_dir);
+		printk(KERN_ALERT "ERROR: Could not initialize /proc/%s\n",
+					"arm1");
+		return -ENOMEM;
+	} else {
+		arm1_proc_file->read_proc = freq_read;
+		arm1_proc_file->write_proc = freq_write;
+	}
+
+	return 0;
+}
+
+static int arm1_init(void)
+{
+	int ret = 0;
+
+	arm1_proc_dir = proc_mkdir("arm1", NULL);
+	procfile();
+
+	printk(KERN_INFO "arm1: Module loaded.\n");
+
+	return ret;
+}
+
+static void  arm1_exit(void)
+{
+	remove_proc_entry("arm1", arm1_proc_dir);
+	printk(KERN_INFO "arm1: Module unloaded.\n");
+}
+
+module_init(arm1_init);
+module_exit(arm1_exit);
+
+MODULE_LICENSE("GPL");
+
diff --git a/arch/arm/mach-comcerto/include/mach/comcerto-1000.h b/arch/arm/mach-comcerto/include/mach/comcerto-1000.h
index 7922a7a..9e996c9 100644
--- a/arch/arm/mach-comcerto/include/mach/comcerto-1000.h
+++ b/arch/arm/mach-comcerto/include/mach/comcerto-1000.h
@@ -25,6 +25,8 @@
 #define COMCERTO_PHYCLK			250 /* MHz */
 #define COMCERTO_ARMCLK			650 /* MHz */
 
+#define REFCLKFREQ                      24  /* MHz */
+
 /***** Physical address of IO on APB Bus *****/
 
 /*	0x001F0000 Reserved*/
@@ -96,4 +98,29 @@
 #include <mach/comcerto-1000/gpio.h>
 #include <mach/comcerto-1000/exp-bus.h>
 
+#ifndef __ASSEMBLY__
+typedef enum {
+	COMPONENT_ARM0,
+	COMPONENT_ARM1,
+	COMPONENT_GEMAC0,
+	COMPONENT_GEMAC1,
+	COMPONENT_USB0,
+	COMPONENT_TDM,
+	COMPONENT_IPSEC,
+	COMPONENT_UART0,
+	COMPONENT_UART1,
+	COMPONENT_I2C,
+	COMPONENT_SPI,
+	COMPONENT_MDMA,
+	COMPONENT_DDR,
+	COMPONENT_PCIE0,
+	COMPONENT_PCIE1,
+	COMPONENT_PCIEPHY,
+	COMPONENT_EXP,
+	COMPONENT_AHB
+} clk_down_components;
+
+unsigned long comcerto_get_ahb_clk(void);
+#endif
+
 #endif
diff --git a/arch/arm/mach-comcerto/pwrmgmt_c1000.c b/arch/arm/mach-comcerto/pwrmgmt_c1000.c
new file mode 100644
index 0000000..a653326
--- /dev/null
+++ b/arch/arm/mach-comcerto/pwrmgmt_c1000.c
@@ -0,0 +1,570 @@
+/*
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+
+#include <asm/io.h>
+#include <asm/mach/time.h>
+
+#include <mach/hardware.h>
+#include <mach/comcerto-1000/exp-bus.h>
+
+spinlock_t pm_lock;
+static int uart_state[2], i2cspi_state[2], gem_state[2], pcie_state[2];
+
+extern unsigned long get_arm_pll(void);
+extern unsigned long get_ahb_pll(void);
+
+void pwr_mgmt_clk_down(int component)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&pm_lock, flags);
+	switch (component) {
+	case COMPONENT_ARM0:
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) | ARM0_FCLK_PD |
+				ARM0_AHBCLK_PD, COMCERTO_CLK_CLK_PWR_DWN);
+		break;
+
+	case COMPONENT_ARM1:
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) | ARM1_FCLK_PD |
+				ARM1_AHBCLK_PD, COMCERTO_CLK_CLK_PWR_DWN);
+		break;
+
+	case COMPONENT_GEMAC0:
+		gem_state[0] = 1;
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) | GEMAC0_AHBCLK_PD |
+				GEMAC0_REFCLK_PD, COMCERTO_CLK_CLK_PWR_DWN);
+		goto gem_spnd;
+
+	case COMPONENT_GEMAC1:
+		gem_state[1] = 1;
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) | GEMAC1_AHBCLK_PD |
+				GEMAC1_REFCLK_PD, COMCERTO_CLK_CLK_PWR_DWN);
+
+gem_spnd:
+		if ((gem_state[0] == 1) && (gem_state[1] == 1))
+			writel(readl(COMCERTO_CLK_CLK_PWR_DWN) | PHY_REFCLK_PD,
+				COMCERTO_CLK_CLK_PWR_DWN);
+		break;
+
+	case COMPONENT_USB0:
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) | USB_AHBCLK_PD |
+				USB_REFCLK_PD, COMCERTO_CLK_CLK_PWR_DWN);
+		break;
+
+	case COMPONENT_TDM:
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) | TDM_AHBCLK_PD |
+				TDM_CLK_PD, COMCERTO_CLK_CLK_PWR_DWN);
+		break;
+
+	case COMPONENT_IPSEC:
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) | IPSEC_CORECLK_PD |
+				IPSEC_AHBCLK_PD | IPSEC2_AHBCLK_PD,
+				COMCERTO_CLK_CLK_PWR_DWN);
+		break;
+
+	case COMPONENT_UART0:
+		uart_state[0] = 1;
+		goto uart_spnd;
+
+	case COMPONENT_UART1:
+		uart_state[1] = 1;
+
+uart_spnd:
+		if (uart_state[0] == 1 && uart_state[1] == 1)
+			writel(readl(COMCERTO_CLK_CLK_PWR_DWN) | UART_AHBCLK_PD,
+				COMCERTO_CLK_CLK_PWR_DWN);
+		break;
+
+	case COMPONENT_I2C:
+		i2cspi_state[0] = 1;
+		goto i2cspi_spnd;
+
+	case COMPONENT_SPI:
+		i2cspi_state[1] = 1;
+
+i2cspi_spnd:
+		if (i2cspi_state[0] == 1 && i2cspi_state[1] == 1)
+			writel(readl(COMCERTO_CLK_CLK_PWR_DWN) |
+				I2CSPI_AHBCLK_PD, COMCERTO_CLK_CLK_PWR_DWN);
+		break;
+
+	case COMPONENT_MDMA:
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) | MDMA_AHBCLK_PD,
+				COMCERTO_CLK_CLK_PWR_DWN);
+		break;
+
+	case COMPONENT_DDR:
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) | DDRCTRL_AHBCLK_PD |
+				DDR_CLK_PD, COMCERTO_CLK_CLK_PWR_DWN);
+		break;
+
+	case COMPONENT_PCIE0:
+		pcie_state[0] = 1;
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) | PCIE0_AHBCLK_PD,
+				COMCERTO_CLK_CLK_PWR_DWN);
+		goto pcie_spnd;
+
+	case COMPONENT_PCIE1:
+		pcie_state[1] = 1;
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) | PCIE1_AHBCLK_PD,
+				COMCERTO_CLK_CLK_PWR_DWN);
+		if ((pcie_state[0] == 0) || (pcie_state[1] == 0))
+			break;
+
+pcie_spnd:
+	case COMPONENT_PCIEPHY:
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) | PCIE_REFCLK_NP_PD,
+				COMCERTO_CLK_CLK_PWR_DWN);
+		break;
+
+	case COMPONENT_EXP:
+		writel(readl(COMCERTO_EXP_CS_EN_R) & ~EXP_CLK_EN,
+				COMCERTO_EXP_CS_EN_R);
+		break;
+
+	default:
+		break;
+	}
+	spin_unlock_irqrestore(&pm_lock, flags);
+}
+EXPORT_SYMBOL(pwr_mgmt_clk_down);
+
+void pwr_mgmt_clk_restore(int component)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&pm_lock, flags);
+	switch (component) {
+	case COMPONENT_ARM0:
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) &
+				~(ARM0_FCLK_PD | ARM0_AHBCLK_PD),
+				COMCERTO_CLK_CLK_PWR_DWN);
+		break;
+
+	case COMPONENT_ARM1:
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) &
+				~(ARM1_FCLK_PD | ARM1_AHBCLK_PD),
+				COMCERTO_CLK_CLK_PWR_DWN);
+		break;
+
+	case COMPONENT_GEMAC0:
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) &
+				~(GEMAC0_AHBCLK_PD | GEMAC0_REFCLK_PD),
+				COMCERTO_CLK_CLK_PWR_DWN);
+		gem_state[0] = 0;
+		goto gem_spnd;
+
+	case COMPONENT_GEMAC1:
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) &
+				~(GEMAC1_AHBCLK_PD | GEMAC1_REFCLK_PD),
+				COMCERTO_CLK_CLK_PWR_DWN);
+		gem_state[1] = 0;
+
+gem_spnd:
+		if ((gem_state[0] == 0) || (gem_state[1] == 0))
+			writel(readl(COMCERTO_CLK_CLK_PWR_DWN) &
+				~PHY_REFCLK_PD, COMCERTO_CLK_CLK_PWR_DWN);
+		break;
+
+	case COMPONENT_USB0:
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) &
+				~(USB_AHBCLK_PD | USB_REFCLK_PD),
+				COMCERTO_CLK_CLK_PWR_DWN);
+		break;
+
+	case COMPONENT_TDM:
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) &
+				~(TDM_AHBCLK_PD | TDM_CLK_PD),
+				COMCERTO_CLK_CLK_PWR_DWN);
+		break;
+
+	case COMPONENT_IPSEC:
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) & ~
+			(IPSEC_AHBCLK_PD | IPSEC2_AHBCLK_PD | IPSEC_CORECLK_PD),
+			COMCERTO_CLK_CLK_PWR_DWN);
+		break;
+
+	case COMPONENT_UART0:
+		uart_state[0] = 0;
+		goto uart_rsm;
+
+	case COMPONENT_UART1:
+		uart_state[1] = 0;
+
+uart_rsm:
+		if (uart_state[0] == 0 || uart_state[1] == 0)
+			writel(readl(COMCERTO_CLK_CLK_PWR_DWN) &
+				~UART_AHBCLK_PD, COMCERTO_CLK_CLK_PWR_DWN);
+		break;
+
+	case COMPONENT_I2C:
+		i2cspi_state[0] = 0;
+		goto i2cspi_spnd;
+
+	case COMPONENT_SPI:
+		i2cspi_state[1] = 0;
+
+i2cspi_spnd:
+		if (i2cspi_state[0] == 0 || i2cspi_state[1] == 0)
+			writel(readl(COMCERTO_CLK_CLK_PWR_DWN) &
+				~I2CSPI_AHBCLK_PD, COMCERTO_CLK_CLK_PWR_DWN);
+		break;
+
+	case COMPONENT_MDMA:
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) & ~MDMA_AHBCLK_PD,
+				COMCERTO_CLK_CLK_PWR_DWN);
+		break;
+
+	case COMPONENT_DDR:
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) &
+				~(DDR_CLK_PD | DDRCTRL_AHBCLK_PD),
+				COMCERTO_CLK_CLK_PWR_DWN);
+		break;
+
+	case COMPONENT_PCIE0:
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) & ~PCIE0_AHBCLK_PD,
+				COMCERTO_CLK_CLK_PWR_DWN);
+		pcie_state[0] = 0;
+		goto pcie_spnd;
+
+	case COMPONENT_PCIE1:
+		writel(readl(COMCERTO_CLK_CLK_PWR_DWN) & ~PCIE1_AHBCLK_PD,
+				COMCERTO_CLK_CLK_PWR_DWN);
+		pcie_state[1] = 0;
+
+pcie_spnd:
+	case COMPONENT_PCIEPHY:
+		if (!(readl(COMCERTO_GPIO_SYSTEM_CONFIG) & PCIE_REFCLK_SRC))
+			writel(readl(COMCERTO_CLK_CLK_PWR_DWN) &
+				~PCIE_REFCLK_NP_PD, COMCERTO_CLK_CLK_PWR_DWN);
+		break;
+
+	case COMPONENT_EXP:
+		writel(readl(COMCERTO_EXP_CS_EN_R) | EXP_CLK_EN,
+				COMCERTO_EXP_CS_EN_R);
+		break;
+
+	default:
+		break;
+	}
+	spin_unlock_irqrestore(&pm_lock, flags);
+}
+EXPORT_SYMBOL(pwr_mgmt_clk_restore);
+
+void pwr_mgmt_divide_frq(int component, int divider)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&pm_lock, flags);
+	switch (component) {
+	case COMPONENT_ARM0:
+		writel((readl(COMCERTO_CLK_ARM_CLK_CNTRL2) & 0xFFFFFF00) |
+				(0x0 | divider), COMCERTO_CLK_ARM_CLK_CNTRL2);
+		break;
+
+	case COMPONENT_ARM1:
+		writel((readl(COMCERTO_CLK_ARM_CLK_CNTRL2) & 0xFFFF00FF) |
+				(0x0 | (divider << 8)),
+				COMCERTO_CLK_ARM_CLK_CNTRL2);
+		break;
+
+	case COMPONENT_IPSEC:
+		writel((readl(COMCERTO_CLK_DDR_PCIE_CLK_CNTRL) & 0x0FF0FFF0) |
+				(0x10000000 | (divider << 16)),
+				COMCERTO_CLK_DDR_PCIE_CLK_CNTRL);
+		break;
+
+	case COMPONENT_AHB:
+		writel((readl(COMCERTO_CLK_AHB_CLK_CNTRL2) & 0xFFFFFF0F) |
+				(0x0 | (divider << 4)),
+				COMCERTO_CLK_AHB_CLK_CNTRL2);
+		break;
+
+	default:
+		break;
+	}
+	spin_unlock_irqrestore(&pm_lock, flags);
+}
+EXPORT_SYMBOL(pwr_mgmt_divide_frq);
+
+
+void pwr_mgmt_restore_frq(int component)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&pm_lock, flags);
+	switch (component) {
+	case COMPONENT_ARM0:
+		writel(readl(COMCERTO_CLK_ARM_CLK_CNTRL2) | ARM0_DIV_BP,
+				COMCERTO_CLK_ARM_CLK_CNTRL2);
+		break;
+
+	case COMPONENT_ARM1:
+		writel(readl(COMCERTO_CLK_ARM_CLK_CNTRL2) | ARM1_DIV_BP,
+				COMCERTO_CLK_ARM_CLK_CNTRL2);
+		break;
+
+	case COMPONENT_IPSEC:
+		writel(readl(COMCERTO_CLK_DDR_PCIE_CLK_CNTRL) |
+				IPSEC1_DIV_BYPASS,
+				COMCERTO_CLK_DDR_PCIE_CLK_CNTRL);
+		writel(readl(COMCERTO_CLK_DDR_PCIE_CLK_CNTRL) & ~IPSEC_MUX_SEL,
+				COMCERTO_CLK_DDR_PCIE_CLK_CNTRL);
+		break;
+
+	case COMPONENT_AHB:
+		writel(readl(COMCERTO_CLK_AHB_CLK_CNTRL2) |
+				AHB_CLK_CNTRL2_AHB_DIV1_BYPASS,
+				COMCERTO_CLK_AHB_CLK_CNTRL2);
+		break;
+
+	default:
+		break;
+	}
+	spin_unlock_irqrestore(&pm_lock, flags);
+}
+EXPORT_SYMBOL(pwr_mgmt_restore_frq);
+
+int pwr_mgmt_clk_status(int component)
+{
+	int ret = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&pm_lock, flags);
+	switch (component) {
+	case COMPONENT_ARM0:
+		if (readl(COMCERTO_CLK_CLK_PWR_DWN) &
+				(ARM0_FCLK_PD | ARM0_AHBCLK_PD))
+			ret = 1;
+		break;
+
+	case COMPONENT_ARM1:
+		if (readl(COMCERTO_CLK_CLK_PWR_DWN) &
+				(ARM1_FCLK_PD | ARM1_AHBCLK_PD))
+			ret = 1;
+		break;
+
+	case COMPONENT_GEMAC0:
+		if (readl(COMCERTO_CLK_CLK_PWR_DWN) &
+				(GEMAC0_AHBCLK_PD | GEMAC0_REFCLK_PD))
+			ret = 1;
+		break;
+
+	case COMPONENT_GEMAC1:
+		if (readl(COMCERTO_CLK_CLK_PWR_DWN) &
+				(GEMAC1_AHBCLK_PD | GEMAC1_REFCLK_PD))
+			ret = 1;
+		break;
+
+	case COMPONENT_USB0:
+		if (readl(COMCERTO_CLK_CLK_PWR_DWN) &
+				(USB_AHBCLK_PD | USB_REFCLK_PD))
+			ret = 1;
+		break;
+
+	case COMPONENT_TDM:
+		if (readl(COMCERTO_CLK_CLK_PWR_DWN) &
+				(TDM_AHBCLK_PD | TDM_CLK_PD))
+			ret = 1;
+		break;
+
+	case COMPONENT_IPSEC:
+		if (readl(COMCERTO_CLK_CLK_PWR_DWN) & (IPSEC_CORECLK_PD |
+					IPSEC_AHBCLK_PD | IPSEC2_AHBCLK_PD))
+			ret = 1;
+		break;
+
+	case COMPONENT_UART0:
+	case COMPONENT_UART1:
+		if (readl(COMCERTO_CLK_CLK_PWR_DWN) & UART_AHBCLK_PD)
+			ret = 1;
+		break;
+
+	case COMPONENT_I2C:
+	case COMPONENT_SPI:
+		if (readl(COMCERTO_CLK_CLK_PWR_DWN) & I2CSPI_AHBCLK_PD)
+			ret = 1;
+		break;
+
+	case COMPONENT_MDMA:
+		if (readl(COMCERTO_CLK_CLK_PWR_DWN) & MDMA_AHBCLK_PD)
+			ret = 1;
+		break;
+
+	case COMPONENT_PCIE0:
+		if (readl(COMCERTO_CLK_CLK_PWR_DWN) & PCIE0_AHBCLK_PD)
+			ret = 1;
+		break;
+
+	case COMPONENT_PCIE1:
+		if (readl(COMCERTO_CLK_CLK_PWR_DWN) & PCIE1_AHBCLK_PD)
+			ret = 1;
+		break;
+
+	case COMPONENT_DDR:
+		if (readl(COMCERTO_CLK_CLK_PWR_DWN) &
+				(DDRCTRL_AHBCLK_PD | DDR_CLK_PD))
+			ret = 1;
+		break;
+
+	case COMPONENT_EXP:
+		if (!(readl(COMCERTO_EXP_CS_EN_R) & EXP_CLK_EN))
+			ret = 1;
+		break;
+
+	default:
+		ret = 99;
+	}
+	spin_unlock_irqrestore(&pm_lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(pwr_mgmt_clk_status);
+
+int get_arm0_clk(void)
+{
+	u32 mode = readl(COMCERTO_CLK_ARM_CLK_CNTRL2);
+
+	if (mode & ARM_CLK_CNTRL2_ARM0_AHB_BYPASS)
+		return comcerto_get_ahb_clk();
+	else {
+		u32 arm_pll = get_arm_pll();
+
+		if (mode & ARM_CLK_CNTRL2_ARM0_DIV_BYPASS)
+			return arm_pll;
+		else {
+			u32 div = mode & 0xf;
+
+			return arm_pll / div;
+		}
+	}
+}
+
+int get_arm1_clk(void)
+{
+	u32 mode = readl(COMCERTO_CLK_ARM_CLK_CNTRL2);
+
+	if (mode & ARM_CLK_CNTRL2_ARM1_AHB_BYPASS)
+		return comcerto_get_ahb_clk();
+	else {
+		u32 arm_pll = get_arm_pll();
+
+		if (mode & ARM_CLK_CNTRL2_ARM1_DIV_BYPASS)
+			return arm_pll;
+		else {
+			u32 div = (mode >> 8) & 0xf;
+
+			return arm_pll / div;
+		}
+	}
+}
+
+int get_ipsec_clk(void)
+{
+	u32 mux_sel = readl(COMCERTO_CLK_DDR_PCIE_CLK_CNTRL);
+
+	if (mux_sel & IPSEC_MUX_SEL) {
+		u32 arm_pll = get_arm_pll();
+
+		if (mux_sel & IPSEC1_DIV_BYPASS)
+			return arm_pll;
+		else {
+			u32 div = (mux_sel >> 16) & 0xf;
+			return arm_pll / div;
+		}
+	} else {
+		u32 ahb_pll = get_ahb_pll();
+
+		if (mux_sel & IPSEC0_DIV_BYPASS)
+			return ahb_pll;
+		else {
+			u32 div = (mux_sel >> 12) & 0xf;
+			return ahb_pll / div;
+		}
+	}
+}
+
+int pwr_mgmt_get_frq(int component)
+{
+	int ret = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&pm_lock, flags);
+	switch (component) {
+	case COMPONENT_ARM0:
+		ret = get_arm0_clk();
+		break;
+
+	case COMPONENT_ARM1:
+		ret = get_arm1_clk();
+		break;
+
+	case COMPONENT_AHB:
+		ret = comcerto_get_ahb_clk();
+		break;
+
+	case COMPONENT_IPSEC:
+		ret = get_ipsec_clk();
+		break;
+
+	default:
+		break;
+	}
+	spin_unlock_irqrestore(&pm_lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL(pwr_mgmt_get_frq);
+
+int pwr_mgmt_init(void)
+{
+	uart_state[0] = uart_state[1] = 0;
+	i2cspi_state[0] = i2cspi_state[1] = 0;
+	gem_state[0] = gem_state[1] = 0;
+	pcie_state[0] = pcie_state[1] = 0;
+
+	spin_lock_init(&pm_lock);
+
+#if !defined(CONFIG_COMCERTO_UART0_SUPPORT)
+	pwr_mgmt_clk_down(COMPONENT_UART0);
+#endif
+
+#if !defined(CONFIG_COMCERTO_UART1_SUPPORT)
+	pwr_mgmt_clk_down(COMPONENT_UART1);
+#endif
+
+#if !defined(CONFIG_I2C_COMCERTO_SUPPORT)
+	pwr_mgmt_clk_down(COMPONENT_I2C);
+#endif
+
+#if !defined(CONFIG_COMCERTO_SPI_SUPPORT)
+	pwr_mgmt_clk_down(COMPONENT_SPI);
+#endif
+
+#if !defined(CONFIG_USB_EHCI_COMCERTO_83XX)
+	pwr_mgmt_clk_down(COMPONENT_USB0);
+#endif
+
+#if !defined(CONFIG_COMCERTO_IPSEC_SUPPORT)
+	pwr_mgmt_clk_down(COMPONENT_IPSEC);
+#endif
+
+	return 0;
+}
-- 
1.6.5.2

