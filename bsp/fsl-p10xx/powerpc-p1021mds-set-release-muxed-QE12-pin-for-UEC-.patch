From 3f2917a3ab26526c789d6dd6e086cc17f6588915 Mon Sep 17 00:00:00 2001
From: Wei Yang <Wei.Yang@windriver.com>
Date: Wed, 13 Mar 2013 15:52:51 +0800
Subject: [PATCH 11/21] powerpc/p1021mds: set/release muxed QE12 pin for UEC
 MII and LBCTL

P1021 has QE_MDIO pin muxed with LBCTL pin, which is controlled by
PMUXCR[QE12]. For accessing mdio by probing mdio bus and read/write phy
registers, QE12 needs to be set together with QE9 to enable both
QE_MDIO and QE_MDC. However, after accessing mdio, QE12 needs to be
released so that eLBC can be accessed properly.

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
[Extracted from the P1021MDS-20101124-ltib.iso vendor drop.
Fixed context to apply to Wind River kernel tree.]
Signed-off-by: Wei Yang <Wei.Yang@windriver.com>
[Kevin: Check the SVR to make sure this is only applied to p1021.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/include/asm/mpc85xx.h           |    1 +
 arch/powerpc/platforms/85xx/Kconfig          |    9 ++++
 arch/powerpc/platforms/85xx/mpc85xx_mds.c    |    8 +---
 arch/powerpc/sysdev/fsl_soc.c                |   55 ++++++++++++++++++++++++++
 arch/powerpc/sysdev/fsl_soc.h                |    4 ++
 drivers/net/ethernet/freescale/fsl_pq_mdio.c |   27 +++++++++++++
 drivers/net/ethernet/freescale/ucc_geth.c    |   11 +++++
 7 files changed, 109 insertions(+), 6 deletions(-)

diff --git a/arch/powerpc/include/asm/mpc85xx.h b/arch/powerpc/include/asm/mpc85xx.h
index a49fead..c23bf15 100644
--- a/arch/powerpc/include/asm/mpc85xx.h
+++ b/arch/powerpc/include/asm/mpc85xx.h
@@ -54,6 +54,7 @@
 #define SVR_8572_E	0x80E800
 #define SVR_P1010	0x80f900
 #define SVR_P1010_E	0x80F100
+#define SVR_P1021	0x80E401
 #define SVR_P2041	0x821001
 #define SVR_P2041_E	0x821801
 #define SVR_P3041	0x821103
diff --git a/arch/powerpc/platforms/85xx/Kconfig b/arch/powerpc/platforms/85xx/Kconfig
index f3de28f..44eed54 100644
--- a/arch/powerpc/platforms/85xx/Kconfig
+++ b/arch/powerpc/platforms/85xx/Kconfig
@@ -70,6 +70,15 @@ config MPC85xx_MDS
 	help
 	  This option enables support for the MPC85xx MDS board
 
+config P1021_MDIO_MUX
+	bool "Set and clear MII pins for P1021"
+	depends on QUICC_ENGINE
+	depends on PPC_85xx
+	help
+	   P1021 has pins muxed for QE_MDIO and LBCTL, thus QE12 in PMUXCR needs
+	   to be set and released for accessing MIIM and eLBC.
+	default n
+
 config MPC8536_DS
 	bool "Freescale MPC8536 DS"
 	select DEFAULT_UIMAGE
diff --git a/arch/powerpc/platforms/85xx/mpc85xx_mds.c b/arch/powerpc/platforms/85xx/mpc85xx_mds.c
index 2a013cc..2004c4d 100644
--- a/arch/powerpc/platforms/85xx/mpc85xx_mds.c
+++ b/arch/powerpc/platforms/85xx/mpc85xx_mds.c
@@ -278,14 +278,10 @@ static void __init mpc85xx_mds_qe_init(void)
 			else{
 			/* P1021 has pins muxed for QE and other functions. To
 			 * enable QE UEC mode, we need to set bit QE0 for UCC1
-			 * in Eth mode, QE0 and QE3 for UCC5 in Eth mode, QE9
-			 * and QE12 for QE MII management signals in PMUXCR
-			 * register.
+			 * in Eth mode, QE0 and QE3 for UCC5 in Eth mode.
 			 */
 				setbits32(&guts->pmuxcr, MPC85xx_PMUXCR_QE(0) |
-						  MPC85xx_PMUXCR_QE(3) |
-						  MPC85xx_PMUXCR_QE(9) |
-						  MPC85xx_PMUXCR_QE(12));
+						  MPC85xx_PMUXCR_QE(3));
 				iounmap(guts);
 			}
 			of_node_put(np);
diff --git a/arch/powerpc/sysdev/fsl_soc.c b/arch/powerpc/sysdev/fsl_soc.c
index 5aebbf3..454fafa 100644
--- a/arch/powerpc/sysdev/fsl_soc.c
+++ b/arch/powerpc/sysdev/fsl_soc.c
@@ -41,6 +41,8 @@
 #include <mm/mmu_decl.h>
 #include <asm/cpm2.h>
 #include <asm/fsl_hcalls.h>	/* For the Freescale hypervisor */
+#include <asm/fsl_guts.h>
+#include <asm/mpc85xx.h>
 
 extern void init_fcc_ioports(struct fs_platform_info*);
 extern void init_fec_ioports(struct fs_platform_info*);
@@ -278,3 +280,56 @@ void fsl_hv_halt(void)
 	pr_info("hv exit\n");
 	fh_partition_stop(-1);
 }
+
+#ifdef CONFIG_P1021_MDIO_MUX
+/*
+ * P1021 has pins muxed for QE and other functions.
+ * Set QE9 and QE12 bit in PMUXCR register to enable QE_MDC and QE_MDIO, clear
+ * QE12 to release the QE_MDIO for LBCTL to allow the eLBC data buffer control.
+ * Please note the potential risk may occur if both QE_MDIO and LBCTL needs to
+ * be active simutaneously.
+ */
+void p1021_pmuxcr_mdio_mux(void)
+{
+	struct device_node *np;
+	struct ccsr_guts __iomem *guts;
+
+	if (!fsl_svr_is(SVR_P1021))
+		return;
+
+	np = of_find_node_by_name(NULL, "global-utilities");
+	if (np) {
+		guts = of_iomap(np, 0);
+		if (!guts)
+			pr_err("mpc85xx-mds: could not map global utilities register\n");
+		else
+			setbits32(&guts->pmuxcr, MPC85xx_PMUXCR_QE(9) |
+					  MPC85xx_PMUXCR_QE(12));
+		iounmap(guts);
+		of_node_put(np);
+	}
+}
+EXPORT_SYMBOL(p1021_pmuxcr_mdio_mux);
+
+void p1021_pmuxcr_lbctl_mux(void)
+{
+	struct device_node *np;
+	struct ccsr_guts __iomem *guts;
+
+	if (!fsl_svr_is(SVR_P1021))
+		return;
+
+	np = of_find_node_by_name(NULL, "global-utilities");
+	if (np) {
+		guts = of_iomap(np, 0);
+		if (!guts)
+			pr_err("mpc85xx-mds: could not map global utilities register\n");
+		else
+			clrbits32(&guts->pmuxcr, MPC85xx_PMUXCR_QE(12));
+		iounmap(guts);
+		of_node_put(np);
+	}
+}
+EXPORT_SYMBOL(p1021_pmuxcr_lbctl_mux);
+#endif /* CONFIG_P1021_MDIO_MUX */
+
diff --git a/arch/powerpc/sysdev/fsl_soc.h b/arch/powerpc/sysdev/fsl_soc.h
index b7d5ef7..3b5b525 100644
--- a/arch/powerpc/sysdev/fsl_soc.h
+++ b/arch/powerpc/sysdev/fsl_soc.h
@@ -67,5 +67,9 @@ static inline void mpc85xx_enter_jog(u64 ccsrbar, u32 powmgtreq)
 {
 	mpc85xx_enter_deep_sleep(ccsrbar, powmgtreq);
 }
+#ifdef CONFIG_P1021_MDIO_MUX
+extern void p1021_pmuxcr_mdio_mux(void);
+extern void p1021_pmuxcr_lbctl_mux(void);
+#endif /* CONFIG_P1021_MDIO_MUX */
 #endif
 #endif
diff --git a/drivers/net/ethernet/freescale/fsl_pq_mdio.c b/drivers/net/ethernet/freescale/fsl_pq_mdio.c
index 1e54f9f..6eb2654 100644
--- a/drivers/net/ethernet/freescale/fsl_pq_mdio.c
+++ b/drivers/net/ethernet/freescale/fsl_pq_mdio.c
@@ -30,6 +30,9 @@
 
 #include <asm/io.h>
 #include <asm/ucc.h>	/* for ucc_set_qe_mux_mii_mng() */
+#ifdef CONFIG_P1021_MDIO_MUX
+#include <sysdev/fsl_soc.h>
+#endif
 
 #include "gianfar.h"
 
@@ -105,6 +108,9 @@ static int fsl_pq_mdio_write(struct mii_bus *bus, int mii_id, int dev_addr, int
 	struct fsl_pq_mii __iomem *regs = priv->regs;
 	u32 status;
 
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_mdio_mux();
+#endif
 	/* Set the PHY address and the register address we want to write */
 	out_be32(&regs->miimadd, (mii_id << 8) | regnum);
 
@@ -115,6 +121,9 @@ static int fsl_pq_mdio_write(struct mii_bus *bus, int mii_id, int dev_addr, int
 	status = spin_event_timeout(!(in_be32(&regs->miimind) &	MIIMIND_BUSY),
 				    MII_TIMEOUT, 0);
 
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_lbctl_mux();
+#endif
 	return status ? 0 : -ETIMEDOUT;
 }
 
@@ -135,6 +144,9 @@ static int fsl_pq_mdio_read(struct mii_bus *bus, int mii_id, int dev_addr, int r
 	u32 status;
 	u16 value;
 
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_mdio_mux();
+#endif
 	/* Set the PHY address and the register address we want to read */
 	out_be32(&regs->miimadd, (mii_id << 8) | regnum);
 
@@ -153,6 +165,9 @@ static int fsl_pq_mdio_read(struct mii_bus *bus, int mii_id, int dev_addr, int r
 	value = in_be32(&regs->miimstat);
 
 	dev_dbg(&bus->dev, "read %04x from address %x/%x\n", value, mii_id, regnum);
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_lbctl_mux();
+#endif
 	return value;
 }
 
@@ -165,6 +180,9 @@ static int fsl_pq_mdio_reset(struct mii_bus *bus)
 
 	mutex_lock(&bus->mdio_lock);
 
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_mdio_mux();
+#endif
 	/* Reset the management interface */
 	out_be32(&regs->miimcfg, MIIMCFG_RESET);
 
@@ -175,6 +193,9 @@ static int fsl_pq_mdio_reset(struct mii_bus *bus)
 	status = spin_event_timeout(!(in_be32(&regs->miimind) &	MIIMIND_BUSY),
 				    MII_TIMEOUT, 0);
 
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_lbctl_mux();
+#endif
 	mutex_unlock(&bus->mdio_lock);
 
 	if (!status) {
@@ -438,7 +459,13 @@ static int fsl_pq_mdio_probe(struct platform_device *pdev)
 	if (data->ucc_configure)
 		data->ucc_configure(res.start, res.end);
 
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_mdio_mux();
+#endif
 	err = of_mdiobus_register(new_bus, np);
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_lbctl_mux();
+#endif
 	if (err) {
 		dev_err(&pdev->dev, "cannot register %s as MDIO bus\n",
 			new_bus->name);
diff --git a/drivers/net/ethernet/freescale/ucc_geth.c b/drivers/net/ethernet/freescale/ucc_geth.c
index 28edf3a..788d389 100644
--- a/drivers/net/ethernet/freescale/ucc_geth.c
+++ b/drivers/net/ethernet/freescale/ucc_geth.c
@@ -43,6 +43,10 @@
 
 #include "ucc_geth.h"
 
+#ifdef CONFIG_P1021_MDIO_MUX
+#include <sysdev/fsl_soc.h>
+#endif
+
 #undef DEBUG
 
 #define ugeth_printk(level, format, arg...)  \
@@ -3562,7 +3566,14 @@ static int ucc_geth_open(struct net_device *dev)
 		return -EINVAL;
 	}
 
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_mdio_mux();
+#endif
 	err = init_phy(dev);
+
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_lbctl_mux();
+#endif
 	if (err) {
 		if (netif_msg_ifup(ugeth))
 			ugeth_err("%s: Cannot initialize PHY, aborting.",
-- 
1.7.5.4

