From ecaa68b114e99be5b15caf4bc93dfa23c1b35589 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Wed, 22 Dec 2010 17:16:06 +0800
Subject: [PATCH] fsl_p2020/cgl/preempt_rt: force handling those nested threaded irqs dedicated to i8259

On fsl_p2020 i8259 existed on the South Bridge is connected to MPIC as a
cascaded interrupt controller and as you know the cascaded interrupt controller
irq is always not threaded. But those devices irqs from South Bridge would
be threaded. So we have to forcing handling those threaded irqs nested for
this i8259 irq cascaded to MPIC to make sure these irqs can handle
at appropriate time, i,e, PCI NIC irq should be handled immediately.

Here use handle_nested_irq() to handle those cascade_irq when this nested
i8259 irq is triggered. And so we cannot sleep within handle_nested_irq()
for the real interrupt context.

Additionally, set_irq_regs() always use smp_processor_id(). But for cgl/preempt_rt,
irq_exit() will enable preempt so it invoke the typical call trace about
using smp_processor_id() in preemptible. So push set_irq_regs before irq_exit() safely.

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/powerpc/kernel/irq.c                |    5 +++++
 arch/powerpc/platforms/85xx/mpc85xx_ds.c |    8 ++++++++
 kernel/irq/chip.c                        |    5 +++++
 3 files changed, 18 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/kernel/irq.c b/arch/powerpc/kernel/irq.c
index 8bf1148..cf35d90 100644
--- a/arch/powerpc/kernel/irq.c
+++ b/arch/powerpc/kernel/irq.c
@@ -415,8 +415,13 @@ void native_do_IRQ(struct pt_regs *regs)
 	else if (irq != NO_IRQ_IGNORE)
 		__get_cpu_var(irq_stat).spurious_irqs++;
 
+#ifdef CONFIG_PREEMPT_HARDIRQS
+	set_irq_regs(old_regs);
+#endif
 	irq_exit();
+#ifndef CONFIG_PREEMPT_HARDIRQS
 	set_irq_regs(old_regs);
+#endif
 
 #ifdef CONFIG_PPC_ISERIES
 	if (firmware_has_feature(FW_FEATURE_ISERIES) &&
diff --git a/arch/powerpc/platforms/85xx/mpc85xx_ds.c b/arch/powerpc/platforms/85xx/mpc85xx_ds.c
index 544011a..09b8bd8 100644
--- a/arch/powerpc/platforms/85xx/mpc85xx_ds.c
+++ b/arch/powerpc/platforms/85xx/mpc85xx_ds.c
@@ -51,6 +51,14 @@ static void mpc85xx_8259_cascade(unsigned int irq, struct irq_desc *desc)
 
 	if (cascade_irq != NO_IRQ) {
 		generic_handle_irq(cascade_irq);
+#ifdef CONFIG_PREEMPT_HARDIRQS
+		/* FIXME: we have to handle those threaded irqs nested for
+		 * this i8259 irq cascaded to MPIC to make sure these irqs
+		 * can handle at appropriate time, i,e, PCI NIC irq should
+		 * be handled immediately.
+		 */
+		handle_nested_irq(cascade_irq);
+#endif
 	}
 	desc->chip->eoi(irq);
 }
diff --git a/kernel/irq/chip.c b/kernel/irq/chip.c
index 77403e9..8731a29 100644
--- a/kernel/irq/chip.c
+++ b/kernel/irq/chip.c
@@ -393,7 +393,12 @@ void handle_nested_irq(unsigned int irq)
 	struct irqaction *action;
 	irqreturn_t action_ret;
 
+#ifndef CONFIG_PREEMPT_HARDIRQS
+	/* Sometimes we may call this on a non-threaded interrupt, so
+	 * we cannot sleep on interrupt contest.
+	 */
 	might_sleep();
+#endif
 
 	raw_spin_lock_irq(&desc->lock);
 
-- 
1.7.0

