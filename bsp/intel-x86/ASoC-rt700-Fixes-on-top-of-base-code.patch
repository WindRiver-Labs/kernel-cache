From d7d1cb6364bdfd3d403093dc1b0e9097f7a8fe9c Mon Sep 17 00:00:00 2001
From: bardliao <bardliao@realtek.com>
Date: Tue, 5 Jul 2016 19:45:58 +0800
Subject: [PATCH 3918/4301] ASoC: rt700: Fixes on top of base code.

commit 4c6643d57e7abb657926caa2b5c4efc24059301f from
git://git@github.com:01org/linux-intel-4.9.git

Following fixes are done on top of RT700 codec code.

1. Fix swap get and put func in SOC_DAPM_ENUM_EXT
2. Add hda dump list, and cat hda_reg will show the show all the values in
the list.  Add index_read function
3. Add index_read function to read realtek define registers.
4. Add SPK EAPD high
5. Set Speaker EVPD pin high.
6. Fix dump 4 bit hda verb error
7. Add rt700_hda_read function
8. Add rt700_hda_read function to simplify the code. Also, read the verbs
which be set in rt700_probe to check if these verbs is set properly.
9. Enable LINE2
10. Enable DMIC capture
11. Fix register of ADC 09 Capture Switch
12. Enable AMIC
13. Fix dapm status doesn't update
14. Add power management control
15. Fix dapm bias level
16. Add interrupt callback function
17. Configure codec clock
18. Set upscale_factor=1
19. Enable jack detection in probe
20. Fix upstream framework changes
21. Set D3 in the end of probe
22. Wait for slave enumeration in clock stop mode

Change-Id: I5a5d270097477f0b69635f3c4f26f1666c8cbe36
Signed-off-by: Shreyas NC <shreyas.nc@intel.com>
Signed-off-by: Bard Liao <bardliao@realtek.com>
Signed-off-by: Guneshwor Singh <guneshwor.o.singh@intel.com>
---
 sound/soc/codecs/rt700-sdw.c |   60 +++-
 sound/soc/codecs/rt700.c     |  839 +++++++++++++++++++++++++++++++++++++++---
 sound/soc/codecs/rt700.h     |   19 +
 3 files changed, 861 insertions(+), 57 deletions(-)

diff --git a/sound/soc/codecs/rt700-sdw.c b/sound/soc/codecs/rt700-sdw.c
index a629f57..a4e9efd 100644
--- a/sound/soc/codecs/rt700-sdw.c
+++ b/sound/soc/codecs/rt700-sdw.c
@@ -11,6 +11,7 @@
  * published by the Free Software Foundation.
  *
  */
+#define DEBUG
 
 #include <linux/delay.h>
 #include <linux/sdw_bus.h>
@@ -150,7 +151,7 @@ int hda_to_sdw(unsigned int nid, unsigned int verb, unsigned int payload,
 		unsigned int *sdw_addr_l, unsigned int *sdw_data_l) {
 	unsigned int offset_h, offset_l, e_verb;
 
-	if ((verb & 0xff) != 0) { /* 12 bits command */
+	if (((verb & 0xff) != 0) || verb == 0xf00) { /* 12 bits command */
 		if (verb == 0x7ff) /* special case */
 			offset_h = 0;
 		else
@@ -192,9 +193,9 @@ static int rt700_register_sdw_capabilties(struct sdw_slave *sdw,
 	struct sdw_slv_dpn_capabilities *dpn_cap = NULL;
 	struct port_audio_mode_properties *prop = NULL;
 	unsigned int bus_config_frequencies[] = {
-		2400000, 4800000, 9600000, 3000000, 6000000, 12000000};
+		2400000, 4800000, 9600000, 3000000, 6000000, 12000000, 19200000};
 	unsigned int freq_supported[] = {
-		2400000, 4800000, 9600000, 12000000, 12288000};
+		19200000, 2400000, 4800000, 9600000, 12000000, 12288000};
 	int i, j;
 
 	cap.wake_up_unavailable = false;
@@ -205,8 +206,9 @@ static int rt700_register_sdw_capabilties(struct sdw_slave *sdw,
 	cap.paging_supported = false;
 	cap.bank_delay_support = false;
 	cap.port_15_read_behavior = 1;
-	cap.sdw_dp0_supported = true;
+	cap.sdw_dp0_supported = false;
 	cap.num_of_sdw_ports = 8; /* Inport 4, Outport 4 */
+	cap.scp_impl_def_intr_mask = 0x4;
 	cap.sdw_dp0_cap = devm_kzalloc(&sdw->dev,
 			sizeof(struct sdw_slv_dp0_capabilities), GFP_KERNEL);
 
@@ -221,9 +223,9 @@ static int rt700_register_sdw_capabilties(struct sdw_slave *sdw,
 	/* Address 0x0001, bit 0: port ready, bit 2: BRA failure*/
 	cap.sdw_dp0_cap->imp_def_intr_mask = 0;
 	cap.sdw_dp0_cap->impl_def_bpt_supported = true;
-	cap.sdw_dp0_cap->slave_bra_cap.max_bus_frequency = 12000000;
+	cap.sdw_dp0_cap->slave_bra_cap.max_bus_frequency = 24000000;
 	cap.sdw_dp0_cap->slave_bra_cap.min_bus_frequency = 2400000;
-	cap.sdw_dp0_cap->slave_bra_cap.num_bus_config_frequency = 6;
+	cap.sdw_dp0_cap->slave_bra_cap.num_bus_config_frequency = 7;
 	cap.sdw_dp0_cap->slave_bra_cap.bus_config_frequencies =
 						bus_config_frequencies;
 	cap.sdw_dp0_cap->slave_bra_cap.max_data_per_frame = 470;
@@ -267,10 +269,19 @@ static int rt700_register_sdw_capabilties(struct sdw_slave *sdw,
 				dpn_cap->num_audio_modes), GFP_KERNEL);
 		for (j = 0; j < dpn_cap->num_audio_modes; j++) {
 			prop = &dpn_cap->mode_properties[j];
-			prop->max_frequency = 12288000;
+			prop->max_frequency = 24000000;
 			prop->min_frequency = 2400000;
-			prop->num_freq_configs = 5;
-			prop->freq_supported = freq_supported;
+			prop->num_freq_configs = 0;
+			prop->freq_supported = devm_kzalloc(&sdw->dev,
+						    prop->num_freq_configs *
+						    (sizeof(unsigned int)),
+						    GFP_KERNEL);
+			if (!prop->freq_supported)
+				return -ENOMEM;
+
+			memcpy(prop->freq_supported, freq_supported,
+						    prop->num_freq_configs *
+						    (sizeof(unsigned int)));
 			prop->glitchless_transitions_mask = 0x0;
 			prop->max_sampling_frequency = 192000;
 			prop->min_sampling_frequency = 8000;
@@ -285,15 +296,26 @@ static int rt700_register_sdw_capabilties(struct sdw_slave *sdw,
 static int rt700_sdw_probe(struct sdw_slave *sdw,
 				 const struct sdw_slave_id *sdw_id)
 {
+	struct alc700 *alc700_priv;
 	struct regmap *regmap;
 	int ret;
 
+	alc700_priv = kzalloc(sizeof(struct alc700), GFP_KERNEL);
+	if(!alc700_priv) {
+		return -ENOMEM;
+	}
+	dev_set_drvdata(&sdw->dev, alc700_priv);
+	alc700_priv->sdw = sdw;
+	alc700_priv->params = kzalloc(sizeof(struct sdw_bus_params), GFP_KERNEL);
 	regmap = devm_regmap_init_sdw(sdw, &rt700_sdw_regmap);
 	if (!regmap)
 		return -EINVAL;
 	ret = rt700_register_sdw_capabilties(sdw, sdw_id);
 	if (ret)
 		return ret;
+	ret = sdw_slave_get_bus_params(sdw, alc700_priv->params);
+	if (ret)
+		return -EFAULT;
 	return rt700_probe(&sdw->dev, regmap, sdw);
 }
 
@@ -319,11 +341,29 @@ static const struct sdw_slave_id rt700_id[] = {
 	{"15:02:5d:07:01:00", 0},
 	{"16:02:5d:07:01:00", 0},
 	{"17:02:5d:07:01:00", 0},
+	{"10:02:5d:07:00:01", 0},
 	{}
 };
 
 MODULE_DEVICE_TABLE(sdw, rt700_id);
 
+
+static int rt700_sdw_handle_impl_def_interrupts(struct sdw_slave *swdev,
+		struct sdw_impl_def_intr_stat *intr_status)
+{
+	struct rt700_priv *rt700 = dev_get_drvdata(&swdev->dev);
+	bool hp, mic;
+
+	pr_debug("%s control_port_stat=%x port0_stat=%x\n", __func__,
+		intr_status->control_port_stat, intr_status->port0_stat);
+	if (intr_status->control_port_stat & 0x4) {
+		rt700_jack_detect(rt700, &hp, &mic);
+		pr_info("%s hp=%d mic=%d\n", __func__, hp, mic);
+	}
+
+	return 0;
+}
+
 static struct sdw_slave_driver rt700_sdw_driver = {
 	.driver_type = SDW_DRIVER_TYPE_SLAVE,
 	.driver = {
@@ -332,6 +372,8 @@ static struct sdw_slave_driver rt700_sdw_driver = {
 		   },
 	.probe = rt700_sdw_probe,
 	.remove = rt700_sdw_remove,
+	.handle_impl_def_interrupts = rt700_sdw_handle_impl_def_interrupts,
+
 	.id_table = rt700_id,
 };
 
diff --git a/sound/soc/codecs/rt700.c b/sound/soc/codecs/rt700.c
index 64614b2..61606fb 100644
--- a/sound/soc/codecs/rt700.c
+++ b/sound/soc/codecs/rt700.c
@@ -39,6 +39,7 @@
 #include <sound/soc-dapm.h>
 #include <sound/initval.h>
 #include <sound/tlv.h>
+#include <sound/hda_verbs.h>
 
 #include "rt700.h"
 
@@ -46,6 +47,425 @@ struct sdw_stream_data {
 	int stream_tag;
 };
 
+struct hda_cmd {
+	u16 vid;
+	u8 nid;
+	u16 payload;
+};
+
+static struct hda_cmd hda_dump_list[] = {
+	/* vid, nid, payload */
+	{0xf00, 0x00,  0x00}, /* Vendor ID */
+#if 0
+	{0xf00, 0x00,  0x02}, /* Revision ID */
+	{0xf00, 0x00,  0x04}, /* Subordinate Node Count */
+	{0xf00, 0x01,  0x04}, /* Subordinate Node Count */
+	{0xf00, 0x01,  0x05}, /* Function Group Type */
+	{0xf00, 0x01,  0x08}, /* Audio Function Capabilities */
+	{0xf00, 0x00,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x01,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x02,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x03,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x04,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x05,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x06,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x07,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x08,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x09,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x0a,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x27,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x22,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x23,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x24,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x25,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x14,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x15,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x17,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x18,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x29,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x19,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x1a,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x1b,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x16,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x1d,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x21,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x1e,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x1f,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x12,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x13,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x20,  0x09}, /* Audio Widget Capabilities */
+	{0xf00, 0x01,  0x0a}, /* Supported PCM Size, Rates */
+	{0xf00, 0x02,  0x0a}, /* Supported PCM Size, Rates */
+	{0xf00, 0x03,  0x0a}, /* Supported PCM Size, Rates */
+	{0xf00, 0x04,  0x0a}, /* Supported PCM Size, Rates */
+	{0xf00, 0x05,  0x0a}, /* Supported PCM Size, Rates */
+	{0xf00, 0x06,  0x0a}, /* Supported PCM Size, Rates */
+	{0xf00, 0x07,  0x0a}, /* Supported PCM Size, Rates */
+	{0xf00, 0x08,  0x0a}, /* Supported PCM Size, Rates */
+	{0xf00, 0x09,  0x0a}, /* Supported PCM Size, Rates */
+	{0xf00, 0x0a,  0x0a}, /* Supported PCM Size, Rates */
+	{0xf00, 0x27,  0x0a}, /* Supported PCM Size, Rates */
+	{0xf00, 0x01,  0x0b}, /* Supported Stream Formats */
+	{0xf00, 0x02,  0x0b}, /* Supported Stream Formats */
+	{0xf00, 0x03,  0x0b}, /* Supported Stream Formats */
+	{0xf00, 0x04,  0x0b}, /* Supported Stream Formats */
+	{0xf00, 0x05,  0x0b}, /* Supported Stream Formats */
+	{0xf00, 0x06,  0x0b}, /* Supported Stream Formats */
+	{0xf00, 0x07,  0x0b}, /* Supported Stream Formats */
+	{0xf00, 0x08,  0x0b}, /* Supported Stream Formats */
+	{0xf00, 0x09,  0x0b}, /* Supported Stream Formats */
+	{0xf00, 0x0a,  0x0b}, /* Supported Stream Formats */
+	{0xf00, 0x27,  0x0b}, /* Supported Stream Formats */
+	{0xf00, 0x12,  0x0c}, /* Pin Capabilities */
+	{0xf00, 0x13,  0x0c}, /* Pin Capabilities */
+	{0xf00, 0x14,  0x0c}, /* Pin Capabilities */
+	{0xf00, 0x15,  0x0c}, /* Pin Capabilities */
+	{0xf00, 0x16,  0x0c}, /* Pin Capabilities */
+	{0xf00, 0x17,  0x0c}, /* Pin Capabilities */
+	{0xf00, 0x18,  0x0c}, /* Pin Capabilities */
+	{0xf00, 0x19,  0x0c}, /* Pin Capabilities */
+	{0xf00, 0x1a,  0x0c}, /* Pin Capabilities */
+	{0xf00, 0x1b,  0x0c}, /* Pin Capabilities */
+	{0xf00, 0x1d,  0x0c}, /* Pin Capabilities */
+	{0xf00, 0x1e,  0x0c}, /* Pin Capabilities */
+	{0xf00, 0x1f,  0x0c}, /* Pin Capabilities */
+	{0xf00, 0x21,  0x0c}, /* Pin Capabilities */
+	{0xf00, 0x29,  0x0c}, /* Pin Capabilities */
+	{0xf00, 0x07,  0x0d}, /* Amplifier Capabilities */
+	{0xf00, 0x08,  0x0d}, /* Amplifier Capabilities */
+	{0xf00, 0x09,  0x0d}, /* Amplifier Capabilities */
+	{0xf00, 0x12,  0x0d}, /* Amplifier Capabilities */
+	{0xf00, 0x13,  0x0d}, /* Amplifier Capabilities */
+	{0xf00, 0x18,  0x0d}, /* Amplifier Capabilities */
+	{0xf00, 0x19,  0x0d}, /* Amplifier Capabilities */
+	{0xf00, 0x1a,  0x0d}, /* Amplifier Capabilities */
+	{0xf00, 0x1b,  0x0d}, /* Amplifier Capabilities */
+	{0xf00, 0x22,  0x0d}, /* Amplifier Capabilities */
+	{0xf00, 0x23,  0x0d}, /* Amplifier Capabilities */
+	{0xf00, 0x24,  0x0d}, /* Amplifier Capabilities */
+	{0xf00, 0x25,  0x0d}, /* Amplifier Capabilities */
+	{0xf00, 0x29,  0x0d}, /* Amplifier Capabilities */
+	{0xf00, 0x02,  0x12}, /* Output Amplifiers */
+	{0xf00, 0x03,  0x12}, /* Output Amplifiers */
+	{0xf00, 0x14,  0x12}, /* Output Amplifiers */
+	{0xf00, 0x15,  0x12}, /* Output Amplifiers */
+	{0xf00, 0x16,  0x12}, /* Output Amplifiers */
+	{0xf00, 0x17,  0x12}, /* Output Amplifiers */
+	{0xf00, 0x1a,  0x12}, /* Output Amplifiers */
+	{0xf00, 0x1b,  0x12}, /* Output Amplifiers */
+	{0xf00, 0x21,  0x12}, /* Output Amplifiers */
+	{0xf00, 0x07,  0x0e}, /* Connect List Length */
+	{0xf00, 0x08,  0x0e}, /* Connect List Length */
+	{0xf00, 0x09,  0x0e}, /* Connect List Length */
+	{0xf00, 0x0a,  0x0e}, /* Connect List Length */
+	{0xf00, 0x27,  0x0e}, /* Connect List Length */
+	{0xf00, 0x22,  0x0e}, /* Connect List Length */
+	{0xf00, 0x23,  0x0e}, /* Connect List Length */
+	{0xf00, 0x24,  0x0e}, /* Connect List Length */
+	{0xf00, 0x25,  0x0e}, /* Connect List Length */
+	{0xf00, 0x14,  0x0e}, /* Connect List Length */
+	{0xf00, 0x15,  0x0e}, /* Connect List Length */
+	{0xf00, 0x16,  0x0e}, /* Connect List Length */
+	{0xf00, 0x17,  0x0e}, /* Connect List Length */
+	{0xf00, 0x18,  0x0e}, /* Connect List Length */
+	{0xf00, 0x19,  0x0e}, /* Connect List Length */
+	{0xf00, 0x1a,  0x0e}, /* Connect List Length */
+	{0xf00, 0x1b,  0x0e}, /* Connect List Length */
+	{0xf00, 0x1d,  0x0e}, /* Connect List Length */
+	{0xf00, 0x21,  0x0e}, /* Connect List Length */
+	{0xf00, 0x1e,  0x0e}, /* Connect List Length */
+	{0xf00, 0x1f,  0x0e}, /* Connect List Length */
+	{0xf00, 0x12,  0x0e}, /* Connect List Length */
+	{0xf00, 0x13,  0x0e}, /* Connect List Length */
+	{0xf00, 0x29,  0x0e}, /* Connect List Length */
+	{0xf00, 0x01,  0x0f}, /* Supported Power States */
+	{0xf00, 0x02,  0x0f}, /* Supported Power States */
+	{0xf00, 0x03,  0x0f}, /* Supported Power States */
+	{0xf00, 0x04,  0x0f}, /* Supported Power States */
+	{0xf00, 0x05,  0x0f}, /* Supported Power States */
+	{0xf00, 0x06,  0x0f}, /* Supported Power States */
+	{0xf00, 0x07,  0x0f}, /* Supported Power States */
+	{0xf00, 0x08,  0x0f}, /* Supported Power States */
+	{0xf00, 0x09,  0x0f}, /* Supported Power States */
+	{0xf00, 0x0a,  0x0f}, /* Supported Power States */
+	{0xf00, 0x27,  0x0f}, /* Supported Power States */
+	{0xf00, 0x22,  0x0f}, /* Supported Power States */
+	{0xf00, 0x23,  0x0f}, /* Supported Power States */
+	{0xf00, 0x24,  0x0f}, /* Supported Power States */
+	{0xf00, 0x21,  0x0f}, /* Supported Power States */
+	{0xf00, 0x12,  0x0f}, /* Supported Power States */
+	{0xf00, 0x13,  0x0f}, /* Supported Power States */
+	{0xf00, 0x14,  0x0f}, /* Supported Power States */
+	{0xf00, 0x15,  0x0f}, /* Supported Power States */
+	{0xf00, 0x16,  0x0f}, /* Supported Power States */
+	{0xf00, 0x17,  0x0f}, /* Supported Power States */
+	{0xf00, 0x18,  0x0f}, /* Supported Power States */
+	{0xf00, 0x19,  0x0f}, /* Supported Power States */
+	{0xf00, 0x1a,  0x0f}, /* Supported Power States */
+	{0xf00, 0x1b,  0x0f}, /* Supported Power States */
+	{0xf00, 0x1d,  0x0f}, /* Supported Power States */
+	{0xf00, 0x1e,  0x0f}, /* Supported Power States */
+	{0xf00, 0x1f,  0x0f}, /* Supported Power States */
+	{0xf00, 0x29,  0x0f}, /* Supported Power States */
+	{0xf00, 0x0b,  0x0f}, /* Supported Power States */
+	{0xf00, 0x0c,  0x0f}, /* Supported Power States */
+	{0xf00, 0x0d,  0x0f}, /* Supported Power States */
+	{0xf00, 0x0e,  0x0f}, /* Supported Power States */
+	{0xf00, 0x0f,  0x0f}, /* Supported Power States */
+	{0xf00, 0x10,  0x0f}, /* Supported Power States */
+	{0xf00, 0x11,  0x0f}, /* Supported Power States */
+	{0xf00, 0x1c,  0x0f}, /* Supported Power States */
+	{0xf00, 0x20,  0x0f}, /* Supported Power States */
+	{0xf00, 0x26,  0x0f}, /* Supported Power States */
+	{0xf00, 0x28,  0x0f}, /* Supported Power States */
+	{0xf00, 0x20,  0x10}, /* Processing Capabilities */
+	{0xf00, 0x53,  0x10}, /* Processing Capabilities */
+	{0xf00, 0x54,  0x10}, /* Processing Capabilities */
+	{0xf00, 0x55,  0x10}, /* Processing Capabilities */
+	{0xf00, 0x56,  0x10}, /* Processing Capabilities */
+	{0xf00, 0x57,  0x10}, /* Processing Capabilities */
+	{0xf00, 0x58,  0x10}, /* Processing Capabilities */
+	{0xf00, 0x5b,  0x10}, /* Processing Capabilities */
+	{0xf00, 0x60,  0x10}, /* Processing Capabilities */
+	{0xf00, 0x01,  0x11}, /* GPIO Capabilities */
+	{0xf00, 0x00,  0x16}, /* Statically Switchable BCLK Clock Frequency */
+	{0xf00, 0x00,  0x17}, /* Interface Type Capability */
+#endif
+	{0xf01, 0x14,  0x00}, /* Connection Select Control */
+	{0xf01, 0x15,  0x00}, /* Connection Select Control */
+	{0xf01, 0x16,  0x00}, /* Connection Select Control */
+	{0xf01, 0x1b,  0x00}, /* Connection Select Control */
+	{0xf01, 0x21,  0x00}, /* Connection Select Control */
+	{0xf01, 0x22,  0x00}, /* Connection Select Control */
+	{0xf01, 0x23,  0x00}, /* Connection Select Control */
+	{0xf01, 0x24,  0x00}, /* Connection Select Control */
+	{0xf01, 0x25,  0x00}, /* Connection Select Control */
+	{0xf02, 0x07,  0x00}, /* Connection List Entry */
+	{0xf02, 0x08,  0x00}, /* Connection List Entry */
+	{0xf02, 0x09,  0x00}, /* Connection List Entry */
+	{0xf02, 0x0a,  0x00}, /* Connection List Entry */
+	{0xf02, 0x14,  0x00}, /* Connection List Entry */
+	{0xf02, 0x15,  0x00}, /* Connection List Entry */
+	{0xf02, 0x16,  0x00}, /* Connection List Entry */
+	{0xf02, 0x1b,  0x00}, /* Connection List Entry */
+	{0xf02, 0x21,  0x00}, /* Connection List Entry */
+	{0xf02, 0x1e,  0x00}, /* Connection List Entry */
+	{0xf02, 0x21,  0x00}, /* Connection List Entry */
+	{0xf02, 0x23,  0x00}, /* Connection List Entry */
+	{0xf02, 0x24,  0x00}, /* Connection List Entry */
+	{0xf02, 0x25,  0x00}, /* Connection List Entry */
+	{0xd00, 0x20,  0x00}, /* Coefficient Index */
+	{0xd00, 0x53,  0x00}, /* Coefficient Index */
+	{0xd00, 0x54,  0x00}, /* Coefficient Index */
+	{0xd00, 0x56,  0x00}, /* Coefficient Index */
+	{0xd00, 0x57,  0x00}, /* Coefficient Index */
+	{0xd00, 0x58,  0x00}, /* Coefficient Index */
+	{0xc00, 0x20,  0x00}, /* Processing Coefficient */
+	{0xc00, 0x53,  0x00}, /* Processing Coefficient */
+	{0xc00, 0x54,  0x00}, /* Processing Coefficient */
+	{0xc00, 0x56,  0x00}, /* Processing Coefficient */
+	{0xc00, 0x57,  0x00}, /* Processing Coefficient */
+	{0xc00, 0x58,  0x00}, /* Processing Coefficient */
+	{0xb00, 0x02,  0x8000}, /* Amplifier Gain */
+	{0xb00, 0x02,  0xa000}, /* Amplifier Gain */
+	{0xb00, 0x03,  0x8000}, /* Amplifier Gain */
+	{0xb00, 0x03,  0xa000}, /* Amplifier Gain */
+	{0xb00, 0x07,  0x0000}, /* Amplifier Gain */
+	{0xb00, 0x07,  0x2000}, /* Amplifier Gain */
+	{0xb00, 0x08,  0x0000}, /* Amplifier Gain */
+	{0xb00, 0x08,  0x2000}, /* Amplifier Gain */
+	{0xb00, 0x09,  0x0000}, /* Amplifier Gain */
+	{0xb00, 0x09,  0x2000}, /* Amplifier Gain */
+	{0xb00, 0x1b,  0x8000}, /* Amplifier Gain */
+	{0xb00, 0x1b,  0xa000}, /* Amplifier Gain */
+	{0xb00, 0x1b,  0x0000}, /* Amplifier Gain */
+	{0xb00, 0x1b,  0x2000}, /* Amplifier Gain */
+	{0xb00, 0x12,  0x0000}, /* Amplifier Gain */
+	{0xb00, 0x12,  0x2000}, /* Amplifier Gain */
+	{0xb00, 0x13,  0x0000}, /* Amplifier Gain */
+	{0xb00, 0x13,  0x2000}, /* Amplifier Gain */
+	{0xb00, 0x19,  0x0000}, /* Amplifier Gain */
+	{0xb00, 0x19,  0x2000}, /* Amplifier Gain */
+	{0xb00, 0x1a,  0x0000}, /* Amplifier Gain */
+	{0xb00, 0x1a,  0x2000}, /* Amplifier Gain */
+	{0xb00, 0x14,  0x8000}, /* Amplifier Gain */
+	{0xb00, 0x14,  0xa000}, /* Amplifier Gain */
+	{0xb00, 0x15,  0x8000}, /* Amplifier Gain */
+	{0xb00, 0x15,  0xa000}, /* Amplifier Gain */
+	{0xb00, 0x16,  0x8000}, /* Amplifier Gain */
+	{0xb00, 0x16,  0xa000}, /* Amplifier Gain */
+	{0xb00, 0x17,  0x8000}, /* Amplifier Gain */
+	{0xb00, 0x17,  0xa000}, /* Amplifier Gain */
+	{0xb00, 0x21,  0x8000}, /* Amplifier Gain */
+	{0xb00, 0x21,  0xa000}, /* Amplifier Gain */
+	{0xa00, 0x02,  0x0000}, /* Converter Format */
+	{0xa00, 0x03,  0x0000}, /* Converter Format */
+	{0xa00, 0x04,  0x0000}, /* Converter Format */
+	{0xa00, 0x05,  0x0000}, /* Converter Format */
+	{0xa00, 0x06,  0x0000}, /* Converter Format */
+	{0xa00, 0x07,  0x0000}, /* Converter Format */
+	{0xa00, 0x08,  0x0000}, /* Converter Format */
+	{0xa00, 0x09,  0x0000}, /* Converter Format */
+	{0xa00, 0x0a,  0x0000}, /* Converter Format */
+	{0xa00, 0x27,  0x0000}, /* Converter Format */
+	{0xf05, 0x01,  0x00}, /* Power State */
+	{0xf05, 0x02,  0x00}, /* Power State */
+	{0xf05, 0x03,  0x00}, /* Power State */
+	{0xf05, 0x04,  0x00}, /* Power State */
+	{0xf05, 0x05,  0x00}, /* Power State */
+	{0xf05, 0x06,  0x00}, /* Power State */
+	{0xf05, 0x07,  0x00}, /* Power State */
+	{0xf05, 0x08,  0x00}, /* Power State */
+	{0xf05, 0x09,  0x00}, /* Power State */
+	{0xf05, 0x0a,  0x00}, /* Power State */
+	{0xf05, 0x12,  0x00}, /* Power State */
+	{0xf05, 0x13,  0x00}, /* Power State */
+	{0xf05, 0x14,  0x00}, /* Power State */
+	{0xf05, 0x15,  0x00}, /* Power State */
+	{0xf05, 0x16,  0x00}, /* Power State */
+	{0xf05, 0x17,  0x00}, /* Power State */
+	{0xf05, 0x18,  0x00}, /* Power State */
+	{0xf05, 0x19,  0x00}, /* Power State */
+	{0xf05, 0x1a,  0x00}, /* Power State */
+	{0xf05, 0x1b,  0x00}, /* Power State */
+	{0xf05, 0x1d,  0x00}, /* Power State */
+	{0xf05, 0x1e,  0x00}, /* Power State */
+	{0xf05, 0x1f,  0x00}, /* Power State */
+	{0xf05, 0x21,  0x00}, /* Power State */
+	{0xf05, 0x27,  0x00}, /* Power State */
+	{0xf05, 0x29,  0x00}, /* Power State */
+	{0xf06, 0x02,  0x00}, /* Converter Stream, Channel */
+	{0xf06, 0x03,  0x00}, /* Converter Stream, Channel */
+	{0xf06, 0x04,  0x00}, /* Converter Stream, Channel */
+	{0xf06, 0x05,  0x00}, /* Converter Stream, Channel */
+	{0xf06, 0x06,  0x00}, /* Converter Stream, Channel */
+	{0xf06, 0x07,  0x00}, /* Converter Stream, Channel */
+	{0xf06, 0x08,  0x00}, /* Converter Stream, Channel */
+	{0xf06, 0x09,  0x00}, /* Converter Stream, Channel */
+	{0xf06, 0x0a,  0x00}, /* Converter Stream, Channel */
+	{0xf06, 0x27,  0x00}, /* Converter Stream, Channel */
+	{0xf07, 0x12,  0x00}, /* Pin Widget Control */
+	{0xf07, 0x13,  0x00}, /* Pin Widget Control */
+	{0xf07, 0x14,  0x00}, /* Pin Widget Control */
+	{0xf07, 0x15,  0x00}, /* Pin Widget Control */
+	{0xf07, 0x16,  0x00}, /* Pin Widget Control */
+	{0xf07, 0x17,  0x00}, /* Pin Widget Control */
+	{0xf07, 0x18,  0x00}, /* Pin Widget Control */
+	{0xf07, 0x19,  0x00}, /* Pin Widget Control */
+	{0xf07, 0x1a,  0x00}, /* Pin Widget Control */
+	{0xf07, 0x1b,  0x00}, /* Pin Widget Control */
+	{0xf07, 0x1d,  0x00}, /* Pin Widget Control */
+	{0xf07, 0x1e,  0x00}, /* Pin Widget Control */
+	{0xf07, 0x1f,  0x00}, /* Pin Widget Control */
+	{0xf07, 0x21,  0x00}, /* Pin Widget Control */
+	{0xf07, 0x29,  0x00}, /* Pin Widget Control */
+	{0xf0c, 0x14,  0x00}, /* EAPD Enable */
+	{0xf0c, 0x15,  0x00}, /* EAPD Enable */
+	{0xf0c, 0x16,  0x00}, /* EAPD Enable */
+	{0xf0c, 0x17,  0x00}, /* EAPD Enable */
+	{0xf0c, 0x1b,  0x00}, /* EAPD Enable */
+	{0xf0c, 0x21,  0x00}, /* EAPD Enable */
+	{0xf08, 0x01,  0x00}, /* Unsolicited Response */
+	{0xf08, 0x15,  0x00}, /* Unsolicited Response */
+	{0xf08, 0x16,  0x00}, /* Unsolicited Response */
+	{0xf08, 0x17,  0x00}, /* Unsolicited Response */
+	{0xf08, 0x18,  0x00}, /* Unsolicited Response */
+	{0xf08, 0x19,  0x00}, /* Unsolicited Response */
+	{0xf08, 0x1a,  0x00}, /* Unsolicited Response */
+	{0xf08, 0x1b,  0x00}, /* Unsolicited Response */
+	{0xf08, 0x1e,  0x00}, /* Unsolicited Response */
+	{0xf08, 0x21,  0x00}, /* Unsolicited Response */
+	{0xf08, 0x55,  0x00}, /* Unsolicited Response */
+	{0xf08, 0x60,  0x00}, /* Unsolicited Response */
+	{0xf09, 0x60,  0x00}, /* Pin Sense */
+	{0xf09, 0x15,  0x00}, /* Pin Sense */
+	{0xf09, 0x16,  0x00}, /* Pin Sense */
+	{0xf09, 0x17,  0x00}, /* Pin Sense */
+	{0xf09, 0x18,  0x00}, /* Pin Sense */
+	{0xf09, 0x19,  0x00}, /* Pin Sense */
+	{0xf09, 0x1a,  0x00}, /* Pin Sense */
+	{0xf09, 0x1b,  0x00}, /* Pin Sense */
+	{0xf09, 0x1e,  0x00}, /* Pin Sense */
+	{0xf09, 0x1f,  0x00}, /* Pin Sense */
+	{0xf09, 0x29,  0x00}, /* Pin Sense */
+	{0xf0a, 0x01,  0x00}, /* BEEP Generator */
+	{0xf20, 0x01,  0x00}, /* Subsystem ID */
+	{0xf21, 0x01,  0x00}, /* Subsystem ID */
+	{0xf22, 0x01,  0x00}, /* Subsystem ID */
+	{0xf23, 0x01,  0x00}, /* Subsystem ID */
+	{0xf1c, 0x12,  0x00}, /* Configuration Default */
+	{0xf1c, 0x13,  0x00}, /* Configuration Default */
+	{0xf1c, 0x14,  0x00}, /* Configuration Default */
+	{0xf1c, 0x15,  0x00}, /* Configuration Default */
+	{0xf1c, 0x16,  0x00}, /* Configuration Default */
+	{0xf1c, 0x17,  0x00}, /* Configuration Default */
+	{0xf1c, 0x18,  0x00}, /* Configuration Default */
+	{0xf1c, 0x19,  0x00}, /* Configuration Default */
+	{0xf1c, 0x1a,  0x00}, /* Configuration Default */
+	{0xf1c, 0x1b,  0x00}, /* Configuration Default */
+	{0xf1c, 0x1d,  0x00}, /* Configuration Default */
+	{0xf1c, 0x1e,  0x00}, /* Configuration Default */
+	{0xf1c, 0x1f,  0x00}, /* Configuration Default */
+	{0xf1c, 0x21,  0x00}, /* Configuration Default */
+	{0xf1c, 0x29,  0x00}, /* Configuration Default */
+	{0xf1d, 0x12,  0x00}, /* Configuration Default */
+	{0xf1d, 0x13,  0x00}, /* Configuration Default */
+	{0xf1d, 0x14,  0x00}, /* Configuration Default */
+	{0xf1d, 0x15,  0x00}, /* Configuration Default */
+	{0xf1d, 0x16,  0x00}, /* Configuration Default */
+	{0xf1d, 0x17,  0x00}, /* Configuration Default */
+	{0xf1d, 0x18,  0x00}, /* Configuration Default */
+	{0xf1d, 0x19,  0x00}, /* Configuration Default */
+	{0xf1d, 0x1a,  0x00}, /* Configuration Default */
+	{0xf1d, 0x1b,  0x00}, /* Configuration Default */
+	{0xf1d, 0x1d,  0x00}, /* Configuration Default */
+	{0xf1d, 0x1e,  0x00}, /* Configuration Default */
+	{0xf1d, 0x1f,  0x00}, /* Configuration Default */
+	{0xf1d, 0x21,  0x00}, /* Configuration Default */
+	{0xf1d, 0x29,  0x00}, /* Configuration Default */
+	{0xf1e, 0x12,  0x00}, /* Configuration Default */
+	{0xf1e, 0x13,  0x00}, /* Configuration Default */
+	{0xf1e, 0x14,  0x00}, /* Configuration Default */
+	{0xf1e, 0x15,  0x00}, /* Configuration Default */
+	{0xf1e, 0x16,  0x00}, /* Configuration Default */
+	{0xf1e, 0x17,  0x00}, /* Configuration Default */
+	{0xf1e, 0x18,  0x00}, /* Configuration Default */
+	{0xf1e, 0x19,  0x00}, /* Configuration Default */
+	{0xf1e, 0x1a,  0x00}, /* Configuration Default */
+	{0xf1e, 0x1b,  0x00}, /* Configuration Default */
+	{0xf1e, 0x1d,  0x00}, /* Configuration Default */
+	{0xf1e, 0x1e,  0x00}, /* Configuration Default */
+	{0xf1e, 0x1f,  0x00}, /* Configuration Default */
+	{0xf1e, 0x21,  0x00}, /* Configuration Default */
+	{0xf1e, 0x29,  0x00}, /* Configuration Default */
+	{0xf1f, 0x12,  0x00}, /* Configuration Default */
+	{0xf1f, 0x13,  0x00}, /* Configuration Default */
+	{0xf1f, 0x14,  0x00}, /* Configuration Default */
+	{0xf1f, 0x15,  0x00}, /* Configuration Default */
+	{0xf1f, 0x16,  0x00}, /* Configuration Default */
+	{0xf1f, 0x17,  0x00}, /* Configuration Default */
+	{0xf1f, 0x18,  0x00}, /* Configuration Default */
+	{0xf1f, 0x19,  0x00}, /* Configuration Default */
+	{0xf1f, 0x1a,  0x00}, /* Configuration Default */
+	{0xf1f, 0x1b,  0x00}, /* Configuration Default */
+	{0xf1f, 0x1d,  0x00}, /* Configuration Default */
+	{0xf1f, 0x1e,  0x00}, /* Configuration Default */
+	{0xf1f, 0x1f,  0x00}, /* Configuration Default */
+	{0xf1f, 0x21,  0x00}, /* Configuration Default */
+	{0xf1f, 0x29,  0x00}, /* Configuration Default */
+	{0xf0d, 0x06,  0x00}, /* Digital Converter */
+	{0xf0d, 0x0a,  0x00}, /* Digital Converter */
+	{0xf15, 0x01,  0x00}, /* GPIO Data */
+	{0xf16, 0x01,  0x00}, /* GPIO Enable Mask */
+	{0xf16, 0x20,  0x00}, /* GPIO Enable Mask */
+	{0xf17, 0x01,  0x00}, /* GPIO Direction */
+	{0xf17, 0x20,  0x00}, /* GPIO Direction */
+	{0xf19, 0x01,  0x00}, /* GPIO Unsolicited Response Enable Mask */
+	{0xf19, 0x20,  0x00}, /* GPIO Unsolicited Response Enable Mask */
+	{0xf37, 0x01,  0x00}, /* Current BCLK Frequency */
+};
+#define RT700_HDA_DUMP_LEN ARRAY_SIZE(hda_dump_list)
+
 static int rt700_index_write(struct regmap *regmap,
 		unsigned int reg, unsigned int value)
 {
@@ -82,6 +502,127 @@ err:
 	return ret;
 }
 
+static int rt700_index_read(struct regmap *regmap,
+		unsigned int reg, unsigned int *value)
+{
+	int ret;
+	unsigned int val_h, val_l;
+	unsigned int sdw_data_3, sdw_data_2, sdw_data_1, sdw_data_0;
+
+	val_h = (reg >> 8) & 0xff;
+	val_l = reg & 0xff;
+	ret = regmap_write(regmap, RT700_PRIV_INDEX_W_H, val_h);
+	if (ret < 0) {
+		pr_err("Failed to set private addr: %d\n", ret);
+		goto err;
+	}
+	ret = regmap_write(regmap, RT700_PRIV_INDEX_W_L, val_l);
+	if (ret < 0) {
+		pr_err("Failed to set private addr: %d\n", ret);
+		goto err;
+	}
+	val_h = 0;
+	val_l = 0;
+	ret = regmap_write(regmap, RT700_PRIV_DATA_R_H, val_h);
+	if (ret < 0) {
+		pr_err("Failed to set private value: %d\n", ret);
+		goto err;
+	}
+	ret = regmap_write(regmap, RT700_PRIV_DATA_R_L, val_l);
+	if (ret < 0) {
+		pr_err("Failed to set private value: %d\n", ret);
+		goto err;
+	}
+
+	sdw_data_3 = 0;
+	sdw_data_2 = 0;
+	sdw_data_1 = 0;
+	sdw_data_0 = 0;
+	regmap_read(regmap,
+		RT700_READ_HDA_3, &sdw_data_3);
+	regmap_read(regmap,
+		RT700_READ_HDA_2, &sdw_data_2);
+	regmap_read(regmap,
+		RT700_READ_HDA_1, &sdw_data_1);
+	regmap_read(regmap,
+		RT700_READ_HDA_0, &sdw_data_0);
+	*value = ((sdw_data_3 & 0xff) << 24) | ((sdw_data_2 & 0xff) << 16) |
+		 ((sdw_data_1 & 0xff) << 8) | (sdw_data_0 & 0xff);
+	return 0;
+
+err:
+	return ret;
+}
+
+static int rt700_hda_read(struct regmap *regmap, unsigned int vid,
+	unsigned int nid, unsigned int pid, unsigned int *value)
+{
+	int ret;
+	unsigned int val_h, val_l;
+	unsigned int sdw_data_3, sdw_data_2, sdw_data_1, sdw_data_0;
+	unsigned int sdw_addr_h, sdw_addr_l;
+
+	sdw_data_3 = 0;
+	sdw_data_2 = 0;
+	sdw_data_1 = 0;
+	sdw_data_0 = 0;
+
+	if (vid & 0x800) { /* get command */
+		hda_to_sdw(nid, vid, pid,
+				&sdw_addr_h, &sdw_data_1, &sdw_addr_l, &sdw_data_0);
+
+		pr_debug("write %04x %02x\n", sdw_addr_h, sdw_data_1);
+		regmap_write(regmap, sdw_addr_h, sdw_data_1);
+		if (sdw_addr_l) {
+			pr_debug("write %04x %02x", sdw_addr_l, sdw_data_0);
+			regmap_write(regmap, sdw_addr_l, sdw_data_0);
+		}
+		regmap_read(regmap,
+			RT700_READ_HDA_3, &sdw_data_3);
+		regmap_read(regmap,
+			RT700_READ_HDA_2, &sdw_data_2);
+		regmap_read(regmap,
+			RT700_READ_HDA_1, &sdw_data_1);
+		regmap_read(regmap,
+			RT700_READ_HDA_0, &sdw_data_0);
+		pr_debug("(%03x %02x %04x) = %02x%02x%02x%02x\n",
+			vid, nid, pid, sdw_data_3,
+			sdw_data_2, sdw_data_1, sdw_data_0);
+	} else {
+		pr_err("%s: it is not a get verb\n", __func__);
+	}
+	*value = ((sdw_data_3 & 0xff) << 24) | ((sdw_data_2 & 0xff) << 16) |
+		((sdw_data_1 & 0xff) << 8) | (sdw_data_0 & 0xff);
+
+	return 0;
+}
+
+int rt700_jack_detect(struct rt700_priv *rt700, bool *hp, bool *mic)
+{
+	unsigned int buf;
+
+	rt700_index_read(rt700->regmap, 0x82, &buf);
+	*hp = buf & 0x10;
+	if (*hp) {
+		*mic = buf & 0x40;
+	} else {
+		*mic = false;
+	}
+
+	/* Clear IRQ */
+	rt700_index_read(rt700->regmap, 0x10, &buf);
+	buf = buf | 0x1000;
+	rt700_index_write(rt700->regmap, 0x10, buf);
+
+	rt700_index_read(rt700->regmap, 0x19, &buf);
+	buf = buf | 0x0100;
+	rt700_index_write(rt700->regmap, 0x19, buf);
+
+
+	return 0;
+}
+EXPORT_SYMBOL(rt700_jack_detect);
+
 /* For Verb-Set Amplifier Gain (Verb ID = 3h) */
 static int rt700_set_amp_gain_put(struct snd_kcontrol *kcontrol,
 		struct snd_ctl_elem_value *ucontrol)
@@ -135,13 +676,13 @@ static int rt700_set_amp_gain_put(struct snd_kcontrol *kcontrol,
 		val_l = (mc->max - ucontrol->value.integer.value[0]) << 7;
 		/* keep gain */
 		read_ll = read_ll & 0x7f;
-		val_l |= read_rl;
+		val_l |= read_ll;
 	} else {
 		/* for gain */
 		val_l = ((ucontrol->value.integer.value[0]) & mc->max);
 		/* keep mute status */
 		read_ll = read_ll & 0x80;
-		val_l |= read_rl;
+		val_l |= read_ll;
 	}
 
 	regmap_write(rt700->regmap, addr_h, val_h);
@@ -243,8 +784,8 @@ static const struct snd_kcontrol_new rt700_snd_controls[] = {
 	SOC_DOUBLE_R_EXT("ADC 08 Capture Switch", RT700_SET_GAIN_ADC2_H,
 			    RT700_SET_GAIN_ADC2_L, RT700_DIR_IN_SFT, 1, 1,
 			    rt700_set_amp_gain_get, rt700_set_amp_gain_put),
-	SOC_DOUBLE_R_EXT("ADC 09 Capture Switch", RT700_SET_GAIN_ADC2_H,
-			    RT700_SET_GAIN_ADC2_L, RT700_DIR_IN_SFT, 1, 1,
+	SOC_DOUBLE_R_EXT("ADC 09 Capture Switch", RT700_SET_GAIN_ADC1_H,
+			    RT700_SET_GAIN_ADC1_L, RT700_DIR_IN_SFT, 1, 1,
 			    rt700_set_amp_gain_get, rt700_set_amp_gain_put),
 	SOC_DOUBLE_R_EXT_TLV("ADC 08 Capture Volume", RT700_SET_GAIN_ADC2_H,
 			    RT700_SET_GAIN_ADC2_L, RT700_DIR_IN_SFT, 0x3f, 0,
@@ -290,10 +831,10 @@ static int rt700_mux_put(struct snd_kcontrol *kcontrol,
 	struct snd_soc_codec *codec = snd_soc_dapm_kcontrol_codec(kcontrol);
 	struct snd_soc_dapm_context *dapm =
 				snd_soc_dapm_kcontrol_dapm(kcontrol);
-	struct snd_soc_card *card = dapm->card;
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
 	unsigned int *item = ucontrol->value.enumerated.item;
 	unsigned int val, val2, change, reg;
+	struct snd_soc_dapm_update update;
 
 	if (item[0] >= e->items)
 		return -EINVAL;
@@ -319,7 +860,12 @@ static int rt700_mux_put(struct snd_kcontrol *kcontrol,
 		reg = RT700_VERB_SET_CONNECT_SEL | e->reg;
 		snd_soc_write(codec, reg, val);
 		pr_debug("%s write %04x %02x\n", __func__, reg, val);
-		soc_dpcm_runtime_update(card);
+		update.kcontrol = kcontrol;
+		update.reg = e->reg;
+		update.mask = 0xff;
+		update.val = val;
+		snd_soc_dapm_mux_update_power(dapm, kcontrol,
+						item[0], e, &update);
 	}
 
 	return change;
@@ -340,11 +886,11 @@ static const SOC_ENUM_SINGLE_DECL(
 
 static const struct snd_kcontrol_new rt700_adc22_mux =
 	SOC_DAPM_ENUM_EXT("ADC 22 Mux", rt700_adc22_enum,
-			rt700_mux_put, rt700_mux_get);
+			rt700_mux_get, rt700_mux_put);
 
 static const struct snd_kcontrol_new rt700_adc23_mux =
 	SOC_DAPM_ENUM_EXT("ADC 23 Mux", rt700_adc23_enum,
-			rt700_mux_put, rt700_mux_get);
+			rt700_mux_get, rt700_mux_put);
 
 static const char * const out_mux_text[] = {
 	"Front",
@@ -356,7 +902,7 @@ static const SOC_ENUM_SINGLE_DECL(
 
 static const struct snd_kcontrol_new rt700_hp_mux =
 	SOC_DAPM_ENUM_EXT("HP Mux", rt700_hp_enum,
-			rt700_mux_put, rt700_mux_get);
+			rt700_mux_get, rt700_mux_put);
 
 static const struct snd_soc_dapm_widget rt700_dapm_widgets[] = {
 	SND_SOC_DAPM_OUTPUT("HP"),
@@ -386,6 +932,7 @@ static const struct snd_soc_dapm_route rt700_audio_map[] = {
 	{"DAC Front", NULL, "DP1RX"},
 	{"DAC Surround", NULL, "DP3RX"},
 	{"DP2TX", NULL, "ADC 09"},
+	{"DP4TX", NULL, "ADC 08"},
 	{"ADC 09", NULL, "ADC 22 Mux"},
 	{"ADC 08", NULL, "ADC 23 Mux"},
 	{"ADC 22 Mux", "DMIC", "DMIC1"},
@@ -406,17 +953,37 @@ static const struct snd_soc_dapm_route rt700_audio_map[] = {
 static int rt700_set_bias_level(struct snd_soc_codec *codec,
 					enum snd_soc_bias_level level)
 {
+	struct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);
+
+	switch (level) {
+	case SND_SOC_BIAS_PREPARE:
+		if (SND_SOC_BIAS_STANDBY == dapm->bias_level) {
+			snd_soc_write(codec,
+				RT700_SET_AUDIO_POWER_STATE, AC_PWRST_D0);
+		}
+		break;
+
+	case SND_SOC_BIAS_STANDBY:
+		snd_soc_write(codec, RT700_SET_AUDIO_POWER_STATE, AC_PWRST_D3);
+		break;
+
+	default:
+		break;
+	}
+	dapm->bias_level = level;
 	return 0;
 }
 
 static const struct snd_soc_codec_driver soc_codec_dev_rt700 = {
 	.set_bias_level = rt700_set_bias_level,
-	.controls = rt700_snd_controls,
-	.num_controls = ARRAY_SIZE(rt700_snd_controls),
-	.dapm_widgets = rt700_dapm_widgets,
-	.num_dapm_widgets = ARRAY_SIZE(rt700_dapm_widgets),
-	.dapm_routes = rt700_audio_map,
-	.num_dapm_routes = ARRAY_SIZE(rt700_audio_map),
+	.component_driver = {
+		.controls = rt700_snd_controls,
+		.num_controls = ARRAY_SIZE(rt700_snd_controls),
+		.dapm_widgets = rt700_dapm_widgets,
+		.num_dapm_widgets = ARRAY_SIZE(rt700_dapm_widgets),
+		.dapm_routes = rt700_audio_map,
+		.num_dapm_routes = ARRAY_SIZE(rt700_audio_map),
+	},
 };
 
 static int rt700_program_stream_tag(struct snd_pcm_substream *substream,
@@ -459,7 +1026,7 @@ static int rt700_pcm_hw_params(struct snd_pcm_substream *substream,
 	struct sdw_stream_data *stream;
 	int port;
 	int num_channels;
-	int upscale_factor = 16;
+	int upscale_factor = 1;
 	unsigned int val = 0;
 
 	stream = snd_soc_dai_get_dma_data(dai, substream);
@@ -629,40 +1196,101 @@ static struct snd_soc_dai_driver rt700_dai[] = {
 	},
 };
 
-static ssize_t rt700_hda_cmd_show(struct device *dev,
+static ssize_t rt700_index_cmd_show(struct device *dev,
 				 struct device_attribute *attr, char *buf)
 {
 	struct rt700_priv *rt700 = dev_get_drvdata(dev);
 	unsigned int sdw_addr_h, sdw_addr_l;
 	unsigned int sdw_data_3, sdw_data_2, sdw_data_1, sdw_data_0;
-	int cnt = 0;
+	int i, cnt = 0;
 
-	hda_to_sdw(rt700->dbg_nid, rt700->dbg_vid, rt700->dbg_payload,
-		&sdw_addr_h, &sdw_data_1, &sdw_addr_l, &sdw_data_0);
+	/* index */
+	for (i = 0; i <= 0xa0; i++) {
+		rt700_index_read(rt700->regmap, i, &sdw_data_0);
+		cnt += snprintf(buf + cnt, 12,
+				"%02x = %04x\n", i, sdw_data_0);
+	}
 
-	regmap_write(rt700->regmap, sdw_addr_h, sdw_data_1);
-	if (!sdw_addr_l)
-		regmap_write(rt700->regmap, sdw_addr_l, sdw_data_0);
+	if (cnt >= PAGE_SIZE)
+		cnt = PAGE_SIZE - 1;
 
+	return cnt;
+}
 
-	sdw_data_3 = 0;
-	sdw_data_2 = 0;
-	sdw_data_1 = 0;
-	sdw_data_0 = 0;
-	if (rt700->dbg_vid & 0x800) { /* get command */
-		regmap_read(rt700->regmap, RT700_READ_HDA_3, &sdw_data_3);
-		regmap_read(rt700->regmap, RT700_READ_HDA_2, &sdw_data_2);
-		regmap_read(rt700->regmap, RT700_READ_HDA_1, &sdw_data_1);
-		regmap_read(rt700->regmap, RT700_READ_HDA_0, &sdw_data_0);
-		pr_info("read (%02x %03x %04x) = %02x%02x%02x%02x\n",
-			rt700->dbg_nid, rt700->dbg_vid, rt700->dbg_payload,
-			sdw_data_3, sdw_data_2, sdw_data_1, sdw_data_0);
+static ssize_t rt700_index_cmd_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct rt700_priv *rt700 = dev_get_drvdata(dev);
+	unsigned int sdw_addr_h, sdw_addr_l, sdw_data_h, sdw_data_l;
+	unsigned int index_reg, index_val;
+	int i;
+
+	pr_debug("register \"%s\" count=%zu\n", buf, count);
+	for (i = 0; i < count; i++) {	/*rt700->dbg_nidess */
+		if (*(buf + i) <= '9' && *(buf + i) >= '0')
+			index_reg = (index_reg << 4) |
+						(*(buf + i) - '0');
+		else if (*(buf + i) <= 'f' && *(buf + i) >= 'a')
+			index_reg = (index_reg << 4) |
+						((*(buf + i) - 'a') + 0xa);
+		else if (*(buf + i) <= 'F' && *(buf + i) >= 'A')
+			index_reg = (index_reg << 4) |
+						((*(buf + i) - 'A') + 0xa);
+		else
+			break;
+	}
+
+	for (i = i + 1; i < count; i++) {
+		if (*(buf + i) <= '9' && *(buf + i) >= '0')
+			index_val = (index_val << 4) |
+						(*(buf + i) - '0');
+		else if (*(buf + i) <= 'f' && *(buf + i) >= 'a')
+			index_val = (index_val << 4) |
+						((*(buf + i) - 'a') + 0xa);
+		else if (*(buf + i) <= 'F' && *(buf + i) >= 'A')
+			index_val = (index_val << 4) |
+						((*(buf + i) - 'A') + 0xa);
+		else
+			break;
 	}
-	cnt += snprintf(buf, PAGE_SIZE - 1,
-			"read (%02x %03x %04x) = %02x%02x%02x%02x\n",
-			rt700->dbg_nid, rt700->dbg_vid, rt700->dbg_payload,
-			sdw_data_3, sdw_data_2, sdw_data_1, sdw_data_0);
 
+	pr_debug("index_reg=0x%x index_val=0x%x\n",
+		index_reg, index_val);
+
+	rt700_index_write(rt700->regmap, index_reg, index_val);
+
+	return count;
+}
+
+static DEVICE_ATTR(index_reg, 0664, rt700_index_cmd_show, rt700_index_cmd_store);
+
+static ssize_t rt700_hda_cmd_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct rt700_priv *rt700 = dev_get_drvdata(dev);
+	unsigned int sdw_addr_h, sdw_addr_l;
+	unsigned int sdw_data_3, sdw_data_2, sdw_data_1, sdw_data_0;
+	int i, cnt = 0;
+	unsigned int value;
+
+	pr_debug("%s cnt=%d RT700_HDA_DUMP_LEN=%d PAGE_SIZE=%d\n",
+		__func__, cnt, RT700_HDA_DUMP_LEN, PAGE_SIZE);
+	for (i = 0; i < RT700_HDA_DUMP_LEN; i++) {
+		pr_debug("%s i=%d", __func__, i);
+		if (cnt + 25 >= PAGE_SIZE)
+			break;
+		rt700->dbg_nid = hda_dump_list[i].nid;
+		rt700->dbg_vid = hda_dump_list[i].vid;
+		rt700->dbg_payload = hda_dump_list[i].payload;
+		rt700_hda_read(rt700->regmap, rt700->dbg_vid,
+			rt700->dbg_nid, rt700->dbg_payload, &value);
+
+		cnt += snprintf(buf + cnt, 25,
+			"%03x %02x %04x=%x\n",
+			rt700->dbg_vid, rt700->dbg_nid,
+			rt700->dbg_payload, value);
+	}
 
 	if (cnt >= PAGE_SIZE)
 		cnt = PAGE_SIZE - 1;
@@ -749,17 +1377,66 @@ static ssize_t rt700_hda_cmd_store(struct device *dev,
 			sdw_data_3, sdw_data_2, sdw_data_1, sdw_data_0);
 	}
 
+	/* Enable Jack Detection */
+	regmap_write(rt700->regmap,  RT700_SET_MIC2_UNSOLICITED_ENABLE, 0x82);
+	regmap_write(rt700->regmap,  RT700_SET_HP_UNSOLICITED_ENABLE, 0x81);
+	rt700_index_write(rt700->regmap, 0x10, 0x2420);
+	rt700_index_write(rt700->regmap, 0x19, 0x2e11);
 
 	return count;
 }
 
 static DEVICE_ATTR(hda_reg, 0664, rt700_hda_cmd_show, rt700_hda_cmd_store);
 
+/* Bus clock frequency */
+#define RT700_CLK_FREQ_9600000HZ 9600000
+#define RT700_CLK_FREQ_12000000HZ 12000000
+#define RT700_CLK_FREQ_6000000HZ 6000000
+#define RT700_CLK_FREQ_4800000HZ 4800000
+#define RT700_CLK_FREQ_2400000HZ 2400000
+#define RT700_CLK_FREQ_12288000HZ 12288000
+
+
+static int rt700_clock_config(struct device *dev, struct alc700 *alc700)
+{
+	struct rt700_priv *rt700 = dev_get_drvdata(dev);
+	int value, read_value1, read_value2;
+
+	switch(alc700->params->bus_clk_freq) {
+	case RT700_CLK_FREQ_12000000HZ:
+		value = 0x0;
+		break;
+	case RT700_CLK_FREQ_6000000HZ:
+		value = 0x1;
+		break;
+	case RT700_CLK_FREQ_9600000HZ:
+		value = 0x2;
+		break;
+	case RT700_CLK_FREQ_4800000HZ:
+		value = 0x3;
+		break;
+	case RT700_CLK_FREQ_2400000HZ:
+		value = 0x4;
+		break;
+	case RT700_CLK_FREQ_12288000HZ:
+		value = 0x5;
+		break;
+	default:
+		return -EINVAL;
+	}
+	regmap_write(rt700->regmap, 0xe0, value);
+	regmap_write(rt700->regmap, 0xf0, value);
+
+	return 0;
+}
+
 int rt700_probe(struct device *dev, struct regmap *regmap,
 					struct sdw_slave *slave)
 {
 	struct rt700_priv *rt700;
+	struct alc700 *alc700 = dev_get_drvdata(dev);
 	int ret;
+	unsigned int value;
 
 	rt700 = devm_kzalloc(dev, sizeof(struct rt700_priv),
 			       GFP_KERNEL);
@@ -785,7 +1462,7 @@ int rt700_probe(struct device *dev, struct regmap *regmap,
 	/* Rx_09: index 91[8] */
 	/* Rx_08: index 91[6] */
 	/* Mic2 (19) -> Mux (22) -> ADC (09) */
-	regmap_write(rt700->regmap, 0x3122, 0x0); /* Mic2 (19) -> Mux (22)*/
+	//regmap_write(rt700->regmap, 0x3122, 0x0); /* Mic2 (19) -> Mux (22)*/
 
 	/* Assign stream ID */
 	/* do it in dapm widget
@@ -796,27 +1473,83 @@ int rt700_probe(struct device *dev, struct regmap *regmap,
 	*/
 
 	/* Set Pin Widget */
-	regmap_write(rt700->regmap,  RT700_SET_PIN_HP, 0x40);
-	regmap_write(rt700->regmap,  RT700_SET_PIN_SPK, 0x40);
-	regmap_write(rt700->regmap,  0x3c14, 0x02); /* 14 70c 02 */
-	regmap_write(rt700->regmap,  RT700_SET_PIN_DMIC1, 0x20);
-	regmap_write(rt700->regmap,  RT700_SET_PIN_DMIC2, 0x20);
-	regmap_write(rt700->regmap,  RT700_SET_PIN_MIC2, 0x20);
+	regmap_write(rt700->regmap, RT700_SET_PIN_HP, 0x40);
+	regmap_write(rt700->regmap, RT700_SET_PIN_SPK, 0x40);
+	//regmap_write(rt700->regmap,  0x3c14, 0x02); /* 14 70c 02 */
+	regmap_write(rt700->regmap, RT700_SET_EAPD_SPK, RT700_EAPD_HIGH);
+	regmap_write(rt700->regmap, RT700_SET_PIN_DMIC1, 0x20);
+	regmap_write(rt700->regmap, RT700_SET_PIN_DMIC2, 0x20);
+	regmap_write(rt700->regmap, RT700_SET_PIN_MIC2, 0x20);
+	/*
 	regmap_write(rt700->regmap,  RT700_SET_PIN_LINE1, 0x20);
 	regmap_write(rt700->regmap,  RT700_SET_PIN_LINE2, 0x20);
+	*/
+
+	/* Set Configuration Default */
+	//regmap_write(rt700->regmap, 0x4f12, 0x00);
+	regmap_write(rt700->regmap, 0x4f12, 0x91);
+	regmap_write(rt700->regmap, 0x4e12, 0xd6);
+	regmap_write(rt700->regmap, 0x4d12, 0x11);
+	regmap_write(rt700->regmap, 0x4c12, 0x20);
+	regmap_write(rt700->regmap, 0x4f13, 0x91);
+	regmap_write(rt700->regmap, 0x4e13, 0xd6);
+	regmap_write(rt700->regmap, 0x4d13, 0x11);
+	regmap_write(rt700->regmap, 0x4c13, 0x21);
+
+	regmap_write(rt700->regmap, 0x4f19, 0x02);
+	regmap_write(rt700->regmap, 0x4e19, 0xa1);
+	regmap_write(rt700->regmap, 0x4d19, 0x90);
+	regmap_write(rt700->regmap, 0x4c19, 0x80);
+
+	/* Enable Line2 */
+	regmap_write(rt700->regmap,  0x371b, 0x40);
+	regmap_write(rt700->regmap,  0x731b, 0xb0);
+	regmap_write(rt700->regmap,  0x839b, 0x00);
 
 	/* Set index */
 	rt700_index_write(rt700->regmap, 0x4a, 0x201b);
-	rt700_index_write(rt700->regmap, 0x38, 0x4921);
+	//rt700_index_write(rt700->regmap, 0x38, 0x4921);
+
+	/* get the setting registers for debug 
+	pr_debug("%s get the setting registers\n", __func__);
+	rt700_hda_read(rt700->regmap, 0xf07, 0x21, 0, &value);
+	rt700_hda_read(rt700->regmap, 0xf07, 0x14, 0, &value);
+	rt700_hda_read(rt700->regmap, 0xf07, 0x12, 0, &value);
+	rt700_hda_read(rt700->regmap, 0xf07, 0x13, 0, &value);
+	rt700_hda_read(rt700->regmap, 0xf07, 0x19, 0, &value);
+	rt700_hda_read(rt700->regmap, 0xf07, 0x1a, 0, &value);
+	rt700_hda_read(rt700->regmap, 0xf07, 0x1b, 0, &value);
+	rt700_hda_read(rt700->regmap, 0xf0c, 0x14, 0, &value);
+	*/
+	ret = rt700_clock_config(dev, alc700);
 
+	/* Enable Jack Detection */
+	regmap_write(rt700->regmap,  RT700_SET_MIC2_UNSOLICITED_ENABLE, 0x82);
+	regmap_write(rt700->regmap,  RT700_SET_HP_UNSOLICITED_ENABLE, 0x81);
+	rt700_index_write(rt700->regmap, 0x10, 0x2420);
+	rt700_index_write(rt700->regmap, 0x19, 0x2e11);
+
+	/* Finish Initial Settings, set power to D3 */
+	regmap_write(rt700->regmap, RT700_SET_AUDIO_POWER_STATE, AC_PWRST_D3);
+
+	ret = device_create_file(&slave->dev, &dev_attr_index_reg);
+	if (ret != 0) {
+		dev_err(&slave->dev,
+			"Failed to create index_reg sysfs files: %d\n", ret);
+		return ret;
+	}
 
 	ret = device_create_file(&slave->dev, &dev_attr_hda_reg);
 	if (ret != 0) {
 		dev_err(&slave->dev,
-			"Failed to create codex_reg sysfs files: %d\n", ret);
+			"Failed to create hda_reg sysfs files: %d\n", ret);
 		return ret;
 	}
 
+	pm_runtime_set_autosuspend_delay(&slave->dev, 3000);
+	pm_runtime_use_autosuspend(&slave->dev);
+	pm_runtime_enable(&slave->dev);
+	pm_runtime_put_sync_autosuspend(&slave->dev);
 	return ret;
 }
 EXPORT_SYMBOL(rt700_probe);
@@ -840,6 +1573,16 @@ static int rt700_runtime_suspend(struct device *dev)
 
 static int rt700_runtime_resume(struct device *dev)
 {
+	struct rt700_priv *rt700 = dev_get_drvdata(dev);
+	int ret;
+	int timeout = 0;
+
+	if(rt700->sdw) {
+		ret = sdw_wait_for_slave_enumeration(rt700->sdw->mstr,
+						     rt700->sdw);
+		if (ret < 0)
+			return ret;
+	}
 
 	return 0;
 }
diff --git a/sound/soc/codecs/rt700.h b/sound/soc/codecs/rt700.h
index 98a5cad3..530831b 100644
--- a/sound/soc/codecs/rt700.h
+++ b/sound/soc/codecs/rt700.h
@@ -32,6 +32,11 @@ struct  rt700_priv {
 	int dbg_payload;
 };
 
+struct alc700 {
+        struct sdw_slave *sdw;
+        struct sdw_bus_params *params;
+};
+
 /* NID */
 #define RT700_AUDIO_FUNCTION_GROUP			0x01
 #define RT700_DAC_OUT1					0x02
@@ -54,9 +59,12 @@ struct  rt700_priv {
 
 /* Verb */
 #define RT700_VERB_SET_CONNECT_SEL			0x3100
+#define RT700_VERB_SET_EAPD_BTLENABLE			0x3c00
 #define RT700_VERB_GET_CONNECT_SEL			0xb100
+#define RT700_VERB_SET_POWER_STATE			0x3500
 #define RT700_VERB_SET_CHANNEL_STREAMID			0x3600
 #define RT700_VERB_SET_PIN_WIDGET_CONTROL		0x3700
+#define RT700_VERB_SET_UNSOLICITED_ENABLE		0x3800
 #define RT700_SET_AMP_GAIN_MUTE_H			0x7300
 #define RT700_SET_AMP_GAIN_MUTE_L			0x8380
 
@@ -76,6 +84,8 @@ struct  rt700_priv {
 #define RT700_DAC_FORMAT_L				0x8283
 #define RT700_ADC_FORMAT_H				0x7209
 #define RT700_ADC_FORMAT_L				0x8289
+#define RT700_SET_AUDIO_POWER_STATE\
+	(RT700_VERB_SET_POWER_STATE | RT700_AUDIO_FUNCTION_GROUP)
 #define RT700_SET_PIN_DMIC1\
 	(RT700_VERB_SET_PIN_WIDGET_CONTROL | RT700_DMIC1)
 #define RT700_SET_PIN_DMIC2\
@@ -90,6 +100,10 @@ struct  rt700_priv {
 	(RT700_VERB_SET_PIN_WIDGET_CONTROL | RT700_LINE1)
 #define RT700_SET_PIN_LINE2\
 	(RT700_VERB_SET_PIN_WIDGET_CONTROL | RT700_LINE2)
+#define RT700_SET_MIC2_UNSOLICITED_ENABLE\
+	(RT700_VERB_SET_UNSOLICITED_ENABLE | RT700_MIC2)
+#define RT700_SET_HP_UNSOLICITED_ENABLE\
+	(RT700_VERB_SET_UNSOLICITED_ENABLE | RT700_HP_OUT)
 #define RT700_SET_STREAMID_DAC1\
 	(RT700_VERB_SET_CHANNEL_STREAMID | RT700_DAC_OUT1)
 #define RT700_SET_STREAMID_DAC2\
@@ -122,7 +136,11 @@ struct  rt700_priv {
 	(RT700_SET_AMP_GAIN_MUTE_L | RT700_SPK_OUT)
 #define RT700_SET_GAIN_SPK_H\
 	(RT700_SET_AMP_GAIN_MUTE_H | RT700_SPK_OUT)
+#define RT700_SET_EAPD_SPK\
+	(RT700_VERB_SET_EAPD_BTLENABLE | RT700_SPK_OUT)
 
+#define RT700_EAPD_HIGH					0x2
+#define RT700_EAPD_LOW					0x0
 #define RT700_MUTE_SFT					7
 #define RT700_DIR_IN_SFT				6
 #define RT700_DIR_OUT_SFT				7
@@ -139,4 +157,5 @@ int rt700_remove(struct device *dev);
 int hda_to_sdw(unsigned int nid, unsigned int verb, unsigned int payload,
 		unsigned int *sdw_addr_h, unsigned int *sdw_data_h,
 		unsigned int *sdw_addr_l, unsigned int *sdw_data_l);
+int rt700_jack_detect(struct rt700_priv *rt700, bool *hp, bool *mic);
 #endif /* __RT700_H__ */
-- 
1.7.5.4

