From 87cea104c2c74d8c492f739c582eb298c061a5a9 Mon Sep 17 00:00:00 2001
From: fupan li <fupan.li@windriver.com>
Date: Mon, 23 Mar 2015 11:25:05 +0800
Subject: [PATCH 3/9] Revert "atomisp: fix the call trace on preempt-rt
 kernel"

This reverts commit 91194b19646eae71f191da2e68e5c6784dcc8894.
---
 drivers/media/atomisp2/atomisp_cmd.c      |   16 ++++++++--------
 drivers/media/atomisp2/atomisp_compat.c   |    6 +++---
 drivers/media/atomisp2/atomisp_internal.h |    2 +-
 drivers/media/atomisp2/atomisp_ioctl.c    |    8 ++++----
 drivers/media/atomisp2/atomisp_v4l2.c     |    8 ++++----
 drivers/media/v4l2-core/v4l2-dev.c        |    2 +-
 drivers/media/v4l2-core/v4l2-event.c      |   28 ++++++++++++++--------------
 drivers/media/v4l2-core/v4l2-fh.c         |   12 ++++++------
 include/media/v4l2-dev.h                  |    2 +-
 9 files changed, 42 insertions(+), 42 deletions(-)

diff --git a/drivers/media/atomisp2/atomisp_cmd.c b/drivers/media/atomisp2/atomisp_cmd.c
index bcfe9d4c..ee756a2 100644
--- a/drivers/media/atomisp2/atomisp_cmd.c
+++ b/drivers/media/atomisp2/atomisp_cmd.c
@@ -778,7 +778,7 @@ irqreturn_t atomisp_isr(int irq, void *dev)
 	msg_ret |= 1 << INTR_IIR;
 	pci_write_config_dword(isp->pdev, PCI_INTERRUPT_CTRL, msg_ret);
 
-	raw_spin_lock_irqsave(&isp->lock, flags);
+	spin_lock_irqsave(&isp->lock, flags);
 
 	for (i = 0, streaming = 0; i < isp->num_of_streams; i++)
 		streaming += isp->isp_subdev[i].streaming ==
@@ -828,12 +828,12 @@ irqreturn_t atomisp_isr(int irq, void *dev)
 		/* TODO: handle SH_CSS_RX_IRQ_INFO_BUFFER_OVERRUN */
 	}
 
-	raw_spin_unlock_irqrestore(&isp->lock, flags);
+	spin_unlock_irqrestore(&isp->lock, flags);
 
 	return IRQ_WAKE_THREAD;
 
 out_nowake:
-	raw_spin_unlock_irqrestore(&isp->lock, flags);
+	spin_unlock_irqrestore(&isp->lock, flags);
 
 	return IRQ_HANDLED;
 }
@@ -1567,11 +1567,11 @@ irqreturn_t atomisp_isr_thread(int irq, void *isp_ptr)
 	memset(css_pipe_done, 0, sizeof(css_pipe_done));
 	mutex_lock(&isp->mutex);
 
-	raw_spin_lock_irqsave(&isp->lock, flags);
+	spin_lock_irqsave(&isp->lock, flags);
 	for (i = 0, streaming = 0; i < isp->num_of_streams; i++)
 		streaming += isp->isp_subdev[i].streaming ==
 		    ATOMISP_DEVICE_STREAMING_ENABLED;
-	raw_spin_unlock_irqrestore(&isp->lock, flags);
+	spin_unlock_irqrestore(&isp->lock, flags);
 	if (!streaming)
 		goto out;
 
@@ -2809,12 +2809,12 @@ int atomisp_get_dis_stat(struct atomisp_sub_device *isp_subdev,
 		return -EINVAL;
 
 	/* isp needs to be streaming to get DIS statistics */
-	raw_spin_lock_irqsave(&isp->lock, flags);
+	spin_lock_irqsave(&isp->lock, flags);
 	if (isp_subdev->streaming != ATOMISP_DEVICE_STREAMING_ENABLED) {
-		raw_spin_unlock_irqrestore(&isp->lock, flags);
+		spin_unlock_irqrestore(&isp->lock, flags);
 		return -EINVAL;
 	}
-	raw_spin_unlock_irqrestore(&isp->lock, flags);
+	spin_unlock_irqrestore(&isp->lock, flags);
 
 	if (!isp_subdev->params.video_dis_en)
 		return -EINVAL;
diff --git a/drivers/media/atomisp2/atomisp_compat.c b/drivers/media/atomisp2/atomisp_compat.c
index db9c5b6..9624655 100644
--- a/drivers/media/atomisp2/atomisp_compat.c
+++ b/drivers/media/atomisp2/atomisp_compat.c
@@ -34,13 +34,13 @@
  *    Sighting #4600742 also points to system hard hang upon access to IUNIT MMIO.
  *
  */
-static DEFINE_RAW_SPINLOCK(mmio_lock);
+static DEFINE_SPINLOCK(mmio_lock);
 extern raw_spinlock_t pci_config_lock;
 
 #ifdef ISOF_SILICON_BUG_WORKAROUND
-#define MMIO_LOCK raw_spin_lock_irqsave(&mmio_lock, flags);
+#define MMIO_LOCK spin_lock_irqsave(&mmio_lock, flags);
 #define PCI_CONFIG_LOCK raw_spin_lock(&pci_config_lock);
-#define MMIO_UNLOCK raw_spin_unlock_irqrestore(&mmio_lock, flags);
+#define MMIO_UNLOCK spin_unlock_irqrestore(&mmio_lock, flags);
 #define PCI_CONFIG_UNLOCK raw_spin_unlock(&pci_config_lock);
 #else
 #define MMIO_LOCK
diff --git a/drivers/media/atomisp2/atomisp_internal.h b/drivers/media/atomisp2/atomisp_internal.h
index 6c79f8b..0a514ed 100644
--- a/drivers/media/atomisp2/atomisp_internal.h
+++ b/drivers/media/atomisp2/atomisp_internal.h
@@ -276,7 +276,7 @@ struct atomisp_device {
 	unsigned int wdt_duration;	/* in jiffies */
 	enum atomisp_frame_status fr_status;
 
-	raw_spinlock_t lock; /* Just for streaming below */
+	spinlock_t lock; /* Just for streaming below */
 
 	bool need_gfx_throttle;
 
diff --git a/drivers/media/atomisp2/atomisp_ioctl.c b/drivers/media/atomisp2/atomisp_ioctl.c
index a1d4477..c949a4a 100644
--- a/drivers/media/atomisp2/atomisp_ioctl.c
+++ b/drivers/media/atomisp2/atomisp_ioctl.c
@@ -1498,13 +1498,13 @@ int __atomisp_streamoff(struct file *file, void *fh, enum v4l2_buf_type type)
 
 
 	atomisp_clear_frame_counters(isp_subdev);
-	raw_spin_lock_irqsave(&isp->lock, flags);
+	spin_lock_irqsave(&isp->lock, flags);
 	if (isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_ENABLED
 	    || isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_STARTING) {
 		isp_subdev->streaming = ATOMISP_DEVICE_STREAMING_STOPPING;
 		first_streamoff = true;
 	}
-	raw_spin_unlock_irqrestore(&isp->lock, flags);
+	spin_unlock_irqrestore(&isp->lock, flags);
 
 	if (first_streamoff) {
 		mutex_unlock(&isp->mutex);
@@ -1526,10 +1526,10 @@ int __atomisp_streamoff(struct file *file, void *fh, enum v4l2_buf_type type)
 		atomisp_acc_unload_extensions(isp);
 	}
 
-	raw_spin_lock_irqsave(&isp->lock, flags);
+	spin_lock_irqsave(&isp->lock, flags);
 	if (atomisp_streaming_count(isp_subdev) <= 1)
 		isp_subdev->streaming = ATOMISP_DEVICE_STREAMING_DISABLED;
-	raw_spin_unlock_irqrestore(&isp->lock, flags);
+	spin_unlock_irqrestore(&isp->lock, flags);
 
 	if (!first_streamoff) {
 		if(pipe->vb2q.streaming)
diff --git a/drivers/media/atomisp2/atomisp_v4l2.c b/drivers/media/atomisp2/atomisp_v4l2.c
index 0a5286b..0f462b8 100644
--- a/drivers/media/atomisp2/atomisp_v4l2.c
+++ b/drivers/media/atomisp2/atomisp_v4l2.c
@@ -474,17 +474,17 @@ static int atomisp_suspend(struct device *dev)
 	if (atomisp_dev_users(isp))
 		return -EBUSY;
 
-	raw_spin_lock_irqsave(&isp->lock, flags);
+	spin_lock_irqsave(&isp->lock, flags);
 	for(i=0;i<isp->num_of_streams;i++)
 	{
 		if (isp->isp_subdev[i].streaming != ATOMISP_DEVICE_STREAMING_DISABLED) {
-			raw_spin_unlock_irqrestore(&isp->lock, flags);
+			spin_unlock_irqrestore(&isp->lock, flags);
 			v4l2_err(&atomisp_dev,
 				    "atomisp cannot suspend at this time.\n");
 			return -EINVAL;
 		}
 	}
-	raw_spin_unlock_irqrestore(&isp->lock, flags);
+	spin_unlock_irqrestore(&isp->lock, flags);
 
 	/* Prepare for MRFLD IUNIT power down */
 	if (IS_MRFLD) {
@@ -1133,7 +1133,7 @@ static int atomisp_pci_probe(struct pci_dev *dev,
 	mutex_init(&isp->mutex);
 	mutex_init(&isp->streamoff_mutex);
 	mutex_init(&isp->vb2mutex);
-	raw_spin_lock_init(&isp->lock);
+	spin_lock_init(&isp->lock);
 
 	isp->max_isr_latency = ATOMISP_MAX_ISR_LATENCY;
 
diff --git a/drivers/media/v4l2-core/v4l2-dev.c b/drivers/media/v4l2-core/v4l2-dev.c
index b3691d7..5923c5d 100644
--- a/drivers/media/v4l2-core/v4l2-dev.c
+++ b/drivers/media/v4l2-core/v4l2-dev.c
@@ -779,7 +779,7 @@ int __video_register_device(struct video_device *vdev, int type, int nr,
 		return -EINVAL;
 
 	/* v4l2_fh support */
-	raw_spin_lock_init(&vdev->fh_lock);
+	spin_lock_init(&vdev->fh_lock);
 	INIT_LIST_HEAD(&vdev->fh_list);
 
 	/* Part 1: check device type */
diff --git a/drivers/media/v4l2-core/v4l2-event.c b/drivers/media/v4l2-core/v4l2-event.c
index 814f70a..86dcb54 100644
--- a/drivers/media/v4l2-core/v4l2-event.c
+++ b/drivers/media/v4l2-core/v4l2-event.c
@@ -41,10 +41,10 @@ static int __v4l2_event_dequeue(struct v4l2_fh *fh, struct v4l2_event *event)
 	struct v4l2_kevent *kev;
 	unsigned long flags;
 
-	raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 
 	if (list_empty(&fh->available)) {
-		raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+		spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 		return -ENOENT;
 	}
 
@@ -59,7 +59,7 @@ static int __v4l2_event_dequeue(struct v4l2_fh *fh, struct v4l2_event *event)
 	kev->sev->first = sev_pos(kev->sev, 1);
 	kev->sev->in_use--;
 
-	raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 
 	return 0;
 }
@@ -98,7 +98,7 @@ static struct v4l2_subscribed_event *v4l2_event_subscribed(
 {
 	struct v4l2_subscribed_event *sev;
 
-	assert_raw_spin_locked(&fh->vdev->fh_lock);
+	assert_spin_locked(&fh->vdev->fh_lock);
 
 	list_for_each_entry(sev, &fh->subscribed, list)
 		if (sev->type == type && sev->id == id)
@@ -174,12 +174,12 @@ void v4l2_event_queue(struct video_device *vdev, const struct v4l2_event *ev)
 
 	ktime_get_ts(&timestamp);
 
-	raw_spin_lock_irqsave(&vdev->fh_lock, flags);
+	spin_lock_irqsave(&vdev->fh_lock, flags);
 
 	list_for_each_entry(fh, &vdev->fh_list, list)
 		__v4l2_event_queue_fh(fh, ev, &timestamp);
 
-	raw_spin_unlock_irqrestore(&vdev->fh_lock, flags);
+	spin_unlock_irqrestore(&vdev->fh_lock, flags);
 }
 EXPORT_SYMBOL_GPL(v4l2_event_queue);
 
@@ -190,9 +190,9 @@ void v4l2_event_queue_fh(struct v4l2_fh *fh, const struct v4l2_event *ev)
 
 	ktime_get_ts(&timestamp);
 
-	raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 	__v4l2_event_queue_fh(fh, ev, &timestamp);
-	raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 }
 EXPORT_SYMBOL_GPL(v4l2_event_queue_fh);
 
@@ -227,11 +227,11 @@ int v4l2_event_subscribe(struct v4l2_fh *fh,
 	sev->fh = fh;
 	sev->ops = ops;
 
-	raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 	found_ev = v4l2_event_subscribed(fh, sub->type, sub->id);
 	if (!found_ev)
 		list_add(&sev->list, &fh->subscribed);
-	raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 
 	if (found_ev) {
 		kfree(sev);
@@ -263,14 +263,14 @@ void v4l2_event_unsubscribe_all(struct v4l2_fh *fh)
 	do {
 		sev = NULL;
 
-		raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+		spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 		if (!list_empty(&fh->subscribed)) {
 			sev = list_first_entry(&fh->subscribed,
 					struct v4l2_subscribed_event, list);
 			sub.type = sev->type;
 			sub.id = sev->id;
 		}
-		raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+		spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 		if (sev)
 			v4l2_event_unsubscribe(fh, &sub);
 	} while (sev);
@@ -289,7 +289,7 @@ int v4l2_event_unsubscribe(struct v4l2_fh *fh,
 		return 0;
 	}
 
-	raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 
 	sev = v4l2_event_subscribed(fh, sub->type, sub->id);
 	if (sev != NULL) {
@@ -301,7 +301,7 @@ int v4l2_event_unsubscribe(struct v4l2_fh *fh,
 		list_del(&sev->list);
 	}
 
-	raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 
 	if (sev && sev->ops && sev->ops->del)
 		sev->ops->del(sev);
diff --git a/drivers/media/v4l2-core/v4l2-fh.c b/drivers/media/v4l2-core/v4l2-fh.c
index 6d0152c..e57c002 100644
--- a/drivers/media/v4l2-core/v4l2-fh.c
+++ b/drivers/media/v4l2-core/v4l2-fh.c
@@ -51,9 +51,9 @@ void v4l2_fh_add(struct v4l2_fh *fh)
 
 	if (test_bit(V4L2_FL_USE_FH_PRIO, &fh->vdev->flags))
 		v4l2_prio_open(fh->vdev->prio, &fh->prio);
-	raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 	list_add(&fh->list, &fh->vdev->fh_list);
-	raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 }
 EXPORT_SYMBOL_GPL(v4l2_fh_add);
 
@@ -75,9 +75,9 @@ void v4l2_fh_del(struct v4l2_fh *fh)
 {
 	unsigned long flags;
 
-	raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 	list_del_init(&fh->list);
-	raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 	if (test_bit(V4L2_FL_USE_FH_PRIO, &fh->vdev->flags))
 		v4l2_prio_close(fh->vdev->prio, fh->prio);
 }
@@ -112,9 +112,9 @@ int v4l2_fh_is_singular(struct v4l2_fh *fh)
 
 	if (fh == NULL || fh->vdev == NULL)
 		return 0;
-	raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 	is_singular = list_is_singular(&fh->list);
-	raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 	return is_singular;
 }
 EXPORT_SYMBOL_GPL(v4l2_fh_is_singular);
diff --git a/include/media/v4l2-dev.h b/include/media/v4l2-dev.h
index 8aa2913..95d1c91 100644
--- a/include/media/v4l2-dev.h
+++ b/include/media/v4l2-dev.h
@@ -122,7 +122,7 @@ struct video_device
 	int index;
 
 	/* V4L2 file handles */
-	raw_spinlock_t		fh_lock; /* Lock for all v4l2_fhs */
+	spinlock_t		fh_lock; /* Lock for all v4l2_fhs */
 	struct list_head	fh_list; /* List of struct v4l2_fh */
 
 	int debug;			/* Activates debug level*/
-- 
1.7.5.4

