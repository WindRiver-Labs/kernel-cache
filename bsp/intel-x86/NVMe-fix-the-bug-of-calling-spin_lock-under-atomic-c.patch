From 58738168807f56cfe732e24d377579e07a6ae364 Mon Sep 17 00:00:00 2001
From: fupan li <fupan.li@windriver.com>
Date: Thu, 12 Jun 2014 10:00:56 +0800
Subject: [PATCH] NVMe: fix the bug of calling spin_lock under atomic context
 on rt kernel

get_cpu_var() will call preempt_disable to into the atomic
context, in which is illegal to call spin_lock on rt kernel.
In fact, there is no need to disable preempt after getting the
cpu var, just making sure those codes referencing the cpu var
is not migrated to other cpus is ok on rt kernel. So here replacee
get_cpu_var/put_cpu_var with get_local_var/put_local_var.

Signed-off-by: fupan li <fupan.li@windriver.com>
---
 drivers/block/nvme-core.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/block/nvme-core.c b/drivers/block/nvme-core.c
index 7ecb670..c7edccd 100644
--- a/drivers/block/nvme-core.c
+++ b/drivers/block/nvme-core.c
@@ -279,7 +279,7 @@ static struct nvme_queue *raw_nvmeq(struct nvme_dev *dev, int qid)
 
 static struct nvme_queue *get_nvmeq(struct nvme_dev *dev) __acquires(RCU)
 {
-	unsigned queue_id = get_cpu_var(*dev->io_queue);
+	unsigned queue_id = get_local_var(*dev->io_queue);
 	rcu_read_lock();
 	return rcu_dereference(dev->queues[queue_id]);
 }
@@ -287,7 +287,7 @@ static struct nvme_queue *get_nvmeq(struct nvme_dev *dev) __acquires(RCU)
 static void put_nvmeq(struct nvme_queue *nvmeq) __releases(RCU)
 {
 	rcu_read_unlock();
-	put_cpu_var(nvmeq->dev->io_queue);
+	put_local_var(nvmeq->dev->io_queue);
 }
 
 static struct nvme_queue *lock_nvmeq(struct nvme_dev *dev, int q_idx)
-- 
1.7.5.4

