From c1fec69b7e819aa53e3e23947288dcac41449f7f Mon Sep 17 00:00:00 2001
From: Rex Zhu <Rex.Zhu@amd.com>
Date: Fri, 19 Aug 2016 20:42:09 +0800
Subject: [PATCH 0914/4301] drm/amd/powerplay: use smu7 common functions and
 data on Tonga.

commit ac43f0800f46f6648b49231b54646034a4143145 upstream

Signed-off-by: Rex Zhu <Rex.Zhu@amd.com>
Reviewed-by: Alex Deucher <alexander.deucher@amd.com>
Signed-off-by: Alex Deucher <alexander.deucher@amd.com>
---
 drivers/gpu/drm/amd/powerplay/smumgr/tonga_smc.c   |  201 +++---
 .../gpu/drm/amd/powerplay/smumgr/tonga_smumgr.c    |  657 +-------------------
 .../gpu/drm/amd/powerplay/smumgr/tonga_smumgr.h    |   33 +-
 3 files changed, 117 insertions(+), 774 deletions(-)

diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/tonga_smc.c b/drivers/gpu/drm/amd/powerplay/smumgr/tonga_smc.c
index 3acdbff..4dfd3f6 100644
--- a/drivers/gpu/drm/amd/powerplay/smumgr/tonga_smc.c
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/tonga_smc.c
@@ -347,27 +347,27 @@ static int tonga_populate_smc_voltage_tables(struct pp_hwmgr *hwmgr,
 	int result;
 
 	result = tonga_populate_smc_vddc_table(hwmgr, table);
-	PP_ASSERT_WITH_CODE(0 == result,
+	PP_ASSERT_WITH_CODE(!result,
 			"can not populate VDDC voltage table to SMC",
 			return -EINVAL);
 
 	result = tonga_populate_smc_vdd_ci_table(hwmgr, table);
-	PP_ASSERT_WITH_CODE(0 == result,
+	PP_ASSERT_WITH_CODE(!result,
 			"can not populate VDDCI voltage table to SMC",
 			return -EINVAL);
 
 	result = tonga_populate_smc_vdd_gfx_table(hwmgr, table);
-	PP_ASSERT_WITH_CODE(0 == result,
+	PP_ASSERT_WITH_CODE(!result,
 			"can not populate VDDGFX voltage table to SMC",
 			return -EINVAL);
 
 	result = tonga_populate_smc_mvdd_table(hwmgr, table);
-	PP_ASSERT_WITH_CODE(0 == result,
+	PP_ASSERT_WITH_CODE(!result,
 			"can not populate MVDD voltage table to SMC",
 			return -EINVAL);
 
 	result = tonga_populate_cac_tables(hwmgr, table);
-	PP_ASSERT_WITH_CODE(0 == result,
+	PP_ASSERT_WITH_CODE(!result,
 			"can not populate CAC voltage tables to SMC",
 			return -EINVAL);
 
@@ -542,7 +542,7 @@ static int tonga_populate_single_graphic_level(struct pp_hwmgr *hwmgr,
 	result = tonga_get_dependecy_volt_by_clk(hwmgr,
 		pptable_info->vdd_dep_on_sclk, engine_clock,
 		&graphic_level->MinVoltage, &mvdd);
-	PP_ASSERT_WITH_CODE((0 == result),
+	PP_ASSERT_WITH_CODE((!result),
 		"can not find VDDC voltage value for VDDC "
 		"engine clock dependency table", return result);
 
@@ -574,7 +574,7 @@ static int tonga_populate_single_graphic_level(struct pp_hwmgr *hwmgr,
 	/* Default to slow, highest DPM level will be set to PPSMC_DISPLAY_WATERMARK_LOW later.*/
 	graphic_level->DisplayWatermark = PPSMC_DISPLAY_WATERMARK_LOW;
 
-	if (0 == result) {
+	if (!result) {
 		/* CONVERT_FROM_HOST_TO_SMC_UL(graphic_level->MinVoltage);*/
 		/* CONVERT_FROM_HOST_TO_SMC_UL(graphic_level->MinVddcPhases);*/
 		CONVERT_FROM_HOST_TO_SMC_UL(graphic_level->SclkFrequency);
@@ -603,7 +603,7 @@ int tonga_populate_all_graphic_levels(struct pp_hwmgr *hwmgr)
 	struct smu7_dpm_table *dpm_table = &data->dpm_table;
 	struct phm_ppt_v1_pcie_table *pcie_table = pptable_info->pcie_table;
 	uint8_t pcie_entry_count = (uint8_t) data->dpm_table.pcie_speed_table.count;
-	uint32_t level_array_address = smu_data->dpm_table_start +
+	uint32_t level_array_address = smu_data->smu7_data.dpm_table_start +
 				offsetof(SMU72_Discrete_DpmTable, GraphicsLevel);
 
 	uint32_t level_array_size = sizeof(SMU72_Discrete_GraphicsLevel) *
@@ -690,7 +690,7 @@ int tonga_populate_all_graphic_levels(struct pp_hwmgr *hwmgr)
 		smu_data->smc_state_table.GraphicsLevel[1].pcieDpmLevel = mid_pcie_level_enabled;
 	}
 	/* level count will send to smc once at init smc table and never change*/
-	result = tonga_copy_bytes_to_smc(hwmgr->smumgr, level_array_address,
+	result = smu7_copy_bytes_to_smc(hwmgr->smumgr, level_array_address,
 				(uint8_t *)levels, (uint32_t)level_array_size,
 								SMC_RAM_END);
 
@@ -730,7 +730,7 @@ static int tonga_calculate_mclk_params(
 	result = atomctrl_get_memory_pll_dividers_si(hwmgr,
 				memory_clock, &mpll_param, strobe_mode);
 	PP_ASSERT_WITH_CODE(
-			0 == result,
+			!result,
 			"Error retrieving Memory Clock Parameters from VBIOS.",
 			return result);
 
@@ -900,7 +900,7 @@ static int tonga_populate_single_memory_level(
 				memory_clock,
 				&memory_level->MinVoltage, &mvdd);
 		PP_ASSERT_WITH_CODE(
-			0 == result,
+			!result,
 			"can not find MinVddc voltage value from memory VDDC "
 			"voltage dependency table",
 			return result);
@@ -1008,7 +1008,7 @@ int tonga_populate_all_memory_levels(struct pp_hwmgr *hwmgr)
 
 	/* populate MCLK dpm table to SMU7 */
 	uint32_t level_array_address =
-				smu_data->dpm_table_start +
+				smu_data->smu7_data.dpm_table_start +
 				offsetof(SMU72_Discrete_DpmTable, MemoryLevel);
 	uint32_t level_array_size =
 				sizeof(SMU72_Discrete_MemoryLevel) *
@@ -1048,11 +1048,10 @@ int tonga_populate_all_memory_levels(struct pp_hwmgr *hwmgr)
 	smu_data->smc_state_table.MemoryLevel[dpm_table->mclk_table.count-1].DisplayWatermark = PPSMC_DISPLAY_WATERMARK_HIGH;
 
 	/* level count will send to smc once at init smc table and never change*/
-	result = tonga_copy_bytes_to_smc(hwmgr->smumgr,
+	result = smu7_copy_bytes_to_smc(hwmgr->smumgr,
 		level_array_address, (uint8_t *)levels, (uint32_t)level_array_size,
 		SMC_RAM_END);
 
-
 	return result;
 }
 
@@ -1257,7 +1256,7 @@ static int tonga_populate_smc_uvd_level(struct pp_hwmgr *hwmgr,
 					table->UvdLevel[count].VclkFrequency,
 					&dividers);
 
-		PP_ASSERT_WITH_CODE((0 == result),
+		PP_ASSERT_WITH_CODE((!result),
 				    "can not find divide id for Vclk clock",
 					return result);
 
@@ -1265,7 +1264,7 @@ static int tonga_populate_smc_uvd_level(struct pp_hwmgr *hwmgr,
 
 		result = atomctrl_get_dfs_pll_dividers_vi(hwmgr,
 							  table->UvdLevel[count].DclkFrequency, &dividers);
-		PP_ASSERT_WITH_CODE((0 == result),
+		PP_ASSERT_WITH_CODE((!result),
 				    "can not find divide id for Dclk clock",
 					return result);
 
@@ -1314,7 +1313,7 @@ static int tonga_populate_smc_vce_level(struct pp_hwmgr *hwmgr,
 		/* retrieve divider value for VBIOS */
 		result = atomctrl_get_dfs_pll_dividers_vi(hwmgr,
 					table->VceLevel[count].Frequency, &dividers);
-		PP_ASSERT_WITH_CODE((0 == result),
+		PP_ASSERT_WITH_CODE((!result),
 				"can not find divide id for VCE engine clock",
 				return result);
 
@@ -1359,7 +1358,7 @@ static int tonga_populate_smc_acp_level(struct pp_hwmgr *hwmgr,
 		/* retrieve divider value for VBIOS */
 		result = atomctrl_get_dfs_pll_dividers_vi(hwmgr,
 			table->AcpLevel[count].Frequency, &dividers);
-		PP_ASSERT_WITH_CODE((0 == result),
+		PP_ASSERT_WITH_CODE((!result),
 			"can not find divide id for engine clock", return result);
 
 		table->AcpLevel[count].Divider = (uint8_t)dividers.pll_post_divider;
@@ -1404,7 +1403,7 @@ static int tonga_populate_smc_samu_level(struct pp_hwmgr *hwmgr,
 		/* retrieve divider value for VBIOS */
 		result = atomctrl_get_dfs_pll_dividers_vi(hwmgr,
 					table->SamuLevel[count].Frequency, &dividers);
-		PP_ASSERT_WITH_CODE((0 == result),
+		PP_ASSERT_WITH_CODE((!result),
 			"can not find divide id for samu clock", return result);
 
 		table->SamuLevel[count].Divider = (uint8_t)dividers.pll_post_divider;
@@ -1474,10 +1473,10 @@ static int tonga_program_memory_timing_parameters(struct pp_hwmgr *hwmgr)
 		}
 	}
 
-	if (0 == result) {
-		result = tonga_copy_bytes_to_smc(
+	if (!result) {
+		result = smu7_copy_bytes_to_smc(
 				hwmgr->smumgr,
-				smu_data->arb_table_start,
+				smu_data->smu7_data.arb_table_start,
 				(uint8_t *)&arb_regs,
 				sizeof(SMU72_Discrete_MCArbDramTimingTable),
 				SMC_RAM_END
@@ -1502,7 +1501,7 @@ static int tonga_populate_smc_boot_level(struct pp_hwmgr *hwmgr,
 	data->vbios_boot_state.sclk_bootup_value,
 	(uint32_t *)&(smu_data->smc_state_table.GraphicsBootLevel));
 
-	if (0 != result) {
+	if (result != 0) {
 		smu_data->smc_state_table.GraphicsBootLevel = 0;
 		printk(KERN_ERR "[powerplay] VBIOS did not find boot engine "
 				"clock value in dependency table. "
@@ -1514,7 +1513,7 @@ static int tonga_populate_smc_boot_level(struct pp_hwmgr *hwmgr,
 		data->vbios_boot_state.mclk_bootup_value,
 		(uint32_t *)&(smu_data->smc_state_table.MemoryBootLevel));
 
-	if (0 != result) {
+	if (result != 0) {
 		smu_data->smc_state_table.MemoryBootLevel = 0;
 		printk(KERN_ERR "[powerplay] VBIOS did not find boot "
 				"engine clock value in dependency table."
@@ -1538,7 +1537,6 @@ static int tonga_populate_smc_boot_level(struct pp_hwmgr *hwmgr,
 	return result;
 }
 
-
 static int tonga_populate_clock_stretcher_data_table(struct pp_hwmgr *hwmgr)
 {
 	uint32_t ro, efuse, efuse2, clock_freq, volt_without_cks,
@@ -1591,6 +1589,7 @@ static int tonga_populate_clock_stretcher_data_table(struct pp_hwmgr *hwmgr)
 	/* Populate Stretch amount */
 	smu_data->smc_state_table.ClockStretcherAmount = stretch_amount;
 
+
 	/* Populate Sclk_CKS_masterEn0_7 and Sclk_voltageOffset */
 	for (i = 0; i < sclk_table->count; i++) {
 		smu_data->smc_state_table.Sclk_CKS_masterEn0_7 |=
@@ -1798,17 +1797,17 @@ static int tonga_init_arb_table_index(struct pp_smumgr *smumgr)
 	* In reality this field should not be in that structure
 	* but in a soft register.
 	*/
-	result = tonga_read_smc_sram_dword(smumgr,
-				smu_data->arb_table_start, &tmp, SMC_RAM_END);
+	result = smu7_read_smc_sram_dword(smumgr,
+				smu_data->smu7_data.arb_table_start, &tmp, SMC_RAM_END);
 
-	if (0 != result)
+	if (result != 0)
 		return result;
 
 	tmp &= 0x00FFFFFF;
 	tmp |= ((uint32_t)MC_CG_ARB_FREQ_F1) << 24;
 
-	return tonga_write_smc_sram_dword(smumgr,
-			smu_data->arb_table_start,  tmp, SMC_RAM_END);
+	return smu7_write_smc_sram_dword(smumgr,
+			smu_data->smu7_data.arb_table_start, tmp, SMC_RAM_END);
 }
 
 
@@ -1903,7 +1902,7 @@ static int tonga_populate_dw8(struct pp_hwmgr *hwmgr, uint32_t fuse_table_offset
 	struct tonga_pt_defaults *defaults = smu_data->power_tune_defaults;
 	uint32_t temp;
 
-	if (tonga_read_smc_sram_dword(hwmgr->smumgr,
+	if (smu7_read_smc_sram_dword(hwmgr->smumgr,
 			fuse_table_offset +
 			offsetof(SMU72_Discrete_PmFuses, TdcWaterfallCtl),
 			(uint32_t *)&temp, SMC_RAM_END))
@@ -1994,7 +1993,7 @@ static int tonga_populate_pm_fuses(struct pp_hwmgr *hwmgr)
 
 	if (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,
 			PHM_PlatformCaps_PowerContainment)) {
-		if (tonga_read_smc_sram_dword(hwmgr->smumgr,
+		if (smu7_read_smc_sram_dword(hwmgr->smumgr,
 				SMU72_FIRMWARE_HEADER_LOCATION +
 				offsetof(SMU72_Firmware_Header, PmFuseTable),
 				&pm_fuse_table_offset, SMC_RAM_END))
@@ -2052,7 +2051,7 @@ static int tonga_populate_pm_fuses(struct pp_hwmgr *hwmgr)
 				"Hi and Lo Sidd Failed !",
 				return -EINVAL);
 
-		if (tonga_copy_bytes_to_smc(hwmgr->smumgr, pm_fuse_table_offset,
+		if (smu7_copy_bytes_to_smc(hwmgr->smumgr, pm_fuse_table_offset,
 				(uint8_t *)&smu_data->power_tune_table,
 				sizeof(struct SMU72_Discrete_PmFuses), SMC_RAM_END))
 			PP_ASSERT_WITH_CODE(false,
@@ -2173,10 +2172,10 @@ static int tonga_update_and_upload_mc_reg_table(struct pp_hwmgr *hwmgr)
 		return result;
 
 
-	address = smu_data->mc_reg_table_start +
+	address = smu_data->smu7_data.mc_reg_table_start +
 			(uint32_t)offsetof(SMU72_Discrete_MCRegisters, data[0]);
 
-	return  tonga_copy_bytes_to_smc(
+	return  smu7_copy_bytes_to_smc(
 			hwmgr->smumgr, address,
 			(uint8_t *)&smu_data->mc_regs.data[0],
 			sizeof(SMU72_Discrete_MCRegisterSet) *
@@ -2192,16 +2191,16 @@ static int tonga_populate_initial_mc_reg_table(struct pp_hwmgr *hwmgr)
 
 	memset(&smu_data->mc_regs, 0x00, sizeof(SMU72_Discrete_MCRegisters));
 	result = tonga_populate_mc_reg_address(smumgr, &(smu_data->mc_regs));
-	PP_ASSERT_WITH_CODE(0 == result,
+	PP_ASSERT_WITH_CODE(!result,
 		"Failed to initialize MCRegTable for the MC register addresses !",
 		return result;);
 
 	result = tonga_convert_mc_reg_table_to_smc(hwmgr, &smu_data->mc_regs);
-	PP_ASSERT_WITH_CODE(0 == result,
+	PP_ASSERT_WITH_CODE(!result,
 		"Failed to initialize MCRegTable for driver state !",
 		return result;);
 
-	return tonga_copy_bytes_to_smc(smumgr, smu_data->mc_reg_table_start,
+	return smu7_copy_bytes_to_smc(smumgr, smu_data->smu7_data.mc_reg_table_start,
 			(uint8_t *)&smu_data->mc_regs, sizeof(SMU72_Discrete_MCRegisters), SMC_RAM_END);
 }
 
@@ -2268,7 +2267,7 @@ int tonga_init_smc_table(struct pp_hwmgr *hwmgr)
 
 	if (data->ulv_supported && table_info->us_ulv_voltage_offset) {
 		result = tonga_populate_ulv_state(hwmgr, table);
-		PP_ASSERT_WITH_CODE(0 == result,
+		PP_ASSERT_WITH_CODE(!result,
 			"Failed to initialize ULV state !",
 			return result;);
 
@@ -2277,31 +2276,31 @@ int tonga_init_smc_table(struct pp_hwmgr *hwmgr)
 	}
 
 	result = tonga_populate_smc_link_level(hwmgr, table);
-	PP_ASSERT_WITH_CODE(0 == result,
+	PP_ASSERT_WITH_CODE(!result,
 		"Failed to initialize Link Level !", return result);
 
 	result = tonga_populate_all_graphic_levels(hwmgr);
-	PP_ASSERT_WITH_CODE(0 == result,
+	PP_ASSERT_WITH_CODE(!result,
 		"Failed to initialize Graphics Level !", return result);
 
 	result = tonga_populate_all_memory_levels(hwmgr);
-	PP_ASSERT_WITH_CODE(0 == result,
+	PP_ASSERT_WITH_CODE(!result,
 		"Failed to initialize Memory Level !", return result);
 
 	result = tonga_populate_smc_acpi_level(hwmgr, table);
-	PP_ASSERT_WITH_CODE(0 == result,
+	PP_ASSERT_WITH_CODE(!result,
 		"Failed to initialize ACPI Level !", return result);
 
 	result = tonga_populate_smc_vce_level(hwmgr, table);
-	PP_ASSERT_WITH_CODE(0 == result,
+	PP_ASSERT_WITH_CODE(!result,
 		"Failed to initialize VCE Level !", return result);
 
 	result = tonga_populate_smc_acp_level(hwmgr, table);
-	PP_ASSERT_WITH_CODE(0 == result,
+	PP_ASSERT_WITH_CODE(!result,
 		"Failed to initialize ACP Level !", return result);
 
 	result = tonga_populate_smc_samu_level(hwmgr, table);
-	PP_ASSERT_WITH_CODE(0 == result,
+	PP_ASSERT_WITH_CODE(!result,
 		"Failed to initialize SAMU Level !", return result);
 
 	/* Since only the initial state is completely set up at this
@@ -2309,26 +2308,26 @@ int tonga_init_smc_table(struct pp_hwmgr *hwmgr)
 	* need to populate the  ARB settings for the initial state.
 	*/
 	result = tonga_program_memory_timing_parameters(hwmgr);
-	PP_ASSERT_WITH_CODE(0 == result,
+	PP_ASSERT_WITH_CODE(!result,
 		"Failed to Write ARB settings for the initial state.",
 		return result;);
 
 	result = tonga_populate_smc_uvd_level(hwmgr, table);
-	PP_ASSERT_WITH_CODE(0 == result,
+	PP_ASSERT_WITH_CODE(!result,
 		"Failed to initialize UVD Level !", return result);
 
 	result = tonga_populate_smc_boot_level(hwmgr, table);
-	PP_ASSERT_WITH_CODE(0 == result,
+	PP_ASSERT_WITH_CODE(!result,
 		"Failed to initialize Boot Level !", return result);
 
 	tonga_populate_bapm_parameters_in_dpm_table(hwmgr);
-	PP_ASSERT_WITH_CODE(0 == result,
+	PP_ASSERT_WITH_CODE(!result,
 		"Failed to populate BAPM Parameters !", return result);
 
 	if (phm_cap_enabled(hwmgr->platform_descriptor.platformCaps,
 			PHM_PlatformCaps_ClockStretcher)) {
 		result = tonga_populate_clock_stretcher_data_table(hwmgr);
-		PP_ASSERT_WITH_CODE(0 == result,
+		PP_ASSERT_WITH_CODE(!result,
 			"Failed to populate Clock Stretcher Data Table !",
 			return result;);
 	}
@@ -2367,7 +2366,7 @@ int tonga_init_smc_table(struct pp_hwmgr *hwmgr)
 	table->PCIeGenInterval  = 1;
 
 	result = tonga_populate_vr_config(hwmgr, table);
-	PP_ASSERT_WITH_CODE(0 == result,
+	PP_ASSERT_WITH_CODE(!result,
 		"Failed to populate VRConfig setting !", return result);
 
 	table->ThermGpio  = 17;
@@ -2448,26 +2447,26 @@ int tonga_init_smc_table(struct pp_hwmgr *hwmgr)
 	CONVERT_FROM_HOST_TO_SMC_US(table->PhaseResponseTime);
 
 	/* Upload all dpm data to SMC memory.(dpm level, dpm level count etc) */
-	result = tonga_copy_bytes_to_smc(
+	result = smu7_copy_bytes_to_smc(
 			hwmgr->smumgr,
-			smu_data->dpm_table_start + offsetof(SMU72_Discrete_DpmTable, SystemFlags),
+			smu_data->smu7_data.dpm_table_start + offsetof(SMU72_Discrete_DpmTable, SystemFlags),
 			(uint8_t *)&(table->SystemFlags),
 			sizeof(SMU72_Discrete_DpmTable) - 3 * sizeof(SMU72_PIDController),
 			SMC_RAM_END);
 
-	PP_ASSERT_WITH_CODE(0 == result,
+	PP_ASSERT_WITH_CODE(!result,
 		"Failed to upload dpm data to SMC memory !", return result;);
 
 	result = tonga_init_arb_table_index(hwmgr->smumgr);
-	PP_ASSERT_WITH_CODE(0 == result,
+	PP_ASSERT_WITH_CODE(!result,
 			"Failed to upload arb data to SMC memory !", return result);
 
 	tonga_populate_pm_fuses(hwmgr);
-	PP_ASSERT_WITH_CODE((0 == result),
+	PP_ASSERT_WITH_CODE((!result),
 		"Failed to populate initialize pm fuses !", return result);
 
 	result = tonga_populate_initial_mc_reg_table(hwmgr);
-	PP_ASSERT_WITH_CODE((0 == result),
+	PP_ASSERT_WITH_CODE((!result),
 		"Failed to populate initialize MC Reg table !", return result);
 
 	return 0;
@@ -2498,7 +2497,7 @@ int tonga_thermal_setup_fan_table(struct pp_hwmgr *hwmgr)
 					PHM_PlatformCaps_MicrocodeFanControl))
 		return 0;
 
-	if (0 == smu_data->fan_table_start) {
+	if (0 == smu_data->smu7_data.fan_table_start) {
 		phm_cap_unset(hwmgr->platform_descriptor.platformCaps,
 					PHM_PlatformCaps_MicrocodeFanControl);
 		return 0;
@@ -2558,19 +2557,12 @@ int tonga_thermal_setup_fan_table(struct pp_hwmgr *hwmgr)
 
 	fan_table.FanControl_GL_Flag = 1;
 
-	res = tonga_copy_bytes_to_smc(hwmgr->smumgr, smu_data->fan_table_start, (uint8_t *)&fan_table, (uint32_t)sizeof(fan_table), SMC_RAM_END);
-/* TO DO FOR SOME DEVICE ID 0X692b, send this msg return invalid command.
-	if (res == 0 && hwmgr->thermal_controller.advanceFanControlParameters.ucMinimumPWMLimit != 0)
-		res = (0 == smum_send_msg_to_smc_with_parameter(hwmgr->smumgr, PPSMC_MSG_SetFanMinPwm, \
-						hwmgr->thermal_controller.advanceFanControlParameters.ucMinimumPWMLimit) ? 0 : -1);
+	res = smu7_copy_bytes_to_smc(hwmgr->smumgr,
+					smu_data->smu7_data.fan_table_start,
+					(uint8_t *)&fan_table,
+					(uint32_t)sizeof(fan_table),
+					SMC_RAM_END);
 
-	if (res == 0 && hwmgr->thermal_controller.advanceFanControlParameters.ulMinFanSCLKAcousticLimit != 0)
-		res = (0 == smum_send_msg_to_smc_with_parameter(hwmgr->smumgr, PPSMC_MSG_SetFanSclkTarget, \
-					hwmgr->thermal_controller.advanceFanControlParameters.ulMinFanSCLKAcousticLimit) ? 0 : -1);
-
-	if (0 != res)
-		phm_cap_unset(hwmgr->platform_descriptor.platformCaps, PHM_PlatformCaps_MicrocodeFanControl);
-*/
 	return 0;
 }
 
@@ -2606,9 +2598,9 @@ int tonga_update_sclk_threshold(struct pp_hwmgr *hwmgr)
 
 		CONVERT_FROM_HOST_TO_SMC_UL(low_sclk_interrupt_threshold);
 
-		result = tonga_copy_bytes_to_smc(
+		result = smu7_copy_bytes_to_smc(
 				hwmgr->smumgr,
-				smu_data->dpm_table_start +
+				smu_data->smu7_data.dpm_table_start +
 				offsetof(SMU72_Discrete_DpmTable,
 					LowSclkInterruptThreshold),
 				(uint8_t *)&low_sclk_interrupt_threshold,
@@ -2618,7 +2610,7 @@ int tonga_update_sclk_threshold(struct pp_hwmgr *hwmgr)
 
 	result = tonga_update_and_upload_mc_reg_table(hwmgr);
 
-	PP_ASSERT_WITH_CODE((0 == result),
+	PP_ASSERT_WITH_CODE((!result),
 				"Failed to upload MC reg table !",
 				return result);
 
@@ -2645,6 +2637,8 @@ uint32_t tonga_get_offsetof(uint32_t type, uint32_t member)
 			return offsetof(SMU72_SoftRegisters, PreVBlankGap);
 		case VBlankTimeout:
 			return offsetof(SMU72_SoftRegisters, VBlankTimeout);
+		case UcodeLoadStatus:
+			return offsetof(SMU72_SoftRegisters, UcodeLoadStatus);
 		}
 	case SMU_Discrete_DpmTable:
 		switch (member) {
@@ -2700,7 +2694,7 @@ static int tonga_update_uvd_smc_table(struct pp_hwmgr *hwmgr)
 	if (table_info->mm_dep_table->count > 0)
 		smu_data->smc_state_table.UvdBootLevel =
 				(uint8_t) (table_info->mm_dep_table->count - 1);
-	mm_boot_level_offset = smu_data->dpm_table_start +
+	mm_boot_level_offset = smu_data->smu7_data.dpm_table_start +
 				offsetof(SMU72_Discrete_DpmTable, UvdBootLevel);
 	mm_boot_level_offset /= 4;
 	mm_boot_level_offset *= 4;
@@ -2734,7 +2728,7 @@ static int tonga_update_vce_smc_table(struct pp_hwmgr *hwmgr)
 	smu_data->smc_state_table.VceBootLevel =
 		(uint8_t) (table_info->mm_dep_table->count - 1);
 
-	mm_boot_level_offset = smu_data->dpm_table_start +
+	mm_boot_level_offset = smu_data->smu7_data.dpm_table_start +
 					offsetof(SMU72_Discrete_DpmTable, VceBootLevel);
 	mm_boot_level_offset /= 4;
 	mm_boot_level_offset *= 4;
@@ -2759,7 +2753,7 @@ static int tonga_update_samu_smc_table(struct pp_hwmgr *hwmgr)
 	uint32_t mm_boot_level_offset, mm_boot_level_value;
 
 	smu_data->smc_state_table.SamuBootLevel = 0;
-	mm_boot_level_offset = smu_data->dpm_table_start +
+	mm_boot_level_offset = smu_data->smu7_data.dpm_table_start +
 				offsetof(SMU72_Discrete_DpmTable, SamuBootLevel);
 
 	mm_boot_level_offset /= 4;
@@ -2813,67 +2807,66 @@ int tonga_process_firmware_header(struct pp_hwmgr *hwmgr)
 	int result;
 	bool error = false;
 
-	result = tonga_read_smc_sram_dword(hwmgr->smumgr,
+	result = smu7_read_smc_sram_dword(hwmgr->smumgr,
 				SMU72_FIRMWARE_HEADER_LOCATION +
 				offsetof(SMU72_Firmware_Header, DpmTable),
 				&tmp, SMC_RAM_END);
 
-	if (0 == result)
-		smu_data->dpm_table_start = tmp;
+	if (!result)
+		smu_data->smu7_data.dpm_table_start = tmp;
 
-	error |= (0 != result);
+	error |= (result != 0);
 
-	result = tonga_read_smc_sram_dword(hwmgr->smumgr,
+	result = smu7_read_smc_sram_dword(hwmgr->smumgr,
 				SMU72_FIRMWARE_HEADER_LOCATION +
 				offsetof(SMU72_Firmware_Header, SoftRegisters),
 				&tmp, SMC_RAM_END);
 
-	if (0 == result) {
+	if (!result) {
 		data->soft_regs_start = tmp;
-		smu_data->soft_regs_start = tmp;
+		smu_data->smu7_data.soft_regs_start = tmp;
 	}
 
-	error |= (0 != result);
+	error |= (result != 0);
 
 
-	result = tonga_read_smc_sram_dword(hwmgr->smumgr,
+	result = smu7_read_smc_sram_dword(hwmgr->smumgr,
 				SMU72_FIRMWARE_HEADER_LOCATION +
 				offsetof(SMU72_Firmware_Header, mcRegisterTable),
 				&tmp, SMC_RAM_END);
 
-	if (0 == result)
-		smu_data->mc_reg_table_start = tmp;
+	if (!result)
+		smu_data->smu7_data.mc_reg_table_start = tmp;
 
-
-	result = tonga_read_smc_sram_dword(hwmgr->smumgr,
+	result = smu7_read_smc_sram_dword(hwmgr->smumgr,
 				SMU72_FIRMWARE_HEADER_LOCATION +
 				offsetof(SMU72_Firmware_Header, FanTable),
 				&tmp, SMC_RAM_END);
 
-	if (0 == result)
-		smu_data->fan_table_start = tmp;
+	if (!result)
+		smu_data->smu7_data.fan_table_start = tmp;
 
-	error |= (0 != result);
+	error |= (result != 0);
 
-	result = tonga_read_smc_sram_dword(hwmgr->smumgr,
+	result = smu7_read_smc_sram_dword(hwmgr->smumgr,
 				SMU72_FIRMWARE_HEADER_LOCATION +
 				offsetof(SMU72_Firmware_Header, mcArbDramTimingTable),
 				&tmp, SMC_RAM_END);
 
-	if (0 == result)
-		smu_data->arb_table_start = tmp;
+	if (!result)
+		smu_data->smu7_data.arb_table_start = tmp;
 
-	error |= (0 != result);
+	error |= (result != 0);
 
-	result = tonga_read_smc_sram_dword(hwmgr->smumgr,
+	result = smu7_read_smc_sram_dword(hwmgr->smumgr,
 				SMU72_FIRMWARE_HEADER_LOCATION +
 				offsetof(SMU72_Firmware_Header, Version),
 				&tmp, SMC_RAM_END);
 
-	if (0 == result)
+	if (!result)
 		hwmgr->microcode_version_info.SMC = tmp;
 
-	error |= (0 != result);
+	error |= (result != 0);
 
 	return error ? 1 : 0;
 }
@@ -3141,7 +3134,7 @@ int tonga_initialize_mc_reg_table(struct pp_hwmgr *hwmgr)
 
 	table = kzalloc(sizeof(pp_atomctrl_mc_reg_table), GFP_KERNEL);
 
-	if (NULL == table)
+	if (table == NULL)
 		return -ENOMEM;
 
 	/* Program additional LP registers that are no longer programmed by VBIOS */
@@ -3190,15 +3183,15 @@ int tonga_initialize_mc_reg_table(struct pp_hwmgr *hwmgr)
 
 	result = atomctrl_initialize_mc_reg_table(hwmgr, module_index, table);
 
-	if (0 == result)
+	if (!result)
 		result = tonga_copy_vbios_smc_reg_table(table, ni_table);
 
-	if (0 == result) {
+	if (!result) {
 		tonga_set_s0_mc_reg_index(ni_table);
 		result = tonga_set_mc_special_registers(hwmgr, ni_table);
 	}
 
-	if (0 == result)
+	if (!result)
 		tonga_set_valid_flag(ni_table);
 
 	kfree(table);
diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/tonga_smumgr.c b/drivers/gpu/drm/amd/powerplay/smumgr/tonga_smumgr.c
index b543d6c..5f91240 100644
--- a/drivers/gpu/drm/amd/powerplay/smumgr/tonga_smumgr.c
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/tonga_smumgr.c
@@ -34,587 +34,8 @@
 #include "smu/smu_7_1_2_sh_mask.h"
 #include "cgs_common.h"
 #include "tonga_smc.h"
+#include "smu7_smumgr.h"
 
-#define TONGA_SMC_SIZE			0x20000
-#define BUFFER_SIZE			80000
-#define MAX_STRING_SIZE			15
-#define BUFFER_SIZETWO              131072 /*128 *1024*/
-
-/**
-* Set the address for reading/writing the SMC SRAM space.
-* @param    smumgr  the address of the powerplay hardware manager.
-* @param    smcAddress the address in the SMC RAM to access.
-*/
-static int tonga_set_smc_sram_address(struct pp_smumgr *smumgr,
-				uint32_t smcAddress, uint32_t limit)
-{
-	if (smumgr == NULL || smumgr->device == NULL)
-		return -EINVAL;
-	PP_ASSERT_WITH_CODE((0 == (3 & smcAddress)),
-		"SMC address must be 4 byte aligned.",
-		return -1;);
-
-	PP_ASSERT_WITH_CODE((limit > (smcAddress + 3)),
-		"SMC address is beyond the SMC RAM area.",
-		return -1;);
-
-	cgs_write_register(smumgr->device, mmSMC_IND_INDEX_0, smcAddress);
-	SMUM_WRITE_FIELD(smumgr->device, SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_11, 0);
-
-	return 0;
-}
-
-/**
-* Copy bytes from an array into the SMC RAM space.
-*
-* @param    smumgr  the address of the powerplay SMU manager.
-* @param    smcStartAddress the start address in the SMC RAM to copy bytes to.
-* @param    src the byte array to copy the bytes from.
-* @param    byteCount the number of bytes to copy.
-*/
-int tonga_copy_bytes_to_smc(struct pp_smumgr *smumgr,
-		uint32_t smcStartAddress, const uint8_t *src,
-		uint32_t byteCount, uint32_t limit)
-{
-	uint32_t addr;
-	uint32_t data, orig_data;
-	int result = 0;
-	uint32_t extra_shift;
-
-	if (smumgr == NULL || smumgr->device == NULL)
-		return -EINVAL;
-	PP_ASSERT_WITH_CODE((0 == (3 & smcStartAddress)),
-		"SMC address must be 4 byte aligned.",
-		return 0;);
-
-	PP_ASSERT_WITH_CODE((limit > (smcStartAddress + byteCount)),
-		"SMC address is beyond the SMC RAM area.",
-		return 0;);
-
-	addr = smcStartAddress;
-
-	while (byteCount >= 4) {
-		/*
-		 * Bytes are written into the
-		 * SMC address space with the MSB first
-		 */
-		data = (src[0] << 24) + (src[1] << 16) + (src[2] << 8) + src[3];
-
-		result = tonga_set_smc_sram_address(smumgr, addr, limit);
-
-		if (result)
-			goto out;
-
-		cgs_write_register(smumgr->device, mmSMC_IND_DATA_0, data);
-
-		src += 4;
-		byteCount -= 4;
-		addr += 4;
-	}
-
-	if (0 != byteCount) {
-		/* Now write odd bytes left, do a read modify write cycle */
-		data = 0;
-
-		result = tonga_set_smc_sram_address(smumgr, addr, limit);
-		if (result)
-			goto out;
-
-		orig_data = cgs_read_register(smumgr->device,
-							mmSMC_IND_DATA_0);
-		extra_shift = 8 * (4 - byteCount);
-
-		while (byteCount > 0) {
-			data = (data << 8) + *src++;
-			byteCount--;
-		}
-
-		data <<= extra_shift;
-		data |= (orig_data & ~((~0UL) << extra_shift));
-
-		result = tonga_set_smc_sram_address(smumgr, addr, limit);
-		if (result)
-			goto out;
-
-		cgs_write_register(smumgr->device, mmSMC_IND_DATA_0, data);
-	}
-
-out:
-	return result;
-}
-
-
-int tonga_program_jump_on_start(struct pp_smumgr *smumgr)
-{
-	static const unsigned char pData[] = { 0xE0, 0x00, 0x80, 0x40 };
-
-	tonga_copy_bytes_to_smc(smumgr, 0x0, pData, 4, sizeof(pData)+1);
-
-	return 0;
-}
-
-/**
-* Return if the SMC is currently running.
-*
-* @param    smumgr  the address of the powerplay hardware manager.
-*/
-static int tonga_is_smc_ram_running(struct pp_smumgr *smumgr)
-{
-	return ((0 == SMUM_READ_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,
-					SMC_SYSCON_CLOCK_CNTL_0, ck_disable))
-			&& (0x20100 <= cgs_read_ind_register(smumgr->device,
-					CGS_IND_REG__SMC, ixSMC_PC_C)));
-}
-
-static int tonga_send_msg_to_smc_offset(struct pp_smumgr *smumgr)
-{
-	if (smumgr == NULL || smumgr->device == NULL)
-		return -EINVAL;
-
-	SMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);
-
-	cgs_write_register(smumgr->device, mmSMC_MSG_ARG_0, 0x20000);
-	cgs_write_register(smumgr->device, mmSMC_MESSAGE_0, PPSMC_MSG_Test);
-
-	SMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);
-
-	return 0;
-}
-
-/**
-* Send a message to the SMC, and wait for its response.
-*
-* @param    smumgr  the address of the powerplay hardware manager.
-* @param    msg the message to send.
-* @return   The response that came from the SMC.
-*/
-static int tonga_send_msg_to_smc(struct pp_smumgr *smumgr, uint16_t msg)
-{
-	if (smumgr == NULL || smumgr->device == NULL)
-		return -EINVAL;
-
-	if (!tonga_is_smc_ram_running(smumgr))
-		return -1;
-
-	SMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);
-	PP_ASSERT_WITH_CODE(
-		1 == SMUM_READ_FIELD(smumgr->device, SMC_RESP_0, SMC_RESP),
-		"Failed to send Previous Message.",
-		);
-
-	cgs_write_register(smumgr->device, mmSMC_MESSAGE_0, msg);
-
-	SMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);
-	PP_ASSERT_WITH_CODE(
-		1 == SMUM_READ_FIELD(smumgr->device, SMC_RESP_0, SMC_RESP),
-		"Failed to send Message.",
-		);
-
-	return 0;
-}
-
-/*
-* Send a message to the SMC, and do not wait for its response.
-*
-* @param    smumgr  the address of the powerplay hardware manager.
-* @param    msg the message to send.
-* @return   The response that came from the SMC.
-*/
-static int tonga_send_msg_to_smc_without_waiting
-				(struct pp_smumgr *smumgr, uint16_t msg)
-{
-	if (smumgr == NULL || smumgr->device == NULL)
-		return -EINVAL;
-
-	SMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);
-	PP_ASSERT_WITH_CODE(
-		1 == SMUM_READ_FIELD(smumgr->device, SMC_RESP_0, SMC_RESP),
-		"Failed to send Previous Message.",
-		);
-	cgs_write_register(smumgr->device, mmSMC_MESSAGE_0, msg);
-
-	return 0;
-}
-
-/*
-* Send a message to the SMC with parameter
-*
-* @param    smumgr:  the address of the powerplay hardware manager.
-* @param    msg: the message to send.
-* @param    parameter: the parameter to send
-* @return   The response that came from the SMC.
-*/
-static int tonga_send_msg_to_smc_with_parameter(struct pp_smumgr *smumgr,
-				uint16_t msg, uint32_t parameter)
-{
-	if (smumgr == NULL || smumgr->device == NULL)
-		return -EINVAL;
-
-	if (!tonga_is_smc_ram_running(smumgr))
-		return PPSMC_Result_Failed;
-
-	SMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);
-	cgs_write_register(smumgr->device, mmSMC_MSG_ARG_0, parameter);
-
-	return tonga_send_msg_to_smc(smumgr, msg);
-}
-
-/*
-* Send a message to the SMC with parameter, do not wait for response
-*
-* @param    smumgr:  the address of the powerplay hardware manager.
-* @param    msg: the message to send.
-* @param    parameter: the parameter to send
-* @return   The response that came from the SMC.
-*/
-static int tonga_send_msg_to_smc_with_parameter_without_waiting(
-			struct pp_smumgr *smumgr,
-			uint16_t msg, uint32_t parameter)
-{
-	if (smumgr == NULL || smumgr->device == NULL)
-		return -EINVAL;
-
-	SMUM_WAIT_FIELD_UNEQUAL(smumgr, SMC_RESP_0, SMC_RESP, 0);
-
-	cgs_write_register(smumgr->device, mmSMC_MSG_ARG_0, parameter);
-
-	return tonga_send_msg_to_smc_without_waiting(smumgr, msg);
-}
-
-/*
- * Read a 32bit value from the SMC SRAM space.
- * ALL PARAMETERS ARE IN HOST BYTE ORDER.
- * @param    smumgr  the address of the powerplay hardware manager.
- * @param    smcAddress the address in the SMC RAM to access.
- * @param    value and output parameter for the data read from the SMC SRAM.
- */
-int tonga_read_smc_sram_dword(struct pp_smumgr *smumgr,
-					uint32_t smcAddress, uint32_t *value,
-					uint32_t limit)
-{
-	int result;
-
-	result = tonga_set_smc_sram_address(smumgr, smcAddress, limit);
-
-	if (0 != result)
-		return result;
-
-	*value = cgs_read_register(smumgr->device, mmSMC_IND_DATA_0);
-
-	return 0;
-}
-
-/*
- * Write a 32bit value to the SMC SRAM space.
- * ALL PARAMETERS ARE IN HOST BYTE ORDER.
- * @param    smumgr  the address of the powerplay hardware manager.
- * @param    smcAddress the address in the SMC RAM to access.
- * @param    value to write to the SMC SRAM.
- */
-int tonga_write_smc_sram_dword(struct pp_smumgr *smumgr,
-					uint32_t smcAddress, uint32_t value,
-					uint32_t limit)
-{
-	int result;
-
-	result = tonga_set_smc_sram_address(smumgr, smcAddress, limit);
-
-	if (0 != result)
-		return result;
-
-	cgs_write_register(smumgr->device, mmSMC_IND_DATA_0, value);
-
-	return 0;
-}
-
-static int tonga_smu_fini(struct pp_smumgr *smumgr)
-{
-	struct tonga_smumgr *priv = (struct tonga_smumgr *)(smumgr->backend);
-
-	smu_free_memory(smumgr->device, (void *)priv->smu_buffer.handle);
-	smu_free_memory(smumgr->device, (void *)priv->header_buffer.handle);
-
-	if (smumgr->backend != NULL) {
-		kfree(smumgr->backend);
-		smumgr->backend = NULL;
-	}
-
-	cgs_rel_firmware(smumgr->device, CGS_UCODE_ID_SMU);
-	return 0;
-}
-
-static enum cgs_ucode_id tonga_convert_fw_type_to_cgs(uint32_t fw_type)
-{
-	enum cgs_ucode_id result = CGS_UCODE_ID_MAXIMUM;
-
-	switch (fw_type) {
-	case UCODE_ID_SMU:
-		result = CGS_UCODE_ID_SMU;
-		break;
-	case UCODE_ID_SDMA0:
-		result = CGS_UCODE_ID_SDMA0;
-		break;
-	case UCODE_ID_SDMA1:
-		result = CGS_UCODE_ID_SDMA1;
-		break;
-	case UCODE_ID_CP_CE:
-		result = CGS_UCODE_ID_CP_CE;
-		break;
-	case UCODE_ID_CP_PFP:
-		result = CGS_UCODE_ID_CP_PFP;
-		break;
-	case UCODE_ID_CP_ME:
-		result = CGS_UCODE_ID_CP_ME;
-		break;
-	case UCODE_ID_CP_MEC:
-		result = CGS_UCODE_ID_CP_MEC;
-		break;
-	case UCODE_ID_CP_MEC_JT1:
-		result = CGS_UCODE_ID_CP_MEC_JT1;
-		break;
-	case UCODE_ID_CP_MEC_JT2:
-		result = CGS_UCODE_ID_CP_MEC_JT2;
-		break;
-	case UCODE_ID_RLC_G:
-		result = CGS_UCODE_ID_RLC_G;
-		break;
-	default:
-		break;
-	}
-
-	return result;
-}
-
-/**
- * Convert the PPIRI firmware type to SMU type mask.
- * For MEC, we need to check all MEC related type
-*/
-static uint16_t tonga_get_mask_for_firmware_type(uint16_t firmwareType)
-{
-	uint16_t result = 0;
-
-	switch (firmwareType) {
-	case UCODE_ID_SDMA0:
-		result = UCODE_ID_SDMA0_MASK;
-		break;
-	case UCODE_ID_SDMA1:
-		result = UCODE_ID_SDMA1_MASK;
-		break;
-	case UCODE_ID_CP_CE:
-		result = UCODE_ID_CP_CE_MASK;
-		break;
-	case UCODE_ID_CP_PFP:
-		result = UCODE_ID_CP_PFP_MASK;
-		break;
-	case UCODE_ID_CP_ME:
-		result = UCODE_ID_CP_ME_MASK;
-		break;
-	case UCODE_ID_CP_MEC:
-	case UCODE_ID_CP_MEC_JT1:
-	case UCODE_ID_CP_MEC_JT2:
-		result = UCODE_ID_CP_MEC_MASK;
-		break;
-	case UCODE_ID_RLC_G:
-		result = UCODE_ID_RLC_G_MASK;
-		break;
-	default:
-		break;
-	}
-
-	return result;
-}
-
-/**
- * Check if the FW has been loaded,
- * SMU will not return if loading has not finished.
-*/
-static int tonga_check_fw_load_finish(struct pp_smumgr *smumgr, uint32_t fwType)
-{
-	uint16_t fwMask = tonga_get_mask_for_firmware_type(fwType);
-
-	if (0 != SMUM_WAIT_VFPF_INDIRECT_REGISTER(smumgr, SMC_IND,
-				SOFT_REGISTERS_TABLE_28, fwMask, fwMask)) {
-		printk(KERN_ERR "[ powerplay ] check firmware loading failed\n");
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-/* Populate one firmware image to the data structure */
-static int tonga_populate_single_firmware_entry(struct pp_smumgr *smumgr,
-				uint16_t firmware_type,
-				struct SMU_Entry *pentry)
-{
-	int result;
-	struct cgs_firmware_info info = {0};
-
-	result = cgs_get_firmware_info(
-				smumgr->device,
-				tonga_convert_fw_type_to_cgs(firmware_type),
-				&info);
-
-	if (result == 0) {
-		pentry->version = 0;
-		pentry->id = (uint16_t)firmware_type;
-		pentry->image_addr_high = smu_upper_32_bits(info.mc_addr);
-		pentry->image_addr_low = smu_lower_32_bits(info.mc_addr);
-		pentry->meta_data_addr_high = 0;
-		pentry->meta_data_addr_low = 0;
-		pentry->data_size_byte = info.image_size;
-		pentry->num_register_entries = 0;
-
-		if (firmware_type == UCODE_ID_RLC_G)
-			pentry->flags = 1;
-		else
-			pentry->flags = 0;
-	} else {
-		return result;
-	}
-
-	return result;
-}
-
-static int tonga_request_smu_reload_fw(struct pp_smumgr *smumgr)
-{
-	struct tonga_smumgr *tonga_smu =
-		(struct tonga_smumgr *)(smumgr->backend);
-	uint16_t fw_to_load;
-	struct SMU_DRAMData_TOC *toc;
-	/**
-	 * First time this gets called during SmuMgr init,
-	 * we haven't processed SMU header file yet,
-	 * so Soft Register Start offset is unknown.
-	 * However, for this case, UcodeLoadStatus is already 0,
-	 * so we can skip this if the Soft Registers Start offset is 0.
-	 */
-	cgs_write_ind_register(smumgr->device,
-		CGS_IND_REG__SMC, ixSOFT_REGISTERS_TABLE_28, 0);
-
-	tonga_send_msg_to_smc_with_parameter(smumgr,
-		PPSMC_MSG_SMU_DRAM_ADDR_HI,
-		tonga_smu->smu_buffer.mc_addr_high);
-	tonga_send_msg_to_smc_with_parameter(smumgr,
-		PPSMC_MSG_SMU_DRAM_ADDR_LO,
-		tonga_smu->smu_buffer.mc_addr_low);
-
-	toc = (struct SMU_DRAMData_TOC *)tonga_smu->pHeader;
-	toc->num_entries = 0;
-	toc->structure_version = 1;
-
-	PP_ASSERT_WITH_CODE(
-		0 == tonga_populate_single_firmware_entry(smumgr,
-		UCODE_ID_RLC_G,
-		&toc->entry[toc->num_entries++]),
-		"Failed to Get Firmware Entry.\n",
-		return -1);
-	PP_ASSERT_WITH_CODE(
-		0 == tonga_populate_single_firmware_entry(smumgr,
-		UCODE_ID_CP_CE,
-		&toc->entry[toc->num_entries++]),
-		"Failed to Get Firmware Entry.\n",
-		return -1);
-	PP_ASSERT_WITH_CODE(
-		0 == tonga_populate_single_firmware_entry
-		(smumgr, UCODE_ID_CP_PFP, &toc->entry[toc->num_entries++]),
-		"Failed to Get Firmware Entry.\n", return -1);
-	PP_ASSERT_WITH_CODE(
-		0 == tonga_populate_single_firmware_entry
-		(smumgr, UCODE_ID_CP_ME, &toc->entry[toc->num_entries++]),
-		"Failed to Get Firmware Entry.\n", return -1);
-	PP_ASSERT_WITH_CODE(
-		0 == tonga_populate_single_firmware_entry
-		(smumgr, UCODE_ID_CP_MEC, &toc->entry[toc->num_entries++]),
-		"Failed to Get Firmware Entry.\n", return -1);
-	PP_ASSERT_WITH_CODE(
-		0 == tonga_populate_single_firmware_entry
-		(smumgr, UCODE_ID_CP_MEC_JT1, &toc->entry[toc->num_entries++]),
-		"Failed to Get Firmware Entry.\n", return -1);
-	PP_ASSERT_WITH_CODE(
-		0 == tonga_populate_single_firmware_entry
-		(smumgr, UCODE_ID_CP_MEC_JT2, &toc->entry[toc->num_entries++]),
-		"Failed to Get Firmware Entry.\n", return -1);
-	PP_ASSERT_WITH_CODE(
-		0 == tonga_populate_single_firmware_entry
-		(smumgr, UCODE_ID_SDMA0, &toc->entry[toc->num_entries++]),
-		"Failed to Get Firmware Entry.\n", return -1);
-	PP_ASSERT_WITH_CODE(
-		0 == tonga_populate_single_firmware_entry
-		(smumgr, UCODE_ID_SDMA1, &toc->entry[toc->num_entries++]),
-		"Failed to Get Firmware Entry.\n", return -1);
-
-	tonga_send_msg_to_smc_with_parameter(smumgr,
-		PPSMC_MSG_DRV_DRAM_ADDR_HI,
-		tonga_smu->header_buffer.mc_addr_high);
-	tonga_send_msg_to_smc_with_parameter(smumgr,
-		PPSMC_MSG_DRV_DRAM_ADDR_LO,
-		tonga_smu->header_buffer.mc_addr_low);
-
-	fw_to_load = UCODE_ID_RLC_G_MASK
-			+ UCODE_ID_SDMA0_MASK
-			+ UCODE_ID_SDMA1_MASK
-			+ UCODE_ID_CP_CE_MASK
-			+ UCODE_ID_CP_ME_MASK
-			+ UCODE_ID_CP_PFP_MASK
-			+ UCODE_ID_CP_MEC_MASK;
-
-	PP_ASSERT_WITH_CODE(
-		0 == tonga_send_msg_to_smc_with_parameter_without_waiting(
-		smumgr, PPSMC_MSG_LoadUcodes, fw_to_load),
-		"Fail to Request SMU Load uCode", return 0);
-
-	return 0;
-}
-
-static int tonga_request_smu_load_specific_fw(struct pp_smumgr *smumgr,
-				uint32_t firmwareType)
-{
-	return 0;
-}
-
-/**
- * Upload the SMC firmware to the SMC microcontroller.
- *
- * @param    smumgr  the address of the powerplay hardware manager.
- * @param    pFirmware the data structure containing the various sections of the firmware.
- */
-static int tonga_smu_upload_firmware_image(struct pp_smumgr *smumgr)
-{
-	const uint8_t *src;
-	uint32_t byte_count;
-	uint32_t *data;
-	struct cgs_firmware_info info = {0};
-
-	if (smumgr == NULL || smumgr->device == NULL)
-		return -EINVAL;
-
-	cgs_get_firmware_info(smumgr->device,
-		tonga_convert_fw_type_to_cgs(UCODE_ID_SMU), &info);
-
-	if (info.image_size & 3) {
-		printk(KERN_ERR "[ powerplay ] SMC ucode is not 4 bytes aligned\n");
-		return -EINVAL;
-	}
-
-	if (info.image_size > TONGA_SMC_SIZE) {
-		printk(KERN_ERR "[ powerplay ] SMC address is beyond the SMC RAM area\n");
-		return -EINVAL;
-	}
-
-	cgs_write_register(smumgr->device, mmSMC_IND_INDEX_0, 0x20000);
-	SMUM_WRITE_FIELD(smumgr->device, SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_0, 1);
-
-	byte_count = info.image_size;
-	src = (const uint8_t *)info.kptr;
-
-	data = (uint32_t *)src;
-	for (; byte_count >= 4; data++, byte_count -= 4)
-		cgs_write_register(smumgr->device, mmSMC_IND_DATA_0, data[0]);
-
-	SMUM_WRITE_FIELD(smumgr->device, SMC_IND_ACCESS_CNTL, AUTO_INCREMENT_IND_0, 0);
-
-	return 0;
-}
 
 static int tonga_start_in_protection_mode(struct pp_smumgr *smumgr)
 {
@@ -624,7 +45,7 @@ static int tonga_start_in_protection_mode(struct pp_smumgr *smumgr)
 	SMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,
 		SMC_SYSCON_RESET_CNTL, rst_reg, 1);
 
-	result = tonga_smu_upload_firmware_image(smumgr);
+	result = smu7_upload_smu_firmware_image(smumgr);
 	if (result)
 		return result;
 
@@ -654,7 +75,7 @@ static int tonga_start_in_protection_mode(struct pp_smumgr *smumgr)
 	/**
 	 * Call Test SMU message with 0x20000 offset to trigger SMU start
 	 */
-	tonga_send_msg_to_smc_offset(smumgr);
+	smu7_send_msg_to_smc_offset(smumgr);
 
 	/* Wait for done bit to be set */
 	SMUM_WAIT_VFPF_INDIRECT_FIELD_UNEQUAL(smumgr, SMC_IND,
@@ -691,13 +112,13 @@ static int tonga_start_in_non_protection_mode(struct pp_smumgr *smumgr)
 	SMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,
 		SMC_SYSCON_RESET_CNTL, rst_reg, 1);
 
-	result = tonga_smu_upload_firmware_image(smumgr);
+	result = smu7_upload_smu_firmware_image(smumgr);
 
 	if (result != 0)
 		return result;
 
 	/* Set smc instruct start point at 0x0 */
-	tonga_program_jump_on_start(smumgr);
+	smu7_program_jump_on_start(smumgr);
 
 
 	SMUM_WRITE_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,
@@ -719,7 +140,7 @@ static int tonga_start_smu(struct pp_smumgr *smumgr)
 	int result;
 
 	/* Only start SMC if SMC RAM is not running */
-	if (!tonga_is_smc_ram_running(smumgr)) {
+	if (!smu7_is_smc_ram_running(smumgr)) {
 		/*Check if SMU is running in protected mode*/
 		if (0 == SMUM_READ_VFPF_INDIRECT_FIELD(smumgr->device, CGS_IND_REG__SMC,
 					SMU_FIRMWARE, SMU_MODE)) {
@@ -733,7 +154,7 @@ static int tonga_start_smu(struct pp_smumgr *smumgr)
 		}
 	}
 
-	result = tonga_request_smu_reload_fw(smumgr);
+	result = smu7_request_smu_load_fw(smumgr);
 
 	return result;
 }
@@ -747,70 +168,28 @@ static int tonga_start_smu(struct pp_smumgr *smumgr)
  */
 static int tonga_smu_init(struct pp_smumgr *smumgr)
 {
-	struct tonga_smumgr *tonga_smu;
-	uint8_t *internal_buf;
-	uint64_t mc_addr = 0;
+	struct tonga_smumgr *smu_data = (struct tonga_smumgr *)(smumgr->backend);
+
 	int i;
 
-	/* Allocate memory for backend private data */
-	tonga_smu = (struct tonga_smumgr *)(smumgr->backend);
-	tonga_smu->header_buffer.data_size =
-		((sizeof(struct SMU_DRAMData_TOC) / 4096) + 1) * 4096;
-	tonga_smu->smu_buffer.data_size = 200*4096;
-
-	smu_allocate_memory(smumgr->device,
-		tonga_smu->header_buffer.data_size,
-		CGS_GPU_MEM_TYPE__VISIBLE_CONTIG_FB,
-		PAGE_SIZE,
-		&mc_addr,
-		&tonga_smu->header_buffer.kaddr,
-		&tonga_smu->header_buffer.handle);
-
-	tonga_smu->pHeader = tonga_smu->header_buffer.kaddr;
-	tonga_smu->header_buffer.mc_addr_high = smu_upper_32_bits(mc_addr);
-	tonga_smu->header_buffer.mc_addr_low = smu_lower_32_bits(mc_addr);
-
-	PP_ASSERT_WITH_CODE((NULL != tonga_smu->pHeader),
-		"Out of memory.",
-		kfree(smumgr->backend);
-		cgs_free_gpu_mem(smumgr->device,
-		(cgs_handle_t)tonga_smu->header_buffer.handle);
-		return -1);
-
-	smu_allocate_memory(smumgr->device,
-		tonga_smu->smu_buffer.data_size,
-		CGS_GPU_MEM_TYPE__VISIBLE_CONTIG_FB,
-		PAGE_SIZE,
-		&mc_addr,
-		&tonga_smu->smu_buffer.kaddr,
-		&tonga_smu->smu_buffer.handle);
-
-	internal_buf = tonga_smu->smu_buffer.kaddr;
-	tonga_smu->smu_buffer.mc_addr_high = smu_upper_32_bits(mc_addr);
-	tonga_smu->smu_buffer.mc_addr_low = smu_lower_32_bits(mc_addr);
-
-	PP_ASSERT_WITH_CODE((NULL != internal_buf),
-		"Out of memory.",
-		kfree(smumgr->backend);
-		cgs_free_gpu_mem(smumgr->device,
-		(cgs_handle_t)tonga_smu->smu_buffer.handle);
-		return -1;);
+	if (smu7_init(smumgr))
+		return -EINVAL;
 
 	for (i = 0; i < SMU72_MAX_LEVELS_GRAPHICS; i++)
-		tonga_smu->activity_target[i] = 30;
+		smu_data->activity_target[i] = 30;
 
 	return 0;
 }
 
 static const struct pp_smumgr_func tonga_smu_funcs = {
 	.smu_init = &tonga_smu_init,
-	.smu_fini = &tonga_smu_fini,
+	.smu_fini = &smu7_smu_fini,
 	.start_smu = &tonga_start_smu,
-	.check_fw_load_finish = &tonga_check_fw_load_finish,
-	.request_smu_load_fw = &tonga_request_smu_reload_fw,
-	.request_smu_load_specific_fw = &tonga_request_smu_load_specific_fw,
-	.send_msg_to_smc = &tonga_send_msg_to_smc,
-	.send_msg_to_smc_with_parameter = &tonga_send_msg_to_smc_with_parameter,
+	.check_fw_load_finish = &smu7_check_fw_load_finish,
+	.request_smu_load_fw = &smu7_request_smu_load_fw,
+	.request_smu_load_specific_fw = NULL,
+	.send_msg_to_smc = &smu7_send_msg_to_smc,
+	.send_msg_to_smc_with_parameter = &smu7_send_msg_to_smc_with_parameter,
 	.download_pptable_settings = NULL,
 	.upload_pptable_settings = NULL,
 	.update_smc_table = tonga_update_smc_table,
diff --git a/drivers/gpu/drm/amd/powerplay/smumgr/tonga_smumgr.h b/drivers/gpu/drm/amd/powerplay/smumgr/tonga_smumgr.h
index b2ad232..edb5f20 100644
--- a/drivers/gpu/drm/amd/powerplay/smumgr/tonga_smumgr.h
+++ b/drivers/gpu/drm/amd/powerplay/smumgr/tonga_smumgr.h
@@ -26,16 +26,7 @@
 
 #include "smu72_discrete.h"
 
-#define SMC_RAM_END		0x40000
-
-struct tonga_buffer_entry {
-	uint32_t data_size;
-	uint32_t mc_addr_low;
-	uint32_t mc_addr_high;
-	void *kaddr;
-	unsigned long  handle;
-};
-
+#include "smu7_smumgr.h"
 
 struct tonga_mc_reg_entry {
 	uint32_t mclk_max;
@@ -52,19 +43,8 @@ struct tonga_mc_reg_table {
 
 
 struct tonga_smumgr {
-	uint8_t *pHeader;
-	uint8_t *pMecImage;
-
-
-	uint32_t soft_regs_start;
-	uint32_t dpm_table_start;
-	uint32_t mc_reg_table_start;
-	uint32_t fan_table_start;
-	uint32_t arb_table_start;
-
-	struct tonga_buffer_entry header_buffer;
-	struct tonga_buffer_entry smu_buffer;
 
+	struct smu7_smumgr                   smu7_data;
 	struct SMU72_Discrete_DpmTable       smc_state_table;
 	struct SMU72_Discrete_Ulv            ulv_setting;
 	struct SMU72_Discrete_PmFuses  power_tune_table;
@@ -76,13 +56,4 @@ struct tonga_smumgr {
 
 };
 
-extern int tonga_smum_init(struct pp_smumgr *smumgr);
-extern int tonga_copy_bytes_to_smc(struct pp_smumgr *smumgr,
-		uint32_t smcStartAddress, const uint8_t *src,
-		uint32_t byteCount, uint32_t limit);
-extern int tonga_read_smc_sram_dword(struct pp_smumgr *smumgr, uint32_t smcAddress,
-		uint32_t *value, uint32_t limit);
-extern int tonga_write_smc_sram_dword(struct pp_smumgr *smumgr, uint32_t smcAddress,
-		uint32_t value, uint32_t limit);
-
 #endif
-- 
1.7.5.4

