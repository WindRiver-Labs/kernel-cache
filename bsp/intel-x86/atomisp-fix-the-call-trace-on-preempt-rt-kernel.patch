From 91194b19646eae71f191da2e68e5c6784dcc8894 Mon Sep 17 00:00:00 2001
From: fupan li <fupan.li@windriver.com>
Date: Mon, 20 Oct 2014 17:45:44 +0800
Subject: [PATCH] atomisp: fix the call trace on preempt-rt kernel

on preempt-rt kernel, the atomisp driver will cause the following
call trace:

BUG: sleeping function called from invalid context at /home/jagalind/windriver/linux-windriver/kernel/rtmutex.c:658
in_atomic(): 1, irqs_disabled(): 1, pid: 0, name: swapper/0
Pid: 0, comm: swapper/0 Not tainted 3.10.38-ltsi-rt34-WR6.0.0.0_preempt-rt #2
Call Trace:
 [<c105a6ee>] __might_sleep+0xce/0x100
 [<c170acec>] rt_spin_lock+0x1c/0x40
 [<f95c0870>] atomisp_css2_hw_load_32+0x20/0x40 [atomisp]
 [<f95e9e8e>] device_load_uint32+0xe/0x10 [atomisp]
 [<f95e2acb>] irq_reg_load+0x4b/0xa0 [atomisp]
 [<c106696a>] ? enqueue_pushable_task+0x6a/0x90
 [<c109a990>] ? handle_simple_irq+0x80/0x80
 [<f95e3500>] virq_get_channel_id+0x20/0x190 [atomisp]
 [<c105af0c>] ? resched_task+0x3c/0x70
 [<c109a990>] ? handle_simple_irq+0x80/0x80
 [<f95c47a0>] ia_css_irq_translate+0x30/0x1f0 [atomisp]
 [<c109a990>] ? handle_simple_irq+0x80/0x80
 [<f95af310>] atomisp_isr+0x20/0x3d0 [atomisp]
 [<c170af97>] ? _raw_spin_unlock_irqrestore+0x17/0x40
 [<c101fc82>] ? assign_irq_vector+0x42/0x60
 [<c109a990>] ? handle_simple_irq+0x80/0x80
 [<c10983ca>] handle_irq_event_percpu+0x7a/0x330
 [<c1020401>] ? msi_set_affinity+0x61/0x70
 [<c13621de>] ? acpi_idle_enter_c1+0x9f/0xc1
 [<c1325baf>] ? msi_set_mask_bit+0x6f/0x80
 [<c109a990>] ? handle_simple_irq+0x80/0x80
 [<c10986c2>] handle_irq_event+0x42/0x60
 [<c109a9f6>] handle_edge_irq+0x66/0x120
 <IRQ>  [<c1711c78>] ? do_IRQ+0x48/0xc0
 [<c10654dc>] ? idle_balance+0x14c/0x170
 [<c1711ba9>] ? common_interrupt+0x29/0x30
 [<c103007b>] ? update_console_cmdline+0x1b/0x90
 [<c13621de>] ? acpi_idle_enter_c1+0x9f/0xc1
 [<c157fabb>] ? cpuidle_enter+0x1b/0x30
 [<c1580070>] ? cpuidle_idle_call+0xa0/0x310
 [<c1009e7a>] ? cpu_idle+0x5a/0xd0
 [<c16e3f90>] ? rest_init+0x6c/0x7c
 [<c1a12714>] ? start_kernel+0x31b/0x322
 [<c1a12231>] ? repair_env_string+0x51/0x51
 [<c1a12078>] ? i386_start_kernel+0x78/0x7d

Signed-off-by: fupan li <fupan.li@windriver.com>
---
 drivers/media/atomisp2/atomisp_cmd.c      |   16 ++++++++--------
 drivers/media/atomisp2/atomisp_compat.c   |    6 +++---
 drivers/media/atomisp2/atomisp_internal.h |    2 +-
 drivers/media/atomisp2/atomisp_ioctl.c    |    8 ++++----
 drivers/media/atomisp2/atomisp_v4l2.c     |    8 ++++----
 drivers/media/v4l2-core/v4l2-dev.c        |    2 +-
 drivers/media/v4l2-core/v4l2-event.c      |   28 ++++++++++++++--------------
 drivers/media/v4l2-core/v4l2-fh.c         |   12 ++++++------
 include/media/v4l2-dev.h                  |    2 +-
 9 files changed, 42 insertions(+), 42 deletions(-)

diff --git a/drivers/media/atomisp2/atomisp_cmd.c b/drivers/media/atomisp2/atomisp_cmd.c
index ee756a2..bcfe9d4c 100644
--- a/drivers/media/atomisp2/atomisp_cmd.c
+++ b/drivers/media/atomisp2/atomisp_cmd.c
@@ -778,7 +778,7 @@ irqreturn_t atomisp_isr(int irq, void *dev)
 	msg_ret |= 1 << INTR_IIR;
 	pci_write_config_dword(isp->pdev, PCI_INTERRUPT_CTRL, msg_ret);
 
-	spin_lock_irqsave(&isp->lock, flags);
+	raw_spin_lock_irqsave(&isp->lock, flags);
 
 	for (i = 0, streaming = 0; i < isp->num_of_streams; i++)
 		streaming += isp->isp_subdev[i].streaming ==
@@ -828,12 +828,12 @@ irqreturn_t atomisp_isr(int irq, void *dev)
 		/* TODO: handle SH_CSS_RX_IRQ_INFO_BUFFER_OVERRUN */
 	}
 
-	spin_unlock_irqrestore(&isp->lock, flags);
+	raw_spin_unlock_irqrestore(&isp->lock, flags);
 
 	return IRQ_WAKE_THREAD;
 
 out_nowake:
-	spin_unlock_irqrestore(&isp->lock, flags);
+	raw_spin_unlock_irqrestore(&isp->lock, flags);
 
 	return IRQ_HANDLED;
 }
@@ -1567,11 +1567,11 @@ irqreturn_t atomisp_isr_thread(int irq, void *isp_ptr)
 	memset(css_pipe_done, 0, sizeof(css_pipe_done));
 	mutex_lock(&isp->mutex);
 
-	spin_lock_irqsave(&isp->lock, flags);
+	raw_spin_lock_irqsave(&isp->lock, flags);
 	for (i = 0, streaming = 0; i < isp->num_of_streams; i++)
 		streaming += isp->isp_subdev[i].streaming ==
 		    ATOMISP_DEVICE_STREAMING_ENABLED;
-	spin_unlock_irqrestore(&isp->lock, flags);
+	raw_spin_unlock_irqrestore(&isp->lock, flags);
 	if (!streaming)
 		goto out;
 
@@ -2809,12 +2809,12 @@ int atomisp_get_dis_stat(struct atomisp_sub_device *isp_subdev,
 		return -EINVAL;
 
 	/* isp needs to be streaming to get DIS statistics */
-	spin_lock_irqsave(&isp->lock, flags);
+	raw_spin_lock_irqsave(&isp->lock, flags);
 	if (isp_subdev->streaming != ATOMISP_DEVICE_STREAMING_ENABLED) {
-		spin_unlock_irqrestore(&isp->lock, flags);
+		raw_spin_unlock_irqrestore(&isp->lock, flags);
 		return -EINVAL;
 	}
-	spin_unlock_irqrestore(&isp->lock, flags);
+	raw_spin_unlock_irqrestore(&isp->lock, flags);
 
 	if (!isp_subdev->params.video_dis_en)
 		return -EINVAL;
diff --git a/drivers/media/atomisp2/atomisp_compat.c b/drivers/media/atomisp2/atomisp_compat.c
index 9624655..db9c5b6 100644
--- a/drivers/media/atomisp2/atomisp_compat.c
+++ b/drivers/media/atomisp2/atomisp_compat.c
@@ -34,13 +34,13 @@
  *    Sighting #4600742 also points to system hard hang upon access to IUNIT MMIO.
  *
  */
-static DEFINE_SPINLOCK(mmio_lock);
+static DEFINE_RAW_SPINLOCK(mmio_lock);
 extern raw_spinlock_t pci_config_lock;
 
 #ifdef ISOF_SILICON_BUG_WORKAROUND
-#define MMIO_LOCK spin_lock_irqsave(&mmio_lock, flags);
+#define MMIO_LOCK raw_spin_lock_irqsave(&mmio_lock, flags);
 #define PCI_CONFIG_LOCK raw_spin_lock(&pci_config_lock);
-#define MMIO_UNLOCK spin_unlock_irqrestore(&mmio_lock, flags);
+#define MMIO_UNLOCK raw_spin_unlock_irqrestore(&mmio_lock, flags);
 #define PCI_CONFIG_UNLOCK raw_spin_unlock(&pci_config_lock);
 #else
 #define MMIO_LOCK
diff --git a/drivers/media/atomisp2/atomisp_internal.h b/drivers/media/atomisp2/atomisp_internal.h
index 0a514ed..6c79f8b 100644
--- a/drivers/media/atomisp2/atomisp_internal.h
+++ b/drivers/media/atomisp2/atomisp_internal.h
@@ -276,7 +276,7 @@ struct atomisp_device {
 	unsigned int wdt_duration;	/* in jiffies */
 	enum atomisp_frame_status fr_status;
 
-	spinlock_t lock; /* Just for streaming below */
+	raw_spinlock_t lock; /* Just for streaming below */
 
 	bool need_gfx_throttle;
 
diff --git a/drivers/media/atomisp2/atomisp_ioctl.c b/drivers/media/atomisp2/atomisp_ioctl.c
index c949a4a..a1d4477 100644
--- a/drivers/media/atomisp2/atomisp_ioctl.c
+++ b/drivers/media/atomisp2/atomisp_ioctl.c
@@ -1498,13 +1498,13 @@ int __atomisp_streamoff(struct file *file, void *fh, enum v4l2_buf_type type)
 
 
 	atomisp_clear_frame_counters(isp_subdev);
-	spin_lock_irqsave(&isp->lock, flags);
+	raw_spin_lock_irqsave(&isp->lock, flags);
 	if (isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_ENABLED
 	    || isp_subdev->streaming == ATOMISP_DEVICE_STREAMING_STARTING) {
 		isp_subdev->streaming = ATOMISP_DEVICE_STREAMING_STOPPING;
 		first_streamoff = true;
 	}
-	spin_unlock_irqrestore(&isp->lock, flags);
+	raw_spin_unlock_irqrestore(&isp->lock, flags);
 
 	if (first_streamoff) {
 		mutex_unlock(&isp->mutex);
@@ -1526,10 +1526,10 @@ int __atomisp_streamoff(struct file *file, void *fh, enum v4l2_buf_type type)
 		atomisp_acc_unload_extensions(isp);
 	}
 
-	spin_lock_irqsave(&isp->lock, flags);
+	raw_spin_lock_irqsave(&isp->lock, flags);
 	if (atomisp_streaming_count(isp_subdev) <= 1)
 		isp_subdev->streaming = ATOMISP_DEVICE_STREAMING_DISABLED;
-	spin_unlock_irqrestore(&isp->lock, flags);
+	raw_spin_unlock_irqrestore(&isp->lock, flags);
 
 	if (!first_streamoff) {
 		if(pipe->vb2q.streaming)
diff --git a/drivers/media/atomisp2/atomisp_v4l2.c b/drivers/media/atomisp2/atomisp_v4l2.c
index 0f462b8..0a5286b 100644
--- a/drivers/media/atomisp2/atomisp_v4l2.c
+++ b/drivers/media/atomisp2/atomisp_v4l2.c
@@ -474,17 +474,17 @@ static int atomisp_suspend(struct device *dev)
 	if (atomisp_dev_users(isp))
 		return -EBUSY;
 
-	spin_lock_irqsave(&isp->lock, flags);
+	raw_spin_lock_irqsave(&isp->lock, flags);
 	for(i=0;i<isp->num_of_streams;i++)
 	{
 		if (isp->isp_subdev[i].streaming != ATOMISP_DEVICE_STREAMING_DISABLED) {
-			spin_unlock_irqrestore(&isp->lock, flags);
+			raw_spin_unlock_irqrestore(&isp->lock, flags);
 			v4l2_err(&atomisp_dev,
 				    "atomisp cannot suspend at this time.\n");
 			return -EINVAL;
 		}
 	}
-	spin_unlock_irqrestore(&isp->lock, flags);
+	raw_spin_unlock_irqrestore(&isp->lock, flags);
 
 	/* Prepare for MRFLD IUNIT power down */
 	if (IS_MRFLD) {
@@ -1133,7 +1133,7 @@ static int atomisp_pci_probe(struct pci_dev *dev,
 	mutex_init(&isp->mutex);
 	mutex_init(&isp->streamoff_mutex);
 	mutex_init(&isp->vb2mutex);
-	spin_lock_init(&isp->lock);
+	raw_spin_lock_init(&isp->lock);
 
 	isp->max_isr_latency = ATOMISP_MAX_ISR_LATENCY;
 
diff --git a/drivers/media/v4l2-core/v4l2-dev.c b/drivers/media/v4l2-core/v4l2-dev.c
index 5923c5d..b3691d7 100644
--- a/drivers/media/v4l2-core/v4l2-dev.c
+++ b/drivers/media/v4l2-core/v4l2-dev.c
@@ -779,7 +779,7 @@ int __video_register_device(struct video_device *vdev, int type, int nr,
 		return -EINVAL;
 
 	/* v4l2_fh support */
-	spin_lock_init(&vdev->fh_lock);
+	raw_spin_lock_init(&vdev->fh_lock);
 	INIT_LIST_HEAD(&vdev->fh_list);
 
 	/* Part 1: check device type */
diff --git a/drivers/media/v4l2-core/v4l2-event.c b/drivers/media/v4l2-core/v4l2-event.c
index 86dcb54..814f70a 100644
--- a/drivers/media/v4l2-core/v4l2-event.c
+++ b/drivers/media/v4l2-core/v4l2-event.c
@@ -41,10 +41,10 @@ static int __v4l2_event_dequeue(struct v4l2_fh *fh, struct v4l2_event *event)
 	struct v4l2_kevent *kev;
 	unsigned long flags;
 
-	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+	raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 
 	if (list_empty(&fh->available)) {
-		spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+		raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 		return -ENOENT;
 	}
 
@@ -59,7 +59,7 @@ static int __v4l2_event_dequeue(struct v4l2_fh *fh, struct v4l2_event *event)
 	kev->sev->first = sev_pos(kev->sev, 1);
 	kev->sev->in_use--;
 
-	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+	raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 
 	return 0;
 }
@@ -98,7 +98,7 @@ static struct v4l2_subscribed_event *v4l2_event_subscribed(
 {
 	struct v4l2_subscribed_event *sev;
 
-	assert_spin_locked(&fh->vdev->fh_lock);
+	assert_raw_spin_locked(&fh->vdev->fh_lock);
 
 	list_for_each_entry(sev, &fh->subscribed, list)
 		if (sev->type == type && sev->id == id)
@@ -174,12 +174,12 @@ void v4l2_event_queue(struct video_device *vdev, const struct v4l2_event *ev)
 
 	ktime_get_ts(&timestamp);
 
-	spin_lock_irqsave(&vdev->fh_lock, flags);
+	raw_spin_lock_irqsave(&vdev->fh_lock, flags);
 
 	list_for_each_entry(fh, &vdev->fh_list, list)
 		__v4l2_event_queue_fh(fh, ev, &timestamp);
 
-	spin_unlock_irqrestore(&vdev->fh_lock, flags);
+	raw_spin_unlock_irqrestore(&vdev->fh_lock, flags);
 }
 EXPORT_SYMBOL_GPL(v4l2_event_queue);
 
@@ -190,9 +190,9 @@ void v4l2_event_queue_fh(struct v4l2_fh *fh, const struct v4l2_event *ev)
 
 	ktime_get_ts(&timestamp);
 
-	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+	raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 	__v4l2_event_queue_fh(fh, ev, &timestamp);
-	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+	raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 }
 EXPORT_SYMBOL_GPL(v4l2_event_queue_fh);
 
@@ -227,11 +227,11 @@ int v4l2_event_subscribe(struct v4l2_fh *fh,
 	sev->fh = fh;
 	sev->ops = ops;
 
-	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+	raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 	found_ev = v4l2_event_subscribed(fh, sub->type, sub->id);
 	if (!found_ev)
 		list_add(&sev->list, &fh->subscribed);
-	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+	raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 
 	if (found_ev) {
 		kfree(sev);
@@ -263,14 +263,14 @@ void v4l2_event_unsubscribe_all(struct v4l2_fh *fh)
 	do {
 		sev = NULL;
 
-		spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+		raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 		if (!list_empty(&fh->subscribed)) {
 			sev = list_first_entry(&fh->subscribed,
 					struct v4l2_subscribed_event, list);
 			sub.type = sev->type;
 			sub.id = sev->id;
 		}
-		spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+		raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 		if (sev)
 			v4l2_event_unsubscribe(fh, &sub);
 	} while (sev);
@@ -289,7 +289,7 @@ int v4l2_event_unsubscribe(struct v4l2_fh *fh,
 		return 0;
 	}
 
-	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+	raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 
 	sev = v4l2_event_subscribed(fh, sub->type, sub->id);
 	if (sev != NULL) {
@@ -301,7 +301,7 @@ int v4l2_event_unsubscribe(struct v4l2_fh *fh,
 		list_del(&sev->list);
 	}
 
-	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+	raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 
 	if (sev && sev->ops && sev->ops->del)
 		sev->ops->del(sev);
diff --git a/drivers/media/v4l2-core/v4l2-fh.c b/drivers/media/v4l2-core/v4l2-fh.c
index e57c002..6d0152c 100644
--- a/drivers/media/v4l2-core/v4l2-fh.c
+++ b/drivers/media/v4l2-core/v4l2-fh.c
@@ -51,9 +51,9 @@ void v4l2_fh_add(struct v4l2_fh *fh)
 
 	if (test_bit(V4L2_FL_USE_FH_PRIO, &fh->vdev->flags))
 		v4l2_prio_open(fh->vdev->prio, &fh->prio);
-	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+	raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 	list_add(&fh->list, &fh->vdev->fh_list);
-	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+	raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 }
 EXPORT_SYMBOL_GPL(v4l2_fh_add);
 
@@ -75,9 +75,9 @@ void v4l2_fh_del(struct v4l2_fh *fh)
 {
 	unsigned long flags;
 
-	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+	raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 	list_del_init(&fh->list);
-	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+	raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 	if (test_bit(V4L2_FL_USE_FH_PRIO, &fh->vdev->flags))
 		v4l2_prio_close(fh->vdev->prio, fh->prio);
 }
@@ -112,9 +112,9 @@ int v4l2_fh_is_singular(struct v4l2_fh *fh)
 
 	if (fh == NULL || fh->vdev == NULL)
 		return 0;
-	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
+	raw_spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 	is_singular = list_is_singular(&fh->list);
-	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
+	raw_spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 	return is_singular;
 }
 EXPORT_SYMBOL_GPL(v4l2_fh_is_singular);
diff --git a/include/media/v4l2-dev.h b/include/media/v4l2-dev.h
index 95d1c91..8aa2913 100644
--- a/include/media/v4l2-dev.h
+++ b/include/media/v4l2-dev.h
@@ -122,7 +122,7 @@ struct video_device
 	int index;
 
 	/* V4L2 file handles */
-	spinlock_t		fh_lock; /* Lock for all v4l2_fhs */
+	raw_spinlock_t		fh_lock; /* Lock for all v4l2_fhs */
 	struct list_head	fh_list; /* List of struct v4l2_fh */
 
 	int debug;			/* Activates debug level*/
-- 
1.7.5.4

