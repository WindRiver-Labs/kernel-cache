From ea5241dd3799c10033e9b43c118fdace4f089106 Mon Sep 17 00:00:00 2001
From: Thomas Tai <thomas.tai@windriver.com>
Date: Wed, 29 Apr 2009 10:30:18 -0400
Subject: [PATCH] mpc8536ds: add cpufreq support for 8536

Add function to change cpu clock frequency, doing so can lower
power consumption and consider to be power management method.
For 8536, frequency can be changed on power on reset or wake up
from deep sleep mode.

[
>>From c5ee035009ca3e67c4784275bf48146737e28d2f Mon Sep 17 00:00:00 2001
From: Dave Liu <daveliu@freescale.com>
Date: Fri, 18 Jul 2008 14:00:44 +0800
Subject: [PATCH] add cpufreq support for 8536

The 8536 has two options to change the e500 core frequency
on run-time, but it is not real run-time. because it is not
on-the-fly to change frequency like 74xx, it needs processor
do one power on reset to change to new core frequency. so,
it will take more time to change the core frequency.

* JOG mode
  Unfortunately, the current 8536 rev1.0 silicon doesn't
  support the feature due to one issue.
* deep sleep
  Fortunately, we can change the core frequency when the
  processor wake up from deep sleep, if we request the change
  to PMJCR register.

This patch is cpufreq driver to request the freq change for 8536,
to make the new freq take effect, it must work together with the
deep sleep and mpic timer.

Before you build the driver, choose CPU Frequency scaling and
CPU frequency translation statistics and detail, only choose the
userspace governor, and choose the Freescale MPC85xx CPU freq on
the menuconfig.

to change the core frequency to 600MHz in the kernel, please do

echo 590000 > /sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed
echo 30 > /sys/devices/ffe00000.soc/ffe41100.timer/timeout
echo mem > /sys/power/state

after the processor wake up from deep sleep, the core freq will be
600MHz.

samilarly, you also can increase the core freq from default 1GHz.

Signed-off-by: Dave Liu <daveliu@freescale.com>
]
Integrated-by: Thomas Tai <thomas.tai@windriver.com>
---
 arch/powerpc/platforms/85xx/Makefile  |    1 +
 arch/powerpc/platforms/85xx/cpufreq.c |  227 +++++++++++++++++++++++++++++++++
 arch/powerpc/platforms/Kconfig        |    8 +
 3 files changed, 236 insertions(+), 0 deletions(-)
 create mode 100644 arch/powerpc/platforms/85xx/cpufreq.c

diff --git a/arch/powerpc/platforms/85xx/Makefile b/arch/powerpc/platforms/85xx/Makefile
index 2245ca1..3acd178 100644
--- a/arch/powerpc/platforms/85xx/Makefile
+++ b/arch/powerpc/platforms/85xx/Makefile
@@ -13,3 +13,4 @@ obj-$(CONFIG_SBC8560)     += sbc8560.o
 obj-$(CONFIG_SBC8548)     += sbc8548.o
 obj-$(CONFIG_KSI8560)	  += ksi8560.o
 obj-$(CONFIG_SUSPEND)     += suspend.o suspend-asm.o
+obj-$(CONFIG_MPC85xx_CPUFREQ)	+= cpufreq.o
diff --git a/arch/powerpc/platforms/85xx/cpufreq.c b/arch/powerpc/platforms/85xx/cpufreq.c
new file mode 100644
index 0000000..858e611
--- /dev/null
+++ b/arch/powerpc/platforms/85xx/cpufreq.c
@@ -0,0 +1,227 @@
+/*
+ * Copyright (C) 2008 Freescale Semiconductor, Inc.
+ * 	Dave Liu <daveliu@freescale.com>
+ *
+ * The cpufreq driver is for Freescale 85xx processor,
+ * based on arch/powerpc/platforms/cell/cbe_cpufreq.c
+ * (C) Copyright IBM Deutschland Entwicklung GmbH 2005-2007
+ *	Christian Krafft <krafft@de.ibm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/cpufreq.h>
+#include <linux/of_platform.h>
+
+#include <asm/prom.h>
+#include <asm/time.h>
+#include <asm/reg.h>
+#include <linux/io.h>
+
+#include <sysdev/fsl_soc.h>
+
+static DEFINE_MUTEX(mpc85xx_switch_mutex);
+
+static __be32 __iomem *porpllsr;
+static __be32 __iomem *pmjcr;
+#define PORPLLSR	0xe0000
+#define PMJCR		0xe007c
+#define PLAT_RATIO	0x3f
+
+/* e500 core frequence is ratio * system bus freq (CCB_CLK)
+static struct core_ratio {
+	ulong pll;
+	char *ratio;
+} e500_ratio[] = {
+	{3, "3:2"},
+	{4, "2:1"},
+	{5, "5:2"},
+	{6, "3:1"},
+	{7, "7:2"},
+	{8, "4:1"},
+	{9, "9:2"},
+};
+*/
+static struct cpufreq_frequency_table mpc85xx_freqs[] = {
+	{3,	0},
+	{4,	0},
+	{5,	0},
+	{6,	0},
+	{7,	0},
+	{8,	0},
+	{0,	CPUFREQ_TABLE_END},
+};
+
+/*
+ * hardware specific functions
+ */
+static int get_pll(void)
+{
+	int ret;
+	u32 pll = in_be32(porpllsr);
+	ret = (pll >> 16) & PLAT_RATIO;
+
+	return ret;
+}
+
+static void set_pll(unsigned int pll)
+{
+	u32 busfreq = fsl_get_sys_freq();
+	u32 val = (pll & PLAT_RATIO) << 16;
+	u32 corefreq;
+
+	corefreq = ((busfreq * pll) >> 1);
+	/* must set the bit[18] if the requested core freq > 800 MHz */
+	if (corefreq > 800000000)
+		val |= 0x00002000;
+	out_be32(pmjcr, val);
+	pr_debug("PMJCR request %08x\n", val);
+	val = in_be32(pmjcr);
+}
+
+static void verify_pll(void)
+{
+	u32 busfreq = fsl_get_sys_freq();
+	u32 pll = (in_be32(porpllsr) >> 16) & PLAT_RATIO;
+	u32 corefreq;
+
+	corefreq = (busfreq * pll) >> 1;
+	corefreq /= 1000000;
+	printk("PORPLLSR core freq %dMHz\n", corefreq);
+}
+
+/*
+ * cpufreq functions
+ */
+
+static int mpc85xx_cpufreq_cpu_init(struct cpufreq_policy *policy)
+{
+	u32 busfreq = fsl_get_sys_freq();
+	int i, cur_pll;
+
+	/* we need the freq unit with kHz */
+	busfreq /= 1000;
+
+	/* initialize frequency table */
+	for (i = 0; mpc85xx_freqs[i].frequency != CPUFREQ_TABLE_END; i++) {
+		mpc85xx_freqs[i].frequency = (busfreq * mpc85xx_freqs[i].index) >> 1;
+		printk("%d: %dkHz\n", i, mpc85xx_freqs[i].frequency);
+	}
+
+	/* the latency of a transition, the unit is ns */
+	policy->cpuinfo.transition_latency = 2000;
+
+	cur_pll = get_pll();
+	pr_debug("current pll is at %d\n", cur_pll);
+
+	for (i = 0; mpc85xx_freqs[i].frequency != CPUFREQ_TABLE_END; i++) {
+		if (mpc85xx_freqs[i].index == cur_pll)
+			policy->cur = mpc85xx_freqs[i].frequency;
+	}
+	pr_debug("current core freq is %d\n", policy->cur);
+
+	cpufreq_frequency_table_get_attr(mpc85xx_freqs, policy->cpu);
+
+	/* this ensures that policy->cpuinfo_min
+	 * and policy->cpuinfo_max are set correctly */
+	return cpufreq_frequency_table_cpuinfo(policy, mpc85xx_freqs);
+}
+
+static int mpc85xx_cpufreq_cpu_exit(struct cpufreq_policy *policy)
+{
+	cpufreq_frequency_table_put_attr(policy->cpu);
+	return 0;
+}
+
+static int mpc85xx_cpufreq_verify(struct cpufreq_policy *policy)
+{
+	return cpufreq_frequency_table_verify(policy, mpc85xx_freqs);
+}
+
+static int mpc85xx_cpufreq_target(struct cpufreq_policy *policy,
+			      unsigned int target_freq,
+			      unsigned int relation)
+{
+	struct cpufreq_freqs freqs;
+	unsigned int new;
+
+	cpufreq_frequency_table_target(policy,
+				       mpc85xx_freqs,
+				       target_freq,
+				       relation,
+				       &new);
+
+	freqs.old = policy->cur;
+	freqs.new = mpc85xx_freqs[new].frequency;
+	freqs.cpu = policy->cpu;
+
+	mutex_lock(&mpc85xx_switch_mutex);
+	cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+
+	pr_debug("setting frequency for cpu %d to %d kHz, " \
+		 "PLL ratio is %d/2\n",
+		 policy->cpu,
+		 mpc85xx_freqs[new].frequency,
+		 mpc85xx_freqs[new].index);
+
+	set_pll(mpc85xx_freqs[new].index);
+
+	cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+	mutex_unlock(&mpc85xx_switch_mutex);
+
+	ppc_proc_freq = freqs.new * 1000ul;
+
+	verify_pll();
+
+	return 0;
+}
+
+static struct cpufreq_driver mpc85xx_cpufreq_driver = {
+	.verify		= mpc85xx_cpufreq_verify,
+	.target		= mpc85xx_cpufreq_target,
+	.init		= mpc85xx_cpufreq_cpu_init,
+	.exit		= mpc85xx_cpufreq_cpu_exit,
+	.name		= "mpc85xx-cpufreq",
+	.owner		= THIS_MODULE,
+	.flags		= CPUFREQ_CONST_LOOPS,
+};
+
+/*
+ * module init and destoy
+ */
+
+static int __init mpc85xx_cpufreq_init(void)
+{
+	if (!machine_is_compatible("fsl,mpc8536ds"))
+		return -ENODEV;
+
+	porpllsr = ioremap(get_immrbase() + PORPLLSR, 4);
+	pmjcr = ioremap(get_immrbase() + PMJCR, 4);
+
+	return cpufreq_register_driver(&mpc85xx_cpufreq_driver);
+}
+
+static void __exit mpc85xx_cpufreq_exit(void)
+{
+	iounmap(porpllsr);
+	iounmap(pmjcr);
+
+	cpufreq_unregister_driver(&mpc85xx_cpufreq_driver);
+}
+
+module_init(mpc85xx_cpufreq_init);
+module_exit(mpc85xx_cpufreq_exit);
+
+MODULE_LICENSE("GPL");
diff --git a/arch/powerpc/platforms/Kconfig b/arch/powerpc/platforms/Kconfig
index 4c900ef..3160a5d 100644
--- a/arch/powerpc/platforms/Kconfig
+++ b/arch/powerpc/platforms/Kconfig
@@ -169,6 +169,14 @@ config CPU_FREQ_PMAC64
 	  This adds support for frequency switching on Apple iMac G5,
 	  and some of the more recent desktop G5 machines as well.
 
+config MPC85xx_CPUFREQ
+	bool "Support for Freescale MPC85xx CPU freq"
+	depends on PPC_85xx && PPC32
+	select CPU_FREQ_TABLE
+	help
+	  This adds support for frequency switching on Freescale MPC85xx,
+	  this currently includes MPC8536 processor.
+
 config PPC_PASEMI_CPUFREQ
 	bool "Support for PA Semi PWRficient"
 	depends on PPC_PASEMI
-- 
1.6.0.4

