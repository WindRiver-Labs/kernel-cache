From 8911162f2b823fb366c3c8a63166e528390e497f Mon Sep 17 00:00:00 2001
From: Thomas Tai <thomas.tai@windriver.com>
Date: Wed, 29 Apr 2009 10:30:13 -0400
Subject: [PATCH] mpc8536ds: MPC8536 SPI board support

Original patch taken from rev B.1 board support ISO image for MPC8536E.
http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=MPC8536E

Add MPC8539DS SPI interface in device tree and add
init function for the interface.

[
>>From 24c419e8e1ca7fe99549a0538752ef467c94a615 Mon Sep 17 00:00:00 2001
From: Chen Gong <g.chen@freescale.com>
Date: Mon, 14 Jul 2008 16:32:02 +0800
Subject: [PATCH] MPC8536 SPI board support

Signed-off-by: Chen Gong <g.chen@freescale.com>
]

Integrated-by: Thomas Tai <thomas.tai@windriver.com>
---
 arch/powerpc/boot/dts/mpc8536ds.dts      |   51 +++++++++++++
 arch/powerpc/platforms/85xx/mpc8536_ds.c |  115 ++++++++++++++++++++++++++++++
 arch/powerpc/sysdev/fsl_soc.c            |   14 ++++-
 3 files changed, 179 insertions(+), 1 deletions(-)

diff --git a/arch/powerpc/boot/dts/mpc8536ds.dts b/arch/powerpc/boot/dts/mpc8536ds.dts
index d86a230..ae2f31c 100644
--- a/arch/powerpc/boot/dts/mpc8536ds.dts
+++ b/arch/powerpc/boot/dts/mpc8536ds.dts
@@ -94,6 +94,57 @@
 			};
 		};
 
+		spi@7000 {
+			cell-index = <0>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "fsl,mpc8536-espi", "fsl,espi";
+			reg = <0x7000 0x1000>;
+			interrupts = <59 2>;
+			interrupt-parent = <&mpic>;
+			mode = "cpu";
+
+			fsl_m25p80@0 {
+				#address-cells = <1>;
+				#size-cells = <1>;
+				compatible = "fsl,espi-flash";
+				reg = <0>;
+				linux,modalias = "fsl_m25p80";
+				spi-max-frequency = <50000000>; /* input clock freq */
+				u-boot@0 {
+					label = "u-boot";
+					reg = <0x00000000 0x00100000>;
+					read-only;
+				};
+				kernel@100000 {
+					label = "kernel";
+					reg = <0x00100000 0x00500000>;
+				};
+				fs@600000 {
+					label = "fs";
+					reg = <0x00600000 0x00a00000>;
+				};
+			};
+			fsl_m25p80@1 {
+				compatible = "fsl,espi-flash";
+				reg = <1>;
+				linux,modalias = "fsl_m25p80";
+				spi-max-frequency = <50000000>;
+			};
+			fsl_m25p80@2 {
+				compatible = "fsl,espi-flash";
+				reg = <2>;
+				linux,modalias = "fsl_m25p80";
+				spi-max-frequency = <50000000>;
+			};
+			fsl_m25p80@3 {
+				compatible = "fsl,espi-flash";
+				reg = <3>;
+				linux,modalias = "fsl_m25p80";
+				spi-max-frequency = <50000000>;
+			};
+		};
+
 		dma@21300 {
 			#address-cells = <1>;
 			#size-cells = <1>;
diff --git a/arch/powerpc/platforms/85xx/mpc8536_ds.c b/arch/powerpc/platforms/85xx/mpc8536_ds.c
index 1bf5aef..0d53a21 100644
--- a/arch/powerpc/platforms/85xx/mpc8536_ds.c
+++ b/arch/powerpc/platforms/85xx/mpc8536_ds.c
@@ -17,6 +17,10 @@
 #include <linux/seq_file.h>
 #include <linux/interrupt.h>
 #include <linux/of_platform.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
 
 #include <asm/system.h>
 #include <asm/time.h>
@@ -58,6 +62,117 @@ void __init mpc8536_ds_pic_init(void)
 	mpic_init(mpic);
 }
 
+static int __init mpc85xx_spi_init(void)
+{
+	struct device_node *np, *dp = NULL;
+	struct mtd_partition *parts;
+	struct flash_platform_data *spi_eeprom_pdata;
+	struct spi_board_info *mpc8536_spi_bdinfo;
+	const u32 *iprop;
+	char *sprop;
+	int i, nr_parts, bd_num = 0, n = -1;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,mpc8536-espi");
+	while ((dp = of_get_next_child(np, dp)))
+		bd_num++;
+	of_node_put(np);
+
+	mpc8536_spi_bdinfo =
+		kzalloc(bd_num * sizeof(*mpc8536_spi_bdinfo), GFP_KERNEL);
+	if (mpc8536_spi_bdinfo == NULL){
+		printk(KERN_ERR "failed to allocate spi board info\n");
+		return 0;
+	}
+
+	for_each_compatible_node(np, NULL, "fsl,espi-flash") {
+		n++;
+		iprop = of_get_property(np, "reg", NULL);
+		(mpc8536_spi_bdinfo + n)->chip_select = *iprop;
+		iprop = of_get_property(np, "spi-max-frequency", NULL);
+		(mpc8536_spi_bdinfo + n)->max_speed_hz = *iprop;
+		/* use parent's bus_num as its own bus_num */
+		dp = of_get_parent(np);
+		iprop = of_get_property(dp, "reg", NULL);
+		(mpc8536_spi_bdinfo + n)->bus_num = *iprop;
+		/* Mode (clock phase/polarity/etc.) */
+		if (of_find_property(np, "spi,cpha", NULL))
+			(mpc8536_spi_bdinfo + n)->mode |= SPI_CPHA;
+		if (of_find_property(np, "spi,cpol", NULL))
+			(mpc8536_spi_bdinfo + n)->mode |= SPI_CPOL;
+		/* Select device driver */
+		sprop = of_get_property(np, "linux,modalias", NULL);
+		if (sprop)
+			strncpy((mpc8536_spi_bdinfo + n)->modalias,
+					sprop, sizeof((mpc8536_spi_bdinfo + n)->modalias) - 1);
+		else
+			strncpy((mpc8536_spi_bdinfo + n)->modalias,
+					"spidev", sizeof((mpc8536_spi_bdinfo + n)->modalias) - 1);
+
+		spi_eeprom_pdata =
+			kzalloc(sizeof(*spi_eeprom_pdata), GFP_KERNEL);
+		if (spi_eeprom_pdata == NULL)
+			continue;
+		spi_eeprom_pdata->name = kzalloc(10, GFP_KERNEL);
+		if (spi_eeprom_pdata->name == NULL) {
+			kfree(spi_eeprom_pdata);
+			continue;
+		}
+
+		(mpc8536_spi_bdinfo + n)->platform_data = spi_eeprom_pdata;
+		snprintf(spi_eeprom_pdata->name, 10, "SPIFLASH%d", n);
+
+		nr_parts = 0;
+		dp = NULL;
+		while ((dp = of_get_next_child(np, dp)))
+			nr_parts++;
+		if (nr_parts == 0)
+			continue;
+		parts = kzalloc(nr_parts * sizeof(*parts), GFP_KERNEL);
+		if (!parts)
+			continue;
+
+		i = 0;
+		while ((dp = of_get_next_child(np, dp))) {
+			const u32 *reg;
+			const char *partname;
+			int len;
+
+			reg = of_get_property(dp, "reg", &len);
+			if (!reg || (len != 2 * sizeof(u32))) {
+				of_node_put(dp);
+				kfree(parts);
+				parts = NULL;
+				break;
+			}
+			(parts + i)->offset = reg[0];
+			(parts + i)->size = reg[1];
+
+			partname = of_get_property(dp, "label", &len);
+			if (!partname)
+				partname = dp->name;
+			(parts + i)->name = (char *)partname;
+
+			if (of_get_property(dp, "read-only", &len))
+				(parts + i)->mask_flags = MTD_WRITEABLE;
+
+			i++;
+		}
+		spi_eeprom_pdata->parts = parts;
+		spi_eeprom_pdata->nr_parts = nr_parts;
+	}
+
+	fsl_spi_init(mpc8536_spi_bdinfo, bd_num, NULL, NULL);
+
+	/*
+	 * Only free "struct spi_board_info", because it will be discarded
+	 * after registered, but other info are still reserved.
+	 */
+	kfree(mpc8536_spi_bdinfo);
+	return 0;
+}
+
+device_initcall(mpc85xx_spi_init);
+
 /*
  * Setup the architecture
  */
diff --git a/arch/powerpc/sysdev/fsl_soc.c b/arch/powerpc/sysdev/fsl_soc.c
index dd1d7ed..40c6811 100644
--- a/arch/powerpc/sysdev/fsl_soc.c
+++ b/arch/powerpc/sysdev/fsl_soc.c
@@ -1,6 +1,8 @@
 /*
  * FSL SoC setup code
  *
+ * Copyright (C) 2008 Freescale Semiconductor, Inc. All rights reserved.
+ *
  * Maintained by Kumar Gala (see MAINTAINERS for contact information)
  *
  * 2006 (c) MontaVista Software, Inc.
@@ -627,6 +629,13 @@ static int __init of_fsl_spi_probe(char *type, char *compatible, u32 sysclk,
 {
 	struct device_node *np;
 	unsigned int i = 0;
+	char spi_name[32] = "mpc83xx_spi";
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,espi");
+	if (np != NULL) {
+		strcpy(spi_name, "fsl_espi");
+		of_node_put(np);
+	}
 
 	for_each_compatible_node(np, type, compatible) {
 		int ret;
@@ -672,7 +681,7 @@ static int __init of_fsl_spi_probe(char *type, char *compatible, u32 sysclk,
 		if (ret == NO_IRQ)
 			goto err;
 
-		pdev = platform_device_alloc("mpc83xx_spi", i);
+		pdev = platform_device_alloc(spi_name, i);
 		if (!pdev)
 			goto err;
 
@@ -724,6 +733,9 @@ int __init fsl_spi_init(struct spi_board_info *board_infos,
 	if (!ret)
 		of_fsl_spi_probe("spi", "fsl_spi", sysclk, board_infos,
 				 num_board_infos, activate_cs, deactivate_cs);
+	if (!ret)
+		of_fsl_spi_probe(NULL, "fsl,espi", sysclk, board_infos,
+				 num_board_infos, activate_cs, deactivate_cs);
 
 	return spi_register_board_info(board_infos, num_board_infos);
 }
-- 
1.6.0.4

