From cf8a03c7ef1077fee25b3bd5f253a8dac2b0b161 Mon Sep 17 00:00:00 2001
From: xianchao Zhang <xianchao.zhang@windriver.com>
Date: Fri, 9 Oct 2009 14:19:36 +0800
Subject: [PATCH] Support for Portwell 8070 gpio

This module add GPIO support for PortWell WADE 8070 ITX board.
Operate GPIO via sysfs after exporting the device.

Signed-off-by: xianchao Zhang <xianchao.zhang@windriver.com>
---
 drivers/gpio/Kconfig         |    6 ++
 drivers/gpio/Makefile        |    1 +
 drivers/gpio/wade8070_gpio.c |  205 ++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 212 insertions(+), 0 deletions(-)
 create mode 100644 drivers/gpio/wade8070_gpio.c

diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index 293b4a7..e2b1237 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -167,4 +167,10 @@ config GPIO_MCP23S08
 	  SPI driver for Microchip MCP23S08 I/O expander.  This provides
 	  a GPIO interface supporting inputs and outputs.
 
+config WADE_8070_GPIO
+	tristate "GPIO Support for WADE 8070 ITX board"
+	depends on X86 && PCI
+	---help---
+	  The driver provides a GPIO interface to supporting input and outputs.
+
 endif
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index 6aafdeb..e6244a2 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -11,3 +11,4 @@ obj-$(CONFIG_GPIO_PCA953X)	+= pca953x.o
 obj-$(CONFIG_GPIO_PCF857X)	+= pcf857x.o
 obj-$(CONFIG_GPIO_TWL4030)	+= twl4030-gpio.o
 obj-$(CONFIG_GPIO_BT8XX)	+= bt8xxgpio.o
+obj-$(CONFIG_WADE_8070_GPIO)    += wade8070_gpio.o
diff --git a/drivers/gpio/wade8070_gpio.c b/drivers/gpio/wade8070_gpio.c
new file mode 100644
index 0000000..3fe1410
--- /dev/null
+++ b/drivers/gpio/wade8070_gpio.c
@@ -0,0 +1,205 @@
+/*
+ * Author:      Liang Li <Liang.Li@windriver.com>
+ *
+ * Abstract:    This module supports PortWell WADE 8070 ITX board, w83726UHG
+ *            All of the driver functions are provided in this file.
+ *
+ * Copyright(c) 2008 Windriver Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * Contact Information:
+ * Windriver Corporation
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/gpio.h>
+
+#define DRVNAME "8070_gpio"
+
+#define CR_2E (0x2E)
+#define CR_4E (0x4E)
+#define CR_2A (0x2A)
+#define CR_2C (0x2C)
+#define CR_30 (0x30)
+#define CR_F0 (0xF0)
+#define CR_F1 (0xF1)
+
+static inline void
+superio_outb(int ioreg, int reg, int val)
+{
+    outb(reg, ioreg);
+    outb(val, ioreg + 1);
+}
+
+static inline u8
+superio_inb(int ioreg, int reg)
+{
+    outb(reg, ioreg);
+    return inb(ioreg + 1);
+}
+
+static inline void superio_enter(int ioreg)
+{
+    outb(0x87, ioreg);
+    outb(0x87, ioreg);
+}
+
+static inline void superio_exit(int ioreg)
+{
+    outb(0x02, ioreg);
+    outb(0x02, ioreg + 1);
+}
+
+static DEFINE_MUTEX(w83627_gpio_lock);
+
+static void wade8070_free(struct gpio_chip *chip, unsigned offset)
+{
+	return;
+}
+
+static int wade8070_gpio_direction_input(struct gpio_chip *chip,
+					unsigned offset)
+{
+	return 0;
+}
+
+static int wade8070_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	u8 tmp;
+	mutex_lock(&w83627_gpio_lock);
+	tmp = superio_inb(CR_2E, CR_F1);
+	tmp >>= ((offset % 2) * 4 + (offset / 2));
+	tmp &= 0x01;
+	mutex_unlock(&w83627_gpio_lock);
+	return tmp;
+}
+
+static int wade8070_gpio_direction_output(struct gpio_chip *chip,
+					unsigned offset, int value)
+{
+	int res = 0;
+	u8 tmp;
+	mutex_lock(&w83627_gpio_lock);
+	if ((offset % 2 ) != 0) {
+		printk(KERN_INFO"WADE-8070: Only *ODD* pins can be GPO.\n");
+		printk(KERN_INFO"WADE-8070: The first GPIO pin is '1'.\n");
+		res = -1;
+	} else {
+		tmp = superio_inb(CR_2E, CR_F0);
+		tmp &= ~(1 << (offset / 2));
+		superio_outb(CR_2E, CR_F0, tmp);
+	}
+	mutex_unlock(&w83627_gpio_lock);
+	return res;
+}
+
+static void wade8070_gpio_set(struct gpio_chip *chip, unsigned offset,
+				int value)
+{
+	u8 tmp;
+	mutex_lock(&w83627_gpio_lock);
+
+	tmp = superio_inb(CR_2E, CR_F1);
+	if (0 == value)
+		tmp &= ~(1 << (offset / 2));
+	else
+		tmp |= 1 << (offset / 2);
+	superio_outb(CR_2E, CR_F1, tmp);
+
+	mutex_unlock(&w83627_gpio_lock);
+}
+
+static int wade8070_request(struct gpio_chip *chip, unsigned offset)
+{
+	return 0;
+}
+
+static struct gpio_chip w83627dhg_gpio_chip = {
+	.label              = DRVNAME,
+	.owner              = THIS_MODULE,
+	.request            = wade8070_request,
+	.free               = wade8070_free,
+	.direction_input    = wade8070_gpio_direction_input,
+	.get                = wade8070_gpio_get,
+	.direction_output   = wade8070_gpio_direction_output,
+	.set                = wade8070_gpio_set,
+	.base               = 0,
+	.ngpio              = 8,
+	.can_sleep          = 0,
+};
+
+static void detect_chip(u8 ioaddr)
+{
+	u8 tmp;
+	superio_enter(ioaddr);
+
+	tmp = superio_inb(ioaddr, CR_2A);
+	tmp &= 0xFD;
+	superio_outb(ioaddr, CR_2A, tmp);
+
+	tmp = superio_inb(ioaddr, CR_2C);
+	tmp &= 0x1F;
+	superio_outb(ioaddr, CR_2C, tmp);
+
+	superio_outb(ioaddr, 0x07, 0x09);
+
+	tmp = superio_inb(ioaddr, CR_30);
+	tmp |= 0x02;
+	superio_outb(ioaddr, CR_30, tmp);
+
+	superio_outb(ioaddr, 0xFE, 0x77);
+	superio_outb(ioaddr, 0xF2, 0x00);
+
+	/*'1' for input, '0' for output*/
+	superio_outb(ioaddr, CR_F0, 0xF0);
+
+	superio_outb(ioaddr, CR_F1, 0x0A);
+
+	tmp = superio_inb(ioaddr, CR_F1);
+
+}
+
+static int __init wade8070_gpio_init(void)
+{
+	int err;
+
+	detect_chip(CR_2E);
+
+	err = gpiochip_add(&w83627dhg_gpio_chip);
+	if (err < 0)
+		return err;
+
+	printk(KERN_INFO"8070_gpio_init Done.\n");
+	return 0;
+}
+
+static void __exit wade8070_gpio_exit(void)
+{
+	int err;
+	err = gpiochip_remove(&w83627dhg_gpio_chip);
+
+	superio_exit(CR_2E);
+	printk(KERN_INFO"8070_gpio_exit(%d)\n", err);
+}
+
+module_init(wade8070_gpio_init);
+module_exit(wade8070_gpio_exit);
+
+MODULE_AUTHOR("Liang Li");
+MODULE_DESCRIPTION("WINDRIVER: Portwell WADE 8070 ITX board GPIO DRIVER");
+MODULE_LICENSE("GPL");
-- 
1.6.5.2

