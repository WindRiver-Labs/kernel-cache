From 27322cf4d92d6698da1afee3f3c1439beb7a13a9 Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@cavium.com>
Date: Mon, 16 Apr 2012 16:26:59 +0800
Subject: [PATCH 195/236] MIPS: Octeon: Enable LMCX interrupts in cn68xx model.

Source: Cavium SDK 2.3-427

Enable LMC interrupts in all the enabled LMC controllers.
Cleanup code formatting.

Signed-off-by: Chandrakala Chavva <cchavva@cavium.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 arch/mips/cavium-octeon/setup.c |   65 +++++++++++++++++++++++++++------------
 1 files changed, 45 insertions(+), 20 deletions(-)

diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index fe4f023..d55ffb4 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -41,6 +41,7 @@
 #include <asm/octeon/octeon-boot-info.h>
 
 #include <asm/octeon/cvmx-clock.h>
+#include <asm/octeon/cvmx-ciu2-defs.h>
 #include <asm/octeon/cvmx-error.h>
 #include <asm/octeon/cvmx-debug.h>
 #include <asm/octeon/cvmx-pcie.h>
@@ -613,8 +614,10 @@ int xkphys_usermem_write(long pid, int value)
 
 	preempt_disable();
 
-	/* If we are adjusting ourselves, make the change effective
-	   immediatly.  */
+	/*
+	 * If we are adjusting ourselves, make the change effective
+	 * immediatly.
+	 */
 	if (group_leader == current->group_leader)
 		cavium_prepare_arch_switch(current);
 
@@ -1180,17 +1183,18 @@ void prom_free_prom_memory(void)
 	irq_flags = IRQF_SHARED;
 #endif
 	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+		int i;
 		if (request_irq(OCTEON_IRQ_NAND, octeon_rml_interrupt, IRQF_SHARED,
 					"NAND RML_RSL", octeon_rml_interrupt)) {
-			panic("Unable to request_irq(OCTEON_IRQ_NAND)\n");
+			panic("Unable to request_irq(OCTEON_IRQ_NAND)");
 		}
 		if (request_irq(OCTEON_IRQ_MIO, octeon_rml_interrupt, IRQF_SHARED,
 					"MIO RML_RSL", octeon_rml_interrupt)) {
-			panic("Unable to request_irq(OCTEON_IRQ_MIO)\n");
+			panic("Unable to request_irq(OCTEON_IRQ_MIO)");
 		}
 		if (request_irq(OCTEON_IRQ_FPA, octeon_rml_interrupt, IRQF_SHARED,
 					"FPA RML_RSL", octeon_rml_interrupt)) {
-			panic("Unable to request_irq(OCTEON_IRQ_FPA)\n");
+			panic("Unable to request_irq(OCTEON_IRQ_FPA)");
 		}
 #if 0
 		if (request_irq(OCTEON_IRQ_POW, octeon_rml_interrupt, IRQF_SHARED,
@@ -1200,31 +1204,31 @@ void prom_free_prom_memory(void)
 #endif
 		if (request_irq(OCTEON_IRQ_L2C, octeon_rml_interrupt, IRQF_SHARED,
 					"L2C RML_RSL", octeon_rml_interrupt)) {
-			panic("Unable to request_irq(OCTEON_IRQ_L2C)\n");
+			panic("Unable to request_irq(OCTEON_IRQ_L2C)");
 		}
 		if (request_irq(OCTEON_IRQ_IPD, octeon_rml_interrupt, IRQF_SHARED,
 					"IPD RML_RSL", octeon_rml_interrupt)) {
-			panic("Unable to request_irq(OCTEON_IRQ_IPD)\n");
+			panic("Unable to request_irq(OCTEON_IRQ_IPD)");
 		}
 		if (request_irq(OCTEON_IRQ_PIP, octeon_rml_interrupt, IRQF_SHARED,
 					"PIP RML/RSL", octeon_rml_interrupt)) {
-			panic("Unable to request_irq(OCTEON_IRQ_PIP)\n");
+			panic("Unable to request_irq(OCTEON_IRQ_PIP)");
 		}
 		if (request_irq(OCTEON_IRQ_PKO, octeon_rml_interrupt, IRQF_SHARED,
 					"PKO RML_RSL", octeon_rml_interrupt)) {
-			panic("Unable to request_irq(OCTEON_IRQ_PKO)\n");
+			panic("Unable to request_irq(OCTEON_IRQ_PKO)");
 		}
 		if (request_irq(OCTEON_IRQ_ZIP, octeon_rml_interrupt, IRQF_SHARED,
 					"ZIP RML_RSL", octeon_rml_interrupt)) {
-			panic("Unable to request_irq(OCTEON_IRQ_ZIP)\n");
+			panic("Unable to request_irq(OCTEON_IRQ_ZIP)");
 		}
 		if (request_irq(OCTEON_IRQ_RAD, octeon_rml_interrupt, IRQF_SHARED,
 					"RAD RML_RSL", octeon_rml_interrupt)) {
-			panic("Unable to request_irq(OCTEON_IRQ_RAD)\n");
+			panic("Unable to request_irq(OCTEON_IRQ_RAD)");
 		}
 		if (request_irq(OCTEON_IRQ_KEY, octeon_rml_interrupt, IRQF_SHARED,
 					"KEY RML_RSL", octeon_rml_interrupt)) {
-			panic("Unable to request_irq(OCTEON_IRQ_KEY)\n");
+			panic("Unable to request_irq(OCTEON_IRQ_KEY)");
 		}
 		/* Disable any pending SLI interrupt */
 		if (cvmx_read_csr(CVMX_PEXP_SLI_INT_SUM) & 0x1) {
@@ -1233,25 +1237,46 @@ void prom_free_prom_memory(void)
 		}
 		if (request_irq(OCTEON_IRQ_SLI, octeon_rml_interrupt, IRQF_SHARED,
 					"SLI RML/RSL", octeon_rml_interrupt)) {
-			panic("Unable to request_irq(OCTEON_IRQ_SLI)\n");
+			panic("Unable to request_irq(OCTEON_IRQ_SLI)");
 		}
 		if (request_irq(OCTEON_IRQ_DFA, octeon_rml_interrupt, IRQF_SHARED,
 					"DFA RML_RSL", octeon_rml_interrupt)) {
-			panic("Unable to request_irq(OCTEON_IRQ_DFA)\n");
+			panic("Unable to request_irq(OCTEON_IRQ_DFA)");
 		}
 		if (request_irq(OCTEON_IRQ_DPI, octeon_rml_interrupt, IRQF_SHARED,
 					"DPI RML_RSL", octeon_rml_interrupt)) {
-			panic("Unable to request_irq(OCTEON_IRQ_DPI)\n");
+			panic("Unable to request_irq(OCTEON_IRQ_DPI)");
 		}
 		if (request_irq(OCTEON_IRQ_AGL, octeon_rml_interrupt, IRQF_SHARED,
 					"AGL RML_RSL", octeon_rml_interrupt)) {
-			panic("Unable to request_irq(OCTEON_IRQ_AGL)\n");
+			panic("Unable to request_irq(OCTEON_IRQ_AGL)");
+		}
+		for (i = 0; i < 4; i++) {
+			cvmx_lmcx_dll_ctl2_t ctl2;
+			char buf[20];
+
+			/*
+			 * Check if LMC is initialized before enabling the
+			 * interrupts.
+			 */
+			ctl2.u64 = cvmx_read_csr(CVMX_LMCX_DLL_CTL2(i));
+			if (ctl2.s.intf_en == 0)
+				continue;
+
+			/* Clear pending interrupts before clearing it. */
+			cvmx_write_csr(CVMX_LMCX_INT(i),
+					cvmx_read_csr(CVMX_LMCX_INT(i)));
+
+			sprintf(buf, "LMC%d RML/RSL", i);
+			if (request_irq(OCTEON_IRQ_LMC0 + i,
+					octeon_rml_interrupt, IRQF_SHARED,
+					buf, octeon_rml_interrupt))
+				panic("Unable to request_irq(OCTEON_IRQ_LMC%d)", i);
 		}
 	} else {
 		if (request_irq(OCTEON_IRQ_RML, octeon_rml_interrupt, irq_flags,
-					"RML_RSL", octeon_rml_interrupt)) {
-			panic("Unable to request_irq(OCTEON_IRQ_RML)\n");
-		}
+					"RML_RSL", octeon_rml_interrupt))
+			panic("Unable to request_irq(OCTEON_IRQ_RML)");
 	}
 #endif
 }
@@ -1287,7 +1312,7 @@ void __init device_tree_init(void)
 	/* Copy the default tree from init memory. */
 	initial_boot_params = early_init_dt_alloc_memory_arch(dt_size, 8);
 	if (initial_boot_params == NULL)
-		panic("Could not allocate initial_boot_params\n");
+		panic("Could not allocate initial_boot_params");
 	memcpy(initial_boot_params, fdt, dt_size);
 
 	if (do_prune) {
-- 
1.7.0

