From c1edf958acea014f2a89a24d03c4ecee8803ab0f Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Fri, 11 Nov 2011 11:14:34 -0800
Subject: [PATCH 123/236] MIPS: Octeon: Use device tree to register serial ports

Source: Cavium SDK 2.2-414

Switch to using the device tree to register serial ports.

After the serial8250 driver indicates that it is initialized, add all
the ports with compatible = "cavium,octeon-3860-uart".  Octeon serial
ports have their own device type, required port flags, and I/O
functions, so using of_serial.c is not indicated.

Signed-off-by: David Daney <david.daney@cavium.com>
Integrated-by: Yang Shi <yang.shi@windriver.com>
---
 arch/mips/cavium-octeon/serial.c |  130 ++++++++++++++++----------------------
 1 files changed, 54 insertions(+), 76 deletions(-)

diff --git a/arch/mips/cavium-octeon/serial.c b/arch/mips/cavium-octeon/serial.c
index 3c17b20..37070e9 100644
--- a/arch/mips/cavium-octeon/serial.c
+++ b/arch/mips/cavium-octeon/serial.c
@@ -102,28 +102,28 @@ void octeon_serial_out(struct uart_port *up, int offset, int value)
 	cvmx_write_csr((uint64_t)(up->membase + (offset << 3)), (u8)value);
 }
 
-/*
- * Allocated in .bss, so it is all zeroed.
- */
-#define OCTEON_MAX_UARTS 3
-static struct plat_serial8250_port octeon_uart8250_data[OCTEON_MAX_UARTS + 1];
-static struct platform_device octeon_uart8250_device = {
-	.name			= "serial8250",
-	.id			= PLAT8250_DEV_PLATFORM,
-	.dev			= {
-		.platform_data	= octeon_uart8250_data,
-	},
-};
-
-static void __init octeon_uart_set_common(struct plat_serial8250_port *p)
+static int __devinit octeon_serial_probe(struct platform_device *pdev)
 {
-	p->flags = ASYNC_SKIP_TEST | UPF_SHARE_IRQ | UPF_FIXED_TYPE;
-	p->type = PORT_OCTEON;
-	p->iotype = UPIO_MEM;
-	p->regshift = 3;	/* I/O addresses are every 8 bytes */
+	int irq, res;
+	struct resource *res_mem;
+	struct uart_port port;
+
+	/* All adaptors have an irq.  */
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return irq;
+
+	memset(&port, 0, sizeof(port));
+
+	port.flags = ASYNC_SKIP_TEST | UPF_SHARE_IRQ | UPF_FIXED_TYPE;
+	port.type = PORT_OCTEON;
+	port.iotype = UPIO_MEM;
+	port.regshift = 3;
+	port.dev = &pdev->dev;
+
 	if (octeon_is_simulation())
 		/* Make simulator output fast*/
-		p->uartclk = 115200 * 16;
+		port.uartclk = 115200 * 16;
 	else
 #ifdef CONFIG_WRHV
 		/* Hardcode now, need get the clk from Hyerpvisor
@@ -132,66 +132,23 @@ static void __init octeon_uart_set_common(struct plat_serial8250_port *p)
 		 */
 		p->uartclk = 800000000;
 #else
-		p->uartclk = octeon_get_io_clock_rate();
-#endif
-	p->serial_in = octeon_serial_in;
-	p->serial_out = octeon_serial_out;
-}
-
-static int __init octeon_serial_init(void)
-{
-	int enable_uart0;
-	int enable_uart1;
-	int enable_uart2;
-	struct plat_serial8250_port *p;
-
-#ifdef CONFIG_CAVIUM_OCTEON_2ND_KERNEL
-	/*
-	 * If we are configured to run as the second of two kernels,
-	 * disable uart0 and enable uart1. Uart0 is owned by the first
-	 * kernel
-	 */
-	enable_uart0 = 0;
-	enable_uart1 = 1;
-#else
-	/*
-	 * We are configured for the first kernel. We'll enable uart0
-	 * if the bootloader told us to use 0, otherwise will enable
-	 * uart 1.
-	 */
-	enable_uart0 = (octeon_get_boot_uart() == 0);
-	enable_uart1 = (octeon_get_boot_uart() == 1);
-#ifdef CONFIG_KGDB
-	enable_uart1 = 1;
-#endif
-#endif
-#if defined(CONFIG_CAVIUM_GDB)
-	/* As a special case forcibly disable uart1 if cavium gdb is in use */
-
-	/* cavium_gdb_active is true if 'cavium_gdb' was detected on
-	   kernel command line */
-	if (cavium_gdb_active)
-		enable_uart1 = 0;
+		port.uartclk = octeon_get_io_clock_rate();
 #endif
 
-	/* Right now CN52XX is the only chip with a third uart */
-	enable_uart2 = OCTEON_IS_MODEL(OCTEON_CN52XX);
-
-	p = octeon_uart8250_data;
-	if (enable_uart0) {
-		/* Add a ttyS device for hardware uart 0 */
-		octeon_uart_set_common(p);
-		p->membase = (void *) CVMX_MIO_UARTX_RBR(0);
-		p->mapbase = CVMX_MIO_UARTX_RBR(0) & ((1ull << 49) - 1);
+	port.serial_in = octeon_serial_in;
+	port.serial_out = octeon_serial_out;
+	port.irq = irq;
 #ifdef CONFIG_WRHV
 		/* Set IRQ to zero, will get IRQ via VBI from VIOAPIC */
-		p->irq = 0;
-#else
-		p->irq = OCTEON_IRQ_UART0;
+	piort->irq = 0;
 #endif
-		p++;
+	res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res_mem == NULL) {
+		dev_err(&pdev->dev, "found no memory resource\n");
+		return -ENXIO;
 	}
 
+#if 0
 	if (enable_uart1) {
 		/* Add a ttyS device for hardware uart 1 */
 		octeon_uart_set_common(p);
@@ -216,10 +173,31 @@ static int __init octeon_serial_init(void)
 #endif
 		p++;
 	}
+#endif
+	res = serial8250_register_port(&port);
 
-	BUG_ON(p > &octeon_uart8250_data[OCTEON_MAX_UARTS]);
-
-	return platform_device_register(&octeon_uart8250_device);
+	return res >= 0 ? 0 : res;
 }
 
-device_initcall(octeon_serial_init);
+static struct of_device_id octeon_serial_match[] = {
+	{
+		.compatible = "cavium,octeon-3860-uart",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, octeon_serial_match);
+
+static struct platform_driver octeon_serial_driver = {
+	.probe		= octeon_serial_probe,
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "octeon_serial",
+		.of_match_table = octeon_serial_match,
+	},
+};
+
+static int __init octeon_serial_init(void)
+{
+	return platform_driver_register(&octeon_serial_driver);
+}
+late_initcall(octeon_serial_init);
-- 
1.7.0

