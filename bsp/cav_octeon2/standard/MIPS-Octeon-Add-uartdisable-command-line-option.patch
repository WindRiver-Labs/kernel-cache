From c945315d2b9a8d731aead24ea3f67e88a7ef0b17 Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Fri, 11 Nov 2011 11:50:53 -0800
Subject: [PATCH 138/236] MIPS: Octeon: Add "uartdisable=" command line option

Source: Cavium SDK 2.2-414

This allows for more flexibility in which UARTs have drivers installed.

uartdisable=x,y will prevent drivers being installed for UARTs x and y
(1 and 2 for instance).

The logic to enable and disable UART drivers based on
CONFIG_CAVIUM_OCTEON_2ND_KERNEL is removed and now must explicitly be
specified on the command line.

Signed-off-by: David Daney <david.daney@cavium.com>
Integrated-by: Yang Shi <yang.shi@windriver.com>
---
 arch/mips/cavium-octeon/octeon-platform.c |   25 +-------------
 arch/mips/cavium-octeon/serial.c          |   54 +++++++++++++++++++++++++++++
 arch/mips/cavium-octeon/setup.c           |   10 ++++--
 arch/mips/include/asm/octeon/octeon.h     |    1 -
 4 files changed, 62 insertions(+), 28 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-platform.c b/arch/mips/cavium-octeon/octeon-platform.c
index c71e0de..99c501c 100644
--- a/arch/mips/cavium-octeon/octeon-platform.c
+++ b/arch/mips/cavium-octeon/octeon-platform.c
@@ -459,30 +459,7 @@ int __init octeon_prune_device_tree(void)
 	}
 
 	/* Serial */
-	uart_mask = 0;
-
-#ifdef CONFIG_CAVIUM_OCTEON_2ND_KERNEL
-	/*
-	 * If we are configured to run as the second of two kernels,
-	 * disable uart0 and enable uart1. Uart0 is owned by the first
-	 * kernel
-	 */
-	uart_mask |= 2; /* uart1 */
-#else
-	/*
-	 * We are configured for the first kernel. We'll enable uart0
-	 * if the bootloader told us to use 0, otherwise will enable
-	 * uart 1.
-	 */
-	if (octeon_get_boot_uart() == 0)
-		uart_mask |= 1; /* uart0 */
-	if (octeon_get_boot_uart() == 1)
-		uart_mask |= 2; /* uart1 */
-
-#ifdef CONFIG_KGDB
-	uart_mask |= 2; /* uart1 */
-#endif
-#endif
+	uart_mask = 3;
 
 	/* Right now CN52XX is the only chip with a third uart */
 	if (OCTEON_IS_MODEL(OCTEON_CN52XX))
diff --git a/arch/mips/cavium-octeon/serial.c b/arch/mips/cavium-octeon/serial.c
index 37070e9..d85af88 100644
--- a/arch/mips/cavium-octeon/serial.c
+++ b/arch/mips/cavium-octeon/serial.c
@@ -18,6 +18,8 @@
 
 #include <asm/octeon/octeon.h>
 
+static int octeon_serial_uartdisable_mask;
+
 #if defined(CONFIG_CAVIUM_GDB) || defined(CONFIG_KGDB)
 static int cavium_gdb_active;
 
@@ -59,6 +61,7 @@ static irqreturn_t interrupt_debug_char(int cpl, void *dev_id)
 
 static int octeon_setup_debug_uart(void)
 {
+	octeon_serial_uartdisable_mask |= (1 << DEBUG_UART)
 	/* cavium_gdb_active is true if 'cavium_gdb' was detected on
 	   kernel command line */
 	if (cavium_gdb_active) {
@@ -102,6 +105,40 @@ void octeon_serial_out(struct uart_port *up, int offset, int value)
 	cvmx_write_csr((uint64_t)(up->membase + (offset << 3)), (u8)value);
 }
 
+
+static int __init octeon_serial_uartdisable_setup(char *str)
+{
+	char *comma;
+
+	while (str) {
+		comma = strchr(str, ',');
+		if (comma == NULL || (comma - str) == 2) {
+			switch (*str) {
+			case '0':
+				octeon_serial_uartdisable_mask |= 1;
+				break;
+			case '1':
+				octeon_serial_uartdisable_mask |= 2;
+				break;
+			case '2':
+				octeon_serial_uartdisable_mask |= 4;
+				break;
+			default:
+				goto err;
+			}
+		} else {
+err:
+			pr_warning("Invalid uartdisable= parameter\n");
+			break;
+		}
+		str = comma;
+		if (str)
+			str++;
+	}
+	return 0;
+}
+__setup("uartdisable=", octeon_serial_uartdisable_setup);
+
 static int __devinit octeon_serial_probe(struct platform_device *pdev)
 {
 	int irq, res;
@@ -148,6 +185,19 @@ static int __devinit octeon_serial_probe(struct platform_device *pdev)
 		return -ENXIO;
 	}
 
+	if (res_mem->start == 0x1180000000800ull && (octeon_serial_uartdisable_mask & 1)) {
+		pr_notice("UART0 disabled on command line\n");
+		return 0;
+	}
+	if (res_mem->start == 0x1180000000c00ull && (octeon_serial_uartdisable_mask & 2)) {
+		pr_notice("UART1 disabled on command line\n");
+		return 0;
+	}
+	if (res_mem->start == 0x1180000000400ull && (octeon_serial_uartdisable_mask & 4)) {
+		pr_notice("UART2 disabled on command line\n");
+		return 0;
+	}
+
 #if 0
 	if (enable_uart1) {
 		/* Add a ttyS device for hardware uart 1 */
@@ -174,6 +224,10 @@ static int __devinit octeon_serial_probe(struct platform_device *pdev)
 		p++;
 	}
 #endif
+
+	port.mapbase = res_mem->start;
+	port.membase = ioremap(res_mem->start, resource_size(res_mem));
+
 	res = serial8250_register_port(&port);
 
 	return res >= 0 ? 0 : res;
diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index d9124ef..f2b456d 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -208,7 +208,7 @@ void octeon_write_lcd(const char *s)
  *
  * Returns uart   (0 or 1)
  */
-int octeon_get_boot_uart(void)
+static int octeon_get_boot_uart(void)
 {
 	int uart;
 #ifdef CONFIG_CAVIUM_OCTEON_2ND_KERNEL
@@ -825,8 +825,12 @@ void __init native_prom_init(void)
 	if (strstr(arcs_cmdline, "console=pci"))
 		pci_console_init(strstr(arcs_cmdline, "console=pci") + 8);
 
-	if (strstr(arcs_cmdline, "console=") == NULL)
-		strcat(arcs_cmdline, " console=ttyS0,115200");
+	if (strstr(arcs_cmdline, "console=") == NULL) {
+		if (octeon_uart == 1)
+			strcat(arcs_cmdline, " console=ttyS1,115200");
+		else
+			strcat(arcs_cmdline, " console=ttyS0,115200");
+	}
 
 	if (octeon_is_simulation()) {
 		/*
diff --git a/arch/mips/include/asm/octeon/octeon.h b/arch/mips/include/asm/octeon/octeon.h
index 0b1ac9d..c57ed21 100644
--- a/arch/mips/include/asm/octeon/octeon.h
+++ b/arch/mips/include/asm/octeon/octeon.h
@@ -228,7 +228,6 @@ union octeon_cvmemctl {
 };
 extern void octeon_write_lcd(const char *s);
 extern void octeon_check_cpu_bist(void);
-extern int octeon_get_boot_uart(void);
 
 struct uart_port;
 extern unsigned int octeon_serial_in(struct uart_port *, int);
-- 
1.7.0

