From 66381a99e0d1adfdc3eab3215e8ab694007852ae Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Mon, 27 Jun 2011 17:12:39 -0700
Subject: [PATCH 022/236] MIPS: Octeon: Add watchdog timer support for cn68XX.

Source: Cavium SDK 2.1.0-407

We need to handle 32 CPUs, different register addresses, and different
counter rates.

At high clock rates, the traces from different CPUs can clobber each
other.  Add delay to prevent this from happening.

Signed-off-by: David Daney <david.daney@cavium.com>
Integrated-by: Phil Staub <Phil.Staub@windriver.com>
---
 arch/mips/cavium-octeon/octeon-wdt-main.c |   55 ++++++++++++++++------------
 arch/mips/cavium-octeon/octeon-wdt-nmi.S  |   15 ++++++++
 2 files changed, 46 insertions(+), 24 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-wdt-main.c b/arch/mips/cavium-octeon/octeon-wdt-main.c
index 430004e..aa325e9 100644
--- a/arch/mips/cavium-octeon/octeon-wdt-main.c
+++ b/arch/mips/cavium-octeon/octeon-wdt-main.c
@@ -128,6 +128,7 @@ static void __init octeon_wdt_build_stage1(void)
 	u32 *p = nmi_stage1_insns;
 	struct uasm_label *l = labels;
 	struct uasm_reloc *r = relocs;
+	bool is_ciu2 = OCTEON_IS_MODEL(OCTEON_CN68XX);
 
 	/*
 	 * For the next few instructions running the debugger may
@@ -152,20 +153,32 @@ static void __init octeon_wdt_build_stage1(void)
 		uasm_il_bbit0(&p, &r, K0, ilog2(ST0_NMI), label_enter_bootloader);
 		uasm_i_mfc0(&p, K0, C0_EBASE);
 		/* Coreid number in K0 */
-		uasm_i_andi(&p, K0, K0, 0xf);
+		uasm_i_andi(&p, K0, K0, is_ciu2 ? 0x1f : 0xf);
 		/* 8 * coreid in bits 16-31 */
 		uasm_i_dsll_safe(&p, K0, K0, 3 + 16);
 		uasm_i_ori(&p, K0, K0, 0x8001);
 		uasm_i_dsll_safe(&p, K0, K0, 16);
-		uasm_i_ori(&p, K0, K0, 0x0700);
-		uasm_i_drotr_safe(&p, K0, K0, 32);
-		/*
-		 * Should result in: 0x8001,0700,0000,8*coreid which is
-		 * CVMX_CIU_WDOGX(coreid) - 0x0500
-		 *
-		 * Now ld K0, CVMX_CIU_WDOGX(coreid)
-		 */
-		uasm_i_ld(&p, K0, 0x500, K0);
+		if (is_ciu2) {
+			uasm_i_ori(&p, K0, K0, 0x0701);
+			uasm_i_dsll_safe(&p, K0, K0, 16);
+			uasm_i_ori(&p, K0, K0, 0x0010);
+			uasm_i_drotr_safe(&p, K0, K0, 48);
+			/*
+			 * Should result in: 0x8001,0701,0010,8*coreid which is
+			 * CVMX_CIU2_WDOGX(coreid)
+			 */
+			uasm_i_ld(&p, K0, 0, K0);
+		} else {
+			uasm_i_ori(&p, K0, K0, 0x0700);
+			uasm_i_drotr_safe(&p, K0, K0, 32);
+			/*
+			 * Should result in: 0x8001,0700,0000,8*coreid which is
+			 * CVMX_CIU_WDOGX(coreid) - 0x0500
+			 *
+			 * Now ld K0, CVMX_CIU_WDOGX(coreid)
+			 */
+			uasm_i_ld(&p, K0, 0x500, K0);
+		}
 		/*
 		 * If bit one set handle the NMI as a watchdog event.
 		 * otherwise transfer control to bootloader.
@@ -174,18 +187,6 @@ static void __init octeon_wdt_build_stage1(void)
 		uasm_i_nop(&p);
 	}
 
-	/* Clear Dcache so cvmseg works right. */
-	uasm_i_cache(&p, 1, 0, 0);
-
-	/* Use K0 to do a read/modify/write of CVMMEMCTL */
-	uasm_i_dmfc0(&p, K0, C0_CVMMEMCTL);
-	/* Clear out the size of CVMSEG	*/
-	uasm_i_dins(&p, K0, 0, 0, 6);
-	/* Set CVMSEG to its largest value */
-	uasm_i_ori(&p, K0, K0, 0x1c0 | 54);
-	/* Store the CVMMEMCTL value */
-	uasm_i_dmtc0(&p, K0, C0_CVMMEMCTL);
-
 	/* Load the address of the second stage handler */
 	UASM_i_LA(&p, K0, (long)octeon_wdt_nmi_stage2);
 	uasm_i_jr(&p, K0);
@@ -330,10 +331,10 @@ void octeon_wdt_nmi_stage3(uint64_t reg[32])
 	uint64_t cp0_epc = read_c0_epc();
 
 	/* Delay so output from all cores output is not jumbled together. */
-	__delay(100000000ull * coreid);
+	udelay(85000 * coreid);
 
 	octeon_wdt_write_string("\r\n*** NMI Watchdog interrupt on Core 0x");
-	octeon_wdt_write_hex(coreid, 1);
+	octeon_wdt_write_hex(coreid, 2);
 	octeon_wdt_write_string(" ***\r\n");
 	for (i = 0; i < 32; i++) {
 		octeon_wdt_write_string("\t");
@@ -485,6 +486,9 @@ static void octeon_wdt_calc_parameters(int t)
 	countdown_reset = periods > 2 ? periods - 2 : 0;
 	heartbeat = t;
 	timeout_cnt = ((octeon_get_io_clock_rate() >> 8) * timeout_sec) >> 8;
+	/* cn68XX seems to run at half that rate.  */
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
+		timeout_cnt >>= 1;
 }
 
 static int octeon_wdt_set_heartbeat(int t)
@@ -682,6 +686,9 @@ static int __init octeon_wdt_init(void)
 	do {
 		max_timeout_sec--;
 		timeout_cnt = ((octeon_get_io_clock_rate() >> 8) * max_timeout_sec) >> 8;
+		/* cn68XX seems to run at half that rate.  */
+		if (OCTEON_IS_MODEL(OCTEON_CN68XX))
+			timeout_cnt >>= 1;
 	} while (timeout_cnt > 65535);
 
 	BUG_ON(timeout_cnt == 0);
diff --git a/arch/mips/cavium-octeon/octeon-wdt-nmi.S b/arch/mips/cavium-octeon/octeon-wdt-nmi.S
index a831080..24f2eac 100644
--- a/arch/mips/cavium-octeon/octeon-wdt-nmi.S
+++ b/arch/mips/cavium-octeon/octeon-wdt-nmi.S
@@ -17,6 +17,21 @@
 	.set 	push
 	.set 	noreorder
 	.set 	noat
+	/* Clear Dcache so cvmseg works right. */
+	cache	1,0($0)
+	/* Save K0 into the debug scratch register */
+	dmtc0	k0, $31
+	/* Use K0 to do a read/modify/write of CVMMEMCTL */
+	dmfc0	k0, $11, 7
+	/* Clear out the size of CVMSEG	*/
+	dins	k0, $0, 0, 6
+	/* Set CVMSEG to its largest value */
+	ori	k0, k0, 0x1c0 | 54
+	/* Store the CVMMEMCTL value */
+	dmtc0	k0, $11, 7
+	/* Restore K0 from the debug scratch register */
+	dmfc0	k0, $31
+	
 	/* Save all registers to the top CVMSEG. This shouldn't
 	 * corrupt any state used by the kernel. Also all registers
 	 * should have the value right before the NMI. */
-- 
1.7.0

