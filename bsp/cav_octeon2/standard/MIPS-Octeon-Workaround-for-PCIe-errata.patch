From 65ca2b9a828c3c632040e091c9752d41a52bf9cb Mon Sep 17 00:00:00 2001
From: Phil Staub <Phil.Staub@windriver.com>
Date: Mon, 18 Apr 2011 17:08:05 -0700
Subject: [PATCH 035/236] MIPS: Octeon: Workaround for PCIe errata

Source: Cavium SDK 2.1.0-407

Two errata workarounds:

Erratum PCIE-14459

PCI Express devices are allowed to respond to configuration requests
with a configuration request retry status (CRS) during the early boot
period. OCTEON II will regenerate the configuration request as long as
the timeout specified by PEMi_CTL_STATUS[CFG_RTRY] does not expire. If
the timeout specified by PEMi_CTL_STATUS[CFG_RTRY] expires without
successful completion, the requesting core(s) will receive an all-ones
reply, and PEMi_INT_SUM[CRS_ERR] will be set.  However, if a CRS is
received, the CRS_ERR interrupt will fire unconditionally, even if a
successful completion arrives from one of the regenerated requests.

The workaround is to disable automatic configuration request retries
by setting PEMi_CTL_STATUS[CFG_RTRY] to zero. If the remote device is
not ready on the first attempt, the core will receive an all-ones
reply immediately, and PEMi_INT_SUM[CRS_DR] will be set. Core software
may then re-initiate the transaction.

Erratum PCIE-15205

When we configure one port as PCIe and other as SRIO,
SRIO MAC asserts all of CIU_INT*_SUM0[PCI_INT] with a PCIe MAC
present and leads to spurious interrupts on CN63XX 1_x/2.0 h/w.

Set all of SLI_CTL_PORT*[INT*_MAP] of SRIO and PCIe MAC to different
values to fix the issue.

Integrated-by: Phil Staub <Phil.Staub@windriver.com>
---
 arch/mips/pci/pcie-octeon.c |  291 +++++++++++++++++++++++++++++++-----------
 1 files changed, 215 insertions(+), 76 deletions(-)

diff --git a/arch/mips/pci/pcie-octeon.c b/arch/mips/pci/pcie-octeon.c
index 53886fb..24755a2 100644
--- a/arch/mips/pci/pcie-octeon.c
+++ b/arch/mips/pci/pcie-octeon.c
@@ -17,7 +17,10 @@
 #include <asm/octeon/cvmx-pciercx-defs.h>
 #include <asm/octeon/cvmx-pescx-defs.h>
 #include <asm/octeon/cvmx-pexp-defs.h>
+#include <asm/octeon/cvmx-sli-defs.h>
+#include <asm/octeon/cvmx-sriox-defs.h>
 #include <asm/octeon/cvmx-pcie.h>
+#include <asm/octeon/cvmx-pemx-defs.h>
 #include <asm/octeon/pci-octeon.h>
 
 #include <dma-coherence.h>
@@ -26,6 +29,12 @@
 int disable;
 module_param(disable, int, S_IRUGO);
 
+static int enable_pcie_14459_war;
+#ifdef OCT_PCIE_DBG
+#define oct_pcie_dbg(fmt, ...) printk(fmt, ##__VA_ARGS__)
+#else
+#define oct_pcie_dbg(fmt, ...)
+#endif
 /**
  * Map a PCI device to the appropriate interrupt line
  *
@@ -75,6 +84,53 @@ int __init octeon_pcie_pcibios_map_irq(const struct pci_dev *dev,
 	return pin - 1 + OCTEON_IRQ_PCI_INT0;
 }
 
+void show_pcie_errors(void)
+{
+	cvmx_pemx_dbg_info_t pemx_dbg;
+	cvmx_pemx_int_sum_t pemx_int_sum;
+	pemx_dbg.u64 = cvmx_read_csr(CVMX_PEMX_DBG_INFO(1));
+	pemx_int_sum.u64 = cvmx_read_csr(CVMX_PEMX_INT_SUM(1));
+	oct_pcie_dbg("ints=%llx  dbg=%llx ", pemx_int_sum.u64, pemx_dbg.u64);
+}
+
+
+void show_pemx_ctl_status(void)
+{
+	cvmx_pemx_ctl_status_t pemx_ctl;
+	pemx_ctl.u64 = cvmx_read_csr(CVMX_PEMX_CTL_STATUS(1));
+	oct_pcie_dbg("ctl= %llx ", pemx_ctl.u64);
+}
+
+static  void set_cfg_read_retry(u32 retry_cnt)
+{
+	cvmx_pemx_ctl_status_t pemx_ctl;
+	pemx_ctl.u64 = cvmx_read_csr(CVMX_PEMX_CTL_STATUS(1));
+	pemx_ctl.s.cfg_rtry = retry_cnt;
+	cvmx_write_csr(CVMX_PEMX_CTL_STATUS(1), pemx_ctl.u64);
+}
+
+
+static u32 disable_cfg_read_retry(void)
+{
+	u32 retry_cnt;
+
+	cvmx_pemx_ctl_status_t pemx_ctl;
+	pemx_ctl.u64 = cvmx_read_csr(CVMX_PEMX_CTL_STATUS(1));
+	retry_cnt =  pemx_ctl.s.cfg_rtry;
+	pemx_ctl.s.cfg_rtry = 0;
+	cvmx_write_csr(CVMX_PEMX_CTL_STATUS(1), pemx_ctl.u64);
+	return retry_cnt;
+}
+
+static int is_cfg_retry(void)
+{
+	cvmx_pemx_int_sum_t pemx_int_sum;
+	pemx_int_sum.u64 = cvmx_read_csr(CVMX_PEMX_INT_SUM(1));
+	if (pemx_int_sum.s.crs_dr)
+		return 1;
+	return 0;
+}
+
 /**
  * Read a value from configuration space
  *
@@ -92,6 +148,10 @@ static inline int octeon_pcie_read_config(int pcie_port, struct pci_bus *bus,
 	union octeon_cvmemctl cvmmemctl;
 	union octeon_cvmemctl cvmmemctl_save;
 	int bus_number = bus->number;
+	int cfg_retry = 0;
+	int retry_cnt = 0;
+	int max_retry_cnt = 10;
+	u32 cfg_retry_cnt = 0;
 
 	/* For the top level bus make sure our hardware bus number matches the
 		software one */
@@ -200,29 +260,46 @@ static inline int octeon_pcie_read_config(int pcie_port, struct pci_bus *bus,
 		__write_64bit_c0_register($11, 7, cvmmemctl.u64);
 	}
 
-	/*
-	pr_debug("octeon_pcie_read_config(pcie_port=%d, bus=%d, devfn=0x%x, \
-		 reg=0x%x, size=%d, val=%p)\n",
-		pcie_port, bus_number, devfn, reg, size, val);
-	*/
-
-	switch (size) {
-	case 4:
-		*val = cvmx_pcie_config_read32(pcie_port, bus_number,
-					       devfn >> 3, devfn & 0x7, reg);
-		break;
-	case 2:
-		*val = cvmx_pcie_config_read16(pcie_port, bus_number,
-					       devfn >> 3, devfn & 0x7, reg);
-		break;
-	case 1:
-		*val = cvmx_pcie_config_read8(pcie_port, bus_number, devfn >> 3,
-					      devfn & 0x7, reg);
-		break;
-	default:
-		return PCIBIOS_FUNC_NOT_SUPPORTED;
-	}
+	if ((OCTEON_IS_MODEL(OCTEON_CN63XX)) && (enable_pcie_14459_war))
+		cfg_retry_cnt = disable_cfg_read_retry();
+
+	/*show_pemx_ctl_status(); show_pcie_errors();*/
+	oct_pcie_dbg("pcie_cfg_rd port=%d b=%d devfn=0x%03x reg=0x%03x"
+		" size=%d ", pcie_port, bus_number, devfn, reg, size);
+	do {
+		switch (size) {
+		case 4:
+			*val = cvmx_pcie_config_read32(pcie_port, bus_number,
+				devfn >> 3, devfn & 0x7, reg);
+			break;
+		case 2:
+			*val = cvmx_pcie_config_read16(pcie_port, bus_number,
+				devfn >> 3, devfn & 0x7, reg);
+			break;
+		case 1:
+			*val = cvmx_pcie_config_read8(pcie_port, bus_number,
+				devfn >> 3, devfn & 0x7, reg);
+			break;
+		default:
+			if (OCTEON_IS_MODEL(OCTEON_CN63XX))
+				set_cfg_read_retry(cfg_retry_cnt);
+			return PCIBIOS_FUNC_NOT_SUPPORTED;
+		}
+		if ((OCTEON_IS_MODEL(OCTEON_CN63XX)) &&
+			(enable_pcie_14459_war)) {
+			cfg_retry = is_cfg_retry();
+			retry_cnt++;
+			if (retry_cnt > max_retry_cnt) {
+				printk(KERN_ERR " pcie cfg_read retries "
+				"failed. retry_cnt=%d\n", retry_cnt);
+				cfg_retry = 0;
+			}
+		}
+	} while (cfg_retry);
 
+	if ((OCTEON_IS_MODEL(OCTEON_CN63XX)) && (enable_pcie_14459_war))
+		set_cfg_read_retry(cfg_retry_cnt);
+	oct_pcie_dbg("val=%08x  : tries=%02d\n", *val, retry_cnt);
 	if (OCTEON_IS_MODEL(OCTEON_CN56XX_PASS1) ||
 	    OCTEON_IS_MODEL(OCTEON_CN56XX_PASS1_1))
 		write_c0_cvmmemctl(cvmmemctl_save.u64);
@@ -263,11 +340,10 @@ static inline int octeon_pcie_write_config(int pcie_port, struct pci_bus *bus,
 {
 	int bus_number = bus->number;
 
-	/*
-	pr_debug("octeon_pcie_write_config(pcie_port=%d, bus=%d, devfn=0x%x,\
-		 reg=0x%x, size=%d, val=0x%x)\n",
-		 pcie_port, bus_number, devfn, reg, size, val);
-	*/
+	oct_pcie_dbg("pcie_cfg_wr port=%d b=%d devfn=0x%03x"
+		" reg=0x%03x size=%d val=%08x\n", pcie_port, bus_number, devfn,
+		reg, size, val);
+
 
 	switch (size) {
 	case 4:
@@ -385,6 +461,9 @@ static int __init octeon_pcie_setup(void)
 {
 	int result;
 	int host_mode;
+	int srio_war15205 = 0, port;
+	cvmx_sli_ctl_portx_t sli_ctl_portx;
+	cvmx_sriox_status_reg_t sriox_status_reg;
 
 	/* These chips don't have PCIe */
 	if (!octeon_has_feature(OCTEON_FEATURE_PCIE))
@@ -442,6 +521,16 @@ static int __init octeon_pcie_setup(void)
 
 	if (host_mode) {
 		pr_notice("PCIe: Initializing port 0\n");
+		/* CN63XX pass 1_x/2.0 errata PCIe-15205 */
+		if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X) ||
+			OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_0)) {
+			sriox_status_reg.u64 =
+				cvmx_read_csr(CVMX_SRIOX_STATUS_REG(0));
+			if (sriox_status_reg.s.srio) {
+				srio_war15205 += 1;      /* Port is SRIO */
+				port = 0;
+			}
+		}
 		result = cvmx_pcie_rc_initialize(0);
 		if (result == 0) {
 			/* Memory offsets are physical addresses */
@@ -477,6 +566,12 @@ static int __init octeon_pcie_setup(void)
 		}
 	} else {
 		pr_notice("PCIe: Port 0 in endpoint mode, skipping.\n");
+		/* CN63XX pass 1_x/2.0 errata PCIe-15205 */
+		if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X) ||
+			OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_0)) {
+			srio_war15205 += 1;
+			port = 0;
+		}
 	}
 
 	if (octeon_has_feature(OCTEON_FEATURE_NPEI)) {
@@ -494,60 +589,104 @@ static int __init octeon_pcie_setup(void)
 		host_mode = mio_rst_ctl.s.host_mode;
 	}
 
-	if (!host_mode) {
+	if (host_mode) {
+		pr_notice("PCIe: Initializing port 1\n");
+		/* CN63XX pass 1_x/2.0 errata PCIe-15205 */
+		if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X) ||
+			OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_0)) {
+			sriox_status_reg.u64 =
+				cvmx_read_csr(CVMX_SRIOX_STATUS_REG(1));
+			if (sriox_status_reg.s.srio) {
+				srio_war15205 += 1;      /* Port is SRIO */
+				port = 1;
+			}
+		}
+		result = cvmx_pcie_rc_initialize(1);
+		if (result == 0) {
+			/* Memory offsets are physical addresses */
+			octeon_pcie1_controller.mem_offset =
+				cvmx_pcie_get_mem_base_address(1);
+			/*
+			 * To calculate the address for accessing the 2nd PCIe
+			 * device, either 'io_map_base' (pci_iomap()), or
+			 * 'mips_io_port_base' (ioport_map()) value is added to
+			 * pci_resource_start(dev,bar)). The
+			 * 'mips_io_port_base' is set only once based on first
+			 * PCIe. Also changing 'io_map_base' based on first
+			 * slot's value so that both the routines will work
+			 * properly.
+			 */
+			octeon_pcie1_controller.io_map_base =
+				CVMX_ADD_IO_SEG(
+					cvmx_pcie_get_io_base_address(0));
+			/* IO offsets are Mips virtual addresses */
+			octeon_pcie1_controller.io_offset =
+				cvmx_pcie_get_io_base_address(1) -
+				cvmx_pcie_get_io_base_address(0);
+			/*
+			 * To keep things similar to PCI, we start device
+			 * addresses at the same place as PCI uisng big bar
+			 * support. This normally translates to 4GB-256MB,
+			 * which is the same as most x86 PCs.
+			 */
+			octeon_pcie1_controller.mem_resource->start =
+				cvmx_pcie_get_mem_base_address(1) +
+				(4ul << 30) - (OCTEON_PCI_BAR1_HOLE_SIZE << 20);
+			octeon_pcie1_controller.mem_resource->end =
+				cvmx_pcie_get_mem_base_address(1) +
+				cvmx_pcie_get_mem_size(1) - 1;
+			/*
+			 * Ports must be above 16KB for the ISA bus filtering
+			 * in the PCI-X to PCI bridge.
+			 */
+			octeon_pcie1_controller.io_resource->start =
+				cvmx_pcie_get_io_base_address(1) -
+				cvmx_pcie_get_io_base_address(0);
+			octeon_pcie1_controller.io_resource->end =
+				octeon_pcie1_controller.io_resource->start +
+				cvmx_pcie_get_io_size(1) - 1;
+			msleep(100); /* Some devices need extra time */
+			register_pci_controller(&octeon_pcie1_controller);
+		}
+		octeon_pci_dma_init();
+	} else {
 		pr_notice("PCIe: Port 1 not in root complex mode, skipping.\n");
-		return 0;
+		/* CN63XX pass 1_x/2.0 errata PCIe-15205  */
+		if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X) ||
+			OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_0)) {
+			srio_war15205 += 1;
+			port = 1;
+		}
 	}
 
-	pr_notice("PCIe: Initializing port 1\n");
-	result = cvmx_pcie_rc_initialize(1);
-	if (result == 0) {
-		/* Memory offsets are physical addresses */
-		octeon_pcie1_controller.mem_offset =
-			cvmx_pcie_get_mem_base_address(1);
-		/*
-		 * To calculate the address for accessing the 2nd PCIe device,
-		 * either 'io_map_base' (pci_iomap()), or 'mips_io_port_base'
-		 * (ioport_map()) value is added to
-		 * pci_resource_start(dev,bar)). The 'mips_io_port_base' is set
-		 * only once based on first PCIe. Also changing 'io_map_base'
-		 * based on first slot's value so that both the routines will
-		 * work properly.
-		 */
-		octeon_pcie1_controller.io_map_base =
-			CVMX_ADD_IO_SEG(cvmx_pcie_get_io_base_address(0));
-		/* IO offsets are Mips virtual addresses */
-		octeon_pcie1_controller.io_offset =
-			cvmx_pcie_get_io_base_address(1) -
-			cvmx_pcie_get_io_base_address(0);
-		/*
-		 * To keep things similar to PCI, we start device
-		 * addresses at the same place as PCI uisng big bar
-		 * support. This normally translates to 4GB-256MB,
-		 * which is the same as most x86 PCs.
-		 */
-		octeon_pcie1_controller.mem_resource->start =
-			cvmx_pcie_get_mem_base_address(1) + (4ul << 30) -
-			(OCTEON_PCI_BAR1_HOLE_SIZE << 20);
-		octeon_pcie1_controller.mem_resource->end =
-			cvmx_pcie_get_mem_base_address(1) +
-			cvmx_pcie_get_mem_size(1) - 1;
-		/*
-		 * Ports must be above 16KB for the ISA bus filtering
-		 * in the PCI-X to PCI bridge.
-		 */
-		octeon_pcie1_controller.io_resource->start =
-			cvmx_pcie_get_io_base_address(1) -
-			cvmx_pcie_get_io_base_address(0);
-		octeon_pcie1_controller.io_resource->end =
-			octeon_pcie1_controller.io_resource->start +
-			cvmx_pcie_get_io_size(1) - 1;
-		msleep(100); /* Some devices need extra time */
-		register_pci_controller(&octeon_pcie1_controller);
+	/* CN63XX pass 1_x/2.0 errata PCIe-15205 requires setting all of
+	* SRIO MACs SLI_CTL_PORT*[INT*_MAP] to similar value and all of PCIe
+	* Macs SLI_CTL_PORT*[INT*_MAP] different value from the previous
+	* set values
+	*/
+	if (OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X) ||
+		OCTEON_IS_MODEL(OCTEON_CN63XX_PASS2_0)) {
+		if (srio_war15205 == 1) {
+			sli_ctl_portx.u64 =
+				cvmx_read_csr(CVMX_PEXP_SLI_CTL_PORTX(port));
+			sli_ctl_portx.s.inta_map = 1;
+			sli_ctl_portx.s.intb_map = 1;
+			sli_ctl_portx.s.intc_map = 1;
+			sli_ctl_portx.s.intd_map = 1;
+			cvmx_write_csr(CVMX_PEXP_SLI_CTL_PORTX(port),
+				       sli_ctl_portx.u64);
+
+			sli_ctl_portx.u64 =
+				cvmx_read_csr(CVMX_PEXP_SLI_CTL_PORTX(!port));
+			sli_ctl_portx.s.inta_map = 0;
+			sli_ctl_portx.s.intb_map = 0;
+			sli_ctl_portx.s.intc_map = 0;
+			sli_ctl_portx.s.intd_map = 0;
+			cvmx_write_csr(CVMX_PEXP_SLI_CTL_PORTX(!port),
+				       sli_ctl_portx.u64);
+		}
 	}
 
-	octeon_pci_dma_init();
-
 	return 0;
 }
 
-- 
1.7.0

