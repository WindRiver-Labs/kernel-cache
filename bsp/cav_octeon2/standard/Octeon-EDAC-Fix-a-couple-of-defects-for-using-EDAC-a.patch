From bbab71429ab0ee932dc0ecc63d6320b28307631f Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Mon, 13 Feb 2012 09:12:41 -0800
Subject: [PATCH 172/236] Octeon: EDAC: Fix a couple of defects for using EDAC as modules

When using EDAC driver as modules, a couple of bugs are captured,
fix below issues:

1. Export a couple of symbols, otherwise loading EDAC modules fails due to
undefined symbols
2. Move co_edac_disable to exit section from init section, otherwise when
unloading octeon_edac-lmc.ko, a segmentation fault is triggered because
init section code is removed after module is initialized
3. Don't disable ECC_ENA is LMC controller since it's initialized by
bootloader during boot and keep it intact during runtime otherwise DDR
ECC error is triggered.
4. Initialize edac_op_state for each module. It's initialized by octeon_edac-pc,
but there is no dependance between other modules and it.

Signed-off-by: Yang Shi <yang.shi@windriver.com>
---
 arch/mips/mm/c-octeon.c        |    2 ++
 drivers/edac/octeon_edac-l2c.c |    8 ++++++++
 drivers/edac/octeon_edac-lmc.c |   17 ++++++++---------
 drivers/edac/octeon_edac-pc.c  |    8 +-------
 drivers/edac/octeon_edac-pci.c |    7 +++++++
 simple_exec/cvmx-pcie.c        |    4 ++--
 6 files changed, 28 insertions(+), 18 deletions(-)

diff --git a/arch/mips/mm/c-octeon.c b/arch/mips/mm/c-octeon.c
index 8a879f6..990e194 100644
--- a/arch/mips/mm/c-octeon.c
+++ b/arch/mips/mm/c-octeon.c
@@ -338,3 +338,5 @@ asmlinkage void cache_parity_error_octeon_non_recoverable(void)
 {
 	cache_parity_error_octeon(1);
 }
+
+EXPORT_SYMBOL(cache_err_dcache);
diff --git a/drivers/edac/octeon_edac-l2c.c b/drivers/edac/octeon_edac-l2c.c
index e76ceab..257a969 100644
--- a/drivers/edac/octeon_edac-l2c.c
+++ b/drivers/edac/octeon_edac-l2c.c
@@ -151,6 +151,11 @@ static int __init co_edac_init(void)
 		num_l2tad = 4;
 #endif
 #endif
+
+	/* make sure error reporting method is sane */
+	if (edac_op_state != EDAC_OPSTATE_INVAL) {
+		edac_op_state = EDAC_OPSTATE_POLL; 
+	}
 	ret = platform_driver_register(&co_l2c_driver);
 	if (ret)
 		pr_warning(EDAC_MOD_STR " EDAC failed to register\n");
@@ -168,3 +173,6 @@ module_exit(co_edac_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Ralf Baechle <ralf.baechle@windriver.com>");
+module_param(edac_op_state, int, 0444);
+MODULE_PARM_DESC(edac_op_state,
+		 "EDAC Error Reporting state: 0=Poll");
diff --git a/drivers/edac/octeon_edac-lmc.c b/drivers/edac/octeon_edac-lmc.c
index 199b0be..a2ed629 100644
--- a/drivers/edac/octeon_edac-lmc.c
+++ b/drivers/edac/octeon_edac-lmc.c
@@ -134,20 +134,12 @@ static void __init co_edac_enable(void)
 	}
 }
 
-static void __init co_edac_disable(void)
+static void __exit co_edac_disable(void)
 {
-	lmc_mem_cfg	cfg;
 	lmc_int_en	lint_en;
 	int		lmc;
 
 	for (lmc = 0; lmc < max_lmc; lmc++) {
-		cfg.u64 = cvmx_read_csr(LMC_MEM_CFG0(0) + lmc * LMC_STRIDE);
-		if (!cfg.s.ecc_ena)
-			continue;
-
-		cfg.s.ecc_ena = 0;
-		cvmx_write_csr(LMC_MEM_CFG0(0) + lmc * LMC_STRIDE, cfg.u64);
-
 		lint_en.u64 = cvmx_read_csr(LMC_INT_EN(0) + lmc * LMC_STRIDE);
 		lint_en.s.intr_sec_ena = 0;
 		lint_en.s.intr_ded_ena = 0;
@@ -222,6 +214,10 @@ static int __init co_edac_init(void)
 		}
 	}
 
+	/* make sure error reporting method is sane */
+	if (edac_op_state != EDAC_OPSTATE_INVAL) {
+		edac_op_state = EDAC_OPSTATE_POLL; 
+	}
 	ret = platform_driver_register(&co_lmc_driver);
 	if (ret) {
 		pr_warning(EDAC_MOD_STR " LMC EDAC failed to register\n");
@@ -251,3 +247,6 @@ module_exit(co_edac_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Ralf Baechle <ralf.baechle@windriver.com>");
+module_param(edac_op_state, int, 0444);
+MODULE_PARM_DESC(edac_op_state,
+		 "EDAC Error Reporting state: 0=Poll");
diff --git a/drivers/edac/octeon_edac-pc.c b/drivers/edac/octeon_edac-pc.c
index 23ddcb7..3509c1f 100644
--- a/drivers/edac/octeon_edac-pc.c
+++ b/drivers/edac/octeon_edac-pc.c
@@ -110,14 +110,8 @@ static int __init co_edac_init(void)
 	int ret;
 
 	/* make sure error reporting method is sane */
-	switch (edac_op_state) {
-	case EDAC_OPSTATE_INT:
-	case EDAC_OPSTATE_POLL:
+	if (edac_op_state != EDAC_OPSTATE_INVAL) {
 		edac_op_state = EDAC_OPSTATE_POLL; 
-		break;
-	default:
-		edac_op_state = EDAC_OPSTATE_POLL;
-		break;
 	}
 	ret = platform_driver_register(&co_cache_error_driver);
 	if (ret)
diff --git a/drivers/edac/octeon_edac-pci.c b/drivers/edac/octeon_edac-pci.c
index e398d81..4f2f13d 100644
--- a/drivers/edac/octeon_edac-pci.c
+++ b/drivers/edac/octeon_edac-pci.c
@@ -166,6 +166,10 @@ static int __init co_edac_init(void)
 {
 	int ret;
 
+	/* make sure error reporting method is sane */
+	if (edac_op_state != EDAC_OPSTATE_INVAL) {
+		edac_op_state = EDAC_OPSTATE_POLL; 
+	}
 	ret = platform_driver_register(&co_pci_driver);
 	if (ret)
 		pr_warning(EDAC_MOD_STR " PCI EDAC failed to register\n");
@@ -183,3 +187,6 @@ module_exit(co_edac_exit);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Ralf Baechle <ralf.baechle@windriver.com>");
+module_param(edac_op_state, int, 0444);
+MODULE_PARM_DESC(edac_op_state,
+		 "EDAC Error Reporting state: 0=Poll");
diff --git a/simple_exec/cvmx-pcie.c b/simple_exec/cvmx-pcie.c
index 529fd2b..6179e47 100644
--- a/simple_exec/cvmx-pcie.c
+++ b/simple_exec/cvmx-pcie.c
@@ -1458,7 +1458,7 @@ uint32_t cvmx_pcie_cfgx_read(int pcie_port, uint32_t cfg_offset)
         return pemx_cfg_rd.s.data;
     }
 }
-
+EXPORT_SYMBOL(cvmx_pcie_cfgx_read);
 
 /**
  * Write a PCIe config space register indirectly. This is used for
@@ -1487,7 +1487,7 @@ void cvmx_pcie_cfgx_write(int pcie_port, uint32_t cfg_offset, uint32_t val)
         cvmx_write_csr(CVMX_PEMX_CFG_WR(pcie_port), pemx_cfg_wr.u64);
     }
 }
-
+EXPORT_SYMBOL(cvmx_pcie_cfgx_write);
 
 /**
  * Initialize a PCIe port for use in target(EP) mode.
-- 
1.7.0

