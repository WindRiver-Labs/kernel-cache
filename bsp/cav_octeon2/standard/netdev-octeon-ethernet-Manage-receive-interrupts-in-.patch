From 3b7cd4d65f61e35aa69cb3cfe912630f4eff4479 Mon Sep 17 00:00:00 2001
From: David Daney <ddaney@caviumnetworks.com>
Date: Thu, 10 Feb 2011 14:42:08 -0800
Subject: [PATCH 066/236] netdev: octeon-ethernet: Manage receive interrupts in the POW/SSO.

Source: Cavium SDK 2.1.0-407

We really cannot be calling enable_interrupt()/disable_interrupt()
from IRQ context.  Manage the interrupt sources by masking them in the
POW/SSO registers instead.

Signed-off-by: David Daney <ddaney@caviumnetworks.com>
Integrated-by: Phil Staub <Phil.Staub@windriver.com>
---
 drivers/net/octeon/ethernet-napi.c |   15 ++------
 drivers/net/octeon/ethernet-rx.c   |   66 ++++++++++++++++++++---------------
 2 files changed, 41 insertions(+), 40 deletions(-)

diff --git a/drivers/net/octeon/ethernet-napi.c b/drivers/net/octeon/ethernet-napi.c
index 1a2dd2b..789f088 100644
--- a/drivers/net/octeon/ethernet-napi.c
+++ b/drivers/net/octeon/ethernet-napi.c
@@ -98,19 +98,10 @@ static int CVM_OCT_NAPI_POLL(struct napi_struct *napi, int budget)
 
 		prefetch(work);
 		did_work_request = 0;
-		if (unlikely(work == NULL)) {
-			if (CVM_OCT_NAPI_HAS_CN68XX_SSO) {
-				cvmx_write_csr(CVMX_SSO_WQ_INT, 1ULL << pow_receive_group);
-				cvmx_write_csr(CVMX_SSO_WQ_IQ_DIS, 1ULL << pow_receive_group);
-			} else {
-				union cvmx_pow_wq_int wq_int;
-				wq_int.u64 = 0;
-				wq_int.s.iq_dis = 1 << pow_receive_group;
-				wq_int.s.wq_int = 1 << pow_receive_group;
-				cvmx_write_csr(CVMX_POW_WQ_INT, wq_int.u64);
-			}
+
+		if (unlikely(work == NULL))
 			break;
-		}
+
 		pskb = (struct sk_buff **)(cvm_oct_get_buffer_ptr(work->packet_ptr) - sizeof(void *));
 		prefetch(pskb);
 
diff --git a/drivers/net/octeon/ethernet-rx.c b/drivers/net/octeon/ethernet-rx.c
index f11d49a..05679ea 100644
--- a/drivers/net/octeon/ethernet-rx.c
+++ b/drivers/net/octeon/ethernet-rx.c
@@ -141,7 +141,30 @@ static void cvm_oct_no_more_work(struct napi_struct *napi)
 		 * we can start processing again when there is
 		 * something to do.
 		 */
-		enable_irq(OCTEON_IRQ_WORKQ0 + pow_receive_group);
+
+		if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+			union cvmx_sso_wq_int_thrx int_thr;
+			int_thr.u64 = 0;
+			int_thr.s.iq_thr = 1;
+			int_thr.s.ds_thr = 1;
+			/*
+			 * Enable SSO interrupt when our port has at
+			 * least one packet.
+			 */
+			cvmx_write_csr(CVMX_SSO_WQ_INT_THRX(pow_receive_group),
+				       int_thr.u64);
+		} else {
+			union cvmx_pow_wq_int_thrx int_thr;
+			int_thr.u64 = 0;
+			int_thr.s.iq_thr = 1;
+			int_thr.s.ds_thr = 1;
+			/*
+			 * Enable POW interrupt when our port has at
+			 * least one packet.
+			 */
+			cvmx_write_csr(CVMX_POW_WQ_INT_THRX(pow_receive_group),
+				       int_thr.u64);
+		}
 	}
 }
 
@@ -157,7 +180,20 @@ static irqreturn_t cvm_oct_do_interrupt(int cpl, void *dev_id)
 	unsigned long flags;
 
 	/* Disable the IRQ and start napi_poll. */
-	disable_irq_nosync(OCTEON_IRQ_WORKQ0 + pow_receive_group);
+	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
+		cvmx_write_csr(CVMX_SSO_WQ_INT_THRX(pow_receive_group), 0);
+		cvmx_write_csr(CVMX_SSO_WQ_INT, 1ULL << pow_receive_group);
+		cvmx_write_csr(CVMX_SSO_WQ_IQ_DIS, 1ULL << pow_receive_group);
+	} else {
+		union cvmx_pow_wq_int wq_int;
+
+		cvmx_write_csr(CVMX_POW_WQ_INT_THRX(pow_receive_group), 0);
+
+		wq_int.u64 = 0;
+		wq_int.s.iq_dis = 1 << pow_receive_group;
+		wq_int.s.wq_int = 1 << pow_receive_group;
+		cvmx_write_csr(CVMX_POW_WQ_INT, wq_int.u64);
+	}
 
 	spin_lock_irqsave(&core_state.lock, flags);
 
@@ -358,11 +394,7 @@ void cvm_oct_rx_initialize(int num_wqe)
 		panic("Could not acquire Ethernet IRQ %d\n",
 		      OCTEON_IRQ_WORKQ0 + pow_receive_group);
 
-	disable_irq_nosync(OCTEON_IRQ_WORKQ0 + pow_receive_group);
-
 	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
-		union cvmx_sso_wq_int_thrx int_thr;
-		union cvmx_sso_wq_int_pc int_pc;
 		union cvmx_sso_cfg sso_cfg;
 		union cvmx_fpa_fpfx_marks fpa_marks;
 		int i;
@@ -431,28 +463,6 @@ void cvm_oct_rx_initialize(int num_wqe)
 		sso_cfg.s.rwq_byp_dis = 0;
 		sso_cfg.s.rwio_byp_dis = 0;
 		cvmx_write_csr(CVMX_SSO_CFG, sso_cfg.u64);
-
-		int_thr.u64 = 0;
-		int_thr.s.tc_en = 1;
-		int_thr.s.tc_thr = 1;
-		/* Enable POW interrupt when our port has at least one packet */
-		cvmx_write_csr(CVMX_SSO_WQ_INT_THRX(pow_receive_group), int_thr.u64);
-
-		int_pc.u64 = 0;
-		int_pc.s.pc_thr = 5;
-		cvmx_write_csr(CVMX_SSO_WQ_INT_PC, int_pc.u64);
-	} else {
-		union cvmx_pow_wq_int_thrx int_thr;
-		union cvmx_pow_wq_int_pc int_pc;
-		int_thr.u64 = 0;
-		int_thr.s.tc_en = 1;
-		int_thr.s.tc_thr = 1;
-		/* Enable POW interrupt when our port has at least one packet */
-		cvmx_write_csr(CVMX_POW_WQ_INT_THRX(pow_receive_group), int_thr.u64);
-
-		int_pc.u64 = 0;
-		int_pc.s.pc_thr = 5;
-		cvmx_write_csr(CVMX_POW_WQ_INT_PC, int_pc.u64);
 	}
 
 	/* Scheduld NAPI now.  This will indirectly enable interrupts. */
-- 
1.7.0

