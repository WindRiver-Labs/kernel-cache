From ac2c2dacf436ed0ad3379f87fa4acb77ace00f4c Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Fri, 11 Nov 2011 14:45:21 -0800
Subject: [PATCH 150/238] MIPS: Octeon: Add simple Octeon IPI infrastructure

Source: Cavium SDK 2.2-414

This will allow simple messages to be sent without taking any locks.

Signed-off-by: David Daney <david.daney@cavium.com>
Integrated-by: Yang Shi <yang.shi@windriver.com>
---
 arch/mips/cavium-octeon/smp.c         |   92 +++++++++++++++++++++++++++++----
 arch/mips/include/asm/octeon/octeon.h |    5 ++
 2 files changed, 87 insertions(+), 10 deletions(-)

diff --git a/arch/mips/cavium-octeon/smp.c b/arch/mips/cavium-octeon/smp.c
index fd2a662..6277c33 100644
--- a/arch/mips/cavium-octeon/smp.c
+++ b/arch/mips/cavium-octeon/smp.c
@@ -43,14 +43,81 @@ extern void octeon_hotplug_entry(void);
 #endif
 struct cvmx_app_hotplug_global *octeon_hotplug_global_ptr;
 
+static void octeon_reschedule_self(void)
+{
+	/* Do nothing. */
+}
+
+static void octeon_icache_flush(void)
+{
+	asm volatile ("synci 0($0)\n");
+}
+
+static octeon_message_fn_t  octeon_message_functions[8] = {
+	octeon_reschedule_self,
+	smp_call_function_interrupt,
+	octeon_icache_flush,
+};
+
+static  int octeon_message_free_mask = 0xf8;
+static DEFINE_SPINLOCK(octeon_message_functions_lock);
+
+int octeon_request_ipi_handler(octeon_message_fn_t fn)
+{
+	int i;
+	int message;
+	spin_lock(&octeon_message_functions_lock);
+
+	for (i = 0; i < ARRAY_SIZE(octeon_message_functions); i++) {
+		message = (1 << i);
+		if (message & octeon_message_free_mask) {
+			/* found a slot. */
+			octeon_message_free_mask ^= message;
+			octeon_message_functions[i] = fn;
+			goto out;
+		}
+	}
+	message = -ENOMEM;
+out:
+	spin_unlock(&octeon_message_functions_lock);
+	return message;
+}
+EXPORT_SYMBOL(octeon_request_ipi_handler);
+
+void octeon_release_ipi_handler(int action)
+{
+	int i;
+	int message;
+	spin_lock(&octeon_message_functions_lock);
+
+	for (i = 0; i < ARRAY_SIZE(octeon_message_functions); i++) {
+		message = (1 << i);
+		if (message == action) {
+			octeon_message_functions[i] = NULL;
+			octeon_message_free_mask |= message;
+			goto out;
+		}
+	}
+	pr_err("octeon_release_ipi_handler: Unknown action: %x\n", action);
+out:
+	spin_unlock(&octeon_message_functions_lock);
+}
+EXPORT_SYMBOL(octeon_release_ipi_handler);
+
 #ifndef CONFIG_WRHV
 static irqreturn_t mailbox_interrupt(int irq, void *dev_id)
 {
-	const int coreid = cvmx_get_core_num();
-	uint64_t action;
+	u64 mbox_clrx = CVMX_CIU_MBOX_CLRX(cvmx_get_core_num());
+	u64 action;
+	int i;
+
+	/* Make sure the function array initialization remains correct. */
+	BUILD_BUG_ON(SMP_RESCHEDULE_YOURSELF != (1 << 0));
+	BUILD_BUG_ON(SMP_CALL_FUNCTION       != (1 << 1));
+	BUILD_BUG_ON(SMP_ICACHE_FLUSH        != (1 << 2));
 
 	/* Load the mailbox register to figure out what we're supposed to do */
-	action = cvmx_read_csr(CVMX_CIU_MBOX_CLRX(coreid));
+	action = cvmx_read_csr(mbox_clrx);
 
 	if (OCTEON_IS_MODEL(OCTEON_CN68XX))
 		action &= 0xff;
@@ -58,14 +125,18 @@ static irqreturn_t mailbox_interrupt(int irq, void *dev_id)
 		action &= 0xffff;
 
 	/* Clear the mailbox to clear the interrupt */
-	cvmx_write_csr(CVMX_CIU_MBOX_CLRX(coreid), action);
+	cvmx_write_csr(mbox_clrx, action);
 
-	if (action & SMP_CALL_FUNCTION)
-		smp_call_function_interrupt();
+	for (i = 0; i < ARRAY_SIZE(octeon_message_functions) && action;) {
+		if (action & 1) {
+			octeon_message_fn_t fn = octeon_message_functions[i];
+			if (fn)
+				fn();
+		}
+		action >>= 1;
+		i++;
+	}
 
-	/* Check if we've been told to flush the icache */
-	if (action & SMP_ICACHE_FLUSH)
-		asm volatile ("synci 0($0)\n");
 	return IRQ_HANDLED;
 }
 #endif
@@ -92,6 +163,7 @@ void octeon_send_ipi_single(int cpu, unsigned int action)
 	cvmx_write_csr(CVMX_CIU_MBOX_SETX(coreid), action);
 #endif
 }
+EXPORT_SYMBOL(octeon_send_ipi_single);
 
 static inline void octeon_send_ipi_mask(const struct cpumask *mask,
 					unsigned int action)
diff --git a/arch/mips/include/asm/octeon/octeon.h b/arch/mips/include/asm/octeon/octeon.h
index c57ed21..4c55eda 100644
--- a/arch/mips/include/asm/octeon/octeon.h
+++ b/arch/mips/include/asm/octeon/octeon.h
@@ -283,4 +283,9 @@ extern int octeon_coreid_for_cpu(int);
 typedef void (*octeon_irq_ip4_handler_t)(void);
 void octeon_irq_set_ip4_handler(octeon_irq_ip4_handler_t);
 
+typedef void (*octeon_message_fn_t)(void);
+int octeon_request_ipi_handler(octeon_message_fn_t fn);
+void octeon_send_ipi_single(int cpu, unsigned int action);
+void octeon_release_ipi_handler(int action);
+
 #endif /* __ASM_OCTEON_OCTEON_H */
-- 
1.7.0

