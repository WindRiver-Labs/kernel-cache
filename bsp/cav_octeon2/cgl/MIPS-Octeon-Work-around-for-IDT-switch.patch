From 0de31f9233162fb78e8e194352891daedbea69d5 Mon Sep 17 00:00:00 2001
From: Venkat Subbiah <vsubbiah@caviumnetworks.com>
Date: Wed, 4 May 2011 15:15:27 -0700
Subject: [PATCH 037/238] MIPS: Octeon: Work around for IDT switch.

Source: Cavium SDK 2.1.0-407

The BDF assigned to the upstream switch port needs to be different
from the RC's BDF.

Signed-off-by: Venkat Subbiah <vsubbiah@caviumnetworks.com>
Integrated-by: Phil Staub <Phil.Staub@windriver.com>
---
 arch/mips/pci/pcie-octeon.c |   44 +++++++++++++++++++++++++++++++++---------
 1 files changed, 34 insertions(+), 10 deletions(-)

diff --git a/arch/mips/pci/pcie-octeon.c b/arch/mips/pci/pcie-octeon.c
index 24755a2..7fc0a2e 100644
--- a/arch/mips/pci/pcie-octeon.c
+++ b/arch/mips/pci/pcie-octeon.c
@@ -30,6 +30,7 @@ int disable;
 module_param(disable, int, S_IRUGO);
 
 static int enable_pcie_14459_war;
+static int enable_pcie_bus_num_war[2];
 #ifdef OCT_PCIE_DBG
 #define oct_pcie_dbg(fmt, ...) printk(fmt, ##__VA_ARGS__)
 #else
@@ -156,16 +157,20 @@ static inline int octeon_pcie_read_config(int pcie_port, struct pci_bus *bus,
 	/* For the top level bus make sure our hardware bus number matches the
 		software one */
 	if (bus->parent == NULL) {
-		cvmx_pciercx_cfg006_t pciercx_cfg006;
-		pciercx_cfg006.u32 = cvmx_pcie_cfgx_read(pcie_port,
-			CVMX_PCIERCX_CFG006(pcie_port));
-		if (pciercx_cfg006.s.pbnum != bus_number) {
-			pciercx_cfg006.s.pbnum = bus_number;
-			pciercx_cfg006.s.sbnum = bus_number;
-			pciercx_cfg006.s.subbnum = bus_number;
-			cvmx_pcie_cfgx_write(pcie_port,
-				CVMX_PCIERCX_CFG006(pcie_port),
-				pciercx_cfg006.u32);
+		if (enable_pcie_bus_num_war[pcie_port])
+			bus_number = 0;
+		else {
+			cvmx_pciercx_cfg006_t pciercx_cfg006;
+			pciercx_cfg006.u32 = cvmx_pcie_cfgx_read(pcie_port,
+					     CVMX_PCIERCX_CFG006(pcie_port));
+			if (pciercx_cfg006.s.pbnum != bus_number) {
+				pciercx_cfg006.s.pbnum = bus_number;
+				pciercx_cfg006.s.sbnum = bus_number;
+				pciercx_cfg006.s.subbnum = bus_number;
+				cvmx_pcie_cfgx_write(pcie_port,
+					    CVMX_PCIERCX_CFG006(pcie_port),
+					    pciercx_cfg006.u32);
+			}
 		}
 	}
 
@@ -340,6 +345,9 @@ static inline int octeon_pcie_write_config(int pcie_port, struct pci_bus *bus,
 {
 	int bus_number = bus->number;
 
+	if ((bus->parent == NULL) && (enable_pcie_bus_num_war[pcie_port]))
+		bus_number = 0;
+
 	oct_pcie_dbg("pcie_cfg_wr port=%d b=%d devfn=0x%03x"
 		" reg=0x%03x size=%d val=%08x\n", pcie_port, bus_number, devfn,
 		reg, size, val);
@@ -451,6 +459,14 @@ static struct pci_controller octeon_dummy_controller = {
 	.io_resource = &octeon_dummy_io_resource,
 };
 
+static int device_needs_bus_num_war(uint32_t deviceid)
+{
+#define IDT_VENDOR_ID 0x111d
+
+	if ((deviceid  & 0xffff) == IDT_VENDOR_ID)
+		return 1;
+	return 0;
+}
 
 /**
  * Initialize the Octeon PCIe controllers
@@ -533,6 +549,7 @@ static int __init octeon_pcie_setup(void)
 		}
 		result = cvmx_pcie_rc_initialize(0);
 		if (result == 0) {
+			uint32_t device0;
 			/* Memory offsets are physical addresses */
 			octeon_pcie0_controller.mem_offset =
 				cvmx_pcie_get_mem_base_address(0);
@@ -563,6 +580,9 @@ static int __init octeon_pcie_setup(void)
 				cvmx_pcie_get_io_size(0) - 1;
 			msleep(100); /* Some devices need extra time */
 			register_pci_controller(&octeon_pcie0_controller);
+			device0 = cvmx_pcie_config_read32(0, 0, 0, 0, 0);
+			enable_pcie_bus_num_war[0] =
+				device_needs_bus_num_war(device0);
 		}
 	} else {
 		pr_notice("PCIe: Port 0 in endpoint mode, skipping.\n");
@@ -603,6 +623,7 @@ static int __init octeon_pcie_setup(void)
 		}
 		result = cvmx_pcie_rc_initialize(1);
 		if (result == 0) {
+			uint32_t device0;
 			/* Memory offsets are physical addresses */
 			octeon_pcie1_controller.mem_offset =
 				cvmx_pcie_get_mem_base_address(1);
@@ -647,6 +668,9 @@ static int __init octeon_pcie_setup(void)
 				cvmx_pcie_get_io_size(1) - 1;
 			msleep(100); /* Some devices need extra time */
 			register_pci_controller(&octeon_pcie1_controller);
+			device0 = cvmx_pcie_config_read32(1, 0, 0, 0, 0);
+			enable_pcie_bus_num_war[1] =
+				device_needs_bus_num_war(device0);
 		}
 		octeon_pci_dma_init();
 	} else {
-- 
1.7.0

