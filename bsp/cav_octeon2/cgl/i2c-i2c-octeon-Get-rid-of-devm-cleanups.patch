From f6541e961407ad6a7cab13ea4c1afe0e3cca7713 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Thu, 19 Apr 2012 10:33:35 +0800
Subject: [PATCH 223/238] i2c: i2c-octeon: Get rid of devm* cleanups.

Source: Cavium SDK 2.3-427

They are done automatically, git rid of explicit cleanup of resources
on failure.
Use "clock-frequency" in addition to "clock-rate" OF property.
"clock-frequency" is the official binding.

Signed-off-by: David Daney <david.daney@cavium.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/i2c/busses/i2c-octeon.c |   43 +++++++++++++-------------------------
 1 files changed, 15 insertions(+), 28 deletions(-)

diff --git a/drivers/i2c/busses/i2c-octeon.c b/drivers/i2c/busses/i2c-octeon.c
index 66bc03f..5c397b0 100644
--- a/drivers/i2c/busses/i2c-octeon.c
+++ b/drivers/i2c/busses/i2c-octeon.c
@@ -78,9 +78,7 @@ struct octeon_i2c {
 	int irq;
 	int twsi_freq;
 	int sys_freq;
-	resource_size_t twsi_phys;
 	void __iomem *twsi_base;
-	resource_size_t regsize;
 	struct device *dev;
 	int broken_irq_mode;
 	bool octeon_i2c_hlc_enabled;
@@ -934,49 +932,51 @@ static int __devinit octeon_i2c_probe(struct platform_device *pdev)
 	if (res_mem == NULL) {
 		dev_err(i2c->dev, "found no memory resource\n");
 		result = -ENXIO;
-		goto fail_region;
+		goto out;
 	}
-	i2c->twsi_phys = res_mem->start;
-	i2c->regsize = resource_size(res_mem);
 
-	data = of_get_property(pdev->dev.of_node, "clock-rate", &len);
+	data = of_get_property(pdev->dev.of_node, "clock-frequency", &len);
+	if (!data || len != sizeof(*data))
+		data = of_get_property(pdev->dev.of_node, "clock-rate", &len);
 	if (data && len == sizeof(*data)) {
 		i2c->twsi_freq = be32_to_cpup(data);
 	} else {
-		dev_err(i2c->dev, "no I2C 'clock-rate' property\n");
+		dev_err(i2c->dev,
+			"no I2C 'clock-rate' or 'clock-frequency' property\n");
 		result = -ENXIO;
-		goto fail_region;
+		goto out;
 	}
 
 	i2c->sys_freq = octeon_get_io_clock_rate();
 
-	if (!devm_request_mem_region(&pdev->dev, i2c->twsi_phys, i2c->regsize,
+	if (!devm_request_mem_region(&pdev->dev, res_mem->start, resource_size(res_mem),
 				     res_mem->name)) {
 		dev_err(i2c->dev, "request_mem_region failed\n");
-		goto fail_region;
+		goto out;
 	}
-	i2c->twsi_base = ioremap(i2c->twsi_phys, i2c->regsize);
+	i2c->twsi_base = devm_ioremap(&pdev->dev, res_mem->start, resource_size(res_mem));
 
 	init_waitqueue_head(&i2c->queue);
 
 	i2c->irq = irq;
 
-	result = request_irq(i2c->irq, octeon_i2c_isr, 0, DRV_NAME, i2c);
+	result = devm_request_irq(&pdev->dev, i2c->irq,
+				  octeon_i2c_isr, 0, DRV_NAME, i2c);
 	if (result < 0) {
 		dev_err(i2c->dev, "failed to attach interrupt\n");
-		goto fail_irq;
+		goto out;
 	}
 
 	result = octeon_i2c_initlowlevel(i2c);
 	if (result) {
 		dev_err(i2c->dev, "init low level failed\n");
-		goto  fail_add;
+		goto  out;
 	}
 
 	result = octeon_i2c_setclock(i2c);
 	if (result) {
 		dev_err(i2c->dev, "clock init failed\n");
-		goto  fail_add;
+		goto  out;
 	}
 
 	i2c->adap = octeon_i2c_ops;
@@ -1000,15 +1000,6 @@ static int __devinit octeon_i2c_probe(struct platform_device *pdev)
 
 fail_add:
 	platform_set_drvdata(pdev, NULL);
-	free_irq(i2c->irq, i2c);
-
-fail_irq:
-	iounmap(i2c->twsi_base);
-	devm_release_mem_region(&pdev->dev, i2c->twsi_phys, i2c->regsize);
-
-fail_region:
-	devm_kfree(&pdev->dev, i2c);
-
 out:
 	return result;
 };
@@ -1019,10 +1010,6 @@ static int __devexit octeon_i2c_remove(struct platform_device *pdev)
 
 	i2c_del_adapter(&i2c->adap);
 	platform_set_drvdata(pdev, NULL);
-	free_irq(i2c->irq, i2c);
-	iounmap(i2c->twsi_base);
-	devm_release_mem_region(&pdev->dev, i2c->twsi_phys, i2c->regsize);
-	devm_kfree(&pdev->dev, i2c);
 	return 0;
 };
 
-- 
1.7.0

