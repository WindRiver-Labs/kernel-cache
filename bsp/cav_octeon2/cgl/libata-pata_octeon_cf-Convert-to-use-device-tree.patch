From 2534e41d3b1e6de9f231028afa10b8cbac26909b Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Fri, 11 Nov 2011 10:58:24 -0800
Subject: [PATCH 122/238] libata: pata_octeon_cf: Convert to use device tree

Source: Cavium SDK 2.2-414

Signed-off-by: David Daney <david.daney@cavium.com>
Integrated-by: Yang Shi <yang.shi@windriver.com>
---
 arch/mips/cavium-octeon/octeon-platform.c |    3 +
 arch/mips/include/asm/octeon/octeon.h     |   10 --
 drivers/ata/pata_octeon_cf.c              |  229 +++++++++++++++++++----------
 3 files changed, 154 insertions(+), 88 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-platform.c b/arch/mips/cavium-octeon/octeon-platform.c
index a91e6d2..6d8389d 100644
--- a/arch/mips/cavium-octeon/octeon-platform.c
+++ b/arch/mips/cavium-octeon/octeon-platform.c
@@ -23,6 +23,7 @@
 #include <asm/octeon/cvmx-helper.h>
 #include <asm/octeon/cvmx-helper-board.h>
 
+#if 0
 static struct octeon_cf_data octeon_cf_data;
 
 static int __init octeon_cf_device_init(void)
@@ -125,6 +126,8 @@ out:
 }
 device_initcall(octeon_cf_device_init);
 
+#endif
+
 /* Octeon Random Number Generator.  */
 static int __init octeon_rng_device_init(void)
 {
diff --git a/arch/mips/include/asm/octeon/octeon.h b/arch/mips/include/asm/octeon/octeon.h
index 19933f6..0b1ac9d 100644
--- a/arch/mips/include/asm/octeon/octeon.h
+++ b/arch/mips/include/asm/octeon/octeon.h
@@ -226,15 +226,6 @@ union octeon_cvmemctl {
 		uint64_t lmemsz:6;
 	} s;
 };
-
-struct octeon_cf_data {
-	unsigned long	base_region_bias;
-	unsigned int	base_region;	/* The chip select region used by CF */
-	int		is16bit;	/* 0 - 8bit, !0 - 16bit */
-	int		dma_engine;	/* -1 for no DMA */
-	void		*c0;
-};
-
 extern void octeon_write_lcd(const char *s);
 extern void octeon_check_cpu_bist(void);
 extern int octeon_get_boot_uart(void);
@@ -255,7 +246,6 @@ static inline void octeon_npi_write32(uint64_t address, uint32_t val)
 	cvmx_read64_uint32(address ^ 4);
 }
 
-
 /**
  * Read a 32bit value from the Octeon NPI register space
  *
diff --git a/drivers/ata/pata_octeon_cf.c b/drivers/ata/pata_octeon_cf.c
index 8cf0695..3f6fcf2 100644
--- a/drivers/ata/pata_octeon_cf.c
+++ b/drivers/ata/pata_octeon_cf.c
@@ -5,7 +5,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 2005 - 2009 Cavium Networks
+ * Copyright (C) 2005 - 2011 Cavium Networks
  * Copyright (C) 2008 Wind River Systems
  */
 
@@ -14,6 +14,8 @@
 #include <linux/libata.h>
 #include <linux/hrtimer.h>
 #include <linux/irq.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
 #include <linux/slab.h>
 #include <linux/platform_device.h>
 #include <scsi/scsi_host.h>
@@ -34,15 +36,25 @@
  */
 
 #define DRV_NAME	"pata_octeon_cf"
-#define DRV_VERSION	"2.1"
+#define DRV_VERSION	"2.2"
 
 /* Poll interval in nS. */
 #define OCTEON_CF_BUSY_POLL_INTERVAL 500000
 
+#define DMA_CFG 0
+#define DMA_TIM 0x20
+#define DMA_INT 0x38
+#define DMA_INT_EN 0x50
+
 struct octeon_cf_port {
 	struct hrtimer delayed_finish;
 	struct ata_port *ap;
 	int dma_finished;
+	void		*c0;
+	unsigned int cs0;
+	unsigned int cs1;
+	bool is_true_ide;
+	u64 dma_base;
 };
 
 static struct scsi_host_template octeon_cf_sht = {
@@ -115,9 +127,8 @@ static void octeon_cf_set_boot_reg_cfg(int cs, unsigned int multiplier)
  */
 static void octeon_cf_set_piomode(struct ata_port *ap, struct ata_device *dev)
 {
-	struct octeon_cf_data *ocd = ap->dev->platform_data;
+	struct octeon_cf_port *cf_port = ap->private_data;
 	union cvmx_mio_boot_reg_timx reg_tim;
-	int cs = ocd->base_region;
 	int T;
 	struct ata_timing timing;
 
@@ -164,15 +175,15 @@ static void octeon_cf_set_piomode(struct ata_port *ap, struct ata_device *dev)
 	if (pause)
 		pause--;
 
-	octeon_cf_set_boot_reg_cfg(cs, div);
-	if (ocd->dma_engine >= 0)
+	octeon_cf_set_boot_reg_cfg(cf_port->cs0, div);
+	if (cf_port->is_true_ide)
 		/* True IDE mode, program both chip selects.  */
-		octeon_cf_set_boot_reg_cfg(cs + 1, div);
+		octeon_cf_set_boot_reg_cfg(cf_port->cs1, div);
 
 
 	use_iordy = ata_pio_need_iordy(dev);
 
-	reg_tim.u64 = cvmx_read_csr(CVMX_MIO_BOOT_REG_TIMX(cs));
+	reg_tim.u64 = cvmx_read_csr(CVMX_MIO_BOOT_REG_TIMX(cf_port->cs0));
 	/* Disable page mode */
 	reg_tim.s.pagem = 0;
 	/* Enable dynamic timing */
@@ -201,15 +212,15 @@ static void octeon_cf_set_piomode(struct ata_port *ap, struct ata_device *dev)
 	reg_tim.s.adr = 0;
 
 	/* Program the bootbus region timing for the data port chip select. */
-	cvmx_write_csr(CVMX_MIO_BOOT_REG_TIMX(cs), reg_tim.u64);
-	if (ocd->dma_engine >= 0)
+	cvmx_write_csr(CVMX_MIO_BOOT_REG_TIMX(cf_port->cs0), reg_tim.u64);
+	if (cf_port->is_true_ide)
 		/* True IDE mode, program both chip selects.  */
-		cvmx_write_csr(CVMX_MIO_BOOT_REG_TIMX(cs + 1), reg_tim.u64);
+		cvmx_write_csr(CVMX_MIO_BOOT_REG_TIMX(cf_port->cs1), reg_tim.u64);
 }
 
 static void octeon_cf_set_dmamode(struct ata_port *ap, struct ata_device *dev)
 {
-	struct octeon_cf_data *ocd = dev->link->ap->dev->platform_data;
+	struct octeon_cf_port *cf_port = ap->private_data;
 	union cvmx_mio_boot_dma_timx dma_tim;
 	unsigned int oe_a;
 	unsigned int oe_n;
@@ -268,9 +279,7 @@ static void octeon_cf_set_dmamode(struct ata_port *ap, struct ata_device *dev)
 		 dma_tim.s.oe_n, dma_tim.s.oe_a, dma_tim.s.dmack_s,
 		 dma_tim.s.dmack_h, dma_tim.s.dmarq, dma_tim.s.pause);
 
-	cvmx_write_csr(CVMX_MIO_BOOT_DMA_TIMX(ocd->dma_engine),
-		       dma_tim.u64);
-
+	cvmx_write_csr(cf_port->dma_base + DMA_TIM, dma_tim.u64);
 }
 
 /**
@@ -555,7 +564,7 @@ static void octeon_cf_dma_setup(struct ata_queued_cmd *qc)
  */
 static void octeon_cf_dma_start(struct ata_queued_cmd *qc)
 {
-	struct octeon_cf_data *ocd = qc->ap->dev->platform_data;
+	struct octeon_cf_port *cf_port = qc->ap->private_data;
 	union cvmx_mio_boot_dma_cfgx mio_boot_dma_cfg;
 	union cvmx_mio_boot_dma_intx mio_boot_dma_int;
 	struct scatterlist *sg;
@@ -571,12 +580,10 @@ static void octeon_cf_dma_start(struct ata_queued_cmd *qc)
 	 */
 	mio_boot_dma_int.u64 = 0;
 	mio_boot_dma_int.s.done = 1;
-	cvmx_write_csr(CVMX_MIO_BOOT_DMA_INTX(ocd->dma_engine),
-		       mio_boot_dma_int.u64);
+	cvmx_write_csr(cf_port->dma_base + DMA_INT, mio_boot_dma_int.u64);
 
 	/* Enable the interrupt.  */
-	cvmx_write_csr(CVMX_MIO_BOOT_DMA_INT_ENX(ocd->dma_engine),
-		       mio_boot_dma_int.u64);
+	cvmx_write_csr(cf_port->dma_base + DMA_INT_EN, mio_boot_dma_int.u64);
 
 	/* Set the direction of the DMA */
 	mio_boot_dma_cfg.u64 = 0;
@@ -605,8 +612,7 @@ static void octeon_cf_dma_start(struct ata_queued_cmd *qc)
 		(mio_boot_dma_cfg.s.rw) ? "write" : "read", sg->length,
 		(void *)(unsigned long)mio_boot_dma_cfg.s.adr);
 
-	cvmx_write_csr(CVMX_MIO_BOOT_DMA_CFGX(ocd->dma_engine),
-		       mio_boot_dma_cfg.u64);
+	cvmx_write_csr(cf_port->dma_base + DMA_CFG, mio_boot_dma_cfg.u64);
 }
 
 /**
@@ -619,10 +625,9 @@ static unsigned int octeon_cf_dma_finished(struct ata_port *ap,
 					struct ata_queued_cmd *qc)
 {
 	struct ata_eh_info *ehi = &ap->link.eh_info;
-	struct octeon_cf_data *ocd = ap->dev->platform_data;
+	struct octeon_cf_port *cf_port = ap->private_data;
 	union cvmx_mio_boot_dma_cfgx dma_cfg;
 	union cvmx_mio_boot_dma_intx dma_int;
-	struct octeon_cf_port *cf_port;
 	u8 status;
 
 	VPRINTK("ata%u: protocol %d task_state %d\n",
@@ -632,9 +637,7 @@ static unsigned int octeon_cf_dma_finished(struct ata_port *ap,
 	if (ap->hsm_task_state != HSM_ST_LAST)
 		return 0;
 
-	cf_port = ap->private_data;
-
-	dma_cfg.u64 = cvmx_read_csr(CVMX_MIO_BOOT_DMA_CFGX(ocd->dma_engine));
+	dma_cfg.u64 = cvmx_read_csr(cf_port->dma_base + DMA_CFG);
 	if (dma_cfg.s.size != 0xfffff) {
 		/* Error, the transfer was not complete.  */
 		qc->err_mask |= AC_ERR_HOST_BUS;
@@ -644,15 +647,15 @@ static unsigned int octeon_cf_dma_finished(struct ata_port *ap,
 	/* Stop and clear the dma engine.  */
 	dma_cfg.u64 = 0;
 	dma_cfg.s.size = -1;
-	cvmx_write_csr(CVMX_MIO_BOOT_DMA_CFGX(ocd->dma_engine), dma_cfg.u64);
+	cvmx_write_csr(cf_port->dma_base + DMA_CFG, dma_cfg.u64);
 
 	/* Disable the interrupt.  */
 	dma_int.u64 = 0;
-	cvmx_write_csr(CVMX_MIO_BOOT_DMA_INT_ENX(ocd->dma_engine), dma_int.u64);
+	cvmx_write_csr(cf_port->dma_base + DMA_INT_EN, dma_int.u64);
 
 	/* Clear the DMA complete status */
 	dma_int.s.done = 1;
-	cvmx_write_csr(CVMX_MIO_BOOT_DMA_INTX(ocd->dma_engine), dma_int.u64);
+	cvmx_write_csr(cf_port->dma_base + DMA_INT, dma_int.u64);
 
 	status = ap->ops->sff_check_status(ap);
 
@@ -685,20 +688,15 @@ static irqreturn_t octeon_cf_interrupt(int irq, void *dev_instance)
 		struct ata_queued_cmd *qc;
 		union cvmx_mio_boot_dma_intx dma_int;
 		union cvmx_mio_boot_dma_cfgx dma_cfg;
-		struct octeon_cf_data *ocd;
 
 		ap = host->ports[i];
-		ocd = ap->dev->platform_data;
+		cf_port = ap->private_data;
 
 		if (ap->flags & ATA_FLAG_DISABLED)
 			continue;
 
-		ocd = ap->dev->platform_data;
-		cf_port = ap->private_data;
-		dma_int.u64 =
-			cvmx_read_csr(CVMX_MIO_BOOT_DMA_INTX(ocd->dma_engine));
-		dma_cfg.u64 =
-			cvmx_read_csr(CVMX_MIO_BOOT_DMA_CFGX(ocd->dma_engine));
+		dma_int.u64 = cvmx_read_csr(cf_port->dma_base + DMA_INT);
+		dma_cfg.u64 = cvmx_read_csr(cf_port->dma_base + DMA_CFG);
 
 		qc = ata_qc_from_tag(ap, ap->link.active_tag);
 
@@ -728,8 +726,7 @@ static irqreturn_t octeon_cf_interrupt(int irq, void *dev_instance)
 				/* Clear DMA irq. */
 				dma_int.u64 = 0;
 				dma_int.s.done = 1;
-				cvmx_write_csr(CVMX_MIO_BOOT_DMA_INTX(ocd->dma_engine),
-					       dma_int.u64);
+				cvmx_write_csr(cf_port->dma_base + DMA_INT, dma_int.u64);
 				hrtimer_start_range_ns(&cf_port->delayed_finish,
 						       ns_to_ktime(OCTEON_CF_BUSY_POLL_INTERVAL),
 						       OCTEON_CF_BUSY_POLL_INTERVAL / 5,
@@ -864,46 +861,114 @@ static int __devinit octeon_cf_probe(struct platform_device *pdev)
 {
 	struct resource *res_cs0, *res_cs1;
 
+	bool is_16bit;
+	const __be32 *cs_num;
+	struct property *reg_prop;
+	int n_addr, n_size, reg_len;
+	struct device_node *node;
+	const void *prop;
 	void __iomem *cs0;
 	void __iomem *cs1 = NULL;
 	struct ata_host *host;
 	struct ata_port *ap;
-	struct octeon_cf_data *ocd;
 	int irq = 0;
 	irq_handler_t irq_handler = NULL;
 	void __iomem *base;
 	struct octeon_cf_port *cf_port;
 	unsigned long irq_flags = 0;
+	int rv = -ENOMEM;
 
-	res_cs0 = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-
-	if (!res_cs0)
+	node = pdev->dev.of_node;
+	if (node == NULL)
 		return -EINVAL;
 
-	ocd = pdev->dev.platform_data;
+	cf_port = kzalloc(sizeof(*cf_port), GFP_KERNEL);
+	if (!cf_port)
+		return -ENOMEM;
+
+	cf_port->is_true_ide = (of_find_property(node, "cavium,true-ide", NULL) != NULL);
 
-	cs0 = devm_ioremap_nocache(&pdev->dev, res_cs0->start,
-				   resource_size(res_cs0));
+	prop = of_get_property(node, "cavium,bus-width", NULL);
+	if (prop) {
+		is_16bit = (be32_to_cpup(prop) == 16);
+	} else {
+		is_16bit = false;
+	}
 
-	if (!cs0)
-		return -ENOMEM;
+	n_addr = of_n_addr_cells(node);
+	n_size = of_n_size_cells(node);
+
+	reg_prop = of_find_property(node, "reg", &reg_len);
+	if (!reg_prop || reg_len < sizeof(__be32)) {
+		rv = -EINVAL;
+		goto free_cf_port;
+	}
+	cs_num = reg_prop->value;
+	cf_port->cs0 = be32_to_cpup(cs_num);
+
+	if (cf_port->is_true_ide) {
+		struct device_node *dma_node;
+		dma_node = of_parse_phandle(node, "cavium,dma-engine-handle", 0);
+		if (dma_node) {
+			struct platform_device *dma_dev;
+			dma_dev = of_find_device_by_node(dma_node);
+			if (dma_dev) {
+				struct resource *res_dma;
+				int i;
+				res_dma = platform_get_resource(dma_dev, IORESOURCE_MEM, 0);
+				if (!res_dma) {
+					of_node_put(dma_node);
+					rv = -EINVAL;
+					goto free_cf_port;
+				}
+				cf_port->dma_base = (u64)devm_ioremap_nocache(&pdev->dev, res_dma->start,
+									 resource_size(res_dma));
 
-	/* Determine from availability of DMA if True IDE mode or not */
-	if (ocd->dma_engine >= 0) {
+				if (!cf_port->dma_base) {
+					of_node_put(dma_node);
+					rv = -EINVAL;
+					goto free_cf_port;
+				}
+ 
+				irq_handler = octeon_cf_interrupt;
+				i = platform_get_irq(dma_dev, 0);
+				if (i > 0)
+					irq = i;
+			}
+			of_node_put(dma_node);
+		}
 		res_cs1 = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-		if (!res_cs1)
-			return -EINVAL;
+		if (!res_cs1) {
+			rv = -EINVAL;
+			goto free_cf_port;
+		}
 
 		cs1 = devm_ioremap_nocache(&pdev->dev, res_cs1->start,
-					   resource_size(res_cs1));
+					   res_cs1->end - res_cs1->start + 1);
 
 		if (!cs1)
-			return -ENOMEM;
+			goto free_cf_port;
+
+		if (reg_len < (n_addr + n_size + 1) * sizeof(__be32)) {
+			rv = -EINVAL;
+			goto free_cf_port;
+		}
+		cs_num += n_addr + n_size;
+		cf_port->cs1 = be32_to_cpup(cs_num);
 	}
 
-	cf_port = kzalloc(sizeof(*cf_port), GFP_KERNEL);
-	if (!cf_port)
-		return -ENOMEM;
+	res_cs0 = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	if (!res_cs0) {
+		rv = -EINVAL;
+		goto free_cf_port;
+	}
+
+	cs0 = devm_ioremap_nocache(&pdev->dev, res_cs0->start,
+				   resource_size(res_cs0));
+
+	if (!cs0)
+		goto free_cf_port;
 
 	/* allocate host */
 	host = ata_host_alloc(&pdev->dev, 1);
@@ -912,22 +977,23 @@ static int __devinit octeon_cf_probe(struct platform_device *pdev)
 
 	ap = host->ports[0];
 	ap->private_data = cf_port;
+	pdev->dev.platform_data = cf_port;
 	cf_port->ap = ap;
 	ap->ops = &octeon_cf_ops;
 	ap->pio_mask = ATA_PIO6;
 	ap->flags |= ATA_FLAG_MMIO | ATA_FLAG_NO_LEGACY
 		  | ATA_FLAG_NO_ATAPI | ATA_FLAG_PIO_POLLING;
 
-	base = cs0 + ocd->base_region_bias;
-	if (!ocd->is16bit) {
+	if (!is_16bit) {
+		base = cs0 + 0x800;
 		ap->ioaddr.cmd_addr	= base;
 		ata_sff_std_ports(&ap->ioaddr);
 
 		ap->ioaddr.altstatus_addr = base + 0xe;
 		ap->ioaddr.ctl_addr	= base + 0xe;
 		octeon_cf_ops.sff_data_xfer = octeon_cf_data_xfer8;
-	} else if (cs1) {
-		/* Presence of cs1 indicates True IDE mode.  */
+	} else if (cf_port->is_true_ide) {
+		base = cs0;
 		ap->ioaddr.cmd_addr	= base + (ATA_REG_CMD << 1) + 1;
 		ap->ioaddr.data_addr	= base + (ATA_REG_DATA << 1);
 		ap->ioaddr.error_addr	= base + (ATA_REG_ERR << 1) + 1;
@@ -944,8 +1010,6 @@ static int __devinit octeon_cf_probe(struct platform_device *pdev)
 		octeon_cf_ops.sff_data_xfer = octeon_cf_data_xfer16;
 
 		ap->mwdma_mask	= enable_dma ? ATA_MWDMA4 : 0;
-		irq = platform_get_irq(pdev, 0);
-		irq_handler = octeon_cf_interrupt;
 
 		/* True IDE mode needs a timer to poll for not-busy.  */
 		hrtimer_init(&cf_port->delayed_finish, CLOCK_MONOTONIC,
@@ -953,6 +1017,7 @@ static int __devinit octeon_cf_probe(struct platform_device *pdev)
 		cf_port->delayed_finish.function = octeon_cf_delayed_finish;
 	} else {
 		/* 16 bit but not True IDE */
+		base = cs0 + 0x800;
 		octeon_cf_ops.sff_data_xfer	= octeon_cf_data_xfer16;
 		octeon_cf_ops.softreset		= octeon_cf_softreset16;
 		octeon_cf_ops.sff_check_status	= octeon_cf_check_status16;
@@ -966,15 +1031,15 @@ static int __devinit octeon_cf_probe(struct platform_device *pdev)
 		ap->ioaddr.ctl_addr	= base + 0xe;
 		ap->ioaddr.altstatus_addr = base + 0xe;
 	}
-	ocd->c0 = ap->ioaddr.ctl_addr;
+	cf_port->c0 = ap->ioaddr.ctl_addr;
 
 	ata_port_desc(ap, "cmd %p ctl %p", base, ap->ioaddr.ctl_addr);
 
 
 	dev_info(&pdev->dev, "version " DRV_VERSION" %d bit%s.\n",
-		 (ocd->is16bit) ? 16 : 8,
-		 (cs1) ? ", True IDE" : "");
-
+		 is_16bit ? 16 : 8,
+		 cf_port->is_true_ide ? ", True IDE" : "");
+ 
 #ifdef CONFIG_PREEMPT_HARDIRQS
 	irq_flags = IRQF_NODELAY;
 #endif
@@ -983,45 +1048,53 @@ static int __devinit octeon_cf_probe(struct platform_device *pdev)
 
 free_cf_port:
 	kfree(cf_port);
-	return -ENOMEM;
+	return rv;
 }
 
 static void octeon_cf_shutdown(struct device *dev)
 {
-	struct octeon_cf_data *ocd;
 	union cvmx_mio_boot_dma_cfgx dma_cfg;
 	union cvmx_mio_boot_dma_intx dma_int;
 
-	ocd = dev->platform_data;
+	struct octeon_cf_port *cf_port = dev->platform_data;
 
-	if (ocd->dma_engine >= 0) {
+	if (cf_port->dma_base) {
 		/* Stop and clear the dma engine.  */
 		dma_cfg.u64 = 0;
 		dma_cfg.s.size = -1;
-		cvmx_write_csr(CVMX_MIO_BOOT_DMA_CFGX(ocd->dma_engine), dma_cfg.u64);
+		cvmx_write_csr(cf_port->dma_base + DMA_CFG, dma_cfg.u64);
 
 		/* Disable the interrupt.  */
 		dma_int.u64 = 0;
-		cvmx_write_csr(CVMX_MIO_BOOT_DMA_INT_ENX(ocd->dma_engine), dma_int.u64);
+		cvmx_write_csr(cf_port->dma_base + DMA_INT_EN, dma_int.u64);
 
 		/* Clear the DMA complete status */
 		dma_int.s.done = 1;
-		cvmx_write_csr(CVMX_MIO_BOOT_DMA_INTX(ocd->dma_engine), dma_int.u64);
+		cvmx_write_csr(cf_port->dma_base + DMA_INT, dma_int.u64);
 
-		__raw_writeb(0, ocd->c0);
+		__raw_writeb(0, cf_port->c0);
 		udelay(20);
-		__raw_writeb(ATA_SRST, ocd->c0);
+		__raw_writeb(ATA_SRST, cf_port->c0);
 		udelay(20);
-		__raw_writeb(0, ocd->c0);
+		__raw_writeb(0, cf_port->c0);
 		mdelay(100);
 	}
 }
 
+static struct of_device_id octeon_cf_match[] = {
+	{
+		.compatible = "cavium,ebt3000-compact-flash",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, octeon_i2c_match);
+
 static struct platform_driver octeon_cf_driver = {
 	.probe		= octeon_cf_probe,
 	.driver		= {
 		.name	= DRV_NAME,
 		.owner	= THIS_MODULE,
+		.of_match_table = octeon_cf_match,
 		.shutdown = octeon_cf_shutdown
 	},
 };
-- 
1.7.0

