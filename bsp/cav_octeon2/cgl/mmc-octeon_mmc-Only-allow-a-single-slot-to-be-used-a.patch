From 935cc6a66a89ac3097302ca6c3c35957fa36610f Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Tue, 21 Feb 2012 14:09:23 -0800
Subject: [PATCH 229/238] mmc: octeon_mmc: Only allow a single slot to be used at a time.

Source: Cavium SDK 2.3-427

There is a single controller for the four slots, use of the slots must
be serialized.  Add a semaphore to do this.

Signed-off-by: David Daney <david.daney@cavium.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/mmc/host/octeon_mmc.c |   25 +++++++++++++++++++++----
 1 files changed, 21 insertions(+), 4 deletions(-)

diff --git a/drivers/mmc/host/octeon_mmc.c b/drivers/mmc/host/octeon_mmc.c
index 6f1f392..caade58 100644
--- a/drivers/mmc/host/octeon_mmc.c
+++ b/drivers/mmc/host/octeon_mmc.c
@@ -64,6 +64,8 @@ struct octeon_mmc_host {
 	int sg_idx;
 	bool dma_active;
 
+	struct semaphore mmc_serializer;
+
 	struct platform_device	*pdev;
 
 	struct octeon_mmc_slot	*slot[OCTEON_MAX_MMC];
@@ -148,6 +150,7 @@ static irqreturn_t octeon_mmc_interrupt(int irq, void *dev_id)
 	struct octeon_mmc_host *host = dev_id;
 	union cvmx_mio_emm_int emm_int;
 	struct mmc_request	*req;
+	bool host_done;
 	u64 rsp_sts;
 	unsigned long flags;
 
@@ -198,8 +201,8 @@ static irqreturn_t octeon_mmc_interrupt(int irq, void *dev_id)
 		req->cmd->data->bytes_xfered = bytes_xfered;
 		req->cmd->data->error = 0;
 	}
-
-	if ((emm_int.s.cmd_done || emm_int.s.dma_done || emm_int.s.cmd_err) && req->done) {
+	host_done = emm_int.s.cmd_done || emm_int.s.dma_done || emm_int.s.cmd_err;
+	if (host_done && req->done) {
 		int rsp_val;
 
 		rsp_val = (rsp_sts >> 12) & 1;
@@ -245,6 +248,8 @@ static irqreturn_t octeon_mmc_interrupt(int irq, void *dev_id)
 		req->done(req);
 	}
 	spin_unlock_irqrestore(&host->lock, flags);
+	if (host_done)
+		up(&host->mmc_serializer);
 out:
 	return IRQ_RETVAL(emm_int.u64 != 0);
 }
@@ -272,6 +277,9 @@ static void octeon_mmc_dma_request(struct mmc_host *mmc, struct mmc_request *mrq
 	slot = mmc_priv(mmc);
 	host = slot->host;
 
+	/* Only a single user of the host block at a time. */
+	down(&host->mmc_serializer);
+
 	data = mrq->data;
 
 	spin_lock_irqsave(&host->lock, flags);
@@ -327,6 +335,9 @@ static void octeon_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	slot = mmc_priv(mmc);
 	host = slot->host;
 
+	/* Only a single user of the host block at a time. */
+	down(&host->mmc_serializer);
+
 	spin_lock_irqsave(&host->lock, flags);
 	WARN_ON(host->current_req);
 	host->current_req = mrq;
@@ -409,6 +420,9 @@ static void octeon_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 	slot = mmc_priv(mmc);
 	host = slot->host;
 
+	/* Only a single user of the host block at a time. */
+	down(&host->mmc_serializer);
+
 	pr_debug("Calling set_ios: slot: clk = 0x%x, bus_width = %d\n", slot->clock, slot->bus_width);
 	pr_debug("Calling set_ios: ios: clk = 0x%x, vdd = %u, bus_width = %u, power_mode = %u, timing = %u\n",
 		 ios->clock, ios->vdd, ios->bus_width, ios->power_mode, ios->timing);
@@ -456,7 +470,7 @@ static void octeon_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 
 		if (!octeon_mmc_switch_val_changed(slot, emm_switch.u64)) {
 			pr_debug("No change from 0x%llx mio_emm_switch, returning.\n", emm_switch.u64);
-			return;
+			goto out;
 		}
 
 		pr_debug("Writing 0x%llx to mio_emm_wdog\n", ((u64)clock * 850ull) / 1000ull);
@@ -475,9 +489,11 @@ static void octeon_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 		if (timeout <= 0) {
 			pr_debug("%s: switch command timed out, status=0x%llx\n",
 				 __func__, emm_sts.u64);
-			return;
+			goto out;
 		}
 	}
+out:
+	up(&host->mmc_serializer);
 }
 
 static const struct mmc_host_ops octeon_mmc_ops = {
@@ -694,6 +710,7 @@ static int __init octeon_mmc_probe(struct platform_device *pdev)
 
 
 	spin_lock_init(&host->lock);
+	sema_init(&host->mmc_serializer, 1);
 
 	platform_set_drvdata(pdev, host);
 
-- 
1.7.0

