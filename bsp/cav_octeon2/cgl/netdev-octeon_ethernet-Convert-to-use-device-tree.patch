From 58a812f8e5d1088ceb6c20e7cebdde6fae174b1c Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Wed, 11 Jan 2012 10:17:49 -0800
Subject: [PATCH 118/238] netdev: octeon_ethernet: Convert to use device tree

Source: Cavium SDK 2.2-414

Get MAC address and PHY connection from the device tree.

Signed-off-by: David Daney <ddaney@caviumnetworks.com>
Integrated-by: Yang Shi <yang.shi@windriver.com>
---
 drivers/net/octeon/ethernet-mdio.c   |   30 +++++------
 drivers/net/octeon/ethernet.c        |   93 +++++++++++++++++++--------------
 drivers/net/octeon/octeon-ethernet.h |    2 +
 3 files changed, 69 insertions(+), 56 deletions(-)

diff --git a/drivers/net/octeon/ethernet-mdio.c b/drivers/net/octeon/ethernet-mdio.c
index 978d27c..8c0f18a 100644
--- a/drivers/net/octeon/ethernet-mdio.c
+++ b/drivers/net/octeon/ethernet-mdio.c
@@ -27,6 +27,7 @@
 #include <linux/kernel.h>
 #include <linux/ethtool.h>
 #include <linux/phy.h>
+#include <linux/of_mdio.h>
 #include <linux/net_tstamp.h>
 
 #include <net/dst.h>
@@ -392,26 +393,23 @@ static void cvm_oct_adjust_link(struct net_device *dev)
 int cvm_oct_phy_setup_device(struct net_device *dev)
 {
 	struct octeon_ethernet *priv = netdev_priv(dev);
+	struct device_node *phy_node;
 
-	int phy_addr = cvmx_helper_board_get_mii_address(priv->ipd_port);
-	if (phy_addr != -1) {
-		char phy_id[20];
-		char bus_number[2];
+	if (!priv->of_node)
+		return 0;
 
-		bus_number[0] = '0' + ((phy_addr >> 8) & 3);
-		bus_number[1] = 0;
+	phy_node = of_parse_phandle(priv->of_node, "phy-handle", 0);
+	if (!phy_node)
+		return 0;
 
-		snprintf(phy_id, sizeof(phy_id), PHY_ID_FMT, bus_number, phy_addr & 0xff);
+	priv->phydev = of_phy_connect(dev, phy_node, cvm_oct_adjust_link, 0,
+				      PHY_INTERFACE_MODE_GMII);
 
-		priv->phydev = phy_connect(dev, phy_id, cvm_oct_adjust_link, 0,
-					   PHY_INTERFACE_MODE_GMII);
+	if (priv->phydev == NULL)
+		return -ENODEV;
+
+	priv->last_link = 0;
+	phy_start_aneg(priv->phydev);
 
-		if (IS_ERR(priv->phydev)) {
-			priv->phydev = NULL;
-			return -1;
-		}
-		priv->last_link = 0;
-		phy_start_aneg(priv->phydev);
-	}
 	return 0;
 }
diff --git a/drivers/net/octeon/ethernet.c b/drivers/net/octeon/ethernet.c
index eb90e61..286560e 100644
--- a/drivers/net/octeon/ethernet.c
+++ b/drivers/net/octeon/ethernet.c
@@ -30,6 +30,7 @@
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/phy.h>
+#include <linux/of_net.h>
 
 #include <net/dst.h>
 
@@ -91,15 +92,6 @@ int rx_napi_weight = 32;
 module_param(rx_napi_weight, int, 0444);
 MODULE_PARM_DESC(rx_napi_weight, "The NAPI WEIGHT parameter.");
 
-/*
- * The offset from mac_addr_base that should be used for the next port
- * that is configured.  By convention, if any mgmt ports exist on the
- * chip, they get the first mac addresses, The ports controlled by
- * this driver are numbered sequencially following any mgmt addresses
- * that may exist.
- */
-static unsigned int cvm_oct_mac_addr_offset;
-
 /**
  * cvm_oct_poll_queue - Workqueue for polling operations.
  */
@@ -471,29 +463,16 @@ int cvm_oct_common_init(struct net_device *dev)
 	unsigned long flags;
 	cvmx_pko_port_status_t tx_status;
 	struct octeon_ethernet *priv = netdev_priv(dev);
-	struct sockaddr sa;
-	u64 mac = ((u64)(octeon_bootinfo->mac_addr_base[0] & 0xff) << 40) |
-		((u64)(octeon_bootinfo->mac_addr_base[1] & 0xff) << 32) |
-		((u64)(octeon_bootinfo->mac_addr_base[2] & 0xff) << 24) |
-		((u64)(octeon_bootinfo->mac_addr_base[3] & 0xff) << 16) |
-		((u64)(octeon_bootinfo->mac_addr_base[4] & 0xff) << 8) |
-		(u64)(octeon_bootinfo->mac_addr_base[5] & 0xff);
-
-	mac += cvm_oct_mac_addr_offset;
-	sa.sa_data[0] = (mac >> 40) & 0xff;
-	sa.sa_data[1] = (mac >> 32) & 0xff;
-	sa.sa_data[2] = (mac >> 24) & 0xff;
-	sa.sa_data[3] = (mac >> 16) & 0xff;
-	sa.sa_data[4] = (mac >> 8) & 0xff;
-	sa.sa_data[5] = mac & 0xff;
-
-	if (cvm_oct_mac_addr_offset >= octeon_bootinfo->mac_addr_count)
-		printk(KERN_DEBUG "%s: Using MAC outside of the assigned range:"
-			" %02x:%02x:%02x:%02x:%02x:%02x\n", dev->name,
-			sa.sa_data[0] & 0xff, sa.sa_data[1] & 0xff,
-			sa.sa_data[2] & 0xff, sa.sa_data[3] & 0xff,
-			sa.sa_data[4] & 0xff, sa.sa_data[5] & 0xff);
-	cvm_oct_mac_addr_offset++;
+	struct sockaddr sa = {0};
+	const u8 *mac = NULL;
+
+	if (priv->of_node)
+		mac = of_get_mac_address(priv->of_node);
+
+	if (mac)
+		memcpy(sa.sa_data, mac, ETH_ALEN);
+	else
+		random_ether_addr(sa.sa_data);
 
 	if (priv->num_tx_queues) {
 		dev->features |= NETIF_F_SG;
@@ -736,12 +715,47 @@ struct octeon_ethernet *cvm_oct_dev_for_port(int port_number)
 	return NULL;
 }
 
+static struct device_node * __init cvm_oct_of_get_child(const struct device_node *parent,
+							int reg_val)
+{
+	struct device_node *node = NULL;
+	int size;
+	const __be32 *addr;
+
+	for (;;) {
+		node = of_get_next_child(parent, node);
+		if (!node)
+			break;
+		addr = of_get_property(node, "reg", &size);
+		if (addr && (be32_to_cpu(*addr) == reg_val))
+			break;
+	}
+	return node;
+}
+
+static struct device_node * __init cvm_oct_node_for_port(struct device_node *pip,
+							 int interface, int port)
+{
+	struct device_node *ni, *np;
+
+	ni = cvm_oct_of_get_child(pip, interface);
+	if (!ni)
+		return NULL;
+
+	np = cvm_oct_of_get_child(ni, port);
+	of_node_put(ni);
+
+	return np;
+}
+
+
 static int __init cvm_oct_init_module(void)
 {
 	int num_interfaces;
 	int interface;
 	int fau = FAU_NUM_PACKET_BUFFERS_TO_FREE;
 	int qos;
+	struct device_node *pip;
 	int i;
 	int rv = 0;
 
@@ -753,15 +767,13 @@ static int __init cvm_oct_init_module(void)
 	octeon_mdiobus_force_mod_depencency();
 	pr_notice("octeon-ethernet %s\n", OCTEON_ETHERNET_VERSION);
 
-	cvmx_override_pko_queue_priority = cvm_oct_override_pko_queue_priority;
+	pip = of_find_node_by_path("pip");
+	if (!pip) {
+		pr_err("Error: No 'pip' in /aliases\n");
+		return -EINVAL;
+	}
 
-	if (OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN63XX)
-	    || OCTEON_IS_MODEL(OCTEON_CN66XX))
-		cvm_oct_mac_addr_offset = 2; /* First two are the mgmt ports. */
-	else if (OCTEON_IS_MODEL(OCTEON_CN56XX) || OCTEON_IS_MODEL(OCTEON_CN68XX))
-		cvm_oct_mac_addr_offset = 1; /* First one is the mgmt port. */
-	else
-		cvm_oct_mac_addr_offset = 0;
+	cvmx_override_pko_queue_priority = cvm_oct_override_pko_queue_priority;
 
 	cvm_oct_poll_queue = create_singlethread_workqueue("oct-eth-wq1");
 	if (cvm_oct_poll_queue == NULL) {
@@ -836,6 +848,7 @@ static int __init cvm_oct_init_module(void)
 
 			/* Initialize the device private structure. */
 			priv = netdev_priv(dev);
+			priv->of_node = cvm_oct_node_for_port(pip, interface, interface_port);
 			RB_CLEAR_NODE(&priv->ipd_tree);
 			priv->netdev = dev;
 			priv->interface = interface;
diff --git a/drivers/net/octeon/octeon-ethernet.h b/drivers/net/octeon/octeon-ethernet.h
index 92c3a64..6bc3401 100644
--- a/drivers/net/octeon/octeon-ethernet.h
+++ b/drivers/net/octeon/octeon-ethernet.h
@@ -31,6 +31,7 @@
 #ifndef OCTEON_ETHERNET_H
 #define OCTEON_ETHERNET_H
 
+#include <linux/of.h>
 #include <linux/rbtree.h>
 
 #include <asm/octeon/cvmx-helper.h>
@@ -92,6 +93,7 @@ struct octeon_ethernet {
 	void (*poll) (struct net_device *dev);
 	struct delayed_work	port_periodic_work;
 	struct work_struct	port_work;	/* may be unused. */
+	struct device_node	*of_node;
 	u64 last_tx_octets;
 	u32 last_tx_packets;
 };
-- 
1.7.0

