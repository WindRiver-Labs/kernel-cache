From 316feb757013f9b6f1821d3b6f942d8ede592135 Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Tue, 10 Apr 2012 18:16:46 +0800
Subject: [PATCH 182/238] MIPS: Octeon: Correctly mask and unmask interrupts in v1 CIU.

Source: Cavium SDK 2.3-427

When using threaded interrupts, we cannot do fake masking of interrupts.
The thread that does the unmasking may be on a different CPU with breaks
the assumptions that were made.
Also protect the register accesses with a per-CPU spinlock instead of
a global lock.  This should minimize lock contention under high irq
loads now that we are actually masking and unmasking individual irq
lines on each interrupt.

Signed-off-by: David Daney <david.daney@cavium.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 arch/mips/cavium-octeon/octeon-irq.c |  248 +++++++++++++++++-----------------
 1 files changed, 122 insertions(+), 126 deletions(-)

diff --git a/arch/mips/cavium-octeon/octeon-irq.c b/arch/mips/cavium-octeon/octeon-irq.c
index a53c673..faa33a4 100644
--- a/arch/mips/cavium-octeon/octeon-irq.c
+++ b/arch/mips/cavium-octeon/octeon-irq.c
@@ -16,11 +16,9 @@
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/cvmx-ciu2-defs.h>
 
-DEFINE_SPINLOCK(octeon_irq_ciu0_spinlock);
-DEFINE_SPINLOCK(octeon_irq_ciu1_spinlock);
-
 static DEFINE_PER_CPU(unsigned long, octeon_irq_ciu0_en_mirror);
 static DEFINE_PER_CPU(unsigned long, octeon_irq_ciu1_en_mirror);
+static DEFINE_PER_CPU(spinlock_t, octeon_irq_ciu_spinlock);
 
 static __read_mostly u8 octeon_irq_ciu_to_irq[8][64];
 
@@ -270,22 +268,23 @@ static void octeon_irq_ciu_enable(unsigned int irq)
 	volatile unsigned long *pen;
 	unsigned long flags;
 	union octeon_ciu_chip_data cd;
+	spinlock_t *lock = &per_cpu(octeon_irq_ciu_spinlock, cpu);
 
 	cd.p = desc->chip_data;
 
+	spin_lock_irqsave(lock, flags);
 	if (cd.s.line == 0) {
-		spin_lock_irqsave(&octeon_irq_ciu0_spinlock, flags);
 		pen = &per_cpu(octeon_irq_ciu0_en_mirror, cpu);
-		set_bit(cd.s.bit, pen);
+		__set_bit(cd.s.bit, pen);
+		wmb();
 		cvmx_write_csr(CVMX_CIU_INTX_EN0(coreid * 2), *pen);
-		spin_unlock_irqrestore(&octeon_irq_ciu0_spinlock, flags);
 	} else {
-		spin_lock_irqsave(&octeon_irq_ciu1_spinlock, flags);
 		pen = &per_cpu(octeon_irq_ciu1_en_mirror, cpu);
-		set_bit(cd.s.bit, pen);
+		__set_bit(cd.s.bit, pen);
+		wmb();
 		cvmx_write_csr(CVMX_CIU_INTX_EN1(coreid * 2 + 1), *pen);
-		spin_unlock_irqrestore(&octeon_irq_ciu1_spinlock, flags);
 	}
+	spin_unlock_irqrestore(lock, flags);
 }
 
 static void octeon_irq_ciu_enable_local(unsigned int irq)
@@ -295,53 +294,93 @@ static void octeon_irq_ciu_enable_local(unsigned int irq)
 	volatile unsigned long *pen;
 	unsigned long flags;
 	union octeon_ciu_chip_data cd;
+	spinlock_t *lock = &__get_cpu_var(octeon_irq_ciu_spinlock);
 
 	cd.p = desc->chip_data;
 
+	spin_lock_irqsave(lock, flags);
 	if (cd.s.line == 0) {
-		spin_lock_irqsave(&octeon_irq_ciu0_spinlock, flags);
 		pen = &__get_cpu_var(octeon_irq_ciu0_en_mirror);
-		set_bit(cd.s.bit, pen);
+		__set_bit(cd.s.bit, pen);
+		wmb();
 		cvmx_write_csr(CVMX_CIU_INTX_EN0(coreid * 2), *pen);
-		spin_unlock_irqrestore(&octeon_irq_ciu0_spinlock, flags);
 	} else {
-		spin_lock_irqsave(&octeon_irq_ciu1_spinlock, flags);
 		pen = &__get_cpu_var(octeon_irq_ciu1_en_mirror);
-		set_bit(cd.s.bit, pen);
+		__set_bit(cd.s.bit, pen);
+		wmb();
 		cvmx_write_csr(CVMX_CIU_INTX_EN1(coreid * 2 + 1), *pen);
-		spin_unlock_irqrestore(&octeon_irq_ciu1_spinlock, flags);
 	}
+	spin_unlock_irqrestore(lock, flags);
+}
+
+static void octeon_irq_ciu_enable_check(unsigned int irq)
+{
+	struct irq_desc *desc = irq_to_desc(irq);
+	if ((desc->status & IRQ_DISABLED) == 0)
+		octeon_irq_ciu_enable(irq);
 }
 
-static void octeon_irq_ciu_disable(unsigned int irq)
+static void octeon_irq_ciu_enable_local_check(unsigned int irq)
+{
+	struct irq_desc *desc = irq_to_desc(irq);
+	if ((desc->status & IRQ_DISABLED) == 0)
+		octeon_irq_ciu_enable_local(irq);
+}
+
+static void octeon_irq_ciu_disable_all(unsigned int irq)
 {
 	struct irq_desc *desc = irq_to_desc(irq);
 	unsigned long flags;
 	volatile unsigned long *pen;
 	int cpu;
 	union octeon_ciu_chip_data cd;
+	spinlock_t *lock;
 
 	cd.p = desc->chip_data;
 
-	if (cd.s.line == 0) {
-		spin_lock_irqsave(&octeon_irq_ciu0_spinlock, flags);
-		for_each_online_cpu(cpu) {
-			int coreid = octeon_coreid_for_cpu(cpu);
+	for_each_online_cpu(cpu) {
+		int coreid = octeon_coreid_for_cpu(cpu);
+		lock = &per_cpu(octeon_irq_ciu_spinlock, cpu);
+		if (cd.s.line == 0)
 			pen = &per_cpu(octeon_irq_ciu0_en_mirror, cpu);
-			clear_bit(cd.s.bit, pen);
-			cvmx_write_csr(CVMX_CIU_INTX_EN0(coreid * 2), *pen);
-		}
-		spin_unlock_irqrestore(&octeon_irq_ciu0_spinlock, flags);
-	} else {
-		spin_lock_irqsave(&octeon_irq_ciu1_spinlock, flags);
-		for_each_online_cpu(cpu) {
-			int coreid = octeon_coreid_for_cpu(cpu);
+		else
 			pen = &per_cpu(octeon_irq_ciu1_en_mirror, cpu);
-			clear_bit(cd.s.bit, pen);
+
+		spin_lock_irqsave(lock, flags);
+		__clear_bit(cd.s.bit, pen);
+		wmb();
+		if (cd.s.line == 0)
+			cvmx_write_csr(CVMX_CIU_INTX_EN0(coreid * 2), *pen);
+		else
 			cvmx_write_csr(CVMX_CIU_INTX_EN1(coreid * 2 + 1), *pen);
-		}
-		spin_unlock_irqrestore(&octeon_irq_ciu1_spinlock, flags);
+		spin_unlock_irqrestore(lock, flags);
+	}
+}
+
+static void octeon_irq_ciu_disable_local(unsigned int irq)
+{
+	struct irq_desc *desc = irq_to_desc(irq);
+	int coreid = cvmx_get_core_num();
+	volatile unsigned long *pen;
+	unsigned long flags;
+	union octeon_ciu_chip_data cd;
+	spinlock_t *lock = &__get_cpu_var(octeon_irq_ciu_spinlock);
+
+	cd.p = desc->chip_data;
+
+	spin_lock_irqsave(lock, flags);
+	if (cd.s.line == 0) {
+		pen = &__get_cpu_var(octeon_irq_ciu0_en_mirror);
+		__clear_bit(cd.s.bit, pen);
+		wmb();
+		cvmx_write_csr(CVMX_CIU_INTX_EN0(coreid * 2), *pen);
+	} else {
+		pen = &__get_cpu_var(octeon_irq_ciu1_en_mirror);
+		__clear_bit(cd.s.bit, pen);
+		wmb();
+		cvmx_write_csr(CVMX_CIU_INTX_EN1(coreid * 2 + 1), *pen);
 	}
+	spin_unlock_irqrestore(lock, flags);
 }
 
 /*
@@ -488,6 +527,8 @@ static int octeon_irq_ciu_set_affinity(unsigned int irq, const struct cpumask *d
 	int enable_one = (desc->status & IRQ_DISABLED) == 0;
 	unsigned long flags;
 	union octeon_ciu_chip_data cd;
+	volatile unsigned long *pen;
+	spinlock_t *lock;
 
 	cd.p = desc->chip_data;
 
@@ -502,36 +543,31 @@ static int octeon_irq_ciu_set_affinity(unsigned int irq, const struct cpumask *d
 	if (desc->status & IRQ_DISABLED)
 		return 0;
 
-	if (cd.s.line == 0) {
-		spin_lock_irqsave(&octeon_irq_ciu0_spinlock, flags);
-		for_each_online_cpu(cpu) {
-			int coreid = octeon_coreid_for_cpu(cpu);
-			volatile unsigned long *pen = &per_cpu(octeon_irq_ciu0_en_mirror, cpu);
+	for_each_online_cpu(cpu) {
+		int coreid = octeon_coreid_for_cpu(cpu);
 
-			if (cpumask_test_cpu(cpu, dest) && enable_one) {
-				enable_one = 0;
-				set_bit(cd.s.bit, pen);
-			} else {
-				clear_bit(cd.s.bit, pen);
-			}
-			cvmx_write_csr(CVMX_CIU_INTX_EN0(coreid * 2), *pen);
+		lock = &per_cpu(octeon_irq_ciu_spinlock, cpu);
+		spin_lock_irqsave(lock, flags);
+
+		if (cd.s.line == 0)
+			pen = &per_cpu(octeon_irq_ciu0_en_mirror, cpu);
+		else
+			pen = &per_cpu(octeon_irq_ciu1_en_mirror, cpu);
+
+		if (cpumask_test_cpu(cpu, dest) && enable_one) {
+			enable_one = 0;
+			__set_bit(cd.s.bit, pen);
+		} else {
+			__clear_bit(cd.s.bit, pen);
 		}
-		spin_unlock_irqrestore(&octeon_irq_ciu0_spinlock, flags);
-	} else {
-		spin_lock_irqsave(&octeon_irq_ciu1_spinlock, flags);
-		for_each_online_cpu(cpu) {
-			int coreid = octeon_coreid_for_cpu(cpu);
-			volatile unsigned long *pen = &per_cpu(octeon_irq_ciu1_en_mirror, cpu);
+		wmb();
 
-			if (cpumask_test_cpu(cpu, dest) && enable_one) {
-				enable_one = 0;
-				set_bit(cd.s.bit, pen);
-			} else {
-				clear_bit(cd.s.bit, pen);
-			}
+		if (cd.s.line == 0)
+			cvmx_write_csr(CVMX_CIU_INTX_EN0(coreid * 2), *pen);
+		else
 			cvmx_write_csr(CVMX_CIU_INTX_EN1(coreid * 2 + 1), *pen);
-		}
-		spin_unlock_irqrestore(&octeon_irq_ciu1_spinlock, flags);
+
+		spin_unlock_irqrestore(lock, flags);
 	}
 	return 0;
 }
@@ -587,15 +623,6 @@ static int octeon_irq_ciu_set_affinity_v2(unsigned int irq,
 #endif
 
 /*
- * The v1 CIU code already masks things, so supply a dummy version to
- * the core chip code.
- */
-static void octeon_irq_dummy_mask(unsigned int irq)
-{
-	return;
-}
-
-/*
  * Newer octeon chips have support for lockless CIU operation.
  */
 static struct irq_chip octeon_irq_chip_ciu_v2 = {
@@ -624,8 +651,9 @@ static struct irq_chip octeon_irq_chip_ciu_edge_v2 = {
 static struct irq_chip octeon_irq_chip_ciu = {
 	.name = "CIU",
 	.enable = octeon_irq_ciu_enable,
-	.disable = octeon_irq_ciu_disable,
-	.mask = octeon_irq_dummy_mask,
+	.disable = octeon_irq_ciu_disable_all,
+	.mask = octeon_irq_ciu_disable_local,
+	.unmask = octeon_irq_ciu_enable_check,
 #ifdef CONFIG_SMP
 	.set_affinity = octeon_irq_ciu_set_affinity,
 #endif
@@ -634,9 +662,10 @@ static struct irq_chip octeon_irq_chip_ciu = {
 static struct irq_chip octeon_irq_chip_ciu_edge = {
 	.name = "CIU-E",
 	.enable = octeon_irq_ciu_enable,
-	.disable = octeon_irq_ciu_disable,
-	.mask = octeon_irq_dummy_mask,
+	.disable = octeon_irq_ciu_disable_all,
 	.ack = octeon_irq_ciu_ack,
+	.mask = octeon_irq_ciu_disable_local,
+	.unmask = octeon_irq_ciu_enable_check,
 #ifdef CONFIG_SMP
 	.set_affinity = octeon_irq_ciu_set_affinity,
 #endif
@@ -654,7 +683,9 @@ static struct irq_chip octeon_irq_chip_ciu_mbox_v2 = {
 static struct irq_chip octeon_irq_chip_ciu_mbox = {
 	.name = "CIU-M",
 	.enable = octeon_irq_ciu_enable_local,
-	.disable = octeon_irq_ciu_disable,
+	.disable = octeon_irq_ciu_disable_all,
+	.ack = octeon_irq_ciu_disable_local,
+	.eoi = octeon_irq_ciu_enable_local_check
 };
 
 /*
@@ -668,12 +699,14 @@ static void octeon_irq_ciu_wd_enable(unsigned int irq)
 
 	volatile unsigned long *pen;
 	int cpu = octeon_cpu_for_coreid(coreid);
+	spinlock_t *lock = &per_cpu(octeon_irq_ciu_spinlock, cpu);
 
-	spin_lock_irqsave(&octeon_irq_ciu1_spinlock, flags);
 	pen = &per_cpu(octeon_irq_ciu1_en_mirror, cpu);
-	set_bit(coreid, pen);
+	spin_lock_irqsave(lock, flags);
+	__set_bit(coreid, pen);
+	wmb();
 	cvmx_write_csr(CVMX_CIU_INTX_EN1(coreid * 2 + 1), *pen);
-	spin_unlock_irqrestore(&octeon_irq_ciu1_spinlock, flags);
+	spin_unlock_irqrestore(lock, flags);
 }
 
 /*
@@ -701,8 +734,9 @@ static struct irq_chip octeon_irq_chip_ciu_wd_v2 = {
 static struct irq_chip octeon_irq_chip_ciu_wd = {
 	.name = "CIU-W",
 	.enable = octeon_irq_ciu_wd_enable,
-	.disable = octeon_irq_ciu_disable,
-	.mask = octeon_irq_dummy_mask,
+	.disable = octeon_irq_ciu_disable_all,
+	.mask = octeon_irq_ciu_disable_local,
+	.unmask = octeon_irq_ciu_enable_check
 };
 
 void paravirt_arch_init_irq(void)
@@ -767,7 +801,7 @@ static void octeon_irq_ciu_disable_gpio(unsigned int irq)
 	int bit = irq - OCTEON_IRQ_GPIO0;
 	cvmx_write_csr(CVMX_GPIO_BIT_CFGX(bit), 0);
 
-	octeon_irq_ciu_disable(irq);
+	octeon_irq_ciu_disable_all(irq);
 }
 
 static void octeon_irq_ciu_gpio_ack(unsigned int irq)
@@ -795,7 +829,8 @@ static struct irq_chip octeon_irq_chip_ciu_gpio = {
 	.name = "CIU-GPIO",
 	.enable = octeon_irq_ciu_enable_gpio,
 	.disable = octeon_irq_ciu_disable_gpio,
-	.mask = octeon_irq_dummy_mask,
+	.mask = octeon_irq_ciu_disable_local,
+	.unmask = octeon_irq_ciu_enable_check,
 	.ack = octeon_irq_ciu_gpio_ack,
 	.set_type = octeon_irq_ciu_gpio_set_type,
 #ifdef CONFIG_SMP
@@ -803,27 +838,7 @@ static struct irq_chip octeon_irq_chip_ciu_gpio = {
 #endif
 };
 
-static void octeon_irq_ip2_v1(void)
-{
-	const unsigned long core_id = cvmx_get_core_num();
-	u64 ciu_sum = cvmx_read_csr(CVMX_CIU_INTX_SUM0(core_id * 2));
-
-	ciu_sum &= __get_cpu_var(octeon_irq_ciu0_en_mirror);
-	clear_c0_status(STATUSF_IP2);
-	if (likely(ciu_sum)) {
-		int bit = fls64(ciu_sum) - 1;
-		int irq = octeon_irq_ciu_to_irq[0][bit];
-		if (likely(irq))
-			do_IRQ(irq);
-		else
-			spurious_interrupt();
-	} else {
-		spurious_interrupt();
-	}
-	set_c0_status(STATUSF_IP2);
-}
-
-static void octeon_irq_ip2_v2(void)
+static void octeon_irq_ip2_ciu(void)
 {
 	const unsigned long core_id = cvmx_get_core_num();
 	u64 ciu_sum = cvmx_read_csr(CVMX_CIU_INTX_SUM0(core_id * 2));
@@ -840,26 +855,8 @@ static void octeon_irq_ip2_v2(void)
 		spurious_interrupt();
 	}
 }
-static void octeon_irq_ip3_v1(void)
-{
-	u64 ciu_sum = cvmx_read_csr(CVMX_CIU_INT_SUM1);
-
-	ciu_sum &= __get_cpu_var(octeon_irq_ciu1_en_mirror);
-	clear_c0_status(STATUSF_IP3);
-	if (likely(ciu_sum)) {
-		int bit = fls64(ciu_sum) - 1;
-		int irq = octeon_irq_ciu_to_irq[1][bit];
-		if (likely(irq))
-			do_IRQ(irq);
-		else
-			spurious_interrupt();
-	} else {
-		spurious_interrupt();
-	}
-	set_c0_status(STATUSF_IP3);
-}
 
-static void octeon_irq_ip3_v2(void)
+static void octeon_irq_ip3_ciu(void)
 {
 	u64 ciu_sum = cvmx_read_csr(CVMX_CIU_INT_SUM1);
 
@@ -924,6 +921,11 @@ static void octeon_irq_percpu_enable(void)
 static void octeon_irq_init_ciu_percpu(void)
 {
 	int coreid = cvmx_get_core_num();
+
+	__get_cpu_var(octeon_irq_ciu0_en_mirror) = 0;
+	__get_cpu_var(octeon_irq_ciu1_en_mirror) = 0;
+	spin_lock_init(&__get_cpu_var(octeon_irq_ciu_spinlock));
+
 	/*
 	 * Disable All CIU Interrupts. The ones we need will be
 	 * enabled later.  Read the SUM register so we know the write
@@ -960,10 +962,6 @@ static void octeon_irq_init_ciu2_percpu(void)
 
 static void octeon_irq_setup_secondary_ciu(void)
 {
-
-	__get_cpu_var(octeon_irq_ciu0_en_mirror) = 0;
-	__get_cpu_var(octeon_irq_ciu1_en_mirror) = 0;
-
 	octeon_irq_init_ciu_percpu();
 	octeon_irq_percpu_enable();
 
@@ -1000,20 +998,18 @@ static void __init octeon_irq_init_ciu(void)
 	octeon_irq_init_ciu_percpu();
 	octeon_irq_setup_secondary = octeon_irq_setup_secondary_ciu;
 
+	octeon_irq_ip2 = octeon_irq_ip2_ciu;
+	octeon_irq_ip3 = octeon_irq_ip3_ciu;
 	if (OCTEON_IS_MODEL(OCTEON_CN58XX_PASS2_X) ||
 	    OCTEON_IS_MODEL(OCTEON_CN56XX_PASS2_X) ||
 	    OCTEON_IS_MODEL(OCTEON_CN52XX_PASS2_X) ||
 	    OCTEON_IS_MODEL(OCTEON_CN6XXX)) {
-		octeon_irq_ip2 = octeon_irq_ip2_v2;
-		octeon_irq_ip3 = octeon_irq_ip3_v2;
 		chip = &octeon_irq_chip_ciu_v2;
 		chip_edge = &octeon_irq_chip_ciu_edge_v2;
 		chip_mbox = &octeon_irq_chip_ciu_mbox_v2;
 		chip_wd = &octeon_irq_chip_ciu_wd_v2;
 		chip_gpio = &octeon_irq_chip_ciu_gpio_v2;
 	} else {
-		octeon_irq_ip2 = octeon_irq_ip2_v1;
-		octeon_irq_ip3 = octeon_irq_ip3_v1;
 		chip = &octeon_irq_chip_ciu;
 		chip_edge = &octeon_irq_chip_ciu_edge;
 		chip_mbox = &octeon_irq_chip_ciu_mbox;
-- 
1.7.0

