From 4c5a4594f02508b4264b17c8697f38a753a61638 Mon Sep 17 00:00:00 2001
From: Chandrakala Chavva <cchavva@cavium.com>
Date: Wed, 11 Apr 2012 10:41:48 +0800
Subject: [PATCH 199/238] MIPS: Octeon: Fix error interrupts in ebb6800.

Source: Cavium SDK 2.3-427

Kernel disables the interrupts before calling cvmx_error_poll() in
case of an error interrupt, which is used for decoding the interrupt.
Get the index of the error info structure for the corresponding error
interrupt for decoding.

Signed-off-by: Chandrakala Chavva <cchavva@cavium.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 arch/mips/cavium-octeon/setup.c |  124 ++++++++++++++++++++++++++-------------
 1 files changed, 82 insertions(+), 42 deletions(-)

diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c
index bffc2db..e429b44 100644
--- a/arch/mips/cavium-octeon/setup.c
+++ b/arch/mips/cavium-octeon/setup.c
@@ -40,13 +40,25 @@
 #include <asm/octeon/octeon.h>
 #include <asm/octeon/octeon-boot-info.h>
 
-#include <asm/octeon/cvmx-clock.h>
+#include <asm/octeon/cvmx-agl-defs.h>
 #include <asm/octeon/cvmx-ciu2-defs.h>
+#include <asm/octeon/cvmx-rad-defs.h>
+#include <asm/octeon/cvmx-fpa-defs.h>
+#include <asm/octeon/cvmx-dfa-defs.h>
+#include <asm/octeon/cvmx-dpi-defs.h>
+#include <asm/octeon/cvmx-key-defs.h>
+#include <asm/octeon/cvmx-l2c-defs.h>
+#include <asm/octeon/cvmx-ndf-defs.h>
+#include <asm/octeon/cvmx-pexp-defs.h>
+#include <asm/octeon/cvmx-pko-defs.h>
+#include <asm/octeon/cvmx-pip-defs.h>
+#include <asm/octeon/cvmx-sso-defs.h>
+#include <asm/octeon/cvmx-zip-defs.h>
+
+#include <asm/octeon/cvmx-clock.h>
 #include <asm/octeon/cvmx-error.h>
 #include <asm/octeon/cvmx-debug.h>
 #include <asm/octeon/cvmx-pcie.h>
-#include <asm/octeon/cvmx-pexp-defs.h>
-#include <asm/octeon/cvmx-sso-defs.h>
 
 #ifdef CONFIG_KEXEC
 #include <linux/kexec.h>
@@ -340,6 +352,15 @@ static irqreturn_t octeon_rml_interrupt(int cpl, void *dev_id)
 	else
 		return IRQ_NONE;
 }
+
+static irqreturn_t octeon_rml_interrupt_v2(int cpl, void *data)
+{
+	if (data != NULL) {
+		if (__cvmx_error_decode((cvmx_error_info_t *)data))
+			return IRQ_HANDLED;
+	}
+	return IRQ_NONE;
+}
 #endif
 
 /**
@@ -1184,91 +1205,110 @@ void prom_free_prom_memory(void)
 #endif
 	if (OCTEON_IS_MODEL(OCTEON_CN68XX)) {
 		int i;
-		if (request_irq(OCTEON_IRQ_NAND, octeon_rml_interrupt, IRQF_SHARED,
-					"NAND RML_RSL", octeon_rml_interrupt)) {
+		if (request_irq(OCTEON_IRQ_NAND, octeon_rml_interrupt_v2,
+					IRQF_SHARED, "NAND RML/RSL",
+					cvmx_error_get_index(CVMX_NDF_INT))) {
 			panic("Unable to request_irq(OCTEON_IRQ_NAND)");
 		}
-		if (request_irq(OCTEON_IRQ_MIO, octeon_rml_interrupt, IRQF_SHARED,
-					"MIO RML_RSL", octeon_rml_interrupt)) {
+		if (request_irq(OCTEON_IRQ_MIO, octeon_rml_interrupt_v2,
+					IRQF_SHARED, "MIO RML/RSL",
+					cvmx_error_get_index(CVMX_MIO_RST_INT))) {
 			panic("Unable to request_irq(OCTEON_IRQ_MIO)");
 		}
-		if (request_irq(OCTEON_IRQ_FPA, octeon_rml_interrupt, IRQF_SHARED,
-					"FPA RML_RSL", octeon_rml_interrupt)) {
+		if (request_irq(OCTEON_IRQ_FPA, octeon_rml_interrupt_v2,
+					IRQF_SHARED, "FPA RML/RSL",
+					cvmx_error_get_index(CVMX_FPA_INT_SUM))) {
 			panic("Unable to request_irq(OCTEON_IRQ_FPA)");
 		}
 #if 0
-		if (request_irq(OCTEON_IRQ_POW, octeon_rml_interrupt, IRQF_SHARED,
-					"POW RML_RSL", octeon_rml_interrupt)) {
-			panic("Unable to request_irq(OCTEON_IRQ_POW)\n");
+		if (request_irq(OCTEON_IRQ_POW, octeon_rml_interrupt_v2,
+					IRQF_SHARED, "POW RML/RSL",
+					cvmx_error_get_index(CVMX_SSO_ERR))) {
+			panic("Unable to request_irq(OCTEON_IRQ_POW)");
 		}
 #endif
-		if (request_irq(OCTEON_IRQ_L2C, octeon_rml_interrupt, IRQF_SHARED,
-					"L2C RML_RSL", octeon_rml_interrupt)) {
+		if (request_irq(OCTEON_IRQ_L2C, octeon_rml_interrupt_v2,
+					IRQF_SHARED, "L2C RML/RSL",
+					cvmx_error_get_index(CVMX_L2C_INT_REG))) {
 			panic("Unable to request_irq(OCTEON_IRQ_L2C)");
 		}
-		if (request_irq(OCTEON_IRQ_IPD, octeon_rml_interrupt, IRQF_SHARED,
-					"IPD RML_RSL", octeon_rml_interrupt)) {
+		if (request_irq(OCTEON_IRQ_IPD, octeon_rml_interrupt_v2,
+					IRQF_SHARED, "IPD RML/RSL",
+					cvmx_error_get_index(CVMX_IPD_INT_SUM))) {
 			panic("Unable to request_irq(OCTEON_IRQ_IPD)");
 		}
-		if (request_irq(OCTEON_IRQ_PIP, octeon_rml_interrupt, IRQF_SHARED,
-					"PIP RML/RSL", octeon_rml_interrupt)) {
+		if (request_irq(OCTEON_IRQ_PIP, octeon_rml_interrupt_v2,
+					IRQF_SHARED, "PIP RML/RSL",
+					cvmx_error_get_index(CVMX_PIP_INT_REG))) {
 			panic("Unable to request_irq(OCTEON_IRQ_PIP)");
 		}
-		if (request_irq(OCTEON_IRQ_PKO, octeon_rml_interrupt, IRQF_SHARED,
-					"PKO RML_RSL", octeon_rml_interrupt)) {
+		if (request_irq(OCTEON_IRQ_PKO, octeon_rml_interrupt_v2,
+					IRQF_SHARED, "PKO RML/RSL",
+					cvmx_error_get_index(CVMX_PKO_REG_ERROR))) {
 			panic("Unable to request_irq(OCTEON_IRQ_PKO)");
 		}
-		if (request_irq(OCTEON_IRQ_ZIP, octeon_rml_interrupt, IRQF_SHARED,
-					"ZIP RML_RSL", octeon_rml_interrupt)) {
+		if (request_irq(OCTEON_IRQ_ZIP, octeon_rml_interrupt_v2,
+					IRQF_SHARED, "ZIP RML/RSL",
+					cvmx_error_get_index(CVMX_ZIP_ERROR))) {
 			panic("Unable to request_irq(OCTEON_IRQ_ZIP)");
 		}
-		if (request_irq(OCTEON_IRQ_RAD, octeon_rml_interrupt, IRQF_SHARED,
-					"RAD RML_RSL", octeon_rml_interrupt)) {
+		if (request_irq(OCTEON_IRQ_RAD, octeon_rml_interrupt_v2,
+					IRQF_SHARED, "RAD RML/RSL",
+					cvmx_error_get_index(CVMX_RAD_REG_ERROR))) {
 			panic("Unable to request_irq(OCTEON_IRQ_RAD)");
 		}
-		if (request_irq(OCTEON_IRQ_KEY, octeon_rml_interrupt, IRQF_SHARED,
-					"KEY RML_RSL", octeon_rml_interrupt)) {
+		if (request_irq(OCTEON_IRQ_KEY, octeon_rml_interrupt_v2,
+					IRQF_SHARED, "KEY RML/RSL",
+					cvmx_error_get_index(CVMX_KEY_INT_SUM))) {
 			panic("Unable to request_irq(OCTEON_IRQ_KEY)");
 		}
 		/* Disable any pending SLI interrupt */
-		if (cvmx_read_csr(CVMX_PEXP_SLI_INT_SUM) & 0x1) {
-			pr_info("clearing pending SLI_INT_SUM[RML_TO] (ignore)\n");
+		if (cvmx_read_csr(CVMX_PEXP_SLI_INT_SUM) & 0x1)	{
+			pr_info("clearing pending SLI_INT_SUM[RML_TO] (ignore)");
 			cvmx_write_csr(CVMX_PEXP_SLI_INT_SUM, 1);
 		}
-		if (request_irq(OCTEON_IRQ_SLI, octeon_rml_interrupt, IRQF_SHARED,
-					"SLI RML/RSL", octeon_rml_interrupt)) {
+		if (request_irq(OCTEON_IRQ_SLI, octeon_rml_interrupt_v2,
+					IRQF_SHARED, "SLI RML/RSL",
+					cvmx_error_get_index(
+						CVMX_PEXP_SLI_INT_SUM))) {
 			panic("Unable to request_irq(OCTEON_IRQ_SLI)");
 		}
-		if (request_irq(OCTEON_IRQ_DFA, octeon_rml_interrupt, IRQF_SHARED,
-					"DFA RML_RSL", octeon_rml_interrupt)) {
+		if (request_irq(OCTEON_IRQ_DFA, octeon_rml_interrupt_v2,
+					IRQF_SHARED, "DFA RML/RSL",
+					cvmx_error_get_index(CVMX_DFA_ERROR))) {
 			panic("Unable to request_irq(OCTEON_IRQ_DFA)");
 		}
-		if (request_irq(OCTEON_IRQ_DPI, octeon_rml_interrupt, IRQF_SHARED,
-					"DPI RML_RSL", octeon_rml_interrupt)) {
+		if (request_irq(OCTEON_IRQ_DPI, octeon_rml_interrupt_v2,
+					IRQF_SHARED, "DPI RML/RSL",
+					cvmx_error_get_index(CVMX_DPI_INT_REG))) {
 			panic("Unable to request_irq(OCTEON_IRQ_DPI)");
 		}
-		if (request_irq(OCTEON_IRQ_AGL, octeon_rml_interrupt, IRQF_SHARED,
-					"AGL RML_RSL", octeon_rml_interrupt)) {
+		if (request_irq(OCTEON_IRQ_AGL, octeon_rml_interrupt_v2,
+					IRQF_SHARED, "AGL RML/RSL",
+					cvmx_error_get_index(
+						CVMX_AGL_GMX_BAD_REG))) {
 			panic("Unable to request_irq(OCTEON_IRQ_AGL)");
 		}
 		for (i = 0; i < 4; i++) {
 			cvmx_lmcx_dll_ctl2_t ctl2;
+			cvmx_error_info_t *index;
 
 			/*
-			 * Check if LMC is initialized before enabling the
-			 * interrupts.
+			 * Check if LMC is initialized before enabling
+			 * the interrupts.
 			 */
 			ctl2.u64 = cvmx_read_csr(CVMX_LMCX_DLL_CTL2(i));
 			if (ctl2.s.intf_en == 0)
 				continue;
 
-			/* Clear pending interrupts before clearing it. */
+			/* Clear pending interrupts before enabling it. */
 			cvmx_write_csr(CVMX_LMCX_INT(i),
-					cvmx_read_csr(CVMX_LMCX_INT(i)));
+				       cvmx_read_csr(CVMX_LMCX_INT(i)));
 
+			index = cvmx_error_get_index(CVMX_LMCX_INT(i));
 			if (request_irq(OCTEON_IRQ_LMC0 + i,
-					octeon_rml_interrupt, IRQF_SHARED,
-					"LMC RML/RSL", octeon_rml_interrupt))
+					octeon_rml_interrupt_v2, IRQF_SHARED,
+					"LMC RML/RSL", index))
 				panic("Unable to request_irq(OCTEON_IRQ_LMC%d)", i);
 		}
 	} else {
-- 
1.7.0

