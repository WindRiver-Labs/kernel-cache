From 8e25b9f2d37a016c476e868851e0eeace4c6080e Mon Sep 17 00:00:00 2001
From: David Daney <ddaney@caviumnetworks.com>
Date: Mon, 15 Nov 2010 12:06:15 -0800
Subject: [PATCH 055/238] usb: octeon-hcd: Don't do callbacks from octeon_usb_urb_dequeue.

Source: Cavium SDK 2.1.0-407

It is not allowed to do any callbacks from octeon_usb_urb_dequeue(),
so defer them to a tasklet.

Signed-off-by: David Daney <ddaney@caviumnetworks.com>
Integrated-by: Phil Staub <Phil.Staub@windriver.com>
---
 drivers/usb/host/octeon-hcd.c |   62 ++++++++++++++++++++++++++++++++++------
 1 files changed, 52 insertions(+), 10 deletions(-)

diff --git a/drivers/usb/host/octeon-hcd.c b/drivers/usb/host/octeon-hcd.c
index 4faaa10..5d975e6 100644
--- a/drivers/usb/host/octeon-hcd.c
+++ b/drivers/usb/host/octeon-hcd.c
@@ -45,6 +45,8 @@
 struct octeon_hcd {
 	spinlock_t lock;
 	cvmx_usb_state_t usb;
+	struct tasklet_struct dequeue_tasklet;
+	struct list_head dequeue_list;
 };
 
 /* convert between an HCD pointer and the corresponding struct octeon_hcd */
@@ -136,6 +138,18 @@ static void octeon_usb_urb_complete_callback(cvmx_usb_state_t *usb,
 	urb->actual_length = bytes_transferred;
 	urb->hcpriv = NULL;
 
+	if (!list_empty(&urb->urb_list)) {
+		/*
+		 * It is on the dequeue_list, but we are going to call
+		 * usb_hcd_giveback_urb(), so we must clear it from
+		 * the list.  We got to it before the
+		 * octeon_usb_urb_dequeue_work() tasklet did.
+		 */
+		list_del(&urb->urb_list);
+		/* No longer on the dequeue_list. */
+		INIT_LIST_HEAD(&urb->urb_list);
+	}
+
 	/* For Isochronous transactions we need to update the URB packet status
 	   list from data in our private copy */
 	if (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {
@@ -167,7 +181,8 @@ static void octeon_usb_urb_complete_callback(cvmx_usb_state_t *usb,
 		urb->status = 0;
 		break;
 	case CVMX_USB_COMPLETE_CANCEL:
-		urb->status = -ENOENT;
+		if (urb->status == 0)
+			urb->status = -ENOENT;
 		break;
 	case CVMX_USB_COMPLETE_STALL:
 		DEBUG_ERROR("status=stall pipe=%d submit=%d size=%d\n", pipe_handle, submit_handle, bytes_transferred);
@@ -206,6 +221,9 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 	struct usb_host_endpoint *ep = urb->ep;
 
 	DEBUG_CALL();
+
+	urb->status = 0;
+	INIT_LIST_HEAD(&urb->urb_list); /* not enqueued on dequeue_list */
 	spin_lock_irqsave(&priv->lock, flags);
 
 	if (!ep->hcpriv) {
@@ -348,11 +366,31 @@ static int octeon_usb_urb_enqueue(struct usb_hcd *hcd,
 	return 0;
 }
 
+static void octeon_usb_urb_dequeue_work(unsigned long arg)
+{
+	unsigned long flags;
+	struct octeon_hcd *priv = (struct octeon_hcd *)arg;
+
+	spin_lock_irqsave(&priv->lock, flags);
+
+	while (!list_empty(&priv->dequeue_list)) {
+		int pipe_handle;
+		int submit_handle;
+		struct urb *urb = container_of(priv->dequeue_list.next, struct urb, urb_list);
+		list_del(&urb->urb_list);
+		/* not enqueued on dequeue_list */
+		INIT_LIST_HEAD(&urb->urb_list);
+		pipe_handle = 0xffff & (long)urb->hcpriv;
+		submit_handle = ((long)urb->hcpriv) >> 16;
+		cvmx_usb_cancel(&priv->usb, pipe_handle, submit_handle);
+	}
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
 static int octeon_usb_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)
 {
 	struct octeon_hcd *priv = hcd_to_octeon(hcd);
-	int pipe_handle;
-	int submit_handle;
 	unsigned long flags;
 
 	DEBUG_CALL();
@@ -360,15 +398,15 @@ static int octeon_usb_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int stat
 	if (!urb->dev)
 		return -EINVAL;
 
-	pipe_handle = 0xffff & (long)urb->hcpriv;
-	submit_handle = ((long)urb->hcpriv) >> 16;
 	spin_lock_irqsave(&priv->lock, flags);
-	if (cvmx_usb_cancel(&priv->usb, pipe_handle, submit_handle)) {
-		spin_unlock_irqrestore(&priv->lock, flags);
-		DEBUG_ERROR("Canceling URB failed\n");
-		return -1;
-	}
+
+	urb->status = status;
+	list_add_tail(&urb->urb_list, &priv->dequeue_list);
+
 	spin_unlock_irqrestore(&priv->lock, flags);
+
+	tasklet_schedule(&priv->dequeue_tasklet);
+
 	return 0;
 }
 
@@ -647,6 +685,9 @@ static int octeon_usb_driver_probe(struct device *dev)
 
 	spin_lock_init(&priv->lock);
 
+	tasklet_init(&priv->dequeue_tasklet, octeon_usb_urb_dequeue_work, (unsigned long)priv);
+	INIT_LIST_HEAD(&priv->dequeue_list);
+
 	initialize_flags = CVMX_USB_INITIALIZE_FLAGS_CLOCK_AUTO;
 
 #ifdef OCTEON_HCD_DEBUG
@@ -690,6 +731,7 @@ static int octeon_usb_driver_remove(struct device *dev)
 	DEBUG_CALL();
 
 	usb_remove_hcd(hcd);
+	tasklet_kill(&priv->dequeue_tasklet);
 	spin_lock_irqsave(&priv->lock, flags);
 	status = cvmx_usb_shutdown(&priv->usb);
 	spin_unlock_irqrestore(&priv->lock, flags);
-- 
1.7.0

