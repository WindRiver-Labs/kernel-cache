From d03ceebaea5e5efe76298abe27b0de7e84d93e2d Mon Sep 17 00:00:00 2001
From: David Daney <david.daney@cavium.com>
Date: Wed, 22 Feb 2012 14:15:23 -0800
Subject: [PATCH 230/238] mmc: octeon_mmc: Improve error handling and use correct timeouts

Source: Cavium SDK 2.3-427

Improve error handling and use correct timeouts.

Signed-off-by: David Daney <david.daney@cavium.com>
Integrated-by: Jiang Bin <bin.jiang@windriver.com>
---
 drivers/mmc/host/octeon_mmc.c |   83 ++++++++++++++++++++++++++++-------------
 1 files changed, 57 insertions(+), 26 deletions(-)

diff --git a/drivers/mmc/host/octeon_mmc.c b/drivers/mmc/host/octeon_mmc.c
index caade58..943d40b 100644
--- a/drivers/mmc/host/octeon_mmc.c
+++ b/drivers/mmc/host/octeon_mmc.c
@@ -84,13 +84,21 @@ struct octeon_mmc_slot {
 
 static void octeon_mmc_reset_bus(struct octeon_mmc_slot *slot, int preserve);
 
-static bool octeon_mmc_switch_val_changed(struct octeon_mmc_slot *slot, u64 new_val)
+static bool octeon_mmc_switch_val_changed(struct octeon_mmc_slot *slot,
+					  u64 new_val)
 {
 	/* Match BUS_ID, HS_TIMING, BUS_WIDTH, POWER_CLASS, CLK_HI, CLK_LO */
 	u64 m = 0x3001070fffffffffull;
 	return (slot->host->last_emm_switch & m) != (new_val & m);
 }
 
+static unsigned int octeon_mmc_timeout_to_wdog(struct octeon_mmc_slot *slot,
+					       unsigned int ns)
+{
+	u64 bt = (u64)slot->clock * (u64)ns;
+	return (unsigned int)(bt / 1000000000);
+}
+
 static void octeon_mmc_dma_next(struct octeon_mmc_host	*host)
 {
 	struct scatterlist *sg;
@@ -151,7 +159,7 @@ static irqreturn_t octeon_mmc_interrupt(int irq, void *dev_id)
 	union cvmx_mio_emm_int emm_int;
 	struct mmc_request	*req;
 	bool host_done;
-	u64 rsp_sts;
+	union cvmx_mio_emm_rsp_sts rsp_sts;
 	unsigned long flags;
 
 	spin_lock_irqsave(&host->lock, flags);
@@ -164,12 +172,13 @@ static irqreturn_t octeon_mmc_interrupt(int irq, void *dev_id)
 	if (!req)
 		goto out;
 
-	rsp_sts = cvmx_read_csr(host->base + OCT_MIO_EMM_RSP_STS);
-	pr_debug("octeon_mmc_interrupt  MIO_EMM_RSP_STS 0x%llx\n", rsp_sts);
+	rsp_sts.u64 = cvmx_read_csr(host->base + OCT_MIO_EMM_RSP_STS);
+	pr_debug("octeon_mmc_interrupt  MIO_EMM_RSP_STS 0x%llx\n", rsp_sts.u64);
 
-	if (!host->dma_active && emm_int.s.buf_done && req->cmd->data && ((rsp_sts >> 7) & 3) == 1) {
+	if (!host->dma_active && emm_int.s.buf_done && req->cmd->data &&
+	    ((rsp_sts.u64 >> 7) & 3) == 1) {
 		/* Read */
-		int dbuf = (rsp_sts >> 23) & 1;
+		int dbuf = rsp_sts.s.dbuf;
 		struct sg_mapping_iter *smi = &host->smi;
 		unsigned int bytes_xfered = 0;
 		u64 dat = 0;
@@ -201,13 +210,10 @@ static irqreturn_t octeon_mmc_interrupt(int irq, void *dev_id)
 		req->cmd->data->bytes_xfered = bytes_xfered;
 		req->cmd->data->error = 0;
 	}
-	host_done = emm_int.s.cmd_done || emm_int.s.dma_done || emm_int.s.cmd_err;
+	host_done = emm_int.s.cmd_done || emm_int.s.dma_done ||
+		emm_int.s.cmd_err || emm_int.s.dma_err;
 	if (host_done && req->done) {
-		int rsp_val;
-
-		rsp_val = (rsp_sts >> 12) & 1;
-
-		if (rsp_sts & (7ull << 13))
+		if (rsp_sts.u64 & (7ull << 13))
 			req->cmd->error = -EILSEQ;
 		else
 			req->cmd->error = 0;
@@ -216,12 +222,11 @@ static irqreturn_t octeon_mmc_interrupt(int irq, void *dev_id)
 			req->cmd->data->error = 0;
 			req->cmd->data->bytes_xfered = req->cmd->data->blocks * req->cmd->data->blksz;
 		}
-		if (rsp_val) {
+		if (rsp_sts.s.rsp_val) {
 			u64 rsp_hi;
-			int rsp_type = (rsp_sts >> 9) & 7;
 			u64 rsp_lo = cvmx_read_csr(host->base + OCT_MIO_EMM_RSP_LO);
 
-			switch (rsp_type) {
+			switch (rsp_sts.s.rsp_type) {
 			case 1:
 			case 3:
 				req->cmd->resp[0] = (rsp_lo >> 8) & 0xffffffff;
@@ -237,12 +242,22 @@ static irqreturn_t octeon_mmc_interrupt(int irq, void *dev_id)
 				req->cmd->resp[0] = (rsp_hi >> 32) & 0xffffffff;
 				break;
 			default:
-				pr_debug("octeon_mmc_interrupt unhandled rsp_val %d\n", rsp_type);
+				pr_debug("octeon_mmc_interrupt unhandled rsp_val %d\n",
+					 rsp_sts.s.rsp_type);
 				break;
 			}
 			pr_debug("octeon_mmc_interrupt  resp %08x %08x %08x %08x\n",
 				 req->cmd->resp[0], req->cmd->resp[1], req->cmd->resp[2], req->cmd->resp[3]);
 		}
+		if (emm_int.s.dma_err && rsp_sts.s.dma_pend) {
+			/* Try to clean up failed DMA */
+			union cvmx_mio_emm_dma emm_dma;
+			emm_dma.u64 = 0;
+			emm_dma.s.dma_val = 1;
+			emm_dma.s.dat_null = 1;
+			emm_dma.s.bus_id = rsp_sts.s.bus_id;
+			cvmx_write_csr(host->base + OCT_MIO_EMM_DMA, emm_dma.u64);
+		}
 
 		host->current_req = NULL;
 		req->done(req);
@@ -282,6 +297,11 @@ static void octeon_mmc_dma_request(struct mmc_host *mmc, struct mmc_request *mrq
 
 	data = mrq->data;
 
+	if (data->timeout_ns) {
+		cvmx_write_csr(host->base + OCT_MIO_EMM_WDOG,
+			       octeon_mmc_timeout_to_wdog(slot, data->timeout_ns));
+			pr_debug("OCT_MIO_EMM_WDOG %llu\n", cvmx_read_csr(host->base + OCT_MIO_EMM_WDOG));	}
+
 	spin_lock_irqsave(&host->lock, flags);
 	WARN_ON(host->current_req);
 	host->current_req = mrq;
@@ -305,6 +325,7 @@ static void octeon_mmc_dma_request(struct mmc_host *mmc, struct mmc_request *mrq
 	emm_int.u64 = 0;
 	emm_int.s.dma_done = 1;
 	emm_int.s.cmd_err = 1;
+	emm_int.s.dma_err = 1;
 	/* Clear the bit. */
 	cvmx_write_csr(host->base + OCT_MIO_EMM_INT, emm_int.u64);
 	cvmx_write_csr(host->base + OCT_MIO_EMM_INT_EN, emm_int.u64);
@@ -387,6 +408,14 @@ static void octeon_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
 			cmd->data->bytes_xfered = bytes_xfered;
 			cmd->data->error = 0;
 		}
+		if (cmd->data->timeout_ns) {
+			cvmx_write_csr(host->base + OCT_MIO_EMM_WDOG,
+				       octeon_mmc_timeout_to_wdog(slot, cmd->data->timeout_ns));
+			pr_debug("OCT_MIO_EMM_WDOG %llu\n", cvmx_read_csr(host->base + OCT_MIO_EMM_WDOG));		}
+	} else {
+		cvmx_write_csr(host->base + OCT_MIO_EMM_WDOG,
+			       ((u64)slot->clock * 850ull) / 1000ull);
+			pr_debug("OCT_MIO_EMM_WDOG %llu\n", cvmx_read_csr(host->base + OCT_MIO_EMM_WDOG));
 	}
 	/* Clear the bit. */
 	cvmx_write_csr(host->base + OCT_MIO_EMM_INT, emm_int.u64);
@@ -399,7 +428,7 @@ static void octeon_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
 	emm_cmd.s.bus_id = slot->bus_id;
 	emm_cmd.s.cmd_idx = cmd->opcode;
 	emm_cmd.s.arg = cmd->arg;
-	cvmx_write_csr(CVMX_MIO_EMM_CMD, emm_cmd.u64);
+	cvmx_write_csr(host->base + OCT_MIO_EMM_CMD, emm_cmd.u64);
 	pr_debug("Send the command: %llx\n", emm_cmd.u64);
 
 }
@@ -474,13 +503,13 @@ static void octeon_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
 		}
 
 		pr_debug("Writing 0x%llx to mio_emm_wdog\n", ((u64)clock * 850ull) / 1000ull);
-		cvmx_write_csr(CVMX_MIO_EMM_WDOG, ((u64)clock * 850ull) / 1000ull);
+		cvmx_write_csr(host->base + OCT_MIO_EMM_WDOG, ((u64)clock * 850ull) / 1000ull);
 		pr_debug("Writing 0x%llx to mio_emm_switch\n", emm_switch.u64);
-		cvmx_write_csr(CVMX_MIO_EMM_SWITCH, emm_switch.u64);
+		cvmx_write_csr(host->base + OCT_MIO_EMM_SWITCH, emm_switch.u64);
 		slot->host->last_emm_switch = emm_switch.u64;
 
 		do {
-			emm_sts.u64 = cvmx_read_csr(CVMX_MIO_EMM_RSP_STS);
+			emm_sts.u64 = cvmx_read_csr(host->base + OCT_MIO_EMM_RSP_STS);
 			if (!emm_sts.s.switch_val)
 				break;
 			udelay(100);
@@ -554,6 +583,7 @@ static int octeon_mmc_initlowlevel(struct octeon_mmc_slot *slot, int id,
 			int bus_width)
 {
 	union cvmx_mio_emm_switch emm_switch;
+	struct octeon_mmc_host *host = slot->host;
 
 	octeon_mmc_reset_bus(slot, 0);
 
@@ -566,8 +596,9 @@ static int octeon_mmc_initlowlevel(struct octeon_mmc_slot *slot, int id,
 	emm_switch.s.clk_hi = (slot->sclock / slot->clock) / 2;
 	emm_switch.s.clk_lo = (slot->sclock / slot->clock) / 2;
 	slot->host->last_emm_switch = emm_switch.u64;
-	cvmx_write_csr(CVMX_MIO_EMM_SWITCH, emm_switch.u64);
-	cvmx_write_csr(CVMX_MIO_EMM_WDOG, ((u64)slot->clock * 850ull) / 1000ull);
+	cvmx_write_csr(host->base + OCT_MIO_EMM_SWITCH, emm_switch.u64);
+	cvmx_write_csr(host->base + OCT_MIO_EMM_WDOG, ((u64)slot->clock * 850ull) / 1000ull);
+	cvmx_write_csr(host->base + OCT_MIO_EMM_STS_MASK, 0xe4f90080ull);
 
 	return 0;
 }
@@ -764,7 +795,7 @@ static int __init octeon_mmc_probe(struct platform_device *pdev)
 err:
 	/* Disable MMC controller */
 	emm_cfg.s.bus_ena = 0;
-	cvmx_write_csr(CVMX_MIO_EMM_CFG, emm_cfg.u64);
+	cvmx_write_csr(host->base + OCT_MIO_EMM_CFG, emm_cfg.u64);
 	return ret;
 }
 
@@ -777,13 +808,13 @@ static int octeon_mmc_remove(struct platform_device *pdev)
 	pr_debug("Calling mmc_remove, host = %p\n", host);
 	if (host) {
 		/* Reset bus_id */
-		ndf_dma_cfg.u64 = cvmx_read_csr(CVMX_MIO_NDF_DMA_CFG);
+		ndf_dma_cfg.u64 = cvmx_read_csr(host->ndf_base + OCT_MIO_NDF_DMA_CFG);
 		ndf_dma_cfg.s.en = 0;
-		cvmx_write_csr(CVMX_MIO_NDF_DMA_CFG, ndf_dma_cfg.u64);
+		cvmx_write_csr(host->ndf_base + OCT_MIO_NDF_DMA_CFG, ndf_dma_cfg.u64);
 
 		/* Disable the interrupt */
 		ndf_dma_int.u64 = 0;
-		cvmx_write_csr(CVMX_MIO_NDF_DMA_INT, ndf_dma_int.u64);
+		cvmx_write_csr(host->ndf_base + OCT_MIO_NDF_DMA_INT, ndf_dma_int.u64);
 
 		pr_debug("MMC Removed\n");
 	}
-- 
1.7.0

