From da1005135d1abc63c23622d0faae6eb912772e0c Mon Sep 17 00:00:00 2001
From: Dong Aisheng <aisheng.dong@nxp.com>
Date: Wed, 31 Aug 2016 21:07:21 +0800
Subject: [PATCH 79/85] MLK-13179-2 bcmdhd: add OOB feature switch function
 and P2P stability fix

The patch is delivered by Cypress to add OOB switch interface
and a P2P stability fix.

Whether to enable OOB is controlled by the gpios property under
bcmdhd_wlan_0 node.
e.g.
        bcmdhd_wlan_0: bcmdhd_wlan@0 {
                compatible = "android,bcmdhd_wlan";
                gpios = <&gpio5 20 0>; /* WL_HOST_WAKE */
                wlreg_on-supply = <&wlreg_on>;
        };

If valid gpios property found, then driver will consider to use
OOB feature.

Signed-off-by: Dong Aisheng <aisheng.dong@nxp.com>
(cherry picked from commit a1f93352b071d37697ad7c09c9bb910482d5a77e)
[zou:Original patch taken from
git://git.freescale.com/imx/linux-imx.git imx_4.1.15_2.0.0_ga]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/net/wireless/bcmdhd/Makefile             |    7 +-
 drivers/net/wireless/bcmdhd/bcmsdh_linux.c       |   24 ++--
 drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.c       |  153 +++++++++++++---------
 drivers/net/wireless/bcmdhd/bcmsdh_sdmmc_linux.c |   14 ++-
 drivers/net/wireless/bcmdhd/bcmspibrcm.c         |   26 ++--
 drivers/net/wireless/bcmdhd/dhd.h                |   20 +++-
 drivers/net/wireless/bcmdhd/dhd_common.c         |   26 ++++-
 drivers/net/wireless/bcmdhd/dhd_linux.c          |   52 +++++---
 drivers/net/wireless/bcmdhd/dhd_linux_platdev.c  |   88 ++++++++-----
 drivers/net/wireless/bcmdhd/dhd_sdio.c           |  115 ++++++++++-------
 drivers/net/wireless/bcmdhd/include/bcmsdstd.h   |    6 +-
 drivers/net/wireless/bcmdhd/include/epivers.h    |   10 +-
 drivers/net/wireless/bcmdhd/include/linux_osl.h  |    4 +-
 drivers/net/wireless/bcmdhd/wl_cfg80211.c        |  140 ++++++++++++++++----
 drivers/net/wireless/bcmdhd/wl_cfg80211.h        |    3 +-
 drivers/net/wireless/bcmdhd/wl_cfg_btcoex.c      |    8 +-
 16 files changed, 451 insertions(+), 245 deletions(-)

diff --git a/drivers/net/wireless/bcmdhd/Makefile b/drivers/net/wireless/bcmdhd/Makefile
index c3fea8d..5ee0fb1 100644
--- a/drivers/net/wireless/bcmdhd/Makefile
+++ b/drivers/net/wireless/bcmdhd/Makefile
@@ -11,7 +11,7 @@ DHDCFLAGS += -Wall -Wstrict-prototypes -Dlinux -DLINUX -DBCMDRIVER            \
 	-DEMBEDDED_PLATFORM -DPNO_SUPPORT                                     \
 	-DDHD_DONOT_FORWARD_BCMEVENT_AS_NETWORK_PKT                           \
 	-DCUSTOMER_HW2 -DGET_CUSTOM_MAC_ENABLE	\
-	-DCONFIG_DTS
+	-DCONFIG_DTS -DCUSTOMER_IMX
 
 #################
 # Common feature
@@ -151,9 +151,8 @@ ifneq ($(CONFIG_BCM4339),)
 endif
 
 ifneq ($(CONFIG_BCMDHD_SDIO),)
-#  DHDCFLAGS += -DBDC -DOOB_INTR_ONLY -DDHD_BCMEVENTS -DMMC_SDIO_ABORT -DHW_OOB
-  DHDCFLAGS += -DBDC -DSDIO_ISR_THREAD -DDHD_BCMEVENTS -DMMC_SDIO_ABORT
-  DHDCFLAGS += -DBCMSDIO -DBCMLXSDMMC -DUSE_SDIOFIFO_IOVAR
+  DHDCFLAGS += -DBDC -DOOB_INTR_ONLY -DDHD_BCMEVENTS -DMMC_SDIO_ABORT -DOOB_PARAM -DHW_OOB
+  DHDCFLAGS += -DBCMSDIO -DBCMLXSDMMC -DUSE_SDIOFIFO_IOVAR -DDHD_VERSION_NO_DATE_TIME
 endif
 
 ifneq ($(CONFIG_BCMDHD_PCIE),)
diff --git a/drivers/net/wireless/bcmdhd/bcmsdh_linux.c b/drivers/net/wireless/bcmdhd/bcmsdh_linux.c
index 5917344..3eb4a48 100644
--- a/drivers/net/wireless/bcmdhd/bcmsdh_linux.c
+++ b/drivers/net/wireless/bcmdhd/bcmsdh_linux.c
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmsdh_linux.c 599866 2015-11-17 03:16:31Z $
+ * $Id: bcmsdh_linux.c 634247 2016-04-27 05:53:55Z $
  */
 
 /**
@@ -84,6 +84,10 @@ typedef struct bcmsdh_os_info {
 /* debugging macros */
 #define SDLX_MSG(x)
 
+#if defined(OOB_PARAM)
+extern uint dhd_oob_disable;
+#endif /* OOB_PARAM */
+
 /**
  * Checks to see if vendor and device IDs match a supported SDIO Host Controller.
  */
@@ -164,15 +168,17 @@ void* bcmsdh_probe(osl_t *osh, void *dev, void *sdioh, void *adapter_info, uint
 #endif /* !defined(CONFIG_HAS_WAKELOCK) && (LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 36)) */
 
 #if defined(OOB_INTR_ONLY)
-	spin_lock_init(&bcmsdh_osinfo->oob_irq_spinlock);
-	/* Get customer specific OOB IRQ parametres: IRQ number as IRQ type */
-	bcmsdh_osinfo->oob_irq_num = wifi_platform_get_irq_number(adapter_info,
-		&bcmsdh_osinfo->oob_irq_flags);
-	if  (bcmsdh_osinfo->oob_irq_num < 0) {
-		SDLX_MSG(("%s: Host OOB irq is not defined\n", __FUNCTION__));
-		goto err;
+	OOB_PARAM_IF(!dhd_oob_disable) {
+		spin_lock_init(&bcmsdh_osinfo->oob_irq_spinlock);
+		/* Get customer specific OOB IRQ parametres: IRQ number as IRQ type */
+		bcmsdh_osinfo->oob_irq_num = wifi_platform_get_irq_number(adapter_info,
+			&bcmsdh_osinfo->oob_irq_flags);
+		if  (bcmsdh_osinfo->oob_irq_num < 0) {
+			SDLX_MSG(("%s: Host OOB irq is not defined\n", __FUNCTION__));
+			goto err;
+		}
 	}
-#endif /* defined(BCMLXSDMMC) */
+#endif /* defined(OOB_INTR_ONLY) */
 
 	/* Read the vendor/device ID from the CIS */
 	vendevid = bcmsdh_query_device(bcmsdh);
diff --git a/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.c b/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.c
index a2ac5c0..edaf1cf 100644
--- a/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.c
+++ b/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc.c
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmsdh_sdmmc.c 557203 2015-05-18 02:05:14Z $
+ * $Id: bcmsdh_sdmmc.c 643045 2016-06-13 06:02:06Z $
  */
 #include <typedefs.h>
 
@@ -54,10 +54,13 @@ extern int sdio_function_init(void);
 extern void sdio_function_cleanup(void);
 #endif /* BCMSDH_MODULE */
 
-#if !defined(OOB_INTR_ONLY)
+#if defined(OOB_PARAM)
+extern uint dhd_oob_disable;
+#endif /* OOB_PARAM */
+#if !defined(OOB_INTR_ONLY) || defined(OOB_PARAM)
 static void IRQHandler(struct sdio_func *func);
 static void IRQHandlerF2(struct sdio_func *func);
-#endif /* !defined(OOB_INTR_ONLY) */
+#endif /* !defined(OOB_INTR_ONLY) || defined(OOB_PARAM) */
 static int sdioh_sdmmc_get_cisaddr(sdioh_info_t *sd, uint32 regaddr);
 extern int sdio_reset_comm(struct mmc_card *card);
 
@@ -302,26 +305,31 @@ sdioh_interrupt_register(sdioh_info_t *sd, sdioh_cb_fn_t fn, void *argh)
 		sd_err(("%s: interrupt handler is NULL, not registering\n", __FUNCTION__));
 		return SDIOH_API_RC_FAIL;
 	}
-#if !defined(OOB_INTR_ONLY)
-	sd->intr_handler = fn;
-	sd->intr_handler_arg = argh;
-	sd->intr_handler_valid = TRUE;
-
-	/* register and unmask irq */
-	if (sd->func[2]) {
-		sdio_claim_host(sd->func[2]);
-		sdio_claim_irq(sd->func[2], IRQHandlerF2);
-		sdio_release_host(sd->func[2]);
-	}
+#if !defined(OOB_INTR_ONLY) || defined(OOB_PARAM)
+	OOB_PARAM_IF(dhd_oob_disable) {
+		sd->intr_handler = fn;
+		sd->intr_handler_arg = argh;
+		sd->intr_handler_valid = TRUE;
+
+		/* register and unmask irq */
+		if (sd->func[2]) {
+			sdio_claim_host(sd->func[2]);
+			sdio_claim_irq(sd->func[2], IRQHandlerF2);
+			sdio_release_host(sd->func[2]);
+		}
 
-	if (sd->func[1]) {
-		sdio_claim_host(sd->func[1]);
-		sdio_claim_irq(sd->func[1], IRQHandler);
-		sdio_release_host(sd->func[1]);
+		if (sd->func[1]) {
+			sdio_claim_host(sd->func[1]);
+			sdio_claim_irq(sd->func[1], IRQHandler);
+			sdio_release_host(sd->func[1]);
+		}
+	} OOB_PARAM_ELSE()
+#endif /* !defined(OOB_INTR_ONLY) || defined(OOB_PARAM) */
+#if defined(OOB_INTR_ONLY) && defined(HW_OOB)
+	{
+		sdioh_enable_func_intr(sd);
 	}
-#elif defined(HW_OOB)
-	sdioh_enable_func_intr(sd);
-#endif /* !defined(OOB_INTR_ONLY) */
+#endif /* defined(OOB_INTR_ONLY) && defined(HW_OOB) */
 
 	return SDIOH_API_RC_SUCCESS;
 }
@@ -331,28 +339,33 @@ sdioh_interrupt_deregister(sdioh_info_t *sd)
 {
 	sd_trace(("%s: Entering\n", __FUNCTION__));
 
-#if !defined(OOB_INTR_ONLY)
-	if (sd->func[1]) {
-		/* register and unmask irq */
-		sdio_claim_host(sd->func[1]);
-		sdio_release_irq(sd->func[1]);
-		sdio_release_host(sd->func[1]);
-	}
+#if !defined(OOB_INTR_ONLY) || defined(OOB_PARAM)
+	OOB_PARAM_IF(dhd_oob_disable) {
+		if (sd->func[1]) {
+			/* register and unmask irq */
+			sdio_claim_host(sd->func[1]);
+			sdio_release_irq(sd->func[1]);
+			sdio_release_host(sd->func[1]);
+		}
 
-	if (sd->func[2]) {
-		/* Claim host controller F2 */
-		sdio_claim_host(sd->func[2]);
-		sdio_release_irq(sd->func[2]);
-		/* Release host controller F2 */
-		sdio_release_host(sd->func[2]);
-	}
+		if (sd->func[2]) {
+			/* Claim host controller F2 */
+			sdio_claim_host(sd->func[2]);
+			sdio_release_irq(sd->func[2]);
+			/* Release host controller F2 */
+			sdio_release_host(sd->func[2]);
+		}
 
-	sd->intr_handler_valid = FALSE;
-	sd->intr_handler = NULL;
-	sd->intr_handler_arg = NULL;
-#elif defined(HW_OOB)
-	sdioh_disable_func_intr(sd);
-#endif /* !defined(OOB_INTR_ONLY) */
+		sd->intr_handler_valid = FALSE;
+		sd->intr_handler = NULL;
+		sd->intr_handler_arg = NULL;
+	} OOB_PARAM_ELSE()
+#endif /* !defined(OOB_INTR_ONLY) || defined(OOB_PARAM) */
+#if defined(OOB_INTR_ONLY) && defined(HW_OOB)
+	{
+		sdioh_disable_func_intr(sd);
+	}
+#endif /* defined(OOB_INTR_ONLY) && defined(HW_OOB) */
 	return SDIOH_API_RC_SUCCESS;
 }
 
@@ -1249,7 +1262,7 @@ sdioh_sdmmc_card_regread(sdioh_info_t *sd, int func, uint32 regaddr, int regsize
 	return SUCCESS;
 }
 
-#if !defined(OOB_INTR_ONLY)
+#if !defined(OOB_INTR_ONLY) || defined(OOB_PARAM)
 /* bcmsdh_sdmmc interrupt handler */
 static void IRQHandler(struct sdio_func *func)
 {
@@ -1280,7 +1293,7 @@ static void IRQHandlerF2(struct sdio_func *func)
 {
 	sd_trace(("bcmsdh_sdmmc: ***IRQHandlerF2\n"));
 }
-#endif /* !defined(OOB_INTR_ONLY) */
+#endif /* !defined(OOB_INTR_ONLY) || defined(OOB_PARAM) */
 
 #ifdef NOTUSED
 /* Write client card reg */
@@ -1377,18 +1390,23 @@ sdioh_start(sdioh_info_t *sd, int stage)
 			sdioh_sdmmc_card_enablefuncs(sd);
 			}
 		} else {
-#if !defined(OOB_INTR_ONLY)
-			sdio_claim_host(sd->func[0]);
-			if (sd->func[2])
-				sdio_claim_irq(sd->func[2], IRQHandlerF2);
-			if (sd->func[1])
-				sdio_claim_irq(sd->func[1], IRQHandler);
-			sdio_release_host(sd->func[0]);
-#else /* defined(OOB_INTR_ONLY) */
+#if !defined(OOB_INTR_ONLY) || defined(OOB_PARAM)
+			OOB_PARAM_IF(dhd_oob_disable) {
+				sdio_claim_host(sd->func[0]);
+				if (sd->func[2])
+					sdio_claim_irq(sd->func[2], IRQHandlerF2);
+				if (sd->func[1])
+					sdio_claim_irq(sd->func[1], IRQHandler);
+				sdio_release_host(sd->func[0]);
+			} OOB_PARAM_ELSE()
+#endif /* !defined(OOB_INTR_ONLY) || defined(OOB_PARAM) */
+#if defined(OOB_INTR_ONLY)
+			{
 #if defined(HW_OOB)
-			sdioh_enable_func_intr(sd);
-#endif
-			bcmsdh_oob_intr_set(sd->bcmsdh, TRUE);
+				sdioh_enable_func_intr(sd);
+#endif /* defined(HW_OOB) */
+				bcmsdh_oob_intr_set(sd->bcmsdh, TRUE);
+			}
 #endif /* !defined(OOB_INTR_ONLY) */
 		}
 	}
@@ -1408,19 +1426,24 @@ sdioh_stop(sdioh_info_t *sd)
 		polling
 	*/
 	if (sd->func[0]) {
-#if !defined(OOB_INTR_ONLY)
-		sdio_claim_host(sd->func[0]);
-		if (sd->func[1])
-			sdio_release_irq(sd->func[1]);
-		if (sd->func[2])
-			sdio_release_irq(sd->func[2]);
-		sdio_release_host(sd->func[0]);
-#else /* defined(OOB_INTR_ONLY) */
+#if !defined(OOB_INTR_ONLY) || defined(OOB_PARAM)
+		OOB_PARAM_IF(dhd_oob_disable) {
+			sdio_claim_host(sd->func[0]);
+			if (sd->func[1])
+				sdio_release_irq(sd->func[1]);
+			if (sd->func[2])
+				sdio_release_irq(sd->func[2]);
+			sdio_release_host(sd->func[0]);
+		} OOB_PARAM_ELSE()
+#endif /* !defined(OOB_INTR_ONLY) || defined(OOB_PARAM) */
+#if defined(OOB_INTR_ONLY)
+		{
 #if defined(HW_OOB)
-		sdioh_disable_func_intr(sd);
+			sdioh_disable_func_intr(sd);
 #endif
-		bcmsdh_oob_intr_set(sd->bcmsdh, FALSE);
-#endif /* !defined(OOB_INTR_ONLY) */
+			bcmsdh_oob_intr_set(sd->bcmsdh, FALSE);
+		}
+#endif /* defined(OOB_INTR_ONLY) */
 	}
 	else
 		sd_err(("%s Failed\n", __FUNCTION__));
diff --git a/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc_linux.c b/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc_linux.c
index c7becf2..03bb701 100644
--- a/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc_linux.c
+++ b/drivers/net/wireless/bcmdhd/bcmsdh_sdmmc_linux.c
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmsdh_sdmmc_linux.c 523920 2015-01-05 06:07:16Z $
+ * $Id: bcmsdh_sdmmc_linux.c 634247 2016-04-27 05:53:55Z $
  */
 
 #include <typedefs.h>
@@ -96,6 +96,10 @@ MODULE_PARM_DESC(clockoverride, "SDIO card clock override");
 
 extern volatile bool dhd_mmc_suspend;
 
+#if defined(OOB_PARAM)
+extern uint dhd_oob_disable;
+#endif /* OOB_PARAM */
+
 static int sdioh_probe(struct sdio_func *func)
 {
 	int host_idx = func->card->host->index;
@@ -251,7 +255,9 @@ static int bcmsdh_sdmmc_suspend(struct device *pdev)
 		return err;
 	}
 #if defined(OOB_INTR_ONLY)
-	bcmsdh_oob_intr_set(sdioh->bcmsdh, FALSE);
+	OOB_PARAM_IF(!dhd_oob_disable) {
+		bcmsdh_oob_intr_set(sdioh->bcmsdh, FALSE);
+	}
 #endif 
 	smp_mb();
 
@@ -270,7 +276,9 @@ static int bcmsdh_sdmmc_resume(struct device *pdev)
 	sdioh = sdio_get_drvdata(func);
 	dhd_mmc_suspend = FALSE;
 #if defined(OOB_INTR_ONLY)
-	bcmsdh_resume(sdioh->bcmsdh);
+	OOB_PARAM_IF(!dhd_oob_disable) {
+		bcmsdh_resume(sdioh->bcmsdh);
+	}
 #endif 
 
 	smp_mb();
diff --git a/drivers/net/wireless/bcmdhd/bcmspibrcm.c b/drivers/net/wireless/bcmdhd/bcmspibrcm.c
index 2ddda96..c286a2be 100644
--- a/drivers/net/wireless/bcmdhd/bcmspibrcm.c
+++ b/drivers/net/wireless/bcmdhd/bcmspibrcm.c
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmspibrcm.c 373331 2012-12-07 04:46:22Z $
+ * $Id: bcmspibrcm.c 634247 2016-04-27 05:53:55Z $
  */
 
 #define HSMODE
@@ -199,11 +199,13 @@ extern SDIOH_API_RC
 sdioh_interrupt_register(sdioh_info_t *sd, sdioh_cb_fn_t fn, void *argh)
 {
 	sd_trace(("%s: Entering\n", __FUNCTION__));
-#if !defined(OOB_INTR_ONLY)
-	sd->intr_handler = fn;
-	sd->intr_handler_arg = argh;
-	sd->intr_handler_valid = TRUE;
-#endif /* !defined(OOB_INTR_ONLY) */
+#if !defined(OOB_INTR_ONLY) || defined(OOB_PARAM)
+	OOB_PARAM_IF(dhd_oob_disable) {
+		sd->intr_handler = fn;
+		sd->intr_handler_arg = argh;
+		sd->intr_handler_valid = TRUE;
+	}
+#endif /* !defined(OOB_INTR_ONLY) || defined(OOB_PARAM) */
 	return SDIOH_API_RC_SUCCESS;
 }
 
@@ -211,11 +213,13 @@ extern SDIOH_API_RC
 sdioh_interrupt_deregister(sdioh_info_t *sd)
 {
 	sd_trace(("%s: Entering\n", __FUNCTION__));
-#if !defined(OOB_INTR_ONLY)
-	sd->intr_handler_valid = FALSE;
-	sd->intr_handler = NULL;
-	sd->intr_handler_arg = NULL;
-#endif /* !defined(OOB_INTR_ONLY) */
+#if !defined(OOB_INTR_ONLY) || defined(OOB_PARAM)
+	OOB_PARAM_IF(dhd_oob_disable) {
+		sd->intr_handler_valid = FALSE;
+		sd->intr_handler = NULL;
+		sd->intr_handler_arg = NULL;
+	}
+#endif /* !defined(OOB_INTR_ONLY) || defined(OOB_PARAM) */
 	return SDIOH_API_RC_SUCCESS;
 }
 
diff --git a/drivers/net/wireless/bcmdhd/dhd.h b/drivers/net/wireless/bcmdhd/dhd.h
index d61907a..fab855c 100644
--- a/drivers/net/wireless/bcmdhd/dhd.h
+++ b/drivers/net/wireless/bcmdhd/dhd.h
@@ -24,7 +24,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: dhd.h 557502 2015-05-19 06:32:03Z $
+ * $Id: dhd.h 634247 2016-04-27 05:53:55Z $
  */
 
 /****************
@@ -165,6 +165,20 @@ typedef struct reorder_info {
 	uint8 pend_pkts;
 } reorder_info_t;
 
+#if defined(OOB_PARAM)
+#if !defined(OOB_INTR_ONLY)
+#error OOB_PARAM must be defined with OOB_INTR_ONLY!!
+#endif /* !defined(OOB_INTR_ONLY) */
+
+#define OOB_PARAM_IF(x)		if (x)
+#define OOB_PARAM_ELSE()	else
+
+#else	/* defined(OOB_PARAM) */
+
+#define OOB_PARAM_IF(x)
+#define OOB_PARAM_ELSE()
+#endif /* defined(OOB_PARAM) */
+
 #ifdef DHDTCPACK_SUPPRESS
 #define TCPACK_SUP_OFF		0	/* TCPACK suppress off */
 /* Replace TCPACK in txq when new coming one has higher ACK number. */
@@ -620,8 +634,8 @@ extern int dhd_ifname2idx(struct dhd_info *dhd, char *name);
 extern int dhd_net2idx(struct dhd_info *dhd, struct net_device *net);
 extern struct net_device * dhd_idx2net(void *pub, int ifidx);
 extern int net_os_send_hang_message(struct net_device *dev);
-extern int wl_host_event(dhd_pub_t *dhd_pub, int *idx, void *pktdata,
-                         wl_event_msg_t *, void **data_ptr, void *raw_event);
+extern int wl_host_event(dhd_pub_t *dhd_pub, int *idx, void *pktdata, uint16 pktlen,
+		wl_event_msg_t *, void **data_ptr, void *raw_event);
 extern void wl_event_to_host_order(wl_event_msg_t * evt);
 
 extern int dhd_wl_ioctl(dhd_pub_t *dhd_pub, int ifindex, wl_ioctl_t *ioc, void *buf, int len);
diff --git a/drivers/net/wireless/bcmdhd/dhd_common.c b/drivers/net/wireless/bcmdhd/dhd_common.c
index 2413ed9..83e2741 100644
--- a/drivers/net/wireless/bcmdhd/dhd_common.c
+++ b/drivers/net/wireless/bcmdhd/dhd_common.c
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: dhd_common.c 557502 2015-05-19 06:32:03Z $
+ * $Id: dhd_common.c 643093 2016-06-13 08:43:46Z $
  */
 #include <typedefs.h>
 #include <osl.h>
@@ -107,7 +107,16 @@ bool ap_fw_loaded = FALSE;
 #define DHD_COMPILED "\nCompiled in " SRCBASE
 #endif /* DHD_DEBUG */
 
+#if defined(DHD_VERSION_NO_DATE_TIME)
+const char dhd_version[] = "Dongle Host Driver, version " EPI_VERSION_STR	DHD_COMPILED;
+#else
+#if defined(DHD_DEBUG)
+const char dhd_version[] = "Dongle Host Driver, version " EPI_VERSION_STR
+	DHD_COMPILED " on " __DATE__ " at " __TIME__;
+#else
 const char dhd_version[] = "\nDongle Host Driver, version " EPI_VERSION_STR "\nCompiled from ";
+#endif 
+#endif /* DHD_VERSION_NO_DATE_TIME */
 
 void dhd_set_timer(void *bus, uint wdtick);
 
@@ -1432,7 +1441,7 @@ wl_show_host_event(dhd_pub_t *dhd_pub, wl_event_msg_t *event, void *event_data,
 #endif /* SHOW_EVENTS */
 
 int
-wl_host_event(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata,
+wl_host_event(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata, uint16 pktlen,
               wl_event_msg_t *event, void **data_ptr, void *raw_event)
 {
 	/* check whether packet is a BRCM event pkt */
@@ -1442,13 +1451,17 @@ wl_host_event(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata,
 	uint16 flags;
 	int evlen;
 
+	if (pktlen < sizeof(bcm_event_t))
+		return (BCME_ERROR);
+
 	if (bcmp(BRCM_OUI, &pvt_data->bcm_hdr.oui[0], DOT11_OUI_LEN)) {
 		DHD_ERROR(("%s: mismatched OUI, bailing\n", __FUNCTION__));
 		return (BCME_ERROR);
 	}
 
 	/* BRCM event pkt may be unaligned - use xxx_ua to load user_subtype. */
-	if (ntoh16_ua((void *)&pvt_data->bcm_hdr.usr_subtype) != BCMILCP_BCM_SUBTYPE_EVENT) {
+	if (ntoh16_ua((void *)&pvt_data->bcm_hdr.usr_subtype) != BCMILCP_BCM_SUBTYPE_EVENT ||
+		ntoh16_ua((void *)&pvt_data->bcm_hdr.subtype) != BCMILCP_SUBTYPE_VENDOR_LONG) {
 		DHD_ERROR(("%s: mismatched subtype, bailing\n", __FUNCTION__));
 		return (BCME_ERROR);
 	}
@@ -1463,8 +1476,15 @@ wl_host_event(dhd_pub_t *dhd_pub, int *ifidx, void *pktdata,
 	flags = ntoh16_ua((void *)&event->flags);
 	status = ntoh32_ua((void *)&event->status);
 	datalen = ntoh32_ua((void *)&event->datalen);
+
+	if (datalen > pktlen)
+		return (BCME_ERROR);
+
 	evlen = datalen + sizeof(bcm_event_t);
 
+	if (evlen > pktlen)
+		return (BCME_ERROR);
+
 	switch (type) {
 #ifdef DHD_DEBUG
 	case WLC_E_JOIN_START:
diff --git a/drivers/net/wireless/bcmdhd/dhd_linux.c b/drivers/net/wireless/bcmdhd/dhd_linux.c
index 41e1ab0..b84fc48 100644
--- a/drivers/net/wireless/bcmdhd/dhd_linux.c
+++ b/drivers/net/wireless/bcmdhd/dhd_linux.c
@@ -22,7 +22,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: dhd_linux.c 615742 2016-01-28 12:53:11Z $
+ * $Id: dhd_linux.c 634247 2016-04-27 05:53:55Z $
  */
 
 #include <typedefs.h>
@@ -177,6 +177,11 @@ volatile bool dhd_mmc_suspend = FALSE;
 DECLARE_WAIT_QUEUE_HEAD(dhd_dpc_wait);
 #endif /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)) && defined(CONFIG_PM_SLEEP) */
 
+#if defined(OOB_PARAM)
+uint dhd_oob_disable = FALSE;
+module_param(dhd_oob_disable, uint, 0);
+#endif /* OOB_PARAM */
+
 #if defined(OOB_INTR_ONLY)
 extern void dhd_enable_oob_intr(struct dhd_bus *bus, bool enable);
 #endif 
@@ -638,7 +643,7 @@ static int dhd_toe_get(dhd_info_t *dhd, int idx, uint32 *toe_ol);
 static int dhd_toe_set(dhd_info_t *dhd, int idx, uint32 toe_ol);
 #endif /* TOE */
 
-static int dhd_wl_host_event(dhd_info_t *dhd, int *ifidx, void *pktdata,
+static int dhd_wl_host_event(dhd_info_t *dhd, int *ifidx, void *pktdata, uint16 pktlen,
                              wl_event_msg_t *event_ptr, void **data_ptr);
 #if defined(SUPPORT_P2P_GO_PS)
 #ifdef PROP_TXSTATUS
@@ -2103,6 +2108,7 @@ dhd_rx_frame(dhd_pub_t *dhdp, int ifidx, void *pktbuf, int numpkt, uint8 chan)
 #else
 			skb->mac.raw,
 #endif /* LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 22) */
+			len - ETHER_TYPE_LEN,
 			&event,
 			&data);
 
@@ -4425,23 +4431,25 @@ dhd_bus_start(dhd_pub_t *dhdp)
 		return ret;
 	}
 #if defined(OOB_INTR_ONLY)
-	/* Host registration for OOB interrupt */
-	if (dhd_bus_oob_intr_register(dhdp)) {
-		/* deactivate timer and wait for the handler to finish */
-
-		flags = dhd_os_spin_lock(&dhd->pub);
-		dhd->wd_timer_valid = FALSE;
-		dhd_os_spin_unlock(&dhd->pub, flags);
-		del_timer_sync(&dhd->timer);
+	OOB_PARAM_IF(!dhd_oob_disable) {
+		/* Host registration for OOB interrupt */
+		if (dhd_bus_oob_intr_register(dhdp)) {
+			/* deactivate timer and wait for the handler to finish */
+
+			flags = dhd_os_spin_lock(&dhd->pub);
+			dhd->wd_timer_valid = FALSE;
+			dhd_os_spin_unlock(&dhd->pub, flags);
+			del_timer_sync(&dhd->timer);
+
+			DHD_ERROR(("%s Host failed to register for OOB\n", __FUNCTION__));
+			dhd_os_sdunlock(dhdp);
+			DHD_OS_WD_WAKE_UNLOCK(&dhd->pub);
+			return -ENODEV;
+		}
 
-		DHD_ERROR(("%s Host failed to register for OOB\n", __FUNCTION__));
-		dhd_os_sdunlock(dhdp);
-		DHD_OS_WD_WAKE_UNLOCK(&dhd->pub);
-		return -ENODEV;
+		/* Enable oob at firmware */
+		dhd_enable_oob_intr(dhd->pub.bus, TRUE);
 	}
-
-	/* Enable oob at firmware */
-	dhd_enable_oob_intr(dhd->pub.bus, TRUE);
 #endif 
 
 	/* If bus is not ready, can't come up */
@@ -5737,7 +5745,9 @@ dhd_bus_detach(dhd_pub_t *dhdp)
 			}
 
 #if defined(OOB_INTR_ONLY)
-			dhd_bus_oob_intr_unregister(dhdp);
+			OOB_PARAM_IF(!dhd_oob_disable) {
+				dhd_bus_oob_intr_unregister(dhdp);
+			}
 #endif 
 		}
 	}
@@ -6327,16 +6337,16 @@ dhd_get_wireless_stats(struct net_device *dev)
 #endif /* defined(WL_WIRELESS_EXT) */
 
 static int
-dhd_wl_host_event(dhd_info_t *dhd, int *ifidx, void *pktdata,
+dhd_wl_host_event(dhd_info_t *dhd, int *ifidx, void *pktdata, uint16 pktlen,
 	wl_event_msg_t *event, void **data)
 {
 	int bcmerror = 0;
 	ASSERT(dhd != NULL);
 
 #ifdef SHOW_LOGTRACE
-	bcmerror = wl_host_event(&dhd->pub, ifidx, pktdata, event, data, &dhd->event_data);
+	bcmerror = wl_host_event(&dhd->pub, ifidx, pktdata,  pktlen, event, data, &dhd->event_data);
 #else
-	bcmerror = wl_host_event(&dhd->pub, ifidx, pktdata, event, data, NULL);
+	bcmerror = wl_host_event(&dhd->pub, ifidx, pktdata,  pktlen, event, data, NULL);
 #endif /* SHOW_LOGTRACE */
 
 	if (bcmerror != BCME_OK)
diff --git a/drivers/net/wireless/bcmdhd/dhd_linux_platdev.c b/drivers/net/wireless/bcmdhd/dhd_linux_platdev.c
index 7c0f824..8d68c42 100644
--- a/drivers/net/wireless/bcmdhd/dhd_linux_platdev.c
+++ b/drivers/net/wireless/bcmdhd/dhd_linux_platdev.c
@@ -1,7 +1,7 @@
 /*
  * Linux platform device for DHD WLAN adapter
  *
- * Copyright (C) 1999-2015, Broadcom Corporation
+ * Copyright (C) 1999-2016, Broadcom Corporation
  * 
  *      Unless you and Broadcom execute a separate written software license
  * agreement governing use of this software, this software is licensed to you
@@ -70,6 +70,10 @@ struct wifi_platform_data {
 struct regulator *wifi_regulator = NULL;
 #endif /* CONFIG_DTS */
 
+#if defined(OOB_PARAM)
+extern uint dhd_oob_disable;
+#endif /* OOB_PARAM */
+
 bool cfg_multichip = FALSE;
 bcmdhd_wifi_platdata_t *dhd_wifi_platdata = NULL;
 static int wifi_plat_dev_probe_ret = 0;
@@ -207,34 +211,30 @@ int wifi_platform_set_power(wifi_adapter_info_t *adapter, bool on, unsigned long
 
 	return err;
 }
+#if defined(CUSTOMER_IMX)
 
-#if 1
-/* Murata debug: this function is re-worked because "wifi_plat_data" is NULL.  */
-/* Need to investigate how this pointer/data is being passed into probe function. */
-/* "wifi_plat_data" used to be "wifi_ctrl".  */
-/* All this code is done for only one reason -- calling mmc_detect_change() in /drivers/mmc/core/core.c. */
 extern void wifi_card_detect(bool);
 int wifi_platform_bus_enumerate(wifi_adapter_info_t *adapter, bool device_present)
 {
-        int err = 0;
-        struct wifi_platform_data *plat_data;
+	int err = 0;
+	struct wifi_platform_data *plat_data;
 
-        if (!adapter) {
-                pr_err("!!!! %s: failed!  adapter variable is NULL!!!!!\n", __FUNCTION__);
-                return -EINVAL;
-        }
+	if (!adapter) {
+		pr_err("!!!! %s: failed!  adapter variable is NULL!!!!!\n", __FUNCTION__);
+		return -EINVAL;
+	}
 
-        DHD_ERROR(("%s device present %d\n", __FUNCTION__, device_present));
+	DHD_ERROR(("%s device present %d\n", __FUNCTION__, device_present));
 
 	if (!adapter->wifi_plat_data) {
 		wifi_card_detect(device_present); /* hook for card_detect */
 	} else {
 		plat_data = adapter->wifi_plat_data;
 		if (plat_data->set_carddetect)
-			err = plat_data->set_carddetect(device_present);
+		err = plat_data->set_carddetect(device_present);
 	}
 
-        return 0; /* force success status returned */
+	return 0; /* force success status returned */
 }
 
 #else
@@ -254,8 +254,7 @@ int wifi_platform_bus_enumerate(wifi_adapter_info_t *adapter, bool device_presen
 	return err;
 
 }
-#endif
-
+#endif /* CUSTOMER_IMX */
 int wifi_platform_get_mac_addr(wifi_adapter_info_t *adapter, unsigned char *buf)
 {
 	struct wifi_platform_data *plat_data;
@@ -298,7 +297,7 @@ static int wifi_plat_dev_drv_probe(struct platform_device *pdev)
 	struct resource *resource;
 	wifi_adapter_info_t *adapter;
 #ifdef CONFIG_DTS
-#if defined(OOB_INTR_ONLY) && defined (HW_OOB)
+#if defined(OOB_INTR_ONLY) && defined(HW_OOB)
 	int irq, gpio;
 #endif /* defined(OOB_INTR_ONLY) && defined (HW_OOB) */
 #endif /* CONFIG_DTS */
@@ -325,24 +324,37 @@ static int wifi_plat_dev_drv_probe(struct platform_device *pdev)
 		DHD_ERROR(("%s regulator is null\n", __FUNCTION__));
 		return -1;
 	}
-#if defined(OOB_INTR_ONLY) && defined (HW_OOB)
-	/* This is to get the irq for the OOB */
-	gpio = of_get_gpio(pdev->dev.of_node, 0);
+#if defined(OOB_INTR_ONLY) && defined(HW_OOB)
+	OOB_PARAM_IF(!dhd_oob_disable) {
+		/* This is to get the irq for the OOB */
+		gpio = of_get_gpio(pdev->dev.of_node, 0);
+
+		if (gpio < 0) {
+			DHD_ERROR(("%s no GPIO for OOB in device tree.\n", __FUNCTION__));
+#if defined(OOB_PARAM)
+			DHD_ERROR(("%s continue with non-OOB mode.\n", __FUNCTION__));
+			dhd_oob_disable = TRUE;
+			goto out;
+#else
+			return -1;
+#endif /* defined(OOB_PARAM) */
+		}
 
-	if (gpio < 0) {
-		DHD_ERROR(("%s gpio information is incorrect\n", __FUNCTION__));
-		return -1;
-	}
-	irq = gpio_to_irq(gpio);
-	if (irq < 0) {
-		DHD_ERROR(("%s irq information is incorrect\n", __FUNCTION__));
-		return -1;
+		irq = gpio_to_irq(gpio);
+		if (irq < 0) {
+			DHD_ERROR(("%s irq information is incorrect\n", __FUNCTION__));
+			return -1;
+		}
+		adapter->irq_num = irq;
+
+		/* need to change the flags according to our requirement */
+		adapter->intr_flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL |
+			IORESOURCE_IRQ_SHAREABLE;
 	}
-	adapter->irq_num = irq;
 
-	/* need to change the flags according to our requirement */
-	adapter->intr_flags = IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL |
-		IORESOURCE_IRQ_SHAREABLE;
+#if defined(OOB_PARAM)
+out:
+#endif /* defined(OOB_PARAM) */
 #endif /* defined(OOB_INTR_ONLY) && defined (HW_OOB) */
 #endif /* CONFIG_DTS */
 
@@ -376,7 +388,9 @@ static int wifi_plat_dev_drv_suspend(struct platform_device *pdev, pm_message_t
 	DHD_TRACE(("##> %s\n", __FUNCTION__));
 #if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 39)) && defined(OOB_INTR_ONLY) && \
 	defined(BCMSDIO)
-	bcmsdh_oob_intr_set(0);
+	OOB_PARAM_IF(!dhd_oob_disable) {
+		bcmsdh_oob_intr_set(0);
+	}
 #endif /* (OOB_INTR_ONLY) */
 	return 0;
 }
@@ -386,8 +400,10 @@ static int wifi_plat_dev_drv_resume(struct platform_device *pdev)
 	DHD_TRACE(("##> %s\n", __FUNCTION__));
 #if (LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 39)) && defined(OOB_INTR_ONLY) && \
 	defined(BCMSDIO)
-	if (dhd_os_check_if_up(wl_cfg80211_get_dhdp()))
-		bcmsdh_oob_intr_set(1);
+	OOB_PARAM_IF(!dhd_oob_disable) {
+		if (dhd_os_check_if_up(wl_cfg80211_get_dhdp()))
+			bcmsdh_oob_intr_set(1);
+	}
 #endif /* (OOB_INTR_ONLY) */
 	return 0;
 }
diff --git a/drivers/net/wireless/bcmdhd/dhd_sdio.c b/drivers/net/wireless/bcmdhd/dhd_sdio.c
index 8cb8796..7e0e7ab 100644
--- a/drivers/net/wireless/bcmdhd/dhd_sdio.c
+++ b/drivers/net/wireless/bcmdhd/dhd_sdio.c
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: dhd_sdio.c 572232 2015-07-17 12:14:31Z $
+ * $Id: dhd_sdio.c 634247 2016-04-27 05:53:55Z $
  */
 
 #include <typedefs.h>
@@ -418,6 +418,10 @@ uint dhd_dpcpoll = FALSE;
 module_param(dhd_doflow, uint, 0644);
 module_param(dhd_dpcpoll, uint, 0644);
 
+#if defined(OOB_PARAM)
+extern uint dhd_oob_disable;
+#endif /* OOB_PARAM */
+
 static bool dhd_alignctl;
 
 static bool sd1idle;
@@ -1175,9 +1179,13 @@ dhdsdio_htclk(dhd_bus_t *bus, bool on, bool pendok)
 			return BCME_ERROR;
 		}
 
-#if !defined(OOB_INTR_ONLY)
+#if !defined(OOB_INTR_ONLY) || defined(OOB_PARAM)
 		/* Go to pending and await interrupt if appropriate */
-		if (!SBSDIO_CLKAV(clkctl, bus->alp_only) && pendok) {
+		if (1 &&
+#if defined(OOB_PARAM)
+			dhd_oob_disable &&
+#endif /* OOB_PARAM */
+			!SBSDIO_CLKAV(clkctl, bus->alp_only) && pendok) {
 			/* Allow only clock-available interrupt */
 			devctl = bcmsdh_cfg_read(sdh, SDIO_FUNC_1, SBSDIO_DEVICE_CTL, &err);
 			if (err) {
@@ -1192,7 +1200,7 @@ dhdsdio_htclk(dhd_bus_t *bus, bool on, bool pendok)
 			bus->clkstate = CLK_PENDING;
 			return BCME_OK;
 		} else
-#endif /* !defined (OOB_INTR_ONLY) */
+#endif /* !defined(OOB_INTR_ONLY) || defined(OOB_PARAM) */
 		{
 			if (bus->clkstate == CLK_PENDING) {
 				/* Cancel CA-only interrupt filter */
@@ -1877,10 +1885,6 @@ static int dhdsdio_txpkt_preprocess(dhd_bus_t *bus, void *pkt, int chan, int txs
 		PKTALIGN(osh, tmp_pkt, PKTLEN(osh, pkt), DHD_SDALIGN);
 		bcopy(PKTDATA(osh, pkt), PKTDATA(osh, tmp_pkt), PKTLEN(osh, pkt));
 		*new_pkt = tmp_pkt;
-		/* pull back sdpcm_hdrlen length from old skb as new skb here is passed
-		 * to postprocessing
-		 */
-		PKTPULL(osh, pkt, sdpcm_hdrlen);
 		pkt = tmp_pkt;
 	}
 
@@ -2101,7 +2105,6 @@ done:
 				PKTFREE(osh, pkt, TRUE);
 		}
 	}
-
 	for (i = 0; i < new_pkt_num; i++)
 		PKTFREE(osh, new_pkts[i], TRUE);
 
@@ -6014,24 +6017,28 @@ clkwait:
 		          __FUNCTION__, rxdone, framecnt));
 		bus->intdis = FALSE;
 #if defined(OOB_INTR_ONLY)
-		bcmsdh_oob_intr_set(bus->sdh, TRUE);
+		OOB_PARAM_IF(!dhd_oob_disable) {
+			bcmsdh_oob_intr_set(bus->sdh, TRUE);
+		}
 #endif /* defined(OOB_INTR_ONLY) */
 		bcmsdh_intr_enable(sdh);
 	}
 
 #if defined(OOB_INTR_ONLY) && !defined(HW_OOB)
-	/* In case of SW-OOB(using edge trigger),
-	 * Check interrupt status in the dongle again after enable irq on the host.
-	 * and rechedule dpc if interrupt is pended in the dongle.
-	 * There is a chance to miss OOB interrupt while irq is disabled on the host.
-	 * No need to do this with HW-OOB(level trigger)
-	 */
-	R_SDREG(newstatus, &regs->intstatus, retries);
-	if (bcmsdh_regfail(bus->sdh))
-		newstatus = 0;
-	if (newstatus & bus->hostintmask) {
-		bus->ipend = TRUE;
-		resched = TRUE;
+	OOB_PARAM_IF(!dhd_oob_disable) {
+		/* In case of SW-OOB(using edge trigger),
+		 * Check interrupt status in the dongle again after enable irq on the host.
+		 * and rechedule dpc if interrupt is pended in the dongle.
+		 * There is a chance to miss OOB interrupt while irq is disabled on the host.
+		 * No need to do this with HW-OOB(level trigger)
+		 */
+		R_SDREG(newstatus, &regs->intstatus, retries);
+		if (bcmsdh_regfail(bus->sdh))
+			newstatus = 0;
+		if (newstatus & bus->hostintmask) {
+			bus->ipend = TRUE;
+			resched = TRUE;
+		}
 	}
 #endif /* defined(OOB_INTR_ONLY) && !defined(HW_OOB) */
 
@@ -6152,17 +6159,21 @@ dhdsdio_isr(void *arg)
 	bcmsdh_intr_disable(sdh);
 	bus->intdis = TRUE;
 
-#if defined(SDIO_ISR_THREAD)
-	DHD_TRACE(("Calling dhdsdio_dpc() from %s\n", __FUNCTION__));
-	DHD_OS_WAKE_LOCK(bus->dhd);
-	dhdsdio_dpc(bus);
-	DHD_OS_WAKE_UNLOCK(bus->dhd);
-#else
-
-	bus->dpc_sched = TRUE;
-	dhd_sched_dpc(bus->dhd);
+#if defined(SDIO_ISR_THREAD) || defined(OOB_PARAM)
+	OOB_PARAM_IF(dhd_oob_disable) {
+		DHD_TRACE(("Calling dhdsdio_dpc() from %s\n", __FUNCTION__));
+		DHD_OS_WAKE_LOCK(bus->dhd);
+		dhdsdio_dpc(bus);
+		DHD_OS_WAKE_UNLOCK(bus->dhd);
+	} OOB_PARAM_ELSE()
+#endif /* defined(SDIO_ISR_THREAD) || defined(OOB_PARAM) */
+#if !defined(SDIO_ISR_THREAD) || defined(OOB_PARAM)
+	{
+		bus->dpc_sched = TRUE;
+		dhd_sched_dpc(bus->dhd);
+	}
+#endif /* !defined(SDIO_ISR_THREAD) || defined(OOB_PARAM) */
 
-#endif /* defined(SDIO_ISR_THREAD) */
 
 }
 
@@ -6474,7 +6485,9 @@ int dhd_bus_oob_intr_register(dhd_pub_t *dhdp)
 	int err = 0;
 
 #if defined(OOB_INTR_ONLY)
-	err = bcmsdh_oob_intr_register(dhdp->bus->sdh, dhdsdio_isr, dhdp->bus);
+	OOB_PARAM_IF(!dhd_oob_disable) {
+		err = bcmsdh_oob_intr_register(dhdp->bus->sdh, dhdsdio_isr, dhdp->bus);
+	}
 #endif
 	return err;
 }
@@ -6482,14 +6495,18 @@ int dhd_bus_oob_intr_register(dhd_pub_t *dhdp)
 void dhd_bus_oob_intr_unregister(dhd_pub_t *dhdp)
 {
 #if defined(OOB_INTR_ONLY)
-	bcmsdh_oob_intr_unregister(dhdp->bus->sdh);
+	OOB_PARAM_IF(!dhd_oob_disable) {
+		bcmsdh_oob_intr_unregister(dhdp->bus->sdh);
+	}
 #endif
 }
 
 void dhd_bus_oob_intr_set(dhd_pub_t *dhdp, bool enable)
 {
 #if defined(OOB_INTR_ONLY)
-	bcmsdh_oob_intr_set(dhdp->bus->sdh, enable);
+	OOB_PARAM_IF(!dhd_oob_disable) {
+		bcmsdh_oob_intr_set(dhdp->bus->sdh, enable);
+	}
 #endif
 }
 
@@ -7279,6 +7296,7 @@ dhdsdio_probe_init(dhd_bus_t *bus, osl_t *osh, void *sdh)
 		PKTSETNEXT(osh, bus->pad_pkt, NULL);
 	}
 
+
 	/* Query if bus module supports packet chaining, default to use if supported */
 	if (bcmsdh_iovar_op(sdh, "sd_rxchain", NULL, 0,
 	                    &bus->sd_rxchain, sizeof(int32), FALSE) != BCME_OK) {
@@ -7366,6 +7384,7 @@ dhdsdio_release(dhd_bus_t *bus, osl_t *osh)
 		if (bus->pad_pkt)
 			PKTFREE(osh, bus->pad_pkt, FALSE);
 
+
 		MFREE(osh, bus, sizeof(dhd_bus_t));
 	}
 
@@ -7484,8 +7503,10 @@ dhdsdio_resume(void *context)
 #if defined(OOB_INTR_ONLY)
 	dhd_bus_t *bus = (dhd_bus_t*)context;
 
-	if (dhd_os_check_if_up(bus->dhd))
-		bcmsdh_oob_intr_set(bus->sdh, TRUE);
+	OOB_PARAM_IF(!dhd_oob_disable) {
+		if (dhd_os_check_if_up(bus->dhd))
+			bcmsdh_oob_intr_set(bus->sdh, TRUE);
+	}
 #endif 
 	return 0;
 }
@@ -7979,10 +8000,12 @@ dhd_bus_devreset(dhd_pub_t *dhdp, uint8 flag)
 			dhd_bus_stop(bus, FALSE);
 
 #if defined(OOB_INTR_ONLY)
-			/* Clean up any pending IRQ */
-			dhd_enable_oob_intr(bus, FALSE);
-			bcmsdh_oob_intr_set(bus->sdh, FALSE);
-			bcmsdh_oob_intr_unregister(bus->sdh);
+			OOB_PARAM_IF(!dhd_oob_disable) {
+				/* Clean up any pending IRQ */
+				dhd_enable_oob_intr(bus, FALSE);
+				bcmsdh_oob_intr_set(bus->sdh, FALSE);
+				bcmsdh_oob_intr_unregister(bus->sdh);
+			}
 #endif 
 
 			/* Clean tx/rx buffer pointers, detach from the dongle */
@@ -8020,10 +8043,12 @@ dhd_bus_devreset(dhd_pub_t *dhdp, uint8 flag)
 					bcmerror = dhd_bus_init((dhd_pub_t *) bus->dhd, FALSE);
 					if (bcmerror == BCME_OK) {
 #if defined(OOB_INTR_ONLY)
-						dhd_enable_oob_intr(bus, TRUE);
-						bcmsdh_oob_intr_register(bus->sdh,
-							dhdsdio_isr, bus);
-						bcmsdh_oob_intr_set(bus->sdh, TRUE);
+						OOB_PARAM_IF(!dhd_oob_disable) {
+							dhd_enable_oob_intr(bus, TRUE);
+							bcmsdh_oob_intr_register(bus->sdh,
+								dhdsdio_isr, bus);
+							bcmsdh_oob_intr_set(bus->sdh, TRUE);
+						}
 #endif 
 
 						bus->dhd->dongle_reset = FALSE;
diff --git a/drivers/net/wireless/bcmdhd/include/bcmsdstd.h b/drivers/net/wireless/bcmdhd/include/bcmsdstd.h
index 803f77f..3624aab 100644
--- a/drivers/net/wireless/bcmdhd/include/bcmsdstd.h
+++ b/drivers/net/wireless/bcmdhd/include/bcmsdstd.h
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: bcmsdstd.h 455427 2014-02-14 00:11:19Z $
+ * $Id: bcmsdstd.h 623513 2016-03-08 06:22:05Z $
  */
 #ifndef	_BCM_SD_STD_H
 #define	_BCM_SD_STD_H
@@ -237,8 +237,8 @@ extern void sdstd_spinbits(sdioh_info_t *sd, uint16 norm, uint16 err);
  */
 
 /* Register mapping routines */
-extern uint32 *sdstd_reg_map(osl_t *osh, int32 addr, int size);
-extern void sdstd_reg_unmap(osl_t *osh, int32 addr, int size);
+extern uint32 *sdstd_reg_map(osl_t *osh, ulong addr, int size);
+extern void sdstd_reg_unmap(osl_t *osh, ulong addr, int size);
 
 /* Interrupt (de)registration routines */
 extern int sdstd_register_irq(sdioh_info_t *sd, uint irq);
diff --git a/drivers/net/wireless/bcmdhd/include/epivers.h b/drivers/net/wireless/bcmdhd/include/epivers.h
index 5b8f403..07fe014 100644
--- a/drivers/net/wireless/bcmdhd/include/epivers.h
+++ b/drivers/net/wireless/bcmdhd/include/epivers.h
@@ -30,19 +30,19 @@
 
 #define	EPI_MINOR_VERSION	141
 
-#define	EPI_RC_NUMBER		88
+#define	EPI_RC_NUMBER		92
 
 #define	EPI_INCREMENTAL_NUMBER	0
 
 #define	EPI_BUILD_NUMBER	0
 
-#define	EPI_VERSION		1, 141, 88, 0
+#define	EPI_VERSION		1, 141, 92, 0
 
-#define	EPI_VERSION_NUM		0x018d5800
+#define	EPI_VERSION_NUM		0x018d5c00
 
-#define EPI_VERSION_DEV		1.141.88
+#define EPI_VERSION_DEV		1.141.92
 
 /* Driver Version String, ASCII, 32 chars max */
-#define	EPI_VERSION_STR		"1.141.88 (r)"
+#define	EPI_VERSION_STR		"1.141.92 (r)"
 
 #endif /* _epivers_h_ */
diff --git a/drivers/net/wireless/bcmdhd/include/linux_osl.h b/drivers/net/wireless/bcmdhd/include/linux_osl.h
index 435a447..d9dd5fd 100644
--- a/drivers/net/wireless/bcmdhd/include/linux_osl.h
+++ b/drivers/net/wireless/bcmdhd/include/linux_osl.h
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: linux_osl.h 432719 2013-10-29 12:04:59Z $
+ * $Id: linux_osl.h 623322 2016-03-07 12:58:14Z $
  */
 
 #ifndef _linux_osl_h_
@@ -317,6 +317,8 @@ extern int osl_error(int bcmerror);
 #endif /* CONFIG_DHD_USE_STATIC_BUF */
 #define	PKTDATA(osh, skb)		({BCM_REFERENCE(osh); (((struct sk_buff*)(skb))->data);})
 #define	PKTLEN(osh, skb)		({BCM_REFERENCE(osh); (((struct sk_buff*)(skb))->len);})
+
+
 #define PKTHEADROOM(osh, skb)		(PKTDATA(osh, skb)-(((struct sk_buff*)(skb))->head))
 #define PKTEXPHEADROOM(osh, skb, b)	\
 	({ \
diff --git a/drivers/net/wireless/bcmdhd/wl_cfg80211.c b/drivers/net/wireless/bcmdhd/wl_cfg80211.c
index 90d70c5..bfa8a14 100644
--- a/drivers/net/wireless/bcmdhd/wl_cfg80211.c
+++ b/drivers/net/wireless/bcmdhd/wl_cfg80211.c
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: wl_cfg80211.c 614516 2016-01-22 13:45:21Z $
+ * $Id: wl_cfg80211.c 641576 2016-06-03 08:52:14Z $
  */
 /* */
 #include <typedefs.h>
@@ -1193,8 +1193,10 @@ wl_validate_wps_ie(char *wps_ie, s32 wps_ie_len, bool *pbc)
 			WL_DBG(("  attr WPS_ID_CONFIG_METHODS: %x\n", HTON16(val)));
 		} else if (subelt_id == WPS_ID_DEVICE_NAME) {
 			char devname[100];
-			memcpy(devname, subel, subelt_len);
-			devname[subelt_len] = '\0';
+			int namelen = MIN(subelt_len, (sizeof(devname) - 1));
+			memcpy(devname, subel, namelen);
+			devname[namelen] = '\0';
+			/* Printing len as rx'ed in the IE */
 			WL_DBG(("  attr WPS_ID_DEVICE_NAME: %s (len %u)\n",
 				devname, subelt_len));
 		} else if (subelt_id == WPS_ID_DEVICE_PWD_ID) {
@@ -1302,14 +1304,15 @@ static chanspec_t wl_cfg80211_get_shared_freq(struct wiphy *wiphy)
 	struct wl_bss_info *bss = NULL;
 
 	if ((err = wldev_ioctl(dev, WLC_GET_BSSID, &bssid, sizeof(bssid), false))) {
-		struct channel_info ci;
+		int chspc;
 		/* STA interface is not associated. So start the new interface on a temp
 		 * channel . Later proper channel will be applied by the above framework
 		 * via set_channel (cfg80211 API).
 		 */
 		WL_DBG(("Not associated. Return first channel from supported channel list. \n"));
-		if (!wldev_ioctl(dev, WLC_GET_CHANNEL, &ci, sizeof(ci), false)) {
-			return wl_ch_host_to_driver(ci.hw_channel);
+		err = wldev_iovar_getint(dev, "chanspec", &chspc);
+		if (!err) {
+			return chspc;
 		} else {
 
 			return wl_ch_host_to_driver(WL_P2P_TEMP_CHAN);
@@ -6271,6 +6274,7 @@ wl_cfg80211_bcn_bringup_ap(
 	s32 infra = 1;
 	s32 join_params_size = 0;
 	s32 ap = 1;
+	s32 pm;
 	s32 err = BCME_OK;
 
 	WL_DBG(("Enter dev_role: %d\n", dev_role));
@@ -6318,11 +6322,22 @@ wl_cfg80211_bcn_bringup_ap(
 			WL_ERR(("SET INFRA error %d\n", err));
 			goto exit;
 		}
+		if ((err = wldev_iovar_setint(dev, "apsta", 0)) < 0) {
+			WL_ERR(("wl apsta 0 error %d\n", err));
+			goto exit;
+		}
 		if ((err = wldev_ioctl(dev, WLC_SET_AP, &ap, sizeof(s32), true)) < 0) {
 			WL_ERR(("setting AP mode failed %d \n", err));
 			goto exit;
 		}
 
+		pm = 0;
+		if ((err = wldev_ioctl(dev, WLC_SET_PM, &pm, sizeof(pm), true)) != 0) {
+			WL_ERR(("wl PM 0 returned error:%d\n", err));
+			goto exit;
+		}
+
+
 		err = wldev_ioctl(dev, WLC_UP, &ap, sizeof(s32), true);
 		if (unlikely(err)) {
 			WL_ERR(("WLC_UP error (%d)\n", err));
@@ -6637,6 +6652,7 @@ wl_cfg80211_start_ap(
 	struct parsed_ies ies;
 	s32 bssidx = 0;
 	u32 dev_role = 0;
+	dhd_pub_t *dhd = (dhd_pub_t *)(cfg->pub);
 
 	WL_DBG(("Enter \n"));
 	if (dev == bcmcfg_to_prmry_ndev(cfg)) {
@@ -6657,11 +6673,45 @@ wl_cfg80211_start_ap(
 		WL_ERR(("Find p2p index from dev(%p) failed\n", dev));
 		return BCME_ERROR;
 	}
-	if (p2p_is_on(cfg) &&
-		(bssidx == wl_to_p2p_bss_bssidx(cfg,
-		P2PAPI_BSSCFG_CONNECTION))) {
+
+	if (p2p_is_on(cfg) && (dev->ieee80211_ptr->iftype == NL80211_IFTYPE_P2P_GO)) {
 		dev_role = NL80211_IFTYPE_P2P_GO;
 		WL_DBG(("Start AP req on P2P connection iface\n"));
+	} else if (dev_role == NL80211_IFTYPE_AP) {
+		WL_DBG(("Start AP req\n"));
+		dhd->op_mode |= DHD_FLAG_HOSTAP_MODE;
+		/*
+		 * Enabling Softap is causing issues with STA NDO operations
+		 * as NDO is not interface specific. So disable NDO while
+		 * Softap is enabled
+		 */
+		err = dhd_ndo_enable(dhd, FALSE);
+		WL_DBG(("%s: Disabling NDO on Hostapd mode %d\n", __FUNCTION__, err));
+		if (err) {
+			/* Non fatal error. */
+			WL_ERR(("%s: Disabling NDO Failed %d\n", __FUNCTION__, err));
+		} else {
+			cfg->revert_ndo_disable = true;
+		}
+
+#ifdef PKT_FILTER_SUPPORT
+		/* Disable packet filter */
+		if (dhd->early_suspended) {
+			WL_ERR(("Disable pkt_filter\n"));
+			dhd_enable_packet_filter(0, dhd);
+		}
+#endif /* PKT_FILTER_SUPPORT */
+#ifdef ARP_OFFLOAD_SUPPORT
+		/* IF SoftAP is enabled, disable arpoe */
+		if (dhd->op_mode & DHD_FLAG_STA_MODE) {
+			dhd_arp_offload_set(dhd, 0);
+			dhd_arp_offload_enable(dhd, FALSE);
+		}
+#endif /* ARP_OFFLOAD_SUPPORT */
+	} else {
+		/* only AP or GO role need to be handled here. */
+		err = -EINVAL;
+		goto fail;
 	}
 
 	if (!check_dev_role_integrity(cfg, dev_role))
@@ -6744,37 +6794,61 @@ wl_cfg80211_stop_ap(
 	int ap = 0;
 	s32 bssidx = 0;
 	struct bcm_cfg80211 *cfg = wiphy_priv(wiphy);
+	dhd_pub_t *dhd = (dhd_pub_t *)(cfg->pub);
 
 	WL_DBG(("Enter \n"));
-	if (dev == bcmcfg_to_prmry_ndev(cfg)) {
-		dev_role = NL80211_IFTYPE_AP;
-	}
-#if defined(WL_ENABLE_P2P_IF)
-	else if (dev == cfg->p2p_net) {
-		/* Group Add request on p2p0 */
-#ifndef  P2PONEINT
-		dev = bcmcfg_to_prmry_ndev(cfg);
-#endif
-		dev_role = NL80211_IFTYPE_P2P_GO;
-	}
-#endif /* WL_ENABLE_P2P_IF */
+
 	if (wl_cfgp2p_find_idx(cfg, dev, &bssidx) != BCME_OK) {
 		WL_ERR(("Find p2p index from dev(%p) failed\n", dev));
 		return BCME_ERROR;
 	}
-	if (p2p_is_on(cfg) &&
-		(bssidx == wl_to_p2p_bss_bssidx(cfg,
-		P2PAPI_BSSCFG_CONNECTION))) {
+
+	if (dev->ieee80211_ptr->iftype == NL80211_IFTYPE_AP) {
+		dev_role = NL80211_IFTYPE_AP;
+		WL_DBG(("stopping AP operation\n"));
+	} else if (dev->ieee80211_ptr->iftype == NL80211_IFTYPE_P2P_GO) {
 		dev_role = NL80211_IFTYPE_P2P_GO;
+		WL_DBG(("stopping P2P GO operation\n"));
+	} else {
+		WL_ERR(("no AP/P2P GO interface is operational.\n"));
+		return -EINVAL;
 	}
 
 	if (!check_dev_role_integrity(cfg, dev_role))
 		goto exit;
 
+	if ((err = wl_cfgp2p_bss(cfg, dev, bssidx, 0)) < 0) {
+		WL_ERR(("bss down error %d\n", err));
+	}
+
 	if (dev_role == NL80211_IFTYPE_AP) {
 		/* SoftAp on primary Interface.
 		 * Shut down AP and turn on MPC
 		 */
+		if (cfg->revert_ndo_disable == true) {
+			err = dhd_ndo_enable(dhd, TRUE);
+			WL_DBG(("%s: Enabling back NDO on Softap turn off %d\n",
+				__FUNCTION__, err));
+			if (err) {
+				WL_ERR(("%s: Enabling NDO Failed %d\n", __FUNCTION__, err));
+			}
+			cfg->revert_ndo_disable = false;
+		}
+
+#ifdef PKT_FILTER_SUPPORT
+		/* Enable packet filter */
+		if (dhd->early_suspended) {
+			WL_ERR(("Enable pkt_filter\n"));
+			dhd_enable_packet_filter(1, dhd);
+		}
+#endif /* PKT_FILTER_SUPPORT */
+#ifdef ARP_OFFLOAD_SUPPORT
+		/* IF SoftAP is disabled, enable arpoe back for STA mode. */
+		if (dhd->op_mode & DHD_FLAG_STA_MODE) {
+			dhd_arp_offload_set(dhd, dhd_arp_mode);
+			dhd_arp_offload_enable(dhd, TRUE);
+		}
+#endif /* ARP_OFFLOAD_SUPPORT */
 		if ((err = wldev_ioctl(dev, WLC_SET_AP, &ap, sizeof(s32), true)) < 0) {
 			WL_ERR(("setting AP mode failed %d \n", err));
 			err = -ENOTSUPP;
@@ -6812,6 +6886,10 @@ wl_cfg80211_stop_ap(
 	}
 
 exit:
+	if (dev_role == NL80211_IFTYPE_AP) {
+		/* clear the AP mode */
+		dhd->op_mode &= ~DHD_FLAG_HOSTAP_MODE;
+	}
 	return err;
 }
 
@@ -9206,8 +9284,13 @@ wl_notify_sched_scan_results(struct bcm_cfg80211 *cfg, struct net_device *ndev,
 
 	WL_DBG(("Enter\n"));
 
-	if (e->event_type == WLC_E_PFN_NET_LOST) {
-		WL_PNO(("PFN NET LOST event. Do Nothing \n"));
+	if ((e->event_type == WLC_E_PFN_NET_LOST) || !data) {
+		WL_PNO(("Do Nothing %d\n", e->event_type));
+		return 0;
+	}
+	if (pfn_result->version != PFN_SCANRESULT_VERSION) {
+		WL_ERR(("Incorrect version %d, expected %d\n", pfn_result->version,
+			PFN_SCANRESULT_VERSION));
 		return 0;
 	}
 	WL_PNO((">>> PFN NET FOUND event. count:%d \n", n_pfn_results));
@@ -9250,9 +9333,8 @@ wl_notify_sched_scan_results(struct bcm_cfg80211 *cfg, struct net_device *ndev,
 			 * scan request in the form of cfg80211_scan_request. For timebeing, create
 			 * cfg80211_scan_request one out of the received PNO event.
 			 */
-			memcpy(ssid[i].ssid, netinfo->pfnsubnet.SSID,
-				netinfo->pfnsubnet.SSID_len);
-			ssid[i].ssid_len = netinfo->pfnsubnet.SSID_len;
+			ssid[i].ssid_len = MIN(netinfo->pfnsubnet.SSID_len, DOT11_MAX_SSID_LEN);
+			memcpy(ssid[i].ssid, netinfo->pfnsubnet.SSID, ssid[i].ssid_len);
 			request->n_ssids++;
 
 			channel_req = netinfo->pfnsubnet.channel;
diff --git a/drivers/net/wireless/bcmdhd/wl_cfg80211.h b/drivers/net/wireless/bcmdhd/wl_cfg80211.h
index f5f0cb2..b219d1d 100644
--- a/drivers/net/wireless/bcmdhd/wl_cfg80211.h
+++ b/drivers/net/wireless/bcmdhd/wl_cfg80211.h
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: wl_cfg80211.h 599648 2015-11-16 09:33:00Z $
+ * $Id: wl_cfg80211.h 635212 2016-05-03 06:35:20Z $
  */
 
 #ifndef _wl_cfg80211_h_
@@ -617,6 +617,7 @@ struct bcm_cfg80211 {
 	bool nan_running;
 	bool need_wait_afrx;
 	struct ether_addr last_roamed_addr;
+	bool revert_ndo_disable;
 };
 
 
diff --git a/drivers/net/wireless/bcmdhd/wl_cfg_btcoex.c b/drivers/net/wireless/bcmdhd/wl_cfg_btcoex.c
index bad3623..886c2c4 100644
--- a/drivers/net/wireless/bcmdhd/wl_cfg_btcoex.c
+++ b/drivers/net/wireless/bcmdhd/wl_cfg_btcoex.c
@@ -21,7 +21,7 @@
  * software in any way with any other Broadcom software provided under a license
  * other than the GPL, without Broadcom's express prior written consent.
  *
- * $Id: wl_cfg_btcoex.c 427707 2013-10-04 10:28:29Z $
+ * $Id: wl_cfg_btcoex.c 638311 2016-05-17 09:20:23Z $
  */
 
 #include <net/rtnetlink.h>
@@ -100,11 +100,7 @@ dev_wlc_intvar_get_reg(struct net_device *dev, char *name,
 static int
 dev_wlc_bufvar_set(struct net_device *dev, char *name, char *buf, int len)
 {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31)
-	char ioctlbuf_local[1024];
-#else
-	static char ioctlbuf_local[1024];
-#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 31) */
+	char ioctlbuf_local[WLC_IOCTL_SMLEN];
 
 	bcm_mkiovar(name, buf, len, ioctlbuf_local, sizeof(ioctlbuf_local));
 
-- 
1.7.5.4

