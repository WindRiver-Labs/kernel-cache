From cfa5699c7279de8e8d206f1281839dba98967472 Mon Sep 17 00:00:00 2001
From: Shengjiu Wang <shengjiu.wang@freescale.com>
Date: Thu, 30 Jun 2016 17:45:05 +0800
Subject: [PATCH 48/85] MLK-12771: ASoC: fsl_asrc: fix dma task timeout issue

The test case is one p2p playback + two m2m converter running
simultaneously. There are three root cause for this issue:

1. hw_free() of p2p may be called twice in the end, which cause
release twice of one pair, if another pair request is called between
this two release, there will be issue.

2. In m2m close(), the asrc_priv->pair[i] will be set NULL twice,
which is same issue as 1.

3. when output rate is more than eight multiple of input rate for m2m,
the last_period_size should be larger.

Signed-off-by: Shengjiu Wang <shengjiu.wang@freescale.com>
[zou:Original patch taken from
git://git.freescale.com/imx/linux-imx.git imx_4.1.15_2.0.0_ga]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 sound/soc/fsl/fsl_asrc.c     |    9 +++++++--
 sound/soc/fsl/fsl_asrc.h     |    2 ++
 sound/soc/fsl/fsl_asrc_m2m.c |   15 +++++----------
 3 files changed, 14 insertions(+), 12 deletions(-)

diff --git a/sound/soc/fsl/fsl_asrc.c b/sound/soc/fsl/fsl_asrc.c
index 40abe9f..562c080 100644
--- a/sound/soc/fsl/fsl_asrc.c
+++ b/sound/soc/fsl/fsl_asrc.c
@@ -513,6 +513,7 @@ static int fsl_asrc_dai_hw_params(struct snd_pcm_substream *substream,
 		return ret;
 	}
 
+	asrc_priv->pair_streams |= BIT(substream->stream);
 	pair->config = &config;
 
 	if (width == 16)
@@ -561,11 +562,15 @@ static int fsl_asrc_dai_hw_params(struct snd_pcm_substream *substream,
 static int fsl_asrc_dai_hw_free(struct snd_pcm_substream *substream,
 				struct snd_soc_dai *dai)
 {
+	struct fsl_asrc *asrc_priv = snd_soc_dai_get_drvdata(dai);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct fsl_asrc_pair *pair = runtime->private_data;
 
-	if (pair)
-		fsl_asrc_release_pair(pair);
+	if (asrc_priv->pair_streams & BIT(substream->stream)) {
+		if (pair)
+			fsl_asrc_release_pair(pair);
+		asrc_priv->pair_streams &= ~BIT(substream->stream);
+	}
 
 	return 0;
 }
diff --git a/sound/soc/fsl/fsl_asrc.h b/sound/soc/fsl/fsl_asrc.h
index fafa22b..48b39c2 100644
--- a/sound/soc/fsl/fsl_asrc.h
+++ b/sound/soc/fsl/fsl_asrc.h
@@ -343,6 +343,7 @@ struct fsl_asrc_pair {
  * @pair: pair pointers
  * @channel_bits: width of ASRCNCR register for each pair
  * @channel_avail: non-occupied channel numbers
+ * @pair_streams:indicat which substream is running
  * @asrc_rate: default sample rate for ASoC Back-Ends
  * @asrc_width: default sample width for ASoC Back-Ends
  * @regcache_cfg: store register value of REG_ASRCFG
@@ -363,6 +364,7 @@ struct fsl_asrc {
 	struct fsl_asrc_pair *pair[ASRC_PAIR_MAX_NUM];
 	unsigned int channel_bits;
 	unsigned int channel_avail;
+	unsigned int pair_streams;
 
 	int asrc_rate;
 	int asrc_width;
diff --git a/sound/soc/fsl/fsl_asrc_m2m.c b/sound/soc/fsl/fsl_asrc_m2m.c
index 9ee0f50..7363dc0 100644
--- a/sound/soc/fsl/fsl_asrc_m2m.c
+++ b/sound/soc/fsl/fsl_asrc_m2m.c
@@ -274,7 +274,8 @@ static int fsl_asrc_prepare_io_buffer(struct fsl_asrc_pair *pair,
 		word_size = 2;
 
 	if (buf_len < word_size * pair->channels * wm ||
-	    buf_len > ASRC_DMA_BUFFER_SIZE) {
+	    buf_len > ASRC_DMA_BUFFER_SIZE ||
+	    (dir == OUT && buf_len < word_size * pair->channels * last_period_size)) {
 		pair_err("%sput buffer size is error: [%d]\n",
 				DIR_STR(dir), buf_len);
 		return -EINVAL;
@@ -557,7 +558,9 @@ static long fsl_asrc_ioctl_config_pair(struct fsl_asrc_pair *pair,
 	m2m->rate[IN] = config.input_sample_rate;
 	m2m->rate[OUT] = config.output_sample_rate;
 
-	if (m2m->rate[OUT] > m2m->rate[IN])
+	if (m2m->rate[OUT] >= m2m->rate[IN] * 8)
+		m2m->last_period_size = (m2m->rate[OUT] / m2m->rate[IN]) * 5;
+	else if (m2m->rate[OUT] > m2m->rate[IN])
 		m2m->last_period_size = ASRC_OUTPUT_LAST_SAMPLE_MAX;
 	else
 		m2m->last_period_size = ASRC_OUTPUT_LAST_SAMPLE;
@@ -852,14 +855,6 @@ static int fsl_asrc_close(struct inode *inode, struct file *file)
 	struct fsl_asrc *asrc_priv = pair->asrc_priv;
 	struct device *dev = &asrc_priv->pdev->dev;
 	unsigned long lock_flags;
-	int i;
-
-	/* Make sure we have clear the pointer */
-	spin_lock_irqsave(&asrc_priv->lock, lock_flags);
-	for (i = 0; i < ASRC_PAIR_MAX_NUM; i++)
-		if (asrc_priv->pair[i] == pair)
-			asrc_priv->pair[i] = NULL;
-	spin_unlock_irqrestore(&asrc_priv->lock, lock_flags);
 
 	if (m2m->asrc_active) {
 		m2m->asrc_active = 0;
-- 
1.7.5.4

