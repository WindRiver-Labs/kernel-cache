From a6c0b2aa9d9739dc66661dad2840cbba5324d939 Mon Sep 17 00:00:00 2001
From: Max Krummenacher <max.oss.09@gmail.com>
Date: Wed, 27 Sep 2017 14:30:30 +0200
Subject: [PATCH] mtd: fsl-quadspi: fix macro collision problems with
 READ/WRITE"

commit 6c1ad49339f46ff453d6f07be7d63fd495069bfe from
https://github.com/Freescale/linux-fslc.git

Mainline commit 9386aae907d9ee79d54640f09d70909393e0ddeb addresses
macro collisions, however the mainline and downstream kernel driver
do not match.

Fix the issue addressed in mainline in the downstream codebase.

Signed-off-by: Max Krummenacher <max.krummenacher@toradex.com>
Signed-off-by: Otavio Salvador <otavio@ossystems.com.br>
Signed-off-by: Ovidiu Panait <ovidiu.panait@windriver.com>
---
 drivers/mtd/spi-nor/fsl-quadspi.c |   78 ++++++++++++++++++++-----------------
 1 file changed, 42 insertions(+), 36 deletions(-)

diff --git a/drivers/mtd/spi-nor/fsl-quadspi.c b/drivers/mtd/spi-nor/fsl-quadspi.c
index f769c5a..09bc90f 100644
--- a/drivers/mtd/spi-nor/fsl-quadspi.c
+++ b/drivers/mtd/spi-nor/fsl-quadspi.c
@@ -193,7 +193,7 @@
 /* Macros for constructing the LUT register. */
 #define LUT0(ins, pad, opr)						\
 		(((opr) << OPRND0_SHIFT) | ((LUT_##pad) << PAD0_SHIFT) | \
-		((LUT_##ins) << INSTR0_SHIFT))
+		((ins) << INSTR0_SHIFT))
 
 #define LUT1(ins, pad, opr)	(LUT0(ins, pad, opr) << OPRND1_SHIFT)
 
@@ -243,10 +243,10 @@ struct lut_desc_pair current_lut_pair;
 
 static const struct lut_desc_pair dynamic_lut_table[] = {
 	/* VCR RD/WR pair */
-	{ {SPINOR_OP_RD_VCR, {LUT0(CMD, PAD1, SPINOR_OP_RD_EVCR) |
-			     LUT1(READ, PAD1, 0x1)} },
-	  {SPINOR_OP_WR_VCR, {LUT0(CMD, PAD1, SPINOR_OP_WD_EVCR) |
-			     LUT1(WRITE, PAD1, 0x1)} },
+	{ {SPINOR_OP_RD_VCR, {LUT0(LUT_CMD, PAD1, SPINOR_OP_RD_EVCR) |
+			     LUT1(LUT_READ, PAD1, 0x1)} },
+	  {SPINOR_OP_WR_VCR, {LUT0(LUT_CMD, PAD1, SPINOR_OP_WD_EVCR) |
+			     LUT1(LUT_WRITE, PAD1, 0x1)} },
 	},
 	{/* sentinel */},
 };
@@ -409,11 +409,11 @@ static void fsl_qspi_init_lut(struct fsl_qspi *q)
 	if (nor->flash_read == SPI_NOR_QUAD) {
 		if (op == SPINOR_OP_READ_1_1_4 || op == SPINOR_OP_READ4_1_1_4) {
 			/* read mode : 1-1-4 */
-			writel(LUT0(CMD, PAD1, op) | LUT1(ADDR, PAD1, addrlen),
-				base + QUADSPI_LUT(lut_base));
+			writel(LUT0(LUT_CMD, PAD1, op) | LUT1(LUT_ADDR, PAD1,
+				addrlen), base + QUADSPI_LUT(lut_base));
 
-			writel(LUT0(DUMMY, PAD1, dm) | LUT1(READ, PAD4, rxfifo),
-				base + QUADSPI_LUT(lut_base + 1));
+			writel(LUT0(LUT_DUMMY, PAD1, dm) | LUT1(LUT_READ, PAD4,
+				rxfifo), base + QUADSPI_LUT(lut_base + 1));
 		} else {
 			dev_err(nor->dev, "Unsupported opcode : 0x%.2x\n", op);
 		}
@@ -421,28 +421,28 @@ static void fsl_qspi_init_lut(struct fsl_qspi *q)
 		if (op == SPINOR_OP_READ_1_4_4_D ||
 			 op == SPINOR_OP_READ4_1_4_4_D) {
 			/* read mode : 1-4-4, such as Spansion s25fl128s. */
-			writel(LUT0(CMD, PAD1, op)
-				| LUT1(ADDR_DDR, PAD4, addrlen),
+			writel(LUT0(LUT_CMD, PAD1, op)
+				| LUT1(LUT_ADDR_DDR, PAD4, addrlen),
 				base + QUADSPI_LUT(lut_base));
 
-			writel(LUT0(MODE_DDR, PAD4, 0xff)
-				| LUT1(DUMMY, PAD1, dm),
+			writel(LUT0(LUT_MODE_DDR, PAD4, 0xff)
+				| LUT1(LUT_DUMMY, PAD1, dm),
 				base + QUADSPI_LUT(lut_base + 1));
 
-			writel(LUT0(READ_DDR, PAD4, rxfifo)
-				| LUT1(JMP_ON_CS, PAD1, 0),
+			writel(LUT0(LUT_READ_DDR, PAD4, rxfifo)
+				| LUT1(LUT_JMP_ON_CS, PAD1, 0),
 				base + QUADSPI_LUT(lut_base + 2));
 		} else if (op == SPINOR_OP_READ_1_1_4_D) {
 			/* read mode : 1-1-4, such as Micron N25Q256A. */
-			writel(LUT0(CMD, PAD1, op)
-				| LUT1(ADDR_DDR, PAD1, addrlen),
+			writel(LUT0(LUT_CMD, PAD1, op)
+				| LUT1(LUT_ADDR_DDR, PAD1, addrlen),
 				base + QUADSPI_LUT(lut_base));
 
-			writel(LUT0(DUMMY, PAD1, dm)
-				| LUT1(READ_DDR, PAD4, rxfifo),
+			writel(LUT0(LUT_DUMMY, PAD1, dm)
+				| LUT1(LUT_READ_DDR, PAD4, rxfifo),
 				base + QUADSPI_LUT(lut_base + 1));
 
-			writel(LUT0(JMP_ON_CS, PAD1, 0),
+			writel(LUT0(LUT_JMP_ON_CS, PAD1, 0),
 				base + QUADSPI_LUT(lut_base + 2));
 		} else {
 			dev_err(nor->dev, "Unsupported opcode : 0x%.2x\n", op);
@@ -451,63 +451,69 @@ static void fsl_qspi_init_lut(struct fsl_qspi *q)
 
 	/* Write enable */
 	lut_base = SEQID_WREN * 4;
-	writel(LUT0(CMD, PAD1, SPINOR_OP_WREN), base + QUADSPI_LUT(lut_base));
+	writel(LUT0(LUT_CMD, PAD1, SPINOR_OP_WREN),
+		base + QUADSPI_LUT(lut_base));
 
 	/* Page Program */
 	lut_base = SEQID_PP * 4;
-	writel(LUT0(CMD, PAD1, nor->program_opcode) | LUT1(ADDR, PAD1, addrlen),
-			base + QUADSPI_LUT(lut_base));
-	writel(LUT0(WRITE, PAD1, 0), base + QUADSPI_LUT(lut_base + 1));
+	writel(LUT0(LUT_CMD, PAD1, nor->program_opcode) | LUT1(LUT_ADDR, PAD1,
+			addrlen), base + QUADSPI_LUT(lut_base));
+	writel(LUT0(LUT_WRITE, PAD1, 0), base + QUADSPI_LUT(lut_base + 1));
 
 	/* Read Status */
 	lut_base = SEQID_RDSR * 4;
-	writel(LUT0(CMD, PAD1, SPINOR_OP_RDSR) | LUT1(READ, PAD1, 0x1),
+	writel(LUT0(LUT_CMD, PAD1, SPINOR_OP_RDSR) | LUT1(LUT_READ, PAD1, 0x1),
 			base + QUADSPI_LUT(lut_base));
 
 	/* Erase a sector */
 	lut_base = SEQID_SE * 4;
-	writel(LUT0(CMD, PAD1, nor->erase_opcode) | LUT1(ADDR, PAD1, addrlen),
-			base + QUADSPI_LUT(lut_base));
+	writel(LUT0(LUT_CMD, PAD1, nor->erase_opcode) | LUT1(LUT_ADDR, PAD1,
+		addrlen), base + QUADSPI_LUT(lut_base));
 
 	/* Erase the whole chip */
 	lut_base = SEQID_CHIP_ERASE * 4;
-	writel(LUT0(CMD, PAD1, SPINOR_OP_CHIP_ERASE),
+	writel(LUT0(LUT_CMD, PAD1, SPINOR_OP_CHIP_ERASE),
 			base + QUADSPI_LUT(lut_base));
 
 	/* READ ID */
 	lut_base = SEQID_RDID * 4;
-	writel(LUT0(CMD, PAD1, SPINOR_OP_RDID) | LUT1(READ, PAD1, 0x8),
+	writel(LUT0(LUT_CMD, PAD1, SPINOR_OP_RDID) | LUT1(LUT_READ, PAD1, 0x8),
 			base + QUADSPI_LUT(lut_base));
 
 	/* Write Register */
 	lut_base = SEQID_WRSR * 4;
-	writel(LUT0(CMD, PAD1, SPINOR_OP_WRSR) | LUT1(WRITE, PAD1, 0x2),
+	writel(LUT0(LUT_CMD, PAD1, SPINOR_OP_WRSR) | LUT1(LUT_WRITE, PAD1, 0x2),
 			base + QUADSPI_LUT(lut_base));
 
 	/* Read Configuration Register */
 	lut_base = SEQID_RDCR * 4;
-	writel(LUT0(CMD, PAD1, SPINOR_OP_RDCR) | LUT1(READ, PAD1, 0x1),
+	writel(LUT0(LUT_CMD, PAD1, SPINOR_OP_RDCR) | LUT1(LUT_READ, PAD1, 0x1),
 			base + QUADSPI_LUT(lut_base));
 
 	/* Write disable */
 	lut_base = SEQID_WRDI * 4;
-	writel(LUT0(CMD, PAD1, SPINOR_OP_WRDI), base + QUADSPI_LUT(lut_base));
+	writel(LUT0(LUT_CMD, PAD1, SPINOR_OP_WRDI),
+		base + QUADSPI_LUT(lut_base));
 
 	/* Enter 4 Byte Mode (Micron) */
 	lut_base = SEQID_EN4B * 4;
-	writel(LUT0(CMD, PAD1, SPINOR_OP_EN4B), base + QUADSPI_LUT(lut_base));
+	writel(LUT0(LUT_CMD, PAD1, SPINOR_OP_EN4B),
+		base + QUADSPI_LUT(lut_base));
 
 	/* Enter 4 Byte Mode (Spansion) */
 	lut_base = SEQID_BRWR * 4;
-	writel(LUT0(CMD, PAD1, SPINOR_OP_BRWR), base + QUADSPI_LUT(lut_base));
+	writel(LUT0(LUT_CMD, PAD1, SPINOR_OP_BRWR),
+		base + QUADSPI_LUT(lut_base));
 
 	/* Read EVCR register */
 	lut_base = SEQID_RD_EVCR * 4;
-	writel(LUT0(CMD, PAD1, SPINOR_OP_RD_EVCR), base + QUADSPI_LUT(lut_base));
+	writel(LUT0(LUT_CMD, PAD1, SPINOR_OP_RD_EVCR),
+		base + QUADSPI_LUT(lut_base));
 
 	/* Write EVCR register */
 	lut_base = SEQID_WD_EVCR * 4;
-	writel(LUT0(CMD, PAD1, SPINOR_OP_WD_EVCR), base + QUADSPI_LUT(lut_base));
+	writel(LUT0(LUT_CMD, PAD1, SPINOR_OP_WD_EVCR),
+		base + QUADSPI_LUT(lut_base));
 	fsl_qspi_lock_lut(q);
 }
 
-- 
1.7.9.5

