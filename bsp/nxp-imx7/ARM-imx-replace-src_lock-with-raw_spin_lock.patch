From 683543fd32ebf4f4caa5e66c95c12431a206af57 Mon Sep 17 00:00:00 2001
From: zou cao <cao.zou@windriver.com>
Date: Thu, 27 Apr 2017 07:10:00 +0000
Subject: [PATCH] ARM: imx: replace src_lock with raw_spin_lock

imx7 now support low power idle mode, src_lock will be ran in cpuidle driver
with irq-disabled, it fix the below call trace:

BUG: sleeping function called from invalid context at kernel/locking/rtmutex.c:917
in_atomic(): 1, irqs_disabled(): 128, pid: 0, name: swapper/1
Preemption disabled at:[<  (null)>]   (null)

CPU: 1 PID: 0 Comm: swapper/1 Not tainted 4.1.21-rt13-WR8.0.0.0_preempt-rt #3
Hardware name: Freescale i.MX7 Dual (Device Tree)
[<8001a0e8>] (unwind_backtrace) from [<80013b30>] (show_stack+0x20/0x24)
[<80013b30>] (show_stack) from [<8088bef4>] (dump_stack+0x84/0xa8)
[<8088bef4>] (dump_stack) from [<8005b120>] (___might_sleep+0x184/0x1b8)
[<8005b120>] (___might_sleep) from [<808922e0>] (rt_spin_lock+0x28/0x78)
[<808922e0>] (rt_spin_lock) from [<8002aa20>] (imx_set_cpu_jump+0x28/0x7c)
[<8002aa20>] (imx_set_cpu_jump) from [<80027648>] (imx7d_enter_low_power_idle+0x108/0x198)
[<805ddd68>] (cpuidle_enter_state) from [<805de028>] (cpuidle_enter+0x24/0x28)
[<805de028>] (cpuidle_enter) from [<80073310>] (cpu_startup_entry+0x388/0x4f0)
[<80073310>] (cpu_startup_entry) from [<80016c4c>] (secondary_start_kernel+0x114/0x130)
[<80016c4c>] (secondary_start_kernel) from [<8000950c>] (__enable_mmu+0x0/0x14)

Signed-off-by: zou cao <cao.zou@windriver.com>
---
 arch/arm/mach-imx/src.c |   18 +++++++++---------
 1 files changed, 9 insertions(+), 9 deletions(-)

diff --git a/arch/arm/mach-imx/src.c b/arch/arm/mach-imx/src.c
index 4661c5e..0ae958e 100644
--- a/arch/arm/mach-imx/src.c
+++ b/arch/arm/mach-imx/src.c
@@ -40,7 +40,7 @@
 #define BP_SRC_A7RCR1_A7_CORE1_ENABLE  1
 
 static void __iomem *src_base;
-static DEFINE_SPINLOCK(src_lock);
+static DEFINE_RAW_SPINLOCK(src_lock);
 static bool m4_is_enabled;
 
 static const int sw_reset_bits[5] = {
@@ -72,11 +72,11 @@ static int imx_src_reset_module(struct reset_controller_dev *rcdev,
 
 	bit = 1 << sw_reset_bits[sw_reset_idx];
 
-	spin_lock_irqsave(&src_lock, flags);
+	raw_spin_lock_irqsave(&src_lock, flags);
 	val = readl_relaxed(src_base + SRC_SCR);
 	val |= bit;
 	writel_relaxed(val, src_base + SRC_SCR);
-	spin_unlock_irqrestore(&src_lock, flags);
+	raw_spin_unlock_irqrestore(&src_lock, flags);
 
 	timeout = jiffies + msecs_to_jiffies(1000);
 	while (readl(src_base + SRC_SCR) & bit) {
@@ -102,7 +102,7 @@ void imx_enable_cpu(int cpu, bool enable)
 	u32 mask, val;
 
 	cpu = cpu_logical_map(cpu);
-	spin_lock(&src_lock);
+	raw_spin_lock(&src_lock);
 	if (cpu_is_imx7d()) {
 		/* enable core */
 		if (enable)
@@ -119,12 +119,12 @@ void imx_enable_cpu(int cpu, bool enable)
 		val |= 1 << (BP_SRC_SCR_CORE1_RST + cpu - 1);
 		writel_relaxed(val, src_base + SRC_SCR);
 	}
-		spin_unlock(&src_lock);
+		raw_spin_unlock(&src_lock);
 }
 
 void imx_set_cpu_jump(int cpu, void *jump_addr)
 {
-	spin_lock(&src_lock);
+	raw_spin_lock(&src_lock);
 	cpu = cpu_logical_map(cpu);
 	if (cpu_is_imx7d())
 		writel_relaxed(virt_to_phys(jump_addr),
@@ -132,7 +132,7 @@ void imx_set_cpu_jump(int cpu, void *jump_addr)
 	else
 		writel_relaxed(virt_to_phys(jump_addr),
 			src_base + SRC_GPR1 + cpu * 8);
-	spin_unlock(&src_lock);
+	raw_spin_unlock(&src_lock);
 }
 
 u32 imx_get_cpu_arg(int cpu)
@@ -185,7 +185,7 @@ void __init imx_src_init(void)
 	 * force warm reset sources to generate cold reset
 	 * for a more reliable restart
 	 */
-	spin_lock(&src_lock);
+	raw_spin_lock(&src_lock);
 	val = readl_relaxed(src_base + SRC_SCR);
 
 	/* bit 4 is m4c_non_sclr_rst on i.MX6SX */
@@ -197,5 +197,5 @@ void __init imx_src_init(void)
 
 	val &= ~(1 << BP_SRC_SCR_WARM_RESET_ENABLE);
 	writel_relaxed(val, src_base + SRC_SCR);
-	spin_unlock(&src_lock);
+	raw_spin_unlock(&src_lock);
 }
-- 
1.7.5.4

