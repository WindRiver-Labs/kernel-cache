From 2f48bbb5b3383c06a1bb163628594635592be0f7 Mon Sep 17 00:00:00 2001
From: Richard Zhu <hongxing.zhu@nxp.com>
Date: Fri, 19 Aug 2016 15:29:17 +0800
Subject: [PATCH 73/85] MLK-13186-4 PCI: imx: enable external osc support

In order to pass the pcie gen2 compliance tests,
the external oscillator is mandatory required by
imx6 legacy platforms.
add the external osc support by this patch.
- pll6 should be set bypass mode.
- src of the pll6_bypass should be lvds_clk1
- adjust the swing/deemphase value
- re-configure the phy if the external 100Mhz
differential osc is used. Because that phy used
the 125Mhz before.

Signed-off-by: Richard Zhu <hongxing.zhu@nxp.com>
(cherry picked from commit c98c16d7a28641cdc032a46d139baf592a5f4a7d)
[zou:Original patch taken from
git://git.freescale.com/imx/linux-imx.git imx_4.1.15_2.0.0_ga]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/pci/host/pci-imx6.c |  114 +++++++++++++++++++++++++++++++++++-------
 1 files changed, 95 insertions(+), 19 deletions(-)

diff --git a/drivers/pci/host/pci-imx6.c b/drivers/pci/host/pci-imx6.c
index c519e8e..167987a 100644
--- a/drivers/pci/host/pci-imx6.c
+++ b/drivers/pci/host/pci-imx6.c
@@ -47,6 +47,7 @@
 static u32 ddr_test_region = 0, test_region_size = SZ_2M;
 
 struct imx6_pcie {
+	u32 			ext_osc;
 	int			dis_gpio;
 	int			power_on_gpio;
 	int			reset_gpio;
@@ -54,6 +55,8 @@ struct imx6_pcie {
 	struct clk		*pcie_inbound_axi;
 	struct clk		*pcie_phy;
 	struct clk		*pcie;
+	struct clk		*pcie_ext;
+	struct clk		*pcie_ext_src;
 	struct pcie_port	pp;
 	struct regmap		*iomuxc_gpr;
 	struct regmap		*reg_src;
@@ -98,6 +101,25 @@ struct imx6_pcie {
 #define PHY_RX_OVRD_IN_LO_RX_DATA_EN (1 << 5)
 #define PHY_RX_OVRD_IN_LO_RX_PLL_EN (1 << 3)
 
+#define SSP_CR_SUP_DIG_MPLL_OVRD_IN_LO 0x0011
+/* FIELD: RES_ACK_IN_OVRD [15:15]
+ * FIELD: RES_ACK_IN [14:14]
+ * FIELD: RES_REQ_IN_OVRD [13:13]
+ * FIELD: RES_REQ_IN [12:12]
+ * FIELD: RTUNE_REQ_OVRD [11:11]
+ * FIELD: RTUNE_REQ [10:10]
+ * FIELD: MPLL_MULTIPLIER_OVRD [9:9]
+ * FIELD: MPLL_MULTIPLIER [8:2]
+ * FIELD: MPLL_EN_OVRD [1:1]
+ * FIELD: MPLL_EN [0:0]
+ */
+
+#define SSP_CR_SUP_DIG_ATEOVRD 0x0010
+/* FIELD: ateovrd_en [2:2]
+ * FIELD: ref_usb2_en [1:1]
+ * FIELD: ref_clkdiv2 [0:0]
+ */
+
 static inline bool is_imx7d_pcie(struct imx6_pcie *imx6_pcie)
 {
 	struct pcie_port *pp = &imx6_pcie->pp;
@@ -339,31 +361,42 @@ static void pci_imx_phy_pll_locked(struct imx6_pcie *imx6_pcie)
 static int imx6_pcie_deassert_core_reset(struct pcie_port *pp)
 {
 	int ret;
+	u32 val;
 	struct imx6_pcie *imx6_pcie = to_imx6_pcie(pp);
 
 	if (gpio_is_valid(imx6_pcie->power_on_gpio))
 		gpio_set_value_cansleep(imx6_pcie->power_on_gpio, 1);
 
 	request_bus_freq(BUS_FREQ_HIGH);
-	ret = clk_prepare_enable(imx6_pcie->pcie_phy);
+	ret = clk_prepare_enable(imx6_pcie->pcie);
 	if (ret) {
-		dev_err(pp->dev, "unable to enable pcie_phy clock\n");
-		goto err_pcie_phy;
+		dev_err(pp->dev, "unable to enable pcie clock\n");
+		goto err_pcie;
 	}
 
 	if (!IS_ENABLED(CONFIG_EP_MODE_IN_EP_RC_SYS)
 			&& !IS_ENABLED(CONFIG_RC_MODE_IN_EP_RC_SYS)) {
-		ret = clk_prepare_enable(imx6_pcie->pcie_bus);
-		if (ret) {
-			dev_err(pp->dev, "unable to enable pcie_bus clock\n");
-			goto err_pcie_bus;
+		if (imx6_pcie->ext_osc) {
+			clk_set_parent(imx6_pcie->pcie_ext,
+					imx6_pcie->pcie_ext_src);
+			ret = clk_prepare_enable(imx6_pcie->pcie_ext);
+			if (ret) {
+				dev_err(pp->dev, "unable to enable pcie_ext clock\n");
+				goto err_pcie_bus;
+			}
+		} else {
+			ret = clk_prepare_enable(imx6_pcie->pcie_bus);
+			if (ret) {
+				dev_err(pp->dev, "unable to enable pcie_bus clock\n");
+				goto err_pcie_bus;
+			}
 		}
 	}
 
-	ret = clk_prepare_enable(imx6_pcie->pcie);
+	ret = clk_prepare_enable(imx6_pcie->pcie_phy);
 	if (ret) {
-		dev_err(pp->dev, "unable to enable pcie clock\n");
-		goto err_pcie;
+		dev_err(pp->dev, "unable to enable pcie_phy clock\n");
+		goto err_pcie_phy;
 	}
 
 	if (is_imx6sx_pcie(imx6_pcie)) {
@@ -426,17 +459,39 @@ static int imx6_pcie_deassert_core_reset(struct pcie_port *pp)
 		udelay(200);
 	}
 
+	/* Configure the PHY when 100Mhz external OSC is used as input clock */
+	if (imx6_pcie->ext_osc && is_imx6qp_pcie(imx6_pcie)) {
+		mdelay(4);
+		pcie_phy_read(pp->dbi_base, SSP_CR_SUP_DIG_MPLL_OVRD_IN_LO, &val);
+		/* MPLL_MULTIPLIER [8:2] */
+		val &= ~(0x7F << 2);
+		val |= (0x19 << 2);
+		/* MPLL_MULTIPLIER_OVRD [9:9] */
+		val |= (0x1 << 9);
+		pcie_phy_write(pp->dbi_base, SSP_CR_SUP_DIG_MPLL_OVRD_IN_LO, val);
+		mdelay(4);
+
+		pcie_phy_read(pp->dbi_base, SSP_CR_SUP_DIG_ATEOVRD, &val);
+		/* ref_clkdiv2 [0:0] */
+		val &= ~0x1;
+		/* ateovrd_en [2:2] */
+		val |=  0x4;
+		pcie_phy_write(pp->dbi_base, SSP_CR_SUP_DIG_ATEOVRD, val);
+		mdelay(4);
+	}
+
 	return 0;
 
 err_inbound_axi:
 	clk_disable_unprepare(imx6_pcie->pcie);
-err_pcie:
+err_pcie_phy:
 	if (!IS_ENABLED(CONFIG_EP_MODE_IN_EP_RC_SYS)
-			&& !IS_ENABLED(CONFIG_RC_MODE_IN_EP_RC_SYS))
+			&& !IS_ENABLED(CONFIG_RC_MODE_IN_EP_RC_SYS)
+			&& !imx6_pcie->ext_osc)
 		clk_disable_unprepare(imx6_pcie->pcie_bus);
 err_pcie_bus:
-	clk_disable_unprepare(imx6_pcie->pcie_phy);
-err_pcie_phy:
+	clk_disable_unprepare(imx6_pcie->pcie);
+err_pcie:
 	return ret;
 
 }
@@ -487,15 +542,15 @@ static void imx6_pcie_init_phy(struct pcie_port *pp)
 				IMX6Q_GPR12_LOS_LEVEL, IMX6Q_GPR12_LOS_LEVEL_9);
 
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR8,
-				IMX6Q_GPR8_TX_DEEMPH_GEN1, 0 << 0);
+				IMX6Q_GPR8_TX_DEEMPH_GEN1, 20 << 0);
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR8,
-				IMX6Q_GPR8_TX_DEEMPH_GEN2_3P5DB, 0 << 6);
+				IMX6Q_GPR8_TX_DEEMPH_GEN2_3P5DB, 20 << 6);
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR8,
 				IMX6Q_GPR8_TX_DEEMPH_GEN2_6DB, 20 << 12);
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR8,
-				IMX6Q_GPR8_TX_SWING_FULL, 127 << 18);
+				IMX6Q_GPR8_TX_SWING_FULL, 115 << 18);
 		regmap_update_bits(imx6_pcie->iomuxc_gpr, IOMUXC_GPR8,
-				IMX6Q_GPR8_TX_SWING_LOW, 127 << 25);
+				IMX6Q_GPR8_TX_SWING_LOW, 115 << 25);
 	}
 
 	/* configure the device type */
@@ -998,7 +1053,8 @@ static int pci_imx_suspend_noirq(struct device *dev)
 		/* Disable clks */
 		clk_disable_unprepare(imx6_pcie->pcie);
 		clk_disable_unprepare(imx6_pcie->pcie_phy);
-		clk_disable_unprepare(imx6_pcie->pcie_bus);
+		if (!imx6_pcie->ext_osc)
+			clk_disable_unprepare(imx6_pcie->pcie_bus);
 		if (is_imx6sx_pcie(imx6_pcie))
 			clk_disable_unprepare(imx6_pcie->pcie_inbound_axi);
 		else if (is_imx7d_pcie(imx6_pcie))
@@ -1183,6 +1239,26 @@ static int __init imx6_pcie_probe(struct platform_device *pdev)
 		return PTR_ERR(imx6_pcie->pcie_bus);
 	}
 
+	if (of_property_read_u32(np, "ext_osc", &imx6_pcie->ext_osc) < 0)
+		imx6_pcie->ext_osc = 0;
+
+	if (imx6_pcie->ext_osc) {
+		imx6_pcie->pcie_ext = devm_clk_get(&pdev->dev, "pcie_ext");
+		if (IS_ERR(imx6_pcie->pcie_ext)) {
+			dev_err(&pdev->dev,
+				"pcie_ext clock source missing or invalid\n");
+			return PTR_ERR(imx6_pcie->pcie_ext);
+		}
+
+		imx6_pcie->pcie_ext_src = devm_clk_get(&pdev->dev,
+				"pcie_ext_src");
+		if (IS_ERR(imx6_pcie->pcie_ext_src)) {
+			dev_err(&pdev->dev,
+				"pcie_ext_src clk src missing or invalid\n");
+			return PTR_ERR(imx6_pcie->pcie_ext_src);
+		}
+	}
+
 	imx6_pcie->pcie = devm_clk_get(&pdev->dev, "pcie");
 	if (IS_ERR(imx6_pcie->pcie)) {
 		dev_err(&pdev->dev,
-- 
1.7.5.4

