From 7e2ead38c5c805edfbd198b3f9de118552afad5f Mon Sep 17 00:00:00 2001
From: ye li <ye.li@nxp.com>
Date: Fri, 9 Sep 2016 22:06:57 +0800
Subject: [PATCH 74/85] MLK-12997 CRYPTO: CAAM: Fix kernel hang in CAAM when
 HAB boot

When HAB boot, the CAAM clocks are disabled after authenticate kernel image.
But the CAAM driver accesses the CTPR_MS register earlier than enabling clocks,
which causes kernel hang.

Fix the issue by moving the page size getting later than clocks enabling.

Signed-off-by: ye li <ye.li@nxp.com>
(cherry picked from commit 781ffdb82e9a08521394e6a3b94a4354e94c51eb)
[zou:Original patch taken from
git://git.freescale.com/imx/linux-imx.git imx_4.1.15_2.0.0_ga]
Signed-off-by: zou cao <cao.zou@windriver.com>
---
 drivers/crypto/caam/ctrl.c |   43 ++++++++++++++++++++++---------------------
 1 files changed, 22 insertions(+), 21 deletions(-)

diff --git a/drivers/crypto/caam/ctrl.c b/drivers/crypto/caam/ctrl.c
index c811674..c160f83 100644
--- a/drivers/crypto/caam/ctrl.c
+++ b/drivers/crypto/caam/ctrl.c
@@ -468,27 +468,6 @@ static int caam_probe(struct platform_device *pdev)
 		dev_err(dev, "caam: of_iomap() failed\n");
 		return -ENOMEM;
 	}
-	/* Finding the page size for using the CTPR_MS register */
-	comp_params = rd_reg32(&ctrl->perfmon.comp_parms_ms);
-	pg_size = (comp_params & CTPR_MS_PG_SZ_MASK) >> CTPR_MS_PG_SZ_SHIFT;
-
-	/* Allocating the BLOCK_OFFSET based on the supported page size on
-	 * the platform
-	 */
-	if (pg_size == 0)
-		BLOCK_OFFSET = PG_SIZE_4K;
-	else
-		BLOCK_OFFSET = PG_SIZE_64K;
-
-	ctrlpriv->ctrl = (struct caam_ctrl __force *)ctrl;
-	ctrlpriv->assure = (struct caam_assurance __force *)
-			   ((uint8_t *)ctrl +
-			    BLOCK_OFFSET * ASSURE_BLOCK_NUMBER
-			   );
-	ctrlpriv->deco = (struct caam_deco __force *)
-			 ((uint8_t *)ctrl +
-			 BLOCK_OFFSET * DECO_BLOCK_NUMBER
-			 );
 
 	/* Get CAAM-SM node and of_iomap() and save */
 	np = of_find_compatible_node(NULL, NULL, "fsl,imx6q-caam-sm");
@@ -584,6 +563,28 @@ static int caam_probe(struct platform_device *pdev)
 	}
 #endif
 
+	/* Finding the page size for using the CTPR_MS register */
+        comp_params = rd_reg32(&ctrl->perfmon.comp_parms_ms);
+        pg_size = (comp_params & CTPR_MS_PG_SZ_MASK) >> CTPR_MS_PG_SZ_SHIFT;
+
+        /* Allocating the BLOCK_OFFSET based on the supported page size on
+         * the platform
+         */
+        if (pg_size == 0)
+                BLOCK_OFFSET = PG_SIZE_4K;
+        else
+                BLOCK_OFFSET = PG_SIZE_64K;
+
+        ctrlpriv->ctrl = (struct caam_ctrl __force *)ctrl;
+        ctrlpriv->assure = (struct caam_assurance __force *)
+                           ((uint8_t *)ctrl +
+                            BLOCK_OFFSET * ASSURE_BLOCK_NUMBER
+                           );
+        ctrlpriv->deco = (struct caam_deco __force *)
+                         ((uint8_t *)ctrl +
+                         BLOCK_OFFSET * DECO_BLOCK_NUMBER
+                         );
+
 	/*
 	 * Enable DECO watchdogs and, if this is a PHYS_ADDR_T_64BIT kernel,
 	 * long pointers in master configuration register
-- 
1.7.5.4

