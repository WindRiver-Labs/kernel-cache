From 9e76f4e3ca5ed4c145c6e09ec97abb252cb59705 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Tue, 6 Aug 2013 16:54:27 +0800
Subject: [PATCH 9/9] powerpc/86xx: add the kexec/kdump support

This is based on the mpc85xx code. Currently we only support
UP for the kexec/kdump kernel.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/platforms/86xx/mpc86xx_smp.c |  115 +++++++++++++++++++++++++++++
 1 files changed, 115 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/platforms/86xx/mpc86xx_smp.c b/arch/powerpc/platforms/86xx/mpc86xx_smp.c
index af09bae..3ed6e49 100644
--- a/arch/powerpc/platforms/86xx/mpc86xx_smp.c
+++ b/arch/powerpc/platforms/86xx/mpc86xx_smp.c
@@ -14,6 +14,8 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/delay.h>
+#include <linux/highmem.h>
+#include <linux/kexec.h>
 
 #include <asm/code-patching.h>
 #include <asm/page.h>
@@ -113,9 +115,122 @@ struct smp_ops_t smp_86xx_ops = {
 	.give_timebase = smp_generic_give_timebase,
 };
 
+#ifdef CONFIG_KEXEC
+void smp_86xx_kexec_cpu_down(int crash, int secondary)
+{
+	if (!secondary)
+		return;
+
+	while (1)
+		;
+}
+
+static void smp_86xx_kexec_down(void *arg)
+{
+	if (ppc_md.kexec_cpu_down)
+		ppc_md.kexec_cpu_down(0, 1);
+}
+
+static void map_and_flush(unsigned long paddr)
+{
+	struct page *page = pfn_to_page(paddr >> PAGE_SHIFT);
+	unsigned long kaddr  = (unsigned long)kmap(page);
+
+	flush_dcache_range(kaddr, kaddr + PAGE_SIZE);
+	kunmap(page);
+}
+
+/**
+ * Before we reset the other cores, we need to flush relevant cache
+ * out to memory so we don't get anything corrupted, some of these flushes
+ * are performed out of an overabundance of caution as interrupts are not
+ * disabled yet and we can switch cores
+ */
+static void mpc86xx_smp_flush_dcache_kexec(struct kimage *image)
+{
+	kimage_entry_t *ptr, entry;
+	unsigned long paddr;
+	int i;
+
+	if (image->type == KEXEC_TYPE_DEFAULT) {
+		/* normal kexec images are stored in temporary pages */
+		for (ptr = &image->head; (entry = *ptr) && !(entry & IND_DONE);
+		     ptr = (entry & IND_INDIRECTION) ?
+				phys_to_virt(entry & PAGE_MASK) : ptr + 1) {
+			if (!(entry & IND_DESTINATION))
+				map_and_flush(entry);
+		}
+		/* flush out last IND_DONE page */
+		map_and_flush(entry);
+	} else {
+		/* crash type kexec images are copied to the crash region */
+		for (i = 0; i < image->nr_segments; i++) {
+			struct kexec_segment *seg = &image->segment[i];
+			for (paddr = seg->mem; paddr < seg->mem + seg->memsz;
+			     paddr += PAGE_SIZE) {
+				map_and_flush(paddr);
+			}
+		}
+	}
+
+	/* also flush the kimage struct to be passed in as well */
+	flush_dcache_range((unsigned long)image,
+			   (unsigned long)image + sizeof(*image));
+}
+
+#define DEVDISR_ADDR 0x70
+#define E600_0	(0x1 << 15)
+#define E600_1	(0x1 << 14)
+
+static void smp_86xx_machine_kexec(struct kimage *image)
+{
+	struct device_node *np;
+	unsigned int tmp;
+	__be32 __iomem *gut, *devdisr;
+
+	mpc86xx_smp_flush_dcache_kexec(image);
+	if (image->type == KEXEC_TYPE_DEFAULT)
+		smp_call_function(smp_86xx_kexec_down, NULL, 0);
+
+	np = of_find_node_by_name(NULL, "global-utilities");
+	if (!np) {
+		pr_err("No global-utilities device node\n");
+		return;
+	}
+
+	gut = of_iomap(np, 0);
+	if (!gut) {
+		pr_err("Can't map global-utilities registers\n");
+		return;
+	}
+
+	devdisr = gut + (DEVDISR_ADDR >> 2);
+
+	tmp = in_be32(devdisr);
+	if (smp_processor_id())
+		tmp |= E600_0;
+	else
+		tmp |= E600_1;
+
+	/* Disable the core. */
+	out_be32(devdisr, tmp);
+	if (!spin_event_timeout(in_be32(devdisr) & (E600_0 | E600_1),
+				10000, 100))
+		pr_err("Failed to disable the core\n");
+
+	iounmap(gut);
+	of_node_put(np);
+
+	default_machine_kexec(image);
+}
+#endif
 
 void __init
 mpc86xx_smp_init(void)
 {
 	smp_ops = &smp_86xx_ops;
+#ifdef CONFIG_KEXEC
+	ppc_md.kexec_cpu_down = smp_86xx_kexec_cpu_down;
+	ppc_md.machine_kexec = smp_86xx_machine_kexec;
+#endif
 }
-- 
1.7.5.4

