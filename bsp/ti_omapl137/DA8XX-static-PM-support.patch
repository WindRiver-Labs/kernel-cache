From 21cebcfb960b6d04b67f9b4c0e55b75778c21ec7 Mon Sep 17 00:00:00 2001
From: Tonyliu <Bo.Liu@windriver.com>
Date: Thu, 22 Oct 2009 16:57:41 +0800
Subject: [PATCH 12/14] DA8XX: static PM support

Introduce a general static PM infrastructure for DA8XX. Dependending on
hardware implementation, this PM framework can be divided into several parts:
- IRQ controller context save/restore.
- DMA controller context save/restore.
- Ejects and suspends on internal sram region.

All these entities can be registered into arch level static PM handling by
standard interaces. And the abstracted arch level PM framework can collaborate with
kernel level PM layer seamlessly.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 arch/arm/mach-davinci/Makefile             |    3 +
 arch/arm/mach-davinci/cp_intc.c            |  167 +++++++++++++++++
 arch/arm/mach-davinci/da830.c              |   80 +++++++++
 arch/arm/mach-davinci/devices-da8xx.c      |    2 +-
 arch/arm/mach-davinci/dma.c                |  164 +++++++++++++++++
 arch/arm/mach-davinci/include/mach/da8xx.h |   19 ++-
 arch/arm/mach-davinci/include/mach/pm.h    |   92 ++++++++++
 arch/arm/mach-davinci/include/mach/sram.h  |   25 +++
 arch/arm/mach-davinci/pm.c                 |  267 ++++++++++++++++++++++++++++
 arch/arm/mach-davinci/sleep.S              |  109 +++++++++++
 arch/arm/mach-davinci/sram.c               |   82 +++++++++
 11 files changed, 1008 insertions(+), 2 deletions(-)
 create mode 100644 arch/arm/mach-davinci/include/mach/pm.h
 create mode 100644 arch/arm/mach-davinci/include/mach/sram.h
 create mode 100644 arch/arm/mach-davinci/pm.c
 create mode 100644 arch/arm/mach-davinci/sleep.S
 create mode 100644 arch/arm/mach-davinci/sram.c

diff --git a/arch/arm/mach-davinci/Makefile b/arch/arm/mach-davinci/Makefile
index 7e4d410..90191da 100644
--- a/arch/arm/mach-davinci/Makefile
+++ b/arch/arm/mach-davinci/Makefile
@@ -18,3 +18,6 @@ obj-$(CONFIG_CP_INTC)			+= cp_intc.o
 # Board specific
 obj-$(CONFIG_MACH_DAVINCI_EVM)  += board-evm.o
 obj-$(CONFIG_MACH_DAVINCI_DA830_EVM)    += board-da830-evm.o
+
+# Power Management
+obj-$(CONFIG_PM) += pm.o sram.o sleep.o
diff --git a/arch/arm/mach-davinci/cp_intc.c b/arch/arm/mach-davinci/cp_intc.c
index 96c8e97..edd368a 100644
--- a/arch/arm/mach-davinci/cp_intc.c
+++ b/arch/arm/mach-davinci/cp_intc.c
@@ -18,6 +18,11 @@
 
 #include <mach/cp_intc.h>
 
+#ifdef CONFIG_PM
+#include <mach/pm.h>
+static struct davinci_pm_irq_chip *pm_chip;
+#endif
+
 static void __iomem *cp_intc_base;
 
 static inline unsigned int cp_intc_read(unsigned offset)
@@ -38,16 +43,32 @@ static void cp_intc_ack_irq(unsigned int irq)
 /* Disable interrupt */
 static void cp_intc_mask_irq(unsigned int irq)
 {
+#ifdef CONFIG_PM
+	unsigned int index = BIT_WORD(irq);
+	unsigned int mask = BIT_MASK(irq);
+#endif
 	/* XXX don't know why we need to disable nIRQ here... */
 	cp_intc_write(1, CP_INTC_HOST_ENABLE_IDX_CLR);
 	cp_intc_write(irq, CP_INTC_SYS_ENABLE_IDX_CLR);
+#ifdef CONFIG_PM
+	if(pm_chip)
+		pm_chip->irq_saved[index] &= ~mask;
+#endif
 	cp_intc_write(1, CP_INTC_HOST_ENABLE_IDX_SET);
 }
 
 /* Enable interrupt */
 static void cp_intc_unmask_irq(unsigned int irq)
 {
+#ifdef CONFIG_PM
+	unsigned int index = BIT_WORD(irq);
+	unsigned int mask = BIT_MASK(irq);
+#endif
 	cp_intc_write(irq, CP_INTC_SYS_ENABLE_IDX_SET);
+#ifdef CONFIG_PM
+	if(pm_chip)
+		pm_chip->irq_saved[index] |= mask;
+#endif
 }
 
 static int cp_intc_set_irq_type(unsigned int irq, unsigned int flow_type)
@@ -84,12 +105,143 @@ static int cp_intc_set_irq_type(unsigned int irq, unsigned int flow_type)
 	return 0;
 }
 
+#ifdef CONFIG_PM
+static struct davinci_pm_irq_chip *pm_chip;
+
+static int __init davinci_pm_irq_notifier(struct notifier_block *nfb,
+		unsigned long action, void *pdata);
+
+static struct notifier_block  pm_irq_notifier = {
+	.notifier_call = davinci_pm_irq_notifier,
+};
+
+static int __init davinci_pm_irq_notifier(struct notifier_block *nfb,
+		unsigned long action, void *pdata)
+{
+	enum davinci_pm_stage stage = action;
+
+	if(stage != PM_START)
+		return 0;
+
+	davinci_pm_trigger(PM_IRQ, pm_chip);
+
+    return 0;
+}
+
+/*
+ * do prepare for pm suspend. save irq bitmask and set wakeup
+ * irq bitmask
+ */
+static int cp_intc_irq_prepare(void)
+{
+	unsigned int i, bitmask = 0;
+	int ret = 0;
+
+	/*disable the host interrupt */
+	cp_intc_write(1, CP_INTC_HOST_ENABLE_IDX_CLR);
+
+	/* configure wake interrupts. disable all interrupts
+	 * except wake irqs
+	 */
+	for(i = 0; i < pm_chip->num; i++)
+	{
+		cp_intc_write(pm_chip->irq_reserved[i],
+			CP_INTC_SYS_ENABLE_CLR(i));
+
+		if(pm_chip->irq_wake_src[i]) {
+			bitmask |= pm_chip->irq_wake_src[i];
+			cp_intc_write(pm_chip->irq_wake_src[i],
+				CP_INTC_SYS_ENABLE_SET(i));
+		}
+	}
+
+	if(likely(bitmask))
+		ret = 0;
+	else {
+		printk(KERN_ERR "davinci no wakeup src for suspend\n");
+		ret = -EINVAL;
+	}
+
+	/*reenable the host interrupt*/
+	cp_intc_write(1, CP_INTC_HOST_ENABLE_IDX_SET);
+	return ret;
+}
+
+/*
+ * restore irq bitmask
+ */
+static void cp_intc_irq_restore(void)
+{
+	unsigned int i;
+
+	/*disable the host interrupt */
+	cp_intc_write(1, CP_INTC_HOST_ENABLE_IDX_CLR);
+
+	for(i = 0; i < pm_chip->num; i++) {
+		cp_intc_write(pm_chip->irq_reserved[i],
+			CP_INTC_SYS_ENABLE_CLR(i));
+
+		if(pm_chip->irq_saved[i])
+			cp_intc_write(pm_chip->irq_saved[i],
+			CP_INTC_SYS_ENABLE_SET(i));
+	}
+
+	/*reenable the host interrupt*/
+	cp_intc_write(1, CP_INTC_HOST_ENABLE_IDX_SET);
+}
+
+/*
+ * check any pending irq need to be handling
+ * return value:
+ * 0    --  no unhandled pending irq
+ * 1    --  there is still some pending irq.
+ */
+static unsigned int cp_intc_irq_pending(void)
+{
+	int pending;
+
+	pending = cp_intc_read(CP_INTC_PRIO_IDX);
+
+	if(likely(pending & 0x80000000))
+		return 0;
+	else
+		return 1;
+}
+
+/*
+ * setup irq wakeup src
+ */
+static int cp_intc_irq_set_wake(unsigned int irq, unsigned int on)
+{
+	unsigned int index = BIT_WORD(irq);
+	unsigned int mask = BIT_MASK(irq);
+
+	if(on)
+		pm_chip->irq_wake_src[index] |= mask;
+	else
+		pm_chip->irq_wake_src[index] &= ~mask;
+
+	return 0;
+}
+
+static struct davinci_pm_irq_chip cp_intc_pm_irq_chip = {
+	.prepare    = cp_intc_irq_prepare,
+	.restore    = cp_intc_irq_restore,
+	.pending    = cp_intc_irq_pending,
+};
+
+#endif
+
+
 static struct irq_chip cp_intc_irq_chip = {
 	.name		= "cp_intc",
 	.ack		= cp_intc_ack_irq,
 	.mask		= cp_intc_mask_irq,
 	.unmask		= cp_intc_unmask_irq,
 	.set_type	= cp_intc_set_irq_type,
+#ifdef CONFIG_PM
+	.set_wake   =  cp_intc_irq_set_wake,
+#endif
 };
 
 void __init cp_intc_init(void __iomem *base, unsigned short num_irq,
@@ -158,4 +310,19 @@ void __init cp_intc_init(void __iomem *base, unsigned short num_irq,
 
 	/* Enable global interrupt */
 	cp_intc_write(1, CP_INTC_GLOBAL_ENABLE);
+
+#ifdef CONFIG_PM
+	pm_chip = &cp_intc_pm_irq_chip;
+	pm_chip->num = BITS_TO_LONGS(num_irq);
+	for(i = 0; i < pm_chip->num; i++) {
+		pm_chip->irq_saved[i] = 0;
+		pm_chip->irq_wake_src[i] = 0;
+		pm_chip->irq_reserved[i] = 0xffffffff;
+	}
+
+	/*set irq 60 ~ 90 mask*/
+	pm_chip->irq_reserved[i - 1] = 0x0fffffff;
+
+	raw_notifier_chain_register(&pm_chain, &pm_irq_notifier);
+#endif
 }
diff --git a/arch/arm/mach-davinci/da830.c b/arch/arm/mach-davinci/da830.c
index b5865bc..b466742 100644
--- a/arch/arm/mach-davinci/da830.c
+++ b/arch/arm/mach-davinci/da830.c
@@ -25,6 +25,11 @@
 #include <mach/da8xx.h>
 #include <mach/asp.h>
 
+#ifdef CONFIG_PM
+#include <mach/pm.h>
+#include <mach/sram.h>
+#endif
+
 #include "clock.h"
 #include "mux.h"
 
@@ -1130,6 +1135,20 @@ static struct map_desc da830_io_desc[] = {
 		.length		= DA8XX_CP_INTC_SIZE,
 		.type		= MT_DEVICE
 	},
+#ifdef CONFIG_PM
+	{
+		.virtual    = DA8XX_DDR2_CTL_VIRT,
+		.pfn        = __phys_to_pfn(DA8XX_DDR2_CTL_BASE),
+		.length     = DA8XX_DDR2_CTL_VIRT_SZ,
+		.type       = MT_DEVICE
+	},
+	{
+		.virtual    = DA8XX_SHARED_RAM_VIRT,
+		.pfn        = __phys_to_pfn(DA8XX_SHARED_RAM_BASE),
+		.length     = DA8XX_SHARED_RAM_VIRT_SZ,
+		.type       = MT_DEVICE
+	}
+#endif
 };
 
 static void __iomem *da830_psc_bases[] = {
@@ -1165,6 +1184,63 @@ static struct davinci_timer_instance da830_timer_instance[2] = {
 	},
 };
 
+#ifdef CONFIG_PM
+
+static int __init davinci_pm_arch_notifier(struct notifier_block *nfb,
+		unsigned long action, void *pdata);
+
+static struct notifier_block  pm_arch_notifier = {
+	.notifier_call = davinci_pm_arch_notifier,
+};
+
+static int da830_pm_sram_init(unsigned long start,
+        unsigned long size)
+{
+	u32 ttb, pte;
+
+	/* Check if SRAM is mapped using one 1MB desc, avoid MMU walks while
+	 * running from SRAM */
+	/* Get TTB from TTBR */
+	asm volatile ("mrc p15, 0, %0, c2, c0, 0" : "=r" (ttb) :);
+
+	/* Convert TTB to virtual address */
+	ttb = (u32)phys_to_virt(ttb & 0xFFFFC000);
+
+	/* Get table entry */
+	pte = *(u32 *) (ttb + (start >> 18));
+
+	/* Section bits set ? */
+	if ((pte & 0x3) != 0x2) {
+		printk(KERN_ERR "SRAM not mapped using section descriptor: " \
+			"0x%08x\n", pte);
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+struct davinci_sram_region da830_sram = {
+	.start = DA8XX_SHARED_RAM_VIRT,
+	.size  = DA8XX_SHARED_RAM_SIZE,
+	.init  = da830_pm_sram_init,
+};
+
+static int __init davinci_pm_arch_notifier(struct notifier_block *nfb,
+		unsigned long action, void *pdata)
+{
+	int ret = 0;
+	enum davinci_pm_stage stage = action;
+
+	if(stage != PM_START)
+		return ret;
+
+	ret = davinci_sram_register(&da830_sram);
+
+	return ret;
+}
+#endif
+
+
 /*
  * T0_BOT: Timer 0, bottom		: Used for clock_event & clocksource
  * T0_TOP: Timer 0, top			: Used by DSP
@@ -1209,4 +1285,8 @@ void __init da830_init(void)
 	davinci_soc_info_da830.pinmux_base = DA8XX_SYSCFG_VIRT(0x120);
 
 	davinci_common_init(&davinci_soc_info_da830);
+
+#ifdef CONFIG_PM
+	raw_notifier_chain_register(&pm_chain, &pm_arch_notifier);
+#endif
 }
diff --git a/arch/arm/mach-davinci/devices-da8xx.c b/arch/arm/mach-davinci/devices-da8xx.c
index eaeabe6..904ea22 100644
--- a/arch/arm/mach-davinci/devices-da8xx.c
+++ b/arch/arm/mach-davinci/devices-da8xx.c
@@ -152,7 +152,7 @@ static struct resource da8xx_edma_resources[] = {
 
 static struct platform_device da8xx_edma_device = {
 	.name		= "edma",
-	.id		= -1,
+	.id		= 0,
 	.dev = {
 		.platform_data	= da8xx_edma_info,
 	},
diff --git a/arch/arm/mach-davinci/dma.c b/arch/arm/mach-davinci/dma.c
index f2e57d2..d3e5f4a 100644
--- a/arch/arm/mach-davinci/dma.c
+++ b/arch/arm/mach-davinci/dma.c
@@ -34,6 +34,12 @@
 #include <mach/edma.h>
 #include <mach/mux.h>
 
+#ifdef CONFIG_PM
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <mach/pm.h>
+#endif
 
 /* Offsets matching "struct edmacc_param" */
 #define PARM_OPT		0x00
@@ -249,6 +255,14 @@ struct edma {
 				void *data);
 		void *data;
 	} intr_data[EDMA_MAX_DMACH];
+
+#ifdef CONFIG_PM
+#define EDMA_MAX_TC     4
+	unsigned idx;
+	struct clk *clk_cc[EDMA_MAX_CC];
+	struct clk *clk_tc[EDMA_MAX_TC];
+	__iomem void *tc_base[EDMA_MAX_TC];
+#endif
 };
 
 static struct edma *edma_info[EDMA_MAX_CC];
@@ -1326,6 +1340,108 @@ void edma_clear_event(unsigned channel)
 }
 EXPORT_SYMBOL(edma_clear_event);
 
+#ifdef CONFIG_PM
+#define EDMA_BUSY_CC_EVTACTV    1
+#define EDMA_BUSY_CC_QEVTACTV   (1 << 1)
+#define EDMA_BUSY_CC_TRACTV     (1 << 2)
+#define EDMA_BUSY_CC_WSTATACTV  (1 << 3)
+#define EDMA_BUSY_CC_ACTV       (1 << 4)
+
+#define EDMA_TCSTAT     0x100
+#define EDMA_BUSY_TC_PROGBUSY   1
+#define EDMA_BUSY_TC_SRCACTV    (1 << 1)
+#define EDMA_BUSY_TC_WSACTV     (1 << 2)
+
+static int davinci_edma_is_running(void *priv)
+{
+	struct edma *info = (struct edma *)priv;
+	unsigned long i, ccstat, tcstat;
+
+	/*The EDMA3CC checks for the following conditions:
+	 * 1) No pending DMA/QDMA events
+	 * 2) No outstanding events in the event queues
+	 * 3) Transfer request processing logic is not active
+	 * 4) No completion requests outstanding (early or normal completion)
+	 * 5) No configuration bus requests in progress
+	 */
+	ccstat = 0;
+	ccstat = edma_read(info->idx, EDMA_CCSTAT);
+	if(ccstat & (EDMA_BUSY_CC_EVTACTV | EDMA_BUSY_CC_QEVTACTV | \
+		EDMA_BUSY_CC_TRACTV | EDMA_BUSY_CC_WSTATACTV | EDMA_BUSY_CC_ACTV))
+		return 1;
+
+	/*From the EDMA3TC perspective, there are no outstanding TRs that are
+	 * getting processed and essentially the read/write controller is not
+	 * busy processing a TR
+	 */
+	for(i = 0; i < info->num_tc; i++) {
+		tcstat = __raw_readl(info->tc_base[i] + EDMA_TCSTAT);
+		if(tcstat & (EDMA_BUSY_TC_PROGBUSY | EDMA_BUSY_TC_SRCACTV | \
+			EDMA_BUSY_TC_WSACTV))
+			return 1;
+	}
+
+	return 0;
+}
+
+static void davinci_edma_suspend(void *priv)
+{
+	struct edma *info = (struct edma *)priv;
+	int i;
+
+	for(i = 0; i < info->num_cc; i++)
+		clk_disable(info->clk_cc[i]);
+
+	for(i = 0; i < info->num_tc; i++)
+		clk_disable(info->clk_tc[i]);
+}
+
+static void davinci_edma_resume(void *priv)
+{
+	struct edma *info = (struct edma *)priv;
+	int i;
+
+	for(i = 0; i < info->num_tc; i++)
+		clk_enable(info->clk_tc[i]);
+
+	for(i = 0; i < info->num_cc; i++)
+		clk_enable(info->clk_cc[i]);
+}
+
+/* Make sure edma controller suspend after all platform
+ * devices suspend and resume befor all plaftform devices
+ * resume.
+ * The recommended PM sequence for EDMA hosted platform is:
+ * Disable peripheral => Disable the DMA channel associated
+ * with the peripheral => Disable EDMA3CC => Disable EDMA3TC(s).
+ * See TI's document SPRUGP9 section 2.17 for more details.
+ */
+static struct davinci_pm_dma_ops dma_pm_ops = {
+    .dma_is_running = davinci_edma_is_running,
+    .suspend = davinci_edma_suspend,
+    .resume = davinci_edma_resume,
+};
+
+static struct davinci_pm_dma_ctl dma_ctl;
+
+static int __init davinci_pm_dma_notifier(struct notifier_block *nfb,
+        unsigned long action, void *pdata)
+{
+	enum davinci_pm_stage stage = action;
+
+	if(stage != PM_START)
+		return 0;
+
+	davinci_pm_trigger(PM_DMA, &dma_ctl);
+
+	return 0;
+}
+
+static struct notifier_block  pm_dma_notifier = {
+	.notifier_call = davinci_pm_dma_notifier,
+};
+#endif
+
 /*-----------------------------------------------------------------------*/
 
 static int __init edma_probe(struct platform_device *pdev)
@@ -1339,6 +1455,9 @@ static int __init edma_probe(struct platform_device *pdev)
 	int			irq[EDMA_MAX_CC] = {0, 0};
 	int			err_irq[EDMA_MAX_CC] = {0, 0};
 	struct resource		*r[EDMA_MAX_CC] = {NULL};
+#ifdef CONFIG_PM
+	struct resource		*res = NULL;
+#endif
 	resource_size_t		len[EDMA_MAX_CC];
 	char			res_name[10];
 	char			irq_name[10];
@@ -1460,6 +1579,44 @@ static int __init edma_probe(struct platform_device *pdev)
 		}
 	}
 
+#ifdef CONFIG_PM
+    edma_info[pdev->id]->num_tc = min_t(unsigned, info->n_tc, EDMA_MAX_TC);
+    edma_info[pdev->id]->idx = pdev->id;
+
+    for(i = 0; i < edma_info[pdev->id]->num_tc; i++) {
+        sprintf(res_name, "edma_tc%d", i);
+
+        res = platform_get_resource_byname(pdev, IORESOURCE_MEM, res_name);
+        if (!res) {
+            status = -ENODEV;
+            goto fail1;
+        }
+
+
+        res = request_mem_region(res->start,
+                (res->end - res->start + 1), res->name);
+        if(!res) {
+            status = -EBUSY;
+            goto fail1;
+        }
+
+        edma_info[pdev->id]->tc_base[i] = IO_ADDRESS(res->start);
+    }
+
+    for(i = 0; i < edma_info[pdev->id]->num_cc; i++) {
+        edma_info[pdev->id]->clk_cc[i] = clk_get(&pdev->dev, "tpcc");
+        if(IS_ERR(edma_info[pdev->id]->clk_cc[i]))
+            goto fail1;
+    }
+
+    for(i = 0; i < edma_info[pdev->id]->num_tc; i++) {
+        sprintf(res_name, "tptc%d", i);
+        edma_info[pdev->id]->clk_tc[i] = clk_get(&pdev->dev, res_name);
+        if(IS_ERR(edma_info[pdev->id]->clk_tc[i]))
+            goto fail1;
+    }
+#endif
+
 	if (tc_errs_handled) {
 		status = request_irq(IRQ_TCERRINT0, dma_tc0err_handler, 0,
 					"edma_tc0", &pdev->dev);
@@ -1477,6 +1634,13 @@ static int __init edma_probe(struct platform_device *pdev)
 		}
 	}
 
+#ifdef CONFIG_PM
+	dma_ctl.ops = &dma_pm_ops;
+	dma_ctl.priv = (void *)edma_info[pdev->id];
+
+	raw_notifier_chain_register(&pm_chain, &pm_dma_notifier);
+#endif
+
 	return 0;
 
 fail:
diff --git a/arch/arm/mach-davinci/include/mach/da8xx.h b/arch/arm/mach-davinci/include/mach/da8xx.h
index b69b786..6ed9693 100644
--- a/arch/arm/mach-davinci/include/mach/da8xx.h
+++ b/arch/arm/mach-davinci/include/mach/da8xx.h
@@ -11,6 +11,7 @@
 #ifndef __ASM_ARCH_DAVINCI_DA8XX_H
 #define __ASM_ARCH_DAVINCI_DA8XX_H
 
+#ifndef __ASSEMBLER__
 #include <mach/serial.h>
 #include <mach/edma.h>
 #include <mach/i2c.h>
@@ -19,7 +20,7 @@
 #include <mach/mmc.h>
 
 extern void __iomem *da8xx_syscfg_base;
-
+#endif
 /*
  * The cp_intc interrupt controller for the da8xx isn't in the same
  * chunk of physical memory space as the other registers (like it is
@@ -53,6 +54,20 @@ extern void __iomem *da8xx_syscfg_base;
 #define DA8XX_AEMIF_CS3_BASE	0x62000000
 #define DA8XX_AEMIF_CTL_BASE	0x68000000
 
+#define DA8XX_SHARED_RAM_BASE   0x80000000
+#define DA8XX_SHARED_RAM_SIZE   SZ_128K
+#define DA8XX_SHARED_RAM_VIRT_SZ    SZ_1M
+#define DA8XX_SHARED_RAM_VIRT   (((IO_VIRT + IO_SIZE) + SZ_1M - 1) \
+		& ~(SZ_1M - 1))
+
+#define DA8XX_DDR2_CTL_BASE     0xb0000000
+#define DA8XX_DDR2_CTL_SIZE     SZ_32K
+#define DA8XX_DDR2_CTL_VIRT_SZ  SZ_1M
+#define DA8XX_DDR2_CTL_VIRT     (DA8XX_SHARED_RAM_VIRT + \
+		DA8XX_SHARED_RAM_VIRT_SZ)
+
+#define DDR2_CTRL_VIRT  DA8XX_DDR2_CTL_VIRT
+
 #define PINMUX0			0x00
 #define PINMUX1			0x04
 #define PINMUX2			0x08
@@ -74,6 +89,7 @@ extern void __iomem *da8xx_syscfg_base;
 #define PINMUX18		0x48
 #define PINMUX19		0x4c
 
+#ifndef __ASSEMBLER__
 struct spi_board_info;
 
 void __init da830_init(void);
@@ -126,5 +142,6 @@ extern const short da830_eqep0_pins[];
 extern const short da830_eqep1_pins[];
 
 int da8xx_pinmux_setup(const short pins[]);
+#endif /*__ASSEMBLER__*/
 
 #endif /* __ASM_ARCH_DAVINCI_DA8XX_H */
diff --git a/arch/arm/mach-davinci/include/mach/pm.h b/arch/arm/mach-davinci/include/mach/pm.h
new file mode 100644
index 0000000..b1ac817
--- /dev/null
+++ b/arch/arm/mach-davinci/include/mach/pm.h
@@ -0,0 +1,92 @@
+/*
+ * linux/include/asm-arm/arch-davinci/pm.h
+ * 
+ * Header file for DaVinci Power Management Routines
+ *
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+*/ 
+
+#ifndef __ASM_ARCH_DAVINCI_PM_H__
+#define __ASM_ARCH_DAVINCI_PM_H__
+
+#define NR_IRQ_SAVED	4
+
+struct davinci_pm_dma_ctl;
+
+struct davinci_pm_dma_ops {
+	int (*dma_is_running)(void *priv);    /*Any pending or processing dma operation*/
+	void (*suspend)(void *priv);          /*Dma controller specific suspend handing*/
+	void (*resume)(void *priv);           /*Dma controller specific resume handling*/
+};
+
+struct davinci_pm_dma_ctl {
+	struct davinci_pm_dma_ops *ops;
+	void *priv;		/*DMA controller specific data*/
+};
+
+struct davinci_sram_region {
+	unsigned long start;	/*Region kernel start address*/
+	unsigned long size;		/*Region size*/
+	unsigned long avail;	/*Remained useful region size*/
+	int (*init)(unsigned long start, unsigned long size);
+	void *(*push)(void *start, unsigned long size,
+			struct davinci_sram_region *area);
+};
+
+struct davinci_pm_irq_chip {
+	void (*init)(void);
+	int (*prepare)(void);					/*Save irq bitmask before suspend*/
+	void (*restore)(void);					/*Restore irq bitmask after suspend*/
+	unsigned int (*pending)(void);			/*Any unhandled pending irq*/
+	unsigned int num;						/*Num of word we need to save irq bitmask*/
+	unsigned int irq_saved[NR_IRQ_SAVED];	/*System irqs bitmask before suspend*/
+	unsigned int irq_wake_src[NR_IRQ_SAVED]; /*Wake source irq bitmask*/
+	unsigned int irq_reserved[NR_IRQ_SAVED]; /*Irqs cleaning pattern*/
+};
+
+struct davinci_pm_proxy {
+	struct mutex lock;
+	void (*suspend)(void);		/*Arch suspend handler*/
+	void (*saved_idle)(void);	/*Saved system idle handler*/
+	struct davinci_pm_dma_ctl *dma_ctl;
+	struct davinci_pm_irq_chip *irq_chip;
+	struct davinci_sram_region *area;
+
+	unsigned int enable_standby;	/*Standby enable switch*/
+	unsigned int count_standby;		/*Standby counter*/
+};
+
+enum davinci_pm_stage {
+	PM_START,
+	PM_PLATFORM,
+	PM_DMA,
+	PM_SRAM,
+	PM_IRQ,
+	PM_END,
+};
+
+#ifndef __ASSEMBLER__
+extern struct raw_notifier_head pm_chain;
+
+extern void davinci_cpu_suspend(void);
+
+extern unsigned int davinci_cpu_suspend_sz;
+
+extern void davinci_pm_trigger(enum davinci_pm_stage action,
+		void *pdata);
+#endif /* ASSEMBLER */
+#endif /* __ASM_ARCH_DAVINCI_PM_H__ */
diff --git a/arch/arm/mach-davinci/include/mach/sram.h b/arch/arm/mach-davinci/include/mach/sram.h
new file mode 100644
index 0000000..853796a
--- /dev/null
+++ b/arch/arm/mach-davinci/include/mach/sram.h
@@ -0,0 +1,25 @@
+/*
+ * arch/arm/mach-davinci/include/mach/sram.h
+ * 
+ * Copyright (c) 2009 Wind River Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */ 
+
+#ifndef __ARCH_ARM_DAVINCI_SRAM_H
+#define __ARCH_ARM_DAVINCI_SRAM_H
+
+extern int davinci_sram_register(struct davinci_sram_region *area);
+#endif /* __ARCH_ARM_DAVINCI_TCM_H */
diff --git a/arch/arm/mach-davinci/pm.c b/arch/arm/mach-davinci/pm.c
new file mode 100644
index 0000000..9b13ba0
--- /dev/null
+++ b/arch/arm/mach-davinci/pm.c
@@ -0,0 +1,267 @@
+/*
+ * linux/arch/arm/mach-davinci/pm.c
+ *
+ * DaVinci Power Management Routines
+ *
+ * Copyright 2008 Dirk Behme <[EMAIL PROTECTED]>
+ *
+ * Based on arch/arm/mach-omap2/pm.c from:
+ *
+ * Copyright (C) 2005 Texas Instruments, Inc.
+ * Copyright (C) 2006 Nokia Corporation
+ *
+ * Written by:
+ * Richard Woodruff <[EMAIL PROTECTED]>
+ * Tony Lindgren
+ * Juha Yrjola
+ * Amit Kucheria <[EMAIL PROTECTED]>
+ * Igor Stoppa <[EMAIL PROTECTED]>
+ *
+ * Based on pm.c for omap1
+ *
+ * Copyright 2009 WindRiver System, Inc.
+ * Tony Liu <Bo.Liu@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/suspend.h>
+#include <linux/interrupt.h>
+#include <linux/sysfs.h>
+#include <linux/sysdev.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+#include <linux/delay.h>
+
+#include <mach/edma.h>
+#include <mach/pm.h>
+#include <mach/io.h>
+#include <mach/irqs.h>
+#include <mach/system.h>
+
+RAW_NOTIFIER_HEAD(pm_chain);
+
+static struct davinci_pm_proxy *pm_proxy;
+
+static void davinci_enter_standby(void)
+{
+	int ret = 0;
+	struct davinci_pm_irq_chip *irq_chip = pm_proxy->irq_chip;
+
+	/* ToDo: Disable all unused peripherals using PSC*/
+	/* Save irq enable masks */
+	ret = irq_chip->prepare();
+	if(ret)
+		goto no_sleep;
+
+	/* Jump to suspend code in SRAM */
+	pm_proxy->suspend();
+
+	pm_proxy->count_standby++;
+
+	pm_proxy->enable_standby = 0;
+
+no_sleep:
+	/* Reenable interrupts, rewrite saved enable configuration */
+	irq_chip->restore();
+}
+
+static inline int davinci_can_sleep(void)
+{
+	if (!pm_proxy->enable_standby)
+		return 0;
+
+	return 1;
+}
+
+static void davinci_pm_suspend(void)
+{
+	struct davinci_pm_irq_chip *irq_chip = pm_proxy->irq_chip;
+
+	if(!irq_chip) {
+		printk(KERN_ERR "not setup pm irq\n");
+		return;
+	}
+
+	if (!davinci_can_sleep())
+		goto out;
+
+	/*
+	 * If any pending IRQ, cancel suspend action.
+	 */
+	if (irq_chip->pending())
+		goto out;
+
+	davinci_enter_standby();
+
+out:
+	return;
+}
+
+static int davinci_pm_prepare(void)
+{
+	struct davinci_pm_dma_ctl *dma_ctl;
+	struct davinci_pm_dma_ops *dma_ops;
+	int limit = 500;
+
+	dma_ctl = pm_proxy->dma_ctl;
+	dma_ops = dma_ctl->ops;
+
+	/*Devices has been suspended, Make sure all on-going
+	 * DMA operation finished before step in suspend_enter()
+	 * which disable local irq*/
+	while(dma_ops->dma_is_running(dma_ctl->priv) && limit--)
+		msleep(10);
+
+	if(dma_ops->dma_is_running(dma_ctl->priv))
+		return -EBUSY;
+
+	/*Shut down DMA controller after all devices suspend*/
+	dma_ops->suspend(dma_ctl->priv);
+
+	/* We cannot sleep in idle until we have resumed */
+	pm_proxy->saved_idle = pm_idle;
+	pm_idle = NULL;
+
+	return 0;
+}
+
+static int davinci_pm_enter(suspend_state_t state)
+{
+	int ret = 0;
+
+	switch (state) {
+	case PM_SUSPEND_STANDBY:
+		pm_proxy->enable_standby = 1;
+		davinci_pm_suspend();
+		break;
+	case PM_SUSPEND_MEM:
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static void davinci_pm_finish(void)
+{
+	struct davinci_pm_dma_ctl *dma_ctl;
+	struct davinci_pm_dma_ops *dma_ops;
+
+	pm_idle = pm_proxy->saved_idle;
+
+	/*Restore DMA controller before all devices resume*/
+	dma_ctl = pm_proxy->dma_ctl;
+	dma_ops = dma_ctl->ops;
+
+	dma_ops->resume(dma_ctl->priv);
+}
+
+static int davinci_pm_valid_standby(suspend_state_t state)
+{
+	return state == PM_SUSPEND_STANDBY;
+}
+
+static struct platform_suspend_ops davinci_pm_ops = {
+	.prepare        = davinci_pm_prepare,
+	.enter          = davinci_pm_enter,
+	.finish         = davinci_pm_finish,
+	.valid          = davinci_pm_valid_standby,
+};
+
+void davinci_pm_trigger(enum davinci_pm_stage  action, void *pdata)
+{
+	if(!pm_proxy)
+		return;
+
+	raw_notifier_call_chain(&pm_chain, action, pdata);
+}
+EXPORT_SYMBOL(davinci_pm_trigger);
+
+static int __init davinci_pm_notifier(struct notifier_block *nfb,
+		unsigned long action, void *pdata)
+{
+	struct davinci_pm_irq_chip *irq_chip;
+	enum davinci_pm_stage stage = action;
+	int ret = 0;
+
+	if(!pdata) {
+		printk(KERN_INFO "no avaiable pm handler\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&pm_proxy->lock);
+	switch(stage) {
+	case PM_START:
+		/*Do nothing*/
+		break;
+	case PM_PLATFORM:
+		/*TODO: Register platform specific pm handler*/
+		break;
+	case PM_SRAM:
+		pm_proxy->area = (struct davinci_sram_region *)pdata;
+		/*Inject suspend codes into sram region*/
+		pm_proxy->suspend = pm_proxy->area->push(
+				davinci_cpu_suspend, davinci_cpu_suspend_sz,
+				pm_proxy->area);
+		if(!pm_proxy->suspend)
+			ret = -EFAULT;
+
+		break;
+	case PM_IRQ:
+		/*Register irq_chip specific pm handler*/
+		pm_proxy->irq_chip = (struct davinci_pm_irq_chip *)pdata;
+		irq_chip = pm_proxy->irq_chip;
+		if(irq_chip->init)
+			irq_chip->init();
+
+		break;
+	case PM_DMA:
+		pm_proxy->dma_ctl = (struct davinci_pm_dma_ctl *)pdata;
+
+		break;
+	case PM_END:
+		/*Setup system suspend ops*/
+		suspend_set_ops(&davinci_pm_ops);
+
+		break;
+	default:
+		printk(KERN_ERR "invalid davinci pm action\n");
+		ret = -EINVAL;
+	}
+	mutex_unlock(&pm_proxy->lock);
+	return ret;
+}
+
+static struct notifier_block  __initdata pm_notifier = {
+	.notifier_call = davinci_pm_notifier,
+};
+
+static struct davinci_pm_proxy pm_stub = {
+	.enable_standby	= 0,
+	.count_standby = 0,
+};
+
+static int __init davinci_pm_init(void)
+{
+	int ret = 0;
+
+	printk(KERN_INFO "Power Management for DaVinci initializing\n");
+
+	pm_proxy = &pm_stub;
+	mutex_init(&pm_proxy->lock);
+
+	ret = raw_notifier_chain_register(&pm_chain, &pm_notifier);
+	if(ret) {
+		printk(KERN_ERR "davinci pm register notifier failed\n");
+		return ret;
+	}
+
+	raw_notifier_call_chain(&pm_chain, PM_START, pm_proxy);
+	raw_notifier_call_chain(&pm_chain, PM_END, pm_proxy);
+	return 0;
+}
+arch_initcall(davinci_pm_init);
diff --git a/arch/arm/mach-davinci/sleep.S b/arch/arm/mach-davinci/sleep.S
new file mode 100644
index 0000000..fcb0271
--- /dev/null
+++ b/arch/arm/mach-davinci/sleep.S
@@ -0,0 +1,109 @@
+/*
+ * linux/arch/arm/mach-davinci/sleep.S
+ *
+ * Assembly sleep routines for DaVinci
+ *
+ * Copyright 2007 Dirk Behme <[EMAIL PROTECTED]>
+ *
+ * Based on arch/arm/mach-omap2/sleep.S from:
+ *
+ * (C) Copyright 2004
+ * Texas Instruments, <www.ti.com>
+ * Richard Woodruff <[EMAIL PROTECTED]>
+ *
+ * (C) Copyright 2006 Nokia Corporation
+ * Fixed idle loop sleep
+ * Igor Stoppa <[EMAIL PROTECTED]>
+ *
+ * Copyright 2009 WindRiver System, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR /PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <mach/hardware.h>
+#include <mach/io.h>
+#include <asm/sizes.h>
+
+#ifdef CONFIG_ARCH_DAVINCI_DA8XX
+#include <mach/da8xx.h>
+#endif
+       .text
+/*
+ * davinci_cpu_suspend() - Forces DaVinci into sleep state by switching
+ * SDRAM into self refresh and then enter WFI.
+ */
+	.align  10
+ENTRY(davinci_cpu_suspend)
+	stmfd   sp!, {r0 - r12, lr}     @ save registers on stack
+tci_loop:
+	mrc     p15, 0, r15, c7, c14, 3 @ test clean and invalidate DCache
+	bne     tci_loop
+
+	mov     r0, #0x0                @ clear for mrc call
+	mcr     p15, 0, r0, c7, c10, 4  @ drain write buffer,
+                                       @ hope SDR/DDR finished
+	nop
+	nop
+
+	/* ToDo: Currently, we only switch SDRAM to self refresh here. To
+	 *       save even more power, we should gate input clocks to the
+	 *       memory controller module off. See TI document SPRUE22C
+	 *       section 2.15 "Power management" for more details.
+	 */
+
+	/* Switch SDRAM to selfrefresh */
+	ldr     r0, ddr2_ctrl_base
+	ldr     r1, self_refresh
+	ldr     r2, [r0]
+	orr     r2, r2, r1
+	str     r2, [r0]
+
+	/* ToDo: Wait T_CKE+1 cycles */
+	mov     r2, #0x1000
+loop1:
+	subs    r2, r2, #0x1
+	bne     loop1
+
+	/* Sleep */
+	mov     r2, #0
+	mcr     p15, 0, r2, c7, c0, 4   @ wait for interrupt
+	nop
+
+	/* Exit SDRAM selfrefresh, r0 and r1 should be still valid */
+	ldr     r2, [r0]
+	bic     r2, r2, r1
+	str     r2, [r0]
+
+	/* ToDo: Wait T_SXNR+1 and/or T_SCRD+1 cylces */
+	mov     r0, #0x1000
+loop2:
+	subs    r0, r0, #0x1
+	bne     loop2
+
+	/* Resume*/
+	ldmfd   sp!, {r0 - r12, pc}     @ restore regs and return
+
+ddr2_ctrl_base:
+		.word DDR2_CTRL_VIRT
+self_refresh:
+		.word 0x80000000
+
+ENTRY(davinci_cpu_suspend_sz)
+		.word   . - davinci_cpu_suspend
+
+
diff --git a/arch/arm/mach-davinci/sram.c b/arch/arm/mach-davinci/sram.c
new file mode 100644
index 0000000..1d9b654
--- /dev/null
+++ b/arch/arm/mach-davinci/sram.c
@@ -0,0 +1,82 @@
+/*
+ * linux/arch/arm/mach-davinci/sram.c
+ *
+ * DaVinci interal TCM detection and management
+ *
+ * Copyright 2007 Dirk Behme <[EMAIL PROTECTED]>
+ *
+ * Based on arch/arm/plat-omap/sram.c from:
+ *
+ * Copyright (C) 2005 Nokia Corporation
+ * Written by Tony Lindgren <[EMAIL PROTECTED]>
+ *
+ * Copyright 2009 WindRiver System, Inc.
+ * Tony Liu <Bo.Liu@windriver.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/io.h>
+
+#include <mach/pm.h>
+#include <mach/sram.h>
+
+#define ROUND_DOWN(value, boundary)    ((value) & (~((boundary)-1)))
+
+/*
+ * Copy arch suspend codes into TCM region.
+ * @start: address of suspend codes in sdram.
+ * @size:  total size of suspend codes.
+ * @area:  davinci tcm region structure.
+ */
+void *davinci_sram_push(void *start, unsigned long size,
+		struct davinci_sram_region *area)
+{
+	unsigned long cur;
+
+	if (size > area->avail) {
+		printk(KERN_ERR "Not enough space in ITCM\n");
+		return NULL;
+	}
+
+	cur = area->start + area->avail;
+	cur -= size;
+	cur = ROUND_DOWN(cur, sizeof(void *));
+	area->avail -= size;
+	memcpy((void *)cur, start, size);
+
+	return (void *)cur;
+}
+
+/*Initialize tcm configuration and register tcm handling to PM*/
+int davinci_sram_register(struct davinci_sram_region *area)
+{
+	int ret;
+
+	if(!area->size) {
+		printk(KERN_ERR "tcm region size can't be 0\n");
+		return -EINVAL;
+	}
+
+	area->avail = area->size;
+
+	/*Do some platform specific initialization*/
+	if(area->init) {
+		ret = area->init(area->start, area->size);
+		if(ret)
+			return ret;
+	}
+
+	area->push = davinci_sram_push;
+
+	/*Notify system pm to setup tcm*/
+	davinci_pm_trigger(PM_SRAM, area);
+
+	return 0;
+}
+EXPORT_SYMBOL(davinci_sram_register);
-- 
1.6.5.2

