From 971d1fa297a35d318b127d0ac6bbfaf0a95deb1e Mon Sep 17 00:00:00 2001
From: Tonyliu <Bo.Liu@windriver.com>
Date: Thu, 22 Oct 2009 16:57:29 +0800
Subject: [PATCH 05/14] On-board EEPROM extension

Original codes from TI Linux Platform Support Package DaVinci-PSP-SDK-03.20.00.03.tgz
http://software-dl.ti.com/dsps/dsps_public_sw/sdo_sb/targetcontent/psp/DaVinci-PSP-SDK/03_20/index_FDS.html

Add hooks for access the eeprom data by other kernel code, For example, it
might hold a board's Ethernet address.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 drivers/i2c/chips/at24.c |   33 +++++++++++++++++++++++++++++++++
 include/linux/i2c/at24.h |   10 ++++++++++
 2 files changed, 43 insertions(+), 0 deletions(-)

diff --git a/drivers/i2c/chips/at24.c b/drivers/i2c/chips/at24.c
index 2a4acb2..3421143 100644
--- a/drivers/i2c/chips/at24.c
+++ b/drivers/i2c/chips/at24.c
@@ -53,6 +53,7 @@
 
 struct at24_data {
 	struct at24_platform_data chip;
+	struct at24_iface iface;
 	bool use_smbus;
 
 	/*
@@ -386,6 +387,28 @@ static ssize_t at24_bin_write(struct kobject *kobj, struct bin_attribute *attr,
 
 /*-------------------------------------------------------------------------*/
 
+/*
+ * This lets other kernel code access the eeprom data. For example, it
+ * might hold a board's Ethernet address, or board-specific calibration
+ * data generated on the manufacturing floor.
+ */
+
+static ssize_t at24_iface_read(struct at24_iface *iface, char *buf,
+			      off_t offset, size_t count)
+{
+	struct at24_data *at24 = container_of(iface, struct at24_data, iface);
+
+	return at24_eeprom_read(at24, buf, offset, count);
+}
+
+static ssize_t at24_iface_write(struct at24_iface *iface, char *buf,
+			       off_t offset, size_t count)
+{
+	struct at24_data *at24 = container_of(iface, struct at24_data, iface);
+
+	return at24_eeprom_write(at24, buf, offset, count);
+}
+
 static int at24_probe(struct i2c_client *client, const struct i2c_device_id *id)
 {
 	struct at24_platform_data chip;
@@ -413,6 +436,9 @@ static int at24_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		 * is recommended anyhow.
 		 */
 		chip.page_size = 1;
+
+		chip.setup = NULL;
+		chip.context = NULL;
 	}
 
 	if (!is_power_of_2(chip.byte_len))
@@ -449,6 +475,9 @@ static int at24_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		goto err_out;
 	}
 
+	at24->iface.read = at24_iface_read;
+	at24->iface.write = at24_iface_write;
+
 	mutex_init(&at24->lock);
 	at24->use_smbus = use_smbus;
 	at24->chip = chip;
@@ -521,6 +550,10 @@ static int at24_probe(struct i2c_client *client, const struct i2c_device_id *id)
 		at24->write_max,
 		use_smbus ? ", use_smbus" : "");
 
+	/* export data to kernel code */
+	if (chip.setup)
+		chip.setup(&at24->iface, chip.context);
+
 	return 0;
 
 err_clients:
diff --git a/include/linux/i2c/at24.h b/include/linux/i2c/at24.h
index f6edd52..a7bd771 100644
--- a/include/linux/i2c/at24.h
+++ b/include/linux/i2c/at24.h
@@ -15,6 +15,13 @@
  * is bigger than what the chip actually supports!
  */
 
+struct at24_iface {
+	ssize_t (*read)(struct at24_iface *, char *buf, off_t offset,
+		size_t count);
+	ssize_t (*write)(struct at24_iface *, char *buf, off_t offset,
+		size_t count);
+};
+
 struct at24_platform_data {
 	u32		byte_len;		/* size (sum of all addr) */
 	u16		page_size;		/* for writes */
@@ -23,6 +30,9 @@ struct at24_platform_data {
 #define AT24_FLAG_READONLY	0x40	/* sysfs-entry will be read-only */
 #define AT24_FLAG_IRUGO		0x20	/* sysfs-entry will be world-readable */
 #define AT24_FLAG_TAKE8ADDR	0x10	/* take always 8 addresses (24c00) */
+
+	int			(*setup)(struct at24_iface *, void *context);
+	void		*context;
 };
 
 #endif /* _LINUX_AT24_H */
-- 
1.6.5.2

