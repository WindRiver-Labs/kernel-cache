From 74791f1bbfc0d717e24afeea54c9aa5a53e2c740 Mon Sep 17 00:00:00 2001
From: Tonyliu <Bo.Liu@windriver.com>
Date: Thu, 22 Oct 2009 16:57:25 +0800
Subject: [PATCH 02/14] DaVinci: da8xx mach update

Merge all DA8XX arch related codes between commits
380b0fdfd0227d7604cd91ad97fb846ba643e0e7 ~
1a7ff8ff6eebfa732ca2abe00a0878136bfb2d01
from mainline.

- Add general "struct davinci_soc_info" to support a series of standard chip
level abstracted methods and fields for DaVinci chips and add common platform init
routines.
- Seperate DA8XX on-board peripherals platform devices setup and registry into
devices-da8xx.c
- Add platform usb setup.
- Make GPIO code more generic according to new chip level software abstracted algorithm.
- Move pinmux setup info to SoC infrastructure.
- Make PLL, PSC handling more generic according to new chip level software abstracted algorithm.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 arch/arm/Kconfig                                 |    2 +
 arch/arm/mach-davinci/Kconfig                    |   52 ++
 arch/arm/mach-davinci/Makefile                   |   12 +-
 arch/arm/mach-davinci/Makefile.boot              |    8 +-
 arch/arm/mach-davinci/common.c                   |   98 ++++
 arch/arm/mach-davinci/devices-da8xx.c            |  567 ++++++++++++++++++++++
 arch/arm/mach-davinci/gpio.c                     |  332 +++++++++----
 arch/arm/mach-davinci/include/mach/asp.h         |   62 +++
 arch/arm/mach-davinci/include/mach/common.h      |   59 +++
 arch/arm/mach-davinci/include/mach/cputype.h     |   46 ++
 arch/arm/mach-davinci/include/mach/da8xx.h       |  130 +++++
 arch/arm/mach-davinci/include/mach/debug-macro.S |   39 ++-
 arch/arm/mach-davinci/include/mach/dma.h         |    2 -
 arch/arm/mach-davinci/include/mach/entry-macro.S |   21 +-
 arch/arm/mach-davinci/include/mach/gpio.h        |  105 ++--
 arch/arm/mach-davinci/include/mach/hardware.h    |   68 ++--
 arch/arm/mach-davinci/include/mach/io.h          |   61 +--
 arch/arm/mach-davinci/include/mach/irqs.h        |  111 ++++-
 arch/arm/mach-davinci/include/mach/memory.h      |   17 +-
 arch/arm/mach-davinci/include/mach/mux.h         |  473 ++++++++++++++++--
 arch/arm/mach-davinci/include/mach/psc.h         |   50 ++-
 arch/arm/mach-davinci/include/mach/serial.h      |   23 +-
 arch/arm/mach-davinci/include/mach/system.h      |    6 +-
 arch/arm/mach-davinci/include/mach/time.h        |   35 ++
 arch/arm/mach-davinci/include/mach/uncompress.h  |   19 +-
 arch/arm/mach-davinci/include/mach/usb.h         |   61 +++
 arch/arm/mach-davinci/include/mach/vmalloc.h     |    3 +-
 arch/arm/mach-davinci/io.c                       |   49 +--
 arch/arm/mach-davinci/mux.c                      |  118 ++++-
 arch/arm/mach-davinci/mux.h                      |   51 ++
 arch/arm/mach-davinci/psc.c                      |  118 ++---
 arch/arm/mach-davinci/serial.c                   |   83 ++--
 arch/arm/mach-davinci/time.c                     |  314 ++++++++-----
 arch/arm/mach-davinci/usb.c                      |  159 ++++++
 34 files changed, 2758 insertions(+), 596 deletions(-)
 create mode 100644 arch/arm/mach-davinci/common.c
 create mode 100644 arch/arm/mach-davinci/devices-da8xx.c
 create mode 100644 arch/arm/mach-davinci/include/mach/asp.h
 create mode 100644 arch/arm/mach-davinci/include/mach/cputype.h
 create mode 100644 arch/arm/mach-davinci/include/mach/da8xx.h
 create mode 100644 arch/arm/mach-davinci/include/mach/time.h
 create mode 100644 arch/arm/mach-davinci/include/mach/usb.h
 create mode 100644 arch/arm/mach-davinci/mux.h
 create mode 100644 arch/arm/mach-davinci/usb.c

diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 93602d9..69ff29e 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -513,9 +513,11 @@ config ARCH_LH7A40X
 
 config ARCH_DAVINCI
 	bool "TI DaVinci"
+	select CPU_ARM926T
 	select GENERIC_TIME
 	select GENERIC_CLOCKEVENTS
 	select GENERIC_GPIO
+	select ARCH_REQUIRE_GPIOLIB
 	select HAVE_CLK
 	help
 	  Support for TI's DaVinci platform.
diff --git a/arch/arm/mach-davinci/Kconfig b/arch/arm/mach-davinci/Kconfig
index bac988e..c54dfb6 100644
--- a/arch/arm/mach-davinci/Kconfig
+++ b/arch/arm/mach-davinci/Kconfig
@@ -8,6 +8,14 @@ config ARCH_DAVINCI644x
 	default y
 	bool "DaVinci 644x based system"
 
+config ARCH_DAVINCI_DA830
+	bool "DA830/OMAP-L137 based system"
+	select CP_INTC
+	select ARCH_DAVINCI_DA8XX
+
+config ARCH_DAVINCI_DA8XX
+	bool
+
 comment "DaVinci Board Type"
 
 config MACH_DAVINCI_EVM
@@ -18,6 +26,50 @@ config MACH_DAVINCI_EVM
 	  Configure this option to specify the whether the board used
 	  for development is a DaVinci EVM
 
+config MACH_DAVINCI_DA830_EVM
+	bool "TI DA830/OMAP-L137 Reference Platform"
+	default ARCH_DAVINCI_DA830
+	depends on ARCH_DAVINCI_DA830
+	help
+	  Say Y here to select the TI DA830/OMAP-L137 Evaluation Module.
+
+config DAVINCI_MUX
+	bool "DAVINCI multiplexing support"
+	depends on ARCH_DAVINCI
+	default y
+	help
+	  Pin multiplexing support for DAVINCI boards. If your bootloader
+	  sets the multiplexing correctly, say N. Otherwise, or if unsure,
+	  say Y.
+
+config DAVINCI_MUX_DEBUG
+	bool "Multiplexing debug output"
+	depends on DAVINCI_MUX
+	help
+	  Makes the multiplexing functions print out a lot of debug info.
+	  This is useful if you want to find out the correct values of the
+	  multiplexing registers.
+
+config DAVINCI_MUX_WARNINGS
+	bool "Warn about pins the bootloader didn't set up"
+	depends on DAVINCI_MUX
+	help
+	  Choose Y here to warn whenever driver initialization logic needs
+	  to change the pin multiplexing setup.  When there are no warnings
+	  printed, it's safe to deselect DAVINCI_MUX for your product.
+
+config DAVINCI_RESET_CLOCKS
+	bool "Reset unused clocks during boot"
+	depends on ARCH_DAVINCI
+	help
+	  Say Y if you want to reset unused clocks during boot.
+	  This option saves power, but assumes all drivers are
+	  using the clock framework. Broken drivers that do not
+	  yet use clock framework may not work with this option.
+	  If you are booting from another operating system, you
+	  probably do not want this option enabled until your
+	  device drivers work properly.
+
 endmenu
 
 endif
diff --git a/arch/arm/mach-davinci/Makefile b/arch/arm/mach-davinci/Makefile
index 99ac2e5..2f759e3 100644
--- a/arch/arm/mach-davinci/Makefile
+++ b/arch/arm/mach-davinci/Makefile
@@ -4,8 +4,16 @@
 #
 
 # Common objects
-obj-y 			:= time.o irq.o clock.o serial.o io.o id.o psc.o \
-			   gpio.o mux.o
+obj-y 			:= time.o clock.o serial.o io.o psc.o \
+			   gpio.o dma.o usb.o common.o
+
+obj-$(CONFIG_DAVINCI_MUX)		+= mux.o
+
+# Chip specific
+obj-$(CONFIG_ARCH_DAVINCI_DA830)		+= da830.o devices-da8xx.o
+
+obj-$(CONFIG_AINTC)				+= irq.o
 
 # Board specific
 obj-$(CONFIG_MACH_DAVINCI_EVM)  += board-evm.o
+obj-$(CONFIG_MACH_DAVINCI_DA830_EVM)    += board-da830-evm.o
diff --git a/arch/arm/mach-davinci/Makefile.boot b/arch/arm/mach-davinci/Makefile.boot
index e1dd366..752a204 100644
--- a/arch/arm/mach-davinci/Makefile.boot
+++ b/arch/arm/mach-davinci/Makefile.boot
@@ -1,3 +1,9 @@
-   zreladdr-y	:= 0x80008000
+ifeq ($(CONFIG_ARCH_DAVINCI_DA8XX),y)
+	zreladdr-y   := 0xc0008000
+params_phys-y   := 0xc0000100
+initrd_phys-y   := 0xc0800000
+else
+	zreladdr-y	:= 0x80008000
 params_phys-y	:= 0x80000100
 initrd_phys-y	:= 0x80800000
+endif
diff --git a/arch/arm/mach-davinci/common.c b/arch/arm/mach-davinci/common.c
new file mode 100644
index 0000000..672656e
--- /dev/null
+++ b/arch/arm/mach-davinci/common.c
@@ -0,0 +1,98 @@
+/*
+ * Code commons to all DaVinci SoCs.
+ *
+ * Author: Mark A. Greer <mgreer@mvista.com>
+ *
+ * 2009 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/etherdevice.h>
+
+#include <asm/tlb.h>
+#include <asm/mach/map.h>
+
+#include <mach/common.h>
+#include <mach/cputype.h>
+#include <mach/emac.h>
+
+#include "clock.h"
+
+struct davinci_soc_info davinci_soc_info;
+EXPORT_SYMBOL(davinci_soc_info);
+
+void __iomem *davinci_intc_base;
+int davinci_intc_type;
+
+static struct davinci_id * __init davinci_get_id(u32 jtag_id)
+{
+	int i;
+	struct davinci_id *dip;
+	u8 variant = (jtag_id & 0xf0000000) >> 28;
+	u16 part_no = (jtag_id & 0x0ffff000) >> 12;
+
+	for (i = 0, dip = davinci_soc_info.ids; i < davinci_soc_info.ids_num;
+			i++, dip++)
+		/* Don't care about the manufacturer right now */
+		if ((dip->part_no == part_no) && (dip->variant == variant))
+			return dip;
+
+	return NULL;
+}
+
+void __init davinci_common_init(struct davinci_soc_info *soc_info)
+{
+	int ret;
+	struct davinci_id *dip;
+
+	if (!soc_info) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	memcpy(&davinci_soc_info, soc_info, sizeof(struct davinci_soc_info));
+
+	if (davinci_soc_info.io_desc && (davinci_soc_info.io_desc_num > 0))
+		iotable_init(davinci_soc_info.io_desc,
+				davinci_soc_info.io_desc_num);
+
+	/*
+	 * Normally devicemaps_init() would flush caches and tlb after
+	 * mdesc->map_io(), but we must also do it here because of the CPU
+	 * revision check below.
+	 */
+	local_flush_tlb_all();
+	flush_cache_all();
+
+	/*
+	 * We want to check CPU revision early for cpu_is_xxxx() macros.
+	 * IO space mapping must be initialized before we can do that.
+	 */
+	davinci_soc_info.jtag_id = __raw_readl(davinci_soc_info.jtag_id_base);
+
+	dip = davinci_get_id(davinci_soc_info.jtag_id);
+	if (!dip) {
+		ret = -EINVAL;
+		goto err;
+	}
+
+	davinci_soc_info.cpu_id = dip->cpu_id;
+	pr_info("DaVinci %s variant 0x%x\n", dip->name, dip->variant);
+
+	if (davinci_soc_info.cpu_clks) {
+		ret = davinci_clk_init(davinci_soc_info.cpu_clks);
+
+		if (ret != 0)
+			goto err;
+	}
+
+	davinci_intc_base = davinci_soc_info.intc_base;
+	davinci_intc_type = davinci_soc_info.intc_type;
+	return;
+
+err:
+	pr_err("davinci_common_init: SoC Initialization failed\n");
+}
diff --git a/arch/arm/mach-davinci/devices-da8xx.c b/arch/arm/mach-davinci/devices-da8xx.c
new file mode 100644
index 0000000..eaeabe6
--- /dev/null
+++ b/arch/arm/mach-davinci/devices-da8xx.c
@@ -0,0 +1,567 @@
+/*
+ * DA8XX/OMAP L1XX platform device data
+ *
+ * Copyright (c) 2007-2009, MontaVista Software, Inc. <source@mvista.com>
+ * Derived from code that was:
+ *	Copyright (C) 2006 Komal Shah <komal_shah802003@yahoo.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/serial_8250.h>
+#include <linux/spi/davinci_spi_master.h>
+
+#include <mach/cputype.h>
+#include <mach/common.h>
+#include <mach/mux.h>
+#include <mach/time.h>
+#include <mach/da8xx.h>
+
+#include "clock.h"
+
+#define DA8XX_TPCC_BASE			0x01c00000
+#define DA8XX_TPTC0_BASE		0x01c08000
+#define DA8XX_TPTC1_BASE		0x01c08400
+#define DA8XX_WDOG_BASE			0x01c21000 /* DA8XX_TIMER64P1_BASE */
+#define DA8XX_I2C0_BASE			0x01c22000
+#define DA8XX_RTC_BASE			0x01C23000
+#define DA8XX_EMAC_CPPI_PORT_BASE	0x01e20000
+#define DA8XX_EMAC_CPGMACSS_BASE	0x01e22000
+#define DA8XX_EMAC_CPGMAC_BASE		0x01e23000
+#define DA8XX_EMAC_MDIO_BASE		0x01e24000
+#define DA8XX_GPIO_BASE			0x01e26000
+#define DA8XX_I2C1_BASE			0x01e28000
+
+#define DA8XX_EMAC_CTRL_REG_OFFSET	0x3000
+#define DA8XX_EMAC_MOD_REG_OFFSET	0x2000
+#define DA8XX_EMAC_RAM_OFFSET		0x0000
+#define DA8XX_MDIO_REG_OFFSET		0x4000
+#define DA8XX_EMAC_CTRL_RAM_SIZE	SZ_8K
+
+void __iomem *da8xx_syscfg_base;
+
+static struct plat_serial8250_port da8xx_serial_pdata[] = {
+	{
+		.mapbase	= DA8XX_UART0_BASE,
+		.irq		= IRQ_DA8XX_UARTINT0,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
+					UPF_IOREMAP,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+	},
+	{
+		.mapbase	= DA8XX_UART1_BASE,
+		.irq		= IRQ_DA8XX_UARTINT1,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
+					UPF_IOREMAP,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+	},
+	{
+		.mapbase	= DA8XX_UART2_BASE,
+		.irq		= IRQ_DA8XX_UARTINT2,
+		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
+					UPF_IOREMAP,
+		.iotype		= UPIO_MEM,
+		.regshift	= 2,
+	},
+	{
+		.flags	= 0,
+	},
+};
+
+struct platform_device da8xx_serial_device = {
+	.name	= "serial8250",
+	.id	= PLAT8250_DEV_PLATFORM,
+	.dev	= {
+		.platform_data	= da8xx_serial_pdata,
+	},
+};
+
+static const s8 da8xx_dma_chan_no_event[] = {
+	20, 21,
+	-1
+};
+
+static const s8 da8xx_queue_tc_mapping[][2] = {
+	/* {event queue no, TC no} */
+	{0, 0},
+	{1, 1},
+	{-1, -1}
+};
+
+static const s8 da8xx_queue_priority_mapping[][2] = {
+	/* {event queue no, Priority} */
+	{0, 3},
+	{1, 7},
+	{-1, -1}
+};
+
+static struct edma_soc_info da8xx_edma_info[] = {
+	{
+		.n_channel		= 32,
+		.n_region		= 4,
+		.n_slot			= 128,
+		.n_tc			= 2,
+		.n_cc			= 1,
+		.noevent		= da8xx_dma_chan_no_event,
+		.queue_tc_mapping	= da8xx_queue_tc_mapping,
+		.queue_priority_mapping	= da8xx_queue_priority_mapping,
+	},
+};
+
+#define SZ_32K (32 * 1024)
+
+static struct resource da8xx_edma_resources[] = {
+	{
+		.name	= "edma_cc0",
+		.start	= DA8XX_TPCC_BASE,
+		.end	= DA8XX_TPCC_BASE + SZ_32K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "edma_tc0",
+		.start	= DA8XX_TPTC0_BASE,
+		.end	= DA8XX_TPTC0_BASE + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "edma_tc1",
+		.start	= DA8XX_TPTC1_BASE,
+		.end	= DA8XX_TPTC1_BASE + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.name	= "edma0",
+		.start	= IRQ_DA8XX_CCINT0,
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		.name	= "edma0_err",
+		.start	= IRQ_DA8XX_CCERRINT,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device da8xx_edma_device = {
+	.name		= "edma",
+	.id		= -1,
+	.dev = {
+		.platform_data	= da8xx_edma_info,
+	},
+	.num_resources	= ARRAY_SIZE(da8xx_edma_resources),
+	.resource	= da8xx_edma_resources,
+};
+
+int __init da8xx_register_edma(void)
+{
+	return platform_device_register(&da8xx_edma_device);
+}
+
+static struct resource da8xx_i2c_resources0[] = {
+	{
+		.start	= DA8XX_I2C0_BASE,
+		.end	= DA8XX_I2C0_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= IRQ_DA8XX_I2CINT0,
+		.end	= IRQ_DA8XX_I2CINT0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device da8xx_i2c_device0 = {
+	.name		= "i2c_davinci",
+	.id		= 1,
+	.num_resources	= ARRAY_SIZE(da8xx_i2c_resources0),
+	.resource	= da8xx_i2c_resources0,
+};
+
+static struct resource da8xx_i2c_resources1[] = {
+	{
+		.start	= DA8XX_I2C1_BASE,
+		.end	= DA8XX_I2C1_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= IRQ_DA8XX_I2CINT1,
+		.end	= IRQ_DA8XX_I2CINT1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device da8xx_i2c_device1 = {
+	.name		= "i2c_davinci",
+	.id		= 2,
+	.num_resources	= ARRAY_SIZE(da8xx_i2c_resources1),
+	.resource	= da8xx_i2c_resources1,
+};
+
+int __init da8xx_register_i2c(int instance,
+		struct davinci_i2c_platform_data *pdata)
+{
+	struct platform_device *pdev;
+
+	if (instance == 0)
+		pdev = &da8xx_i2c_device0;
+	else if (instance == 1)
+		pdev = &da8xx_i2c_device1;
+	else
+		return -EINVAL;
+
+	pdev->dev.platform_data = pdata;
+	return platform_device_register(pdev);
+}
+
+static struct resource da8xx_watchdog_resources[] = {
+	{
+		.start	= DA8XX_WDOG_BASE,
+		.end	= DA8XX_WDOG_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+struct platform_device davinci_wdt_device = {
+	.name		= "watchdog",
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(da8xx_watchdog_resources),
+	.resource	= da8xx_watchdog_resources,
+};
+
+int __init da8xx_register_watchdog(void)
+{
+	return platform_device_register(&davinci_wdt_device);
+}
+
+static struct resource da8xx_emac_resources[] = {
+	{
+		.start	= DA8XX_EMAC_CPPI_PORT_BASE,
+		.end	= DA8XX_EMAC_CPPI_PORT_BASE + 0x5000 - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= IRQ_DA8XX_C0_RX_THRESH_PULSE,
+		.end	= IRQ_DA8XX_C0_RX_THRESH_PULSE,
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		.start	= IRQ_DA8XX_C0_RX_PULSE,
+		.end	= IRQ_DA8XX_C0_RX_PULSE,
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		.start	= IRQ_DA8XX_C0_TX_PULSE,
+		.end	= IRQ_DA8XX_C0_TX_PULSE,
+		.flags	= IORESOURCE_IRQ,
+	},
+	{
+		.start	= IRQ_DA8XX_C0_MISC_PULSE,
+		.end	= IRQ_DA8XX_C0_MISC_PULSE,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+struct emac_platform_data da8xx_emac_pdata = {
+	.ctrl_reg_offset	= DA8XX_EMAC_CTRL_REG_OFFSET,
+	.ctrl_mod_reg_offset	= DA8XX_EMAC_MOD_REG_OFFSET,
+	.ctrl_ram_offset	= DA8XX_EMAC_RAM_OFFSET,
+	.mdio_reg_offset	= DA8XX_MDIO_REG_OFFSET,
+	.ctrl_ram_size		= DA8XX_EMAC_CTRL_RAM_SIZE,
+	.version		= EMAC_VERSION_2,
+};
+
+static struct platform_device da8xx_emac_device = {
+	.name		= "davinci_emac",
+	.id		= 1,
+	.dev = {
+		.platform_data	= &da8xx_emac_pdata,
+	},
+	.num_resources	= ARRAY_SIZE(da8xx_emac_resources),
+	.resource	= da8xx_emac_resources,
+};
+
+int __init da8xx_register_emac(void)
+{
+	return platform_device_register(&da8xx_emac_device);
+}
+
+
+static struct davinci_spi_platform_data da8xx_spi_pdata0 = {
+	.version = DAVINCI_SPI_VERSION_2,
+	.clk_name = "spi0",
+	.cc_inst = 0
+};
+
+static struct resource da8xx_spi_resources0[] = {
+	[0] = {
+		.start = 0x01C41000,
+		.end = 0x01C41000 + 0xfff,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_DA8XX_SPINT0,
+		.end = IRQ_DA8XX_SPINT0,
+		.flags = IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start = EDMA_CTLR_CHAN(0, 14),
+		.end = EDMA_CTLR_CHAN(0, 14),
+		.flags = IORESOURCE_DMA | IORESOURCE_DMA_RX_CHAN,
+	},
+	[3] = {
+		.start = EDMA_CTLR_CHAN(0, 15),
+		.end = EDMA_CTLR_CHAN(0, 15),
+		.flags = IORESOURCE_DMA | IORESOURCE_DMA_TX_CHAN,
+	},
+	[4] = {
+		.start = 1,
+		.end = 1,
+		.flags = IORESOURCE_DMA | IORESOURCE_DMA_EVENT_Q,
+	},
+};
+
+static struct platform_device da8xx_spi_pdev0 = {
+	.name = "dm_spi",
+	.id = 0,
+	.resource = da8xx_spi_resources0,
+	.num_resources = ARRAY_SIZE(da8xx_spi_resources0),
+	.dev = {
+		.platform_data = &da8xx_spi_pdata0,
+	},
+};
+
+static struct davinci_spi_platform_data da8xx_spi_pdata1 = {
+	.version = DAVINCI_SPI_VERSION_2,
+	.clk_name = "spi1",
+	.cc_inst = 0
+};
+
+static struct resource da8xx_spi_resources1[] = {
+	[0] = {
+		.start = 0x01E12000,
+		.end = 0x01E12000 + 0xfff,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_DA8XX_SPINT1,
+		.end = IRQ_DA8XX_SPINT1,
+		.flags = IORESOURCE_IRQ,
+	},
+	[2] = {
+		.start = 18,
+		.end = 18,
+		.flags = IORESOURCE_DMA | IORESOURCE_DMA_RX_CHAN,
+	},
+	[3] = {
+		.start = 19,
+		.end = 19,
+		.flags = IORESOURCE_DMA | IORESOURCE_DMA_TX_CHAN,
+	},
+	[4] = {
+		.start = 1,
+		.end = 1,
+		.flags = IORESOURCE_DMA | IORESOURCE_DMA_EVENT_Q,
+	},
+};
+
+static struct platform_device da8xx_spi_pdev1 = {
+	.name = "dm_spi",
+	.id = 1,
+	.resource = da8xx_spi_resources1,
+	.num_resources = ARRAY_SIZE(da8xx_spi_resources1),
+	.dev = {
+		.platform_data = &da8xx_spi_pdata1,
+	},
+};
+
+void __init da8xx_init_spi0(unsigned char* chip_sel, unsigned int num_sel,
+    struct spi_board_info *info, unsigned num_dev)
+{
+	struct davinci_spi_platform_data *pdata =
+		da8xx_spi_pdev0.dev.platform_data;
+
+	/* TODO:
+	* 1.  remove ENA pin mux. It is likely not used anywhere.
+	* 2.  do pinmux based on chipsel mask ala DM355
+	*/
+	davinci_cfg_reg(DA830_SPI0_SOMI_0);
+	davinci_cfg_reg(DA830_SPI0_SIMO_0);
+	davinci_cfg_reg(DA830_SPI0_CLK);
+
+	if (num_sel && (!chip_sel || chip_sel[0] == DAVINCI_SPI_INTERN_CS))
+		davinci_cfg_reg(DA830_NSPI0_SCS_0);
+
+	spi_register_board_info(info, num_dev);
+
+	pdata->chip_sel = chip_sel;
+	pdata->num_chipselect = num_sel;
+	platform_device_register(&da8xx_spi_pdev0);
+}
+
+void __init da8xx_init_spi1(unsigned char* chip_sel, unsigned int num_sel,
+    struct spi_board_info *info, unsigned num_dev)
+{
+	struct davinci_spi_platform_data *pdata =
+		da8xx_spi_pdev1.dev.platform_data;
+
+	/* TODO
+	* 1.  remove ENA pin mux. It is likely not used anywhere.
+	* 2.  do pinmux based on chipsel mask ala DM355
+	*/
+
+	davinci_cfg_reg(DA830_SPI1_SOMI_0);
+	davinci_cfg_reg(DA830_SPI1_SIMO_0);
+	davinci_cfg_reg(DA830_SPI1_CLK);
+
+	if (num_sel && (!chip_sel || chip_sel[0] == DAVINCI_SPI_INTERN_CS))
+		davinci_cfg_reg(DA830_NSPI1_SCS_0);
+
+	spi_register_board_info(info, num_dev);
+
+	pdata->chip_sel = chip_sel;
+	pdata->num_chipselect = num_sel;
+	platform_device_register(&da8xx_spi_pdev1);
+}
+
+#ifdef FB_DAVINCI
+static const struct display_panel disp_panel = {
+	QVGA,
+	16,
+	16,
+	COLOR_ACTIVE,
+};
+
+static struct lcd_ctrl_config lcd_cfg = {
+	&disp_panel,
+	.ac_bias		= 255,
+	.ac_bias_intrpt		= 0,
+	.dma_burst_sz		= 16,
+	.bpp			= 16,
+	.fdd			= 255,
+	.tft_alt_mode		= 0,
+	.stn_565_mode		= 0,
+	.mono_8bit_mode		= 0,
+	.invert_line_clock	= 1,
+	.invert_frm_clock	= 1,
+	.sync_edge		= 0,
+	.sync_ctrl		= 1,
+	.raster_order		= 0,
+};
+
+struct da8xx_lcdc_platform_data sharp_lcd035q3dg01_pdata = {
+	.manu_name		= "sharp",
+	.controller_data	= &lcd_cfg,
+	.type			= "Sharp_LCD035Q3DG01",
+};
+
+struct da8xx_lcdc_platform_data sharp_lk043t1dg01_pdata = {
+	.manu_name		= "sharp",
+	.controller_data	= &lcd_cfg,
+	.type			= "Sharp_LK043T1DG01",
+};
+
+static struct resource da8xx_lcdc_resources[] = {
+	[0] = { /* registers */
+		.start  = DA8XX_LCD_CNTRL_BASE,
+		.end    = DA8XX_LCD_CNTRL_BASE + SZ_4K - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = { /* interrupt */
+		.start  = IRQ_DA8XX_LCDINT,
+		.end    = IRQ_DA8XX_LCDINT,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device da8xx_lcdc_device = {
+	.name		= "da8xx_lcdc",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(da8xx_lcdc_resources),
+	.resource	= da8xx_lcdc_resources,
+};
+
+int __init da8xx_register_lcdc(struct da8xx_lcdc_platform_data *pdata)
+{
+	da8xx_lcdc_device.dev.platform_data = pdata;
+	return platform_device_register(&da8xx_lcdc_device);
+}
+
+#endif /*FB_DAVINCI*/
+
+static struct resource da8xx_mmcsd0_resources[] = {
+	{		/* registers */
+		.start	= DA8XX_MMCSD0_BASE,
+		.end	= DA8XX_MMCSD0_BASE + SZ_4K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	{		/* interrupt */
+		.start	= IRQ_DA8XX_MMCSDINT0,
+		.end	= IRQ_DA8XX_MMCSDINT0,
+		.flags	= IORESOURCE_IRQ,
+	},
+	{		/* DMA RX */
+		.start	= EDMA_CTLR_CHAN(0, 16),
+		.end	= EDMA_CTLR_CHAN(0, 16),
+		.flags	= IORESOURCE_DMA,
+	},
+	{		/* DMA TX */
+		.start	= EDMA_CTLR_CHAN(0, 17),
+		.end	= EDMA_CTLR_CHAN(0, 17),
+		.flags	= IORESOURCE_DMA,
+	},
+};
+
+static struct platform_device da8xx_mmcsd0_device = {
+	.name		= "davinci_mmc",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(da8xx_mmcsd0_resources),
+	.resource	= da8xx_mmcsd0_resources,
+};
+
+int __init da8xx_register_mmcsd0(struct davinci_mmc_config *config)
+{
+	da8xx_mmcsd0_device.dev.platform_data = config;
+	return platform_device_register(&da8xx_mmcsd0_device);
+}
+
+static struct resource da8xx_rtc_resources[] = {
+	{
+		.start		= DA8XX_RTC_BASE,
+		.end		= DA8XX_RTC_BASE + SZ_4K - 1,
+		.flags		= IORESOURCE_MEM,
+	},
+	{ /* timer irq */
+		.start		= IRQ_DA8XX_RTC,
+		.end		= IRQ_DA8XX_RTC,
+		.flags		= IORESOURCE_IRQ,
+	},
+	{ /* alarm irq */
+		.start		= IRQ_DA8XX_RTC,
+		.end		= IRQ_DA8XX_RTC,
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device da8xx_rtc_device = {
+	.name           = "rtc-da830",
+	.id             = -1,
+	.num_resources	= ARRAY_SIZE(da8xx_rtc_resources),
+	.resource	= da8xx_rtc_resources,
+};
+
+int da8xx_register_rtc(void)
+{
+	/* Unlock the rtc's registers */
+	__raw_writel(0x83e70b13, IO_ADDRESS(DA8XX_RTC_BASE + 0x6c));
+	__raw_writel(0x95a4f1e0, IO_ADDRESS(DA8XX_RTC_BASE + 0x70));
+
+	return platform_device_register(&da8xx_rtc_device);
+}
diff --git a/arch/arm/mach-davinci/gpio.c b/arch/arm/mach-davinci/gpio.c
index c9cb4f0..f7b42bf 100644
--- a/arch/arm/mach-davinci/gpio.c
+++ b/arch/arm/mach-davinci/gpio.c
@@ -1,7 +1,7 @@
 /*
  * TI DaVinci GPIO Support
  *
- * Copyright (c) 2006 David Brownell
+ * Copyright (c) 2006-2007 David Brownell
  * Copyright (c) 2007, MontaVista Software, Inc. <source@mvista.com>
  *
  * This program is free software; you can redistribute it and/or modify
@@ -20,53 +20,54 @@
 #include <linux/irq.h>
 #include <linux/bitops.h>
 
+#include <mach/cputype.h>
 #include <mach/irqs.h>
 #include <mach/hardware.h>
+#include <mach/common.h>
 #include <mach/gpio.h>
 
 #include <asm/mach/irq.h>
 
-static DEFINE_SPINLOCK(gpio_lock);
-static DECLARE_BITMAP(gpio_in_use, DAVINCI_N_GPIO);
-
-int gpio_request(unsigned gpio, const char *tag)
-{
-	if (gpio >= DAVINCI_N_GPIO)
-		return -EINVAL;
 
-	if (test_and_set_bit(gpio, gpio_in_use))
-		return -EBUSY;
-
-	return 0;
-}
-EXPORT_SYMBOL(gpio_request);
+static DEFINE_SPINLOCK(gpio_lock);
 
-void gpio_free(unsigned gpio)
-{
-	if (gpio >= DAVINCI_N_GPIO)
-		return;
+struct davinci_gpio {
+	struct gpio_chip	chip;
+	struct gpio_controller	*__iomem regs;
+	int			irq_base;
+};
 
-	clear_bit(gpio, gpio_in_use);
-}
-EXPORT_SYMBOL(gpio_free);
+static struct davinci_gpio chips[DIV_ROUND_UP(DAVINCI_N_GPIO, 32)];
 
 /* create a non-inlined version */
-static struct gpio_controller *__iomem gpio2controller(unsigned gpio)
+static struct gpio_controller __iomem * __init gpio2controller(unsigned gpio)
 {
 	return __gpio_to_controller(gpio);
 }
 
+static int __init davinci_gpio_irq_setup(void);
+
+/*--------------------------------------------------------------------------*/
+
 /*
- * Assuming the pin is muxed as a gpio output, set its output value.
+ * board setup code *MUST* set PINMUX0 and PINMUX1 as
+ * needed, and enable the GPIO clock.
  */
-void __gpio_set(unsigned gpio, int value)
+
+static int davinci_direction_in(struct gpio_chip *chip, unsigned offset)
 {
-	struct gpio_controller *__iomem g = gpio2controller(gpio);
+	struct davinci_gpio *d = container_of(chip, struct davinci_gpio, chip);
+	struct gpio_controller *__iomem g = d->regs;
+	u32 temp;
 
-	__raw_writel(__gpio_mask(gpio), value ? &g->set_data : &g->clr_data);
-}
-EXPORT_SYMBOL(__gpio_set);
+	spin_lock(&gpio_lock);
+	temp = __raw_readl(&g->dir);
+	temp |= (1 << offset);
+	__raw_writel(temp, &g->dir);
+	spin_unlock(&gpio_lock);
 
+	return 0;
+}
 
 /*
  * Read the pin's value (works even if it's set up as output);
@@ -75,77 +76,102 @@ EXPORT_SYMBOL(__gpio_set);
  * Note that changes are synched to the GPIO clock, so reading values back
  * right after you've set them may give old values.
  */
-int __gpio_get(unsigned gpio)
+static int davinci_gpio_get(struct gpio_chip *chip, unsigned offset)
 {
-	struct gpio_controller *__iomem g = gpio2controller(gpio);
+	struct davinci_gpio *d = container_of(chip, struct davinci_gpio, chip);
+	struct gpio_controller *__iomem g = d->regs;
 
-	return !!(__gpio_mask(gpio) & __raw_readl(&g->in_data));
+	return (1 << offset) & __raw_readl(&g->in_data);
 }
-EXPORT_SYMBOL(__gpio_get);
-
 
-/*--------------------------------------------------------------------------*/
-
-/*
- * board setup code *MUST* set PINMUX0 and PINMUX1 as
- * needed, and enable the GPIO clock.
- */
-
-int gpio_direction_input(unsigned gpio)
+static int
+davinci_direction_out(struct gpio_chip *chip, unsigned offset, int value)
 {
-	struct gpio_controller *__iomem g = gpio2controller(gpio);
+	struct davinci_gpio *d = container_of(chip, struct davinci_gpio, chip);
+	struct gpio_controller *__iomem g = d->regs;
 	u32 temp;
-	u32 mask;
-
-	if (!g)
-		return -EINVAL;
+	u32 mask = 1 << offset;
 
 	spin_lock(&gpio_lock);
-	mask = __gpio_mask(gpio);
 	temp = __raw_readl(&g->dir);
-	temp |= mask;
+	temp &= ~mask;
+	__raw_writel(mask, value ? &g->set_data : &g->clr_data);
 	__raw_writel(temp, &g->dir);
 	spin_unlock(&gpio_lock);
 	return 0;
 }
-EXPORT_SYMBOL(gpio_direction_input);
 
-int gpio_direction_output(unsigned gpio, int value)
+/*
+ * Assuming the pin is muxed as a gpio output, set its output value.
+ */
+static void
+davinci_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
 {
-	struct gpio_controller *__iomem g = gpio2controller(gpio);
-	u32 temp;
-	u32 mask;
+	struct davinci_gpio *d = container_of(chip, struct davinci_gpio, chip);
+	struct gpio_controller *__iomem g = d->regs;
+
+	__raw_writel((1 << offset), value ? &g->set_data : &g->clr_data);
+}
 
-	if (!g)
+static int __init davinci_gpio_setup(void)
+{
+	int i, base;
+	unsigned ngpio;
+	struct davinci_soc_info *soc_info = &davinci_soc_info;
+
+	/*
+	 * The gpio banks conceptually expose a segmented bitmap,
+	 * and "ngpio" is one more than the largest zero-based
+	 * bit index that's valid.
+	 */
+	ngpio = soc_info->gpio_num;
+	if (ngpio == 0) {
+		pr_err("GPIO setup:  how many GPIOs?\n");
 		return -EINVAL;
+	}
 
-	spin_lock(&gpio_lock);
-	mask = __gpio_mask(gpio);
-	temp = __raw_readl(&g->dir);
-	temp &= ~mask;
-	__raw_writel(mask, value ? &g->set_data : &g->clr_data);
-	__raw_writel(temp, &g->dir);
-	spin_unlock(&gpio_lock);
+	if (WARN_ON(DAVINCI_N_GPIO < ngpio))
+		ngpio = DAVINCI_N_GPIO;
+
+	for (i = 0, base = 0; base < ngpio; i++, base += 32) {
+		chips[i].chip.label = "DaVinci";
+
+		chips[i].chip.direction_input = davinci_direction_in;
+		chips[i].chip.get = davinci_gpio_get;
+		chips[i].chip.direction_output = davinci_direction_out;
+		chips[i].chip.set = davinci_gpio_set;
+
+		chips[i].chip.base = base;
+		chips[i].chip.ngpio = ngpio - base;
+		if (chips[i].chip.ngpio > 32)
+			chips[i].chip.ngpio = 32;
+
+		chips[i].regs = gpio2controller(base);
+
+		gpiochip_add(&chips[i].chip);
+	}
+
+	davinci_gpio_irq_setup();
 	return 0;
 }
-EXPORT_SYMBOL(gpio_direction_output);
+pure_initcall(davinci_gpio_setup);
 
+/*--------------------------------------------------------------------------*/
 /*
  * We expect irqs will normally be set up as input pins, but they can also be
  * used as output pins ... which is convenient for testing.
  *
- * NOTE:  GPIO0..GPIO7 also have direct INTC hookups, which work in addition
- * to their GPIOBNK0 irq (but with a bit less overhead).  But we don't have
- * a good way to hook those up ...
+ * NOTE:  The first few GPIOs also have direct INTC hookups in addition
+ * to their GPIOBNK0 irq, with a bit less overhead.
  *
- * All those INTC hookups (GPIO0..GPIO7 plus five IRQ banks) can also
+ * All those INTC hookups (direct, plus several IRQ banks) can also
  * serve as EDMA event triggers.
  */
 
 static void gpio_irq_disable(unsigned irq)
 {
 	struct gpio_controller *__iomem g = get_irq_chip_data(irq);
-	u32 mask = __gpio_mask(irq_to_gpio(irq));
+	u32 mask = (u32) get_irq_data(irq);
 
 	__raw_writel(mask, &g->clr_falling);
 	__raw_writel(mask, &g->clr_rising);
@@ -154,18 +180,23 @@ static void gpio_irq_disable(unsigned irq)
 static void gpio_irq_enable(unsigned irq)
 {
 	struct gpio_controller *__iomem g = get_irq_chip_data(irq);
-	u32 mask = __gpio_mask(irq_to_gpio(irq));
+	u32 mask = (u32) get_irq_data(irq);
+	unsigned status = irq_desc[irq].status;
+
+	status &= IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING;
+	if (!status)
+		status = IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING;
 
-	if (irq_desc[irq].status & IRQ_TYPE_EDGE_FALLING)
+	if (status & IRQ_TYPE_EDGE_FALLING)
 		__raw_writel(mask, &g->set_falling);
-	if (irq_desc[irq].status & IRQ_TYPE_EDGE_RISING)
+	if (status & IRQ_TYPE_EDGE_RISING)
 		__raw_writel(mask, &g->set_rising);
 }
 
 static int gpio_irq_type(unsigned irq, unsigned trigger)
 {
 	struct gpio_controller *__iomem g = get_irq_chip_data(irq);
-	u32 mask = __gpio_mask(irq_to_gpio(irq));
+	u32 mask = (u32) get_irq_data(irq);
 
 	if (trigger & ~(IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))
 		return -EINVAL;
@@ -173,10 +204,13 @@ static int gpio_irq_type(unsigned irq, unsigned trigger)
 	irq_desc[irq].status &= ~IRQ_TYPE_SENSE_MASK;
 	irq_desc[irq].status |= trigger;
 
-	__raw_writel(mask, (trigger & IRQ_TYPE_EDGE_FALLING)
-		     ? &g->set_falling : &g->clr_falling);
-	__raw_writel(mask, (trigger & IRQ_TYPE_EDGE_RISING)
-		     ? &g->set_rising : &g->clr_rising);
+	/* don't enable the IRQ if it's currently disabled */
+	if (irq_desc[irq].depth == 0) {
+		__raw_writel(mask, (trigger & IRQ_TYPE_EDGE_FALLING)
+			     ? &g->set_falling : &g->clr_falling);
+		__raw_writel(mask, (trigger & IRQ_TYPE_EDGE_RISING)
+			     ? &g->set_rising : &g->clr_rising);
+	}
 	return 0;
 }
 
@@ -198,10 +232,10 @@ gpio_irq_handler(unsigned irq, struct irq_desc *desc)
 		mask <<= 16;
 
 	/* temporarily mask (level sensitive) parent IRQ */
+	desc->chip->mask(irq);
 	desc->chip->ack(irq);
 	while (1) {
 		u32		status;
-		struct irq_desc	*gpio;
 		int		n;
 		int		res;
 
@@ -215,12 +249,10 @@ gpio_irq_handler(unsigned irq, struct irq_desc *desc)
 
 		/* now demux them to the right lowlevel handler */
 		n = (int)get_irq_data(irq);
-		gpio = &irq_desc[n];
 		while (status) {
 			res = ffs(status);
 			n += res;
-			gpio += res;
-			desc_handle_irq(n - 1, gpio - 1);
+			generic_handle_irq(n - 1);
 			status >>= res;
 		}
 	}
@@ -228,59 +260,165 @@ gpio_irq_handler(unsigned irq, struct irq_desc *desc)
 	/* now it may re-trigger */
 }
 
+static int gpio_to_irq_banked(struct gpio_chip *chip, unsigned offset)
+{
+	struct davinci_gpio *d = container_of(chip, struct davinci_gpio, chip);
+
+	if (d->irq_base >= 0)
+		return d->irq_base + offset;
+	else
+		return -ENODEV;
+}
+
+#ifndef CONFIG_CP_INTC
+static int gpio_to_irq_unbanked(struct gpio_chip *chip, unsigned offset)
+{
+	struct davinci_soc_info *soc_info = &davinci_soc_info;
+
+	/* NOTE:  we assume for now that only irqs in the first gpio_chip
+	 * can provide direct-mapped IRQs to AINTC (up to 32 GPIOs).
+	 */
+	if (offset < soc_info->gpio_unbanked)
+		return soc_info->gpio_irq + offset;
+	else
+		return -ENODEV;
+}
+
+static int gpio_irq_type_unbanked(unsigned irq, unsigned trigger)
+{
+	struct gpio_controller *__iomem g = get_irq_chip_data(irq);
+	u32 mask = (u32) get_irq_data(irq);
+
+	if (trigger & ~(IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))
+		return -EINVAL;
+
+	__raw_writel(mask, (trigger & IRQ_TYPE_EDGE_FALLING)
+		     ? &g->set_falling : &g->clr_falling);
+	__raw_writel(mask, (trigger & IRQ_TYPE_EDGE_RISING)
+		     ? &g->set_rising : &g->clr_rising);
+
+	return 0;
+}
+#endif
+
 /*
- * NOTE:  for suspend/resume, probably best to make a sysdev (and class)
- * with its suspend/resume calls hooking into the results of the set_wake()
+ * NOTE:  for suspend/resume, probably best to make a platform_device with
+ * suspend_late/resume_resume calls hooking into results of the set_wake()
  * calls ... so if no gpios are wakeup events the clock can be disabled,
  * with outputs left at previously set levels, and so that VDD3P3V.IOPWDN0
- * can be set appropriately for GPIOV33 pins.
+ * (dm6446) can be set appropriately for GPIOV33 pins.
  */
 
 static int __init davinci_gpio_irq_setup(void)
 {
 	unsigned	gpio, irq, bank;
 	struct clk	*clk;
+	u32		binten = 0;
+	unsigned	ngpio, bank_irq;
+	struct davinci_soc_info *soc_info = &davinci_soc_info;
+	struct gpio_controller	*__iomem g;
+
+	ngpio = soc_info->gpio_num;
+
+	bank_irq = soc_info->gpio_irq;
+	if (bank_irq == 0) {
+		printk(KERN_ERR "Don't know first GPIO bank IRQ.\n");
+		return -EINVAL;
+	}
 
 	clk = clk_get(NULL, "gpio");
 	if (IS_ERR(clk)) {
 		printk(KERN_ERR "Error %ld getting gpio clock?\n",
 		       PTR_ERR(clk));
-		return 0;
+		return PTR_ERR(clk);
 	}
-
 	clk_enable(clk);
 
-	for (gpio = 0, irq = gpio_to_irq(0), bank = IRQ_GPIOBNK0;
-	     gpio < DAVINCI_N_GPIO; bank++) {
-		struct gpio_controller	*__iomem g = gpio2controller(gpio);
+	/* Arrange gpio_to_irq() support, handling either direct IRQs or
+	 * banked IRQs.  Having GPIOs in the first GPIO bank use direct
+	 * IRQs, while the others use banked IRQs, would need some setup
+	 * tweaks to recognize hardware which can do that.
+	 */
+	for (gpio = 0, bank = 0; gpio < ngpio; bank++, gpio += 32) {
+		chips[bank].chip.to_irq = gpio_to_irq_banked;
+		chips[bank].irq_base = soc_info->gpio_unbanked
+			? -EINVAL
+			: (soc_info->intc_irq_num + gpio);
+	}
+
+#ifndef CONFIG_CP_INTC
+	/*
+	 * AINTC can handle direct/unbanked IRQs for GPIOs, with the GPIO
+	 * controller only handling trigger modes.  We currently assume no
+	 * IRQ mux conflicts; gpio_irq_type_unbanked() is only for GPIOs.
+	 */
+	if (soc_info->gpio_unbanked) {
+		static struct irq_chip gpio_irqchip_unbanked;
+
+		/* pass "bank 0" GPIO IRQs to AINTC */
+		chips[0].chip.to_irq = gpio_to_irq_unbanked;
+		binten = BIT(0);
+
+		/* AINTC handles mask/unmask; GPIO handles triggering */
+		irq = bank_irq;
+		gpio_irqchip_unbanked = *get_irq_desc_chip(irq_to_desc(irq));
+		gpio_irqchip_unbanked.name = "GPIO-AINTC";
+		gpio_irqchip_unbanked.set_type = gpio_irq_type_unbanked;
+
+		/* default trigger: both edges */
+		g = gpio2controller(0);
+		__raw_writel(~0, &g->set_falling);
+		__raw_writel(~0, &g->set_rising);
+
+		/* set the direct IRQs up to use that irqchip */
+		for (gpio = 0; gpio < soc_info->gpio_unbanked; gpio++, irq++) {
+			set_irq_chip(irq, &gpio_irqchip_unbanked);
+			set_irq_data(irq, (void *) __gpio_mask(gpio));
+			set_irq_chip_data(irq, g);
+			irq_desc[irq].status |= IRQ_TYPE_EDGE_BOTH;
+		}
+
+		goto done;
+	}
+#endif
+	/*
+	 * Or, AINTC can handle IRQs for banks of 16 GPIO IRQs, which we
+	 * then chain through our own handler.
+	 */
+	for (gpio = 0, irq = gpio_to_irq(0), bank = 0;
+			gpio < ngpio;
+			bank++, bank_irq++) {
 		unsigned		i;
 
+		/* disabled by default, enabled only as needed */
+		g = gpio2controller(gpio);
 		__raw_writel(~0, &g->clr_falling);
 		__raw_writel(~0, &g->clr_rising);
 
 		/* set up all irqs in this bank */
-		set_irq_chained_handler(bank, gpio_irq_handler);
-		set_irq_chip_data(bank, g);
-		set_irq_data(bank, (void *)irq);
+		set_irq_chained_handler(bank_irq, gpio_irq_handler);
+		set_irq_chip_data(bank_irq, g);
+		set_irq_data(bank_irq, (void *)irq);
 
-		for (i = 0; i < 16 && gpio < DAVINCI_N_GPIO;
-		     i++, irq++, gpio++) {
+		for (i = 0; i < 16 && gpio < ngpio; i++, irq++, gpio++) {
 			set_irq_chip(irq, &gpio_irqchip);
 			set_irq_chip_data(irq, g);
+			set_irq_data(irq, (void *) __gpio_mask(gpio));
 			set_irq_handler(irq, handle_simple_irq);
 			set_irq_flags(irq, IRQF_VALID);
 		}
-	}
 
+		binten |= BIT(bank);
+	}
+#ifndef CONFIG_CP_INTC
+done:
+#endif
 	/* BINTEN -- per-bank interrupt enable. genirq would also let these
 	 * bits be set/cleared dynamically.
 	 */
-	__raw_writel(0x1f, (void *__iomem)
-		     IO_ADDRESS(DAVINCI_GPIO_BASE + 0x08));
+	__raw_writel(binten, soc_info->gpio_base + 0x08);
 
 	printk(KERN_INFO "DaVinci: %d gpio irqs\n", irq - gpio_to_irq(0));
 
 	return 0;
 }
-
-arch_initcall(davinci_gpio_irq_setup);
diff --git a/arch/arm/mach-davinci/include/mach/asp.h b/arch/arm/mach-davinci/include/mach/asp.h
new file mode 100644
index 0000000..e4a16a8
--- /dev/null
+++ b/arch/arm/mach-davinci/include/mach/asp.h
@@ -0,0 +1,62 @@
+/*
+ * <mach/asp.h> - DaVinci Audio Serial Port support
+ */
+#ifndef __ASM_ARCH_DAVINCI_ASP_H
+#define __ASM_ARCH_DAVINCI_ASP_H
+
+#include <mach/irqs.h>
+#include <mach/edma.h>
+
+/* Bases of register banks */
+#define DAVINCI_ASP0_BASE	0x01E02000
+#define DAVINCI_ASP1_BASE	0x01E04000
+
+/* Bases of da850/da830 McASP0  register banks */
+#define DAVINCI_DA8XX_MCASP0_REG_BASE	0x01D00000
+
+/* Bases of da830 McASP1 register banks */
+#define DAVINCI_DA830_MCASP1_REG_BASE	0x01D04000
+
+/* EDMA channels of da850/da830 McASP0 */
+#define	DAVINCI_DA8XX_DMA_MCASP0_AREVT	0
+#define	DAVINCI_DA8XX_DMA_MCASP0_AXEVT	1
+
+/* EDMA channels of da830 McASP1 */
+#define	DAVINCI_DA830_DMA_MCASP1_AREVT	2
+#define	DAVINCI_DA830_DMA_MCASP1_AXEVT	3
+
+/* Interrupts */
+#define DAVINCI_ASP0_RX_INT	IRQ_MBRINT
+#define DAVINCI_ASP0_TX_INT	IRQ_MBXINT
+#define DAVINCI_ASP1_RX_INT	IRQ_MBRINT
+#define DAVINCI_ASP1_TX_INT	IRQ_MBXINT
+
+struct snd_platform_data {
+	u32 tx_dma_offset;
+	u32 rx_dma_offset;
+	enum dma_event_q eventq_no;	/* event queue number */
+	unsigned int codec_fmt;
+
+	/* McASP specific fields */
+	int tdm_slots;
+	u8 op_mode;
+	u8 num_serializer;
+	u8 *serial_dir;
+	u8 version;
+	u8 txnumevt;
+	u8 rxnumevt;
+};
+
+enum {
+	MCASP_VERSION_1 = 0,	/* DM646x */
+	MCASP_VERSION_2,	/* DA8xx/OMAPL1x */
+};
+
+#define INACTIVE_MODE	0
+#define TX_MODE		1
+#define RX_MODE		2
+
+#define DAVINCI_MCASP_IIS_MODE	0
+#define DAVINCI_MCASP_DIT_MODE	1
+
+#endif /* __ASM_ARCH_DAVINCI_ASP_H */
diff --git a/arch/arm/mach-davinci/include/mach/common.h b/arch/arm/mach-davinci/include/mach/common.h
index a97dfbb..4b39611 100644
--- a/arch/arm/mach-davinci/include/mach/common.h
+++ b/arch/arm/mach-davinci/include/mach/common.h
@@ -16,4 +16,63 @@ struct sys_timer;
 
 extern struct sys_timer davinci_timer;
 
+extern void davinci_irq_init(void);
+extern void __iomem *davinci_intc_base;
+extern int davinci_intc_type;
+
+/* parameters describe VBUS sourcing for host mode */
+extern void setup_usb(unsigned mA, unsigned potpgt_msec);
+
+struct davinci_timer_instance {
+	void __iomem	*base;
+	u32		bottom_irq;
+	u32		top_irq;
+	unsigned long	cmp_off;
+	unsigned int	cmp_irq;
+};
+
+struct davinci_timer_info {
+	struct davinci_timer_instance	*timers;
+	unsigned int			clockevent_id;
+	unsigned int			clocksource_id;
+};
+
+/* SoC specific init support */
+struct davinci_soc_info {
+	struct map_desc			*io_desc;
+	unsigned long			io_desc_num;
+	u32				cpu_id;
+	u32				jtag_id;
+	void __iomem			*jtag_id_base;
+	struct davinci_id		*ids;
+	unsigned long			ids_num;
+	struct davinci_clk		*cpu_clks;
+	void __iomem			**psc_bases;
+	unsigned long			psc_bases_num;
+	void __iomem			*pinmux_base;
+	const struct mux_config		*pinmux_pins;
+	unsigned long			pinmux_pins_num;
+	void __iomem			*intc_base;
+	int				intc_type;
+	u8				*intc_irq_prios;
+	unsigned long			intc_irq_num;
+	struct davinci_timer_info	*timer_info;
+	void __iomem			*gpio_base;
+	unsigned			gpio_num;
+	unsigned			gpio_irq;
+	unsigned			gpio_unbanked;
+	struct platform_device		*serial_dev;
+	struct emac_platform_data	*emac_pdata;
+	dma_addr_t			sram_dma;
+	unsigned			sram_len;
+};
+
+extern struct davinci_soc_info davinci_soc_info;
+
+extern void davinci_common_init(struct davinci_soc_info *soc_info);
+
+/* standard place to map on-chip SRAMs; they *may* support DMA */
+#define SRAM_VIRT	0xfffe0000
+#define SRAM_SIZE	SZ_128K
+
 #endif /* __ARCH_ARM_MACH_DAVINCI_COMMON_H */
diff --git a/arch/arm/mach-davinci/include/mach/cputype.h b/arch/arm/mach-davinci/include/mach/cputype.h
new file mode 100644
index 0000000..f884c94
--- /dev/null
+++ b/arch/arm/mach-davinci/include/mach/cputype.h
@@ -0,0 +1,46 @@
+/*
+ * DaVinci CPU type detection
+ *
+ * Author: Kevin Hilman, Deep Root Systems, LLC
+ *
+ * Defines the cpu_is_*() macros for runtime detection of DaVinci
+ * device type.  In addtion, if support for a given device is not
+ * compiled in to the kernel, the macros return 0 so that
+ * resulting code can be optimized out.
+ *
+ * 2009 (c) Deep Root Systems, LLC. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#ifndef _ASM_ARCH_CPU_H
+#define _ASM_ARCH_CPU_H
+
+#include <mach/common.h>
+
+struct davinci_id {
+	u8	variant;	/* JTAG ID bits 31:28 */
+	u16	part_no;	/* JTAG ID bits 27:12 */
+	u16	manufacturer;	/* JTAG ID bits 11:1 */
+	u32	cpu_id;
+	char	*name;
+};
+
+/* Can use lower 16 bits of cpu id  for a variant when required */
+#define	DAVINCI_CPU_ID_DA830		0x08300000
+
+#define IS_DAVINCI_CPU(type, id)					\
+static inline int is_davinci_ ##type(void)				\
+{									\
+	return (davinci_soc_info.cpu_id == (id));			\
+}
+
+IS_DAVINCI_CPU(da830, DAVINCI_CPU_ID_DA830)
+
+#ifdef CONFIG_ARCH_DAVINCI_DA830
+#define cpu_is_davinci_da830() is_davinci_da830()
+#else
+#define cpu_is_davinci_da830() 0
+#endif
+
+#endif
diff --git a/arch/arm/mach-davinci/include/mach/da8xx.h b/arch/arm/mach-davinci/include/mach/da8xx.h
new file mode 100644
index 0000000..b69b786
--- /dev/null
+++ b/arch/arm/mach-davinci/include/mach/da8xx.h
@@ -0,0 +1,130 @@
+/*
+ * Chip specific defines for DA8XX/OMAP L1XX SoC
+ *
+ * Author: Mark A. Greer <mgreer@mvista.com>
+ *
+ * 2007, 2009 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#ifndef __ASM_ARCH_DAVINCI_DA8XX_H
+#define __ASM_ARCH_DAVINCI_DA8XX_H
+
+#include <mach/serial.h>
+#include <mach/edma.h>
+#include <mach/i2c.h>
+#include <mach/emac.h>
+#include <mach/asp.h>
+#include <mach/mmc.h>
+
+extern void __iomem *da8xx_syscfg_base;
+
+/*
+ * The cp_intc interrupt controller for the da8xx isn't in the same
+ * chunk of physical memory space as the other registers (like it is
+ * on the davincis) so it needs to be mapped separately.  It will be
+ * mapped early on when the I/O space is mapped and we'll put it just
+ * before the I/O space in the processor's virtual memory space.
+ */
+#define DA8XX_CP_INTC_BASE	0xfffee000
+#define DA8XX_CP_INTC_SIZE	SZ_8K
+#define DA8XX_CP_INTC_VIRT	(IO_VIRT - DA8XX_CP_INTC_SIZE - SZ_4K)
+
+#define DA8XX_SYSCFG_BASE	(IO_PHYS + 0x14000)
+#define DA8XX_SYSCFG_VIRT(x)	(da8xx_syscfg_base + (x))
+#define DA8XX_JTAG_ID_REG	0x18
+#define DA8XX_CFGCHIP3_REG	0x188
+
+#define DA8XX_KICK0             (DA8XX_SYSCFG_BASE + 0x38)
+#define DA8XX_KICK0_MAGIC       0x83e70b13
+#define DA8XX_KICK1             (DA8XX_SYSCFG_BASE + 0x3c)
+#define DA8XX_KICK1_MAGIC       0x95a4f1e0
+
+#define DA8XX_PSC0_BASE		0x01c10000
+#define DA8XX_PLL0_BASE		0x01c11000
+#define DA8XX_TIMER64P0_BASE	0x01c20000
+#define DA8XX_TIMER64P1_BASE	0x01c21000
+#define DA8XX_GPIO_BASE		0x01e26000
+#define DA8XX_PSC1_BASE		0x01e27000
+#define DA8XX_LCD_CNTRL_BASE	0x01e13000
+#define DA8XX_MMCSD0_BASE	0x01c40000
+#define DA8XX_AEMIF_CS2_BASE	0x60000000
+#define DA8XX_AEMIF_CS3_BASE	0x62000000
+#define DA8XX_AEMIF_CTL_BASE	0x68000000
+
+#define PINMUX0			0x00
+#define PINMUX1			0x04
+#define PINMUX2			0x08
+#define PINMUX3			0x0c
+#define PINMUX4			0x10
+#define PINMUX5			0x14
+#define PINMUX6			0x18
+#define PINMUX7			0x1c
+#define PINMUX8			0x20
+#define PINMUX9			0x24
+#define PINMUX10		0x28
+#define PINMUX11		0x2c
+#define PINMUX12		0x30
+#define PINMUX13		0x34
+#define PINMUX14		0x38
+#define PINMUX15		0x3c
+#define PINMUX16		0x40
+#define PINMUX17		0x44
+#define PINMUX18		0x48
+#define PINMUX19		0x4c
+
+struct spi_board_info;
+
+void __init da830_init(void);
+
+int da8xx_register_edma(void);
+int da8xx_register_i2c(int instance, struct davinci_i2c_platform_data *pdata);
+int da8xx_register_watchdog(void);
+int da8xx_register_emac(void);
+#ifdef FB_DAVINCI
+int da8xx_register_lcdc(struct da8xx_lcdc_platform_data *pdata);
+#endif
+int da8xx_register_mmcsd0(struct davinci_mmc_config *config);
+void da8xx_init_spi0(unsigned char *chip_sel, unsigned int num_sel,
+		struct spi_board_info *info, unsigned num_dev);
+void da8xx_init_spi1(unsigned char *chip_sel, unsigned int num_sel,
+		struct spi_board_info *info, unsigned num_dev);
+void da8xx_register_mcasp(int id, struct snd_platform_data *pdata);
+int da8xx_register_rtc(void);
+
+extern struct platform_device da8xx_serial_device;
+extern struct emac_platform_data da8xx_emac_pdata;
+#ifdef FB_DAVINCI
+extern struct da8xx_lcdc_platform_data sharp_lcd035q3dg01_pdata;
+extern struct da8xx_lcdc_platform_data sharp_lk043t1dg01_pdata;
+#endif
+
+extern const short da830_emif25_pins[];
+extern const short da830_spi0_pins[];
+extern const short da830_spi1_pins[];
+extern const short da830_mmc_sd_pins[];
+extern const short da830_uart0_pins[];
+extern const short da830_uart1_pins[];
+extern const short da830_uart2_pins[];
+extern const short da830_usb20_pins[];
+extern const short da830_usb11_pins[];
+extern const short da830_uhpi_pins[];
+extern const short da830_cpgmac_pins[];
+extern const short da830_emif3c_pins[];
+extern const short da830_mcasp0_pins[];
+extern const short da830_mcasp1_pins[];
+extern const short da830_mcasp2_pins[];
+extern const short da830_i2c0_pins[];
+extern const short da830_i2c1_pins[];
+extern const short da830_lcdcntl_pins[];
+extern const short da830_pwm_pins[];
+extern const short da830_ecap0_pins[];
+extern const short da830_ecap1_pins[];
+extern const short da830_ecap2_pins[];
+extern const short da830_eqep0_pins[];
+extern const short da830_eqep1_pins[];
+
+int da8xx_pinmux_setup(const short pins[]);
+
+#endif /* __ASM_ARCH_DAVINCI_DA8XX_H */
diff --git a/arch/arm/mach-davinci/include/mach/debug-macro.S b/arch/arm/mach-davinci/include/mach/debug-macro.S
index e6c0f0d..17ab523 100644
--- a/arch/arm/mach-davinci/include/mach/debug-macro.S
+++ b/arch/arm/mach-davinci/include/mach/debug-macro.S
@@ -9,13 +9,48 @@
  * or implied.
  */
 
+/* Modifications
+ * Jan 2009	Chaithrika U S	Added senduart, busyuart, waituart
+ *				macros, based on debug-8250.S file
+ *				but using 32-bit accesses required for
+ *                              some davinci devices.
+ */
+
+#include <linux/serial_reg.h>
+#define UART_SHIFT	2
+
 		.macro addruart, rx
 		mrc	p15, 0, \rx, c1, c0
 		tst	\rx, #1			@ MMU enabled?
 		moveq	\rx, #0x01000000	@ physical base address
 		movne	\rx, #0xfe000000	@ virtual base
+#if defined(CONFIG_ARCH_DAVINCI_DA8XX) && defined(CONFIG_ARCH_DAVINCI_DMx)
+#error Cannot enable DaVinci and DA8XX platforms concurrently
+#elif defined(CONFIG_MACH_DAVINCI_DA830_EVM) || \
+	defined(CONFIG_MACH_DAVINCI_DA850_EVM)
+		orr	\rx, \rx, #0x00d00000	@ physical base address
+		orr	\rx, \rx, #0x0000d000	@ of UART 2
+#else
 		orr	\rx, \rx, #0x00c20000   @ UART 0
+#endif
+		.endm
+
+		.macro	senduart,rd,rx
+		str	\rd, [\rx, #UART_TX << UART_SHIFT]
+		.endm
+
+		.macro	busyuart,rd,rx
+1002:		ldr	\rd, [\rx, #UART_LSR << UART_SHIFT]
+		and	\rd, \rd, #UART_LSR_TEMT | UART_LSR_THRE
+		teq	\rd, #UART_LSR_TEMT | UART_LSR_THRE
+		bne	1002b
+		.endm
+
+		.macro	waituart,rd,rx
+#ifdef FLOW_CONTROL
+1001:		ldr	\rd, [\rx, #UART_MSR << UART_SHIFT]
+		tst	\rd, #UART_MSR_CTS
+		beq	1001b
+#endif
 		.endm
 
-#define UART_SHIFT	2
-#include <asm/hardware/debug-8250.S>
diff --git a/arch/arm/mach-davinci/include/mach/dma.h b/arch/arm/mach-davinci/include/mach/dma.h
index 8e2f2d0..4e45a9e 100644
--- a/arch/arm/mach-davinci/include/mach/dma.h
+++ b/arch/arm/mach-davinci/include/mach/dma.h
@@ -11,6 +11,4 @@
 #ifndef __ASM_ARCH_DMA_H
 #define __ASM_ARCH_DMA_H
 
-#define MAX_DMA_ADDRESS			0xffffffff
-
 #endif /* __ASM_ARCH_DMA_H */
diff --git a/arch/arm/mach-davinci/include/mach/entry-macro.S b/arch/arm/mach-davinci/include/mach/entry-macro.S
index 039b84f..1886968 100644
--- a/arch/arm/mach-davinci/include/mach/entry-macro.S
+++ b/arch/arm/mach-davinci/include/mach/entry-macro.S
@@ -15,17 +15,36 @@
 		.endm
 
 		.macro  get_irqnr_preamble, base, tmp
-		ldr \base, =IO_ADDRESS(DAVINCI_ARM_INTC_BASE)
+		ldr \base, =davinci_intc_base
+		ldr \base, [\base]
 		.endm
 
 		.macro  arch_ret_to_user, tmp1, tmp2
 		.endm
 
 		.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+#if defined(CONFIG_CP_INTC)
+		ldr \tmp, =davinci_intc_type
+		ldr \tmp, [\tmp]
+		cmp \tmp, #DAVINCI_INTC_TYPE_CP_INTC
+		beq 1001f
+#endif
+#if defined(CONFIG_AINTC)
 		ldr \tmp, [\base, #0x14]
 		mov \tmp, \tmp, lsr #2
 		sub \irqnr, \tmp, #1
 		cmp \tmp, #0
+#endif
+#if defined(CONFIG_CP_INTC)
+1001:		ldr \irqnr, [\base, #0x80] /* get irq number */
+		and \irqnr, \irqnr, #0xff  /* irq is in bits 0-9 */
+		mov \tmp, \irqnr, lsr #3
+		and \tmp, \tmp, #0xfc
+		add \tmp, \tmp, #0x280 /* get the register offset */
+		ldr \irqstat, [\base, \tmp] /* get the intc status */
+		cmp \irqstat, #0x0
+#endif
+1002:
 		.endm
 
 		.macro	irq_prio_table
diff --git a/arch/arm/mach-davinci/include/mach/gpio.h b/arch/arm/mach-davinci/include/mach/gpio.h
index ec151cc..9cbd36e 100644
--- a/arch/arm/mach-davinci/include/mach/gpio.h
+++ b/arch/arm/mach-davinci/include/mach/gpio.h
@@ -14,7 +14,12 @@
 #define	__DAVINCI_GPIO_H
 
 #include <linux/io.h>
-#include <mach/hardware.h>
+#include <asm-generic/gpio.h>
+
+#include <mach/irqs.h>
+#include <mach/common.h>
+
+#define DAVINCI_GPIO_BASE 0x01C67000
 
 /*
  * basic gpio routines
@@ -24,20 +29,21 @@
  * go through boot loaders.
  *
  * the gpio clock will be turned on when gpios are used, and you may also
- * need to pay attention to PINMUX0 and PINMUX1 to be sure those pins are
+ * need to pay attention to PINMUX registers to be sure those pins are
  * used as gpios, not with other peripherals.
  *
- * GPIOs are numbered 0..(DAVINCI_N_GPIO-1).  For documentation, and maybe
- * for later updates, code should write GPIO(N) or:
- *  - GPIOV18(N) for 1.8V pins, N in 0..53; same as GPIO(0)..GPIO(53)
- *  - GPIOV33(N) for 3.3V pins, N in 0..17; same as GPIO(54)..GPIO(70)
+ * On-chip GPIOs are numbered 0..(DAVINCI_N_GPIO-1).  For documentation,
+ * and maybe for later updates, code may write GPIO(N).  These may be
+ * all 1.8V signals, all 3.3V ones, or a mix of the two.  A given chip
+ * may not support all the GPIOs in that range.
  *
- * For GPIO IRQs use gpio_to_irq(GPIO(N)) or gpio_to_irq(GPIOV33(N)) etc
- * for now, that's != GPIO(N)
+ * GPIOs can also be on external chips, numbered after the ones built-in
+ * to the DaVinci chip.  For now, they won't be usable as IRQ sources.
  */
-#define	GPIO(X)		(X)		/* 0 <= X <= 70 */
-#define	GPIOV18(X)	(X)		/* 1.8V i/o; 0 <= X <= 53 */
-#define	GPIOV33(X)	((X)+54)	/* 3.3V i/o; 0 <= X <= 17 */
+#define	GPIO(X)		(X)		/* 0 <= X <= (DAVINCI_N_GPIO - 1) */
+
+/* Convert GPIO signal to GPIO pin number */
+#define GPIO_TO_PIN(bank, gpio)	(16 * (bank) + (gpio))
 
 struct gpio_controller {
 	u32	dir;
@@ -65,13 +71,18 @@ static inline struct gpio_controller *__iomem
 __gpio_to_controller(unsigned gpio)
 {
 	void *__iomem ptr;
-
-	if (gpio < 32)
-		ptr = (void *__iomem)IO_ADDRESS(DAVINCI_GPIO_BASE + 0x10);
-	else if (gpio < 64)
-		ptr = (void *__iomem)IO_ADDRESS(DAVINCI_GPIO_BASE + 0x38);
-	else if (gpio < DAVINCI_N_GPIO)
-		ptr = (void *__iomem)IO_ADDRESS(DAVINCI_GPIO_BASE + 0x60);
+	void __iomem *base = davinci_soc_info.gpio_base;
+
+	if (gpio < 32 * 1)
+		ptr = base + 0x10;
+	else if (gpio < 32 * 2)
+		ptr = base + 0x38;
+	else if (gpio < 32 * 3)
+		ptr = base + 0x60;
+	else if (gpio < 32 * 4)
+		ptr = base + 0x88;
+	else if (gpio < 32 * 5)
+		ptr = base + 0xb0;
 	else
 		ptr = NULL;
 	return ptr;
@@ -83,25 +94,17 @@ static inline u32 __gpio_mask(unsigned gpio)
 }
 
 /* The get/set/clear functions will inline when called with constant
- * parameters, for low-overhead bitbanging.  Illegal constant parameters
- * cause link-time errors.
+ * parameters referencing built-in GPIOs, for low-overhead bitbanging.
  *
- * Otherwise, calls with variable parameters use outlined functions.
+ * Otherwise, calls with variable parameters or referencing external
+ * GPIOs (e.g. on GPIO expander chips) use outlined functions.
  */
-extern int __error_inval_gpio(void);
-
-extern void __gpio_set(unsigned gpio, int value);
-extern int __gpio_get(unsigned gpio);
-
 static inline void gpio_set_value(unsigned gpio, int value)
 {
-	if (__builtin_constant_p(value)) {
+	if (__builtin_constant_p(value) && gpio < DAVINCI_N_GPIO) {
 		struct gpio_controller	*__iomem g;
 		u32			mask;
 
-		if (gpio >= DAVINCI_N_GPIO)
-			__error_inval_gpio();
-
 		g = __gpio_to_controller(gpio);
 		mask = __gpio_mask(gpio);
 		if (value)
@@ -111,44 +114,40 @@ static inline void gpio_set_value(unsigned gpio, int value)
 		return;
 	}
 
-	__gpio_set(gpio, value);
+	__gpio_set_value(gpio, value);
 }
 
 /* Returns zero or nonzero; works for gpios configured as inputs OR
- * as outputs.
+ * as outputs, at least for built-in GPIOs.
  *
- * NOTE: changes in reported values are synchronized to the GPIO clock.
- * This is most easily seen after calling gpio_set_value() and then immediatly
- * gpio_get_value(), where the gpio_get_value() would return the old value
- * until the GPIO clock ticks and the new value gets latched.
+ * NOTE: for built-in GPIOs, changes in reported values are synchronized
+ * to the GPIO clock.  This is easily seen after calling gpio_set_value()
+ * and then immediately gpio_get_value(), where the gpio_get_value() will
+ * return the old value until the GPIO clock ticks and the new value gets
+ * latched.
  */
-
 static inline int gpio_get_value(unsigned gpio)
 {
-	struct gpio_controller *__iomem g;
-
-	if (!__builtin_constant_p(gpio))
-		return __gpio_get(gpio);
+	struct gpio_controller	*__iomem g;
 
-	if (gpio >= DAVINCI_N_GPIO)
-		return __error_inval_gpio();
+	if (!__builtin_constant_p(gpio) || gpio >= DAVINCI_N_GPIO)
+		return __gpio_get_value(gpio);
 
 	g = __gpio_to_controller(gpio);
-	return !!(__gpio_mask(gpio) & __raw_readl(&g->in_data));
+	return __gpio_mask(gpio) & __raw_readl(&g->in_data);
 }
 
-/* powerup default direction is IN */
-extern int gpio_direction_input(unsigned gpio);
-extern int gpio_direction_output(unsigned gpio, int value);
-
-#include <asm-generic/gpio.h>	/* cansleep wrappers */
-
-extern int gpio_request(unsigned gpio, const char *tag);
-extern void gpio_free(unsigned gpio);
+static inline int gpio_cansleep(unsigned gpio)
+{
+	if (__builtin_constant_p(gpio) && gpio < DAVINCI_N_GPIO)
+		return 0;
+	else
+		return __gpio_cansleep(gpio);
+}
 
 static inline int gpio_to_irq(unsigned gpio)
 {
-	return DAVINCI_N_AINTC_IRQ + gpio;
+	return __gpio_to_irq(gpio);
 }
 
 static inline int irq_to_gpio(unsigned irq)
diff --git a/arch/arm/mach-davinci/include/mach/hardware.h b/arch/arm/mach-davinci/include/mach/hardware.h
index a2e8969..41c8938 100644
--- a/arch/arm/mach-davinci/include/mach/hardware.h
+++ b/arch/arm/mach-davinci/include/mach/hardware.h
@@ -1,9 +1,9 @@
 /*
- * Common hardware definitions
+ * Hardware definitions common to all DaVinci family processors
  *
- * Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
+ * Author: Kevin Hilman, Deep Root Systems, LLC
  *
- * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * 2007 (c) Deep Root Systems, LLC. This file is licensed under
  * the terms of the GNU General Public License version 2. This program
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
@@ -12,41 +12,33 @@
 #define __ASM_ARCH_HARDWARE_H
 
 /*
- * Base register addresses
+ * Before you add anything to ths file:
+ *
+ * This header is for defines common to ALL DaVinci family chips.
+ * Anything that is chip specific should go in <chipname>.h,
+ * and the chip/board init code should then explicitly include
+ * <chipname>.h
+ */
+#define DAVINCI_SYSTEM_MODULE_BASE        0x01C40000
+
+/* System control register offsets */
+#define DM64XX_VDD3P3V_PWDN	0x48
+
+/*
+ * I/O mapping
  */
-#define DAVINCI_DMA_3PCC_BASE			(0x01C00000)
-#define DAVINCI_DMA_3PTC0_BASE			(0x01C10000)
-#define DAVINCI_DMA_3PTC1_BASE			(0x01C10400)
-#define DAVINCI_I2C_BASE			(0x01C21000)
-#define DAVINCI_PWM0_BASE			(0x01C22000)
-#define DAVINCI_PWM1_BASE			(0x01C22400)
-#define DAVINCI_PWM2_BASE			(0x01C22800)
-#define DAVINCI_SYSTEM_MODULE_BASE		(0x01C40000)
-#define DAVINCI_PLL_CNTRL0_BASE			(0x01C40800)
-#define DAVINCI_PLL_CNTRL1_BASE			(0x01C40C00)
-#define DAVINCI_PWR_SLEEP_CNTRL_BASE		(0x01C41000)
-#define DAVINCI_SYSTEM_DFT_BASE			(0x01C42000)
-#define DAVINCI_IEEE1394_BASE			(0x01C60000)
-#define DAVINCI_USB_OTG_BASE			(0x01C64000)
-#define DAVINCI_CFC_ATA_BASE			(0x01C66000)
-#define DAVINCI_SPI_BASE			(0x01C66800)
-#define DAVINCI_GPIO_BASE			(0x01C67000)
-#define DAVINCI_UHPI_BASE			(0x01C67800)
-#define DAVINCI_VPSS_REGS_BASE			(0x01C70000)
-#define DAVINCI_EMAC_CNTRL_REGS_BASE		(0x01C80000)
-#define DAVINCI_EMAC_WRAPPER_CNTRL_REGS_BASE	(0x01C81000)
-#define DAVINCI_EMAC_WRAPPER_RAM_BASE		(0x01C82000)
-#define DAVINCI_MDIO_CNTRL_REGS_BASE		(0x01C84000)
-#define DAVINCI_IMCOP_BASE			(0x01CC0000)
-#define DAVINCI_ASYNC_EMIF_CNTRL_BASE		(0x01E00000)
-#define DAVINCI_VLYNQ_BASE			(0x01E01000)
-#define DAVINCI_MCBSP_BASE			(0x01E02000)
-#define DAVINCI_MMC_SD_BASE			(0x01E10000)
-#define DAVINCI_MS_BASE				(0x01E20000)
-#define DAVINCI_ASYNC_EMIF_DATA_CE0_BASE	(0x02000000)
-#define DAVINCI_ASYNC_EMIF_DATA_CE1_BASE	(0x04000000)
-#define DAVINCI_ASYNC_EMIF_DATA_CE2_BASE	(0x06000000)
-#define DAVINCI_ASYNC_EMIF_DATA_CE3_BASE	(0x08000000)
-#define DAVINCI_VLYNQ_REMOTE_BASE		(0x0C000000)
+#define IO_PHYS				0x01c00000
+#define IO_OFFSET			0xfd000000 /* Virtual IO = 0xfec00000 */
+#define IO_SIZE				0x00400000
+#define IO_VIRT				(IO_PHYS + IO_OFFSET)
+#define io_v2p(va)			((va) - IO_OFFSET)
+#define __IO_ADDRESS(x)			((x) + IO_OFFSET)
+#define IO_ADDRESS(pa)			IOMEM(__IO_ADDRESS(pa))
+
+#ifdef __ASSEMBLER__
+#define IOMEM(x)                	x
+#else
+#define IOMEM(x)                	((void __force __iomem *)(x))
+#endif
 
 #endif /* __ASM_ARCH_HARDWARE_H */
diff --git a/arch/arm/mach-davinci/include/mach/io.h b/arch/arm/mach-davinci/include/mach/io.h
index e7accb9..9d63968 100644
--- a/arch/arm/mach-davinci/include/mach/io.h
+++ b/arch/arm/mach-davinci/include/mach/io.h
@@ -14,66 +14,19 @@
 #define IO_SPACE_LIMIT 0xffffffff
 
 /*
- * ----------------------------------------------------------------------------
- * I/O mapping
- * ----------------------------------------------------------------------------
- */
-#define IO_PHYS		0x01c00000
-#define IO_OFFSET	0xfd000000 /* Virtual IO = 0xfec00000 */
-#define IO_SIZE		0x00400000
-#define IO_VIRT		(IO_PHYS + IO_OFFSET)
-#define io_p2v(pa)	((pa) + IO_OFFSET)
-#define io_v2p(va)	((va) - IO_OFFSET)
-#define IO_ADDRESS(x)	io_p2v(x)
-
-/*
  * We don't actually have real ISA nor PCI buses, but there is so many
  * drivers out there that might just work if we fake them...
  */
-#define PCIO_BASE               0
-#define __io(a)			((void __iomem *)(PCIO_BASE + (a)))
+#define __io(a)			((void __iomem *)(a))	
 #define __mem_pci(a)		(a)
 #define __mem_isa(a)		(a)
 
 #ifndef __ASSEMBLER__
+#define __arch_ioremap(p, s, t)	davinci_ioremap(p, s, t)
+#define __arch_iounmap(v)	davinci_iounmap(v)
 
-/*
- * Functions to access the DaVinci IO region
- *
- * NOTE: - Use davinci_read/write[bwl] for physical register addresses
- *	 - Use __raw_read/write[bwl]() for virtual register addresses
- *	 - Use IO_ADDRESS(phys_addr) to convert registers to virtual addresses
- *	 - DO NOT use hardcoded virtual addresses to allow changing the
- *	   IO address space again if needed
- */
-#define davinci_readb(a)	(*(volatile unsigned char  *)IO_ADDRESS(a))
-#define davinci_readw(a)	(*(volatile unsigned short *)IO_ADDRESS(a))
-#define davinci_readl(a)	(*(volatile unsigned int   *)IO_ADDRESS(a))
-
-#define davinci_writeb(v,a)	(*(volatile unsigned char  *)IO_ADDRESS(a) = (v))
-#define davinci_writew(v,a)	(*(volatile unsigned short *)IO_ADDRESS(a) = (v))
-#define davinci_writel(v,a)	(*(volatile unsigned int   *)IO_ADDRESS(a) = (v))
-
-/* 16 bit uses LDRH/STRH, base +/- offset_8 */
-typedef struct { volatile u16 offset[256]; } __regbase16;
-#define __REGV16(vaddr)		((__regbase16 *)((vaddr)&~0xff)) \
-					->offset[((vaddr)&0xff)>>1]
-#define __REG16(paddr)          __REGV16(io_p2v(paddr))
-
-/* 8/32 bit uses LDR/STR, base +/- offset_12 */
-typedef struct { volatile u8 offset[4096]; } __regbase8;
-#define __REGV8(vaddr)		((__regbase8  *)((vaddr)&~4095)) \
-					->offset[((vaddr)&4095)>>0]
-#define __REG8(paddr)		__REGV8(io_p2v(paddr))
-
-typedef struct { volatile u32 offset[4096]; } __regbase32;
-#define __REGV32(vaddr)		((__regbase32 *)((vaddr)&~4095)) \
-					->offset[((vaddr)&4095)>>2]
-
-#define __REG(paddr)		__REGV32(io_p2v(paddr))
-#else
-
-#define __REG(x)	(*((volatile unsigned long *)io_p2v(x)))
-
-#endif /* __ASSEMBLER__ */
+void __iomem *davinci_ioremap(unsigned long phys, size_t size,
+			      unsigned int type);
+void davinci_iounmap(volatile void __iomem *addr);
+#endif
 #endif /* __ASM_ARCH_IO_H */
diff --git a/arch/arm/mach-davinci/include/mach/irqs.h b/arch/arm/mach-davinci/include/mach/irqs.h
index f4c5ca6..f3e53ae 100644
--- a/arch/arm/mach-davinci/include/mach/irqs.h
+++ b/arch/arm/mach-davinci/include/mach/irqs.h
@@ -30,6 +30,9 @@
 /* Base address */
 #define DAVINCI_ARM_INTC_BASE 0x01C48000
 
+#define DAVINCI_INTC_TYPE_AINTC		0
+#define DAVINCI_INTC_TYPE_CP_INTC	1
+
 /* Interrupt lines */
 #define IRQ_VDINT0       0
 #define IRQ_VDINT1       1
@@ -96,10 +99,112 @@
 #define IRQ_EMUINT       63
 
 #define DAVINCI_N_AINTC_IRQ	64
-#define DAVINCI_N_GPIO		71
-
-#define NR_IRQS			(DAVINCI_N_AINTC_IRQ + DAVINCI_N_GPIO)
 
 #define ARCH_TIMER_IRQ IRQ_TINT1_TINT34
 
+/* DA8XX interrupts */
+#define IRQ_DA8XX_COMMTX		0
+#define IRQ_DA8XX_COMMRX		1
+#define IRQ_DA8XX_NINT			2
+#define IRQ_DA8XX_EVTOUT0		3
+#define IRQ_DA8XX_EVTOUT1		4
+#define IRQ_DA8XX_EVTOUT2		5
+#define IRQ_DA8XX_EVTOUT3		6
+#define IRQ_DA8XX_EVTOUT4		7
+#define IRQ_DA8XX_EVTOUT5		8
+#define IRQ_DA8XX_EVTOUT6		9
+#define IRQ_DA8XX_EVTOUT7		10
+#define IRQ_DA8XX_CCINT0		11
+#define IRQ_DA8XX_CCERRINT		12
+#define IRQ_DA8XX_TCERRINT0		13
+#define IRQ_DA8XX_AEMIFINT		14
+#define IRQ_DA8XX_I2CINT0		15
+#define IRQ_DA8XX_MMCSDINT0		16
+#define IRQ_DA8XX_MMCSDINT1		17
+#define IRQ_DA8XX_ALLINT0		18
+#define IRQ_DA8XX_RTC			19
+#define IRQ_DA8XX_SPINT0		20
+#define IRQ_DA8XX_TINT12_0		21
+#define IRQ_DA8XX_TINT34_0		22
+#define IRQ_DA8XX_TINT12_1		23
+#define IRQ_DA8XX_TINT34_1		24
+#define IRQ_DA8XX_UARTINT0		25
+#define IRQ_DA8XX_KEYMGRINT		26
+#define IRQ_DA8XX_SECINT		26
+#define IRQ_DA8XX_SECKEYERR		26
+#define IRQ_DA8XX_CHIPINT0		28
+#define IRQ_DA8XX_CHIPINT1		29
+#define IRQ_DA8XX_CHIPINT2		30
+#define IRQ_DA8XX_CHIPINT3		31
+#define IRQ_DA8XX_TCERRINT1		32
+#define IRQ_DA8XX_C0_RX_THRESH_PULSE	33
+#define IRQ_DA8XX_C0_RX_PULSE		34
+#define IRQ_DA8XX_C0_TX_PULSE		35
+#define IRQ_DA8XX_C0_MISC_PULSE		36
+#define IRQ_DA8XX_C1_RX_THRESH_PULSE	37
+#define IRQ_DA8XX_C1_RX_PULSE		38
+#define IRQ_DA8XX_C1_TX_PULSE		39
+#define IRQ_DA8XX_C1_MISC_PULSE		40
+#define IRQ_DA8XX_MEMERR		41
+#define IRQ_DA8XX_GPIO0			42
+#define IRQ_DA8XX_GPIO1			43
+#define IRQ_DA8XX_GPIO2			44
+#define IRQ_DA8XX_GPIO3			45
+#define IRQ_DA8XX_GPIO4			46
+#define IRQ_DA8XX_GPIO5			47
+#define IRQ_DA8XX_GPIO6			48
+#define IRQ_DA8XX_GPIO7			49
+#define IRQ_DA8XX_GPIO8			50
+#define IRQ_DA8XX_I2CINT1		51
+#define IRQ_DA8XX_LCDINT		52
+#define IRQ_DA8XX_UARTINT1		53
+#define IRQ_DA8XX_MCASPINT		54
+#define IRQ_DA8XX_ALLINT1		55
+#define IRQ_DA8XX_SPINT1		56
+#define IRQ_DA8XX_UHPI_INT1		57
+#define IRQ_DA8XX_USB_INT		58
+#define IRQ_DA8XX_IRQN			59
+#define IRQ_DA8XX_RWAKEUP		60
+#define IRQ_DA8XX_UARTINT2		61
+#define IRQ_DA8XX_DFTSSINT		62
+#define IRQ_DA8XX_EHRPWM0		63
+#define IRQ_DA8XX_EHRPWM0TZ		64
+#define IRQ_DA8XX_EHRPWM1		65
+#define IRQ_DA8XX_EHRPWM1TZ		66
+#define IRQ_DA8XX_ECAP0			69
+#define IRQ_DA8XX_ECAP1			70
+#define IRQ_DA8XX_ECAP2			71
+#define IRQ_DA8XX_ARMCLKSTOPREQ		90
+
+/* DA830 specific interrupts */
+#define IRQ_DA830_MPUERR		27
+#define IRQ_DA830_IOPUERR		27
+#define IRQ_DA830_BOOTCFGERR		27
+#define IRQ_DA830_EHRPWM2		67
+#define IRQ_DA830_EHRPWM2TZ		68
+#define IRQ_DA830_EQEP0			72
+#define IRQ_DA830_EQEP1			73
+#define IRQ_DA830_T12CMPINT0_0		74
+#define IRQ_DA830_T12CMPINT1_0		75
+#define IRQ_DA830_T12CMPINT2_0		76
+#define IRQ_DA830_T12CMPINT3_0		77
+#define IRQ_DA830_T12CMPINT4_0		78
+#define IRQ_DA830_T12CMPINT5_0		79
+#define IRQ_DA830_T12CMPINT6_0		80
+#define IRQ_DA830_T12CMPINT7_0		81
+#define IRQ_DA830_T12CMPINT0_1		82
+#define IRQ_DA830_T12CMPINT1_1		83
+#define IRQ_DA830_T12CMPINT2_1		84
+#define IRQ_DA830_T12CMPINT3_1		85
+#define IRQ_DA830_T12CMPINT4_1		86
+#define IRQ_DA830_T12CMPINT5_1		87
+#define IRQ_DA830_T12CMPINT6_1		88
+#define IRQ_DA830_T12CMPINT7_1		89
+
+#define DA830_N_CP_INTC_IRQ		96
+
+#define DAVINCI_N_GPIO			144
+/* da830 currently has the most irqs so use DA830_N_CP_INTC_IRQ */
+#define NR_IRQS				(DA830_N_CP_INTC_IRQ + DAVINCI_N_GPIO)
+
 #endif /* __ASM_ARCH_IRQS_H */
diff --git a/arch/arm/mach-davinci/include/mach/memory.h b/arch/arm/mach-davinci/include/mach/memory.h
index dd1625c..392f9e1 100644
--- a/arch/arm/mach-davinci/include/mach/memory.h
+++ b/arch/arm/mach-davinci/include/mach/memory.h
@@ -20,15 +20,21 @@
 /**************************************************************************
  * Definitions
  **************************************************************************/
-#define DAVINCI_DDR_BASE    0x80000000
-#define DAVINCI_IRAM_BASE   0x00008000 /* ARM Internal RAM */
+#define DAVINCI_DDR_BASE	0x80000000
+#define DA8XX_DDR_BASE		0xc0000000
 
+#if defined(CONFIG_ARCH_DAVINCI_DA8XX) && defined(CONFIG_ARCH_DAVINCI_DMx)
+#error Cannot enable DaVinci and DA8XX platforms concurrently
+#elif defined(CONFIG_ARCH_DAVINCI_DA8XX)
+#define PHYS_OFFSET DA8XX_DDR_BASE
+#else
 #define PHYS_OFFSET DAVINCI_DDR_BASE
+#endif
 
 /*
  * Increase size of DMA-consistent memory region
  */
-#define CONSISTENT_DMA_SIZE (14<<20)
+#define CONSISTENT_DMA_SIZE (10<<20)
 
 #ifndef __ASSEMBLY__
 /*
@@ -52,13 +58,14 @@ __arch_adjust_zones(int node, unsigned long *size, unsigned long *holes)
         if ((meminfo.bank[0].size >> 20) > 128) __arch_adjust_zones(node, zone_size, holes)
 
 #define ISA_DMA_THRESHOLD	(PHYS_OFFSET + (128<<20) - 1)
+#define MAX_DMA_ADDRESS		(PAGE_OFFSET + (128<<20))
 
 #endif
 
 /*
  * Bus address is physical address
  */
-#define __virt_to_bus(x)	__virt_to_phys(x)
-#define __bus_to_virt(x)	__phys_to_virt(x)
+#define __virt_to_bus(x)    __virt_to_phys(x)
+#define __bus_to_virt(x)    __phys_to_virt(x)
 
 #endif /* __ASM_ARCH_MEMORY_H */
diff --git a/arch/arm/mach-davinci/include/mach/mux.h b/arch/arm/mach-davinci/include/mach/mux.h
index c24b678..941da38 100644
--- a/arch/arm/mach-davinci/include/mach/mux.h
+++ b/arch/arm/mach-davinci/include/mach/mux.h
@@ -1,55 +1,444 @@
 /*
- * DaVinci pin multiplexing defines
+ * Table of the DAVINCI register configurations for the PINMUX combinations
  *
  * Author: Vladimir Barinov, MontaVista Software, Inc. <source@mvista.com>
  *
+ * Based on linux/include/asm-arm/arch-omap/mux.h:
+ * Copyright (C) 2003 - 2005 Nokia Corporation
+ *
+ * Written by Tony Lindgren
+ *
  * 2007 (c) MontaVista Software, Inc. This file is licensed under
  * the terms of the GNU General Public License version 2. This program
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
+ *
+ * Copyright (C) 2008 Texas Instruments.
  */
-#ifndef __ASM_ARCH_MUX_H
-#define __ASM_ARCH_MUX_H
 
-#define DAVINCI_MUX_AEAW0	0
-#define DAVINCI_MUX_AEAW1	1
-#define DAVINCI_MUX_AEAW2	2
-#define DAVINCI_MUX_AEAW3	3
-#define DAVINCI_MUX_AEAW4	4
-#define DAVINCI_MUX_AECS4	10
-#define DAVINCI_MUX_AECS5	11
-#define DAVINCI_MUX_VLYNQWD0	12
-#define DAVINCI_MUX_VLYNQWD1	13
-#define DAVINCI_MUX_VLSCREN	14
-#define DAVINCI_MUX_VLYNQEN	15
-#define DAVINCI_MUX_HDIREN	16
-#define DAVINCI_MUX_ATAEN	17
-#define DAVINCI_MUX_RGB666	22
-#define DAVINCI_MUX_RGB888	23
-#define DAVINCI_MUX_LOEEN	24
-#define DAVINCI_MUX_LFLDEN	25
-#define DAVINCI_MUX_CWEN	26
-#define DAVINCI_MUX_CFLDEN	27
-#define DAVINCI_MUX_HPIEN	29
-#define DAVINCI_MUX_1394EN	30
-#define DAVINCI_MUX_EMACEN	31
+#ifndef __INC_MACH_MUX_H
+#define __INC_MACH_MUX_H
+
+struct mux_config {
+	const char *name;
+	const char *mux_reg_name;
+	const unsigned char mux_reg;
+	const unsigned char mask_offset;
+	const unsigned char mask;
+	const unsigned char mode;
+	bool debug;
+};
 
-#define DAVINCI_MUX_LEVEL2	32
-#define DAVINCI_MUX_UART0	(DAVINCI_MUX_LEVEL2 + 0)
-#define DAVINCI_MUX_UART1	(DAVINCI_MUX_LEVEL2 + 1)
-#define DAVINCI_MUX_UART2	(DAVINCI_MUX_LEVEL2 + 2)
-#define DAVINCI_MUX_U2FLO	(DAVINCI_MUX_LEVEL2 + 3)
-#define DAVINCI_MUX_PWM0	(DAVINCI_MUX_LEVEL2 + 4)
-#define DAVINCI_MUX_PWM1	(DAVINCI_MUX_LEVEL2 + 5)
-#define DAVINCI_MUX_PWM2	(DAVINCI_MUX_LEVEL2 + 6)
-#define DAVINCI_MUX_I2C		(DAVINCI_MUX_LEVEL2 + 7)
-#define DAVINCI_MUX_SPI		(DAVINCI_MUX_LEVEL2 + 8)
-#define DAVINCI_MUX_MSTK	(DAVINCI_MUX_LEVEL2 + 9)
-#define DAVINCI_MUX_ASP		(DAVINCI_MUX_LEVEL2 + 10)
-#define DAVINCI_MUX_CLK0	(DAVINCI_MUX_LEVEL2 + 16)
-#define DAVINCI_MUX_CLK1	(DAVINCI_MUX_LEVEL2 + 17)
-#define DAVINCI_MUX_TIMIN	(DAVINCI_MUX_LEVEL2 + 18)
+enum da830_index {
+	DA830_GPIO7_14,
+	DA830_RTCK,
+	DA830_GPIO7_15,
+	DA830_EMU_0,
+	DA830_EMB_SDCKE,
+	DA830_EMB_CLK_GLUE,
+	DA830_EMB_CLK,
+	DA830_NEMB_CS_0,
+	DA830_NEMB_CAS,
+	DA830_NEMB_RAS,
+	DA830_NEMB_WE,
+	DA830_EMB_BA_1,
+	DA830_EMB_BA_0,
+	DA830_EMB_A_0,
+	DA830_EMB_A_1,
+	DA830_EMB_A_2,
+	DA830_EMB_A_3,
+	DA830_EMB_A_4,
+	DA830_EMB_A_5,
+	DA830_GPIO7_0,
+	DA830_GPIO7_1,
+	DA830_GPIO7_2,
+	DA830_GPIO7_3,
+	DA830_GPIO7_4,
+	DA830_GPIO7_5,
+	DA830_GPIO7_6,
+	DA830_GPIO7_7,
+	DA830_EMB_A_6,
+	DA830_EMB_A_7,
+	DA830_EMB_A_8,
+	DA830_EMB_A_9,
+	DA830_EMB_A_10,
+	DA830_EMB_A_11,
+	DA830_EMB_A_12,
+	DA830_EMB_D_31,
+	DA830_GPIO7_8,
+	DA830_GPIO7_9,
+	DA830_GPIO7_10,
+	DA830_GPIO7_11,
+	DA830_GPIO7_12,
+	DA830_GPIO7_13,
+	DA830_GPIO3_13,
+	DA830_EMB_D_30,
+	DA830_EMB_D_29,
+	DA830_EMB_D_28,
+	DA830_EMB_D_27,
+	DA830_EMB_D_26,
+	DA830_EMB_D_25,
+	DA830_EMB_D_24,
+	DA830_EMB_D_23,
+	DA830_EMB_D_22,
+	DA830_EMB_D_21,
+	DA830_EMB_D_20,
+	DA830_EMB_D_19,
+	DA830_EMB_D_18,
+	DA830_EMB_D_17,
+	DA830_EMB_D_16,
+	DA830_NEMB_WE_DQM_3,
+	DA830_NEMB_WE_DQM_2,
+	DA830_EMB_D_0,
+	DA830_EMB_D_1,
+	DA830_EMB_D_2,
+	DA830_EMB_D_3,
+	DA830_EMB_D_4,
+	DA830_EMB_D_5,
+	DA830_EMB_D_6,
+	DA830_GPIO6_0,
+	DA830_GPIO6_1,
+	DA830_GPIO6_2,
+	DA830_GPIO6_3,
+	DA830_GPIO6_4,
+	DA830_GPIO6_5,
+	DA830_GPIO6_6,
+	DA830_EMB_D_7,
+	DA830_EMB_D_8,
+	DA830_EMB_D_9,
+	DA830_EMB_D_10,
+	DA830_EMB_D_11,
+	DA830_EMB_D_12,
+	DA830_EMB_D_13,
+	DA830_EMB_D_14,
+	DA830_GPIO6_7,
+	DA830_GPIO6_8,
+	DA830_GPIO6_9,
+	DA830_GPIO6_10,
+	DA830_GPIO6_11,
+	DA830_GPIO6_12,
+	DA830_GPIO6_13,
+	DA830_GPIO6_14,
+	DA830_EMB_D_15,
+	DA830_NEMB_WE_DQM_1,
+	DA830_NEMB_WE_DQM_0,
+	DA830_SPI0_SOMI_0,
+	DA830_SPI0_SIMO_0,
+	DA830_SPI0_CLK,
+	DA830_NSPI0_ENA,
+	DA830_NSPI0_SCS_0,
+	DA830_EQEP0I,
+	DA830_EQEP0S,
+	DA830_EQEP1I,
+	DA830_NUART0_CTS,
+	DA830_NUART0_RTS,
+	DA830_EQEP0A,
+	DA830_EQEP0B,
+	DA830_GPIO6_15,
+	DA830_GPIO5_14,
+	DA830_GPIO5_15,
+	DA830_GPIO5_0,
+	DA830_GPIO5_1,
+	DA830_GPIO5_2,
+	DA830_GPIO5_3,
+	DA830_GPIO5_4,
+	DA830_SPI1_SOMI_0,
+	DA830_SPI1_SIMO_0,
+	DA830_SPI1_CLK,
+	DA830_UART0_RXD,
+	DA830_UART0_TXD,
+	DA830_AXR1_10,
+	DA830_AXR1_11,
+	DA830_NSPI1_ENA,
+	DA830_I2C1_SCL,
+	DA830_I2C1_SDA,
+	DA830_EQEP1S,
+	DA830_I2C0_SDA,
+	DA830_I2C0_SCL,
+	DA830_UART2_RXD,
+	DA830_TM64P0_IN12,
+	DA830_TM64P0_OUT12,
+	DA830_GPIO5_5,
+	DA830_GPIO5_6,
+	DA830_GPIO5_7,
+	DA830_GPIO5_8,
+	DA830_GPIO5_9,
+	DA830_GPIO5_10,
+	DA830_GPIO5_11,
+	DA830_GPIO5_12,
+	DA830_NSPI1_SCS_0,
+	DA830_USB0_DRVVBUS,
+	DA830_AHCLKX0,
+	DA830_ACLKX0,
+	DA830_AFSX0,
+	DA830_AHCLKR0,
+	DA830_ACLKR0,
+	DA830_AFSR0,
+	DA830_UART2_TXD,
+	DA830_AHCLKX2,
+	DA830_ECAP0_APWM0,
+	DA830_RMII_MHZ_50_CLK,
+	DA830_ECAP1_APWM1,
+	DA830_USB_REFCLKIN,
+	DA830_GPIO5_13,
+	DA830_GPIO4_15,
+	DA830_GPIO2_11,
+	DA830_GPIO2_12,
+	DA830_GPIO2_13,
+	DA830_GPIO2_14,
+	DA830_GPIO2_15,
+	DA830_GPIO3_12,
+	DA830_AMUTE0,
+	DA830_AXR0_0,
+	DA830_AXR0_1,
+	DA830_AXR0_2,
+	DA830_AXR0_3,
+	DA830_AXR0_4,
+	DA830_AXR0_5,
+	DA830_AXR0_6,
+	DA830_RMII_TXD_0,
+	DA830_RMII_TXD_1,
+	DA830_RMII_TXEN,
+	DA830_RMII_CRS_DV,
+	DA830_RMII_RXD_0,
+	DA830_RMII_RXD_1,
+	DA830_RMII_RXER,
+	DA830_AFSR2,
+	DA830_ACLKX2,
+	DA830_AXR2_3,
+	DA830_AXR2_2,
+	DA830_AXR2_1,
+	DA830_AFSX2,
+	DA830_ACLKR2,
+	DA830_NRESETOUT,
+	DA830_GPIO3_0,
+	DA830_GPIO3_1,
+	DA830_GPIO3_2,
+	DA830_GPIO3_3,
+	DA830_GPIO3_4,
+	DA830_GPIO3_5,
+	DA830_GPIO3_6,
+	DA830_AXR0_7,
+	DA830_AXR0_8,
+	DA830_UART1_RXD,
+	DA830_UART1_TXD,
+	DA830_AXR0_11,
+	DA830_AHCLKX1,
+	DA830_ACLKX1,
+	DA830_AFSX1,
+	DA830_MDIO_CLK,
+	DA830_MDIO_D,
+	DA830_AXR0_9,
+	DA830_AXR0_10,
+	DA830_EPWM0B,
+	DA830_EPWM0A,
+	DA830_EPWMSYNCI,
+	DA830_AXR2_0,
+	DA830_EPWMSYNC0,
+	DA830_GPIO3_7,
+	DA830_GPIO3_8,
+	DA830_GPIO3_9,
+	DA830_GPIO3_10,
+	DA830_GPIO3_11,
+	DA830_GPIO3_14,
+	DA830_GPIO3_15,
+	DA830_GPIO4_10,
+	DA830_AHCLKR1,
+	DA830_ACLKR1,
+	DA830_AFSR1,
+	DA830_AMUTE1,
+	DA830_AXR1_0,
+	DA830_AXR1_1,
+	DA830_AXR1_2,
+	DA830_AXR1_3,
+	DA830_ECAP2_APWM2,
+	DA830_EHRPWMGLUETZ,
+	DA830_EQEP1A,
+	DA830_GPIO4_11,
+	DA830_GPIO4_12,
+	DA830_GPIO4_13,
+	DA830_GPIO4_14,
+	DA830_GPIO4_0,
+	DA830_GPIO4_1,
+	DA830_GPIO4_2,
+	DA830_GPIO4_3,
+	DA830_AXR1_4,
+	DA830_AXR1_5,
+	DA830_AXR1_6,
+	DA830_AXR1_7,
+	DA830_AXR1_8,
+	DA830_AXR1_9,
+	DA830_EMA_D_0,
+	DA830_EMA_D_1,
+	DA830_EQEP1B,
+	DA830_EPWM2B,
+	DA830_EPWM2A,
+	DA830_EPWM1B,
+	DA830_EPWM1A,
+	DA830_MMCSD_DAT_0,
+	DA830_MMCSD_DAT_1,
+	DA830_UHPI_HD_0,
+	DA830_UHPI_HD_1,
+	DA830_GPIO4_4,
+	DA830_GPIO4_5,
+	DA830_GPIO4_6,
+	DA830_GPIO4_7,
+	DA830_GPIO4_8,
+	DA830_GPIO4_9,
+	DA830_GPIO0_0,
+	DA830_GPIO0_1,
+	DA830_EMA_D_2,
+	DA830_EMA_D_3,
+	DA830_EMA_D_4,
+	DA830_EMA_D_5,
+	DA830_EMA_D_6,
+	DA830_EMA_D_7,
+	DA830_EMA_D_8,
+	DA830_EMA_D_9,
+	DA830_MMCSD_DAT_2,
+	DA830_MMCSD_DAT_3,
+	DA830_MMCSD_DAT_4,
+	DA830_MMCSD_DAT_5,
+	DA830_MMCSD_DAT_6,
+	DA830_MMCSD_DAT_7,
+	DA830_UHPI_HD_8,
+	DA830_UHPI_HD_9,
+	DA830_UHPI_HD_2,
+	DA830_UHPI_HD_3,
+	DA830_UHPI_HD_4,
+	DA830_UHPI_HD_5,
+	DA830_UHPI_HD_6,
+	DA830_UHPI_HD_7,
+	DA830_LCD_D_8,
+	DA830_LCD_D_9,
+	DA830_GPIO0_2,
+	DA830_GPIO0_3,
+	DA830_GPIO0_4,
+	DA830_GPIO0_5,
+	DA830_GPIO0_6,
+	DA830_GPIO0_7,
+	DA830_GPIO0_8,
+	DA830_GPIO0_9,
+	DA830_EMA_D_10,
+	DA830_EMA_D_11,
+	DA830_EMA_D_12,
+	DA830_EMA_D_13,
+	DA830_EMA_D_14,
+	DA830_EMA_D_15,
+	DA830_EMA_A_0,
+	DA830_EMA_A_1,
+	DA830_UHPI_HD_10,
+	DA830_UHPI_HD_11,
+	DA830_UHPI_HD_12,
+	DA830_UHPI_HD_13,
+	DA830_UHPI_HD_14,
+	DA830_UHPI_HD_15,
+	DA830_LCD_D_7,
+	DA830_MMCSD_CLK,
+	DA830_LCD_D_10,
+	DA830_LCD_D_11,
+	DA830_LCD_D_12,
+	DA830_LCD_D_13,
+	DA830_LCD_D_14,
+	DA830_LCD_D_15,
+	DA830_UHPI_HCNTL0,
+	DA830_GPIO0_10,
+	DA830_GPIO0_11,
+	DA830_GPIO0_12,
+	DA830_GPIO0_13,
+	DA830_GPIO0_14,
+	DA830_GPIO0_15,
+	DA830_GPIO1_0,
+	DA830_GPIO1_1,
+	DA830_EMA_A_2,
+	DA830_EMA_A_3,
+	DA830_EMA_A_4,
+	DA830_EMA_A_5,
+	DA830_EMA_A_6,
+	DA830_EMA_A_7,
+	DA830_EMA_A_8,
+	DA830_EMA_A_9,
+	DA830_MMCSD_CMD,
+	DA830_LCD_D_6,
+	DA830_LCD_D_3,
+	DA830_LCD_D_2,
+	DA830_LCD_D_1,
+	DA830_LCD_D_0,
+	DA830_LCD_PCLK,
+	DA830_LCD_HSYNC,
+	DA830_UHPI_HCNTL1,
+	DA830_GPIO1_2,
+	DA830_GPIO1_3,
+	DA830_GPIO1_4,
+	DA830_GPIO1_5,
+	DA830_GPIO1_6,
+	DA830_GPIO1_7,
+	DA830_GPIO1_8,
+	DA830_GPIO1_9,
+	DA830_EMA_A_10,
+	DA830_EMA_A_11,
+	DA830_EMA_A_12,
+	DA830_EMA_BA_1,
+	DA830_EMA_BA_0,
+	DA830_EMA_CLK,
+	DA830_EMA_SDCKE,
+	DA830_NEMA_CAS,
+	DA830_LCD_VSYNC,
+	DA830_NLCD_AC_ENB_CS,
+	DA830_LCD_MCLK,
+	DA830_LCD_D_5,
+	DA830_LCD_D_4,
+	DA830_OBSCLK,
+	DA830_NEMA_CS_4,
+	DA830_UHPI_HHWIL,
+	DA830_AHCLKR2,
+	DA830_GPIO1_10,
+	DA830_GPIO1_11,
+	DA830_GPIO1_12,
+	DA830_GPIO1_13,
+	DA830_GPIO1_14,
+	DA830_GPIO1_15,
+	DA830_GPIO2_0,
+	DA830_GPIO2_1,
+	DA830_NEMA_RAS,
+	DA830_NEMA_WE,
+	DA830_NEMA_CS_0,
+	DA830_NEMA_CS_2,
+	DA830_NEMA_CS_3,
+	DA830_NEMA_OE,
+	DA830_NEMA_WE_DQM_1,
+	DA830_NEMA_WE_DQM_0,
+	DA830_NEMA_CS_5,
+	DA830_UHPI_HRNW,
+	DA830_NUHPI_HAS,
+	DA830_NUHPI_HCS,
+	DA830_NUHPI_HDS1,
+	DA830_NUHPI_HDS2,
+	DA830_NUHPI_HINT,
+	DA830_AXR0_12,
+	DA830_AMUTE2,
+	DA830_AXR0_13,
+	DA830_AXR0_14,
+	DA830_AXR0_15,
+	DA830_GPIO2_2,
+	DA830_GPIO2_3,
+	DA830_GPIO2_4,
+	DA830_GPIO2_5,
+	DA830_GPIO2_6,
+	DA830_GPIO2_7,
+	DA830_GPIO2_8,
+	DA830_GPIO2_9,
+	DA830_EMA_WAIT_0,
+	DA830_NUHPI_HRDY,
+	DA830_GPIO2_10,
+};
 
-extern void davinci_mux_peripheral(unsigned int mux, unsigned int enable);
+#ifdef CONFIG_DAVINCI_MUX
+/* setup pin muxing */
+extern int davinci_cfg_reg(unsigned long reg_cfg);
+#else
+/* boot loader does it all (no warnings from CONFIG_DAVINCI_MUX_WARNINGS) */
+static inline int davinci_cfg_reg(unsigned long reg_cfg) { return 0; }
+#endif
 
-#endif /* __ASM_ARCH_MUX_H */
+#endif /* __INC_MACH_MUX_H */
diff --git a/arch/arm/mach-davinci/include/mach/psc.h b/arch/arm/mach-davinci/include/mach/psc.h
index 4977aa0..f4b12c8 100644
--- a/arch/arm/mach-davinci/include/mach/psc.h
+++ b/arch/arm/mach-davinci/include/mach/psc.h
@@ -27,6 +27,8 @@
 #ifndef __ASM_ARCH_PSC_H
 #define __ASM_ARCH_PSC_H
 
+#define	DAVINCI_PWR_SLEEP_CNTRL_BASE	0x01C41000
+
 /* Power and Sleep Controller (PSC) Domains */
 #define DAVINCI_GPSC_ARMDOMAIN      0
 #define DAVINCI_GPSC_DSPDOMAIN      1
@@ -38,8 +40,6 @@
 #define DAVINCI_LPSC_TPTC1          4
 #define DAVINCI_LPSC_EMAC           5
 #define DAVINCI_LPSC_EMAC_WRAPPER   6
-#define DAVINCI_LPSC_MDIO           7
-#define DAVINCI_LPSC_IEEE1394       8
 #define DAVINCI_LPSC_USB            9
 #define DAVINCI_LPSC_ATA            10
 #define DAVINCI_LPSC_VLYNQ          11
@@ -47,7 +47,6 @@
 #define DAVINCI_LPSC_DDR_EMIF       13
 #define DAVINCI_LPSC_AEMIF          14
 #define DAVINCI_LPSC_MMC_SD         15
-#define DAVINCI_LPSC_MEMSTICK       16
 #define DAVINCI_LPSC_McBSP          17
 #define DAVINCI_LPSC_I2C            18
 #define DAVINCI_LPSC_UART0          19
@@ -73,4 +72,49 @@
 #define DAVINCI_LPSC_GEM            39
 #define DAVINCI_LPSC_IMCOP          40
 
+/* PSC0 defines */
+#define DA8XX_LPSC0_TPCC		0
+#define DA8XX_LPSC0_TPTC0		1
+#define DA8XX_LPSC0_TPTC1		2
+#define DA8XX_LPSC0_EMIF25		3
+#define DA8XX_LPSC0_SPI0		4
+#define DA8XX_LPSC0_MMC_SD		5
+#define DA8XX_LPSC0_AINTC		6
+#define DA8XX_LPSC0_ARM_RAM_ROM		7
+#define DA8XX_LPSC0_SECU_MGR		8
+#define DA8XX_LPSC0_UART0		9
+#define DA8XX_LPSC0_SCR0_SS		10
+#define DA8XX_LPSC0_SCR1_SS		11
+#define DA8XX_LPSC0_SCR2_SS		12
+#define DA8XX_LPSC0_DMAX		13
+#define DA8XX_LPSC0_ARM			14
+#define DA8XX_LPSC0_GEM			15
+
+/* PSC1 defines */
+#define DA8XX_LPSC1_USB20		1
+#define DA8XX_LPSC1_USB11		2
+#define DA8XX_LPSC1_GPIO		3
+#define DA8XX_LPSC1_UHPI		4
+#define DA8XX_LPSC1_CPGMAC		5
+#define DA8XX_LPSC1_EMIF3C		6
+#define DA8XX_LPSC1_McASP0		7
+#define DA830_LPSC1_McASP1		8
+#define DA830_LPSC1_McASP2		9
+#define DA8XX_LPSC1_SPI1		10
+#define DA8XX_LPSC1_I2C			11
+#define DA8XX_LPSC1_UART1		12
+#define DA8XX_LPSC1_UART2		13
+#define DA8XX_LPSC1_LCDC		16
+#define DA8XX_LPSC1_PWM			17
+#define DA8XX_LPSC1_ECAP		20
+#define DA830_LPSC1_EQEP		21
+#define DA8XX_LPSC1_SCR_P0_SS		24
+#define DA8XX_LPSC1_SCR_P1_SS		25
+#define DA8XX_LPSC1_CR_P3_SS		26
+#define DA8XX_LPSC1_L3_CBA_RAM		31
+
+extern int davinci_psc_is_clk_active(unsigned int ctlr, unsigned int id);
+extern void davinci_psc_config(unsigned int domain, unsigned int ctlr,
+		unsigned int id, char enable);
+
 #endif /* __ASM_ARCH_PSC_H */
diff --git a/arch/arm/mach-davinci/include/mach/serial.h b/arch/arm/mach-davinci/include/mach/serial.h
index fb8cb22..976cf94 100644
--- a/arch/arm/mach-davinci/include/mach/serial.h
+++ b/arch/arm/mach-davinci/include/mach/serial.h
@@ -11,10 +11,25 @@
 #ifndef __ASM_ARCH_SERIAL_H
 #define __ASM_ARCH_SERIAL_H
 
-#include <mach/io.h>
+#include <mach/hardware.h>
 
-#define DAVINCI_UART0_BASE   (IO_PHYS + 0x20000)
-#define DAVINCI_UART1_BASE   (IO_PHYS + 0x20400)
-#define DAVINCI_UART2_BASE   (IO_PHYS + 0x20800)
+#define DAVINCI_MAX_NR_UARTS	3
+#define DAVINCI_UART0_BASE	(IO_PHYS + 0x20000)
+#define DAVINCI_UART1_BASE	(IO_PHYS + 0x20400)
+#define DAVINCI_UART2_BASE	(IO_PHYS + 0x20800)
+
+#define DA8XX_UART0_BASE	(IO_PHYS + 0x042000)
+#define DA8XX_UART1_BASE	(IO_PHYS + 0x10c000)
+#define DA8XX_UART2_BASE	(IO_PHYS + 0x10d000)
+
+/* DaVinci UART register offsets */
+#define UART_DAVINCI_PWREMU		0x0c
+
+struct davinci_uart_config {
+	/* Bit field of UARTs present; bit 0 --> UART1 */
+	unsigned int enabled_uarts;
+};
+
+extern int davinci_serial_init(struct davinci_uart_config *);
 
 #endif /* __ASM_ARCH_SERIAL_H */
diff --git a/arch/arm/mach-davinci/include/mach/system.h b/arch/arm/mach-davinci/include/mach/system.h
index 84ff77a..83bf5d0 100644
--- a/arch/arm/mach-davinci/include/mach/system.h
+++ b/arch/arm/mach-davinci/include/mach/system.h
@@ -11,17 +11,17 @@
 #ifndef __ASM_ARCH_SYSTEM_H
 #define __ASM_ARCH_SYSTEM_H
 
-#include <asm/io.h>
+#include <linux/io.h>
 #include <mach/hardware.h>
 
 extern void davinci_watchdog_reset(void);
 
-static void arch_idle(void)
+static inline void arch_idle(void)
 {
 	cpu_do_idle();
 }
 
-static void arch_reset(char mode)
+static inline void arch_reset(char mode)
 {
 	davinci_watchdog_reset();
 }
diff --git a/arch/arm/mach-davinci/include/mach/time.h b/arch/arm/mach-davinci/include/mach/time.h
new file mode 100644
index 0000000..1c971d8
--- /dev/null
+++ b/arch/arm/mach-davinci/include/mach/time.h
@@ -0,0 +1,35 @@
+/*
+ * Local header file for DaVinci time code.
+ *
+ * Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+#ifndef __ARCH_ARM_MACH_DAVINCI_TIME_H
+#define __ARCH_ARM_MACH_DAVINCI_TIME_H
+
+#define DAVINCI_TIMER0_BASE		(IO_PHYS + 0x21400)
+#define DAVINCI_TIMER1_BASE		(IO_PHYS + 0x21800)
+#define DAVINCI_WDOG_BASE		(IO_PHYS + 0x21C00)
+
+enum {
+	T0_BOT,
+	T0_TOP,
+	T1_BOT,
+	T1_TOP,
+	NUM_TIMERS
+};
+
+#define IS_TIMER1(id)		(id & 0x2)
+#define IS_TIMER0(id)		(!IS_TIMER1(id))
+#define IS_TIMER_TOP(id)	((id & 0x1))
+#define IS_TIMER_BOT(id)	(!IS_TIMER_TOP(id))
+
+#define ID_TO_TIMER(id)		(IS_TIMER1(id) != 0)
+
+extern struct davinci_timer_instance davinci_timer_instance[];
+
+#endif /* __ARCH_ARM_MACH_DAVINCI_TIME_H */
diff --git a/arch/arm/mach-davinci/include/mach/uncompress.h b/arch/arm/mach-davinci/include/mach/uncompress.h
index 8c165de..f995038 100644
--- a/arch/arm/mach-davinci/include/mach/uncompress.h
+++ b/arch/arm/mach-davinci/include/mach/uncompress.h
@@ -13,11 +13,24 @@
 #include <linux/serial_reg.h>
 #include <mach/serial.h>
 
+#include <asm/mach-types.h>
+
+static u32 *uart;
+
+static u32 *get_uart_base(void)
+{
+	if (__machine_arch_type == MACH_TYPE_DAVINCI_DA8XX_EVM)
+		return (u32 *)DA8XX_UART2_BASE;
+	else
+		return (u32 *)DAVINCI_UART0_BASE;
+}
+
 /* PORT_16C550A, in polled non-fifo mode */
 
 static void putc(char c)
 {
-	volatile u32 *uart = (volatile void *) DAVINCI_UART0_BASE;
+	if (!uart)
+		uart = get_uart_base();
 
 	while (!(uart[UART_LSR] & UART_LSR_THRE))
 		barrier();
@@ -26,7 +39,9 @@ static void putc(char c)
 
 static inline void flush(void)
 {
-	volatile u32 *uart = (volatile void *) DAVINCI_UART0_BASE;
+	if (!uart)
+		uart = get_uart_base();
+
 	while (!(uart[UART_LSR] & UART_LSR_THRE))
 		barrier();
 }
diff --git a/arch/arm/mach-davinci/include/mach/usb.h b/arch/arm/mach-davinci/include/mach/usb.h
new file mode 100644
index 0000000..f2e9999
--- /dev/null
+++ b/arch/arm/mach-davinci/include/mach/usb.h
@@ -0,0 +1,61 @@
+/*
+ * USB related definitions
+ *
+ * Copyright (C) 2009 MontaVista Software, Inc. <source@mvista.com>
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef __ASM_ARCH_USB_H
+#define __ASM_ARCH_USB_H
+
+/* DA8xx has 5 CFGCHIP registers */
+#define DA8XX_CFGCHIP(n)	(DA8XX_SYSCFG_BASE + 0x17c + (n) * 4)
+
+/* DA8xx CFGCHIP2 (USB 2.0 PHY Control) register bits */
+#define CFGCHIP2_PHYCLKGD	(1 << 17)
+#define CFGCHIP2_VBUSSENSE	(1 << 16)
+#define CFGCHIP2_RESET		(1 << 15)
+#define CFGCHIP2_OTGMODE	(3 << 13)
+#define CFGCHIP2_NO_OVERRIDE	(0 << 13)
+#define CFGCHIP2_FORCE_HOST	(1 << 13)
+#define CFGCHIP2_FORCE_DEVICE 	(2 << 13)
+#define CFGCHIP2_FORCE_HOST_VBUS_LOW (3 << 13)
+#define CFGCHIP2_USB1PHYCLKMUX	(1 << 12)
+#define CFGCHIP2_USB2PHYCLKMUX	(1 << 11)
+#define CFGCHIP2_PHYPWRDN	(1 << 10)
+#define CFGCHIP2_OTGPWRDN	(1 << 9)
+#define CFGCHIP2_DATPOL 	(1 << 8)
+#define CFGCHIP2_USB1SUSPENDM	(1 << 7)
+#define CFGCHIP2_PHY_PLLON	(1 << 6)	/* override PLL suspend */
+#define CFGCHIP2_SESENDEN	(1 << 5)	/* Vsess_end comparator */
+#define CFGCHIP2_VBDTCTEN	(1 << 4)	/* Vbus comparator */
+#define CFGCHIP2_REFFREQ	(0xf << 0)
+#define CFGCHIP2_REFFREQ_12MHZ	(1 << 0)
+#define CFGCHIP2_REFFREQ_24MHZ	(2 << 0)
+#define CFGCHIP2_REFFREQ_48MHZ	(3 << 0)
+
+struct	da8xx_ohci_root_hub;
+
+typedef void (*da8xx_ocic_handler_t)(struct da8xx_ohci_root_hub *hub,
+					unsigned port);
+
+/* Passed as the platform data to the OHCI driver */
+struct	da8xx_ohci_root_hub {
+	/* Switch the port power on/off */
+	int	(*set_power)(unsigned port, int on);
+	/* Read the port power status */
+	int	(*get_power)(unsigned port);
+	/* Read the port over-current indicator */
+	int	(*get_oci)(unsigned port);
+	/* Over-current indicator change notification (pass NULL to disable) */
+	int	(*ocic_notify)(da8xx_ocic_handler_t handler);
+	/* Time from power on to power good (in 2 ms units) */
+	u8	potpgt;
+};
+
+int da8xx_register_ohci(void);
+#endif	/* ifndef __ASM_ARCH_USB_H */
+
diff --git a/arch/arm/mach-davinci/include/mach/vmalloc.h b/arch/arm/mach-davinci/include/mach/vmalloc.h
index b98bd9e..d49646a 100644
--- a/arch/arm/mach-davinci/include/mach/vmalloc.h
+++ b/arch/arm/mach-davinci/include/mach/vmalloc.h
@@ -8,8 +8,7 @@
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
  */
-#include <asm/memory.h>
-#include <mach/io.h>
+#include <mach/hardware.h>
 
 /* Allow vmalloc range until the IO virtual range minus a 2M "hole" */
 #define VMALLOC_END	  (IO_VIRT - (2<<20))
diff --git a/arch/arm/mach-davinci/io.c b/arch/arm/mach-davinci/io.c
index 5bb66b6..49912b4 100644
--- a/arch/arm/mach-davinci/io.c
+++ b/arch/arm/mach-davinci/io.c
@@ -9,49 +9,30 @@
  */
 
 #include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
+#include <linux/io.h>
 
 #include <asm/tlb.h>
-#include <asm/io.h>
-#include <asm/memory.h>
 
-#include <asm/mach/map.h>
-#include <mach/clock.h>
-
-extern void davinci_check_revision(void);
+#define BETWEEN(p, st, sz)	((p) >= (st) && (p) < ((st) + (sz)))
+#define XLATE(p, pst, vst)	((void __iomem *)((p) - (pst) + (vst)))
 
 /*
- * The machine specific code may provide the extra mapping besides the
- * default mapping provided here.
+ * Intercept ioremap() requests for addresses in our fixed mapping regions.
  */
-static struct map_desc davinci_io_desc[] __initdata = {
-	{
-		.virtual	= IO_VIRT,
-		.pfn		= __phys_to_pfn(IO_PHYS),
-		.length		= IO_SIZE,
-		.type		= MT_DEVICE
-	},
-};
-
-void __init davinci_map_common_io(void)
+void __iomem *davinci_ioremap(unsigned long p, size_t size, unsigned int type)
 {
-	iotable_init(davinci_io_desc, ARRAY_SIZE(davinci_io_desc));
+	if (BETWEEN(p, IO_PHYS, IO_SIZE))
+		return XLATE(p, IO_PHYS, IO_VIRT);
 
-	/* Normally devicemaps_init() would flush caches and tlb after
-	 * mdesc->map_io(), but we must also do it here because of the CPU
-	 * revision check below.
-	 */
-	local_flush_tlb_all();
-	flush_cache_all();
-
-	/* We want to check CPU revision early for cpu_is_xxxx() macros.
-	 * IO space mapping must be initialized before we can do that.
-	 */
-	davinci_check_revision();
+	return __arm_ioremap(p, size, type);
 }
+EXPORT_SYMBOL(davinci_ioremap);
 
-void __init davinci_init_common_hw(void)
+void davinci_iounmap(volatile void __iomem *addr)
 {
-	davinci_clk_init();
+	unsigned long virt = (unsigned long)addr;
+
+	if (virt >= VMALLOC_START && virt < VMALLOC_END)
+		__iounmap(addr);
 }
+EXPORT_SYMBOL(davinci_iounmap);
diff --git a/arch/arm/mach-davinci/mux.c b/arch/arm/mach-davinci/mux.c
index 8ff9d8a..da2e77f 100644
--- a/arch/arm/mach-davinci/mux.c
+++ b/arch/arm/mach-davinci/mux.c
@@ -1,41 +1,119 @@
 /*
- * DaVinci pin multiplexing configurations
+ * Utility to set the DAVINCI MUX register from a table in mux.h
  *
  * Author: Vladimir Barinov, MontaVista Software, Inc. <source@mvista.com>
  *
+ * Based on linux/arch/arm/plat-omap/mux.c:
+ * Copyright (C) 2003 - 2005 Nokia Corporation
+ *
+ * Written by Tony Lindgren
+ *
  * 2007 (c) MontaVista Software, Inc. This file is licensed under
  * the terms of the GNU General Public License version 2. This program
  * is licensed "as is" without any warranty of any kind, whether express
  * or implied.
+ *
+ * Copyright (C) 2008 Texas Instruments.
  */
 #include <linux/io.h>
+#include <linux/module.h>
 #include <linux/spinlock.h>
 
 #include <mach/hardware.h>
-
 #include <mach/mux.h>
+#include <mach/common.h>
 
-/* System control register offsets */
-#define PINMUX0         0x00
-#define PINMUX1         0x04
+#ifdef CONFIG_ARCH_DAVINCI_DA8XX
+#include <mach/cputype.h>
+#include <mach/da8xx.h>
+#endif
 
-static DEFINE_SPINLOCK(mux_lock);
-
-void davinci_mux_peripheral(unsigned int mux, unsigned int enable)
+/*
+ * Sets the DAVINCI MUX register based on the table
+ */
+int __init_or_module davinci_cfg_reg(const unsigned long index)
 {
-	u32 pinmux, muxreg = PINMUX0;
+	static DEFINE_SPINLOCK(mux_spin_lock);
+	struct davinci_soc_info *soc_info = &davinci_soc_info;
+	void __iomem *base = soc_info->pinmux_base;
+	unsigned long flags;
+	const struct mux_config *cfg;
+	unsigned int reg_orig = 0, reg = 0;
+	unsigned int mask, warn = 0;
+
+	if (!soc_info->pinmux_pins)
+		BUG();
+
+	/*Specific handling for da830*/
+	if (cpu_is_davinci_da830()) {
+        /* Unlock the SYSCFG registers */
+        __raw_writel(DA8XX_KICK0_MAGIC, IO_ADDRESS(DA8XX_KICK0));
+        __raw_writel(DA8XX_KICK1_MAGIC, IO_ADDRESS(DA8XX_KICK1));
+    }
+
+	if (index >= soc_info->pinmux_pins_num) {
+		printk(KERN_ERR "Invalid pin mux index: %lu (%lu)\n",
+		       index, soc_info->pinmux_pins_num);
+		dump_stack();
+		return -ENODEV;
+	}
+
+	cfg = &soc_info->pinmux_pins[index];
+
+	if (cfg->name == NULL) {
+		printk(KERN_ERR "No entry for the specified index\n");
+		return -ENODEV;
+	}
 
-	if (mux >= DAVINCI_MUX_LEVEL2) {
-		muxreg = PINMUX1;
-		mux -= DAVINCI_MUX_LEVEL2;
+	/* Update the mux register in question */
+	if (cfg->mask) {
+		unsigned	tmp1, tmp2;
+
+		spin_lock_irqsave(&mux_spin_lock, flags);
+		reg_orig = __raw_readl(base + cfg->mux_reg);
+
+		mask = (cfg->mask << cfg->mask_offset);
+		tmp1 = reg_orig & mask;
+		reg = reg_orig & ~mask;
+
+		tmp2 = (cfg->mode << cfg->mask_offset);
+		reg |= tmp2;
+
+		if (tmp1 != tmp2)
+			warn = 1;
+
+		__raw_writel(reg, base + cfg->mux_reg);
+		spin_unlock_irqrestore(&mux_spin_lock, flags);
+	}
+
+	if (warn) {
+#ifdef CONFIG_DAVINCI_MUX_WARNINGS
+		printk(KERN_WARNING "MUX: initialized %s\n", cfg->name);
+#endif
 	}
 
-	spin_lock(&mux_lock);
-	pinmux = davinci_readl(DAVINCI_SYSTEM_MODULE_BASE + muxreg);
-	if (enable)
-		pinmux |= (1 << mux);
-	else
-		pinmux &= ~(1 << mux);
-	davinci_writel(pinmux, DAVINCI_SYSTEM_MODULE_BASE + muxreg);
-	spin_unlock(&mux_lock);
+#ifdef CONFIG_DAVINCI_MUX_DEBUG
+	if (cfg->debug || warn) {
+		printk(KERN_WARNING "MUX: Setting register %s\n", cfg->name);
+		printk(KERN_WARNING "	   %s (0x%08x) = 0x%08x -> 0x%08x\n",
+		       cfg->mux_reg_name, cfg->mux_reg, reg_orig, reg);
+	}
+#endif
+
+	return 0;
+}
+EXPORT_SYMBOL(davinci_cfg_reg);
+
+int da8xx_pinmux_setup(const short pins[])
+{
+	int i, error = -EINVAL;
+
+	if (pins)
+		for (i = 0; pins[i] >= 0; i++) {
+			error = davinci_cfg_reg(pins[i]);
+			if (error)
+				break;
+		}
+
+	return error;
 }
diff --git a/arch/arm/mach-davinci/mux.h b/arch/arm/mach-davinci/mux.h
new file mode 100644
index 0000000..adc8694
--- /dev/null
+++ b/arch/arm/mach-davinci/mux.h
@@ -0,0 +1,51 @@
+/*
+ * Pin-multiplex helper macros for TI DaVinci family devices
+ *
+ * Author: Vladimir Barinov, MontaVista Software, Inc. <source@mvista.com>
+ *
+ * 2007 (c) MontaVista Software, Inc. This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Copyright (C) 2008 Texas Instruments.
+ */
+#ifndef _MACH_DAVINCI_MUX_H_
+#define _MACH_DAVINCI_MUX_H_
+
+#include <mach/mux.h>
+
+#define MUX_CFG(soc, desc, muxreg, mode_offset, mode_mask, mux_mode, dbg)\
+[soc##_##desc] = {							\
+			.name =  #desc,					\
+			.debug = dbg,					\
+			.mux_reg_name = "PINMUX"#muxreg,		\
+			.mux_reg = PINMUX##muxreg,			\
+			.mask_offset = mode_offset,			\
+			.mask = mode_mask,				\
+			.mode = mux_mode,				\
+		},
+
+#define INT_CFG(soc, desc, mode_offset, mode_mask, mux_mode, dbg)	\
+[soc##_##desc] = {							\
+			.name =  #desc,					\
+			.debug = dbg,					\
+			.mux_reg_name = "INTMUX",			\
+			.mux_reg = INTMUX,				\
+			.mask_offset = mode_offset,			\
+			.mask = mode_mask,				\
+			.mode = mux_mode,				\
+		},
+
+#define EVT_CFG(soc, desc, mode_offset, mode_mask, mux_mode, dbg)	\
+[soc##_##desc] = {							\
+			.name =  #desc,					\
+			.debug = dbg,					\
+			.mux_reg_name = "EVTMUX",			\
+			.mux_reg = EVTMUX,				\
+			.mask_offset = mode_offset,			\
+			.mask = mode_mask,				\
+			.mode = mux_mode,				\
+		},
+
+#endif /* _MACH_DAVINCI_MUX_H */
diff --git a/arch/arm/mach-davinci/psc.c b/arch/arm/mach-davinci/psc.c
index aa2fc37..a78b657 100644
--- a/arch/arm/mach-davinci/psc.c
+++ b/arch/arm/mach-davinci/psc.c
@@ -21,8 +21,9 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/io.h>
 
-#include <asm/io.h>
+#include <mach/cputype.h>
 #include <mach/hardware.h>
 #include <mach/psc.h>
 #include <mach/mux.h>
@@ -36,102 +37,81 @@
 #define MDSTAT		0x800
 #define MDCTL		0xA00
 
-/* System control register offsets */
-#define VDD3P3V_PWDN	0x48
+#define MDSTAT_STATE_MASK 0x1f
 
-static void davinci_psc_mux(unsigned int id)
+/* Return nonzero iff the domain's clock is active */
+int __init davinci_psc_is_clk_active(unsigned int ctlr, unsigned int id)
 {
-	switch (id) {
-	case DAVINCI_LPSC_ATA:
-		davinci_mux_peripheral(DAVINCI_MUX_HDIREN, 1);
-		davinci_mux_peripheral(DAVINCI_MUX_ATAEN, 1);
-		break;
-	case DAVINCI_LPSC_MMC_SD:
-		/* VDD power manupulations are done in U-Boot for CPMAC
-		 * so applies to MMC as well
-		 */
-		/*Set up the pull regiter for MMC */
-		davinci_writel(0, DAVINCI_SYSTEM_MODULE_BASE + VDD3P3V_PWDN);
-		davinci_mux_peripheral(DAVINCI_MUX_MSTK, 0);
-		break;
-	case DAVINCI_LPSC_I2C:
-		davinci_mux_peripheral(DAVINCI_MUX_I2C, 1);
-		break;
-	case DAVINCI_LPSC_McBSP:
-		davinci_mux_peripheral(DAVINCI_MUX_ASP, 1);
-		break;
-	default:
-		break;
+	void __iomem *psc_base;
+	u32 mdstat;
+	struct davinci_soc_info *soc_info = &davinci_soc_info;
+
+	if (!soc_info->psc_bases || (ctlr >= soc_info->psc_bases_num)) {
+		pr_warning("PSC: Bad psc data: 0x%x[%d]\n",
+				(int)soc_info->psc_bases, ctlr);
+		return 0;
 	}
+
+	psc_base = soc_info->psc_bases[ctlr];
+	mdstat = __raw_readl(psc_base + MDSTAT + 4 * id);
+
+	/* if clocked, state can be "Enable" or "SyncReset" */
+	return mdstat & BIT(12);
 }
 
 /* Enable or disable a PSC domain */
-void davinci_psc_config(unsigned int domain, unsigned int id, char enable)
+void davinci_psc_config(unsigned int domain, unsigned int ctlr,
+		unsigned int id, char enable)
 {
-	u32 epcpr, ptcmd, ptstat, pdstat, pdctl1, mdstat, mdctl, mdstat_mask;
+	u32 epcpr, ptcmd, ptstat, pdstat, pdctl1, mdstat, mdctl;
+	void __iomem *psc_base;
+	struct davinci_soc_info *soc_info = &davinci_soc_info;
+	u32 next_state = enable ? 0x3 : 0x2; /* 0x3 enables, 0x2 disables */
+
+	if (!soc_info->psc_bases || (ctlr >= soc_info->psc_bases_num)) {
+		pr_warning("PSC: Bad psc data: 0x%x[%d]\n",
+				(int)soc_info->psc_bases, ctlr);
+		return;
+	}
 
-	mdctl = davinci_readl(DAVINCI_PWR_SLEEP_CNTRL_BASE + MDCTL + 4 * id);
-	if (enable)
-		mdctl |= 0x00000003;	/* Enable Module */
-	else
-		mdctl &= 0xFFFFFFF2;	/* Disable Module */
-	davinci_writel(mdctl, DAVINCI_PWR_SLEEP_CNTRL_BASE + MDCTL + 4 * id);
+	psc_base = soc_info->psc_bases[ctlr];
 
-	pdstat = davinci_readl(DAVINCI_PWR_SLEEP_CNTRL_BASE + PDSTAT);
+	mdctl = __raw_readl(psc_base + MDCTL + 4 * id);
+	mdctl &= ~MDSTAT_STATE_MASK;
+	mdctl |= next_state;
+	__raw_writel(mdctl, psc_base + MDCTL + 4 * id);
+
+	pdstat = __raw_readl(psc_base + PDSTAT);
 	if ((pdstat & 0x00000001) == 0) {
-		pdctl1 = davinci_readl(DAVINCI_PWR_SLEEP_CNTRL_BASE + PDCTL1);
+		pdctl1 = __raw_readl(psc_base + PDCTL1);
 		pdctl1 |= 0x1;
-		davinci_writel(pdctl1, DAVINCI_PWR_SLEEP_CNTRL_BASE + PDCTL1);
+		__raw_writel(pdctl1, psc_base + PDCTL1);
 
 		ptcmd = 1 << domain;
-		davinci_writel(ptcmd, DAVINCI_PWR_SLEEP_CNTRL_BASE + PTCMD);
+		__raw_writel(ptcmd, psc_base + PTCMD);
 
 		do {
-			epcpr = davinci_readl(DAVINCI_PWR_SLEEP_CNTRL_BASE +
-					      EPCPR);
+			epcpr = __raw_readl(psc_base + EPCPR);
 		} while ((((epcpr >> domain) & 1) == 0));
 
-		pdctl1 = davinci_readl(DAVINCI_PWR_SLEEP_CNTRL_BASE + PDCTL1);
+		pdctl1 = __raw_readl(psc_base + PDCTL1);
 		pdctl1 |= 0x100;
-		davinci_writel(pdctl1, DAVINCI_PWR_SLEEP_CNTRL_BASE + PDCTL1);
+		__raw_writel(pdctl1, psc_base + PDCTL1);
 
 		do {
-			ptstat = davinci_readl(DAVINCI_PWR_SLEEP_CNTRL_BASE +
+			ptstat = __raw_readl(psc_base +
 					       PTSTAT);
 		} while (!(((ptstat >> domain) & 1) == 0));
 	} else {
 		ptcmd = 1 << domain;
-		davinci_writel(ptcmd, DAVINCI_PWR_SLEEP_CNTRL_BASE + PTCMD);
+		__raw_writel(ptcmd, psc_base + PTCMD);
 
 		do {
-			ptstat = davinci_readl(DAVINCI_PWR_SLEEP_CNTRL_BASE +
-					       PTSTAT);
+			ptstat = __raw_readl(psc_base + PTSTAT);
 		} while (!(((ptstat >> domain) & 1) == 0));
 	}
 
-	if (enable)
-		mdstat_mask = 0x3;
-	else
-		mdstat_mask = 0x2;
-
 	do {
-		mdstat = davinci_readl(DAVINCI_PWR_SLEEP_CNTRL_BASE +
-				       MDSTAT + 4 * id);
-	} while (!((mdstat & 0x0000001F) == mdstat_mask));
-
-	if (enable)
-		davinci_psc_mux(id);
-}
-
-void __init davinci_psc_init(void)
-{
-	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_VPSSMSTR, 1);
-	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_VPSSSLV, 1);
-	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_TPCC, 1);
-	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_TPTC0, 1);
-	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_TPTC1, 1);
-	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_GPIO, 1);
-
-	/* Turn on WatchDog timer LPSC.	 Needed for RESET to work */
-	davinci_psc_config(DAVINCI_GPSC_ARMDOMAIN, DAVINCI_LPSC_TIMER2, 1);
+		mdstat = __raw_readl(psc_base + MDSTAT + 4 * id);
+	} while (!((mdstat & MDSTAT_STATE_MASK) == next_state));
 }
diff --git a/arch/arm/mach-davinci/serial.c b/arch/arm/mach-davinci/serial.c
index caf101e..2f18a71 100644
--- a/arch/arm/mach-davinci/serial.c
+++ b/arch/arm/mach-davinci/serial.c
@@ -26,71 +26,74 @@
 #include <linux/platform_device.h>
 #include <linux/delay.h>
 #include <linux/clk.h>
+#include <linux/io.h>
 
-#include <asm/io.h>
 #include <asm/irq.h>
 #include <mach/hardware.h>
 #include <mach/serial.h>
 #include <mach/irqs.h>
+#include <mach/cputype.h>
+#include <mach/common.h>
 
-#define UART_DAVINCI_PWREMU 0x0c
+#include "clock.h"
 
-static inline unsigned int davinci_serial_in(struct plat_serial8250_port *up,
-					  int offset)
+static inline unsigned int serial_read_reg(struct plat_serial8250_port *up,
+					   int offset)
 {
 	offset <<= up->regshift;
-	return (unsigned int)__raw_readb(up->membase + offset);
+	return (unsigned int)__raw_readl(IO_ADDRESS(up->mapbase) + offset);
 }
 
-static inline void davinci_serial_outp(struct plat_serial8250_port *p,
-				       int offset, int value)
+static inline void serial_write_reg(struct plat_serial8250_port *p, int offset,
+				    int value)
 {
 	offset <<= p->regshift;
-	__raw_writeb(value, p->membase + offset);
+	__raw_writel(value, IO_ADDRESS(p->mapbase) + offset);
 }
 
-static struct plat_serial8250_port serial_platform_data[] = {
-	{
-		.membase	= (char *)IO_ADDRESS(DAVINCI_UART0_BASE),
-		.mapbase	= (unsigned long)DAVINCI_UART0_BASE,
-		.irq		= IRQ_UARTINT0,
-		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST,
-		.iotype		= UPIO_MEM,
-		.regshift	= 2,
-		.uartclk	= 27000000,
-	},
-	{
-		.flags		= 0
-	},
-};
-
-static struct platform_device serial_device = {
-	.name			= "serial8250",
-	.id			= PLAT8250_DEV_PLATFORM,
-	.dev			= {
-		.platform_data	= serial_platform_data,
-	},
-};
-
 static void __init davinci_serial_reset(struct plat_serial8250_port *p)
 {
-	/* reset both transmitter and receiver: bits 14,13 = UTRST, URRST */
 	unsigned int pwremu = 0;
 
-	davinci_serial_outp(p, UART_IER, 0);  /* disable all interrupts */
+	serial_write_reg(p, UART_IER, 0);  /* disable all interrupts */
 
-	davinci_serial_outp(p, UART_DAVINCI_PWREMU, pwremu);
+	/* reset both transmitter and receiver: bits 14,13 = UTRST, URRST */
+	serial_write_reg(p, UART_DAVINCI_PWREMU, pwremu);
 	mdelay(10);
 
 	pwremu |= (0x3 << 13);
 	pwremu |= 0x1;
-	davinci_serial_outp(p, UART_DAVINCI_PWREMU, pwremu);
+	serial_write_reg(p, UART_DAVINCI_PWREMU, pwremu);
 }
 
-static int __init davinci_init(void)
+int __init davinci_serial_init(struct davinci_uart_config *info)
 {
-	davinci_serial_reset(&serial_platform_data[0]);
-	return platform_device_register(&serial_device);
-}
+	int i;
+	char name[16];
+	struct clk *uart_clk;
+	struct davinci_soc_info *soc_info = &davinci_soc_info;
+	struct device *dev = &soc_info->serial_dev->dev;
+	struct plat_serial8250_port *p = dev->platform_data;
+
+	/*
+	 * Make sure the serial ports are muxed on at this point.
+	 * You have to mux them off in device drivers later on if not needed.
+	 */
+	for (i = 0; i < DAVINCI_MAX_NR_UARTS; i++, p++) {
+		if (!(info->enabled_uarts & (1 << i)))
+			continue;
 
-arch_initcall(davinci_init);
+		sprintf(name, "uart%d", i);
+		uart_clk = clk_get(dev, name);
+		if (IS_ERR(uart_clk))
+			printk(KERN_ERR "%s:%d: failed to get UART%d clock\n",
+					__func__, __LINE__, i);
+		else {
+			clk_enable(uart_clk);
+			p->uartclk = clk_get_rate(uart_clk);
+			davinci_serial_reset(p);
+		}
+	}
+
+	return platform_device_register(soc_info->serial_dev);
+}
diff --git a/arch/arm/mach-davinci/time.c b/arch/arm/mach-davinci/time.c
index 206e80d..ede90aa 100644
--- a/arch/arm/mach-davinci/time.c
+++ b/arch/arm/mach-davinci/time.c
@@ -15,8 +15,12 @@
 #include <linux/clocksource.h>
 #include <linux/clockchips.h>
 #include <linux/spinlock.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/device.h>
+#include <linux/platform_device.h>
 
-#include <asm/io.h>
 #include <mach/hardware.h>
 #include <asm/system.h>
 #include <asm/irq.h>
@@ -24,50 +28,42 @@
 #include <asm/mach/time.h>
 #include <asm/errno.h>
 #include <mach/io.h>
+#include <mach/cputype.h>
+#include <mach/time.h>
+#include "clock.h"
 
 static struct clock_event_device clockevent_davinci;
-
-#define DAVINCI_TIMER0_BASE (IO_PHYS + 0x21400)
-#define DAVINCI_TIMER1_BASE (IO_PHYS + 0x21800)
-#define DAVINCI_WDOG_BASE   (IO_PHYS + 0x21C00)
-
-enum {
-	T0_BOT = 0, T0_TOP, T1_BOT, T1_TOP, NUM_TIMERS,
-};
-
-#define IS_TIMER1(id)    (id & 0x2)
-#define IS_TIMER0(id)    (!IS_TIMER1(id))
-#define IS_TIMER_TOP(id) ((id & 0x1))
-#define IS_TIMER_BOT(id) (!IS_TIMER_TOP(id))
-
-static int timer_irqs[NUM_TIMERS] = {
-	IRQ_TINT0_TINT12,
-	IRQ_TINT0_TINT34,
-	IRQ_TINT1_TINT12,
-	IRQ_TINT1_TINT34,
-};
+static unsigned int davinci_clock_tick_rate;
 
 /*
  * This driver configures the 2 64-bit count-up timers as 4 independent
  * 32-bit count-up timers used as follows:
- *
- * T0_BOT: Timer 0, bottom:  clockevent source for hrtimers
- * T0_TOP: Timer 0, top   :  clocksource for generic timekeeping
- * T1_BOT: Timer 1, bottom:  (used by DSP in TI DSPLink code)
- * T1_TOP: Timer 1, top   :  <unused>
  */
-#define TID_CLOCKEVENT  T0_BOT
-#define TID_CLOCKSOURCE T0_TOP
+
+enum {
+	TID_CLOCKEVENT,
+	TID_CLOCKSOURCE,
+};
 
 /* Timer register offsets */
-#define PID12                        0x0
-#define TIM12                        0x10
-#define TIM34                        0x14
-#define PRD12                        0x18
-#define PRD34                        0x1c
-#define TCR                          0x20
-#define TGCR                         0x24
-#define WDTCR                        0x28
+#define PID12			0x0
+#define TIM12			0x10
+#define TIM34			0x14
+#define PRD12			0x18
+#define PRD34			0x1c
+#define TCR			0x20
+#define TGCR			0x24
+#define WDTCR			0x28
+
+/* Offsets of the 8 compare registers */
+#define	CMP12_0			0x60
+#define	CMP12_1			0x64
+#define	CMP12_2			0x68
+#define	CMP12_3			0x6c
+#define	CMP12_4			0x70
+#define	CMP12_5			0x74
+#define	CMP12_6			0x78
+#define	CMP12_7			0x7c
 
 /* Timer register bitfields */
 #define TCR_ENAMODE_DISABLE          0x0
@@ -99,45 +95,74 @@ struct timer_s {
 	unsigned int id;
 	unsigned long period;
 	unsigned long opts;
-	unsigned long reg_base;
-	unsigned long tim_reg;
-	unsigned long prd_reg;
+	unsigned long flags;
+	void __iomem *base;
+	unsigned long tim_off;
+	unsigned long prd_off;
 	unsigned long enamode_shift;
 	struct irqaction irqaction;
 };
 static struct timer_s timers[];
 
 /* values for 'opts' field of struct timer_s */
-#define TIMER_OPTS_DISABLED   0x00
-#define TIMER_OPTS_ONESHOT    0x01
-#define TIMER_OPTS_PERIODIC   0x02
+#define TIMER_OPTS_DISABLED		0x01
+#define TIMER_OPTS_ONESHOT		0x02
+#define TIMER_OPTS_PERIODIC		0x04
+#define TIMER_OPTS_STATE_MASK		0x07
+
+#define TIMER_OPTS_USE_COMPARE		0x80000000
+#define USING_COMPARE(t)		((t)->opts & TIMER_OPTS_USE_COMPARE)
+
+static char *id_to_name[] = {
+	[T0_BOT]	= "timer0_0",
+	[T0_TOP]	= "timer0_1",
+	[T1_BOT]	= "timer1_0",
+	[T1_TOP]	= "timer1_1",
+};
 
 static int timer32_config(struct timer_s *t)
 {
-	u32 tcr = davinci_readl(t->reg_base + TCR);
-
-	/* disable timer */
-	tcr &= ~(TCR_ENAMODE_MASK << t->enamode_shift);
-	davinci_writel(tcr, t->reg_base + TCR);
-
-	/* reset counter to zero, set new period */
-	davinci_writel(0, t->tim_reg);
-	davinci_writel(t->period, t->prd_reg);
-
-	/* Set enable mode */
-	if (t->opts & TIMER_OPTS_ONESHOT) {
-		tcr |= TCR_ENAMODE_ONESHOT << t->enamode_shift;
-	} else if (t->opts & TIMER_OPTS_PERIODIC) {
-		tcr |= TCR_ENAMODE_PERIODIC << t->enamode_shift;
+	u32 tcr;
+	struct davinci_soc_info *soc_info = &davinci_soc_info;
+
+	if (USING_COMPARE(t)) {
+		struct davinci_timer_instance *dtip =
+				soc_info->timer_info->timers;
+		int event_timer = ID_TO_TIMER(timers[TID_CLOCKEVENT].id);
+
+		/*
+		 * Next interrupt should be the current time reg value plus
+		 * the new period (using 32-bit unsigned addition/wrapping
+		 * to 0 on overflow).  This assumes that the clocksource
+		 * is setup to count to 2^32-1 before wrapping around to 0.
+		 */
+		__raw_writel(__raw_readl(t->base + t->tim_off) + t->period,
+			t->base + dtip[event_timer].cmp_off);
+	} else {
+		tcr = __raw_readl(t->base + TCR);
+
+		/* disable timer */
+		tcr &= ~(TCR_ENAMODE_MASK << t->enamode_shift);
+		__raw_writel(tcr, t->base + TCR);
+
+		/* reset counter to zero, set new period */
+		__raw_writel(0, t->base + t->tim_off);
+		__raw_writel(t->period, t->base + t->prd_off);
+
+		/* Set enable mode */
+		if (t->opts & TIMER_OPTS_ONESHOT)
+			tcr |= TCR_ENAMODE_ONESHOT << t->enamode_shift;
+		else if (t->opts & TIMER_OPTS_PERIODIC)
+			tcr |= TCR_ENAMODE_PERIODIC << t->enamode_shift;
+
+		__raw_writel(tcr, t->base + TCR);
 	}
-
-	davinci_writel(tcr, t->reg_base + TCR);
 	return 0;
 }
 
 static inline u32 timer32_read(struct timer_s *t)
 {
-	return davinci_readl(t->tim_reg);
+	return __raw_readl(t->base + t->tim_off);
 }
 
 static irqreturn_t timer_interrupt(int irq, void *dev_id)
@@ -176,69 +201,73 @@ static struct timer_s timers[] = {
 
 static void __init timer_init(void)
 {
-	u32 bases[] = {DAVINCI_TIMER0_BASE, DAVINCI_TIMER1_BASE};
+	struct davinci_soc_info *soc_info = &davinci_soc_info;
+	struct davinci_timer_instance *dtip = soc_info->timer_info->timers;
 	int i;
 
 	/* Global init of each 64-bit timer as a whole */
 	for(i=0; i<2; i++) {
-		u32 tgcr, base = bases[i];
+		u32 tgcr;
+		void __iomem *base = dtip[i].base;
 
 		/* Disabled, Internal clock source */
-		davinci_writel(0, base + TCR);
+		__raw_writel(0, base + TCR);
 
 		/* reset both timers, no pre-scaler for timer34 */
 		tgcr = 0;
-		davinci_writel(tgcr, base + TGCR);
+		__raw_writel(tgcr, base + TGCR);
 
 		/* Set both timers to unchained 32-bit */
 		tgcr = TGCR_TIMMODE_32BIT_UNCHAINED << TGCR_TIMMODE_SHIFT;
-		davinci_writel(tgcr, base + TGCR);
+		__raw_writel(tgcr, base + TGCR);
 
 		/* Unreset timers */
 		tgcr |= (TGCR_UNRESET << TGCR_TIM12RS_SHIFT) |
 			(TGCR_UNRESET << TGCR_TIM34RS_SHIFT);
-		davinci_writel(tgcr, base + TGCR);
+		__raw_writel(tgcr, base + TGCR);
 
 		/* Init both counters to zero */
-		davinci_writel(0, base + TIM12);
-		davinci_writel(0, base + TIM34);
+		__raw_writel(0, base + TIM12);
+		__raw_writel(0, base + TIM34);
 	}
 
 	/* Init of each timer as a 32-bit timer */
 	for (i=0; i< ARRAY_SIZE(timers); i++) {
 		struct timer_s *t = &timers[i];
+		int timer = ID_TO_TIMER(t->id);
+		u32 irq;
+
+		t->base = dtip[timer].base;
+
+		if (IS_TIMER_BOT(t->id)) {
+			t->enamode_shift = 6;
+			t->tim_off = TIM12;
+			t->prd_off = PRD12;
+			irq = dtip[timer].bottom_irq;
+		} else {
+			t->enamode_shift = 22;
+			t->tim_off = TIM34;
+			t->prd_off = PRD34;
+			irq = dtip[timer].top_irq;
+		}
+
+		/* Register interrupt */
+		t->irqaction.name = t->name;
+		t->irqaction.dev_id = (void *)t;
 
-		if (t->name) {
-			t->id = i;
-			t->reg_base = (IS_TIMER1(t->id) ?
-			       DAVINCI_TIMER1_BASE : DAVINCI_TIMER0_BASE);
-
-			if (IS_TIMER_BOT(t->id)) {
-				t->enamode_shift = 6;
-				t->tim_reg = t->reg_base + TIM12;
-				t->prd_reg = t->reg_base + PRD12;
-			} else {
-				t->enamode_shift = 22;
-				t->tim_reg = t->reg_base + TIM34;
-				t->prd_reg = t->reg_base + PRD34;
-			}
-
-			/* Register interrupt */
-			t->irqaction.name = t->name;
-			t->irqaction.dev_id = (void *)t;
-			if (t->irqaction.handler != NULL) {
-				setup_irq(timer_irqs[t->id], &t->irqaction);
-			}
-
-			timer32_config(&timers[i]);
+		if (t->irqaction.handler != NULL) {
+			irq = USING_COMPARE(t) ? dtip[i].cmp_irq : irq;
+			setup_irq(irq, &t->irqaction);
 		}
+
+		timer32_config(&timers[i]);
 	}
 }
 
 /*
  * clocksource
  */
-static cycle_t read_cycles(void)
+static cycle_t read_cycles(struct clocksource *cs)
 {
 	struct timer_s *t = &timers[TID_CLOCKSOURCE];
 
@@ -246,7 +275,6 @@ static cycle_t read_cycles(void)
 }
 
 static struct clocksource clocksource_davinci = {
-	.name		= "timer0_1",
 	.rating		= 300,
 	.read		= read_cycles,
 	.mask		= CLOCKSOURCE_MASK(32),
@@ -274,16 +302,19 @@ static void davinci_set_mode(enum clock_event_mode mode,
 
 	switch (mode) {
 	case CLOCK_EVT_MODE_PERIODIC:
-		t->period = CLOCK_TICK_RATE / (HZ);
-		t->opts = TIMER_OPTS_PERIODIC;
+		t->period = davinci_clock_tick_rate / (HZ);
+		t->opts &= ~TIMER_OPTS_STATE_MASK;
+		t->opts |= TIMER_OPTS_PERIODIC;
 		timer32_config(t);
 		break;
 	case CLOCK_EVT_MODE_ONESHOT:
-		t->opts = TIMER_OPTS_ONESHOT;
+		t->opts &= ~TIMER_OPTS_STATE_MASK;
+		t->opts |= TIMER_OPTS_ONESHOT;
 		break;
 	case CLOCK_EVT_MODE_UNUSED:
 	case CLOCK_EVT_MODE_SHUTDOWN:
-		t->opts = TIMER_OPTS_DISABLED;
+		t->opts &= ~TIMER_OPTS_STATE_MASK;
+		t->opts |= TIMER_OPTS_DISABLED;
 		break;
 	case CLOCK_EVT_MODE_RESUME:
 		break;
@@ -291,7 +322,6 @@ static void davinci_set_mode(enum clock_event_mode mode,
 }
 
 static struct clock_event_device clockevent_davinci = {
-	.name		= "timer0_0",
 	.features       = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT,
 	.shift		= 32,
 	.set_next_event	= davinci_set_next_event,
@@ -301,26 +331,67 @@ static struct clock_event_device clockevent_davinci = {
 
 static void __init davinci_timer_init(void)
 {
+	struct clk *timer_clk;
+	struct davinci_soc_info *soc_info = &davinci_soc_info;
+	unsigned int clockevent_id;
+	unsigned int clocksource_id;
 	static char err[] __initdata = KERN_ERR
 		"%s: can't register clocksource!\n";
 
+	clockevent_id = soc_info->timer_info->clockevent_id;
+	clocksource_id = soc_info->timer_info->clocksource_id;
+
+	timers[TID_CLOCKEVENT].id = clockevent_id;
+	timers[TID_CLOCKSOURCE].id = clocksource_id;
+
+	/*
+	 * If using same timer for both clock events & clocksource,
+	 * a compare register must be used to generate an event interrupt.
+	 * This is equivalent to a oneshot timer only (not periodic).
+	 */
+	if (clockevent_id == clocksource_id) {
+		struct davinci_timer_instance *dtip =
+				soc_info->timer_info->timers;
+		int event_timer = ID_TO_TIMER(clockevent_id);
+
+		/* Only bottom timers can use compare regs */
+		if (IS_TIMER_TOP(clockevent_id))
+			pr_warning("davinci_timer_init: Invalid use"
+				" of system timers.  Results unpredictable.\n");
+		else if ((dtip[event_timer].cmp_off == 0)
+				|| (dtip[event_timer].cmp_irq == 0))
+			pr_warning("davinci_timer_init:  Invalid timer instance"
+				" setup.  Results unpredictable.\n");
+		else {
+			timers[TID_CLOCKEVENT].opts |= TIMER_OPTS_USE_COMPARE;
+			clockevent_davinci.features = CLOCK_EVT_FEAT_ONESHOT;
+		}
+	}
+
 	/* init timer hw */
 	timer_init();
 
+	timer_clk = clk_get(NULL, "timer0");
+	BUG_ON(IS_ERR(timer_clk));
+	clk_enable(timer_clk);
+
+	davinci_clock_tick_rate = clk_get_rate(timer_clk);
+
 	/* setup clocksource */
+	clocksource_davinci.name = id_to_name[clocksource_id];
 	clocksource_davinci.mult =
-		clocksource_khz2mult(CLOCK_TICK_RATE/1000,
+		clocksource_khz2mult(davinci_clock_tick_rate/1000,
 				     clocksource_davinci.shift);
 	if (clocksource_register(&clocksource_davinci))
 		printk(err, clocksource_davinci.name);
 
 	/* setup clockevent */
-	clockevent_davinci.mult = div_sc(CLOCK_TICK_RATE, NSEC_PER_SEC,
+	clockevent_davinci.name = id_to_name[timers[TID_CLOCKEVENT].id];
+	clockevent_davinci.mult = div_sc(davinci_clock_tick_rate, NSEC_PER_SEC,
 					 clockevent_davinci.shift);
 	clockevent_davinci.max_delta_ns =
 		clockevent_delta2ns(0xfffffffe, &clockevent_davinci);
-	clockevent_davinci.min_delta_ns =
-		clockevent_delta2ns(1, &clockevent_davinci);
+	clockevent_davinci.min_delta_ns = 50000; /* 50 usec */
 
 	clockevent_davinci.cpumask = cpumask_of_cpu(0);
 	clockevents_register_device(&clockevent_davinci);
@@ -332,43 +403,48 @@ struct sys_timer davinci_timer = {
 
 
 /* reset board using watchdog timer */
-void davinci_watchdog_reset(void) {
-	u32 tgcr, wdtcr, base = DAVINCI_WDOG_BASE;
+void davinci_watchdog_reset(void)
+{
+	u32 tgcr, wdtcr;
+	struct platform_device *pdev = &davinci_wdt_device;
+	void __iomem *base = IO_ADDRESS(pdev->resource[0].start);
+	struct clk *wd_clk;
+
+	wd_clk = clk_get(&pdev->dev, "timer1");
+	if (WARN_ON(IS_ERR(wd_clk)))
+		return;
+	clk_enable(wd_clk);
 
 	/* disable, internal clock source */
-	davinci_writel(0, base + TCR);
+	__raw_writel(0, base + TCR);
 
 	/* reset timer, set mode to 64-bit watchdog, and unreset */
 	tgcr = 0;
-	davinci_writel(tgcr, base + TCR);
+	__raw_writel(tgcr, base + TGCR);
 	tgcr = TGCR_TIMMODE_64BIT_WDOG << TGCR_TIMMODE_SHIFT;
 	tgcr |= (TGCR_UNRESET << TGCR_TIM12RS_SHIFT) |
 		(TGCR_UNRESET << TGCR_TIM34RS_SHIFT);
-	davinci_writel(tgcr, base + TCR);
+	__raw_writel(tgcr, base + TGCR);
 
 	/* clear counter and period regs */
-	davinci_writel(0, base + TIM12);
-	davinci_writel(0, base + TIM34);
-	davinci_writel(0, base + PRD12);
-	davinci_writel(0, base + PRD34);
-
-	/* enable */
-	wdtcr = davinci_readl(base + WDTCR);
-	wdtcr |= WDTCR_WDEN_ENABLE << WDTCR_WDEN_SHIFT;
-	davinci_writel(wdtcr, base + WDTCR);
+	__raw_writel(0, base + TIM12);
+	__raw_writel(0, base + TIM34);
+	__raw_writel(0, base + PRD12);
+	__raw_writel(0, base + PRD34);
 
 	/* put watchdog in pre-active state */
+	wdtcr = __raw_readl(base + WDTCR);
 	wdtcr = (WDTCR_WDKEY_SEQ0 << WDTCR_WDKEY_SHIFT) |
 		(WDTCR_WDEN_ENABLE << WDTCR_WDEN_SHIFT);
-	davinci_writel(wdtcr, base + WDTCR);
+	__raw_writel(wdtcr, base + WDTCR);
 
 	/* put watchdog in active state */
 	wdtcr = (WDTCR_WDKEY_SEQ1 << WDTCR_WDKEY_SHIFT) |
 		(WDTCR_WDEN_ENABLE << WDTCR_WDEN_SHIFT);
-	davinci_writel(wdtcr, base + WDTCR);
+	__raw_writel(wdtcr, base + WDTCR);
 
 	/* write an invalid value to the WDKEY field to trigger
 	 * a watchdog reset */
 	wdtcr = 0x00004000;
-	davinci_writel(wdtcr, base + WDTCR);
+	__raw_writel(wdtcr, base + WDTCR);
 }
diff --git a/arch/arm/mach-davinci/usb.c b/arch/arm/mach-davinci/usb.c
new file mode 100644
index 0000000..4ced9c2
--- /dev/null
+++ b/arch/arm/mach-davinci/usb.c
@@ -0,0 +1,159 @@
+/*
+ * USB
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+
+#include <linux/usb/musb.h>
+#include <linux/usb/otg.h>
+
+#include <mach/common.h>
+#include <mach/hardware.h>
+#include <mach/irqs.h>
+#include <mach/cputype.h>
+#include <mach/mux.h>
+#include <mach/usb.h>
+
+
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
+
+#define DA8XX_USB0_BASE     0x01e00000
+#define DA8XX_USB1_BASE     0x01e25000
+
+struct  da8xx_ohci_root_hub da8xx_ohci_rh_data = {0, 0, 0, 0, 1};
+static struct resource da8xx_ohci_resources[] = {
+	{
+		/* physical address */
+		.start  =   DA8XX_USB1_BASE,
+		.end    =   DA8XX_USB1_BASE + 0xfff,
+		.flags  =   IORESOURCE_MEM,
+	},
+	{
+		.start  =   IRQ_DA8XX_IRQN,
+		.flags  =   IORESOURCE_IRQ,
+	}
+};
+
+static u64 da8xx_usb1_dma_mask = ~(u32)0;
+static struct platform_device da8xx_ohci_device = {
+	.name   = "usb_ohci",
+	.id = -1,
+	.dev = {
+		.platform_data          = &da8xx_ohci_rh_data,
+		.dma_mask               = &da8xx_usb1_dma_mask,
+		.coherent_dma_mask      = 0xffffffff,
+	},
+	.num_resources  = ARRAY_SIZE(da8xx_ohci_resources),
+	.resource       = da8xx_ohci_resources,
+};
+
+int __init da8xx_register_ohci(void)
+{
+	if(!cpu_is_davinci_da830())
+		return 0;
+
+	return platform_device_register(&da8xx_ohci_device);
+}
+#else
+int __init da8xx_register_ohci(void)
+{
+	return 0;
+}
+#endif /*CONFIG_USB_OHCI_HCD*/
+
+#define DAVINCI_USB_OTG_BASE 0x01E00000
+
+#if defined(CONFIG_USB_MUSB_HDRC) || defined(CONFIG_USB_MUSB_HDRC_MODULE)
+static struct musb_hdrc_eps_bits musb_eps[] = {
+	{ "ep1_tx", 8, },
+	{ "ep1_rx", 8, },
+	{ "ep2_tx", 8, },
+	{ "ep2_rx", 8, },
+	{ "ep3_tx", 5, },
+	{ "ep3_rx", 5, },
+	{ "ep4_tx", 5, },
+	{ "ep4_rx", 5, },
+};
+
+static struct musb_hdrc_config musb_config = {
+	.multipoint	= true,
+	.dyn_fifo	= true,
+	.soft_con	= true,
+	.dma		= true,
+
+	.num_eps	= 5,
+	.dma_channels	= 8,
+	.ram_bits	= 10,
+	.eps_bits	= musb_eps,
+};
+
+static struct musb_hdrc_platform_data usb_data = {
+#if defined(CONFIG_USB_MUSB_OTG)
+	/* OTG requires a Mini-AB connector */
+	.mode           = MUSB_OTG,
+#elif defined(CONFIG_USB_MUSB_PERIPHERAL)
+	.mode           = MUSB_PERIPHERAL,
+#elif defined(CONFIG_USB_MUSB_HOST)
+	.mode           = MUSB_HOST,
+#endif
+	.clock		= "usb20",
+	.config		= &musb_config,
+};
+
+static struct resource usb_resources[] = {
+	{
+		/* physical address */
+		.start          = DAVINCI_USB_OTG_BASE,
+		.end            = DAVINCI_USB_OTG_BASE + 0xffff,
+		.flags          = IORESOURCE_MEM,
+	},
+	{
+		.start          = IRQ_USBINT,
+		.flags          = IORESOURCE_IRQ,
+	},
+	{
+		/* placeholder for the dedicated CPPI IRQ */
+		.flags          = IORESOURCE_IRQ,
+	},
+};
+
+static u64 usb_dmamask = DMA_BIT_MASK(32);
+
+static struct platform_device usb_dev = {
+	.name           = "musb_hdrc",
+	.id             = -1,
+	.dev = {
+		.platform_data		= &usb_data,
+		.dma_mask		= &usb_dmamask,
+		.coherent_dma_mask      = DMA_BIT_MASK(32),
+	},
+	.resource       = usb_resources,
+	.num_resources  = ARRAY_SIZE(usb_resources),
+};
+
+void __init setup_usb(unsigned mA, unsigned potpgt_msec)
+{
+	usb_data.power = mA / 2;
+	usb_data.potpgt = potpgt_msec / 2;
+
+	if (cpu_is_davinci_da830()) {
+		usb_dev.resource[1].start = IRQ_DA8XX_USB_INT;
+		davinci_cfg_reg(DA830_USB0_DRVVBUS);
+		usb_dev.num_resources = 2;
+	} else	/* other devices don't have dedicated CPPI IRQ */
+		usb_dev.num_resources = 2;
+
+	platform_device_register(&usb_dev);
+}
+
+#else
+
+void __init setup_usb(unsigned mA, unsigned potpgt_msec)
+{
+}
+
+#endif  /* CONFIG_USB_MUSB_HDRC */
+
-- 
1.6.5.2

