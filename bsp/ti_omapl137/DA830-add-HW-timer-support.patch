From 21601561e4a5d8c77b59f15ef8627cd730620ae3 Mon Sep 17 00:00:00 2001
From: Tonyliu <Bo.Liu@windriver.com>
Date: Thu, 22 Oct 2009 16:57:40 +0800
Subject: [PATCH 11/14] DA830: add HW timer support

There are 2 GP timers on da830, use GP timer 2 as HW timer.

Signed-off-by: Tonyliu <Bo.Liu@windriver.com>
---
 arch/arm/mach-davinci/time.c |  220 ++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 220 insertions(+), 0 deletions(-)

diff --git a/arch/arm/mach-davinci/time.c b/arch/arm/mach-davinci/time.c
index ede90aa..3de3fb9 100644
--- a/arch/arm/mach-davinci/time.c
+++ b/arch/arm/mach-davinci/time.c
@@ -32,6 +32,10 @@
 #include <mach/time.h>
 #include "clock.h"
 
+#ifdef  CONFIG_HWTIMER_HOOKS
+#include <linux/hwtimer.h>
+#endif
+
 static struct clock_event_device clockevent_davinci;
 static unsigned int davinci_clock_tick_rate;
 
@@ -54,6 +58,9 @@ enum {
 #define TCR			0x20
 #define TGCR			0x24
 #define WDTCR			0x28
+#define REL12			0x34
+#define REL34			0x38
+#define TINTCSR			0x44
 
 /* Offsets of the 8 compare registers */
 #define	CMP12_0			0x60
@@ -90,6 +97,12 @@ enum {
 #define WDTCR_WDKEY_SEQ0             0xa5c6
 #define WDTCR_WDKEY_SEQ1             0xda7e
 
+#define TINTCSR_PRDINTSTAT           0x1
+#define TINTCSR_PRDINTSTAT_SHIFT     1
+#define TINTCSR_PRDINTEN             0x1
+#define TINTCSR_PRDINTEN_SHIFT       0
+
+
 struct timer_s {
 	char *name;
 	unsigned int id;
@@ -165,6 +178,208 @@ static inline u32 timer32_read(struct timer_s *t)
 	return __raw_readl(t->base + t->tim_off);
 }
 
+#ifdef  CONFIG_HWTIMER_HOOKS
+
+static irqreturn_t da830_clockapi_timer_interrupt(int irq, void *dev_id);
+
+static struct clk *clockapi_timer_clk;
+static struct timer_s *hw_timer;
+
+static struct timer_s gp_timer_2_clockapi = {
+	.id   = T1_BOT,
+	.opts = TIMER_OPTS_PERIODIC,
+	.irqaction = {
+		.flags      = IRQF_DISABLED,
+		.handler    = da830_clockapi_timer_interrupt,
+   },
+};
+
+static struct hwtimer_data clockapi_timer_data = {
+	name: "da830 hw timer",
+	desc: "da830 gp timer 2",
+	def_freq: 2,
+	min_freq: 2,
+	max_freq: 8192
+};
+
+static int clockapi_timer_get_freq(void);
+static int clockapi_timer_set_freq(int freq);
+static int clockapi_timer_start(void);
+static int clockapi_timer_stop(void);
+
+static DECLARE_HWTIMER_LOCK(clockapi_timer_lock);
+static unsigned int current_freq;
+
+static struct hwtimer clockapi_timer = {
+	data: &clockapi_timer_data,
+	set_freq: clockapi_timer_set_freq,
+	get_freq: clockapi_timer_get_freq,
+	start: clockapi_timer_start,
+	stop: clockapi_timer_stop,
+	lock: &clockapi_timer_lock,
+	hook: NULL,
+	hook_data: NULL
+};
+
+static irqreturn_t da830_clockapi_timer_interrupt(int irq, void *dev_id)
+{
+	struct timer_s *t = (struct timer_s *)dev_id;
+
+	__raw_writel(__raw_readl(t->base + TINTCSR),
+		t->base + TINTCSR);
+
+	spin_lock(clockapi_timer.lock);
+	if(clockapi_timer.hook != NULL)
+		clockapi_timer.hook(clockapi_timer.hook_data);
+	spin_unlock(clockapi_timer.lock);
+
+	return IRQ_HANDLED;
+}
+
+static int clockapi_timer_get_freq(void)
+{
+	return current_freq;
+}
+
+static int clockapi_timer_set_freq(int freq)
+{
+	BUG_ON(IS_ERR(clockapi_timer_clk));
+
+	if ((freq < clockapi_timer.data->min_freq) ||
+		(freq > clockapi_timer.data->max_freq))
+		return -EINVAL;
+
+	hw_timer->period =  CLOCK_TICK_RATE / freq;
+	hw_timer->period -= 1;
+
+	/* reset counter to zero, set new period */
+	__raw_writel(0, hw_timer->base + hw_timer->tim_off);
+	__raw_writel(hw_timer->period, hw_timer->base + hw_timer->prd_off);
+
+	current_freq = freq;
+	return 0;
+}
+
+static int clockapi_timer_start(void)
+{
+	u32 ticsr, tgcr;
+
+	clockapi_timer_clk = clk_get(NULL, "timer1");
+	BUG_ON(IS_ERR(clockapi_timer_clk));
+	clk_enable(clockapi_timer_clk);
+
+	ticsr = __raw_readl(hw_timer->base + TINTCSR);
+	tgcr = __raw_readl(hw_timer->base + TGCR);
+
+	/*Enable interrupt generation*/
+	if (IS_TIMER_BOT(hw_timer->id))
+		tgcr &= ~(TGCR_UNRESET << TGCR_TIM12RS_SHIFT);
+	else
+		tgcr &= ~(TGCR_UNRESET << TGCR_TIM34RS_SHIFT);
+
+	__raw_writel(tgcr, hw_timer->base + TGCR);
+
+	if (IS_TIMER_BOT(hw_timer->id)) {
+		ticsr |= (TINTCSR_PRDINTEN  << TINTCSR_PRDINTEN_SHIFT);
+		tgcr |= (TGCR_UNRESET << TGCR_TIM12RS_SHIFT);
+	} else {
+		ticsr |= (TINTCSR_PRDINTEN  << (TINTCSR_PRDINTEN_SHIFT + 16));
+		tgcr |= (TGCR_UNRESET << TGCR_TIM34RS_SHIFT);
+	}
+
+	__raw_writel(tgcr, hw_timer->base + TGCR);
+	__raw_writel(ticsr, hw_timer->base + TINTCSR);
+
+	return 0;
+}
+
+static int clockapi_timer_stop(void)
+{
+	u32 ticsr, tgcr;
+
+	ticsr = __raw_readl(hw_timer->base + TINTCSR);
+	tgcr = __raw_readl(hw_timer->base + TGCR);
+
+	/*Disable interrupt generation*/
+	if (IS_TIMER_BOT(hw_timer->id)) {
+		ticsr &= ~(TINTCSR_PRDINTEN  << TINTCSR_PRDINTEN_SHIFT);
+		tgcr &= ~(TGCR_UNRESET << TGCR_TIM12RS_SHIFT);
+	} else {
+		ticsr &= ~(TINTCSR_PRDINTEN  << (TINTCSR_PRDINTEN_SHIFT + 16));
+		tgcr &= ~(TGCR_UNRESET << TGCR_TIM34RS_SHIFT);
+	}
+
+	__raw_writel(ticsr, hw_timer->base + TINTCSR);
+	__raw_writel(tgcr, hw_timer->base + TGCR);
+
+	clk_disable(clockapi_timer_clk);
+
+	return 0;
+}
+
+static void clockapi_timer_init(void)
+{
+	struct davinci_soc_info *soc_info = &davinci_soc_info;
+    struct davinci_timer_instance *dtip = soc_info->timer_info->timers;
+	struct clk *timer_clk;
+	int irq, timer;
+	u32 tcr, tgcr;
+
+	hw_timer = &gp_timer_2_clockapi;
+	timer = ID_TO_TIMER(hw_timer->id);
+	hw_timer->base = dtip[timer].base;
+
+	tcr = __raw_readl(hw_timer->base + TCR);
+	tgcr = __raw_readl(hw_timer->base + TGCR);
+
+	if (IS_TIMER_BOT(hw_timer->id)) {
+		tcr &= 0xffff0000;
+		tgcr &= ~(TGCR_UNRESET << TGCR_TIM12RS_SHIFT);
+
+		hw_timer->enamode_shift = 6;
+		hw_timer->tim_off = TIM12;
+		hw_timer->prd_off = PRD12;
+
+		irq = dtip[timer].bottom_irq;
+	} else {
+		tcr &= 0x0000ffff;
+		tgcr &= ~(TGCR_UNRESET << TGCR_TIM34RS_SHIFT);
+
+		hw_timer->enamode_shift = 22;
+		hw_timer->tim_off = TIM34;
+		hw_timer->prd_off = PRD34;
+
+		irq = dtip[timer].top_irq;
+	}
+
+	/* Disabled, Internal clock source */
+	__raw_writel(tcr, hw_timer->base + TCR);
+
+	/*reset timer, Set timer to unchained 32-bit*/
+	tgcr |= TGCR_TIMMODE_32BIT_UNCHAINED << TGCR_TIMMODE_SHIFT;
+	__raw_writel(tgcr, hw_timer->base + TGCR);
+
+	if (IS_TIMER_BOT(hw_timer->id))
+		__raw_writel(0, hw_timer->base + TIM12);
+	else
+		__raw_writel(0, hw_timer->base + TIM34);
+
+	/* Register interrupt */
+	hw_timer->irqaction.dev_id = (void *)hw_timer;
+
+	if(hw_timer->irqaction.handler)
+		setup_irq(irq, &hw_timer->irqaction);
+
+	timer_clk = clk_get(NULL, "timer1");
+	BUG_ON(IS_ERR(timer_clk));
+
+	hw_timer->period = clk_get_rate(timer_clk) / clockapi_timer_data.def_freq;
+	current_freq = clockapi_timer_data.def_freq;
+
+	timer32_config(hw_timer);
+}
+#endif
+
 static irqreturn_t timer_interrupt(int irq, void *dev_id)
 {
 	struct clock_event_device *evt = &clockevent_davinci;
@@ -395,6 +610,11 @@ static void __init davinci_timer_init(void)
 
 	clockevent_davinci.cpumask = cpumask_of_cpu(0);
 	clockevents_register_device(&clockevent_davinci);
+
+#ifdef CONFIG_HWTIMER_HOOKS
+	clockapi_timer_init();
+	register_hwtimer(&clockapi_timer);
+#endif
 }
 
 struct sys_timer davinci_timer = {
-- 
1.6.5.2

