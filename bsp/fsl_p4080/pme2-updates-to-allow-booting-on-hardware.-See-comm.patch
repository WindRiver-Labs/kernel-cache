From d86bcb6e1c651e82de877aafdcee9c00793bd607 Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Thu, 17 Sep 2009 20:47:38 -0400
Subject: [PATCH] pme2: updates to allow booting on hardware. See commit log for details.

* rev v1.0 appears to implement 'cmd' reflection in PME responses, which
  was not expected until v1.1, so pme_fd_res_flags() needs to mask these.
* pme_ctx_ctrl_***() operations do not detect if PME responses include
  errors (the return code indicates whether the operation was issued or
  not), so add pme_ctx_is_dead().
* update comments for pme_ctx_ctrl_***() APIs to explain semantics.
* add FAMCR, SMCR, and DMCR registers to the sysfs interface, and properly
  initialise them for coherency. NB: long-term it should be possible to
  require only *data* operations to be coherent, but the DMA code in the
  kernel arch does not yet support this.
* don't initialise h/w flow contexts from s/w (better to use update_flow
  to have h/w initialise its own resources). Only initialise s/w flow
  contexts, so update_flow() can be used with an allocated flow to achieve
  sane defaults.
* fix inverted FAMCR/PMSTAT register offsets.
* fix the /dev/pme_scan user-interface and the kernel tests to update_flow
  contexts before using them.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
[Kevin: Original patch taken from Freescale p4080 SDK 2.0 ISO image.
Apply cleanly to kernel 2.6.27]
Integrated-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/match/pme2_ctrl.c      |   42 ++++++++++++++++++++++
 drivers/match/pme2_high.c      |    6 +++
 drivers/match/pme2_low.c       |   29 +++++++++++-----
 drivers/match/pme2_regs.h      |    4 +-
 drivers/match/pme2_scan.c      |   19 +++++++++-
 drivers/match/pme2_test_high.c |   39 +++++++++++++--------
 drivers/match/pme2_test_scan.c |   75 ++++++++++++++++++++++------------------
 include/linux/fsl_pme.h        |   18 ++++++++-
 8 files changed, 169 insertions(+), 63 deletions(-)

diff --git a/drivers/match/pme2_ctrl.c b/drivers/match/pme2_ctrl.c
index e3159f4..4c80df8 100644
--- a/drivers/match/pme2_ctrl.c
+++ b/drivers/match/pme2_ctrl.c
@@ -205,6 +205,18 @@ static inline struct pme *pme_create(void *regs)
 	pme_out(res, FACONF, 0);
 	pme_out(res, EFQC, PME_EFQC(0, 0));
 	pme_out(res, FACONF, PME_FACONF_ENABLE);
+	/* TODO: these coherency settings for PMFA, DXE, and SRE force all
+	 * transactions to snoop, as the kernel does not yet support flushing in
+	 * dma_map_***() APIs (ie. h/w can not treat otherwise coherent memory
+	 * in a non-coherent manner, temporarily or otherwise). When the kernel
+	 * supports this, we should tune these settings back to;
+	 *     FAMCR = 0x00010001
+	 *      DMCR = 0x00000000
+	 *      SMCR = 0x00000000
+	 */
+	pme_out(res, FAMCR, 0x01010101);
+	pme_out(res, DMCR, 0x00000001);
+	pme_out(res, SMCR, 0x00000211);
 	return res;
 }
 
@@ -358,6 +370,9 @@ static DRIVER_ATTR(update_interval, (S_IRUSR | S_IWUSR),
 /* read-write; */
 PME_GENERIC_ATTR(efqc_int, PRIV_RW, FMT_DEC);
 PME_GENERIC_ATTR(sw_db, PRIV_RW, FMT_DEC);
+PME_GENERIC_ATTR(dmcr, PRIV_RW, FMT_0HEX);
+PME_GENERIC_ATTR(smcr, PRIV_RW, FMT_0HEX);
+PME_GENERIC_ATTR(famcr, PRIV_RW, FMT_0HEX);
 PME_GENERIC_ATTR(kvlts, PRIV_RW, FMT_DEC);
 PME_GENERIC_ATTR(max_chain_length, PRIV_RW, FMT_DEC);
 PME_GENERIC_ATTR(pattern_range_counter_idx, PRIV_RW, FMT_0HEX);
@@ -480,6 +495,9 @@ PME_GENERIC_STAT_ATTR(mia_blc, PRIV_RW);
 static struct attribute *pme_drv_attrs[] = {
 	&driver_attr_efqc_int.attr,
 	&driver_attr_sw_db.attr,
+	&driver_attr_dmcr.attr,
+	&driver_attr_smcr.attr,
+	&driver_attr_famcr.attr,
 	&driver_attr_kvlts.attr,
 	&driver_attr_max_chain_length.attr,
 	&driver_attr_pattern_range_counter_idx.attr,
@@ -862,6 +880,18 @@ int pme_attr_set(enum pme_attr attr, u32 val)
 		pme_out(global_pme, SWDB, val);
 		break;
 
+	case pme_attr_dmcr:
+		pme_out(global_pme, DMCR, val);
+		break;
+
+	case pme_attr_smcr:
+		pme_out(global_pme, SMCR, val);
+		break;
+
+	case pme_attr_famcr:
+		pme_out(global_pme, FAMCR, val);
+		break;
+
 	case pme_attr_kvlts:
 		if (val < 2 || val > 16)
 			return -EINVAL;
@@ -1069,6 +1099,18 @@ int pme_attr_get(enum pme_attr attr, u32 *val)
 		attr_val = pme_in(global_pme, SWDB);
 		break;
 
+	case pme_attr_dmcr:
+		attr_val = pme_in(global_pme, DMCR);
+		break;
+
+	case pme_attr_smcr:
+		attr_val = pme_in(global_pme, SMCR);
+		break;
+
+	case pme_attr_famcr:
+		attr_val = pme_in(global_pme, FAMCR);
+		break;
+
 	case pme_attr_kvlts:
 		/* bit 28-31 */
 		attr_val = pme_in(global_pme, KVLTS);
diff --git a/drivers/match/pme2_high.c b/drivers/match/pme2_high.c
index 74268d4..2d027af 100644
--- a/drivers/match/pme2_high.c
+++ b/drivers/match/pme2_high.c
@@ -348,6 +348,12 @@ int pme_ctx_is_disabled(struct pme_ctx *ctx)
 }
 EXPORT_SYMBOL(pme_ctx_is_disabled);
 
+int pme_ctx_is_dead(struct pme_ctx *ctx)
+{
+	return (ctx->flags & PME_CTX_FLAG_DEAD);
+}
+EXPORT_SYMBOL(pme_ctx_is_dead);
+
 int pme_ctx_disable(struct pme_ctx *ctx, u32 flags)
 {
 	struct qm_mcc_initfq initfq;
diff --git a/drivers/match/pme2_low.c b/drivers/match/pme2_low.c
index 27b5e9e..9fb47df 100644
--- a/drivers/match/pme2_low.c
+++ b/drivers/match/pme2_low.c
@@ -143,13 +143,6 @@ EXPORT_SYMBOL(pme_hw_residue_free);
 struct pme_hw_flow *pme_hw_flow_new(void)
 {
 	struct pme_flow *flow = kmem_cache_zalloc(slab_flow, GFP_KERNEL);
-	if(likely(flow)){
-		flow->sos=1;
-		flow->esee=1;
-		flow->clim=0xffff;
-		flow->mlim=0xffff;
-		flow_map(flow);
-	}
 	return (struct pme_hw_flow *)flow;
 }
 EXPORT_SYMBOL(pme_hw_flow_new);
@@ -160,15 +153,33 @@ void pme_hw_flow_free(struct pme_hw_flow *p)
 }
 EXPORT_SYMBOL(pme_hw_flow_free);
 
+static const struct pme_flow default_sw_flow = {
+	.sos = 1,
+	.srvm = 0,
+	.esee = 1,
+	.ren = 0,
+	.rlen = 0,
+	.seqnum_hi = 0,
+	.seqnum_lo = 0,
+	.sessionid = 0x7ffffff,
+	.rptr_hi = 0,
+	.rptr_lo = 0,
+	.clim = 0xffff,
+	.mlim = 0xffff
+};
+
 struct pme_flow *pme_sw_flow_new(void)
 {
-	return (struct pme_flow *)pme_hw_flow_new();
+	struct pme_flow *flow = kmem_cache_zalloc(slab_flow, GFP_KERNEL);
+	if (likely(flow))
+		memcpy(flow, &default_sw_flow, sizeof(*flow));
+	return flow;
 }
 EXPORT_SYMBOL(pme_sw_flow_new);
 
 void pme_sw_flow_free(struct pme_flow *p)
 {
-	pme_hw_flow_free((struct pme_hw_flow *)p);
+	kmem_cache_free(slab_flow, p);
 }
 EXPORT_SYMBOL(pme_sw_flow_free);
 
diff --git a/drivers/match/pme2_regs.h b/drivers/match/pme2_regs.h
index 6ac4f44..05799ff 100644
--- a/drivers/match/pme2_regs.h
+++ b/drivers/match/pme2_regs.h
@@ -46,8 +46,8 @@
 #define PME_REG_ECR0		0x034
 #define PME_REG_EFQC		0x050
 #define PME_REG_FACONF		0x060
-#define PME_REG_FAMCR		0x064
-#define PME_REG_PMSTAT		0x068
+#define PME_REG_PMSTAT		0x064
+#define PME_REG_FAMCR		0x068
 #define PME_REG_PMTR		0x06C
 #define PME_REG_PEHD		0x074
 #define PME_REG_BSC0		0x080
diff --git a/drivers/match/pme2_scan.c b/drivers/match/pme2_scan.c
index 9b29c80..ce23a50 100644
--- a/drivers/match/pme2_scan.c
+++ b/drivers/match/pme2_scan.c
@@ -486,12 +486,17 @@ static int fsl_pme2_scan_open(struct inode *node, struct file *fp)
 {
 	int ret;
 	struct scan_session *session;
+	struct pme_flow *flow = pme_sw_flow_new();
 #ifdef CONFIG_FSL_PME2_SCAN_DEBUG
 	pr_info("pme2_scan: open %d\n", smp_processor_id());
 #endif
+	if (!flow)
+		return -ENOMEM;
 	fp->private_data = kzalloc(sizeof(*session), GFP_KERNEL);
-	if (!fp->private_data)
+	if (!fp->private_data) {
+		pme_sw_flow_free(flow);
 		return -ENOMEM;
+	}
 	session = (struct scan_session *)fp->private_data;
 	/* Set up the structures used for asynchronous requests */
 	init_waitqueue_head(&session->waiting_for_completion);
@@ -517,12 +522,24 @@ static int fsl_pme2_scan_open(struct inode *node, struct file *fp)
 		pme_ctx_finish(&session->ctx);
 		goto exit;
 	}
+	/* Update flow to set sane defaults in the flow context */
+	/* TODO: because we free 'flow' here, we need to be uninterruptible. */
+	ret = pme_ctx_ctrl_update_flow(&session->ctx,
+			PME_CTX_OP_WAIT | PME_CMD_FCW_ALL, flow);
+	if (ret) {
+		pr_info("pme2_scan: error updating flow ctx %d\n", ret);
+		pme_ctx_disable(&session->ctx, PME_CTX_OP_WAIT);
+		pme_ctx_finish(&session->ctx);
+		goto exit;
+	}
+	pme_sw_flow_free(flow);
 #ifdef CONFIG_FSL_PME2_SCAN_DEBUG
 	/* Set up the structures used for asynchronous requests */
 	pr_info("pme2_scan: Finish pme_scan open %d \n", smp_processor_id());
 #endif
 	return 0;
 exit:
+	pme_sw_flow_free(flow);
 	kfree(fp->private_data);
 	fp->private_data = NULL;
 	return ret;
diff --git a/drivers/match/pme2_test_high.c b/drivers/match/pme2_test_high.c
index 2a99fd4..8d2f7d9 100644
--- a/drivers/match/pme2_test_high.c
+++ b/drivers/match/pme2_test_high.c
@@ -38,9 +38,10 @@ MODULE_DESCRIPTION("FSL PME2 (p4080) high-level self-test");
 
 /* Default Flow Context State */
 static u8 fl_ctx_exp[]={
-	0x88,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,
-	0x00,0x00,0x00,0x00
+	0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xe0,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00
 };
 
 void scan_cb(struct pme_ctx *ctx, const struct qm_fd *fd,
@@ -50,6 +51,12 @@ void scan_cb(struct pme_ctx *ctx, const struct qm_fd *fd,
 	hexdump(fd, sizeof(*fd));
 }
 
+#define POST_CTRL() \
+do { \
+	BUG_ON(ret); \
+	BUG_ON(pme_ctx_is_dead(&ctx)); \
+} while (0)
+
 void pme2_test_high(void)
 {
 	struct pme_flow *flow;
@@ -64,14 +71,16 @@ void pme2_test_high(void)
 	pr_info("PME2: high-level test starting\n");
 
 	ret = pme_ctx_init(&ctx, PME_CTX_FLAG_LOCAL, 0, 4, 4, 0, NULL);
-	BUG_ON(ret);
+	POST_CTRL();
 	/* enable the context */
 	pme_ctx_enable(&ctx);
+	ret = pme_ctx_ctrl_update_flow(&ctx, PME_CTX_OP_WAIT | PME_CMD_FCW_ALL,
+					flow);
+	POST_CTRL();
 	/* read back flow settings */
-	ret = pme_ctx_ctrl_read_flow(&ctx,
-		PME_CTX_OP_WAIT | PME_CTX_OP_WAIT_INT | PME_CMD_FCW_ALL, flow);
-	BUG_ON(ret);
-	if (memcmp(flow,fl_ctx_exp, sizeof(*flow))!= 0) {
+	ret = pme_ctx_ctrl_read_flow(&ctx, PME_CTX_OP_WAIT, flow);
+	POST_CTRL();
+	if (memcmp(flow, fl_ctx_exp, sizeof(*flow))) {
 		pr_info("Default Flow Context Read FAIL\n");
 		pr_info("Expected:\n");
 		hexdump(fl_ctx_exp, sizeof(fl_ctx_exp));
@@ -82,15 +91,15 @@ void pme2_test_high(void)
 		pr_info("Default Flow Context Read OK\n");
 	/* start a non-blocking NOP */
 	ret = pme_ctx_ctrl_nop(&ctx, 0);
-	BUG_ON(ret);
+	POST_CTRL();
 	/* start a blocking update (implicitly blocks on NOP-completion) to add
 	 * residue to the context */
 	flow->ren = 1;
-	ret = pme_ctx_ctrl_update_flow(&ctx,
-		PME_CTX_OP_WAIT | PME_CTX_OP_WAIT_INT | PME_CMD_FCW_RES, flow);
-	BUG_ON(ret);
+	ret = pme_ctx_ctrl_update_flow(&ctx, PME_CTX_OP_WAIT | PME_CMD_FCW_RES,
+					flow);
+	POST_CTRL();
 	/* start a blocking disable */
-	ret = pme_ctx_disable(&ctx, PME_CTX_OP_WAIT | PME_CTX_OP_WAIT_INT);
+	ret = pme_ctx_disable(&ctx, PME_CTX_OP_WAIT);
 	BUG_ON(ret);
 	/* do some reconfiguration */
 	ret = pme_ctx_reconfigure_tx(&ctx, 63, 7);
@@ -107,12 +116,12 @@ void pme2_test_high(void)
 	/* read back flow settings */
 	ret = pme_ctx_ctrl_read_flow(&ctx,
 		PME_CTX_OP_WAIT | PME_CTX_OP_WAIT_INT | PME_CMD_FCW_RES, flow);
-	BUG_ON(ret);
+	POST_CTRL();
 	pr_info("read Flow Context;\n");
 	hexdump(flow, sizeof(*flow));
 	/* blocking NOP */
 	ret = pme_ctx_ctrl_nop(&ctx, PME_CTX_OP_WAIT | PME_CTX_OP_WAIT_INT);
-	BUG_ON(ret);
+	POST_CTRL();
 	/* Disable, and done */
 	ret = pme_ctx_disable(&ctx, PME_CTX_OP_WAIT | PME_CTX_OP_WAIT_INT);
 	BUG_ON(ret);
diff --git a/drivers/match/pme2_test_scan.c b/drivers/match/pme2_test_scan.c
index 7226499..7758b37 100644
--- a/drivers/match/pme2_test_scan.c
+++ b/drivers/match/pme2_test_scan.c
@@ -33,14 +33,23 @@
 #include "pme2_test.h"
 
 static u8 scan_result_direct_mode_inc_mode[] = {
-	0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,
-	0x00,0x00
+	0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00
 };
 
 static u8 fl_ctx_exp[] = {
-	0x88,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
-	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,
-	0x00,0x00,0x00,0x00
+	0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xe0,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00
+};
+
+/* same again with 'sos' bit cleared */
+static u8 fl_ctx_exp_post_scan[] = {
+	0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xe0,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00
 };
 
 struct scan_ctx {
@@ -276,18 +285,16 @@ void pme2_test_scan(void)
 	pme_ctx_enable(&a_scan_ctx.base_ctx);
 	pr_info("st: Context Enabled\n");
 
+	ret = pme_ctx_ctrl_update_flow(&a_scan_ctx.base_ctx,
+		PME_CTX_OP_WAIT | PME_CMD_FCW_ALL, flow);
+	BUG_ON(ret);
+
 	/* read back flow settings */
 	{
-		struct pme_flow* rb_flow;
-		rb_flow = pme_sw_flow_new();
-		memset(rb_flow, 0, sizeof(struct pme_flow));
-		pr_info("st: Initial rb_flow\n");
-		hexdump(rb_flow, sizeof(*rb_flow));
+		struct pme_flow *rb_flow = pme_sw_flow_new();
 
 		ret = pme_ctx_ctrl_read_flow(&a_scan_ctx.base_ctx,
-			PME_CTX_OP_WAIT |
-			PME_CTX_OP_WAIT_INT |
-			PME_CMD_FCW_ALL, rb_flow);
+					PME_CTX_OP_WAIT, rb_flow);
 		BUG_ON(ret);
 		if (memcmp(rb_flow,fl_ctx_exp, sizeof(*rb_flow)) != 0) {
 			pr_info("st: Flow Context Read FAIL\n");
@@ -302,7 +309,6 @@ void pme2_test_scan(void)
 		pme_sw_flow_free(rb_flow);
 	}
 
-
 	/* Do a pre-built output, scan with match test */
 	/* Build a frame descriptor */
 	memset(&fd, 0, sizeof(struct qm_fd));
@@ -345,21 +351,17 @@ void pme2_test_scan(void)
 
 	/* read back flow settings */
 	{
-		struct pme_flow *rb_flow;
-		rb_flow = pme_sw_flow_new();
-		memset(rb_flow, 0, sizeof(struct pme_flow));
-		pr_info("st: Initial rb_flow\n");
-		hexdump(rb_flow, sizeof(*rb_flow));
+		struct pme_flow *rb_flow = pme_sw_flow_new();
 
 		ret = pme_ctx_ctrl_read_flow(&a_scan_ctx.base_ctx,
-			PME_CTX_OP_WAIT |
-			PME_CTX_OP_WAIT_INT |
-			PME_CMD_FCW_ALL, rb_flow);
+					PME_CTX_OP_WAIT, rb_flow);
 		BUG_ON(ret);
-		if (memcmp(rb_flow,fl_ctx_exp, sizeof(*rb_flow)) != 0) {
+		if (memcmp(rb_flow, fl_ctx_exp_post_scan,
+					sizeof(*rb_flow)) != 0) {
 			pr_info("st: Flow Context Read FAIL\n");
 			pr_info("st: Expected\n");
-			hexdump(fl_ctx_exp, sizeof(fl_ctx_exp));
+			hexdump(fl_ctx_exp_post_scan,
+				sizeof(fl_ctx_exp_post_scan));
 			pr_info("st: Received\n");
 			hexdump(rb_flow, sizeof(*rb_flow));
 			BUG_ON(1);
@@ -398,22 +400,27 @@ void pme2_test_scan(void)
 
 	/* read back flow settings */
 	{
-		struct pme_flow *rb_flow;
-		rb_flow = pme_sw_flow_new();
-		memset(rb_flow, 0, sizeof(struct pme_flow));
+		struct pme_flow *rb_flow = pme_sw_flow_new();
 		ret = pme_ctx_ctrl_read_flow(&a_scan_ctx.base_ctx,
-			PME_CTX_OP_WAIT |
-			PME_CTX_OP_WAIT_INT |
-			PME_CMD_FCW_ALL, rb_flow);
+					PME_CTX_OP_WAIT, rb_flow);
 		BUG_ON(ret);
-		pr_info("st: read Flow Context;\n");
-		hexdump(rb_flow, sizeof(*rb_flow));
+		if (memcmp(rb_flow, fl_ctx_exp_post_scan,
+					sizeof(*rb_flow)) != 0) {
+			pr_info("st: Flow Context Read FAIL\n");
+			pr_info("st: Expected\n");
+			hexdump(fl_ctx_exp_post_scan,
+				sizeof(fl_ctx_exp_post_scan));
+			pr_info("st: Received\n");
+			hexdump(rb_flow, sizeof(*rb_flow));
+			BUG_ON(1);
+		} else {
+			pr_info("st: Flow Context Read OK\n");
+		}
 		pme_sw_flow_free(rb_flow);
 	}
 
 	/* Disable */
-	ret = pme_ctx_disable(&a_scan_ctx.base_ctx,
-			PME_CTX_OP_WAIT | PME_CTX_OP_WAIT_INT);
+	ret = pme_ctx_disable(&a_scan_ctx.base_ctx, PME_CTX_OP_WAIT);
 	BUG_ON(ret);
 	pme_ctx_finish(&a_scan_ctx.base_ctx);
 	pme_sw_flow_free(flow);
diff --git a/include/linux/fsl_pme.h b/include/linux/fsl_pme.h
index 328686d..18ebdaa 100644
--- a/include/linux/fsl_pme.h
+++ b/include/linux/fsl_pme.h
@@ -100,6 +100,7 @@ enum pme_status {
 /* pme_fd_res_flags() returns these flags */
 #define PME_STATUS_UNRELIABLE	0x80
 #define PME_STATUS_TRUNCATED	0x10
+#define PME_STATUS_MASK		0x90
 
 /**************/
 /* USER SPACE */
@@ -348,7 +349,7 @@ static inline enum pme_status pme_fd_res_status(const struct qm_fd *fd)
 }
 static inline u8 pme_fd_res_flags(const struct qm_fd *fd)
 {
-	return (fd->status >> 16) & 0xff;
+	return (fd->status >> 16) & PME_STATUS_MASK;
 }
 
 /* Fill in a frame descriptor for a NOP command. */
@@ -516,6 +517,9 @@ int pme_ctx_enable(struct pme_ctx *ctx);
 /* query whether a context is disabled. Returns > 0 if the ctx is disabled. */
 int pme_ctx_is_disabled(struct pme_ctx *ctx);
 
+/* query whether a context is in an error state. */
+int pme_ctx_is_dead(struct pme_ctx *ctx);
+
 /* A pre-condition for the following APIs is the ctx must be disabled
  * dest maybe ignored if the flags parameter indicated LOCAL during the
  * corresponding pme_ctx_init.
@@ -529,7 +533,14 @@ int pme_ctx_reconfigure_rx(struct pme_ctx *ctx, u8 qosout,
  * sent. If PME_CTX_OP_WAIT_INT was specified and a signal was received while
  * waiting for the response, it may return prematurely with success. The caller
  * can use signal_pending() to deal with any corresponding issues, if required.
- * Also 'params' may be modified by this call. For instance if
+ * If WAIT isn't used, or if WAIT_INT is specified and a signal may have
+ * returned prematurely before the PME replied to the control command, then
+ * pme_ctx_in_ctrl() should be used to determine when the command is complete.
+ * NB: as the return value indicates whether the command was issued (and not
+ * what the device did in reaction to the command), device errors caused by
+ * pme_ctx_ctrl_***() APIs should be detected by calling pme_ctx_is_dead() after
+ * the operation completes.
+ * NB: 'params' may be modified by this call. For instance if
  * PME_CTX_OP_RESETRESLEN was specified and residue is enabled, then the
  * params->ren will be set to 1 (in order not to disabled residue).
  * NB: _update() will overwrite the 'params->rptr_[hi/low]' fields since the
@@ -575,6 +586,9 @@ int pme2_have_control(void);
 enum pme_attr {
 	pme_attr_efqc_int,
 	pme_attr_sw_db,
+	pme_attr_dmcr,
+	pme_attr_smcr,
+	pme_attr_famcr,
 	pme_attr_kvlts,
 	pme_attr_max_chain_length,
 	pme_attr_pattern_range_counter_idx,
-- 
1.6.0.4

