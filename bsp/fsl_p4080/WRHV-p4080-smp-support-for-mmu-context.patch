From e8c3ada0db11e103a9df6ff08f502b88e7e3c595 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Fri, 5 Feb 2010 23:00:09 -0800
Subject: [PATCH 2/4] WRHV/p4080: smp support for mmu context

Based on the patch committed by Benjamin Herrenschmidt. It adds
support for SMP by implementing a concept of stale context map
to lazily flush the TLB on processors where a context may have
been invalidated.

http://www.nabble.com/-PATCH-6-9--powerpc:-Rework-context-management-for-CPUs-with-no-hash-table-p20889864.html

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
Integrated-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/powerpc/include/asm/mmu-fsl-booke.h |    2 +-
 arch/powerpc/include/asm/mmu_context.h   |   12 ++++++------
 arch/powerpc/kernel/ppc_ksyms.c          |    2 +-
 arch/powerpc/kernel/swsusp.c             |    2 +-
 arch/powerpc/mm/mmu_context_32.c         |    6 +++---
 5 files changed, 12 insertions(+), 12 deletions(-)

diff --git a/arch/powerpc/include/asm/mmu-fsl-booke.h b/arch/powerpc/include/asm/mmu-fsl-booke.h
index 6b7f5cb..afd6703 100644
--- a/arch/powerpc/include/asm/mmu-fsl-booke.h
+++ b/arch/powerpc/include/asm/mmu-fsl-booke.h
@@ -74,7 +74,7 @@
 #ifndef __ASSEMBLY__
 
 typedef struct {
-#ifdef CONFIG_MPC85xx_DS
+#if defined(CONFIG_MPC85xx_DS) || defined(CONFIG_WRHV_P4080DS)
 	unsigned short	id;
 	unsigned short	active;
 #else
diff --git a/arch/powerpc/include/asm/mmu_context.h b/arch/powerpc/include/asm/mmu_context.h
index 6dab487..a44e136 100644
--- a/arch/powerpc/include/asm/mmu_context.h
+++ b/arch/powerpc/include/asm/mmu_context.h
@@ -111,7 +111,7 @@ extern unsigned long next_mmu_context;
 #if LAST_CONTEXT < 30000
 #define FEW_CONTEXTS	1
 extern struct mm_struct *context_mm[LAST_CONTEXT+1];
-#ifdef CONFIG_MPC85xx_DS
+#if defined(CONFIG_MPC85xx_DS) || defined(CONFIG_WRHV_P4080DS)
 extern unsigned int nr_free_contexts;
 #else
 extern atomic_t nr_free_contexts;
@@ -119,7 +119,7 @@ extern void steal_context(void);
 #endif
 #endif
 
-#ifdef CONFIG_MPC85xx_DS
+#if defined(CONFIG_MPC85xx_DS) || defined(CONFIG_WRHV_P4080DS)
 extern spinlock_t context_lock;
 void switch_mmu_context(struct mm_struct *, struct mm_struct *);
 #else
@@ -156,7 +156,7 @@ static inline void get_mmu_context(struct mm_struct *mm)
 static inline int init_new_context(struct task_struct *t, struct mm_struct *mm)
 {
 	mm->context.id = NO_CONTEXT;
-#ifdef CONFIG_MPC85xx_DS
+#if defined(CONFIG_MPC85xx_DS) || defined(CONFIG_WRHV_P4080DS)
 	mm->context.active = 0;
 #endif
 	return 0;
@@ -165,7 +165,7 @@ static inline int init_new_context(struct task_struct *t, struct mm_struct *mm)
 /*
  * We're finished using the context for an address space.
  */
-#ifdef CONFIG_MPC85xx_DS
+#if defined(CONFIG_MPC85xx_DS) || defined(CONFIG_WRHV_P4080DS)
 static inline void destroy_context(struct mm_struct *mm)
 {
 	unsigned int id;
@@ -200,7 +200,7 @@ static inline void destroy_context(struct mm_struct *mm)
 static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,
 			     struct task_struct *tsk)
 {
-#ifdef CONFIG_MPC85xx_DS
+#if defined(CONFIG_MPC85xx_DS) || defined(CONFIG_WRHV_P4080DS)
 	if (!cpu_isset(smp_processor_id(), next->cpu_vm_mask))
 		cpu_set(smp_processor_id(), next->cpu_vm_mask);
 #endif
@@ -220,7 +220,7 @@ static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,
 		return;
 
 	/* Setup new userspace context */
-#ifdef CONFIG_MPC85xx_DS
+#if defined(CONFIG_MPC85xx_DS) || defined(CONFIG_WRHV_P4080DS)
 	switch_mmu_context(prev, next);
 #else
 	get_mmu_context(next);
diff --git a/arch/powerpc/kernel/ppc_ksyms.c b/arch/powerpc/kernel/ppc_ksyms.c
index f9f5a9a..9e757a2 100644
--- a/arch/powerpc/kernel/ppc_ksyms.c
+++ b/arch/powerpc/kernel/ppc_ksyms.c
@@ -170,7 +170,7 @@ EXPORT_SYMBOL(cacheable_memcpy);
 #endif
 
 #ifdef CONFIG_PPC32
-#ifdef CONFIG_MPC85xx_DS
+#if defined(CONFIG_MPC85xx_DS) || defined(CONFIG_WRHV_P4080DS)
 EXPORT_SYMBOL(switch_mmu_context);
 #else
 EXPORT_SYMBOL(next_mmu_context);
diff --git a/arch/powerpc/kernel/swsusp.c b/arch/powerpc/kernel/swsusp.c
index a277040..ae28c42 100644
--- a/arch/powerpc/kernel/swsusp.c
+++ b/arch/powerpc/kernel/swsusp.c
@@ -34,7 +34,7 @@ void save_processor_state(void)
 void restore_processor_state(void)
 {
 #ifdef CONFIG_PPC32
-#ifdef CONFIG_MPC85xx_DS
+#if defined(CONFIG_MPC85xx_DS) || defined(CONFIG_WRHV_P4080DS)
 	switch_mmu_context(NULL, current->active_mm);
 #else
 	set_context(current->active_mm->context.id, current->active_mm->pgd);
diff --git a/arch/powerpc/mm/mmu_context_32.c b/arch/powerpc/mm/mmu_context_32.c
index 44f80db..534eae4 100644
--- a/arch/powerpc/mm/mmu_context_32.c
+++ b/arch/powerpc/mm/mmu_context_32.c
@@ -32,7 +32,7 @@ unsigned long next_mmu_context;
 unsigned long context_map[LAST_CONTEXT / BITS_PER_LONG + 1];
 #ifdef FEW_CONTEXTS
 struct mm_struct *context_mm[LAST_CONTEXT+1];
-#ifdef CONFIG_MPC85xx_DS
+#if defined(CONFIG_MPC85xx_DS) || defined(CONFIG_WRHV_P4080DS)
 DEFINE_SPINLOCK(context_lock);
 unsigned int nr_free_contexts;
 static unsigned long stale_map[NR_CPUS][LAST_CONTEXT / BITS_PER_LONG + 1];
@@ -57,7 +57,7 @@ mmu_context_init(void)
 	context_map[0] = (1 << FIRST_CONTEXT) - 1;
 	next_mmu_context = FIRST_CONTEXT;
 #ifdef FEW_CONTEXTS
-#ifdef CONFIG_MPC85xx_DS
+#if defined(CONFIG_MPC85xx_DS) || defined(CONFIG_WRHV_P4080DS)
 	/* Mark init_mm as being active on all possible CPUs since
 	 * we'll get called with prev == init_mm the first time
 	 * we schedule on a given CPU
@@ -83,7 +83,7 @@ mmu_context_init(void)
  * place to implement an LRU scheme if anyone was motivated to do it.
  *  -- paulus
  */
-#ifdef CONFIG_MPC85xx_DS
+#if defined(CONFIG_MPC85xx_DS) || defined(CONFIG_WRHV_P4080DS)
 #include <asm/udbg.h>
 
 /*
-- 
1.6.5.2

