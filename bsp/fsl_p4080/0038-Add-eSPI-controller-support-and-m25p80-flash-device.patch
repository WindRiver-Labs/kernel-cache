From 12b2e09303b2d2777fbebbf4541645081f5f9057 Mon Sep 17 00:00:00 2001
From: Greg Moffatt <greg.moffatt@windriver.com>
Date: Wed, 23 Sep 2009 09:33:52 -0400
Subject: [PATCH 38/52] Add eSPI controller support and m25p80 flash device

Extracted from P4080_WRlinux-rc1(/2)_20090904.iso vendor drop

Signed-off-by: Junjie Zhang <b18070@freescale.com>
Signed-off-by: Roy Zang <tie-fei.zang@freescale.com>

[ Some formatting changes were made.]
Signed-off-by: Greg Moffatt <greg.moffatt@windriver.com>
---
 arch/powerpc/include/asm/delay.h |   36 ++
 drivers/mtd/devices/Kconfig      |   12 +-
 drivers/mtd/devices/Makefile     |    1 +
 drivers/mtd/devices/fsl_m25p80.c |  880 ++++++++++++++++++++++++++++++++++++++
 drivers/of/base.c                |    2 +-
 drivers/spi/Kconfig              |    6 +
 drivers/spi/Makefile             |    1 +
 drivers/spi/fsl_espi.c           |  550 ++++++++++++++++++++++++
 drivers/spi/spi_bitbang.c        |    3 +-
 9 files changed, 1488 insertions(+), 3 deletions(-)
 create mode 100644 drivers/mtd/devices/fsl_m25p80.c
 create mode 100644 drivers/spi/fsl_espi.c

diff --git a/arch/powerpc/include/asm/delay.h b/arch/powerpc/include/asm/delay.h
index f9200a6..a51dafb 100644
--- a/arch/powerpc/include/asm/delay.h
+++ b/arch/powerpc/include/asm/delay.h
@@ -2,8 +2,11 @@
 #define _ASM_POWERPC_DELAY_H
 #ifdef __KERNEL__
 
+#include <asm/time.h>
+
 /*
  * Copyright 1996, Paul Mackerras.
+ * Copyright (C) 2009 Freescale Semiconductor, Inc. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -30,5 +33,38 @@ extern void udelay(unsigned long usecs);
 #define mdelay(n)	udelay((n) * 1000)
 #endif
 
+/**
+ * spin_event_timeout - spin until a condition gets true or a timeout elapses
+ * @condition: a C expression to evalate
+ * @timeout: timeout, in microseconds
+ * @delay: the number of microseconds to delay between each evaluation of
+ *         @condition
+ *
+ * The process spins until the condition evaluates to true (non-zero) or the
+ * timeout elapses.  The return value of this macro is the value of
+ * @condition when the loop terminates. This allows you to determine the cause
+ * of the loop terminates.  If the return value is zero, then you know a
+ * timeout has occurred.
+ *
+ * This primary purpose of this macro is to poll on a hardware register
+ * until a status bit changes.  The timeout ensures that the loop still
+ * terminates even if the bit never changes.  The delay is for devices that
+ * need a delay in between successive reads.
+ *
+ * gcc will optimize out the if-statement if @delay is a constant.
+ */
+#define spin_event_timeout(condition, timeout, delay)                          \
+({                                                                             \
+       typeof(condition) __ret;                                               \
+       unsigned long __loops = tb_ticks_per_usec * timeout;                   \
+       unsigned long __start = get_tbl();                                     \
+       while (!(__ret = (condition)) && (tb_ticks_since(__start) <= __loops)) \
+               if (delay)                                                     \
+                       udelay(delay);                                         \
+               else                                                           \
+                       cpu_relax();                                           \
+       __ret;                                                                 \
+})
+
 #endif /* __KERNEL__ */
 #endif /* _ASM_POWERPC_DELAY_H */
diff --git a/drivers/mtd/devices/Kconfig b/drivers/mtd/devices/Kconfig
index 9c613f0..32701ff 100644
--- a/drivers/mtd/devices/Kconfig
+++ b/drivers/mtd/devices/Kconfig
@@ -76,9 +76,19 @@ config MTD_M25P80
 	  if you want to specify device partitioning or to use a device which
 	  doesn't support the JEDEC ID instruction.
 
+config MTD_FSL_M25P80
+	tristate "Support Flash chips based on Freescale eSPI interface"
+	depends on SPI_MASTER && FSL_ESPI && EXPERIMENTAL
+	help
+	  This only enables access to Freescale eSPI interface
+
+	  Set up your spi devices with the right board-specific platform data,
+	  if you want to specify device partitioning or to use a device which
+	  doesn't support the JEDEC ID instruction.
+
 config M25PXX_USE_FAST_READ
 	bool "Use FAST_READ OPCode allowing SPI CLK <= 50MHz"
-	depends on MTD_M25P80
+	depends on MTD_M25P80 || MTD_FSL_M25P80
 	default y
 	help
 	  This option enables FAST_READ access supported by ST M25Pxx.
diff --git a/drivers/mtd/devices/Makefile b/drivers/mtd/devices/Makefile
index 0993d5c..37c1996 100644
--- a/drivers/mtd/devices/Makefile
+++ b/drivers/mtd/devices/Makefile
@@ -16,3 +16,4 @@ obj-$(CONFIG_MTD_LART)		+= lart.o
 obj-$(CONFIG_MTD_BLOCK2MTD)	+= block2mtd.o
 obj-$(CONFIG_MTD_DATAFLASH)	+= mtd_dataflash.o
 obj-$(CONFIG_MTD_M25P80)	+= m25p80.o
+obj-$(CONFIG_MTD_FSL_M25P80)	+= fsl_m25p80.o
diff --git a/drivers/mtd/devices/fsl_m25p80.c b/drivers/mtd/devices/fsl_m25p80.c
new file mode 100644
index 0000000..e5fd701
--- /dev/null
+++ b/drivers/mtd/devices/fsl_m25p80.c
@@ -0,0 +1,880 @@
+/*
+ * MTD SPI driver for ST M25Pxx (and similar) serial flash chips
+ * only for Freescale eSPI controller
+ *
+ * Author: Chen Gong <g.chen@freescale.com>
+ * heavily based on m25p80.c by Mike Lavender, mike@steroidmicros.com
+ *
+ * Copyright(C) 2008-2009 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+
+#include <linux/spi/spi.h>
+#include <linux/spi/flash.h>
+#include <linux/delay.h>
+
+/* Flash opcodes. */
+#define	OPCODE_WREN		0x06	/* Write enable */
+#define	OPCODE_RDSR		0x05	/* Read status register */
+#define	OPCODE_NORM_READ	0x03	/* Read data bytes (low frequency) */
+#define	OPCODE_FAST_READ	0x0b	/* Read data bytes (high frequency) */
+#define	OPCODE_PP		0x02	/* Page program (up to 256 bytes) */
+#define	OPCODE_BE_4K 		0x20	/* Erase 4KiB block */
+#define	OPCODE_BE_32K		0x52	/* Erase 32KiB block */
+#define	OPCODE_BE		0xc7	/* Erase whole flash block */
+#define	OPCODE_SE		0xd8	/* Sector erase (usually 64KiB) */
+#define	OPCODE_RDID		0x9f	/* Read JEDEC ID */
+
+/* Status Register bits. */
+#define	SR_WIP			1	/* Write in progress */
+#define	SR_WEL			2	/* Write enable latch */
+/* meaning of other SR_* bits may differ between vendors */
+#define	SR_BP0			4	/* Block protect 0 */
+#define	SR_BP1			8	/* Block protect 1 */
+#define	SR_BP2			0x10	/* Block protect 2 */
+#define	SR_SRWD			0x80	/* SR write protect */
+
+/* Define max times to check status register before we give up. */
+#define	MAX_READY_WAIT_COUNT	100000
+#define	CMD_SIZE		4
+
+#ifdef CONFIG_M25PXX_USE_FAST_READ
+#define OPCODE_READ 	OPCODE_FAST_READ
+#define FAST_READ_DUMMY_BYTE 1
+#else
+#define OPCODE_READ 	OPCODE_NORM_READ
+#define FAST_READ_DUMMY_BYTE 0
+#endif
+
+#ifdef CONFIG_MTD_PARTITIONS
+#define	mtd_has_partitions()	(1)
+#else
+#define	mtd_has_partitions()	(0)
+#endif
+
+/****************************************************************************/
+
+struct m25p {
+	struct spi_device	*spi;
+	struct mutex		lock;
+	struct mtd_info		mtd;
+	unsigned		partitioned:1;
+	unsigned int		page_size;	/* of bytes per page */
+	u8			erase_opcode;
+	u8			command[CMD_SIZE + FAST_READ_DUMMY_BYTE];
+};
+
+static inline struct m25p *mtd_to_m25p(struct mtd_info *mtd)
+{
+	return container_of(mtd, struct m25p, mtd);
+}
+
+/****************************************************************************/
+
+/*
+ * Internal helper functions
+ */
+
+/*
+ * Read the status register, returning its value in the location
+ * Return the status register value.
+ * Returns negative if error occurred.
+ */
+static int read_sr(struct m25p *flash)
+{
+	ssize_t retval;
+	u8 code = OPCODE_RDSR;
+	struct spi_message	message;
+	struct spi_transfer	x[1];
+	u8			*local_buf;
+	u8 val;
+
+	spi_message_init(&message);
+	memset(x, 0, sizeof x);
+	x[0].len = 2;
+	spi_message_add_tail(&x[0], &message);
+
+	/* ... unless someone else is using the pre-allocated buffer */
+	local_buf = kzalloc(32, GFP_KERNEL);
+	if (!local_buf)
+		return -ENOMEM;
+
+	memcpy(local_buf, &code, 1);
+	x[0].tx_buf = local_buf;
+	x[0].rx_buf = local_buf + 1;
+
+	/* do the i/o */
+	retval = spi_sync(flash->spi, &message);
+	if (retval == 0)
+		memcpy(&val, x[0].rx_buf + 1, 1);
+
+	kfree(local_buf);
+
+	if (retval < 0) {
+		dev_err(&flash->spi->dev, "error %d reading SR\n",
+				(int) retval);
+		return retval;
+	}
+
+	return val;
+}
+
+
+/*
+ * Set write enable latch with Write Enable command.
+ * Returns negative if error occurred.
+ */
+static inline int write_enable(struct m25p *flash)
+{
+	u8	code = OPCODE_WREN;
+
+	return spi_write_then_read(flash->spi, &code, 1, NULL, 0);
+}
+
+
+/*
+ * Service routine to read status register until ready, or timeout occurs.
+ * Returns non-zero if error.
+ */
+static int wait_till_ready(struct m25p *flash)
+{
+	int count;
+	int sr;
+
+	/* one chip guarantees max 5 msec wait here after page writes,
+	 * but potentially three seconds (!) after page erase.
+	 */
+	for (count = 0; count < MAX_READY_WAIT_COUNT; count++) {
+		sr = read_sr(flash);
+		if (sr < 0)
+			break;
+		else if (!(sr & SR_WIP))
+			return 0;
+
+		/* REVISIT sometimes sleeping would be best */
+	}
+
+	return 1;
+}
+
+/*
+ * Erase the whole flash memory
+ *
+ * Returns 0 if successful, non-zero otherwise.
+ */
+static int erase_block(struct m25p *flash)
+{
+	DEBUG(MTD_DEBUG_LEVEL3, "%s: %s %dKiB\n",
+			dev_name(&flash->spi->dev), __func__,
+			(u32)flash->mtd.size / 1024);
+
+	/* Wait until finished previous write command. */
+	if (wait_till_ready(flash))
+		return 1;
+
+	/* Send write enable, then erase commands. */
+	write_enable(flash);
+
+	/* Set up command buffer. */
+	flash->command[0] = OPCODE_BE;
+
+	spi_write(flash->spi, flash->command, CMD_SIZE);
+
+	return 0;
+}
+
+/*
+ * Erase one sector of flash memory at offset ``offset'' which is any
+ * address within the sector which should be erased.
+ *
+ * Returns 0 if successful, non-zero otherwise.
+ */
+static int erase_sector(struct m25p *flash, u32 offset)
+{
+	DEBUG(MTD_DEBUG_LEVEL3, "%s: %s %dKiB at 0x%08x\n",
+			dev_name(&flash->spi->dev), __func__,
+			flash->mtd.erasesize / 1024, offset);
+
+	/* Wait until finished previous write command. */
+	if (wait_till_ready(flash))
+		return 1;
+
+	/* Send write enable, then erase commands. */
+	write_enable(flash);
+
+	/* Set up command buffer. */
+	flash->command[0] = flash->erase_opcode;
+	flash->command[1] = offset >> 16;
+	flash->command[2] = offset >> 8;
+	flash->command[3] = offset;
+
+	spi_write(flash->spi, flash->command, CMD_SIZE);
+
+	return 0;
+}
+
+/****************************************************************************/
+
+/*
+ * MTD implementation
+ */
+
+/*
+ * Erase an address range on the flash chip.  The address range may extend
+ * one or more erase sectors.  Return an error is there is a problem erasing.
+ */
+static int m25p80_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct m25p *flash = mtd_to_m25p(mtd);
+	u32 addr, len;
+	uint32_t rem;
+
+	DEBUG(MTD_DEBUG_LEVEL2, "%s: %s %s 0x%08x, len %d\n",
+			dev_name(&flash->spi->dev), __func__, "at",
+			(u32)instr->addr, (u32)instr->len);
+
+	/* sanity checks */
+	if (instr->addr + instr->len > flash->mtd.size)
+		return -EINVAL;
+	div_u64_rem(instr->len, mtd->erasesize, &rem);
+	if (rem)
+		return -EINVAL;
+
+	addr = instr->addr;
+	len = instr->len;
+
+	mutex_lock(&flash->lock);
+
+	/* REVISIT in some cases we could speed up erasing large regions
+	 * by using OPCODE_SE instead of OPCODE_BE_4K. Based the same
+	 * reason, in some cases we could use OPCODE_BE instead of
+	 * OPCODE_SE
+	 */
+
+	/* now erase those sectors */
+	if (len == flash->mtd.size && erase_block(flash)) {
+		instr->state = MTD_ERASE_FAILED;
+		mutex_unlock(&flash->lock);
+		return -EIO;
+	} else {
+		while (len) {
+			if (erase_sector(flash, addr)) {
+				instr->state = MTD_ERASE_FAILED;
+				mutex_unlock(&flash->lock);
+				return -EIO;
+			}
+
+			addr += mtd->erasesize;
+			len -= mtd->erasesize;
+		}
+	}
+
+	mutex_unlock(&flash->lock);
+
+	instr->state = MTD_ERASE_DONE;
+	mtd_erase_callback(instr);
+
+	return 0;
+}
+
+static int m25p80_read(struct mtd_info *mtd, loff_t from, size_t len,
+	size_t *retlen, u_char *buf)
+{
+	struct m25p *flash = mtd_to_m25p(mtd);
+	struct spi_message	m;
+	struct spi_transfer	x[1];
+	u8			*local_buf;
+	u32			i, page_size = 0;
+
+	DEBUG(MTD_DEBUG_LEVEL2, "%s: %s %s 0x%08x, len %zd\n",
+			dev_name(&flash->spi->dev), __func__, "from",
+			(u32)from, len);
+
+	/* sanity checks */
+	if (!len)
+		return 0;
+
+	if (from + len > flash->mtd.size)
+		return -EINVAL;
+
+	/* ... unless someone else is using the pre-allocated buffer */
+	local_buf = kzalloc(flash->page_size +
+			2 * (CMD_SIZE + FAST_READ_DUMMY_BYTE), GFP_KERNEL);
+	if (!local_buf)
+		return -ENOMEM;
+
+	spi_message_init(&m);
+	memset(x, 0, sizeof x);
+	spi_message_add_tail(&x[0], &m);
+
+	x[0].tx_buf = local_buf;
+	x[0].rx_buf = local_buf + CMD_SIZE + FAST_READ_DUMMY_BYTE;
+
+	/* Byte count starts at zero. */
+	*retlen = 0;
+
+	mutex_lock(&flash->lock);
+
+	/* Wait till previous write/erase is done. */
+	if (wait_till_ready(flash)) {
+		/* REVISIT status return?? */
+		mutex_unlock(&flash->lock);
+		kfree(local_buf);
+		return 1;
+	}
+
+	/* FIXME switch to OPCODE_FAST_READ.  It's required for higher
+	 * clocks; and at this writing, every chip this driver handles
+	 * supports that opcode.
+	 */
+
+	/* Set up the write data buffer. */
+	local_buf[0] = OPCODE_READ;
+
+	for (i = page_size; i < len; i += page_size) {
+		page_size = len - i;
+		if (page_size > flash->page_size)
+			page_size = flash->page_size;
+
+		/* write the next page to flash */
+		local_buf[1] = (from + i) >> 16;
+		local_buf[2] = (from + i) >> 8;
+		local_buf[3] = (from + i);
+
+		x[0].len = CMD_SIZE + FAST_READ_DUMMY_BYTE + page_size;
+
+		wait_till_ready(flash);
+
+		spi_sync(flash->spi, &m);
+		memcpy(buf + i, x[0].rx_buf + CMD_SIZE + FAST_READ_DUMMY_BYTE,
+				page_size);
+
+		if (retlen)
+			*retlen += m.actual_length -
+				CMD_SIZE - FAST_READ_DUMMY_BYTE;
+	}
+
+
+	mutex_unlock(&flash->lock);
+
+	kfree(local_buf);
+	return 0;
+}
+
+/*
+ * Write an address range to the flash chip.  Data must be written in
+ * FLASH PAGESIZE chunks.  The address range may be any size provided
+ * it is within the physical boundaries.
+ */
+static int m25p80_write(struct mtd_info *mtd, loff_t to, size_t len,
+	size_t *retlen, const u_char *buf)
+{
+	struct m25p *flash = mtd_to_m25p(mtd);
+	u32 page_offset, page_size;
+	struct spi_transfer t[1];
+	struct spi_message m;
+	u8 *local_buf, *tmp;
+
+	DEBUG(MTD_DEBUG_LEVEL2, "%s: %s %s 0x%08x, len %zd\n",
+			dev_name(&flash->spi->dev), __func__, "to",
+			(u32)to, len);
+
+	/* sanity checks */
+	if (!len)
+		return 0;
+
+	if (to + len > flash->mtd.size)
+		return -EINVAL;
+
+	/* ... unless someone else is using the pre-allocated buffer */
+	local_buf = kzalloc(flash->page_size + CMD_SIZE, GFP_KERNEL);
+	if (!local_buf)
+		return -ENOMEM;
+
+	*retlen = 0;
+
+	spi_message_init(&m);
+	memset(t, 0, (sizeof t));
+
+	t[0].tx_buf = local_buf;
+	spi_message_add_tail(&t[0], &m);
+
+	mutex_lock(&flash->lock);
+
+	/* Wait until finished previous write command. */
+	if (wait_till_ready(flash)) {
+		mutex_unlock(&flash->lock);
+		kfree(local_buf);
+		return 1;
+	}
+
+	write_enable(flash);
+
+	/* Set up the opcode in the write buffer. */
+	local_buf[0] = OPCODE_PP;
+	local_buf[1] = (to >> 16) & 0xff;
+	local_buf[2] = (to >> 8) & 0xff;
+	local_buf[3] = to & 0xff;
+
+	/* what page do we start with? */
+	page_offset = ((unsigned)to % flash->page_size);
+
+	/* do all the bytes fit onto one page? */
+	if (page_offset + len <= flash->page_size) {
+		t[0].len = CMD_SIZE + len;
+		memcpy(local_buf + CMD_SIZE, buf, len);
+
+		spi_sync(flash->spi, &m);
+
+		*retlen = m.actual_length - CMD_SIZE;
+	} else {
+		u32 i;
+
+		/* the size of data remaining on the first page */
+		page_size = flash->page_size - page_offset;
+
+		t[0].len = CMD_SIZE + page_size;
+		memcpy(local_buf + CMD_SIZE, buf, page_size);
+
+		spi_sync(flash->spi, &m);
+
+		*retlen = m.actual_length - CMD_SIZE;
+
+		/* write everything in PAGESIZE chunks */
+		for (i = page_size; i < len; i += page_size) {
+			page_size = len - i;
+			if (page_size > flash->page_size)
+				page_size = flash->page_size;
+
+			if (likely(i >= CMD_SIZE))
+				tmp = buf + i - CMD_SIZE;
+			else {
+				tmp = local_buf;
+				memcpy(tmp + CMD_SIZE, buf + i, page_size);
+			}
+			tmp[0] = OPCODE_PP;
+			tmp[1] = ((to + i) >> 16) & 0xff;
+			tmp[2] = ((to + i) >> 8) & 0xff;
+			tmp[3] = (to + i) & 0xff;
+			t[0].tx_buf = tmp;
+			t[0].len = CMD_SIZE + page_size;
+
+			wait_till_ready(flash);
+
+			write_enable(flash);
+
+			spi_sync(flash->spi, &m);
+
+			if (retlen)
+				*retlen += m.actual_length - CMD_SIZE;
+		}
+	}
+
+	mutex_unlock(&flash->lock);
+
+	kfree(local_buf);
+
+	return 0;
+}
+
+
+/****************************************************************************/
+
+/*
+ * SPI device driver setup and teardown
+ */
+
+struct flash_info {
+	char		*name;
+
+	/* JEDEC id zero means "no ID" (most older chips); otherwise it has
+	 * a high byte of zero plus three data bytes: the manufacturer id,
+	 * then a two byte device id.
+	 */
+	u32		jedec_id;
+	u16		ext_id;
+
+	/* The size listed here is what works with OPCODE_SE, which isn't
+	 * necessarily called a "sector" by the vendor.
+	 */
+	unsigned	page_size;
+	unsigned	sector_size;
+	u16		n_sectors;
+
+	u16		flags;
+#define	SECT_4K		0x01		/* OPCODE_BE_4K works uniformly */
+};
+
+
+/* NOTE: double check command sets and memory organization when you add
+ * more flash chips.  This current list focusses on newer chips, which
+ * have been converging on command sets which including JEDEC ID.
+ */
+static struct flash_info __devinitdata m25p_data[] = {
+
+	/* Atmel -- some are (confusingly) marketed as "DataFlash" */
+	{ "at25fs010",  0x1f6601, 0, 256, 32 * 1024, 4, SECT_4K, },
+	{ "at25fs040",  0x1f6604, 0, 256, 64 * 1024, 8, SECT_4K, },
+
+	{ "at25df041a", 0x1f4401, 0, 256, 64 * 1024, 8, SECT_4K, },
+	{ "at25df641",  0x1f4800, 0, 256, 64 * 1024, 128, SECT_4K, },
+
+	{ "at26f004",   0x1f0400, 0, 256, 64 * 1024, 8, SECT_4K, },
+	{ "at26df081a", 0x1f4501, 0, 256, 64 * 1024, 16, SECT_4K, },
+	{ "at26df161a", 0x1f4601, 0, 256, 64 * 1024, 32, SECT_4K, },
+	{ "at26df321",  0x1f4701, 0, 256, 64 * 1024, 64, SECT_4K, },
+
+	/* Spansion -- single (large) sector size only, at least
+	 * for the chips listed here (without boot sectors).
+	 */
+	{ "s25sl004a", 0x010212, 0, 256, 64 * 1024, 8, },
+	{ "s25sl008a", 0x010213, 0, 256, 64 * 1024, 16, },
+	{ "s25sl016a", 0x010214, 0, 256, 64 * 1024, 32, },
+	{ "s25sl032a", 0x010215, 0, 256, 64 * 1024, 64, },
+	{ "s25sl064a", 0x010216, 0, 256, 64 * 1024, 128, },
+	{ "s25sl128a", 0x012018, 0x0300, 256, 256 * 1024, 64, },
+	{ "s25sl128b", 0x012018, 0x0301, 256, 64 * 1024, 256, },
+
+	/* SST -- large erase sizes are "overlays", "sectors" are 4K */
+	{ "sst25vf040b", 0xbf258d, 0, 256, 64 * 1024, 8, SECT_4K, },
+	{ "sst25vf080b", 0xbf258e, 0, 256, 64 * 1024, 16, SECT_4K, },
+	{ "sst25vf016b", 0xbf2541, 0, 256, 64 * 1024, 32, SECT_4K, },
+	{ "sst25vf032b", 0xbf254a, 0, 256, 64 * 1024, 64, SECT_4K, },
+
+	/* ST Microelectronics -- newer production may have feature updates */
+	{ "m25p05",  0x202010,  0, 256, 32 * 1024, 2, },
+	{ "m25p10",  0x202011,  0, 256, 32 * 1024, 4, },
+	{ "m25p20",  0x202012,  0, 256, 64 * 1024, 4, },
+	{ "m25p40",  0x202013,  0, 256, 64 * 1024, 8, },
+	{ "m25p80",         0,  0, 256, 64 * 1024, 16, },
+	{ "m25p16",  0x202015,  0, 256, 64 * 1024, 32, },
+	{ "m25p32",  0x202016,  0, 256, 64 * 1024, 64, },
+	{ "m25p64",  0x202017,  0, 256, 64 * 1024, 128, },
+	{ "m25p128", 0x202018,  0, 256, 256 * 1024, 64, },
+
+	{ "m45pe80", 0x204014,  0, 256, 64 * 1024, 16, },
+	{ "m45pe16", 0x204015,  0, 256, 64 * 1024, 32, },
+
+	{ "m25pe80", 0x208014,  0, 256, 64 * 1024, 16, },
+	{ "m25pe16", 0x208015,  0, 256, 64 * 1024, 32, SECT_4K, },
+
+	/* Winbond -- w25x "blocks" are 64K, "sectors" are 4KiB */
+	{ "w25x10", 0xef3011, 0, 256, 64 * 1024, 2, SECT_4K, },
+	{ "w25x20", 0xef3012, 0, 256, 64 * 1024, 4, SECT_4K, },
+	{ "w25x40", 0xef3013, 0, 256, 64 * 1024, 8, SECT_4K, },
+	{ "w25x80", 0xef3014, 0, 256, 64 * 1024, 16, SECT_4K, },
+	{ "w25x16", 0xef3015, 0, 256, 64 * 1024, 32, SECT_4K, },
+	{ "w25x32", 0xef3016, 0, 256, 64 * 1024, 64, SECT_4K, },
+	{ "w25x64", 0xef3017, 0, 256, 64 * 1024, 128, SECT_4K, },
+};
+
+static struct flash_info *__devinit jedec_probe(struct spi_device *spi)
+{
+	int			tmp;
+	u8			code = OPCODE_RDID;
+	u8			id[5];
+	u32			jedec = 0;
+	u16			ext_jedec = 0;
+	struct flash_info	*info;
+	struct spi_message	message;
+	struct spi_transfer	x[1];
+	u8			*local_buf;
+
+	/* JEDEC also defines an optional "extended device information"
+	 * string for after vendor-specific data, after the three bytes
+	 * we use here.  Supporting some chips might require using it.
+	 */
+
+	spi_message_init(&message);
+	memset(x, 0, sizeof x);
+	x[0].len = 6;
+	spi_message_add_tail(&x[0], &message);
+
+	/* ... unless someone else is using the pre-allocated buffer */
+	local_buf = kzalloc(32, GFP_KERNEL);
+	if (!local_buf)
+		return NULL;
+
+	memcpy(local_buf, &code, 1);
+	x[0].tx_buf = local_buf;
+	x[0].rx_buf = local_buf + 1;
+
+	/* do the i/o */
+	tmp = spi_sync(spi, &message);
+	if (tmp == 0)
+		memcpy(id, x[0].rx_buf + 1, 5);
+
+	kfree(local_buf);
+
+	if (tmp < 0) {
+		DEBUG(MTD_DEBUG_LEVEL0, "%s: error %d reading JEDEC ID\n",
+			dev_name(&spi->dev), tmp);
+		return NULL;
+	}
+	jedec = id[0];
+	jedec = jedec << 8;
+	jedec |= id[1];
+	jedec = jedec << 8;
+	jedec |= id[2];
+
+	ext_jedec = id[3] << 8 | id[4];
+
+	for (tmp = 0, info = m25p_data;
+			tmp < ARRAY_SIZE(m25p_data);
+			tmp++, info++) {
+		if (info->jedec_id == jedec) {
+			if (info->ext_id != 0 && info->ext_id != ext_jedec)
+				continue;
+			return info;
+		}
+	}
+	dev_err(&spi->dev, "unrecognized JEDEC id %06x\n", jedec);
+	return NULL;
+}
+
+/*
+ * parse_flash_partition - Parse the flash partition on the SPI bus
+ * @spi:	Pointer to spi_device device
+ */
+void parse_flash_partition(struct spi_device *spi)
+{
+	struct mtd_partition *parts;
+	struct flash_platform_data *spi_pdata;
+	int nr_parts = 0;
+	static int num_flash;
+	struct device_node *np = spi->dev.archdata.of_node;
+
+	nr_parts = of_mtd_parse_partitions(&spi->dev, np, &parts);
+	if (!nr_parts)
+		goto end;
+
+	spi_pdata = kzalloc(sizeof(*spi_pdata), GFP_KERNEL);
+	if (!spi_pdata)
+		goto end;
+	spi_pdata->name = kzalloc(10, GFP_KERNEL);
+	if (!spi_pdata->name)
+		goto free_flash;
+	snprintf(spi_pdata->name, 10, "SPIFLASH%d", num_flash++);
+
+	spi_pdata->parts = parts;
+	spi_pdata->nr_parts = nr_parts;
+
+	spi->dev.platform_data = spi_pdata;
+
+	return;
+
+free_flash:
+	kfree(spi_pdata);
+end:
+	return;
+}
+
+/*
+ * board specific setup should have ensured the SPI clock used here
+ * matches what the READ command supports, at least until this driver
+ * understands FAST_READ (for clocks over 25 MHz).
+ */
+static int __devinit m25p_probe(struct spi_device *spi)
+{
+	struct flash_platform_data	*data;
+	struct m25p			*flash;
+	struct flash_info		*info;
+	unsigned			i;
+
+	/* Platform data helps sort out which chip type we have, as
+	 * well as how this board partitions it.  If we don't have
+	 * a chip ID, try the JEDEC id commands; they'll work for most
+	 * newer chips, even if we don't recognize the particular chip.
+	 */
+	/* Parse the flash partition */
+	parse_flash_partition(spi);
+	data = spi->dev.platform_data;
+	if (data && data->type) {
+		for (i = 0, info = m25p_data;
+				i < ARRAY_SIZE(m25p_data);
+				i++, info++) {
+			if (strcmp(data->type, info->name) == 0)
+				break;
+		}
+
+		/* unrecognized chip? */
+		if (i == ARRAY_SIZE(m25p_data)) {
+			DEBUG(MTD_DEBUG_LEVEL0, "%s: unrecognized id %s\n",
+					dev_name(&spi->dev), data->type);
+			info = NULL;
+
+		/* recognized; is that chip really what's there? */
+		} else if (info->jedec_id) {
+			struct flash_info	*chip = jedec_probe(spi);
+
+			if (!chip || chip != info) {
+				dev_warn(&spi->dev, "found %s, expected %s\n",
+						chip ? chip->name : "UNKNOWN",
+						info->name);
+				info = NULL;
+			}
+		}
+	} else
+		info = jedec_probe(spi);
+
+	if (!info)
+		return -ENODEV;
+
+	flash = kzalloc(sizeof *flash, GFP_KERNEL);
+	if (!flash)
+		return -ENOMEM;
+
+	flash->spi = spi;
+	mutex_init(&flash->lock);
+	dev_set_drvdata(&spi->dev, flash);
+
+	if (data && data->name)
+		flash->mtd.name = data->name;
+	else
+		flash->mtd.name = dev_name(&spi->dev);
+
+	flash->page_size = info->page_size;
+	flash->mtd.type = MTD_NORFLASH;
+	flash->mtd.writesize = 1;
+	flash->mtd.flags = MTD_CAP_NORFLASH;
+	flash->mtd.size = info->sector_size * info->n_sectors;
+	flash->mtd.erase = m25p80_erase;
+	flash->mtd.read = m25p80_read;
+	flash->mtd.write = m25p80_write;
+
+	/* prefer "small sector" erase if possible */
+	if (info->flags & SECT_4K) {
+		flash->erase_opcode = OPCODE_BE_4K;
+		flash->mtd.erasesize = 4096;
+	} else {
+		flash->erase_opcode = OPCODE_SE;
+		flash->mtd.erasesize = info->sector_size;
+	}
+
+	dev_info(&spi->dev, "%s (%d Kbytes)\n", info->name,
+			(u32)flash->mtd.size / 1024);
+
+	DEBUG(MTD_DEBUG_LEVEL2,
+		"mtd .name = %s, .size = 0x%.8x (%uMiB) "
+			".erasesize = 0x%.8x (%uKiB) .numeraseregions = %d\n",
+		flash->mtd.name,
+		(u32)flash->mtd.size, (u32)flash->mtd.size / (1024*1024),
+		flash->mtd.erasesize, flash->mtd.erasesize / 1024,
+		flash->mtd.numeraseregions);
+
+	if (flash->mtd.numeraseregions)
+		for (i = 0; i < flash->mtd.numeraseregions; i++)
+			DEBUG(MTD_DEBUG_LEVEL2,
+				"mtd.eraseregions[%d] = { .offset = 0x%.8x, "
+				".erasesize = 0x%.8x (%uKiB), "
+				".numblocks = %d }\n",
+				i, (u32)flash->mtd.eraseregions[i].offset,
+				flash->mtd.eraseregions[i].erasesize,
+				flash->mtd.eraseregions[i].erasesize / 1024,
+				flash->mtd.eraseregions[i].numblocks);
+
+
+	/* partitions should match sector boundaries; and it may be good to
+	 * use readonly partitions for writeprotected sectors (BP2..BP0).
+	 */
+	if (mtd_has_partitions()) {
+		struct mtd_partition	*parts = NULL;
+		int			nr_parts = 0;
+
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+		static const char *part_probes[] = { "cmdlinepart", NULL, };
+
+		nr_parts = parse_mtd_partitions(&flash->mtd,
+				part_probes, &parts, 0);
+#endif
+
+		if (nr_parts <= 0 && data && data->parts) {
+			parts = data->parts;
+			nr_parts = data->nr_parts;
+		}
+
+		if (nr_parts > 0) {
+			for (i = 0; i < nr_parts; i++) {
+				DEBUG(MTD_DEBUG_LEVEL2, "partitions[%d] = "
+					"{.name = %s, .offset = 0x%.8x, "
+						".size = 0x%.8x (%uKiB) }\n",
+					i, parts[i].name,
+					(u32)parts[i].offset,
+					(u32)parts[i].size,
+					(u32)parts[i].size / 1024);
+			}
+			flash->partitioned = 1;
+			return add_mtd_partitions(&flash->mtd, parts, nr_parts);
+		}
+	} else if (data->nr_parts)
+		dev_warn(&spi->dev, "ignoring %d default partitions on %s\n",
+				data->nr_parts, data->name);
+
+	return add_mtd_device(&flash->mtd) == 1 ? -ENODEV : 0;
+}
+
+
+static int __devexit m25p_remove(struct spi_device *spi)
+{
+	struct m25p	*flash = dev_get_drvdata(&spi->dev);
+	int		status;
+
+	/* Clean up MTD stuff. */
+	if (mtd_has_partitions() && flash->partitioned)
+		status = del_mtd_partitions(&flash->mtd);
+	else
+		status = del_mtd_device(&flash->mtd);
+	if (status == 0)
+		kfree(flash);
+	return 0;
+}
+
+
+static struct spi_driver m25p80_driver = {
+	.driver = {
+		.name	= "fsl_m25p80",
+		.bus	= &spi_bus_type,
+		.owner	= THIS_MODULE,
+	},
+	.probe	= m25p_probe,
+	.remove	= __devexit_p(m25p_remove),
+
+	/* REVISIT: many of these chips have deep power-down modes, which
+	 * should clearly be entered on suspend() to minimize power use.
+	 * And also when they're otherwise idle...
+	 */
+};
+
+
+static int m25p80_init(void)
+{
+	return spi_register_driver(&m25p80_driver);
+}
+
+
+static void m25p80_exit(void)
+{
+	spi_unregister_driver(&m25p80_driver);
+}
+
+
+module_init(m25p80_init);
+module_exit(m25p80_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Chen Gong <g.chen@freescale.com>");
+MODULE_DESCRIPTION("MTD SPI driver for ST M25Pxx flash chips");
diff --git a/drivers/of/base.c b/drivers/of/base.c
index 517da97..b71f94e 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -410,7 +410,7 @@ struct of_modalias_table {
 	char *modalias;
 };
 static struct of_modalias_table of_modalias_table[] = {
-	/* Empty for now; add entries as needed */
+	{ "fsl,espi-flash", "fsl_m25p80"},
 };
 
 /**
diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig
index c04029a..63a55d9 100644
--- a/drivers/spi/Kconfig
+++ b/drivers/spi/Kconfig
@@ -135,6 +135,12 @@ config SPI_MPC83xx
 	  technology. This driver uses a simple set of shift registers for data
 	  (opposed to the CPM based descriptor model).
 
+config FSL_ESPI
+	tristate "Freescale eSPI controller"
+	depends on SPI_MASTER && FSL_SOC && EXPERIMENTAL
+	help
+	  This enables using the Freescale eSPI controllers in master mode.
+
 config SPI_OMAP_UWIRE
 	tristate "OMAP1 MicroWire"
 	depends on ARCH_OMAP1
diff --git a/drivers/spi/Makefile b/drivers/spi/Makefile
index 1c2e7fc..fed2796 100644
--- a/drivers/spi/Makefile
+++ b/drivers/spi/Makefile
@@ -24,6 +24,7 @@ obj-$(CONFIG_SPI_OMAP24XX)		+= omap2_mcspi.o
 obj-$(CONFIG_SPI_ORION)			+= orion_spi.o
 obj-$(CONFIG_SPI_MPC52xx_PSC)		+= mpc52xx_psc_spi.o
 obj-$(CONFIG_SPI_MPC83xx)		+= spi_mpc83xx.o
+obj-$(CONFIG_FSL_ESPI)			+= fsl_espi.o
 obj-$(CONFIG_SPI_S3C24XX_GPIO)		+= spi_s3c24xx_gpio.o
 obj-$(CONFIG_SPI_S3C24XX)		+= spi_s3c24xx.o
 obj-$(CONFIG_SPI_TXX9)			+= spi_txx9.o
diff --git a/drivers/spi/fsl_espi.c b/drivers/spi/fsl_espi.c
new file mode 100644
index 0000000..782510d
--- /dev/null
+++ b/drivers/spi/fsl_espi.c
@@ -0,0 +1,550 @@
+/*
+ * Freescale eSPI controller driver.
+ *
+ * Copyright (C) 2008-2009 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Author:
+ * Jerry Huang <Chang-Ming.Huang@freescale.com>
+ * Chen Gong <g.chen@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/completion.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/device.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spi_bitbang.h>
+#include <linux/platform_device.h>
+#include <linux/fsl_devices.h>
+#include <linux/of_platform.h>
+#include <linux/of_device.h>
+#include <linux/of_spi.h>
+#include <sysdev/fsl_soc.h>
+#include <linux/io.h>
+
+/* SPI Controller registers */
+struct fsl_espi_reg {
+	__be32 mode;
+	__be32 event;
+	__be32 mask;
+	__be32 command;
+	__be32 transmit;
+	__be32 receive;
+	__be32 res[2];
+	__be32 csmode[4];
+};
+
+#define MAX_CS_NUM		4
+
+/* SPI Controller mode register definitions */
+#define CSMODE_CI_INACTIVEHIGH	(1 << 31)
+#define CSMODE_CP_BEGIN_EDGECLK	(1 << 30)
+#define CSMODE_REV		(1 << 29)
+#define CSMODE_DIV16		(1 << 28)
+#define CSMODE_PM(x)		((x) << 24)
+#define CSMODE_POL_1		(1 << 20)
+#define CSMODE_LEN(x)		((x) << 16)
+#define CS_BEF(x)		((x) << 12)
+#define CS_AFT(x)		((x) << 8)
+#define CS_CG(x)		((x) << 3)
+
+#define SPMODE_ENABLE		(1 << 31)
+#define SPMODE_LOOP		(1 << 30)
+#define SPIMODE_TXTHR(x)	((x) << 8)
+#define SPIMODE_RXTHR(x)	((x) << 0)
+
+/*
+ * Default for SPI Mode:
+ * 	SPI MODE 0 (inactive low, phase middle, MSB, 8-bit length, slow clk
+ */
+#define CSMODE_INIT_VAL (CSMODE_POL_1 | CS_BEF(0) | CS_AFT(0) | CS_CG(1))
+
+#define SPMODE_INIT_VAL (SPIMODE_TXTHR(4) | SPIMODE_RXTHR(3))
+
+/* SPIE register values */
+#define SPIE_RXT	0x00002000	/* RX Over Threshold */
+#define SPIE_NE		0x00000200	/* Not empty */
+#define SPIE_NF		0x00000100	/* Not full */
+#define SPIE_RXCNT(reg)     ((reg >> 24) & 0x3F)
+#define SPIE_TXCNT(reg)     ((reg >> 16) & 0x3F)
+
+/* SPIM register values */
+#define SPIM_NE		0x00000200	/* Not empty */
+#define SPIM_NF		0x00000100	/* Not full */
+
+/* the spi->mode bits understood by this driver: */
+#define MODEBITS	(SPI_CPOL | SPI_CPHA | SPI_CS_HIGH \
+			| SPI_LSB_FIRST | SPI_LOOP)
+
+/* SPI Controller driver's private data. */
+struct fsl_espi {
+	/* bitbang has to be first */
+	struct spi_bitbang bitbang;
+	struct fsl_espi_reg __iomem *regs;
+	struct completion done;
+
+	/* rx & tx bufs from the spi_transfer */
+	const void *tx;
+	void *rx;
+
+	/* functions to deal with different sized buffers */
+	void (*get_rx) (u32 rx_data, struct fsl_espi *);
+	u32 (*get_tx) (struct fsl_espi *);
+
+	int count;
+	int irq;
+
+	u32 spibrg;		/* SPIBRG input clock */
+	u32 rx_shift;		/* RX data reg shift when in qe mode */
+	u32 tx_shift;		/* TX data reg shift when in qe mode */
+};
+
+struct fsl_espi_cs {
+	/* functions to deal with different sized buffers */
+	void (*get_rx) (u32 rx_data, struct fsl_espi *);
+	u32 (*get_tx) (struct fsl_espi *);
+	u32 rx_shift;		/* RX data reg shift when in qe mode */
+	u32 tx_shift;		/* TX data reg shift when in qe mode */
+	u32 hw_mode;		/* Holds HW mode register settings */
+};
+
+static void fsl_espi_rx_buf(u32 data, struct fsl_espi *fsl_espi)
+{
+	u32 *rx = fsl_espi->rx;
+	*rx++ = (u32)(data >> fsl_espi->rx_shift);
+	fsl_espi->rx = rx;
+}
+
+static u32 fsl_espi_tx_buf(struct fsl_espi *fsl_espi)
+{
+	u32 data;
+	const u32 *tx = fsl_espi->tx;
+	if (!tx)
+		return 0;
+	data = *tx++ << fsl_espi->tx_shift;
+	fsl_espi->tx = tx;
+	return data;
+}
+
+static
+int fsl_espi_setup_transfer(struct spi_device *spi, struct spi_transfer *t)
+{
+	struct fsl_espi *fsl_espi;
+	unsigned long flags;
+	u32 regval;
+	u8 bits_per_word, pm, cs_sel = spi->chip_select;
+	u32 hz;
+	struct fsl_espi_cs *cs = spi->controller_state;
+
+	fsl_espi = spi_master_get_devdata(spi->master);
+
+	if (t) {
+		bits_per_word = t->bits_per_word;
+		hz = t->speed_hz;
+	} else {
+		bits_per_word = 0;
+		hz = 0;
+	}
+
+	/* spi_transfer level calls that work per-word */
+	if (!bits_per_word)
+		bits_per_word = spi->bits_per_word;
+
+	/* Make sure its a bit width we support [4..16] */
+	if (bits_per_word < 4 || bits_per_word > 16)
+		return -EINVAL;
+	bits_per_word -= 1;
+
+	if (!hz)
+		hz = spi->max_speed_hz;
+
+	cs->rx_shift = 0;
+	cs->tx_shift = 0;
+	cs->get_rx = fsl_espi_rx_buf;
+	cs->get_tx = fsl_espi_tx_buf;
+
+	fsl_espi->rx_shift = cs->rx_shift;
+	fsl_espi->tx_shift = cs->tx_shift;
+	fsl_espi->get_rx = cs->get_rx;
+	fsl_espi->get_tx = cs->get_tx;
+
+	/* mask out bits we are going to set */
+	cs->hw_mode &= ~(CSMODE_LEN(0xF) | CSMODE_DIV16 | CSMODE_PM(0xF));
+
+	cs->hw_mode |= CSMODE_LEN(bits_per_word) | CSMODE_INIT_VAL;
+
+	if ((fsl_espi->spibrg / hz) > 32) {
+		cs->hw_mode |= CSMODE_DIV16;
+		pm = fsl_espi->spibrg / (hz * 32);
+		if (pm > 16) {
+			pm = 16;
+			dev_err(&spi->dev, "Requested speed is too "
+				"low: %d Hz. Will use %d Hz instead.\n",
+				hz, fsl_espi->spibrg / 32 * 16);
+		}
+	} else
+		pm = fsl_espi->spibrg / (hz * 2);
+	if (pm)
+		pm--;
+	cs->hw_mode |= CSMODE_PM(pm);
+
+	/* Reset the hw mode */
+	regval = in_be32(&fsl_espi->regs->mode);
+	local_irq_save(flags);
+	/* Turn off SPI unit prior changing mode */
+	out_be32(&fsl_espi->regs->mode, regval & ~SPMODE_ENABLE);
+	out_be32(&fsl_espi->regs->csmode[cs_sel], cs->hw_mode);
+	out_be32(&fsl_espi->regs->mode, regval);
+	local_irq_restore(flags);
+
+	return 0;
+}
+
+static int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)
+{
+	struct fsl_espi *fsl_espi;
+	u32 word, len, bits_per_word;
+
+	fsl_espi = spi_master_get_devdata(spi->master);
+
+	fsl_espi->tx = t->tx_buf;
+	fsl_espi->rx = t->rx_buf;
+	bits_per_word = spi->bits_per_word;
+	if (t->bits_per_word)
+		bits_per_word = t->bits_per_word;
+	len = t->len;
+	fsl_espi->count = len;
+
+	/* every frame owns one byte */
+	out_be32(&fsl_espi->regs->command,
+			(spi->chip_select << 30) | (len - 1));
+	INIT_COMPLETION(fsl_espi->done);
+
+	/* enable rx ints */
+	out_be32(&fsl_espi->regs->mask, SPIM_NE);
+
+	/* transmit word */
+	word = fsl_espi->get_tx(fsl_espi);
+	out_be32(&fsl_espi->regs->transmit, word);
+
+	wait_for_completion(&fsl_espi->done);
+
+	return t->len;
+}
+
+static void fsl_espi_chipselect(struct spi_device *spi, int is_on)
+{
+	return;
+}
+
+static int fsl_espi_setup(struct spi_device *spi)
+{
+	struct fsl_espi *fsl_espi;
+	int retval;
+	u32 hw_mode;
+	struct fsl_espi_cs	*cs = spi->controller_state;
+
+	if (spi->mode & ~MODEBITS) {
+		dev_dbg(&spi->dev, "setup: unsupported mode bits %x\n",
+			spi->mode & ~MODEBITS);
+		return -EINVAL;
+	}
+
+	if (!spi->max_speed_hz)
+		return -EINVAL;
+
+	if (!cs) {
+		cs = kzalloc(sizeof(*cs), GFP_KERNEL);
+		if (!cs)
+			return -ENOMEM;
+		spi->controller_state = cs;
+	}
+
+	fsl_espi = spi_master_get_devdata(spi->master);
+
+	if (!spi->bits_per_word)
+		spi->bits_per_word = 8;
+
+	hw_mode = cs->hw_mode; /* Save orginal settings */
+	cs->hw_mode =
+		in_be32(&fsl_espi->regs->csmode[spi->chip_select]);
+	/* mask out bits we are going to set */
+	cs->hw_mode &= ~(CSMODE_CP_BEGIN_EDGECLK | CSMODE_CI_INACTIVEHIGH
+			 | CSMODE_REV);
+
+	if (spi->mode & SPI_CPHA)
+		cs->hw_mode |= CSMODE_CP_BEGIN_EDGECLK;
+	if (spi->mode & SPI_CPOL)
+		cs->hw_mode |= CSMODE_CI_INACTIVEHIGH;
+	if (!(spi->mode & SPI_LSB_FIRST))
+		cs->hw_mode |= CSMODE_REV;
+
+	retval = fsl_espi_setup_transfer(spi, NULL);
+	if (retval < 0) {
+		cs->hw_mode = hw_mode; /* Restore settings */
+		return retval;
+	}
+
+	dev_dbg(&spi->dev, "%s, mode %d, %u bits/w, %u Hz\n",
+		__func__, spi->mode & (SPI_CPOL | SPI_CPHA),
+		spi->bits_per_word, spi->max_speed_hz);
+	return 0;
+}
+
+irqreturn_t fsl_espi_irq(s32 irq, void *context_data)
+{
+	struct fsl_espi *fsl_espi = context_data;
+	u32 event, rx_data, word;
+	int ret;
+
+	/* Get interrupt events(tx/rx) */
+	event = in_be32(&fsl_espi->regs->event);
+
+	/* We need handle RX first */
+	if (event & SPIE_NE) {
+		/* spin until RX is done */
+		void *event_ptr = &fsl_espi->regs->event;
+		int limit = min(4, fsl_espi->count);
+
+		ret = spin_event_timeout(
+			SPIE_RXCNT(event = in_be32(event_ptr)) >=  limit,
+			500, 0);
+		if (!ret)
+			return IRQ_NONE;
+		rx_data = in_be32(&fsl_espi->regs->receive);
+
+		if (fsl_espi->rx)
+			fsl_espi->get_rx(rx_data, fsl_espi);
+	} else {
+		/* Clear the events */
+		out_be32(&fsl_espi->regs->event, event);
+		return IRQ_HANDLED;
+	}
+
+	fsl_espi->count -= 4;
+	if (fsl_espi->count > 0) {
+		if ((event & SPIE_NF) == 0) {
+			/* spin until TX is done */
+			ret = spin_event_timeout((event =
+				in_be32(&fsl_espi->regs->event)) & SPIE_NF,
+				500, 0);
+			if (!ret)
+				return IRQ_NONE;
+		}
+		word = fsl_espi->get_tx(fsl_espi);
+		out_be32(&fsl_espi->regs->transmit, word);
+	} else {
+		fsl_espi->count = 0;
+		/* disable rx ints */
+		out_be32(&fsl_espi->regs->mask, 0);
+		complete(&fsl_espi->done);
+	}
+
+	/* Clear the events */
+	out_be32(&fsl_espi->regs->event, event);
+
+	return IRQ_HANDLED;
+}
+
+static void fsl_espi_cleanup(struct spi_device *spi)
+{
+	kfree(spi->controller_state);
+	spi->controller_state = NULL;
+}
+
+static int __init fsl_espi_probe(struct of_device *ofdev,
+					const struct of_device_id *match)
+{
+	struct spi_master *master;
+	struct fsl_espi *fsl_espi;
+	struct resource r_irq_struct;
+	struct resource r_mem_struct;
+	struct resource *r_irq = &r_irq_struct;
+	struct resource *r_mem = &r_mem_struct;
+	const u32 *prop;
+	u32 regval;
+	int ret = 0;
+	int len;
+
+	/* Get resources(memory, IRQ) associated with the device */
+	master = spi_alloc_master(&ofdev->dev, sizeof(struct fsl_espi));
+
+	if (master == NULL) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	dev_set_drvdata(&ofdev->dev, master);
+
+	ret = of_address_to_resource(ofdev->node, 0, r_mem);
+	if (ret) {
+		dev_warn(&ofdev->dev, "invalid address\n");
+		goto free_master;
+	}
+
+	ret = of_irq_to_resource(ofdev->node, 0, r_irq);
+	if (ret == NO_IRQ) {
+		dev_warn(&ofdev->dev, "no IRQ found\n");
+		goto free_master;
+	}
+
+	master->setup = fsl_espi_setup;
+	master->cleanup = fsl_espi_cleanup;
+
+	fsl_espi = spi_master_get_devdata(master);
+	fsl_espi->bitbang.master = spi_master_get(master);
+	fsl_espi->bitbang.chipselect = fsl_espi_chipselect;
+	fsl_espi->bitbang.txrx_bufs = fsl_espi_bufs;
+	fsl_espi->bitbang.setup_transfer = fsl_espi_setup_transfer;
+	fsl_espi->get_rx = fsl_espi_rx_buf;
+	fsl_espi->get_tx = fsl_espi_tx_buf;
+	fsl_espi->spibrg = fsl_get_sys_freq() / 2;
+
+	fsl_espi->rx_shift = 0;
+	fsl_espi->tx_shift = 0;
+
+	init_completion(&fsl_espi->done);
+
+	if (!request_mem_region(r_mem->start,
+				r_mem->end - r_mem->start + 1, "fsl-espi")) {
+		ret = -ENXIO;
+		dev_warn(&ofdev->dev, "memory request failure\n");
+		goto free_master;
+	}
+
+	fsl_espi->regs = ioremap(r_mem->start, r_mem->end - r_mem->start + 1);
+	if (fsl_espi->regs == NULL) {
+		ret = -ENOMEM;
+		goto put_master;
+	}
+
+	fsl_espi->irq = r_irq->start;
+	if (fsl_espi->irq < 0) {
+		ret = -ENXIO;
+		goto unmap_io;
+	}
+
+	/* Register for SPI Interrupt */
+	ret = request_irq(fsl_espi->irq, fsl_espi_irq,
+			  0, "fsl-espi", fsl_espi);
+
+	if (ret != 0)
+		goto unmap_io;
+
+	master->bus_num = -1;	/* dynamic bus assignment */
+	/* number of slave select bits is required */
+	prop = of_get_property(ofdev->node, "espi,num-ss-bits", &len);
+	if (!prop || len < sizeof(*prop)) {
+		dev_warn(&ofdev->dev, "no 'espi,num-ss-bits' property\n");
+		goto free_irq;
+	}
+	master->num_chipselect = *prop;
+
+	/* SPI controller initializations */
+	out_be32(&fsl_espi->regs->mode, 0);
+	out_be32(&fsl_espi->regs->mask, 0);
+	out_be32(&fsl_espi->regs->command, 0);
+	out_be32(&fsl_espi->regs->event, 0xffffffff);
+
+	/* Enable SPI interface */
+	regval = SPMODE_INIT_VAL | SPMODE_ENABLE;
+	out_be32(&fsl_espi->regs->mode, regval);
+	/* init CS mode interface */
+	for (ret = 0; ret < MAX_CS_NUM; ret++)
+		out_be32(&fsl_espi->regs->csmode[ret],
+				CSMODE_INIT_VAL);
+
+	ret = spi_bitbang_start(&fsl_espi->bitbang);
+	if (ret != 0) {
+		dev_err(&ofdev->dev, "spi_bitbang_start FAILED\n");
+		goto free_irq;
+	}
+
+	dev_info(&ofdev->dev,
+	       "Freescale eSPI Controller driver at 0x%p (irq = %d)\n",
+	       fsl_espi->regs, fsl_espi->irq);
+
+	/* add any subnodes on the SPI bus */
+	of_register_spi_devices(master, ofdev->node);
+
+	return ret;
+
+free_irq:
+	free_irq(fsl_espi->irq, fsl_espi);
+unmap_io:
+	iounmap(fsl_espi->regs);
+put_master:
+	spi_master_put(master);
+free_master:
+	kfree(master);
+err:
+	return ret;
+}
+
+static int __exit fsl_espi_remove(struct of_device *ofdev)
+{
+	struct fsl_espi *fsl_espi;
+	struct spi_master *master;
+	struct resource r_mem;
+
+	master = platform_get_drvdata(ofdev);
+	fsl_espi = spi_master_get_devdata(master);
+
+	spi_bitbang_stop(&fsl_espi->bitbang);
+
+	free_irq(fsl_espi->irq, fsl_espi);
+	iounmap(fsl_espi->regs);
+	fsl_espi->regs = NULL;
+	if (!of_address_to_resource(ofdev->node, 0, &r_mem))
+		release_mem_region(r_mem.start, resource_size(&r_mem));
+	dev_set_drvdata(&ofdev->dev, 0);
+	spi_master_put(fsl_espi->bitbang.master);
+
+	return 0;
+}
+
+static struct of_device_id fsl_espi_of_match[] = {
+	{ .compatible = "fsl,espi",},
+	{}
+};
+MODULE_DEVICE_TABLE(of, fsl_espi_of_match);
+
+MODULE_ALIAS("platform:fsl-espi");
+static struct of_platform_driver fsl_espi_driver = {
+	.owner = THIS_MODULE,
+	.name = "fsl-espi",
+	.match_table = fsl_espi_of_match,
+	.probe = fsl_espi_probe,
+	.remove = __exit_p(fsl_espi_remove),
+	.driver = {
+		.name = "fsl-espi",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init fsl_espi_init(void)
+{
+	return of_register_platform_driver(&fsl_espi_driver);
+}
+
+static void __exit fsl_espi_exit(void)
+{
+	of_unregister_platform_driver(&fsl_espi_driver);
+}
+
+module_init(fsl_espi_init);
+module_exit(fsl_espi_exit);
+
+MODULE_AUTHOR("Chen Gong <g.chen@freescale.com>, "
+	      "Jerry Huang <Chang-Ming.Huang@freescale.com>");
+MODULE_DESCRIPTION("Freescale eSPI Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/spi/spi_bitbang.c b/drivers/spi/spi_bitbang.c
index 96cc39e..e72ac06 100644
--- a/drivers/spi/spi_bitbang.c
+++ b/drivers/spi/spi_bitbang.c
@@ -303,7 +303,8 @@ static void bitbang_work(struct work_struct *work)
 		list_for_each_entry (t, &m->transfers, transfer_list) {
 
 			/* override or restore speed and wordsize */
-			if (t->speed_hz || t->bits_per_word) {
+			if (t->speed_hz || t->bits_per_word ||
+					spi->bits_per_word) {
 				setup_transfer = bitbang->setup_transfer;
 				if (!setup_transfer) {
 					status = -ENOPROTOOPT;
-- 
1.6.3.3

