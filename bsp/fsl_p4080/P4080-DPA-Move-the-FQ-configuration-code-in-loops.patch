From 5a38f81739e7549453eb98e45ba2d51f7631d842 Mon Sep 17 00:00:00 2001
From: Emil Medve <Emilian.Medve@Freescale.com>
Date: Mon, 30 Nov 2009 13:47:59 -0600
Subject: [PATCH] P4080/DPA: Move the FQ configuration code in loops

This saves some code size and makes the code more consistent. It also prepares for the OH port(s)
support

Signed-off-by: Emil Medve <Emilian.Medve@Freescale.com>
[Kevin: Original patch taken from Freescale p4080 SDK 2.0.2 tar
package, apply cleanly to kernel 2.6.27]
Integrated-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/dpa/dpa.c |  155 ++++++++++++++++++++-----------------------------
 1 files changed, 64 insertions(+), 91 deletions(-)

diff --git a/drivers/net/dpa/dpa.c b/drivers/net/dpa/dpa.c
index 2032cd5..aeb1d99 100644
--- a/drivers/net/dpa/dpa.c
+++ b/drivers/net/dpa/dpa.c
@@ -2255,38 +2255,6 @@ _return:
 	return _errno;
 }
 
-static const uint32_t *dpa_get_fqids(struct device_node *dpa_node,
-					const char *match, int *num)
-{
-	const uint32_t *fqids;
-
-	fqids = of_get_property(dpa_node, match, num);
-	if (unlikely(!fqids)) {
-		cpu_pr_err(KBUILD_MODNAME ": %s:%hu:%s(): "
-			   "of_get_property(%s, %s) failed\n",
-			   __file__, __LINE__, __func__,
-			   dpa_node->full_name, match);
-
-		*num = 0;
-		return NULL;
-	}
-
-	*num /= (2 * sizeof(*fqids));
-
-	return fqids;
-}
-
-static int dpa_count_fqs(const uint32_t *fqids, int num)
-{
-	int i;
-	int count = 0;
-
-	for (i = 0; i < num; i++)
-		count += fqids[2 * i + 1];
-
-	return count;
-}
-
 #ifdef CONFIG_DEBUG_FS
 static int __cold dpa_debugfs_show(struct seq_file *file, void *offset)
 {
@@ -2345,6 +2313,11 @@ static const struct file_operations dpa_debugfs_fops = {
 };
 #endif
 
+static const uint32_t default_fqids[][6] __devinitconst = {
+	[RX] = {0, 1, 0, 1},
+	[TX] = {0, 1, 0, 1, 0, ARRAY_SIZE(((struct dpa_priv_s *)0)->egress_fqs)}
+};
+
 static int __devinit __cold __attribute__((nonnull))
 dpa_probe(struct of_device *_of_dev)
 {
@@ -2363,14 +2336,12 @@ dpa_probe(struct of_device *_of_dev)
 	const uint32_t			*uint32_prop;
 	const uint8_t			*mac_addr;
 	struct qman_fq			*ingress_fq;
-	uint32_t		ingress_fqids[ARRAY_SIZE(ingress_fqs)][2];
-	const uint32_t		default_tx_fqids[] =
-				  {0, 1, 0, 1, 0, ARRAY_SIZE(priv->egress_fqs)};
-	const uint32_t		default_rx_fqids[] = {0, 1, 0, 1};
-	const uint32_t		*tx_fqids;
-	const uint32_t		*rx_fqids;
-	int			num_tx_fqids, num_tx_fqs;
-	int			num_rx_fqids, num_rx_fqs;
+	uint32_t		   ingress_fqids[ARRAY_SIZE(ingress_fqs)][2];
+	const uint32_t		  *fqids[ARRAY_SIZE(fsl_qman_frame_queues)];
+	int			   num_fqids[ARRAY_SIZE(fsl_qman_frame_queues)];
+	uint32_t		   num_fqs[ARRAY_SIZE(fsl_qman_frame_queues)];
+	uint32_t		   fqid;
+	uint8_t			   wq;
 
 	dev = &_of_dev->dev;
 
@@ -2504,12 +2475,19 @@ dpa_probe(struct of_device *_of_dev)
 		goto _return_free_percpu;
 	}
 
-	tx_fqids = dpa_get_fqids(dpa_node, "fsl,qman-frame-queues-tx",
-					&num_tx_fqids);
-	num_tx_fqs = dpa_count_fqs(tx_fqids, num_tx_fqids);
-	rx_fqids = dpa_get_fqids(dpa_node, "fsl,qman-frame-queues-rx",
-					&num_rx_fqids);
-	num_rx_fqs = dpa_count_fqs(rx_fqids, num_rx_fqids);
+	for (i = 0; i < ARRAY_SIZE(fqids); i++) {
+		fqids[i] = (typeof(fqids[i]))of_get_property(dpa_node,
+				fsl_qman_frame_queues[i], &lenp);
+		if (unlikely(fqids[i] == NULL)) {
+			cpu_dev_info(dev, "Using dynamic %s QM frame queues\n",
+				     rtx[i]);
+			num_fqids[i] = 0;
+		} else
+			num_fqids[i] = lenp / (sizeof(*fqids[i]) * 2);
+
+		for (j = 0, num_fqs[i] = 0; j < num_fqids[i]; j++)
+			num_fqs[i] += fqids[i][j * 2 + 1];
+	}
 
 	if(priv->mac_dev == NULL) {
 		if (netif_msg_probe(priv))
@@ -2533,15 +2511,16 @@ dpa_probe(struct of_device *_of_dev)
 
 		/* For now, stick to the idea that we have to have
 		 * static declarations on MAC-less devices */
-		if (!tx_fqids || !rx_fqids) {
-			cpu_dev_err(dev, "%s:%hu:%s(): "
-				"MAC-less interfaces require FQ declarations\n",
-				__file__, __LINE__, __func__);
-			_errno = -EINVAL;
-			goto _return_free_percpu;
-		}
+		for (i = 0; i < ARRAY_SIZE(fqids); i++)
+			if (unlikely(fqids[i])) {
+				cpu_dev_err(dev, "%s:%hu:%s(): "
+			     "MAC-less interfaces require %s FQ declarations\n",
+			      __file__, __LINE__, __func__, rtx[i]);
+				_errno = -EINVAL;
+				goto _return_free_percpu;
+			}
 
-		dpa_fq = devm_kzalloc(dev, sizeof(*dpa_fq) * num_rx_fqs,
+		dpa_fq = devm_kzalloc(dev, sizeof(*dpa_fq) * num_fqs[RX],
 					GFP_KERNEL);
 		if (unlikely(dpa_fq == NULL)) {
 			cpu_dev_err(dev, "%s:%hu:%s(): devm_kzalloc() failed\n",
@@ -2550,18 +2529,17 @@ dpa_probe(struct of_device *_of_dev)
 			goto _return_free_percpu;
 		}
 
-		for (i = 0; i < num_rx_fqids; i++) {
-			for (j = 0; j < rx_fqids[2 * i + 1]; j++, dpa_fq++) {
-				uint32_t fqid =
-					rx_fqids[2 * i] ?
-					rx_fqids[2 * i] + j : 0;
+		for (i = 0; i < num_fqids[RX]; i++) {
+			for (j = 0; j < fqids[RX][2 * i + 1]; j++, dpa_fq++) {
+				fqid = fqids[RX][2 * i] ?
+				       fqids[RX][2 * i] + j : 0;
 				/* The work queue will be set to the value
 				 * of the fqid mod 8.  This way, system
 				 * architects can choose the priority
 				 * of the frame queue by statically
 				 * assigning the fqid
 				 */
-				int wq = fqid ?
+				wq = fqid ?
 					fqid % net_dev->num_tx_queues :
 					net_dev->num_tx_queues - 1;
 
@@ -2585,10 +2563,10 @@ dpa_probe(struct of_device *_of_dev)
 			}
 		}
 
-		BUG_ON(num_tx_fqs != net_dev->num_tx_queues);
+		BUG_ON(num_fqs[TX] != net_dev->num_tx_queues);
 
 		/* FIXME: Horribly leaky */
-		dpa_fq = devm_kzalloc(dev, sizeof(*dpa_fq) * num_tx_fqs,
+		dpa_fq = devm_kzalloc(dev, sizeof(*dpa_fq) * num_fqs[TX],
 					GFP_KERNEL);
 		if (unlikely(dpa_fq == NULL)) {
 			cpu_dev_err(dev, "%s:%hu:%s(): devm_kzalloc() failed\n",
@@ -2597,8 +2575,8 @@ dpa_probe(struct of_device *_of_dev)
 			goto _return_free_percpu;
 		}
 
-		for (i = 0; i < tx_fqids[1]; i++, dpa_fq++) {
-			uint32_t fqid = tx_fqids[0] ? tx_fqids[0] + i : 0;
+		for (i = 0; i < fqids[TX][1]; i++, dpa_fq++) {
+			fqid = fqids[TX][0] ? fqids[TX][0] + i : 0;
 
 			dpa_fq->fq_base = _egress_fqs;
 			dpa_fq->net_dev	= net_dev;
@@ -2615,8 +2593,6 @@ dpa_probe(struct of_device *_of_dev)
 					qman_fq_fqid(priv->egress_fqs[i]));
 		}
 	} else {
-		uint32_t ingress_fq_cfg[2][2];
-
 		net_dev->mem_start	= priv->mac_dev->res->start;
 		net_dev->mem_end	= priv->mac_dev->res->end;
 
@@ -2646,21 +2622,19 @@ dpa_probe(struct of_device *_of_dev)
 
 		/* QM */
 
-		if (!tx_fqids) {
-			tx_fqids = &default_tx_fqids[0];
-			num_tx_fqids = ARRAY_SIZE(default_tx_fqids) / 2;
-			num_tx_fqs = dpa_count_fqs(tx_fqids, num_tx_fqids);
-		}
+		for (i = 0; i < ARRAY_SIZE(fqids); i++)
+			if (!fqids[i]) {
+				fqids[i] = default_fqids[i];
+				num_fqids[i] = ARRAY_SIZE(default_fqids[i]) / 2;
 
-		if (!rx_fqids) {
-			rx_fqids = &default_rx_fqids[0];
-			num_rx_fqids = ARRAY_SIZE(default_rx_fqids) / 2;
-			num_rx_fqs = dpa_count_fqs(rx_fqids, num_rx_fqids);
-		}
+				num_fqs[i] = 0;
+				for (j = 0; j < num_fqids[i]; j++)
+					num_fqs[i] += fqids[i][j * 2 + 1];
+			}
 
 		/* FIXME: Horribly leaky */
 		dpa_fq = devm_kzalloc(dev,
-				sizeof(*dpa_fq) * (num_tx_fqs + num_rx_fqs),
+				sizeof(*dpa_fq) * (num_fqs[TX] + num_fqs[RX]),
 				GFP_KERNEL);
 		if (unlikely(dpa_fq == NULL)) {
 			cpu_dev_err(dev, "%s:%hu:%s(): devm_kzalloc() failed\n",
@@ -2670,10 +2644,10 @@ dpa_probe(struct of_device *_of_dev)
 		}
 
 		/* device tree has default,error, but local array is reversed */
-		ingress_fq_cfg[0][1] = rx_fqids[0];
-		ingress_fq_cfg[0][0] = rx_fqids[2];
-		ingress_fq_cfg[1][1] = tx_fqids[0];
-		ingress_fq_cfg[1][0] = tx_fqids[2];
+		for (i = 0; i < ARRAY_SIZE(ingress_fqids); i++) {
+			ingress_fqids[i][1] = fqids[i][0];
+			ingress_fqids[i][0] = fqids[i][2];
+		}
 
 		for (i = 0; i < ARRAY_SIZE(ingress_fqs); i++) {
 			/* Error, default */
@@ -2683,7 +2657,7 @@ dpa_probe(struct of_device *_of_dev)
 				dpa_fq->net_dev	= net_dev;
 				ingress_fq = _dpa_fq_alloc(
 						priv->dpa_fq_list + RX,
-						dpa_fq, ingress_fq_cfg[i][j],
+						dpa_fq, ingress_fqids[i][j],
 						QMAN_FQ_FLAG_NO_ENQUEUE,
 						priv->channel, 7);
 				if (IS_ERR(ingress_fq)) {
@@ -2700,13 +2674,12 @@ dpa_probe(struct of_device *_of_dev)
 			}
 		}
 
-		/* Loop through the remaining fq assignments */
-		for (i = 2; i < num_rx_fqids; i++) {
-			for (j = 0; j < rx_fqids[2 * i + 1]; j++, dpa_fq++) {
-				uint32_t fqid =
-					rx_fqids[2 * i] ?
-					rx_fqids[2 * i] + j : 0;
-				int wq = fqid ?
+		/* Loop through the remaining FQ assignments */
+		for (; i < num_fqids[RX]; i++) {
+			for (j = 0; j < fqids[RX][2 * i + 1]; j++, dpa_fq++) {
+				fqid = fqids[RX][2 * i] ?
+				       fqids[RX][2 * i] + j : 0;
+				wq = fqid ?
 					fqid % net_dev->num_tx_queues :
 					net_dev->num_tx_queues - 1;
 
@@ -2729,10 +2702,10 @@ dpa_probe(struct of_device *_of_dev)
 			}
 		}
 
-		BUG_ON(tx_fqids[5] != net_dev->num_tx_queues);
+		BUG_ON(fqids[TX][5] != net_dev->num_tx_queues);
 
 		for (i = 0; i < net_dev->num_tx_queues; i++, dpa_fq++) {
-			uint32_t fqid = tx_fqids[4] ? tx_fqids[4] + i : 0;
+			fqid = fqids[TX][4] ? fqids[TX][4] + i : 0;
 
 			dpa_fq->fq_base	= _egress_fqs;
 			dpa_fq->net_dev	= net_dev;
-- 
1.6.0.4

