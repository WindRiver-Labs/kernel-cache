From cdba5fc5cfcfc365bbcaca5e521056fe75d340fc Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Wed, 12 May 2010 16:39:31 +0800
Subject: [PATCH 03/15] WRHV/fsl_p4080: Implement early printf for the first boot phase

Create one file, wrhv_p4080_ns16550.c, to support early printf for p4080ds. Here also
create one TLB entry to map UART space.

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/powerpc/boot/Makefile             |    9 +++-
 arch/powerpc/boot/wrhv_p4080_ns16550.c |  105 ++++++++++++++++++++++++++++++++
 2 files changed, 113 insertions(+), 1 deletions(-)
 create mode 100644 arch/powerpc/boot/wrhv_p4080_ns16550.c

diff --git a/arch/powerpc/boot/Makefile b/arch/powerpc/boot/Makefile
index 3ee4a77..08d380c 100644
--- a/arch/powerpc/boot/Makefile
+++ b/arch/powerpc/boot/Makefile
@@ -66,11 +66,18 @@ $(addprefix $(obj)/,$(libfdt) libfdt-wrapper.o simpleboot.o): \
 
 src-wlib := string.S crt0.S crtsavres.S stdio.c main.c \
 		$(libfdt) libfdt-wrapper.c \
-		ns16550.c serial.c simple_alloc.c div64.S util.S \
+		serial.c simple_alloc.c div64.S util.S \
 		gunzip_util.c elf_util.c $(zlib) devtree.c oflib.c ofconsole.c \
 		4xx.c ebony.c mv64x60.c mpsc.c mv64x60_i2c.c cuboot.c bamboo.c \
 		cpm-serial.c stdlib.c mpc52xx-psc.c planetcore.c uartlite.c \
 		fsl-soc.c mpc8xx.c pq2.c ugecon.c
+
+ifeq ($(CONFIG_WRHV_P4080DS),y)
+src-wlib += wrhv_p4080_ns16550.c
+else
+src-wlib += ns16550.c
+endif
+
 src-plat := of.c cuboot-52xx.c cuboot-824x.c cuboot-83xx.c cuboot-85xx.c holly.c \
 		cuboot-ebony.c cuboot-hotfoot.c treeboot-ebony.c prpmc2800.c \
 		ps3-head.S ps3-hvcall.S ps3.c treeboot-bamboo.c cuboot-8xx.c \
diff --git a/arch/powerpc/boot/wrhv_p4080_ns16550.c b/arch/powerpc/boot/wrhv_p4080_ns16550.c
new file mode 100644
index 0000000..dcb8e21
--- /dev/null
+++ b/arch/powerpc/boot/wrhv_p4080_ns16550.c
@@ -0,0 +1,105 @@
+/*
+ * 16550 serial console support for E500mc.
+ *
+ * Copyright (C) 2009-2010 Wind River Systems, Inc.
+ *
+ */
+#include <stdarg.h>
+#include <stddef.h>
+#include "types.h"
+#include "string.h"
+#include "stdio.h"
+#include "io.h"
+#include "ops.h"
+
+#define UART_DLL	0	/* Out: Divisor Latch Low */
+#define UART_DLM	1	/* Out: Divisor Latch High */
+#define UART_FCR	2	/* Out: FIFO Control Register */
+#define UART_LCR	3	/* Out: Line Control Register */
+#define UART_MCR	4	/* Out: Modem Control Register */
+#define UART_LSR	5	/* In:  Line Status Register */
+#define UART_LSR_THRE	0x20	/* Transmit-hold-register empty */
+#define UART_LSR_DR	0x01	/* Receiver data ready */
+#define UART_MSR	6	/* In:  Modem Status Register */
+#define UART_SCR	7	/* I/O: Scratch Register */
+
+static unsigned char *reg_base;
+static u32 reg_shift;
+
+static int ns16550_open(void)
+{
+	out_8(reg_base + (UART_FCR << reg_shift), 0x06);
+	return 0;
+}
+
+static void ns16550_putc(unsigned char c)
+{
+	while ((in_8(reg_base + (UART_LSR << reg_shift)) & UART_LSR_THRE) == 0);
+	out_8(reg_base, c);
+}
+
+static unsigned char ns16550_getc(void)
+{
+	while ((in_8(reg_base + (UART_LSR << reg_shift)) & UART_LSR_DR) == 0);
+	return in_8(reg_base);
+}
+
+static u8 ns16550_tstc(void)
+{
+	return ((in_8(reg_base + (UART_LSR << reg_shift)) & UART_LSR_DR) != 0);
+}
+
+#define TLBWE_CODE		0x7C0007A4
+#define MAS0_TLBSEL0_ENTRY0	0x0
+#define MAS1_VALID_4K_TSIZE	(0x80000000|((1 << 8) & 0x00000F00))
+#define MAS2_IG			0x0000000a
+#define MAS2_SXWR		0x00000015
+
+/* Here we have to create ont TLB0 entry to map uart since the Hypervisor dose
+ * not map this while pass the guest OS on E500mc. */
+static void wrhv_uart_tlb0_create(void)
+{
+	/* Write MAS0/1/2/3 to create tlb0 to map uart. And note 
+	 * r3 should be privileged instruction code as the HY expect. */
+	__asm__ __volatile__(
+		"mtspr  0x270,%0\n"
+		"mtspr  0x271,%1\n"
+		"mtspr  0x272,%2\n"
+		"mtspr  0x273,%3\n"
+		"lis    3,%4@h\n"
+		"ori    3,3,%4@l\n"
+		"tlbwe\n"
+	:
+	:"r" (MAS0_TLBSEL0_ENTRY0), "r" (MAS1_VALID_4K_TSIZE),
+		"r" ((unsigned int)reg_base|MAS2_IG), 
+		"r" ((unsigned int)reg_base|MAS2_SXWR), 
+		"i" (TLBWE_CODE)
+	);
+}
+
+int ns16550_console_init(void *devp, struct serial_console_data *scdp)
+{
+	int n;
+	u32 reg_offset;
+
+	if (dt_get_virtual_reg(devp, (void **)&reg_base, 1) < 1)
+		return -1;
+
+	n = getprop(devp, "reg-offset", &reg_offset, sizeof(reg_offset));
+	if (n == sizeof(reg_offset))
+		reg_base += reg_offset;
+
+	n = getprop(devp, "reg-shift", &reg_shift, sizeof(reg_shift));
+	if (n != sizeof(reg_shift))
+		reg_shift = 0;
+
+	wrhv_uart_tlb0_create();
+
+	scdp->open = ns16550_open;
+	scdp->putc = ns16550_putc;
+	scdp->getc = ns16550_getc;
+	scdp->tstc = ns16550_tstc;
+	scdp->close = NULL;
+
+	return 0;
+}
-- 
1.6.5.2

