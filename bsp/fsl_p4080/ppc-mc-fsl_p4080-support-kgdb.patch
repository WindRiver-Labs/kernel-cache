From 78877bd85d6f8578a5efb2df65112d37948bde39 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Thu, 2 Sep 2010 20:24:23 -0700
Subject: [PATCH] ppc-mc/fsl_p4080: support kgdb

For e500mc we can access those debug REGs by trapping the privileged exception.
On there the HY will emulate mfspr/mtspr debug REGs then pass actual result to
guest OS.

And fix the original DEBUG exception entry like e500.

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/powerpc/include/asm/reg.h        |    2 +-
 arch/powerpc/kernel/head_wrhv_p4080.S |    6 +-
 arch/powerpc/kernel/vbi/wrhv.c        |   79 ++++++++++++++++++++++++++++++++-
 3 files changed, 81 insertions(+), 6 deletions(-)

diff --git a/arch/powerpc/include/asm/reg.h b/arch/powerpc/include/asm/reg.h
index 3ef54b0..ce6bbf0 100644
--- a/arch/powerpc/include/asm/reg.h
+++ b/arch/powerpc/include/asm/reg.h
@@ -894,7 +894,7 @@
 			asm volatile("mfspr %0," __stringify(rn) \
 				: "=r" (rval)); rval;})
 
-#ifdef CONFIG_WRHV
+#if defined(CONFIG_WRHV) && !defined(CONFIG_PPC85xx_VT_MODE)
 extern void wrhv_mtspr(unsigned int, unsigned int);
 #define mtspr(rn, v)	wrhv_mtspr(rn, v)
 #else
diff --git a/arch/powerpc/kernel/head_wrhv_p4080.S b/arch/powerpc/kernel/head_wrhv_p4080.S
index 34e5eac..32197b5 100644
--- a/arch/powerpc/kernel/head_wrhv_p4080.S
+++ b/arch/powerpc/kernel/head_wrhv_p4080.S
@@ -480,7 +480,8 @@ interrupt_base:
 	addi	r3,r1,STACK_FRAME_OVERHEAD
 	EXC_XFER_EE_LITE(0x2010, KernelSPE)
 #else
-	EXCEPTION(0x2020, SPEUnavailable, unknown_exception, EXC_XFER_EE)
+	/* Debug Interrupt */
+	DEBUG_DEBUG_EXCEPTION
 #endif /* CONFIG_SPE */
 
 	/* SPE Floating Point Data */
@@ -503,8 +504,7 @@ interrupt_base:
 
 	EXCEPTION(0x2090, DirectExternalInput, wrhv_do_direct_IRQ, EXC_XFER_LITE)
 
-	/* Debug Interrupt */
-	DEBUG_DEBUG_EXCEPTION
+	/* Debug CRIT Interrupt */
 	DEBUG_CRIT_EXCEPTION
 
 /*
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index a26339d..3c11ba6 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -1346,21 +1346,82 @@ static void wrhv_handle_debug(struct pt_regs *regs, unsigned long debug_status)
 		mtspr(SPRN_DBCR0, current->thread.dbcr0);
 }
 
+#define SPRN_DBSR_W 0x7c904ba6	/* mtspr SPRN_DBSR,r4 */
+#define SPRN_DBSR_R 0x7c904aa6  /* mfspr r4,SPRN_DBSR */
+#define SPRN_DBCR0_W 0x7c944ba6 /* mtspr SPRN_DBCR0,r4 */
+#define SPRN_DBCR0_R 0x7c944aa6 /* mfspr r4,SPRN_DBCR0 */
 /* arch/powerpc/include/asm/reg.h */
 void wrhv_mtspr(unsigned int sprn, unsigned int value)
 {
 
 	switch(sprn){
 		case SPRN_DBCR0:
+#ifdef CONFIG_PPC85xx_VT_MODE
+			__asm__ __volatile__(
+			"lis    3,%0@h\n"
+			"ori    3,3,%0@l\n"
+			"mr	4,%1\n"
+			"mtspr	0x134,4\n"
+			::"i" (SPRN_DBCR0_W), "r" (value)
+			);
+#else
 			wr_control->vb_control_regs.dbcr0 = value;
+#endif
 			break;
 
 		case SPRN_DBSR:
+#ifdef CONFIG_PPC85xx_VT_MODE
+			__asm__ __volatile__(
+			"lis    3,%0@h\n"
+			"ori    3,3,%0@l\n"
+			"mr	4,%1\n"
+			"mtspr	0x130,4\n"
+			::"i" (SPRN_DBSR_W), "r" (value)
+			);
+#else
 			wr_control->vb_control_regs.dbsr = value;
+#endif
 			break;
 	}
 }
 
+unsigned int wrhv_mfspr(unsigned int sprn)
+{
+	unsigned int value = 0;
+	switch(sprn){
+		case SPRN_DBCR0:
+#ifdef CONFIG_PPC85xx_VT_MODE
+			__asm__ __volatile__(
+			"lis    3,%1@h\n"
+			"ori    3,3,%1@l\n"
+			"mfspr	4,0x134\n"
+			"mr	%0,4\n"
+			:"=r" (value)
+			:"i" (SPRN_DBCR0_R)
+			);
+#else
+			value = wr_control->vb_control_regs.dbcr0;
+#endif
+			break;
+
+		case SPRN_DBSR:
+#ifdef CONFIG_PPC85xx_VT_MODE
+			__asm__ __volatile__(
+			"lis    3,%1@h\n"
+			"ori    3,3,%1@l\n"
+			"mfspr	4,0x130\n"
+			"mr	%0,4\n"
+			:"=r" (value)
+			:"i" (SPRN_DBSR_R)
+			);
+#else
+			value = wr_control->vb_control_regs.dbsr;
+#endif
+			break;
+	}
+
+	return value;
+}
 
 /* arch/powerpc/kernel/traps.c */
 void __kprobes wrhv_DebugException(struct pt_regs *regs, unsigned long debug_status)
@@ -1378,10 +1439,12 @@ void __kprobes wrhv_DebugException(struct pt_regs *regs, unsigned long debug_sta
 	if (debug_status & DBSR_BT) {
 		regs->msr &= ~MSR_DE;
 
+#ifdef CONFIG_PPC85xx_VT_MODE
 		/* Disable BT */
-		mtspr(SPRN_DBCR0, mfspr(SPRN_DBCR0) & ~DBCR0_BT);
+		wrhv_mtspr(SPRN_DBCR0, wrhv_mfspr(SPRN_DBCR0) & ~DBCR0_BT);
 		/* Clear the BT event */
-		mtspr(SPRN_DBSR, DBSR_BT);
+		wrhv_mtspr(SPRN_DBSR, DBSR_BT);
+#endif
 
 		/* Do the single step trick only when coming from userspace */
 		if (user_mode(regs)) {
@@ -1400,6 +1463,13 @@ void __kprobes wrhv_DebugException(struct pt_regs *regs, unsigned long debug_sta
 	} else if (debug_status & DBSR_IC) { 	/* Instruction complete */
 		regs->msr &= ~MSR_DE;
 
+#ifdef CONFIG_PPC85xx_VT_MODE
+		/* Disable instruction completion */
+		wrhv_mtspr(SPRN_DBCR0, wrhv_mfspr(SPRN_DBCR0) & ~DBCR0_IC);
+		/* Clear the instruction completion event */
+		wrhv_mtspr(SPRN_DBSR, DBSR_IC);
+#endif
+
 		if (notify_die(DIE_SSTEP, "single_step", regs, 5,
 			       5, SIGTRAP) == NOTIFY_STOP) {
 			return;
@@ -1448,7 +1518,12 @@ int wrhv_kgdb_arch_handle_exception(int vector, int signo, int err_code,
 		/* set the trace bit if we're stepping */
 		if (remcom_in_buffer[0] == 's') {
 #ifdef CONFIG_PPC_ADV_DEBUG_REGS
+#ifdef CONFIG_PPC85xx_VT_MODE
+			wrhv_mtspr(SPRN_DBCR0,
+			      wrhv_mfspr(SPRN_DBCR0) | DBCR0_IC | DBCR0_IDM);
+#else
 			wr_control->vb_control_regs.dbcr0 |= (DBCR0_IC | DBCR0_IDM);
+#endif
 			wr_control->vb_control_regs.emsr |= MSR_DE;
 			linux_regs->msr |= MSR_DE;
 #else
-- 
1.6.5.2

