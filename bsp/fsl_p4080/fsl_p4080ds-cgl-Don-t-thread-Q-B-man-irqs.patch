From 9dea1f997c12841bde957c5fef1d4780215bc3da Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Fri, 2 Jul 2010 16:43:35 +0800
Subject: [PATCH] fsl_p4080ds/cgl: Don't thread Q/B man irqs.

When Q/B man irqs are threaded, actually QmEnqueueCB cannot relax CPU with
udelay() which is one busy-waiting, and cpu_realx which is really implemented
only as a barrier. So the apropriate interrupt route may not be waked up to
handle QmEnqueue then sync their flag since the irqs already threaded.

So here create one work queue to make QmEnqueueCB can sleep after its QmEnqueue.
Then the interrupt route can have a chance to be scheduled to do with QmEnqueue.

Note we will backport Q/B man irqs to the original thread mode. Here make the
changes conditional on the hard/soft irq threading Kconfig options. That allows it
to fall gracefully back to the no workqueue version of the driver.

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 .../kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c |   30 ++++++++++++++++++-
 1 files changed, 28 insertions(+), 2 deletions(-)

diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
index 6b670bb..2305fc4 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
@@ -461,7 +461,16 @@ static irqreturn_t fm_err_irq(int irq, void *_dev)
     return IRQ_HANDLED;
 }
 
+#if defined(CONFIG_PREEMPT_HARDIRQS) || defined(CONFIG_PREEMPT_SOFTIRQS)
+enum {
+	HC_FRMRCV_COMPLETE,
+	HC_FRMRCV_READY,
+};
+static volatile int hcFrmRcv = HC_FRMRCV_READY;
+static DECLARE_WAIT_QUEUE_HEAD(wq);
+#else
 static volatile int   hcFrmRcv = 0;
+#endif
 
 static enum qman_cb_dqrr_result qm_tx_conf_dqrr_cb(struct qman_portal          *portal,
                                                    struct qman_fq              *fq,
@@ -470,7 +479,12 @@ static enum qman_cb_dqrr_result qm_tx_conf_dqrr_cb(struct qman_portal          *
     t_LnxWrpFmDev       *p_LnxWrpFmDev = ((t_FmTestFq *)fq)->h_Arg;
 
     FM_PCD_HcTxConf(p_LnxWrpFmDev->h_PcdDev, (t_FmFD *)&dq->fd);
+#if defined(CONFIG_PREEMPT_HARDIRQS) || defined(CONFIG_PREEMPT_SOFTIRQS)
+	hcFrmRcv = HC_FRMRCV_COMPLETE;
+	wake_up_interruptible(&wq);
+#else
     hcFrmRcv--;
+#endif
 
     return qman_cb_dqrr_consume;
 }
@@ -546,23 +560,35 @@ static struct qman_fq * FqAlloc(t_LnxWrpFmDev   *p_LnxWrpFmDev,
 static t_Error QmEnqueueCB (t_Handle h_Arg, uint32_t fqid, void *p_Fd)
 {
     t_LnxWrpFmDev   *p_LnxWrpFmDev = (t_LnxWrpFmDev*)h_Arg;
-    int             _errno, timeout=1000000;
+    int             _errno;
+#if !defined(CONFIG_PREEMPT_HARDIRQS) && !defined(CONFIG_PREEMPT_SOFTIRQS)
+    int             timeout=1000000;
+#endif
 
     ASSERT_COND(p_LnxWrpFmDev);
     UNUSED(fqid);
 
+#if defined(CONFIG_PREEMPT_HARDIRQS) || defined(CONFIG_PREEMPT_SOFTIRQS)
+	hcFrmRcv=HC_FRMRCV_READY;
+#else
     hcFrmRcv++;
+#endif
 //MemDisp((uint8_t*)p_Fd,sizeof(t_FmFD));
     _errno = qman_enqueue(p_LnxWrpFmDev->hc_tx_fq, (struct qm_fd*)p_Fd, 0);
     if (_errno)
         RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
 
+#if defined(CONFIG_PREEMPT_HARDIRQS) || defined(CONFIG_PREEMPT_SOFTIRQS)
+	wait_event_interruptible_timeout(wq, hcFrmRcv == HC_FRMRCV_COMPLETE, 
+			msecs_to_jiffies(250));
+#else
     while (hcFrmRcv && --timeout)
     {
         udelay(1);
         cpu_relax();
     }
     BUG_ON(!timeout);
+#endif
 
     return E_OK;
 }
@@ -695,7 +721,7 @@ typedef _Packed struct {
  * allows older systems to continue functioning.  0xFEF000000 is the address
  * where the firmware is normally on a P4080DS.
  */
-static phys_addr_t P4080_UCAddr = 0xfef000000;
+static phys_addr_t P4080_UCAddr = 0xfef000000ULL;
 
 
 /**
-- 
1.6.5.2

