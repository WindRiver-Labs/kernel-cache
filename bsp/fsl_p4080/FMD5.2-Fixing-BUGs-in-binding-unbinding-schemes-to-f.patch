From 5cccac0ccfde4a1cef10d04684847c6a5fd9a9c5 Mon Sep 17 00:00:00 2001
From: Shlomi Gridish <gridish@freescale.com>
Date: Wed, 5 Aug 2009 12:11:38 +0300
Subject: [PATCH 019/148] FMD5.2 Fixing BUGs in binding/unbinding schemes to/from port.

Signed-off-by: Shlomi Gridish <gridish@freescale.com>
[Cleanly applied the FSL SDK 2.0.3 patch:
"0001-FMD5.2.patch"]
Integrated-by: Yuri Nedel <Yuri.Nedel@windriver.com>
---
 drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c   |  223 ++++----------------
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c   |   96 +++++----
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c  |   12 +-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.c    |  222 +++++++-------------
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_common.h   |    5 +-
 .../net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h   |    3 +
 .../kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c |   23 ++-
 drivers/net/dpa/mac.c                              |   12 -
 8 files changed, 191 insertions(+), 405 deletions(-)

diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c
index f5214aa..c67d2b0 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c
@@ -185,14 +185,6 @@ typedef struct t_FmHc {
 } t_FmHc;
 
 
-t_Error     FmHcPortSetPCD(t_Handle h_FmHc, t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams);
-t_Error     FmHcPortDeletePCD(t_Handle h_FmHc, t_Handle h_FmPort);
-
-t_Error     FmHcPortPcdKgModifyClsPlanGrp (t_Handle h_FmHc, t_Handle h_FmPort, bool useClsPlan, t_Handle h_NewClsPlanGrp);
-t_Error     FmHcPortPcdKgBindSchemes(t_Handle h_FmHc , t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme);
-t_Error     FmHcPortPcdKgUnbindSchemes(t_Handle h_FmHc , t_Handle h_FmPort);
-
-
 static t_Error KgHcSetClsPlan(t_FmHc *p_FmHc, t_FmPcdKgInterModuleClsPlanSet *p_Set)
 {
     t_HcFrame               hcFrame;
@@ -219,64 +211,6 @@ static t_Error KgHcSetClsPlan(t_FmHc *p_FmHc, t_FmPcdKgInterModuleClsPlanSet *p_
     return E_OK;
 }
 
-static t_Error KgHcWriteSp(t_FmHc *p_FmHc, uint8_t hardwarePortId, uint32_t spReg, bool add)
-{
-    t_HcFrame               hcFrame;
-    t_FmFD                  fmFd;
-    t_Error                 err;
-
-    ASSERT_COND(p_FmHc);
-
-    memset(&hcFrame, 0, sizeof(hcFrame));
-    /* first read SP register */
-    hcFrame.opcode = 0x00000001;
-    hcFrame.actionReg  = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
-    hcFrame.extraReg = 0xFFFFF800;
-    hcFrame.commandSequence = p_FmHc->seqNum;
-
-    BUILD_FD(SIZE_OF_HC_FRAME_PORT_REGS);
-
-    ENQUEUE_FRM(&fmFd);
-
-    /* spReg is the first reg, so we can use it bothe for read and for write */
-    if(add)
-        hcFrame.hcSpecificData.portRegsForRead.spReg |= spReg;
-    else
-        hcFrame.hcSpecificData.portRegsForRead.spReg &= ~spReg;
-
-    hcFrame.actionReg  = FmPcdKgBuildWritePortSchemeBindActionReg(hardwarePortId);
-    hcFrame.commandSequence = p_FmHc->seqNum;
-
-    BUILD_FD(sizeof(hcFrame));
-
-    ENQUEUE_FRM(&fmFd);
-
-    return E_OK;
-}
-
-static t_Error KgHcWriteCpp(t_FmHc *p_FmHc, uint8_t hardwarePortId, uint32_t cppReg)
-{
-    t_HcFrame               hcFrame;
-    t_FmFD                  fmFd;
-    t_Error                 err;
-
-    ASSERT_COND(p_FmHc);
-
-    memset(&hcFrame, 0, sizeof(hcFrame));
-    /* first read SP register */
-    hcFrame.opcode = 0x00000001;
-    hcFrame.actionReg  = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
-    hcFrame.extraReg = 0xFFFFF800;
-    hcFrame.commandSequence = p_FmHc->seqNum;
-    hcFrame.hcSpecificData.singleRegForWrite = cppReg;
-
-    BUILD_FD(sizeof(hcFrame));
-
-    ENQUEUE_FRM(&fmFd);
-
-    return E_OK;
-}
-
 static t_Error CcHcDoDynamicChange(t_FmHc *p_FmHc, bool keyModify, t_Handle p_OldPointer, t_Handle p_NewPointer)
 {
     t_HcFrame               hcFrame;
@@ -349,34 +283,6 @@ static t_Error HcDynamicChangeForKey(t_FmHc *p_FmHc,t_Handle  *h_OldPointersLst,
     return E_OK;
 }
 
-static t_Error HcPortPcdKgBindSchemes(t_FmHc *p_FmHc , t_Handle h_FmPort,t_FmPcdPortSchemesParams *p_PortScheme)
-{
-    uint32_t                                spReg;
-    t_Error                                 err;
-    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
-    int                                     i;
-
-    /* we use this routine just to get the port parameters such as HW id, netEnv etc. */
-    FmPortGetPortSchemeBindParams(h_FmPort, &schemeBind, FALSE);
-
-    /* overwrite port params with the schemes we want removed */
-    schemeBind.numOfSchemes = p_PortScheme->numOfSchemes;
-    for (i=0; i<schemeBind.numOfSchemes; i++)
-        schemeBind.schemesIds[i] = (uint8_t)(CAST_POINTER_TO_UINT32(p_PortScheme->h_Schemes[i])-1);
-
-    err = FmPcdKgBuildBindPortToSchemes(p_FmHc->h_FmPcd, &schemeBind, &spReg, TRUE);
-    if(err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-
-    err = KgHcWriteSp(p_FmHc, schemeBind.hardwarePortId, spReg, TRUE);
-    if(err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-
-    FmPcdKgIncSchemeOwners(p_FmHc->h_FmPcd, &schemeBind);
-
-    return E_OK;
-}
-
 t_Handle    FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
 {
     t_FmHc          *p_FmHc;
@@ -1210,115 +1116,62 @@ t_Error FmHcPcdCcModifyKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex,
     return err;
 }
 
-t_Error FmHcPortPcdKgModifyClsPlanGrp (t_Handle h_FmHc, t_Handle h_FmPort, bool useClsPlan, t_Handle h_NewClsPlanGrp)
+t_Error FmHcKgWriteSp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t spReg, bool add)
 {
-    t_FmHc          *p_FmHc = (t_FmHc*)h_FmHc;
-    t_Error         err;
-    uint32_t        cppReg;
-
-    /* deal with SW */
-    FmPortPcdKgSwUnbindClsPlanGrp(h_FmPort);
-
-    err = FmPortPcdKgSwBindClsPlanGrp(h_FmPort, useClsPlan, (uint8_t)(CAST_POINTER_TO_UINT32(h_NewClsPlanGrp)-1));
-    if(err)
-        RETURN_ERROR(MINOR, err, NO_MSG);
+    t_FmHc                  *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame               hcFrame;
+    t_FmFD                  fmFd;
+    t_Error                 err;
 
-    /* deal with HW */
-    cppReg = FmPcdKgBuildCppReg(p_FmHc->h_FmPcd, FmPortGetClsPlanId(h_FmPort));
-    err = KgHcWriteCpp(p_FmHc, FmPortGetHardwarePortId(h_FmPort), cppReg);
+    ASSERT_COND(p_FmHc);
 
-    return err;
-}
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    /* first read SP register */
+    hcFrame.opcode = 0x00000001;
+    hcFrame.actionReg  = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
+    hcFrame.extraReg = 0xFFFFF800;
+    hcFrame.commandSequence = p_FmHc->seqNum;
 
-t_Error FmHcPortPcdKgBindSchemes(t_Handle h_FmHc , t_Handle h_FmPort,t_FmPcdPortSchemesParams *p_PortScheme)
-{
-    return HcPortPcdKgBindSchemes(h_FmHc, h_FmPort, p_PortScheme);
-}
+    BUILD_FD(SIZE_OF_HC_FRAME_PORT_REGS);
 
-t_Error FmHcPortPcdKgUnbindSchemes(t_Handle h_FmHc , t_Handle h_FmPort)
-{
-    t_FmHc                                  *p_FmHc = (t_FmHc*)h_FmHc;
-    uint32_t                                spReg;
-    t_Error                                 err;
-    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+    ENQUEUE_FRM(&fmFd);
 
-    /* we use this routine just to get the port parameters such as HW id, netEnv etc. */
-    FmPortGetPortSchemeBindParams(h_FmPort, &schemeBind, TRUE);
+    /* spReg is the first reg, so we can use it bothe for read and for write */
+    if(add)
+        hcFrame.hcSpecificData.portRegsForRead.spReg |= spReg;
+    else
+        hcFrame.hcSpecificData.portRegsForRead.spReg &= ~spReg;
 
-    err = FmPcdKgBuildBindPortToSchemes(p_FmHc->h_FmPcd, &schemeBind, &spReg, FALSE);
-    if(err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    hcFrame.actionReg  = FmPcdKgBuildWritePortSchemeBindActionReg(hardwarePortId);
+    hcFrame.commandSequence = p_FmHc->seqNum;
 
-    err = KgHcWriteSp(h_FmHc, schemeBind.hardwarePortId, spReg, FALSE);
-    if(err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    BUILD_FD(sizeof(hcFrame));
 
-    FmPcdKgDecSchemeOwners(p_FmHc->h_FmPcd, &schemeBind);
+    ENQUEUE_FRM(&fmFd);
 
     return E_OK;
 }
 
-t_Error FmHcPortSetPCD(t_Handle h_FmHc, t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
-{
-    t_FmHc                                  *p_FmHc = (t_FmHc*)h_FmHc;
-    t_Error                                 err = E_OK;
-    t_FmPcdPortSchemesParams                currentSchemes;
-    uint32_t                                cppReg;
-    uint8_t                                 i;
-
-    err = FmPortSetPcd(h_FmPort, p_PcdParams);
-    if(err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-
-    if(FmPortGetPcdEngines(h_FmPort) & FM_PCD_KG)
-    {
-        currentSchemes.numOfSchemes = p_PcdParams->p_KgParams->numOfSchemes;
-        for(i = 0;i<currentSchemes.numOfSchemes;i++)
-            currentSchemes.h_Schemes[i] = p_PcdParams->p_KgParams->h_Schemes[i];
-        err = HcPortPcdKgBindSchemes(h_FmHc ,h_FmPort, &currentSchemes);
-        if(err)
-        {
-            FmPortDeletePcd(h_FmPort);
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-        }
-
-        cppReg = FmPcdKgBuildCppReg(p_FmHc->h_FmPcd, FmPortGetClsPlanId(h_FmPort));
-
-        err = KgHcWriteCpp(p_FmHc, FmPortGetHardwarePortId(h_FmPort), cppReg);
-        if(err)
-        {
-            FmHcPortPcdKgUnbindSchemes(p_FmHc->h_FmPcd, h_FmPort);
-            FmPortDeletePcd(h_FmPort);
-            RETURN_ERROR(MINOR, err, NO_MSG);
-        }
-    }
-
-    FmPcdIncNetEnvOwners(p_FmHc->h_FmPcd, FmPortGetNetEnvId(h_FmPort));
-
-    return FmPortAttachPCD(h_FmPort);
-}
-
-t_Error FmHcPortDeletePCD(t_Handle h_FmHc, t_Handle h_FmPort)
+t_Error FmHcKgWriteCpp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t cppReg)
 {
-    t_FmHc                                  *p_FmHc = (t_FmHc*)h_FmHc;
-    t_Error                                 err = E_OK;
+    t_FmHc                  *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame               hcFrame;
+    t_FmFD                  fmFd;
+    t_Error                 err;
 
-    if(FmPortGetPcdEngines(h_FmPort) & FM_PCD_KG)
-    {
-        err = FmHcPortPcdKgUnbindSchemes(h_FmHc , h_FmPort);
-        if(err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+    ASSERT_COND(p_FmHc);
 
-        err = KgHcWriteCpp(p_FmHc, FmPortGetHardwarePortId(h_FmPort), 0);
-        if(err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-    }
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    /* first read SP register */
+    hcFrame.opcode = 0x00000001;
+    hcFrame.actionReg  = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
+    hcFrame.extraReg = 0xFFFFF800;
+    hcFrame.commandSequence = p_FmHc->seqNum;
+    hcFrame.hcSpecificData.singleRegForWrite = cppReg;
 
-    err = FmPortDeletePcd( h_FmPort);
-    if(err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    BUILD_FD(sizeof(hcFrame));
 
-    FmPcdDecNetEnvOwners(p_FmHc->h_FmPcd, FmPortGetNetEnvId(h_FmPort));
+    ENQUEUE_FRM(&fmFd);
 
     return E_OK;
 }
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
index f9847f4..6e96b9f 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
@@ -1183,45 +1183,71 @@ static void PcdKgErrorException(t_Handle h_FmPcd)
     }
 }
 
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
-static t_Error KgWriteSp(t_FmPcd *p_FmPcd , uint8_t hardwarePortId, uint32_t spReg, bool add)
+static t_Error KgWriteSp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t spReg, bool add)
 {
-    t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
-    uint32_t                tmpKgarReg = 0, tmpKgpeSp;
-    t_Error                 err;
-
-    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
+    if (p_FmPcd->h_Hc)
+        return FmHcKgWriteSp(p_FmPcd->h_Hc, hardwarePortId, spReg, add);
+    else
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+#else
+    {
+        t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
+        uint32_t                tmpKgarReg = 0, tmpKgpeSp;
+        t_Error                 err;
 
-    tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
+        p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
 
-    err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-    if(err)
-        RETURN_ERROR(MINOR, err, NO_MSG);
+        tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
 
-    tmpKgpeSp = GET_UINT32(p_FmPcdKgPortRegs->kgoe_sp);
+        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
 
-    if(add)
-        tmpKgpeSp |= spReg;
-    else
-        tmpKgpeSp &= ~spReg;
+        tmpKgpeSp = GET_UINT32(p_FmPcdKgPortRegs->kgoe_sp);
 
+        if(add)
+            tmpKgpeSp |= spReg;
+        else
+            tmpKgpeSp &= ~spReg;
 
-    WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_sp, tmpKgpeSp);
+        WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_sp, tmpKgpeSp);
 
-    tmpKgarReg = FmPcdKgBuildWritePortSchemeBindActionReg(hardwarePortId);
+        tmpKgarReg = FmPcdKgBuildWritePortSchemeBindActionReg(hardwarePortId);
 
-    err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-    if(err)
-        RETURN_ERROR(MINOR, err, NO_MSG);
+        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
 
     return E_OK;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+static t_Error KgWriteCpp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t cppReg)
+{
+    if (p_FmPcd->h_Hc)
+        return FmHcKgWriteCpp(p_FmPcd->h_Hc, hardwarePortId, cppReg);
+    else
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+#else
+    {
+        t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
+        uint32_t                tmpKgarReg;
+
+        p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
+        WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_cpp, cppReg);
+
+        tmpKgarReg = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
+        return WriteKgarWait(p_FmPcd, tmpKgarReg);
+    }
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 }
-#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
 
 /****************************************/
 /*  Internal and Inter-Module routines  */
 /****************************************/
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
 t_Error FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes  *p_SchemeBind)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -1263,35 +1289,21 @@ t_Error FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd ,  t_FmPcdKgInterModuleBindP
 t_Error FmPcdKgBindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
-    uint32_t                tmpKgarReg = 0, tmpKgpeCpp = 0;
+    uint32_t                tmpKgpeCpp = 0;
 
-    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
     tmpKgpeCpp = FmPcdKgBuildCppReg(p_FmPcd, clsPlanGrpId);
-    WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_cpp, tmpKgpeCpp);
-
-    tmpKgarReg = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
-    return WriteKgarWait(p_FmPcd, tmpKgarReg);
+    return KgWriteCpp(p_FmPcd, hardwarePortId, tmpKgpeCpp);
 }
 
 void FmPcdKgUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
-    uint32_t                tmpKgarReg = 0;
-
 
     SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
 
-    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
-    WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_cpp, 0);
-
-    tmpKgarReg = 0;
-    tmpKgarReg |= FM_PCD_KG_KGAR_GO | FM_PCD_KG_KGAR_WRITE | FM_PCD_KG_KGAR_SEL_PORT_ENTRY | hardwarePortId | FM_PCD_KG_KGAR_SEL_PORT_WSEL_CPP;
-    WriteKgarWait(p_FmPcd, tmpKgarReg);
+    KgWriteCpp(p_FmPcd, hardwarePortId, 0);
 }
-#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
 
 #if 0
 bool KgSchemeIsValid(t_Handle h_FmPcd, uint8_t schemeId)
@@ -1380,8 +1392,8 @@ t_Error KgInit(t_FmPcd *p_FmPcd)
 #ifndef CONFIG_GUEST_PARTITION
     int                         i;
     t_FmPcdKgPortConfigRegs     *p_FmPcdKgPortRegs;
-    uint8_t                     hardwarePortId;
     uint32_t                    tmpKgarReg;
+    uint8_t                     hardwarePortId;
     uint8_t                     portsTable[] = PCD_PORTS_TABLE;
     uint32_t                    tmpReg;
 #else
@@ -1439,6 +1451,7 @@ t_Error KgInit(t_FmPcd *p_FmPcd)
         tmpKgarReg = FmPcdKgBuildWritePortSchemeBindActionReg(hardwarePortId);
 
         err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+//        err = KgWriteSp(p_FmPcd, hardwarePortId, 0xffffffff, FALSE);
         if(err)
             RETURN_ERROR(MINOR, err, NO_MSG);
 
@@ -1447,6 +1460,7 @@ t_Error KgInit(t_FmPcd *p_FmPcd)
         tmpKgarReg = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
 
         err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+//        err = KgWriteCpp(p_FmPcd, hardwarePortId, 0);
         if(err)
             RETURN_ERROR(MINOR, err, NO_MSG);
     }
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
index 5530abc..8af8a09 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
@@ -44,11 +44,12 @@
 #include "net_ext.h"
 #include "fm_ext.h"
 #include "fm_pcd_ext.h"
-#include "fm_hc.h"
+
+#include "fm_pcd.h"
 #ifdef FM_MASTER_PARTITION
 #include "fm_pcd_ipc.h"
 #endif /* FM_MASTER_PARTITION */
-#include "fm_pcd.h"
+#include "fm_hc.h"
 
 
 #ifndef CONFIG_GUEST_PARTITION
@@ -281,13 +282,6 @@ uint8_t FmPcdGetPartitionId(t_Handle h_FmPcd)
 }
 #endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 
-t_Handle FmPcdGetHcHandle(t_Handle h_FmPcd)
-{
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-
-    return p_FmPcd->h_Hc;
-}
-
 void FmPcdIncNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId)
 {
     ((t_FmPcd*)h_FmPcd)->netEnvs[netEnvId].owners++;
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
index f19531c..3670a6f 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
@@ -45,14 +45,6 @@
 #include "fm_port.h"
 
 
-extern t_Error     FmHcPortSetPCD(t_Handle h_FmHc, t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams);
-extern t_Error     FmHcPortDeletePCD(t_Handle h_FmHc, t_Handle h_FmPort);
-
-extern t_Error     FmHcPortPcdKgModifyClsPlanGrp (t_Handle h_FmHc, t_Handle h_FmPort, bool useClsPlan, t_Handle h_NewClsPlanGrp);
-extern t_Error     FmHcPortPcdKgBindSchemes(t_Handle h_FmHc , t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme);
-extern t_Error     FmHcPortPcdKgUnbindSchemes(t_Handle h_FmHc , t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme);
-
-
 /****************************************/
 /*       static functions               */
 /****************************************/
@@ -1205,6 +1197,37 @@ static t_Error  AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrP
 
     return E_OK;
 }
+
+static uint32_t GetPortSchemeBindParams(t_Handle h_FmPort, t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t                    walking1Mask = 0x80000000, tmp;
+    uint8_t                     idx = 0;
+
+    p_SchemeBind->netEnvId = p_FmPort->netEnvId;
+    p_SchemeBind->hardwarePortId = p_FmPort->hardwarePortId;
+    p_SchemeBind->useClsPlan = p_FmPort->useClsPlan;
+    p_SchemeBind->numOfSchemes = 0;
+    tmp = p_FmPort->schemesPerPortVector;
+    if(tmp)
+    {
+        while (tmp)
+        {
+            if(tmp & walking1Mask)
+            {
+                p_SchemeBind->schemesIds[p_SchemeBind->numOfSchemes] = FmPcdKgGetSchemeSwId(p_FmPort->h_FmPcd, idx);
+                p_SchemeBind->numOfSchemes++;
+                tmp &= ~walking1Mask;
+            }
+            walking1Mask >>= 1;
+            idx++;
+        }
+    }
+
+    return tmp;
+}
+
+
 /********************************************/
 /*  Inter-module API                        */
 /********************************************/
@@ -1321,7 +1344,6 @@ t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
         for(i = 0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
         {
             physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(p_PcdParams->p_KgParams->h_Schemes[i])-1);
-
             /* build vector */
             p_FmPort->schemesPerPortVector |= 1 << (31 - physicalSchemeId);
         }
@@ -1652,36 +1674,6 @@ t_Error          FmPortPcdKgSwBindClsPlanGrp (t_Handle h_FmPort, bool useClsPlan
     return E_OK;
 }
 
-void FmPortGetPortSchemeBindParams(t_Handle h_FmPort, t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind, bool clear)
-{
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
-    uint32_t                    walking1Mask = 0x80000000, tmp;
-    uint8_t                     idx = 0;
-
-    p_SchemeBind->netEnvId = p_FmPort->netEnvId;
-    p_SchemeBind->hardwarePortId = p_FmPort->hardwarePortId;
-    p_SchemeBind->useClsPlan = p_FmPort->useClsPlan;
-    p_SchemeBind->numOfSchemes = 0;
-    tmp = p_FmPort->schemesPerPortVector;
-    if(tmp)
-    {
-        while (tmp)
-        {
-            if(tmp & walking1Mask)
-            {
-                p_SchemeBind->schemesIds[p_SchemeBind->numOfSchemes] = FmPcdKgGetSchemeSwId(p_FmPort->h_FmPcd, idx);
-                p_SchemeBind->numOfSchemes++;
-                tmp &= ~walking1Mask;
-            }
-            walking1Mask >>= 1;
-            idx++;
-        }
-    }
-
-    if (clear)
-        p_FmPort->schemesPerPortVector = tmp;
-}
-
 uint8_t FmPortGetNetEnvId(t_Handle h_FmPort)
 {
     return ((t_FmPort*)h_FmPort)->netEnvId;
@@ -3374,11 +3366,9 @@ t_Error FM_PORT_DetachPCD(t_Handle h_FmPort)
 t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
 {
     t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error                                 err = E_OK;
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
     t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+    t_Error                                 err = E_OK;
     uint8_t                                 i;
-#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
 
     if (p_FmPort->imEn)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
@@ -3388,17 +3378,6 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
     p_FmPort->h_FmPcd = FmGetPcdHandle(p_FmPort->h_Fm);
     ASSERT_COND(p_FmPort->h_FmPcd);
 
-    if (FmPcdGetHcHandle(p_FmPort->h_FmPcd))
-    {
-        err = FmHcPortSetPCD(FmPcdGetHcHandle(p_FmPort->h_FmPcd), p_FmPort, p_PcdParams);
-        RELEASE_LOCK(p_FmPort->lock);
-        return err;
-    }
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-    else
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
-
-#else
     err = FmPortSetPcd( h_FmPort, p_PcdParams);
     if(err)
     {
@@ -3414,6 +3393,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
         schemeBind.useClsPlan = p_PcdParams->p_KgParams->useClsPlan;
         for(i = 0;i<schemeBind.numOfSchemes;i++)
             schemeBind.schemesIds[i] = (uint8_t)(CAST_POINTER_TO_UINT32(p_PcdParams->p_KgParams->h_Schemes[i])-1);
+
         err = FmPcdKgBindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
         if(err)
         {
@@ -3432,8 +3412,10 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
         }
     }
 
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
     if(( p_FmPort->pcdEngines & FM_PCD_PRS) && (p_PcdParams->p_PrsParams->includeInPrsStatistics))
         FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, TRUE);
+#endif  /* ! CONFIG_MULTI_PARTITION_SUPPORT */
 
     FmPcdIncNetEnvOwners(p_FmPort->h_FmPcd, p_FmPort->netEnvId);
 
@@ -3442,28 +3424,18 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
     RELEASE_LOCK(p_FmPort->lock);
 
     return err;
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 }
 
 t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
 {
     t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
-    t_Error                                 err = E_OK;
     t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
-#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
-
-    if (FmPcdGetHcHandle(p_FmPort->h_FmPcd))
-        return FmHcPortDeletePCD(FmPcdGetHcHandle(p_FmPort->h_FmPcd), p_FmPort);
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-    else
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+    t_Error                                 err = E_OK;
 
-#else
     if(p_FmPort->pcdEngines & FM_PCD_KG)
     {
         /* unbind all schemes */
-        FmPortGetPortSchemeBindParams(p_FmPort, &schemeBind, TRUE);
+        p_FmPort->schemesPerPortVector = GetPortSchemeBindParams(p_FmPort, &schemeBind);
 
         err = FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
         if(err)
@@ -3472,8 +3444,10 @@ t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
         FmPcdKgUnbindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId);
     }
 
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
     /* we do it anyway, instead of checking if included */
     FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, FALSE);
+#endif  /* ! CONFIG_MULTI_PARTITION_SUPPORT */
 
     err = FmPortDeletePcd( h_FmPort);
     if(err)
@@ -3482,10 +3456,9 @@ t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
     FmPcdDecNetEnvOwners(p_FmPort->h_FmPcd, p_FmPort->netEnvId);
 
     return E_OK;
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 }
 
-t_Error          FM_PORT_PcdKgModifyClsPlanGrp (t_Handle h_FmPort, bool useClsPlan, t_Handle h_NewClsPlanGrp)
+t_Error FM_PORT_PcdKgModifyClsPlanGrp (t_Handle h_FmPort, bool useClsPlan, t_Handle h_NewClsPlanGrp)
 {
     t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
     t_Error             err;
@@ -3520,43 +3493,23 @@ t_Error          FM_PORT_PcdKgModifyClsPlanGrp (t_Handle h_FmPort, bool useClsPl
     if((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
 
-    if (FmPcdGetHcHandle(p_FmPort->h_FmPcd))
-    {
-        err = FmHcPortPcdKgModifyClsPlanGrp(FmPcdGetHcHandle(p_FmPort->h_FmPcd), p_FmPort, useClsPlan, h_NewClsPlanGrp);
-        if(err)
-        {
-            RELEASE_LOCK(p_FmPort->lock);
-            return err;
-        }
-    }
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-    else
+    /* deal with SW */
+    FmPortPcdKgSwUnbindClsPlanGrp(h_FmPort);
+
+    err = FmPortPcdKgSwBindClsPlanGrp(h_FmPort, useClsPlan, (uint8_t)(CAST_POINTER_TO_UINT32(h_NewClsPlanGrp)-1));
+    if(err)
     {
         RELEASE_LOCK(p_FmPort->lock);
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+        RETURN_ERROR(MINOR, err, NO_MSG);
     }
-#else
-    else
-    {
-        /* deal with SW */
-        FmPortPcdKgSwUnbindClsPlanGrp(h_FmPort);
 
-        err = FmPortPcdKgSwBindClsPlanGrp(h_FmPort, useClsPlan, (uint8_t)(CAST_POINTER_TO_UINT32(h_NewClsPlanGrp)-1));
-        if(err)
-        {
-            RELEASE_LOCK(p_FmPort->lock);
-            RETURN_ERROR(MINOR, err, NO_MSG);
-        }
-
-        /* deal with HW */
-        err = FmPcdKgBindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, p_FmPort->clsPlanGrpId);
-        if(err)
-        {
-            RELEASE_LOCK(p_FmPort->lock);
-            RETURN_ERROR(MINOR, err, NO_MSG);
-        }
+    /* deal with HW */
+    err = FmPcdKgBindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, p_FmPort->clsPlanGrpId);
+    if(err)
+    {
+        RELEASE_LOCK(p_FmPort->lock);
+        RETURN_ERROR(MINOR, err, NO_MSG);
     }
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 
     /************************************/
     /* Parser classification group plan parameters           */
@@ -3657,89 +3610,68 @@ t_Error          FM_PORT_PcdKgModifyClsPlanGrp (t_Handle h_FmPort, bool useClsPl
     return E_OK;
 }
 
-t_Error       FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme)
+t_Error  FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error                     err;
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
     t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+    t_Error                                 err;
+    uint32_t                                tmpScmVec=0;
     int                                     i;
-#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG , E_INVALID_STATE);
 
-    TRY_LOCK_RET_ERR(p_FmPort->lock);
-
-    if (FmPcdGetHcHandle(p_FmPort->h_FmPcd))
-    {
-        err = FmHcPortPcdKgBindSchemes(FmPcdGetHcHandle(p_FmPort->h_FmPcd), p_FmPort, p_PortScheme);
-        RELEASE_LOCK(p_FmPort->lock);
-        return err;
-    }
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-    else
-    {
-        RELEASE_LOCK(p_FmPort->lock);
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
-    }
-
-#else
     schemeBind.netEnvId = p_FmPort->netEnvId;
     schemeBind.hardwarePortId = p_FmPort->hardwarePortId;
     schemeBind.numOfSchemes = p_PortScheme->numOfSchemes;
     schemeBind.useClsPlan = p_FmPort->useClsPlan;
     for (i=0; i<schemeBind.numOfSchemes; i++)
+    {
         schemeBind.schemesIds[i] = (uint8_t)(CAST_POINTER_TO_UINT32(p_PortScheme->h_Schemes[i])-1);
+        /* build vector */
+        tmpScmVec |= 1 << (31 - schemeBind.schemesIds[i]);
+    }
 
-    err = FmPcdKgBindPortToSchemes(h_FmPort, &schemeBind);
+    TRY_LOCK_RET_ERR(p_FmPort->lock);
+    err = FmPcdKgBindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
+    p_FmPort->schemesPerPortVector |= tmpScmVec;
     RELEASE_LOCK(p_FmPort->lock);
+
     return err;
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 }
 
-t_Error       FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme)
+t_Error FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme)
 {
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error                     err;
-
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
     t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+    t_Error                                 err;
+    uint32_t                                tmpScmVec=0;
     int                                     i;
-#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG , E_INVALID_STATE);
 
-    if (FmPcdGetHcHandle(p_FmPort->h_FmPcd))
-    {
-        err = FmHcPortPcdKgUnbindSchemes(FmPcdGetHcHandle(p_FmPort->h_FmPcd), p_FmPort, p_PortScheme);
-        RELEASE_LOCK(p_FmPort->lock);
-        return err;
-    }
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-    else
-    {
-        RELEASE_LOCK(p_FmPort->lock);
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
-    }
-
-#else
     schemeBind.netEnvId = p_FmPort->netEnvId;
     schemeBind.hardwarePortId = p_FmPort->hardwarePortId;
     schemeBind.numOfSchemes = p_PortScheme->numOfSchemes;
     for (i=0; i<schemeBind.numOfSchemes; i++)
+    {
         schemeBind.schemesIds[i] = (uint8_t)(CAST_POINTER_TO_UINT32(p_PortScheme->h_Schemes[i])-1);
+        /* build vector */
+        tmpScmVec |= 1 << (31 - schemeBind.schemesIds[i]);
+    }
 
-    err = FmPcdKgUnbindPortToSchemes(h_FmPort, &schemeBind);
+    TRY_LOCK_RET_ERR(p_FmPort->lock);
+    err = FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
+    p_FmPort->schemesPerPortVector &= ~tmpScmVec;
     RELEASE_LOCK(p_FmPort->lock);
+
     return err;
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 }
 
-t_Error       FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_FmPcdPrsStart)
+t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_FmPcdPrsStart)
 {
     t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
     volatile uint32_t   *p_BmiPrsStartOffset = NULL;
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
index f9b06eb..6250db1 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
@@ -550,12 +550,12 @@ uint8_t     FmPcdKgGetSchemeSwId(t_Handle h_FmPcd, uint8_t schemeHwId);
 t_Error     FmPcdKgSchemeTryLock(t_Handle h_FmPcd, uint8_t schemeId);
 void        FmPcdKgReleaseSchemeLock(t_Handle h_FmPcd, uint8_t schemeId);
 
-#ifndef CONFIG_MULTI_PARTITION_SUPPORT
 t_Error     FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes  *p_SchemeBind);
 t_Error     FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind);
 t_Error     FmPcdKgBindPortToClsPlanGrp(t_Handle p_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId);
 void        FmPcdKgUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId);
 
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
 void        FmPcdPrsIncludePortInStatistics(t_Handle p_FmPcd, uint8_t hardwarePortId,  bool include);
 #endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
 
@@ -591,14 +591,11 @@ t_Error     FmPcdHandleIpcMsg(t_Handle h_FmPcd, uint32_t msgId, uint8_t msgBody[
 uint8_t     FmPcdGetPartitionId(t_Handle h_FmPcd);
 #endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 
-t_Handle    FmPcdGetHcHandle(t_Handle h_FmPcd);
-
 t_Error     FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams);
 t_Error     FmPortDeletePcd(t_Handle h_FmPort);
 uint8_t     FmPortGetNetEnvId(t_Handle h_FmPort);
 uint8_t     FmPortGetHardwarePortId(t_Handle h_FmPort);
 uint32_t    FmPortGetPcdEngines(t_Handle h_FmPort);
-void        FmPortGetPortSchemeBindParams(t_Handle h_FmPort, t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind, bool clear);
 uint8_t     FmPortGetClsPlanId(t_Handle h_FmPort);
 t_Error     FmPortPcdKgSwBindClsPlanGrp (t_Handle h_FmPort, bool useClsPlan, uint8_t newClsPlanGrpId);
 void        FmPortPcdKgSwUnbindClsPlanGrp (t_Handle h_FmPort);
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
index 67b03ee..6525ef0 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
@@ -72,5 +72,8 @@ t_Error     FmHcPcdPlcrDeleteProfile(t_Handle h_FmHc, t_Handle h_Profile);
 t_Error     FmHcPcdPlcrSetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter, uint32_t value);
 uint32_t    FmHcPcdPlcrGetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter);
 
+t_Error     FmHcKgWriteSp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t spReg, bool add);
+t_Error     FmHcKgWriteCpp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t cppReg);
+
 
 #endif /* __FM_HC_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
index 3115961..a865162 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
@@ -60,8 +60,8 @@
 #include <linux/of_platform.h>
 #include <asm/uaccess.h>
 #include <asm/errno.h>
+#include <asm/qe.h>        /* For struct qe_firmware */
 #include <sysdev/fsl_soc.h>
-#include <asm/qe.h>		/* For struct qe_firmware */
 
 /* NetCommSw Headers --------------- */
 #include "std_ext.h"
@@ -398,13 +398,13 @@ typedef _Packed struct {
 }
 
 #ifndef NO_OF_SUPPORT
-
 /* The default address for the Fman microcode in flash. Having a default
  * allows older systems to continue functioning.  0xEF000000 is the address
  * where the firmware is normally on a P4080DS.
  */
 static phys_addr_t P4080_UCAddr = 0xef000000;
 
+
 /**
  * FmanUcodeAddrParam - process the fman_ucode kernel command-line parameter
  *
@@ -414,14 +414,14 @@ static phys_addr_t P4080_UCAddr = 0xef000000;
  */
 static int FmanUcodeAddrParam(char *str)
 {
-	unsigned long long l;
-	int ret;
+    unsigned long long l;
+    int ret;
 
-	ret = strict_strtoull(str, 0, &l);
-	if (!ret)
-		P4080_UCAddr = (phys_addr_t) l;
+    ret = strict_strtoull(str, 0, &l);
+    if (!ret)
+        P4080_UCAddr = (phys_addr_t) l;
 
-	return ret;
+    return ret;
 }
 __setup("fman_ucode=", FmanUcodeAddrParam);
 
@@ -452,7 +452,8 @@ static struct qe_firmware *FindFmanMicrocode(void)
 
         /* Make sure it really is a QE Firmware blob */
         hdr = &P4080_UCPatch->header;
-        if ((hdr->magic[0] != 'Q') || (hdr->magic[1] != 'E') ||
+        if (!hdr ||
+            (hdr->magic[0] != 'Q') || (hdr->magic[1] != 'E') ||
             (hdr->magic[2] != 'F')) {
             REPORT_ERROR(MAJOR, E_NOT_FOUND, ("data at %llx is not a Fman microcode", (u64) P4080_UCAddr));
             return NULL;
@@ -607,6 +608,10 @@ static t_LnxWrpFmDev * ReadFmDevTreeNode (struct of_device *of_dev)
             (void *) fw + fw->microcode[0].code_offset;
         p_LnxWrpFmDev->fmDevSettings.param.firmware.size =
             sizeof(u32) * fw->microcode[0].count;
+        DBG(INFO, ("Loading fman-controller code version %d.%d.%d",
+                   fw->microcode[0].major,
+                   fw->microcode[0].minor,
+                   fw->microcode[0].revision));
     }
 
     p_LnxWrpFmDev->active = TRUE;
diff --git a/drivers/net/dpa/mac.c b/drivers/net/dpa/mac.c
index af6de21..6986c4d 100644
--- a/drivers/net/dpa/mac.c
+++ b/drivers/net/dpa/mac.c
@@ -173,19 +173,7 @@ static int __devinit __cold mac_probe(struct of_device *_of_dev, const struct of
 		goto _return_of_node_put;
 	}
 
-#ifdef CONFIG_GUEST_PARTITION
-	uint32_prop = of_get_property(dev_node, "cell-index", &lenp);
-	if (unlikely(uint32_prop == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): of_get_property(%s, cell-index) failed\n",
-			    __file__, __LINE__, __func__, dev_node->full_name);
-		_errno = -EINVAL;
-		goto _return;
-	}
-	BUG_ON(lenp != sizeof(uint32_t));
-    mac_dev->fm = (void *)*uint32_prop;
-#else
     mac_dev->fm = (void *)fm_get_handle(mac_dev->fm_dev);
-#endif /* CONFIG_GUEST_PARTITION */
 	of_node_put(dev_node);
 
 	/* Get the address of the memory mapped registers */
-- 
1.6.5.2

