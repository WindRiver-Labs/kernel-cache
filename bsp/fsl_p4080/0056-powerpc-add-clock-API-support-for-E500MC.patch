From 0afd2d64dc764c8d40b1ad18b15c1a27630c51af Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Wed, 14 Oct 2009 14:33:43 +0800
Subject: [PATCH] powerpc: add clock API support for E500MC

We can't get PLL value as other e500 core because the e500mc
doesn't have a HID1 register. The latest u-boot has already
set the system frequency in DTB. The kernel has also had a
function to get it from DTB. So we use this method to get the
mpic timer frequency.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/sysdev/mpic.c |   28 +++++++++++++++++++++++++---
 1 files changed, 25 insertions(+), 3 deletions(-)

diff --git a/arch/powerpc/sysdev/mpic.c b/arch/powerpc/sysdev/mpic.c
index c615d51..22b826c 100644
--- a/arch/powerpc/sysdev/mpic.c
+++ b/arch/powerpc/sysdev/mpic.c
@@ -35,6 +35,9 @@
 #include <asm/machdep.h>
 #include <asm/mpic.h>
 #include <asm/smp.h>
+#ifdef CONFIG_PPC_E500MC
+#include <sysdev/fsl_soc.h>
+#endif
 
 #include "mpic.h"
 
@@ -276,7 +279,12 @@ static inline void _mpic_irq_write(struct mpic *mpic, unsigned int src_no,
 #include <linux/hwtimer.h>
 #include <linux/delay.h>
 
+#ifdef CONFIG_PPC_E500MC
+#define TIMER_DEFAULT_DIVISOR 16
+#else
 #define TIMER_DEFAULT_DIVISOR 8
+#endif
+
 #ifdef CONFIG_MPC85xx
 static int pll_divisor[4]={1,2,1,2};
 static int pll_dividend[4]={2,5,3,7};
@@ -307,6 +315,13 @@ int mpic_hwtimer_get_freq(void)
 static int mpic_hwtimer_set_freq(int freq)
 {
 	struct mpic *mpic = mpic_primary;
+	unsigned long sys_freq;
+
+#ifdef CONFIG_PPC_E500MC
+	sys_freq = fsl_get_sys_freq();
+#else
+	sys_freq = ppc_proc_freq * PROC_PLL_RATIO;
+#endif
 
 	if ((freq < mpic_hwtimer_data.min_freq) || (freq > mpic_hwtimer_data.max_freq))
 		return -EINVAL;
@@ -314,7 +329,7 @@ static int mpic_hwtimer_set_freq(int freq)
 	mpic_write(mpic->tmregs,
 		   mpic_hwtimer_index * MPIC_INFO(TIMER_STRIDE) +
 		   MPIC_INFO(TIMER_BASE_CNT),
-		   ppc_proc_freq * PROC_PLL_RATIO / TIMER_DEFAULT_DIVISOR / mpic_hwtimer_freq);
+		   sys_freq / TIMER_DEFAULT_DIVISOR / mpic_hwtimer_freq);
 	return 0;
 }
 
@@ -325,6 +340,13 @@ static int mpic_hwtimer_start(void)
 	u32 tmp = 0;
 	int ret = 0;
 	struct mpic *mpic = mpic_primary;
+	unsigned long sys_freq;
+
+#ifdef CONFIG_PPC_E500MC
+	sys_freq = fsl_get_sys_freq();
+#else
+	sys_freq = ppc_proc_freq * PROC_PLL_RATIO;
+#endif
 
 	mpic_hwtimer_irq = irq_create_mapping(mpic->irqhost,
 						mpic->timer_vecs[mpic_hwtimer_index]);
@@ -348,7 +370,7 @@ static int mpic_hwtimer_start(void)
 	mpic_write(mpic->tmregs,
 		   mpic_hwtimer_index * MPIC_INFO(TIMER_STRIDE) +
 		   MPIC_INFO(TIMER_BASE_CNT),
-		   ppc_proc_freq * PROC_PLL_RATIO / TIMER_DEFAULT_DIVISOR / mpic_hwtimer_freq);
+		   sys_freq / TIMER_DEFAULT_DIVISOR / mpic_hwtimer_freq);
 	tmp = mpic_read(mpic->tmregs, mpic_hwtimer_index * MPIC_INFO(TIMER_STRIDE) +
 		   	MPIC_INFO(TIMER_VECTOR_PRI));
 
@@ -1588,7 +1610,7 @@ void __init mpic_init(struct mpic *mpic)
 
 
 #ifdef CONFIG_HWTIMER_HOOKS
-#ifdef CONFIG_MPC85xx
+#if defined(CONFIG_MPC85xx) &&  !defined(CONFIG_PPC_E500MC)
 	uint phid1;
 	phid1=mfspr(SPRN_HID1);
 	pll_index=((phid1 >> 24) & 0x3f) - 4;
-- 
1.5.5.1

