From be2c27f9428bdb348be44bf38c0531a916a19972 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Tue, 25 May 2010 09:24:46 +0800
Subject: [PATCH 2/5] WRHV/PPC: Get vb mdio bus

For P4080 The hypervisor needs to know which FMAN and which DTSEC you are
trying to access via the MDIO as the access functions need that information.
This information should be encoded into the "bus" element of the MDIO_MSG
struct.

fman 4 bits  0-1
dtsec 4 bits 0-3

0x000000<fman><dtsec>

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/include/asm/machdep.h          |    2 +
 arch/powerpc/kernel/vbi/wrhv.c              |   12 ++++-
 arch/powerpc/platforms/85xx/wrhv_p4080_ds.c |   77 +++++++++++++++++++++++++++
 3 files changed, 89 insertions(+), 2 deletions(-)

diff --git a/arch/powerpc/include/asm/machdep.h b/arch/powerpc/include/asm/machdep.h
index e2e684b..8a0aa87 100644
--- a/arch/powerpc/include/asm/machdep.h
+++ b/arch/powerpc/include/asm/machdep.h
@@ -12,6 +12,7 @@
 #include <linux/seq_file.h>
 #include <linux/init.h>
 #include <linux/dma-mapping.h>
+#include <linux/phy.h>
 
 #include <asm/setup.h>
 
@@ -279,6 +280,7 @@ struct machdep_calls {
 	int (*set_law_attr)(int index, unsigned int attr);
 	int (*get_law_attr)(int index);
 	unsigned int (*get_direct_irq)(void);
+	uint32_t (*get_mdio_bus)(struct mii_bus *bus, int mii_id);
 #endif
 };
 
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 21638ca..8a2cc95 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -297,9 +297,13 @@ int wrhv_mdio_write(struct mii_bus *bus, int mii_id, int regnum, u16 value)
 	VBI_BSP_MSG		mdio_msg;
 	VBI_BSP_MSG_REPLY	mdio_reply;
 	int			rc = -1;
+	u32			bid = 0;
+
+	if (ppc_md.get_mdio_bus)
+		bid = ppc_md.get_mdio_bus(bus, mii_id);
 
 	mdio_msg.request = VBI_MDIO_WRITE;
-	mdio_msg.arg.mdioWrite.bus = wrhv_mdio_bus;
+	mdio_msg.arg.mdioWrite.bus = bid;
 	mdio_msg.arg.mdioWrite.phyAddr = (uint32_t) mii_id;
 	mdio_msg.arg.mdioWrite.regNum = (uint32_t) regnum;
 	mdio_msg.arg.mdioWrite.page = 0;
@@ -319,9 +323,13 @@ int wrhv_mdio_read(struct mii_bus *bus, int mii_id, int regnum)
 	VBI_BSP_MSG		mdio_msg;
 	VBI_BSP_MSG_REPLY	mdio_reply;
 	int			rc = -1;
+	u32			bid = 0;
+
+	if (ppc_md.get_mdio_bus)
+		bid = ppc_md.get_mdio_bus(bus, mii_id);
 
 	mdio_msg.request = VBI_MDIO_READ;
-	mdio_msg.arg.mdioRead.bus = wrhv_mdio_bus;
+	mdio_msg.arg.mdioRead.bus = bid;
 	mdio_msg.arg.mdioRead.phyAddr = (uint32_t) mii_id;
 	mdio_msg.arg.mdioRead.regNum = (uint32_t) regnum;
 	mdio_msg.arg.mdioRead.page = 0;
diff --git a/arch/powerpc/platforms/85xx/wrhv_p4080_ds.c b/arch/powerpc/platforms/85xx/wrhv_p4080_ds.c
index 800259a..046917c 100644
--- a/arch/powerpc/platforms/85xx/wrhv_p4080_ds.c
+++ b/arch/powerpc/platforms/85xx/wrhv_p4080_ds.c
@@ -79,6 +79,82 @@ int wrhv_p4080_get_law_attr(int index)
 	return attr;
 }
 
+/*
+ * The hypervisor needs to know which FMAN and which DTSEC you
+ * are trying to access via the MDIO as the access functions
+ * need that information.
+ * This information should be encoded into the "bus" element
+ * of the MDIO_MSG struct.
+
+ * fman 4 bits  0-1
+ * dtsec 4 bits 0-3
+
+ * 0x000000<fman><dtsec>
+ */
+static uint32_t p4080_mdio_bus[PHY_MAX_ADDR];
+
+static int __init p4080_mdio_bus_init(void)
+{
+	struct device_node *np, *phy_np;
+	int i, j;
+	uint32_t bus = 0;
+	char *mdio_bus[] = {
+			"/soc@fe000000/fman@400000/ethernet@e0000",
+			"/soc@fe000000/fman@400000/ethernet@e2000",
+			"/soc@fe000000/fman@400000/ethernet@e4000",
+			"/soc@fe000000/fman@400000/ethernet@e6000",
+			"/soc@fe000000/fman@500000/ethernet@e0000",
+			"/soc@fe000000/fman@500000/ethernet@e2000",
+			"/soc@fe000000/fman@500000/ethernet@e4000",
+			"/soc@fe000000/fman@500000/ethernet@e6000",
+	};
+
+	for (i = 0; i < PHY_MAX_ADDR; i++) {
+		for_each_compatible_node(np, NULL, "fsl,p4080-fman-1g-mac") {
+			const u32 *phandle;
+			const u32 *reg;
+
+			phandle = of_get_property(np, "phy-handle", NULL);
+			phy_np = of_find_node_by_phandle(*phandle);
+			reg = of_get_property(phy_np, "reg", NULL);
+			if (reg && (*reg == i))
+				break;
+		}
+		if (!np) {
+			bus = 0;
+			goto get_bus;
+		}
+
+		for (j = 0; j < ARRAY_SIZE(mdio_bus); j++) {
+			if (!(strcmp(np->full_name,  mdio_bus[j]))) {
+				bus = j;
+				/*
+				 * mask fman1
+				*/
+				if (j > 3) {
+					bus -= 4;
+					bus |= 1 << 4;
+				}
+				break;
+			}
+		}
+
+get_bus:
+		p4080_mdio_bus[i] = bus;
+	}
+
+	return 0;
+}
+subsys_initcall(p4080_mdio_bus_init);
+
+uint32_t p4080_get_vb_mdio_bus(struct mii_bus *mii_bus, int addr)
+{
+	if (addr > PHY_MAX_ADDR)
+		return -1;
+
+	return p4080_mdio_bus[addr];
+}
+
 static void __init mpc85xx_ds_setup_arch(void)
 {
 #ifdef CONFIG_PCI
@@ -253,4 +329,5 @@ define_machine(p4080_ds) {
 	.set_law_base		= wrhv_p4080_set_law_base,	
 	.set_law_attr		= wrhv_p4080_set_law_attr,
 	.get_law_attr		= wrhv_p4080_get_law_attr,
+	.get_mdio_bus		= p4080_get_vb_mdio_bus,
 };
-- 
1.6.5.2

