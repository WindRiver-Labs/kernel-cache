From 68d20820b80c89dd78b6012f6b83ff5826742d6b Mon Sep 17 00:00:00 2001
From: Shlomi Gridish <gridish@freescale.com>
Date: Wed, 14 Oct 2009 20:59:13 +0200
Subject: [PATCH 061/148] FMD6

1. Fixing Bugzila BUGs 4143, 3482, 4090, 4074, 4230, 3182, 4052, 3935, 4413, 4450
  2. Added workarounds for FM chip erratas.
  3. Fixed several BUGs found during bring-up
  4. Added support for sw-parser

Signed-off-by: Shlomi Gridish <gridish@freescale.com>
[Applied FSL SDK 2.0.3 patch "0001-FMD6.ppp.patch"]
Integrated-by: Yuri Nedel <Yuri.Nedel@windriver.com>
---
 drivers/net/dpa/NetCommSw/Kconfig                  |    4 +-
 drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c   |   66 ++--
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c   |  424 ++++++++++++++------
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h   |  110 ++++--
 .../NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c   |    2 +-
 .../NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h   |   20 +-
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c  |   62 ++-
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h  |    7 +-
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c    |  168 ++++++++-
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h    |  245 +++++++-----
 .../NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c    |   20 +-
 .../NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h    |   20 +-
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c   |   64 ++--
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c   |   49 +--
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c  |   26 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h  |   21 +-
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c |   35 +-
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c  |   48 ++-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.c    |   26 +-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.h    |    8 +-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c |   28 +-
 drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c      |  387 +++++++++++++-----
 drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h      |  141 ++++---
 .../net/dpa/NetCommSw/Peripherals/FM/fm_guest.c    |  101 +++++-
 drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h  |   14 +
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_common.h   |  118 ++++++-
 drivers/net/dpa/NetCommSw/dflags.h                 |    4 +
 drivers/net/dpa/NetCommSw/etc/memcpy.c             |   12 +-
 drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h |  284 ++++++-------
 .../net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h |  150 +++++--
 .../net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h |   19 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_port_ext.h    |   54 ++--
 .../inc/integrations/P4080/part_integration_ext.h  |  280 ++++++++++++-
 .../net/dpa/NetCommSw/inc/integrations/part_ext.h  |    6 +-
 drivers/net/dpa/NetCommSw/inc/ncsw_ext.h           |   23 +-
 drivers/net/dpa/NetCommSw/inc/net_ext.h            |    7 +-
 .../net/dpa/NetCommSw/integrations/P4080/P4080.c   |  157 --------
 .../net/dpa/NetCommSw/integrations/P4080/P4080.h   |  166 --------
 .../dpa/NetCommSw/integrations/P4080/P4080_mng.c   |  150 -------
 .../NetCommSw/integrations/P4080/module_strings.c  |    1 +
 .../kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h   |    5 +-
 .../2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h      |   29 +-
 .../2.6/inc/ioctl/Peripherals/fm_port_ioctls.h     |    5 +-
 .../2.6/inc/ioctl/Peripherals/fm_test_ioctls.h     |   48 ++-
 .../user/env/linux/kernel/2.6/inc/ioctl/ioctls.h   |   22 +-
 .../user/env/linux/kernel/2.6/inc/procbuff_ext.h   |    2 +-
 .../env/linux/kernel/2.6/inc/system/platform_ext.h |   86 ++++-
 .../user/env/linux/kernel/2.6/inc/system/sys_ext.h |  272 +++++++++++++
 .../kernel/2.6/inc/wrappers/Peripherals/fsl_fman.h |    4 +-
 .../2.6/inc/wrappers/Peripherals/fsl_fman_test.h   |   51 +++-
 .../2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h   |    4 +-
 .../kernel/2.6/modules/integrations/P4080/FM/fmm.c |    2 +-
 .../kernel/2.6/wrappers/Peripherals/FM/fman_test.c |  198 +++++++++-
 .../kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c |  388 +++++++++++++++----
 .../kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h |   10 +-
 .../2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c |   31 ++
 .../2.6/xx/integrations/P4080/xx_integration.c     |   31 ++
 .../NetCommSw/user/env/linux/kernel/2.6/xx/xx.h    |    5 +
 .../user/env/linux/kernel/2.6/xx/xx_linux.c        |   35 +--
 drivers/net/dpa/dpa.c                              |  180 ++++-----
 drivers/net/dpa/dpa.h                              |    5 +-
 drivers/net/dpa/mac-api.c                          |   62 ++-
 62 files changed, 3326 insertions(+), 1676 deletions(-)
 delete mode 100644 drivers/net/dpa/NetCommSw/integrations/P4080/P4080.c
 delete mode 100644 drivers/net/dpa/NetCommSw/integrations/P4080/P4080.h
 delete mode 100644 drivers/net/dpa/NetCommSw/integrations/P4080/P4080_mng.c

diff --git a/drivers/net/dpa/NetCommSw/Kconfig b/drivers/net/dpa/NetCommSw/Kconfig
index 70dde1a..0abebdb 100644
--- a/drivers/net/dpa/NetCommSw/Kconfig
+++ b/drivers/net/dpa/NetCommSw/Kconfig
@@ -10,10 +10,10 @@ menuconfig FSL_FMAN
 if FSL_FMAN
 
 config FSL_FMAN_TEST
-	bool "Fman test module"
+	bool "FMan test module"
 	default n
 	---help---
-	  This option compiles test code for Fman.
+	  This option compiles test code for FMan.
 
 endif # FSL_FMAN
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c
index c67d2b0..f47b808 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c
@@ -47,18 +47,6 @@
 #define SIZE_OF_HC_FRAME_PROFILE_CNT        (sizeof(t_HcFrame)-sizeof(t_FmPcdPlcrInterModuleProfileRegs)+sizeof(uint32_t))
 #define SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC 16
 
-/*
-#define BUILD_FD(len)                                                           \
-do {                                                                            \
-        memset(&fmFd, 0, sizeof(t_FmFD));                                       \
-        FM_FD_SET_DD(&fmFd, (uint32_t)0x3);                                     \
-        FM_FD_SET_PID(&fmFd, (uint32_t)0x3f);                                   \
-        FM_FD_SET_BPID(&fmFd, (uint32_t)0xff);                                  \
-        FM_FD_SET_ADDR(&fmFd, &hcFrame);                                        \
-        FM_FD_SET_OFFSET(&fmFd, 0);                                             \
-        FM_FD_SET_LENGTH(&fmFd, len);                                           \
-} while (0)
-*/
 #define BUILD_FD(len)                                                           \
 do {                                                                            \
         memset(&fmFd, 0, sizeof(t_FmFD));                                       \
@@ -73,6 +61,8 @@ do {
     p_FmHc->seqNum = (uint32_t)((p_FmHc->seqNum+1)%32);                         \
     ASSERT_COND(!p_FmHc->wait[savedSeqNum]);                                    \
     p_FmHc->wait[savedSeqNum] = TRUE;                                           \
+    DBG(TRACE, ("Send Hc 0x%x , SeqNum %d, fd addr 0x%x, fd offset 0x%x",       \
+            p_FmHc,savedSeqNum,FM_FD_GET_ADDR(frm),FM_FD_GET_OFFSET(frm)));     \
     err = p_FmHc->f_QmEnqueueCB(p_FmHc->h_QmArg, p_FmHc->enqFqid, (void *)frm); \
     if(err)                                                                     \
         RETURN_ERROR(MINOR, err, ("HC enqueue failed"));                        \
@@ -85,6 +75,8 @@ do {
     p_FmHc->seqNum = (uint32_t)((p_FmHc->seqNum+1)%32);                         \
     ASSERT_COND(!p_FmHc->wait[savedSeqNum]);                                    \
     p_FmHc->wait[savedSeqNum] = TRUE;                                           \
+    DBG(TRACE, ("Send Hc Null 0x%x , SeqNum %d, fd addr 0x%x, fd offset 0x%x",  \
+            p_FmHc,savedSeqNum,FM_FD_GET_ADDR(frm),FM_FD_GET_OFFSET(frm)));     \
     err = p_FmHc->f_QmEnqueueCB(p_FmHc->h_QmArg, p_FmHc->enqFqid, (void *)frm); \
     if(err)  {                                                                  \
         REPORT_ERROR(MINOR, err, ("HC enqueue failed")); return NULL;           \
@@ -176,8 +168,8 @@ typedef struct t_FmHc {
     t_Handle                h_FmPcd;
     t_Handle                h_HcPortDev;
     uint32_t                enqFqid;            /**< Host-Command enqueue Queue Id. */
-    t_FmPcdQmEnqueueCB      *f_QmEnqueueCB;     /**< TBD */
-    t_Handle                h_QmArg;            /**< TBD */
+    t_FmPcdQmEnqueueCB      *f_QmEnqueueCB;     /**< A callback for enquing frames to the QM */
+    t_Handle                h_QmArg;            /**< A handle to the QM module */
 
     //volatile bool           lock;
     uint32_t                seqNum;
@@ -190,7 +182,7 @@ static t_Error KgHcSetClsPlan(t_FmHc *p_FmHc, t_FmPcdKgInterModuleClsPlanSet *p_
     t_HcFrame               hcFrame;
     t_FmFD                  fmFd;
     int                     i;
-    t_Error                 err;
+    t_Error                 err = E_OK;
 
     ASSERT_COND(p_FmHc);
 
@@ -215,7 +207,7 @@ static t_Error CcHcDoDynamicChange(t_FmHc *p_FmHc, bool keyModify, t_Handle p_Ol
 {
     t_HcFrame               hcFrame;
     t_FmFD                  fmFd;
-    t_Error                 err;
+    t_Error                 err = E_OK;
 
     ASSERT_COND(p_FmHc);
 
@@ -242,7 +234,7 @@ static t_Error CcHcDoDynamicChange(t_FmHc *p_FmHc, bool keyModify, t_Handle p_Ol
 
 static t_Error CcHcDynamicChangeForNextEngine(t_FmHc *p_FmHc, t_Handle h_OldPointer, t_Handle h_NewPointer)
 {
-    t_Error err;
+    t_Error err = E_OK;
 
     ASSERT_COND(p_FmHc);
 
@@ -260,7 +252,7 @@ static t_Error HcDynamicChangeForKey(t_FmHc *p_FmHc,t_Handle  *h_OldPointersLst,
 
     t_List      *p_Pos;
     uint16_t    i = 0;
-    t_Error     err;
+    t_Error     err = E_OK;
     t_List      *p_OldPointersLst = (t_List *)h_OldPointersLst;
 
     LIST_FOR_EACH(p_Pos, p_OldPointersLst)
@@ -288,7 +280,7 @@ t_Handle    FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
     t_FmHc          *p_FmHc;
 #ifndef CONFIG_GUEST_PARTITION
     t_FmPortParams  fmPortParam;
-    t_Error         err;
+    t_Error         err = E_OK;
 #endif /* !CONFIG_GUEST_PARTITION */
 
     p_FmHc = XX_Malloc(sizeof(t_FmHc));
@@ -357,6 +349,10 @@ void FmHcTxConf(t_Handle h_FmHc, t_FmFD *p_Fd)
 
     p_HcFrame  = CAST_UINT64_TO_POINTER_TYPE(t_HcFrame,
                                              (CAST_POINTER_TO_UINT64(FM_FD_GET_ADDR(p_Fd)) + FM_FD_GET_OFFSET(p_Fd)));
+
+    DBG(TRACE, ("Hc Conf 0x%x , SeqNum %d, fd addr 0x%x, fd offset 0x%x",
+            p_FmHc,p_HcFrame->commandSequence,FM_FD_GET_ADDR(p_Fd),FM_FD_GET_OFFSET(p_Fd)));
+
     ASSERT_COND(p_FmHc->wait[p_HcFrame->commandSequence]);
 
     p_FmHc->wait[p_HcFrame->commandSequence] = FALSE;
@@ -365,7 +361,7 @@ void FmHcTxConf(t_Handle h_FmHc, t_FmFD *p_Fd)
 t_Handle FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme)
 {
     t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
-    t_Error                             err;
+    t_Error                             err = E_OK;
     t_FmPcdKgInterModuleSchemeRegs      schemeRegs;
     t_HcFrame                           hcFrame;
     t_FmFD                              fmFd;
@@ -463,7 +459,7 @@ t_Handle FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme)
 t_Error FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme)
 {
     t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
-    t_Error                             err;
+    t_Error                             err = E_OK;
     t_HcFrame                           hcFrame;
     t_FmFD                              fmFd;
     uint8_t                             relativeSchemeId;
@@ -508,7 +504,7 @@ t_Error FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme)
 uint32_t  FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme)
 {
     t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
-    t_Error                             err;
+    t_Error                             err = E_OK;
     t_HcFrame                           hcFrame;
     t_FmFD                              fmFd;
     uint32_t                            retVal;
@@ -559,7 +555,7 @@ t_Error  FmHcPcdKgSetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme, uint32_t
 {
 
     t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
-    t_Error                             err;
+    t_Error                             err = E_OK;
     t_HcFrame                           hcFrame;
     t_FmFD                              fmFd;
     uint8_t                             relativeSchemeId, physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(h_Scheme)-1);
@@ -619,7 +615,7 @@ t_Handle FmHcPcdKgSetClsPlanGrp(t_Handle h_FmHc, t_FmPcdKgClsPlanGrpParams *p_Gr
     t_FmHc                          *p_FmHc = (t_FmHc*)h_FmHc;
     t_FmPcdKgInterModuleClsPlanSet  clsPlanSet;
     t_Handle                        h_ClsPlanGrp;
-    t_Error                         err;
+    t_Error                         err = E_OK;
 
     h_ClsPlanGrp = FmPcdKgBuildClsPlanGrp(p_FmHc->h_FmPcd, p_Grp, &clsPlanSet);
     if(!h_ClsPlanGrp)
@@ -661,7 +657,7 @@ t_Handle FmHcPcdPlcrSetProfile(t_Handle h_FmHc,t_FmPcdPlcrProfileParams *p_Profi
 {
     t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
     t_FmPcdPlcrInterModuleProfileRegs              profileRegs;
-    t_Error                             err;
+    t_Error                             err = E_OK;
     uint16_t                            profileIndx;
     t_HcFrame                           hcFrame;
     t_FmFD                              fmFd;
@@ -746,7 +742,7 @@ t_Error FmHcPcdPlcrDeleteProfile(t_Handle h_FmHc, t_Handle h_Profile)
 {
     t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
     uint16_t                            absoluteProfileId = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
-    t_Error                             err;
+    t_Error                             err = E_OK;
     t_HcFrame                           hcFrame;
     t_FmFD                              fmFd;
 
@@ -776,7 +772,7 @@ t_Error  FmHcPcdPlcrSetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
 
     t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
     uint16_t                            absoluteProfileId = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
-    t_Error                             err;
+    t_Error                             err = E_OK;
     t_HcFrame                           hcFrame;
     t_FmFD                              fmFd;
 
@@ -821,7 +817,7 @@ uint32_t FmHcPcdPlcrGetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
 {
     t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
     uint16_t                            absoluteProfileId = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
-    t_Error                             err;
+    t_Error                             err = E_OK;
     t_HcFrame                           hcFrame;
     t_FmFD                              fmFd;
     uint32_t                            retVal;
@@ -968,8 +964,8 @@ t_Error FmHcPcdCcRemoveKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex)
     t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
     t_Handle    h_NewPointer;
     t_List      h_OldPointersLst;
-    t_Error     err;
-    t_List      h_List      ;
+    t_Error     err = E_OK;
+    t_List      h_List;
 
     INIT_LIST(&h_List);
 
@@ -1005,7 +1001,7 @@ t_Error FmHcPcdCcAddKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, ui
     t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
     t_Handle    h_NewPointer;
     t_List      h_OldPointersLst;
-    t_Error     err;
+    t_Error     err = E_OK;
     t_List      h_List;
 
     UNUSED(keySize);
@@ -1045,7 +1041,7 @@ t_Error FmHcPcdCcModifyKeyAndNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint
     t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
     t_List      h_OldPointersLst;
     t_Handle    h_NewPointer;
-    t_Error     err;
+    t_Error     err = E_OK;
     t_List      h_List;
 
     UNUSED(keySize);
@@ -1084,7 +1080,7 @@ t_Error FmHcPcdCcModifyKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex,
     t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
     t_List      h_OldPointersLst;
     t_Handle    h_NewPointer;
-    t_Error     err;
+    t_Error     err = E_OK;
     t_List      h_List;
     UNUSED(keySize);
 
@@ -1121,7 +1117,7 @@ t_Error FmHcKgWriteSp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t spReg, b
     t_FmHc                  *p_FmHc = (t_FmHc*)h_FmHc;
     t_HcFrame               hcFrame;
     t_FmFD                  fmFd;
-    t_Error                 err;
+    t_Error                 err = E_OK;
 
     ASSERT_COND(p_FmHc);
 
@@ -1157,7 +1153,7 @@ t_Error FmHcKgWriteCpp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t cppReg)
     t_FmHc                  *p_FmHc = (t_FmHc*)h_FmHc;
     t_HcFrame               hcFrame;
     t_FmFD                  fmFd;
-    t_Error                 err;
+    t_Error                 err = E_OK;
 
     ASSERT_COND(p_FmHc);
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
index fa9b320..7ffb3a1 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
@@ -43,6 +43,7 @@
 #include "endian_ext.h"
 #include "crc_mac_addr_ext.h"
 #include "debug_ext.h"
+#include "fm_common.h"
 
 #include "dtsec.h"
 
@@ -110,57 +111,160 @@ static void SetDefaultParam(t_Dtsec *p_Dtsec, t_DtsecDriverParam *p_DtsecDriverP
     p_DtsecDriverParam->pauseExtended       = DEFAULT_pauseExtended;
     p_DtsecDriverParam->pauseTime           = DEFAULT_pauseTime;
 
-    p_DtsecDriverParam->halfDuplex          = DEFAULT_halfDuplex;
+    p_DtsecDriverParam->halfDuplex              = DEFAULT_halfDuplex;
     p_DtsecDriverParam->halfDulexFlowControlEn  = DEFAULT_halfDulexFlowControlEn;
-    p_DtsecDriverParam->txTimeStampEn       = DEFAULT_txTimeStampEn;
-    p_DtsecDriverParam->rxTimeStampEn       = DEFAULT_rxTimeStampEn;
+    p_DtsecDriverParam->txTimeStampEn           = DEFAULT_txTimeStampEn;
+    p_DtsecDriverParam->rxTimeStampEn           = DEFAULT_rxTimeStampEn;
 
     p_DtsecDriverParam->packetAlignmentPadding = DEFAULT_packetAlignment;
-    p_DtsecDriverParam->controlFrameAccept   = DEFAULT_controlFrameAccept;
-    p_DtsecDriverParam->groupHashExtend      = DEFAULT_groupHashExtend;
-    p_DtsecDriverParam->broadcReject         = DEFAULT_broadcReject;
-    p_DtsecDriverParam->rxShortFrame         = DEFAULT_rxShortFrame;
-    p_DtsecDriverParam->exactMatch           = DEFAULT_exactMatch;
-    p_DtsecDriverParam->debugMode            = DEFAULT_debugMode;
-
-    p_DtsecDriverParam->loopback             = DEFAULT_loopback;
-    p_DtsecDriverParam->tbiPhyAddr           = DEFAULT_tbiPhyAddr;
-    p_DtsecDriverParam->actOnRxPauseFrame    = DEFAULT_actOnRxPauseFrame;
-    p_DtsecDriverParam->actOnTxPauseFrame    = DEFAULT_actOnTxPauseFrame;
-
-    p_DtsecDriverParam->preambleLength       = DEFAULT_PreAmLength;
-    p_DtsecDriverParam->preambleRxEn         = DEFAULT_PreAmRxEn;
-    p_DtsecDriverParam->preambleTxEn         = DEFAULT_PreAmTxEn;
-    p_DtsecDriverParam->hugeFramesEnable     = DEFAULT_hugeFrames;
-    p_DtsecDriverParam->lengthCheckEnable    = DEFAULT_lengthCheckEnable;
-    p_DtsecDriverParam->padAndCrcEnable      = DEFAULT_padAndCrcEnable;
-    p_DtsecDriverParam->crcEnable            = DEFAULT_crcEnable;
-
-    p_DtsecDriverParam->nonBackToBackIpg1    = DEFAULT_nonBackToBackIpg1;
-    p_DtsecDriverParam->nonBackToBackIpg2    = DEFAULT_nonBackToBackIpg2;
-    p_DtsecDriverParam->minIfgEnforcement    = DEFAULT_minIfgEnforcement;
-    p_DtsecDriverParam->backToBackIpg        = DEFAULT_backToBackIpg;
+    p_DtsecDriverParam->controlFrameAccept     = DEFAULT_controlFrameAccept;
+    p_DtsecDriverParam->groupHashExtend        = DEFAULT_groupHashExtend;
+    p_DtsecDriverParam->broadcReject           = DEFAULT_broadcReject;
+    p_DtsecDriverParam->rxShortFrame           = DEFAULT_rxShortFrame;
+    p_DtsecDriverParam->exactMatch             = DEFAULT_exactMatch;
+    p_DtsecDriverParam->debugMode              = DEFAULT_debugMode;
+
+    p_DtsecDriverParam->loopback               = DEFAULT_loopback;
+    p_DtsecDriverParam->tbiPhyAddr             = DEFAULT_tbiPhyAddr;
+    p_DtsecDriverParam->actOnRxPauseFrame      = DEFAULT_actOnRxPauseFrame;
+    p_DtsecDriverParam->actOnTxPauseFrame      = DEFAULT_actOnTxPauseFrame;
+
+    p_DtsecDriverParam->preambleLength         = DEFAULT_PreAmLength;
+    p_DtsecDriverParam->preambleRxEn           = DEFAULT_PreAmRxEn;
+    p_DtsecDriverParam->preambleTxEn           = DEFAULT_PreAmTxEn;
+    p_DtsecDriverParam->hugeFramesEnable       = DEFAULT_hugeFrames;
+    p_DtsecDriverParam->lengthCheckEnable      = DEFAULT_lengthCheckEnable;
+    p_DtsecDriverParam->padAndCrcEnable        = DEFAULT_padAndCrcEnable;
+    p_DtsecDriverParam->crcEnable              = DEFAULT_crcEnable;
+
+    p_DtsecDriverParam->nonBackToBackIpg1      = DEFAULT_nonBackToBackIpg1;
+    p_DtsecDriverParam->nonBackToBackIpg2      = DEFAULT_nonBackToBackIpg2;
+    p_DtsecDriverParam->minIfgEnforcement      = DEFAULT_minIfgEnforcement;
+    p_DtsecDriverParam->backToBackIpg          = DEFAULT_backToBackIpg;
 
     p_DtsecDriverParam->alternateBackoffVal    = DEFAULT_altBackoffVal;
     p_DtsecDriverParam->alternateBackoffEnable = DEFAULT_altBackoffEnable;
-    p_DtsecDriverParam->backPressureNoBackoff = DEFAULT_backPressureNoBackoff;
-    p_DtsecDriverParam->noBackoff             = DEFAULT_noBackoff;
-    p_DtsecDriverParam->excessDefer           = DEFAULT_excessDefer;
-    p_DtsecDriverParam->maxRetransmission     = DEFAULT_maxRetransmission;
-    p_DtsecDriverParam->collisionWindow       = DEFAULT_collisionWindow;
+    p_DtsecDriverParam->backPressureNoBackoff  = DEFAULT_backPressureNoBackoff;
+    p_DtsecDriverParam->noBackoff              = DEFAULT_noBackoff;
+    p_DtsecDriverParam->excessDefer            = DEFAULT_excessDefer;
+    p_DtsecDriverParam->maxRetransmission      = DEFAULT_maxRetransmission;
+    p_DtsecDriverParam->collisionWindow        = DEFAULT_collisionWindow;
 
-    p_DtsecDriverParam->maxFrameLength        = DEFAULT_maxFrameLength;
+    p_DtsecDriverParam->maxFrameLength         = DEFAULT_maxFrameLength;
 
-    p_DtsecDriverParam->cam1                  = DEFAULT_cam;
-    p_DtsecDriverParam->cam2                  = DEFAULT_cam;
+    p_DtsecDriverParam->cam1                   = DEFAULT_cam;
+    p_DtsecDriverParam->cam2                   = DEFAULT_cam;
 
-    p_DtsecDriverParam->fifoTxThr          = DEFAULT_fifoTxThr;
-    p_DtsecDriverParam->fifoTxWatermarkH   = DEFAULT_fifoTxWatermarkH;
+    p_DtsecDriverParam->fifoTxThr              = DEFAULT_fifoTxThr;
+    p_DtsecDriverParam->fifoTxWatermarkH       = DEFAULT_fifoTxWatermarkH;
 
-    p_DtsecDriverParam->fifoRxWatermarkL   = DEFAULT_fifoRxWatermarkL;
+    p_DtsecDriverParam->fifoRxWatermarkL       = DEFAULT_fifoRxWatermarkL;
+}
+
+static void DtsecException(t_Handle h_Dtsec)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    uint32_t            event;
+    t_DtsecMemMap       *p_DtsecMemMap = p_Dtsec->p_MemMap;
+
+    event = GET_UINT32(p_DtsecMemMap->ievent);
+    /* handle only MDIO events */
+    event &= (IMASK_MMRDEN | IMASK_MMWREN);
+    if(event)
+    {
+        event &= GET_UINT32(p_DtsecMemMap->imask);
+
+        WRITE_UINT32(p_DtsecMemMap->ievent, event);
+
+        if(event & IMASK_MMRDEN)
+            p_Dtsec->f_Events(p_Dtsec->h_App, e_FM_MAC_EX_1G_MII_MNG_RD_COMPLET);
+        if(event & IMASK_MMWREN)
+            p_Dtsec->f_Events(p_Dtsec->h_App, e_FM_MAC_EX_1G_MII_MNG_WR_COMPLET);
+    }
+    if (p_Dtsec->structFor1588.enErrExeption)
+    {
+        event = GET_UINT32(p_DtsecMemMap->tmr_pevent);
+        event &= GET_UINT32(p_DtsecMemMap->tmr_pemask);
+        if(event)
+        {
+            WRITE_UINT32(p_DtsecMemMap->tmr_pevent, event);
+
+            if(event & PEMASK_TSRE)
+                p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_1588_TS_RX_ERR);
+        }
+/* TODO - For Moti */
+ /*       if(event & PEMASK_EVENTS)*/
+    }
+
+}
+
+static void DtsecErrException(t_Handle h_Dtsec)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    uint32_t            event;
+    t_DtsecMemMap       *p_DtsecMemMap = p_Dtsec->p_MemMap;
+
+    event = GET_UINT32(p_DtsecMemMap->ievent);
+    /* do not handle MDIO events */
+    event &= ~(IMASK_MMRDEN | IMASK_MMWREN);
+
+    event &= GET_UINT32(p_DtsecMemMap->imask);
+
+    WRITE_UINT32(p_DtsecMemMap->ievent, event);
+
+    if(event & IMASK_BREN)
+        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_BAB_RX);
+    if(event & IMASK_RXCEN)
+        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_RX_CTL);
+    if(event & IMASK_MSROEN)
+        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_MIB_CNT_OVFL);
+    if(event & IMASK_GTSCEN)
+        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET);
+    if(event & IMASK_BTEN)
+        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_BAB_TX);
+    if(event & IMASK_TXCEN)
+        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_TX_CTL);
+    if(event & IMASK_TXEEN)
+        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_TX_ERR);
+    if(event & IMASK_LCEN)
+        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_LATE_COL);
+    if(event & IMASK_CRLEN)
+        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_COL_RET_LMT);
+    if(event & IMASK_XFUNEN)
+        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_TX_FIFO_UNDRN);
+    if(event & IMASK_MAGEN)
+        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_MAG_PCKT);
+    if(event & IMASK_GRSCEN)
+        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET);
+    if(event & IMASK_TDPEEN)
+        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_TX_DATA_ERR);
+    if(event & IMASK_RDPEEN)
+        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_RX_DATA_ERR);
+
+    /*  - masked interrupts */
+    ASSERT_COND(!(event & IMASK_ABRTEN));
+    ASSERT_COND(!(event & IMASK_IFERREN));
+}
+
+/*
+static void Tmr1588Exception(t_Handle h_Dtsec)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    uint32_t            event;
+    t_DtsecMemMap       *p_DtsecMemMap = p_Dtsec->p_MemMap;
+
+    ASSERT_COND(p_Dtsec->support1588);
+
+    event = GET_UINT32(p_DtsecMemMap->tmr_pevent);
+    event &= GET_UINT32(p_DtsecMemMap->tmr_pemask);
+
+    WRITE_UINT32(p_DtsecMemMap->tmr_pevent, event);
+
+    if(event & PEMASK_TSRE)
+        p_Dtsec->f_Exceptions(p_Dtsec->h_App, e_FM_MAC_EX_1G_1588_TS_RX_ERR);
 
-//#warning /*TODO - Handle Interrupt Mask */ /*    p_DtsecDriverParam->imask              = DEFAULT_imask;    */
 }
+*/
 
 /* ........................................................................... */
 
@@ -252,31 +356,31 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     p_Dtsec->debugMode  = p_DtsecDriverParam->debugMode;
     p_DtsecMemMap       = p_Dtsec->p_MemMap;
 
-/*************dtsec_id2******************/
-   tmpReg32 =  GET_UINT32(p_DtsecMemMap->tsec_id2);
+    /*************dtsec_id2******************/
+    tmpReg32 =  GET_UINT32(p_DtsecMemMap->tsec_id2);
 
-   if ((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
-       (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) ||
-       (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000))
-       if(tmpReg32 & ID2_INT_REDUCED_OFF)
-       {
-            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("no support for reduced interface in current DTSEC version"));
-       }
+    if ((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000))
+        if(tmpReg32 & ID2_INT_REDUCED_OFF)
+        {
+             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("no support for reduced interface in current DTSEC version"));
+        }
 
-   if ((p_Dtsec->enetMode == e_ENET_MODE_SGMII_10) ||
-       (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100) ||
-       (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000))
-       if(tmpReg32 & ID2_INT_NORMAL_OFF)
-       {
-            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("no support for normal interface in current DTSEC version"));
-       }
-/*************dtsec_id2******************/
+    if ((p_Dtsec->enetMode == e_ENET_MODE_SGMII_10) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000))
+        if(tmpReg32 & ID2_INT_NORMAL_OFF)
+        {
+             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("no support for normal interface in current DTSEC version"));
+        }
+    /*************dtsec_id2******************/
 
-/***************EDIS************************/
+    /***************EDIS************************/
     WRITE_UINT32(p_DtsecMemMap->edis, p_DtsecDriverParam->errorDisabled);
-/***************EDIS************************/
+    /***************EDIS************************/
 
-/***************ECNTRL************************/
+    /***************ECNTRL************************/
     tmpReg32 = GET_UINT32(p_DtsecMemMap->ecntrl);
     if(tmpReg32 & ECNTRL_CFG_RO)
     {
@@ -336,23 +440,20 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     if(p_DtsecDriverParam->statisticsEnable)
         tmpReg32 |= ECNTRL_STEN;
     WRITE_UINT32(p_DtsecMemMap->ecntrl, tmpReg32);
+    /***************ECNTRL************************/
 
-/***************ECNTRL************************/
-/***************PTV************************/
+    /***************PTV************************/
     /* initialize PTV */
     tmpReg32 = 0;
-
     if (p_DtsecDriverParam->pauseTime)
         tmpReg32 |= (uint32_t)p_DtsecDriverParam->pauseTime;
 
     if (p_DtsecDriverParam->pauseExtended)
         tmpReg32 |= ((uint32_t)p_DtsecDriverParam->pauseExtended) << PTV_PTE_OFST;
-
     WRITE_UINT32(p_DtsecMemMap->ptv, tmpReg32);
+    /***************PTV************************/
 
-/***************PTV************************/
-
-/***************TCTRL************************/
+    /***************TCTRL************************/
     tmpReg32 = 0;
     if(p_DtsecDriverParam->halfDuplex)
     {
@@ -365,8 +466,9 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
             tmpReg32 |= TCTRL_TTSE;
     }
     WRITE_UINT32(p_DtsecMemMap->tctrl, tmpReg32);
-/***************TCTRL************************/
-/***************RCTRL************************/
+    /***************TCTRL************************/
+
+    /***************RCTRL************************/
     tmpReg32 = 0;
     if (p_DtsecDriverParam->packetAlignmentPadding)
         tmpReg32 |= ((uint32_t)(0x0000001f & p_DtsecDriverParam->packetAlignmentPadding)) << 16;
@@ -410,33 +512,43 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
         tmpReg16 = PHY_TBICON_SPEED2;
 
         DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 17, tmpReg16);
-                        
+
         if(!p_DtsecDriverParam->halfDuplex)
             tmpReg16 |= PHY_CR_FULLDUPLEX | 0x8000 | PHY_CR_ANE;
 
         DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 0, tmpReg16);
-        
+
         tmpReg16 = 0x01a0;
         DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 4, tmpReg16);
-                        
+
         tmpReg16 = 0x1340;
-        DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 0, tmpReg16);                
+        DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 0, tmpReg16);
+    }
+    /***************RCTRL************************/
+
+    /***************IMASK************************/
+    WRITE_UINT32(p_DtsecMemMap->imask, p_Dtsec->exceptions);
+    /***************IMASK************************/
+
+    /***************IEVENT************************/
+    WRITE_UINT32(p_DtsecMemMap->ievent, EVENTS_MASK);
+
+    if(p_Dtsec->support1588)
+    {
+        tmpReg32 = PEMASK_EVENTS;
+        if (p_Dtsec->structFor1588.enErrExeption)
+            tmpReg32 |= PEMASK_TSRE;
+        WRITE_UINT32(p_DtsecMemMap->tmr_pemask, tmpReg32);
+        WRITE_UINT32(p_DtsecMemMap->tmr_pevent, tmpReg32);
     }
 
-/***************RCTRL************************/
-/***************IMASK************************/
-    WRITE_UINT32(p_DtsecMemMap->imask, p_DtsecDriverParam->imask);
-/***************IMASK************************/
-/***************IEVENT************************/
-    WRITE_UINT32(p_DtsecMemMap->ievent, 0xc7c7cfc3);
-/***************IEVENT************************/
-/***************DEBUG************************/
+    /***************DEBUG************************/
     tmpReg32 = 0;
     if(p_DtsecDriverParam->debugMode)
         WRITE_UINT32(p_DtsecMemMap->tsec_id1, TSEC_ID1_DEBUG);
-/***************DEBUG************************/
-/***************MACCFG1***********************/
+    /***************DEBUG************************/
 
+    /***************MACCFG1***********************/
     WRITE_UINT32(p_DtsecMemMap->maccfg1, MACCFG1_SOFT_RESET);
     WRITE_UINT32(p_DtsecMemMap->maccfg1, 0);
     tmpReg32 = 0;
@@ -447,9 +559,9 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     if(p_DtsecDriverParam->actOnTxPauseFrame)
         tmpReg32 |= MACCFG1_TX_FLOW;
     WRITE_UINT32(p_DtsecMemMap->maccfg1, tmpReg32);
+    /***************MACCFG1***********************/
 
-/***************MACCFG1***********************/
-/***************MACCFG2***********************/
+    /***************MACCFG2***********************/
     tmpReg32 = 0;
     if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
         (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)||
@@ -482,10 +594,9 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     if(!p_DtsecDriverParam->halfDuplex)
         tmpReg32 |= MACCFG2_FULL_DUPLEX;
     WRITE_UINT32(p_DtsecMemMap->maccfg2, tmpReg32);
+    /***************MACCFG2***********************/
 
-/***************MACCFG2***********************/
-/***************IPGIFG************************/
-
+    /***************IPGIFG************************/
     tmpReg32 = 0;
     ASSERT_COND(p_DtsecDriverParam->nonBackToBackIpg1 <= p_DtsecDriverParam->nonBackToBackIpg2);
     tmpReg32 = (uint32_t)((((uint32_t)p_DtsecDriverParam->nonBackToBackIpg1 <<
@@ -495,11 +606,10 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
               (((uint32_t)p_DtsecDriverParam->minIfgEnforcement <<
                 IPGIFG_MIN_IFG_ENFORCEMENT_SHIFT) & IPGIFG_MIN_IFG_ENFORCEMENT) |
               ((uint32_t)p_DtsecDriverParam->backToBackIpg & IPGIFG_BACK_TO_BACK_IPG));
-
     WRITE_UINT32(p_DtsecMemMap->ipgifg, tmpReg32);
+    /***************IPGIFG************************/
 
-/***************IPGIFG************************/
-/***************HAFDUP************************/
+    /***************HAFDUP************************/
     tmpReg32 = 0;
     if(p_DtsecDriverParam->alternateBackoffEnable)
     {
@@ -518,32 +628,25 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     tmpReg32|= ((uint32_t)p_DtsecDriverParam->collisionWindow & HAFDUP_COLLISION_WINDOW) ;
 
     WRITE_UINT32(p_DtsecMemMap->hafdup, tmpReg32);
-/***************HAFDUP************************/
-/***************MAXFRM************************/
+    /***************HAFDUP************************/
 
+    /***************MAXFRM************************/
     /* Initialize MAXFRM */
     WRITE_UINT32(p_DtsecMemMap->maxfrm,
                  p_DtsecDriverParam->maxFrameLength);
+    /***************MAXFRM************************/
 
-/***************MAXFRM************************/
-/***************MII************************/
-//#warning /*TODO - to take care about MII stuff*/
-/***************MII************************/
-/***************CAM1************************/
-
+    /***************CAM1************************/
     WRITE_UINT32(p_DtsecMemMap->cam1,
                  p_DtsecDriverParam->cam1);
+    /***************CAM1************************/
 
-/***************CAM1************************/
-/***************CAM2************************/
-
+    /***************CAM2************************/
     WRITE_UINT32(p_DtsecMemMap->cam2,
                  p_DtsecDriverParam->cam2);
+    /***************CAM2************************/
 
-/***************CAM2************************/
-
-/***************MACSTNADDR1/2*****************/
-
+    /***************MACSTNADDR1/2*****************/
     /*  Initialize MAC Station Address registers (1 & 2)    */
     /*  Station address have to be swapped (big endian to little endian */
     addr = p_Dtsec->addr;
@@ -555,15 +658,15 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     tmpReg32 = (uint32_t)(addr>>32);
     SwapUint32P(&tmpReg32);
     WRITE_UINT32(p_DtsecMemMap->macstnaddr2, tmpReg32);
-/***************MACSTNADDR1/2*****************/
+    /***************MACSTNADDR1/2*****************/
 
-/***************DEBUG*****************/
+    /***************DEBUG*****************/
     WRITE_UINT32(p_DtsecMemMap->tx_threshold,       (uint32_t)(p_DtsecDriverParam->fifoTxThr & 0x7f));
     WRITE_UINT32(p_DtsecMemMap->tx_watermark_high,  (uint32_t)(p_DtsecDriverParam->fifoTxWatermarkH & 0x7f));
     WRITE_UINT32(p_DtsecMemMap->rx_watermark_low,   (uint32_t)(p_DtsecDriverParam->fifoRxWatermarkL & 0x7f));
-/***************DEBUG*****************/
+    /***************DEBUG*****************/
 
-/*****************HASH************************/
+    /*****************HASH************************/
     for(i=0 ; i<NUM_OF_HASH_REGS ; i++)
     {
         /* Initialize IADDRx */
@@ -586,8 +689,15 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     }
     /*****************HASH************************/
 
-//#warning /*TODO - Set Interrupt routin*/
-//#warning /*TODO - TBI - need to think*/
+    FmRegisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC, p_Dtsec->macId, e_FM_INTR_TYPE_ERR, DtsecErrException , p_Dtsec);
+    FmRegisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC_TMR, p_Dtsec->macId, e_FM_INTR_TYPE_NORMAL, DtsecErrException , p_Dtsec);
+    if ((p_Dtsec->mdioIrq != 0) && (p_Dtsec->mdioIrq != NO_IRQ))
+    {
+        XX_SetIntr(p_Dtsec->mdioIrq, DtsecException, p_Dtsec);
+        XX_EnableIntr(p_Dtsec->mdioIrq);
+    }
+    else if (p_Dtsec->mdioIrq == 0)
+        FmRegisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC, p_Dtsec->macId, e_FM_INTR_TYPE_NORMAL, DtsecException , p_Dtsec);
 
     XX_Free(p_DtsecDriverParam);
     p_Dtsec->p_DtsecDriverParam = NULL;
@@ -705,6 +815,38 @@ static t_Error DtsecConfigHugeFrames(t_Handle h_Dtsec, bool newVal)
     return E_OK;
 }
 
+static t_Error DtsecConfigException(t_Handle h_Dtsec, e_FmMacExceptions exception, bool enable)
+{
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    uint32_t    bitMask = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    if(exception != e_FM_MAC_EX_1G_1588_TS_RX_ERR)
+    {
+        GET_EXCEPTION_FLAG(bitMask, exception);
+        if(bitMask)
+        {
+            if (enable)
+                p_Dtsec->exceptions |= bitMask;
+            else
+                p_Dtsec->exceptions &= ~bitMask;
+        }
+        else
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+    }
+    else
+    {
+        if(!p_Dtsec->support1588)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exception valid for 1588 only"));
+        if(enable)
+            p_Dtsec->structFor1588.enErrExeption = TRUE;
+        else
+            p_Dtsec->structFor1588.enErrExeption = FALSE;
+    }
+    return E_OK;
+}
 /*****************************************************************************/
 /*                      dTSEC Run Time API functions                         */
 /*****************************************************************************/
@@ -1199,14 +1341,12 @@ static t_Error DtsecAdjustLink(t_Handle h_Dtsec, e_EnetSpeed speed, bool fullDup
     else
         tmpReg32 |= MACCFG2_FULL_DUPLEX;
 
-	tmpReg32 &= ~(MACCFG2_NIBBLE_MODE | MACCFG2_BYTE_MODE);
-
+    tmpReg32 &= ~(MACCFG2_NIBBLE_MODE | MACCFG2_BYTE_MODE);
     if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
         (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)||
         (p_Dtsec->enetMode == e_ENET_MODE_SGMII_10) ||
         (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100))
             tmpReg32 |= MACCFG2_NIBBLE_MODE;
-
     else if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
         (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)||
         (p_Dtsec->enetMode == e_ENET_MODE_GMII_1000))
@@ -1232,6 +1372,7 @@ static t_Error DtsecGetId(t_Handle h_Dtsec, uint32_t *macId)
 {
     t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
     t_DtsecMemMap        *p_DtsecMemMap = p_Dtsec->p_MemMap;
+
 UNUSED(macId);
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
@@ -1261,14 +1402,53 @@ static t_Error DtsecGetVersion(t_Handle h_Dtsec, uint32_t *macVersion)
 
 /* .............................................................................. */
 
-static t_Error DtsecSetExcpetions(t_Handle h_Dtsec, e_FmMacExceptions ex)
+static t_Error DtsecSetExcpetion(t_Handle h_Dtsec, e_FmMacExceptions exception, bool enable)
 {
-    t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    uint32_t            tmpReg, bitMask = 0;
+    t_DtsecMemMap       *p_DtsecMemMap = (t_DtsecMemMap*)p_Dtsec->p_MemMap;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
-UNUSED(ex);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
+    //e_FM_MAC_EX_1G_1588_TS_RX_ERR??
+
+    if(exception != e_FM_MAC_EX_1G_1588_TS_RX_ERR)
+    {
+        GET_EXCEPTION_FLAG(bitMask, exception);
+        if(bitMask)
+        {
+            if (enable)
+                p_Dtsec->exceptions |= bitMask;
+            else
+                p_Dtsec->exceptions &= ~bitMask;
+       }
+        else
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+        tmpReg = GET_UINT32(p_DtsecMemMap->imask);
+        if(enable)
+            tmpReg |= bitMask;
+        else
+            tmpReg &= ~bitMask;
+        WRITE_UINT32(p_DtsecMemMap->imask, tmpReg);
+    }
+    else
+    {
+        if(!p_Dtsec->support1588)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exception valid for 1588 only"));
+        if(enable)
+        {
+            p_Dtsec->structFor1588.enErrExeption = TRUE;
+            WRITE_UINT32(p_DtsecMemMap->tmr_pemask, PEMASK_TSRE);
+        }
+        else
+        {
+            p_Dtsec->structFor1588.enErrExeption = FALSE;
+            WRITE_UINT32(p_DtsecMemMap->tmr_pemask, 0);
+        }
+    }
 
-    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+    return E_OK;
 }
 
 /* ........................................................................... */
@@ -1308,7 +1488,6 @@ static t_Error DtsecDumpRegs(t_Handle h_Dtsec)
             DUMP_VAR(p_Dtsec->p_MemMap, macaddr[i].exact_match1);
             DUMP_VAR(p_Dtsec->p_MemMap, macaddr[i].exact_match2);
         }
-
     }
 
     return E_OK;
@@ -1336,12 +1515,13 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
     p_FmMacControllerDriver->f_FM_MAC_ConfigPadAndCrc           = DtsecConfigPadAndCrc;
     p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex          = DtsecConfigHalfDuplex;
     p_FmMacControllerDriver->f_FM_MAC_ConfigHugeFrames          = DtsecConfigHugeFrames;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigException           = DtsecConfigException;
 
     p_FmMacControllerDriver->f_FM_MAC_Enable                    = DtsecEnable;
     p_FmMacControllerDriver->f_FM_MAC_Disable                   = DtsecDisable;
     p_FmMacControllerDriver->f_FM_MAC_Restart                   = DtsecRestart;
 
-    p_FmMacControllerDriver->f_FM_MAC_SetExceptions             = DtsecSetExcpetions;
+    p_FmMacControllerDriver->f_FM_MAC_SetException              = DtsecSetExcpetion;
 
     p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous            = DtsecSetPromiscuous;
     p_FmMacControllerDriver->f_FM_MAC_AdjustLink                = DtsecAdjustLink;
@@ -1410,6 +1590,10 @@ t_Handle  DTSEC_Config(t_FmMacParams *p_FmMacParam)
     p_Dtsec->p_MiiMemMap  = CAST_UINT64_TO_POINTER_TYPE(t_MiiAccessMemMap, (baseAddr + DTSEC_TO_MII_OFFSET));
     p_Dtsec->enetMode = p_FmMacParam->enetMode;
     p_Dtsec->macId    = p_FmMacParam->macId;
+    p_Dtsec->exceptions = DEFAULT_exceptions;
+    p_Dtsec->f_Exceptions = p_FmMacParam->f_Exceptions;
+    p_Dtsec->mdioIrq = p_FmMacParam->mdioIrq;
+    p_Dtsec->f_Events = p_FmMacParam->f_Events;
 
     return p_Dtsec;
 }
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
index 01c6415..b80e5b3 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
@@ -45,6 +45,64 @@
 #include "fm_mac.h"
 
 
+#define PEMASK_TSRE                 0x00010000
+#define PEMASK_EVENTS               0x00000301
+
+#define IMASK_BREN                  0x80000000
+#define IMASK_RXCEN                 0x40000000
+#define IMASK_MSROEN                0x04000000
+#define IMASK_GTSCEN                0x02000000
+#define IMASK_BTEN                  0x01000000
+#define IMASK_TXCEN                 0x00800000
+#define IMASK_TXEEN                 0x00400000
+#define IMASK_LCEN                  0x00040000
+#define IMASK_CRLEN                 0x00020000
+#define IMASK_XFUNEN                0x00010000
+#define IMASK_ABRTEN                0x00008000
+#define IMASK_IFERREN               0x00004000
+#define IMASK_MAGEN                 0x00000800
+#define IMASK_MMRDEN                0x00000400
+#define IMASK_MMWREN                0x00000200
+#define IMASK_GRSCEN                0x00000100
+#define IMASK_TDPEEN                0x00000002
+#define IMASK_RDPEEN                0x00000001
+
+#define GET_EXCEPTION_FLAG(bitMask, exception)       switch(exception){ \
+    case e_FM_MAC_EX_1G_BAB_RX:                                   \
+        bitMask = IMASK_BREN; break;                              \
+    case e_FM_MAC_EX_1G_RX_CTL:                                   \
+        bitMask = IMASK_RXCEN; break;                             \
+    case e_FM_MAC_EX_1G_MIB_CNT_OVFL:                             \
+        bitMask = IMASK_MSROEN ; break;                           \
+    case e_FM_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET:                  \
+        bitMask = IMASK_GTSCEN ; break;                           \
+    case e_FM_MAC_EX_1G_BAB_TX:                                   \
+        bitMask = IMASK_BTEN   ; break;                           \
+    case e_FM_MAC_EX_1G_TX_CTL:                                   \
+        bitMask = IMASK_TXCEN  ; break;                           \
+    case e_FM_MAC_EX_1G_TX_ERR:                                   \
+        bitMask = IMASK_TXEEN  ; break;                           \
+    case e_FM_MAC_EX_1G_LATE_COL:                                 \
+        bitMask = IMASK_LCEN   ; break;                           \
+    case e_FM_MAC_EX_1G_COL_RET_LMT:                              \
+        bitMask = IMASK_CRLEN  ; break;                           \
+    case e_FM_MAC_EX_1G_TX_FIFO_UNDRN:                            \
+        bitMask = IMASK_XFUNEN ; break;                           \
+    case e_FM_MAC_EX_1G_MAG_PCKT:                                 \
+        bitMask = IMASK_MAGEN ; break;                            \
+    case e_FM_MAC_EX_1G_MII_MNG_RD_COMPLET:                       \
+        bitMask = IMASK_MMRDEN; break;                            \
+    case e_FM_MAC_EX_1G_MII_MNG_WR_COMPLET:                       \
+        bitMask = IMASK_MMWREN  ; break;                          \
+    case e_FM_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET:                  \
+        bitMask = IMASK_GRSCEN; break;                            \
+    case e_FM_MAC_EX_1G_TX_DATA_ERR:                              \
+        bitMask = IMASK_TDPEEN; break;                            \
+    case e_FM_MAC_EX_1G_RX_DATA_ERR:                              \
+        bitMask = IMASK_RDPEEN ; break;                           \
+    default: bitMask = 0;break;}
+
+
 #define MAX_PACKET_ALIGNMENT        31
 #define MAX_INTER_PACKET_GAP        0x7f
 #define MAX_INTER_PALTERNATE_BEB    0x0f
@@ -134,13 +192,12 @@ typedef  uint32_t t_ErrorDisable;
 #define DEFAULT_fifoRxWatermarkL    0x08
 #define DEFAULT_tbiPhyAddr          5
 
-#define DEFAULT_imask               ((uint32_t)(IMASK_BREN | IMASK_RXCEN | IMASK_MSROEN | IMASK_GTSCEN | \
-                                                IMASK_BTEN | IMASK_TXCEN | IMASK_TXEEN |  IMASK_ABRTEN | \
-                                                IMASK_LCEN | IMASK_CRLEN | IMASK_XFUNEN) |IMASK_IFERREN| \
-                                                IMASK_MAGEN | IMASK_MMRDEN | IMASK_MMWREN |IMASK_GRSCEN| \
-                                                IMASK_TDPEEN |IMASK_RDPEEN)
+#define DEFAULT_exceptions         ((uint32_t)(IMASK_BREN | IMASK_RXCEN | IMASK_MSROEN | \
+                                               IMASK_BTEN | IMASK_TXCEN | IMASK_TXEEN |  IMASK_ABRTEN | \
+                                               IMASK_LCEN | IMASK_CRLEN | IMASK_XFUNEN |IMASK_IFERREN| \
+                                               IMASK_MAGEN | IMASK_TDPEEN |IMASK_RDPEEN))
 
-#define MAX_PHYS                    31 /* maximum number of phys */
+#define MAX_PHYS                    32 /* maximum number of phys */
 
 #define DTSEC_ID1_ID                0xffff0000
 #define DTSEC_ID1_REV_MJ            0x0000FF00
@@ -238,29 +295,11 @@ typedef  uint32_t t_ErrorDisable;
 /* Pause Time Value Register  */
 #define PTV_PTE_SHIFT    16
 
-#define IEVENT_BABR    IMASK_BREN                  /* 0x80000000 */
-#define IEVENT_RXC     IMASK_RXCEN                 /* 0x40000000 */
-#define IEVENT_MSRO    IMASK_MSROEN                /* 0x04000000 */
-#define IEVENT_GTSC    IMASK_GTSCEN                /* 0x02000000 */
-#define IEVENT_BABT    IMASK_BTEN                  /* 0x01000000 */
-#define IEVENT_TXC     IMASK_TXCEN                 /* 0x00800000 */
-#define IEVENT_TXE     IMASK_TXEEN                 /* 0x00400000 */
-#define IEVENT_LC      IMASK_LCEN                  /* 0x00040000 */
-#define IEVENT_CRL     IMASK_CRLEN                 /* 0x00020000 */
-#define IEVENT_XFUN    IMASK_XFUNEN                /* 0x00010000 */
-#define IEVENT_ABRT    IMASK_ABRTEN                /* 0x00008000 */
-#define IEVENT_IFERR   IMASK_IFERREN               /* 0x00004000 */
-#define IEVENT_MAG     IMASK_MAGEN                 /* 0x00000800 */
-#define IEVENT_MMRD    IMASK_MMRDEN                /* 0x00000400 */
-#define IEVENT_MMWR    IMASK_MMWREN                /* 0x00000200 */
-#define IEVENT_GRSC    IMASK_GRSCEN                /* 0x00000100 */
-#define IEVENT_DPE     IMASK_TDPEEN                /* 0x00000002 */
-#define IEVENT_RDPE    IMASK_RDPEEN                /* 0x00000001 */
-
-#define IEVENT_ERRORS   (IEVENT_BABR | IMASK_RXCEN | IMASK_MSROEN | IMASK_BTEN | \
-                         IMASK_TXCEN | IMASK_TXEEN | IMASK_LCEN | IMASK_CRLEN | \
-                         IMASK_XFUNEN | IMASK_ABRTEN | IMASK_IFERREN | IMASK_MAGEN | \
-                         IMASK_MMRDEN | IMASK_MMWREN | IMASK_TDPEEN | IMASK_RDPEEN)
+#define EVENTS_MASK                 ((uint32_t)(IMASK_BREN | IMASK_RXCEN | IMASK_MSROEN | IMASK_GTSCEN | \
+                                                IMASK_BTEN | IMASK_TXCEN | IMASK_TXEEN  | IMASK_ABRTEN | \
+                                                IMASK_LCEN | IMASK_CRLEN | IMASK_XFUNEN | IMASK_IFERREN| \
+                                                IMASK_MAGEN | IMASK_MMRDEN | IMASK_MMWREN | \
+                                                IMASK_TDPEEN |IMASK_RDPEEN))
 
 #define     MASK22BIT   0x003FFFFF
 #define     MASK16BIT   0x0000FFFF
@@ -319,7 +358,7 @@ typedef _Packed struct
     volatile uint32_t ipgifg;               /* 0x108 IPG/IFG */
     volatile uint32_t hafdup;               /* 0x10C Half-duplex */
     volatile uint32_t maxfrm;               /* 0x110 Maximum frame */
-    volatile uint32_t DTSEC_RESERVED7[3];   /* 0x1140x11C register */
+    volatile uint32_t DTSEC_RESERVED7[3];  /* 0x1140x11C register */
     volatile uint32_t miimcfg;              /* 0x120 MII Mgmt:configuration */
     volatile uint32_t miimcom;              /* 0x124 MII Mgmt:command */
     volatile uint32_t miimadd;              /* 0x128 MII Mgmt:address */
@@ -477,8 +516,6 @@ typedef struct {
     uint8_t     fifoTxThr;
     uint8_t     fifoTxWatermarkH;
     uint8_t     fifoRxWatermarkL;
-
-    uint32_t    imask;
 } t_DtsecDriverParam;
 
 typedef struct {
@@ -489,6 +526,8 @@ typedef struct {
     uint64_t                    addr;             /**< MAC address of device;                             */
     e_EnetMode                  enetMode;         /**< Ethernet physical interface  */
     t_FmMacExceptionCallback    *f_Exceptions;
+    int                         mdioIrq;
+    t_FmMacExceptionCallback    *f_Events;
     bool                        indAddrRegUsed[DTSEC_NUM_OF_PADDRS]; /**< Whether a particular individual address recognition register is being used */
     uint64_t                    paddr[DTSEC_NUM_OF_PADDRS]; /**< MAC address for particular individual address recognition register */
     uint8_t                     numOfIndAddrInRegs; /**< Number of individual addresses in registers for this station. */
@@ -498,9 +537,16 @@ typedef struct {
     t_EthHash                   *p_MulticastAddrHash;      /* pointer to driver's global address hash table  */
     t_EthHash                   *p_UnicastAddrHash;    /* pointer to driver's individual address hash table  */
     uint8_t                     macId;
+    uint32_t                    exceptions;
     t_DtsecDriverParam          *p_DtsecDriverParam;
+/* TODO - tmp, for Moti to set names and structs */
+    bool                        support1588;
+    struct{
+            bool    enErrExeption;
+    }structFor1588;
 } t_Dtsec;
 
+
 t_Error DTSEC_MII_WritePhyReg(t_Handle h_Dtsec, uint8_t phyAddr, uint8_t reg, uint16_t data);
 t_Error DTSEC_MII_ReadPhyReg(t_Handle  h_Dtsec, uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
index 64518be..8a146e5 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
@@ -112,7 +112,7 @@ t_Error DTSEC_MII_ReadPhyReg(t_Handle h_Dtsec,
     tmpReg = GET_UINT32(p_MiiAccess->miimcom);
 
     if (*p_Data == 0xffff)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Read wrong data: phyAddr"));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Read wrong data (0xffff): phyAddr 0x%x, reg 0x%x", phyAddr, reg));
 
     return E_OK;
 }
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
index c952a59..cd19090 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
@@ -30,10 +30,11 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifndef __MII_ACC_H
-#define __MII_ACC_H
+#ifndef __DTSEC_MII_ACC_H
+#define __DTSEC_MII_ACC_H
+
+#include "std_ext.h"
 
-/* #define __ERR_MODULE__ MODULE_MII */
 
 /* MII Management Configuration Register */
 #define MIIMCFG_RESET_MGMT          0x80000000
@@ -49,6 +50,12 @@
 /* MII Management Indicator Register */
 #define MIIMIND_BUSY                0x00000001
 
+
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+
 /*----------------------------------------------------*/
 /* MII Configuration Control Memory Map Registers     */
 /*----------------------------------------------------*/
@@ -62,5 +69,10 @@ typedef _Packed struct t_MiiAccessMemMap
     volatile uint32_t miimind;    /* MII Mgmt:indicators    */
 } _PackedType t_MiiAccessMemMap ;
 
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
 
-#endif /* __MII_ACC_H */
+#endif /* __DTSEC_MII_ACC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
index 34d39ca..601cb18 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
@@ -60,10 +60,10 @@ t_Handle FM_MAC_Config (t_FmMacParams *p_FmMacParam)
     if (!p_FmMacControllerDriver)
         return NULL;
 
-    p_FmMacControllerDriver->h_Fm = p_FmMacParam->h_Fm;
-
-    p_FmMacControllerDriver->enetMode = p_FmMacParam->enetMode;
-    p_FmMacControllerDriver->macId    = p_FmMacParam->macId;
+    p_FmMacControllerDriver->h_Fm           = p_FmMacParam->h_Fm;
+    p_FmMacControllerDriver->enetMode       = p_FmMacParam->enetMode;
+    p_FmMacControllerDriver->macId          = p_FmMacParam->macId;
+    p_FmMacControllerDriver->resetOnInit    = DEFAULT_resetOnInit;
 
     return (t_Handle)p_FmMacControllerDriver;
 }
@@ -76,6 +76,12 @@ t_Error FM_MAC_Init (t_Handle h_FmMac)
 
     SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
 
+    if (p_FmMacControllerDriver->resetOnInit &&
+        (FmResetMac(p_FmMacControllerDriver->h_Fm,
+                    ((ENET_INTERFACE_FROM_MODE(p_FmMacControllerDriver->enetMode) == e_ENET_IF_XGMII) ? e_FM_MAC_10G : e_FM_MAC_1G),
+                     p_FmMacControllerDriver->macId) != E_OK))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Can't reset MAC!"));
+
     if (p_FmMacControllerDriver->f_FM_MAC_Init)
         return p_FmMacControllerDriver->f_FM_MAC_Init(h_FmMac);
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
@@ -97,6 +103,19 @@ t_Error FM_MAC_Free (t_Handle h_FmMac)
 
 /* ........................................................................... */
 
+t_Error FM_MAC_ConfigResetOnInit (t_Handle h_FmMac, bool enable)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    p_FmMacControllerDriver->resetOnInit = enable;
+
+    return E_OK;
+}
+
+/* ........................................................................... */
+
 t_Error FM_MAC_ConfigStatistics (t_Handle h_FmMac, bool newVal)
 {
     t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
@@ -193,6 +212,19 @@ t_Error FM_MAC_ConfigHugeFrames (t_Handle h_FmMac, bool newVal)
 }
 
 /* ........................................................................... */
+t_Error FM_MAC_ConfigException (t_Handle h_FmMac, e_FmMacExceptions ex, bool enable)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigException)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigException(h_FmMac, ex, enable);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
 
 /*****************************************************************************/
 /* Run Time Control                                                          */
@@ -242,22 +274,6 @@ t_Error FM_MAC_Restart (t_Handle h_FmMac, e_CommMode mode)
 
 /* ........................................................................... */
 
-t_Error FM_MAC_Reset (t_Handle h_FmMac, bool wait)
-{
-    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
-
-    if  (!wait)
-        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("reset must blocking!!!"));
-
-    return FmResetMac(p_FmMacControllerDriver->h_Fm,
-                      ((ENET_SPEED_FROM_MODE(p_FmMacControllerDriver->enetMode) < e_ENET_SPEED_10000) ? e_FM_MAC_1G : e_FM_MAC_10G),
-                      p_FmMacControllerDriver->macId);
-}
-
-/* ........................................................................... */
-
 t_Error FM_MAC_TxMacPause (t_Handle h_FmMac, uint16_t pauseTime, uint16_t exPauseTime)
 {
     t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
@@ -286,14 +302,14 @@ t_Error FM_MAC_ResetCounters (t_Handle h_FmMac)
 
 /* ........................................................................... */
 
-t_Error FM_MAC_SetExceptions(t_Handle h_FmMac, e_FmMacExceptions ex)
+t_Error FM_MAC_SetException(t_Handle h_FmMac, e_FmMacExceptions ex, bool enable)
 {
    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
 
     SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
 
-    if (p_FmMacControllerDriver->f_FM_MAC_SetExceptions)
-        return p_FmMacControllerDriver->f_FM_MAC_SetExceptions(h_FmMac, ex);
+    if (p_FmMacControllerDriver->f_FM_MAC_SetException)
+        return p_FmMacControllerDriver->f_FM_MAC_SetException(h_FmMac, ex, enable);
 
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
index 16c26fe..b981f41 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
@@ -45,6 +45,9 @@
 #include "fm_mac_ext.h"
 
 
+#define DEFAULT_resetOnInit                 FALSE
+
+
 typedef struct
 {
     t_Error (*f_FM_MAC_Init) (t_Handle h_FmMac);
@@ -57,8 +60,9 @@ typedef struct
     t_Error (*f_FM_MAC_ConfigPadAndCrc) (t_Handle h_FmMac, bool newVal);
     t_Error (*f_FM_MAC_ConfigHalfDuplex) (t_Handle h_FmMac, bool newVal);
     t_Error (*f_FM_MAC_ConfigHugeFrames) (t_Handle h_FmMac, bool newVal);
+    t_Error (*f_FM_MAC_ConfigException) (t_Handle h_FmMac, e_FmMacExceptions, bool enable);
 
-    t_Error (*f_FM_MAC_SetExceptions) (t_Handle h_FmMac, e_FmMacExceptions ex);
+    t_Error (*f_FM_MAC_SetException) (t_Handle h_FmMac, e_FmMacExceptions ex, bool enable);
 
     t_Error (*f_FM_MAC_Enable)  (t_Handle h_FmMac,  e_CommMode mode);
     t_Error (*f_FM_MAC_Disable) (t_Handle h_FmMac, e_CommMode mode);
@@ -93,6 +97,7 @@ typedef struct
     t_Handle        h_Fm;
     e_EnetMode      enetMode;
     uint8_t         macId;
+    bool            resetOnInit;
 } t_FmMacControllerDriver;
 
 typedef struct {
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
index 34bcb06..81ddd82 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
@@ -43,6 +43,7 @@
 #include "endian_ext.h"
 #include "crc_mac_addr_ext.h"
 #include "debug_ext.h"
+#include "fm_common.h"
 
 #include "tgec.h"
 
@@ -95,12 +96,75 @@ static void SetDefaultParam(t_TgecDriverParam *p_TgecDriverParam)
     p_TgecDriverParam->debugMode                = DEFAULT_debugMode;
 
     p_TgecDriverParam->pauseTime                = DEFAULT_pauseTime;
-
-//Temp    p_TgecDriverParam->imask              = DEFAULT_imask;
 }
 
 /* ........................................................................... */
 
+static void TgecErrException(t_Handle h_Tgec)
+{
+    t_Tgec             *p_Tgec = (t_Tgec *)h_Tgec;
+    uint32_t            event;
+    t_TgecMemMap        *p_TgecMemMap = p_Tgec->p_MemMap;
+
+    event = GET_UINT32(p_TgecMemMap->ievent);
+    /* do not handle MDIO events */
+    event &= ~(IMASK_MDIO_SCAN_EVENTMDIO | IMASK_MDIO_CMD_CMPL);
+
+    event &= GET_UINT32(p_TgecMemMap->imask);
+
+    WRITE_UINT32(p_TgecMemMap->ievent, event);
+
+    if(event & IMASK_REM_FAULT)
+        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_REM_FAULT);
+    if(event & IMASK_LOC_FAULT)
+        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_LOC_FAULT);
+    if(event & IMASK_1TX_ECC_ER)
+        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_1TX_ECC_ER);
+    if(event & IMASK_TX_FIFO_UNFL)
+        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_TX_FIFO_UNFL);
+    if(event & IMASK_TX_FIFO_OVFL)
+        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_TX_FIFO_OVFL);
+    if(event & IMASK_TX_ER )
+        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_TX_ER);
+    if(event & IMASK_RX_FIFO_OVFL )
+        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_FIFO_OVFL);
+    if(event & IMASK_RX_ECC_ER )
+        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_ECC_ER);
+    if(event & IMASK_RX_JAB_FRM)
+        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_JAB_FRM);
+    if(event & IMASK_RX_OVRSZ_FRM)
+        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_OVRSZ_FRM);
+    if(event & IMASK_RX_RUNT_FRM )
+        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_RUNT_FRM);
+    if(event & IMASK_RX_FRAG_FRM)
+        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_FRAG_FRM);
+    if(event & IMASK_RX_LEN_ER)
+        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_LEN_ER);
+    if(event & IMASK_RX_CRC_ER)
+        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_CRC_ER);
+    if(event & IMASK_RX_ALIGN_ER)
+        p_Tgec->f_Exceptions(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_ALIGN_ER);
+
+}
+static void TgecException(t_Handle h_Tgec)
+{
+    t_Tgec             *p_Tgec = (t_Tgec *)h_Tgec;
+     uint32_t            event;
+     t_TgecMemMap        *p_TgecMemMap = p_Tgec->p_MemMap;
+
+     event = GET_UINT32(p_TgecMemMap->ievent);
+     /* handle only MDIO events */
+     event &= (IMASK_MDIO_SCAN_EVENTMDIO | IMASK_MDIO_CMD_CMPL);
+     event &= GET_UINT32(p_TgecMemMap->imask);
+
+     WRITE_UINT32(p_TgecMemMap->ievent, event);
+
+     if(event & IMASK_MDIO_SCAN_EVENTMDIO)
+         p_Tgec->f_Events(p_Tgec->h_App, e_FM_MAC_EX_10G_MDIO_SCAN_EVENTMDIO);
+     if(event & IMASK_MDIO_CMD_CMPL)
+         p_Tgec->f_Events(p_Tgec->h_App, e_FM_MAC_EX_10G_MDIO_CMD_CMPL);
+}
+
 static void FreeInitResources(t_Tgec *p_Tgec)
 {
     /* release the driver's group hash table */
@@ -262,6 +326,19 @@ static t_Error TgecInit(t_Handle h_Tgec)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("allocation hash table is FAILED"));
     }
 
+    /* interrupts */
+    WRITE_UINT32(p_MemMap->ievent, EVENTS_MASK);
+    WRITE_UINT32(p_MemMap->imask, p_Tgec->exceptions);
+
+    FmRegisterIntr(p_Tgec->fmMacControllerDriver.h_Fm, e_FM_MOD_10G_MAC, p_Tgec->macId, e_FM_INTR_TYPE_ERR, TgecErrException , p_Tgec);
+    if ((p_Tgec->mdioIrq != 0) && (p_Tgec->mdioIrq != NO_IRQ))
+    {
+        XX_SetIntr(p_Tgec->mdioIrq, TgecException, p_Tgec);
+        XX_EnableIntr(p_Tgec->mdioIrq);
+    }
+    else if (p_Tgec->mdioIrq == 0)
+        REPORT_ERROR(MINOR, E_NOT_SUPPORTED, (NO_MSG));
+
     XX_Free(p_TgecDriverParam);
     p_Tgec->p_TgecDriverParam = NULL;
 
@@ -287,6 +364,7 @@ static t_Error TgecConfigStatistics(t_Handle h_Tgec, bool newVal)
     return E_OK;
 }
 
+#ifndef FM_10G_MAC_NO_CTRL_LOOPBACK
 /* .............................................................................. */
 
 static t_Error TgecConfigLoopback(t_Handle h_Tgec, bool newVal)
@@ -300,6 +378,7 @@ static t_Error TgecConfigLoopback(t_Handle h_Tgec, bool newVal)
 
     return E_OK;
 }
+#endif /* !FM_10G_MAC_NO_CTRL_LOOPBACK */
 
 /* .............................................................................. */
 
@@ -364,6 +443,28 @@ static t_Error TgecConfigHugeFrames(t_Handle h_Tgec, bool newVal)
 
 /* .............................................................................. */
 
+static t_Error TgecConfigException(t_Handle h_Tgec, e_FmMacExceptions exception, bool enable)
+{
+    t_Tgec      *p_Tgec = (t_Tgec *)h_Tgec;
+    uint32_t    bitMask = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
+    GET_EXCEPTION_FLAG(bitMask, exception);
+    if(bitMask)
+    {
+        if (enable)
+            p_Tgec->exceptions |= bitMask;
+        else
+            p_Tgec->exceptions &= ~bitMask;
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    return E_OK;
+}
+
 static t_Error TgecEnable(t_Handle h_Tgec,  e_CommMode mode)
 {
     t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
@@ -465,8 +566,6 @@ static t_Error TgecGetStatistics(t_Handle h_Tgec, t_FmMacStatistics *p_Statistic
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Statistics, E_NULL_POINTER);
 
-
-
     p_Statistics->eStatPkts64           = GET_UINT64(p_TgecMemMap->R64);
     p_Statistics->eStatPkts65to127      = GET_UINT64(p_TgecMemMap->R127);
     p_Statistics->eStatPkts128to255     = GET_UINT64(p_TgecMemMap->R255);
@@ -806,15 +905,33 @@ RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 
 /* .............................................................................. */
 
-static t_Error TgecSetExcpetions(t_Handle h_Tgec, e_FmMacExceptions ex)
+static t_Error TgecSetExcpetion(t_Handle h_Tgec, e_FmMacExceptions exception, bool enable)
 {
     t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
+    uint32_t            bitMask = 0, tmpReg;
+    t_TgecMemMap        *p_TgecMemMap = p_Tgec->p_MemMap;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_HANDLE);
-UNUSED(ex);
 
-    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+    GET_EXCEPTION_FLAG(bitMask, exception);
+    if(bitMask)
+    {
+        if (enable)
+            p_Tgec->exceptions |= bitMask;
+        else
+            p_Tgec->exceptions &= ~bitMask;
+   }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    tmpReg = GET_UINT32(p_TgecMemMap->imask);
+    if(enable)
+        tmpReg |= bitMask;
+    else
+        tmpReg &= ~bitMask;
+    WRITE_UINT32(p_TgecMemMap->imask, tmpReg);
+    return E_OK;
 }
 
 /* .............................................................................. */
@@ -829,6 +946,34 @@ static t_Error TgecDumpRegs(t_Handle h_Tgec)
     if (p_Tgec->p_MemMap)
     {
         DUMP_TITLE(p_Tgec->p_MemMap, ("10G MAC %d: ", p_Tgec->macId));
+        DUMP_VAR(p_Tgec->p_MemMap, tgec_id);
+        DUMP_VAR(p_Tgec->p_MemMap, scratch);
+        DUMP_VAR(p_Tgec->p_MemMap, cmd_conf_ctrl);
+        DUMP_VAR(p_Tgec->p_MemMap, mac_addr_0);
+        DUMP_VAR(p_Tgec->p_MemMap, mac_addr_1);
+        DUMP_VAR(p_Tgec->p_MemMap, maxfrm);
+        DUMP_VAR(p_Tgec->p_MemMap, pause_quant);
+        DUMP_VAR(p_Tgec->p_MemMap, rx_fifo_sections);
+        DUMP_VAR(p_Tgec->p_MemMap, tx_fifo_sections);
+        DUMP_VAR(p_Tgec->p_MemMap, rx_fifo_almost_f_e);
+        DUMP_VAR(p_Tgec->p_MemMap, tx_fifo_almost_f_e);
+        DUMP_VAR(p_Tgec->p_MemMap, hashtable_ctrl);
+        DUMP_VAR(p_Tgec->p_MemMap, mdio_cfg_status);
+        DUMP_VAR(p_Tgec->p_MemMap, mdio_command);
+        DUMP_VAR(p_Tgec->p_MemMap, mdio_data);
+        DUMP_VAR(p_Tgec->p_MemMap, mdio_regaddr);
+        DUMP_VAR(p_Tgec->p_MemMap, status);
+        DUMP_VAR(p_Tgec->p_MemMap, tx_ipg_len);
+        DUMP_VAR(p_Tgec->p_MemMap, mac_addr_2);
+        DUMP_VAR(p_Tgec->p_MemMap, mac_addr_3);
+        DUMP_VAR(p_Tgec->p_MemMap, rx_fifo_ptr_rd);
+        DUMP_VAR(p_Tgec->p_MemMap, rx_fifo_ptr_wr);
+        DUMP_VAR(p_Tgec->p_MemMap, tx_fifo_ptr_rd);
+        DUMP_VAR(p_Tgec->p_MemMap, tx_fifo_ptr_wr);
+        DUMP_VAR(p_Tgec->p_MemMap, imask);
+        DUMP_VAR(p_Tgec->p_MemMap, ievent);
+        DUMP_VAR(p_Tgec->p_MemMap, udp_port);
+        DUMP_VAR(p_Tgec->p_MemMap, type_1588v2);
     }
 
     return E_OK;
@@ -845,7 +990,9 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
     p_FmMacControllerDriver->f_FM_MAC_Free                      = TgecFree;
 
     p_FmMacControllerDriver->f_FM_MAC_ConfigStatistics          = TgecConfigStatistics;
+#ifndef FM_10G_MAC_NO_CTRL_LOOPBACK
     p_FmMacControllerDriver->f_FM_MAC_ConfigLoopback            = TgecConfigLoopback;
+#endif /* !FM_10G_MAC_NO_CTRL_LOOPBACK */
     p_FmMacControllerDriver->f_FM_MAC_ConfigMaxFrameLength      = TgecConfigMaxFrameLength;
 
     p_FmMacControllerDriver->f_FM_MAC_ConfigWan                 = TgecConfigWan;
@@ -853,8 +1000,9 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
     p_FmMacControllerDriver->f_FM_MAC_ConfigPadAndCrc           = TgecConfigPadAndCrc;
     p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex          = NULL; /* half-duplex is not supported in xgec */
     p_FmMacControllerDriver->f_FM_MAC_ConfigHugeFrames          = TgecConfigHugeFrames;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigException           = TgecConfigException;
 
-    p_FmMacControllerDriver->f_FM_MAC_SetExceptions             = TgecSetExcpetions;
+    p_FmMacControllerDriver->f_FM_MAC_SetException              = TgecSetExcpetion;
 
     p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous            = TgecSetPromiscuous;
     p_FmMacControllerDriver->f_FM_MAC_AdjustLink                = TgecAdjustLink;
@@ -925,6 +1073,10 @@ t_Handle  TGEC_Config(t_FmMacParams *p_FmMacParam)
     p_Tgec->p_MiiMemMap  = CAST_UINT64_TO_POINTER_TYPE(t_TgecMiiAccessMemMap, (baseAddr + TGEC_TO_MII_OFFSET));
     p_Tgec->enetMode = p_FmMacParam->enetMode;
     p_Tgec->macId    = p_FmMacParam->macId;
+    p_Tgec->exceptions = DEFAULT_exceptions;
+    p_Tgec->f_Exceptions = p_FmMacParam->f_Exceptions;
+    p_Tgec->mdioIrq = p_FmMacParam->mdioIrq;
+    p_Tgec->f_Events = p_FmMacParam->f_Events;
 
     return p_Tgec;
 }
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
index 9c8ac97..173f67c 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
@@ -44,6 +44,114 @@
 #include "tgec_mii_acc.h"
 #include "fm_mac.h"
 
+/* Interrupt Mask Register (IMASK) */
+#define IMASK_MDIO_SCAN_EVENTMDIO   0x00010000  /* MDIO_SCAN_EVENTMDIO scan event interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_MDIO_CMD_CMPL         0x00008000  /* 16 MDIO_CMD_CMPL MDIO command completion interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_REM_FAULT             0x00004000  /* 17 REM_FAULT Remote fault interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_LOC_FAULT             0x00002000  /* 18 LOC_FAULT Local fault interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_1TX_ECC_ER            0x00001000  /* 19 TX_ECC_ER Transmit frame ECC error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_TX_FIFO_UNFL          0x00000800  /* 20 TX_FIFO_UNFL Transmit FIFO underflow interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_TX_FIFO_OVFL          0x00000400  /* 21 TX_FIFO_OVFL Transmit FIFO overflow interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_TX_ER                 0x00000200  /* 22 TX_ER Transmit frame error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_FIFO_OVFL          0x00000100  /* 23 RX_FIFO_OVFL Receive FIFO overflow interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_ECC_ER             0x00000080  /* 24 RX_ECC_ER Receive frame ECC error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_JAB_FRM            0x00000040  /* 25 RX_JAB_FRM Receive jabber frame interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_OVRSZ_FRM          0x00000020  /* 26 RX_OVRSZ_FRM Receive oversized frame interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_RUNT_FRM           0x00000010  /* 27 RX_RUNT_FRM Receive runt frame interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_FRAG_FRM           0x00000008  /* 28 RX_FRAG_FRM Receive fragment frame interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_LEN_ER             0x00000004  /* 29 RX_LEN_ER Receive payload length error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_CRC_ER             0x00000002  /* 30 RX_CRC_ER Receive CRC error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_ALIGN_ER           0x00000001  /* 31 RX_ALIGN_ER Receive alignment error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+
+
+#define GET_EXCEPTION_FLAG(bitMask, exception)       switch(exception){ \
+    case e_FM_MAC_EX_10G_MDIO_SCAN_EVENTMDIO:                                    \
+        bitMask = IMASK_MDIO_SCAN_EVENTMDIO; break;                              \
+    case e_FM_MAC_EX_10G_MDIO_CMD_CMPL:                                          \
+        bitMask = IMASK_MDIO_CMD_CMPL      ; break;                              \
+    case e_FM_MAC_EX_10G_REM_FAULT:                                              \
+        bitMask = IMASK_REM_FAULT          ; break;                              \
+    case e_FM_MAC_EX_10G_LOC_FAULT:                                              \
+        bitMask = IMASK_LOC_FAULT          ; break;                              \
+    case e_FM_MAC_EX_10G_1TX_ECC_ER:                                             \
+        bitMask = IMASK_1TX_ECC_ER         ; break;                              \
+    case e_FM_MAC_EX_10G_TX_FIFO_UNFL:                                           \
+        bitMask = IMASK_TX_FIFO_UNFL       ; break;                              \
+    case e_FM_MAC_EX_10G_TX_FIFO_OVFL:                                           \
+        bitMask = IMASK_TX_FIFO_OVFL       ; break;                              \
+    case e_FM_MAC_EX_10G_TX_ER:                                                  \
+        bitMask = IMASK_TX_ER              ; break;                              \
+    case e_FM_MAC_EX_10G_RX_FIFO_OVFL:                                           \
+        bitMask = IMASK_RX_FIFO_OVFL       ; break;                              \
+    case e_FM_MAC_EX_10G_RX_ECC_ER:                                              \
+        bitMask = IMASK_RX_ECC_ER          ; break;                              \
+    case e_FM_MAC_EX_10G_RX_JAB_FRM:                                             \
+        bitMask = IMASK_RX_JAB_FRM         ; break;                              \
+    case e_FM_MAC_EX_10G_RX_OVRSZ_FRM:                                           \
+        bitMask = IMASK_RX_OVRSZ_FRM       ; break;                              \
+    case e_FM_MAC_EX_10G_RX_RUNT_FRM:                                            \
+        bitMask = IMASK_RX_RUNT_FRM        ; break;                              \
+    case e_FM_MAC_EX_10G_RX_FRAG_FRM:                                            \
+        bitMask = IMASK_RX_FRAG_FRM        ; break;                              \
+    case e_FM_MAC_EX_10G_RX_LEN_ER:                                              \
+        bitMask = IMASK_RX_LEN_ER          ; break;                              \
+    case e_FM_MAC_EX_10G_RX_CRC_ER:                                              \
+        bitMask = IMASK_RX_CRC_ER          ; break;                              \
+    case e_FM_MAC_EX_10G_RX_ALIGN_ER:                                            \
+        bitMask = IMASK_RX_ALIGN_ER        ; break;                              \
+    default: bitMask = 0;break;}
+
 
 /* Default Config Params */
 #define DEFAULT_wanModeEnable               FALSE
@@ -60,7 +168,8 @@
 #define DEFAULT_rxErrorDiscard              FALSE
 #define DEFAULT_phyTxenaOn                  FALSE
 #define DEFAULT_sendIdleEnable              FALSE
-#define DEFAULT_noLengthCheckEnable         FALSE
+/* TODO - change it back to check length!!! */
+#define DEFAULT_noLengthCheckEnable         TRUE
 #define DEFAULT_lgthCheckNostdr             FALSE
 #define DEFAULT_timeStampEnable             FALSE
 #define DEFAULT_rxSfdAny                    FALSE
@@ -74,7 +183,42 @@
 
 #define DEFAULT_debugMode                   FALSE
 #define DEFAULT_pauseTime                   0xf000
-
+#define DEFAULT_imask                       0xf000
+
+#define DEFAULT_exceptions         ((uint32_t)(IMASK_MDIO_SCAN_EVENTMDIO |  \
+                                               IMASK_REM_FAULT           |  \
+                                               IMASK_LOC_FAULT           |  \
+                                               IMASK_1TX_ECC_ER          |  \
+                                               IMASK_TX_FIFO_UNFL        |  \
+                                               IMASK_TX_FIFO_OVFL        |  \
+                                               IMASK_TX_ER               |  \
+                                               IMASK_RX_FIFO_OVFL        |  \
+                                               IMASK_RX_ECC_ER           |  \
+                                               IMASK_RX_JAB_FRM          |  \
+                                               IMASK_RX_OVRSZ_FRM        |  \
+                                               IMASK_RX_RUNT_FRM         |  \
+                                               IMASK_RX_FRAG_FRM         |  \
+                                               IMASK_RX_LEN_ER           |  \
+                                               IMASK_RX_CRC_ER           |  \
+                                               IMASK_RX_ALIGN_ER))
+
+
+#define EVENTS_MASK         ((uint32_t)(IMASK_MDIO_SCAN_EVENTMDIO |  \
+                                        IMASK_REM_FAULT           |  \
+                                        IMASK_LOC_FAULT           |  \
+                                        IMASK_1TX_ECC_ER          |  \
+                                        IMASK_TX_FIFO_UNFL        |  \
+                                        IMASK_TX_FIFO_OVFL        |  \
+                                        IMASK_TX_ER               |  \
+                                        IMASK_RX_FIFO_OVFL        |  \
+                                        IMASK_RX_ECC_ER           |  \
+                                        IMASK_RX_JAB_FRM          |  \
+                                        IMASK_RX_OVRSZ_FRM        |  \
+                                        IMASK_RX_RUNT_FRM         |  \
+                                        IMASK_RX_FRAG_FRM         |  \
+                                        IMASK_RX_LEN_ER           |  \
+                                        IMASK_RX_CRC_ER           |  \
+                                        IMASK_RX_ALIGN_ER))
 
 #define MAX_PACKET_ALIGNMENT        31
 #define MAX_INTER_PACKET_GAP        0x7f
@@ -89,7 +233,7 @@
 
 #define HASH_TABLE_SIZE             512                 /* Hash table size (= 32 bits * 8 regs) */
 
-#define TGEC_TO_MII_OFFSET          0x1000              /* Offset from the MEM map to the MDIO mem map */
+#define TGEC_TO_MII_OFFSET          0x1030              /* Offset from the MEM map to the MDIO mem map */
 
 /* 10-gigabit Ethernet MAC Controller ID (10GEC_ID) */
 #define TGEC_ID_ID                  0xffff0000
@@ -195,95 +339,6 @@
 /* Transmit Inter-Packet Gap Length Register (TX_IPG_LENGTH) */
 #define TX_IPG_LENGTH_MASK          0x000003ff
 
-/* Interrupt Mask Register (IMASK) */
-#define IMASK_MDIO_SCAN_EVENTMDIO   0x00010000  /* MDIO_SCAN_EVENTMDIO scan event interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_MDIO_CMD_CMPL         0x00008000  /* 16 MDIO_CMD_CMPL MDIO command completion interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_REM_FAULT             0x00004000  /* 17 REM_FAULT Remote fault interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_LOC_FAULT             0x00002000  /* 18 LOC_FAULT Local fault interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_1TX_ECC_ER            0x00001000  /* 19 TX_ECC_ER Transmit frame ECC error interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_TX_FIFO_UNFL          0x00000800  /* 20 TX_FIFO_UNFL Transmit FIFO underflow interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_TX_FIFO_OVFL          0x00000400  /* 21 TX_FIFO_OVFL Transmit FIFO overflow interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_TX_ER                 0x00000200  /* 22 TX_ER Transmit frame error interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_RX_FIFO_OVFL          0x00000100  /* 23 RX_FIFO_OVFL Receive FIFO overflow interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_RX_ECC_ER             0x00000080  /* 24 RX_ECC_ER Receive frame ECC error interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_RX_JAB_FRM            0x00000040  /* 25 RX_JAB_FRM Receive jabber frame interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_RX_OVRSZ_FRM          0x00000020  /* 26 RX_OVRSZ_FRM Receive oversized frame interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_RX_RUNT_FRM           0x00000010  /* 27 RX_RUNT_FRM Receive runt frame interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_RX_FRAG_FRM           0x00000008  /* 28 RX_FRAG_FRM Receive fragment frame interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_RX_LEN_ER             0x00000004  /* 29 RX_LEN_ER Receive payload length error interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_RX_CRC_ER             0x00000002  /* 30 RX_CRC_ER Receive CRC error interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_RX_ALIGN_ER           0x00000001  /* 31 RX_ALIGN_ER Receive alignment error interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-
-#ifdef TBD
-#define IEVENT_MDIO_SCAN_EVENTMDIO  IMASK_MDIO_SCAN_EVENTMDIO
-#define IEVENT_MDIO_CMD_CMPL        IMASK_MDIO_CMD_CMPL
-#define IEVENT_REM_FAULT            IMASK_REM_FAULT
-#define IEVENT_LOC_FAULT            IMASK_LOC_FAULT
-#define IEVENT_TX_ECC_ER            IMASK_1TX_ECC_ER
-#define IEVENT_TX_FIFO_UNFL         IMASK_TX_FIFO_UNFL
-#define IEVENT_TX_FIFO_OVFL         IMASK_TX_FIFO_OVFL
-#define IEVENT_TX_ER                IMASK_TX_ER
-#define IEVENT_RX_FIFO_OVFL         IMASK_RX_FIFO_OVFL
-#define IEVENT_RX_ECC_ER            IMASK_RX_ECC_ER
-#define IEVENT_RX_JAB_FRM           IMASK_RX_JAB_FRM
-#define IEVENT_RX_OVRSZ_FRM         IMASK_RX_OVRSZ_FRM
-#define IEVENT_RX_RUNT_FRM          IMASK_RX_RUNT_FRM
-#define IEVENT_RX_FRAG_FRM          IMASK_RX_FRAG_FRM
-#define IEVENT_RX_LEN_ER            IMASK_RX_LEN_ER
-#define IEVENT_RX_CRC_ER            IMASK_RX_CRC_ER
-#define IEVENT_RX_ALIGN_ER          IMASK_RX_ALIGN_ER
-#endif
 
 
 #ifdef __MWERKS__
@@ -407,11 +462,9 @@ typedef struct {
     bool        padAndCrcEnable;
     bool        debugMode;
     uint16_t    pauseTime;
-
 #if 0
     uint32_t    imask;
 #endif
-
 } t_TgecDriverParam;
 
 typedef struct {
@@ -422,6 +475,8 @@ typedef struct {
     uint64_t                    addr;                               /**< MAC address of device; */
     e_EnetMode                  enetMode;                           /**< Ethernet physical interface  */
     t_FmMacExceptionCallback    *f_Exceptions;
+    int                         mdioIrq;
+    t_FmMacExceptionCallback    *f_Events;
     bool                        indAddrRegUsed[TGEC_NUM_OF_PADDRS]; /**< Whether a particular individual address recognition register is being used */
     uint64_t                    paddr[TGEC_NUM_OF_PADDRS];          /**< MAC address for particular individual address recognition register */
     uint8_t                     numOfIndAddrInRegs;                 /**< Number of individual addresses in registers for this station. */
@@ -429,9 +484,11 @@ typedef struct {
     t_EthHash                   *p_UnicastAddrHash;                 /**< pointer to driver's individual address hash table  */
     bool                        debugMode;
     uint8_t                     macId;
+    uint32_t                    exceptions;
     t_TgecDriverParam           *p_TgecDriverParam;
 } t_Tgec;
 
+
 t_Error TGEC_MII_WritePhyReg(t_Handle h_Tgec, uint8_t phyAddr, uint8_t reg, uint16_t data);
 t_Error TGEC_MII_ReadPhyReg(t_Handle h_Tgec,  uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
index 5ea63ff..97a23a8 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
@@ -39,10 +39,10 @@
 
 
 /*****************************************************************************/
-t_Error TGEC_MII_WritePhyReg(t_Handle h_Tgec,
-                        uint8_t     phyAddr,
-                        uint8_t     reg,
-                        uint16_t    data)
+t_Error TGEC_MII_WritePhyReg(t_Handle   h_Tgec,
+                             uint8_t    phyAddr,
+                             uint8_t    reg,
+                             uint16_t   data)
 {
     t_Tgec                  *p_Tgec = (t_Tgec *)h_Tgec;
     t_TgecMiiAccessMemMap   *p_MiiAccess;
@@ -67,14 +67,13 @@ t_Error TGEC_MII_WritePhyReg(t_Handle h_Tgec,
     return E_OK;
 }
 
-
 /*****************************************************************************/
 t_Error TGEC_MII_ReadPhyReg(t_Handle h_Tgec,
-                   uint8_t  phyAddr,
-                   uint8_t  reg,
-                   uint16_t *p_Data)
+                            uint8_t  phyAddr,
+                            uint8_t  reg,
+                            uint16_t *p_Data)
 {
-    t_Tgec             *p_Tgec = (t_Tgec *)h_Tgec;
+    t_Tgec                  *p_Tgec = (t_Tgec *)h_Tgec;
     t_TgecMiiAccessMemMap   *p_MiiAccess;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
@@ -99,5 +98,8 @@ t_Error TGEC_MII_ReadPhyReg(t_Handle h_Tgec,
 
     *p_Data =  (uint16_t)GET_UINT32(p_MiiAccess->mdio_data);
 
+    if (*p_Data == 0xffff)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Read wrong data (0xffff): phyAddr 0x%x, reg 0x%x", phyAddr, reg));
+
     return E_OK;
 }
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
index a7808c6..51b996a 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
@@ -30,10 +30,11 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifndef __MII_ACC_H
-#define __MII_ACC_H
+#ifndef __TGEC_MII_ACC_H
+#define __TGEC_MII_ACC_H
+
+#include "std_ext.h"
 
-/* #define __ERR_MODULE__ MODULE_MII */
 
 /* MII  Management Command Register */
 #define MIIMCOM_READ_POST_INCREMENT 0x00004000
@@ -45,6 +46,12 @@
 #define MIIMIND_BUSY                0x00000001
 #define MIIMIND_READ_ERROR          0x00000002
 
+
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+
 /*----------------------------------------------------*/
 /* MII Configuration Control Memory Map Registers     */
 /*----------------------------------------------------*/
@@ -56,5 +63,10 @@ typedef _Packed struct t_TgecMiiAccessMemMap
     volatile uint32_t   mdio_regaddr;       /* 0x03c  */
 } _PackedType t_TgecMiiAccessMemMap ;
 
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
 
-#endif /* __MII_ACC_H */
+#endif /* __TGEC_MII_ACC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
index 0bd6330..214d4c9 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
@@ -39,11 +39,10 @@
 #include "error_ext.h"
 #include "string_ext.h"
 #include "debug_ext.h"
-
 #include "fm_pcd_ext.h"
 #include "fm_muram_ext.h"
-#include "fm_hc.h"
 
+#include "fm_hc.h"
 #include "fm_pcd.h"
 
 
@@ -542,7 +541,7 @@ static void ReleaseTree(t_FmPcdCc *p_FmPcdCc, uint8_t treeId)
 static t_Error ValidateNextEngineParams(t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_NextEngineParamsInfo *p_NextEngineParamsInfo)
 {
     uint16_t                    absoluteProfileId;
-    t_Error                     err;
+    t_Error                     err = E_OK;
     uint8_t                     relativeSchemeId;
 
     p_NextEngineParamsInfo->fmPcdEngine = e_FM_PCD_DONE;
@@ -1101,7 +1100,7 @@ static t_Error ModifyCcCommon1(t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_Fm
 {
     t_FmPcdModifyCcAdditionalParams *p_CcOldModifyAdditionalParams;
     t_FmPcdModifyCcAdditionalParams *p_CcNewModifyAdditionalParams;
-    t_Error                         err;
+    t_Error                         err = E_OK;
     t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
     t_NextEngineParamsInfo          nextEngineParamsInfo;
 
@@ -1261,7 +1260,7 @@ static t_Error BuildNewNodeCommonPart(t_Handle *h_FmPcd, t_FmPcdCcNode *p_FmPcdC
 
 static t_Error BuildNewNodeAddKey(t_Handle h_FmPcd ,t_FmPcdCcNode *p_FmPcdCcNode, uint8_t keyIndex, t_FmPcdCcKeyParams  *p_KeyParams,t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
-    t_Error                 err;
+    t_Error                 err = E_OK;
     t_NextEngineParamsInfo  nextEngineParamsInfo;
     t_Handle                p_AdTableNewTmp, p_KeysMatchTableNewTmp;
     t_Handle                p_KeysMatchTableOldTmp, p_AdTableOldTmp;
@@ -1337,7 +1336,7 @@ static t_Error BuildNewNodeRemoveKey(t_Handle h_FmPcd  ,t_FmPcdCcNode *p_FmPcdCc
     t_Handle    p_AdTableNewTmp,p_KeysMatchTableNewTmp;
     t_Handle    p_KeysMatchTableOldTmp, p_AdTableOldTmp;
     int         size;
-    t_Error     err;
+    t_Error     err = E_OK;
 
     p_AdditionalInfo->numOfKeys = (uint16_t)(p_FmPcdCcNode->numOfKeys - 1);
 
@@ -1378,7 +1377,7 @@ static t_Error BuildNewNodeRemoveKey(t_Handle h_FmPcd  ,t_FmPcdCcNode *p_FmPcdCc
 
 static t_Error BuildNewNodeModifyKey(t_Handle h_FmPcd ,t_FmPcdCcNode *p_FmPcdCcNode, uint8_t keyIndex, uint8_t  *p_Key, uint8_t *p_Mask,t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
-    t_Error                 err;
+    t_Error                 err = E_OK;
     t_Handle                p_AdTableNewTmp, p_KeysMatchTableNewTmp;
     t_Handle                p_KeysMatchTableOldTmp, p_AdTableOldTmp;
     int                     size;
@@ -1439,7 +1438,7 @@ static t_Error BuildNewNodeModifyKey(t_Handle h_FmPcd ,t_FmPcdCcNode *p_FmPcdCcN
 
 static t_Error BuildNewNodeModifyKeyAndNextEngine(t_Handle h_FmPcd ,t_FmPcdCcNode *p_FmPcdCcNode, uint8_t keyIndex, t_FmPcdCcKeyParams  *p_KeyParams,t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
-    t_Error                 err;
+    t_Error                 err = E_OK;
     t_NextEngineParamsInfo nextEngineParamsInfo;
     t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
     t_Handle                p_AdTableNewTmp,p_KeysMatchTableNewTmp;
@@ -1618,7 +1617,7 @@ static t_Error ModifyKeyCommonPart1(t_FmPcdCcNode *p_FmPcdCcNode,  uint8_t keyIn
 t_Error FmPcdCcModifyNextEngineParamTree(t_Handle h_FmPcd, t_Handle h_FmPcdCcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_Handle *h_OldPointer, t_Handle *h_NewPointer)
 {
     t_FmPcdCcTree                   *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
-    t_Error                         err;
+    t_Error                         err = E_OK;
     t_FmPcdModifyCcAdditionalParams *p_CcOldModifyAdditionalParams;
     t_FmPcdModifyCcAdditionalParams *p_CcNewModifyAdditionalParams;
 
@@ -1653,7 +1652,7 @@ t_Error FmPcdCcModifyNextEngineParamTree(t_Handle h_FmPcd, t_Handle h_FmPcdCcTre
 static t_Error ModifyKeyCommonPart2(t_FmPcd *p_FmPcd, t_FmPcdCcNode *p_FmPcdCcNode, t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams ,t_List *h_OldLst, t_Handle *h_NewPointer)
 {
 
-    t_Error         err;
+    t_Error         err = E_OK;
     t_FmPcdCcNode   fmPcdCcNode;
 
     if(!LIST_IsEmpty(&p_FmPcdCcNode->ccPrevNodesLst))
@@ -1693,7 +1692,7 @@ t_Error FmPcdCcAddKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex
 {
     t_FmPcdCcNode                   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
     t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_Error                         err;
+    t_Error                         err = E_OK;
     t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams;
 
     err =  ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, &p_FmPcdModifyCcKeyAdditionalParams);
@@ -1729,7 +1728,7 @@ t_Error FmPcdCcRemoveKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIn
 
     t_FmPcdCcNode                   *p_FmPcdCcNode = (t_FmPcdCcNode *) h_FmPcdCcNode;
     t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_Error                         err;
+    t_Error                         err = E_OK;
     t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams;
 
 
@@ -1765,7 +1764,7 @@ t_Error FmPcdCcModifyKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIn
 {
     t_FmPcdCcNode                   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
     t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_Error                         err;
+    t_Error                         err = E_OK;
     t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams;
 
     err = ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, &p_FmPcdModifyCcKeyAdditionalParams);
@@ -1797,7 +1796,7 @@ t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdNode, ui
 {
     t_FmPcdCcNode                   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdNode;
     t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_Error                         err;
+    t_Error                         err = E_OK;
     t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams;
 
     err = ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, &p_FmPcdModifyCcKeyAdditionalParams);
@@ -1833,7 +1832,7 @@ t_Error FmPcdCcModiyNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode,
     t_FmPcdModifyCcAdditionalParams *p_CcOldModifyAdditionalParams;
     t_FmPcdModifyCcAdditionalParams *p_CcNewModifyAdditionalParams;
     t_FmPcdCcNode                   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
-    t_Error                         err;
+    t_Error                         err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_VALUE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNode,E_INVALID_HANDLE);
@@ -1863,7 +1862,7 @@ t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle h_FmPcd, t_Handle h_FmPcdC
     t_FmPcdModifyCcAdditionalParams *p_CcOldModifyAdditionalParams;
     t_FmPcdModifyCcAdditionalParams *p_CcNewModifyAdditionalParams;
     t_FmPcdCcNode                   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
-    t_Error                         err;
+    t_Error                         err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNode,E_INVALID_VALUE);
 
@@ -1885,7 +1884,7 @@ t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle h_FmPcd, t_Handle h_FmPcdC
 static t_Error UpdateNodesWithTree(t_Handle h_FmPcd,t_List *ccNextNodesLst, uint16_t *p_CcArray, uint8_t treeId)
 {
     t_List          *p_Pos;
-    t_Error         err;
+    t_Error         err = E_OK;
     t_FmPcdCcNode   *p_FmPcdCcNode;
     uint32_t        nodeIdTmp;
     if(!LIST_IsEmpty(ccNextNodesLst))
@@ -1912,7 +1911,7 @@ static t_Error UpdateNodesWithTree(t_Handle h_FmPcd,t_List *ccNextNodesLst, uint
 static t_Error RemoveNodesFromTree(t_Handle h_FmPcd,t_List *ccNextNodesLst, uint8_t treeId)
 {
     t_List          *p_Pos;
-    t_Error         err;
+    t_Error         err = E_OK;
     t_FmPcdCcNode   *p_FmPcdCcNode;
     uint32_t        nodeIdTmp;
     t_CcNodeInfo    *p_CcNodeInfo;
@@ -1948,7 +1947,7 @@ t_Error FmPcdCcReleaseModifiedOnlyNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdO
     t_FmPcdCcNode                   *p_CurrentNode=NULL, *p_NodeForAdd, *p_NodeForRemove;
     t_CcNodeInfo                    *p_CcNodeInfo, *p_CcNodeInfo1;
     uint16_t                         numOfReplec;
-    t_Error                          err;
+    t_Error                          err = E_OK;
     t_List                          *p_Pos;
     uint16_t                        ccArray[MAX_NUM_OF_PCD_CC_NODES];
 
@@ -2089,7 +2088,7 @@ t_Error FmPcdCcReleaseModifiedKey(t_Handle h_FmPcd, t_List *h_FmPcdOldPointersLs
     t_FmPcdCcNode                  *p_CurrentNode = NULL, *p_NodeForAdd, *p_NodeForRemove;
     uint32_t                        numOfReplec;
     t_List                          *p_Pos;
-    t_Error                         err;
+    t_Error                         err = E_OK;
     uint16_t                        ccArray[MAX_NUM_OF_PCD_CC_NODES];
 
     UNUSED(numOfGoodChanges);
@@ -2231,6 +2230,7 @@ t_Error     CcGetGrpParams(t_Handle h_FmPcdCcTree, uint8_t grpId, uint32_t *p_Gr
 {
     t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *) h_FmPcdCcTree;
 
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((grpId <= 7),E_INVALID_STATE);
 
     if(grpId >= p_FmPcdCcTree->numOfGrps)
@@ -2245,7 +2245,7 @@ t_Handle CcConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
     t_FmPcdCc           *p_FmPcdCc;
 #ifdef CONFIG_GUEST_PARTITION
     t_FmPcdIcPhysAddr   physicalMuramBase;
-    t_Error             err;
+    t_Error             err = E_OK;
 #else
     t_FmPhysAddr        physicalMuramBase;
 #endif /* CONFIG_GUEST_PARTITION */
@@ -2289,7 +2289,7 @@ t_Error  FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle  h_FmPcdCcTree,  uint32_t  *
 {
     t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
     t_FmPcdCcTree       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
-    t_Error             err;
+    t_Error             err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_STATE);
@@ -2317,7 +2317,7 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
 {
     t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
     t_FmPcdCc                   *p_FmPcdCc;
-    t_Error                     err;
+    t_Error                     err = E_OK;
     uint8_t                     treeId;
     int                         i = 0, j = 0, k = 0;
     t_FmPcdCcTree               *p_FmPcdCcTree;
@@ -2530,7 +2530,7 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
     t_FmPcd             *p_FmPcd = (t_FmPcd *) h_FmPcd;
     t_FmPcdCcNode       *p_FmPcdCcNode, *p_FmPcdCcNextNode;
     t_FmPcdCc           *p_FmPcdCc;
-    t_Error             err;
+    t_Error             err = E_OK;
     int                 tmp, size;
     bool                glblMask = FALSE;
     t_FmPcdCcKeyParams  *p_KeyParams;
@@ -2550,6 +2550,13 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
     SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE,NULL);
     SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdCc,E_INVALID_STATE,NULL);
 
+    if (!p_CcNodeParam->keysParams.keySize ||
+        !p_CcNodeParam->keysParams.numOfKeys)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("At least one key of keySize > 0 must be defined."));
+        return NULL;
+    }
+
     memset(profileInfo, 0x00, FM_PCD_PLCR_NUM_ENTRIES*sizeof(uint16_t));
     memset(ccInfo, 0x00, MAX_NUM_OF_PCD_CC_NODES*sizeof(uint16_t));
     memset(ccDifferentInfo, 0x00, MAX_NUM_OF_PCD_CC_NODES*sizeof(uint8_t));
@@ -2705,7 +2712,7 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
             {
                 ReleaseNode(p_FmPcdCc,nodeId);
                 ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
-                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("numOfKeys is not match defined parameters - p_Key is not initialized"));
+                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_Key is not initialized"));
                 return NULL;
             }
 
@@ -2935,6 +2942,7 @@ void FmPcdCcNodeTreeReleaseLock(t_Handle h_FmPcd, t_List *p_List)
         h_FmPcdCcTree = FmPcdCcGetTreeHandler(h_FmPcd, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
         FmPcdCcTreeReleaseLock(h_FmPcdCcTree);
     }
+    ReleaseLst(p_List);
 }
 
 t_Error FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *p_List)
@@ -2943,7 +2951,7 @@ t_Error FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *
     t_List          *p_Pos;
     t_CcNodeInfo    *p_CcNodeInfo;
     t_Handle        h_FmPcdCcTree;
-    t_Error         err;
+    t_Error         err = E_OK;
 
     if(LIST_IsEmpty(&p_FmPcdCcNode->ccTreesLst))
         RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("asked for more nodes in CC than MAX"))  ;
@@ -2955,11 +2963,7 @@ t_Error FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *
         if(err == E_OK)
             CreateNodeInfo(p_List, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
         else
-        {
             FmPcdCcNodeTreeReleaseLock(h_FmPcd, p_List);
-            ReleaseLst(p_List);
-
-        }
     }
 
     return err;
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
index 6e96b9f..ea7adc1 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
@@ -694,7 +694,7 @@ t_Handle FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgClsPlanGrpParams *p_G
     uint32_t                        walking1Mask, oredVectors = 0, lcvVector;
     uint8_t                         tmpEntryId;
     t_FmPcdKgClsPlanGrp             *p_ClsPlanGrp;
-    t_Error                         err;
+    t_Error                         err = E_OK;
     struct {
         protocolOpt_t   opt;
         uint32_t        vector;
@@ -1153,14 +1153,20 @@ void KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set)
 static void PcdKgErrorException(t_Handle h_FmPcd)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    uint32_t                event, schemeIndexes = 0,index = 0;
+    uint32_t                event, schemeIndexes = 0,index = 0, mask = 0;
 
     event = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeer);
-    event &= GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
+    mask = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
 
     schemeIndexes = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseer);
     schemeIndexes &= GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseeer);
 
+    /* clear the forced events */
+    if(GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer)& event)
+        WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, event & ~(event & mask));
+
+    event &= mask;
+
     WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeer, event);
     WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseer, schemeIndexes);
 
@@ -1194,7 +1200,7 @@ static t_Error KgWriteSp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t spRe
     {
         t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
         uint32_t                tmpKgarReg = 0, tmpKgpeSp;
-        t_Error                 err;
+        t_Error                 err = E_OK;
 
         p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
 
@@ -1252,7 +1258,7 @@ t_Error FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPort
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint32_t                spReg;
-    t_Error                 err;
+    t_Error                 err = E_OK;
 
     err = FmPcdKgBuildBindPortToSchemes(h_FmPcd, p_SchemeBind, &spReg, TRUE);
     if(err)
@@ -1271,7 +1277,7 @@ t_Error FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd ,  t_FmPcdKgInterModuleBindP
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint32_t                spReg;
-    t_Error                 err;
+    t_Error                 err = E_OK;
 
     err = FmPcdKgBuildBindPortToSchemes(h_FmPcd, p_SchemeBind, &spReg, FALSE);
     if(err)
@@ -1311,7 +1317,7 @@ bool KgSchemeIsValid(t_Handle h_FmPcd, uint8_t schemeId)
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint32_t    tmpReg;
     uint32_t    tmpKgarReg;
-    t_Error     err;
+    t_Error     err = E_OK;
 
     SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, FALSE);
     SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, FALSE);
@@ -1387,12 +1393,11 @@ t_Handle KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
 
 t_Error KgInit(t_FmPcd *p_FmPcd)
 {
-    t_Error                     err;
+    t_Error                     err = E_OK;
     t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
 #ifndef CONFIG_GUEST_PARTITION
     int                         i;
     t_FmPcdKgPortConfigRegs     *p_FmPcdKgPortRegs;
-    uint32_t                    tmpKgarReg;
     uint8_t                     hardwarePortId;
     uint8_t                     portsTable[] = PCD_PORTS_TABLE;
     uint32_t                    tmpReg;
@@ -1434,7 +1439,7 @@ t_Error KgInit(t_FmPcd *p_FmPcd)
     /**********************KGGCR******************/
 
     /* register even if no interrupts enabled, to allow future enablement */
-    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_EV_ERR_KG, PcdKgErrorException, p_FmPcd);
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_KG, 0, e_FM_INTR_TYPE_ERR, PcdKgErrorException, p_FmPcd);
 
     for(i=0;i<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;i++)
         p_FmPcd->p_FmPcdKg->clsPlanUsedBlocks[i] = FALSE;
@@ -1446,21 +1451,11 @@ t_Error KgInit(t_FmPcd *p_FmPcd)
 
         GET_GLOBAL_PORTID_FROM_PCD_PORTS_TABLE(hardwarePortId, portsTable,i);
 
-        WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_sp, 0x00000000);
-
-        tmpKgarReg = FmPcdKgBuildWritePortSchemeBindActionReg(hardwarePortId);
-
-        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-//        err = KgWriteSp(p_FmPcd, hardwarePortId, 0xffffffff, FALSE);
+        err = KgWriteSp(p_FmPcd, hardwarePortId, 0xffffffff, FALSE);
         if(err)
             RETURN_ERROR(MINOR, err, NO_MSG);
 
-        WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_cpp, 0x00000000);
-
-        tmpKgarReg = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
-
-        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-//        err = KgWriteCpp(p_FmPcd, hardwarePortId, 0);
+        err = KgWriteCpp(p_FmPcd, hardwarePortId, 0);
         if(err)
             RETURN_ERROR(MINOR, err, NO_MSG);
     }
@@ -1593,7 +1588,7 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
     uint8_t                             grpBase;
     bool                                direct=TRUE, absolute=FALSE;
     uint16_t                            profileId, numOfProfiles=0, relativeProfileId;
-    t_Error                             err;
+    t_Error                             err = E_OK;
     int                                 i = 0;
     t_NetEnvParams                      netEnvParams;
     uint32_t                            tmpReg, fqbTmp = 0, ppcTmp = 0, selectTmp, maskTmp, knownTmp, genTmp;
@@ -2416,7 +2411,7 @@ t_Error FM_PCD_KgSetEmptyClsPlanGrp(t_Handle h_FmPcd)
 t_Error FM_PCD_KgDeleteEmptyClsPlanGrp(t_Handle h_FmPcd)
 {
    t_FmPcd  *p_FmPcd = (t_FmPcd*)h_FmPcd;
-   t_Error  err;
+   t_Error  err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
@@ -2439,7 +2434,7 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
     uint8_t             hardwarePortId;
     uint32_t            tmpKgarReg;
     uint8_t             portsTable[] = PCD_PORTS_TABLE;
-    t_Error             err;
+    t_Error             err = E_OK;
 
     DECLARE_DUMP;
 
@@ -2541,7 +2536,7 @@ t_Handle FM_PCD_KgSetScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme)
     t_FmPcdKgInterModuleSchemeRegs      schemeRegs;
     t_FmPcdKgInterModuleSchemeRegs      *p_MemRegs;
     uint8_t                             i;
-    t_Error                             err;
+    t_Error                             err = E_OK;
     uint32_t                            tmpKgarReg;
     uint8_t                             physicalSchemeId, relativeSchemeId;
 #endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
@@ -2654,7 +2649,7 @@ t_Error  FM_PCD_KgDeleteScheme(t_Handle h_FmPcd, t_Handle h_Scheme)
 #ifndef CONFIG_MULTI_PARTITION_SUPPORT
     uint8_t             physicalSchemeId;
     uint32_t            tmpKgarReg;
-    t_Error             err;
+    t_Error             err = E_OK;
     uint8_t             relativeSchemeId;
 #endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
index 8af8a09..bc25565 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
@@ -83,7 +83,7 @@ t_Error  FmPcdHandleIpcMsg(t_Handle h_FmPcd, uint32_t msgId, uint8_t msgBody[MSG
 {
     t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint8_t                     schemeId;
-    t_Error                     err;
+    t_Error                     err = E_OK;
     t_FmPcdKgInterModuleClsPlanSet           clsPlanSet;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
@@ -273,14 +273,6 @@ uint32_t FmPcdGetLcv(t_Handle h_FmPcd, uint32_t netEnvId, uint8_t hdrNum)
     return p_FmPcd->netEnvs[netEnvId].lcvs[hdrNum];
 }
 
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-uint8_t FmPcdGetPartitionId(t_Handle h_FmPcd)
-{
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-
-    return p_FmPcd->partitionId;
-}
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 
 void FmPcdIncNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId)
 {
@@ -398,7 +390,7 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
     }
 
 #ifdef CONFIG_MULTI_PARTITION_SUPPORT
-    p_Pcd->partitionId                                      = p_FmPcdParams->partitionId;
+    p_Pcd->partitionId = FmGetPartitionId(p_Pcd->h_Fm);
 #endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 
 #ifndef CONFIG_GUEST_PARTITION
@@ -413,7 +405,7 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
 t_Error FM_PCD_Init(t_Handle h_FmPcd)
 {
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_Error     err;
+    t_Error     err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
@@ -475,7 +467,7 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd)
     t_FmPcdIpcKgAllocParams             kgAlloc;
 #endif /* CONFIG_GUEST_PARTITION */
 #ifdef CONFIG_MULTI_PARTITION_SUPPORT
-    t_Error                             err;
+    t_Error                             err = E_OK;
 #endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 
 
@@ -563,7 +555,7 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd)
 t_Error FM_PCD_Enable(t_Handle h_FmPcd)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_Error             err;
+    t_Error             err = E_OK;
 
 #ifndef CONFIG_GUEST_PARTITION
     if(p_FmPcd->p_FmPcdKg)
@@ -598,7 +590,7 @@ t_Error FM_PCD_Enable(t_Handle h_FmPcd)
 t_Error FM_PCD_Disable(t_Handle h_FmPcd)
 {
 /*    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;*/
-
+/* TODO - implement */
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 
     return E_OK;
@@ -1246,13 +1238,11 @@ t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception)
             if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_ILLEGAL_ACCESS))
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
             WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr, FM_PCD_PRS_ILLEGAL_ACCESS);
-            break;
+           break;
         case e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS:
             if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_PORT_ILLEGAL_ACCESS))
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr, /*FM_PCD_PRS_PORT_ILLEGAL_ACCESS*/0x80000000);
-            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr, /*FM_PCD_PRS_PORT_ILLEGAL_ACCESS*/0x00800000);
-            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr, FM_PCD_PRS_PORT_ILLEGAL_ACCESS);
+             WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr, FM_PCD_PRS_PORT_ILLEGAL_ACCESS);
             break;
         case e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC:
             if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_SINGLE_ECC))
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
index e8b1da0..3d0ab65 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
@@ -38,9 +38,7 @@
 #ifndef __FM_PCD_IPC_H
 #define __FM_PCD_IPC_H
 
-#include "error_ext.h"
 #include "std_ext.h"
-#include "net_ext.h"
 
 
 /**************************************************************************//**
@@ -73,9 +71,6 @@ typedef uint32_t fmPcdIpcEngines_t; /**< options as defined below: */
 #define FM_PCD_IPC_CC                   0x20000000          /**< Coarse classification indicated */
 #define FM_PCD_IPC_PLCR                 0x10000000          /**< Policer indicated */
 /* @} */
-/**************************************************************************//**
- @Description   struct for defining port PCD modes
-*//***************************************************************************/
 
 
 /**************************************************************************//**
@@ -94,15 +89,6 @@ typedef struct
     uint32_t                offset;                         /**< OUT. MURAM offset for the labeled code. */
 }t_FmPcdIpcSwPrsLable;
 
-/**************************************************************************//**
- @Description   Structure for port-PCD communication.
-                Fields commented 'IN' are passed by the port module to be used
-                by the FM module.
-                Fields commented 'OUT' will be filled by FM before returning to port.
-                Some fields are optional (depending on configuration) and
-                will be analized by the port and FM modules accordingly.
-*//***************************************************************************/
-
 
 /**************************************************************************//**
  @Description   Structure for port-PCD communication.
@@ -112,8 +98,6 @@ typedef struct
                 Some fields are optional (depending on configuration) and
                 will be analized by the port and FM modules accordingly.
 *//***************************************************************************/
-
-
 typedef struct
 {
     uint8_t     partitionId;                                /**< IN */
@@ -146,7 +130,7 @@ typedef _Packed struct t_FmPcdIcPhysAddr
 {
     volatile uint16_t high;
     volatile uint32_t low;
-}_PackedType t_FmPcdIcPhysAddr;
+} _PackedType t_FmPcdIcPhysAddr;
 
 #define MEM_MAP_END
 #ifdef __MWERKS__
@@ -163,6 +147,7 @@ typedef _Packed struct t_FmPcdIcPhysAddr
 
 *//***************************************************************************/
 #define FM_PCD_GET_SET_PORT_PARAMS              20
+
 /**************************************************************************//**
  @Function      FM_PCD_CLEAR_PORT_PARAMS
 
@@ -178,6 +163,7 @@ typedef _Packed struct t_FmPcdIcPhysAddr
 #define FM_PCD_ALLOC_PROFILES                   24
 #define FM_PCD_FREE_PROFILES                    25
 #define FM_PCD_GET_PHYS_MURAM_BASE              26
+
 /**************************************************************************//**
  @Function      FM_PCD_GET_SW_PRS_OFFSET
 
@@ -191,6 +177,7 @@ typedef _Packed struct t_FmPcdIcPhysAddr
 
 #define FM_PCD_ALLOC_SHARED_PROFILES            28
 #define FM_PCD_FREE_SHARED_PROFILES             29
+
 /**************************************************************************//**
  @Function      FM_PCD_GET_SET_KG_SCHEME_HC_PARAMS
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
index 51fcbad..ae4fd33 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
@@ -301,10 +301,15 @@ static void WritePar(t_FmPcd *p_FmPcd, uint32_t par)
 static void PcdPlcrException(t_Handle h_FmPcd)
 {
     t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    uint32_t event;
+    uint32_t event, mask;
 
     event = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_evr);
-    event &= GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier);
+    mask = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier);
+
+    /* clear forced events */
+    if(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr)& event)
+        WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr, event & ~(event & mask));
+    event &= mask;
 
     WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_evr, event);
 
@@ -320,10 +325,16 @@ static void PcdPlcrException(t_Handle h_FmPcd)
 static void PcdPlcrErrorException(t_Handle h_FmPcd)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    uint32_t            event, captureReg;
+    uint32_t            event, captureReg, mask;
 
     event = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eevr);
-    event &= GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier);
+    mask = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier);
+
+    /* clear forced events */
+    if(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr)& event)
+        WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr, event & ~(event & mask));
+
+    mask &= mask;
 
     WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eevr, event);
 
@@ -337,7 +348,7 @@ static void PcdPlcrErrorException(t_Handle h_FmPcd)
         p_UnInitCapt->portId = (uint8_t)((captureReg & PLCR_ERR_UNINIT_PID_MASK) >>PLCR_ERR_UNINIT_PID_SHIFT) ;
         p_UnInitCapt->absolute = (bool)(captureReg & PLCR_ERR_UNINIT_ABSOLUTE_MASK);*/
         p_FmPcd->f_FmPcdIndexedException(p_FmPcd->h_App,e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR,(uint16_t)(captureReg & PLCR_ERR_UNINIT_NUM_MASK));
-        //WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_upcr, PLCR_ERR_UNINIT_CAP);
+        WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_upcr, PLCR_ERR_UNINIT_CAP);
     }
 }
 
@@ -349,7 +360,7 @@ t_Error  FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16
 #ifdef CONFIG_GUEST_PARTITION
     t_FmPcdIpcPlcrAllocParams   ipcPlcrParams;
 #endif /* CONFIG_GUEST_PARTITION */
-    t_Error                     err;
+    t_Error                     err = E_OK;
     uint16_t                    base;
     uint16_t                    pcdPortId;
     uint8_t                     portsTable[]        = PCD_PORTS_TABLE;
@@ -385,7 +396,7 @@ t_Error  FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
 #ifdef CONFIG_GUEST_PARTITION
     t_FmPcdIpcPlcrAllocParams   ipcPlcrParams;
 #endif /* CONFIG_GUEST_PARTITION */
-    t_Error                     err;
+    t_Error                     err = E_OK;
     uint16_t                    pcdPortId;
     uint8_t                     portsTable[]        = PCD_PORTS_TABLE;
 
@@ -588,7 +599,7 @@ t_Error FmPcdPlcrBuildProfile(t_Handle h_FmPcd, t_FmPcdPlcrProfileParams *p_Prof
 {
 
     t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
-    t_Error err;
+    t_Error         err = E_OK;
     uint32_t        pemode, gnia, ynia, rnia;
 
 /* Set G, Y, R Nia */
@@ -825,7 +836,7 @@ t_Error PlcrInit(t_FmPcd *p_FmPcd)
     t_FmPcdDriverParam          *p_Param = p_FmPcd->p_FmPcdDriverParam;
     t_FmPcdPlcr                 *p_FmPcdPlcr = p_FmPcd->p_FmPcdPlcr;
     uint32_t                    tmpReg32 = 0;
-    t_Error                     err;
+    t_Error                     err = E_OK;
 #ifndef CONFIG_GUEST_PARTITION
     t_FmPcdPlcrRegs             *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
 #else
@@ -886,8 +897,8 @@ t_Error PlcrInit(t_FmPcd *p_FmPcd)
     /**********************FMPL_IER******************/
 
     /* register even if no interrupts enabled, to allow future enablement */
-    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_EV_ERR_PLCR, PcdPlcrErrorException, p_FmPcd);
-    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_EV_PLCR, PcdPlcrException, p_FmPcd);
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_ERR, PcdPlcrErrorException, p_FmPcd);
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_NORMAL, PcdPlcrException, p_FmPcd);
 
     /* driver initializes one DFLT profile at the last entry*/
     p_FmPcd->p_FmPcdPlcr->profiles[FM_PCD_PLCR_NUM_ENTRIES-1].profilesMng.allocated = TRUE;
@@ -1045,7 +1056,7 @@ t_Handle FM_PCD_PlcrSetProfile(t_Handle     h_FmPcd,
     t_FmPcdPlcrRegs                     *p_FmPcdPlcrRegs    = p_FmPcdPlcr->p_FmPcdPlcrRegs;
     t_FmPcdPlcrInterModuleProfileRegs   plcrProfileReg;
     uint16_t                            absoluteProfileId;
-    t_Error                             err;
+    t_Error                             err = E_OK;
     uint32_t                            tmpReg32;
 #endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
index 893f877..7e96bd2 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
@@ -81,11 +81,16 @@ t_Handle PrsConfig(t_FmPcd *p_FmPcd,t_FmPcdParams *p_FmPcdParams)
 static void PcdPrsErrorException(t_Handle h_FmPcd)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    uint32_t                event;
+    uint32_t                event, mask;
 
     event = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perr);
-    event &= GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer);
+    mask = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer);
 
+    /* clear the forced events */
+    if(GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr)& event)
+        WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr,  event & ~(event & mask));
+
+    event &= mask;
     WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perr, event);
 
     DBG(TRACE, ("parser error - 0x%08x\n",event));
@@ -95,7 +100,7 @@ static void PcdPrsErrorException(t_Handle h_FmPcd)
     if(event & FM_PCD_PRS_ILLEGAL_ACCESS)
         p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS);
     if(event & FM_PCD_PRS_PORT_ILLEGAL_ACCESS)
-//#warning - change to indexed? how?
+/* TODO - change to indexed? how? */
         p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS);
 }
 
@@ -111,6 +116,9 @@ static void PcdPrsException(t_Handle h_FmPcd)
 
     DBG(TRACE, ("parser event - 0x%08x\n",event));
 
+    if(GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevfr)& event)
+        WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevfr, ~event);
+
     WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevr, event);
 
     p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC);
@@ -140,20 +148,42 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
 {
     t_FmPcdDriverParam  *p_Param = p_FmPcd->p_FmPcdDriverParam;
     t_FmPcdPrsRegs      *p_Regs = p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
-    uint32_t            i, j;
-    uint32_t            tmpReg;
+    uint32_t            i, j, tmpReg;
+#ifdef FM_PRS_MEM_ERRATA
+    uint32_t            regsToGlobalOffset = 0x840;
+    uint32_t            firstPortToGlobalOffset = 0x45800;
+    uint32_t            globalAddr = (uint32_t)p_Regs - regsToGlobalOffset;
+    uint32_t            firstPortAddr = globalAddr - firstPortToGlobalOffset;
+    uint32_t            portSize = 0x1000;
+#endif   /* FM_PRS_MEM_ERRATA */
     uint8_t             swPrsL4Patch[] = SW_PRS_L4_PATCH;
 
+#ifdef FM_PRS_MEM_ERRATA
+    /* clear all parser memory */
+    for(i = 0;i<0x1000;i+=4)
+        WRITE_UINT32(*(uint32_t*)(globalAddr+i), 0x00000000);
+    for(i = 0;i<16;i++)
+    {
+        for(j = 0;j<0x3F8;j+=4)
+            WRITE_UINT32(*(uint32_t*)(firstPortAddr+i*portSize+j), 0x00000000);
+        /* disable all ports parser*/
+        WRITE_UINT32(*(uint32_t*)(firstPortAddr+i*portSize+0x3F8), 0x00000001);
+        /* wait for parser to be in idle state */
+        while(GET_UINT32(*(uint32_t*)(firstPortAddr+i*portSize+0x3F8)) & 0x00000100) ;
+/* TODO - ask Liat */
+        WRITE_UINT32(*(uint32_t*)(firstPortAddr+i*portSize+0x3FC), 0x91009100);
+    }
+#endif   /* FM_PRS_MEM_ERRATA */
+
     /**********************RPCLIM******************/
-    /*TODO - what default value to put*/
     WRITE_UINT32(p_Regs->rpclim, (uint32_t)p_Param->prsMaxParseCycleLimit);
     /**********************FMPL_RPCLIM******************/
 
     /* register even if no interrupts enabled, to allow future enablement */
-    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_EV_ERR_PRS, PcdPrsErrorException, p_FmPcd);
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PRS, 0, e_FM_INTR_TYPE_ERR, PcdPrsErrorException, p_FmPcd);
 
     /* register even if no interrupts enabled, to allow future enablement */
-    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_EV_PRS, PcdPrsException, p_FmPcd);
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PRS, 0, e_FM_INTR_TYPE_NORMAL, PcdPrsException, p_FmPcd);
 
     /**********************PEVR******************/
     WRITE_UINT32(p_Regs->pevr, (FM_PCD_PRS_SINGLE_ECC | FM_PCD_PRS_PORT_IDLE_STS) );
@@ -249,7 +279,7 @@ void FmPcdPrsIncludePortInStatistics(t_Handle h_FmPcd, uint8_t hardwarePortId, b
 uint32_t FmPcdGetSwPrsOffset(t_Handle h_FmPcd, e_NetHeaderType hdr, uint8_t indexPerHdr)
 {
 #ifdef CONFIG_GUEST_PARTITION
-    t_Error                 err;
+    t_Error                 err = E_OK;
     t_FmPcdIpcSwPrsLable    labelParams;
 
     labelParams.hdr = hdr;
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
index 3670a6f..0142d26 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
@@ -52,7 +52,7 @@
 static t_Error CheckInitParameters(t_FmPort *p_FmPort)
 {
     t_FmPortDriverParam *p_Params = p_FmPort->p_FmPortDriverParam;
-    t_Error             ans;
+    t_Error             ans = E_OK;
     uint8_t             i;
     uint32_t            unusedMask;
 
@@ -1653,7 +1653,7 @@ void          FmPortPcdKgSwUnbindClsPlanGrp (t_Handle h_FmPort)
 t_Error          FmPortPcdKgSwBindClsPlanGrp (t_Handle h_FmPort, bool useClsPlan, uint8_t newClsPlanGrpId)
 {
     t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error         err;
+    t_Error         err = E_OK;
 
     if(useClsPlan)
     {
@@ -2257,7 +2257,7 @@ t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold)
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigRxPriElevationLevel(t_Handle h_FmPort, uint32_t priElevationLevel)
+t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priElevationLevel)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
@@ -2575,7 +2575,9 @@ void FM_PORT_Disable(t_Handle h_FmPort)
 
     /* Disable BMI */
     WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) & ~BMI_PORT_CFG_EN);
+#ifndef BUP_FM_PORT_DISABLE_ERRATA
     while(GET_UINT32(*p_BmiStatusReg) & BMI_PORT_STATUS_BSY) ;
+#endif /* !BUP_FM_PORT_DISABLE_ERRATA */
 }
 
 void FM_PORT_Enable(t_Handle h_FmPort)
@@ -2606,7 +2608,6 @@ void FM_PORT_Enable(t_Handle h_FmPort)
             break;
     }
 
-
     /* Enable QMI */
     if (!rxPort && !p_FmPort->imEn)
         WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc,
@@ -2625,7 +2626,6 @@ t_Error FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable)
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     tmpReg = GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc);
-
     if(enable)
         tmpReg |= QMI_PORT_CFG_EN_COUNTERS ;
     else
@@ -3092,7 +3092,7 @@ t_Error FM_PORT_ReleaseStalled(t_Handle h_FmPort)
 t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles)
 {
     t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error                     err;
+    t_Error                     err = E_OK;
 
     p_FmPort->h_FmPcd = FmGetPcdHandle(p_FmPort->h_Fm);
     ASSERT_COND(p_FmPort->h_FmPcd);
@@ -3109,7 +3109,7 @@ t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles)
 t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort)
 {
     t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error                     err;
+    t_Error                     err = E_OK;
 
     err = FmPcdPlcrFreeProfiles(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId);
     if(err)
@@ -3243,7 +3243,7 @@ t_Error          FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
     t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
     uint32_t                            ccTreePhysOffset;
     volatile uint32_t                   *p_BmiCcBase=NULL;
-    t_Error                             err;
+    t_Error                             err = E_OK;
     volatile uint32_t                   *p_BmiNia=NULL;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_VALUE);
@@ -3307,7 +3307,7 @@ t_Error FM_PORT_AttachPCD(t_Handle h_FmPort)
 {
 
     t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error         err;
+    t_Error         err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
@@ -3461,7 +3461,7 @@ t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
 t_Error FM_PORT_PcdKgModifyClsPlanGrp (t_Handle h_FmPort, bool useClsPlan, t_Handle h_NewClsPlanGrp)
 {
     t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error             err;
+    t_Error             err = E_OK;
     uint32_t            tmpHxs[FM_PCD_PRS_NUM_OF_HDRS];
     int                 i = 0;
     uint8_t             hdrNum;
@@ -3614,7 +3614,7 @@ t_Error  FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *
 {
     t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
     t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
-    t_Error                                 err;
+    t_Error                                 err = E_OK;
     uint32_t                                tmpScmVec=0;
     int                                     i;
 
@@ -3645,7 +3645,7 @@ t_Error FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams
 {
     t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
     t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
-    t_Error                                 err;
+    t_Error                                 err = E_OK;
     uint32_t                                tmpScmVec=0;
     int                                     i;
 
@@ -3722,7 +3722,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
 {
     t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
     t_FmPortQmiRegs *p_FmPortQmiRegs;
-    t_Error         err;
+    t_Error         err = E_OK;
     char            arr[30];
     uint8_t         flag;
     int             i=0;
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
index 3192d41..1563480 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
@@ -84,7 +84,11 @@
 #define DEFAULT_PORT_l4Checksum                         TRUE
 #define DEFAULT_PORT_BufMargins_startMargins            32
 #define DEFAULT_PORT_BufMargins_endMargins              0
+#ifdef FM_PORT_SYNC_ERRATA
+#define DEFAULT_PORT_syncReq                            FALSE
+#else
 #define DEFAULT_PORT_syncReq                            TRUE
+#endif /* FM_PORT_SYNC_ERRATA */
 #define DEFAULT_PORT_color                              e_FM_PORT_COLOR_GREEN
 #define DEFAULT_PORT_errorsToDiscard                    0
 
@@ -344,7 +348,7 @@ typedef _Packed struct
     volatile uint8_t    reserved0[0x10];    /**< 0x10 - 0x1f */
     t_FmPortImQd        rxQd;
     t_FmPortImQd        txQd;
-    volatile uint8_t    reserved1[0xa0];    /**< 0x10 - 0x1f */
+    volatile uint8_t    reserved1[0xa0];    /**< 0x60 - 0xff */
 } _PackedType t_FmPortImPram;
 
 #define MEM_MAP_END
@@ -756,7 +760,7 @@ t_Error FmPortImRx  (t_FmPort *p_FmPort);
 
 static __inline__ uint8_t * BD_BUFFER (t_FmImBd *p_Bd)
 {
-//#warning complete
+/* TODO - complete */
     return XX_PhysToVirt(CAST_UINT32_TO_POINTER(GET_UINT32(p_Bd->buff.low)));
 }
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
index 3108611..0ca83d7 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
@@ -198,7 +198,7 @@ t_Error FmPortImRx(t_FmPort *p_FmPort)
 
         BD_STATUS_AND_LENGTH_SET(BD_GET(p_FmPort->im.currBdId), BD_R_E);
 
-//#warning "add here support for errors!!!"
+/* TODO - add here support for errors!!! */
         errors = (uint16_t)((bdStatus & BD_RX_ERRORS) >> 16);
 #if 0
         /* find out which errors the user wants reported. The BD will
@@ -211,29 +211,31 @@ t_Error FmPortImRx(t_FmPort *p_FmPort)
         }
 #endif /* 0 */
 
+        p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId] = h_NewUserPriv;
+
+        p_FmPort->im.currBdId = GetNextBdId(p_FmPort, p_FmPort->im.currBdId);
+        MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.offsetOut, (uint16_t)(p_FmPort->im.currBdId<<4));
+
         /* Pass the buffer if one of the conditions is true:
         - There are no errors
         - This is a part of a larger frame ( the application has already received some buffers )
         - There is an error, but it was defined to be passed anyway. */
         if ((buffPos != SINGLE_BUF) || !errors || (errors & (uint16_t)(BD_ERROR_PASS_FRAME>>16)))
         {
-            p_FmPort->im.f_RxStoreCB(p_FmPort->im.h_App,
-                                     p_CurData,
-                                     length,
-                                     errors,
-                                     buffPos,
-                                     h_CurrUserPriv);
+            if (p_FmPort->im.f_RxStoreCB(p_FmPort->im.h_App,
+                                         p_CurData,
+                                         length,
+                                         errors,
+                                         buffPos,
+                                         h_CurrUserPriv) == e_RX_STORE_RESPONSE_PAUSE)
+                break;
         }
         else if (p_FmPort->im.rxPool.f_PutBuf(p_FmPort->im.rxPool.h_BufferPool,
                                               p_CurData,
                                               h_CurrUserPriv))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Failed freeing data buffer"));
 
-        p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId] = h_NewUserPriv;
-
-        p_FmPort->im.currBdId = GetNextBdId(p_FmPort, p_FmPort->im.currBdId);
         bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
-        MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.offsetOut, (uint16_t)(p_FmPort->im.currBdId<<4));
     }
 
     return E_OK;
@@ -293,11 +295,11 @@ t_Error FmPortImCheckInitParameters(t_FmPort *p_FmPort)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("max Rx buffer length must at least 256!!!"));
         if(p_FmPort->p_FmPortDriverParam->partitionId >= FM_MAX_NUM_OF_PARTITIONS)
              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("partitionId can't be larger than %d", FM_MAX_NUM_OF_PARTITIONS-1));
-//#warning "add checks"
+/* TODO - add checks */
     }
     else
     {
-//#warning "add checks"
+/* TODO - add checks */
     }
 
     return E_OK;
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c
index 177fc6d..8b6be4f 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c
@@ -42,6 +42,7 @@
 #include "sprint_ext.h"
 #include "debug_ext.h"
 #include "fm_muram_ext.h"
+
 #include "fm_common.h"
 #ifdef FM_MASTER_PARTITION
 #include "fm_ipc.h"
@@ -60,10 +61,8 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
     uint8_t     i;
 
     if(p_Fm->p_FmDriverParam->enTimeStamp)
-    {
         if(!p_Fm->timeStampPeriod)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("timeStampPeriod may not be 0"));
-    }
     if(!p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats || (p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats > DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("axiDbgNumOfBeats has to be in the range 1 - %d", DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS));
     if(p_Fm->p_FmDriverParam->dmaCamNumOfEntries % DMA_CAM_UNITS)
@@ -117,6 +116,28 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
     return E_OK;
 }
 
+#ifdef FM_MASTER_PARTITION
+static void SendIpcIsr(t_Fm *p_Fm, uint32_t macEvent, uint32_t pendingReg)
+{
+    char        moduleName[MODULE_NAME_SIZE];
+    t_Error     err;
+    t_FmIpcIsr  fmIpcIsr;
+
+    if (p_Fm->partitionId != p_Fm->intrMng[macEvent].partitionId)
+    {
+        memset(moduleName, 0, MODULE_NAME_SIZE);
+        if(Sprint (moduleName, "FM-%d-%d",p_Fm->fmId, p_Fm->intrMng[macEvent].partitionId) != 6)
+        fmIpcIsr.pendingReg = pendingReg;
+        fmIpcIsr.err = FALSE;
+        err = XX_SendMessage(moduleName, FM_GUEST_ISR, (uint8_t*)&fmIpcIsr, NULL, NULL);
+        if(err)
+            REPORT_ERROR(MINOR, err, NO_MSG);
+    }
+    else
+        p_Fm->intrMng[macEvent].f_Isr(p_Fm->intrMng[macEvent].h_SrcHandle);
+}
+#endif /*FM_MASTER_PARTITION */
+
 static uint8_t  GetPartition(t_Fm *p_Fm, uint16_t liodn)
 {
     int         i;
@@ -140,7 +161,13 @@ static void    BmiErrEvent(t_Fm *p_Fm)
 
     event = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr);
     mask = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
+
+    /* clear the forced events */
+    if(GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr)& event)
+        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, event & ~(event & mask));
+
     event &= mask;
+
     /* clear the acknowledged events */
     WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr, event);
 
@@ -158,7 +185,12 @@ static void    QmiErrEvent(t_Fm *p_Fm)
 
     event = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eie);
     mask = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien);
+    /* clear the forced events */
+    if(GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif)& event)
+        WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif, event & ~(event & mask));
+
     event &= mask;
+
     /* clear the acknowledged events */
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eie, event);
 
@@ -218,6 +250,7 @@ static void    FpmErrEvent(t_Fm *p_Fm)
     uint32_t    event;
 
     event = GET_UINT32(p_Fm->p_FmFpmRegs->fpmem);
+
     /* clear the all occured events */
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, event);
 
@@ -231,31 +264,47 @@ static void    FpmErrEvent(t_Fm *p_Fm)
 
 static void    MuramErrIntr(t_Fm *p_Fm)
 {
-    uint32_t    event;
+    uint32_t    event, mask;
 
     event = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
+    mask = GET_UINT32(p_Fm->p_FmFpmRegs->fmeie);
 
     /* clear MURAM event bit */
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, event & ~FPM_RAM_CTL_IRAM_ECC);
 
+
     ASSERT_COND(event  & FPM_RAM_CTL_MURAM_ECC);
     ASSERT_COND(event  & FPM_RAM_CTL_RAMS_ECC_EN);
 
-    p_Fm->f_Exceptions(p_Fm->h_App, e_FM_EX_MURAM_ECC);
+    if ((mask & FPM_MURAM_ECC_ERR_EX_EN))
+        p_Fm->f_Exceptions(p_Fm->h_App, e_FM_EX_MURAM_ECC);
+
+#ifdef BUP_ERRATA_RAM_INTR
+    else
+        DBG(WARNING, ("MURAM masked Interrupt ..."));
+#endif /* BUP_ERRATA_RAM_INTR */
+
 }
 
 static void    IramErrIntr(t_Fm *p_Fm)
 {
-    uint32_t    event;
+    uint32_t    event, mask;
 
     event = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr) ;
+    mask = GET_UINT32(p_Fm->p_FmFpmRegs->fmeie);
     /* clear the acknowledged events (do not clear IRAM event) */
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, event & ~FPM_RAM_CTL_MURAM_ECC );
 
     ASSERT_COND(event  & FPM_RAM_CTL_IRAM_ECC);
     ASSERT_COND(event  & FPM_RAM_CTL_IRAM_ECC_EN);
 
-    p_Fm->f_Exceptions(p_Fm->h_App, e_FM_EX_IRAM_ECC);
+    if ((mask & FPM_IRAM_ECC_ERR_EX_EN))
+        p_Fm->f_Exceptions(p_Fm->h_App, e_FM_EX_IRAM_ECC);
+
+#ifdef BUP_ERRATA_RAM_INTR
+    else
+        DBG(WARNING, ("IRAM masked Interrupt ..."));
+#endif /* BUP_ERRATA_RAM_INTR */
 }
 
 static void     QmiEvent(t_Fm *p_Fm)
@@ -264,7 +313,12 @@ static void     QmiEvent(t_Fm *p_Fm)
 
     event = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie);
     mask = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien);
+    /* clear the forced events */
+    if(GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_if)& event)
+        WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_if,  event & ~(event & mask));
+
     event &= mask;
+
     /* clear the acknowledged events */
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie, event);
 
@@ -313,12 +367,19 @@ static void FmFreeInitResources(t_Fm *p_Fm)
        FM_MURAM_FreeMem(p_Fm->h_FmMuram, CAST_UINT64_TO_POINTER(p_Fm->fifoBaseAddr));
 }
 
-static void LoadPatch(t_Fm *p_Fm)
+static t_Error LoadUCode(t_Fm *p_Fm)
 {
     t_FMIramRegs    *p_Iram = CAST_UINT64_TO_POINTER_TYPE(t_FMIramRegs, (p_Fm->baseAddr + FM_MM_IMEM));
+    uint32_t        *p_Muram = CAST_UINT64_TO_POINTER_TYPE(uint32_t, (p_Fm->baseAddr + FM_MM_MURAM));
     int             i;
+    uint32_t        tmp;
+    uint8_t         compTo16;
 
-    SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    /* clear MURAM */
+    for (i=0; i < FM_MURAM_SIZE/4; i++)
+        WRITE_UINT32(*(p_Muram+i), 0);
 
     DBG(TRACE, ("Loading firmware to IRAM ..."));
 
@@ -329,12 +390,31 @@ static void LoadPatch(t_Fm *p_Fm)
     for (i=0; i < (p_Fm->p_FmDriverParam->firmware.size / 4); i++)
         WRITE_UINT32(p_Iram->idata, p_Fm->p_FmDriverParam->firmware.p_Code[i]);
 
+    compTo16 = p_Fm->p_FmDriverParam->firmware.size %16;
+    if(compTo16)
+        for (i=0; i < ((16-compTo16) / 4); i++)
+            WRITE_UINT32(p_Iram->idata, 0);
+
     WRITE_UINT32(p_Iram->iadd,0x0);
     /* verify that writing has completed */
     while (GET_UINT32(p_Iram->idata) != p_Fm->p_FmDriverParam->firmware.p_Code[0]) ;
 
+    if (p_Fm->p_FmDriverParam->fwVerify)
+    {
+        WRITE_UINT32(p_Iram->iadd, IRAM_IADD_AIE);
+        while (GET_UINT32(p_Iram->iadd) != IRAM_IADD_AIE) ;
+        for (i=0; i < (p_Fm->p_FmDriverParam->firmware.size / 4); i++)
+            if ((tmp=GET_UINT32(p_Iram->idata)) != p_Fm->p_FmDriverParam->firmware.p_Code[i])
+                RETURN_ERROR(MAJOR, E_WRITE_FAILED,
+                             ("UCode write error : write 0x%x, read 0x%x",
+                              p_Fm->p_FmDriverParam->firmware.p_Code[i],tmp));
+        WRITE_UINT32(p_Iram->iadd,0x0);
+    }
+
     /* Enable patch from IRAM */
     WRITE_UINT32(p_Iram->iready, IRAM_READY);
+
+    return E_OK;
 }
 
 /****************************************/
@@ -366,6 +446,9 @@ t_Error     FmHandleIpcMsg(t_Handle h_Fm, uint32_t msgId, uint8_t msgBody[MSG_BO
         case (FM_FREE_PORT):
             FmFreePortParams(h_Fm, (t_FmInterModulePortFreeParams*)msgBody);
             break;
+        case (FM_REGISTER_INTR):
+            p_Fm->intrMng[((t_FmIpcRegisterIntr*)msgBody)->event].partitionId = ((t_FmIpcRegisterIntr*)msgBody)->partitionId;
+            break;
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
         case (FM_DUMP_PORT_REGS):
             return FmDumpPortRegs(h_Fm, msgBody[0]);
@@ -428,12 +511,18 @@ t_Error FmGetPhysicalMuramBase(t_Handle h_Fm, t_FmPhysAddr *fmPhysAddr)
 
 
 void FmRegisterIntr(t_Handle h_Fm,
-                        e_FmInterModuleEvent   event,
+                        e_FmEventModules        module,
+                        uint8_t                 modId,
+                        e_FmIntrType            intrType,
                         void (*f_Isr) (t_Handle h_Arg),
                         t_Handle    h_Arg)
 {
     t_Fm       *p_Fm = (t_Fm*)h_Fm;
+    uint8_t     event= 0;
+
+    GET_MODULE_EVENT(module, modId,intrType, event);
 
+    ASSERT_COND(event != e_FM_EV_DUMMY_LAST);
     p_Fm->intrMng[event].f_Isr = f_Isr;
     p_Fm->intrMng[event].h_SrcHandle = h_Arg;
 }
@@ -553,7 +642,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
         p_Fm->extraOpenDmasPoolSize = p_PortParams->numOfExtraOpenDmas;
 
     if((p_Fm->accumulatedNumOfOpenDmas + p_PortParams->numOfOpenDmas) > p_Fm->maxNumOfOpenDmas)
-        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested numOfOpenDmas exceeds total numOfTasks."));
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested numOfOpenDmas exceeds total numOfOpenDmas."));
     else
     {
         p_Fm->accumulatedNumOfOpenDmas += p_PortParams->numOfOpenDmas;
@@ -768,6 +857,15 @@ bool FmRamsEccIsExternalCtl(t_Handle h_Fm)
         return FALSE;
 }
 
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+uint8_t FmGetPartitionId(t_Handle h_Fm)
+{
+    t_Fm     *p_Fm = (t_Fm*)h_Fm;
+
+    return p_Fm->partitionId;
+}
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 t_Error FmDumpPortRegs (t_Handle h_Fm,uint8_t hardwarePortId)
 {
@@ -906,10 +1004,11 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->p_FmDriverParam->enMuramTestMode                      = FALSE;
     p_Fm->p_FmDriverParam->externalEccRamsEnable                = DEFAULT_externalEccRamsEnable;
 
-     p_Fm->p_FmDriverParam->firmware.size = p_FmParam->firmware.size;
-     if (p_Fm->p_FmDriverParam->firmware.size)
-     {
-         p_Fm->p_FmDriverParam->firmware.p_Code = (uint32_t *)XX_Malloc(p_Fm->p_FmDriverParam->firmware.size);
+    p_Fm->p_FmDriverParam->fwVerify                             = DEFAULT_VerifyUcode;
+    p_Fm->p_FmDriverParam->firmware.size                        = p_FmParam->firmware.size;
+    if (p_Fm->p_FmDriverParam->firmware.size)
+    {
+        p_Fm->p_FmDriverParam->firmware.p_Code = (uint32_t *)XX_Malloc(p_Fm->p_FmDriverParam->firmware.size);
         if (!p_Fm->p_FmDriverParam->firmware.p_Code)
         {
             XX_Free(p_Fm->p_FmDriverParam);
@@ -918,19 +1017,19 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
             return NULL;
         }
          memcpy(p_Fm->p_FmDriverParam->firmware.p_Code ,p_FmParam->firmware.p_Code ,p_Fm->p_FmDriverParam->firmware.size);
-     }
+    }
 
-#ifdef CONFIG_GUEST_PARTITION
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
     /* register to inter-core messaging mechanism */
     memset(p_Fm->fmModuleName, 0, MODULE_NAME_SIZE);
-    if(Sprint (p_Fm->fmModuleName, "FM-%d",p_Fm->fmId) != 4)
+    if(Sprint (p_Fm->fmModuleName, "FM-%d-Master",p_Fm->fmId) != 11)
     {
         XX_Free(p_Fm->p_FmDriverParam);
         XX_Free(p_Fm);
         REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
         return NULL;
     }
-#endif /* CONFIG_GUEST_PARTITION */
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT  */
 
     return p_Fm;
 }
@@ -949,7 +1048,7 @@ t_Error FM_Init(t_Handle h_Fm)
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
     t_FmDriverParam         *p_FmDriverParam = NULL;
 #ifdef FM_MASTER_PARTITION
-    t_Error                 err;
+    t_Error                 err = E_OK;
 #endif /* FM_MASTER_PARTITION */
     uint32_t                tmpReg, cfgReg = 0;
     int                     i;
@@ -969,8 +1068,9 @@ t_Error FM_Init(t_Handle h_Fm)
     /**********************/
     /* Load patch to Iram */
     /**********************/
-    if (p_Fm->p_FmDriverParam->firmware.p_Code)
-        LoadPatch(p_Fm);
+    if (p_Fm->p_FmDriverParam->firmware.p_Code &&
+        (LoadUCode(p_Fm) != E_OK))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
     /* General FM driver initialization */
     p_Fm->fmMuramPhysBaseAddr = CAST_POINTER_TO_UINT64(XX_VirtToPhys(CAST_UINT64_TO_POINTER(p_Fm->baseAddr + FM_MM_MURAM)));
@@ -991,17 +1091,11 @@ t_Error FM_Init(t_Handle h_Fm)
     tmpReg = 0;
     tmpReg |= p_FmDriverParam->dmaCacheOverride << DMA_MODE_CACHE_OR_SHIFT;
     if(p_FmDriverParam->dmaAidOverride)
-    {
         tmpReg |= DMA_MODE_AID_OR;
-    }
     if (p_Fm->exceptions & FM_EX_DMA_BUS_ERROR)
-    {
         tmpReg |= DMA_MODE_BER;
-    }
     if ((p_Fm->exceptions & FM_EX_DMA_SYSTEM_WRITE_ECC) | (p_Fm->exceptions & FM_EX_DMA_READ_ECC) | (p_Fm->exceptions & FM_EX_DMA_FM_WRITE_ECC))
-    {
         tmpReg |= DMA_MODE_ECC;
-    }
     if(p_FmDriverParam->dmaStopOnBusError)
         tmpReg |= DMA_MODE_SBER;
     tmpReg |= (uint32_t)(p_FmDriverParam->dmaAxiDbgNumOfBeats - 1) << DMA_MODE_AXI_DBG_SHIFT;
@@ -1088,17 +1182,11 @@ t_Error FM_Init(t_Handle h_Fm)
     tmpReg |= (FPM_EV_MASK_STALL | FPM_EV_MASK_DOUBLE_ECC | FPM_EV_MASK_SINGLE_ECC);
     /* enable interrupts */
     if(p_Fm->exceptions & FM_EX_FPM_STALL_ON_TASKS)
-    {
         tmpReg |= FPM_EV_MASK_STALL_EN;
-    }
     if(p_Fm->exceptions & FM_EX_FPM_SINGLE_ECC)
-    {
         tmpReg |= FPM_EV_MASK_SINGLE_ECC_EN;
-    }
     if(p_Fm->exceptions & FM_EX_FPM_DOUBLE_ECC)
-    {
-        tmpReg |= FPM_EV_MASK_DOUBLE_ECC_EN ;
-    }
+        tmpReg |= FPM_EV_MASK_DOUBLE_ECC_EN;
     tmpReg |= (p_Fm->p_FmDriverParam->catastrophicErr  << FPM_EV_MASK_CAT_ERR_SHIFT);
     tmpReg |= (p_Fm->p_FmDriverParam->dmaErr << FPM_EV_MASK_DMA_ERR_SHIFT);
     if(!p_Fm->p_FmDriverParam->haltOnExternalActivation)
@@ -1149,9 +1237,9 @@ t_Error FM_Init(t_Handle h_Fm)
     /* RAM ECC -  enable and clear events*/
     /* first we need to clear all parser memory, as it is uninitialized and
     may cause ECC errors */
-    for(i=0;i<FM_SW_PRS_SIZE;i+=4)
+   /* for(i=0;i<FM_SW_PRS_SIZE;i+=4)
         WRITE_UINT32(*CAST_UINT64_TO_POINTER_TYPE(uint32_t, (p_Fm->baseAddr + FM_MM_PRS + i)), 0);
-
+*/
     tmpReg = 0;
     if(p_Fm->exceptions & FM_EX_IRAM_ECC)
     {
@@ -1260,13 +1348,13 @@ t_Error FM_Init(t_Handle h_Fm)
 
     if (p_Fm->irq != NO_IRQ)
     {
-        XX_SetIntr(p_Fm->irq, FM_Isr, p_Fm);
+        XX_SetIntr(p_Fm->irq, FM_EventIsr, p_Fm);
         XX_EnableIntr(p_Fm->irq);
     }
 
     if (p_Fm->errIrq != NO_IRQ)
     {
-        XX_SetIntr(p_Fm->errIrq, FM_Isr, p_Fm);
+        XX_SetIntr(p_Fm->errIrq, FM_ErrorIsr, p_Fm);
         XX_EnableIntr(p_Fm->errIrq);
     }
 
@@ -1732,7 +1820,98 @@ t_Handle FM_GetPcdHandle(t_Handle h_Fm)
     return ((t_Fm*)h_Fm)->h_Pcd;
 }
 
-void FM_Isr(t_Handle h_Fm)
+void FM_EventIsr(t_Handle h_Fm)
+{
+    t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+    uint32_t                pending;
+
+    SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
+
+    /* normal interrupts */
+    pending = GET_UINT32(p_Fm->p_FmFpmRegs->fmnpi);
+    ASSERT_COND(pending);
+    if(pending & INTR_EN_BMI)
+        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("BMI Event - undefined!"));
+    if(pending & INTR_EN_QMI)
+        QmiEvent(p_Fm);
+    if(pending & INTR_EN_PRS)
+        p_Fm->intrMng[e_FM_EV_PRS].f_Isr(p_Fm->intrMng[e_FM_EV_PRS].h_SrcHandle);
+    if(pending & INTR_EN_PLCR)
+        p_Fm->intrMng[e_FM_EV_PLCR].f_Isr(p_Fm->intrMng[e_FM_EV_PLCR].h_SrcHandle);
+    if(pending & INTR_EN_KG)
+        p_Fm->intrMng[e_FM_EV_KG].f_Isr(p_Fm->intrMng[e_FM_EV_KG].h_SrcHandle);
+    if(pending & FPM_EVENT_FM_CTL)
+        FmCtlEvent(p_Fm, pending  & FPM_EVENT_FM_CTL);
+    if(pending & INTR_EN_TMR)
+            p_Fm->intrMng[e_FM_EV_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_TMR].h_SrcHandle);
+
+    /* MAC events may belong to different partitions */
+    if(pending & INTR_EN_1G_MAC1)
+    {
+#ifdef FM_MASTER_PARTITION
+        if (p_Fm->partitionId != p_Fm->intrMng[e_FM_EV_1G_MAC1].partitionId)
+            SendIpcIsr(p_Fm, e_FM_EV_1G_MAC1, pending);
+        else
+#endif /* FM_MASTER_PARTITION */
+            p_Fm->intrMng[e_FM_EV_1G_MAC1].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC1].h_SrcHandle);
+    }
+    if(pending & INTR_EN_1G_MAC2)
+    {
+#ifdef FM_MASTER_PARTITION
+        if (p_Fm->partitionId != p_Fm->intrMng[e_FM_EV_1G_MAC2].partitionId)
+            SendIpcIsr(p_Fm, e_FM_EV_1G_MAC2, pending);
+        else
+#endif /* FM_MASTER_PARTITION */
+            p_Fm->intrMng[e_FM_EV_1G_MAC2].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC2].h_SrcHandle);
+    }
+    if(pending & INTR_EN_1G_MAC3)
+    {
+#ifdef FM_MASTER_PARTITION
+        if (p_Fm->partitionId != p_Fm->intrMng[e_FM_EV_1G_MAC3].partitionId)
+            SendIpcIsr(p_Fm, e_FM_EV_1G_MAC3, pending);
+        else
+#endif /* FM_MASTER_PARTITION */
+           p_Fm->intrMng[e_FM_EV_1G_MAC3].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC3].h_SrcHandle);
+    }
+    if(pending & INTR_EN_1G_MAC0_TMR)
+    {
+#ifdef FM_MASTER_PARTITION
+        if (p_Fm->partitionId != p_Fm->intrMng[e_FM_EV_1G_MAC0_TMR].partitionId)
+            SendIpcIsr(p_Fm, e_FM_EV_1G_MAC0_TMR, pending);
+        else
+#endif /* FM_MASTER_PARTITION */
+            p_Fm->intrMng[e_FM_EV_1G_MAC0_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC0_TMR].h_SrcHandle);
+    }
+    if(pending & INTR_EN_1G_MAC1_TMR)
+    {
+#ifdef FM_MASTER_PARTITION
+        if (p_Fm->partitionId != p_Fm->intrMng[e_FM_EV_1G_MAC1_TMR].partitionId)
+            SendIpcIsr(p_Fm, e_FM_EV_1G_MAC1_TMR, pending);
+        else
+#endif /* FM_MASTER_PARTITION */
+            p_Fm->intrMng[e_FM_EV_1G_MAC1_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC1_TMR].h_SrcHandle);
+    }
+    if(pending & INTR_EN_1G_MAC2_TMR)
+    {
+#ifdef FM_MASTER_PARTITION
+        if (p_Fm->partitionId != p_Fm->intrMng[e_FM_EV_1G_MAC2_TMR].partitionId)
+            SendIpcIsr(p_Fm, e_FM_EV_1G_MAC2_TMR, pending);
+        else
+#endif /* FM_MASTER_PARTITION */
+            p_Fm->intrMng[e_FM_EV_1G_MAC2_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC2_TMR].h_SrcHandle);
+    }
+    if(pending & INTR_EN_1G_MAC3_TMR)
+    {
+#ifdef FM_MASTER_PARTITION
+       if (p_Fm->partitionId != p_Fm->intrMng[e_FM_EV_1G_MAC3_TMR].partitionId)
+            SendIpcIsr(p_Fm, e_FM_EV_1G_MAC3_TMR, pending);
+        else
+#endif /* FM_MASTER_PARTITION */
+           p_Fm->intrMng[e_FM_EV_1G_MAC3_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC3_TMR].h_SrcHandle);
+    }
+}
+
+void FM_ErrorIsr(t_Handle h_Fm)
 {
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
     uint32_t                pending;
@@ -1741,70 +1920,74 @@ void FM_Isr(t_Handle h_Fm)
 
     /* error interrupts */
     pending = GET_UINT32(p_Fm->p_FmFpmRegs->fmepi);
-    if(pending) /* remove if separate sources */
-    {
-        if(pending & ERR_INTR_EN_BMI)
-            BmiErrEvent(p_Fm);
-        if(pending & ERR_INTR_EN_QMI)
-            QmiErrEvent(p_Fm);
-        if(pending & ERR_INTR_EN_FPM)
-            FpmErrEvent(p_Fm);
-        if(pending & ERR_INTR_EN_DMA)
-            DmaErrEvent(p_Fm);
-        if(pending & ERR_INTR_EN_IRAM)
-            IramErrIntr(p_Fm);
-        if(pending & ERR_INTR_EN_MURAM)
-            MuramErrIntr(p_Fm);
-        if(pending & ERR_INTR_EN_PRS)
-            p_Fm->intrMng[e_FM_EV_ERR_PRS].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_PRS].h_SrcHandle);
-        if(pending & ERR_INTR_EN_PLCR)
-            p_Fm->intrMng[e_FM_EV_ERR_PLCR].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_PLCR].h_SrcHandle);
-        if(pending & ERR_INTR_EN_KG)
-            p_Fm->intrMng[e_FM_EV_ERR_KG].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_KG].h_SrcHandle);
-        if(pending & ERR_INTR_EN_1G_MAC0)
+    if (!pending)
+        return;
+
+    if(pending & ERR_INTR_EN_BMI)
+        BmiErrEvent(p_Fm);
+    if(pending & ERR_INTR_EN_QMI)
+        QmiErrEvent(p_Fm);
+    if(pending & ERR_INTR_EN_FPM)
+        FpmErrEvent(p_Fm);
+    if(pending & ERR_INTR_EN_DMA)
+        DmaErrEvent(p_Fm);
+    if(pending & ERR_INTR_EN_IRAM)
+        IramErrIntr(p_Fm);
+    if(pending & ERR_INTR_EN_MURAM)
+        MuramErrIntr(p_Fm);
+    if(pending & ERR_INTR_EN_PRS)
+        p_Fm->intrMng[e_FM_EV_ERR_PRS].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_PRS].h_SrcHandle);
+    if(pending & ERR_INTR_EN_PLCR)
+        p_Fm->intrMng[e_FM_EV_ERR_PLCR].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_PLCR].h_SrcHandle);
+    if(pending & ERR_INTR_EN_KG)
+        p_Fm->intrMng[e_FM_EV_ERR_KG].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_KG].h_SrcHandle);
+
+    /* MAC events may belong to different partitions */
+    if(pending & ERR_INTR_EN_1G_MAC0)
+    {
+#ifdef FM_MASTER_PARTITION
+       if (p_Fm->partitionId != p_Fm->intrMng[e_FM_EV_ERR_1G_MAC0].partitionId)
+            SendIpcIsr(p_Fm, e_FM_EV_ERR_1G_MAC0, pending);
+        else
+#endif /* FM_MASTER_PARTITION */
             p_Fm->intrMng[e_FM_EV_ERR_1G_MAC0].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC0].h_SrcHandle);
-        if(pending & ERR_INTR_EN_1G_MAC1)
+    }
+    if(pending & ERR_INTR_EN_1G_MAC1)
+    {
+#ifdef FM_MASTER_PARTITION
+       if (p_Fm->partitionId != p_Fm->intrMng[e_FM_EV_ERR_1G_MAC1].partitionId)
+            SendIpcIsr(p_Fm, e_FM_EV_ERR_1G_MAC1, pending);
+        else
+#endif /* FM_MASTER_PARTITION */
             p_Fm->intrMng[e_FM_EV_ERR_1G_MAC1].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC1].h_SrcHandle);
-        if(pending & ERR_INTR_EN_1G_MAC2)
+    }
+    if(pending & ERR_INTR_EN_1G_MAC2)
+    {
+#ifdef FM_MASTER_PARTITION
+       if (p_Fm->partitionId != p_Fm->intrMng[e_FM_EV_ERR_1G_MAC2].partitionId)
+            SendIpcIsr(p_Fm, e_FM_EV_ERR_1G_MAC2, pending);
+        else
+#endif /* FM_MASTER_PARTITION */
             p_Fm->intrMng[e_FM_EV_ERR_1G_MAC2].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC2].h_SrcHandle);
-        if(pending & ERR_INTR_EN_1G_MAC3)
+    }
+    if(pending & ERR_INTR_EN_1G_MAC3)
+    {
+#ifdef FM_MASTER_PARTITION
+       if (p_Fm->partitionId != p_Fm->intrMng[e_FM_EV_ERR_1G_MAC3].partitionId)
+            SendIpcIsr(p_Fm, e_FM_EV_ERR_1G_MAC3, pending);
+        else
+#endif /* FM_MASTER_PARTITION */
             p_Fm->intrMng[e_FM_EV_ERR_1G_MAC3].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC3].h_SrcHandle);
-        if(pending & ERR_INTR_EN_10G_MAC0)
-            p_Fm->intrMng[e_FM_EV_ERR_10G_MAC0].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_10G_MAC0].h_SrcHandle);
     }
+    if(pending & ERR_INTR_EN_10G_MAC0)
+    {
+#ifdef FM_MASTER_PARTITION
+       if (p_Fm->partitionId != p_Fm->intrMng[e_FM_EV_ERR_10G_MAC0].partitionId)
+            SendIpcIsr(p_Fm, e_FM_EV_ERR_10G_MAC0, pending);
+        else
+#endif /* FM_MASTER_PARTITION */
+            p_Fm->intrMng[e_FM_EV_ERR_10G_MAC0].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_10G_MAC0].h_SrcHandle);
 
-    /* normal interrupts */
-    pending = GET_UINT32(p_Fm->p_FmFpmRegs->fmnpi);
-    if(pending) /* remove if separate sources */
-    {
-        if(pending & INTR_EN_BMI)
-            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("BMI Event - undefined!"));
-        if(pending & INTR_EN_QMI)
-            QmiEvent(p_Fm);
-        if(pending & INTR_EN_PRS)
-            p_Fm->intrMng[e_FM_EV_PRS].f_Isr(p_Fm->intrMng[e_FM_EV_PRS].h_SrcHandle);
-        if(pending & INTR_EN_PLCR)
-            p_Fm->intrMng[e_FM_EV_PLCR].f_Isr(p_Fm->intrMng[e_FM_EV_PLCR].h_SrcHandle);
-        if(pending & INTR_EN_KG)
-            p_Fm->intrMng[e_FM_EV_KG].f_Isr(p_Fm->intrMng[e_FM_EV_KG].h_SrcHandle);
-        if(pending & FPM_EVENT_FM_CTL)
-            FmCtlEvent(p_Fm, pending  & FPM_EVENT_FM_CTL);
-        if(pending & INTR_EN_1G_MAC1)
-            p_Fm->intrMng[e_FM_EV_1G_MAC1].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC1].h_SrcHandle);
-        if(pending & INTR_EN_1G_MAC2)
-            p_Fm->intrMng[e_FM_EV_1G_MAC2].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC2].h_SrcHandle);
-        if(pending & INTR_EN_1G_MAC3)
-            p_Fm->intrMng[e_FM_EV_1G_MAC3].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC3].h_SrcHandle);
-        if(pending & INTR_EN_1G_MAC0_TMR)
-            p_Fm->intrMng[e_FM_EV_1G_MAC0_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC0_TMR].h_SrcHandle);
-        if(pending & INTR_EN_1G_MAC1_TMR)
-            p_Fm->intrMng[e_FM_EV_1G_MAC1_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC1_TMR].h_SrcHandle);
-        if(pending & INTR_EN_1G_MAC2_TMR)
-            p_Fm->intrMng[e_FM_EV_1G_MAC2_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC2_TMR].h_SrcHandle);
-        if(pending & INTR_EN_1G_MAC3_TMR)
-            p_Fm->intrMng[e_FM_EV_1G_MAC3_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC3_TMR].h_SrcHandle);
-        if(pending & INTR_EN_TMR)
-            p_Fm->intrMng[e_FM_EV_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_TMR].h_SrcHandle);
     }
 }
 
@@ -2041,7 +2224,6 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                     /* enable ECC if not enabled */
                     if(!p_Fm->ramsEccEnable)
                     {
-
                         WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr) |
                                                                 (FPM_RAM_CTL_IRAM_ECC_EN | FPM_RAM_CTL_RAMS_ECC_EN));
                         p_Fm->ramsEccEnable = TRUE;
@@ -2050,7 +2232,8 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                     tmpReg |= FPM_IRAM_ECC_ERR_EX_EN;
                 }
                 else
-                    tmpReg &= FPM_IRAM_ECC_ERR_EX_EN;
+                    /* ECC mechanism will remain enabled, but interrupts disabled */
+                    tmpReg &= ~FPM_IRAM_ECC_ERR_EX_EN;
                 WRITE_UINT32(p_Fm->p_FmFpmRegs->fmeie, tmpReg);
                 break;
 
@@ -2065,13 +2248,13 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                     tmpReg |= FPM_MURAM_ECC_ERR_EX_EN;
                 }
                 else
-                    tmpReg &= FPM_MURAM_ECC_ERR_EX_EN;
-                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmeie, tmpReg);
+                    /* ECC mechanism will remain enabled, but interrupts disabled */
+                    tmpReg &= ~FPM_MURAM_ECC_ERR_EX_EN;
 
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmeie, tmpReg);
                 break;
             default:
                 RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
-
         }
     }
     else
@@ -2233,7 +2416,7 @@ t_Error  FM_SetCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val)
     return E_OK;
 }
 
-void FM_DmaEmergencyCtrl(t_Handle h_Fm, e_FmDmaMuramPort muramPort, bool enable)
+void FM_SetDmaEmergency(t_Handle h_Fm, e_FmDmaMuramPort muramPort, bool enable)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
     uint32_t    bitMask;
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h
index 6174fed..8817387 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h
@@ -100,58 +100,59 @@
 /**************************************************************************//**
  @Description       defaults
 *//***************************************************************************/
-#define DEFAULT_exceptions              (FM_EX_DMA_BUS_ERROR            |\
-                                        FM_EX_DMA_READ_ECC              |\
-                                        FM_EX_DMA_SYSTEM_WRITE_ECC      |\
-                                        FM_EX_DMA_FM_WRITE_ECC          |\
-                                        FM_EX_FPM_STALL_ON_TASKS        |\
-                                        FM_EX_FPM_SINGLE_ECC            |\
-                                        FM_EX_FPM_DOUBLE_ECC            |\
-                                        FM_EX_QMI_SINGLE_ECC            |\
-                                        FM_EX_QMI_DEQ_FROM_DEFQ         |\
-                                        FM_EX_QMI_DOUBLE_ECC            |\
-                                        FM_EX_BMI_LIST_RAM_ECC          |\
-                                        FM_EX_BMI_PIPELINE_ECC          |\
-                                        FM_EX_BMI_STATISTICS_RAM_ECC    |\
-                                        FM_EX_IRAM_ECC                  |\
-                                        FM_EX_NURAM_ECC                 )
-#define DEFAULT_totalNumOfTasks         96
-#define DEFAULT_totalFifoSize           (128*KILOBYTE)
-#define DEFAULT_maxNumOfOpenDmas      24
-#define DEFAULT_eccEnable               FALSE
-#define DEFAULT_dispLimit               16
-#define DEFAULT_prsDispTh               16
-#define DEFAULT_plcrDispTh              16
-#define DEFAULT_kgDispTh                16
-#define DEFAULT_bmiDispTh               16
-#define DEFAULT_qmiEnqDispTh            16
-#define DEFAULT_qmiDeqDispTh            16
-#define DEFAULT_fmCtl1DispTh             16
-#define DEFAULT_fmCtl2DispTh             16
-#define DEFAULT_cacheOverride           e_FM_DMA_NO_CACHE_OR
-#define DEFAULT_aidOverride             FALSE
-#define DEFAULT_aidMode                 e_FM_DMA_AID_OUT_PORT_ID
-#define DEFAULT_secureBusProtect        FALSE
-#define DEFAULT_privilegeBusProtect     FALSE
-#define DEFAULT_dmaStopOnBusError       FALSE
-#define DEFAULT_busProtectionType       e_FM_DMA_DATA_BUS_PROT
-#define DEFAULT_stopAtBusError          FALSE
-#define DEFAULT_axiDbgNumOfBeats        1
-#define DEFAULT_dmaCamNumOfEntries      32
-#define DEFAULT_dmaCommQLow             16
-#define DEFAULT_dmaCommQHigh            24
-#define DEFAULT_dmaReadIntBufLow        64
-#define DEFAULT_dmaReadIntBufHigh       96
-#define DEFAULT_dmaWriteIntBufLow       64
-#define DEFAULT_dmaWriteIntBufHigh      96
-#define DEFAULT_dmaSosEmergency         0
-#define DEFAULT_dmaDbgCntMode           e_FM_DMA_DBG_NO_CNT
-#define DEFAULT_catastrophicErr         e_FM_CATASTROPHIC_ERR_STALL_PORT
-#define DEFAULT_dmaErr                  e_FM_DMA_ERR_CATASTROPHIC
-#define DEFAULT_resetOnInit             FALSE
-#define DEFAULT_haltOnExternalActivation        FALSE
-#define DEFAULT_haltOnUnrecoverableEccError     FALSE
-#define DEFAULT_externalEccRamsEnable           FALSE
+#define DEFAULT_exceptions                  (FM_EX_DMA_BUS_ERROR            |\
+                                            FM_EX_DMA_READ_ECC              |\
+                                            FM_EX_DMA_SYSTEM_WRITE_ECC      |\
+                                            FM_EX_DMA_FM_WRITE_ECC          |\
+                                            FM_EX_FPM_STALL_ON_TASKS        |\
+                                            FM_EX_FPM_SINGLE_ECC            |\
+                                            FM_EX_FPM_DOUBLE_ECC            |\
+                                            FM_EX_QMI_SINGLE_ECC            |\
+                                            FM_EX_QMI_DEQ_FROM_DEFQ         |\
+                                            FM_EX_QMI_DOUBLE_ECC            |\
+                                            FM_EX_BMI_LIST_RAM_ECC          |\
+                                            FM_EX_BMI_PIPELINE_ECC          |\
+                                            FM_EX_BMI_STATISTICS_RAM_ECC    |\
+                                            FM_EX_IRAM_ECC                  |\
+                                            FM_EX_NURAM_ECC                 )
+#define DEFAULT_totalNumOfTasks             96
+#define DEFAULT_totalFifoSize               (128*KILOBYTE)
+#define DEFAULT_maxNumOfOpenDmas            24
+#define DEFAULT_eccEnable                   FALSE
+#define DEFAULT_dispLimit                   16
+#define DEFAULT_prsDispTh                   16
+#define DEFAULT_plcrDispTh                  16
+#define DEFAULT_kgDispTh                    16
+#define DEFAULT_bmiDispTh                   16
+#define DEFAULT_qmiEnqDispTh                16
+#define DEFAULT_qmiDeqDispTh                16
+#define DEFAULT_fmCtl1DispTh                16
+#define DEFAULT_fmCtl2DispTh                16
+#define DEFAULT_cacheOverride               e_FM_DMA_NO_CACHE_OR
+#define DEFAULT_aidOverride                 FALSE
+#define DEFAULT_aidMode                     e_FM_DMA_AID_OUT_PORT_ID
+#define DEFAULT_privilegeBusProtect         FALSE
+#define DEFAULT_dmaStopOnBusError           FALSE
+#define DEFAULT_busProtectionType           e_FM_DMA_DATA_BUS_PROT
+#define DEFAULT_stopAtBusError              FALSE
+#define DEFAULT_axiDbgNumOfBeats            1
+#define DEFAULT_dmaCamNumOfEntries          32
+#define DEFAULT_dmaCommQLow                 16
+#define DEFAULT_dmaCommQHigh                24
+#define DEFAULT_dmaReadIntBufLow            64
+#define DEFAULT_dmaReadIntBufHigh           96
+#define DEFAULT_dmaWriteIntBufLow           64
+#define DEFAULT_dmaWriteIntBufHigh          96
+#define DEFAULT_dmaSosEmergency             0
+#define DEFAULT_dmaDbgCntMode               e_FM_DMA_DBG_NO_CNT
+#define DEFAULT_catastrophicErr             e_FM_CATASTROPHIC_ERR_STALL_PORT
+#define DEFAULT_dmaErr                      e_FM_DMA_ERR_CATASTROPHIC
+#define DEFAULT_resetOnInit                 FALSE
+#define DEFAULT_haltOnExternalActivation    FALSE
+#define DEFAULT_haltOnUnrecoverableEccError FALSE
+#define DEFAULT_externalEccRamsEnable       FALSE
+#define DEFAULT_VerifyUcode                 FALSE
+
 /**************************************************************************//**
  @Description       Modules registers offsets
 *//***************************************************************************/
@@ -271,7 +272,6 @@ typedef _Packed struct
     }t_FmQmiDbgTraps[NUM_OF_DBG_TRAPS];
 } _PackedType t_FmQmiRegs;
 
-
 typedef _Packed struct
 {
     volatile uint32_t   fmdmsr;         /**<    FM DMA status register 0x04 */
@@ -304,10 +304,10 @@ typedef _Packed struct
 
 typedef _Packed struct
 {
-     volatile uint32_t      iadd;               /**<    FM IRAM instruction address register */
-    volatile uint32_t      idata;               /**<    FM IRAM instruction data register */
-    volatile uint32_t      itcfg;               /**<    FM IRAM timing config register */
-    volatile uint32_t      iready;               /**<    FM IRAM ready register */
+    volatile uint32_t   iadd;           /**<    FM IRAM instruction address register */
+    volatile uint32_t   idata;          /**<    FM IRAM instruction data register */
+    volatile uint32_t   itcfg;          /**<    FM IRAM timing config register */
+    volatile uint32_t   iready;         /**<    FM IRAM ready register */
     volatile uint8_t    res[0x80000-0x10];
 } _PackedType t_FMIramRegs;
 
@@ -316,6 +316,7 @@ typedef _Packed struct
 #pragma pack(pop)
 #endif /* __MWERKS__ */
 
+
 /**************************************************************************//**
  @Description       General defines
 *//***************************************************************************/
@@ -391,13 +392,13 @@ typedef _Packed struct
 *//***************************************************************************/
 
 /* masks */
-#define FPM_EV_MASK_DOUBLE_ECC_EN       0x00008000
-#define FPM_EV_MASK_STALL_EN            0x00004000
-#define FPM_EV_MASK_SINGLE_ECC_EN       0x00002000
 #define FPM_EV_MASK_DOUBLE_ECC          0x80000000
 #define FPM_EV_MASK_STALL               0x40000000
 #define FPM_EV_MASK_SINGLE_ECC          0x20000000
 #define FPM_EV_MASK_RELEASE_FM          0x00010000
+#define FPM_EV_MASK_DOUBLE_ECC_EN       0x00008000
+#define FPM_EV_MASK_STALL_EN            0x00004000
+#define FPM_EV_MASK_SINGLE_ECC_EN       0x00002000
 #define FPM_EV_MASK_EXTERNAL_HALT       0x00000008
 #define FPM_EV_MASK_ECC_ERR_HALT        0x00000004
 
@@ -577,6 +578,7 @@ typedef struct
     bool                        enIramTestMode;
     bool                        externalEccRamsEnable;
     t_FmPcdFirmwareParams       firmware;
+    bool                        fwVerify;
 } t_FmDriverParam;
 
 typedef void (t_FmCtlIsr)( t_Handle h_Fm, uint32_t event);
@@ -588,6 +590,10 @@ typedef struct
     t_Handle                    h_FmPorts[FM_MAX_NUM_OF_PORTS]; /* Handles to all partitions ports */
     e_FmPortType                portsTypes[FM_MAX_NUM_OF_PORTS];
     char                        fmModuleName[MODULE_NAME_SIZE];
+    t_FmIntrSrc                 intrMng[e_FM_EV_DUMMY_LAST];    /* FM exceptions user callback */
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    uint8_t                     partitionId;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 #ifndef CONFIG_GUEST_PARTITION
     uint64_t                    baseAddr;
     t_Handle                    h_FmMuram;
@@ -615,7 +621,6 @@ typedef struct
     t_FmExceptionsCallback      *f_Exceptions;
     t_FmBusErrorCallback        *f_BusError;
     t_Handle                    h_App;                          /* Application handle */
-    t_FmIntrSrc                 intrMng[e_FM_EV_DUMMY_LAST];    /* FM exceptions user callback */
     t_FmCtlIsr                  *f_FmCtlIsr[NUM_OF_FM_CTL_EVENT_REGS];
     bool                        ramsEccEnable;
     uint32_t                    extraFifoPoolSize;
@@ -625,5 +630,19 @@ typedef struct
 #endif /* ! CONFIG_GUEST_PARTITION */
 } t_Fm;
 
+/**************************************************************************//**
+ @Function      FM_Isr
+
+ @Description   FM interrupt-service-routine.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+#ifdef CONFIG_GUEST_PARTITION
+void FM_ErrorIsr(t_Handle h_Fm);
+void FM_EventIsr(t_Handle h_Fm);
+#endif /* !CONFIG_GUEST_PARTITION */
+
 #endif /* __FM_H */
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c
index 98b7357..fa608bb 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c
@@ -144,6 +144,49 @@ uint32_t    FmGetTimeStampPeriod(t_Handle h_Fm)
     return timeStampPeriod;
 }
 
+t_Error     FmHandleIpcMsg(t_Handle h_Fm, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE])
+{
+    t_Fm    *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    switch(msgId)
+    {
+        case (FM_GUEST_ISR):
+            if(((t_FmIpcIsr*)msgBody)->err)
+                FM_ErrorIsr(h_Fm, uint32_t ((t_FmIpcIsr*)msgBody)->pending);
+            else
+                FM_EventIsr(h_Fm, uint32_t ((t_FmIpcIsr*)msgBody)->pending);
+        break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("command not found!!!"));
+    }
+    return E_OK;
+}
+
+void FmRegisterIntr(t_Handle h_Fm,
+                        e_FmEventModules        module,
+                        uint8_t                 modId,
+                        bool                    err,
+                        void (*f_Isr) (t_Handle h_Arg),
+                        t_Handle    h_Arg)
+{
+    t_Fm                *p_Fm = (t_Fm*)h_Fm;
+    uint8_t             event= 0;
+    t_FmIpcRegisterIntr *fmIpcRegisterIntr;
+
+    /* register in local FM structure */
+    GET_MODULE_EVENT(module, modId,err, event);
+    ASSERT_COND(event != e_FM_EV_DUMMY_LAST);
+    p_Fm->intrMng[event].f_Isr = f_Isr;
+    p_Fm->intrMng[event].h_SrcHandle = h_Arg;
+
+    /* register in Master FM structure */
+    fmIpcRegisterIntr.event = event;
+    fmIpcRegisterIntr.partitionId = p_Fm->partitionId;
+    return XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_REGISTER_INTR, (uint8_t*)&fmIpcRegisterIntr, NULL, NULL);
+}
+
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 t_Error FmDumpPortRegs (t_Handle h_Fm,uint8_t hardwarePortId)
 {
@@ -176,7 +219,7 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
         p_Fm->portsTypes[i] = e_FM_PORT_TYPE_DUMMY;
     /* register to inter-core messaging mechanism */
     memset(p_Fm->fmModuleName, 0, MODULE_NAME_SIZE);
-    if(Sprint (p_Fm->fmModuleName, "FM-%d",p_Fm->fmId) != 4)
+    if(Sprint (p_Fm->fmModuleName, "FM-%d-%d",p_Fm->fmId, p_Fm->partitionId) != (p_Fm->partitionId<10 ? 6:7))
     {
         XX_Free(p_Fm);
         REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
@@ -197,7 +240,16 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
 *//***************************************************************************/
 t_Error FM_Init(t_Handle h_Fm)
 {
-    UNUSED(h_Fm);
+    t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+    int                     i;
+
+    for(i=0;i<e_FM_EV_DUMMY_LAST;i++)
+        p_Fm->intrMng[i].f_Isr = UnimplementedIsr;
+
+    err = XX_RegisterMessageHandler(p_Fm->fmModuleName, FmHandleIpcMsg, p_Fm);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
     return E_OK;
 }
 
@@ -277,6 +329,51 @@ uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
     return counterParams.val;
 }
 
+void FM_ErrorIsr(t_Handle h_Fm, uint32_t pending)
+{
+    t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+    uint32_t                pending;
+
+    SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
+
+    /* error interrupts */
+    if(pending & ERR_INTR_EN_1G_MAC0)
+        p_Fm->intrMng[e_FM_EV_ERR_1G_MAC0].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC0].h_SrcHandle);
+    if(pending & ERR_INTR_EN_1G_MAC1)
+        p_Fm->intrMng[e_FM_EV_ERR_1G_MAC1].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC1].h_SrcHandle);
+    if(pending & ERR_INTR_EN_1G_MAC2)
+        p_Fm->intrMng[e_FM_EV_ERR_1G_MAC2].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC2].h_SrcHandle);
+    if(pending & ERR_INTR_EN_1G_MAC3)
+        p_Fm->intrMng[e_FM_EV_ERR_1G_MAC3].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC3].h_SrcHandle);
+    if(pending & ERR_INTR_EN_10G_MAC0)
+        p_Fm->intrMng[e_FM_EV_ERR_10G_MAC0].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_10G_MAC0].h_SrcHandle);
+}
+
+void FM_EventIsr(t_Handle h_Fm, uint32_t pending)
+{
+    t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+    uint32_t                pending;
+
+    SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
+
+    if(pending & INTR_EN_1G_MAC1)
+       p_Fm->intrMng[e_FM_EV_1G_MAC1].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC1].h_SrcHandle);
+    if(pending & INTR_EN_1G_MAC2)
+        p_Fm->intrMng[e_FM_EV_1G_MAC2].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC2].h_SrcHandle);
+    if(pending & INTR_EN_1G_MAC3)
+        p_Fm->intrMng[e_FM_EV_1G_MAC3].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC3].h_SrcHandle);
+    if(pending & INTR_EN_1G_MAC0_TMR)
+        p_Fm->intrMng[e_FM_EV_1G_MAC0_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC0_TMR].h_SrcHandle);
+    if(pending & INTR_EN_1G_MAC1_TMR)
+        p_Fm->intrMng[e_FM_EV_1G_MAC1_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC1_TMR].h_SrcHandle);
+    if(pending & INTR_EN_1G_MAC2_TMR)
+        p_Fm->intrMng[e_FM_EV_1G_MAC2_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC2_TMR].h_SrcHandle);
+    if(pending & INTR_EN_1G_MAC3_TMR)
+        p_Fm->intrMng[e_FM_EV_1G_MAC3_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC3_TMR].h_SrcHandle);
+    if(pending & INTR_EN_TMR)
+        p_Fm->intrMng[e_FM_EV_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_TMR].h_SrcHandle);
+}
+
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 t_Error FM_DumpRegs(t_Handle h_Fm)
 {
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
index 1cb41a9..059452f 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
@@ -242,6 +242,8 @@ typedef _Packed struct t_FmIpcPhysAddr
 #define FM_IS_PORT_STALLED          9
 #define FM_DUMP_PORT_REGS           10
 #define FM_GET_REV                  11
+#define FM_REGISTER_INTR            12
+#define FM_GUEST_ISR                13
 /**************************************************************************//**
  @Description   Structure for IPC communication during FM_PORT_Init.
                 Fields commented 'IN' are passed by the port module to be used
@@ -301,6 +303,18 @@ typedef struct t_FmIpcGetCounter
     uint32_t        val;        /* OUT */
 } t_FmIpcGetCounter;
 
+typedef struct t_FmIpcRegisterIntr
+{
+    uint8_t         partitionId;    /* IN */
+    uint32_t        event;          /* IN */
+} t_FmIpcRegisterIntr;
+
+typedef struct t_FmIpcIsr
+{
+    bool            err;            /* IN */
+    uint32_t        pendingReg;     /* IN */
+} t_FmIpcIsr;
+
 /** @} */ /* end of FM_IPC_grp group */
 /** @} */ /* end of FM_grp group */
 
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
index 6250db1..a600ecd 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
@@ -165,6 +165,79 @@ do {                                                            \
 #define FM_MASTER_PARTITION
 #endif /* defined (CONFIG_GUEST_PARTITION) && ... */
 
+/**************************************************************************//**
+ @Collection   Defines used for enabling/disabling FM interrupts
+
+ @{
+*//***************************************************************************/
+
+typedef uint32_t t_FmBlockErrIntrEnable;
+
+#define ERR_INTR_EN_DMA         0x00010000
+#define ERR_INTR_EN_FPM         0x80000000
+#define ERR_INTR_EN_BMI         0x00800000
+#define ERR_INTR_EN_QMI         0x00400000
+#define ERR_INTR_EN_PRS         0x00200000
+#define ERR_INTR_EN_KG          0x00100000
+#define ERR_INTR_EN_PLCR        0x00080000
+#define ERR_INTR_EN_MURAM       0x00040000
+#define ERR_INTR_EN_IRAM        0x00020000
+#define ERR_INTR_EN_10G_MAC0    0x00008000
+#define ERR_INTR_EN_1G_MAC0     0x00004000
+#define ERR_INTR_EN_1G_MAC1     0x00002000
+#define ERR_INTR_EN_1G_MAC2     0x00001000
+#define ERR_INTR_EN_1G_MAC3     0x00000800
+
+typedef uint32_t t_FmBlockIntrEnable;
+
+#define INTR_EN_BMI             0x80000000
+#define INTR_EN_QMI             0x40000000
+#define INTR_EN_PRS             0x20000000
+#define INTR_EN_KG              0x10000000
+#define INTR_EN_PLCR            0x08000000
+#define INTR_EN_REV0            0x00008000
+#define INTR_EN_REV1            0x00004000
+#define INTR_EN_REV2            0x00002000
+#define INTR_EN_REV3            0x00001000
+#define INTR_EN_BRK             0x00000080
+#define INTR_EN_TMR             0x01000000
+#define INTR_EN_1G_MAC0_TMR     0x00080000
+#define INTR_EN_1G_MAC1_TMR     0x00040000
+#define INTR_EN_1G_MAC2_TMR     0x00020000
+#define INTR_EN_1G_MAC3_TMR     0x00010000
+#define INTR_EN_1G_MAC1         0x00400000
+#define INTR_EN_1G_MAC2         0x00200000
+#define INTR_EN_1G_MAC3         0x00100000
+
+/* @} */
+
+
+/**************************************************************************//**
+ @Description   Enum for inter-module interrupts registration
+*//***************************************************************************/
+typedef enum e_FmInterModuleEvent {
+    e_FM_EV_PRS,                    /**< Parser event */
+    e_FM_EV_ERR_PRS,                /**< Parser error event */
+    e_FM_EV_KG,                     /**< Keygen event */
+    e_FM_EV_ERR_KG,                 /**< Keygen error event */
+    e_FM_EV_PLCR,                   /**< Policer event */
+    e_FM_EV_ERR_PLCR,               /**< Policer error event */
+    e_FM_EV_ERR_10G_MAC0,           /**< 10G MAC 0 error event */
+    e_FM_EV_ERR_1G_MAC0,            /**< 1G MAC 0 error event */
+    e_FM_EV_ERR_1G_MAC1,            /**< 1G MAC 1 error event */
+    e_FM_EV_ERR_1G_MAC2,            /**< 1G MAC 2 error event */
+    e_FM_EV_ERR_1G_MAC3,            /**< 1G MAC 3 error event */
+    e_FM_EV_TMR,                    /**< Timer event */
+    e_FM_EV_1G_MAC1,                /**< 1G MAC 1 event */
+    e_FM_EV_1G_MAC2,                /**< 1G MAC 2 event */
+    e_FM_EV_1G_MAC3,                /**< 1G MAC 3 event */
+    e_FM_EV_1G_MAC0_TMR,            /**< 1G MAC 0 Timer event */
+    e_FM_EV_1G_MAC1_TMR,            /**< 1G MAC 1 Timer event */
+    e_FM_EV_1G_MAC2_TMR,            /**< 1G MAC 2 Timer event */
+    e_FM_EV_1G_MAC3_TMR,            /**< 1G MAC 3 Timer event */
+    e_FM_EV_DUMMY_LAST
+} e_FmInterModuleEvent;
+
 
 #define MAX_NUM_OF_OP_PORTS                 7
 #define MAX_NUM_OF_RX_1G_PORTS              4
@@ -277,6 +350,9 @@ typedef struct
 {
     void        (*f_Isr) (t_Handle h_Arg);
     t_Handle    h_SrcHandle;
+#ifdef FM_MASTER_PARTITION
+    uint8_t     partitionId;
+#endif
 } t_FmIntrSrc;
 
 #define ILLEGAL_HDR_NUM                         0xFF
@@ -587,9 +663,6 @@ t_Error     FmPcdCcUnbindTree(t_Handle h_FmPcd, t_Handle h_CcTree);
 t_Error     FmPcdHandleIpcMsg(t_Handle h_FmPcd, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE]);
 #endif /* (defined(CONFIG_MULTI_PARTITION_SUPPORT) && ... */
 
-#ifdef CONFIG_MULTI_PARTITION_SUPPORT
-uint8_t     FmPcdGetPartitionId(t_Handle h_FmPcd);
-#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 
 t_Error     FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams);
 t_Error     FmPortDeletePcd(t_Handle h_FmPort);
@@ -602,5 +675,44 @@ void        FmPortPcdKgSwUnbindClsPlanGrp (t_Handle h_FmPort);
 t_Error     FmPortAttachPCD(t_Handle h_FmPort);
 
 
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+uint8_t     FmGetPartitionId(t_Handle h_Fm);
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+/**************************************************************************//**
+ @Function      FmRegisterIntr
+
+ @Description   Used to register an inter-module event handler to be processed by FM
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     mod             The module that causes the event
+ @Param[in]     modId           Module id - if more than 1 instansiation of this
+                                mode exists,0 otherwise.
+ @Param[in]     intrType        Interrupt type (error/normal) selection.
+ @Param[in]     f_Isr           The interrupt service routine.
+ @Param[in]     h_Arg           Argument to be passed to f_Isr.
+
+ @Return        None.
+*//***************************************************************************/
+void FmRegisterIntr(t_Handle                h_Fm,
+                     e_FmEventModules       mod,
+                     uint8_t                modId,
+                     e_FmIntrType           intrType,
+                     void                   (*f_Isr) (t_Handle h_Arg),
+                     t_Handle               h_Arg);
+
+/**************************************************************************//**
+ @Function      FmRegisterFmCtlIntr
+
+ @Description   Used to register to one of the fmCtl events in the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     eventRegId      FmCtl event id (0-7).
+ @Param[in]     f_Isr           The interrupt service routine.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void  FmRegisterFmCtlIntr(t_Handle h_Fm, uint8_t eventRegId, void (*f_Isr) (t_Handle h_Fm, uint32_t event));
 
 #endif /* __FM_COMMON_H */
diff --git a/drivers/net/dpa/NetCommSw/dflags.h b/drivers/net/dpa/NetCommSw/dflags.h
index bc40bcc..581f0dd 100644
--- a/drivers/net/dpa/NetCommSw/dflags.h
+++ b/drivers/net/dpa/NetCommSw/dflags.h
@@ -55,5 +55,9 @@
 #define REPORT_EVENTS       1
 #define EVENT_GLOBAL_LEVEL  REPORT_LEVEL_MINOR
 
+#ifdef CONFIG_P4080_SIM
+#define SIMULATOR
+#endif /* CONFIG_P4080_SIM */
+
 
 #endif /* __dflags_h */
diff --git a/drivers/net/dpa/NetCommSw/etc/memcpy.c b/drivers/net/dpa/NetCommSw/etc/memcpy.c
index e43d3b9..57360d4 100644
--- a/drivers/net/dpa/NetCommSw/etc/memcpy.c
+++ b/drivers/net/dpa/NetCommSw/etc/memcpy.c
@@ -40,28 +40,25 @@
 static void MY_MY_WRITE_UINT8(uint8_t *addr, uint8_t val)
 {
     uint32_t newAddr, newVal;
+    newAddr = (uint32_t)addr & ~0x3L;
     switch ((uint32_t)addr%4)
     {
     case (0):
-        newAddr = (uint32_t)addr;
         newVal = GET_UINT32(*(uint32_t*)newAddr);
         newVal = (newVal & 0x00ffffff) | (((uint32_t)val)<<24);
         WRITE_UINT32(*(uint32_t*)newAddr, newVal);
         break;
     case (1):
-        newAddr = (((uint32_t)addr>>1)<<1);
-        newVal = GET_UINT32(*(uint32_t*)newAddr);
+         newVal = GET_UINT32(*(uint32_t*)newAddr);
         newVal = (newVal & 0xff00ffff) | (((uint32_t)val)<<16);
         WRITE_UINT32(*(uint32_t*)newAddr, newVal);
         break;
     case (2):
-        newAddr = (((uint32_t)addr>>2)<<2);
         newVal = GET_UINT32(*(uint32_t*)newAddr);
         newVal = (newVal & 0xffff00ff) | (((uint32_t)val)<<8);
         WRITE_UINT32(*(uint32_t*)newAddr, newVal);
         break;
     case (3):
-        newAddr = (((uint32_t)addr>>3)<<3);
         newVal = GET_UINT32(*(uint32_t*)newAddr);
         newVal = (newVal & 0xffffff00) | val;
         WRITE_UINT32(*(uint32_t*)newAddr, newVal);
@@ -72,25 +69,22 @@ static void MY_MY_WRITE_UINT8(uint8_t *addr, uint8_t val)
 static uint8_t MY_MY_GET_UINT8(uint8_t *addr)
 {
     uint32_t newAddr, newVal=0;
+    newAddr = (uint32_t)addr & ~0x3L;
     switch ((uint32_t)addr%4)
     {
     case (0):
-        newAddr = (uint32_t)addr;
         newVal = GET_UINT32(*(uint32_t*)newAddr);
         newVal = (newVal & 0xff000000)>>24;
         break;
     case (1):
-        newAddr = (((uint32_t)addr>>1)<<1);
         newVal = GET_UINT32(*(uint32_t*)newAddr);
         newVal = (newVal & 0x00ff0000)>>16;
         break;
     case (2):
-        newAddr = (((uint32_t)addr>>2)<<2);
         newVal = GET_UINT32(*(uint32_t*)newAddr);
         newVal = (newVal & 0x0000ff00)>>8;
         break;
     case (3):
-        newAddr = (((uint32_t)addr>>3)<<3);
         newVal = GET_UINT32(*(uint32_t*)newAddr);
         newVal = (newVal & 0x000000ff);
         break;
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h
index 4fee320..bd04b06 100644
--- a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h
@@ -105,8 +105,8 @@ typedef uint32_t    fmPortFrameErrSelect_t;                         /**< typedef
 #define FM_PORT_FRM_ERR_EXTRACTION                      0x00008000  /**< Extract Out of Frame */
 #define FM_PORT_FRM_ERR_NO_SCHEME                       0x00004000  /**< No Scheme Selected */
 #define FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW                0x00002000  /**< No Scheme Selected */
-#define FM_PORT_FRM_ERR_COLOR_YELLOW                    0x00000400
-#define FM_PORT_FRM_ERR_COLOR_RED                       0x00000800
+#define FM_PORT_FRM_ERR_COLOR_YELLOW                    0x00000400  /**< */
+#define FM_PORT_FRM_ERR_COLOR_RED                       0x00000800  /**< */
 #define FM_PORT_FRM_ERR_ILL_PLCR                        0x00000200  /**< Illegal Policer Profile selected */
 #define FM_PORT_FRM_ERR_PLCR_FRAME_LEN                  0x00000100  /**< Illegal Policer Profile selected */
 #define FM_PORT_FRM_ERR_PRS_TIMEOUT                     0x00000080  /**< Parser Time out Exceed */
@@ -125,8 +125,8 @@ typedef uint32_t    fmPortFrameErrSelect_t;                         /**< typedef
 *//***************************************************************************/
 typedef _Packed struct t_FmPhysAddr
 {
-    volatile uint16_t high;
-    volatile uint32_t low;
+    volatile uint16_t high;         /**< High part of the physical address */
+    volatile uint32_t low;          /**< Low part of the physical address */
 }_PackedType t_FmPhysAddr;
 
 /**************************************************************************//**
@@ -158,35 +158,47 @@ typedef _Packed struct t_FmPrsResult {
 /**************************************************************************//**
  @Description   Parse results
 *//***************************************************************************/
-#define FM_PR_L2_VLAN_STACK       0x0100
-#define FM_PR_L2_ETHERNET         0x8000
-#define FM_PR_L2_VLAN             0x4000
-#define FM_PR_L2_LLC_SNAP         0x2000
-#define FM_PR_L2_MPLS             0x1000
-#define FM_PR_L2_PPPoE            0x0800
+#define FM_PR_L2_VLAN_STACK       0x0100    /**< */
+#define FM_PR_L2_ETHERNET         0x8000    /**< */
+#define FM_PR_L2_VLAN             0x4000    /**< */
+#define FM_PR_L2_LLC_SNAP         0x2000    /**< */
+#define FM_PR_L2_MPLS             0x1000    /**< */
+#define FM_PR_L2_PPPoE            0x0800    /**< */
 
 /**************************************************************************//**
  @Description   Time stamp in buffer
 *//***************************************************************************/
 typedef _Packed struct t_FmTimeStamp {
-    uint32_t    timeStamp;          /**< Time stamp integer */
-    uint32_t    timeStampFrac;      /**< Time stamp fraction */
+    volatile uint32_t    timeStamp;          /**< Time stamp integer */
+    volatile uint32_t    timeStampFrac;      /**< Time stamp fraction */
 } _PackedType t_FmTimeStamp;
 
 /**************************************************************************//**
  @Description   Frame descriptor
 *//***************************************************************************/
 typedef _Packed struct t_FmFD {
-    uint32_t    id;                 /**< FD id */
-    uint32_t    addrl;              /**< Data Address */
-    uint32_t    length;             /**< Frame length */
-    uint32_t    status;             /**< FD status */
+    volatile uint32_t    id;                 /**< FD id */
+    volatile uint32_t    addrl;              /**< Data Address */
+    volatile uint32_t    length;             /**< Frame length */
+    volatile uint32_t    status;             /**< FD status */
 } _PackedType t_FmFD;
 
-#define MEM_MAP_END
-#ifdef __MWERKS__
-#pragma pack(pop)
-#endif /* __MWERKS__ */
+/**************************************************************************//**
+ @Description   enum for defining frame format
+*//***************************************************************************/
+typedef enum e_FmFDFormatType {
+    e_FM_FD_FORMAT_TYPE_SHORT_SBSF  = 0x0,   /**< Simple frame Single buffer; Offset and
+                                                  small length (9b OFFSET, 20b LENGTH) */
+    e_FM_FD_FORMAT_TYPE_LONG_SBSF   = 0x2,   /**< Simple frame, single buffer; big length
+                                                  (29b LENGTH ,No OFFSET) */
+    e_FM_FD_FORMAT_TYPE_SHORT_MBSF  = 0x4,   /**< Simple frame, Scatter Gather table; Offset
+                                                  and small length (9b OFFSET, 20b LENGTH) */
+    e_FM_FD_FORMAT_TYPE_LONG_MBSF   = 0x6,   /**< Simple frame, Scatter Gather table;
+                                                  big length (29b LENGTH ,No OFFSET) */
+    e_FM_FD_FORMAT_TYPE_COMPOUND    = 0x1,   /**< Compound Frame (29b CONGESTION-WEIGHT
+                                                  No LENGTH or OFFSET) */
+    e_FM_FD_FORMAT_TYPE_DUMMY
+} e_FmFDFormatType;
 
 /**************************************************************************//**
  @Collection   Frame descriptor macros
@@ -212,22 +224,21 @@ typedef _Packed struct t_FmFD {
 #define FM_FD_GET_STATUS(fd)        ((t_FmFD *)fd)->status                                      /**< Macro to get FD STATUS field */
 #define FM_FD_GET_ADDR(fd)          XX_PhysToVirt(CAST_UINT64_TO_POINTER(FM_FD_GET_PHYS_ADDR(fd)))
 
-#define FM_FD_SET_DD(fd,val)        (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_DD_MASK) | ((val << (31-1))& FM_FD_DD_MASK )))      /**< Macro to get FD DD field */
-#define FM_FD_SET_PID(fd,val)       (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_PID_MASK) | ((val << (31-7))& FM_FD_PID_MASK)))     /**< Macro to get FD PID field */
-#define FM_FD_SET_BPID(fd,val)      (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_BPID_MASK) | ((val  << (31-15))& FM_FD_BPID_MASK))) /**< Macro to get FD BPID field */
-#define FM_FD_SET_ADDRH(fd,val)     (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_ADDRH_MASK) | (val & FM_FD_ADDRH_MASK)))            /**< Macro to get FD ADDRH field */
-#define FM_FD_SET_ADDRL(fd,val)     ((t_FmFD *)fd)->addrl = val                                 /**< Macro to get FD ADDRL field */
+#define FM_FD_SET_DD(fd,val)        (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_DD_MASK) | ((val << (31-1))& FM_FD_DD_MASK )))      /**< Macro to set FD DD field */
+#define FM_FD_SET_PID(fd,val)       (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_PID_MASK) | ((val << (31-7))& FM_FD_PID_MASK)))     /**< Macro to set FD PID field */
+#define FM_FD_SET_BPID(fd,val)      (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_BPID_MASK) | ((val  << (31-15))& FM_FD_BPID_MASK))) /**< Macro to set FD BPID field */
+#define FM_FD_SET_ADDRH(fd,val)     (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_ADDRH_MASK) | (val & FM_FD_ADDRH_MASK)))            /**< Macro to set FD ADDRH field */
+#define FM_FD_SET_ADDRL(fd,val)     ((t_FmFD *)fd)->addrl = val                                 /**< Macro to set FD ADDRL field */
 #define FM_FD_SET_ADDR(fd,val)                                      \
 do {                                                                \
     uint64_t physAddr = CAST_POINTER_TO_UINT64(XX_VirtToPhys(val)); \
     FM_FD_SET_ADDRH(fd, ((uint32_t)(physAddr >> 32)));              \
     FM_FD_SET_ADDRL(fd, (uint32_t)physAddr);                        \
-} while (0)                                                                                     /**< Macro to get FD ADDR field */
-#define FM_FD_SET_FORMAT(fd,val)    (((t_FmFD *)fd)->length = ((((t_FmFD *)fd)->length & ~FM_FD_FORMAT_MASK) | ((val  << (31-2))& FM_FD_FORMAT_MASK)))  /**< Macro to get FD FORMAT field */
-#define FM_FD_SET_OFFSET(fd,val)    (((t_FmFD *)fd)->length = ((((t_FmFD *)fd)->length & ~FM_FD_OFFSET_MASK) | ((val << (31-11))& FM_FD_OFFSET_MASK) )) /**< Macro to get FD OFFSET field */
-#define FM_FD_SET_LENGTH(fd,val)    (((t_FmFD *)fd)->length = (((t_FmFD *)fd)->length & ~FM_FD_LENGTH_MASK) | (val & FM_FD_LENGTH_MASK))                /**< Macro to get FD LENGTH field */
-#define FM_FD_SET_STATUS(fd,val)    ((t_FmFD *)fd)->status = val                                /**< Macro to get FD STATUS field */
-
+} while (0)                                                                                     /**< Macro to set FD ADDR field */
+#define FM_FD_SET_FORMAT(fd,val)    (((t_FmFD *)fd)->length = ((((t_FmFD *)fd)->length & ~FM_FD_FORMAT_MASK) | ((val  << (31-2))& FM_FD_FORMAT_MASK)))  /**< Macro to set FD FORMAT field */
+#define FM_FD_SET_OFFSET(fd,val)    (((t_FmFD *)fd)->length = ((((t_FmFD *)fd)->length & ~FM_FD_OFFSET_MASK) | ((val << (31-11))& FM_FD_OFFSET_MASK) )) /**< Macro to set FD OFFSET field */
+#define FM_FD_SET_LENGTH(fd,val)    (((t_FmFD *)fd)->length = (((t_FmFD *)fd)->length & ~FM_FD_LENGTH_MASK) | (val & FM_FD_LENGTH_MASK))                /**< Macro to set FD LENGTH field */
+#define FM_FD_SET_STATUS(fd,val)    ((t_FmFD *)fd)->status = val                                /**< Macro to set FD STATUS field */
 
 #define FM_FD_CMD_FCO  0x80000000      /* Frame queue Context Override */
 #define FM_FD_CMD_RPD  0x40000000      /* Read Prepended Data */
@@ -239,6 +250,68 @@ do {                                                                \
 /* @} */
 
 /**************************************************************************//**
+ @Description   Frame Scatter/Gather Table Entry
+*//***************************************************************************/
+typedef _Packed struct t_FmSGTE {
+    volatile uint32_t    addrh;        /**< Buffer Address high */
+    volatile uint32_t    addrl;        /**< Buffer Address low */
+    volatile uint32_t    length;       /**< Buffer length */
+    volatile uint32_t    offset;       /**< SGTE offset */
+} _PackedType t_FmSGTE;
+
+#define FM_NUM_OF_SG_TABLE_ENTRY 16
+
+/**************************************************************************//**
+ @Description   Frame Scatter/Gather Table
+*//***************************************************************************/
+typedef _Packed struct t_FmSGT {
+    t_FmSGTE    tableEntry[FM_NUM_OF_SG_TABLE_ENTRY];
+} _PackedType t_FmSGT;
+
+/**************************************************************************//**
+ @Collection   Frame Scatter/Gather Table Entry macros
+*//***************************************************************************/
+#define FM_SGTE_ADDRH_MASK    0x0000ffff           /**< SGTE ADDRH field mask */
+#define FM_SGTE_ADDRL_MASK    0xffffffff           /**< SGTE ADDRL field mask */
+#define FM_SGTE_E_MASK        0x80000000           /**< SGTE Extension field mask */
+#define FM_SGTE_F_MASK        0x40000000           /**< SGTE Final field mask */
+#define FM_SGTE_LENGTH_MASK   0x3fffffff           /**< SGTE LENGTH field mask */
+#define FM_SGTE_BPID_MASK     0x00ff0000           /**< SGTE BPID field mask */
+#define FM_SGTE_OFFSET_MASK   0x00001fff           /**< SGTE OFFSET field mask */
+
+#define FM_SGTE_GET_ADDRH(sgte)         (((t_FmSGTE *)sgte)->addrh & FM_SGTE_ADDRH_MASK)                /**< Macro to get SGTE ADDRH field */
+#define FM_SGTE_GET_ADDRL(sgte)         ((t_FmSGTE *)sgte)->addrl                                       /**< Macro to get SGTE ADDRL field */
+#define FM_SGTE_GET_PHYS_ADDR(sgte)       ((uint64_t)(((uint64_t)FM_SGTE_GET_ADDRH(sgte) << 32) | (uint64_t)FM_SGTE_GET_ADDRL(sgte))) /**< Macro to get FD ADDR field */
+#define FM_SGTE_GET_EXTENSION(sgte)     ((((t_FmSGTE *)sgte)->length & FM_SGTE_E_MASK) >> (31-0))       /**< Macro to get SGTE EXTENSION field */
+#define FM_SGTE_GET_FINAL(sgte)         ((((t_FmSGTE *)sgte)->length & FM_SGTE_F_MASK) >> (31-1))       /**< Macro to get SGTE FINAL field */
+#define FM_SGTE_GET_LENGTH(sgte)        (((t_FmSGTE *)sgte)->length & FM_SGTE_LENGTH_MASK)              /**< Macro to get SGTE LENGTH field */
+#define FM_SGTE_GET_BPID(sgte)          ((((t_FmSGTE *)sgte)->offset & FM_SGTE_BPID_MASK) >> (31-15))   /**< Macro to get SGTE BPID field */
+#define FM_SGTE_GET_OFFSET(sgte)        (((t_FmSGTE *)sgte)->offset & FM_SGTE_OFFSET_MASK)              /**< Macro to get SGTE OFFSET field */
+#define FM_SGTE_GET_ADDR(sgte)          XX_PhysToVirt(CAST_UINT64_TO_POINTER(FM_SGTE_GET_PHYS_ADDR(sgte)))
+
+#define FM_SGTE_SET_ADDRH(sgte,val)     (((t_FmSGTE *)sgte)->addrh = ((((t_FmSGTE *)sgte)->addrh & ~FM_SGTE_ADDRH_MASK) | (val & FM_SGTE_ADDRH_MASK))) /**< Macro to set SGTE ADDRH field */
+#define FM_SGTE_SET_ADDRL(sgte,val)     ((t_FmSGTE *)sgte)->addrl = val                                 /**< Macro to set SGTE ADDRL field */
+#define FM_SGTE_SET_ADDR(sgte,val)                                      \
+do {                                                                    \
+    uint64_t physAddr = CAST_POINTER_TO_UINT64(XX_VirtToPhys(val));     \
+    FM_SGTE_SET_ADDRH(sgte, ((uint32_t)(physAddr >> 32)));              \
+    FM_SGTE_SET_ADDRL(sgte, (uint32_t)physAddr);                        \
+} while (0)                                                                                     /**< Macro to set SGTE ADDR field */
+#define FM_SGTE_SET_EXTENSION(sgte,val) (((t_FmSGTE *)sgte)->length = ((((t_FmSGTE *)sgte)->length & ~FM_SGTE_E_MASK) | ((val  << (31-0))& FM_SGTE_E_MASK)))            /**< Macro to set SGTE EXTENSION field */
+#define FM_SGTE_SET_FINAL(sgte,val)     (((t_FmSGTE *)sgte)->length = ((((t_FmSGTE *)sgte)->length & ~FM_SGTE_F_MASK) | ((val  << (31-1))& FM_SGTE_F_MASK)))            /**< Macro to set SGTE FINAL field */
+#define FM_SGTE_SET_LENGTH(sgte,val)    (((t_FmSGTE *)sgte)->length = (((t_FmSGTE *)sgte)->length & ~FM_SGTE_LENGTH_MASK) | (val & FM_SGTE_LENGTH_MASK))                /**< Macro to set SGTE LENGTH field */
+#define FM_SGTE_SET_BPID(sgte,val)      (((t_FmSGTE *)sgte)->offset = ((((t_FmSGTE *)sgte)->offset & ~FM_SGTE_BPID_MASK) | ((val  << (31-15))& FM_SGTE_BPID_MASK)))     /**< Macro to set SGTE BPID field */
+#define FM_SGTE_SET_OFFSET(sgte,val)    (((t_FmSGTE *)sgte)->offset = ((((t_FmSGTE *)sgte)->offset & ~FM_SGTE_OFFSET_MASK) | ((val << (31-11))& FM_SGTE_OFFSET_MASK) )) /**< Macro to set SGTE OFFSET field */
+
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
+/* @} */
+
+
+/**************************************************************************//**
  @Description   FM Exceptions
 *//***************************************************************************/
 typedef enum e_FmExceptions {
@@ -320,6 +393,9 @@ typedef struct t_FmPcdFirmwareParams {
 *//***************************************************************************/
 typedef struct t_FmParams {
     uint8_t                 fmId;                   /**< Index of the FM */
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    uint8_t                     partitionId;        /**< FM Partition Id */
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
 #ifndef CONFIG_GUEST_PARTITION
     uint64_t                baseAddr;               /**< A pointer to base of memory mapped FM registers (virtual).*/
     t_Handle                h_FmMuram;              /**< A handle of an initialized MURAM object,
@@ -640,7 +716,6 @@ t_Error FM_ConfigTimeStamp(t_Handle h_Fm, uint32_t timeStampPeriod);
  @Description   Calling this routine changes the internal driver data base
                 from its default FM threshold configuration
                                   privilegeBusProtect:      [DEFAULT_secureBusProtect]
-                                  secureBusProtect:         [DEFAULT_privilegeBusProtect]
                                   busProtectType:           [DEFAULT_busProtectionType]
 
  @Param[in]     h_Fm                A handle to an FM Module.
@@ -1114,17 +1189,6 @@ t_Error FM_DumpRegs(t_Handle h_Fm);
 #endif /* (defined(DEBUG_ERRORS) && ... */
 
 /**************************************************************************//**
- @Function      FM_Isr
-
- @Description   FM interrupt-service-routine.
-
- @Param[in]     h_Fm            A handle to an FM Module.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-void FM_Isr(t_Handle h_Fm);
-
-/**************************************************************************//**
  @Function      FM_SetException
 
  @Description   Calling this routine enables/disables the specified exception.
@@ -1264,7 +1328,7 @@ void FM_Resume(t_Handle h_Fm);
 uint32_t FM_GetTimeStamp(t_Handle h_Fm);
 
 /**************************************************************************//**
- @Function      FM_DmaEmergencyCtrl
+ @Function      FM_SetDmaEmergency
 
  @Description   Manual emergency set
 
@@ -1276,7 +1340,7 @@ uint32_t FM_GetTimeStamp(t_Handle h_Fm);
 
  @Cautions      Allowed only following FM_Init().
 *//***************************************************************************/
-void FM_DmaEmergencyCtrl(t_Handle h_Fm, e_FmDmaMuramPort muramPort, bool enable);
+void FM_SetDmaEmergency(t_Handle h_Fm, e_FmDmaMuramPort muramPort, bool enable);
 
 /**************************************************************************//**
  @Function      FM_SetDmaExtBusPri
@@ -1333,6 +1397,31 @@ void FM_GetDmaStatus(t_Handle h_Fm, t_FmDmaStatus *p_FmDmaStatus);
  @Cautions      Allowed only following FM_Init().
 *//***************************************************************************/
 t_Handle FM_GetPcdHandle(t_Handle h_Fm);
+
+#ifndef CONFIG_GUEST_PARTITION
+/**************************************************************************//**
+ @Function      FM_ErrorIsr
+
+ @Description   FM interrupt-service-routine for errors.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void FM_ErrorIsr(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_EventIsr
+
+ @Description   FM interrupt-service-routine for normal events.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void FM_EventIsr(t_Handle h_Fm);
+#endif /* !CONFIG_GUEST_PARTITION */
+
 /** @} */ /* end of FM_runtime_control_grp group */
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
@@ -1379,79 +1468,6 @@ t_Error FmDumpPortRegs(t_Handle h_Fm,uint8_t hardwarePortId);
 *//***************************************************************************/
 
 /**************************************************************************//**
- @Collection   Defines used for enabling/disabling FM interrupts
-
- @{
-*//***************************************************************************/
-
-typedef uint32_t t_FmBlockErrIntrEnable;
-
-#define ERR_INTR_EN_DMA         0x00010000      /**< TBD */
-#define ERR_INTR_EN_FPM         0x80000000      /**< TBD */
-#define ERR_INTR_EN_BMI         0x00800000      /**< TBD */
-#define ERR_INTR_EN_QMI         0x00400000      /**< TBD */
-#define ERR_INTR_EN_PRS         0x00200000      /**< TBD */
-#define ERR_INTR_EN_KG          0x00100000      /**< TBD */
-#define ERR_INTR_EN_PLCR        0x00080000      /**< TBD */
-#define ERR_INTR_EN_MURAM       0x00040000      /**< TBD */
-#define ERR_INTR_EN_IRAM        0x00020000      /**< TBD */
-#define ERR_INTR_EN_10G_MAC0    0x00008000      /**< TBD */
-#define ERR_INTR_EN_1G_MAC0     0x00004000      /**< TBD */
-#define ERR_INTR_EN_1G_MAC1     0x00002000      /**< TBD */
-#define ERR_INTR_EN_1G_MAC2     0x00001000      /**< TBD */
-#define ERR_INTR_EN_1G_MAC3     0x00000800      /**< TBD */
-
-typedef uint32_t t_FmBlockIntrEnable;           /**< TBD */
-
-#define INTR_EN_BMI             0x80000000      /**< TBD */
-#define INTR_EN_QMI             0x40000000      /**< TBD */
-#define INTR_EN_PRS             0x20000000      /**< TBD */
-#define INTR_EN_KG              0x10000000      /**< TBD */
-#define INTR_EN_PLCR            0x08000000      /**< TBD */
-#define INTR_EN_REV0            0x00008000      /**< TBD */
-#define INTR_EN_REV1            0x00004000      /**< TBD */
-#define INTR_EN_REV2            0x00002000      /**< TBD */
-#define INTR_EN_REV3            0x00001000      /**< TBD */
-#define INTR_EN_BRK             0x00000080      /**< TBD */
-#define INTR_EN_TMR             0x01000000      /**< TBD */
-#define INTR_EN_1G_MAC0_TMR     0x00080000      /**< TBD */
-#define INTR_EN_1G_MAC1_TMR     0x00040000      /**< TBD */
-#define INTR_EN_1G_MAC2_TMR     0x00020000      /**< TBD */
-#define INTR_EN_1G_MAC3_TMR     0x00010000      /**< TBD */
-#define INTR_EN_1G_MAC1         0x00400000      /**< TBD */
-#define INTR_EN_1G_MAC2         0x00200000      /**< TBD */
-#define INTR_EN_1G_MAC3         0x00100000      /**< TBD */
-
-/* @} */
-
-
-/**************************************************************************//**
- @Description   Enum for inter-module interrupts registration
-*//***************************************************************************/
-typedef enum e_FmInterModuleEvent {
-    e_FM_EV_PRS,                    /**< Parser event */
-    e_FM_EV_ERR_PRS,                /**< Parser error event */
-    e_FM_EV_KG,                     /**< Keygen event */
-    e_FM_EV_ERR_KG,                 /**< Keygen error event */
-    e_FM_EV_PLCR,                   /**< Policer event */
-    e_FM_EV_ERR_PLCR,               /**< Policer error event */
-    e_FM_EV_ERR_10G_MAC0,           /**< 10G MAC 0 error event */
-    e_FM_EV_ERR_1G_MAC0,            /**< 1G MAC 0 error event */
-    e_FM_EV_ERR_1G_MAC1,            /**< 1G MAC 1 error event */
-    e_FM_EV_ERR_1G_MAC2,            /**< 1G MAC 2 error event */
-    e_FM_EV_ERR_1G_MAC3,            /**< 1G MAC 3 error event */
-    e_FM_EV_TMR,                    /**< Timer event */
-    e_FM_EV_1G_MAC1,                /**< 1G MAC 1 event */
-    e_FM_EV_1G_MAC2,                /**< 1G MAC 2 event */
-    e_FM_EV_1G_MAC3,                /**< 1G MAC 3 event */
-    e_FM_EV_1G_MAC0_TMR,            /**< 1G MAC 0 Timer event */
-    e_FM_EV_1G_MAC1_TMR,            /**< 1G MAC 1 Timer event */
-    e_FM_EV_1G_MAC2_TMR,            /**< 1G MAC 2 Timer event */
-    e_FM_EV_1G_MAC3_TMR,            /**< 1G MAC 3 Timer event */
-    e_FM_EV_DUMMY_LAST
-} e_FmInterModuleEvent;
-
-/**************************************************************************//**
  @Description   enum for defining MAC types
 *//***************************************************************************/
 typedef enum e_FmMacType {
@@ -1493,38 +1509,6 @@ typedef struct t_FmInterModulePortFreeParams {
 } t_FmInterModulePortFreeParams;
 
 /**************************************************************************//**
- @Function      FmRegisterIntr
-
- @Description   Used to register an inter-module event handler to be processed by FM
-
- @Param[in]     h_Fm            A handle to an FM Module.
- @Param[in]     event           Event selector
- @Param[in]     f_Isr           The interrupt service routine.
- @Param[in]     h_Arg           Argument to be passed to f_Isr.
-
- @Return        None.
-*//***************************************************************************/
-void FmRegisterIntr(t_Handle               h_Fm,
-                     e_FmInterModuleEvent   event,
-                     void                   (*f_Isr) (t_Handle h_Arg),
-                     t_Handle               h_Arg);
-
-/**************************************************************************//**
- @Function      FmRegisterFmCtlIntr
-
- @Description   Used to register to one of the fmCtl events in the FM module
-
- @Param[in]     h_Fm            A handle to an FM Module.
- @Param[in]     eventRegId      FmCtl event id (0-7).
- @Param[in]     f_Isr           The interrupt service routine.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Init().
-*//***************************************************************************/
-void  FmRegisterFmCtlIntr(t_Handle h_Fm, uint8_t eventRegId, void (*f_Isr) (t_Handle h_Fm, uint32_t event));
-
-/**************************************************************************//**
  @Function      FmGetPcdPrsBaseAddr
 
  @Description   Get the base address of the Parser from the FM module
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
index a034268..b603e0d 100644
--- a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
@@ -59,6 +59,47 @@
 *//***************************************************************************/
 
 /**************************************************************************//**
+ @Description   FM MAC Exceptions
+*//***************************************************************************/
+typedef enum e_FmMacExceptions {
+    e_FM_MAC_EX_10G_MDIO_SCAN_EVENTMDIO
+   ,e_FM_MAC_EX_10G_MDIO_CMD_CMPL
+   ,e_FM_MAC_EX_10G_REM_FAULT
+   ,e_FM_MAC_EX_10G_LOC_FAULT
+   ,e_FM_MAC_EX_10G_1TX_ECC_ER
+   ,e_FM_MAC_EX_10G_TX_FIFO_UNFL
+   ,e_FM_MAC_EX_10G_TX_FIFO_OVFL
+   ,e_FM_MAC_EX_10G_TX_ER
+   ,e_FM_MAC_EX_10G_RX_FIFO_OVFL
+   ,e_FM_MAC_EX_10G_RX_ECC_ER
+   ,e_FM_MAC_EX_10G_RX_JAB_FRM
+   ,e_FM_MAC_EX_10G_RX_OVRSZ_FRM
+   ,e_FM_MAC_EX_10G_RX_RUNT_FRM
+   ,e_FM_MAC_EX_10G_RX_FRAG_FRM
+   ,e_FM_MAC_EX_10G_RX_LEN_ER
+   ,e_FM_MAC_EX_10G_RX_CRC_ER
+   ,e_FM_MAC_EX_10G_RX_ALIGN_ER
+   ,e_FM_MAC_EX_1G_BAB_RX
+   ,e_FM_MAC_EX_1G_RX_CTL
+   ,e_FM_MAC_EX_1G_MIB_CNT_OVFL
+   ,e_FM_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET
+   ,e_FM_MAC_EX_1G_BAB_TX
+   ,e_FM_MAC_EX_1G_TX_CTL
+   ,e_FM_MAC_EX_1G_TX_ERR
+   ,e_FM_MAC_EX_1G_LATE_COL
+   ,e_FM_MAC_EX_1G_COL_RET_LMT
+   ,e_FM_MAC_EX_1G_TX_FIFO_UNDRN
+   ,e_FM_MAC_EX_1G_MAG_PCKT
+   ,e_FM_MAC_EX_1G_MII_MNG_RD_COMPLET
+   ,e_FM_MAC_EX_1G_MII_MNG_WR_COMPLET
+   ,e_FM_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET
+   ,e_FM_MAC_EX_1G_TX_DATA_ERR
+   ,e_FM_MAC_EX_1G_RX_DATA_ERR
+   ,e_FM_MAC_EX_1G_1588_TS_RX_ERR
+} e_FmMacExceptions;
+
+#if 0
+/**************************************************************************//**
  @Description   interrupt setup option
 *//***************************************************************************/
 typedef enum e_FmMacIntOption {
@@ -76,7 +117,7 @@ typedef enum e_FmMacExceptions {
     e_FM_MAC_INT_MINOR                      /**<   Disable all Interrupts */
 } e_FmMacExceptions;
 
-
+#endif /* 0*/
 /**************************************************************************//**
  @Function      t_FmMacExceptionCallback
 
@@ -84,13 +125,12 @@ typedef enum e_FmMacExceptions {
 
  @Param[in]     h_App             - Handle to the upper layer handler
 
- @Param[in]     exceptions        - Exceptions clasification
+ @Param[in]     exceptions        - The exception that occured
 
- @Param[in]     events            - bitwise denition of the exact mac event register
 
  @Return        void.
 *//***************************************************************************/
-typedef void (t_FmMacExceptionCallback)(t_Handle h_App, e_FmMacExceptions exceptions, uint32_t events);
+typedef void (t_FmMacExceptionCallback)(t_Handle h_App, e_FmMacExceptions exceptions);
 
 
 /**************************************************************************//**
@@ -117,26 +157,26 @@ typedef struct t_FmMacStatistics {
     uint64_t  reStatPause;             /**< Pause MAC Control sent */
 
 /* MIB II */
-    uint64_t  ifInOctets;               /**< Total number of byte received. */
-    uint64_t  ifInPkts;                 /**< Total number of packets received.*/
-    uint64_t  ifInMcastPkts;            /**< Total number of multicast frame received*/
-    uint64_t  ifInBcastPkts;            /**< Total number of broadcast frame received */
-    uint64_t  ifInDiscards;             /**< Frames received, but discarded due to problems within the MAC RX. */
-    uint64_t  ifInErrors;               /**< Number of frames received with error:
-                                                 FIFO Overflow Error
-                                                 CRC Error
-                                                 Frame Too Long Error
-                                                 Alignment Error
-                                                 The dedicated Error Code (0xfe, not a code error) was received */
-    uint64_t  ifOutOctets;              /**< Total number of byte sent. */
-    uint64_t  ifOutPkts;                /**< Total number of packets sent .*/
-    uint64_t  ifOutMcastPkts;           /**< Total number of multicast frame sent */
-    uint64_t  ifOutBcastPkts;           /**< Total number of multicast frame sent */
-    uint64_t  ifOutDiscards;            /**< Frames received, but discarded due to problems within the MAC TX N/A!.*/
-    uint64_t  ifOutErrors;              /**< Number of frames transmitted with error:
-                                                 FIFO Overflow Error
-                                                 FIFO Underflow Error
-                                                 Other*/
+    uint64_t  ifInOctets;              /**< Total number of byte received. */
+    uint64_t  ifInPkts;                /**< Total number of packets received.*/
+    uint64_t  ifInMcastPkts;           /**< Total number of multicast frame received*/
+    uint64_t  ifInBcastPkts;           /**< Total number of broadcast frame received */
+    uint64_t  ifInDiscards;            /**< Frames received, but discarded due to problems within the MAC RX. */
+    uint64_t  ifInErrors;              /**< Number of frames received with error:
+                                                FIFO Overflow Error
+                                                CRC Error
+                                                Frame Too Long Error
+                                                Alignment Error
+                                                The dedicated Error Code (0xfe, not a code error) was received */
+    uint64_t  ifOutOctets;             /**< Total number of byte sent. */
+    uint64_t  ifOutPkts;               /**< Total number of packets sent .*/
+    uint64_t  ifOutMcastPkts;          /**< Total number of multicast frame sent */
+    uint64_t  ifOutBcastPkts;          /**< Total number of multicast frame sent */
+    uint64_t  ifOutDiscards;           /**< Frames received, but discarded due to problems within the MAC TX N/A!.*/
+    uint64_t  ifOutErrors;             /**< Number of frames transmitted with error:
+                                                FIFO Overflow Error
+                                                FIFO Underflow Error
+                                                Other*/
 } t_FmMacStatistics;
 
 
@@ -156,13 +196,16 @@ typedef struct t_FmMacParams {
     uint8_t                     macId;              /**< MAC ID <dTSEC 0-3> <10G 0>         */
     t_EnetAddr                  addr;               /**< MAC address of device; First octet is sent first */
     e_EnetMode                  enetMode;           /**< Ethernet operation mode (MAC-PHY interface and speed) */
+    t_Handle                    h_Fm;               /**< A handle to the FM object this port related to */
+    int                         mdioIrq;            /**< MDIO exceptions interrupt source - not valid for all
+                                                         MACs; for MACs that don't have mdio-irq, leave this
+                                                         parameters 0; For polling, put this parameter - NO_IRQ */
+    t_FmMacExceptionCallback    *f_Events;          /**< MDIO Events Callback Routine         */
     t_FmMacExceptionCallback    *f_Exceptions;      /**< Exception Callback Routine         */
     t_Handle                    h_App;              /**< A handle to an application layer object; This handle will
                                                          be passed by the driver upon calling the above callbacks */
-    t_Handle                    h_Fm;               /**< A handle to the FM object this port related to */
 } t_FmMacParams;
 
-
 /**************************************************************************//**
  @Function      FM_MAC_Config
 
@@ -215,6 +258,21 @@ t_Error  FM_MAC_Free (t_Handle h_FmMac);
 *//***************************************************************************/
 
 /**************************************************************************//**
+ @Function      FM_MAC_ConfigResetOnInit
+
+ @Description   Tell the driver whether to reset the FM MAC before initialization or
+                not. It changes the default configuration [DEFAULT_resetOnInit].
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     When TRUE, FM will be reset before any initialization.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigResetOnInit (t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
  @Function      FM_MAC_ConfigStatistics
 
  @Description   Enable/Disable RMON statistics
@@ -311,6 +369,23 @@ t_Error FM_MAC_ConfigHalfDuplex (t_Handle h_FmMac, bool enable);
  @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
 *//***************************************************************************/
 t_Error FM_MAC_ConfigHugeFrames (t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigException
+
+ @Description   Change Excption selection from default
+
+ @Param[in]     h_FmMac         A handle to a FM MAC Module.
+ @Param[in]     ex              Type of the desired excpetions
+ @Param[in]     enable          TRUE to enable the specified exception, FALSE to disable it.
+
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigException(t_Handle h_FmMac, e_FmMacExceptions ex, bool enable);
+
 /** @} */ /* end of FM_mac_advanced_init_grp group */
 /** @} */ /* end of FM_mac_init_grp group */
 
@@ -366,21 +441,6 @@ t_Error FM_MAC_Disable (t_Handle h_FmMac, e_CommMode mode);
 t_Error FM_MAC_Restart (t_Handle h_FmMac, e_CommMode mode);
 
 /**************************************************************************//**
- @Function      FM_MAC_Reset
-
- @Description   Reset FM-MAC controller. The controller will be back to default setup.
-
- @Param[in]     h_FmMac    A handle to a FM MAC Module.
- @Param[in]     wait       Reset the MAC to this mode
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_MAC_Disable(). After this routine is
-                being called, the only operation allowed is FM_MAC_Free().
-*//***************************************************************************/
-t_Error FM_MAC_Reset (t_Handle h_FmMac, bool wait);
-
-/**************************************************************************//**
  @Function      FM_MAC_TxMacPause
 
  @Description   Enable transmition of  Pause frame
@@ -409,18 +469,20 @@ t_Error FM_MAC_TxMacPause (t_Handle h_FmMac, uint16_t pauseTime, uint16_t exPaus
 t_Error FM_MAC_ResetCounters (t_Handle h_FmMac);
 
 /**************************************************************************//**
- @Function      FM_MAC_SetExceptions
+ @Function      FM_MAC_SetException
 
- @Description   Setup Excption Handler
+ @Description   Enable/Disable a sspecific Excption
 
  @Param[in]     h_FmMac         A handle to a FM MAC Module.
  @Param[in]     ex              Type of the desired excpetions
+ @Param[in]     enable          TRUE to enable the specified exception, FALSE to disable it.
+
 
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_SetExceptions(t_Handle h_FmMac, e_FmMacExceptions ex);
+t_Error FM_MAC_SetException(t_Handle h_FmMac, e_FmMacExceptions ex, bool enable);
 
 /**************************************************************************//**
  @Function      FM_MAC_GetStatistics
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
index dcd4607..b48994d 100644
--- a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
@@ -150,9 +150,6 @@ typedef enum e_FmPcdCounters {
  @Description   PCD interrupts
 *//***************************************************************************/
 typedef enum e_FmPcdExceptions {
-
-    /*TODO - to understand how it has to be done*/
-    /*maybe module of PCD + specific interrupts*/
     e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC,                   /**< Keygen ECC error */
     e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC,                 /**< Read Buffer ECC error */
     e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW,             /**< Write Buffer ECC error on system side */
@@ -188,11 +185,11 @@ typedef void (t_FmPcdIdException) ( t_Handle           h_App,
                                     uint16_t           index);
 
 /**************************************************************************//**
- @Description   t_FmPcdQmEnqueueCB - TBD.
+ @Description   t_FmPcdQmEnqueueCB - A callback for enquing frame onto a QM queue.
 
  @Param[in]     h_App           - User's application descriptor.
- @Param[in]     fqid            - TBD.
- @Param[in]     p_Fd            - TBD.
+ @Param[in]     fqid            - Frame queue ID on which frame should be enqueued.
+ @Param[in]     p_Fd            - Frame descriptor for the frame.
 
  @Return        E_OK on success; Error code otherwise.
  *//***************************************************************************/
@@ -217,8 +214,8 @@ typedef struct t_FmPcdHcParams {
     uint8_t                 deqSubPortal;       /**< Host-Command Port Subportal for dequeue. */
 #endif /* !CONFIG_GUEST_PARTITION */
     uint32_t                enqFqid;            /**< Host-Command enqueue Queue Id. */
-    t_FmPcdQmEnqueueCB      *f_QmEnqueueCB;     /**< TBD */
-    t_Handle                h_QmArg;            /**< TBD */
+    t_FmPcdQmEnqueueCB      *f_QmEnqueueCB;     /**< Call back routine for enquing a frame to the QM */
+    t_Handle                h_QmArg;            /**< A handle of the QM module */
 } t_FmPcdHcParams;
 
 /**************************************************************************//**
@@ -240,7 +237,6 @@ typedef struct t_FmPcdParams {
     uint8_t                     numOfSchemes;           /**< Number of schemes dedicated to this partition. */
     uint16_t                    numOfClsPlanEntries;    /**< Number of clsPlan entries dedicated to this partition,
                                                              Must be a power of 2. */
-    uint8_t                     partitionId;            /**< Guest Partition Id */
 #else
     bool                        useHostCommand;
 #endif  /* CONFIG_MULTI_PARTITION_SUPPORT */
@@ -651,10 +647,11 @@ t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception);
 /**************************************************************************//**
  @Function      FM_PCD_HcTxConf
 
- @Description   TBD
+ @Description   This routine should be called to confirm frames that were
+                 recieved on the HC confirmation queue.
 
  @Param[in]     h_FmPcd         A handle to an FM PCD Module.
- @Param[in]     p_Fd            TBD
+ @Param[in]     p_Fd            Frame descriptor of the received frame.
 
  @Cautions      Allowed only following FM_PCD_Init(). Allowed only if 'useHostCommand'
                 option was selected in the initialization.
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
index 44c334e..df236ca 100644
--- a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
@@ -119,37 +119,41 @@ typedef enum e_FmPortPcdSupport {
 
                 User provides this function. Driver invokes it.
 
- @Param[in]     h_App       Application's handle originally specified to
-                            the API Config function
- @Param[in]     p_Data      A pointer to data received
- @Param[in]     length      length of received data
- @Param[in]     status      receive status and errors
- @Param[in]     position    position of buffer in frame
- @Param[in]     h_UserPriv  A handle of the user acossiated with this buffer
- *//***************************************************************************/
-typedef void (t_FmPortImRxStoreFunction) (t_Handle h_App,
-                                          uint8_t  *p_Data,
-                                          uint16_t length,
-                                          uint16_t status,
-                                          uint8_t  position,
-                                          t_Handle h_UserPriv);
+ @Param[in]     h_App           Application's handle originally specified to
+                                the API Config function
+ @Param[in]     p_Data          A pointer to data received
+ @Param[in]     length          length of received data
+ @Param[in]     status          receive status and errors
+ @Param[in]     position        position of buffer in frame
+ @Param[in]     h_BufContext    A handle of the user acossiated with this buffer
+
+ @Retval        e_RX_STORE_RESPONSE_CONTINUE - order the driver to continue Rx
+                                               operation for all ready data.
+ @Retval        e_RX_STORE_RESPONSE_PAUSE    - order the driver to stop Rx operation.
+*//***************************************************************************/
+typedef e_RxStoreResponse (t_FmPortImRxStoreFunction) (t_Handle h_App,
+                                                       uint8_t  *p_Data,
+                                                       uint16_t length,
+                                                       uint16_t status,
+                                                       uint8_t  position,
+                                                       t_Handle h_BufContext);
 
 /**************************************************************************//**
  @Description   User callback function called by driver when transmit completed.
 
                 User provides this function. Driver invokes it.
 
- @Param[in]     h_App       Application's handle originally specified to
-                            the API Config function
- @Param[in]     p_Data      A pointer to data received
- @Param[in]     status      transmit status and errors
- @Param[in]     lastBuffer  is last buffer in frame
- @Param[in]     h_UserPriv  A handle of the user acossiated with this buffer
+ @Param[in]     h_App           Application's handle originally specified to
+                                the API Config function
+ @Param[in]     p_Data          A pointer to data received
+ @Param[in]     status          transmit status and errors
+ @Param[in]     lastBuffer      is last buffer in frame
+ @Param[in]     h_BufContext    A handle of the user acossiated with this buffer
  *//***************************************************************************/
 typedef void (t_FmPortImTxConfFunction) (t_Handle   h_App,
                                          uint8_t    *p_Data,
                                          uint16_t   status,
-                                         t_Handle   h_UserPriv);
+                                         t_Handle   h_BufContext);
 
 /**************************************************************************//**
  @Description   A structure of information about each of the external
@@ -606,7 +610,7 @@ t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComf
 t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold);
 
 /**************************************************************************//**
- @Function      FM_PORT_ConfigRxPriElevationLevel
+ @Function      FM_PORT_ConfigRxFifoPriElevationLevel
 
  @Description   Calling this routine changes the priority elevation level
                 parameter in the internal driver data base from its default
@@ -627,7 +631,7 @@ t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold)
 
  @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
 *//***************************************************************************/
-t_Error FM_PORT_ConfigRxPriElevationLevel(t_Handle h_FmPort, uint32_t priElevationLevel);
+t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priElevationLevel);
 
 /**************************************************************************//**
  @Function      FM_PORT_ConfigBufferPrefixContent
@@ -1834,7 +1838,7 @@ t_Error      FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart
  @Param[in]     length      Size of data for transmission.
  @Param[in]     lastBuffer  Buffer poistion - TRUE for the last buffer
                             of a frame, including a single buffer frame
- @Param[in]     h_UserPriv  A handle of the user acossiated with this buffer
+ @Param[in]     h_BufContext  A handle of the user acossiated with this buffer
 
  @Return        E_OK on success; Error code otherwise.
 
@@ -1846,7 +1850,7 @@ t_Error  FM_PORT_ImTx( t_Handle               h_FmPort,
                        uint8_t                *p_Data,
                        uint16_t               length,
                        bool                   lastBuffer,
-                       t_Handle               h_UserPriv);
+                       t_Handle               h_BufContext);
 
 /**************************************************************************//**
  @Function      FM_PORT_ImTxConf
diff --git a/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h b/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h
index dd0d556..cb3556d 100644
--- a/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h
@@ -39,6 +39,7 @@
 #ifndef __PART_INTEGRATION_EXT_H
 #define __PART_INTEGRATION_EXT_H
 
+//#include "ddr_std_ext.h"
 
 /**************************************************************************//**
  @Group         P4080_chip_id P4080 Application Programming Interface
@@ -59,7 +60,42 @@ typedef enum e_ModuleId
     e_MODULE_ID_DUART_4,
     e_MODULE_ID_QM,                 /**< Queue manager module */
     e_MODULE_ID_BM,                 /**< Buffer manager module */
-
+    e_MODULE_ID_QM_CE_PORTAL_0,
+    e_MODULE_ID_QM_CE_PORTAL_1,
+    e_MODULE_ID_QM_CE_PORTAL_2,
+    e_MODULE_ID_QM_CE_PORTAL_3,
+    e_MODULE_ID_QM_CE_PORTAL_4,
+    e_MODULE_ID_QM_CE_PORTAL_5,
+    e_MODULE_ID_QM_CE_PORTAL_6,
+    e_MODULE_ID_QM_CE_PORTAL_7,
+    e_MODULE_ID_QM_CE_PORTAL_8,
+    e_MODULE_ID_QM_CI_PORTAL_0,
+    e_MODULE_ID_QM_CI_PORTAL_1,
+    e_MODULE_ID_QM_CI_PORTAL_2,
+    e_MODULE_ID_QM_CI_PORTAL_3,
+    e_MODULE_ID_QM_CI_PORTAL_4,
+    e_MODULE_ID_QM_CI_PORTAL_5,
+    e_MODULE_ID_QM_CI_PORTAL_6,
+    e_MODULE_ID_QM_CI_PORTAL_7,
+    e_MODULE_ID_QM_CI_PORTAL_8,
+    e_MODULE_ID_BM_CE_PORTAL_0,
+    e_MODULE_ID_BM_CE_PORTAL_1,
+    e_MODULE_ID_BM_CE_PORTAL_2,
+    e_MODULE_ID_BM_CE_PORTAL_3,
+    e_MODULE_ID_BM_CE_PORTAL_4,
+    e_MODULE_ID_BM_CE_PORTAL_5,
+    e_MODULE_ID_BM_CE_PORTAL_6,
+    e_MODULE_ID_BM_CE_PORTAL_7,
+    e_MODULE_ID_BM_CE_PORTAL_8,
+    e_MODULE_ID_BM_CI_PORTAL_0,
+    e_MODULE_ID_BM_CI_PORTAL_1,
+    e_MODULE_ID_BM_CI_PORTAL_2,
+    e_MODULE_ID_BM_CI_PORTAL_3,
+    e_MODULE_ID_BM_CI_PORTAL_4,
+    e_MODULE_ID_BM_CI_PORTAL_5,
+    e_MODULE_ID_BM_CI_PORTAL_6,
+    e_MODULE_ID_BM_CI_PORTAL_7,
+    e_MODULE_ID_BM_CI_PORTAL_8,
     e_MODULE_ID_FM1,                /**< Frame manager #1 module */
     e_MODULE_ID_FM1_MURAM,          /**< FM Multi-User-RAM */
     e_MODULE_ID_FM1_BMI,            /**< FM BMI block */
@@ -143,6 +179,8 @@ typedef enum e_ModuleId
     e_MODULE_ID_FM2_10GMAC0,        /**< FM 10G MAC #0 */
 
     e_MODULE_ID_MPIC,               /**< MPIC */
+    e_MODULE_ID_GPIO,               /**< GPIO */
+    e_MODULE_ID_SERDES,             /**< SERDES */
     e_MODULE_ID_DUMMY_LAST
 } e_ModuleId;
 
@@ -161,7 +199,6 @@ typedef enum e_TransSrc
     e_TRANS_SRC_DMA             = 0x15, /**< DMA                     */
 } e_TransSrc;
 
-
 /***************************************************************
     P4080 general routines
 ****************************************************************/
@@ -179,27 +216,76 @@ typedef enum e_TransSrc
 typedef enum e_P4080DeviceName
 {
     e_P4080_REV_INVALID   = 0x00000000,   /**< Invalid revision      */
-    e_P4080E_REV_1_0      = 0x80230010    /**< P4080E with security, revision 1.0 */
+    e_P4080E_REV_1_0      = 0x82080010    /**< P4080E with security, revision 1.0 */
 } e_P4080DeviceName;
 
+/**************************************************************************//**
+ @Description   structure representing P4080 initialization parameters
+*//***************************************************************************/
+typedef struct
+{
+    uint64_t        ccsrBaseAddress;        /**< CCSR base address (virtual) */
+    uint64_t        portalsBaseAddress;     /**< Portals base address (virtual) */
+    bool            (*f_BoardIsValidSerDesConfigurationCB) (uint8_t val);
+} t_P4080Params;
+
+/**************************************************************************//**
+ @Description   SERDES lanes activation
+*//***************************************************************************/
+typedef enum e_SerDesLaneActivation
+{
+    e_SERDES_LANE_F,                /**<  */
+    e_SERDES_LANE_H,                /**<  */
+    e_SERDES_LANE_A_B,              /**<  */
+    e_SERDES_LANE_C_D,              /**<  */
+    e_SERDES_LANE_E_F,              /**<  */
+    e_SERDES_LANE_G_H,              /**<  */
+    e_SERDES_LANE_I_J,              /**<  */
+    e_SERDES_LANE_A_B_C_D,          /**<  */
+    e_SERDES_LANE_E_F_G_H,          /**<  */
+    e_SERDES_LANE_A_B_C_D_E_F_G_H,  /**<  */
+} e_SerDesLaneActivation;
+
+/**************************************************************************//**
+ @Description   structure representing P4080 devices configuration
+*//***************************************************************************/
+typedef struct
+{
+    struct
+    {
+        struct
+        {
+            bool                    en;
+            uint8_t                 serdesBank;
+            e_SerDesLaneActivation  serdesLane;
+            bool                    sgmii;
+        } dtsecs[4];
+        struct
+        {
+            bool                    en;
+            uint8_t                 serdesBank;
+            e_SerDesLaneActivation  serdesLane;
+        } tgec;
+    } fms[2];
+} t_P4080DevParams;
 
 /**************************************************************************//**
  @Function      P4080_ConfigAndInit
 
  @Description   General initiation of the chip registers.
 
- @Param         baseAddress  - (In) memory map start
+ @Param[in]     p_P4080Params  - A pointer to data structure of parameters
 
  @Return        A handle to the P4080 data structure.
 *//***************************************************************************/
-t_Handle P4080_ConfigAndInit(uint32_t baseAddress);
+t_Handle P4080_ConfigAndInit(t_P4080Params *p_P4080Params);
 
 /**************************************************************************//**
  @Function      P4080_Free
 
  @Description   Free all resources.
 
- @Param         h_P4080 - (In) The handle of the initialized P4080 object.
+ @Param[in]     h_P4080 - The handle of the initialized P4080 object.
 
  @Return        E_OK on success; Other value otherwise.
 *//***************************************************************************/
@@ -211,20 +297,20 @@ t_Error P4080_Free(t_Handle h_P4080);
  @Description   returns the base address of a P4080 module's
                 memory mapped registers.
 
- @Param         h_P4080   - (In) The handle of the initialized P4080 object.
- @Param         module      - (In) The module ID.
+ @Param[in]     h_P4080   - The handle of the initialized P4080 object.
+ @Param[in]     module    - The module ID.
 
  @Return        Base address of module's memory mapped registers.
                 ILLEGAL_BASE in case of non-existent module
 *//***************************************************************************/
-uint32_t P4080_GetModuleBase(t_Handle h_P4080, e_ModuleId module);
+uint64_t P4080_GetModuleBase(t_Handle h_P4080, e_ModuleId module);
 
 /**************************************************************************//**
  @Function      P4080_GetRevInfo
 
  @Description   This routine enables access to chip and revision information.
 
- @Param         h_P4080 - (In) The handle of the initialized P4080 object.
+ @Param[in]     h_P4080 - The handle of the initialized P4080 object.
 
  @Return        Part ID and revision.
 *//***************************************************************************/
@@ -235,26 +321,71 @@ e_P4080DeviceName P4080_GetRevInfo(t_Handle h_P4080);
 
  @Description   returns system multiplication factor.
 
- @Param         h_P4080 - (In) a handle to the P4080 object.
- @Param         p_E500MulFactor   - (Out) returns E500 to CCB multification factor.
- @Param         p_E500DivFactor   - (Out) returns E500 to CCB division factor.
+ @Param[in]     h_P4080         - A handle to the P4080 object.
+ @Param[in]     coreIndex       - core index.
+ @Param[out]    p_E500MulFactor - returns E500 to CCB multification factor.
+ @Param[out]    p_E500DivFactor - returns E500 to CCB division factor.
 
  @Return        E_OK on success; Other value otherwise.
 *
 *//***************************************************************************/
-t_Error P4080_GetE500Factor(t_Handle h_P4080, uint32_t *p_E500MulFactor, uint32_t *p_E500DivFactor);
+t_Error P4080_GetE500Factor(t_Handle h_P4080, uint8_t coreIndex, uint32_t *p_E500MulFactor, uint32_t *p_E500DivFactor);
 
 /**************************************************************************//**
  @Function      P4080_GetCcbFactor
 
  @Description   returns system multiplication factor.
 
- @Param         h_P4080 - (In) The handle of the initialized P4080 object.
+ @Param[in]     h_P4080 - The handle of the initialized P4080 object.
 
  @Return        System multiplication factor.
 *//***************************************************************************/
 uint32_t P4080_GetCcbFactor(t_Handle h_P4080);
 
+/**************************************************************************//**
+ @Function      P4080_GetDdrFactor
+
+ @Description   returns the multiplication factor of the clock in for the DDR clock.
+
+ @Param[in]     h_P080 - a handle to the P4080 object.
+
+ @Return        System multiplication factor.
+*//***************************************************************************/
+uint32_t P4080_GetDdrFactor(t_Handle h_P4080);
+
+/**************************************************************************//**
+ @Function      P4080_GetDdrType
+
+ @Description   returns the multiplication factor of the clock in for the DDR clock .
+
+ @Param[in]     h_P080 - a handle to the P4080 object.
+ @Param[out]    p_DdrType - returns DDR type DDR2/DDR3.
+
+ @Return        E_OK on success; Other value otherwise.
+*//***************************************************************************/
+//t_Error P4080_GetDdrType(t_Handle h_P4080, e_DdrType *p_DdrType);
+
+/**************************************************************************//**
+ @Function      P4080_GetFmFactor
+
+ @Description   returns FM multiplication factors. (This value is returned using
+                two parameters to avoid using float parameter).
+
+ @Param[in]     h_P4080         - The handle of the initialized P4080 object.
+ @Param[in]     fmIndex         - fm index.
+ @Param[out]    p_FmMulFactor   - returns E500 to CCB multification factor.
+ @Param[out]    p_FmDivFactor   - returns E500 to CCB division factor.
+
+ @Return        E_OK on success; Other value otherwise.
+*//***************************************************************************/
+t_Error  P4080_GetFmFactor(t_Handle h_P4080, uint8_t fmIndex, uint32_t *p_FmMulFactor, uint32_t *p_FmDivFactor);
+
+t_Error P4080_CoreTimeBaseEnable(t_Handle h_P4080);
+t_Error P4080_CoreTimeBaseDisable(t_Handle h_P4080);
+
+t_P4080DevParams * P4080_GetDevicesConfiguration(t_Handle h_P4080);
+t_Error P4080_DeviceEnable(t_Handle h_P4080,e_ModuleId module, bool enable);
+
 /** @} */ /* end of P4080_init_grp group */
 /** @} */ /* end of P4080_grp group */
 
@@ -275,6 +406,43 @@ uint32_t P4080_GetCcbFactor(t_Handle h_P4080);
 #define MODULE_QM               0x000a0000
 #define MODULE_BM               0x000b0000
 #define MODULE_DUART            0x000c0000
+#define MODULE_SERDES           0x000d0000
+#define MODULE_PIO              0x000e0000
+
+/*****************************************************************************
+ GPIO INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define GPIO_NUM_OF_PORTS   1   /**< Number of ports in GPIO module;
+                                     Each port contains up to 32 i/O pins. */
+
+#define GPIO_VALID_PIN_MASKS  \
+    { /* Port A */ 0xFFFFFFFF }
+
+#define GPIO_VALID_INTR_MASKS \
+    { /* Port A */ 0xFFFFFFFF }
+
+
+#ifdef SIMULATOR
+#define CORE_8BIT_ACCESS_ERRATA
+#endif /* SIMULATOR */
+
+/*****************************************************************************
+ MPIC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define EPIC_MULTICORE_SUPPORT
+
+/*****************************************************************************
+ QMan INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define QMAN_WQ_CS_CFG_ERRATA
+#define QMAN_SFDR_LEAK_ERRATA
+
+/*****************************************************************************
+ SerDes INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#ifndef SIMULATOR
+#define SERDES_ERRATA
+#endif /* !SIMULATOR */
 
 /*****************************************************************************
  FM INTEGRATION-SPECIFIC DEFINITIONS
@@ -287,22 +455,96 @@ uint32_t P4080_GetCcbFactor(t_Handle h_P4080);
 #define FM_MAX_NUM_OF_1G_TX_PORTS   4
 #define FM_MAX_NUM_OF_10G_TX_PORTS  1
 #define FM_MAX_NUM_OF_TX_PORTS      (FM_MAX_NUM_OF_10G_TX_PORTS+FM_MAX_NUM_OF_1G_TX_PORTS)
-#define FM_MAX_NUM_OF_OP_PORTS      6
-#define FM_MAX_NUM_OF_HC_PORTS      1
+#define FM_MAX_NUM_OF_OH_PORTS      7
 #define FM_MAX_NUM_OF_1G_MACS       (FM_MAX_NUM_OF_1G_RX_PORTS)
 #define FM_MAX_NUM_OF_10G_MACS      (FM_MAX_NUM_OF_10G_RX_PORTS)
 #define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS+FM_MAX_NUM_OF_10G_MACS)
-#define FM_MAX_NUM_OF_PCD_PORTS     FM_MAX_NUM_OF_RX_PORTS+FM_MAX_NUM_OF_OP_PORTS
+#define FM_MAX_NUM_OF_PCD_PORTS     (FM_MAX_NUM_OF_RX_PORTS+FM_MAX_NUM_OF_OH_PORTS)
 
 #define FM_MURAM_SIZE               (160*KILOBYTE)
 #define FM_PCD_PLCR_NUM_ENTRIES     256                 /**< Total number of policer profiles */
 #define FM_PCD_KG_NUM_OF_SCHEMES    32                  /**< Total number of KG schemes */
 #define FM_PCD_MAX_NUM_OF_CLS_PLANS 256                 /**< Number of classification plan entries. */
 
+/**************************************************************************//**
+ @Description   Enum for inter-module interrupts registration
+*//***************************************************************************/
+typedef enum e_FmEventModules{
+    e_FM_MOD_PRS,                   /**< Parser event */
+    e_FM_MOD_KG,                    /**< Keygen event */
+    e_FM_MOD_PLCR,                  /**< Policer event */
+    e_FM_MOD_10G_MAC,               /**< 10G MAC  error event */
+    e_FM_MOD_1G_MAC,                /**< 1G MAC  error event */
+    e_FM_MOD_TMR,                   /**< Timer event */
+    e_FM_MOD_1G_MAC_TMR,            /**< 1G MAC  Timer event */
+    e_FM_MOD_DUMMY_LAST
+} e_FmEventModules;
+
+/**************************************************************************//**
+ @Description   Enum for interrupts types
+*//***************************************************************************/
+typedef enum e_FmIntrType {
+    e_FM_INTR_TYPE_ERR,
+    e_FM_INTR_TYPE_NORMAL
+}e_FmIntrType;
+
+#define GET_MODULE_EVENT(mod, id, intrType, event)                                                  \
+    switch(mod){                                                                                    \
+        case e_FM_MOD_PRS:                                                                          \
+            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
+            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PRS:e_FM_EV_PRS;            \
+            break;                                                                                  \
+        case e_FM_MOD_KG:                                                                           \
+            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
+            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_KG:e_FM_EV_DUMMY_LAST;      \
+            break;                                                                                  \
+        case e_FM_MOD_PLCR:                                                                         \
+            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
+            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PLCR:e_FM_EV_PLCR;          \
+            break;                                                                                  \
+        case e_FM_MOD_10G_MAC:                                                                      \
+            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
+            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_10G_MAC0:e_FM_EV_DUMMY_LAST;\
+            break;                                                                                  \
+        case e_FM_MOD_1G_MAC:                                                                       \
+            switch(id){                                                                             \
+                 case(0): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC0:e_FM_EV_DUMMY_LAST; break; \
+                 case(1): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC1:e_FM_EV_1G_MAC1; break;    \
+                 case(2): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC2:e_FM_EV_1G_MAC2; break;    \
+                 case(3): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC3:e_FM_EV_1G_MAC3; break;    \
+                 }                                                                                  \
+            break;                                                                                  \
+        case e_FM_MOD_TMR:                                                                          \
+            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
+            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_TMR;         \
+            break;                                                                                  \
+        case e_FM_MOD_1G_MAC_TMR:                                                                   \
+            switch(id){                                                                             \
+                 case(0): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC0_TMR; break; \
+                 case(1): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC1_TMR; break; \
+                 case(2): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC2_TMR; break; \
+                 case(3): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC3_TMR; break; \
+                 }                                                                                  \
+            break;                                                                                  \
+        default:event = e_FM_EV_DUMMY_LAST;                                                         \
+        break;}
+
+#ifndef SIMULATOR
+#define FM_10G_MAC_NO_CTRL_LOOPBACK
+#endif /* !SIMULATOR */
+
 /* FM erratas */
 #define FM_OP_PARTITION_ERRATA
-#define CORE_8BIT_ACCESS_ERRATA
+#ifndef SIMULATOR
 #define FM_ENET_SGMII_1000_ERRATA
+#define FM_ENET_PAUSE_FRM_ERRATA
+#define FM_MURAM_ERR_IRQ_ERRATA
+#define FM_PORT_SYNC_ERRATA
+#define FM_PRS_MEM_ERRATA
+#define BUP_FM_PORT_DISABLE_ERRATA
+#define BUP_FM_HALT_SIG_ERRATA
+#define BUP_ERRATA_RAM_INTR
+#endif /* !SIMULATOR */
 
 
 #endif /* __PART_INTEGRATION_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/integrations/part_ext.h b/drivers/net/dpa/NetCommSw/inc/integrations/part_ext.h
index b9f3f87..427f262 100644
--- a/drivers/net/dpa/NetCommSw/inc/integrations/part_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/integrations/part_ext.h
@@ -51,6 +51,7 @@
       defined(MPC8568) || \
       defined(MPC8569) || \
       defined(P4080)   || \
+      defined(P2020)   || \
       defined(MSC814x))
 #error "unable to proceed without chip-definition"
 #endif /* !(defined(MPC834x) || ... */
@@ -74,12 +75,11 @@ typedef struct t_Part
 {
     uint32_t    (* f_GetRevInfo)(t_Handle h_Part);
                 /**< Returns the revision number of the chip. */
-    uint32_t    (* f_GetModuleBase)(t_Handle h_Part, e_ModuleId moduleId);
+    uint64_t    (* f_GetModuleBase)(t_Handle h_Part, e_ModuleId moduleId);
                 /**< Returns the address of the module's memory map base. */
-    e_ModuleId  (* f_GetModuleIdByBase)(t_Handle h_Part, uint32_t baseAddress);
+    e_ModuleId  (* f_GetModuleIdByBase)(t_Handle h_Part, uint64_t baseAddress);
                 /**< Returns the module's ID according to its memory map base. */
 } t_Part;
 
 
-
 #endif /* __PART_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/ncsw_ext.h b/drivers/net/dpa/NetCommSw/inc/ncsw_ext.h
index 139ff76..4d8449f 100644
--- a/drivers/net/dpa/NetCommSw/inc/ncsw_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/ncsw_ext.h
@@ -195,10 +195,10 @@ typedef enum e_TimerMode
 *//***************************************************************************/
 typedef enum e_CommMode
 {
-      e_COMM_MODE_NONE         = 0  /**< No transmit/receive communication */
-    , e_COMM_MODE_RX           = 1  /**< Only receive communication */
-    , e_COMM_MODE_TX           = 2  /**< Only transmit communication */
-    , e_COMM_MODE_RX_AND_TX    = 3  /**< Both transmit and receive communication */
+    e_COMM_MODE_NONE        = 0,    /**< No transmit/receive communication */
+    e_COMM_MODE_RX          = 1,    /**< Only receive communication */
+    e_COMM_MODE_TX          = 2,    /**< Only transmit communication */
+    e_COMM_MODE_RX_AND_TX   = 3     /**< Both transmit and receive communication */
 } e_CommMode;
 
 /**************************************************************************//**
@@ -207,12 +207,15 @@ typedef enum e_CommMode
 typedef enum e_DiagMode
 {
     e_DIAG_MODE_NONE = 0,
-    e_DIAG_MODE_CTRL_LOOPBACK,
-    e_DIAG_MODE_PHY_LOOPBACK,
-    e_DIAG_MODE_LINE_LOOPBACK,
-    e_DIAG_MODE_CTRL_ECHO,
-    e_DIAG_MODE_PHY_ECHO
-
+    e_DIAG_MODE_CTRL_LOOPBACK,      /**< loopback in the controller; E.g. MAC, TDM, etc. */
+#ifdef P4080
+    e_DIAG_MODE_CHIP_LOOPBACK,      /**< loopback in the chip but not in controller;
+                                         E.g. IO-pins, SerDes, etc. */
+#endif /* P4080 */
+    e_DIAG_MODE_PHY_LOOPBACK,       /**< loopback in the external PHY */
+    e_DIAG_MODE_LINE_LOOPBACK,      /**< loopback in the external line */
+    e_DIAG_MODE_CTRL_ECHO,          /**< */
+    e_DIAG_MODE_PHY_ECHO            /**< */
 } e_DiagMode;
 
 /**************************************************************************//**
diff --git a/drivers/net/dpa/NetCommSw/inc/net_ext.h b/drivers/net/dpa/NetCommSw/inc/net_ext.h
index 5a6bcd8..996bd92 100644
--- a/drivers/net/dpa/NetCommSw/inc/net_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/net_ext.h
@@ -227,8 +227,11 @@ typedef uint8_t headerFieldVlan_t;
 #define NET_HEADER_FIELD_VLAN_VID                       (NET_HEADER_FIELD_VLAN_VPRI << 2)
 #define NET_HEADER_FIELD_VLAN_LENGTH                    (NET_HEADER_FIELD_VLAN_VPRI << 3)
 #define NET_HEADER_FIELD_VLAN_TYPE                      (NET_HEADER_FIELD_VLAN_VPRI << 4)
-#define NET_HEADER_FIELD_VLAN_TCI                       (NET_HEADER_FIELD_VLAN_VPRI << 5)
-#define NET_HEADER_FIELD_VLAN_ALL_FIELDS                ((NET_HEADER_FIELD_VLAN_VPRI << 6) - 1)
+#define NET_HEADER_FIELD_VLAN_ALL_FIELDS                ((NET_HEADER_FIELD_VLAN_VPRI << 5) - 1)
+
+#define NET_HEADER_FIELD_VLAN_TCI                       (NET_HEADER_FIELD_VLAN_VPRI | \
+                                                         NET_HEADER_FIELD_VLAN_CFI | \
+                                                         NET_HEADER_FIELD_VLAN_VID)
 
 
 typedef uint8_t headerFieldLlc_t;
diff --git a/drivers/net/dpa/NetCommSw/integrations/P4080/P4080.c b/drivers/net/dpa/NetCommSw/integrations/P4080/P4080.c
deleted file mode 100644
index d2474ff..0000000
--- a/drivers/net/dpa/NetCommSw/integrations/P4080/P4080.c
+++ /dev/null
@@ -1,157 +0,0 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "error_ext.h"
-#include "std_ext.h"
-#include "string_ext.h"
-#include "part_ext.h"
-#include "xx_ext.h"
-
-#include "P4080.h"
-
-
-/*****************************************************************************/
-static e_ModuleId GetModuleIdByBase(t_Handle h_P4080, uint32_t baseAddress)
-{
-    t_P4080   *p_P4080 = (t_P4080 *)h_P4080;
-    e_ModuleId  moduleId;
-
-    SANITY_CHECK_RETURN_VALUE(p_P4080, E_INVALID_HANDLE, e_MODULE_ID_DUMMY_LAST);
-
-    for (moduleId = (e_ModuleId)0; moduleId < e_MODULE_ID_DUMMY_LAST; moduleId++)
-    {
-        if (baseAddress == p_P4080->baseAddresses[moduleId])
-        {
-            return moduleId;
-        }
-    }
-
-    return e_MODULE_ID_DUMMY_LAST;
-}
-
-
-/*****************************************************************************/
-t_Handle P4080_ConfigAndInit(uint32_t baseAddress)
-{
-    t_P4080   *p_P4080;
-    t_Error     errCode;
-
-    p_P4080 = (t_P4080 *)XX_Malloc(sizeof(t_P4080));
-    if (!p_P4080)
-    {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("P4080 driver structure"));
-        return NULL;
-    }
-
-    memset(p_P4080, 0, sizeof(t_P4080));
-
-    /* Initialize 'part' parameters with P4080 parameters and service routines. */
-    ((t_Part *)p_P4080)->f_GetModuleBase = P4080_GetModuleBase;
-    ((t_Part *)p_P4080)->f_GetModuleIdByBase = GetModuleIdByBase;
-    ((t_Part *)p_P4080)->f_GetRevInfo = (t_RevInfoCallback *)P4080_GetRevInfo;
-
-    errCode = P4080_MngInit(p_P4080, baseAddress);
-    if (errCode != E_OK)
-    {
-        P4080_Free(p_P4080);
-        REPORT_ERROR(MAJOR, errCode, NO_MSG);
-        return NULL;
-    }
-
-    return p_P4080;
-}
-
-/*****************************************************************************/
-t_Error P4080_Free(t_Handle h_P4080)
-{
-    t_P4080 *p_P4080 = (t_P4080 *)h_P4080;
-
-    SANITY_CHECK_RETURN_ERROR(p_P4080, E_INVALID_HANDLE);
-
-    P4080_MngFree(p_P4080);
-
-    XX_Free(p_P4080);
-
-    return E_OK;
-}
-
-/*****************************************************************************/
-uint32_t P4080_GetModuleBase(t_Handle h_P4080, e_ModuleId module)
-{
-    t_P4080 *p_P4080 = (t_P4080 *)h_P4080;
-
-    SANITY_CHECK_RETURN_VALUE(p_P4080, E_INVALID_HANDLE, 0);
-
-    return p_P4080->baseAddresses[module];
-}
-
-/*****************************************************************************/
-uint32_t P4080_GetPramSize(t_Handle h_P4080)
-{
-    SANITY_CHECK_RETURN_VALUE(h_P4080, E_INVALID_HANDLE, 0);
-
-    UNUSED(h_P4080);
-    return FM_MURAM_SIZE;
-}
-
-/*****************************************************************************/
-e_P4080DeviceName P4080_GetRevInfo(t_Handle h_P4080)
-{
-    t_P4080  *p_P4080 = (t_P4080 *)h_P4080;
-
-    SANITY_CHECK_RETURN_VALUE(p_P4080, E_INVALID_HANDLE, e_P4080_REV_INVALID);
-
-    REPORT_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
-    return e_P4080_REV_INVALID;
-}
-
-/*****************************************************************************/
-t_Error P4080_GetE500Factor(t_Handle h_P4080, uint32_t *p_E500MulFactor, uint32_t *p_E500DivFactor)
-{
-    t_P4080   *p_P4080 = (t_P4080 *)h_P4080;
-
-    SANITY_CHECK_RETURN_ERROR(p_P4080, E_INVALID_HANDLE);
-
-    *p_E500MulFactor = 8;
-    *p_E500DivFactor = 3;
-    return E_OK;
-}
-
-/*****************************************************************************/
-uint32_t P4080_GetCcbFactor(t_Handle h_P4080)
-{
-    t_P4080   *p_P4080 = (t_P4080 *)h_P4080;
-
-    SANITY_CHECK_RETURN_VALUE(p_P4080, E_INVALID_HANDLE, 0);
-
-    return 8;
-}
diff --git a/drivers/net/dpa/NetCommSw/integrations/P4080/P4080.h b/drivers/net/dpa/NetCommSw/integrations/P4080/P4080.h
deleted file mode 100644
index 0e00dc1..0000000
--- a/drivers/net/dpa/NetCommSw/integrations/P4080/P4080.h
+++ /dev/null
@@ -1,166 +0,0 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
- /**************************************************************************//**
-
- @File          P4080.h
-
- @Description   P4080 object data structure declaration, definitions and internal prototypes.
-*//***************************************************************************/
-
-#ifndef __P4080_H
-#define __P4080_H
-
-#include "std_ext.h"
-#include "part_ext.h"
-
-
-#define __ERR_MODULE__  MODULE_P4080
-
-#ifdef __MWERKS__
-#pragma pack(push,1)
-#endif /* __MWERKS__ */
-#define MEM_MAP_START
-
-typedef _Packed struct
-{
-    /* system configuration module */
-    volatile uint32_t tbd;    /**< tbd */
-} _PackedType t_P4080SysCfgMemMap;
-
-#define MEM_MAP_END
-#ifdef __MWERKS__
-#pragma pack(pop)
-#endif /* __MWERKS__ */
-
-
-/* Offsets relative to larger memory map, with base IMMRBAR */
-#define DUART0_OFFSET           0x0011c500
-#define DUART1_OFFSET           0x0011c600
-#define DUART2_OFFSET           0x0011d500
-#define DUART3_OFFSET           0x0011d600
-#define QM_OFFSET               0x00318000
-#define BM_OFFSET               0x0031a000
-#define FM1_OFFSET              0x00400000
-#define FM2_OFFSET              0x00500000
-#define MPIC_OFFSET             0x00040000
-
-/* Offsets relative to FM_BASE_OFFSET off of base IMMRBAR */
-#define FM_MURAM_OFFSET         0x00000000
-#define FM_BMI_OFFSET           0x00080000
-#define FM_QMI_OFFSET           0x00080400
-#define FM_PRS_OFFSET           0x00080800
-#define FM_PORT_HO0_OFFSET      0x00081000
-#define FM_PORT_HO1_OFFSET      0x00082000
-#define FM_PORT_HO2_OFFSET      0x00083000
-#define FM_PORT_HO3_OFFSET      0x00084000
-#define FM_PORT_HO4_OFFSET      0x00085000
-#define FM_PORT_HO5_OFFSET      0x00086000
-#define FM_PORT_HO6_OFFSET      0x00087000
-#define FM_PORT_1GRX0_OFFSET    0x00088000
-#define FM_PORT_1GRX1_OFFSET    0x00089000
-#define FM_PORT_1GRX2_OFFSET    0x0008a000
-#define FM_PORT_1GRX3_OFFSET    0x0008b000
-#define FM_PORT_10GRX0_OFFSET   0x00090000
-#define FM_PORT_1GTX0_OFFSET    0x000a8000
-#define FM_PORT_1GTX1_OFFSET    0x000a9000
-#define FM_PORT_1GTX2_OFFSET    0x000aa000
-#define FM_PORT_1GTX3_OFFSET    0x000ab000
-#define FM_PORT_10GTX0_OFFSET   0x000b0000
-#define FM_PLCR_OFFSET          0x000c0000
-#define FM_KG_OFFSET            0x000c1000
-#define FM_DMA_OFFSET           0x000c2000
-#define FM_FPM_OFFSET           0x000c3000
-#define FM_IRAM_OFFSET          0x000c4000
-#define FM_PRS_IRAM_OFFSET      0x000c7000
-#define FM_RISC0_OFFSET         0x000d0000
-#define FM_RISC1_OFFSET         0x000d1000
-#define FM_1GMAC0_OFFSET        0x000e0000
-#define FM_1GMDIO0_OFFSET       0x000e1000
-#define FM_1GMAC1_OFFSET        0x000e2000
-#define FM_1GMDIO1_OFFSET       0x000e3000
-#define FM_1GMAC2_OFFSET        0x000e4000
-#define FM_1GMDIO2_OFFSET       0x000e5000
-#define FM_1GMAC3_OFFSET        0x000e6000
-#define FM_1GMDIO3_OFFSET       0x000e7000
-#define FM_10GMAC0_OFFSET       0x000f0000
-#define FM_10GMDIO_OFFSET       0x000f1000
-
-//#define FM_MURAM_SIZE 0x40000
-
-#define BM_PORTALS_CE_OFFSET    0x000000
-#define BM_PORTALS_CI_OFFSET    0x100000
-#define QM_PORTALS_CE_OFFSET    0x200000
-#define QM_PORTALS_CI_OFFSET    0x300000
-
-#define QM_PORTALS_OFFSET_CE(portal)    (0x4000 * portal)
-#define QM_PORTALS_OFFSET_CI(portal)    (0x1000 * portal)
-#define BM_PORTALS_OFFSET_CE(portal)    (0x4000 * portal)
-#define BM_PORTALS_OFFSET_CI(portal)    (0x1000 * portal)
-
-
-/*--------------------------------------*/
-/* Structure for the P4080 object.    */
-/*--------------------------------------*/
-typedef struct
-{
-    t_Part                  part;               /**< Common parameters for all parts */
-    uint32_t                baseAddresses[NUM_OF_MODULES];
-                                                /**< Modules offsets in memory map */
-} t_P4080;
-
-
-/**************************************************************************//**
- @Function      P4080_MngInit
-
- @Description   Initializes the P4080 module's managment unit.
-
- @Param         p_P4080   - (in) Pointer to the P4080 control structure.
- @Param         baseAddress - (in) Base address of the memory-map.
-
- @Return        E_OK on success, other value otherwise.
-*//***************************************************************************/
-t_Error P4080_MngInit(t_P4080 *p_P4080, uint32_t baseAddress);
-
-/**************************************************************************//**
- @Function      P4080_MngFree
-
- @Description   Free the P4080 module's managment unit.
-
- @Param         p_P4080 - (in) Pointer to the P4080 control structure.
-
- @Return        E_OK on success, other value otherwise.
-*//***************************************************************************/
-t_Error P4080_MngFree(t_P4080 *p_P4080);
-
-
-#endif /* __P4080_H */
diff --git a/drivers/net/dpa/NetCommSw/integrations/P4080/P4080_mng.c b/drivers/net/dpa/NetCommSw/integrations/P4080/P4080_mng.c
deleted file mode 100644
index b686e4c..0000000
--- a/drivers/net/dpa/NetCommSw/integrations/P4080/P4080_mng.c
+++ /dev/null
@@ -1,150 +0,0 @@
-/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "string_ext.h"
-#include "error_ext.h"
-#include "std_ext.h"
-#include "xx_ext.h"
-
-#include "P4080.h"
-
-
-/*****************************************************************************/
-t_Error P4080_MngInit(t_P4080 *p_P4080, uint32_t baseAddress)
-{
-    uint32_t tmpBaseAddr = baseAddress;
-
-    /* Initialize base addresses to ILLEGAL_BASE */
-    memset(p_P4080->baseAddresses, (~0), NUM_OF_MODULES * sizeof(uint32_t));
-
-    /* init base addresses for all part's modules */
-    p_P4080->baseAddresses[e_MODULE_ID_DUART_1]   = tmpBaseAddr + DUART0_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_DUART_2]   = tmpBaseAddr + DUART1_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_DUART_3]   = tmpBaseAddr + DUART2_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_DUART_4]   = tmpBaseAddr + DUART3_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_QM]        = tmpBaseAddr + QM_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_BM]        = tmpBaseAddr + BM_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_MPIC]      = tmpBaseAddr + MPIC_OFFSET;
-
-    tmpBaseAddr = baseAddress + FM1_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1]               = tmpBaseAddr;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_MURAM]         = tmpBaseAddr + FM_MURAM_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_BMI]           = tmpBaseAddr + FM_BMI_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_QMI]           = tmpBaseAddr + FM_QMI_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_PRS]           = tmpBaseAddr + FM_PRS_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_HO0]      = tmpBaseAddr + FM_PORT_HO0_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_HO1]      = tmpBaseAddr + FM_PORT_HO1_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_HO2]      = tmpBaseAddr + FM_PORT_HO2_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_HO3]      = tmpBaseAddr + FM_PORT_HO3_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_HO4]      = tmpBaseAddr + FM_PORT_HO4_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_HO5]      = tmpBaseAddr + FM_PORT_HO5_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_HO6]      = tmpBaseAddr + FM_PORT_HO6_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_1GRx0]    = tmpBaseAddr + FM_PORT_1GRX0_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_1GRx1]    = tmpBaseAddr + FM_PORT_1GRX1_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_1GRx2]    = tmpBaseAddr + FM_PORT_1GRX2_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_1GRx3]    = tmpBaseAddr + FM_PORT_1GRX3_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_10GRx0]   = tmpBaseAddr + FM_PORT_10GRX0_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_1GTx0]    = tmpBaseAddr + FM_PORT_1GTX0_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_1GTx1]    = tmpBaseAddr + FM_PORT_1GTX1_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_1GTx2]    = tmpBaseAddr + FM_PORT_1GTX2_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_1GTx3]    = tmpBaseAddr + FM_PORT_1GTX3_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_PORT_10GTx0]   = tmpBaseAddr + FM_PORT_10GTX0_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_PLCR]          = tmpBaseAddr + FM_PLCR_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_KG]            = tmpBaseAddr + FM_KG_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_DMA]           = tmpBaseAddr + FM_DMA_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_FPM]           = tmpBaseAddr + FM_FPM_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_IRAM]          = tmpBaseAddr + FM_IRAM_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_1GMDIO0]       = tmpBaseAddr + FM_1GMDIO0_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_1GMDIO1]       = tmpBaseAddr + FM_1GMDIO1_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_1GMDIO2]       = tmpBaseAddr + FM_1GMDIO2_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_1GMDIO3]       = tmpBaseAddr + FM_1GMDIO3_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_10GMDIO]       = tmpBaseAddr + FM_10GMDIO_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_PRS_IRAM]      = tmpBaseAddr + FM_PRS_IRAM_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_RISC0]         = tmpBaseAddr + FM_RISC0_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_RISC1]         = tmpBaseAddr + FM_RISC1_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_1GMAC0]        = tmpBaseAddr + FM_1GMAC0_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_1GMAC1]        = tmpBaseAddr + FM_1GMAC1_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_1GMAC2]        = tmpBaseAddr + FM_1GMAC2_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_1GMAC3]        = tmpBaseAddr + FM_1GMAC3_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM1_10GMAC0]       = tmpBaseAddr + FM_10GMAC0_OFFSET;
-
-    tmpBaseAddr = baseAddress + FM2_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2]               = tmpBaseAddr;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_MURAM]         = tmpBaseAddr + FM_MURAM_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_BMI]           = tmpBaseAddr + FM_BMI_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_QMI]           = tmpBaseAddr + FM_QMI_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_PRS]           = tmpBaseAddr + FM_PRS_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_HO0]      = tmpBaseAddr + FM_PORT_HO0_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_HO1]      = tmpBaseAddr + FM_PORT_HO1_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_HO2]      = tmpBaseAddr + FM_PORT_HO2_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_HO3]      = tmpBaseAddr + FM_PORT_HO3_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_HO4]      = tmpBaseAddr + FM_PORT_HO4_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_HO5]      = tmpBaseAddr + FM_PORT_HO5_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_HO6]      = tmpBaseAddr + FM_PORT_HO6_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_1GRx0]    = tmpBaseAddr + FM_PORT_1GRX0_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_1GRx1]    = tmpBaseAddr + FM_PORT_1GRX1_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_1GRx2]    = tmpBaseAddr + FM_PORT_1GRX2_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_1GRx3]    = tmpBaseAddr + FM_PORT_1GRX3_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_10GRx0]   = tmpBaseAddr + FM_PORT_10GRX0_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_1GTx0]    = tmpBaseAddr + FM_PORT_1GTX0_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_1GTx1]    = tmpBaseAddr + FM_PORT_1GTX1_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_1GTx2]    = tmpBaseAddr + FM_PORT_1GTX2_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_1GTx3]    = tmpBaseAddr + FM_PORT_1GTX3_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_PORT_10GTx0]   = tmpBaseAddr + FM_PORT_10GTX0_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_PLCR]          = tmpBaseAddr + FM_PLCR_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_KG]            = tmpBaseAddr + FM_KG_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_DMA]           = tmpBaseAddr + FM_DMA_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_FPM]           = tmpBaseAddr + FM_FPM_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_IRAM]          = tmpBaseAddr + FM_IRAM_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_1GMDIO0]       = tmpBaseAddr + FM_1GMDIO0_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_1GMDIO1]       = tmpBaseAddr + FM_1GMDIO1_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_1GMDIO2]       = tmpBaseAddr + FM_1GMDIO2_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_1GMDIO3]       = tmpBaseAddr + FM_1GMDIO3_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_10GMDIO]       = tmpBaseAddr + FM_10GMDIO_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_PRS_IRAM]      = tmpBaseAddr + FM_PRS_IRAM_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_RISC0]         = tmpBaseAddr + FM_RISC0_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_RISC1]         = tmpBaseAddr + FM_RISC1_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_1GMAC0]        = tmpBaseAddr + FM_1GMAC0_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_1GMAC1]        = tmpBaseAddr + FM_1GMAC1_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_1GMAC2]        = tmpBaseAddr + FM_1GMAC2_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_1GMAC3]        = tmpBaseAddr + FM_1GMAC3_OFFSET;
-    p_P4080->baseAddresses[e_MODULE_ID_FM2_10GMAC0]       = tmpBaseAddr + FM_10GMAC0_OFFSET;
-
-    return E_OK;
-}
-
-/*****************************************************************************/
-t_Error P4080_MngFree(t_P4080 *p_P4080)
-{
-    UNUSED(p_P4080);
-    return E_OK;
-}
diff --git a/drivers/net/dpa/NetCommSw/integrations/P4080/module_strings.c b/drivers/net/dpa/NetCommSw/integrations/P4080/module_strings.c
index 16d0429..03d0cd2 100644
--- a/drivers/net/dpa/NetCommSw/integrations/P4080/module_strings.c
+++ b/drivers/net/dpa/NetCommSw/integrations/P4080/module_strings.c
@@ -45,4 +45,5 @@ const char *moduleStrings[] =
     ,"FM"                       /* MODULE_FM */
     ,"QM"                       /* MODULE_QM */
     ,"BM"                       /* MODULE_BM */
+    ,"DUART"                    /* MODULE_DUART */
 };
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h
index 95abf75..90a7837 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_ioctls.h
@@ -54,9 +54,8 @@
 
 #define DEV_FM_MINOR_BASE           0
 #define DEV_FM_PCD_MINOR_BASE       (DEV_FM_MINOR_BASE + 1)
-#define DEV_FM_HC_PORT_MINOR_BASE   (DEV_FM_PCD_MINOR_BASE + 1)
-#define DEV_FM_OP_PORTS_MINOR_BASE  (DEV_FM_HC_PORT_MINOR_BASE + 1)
-#define DEV_FM_RX_PORTS_MINOR_BASE  (DEV_FM_OP_PORTS_MINOR_BASE + 6)
+#define DEV_FM_OH_PORTS_MINOR_BASE  (DEV_FM_PCD_MINOR_BASE + 1)
+#define DEV_FM_RX_PORTS_MINOR_BASE  (DEV_FM_OH_PORTS_MINOR_BASE + 7)
 #define DEV_FM_TX_PORTS_MINOR_BASE  (DEV_FM_RX_PORTS_MINOR_BASE + 5)
 #define DEV_FM_MAX_MINORS           (DEV_FM_TX_PORTS_MINOR_BASE + 5)
 
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h
index 170a2fa..f5f3b77 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_pcd_ioctls.h
@@ -231,6 +231,9 @@ typedef struct ioc_fm_pcd_prs_sw_params_t {
                                                              umOfLabels entries */
 } ioc_fm_pcd_prs_sw_params_t;
 
+/**************************************************************************//**
+ @Description   A structure to set the a KeyGen default value
+ *//***************************************************************************/
 typedef struct ioc_fm_pcd_kg_dflt_value_params_t {
     uint8_t                         valueId;                /**< 0,1 - one of 2 global default values */
     uint32_t                        value;                  /**< The requested default value */
@@ -323,7 +326,7 @@ typedef struct ioc_fm_pcd_kg_dflt_value_params_t {
                 field/header.
                 By default default values are 0.
 
- @Param[in]     ioc_fm_pcd_kg_dflt_value_params_t   TBD
+ @Param[in]     ioc_fm_pcd_kg_dflt_value_params_t   A pointer to a structure with the relevant parameters
 
  @Return        E_OK on success; Error code otherwise.
 
@@ -1125,7 +1128,7 @@ typedef struct ioc_fm_pcd_plcr_profile_params_t {
 } ioc_fm_pcd_plcr_profile_params_t;
 
 /**************************************************************************//**
- @Description   TBD
+ @Description   A structure for modifying CC tree next engine
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_cc_tree_modify_next_engine_params_t {
     void                                *id;                /**< CC tree Id to be used */
@@ -1136,7 +1139,7 @@ typedef struct ioc_fm_pcd_cc_tree_modify_next_engine_params_t {
 } ioc_fm_pcd_cc_tree_modify_next_engine_params_t;
 
 /**************************************************************************//**
- @Description   TBD
+ @Description   A structure for modifying CC node next engine
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_cc_node_modify_next_engine_params_t {
     void                                *id;                /**< CC node Id to be used */
@@ -1148,7 +1151,7 @@ typedef struct ioc_fm_pcd_cc_node_modify_next_engine_params_t {
 } ioc_fm_pcd_cc_node_modify_next_engine_params_t;
 
 /**************************************************************************//**
- @Description   TBD
+ @Description   A structure for modifying CC node key and next engine
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t {
     void                                *id;                /**< CC node Id to be used */
@@ -1160,7 +1163,7 @@ typedef struct ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t {
 } ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t;
 
 /**************************************************************************//**
- @Description   TBD
+ @Description   A structure for remove CC node key
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_cc_node_remove_key_params_t {
     void                                *id;                /**< CC node Id to be used */
@@ -1169,7 +1172,7 @@ typedef struct ioc_fm_pcd_cc_node_remove_key_params_t {
 } ioc_fm_pcd_cc_node_remove_key_params_t;
 
 /**************************************************************************//**
- @Description   TBD
+ @Description   A structure for modifying CC node key
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_cc_node_modify_key_params_t {
     void                                *id;                /**< CC node Id to be used */
@@ -1371,7 +1374,7 @@ typedef struct ioc_fm_pcd_cc_node_modify_key_params_t {
 
  @Description   Modify the Next Engine Parameters in the entry of the tree.
 
- @Param[in]     ioc_fm_pcd_cc_tree_modify_next_engine_params_t  TBD
+ @Param[in]     ioc_fm_pcd_cc_tree_modify_next_engine_params_t  A pointer to a structure with the relevant parameters
 
  @Return        E_OK on success; Error code otherwise.
 
@@ -1384,7 +1387,7 @@ typedef struct ioc_fm_pcd_cc_node_modify_key_params_t {
 
  @Description   Modify the Next Engine Parameters in the relevent key entry of the node.
 
- @Param[in]     ioc_fm_pcd_cc_node_modify_next_engine_params_t  TBD
+ @Param[in]     ioc_fm_pcd_cc_node_modify_next_engine_params_t  A pointer to a structure with the relevant parameters
 
  @Return        E_OK on success; Error code otherwise.
 
@@ -1397,7 +1400,7 @@ typedef struct ioc_fm_pcd_cc_node_modify_key_params_t {
 
  @Description   Modify the Next Engine Parameters of the Miss key case of the node.
 
- @Param[in]     ioc_fm_pcd_cc_node_modify_next_engine_params_t  TBD
+ @Param[in]     ioc_fm_pcd_cc_node_modify_next_engine_params_t  A pointer to a structure with the relevant parameters
 
  @Return        E_OK on success; Error code otherwise.
 
@@ -1410,7 +1413,7 @@ typedef struct ioc_fm_pcd_cc_node_modify_key_params_t {
 
  @Description   Remove the key (include Next Engine Parameters of this key) defined by the index of the relevant node .
 
- @Param[in]     ioc_fm_pcd_cc_node_remove_key_params_t  TBD
+ @Param[in]     ioc_fm_pcd_cc_node_remove_key_params_t  A pointer to a structure with the relevant parameters
 
  @Return        E_OK on success; Error code otherwise.
 
@@ -1424,7 +1427,7 @@ typedef struct ioc_fm_pcd_cc_node_modify_key_params_t {
 
  @Description   Add the key(include Next Engine Parameters of this key)in the index defined by the keyIndex .
 
- @Param[in]     ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  TBD
+ @Param[in]     ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  A pointer to a structure with the relevant parameters
 
  @Return        E_OK on success; Error code otherwise.
 
@@ -1438,7 +1441,7 @@ typedef struct ioc_fm_pcd_cc_node_modify_key_params_t {
 
  @Description   Modify the key and Next Engine Parameters of this key in the index defined by the keyIndex .
 
- @Param[in]     ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  TBD
+ @Param[in]     ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t  A pointer to a structure with the relevant parameters
 
  @Return        E_OK on success; Error code otherwise.
 
@@ -1452,7 +1455,7 @@ typedef struct ioc_fm_pcd_cc_node_modify_key_params_t {
 
  @Description   Modify the key  in the index defined by the keyIndex .
 
- @Param[in]     ioc_fm_pcd_cc_node_modify_key_params_t  TBD
+ @Param[in]     ioc_fm_pcd_cc_node_modify_key_params_t  A pointer to a structure with the relevant parameters
 
  @Return        E_OK on success; Error code otherwise.
 
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_port_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_port_ioctls.h
index 4027dac..087eade 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_port_ioctls.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_port_ioctls.h
@@ -275,7 +275,10 @@ typedef struct ioc_fm_pcd_prs_additional_hdr_params_t {
     bool                        err_disable;        /**< TRUE to disable error indication */
     bool                        soft_prs_enable;    /**< Enable jump to SW parser when this
                                                          header is recognized by the HW parser. */
-    char                        *soft_prs_label;    /**< Label of SW parser to jump to. */
+    uint8_t                     index_per_hdr;      /**< Normally 0, if more than one sw parser
+                                                         attachments exists for the same header,
+                                                         (in the main sw parser code) use this
+                                                         index to distinguish between them. */
     bool                        use_prs_opts;       /**< TRUE to use parser options. */
     ioc_fm_pcd_hdr_prs_opts_u   prs_opts;           /**< A unuion according to header type,
                                                          defining the parser options selected.*/
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_test_ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_test_ioctls.h
index 848ba0f..7cb27c3 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_test_ioctls.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/Peripherals/fm_test_ioctls.h
@@ -52,7 +52,7 @@
 #define IOC_FMT_MAX_NUM_OF_PORTS        24
 
 /**************************************************************************//**
- @Collection    TBD
+ @Collection    TEST Parameters
 *//***************************************************************************/
 /**************************************************************************//**
   @Description: Name of the FM-Test chardev
@@ -68,19 +68,19 @@
 /**************************************************************************//**
  @Group         lnx_ioctl_FMT_lib_grp FM-Test library
 
- @Description   TBD
+ @Description   TODO
 
  @{
 *//***************************************************************************/
 
 /**************************************************************************//**
- @Description   TBD
+ @Description   TODO
 *//***************************************************************************/
 typedef uint8_t ioc_fmt_xxx_t;
 
 
 /**************************************************************************//**
- @Description   TBD
+ @Description   FM Port buffer content description
 *//***************************************************************************/
 typedef struct ioc_fmt_buff_context_t {
     void            *p_user_priv;
@@ -90,7 +90,7 @@ typedef struct ioc_fmt_buff_context_t {
 
 
 /**************************************************************************//**
- @Description   TBD
+ @Description   Buffer descriptor
 *//***************************************************************************/
 typedef struct ioc_fmt_buff_desc_t {
     uint32_t               qid;
@@ -104,7 +104,7 @@ typedef struct ioc_fmt_buff_desc_t {
 /**************************************************************************//**
  @Group         lnx_ioctl_FMT_runtime_control_grp FM-Test Runtime Control Unit
 
- @Description   TBD
+ @Description   TODO
  @{
 *//***************************************************************************/
 
@@ -114,13 +114,13 @@ typedef struct ioc_fmt_buff_desc_t {
 /**************************************************************************//**
  @Group         lnx_ioctl_FMTP_lib_grp FM-Port-Test library
 
- @Description   TBD
+ @Description   TODO
 
  @{
 *//***************************************************************************/
 
 /**************************************************************************//**
- @Description   FM-Test TBD
+ @Description   FM-Test FM port type
 *//***************************************************************************/
 typedef enum ioc_fmt_port_type {
     e_IOC_FMT_PORT_T_RXTX,  /**< Standard port */
@@ -128,7 +128,7 @@ typedef enum ioc_fmt_port_type {
 } ioc_fmt_port_type;
 
 /**************************************************************************//**
- @Description   TBD
+ @Description   TODO
 *//***************************************************************************/
 typedef struct ioc_fmt_port_param_t {
     uint8_t             fm_id;
@@ -141,15 +141,35 @@ typedef struct ioc_fmt_port_param_t {
 /**************************************************************************//**
  @Function      FMT_PORT_IOC_INIT
 
- @Description   TBD
+ @Description   TODO
 
- @Param[in]    ioc_fmt_port_param_t  TBD
+ @Param[in]     ioc_fmt_port_param_t  TODO
 
- @Return        None.
+ @Cautions      Allowed only after the FM equivalent port is already initialized.
+*//***************************************************************************/
+#define FMT_PORT_IOC_INIT           _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(0), ioc_fmt_port_param_t)
+
+/**************************************************************************//**
+ @Function      FMT_PORT_IOC_SET_DIAG_MODE
+
+ @Description   TODO
+
+ @Param[in]     ioc_diag_mode  TODO
+
+ @Cautions      Allowed only following FMT_PORT_IOC_INIT().
+*//***************************************************************************/
+#define FMT_PORT_IOC_SET_DIAG_MODE  _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(1), ioc_diag_mode)
+
+/**************************************************************************//**
+ @Function      FMT_PORT_IOC_SET_IP_HEADER_MANIP
+
+ @Description   Set IP header manipulations for this port.
+
+ @Param[in]     int     1 to enable; 0 to disable
 
- @Cautions      Allowed only following FM_Init().
+ @Cautions      Allowed only following FMT_PORT_IOC_INIT().
 *//***************************************************************************/
-#define FMT_PORT_IOC_INIT   _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(0), ioc_fmt_port_param_t)
+#define FMT_PORT_IOC_SET_IP_HEADER_MANIP  _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(2), int)
 
 /** @} */ /* end of lnx_ioctl_FMTP_lib_grp group */
 /** @} */ /* end of lnx_ioctl_FMT_lib_grp group */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/ioctls.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/ioctls.h
index 151a0f4..f138450 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/ioctls.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/ioctl/ioctls.h
@@ -49,11 +49,8 @@
  @{
 *//***************************************************************************/
 
-/**************************************************************************//**
- @Collection    TBD
-*//***************************************************************************/
-#define NCSW_IOC_TYPE_BASE          0xe0
-/* @} */
+#define NCSW_IOC_TYPE_BASE          0xe0    /**< defines the IOCTL type for all
+                                                 the NCSW Linux module commands */
 
 
 /**************************************************************************//**
@@ -78,6 +75,21 @@ typedef enum ioc_comm_mode {
     , e_IOC_COMM_MODE_RX_AND_TX    = 3  /**< Both transmit and receive communication */
 } ioc_comm_mode;
 
+/**************************************************************************//**
+ @Description   General Diagnostic Mode
+*//***************************************************************************/
+typedef enum ioc_diag_mode
+{
+    e_IOC_DIAG_MODE_NONE = 0,
+    e_IOC_DIAG_MODE_CTRL_LOOPBACK,      /**< loopback in the controller; E.g. MAC, TDM, etc. */
+    e_IOC_DIAG_MODE_CHIP_LOOPBACK,      /**< loopback in the chip but not in controller;
+                                         E.g. IO-pins, SerDes, etc. */
+    e_IOC_DIAG_MODE_PHY_LOOPBACK,       /**< loopback in the external PHY */
+    e_IOC_DIAG_MODE_LINE_LOOPBACK,      /**< loopback in the external line */
+    e_IOC_DIAG_MODE_CTRL_ECHO,          /**< */
+    e_IOC_DIAG_MODE_PHY_ECHO            /**< */
+} ioc_diag_mode;
+
 /** @} */ /* end of lnx_ioctl_ncsw_grp */
 
 
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/procbuff_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/procbuff_ext.h
index e4f9898..d50ffb0 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/procbuff_ext.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/procbuff_ext.h
@@ -35,7 +35,7 @@
 
  @Author        Eran Liberty
 
- @Description   TBD
+ @Description   TODO
 *//***************************************************************************/
 #ifndef __PROCBUFF_EXT_H
 #define __PROCBUFF_EXT_H
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_ext.h
index d25f3d7..5dcef2d 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_ext.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/platform_ext.h
@@ -42,7 +42,6 @@
 #include "std_ext.h"
 #include "sys_ext.h"
 
-
 /**************************************************************************//**
  @Group         platform_grp PLATFORM Application Programming Interface
 
@@ -54,6 +53,7 @@
 
 #define MAX_CHIP_NAME_LEN   9   /* (including null character) */
 
+#define PLATFORM_IO_MODE_ANY    (-1)    /**< Unspecified I/O mode */
 
 /**************************************************************************//**
  @Description   Cache Operation Mode
@@ -100,6 +100,76 @@ typedef struct t_ChipRevInfo
                     /**< Minor chip revision */
 } t_ChipRevInfo;
 
+/**************************************************************************//**
+ @Description   Platform Events
+*//***************************************************************************/
+typedef enum e_PlatformEvent
+{
+    e_PLATFORM_EVENT_LINK_DOWN, /**< Link-up event */
+    e_PLATFORM_EVENT_LINK_UP    /**< Link-down event */
+
+} e_PlatformEvent;
+
+/**************************************************************************//**
+ @Description   Callback Function Prototype for Link Events
+*//***************************************************************************/
+typedef void (t_PlatformLinkEventsCb)(t_Handle          h_Controller,
+                                      uint8_t           linkId,
+                                      e_PlatformEvent   event);
+
+
+
+/**************************************************************************//**
+ @Description   Interrupt Source Types
+*//***************************************************************************/
+typedef enum e_InterruptType
+{
+    e_INTR_TYPE_GENERAL,
+    e_INTR_TYPE_IRQ,
+    e_INTR_TYPE_ERR,
+    e_INTR_TYPE_GTIMERS_TIMER,
+    e_INTR_TYPE_RTC_COUNT,
+    e_INTR_TYPE_RTC_ALARM,
+    e_INTR_TYPE_PCI_IRQ,
+    e_INTR_TYPE_PCI_PME,
+    e_INTR_TYPE_PCI_MSI,
+    e_INTR_TYPE_ETSEC_TX,
+    e_INTR_TYPE_ETSEC_RX,
+    e_INTR_TYPE_ETSEC_ERROR,
+    e_INTR_TYPE_RIO_PW,
+    e_INTR_TYPE_RIO_DB_OUT,
+    e_INTR_TYPE_RIO_DB_IN,
+    e_INTR_TYPE_RIO_MSG_OUT,
+    e_INTR_TYPE_RIO_MSG_IN,
+    e_INTR_TYPE_QE_LOW,
+    e_INTR_TYPE_QE_HIGH,
+    e_INTR_TYPE_QE_IO_PORTS,
+    e_INTR_TYPE_QE_IRAM_ERR,
+    e_INTR_TYPE_QE_MURAM_ERR,
+    e_INTR_TYPE_QE_RTT,
+    e_INTR_TYPE_QE_SDMA,
+    e_INTR_TYPE_QE_VT,
+    e_INTR_TYPE_QE_EXT_REQ
+} e_InterruptType;
+
+/**************************************************************************//**
+ @Description   Descriptor of Board Connections
+*//***************************************************************************/
+typedef struct t_BoardConnectorDesc
+{
+    struct
+    {
+        e_SysModule module;
+        uint32_t    id;
+    } source;
+
+    struct
+    {
+        e_SysModule module;
+        uint32_t    id;
+    } dest;
+
+} t_BoardConnectorDesc;
 
 /**************************************************************************//**
  @Description   Platform configuration parameters structure.
@@ -120,7 +190,19 @@ uint32_t PLATFORM_GetMemoryMappedModuleBase(t_Handle    h_Platform,
                                             e_SysModule module,
                                             uint32_t    id);
 
-/** @} */ /* end of platform_grp */
+int PLATFORM_GetInterruptId(t_Handle        h_Platform,
+                            e_SysModule     module,
+                            uint32_t        id,
+                            e_InterruptType intrType,
+                            uint32_t        intrRelatedId);
 
+uint32_t PLATFORM_GetCoreClk(t_Handle h_Platform);
+
+uint32_t PLATFORM_GetSystemBusClk(t_Handle h_Platform);
+
+uint32_t PLATFORM_GetControllerClk(t_Handle     h_Platform,
+                                   e_SysModule  module,
+                                   uint32_t     id);
+/** @} */ /* end of platform_grp */
 
 #endif /* __PLATFORM_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_ext.h
index 29d6d74..e695033 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_ext.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/system/sys_ext.h
@@ -42,12 +42,284 @@ typedef enum e_SysModule
 
     /* ----------- Modules ----------- */
     e_SYS_MODULE_PLATFORM,
-
+    e_SYS_MODULE_DEV_MNG,
+    e_SYS_MODULE_DATA_POOL_MNG,
+    e_SYS_MODULE_TRAFFIC_MNG,
+    e_SYS_MODULE_APP,
+    /* Stacks */
+    e_SYS_MODULE_PCI_STACK,
+    e_SYS_MODULE_ESDHC_STACK,
+    e_SYS_MODULE_RIO_STACK,
+    e_SYS_MODULE_I2C_STACK,
+    e_SYS_MODULE_SPI_STACK,
+    e_SYS_MODULE_USB_STACK,
+    e_SYS_MODULE_IMA_STACK,
+    /* Wrappers */
+    e_SYS_MODULE_WRP_ECM,
+    e_SYS_MODULE_WRP_ARBITER,
+    e_SYS_MODULE_WRP_DUART,
+    e_SYS_MODULE_WRP_UART,
+    e_SYS_MODULE_WRP_QE,
+    e_SYS_MODULE_WRP_UPC,
+    e_SYS_MODULE_WRP_UCC_ATM,
+    e_SYS_MODULE_WRP_UCC_POS,
+    e_SYS_MODULE_WRP_UCC_GETH,
+    e_SYS_MODULE_WRP_UCC_HDLC,
+    e_SYS_MODULE_WRP_UCC_TRNS,
+    e_SYS_MODULE_WRP_UCC_UART,
+    e_SYS_MODULE_WRP_QMC,
+    e_SYS_MODULE_WRP_QMC_HDLC,
+    e_SYS_MODULE_WRP_QMC_TRANS,
+    e_SYS_MODULE_WRP_L2_SWITCH,
+    e_SYS_MODULE_WRP_SI,
+    e_SYS_MODULE_WRP_TDM,
+    e_SYS_MODULE_WRP_MCC,
+    e_SYS_MODULE_WRP_MCC_HDLC,
+    e_SYS_MODULE_WRP_MCC_TRANS,
+    e_SYS_MODULE_WRP_MCC_SS7,
+    e_SYS_MODULE_WRP_PPPOHT,
+    e_SYS_MODULE_WRP_IW_PPPOHT,
+    e_SYS_MODULE_WRP_PCI,
+    e_SYS_MODULE_WRP_ESDHC,
+    e_SYS_MODULE_WRP_RIO,
+    e_SYS_MODULE_WRP_I2C,
+    e_SYS_MODULE_WRP_SPI,
+    e_SYS_MODULE_WRP_ETSEC,
+    e_SYS_MODULE_WRP_SRIO,
+    e_SYS_MODULE_WRP_IMA,
+    e_SYS_MODULE_WRP_MTC,
+    e_SYS_MODULE_WRP_QE_IW,
+    e_SYS_MODULE_WRP_QE_FILTERING,
+    e_SYS_MODULE_WRP_QE_RTC,
+    e_SYS_MODULE_WRP_VP,
+    e_SYS_MODULE_WRP_GTIMERS,
+    e_SYS_MODULE_WRP_DMA,
+    e_SYS_MODULE_WRP_PTP,
+
+    /* Bus Device Drivers */
+    e_SYS_MODULE_MPC8568_RIO_DEV,
+    e_SYS_MODULE_MPC8568_PCI_DEV,
+    e_SYS_MODULE_MPC836X_PCI_DEV,
+    e_SYS_MODULE_MPC832X_PCI_DEV,
+    e_SYS_MODULE_MPC8568_PCIE_DEV,
+    e_SYS_MODULE_MPC8569_PCIE_DEV,
+    e_SYS_MODULE_MPC8568_SPI_FLASH_DEV,
+    e_SYS_MODULE_MPC8568_SPI_LB_DEV,
+    e_SYS_MODULE_SD_DEV,
+    e_SYS_MODULE_SPD_I2C_DEV,
+    e_SYS_MODULE_DS1374_I2C_DEV,
+    e_SYS_MODULE_PCA9555_I2C_DEV,
+    e_SYS_MODULE_M24256_I2C_DEV,
+    e_SYS_MODULE_AT24C01A_I2C_DEV,
+
+    /* Must close the modules list and open the sub-modules list */
+    e_SYS_SUBMODULE_DUMMY_FIRST,
+
+    /* --------- Sub-modules --------- */
+    e_SYS_SUBMODULE_DATA_POOL,
+    e_SYS_SUBMODULE_PG,
+    e_SYS_SUBMODULE_TG,
+    e_SYS_SUBMODULE_TA,
+    e_SYS_SUBMODULE_DEC,
+    e_SYS_SUBMODULE_PART,
+    e_SYS_SUBMODULE_IPIC,
+    e_SYS_SUBMODULE_EPIC,
+    e_SYS_SUBMODULE_QE_IC,
+    e_SYS_SUBMODULE_LAW,
+    e_SYS_SUBMODULE_DDR,
+    e_SYS_SUBMODULE_LBC,
+    e_SYS_SUBMODULE_ECM,
+    e_SYS_SUBMODULE_ARBITER,
+    e_SYS_SUBMODULE_L2,
+    e_SYS_SUBMODULE_QE,
+    e_SYS_SUBMODULE_QE_TIMERS,
+    e_SYS_SUBMODULE_GTIMERS,
+    e_SYS_SUBMODULE_PAR_IO,
+    e_SYS_SUBMODULE_SI,
+    e_SYS_SUBMODULE_TDM,
+    e_SYS_SUBMODULE_TDM_RX_FRAME,
+    e_SYS_SUBMODULE_TDM_TX_FRAME,
+    e_SYS_SUBMODULE_MCC,
+    e_SYS_SUBMODULE_MCC_HDLC_CH,
+    e_SYS_SUBMODULE_MCC_TRANS_CH,
+    e_SYS_SUBMODULE_MCC_SS7_CH,
+    e_SYS_SUBMODULE_UPC,
+    e_SYS_SUBMODULE_DUART,
+    e_SYS_SUBMODULE_I2C_CTRL,
+    e_SYS_SUBMODULE_DMA,
+    e_SYS_SUBMODULE_DMA_CH,
+    e_SYS_SUBMODULE_PM,
+    e_SYS_SUBMODULE_RTC,
+    e_SYS_SUBMODULE_TLU,
+    e_SYS_SUBMODULE_SEC,
+    e_SYS_SUBMODULE_PCI_CTRL,
+    e_SYS_SUBMODULE_PCIE_CTRL,
+    e_SYS_SUBMODULE_ESDHC,
+    e_SYS_SUBMODULE_SRIO_PORT,
+    e_SYS_SUBMODULE_SRIO_MU,
+    e_SYS_SUBMODULE_SPI_CTRL,
+    e_SYS_SUBMODULE_ETSEC,
+    e_SYS_SUBMODULE_USB,
+    e_SYS_SUBMODULE_UCC_GETH,
+    e_SYS_SUBMODULE_UCC_ATM_COMMON,
+    e_SYS_SUBMODULE_UCC_ATM_AAL2_COMMON,
+    e_SYS_SUBMODULE_UCC_ATM_CTRL,
+    e_SYS_SUBMODULE_UCC_POS_COMMON,
+    e_SYS_SUBMODULE_UCC_POS_CTRL,
+    e_SYS_SUBMODULE_EOS_LINK,
+    e_SYS_SUBMODULE_PPPOS_LINK,
+    e_SYS_SUBMODULE_UTOPIA_PORT,
+    e_SYS_SUBMODULE_UCC_ATM_POLICER,
+    e_SYS_SUBMODULE_UCC_ATM_AAL0,
+    e_SYS_SUBMODULE_UCC_ATM_AAL5,
+    e_SYS_SUBMODULE_UCC_ATM_AAL1,
+    e_SYS_SUBMODULE_UCC_ATM_AAL2,
+    e_SYS_SUBMODULE_UCC_ATM_AAL2_TQD,
+    e_SYS_SUBMODULE_UCC_ATM_AAL2_CID,
+    e_SYS_SUBMODULE_UCC_HDLC,
+    e_SYS_SUBMODULE_UCC_TRNS,
+    e_SYS_SUBMODULE_UCC_UART,
+    e_SYS_SUBMODULE_QMC,
+    e_SYS_SUBMODULE_QMC_HDLC_CH,
+    e_SYS_SUBMODULE_QMC_TRANS_CH,
+    e_SYS_SUBMODULE_L2_SWITCH,
+    e_SYS_SUBMODULE_L2_SWITCH_PORT,
+    e_SYS_SUBMODULE_PPPOHT,
+    e_SYS_SUBMODULE_PPPOHT_BUNDLE,
+    e_SYS_SUBMODULE_PPPOHT_LINK,
+    e_SYS_SUBMODULE_PPPOHT_RX_FBP,
+    e_SYS_SUBMODULE_PPPOHT_TX_FBPS,
+    e_SYS_SUBMODULE_IW_PPPOHT,
+    e_SYS_SUBMODULE_IW_PPPOHT_BUNDLE,
+    e_SYS_SUBMODULE_IW_PPPOHT_LINK,
+    e_SYS_SUBMODULE_IMA,
+    e_SYS_SUBMODULE_IMA_GROUP_PORT,
+    e_SYS_SUBMODULE_IMA_GROUP,
+    e_SYS_SUBMODULE_IMA_LINK,
+    e_SYS_SUBMODULE_MTC_COMMON,
+    e_SYS_SUBMODULE_MTC,
+    e_SYS_SUBMODULE_MTC_UCC,
+    e_SYS_SUBMODULE_MTC_MCC,
+    e_SYS_SUBMODULE_MTC_MCC_COMMON,
+    e_SYS_SUBMODULE_IW_COMMON,
+    e_SYS_SUBMODULE_IW_DEV,
+    e_SYS_SUBMODULE_IW_CONN,
+    e_SYS_SUBMODULE_IW_CDESC,
+    e_SYS_SUBMODULE_IW_MCAST_GROUP,
+    e_SYS_SUBMODULE_IW_IP_REASS,
+    e_SYS_SUBMODULE_IW_PLCR,
+    e_SYS_SUBMODULE_IW_QM,
+    e_SYS_SUBMODULE_QE_FILTER,
+    e_SYS_SUBMODULE_QE_TABLE,
+    e_SYS_SUBMODULE_QE_RTC,
+    e_SYS_SUBMODULE_VP_DEV,
+    e_SYS_SUBMODULE_VP_PORT,
+    e_SYS_SUBMODULE_MII_MNG,
+    e_SYS_SUBMODULE_PTP,
+    e_SYS_SUBMODULE_BM,
+    e_SYS_SUBMODULE_BM_PORTAL,
+    e_SYS_SUBMODULE_BM_CE_PORTAL,
+    e_SYS_SUBMODULE_BM_CI_PORTAL,
+    e_SYS_SUBMODULE_QM,
+    e_SYS_SUBMODULE_QM_PORTAL,
+    e_SYS_SUBMODULE_QM_CE_PORTAL,
+    e_SYS_SUBMODULE_QM_CI_PORTAL,
+    e_SYS_SUBMODULE_FM,
+    e_SYS_SUBMODULE_FM_MURAM,
+    e_SYS_SUBMODULE_FM_PORT_HO,
+    e_SYS_SUBMODULE_FM_PORT_10GRx,
+    e_SYS_SUBMODULE_FM_PORT_1GRx,
+    e_SYS_SUBMODULE_FM_PORT_10GTx,
+    e_SYS_SUBMODULE_FM_PORT_1GTx,
+    e_SYS_SUBMODULE_FM_PORT_10GMAC,
+    e_SYS_SUBMODULE_FM_PORT_1GMAC,
+    e_SYS_SUBMODULE_IW_IPHC_HC,
+    e_SYS_SUBMODULE_IW_IPHC_HDEC,
     /* Must close the sub-modules list */
     e_SYS_SUBMODULE_DUMMY_LAST
 
 } e_SysModule;
 
+/**************************************************************************//**
+ @Function      SYS_GetHandle
+
+ @Description   Returns a specific object handle.
+
+                This routine may be used to get the handle of any module or
+                sub-module in the system.
+
+                For singleton objects, it is recommended to use the
+                SYS_GetUniqueHandle() routine.
+
+ @Param[in]     module  - Module/sub-module type.
+ @Param[in]     id      - For sub-modules, this is the unique object ID;
+                          For modules, this value must always be zero.
+
+ @Return        The handle of the specified object if exists;
+                NULL if the object is not known or is not initialized.
+*//***************************************************************************/
+t_Handle SYS_GetHandle(e_SysModule module, uint32_t id);
+
+/**************************************************************************//**
+ @Function      SYS_GetUniqueHandle
+
+ @Description   Returns a specific object handle (for singleton objects).
+
+                This routine may be used to get the handle of any singleton
+                module or sub-module in the system.
+
+                This routine simply calls the SYS_GetHandle() routine with
+                the \c id parameter set to zero.
+
+ @Param[in]     module - Module/sub-module type.
+
+ @Return        The handle of the specified object if exists;
+                NULL if the object is not known or is not initialized.
+*//***************************************************************************/
+static __inline__ t_Handle SYS_GetUniqueHandle(e_SysModule module)
+{
+    return SYS_GetHandle(module, 0);
+}
+
+/**************************************************************************//**
+ @Function      SYS_ForceHandle
+
+ @Description   Forces a handle for a specific object in the system.
+
+                This routine allows forcing an object handle into the system
+                and thus bypassing the normal initialization flow.
+
+                The forced handle must be removed as soon as it is not valid
+                anymore, using the SYS_RemoveForcedHandle() routine.
+
+ @Param[in]     module      - The object (module/sub-module) type.
+ @Param[in]     id          - Unique object ID;
+ @Param[in]     h_Module    - The object handle;
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      This routine must not be used in normal flow - it serves only
+                rare and special cases in platform initialization.
+*//***************************************************************************/
+t_Error SYS_ForceHandle(e_SysModule module, uint32_t id, t_Handle h_Module);
+
+/**************************************************************************//**
+ @Function      SYS_RemoveForcedHandle
+
+ @Description   Removes a previously forced handle of a specific object.
+
+                This routine must be called to remove object handles that
+                were previously forced using the SYS_ForceHandle() routine.
+
+ @Param[in]     module      - The object (module/sub-module) type.
+ @Param[in]     id          - Unique object ID;
+
+ @Return        None.
+
+ @Cautions      This routine must not be used in normal flow - it serves only
+                rare and special cases in platform initialization.
+*//***************************************************************************/
+void SYS_RemoveForcedHandle(e_SysModule module, uint32_t id);
 
 typedef struct t_SysObjectDescriptor
 {
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman.h
index b955a58..c4cac55 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman.h
@@ -106,7 +106,7 @@ struct fm_port_rx_params {
     uint8_t                     num_pools;          /**< Number of pools use by this port */
     struct fm_port_pool_param   pool_param[FM_PORT_MAX_NUM_OF_EXT_POOLS];
                                                     /**< Parameters for each pool */
-    uint8_t                     priv_data_size;     /**< Area that user may save for his own need (E.g. save the SKB) */
+    uint16_t                    priv_data_size;     /**< Area that user may save for his own need (E.g. save the SKB) */
     bool                        parse_results;      /**< Whether to have the parser-results in the Received buffer */
 };
 
@@ -118,7 +118,7 @@ struct fm_port_non_rx_params {
     uint32_t                defq;               /**< For Tx and HC - Default Confirmation queue,
                                                      0 means no Tx confirmation for processed
                                                      frames. For OP - default Rx queue. */
-    uint8_t                 priv_data_size;     /**< Area that user may save for his own need (E.g. save the SKB) */
+    uint16_t                priv_data_size;     /**< Area that user may save for his own need (E.g. save the SKB) */
     bool                    parse_results;      /**< Whether to put the parser-results in the Transmitted buffer */
 };
 
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman_test.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman_test.h
index cc8393c..d0406a1 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman_test.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/fsl_fman_test.h
@@ -30,6 +30,38 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
 /******************************************************************************
  @File          fsl_fman_test.h
 
@@ -53,9 +85,12 @@
 
  @Description   Check if arriving frame belong to the test
 
- @Param[in]     void * fd,  uint32_t fqid, uint8_t *buffer , uint32_t size
+ @Param[in]     mac_dev - TODO
+ @Param[in]     queueId - TODO
+ @Param[in]     buffer  - A pointer to the buffer to check.
+ @Param[in]     size    - size of the given buffer.
 
- @Param[out]    true/false
+ @Return        true if this buffer belongs to FMan test application; false otherwise.
 
  @Cautions      Allowed only the port is initialized.
 *//***************************************************************************/
@@ -64,5 +99,17 @@ bool is_fman_test (void     *mac_dev,
                    uint8_t  *buffer,
                    uint32_t size);
 
+/**************************************************************************//**
+ @Function      fman_test_ip_manip
+
+ @Description   IP header manipulation
+
+ @Param[in]     mac_dev - TODO
+ @Param[in]     data    - A pointer to the data (payload) to manipulate.
+
+ @Cautions      Allowed only the port is initialized.
+*//***************************************************************************/
+void fman_test_ip_manip (void *mac_dev, uint8_t *data);
+
 
 #endif /* __FSL_FMAN_TEST_H */
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h
index 65d80a8..f7c7a93 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/inc/wrappers/Peripherals/lnxwrp_fm_ext.h
@@ -33,7 +33,7 @@
 /******************************************************************************
  @File          lnxwrp_fm_ext.h
 
- @Description   TBD
+ @Description   TODO
 *//***************************************************************************/
 
 #ifndef __LNXWRP_FM_EXT_H
@@ -148,7 +148,7 @@ t_Error  LNXWRP_FM_TEST_Free(t_Handle h_FmTestLnxWrp);
 
  @Description   Control Unit
 
-                TBD
+                TODO
  @{
 *//***************************************************************************/
 
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/fmm.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/fmm.c
index d4a2cb7..6fdfcd1 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/fmm.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/modules/integrations/P4080/FM/fmm.c
@@ -185,7 +185,7 @@ static int __init __cold fm_load (void)
     }
 #endif /* CONFIG_FSL_FMAN_TEST */
 
-    printk (KERN_CRIT "Freescale FM module ("__DATE__ ":"__TIME__")\n\n");
+    printk (KERN_CRIT "Freescale FM module ("__DATE__ ":"__TIME__")\n");
 
     return 0;
 }
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fman_test.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fman_test.c
index fb35312..479bf89 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fman_test.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/fman_test.c
@@ -57,6 +57,7 @@
 #include <linux/ioport.h>
 #include <linux/fsl_qman.h>     /*struct qman_fq */
 #include <linux/of_platform.h>
+#include <linux/ip.h>
 #include <asm/uaccess.h>
 #include <asm/errno.h>
 
@@ -95,6 +96,8 @@ typedef struct {
     bool                valid;
     uint8_t             id;
     ioc_fmt_port_type   portType;
+    ioc_diag_mode       diag;
+    bool                ip_header_manip;
     struct fm_port      *p_TxPort;
     t_Handle            h_TxFmPortDev;
     struct fm_port      *p_RxPort;
@@ -116,19 +119,14 @@ typedef struct {
 static t_FmTest fmTest;
 
 
-static t_Error SetMacLoopback(t_FmTestPort *p_FmTestPort, bool en)
+static t_Error Set1GMacIntLoopback(t_FmTestPort *p_FmTestPort, bool en)
 {
 #define FM_1GMAC0_OFFSET                0x000e0000
 #define FM_1GMAC1_OFFSET                0x000e2000
 #define FM_1GMAC2_OFFSET                0x000e4000
 #define FM_1GMAC3_OFFSET                0x000e6000
-#define FM_10GMAC0_OFFSET               0x000f0000
-
 #define FM_1GMAC_CMD_CONF_CTRL_OFFSET   0x100
-#define FM_10GMAC_CMD_CONF_CTRL_OFFSET  0x8
-
 #define MACCFG1_LOOPBACK                0x00000100
-#define CMD_CFG_LOOPBACK_EN             0x00000400
 
     uint64_t    tmpAddr = p_FmTestPort->fmPhysBaseAddr;
     uint32_t    tmpVal;
@@ -148,9 +146,6 @@ static t_Error SetMacLoopback(t_FmTestPort *p_FmTestPort, bool en)
         case 3:
             tmpAddr += FM_1GMAC3_OFFSET;
             break;
-        case 4:
-            tmpAddr += FM_10GMAC0_OFFSET;
-            break;
         default:
             RETURN_ERROR(MINOR, E_INVALID_VALUE, ("fm-port-test id!"));
     }
@@ -171,6 +166,39 @@ static t_Error SetMacLoopback(t_FmTestPort *p_FmTestPort, bool en)
                 tmpVal &= ~MACCFG1_LOOPBACK;
             WRITE_UINT32(*CAST_UINT64_TO_POINTER_TYPE(uint32_t,tmpAddr), tmpVal);
             break;
+        default:
+            break;
+    }
+
+    iounmap(CAST_UINT64_TO_POINTER(tmpAddr));
+
+    return E_OK;
+}
+
+#ifndef FM_10G_MAC_NO_CTRL_LOOPBACK
+static t_Error Set10GMacIntLoopback(t_FmTestPort *p_FmTestPort, bool en)
+{
+#define FM_10GMAC0_OFFSET               0x000f0000
+#define FM_10GMAC_CMD_CONF_CTRL_OFFSET  0x8
+#define CMD_CFG_LOOPBACK_EN             0x00000400
+
+    uint64_t    tmpAddr = p_FmTestPort->fmPhysBaseAddr;
+    uint32_t    tmpVal;
+
+    if (p_FmTestPort->portType == e_IOC_FMT_PORT_T_RXTX)
+        switch (p_FmTestPort->id)
+        {
+            case 4:
+                tmpAddr += FM_10GMAC0_OFFSET;
+                break;
+            default:
+                RETURN_ERROR(MINOR, E_INVALID_VALUE, ("fm-port-test id!"));
+        }
+
+    tmpAddr = CAST_POINTER_TO_UINT64(ioremap(tmpAddr, 0x1000));
+
+    switch (p_FmTestPort->id)
+    {
         case 4:
             tmpAddr += FM_10GMAC_CMD_CONF_CTRL_OFFSET;
             tmpVal = GET_UINT32(*CAST_UINT64_TO_POINTER_TYPE(uint32_t,tmpAddr));
@@ -188,6 +216,31 @@ static t_Error SetMacLoopback(t_FmTestPort *p_FmTestPort, bool en)
 
     return E_OK;
 }
+#endif /* !FM_10G_MAC_NO_CTRL_LOOPBACK */
+
+static t_Error SetMacIntLoopback(t_FmTestPort *p_FmTestPort, bool en)
+{
+    if (p_FmTestPort->portType == e_IOC_FMT_PORT_T_RXTX)
+        switch (p_FmTestPort->id)
+        {
+            case 0:
+            case 1:
+            case 2:
+            case 3:
+                return Set1GMacIntLoopback(p_FmTestPort, en);
+                break;
+            case 4:
+#ifndef FM_10G_MAC_NO_CTRL_LOOPBACK
+                return Set10GMacIntLoopback(p_FmTestPort, en);
+#else
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("TGEC don't have internal-loopback"));
+#endif /* !FM_10G_MAC_NO_CTRL_LOOPBACK */
+                break;
+            default:
+                RETURN_ERROR(MINOR, E_INVALID_VALUE, ("fm-port-test id!"));
+        }
+    RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+}
 
 static void EnqueueFrameToRxQ(t_FmTestPort *p_FmTestPort, t_FmTestFrame *p_FmTestFrame)
 {
@@ -294,9 +347,11 @@ static t_Error PortInit (t_FmTestPort *p_FmTestPort, ioc_fmt_port_param_t *p_Par
     uint32_t            i;
 
     INIT_LIST(&p_FmTestPort->rxFrmsQ);
-    p_FmTestPort->numOfTxQs = p_Params->num_tx_queues;
-    p_FmTestPort->id        = p_Params->fm_port_id;
-    p_FmTestPort->portType  = p_Params->fm_port_type;
+    p_FmTestPort->numOfTxQs         = p_Params->num_tx_queues;
+    p_FmTestPort->id                = p_Params->fm_port_id;
+    p_FmTestPort->portType          = p_Params->fm_port_type;
+    p_FmTestPort->diag              = e_IOC_DIAG_MODE_NONE;
+    p_FmTestPort->ip_header_manip   = FALSE;
 
     /* Get all the FM nodes */
     memset(&name, 0, sizeof(struct of_device_id));
@@ -400,8 +455,6 @@ static t_Error PortInit (t_FmTestPort *p_FmTestPort, ioc_fmt_port_param_t *p_Par
             RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("Tx FQs!"));
     }
 
-    SetMacLoopback(p_FmTestPort, TRUE);
-
     p_FmTestPort->valid     = TRUE;
 
     return E_OK;
@@ -480,6 +533,97 @@ bool is_fman_test (void     *mac_dev,
     return false;
 }
 
+void fman_test_ip_manip (void *mac_dev, uint8_t *data)
+{
+    t_FmTest                *p_FmTest = &fmTest;
+    t_FmTestPort            *p_FmTestPort=NULL;
+    struct iphdr            *iph;
+    uint32_t                *p_Data = (uint32_t *)data;
+    uint32_t                net;
+    uint32_t                saddr, daddr;
+    uint8_t                 i;
+
+    /* Get the FM-test-port object */
+    for (i=0; i<IOC_FMT_MAX_NUM_OF_PORTS; i++)
+        if (mac_dev == p_FmTest->ports[i].h_Mac)
+            p_FmTestPort = &p_FmTest->ports[i];
+#ifdef SIMULATOR
+    if (!p_FmTestPort || !p_FmTestPort->ip_header_manip)
+        return;
+#endif /* SIMULATOR */
+
+    iph = (struct iphdr *)p_Data;
+    saddr = iph->saddr;
+    daddr = iph->daddr;
+
+    /* If it is ARP packet ... */
+    if (*p_Data == 0x00010800)
+    {
+        saddr = *CAST_UINT64_TO_POINTER_TYPE(uint32_t,(CAST_POINTER_TO_UINT64(p_Data)+14));
+        daddr = *CAST_UINT64_TO_POINTER_TYPE(uint32_t,(CAST_POINTER_TO_UINT64(p_Data)+24));
+    }
+
+    DBG(TRACE,
+        ("\nSrc  IP before header-manipulation: %d.%d.%d.%d"
+         "\nDest IP before header-manipulation: %d.%d.%d.%d",
+         (int)((saddr & 0xff000000) >> 24),
+         (int)((saddr & 0x00ff0000) >> 16),
+         (int)((saddr & 0x0000ff00) >> 8),
+         (int)((saddr & 0x000000ff) >> 0),
+         (int)((daddr & 0xff000000) >> 24),
+         (int)((daddr & 0x00ff0000) >> 16),
+         (int)((daddr & 0x0000ff00) >> 8),
+         (int)((daddr & 0x000000ff) >> 0)));
+
+#ifdef SIMULATOR
+    if ((p_FmTestPort->diag == e_IOC_DIAG_MODE_CTRL_LOOPBACK) ||
+        (p_FmTestPort->diag == e_IOC_DIAG_MODE_CHIP_LOOPBACK) ||
+        (p_FmTestPort->diag == e_IOC_DIAG_MODE_PHY_LOOPBACK) ||
+        (p_FmTestPort->diag == e_IOC_DIAG_MODE_LINE_LOOPBACK))
+#else
+    if (true)
+#endif /* SIMULATOR */
+    {
+        net   = saddr;
+        saddr = daddr;
+        daddr = net;
+    }
+    else
+    {
+        /* We allow only up to 10 eth ports */
+        net   = ((daddr & 0x000000ff) % 10);
+        saddr = (uint32_t)((saddr & ~0x0000ff00) | (net << 8));
+        daddr = (uint32_t)((daddr & ~0x0000ff00) | (net << 8));
+    }
+
+    /* If not ARP ... */
+    if (*p_Data != 0x00010800)
+    {
+        iph->check = 0;
+
+        iph->saddr = saddr;
+        iph->daddr = daddr;
+        iph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);
+    }
+    else /* The packet is ARP */
+    {
+        *CAST_UINT64_TO_POINTER_TYPE(uint32_t,(CAST_POINTER_TO_UINT64(p_Data)+14)) = saddr;
+        *CAST_UINT64_TO_POINTER_TYPE(uint32_t,(CAST_POINTER_TO_UINT64(p_Data)+24)) = daddr;
+    }
+
+    DBG(TRACE,
+        ("\nSrc  IP after  header-manipulation: %d.%d.%d.%d"
+         "\nDest IP after  header-manipulation: %d.%d.%d.%d",
+         (int)((saddr & 0xff000000) >> 24),
+         (int)((saddr & 0x00ff0000) >> 16),
+         (int)((saddr & 0x0000ff00) >> 8),
+         (int)((saddr & 0x000000ff) >> 0),
+         (int)((daddr & 0xff000000) >> 24),
+         (int)((daddr & 0x00ff0000) >> 16),
+         (int)((daddr & 0x0000ff00) >> 8),
+         (int)((daddr & 0x000000ff) >> 0)));
+}
+
 
 /*****************************************************************************/
 /*               API routines for the FM Linux Device                        */
@@ -519,8 +663,6 @@ static int fm_test_close(struct inode *inode, struct file *file)
 
     p_FmTestPort->valid = FALSE;
 
-    SetMacLoopback(p_FmTestPort, FALSE);
-
     /* Complete!!! */
     return err;
 }
@@ -554,6 +696,30 @@ static int fm_test_ioctl(struct inode *inode, struct file *file, unsigned int cm
 
             return PortInit(p_FmTestPort, &param);
         }
+
+        case FMT_PORT_IOC_SET_DIAG_MODE:
+        {
+            if (get_user(p_FmTestPort->diag, (ioc_diag_mode *)arg)) {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                return -EFAULT;
+            }
+
+            if (p_FmTestPort->diag == e_IOC_DIAG_MODE_CTRL_LOOPBACK)
+                return SetMacIntLoopback(p_FmTestPort, TRUE);
+            else
+                return SetMacIntLoopback(p_FmTestPort, FALSE);
+            break;
+        }
+
+        case FMT_PORT_IOC_SET_IP_HEADER_MANIP:
+        {
+            if (get_user(p_FmTestPort->ip_header_manip, (int *)arg)) {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                return -EFAULT;
+            }
+            break;
+        }
+
         default:
             REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("IOCTL"));
             return -EFAULT;
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
index 3d0f4a6..81ab7e4 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.c
@@ -165,8 +165,6 @@ static int fm_pcd_proc_dump_stats(char *buffer, char **start, off_t offset,
     }
 
     local_irq_save(flags);
-    ProcBuff_Write (h_ProcBuff, "FM-PCD driver statistics:\n");
-
     ProcBuff_Write (h_ProcBuff,
                     "\tFM-PCD counters:\n"
                     "e_FM_COUNTERS_ENQ_TOTAL_FRAME: %d\n"
@@ -228,6 +226,84 @@ static int fm_pcd_proc_dump_stats(char *buffer, char **start, off_t offset,
     return numOfWrittenChars;
 }
 
+static int fm_port_proc_dump_stats(char *buffer, char **start, off_t offset,
+                                   int length, int *eof, void *data)
+{
+    t_LnxWrpFmPortDev           *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)data;
+    t_LnxWrpFmDev               *p_LnxWrpFmDev;
+    t_Handle                    h_ProcBuff = ProcBuff_Init(buffer,start,offset,length,eof);
+    unsigned long               flags;
+    int                         numOfWrittenChars;
+
+    if (!p_LnxWrpFmPortDev)
+    {
+        REPORT_ERROR(MINOR, E_INVALID_STATE, ("FM-Port not initialized!"));
+        return 0;
+    }
+    p_LnxWrpFmDev = (t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
+    if (!p_LnxWrpFmDev->active || !p_LnxWrpFmDev->h_Dev)
+    {
+        REPORT_ERROR(MINOR, E_INVALID_STATE, ("FM not initialized!"));
+        return 0;
+    }
+
+    local_irq_save(flags);
+    ProcBuff_Write (h_ProcBuff,
+             "\tFM %d %s Port %d counters:\n"
+             "e_FM_PORT_COUNTERS_CYCLE=%d\n"
+             "e_FM_PORT_COUNTERS_TASK_UTIL=%d\n"
+             "e_FM_PORT_COUNTERS_QUEUE_UTIL=%d\n"
+             "e_FM_PORT_COUNTERS_DMA_UTIL=%d\n"
+             "e_FM_PORT_COUNTERS_FIFO_UTIL=%d\n"
+             "e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION=%d\n"
+             "e_FM_PORT_COUNTERS_FRAME=%d\n"
+             "e_FM_PORT_COUNTERS_DISCARD_FRAME=%d\n"
+             "e_FM_PORT_COUNTERS_DEALLOC_BUF=%d\n"
+             "e_FM_PORT_COUNTERS_RX_BAD_FRAME=%d\n"
+             "e_FM_PORT_COUNTERS_RX_LARGE_FRAME=%d\n"
+             "e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD=%d\n"
+             "e_FM_PORT_COUNTERS_RX_FILTER_FRAME=%d\n"
+             "e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR=%d\n"
+             "e_FM_PORT_COUNTERS_WRED_DISCARD=%d\n"
+             "e_FM_PORT_COUNTERS_LENGTH_ERR=%d\n"
+             "e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT=%d\n"
+             "e_FM_PORT_COUNTERS_DEQ_TOTAL=%d\n"
+             "e_FM_PORT_COUNTERS_ENQ_TOTAL=%d\n"
+             "e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT=%d\n"
+             "e_FM_PORT_COUNTERS_DEQ_CONFIRM =%d\n",
+             p_LnxWrpFmDev->id,
+             /*(oh ? "OH" : (rx ? "RX" : "TX"))*/"unknown",
+             p_LnxWrpFmPortDev->id,
+             FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_CYCLE),
+             FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_TASK_UTIL),
+             FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_QUEUE_UTIL),
+             FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_DMA_UTIL),
+             FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_FIFO_UTIL),
+             FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION),
+             FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_FRAME),
+             FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_DISCARD_FRAME),
+             FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_DEALLOC_BUF),
+             FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_RX_BAD_FRAME),
+             FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_RX_LARGE_FRAME),
+             FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD),
+             FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_RX_FILTER_FRAME),
+             FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR),
+             FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_WRED_DISCARD),
+             FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_LENGTH_ERR),
+             FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT),
+             FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_DEQ_TOTAL),
+             FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_ENQ_TOTAL),
+             FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT),
+             FM_PORT_GetCounter(p_LnxWrpFmPortDev->h_Dev, e_FM_PORT_COUNTERS_DEQ_CONFIRM)
+             );
+
+    numOfWrittenChars = ProcBuff_GetNumOfWrittenChars(h_ProcBuff);
+    ProcBuff_Free(h_ProcBuff);
+    local_irq_restore(flags);
+
+    return numOfWrittenChars;
+}
+
 static int fm_proc_dump_regs(char *buffer, char **start, off_t offset,
                              int length, int *eof, void *data)
 {
@@ -235,7 +311,6 @@ static int fm_proc_dump_regs(char *buffer, char **start, off_t offset,
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
     t_LnxWrpFmDev   *p_LnxWrpFmDev = (t_LnxWrpFmDev*)data;
-    int             i;
     char            *next = buffer;
     unsigned        size = length;
     int             t;
@@ -248,22 +323,8 @@ static int fm_proc_dump_regs(char *buffer, char **start, off_t offset,
     if (!p_LnxWrpFmDev->active || !p_LnxWrpFmDev->h_Dev)
         REPORT_ERROR(MINOR, E_INVALID_STATE, ("FM not initialized!"));
     else
-    {
         FM_DumpRegs(p_LnxWrpFmDev->h_Dev);
 
-        for (i=0; i<FM_MAX_NUM_OF_OP_PORTS; i++)
-            if (p_LnxWrpFmDev->opPorts[i].active && p_LnxWrpFmDev->opPorts[i].h_Dev)
-                FM_PORT_DumpRegs(p_LnxWrpFmDev->opPorts[i].h_Dev);
-        for (i=0; i<FM_MAX_NUM_OF_TX_PORTS; i++)
-            if (p_LnxWrpFmDev->txPorts[i].active && p_LnxWrpFmDev->txPorts[i].h_Dev)
-                FM_PORT_DumpRegs(p_LnxWrpFmDev->txPorts[i].h_Dev);
-        for (i=0; i<FM_MAX_NUM_OF_RX_PORTS; i++)
-            if (p_LnxWrpFmDev->rxPorts[i].active && p_LnxWrpFmDev->rxPorts[i].h_Dev)
-                FM_PORT_DumpRegs(p_LnxWrpFmDev->rxPorts[i].h_Dev);
-        if (p_LnxWrpFmDev->hcPort.active && p_LnxWrpFmDev->hcPort.h_Dev)
-            FM_PORT_DumpRegs(p_LnxWrpFmDev->hcPort.h_Dev);
-    }
-
     local_irq_restore(flags);
     *eof = 1;
 
@@ -323,6 +384,46 @@ static int fm_pcd_proc_dump_regs(char *buffer, char **start, off_t offset,
 #endif /* (defined(DEBUG_ERRORS) && ... */
 }
 
+static int fm_port_proc_dump_regs(char *buffer, char **start, off_t offset,
+                                  int length, int *eof, void *data)
+{
+    unsigned long   flags;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    t_LnxWrpFmPortDev           *p_LnxWrpFmPortDev = (t_LnxWrpFmPortDev*)data;
+    char            *next = buffer;
+    unsigned        size = length;
+    int             t;
+
+    local_irq_save(flags);
+    t = scnprintf(next, size, "FM port driver registers dump.\n");
+    size -= t;
+    next += t;
+
+    if (!p_LnxWrpFmPortDev->h_Dev)
+        REPORT_ERROR(MINOR, E_INVALID_STATE, ("FM port not initialized!"));
+    else
+        FM_PORT_DumpRegs(p_LnxWrpFmPortDev->h_Dev);
+
+    local_irq_restore(flags);
+    *eof = 1;
+
+    return length - size;
+
+#else
+    t_Handle    h_ProcBuff = ProcBuff_Init(buffer,start,offset,length,eof);
+    int         numOfWrittenChars;
+
+    local_irq_save(flags);
+    ProcBuff_Write (h_ProcBuff, "Debug level is too low to dump registers!!!\n");
+    numOfWrittenChars = ProcBuff_GetNumOfWrittenChars(h_ProcBuff);
+    ProcBuff_Free(h_ProcBuff);
+    local_irq_restore(flags);
+
+    return numOfWrittenChars;
+#endif /* (defined(DEBUG_ERRORS) && ... */
+}
+
 static irqreturn_t fm_irq(int irq, void *_dev)
 {
     t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)_dev;
@@ -330,7 +431,19 @@ static irqreturn_t fm_irq(int irq, void *_dev)
     if (!p_LnxWrpFmDev || !p_LnxWrpFmDev->h_Dev)
         return IRQ_NONE;
 
-    FM_Isr(p_LnxWrpFmDev->h_Dev);
+    FM_EventIsr(p_LnxWrpFmDev->h_Dev);
+
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t fm_err_irq(int irq, void *_dev)
+{
+    t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)_dev;
+
+    if (!p_LnxWrpFmDev || !p_LnxWrpFmDev->h_Dev)
+        return IRQ_NONE;
+
+    FM_ErrorIsr(p_LnxWrpFmDev->h_Dev);
 
     return IRQ_HANDLED;
 }
@@ -470,7 +583,7 @@ static t_LnxWrpFmDev * CreateFmDev(uint8_t  id)
         p_LnxWrpFmDev->txPorts[j].settings.advConfig = (t_SysObjectAdvConfigEntry*)XX_Malloc(FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry));
         memset(p_LnxWrpFmDev->txPorts[j].settings.advConfig, 0, (FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry)));
     }
-    for (j=0; j<FM_MAX_NUM_OF_OP_PORTS; j++)
+    for (j=0; j<FM_MAX_NUM_OF_OH_PORTS-1; j++)
     {
         p_LnxWrpFmDev->opPorts[j].settings.advConfig = (t_SysObjectAdvConfigEntry*)XX_Malloc(FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry));
         memset(p_LnxWrpFmDev->opPorts[j].settings.advConfig, 0, (FM_MAX_NUM_OF_ADV_SETTINGS*sizeof(t_SysObjectAdvConfigEntry)));
@@ -483,7 +596,7 @@ static void DistroyFmDev(t_LnxWrpFmDev *p_LnxWrpFmDev)
 {
     int             j;
 
-    for (j=0; j<FM_MAX_NUM_OF_OP_PORTS; j++)
+    for (j=0; j<FM_MAX_NUM_OF_OH_PORTS-1; j++)
         if (p_LnxWrpFmDev->opPorts[j].settings.advConfig)
             XX_Free(p_LnxWrpFmDev->opPorts[j].settings.advConfig);
     for (j=0; j<FM_MAX_NUM_OF_TX_PORTS; j++)
@@ -652,11 +765,21 @@ static t_LnxWrpFmDev * ReadFmDevTreeNode (struct of_device *of_dev)
     p_LnxWrpFmDev->id = *uint32_prop;
 
     /* Get the FM interrupt */
-    p_LnxWrpFmDev->irq1 = of_irq_to_resource(fm_node, 0, NULL);
-    if (unlikely(p_LnxWrpFmDev->irq1 == NO_IRQ)) {
+    p_LnxWrpFmDev->irq = of_irq_to_resource(fm_node, 0, NULL);
+    if (unlikely(p_LnxWrpFmDev->irq == /*NO_IRQ*/0)) {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_irq_to_resource() = %d", NO_IRQ));
+        return NULL;
+    }
+
+    /* Get the FM error interrupt */
+    p_LnxWrpFmDev->err_irq = of_irq_to_resource(fm_node, 1, NULL);
+    /* TODO - un-comment it once there will be err_irq in the DTS */
+#if 0
+    if (unlikely(p_LnxWrpFmDev->err_irq == /*NO_IRQ*/0)) {
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_irq_to_resource() = %d", NO_IRQ));
         return NULL;
     }
+#endif /* 0 */
 
     /* Get the FM address */
     _errno = of_address_to_resource(fm_node, 0, &res);
@@ -862,7 +985,7 @@ static t_LnxWrpFmPortDev * ReadFmPortDevTreeNode (struct of_device *of_dev)
     }
     BUG_ON(lenp != sizeof(uint32_t));
     if (of_device_is_compatible(port_node, "fsl,fman-port-oh")) {
-        if (unlikely(*uint32_prop >= FM_MAX_NUM_OF_OP_PORTS+1)) {
+        if (unlikely(*uint32_prop >= FM_MAX_NUM_OF_OH_PORTS)) {
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("of_get_property(%s, cell-index) failed", port_node->full_name));
             return NULL;
         }
@@ -1023,12 +1146,21 @@ static t_Error ConfigureFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
     if (!p_LnxWrpFmDev->active)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM not configured!!!"));
 
-    _errno = can_request_irq(p_LnxWrpFmDev->irq1, 0);
+    _errno = can_request_irq(p_LnxWrpFmDev->irq, 0);
     if (unlikely(_errno < 0))
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("can_request_irq() = %d", _errno));
-    _errno = devm_request_irq(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->irq1, fm_irq, 0, "fman", p_LnxWrpFmDev);
+    _errno = devm_request_irq(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->irq, fm_irq, 0, "fman", p_LnxWrpFmDev);
     if (unlikely(_errno < 0))
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("request_irq(%d) = %d", p_LnxWrpFmDev->irq1, _errno));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("request_irq(%d) = %d", p_LnxWrpFmDev->irq, _errno));
+
+    if (p_LnxWrpFmDev->err_irq != 0) {
+        _errno = can_request_irq(p_LnxWrpFmDev->err_irq, 0);
+        if (unlikely(_errno < 0))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("can_request_irq() = %d", _errno));
+        _errno = devm_request_irq(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->err_irq, fm_err_irq, IRQF_SHARED, "fman-err", p_LnxWrpFmDev);
+        if (unlikely(_errno < 0))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("request_irq(%d) = %d", p_LnxWrpFmDev->err_irq, _errno));
+    }
 
     fmPhysAddr = p_LnxWrpFmDev->fmBaseAddr;
     p_LnxWrpFmDev->res = devm_request_mem_region(p_LnxWrpFmDev->dev, p_LnxWrpFmDev->fmBaseAddr, p_LnxWrpFmDev->fmMemSize, "fman");
@@ -1150,6 +1282,16 @@ static t_Error InitFmPcdDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
                                                        LNXWRP_FM_NUM_OF_SHARED_PROFILES))!= E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
+        if (p_LnxWrpFmDev->err_irq != 0) {
+            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC,FALSE);
+            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW,FALSE);
+            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR,FALSE);
+            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC,FALSE);
+            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,FALSE);
+            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS,FALSE);
+            FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev,e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS,FALSE);
+        }
+
         if((err = FM_PCD_Init(p_LnxWrpFmDev->h_PcdDev))!= E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
@@ -1173,19 +1315,40 @@ static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
     if (FM_ConfigResetOnInit(p_LnxWrpFmDev->h_Dev, TRUE) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
 
+    if (p_LnxWrpFmDev->err_irq != 0) {
+        FM_SetException(p_LnxWrpFmDev->h_Dev, e_FM_EX_DMA_BUS_ERROR,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_DMA_READ_ECC,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_DMA_SYSTEM_WRITE_ECC,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_DMA_FM_WRITE_ECC,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_FPM_STALL_ON_TASKS , FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_FPM_SINGLE_ECC,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_FPM_DOUBLE_ECC,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_IRAM_ECC,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_MURAM_ECC,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_QMI_DOUBLE_ECC,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_QMI_DEQ_FROM_DEFQ,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_BMI_LIST_RAM_ECC,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_BMI_PIPELINE_ECC,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_BMI_STATISTICS_RAM_ECC, FALSE);
+    }
+
+#ifdef BUP_FM_HALT_SIG_ERRATA
     /* Workaround for silicon! not relevant for simulator */
-    if (FM_ConfigCatastrophicErr(p_LnxWrpFmDev->h_Dev, e_FM_CATASTROPHIC_ERR_STALL_TASK) != E_OK)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
-    if (FM_ConfigDmaErr(p_LnxWrpFmDev->h_Dev, e_FM_DMA_ERR_REPORT) != E_OK)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
     if (FM_ConfigHaltOnExternalActivation(p_LnxWrpFmDev->h_Dev, FALSE) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
     if (FM_ConfigHaltOnUnrecoverableEccError(p_LnxWrpFmDev->h_Dev, FALSE) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
+#endif /* BUP_FM_HALT_SIG_ERRATA */
 
     if (FM_Init(p_LnxWrpFmDev->h_Dev) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
 
+#ifdef FM_MURAM_ERR_IRQ_ERRATA
+        FM_SetException(p_LnxWrpFmDev->h_Dev, e_FM_EX_BMI_LIST_RAM_ECC, FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev, e_FM_EX_MURAM_ECC, FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev, e_FM_EX_IRAM_ECC, FALSE);
+#endif /* FM_MURAM_ERR_IRQ_ERRATA */
+
 //    return InitFmPcdDev(p_LnxWrpFmDev);
     return E_OK;
 }
@@ -1324,6 +1487,33 @@ static t_Error InitFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
     if ((p_LnxWrpFmPortDev->h_Dev = FM_PORT_Config(&p_LnxWrpFmPortDev->settings.param)) == NULL)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM-port"));
 
+    if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX_10G)
+    {
+        t_FmPortRsrc    portRsrc;
+        t_Error         errCode;
+
+        portRsrc.num = 24;
+        portRsrc.extra = 8;
+
+        if ((errCode = FM_PORT_ConfigNumOfTasks(p_LnxWrpFmPortDev->h_Dev, &portRsrc)) != E_OK)
+             RETURN_ERROR(MAJOR, errCode, NO_MSG);
+    }
+
+    if (((t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev)->err_irq != 0) {
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_MDIO_SCAN_EVENTMDIO,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_MDIO_CMD_CMPL,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_REM_FAULT,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_LOC_FAULT,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_1TX_ECC_ER,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_TX_FIFO_UNFL,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_TX_FIFO_OVFL,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_TX_ER,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_RX_FIFO_OVFL,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_RX_ECC_ER,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_RX_JAB_FRM,FALSE);
+        FM_MAC_SetException(p_LnxWrpFmPortDev->h_Dev, e_FM_MAC_EX_10G_RX_OVRSZ_FRM,FALSE);
+    }
+
     /* Call the driver's advanced configuration routines, if requested:
        Compare the function pointer of each entry to the available routines,
        and invoke the matching routine with proper casting of arguments. */
@@ -1448,10 +1638,10 @@ static int fm_open(struct inode *inode, struct file *file)
     else if (minor == DEV_FM_PCD_MINOR_BASE)
         file->private_data = p_LnxWrpFmDev;
     else {
-        if (minor == DEV_FM_HC_PORT_MINOR_BASE)
+        if (minor == DEV_FM_OH_PORTS_MINOR_BASE)
             p_LnxWrpFmPortDev = &p_LnxWrpFmDev->hcPort;
-        else if ((minor >= DEV_FM_OP_PORTS_MINOR_BASE) && (minor < DEV_FM_RX_PORTS_MINOR_BASE))
-            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->opPorts[minor-DEV_FM_OP_PORTS_MINOR_BASE];
+        else if ((minor > DEV_FM_OH_PORTS_MINOR_BASE) && (minor < DEV_FM_RX_PORTS_MINOR_BASE))
+            p_LnxWrpFmPortDev = &p_LnxWrpFmDev->opPorts[minor-DEV_FM_OH_PORTS_MINOR_BASE-1];
         else if ((minor >= DEV_FM_RX_PORTS_MINOR_BASE) && (minor < DEV_FM_TX_PORTS_MINOR_BASE))
             p_LnxWrpFmPortDev = &p_LnxWrpFmDev->rxPorts[minor-DEV_FM_RX_PORTS_MINOR_BASE];
         else if ((minor >= DEV_FM_TX_PORTS_MINOR_BASE) && (minor < DEV_FM_MAX_MINORS))
@@ -1491,8 +1681,7 @@ static int fm_close(struct inode *inode, struct file *file)
             return -ENODEV;
         fm_unbind((struct fm *)p_LnxWrpFmDev);
     }
-    else if ((minor == DEV_FM_HC_PORT_MINOR_BASE) ||
-             ((minor >= DEV_FM_OP_PORTS_MINOR_BASE) && (minor < DEV_FM_RX_PORTS_MINOR_BASE)) ||
+    else if (((minor >= DEV_FM_OH_PORTS_MINOR_BASE) && (minor < DEV_FM_RX_PORTS_MINOR_BASE)) ||
              ((minor >= DEV_FM_RX_PORTS_MINOR_BASE) && (minor < DEV_FM_TX_PORTS_MINOR_BASE)) ||
              ((minor >= DEV_FM_TX_PORTS_MINOR_BASE) && (minor < DEV_FM_MAX_MINORS)))
     {
@@ -1520,8 +1709,7 @@ static int fm_ioctl(struct inode *inode, struct file *file, unsigned int cmd, un
         if (LnxwrpFmIOCTL(p_LnxWrpFmDev, cmd, arg))
             return -EFAULT;
     }
-    else if ((minor == DEV_FM_HC_PORT_MINOR_BASE) ||
-             ((minor >= DEV_FM_OP_PORTS_MINOR_BASE) && (minor < DEV_FM_RX_PORTS_MINOR_BASE)) ||
+    else if (((minor >= DEV_FM_OH_PORTS_MINOR_BASE) && (minor < DEV_FM_RX_PORTS_MINOR_BASE)) ||
              ((minor >= DEV_FM_RX_PORTS_MINOR_BASE) && (minor < DEV_FM_TX_PORTS_MINOR_BASE)) ||
              ((minor >= DEV_FM_TX_PORTS_MINOR_BASE) && (minor < DEV_FM_MAX_MINORS)))
     {
@@ -1554,7 +1742,6 @@ static struct file_operations fm_fops =
 static int /*__devinit*/ fm_probe(struct of_device *of_dev, const struct of_device_id *match)
 {
     t_LnxWrpFmDev   *p_LnxWrpFmDev;
-    char            fmName[10];
 
     if ((p_LnxWrpFmDev = ReadFmDevTreeNode(of_dev)) == NULL)
         return -EIO;
@@ -1563,20 +1750,31 @@ static int /*__devinit*/ fm_probe(struct of_device *of_dev, const struct of_devi
     if (InitFmDev(p_LnxWrpFmDev) != E_OK)
         return -EIO;
 
-    memset(fmName,0,sizeof(fmName));
-    Sprint (fmName, "%s%d", DEV_FM_NAME, p_LnxWrpFmDev->id);
+    Sprint (p_LnxWrpFmDev->name, "%s%d", DEV_FM_NAME, p_LnxWrpFmDev->id);
 
     /* Register to the /dev for IOCTL API */
     /* Register dynamically a new major number for the character device: */
-    if ((p_LnxWrpFmDev->major = register_chrdev(0, fmName, &fm_fops)) <= 0)
-    {
-        FreeFmDev(p_LnxWrpFmDev);
-        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Failed to allocate a major number for device \"%s\"", DEV_FM_NAME));
+    if ((p_LnxWrpFmDev->major = register_chrdev(0, p_LnxWrpFmDev->name, &fm_fops)) <= 0) {
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Failed to allocate a major number for device \"%s\"", p_LnxWrpFmDev->name));
+        return -EIO;
+    }
+
+    /* Creating classes for FM */
+    DBG(TRACE ,("class_create fm_class"));
+    p_LnxWrpFmDev->fm_class = class_create(THIS_MODULE, p_LnxWrpFmDev->name);
+    if (IS_ERR(p_LnxWrpFmDev->fm_class)) {
+        unregister_chrdev(p_LnxWrpFmDev->major, p_LnxWrpFmDev->name);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("class_create error fm_class"));
         return -EIO;
     }
 
+    device_create(p_LnxWrpFmDev->fm_class, NULL, MKDEV(p_LnxWrpFmDev->major, DEV_FM_MINOR_BASE), NULL,
+                  "fm%d", p_LnxWrpFmDev->id);
+    device_create(p_LnxWrpFmDev->fm_class, NULL, MKDEV(p_LnxWrpFmDev->major, DEV_FM_PCD_MINOR_BASE), NULL,
+                  "fm%d-pcd", p_LnxWrpFmDev->id);
+
     /* Register to the /proc for debug and statistics API */
-    if (((p_LnxWrpFmDev->proc_fm = proc_mkdir(fmName, NULL)) == NULL) ||
+    if (((p_LnxWrpFmDev->proc_fm = proc_mkdir(p_LnxWrpFmDev->name, NULL)) == NULL) ||
         ((p_LnxWrpFmDev->proc_fm_regs = create_proc_read_entry("regs", 0, p_LnxWrpFmDev->proc_fm, fm_proc_dump_regs, p_LnxWrpFmDev)) == NULL) ||
         ((p_LnxWrpFmDev->proc_fm_stats = create_proc_read_entry("stats", 0, p_LnxWrpFmDev->proc_fm, fm_proc_dump_stats, p_LnxWrpFmDev)) == NULL) ||
         ((p_LnxWrpFmDev->proc_fm_pcd = proc_mkdir("fm-pcd", p_LnxWrpFmDev->proc_fm)) == NULL) ||
@@ -1600,22 +1798,24 @@ static int __devexit fm_remove(struct of_device *of_dev)
 {
     t_LnxWrpFmDev   *p_LnxWrpFmDev;
     struct device   *dev;
-    char            fmName[10];
 
     dev = &of_dev->dev;
     p_LnxWrpFmDev = dev_get_drvdata(dev);
 
     remove_proc_entry("stats", p_LnxWrpFmDev->proc_fm_pcd);
     remove_proc_entry("regs", p_LnxWrpFmDev->proc_fm_pcd);
-    remove_proc_entry(p_LnxWrpFmDev->proc_fm_pcd, p_LnxWrpFmDev->proc_fm);
+    remove_proc_entry("fm-pcd", p_LnxWrpFmDev->proc_fm);
     remove_proc_entry("stats", p_LnxWrpFmDev->proc_fm);
     remove_proc_entry("regs", p_LnxWrpFmDev->proc_fm);
-    memset(fmName,0,sizeof(fmName));
-    Sprint (fmName, "%s%d", DEV_FM_NAME, p_LnxWrpFmDev->id);
-    remove_proc_entry(fmName, NULL);
+    remove_proc_entry(p_LnxWrpFmDev->name, NULL);
+
+    DBG(TRACE, ("destroy fm_class"));
+    device_destroy(p_LnxWrpFmDev->fm_class, MKDEV(p_LnxWrpFmDev->major, DEV_FM_MINOR_BASE));
+    device_destroy(p_LnxWrpFmDev->fm_class, MKDEV(p_LnxWrpFmDev->major, DEV_FM_PCD_MINOR_BASE));
+    class_destroy(p_LnxWrpFmDev->fm_class);
 
     /* Destroy chardev */
-    unregister_chrdev(p_LnxWrpFmDev->major, DEV_FM_NAME);
+    unregister_chrdev(p_LnxWrpFmDev->major, p_LnxWrpFmDev->name);
 
     FreeFmDev(p_LnxWrpFmDev);
 
@@ -1647,6 +1847,7 @@ static struct of_platform_driver fm_driver = {
 static int /*__devinit*/ fm_port_probe(struct of_device *of_dev, const struct of_device_id *match)
 {
     t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev;
+    t_LnxWrpFmDev       *p_LnxWrpFmDev;
     struct device       *dev;
 
     dev = &of_dev->dev;
@@ -1668,30 +1869,57 @@ static int /*__devinit*/ fm_port_probe(struct of_device *of_dev, const struct of
 
     dev_set_drvdata(dev, p_LnxWrpFmPortDev);
 
-    DBG(TRACE, ("FM-port-%s%d probed",
-               (((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX_10G) ||
-                 (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX)) ? "rx" :
-                (((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX_10G) ||
-                  (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX)) ? "tx" :
-                 ((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_OFFLINE_PARSING) ? "op" : "hc"))),
-               p_LnxWrpFmPortDev->id));
-
     if ((p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_HOST_COMMAND) &&
         (InitFmPcdDev((t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev) != E_OK))
         return -EIO;
 
-#if 0
+    p_LnxWrpFmDev = (t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
+
+    if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX)
+    {
+        Sprint (p_LnxWrpFmPortDev->name, "%s-port-rx%d", p_LnxWrpFmDev->name, p_LnxWrpFmPortDev->id);
+        p_LnxWrpFmPortDev->minor = p_LnxWrpFmPortDev->id + DEV_FM_RX_PORTS_MINOR_BASE;
+    }
+    else if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_RX_10G)
+    {
+        Sprint (p_LnxWrpFmPortDev->name, "%s-port-rx%d", p_LnxWrpFmDev->name, p_LnxWrpFmPortDev->id+FM_MAX_NUM_OF_1G_RX_PORTS);
+        p_LnxWrpFmPortDev->minor = p_LnxWrpFmPortDev->id + FM_MAX_NUM_OF_1G_RX_PORTS + DEV_FM_RX_PORTS_MINOR_BASE;
+    }
+    else if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX)
+    {
+        Sprint (p_LnxWrpFmPortDev->name, "%s-port-tx%d", p_LnxWrpFmDev->name, p_LnxWrpFmPortDev->id);
+        p_LnxWrpFmPortDev->minor = p_LnxWrpFmPortDev->id + DEV_FM_TX_PORTS_MINOR_BASE;
+    }
+    else if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_TX_10G)
+    {
+        Sprint (p_LnxWrpFmPortDev->name, "%s-port-tx%d", p_LnxWrpFmDev->name, p_LnxWrpFmPortDev->id+FM_MAX_NUM_OF_1G_TX_PORTS);
+        p_LnxWrpFmPortDev->minor = p_LnxWrpFmPortDev->id + FM_MAX_NUM_OF_1G_TX_PORTS + DEV_FM_TX_PORTS_MINOR_BASE;
+    }
+    else if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_HOST_COMMAND)
+    {
+        Sprint (p_LnxWrpFmPortDev->name, "%s-port-oh%d", p_LnxWrpFmDev->name, p_LnxWrpFmPortDev->id);
+        p_LnxWrpFmPortDev->minor = p_LnxWrpFmPortDev->id + DEV_FM_OH_PORTS_MINOR_BASE;
+    }
+    else if (p_LnxWrpFmPortDev->settings.param.portType == e_FM_PORT_TYPE_OFFLINE_PARSING)
+    {
+        Sprint (p_LnxWrpFmPortDev->name, "%s-port-oh%d", p_LnxWrpFmDev->name, p_LnxWrpFmPortDev->id+1);
+        p_LnxWrpFmPortDev->minor = p_LnxWrpFmPortDev->id + 1 + DEV_FM_OH_PORTS_MINOR_BASE;
+    }
+
+    device_create(p_LnxWrpFmDev->fm_class, NULL, MKDEV(p_LnxWrpFmDev->major, p_LnxWrpFmPortDev->minor), NULL, p_LnxWrpFmPortDev->name);
+
     /* Register to the /proc for debug and statistics API */
-    if (((p_LnxWrpFmPortDev->proc = proc_mkdir(fmName, NULL)) == NULL) ||
-        ((p_LnxWrpFmPortDev->proc_regs = create_proc_read_entry("regs", 0, p_LnxWrpFmDev->proc_fm, fm_proc_dump_regs, p_LnxWrpFmDev)) == NULL) ||
-        ((p_LnxWrpFmPortDev->proc_stats = create_proc_read_entry("stats", 0, p_LnxWrpFmDev->proc_fm, fm_proc_dump_stats, p_LnxWrpFmDev)) == NULL)
+    if (((p_LnxWrpFmPortDev->proc = proc_mkdir(p_LnxWrpFmPortDev->name, p_LnxWrpFmDev->proc_fm)) == NULL) ||
+        ((p_LnxWrpFmPortDev->proc_regs = create_proc_read_entry("regs", 0, p_LnxWrpFmPortDev->proc, fm_port_proc_dump_regs, p_LnxWrpFmPortDev)) == NULL) ||
+        ((p_LnxWrpFmPortDev->proc_stats = create_proc_read_entry("stats", 0, p_LnxWrpFmPortDev->proc, fm_port_proc_dump_stats, p_LnxWrpFmPortDev)) == NULL)
         )
     {
         FreeFmDev(p_LnxWrpFmDev);
         REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Unable to create proc entry - fm!!!"));
         return -EIO;
     }
-#endif /* 0 */
+
+    DBG(TRACE, ("%s probed", p_LnxWrpFmPortDev->name));
 
     return 0;
 }
@@ -1699,11 +1927,19 @@ static int /*__devinit*/ fm_port_probe(struct of_device *of_dev, const struct of
 static int __devexit fm_port_remove(struct of_device *of_dev)
 {
     t_LnxWrpFmPortDev   *p_LnxWrpFmPortDev;
+    t_LnxWrpFmDev       *p_LnxWrpFmDev;
     struct device       *dev;
 
     dev = &of_dev->dev;
     p_LnxWrpFmPortDev = dev_get_drvdata(dev);
 
+    remove_proc_entry("stats", p_LnxWrpFmPortDev->proc_stats);
+    remove_proc_entry("regs", p_LnxWrpFmPortDev->proc_regs);
+    remove_proc_entry(p_LnxWrpFmPortDev->name, p_LnxWrpFmPortDev->proc);
+
+    p_LnxWrpFmDev = (t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev;
+    device_destroy(p_LnxWrpFmDev->fm_class, MKDEV(p_LnxWrpFmDev->major, p_LnxWrpFmPortDev->minor));
+
     FreeFmPortDev(p_LnxWrpFmPortDev);
 
     dev_set_drvdata(dev, NULL);
@@ -1747,7 +1983,6 @@ t_Handle LNXWRP_FM_Init(void)
 {
 #ifdef NO_OF_SUPPORT
     t_LnxWrpFmDev   *p_LnxWrpFmDev;
-    char            fmName[10];
     int             i, j;
 #endif /* NO_OF_SUPPORT */
 
@@ -1770,18 +2005,18 @@ t_Handle LNXWRP_FM_Init(void)
             if (InitFmDev(p_LnxWrpFmDev) != E_OK)
                 return NULL;
 
+            Sprint (p_LnxWrpFmDev->name, "%s%d", DEV_FM_NAME, p_LnxWrpFmDev->id);
+
             /* Register to the /dev for IOCTL API */
             /* Register dynamically a new major number for the character device: */
-            if ((p_LnxWrpFmDev->major = register_chrdev(0, DEV_FM_NAME, &fm_fops)) <= 0)
+            if ((p_LnxWrpFmDev->major = register_chrdev(0, p_LnxWrpFmDev->name, &fm_fops)) <= 0)
             {
-                REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Failed to allocate a major number for device \"%s\"", DEV_FM_NAME));
+                REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Failed to allocate a major number for device \"%s\"", p_LnxWrpFmDev->name));
                 return NULL;
             }
 
             /* Register to the /proc for debug and statistics API */
-            memset(fmName,0,sizeof(fmName));
-            Sprint (fmName, "%s%d", DEV_FM_NAME, p_LnxWrpFmDev->id);
-            if (((p_LnxWrpFmDev->proc_fm = proc_mkdir(fmName, NULL)) == NULL) ||
+            if (((p_LnxWrpFmDev->proc_fm = proc_mkdir(p_LnxWrpFmDev->name, NULL)) == NULL) ||
                 ((p_LnxWrpFmDev->proc_fm_regs = create_proc_read_entry("regs", 0, p_LnxWrpFmDev->proc_fm, fm_proc_dump_regs, p_LnxWrpFmDev)) == NULL) ||
                 ((p_LnxWrpFmDev->proc_fm_stats = create_proc_read_entry("stats", 0, p_LnxWrpFmDev->proc_fm, fm_proc_dump_stats, p_LnxWrpFmDev)) == NULL))
             {
@@ -1801,6 +2036,12 @@ t_Handle LNXWRP_FM_Init(void)
     of_register_platform_driver(&fm_port_driver);
 #endif /* !NO_OF_SUPPORT */
 
+#ifdef CONFIG_FSL_FMAN_TEST
+	/* Seed the QMan allocator so we'll have enough queues to run PCD with
+	   dinamically fqid-range allocation */
+	qman_release_fqid_range(0x100, 0x100);
+#endif /* CONFIG_FSL_FMAN_TEST */
+
     return &lnxWrpFm;
 }
 
@@ -1810,7 +2051,6 @@ t_Error LNXWRP_FM_Free(t_Handle h_LnxWrpFm)
     t_LnxWrpFm          *p_LnxWrpFm = (t_LnxWrpFm *)h_LnxWrpFm;
     t_LnxWrpFmDev       *p_LnxWrpFmDev;
     int                 i, j;
-    char                fmName[10];
 
     for (i=0; i<INTG_MAX_NUM_OF_FM; i++)
     {
@@ -1818,12 +2058,10 @@ t_Error LNXWRP_FM_Free(t_Handle h_LnxWrpFm)
 
         remove_proc_entry("stats", p_LnxWrpFmDev->proc_fm);
         remove_proc_entry("regs", p_LnxWrpFmDev->proc_fm);
-        memset(fmName,0,sizeof(fmName));
-        Sprint (fmName, "%s%d", DEV_FM_NAME, p_LnxWrpFmDev->id);
-        remove_proc_entry(fmName, NULL);
+        remove_proc_entry(p_LnxWrpFmDev->name, NULL);
 
         /* Destroy chardev */
-        unregister_chrdev(p_LnxWrpFmDev->major, DEV_FM_NAME);
+        unregister_chrdev(p_LnxWrpFmDev->major, p_LnxWrpFmDev->name);
 
         FreeFmDev(p_LnxWrpFmDev);
 
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h
index 3f2f94f..7955577 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm.h
@@ -71,6 +71,8 @@ typedef struct t_FmTestFq {
 
 typedef struct {
     uint8_t                     id;
+    int                         minor;
+    char                        name[20];
     bool                        active;
     bool                        initialized;
     uint64_t                    baseAddr;
@@ -107,6 +109,7 @@ typedef struct {
 
 typedef struct {
     uint8_t                     id;
+    char                        name[10];
     bool                        active;
     bool                        pcdActive;
     bool                        prsActive;
@@ -123,8 +126,8 @@ typedef struct {
     uint32_t                    fmMemSize;
     uint64_t                    fmMuramBaseAddr;
     uint32_t                    fmMuramMemSize;
-    int                         irq1;
-    int                         irq2;
+    int                         irq;
+    int                         err_irq;
     t_WrpFmDevSettings          fmDevSettings;
     t_WrpFmPcdDevSettings       fmPcdDevSettings;
     t_Handle                    h_Dev;
@@ -134,7 +137,7 @@ typedef struct {
     t_Handle                    h_PcdDev;
 
     t_LnxWrpFmPortDev           hcPort;
-    t_LnxWrpFmPortDev           opPorts[FM_MAX_NUM_OF_OP_PORTS];
+    t_LnxWrpFmPortDev           opPorts[FM_MAX_NUM_OF_OH_PORTS-1];
     t_LnxWrpFmPortDev           rxPorts[FM_MAX_NUM_OF_RX_PORTS];
     t_LnxWrpFmPortDev           txPorts[FM_MAX_NUM_OF_TX_PORTS];
     t_LnxWrpFmMacDev            macs[FM_MAX_NUM_OF_MACS];
@@ -142,6 +145,7 @@ typedef struct {
     struct device               *dev;
     struct resource             *res;
     int                         major;
+    struct class                *fm_class;
     struct proc_dir_entry       *proc_fm;
     struct proc_dir_entry       *proc_fm_regs;
     struct proc_dir_entry       *proc_fm_stats;
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c
index 1e2f239..3cc7df1 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/wrappers/Peripherals/FM/lnxwrp_fm_ioctls.c
@@ -81,7 +81,38 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
     switch (cmd)
     {
         case FM_PCD_IOC_PRS_LOAD_SW:
+        {
+            ioc_fm_pcd_prs_sw_params_t *param;
+            uint8_t                    *p_code;
+
+            param = (ioc_fm_pcd_prs_sw_params_t *)XX_Malloc(sizeof(ioc_fm_pcd_prs_sw_params_t));
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            if (copy_from_user(param, (ioc_fm_pcd_prs_sw_params_t *)arg, sizeof(ioc_fm_pcd_prs_sw_params_t))) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            p_code = (uint8_t *)XX_Malloc(param->size);
+            if (!p_code) {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            if (copy_from_user(p_code, param->p_code, param->size)) {
+                XX_Free(p_code);
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            param->p_code = p_code;
+
+            err = FM_PCD_PrsLoadSw(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdPrsSwParams*)param);
+            XX_Free(p_code);
+            XX_Free(param);
             break;
+        }
 
         case FM_PCD_IOC_ENABLE:
             return FM_PCD_Enable(p_LnxWrpFmDev->h_PcdDev);
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/xx_integration.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/xx_integration.c
index 2881292..92d7577 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/xx_integration.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/integrations/P4080/xx_integration.c
@@ -163,3 +163,34 @@ void * XX_VirtToPhys(void * addr)
 {
     return CAST_UINT64_TO_POINTER(SYS_VirtToPhys(CAST_POINTER_TO_UINT64(addr)));
 }
+
+/*****************************************************************************/
+void * xx_MallocSmart(uint32_t size, int memPartitionId, uint32_t alignment)
+{
+    void        *returnCode;
+    uint32_t    tmp;
+
+    switch(memPartitionId) {
+       case(0):
+       case(e_MEM_1ST_DDR_CACHEABLE):
+            if (alignment < 4)
+                alignment = 4;
+            tmp = (uint32_t)(xx_Malloc((uint32_t)(size + alignment)));
+            if (tmp == 0)
+                return NULL;
+            returnCode = (void*)((tmp + alignment) & ~(alignment - 1));
+            *(uint32_t*)((uint32_t)returnCode - 4) = tmp;
+            break;
+        default:
+            XX_Print("XX_MallocSmart:Mem type not supported\r\n");
+            return NULL;
+    }
+    return returnCode;
+}
+
+void xx_FreeSmart(void *p)
+{
+    xx_Free((void *)(*(uint32_t *)((uint32_t)(p)-4)));
+}
+
+
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx.h b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx.h
index fbe65dd..45607d4 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx.h
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx.h
@@ -35,6 +35,11 @@
 
 #include "xx_ext.h"
 
+void * xx_Malloc(uint32_t n);
+void xx_Free(void *p);
+
+void *xx_MallocSmart(uint32_t size, int memPartitionId, uint32_t align);
+void xx_FreeSmart(void *p);
 
 char  * GetDeviceName(int irq);
 int     GetDeviceIrqNum(int irq);
diff --git a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx_linux.c b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx_linux.c
index cacee0f..32f0e37 100644
--- a/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx_linux.c
+++ b/drivers/net/dpa/NetCommSw/user/env/linux/kernel/2.6/xx/xx_linux.c
@@ -108,7 +108,7 @@
 #define MAX_ALLOCATION_SIZE     128 * 1024 /* Maximum size allocated with kmalloc is 128K */
 
 
-/* FIXME: large allocations => use big phys area */
+/* TODO: large allocations => use big phys area */
 /******************************************************************************
  * routine:     get_nr_pages
  *
@@ -136,7 +136,7 @@ static bool in_big_phys_area (uint32_t addr)
 }
 #endif /* BIGPHYSAREA_ENABLE */
 
-static void * xx_Malloc(uint32_t n)
+void * xx_Malloc(uint32_t n)
 {
     void        *a;
     uint32_t    flags;
@@ -155,7 +155,7 @@ static void * xx_Malloc(uint32_t n)
     return a;
 }
 
-static void xx_Free(void *p)
+void xx_Free(void *p)
 {
 #ifdef BIGPHYSAREA_ENABLE
     if (in_big_phys_area ((uint32_t)p))
@@ -165,35 +165,6 @@ static void xx_Free(void *p)
     kfree(p);
 }
 
-static void * xx_MallocSmart(uint32_t size, int memPartitionId, uint32_t alignment)
-{
-    void        *returnCode;
-    uint32_t    tmp;
-
-    switch(memPartitionId) {
-       case(0):
-       case(e_MEM_1ST_DDR_CACHEABLE):
-            if (alignment < 4)
-                alignment = 4;
-            tmp = (uint32_t)(xx_Malloc((uint32_t)(size + alignment)));
-            if (tmp == 0)
-                return NULL;
-            returnCode = (void*)((tmp + alignment) & ~(alignment - 1));
-            *(uint32_t*)((uint32_t)returnCode - 4) = tmp;
-            break;
-        default:
-            XX_Print("XX_MallocSmart:Mem type not supported\r\n");
-            return NULL;
-    }
-    return returnCode;
-}
-
-static void xx_FreeSmart(void *p)
-{
-    xx_Free((void *)(*(uint32_t *)((uint32_t)(p)-4)));
-}
-
-
 void XX_Exit(int status)
 {
     XX_Print("NetCommSw driver can't go on!!!\r\n");
diff --git a/drivers/net/dpa/dpa.c b/drivers/net/dpa/dpa.c
index ac3c293..c76b200 100644
--- a/drivers/net/dpa/dpa.c
+++ b/drivers/net/dpa/dpa.c
@@ -734,16 +734,14 @@ ingress_rx_error_dqrr(struct qman_portal *portal, struct qman_fq *fq,
 
 #ifdef CONFIG_FSL_FMAN_TEST
 {
-    const struct bm_buffer *bmb;
-    const struct dpa_bp *dpa_bp;
-
-    bmb = (typeof(bmb))&dq->fd;
-
-    dpa_bp = dpa_bpid2pool(&priv->dpa_bp_list, bmb->bpid);
-    BUG_ON(IS_ERR(dpa_bp));
-
-	is_fman_test(priv->mac_dev, FMT_RX_ERR_Q, dpa_phys2virt(dpa_bp, bmb),
-		     dq->fd.length20 + dq->fd.offset);
+    void	*virt = bus_to_virt(dq->fd.addr_lo);
+    /* No support yet for more than 32 bit address */
+    BUG_ON(dq->fd.addr_hi);
+    if (is_fman_test((void *)priv->mac_dev,
+                     FMT_RX_ERR_Q,
+                     virt,
+                     dq->fd.length20 + dq->fd.offset))
+        return qman_cb_dqrr_consume;
 }
 #endif	/* CONFIG_FSL_FMAN_TEST */
 
@@ -834,8 +832,6 @@ ingress_rx_default_dqrr(struct qman_portal		*portal,
 
 #ifdef CONFIG_FSL_FMAN_TEST
 {
-    const struct bm_buffer	*bmb;
-    const struct dpa_bp		*dpa_bp;
     void   					*virt;
     int						 _errno, i;
 	struct dpa_fq			*dpa_fq;
@@ -866,12 +862,9 @@ ingress_rx_default_dqrr(struct qman_portal		*portal,
 			BUG();
 	}
 
-    bmb = (typeof(bmb))&dq->fd;
-
-    dpa_bp = dpa_bpid2pool(&priv->dpa_bp_list, bmb->bpid);
-    BUG_ON(IS_ERR(dpa_bp));
-
-    virt = dpa_phys2virt(dpa_bp, bmb);
+    virt = bus_to_virt(dq->fd.addr_lo);
+    /* No support yet for more than 32 bit address */
+    BUG_ON(dq->fd.addr_hi);
     if (is_fman_test((void *)priv->mac_dev,
                      fqid,
                      virt,
@@ -991,12 +984,13 @@ ingress_tx_error_dqrr(struct qman_portal *portal, struct qman_fq *fq,
 #ifdef CONFIG_FSL_FMAN_TEST
 {
     void   *virt = bus_to_virt(dq->fd.addr_lo);
+    /* No support yet for more than 32 bit address */
+    BUG_ON(dq->fd.addr_hi);
     if (is_fman_test((void *)priv->mac_dev,
                      FMT_TX_ERR_Q,
                      virt,
-                     dq->fd.length20 + dq->fd.offset)) {
+                     dq->fd.length20 + dq->fd.offset))
         return qman_cb_dqrr_consume;
-    }
 }
 #endif /* CONFIG_FSL_FMAN_TEST */
 
@@ -1083,12 +1077,13 @@ ingress_tx_default_dqrr(struct qman_portal		*portal,
 #ifdef CONFIG_FSL_FMAN_TEST
 {
     void   *virt = bus_to_virt(dq->fd.addr_lo);
+    /* No support yet for more than 32 bit address */
+    BUG_ON(dq->fd.addr_hi);
     if (is_fman_test((void *)priv->mac_dev,
                      FMT_TX_CONF_Q,
                      virt,
-                     dq->fd.length20 + dq->fd.offset)) {
+                     dq->fd.length20 + dq->fd.offset))
         return qman_cb_dqrr_consume;
-    }
 }
 #endif /* CONFIG_FSL_FMAN_TEST */
 
@@ -1471,73 +1466,10 @@ static void __hot dpa_rx(struct work_struct *fd_work)
 		}
 
 		skb->protocol = eth_type_trans(skb, net_dev);
-#if defined(CONFIG_FSL_FMAN_TEST) || defined(CONFIG_FSL_FMAN_TEST_LOOP)
-{
-    struct iphdr    *iph = (struct iphdr *)(skb->data);
-    uint32_t        net;
-    uint32_t        saddr = iph->saddr;
-    uint32_t        daddr = iph->daddr;
-
-    /* If it is ARP packet ... */
-    if (*(uint32_t*)skb->data == 0x00010800)
-    {
-        saddr = *((uint32_t*)(skb->data+14));
-        daddr = *((uint32_t*)(skb->data+24));
-    }
 
-    cpu_dev_dbg (net_dev->dev.parent,
-                 "Src  IP before header-manipulation: %d.%d.%d.%d\n",
-                 (int)((saddr & 0xff000000) >> 24),
-                 (int)((saddr & 0x00ff0000) >> 16),
-                 (int)((saddr & 0x0000ff00) >> 8),
-                 (int)((saddr & 0x000000ff) >> 0));
-    cpu_dev_dbg (net_dev->dev.parent,
-                 "Dest IP before header-manipulation: %d.%d.%d.%d\n",
-                 (int)((daddr & 0xff000000) >> 24),
-                 (int)((daddr & 0x00ff0000) >> 16),
-                 (int)((daddr & 0x0000ff00) >> 8),
-                 (int)((daddr & 0x000000ff) >> 0));
-
-    /* We allow only up to 10 eth ports */
-#if defined(CONFIG_FSL_FMAN_TEST)
-    net   = ((daddr & 0x000000ff) % 10);
-    saddr = (uint32_t)((saddr & ~0x0000ff00) | (net << 8));
-    daddr = (uint32_t)((daddr & ~0x0000ff00) | (net << 8));
-#else /* loopback */
-    net   = saddr;
-    saddr = daddr;
-    daddr = net;
-#endif /* defined(CONFIG_FSL_FMAN_TEST) */
-
-    /* If not ARP ... */
-    if (*(uint32_t*)skb->data != 0x00010800)
-    {
-        iph->check = 0;
-
-        iph->saddr = saddr;
-        iph->daddr = daddr;
-        iph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);
-    }
-    else /* The packet is ARP */
-    {
-        *(uint32_t*)(skb->data+14) = saddr;
-        *(uint32_t*)(skb->data+24) = daddr;
-    }
-
-    cpu_dev_dbg (net_dev->dev.parent,
-                 "Src  IP after  header-manipulation: %d.%d.%d.%d\n",
-                 (int)((saddr & 0xff000000) >> 24),
-                 (int)((saddr & 0x00ff0000) >> 16),
-                 (int)((saddr & 0x0000ff00) >> 8),
-                 (int)((saddr & 0x000000ff) >> 0));
-    cpu_dev_dbg (net_dev->dev.parent,
-                 "Dest IP after  header-manipulation: %d.%d.%d.%d\n",
-                 (int)((daddr & 0xff000000) >> 24),
-                 (int)((daddr & 0x00ff0000) >> 16),
-                 (int)((daddr & 0x0000ff00) >> 8),
-                 (int)((daddr & 0x000000ff) >> 0));
-}
-#endif /* defined(CONFIG_FSL_FMAN_TEST) */
+#ifdef CONFIG_FSL_FMAN_TEST
+        fman_test_ip_manip((void *)priv->mac_dev, skb->data);
+#endif /* CONFIG_FSL_FMAN_TEST */
 
 		_errno = netif_rx_ni(skb);
 		if (unlikely(_errno != NET_RX_SUCCESS)) {
@@ -1763,7 +1695,8 @@ static int __cold dpa_stop(struct net_device *net_dev)
 		for (i = 0; i < ARRAY_SIZE(priv->mac_dev->port_dev); i++)
 			fm_port_disable(priv->mac_dev->port_dev[i]);
 
-		phy_disconnect(priv->mac_dev->phy_dev);
+		if (priv->mac_dev->phy_dev)
+			phy_disconnect(priv->mac_dev->phy_dev);
 		priv->mac_dev->phy_dev = NULL;
 	}
 
@@ -1949,6 +1882,71 @@ static const char fsl_qman_frame_queues[][25] __devinitconst = {
 	[TX] = "fsl,qman-frame-queues-tx"
 };
 
+#ifdef CONFIG_FSL_QMAN_FQRANGE
+static int __devinit __cold dpa_alloc_pcd_fqids(struct device	*dev,
+						uint32_t	 num,
+						uint8_t		 alignment,
+						uint32_t	*base_fqid)
+{
+	int			 _errno, i;
+	struct net_device	*net_dev;
+	struct dpa_priv_s	*priv;
+	struct dpa_fq		*dpa_fq;
+	struct qman_fq		*ingress_fq;
+	int					 num_allocated;
+	u32					 base_allocated;
+
+	net_dev = (typeof(net_dev))dev_get_drvdata(dev);
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	num_allocated = qman_alloc_fqid_range(&base_allocated, num, alignment, 0);
+	if ((num_allocated <= 0) ||
+		(num_allocated < num) ||
+		(base_allocated % alignment)) {
+		if (netif_msg_probe(priv))
+			cpu_dev_err(dev, "%s:%hu:%s(): Failed to allocate an FQs range (%d)\n",
+				    __file__, __LINE__, __func__, num);
+		_errno = -EINVAL;
+		goto _return;
+	}
+
+	cpu_dev_dbg(dev, "wanted %d align %d, got %d fqids@%d\n",num, alignment, num_allocated, base_allocated);
+
+	*base_fqid = base_allocated;
+
+	dpa_fq = (typeof(dpa_fq))devm_kzalloc(dev, num_allocated * sizeof(*dpa_fq), GFP_KERNEL);
+	if (unlikely(dpa_fq == NULL)) {
+		if (netif_msg_probe(priv))
+			cpu_dev_err(dev, "%s:%hu:%s(): devm_kzalloc() failed\n",
+				    __file__, __LINE__, __func__);
+		_errno = -ENOMEM;
+		goto _return;
+	}
+
+	for (i = 0, ingress_fq = NULL; i < num_allocated; i++, dpa_fq++) {
+		dpa_fq->fq_base	= ingress_fqs[RX][1];
+		dpa_fq->net_dev	= net_dev;
+		ingress_fq = _dpa_fq_alloc(priv->dpa_fq_list + RX, dpa_fq, base_allocated++,
+					   QMAN_FQ_FLAG_NO_ENQUEUE, priv->channel, 7);
+		if (IS_ERR(ingress_fq)) {
+			_errno = PTR_ERR(ingress_fq);
+			goto _return;
+		}
+	}
+
+	BUG_ON(priv->num >= (sizeof(priv->ranges)/sizeof(struct pcd_range)));
+	priv->ranges[priv->num].base    = *base_fqid;
+	priv->ranges[priv->num++].count = num;
+
+	_errno = 0;
+
+_return:
+	cpu_dev_dbg(dev, "%s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+
+#else
 static int __devinit __cold dpa_alloc_pcd_fqids(struct device	*dev,
 						uint32_t	 num,
 						uint8_t		 alignment,
@@ -2003,11 +2001,10 @@ static int __devinit __cold dpa_alloc_pcd_fqids(struct device	*dev,
 		padding = alignment - (*base_fqid % alignment);
 	*base_fqid += padding;
 	BUG_ON((total_num_fqs-padding)<num);
-#ifdef CONFIG_FSL_FMAN_TEST
+
 	BUG_ON(priv->num >= (sizeof(priv->ranges)/sizeof(struct pcd_range)));
 	priv->ranges[priv->num].base    = *base_fqid;
 	priv->ranges[priv->num++].count = num;
-#endif /* CONFIG_FSL_FMAN_TEST */
 
 	cpu_dev_dbg(dev, "%s:%s(): pcd_fqs base %u\n", __file__, __func__,
 			*base_fqid);
@@ -2019,6 +2016,7 @@ _return:
 
 	return _errno;
 }
+#endif /* CONFIG_FSL_QMAN_FQRANGE */
 
 static int __devinit __cold __attribute__((nonnull))
 dpa_init_probe(struct of_device *_of_dev)
diff --git a/drivers/net/dpa/dpa.h b/drivers/net/dpa/dpa.h
index 4df2766..b9e9469 100644
--- a/drivers/net/dpa/dpa.h
+++ b/drivers/net/dpa/dpa.h
@@ -47,12 +47,10 @@
 
 #include "mac.h"		/* struct mac_device */
 
-#ifdef CONFIG_FSL_FMAN_TEST
 struct pcd_range {
 	uint32_t			 base;
 	uint32_t			 count;
 };
-#endif /* CONFIG_FSL_FMAN_TEST */
 
 struct dpa_percpu_priv_s {
 	struct net_device	*net_dev;
@@ -69,10 +67,9 @@ struct dpa_priv_s {
 	uint16_t		 channel;
 	struct list_head	 dpa_fq_list[2];
 	struct qman_fq		*egress_fqs[8];
-#ifdef CONFIG_FSL_FMAN_TEST
+
 	int					 num;
 	struct pcd_range	 ranges[4];
-#endif /* CONFIG_FSL_FMAN_TEST */
 
 	struct mac_device	*mac_dev;
 
diff --git a/drivers/net/dpa/mac-api.c b/drivers/net/dpa/mac-api.c
index 6039b25..6a27cd1 100644
--- a/drivers/net/dpa/mac-api.c
+++ b/drivers/net/dpa/mac-api.c
@@ -94,15 +94,13 @@ macdev2enetinterface(const struct mac_device *mac_dev)
 	}
 }
 
-static void mac_exception(t_Handle _mac_dev, e_FmMacExceptions exceptions, uint32_t events)
+static void mac_exception(t_Handle _mac_dev, e_FmMacExceptions exception)
 {
 	struct mac_device	*mac_dev;
 
 	mac_dev = (typeof(mac_dev))_mac_dev;
 
-	cpu_dev_dbg(mac_dev->dev, "-> %s:%s()\n", __file__, __func__);
-
-	cpu_dev_dbg(mac_dev->dev, "%s:%s() ->\n", __file__, __func__);
+	cpu_dev_dbg(mac_dev->dev, "%s:%s() -> %d\n", __file__, __func__, exception);
 }
 
 static int __devinit __cold init(struct mac_device *mac_dev)
@@ -119,10 +117,12 @@ static int __devinit __cold init(struct mac_device *mac_dev)
 		mac_dev->dev, mac_dev->res->start, 0x2000);
 	param.enetMode	= macdev2enetinterface(mac_dev);
 	memcpy(&param.addr, mac_dev->addr, min(sizeof(param.addr), sizeof(mac_dev->addr)));
+	param.macId			= mac_dev->cell_index;
+	param.h_Fm 			= (t_Handle)mac_dev->fm;
+	param.mdioIrq		= NO_IRQ;
 	param.f_Exceptions	= mac_exception;
-	param.h_App		= mac_dev;
-	param.macId		= mac_dev->cell_index;
-	param.h_Fm = (t_Handle)mac_dev->fm;
+	param.f_Events		= mac_exception;
+	param.h_App			= mac_dev;
 
 	priv->mac = FM_MAC_Config(&param);
 	if (unlikely(priv->mac == NULL)) {
@@ -149,13 +149,22 @@ static int __devinit __cold init(struct mac_device *mac_dev)
 			goto _return_fm_mac_free;
 		}
 	}
+	else  {
+		err = FM_MAC_ConfigResetOnInit(priv->mac, true);
+		_errno = -GET_ERROR_TYPE(err);
+		if (unlikely(_errno < 0)) {
+			cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_ConfigResetOnInit() = 0x%08x\n",
+				    __file__, __LINE__, __func__, err);
+			goto _return_fm_mac_free;
+		}
+	}
 
 	err = FM_MAC_Init(priv->mac);
 	_errno = -GET_ERROR_TYPE(err);
 	if (unlikely(_errno < 0)) {
 		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_Init() = 0x%08x\n",
 			    __file__, __LINE__, __func__, err);
-		goto _return_fm_mac_reset;
+		goto _return_fm_mac_free;
 	}
 
 	err = FM_MAC_GetVesrion(priv->mac, &version);
@@ -163,7 +172,7 @@ static int __devinit __cold init(struct mac_device *mac_dev)
 	if (unlikely(_errno < 0)) {
 		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_GetVesrion() = 0x%08x\n",
 			    __file__, __LINE__, __func__, err);
-		goto _return_fm_mac_reset;
+		goto _return_fm_mac_free;
 	}
 	cpu_dev_info(mac_dev->dev, "FMan %s version: 0x%08x\n",
 				 ((macdev2enetinterface(mac_dev) != e_ENET_MODE_XGMII_10000) ? "dTSEC" : "XGEC"),
@@ -172,11 +181,6 @@ static int __devinit __cold init(struct mac_device *mac_dev)
 	goto _return;
 
 
-_return_fm_mac_reset:
-	err = FM_MAC_Reset(priv->mac, true);
-	if (unlikely(-GET_ERROR_TYPE(err) < 0))
-		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_Reset() = 0x%08x\n",
-			    __file__, __LINE__, __func__, err);
 _return_fm_mac_free:
 	err = FM_MAC_Free(priv->mac);
 	if (unlikely(-GET_ERROR_TYPE(err) < 0))
@@ -200,10 +204,12 @@ static int __cold start(struct mac_device *mac_dev)
 				"%s:%hu:%s(): FM_MAC_Enable() = 0x%08x\n",
 				__file__, __LINE__, __func__, err);
 
-	if (macdev2enetinterface(mac_dev) != e_ENET_MODE_XGMII_10000)
-		phy_start(phy_dev);
-	else if (phy_dev->drv->read_status)
-		phy_dev->drv->read_status(phy_dev);
+	if (phy_dev) {
+		if (macdev2enetinterface(mac_dev) != e_ENET_MODE_XGMII_10000)
+			phy_start(phy_dev);
+		else if (phy_dev->drv->read_status)
+			phy_dev->drv->read_status(phy_dev);
+	}
 
 	return _errno;
 }
@@ -213,7 +219,8 @@ static int __cold stop(struct mac_device *mac_dev)
 	int	 _errno;
 	t_Error	 err;
 
-	if (macdev2enetinterface(mac_dev) != e_ENET_MODE_XGMII_10000)
+	if (mac_dev->phy_dev &&
+		(macdev2enetinterface(mac_dev) != e_ENET_MODE_XGMII_10000))
 		phy_stop(mac_dev->phy_dev);
 
 	err = FM_MAC_Disable(((struct mac_priv_s *)macdev_priv(mac_dev))->mac,
@@ -244,6 +251,7 @@ static int __cold change_promisc(struct mac_device *mac_dev)
 	return _errno;
 }
 
+#ifndef CONFIG_P4080_SIM
 static void adjust_link(struct net_device *net_dev)
 {
 	struct dpa_priv_s *priv = netdev_priv(net_dev);
@@ -329,6 +337,18 @@ static int xgmac_init_phy(struct net_device *net_dev)
 	return 0;
 }
 
+#else
+static int dtsec_init_phy(struct net_device *net_dev)
+{
+	return 0;
+}
+
+static int xgmac_init_phy(struct net_device *net_dev)
+{
+	return 0;
+}
+#endif /* !CONFIG_P4080_SIM */
+
 static int __cold uninit(struct mac_device *mac_dev)
 {
 	int			 _errno, __errno;
@@ -337,10 +357,10 @@ static int __cold uninit(struct mac_device *mac_dev)
 
 	priv = (typeof(priv))macdev_priv(mac_dev);
 
-	err = FM_MAC_Reset(priv->mac, true);
+	err = FM_MAC_Disable(priv->mac, e_COMM_MODE_RX_AND_TX);
 	_errno = -GET_ERROR_TYPE(err);
 	if (unlikely(_errno < 0))
-		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_Reset() = 0x%08x\n",
+		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_Disable() = 0x%08x\n",
 			    __file__, __LINE__, __func__, err);
 
 	err = FM_MAC_Free(priv->mac);
-- 
1.6.5.2

