From c50dbb02813986dc3de1d9fdd78fea28d92e6725 Mon Sep 17 00:00:00 2001
From: Shlomi Gridish <gridish@freescale.com>
Date: Fri, 16 Apr 2010 11:54:40 -0400
Subject: [PATCH 009/148] p4080_1-2-rc1-netcomm_inc.patch

drivers/net/dpa/NetCommSw/inc/ctype_ext.h
drivers/net/dpa/NetCommSw/inc/debug_ext.h
drivers/net/dpa/NetCommSw/inc/endian_ext.h
drivers/net/dpa/NetCommSw/inc/enet_ext.h
drivers/net/dpa/NetCommSw/inc/error_ext.h
drivers/net/dpa/NetCommSw/inc/etc/list_ext.h
drivers/net/dpa/NetCommSw/inc/etc/memcpy_ext.h
drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h
drivers/net/dpa/NetCommSw/inc/etc/mm_ext.h
drivers/net/dpa/NetCommSw/inc/etc/sprint_ext.h
drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h
drivers/net/dpa/NetCommSw/inc/integrations/part_ext.h
drivers/net/dpa/NetCommSw/inc/math_ext.h
drivers/net/dpa/NetCommSw/inc/ncsw_ext.h
drivers/net/dpa/NetCommSw/inc/net_ext.h
drivers/net/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h
drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
drivers/net/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
drivers/net/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
drivers/net/dpa/NetCommSw/inc/stdarg_ext.h
drivers/net/dpa/NetCommSw/inc/std_ext.h
drivers/net/dpa/NetCommSw/inc/stdlib_ext.h
drivers/net/dpa/NetCommSw/inc/string_ext.h
drivers/net/dpa/NetCommSw/inc/types_ext.h
drivers/net/dpa/NetCommSw/inc/xx_ext.h

Signed-off-by: Donio Ron <rdonio@freescale.com>
Signed-off-by: Emil Medve <Emilian.Medve@Freescale.com>
Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
Signed-off-by: Shlomi Gridish <gridish@freescale.com>

[Cleanly applied FSL SDK 2.0.3 patch:
"p4080_1-2-rc1-netcomm_inc.patch", original
had no commit text]
Integrated-by: Yuri Nedel <Yuri.Nedel@windriver.com>
---
 .../NetCommSw/inc/Peripherals/crc_mac_addr_ext.h   |  363 ++++
 drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h | 1694 ++++++++++++++++++
 .../net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h |  617 +++++++
 .../dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h   |  142 ++
 .../net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h | 1889 ++++++++++++++++++++
 .../dpa/NetCommSw/inc/Peripherals/fm_port_ext.h    | 1889 ++++++++++++++++++++
 .../dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h    |   75 +
 drivers/net/dpa/NetCommSw/inc/ctype_ext.h          |   96 +
 drivers/net/dpa/NetCommSw/inc/debug_ext.h          |  258 +++
 drivers/net/dpa/NetCommSw/inc/endian_ext.h         |  458 +++++
 drivers/net/dpa/NetCommSw/inc/enet_ext.h           |  151 ++
 drivers/net/dpa/NetCommSw/inc/error_ext.h          |  538 ++++++
 drivers/net/dpa/NetCommSw/inc/etc/list_ext.h       |  357 ++++
 drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h        |  324 ++++
 drivers/net/dpa/NetCommSw/inc/etc/memcpy_ext.h     |  173 ++
 drivers/net/dpa/NetCommSw/inc/etc/mm_ext.h         |  301 ++++
 drivers/net/dpa/NetCommSw/inc/etc/sprint_ext.h     |  121 ++
 .../inc/integrations/P4080/part_integration_ext.h  |  306 ++++
 .../net/dpa/NetCommSw/inc/integrations/part_ext.h  |   85 +
 drivers/net/dpa/NetCommSw/inc/math_ext.h           |  101 ++
 drivers/net/dpa/NetCommSw/inc/ncsw_ext.h           |  383 ++++
 drivers/net/dpa/NetCommSw/inc/net_ext.h            |  365 ++++
 drivers/net/dpa/NetCommSw/inc/std_ext.h            |   48 +
 drivers/net/dpa/NetCommSw/inc/stdarg_ext.h         |   48 +
 drivers/net/dpa/NetCommSw/inc/stdlib_ext.h         |  164 ++
 drivers/net/dpa/NetCommSw/inc/string_ext.h         |   58 +
 drivers/net/dpa/NetCommSw/inc/types_ext.h          |   94 +
 drivers/net/dpa/NetCommSw/inc/xx_ext.h             |  818 +++++++++
 28 files changed, 11916 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/ctype_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/debug_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/endian_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/enet_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/error_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/etc/list_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/etc/memcpy_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/etc/mm_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/etc/sprint_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/integrations/part_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/math_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/ncsw_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/net_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/std_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/stdarg_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/stdlib_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/string_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/types_ext.h
 create mode 100644 drivers/net/dpa/NetCommSw/inc/xx_ext.h

diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
new file mode 100644
index 0000000..a957648
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
@@ -0,0 +1,363 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*------------------------------------------------------*/
+/*                                                      */
+/* File: crc_mac_addr_ext.h                             */
+/*                                                      */
+/* Description:                                         */
+/*    Define a macro that calculate the crc value of    */
+/*    an Ethernet MAC address (48 bitd address          */
+/*------------------------------------------------------*/
+
+#ifndef __crc_mac_addr_ext_h
+#define __crc_mac_addr_ext_h
+
+#include "std_ext.h"
+
+
+static uint32_t crc_table[256] =
+{
+    0x00000000,
+    0x77073096,
+    0xee0e612c,
+    0x990951ba,
+    0x076dc419,
+    0x706af48f,
+    0xe963a535,
+    0x9e6495a3,
+    0x0edb8832,
+    0x79dcb8a4,
+    0xe0d5e91e,
+    0x97d2d988,
+    0x09b64c2b,
+    0x7eb17cbd,
+    0xe7b82d07,
+    0x90bf1d91,
+    0x1db71064,
+    0x6ab020f2,
+    0xf3b97148,
+    0x84be41de,
+    0x1adad47d,
+    0x6ddde4eb,
+    0xf4d4b551,
+    0x83d385c7,
+    0x136c9856,
+    0x646ba8c0,
+    0xfd62f97a,
+    0x8a65c9ec,
+    0x14015c4f,
+    0x63066cd9,
+    0xfa0f3d63,
+    0x8d080df5,
+    0x3b6e20c8,
+    0x4c69105e,
+    0xd56041e4,
+    0xa2677172,
+    0x3c03e4d1,
+    0x4b04d447,
+    0xd20d85fd,
+    0xa50ab56b,
+    0x35b5a8fa,
+    0x42b2986c,
+    0xdbbbc9d6,
+    0xacbcf940,
+    0x32d86ce3,
+    0x45df5c75,
+    0xdcd60dcf,
+    0xabd13d59,
+    0x26d930ac,
+    0x51de003a,
+    0xc8d75180,
+    0xbfd06116,
+    0x21b4f4b5,
+    0x56b3c423,
+    0xcfba9599,
+    0xb8bda50f,
+    0x2802b89e,
+    0x5f058808,
+    0xc60cd9b2,
+    0xb10be924,
+    0x2f6f7c87,
+    0x58684c11,
+    0xc1611dab,
+    0xb6662d3d,
+    0x76dc4190,
+    0x01db7106,
+    0x98d220bc,
+    0xefd5102a,
+    0x71b18589,
+    0x06b6b51f,
+    0x9fbfe4a5,
+    0xe8b8d433,
+    0x7807c9a2,
+    0x0f00f934,
+    0x9609a88e,
+    0xe10e9818,
+    0x7f6a0dbb,
+    0x086d3d2d,
+    0x91646c97,
+    0xe6635c01,
+    0x6b6b51f4,
+    0x1c6c6162,
+    0x856530d8,
+    0xf262004e,
+    0x6c0695ed,
+    0x1b01a57b,
+    0x8208f4c1,
+    0xf50fc457,
+    0x65b0d9c6,
+    0x12b7e950,
+    0x8bbeb8ea,
+    0xfcb9887c,
+    0x62dd1ddf,
+    0x15da2d49,
+    0x8cd37cf3,
+    0xfbd44c65,
+    0x4db26158,
+    0x3ab551ce,
+    0xa3bc0074,
+    0xd4bb30e2,
+    0x4adfa541,
+    0x3dd895d7,
+    0xa4d1c46d,
+    0xd3d6f4fb,
+    0x4369e96a,
+    0x346ed9fc,
+    0xad678846,
+    0xda60b8d0,
+    0x44042d73,
+    0x33031de5,
+    0xaa0a4c5f,
+    0xdd0d7cc9,
+    0x5005713c,
+    0x270241aa,
+    0xbe0b1010,
+    0xc90c2086,
+    0x5768b525,
+    0x206f85b3,
+    0xb966d409,
+    0xce61e49f,
+    0x5edef90e,
+    0x29d9c998,
+    0xb0d09822,
+    0xc7d7a8b4,
+    0x59b33d17,
+    0x2eb40d81,
+    0xb7bd5c3b,
+    0xc0ba6cad,
+    0xedb88320,
+    0x9abfb3b6,
+    0x03b6e20c,
+    0x74b1d29a,
+    0xead54739,
+    0x9dd277af,
+    0x04db2615,
+    0x73dc1683,
+    0xe3630b12,
+    0x94643b84,
+    0x0d6d6a3e,
+    0x7a6a5aa8,
+    0xe40ecf0b,
+    0x9309ff9d,
+    0x0a00ae27,
+    0x7d079eb1,
+    0xf00f9344,
+    0x8708a3d2,
+    0x1e01f268,
+    0x6906c2fe,
+    0xf762575d,
+    0x806567cb,
+    0x196c3671,
+    0x6e6b06e7,
+    0xfed41b76,
+    0x89d32be0,
+    0x10da7a5a,
+    0x67dd4acc,
+    0xf9b9df6f,
+    0x8ebeeff9,
+    0x17b7be43,
+    0x60b08ed5,
+    0xd6d6a3e8,
+    0xa1d1937e,
+    0x38d8c2c4,
+    0x4fdff252,
+    0xd1bb67f1,
+    0xa6bc5767,
+    0x3fb506dd,
+    0x48b2364b,
+    0xd80d2bda,
+    0xaf0a1b4c,
+    0x36034af6,
+    0x41047a60,
+    0xdf60efc3,
+    0xa867df55,
+    0x316e8eef,
+    0x4669be79,
+    0xcb61b38c,
+    0xbc66831a,
+    0x256fd2a0,
+    0x5268e236,
+    0xcc0c7795,
+    0xbb0b4703,
+    0x220216b9,
+    0x5505262f,
+    0xc5ba3bbe,
+    0xb2bd0b28,
+    0x2bb45a92,
+    0x5cb36a04,
+    0xc2d7ffa7,
+    0xb5d0cf31,
+    0x2cd99e8b,
+    0x5bdeae1d,
+    0x9b64c2b0,
+    0xec63f226,
+    0x756aa39c,
+    0x026d930a,
+    0x9c0906a9,
+    0xeb0e363f,
+    0x72076785,
+    0x05005713,
+    0x95bf4a82,
+    0xe2b87a14,
+    0x7bb12bae,
+    0x0cb61b38,
+    0x92d28e9b,
+    0xe5d5be0d,
+    0x7cdcefb7,
+    0x0bdbdf21,
+    0x86d3d2d4,
+    0xf1d4e242,
+    0x68ddb3f8,
+    0x1fda836e,
+    0x81be16cd,
+    0xf6b9265b,
+    0x6fb077e1,
+    0x18b74777,
+    0x88085ae6,
+    0xff0f6a70,
+    0x66063bca,
+    0x11010b5c,
+    0x8f659eff,
+    0xf862ae69,
+    0x616bffd3,
+    0x166ccf45,
+    0xa00ae278,
+    0xd70dd2ee,
+    0x4e048354,
+    0x3903b3c2,
+    0xa7672661,
+    0xd06016f7,
+    0x4969474d,
+    0x3e6e77db,
+    0xaed16a4a,
+    0xd9d65adc,
+    0x40df0b66,
+    0x37d83bf0,
+    0xa9bcae53,
+    0xdebb9ec5,
+    0x47b2cf7f,
+    0x30b5ffe9,
+    0xbdbdf21c,
+    0xcabac28a,
+    0x53b39330,
+    0x24b4a3a6,
+    0xbad03605,
+    0xcdd70693,
+    0x54de5729,
+    0x23d967bf,
+    0xb3667a2e,
+    0xc4614ab8,
+    0x5d681b02,
+    0x2a6f2b94,
+    0xb40bbe37,
+    0xc30c8ea1,
+    0x5a05df1b,
+    0x2d02ef8d
+};
+
+
+#define GET_MAC_ADDR_CRC(addr, crc)             \
+{                                               \
+    uint32_t    i;                              \
+    uint8_t     data;                           \
+                                                \
+    /* CRC calculation */                       \
+    crc = 0xffffffff;                           \
+    for (i=0; i < 6; i++)                       \
+    {                                           \
+        data = (uint8_t)(addr >> ((5-i)*8));    \
+        crc = crc^data;                         \
+        crc = crc_table[crc&0xff] ^ (crc>>8);   \
+    }                                           \
+}                                               \
+
+/*    Define a macro for getting the mirrored value of      */
+/*    a byte size number. (0x11010011 --> 0x11001011)       */
+/*    Sometimes the mirrored value of the CRC is required   */
+static __inline__ uint8_t GetMirror(uint8_t n)
+{
+    uint8_t mirror[16] =
+        {
+            0x00,
+            0x08,
+            0x04,
+            0x0c,
+            0x02,
+            0x0a,
+            0x06,
+            0x0e,
+            0x01,
+            0x09,
+            0x05,
+            0x0d,
+            0x03,
+            0x0b,
+            0x07,
+            0x0f
+        };
+    return ((uint8_t)(((mirror[n & 0x0f] << 4) | (mirror[n >> 4]))));
+}
+
+static __inline__ uint32_t GetMirror32(uint32_t n)
+{
+    return (((uint32_t)GetMirror((uint8_t)(n))<<24) |
+            ((uint32_t)GetMirror((uint8_t)(n>>8))<<16) |
+            ((uint32_t)GetMirror((uint8_t)(n>>16))<<8) |
+            ((uint32_t)GetMirror((uint8_t)(n>>24))));
+}
+
+#define MIRROR      GetMirror
+#define MIRROR_32   GetMirror32
+
+
+#endif /* __crc_mac_addr_ext_h */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h
new file mode 100644
index 0000000..4fee320
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_ext.h
@@ -0,0 +1,1694 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          FM_ext.h
+
+ @Description   FM Application Programming Interface.
+*//***************************************************************************/
+#ifndef __FM_EXT
+#define __FM_EXT
+
+#include "error_ext.h"
+#include "std_ext.h"
+
+
+/**************************************************************************//**
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums.
+
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_lib_grp FM library
+
+ @Description   FM API functions, definitions and enums
+                The FM module is the main driver module and is a mandatory module
+                for FM driver users. Before any further module initialization,
+                this module must be initialized.
+                The FM is a "singletone" module. It is responsible of the common
+                HW modules: FPM, DMA, common QMI, common BMI initializations and
+                run-time control routines. This module must be initialized always
+                when working with any of the FM modules.
+                NOTE - We assumes that the FML will be initialize only by core No. 0!
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   enum for defining port types
+*//***************************************************************************/
+typedef enum e_FmPortType {
+    e_FM_PORT_TYPE_OFFLINE_PARSING, /**< Offline parsing port (id's: 0-6, share id's with
+                                         host command, so must have exclusive id) */
+    e_FM_PORT_TYPE_HOST_COMMAND,    /**< Host command port (id's: 0-6, share id's with
+                                         offline parsing ports, so must have exclusive id) */
+    e_FM_PORT_TYPE_RX,              /**< 1G Rx port (id's: 0-3) */
+    e_FM_PORT_TYPE_RX_10G,          /**< 10G Rx port (id's: 0) */
+    e_FM_PORT_TYPE_TX,              /**< 1G Tx port (id's: 0-3) */
+    e_FM_PORT_TYPE_TX_10G,          /**< 10G Tx port (id's: 0) */
+    e_FM_PORT_TYPE_DUMMY
+} e_FmPortType;
+
+/**************************************************************************//**
+ @Collection    General FM defines
+*//***************************************************************************/
+#define FM_MAX_NUM_OF_PARTITIONS    64      /**< Maximim number of partitions */
+#define FM_PHYS_ADDRESS_SIZE        6       /**< FM Physical address size */
+/* @} */
+
+/**************************************************************************//**
+ @Collection   FM Frame error
+*//***************************************************************************/
+typedef uint32_t    fmPortFrameErrSelect_t;                         /**< typedef for defining Frame Descriptor errors */
+
+#define FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT              0x04000000  /**< Offline parsing only! Unsupported Format */
+#define FM_PORT_FRM_ERR_LENGTH                          0x02000000  /**< Offline parsing only! Length Error */
+#define FM_PORT_FRM_ERR_DMA                             0x01000000  /**< DMA Data error */
+#define FM_PORT_FRM_ERR_PHYSICAL                        0x00080000  /**< Rx FIFO overflow, FCS error, code error, running disparity
+                                                                         error (SGMII and TBI modes), FIFO parity error. PHY
+                                                                         Sequence error, PHY error control character detected. */
+#define FM_PORT_FRM_ERR_SIZE                            0x00040000  /**< Frame too long OR Frame size exceeds max_length_frame  */
+#define FM_PORT_FRM_ERR_CLS_DISCARD                     0x00020000  /**< classification discard */
+#define FM_PORT_FRM_ERR_EXTRACTION                      0x00008000  /**< Extract Out of Frame */
+#define FM_PORT_FRM_ERR_NO_SCHEME                       0x00004000  /**< No Scheme Selected */
+#define FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW                0x00002000  /**< No Scheme Selected */
+#define FM_PORT_FRM_ERR_COLOR_YELLOW                    0x00000400
+#define FM_PORT_FRM_ERR_COLOR_RED                       0x00000800
+#define FM_PORT_FRM_ERR_ILL_PLCR                        0x00000200  /**< Illegal Policer Profile selected */
+#define FM_PORT_FRM_ERR_PLCR_FRAME_LEN                  0x00000100  /**< Illegal Policer Profile selected */
+#define FM_PORT_FRM_ERR_PRS_TIMEOUT                     0x00000080  /**< Parser Time out Exceed */
+#define FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT                0x00000040  /**< Invalid Soft Parser instruction */
+#define FM_PORT_FRM_ERR_PRS_HDR_ERR                     0x00000020  /**< Header error was identified during parsing */
+#define FM_PORT_FRM_ERR_PROCESS_TIMEOUT                 0x00000001  /**< FPT Frame Processing Timeout Exceeded */
+/* @} */
+
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+
+/**************************************************************************//**
+ @Description   FM physical Address
+*//***************************************************************************/
+typedef _Packed struct t_FmPhysAddr
+{
+    volatile uint16_t high;
+    volatile uint32_t low;
+}_PackedType t_FmPhysAddr;
+
+/**************************************************************************//**
+ @Description   Parse results memory layout
+*//***************************************************************************/
+typedef _Packed struct t_FmPrsResult {
+    uint8_t     lpid;               /**< Logical port id */
+    uint8_t     shimr;              /**< Shim header result  */
+    uint16_t    l2r;                /**< Layer 2 result */
+    uint16_t    l3r;                /**< Layer 3 result */
+    uint8_t     l4r;                /**< Layer 4 result */
+    uint8_t     cplan;              /**< Classification plan id */
+    uint16_t    nxthdr;             /**< Next Header  */
+    uint16_t    cksum;              /**< Checksum */
+    uint32_t    lcv;                /**< LCV */
+    uint8_t     shim_off[3];        /**< Shim offset */
+    uint8_t     eth_off;            /**< ETH offset */
+    uint8_t     llc_snap_off;       /**< LLC_SNAP offset */
+    uint8_t     vlan_off[2];        /**< VLAN offset */
+    uint8_t     etype_off;          /**< ETYPE offset */
+    uint8_t     pppoe_off;          /**< PPP offset */
+    uint8_t     mpls_off[2];        /**< MPLS offset */
+    uint8_t     ip_off[2];          /**< IP offset */
+    uint8_t     gre_off;            /**< GRE offset */
+    uint8_t     l4_off;             /**< Layer 4 offset */
+    uint8_t     nxthdr_off;         /**< Parser end point */
+} _PackedType t_FmPrsResult;
+
+/**************************************************************************//**
+ @Description   Parse results
+*//***************************************************************************/
+#define FM_PR_L2_VLAN_STACK       0x0100
+#define FM_PR_L2_ETHERNET         0x8000
+#define FM_PR_L2_VLAN             0x4000
+#define FM_PR_L2_LLC_SNAP         0x2000
+#define FM_PR_L2_MPLS             0x1000
+#define FM_PR_L2_PPPoE            0x0800
+
+/**************************************************************************//**
+ @Description   Time stamp in buffer
+*//***************************************************************************/
+typedef _Packed struct t_FmTimeStamp {
+    uint32_t    timeStamp;          /**< Time stamp integer */
+    uint32_t    timeStampFrac;      /**< Time stamp fraction */
+} _PackedType t_FmTimeStamp;
+
+/**************************************************************************//**
+ @Description   Frame descriptor
+*//***************************************************************************/
+typedef _Packed struct t_FmFD {
+    uint32_t    id;                 /**< FD id */
+    uint32_t    addrl;              /**< Data Address */
+    uint32_t    length;             /**< Frame length */
+    uint32_t    status;             /**< FD status */
+} _PackedType t_FmFD;
+
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
+/**************************************************************************//**
+ @Collection   Frame descriptor macros
+*//***************************************************************************/
+#define FM_FD_DD_MASK       0xc0000000           /**< FD DD field mask */
+#define FM_FD_PID_MASK      0x3f000000           /**< FD PID field mask */
+#define FM_FD_BPID_MASK     0x00ff0000           /**< FD BPID field mask */
+#define FM_FD_ADDRH_MASK    0x0000ffff           /**< FD ADDRH field mask */
+#define FM_FD_ADDRL_MASK    0xffffffff           /**< FD ADDRL field mask */
+#define FM_FD_FORMAT_MASK   0xe0000000           /**< FD FORMAT field mask */
+#define FM_FD_OFFSET_MASK   0x1ff00000           /**< FD OFFSET field mask */
+#define FM_FD_LENGTH_MASK   0x000fffff           /**< FD LENGTH field mask */
+
+#define FM_FD_GET_DD(fd)            ((((t_FmFD *)fd)->id & FM_FD_DD_MASK) >> (31-1))            /**< Macro to get FD DD field */
+#define FM_FD_GET_PID(fd)           ((((t_FmFD *)fd)->id & FM_FD_PID_MASK) >> (31-7))           /**< Macro to get FD PID field */
+#define FM_FD_GET_BPID(fd)          ((((t_FmFD *)fd)->id & FM_FD_BPID_MASK) >> (31-15))         /**< Macro to get FD BPID field */
+#define FM_FD_GET_ADDRH(fd)         (((t_FmFD *)fd)->id & FM_FD_ADDRH_MASK)                     /**< Macro to get FD ADDRH field */
+#define FM_FD_GET_ADDRL(fd)         ((t_FmFD *)fd)->addrl                                       /**< Macro to get FD ADDRL field */
+#define FM_FD_GET_PHYS_ADDR(fd)     ((uint64_t)(((uint64_t)FM_FD_GET_ADDRH(fd) << 32) | (uint64_t)FM_FD_GET_ADDRL(fd))) /**< Macro to get FD ADDR field */
+#define FM_FD_GET_FORMAT(fd)        ((((t_FmFD *)fd)->length & FM_FD_FORMAT_MASK) >> (31-2))    /**< Macro to get FD FORMAT field */
+#define FM_FD_GET_OFFSET(fd)        ((((t_FmFD *)fd)->length & FM_FD_OFFSET_MASK) >> (31-11))   /**< Macro to get FD OFFSET field */
+#define FM_FD_GET_LENGTH(fd)        (((t_FmFD *)fd)->length & FM_FD_LENGTH_MASK)                /**< Macro to get FD LENGTH field */
+#define FM_FD_GET_STATUS(fd)        ((t_FmFD *)fd)->status                                      /**< Macro to get FD STATUS field */
+#define FM_FD_GET_ADDR(fd)          XX_PhysToVirt(CAST_UINT64_TO_POINTER(FM_FD_GET_PHYS_ADDR(fd)))
+
+#define FM_FD_SET_DD(fd,val)        (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_DD_MASK) | ((val << (31-1))& FM_FD_DD_MASK )))      /**< Macro to get FD DD field */
+#define FM_FD_SET_PID(fd,val)       (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_PID_MASK) | ((val << (31-7))& FM_FD_PID_MASK)))     /**< Macro to get FD PID field */
+#define FM_FD_SET_BPID(fd,val)      (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_BPID_MASK) | ((val  << (31-15))& FM_FD_BPID_MASK))) /**< Macro to get FD BPID field */
+#define FM_FD_SET_ADDRH(fd,val)     (((t_FmFD *)fd)->id = ((((t_FmFD *)fd)->id & ~FM_FD_ADDRH_MASK) | (val & FM_FD_ADDRH_MASK)))            /**< Macro to get FD ADDRH field */
+#define FM_FD_SET_ADDRL(fd,val)     ((t_FmFD *)fd)->addrl = val                                 /**< Macro to get FD ADDRL field */
+#define FM_FD_SET_ADDR(fd,val)                                      \
+do {                                                                \
+    uint64_t physAddr = CAST_POINTER_TO_UINT64(XX_VirtToPhys(val)); \
+    FM_FD_SET_ADDRH(fd, ((uint32_t)(physAddr >> 32)));              \
+    FM_FD_SET_ADDRL(fd, (uint32_t)physAddr);                        \
+} while (0)                                                                                     /**< Macro to get FD ADDR field */
+#define FM_FD_SET_FORMAT(fd,val)    (((t_FmFD *)fd)->length = ((((t_FmFD *)fd)->length & ~FM_FD_FORMAT_MASK) | ((val  << (31-2))& FM_FD_FORMAT_MASK)))  /**< Macro to get FD FORMAT field */
+#define FM_FD_SET_OFFSET(fd,val)    (((t_FmFD *)fd)->length = ((((t_FmFD *)fd)->length & ~FM_FD_OFFSET_MASK) | ((val << (31-11))& FM_FD_OFFSET_MASK) )) /**< Macro to get FD OFFSET field */
+#define FM_FD_SET_LENGTH(fd,val)    (((t_FmFD *)fd)->length = (((t_FmFD *)fd)->length & ~FM_FD_LENGTH_MASK) | (val & FM_FD_LENGTH_MASK))                /**< Macro to get FD LENGTH field */
+#define FM_FD_SET_STATUS(fd,val)    ((t_FmFD *)fd)->status = val                                /**< Macro to get FD STATUS field */
+
+
+#define FM_FD_CMD_FCO  0x80000000      /* Frame queue Context Override */
+#define FM_FD_CMD_RPD  0x40000000      /* Read Prepended Data */
+#define FM_FD_CMD_UDP  0x20000000      /* Update Prepended Data */
+#define FM_FD_CMD_BMF  0x10000000      /* Buffer Must not be Freed */
+#define FM_FD_CMD_DTC  0x08000000      /* Do TCP Checksum */
+#define FM_FD_CMD_DME  0x01000000      /* DMA Error */
+#define FM_FD_CMD_CFQ  0x00ffffff      /* Confirmation Frame Queue */
+/* @} */
+
+/**************************************************************************//**
+ @Description   FM Exceptions
+*//***************************************************************************/
+typedef enum e_FmExceptions {
+    e_FM_EX_DMA_BUS_ERROR,              /**< DMA bus error. */
+    e_FM_EX_DMA_READ_ECC,               /**< Read Buffer ECC error */
+    e_FM_EX_DMA_SYSTEM_WRITE_ECC,       /**< Write Buffer ECC error on system side */
+    e_FM_EX_DMA_FM_WRITE_ECC,           /**< Write Buffer ECC error on FM side */
+    e_FM_EX_FPM_STALL_ON_TASKS ,        /**< Stall of tasks on FPM */
+    e_FM_EX_FPM_SINGLE_ECC,             /**< Single ECC on FPM. */
+    e_FM_EX_FPM_DOUBLE_ECC,             /**< Double ECC error on FPM ram access */
+    e_FM_EX_QMI_SINGLE_ECC,             /**< Single ECC on QMI. */
+    e_FM_EX_QMI_DOUBLE_ECC,             /**< Double bit ECC occured on QMI */
+    e_FM_EX_QMI_DEQ_FROM_DEFQ,          /**< Dequeu from default queue id, as a result
+                                             of invalid port id. */
+    e_FM_EX_BMI_LIST_RAM_ECC,           /**< Linked List RAM ECC error */
+    e_FM_EX_BMI_PIPELINE_ECC,           /**< Pipeline Table ECC Error */
+    e_FM_EX_BMI_STATISTICS_RAM_ECC,     /**< Statistics Count RAM ECC Error Enable */
+    e_FM_EX_IRAM_ECC,                   /**< Double bit ECC occured on IRAM*/
+    e_FM_EX_MURAM_ECC                   /**< Double bit ECC occured on MURAM*/
+} e_FmExceptions;
+
+/**************************************************************************//**
+ @Group         FM_init_grp FM Initialization Unit
+
+ @Description   FM Initialization Unit
+
+                Initialization Flow
+                Initialization of the FM Module will be carried out by the application
+                according to the following sequence:
+                a.  Calling the configuration routine with basic parameters.
+                b.  Calling the advance initialization routines to change driver's defaults.
+                c.  Calling the initialization routine.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      t_FmExceptionsCallback
+
+ @Description   Exceptions user callback routine, will be called upon an
+                exception passing the exception identification.
+
+ @Param[in]     h_App      - User's application descriptor.
+ @Param[in]     exception  - The exception.
+*//***************************************************************************/
+typedef void (t_FmExceptionsCallback) ( t_Handle              h_App,
+                                        e_FmExceptions        exception);
+
+/**************************************************************************//**
+ @Function      t_FmBusErrorCallback
+
+ @Description   Bus error user callback routine, will be called upon a
+                bus error, passing parameters describing the errors and the owner.
+
+ @Param[in]     h_App       - User's application descriptor.
+ @Param[in]     portType    - Port type (e_FmPortType)
+ @Param[in]     portId      - Port id - relative to type.
+ @Param[in]     addr        - Address that caused the error
+ @Param[in]     tnum        - Owner of error
+ @Param[in]     partition   - memory partition
+*//***************************************************************************/
+typedef void (t_FmBusErrorCallback) ( t_Handle        h_App,
+                                      e_FmPortType    portType,
+                                      uint8_t         portId,
+                                      uint64_t        addr,
+                                      uint8_t         tnum,
+                                      uint8_t         partition);
+
+/**************************************************************************//**
+ @Description   structure for defining Ucode patch for loading.
+*//***************************************************************************/
+typedef struct t_FmPcdFirmwareParams {
+    uint32_t                size;                   /**< Size of uCode */
+    uint32_t                *p_Code;                /**< A pointer to the uCode */
+} t_FmPcdFirmwareParams;
+
+/**************************************************************************//**
+ @Description   structure representing FM initialization parameters
+*//***************************************************************************/
+typedef struct t_FmParams {
+    uint8_t                 fmId;                   /**< Index of the FM */
+#ifndef CONFIG_GUEST_PARTITION
+    uint64_t                baseAddr;               /**< A pointer to base of memory mapped FM registers (virtual).*/
+    t_Handle                h_FmMuram;              /**< A handle of an initialized MURAM object,
+                                                         to be used by the FM */
+    uint16_t                fmClkFreq;              /**< In Mhz */
+    uint8_t                 liodnPerPartition[FM_MAX_NUM_OF_PARTITIONS]; /**< For each partition, LIODN should be configured here. */
+    t_FmExceptionsCallback  *f_Exceptions;          /**< An application callback routine to
+                                                         handle exceptions.*/
+    t_FmBusErrorCallback    *f_BusError;            /**< An application callback routine to
+                                                         handle exceptions.*/
+    t_Handle                h_App;                  /**< A handle to an application layer object; This handle will
+                                                         be passed by the driver upon calling the above callbacks */
+    int                     irq;                    /**< FM interrupt source for normal events */
+    int                     errIrq;                 /**< FM interrupt source for errors */
+    t_FmPcdFirmwareParams   firmware;               /**< Ucode */
+#endif /* CONFIG_GUEST_PARTITION */
+} t_FmParams;
+
+
+/**************************************************************************//**
+ @Function      FM_Config
+
+ @Description   Creates descriptor for the FM module.
+
+                The routine returns a handle (descriptor) to the FM object.
+                This descriptor must be passed as first parameter to all other
+                FM function calls.
+
+                No actual initialization or configuration of FM hardware is
+                done by this routine.
+
+ @Param[in]     p_FmParams  - A pointer to data structure of parameters
+
+ @Return        Handle to FM object, or NULL for Failure.
+*//***************************************************************************/
+t_Handle FM_Config(t_FmParams *p_FmParams);
+
+/**************************************************************************//**
+ @Function      FM_Init
+
+ @Description   Initializes the FM module
+
+ @Param[in]     h_Fm - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_Init(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_Free
+
+ @Description   Frees all resources that were assigned to FM module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_Fm - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_Free(t_Handle h_Fm);
+
+
+/**************************************************************************//**
+ @Group         FM_advanced_init_grp    FM Advanced Configuration Unit
+
+ @Description   Configuration functions used to change default values.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   DMA debug mode
+*//***************************************************************************/
+typedef enum e_FmDmaDbgCntMode {
+    e_FM_DMA_DBG_NO_CNT             = 0,    /**< No counting */
+    e_FM_DMA_DBG_CNT_DONE           = 1,    /**< Count DONE commands */
+    e_FM_DMA_DBG_CNT_COMM_Q_EM      = 2,    /**< count command queue emergency signals */
+    e_FM_DMA_DBG_CNT_INT_READ_EM    = 3,    /**< Count Internal Read buffer emergency signal */
+    e_FM_DMA_DBG_CNT_INT_WRITE_EM   = 4,    /**< Count Internal Write buffer emergency signal */
+    e_FM_DMA_DBG_CNT_FPM_WAIT       = 5,    /**< Count FPM WAIT signal */
+    e_FM_DMA_DBG_CNT_SIGLE_BIT_ECC  = 6,    /**< Single bit ECC errors. */
+    e_FM_DMA_DBG_CNT_RAW_WAR_PROT   = 7     /**< Number of times there was a need for RAW & WAR protection. */
+} e_FmDmaDbgCntMode;
+
+/**************************************************************************//**
+ @Description   DMA Cache Override
+*//***************************************************************************/
+typedef enum e_FmDmaCacheOverride {
+    e_FM_DMA_NO_CACHE_OR,                   /**< No override of the Cache field */
+    e_FM_DMA_NO_STASH_DATA,                 /**< Data should not be stashed in system level cache */
+    e_FM_DMA_MAY_STASH_DATA,                /**< Data may be stashed in system level cache */
+    e_FM_DMA_STASH_DATA                     /**< Data should be stashed in system level cache */
+} e_FmDmaCacheOverride;
+
+/**************************************************************************//**
+ @Description   DMA External Bus Priority
+*//***************************************************************************/
+typedef enum e_FmDmaExtBusPri {
+    e_FM_DMA_EXT_BUS_NORMAL,                /**< Normal priority */
+    e_FM_DMA_EXT_BUS_EBS,                   /**< AXI extended bus service priority */
+    e_FM_DMA_EXT_BUS_SOS,                   /**< AXI sos priority */
+    e_FM_DMA_EXT_BUS_EBS_AND_SOS            /**< AXI ebs + sos priority */
+} e_FmDmaExtBusPri;
+
+/**************************************************************************//**
+ @Description   enum for choosing the field that will be output on AID
+*//***************************************************************************/
+typedef enum e_FmDmaAidMode {
+    e_FM_DMA_AID_OUT_PORT_ID,               /**< 4 LSB of PORT_ID */
+    e_FM_DMA_AID_OUT_TNUM                   /**< 4 LSB of TNUM */
+} e_FmDmaAidMode;
+
+/**************************************************************************//**
+ @Description   DMA AXI Bus protection
+*//***************************************************************************/
+typedef enum e_FmDmaBusProtectionType {
+    e_FM_DMA_DATA_BUS_PROT,                 /**< AXI data bus protection */
+    e_FM_DMA_INSTRUCTION_BUS_PROT           /**< AXI instruction bus protection */
+} e_FmDmaBusProtectionType;
+
+/**************************************************************************//**
+ @Description   FPM Catasrophic error behaviour
+*//***************************************************************************/
+typedef enum e_FmCatastrophicErr {
+    e_FM_CATASTROPHIC_ERR_STALL_PORT,       /**< Port_ID is stalled (only reset can release it) */
+    e_FM_CATASTROPHIC_ERR_STALL_TASK        /**< Only errornous task is stalled */
+} e_FmCatastrophicErr;
+
+/**************************************************************************//**
+ @Description   FPM DMA error behaviour
+*//***************************************************************************/
+typedef enum e_FmDmaErr {
+    e_FM_DMA_ERR_CATASTROPHIC,              /**< Dma error is treated as a catastrophic error */
+    e_FM_DMA_ERR_REPORT                     /**< Dma error is just reported */
+} e_FmDmaErr;
+
+/**************************************************************************//**
+ @Description   DMA Emergency level by BMI emergency signal
+*//***************************************************************************/
+typedef enum e_FmDmaEmergencyLevel {
+    e_FM_DMA_EM_EBS,                        /**< EBS emergency */
+    e_FM_DMA_EM_SOS                         /**< SOS emergency */
+} e_FmDmaEmergencyLevel;
+
+/**************************************************************************//**
+ @Collection   DMA emergency options
+*//***************************************************************************/
+typedef uint32_t fmEmergencyBus_t;          /**< DMA emergency options */
+
+#define  FM_DMA_MURAM_READ_EMERGENCY        0x00800000    /**< Enable emergency for MURAM1 */
+#define  FM_DMA_MURAM_WRITE_EMERGENCY       0x00400000    /**< Enable emergency for MURAM2 */
+#define  FM_DMA_EXT_BUS_EMERGENCY           0x00100000    /**< Enable emergency for external bus */
+/* @} */
+
+/**************************************************************************//**
+ @Description   A structure for defining DMA emergency level
+*//***************************************************************************/
+typedef struct t_FmDmaEmergency {
+    fmEmergencyBus_t        emergencyBusSelect;             /**< An OR of the busses where emergency
+                                                                 should be enabled */
+    e_FmDmaEmergencyLevel   emergencyLevel;                 /**< EBS/SOS */
+} t_FmDmaEmergency;
+
+/**************************************************************************//**
+ @Description   structure for defining FM threshold
+*//***************************************************************************/
+typedef struct t_FmThresholds {
+    uint8_t                 dispLimit;                      /**< The number of times a frames may
+                                                                 be passed in the FM before assumed to
+                                                                 be looping. */
+    uint8_t                 prsDispTh;                      /**< This is the number pf packets that may be
+                                                                 queued in the parser dispatch queue*/
+    uint8_t                 plcrDispTh;                     /**< This is the number pf packets that may be
+                                                                 queued in the policer dispatch queue*/
+    uint8_t                 kgDispTh;                       /**< This is the number pf packets that may be
+                                                                 queued in the keygen dispatch queue*/
+    uint8_t                 bmiDispTh;                      /**< This is the number pf packets that may be
+                                                                 queued in the BMI dispatch queue*/
+    uint8_t                 qmiEnqDispTh;                   /**< This is the number pf packets that may be
+                                                                 queued in the QMI enqueue dispatch queue*/
+    uint8_t                 qmiDeqDispTh;                   /**< This is the number pf packets that may be
+                                                                 queued in the QMI dequeue dispatch queue*/
+    uint8_t                 fmCtl1DispTh;                    /**< This is the number pf packets that may be
+                                                                 queued in fmCtl1 dispatch queue*/
+    uint8_t                 fmCtl2DispTh;                    /**< This is the number pf packets that may be
+                                                                 queued in fmCtl2 dispatch queue*/
+} t_FmThresholds;
+
+/**************************************************************************//**
+ @Description   structure for defining DMA mode parameters
+*//***************************************************************************/
+typedef struct t_FmDmaBusProtect {
+    bool                        privilegeBusProtect;        /**< TRUE to select privilage bus protection */
+    e_FmDmaBusProtectionType    busProtectType;             /**< Data/Instruction protect select. */
+} t_FmDmaBusProtect;
+
+/**************************************************************************//**
+ @Description   structure for defining DMA thresholds
+*//***************************************************************************/
+typedef struct t_FmDmaThresholds {
+    uint8_t                     assertEmergency;            /**< When this value is reached,
+                                                                 assert emergency (Threshold)*/
+    uint8_t                     clearEmergency;             /**< After emergency is asserted, it is held
+                                                                 until this value is reached (Hystheresis) */
+} t_FmDmaThresholds;
+
+
+/**************************************************************************//**
+ @Function      FM_ConfigResetOnInit
+
+ @Description   Tell the driver whether to reset the FM before initialization or
+                not. It changes the default configuration [DEFAULT_resetOnInit].
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     enable              When TRUE, FM will be reset before any initialization.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigResetOnInit(t_Handle h_Fm, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_ConfigTotalNumOfTasks
+
+ @Description   Change the total number of tasks from its default
+                configuration [DEFAULT_totalNumOfTasks]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     totalNumOfTasks     The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigTotalNumOfTasks(t_Handle h_Fm, uint8_t totalNumOfTasks);
+
+/**************************************************************************//**
+ @Function      FM_ConfigTotalFifoSize
+
+ @Description   Change the total Fifo size from its default
+                configuration [DEFAULT_totalFifoSize]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     totalFifoSize       The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigTotalFifoSize(t_Handle h_Fm, uint32_t totalFifoSize);
+
+/**************************************************************************//**
+ @Function      FM_ConfigMaxNumOfOpenDmas
+
+ @Description   Change the maximum allowed open DMA's for this FM from its default
+                configuration [DEFAULT_maxNumOfOpenDmas]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     maxNumOfOpenDmas    The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigMaxNumOfOpenDmas(t_Handle h_Fm, uint8_t maxNumOfOpenDmas);
+
+/**************************************************************************//**
+ @Function      FM_ConfigThresholds
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default FM threshold configuration:
+                                          dispLimit:    [DEFAULT_dispLimit]
+                                          prsDispTh:    [DEFAULT_prsDispTh]
+                                          plcrDispTh:   [DEFAULT_plcrDispTh]
+                                          kgDispTh:     [DEFAULT_kgDispTh]
+                                          bmiDispTh:    [DEFAULT_bmiDispTh]
+                                          qmiEnqDispTh: [DEFAULT_qmiEnqDispTh]
+                                          qmiDeqDispTh: [DEFAULT_qmiDeqDispTh]
+                                          fmCtl1DispTh:  [DEFAULT_fmCtl1DispTh]
+                                          fmCtl2DispTh:  [DEFAULT_fmCtl2DispTh]
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     p_FmThresholds  A structure of threshold parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds);
+
+/**************************************************************************//**
+ @Function      FM_ConfigTimeStamp
+
+ @Description   This routine enables the FPM timeStamp and sets its frequency.
+                Calling this routine changes the internal driver data base
+                from its default configuration - by default time stamp is disabled.
+                The value selected here will be used for the non-Rx ports
+                rate-limit mechanism and for the policer profiles.
+                Note that rate-limiting may be done only for time
+                units larger than the timeStampPeriod specifies
+                here (i.e. select here the smallest time unit
+                required between all ports).
+
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     timeStampPeriod    (in nano-seconds)
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigTimeStamp(t_Handle h_Fm, uint32_t timeStampPeriod);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaBusProtect
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default FM threshold configuration
+                                  privilegeBusProtect:      [DEFAULT_secureBusProtect]
+                                  secureBusProtect:         [DEFAULT_privilegeBusProtect]
+                                  busProtectType:           [DEFAULT_busProtectionType]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     p_FmDmaBusProtect   A structure of bus protection parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaBusProtect(t_Handle h_Fm, t_FmDmaBusProtect *p_FmDmaBusProtect);
+
+ /**************************************************************************//**
+ @Function      FM_ConfigDmaCacheOverride
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of cache override mode [DEFAULT_cacheOverride]
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     cacheOverride   The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaCacheOverride(t_Handle h_Fm, e_FmDmaCacheOverride cacheOverride);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaAidOverride
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of aid override mode [DEFAULT_aidOverride]
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     aidOverride     The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaAidOverride(t_Handle h_Fm, bool aidOverride);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaAidMode
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of aid mode [DEFAULT_aidMode]
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     aidMode         The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaAidMode(t_Handle h_Fm, e_FmDmaAidMode aidMode);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaAxiDbgNumOfBeats
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of axi debug [DEFAULT_axiDbgNumOfBeats]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     axiDbgNumOfBeats    The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaAxiDbgNumOfBeats(t_Handle h_Fm, uint8_t axiDbgNumOfBeats);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaCamNumOfEntries
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of number of CAM entries [DEFAULT_dmaCamNumOfEntries]
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     numOfEntries    The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaCamNumOfEntries(t_Handle h_Fm, uint8_t numOfEntries);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaWatchdog
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default watchdog configuration, which is the maximum
+                possible value.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     watchDogValue   The selected new value - in microseconds.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaWatchdog(t_Handle h_Fm, uint32_t watchDogValue);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaWriteBufThresholds
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of DMA write buffer threshold
+                assertEmergency: [DEFAULT_dmaWriteIntBufLow]
+                clearEmergency:  [DEFAULT_dmaWriteIntBufHigh]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     p_FmDmaThresholds   A structure of thresholds to define emegrency behavior -
+                                    When 'assertEmergency' value is reached, emergency is asserted,
+                                    then it is held until 'clearEmergency' value is reached.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
+
+ /**************************************************************************//**
+ @Function      FM_ConfigDmaCommQThresholds
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of DMA command queue threshold
+                assertEmergency: [DEFAULT_dmaCommQLow]
+                clearEmergency:  [DEFAULT_dmaCommQHigh]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     p_FmDmaThresholds   A structure of thresholds to define emegrency behavior -
+                                    When 'assertEmergency' value is reached, emergency is asserted,
+                                    then it is held until 'clearEmergency' value is reached..
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaCommQThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaReadBufThresholds
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of DMA read buffer threshold
+                assertEmergency: [DEFAULT_dmaReadIntBufLow]
+                clearEmergency:  [DEFAULT_dmaReadIntBufHigh]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     p_FmDmaThresholds   A structure of thresholds to define emegrency behavior -
+                                    When 'assertEmergency' value is reached, emergency is asserted,
+                                    then it is held until 'clearEmergency' value is reached..
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaReadBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaSosEmergencyThreshold
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default dma SOS emergency configuration [DEFAULT_dmaSosEmergency]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     dmaSosEmergency     The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaSosEmergencyThreshold(t_Handle h_Fm, uint32_t dmaSosEmergency);
+
+/**************************************************************************//**
+ @Function      FM_ConfigEnableCounters
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default counters configuration where counters are disabled.
+
+ @Param[in]     h_Fm    A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigEnableCounters(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaDbgCounter
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default DMA debug counters configuration [DEFAULT_dmaDbgCntMode]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     fmDmaDbgCntMode     An enum selecting the debug counter mode.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaDbgCounter(t_Handle h_Fm, e_FmDmaDbgCntMode fmDmaDbgCntMode);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaStopOnBusErr
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of bus error behavior [DEFAULT_dmaStopOnBusError]
+
+
+ @Param[in]     h_Fm    A handle to an FM Module.
+ @Param[in]     stop    TRUE to stop on bus error, FALSE to continue.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+                Only if bus error is enabled.
+*//***************************************************************************/
+t_Error FM_ConfigDmaStopOnBusErr(t_Handle h_Fm, bool stop);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaEmergency
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of DMA emergency where's it's disabled.
+
+ @Param[in]     h_Fm        A handle to an FM Module.
+ @Param[in]     p_Emergency An OR mask of all required options.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaEmergency(t_Handle h_Fm, t_FmDmaEmergency *p_Emergency);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaEmergencySmoother
+
+ @Description   sets the minimum amount of DATA beats transferred on the AXI
+                READ and WRITE ports before lowering the emergency level.
+                By default smother is disabled.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     emergencyCnt    emergency switching counter.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaEmergencySmoother(t_Handle h_Fm, uint32_t emergencyCnt);
+
+/**************************************************************************//**
+ @Function      FM_ConfigDmaErr
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default DMA error treatment [DEFAULT_dmaErr]
+
+ @Param[in]     h_Fm    A handle to an FM Module.
+ @Param[in]     dmaErr  The selected new choice.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigDmaErr(t_Handle h_Fm, e_FmDmaErr dmaErr);
+
+/**************************************************************************//**
+ @Function      FM_ConfigCatastrophicErr
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default behavior on catastrophic error [DEFAULT_catastrophicErr]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     catastrophicErr     The selected new choice.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigCatastrophicErr(t_Handle h_Fm, e_FmCatastrophicErr catastrophicErr);
+
+/**************************************************************************//**
+ @Function      FM_ConfigEnableMuramTestMode
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of test mode where it's disabled.
+
+ @Param[in]     h_Fm    A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigEnableMuramTestMode(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_ConfigEnableIramTestMode
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of test mode where it's disabled.
+
+ @Param[in]     h_Fm    A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigEnableIramTestMode(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_ConfigHaltOnExternalActivation
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of FM behaviour on external halt
+                activation [DEFAULT_haltOnExternalActivation].
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     enable          TRUE to enable halt on external halt
+                                activation.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigHaltOnExternalActivation(t_Handle h_Fm, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_ConfigHaltOnUnrecoverableEccError
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of FM behaviour on unrecoverable
+                Ecc error [DEFAULT_haltOnUnrecoverableEccError].
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     enable          TRUE to enable halt on unrecoverable Ecc error
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigHaltOnUnrecoverableEccError(t_Handle h_Fm, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_ConfigException
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of exceptions enablement.
+                By default all exceptions are enabled.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_ConfigExternalEccRamsEnable
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default [DEFAULT_externalEccRamsEnable].
+                When this option is enabled Rams ECC enable is not effected
+                by the FPM RCR bit, but by a JTAG.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     enable          TRUE to enable this option.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable);
+
+/** @} */ /* end of FM_advanced_init_grp group */
+/** @} */ /* end of FM_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_runtime_control_grp FM Runtime Control Unit
+
+ @Description   FM Runtime control unit API functions, definitions and enums.
+                The FM driver provides a set of control routines for each module.
+                These routines may only be called after the module was fully
+                initialized (both configuration and initialization routines were
+                called). They are typically used to get information from hardware
+                (status, counters/statistics, revision etc.), to modify a current
+                state or to force/enable a required action. Run-time control may
+                be called whenever necessary and as many times as needed.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection   General FM defines.
+*//***************************************************************************/
+#define NUM_OF_PORT_TYPES               e_FM_PORT_TYPE_DUMMY    /**< Number of port types */
+#define MAX_NUM_OF_PORTS_PER_TYPE       7                       /**< Max number of ports of the same type */
+/* @} */
+
+/**************************************************************************//**
+ @Description   Port id by type and relative id.
+                This type is a 2 dimentional array of port id's according
+                to port types.used to pass per-port parameters.
+                Note that not all places in the array are valid e.g
+                array[e_FM_PORT_TYPE_TX_10G][1] is not a valid indexes pair.
+*//***************************************************************************/
+typedef uint8_t t_PortsParam[NUM_OF_PORT_TYPES][MAX_NUM_OF_PORTS_PER_TYPE];
+
+/**************************************************************************//**
+ @Description   DMA Emergency control on MURAM
+*//***************************************************************************/
+typedef enum e_FmDmaMuramPort {
+    e_FM_DMA_MURAM_PORT_WRITE,              /**< MURAM write port */
+    e_FM_DMA_MURAM_PORT_READ                /**< MURAM read port */
+} e_FmDmaMuramPort;
+
+/**************************************************************************//**
+ @Description   enum for defining FM counters
+*//***************************************************************************/
+typedef enum e_FmCounters {
+    e_FM_COUNTERS_ENQ_TOTAL_FRAME,              /**< QMI total enqueued frames counter */
+    e_FM_COUNTERS_DEQ_TOTAL_FRAME,              /**< QMI total dequeued frames counter */
+    e_FM_COUNTERS_DEQ_0,                        /**< QMI 0 frames from QMan counter */
+    e_FM_COUNTERS_DEQ_1,                        /**< QMI 1 frames from QMan counter */
+    e_FM_COUNTERS_DEQ_2,                        /**< QMI 2 frames from QMan counter */
+    e_FM_COUNTERS_DEQ_3,                        /**< QMI 3 frames from QMan counter */
+    e_FM_COUNTERS_DEQ_FROM_DEFAULT,             /**< QMI dequeue from default queue counter */
+    e_FM_COUNTERS_DEQ_FROM_CONTEXT,             /**< QMI dequeue from FQ context counter */
+    e_FM_COUNTERS_DEQ_FROM_FD,                  /**< QMI dequeue from FD command field counter */
+    e_FM_COUNTERS_DEQ_CONFIRM,                  /**< QMI dequeue confirm counter */
+    e_FM_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT,   /**< DMA semaphor reject due to full entry counter */
+    e_FM_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT,   /**< DMA semaphor reject due to full CAM queue counter */
+    e_FM_COUNTERS_SEMAPHOR_SYNC_REJECT          /**< DMA semaphor reject due to sync counter */
+} e_FmCounters;
+
+/**************************************************************************//**
+ @Description   structure for returning revision information
+*//***************************************************************************/
+typedef struct t_FmRevisionInfo {
+    uint8_t         majorRev;               /**< Major revision */
+    uint8_t         minorRev;               /**< Minor revision */
+} t_FmRevisionInfo;
+
+/**************************************************************************//**
+ @Description   struct for defining DMA status
+*//***************************************************************************/
+typedef struct t_FmDmaStatus {
+    bool    cmqNotEmpty;            /**< Command queue is not empty */
+    bool    busError;               /**< Bus error occured */
+    bool    readBufEccError;        /**< Double ECC error on buffer Read */
+    bool    writeBufEccSysError;    /**< Double ECC error on buffer write from system side */
+    bool    writeBufEccFmError;     /**< Double ECC error on buffer write from FM side */
+} t_FmDmaStatus;
+
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//**
+ @Function      FM_DumpRegs
+
+ @Description   Dumps all FM registers
+
+ @Param[in]     h_Fm      A handle to an FM Module.
+
+ @Return        E_OK on success;
+
+ @Cautions      Allowed only FM_Init().
+*//***************************************************************************/
+t_Error FM_DumpRegs(t_Handle h_Fm);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+/**************************************************************************//**
+ @Function      FM_Isr
+
+ @Description   FM interrupt-service-routine.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void FM_Isr(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_SetException
+
+ @Description   Calling this routine enables/disables the specified exception.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_SetPortsBandwidth
+
+ @Description   Sets relative weights between ports when accessing common resources.
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     p_PortsBandwidth    A table of ports bandwidth in percentage, i.e.
+                                    total must equal 100.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_PortsParam *p_PortsBandwidth);
+
+/**************************************************************************//**
+ @Function      FM_EnableRamsEcc
+
+ @Description   Enables ECC mechanism for the different FM RAM's - IRAM, MURAM,
+                Parser, Keygen and Policer.
+                Note:
+                If FM_ConfigExternalEccRamsEnable was called to enable external
+                setting of ECC, this routine effects IRAM ECC only.
+                This routine is also called by the driver if an ECC exception is
+                enabled.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_EnableRamsEcc(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_DisableRamsEcc
+
+ @Description   Disables ECC mechanism for the different FM RAM's - IRAM, MURAM,
+                Parser, Keygen and Policer.
+                Note:
+                If FM_ConfigExternalEccRamsEnable was called to enable external
+                setting of ECC, this routine effects IRAM ECC only.
+                In opposed to FM_EnableRamsEcc, this routine must be called
+                explicitly to disable all Rams ECC.
+
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+*//***************************************************************************/
+t_Error FM_DisableRamsEcc(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_GetRevision
+
+ @Description   Returns the FM revision
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[out]    p_FmRevisionInfo    A structure of revision information parameters.
+
+ @Return        None.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void  FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo);
+
+/**************************************************************************//**
+ @Function      FM_GetCounter
+
+ @Description   Reads one of the FM counters.
+
+ @Param[in]     h_Fm        A handle to an FM Module.
+ @Param[in]     counter     The requested counter.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_Init().
+                Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter);
+
+/**************************************************************************//**
+ @Function      FM_SetCounter
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     h_Fm        A handle to an FM Module.
+ @Param[in]     counter     The requested counter.
+ @Param[in]     val         The requested value to be written into the counter.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error  FM_SetCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val);
+
+/**************************************************************************//**
+ @Function      FM_Resume
+
+ @Description   Release FM after halt FM command or after unrecoverable ECC error.
+
+ @Param[in]     h_Fm        A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+void FM_Resume(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_GetTimeStamp
+
+ @Description   Reads the current time stamp
+
+ @Param[in]     h_Fm    A handle to an FM Module.
+
+ @Return        TimeStamp integer at calling time.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+uint32_t FM_GetTimeStamp(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_DmaEmergencyCtrl
+
+ @Description   Manual emergency set
+
+ @Param[in]     h_Fm        A handle to an FM Module.
+ @Param[in]     muramPort   MURAM direction select.
+ @Param[in]     enable      TRUE to manualy enable emergency, FALSE to disable.
+
+ @Return        None.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void FM_DmaEmergencyCtrl(t_Handle h_Fm, e_FmDmaMuramPort muramPort, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_SetDmaExtBusPri
+
+ @Description   Manual emergency set
+
+ @Param[in]     h_Fm    A handle to an FM Module.
+ @Param[in]     pri     External bus priority select
+
+ @Return        None.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void FM_SetDmaExtBusPri(t_Handle h_Fm, e_FmDmaExtBusPri pri);
+
+/**************************************************************************//**
+ @Function      FM_ForceIntr
+
+ @Description   Causes an interrupt event on the requested source.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     exception       An exception to be forced.
+
+ @Return        E_OK on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception);
+
+/**************************************************************************//**
+ @Function      FM_GetDmaStatus
+
+ @Description   Reads the DMA current status
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[out]     p_FmDmaStatus      A structure of DMA status parameters.
+
+ @Return        None
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void FM_GetDmaStatus(t_Handle h_Fm, t_FmDmaStatus *p_FmDmaStatus);
+
+/**************************************************************************//**
+ @Function      FM_GetPcdHandle
+
+ @Description   Used by FMC in order to get PCD handle
+
+ @Param[in]     h_Fm     A handle to an FM Module.
+
+ @Return        A handle to the PCD module, NULL if uninitialized.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Handle FM_GetPcdHandle(t_Handle h_Fm);
+/** @} */ /* end of FM_runtime_control_grp group */
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//**
+ @Function      FmDumpPortRegs
+
+ @Description   Dumps FM port registers which are part of FM common registers
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     hardwarePortId    HW port id.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only FM_Init().
+*//***************************************************************************/
+t_Error FmDumpPortRegs(t_Handle h_Fm,uint8_t hardwarePortId);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+/** @} */ /* end of FM_lib_grp group */
+/** @} */ /* end of FM_grp group */
+
+/*****************************************************/
+/*****************************************************/
+/****   Inter-module Routines and definitions     ****/
+/*****************************************************/
+/*****************************************************/
+#ifndef DOXYGEN_ONLY
+
+/**************************************************************************//**
+@Group         FM_InterModule_grp FM Inter-Module Unit
+
+ @Description   FM Inter Module functions -
+                These are not User API routines but routines that may be called
+                from other modules.
+                Routines used by PCD module are always called directly by the PCD
+                module, since the PCD and FM modules always run on the same core.
+                As for routines used by other modules (FM-Port), They will be called directly
+                in a single core environment. In a multicore environment, some of the
+                other modules may be run by other cores and therefor these routines
+                may not be called directly and will be internally invoked using the
+                XX messeging mechanism.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection   Defines used for enabling/disabling FM interrupts
+
+ @{
+*//***************************************************************************/
+
+typedef uint32_t t_FmBlockErrIntrEnable;
+
+#define ERR_INTR_EN_DMA         0x00010000      /**< TBD */
+#define ERR_INTR_EN_FPM         0x80000000      /**< TBD */
+#define ERR_INTR_EN_BMI         0x00800000      /**< TBD */
+#define ERR_INTR_EN_QMI         0x00400000      /**< TBD */
+#define ERR_INTR_EN_PRS         0x00200000      /**< TBD */
+#define ERR_INTR_EN_KG          0x00100000      /**< TBD */
+#define ERR_INTR_EN_PLCR        0x00080000      /**< TBD */
+#define ERR_INTR_EN_MURAM       0x00040000      /**< TBD */
+#define ERR_INTR_EN_IRAM        0x00020000      /**< TBD */
+#define ERR_INTR_EN_10G_MAC0    0x00008000      /**< TBD */
+#define ERR_INTR_EN_1G_MAC0     0x00004000      /**< TBD */
+#define ERR_INTR_EN_1G_MAC1     0x00002000      /**< TBD */
+#define ERR_INTR_EN_1G_MAC2     0x00001000      /**< TBD */
+#define ERR_INTR_EN_1G_MAC3     0x00000800      /**< TBD */
+
+typedef uint32_t t_FmBlockIntrEnable;           /**< TBD */
+
+#define INTR_EN_BMI             0x80000000      /**< TBD */
+#define INTR_EN_QMI             0x40000000      /**< TBD */
+#define INTR_EN_PRS             0x20000000      /**< TBD */
+#define INTR_EN_KG              0x10000000      /**< TBD */
+#define INTR_EN_PLCR            0x08000000      /**< TBD */
+#define INTR_EN_REV0            0x00008000      /**< TBD */
+#define INTR_EN_REV1            0x00004000      /**< TBD */
+#define INTR_EN_REV2            0x00002000      /**< TBD */
+#define INTR_EN_REV3            0x00001000      /**< TBD */
+#define INTR_EN_BRK             0x00000080      /**< TBD */
+#define INTR_EN_TMR             0x01000000      /**< TBD */
+#define INTR_EN_1G_MAC0_TMR     0x00080000      /**< TBD */
+#define INTR_EN_1G_MAC1_TMR     0x00040000      /**< TBD */
+#define INTR_EN_1G_MAC2_TMR     0x00020000      /**< TBD */
+#define INTR_EN_1G_MAC3_TMR     0x00010000      /**< TBD */
+#define INTR_EN_1G_MAC1         0x00400000      /**< TBD */
+#define INTR_EN_1G_MAC2         0x00200000      /**< TBD */
+#define INTR_EN_1G_MAC3         0x00100000      /**< TBD */
+
+/* @} */
+
+
+/**************************************************************************//**
+ @Description   Enum for inter-module interrupts registration
+*//***************************************************************************/
+typedef enum e_FmInterModuleEvent {
+    e_FM_EV_PRS,                    /**< Parser event */
+    e_FM_EV_ERR_PRS,                /**< Parser error event */
+    e_FM_EV_KG,                     /**< Keygen event */
+    e_FM_EV_ERR_KG,                 /**< Keygen error event */
+    e_FM_EV_PLCR,                   /**< Policer event */
+    e_FM_EV_ERR_PLCR,               /**< Policer error event */
+    e_FM_EV_ERR_10G_MAC0,           /**< 10G MAC 0 error event */
+    e_FM_EV_ERR_1G_MAC0,            /**< 1G MAC 0 error event */
+    e_FM_EV_ERR_1G_MAC1,            /**< 1G MAC 1 error event */
+    e_FM_EV_ERR_1G_MAC2,            /**< 1G MAC 2 error event */
+    e_FM_EV_ERR_1G_MAC3,            /**< 1G MAC 3 error event */
+    e_FM_EV_TMR,                    /**< Timer event */
+    e_FM_EV_1G_MAC1,                /**< 1G MAC 1 event */
+    e_FM_EV_1G_MAC2,                /**< 1G MAC 2 event */
+    e_FM_EV_1G_MAC3,                /**< 1G MAC 3 event */
+    e_FM_EV_1G_MAC0_TMR,            /**< 1G MAC 0 Timer event */
+    e_FM_EV_1G_MAC1_TMR,            /**< 1G MAC 1 Timer event */
+    e_FM_EV_1G_MAC2_TMR,            /**< 1G MAC 2 Timer event */
+    e_FM_EV_1G_MAC3_TMR,            /**< 1G MAC 3 Timer event */
+    e_FM_EV_DUMMY_LAST
+} e_FmInterModuleEvent;
+
+/**************************************************************************//**
+ @Description   enum for defining MAC types
+*//***************************************************************************/
+typedef enum e_FmMacType {
+    e_FM_MAC_10G,               /**< 10G MAC */
+    e_FM_MAC_1G                 /**< 1G MAC */
+} e_FmMacType;
+
+/**************************************************************************//**
+ @Description   Structure for port-FM communication during FM_PORT_Init.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+                Some fields are optional (depending on configuration) and
+                will be analized by the port and FM modules accordingly.
+*//***************************************************************************/
+typedef struct t_FmInterModulePortInitParams {
+    uint8_t             hardwarePortId;       /**< IN. port Id */
+    e_FmPortType        portType;           /**< IN. Port type */
+    uint32_t            timeStampPeriod;    /**< OUT. Time stamp period in NanoSec */
+    bool                independentMode;    /**< IN. TRUE if FM Port operates in independent mode */
+    uint8_t             portPartition;      /**< IN. Port's requested resource */
+    uint8_t             numOfTasks;         /**< IN. Port's requested resource */
+    uint8_t             numOfExtraTasks;    /**< IN. Port's requested resource */
+    uint8_t             numOfOpenDmas;      /**< IN. Port's requested resource */
+    uint8_t             numOfExtraOpenDmas; /**< IN. Port's requested resource */
+    uint32_t            sizeOfFifo;         /**< IN. Port's requested resource */
+    uint32_t            extraSizeOfFifo;    /**< IN. Port's requested resource */
+    uint8_t             deqPipelineDepth;   /**< IN. Port's requested resource */
+    t_FmPhysAddr        fmMuramPhysBaseAddr;/**< OUT. FM-MURAM physical address*/
+} t_FmInterModulePortInitParams;
+
+/**************************************************************************//**
+ @Description   Structure for port-FM communication during FM_PORT_Free.
+*//***************************************************************************/
+typedef struct t_FmInterModulePortFreeParams {
+    uint8_t             hardwarePortId;     /**< IN. port Id */
+    e_FmPortType        portType;           /**< IN. Port type */
+    uint8_t             deqPipelineDepth;   /**< IN. Port's requested resource */
+} t_FmInterModulePortFreeParams;
+
+/**************************************************************************//**
+ @Function      FmRegisterIntr
+
+ @Description   Used to register an inter-module event handler to be processed by FM
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     event           Event selector
+ @Param[in]     f_Isr           The interrupt service routine.
+ @Param[in]     h_Arg           Argument to be passed to f_Isr.
+
+ @Return        None.
+*//***************************************************************************/
+void FmRegisterIntr(t_Handle               h_Fm,
+                     e_FmInterModuleEvent   event,
+                     void                   (*f_Isr) (t_Handle h_Arg),
+                     t_Handle               h_Arg);
+
+/**************************************************************************//**
+ @Function      FmRegisterFmCtlIntr
+
+ @Description   Used to register to one of the fmCtl events in the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     eventRegId      FmCtl event id (0-7).
+ @Param[in]     f_Isr           The interrupt service routine.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void  FmRegisterFmCtlIntr(t_Handle h_Fm, uint8_t eventRegId, void (*f_Isr) (t_Handle h_Fm, uint32_t event));
+
+/**************************************************************************//**
+ @Function      FmGetPcdPrsBaseAddr
+
+ @Description   Get the base address of the Parser from the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        Base address.
+*//***************************************************************************/
+uint64_t FmGetPcdPrsBaseAddr(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmGetPcdKgBaseAddr
+
+ @Description   Get the base address of the Keygen from the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        Base address.
+*//***************************************************************************/
+uint64_t FmGetPcdKgBaseAddr(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmGetPcdPlcrBaseAddr
+
+ @Description   Get the base address of the Policer from the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        Base address.
+*//***************************************************************************/
+uint64_t FmGetPcdPlcrBaseAddr(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmGetMuramHandle
+
+ @Description   Get the handle of the MURAM from the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        MURAM module handle.
+*//***************************************************************************/
+t_Handle FmGetMuramHandle(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmGetPhysicalMuramBase
+
+ @Description   Get the physical base address of the MURAM from the FM module
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     fmPhysAddr      Physical MURAM base
+
+ @Return        Physical base address.
+*//***************************************************************************/
+t_Error FmGetPhysicalMuramBase(t_Handle h_Fm, t_FmPhysAddr *fmPhysAddr);
+
+/**************************************************************************//**
+ @Function      FmGetTimeStampPeriod
+
+ @Description   Used internally by other modules in order to get the timeStamp
+                period as requested by the application.
+
+ @Param[in]     h_Fm                    A handle to an FM Module.
+
+ @Return        TimeStamp period in nanoseconds.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+uint32_t    FmGetTimeStampPeriod(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmResumeStalledPort
+
+ @Description   Used internally by FM port to release a stalled port.
+
+ @Param[in]     h_Fm                            A handle to an FM Module.
+ @Param[in]     hardwarePortId                    HW port id.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FmResumeStalledPort(t_Handle h_Fm, uint8_t hardwarePortId);
+
+/**************************************************************************//**
+ @Function      FmIsPortStalled
+
+ @Description   Used internally by FM port to read the port's status.
+
+ @Param[in]     h_Fm                            A handle to an FM Module.
+ @Param[in]     hardwarePortId                    HW port id.
+
+ @Return        TRUE if port is stalled, FALSE otherwize
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+bool FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId);
+
+/**************************************************************************//**
+ @Function      FmResetMac
+
+ @Description   Used by MAC driver to reset the MAC registers
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     type            MAC type.
+ @Param[in]     macId           MAC id - according to type.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId);
+
+/**************************************************************************//**
+ @Function      FmGetId
+
+ @Description   Used by PCD driver to read rhe FM id
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+uint8_t FmGetId(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FmGetSetPortParams
+
+ @Description   Used by FM-PORT driver to pass and receive parameters between
+                PORT and FM modules.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in,out] p_PortParams    A structure of FM Port parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortParams);
+
+/**************************************************************************//**
+ @Function      FmFreePortParams
+
+ @Description   Used by FM-PORT driver to free port's resources within the FM.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in,out] p_PortParams    A structure of FM Port parameters.
+
+ @Return        None.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams);
+
+#if (defined(CONFIG_MULTI_PARTITION_SUPPORT) && !defined(CONFIG_GUEST_PARTITION))
+t_Error     FmHandleIpcMsg(t_Handle h_Fm, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE]);
+#endif /* (defined(CONFIG_MULTI_PARTITION_SUPPORT) && ... */
+void        FmRegisterPcd(t_Handle h_Fm, t_Handle h_FmPcd);
+t_Handle    FmGetPcdHandle(t_Handle h_Fm);
+bool        FmRamsEccIsExternalCtl(t_Handle h_Fm);
+
+
+/** @} */ /* end of FM_lib_grp group */
+
+#endif /* ! DOXYGEN_ONLY */
+
+#endif /* __FM_EXT */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
new file mode 100644
index 0000000..a034268
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
@@ -0,0 +1,617 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_mac_ext.h
+
+ @Description   FM MAC ...
+*//***************************************************************************/
+#ifndef __FM_MAC_EXT_H
+#define __FM_MAC_EXT_H
+
+#include "std_ext.h"
+#include "enet_ext.h"
+
+
+/**************************************************************************//**
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_mac_grp FM MAC
+
+ @Description   FM MAC API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   interrupt setup option
+*//***************************************************************************/
+typedef enum e_FmMacIntOption {
+    e_FM_MAC_INT_NONE,                      /**<   Disable all Interrupts */
+    e_FM_MAC_INT_DFLT,                      /**<   Enable Default Interrupts */
+    e_FM_MAC_INT_ALL                        /**<   Enable all Interrupts */
+} e_FmMacIntOption;
+
+/**************************************************************************//**
+ @Description   interrupt Exceptions
+*//***************************************************************************/
+typedef enum e_FmMacExceptions {
+    e_FM_MAC_INT_FATAL,                     /**<   Enable all Interrupts */
+    e_FM_MAC_INT_RECOVER,                   /**<   Enable Default Interrupts */
+    e_FM_MAC_INT_MINOR                      /**<   Disable all Interrupts */
+} e_FmMacExceptions;
+
+
+/**************************************************************************//**
+ @Function      t_FmMacExceptionCallback
+
+ @Description   Fm Mac Exception Callback from FM MAC to the user
+
+ @Param[in]     h_App             - Handle to the upper layer handler
+
+ @Param[in]     exceptions        - Exceptions clasification
+
+ @Param[in]     events            - bitwise denition of the exact mac event register
+
+ @Return        void.
+*//***************************************************************************/
+typedef void (t_FmMacExceptionCallback)(t_Handle h_App, e_FmMacExceptions exceptions, uint32_t events);
+
+
+/**************************************************************************//**
+ @Description   TM MAC statistics rfc3635
+*//***************************************************************************/
+typedef struct t_FmMacStatistics {
+/* RMON */
+    uint64_t  eStatPkts64;             /**< r-10G tr-DT 64 byte frame counter */
+    uint64_t  eStatPkts65to127;        /**< r-10G 65 to 127 byte frame counter */
+    uint64_t  eStatPkts128to255;       /**< r-10G 128 to 255 byte frame counter */
+    uint64_t  eStatPkts256to511;       /**< r-10G 256 to 511 byte frame counter */
+    uint64_t  eStatPkts512to1023;      /**< r-10G 512 to 1023 byte frame counter */
+    uint64_t  eStatPkts1024to1518;     /**< r-10G 1024 to 1518 byte frame counter */
+    uint64_t  eStatPkts1519to1522;     /**< r-10G 1519 to 1522 byte good frame count */
+/* */
+    uint64_t  eStatFragments;          /**< Total number of packets that were less than 64 octets long with a wrong CRC.*/
+    uint64_t  eStatJabbers;            /**< Total number of packets longer than valid maximum length octets */
+    uint64_t  eStatsDropEvents;        /**< number of dropped packets due to internal errors of the MAC Client. */
+    uint64_t  eStatCRCAlignErrors;     /**< Incremented when frames of correct length but with CRC error are received.*/
+    uint64_t  eStatUndersizePkts;      /**< Total number of packets that were less than 64 octets long with a good CRC.*/
+    uint64_t  eStatOversizePkts;       /**< T,B.D*/
+/* Pause */
+    uint64_t  teStatPause;             /**< Pause MAC Control received */
+    uint64_t  reStatPause;             /**< Pause MAC Control sent */
+
+/* MIB II */
+    uint64_t  ifInOctets;               /**< Total number of byte received. */
+    uint64_t  ifInPkts;                 /**< Total number of packets received.*/
+    uint64_t  ifInMcastPkts;            /**< Total number of multicast frame received*/
+    uint64_t  ifInBcastPkts;            /**< Total number of broadcast frame received */
+    uint64_t  ifInDiscards;             /**< Frames received, but discarded due to problems within the MAC RX. */
+    uint64_t  ifInErrors;               /**< Number of frames received with error:
+                                                 FIFO Overflow Error
+                                                 CRC Error
+                                                 Frame Too Long Error
+                                                 Alignment Error
+                                                 The dedicated Error Code (0xfe, not a code error) was received */
+    uint64_t  ifOutOctets;              /**< Total number of byte sent. */
+    uint64_t  ifOutPkts;                /**< Total number of packets sent .*/
+    uint64_t  ifOutMcastPkts;           /**< Total number of multicast frame sent */
+    uint64_t  ifOutBcastPkts;           /**< Total number of multicast frame sent */
+    uint64_t  ifOutDiscards;            /**< Frames received, but discarded due to problems within the MAC TX N/A!.*/
+    uint64_t  ifOutErrors;              /**< Number of frames transmitted with error:
+                                                 FIFO Overflow Error
+                                                 FIFO Underflow Error
+                                                 Other*/
+} t_FmMacStatistics;
+
+
+/**************************************************************************//**
+ @Group         FM_mac_init_grp Initialization Unit
+
+ @Description   FM MAC Initialization Unit
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   FM MAC config input
+*//***************************************************************************/
+typedef struct t_FmMacParams {
+    uint64_t                    baseAddr;           /**< Base of memory mapped FM MAC registers */
+    uint8_t                     macId;              /**< MAC ID <dTSEC 0-3> <10G 0>         */
+    t_EnetAddr                  addr;               /**< MAC address of device; First octet is sent first */
+    e_EnetMode                  enetMode;           /**< Ethernet operation mode (MAC-PHY interface and speed) */
+    t_FmMacExceptionCallback    *f_Exceptions;      /**< Exception Callback Routine         */
+    t_Handle                    h_App;              /**< A handle to an application layer object; This handle will
+                                                         be passed by the driver upon calling the above callbacks */
+    t_Handle                    h_Fm;               /**< A handle to the FM object this port related to */
+} t_FmMacParams;
+
+
+/**************************************************************************//**
+ @Function      FM_MAC_Config
+
+ @Description   Creates descriptor for the FM MAC module.
+
+                The routine returns a handle (descriptor) to the FM MAC object.
+                This descriptor must be passed as first parameter to all other
+                FM MAC function calls.
+
+                No actual initialization or configuration of FM MAC hardware is
+                done by this routine.
+
+ @Param[in]     p_FmMacParam   - Pointer to data structure of parameters
+
+ @Retval        Handle to FM MAC object, or NULL for Failure.
+*//***************************************************************************/
+t_Handle FM_MAC_Config (t_FmMacParams *p_FmMacParam);
+
+/**************************************************************************//**
+ @Function      FM_MAC_Init
+
+ @Description   Initializes the FM MAC module
+
+ @Param[in]     h_FmMac - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error  FM_MAC_Init (t_Handle h_FmMac);
+
+/**************************************************************************//**
+ @Function      FM_Free
+
+ @Description   Frees all resources that were assigned to FM MAC module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmMac - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error  FM_MAC_Free (t_Handle h_FmMac);
+
+
+/**************************************************************************//**
+ @Group         FM_mac_advanced_init_grp    Advanced Configuration Unit
+
+ @Description   Configuration functions used to change default values.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigStatistics
+
+ @Description   Enable/Disable RMON statistics
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigStatistics (t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigLoopback
+
+ @Description   Enable/Disable internal loopback mode
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigLoopback (t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigMaxFrameLength
+
+ @Description   Setup maximum Farme Length
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     newVal     MAX Frame length
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigMaxFrameLength (t_Handle h_FmMac, uint16_t newVal);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigWan
+
+ @Description   ENABLE WAN mode in 10G MAC
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigWan (t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigPadAndCrc
+
+ @Description   Config PAD and CRC mode
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigPadAndCrc (t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigHalfDuplex
+
+ @Description   Config Half Duplex Mode
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigHalfDuplex (t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigHugeFrames
+
+ @Description   Enable Huge Frame mode
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     enable     TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigHugeFrames (t_Handle h_FmMac, bool enable);
+/** @} */ /* end of FM_mac_advanced_init_grp group */
+/** @} */ /* end of FM_mac_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_mac_runtime_control_grp Runtime Control Unit
+
+ @Description   FM MAC Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_MAC_Enable
+
+ @Description   Enable the MAC
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     mode       Mode of operation (RX, TX, Both)
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_Enable  (t_Handle h_FmMac,  e_CommMode mode);
+
+/**************************************************************************//**
+ @Function      FM_MAC_Disable
+
+ @Description   DISABLE the MAC
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     mode       Define what part to Disable (RX,  TX or BOTH)
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_Disable (t_Handle h_FmMac, e_CommMode mode);
+
+/**************************************************************************//**
+ @Function      FM_MAC_Restart
+
+ @Description   Restart Rx and Tx on FM-MAC controller
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     mode       Restart the MAC to this mode
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Disable().
+*//***************************************************************************/
+t_Error FM_MAC_Restart (t_Handle h_FmMac, e_CommMode mode);
+
+/**************************************************************************//**
+ @Function      FM_MAC_Reset
+
+ @Description   Reset FM-MAC controller. The controller will be back to default setup.
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     wait       Reset the MAC to this mode
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Disable(). After this routine is
+                being called, the only operation allowed is FM_MAC_Free().
+*//***************************************************************************/
+t_Error FM_MAC_Reset (t_Handle h_FmMac, bool wait);
+
+/**************************************************************************//**
+ @Function      FM_MAC_TxMacPause
+
+ @Description   Enable transmition of  Pause frame
+
+ @Param[in]     h_FmMac     A handle to a FM MAC Module.
+ @Param[in]     pauseTime   Define pause time
+ @Param[in]     exPauseTime define Extended pause time (not on 10G)
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_TxMacPause (t_Handle h_FmMac, uint16_t pauseTime, uint16_t exPauseTime);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ResetCounters
+
+ @Description   reset all statistics counters
+
+ @Param[in]     h_FmMac     A handle to a FM MAC Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ResetCounters (t_Handle h_FmMac);
+
+/**************************************************************************//**
+ @Function      FM_MAC_SetExceptions
+
+ @Description   Setup Excption Handler
+
+ @Param[in]     h_FmMac         A handle to a FM MAC Module.
+ @Param[in]     ex              Type of the desired excpetions
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_SetExceptions(t_Handle h_FmMac, e_FmMacExceptions ex);
+
+/**************************************************************************//**
+ @Function      FM_MAC_GetStatistics
+
+ @Description   get all statistics counters
+
+ @Param[in]     h_FmMac         A handle to a FM MAC Module.
+ @Param[in]     p_Statistics    Staructure with statistics
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FM_MAC_GetStatistics (t_Handle h_FmMac, t_FmMacStatistics *p_Statistics);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ModifyMacAddr
+
+ @Description   Replace the main MAC Address
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     p_EnetAddr  -   Ethernet Mac address
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ModifyMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+
+/**************************************************************************//**
+ @Function      FM_MAC_AddHashMacAddr
+
+ @Description   Add an Address to the hash table. This is for filter purpose only.
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     p_EnetAddr  -   Ethernet Mac address
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init(). It is a filter only address.
+ @Cautions      Some address need to be filterd out in upper FM blocks.
+*//***************************************************************************/
+t_Error FM_MAC_AddHashMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+
+/**************************************************************************//**
+ @Function      FM_MAC_RemoveHashMacAddr
+
+ @Description   Delete an Address to the hash table. This is for filter purpose only.
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     p_EnetAddr  -   Ethernet Mac address
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_RemoveHashMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+
+/**************************************************************************//**
+ @Function      FM_MAC_AddExactMatchMacAddr
+
+ @Description   Add a unicast or multicast mac address (8 on dTSEC 1 on 10G).
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     p_EnetAddr  -   MAC Address to ADD
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_AddExactMatchMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+
+/**************************************************************************//**
+ @Function      FM_MAC_RemovelExactMatchMacAddr
+
+ @Description   Remove a uni cast or multi cast mac address
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     p_EnetAddr  -   MAC Address to remove
+
+ @Return        E_OK on success; Error code otherwise..
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_RemovelExactMatchMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+
+/**************************************************************************//**
+ @Function      FM_MAC_SetPromiscuous
+
+ @Description   Enable/Disable MAC Promiscuous mode for ALL mac addresses.
+
+ @Param[in]     h_FmMac    - A handle to a FM MAC Module.
+ @Param[in]     enable     - TRUE to enable or FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_SetPromiscuous (t_Handle h_FmMac, bool enable);
+/**************************************************************************//**
+ @Function      FM_MAC_AdjustLink
+
+ @Description   Adjusts the Ethernet link with new speed/duplex setup.
+
+ @Param[in]     h_FmMac     - A handle to a FM Module.
+ @Param[in]     speed       - Ethernet speed.
+ @Param[in]     fullDuplex  - TRUE for Full-Duplex mode;
+                              FALSE for Half-Duplex mode.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_MAC_AdjustLink(t_Handle h_FmMac, e_EnetSpeed speed, bool fullDuplex);
+
+/**************************************************************************//**
+ @Function      FM_MAC_GetId
+
+ @Description   Return the MAC ID
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[out]    p_MacId     -   MAC ID of device
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_GetId (t_Handle h_FmMac, uint32_t *p_MacId);
+
+/**************************************************************************//**
+ @Function      FM_MAC_GetVesrion
+
+ @Description   Return Mac HW chip version
+
+ @Param[in]     h_FmMac      -   A handle to a FM Module.
+ @Param[out]    p_MacVresion -   Mac version as defined by the chip
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_GetVesrion (t_Handle h_FmMac, uint32_t *p_MacVresion);
+
+/**************************************************************************//**
+ @Function      FM_MAC_MII_WritePhyReg
+
+ @Description   Write data into Phy Register
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     phyAddr     -   Phy Address on the MII bus
+ @Param[in]     reg         -   Register Number.
+ @Param[in]     data        -   Data to write.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_MII_WritePhyReg (t_Handle h_FmMac, uint8_t phyAddr, uint8_t reg, uint16_t data);
+
+/**************************************************************************//**
+ @Function      FM_MAC_MII_ReadPhyReg
+
+ @Description   Read data from Phy Register
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+ @Param[in]     phyAddr     -   Phy Address on the MII bus
+ @Param[in]     reg         -   Register Number.
+ @Param[out]    p_Data      -   Data from PHY.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_MII_ReadPhyReg(t_Handle h_FmMac,  uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
+
+#if (DEBUG_ERRORS > 0)
+/**************************************************************************//**
+ @Function      FM_MAC_DumpRegs
+
+ @Description   Dump internal registers
+
+ @Param[in]     h_FmMac     -   A handle to a FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_DumpRegs(t_Handle h_FmMac);
+#endif /* (DEBUG_ERRORS > 0) */
+
+/** @} */ /* end of FM_mac_runtime_control_grp group */
+/** @} */ /* end of FM_mac_grp group */
+/** @} */ /* end of FM_grp group */
+
+
+#endif /* __FM_MAC_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
new file mode 100644
index 0000000..47cc754
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
@@ -0,0 +1,142 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          FM_muram_ext.h
+
+ @Description   FM MURAM Application Programming Interface.
+*//***************************************************************************/
+#ifndef __FM_MURAM_EXT
+#define __FM_MURAM_EXT
+
+#include "error_ext.h"
+#include "std_ext.h"
+
+
+/**************************************************************************//**
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_muram_grp FM MURAM
+
+ @Description   FM MURAM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_muram_init_grp FM MURAM Initialization
+
+ @Description   FM MURAM initialization API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_MURAM_ConfigAndInit
+
+ @Description   Creates partition in the MURAM.
+
+                The routine returns a handle (descriptor) to the MURAM partition.
+                This descriptor must be passed as first parameter to all other
+                FM-MURAM function calls.
+
+                No actual initialization or configuration of FM_MURAM hardware is
+                done by this routine.
+
+ @Param[in]     baseAddress - Pointer to base of memory mapped FM-MURAM.
+ @Param[in]     size        - Size of the FM-MURAM partition.
+
+ @Return        Handle to FM-MURAM object, or NULL for Failure.
+*//***************************************************************************/
+t_Handle FM_MURAM_ConfigAndInit(uint64_t baseAddress, uint32_t size);
+
+/**************************************************************************//**
+ @Function      FM_MURAM_Free
+
+ @Description   Frees all resources that were assigned to FM-MURAM module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmMuram - FM-MURAM module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error  FM_MURAM_Free(t_Handle h_FmMuram);
+
+/** @} */ /* end of FM_muram_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_muram_ctrl_grp FM MURAM Control
+
+ @Description   FM MURAM control API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_MURAM_AllocMem
+
+ @Description   Allocate some memory from FM-MURAM partition.
+
+ @Param[in]     h_FmMuram - FM-MURAM module descriptor.
+ @Param[in]     size      - size of the memory to be allocated.
+ @Param[in]     align     - Alignment of the memory.
+
+ @Return        address of the allocated memory; NULL otherwise.
+*//***************************************************************************/
+void  * FM_MURAM_AllocMem(t_Handle h_FmMuram, uint32_t size, uint32_t align);
+
+/**************************************************************************//**
+ @Function      FM_MURAM_FreeMem
+
+ @Description   Free an allocated memory from FM-MURAM partition.
+
+ @Param[in]     h_FmMuram - FM-MURAM module descriptor.
+ @Param[in]     ptr       - A pointer to an allocated memory.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_MURAM_FreeMem(t_Handle h_FmMuram, void *ptr);
+
+/** @} */ /* end of FM_muram_ctrl_grp group */
+/** @} */ /* end of FM_muram_grp group */
+/** @} */ /* end of FM_grp group */
+
+
+#endif /* __FM_MURAM_EXT */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
new file mode 100644
index 0000000..dcd4607
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
@@ -0,0 +1,1889 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_pcd_ext.h
+
+ @Description   FM PCD ...
+*//***************************************************************************/
+#ifndef __FM_PCD_EXT
+#define __FM_PCD_EXT
+
+#include "std_ext.h"
+#include "net_ext.h"
+#include "fm_ext.h"
+#include "list_ext.h"
+
+
+/**************************************************************************//**
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_PCD_grp FM PCD
+
+ @Description   FM PCD API functions, definitions and enums
+
+                The FM PCD module is responsible for the initialization of all
+                global classifying FM modules. This includes the parser general and
+                common registers, the key generator global and common registers,
+                and the Policer global and common registers.
+                In addition, the FM PCD SW module will initialize all required
+                key generator schemes, coarse classification flows, and Policer
+                profiles. When An FM module is configured to work with one of these
+                entities, it will register to it using the FM PORT API. The PCD
+                module will manage the PCD resources - i.e. resource management of
+                Keygen schemes, etc.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    General PCD defines
+*//***************************************************************************/
+typedef uint32_t fmPcdEngines_t; /**< options as defined below: */
+
+#define FM_PCD_NONE                                 0                   /**< No PCD Engine indicated */
+#define FM_PCD_PRS                                  0x80000000          /**< Parser indicated */
+#define FM_PCD_KG                                   0x40000000          /**< Keygen indicated */
+#define FM_PCD_CC                                   0x20000000          /**< Coarse classification indicated */
+#define FM_PCD_PLCR                                 0x10000000          /**< Policer indicated */
+
+#define FM_PCD_MAX_NUM_OF_PRIVATE_HDRS              3                   /**< Number of units/headers saved for user */
+
+#define FM_PCD_PRS_NUM_OF_HDRS                      16                  /**< Number of headers supported by HW parser */
+#define FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS         (32 - FM_PCD_MAX_NUM_OF_PRIVATE_HDRS)
+                                                                        /**< Maximum number of netenv distinction units */
+#define MAX_NUM_OF_OPTIONS                          8                   /**< Maximum number of netenv distinction units options */
+#define FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS       4                   /**< Maximum number of interchangable headers in a distinction unit */
+#define FM_PCD_KG_NUM_OF_GENERIC_REGS               8                   /**< Total number of generic KG registers */
+#define FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY       35                  /**< Max number allowed on any configuration.
+                                                                             For reason of HW implemetation, in most
+                                                                             cases less than this will be allowed. The
+                                                                             driver will return error in initialization
+                                                                             time if resource is overused. */
+#define FM_PCD_KG_NUM_OF_EXTRACT_MASKS              4                   /**< Total number of masks allowed on KG extractions. */
+#define FM_PCD_KG_NUM_OF_DEFAULT_GROUPS             16                  /**< Number of default value logical groups */
+
+#define FM_PCD_PRS_NUM_OF_LABELS                    32                  /**< Max number of SW parser label */
+#define FM_SW_PRS_SIZE                              0x00000800          /**< Total size of sw parser area */
+#define PRS_SW_OFFSET                               0x00000040          /**< Size of illegal addresses at the beginning
+                                                                             of the SW parser area */
+#define PRS_SW_TAIL_SIZE                            4                   /**< Number of bytes that must be cleared at
+                                                                             the end of the SW parser area */
+#define FM_SW_PRS_MAX_IMAGE_SIZE                    (FM_SW_PRS_SIZE-PRS_SW_OFFSET-PRS_SW_TAIL_SIZE)
+                                                                        /**< Max possible size of SW parser code */
+/* @} */
+
+/**************************************************************************//**
+ @Group         FM_PCD_init_grp FM PCD Initialization Unit
+
+ @Description   FM PCD Initialization Unit
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   PCD counters
+*//***************************************************************************/
+typedef enum e_FmPcdCounters {
+    e_FM_PCD_KG_COUNTERS_TOTAL,                                 /**< Policer counter */
+    e_FM_PCD_PLCR_COUNTERS_YELLOW,                              /**< Policer counter */
+    e_FM_PCD_PLCR_COUNTERS_RED,                                 /**< Policer counter */
+    e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED,                    /**< Policer counter */
+    e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW,                 /**< Policer counter */
+    e_FM_PCD_PLCR_COUNTERS_TOTAL,                               /**< Policer counter */
+    e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH,                     /**< Policer counter */
+    e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH,                       /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED,             /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED,             /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED,             /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED,           /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR,  /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES,                      /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES,                /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES,     /**< Parser counter */
+    e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES,                    /**< MURAM counter */
+    e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES,              /**< MURAM counter */
+    e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES,                   /**< MURAM counter */
+    e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES,             /**< MURAM counter */
+    e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES              /**< FPM counter */
+} e_FmPcdCounters;
+
+/**************************************************************************//**
+ @Description   PCD interrupts
+*//***************************************************************************/
+typedef enum e_FmPcdExceptions {
+
+    /*TODO - to understand how it has to be done*/
+    /*maybe module of PCD + specific interrupts*/
+    e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC,                   /**< Keygen ECC error */
+    e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC,                 /**< Read Buffer ECC error */
+    e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW,             /**< Write Buffer ECC error on system side */
+    e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR,           /**< Write Buffer ECC error on FM side */
+    e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE,        /**< Self init complete */
+    e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE,         /**< Atomic action complete */
+    e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,                      /**< Parser ECC error */
+    e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC,                      /**< Parser single ECC */
+    e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS,                  /**< Parser illegal access */
+    e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS              /**< Parser port illegal access */
+} e_FmPcdExceptions;
+
+
+/**************************************************************************//**
+ @Description   t_FmPcdExceptions - Exceptions user callback routine, will be called upon an
+                exception passing the exception identification.
+
+ @Param[in]     h_App      - User's application descriptor.
+ @Param[in]     exception  - The exception.
+  *//***************************************************************************/
+typedef void (t_FmPcdException) ( t_Handle h_App, e_FmPcdExceptions exception);
+
+/**************************************************************************//**
+ @Description   t_FmPcdSchemeErrorExceptionsCallback - Exceptions user callback routine,
+                will be called upon an exception passing the exception identification.
+
+ @Param[in]     h_App           - User's application descriptor.
+ @Param[in]     exception       - The exception.
+ @Param[in]     index           - id of the relevant source (may be scheme or profile id).
+ *//***************************************************************************/
+typedef void (t_FmPcdIdException) ( t_Handle           h_App,
+                                    e_FmPcdExceptions  exception,
+                                    uint16_t           index);
+
+/**************************************************************************//**
+ @Description   t_FmPcdQmEnqueueCB - TBD.
+
+ @Param[in]     h_App           - User's application descriptor.
+ @Param[in]     fqid            - TBD.
+ @Param[in]     p_Fd            - TBD.
+
+ @Return        E_OK on success; Error code otherwise.
+ *//***************************************************************************/
+typedef t_Error (t_FmPcdQmEnqueueCB) ( t_Handle h_QmArg, uint32_t fqid, void *p_Fd);
+
+/**************************************************************************//**
+ @Description   A structure for Host-Command
+                When using Host command for PCD functionalities, a dedicated port
+                must be used. If this routine is called for a PCD in a single partition
+                environment, or it is the Master partition in a Multi partition
+                environment, The port will be initialized by the PCD driver
+                initialization routine.
+ *//***************************************************************************/
+typedef struct t_FmPcdHcParams {
+#ifndef CONFIG_GUEST_PARTITION
+    uint64_t                portBaseAddr;       /**< Host-Command Port Virtual Address of
+                                                     memory mapped registers.*/
+    uint8_t                 portId;             /**< Host-Command Port Id (0-6 relative
+                                                     to Host-Command/Offline parsing ports) */
+    uint32_t                errFqid;            /**< Host-Command Port Error Queue Id. */
+    uint32_t                confFqid;           /**< Host-Command Port Confirmation queue Id. */
+    uint8_t                 deqSubPortal;       /**< Host-Command Port Subportal for dequeue. */
+#endif /* !CONFIG_GUEST_PARTITION */
+    uint32_t                enqFqid;            /**< Host-Command enqueue Queue Id. */
+    t_FmPcdQmEnqueueCB      *f_QmEnqueueCB;     /**< TBD */
+    t_Handle                h_QmArg;            /**< TBD */
+} t_FmPcdHcParams;
+
+/**************************************************************************//**
+ @Description   The main structure for PCD initialization
+ *//***************************************************************************/
+typedef struct t_FmPcdParams {
+    bool                        prsSupport;             /**< TRUE if Parser will be used for any
+                                                             of the FM ports */
+    bool                        ccSupport;              /**< TRUE if Coarse Classification will be used for any
+                                                             of the FM ports */
+    bool                        kgSupport;              /**< TRUE if Keygen will be used for any
+                                                             of the FM ports */
+    bool                        plcrSupport;            /**< TRUE if Policer will be used for any
+                                                             of the FM ports */
+    t_Handle                    h_Fm;                   /**< A handle to the FM module */
+    t_Handle                    h_FmMuram;              /**< Relevant only if ccEnable is enabled. */
+
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    uint8_t                     numOfSchemes;           /**< Number of schemes dedicated to this partition. */
+    uint16_t                    numOfClsPlanEntries;    /**< Number of clsPlan entries dedicated to this partition,
+                                                             Must be a power of 2. */
+    uint8_t                     partitionId;            /**< Guest Partition Id */
+#else
+    bool                        useHostCommand;
+#endif  /* CONFIG_MULTI_PARTITION_SUPPORT */
+    t_FmPcdHcParams             hc;                     /**< Host Command parameters */
+
+#ifndef CONFIG_GUEST_PARTITION
+    t_FmPcdException            *f_FmPcdException;      /**< Callback routine to be called of PCD exception */
+    t_FmPcdIdException          *f_FmPcdIdException;    /**< Callback routine to be used for a single scheme and
+                                                             profile exceptions */
+    t_Handle                    h_App;                  /**< A handle to an application layer object; This handle will
+                                                             be passed by the driver upon calling the above callbacks */
+#endif /* !CONFIG_GUEST_PARTITION */
+} t_FmPcdParams;
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_Config
+
+ @Description   Basic configuration of the PCD module.
+                Creates descriptor for the FM PCD module.
+
+ @Param[in]     p_FmPcdParams    A structure of parameters for the initialization of PCD.
+
+ @Return        A handle to the initialized module.
+*//***************************************************************************/
+t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_Init
+
+ @Description   Initialization of the PCD module.
+
+ @Param[in]     h_FmPcd - FM PCD module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_Init(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_Free
+
+ @Description   Frees all resources that were assigned to FM module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmPcd - FM PCD module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_Free(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Group         FM_PCD_advanced_init_grp    FM PCD Advanced Configuration Unit
+
+ @Description   Configuration functions used to change default values.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_PCD_ConfigPlcrNumOfSharedProfiles
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of exceptions enablement.
+                [DEFAULT_numOfSharedPlcrProfiles].
+
+ @Param[in]     h_FmPcd                     FM PCD module descriptor.
+ @Param[in]     numOfSharedPlcrProfiles     Number of profiles to
+                                            be shared between ports on this partition
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_ConfigPlcrNumOfSharedProfiles(t_Handle h_FmPcd, uint16_t numOfSharedPlcrProfiles);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ConfigException
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of exceptions enablement.
+                By default all exceptions are enabled.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_ConfigException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ConfigPlcrAutoRefreshMode
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of exceptions enablement.
+                By default autorefresh is enabled.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     enable          TRUE to enable, FALSE to disable
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ConfigPrsMaxCycleLimit
+
+ @Description   Calling this routine changes the internal data structure for
+                the maximum parsing time from its default value
+                [DEFAULT_prsMaxParseCycleLimit].
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     value           0 to disable the mechanism, or new
+                                maximum parsing time.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd,uint16_t value);
+
+/** @} */ /* end of FM_PCD_advanced_init_grp group */
+/** @} */ /* end of FM_PCD_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_PCD_Runtime_grp FM PCD Runtime Unit
+
+ @Description   FM PCD Runtime Unit
+
+                The runtime control allows creation of PCD infrastructure modules
+                such as Network Environment Characteristics, Classification Plan
+                Groups and Coarse Classification Trees.
+                It also allows on-the-fly initialization, modification and removal
+                of PCD modules such as Keygen schemes, coarse classification nodes
+                and Policer profiles.
+
+
+                In order to explain the programming model of the PCD driver interface
+                a few terms should be explained, and will be used below.
+                  * Distinction Header - One of the 16 protocols supported by the FM parser,
+                    or one of the shim headers (1-3). May be a header with a special
+                    option (see below).
+                  * Interchangeable Headers Group- This is a group of Headers recognized
+                    by either one of them. For example, if in a specific context the user
+                    chooses to treat IPv4 and IPV6 in the same way, they may create an
+                    Interchangable Headers Unit consisting of these 2 headers.
+                  * A Distinction Unit - a Distinction Header or an Interchangeable Headers
+                    Group.
+                  * Header with special option - applies to ethernet, mpls, vlan, ipv4 and
+                    ipv6, includes multicast, broadcast and other protocol specific options.
+                    In terms of hardware it relates to the options available in the classification
+                    plan.
+                  * Network Environment Characteristics - a set of Distinction Units that define
+                    the total recognizable header selection for a certain environment. This is
+                    NOT the list of all headers that will ever appear in a flow, but rather
+                    everything that needs distinction in a flow, where distinction is made by keygen
+                    schemes and coarse classification action descriptors.
+
+                The PCD runtime modules initialization is done in stages. The first stage after
+                initializing the PCD module itself is to establish a Network Flows Environment
+                Definition. The application may choose to establish one or more such environments.
+                Later, when needed, the application will have to state, for some of its modules,
+                to which single environment it belongs.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   A structure for sw parser labels
+ *//***************************************************************************/
+typedef struct t_FmPcdPrsLabelParams {
+    uint32_t                instructionOffset;              /**< SW parser label instruction offset (2 bytes
+                                                                 resolution), relative to Parser RAM. */
+    e_NetHeaderType         hdr;                            /**< The existance of this header will envoke
+                                                                 the sw parser code. */
+    uint8_t                 indexPerHdr;                    /**< Normally 0, if more than one sw parser
+                                                                 attachments for the same header, use this
+                                                                 index to distinguish between them. */
+} t_FmPcdPrsLabelParams;
+
+/**************************************************************************//**
+ @Description   A structure for sw parser
+ *//***************************************************************************/
+typedef struct t_FmPcdPrsSwParams {
+    bool                    override;                   /**< FALSE to invoke a check that nothing else
+                                                             was loaded to this address, including
+                                                             internal patched.
+                                                             TRUE to override any existing code.*/
+    uint32_t                size;                       /**< SW parser code size */
+    uint16_t                base;                       /**< SW parser base (in instruction counts!
+                                                             muat be larger than 0x20)*/
+    uint8_t                 *p_Code;                    /**< SW parser code */
+    uint32_t                swPrsDataParams[FM_PCD_PRS_NUM_OF_HDRS];
+                                                        /**< SW parser data (parameters) */
+    uint8_t                 numOfLabels;                /**< Number of labels for SW parser. */
+    t_FmPcdPrsLabelParams   labelsTable[FM_PCD_PRS_NUM_OF_LABELS];
+                                                        /**< SW parser labels table, containing n
+                                                             umOfLabels entries */
+} t_FmPcdPrsSwParams;
+
+/**************************************************************************//**
+ @Function      FM_PCD_Enable
+
+ @Description   This routine should be called after PCD is initialized for enabling all
+                PCD engines according to their existing configuration.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+*//***************************************************************************/
+t_Error FM_PCD_Enable(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_Disable
+
+ @Description   This routine may be called when PCD is enabled in order to
+                disable all PCD engines. It may be called
+                only when none of the ports in the system are using the PCD.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is enabled.
+*//***************************************************************************/
+t_Error FM_PCD_Disable(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSetEmptyClsPlanGrp
+
+ @Description   This routine may always be called, and MUST be called when
+                not all ports in the partition are actively using the classification
+                plan mechanism.
+                When called, the driver automatically saves 8 classification
+                plans for ports that do NOT use the classification plan mechanism, to
+                avoid this (in order to save those entries) this routine may
+                be ommited when all ports are using the classification
+                plan machanism.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+ *//***************************************************************************/
+t_Error FM_PCD_KgSetEmptyClsPlanGrp(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgDeleteEmptyClsPlanGrp
+
+ @Description   This routine may be called only when all ports in the
+                system are actively using the classification plan scheme.
+                In such cases, if empty clsPlan was already set,
+                it is recommended in order to save resources.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+                Note that this routine may not be called if any of the FM ports
+                is not using the classification plan mechanism.
+*//***************************************************************************/
+t_Error FM_PCD_KgDeleteEmptyClsPlanGrp(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_GetCounter
+
+ @Description   Reads one of the FM PCD counters.
+
+ @Param[in]     h_FmPcd     FM PCD module descriptor.
+ @Param[in]     counter     The requested counter.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+                Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter);
+
+#ifndef CONFIG_GUEST_PARTITION
+/**************************************************************************//**
+@Function      FM_PCD_PrsLoadSw
+
+@Description   This routine may be called in order to load software parsing code.
+
+
+@Param[in]     h_FmPcd         FM PCD module descriptor.
+@Param[in]     p_SwPrs         A pointer to a structure of software
+                               parser parameters, including the software
+                               parser image.
+
+@Return        E_OK on success; Error code otherwise.
+
+@Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+*//***************************************************************************/
+t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSetDfltValue
+
+ @Description   Calling this routine sets a global default value to be used
+                by the keygen when parser does not recognize a required
+                field/header.
+                By default default values are 0.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     valueId         0,1 - one of 2 global default values.
+ @Param[in]     value           The requested default value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+*//***************************************************************************/
+t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ConfigKgAdditionalDataAfterParsing
+
+ @Description   Calling this routine allows the keygen to access data past
+                the parser finidhing point.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     payloadOffset   the number of bytes beyond the parser location.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init() and when PCD is disabled.
+
+*//***************************************************************************/
+t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payloadOffset);
+
+/**************************************************************************//**
+ @Function      FM_PCD_SetException
+
+ @Description   Calling this routine enables/disables PCD interrupts.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PCD_SetCounter
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     h_FmPcd     FM PCD module descriptor.
+ @Param[in]     counter     The requested counter.
+ @Param[in]     value       The requested value to be written into the counter.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_SetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_PCD_SetPlcrStatistics
+
+ @Description   This routine may be used to enable/disable policer statistics
+                counter. By default the statistics is enabled.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor
+ @Param[in]     enable          TRUE to enable, FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PrsStatistics
+
+ @Description   Defines whether to gather parser statistics including all ports.
+
+ @Param[in]     h_FmPcd     FM PCD module descriptor.
+ @Param[in]     enable      TRUE to enable, FALSE to disable.
+
+ @Return        None
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+void FM_PCD_PrsStatistics(t_Handle h_FmPcd, bool enable);
+#endif /* !CONFIG_GUEST_PARTITION */
+
+/**************************************************************************//**
+ @Function      FM_PCD_ForceIntr
+
+ @Description   Causes an interrupt event on the requested source.
+
+ @Param[in]     h_FmPcd     FM PCD module descriptor.
+ @Param[in]     exception       An exception to be forced.
+
+ @Return        E_OK on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception);
+
+/**************************************************************************//**
+ @Function      FM_PCD_HcTxConf
+
+ @Description   TBD
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     p_Fd            TBD
+
+ @Cautions      Allowed only following FM_PCD_Init(). Allowed only if 'useHostCommand'
+                option was selected in the initialization.
+*//***************************************************************************/
+void FM_PCD_HcTxConf(t_Handle h_FmPcd, t_FmFD *p_Fd);
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//**
+ @Function      FM_PCD_DumpRegs
+
+ @Description   Dumps all PCD registers
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_DumpRegs(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgDumpRegs
+
+ @Description   Dumps all PCD KG registers
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrDumpRegs
+
+ @Description   Dumps all PCD Plcr registers
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PrsDumpRegs
+
+ @Description   Dumps all PCD Prs registers
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_PrsDumpRegs(t_Handle h_FmPcd);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+#ifdef VERIFICATION_SUPPORT
+/********************* VERIFICATION ONLY ********************************/
+/**************************************************************************//**
+ @Function      FM_PCD_BackdoorSet
+
+ @Description   Reads the DMA current status
+
+ @Param[in]     h_FmPcd             A handle to an FM Module.
+ @Param[out]    moduleId            Selected block.
+ @Param[out]    offset              Register offset withing the block.
+ @Param[out]    value               Value to write.
+
+
+ @Return        None
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+void FM_PCD_BackdoorSet (t_Handle h_FmPcd, e_ModuleId moduleId, uint32_t offset, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_PCD_BackdoorGet
+
+ @Description   Reads the DMA current status
+
+ @Param[in]     h_FmPcd             A handle to an FM Module.
+ @Param[out]    moduleId            Selected block.
+ @Param[out]    offset              Register offset withing the block.
+
+ @Return        Value read
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+uint32_t     FM_PCD_BackdoorGet(t_Handle h_FmPcd, e_ModuleId moduleId, uint32_t offset);
+#endif /*VERIFICATION_SUPPORT*/
+
+
+/**************************************************************************//**
+ @Group         FM_PCD_Runtime_tree_buildgrp FM PCD Tree building Unit
+
+ @Description   FM PCD Runtime Unit
+
+                This group contains routines for setting, deleting and modifying
+                PCD resources, for defining the total PCD tree.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    Definitions of coarse classification
+                parameters as required by keygen (when coarse classification
+                is the next engine after this scheme).
+*//***************************************************************************/
+#define         MAX_NUM_OF_PCD_CC_NODES     255
+#define         MAX_NUM_OF_PCD_CC_TREES     8
+#define         MAX_NUM_OF_PCD_CC_GROUPS    16
+#define         MAX_NUM_OF_CC_UNITS         4
+#define         MAX_NUM_OF_KEYS             256
+#define         MAX_SIZE_OF_KEY             56
+/* @} */
+
+/**************************************************************************//**
+ @Collection    A set of definitions to allow protocol
+                special option description.
+*//***************************************************************************/
+typedef uint32_t        protocolOpt_t;          /**< A general type to define a protocol option. */
+
+typedef protocolOpt_t   ethProtocolOpt_t;       /**< Ethernet protocol options. */
+#define ETH_BROADCAST               0x80000000  /**< Ethernet Broadcast. */
+#define ETH_MULTICAST               0x40000000  /**< Ethernet Multicast. */
+
+typedef protocolOpt_t   vlanProtocolOpt_t;      /**< Vlan protocol options. */
+#define VLAN_STACKED                0x20000000  /**< Vlan Stacked. */
+
+typedef protocolOpt_t   mplsProtocolOpt_t;      /**< MPLS protocol options. */
+#define MPLS_STACKED                0x10000000  /**< MPLS Stacked. */
+
+typedef protocolOpt_t   ipv4ProtocolOpt_t;      /**< IPv4 protocol options. */
+#define IPV4_BROADCAST_1            0x08000000  /**< IPv4 Broadcast. */
+#define IPV4_MULTICAST_1            0x04000000  /**< IPv4 Multicast. */
+#define IPV4_UNICAST_2              0x02000000  /**< Tunneled IPv4 - Unicast. */
+#define IPV4_MULTICAST_BROADCAST_2  0x01000000  /**< Tunneled IPv4 - Broadcast/Multicast. */
+
+typedef protocolOpt_t   ipv6ProtocolOpt_t;      /**< IPv6 protocol options. */
+#define IPV6_MULTICAST_1            0x00800000  /**< IPv6 Multicast. */
+#define IPV6_UNICAST_2              0x00400000  /**< Tunneled IPv6 - Unicast. */
+#define IPV6_MULTICAST_2            0x00200000  /**< Tunneled IPv6 - Multicast. */
+/* @} */
+
+/**************************************************************************//**
+ @Description   A type used for returning the order of the key extraction.
+                each value in this array represents the index of the extraction
+                command as defined by the user in the initialization extraction array.
+                The valid size of this array is the user define number of extractions
+                required (also marked by the second '0' in this array).
+*//***************************************************************************/
+typedef    uint8_t    t_FmPcdKgKeyOrder [FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+
+/**************************************************************************//**
+ @Description   All PCD engines
+*//***************************************************************************/
+typedef enum e_FmPcdEngine {
+    e_FM_PCD_DONE,      /**< No PCD Engine indicated */
+    e_FM_PCD_KG,        /**< Keygen indicated */
+    e_FM_PCD_CC,        /**< Coarse classification indicated */
+    e_FM_PCD_PLCR,      /**< Policer indicated */
+    e_FM_PCD_PRS        /**< Parser indicated */
+} e_FmPcdEngine;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction by header types
+*//***************************************************************************/
+typedef enum e_FmPcdExtractByHdrType {
+    e_FM_PCD_EXTRACT_FROM_HDR,      /**< Extract bytes from header */
+    e_FM_PCD_EXTRACT_FROM_FIELD,    /**< Extract bytes from header field */
+    e_FM_PCD_EXTRACT_FULL_FIELD     /**< Extract a full field */
+} e_FmPcdExtractByHdrType;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction source
+                (when it is not the header)
+*//***************************************************************************/
+typedef enum e_FmPcdExtractFrom {
+    e_FM_PCD_EXTRACT_FROM_FRAME_START,          /**< Extract from beginning of frame */
+    e_FM_PCD_KG_EXTRACT_FROM_DFLT_VALUE,        /**< Extract from a default value */
+    e_FM_PCD_KG_EXTRACT_FROM_PARSE_RESULT,      /**< Extract from the parser result */
+    e_FM_PCD_KG_EXTRACT_FROM_CURR_END_OF_PARSE  /**< Extract from the point where parsing had finished */
+} e_FmPcdExtractFrom;
+
+/**************************************************************************//**
+ @Description   An enum for selecting extraction type
+*//***************************************************************************/
+typedef enum e_FmPcdExtractType {
+    e_FM_PCD_EXTRACT_BY_HDR,                /**< Extract according to header */
+    e_FM_PCD_EXTRACT_NON_HDR,               /**< Extract from data that is not the header */
+    e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO   /**< Extract private info as specified by user */
+} e_FmPcdExtractType;
+
+/**************************************************************************//**
+ @Description   An enum for selecting a default
+*//***************************************************************************/
+typedef enum e_FmPcdKgExtractDfltSelect {
+    e_FM_PCD_KG_DFLT_GBL_0,          /**< Default selection is KG register 0 */
+    e_FM_PCD_KG_DFLT_GBL_1,          /**< Default selection is KG register 1 */
+    e_FM_PCD_KG_DFLT_PRIVATE_0,      /**< Default selection is a per scheme register 0 */
+    e_FM_PCD_KG_DFLT_PRIVATE_1,      /**< Default selection is a per scheme register 1 */
+    e_FM_PCD_KG_DFLT_ILLEGAL         /**< Illegal selection */
+} e_FmPcdKgExtractDfltSelect;
+
+/**************************************************************************//**
+ @Description   An enum defining all default groups -
+                each group shares a default value, one of 4 user
+                initialized values.
+*//***************************************************************************/
+typedef enum e_FmPcdKgKnownFieldsDfltTypes {
+    e_FM_PCD_KG_MAC_ADDR,               /**< MAC Address */
+    e_FM_PCD_KG_TCI,                    /**< TCI field */
+    e_FM_PCD_KG_ENET_TYPE,              /**< ENET Type */
+    e_FM_PCD_KG_PPP_SESSION_ID,         /**< PPP Session id */
+    e_FM_PCD_KG_PPP_PROTOCOL_ID,        /**< PPP Protocol id */
+    e_FM_PCD_KG_MPLS_LABEL,             /**< MPLS label */
+    e_FM_PCD_KG_IP_ADDR,                /**< IP addr */
+    e_FM_PCD_KG_PROTOCOL_TYPE,          /**< Protocol type */
+    e_FM_PCD_KG_IP_TOS_TC,              /**< TOS or TC */
+    e_FM_PCD_KG_IPV6_FLOW_LABEL,        /**< IPV6 flow label */
+    e_FM_PCD_KG_IPSEC_SPI,              /**< IPSEC SPI */
+    e_FM_PCD_KG_L4_PORT,                /**< L4 Port */
+    e_FM_PCD_KG_TCP_FLAG,               /**< TCP Flag */
+    e_FM_PCD_KG_GENERIC_FROM_DATA,      /**< grouping implemented by sw,
+                                             any data extraction that is not the full
+                                             field described above  */
+    e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V, /**< grouping implemented by sw,
+                                             any data extraction without validation */
+    e_FM_PCD_KG_GENERIC_NOT_FROM_DATA   /**< grouping implemented by sw,
+                                             extraction from parser result or
+                                             direct use of default value  */
+} e_FmPcdKgKnownFieldsDfltTypes;
+
+/**************************************************************************//**
+ @Description   enum for defining header index when headers may repeat
+*//***************************************************************************/
+typedef enum e_FmPcdHdrIndex {
+    e_FM_PCD_HDR_INDEX_NONE     =   0,      /**< used when multiple headers not used, also
+                                                 to specify regular IP (not tunneled). */
+    e_FM_PCD_HDR_INDEX_1,                   /**< may be used for VLAN, MPLS, tunneled IP */
+    e_FM_PCD_HDR_INDEX_2,                   /**< may be used for MPLS, tunneled IP */
+    e_FM_PCD_HDR_INDEX_3,                   /**< may be used for MPLS */
+    e_FM_PCD_HDR_INDEX_LAST     =   0xFF    /**< may be used for VLAN, MPLS */
+} e_FmPcdHdrIndex;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile functional type
+*//***************************************************************************/
+typedef enum e_FmPcdProfileTypeSelection {
+    e_FM_PCD_PLCR_PORT_PRIVATE,             /**< Port dedicated profile */
+    e_FM_PCD_PLCR_SHARED                    /**< Shared profile (shared within partition) */
+} e_FmPcdProfileTypeSelection;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile algorithem
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrAlgorithmSelection {
+    e_FM_PCD_PLCR_PASS_THROUGH,         /**< Policer pass through */
+    e_FM_PCD_PLCR_RFC_2698,             /**< Policer algorythm RFC 2698 */
+    e_FM_PCD_PLCR_RFC_4115              /**< Policer algorythm RFC 4115 */
+} e_FmPcdPlcrAlgorithmSelection;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile color mode
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrColorMode {
+    e_FM_PCD_PLCR_COLOR_BLIND,          /**< Color blind */
+    e_FM_PCD_PLCR_COLOR_AWARE           /**< Color aware */
+} e_FmPcdPlcrColorMode;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile color functional mode
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrColor {
+    e_FM_PCD_PLCR_GREEN,                /**< Green */
+    e_FM_PCD_PLCR_YELLOW,               /**< Yellow */
+    e_FM_PCD_PLCR_RED,                  /**< Red */
+    e_FM_PCD_PLCR_OVERRIDE              /**< Color override */
+} e_FmPcdPlcrColor;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile packet frame length selector
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrFrameLengthSelect {
+  e_FM_PCD_PLCR_L2_FRM_LEN,             /**< L2 frame length */
+  e_FM_PCD_PLCR_L3_FRM_LEN,             /**< L3 frame length */
+  e_FM_PCD_PLCR_L4_FRM_LEN,             /**< L4 frame length */
+  e_FM_PCD_PLCR_FULL_FRM_LEN            /**< Full frame length */
+} e_FmPcdPlcrFrameLengthSelect;
+
+/**************************************************************************//**
+ @Description   An enum for selecting rollback frame
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrRollBackFrameSelect {
+  e_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN,    /**< Rollback L2 frame length */
+  e_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN   /**< Rollback Full frame length */
+} e_FmPcdPlcrRollBackFrameSelect;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile packet or byte mode
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrRateMode {
+    e_FM_PCD_PLCR_BYTE_MODE,            /**< Byte mode */
+    e_FM_PCD_PLCR_PACKET_MODE           /**< Packet mode */
+} e_FmPcdPlcrRateMode;
+
+/**************************************************************************//**
+ @Description   An enum for defining action of frame
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrDoneAction {
+    e_FM_PCD_PLCR_ENQ_FRAME,            /**< Enqueue frame */
+    e_FM_PCD_PLCR_DROP_FRAME            /**< Drop frame */
+} e_FmPcdPlcrDoneAction;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer counter
+*//***************************************************************************/
+typedef enum e_FmPcdPlcrProfileCounters {
+    e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER,               /**< Green packets counter */
+    e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER,              /**< Yellow packets counter */
+    e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER,                 /**< Red packets counter */
+    e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER,   /**< Recolored yellow packets counter */
+    e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER       /**< Recolored red packets counter */
+} e_FmPcdPlcrProfileCounters;
+
+
+/**************************************************************************//**
+ @Description   A Union of protocol dependent special options
+*//***************************************************************************/
+typedef union u_FmPcdHdrProtocolOpt {
+    ethProtocolOpt_t    ethOpt;     /**< Ethernet options */
+    vlanProtocolOpt_t   vlanOpt;    /**< Vlan options */
+    mplsProtocolOpt_t   mplsOpt;    /**< MPLS options */
+    ipv4ProtocolOpt_t   ipv4Opt;    /**< IPv4 options */
+    ipv6ProtocolOpt_t   ipv6Opt;    /**< IPv6 options */
+} u_FmPcdHdrProtocolOpt;
+
+/**************************************************************************//**
+ @Description   A union holding all known protocol fields
+*//***************************************************************************/
+typedef union t_FmPcdFields {
+    headerFieldEth_t        eth;        /**< eth      */
+    headerFieldVlan_t       vlan;       /**< vlan     */
+    headerFieldLlcSnap_t    llcSnap;    /**< llcSnap  */
+    headerFieldPppoe_t      pppoe;      /**< pppoe    */
+    headerFieldMpls_t       mpls;       /**< mpls     */
+    headerFieldIpv4_t       ipv4;       /**< ipv4     */
+    headerFieldIpv6_t       ipv6;       /**< ipv6     */
+    headerFieldUdp_t        udp;        /**< udp      */
+    headerFieldTcp_t        tcp;        /**< tcp      */
+    headerFieldSctp_t       sctp;       /**< sctp     */
+    headerFieldDccp_t       dccp;       /**< dccp     */
+    headerFieldGre_t        gre;        /**< gre      */
+    headerFieldMinencap_t   minencap;   /**< minencap */
+    headerFieldIpsecAh_t    ipsecAh;    /**< ipsecAh  */
+    headerFieldIpsecEsp_t   ipsecEsp;   /**< ipsecEsp */
+} t_FmPcdFields;
+
+/**************************************************************************//**
+ @Description   structure for defining header extraction for key generation
+*//***************************************************************************/
+typedef struct t_FmPcdFromHdr {
+    uint8_t             size;           /**< Size in byte */
+    uint8_t             offset;         /**< Byte offset */
+} t_FmPcdFromHdr;
+
+/**************************************************************************//**
+ @Description   structure for defining field extraction for key generation
+*//***************************************************************************/
+typedef struct t_FmPcdFromField {
+    t_FmPcdFields       field;          /**< Field selection */
+    uint8_t             size;           /**< Size in byte */
+    uint8_t             offset;         /**< Byte offset */
+} t_FmPcdFromField;
+
+/**************************************************************************//**
+ @Description   A structure of parameters used to define a single network
+                environment unit.
+                A unit should be defined if it will later be used by one or
+                more PCD engines to distinguich between flows.
+*//***************************************************************************/
+typedef struct t_FmPcdDistinctionUnit {
+    struct {
+        e_NetHeaderType         hdr;        /**< One of the headers supported by the FM */
+        u_FmPcdHdrProtocolOpt   opt;        /**< only one option !! */
+    } hdrs[FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS];
+} t_FmPcdDistinctionUnit;
+
+/**************************************************************************//**
+ @Description   A structure of parameters used to define the different
+                units supported by a specific PCD Network Environment
+                Characteristics module. Each unit represent
+                a protocol or a group of protocols that may be used later
+                by the different PCD engined to distinguich between flows.
+*//***************************************************************************/
+typedef struct t_FmPcdNetEnvParams {
+    uint8_t                 numOfDistinctionUnits;                      /**< Number of different units to be identified */
+    t_FmPcdDistinctionUnit  units[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS]; /**< An array of numOfDistinctionUnits of the
+                                                                             different units to be identified */
+} t_FmPcdNetEnvParams;
+
+/**************************************************************************//**
+ @Description   structure for defining a single extraction action
+                when creating a key
+*//***************************************************************************/
+typedef struct t_FmPcdExtractEntry {
+    e_FmPcdExtractType                  type;           /**< Extraction type select */
+    union {
+        struct {                        /**< used when type = e_FM_PCD_KG_EXTRACT_BY_HDR */
+            e_NetHeaderType             hdr;            /**< Header selection */
+            bool                        ignoreProtocolValidation;   /**< Ignore protocol validation */
+            e_FmPcdHdrIndex             hdrIndex;       /**< Relevant only for MPLS, VLAN and tunneled
+                                                             IP. Otherwise should be cleared.*/
+            e_FmPcdExtractByHdrType     type;           /**< Header extraction type select */
+            union {
+                t_FmPcdFromHdr          fromHdr;        /**< Extract bytes from header parameters */
+                t_FmPcdFromField        fromField;      /**< Extract bytes from field parameters*/
+                t_FmPcdFields           fullField;      /**< Extract full filed parameters*/
+            } extractByHdrType;
+        } extractByHdr;
+        struct {                        /**< used when type = e_FM_PCD_KG_EXTRACT_NON_HDR */
+            e_FmPcdExtractFrom          src;            /**< Non-header extraction source */
+            uint8_t                     offset;         /**< Byte offset */
+            uint8_t                     size;           /**< Size in byte */
+        } extractNonHdr;
+    } extractParams;
+} t_FmPcdExtractEntry;
+
+/**************************************************************************//**
+ @Description   A structure for defining masks for each extracted
+                field in the key.
+*//***************************************************************************/
+typedef struct t_FmPcdKgExtractMask {
+    uint8_t                             extractArrayIndex;       /**< Index in the extraction array, as initialized by user */
+    uint8_t                             offset;                  /**< Byte offset */
+    uint8_t                             mask;                    /**< A byte mask (selected bits will be used) */
+} t_FmPcdKgExtractMask;
+
+/**************************************************************************//**
+ @Description   A structure for defining default selection per groups
+                of fields
+*//***************************************************************************/
+typedef struct t_FmPcdKgExtractDflt {
+    e_FmPcdKgKnownFieldsDfltTypes       type;                /**< Default type select*/
+    e_FmPcdKgExtractDfltSelect          dfltSelect;          /**< Default register select */
+} t_FmPcdKgExtractDflt;
+
+/**************************************************************************//**
+ @Description   A structure for defining all parameters needed for
+                generation a key and using a hash function
+*//***************************************************************************/
+typedef struct t_FmPcdKgKeyExtractAndHashParams {
+    uint32_t                    privateDflt0;                /**< Scheme default register 0 */
+    uint32_t                    privateDflt1;                /**< Scheme default register 1 */
+    uint8_t                     numOfUsedExtracts;           /**< defines the valid size of the following array */
+    t_FmPcdExtractEntry         extractArray [FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY]; /**< An array of extractions definition. */
+    uint8_t                     numOfUsedDflts;              /**< defines the valid size of the following array */
+    t_FmPcdKgExtractDflt        dflts[FM_PCD_KG_NUM_OF_DEFAULT_GROUPS];
+    uint8_t                     numOfUsedMasks;              /**< defines the valid size of the following array */
+    t_FmPcdKgExtractMask        masks[FM_PCD_KG_NUM_OF_EXTRACT_MASKS];
+    uint8_t                     hashShift;                   /**< Select the 24 bits out of the 64 hash result */
+    uint32_t                    hashDistributionNumOfFqids;  /**< must be > 1 and a power of 2. Represents the range
+                                                                  of queues for the key and hash functionality */
+    uint8_t                     hashDistributionFqidsShift;  /**< selects the FQID bits that will be effected by the hash */
+} t_FmPcdKgKeyExtractAndHashParams;
+
+/**************************************************************************//**
+ @Description   A structure of parameters for defining a single
+                Fqid mask (extracted OR).
+*//***************************************************************************/
+typedef struct t_FmPcdKgExtractedOrForFqid {
+    e_FmPcdExtractType              type;               /**< Extraction type select */
+    union {
+        struct {                                        /**< used when type = e_FM_PCD_KG_EXTRACT_BY_HDR */
+            e_NetHeaderType         hdr;
+            e_FmPcdHdrIndex         hdrIndex;           /**< Relevant only for MPLS, VLAN and tunneled
+                                                             IP. Otherwise should be cleared.*/
+            bool                    ignoreProtocolValidation;
+                                                        /**< continue extraction even if protocol is not recognized */
+        } extractByHdr;
+        e_FmPcdExtractFrom          src;                /**< used when type = e_FM_PCD_KG_EXTRACT_NON_HDR */
+    } extractParams;
+    uint8_t                         extractionOffset;   /**< Offset for extraction (in bytes).  */
+    e_FmPcdKgExtractDfltSelect      dfltValue;          /**< Select register from which extraction is taken if
+                                                             field not found */
+    uint8_t                         mask;               /**< Extraction mask (specified bits are used) */
+    uint8_t                         bitOffsetInFqid;    /**< out of 24 bits Qid  (max offset = 16) */
+} t_FmPcdKgExtractedOrForFqid;
+
+/**************************************************************************//**
+ @Description   A structure for configuring scheme counter
+*//***************************************************************************/
+typedef struct t_FmPcdKgSchemeCounter {
+    bool        update;     /**< FALSE to keep the current counter state
+                                 and continue from that point, TRUE to update/reset
+                                 the counter when the scheme is written. */
+    uint32_t    value;      /**< If update=TRUE, this value will be written into the
+                                 counter. clear this field to reset the counter. */
+} t_FmPcdKgSchemeCounter;
+
+/**************************************************************************//**
+ @Description   A structure for defining policer profile
+                parameters as required by keygen (when policer
+                is the next engine after this scheme).
+*//***************************************************************************/
+typedef struct t_FmPcdKgPlcrProfile {
+    bool                sharedProfile;              /**< TRUE if this profile is shared between ports
+                                                         (i.e. managed by master partition) May not be TRUE
+                                                         if profile is after Coarse Classification*/
+    bool                direct;                     /**< if TRUE, directRelativeProfileId only selects the profile
+                                                         id, if FALSE fqidOffsetRelativeProfileIdBase is used
+                                                         together with fqidOffsetShift and numOfProfiles
+                                                         parameters, to define a range of profiles from
+                                                         which the keygen result will determine the
+                                                         destination policer profile.  */
+    union {
+        uint16_t        directRelativeProfileId;         /**< Used if 'direct' is TRUE, to select policer profile.
+                                                         This parameter should
+                                                         indicate the policer profile offset within the port's
+                                                         policer profiles or SHARED window. */
+        struct {
+            uint8_t     fqidOffsetShift;            /**< shift of KG results without the qid base */
+            uint8_t     fqidOffsetRelativeProfileIdBase;/**< OR of KG results without the qid base
+                                                         This parameter should
+                                                         indicate the policer profile offset within the port's
+                                                         policer profiles windowor SHARED window depends on sharedProfile */
+            uint8_t     numOfProfiles;              /**< Range of profiles starting at base */
+        } indirectProfile;
+    } profileSelect;
+} t_FmPcdKgPlcrProfile;
+
+/**************************************************************************//**
+ @Description   A structure for CC parameters if CC is the next engine after KG
+*//***************************************************************************/
+typedef struct t_FmPcdKgCc {
+    t_Handle                h_CcTree;           /**< A handle to a CC Tree */
+    uint8_t                 grpId;              /**< CC group id within the CC tree */
+    bool                    plcrNext;           /**< TRUE if after CC, in case of data frame,
+                                                     policing is required. */
+    t_FmPcdKgPlcrProfile    plcrProfile;        /**< only if plcrNext=TRUE */
+} t_FmPcdKgCc;
+
+/**************************************************************************//**
+ @Description   A structure for initializing a keygen single scheme
+*//***************************************************************************/
+typedef struct t_FmPcdKgSchemeParams {
+    bool                                modify;                 /**< IN: TRUE to change an existing scheme */
+    union
+    {
+        uint8_t                         relativeSchemeId;       /**< IN: if modify=FALSE:Partition relative scheme id */
+        t_Handle                        h_Scheme;               /**< IN: if modify=TRUE: a handle of the existing scheme */
+    }id;
+    bool                                alwaysDirect;           /**< IN: This scheme is reached only directly, i.e.                                                              no need for match vector. Keygen will ignore
+                                                                     it when matching   */
+    struct {                                                    /**< IN: HL Relevant only if alwaysDirect = FALSE */
+        t_Handle                        h_NetEnv;               /**< IN: A handle to the Network environment as returned
+                                                                     by FM_PCD_SetNetEnvCharacteristics() */
+        uint8_t                         numOfDistinctionUnits;  /**< IN: Number of netenv units listed in unitIds array */
+        uint8_t                         unitIds[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];      /**< Indexes as passed to SetNetEnvCharacteristics array*/
+    } netEnvParams;
+    bool                                useHash;                /**< IN: use the KG Hash functionality  */
+    t_FmPcdKgKeyExtractAndHashParams    keyExtractAndHashParams;
+                                                                /**< IN: used only if useHash = TRUE */
+    uint32_t                            baseFqid;               /**< IN: Base FQID */
+    uint8_t                             numOfUsedFqidMasks;     /**< IN: Number of Fqid masks listed in fqidMasks array*/
+    t_FmPcdKgExtractedOrForFqid         fqidMasks[FM_PCD_KG_NUM_OF_GENERIC_REGS];
+                                                                /**< IN: FM_PCD_KG_NUM_OF_GENERIC_REGS
+                                                                     registers are shared between qidMasks
+                                                                     functionality and some of the extraction
+                                                                     actions. Normally only some will be used
+                                                                     for qidMask. Driver will return error if
+                                                                     resource is full at initialization time. */
+    e_FmPcdEngine                       nextEngine;             /**< IN: may be BMI, PLCR or CC */
+    union {                                                     /**< IN: depends on nextEngine */
+        t_FmPcdKgPlcrProfile            plcrProfile;            /**< IN: Used when next engine is PLCR */
+        t_FmPcdKgCc                     cc;                     /**< IN: Used when next engine is CC */
+    } kgNextEngineParams;
+    t_FmPcdKgSchemeCounter              schemeCounter;          /**< IN: A strcucture of parameters for updating
+                                                                     the scheme counter */
+    t_FmPcdKgKeyOrder                   orderedArray;           /**< OUT: A structure holding the order of the key extraction.
+                                                                     Relevant only is 'useHash' is TRUE. each value in this
+                                                                     array represents the index of the
+                                                                     extraction command as defined by the application in
+                                                                     the initialization extraction array.
+                                                                     The valid size of this array is the application define number of extractions
+                                                                     required (also marked by the second '0' in this array).*/
+} t_FmPcdKgSchemeParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining CC params when CC is the
+                next engine after a CC node.
+*//***************************************************************************/
+typedef struct t_FmPcdCcNextCcParams {
+    t_Handle    h_CcNode;                           /**< A handle of the next CC node */
+} t_FmPcdCcNextCcParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining PLCR params when PLCR is the
+                next engine after a CC node.
+*//***************************************************************************/
+typedef struct t_FmPcdCcNextPlcrParams {
+    bool        ctrlFlow;                           /**< TRUE if this is a control flow, FALSE
+                                                         if this is data flow. */
+    bool        sharedProfile;                      /**< Relevant only if ctrlFlow=TRUE:
+                                                         TRUE if this profile is shared between ports */
+    uint16_t    relativeProfileIdForCtrlFlow;        /**< Relevant only if ctrlFlow=TRUE:
+                                                         (for data flow porfile id
+                                                         is taken from keygen).
+                                                         This parameter should
+                                                         indicate the policer profile offset within the port's
+                                                         policer profiles or from SHARED window.*/
+    bool        fqidEnqForCtrlFlow;                 /**< Relevant only if ctrlFlow=TRUE:
+                                                         TRUE if after the policer the frame should
+                                                         be enqueued rather than return to Keygen */
+    uint32_t    fqidForCtrlFlowForEnqueueAfterPlcr; /**< Relevant only if ctrlFlow=TRUE:
+                                                         if fqidEnqForCtrlFlow= TRUE, FQID for enquing
+                                                         the frame. Unused otherwize. */
+} t_FmPcdCcNextPlcrParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining enqueue params when BMI is the
+                next engine after a CC node.
+*//***************************************************************************/
+typedef struct t_FmPcdCcNextEnqueueParams {
+    bool        ctrlFlow;           /**< TRUE if this is a control flow, FALSE
+                                         if this is data flow */
+    uint32_t    fqidForCtrlFlow;    /**< Valid if ctrlFlow=TRUE, FQID for enquing the frame
+                                         (for data flow FQID is taken from keygen). */
+} t_FmPcdCcNextEnqueueParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining KG params when KG is the
+                next engine after a CC node.
+*//***************************************************************************/
+typedef struct t_FmPcdCcNextKgParams {
+    bool        ctrlFlow;           /**< TRUE if this is a control flow, FALSE
+                                         if this is data flow */
+    t_Handle    h_DirectScheme;     /**< Direct scheme handle to go to. */
+} t_FmPcdCcNextKgParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining next engine params after a CC node.
+*//***************************************************************************/
+typedef struct t_FmPcdCcNextEngineParams {
+    e_FmPcdEngine                       nextEngine;    /**< User has to init parameters
+                                                            according to nextEngine definition */
+    union {
+            t_FmPcdCcNextCcParams       ccParams;      /**< Parameters in case next engine is CC */
+            t_FmPcdCcNextPlcrParams     plcrParams;    /**< Parameters in case next engine is PLCR */
+            t_FmPcdCcNextEnqueueParams  enqueueParams; /**< Parameters in case next engine is BMI */
+            t_FmPcdCcNextKgParams       kgParams;      /**< Parameters in case next engine is KG */
+    } params;
+} t_FmPcdCcNextEngineParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining a single CC Key parameters
+*//***************************************************************************/
+typedef struct t_FmPcdCcKeyParams {
+    uint8_t                     *p_Key;     /**< pointer to the key of the size defined in keySize*/
+    uint8_t                     *p_Mask;    /**< pointer to the Mask per key  of the size defined
+                                                 in keySize. p_Key and p_Mask (if defined) has to be
+                                                 of the same size defined in the keySize*/
+    t_FmPcdCcNextEngineParams   ccNextEngineParams; /**< parameters for the next for the defined Key in the p_Key*/
+} t_FmPcdCcKeyParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining CC Keys parameters
+*//***************************************************************************/
+typedef struct t_KeysParams {
+    uint8_t                     numOfKeys;      /**< num Of relevant Keys  */
+    uint8_t                     keySize;        /**< size of the key - in the case of the extraction of
+                                                     the type FULL_FIELD keySize has to be as standard size of the relevant
+                                                     key. In the another type of extraction keySize has to be as size of extraction. */
+
+    uint8_t                     *p_GlblMask;                /**< optional and can be initialized if:
+                                                                 keySize <=4 or  maskForKey is not initialized */
+    t_FmPcdCcKeyParams          keyParams[MAX_NUM_OF_KEYS];               /**< it's array with numOfKeys entries each entry in
+                                                                 the array of the type t_FmPcdCcKeyParams */
+    t_FmPcdCcNextEngineParams   ccNextEngineParamsForMiss;  /**< parameters for the next step of
+                                                                 unfound (or undefined)  key */
+} t_KeysParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining the CC node params
+*//***************************************************************************/
+typedef struct t_FmPcdCcNodeParams {
+    t_FmPcdExtractEntry         extractCcParams;    /**< params which defines extraction parameters */
+    t_KeysParams                keysParams;         /**< params which defines Keys parameters of the
+                                                         extraction defined in  extractParams */
+
+} t_FmPcdCcNodeParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining each CC tree group in term of
+                NetEnv units and the action to be taken in each case.
+                the unitIds list must be in order from lower to higher indexes.
+
+                t_FmPcdCcNextEngineParams is a list of 2^numOfDistinctionUnits
+                structures where each defines the next action to be taken for
+                each units combination. for example:
+                numOfDistinctionUnits = 2
+                unitIds = {1,3}
+                p_NextEnginePerEntriesInGrp[0] = t_FmPcdCcNextEngineParams for the case that
+                                                        unit 1 - not found; unit 3 - not found;
+                p_NextEnginePerEntriesInGrp[1] = t_FmPcdCcNextEngineParams for the case that
+                                                        unit 1 - not found; unit 3 - found;
+                p_NextEnginePerEntriesInGrp[2] = t_FmPcdCcNextEngineParams for the case that
+                                                        unit 1 - found; unit 3 - not found;
+                p_NextEnginePerEntriesInGrp[3] = t_FmPcdCcNextEngineParams for the case that
+                                                        unit 1 - found; unit 3 - found;
+*//***************************************************************************/
+typedef struct t_FmPcdCcGrpParams {
+        uint8_t                     numOfDistinctionUnits;          /**< up to 4 */
+        uint8_t                     unitIds[MAX_NUM_OF_CC_UNITS];   /**< Indexes of the units as defined in
+                                                                         FM_PCD_SetNetEnvCharacteristics() */
+        t_FmPcdCcNextEngineParams   *p_NextEnginePerEntriesInGrp;   /**< Max size is 16 - if only one group used */
+} t_FmPcdCcGrpParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining the CC tree groups
+*//***************************************************************************/
+typedef struct t_FmPcdCcTreeParams {
+        t_Handle                h_NetEnv;                               /**< A handle to the Network environment as returned
+                                                                             by FM_PCD_SetNetEnvCharacteristics() */
+        uint8_t                 numOfGrps;                              /**< Number of CC groups within the CC tree */
+        t_FmPcdCcGrpParams      ccGrpParams[MAX_NUM_OF_PCD_CC_GROUPS];  /**< Parameters for each group. */
+} t_FmPcdCcTreeParams;
+
+/**************************************************************************//**
+ @Description   A structure for initializing a keygen classification plan group
+*//***************************************************************************/
+typedef struct t_FmPcdKgClsPlanGrpParams {
+    t_Handle        h_NetEnv;                       /**< A handle to the Network environment as returned
+                                                         by FM_PCD_SetNetEnvCharacteristics() */
+
+    uint8_t         numOfOptions;                   /**< Number of options, to define the size of the
+                                                         following array. */
+    protocolOpt_t   options[FM_PCD_MAX_NUM_OF_CLS_PLANS];
+                                                    /**< an option may be a basic one, such as ipv6Multicast1,
+                                                         or a combination of the basic ones such as
+                                                         (ethBroadcast | ethMulticast) or
+                                                         (ethBroadcast | ipv4Unicast2 | mplsStacked).
+                                                         No more than a total of 8 basic options may
+                                                         participate in this array. */
+} t_FmPcdKgClsPlanGrpParams;
+
+/**************************************************************************//**
+ @Description   A structure for defining parameters for byte rate
+*//***************************************************************************/
+typedef struct t_FmPcdPlcrByteRateModeParams {
+    e_FmPcdPlcrFrameLengthSelect    frameLengthSelection;   /**< Frame length selection */
+    e_FmPcdPlcrRollBackFrameSelect  rollBackFrameSelection; /**< relevant option only e_FM_PCD_PLCR_L2_FRM_LEN,
+                                                                 e_FM_PCD_PLCR_FULL_FRM_LEN */
+} t_FmPcdPlcrByteRateModeParams;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile RFC 2698 or RFC 4115 parameters
+*//***************************************************************************/
+typedef struct t_FmPcdPlcrNonPassthroughAlgParams {
+    e_FmPcdPlcrRateMode              rateMode;                       /**< Byte / Packet */
+    t_FmPcdPlcrByteRateModeParams    byteModeParams;                 /**< Valid for Byte NULL for Packet */
+    uint32_t                         comittedInfoRate;               /**< KBits/Sec or Packets/Sec */
+    uint32_t                         comittedBurstSize;              /**< KBits or Packets */
+    uint32_t                         peakOrAccessiveInfoRate;        /**< KBits/Sec or Packets/Sec */
+    uint32_t                         peakOrAccessiveBurstSize;       /**< KBits or Packets */
+} t_FmPcdPlcrNonPassthroughAlgParams;
+
+/**************************************************************************//**
+ @Description   A union for defining Policer next engine parameters
+*//***************************************************************************/
+typedef union u_FmPcdPlcrNextEngineParams {
+        e_FmPcdPlcrDoneAction           action;             /**< Action - when next engine is BMI (done) */
+        t_Handle                        h_Profile;          /**< Policer profile handle -  used when next engine
+                                                                 is PLCR, must be a SHARED profile */
+        t_Handle                        h_DirectScheme;     /**< Direct scheme select - when next engine is Keygen */
+} u_FmPcdPlcrNextEngineParams;
+
+/**************************************************************************//**
+ @Description   A structure for selcting the policer profile entry parameters
+*//***************************************************************************/
+typedef struct t_FmPcdPlcrProfileParams {
+    bool                                modify;                     /**< TRUE to change an existing profile */
+    union {
+        struct {
+            e_FmPcdProfileTypeSelection profileType;                /**< Type of policer profile */
+            t_Handle                    h_FmPort;                   /**< Relevant for per-port profiles only */
+            uint16_t                    relativeProfileId;          /**< Profile id - relative to shared group or to port */
+        } newParams;                                                /**< use it when modify=FALSE */
+        t_Handle                        h_Profile;                  /***< A handle to a profile - use it when modify=TRUE */
+    } id;
+    e_FmPcdPlcrAlgorithmSelection       algSelection;               /**< Profile Algoritem PASS_THROUGH, RFC_2698, RFC_4115 */
+    e_FmPcdPlcrColorMode                colorMode;                  /**< COLOR_BLIND, COLOR_AWARE */
+
+    union {
+        e_FmPcdPlcrColor                dfltColor;                  /**< For Color-Blind Pass-Through mode. the policer will re-color
+                                                                         any incoming packet with the default value. */
+        e_FmPcdPlcrColor                override;                   /**< For Color-Aware modes. The profile response to a
+                                                                         pre-color value of 2b11. */
+    } color;
+
+    t_FmPcdPlcrNonPassthroughAlgParams  nonPassthroughAlgParams;    /**< RFC2698 or RFC4115 params */
+
+    e_FmPcdEngine                       nextEngineOnGreen;          /**< Green next engine type */
+    u_FmPcdPlcrNextEngineParams         paramsOnGreen;              /**< Green next engine params */
+
+    e_FmPcdEngine                       nextEngineOnYellow;         /**< Yellow next engine type */
+    u_FmPcdPlcrNextEngineParams         paramsOnYellow;             /**< Yellow next engine params */
+
+    e_FmPcdEngine                       nextEngineOnRed;            /**< Red next engine type */
+    u_FmPcdPlcrNextEngineParams         paramsOnRed;                /**< Red next engine params */
+
+    bool                                trapProfileOnFlowA;         /**< Trap on flow A */
+    bool                                trapProfileOnFlowB;         /**< Trap on flow B */
+    bool                                trapProfileOnFlowC;         /**< Trap on flow C */
+} t_FmPcdPlcrProfileParams;
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_SetNetEnvCharacteristics
+
+ @Description   Define a set of Network Environment Charecteristics.
+                When setting an environment it is important to understand its
+                application. It is not meant to describe the flows that will run
+                on the ports using this environment, but what the user means TO DO
+                with the PCD mechanisms in order to parse-classify-distribute those
+                frames.
+                By specifying a distinction unit, the user means it would use that option
+                for distinction between frames at either a keygen scheme keygen or a coarse
+                classification action descriptor. Using interchangeable headers to define a
+                unit means that the user is indifferent to which of the interchangeable
+                headers is present in the frame, and they want the distinction to be based
+                on the presence of either one of them.
+                Depending on context, there are limitations to the use of environments. A
+                port using the PCD functionality is bound to an environment. Some or even
+                all ports may share an environment but also an environment per port is
+                possible. When initializing a scheme, a classification plan group (see below),
+                or a coarse classification tree, one of the initialized environments must be
+                stated and related to. When a port is bound to a scheme, a classification
+                plan group, or a coarse classification tree, it MUST be bound to the same
+                environment.
+                The different PCD modules, may relate (for flows definition) ONLY on
+                distinction units as defined by their environment. When initializing a
+                scheme for example, it may not choose to select IPV4 as a match for
+                recognizing flows unless it was defined in the relating environment. In
+                fact, to guide the user through the configuration of the PCD, each module's
+                characterization in terms of flows is not done using protocol names, but using
+                environment indexes.
+                In terms of HW implementation, the list of distinction units sets the LCV vectors
+                and later used for match vector, classification plan vectors and coarse classification
+                indexing.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     p_NetEnvParams  A structure of parameters for the initialization of
+                                the network environment.
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams *p_NetEnvParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_DeleteNetEnvCharacteristics
+
+ @Description   Deletes a set of Network Environment Charecteristics.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     h_NetEnv        A handle to the Network environment.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_DeleteNetEnvCharacteristics(t_Handle h_FmPcd, t_Handle h_NetEnv);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSetClsPlanGrp
+
+ @Description   Define a classification plan group..
+                A classification plan group is a set of classification plan
+                entries consisting of a number of protocol options (as listed
+                in HW spec), that is a subset of a previously defined environment,
+                and that is relevant for one or more ports that will use that
+                same environment.
+                By specifying an option, the application means it would use that
+                option for distinction between frames at either a keygen scheme
+                keygen or a coarse classification action descriptor.
+                When RX ports that want to use the classification plan mechanism
+                are initialized, they will be bound to a classification plan
+                group. Usage of the classification plan is optional.
+                If not all ports use classification plan, it is user's responsibility
+                to declare that by calling FM_PCD_KgSetEmptyClsPlanGrp. The driver
+                will then allocate a minimal number of entries for that use, and all
+                ports that do not use the classification plan mechanism will
+                be internally bound to that empty group.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     p_GrpParams     A structure of classification plan parameters.
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_KgSetClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgClsPlanGrpParams *p_GrpParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgDeleteClsPlanGrp
+
+ @Description   Delete classification plan by writing reset value (0xFFFFFFFF)
+                to it - pass all LCV bits.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     h_ClsPlanGrp    a handle to an classification-plan-group.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_KgDeleteClsPlanGrp(t_Handle h_FmPcd, t_Handle h_ClsPlanGrp);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSetScheme
+
+ @Description   Initializing or modifying and enabling a scheme for the keygen.
+                This routine should be called for adding or modifying a scheme.
+                When a scheme needs modifying, the API requires that it will be
+                rewritten. In such a case 'modify' should be TRUE. If the
+                routine is called for a valid scheme and 'modify' is FALSE,
+                it will return error.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in,out] p_Scheme        A structure of parameters for defining the scheme
+
+ @Return        A handle to the initialized scheme on success; NULL code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_KgSetScheme (t_Handle                h_FmPcd,
+                             t_FmPcdKgSchemeParams   *p_Scheme);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgDeleteScheme
+
+ @Description   Deleting an initialized scheme.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSetScheme
+
+ @Return        E_OK on success; Error code otherwise.
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error     FM_PCD_KgDeleteScheme(t_Handle h_FmPcd, t_Handle h_Scheme);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgGetSchemeCounter
+
+ @Description   Reads scheme packet counter.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSetScheme.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+uint32_t  FM_PCD_KgGetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme);
+
+/**************************************************************************//**
+ @Function      FM_PCD_KgSetSchemeCounter
+
+ @Description   Writes scheme packet counter.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSetScheme.
+ @Param[in]     value           New scheme counter value - typically '0' for
+                                resetting the counter.
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error  FM_PCD_KgSetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcBuildTree
+
+ @Description   This routine must be called to define a complete coarse
+                classification tree. This is the way to define coarse
+                classification to a certain flow - the keygen schemes
+                may point only to trees defined in this way.
+
+ @Param[in]     h_FmPcd                 FM PCD module descriptor.
+ @Param[in]     p_FmPcdCcTreeParams     A structure of parameters to define the tree.
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_CcBuildTree (t_Handle             h_FmPcd,
+                             t_FmPcdCcTreeParams  *p_FmPcdCcTreeParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcDeleteTree
+
+ @Description   Deleting an built tree.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     h_CcTree        A handle to a CC tree.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_CcDeleteTree(t_Handle h_FmPcd, t_Handle h_CcTree);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcSetNode
+
+ @Description   This routine should be called for each CC (coarse classification)
+                node. The whole CC tree should be built bottom up so that each
+                node points to already defined nodes.
+
+ @Param[in]     h_FmPcd             FM PCD module descriptor.
+ @Param[in]     p_CcNodeParam       A structure of parameters defining the CC node
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following PCD_Init().
+*//***************************************************************************/
+t_Handle   FM_PCD_CcSetNode(t_Handle             h_FmPcd,
+                            t_FmPcdCcNodeParams  *p_CcNodeParam);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcDeleteNode
+
+ @Description   Deleting an built node.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     h_CcNode        A handle to a CC node.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_CcDeleteNode(t_Handle h_FmPcd, t_Handle h_CcNode);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcTreeModifyNextEngine
+
+ @Description   Modify the Next Engine Parameters in the entry of the tree.
+
+ @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
+ @Param[in]     h_CcTree                    A handle to the tree
+ @Param[in]     grpId                       A Group index in the tree
+ @Param[in]     index                       Entry index in the group defined by grpId
+ @Param[in]     p_FmPcdCcNextEngineParams   A structure for defining new next engine params
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcBuildTree().
+*//***************************************************************************/
+t_Error FM_PCD_CcTreeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcNodeModifyNextEngine
+
+ @Description   Modify the Next Engine Parameters in the relevent key entry of the node.
+
+ @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keyIndex                    Key index for Next Engine Params modifications
+ @Param[in]     p_FmPcdCcNextEngineParams   A structure for defining new next engine params
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode().
+*//***************************************************************************/
+t_Error FM_PCD_CcNodeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcNodeModifyMissNextEngine
+
+ @Description   Modify the Next Engine Parameters of the Miss key case of the node.
+
+ @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     p_FmPcdCcNextEngineParams   A structure for defining new next engine params
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode().
+*//***************************************************************************/
+t_Error FM_PCD_CcNodeModifyMissNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcNodeRemoveKey
+
+ @Description   Remove the key (include Next Engine Parameters of this key) defined by the index of the relevant node .
+
+ @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keyIndex                    Key index for removing
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+t_Error FM_PCD_CcNodeRemoveKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcNodeAddKey
+
+ @Description   Add the key(include Next Engine Parameters of this key)in the index defined by the keyIndex .
+
+ @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keyIndex                    Key index for adding
+ @Param[in]     keySize                     Key size of added key
+ @Param[in]     p_KeyParams                 A pointer to the parametrs includes new key with Next Engine Parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+t_Error FM_PCD_CcNodeAddKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcNodeModifyKeyAndNextEngine
+
+ @Description   Modify the key and Next Engine Parameters of this key in the index defined by the keyIndex .
+
+ @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keyIndex                    Key index for adding
+ @Param[in]     keySize                     Key size of added key
+ @Param[in]     p_KeyParams                 A pointer to the parametrs includes modified key and modified Next Engine Parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+t_Error FM_PCD_CcNodeModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcNodeModifyKey
+
+ @Description   Modify the key  in the index defined by the keyIndex .
+
+ @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keyIndex                    Key index for adding
+ @Param[in]     keySize                     Key size of added key
+ @Param[in]     p_Key                       A pointer to the new key
+ @Param[in]     p_Mask                      A pointer to the new mask if relevnt, otherwise pointer to NULL
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevnt node but also
+                the node that points to this node
+*//***************************************************************************/
+t_Error FM_PCD_CcNodeModifyKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, uint8_t  *p_Key, uint8_t *p_Mask);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrSetProfile
+
+ @Description   Sets a profile entry in the policer profile table.
+                The routine overrides any existing value.
+
+ @Param[in]     h_FmPcd           A handle to an FM PCD Module.
+ @Param[in]     p_Profile         A structure of parameters for defining a
+                                  policer profile entry.
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle FM_PCD_PlcrSetProfile(t_Handle                  h_FmPcd,
+                               t_FmPcdPlcrProfileParams  *p_Profile);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrDeleteProfile
+
+ @Description   Delete a profile entry in the policer profile table.
+                The routine set entry to invalid.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     h_Profile       A handle to the profile.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_PlcrDeleteProfile(t_Handle h_FmPcd, t_Handle h_Profile);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrGetProfileCounter
+
+ @Description   Sets an entry in the classification plan.
+                The routine overrides any existing value.
+
+ @Param[in]     h_FmPcd             A handle to an FM PCD Module.
+ @Param[in]     h_Profile       A handle to the profile.
+ @Param[in]     counter             Counter selector.
+
+ @Return        specific counter value.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+uint32_t FM_PCD_PlcrGetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrSetProfileCounter
+
+ @Description   Sets an entry in the classification plan.
+                The routine overrides any existing value.
+
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
+ @Param[in]     h_Profile       A handle to the profile.
+ @Param[in]     counter         Counter selector.
+ @Param[in]     value           value to set counter with.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_PlcrSetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter,    uint32_t value);
+
+/** @} */ /* end of FM_PCD_Runtime_tree_buildgrp group */
+/** @} */ /* end of FM_PCD_Runtime_grp group */
+/** @} */ /* end of FM_PCD_grp group */
+/** @} */ /* end of FM_grp group */
+
+#endif /* __FM_PCD_EXT */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
new file mode 100644
index 0000000..44c334e
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
@@ -0,0 +1,1889 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_port_ext.h
+
+ @Description   FM-Port Application Programming Interface.
+*//***************************************************************************/
+#ifndef __FM_PORT_EXT
+#define __FM_PORT_EXT
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "fm_pcd_ext.h"
+#include "fm_ext.h"
+#include "net_ext.h"
+
+
+/**************************************************************************//**
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_PORT_grp FM Port
+
+ @Description   FM Port API
+
+                The FM uses a general module called "port" to represent a Tx port
+                (MAC), an Rx port (MAC), offline parsing flow or host command
+                flow. There may be up to 17 (may change) ports in an FM - 5 Tx
+                ports (4 for the 1G MACs, 1 for the 10G MAC), 5 Rx Ports, and 7
+                Host command/Offline parsing ports. The SW driver manages these
+                ports as sub-modules of the FM, i.e. after an FM is initialized,
+                its ports may be initialized and operated upon.
+
+                The port is initialized aware of its type, but other functions on
+                a port may be indifferent to its type. When necessary, the driver
+                verifies coherency and returns error if applicable.
+
+                On initialization, user specifies the port type and it's index
+                (relative to the port's type). Host command and Offline parsing
+                ports share the same id range, I.e user may not initialized host
+                command port 0 and offline parsing port 0.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   An enum for defining port PCD modes.
+                This enum defines the superset of PCD engines support - i.e. not
+                all engines have to be used, but all have to be enabled. The real
+                flow of a specific frame depends on the PCD configuration and the
+                frame headers and payload.
+*//***************************************************************************/
+typedef enum e_FmPortPcdSupport {
+    e_FM_PORT_PCD_SUPPORT_NONE,                 /**< BMI to BMI, PCD is not used */
+    e_FM_PORT_PCD_SUPPORT_PRS_ONLY,             /**< Use only Parser */
+    e_FM_PORT_PCD_SUPPORT_PLCR_ONLY,            /**< Use only Policer */
+    e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR,         /**< Use Parser and Policer */
+    e_FM_PORT_PCD_SUPPORT_PRS_AND_KG,           /**< Use Parser and Keygen */
+    e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC,    /**< Use Parser, Keygen and Coarse Classification */
+    e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR, /**< Use all PCD engines */
+    e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR   /**< Use Parser, Keygen and Policer */
+} e_FmPortPcdSupport;
+
+/**************************************************************************//**
+ @Collection    General FM Port defines
+*//***************************************************************************/
+#define PRS_RESULT_NUM_OF_WORDS             8           /**< Number of 4 bytes words in parser result */
+#define FM_PORT_MAX_NUM_OF_EXT_POOLS        8           /**< Number of external BM pools per Rx port */
+#define MAX_NUM_OF_EXT_POOLS                64          /**< Total number of external BM pools */
+#define FM_PORT_NUM_OF_CONGESTION_GRPS      256         /**< Total number of congestion groups in QM */
+/* @} */
+
+
+/**************************************************************************//**
+ @Group         FM_PORT_init_grp FM Port Initialization Unit
+
+ @Description   FM Port Initialization Unit
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   User callback function called by driver with recieve data.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_App       Application's handle originally specified to
+                            the API Config function
+ @Param[in]     p_Data      A pointer to data received
+ @Param[in]     length      length of received data
+ @Param[in]     status      receive status and errors
+ @Param[in]     position    position of buffer in frame
+ @Param[in]     h_UserPriv  A handle of the user acossiated with this buffer
+ *//***************************************************************************/
+typedef void (t_FmPortImRxStoreFunction) (t_Handle h_App,
+                                          uint8_t  *p_Data,
+                                          uint16_t length,
+                                          uint16_t status,
+                                          uint8_t  position,
+                                          t_Handle h_UserPriv);
+
+/**************************************************************************//**
+ @Description   User callback function called by driver when transmit completed.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_App       Application's handle originally specified to
+                            the API Config function
+ @Param[in]     p_Data      A pointer to data received
+ @Param[in]     status      transmit status and errors
+ @Param[in]     lastBuffer  is last buffer in frame
+ @Param[in]     h_UserPriv  A handle of the user acossiated with this buffer
+ *//***************************************************************************/
+typedef void (t_FmPortImTxConfFunction) (t_Handle   h_App,
+                                         uint8_t    *p_Data,
+                                         uint16_t   status,
+                                         t_Handle   h_UserPriv);
+
+/**************************************************************************//**
+ @Description   A structure of information about each of the external
+                buffer pools used by the port,
+*//***************************************************************************/
+typedef struct t_FmPortExtPoolParams {
+    uint8_t                 id;                 /**< External buffer pool id */
+    uint16_t                size;               /**< External buffer pool buffer size */
+} t_FmPortExtPoolParams;
+
+/**************************************************************************//**
+ @Description   A structure for informing the driver about the external
+                buffer pools allocated in the BM and used by this port.
+*//***************************************************************************/
+typedef struct t_FmPortRxExtPools {
+    uint8_t                 numOfPoolsUsed;     /**< Number of pools use by this port */
+    t_FmPortExtPoolParams   rxExtBufPool[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+                                                /**< Parameters for each port */
+} t_FmPortRxExtPools;
+
+/**************************************************************************//**
+ @Description   structure for additional Rx port parameters
+*//***************************************************************************/
+typedef struct t_FmPortRxParams {
+    uint32_t                errFqid;            /**< Error Queue Id. */
+    uint32_t                dfltFqid;           /**< Default Queue Id.  */
+    uint8_t                 rxPartitionId;      /**< Port's partition id. */
+    t_FmPortRxExtPools      rxExtBufPools;      /**< Which external buffer pools are used
+                                                     (up to 8), and their sizes. */
+} t_FmPortRxParams;
+
+/**************************************************************************//**
+ @Description   structure for additional non-Rx port parameters
+*//***************************************************************************/
+typedef struct t_FmPortNonRxParams {
+    uint32_t                errFqid;            /**< Error Queue Id. */
+    uint32_t                dfltFqid;           /**< For Tx and HC - Default Confirmation queue,
+                                                     0 means no Tx confirmation for processed
+                                                     frames. For OP - default Rx queue. */
+    uint8_t                 deqSubPortal;       /**< Subportal for dequeue. */
+#ifdef FM_OP_PARTITION_ERRATA
+    uint8_t                 opPartitionId;      /**< For Offline Parsing ports only. Port's partition id. */
+#endif  /* FM_OP_PARTITION_ERRATA */
+} t_FmPortNonRxParams;
+
+/**************************************************************************//**
+ @Description   structure for additional Rx port parameters
+*//***************************************************************************/
+typedef struct t_FmPortImRxTxParams {
+    t_Handle                    h_FmMuram;          /**< A handle of the FM-MURAM partition */
+    uint8_t                     partitionId;        /**< For Rx ports only. Port's partition id. */
+    uint8_t                     dataMemId;          /**< Memory partition ID for data buffers */
+    uint32_t                    dataMemAttributes;  /**< Memory attributes for data buffers */
+    t_BufferPoolInfo            rxPoolParams;       /**< For Rx ports only. */
+    t_FmPortImRxStoreFunction   *f_RxStoreCB;       /**< For Rx ports only. */
+    t_FmPortImTxConfFunction    *f_TxConfCB;        /**< For Tx ports only. */
+    t_Handle                    h_App;              /**< A handle to an application layer object; This handle will
+                                                         be passed by the driver upon calling the above callbacks */
+} t_FmPortImRxTxParams;
+
+/**************************************************************************//**
+ @Description   Union for additional parameters depending on port type
+*//***************************************************************************/
+typedef union u_FmPortSpecificParams {
+    t_FmPortImRxTxParams    imRxTxParams;       /**< Rx/Tx Independent-Mode port parameter structure */
+    t_FmPortRxParams        rxParams;           /**< Rx port parameters structure */
+    t_FmPortNonRxParams     nonRxParams;        /**< Non-Rx port parameters structure */
+} u_FmPortSpecificParams;
+
+/**************************************************************************//**
+ @Description   structure representing FM initialization parameters
+*//***************************************************************************/
+typedef struct t_FmPortParams {
+    uint64_t                baseAddr;           /**< Virtual Address of memory mapped FM Port registers.*/
+    t_Handle                h_Fm;               /**< A handle to the FM object this port related to */
+    e_FmPortType            portType;           /**< Port type */
+    uint8_t                 portId;             /**< Port Id - relative to type */
+    bool                    independentModeEnable;  /**< This port is Independent-Mode - Used for Rx/Tx ports only! */
+    u_FmPortSpecificParams  specificParams;     /**< Additional parameters depending on port
+                                                     type. */
+} t_FmPortParams;
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_Config
+
+ @Description   Creates descriptor for the FM PORT module.
+
+                The routine returns a handle (descriptor) to the FM PORT object.
+                This descriptor must be passed as first parameter to all other
+                FM PORT function calls.
+
+                No actual initialization or configuration of FM hardware is
+                done by this routine.
+
+ @Param[in]     p_FmPortParams   - Pointer to data structure of parameters
+
+ @Retval        Handle to FM object, or NULL for Failure.
+*//***************************************************************************/
+t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams);
+
+/**************************************************************************//**
+ @Function      FM_PORT_Init
+
+ @Description   Initializes the FM PORT module
+
+ @Param[in]     h_FmPort - FM PORT module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PORT_Init(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_Free
+
+ @Description   Frees all resources that were assigned to FM PORT module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmPort - FM PORT module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PORT_Free(t_Handle h_FmPort);
+
+
+/**************************************************************************//**
+ @Group         FM_PORT_advanced_init_grp    FM Port Advanced Configuration Unit
+
+ @Description   Configuration functions used to change default values.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   enum for defining QM frame dequeue
+*//***************************************************************************/
+typedef enum e_FmPortDeqType {
+   e_FM_PORT_DEQ_TYPE1,             /**< Dequeue from the SP channel - with priority precedence,
+                                         and Intra-Class Scheduling respected. */
+   e_FM_PORT_DEQ_TYPE2,             /**< Dequeue from the SP channel - with active FQ precedence,
+                                         and Intra-Class Scheduling respected. */
+   e_FM_PORT_DEQ_TYPE3              /**< Dequeue from the SP channel - with active FQ precedence,
+                                         and override Intra-Class Scheduling */
+} e_FmPortDeqType;
+
+/**************************************************************************//**
+ @Description   enum for defining QM frame dequeue
+*//***************************************************************************/
+typedef enum e_FmPortDeqPrefetchOption {
+   e_FM_PORT_DEQ_NO_PREFETCH,       /**< QMI preforms a dequeue action for a single frame
+                                         only when a dedicated portID Tnum is waiting. */
+   e_FM_PORT_DEQ_PARTIAL_PREFETCH,  /**< QMI preforms a dequeue action for 3 frames when
+                                         one dedicated portId tnum is waiting. */
+   e_FM_PORT_DEQ_FULL_PREFETCH      /**< QMI preforms a dequeue action for 3 frames when
+                                         no dedicated portId tnums are waiting. */
+
+} e_FmPortDeqPrefetchOption;
+
+/**************************************************************************//**
+ @Description   enum for defining port DMA swap mode
+*//***************************************************************************/
+typedef enum e_FmPortDmaSwap {
+    e_FM_PORT_DMA_NO_SWP,           /**< No swap, transfer data as is.*/
+    e_FM_PORT_DMA_SWP_PPC_LE,       /**< The transferred data should be swapped
+                                         in PowerPc Little Endian mode. */
+    e_FM_PORT_DMA_SWP_BE            /**< The transferred data should be swapped
+                                         in Big Endian mode */
+} e_FmPortDmaSwap;
+
+/**************************************************************************//**
+ @Description   enum for defining port DMA cache attributes
+*//***************************************************************************/
+typedef enum e_FmPortDmaCache {
+    e_FM_PORT_DMA_NO_STASH,         /**< Cacheable, no Allocate (No Stashing) */
+    e_FM_PORT_DMA_STASH             /**< Cacheable and Allocate (Stashing on) */
+} e_FmPortDmaCache;
+
+/**************************************************************************//**
+ @Description   enum for defining port default color
+*//***************************************************************************/
+typedef enum e_FmPortColor {
+    e_FM_PORT_COLOR_GREEN,          /**< Default port color is green */
+    e_FM_PORT_COLOR_YELLOW,         /**< Default port color is yellow */
+    e_FM_PORT_COLOR_RED,            /**< Default port color is red */
+    e_FM_PORT_COLOR_OVERRIDE        /**< Ignore color */
+} e_FmPortColor;
+
+/**************************************************************************//**
+ @Description   struct for defining FM port resources
+*//***************************************************************************/
+typedef struct t_FmPortRsrc {
+    uint32_t    num;                /**< Commited required resource */
+    uint32_t    extra;              /**< Extra (not commited) required resource */
+} t_FmPortRsrc;
+
+/**************************************************************************//**
+ @Description   struct for defining pool depeltion criteria
+*//***************************************************************************/
+typedef struct t_FmPortBufPoolDepletion {
+    bool        numberOfPoolsModeEnable;            /**< select mode in which pause frames will be sent after
+                                                         a number of pools are depleted */
+    uint8_t     numOfPools;                         /**< the minimum number of depleted pools that will
+                                                         invoke pause frames transmission. */
+    bool        poolsToConsider[MAX_NUM_OF_EXT_POOLS];
+                                                    /**< For each pool, TRUE if it should be considered for
+                                                         deplition (Note - this pool must be used by this port!) */
+    bool        singlePoolModeEnable;               /**< select mode in which pause frames will be sent after
+                                                         a single of pools are depleted */
+    bool        poolsToConsiderForSingleMode[MAX_NUM_OF_EXT_POOLS];
+                                                    /**< For each pool, TRUE if it should be considered for
+                                                         deplition (Note - this pool must be used by this port!) */
+} t_FmPortBufPoolDepletion;
+
+/**************************************************************************//**
+ @Description   struct for defining Tx rate limiting
+*//***************************************************************************/
+typedef struct t_FmPortRateLimit {
+    uint16_t    maxBurstSize;           /**< in KBytes */
+    uint32_t    rateLimit;              /**< in Kb/sec for Tx ports, in frame/sec for
+                                             offline parsing ports. Rate limit will
+                                             be rounded down to the nearest
+                                             16*TimeStampPeriod multiplication. */
+} t_FmPortRateLimit;
+
+/**************************************************************************//**
+ @Description   struct for defining define the parameters of
+                the Rx port performance counters
+*//***************************************************************************/
+typedef struct t_FmPortPerformanceCnt {
+    uint8_t     taskCompVal;            /**< Task compare value */
+    uint8_t     queueCompVal;           /**< Rx queue/Tx confirm queue compare
+                                             value (unused for H/O) */
+    uint8_t     dmaCompVal;             /**< Dma compare value */
+    uint32_t    fifoCompVal;            /**< Fifo compare value */
+} t_FmPortPerformanceCnt;
+
+/**************************************************************************//**
+ @Description   struct for defining buffer content.
+*//***************************************************************************/
+typedef struct t_FmPortBufferPrefixContent {
+    uint16_t    privDataSize;               /**< Number of bytes to be left at the beginning
+                                                 of the external buffer */
+    bool        passPrsResult;              /**< TRUE to pass the parse result to/from the FM */
+    bool        passTimeStamp;              /**< TRUE to pass the timeStamp to/from the FM */
+} t_FmPortBufferPrefixContent;
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigNumOfOpenDmas
+
+ @Description   Calling this routine changes the number of open DMA requested for
+                this port in the internal driver data base from its default configuration.
+
+
+                May be used for all port types.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_NumOfOpenDmas     A structure of resource requested parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfOpenDmas);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigNumOfTasks
+
+ @Description   Calling this routine changes the number of tasks requested for
+                this port in the internal driver data base from its default configuration.
+
+                May be used for all port types.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_NumOfTasks        A structure of resource requested parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigSizeOfFifo
+
+ @Description   Calling this routine changes the Fifo size requested for
+                this port in the internal driver data base from its default configuration.
+
+                May be used for all port types - note that only Rx has 'extra'
+                fifo size. For other ports 'extra' field must be disabled.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_SizeOfFifo        A structure of resource requested parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDeqHighPriority
+
+ @Description   Calling this routine changes the dequeue priority in the
+                internal driver data base from its default configuration
+                [DEFAULT_PORT_deqHighPriority]
+
+
+
+                May be used for Non-Rx ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     highPri     TRUE to select high priority, FALSE for normal operation.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDeqHighPriority(t_Handle h_FmPort, bool highPri);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDeqType
+
+ @Description   Calling this routine changes the dequeue type parameter in the
+                internal driver data base from its default configuration
+                [DEFAULT_PORT_deqType].
+
+
+                May be used for Non-Rx ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     deqType     According to QM definition.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDeqType(t_Handle h_FmPort, e_FmPortDeqType deqType);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDeqPrefetchOption
+
+ @Description   Calling this routine changes the dequeue prefetch option parameter in the
+                internal driver data base from its default configuration
+                [DEFAULT_PORT_deqPrefetchOption]
+
+
+                May be used for Non-Rx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     deqPrefetchOption   New option
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOption deqPrefetchOption);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDeqByteCnt
+
+ @Description   Calling this routine changes the dequeue byte count parameter in
+                the internal driver data base from its default configuration [DEFAULT_PORT_deqByteCnt].
+
+                May be used for Non-Rx ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     deqByteCnt      New byte count
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDeqByteCnt(t_Handle h_FmPort, uint16_t deqByteCnt);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigTxFifoMinFillLevel
+
+ @Description   Calling this routine changes the fifo minimum
+                fill level parameter in the internal driver data base
+                from its default configuration  [DEFAULT_PORT_txFifoMinFillLevel]
+
+                May be used for Tx ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     minFillLevel    New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLevel);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigTxFifoDeqPipelineDepth
+
+ @Description   Calling this routine changes the fifo dequeue
+                pipeline depth parameter in the internal driver data base
+
+                from its default configuration: 1G ports: [DEFAULT_PORT_txFifoDeqPipelineDepth_1G],
+                10G port: [DEFAULT_PORT_txFifoDeqPipelineDepth_10G]
+
+                May be used for Tx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     deqPipelineDepth    New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigTxFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipelineDepth);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigTxFifoLowComfLevel
+
+ @Description   Calling this routine changes the fifo low comfort level
+                parameter in internal driver data base
+                from its default configuration  [DEFAULT_PORT_txFifoLowComfLevel]
+
+                May be used for Tx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     fifoLowComfLevel    New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComfLevel);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigRxFifoThreshold
+
+ @Description   Calling this routine changes the threshold of the FIFO
+                fill level parameter in the internal driver data base
+                from its default configuration [DEFAULT_PORT_rxFifoThreshold]
+
+                If the total number of buffers which are
+                currently in use and associated with the
+                specific RX port exceed this threshold, the
+                BMI will signal the MAC to send a pause frame
+                over the link.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     fifoThreshold       New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigRxPriElevationLevel
+
+ @Description   Calling this routine changes the priority elevation level
+                parameter in the internal driver data base from its default
+                configuration  [DEFAULT_PORT_rxFifoPriElevationLevel]
+
+                If the total number of buffers which are currently
+                in use and associated with the specific RX
+                port exceed the amount specified in priElevationLevel,
+                BMI will signal the main FMs DMA to elivate
+                the FM priority on the system bus.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     priElevationLevel   New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigRxPriElevationLevel(t_Handle h_FmPort, uint32_t priElevationLevel);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigBufferPrefixContent
+
+ @Description   Defines the structure, size and content of the application buffer.
+                The prefix will
+                In Tx ports, if 'passPrsResult', the application
+                should set a value to their offsets in the prefix of
+                the FM will save the first 'privDataSize', than,
+                depending on 'passPrsResult' and 'passTimeStamp', copy parse result
+                and timeStamp, and the packet itself (in this order), to the
+                application buffer, and to offset.
+                Calling this routine changes the buffer margins definitions
+                in the internal driver data base from its default
+                configuration: Data size:  [DEFAULT_PORT_bufferPrefixContent_privDataSize]
+                               Pass Parser result: [DEFAULT_PORT_bufferPrefixContent_passPrsResult].
+                               Pass timestamp: [DEFAULT_PORT_bufferPrefixContent_passTimeStamp].
+
+                May be used for all ports
+
+ @Param[in]     h_FmPort                        A handle to a FM Port module.
+ @Param[in,out] p_FmPortBufferPrefixContent     A structure of parameters describing the
+                                                structure of the buffer.
+                                                Out parameter: Start margin - offset
+                                                of data from start of external buffer.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigBufferPrefixContent(t_Handle h_FmPort, t_FmPortBufferPrefixContent *p_FmPortBufferPrefixContent);
+
+#ifdef VERIFICATION_SUPPORT
+t_Error FM_PORT_ConfigIntContent (t_Handle  h_FmPort,
+                                  uint8_t   intContextIntOffset,
+                                  uint16_t  intContextExtOffset,
+                                  uint16_t  intContextSize,
+                                  uint16_t  startMargins,
+                                  uint16_t  endMargins);
+#endif /* VERIFICATION_SUPPORT */
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigCheksumLastBytesIgnore
+
+ @Description   Calling this routine changes the number of checksum bytes to ignore
+                parameter in the internal driver data base from its default configuration
+                [DEFAULT_PORT_cheksumLastBytesIgnore]
+
+                May be used by Tx & Rx ports only
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     cheksumLastBytesIgnore    New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigCheksumLastBytesIgnore(t_Handle h_FmPort, uint8_t cheksumLastBytesIgnore);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigCutBytesFromEnd
+
+ @Description   Calling this routine changes the number of bytes to cut from a
+                frame's end parameter in the internal driver data base
+                from its default configuration  [DEFAULT_PORT_cutBytesFromEnd]
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     cutBytesFromEnd     New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigCutBytesFromEnd(t_Handle h_FmPort, uint8_t cutBytesFromEnd);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigPoolDepletion
+
+ @Description   Calling this routine enables pause frame generation depending on the
+                depletion status of BM pools. It also defines the conditions to activate
+                this functionality. By default, this functionality is disabled.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     p_BufPoolDepletion      A structure of pool depletion parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmPortBufPoolDepletion *p_BufPoolDepletion);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigRateLimit
+
+ @Description   Calling this routine enables rate limit algorithm.
+                By default, this functionality is disabled.
+                Note that rate-limit mechanism uses the FM time stamp.
+                The selected rate limit specified here would be
+                rounded to the nearest power of 2 multiplication
+                (i.e. up to twice the required rate).
+
+                May be used for Tx and offline parsing ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_RateLimit     A structure of rate limit parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigFrmDiscardOverride
+
+ @Description   Calling this routine changes the error frames destination parameter
+                in the internal driver data base from its default configuration:
+                override = [DEFAULT_PORT_frmDiscardOverride]
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     override    TRUE to override dicarding of error frames and
+                            enqueueing them to error queue.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigFrmDiscardOverride(t_Handle h_FmPort, bool override);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigErrorsToDiscard
+
+ @Description   Calling this routine changes the behaviour on error parameter
+                in the internal driver data base from its default configuration:
+                [DEFAULT_PORT_errorsToDiscard].
+                If a requested error was previously defined as "ErrorsToEnqueue" it's
+                definition will change and the frame will be discarded.
+                Errors that were not defined either as "ErrorsToEnqueue" nor as
+                "ErrorsToDiscard", will be forwarded to CPU.
+
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     errs        A list of errors to discard
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort, fmPortFrameErrSelect_t errs);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDmaSwapData
+
+ @Description   Calling this routine changes the DMA swap data aparameter
+                in the internal driver data base from its default
+                configuration  [DEFAULT_PORT_dmaSwapData]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     swapData    New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDmaSwapData(t_Handle h_FmPort, e_FmPortDmaSwap swapData);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDmaIcCacheAttr
+
+ @Description   Calling this routine changes the internal context cache
+                attribute parameter in the internal driver data base
+                from its default configuration  [DEFAULT_PORT_dmaIntContextCacheAttr]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort                    A handle to a FM Port module.
+ @Param[in]     intContextCacheAttr    New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort, e_FmPortDmaCache intContextCacheAttr);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDmaHdrAttr
+
+ @Description   Calling this routine changes the header cache
+                attribute parameter in the internal driver data base
+                from its default configuration  [DEFAULT_PORT_dmaHeaderCacheAttr]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort                    A handle to a FM Port module.
+ @Param[in]     headerCacheAttr             New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort, e_FmPortDmaCache headerCacheAttr);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDmaScatterGatherAttr
+
+ @Description   Calling this routine changes the scatter gather cache
+                attribute parameter in the internal driver data base
+                from its default configuration  [DEFAULT_PORT_dmaScatterGatherCacheAttr]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort                    A handle to a FM Port module.
+ @Param[in]     scatterGatherCacheAttr      New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmPortDmaCache scatterGatherCacheAttr);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDmaReadOptimize
+
+ @Description   Calling this routine changes the read optimization
+                parameter in the internal driver data base
+                from its default configuration:  optimize = [DEFAULT_PORT_dmaReadOptimize]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     optimize    TRUE to enable optimization, FALSE for normal operation
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDmaReadOptimize(t_Handle h_FmPort, bool optimize);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDmaWriteOptimize
+
+ @Description   Calling this routine changes the write optimization
+                parameter in the internal driver data base
+                from its default configuration:  optimize = [DEFAULT_PORT_dmaWriteOptimize]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     optimize    TRUE to enable optimization, FALSE for normal operation
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDmaWriteOptimize(t_Handle h_FmPort, bool optimize);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigDfltColor
+
+ @Description   Calling this routine changes the internal default color parameter
+                in the internal driver data base
+                from its default configuration  [DEFAULT_PORT_color]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     color           New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigDfltColor(t_Handle h_FmPort, e_FmPortColor color);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigSyncReq
+
+ @Description   Calling this routine changes the synchronization attribute parameter
+                in the internal driver data base from its default configuration:
+                syncReq = [DEFAULT_PORT_syncReq]
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     syncReq         TRUE to request synchronization, FALSE otherwize.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigForwardReuseIntContext
+
+ @Description   This routine is relevant for Rx ports that are routed to offline
+                parsing. It changes the internal context reuse option
+                in the internal driver data base from its default configuration:
+                reuse = [DEFAULT_PORT_forwardIntContextReuse]
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     reuse           TRUE to reuse internal context on frames
+                                forwarded to offline parsing.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigForwardReuseIntContext(t_Handle h_FmPort, bool reuse);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigRxL4ChecksumVerify
+
+ @Description   This routine is relevant for Rx ports that are routed to transmission.
+                It changes the internal context reuse option
+                in the internal driver data base from its default configuration:
+                l4Checksum = [DEFAULT_PORT_l4Checksum]
+
+                May be used for Rx ports only.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     l4Checksum      TRUE to do TCP checksum on frames
+                                forwarded to transmission.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigRxL4ChecksumVerify(t_Handle h_FmPort, bool l4Checksum);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigIMMaxRxBufLength
+
+ @Description   Changes the maximum receive buffer length from its default
+                configuration: [DEFAULT_PORT_ImMaxRxBufLength]
+
+                The maximum receive buffer length directly affects the structure
+                of received frames (single- or multi-buffered) and the performance
+                of both the FM and the driver.
+
+                The selection between single- or multi-buffered frames should be
+                done according to the characteristics of the specific application.
+                The recommended mode is to use a single data buffer per packet,
+                as this mode provides the best performance. However, the user can
+                select to use multiple data buffers per packet.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     newVal          Maximum receive buffer length (in bytes).
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+                This routine is to be used only if Independent-Mode is enabled.
+*//***************************************************************************/
+t_Error FM_PORT_ConfigIMMaxRxBufLength(t_Handle h_FmPort, uint16_t newVal);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigIMRxBdRingLength
+
+ @Description   Changes the receive BD ring length from its default
+                configuration:[DEFAULT_PORT_rxBdRingLength]
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     newVal          The desired BD ring length.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+                This routine is to be used only if Independent-Mode is enabled.
+*//***************************************************************************/
+t_Error FM_PORT_ConfigIMRxBdRingLength(t_Handle h_FmPort, uint16_t newVal);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigIMTxBdRingLength
+
+ @Description   Changes the transmit BD ring length from its default
+                configuration:[DEFAULT_PORT_txBdRingLength]
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     newVal          The desired BD ring length.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+                This routine is to be used only if Independent-Mode is enabled.
+*//***************************************************************************/
+t_Error FM_PORT_ConfigIMTxBdRingLength(t_Handle h_FmPort, uint16_t newVal);
+
+/** @} */ /* end of FM_PORT_advanced_init_grp group */
+/** @} */ /* end of FM_PORT_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_PORT_runtime_control_grp FM Port Runtime Control Unit
+
+ @Description   FM Port Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   enum for defining FM Port counters
+*//***************************************************************************/
+typedef enum e_FmPortCounters {
+    e_FM_PORT_COUNTERS_CYCLE,                       /**< BMI performance counter */
+    e_FM_PORT_COUNTERS_TASK_UTIL,                   /**< BMI performance counter */
+    e_FM_PORT_COUNTERS_QUEUE_UTIL,                  /**< BMI performance counter */
+    e_FM_PORT_COUNTERS_DMA_UTIL,                    /**< BMI performance counter */
+    e_FM_PORT_COUNTERS_FIFO_UTIL,                   /**< BMI performance counter */
+    e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION,         /**< BMI Rx only performance counter */
+    e_FM_PORT_COUNTERS_FRAME,                       /**< BMI statistics counter */
+    e_FM_PORT_COUNTERS_DISCARD_FRAME,               /**< BMI statistics counter */
+    e_FM_PORT_COUNTERS_DEALLOC_BUF,                 /**< BMI deallocate buffer statistics counter */
+    e_FM_PORT_COUNTERS_RX_BAD_FRAME,                /**< BMI Rx only statistics counter */
+    e_FM_PORT_COUNTERS_RX_LARGE_FRAME,              /**< BMI Rx only statistics counter */
+    e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,   /**< BMI Rx only statistics counter */
+    e_FM_PORT_COUNTERS_RX_FILTER_FRAME,             /**< BMI Rx & OP only statistics counter */
+    e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR,             /**< BMI Rx, OP & HC only statistics counter */
+    e_FM_PORT_COUNTERS_WRED_DISCARD,                /**< BMI OP & HC only statistics counter */
+    e_FM_PORT_COUNTERS_LENGTH_ERR,                  /**< BMI non-Rx statistics counter */
+    e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT,           /**< BMI non-Rx statistics counter */
+    e_FM_PORT_COUNTERS_DEQ_TOTAL,                   /**< QMI counter */
+    e_FM_PORT_COUNTERS_ENQ_TOTAL,                   /**< QMI counter */
+    e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT,            /**< QMI counter */
+    e_FM_PORT_COUNTERS_DEQ_CONFIRM                  /**< QMI counter */
+} e_FmPortCounters;
+
+/**************************************************************************//**
+ @Description   Structure for Port id parameters.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+*//***************************************************************************/
+typedef struct t_FmPortCongestionGrps {
+    uint16_t    numOfCongestionGrpsToConsider;          /**< The number of required congestion groups
+                                                             to define the size of the following array */
+    uint8_t     congestionGrpsToConsider[FM_PORT_NUM_OF_CONGESTION_GRPS];
+                                                        /**< An array of 'numOfCongestionGrpsToConsider'
+                                                             describing the groups */
+} t_FmPortCongestionGrps;
+
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//**
+ @Function      FM_PORT_DumpRegs
+
+ @Description   Dump all regs.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmPort - FM PORT module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_DumpRegs(t_Handle h_FmPort);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetBufferDataOffset
+
+ @Description   Returns the data offset from the begining of the data buffer
+
+ @Param[in]     h_FmPort - FM PORT module descriptor
+
+ @Return        data offset.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+uint32_t FM_PORT_GetBufferDataOffset(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetBufferPrsResult
+
+ @Description   Returns the pointer to the parse result in the data buffer.
+                In Rx ports this is relevant after reception, if parse
+                result is configured to be part of the data passed to the
+                application. For non Rx ports it may be used to get the pointer
+                of the area in the buffer where parse result should be
+                initialized - if so configured.
+                See FM_PORT_ConfigBufferPrefixContent for data buffer prefix
+                configuration.
+
+ @Param[in]     h_FmPort    - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        Parse result pointer on success, NULL if parse result was not
+                configured for this port.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_FmPrsResult * FM_PORT_GetBufferPrsResult(t_Handle h_FmPort, char *p_Data);
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetBufferTimeStamp
+
+ @Description   Returns the pointer to the time stamp in the data buffer.
+                In Rx ports this is relevant after reception, if parse
+                result is configured to be part of the data passed to the
+                application. For non Rx ports it may be used to get the pointer
+                of the area in the buffer where time stamp should be
+                initialized - if so configured.
+                See FM_PORT_ConfigBufferPrefixContent for data buffer prefix
+                configuration.
+
+ @Param[in]     h_FmPort    - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        Time stamp pointer on success, NULL if time stamp was not
+                configured for this port.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_FmTimeStamp * FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data);
+
+/**************************************************************************//**
+ @Function      FM_PORT_Disable
+
+ @Description   Gracefully disable an FM port. The port will not start new tasks after all
+                tasks associated with the port are terminated.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                This is a blocking routine, it returns after port is
+                gracefully stopped, i.e. the port will not except new frames,
+                but it will finish all frames or tasks which were already began
+*//***************************************************************************/
+void FM_PORT_Disable(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_Enable
+
+ @Description   A runtime routine provided to allow disable/enable of port.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+void FM_PORT_Enable(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetStatisticsCounters
+
+ @Description   Calling this routine enables/disables port's statistics counters.
+                By default, counters are enabled.
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     enable      TRUE to enable, FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetFrameQueueCounters
+
+ @Description   Calling this routine enables/disables port's enqueue/dequeue counters.
+                By default, counters are enabled.
+
+                May be used for all ports
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     enable      TRUE to enable, FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetPerformanceCounters
+
+ @Description   Calling this routine enables/disables port's performance counters.
+                By default, counters are disabled.
+
+                May be used for all port types
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     p_FmPortPerformanceCnt  A structure of performance counters parameters.
+                                        Note that `queueCompVal` is used only by Rx ports
+                                        and Tx ports with confirmation queue.
+ @Param[in]     enable                  TRUE to enable, FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, t_FmPortPerformanceCnt *p_FmPortPerformanceCnt, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetAllocBufCounter
+
+ @Description   Calling this routine enables/disables BM pool allocate
+                buffer counters.
+                By default, counters are enabled.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     poolId      BM pool id.
+ @Param[in]     enable      TRUE to enable, FALSE to disable.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetEnAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetCounter
+
+ @Description   Reads one of the FM PORT counters.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     fmPortCounter       The requested counter.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters fmPortCounter);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetCounter
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     fmPortCounter       The requested counter.
+ @Param[in]     value                 The requested value to be written into the counter.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetCounter(t_Handle h_FmPort, e_FmPortCounters fmPortCounter, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_PORT_GetAllocBufCounter
+
+ @Description   Reads one of the FM PORT buffer counters.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     poolId              The requested pool.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                Note that it is user's responsibilty to call this routine only
+                for enabled counters, and there will be no indication if a
+                disabled counter is accessed.
+*//***************************************************************************/
+uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetAllocBufCounter
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     poolId              The requested pool.
+ @Param[in]     value               The requested value to be written into the counter.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort,  uint8_t poolId, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_PORT_AddCongestionGrps
+
+ @Description   This routine effects the corresponding Tx port.
+                It should be called in order to enable pause
+                frame transmission in case of congestion in one or more
+                of the congestion groups relevant to this port.
+                Each call to this routine may add one or more congestion
+                groups to be considered relevant to this port.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_CongestionGrps    A pointer to an array of congestion groups
+                                    id's to consider.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps);
+
+/**************************************************************************//**
+ @Function      FM_PORT_RemoveCongestionGrps
+
+ @Description   This routine effects the corresponding Tx port. It should be
+                called when congestion groups were
+                defined for this port and are no longer relevant, or pause
+                frames transmitting is not required on their behalf.
+                Each call to this routine may remove one or more congestion
+                groups to be considered relevant to this port.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_CongestionGrps    A pointer to an array of congestion groups
+                                    id's to consider.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps);
+
+/**************************************************************************//**
+ @Function      FM_PORT_IsStalled
+
+ @Description   A routine for checking whether the specified port is stalled.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+
+ @Return        TRUE if port is stalled, FALSE otherwize
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+bool FM_PORT_IsStalled(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ReleaseStalled
+
+ @Description   This routine may be called in case the port was stalled and may
+                now be released.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ReleaseStalled(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetErrorsRoute
+
+ @Description   Errors selected for this routine will cause a frame with that error
+                to be enqueued to error queue.
+                Errors not selected for this routine will cause a frame with that error
+                to be enqueued to the one of the other port queues.
+                By default all errors are defined to be enqueued to error queue.
+                Errors that were configured to be discarded (at initialization)
+                may not be selected here.
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     errs        A list of errors to enqueue to error queue
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs);
+
+/**************************************************************************//**
+ @Group         FM_PORT_pcd_runtime_control_grp FM Port PCD Runtime Control Unit
+
+ @Description   FM Port PCD Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   A stracture defining the KG scheme after the parser.
+                This is relevant only to change scheme selection mode - from
+                direct to indirect and vice versa, or when the scheme is selected directly,
+                to select the scheme id.
+
+*//***************************************************************************/
+typedef struct t_FmPcdKgSchemeSelect {
+    bool        direct;                 /**< TRUE to use 'h_Scheme' directly, FALSE to use LCV.*/
+    t_Handle    h_DirectScheme;         /**< Relevant for 'direct'=TRUE only. scheme handle,
+                                             Selects the scheme after parser. */
+} t_FmPcdKgSchemeSelect;
+
+/**************************************************************************//**
+ @Description   A structure of scheme parameters
+*//***************************************************************************/
+typedef struct t_FmPcdPortSchemesParams {
+    uint8_t     numOfSchemes;                           /**< Number of schemes for port to be bound to. */
+    t_Handle    h_Schemes[FM_PCD_KG_NUM_OF_SCHEMES];    /**< Array of 'numOfSchemes' schemes for the
+                                                             port to be bound to */
+} t_FmPcdPortSchemesParams;
+
+/**************************************************************************//**
+ @Description   Union for defining port protocol parameters for parser
+*//***************************************************************************/
+typedef union u_FmPcdHdrPrsOpts {
+    /* MPLS */
+    struct {
+        bool            labelInterpretationEnable;  /**< When this bit is set, the last MPLS label will be
+                                                         interpreted as described in HW spec table. When the bit
+                                                         is cleared, the parser will advance to MPLS next parse */
+        e_NetHeaderType nextParse;                  /**< must be equal or higher than IPv4 */
+    } mplsPrsOptions;
+    /* VLAN */
+    struct {
+        uint16_t        tagProtocolId1;             /**< User defined Tag Protocol Identifier, to be recognized
+                                                         on VLAN TAG on top of 0x8100 and 0x88A8 */
+        uint16_t        tagProtocolId2;             /**< User defined Tag Protocol Identifier, to be recognized
+                                                         on VLAN TAG on top of 0x8100 and 0x88A8 */
+    } vlanPrsOptions;
+    /* IPV6 */
+    struct{
+        bool            routingHdrDisable;          /**< Disable routing header */
+    } ipv6PrsOptions;
+
+    /* UDP */
+    struct{
+        bool            padIgnoreChecksum;          /**< TRUE to ignore pad in checksum */
+    } udpPrsOptions;
+
+    /* TCP */
+    struct {
+        bool            padIgnoreChecksum;          /**< TRUE to ignore pad in checksum */
+    } tcpPrsOptions;
+} u_FmPcdHdrPrsOpts;
+
+
+/**************************************************************************//**
+ @Description   A structure for defining each header for the parser
+*//***************************************************************************/
+typedef struct t_FmPcdPrsAdditionalHdrParams {
+    e_NetHeaderType         hdr;            /**< Selected header */
+    bool                    errDisable;     /**< TRUE to disable error indication */
+    bool                    swPrsEnable;    /**< Enable jump to SW parser when this
+                                                 header is recognized by the HW parser. */
+    uint8_t                 indexPerHdr;    /**< Normally 0, if more than one sw parser
+                                                 attachments exists for the same header,
+                                                 (in the main sw parser code) use this
+                                                 index to distinguish between them. */
+    bool                    usePrsOpts;     /**< TRUE to use parser options. */
+    u_FmPcdHdrPrsOpts       prsOpts;        /**< A unuion according to header type,
+                                                 defining the parser options selected.*/
+} t_FmPcdPrsAdditionalHdrParams;
+
+/**************************************************************************//**
+ @Description   struct for defining port PCD parameters
+*//***************************************************************************/
+typedef struct t_FmPortPcdPrsParams {
+    uint8_t                         prsResultPrivateInfo;           /**< The private info provides a method of inserting
+                                                                         port information into the parser result. This information
+                                                                         may be extracted by Keygen and be used for frames
+                                                                         distribution when a per-port distinction is required,
+                                                                         it may also be used as a port logical id for analyazing
+                                                                         incoming frames. */
+    uint8_t                         parsingOffset;                  /**< Number of bytes from begining of packet to
+                                                                         start parsing */
+    e_NetHeaderType                 firstPrsHdr;                    /**< The type of the first header axpected at
+                                                                         'parsingOffset' */
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    bool                            includeInPrsStatistics;         /**< TRUE to include this port in the parser statistics.*/
+#endif  /* ! CONFIG_MULTI_PARTITION_SUPPORT */
+    uint8_t                         numOfHdrsWithAdditionalParams;  /**< Normally 0, some headers may get
+                                                                         special parameters */
+    t_FmPcdPrsAdditionalHdrParams   additionalParams[FM_PCD_PRS_NUM_OF_HDRS];
+                                                                    /**< 'numOfHdrsWithAdditionalParams'  structures
+                                                                         of additional parameters
+                                                                         for each header that requires them */
+    bool                            setVlanTpid1;                   /**< TRUE to configure user selection of Ethertype to
+                                                                         indicate a VLAN tag (in addition to the TPID values
+                                                                         0x8100 and 0x88A8). */
+    uint16_t                        vlanTpid1;                      /**< extra tag to use if setVlanTpid1=TRUE. */
+    bool                            setVlanTpid2;                   /**< TRUE to configure user selection of Ethertype to
+                                                                         indicate a VLAN tag (in addition to the TPID values
+                                                                         0x8100 and 0x88A8). */
+    uint16_t                        vlanTpid2;                      /**< extra tag to use if setVlanTpid1=TRUE. */
+} t_FmPortPcdPrsParams;
+
+/**************************************************************************//**
+ @Description   struct for defining coarse alassification parameters
+*//***************************************************************************/
+typedef struct t_FmPortPcdCcParams {
+    t_Handle            h_CcTree;                       /**< A handle to a CC tree */
+} t_FmPortPcdCcParams;
+
+/**************************************************************************//**
+ @Description   struct for defining keygen parameters
+*//***************************************************************************/
+typedef struct t_FmPortPcdKgParams {
+    uint8_t             numOfSchemes;                   /**< Number of schemes for port to be bound to. */
+    t_Handle            h_Schemes[FM_PCD_KG_NUM_OF_SCHEMES];
+                                                        /**< Array of 'numOfSchemes' schemes handles for the
+                                                             port to be bound to */
+    bool                useClsPlan;                     /**< TRUE to use the classification plan mechanism */
+    t_Handle            h_ClsPlanGrp;                   /**< clssification-Plan must be of the same h_NetEnv
+                                                             of this port */
+    bool                directScheme;                   /**< TRUE for going from parser to a specific scheme,
+                                                             regardless of parser result */
+    t_Handle            h_DirectScheme;                 /**< relevant only if direct == TRUE, Scheme handle,
+                                                             as returned by FM_PCD_KgSetScheme */
+} t_FmPortPcdKgParams;
+
+/**************************************************************************//**
+ @Description   struct for defining policer parameters
+*//***************************************************************************/
+typedef struct t_FmPortPcdPlcrParams {
+    t_Handle                h_Profile;          /**< Selected profile handle. relevant only if
+                                                     e_FM_PCD_SUPPORT_PLCR_ONLY or
+                                                     e_FM_PCD_SUPPORT_PRS_AND_PLCR were selected */
+} t_FmPortPcdPlcrParams;
+
+/**************************************************************************//**
+ @Description   struct for defining port PCD parameters
+*//***************************************************************************/
+typedef struct t_FmPortPcdParams {
+    e_FmPortPcdSupport      pcdSupport;         /**< Relevant for Rx and offline ports only.
+                                                     Describes the active PCD engines for this port. */
+    t_Handle                h_NetEnv;           /**< HL Unused in PLCR only mode */
+    t_FmPortPcdPrsParams    *p_PrsParams;       /**< Parser parameters for this port */
+    t_FmPortPcdCcParams     *p_CcParams;        /**< Coarse classification parameters for this port */
+    t_FmPortPcdKgParams     *p_KgParams;        /**< Keygen parameters for this port */
+    t_FmPortPcdPlcrParams   *p_PlcrParams;      /**< Policer parameters for this port */
+} t_FmPortPcdParams;
+
+
+/**************************************************************************//**
+ @Function      FM_PORT_SetPCD
+
+ @Description   Calling this routine defines the port's PCD configuration.
+                It changes it from its default configuration which is PCD
+                disabled (BMI to BMI) and configures it according to the passed
+                parameters.
+
+                May be used for Rx and offline parsing ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_FmPortPcd     A Structure of parameters defining the port's PCD
+                                configuration.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_FmPortPcd);
+
+/**************************************************************************//**
+ @Function      FM_PORT_DeletePCD
+
+ @Description   Calling this routine releases the port's PCD configuration.
+                The port returns to its default configuration which is PCD
+                disabled (BMI to BMI) and all PCD configuration is removed.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode  only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_DeletePCD(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_AttachPCD
+
+ @Description   This routine may be called after FM_PORT_DetachPCD was called,
+                to return to the originally configured PCD support flow.
+                The couple of routines are used to allow PCD configuration changes
+                that demand that PCD will not be used while changes take place.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_AttachPCD(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_DetachPCD
+
+ @Description   Calling this routine detaches the port from its PCD functionality.
+                The port returns to its default flow which is BMI to BMI.
+
+                May be used for Rx and offline parsing ports which are
+                in PCD mode only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_DetachPCD(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdPlcrAllocProfiles
+
+ @Description   This routine may be called only for ports that use the Policer in
+                order to allocate private policer profiles.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     numOfProfiles       The number of required policer profiles
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(), and before FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdPlcrFreeProfiles
+
+ @Description   This routine should be called for freeing private policer profiles.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(), and before FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdKgModifyInitialScheme
+
+ @Description   This routine may be called only for ports that use the keygen in
+                order to change the initial scheme frame should be routed to.
+                The change may be of a scheme id (in case of direct mode),
+                from direct to indirect, or from indirect to direct - specifying the scheme id.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     p_FmPcdKgScheme     A structure of parameters for defining whether
+                                    a scheme is direct/indirect, and if direct - scheme id.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error          FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSelect *p_FmPcdKgScheme);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdPlcrModifyInitialProfile
+
+ @Description   This routine may be called for ports with flows e_FM_PCD_SUPPORT_PLCR_ONLY or
+                e_FM_PCD_SUPPORT_PRS_AND_PLCR  only, to change the initial Policer profile frame
+                should be routed to. The change may be of a profile and/or absolute/direct mode
+                selection.
+
+ @Param[in]     h_FmPort                A handle to a FM Port module.
+ @Param[in]     h_Profile               Policer profile handle
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_Profile);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdCcModifyTree
+
+ @Description   This routine may be called for ports that use coarse classification tree
+                if the user wishes to replace the tree. The routine may not be called while port
+                receives packets using the PCD functionalities, therefor port must be first detached
+                from the PCD, only than the routine may be called, and than port be attached to PCD again.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     h_CcTree            A CC tree that was already built. The tree id as returned from
+                                    the BuildTree routine.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init(), FM_PORT_SetPCD() and FM_PORT_DetachPCD()
+*//***************************************************************************/
+t_Error          FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdKgModifyClsPlanGrp
+
+ @Description   This routine may be called for ports using the KG functionality of the PCD,
+                if the user wishes to replace the classification plan
+                group that the port uses, to start using the classification plan mechanism or to stop
+                using it. The routine may not be called while port
+                receives packets using the PCD functionalities, therefor port must be first detached
+                from the PCD, only than the routine may be called, and than port be attached to PCD again.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     useClsPlan          TRUE to use a pre-defined group, FALSE to stop using one.
+ @Param[in]     h_NewClsPlanGrp     A handle of a classification plan group that was already set.
+                                    The handle as returned from the SetClsPlanGrp routine.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init(), FM_PORT_SetPCD() and FM_PORT_DetachPCD()
+*//***************************************************************************/
+t_Error          FM_PORT_PcdKgModifyClsPlanGrp (t_Handle h_FmPort, bool useClsPlan, t_Handle h_NewClsPlanGrp);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdKgBindSchemes
+
+ @Description   These routines may be called for adding more schemes for the
+                port to be bound to. The selected schemes are not added,
+                just this specific port starts using them.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_PortScheme    A structure defining the list of schemes to be added.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error      FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme);
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdKgUnbindSchemes
+
+ @Description   These routines may be called for adding more schemes for the
+                port to be bound to. The selected schemes are not removed or invalidated,
+                just this specific port stops using them.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_PortScheme    A structure defining the list of schemes to be added.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error      FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme);
+
+/**************************************************************************//**
+ @Description   A structure for defining the Parser starting point
+*//***************************************************************************/
+typedef struct t_FmPcdPrsStart {
+    uint8_t             parsingOffset;  /**< Number of bytes from begining of packet to
+                                             start parsing */
+    e_NetHeaderType     firstPrsHdr;    /**< The type of the first header axpected at
+                                             'parsingOffset' */
+} t_FmPcdPrsStart;
+
+/**************************************************************************//**
+ @Function      FM_PORT_PcdPrsModifyStartOffset
+
+ @Description   Runtime change of the parser start offset within the header.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_FmPcdPrsStart A structure of parameters for defining the
+                                start point for the parser.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PORT_SetPCD().
+*//***************************************************************************/
+t_Error      FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_FmPcdPrsStart);
+
+/** @} */ /* end of FM_PORT_pcd_runtime_control_grp group */
+/** @} */ /* end of FM_PORT_runtime_control_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_PORT_runtime_data_grp FM Port Runtime Data-path Unit
+
+ @Description   FM Port Runtime data unit API functions, definitions and enums.
+                This API is valid only if working in Independent-Mode.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_PORT_ImTx
+
+ @Description   Tx function, called to transmit a data buffer on the port.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     p_Data      A pointer to an LCP data buffer.
+ @Param[in]     length      Size of data for transmission.
+ @Param[in]     lastBuffer  Buffer poistion - TRUE for the last buffer
+                            of a frame, including a single buffer frame
+ @Param[in]     h_UserPriv  A handle of the user acossiated with this buffer
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                NOTE - This routine can be used only when working in
+                Independent-Mode mode.
+*//***************************************************************************/
+t_Error  FM_PORT_ImTx( t_Handle               h_FmPort,
+                       uint8_t                *p_Data,
+                       uint16_t               length,
+                       bool                   lastBuffer,
+                       t_Handle               h_UserPriv);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ImTxConf
+
+ @Description   Tx port confirmation routine, optional, may be called to verify
+                transmission of all frames. The procedure performed by this
+                routine will be performed automatically on next buffer transmission,
+                but if desired, calling this routine will invoke this action on
+                demand.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                NOTE - This routine can be used only when working in
+                Independent-Mode mode.
+*//***************************************************************************/
+void FM_PORT_ImTxConf(t_Handle h_FmPort);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ImRx
+
+ @Description   Rx function, may be called to poll for received buffers.
+                Normally, Rx process is invoked by the driver on Rx interrupt.
+                Alternatively, this routine may be called on demand.
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+                NOTE - This routine can be used only when working in
+                Independent-Mode mode.
+*//***************************************************************************/
+t_Error  FM_PORT_ImRx(t_Handle h_FmPort);
+
+/** @} */ /* end of FM_PORT_runtime_data_grp group */
+/** @} */ /* end of FM_PORT_grp group */
+/** @} */ /* end of FM_grp group */
+
+#endif /* __FM_PORT_EXT */
diff --git a/drivers/net/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h b/drivers/net/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
new file mode 100644
index 0000000..419445f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
@@ -0,0 +1,75 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef __MII_ACC_EXT_H
+#define __MII_ACC_EXT_H
+
+
+/**************************************************************************//**
+ @Function      MII_ReadPhyReg
+
+ @Description   This routine is called to read a specified PHY
+                register value.
+
+ @Param[in]     h_MiiAccess - Handle to MII configuration access registers
+ @Param[in]     phyAddr     - PHY address (0-31).
+ @Param[in]     reg         - PHY register to read
+ @Param[out]    p_Data      - Gets the register value.
+
+ @Return        Always zero (success).
+*//***************************************************************************/
+int MII_ReadPhyReg(t_Handle h_MiiAccess,
+                   uint8_t  phyAddr,
+                   uint8_t  reg,
+                   uint16_t *p_Data);
+
+/**************************************************************************//**
+ @Function      MII_WritePhyReg
+
+ @Description   This routine is called to write data to a specified PHY
+                   register.
+
+ @Param[in]     h_MiiAccess - Handle to MII configuration access registers
+ @Param[in]     phyAddr     - PHY address (0-31).
+ @Param[in]     reg         - PHY register to write
+ @Param[in]     data        - Data to write in register.
+
+ @Return        Always zero (success).
+*//***************************************************************************/
+int MII_WritePhyReg(t_Handle    h_MiiAccess,
+                    uint8_t     phyAddr,
+                    uint8_t     reg,
+                    uint16_t    data);
+
+
+#endif /* __MII_ACC_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/ctype_ext.h b/drivers/net/dpa/NetCommSw/inc/ctype_ext.h
new file mode 100644
index 0000000..b28ff4c
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/ctype_ext.h
@@ -0,0 +1,96 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __CTYPE_EXT_H
+#define __CTYPE_EXT_H
+
+
+#if defined(NCSW_LINUX) && defined(__KERNEL__)
+/*
+ * NOTE! This ctype does not handle EOF like the standard C
+ * library is required to.
+ */
+
+#define _U    0x01    /* upper */
+#define _L    0x02    /* lower */
+#define _D    0x04    /* digit */
+#define _C    0x08    /* cntrl */
+#define _P    0x10    /* punct */
+#define _S    0x20    /* white space (space/lf/tab) */
+#define _X    0x40    /* hex digit */
+#define _SP   0x80    /* hard space (0x20) */
+
+extern unsigned char _ctype[];
+
+#define __ismask(x) (_ctype[(int)(unsigned char)(x)])
+
+#define isalnum(c)    ((__ismask(c)&(_U|_L|_D)) != 0)
+#define isalpha(c)    ((__ismask(c)&(_U|_L)) != 0)
+#define iscntrl(c)    ((__ismask(c)&(_C)) != 0)
+#define isdigit(c)    ((__ismask(c)&(_D)) != 0)
+#define isgraph(c)    ((__ismask(c)&(_P|_U|_L|_D)) != 0)
+#define islower(c)    ((__ismask(c)&(_L)) != 0)
+#define isprint(c)    ((__ismask(c)&(_P|_U|_L|_D|_SP)) != 0)
+#define ispunct(c)    ((__ismask(c)&(_P)) != 0)
+#define isspace(c)    ((__ismask(c)&(_S)) != 0)
+#define isupper(c)    ((__ismask(c)&(_U)) != 0)
+#define isxdigit(c)   ((__ismask(c)&(_D|_X)) != 0)
+
+#define isascii(c) (((unsigned char)(c))<=0x7f)
+#define toascii(c) (((unsigned char)(c))&0x7f)
+
+static __inline__ unsigned char __tolower(unsigned char c)
+{
+    if (isupper(c))
+        c -= 'A'-'a';
+    return c;
+}
+
+static __inline__ unsigned char __toupper(unsigned char c)
+{
+    if (islower(c))
+        c -= 'a'-'A';
+    return c;
+}
+
+#define tolower(c) __tolower(c)
+#define toupper(c) __toupper(c)
+
+#elif defined(MWI_VXWORKS)
+#include "ctype.h"
+
+#else
+#include <ctype.h>
+#endif /* defined(NCSW_LINUX) && defined(__KERNEL__) */
+
+
+#endif /* __CTYPE_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/debug_ext.h b/drivers/net/dpa/NetCommSw/inc/debug_ext.h
new file mode 100644
index 0000000..f5f3a7c
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/debug_ext.h
@@ -0,0 +1,258 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          debug_ext.h
+
+ @Description   Debug mode definitions.
+*//***************************************************************************/
+
+#ifndef __DEBUG_EXT_H
+#define __DEBUG_EXT_H
+
+#include "std_ext.h"
+#include "xx_ext.h"
+#include "memcpy_ext.h"
+#if (DEBUG_ERRORS > 0)
+#include "sprint_ext.h"
+#include "string_ext.h"
+#endif /* DEBUG_ERRORS > 0 */
+
+
+#if (DEBUG_ERRORS > 0)
+
+/* Internally used macros */
+
+#define DUMP_Print          XX_Print
+#define DUMP_MAX_LEVELS     6
+#define DUMP_MAX_STR        64
+
+
+#define _CREATE_DUMP_SUBSTR(phrase) \
+    dumpTmpLevel = 0; dumpSubStr[0] = '\0'; \
+    sprintf(dumpTmpStr, "%s", #phrase); \
+    p_DumpToken = strtok(dumpTmpStr, (dumpIsArr[0] ? "[" : ".")); \
+    while (p_DumpToken != NULL) \
+    { \
+        strcat(dumpSubStr, p_DumpToken); \
+        if (dumpIsArr[dumpTmpLevel]) \
+        { \
+            strcat(dumpSubStr, dumpIdxStr[dumpTmpLevel]); \
+            p_DumpToken = strtok(NULL, "."); \
+        } \
+        if ((p_DumpToken = strtok(NULL, (dumpIsArr[++dumpTmpLevel] ? "[" : "."))) != 0) \
+            strcat(dumpSubStr, "."); \
+    }\
+
+
+/**************************************************************************//**
+ @Group         gen_id  General Drivers Utilities
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         dump_id  Memory and Registers Dump Mechanism
+
+ @Description   Macros for dumping memory mapped structures.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Declaration of dump mechanism variables.
+
+                This macro must be declared at the beginning of each routine
+                which uses the dump mechanism macros, before the routine's code
+                starts.
+*//***************************************************************************/
+#define DECLARE_DUMP \
+    char    dumpIdxStr[DUMP_MAX_LEVELS + 1][6] = { "", }; \
+    char    dumpSubStr[DUMP_MAX_STR] = ""; \
+    char    dumpTmpStr[DUMP_MAX_STR] = ""; \
+    char    *p_DumpToken = NULL; \
+    int     dumpArrIdx = 0, dumpArrSize = 0, dumpVarSize = 0, dumpLevel = 0, dumpTmpLevel = 0; \
+    uint8_t dumpIsArr[DUMP_MAX_LEVELS + 1] = { 0 }; \
+    /* Prevent warnings if not all used */ \
+    UNUSED(dumpIdxStr[0][0]); \
+    UNUSED(dumpSubStr[0]); \
+    UNUSED(dumpTmpStr[0]); \
+    UNUSED(p_DumpToken); \
+    UNUSED(dumpArrIdx); \
+    UNUSED(dumpArrSize); \
+    UNUSED(dumpVarSize); \
+    UNUSED(dumpLevel); \
+    UNUSED(dumpTmpLevel); \
+    UNUSED(dumpIsArr[0]);
+
+
+/**************************************************************************//**
+ @Description   Prints a title for a subsequent dumped structure or memory.
+
+                The inputs for this macro are the structure/memory title and
+                its base addresss.
+*//***************************************************************************/
+#define DUMP_TITLE(addr, msg)  \
+    DUMP_Print("\r\n"); DUMP_Print msg; \
+    DUMP_Print(" (0x%08X)\r\n" \
+               "---------------------------------------------------------\r\n", \
+               (uint32_t)addr)
+
+/**************************************************************************//**
+ @Description   Prints a subtitle for a subsequent dumped sub-structure (optional).
+
+                The inputs for this macro are the sub-structure subtitle.
+                A separating line with this subtitle will be printed.
+*//***************************************************************************/
+#define DUMP_SUBTITLE(subtitle)  \
+    DUMP_Print("----------- "); DUMP_Print subtitle; DUMP_Print("\r\n")
+
+
+/**************************************************************************//**
+ @Description   Dumps a memory region in 4-bytes aligned format.
+
+                The inputs for this macro are the base addresss and size
+                (in bytes) of the memory region.
+*//***************************************************************************/
+#define DUMP_MEMORY(addr, size)  \
+    MemDisp((uint8_t *)(addr), (int)(size))
+
+
+/**************************************************************************//**
+ @Description   Declares a dump loop, for dumping a sub-structure array.
+
+                The inputs for this macro are:
+                - idx: an index variable, for indexing the sub-structure items
+                       inside the loop. This variable must be declared separately
+                       in the beginning of the routine.
+                - cnt: the number of times to repeat the loop. This number should
+                       equal the number of items in the sub-structures array.
+
+                Note, that the body of the loop must be written inside brackets.
+*//***************************************************************************/
+#define DUMP_SUBSTRUCT_ARRAY(idx, cnt) \
+    for (idx=0, dumpIsArr[dumpLevel++] = 1; \
+         (idx < cnt) && sprintf(dumpIdxStr[dumpLevel-1], "[%d]", idx); \
+         idx++, ((idx < cnt) || ((dumpIsArr[--dumpLevel] = 0) == 0)))
+
+
+/**************************************************************************//**
+ @Description   Dumps a structure's member variable.
+
+                The input for this macro is the full reference for the member
+                variable, where the structure is referenced using a pointer.
+
+                Note, that a members array must be dumped using DUMP_ARR macro,
+                rather than using this macro.
+
+                If the member variable is part of a sub-structure hierarchy,
+                the full hierarchy (including array indexing) must be specified.
+
+                Examples:   p_Struct->member
+                            p_Struct->sub.member
+                            p_Struct->sub[i].member
+*//***************************************************************************/
+#define DUMP_VAR(st, phrase) \
+    do { \
+        _CREATE_DUMP_SUBSTR(phrase); \
+        dumpVarSize = sizeof((st)->phrase); \
+        switch (dumpVarSize) \
+        { \
+            case 1:  DUMP_Print("0x%08X: 0x%02x%14s\t%s\r\n", \
+                                &((st)->phrase), GET_UINT8((st)->phrase), "", dumpSubStr); break; \
+            case 2:  DUMP_Print("0x%08X: 0x%04x%12s\t%s\r\n", \
+                                &((st)->phrase), GET_UINT16((st)->phrase), "", dumpSubStr); break; \
+            case 4:  DUMP_Print("0x%08X: 0x%08x%8s\t%s\r\n", \
+                                &((st)->phrase), GET_UINT32((st)->phrase), "", dumpSubStr); break; \
+            case 8:  DUMP_Print("0x%08X: 0x%016llx\t%s\r\n", \
+                                &((st)->phrase), GET_UINT64((st)->phrase), dumpSubStr); break; \
+            default: DUMP_Print("Bad size %d (" #st "->" #phrase ")\r\n", dumpVarSize); \
+        } \
+    } while (0)
+
+
+/**************************************************************************//**
+ @Description   Dumps a structure's members array.
+
+                The input for this macro is the full reference for the members
+                array, where the structure is referenced using a pointer.
+
+                If the members array is part of a sub-structure hierarchy,
+                the full hierarchy (including array indexing) must be specified.
+
+                Examples:   p_Struct->array
+                            p_Struct->sub.array
+                            p_Struct->sub[i].array
+*//***************************************************************************/
+#define DUMP_ARR(st, phrase) \
+    do { \
+        _CREATE_DUMP_SUBSTR(phrase); \
+        dumpArrSize = ARRAY_SIZE((st)->phrase); \
+        dumpVarSize = sizeof((st)->phrase[0]); \
+        switch (dumpVarSize) \
+        { \
+            case 1: \
+                for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
+                    DUMP_Print("0x%08X: 0x%02x%14s\t%s[%d]\r\n", \
+                               &((st)->phrase[dumpArrIdx]), GET_UINT8((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
+                } break; \
+            case 2: \
+                for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
+                    DUMP_Print("0x%08X: 0x%04x%12s\t%s[%d]\r\n", \
+                               &((st)->phrase[dumpArrIdx]), GET_UINT16((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
+                } break; \
+            case 4: \
+                for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
+                    DUMP_Print("0x%08X: 0x%08x%8s\t%s[%d]\r\n", \
+                               &((st)->phrase[dumpArrIdx]), GET_UINT32((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
+                } break; \
+            case 8: \
+                for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
+                    DUMP_Print("0x%08X: 0x%016llx\t%s[%d]\r\n", \
+                               &((st)->phrase[dumpArrIdx]), GET_UINT64((st)->phrase[dumpArrIdx]), dumpSubStr, dumpArrIdx); \
+                } break; \
+            default: DUMP_Print("Bad size %d (" #st "->" #phrase "[0])\r\n", dumpVarSize); \
+        } \
+    } while (0)
+
+
+#endif /* DEBUG_ERRORS > 0 */
+
+
+/** @} */ /* end of dump_id group */
+/** @} */ /* end of gen_id group */
+
+
+#endif /* __DEBUG_EXT_H */
+
diff --git a/drivers/net/dpa/NetCommSw/inc/endian_ext.h b/drivers/net/dpa/NetCommSw/inc/endian_ext.h
new file mode 100644
index 0000000..37aa966
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/endian_ext.h
@@ -0,0 +1,458 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+
+ @File          endian_ext.h
+
+ @Description   Big/little endian swapping routines.
+*//***************************************************************************/
+
+#ifndef __ENDIAN_EXT_H
+#define __ENDIAN_EXT_H
+
+#include "std_ext.h"
+
+
+/**************************************************************************//**
+ @Group         gen_id  General Drivers Utilities
+
+ @Description   General usage API. This API is intended for usage by both the
+                internal modules and the user's application.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         endian_id Big/Little-Endian Conversion
+
+ @Description   Routines and macros for Big/Little-Endian conversion and
+                general byte swapping.
+
+                All routines and macros are expecting unsigned values as
+                parameters, but will generate the correct result also for
+                signed values. Therefore, signed/unsigned casting is allowed.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Collection    Byte-Swap Macros
+
+                Macros for swapping byte order.
+
+ @Cautions      The parameters of these macros are evaluated multiple times.
+                For calculated expressions or expressions that contain function
+                calls it is recommended to use the byte-swap routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Swaps the byte order of a given 16-bit value.
+
+ @Param[in]     val - The 16-bit value to swap.
+
+ @Return        The byte-swapped value..
+
+ @Cautions      The given value is evaluated multiple times by this macro.
+                For calculated expressions or expressions that contain function
+                calls it is recommended to use the SwapUint16() routine.
+
+ @hideinitializer
+*//***************************************************************************/
+#define SWAP_UINT16(val) \
+    ((uint16_t)((((val) & 0x00FF) << 8) | (((val) & 0xFF00) >> 8)))
+
+/**************************************************************************//**
+ @Description   Swaps the byte order of a given 32-bit value.
+
+ @Param[in]     val - The 32-bit value to swap.
+
+ @Return        The byte-swapped value..
+
+ @Cautions      The given value is evaluated multiple times by this macro.
+                For calculated expressions or expressions that contain function
+                calls it is recommended to use the SwapUint32() routine.
+
+ @hideinitializer
+*//***************************************************************************/
+#define SWAP_UINT32(val) \
+    ((uint32_t)((((val) & 0x000000FF) << 24) | \
+                (((val) & 0x0000FF00) <<  8) | \
+                (((val) & 0x00FF0000) >>  8) | \
+                (((val) & 0xFF000000) >> 24)))
+
+/**************************************************************************//**
+ @Description   Swaps the byte order of a given 64-bit value.
+
+ @Param[in]     val - The 64-bit value to swap.
+
+ @Return        The byte-swapped value..
+
+ @Cautions      The given value is evaluated multiple times by this macro.
+                For calculated expressions or expressions that contain function
+                calls it is recommended to use the SwapUint64() routine.
+
+ @hideinitializer
+*//***************************************************************************/
+#define SWAP_UINT64(val) \
+    ((uint64_t)((((val) & 0x00000000000000FFULL) << 56) | \
+                (((val) & 0x000000000000FF00ULL) << 40) | \
+                (((val) & 0x0000000000FF0000ULL) << 24) | \
+                (((val) & 0x00000000FF000000ULL) <<  8) | \
+                (((val) & 0x000000FF00000000ULL) >>  8) | \
+                (((val) & 0x0000FF0000000000ULL) >> 24) | \
+                (((val) & 0x00FF000000000000ULL) >> 40) | \
+                (((val) & 0xFF00000000000000ULL) >> 56)))
+
+/* @} */
+
+/**************************************************************************//**
+ @Collection    Byte-Swap Routines
+
+                Routines for swapping the byte order of a given parameter and
+                returning the swapped value.
+
+                These inline routines are safer than the byte-swap macros,
+                because they evaluate the parameter expression only once.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      SwapUint16
+
+ @Description   Returns the byte-swapped value of a given 16-bit value.
+
+ @Param[in]     val - The 16-bit value.
+
+ @Return        The byte-swapped value of the parameter.
+*//***************************************************************************/
+static __inline__ uint16_t SwapUint16(uint16_t val)
+{
+    return (uint16_t)(((val & 0x00FF) << 8) |
+                      ((val & 0xFF00) >> 8));
+}
+
+/**************************************************************************//**
+ @Function      SwapUint32
+
+ @Description   Returns the byte-swapped value of a given 32-bit value.
+
+ @Param[in]     val - The 32-bit value.
+
+ @Return        The byte-swapped value of the parameter.
+*//***************************************************************************/
+static __inline__ uint32_t SwapUint32(uint32_t val)
+{
+    return (uint32_t)(((val & 0x000000FF) << 24) |
+                      ((val & 0x0000FF00) <<  8) |
+                      ((val & 0x00FF0000) >>  8) |
+                      ((val & 0xFF000000) >> 24));
+}
+
+/**************************************************************************//**
+ @Function      SwapUint64
+
+ @Description   Returns the byte-swapped value of a given 64-bit value.
+
+ @Param[in]     val - The 64-bit value.
+
+ @Return        The byte-swapped value of the parameter.
+*//***************************************************************************/
+static __inline__ uint64_t SwapUint64(uint64_t val)
+{
+    return (uint64_t)(((val & 0x00000000000000FFULL) << 56) |
+                      ((val & 0x000000000000FF00ULL) << 40) |
+                      ((val & 0x0000000000FF0000ULL) << 24) |
+                      ((val & 0x00000000FF000000ULL) <<  8) |
+                      ((val & 0x000000FF00000000ULL) >>  8) |
+                      ((val & 0x0000FF0000000000ULL) >> 24) |
+                      ((val & 0x00FF000000000000ULL) >> 40) |
+                      ((val & 0xFF00000000000000ULL) >> 56));
+}
+
+/* @} */
+
+/**************************************************************************//**
+ @Collection    In-place Byte-Swap-And-Set Routines
+
+                Routines for swapping the byte order of a given variable and
+                setting the swapped value back to the same variable.
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      SwapUint16P
+
+ @Description   Swaps the byte order of a given 16-bit variable.
+
+ @Param[in]     p_Val - Pointer to the 16-bit variable.
+
+ @Return        None.
+*//***************************************************************************/
+static __inline__ void SwapUint16P(uint16_t *p_Val)
+{
+    *p_Val = SwapUint16(*p_Val);
+}
+
+/**************************************************************************//**
+ @Function      SwapUint32P
+
+ @Description   Swaps the byte order of a given 32-bit variable.
+
+ @Param[in]     p_Val - Pointer to the 32-bit variable.
+
+ @Return        None.
+*//***************************************************************************/
+static __inline__ void SwapUint32P(uint32_t *p_Val)
+{
+    *p_Val = SwapUint32(*p_Val);
+}
+
+/**************************************************************************//**
+ @Function      SwapUint64P
+
+ @Description   Swaps the byte order of a given 64-bit variable.
+
+ @Param[in]     p_Val - Pointer to the 64-bit variable.
+
+ @Return        None.
+*//***************************************************************************/
+static __inline__ void SwapUint64P(uint64_t *p_Val)
+{
+    *p_Val = SwapUint64(*p_Val);
+}
+
+/* @} */
+
+
+/**************************************************************************//**
+ @Collection    Little-Endian Conversion Macros
+
+                These macros convert given parameters to or from Little-Endian
+                format. Use these macros when you want to read or write a specific
+                Little-Endian value in memory, without a-priori knowing the CPU
+                byte order.
+
+                These macros use the byte-swap routines. For conversion of
+                constants in initialization structures, you may use the CONST
+                versions of these macros (see below), which are using the
+                byte-swap macros instead.
+ @{
+*//***************************************************************************/
+
+#ifndef VERILOG
+/**************************************************************************//**
+ @Description   Converts a given 16-bit value from CPU byte order to
+                Little-Endian byte order.
+
+ @Param[in]     val - The 16-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CPU_TO_LE16(val)        SwapUint16(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 32-bit value from CPU byte order to
+                Little-Endian byte order.
+
+ @Param[in]     val - The 32-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CPU_TO_LE32(val)        SwapUint32(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 64-bit value from CPU byte order to
+                Little-Endian byte order.
+
+ @Param[in]     val - The 64-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CPU_TO_LE64(val)        SwapUint64(val)
+
+#else  /* VERILOG */
+#define CPU_TO_LE16(val)        (val)
+#define CPU_TO_LE32(val)        (val)
+#define CPU_TO_LE64(val)        (val)
+#endif /* VERILOG */
+
+/**************************************************************************//**
+ @Description   Converts a given 16-bit value from Little-Endian byte order to
+                CPU byte order.
+
+ @Param[in]     val - The 16-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define LE16_TO_CPU(val)        CPU_TO_LE16(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 32-bit value from Little-Endian byte order to
+                CPU byte order.
+
+ @Param[in]     val - The 32-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define LE32_TO_CPU(val)        CPU_TO_LE32(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 64-bit value from Little-Endian byte order to
+                CPU byte order.
+
+ @Param[in]     val - The 64-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define LE64_TO_CPU(val)        CPU_TO_LE64(val)
+
+/* @} */
+
+/**************************************************************************//**
+ @Collection    Little-Endian Constant Conversion Macros
+
+                These macros convert given constants to or from Little-Endian
+                format. Use these macros when you want to read or write a specific
+                Little-Endian constant in memory, without a-priori knowing the
+                CPU byte order.
+
+                These macros use the byte-swap macros, therefore can be used for
+                conversion of constants in initialization structures.
+
+ @Cautions      The parameters of these macros are evaluated multiple times.
+                For non-constant expressions, use the non-CONST macro versions.
+
+ @{
+*//***************************************************************************/
+
+#ifndef VERILOG
+/**************************************************************************//**
+ @Description   Converts a given 16-bit constant from CPU byte order to
+                Little-Endian byte order.
+
+ @Param[in]     val - The 16-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CONST_CPU_TO_LE16(val)  SWAP_UINT16(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 32-bit constant from CPU byte order to
+                Little-Endian byte order.
+
+ @Param[in]     val - The 32-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CONST_CPU_TO_LE32(val)  SWAP_UINT32(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 64-bit constant from CPU byte order to
+                Little-Endian byte order.
+
+ @Param[in]     val - The 64-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CONST_CPU_TO_LE64(val)  SWAP_UINT64(val)
+
+#else  /* VERILOG */
+#define CONST_CPU_TO_LE16(val)  (val)
+#define CONST_CPU_TO_LE32(val)  (val)
+#define CONST_CPU_TO_LE64(val)  (val)
+#endif /* VERILOG */
+
+/**************************************************************************//**
+ @Description   Converts a given 16-bit constant from Little-Endian byte order
+                to CPU byte order.
+
+ @Param[in]     val - The 16-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CONST_LE16_TO_CPU(val)  CONST_CPU_TO_LE16(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 32-bit constant from Little-Endian byte order
+                to CPU byte order.
+
+ @Param[in]     val - The 32-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CONST_LE32_TO_CPU(val)  CONST_CPU_TO_LE32(val)
+
+/**************************************************************************//**
+ @Description   Converts a given 64-bit constant from Little-Endian byte order
+                to CPU byte order.
+
+ @Param[in]     val - The 64-bit value to convert.
+
+ @Return        The converted value.
+
+ @hideinitializer
+*//***************************************************************************/
+#define CONST_LE64_TO_CPU(val)  CONST_CPU_TO_LE64(val)
+
+/* @} */
+
+
+/** @} */ /* end of endian_id group */
+/** @} */ /* end of gen_id group */
+
+
+#endif /* __ENDIAN_EXT_H */
+
diff --git a/drivers/net/dpa/NetCommSw/inc/enet_ext.h b/drivers/net/dpa/NetCommSw/inc/enet_ext.h
new file mode 100644
index 0000000..2ba5bf3
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/enet_ext.h
@@ -0,0 +1,151 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          enet_ext.h
+
+ @Description   Ethernet generic definitions and enums.
+*//***************************************************************************/
+
+#ifndef __ENET_EXT_H
+#define __ENET_EXT_H
+
+
+#define ENET_NUM_OCTETS_PER_ADDRESS 6     /**< Number of octets (8-bit bytes) in an ethernet address */
+#define ENET_GROUP_ADDR             0x01  /**< Group address mask for ethernet addresses */
+
+
+/**************************************************************************//**
+ @Description   Ethernet Address
+*//***************************************************************************/
+typedef uint8_t t_EnetAddr[ENET_NUM_OCTETS_PER_ADDRESS];
+
+/**************************************************************************//**
+ @Description   Ethernet Address Type.
+*//***************************************************************************/
+typedef enum e_EnetAddrType
+{
+    e_ENET_ADDR_TYPE_INDIVIDUAL,    /**< Individual (unicast) address */
+    e_ENET_ADDR_TYPE_GROUP,         /**< Group (multicast) address */
+    e_ENET_ADDR_TYPE_BROADCAST      /**< Broadcast address */
+} e_EnetAddrType;
+
+
+/**************************************************************************//**
+ @Description   Ethernet MAC-PHY Interface
+*//***************************************************************************/
+typedef enum e_EnetInterface
+{
+    e_ENET_IF_MII   = 0x00010000,   /**< MII interface */
+    e_ENET_IF_RMII  = 0x00020000,   /**< RMII interface */
+    e_ENET_IF_SMII  = 0x00030000,   /**< SMII interface */
+    e_ENET_IF_GMII  = 0x00040000,   /**< GMII interface */
+    e_ENET_IF_RGMII = 0x00050000,   /**< RGMII interface */
+    e_ENET_IF_TBI   = 0x00060000,   /**< TBI interface */
+    e_ENET_IF_RTBI  = 0x00070000,   /**< RTBI interface */
+    e_ENET_IF_SGMII = 0x00080000,   /**< SGMII interface */
+    e_ENET_IF_XGMII = 0x00090000    /**< XGMII interface */
+} e_EnetInterface;
+
+/**************************************************************************//**
+ @Description   Ethernet Duplex Mode
+*//***************************************************************************/
+typedef enum e_EnetDuplexMode
+{
+    e_ENET_HALF_DUPLEX,             /**< Half-Duplex mode */
+    e_ENET_FULL_DUPLEX              /**< Full-Duplex mode */
+} e_EnetDuplexMode;
+
+/**************************************************************************//**
+ @Description   Ethernet Speed (nominal data rate)
+*//***************************************************************************/
+typedef enum e_EnetSpeed
+{
+    e_ENET_SPEED_10     = 10,       /**< 10 Mbps */
+    e_ENET_SPEED_100    = 100,      /**< 100 Mbps */
+    e_ENET_SPEED_1000   = 1000,     /**< 1000 Mbps = 1 Gbps */
+    e_ENET_SPEED_10000  = 10000     /**< 10000 Mbps = 10 Gbps */
+} e_EnetSpeed;
+
+/**************************************************************************//**
+ @Description   Ethernet mode (combination of MAC-PHY interface and speed)
+*//***************************************************************************/
+typedef enum e_EnetMode
+{
+    e_ENET_MODE_INVALID     = 0,                                        /**< Invalid Ethernet mode */
+    e_ENET_MODE_MII_10      = (e_ENET_IF_MII   | e_ENET_SPEED_10),      /**<    10 Mbps MII   */
+    e_ENET_MODE_MII_100     = (e_ENET_IF_MII   | e_ENET_SPEED_100),     /**<   100 Mbps MII   */
+    e_ENET_MODE_RMII_10     = (e_ENET_IF_RMII  | e_ENET_SPEED_10),      /**<    10 Mbps RMII  */
+    e_ENET_MODE_RMII_100    = (e_ENET_IF_RMII  | e_ENET_SPEED_100),     /**<   100 Mbps RMII  */
+    e_ENET_MODE_SMII_10     = (e_ENET_IF_SMII  | e_ENET_SPEED_10),      /**<    10 Mbps SMII  */
+    e_ENET_MODE_SMII_100    = (e_ENET_IF_SMII  | e_ENET_SPEED_100),     /**<   100 Mbps SMII  */
+    e_ENET_MODE_GMII_1000   = (e_ENET_IF_GMII  | e_ENET_SPEED_1000),    /**<  1000 Mbps GMII  */
+    e_ENET_MODE_RGMII_10    = (e_ENET_IF_RGMII | e_ENET_SPEED_10),      /**<    10 Mbps RGMII */
+    e_ENET_MODE_RGMII_100   = (e_ENET_IF_RGMII | e_ENET_SPEED_100),     /**<   100 Mbps RGMII */
+    e_ENET_MODE_RGMII_1000  = (e_ENET_IF_RGMII | e_ENET_SPEED_1000),    /**<  1000 Mbps RGMII */
+    e_ENET_MODE_TBI_1000    = (e_ENET_IF_TBI   | e_ENET_SPEED_1000),    /**<  1000 Mbps TBI   */
+    e_ENET_MODE_RTBI_1000   = (e_ENET_IF_RTBI  | e_ENET_SPEED_1000),    /**<  1000 Mbps RTBI  */
+    e_ENET_MODE_SGMII_10    = (e_ENET_IF_SGMII | e_ENET_SPEED_10),      /**<    10 Mbps SGMII */
+    e_ENET_MODE_SGMII_100   = (e_ENET_IF_SGMII | e_ENET_SPEED_100),     /**<   100 Mbps SGMII */
+    e_ENET_MODE_SGMII_1000  = (e_ENET_IF_SGMII | e_ENET_SPEED_1000),    /**<  1000 Mbps SGMII */
+    e_ENET_MODE_XGMII_10000 = (e_ENET_IF_XGMII | e_ENET_SPEED_10000)    /**< 10000 Mbps XGMII */
+} e_EnetMode;
+
+
+#define IS_ENET_MODE_VALID(mode) \
+        (((mode) == e_ENET_MODE_MII_10     ) || \
+         ((mode) == e_ENET_MODE_MII_100    ) || \
+         ((mode) == e_ENET_MODE_RMII_10    ) || \
+         ((mode) == e_ENET_MODE_RMII_100   ) || \
+         ((mode) == e_ENET_MODE_SMII_10    ) || \
+         ((mode) == e_ENET_MODE_SMII_100   ) || \
+         ((mode) == e_ENET_MODE_GMII_1000  ) || \
+         ((mode) == e_ENET_MODE_RGMII_10   ) || \
+         ((mode) == e_ENET_MODE_RGMII_100  ) || \
+         ((mode) == e_ENET_MODE_RGMII_1000 ) || \
+         ((mode) == e_ENET_MODE_TBI_1000   ) || \
+         ((mode) == e_ENET_MODE_RTBI_1000  ) || \
+         ((mode) == e_ENET_MODE_SGMII_10   ) || \
+         ((mode) == e_ENET_MODE_SGMII_100  ) || \
+         ((mode) == e_ENET_MODE_SGMII_1000 ) || \
+         ((mode) == e_ENET_MODE_XGMII_10000))
+
+
+#define MAKE_ENET_MODE(_interface, _speed)     (e_EnetMode)((_interface) | (_speed))
+
+#define ENET_INTERFACE_FROM_MODE(mode)          (e_EnetInterface)((mode) & 0xFFFF0000)
+#define ENET_SPEED_FROM_MODE(mode)              (e_EnetSpeed)((mode) & 0x0000FFFF)
+
+
+
+#endif /* __ENET_EXT_H */
+
diff --git a/drivers/net/dpa/NetCommSw/inc/error_ext.h b/drivers/net/dpa/NetCommSw/inc/error_ext.h
new file mode 100644
index 0000000..dc739d5
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/error_ext.h
@@ -0,0 +1,538 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ @File          error_ext.h
+
+ @Description   Error definitions.
+*//***************************************************************************/
+
+#ifndef __ERROR_EXT_H
+#define __ERROR_EXT_H
+
+#include "std_ext.h"
+#include "xx_ext.h"
+
+#ifdef VC
+#define __FUNCTION__    ""
+#endif
+
+
+
+/**************************************************************************//**
+ @Group         gen_id  General Drivers Utilities
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         gen_error_id  Errors, Events and Debug
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/******************************************************************************
+The scheme below provides the bits description for error codes:
+
+ 0    1    2    3    4    5    6    7    8    9    10   11   12   13   14   15
+|       Reserved (should be zero)      |              Module ID               |
+
+ 16   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31
+|                               Error Type                                    |
+******************************************************************************/
+
+#define ERROR_CODE(_err)            ((((uint32_t)_err) & 0x0000FFFF) | __ERR_MODULE__)
+
+#define GET_ERROR_TYPE(_errcode)    ((_errcode) & 0x0000FFFF)
+                                /**< Extract module code from error code (#t_Error) */
+
+#define GET_ERROR_MODULE(_errcode)  ((_errcode) & 0x00FF0000)
+                                /**< Extract error type (#e_ErrorType) from
+                                     error code (#t_Error) */
+
+
+/**************************************************************************//**
+ @Description    Error Type Enumeration
+*//***************************************************************************/
+typedef enum e_ErrorType    /*   Comments / Associated Message Strings                      */
+{                           /* ------------------------------------------------------------ */
+    E_OK = 0                /*   Never use "RETURN_ERROR" with E_OK; Use "return E_OK;"     */
+
+    /* Invalid Function Calls */
+    ,E_INVALID_STATE        /**< The operation is not allowed in current module state.      */
+                            /*   String: none.                                              */
+    ,E_INVALID_OPERATION    /**< The operation/command is invalid (unrecognized).           */
+                            /*   String: none.                                              */
+    ,E_NOT_SUPPORTED        /**< The function is not supported or not implemented.          */
+                            /*   String: none.                                              */
+    ,E_NO_DEVICE            /**< The associated device is not initialized.                  */
+                            /*   String: none.                                              */
+
+    /* Invalid Parameters */
+    ,E_INVALID_HANDLE       /**< Invalid handle of module or object.                        */
+                            /*   String: none, unless the function takes in more than one
+                                 handle (in this case add the handle description)           */
+    ,E_INVALID_ID           /**< Invalid module ID (usually enumeration or index).          */
+                            /*   String: none, unless the function takes in more than one
+                                 ID (in this case add the ID description)                   */
+    ,E_NULL_POINTER         /**< Unexpected NULL pointer.                                   */
+                            /*   String: pointer description.                               */
+    ,E_INVALID_VALUE        /**< Invalid value.                                             */
+                            /*   Use for non-enumeration parameters, and
+                                 only when other error types are not suitable.
+                                 String: parameter description + "(should be <attribute>)",
+                                 e.g: "Maximum Rx buffer length (should be divisible by 8)",
+                                      "Channel number (should be even)".                    */
+    ,E_INVALID_SELECTION    /**< Invalid selection or mode.                                 */
+                            /*   Use for enumeration values, only when other error types
+                                 are not suitable.
+                                 String: parameter description.                             */
+    ,E_INVALID_COMM_MODE    /**< Invalid communication mode.                                */
+                            /*   String: none, unless the function takes in more than one
+                                 communication mode indications (in this case add
+                                 parameter description).                                    */
+    ,E_INVALID_BYTE_ORDER   /**< Invalid byte order.                                        */
+                            /*   String: none, unless the function takes in more than one
+                                 byte order indications (in this case add parameter
+                                 description).                                              */
+    ,E_INVALID_MEMORY_TYPE  /**< Invalid memory type.                                       */
+                            /*   String: none, unless the function takes in more than one
+                                 memory types (in this case add memory description,
+                                 e.g: "Data memory", "Buffer descriptors memory").          */
+    ,E_INVALID_INTR_QUEUE   /**< Invalid interrupt queue.                                   */
+                            /*   String: none, unless the function takes in more than one
+                                 interrupt queues (in this case add queue description,
+                                 e.g: "Rx interrupt queue", "Tx interrupt queue").          */
+    ,E_INVALID_PRIORITY     /**< Invalid priority.                                          */
+                            /*   String: none, unless the function takes in more than one
+                                 priority (in this case add priority description).          */
+    ,E_INVALID_CLOCK        /**< Invalid clock.                                             */
+                            /*   String: none, unless the function takes in more than one
+                                 clocks (in this case add clock description,
+                                 e.g: "Rx clock", "Tx clock").                              */
+    ,E_INVALID_RATE         /**< Invalid rate value.                                        */
+                            /*   String: none, unless the function takes in more than one
+                                 rate values (in this case add rate description).           */
+    ,E_INVALID_ADDRESS      /**< Invalid address.                                           */
+                            /*   String: description of the specific violation.             */
+    ,E_INVALID_BUS          /**< Invalid bus type.                                          */
+                            /*   String: none, unless the function takes in more than one
+                                 bus parameters (in this case add bus description).         */
+    ,E_BUS_CONFLICT         /**< Bus (or memory) type conflicts with another setting.       */
+                            /*   String: description of the conflicting buses/memories.     */
+    ,E_CONFLICT             /**< Some setting conflicts with another setting.               */
+                            /*   String: description of the conflicting settings.           */
+    ,E_NOT_ALIGNED          /**< Non-aligned address.                                       */
+                            /*   String: parameter description + "(should be %d-bytes aligned)",
+                                 e.g: "Rx data buffer (should be 32-bytes aligned)".        */
+    ,E_NOT_IN_RANGE         /**< Parameter value is out of range.                           */
+                            /*   Don't use this error for enumeration parameters.
+                                 String: parameter description + "(should be %d-%d)",
+                                 e.g: "Number of pad characters (should be 0-15)".          */
+
+    /* Frame/Buffer Errors */
+    ,E_INVALID_FRAME        /**< Invalid frame object (NULL handle or missing buffers).     */
+                            /*   String: none.                                              */
+    ,E_EMPTY_FRAME          /**< Frame object is empty (has no buffers).                    */
+                            /*   String: none.                                              */
+    ,E_EMPTY_BUFFER         /**< Buffer object is empty (no data, or zero data length).     */
+                            /*   String: none.                                              */
+
+    /* Resource Errors */
+    ,E_NO_MEMORY            /**< External memory allocation failed.                         */
+                            /*   String: description of item for which allocation failed.   */
+    ,E_NOT_FOUND            /**< Requested resource or item was not found.                  */
+                            /*   Use only when the resource/item is uniquely identified.
+                                 String: none, unless the operation is not the main goal
+                                 of the function (in this case add item description).       */
+    ,E_NOT_AVAILABLE        /**< Resource is unavailable.                                   */
+                            /*   String: none, unless the operation is not the main goal
+                                 of the function (in this case add resource description).   */
+    ,E_ALREADY_EXISTS       /**< Requested resource or item already exists.                 */
+                            /*   Use when resource duplication or sharing are not allowed.
+                                 String: none, unless the operation is not the main goal
+                                 of the function (in this case add item description).       */
+    ,E_FULL                 /**< Resource is full.                                          */
+                            /*   String: none, unless the operation is not the main goal
+                                 of the function (in this case add resource description).   */
+    ,E_EMPTY                /**< Resource is empty.                                         */
+                            /*   String: none, unless the operation is not the main goal
+                                 of the function (in this case add resource description).   */
+    ,E_BUSY                 /**< Resource or module is busy.                                */
+                            /*   String: none, unless the operation is not the main goal
+                                 of the function (in this case add resource description).   */
+    ,E_ALREADY_FREE         /**< Specified resource or item is already free or deleted.     */
+                            /*   String: none, unless the operation is not the main goal
+                                 of the function (in this case add item description).       */
+
+    /* Read/Write Access Errors */
+    ,E_READ_FAILED          /**< Read access failed on memory/device.                       */
+                            /*   String: none, or device name.                              */
+    ,E_WRITE_FAILED         /**< Write access failed on memory/device.                      */
+                            /*   String: none, or device name.                              */
+
+    /* Send/Receive Failures */
+    ,E_SEND_FAILED          /**< Send operation failed on device.                           */
+                            /*   String: none, or device name.                              */
+    ,E_RECEIVE_FAILED       /**< Receive operation failed on device.                        */
+                            /*   String: none, or device name.                              */
+
+    /* Operation time-out */
+    ,E_TIMEOUT              /**< The operation timed out.                                   */
+                            /*   String: none.                                              */
+
+    ,E_DUMMY_LAST           /* NEVER USED */
+
+} e_ErrorType;
+
+
+/**************************************************************************//**
+ @Description    Event Type Enumeration
+*//***************************************************************************/
+typedef enum e_Event        /*   Comments / Associated Flags and Message Strings            */
+{                           /* ------------------------------------------------------------ */
+    EV_NO_EVENT = 0         /**< No event; Never used.                                      */
+
+    ,EV_RX_DISCARD          /**< Received packet discarded (by the driver, and only for
+                                 complete packets);
+                                 Flags: error flags in case of error, zero otherwise.       */
+                            /*   String: reason for discard, e.g: "Error in frame",
+                                 "Disordered frame", "Incomplete frame", "No frame object". */
+    ,EV_RX_ERROR            /**< Receive error (by hardware/firmware);
+                                 Flags: usually status flags from the buffer descriptor.    */
+                            /*   String: none.                                              */
+    ,EV_TX_ERROR            /**< Transmit error (by hardware/firmware);
+                                 Flags: usually status flags from the buffer descriptor.    */
+                            /*   String: none.                                              */
+    ,EV_NO_BUFFERS          /**< System ran out of buffer objects;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_NO_MB_FRAMES        /**< System ran out of multi-buffer frame objects;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_NO_SB_FRAMES        /**< System ran out of single-buffer frame objects;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_TX_QUEUE_FULL       /**< Transmit queue is full;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_RX_QUEUE_FULL       /**< Receive queue is full;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_INTR_QUEUE_FULL     /**< Interrupt queue overflow;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_NO_DATA_BUFFER      /**< Data buffer allocation (from higher layer) failed;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_OBJ_POOL_EMPTY      /**< Objects pool is empty;
+                                 Flags: zero.                                               */
+                            /*   String: object description (name).                         */
+    ,EV_BUS_ERROR           /**< Illegal access on bus;
+                                 Flags: the address (if available) or bus identifier        */
+                            /*   String: bus/address/module description.                    */
+    ,EV_PTP_TXTS_QUEUE_FULL /**< PTP Tx timestamps queue is full;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_PTP_RXTS_QUEUE_FULL /**< PTP Rx timestamps queue is full;
+                                 Flags: zero.                                               */
+                            /*   String: none.                                              */
+    ,EV_DUMMY_LAST
+
+} e_Event;
+
+
+/**************************************************************************//**
+ @Collection    Debug Levels for Errors and Events
+
+                The level description refers to errors only.
+                For events, classification is done by the user.
+
+                The TRACE, INFO and WARNING levels are allowed only when using
+                the DBG macro, and are not allowed when using the error macros
+                (RETURN_ERROR or REPORT_ERROR).
+ @{
+*//***************************************************************************/
+#define REPORT_LEVEL_CRITICAL   1       /**< Crasher: Incorrect flow, NULL pointers/handles. */
+#define REPORT_LEVEL_MAJOR      2       /**< Cannot proceed: Invalid operation, parameters or
+                                             configuration. */
+#define REPORT_LEVEL_MINOR      3       /**< Recoverable problem: a repeating call with the same
+                                             parameters may be successful. */
+#define REPORT_LEVEL_WARNING    4       /**< Something is not exactly right, yet it is not an error. */
+#define REPORT_LEVEL_INFO       5       /**< Messages which may be of interest to user/programmer. */
+#define REPORT_LEVEL_TRACE      6       /**< Program flow messages. */
+
+#define EVENT_DISABLED          0xFF    /**< Disabled event (not reported at all) */
+
+/* @} */
+
+
+
+#define NO_MSG      ("")
+
+#ifndef EVENT_GLOBAL_LEVEL
+#define EVENT_GLOBAL_LEVEL  REPORT_LEVEL_MINOR
+#endif
+
+#ifdef EVENT_LOCAL_LEVEL
+#define EVENT_DYNAMIC_LEVEL EVENT_LOCAL_LEVEL
+#else
+#define EVENT_DYNAMIC_LEVEL EVENT_GLOBAL_LEVEL
+#endif
+
+
+#ifndef DEBUG_GLOBAL_LEVEL
+#define DEBUG_GLOBAL_LEVEL  REPORT_LEVEL_WARNING
+#endif
+
+#ifndef DEBUG_DYNAMIC_LEVEL
+
+#define DEBUG_USING_STATIC_LEVEL
+
+#ifdef DEBUG_STATIC_LEVEL
+#define DEBUG_DYNAMIC_LEVEL DEBUG_STATIC_LEVEL
+#else
+#define DEBUG_DYNAMIC_LEVEL DEBUG_GLOBAL_LEVEL
+#endif
+
+#else /* DEBUG_DYNAMIC_LEVEL */
+
+#ifdef DEBUG_STATIC_LEVEL
+#error "Please use either DEBUG_STATIC_LEVEL or DEBUG_DYNAMIC_LEVEL (not both)"
+#else
+int DEBUG_DYNAMIC_LEVEL = DEBUG_GLOBAL_LEVEL;
+#endif /* DEBUG_STATIC_LEVEL */
+
+#endif /* DEBUG_DYNAMIC_LEVEL */
+
+
+#if (!(defined(DEBUG_ERRORS)) || (DEBUG_ERRORS == 0))
+/* No debug/error/event messages at all */
+#define DBG(_level, _vmsg)
+
+#define REPORT_ERROR(_level, _err, _vmsg)
+
+#define RETURN_ERROR(_level, _err, _vmsg) \
+        return ERROR_CODE(_err)
+
+#if (REPORT_EVENTS > 0)
+
+#define REPORT_EVENT(_ev, _appId, _flg, _vmsg) \
+    do { \
+        if (_ev##_LEVEL <= EVENT_DYNAMIC_LEVEL) { \
+            XX_EventById((uint32_t)(_ev), (t_Handle)(_appId), (uint16_t)(_flg), NO_MSG); \
+        } \
+    } while (0)
+
+#else
+
+#define REPORT_EVENT(_ev, _appId, _flg, _vmsg)
+
+#endif /* (REPORT_EVENTS > 0) */
+
+
+#else /* DEBUG_ERRORS > 0 */
+
+extern const char *dbgLevelStrings[];
+extern const char *errTypeStrings[];
+extern const char *moduleStrings[];
+#if (REPORT_EVENTS > 0)
+extern const char *eventStrings[];
+#endif /* (REPORT_EVENTS > 0) */
+
+
+#if ((defined(DEBUG_USING_STATIC_LEVEL)) && (DEBUG_DYNAMIC_LEVEL < REPORT_LEVEL_WARNING))
+/* No need for DBG macro - debug level is higher anyway */
+#define DBG(_level, _vmsg)
+#else
+#define DBG(_level, _vmsg) \
+    do { \
+        if (REPORT_LEVEL_##_level <= DEBUG_DYNAMIC_LEVEL) { \
+            XX_Print("> %s (%s) [%s:%d %s]: ", \
+                     dbgLevelStrings[REPORT_LEVEL_##_level - 1], \
+                     moduleStrings[__ERR_MODULE__ >> 16], \
+                     __FILE__, __LINE__, __FUNCTION__); \
+            XX_Print _vmsg; \
+            XX_Print("\r\n"); \
+        } \
+    } while (0)
+#endif /* (defined(DEBUG_USING_STATIC_LEVEL) && (DEBUG_DYNAMIC_LEVEL < WARNING)) */
+
+
+#define REPORT_ERROR(_level, _err, _vmsg) \
+    do { \
+        if (REPORT_LEVEL_##_level <= DEBUG_DYNAMIC_LEVEL) { \
+            XX_Print("! %s %s Error [%s:%d %s]: %s; ", \
+                     dbgLevelStrings[REPORT_LEVEL_##_level - 1], \
+                     moduleStrings[__ERR_MODULE__ >> 16], \
+                     __FILE__, __LINE__, __FUNCTION__, \
+                     errTypeStrings[(GET_ERROR_TYPE(_err) - E_OK - 1)]); \
+            XX_Print _vmsg; \
+            XX_Print("\r\n"); \
+        } \
+    } while (0)
+
+
+#define RETURN_ERROR(_level, _err, _vmsg) \
+    do { \
+        REPORT_ERROR(_level, (_err), _vmsg); \
+        return ERROR_CODE(_err); \
+    } while (0)
+
+
+#if (REPORT_EVENTS > 0)
+
+#define REPORT_EVENT(_ev, _appId, _flg, _vmsg) \
+    do { \
+        if (_ev##_LEVEL <= EVENT_DYNAMIC_LEVEL) { \
+            XX_Print("~ %s %s Event [%s:%d %s]: %s (flags: 0x%04x); ", \
+                     dbgLevelStrings[_ev##_LEVEL - 1], \
+                     moduleStrings[__ERR_MODULE__ >> 16], \
+                     __FILE__, __LINE__, __FUNCTION__, \
+                     eventStrings[((_ev) - EV_NO_EVENT - 1)], \
+                     (uint16_t)(_flg)); \
+            XX_Print _vmsg; \
+            XX_Print("\r\n"); \
+            XX_EventById((uint32_t)(_ev), (t_Handle)(_appId), (uint16_t)(_flg), NO_MSG); \
+        } \
+    } while (0)
+
+#else /* not REPORT_EVENTS */
+
+#define REPORT_EVENT(_ev, _appId, _flg, _vmsg)
+
+#endif /* (REPORT_EVENTS > 0) */
+
+#endif /* (DEBUG_ERRORS > 0) */
+
+
+/**************************************************************************//**
+ @Function      ASSERT_COND
+
+ @Description   Assertion macro.
+
+ @Param[in]     _cond - The condition being checked, in positive form;
+                        Failure of the condition triggers the assert.
+*//***************************************************************************/
+#ifdef DISABLE_ASSERTIONS
+#define ASSERT_COND(_cond)
+#else
+#define ASSERT_COND(_cond) \
+    do { \
+        if (!(_cond)) { \
+            XX_Print("*** ASSERT_COND failed [%s:%d %s]\r\n", \
+                     __FILE__, __LINE__, __FUNCTION__); \
+            XX_Exit(1); \
+        } \
+    } while (0)
+#endif /* DISABLE_ASSERTIONS */
+
+
+#ifdef DISABLE_INIT_PARAMETERS_CHECK
+
+#define CHECK_INIT_PARAMETERS(handle, f_check)
+#define CHECK_INIT_PARAMETERS_RETURN_VALUE(handle, f_check, retval)
+
+#else
+
+#define CHECK_INIT_PARAMETERS(handle, f_check) \
+    do { \
+        t_Error err = f_check(handle); \
+        if (err != E_OK) { \
+            RETURN_ERROR(MAJOR, err, NO_MSG); \
+        } \
+    } while (0)
+
+#define CHECK_INIT_PARAMETERS_RETURN_VALUE(handle, f_check, retval) \
+    do { \
+        t_Error err = f_check(handle); \
+        if (err != E_OK) { \
+            REPORT_ERROR(MAJOR, err, NO_MSG); \
+            return (retval); \
+        } \
+    } while (0)
+
+#endif /* DISABLE_INIT_PARAMETERS_CHECK */
+
+#ifdef DISABLE_SANITY_CHECKS
+
+#define SANITY_CHECK_RETURN_ERROR(_cond, _err)
+#define SANITY_CHECK_RETURN_VALUE(_cond, _err, retval)
+#define SANITY_CHECK_RETURN(_cond, _err)
+#define SANITY_CHECK_EXIT(_cond, _err)
+
+#else /* DISABLE_SANITY_CHECKS */
+
+#define SANITY_CHECK_RETURN_ERROR(_cond, _err) \
+    do { \
+        if (!(_cond)) { \
+            RETURN_ERROR(CRITICAL, (_err), NO_MSG); \
+        } \
+    } while (0)
+
+#define SANITY_CHECK_RETURN_VALUE(_cond, _err, retval) \
+    do { \
+        if (!(_cond)) { \
+            REPORT_ERROR(CRITICAL, (_err), NO_MSG); \
+            return (retval); \
+        } \
+    } while (0)
+
+#define SANITY_CHECK_RETURN(_cond, _err) \
+    do { \
+        if (!(_cond)) { \
+            REPORT_ERROR(CRITICAL, (_err), NO_MSG); \
+            return; \
+        } \
+    } while (0)
+
+#define SANITY_CHECK_EXIT(_cond, _err) \
+    do { \
+        if (!(_cond)) { \
+            REPORT_ERROR(CRITICAL, (_err), NO_MSG); \
+            XX_Exit(1); \
+        } \
+    } while (0)
+
+#endif /* DISABLE_SANITY_CHECKS */
+
+/** @} */ /* end of Debug/error Utils group */
+
+/** @} */ /* end of General Utils group */
+
+#endif /* __ERROR_EXT_H */
+
+
diff --git a/drivers/net/dpa/NetCommSw/inc/etc/list_ext.h b/drivers/net/dpa/NetCommSw/inc/etc/list_ext.h
new file mode 100644
index 0000000..5325ee1
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/etc/list_ext.h
@@ -0,0 +1,357 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+
+ @File          list_ext.h
+
+ @Description   External prototypes for list.c
+*//***************************************************************************/
+
+#ifndef __LIST_EXT_H
+#define __LIST_EXT_H
+
+
+#include "std_ext.h"
+
+
+/**************************************************************************//**
+ @Group         etc_id   Utility Library Application Programming Interface
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         list_id List
+
+ @Description   List module functions,definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   List structure.
+*//***************************************************************************/
+typedef struct List
+{
+    struct List *p_Next;  /**< A pointer to the next list object     */
+    struct List *p_Prev;  /**< A pointer to the previous list object */
+} t_List;
+
+
+/**************************************************************************//**
+ @Function      LIST_FIRST/LIST_LAST/LIST_NEXT/LIST_PREV
+
+ @Description   Macro to get first/last/next/previous entry in a list.
+
+ @Param[in]     p_List - A pointer to a list.
+*//***************************************************************************/
+#define LIST_FIRST(p_List) (p_List)->p_Next
+#define LIST_LAST(p_List)  (p_List)->p_Prev
+#define LIST_NEXT          LIST_FIRST
+#define LIST_PREV          LIST_LAST
+
+
+/**************************************************************************//**
+ @Function      LIST_INIT
+
+ @Description   Macro for initialization of a list struct.
+
+ @Param[in]     lst - The t_List object to initialize.
+*//***************************************************************************/
+#define LIST_INIT(lst) {&(lst), &(lst)}
+
+
+/**************************************************************************//**
+ @Function      LIST
+
+ @Description   Macro to declare of a list.
+
+ @Param[in]     listName - The list object name.
+*//***************************************************************************/
+#define LIST(listName) t_List listName = LIST_INIT(listName)
+
+
+/**************************************************************************//**
+ @Function      INIT_LIST
+
+ @Description   Macro to initialize a list pointer.
+
+ @Param[in]     p_List - The list pointer.
+*//***************************************************************************/
+#define INIT_LIST(p_List)   LIST_FIRST(p_List) = LIST_LAST(p_List) = (p_List)
+
+
+/**************************************************************************//**
+ @Function      LIST_OBJECT
+
+ @Description   Macro to get the struct (object) for this entry.
+
+ @Param[in]     type   - The type of the struct (object) this list is embedded in.
+ @Param[in]     member - The name of the t_List object within the struct.
+
+ @Return        The structure pointer for this entry.
+*//***************************************************************************/
+#define MEMBER_OFFSET(type, member) ((uint32_t)(&((type *)0)->member))
+#define LIST_OBJECT(p_List, type, member) \
+    ((type *)((char *)(p_List)-MEMBER_OFFSET(type, member)))
+
+
+/**************************************************************************//**
+ @Function      LIST_FOR_EACH
+
+ @Description   Macro to iterate over a list.
+
+ @Param[in]     p_Pos  - A pointer to a list to use as a loop counter.
+ @Param[in]     p_Head - A pointer to the head for your list pointer.
+
+ @Cautions      You can't delete items with this routine.
+                For deletion use LIST_FOR_EACH_SAFE().
+*//***************************************************************************/
+#define LIST_FOR_EACH(p_Pos, p_Head) \
+    for (p_Pos = LIST_FIRST(p_Head); p_Pos != (p_Head); p_Pos = LIST_NEXT(p_Pos))
+
+
+/**************************************************************************//**
+ @Function      LIST_FOR_EACH_SAFE
+
+ @Description   Macro to iterate over a list safe against removal of list entry.
+
+ @Param[in]     p_Pos  - A pointer to a list to use as a loop counter.
+ @Param[in]     p_Tmp  - Another pointer to a list to use as temporary storage.
+ @Param[in]     p_Head - A pointer to the head for your list pointer.
+*//***************************************************************************/
+#define LIST_FOR_EACH_SAFE(p_Pos, p_Tmp, p_Head)                \
+    for (p_Pos = LIST_FIRST(p_Head), p_Tmp = LIST_FIRST(p_Pos); \
+         p_Pos != (p_Head);                                     \
+         p_Pos = p_Tmp, p_Tmp = LIST_NEXT(p_Pos))
+
+
+/**************************************************************************//**
+ @Function      LIST_FOR_EACH_OBJECT_SAFE
+
+ @Description   Macro to iterate over list of given type safely.
+
+ @Param[in]     p_Pos  - A pointer to a list to use as a loop counter.
+ @Param[in]     p_Tmp  - Another pointer to a list to use as temporary storage.
+ @Param[in]     type   - The type of the struct this is embedded in.
+ @Param[in]     p_Head - A pointer to the head for your list pointer.
+ @Param[in]     member - The name of the list_struct within the struct.
+
+ @Cautions      You can't delete items with this routine.
+                For deletion use LIST_FOR_EACH_SAFE().
+*//***************************************************************************/
+#define LIST_FOR_EACH_OBJECT_SAFE(p_Pos, p_Tmp, p_Head, type, member)      \
+    for (p_Pos = LIST_OBJECT(LIST_FIRST(p_Head), type, member),            \
+         p_Tmp = LIST_OBJECT(LIST_FIRST(&p_Pos->member), type, member);    \
+         &p_Pos->member != (p_Head);                                       \
+         p_Pos = p_Tmp,                                                    \
+         p_Tmp = LIST_OBJECT(LIST_FIRST(&p_Pos->member), type, member))
+
+/**************************************************************************//**
+ @Function      LIST_FOR_EACH_OBJECT
+
+ @Description   Macro to iterate over list of given type.
+
+ @Param[in]     p_Pos  - A pointer to a list to use as a loop counter.
+ @Param[in]     type   - The type of the struct this is embedded in.
+ @Param[in]     p_Head - A pointer to the head for your list pointer.
+ @Param[in]     member - The name of the list_struct within the struct.
+
+ @Cautions      You can't delete items with this routine.
+                For deletion use LIST_FOR_EACH_SAFE().
+*//***************************************************************************/
+#define LIST_FOR_EACH_OBJECT(p_Pos, type, p_Head, member)                  \
+    for (p_Pos = LIST_OBJECT(LIST_FIRST(p_Head), type, member);            \
+         &p_Pos->member != (p_Head);                                       \
+         p_Pos = LIST_OBJECT(LIST_FIRST(&(p_Pos->member)), type, member))
+
+
+/**************************************************************************//**
+ @Function      LIST_Add
+
+ @Description   Add a new entry to a list.
+
+                Insert a new entry after the specified head.
+                This is good for implementing stacks.
+
+ @Param[in]     p_New  - A pointer to a new list entry to be added.
+ @Param[in]     p_Head - A pointer to a list head to add it after.
+
+ @Return        none.
+*//***************************************************************************/
+static __inline__ void LIST_Add(t_List *p_New, t_List *p_Head)
+{
+    LIST_PREV(LIST_NEXT(p_Head)) = p_New;
+    LIST_NEXT(p_New)             = LIST_NEXT(p_Head);
+    LIST_PREV(p_New)             = p_Head;
+    LIST_NEXT(p_Head)            = p_New;
+}
+
+
+/**************************************************************************//**
+ @Function      LIST_AddToTail
+
+ @Description   Add a new entry to a list.
+
+                Insert a new entry before the specified head.
+                This is useful for implementing queues.
+
+ @Param[in]     p_New  - A pointer to a new list entry to be added.
+ @Param[in]     p_Head - A pointer to a list head to add it after.
+
+ @Return        none.
+*//***************************************************************************/
+static __inline__ void LIST_AddToTail(t_List *p_New, t_List *p_Head)
+{
+    LIST_NEXT(LIST_PREV(p_Head)) = p_New;
+    LIST_PREV(p_New)             = LIST_PREV(p_Head);
+    LIST_NEXT(p_New)             = p_Head;
+    LIST_PREV(p_Head)            = p_New;
+}
+
+
+/**************************************************************************//**
+ @Function      LIST_Del
+
+ @Description   Deletes entry from a list.
+
+ @Param[in]     p_Entry - A pointer to the element to delete from the list.
+
+ @Return        none.
+
+ @Cautions      LIST_IsEmpty() on entry does not return true after this,
+                the entry is in an undefined state.
+*//***************************************************************************/
+static __inline__ void LIST_Del(t_List *p_Entry)
+{
+    LIST_PREV(LIST_NEXT(p_Entry)) = LIST_PREV(p_Entry);
+    LIST_NEXT(LIST_PREV(p_Entry)) = LIST_NEXT(p_Entry);
+}
+
+
+/**************************************************************************//**
+ @Function      LIST_DelAndInit
+
+ @Description   Deletes entry from list and reinitialize it.
+
+ @Param[in]     p_Entry - A pointer to the element to delete from the list.
+
+ @Return        none.
+*//***************************************************************************/
+static __inline__ void LIST_DelAndInit(t_List *p_Entry)
+{
+    LIST_Del(p_Entry);
+    INIT_LIST(p_Entry);
+}
+
+
+/**************************************************************************//**
+ @Function      LIST_Move
+
+ @Description   Delete from one list and add as another's head.
+
+ @Param[in]     p_Entry - A pointer to the list entry to move.
+ @Param[in]     p_Head  - A pointer to the list head that will precede our entry.
+
+ @Return        none.
+*//***************************************************************************/
+static __inline__ void LIST_Move(t_List *p_Entry, t_List *p_Head)
+{
+    LIST_Del(p_Entry);
+    LIST_Add(p_Entry, p_Head);
+}
+
+
+/**************************************************************************//**
+ @Function      LIST_MoveToTail
+
+ @Description   Delete from one list and add as another's tail.
+
+ @Param[in]     p_Entry - A pointer to the entry to move.
+ @Param[in]     p_Head  - A pointer to the list head that will follow our entry.
+
+ @Return        none.
+*//***************************************************************************/
+static __inline__ void LIST_MoveToTail(t_List *p_Entry, t_List *p_Head)
+{
+    LIST_Del(p_Entry);
+    LIST_AddToTail(p_Entry, p_Head);
+}
+
+
+/**************************************************************************//**
+ @Function      LIST_IsEmpty
+
+ @Description   Tests whether a list is empty.
+
+ @Param[in]     p_List - A pointer to the list to test.
+
+ @Return        1 if the list is empty, 0 otherwise.
+*//***************************************************************************/
+static __inline__ int LIST_IsEmpty(t_List *p_List)
+{
+    return (LIST_FIRST(p_List) == p_List);
+}
+
+
+/**************************************************************************//**
+ @Function      LIST_Append
+
+ @Description   Join two lists.
+
+ @Param[in]     p_NewList - A pointer to the new list to add.
+ @Param[in]     p_Head    - A pointer to the place to add it in the first list.
+
+ @Return        none.
+*//***************************************************************************/
+void LIST_Append(t_List *p_NewList, t_List *p_Head);
+
+
+/**************************************************************************//**
+ @Function      LIST_NumOfObjs
+
+ @Description   Counts number of objects in the list
+
+ @Param[in]     p_List - A pointer to the list which objects are to be counted.
+
+ @Return        Number of objects in the list.
+*//***************************************************************************/
+int LIST_NumOfObjs(t_List *p_List);
+
+/** @} */ /* end of list_id group */
+/** @} */ /* end of etc_id group */
+
+
+#endif /* __LIST_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h b/drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h
new file mode 100644
index 0000000..7e41c56
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/etc/mem_ext.h
@@ -0,0 +1,324 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+
+ @File          mem_ext.h
+
+ @Description   External prototypes for the memory manager object
+*//***************************************************************************/
+
+#ifndef __MEM_EXT_H
+#define __MEM_EXT_H
+
+#include "std_ext.h"
+#include "part_ext.h"
+
+
+/**************************************************************************//**
+ @Group         etc_id   Utility Library Application Programming Interface
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         mem_id   Slab Memory Manager
+
+ @Description   Slab Memory Manager module functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/* Each block is of the following structure:
+ *
+ *
+ *  +-----------+----------+---------------------------+-----------+-----------+
+ *  | Alignment |  Prefix  | Data                      | Postfix   | Alignment |
+ *  |  field    |   field  |  field                    |   field   | Padding   |
+ *  |           |          |                           |           |           |
+ *  +-----------+----------+---------------------------+-----------+-----------+
+ *  and at the beginning of all bytes, an additional optional padding might reside
+ *  to ensure that the first blocks data field is aligned as requested.
+ */
+
+
+#define MEM_MAX_NAME_LENGTH     4
+
+/**************************************************************************//*
+ @Description   Memory Segment structure
+*//***************************************************************************/
+
+typedef struct
+{
+    char        name[MEM_MAX_NAME_LENGTH];
+                                    /* The segment's name */
+    uint16_t    dataSize;           /* Size of each data block */
+    uint32_t    getFailures;        /* Number of times get failed */
+    int         allocOwner;         /* Memory allocation owner */
+    uint8_t     **p_Bases;          /* Base addresses of the segments */
+    uint8_t     **p_BlocksStack;    /* Array of pointers to blocks */
+    uint32_t    num;                /* Number of blocks in segment */
+    uint32_t    current;            /* Current block */
+    uint16_t    prefixSize;         /* How many bytes to reserve before the data */
+    uint16_t    postfixSize;        /* How many bytes to reserve after the data */
+    uint16_t    alignment;          /* Requested alignment for the data field */
+    bool        consecutiveMem;     /* Allocate consecutive data blocks memory */
+#ifdef DEBUG_MEM_LEAKS
+    void        *p_MemDbg;          /* MEM debug database (MEM leaks detection) */
+    uint32_t    blockOffset;
+    uint32_t    blockSize;
+#endif /* DEBUG_MEM_LEAKS */
+
+} t_MemorySegment;
+
+
+
+/**************************************************************************//**
+ @Function      MEM_Init
+
+ @Description   Create a new memory segment.
+
+ @Param[in]     name        - Name of memory partition.
+ @Param[in]     p_Handle    - Handle to new segment is returned through here.
+ @Param[in]     num         - Number of blocks in new segment.
+ @Param[in]     dataSize    - Size of blocks in segment.
+ @Param[in]     prefixSize  - How many bytes to allocate before the data.
+ @Param[in]     postfixSize - How many bytes to allocate after the data.
+ @Param[in]     alignment   - Requested alignment for data field.
+
+ @Return        E_OK - success, E_NO_MEMORY - out of memory.
+*//***************************************************************************/
+t_Error MEM_Init(char     name[],
+                 t_Handle *p_Handle,
+                 uint32_t num,
+                 uint16_t dataSize,
+                 uint16_t prefixSize,
+                 uint16_t postfixSize,
+                 uint16_t alignment);
+
+/**************************************************************************//**
+ @Function      MEM_InitSmart
+
+ @Description   Create a new memory segment.
+
+ @Param[in]     name            - Name of memory partition.
+ @Param[in]     p_Handle        - Handle to new segment is returned through here.
+ @Param[in]     num             - Number of blocks in new segment.
+ @Param[in]     dataSize        - Size of blocks in segment.
+ @Param[in]     prefixSize      - How many bytes to allocate before the data.
+ @Param[in]     postfixSize     - How many bytes to allocate after the data.
+ @Param[in]     alignment       - Requested alignment for data field.
+ @Param[in]     memPartitionId  - Memory partition ID for allocation.
+ @Param[in]     consecutiveMem  - Whether to allocate the memory blocks
+                                  continuously or not.
+
+ @Return        E_OK - success, E_NO_MEMORY - out of memory.
+*//***************************************************************************/
+t_Error MEM_InitSmart(char      name[],
+                      t_Handle  *p_Handle,
+                      uint32_t  num,
+                      uint16_t  dataSize,
+                      uint16_t  prefixSize,
+                      uint16_t  postfixSize,
+                      uint16_t  alignment,
+                      uint8_t   memPartitionId,
+                      bool      consecutiveMem);
+
+/**************************************************************************//**
+ @Function      MEM_InitByAddress
+
+ @Description   Create a new memory segment with a specified base address.
+
+ @Param[in]     name        - Name of memory partition.
+ @Param[in]     p_Handle    - Handle to new segment is returned through here.
+ @Param[in]     num         - Number of blocks in new segment.
+ @Param[in]     dataSize    - Size of blocks in segment.
+ @Param[in]     prefixSize  - How many bytes to allocate before the data.
+ @Param[in]     postfixSize - How many bytes to allocate after the data.
+ @Param[in]     alignment   - Requested alignment for data field.
+ @Param[in]     address     - The required base address.
+
+ @Return        E_OK - success, E_NO_MEMORY - out of memory.
+ *//***************************************************************************/
+t_Error MEM_InitByAddress(char        name[],
+                          t_Handle    *p_Handle,
+                          uint32_t    num,
+                          uint16_t    dataSize,
+                          uint16_t    prefixSize,
+                          uint16_t    postfixSize,
+                          uint16_t    alignment,
+                          uint8_t     *address);
+
+/**************************************************************************//**
+ @Function      MEM_Free
+
+ @Description   Free a specific memory segment.
+
+ @Param[in]     h_Mem - Handle to memory segment.
+
+ @Return        None.
+*//***************************************************************************/
+void MEM_Free(t_Handle h_Mem);
+
+/**************************************************************************//**
+ @Function      MEM_Get
+
+ @Description   Get a block of memory from a segment.
+
+ @Param[in]     h_Mem - Handle to memory segment.
+
+ @Return        Pointer to new memory block on success,0 otherwise.
+*//***************************************************************************/
+void * MEM_Get(t_Handle h_Mem);
+
+/**************************************************************************//**
+ @Function      MEM_GetN
+
+ @Description   Get up to N blocks of memory from a segment.
+
+                The blocks are assumed to be of a fixed size (one size per segment).
+
+ @Param[in]     h_Mem   - Handle to memory segment.
+ @Param[in]     num     - Number of blocks to allocate.
+ @Param[out]    array   - Array of at least num pointers to which the addresses
+                          of the allocated blocks are written.
+
+ @Return        The number of blocks actually allocated.
+
+ @Cautions      Interrupts are disabled for all of the allocation loop.
+                Although this loop is very short for each block (several machine
+                instructions), you should not allocate a very large number
+                of blocks via this routine.
+*//***************************************************************************/
+uint16_t MEM_GetN(t_Handle h_Mem, uint32_t num, void *array[]);
+
+/**************************************************************************//**
+ @Function      MEM_Put
+
+ @Description   Put a block of memory back to a segment.
+
+ @Param[in]     h_Mem   - Handle to memory segment.
+ @Param[in]     p_Block - The block to return.
+
+ @Return        Pointer to new memory block on success,0 otherwise.
+*//***************************************************************************/
+t_Error MEM_Put(t_Handle h_Mem, void *p_Block);
+
+
+
+/**************************************************************************//**
+ @Function      MEM_ComputePartitionSize
+
+ @Description   calculate a tight upper boundary of the size of a partition with
+                given attributes.
+
+                The returned value is suitable if one wants to use MEM_InitByAddress().
+
+ @Param[in]     num         - The number of blocks in the segment.
+ @Param[in]     dataSize    - Size of block to get.
+ @Param[in]     prefixSize  - The prefix size
+ @Param         postfixSize - The postfix size
+ @Param[in]     alignment   - The requested alignment value
+
+ @Return        The memory block size a segment with the given attributes needs.
+*//***************************************************************************/
+uint32_t MEM_ComputePartitionSize(uint32_t num,
+                                  uint16_t dataSize,
+                                  uint16_t prefixSize,
+                                  uint16_t postfixSize,
+                                  uint16_t alignment);
+
+
+#ifdef DEBUG_MEM_LEAKS
+
+#if !(defined(__MWERKS__) && (__dest_os == __ppc_eabi))
+#error  "Memory-Leaks-Debug option is supported only for freescale CodeWarrior"
+#endif /* __MWERKS__ */
+/**************************************************************************//**
+ @Function      MEM_CheckLeaks
+
+ @Description   Report MEM object leaks.
+
+                This routine is automatically called by the MEM_Free() routine,
+                but it can also be invoked while the MEM object is alive.
+
+ @Param[in]     h_Mem - Handle to memory segment.
+
+ @Return        None.
+*//***************************************************************************/
+void MEM_CheckLeaks(t_Handle h_Mem);
+
+#else  /* not DEBUG_MEM_LEAKS */
+
+#define MEM_CheckLeaks(h_Mem)
+
+#endif /* not DEBUG_MEM_LEAKS */
+
+
+/**************************************************************************//**
+ @Description   Get base of MEM
+*//***************************************************************************/
+#define MEM_GetBase(h_Mem)             ((t_MemorySegment *)(h_Mem))->p_Bases[0]
+
+/**************************************************************************//**
+ @Description   Get size of MEM block
+*//***************************************************************************/
+#define MEM_GetSize(h_Mem)             ((t_MemorySegment *)(h_Mem))->dataSize
+
+/**************************************************************************//**
+ @Description   Get prefix size of MEM block
+*//***************************************************************************/
+#define MEM_GetPrefixSize(h_Mem)       ((t_MemorySegment *)(h_Mem))->prefixSize
+
+/**************************************************************************//**
+ @Description   Get postfix size of MEM block
+*//***************************************************************************/
+#define MEM_GetPostfixSize(h_Mem)      ((t_MemorySegment *)(h_Mem))->postfixSize
+
+/**************************************************************************//**
+ @Description   Get alignment of MEM block
+*//***************************************************************************/
+#define MEM_GetAlignment(h_Mem)        ((t_MemorySegment *)(h_Mem))->alignment
+
+/**************************************************************************//**
+ @Description   Get the number of blocks in the segment
+*//***************************************************************************/
+#define MEM_GetNumOfBlocks(h_Mem)             ((t_MemorySegment *)(h_Mem))->num
+
+
+/** @} */ /* end of MEM group */
+/** @} */ /* end of etc_id group */
+
+
+#endif /* __MEM_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/etc/memcpy_ext.h b/drivers/net/dpa/NetCommSw/inc/etc/memcpy_ext.h
new file mode 100644
index 0000000..5de41be
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/etc/memcpy_ext.h
@@ -0,0 +1,173 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+
+ @File          memcpy_ext.h
+
+ @Description   Efficient functions for copying and setting blocks of memory.
+*//***************************************************************************/
+
+#ifndef __MEMCPY_EXT_H
+#define __MEMCPY_EXT_H
+
+#include "std_ext.h"
+
+
+/**************************************************************************//**
+ @Group         etc_id   Utility Library Application Programming Interface
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         mem_cpy Memory Copy
+
+ @Description   Memory Copy module functions,definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      MemCpy32
+
+ @Description   Copies one memory buffer into another one in 4-byte chunks!
+                Which should be more efficient than byte by byte.
+
+                For large buffers (over 60 bytes) this function is about 4 times
+                more efficient than the trivial memory copy. For short buffers
+                it is reduced to the trivial copy and may be a bit worse.
+
+ @Param[in]     pDst    - The address of the destination buffer.
+ @Param[in]     pSrc    - The address of the source buffer.
+ @Param[in]     size    - The number of bytes that will be copied from pSrc to pDst.
+
+ @Return        pDst (the address of the destination buffer).
+
+ @Cautions      There is no parameter or boundary checking! It is up to the user
+                to supply non-null parameters as source & destination and size
+                that actually fits into the destination buffer.
+*//***************************************************************************/
+void * MemCpy32(void* pDst,void* pSrc, uint32_t size);
+void * IO2IOCpy32(void* pDst,void* pSrc, uint32_t size);
+void * IO2MemCpy32(void* pDst,void* pSrc, uint32_t size);
+void * Mem2IOCpy32(void* pDst,void* pSrc, uint32_t size);
+
+/**************************************************************************//**
+ @Function      MemCpy64
+
+ @Description   Copies one memory buffer into another one in 8-byte chunks!
+                Which should be more efficient than byte by byte.
+
+                For large buffers (over 60 bytes) this function is about 8 times
+                more efficient than the trivial memory copy. For short buffers
+                it is reduced to the trivial copy and may be a bit worse.
+
+                Some testing suggests that MemCpy32() preforms better than
+                MemCpy64() over small buffers. On average they break even at
+                100 byte buffers. For buffers larger than that MemCpy64 is
+                superior.
+
+ @Param[in]     pDst    - The address of the destination buffer.
+ @Param[in]     pSrc    - The address of the source buffer.
+ @Param[in]     size    - The number of bytes that will be copied from pSrc to pDst.
+
+ @Return        pDst (the address of the destination buffer).
+
+ @Cautions      There is no parameter or boundary checking! It is up to the user
+                to supply non null parameters as source & destination and size
+                that actually fits into their buffer.
+
+                Do not use under Linux.
+*//***************************************************************************/
+void * MemCpy64(void* pDst,void* pSrc, uint32_t size);
+
+/**************************************************************************//**
+ @Function      MemSet32
+
+ @Description   Sets all bytes of a memory buffer to a specific value, in
+                4-byte chunks.
+
+ @Param[in]     pDst    - The address of the destination buffer.
+ @Param[in]     val     - Value to set destination bytes to.
+ @Param[in]     size    - The number of bytes that will be set to val.
+
+ @Return        pDst (the address of the destination buffer).
+
+ @Cautions      There is no parameter or boundary checking! It is up to the user
+                to supply non null parameter as destination and size
+                that actually fits into the destination buffer.
+*//***************************************************************************/
+void * MemSet32(void* pDst, uint8_t val, uint32_t size);
+void * IOMemSet32(void* pDst, uint8_t val, uint32_t size);
+
+/**************************************************************************//**
+ @Function      MemSet64
+
+ @Description   Sets all bytes of a memory buffer to a specific value, in
+                8-byte chunks.
+
+ @Param[in]     pDst    - The address of the destination buffer.
+ @Param[in]     val     - Value to set destination bytes to.
+ @Param[in]     size    - The number of bytes that will be set to val.
+
+ @Return        pDst (the address of the destination buffer).
+
+ @Cautions      There is no parameter or boundary checking! It is up to the user
+                to supply non null parameter as destination and size
+                that actually fits into the destination buffer.
+*//***************************************************************************/
+void * MemSet64(void* pDst, uint8_t val, uint32_t size);
+
+/**************************************************************************//**
+ @Function      MemDisp
+
+ @Description   Displays a block of memory in chunks of 32 bits.
+
+ @Param[in]     addr    - The address of the memory to dysplay.
+ @Param[in]     size    - The number of bytes that will be displayed.
+
+ @Return        None.
+
+ @Cautions      There is no parameter or boundary checking! It is up to the user
+                to supply non null parameter as destination and size
+                that actually fits into the destination buffer.
+*//***************************************************************************/
+void MemDisp(uint8_t *addr, int size);
+
+/** @} */ /* end of mem_cpy group */
+/** @} */ /* end of etc_id group */
+
+
+#endif /* __MEMCPY_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/etc/mm_ext.h b/drivers/net/dpa/NetCommSw/inc/etc/mm_ext.h
new file mode 100644
index 0000000..129e332
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/etc/mm_ext.h
@@ -0,0 +1,301 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+ /**************************************************************************//**
+
+ @File          mm_ext.h
+
+ @Description   Memory Manager Application Programming Interface
+*//***************************************************************************/
+#ifndef __MM_EXT
+#define __MM_EXT
+
+#include "std_ext.h"
+
+#define MM_MAX_ALIGNMENT    20  /*ys* patch for data overrun */
+                                /* The alignments from 2 to 128 are available
+                                   where maximum alignment defined as
+                                   MM_MAX_ALIGNMENT power of 2 */
+
+#define MM_MAX_NAME_LEN     50
+
+/**************************************************************************//**
+ @Group         etc_id   Utility Library Application Programming Interface
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         mm_grp Flexible Memory Manager
+
+ @Description   Flexible Memory Manager module functions,definitions and enums.
+                (All of the following functions,definitions and enums can be found in mm_ext.h)
+
+ @{
+*//***************************************************************************/
+
+
+/**************************************************************************//**
+ @Function      MM_Init
+
+ @Description   Initializes a new MM object.
+
+                It initializes a new memory block consisting of base address
+                and size of the available memory by calling to MemBlock_Init
+                routine. It is also initializes a new free block for each
+                by calling FreeBlock_Init routine, which is pointed to
+                the almost all memory started from the required alignment
+                from the base address and to the end of the memory.
+                The handle to the new MM object is returned via "MM"
+                argument (passed by reference).
+
+ @Param[in]     h_MM    - Handle to the MM object.
+ @Param[in]     base    - Base address of the MM.
+ @Param[in]     size    - Size of the MM.
+
+ @Return        E_OK is returned on success. E_NOMEMORY is returned if the new MM object or a new free block can not be initialized.
+*//***************************************************************************/
+t_Error     MM_Init(t_Handle *h_MM, uint64_t base, uint64_t size);
+
+/**************************************************************************//**
+ @Function      MM_Get
+
+ @Description   Allocates a block of memory according to the given size and the alignment.
+
+                The Alignement argument tells from which
+                free list allocate a block of memory. 2^alignment indicates
+                the alignment that the base address of the allocated block
+                should have. So, the only values 1, 2, 4, 8, 16, 32 and 64
+                are available for the alignment argument.
+                The routine passes through the specific free list of free
+                blocks and seeks for a first block that have anough memory
+                that  is required (best fit).
+                After the block is found and data is allocated, it calls
+                the internal MM_CutFree routine to update all free lists
+                do not include a just allocated block. Of course, each
+                free list contains a free blocks with the same alignment.
+                It is also creates a busy block that holds
+                information about an allocated block.
+
+ @Param[in]     h_MM        - Handle to the MM object.
+ @Param[in]     size        - Size of the MM.
+ @Param[in]     alignment   - Index as a power of two defines a required
+                              alignment; Should be 1, 2, 4, 8, 16, 32 or 64
+ @Param[in]     name        - The name that specifies an allocated block.
+
+ @Return        base address of an allocated block ILLEGAL_BASE if can't allocate a block
+*//***************************************************************************/
+uint64_t    MM_Get(t_Handle h_MM, uint64_t size, int alignment, char *name);
+
+/**************************************************************************//**
+ @Function      MM_GetBase
+
+ @Description   Gets the base address of the required MM objects.
+
+ @Param[in]     h_MM - Handle to the MM object.
+
+ @Return        base address of the block.
+*//***************************************************************************/
+uint64_t    MM_GetBase(t_Handle h_MM);
+
+/**************************************************************************//**
+ @Function      MM_GetForce
+
+ @Description   Force memory allocation.
+
+                It means to allocate a block of memory of the given
+                size from the given base address.
+                The routine checks if the required block can be allocated
+                (that is it is free) and then, calls the internal MM_CutFree
+                routine to update all free lists do not include that block.
+
+ @Param[in]     h_MM    - Handle to the MM object.
+ @Param[in]     base    - Base address of the MM.
+ @Param[in]     size    - Size of the MM.
+ @Param[in]     name    - Name that specifies an allocated block.
+
+ @Return        base address of an allocated block, ILLEGAL_BASE if can't allocate a block.
+*//***************************************************************************/
+uint64_t    MM_GetForce(t_Handle h_MM, uint64_t base, uint64_t size, char *name);
+
+/**************************************************************************//**
+ @Function      MM_GetForceMin
+
+ @Description   Allocates a block of memory according to the given size, the alignment and minimum base address.
+
+                The Alignement argument tells from which
+                free list allocate a block of memory. 2^alignment indicates
+                the alignment that the base address of the allocated block
+                should have. So, the only values 1, 2, 4, 8, 16, 32 and 64
+                are available for the alignment argument.
+                The minimum baser address forces the location of the block
+                to be from a given address onward.
+                The routine passes through the specific free list of free
+                blocks and seeks for the first base address equal or smaller
+                than the required minimum address and end address larger than
+                than the required base + its size - i.e. that may contain
+                the required block.
+                After the block is found and data is allocated, it calls
+                the internal MM_CutFree routine to update all free lists
+                do not include a just allocated block. Of course, each
+                free list contains a free blocks with the same alignment.
+                It is also creates a busy block that holds
+                information about an allocated block.
+
+ @Param[in]     h_MM        - Handle to the MM object.
+ @Param[in]     size        - Size of the MM.
+ @Param[in]     alignment   - Index as a power of two defines a required
+                              alignment; Should be 1, 2, 4, 8, 16, 32 or 64
+ @Param[in]     min         - The minimum base address of the block.
+ @Param[in]     name        - Name that specifies an allocated block.
+
+ @Return        base address of an allocated block,ILLEGAL_BASE if can't allocate a block.
+*//***************************************************************************/
+uint64_t    MM_GetForceMin(t_Handle h_MM,
+                           uint64_t size,
+                           int      alignment,
+                           uint64_t min,
+                           char     *name);
+
+/**************************************************************************//**
+ @Function      MM_Put
+
+ @Description   Puts a block of memory of the given base address back to the memory.
+
+                It checks if there is a busy block with the
+                given base address. If not, it returns 0, that
+                means can't free a block. Otherwise, it gets parameters of
+                the busy block and after it updates lists of free blocks,
+                removes that busy block from the list by calling to MM_CutBusy
+                routine.
+                After that it calls to MM_AddFree routine to add a new free
+                block to the free lists.
+
+ @Param[in]     h_MM    - Handle to the MM object.
+ @Param[in]     base    - Base address of the MM.
+
+ @Return         The size of bytes released, 0 if failed.
+*//***************************************************************************/
+uint64_t    MM_Put(t_Handle h_MM, uint64_t base);
+
+/**************************************************************************//**
+ @Function      MM_PutForce
+
+ @Description   Releases a block of memory of the required size from the required base address.
+
+                First, it calls to MM_CutBusy routine
+                to cut a free block from the busy list. And then, calls to
+                MM_AddFree routine to add the free block to the free lists.
+
+ @Param[in]     h_MM    - Handle to the MM object.
+ @Param[in]     base    - Base address of of a block to free.
+ @Param[in]     size    - Size of a block to free.
+
+ @Return        The number of bytes released, 0 on failure.
+*//***************************************************************************/
+uint64_t    MM_PutForce(t_Handle h_MM, uint64_t base, uint64_t size);
+
+/**************************************************************************//**
+ @Function      MM_Add
+
+ @Description   Adds a new memory block for memory allocation.
+
+                When a new memory block is initialized and added to the
+                memory list, it calls to MM_AddFree routine to add the
+                new free block to the free lists.
+
+ @Param[in]     h_MM    - Handle to the MM object.
+ @Param[in]     base    - Base address of the memory block.
+ @Param[in]     size    - Size of the memory block.
+
+ @Return        E_OK on success, otherwise returns an error code.
+*//***************************************************************************/
+t_Error     MM_Add(t_Handle h_MM, uint64_t base, uint64_t size);
+
+/**************************************************************************//**
+ @Function      MM_Dump
+
+ @Description   Prints results of free and busy lists into the file.
+
+ @Param[in]     h_MM        - Handle to the MM object.
+ @Param[in]     buff        - A pointer to a buffer
+*//***************************************************************************/
+void        MM_Dump(t_Handle h_MM, void *buff);
+
+/**************************************************************************//**
+ @Function      MM_Free
+
+ @Description   Releases memory allocated for MM object.
+
+ @Param[in]     h_MM - Handle of the MM object.
+*//***************************************************************************/
+void        MM_Free(t_Handle h_MM);
+
+/**************************************************************************//**
+ @Function      MM_GetMemBlock
+
+ @Description   Returns base address of the memory block specified by the index.
+
+                If index is 0, returns base address
+                of the first memory block, 1 - returns base address
+                of the second memory block, etc.
+                Note, those memory blocks are allocated by the
+                application before MM_Init or MM_Add and have to
+                be released by the application before or after invoking
+                the MM_Free routine.
+
+ @Param[in]     h_MM    - Handle to the MM object.
+ @Param[in]     index   - Index of the memory block.
+
+ @Return        valid base address or ILLEGAL_BASE if no memory block specified by the index.
+*//***************************************************************************/
+uint64_t    MM_GetMemBlock(t_Handle h_MM, int index);
+
+/**************************************************************************//**
+ @Function      MM_InRange
+
+ @Description   Checks if a specific address is in the memory range of the passed MM object.
+
+ @Param[in]     h_MM    - Handle to the MM object.
+ @Param[in]     addr    - The address to be checked.
+
+ @Return        TRUE if the addres is in the address range of the block,FALSE otherwise.
+*//***************************************************************************/
+bool        MM_InRange(t_Handle h_MM, uint64_t addr);
+
+
+/** @} */ /* end of mm_grp group */
+/** @} */ /* end of etc_id group */
+
+#endif /* __MM_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/etc/sprint_ext.h b/drivers/net/dpa/NetCommSw/inc/etc/sprint_ext.h
new file mode 100644
index 0000000..db7f1b2
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/etc/sprint_ext.h
@@ -0,0 +1,121 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+
+ @File          sprint_ext.h
+
+ @Description   Debug routines (externals).
+
+*//***************************************************************************/
+
+#ifndef __SPRINT_EXT_H
+#define __SPRINT_EXT_H
+
+
+#if defined(NCSW_LINUX) && defined(__KERNEL__)
+#include <linux/kernel.h>
+
+#elif defined(MWI_VXWORKS)
+#include "stdio.h"
+
+#else
+#include <stdio.h>
+
+#endif /* defined(NCSW_LINUX) && defined(__KERNEL__) */
+
+#include "std_ext.h"
+#ifdef NCSW_VXWORKS
+#include "private/stdioP.h"
+#endif /* NCSW_VXWORKS */
+
+/**************************************************************************//**
+ @Group         etc_id   Utility Library Application Programming Interface
+
+ @Description   External routines.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         sprint_id Sprint
+
+ @Description   Sprint & Sscan module functions,definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      Sprint
+
+ @Description   Format a string and place it in a buffer.
+
+ @Param[in]     buff - The buffer to place the result into.
+ @Param[in]     str  - The format string to use.
+ @Param[in]     ...  - Arguments for the format string.
+
+ @Return        Number of bytes formatted.
+*//***************************************************************************/
+int Sprint(char *buff, const char *str, ...);
+
+/**************************************************************************//**
+ @Function      Snprint
+
+ @Description   Format a string and place it in a buffer.
+
+ @Param[in]     buf  - The buffer to place the result into.
+ @Param[in]     size - The size of the buffer, including the trailing null space.
+ @Param[in]     fmt  - The format string to use.
+ @Param[in]     ...  - Arguments for the format string.
+
+ @Return        Number of bytes formatted.
+*//***************************************************************************/
+int Snprint(char * buf, uint32_t size, const char *fmt, ...);
+
+/**************************************************************************//**
+ @Function      Sscan
+
+ @Description   Unformat a buffer into a list of arguments.
+
+ @Param[in]     buf  - input buffer.
+ @Param[in]     fmt  - formatting of buffer.
+ @Param[out]    ...  - resulting arguments.
+
+ @Return        Number of bytes unformatted.
+*//***************************************************************************/
+int Sscan(const char * buf, const char * fmt, ...);
+
+/** @} */ /* end of sprint_id group */
+/** @} */ /* end of etc_id group */
+
+
+#endif /* __SPRINT_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h b/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h
new file mode 100644
index 0000000..273b46e
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h
@@ -0,0 +1,306 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+
+ @File          part_integration_ext.h
+
+ @Description   P4080 external definitions and structures.
+*//***************************************************************************/
+#ifndef __PART_INTEGRATION_EXT_H
+#define __PART_INTEGRATION_EXT_H
+
+
+/**************************************************************************//**
+ @Group         P4080_chip_id P4080 Application Programming Interface
+
+ @Description   P4080 Chip functions,definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Module types.
+*//***************************************************************************/
+typedef enum e_ModuleId
+{
+    e_MODULE_ID_DUART_1 = 0,
+    e_MODULE_ID_DUART_2,
+    e_MODULE_ID_DUART_3,
+    e_MODULE_ID_DUART_4,
+    e_MODULE_ID_QM,                 /**< Queue manager module */
+    e_MODULE_ID_BM,                 /**< Buffer manager module */
+
+    e_MODULE_ID_FM1,                /**< Frame manager #1 module */
+    e_MODULE_ID_FM1_MURAM,          /**< FM Multi-User-RAM */
+    e_MODULE_ID_FM1_BMI,            /**< FM BMI block */
+    e_MODULE_ID_FM1_QMI,            /**< FM QMI block */
+    e_MODULE_ID_FM1_PRS,            /**< FM parser block */
+    e_MODULE_ID_FM1_PORT_HO0,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO1,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO2,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO3,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO4,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO5,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_HO6,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM1_PORT_1GRx0,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GRx1,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GRx2,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GRx3,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_10GRx0,    /**< FM Rx 10G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GTx0,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GTx1,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GTx2,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_1GTx3,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM1_PORT_10GTx0,    /**< FM Tx 10G MAC port block */
+    e_MODULE_ID_FM1_PLCR,           /**< FM Policer */
+    e_MODULE_ID_FM1_KG,             /**< FM Keygen */
+    e_MODULE_ID_FM1_DMA,            /**< FM DMA */
+    e_MODULE_ID_FM1_FPM,            /**< FM FPM */
+    e_MODULE_ID_FM1_IRAM,           /**< FM Instruction-RAM */
+    e_MODULE_ID_FM1_1GMDIO0,        /**< FM 1G MDIO MAC 0*/
+    e_MODULE_ID_FM1_1GMDIO1,        /**< FM 1G MDIO MAC 1*/
+    e_MODULE_ID_FM1_1GMDIO2,        /**< FM 1G MDIO MAC 2*/
+    e_MODULE_ID_FM1_1GMDIO3,        /**< FM 1G MDIO MAC 3*/
+    e_MODULE_ID_FM1_10GMDIO,        /**< FM 10G MDIO */
+    e_MODULE_ID_FM1_PRS_IRAM,       /**< FM SW-parser Instruction-RAM */
+    e_MODULE_ID_FM1_RISC0,          /**< FM risc #0 */
+    e_MODULE_ID_FM1_RISC1,          /**< FM risc #1 */
+    e_MODULE_ID_FM1_1GMAC0,         /**< FM 1G MAC #0 */
+    e_MODULE_ID_FM1_1GMAC1,         /**< FM 1G MAC #1 */
+    e_MODULE_ID_FM1_1GMAC2,         /**< FM 1G MAC #2 */
+    e_MODULE_ID_FM1_1GMAC3,         /**< FM 1G MAC #3 */
+    e_MODULE_ID_FM1_10GMAC0,        /**< FM 10G MAC #0 */
+
+    e_MODULE_ID_FM2,                /**< Frame manager #2 module */
+    e_MODULE_ID_FM2_MURAM,          /**< FM Multi-User-RAM */
+    e_MODULE_ID_FM2_BMI,            /**< FM BMI block */
+    e_MODULE_ID_FM2_QMI,            /**< FM QMI block */
+    e_MODULE_ID_FM2_PRS,            /**< FM parser block */
+    e_MODULE_ID_FM2_PORT_HO0,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO1,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO2,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO3,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO4,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO5,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_HO6,       /**< FM Host-command/offline-parsing port block */
+    e_MODULE_ID_FM2_PORT_1GRx0,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GRx1,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GRx2,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GRx3,     /**< FM Rx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_10GRx0,    /**< FM Rx 10G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GTx0,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GTx1,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GTx2,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_1GTx3,     /**< FM Tx 1G MAC port block */
+    e_MODULE_ID_FM2_PORT_10GTx0,    /**< FM Tx 10G MAC port block */
+    e_MODULE_ID_FM2_PLCR,           /**< FM Policer */
+    e_MODULE_ID_FM2_KG,             /**< FM Keygen */
+    e_MODULE_ID_FM2_DMA,            /**< FM DMA */
+    e_MODULE_ID_FM2_FPM,            /**< FM FPM */
+    e_MODULE_ID_FM2_IRAM,           /**< FM Instruction-RAM */
+    e_MODULE_ID_FM2_1GMDIO0,        /**< FM 1G MDIO MAC 0*/
+    e_MODULE_ID_FM2_1GMDIO1,        /**< FM 1G MDIO MAC 1*/
+    e_MODULE_ID_FM2_1GMDIO2,        /**< FM 1G MDIO MAC 2*/
+    e_MODULE_ID_FM2_1GMDIO3,        /**< FM 1G MDIO MAC 3*/
+    e_MODULE_ID_FM2_10GMDIO,        /**< FM 10G MDIO */
+    e_MODULE_ID_FM2_PRS_IRAM,       /**< FM SW-parser Instruction-RAM */
+    e_MODULE_ID_FM2_RISC0,          /**< FM risc #0 */
+    e_MODULE_ID_FM2_RISC1,          /**< FM risc #1 */
+    e_MODULE_ID_FM2_1GMAC0,         /**< FM 1G MAC #0 */
+    e_MODULE_ID_FM2_1GMAC1,         /**< FM 1G MAC #1 */
+    e_MODULE_ID_FM2_1GMAC2,         /**< FM 1G MAC #2 */
+    e_MODULE_ID_FM2_1GMAC3,         /**< FM 1G MAC #3 */
+    e_MODULE_ID_FM2_10GMAC0,        /**< FM 10G MAC #0 */
+
+    e_MODULE_ID_MPIC,               /**< MPIC */
+    e_MODULE_ID_DUMMY_LAST
+} e_ModuleId;
+
+#define NUM_OF_MODULES  e_MODULE_ID_DUMMY_LAST
+
+/**************************************************************************//**
+ @Description   Transaction source id (for memory conrollers error reporting DDR,LBC,ECM).
+*//***************************************************************************/
+typedef enum e_TransSrc
+{
+    e_TRANS_SRC_LBC             = 0x4,  /**< Enhanced local bus      */
+    e_TRANS_SRC_BOOTS           = 0xA,  /**< Boot sequencer          */
+    e_TRANS_SRC_DDR1            = 0xF,  /**< DDR controller 1        */
+    e_TRANS_SRC_CORE_INS_FETCH  = 0x10, /**< Processor (instruction) */
+    e_TRANS_SRC_CORE_DATA       = 0x11, /**< Processor (data)        */
+    e_TRANS_SRC_DMA             = 0x15, /**< DMA                     */
+} e_TransSrc;
+
+
+/***************************************************************
+    P4080 general routines
+****************************************************************/
+/**************************************************************************//**
+ @Group         P4080_init_grp P4080 Initialization Unit
+
+ @Description   P4080 initialization unit API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Part ID and revision number
+*//***************************************************************************/
+typedef enum e_P4080DeviceName
+{
+    e_P4080_REV_INVALID   = 0x00000000,   /**< Invalid revision      */
+    e_P4080E_REV_1_0      = 0x807D0010    /**< P4080E with security, revision 1.0 */
+} e_P4080DeviceName;
+
+
+/**************************************************************************//**
+ @Function      P4080_ConfigAndInit
+
+ @Description   General initiation of the chip registers.
+
+ @Param         baseAddress  - (In) memory map start
+
+ @Return        A handle to the P4080 data structure.
+*//***************************************************************************/
+t_Handle P4080_ConfigAndInit(uint32_t baseAddress);
+
+/**************************************************************************//**
+ @Function      P4080_Free
+
+ @Description   Free all resources.
+
+ @Param         h_P4080 - (In) The handle of the initialized P4080 object.
+
+ @Return        E_OK on success; Other value otherwise.
+*//***************************************************************************/
+t_Error P4080_Free(t_Handle h_P4080);
+
+/**************************************************************************//**
+ @Function      P4080_GetModuleBase
+
+ @Description   returns the base address of a P4080 module's
+                memory mapped registers.
+
+ @Param         h_P4080   - (In) The handle of the initialized P4080 object.
+ @Param         module      - (In) The module ID.
+
+ @Return        Base address of module's memory mapped registers.
+                ILLEGAL_BASE in case of non-existent module
+*//***************************************************************************/
+uint32_t P4080_GetModuleBase(t_Handle h_P4080, e_ModuleId module);
+
+/**************************************************************************//**
+ @Function      P4080_GetRevInfo
+
+ @Description   This routine enables access to chip and revision information.
+
+ @Param         h_P4080 - (In) The handle of the initialized P4080 object.
+
+ @Return        Part ID and revision.
+*//***************************************************************************/
+e_P4080DeviceName P4080_GetRevInfo(t_Handle h_P4080);
+
+/**************************************************************************//**
+ @Function      P4080_GetE500Factor
+
+ @Description   returns system multiplication factor.
+
+ @Param         h_P4080 - (In) a handle to the P4080 object.
+ @Param         p_E500MulFactor   - (Out) returns E500 to CCB multification factor.
+ @Param         p_E500DivFactor   - (Out) returns E500 to CCB division factor.
+
+ @Return        E_OK on success; Other value otherwise.
+*
+*//***************************************************************************/
+t_Error P4080_GetE500Factor(t_Handle h_P4080, uint32_t *p_E500MulFactor, uint32_t *p_E500DivFactor);
+
+/**************************************************************************//**
+ @Function      P4080_GetCcbFactor
+
+ @Description   returns system multiplication factor.
+
+ @Param         h_P4080 - (In) The handle of the initialized P4080 object.
+
+ @Return        System multiplication factor.
+*//***************************************************************************/
+uint32_t P4080_GetCcbFactor(t_Handle h_P4080);
+
+/** @} */ /* end of P4080_init_grp group */
+/** @} */ /* end of P4080_grp group */
+
+
+/*****************************************************************************
+ INTEGRATION-SPECIFIC MODULE CODES
+******************************************************************************/
+#define MODULE_UNKNOWN          0x00000000
+#define MODULE_MEM              0x00010000
+#define MODULE_MM               0x00020000
+#define MODULE_CORE             0x00030000
+#define MODULE_PM               0x00040000
+#define MODULE_P4080            0x00050000
+#define MODULE_P4080_PLTFRM     0x00060000
+#define MODULE_MMU              0x00070000
+#define MODULE_EPIC             0x00080000
+#define MODULE_FM               0x00090000
+#define MODULE_QM               0x000a0000
+#define MODULE_BM               0x000b0000
+#define MODULE_DUART            0x000c0000
+
+/*****************************************************************************
+ FM INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define INTG_MAX_NUM_OF_FM          2
+
+#define FM_MAX_NUM_OF_1G_RX_PORTS   4
+#define FM_MAX_NUM_OF_10G_RX_PORTS  1
+#define FM_MAX_NUM_OF_RX_PORTS      (FM_MAX_NUM_OF_10G_RX_PORTS+FM_MAX_NUM_OF_1G_RX_PORTS)
+#define FM_MAX_NUM_OF_1G_TX_PORTS   4
+#define FM_MAX_NUM_OF_10G_TX_PORTS  1
+#define FM_MAX_NUM_OF_TX_PORTS      (FM_MAX_NUM_OF_10G_TX_PORTS+FM_MAX_NUM_OF_1G_TX_PORTS)
+#define FM_MAX_NUM_OF_OP_PORTS      6
+#define FM_MAX_NUM_OF_HC_PORTS      1
+#define FM_MAX_NUM_OF_1G_MACS       (FM_MAX_NUM_OF_1G_RX_PORTS)
+#define FM_MAX_NUM_OF_10G_MACS      (FM_MAX_NUM_OF_10G_RX_PORTS)
+#define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS+FM_MAX_NUM_OF_10G_MACS)
+#define FM_MAX_NUM_OF_PCD_PORTS     FM_MAX_NUM_OF_RX_PORTS+FM_MAX_NUM_OF_OP_PORTS
+
+#define FM_MURAM_SIZE               (160*KILOBYTE)
+#define FM_PCD_PLCR_NUM_ENTRIES     256                 /**< Total number of policer profiles */
+#define FM_PCD_KG_NUM_OF_SCHEMES    32                  /**< Total number of KG schemes */
+#define FM_PCD_MAX_NUM_OF_CLS_PLANS 256                 /**< Number of classification plan entries. */
+
+#define FM_OP_PARTITION_ERRATA
+#define CORE_8BIT_ACCESS_ERRATA
+
+
+#endif /* __PART_INTEGRATION_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/integrations/part_ext.h b/drivers/net/dpa/NetCommSw/inc/integrations/part_ext.h
new file mode 100644
index 0000000..b9f3f87
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/integrations/part_ext.h
@@ -0,0 +1,85 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+
+ @File          part_ext.h
+
+ @Description   Definitions for the part (integration) module.
+*//***************************************************************************/
+
+#ifndef __PART_EXT_H
+#define __PART_EXT_H
+
+#include "std_ext.h"
+#include "part_integration_ext.h"
+
+
+#if !(defined(MPC834x) || \
+      defined(MPC836x) || \
+      defined(MPC832x) || \
+      defined(MPC837x) || \
+      defined(MPC8568) || \
+      defined(MPC8569) || \
+      defined(P4080)   || \
+      defined(MSC814x))
+#error "unable to proceed without chip-definition"
+#endif /* !(defined(MPC834x) || ... */
+
+
+/**************************************************************************//**
+ @Description   Part callback typedef for revision information.
+
+ @Param         appId   - (In) user's id as passed at init routine
+ @Param         event   - (In) GPIO event register - may be used if a single routine
+                        is passed to all events. Otherwize - redundent.
+
+*//***************************************************************************/
+typedef uint32_t (t_RevInfoCallback)(t_Handle h_Part);
+
+/**************************************************************************//*
+ @Description   Part data structure - must be contained in any integration
+                data structure.
+*//***************************************************************************/
+typedef struct t_Part
+{
+    uint32_t    (* f_GetRevInfo)(t_Handle h_Part);
+                /**< Returns the revision number of the chip. */
+    uint32_t    (* f_GetModuleBase)(t_Handle h_Part, e_ModuleId moduleId);
+                /**< Returns the address of the module's memory map base. */
+    e_ModuleId  (* f_GetModuleIdByBase)(t_Handle h_Part, uint32_t baseAddress);
+                /**< Returns the module's ID according to its memory map base. */
+} t_Part;
+
+
+
+#endif /* __PART_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/math_ext.h b/drivers/net/dpa/NetCommSw/inc/math_ext.h
new file mode 100644
index 0000000..59f0533
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/math_ext.h
@@ -0,0 +1,101 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __MATH_EXT_H
+#define __MATH_EXT_H
+
+
+#if defined(NCSW_LINUX) && defined(__KERNEL__)
+#include <linux/math.h>
+
+#elif defined(MWI_VXWORKS)
+#include "math.h"
+
+#elif defined(__MWERKS__)
+#define LOW(x) ( sizeof(x)==8 ? *(1+(int32_t*)&x) : (*(int32_t*)&x))
+#define HIGH(x) (*(int32_t*)&x)
+#define ULOW(x) ( sizeof(x)==8 ? *(1+(uint32_t*)&x) : (*(uint32_t*)&x))
+#define UHIGH(x) (*(uint32_t*)&x)
+
+static const double big = 1.0e300;
+
+/* Macro for checking if a number is a power of 2 */
+static __inline__ double ceil(double x)
+{
+    int32_t i0,i1,j0; /*- cc 020130 -*/
+    uint32_t i,j; /*- cc 020130 -*/
+    i0 =  HIGH(x);
+    i1 =  LOW(x);
+    j0 = ((i0>>20)&0x7ff)-0x3ff;
+    if(j0<20) {
+        if(j0<0) {     /* raise inexact if x != 0 */
+        if(big+x>0.0) {/* return 0*sign(x) if |x|<1 */
+            if(i0<0) {i0=0x80000000;i1=0;}
+            else if((i0|i1)!=0) { i0=0x3ff00000;i1=0;}
+        }
+        } else {
+        i = (uint32_t)(0x000fffff)>>j0;
+        if(((i0&i)|i1)==0) return x; /* x is integral */
+        if(big+x>0.0) {    /* raise inexact flag */
+            if(i0>0) i0 += (0x00100000)>>j0;
+            i0 &= (~i); i1=0;
+        }
+        }
+    } else if (j0>51) {
+        if(j0==0x400) return x+x;    /* inf or NaN */
+        else return x;        /* x is integral */
+    } else {
+        i = ((uint32_t)(0xffffffff))>>(j0-20); /*- cc 020130 -*/
+        if((i1&i)==0) return x;    /* x is integral */
+        if(big+x>0.0) {         /* raise inexact flag */
+        if(i0>0) {
+            if(j0==20) i0+=1;
+            else {
+            j = (uint32_t)(i1 + (1<<(52-j0)));
+            if(j<i1) i0+=1;    /* got a carry */
+            i1 = (int32_t)j;
+            }
+        }
+        i1 &= (~i);
+        }
+    }
+    HIGH(x) = i0;
+    LOW(x) = i1;
+    return x;
+}
+
+#else
+#include <math.h>
+#endif /* defined(NCSW_LINUX) && defined(__KERNEL__) */
+
+
+#endif /* __MATH_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/ncsw_ext.h b/drivers/net/dpa/NetCommSw/inc/ncsw_ext.h
new file mode 100644
index 0000000..139ff76
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/ncsw_ext.h
@@ -0,0 +1,383 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+ /**************************************************************************//**
+ @File          ncsw_ext.h
+
+ @Description   General NetCommSw Standard Definitions
+*//***************************************************************************/
+
+#ifndef __NCSW_EXT_H
+#define __NCSW_EXT_H
+
+#include "memcpy_ext.h"
+
+
+#define WRITE_BLOCK                 IOMemSet32
+#define COPY_BLOCK                  Mem2IOCpy32
+
+#define CAST_POINTER_TO_UINT32(val) ((uint32_t)((size_t)((void*)(val))))
+#define CAST_POINTER_TO_UINT64(val) ((uint64_t)((size_t)((void*)(val))))
+#define CAST_UINT32_TO_POINTER(val) ((void*)((size_t)((uint32_t)(val))))
+#define CAST_UINT64_TO_POINTER(val) ((void*)((size_t)((uint64_t)(val))))
+#define CAST_UINT32_TO_POINTER_TYPE(type,val) ((type*)((size_t)((uint32_t)(val))))
+#define CAST_UINT64_TO_POINTER_TYPE(type,val) ((type*)((size_t)((uint64_t)(val))))
+
+#define WRITE_UINT8_UINT24(arg, data08, data24) WRITE_UINT32(arg,((uint32_t)(data08)<<24)|((uint32_t)(data24)&0x00FFFFFF))
+#define WRITE_UINT24_UINT8(arg, data24, data08) WRITE_UINT32(arg,((uint32_t)(data24)<< 8)|((uint32_t)(data08)&0x000000FF))
+
+/* Little-Endian access macros */
+
+#define WRITE_UINT16_LE(arg, data) \
+        WRITE_UINT16((arg), SwapUint16(data))
+
+#define WRITE_UINT32_LE(arg, data) \
+        WRITE_UINT32((arg), SwapUint32(data))
+
+#define WRITE_UINT64_LE(arg, data) \
+        WRITE_UINT64((arg), SwapUint64(data))
+
+#define GET_UINT16_LE(arg) \
+        SwapUint16(GET_UINT16(arg))
+
+#define GET_UINT32_LE(arg) \
+        SwapUint32(GET_UINT32(arg))
+
+#define GET_UINT64_LE(arg) \
+        SwapUint64(GET_UINT64(arg))
+
+/* Write and Read again macros */
+#define WRITE_UINT_SYNC(size, arg, data)    \
+    do {                                    \
+        uint##size##_t temp;                \
+        WRITE_UINT##size((arg), (data));    \
+        temp = GET_UINT##size(arg);         \
+    } while (0)
+
+#define WRITE_UINT8_SYNC(arg, data)     WRITE_UINT_SYNC(8, (arg), (data))
+
+#define WRITE_UINT16_SYNC(arg, data)    WRITE_UINT_SYNC(16, (arg), (data))
+
+#define WRITE_UINT32_SYNC(arg, data)    WRITE_UINT_SYNC(32, (arg), (data))
+
+#define MAKE_UINT64(high32, low32)      (((uint64_t)high32 << 32) | (low32))
+
+
+/*----------------------*/
+/* Miscellaneous macros */
+/*----------------------*/
+
+#define UNUSED(X) (X=X)
+
+#define KILOBYTE            0x400       /* 1024 */
+#define MEGABYTE            0x100000    /* 1024*1024 */
+
+#define NO_IRQ              (-1)
+
+/* Macro for checking if a number is a power of 2 */
+#define POWER_OF_2(n)   (!((n) & ((n)-1)))
+
+/* Macro for calculating log of base 2 */
+#define LOG2(num, log2Num)                          \
+    do                                              \
+    {                                               \
+        uint64_t tmp = (num);                       \
+        log2Num = 0;                                \
+        while(tmp > 1)                              \
+        {                                           \
+            log2Num++;                              \
+            tmp = tmp >> 1;                         \
+        }                                           \
+    } while (0)
+
+/* Ceiling division - not the fastest way, but safer in terms of overflow */
+#define DIV_CEIL(x,y)   ((uint32_t)((x)/(y)) + (((((uint32_t)((x)/(y)))*(y)) == (x)) ? 0 : 1))
+
+/* Round division */
+#define DIV_ROUND(x,y)  (((x)+((y)>>1))/(y))
+
+/* Timing macro for converting usec units to number of ticks.   */
+/* (number of usec *  clock_Hz) / 1,000,000) - since            */
+/* clk is in MHz units, no division needed.                     */
+#define USEC_TO_CLK(usec,clk)       ((usec) * (clk))
+#define CYCLES_TO_USEC(cycles,clk)  ((cycles) / (clk))
+
+/* Timing macros for converting between nsec units and number of clocks. */
+#define NSEC_TO_CLK(nsec,clk)       DIV_CEIL(((nsec) * (clk)), 1000)
+#define CYCLES_TO_NSEC(cycles,clk)  (((cycles) * 1000) / (clk))
+
+/* Timing macros for converting between psec units and number of clocks. */
+#define PSEC_TO_CLK(psec,clk)       DIV_CEIL(((psec) * (clk)), 1000000)
+#define CYCLES_TO_PSEC(cycles,clk)  (((cycles) * 1000000) / (clk))
+
+/* Min, Max macros */
+#define MIN(a,b)    ((a) < (b) ? (a) : (b))
+#define MAX(a,b)    ((a) > (b) ? (a) : (b))
+#define IN_RANGE(min,val,max) ((min)<=(val) && (val)<=(max))
+
+#if !(defined(ARRAY_SIZE))
+#define ARRAY_SIZE(arr)   (sizeof(arr) / sizeof((arr)[0]))
+#endif /* !defined(ARRAY_SIZE) */
+
+
+/* possible alignments */
+#define HALF_WORD_ALIGNMENT     2
+#define WORD_ALIGNMENT          4
+#define DOUBLE_WORD_ALIGNMENT   8
+#define BURST_ALIGNMENT         32
+
+#define HALF_WORD_ALIGNED       0x00000001
+#define WORD_ALIGNED            0x00000003
+#define DOUBLE_WORD_ALIGNED     0x00000007
+#define BURST_ALIGNED           0x0000001f
+
+
+#define LAST_BUF        1
+#define FIRST_BUF       2
+#define SINGLE_BUF      (LAST_BUF | FIRST_BUF)
+#define MIDDLE_BUF      4
+
+#define ARRAY_END       -1
+
+#define ILLEGAL_BASE    (~0)
+
+#define BUF_POSITION(first, last)   state[(!!(last))<<1 | !!(first)]
+#define DECLARE_POSITION static uint8_t state[4] = { (uint8_t)MIDDLE_BUF, (uint8_t)FIRST_BUF, (uint8_t)LAST_BUF, (uint8_t)SINGLE_BUF };
+
+
+/**************************************************************************//**
+ @Description   Timers operation mode
+*//***************************************************************************/
+typedef enum e_TimerMode
+{
+    e_TIMER_MODE_INVALID = 0,
+    e_TIMER_MODE_FREE_RUN,    /**< Free run - counter continues to increase
+                                   after reaching the reference value. */
+    e_TIMER_MODE_PERIODIC,    /**< Periodic - counter restarts counting from 0
+                                   after reaching the reference value. */
+    e_TIMER_MODE_SINGLE       /**< Single (one-shot) - counter stops counting
+                                   after reaching the reference value. */
+} e_TimerMode;
+
+
+/**************************************************************************//**
+ @Description   Enumeration (bit flags) of communication modes (Transmit,
+                receive or both).
+*//***************************************************************************/
+typedef enum e_CommMode
+{
+      e_COMM_MODE_NONE         = 0  /**< No transmit/receive communication */
+    , e_COMM_MODE_RX           = 1  /**< Only receive communication */
+    , e_COMM_MODE_TX           = 2  /**< Only transmit communication */
+    , e_COMM_MODE_RX_AND_TX    = 3  /**< Both transmit and receive communication */
+} e_CommMode;
+
+/**************************************************************************//**
+ @Description   General Diagnostic Mode
+*//***************************************************************************/
+typedef enum e_DiagMode
+{
+    e_DIAG_MODE_NONE = 0,
+    e_DIAG_MODE_CTRL_LOOPBACK,
+    e_DIAG_MODE_PHY_LOOPBACK,
+    e_DIAG_MODE_LINE_LOOPBACK,
+    e_DIAG_MODE_CTRL_ECHO,
+    e_DIAG_MODE_PHY_ECHO
+
+} e_DiagMode;
+
+/**************************************************************************//**
+ @Description   Possible RxStore callback responses.
+*//***************************************************************************/
+typedef enum e_RxStoreResponse
+{
+      e_RX_STORE_RESPONSE_PAUSE     /**< Pause invoking callback with received data;
+                                         in polling mode, start again invoking callback
+                                         only next time user invokes the receive routine;
+                                         in interrupt mode, start again invoking callback
+                                         only next time a receive event triggers an interrupt;
+                                         in all cases, received data that are pending are not
+                                         lost, rather, their processing is temporarily deferred;
+                                         in all cases, received data are processed in the order
+                                         in which they were received. */
+    , e_RX_STORE_RESPONSE_CONTINUE  /**< Continue invoking callback with received data. */
+} e_RxStoreResponse;
+
+
+/**************************************************************************//**
+ @Description   General Handle
+*//***************************************************************************/
+typedef void *      t_Handle;   /**< handle, used as object's descriptor */
+
+/**************************************************************************//**
+ @Description   MUTEX type
+*//***************************************************************************/
+typedef uint32_t    t_Mutex;
+
+/**************************************************************************//**
+ @Description   Error Code.
+
+                The high word of the error code is the code of the software
+                module (driver). The low word is the error type (e_ErrorType).
+                To get the values from the error code, use GET_ERROR_TYPE()
+                and GET_ERROR_MODULE().
+*//***************************************************************************/
+typedef uint32_t    t_Error;
+
+
+/**************************************************************************//**
+ @Description   General prototype of interrupt service routine (ISR).
+
+ @Param[in]     handle - Optional handle of the module handling the interrupt.
+
+ @Return        None
+ *//***************************************************************************/
+typedef void (t_Isr)(t_Handle handle);
+
+
+/**************************************************************************//**
+ @Anchor        mem_attr
+
+ @Collection    Memory Attributes
+
+                Various attributes of memory partitions. These values may be
+                or'ed together to create a mask of all memory attributes.
+ @{
+*//***************************************************************************/
+#define MEMORY_ATTR_CACHEABLE           0x00000001
+                                        /**< Memory is cacheable */
+#define MEMORY_ATTR_QE_2ND_BUS_ACCESS   0x00000002
+                                        /**< Memory can be accessed by QUICC Engine
+                                             through its secondary bus interface */
+
+/* @} */
+
+
+/**************************************************************************//**
+ @Function      t_GetBufFunction
+
+ @Description   User callback function called by driver to get data buffer.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_BufferPool        - A handle to buffer pool manager
+ @Param[out]    p_BufContextHandle  - Returns the user's private context that
+                                      should be associated with the buffer
+
+ @Return        Pointer to data buffer, NULL if error
+ *//***************************************************************************/
+typedef uint8_t * (t_GetBufFunction)(t_Handle   h_BufferPool,
+                                     t_Handle   *p_BufContextHandle);
+
+/**************************************************************************//**
+ @Function      t_PutBufFunction
+
+ @Description   User callback function called by driver to return data buffer.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_BufferPool    - A handle to buffer pool manager
+ @Param[in]     p_Buffer        - A pointer to buffer to return
+ @Param[in]     h_BufContext    - The user's private context associated with
+                                  the returned buffer
+
+ @Return        E_OK on success; Error code otherwise
+ *//***************************************************************************/
+typedef t_Error (t_PutBufFunction)(t_Handle h_BufferPool,
+                                   uint8_t  *p_Buffer,
+                                   t_Handle h_BufContext);
+
+/**************************************************************************//**
+ @Description   Buffer Pool Information Structure.
+*//***************************************************************************/
+typedef struct t_BufferPoolInfo
+{
+    t_Handle            h_BufferPool;   /**< A handle to the buffer pool manager */
+    t_GetBufFunction    *f_GetBuf;      /**< User callback to get a free buffer */
+    t_PutBufFunction    *f_PutBuf;      /**< User callback to return a buffer */
+    uint16_t            bufferSize;     /**< Buffer size (in bytes) */
+
+} t_BufferPoolInfo;
+
+
+/**************************************************************************//**
+ @Description   User callback function called by driver when transmit completed.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_App           - Application's handle, as was provided to the
+                                  driver by the user
+ @Param[in]     queueId         - Transmit queue ID
+ @Param[in]     p_Data          - Pointer to the data buffer
+ @Param[in]     h_BufContext    - The user's private context associated with
+                                  the given data buffer
+ @Param[in]     status          - Transmit status and errors
+ @Param[in]     flags           - Driver-dependent information
+ *//***************************************************************************/
+typedef void (t_TxConfFunction)(t_Handle    h_App,
+                                uint32_t    queueId,
+                                uint8_t     *p_Data,
+                                t_Handle    h_BufContext,
+                                uint16_t    status,
+                                uint32_t    flags);
+
+/**************************************************************************//**
+ @Description   User callback function called by driver with receive data.
+
+                User provides this function. Driver invokes it.
+
+ @Param[in]     h_App           - Application's handle, as was provided to the
+                                  driver by the user
+ @Param[in]     queueId         - Receive queue ID
+ @Param[in]     p_Data          - Pointer to the buffer with received data
+ @Param[in]     h_BufContext    - The user's private context associated with
+                                  the given data buffer
+ @Param[in]     length          - Length of received data
+ @Param[in]     status          - Receive status and errors
+ @Param[in]     position        - Position of buffer in frame
+ @Param[in]     flags           - Driver-dependent information
+
+ @Retval        e_RX_STORE_RESPONSE_CONTINUE - order the driver to continue Rx
+                                               operation for all ready data.
+ @Retval        e_RX_STORE_RESPONSE_PAUSE    - order the driver to stop Rx operation.
+ *//***************************************************************************/
+typedef e_RxStoreResponse (t_RxStoreFunction)(t_Handle  h_App,
+                                              uint32_t  queueId,
+                                              uint8_t   *p_Data,
+                                              t_Handle  h_BufContext,
+                                              uint32_t  length,
+                                              uint16_t  status,
+                                              uint8_t   position,
+                                              uint32_t  flags);
+
+
+#endif /* __NCSW_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/net_ext.h b/drivers/net/dpa/NetCommSw/inc/net_ext.h
new file mode 100644
index 0000000..5a6bcd8
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/net_ext.h
@@ -0,0 +1,365 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          net_ext.h
+
+ @Description   This file contains common and general netcomm headers definitions.
+*//***************************************************************************/
+#ifndef __NET_EXT_H
+#define __NET_EXT_H
+
+#include "std_ext.h"
+
+
+typedef uint8_t headerFieldPpp_t;
+
+#define NET_HEADER_FIELD_PPP_PID                        (1)
+#define NET_HEADER_FIELD_PPP_COMPRESSED                 (NET_HEADER_FIELD_PPP_PID << 1)
+#define NET_HEADER_FIELD_PPP_ALL_FIELDS                 ((NET_HEADER_FIELD_PPP_PID << 2) - 1)
+
+
+typedef uint8_t headerFieldPppoe_t;
+
+#define NET_HEADER_FIELD_PPPoE_VER                      (1)
+#define NET_HEADER_FIELD_PPPoE_TYPE                     (NET_HEADER_FIELD_PPPoE_VER << 1)
+#define NET_HEADER_FIELD_PPPoE_CODE                     (NET_HEADER_FIELD_PPPoE_VER << 2)
+#define NET_HEADER_FIELD_PPPoE_SID                      (NET_HEADER_FIELD_PPPoE_VER << 3)
+#define NET_HEADER_FIELD_PPPoE_LEN                      (NET_HEADER_FIELD_PPPoE_VER << 4)
+#define NET_HEADER_FIELD_PPPoE_SESSION                  (NET_HEADER_FIELD_PPPoE_VER << 5)
+#define NET_HEADER_FIELD_PPPoE_PID                      (NET_HEADER_FIELD_PPPoE_VER << 6)
+#define NET_HEADER_FIELD_PPPoE_ALL_FIELDS               ((NET_HEADER_FIELD_PPPoE_VER << 7) - 1)
+
+#define NET_HEADER_FIELD_PPPMUX_PID                     (1)
+#define NET_HEADER_FIELD_PPPMUX_CKSUM                   (NET_HEADER_FIELD_PPPMUX_PID << 1)
+#define NET_HEADER_FIELD_PPPMUX_COMPRESSED              (NET_HEADER_FIELD_PPPMUX_PID << 2)
+#define NET_HEADER_FIELD_PPPMUX_ALL_FIELDS              ((NET_HEADER_FIELD_PPPMUX_PID << 3) - 1)
+
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF            (1)
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_LXT            (NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 1)
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_LEN            (NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 2)
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_PID            (NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 3)
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_USE_PID        (NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 4)
+#define NET_HEADER_FIELD_PPPMUX_SUBFRAME_ALL_FIELDS     ((NET_HEADER_FIELD_PPPMUX_SUBFRAME_PFF << 5) - 1)
+
+
+typedef uint8_t headerFieldEth_t;
+
+#define NET_HEADER_FIELD_ETH_DA                         (1)
+#define NET_HEADER_FIELD_ETH_SA                         (NET_HEADER_FIELD_ETH_DA << 1)
+#define NET_HEADER_FIELD_ETH_LENGTH                     (NET_HEADER_FIELD_ETH_DA << 2)
+#define NET_HEADER_FIELD_ETH_TYPE                       (NET_HEADER_FIELD_ETH_DA << 3)
+#define NET_HEADER_FIELD_ETH_FINAL_CKSUM                (NET_HEADER_FIELD_ETH_DA << 4)
+#define NET_HEADER_FIELD_ETH_PADDING                    (NET_HEADER_FIELD_ETH_DA << 5)
+#define NET_HEADER_FIELD_ETH_ALL_FIELDS                 ((NET_HEADER_FIELD_ETH_DA << 6) - 1)
+
+
+typedef uint16_t headerFieldIpv4_t;
+
+#define NET_HEADER_FIELD_IPv4_VER                       (1)
+#define NET_HEADER_FIELD_IPv4_HDR_LEN                   (NET_HEADER_FIELD_IPv4_VER << 1)
+#define NET_HEADER_FIELD_IPv4_TOS                       (NET_HEADER_FIELD_IPv4_VER << 2)
+#define NET_HEADER_FIELD_IPv4_TOTAL_LEN                 (NET_HEADER_FIELD_IPv4_VER << 3)
+#define NET_HEADER_FIELD_IPv4_ID                        (NET_HEADER_FIELD_IPv4_VER << 4)
+#define NET_HEADER_FIELD_IPv4_FLAG_D                    (NET_HEADER_FIELD_IPv4_VER << 5)
+#define NET_HEADER_FIELD_IPv4_FLAG_M                    (NET_HEADER_FIELD_IPv4_VER << 6)
+#define NET_HEADER_FIELD_IPv4_OFFSET                    (NET_HEADER_FIELD_IPv4_VER << 7)
+#define NET_HEADER_FIELD_IPv4_TTL                       (NET_HEADER_FIELD_IPv4_VER << 8)
+#define NET_HEADER_FIELD_IPv4_PROTO                     (NET_HEADER_FIELD_IPv4_VER << 9)
+#define NET_HEADER_FIELD_IPv4_CKSUM                     (NET_HEADER_FIELD_IPv4_VER << 10)
+#define NET_HEADER_FIELD_IPv4_SRC_IP                    (NET_HEADER_FIELD_IPv4_VER << 11)
+#define NET_HEADER_FIELD_IPv4_DST_IP                    (NET_HEADER_FIELD_IPv4_VER << 12)
+#define NET_HEADER_FIELD_IPv4_OPTS                      (NET_HEADER_FIELD_IPv4_VER << 13)
+#define NET_HEADER_FIELD_IPv4_OPTS_COUNT                (NET_HEADER_FIELD_IPv4_VER << 14)
+#define NET_HEADER_FIELD_IPv4_ALL_FIELDS                ((NET_HEADER_FIELD_IPv4_VER << 15) - 1)
+
+
+typedef uint8_t headerFieldIpv6_t;
+
+#define NET_HEADER_FIELD_IPv6_VER                       (1)
+#define NET_HEADER_FIELD_IPv6_TC                        (NET_HEADER_FIELD_IPv6_VER << 1)
+#define NET_HEADER_FIELD_IPv6_SRC_IP                    (NET_HEADER_FIELD_IPv6_VER << 2)
+#define NET_HEADER_FIELD_IPv6_DST_IP                    (NET_HEADER_FIELD_IPv6_VER << 3)
+#define NET_HEADER_FIELD_IPv6_NEXT_HDR                  (NET_HEADER_FIELD_IPv6_VER << 4)
+#define NET_HEADER_FIELD_IPv6_FL                        (NET_HEADER_FIELD_IPv6_VER << 5)
+#define NET_HEADER_FIELD_IPv6_HOP_LIMIT                 (NET_HEADER_FIELD_IPv6_VER << 6)
+#define NET_HEADER_FIELD_IPv6_ALL_FIELDS                ((NET_HEADER_FIELD_IPv6_VER << 7) - 1)
+
+#define NET_HEADER_FIELD_ICMP_TYPE                      (1)
+#define NET_HEADER_FIELD_ICMP_CODE                      (NET_HEADER_FIELD_ICMP_TYPE << 1)
+#define NET_HEADER_FIELD_ICMP_CKSUM                     (NET_HEADER_FIELD_ICMP_TYPE << 2)
+#define NET_HEADER_FIELD_ICMP_ID                        (NET_HEADER_FIELD_ICMP_TYPE << 3)
+#define NET_HEADER_FIELD_ICMP_SQ_NUM                    (NET_HEADER_FIELD_ICMP_TYPE << 4)
+#define NET_HEADER_FIELD_ICMP_ALL_FIELDS                ((NET_HEADER_FIELD_ICMP_TYPE << 5) - 1)
+
+#define NET_HEADER_FIELD_IGMP_VERSION                   (1)
+#define NET_HEADER_FIELD_IGMP_TYPE                      (NET_HEADER_FIELD_IGMP_VERSION << 1)
+#define NET_HEADER_FIELD_IGMP_CKSUM                     (NET_HEADER_FIELD_IGMP_VERSION << 2)
+#define NET_HEADER_FIELD_IGMP_DATA                      (NET_HEADER_FIELD_IGMP_VERSION << 3)
+#define NET_HEADER_FIELD_IGMP_ALL_FIELDS                ((NET_HEADER_FIELD_IGMP_VERSION << 4) - 1)
+
+
+typedef uint16_t headerFieldTcp_t;
+
+#define NET_HEADER_FIELD_TCP_PORT_SRC                   (1)
+#define NET_HEADER_FIELD_TCP_PORT_DST                   (NET_HEADER_FIELD_TCP_PORT_SRC << 1)
+#define NET_HEADER_FIELD_TCP_SEQ                        (NET_HEADER_FIELD_TCP_PORT_SRC << 2)
+#define NET_HEADER_FIELD_TCP_ACK                        (NET_HEADER_FIELD_TCP_PORT_SRC << 3)
+#define NET_HEADER_FIELD_TCP_OFFSET                     (NET_HEADER_FIELD_TCP_PORT_SRC << 4)
+#define NET_HEADER_FIELD_TCP_FLAGS                      (NET_HEADER_FIELD_TCP_PORT_SRC << 5)
+#define NET_HEADER_FIELD_TCP_WINDOW                     (NET_HEADER_FIELD_TCP_PORT_SRC << 6)
+#define NET_HEADER_FIELD_TCP_CKSUM                      (NET_HEADER_FIELD_TCP_PORT_SRC << 7)
+#define NET_HEADER_FIELD_TCP_URGPTR                     (NET_HEADER_FIELD_TCP_PORT_SRC << 8)
+#define NET_HEADER_FIELD_TCP_OPTS                       (NET_HEADER_FIELD_TCP_PORT_SRC << 9)
+#define NET_HEADER_FIELD_TCP_OPTS_COUNT                 (NET_HEADER_FIELD_TCP_PORT_SRC << 10)
+#define NET_HEADER_FIELD_TCP_ALL_FIELDS                 ((NET_HEADER_FIELD_TCP_PORT_SRC << 11) - 1)
+
+
+typedef uint8_t headerFieldSctp_t;
+
+#define NET_HEADER_FIELD_SCTP_PORT_SRC                  (1)
+#define NET_HEADER_FIELD_SCTP_PORT_DST                  (NET_HEADER_FIELD_SCTP_PORT_SRC << 1)
+#define NET_HEADER_FIELD_SCTP_VER_TAG                   (NET_HEADER_FIELD_SCTP_PORT_SRC << 2)
+#define NET_HEADER_FIELD_SCTP_CKSUM                     (NET_HEADER_FIELD_SCTP_PORT_SRC << 3)
+#define NET_HEADER_FIELD_SCTP_ALL_FIELDS                ((NET_HEADER_FIELD_SCTP_PORT_SRC << 4) - 1)
+
+
+typedef uint8_t headerFieldDccp_t;
+
+#define NET_HEADER_FIELD_DCCP_PORT_SRC                  (1)
+#define NET_HEADER_FIELD_DCCP_PORT_DST                  (NET_HEADER_FIELD_DCCP_PORT_SRC << 1)
+#define NET_HEADER_FIELD_DCCP_ALL_FIELDS                ((NET_HEADER_FIELD_DCCP_PORT_SRC << 2) - 1)
+
+
+typedef uint8_t headerFieldUdp_t;
+
+#define NET_HEADER_FIELD_UDP_PORT_SRC                   (1)
+#define NET_HEADER_FIELD_UDP_PORT_DST                   (NET_HEADER_FIELD_UDP_PORT_SRC << 1)
+#define NET_HEADER_FIELD_UDP_LEN                        (NET_HEADER_FIELD_UDP_PORT_SRC << 2)
+#define NET_HEADER_FIELD_UDP_CKSUM                      (NET_HEADER_FIELD_UDP_PORT_SRC << 3)
+#define NET_HEADER_FIELD_UDP_ALL_FIELDS                 ((NET_HEADER_FIELD_UDP_PORT_SRC << 4) - 1)
+
+#define NET_HEADER_FIELD_IPHC_CID                       (1)
+#define NET_HEADER_FIELD_IPHC_CID_TYPE                  (NET_HEADER_FIELD_IPHC_CID << 1)
+#define NET_HEADER_FIELD_IPHC_HCINDEX                   (NET_HEADER_FIELD_IPHC_CID << 2)
+#define NET_HEADER_FIELD_IPHC_GEN                       (NET_HEADER_FIELD_IPHC_CID << 3)
+#define NET_HEADER_FIELD_IPHC_D_BIT                     (NET_HEADER_FIELD_IPHC_CID << 4)
+#define NET_HEADER_FIELD_IPHC_ALL_FIELDS                ((NET_HEADER_FIELD_IPHC_CID << 5) - 1)
+
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE           (1)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_FLAGS          (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 1)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_LENGTH         (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 2)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_TSN            (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 3)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_ID      (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 4)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_STREAM_SQN     (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 5)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_PAYLOAD_PID    (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 6)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_UNORDERED      (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 7)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_BEGGINING      (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 8)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_END            (NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 9)
+#define NET_HEADER_FIELD_SCTP_CHUNK_DATA_ALL_FIELDS     ((NET_HEADER_FIELD_SCTP_CHUNK_DATA_TYPE << 10) - 1)
+
+#define NET_HEADER_FIELD_L2TPv2_TYPE_BIT                (1)
+#define NET_HEADER_FIELD_L2TPv2_LENGTH_BIT              (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 1)
+#define NET_HEADER_FIELD_L2TPv2_SEQUENCE_BIT            (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 2)
+#define NET_HEADER_FIELD_L2TPv2_OFFSET_BIT              (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 3)
+#define NET_HEADER_FIELD_L2TPv2_PRIORITY_BIT            (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 4)
+#define NET_HEADER_FIELD_L2TPv2_VERSION                 (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 5)
+#define NET_HEADER_FIELD_L2TPv2_LEN                     (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 6)
+#define NET_HEADER_FIELD_L2TPv2_TUNNEL_ID               (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 7)
+#define NET_HEADER_FIELD_L2TPv2_SESSION_ID              (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 8)
+#define NET_HEADER_FIELD_L2TPv2_NS                      (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 9)
+#define NET_HEADER_FIELD_L2TPv2_NR                      (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 10)
+#define NET_HEADER_FIELD_L2TPv2_OFFSET_SIZE             (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 11)
+#define NET_HEADER_FIELD_L2TPv2_FIRST_BYTE              (NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 12)
+#define NET_HEADER_FIELD_L2TPv2_ALL_FIELDS              ((NET_HEADER_FIELD_L2TPv2_TYPE_BIT << 13) - 1)
+
+#define NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT           (1)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH_BIT         (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 1)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_SEQUENCE_BIT       (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 2)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_VERSION            (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 3)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_LENGTH             (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 4)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_CONTROL            (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 5)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_SENT               (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 6)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_RECV               (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 7)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_FIRST_BYTE         (NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 8)
+#define NET_HEADER_FIELD_L2TPv3_CTRL_ALL_FIELDS         ((NET_HEADER_FIELD_L2TPv3_CTRL_TYPE_BIT << 9) - 1)
+
+#define NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT           (1)
+#define NET_HEADER_FIELD_L2TPv3_SESS_VERSION            (NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 1)
+#define NET_HEADER_FIELD_L2TPv3_SESS_ID                 (NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 2)
+#define NET_HEADER_FIELD_L2TPv3_SESS_COOKIE             (NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 3)
+#define NET_HEADER_FIELD_L2TPv3_SESS_ALL_FIELDS         ((NET_HEADER_FIELD_L2TPv3_SESS_TYPE_BIT << 4) - 1)
+
+
+typedef uint8_t headerFieldVlan_t;
+
+#define NET_HEADER_FIELD_VLAN_VPRI                      (1)
+#define NET_HEADER_FIELD_VLAN_CFI                       (NET_HEADER_FIELD_VLAN_VPRI << 1)
+#define NET_HEADER_FIELD_VLAN_VID                       (NET_HEADER_FIELD_VLAN_VPRI << 2)
+#define NET_HEADER_FIELD_VLAN_LENGTH                    (NET_HEADER_FIELD_VLAN_VPRI << 3)
+#define NET_HEADER_FIELD_VLAN_TYPE                      (NET_HEADER_FIELD_VLAN_VPRI << 4)
+#define NET_HEADER_FIELD_VLAN_TCI                       (NET_HEADER_FIELD_VLAN_VPRI << 5)
+#define NET_HEADER_FIELD_VLAN_ALL_FIELDS                ((NET_HEADER_FIELD_VLAN_VPRI << 6) - 1)
+
+
+typedef uint8_t headerFieldLlc_t;
+
+#define NET_HEADER_FIELD_LLC_DSAP                       (1)
+#define NET_HEADER_FIELD_LLC_SSAP                       (NET_HEADER_FIELD_LLC_DSAP << 1)
+#define NET_HEADER_FIELD_LLC_CTRL                       (NET_HEADER_FIELD_LLC_DSAP << 2)
+#define NET_HEADER_FIELD_LLC_ALL_FIELDS                 ((NET_HEADER_FIELD_LLC_DSAP << 3) - 1)
+
+#define NET_HEADER_FIELD_NLPID_NLPID                    (1)
+#define NET_HEADER_FIELD_NLPID_ALL_FIELDS               ((NET_HEADER_FIELD_NLPID_NLPID << 1) - 1)
+
+
+typedef uint8_t headerFieldSnap_t;
+
+#define NET_HEADER_FIELD_SNAP_OUI                       (1)
+#define NET_HEADER_FIELD_SNAP_PID                       (NET_HEADER_FIELD_SNAP_OUI << 1)
+#define NET_HEADER_FIELD_SNAP_ALL_FIELDS                ((NET_HEADER_FIELD_SNAP_OUI << 2) - 1)
+
+
+typedef uint8_t headerFieldLlcSnap_t;
+
+#define NET_HEADER_FIELD_LLC_SNAP_TYPE                  (1)
+#define NET_HEADER_FIELD_LLC_SNAP_ALL_FIELDS            ((NET_HEADER_FIELD_LLC_SNAP_ALL_FIELDS << 1) - 1)
+
+#define NET_HEADER_FIELD_ARP_HTYPE                      (1)
+#define NET_HEADER_FIELD_ARP_PTYPE                      (NET_HEADER_FIELD_ARP_HTYPE << 1)
+#define NET_HEADER_FIELD_ARP_HLEN                       (NET_HEADER_FIELD_ARP_HTYPE << 2)
+#define NET_HEADER_FIELD_ARP_PLEN                       (NET_HEADER_FIELD_ARP_HTYPE << 3)
+#define NET_HEADER_FIELD_ARP_OPER                       (NET_HEADER_FIELD_ARP_HTYPE << 4)
+#define NET_HEADER_FIELD_ARP_SHA                        (NET_HEADER_FIELD_ARP_HTYPE << 5)
+#define NET_HEADER_FIELD_ARP_SPA                        (NET_HEADER_FIELD_ARP_HTYPE << 6)
+#define NET_HEADER_FIELD_ARP_THA                        (NET_HEADER_FIELD_ARP_HTYPE << 7)
+#define NET_HEADER_FIELD_ARP_TPA                        (NET_HEADER_FIELD_ARP_HTYPE << 8)
+#define NET_HEADER_FIELD_ARP_ALL_FIELDS                 ((NET_HEADER_FIELD_ARP_HTYPE << 9) - 1)
+
+#define NET_HEADER_FIELD_RFC2684_LLC                    (1)
+#define NET_HEADER_FIELD_RFC2684_NLPID                  (NET_HEADER_FIELD_RFC2684_LLC << 1)
+#define NET_HEADER_FIELD_RFC2684_OUI                    (NET_HEADER_FIELD_RFC2684_LLC << 2)
+#define NET_HEADER_FIELD_RFC2684_PID                    (NET_HEADER_FIELD_RFC2684_LLC << 3)
+#define NET_HEADER_FIELD_RFC2684_VPN_OUI                (NET_HEADER_FIELD_RFC2684_LLC << 4)
+#define NET_HEADER_FIELD_RFC2684_VPN_IDX                (NET_HEADER_FIELD_RFC2684_LLC << 5)
+#define NET_HEADER_FIELD_RFC2684_ALL_FIELDS             ((NET_HEADER_FIELD_RFC2684_LLC << 6) - 1)
+
+#define NET_HEADER_FIELD_USER_DEFINED_SRCPORT           (1)
+#define NET_HEADER_FIELD_USER_DEFINED_PCDID             (NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 1)
+#define NET_HEADER_FIELD_USER_DEFINED_ALL_FIELDS        ((NET_HEADER_FIELD_USER_DEFINED_SRCPORT << 2) - 1)
+
+#define NET_HEADER_FIELD_PAYLOAD_BUFFER                 (1)
+#define NET_HEADER_FIELD_PAYLOAD_SIZE                   (NET_HEADER_FIELD_PAYLOAD_BUFFER << 1)
+#define NET_HEADER_FIELD_MAX_FRM_SIZE                   (NET_HEADER_FIELD_PAYLOAD_BUFFER << 2)
+#define NET_HEADER_FIELD_MIN_FRM_SIZE                   (NET_HEADER_FIELD_PAYLOAD_BUFFER << 3)
+#define NET_HEADER_FIELD_PAYLOAD_TYPE                   (NET_HEADER_FIELD_PAYLOAD_BUFFER << 4)
+#define NET_HEADER_FIELD_FRAME_SIZE                     (NET_HEADER_FIELD_PAYLOAD_BUFFER << 5)
+#define NET_HEADER_FIELD_PAYLOAD_ALL_FIELDS             ((NET_HEADER_FIELD_PAYLOAD_BUFFER << 6) - 1)
+
+
+typedef uint8_t headerFieldGre_t;
+
+#define NET_HEADER_FIELD_GRE_TYPE                       (1)
+#define NET_HEADER_FIELD_GRE_ALL_FIELDS                 ((NET_HEADER_FIELD_GRE_TYPE << 1) - 1)
+
+
+typedef uint8_t headerFieldMinencap_t;
+
+#define NET_HEADER_FIELD_MINENCAP_SRC_IP                (1)
+#define NET_HEADER_FIELD_MINENCAP_DST_IP                (NET_HEADER_FIELD_MINENCAP_SRC_IP << 1)
+#define NET_HEADER_FIELD_MINENCAP_TYPE                  (NET_HEADER_FIELD_MINENCAP_SRC_IP << 2)
+#define NET_HEADER_FIELD_MINENCAP_ALL_FIELDS            ((NET_HEADER_FIELD_MINENCAP_SRC_IP << 3) - 1)
+
+
+typedef uint8_t headerFieldIpsecAh_t;
+
+#define NET_HEADER_FIELD_IPSEC_AH_SPI                   (1)
+#define NET_HEADER_FIELD_IPSEC_AH_NH                    (NET_HEADER_FIELD_IPSEC_AH_SPI << 1)
+#define NET_HEADER_FIELD_IPSEC_AH_ALL_FIELDS            ((NET_HEADER_FIELD_IPSEC_AH_SPI << 2) - 1)
+
+
+typedef uint8_t headerFieldIpsecEsp_t;
+
+#define NET_HEADER_FIELD_IPSEC_ESP_SPI                  (1)
+#define NET_HEADER_FIELD_IPSEC_ESP_ALL_FIELDS           ((NET_HEADER_FIELD_IPSEC_ESP_SPI << 1) - 1)
+
+
+typedef uint8_t headerFieldMpls_t;
+
+#define NET_HEADER_FIELD_MPLS_LABEL_STACK               (1)
+#define NET_HEADER_FIELD_MPLS_LABEL_STACK_ALL_FIELDS    ((NET_HEADER_FIELD_MPLS_LABEL_STACK << 1) - 1)
+
+
+typedef enum {
+    HEADER_TYPE_NONE = 0,
+    HEADER_TYPE_PAYLOAD,
+    HEADER_TYPE_ETH,
+    HEADER_TYPE_VLAN,
+    HEADER_TYPE_IPv4,
+    HEADER_TYPE_IPv6,
+    HEADER_TYPE_TCP,
+    HEADER_TYPE_UDP,
+    HEADER_TYPE_IPHC,
+    HEADER_TYPE_SCTP,
+    HEADER_TYPE_SCTP_CHUNK_DATA,
+    HEADER_TYPE_PPPoE,
+    HEADER_TYPE_PPP,
+    HEADER_TYPE_PPPMUX,
+    HEADER_TYPE_PPPMUX_SUBFRAME,
+    HEADER_TYPE_L2TPv2,
+    HEADER_TYPE_L2TPv3_CTRL,
+    HEADER_TYPE_L2TPv3_SESS,
+    HEADER_TYPE_LLC,
+    HEADER_TYPE_LLC_SNAP,
+    HEADER_TYPE_NLPID,
+    HEADER_TYPE_SNAP,
+    HEADER_TYPE_MPLS,
+    HEADER_TYPE_IPSEC_AH,
+    HEADER_TYPE_IPSEC_ESP,
+    HEADER_TYPE_GRE,
+    HEADER_TYPE_MINENCAP,
+    HEADER_TYPE_DCCP,
+    HEADER_TYPE_ICMP,
+    HEADER_TYPE_IGMP,
+    HEADER_TYPE_ARP,
+    HEADER_TYPE_RFC2684,
+    HEADER_TYPE_USER_DEFINED_L2,
+    HEADER_TYPE_USER_DEFINED_L3,
+    HEADER_TYPE_USER_DEFINED_L4,
+    HEADER_TYPE_USER_DEFINED_SHIM1,
+    HEADER_TYPE_USER_DEFINED_SHIM2,
+    HEADER_TYPE_USER_DEFINED_SHIM3,
+    MAX_HEADER_TYPE_COUNT
+} e_NetHeaderType;
+
+
+#endif /* __NET_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/std_ext.h b/drivers/net/dpa/NetCommSw/inc/std_ext.h
new file mode 100644
index 0000000..ff4698a
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/std_ext.h
@@ -0,0 +1,48 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+ /**************************************************************************//**
+
+ @File          std_ext.h
+
+ @Description   General Standard Definitions
+*//***************************************************************************/
+
+#ifndef __STD_EXT_H
+#define __STD_EXT_H
+
+
+#include "types_ext.h"
+#include "ncsw_ext.h"
+
+
+#endif /* __STD_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/stdarg_ext.h b/drivers/net/dpa/NetCommSw/inc/stdarg_ext.h
new file mode 100644
index 0000000..091bd60
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/stdarg_ext.h
@@ -0,0 +1,48 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __STDARG_EXT_H
+#define __STDARG_EXT_H
+
+
+#if defined(NCSW_LINUX) && defined(__KERNEL__)
+#include <stdarg.h>
+
+#else
+#include <stdarg.h>
+
+#endif /* defined(NCSW_LINUX) && defined(__KERNEL__) */
+
+#include "std_ext.h"
+
+
+#endif /* __STDARG_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/stdlib_ext.h b/drivers/net/dpa/NetCommSw/inc/stdlib_ext.h
new file mode 100644
index 0000000..43b1d77
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/stdlib_ext.h
@@ -0,0 +1,164 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef __STDLIB_EXT_H
+#define __STDLIB_EXT_H
+
+
+#if (defined(MWI_UBOOT) || defined(NCSW_LINUX)) && defined(__KERNEL__)
+#include "stdarg_ext.h"
+#include "std_ext.h"
+
+
+/**
+ * strtoul - convert a string to an uint32_t
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+uint32_t strtoul(const char *cp,char **endp,uint32_t base);
+
+/**
+ * strtol - convert a string to a int32_t
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+long strtol(const char *cp,char **endp,uint32_t base);
+
+/**
+ * strtoull - convert a string to an uint64_t
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+uint64_t strtoull(const char *cp,char **endp,uint32_t base);
+
+/**
+ * strtoll - convert a string to a int64 long
+ * @cp: The start of the string
+ * @endp: A pointer to the end of the parsed string will be placed here
+ * @base: The number base to use
+ */
+long long strtoll(const char *cp,char **endp,uint32_t base);
+
+/**
+ * atoi - convert a character to a int
+ * @s: The start of the string
+ */
+int atoi(const char *s);
+
+/**
+ * strnlen - Find the length of a length-limited string
+ * @s: The string to be sized
+ * @count: The maximum number of bytes to search
+ */
+size_t strnlen(const char * s, size_t count);
+
+/**
+ * strlen - Find the length of a string
+ * @s: The string to be sized
+ */
+size_t strlen(const char * s);
+
+/**
+ * strtok - Split a string into tokens
+ * @s: The string to be searched
+ * @ct: The characters to search for
+ *
+ * WARNING: strtok is deprecated, use strsep instead.
+ */
+char * strtok(char * s,const char * ct);
+
+/**
+ * strncpy - Copy a length-limited, %NUL-terminated string
+ * @dest: Where to copy the string to
+ * @src: Where to copy the string from
+ * @count: The maximum number of bytes to copy
+ *
+ * Note that unlike userspace strncpy, this does not %NUL-pad the buffer.
+ * However, the result is not %NUL-terminated if the source exceeds
+ * @count bytes.
+ */
+char * strncpy(char * dest,const char *src,size_t count);
+
+/**
+ * strcpy - Copy a %NUL terminated string
+ * @dest: Where to copy the string to
+ * @src: Where to copy the string from
+ */
+char * strcpy(char * dest,const char *src);
+
+/**
+ * vsscanf - Unformat a buffer into a list of arguments
+ * @buf:    input buffer
+ * @fmt:    format of buffer
+ * @args:    arguments
+ */
+int vsscanf(const char * buf, const char * fmt, va_list args);
+
+/**
+ * vsnprintf - Format a string and place it in a buffer
+ * @buf: The buffer to place the result into
+ * @size: The size of the buffer, including the trailing null space
+ * @fmt: The format string to use
+ * @args: Arguments for the format string
+ *
+ * Call this function if you are already dealing with a va_list.
+ * You probably want snprintf instead.
+ */
+int vsnprintf(char *buf, size_t size, const char *fmt, va_list args);
+
+/**
+ * vsprintf - Format a string and place it in a buffer
+ * @buf: The buffer to place the result into
+ * @fmt: The format string to use
+ * @args: Arguments for the format string
+ *
+ * Call this function if you are already dealing with a va_list.
+ * You probably want sprintf instead.
+ */
+int vsprintf(char *buf, const char *fmt, va_list args);
+
+#elif defined(MWI_VXWORKS)
+#include "stdlib.h"
+
+#else
+#include <stdlib.h>
+#include <stdio.h>
+#endif /* defined(NCSW_LINUX) && defined(__KERNEL__) */
+
+#include "std_ext.h"
+
+
+#endif /* __STDLIB_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/string_ext.h b/drivers/net/dpa/NetCommSw/inc/string_ext.h
new file mode 100644
index 0000000..b9aa8f2
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/string_ext.h
@@ -0,0 +1,58 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __STRING_EXT_H
+#define __STRING_EXT_H
+
+
+#if defined(NCSW_LINUX) && defined(__KERNEL__)
+#include <linux/kernel.h>
+#include <linux/string.h>
+extern char * strtok ( char * str, const char * delimiters );
+
+#elif defined(MWI_VXWORKS)
+#include "string.h"
+
+#elif defined(MWI_UBOOT) || defined(__KERNEL__)
+#include "linux/types.h"
+#include "linux/posix_types.h"
+#include "linux/string.h"
+
+#else
+#include <string.h>
+
+#endif /* defined(NCSW_LINUX) && defined(__KERNEL__) */
+
+#include "std_ext.h"
+
+
+#endif /* __STRING_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/types_ext.h b/drivers/net/dpa/NetCommSw/inc/types_ext.h
new file mode 100644
index 0000000..4a993d4
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/types_ext.h
@@ -0,0 +1,94 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+ /**************************************************************************//**
+ @File          types_ext.h
+
+ @Description   General types Standard Definitions
+*//***************************************************************************/
+
+#ifndef __TYPES_EXT_H
+#define __TYPES_EXT_H
+
+
+#if defined (__ROCOO__)
+#include "types_rocoo.h"
+
+#elif defined (NCSW_LINUX)
+#include "types_linux.h"
+
+#elif defined (NCSW_VXWORKS)
+#include "types_vxworks.h"
+
+#elif defined (__MWERKS__) && defined (__GNUC__)
+#include "types_bb_gcc.h"
+
+#else
+#include "types_dflt.h"
+#endif /* defined (__ROCOO__) */
+
+
+static __inline__ void TypesChecker(void)
+{
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+     _Packed struct strct {
+        __volatile__ int vi;
+    } _PackedType;
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+    size_t          size=0;
+    int             on=ON, off=OFF;
+    bool            tr=TRUE,fls=FALSE;
+    struct strct    *p_Strct = NULL;
+
+    on=off;
+    tr=fls;
+    p_Strct=p_Strct;
+    size++;
+
+    WRITE_UINT8(*(uint8_t *)UINT8_MAX, GET_UINT8(*(uint8_t *)UINT8_MIN));
+    WRITE_UINT16(*(uint16_t *)UINT16_MAX, GET_UINT16(*(uint16_t *)UINT16_MIN));
+    WRITE_UINT32(*(uint32_t *)UINT32_MAX, GET_UINT32(*(uint32_t *)UINT32_MIN));
+    WRITE_UINT64(*(uint64_t *)UINT64_MAX, GET_UINT64(*(uint64_t *)UINT64_MIN));
+    WRITE_UINT8(*(uint8_t *)INT8_MAX, GET_UINT8(*(uint8_t *)UINT8_MIN));
+    WRITE_UINT16(*(uint16_t *)INT16_MAX, GET_UINT16(*(uint16_t *)INT16_MIN));
+    WRITE_UINT32(*(uint32_t *)INT32_MAX, GET_UINT32(*(uint32_t *)INT32_MIN));
+    WRITE_UINT64(*(uint64_t *)INT64_MAX, GET_UINT64(*(uint64_t *)INT64_MIN));
+}
+
+
+#endif /* __TYPES_EXT_H */
diff --git a/drivers/net/dpa/NetCommSw/inc/xx_ext.h b/drivers/net/dpa/NetCommSw/inc/xx_ext.h
new file mode 100644
index 0000000..5adca3c
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/inc/xx_ext.h
@@ -0,0 +1,818 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          xx_ext.h
+
+ @Description   Prototypes, externals and typedefs for system-supplied
+                (external) routines
+*//***************************************************************************/
+
+#ifndef __XX_EXT_H
+#define __XX_EXT_H
+
+#include "std_ext.h"
+#include "part_ext.h"
+
+#if defined(__MWERKS__) && defined(OPTIMIZED_FOR_SPEED)
+#include "xx_integration_ext.h"
+#endif /* defined(__MWERKS__) && defined(OPTIMIZED_FOR_SPEED) */
+
+/**************************************************************************//**
+ @Group         xx_id  XX Interface (System call hooks)
+
+ @Description   Prototypes, externals and typedefs for system-supplied
+                (external) routines
+
+ @{
+*//***************************************************************************/
+
+#if (defined(REPORT_EVENTS) && (REPORT_EVENTS > 0))
+/**************************************************************************//**
+ @Function      XX_EventById
+
+ @Description   Event reporting routine - executed only when REPORT_EVENTS=1.
+
+ @Param[in]     event - Event code (e_Event).
+ @Param[in]     appId - Application identifier.
+ @Param[in]     flags - Event flags.
+ @Param[in]     msg   - Event message.
+
+ @Return        None
+*//***************************************************************************/
+void XX_EventById(uint32_t event, t_Handle appId, uint16_t flags, char *msg);
+
+#else  /* not REPORT_EVENTS */
+#define XX_EventById(event, appId, flags, msg)
+#endif /* REPORT_EVENTS */
+
+
+
+#ifdef DEBUG_XX_MALLOC
+
+void * XX_MallocDebug(uint32_t size, char *fname, int line);
+
+void * XX_MallocSmartDebug(uint32_t size,
+                           int      memPartitionId,
+                           uint32_t align,
+                           char     *fname,
+                           int      line);
+
+#define XX_Malloc(sz) \
+    XX_MallocDebug((sz), __FILE__, __LINE__)
+
+#define XX_MallocSmart(sz, memt, al) \
+    XX_MallocSmartDebug((sz), (memt), (al), __FILE__, __LINE__)
+
+#else /* not DEBUG_XX_MALLOC */
+
+/**************************************************************************//**
+ @Function      XX_Malloc
+
+ @Description   allocates contiguous block of memory.
+
+ @Param[in]     size - Number of bytes to allocate.
+
+ @Return        The address of the newly allocated block on success, NULL on failure.
+*//***************************************************************************/
+void * XX_Malloc(uint32_t size);
+
+/**************************************************************************//**
+ @Function      XX_MallocSmart
+
+ @Description   Allocates contiguous block of memory in a specified
+                alignment and from the specified segment.
+
+ @Param[in]     size            - Number of bytes to allocate.
+ @Param[in]     memPartitionId  - Memory partition ID; The value zero must
+                                  be mapped to the default heap partition.
+ @Param[in]     alignment       - Required memory alignment.
+
+ @Return        The address of the newly allocated block on success, NULL on failure.
+*//***************************************************************************/
+void * XX_MallocSmart(uint32_t size, int memPartitionId, uint32_t alignment);
+
+#endif /* not DEBUG_XX_MALLOC */
+
+/**************************************************************************//**
+ @Function      XX_FreeSmart
+
+ @Description   Frees the memory block pointed to by "p".
+                Only for memory allocated by XX_MallocSmart
+
+ @Param[in]     p_Memory - pointer to the memory block.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_FreeSmart(void *p_Memory);
+
+/**************************************************************************//**
+ @Function      XX_Free
+
+ @Description   frees the memory block pointed to by "p".
+
+ @Param[in]     p_Memory - pointer to the memory block.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_Free(void *p_Memory);
+
+
+/**************************************************************************//**
+ @Function      XX_GetPartitionBase
+
+ @Description   This routine gets the address of a memory segment according to
+                the memory type.
+
+ @Param[in]     memPartitionId  - Memory partition ID; The value zero must
+                                  be mapped to the default heap partition.
+
+ @Return        The address of the required memory type.
+*//***************************************************************************/
+void * XX_GetMemPartitionBase(int memPartitionId);
+
+/**************************************************************************//**
+ @Function      XX_Print
+
+ @Description   print a string.
+
+ @Param[in]     str - string to print.
+
+ @Return        None.
+*//***************************************************************************/
+void    XX_Print(char *str, ...);
+
+/**************************************************************************//**
+ @Function      XX_GetChar
+
+ @Description   Get character from console.
+
+ @Return        Character is returned on success. Zero is returned otherwise.
+*//***************************************************************************/
+char    XX_GetChar(void);
+
+/**************************************************************************//**
+ @Function      XX_SetIntr
+
+ @Description   Set an interupt service routine for a specific interrupt source.
+
+ @Param[in]     irq     - Interrupt ID (system-specific number).
+ @Param[in]     f_Isr   - Callback routine that will be called when the interupt occurs.
+ @Param[in]     handle  - The argument for the user callback routine.
+
+ @Return        E_OK on success; error code otherwise..
+*//***************************************************************************/
+t_Error XX_SetIntr(int irq, t_Isr *f_Isr, t_Handle handle);
+
+/**************************************************************************//**
+ @Function      XX_FreeIntr
+
+ @Description   Free a specific interrupt and a specific callback routine.
+
+ @Param[in]     irq - Interrupt ID (system-specific number).
+
+ @Return        E_OK on success; error code otherwise..
+*//***************************************************************************/
+t_Error XX_FreeIntr(int irq);
+
+/**************************************************************************//**
+ @Function      XX_EnableIntr
+
+ @Description   Enable a specific interrupt.
+
+ @Param[in]     irq - Interrupt ID (system-specific number).
+
+ @Return        E_OK on success; error code otherwise..
+*//***************************************************************************/
+t_Error XX_EnableIntr(int irq);
+
+/**************************************************************************//**
+ @Function      XX_DisableIntr
+
+ @Description   Disable a specific interrupt.
+
+ @Param[in]     irq - Interrupt ID (system-specific number).
+
+ @Return        E_OK on success; error code otherwise..
+*//***************************************************************************/
+t_Error XX_DisableIntr(int irq);
+
+#if !(defined(__MWERKS__) && defined(OPTIMIZED_FOR_SPEED))
+/**************************************************************************//**
+ @Function      XX_DisableAllIntr
+
+ @Description   Disable interrupts by writing to MSR register at the CPU.
+
+ @Return        intMASK a value that represent the interurupt mask before operation
+*//***************************************************************************/
+uint32_t XX_DisableAllIntr(void);
+
+/**************************************************************************//**
+ @Function      XX_RestoreAllIntr
+
+ @Description   Enable interrupts by writing to MSR register at the CPU.
+
+ @Param[in]     flags           - intMASK, mask of previos level function will set the mask based on it.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_RestoreAllIntr(uint32_t flags);
+#endif /* !(defined(__MWERKS__) && defined(OPTIMIZED_FOR_SPEED)) */
+
+/**************************************************************************//**
+ @Function      XX_Call
+
+ @Description   Call a service in another task.
+
+                Activate the routine f via the queue identified by IntrManagerId. The
+                parameter to f is Id - the handle of the destination object
+
+ @Param[in]     intrManagerId   - Queue ID.
+ @Param[in]     f               - routine pointer.
+ @Param[in]     Id              - the parameter to be passed to f().
+ @Param[in]     h_App           - Application handle.
+ @Param[in]     flags           - Unused,
+
+ @Return        E_OK is returned on success. E_FAIL is returned otherwise (usually an operating system level failure).
+*//***************************************************************************/
+t_Error XX_Call( uint32_t intrManagerId,
+                 t_Error (* f)(t_Handle),
+                 t_Handle Id,
+                 t_Handle h_App,
+                 uint16_t flags );
+
+#ifndef BOOT_SEQ
+/**************************************************************************//**
+ @Function      XX_Exit
+
+ @Description   Stop execution and report status (where it is applicable)
+
+ @Param[in]     status - exit status
+*//***************************************************************************/
+void    XX_Exit(int status);
+#endif /* BOOT_SEQ */
+
+/*****************************************************************************/
+/*                        Tasklet Service Routines                           */
+/*****************************************************************************/
+typedef t_Handle t_TaskletHandle;
+
+/**************************************************************************//**
+ @Function      XX_InitTasklet
+
+ @Description   Create and initialize a tasklet object.
+
+ @Param[in]     routine - A routine to be ran as a tasklet.
+ @Param[in]     data    - An argument to pass to the tasklet.
+
+ @Return        Tasklet handle is returned on success. NULL is returned otherwise.
+*//***************************************************************************/
+t_TaskletHandle XX_InitTasklet (void (*routine)(void *), void *data);
+
+/**************************************************************************//**
+ @Function      XX_FreeTasklet
+
+ @Description   Free a tasklet object.
+
+ @Param[in]     h_Tasklet - A handle to a tasklet to be free.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_FreeTasklet (t_TaskletHandle h_Tasklet);
+
+/**************************************************************************//**
+ @Function      XX_ScheduleTask
+
+ @Description   Schedule a tasklet object.
+
+ @Param[in]     h_Tasklet - A handle to a tasklet to be schedulded.
+ @Param[in]     immediate - Indicate whether to schedule this tasklet on
+                            the immediate queue or on the delayed one.
+
+ @Return        0 - on success. Error code - otherwise.
+*//***************************************************************************/
+int XX_ScheduleTask(t_TaskletHandle h_Tasklet, int immediate);
+
+/**************************************************************************//**
+ @Function      XX_FlushScheduledTasks
+
+ @Description   Flush all tasks there are in the scheduled tasks queue.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_FlushScheduledTasks(void);
+
+/**************************************************************************//**
+ @Function      XX_TaskletIsQueued
+
+ @Description   Check if task is queued.
+
+ @Param[in]     h_Tasklet - A handle to a tasklet to be schedulded.
+
+ @Return        1 - task is queued. 0 - otherwise.
+*//***************************************************************************/
+int XX_TaskletIsQueued(t_TaskletHandle h_Tasklet);
+
+/**************************************************************************//**
+ @Function      XX_SetTaskletData
+
+ @Description   Set data to a scheduleded task. Used to change data of allready
+                scheduled task.
+
+ @Param[in]     h_Tasklet - A handle to a tasklet to be schedulded.
+ @Param[in]     data      - Data to be set.
+*//***************************************************************************/
+void XX_SetTaskletData(t_TaskletHandle h_Tasklet, t_Handle data);
+
+/**************************************************************************//**
+ @Function      XX_GetTaskletData
+
+ @Description   Get the data of scheduled task.
+
+ @Param[in]     h_Tasklet - A handle to a tasklet to be schedulded.
+
+ @Return        handle to the data of the task.
+*//***************************************************************************/
+t_Handle XX_GetTaskletData(t_TaskletHandle h_Tasklet);
+
+/**************************************************************************//**
+ @Function      XX_BottomHalf
+
+ @Description   Bottom half implementation, invoked by the interrupt handler.
+
+                This routine handles all bottom-half tasklets with interrupts
+                enabled.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_BottomHalf(void);
+
+
+/*****************************************************************************/
+/*                        Semaphore Service Routines                         */
+/*****************************************************************************/
+typedef t_Handle t_SemaphoreHandle;
+typedef t_Handle t_MutexHandle;
+
+/**************************************************************************//**
+ @Function      XX_InitSemaphore
+
+ @Description   Creates a counting semaphore.
+
+ @Param[in]     initialCount - initial counter value.
+
+ @Return        Semaphore handle is returned on success. NULL is returned
+                otherwise.
+*//***************************************************************************/
+t_SemaphoreHandle XX_InitSemaphore(int initialCount);
+
+/**************************************************************************//**
+ @Function      XX_InitBinSemaphore
+
+ @Description   creates a binary semaphore, which is a semaphore with maximum
+                count of 1.
+
+ @Param[in]     initialCount - initial counter value, should be of course
+                               either 0 or 1.
+
+ @Return        Semaphore handle is returned on success. NULL is returned
+                otherwise.
+*//***************************************************************************/
+t_SemaphoreHandle XX_InitBinSemaphore(int initialCount);
+
+/**************************************************************************//**
+ @Function      XX_FreeSemaphore
+
+ @Description   Frees the memory allocated for the semaphore creation.
+
+ @Param[in]     h_Semaphore - A handle to a semaphore.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_FreeSemaphore(t_SemaphoreHandle h_Semaphore);
+
+/**************************************************************************//**
+ @Function      XX_InitMutex
+
+ @Description   Creates a mutex.
+
+ @Return        Mutex handle is returned on success. NULL is returned
+                otherwise.
+*//***************************************************************************/
+t_MutexHandle XX_InitMutex(void);
+
+/**************************************************************************//**
+ @Function      XX_InitMutexLocked
+
+ @Description   Creates a mutex and locks it.
+
+ @Return        Mutex handle is returned on success; NULL otherwise.
+*//***************************************************************************/
+t_MutexHandle XX_InitMutexLocked(void);
+
+/**************************************************************************//**
+ @Function      XX_FreeMutex
+
+ @Description   Frees the memory allocated for the mutex creation.
+
+ @Param[in]     h_Mutex - A handle to a mutex.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_FreeMutex(t_MutexHandle h_Mutex);
+
+/**************************************************************************//**
+ @Function      XX_DownSemaphore
+
+ @Description   Decrements the counter of the semaphore by 1; When counter
+                reaches 0, the semaphore is locked.
+
+ @Param[in]     h_Semaphore - A handle to a semaphore.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_DownSemaphore(t_SemaphoreHandle h_Semaphore);
+
+/**************************************************************************//**
+ @Function      XX_UpSemaphore
+
+ @Description   Increments the counter of the semaphore by 1; When counter
+                passes 0, the semaphore is unlocked.
+
+ @Param[in]     h_Semaphore - A handle to a semaphore.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_UpSemaphore(t_SemaphoreHandle h_Semaphore);
+
+/**************************************************************************//**
+ @Function      XX_TryLock
+
+ @Description   Tries to lock a mutex.
+
+ @Param[in]     h_Mutex - A handle to a mutex.
+
+ @Return        1 - on success. 0 - otherwise.
+*//***************************************************************************/
+int XX_TryLock(t_MutexHandle h_Mutex);
+
+/**************************************************************************//**
+ @Function      XX_Lock
+
+ @Description   Locks a mutex.
+
+ @Param[in]     h_Mutex - A handle to a mutex.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_Lock(t_MutexHandle h_Mutex);
+
+/**************************************************************************//**
+ @Function      XX_Unlock
+
+ @Description   Unlocks a mutex.
+
+ @Param[in]     h_Mutex - A handle to a mutex.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_Unlock(t_MutexHandle h_Mutex);
+
+
+/*****************************************************************************/
+/*                        Spinlock Service Routines                          */
+/*****************************************************************************/
+typedef t_Handle t_SpinlockHandle;
+
+/**************************************************************************//**
+ @Function      XX_InitSpinlock
+
+ @Description   Creates a spinlock.
+
+ @Return        Spinlock handle is returned on success; NULL otherwise.
+*//***************************************************************************/
+t_SpinlockHandle  XX_InitSpinlock(void);
+
+/**************************************************************************//**
+ @Function      XX_FreeSpinlock
+
+ @Description   Frees the memory allocated for the spinlock creation.
+
+ @Param[in]     h_Spinlock - A handle to a spinlock.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_FreeSpinlock(t_SpinlockHandle h_Spinlock);
+
+/**************************************************************************//**
+ @Function      XX_Spinlock
+
+ @Description   Locks a spinlock.
+
+ @Param[in]     h_Spinlock - A handle to a spinlock.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_Spinlock(t_SpinlockHandle h_Spinlock);
+
+/**************************************************************************//**
+ @Function      XX_Spinunlock
+
+ @Description   Unlocks a spinlock.
+
+ @Param[in]     h_Spinlock - A handle to a spinlock.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_Spinunlock(t_SpinlockHandle h_Spinlock);
+
+/**************************************************************************//**
+ @Function      XX_IntrSpinlock
+
+ @Description   Locks a spinlock (interrupt safe).
+
+ @Param[in]     h_Spinlock - A handle to a spinlock.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_IntrSpinlock(t_SpinlockHandle h_Spinlock);
+
+/**************************************************************************//**
+ @Function      XX_IntrSpinunlock
+
+ @Description   Unlocks a spinlock (interrupt safe).
+
+ @Param[in]     h_Spinlock - A handle to a spinlock.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_IntrSpinunlock(t_SpinlockHandle h_Spinlock);
+
+
+/*****************************************************************************/
+/*                        Timers Service Routines                            */
+/*****************************************************************************/
+typedef t_Handle t_TimerHandle;
+
+/**************************************************************************//**
+ @Function      XX_CurrentTime
+
+ @Description   Returns current system time.
+
+ @Return        Current system time (in milliseconds).
+*//***************************************************************************/
+uint32_t XX_CurrentTime(void);
+
+/**************************************************************************//**
+ @Function      XX_CreateTimer
+
+ @Description   Creates a timer.
+
+ @Return        Timer handle is returned on success; NULL otherwise.
+*//***************************************************************************/
+t_TimerHandle XX_CreateTimer(void);
+
+/**************************************************************************//**
+ @Function      XX_FreeTimer
+
+ @Description   Frees the memory allocated for the timer creation.
+
+ @Param[in]     h_Timer - A handle to a timer.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_FreeTimer(t_TimerHandle h_Timer);
+
+/**************************************************************************//**
+ @Function      XX_StartTimer
+
+ @Description   Starts a timer.
+
+                The user can select to start the timer as periodic timer or as
+                one-shot timer. The user should provide a callback routine that
+                will be called when the timer expires.
+
+ @Param[in]     h_Timer         - A handle to a timer.
+ @Param[in]     msecs           - Timer expiration period (in milliseconds).
+ @Param[in]     periodic        - TRUE for a periodic timer;
+                                  FALSE for a one-shot timer..
+ @Param[in]     f_TimerExpired  - A callback routine to be called when the
+                                  timer expires.
+ @Param[in]     h_Arg           - The argument to pass in the timer-expired
+                                  callback routine.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_StartTimer(t_TimerHandle    h_Timer,
+                   uint32_t         msecs,
+                   bool             periodic,
+                   void             (*f_TimerExpired)(t_Handle h_Arg),
+                   t_Handle         h_Arg);
+
+/**************************************************************************//**
+ @Function      XX_StopTimer
+
+ @Description   Frees the memory allocated for the timer creation.
+
+ @Param[in]     h_Timer - A handle to a timer.
+
+ @Return        None.
+*//***************************************************************************/
+void XX_StopTimer(t_TimerHandle h_Timer);
+
+/**************************************************************************//**
+ @Function      XX_GetExpirationTime
+
+ @Description   Returns the time (in milliseconds) remaining until the
+                expiration of a timer.
+
+ @Param[in]     h_Timer - A handle to a timer.
+
+ @Return        The time left until the timer expires.
+*//***************************************************************************/
+uint32_t XX_GetExpirationTime(t_TimerHandle h_Timer);
+
+/**************************************************************************//**
+ @Function      XX_ModTimer
+
+ @Description   Updates the expiration time of a timer.
+
+                This routine adds the given time to the current system time,
+                and sets this value as the new expiration time of the timer.
+
+ @Param[in]     h_Timer - A handle to a timer.
+ @Param[in]     msecs   - The new interval until timer expiration
+                          (in milliseconds).
+
+ @Return        None.
+*//***************************************************************************/
+void XX_ModTimer(t_TimerHandle h_Timer, uint32_t msecs);
+
+/**************************************************************************//**
+ @Function      XX_TimerIsActive
+
+ @Description   Checks whether a timer is active (pending) or not.
+
+ @Param[in]     h_Timer - A handle to a timer.
+
+ @Return        0 - the timer is inactive; Non-zero value - the timer is active;
+*//***************************************************************************/
+int XX_TimerIsActive(t_TimerHandle h_Timer);
+
+/**************************************************************************//**
+ @Function      XX_Sleep
+
+ @Description   Non-busy wait until the desired time (in milliseconds) has passed.
+
+ @Param[in]     msecs - The requested sleep time (in milliseconds).
+
+ @Return        None.
+
+ @Cautions      This routine enables interrupts during its wait time.
+*//***************************************************************************/
+uint32_t XX_Sleep(uint32_t msecs);
+
+/**************************************************************************//**
+ @Function      XX_UDelay
+
+ @Description   Busy-wait until the desired time (in microseconds) has passed.
+
+ @Param[in]     usecs - The requested delay time (in microseconds).
+
+ @Return        None.
+
+ @Cautions      It is highly unrecommended to call this routine during interrupt
+                time, because the system time may not be updated properly during
+                the delay loop. The behavior of this routine during interrupt
+                time is unexpected.
+*//***************************************************************************/
+void XX_UDelay(uint32_t usecs);
+
+
+/*****************************************************************************/
+/*                         Other Service Routines                            */
+/*****************************************************************************/
+
+/**************************************************************************//**
+ @Function      XX_PhysToVirt
+
+ @Description   Translates a physical address to the matching virtual address.
+
+ @Param[in]     addr - The physical address to translate.
+
+ @Return        Virtual address.
+*//***************************************************************************/
+void * XX_PhysToVirt(void *addr);
+
+/**************************************************************************//**
+ @Function      XX_VirtToPhys
+
+ @Description   Translates a virtual address to the matching physical address.
+
+ @Param[in]     addr - The virtual address to translate.
+
+ @Return        Physical address.
+*//***************************************************************************/
+void * XX_VirtToPhys(void *addr);
+
+#define XXX_PhysToVirt(addr)  (CAST_POINTER_TO_UINT32(XX_PhysToVirt(CAST_UINT32_TO_POINTER(addr))))
+#define XXX_VirtToPhys(addr)  (CAST_POINTER_TO_UINT32(XX_VirtToPhys(CAST_UINT32_TO_POINTER(addr))))
+
+
+#define MSG_BODY_SIZE       512
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+/**************************************************************************//**
+ @Group         xx_ipc  XX Inter-Partition-Communication API
+
+ @Description   The following API is to be used when working with multi-core.
+
+ @{
+*//***************************************************************************/
+typedef void (t_MsgCompletionCB) (t_Handle h_Arg, uint8_t msgBody[MSG_BODY_SIZE]);
+typedef t_Error (t_MsgHandler) (t_Handle h_Mod, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE]);
+
+/**************************************************************************//**
+ @Function      XX_RegisterMessageHandler
+
+ @Description   This routine is used to register to the XX messaging mechanism.
+
+ @Param[in]     p_Addr          - The module address.
+ @Param[in]     f_MsgHandlerCB  - The module callback; It will be called when the
+                                  module gets message.
+ @Param[in]     h_Mod           - The module arg; It will be passed to the module
+                                  whithin the callback when it gets message.
+
+ @Return        E_OK is returned on success. error code is returned otherwise.
+*//***************************************************************************/
+t_Error XX_RegisterMessageHandler   (char *p_Addr, t_MsgHandler *f_MsgHandlerCB, t_Handle h_Mod);
+
+/**************************************************************************//**
+ @Function      XX_UnregisterMessageHandler
+
+ @Description   This routine is used to unregister to the XX messaging mechanism.
+
+ @Param[in]     p_Addr          - The module address.
+
+ @Return        E_OK is returned on success. error code is returned otherwise.
+*//***************************************************************************/
+t_Error XX_UnregisterMessageHandler (char *p_Addr);
+
+/**************************************************************************//**
+ @Function      XX_SendMessage
+
+ @Description   This routine is used to send messages to modules registered to the
+                XX messaging mechanism.
+
+ @Param[in]     p_DestAddr      - The destination module address.
+ @Param[in]     msgId           - The message ID.
+ @Param[in]     msgBody         - The message body (up to 64 bytes).
+ @Param[in]     f_CompletionCB  - The caller callback; It will be called after the
+                                  message will be handled by the destination module.
+                                  NOTE - if passing here NULL, the routine will be
+                                  blocking untill the destination module will
+                                  handle the message.
+ @Param[in]     h_CBArg         - The caller handler; This argument will be
+                                  passed to whithin the completion routine.
+
+ @Return        E_OK is returned on success. error code is returned otherwise.
+*//***************************************************************************/
+t_Error XX_SendMessage(char                 *p_DestAddr,
+                       uint32_t             msgId,
+                       uint8_t              msgBody[MSG_BODY_SIZE],
+                       t_MsgCompletionCB    *f_CompletionCB,
+                       t_Handle             h_CBArg);
+/** @} */ /* end of xx_ic group */
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+/** @} */ /* end of xx_id group */
+
+
+#endif /* __XX_EXT_H */
-- 
1.6.5.2

