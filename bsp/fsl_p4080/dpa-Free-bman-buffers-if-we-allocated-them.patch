From 7734e25774cfc578081c0a87eb1a6d5b6a7b37c2 Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Mon, 9 Aug 2010 18:55:20 +0800
Subject: [PATCH] dpa: Free bman buffers if we allocated them

From FSL vendor SDK 2.x.

The dpa_bp_free() function was not removing the buffers
from the pool, which meant that an error or a soft-reboot
would leave them there.  This would cause issues, and is
wrong, anyway. However, we don't want to clean out the pool
if the bman driver was the one that created it, so we
resurrect the kernel_pool field, and use that to determine
whether we're responsible for releasing the buffers or not.

Also, use this to determine if we should free the pages, as
we should only do that if we actually allocated them. Same
for dma_unmap.

Signed-off-by: Andy Fleming <afleming@freescale.com>
Integrated-by: Andrew Liu <shengping.liu@windriver.com>
---
 drivers/net/dpa/dpa.c |   14 ++++++++++++--
 1 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/drivers/net/dpa/dpa.c b/drivers/net/dpa/dpa.c
index 470f2e4..ddd1623 100644
--- a/drivers/net/dpa/dpa.c
+++ b/drivers/net/dpa/dpa.c
@@ -126,6 +126,7 @@ static u64 guest_phy_offset;
 
 struct dpa_bp {
 	struct bman_pool		*pool;
+	bool                            kernel_pool;
 	union {
 		struct list_head	list;
 		uint8_t			bpid;
@@ -218,6 +219,8 @@ _dpa_bp_alloc(struct net_device *net_dev, struct list_head *list,
   			_errno = -ENOMEM;
   			goto _return_bman_free_pool;
   		}
+
+		dpa_bp->kernel_pool = true;
   
  		dpa_bp->paddr = dma_map_single(net_dev->dev.parent,
  						dpa_bp->vaddr,
@@ -243,6 +246,7 @@ _dpa_bp_alloc(struct net_device *net_dev, struct list_head *list,
  			}
  		}
   	} else {
+		dpa_bp->kernel_pool = false;
   		devm_request_mem_region(net_dev->dev.parent, dpa_bp->paddr,
   					dpa_bp->size * dpa_bp->count,
   					KBUILD_MODNAME);
@@ -287,10 +291,16 @@ static void __cold __attribute__((nonnull))
 _dpa_bp_free(struct device *dev, struct dpa_bp *dpa_bp)
 {
 	uint8_t	bpid;
+	struct bm_buffer bmb[8];
+
+	if (dpa_bp->kernel_pool) {
+		 while (bman_acquire(dpa_bp->pool, bmb, 8, 0) == 8)
+			;
 
-	dma_unmap_single(dev, dpa_bp->paddr,
+		dma_unmap_single(dev, dpa_bp->paddr,
 			dpa_bp->size * dpa_bp->count, DMA_BIDIRECTIONAL);
-	free_pages_exact(dpa_bp->vaddr, dpa_bp->size * dpa_bp->count);
+		free_pages_exact(dpa_bp->vaddr, dpa_bp->size * dpa_bp->count);
+	}
 	bpid = dpa_pool2bpid(dpa_bp);
 	dpa_bp_array[bpid] = 0;
 	bman_free_pool(dpa_bp->pool);
-- 
1.6.0.3

