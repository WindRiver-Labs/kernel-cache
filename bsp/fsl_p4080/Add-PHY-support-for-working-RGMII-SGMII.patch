From ab5370a60deb4735ef555cb9049902c4dbb9a02d Mon Sep 17 00:00:00 2001
From: Andy Fleming <afleming@freescale.com>
Date: Mon, 24 Aug 2009 18:52:20 -0500
Subject: [PATCH 033/148] Add PHY support for working RGMII/SGMII

Applied the FSL SDK 2.0.3 patch:
"0003-Add-PHY-support-for-working-RGMII-SGMII.patch"
written by Andy Fleming <afleming@freescale.com>

[Changed drivers/net/fsl_pq_mdio.c:
   -module_init(fsl_pq_mdio_init);
   +subsys_initcall_sync(fsl_pq_mdio_init);

in order to get proper functionality. The p4080ds_mdio depends on fsl-pq-mdio.
So the probe of fsl-pq-mdio should be run before the probe of p4080ds_mdio.
Note: no commit header or Signed-off-by present in Andy's original patch]
Integrated-by: Yuri Nedel <Yuri.Nedel@windriver.com>
---
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c   |   87 +++++++++++---
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h   |   22 +++-
 .../NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c   |   27 ++---
 .../inc/integrations/P4080/part_integration_ext.h  |    4 +-
 drivers/net/dpa/dpa.c                              |  134 +++++++++++++++++++-
 drivers/net/dpa/dpa.h                              |    1 +
 drivers/net/dpa/mac-api.c                          |   20 +++-
 drivers/net/dpa/mac.c                              |   30 +++--
 drivers/net/dpa/mac.h                              |    2 +
 drivers/net/fsl_pq_mdio.c                          |   17 +++-
 drivers/net/phy/vitesse.c                          |   25 ++++-
 11 files changed, 313 insertions(+), 56 deletions(-)

diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
index 641814a..fa9b320 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
@@ -87,6 +87,11 @@ static t_Error CheckInitParameters(t_Dtsec *p_Dtsec)
     if((p_Dtsec->p_DtsecDriverParam)->collisionWindow > MAX_COLLISION_WINDOW)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("collisionWindow can't be greater than %d ",MAX_COLLISION_WINDOW ));
 
+    /*  If Auto negotiation process is disabled, need to */
+    /*  Set up the PHY using the MII Management Interface */
+    if (p_Dtsec->p_DtsecDriverParam->tbiPhyAddr > MAX_PHYS)
+        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("PHY address (should be 0-%d)", MAX_PHYS));
+
     return E_OK;
 }
 
@@ -119,6 +124,7 @@ static void SetDefaultParam(t_Dtsec *p_Dtsec, t_DtsecDriverParam *p_DtsecDriverP
     p_DtsecDriverParam->debugMode            = DEFAULT_debugMode;
 
     p_DtsecDriverParam->loopback             = DEFAULT_loopback;
+    p_DtsecDriverParam->tbiPhyAddr           = DEFAULT_tbiPhyAddr;
     p_DtsecDriverParam->actOnRxPauseFrame    = DEFAULT_actOnRxPauseFrame;
     p_DtsecDriverParam->actOnTxPauseFrame    = DEFAULT_actOnTxPauseFrame;
 
@@ -272,7 +278,6 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
 
 /***************ECNTRL************************/
     tmpReg32 = GET_UINT32(p_DtsecMemMap->ecntrl);
-
     if(tmpReg32 & ECNTRL_CFG_RO)
     {
         isRgmii = (( p_Dtsec->enetMode == e_ENET_MODE_RGMII_10)   ||
@@ -303,7 +308,6 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
         if((is100 && !isResetCnfg100) ||
             (!is100 && isResetCnfg100))
           RETURN_ERROR(MAJOR, E_CONFLICT,(" Error. 100 speed interface is not configured properly. Check dTsec cfg switch \n"));
-
     }
     else
     {
@@ -321,13 +325,16 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
             tmpReg32 |= ECNTRL_RPM;
        if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) || (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100))
             tmpReg32 |= ECNTRL_R100M;
+#ifdef FM_ENET_SGMII_1000_ERRATA
+       if(p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)
+            tmpReg32 |= ECNTRL_R100M;
+#endif /* FM_ENET_SGMII_1000_ERRATA */
     }
 
     if (p_DtsecDriverParam->autoZeroCounters)
         tmpReg32 |= ECNTRL_AUTOZ;
     if(p_DtsecDriverParam->statisticsEnable)
-        tmpReg32 |= ECNTRL_STEN ;
-
+        tmpReg32 |= ECNTRL_STEN;
     WRITE_UINT32(p_DtsecMemMap->ecntrl, tmpReg32);
 
 /***************ECNTRL************************/
@@ -380,6 +387,42 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
 
     WRITE_UINT32(p_DtsecMemMap->rctrl, tmpReg32);
 
+    /* Assign a Phy Address to the TBI (TBIPA).            */
+    /* Done also in case that TBI is not selected to avoid */
+    /* conflict with the external PHY’s Physical address   */
+    WRITE_UINT32(p_DtsecMemMap->tbipa, p_DtsecDriverParam->tbiPhyAddr);
+
+    /* Reset the management interface */
+    WRITE_UINT32(p_DtsecMemMap->miimcfg, MIIMCFG_RESET_MGMT);
+
+    /* Setup the MII Mgmt clock speed */
+    WRITE_UINT32(p_DtsecMemMap->miimcfg, MIIMCFG_MGMT_CLOCK_SELECT);
+
+    if(p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)
+    {
+        uint16_t            tmpReg16;
+
+        /* Configure the TBI PHY Control Register */
+        tmpReg16 = PHY_TBICON_SPEED2 | PHY_TBICON_SRESET;
+
+        DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 17, tmpReg16);
+
+        tmpReg16 = PHY_TBICON_SPEED2;
+
+        DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 17, tmpReg16);
+                        
+        if(!p_DtsecDriverParam->halfDuplex)
+            tmpReg16 |= PHY_CR_FULLDUPLEX | 0x8000 | PHY_CR_ANE;
+
+        DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 0, tmpReg16);
+        
+        tmpReg16 = 0x01a0;
+        DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 4, tmpReg16);
+                        
+        tmpReg16 = 0x1340;
+        DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 0, tmpReg16);                
+    }
+
 /***************RCTRL************************/
 /***************IMASK************************/
     WRITE_UINT32(p_DtsecMemMap->imask, p_DtsecDriverParam->imask);
@@ -408,13 +451,15 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
 /***************MACCFG1***********************/
 /***************MACCFG2***********************/
     tmpReg32 = 0;
-
     if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
         (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)||
         (p_Dtsec->enetMode == e_ENET_MODE_SGMII_10) ||
         (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100))
             tmpReg32 |= MACCFG2_NIBBLE_MODE;
-
+#ifdef FM_ENET_SGMII_1000_ERRATA
+    else if(p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)
+            tmpReg32 |= MACCFG2_NIBBLE_MODE;
+#endif /* FM_ENET_SGMII_1000_ERRATA */
     else if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
         (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)||
         (p_Dtsec->enetMode == e_ENET_MODE_GMII_1000))
@@ -436,8 +481,8 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
         tmpReg32 |= MACCFG2_CRC_EN ;
     if(!p_DtsecDriverParam->halfDuplex)
         tmpReg32 |= MACCFG2_FULL_DUPLEX;
-
     WRITE_UINT32(p_DtsecMemMap->maccfg2, tmpReg32);
+
 /***************MACCFG2***********************/
 /***************IPGIFG************************/
 
@@ -1132,11 +1177,13 @@ static t_Error DtsecSetPromiscuous(t_Handle h_Dtsec, bool newVal)
 static t_Error DtsecAdjustLink(t_Handle h_Dtsec, e_EnetSpeed speed, bool fullDuplex)
 {
     t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    t_DtsecMemMap   *p_DtsecMemMap = p_Dtsec->p_MemMap;
+    t_DtsecMemMap   *p_DtsecMemMap;
     uint32_t        tmpReg32;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
+    p_DtsecMemMap = p_Dtsec->p_MemMap;
+    SANITY_CHECK_RETURN_ERROR(p_DtsecMemMap, E_INVALID_HANDLE);
 
     if (!fullDuplex &&
         ((speed >= e_ENET_SPEED_1000) ||
@@ -1144,16 +1191,16 @@ static t_Error DtsecAdjustLink(t_Handle h_Dtsec, e_EnetSpeed speed, bool fullDup
         RETURN_ERROR(MAJOR, E_CONFLICT, ("Ethernet interface does not support Half Duplex mode"));
 
     p_Dtsec->enetMode = MAKE_ENET_MODE(ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode), speed);
-    p_Dtsec->p_DtsecDriverParam->halfDuplex = !fullDuplex;
+    p_Dtsec->halfDuplex = !fullDuplex;
 
     tmpReg32 = GET_UINT32(p_DtsecMemMap->maccfg2);
-    if(p_Dtsec->p_DtsecDriverParam->halfDuplex)
+    if(p_Dtsec->halfDuplex)
         tmpReg32 &= ~MACCFG2_FULL_DUPLEX;
     else
         tmpReg32 |= MACCFG2_FULL_DUPLEX;
-    WRITE_UINT32(p_DtsecMemMap->maccfg2, tmpReg32);
 
-    tmpReg32 = GET_UINT32(p_DtsecMemMap->ecntrl);
+	tmpReg32 &= ~(MACCFG2_NIBBLE_MODE | MACCFG2_BYTE_MODE);
+
     if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
         (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)||
         (p_Dtsec->enetMode == e_ENET_MODE_SGMII_10) ||
@@ -1164,7 +1211,17 @@ static t_Error DtsecAdjustLink(t_Handle h_Dtsec, e_EnetSpeed speed, bool fullDup
         (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)||
         (p_Dtsec->enetMode == e_ENET_MODE_GMII_1000))
             tmpReg32 |= MACCFG2_BYTE_MODE;
-    WRITE_UINT32(p_DtsecMemMap->ecntrl, tmpReg32);
+    WRITE_UINT32(p_DtsecMemMap->maccfg2, tmpReg32);
+
+    tmpReg32 = GET_UINT32(p_DtsecMemMap->ecntrl);
+    if(!(tmpReg32 & ECNTRL_CFG_RO))
+    {
+        if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) || (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100))
+            tmpReg32 |= ECNTRL_R100M;
+        else
+            tmpReg32 &= ~ECNTRL_R100M;
+        WRITE_UINT32(p_DtsecMemMap->ecntrl, tmpReg32);
+    }
 
     return E_OK;
 }
@@ -1302,8 +1359,8 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
     p_FmMacControllerDriver->f_FM_MAC_GetId                     = DtsecGetId;
     p_FmMacControllerDriver->f_FM_MAC_GetVersion                = DtsecGetVersion;
 
-    p_FmMacControllerDriver->f_FM_MAC_MII_WritePhyReg           = MII_WritePhyReg;
-    p_FmMacControllerDriver->f_FM_MAC_MII_ReadPhyReg            = MII_ReadPhyReg;
+    p_FmMacControllerDriver->f_FM_MAC_MII_WritePhyReg           = DTSEC_MII_WritePhyReg;
+    p_FmMacControllerDriver->f_FM_MAC_MII_ReadPhyReg            = DTSEC_MII_ReadPhyReg;
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
     p_FmMacControllerDriver->f_FM_MAC_DumpRegs                  = DtsecDumpRegs;
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
index cb2e2a1..01c6415 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
@@ -74,7 +74,7 @@ typedef  uint32_t t_ErrorDisable;
 #define HASH_TABLE_SIZE             256 /* Hash table size (= 32 bits * 8 regs) */
 
 
-#define DTSEC_TO_MII_OFFSET         0x1000  /* number of pattern match registers (entries) */
+#define DTSEC_TO_MII_OFFSET         0x1120  /* number of pattern match registers (entries) */
 
 #define DEFAULT_cam                 0
 
@@ -132,6 +132,7 @@ typedef  uint32_t t_ErrorDisable;
 #define DEFAULT_fifoTxThr           0x10
 #define DEFAULT_fifoTxWatermarkH    0x7e
 #define DEFAULT_fifoRxWatermarkL    0x08
+#define DEFAULT_tbiPhyAddr          5
 
 #define DEFAULT_imask               ((uint32_t)(IMASK_BREN | IMASK_RXCEN | IMASK_MSROEN | IMASK_GTSCEN | \
                                                 IMASK_BTEN | IMASK_TXCEN | IMASK_TXEEN |  IMASK_ABRTEN | \
@@ -139,6 +140,7 @@ typedef  uint32_t t_ErrorDisable;
                                                 IMASK_MAGEN | IMASK_MMRDEN | IMASK_MMWREN |IMASK_GRSCEN| \
                                                 IMASK_TDPEEN |IMASK_RDPEEN)
 
+#define MAX_PHYS                    31 /* maximum number of phys */
 
 #define DTSEC_ID1_ID                0xffff0000
 #define DTSEC_ID1_REV_MJ            0x0000FF00
@@ -265,6 +267,15 @@ typedef  uint32_t t_ErrorDisable;
 #define     MASK12BIT   0x00000FFF
 #define     MASK8BIT    0x000000FF
 
+/* PHY Control Register */
+#define PHY_CR_LOOPBACK     0x4000
+#define PHY_CR_SPEED0       0x2000
+#define PHY_CR_ANE          0x1000
+#define PHY_CR_FULLDUPLEX   0x0100
+#define PHY_CR_SPEED1       0x0040
+#define PHY_TBICON_SPEED2   0x0020
+#define PHY_TBICON_SRESET   0x8000
+
 
 #ifdef __MWERKS__
 #pragma pack(push,1)
@@ -286,7 +297,7 @@ typedef _Packed struct
     volatile uint32_t edis;                 /* 0x010 Error disabled register */
     volatile uint32_t ecntrl;               /* 0x014 E control register */
     volatile uint32_t ptv;                  /* 0x018 Pause time value register */
-    volatile uint32_t DTSEC_RESERVED1;      /* 0x01C TBIPA—TBI PHY address register */
+    volatile uint32_t tbipa;                /* 0x01C TBI PHY address register */
     volatile uint32_t tmr_ctrl;             /* 0x020 Time-stamp Control register */
     volatile uint32_t tmr_pevent;           /* 0x024 Time-stamp event register */
     volatile uint32_t tmr_pemask;           /* 0x028 Timer event mask register */
@@ -308,7 +319,7 @@ typedef _Packed struct
     volatile uint32_t ipgifg;               /* 0x108 IPG/IFG */
     volatile uint32_t hafdup;               /* 0x10C Half-duplex */
     volatile uint32_t maxfrm;               /* 0x110 Maximum frame */
-    volatile uint32_t  DTSEC_RESERVED7[3];  /* 0x114–0x11C register */
+    volatile uint32_t DTSEC_RESERVED7[3];   /* 0x114–0x11C register */
     volatile uint32_t miimcfg;              /* 0x120 MII Mgmt:configuration */
     volatile uint32_t miimcom;              /* 0x124 MII Mgmt:command */
     volatile uint32_t miimadd;              /* 0x128 MII Mgmt:address */
@@ -413,6 +424,7 @@ typedef struct {
     bool        halfDuplex;
     uint16_t    pauseTime;
     uint16_t    pauseExtended;
+    uint8_t     tbiPhyAddr;         /**< TBI Physical address  (1-31)     [DEFAULT_tbiPhyAddr]*/
 
     bool        autoZeroCounters;
     bool        statisticsEnable;
@@ -489,8 +501,8 @@ typedef struct {
     t_DtsecDriverParam          *p_DtsecDriverParam;
 } t_Dtsec;
 
-t_Error MII_WritePhyReg(t_Handle h_Dtsec, uint8_t phyAddr, uint8_t reg, uint16_t data);
-t_Error MII_ReadPhyReg(t_Handle  h_Dtsec, uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
+t_Error DTSEC_MII_WritePhyReg(t_Handle h_Dtsec, uint8_t phyAddr, uint8_t reg, uint16_t data);
+t_Error DTSEC_MII_ReadPhyReg(t_Handle  h_Dtsec, uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
 
 
 #endif /* __DTSEC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
index 98a0ba6..64518be 100644
--- a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
@@ -42,12 +42,11 @@
 #include "dtsec.h"
 
 
-
 /*****************************************************************************/
-t_Error MII_WritePhyReg(t_Handle h_Dtsec,
-                        uint8_t     phyAddr,
-                        uint8_t     reg,
-                        uint16_t    data)
+t_Error DTSEC_MII_WritePhyReg(t_Handle    h_Dtsec,
+                              uint8_t     phyAddr,
+                              uint8_t     reg,
+                              uint16_t    data)
 {
     t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
     t_MiiAccessMemMap   *p_MiiAccess;
@@ -78,12 +77,11 @@ t_Error MII_WritePhyReg(t_Handle h_Dtsec,
     return E_OK;
 }
 
-
 /*****************************************************************************/
-t_Error MII_ReadPhyReg(t_Handle h_Dtsec,
-                   uint8_t  phyAddr,
-                   uint8_t  reg,
-                   uint16_t *p_Data)
+t_Error DTSEC_MII_ReadPhyReg(t_Handle h_Dtsec,
+                             uint8_t  phyAddr,
+                             uint8_t  reg,
+                             uint16_t *p_Data)
 {
     t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
     t_MiiAccessMemMap   *p_MiiAccess;
@@ -114,14 +112,7 @@ t_Error MII_ReadPhyReg(t_Handle h_Dtsec,
     tmpReg = GET_UINT32(p_MiiAccess->miimcom);
 
     if (*p_Data == 0xffff)
-    {
-        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Read wrong data: phyAddr"));
-/*
-        DBG(INFO, ("Read wrong data: phyAddr %d, reg %d, base %08x",
-            phyAddr, reg, (long)p_MiiAccess));
-*/
-    return E_INVALID_VALUE;
-    }
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Read wrong data: phyAddr"));
 
     return E_OK;
 }
diff --git a/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h b/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h
index 273b46e..dd0d556 100644
--- a/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h
+++ b/drivers/net/dpa/NetCommSw/inc/integrations/P4080/part_integration_ext.h
@@ -179,7 +179,7 @@ typedef enum e_TransSrc
 typedef enum e_P4080DeviceName
 {
     e_P4080_REV_INVALID   = 0x00000000,   /**< Invalid revision      */
-    e_P4080E_REV_1_0      = 0x807D0010    /**< P4080E with security, revision 1.0 */
+    e_P4080E_REV_1_0      = 0x80230010    /**< P4080E with security, revision 1.0 */
 } e_P4080DeviceName;
 
 
@@ -299,8 +299,10 @@ uint32_t P4080_GetCcbFactor(t_Handle h_P4080);
 #define FM_PCD_KG_NUM_OF_SCHEMES    32                  /**< Total number of KG schemes */
 #define FM_PCD_MAX_NUM_OF_CLS_PLANS 256                 /**< Number of classification plan entries. */
 
+/* FM erratas */
 #define FM_OP_PARTITION_ERRATA
 #define CORE_8BIT_ACCESS_ERRATA
+#define FM_ENET_SGMII_1000_ERRATA
 
 
 #endif /* __PART_INTEGRATION_EXT_H */
diff --git a/drivers/net/dpa/dpa.c b/drivers/net/dpa/dpa.c
index d6d1734..adb183e 100644
--- a/drivers/net/dpa/dpa.c
+++ b/drivers/net/dpa/dpa.c
@@ -1238,6 +1238,58 @@ static const struct qman_fq _egress_fqs __devinitconst = {
 	.cb = {egress_dqrr, egress_ern, egress_dc_ern, egress_fqs}
 };
 
+/* Called every time the controller might need to be made
+ * aware of new link state.  The PHY code conveys this
+ * information through variables in the phydev structure, and this
+ * function converts those variables into the appropriate
+ * register values, and can bring down the device if needed.
+ */
+static void adjust_link(struct net_device *net_dev)
+{
+	const struct dpa_priv_s	*priv;
+	struct phy_device *phydev;
+	int			 _errno = 0;
+//	unsigned long flags;
+
+	priv = (typeof(priv))netdev_priv(net_dev);
+	phydev = priv->phydev;
+
+//	spin_lock_irqsave(&priv->lock, flags);
+
+	if (phydev->link)
+		_errno = priv->mac_dev->adjust_link(priv->mac_dev, phydev->speed, phydev->duplex);
+
+	if (unlikely(_errno < 0))
+		cpu_netdev_err(net_dev, "%s:%hu:%s(): mac_dev->adjust_link() = %d\n",
+			       __file__, __LINE__, __func__, _errno);
+//	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+/* Initializes driver's PHY state, and attaches to the PHY.
+ * Returns 0 on success.
+ */
+static int init_phy(struct net_device *net_dev)
+{
+	struct dpa_priv_s	*priv;
+	struct phy_device *phydev;
+
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	phydev = phy_connect(net_dev, priv->mac_dev->phy_id, &adjust_link, 0, priv->mac_dev->phy_if);
+	if (IS_ERR(phydev)) {
+		printk(KERN_ERR "%s: Could not attach to PHY\n", net_dev->name);
+		return PTR_ERR(phydev);
+	}
+
+	/* Remove any features not supported by the controller */
+	phydev->supported &= priv->mac_dev->if_support;
+	phydev->advertising = phydev->supported;
+
+	priv->phydev = phydev;
+
+	return 0;
+}
+
 static struct net_device_stats * __cold dpa_get_stats(struct net_device *net_dev)
 {
 	cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
@@ -1408,6 +1460,73 @@ static void __hot dpa_rx(struct work_struct *fd_work)
 		}
 
 		skb->protocol = eth_type_trans(skb, net_dev);
+#if defined(CONFIG_FSL_FMAN_TEST) || defined(CONFIG_FSL_FMAN_TEST_LOOP)
+{
+    struct iphdr    *iph = (struct iphdr *)(skb->data);
+    uint32_t        net;
+    uint32_t        saddr = iph->saddr;
+    uint32_t        daddr = iph->daddr;
+
+    /* If it is ARP packet ... */
+    if (*(uint32_t*)skb->data == 0x00010800)
+    {
+        saddr = *((uint32_t*)(skb->data+14));
+        daddr = *((uint32_t*)(skb->data+24));
+    }
+
+    cpu_dev_dbg (net_dev->dev.parent,
+                 "Src  IP before header-manipulation: %d.%d.%d.%d\n",
+                 (int)((saddr & 0xff000000) >> 24),
+                 (int)((saddr & 0x00ff0000) >> 16),
+                 (int)((saddr & 0x0000ff00) >> 8),
+                 (int)((saddr & 0x000000ff) >> 0));
+    cpu_dev_dbg (net_dev->dev.parent,
+                 "Dest IP before header-manipulation: %d.%d.%d.%d\n",
+                 (int)((daddr & 0xff000000) >> 24),
+                 (int)((daddr & 0x00ff0000) >> 16),
+                 (int)((daddr & 0x0000ff00) >> 8),
+                 (int)((daddr & 0x000000ff) >> 0));
+
+    /* We allow only up to 10 eth ports */
+#if defined(CONFIG_FSL_FMAN_TEST)
+    net   = ((daddr & 0x000000ff) % 10);
+    saddr = (uint32_t)((saddr & ~0x0000ff00) | (net << 8));
+    daddr = (uint32_t)((daddr & ~0x0000ff00) | (net << 8));
+#else /* loopback */
+    net   = saddr;
+    saddr = daddr;
+    daddr = net;
+#endif /* defined(CONFIG_FSL_FMAN_TEST) */
+
+    /* If not ARP ... */
+    if (*(uint32_t*)skb->data != 0x00010800)
+    {
+        iph->check = 0;
+
+        iph->saddr = saddr;
+        iph->daddr = daddr;
+        iph->check = ip_fast_csum((unsigned char *)iph, iph->ihl);
+    }
+    else /* The packet is ARP */
+    {
+        *(uint32_t*)(skb->data+14) = saddr;
+        *(uint32_t*)(skb->data+24) = daddr;
+    }
+
+    cpu_dev_dbg (net_dev->dev.parent,
+                 "Src  IP after  header-manipulation: %d.%d.%d.%d\n",
+                 (int)((saddr & 0xff000000) >> 24),
+                 (int)((saddr & 0x00ff0000) >> 16),
+                 (int)((saddr & 0x0000ff00) >> 8),
+                 (int)((saddr & 0x000000ff) >> 0));
+    cpu_dev_dbg (net_dev->dev.parent,
+                 "Dest IP after  header-manipulation: %d.%d.%d.%d\n",
+                 (int)((daddr & 0xff000000) >> 24),
+                 (int)((daddr & 0x00ff0000) >> 16),
+                 (int)((daddr & 0x0000ff00) >> 8),
+                 (int)((daddr & 0x000000ff) >> 0));
+}
+#endif /* defined(CONFIG_FSL_FMAN_TEST) */
 
 		_errno = netif_rx_ni(skb);
 		if (unlikely(_errno != NET_RX_SUCCESS)) {
@@ -1548,7 +1667,7 @@ _return:
 
 static int __cold dpa_start(struct net_device *net_dev)
 {
-	int			 _errno, i, j;
+	int			 _errno, i=0, j;
 	const struct dpa_priv_s	*priv;
 
 	priv = (typeof(priv))netdev_priv(net_dev);
@@ -1557,7 +1676,15 @@ static int __cold dpa_start(struct net_device *net_dev)
 		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
 
 	if (priv->mac_dev) {
-		for (i = 0; i < ARRAY_SIZE(priv->mac_dev->port_dev); i++)
+		_errno = init_phy(net_dev);
+		if(_errno) {
+			if (netif_msg_ifup(priv))
+				cpu_netdev_err(net_dev, "%s:%hu:%s(): init_phy() = %d\n",
+					       __file__, __LINE__, __func__, _errno);
+			goto _return_port_dev_stop;
+		}
+
+		for (; i < ARRAY_SIZE(priv->mac_dev->port_dev); i++)
 			fm_port_enable(priv->mac_dev->port_dev[i]);
 
 		_errno = priv->mac_dev->start(priv->mac_dev);
@@ -1567,6 +1694,7 @@ static int __cold dpa_start(struct net_device *net_dev)
 					       __file__, __LINE__, __func__, _errno);
 			goto _return_port_dev_stop;
 		}
+		phy_start(priv->phydev);
 	}
 
 	netif_tx_start_all_queues(net_dev);
@@ -1598,6 +1726,8 @@ static int __cold dpa_stop(struct net_device *net_dev)
 
 	_errno = 0;
 	if (priv->mac_dev) {
+		phy_stop(priv->phydev);
+
 		__errno = priv->mac_dev->stop(priv->mac_dev);
 		if (unlikely(__errno < 0)) {
 			if (netif_msg_ifdown(priv))
diff --git a/drivers/net/dpa/dpa.h b/drivers/net/dpa/dpa.h
index ae4ab95..07c00de 100644
--- a/drivers/net/dpa/dpa.h
+++ b/drivers/net/dpa/dpa.h
@@ -69,6 +69,7 @@ struct dpa_priv_s {
 #endif /* CONFIG_FSL_FMAN_TEST */
 
 	struct mac_device	*mac_dev;
+	struct phy_device	*phydev;
 
 	struct work_struct	 fd_work;
 	struct fd_list_head	*fd_list;
diff --git a/drivers/net/dpa/mac-api.c b/drivers/net/dpa/mac-api.c
index 3868dfa..c1bdf28 100644
--- a/drivers/net/dpa/mac-api.c
+++ b/drivers/net/dpa/mac-api.c
@@ -111,13 +111,13 @@ static int __devinit __cold init(struct mac_device *mac_dev)
 
 	priv = (typeof(priv))macdev_priv(mac_dev);
 
-	param.baseAddr =  (uint64_t)((size_t)(mac_dev->vaddr));
+	param.baseAddr =  devm_ioremap(mac_dev->dev, mac_dev->res->start, 0x2000);
 	param.enetMode	= macdev2enetinterface(mac_dev);
 	memcpy(&param.addr, mac_dev->addr, min(sizeof(param.addr), sizeof(mac_dev->addr)));
 	param.f_Exceptions	= mac_exception;
 	param.h_App		= mac_dev;
 	param.macId		= mac_dev->cell_index;
-    param.h_Fm = (t_Handle)mac_dev->fm;
+	param.h_Fm = (t_Handle)mac_dev->fm;
 
 	priv->mac = FM_MAC_Config(&param);
 	if (unlikely(priv->mac == NULL)) {
@@ -226,6 +226,20 @@ static int __cold change_promisc(struct mac_device *mac_dev)
 	return _errno;
 }
 
+static int __cold adjust_link(struct mac_device *mac_dev, uint16_t speed, bool full_duplex)
+{
+	int	 _errno;
+	t_Error	 err;
+
+	err = FM_MAC_AdjustLink(((struct mac_priv_s *)macdev_priv(mac_dev))->mac, speed, full_duplex);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_AdjustLink() = 0x%08x\n",
+			    __file__, __LINE__, __func__, err);
+
+	return _errno;
+}
+
 static int __cold uninit(struct mac_device *mac_dev)
 {
 	int			 _errno, __errno;
@@ -258,6 +272,7 @@ static void __devinit __cold setup_dtsec(struct mac_device *mac_dev)
 	mac_dev->start		= start;
 	mac_dev->stop		= stop;
 	mac_dev->change_promisc	= change_promisc;
+	mac_dev->adjust_link	= adjust_link;
 	mac_dev->uninit		= uninit;
 }
 
@@ -267,6 +282,7 @@ static void __devinit __cold setup_xgmac(struct mac_device *mac_dev)
 	mac_dev->start		= start;
 	mac_dev->stop		= stop;
 	mac_dev->change_promisc	= change_promisc;
+	mac_dev->adjust_link	= adjust_link;
 	mac_dev->uninit		= uninit;
 }
 
diff --git a/drivers/net/dpa/mac.c b/drivers/net/dpa/mac.c
index 6986c4d..1dd40d4 100644
--- a/drivers/net/dpa/mac.c
+++ b/drivers/net/dpa/mac.c
@@ -33,14 +33,25 @@
 #include <linux/module.h>
 #include <linux/of_platform.h>
 #include <linux/device.h>
+#include <linux/phy.h>
 
 #include "dpa-common.h"
 
 #include "lnxwrp_fm_ext.h"
 
+#include "fsl_pq_mdio.h"
 #include "mac.h"
 
 #define PHY_INTERFACE_MODE_XGMII    (PHY_INTERFACE_MODE_RTBI+1)
+#define DTSEC_SUPPORTED \
+	(SUPPORTED_10baseT_Half \
+	| SUPPORTED_10baseT_Full \
+	| SUPPORTED_100baseT_Half \
+	| SUPPORTED_100baseT_Full \
+	| SUPPORTED_1000baseT_Half \
+	| SUPPORTED_1000baseT_Full \
+	| SUPPORTED_Autoneg \
+	| SUPPORTED_MII)
 
 static const char phy_str[][11] __devinitconst =
 {
@@ -130,6 +141,7 @@ static int __devinit __cold mac_probe(struct of_device *_of_dev, const struct of
 	const char		*char_prop;
 	const phandle		*phandle_prop;
 	const uint32_t		*uint32_prop;
+	char bus_name[MII_BUS_ID_SIZE];
 
 	dev = &_of_dev->dev;
 
@@ -277,6 +289,9 @@ static int __devinit __cold mac_probe(struct of_device *_of_dev, const struct of
 	mac_dev->half_duplex	= false;
 	mac_dev->speed		= phy2speed[mac_dev->phy_if];
 	mac_dev->max_speed	= mac_dev->speed;
+	mac_dev->if_support = DTSEC_SUPPORTED;
+	if (strstr(char_prop, "sgmii") && (mac_dev->max_speed == 1000))
+		mac_dev->if_support &= ~SUPPORTED_1000baseT_Half;
 
 	/* Get the rest of the PHY information */
 	phandle_prop = (typeof(phandle_prop))of_get_property(mac_node, "phy-handle", &lenp);
@@ -318,18 +333,11 @@ static int __devinit __cold mac_probe(struct of_device *_of_dev, const struct of
 	of_node_put(dev_node);
 	dev_node = tmp_node;
 
-	/* Get the MDIO bus address */
-	_errno = of_address_to_resource(dev_node, 0, &res);
-	if (unlikely(_errno < 0)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): of_address_to_resource(%s) = %d\n",
-			    __file__, __LINE__, __func__, dev_node->full_name, _errno);
-		goto _return_of_node_put;
-	}
-	of_node_put(dev_node);
-
 	/* Build the PHY id/address */
-	_errno = snprintf(mac_dev->phy_id, sizeof(mac_dev->phy_id), "%llx:%02x",
-			  res.start, *uint32_prop);
+	fsl_pq_mdio_bus_name(bus_name, dev_node);
+	of_node_put(dev_node);
+	_errno = snprintf(mac_dev->phy_id, sizeof(mac_dev->phy_id), "%s:%02x",
+				bus_name, *uint32_prop);
 	if (unlikely(_errno < 0 || _errno >= sizeof(mac_dev->phy_id))) {
 		cpu_dev_err(dev, "%s:%hu:%s(): snprintf() = %d\n",
 			    __file__, __LINE__, __func__, _errno);
diff --git a/drivers/net/dpa/mac.h b/drivers/net/dpa/mac.h
index c95cb18..4fb2619 100644
--- a/drivers/net/dpa/mac.h
+++ b/drivers/net/dpa/mac.h
@@ -53,6 +53,7 @@ struct mac_device {
 	struct fm_port	*port_dev[2];
 
 	phy_interface_t		 phy_if;
+	u32					 if_support;
 	bool			 link;
 	bool			 half_duplex;
 	uint16_t		 speed;
@@ -65,6 +66,7 @@ struct mac_device {
 	int (*start)(struct mac_device *mac_dev);
 	int (*stop)(struct mac_device *mac_dev);
 	int (*change_promisc)(struct mac_device *mac_dev);
+	int (*adjust_link)(struct mac_device *mac_dev, uint16_t speed, bool full_duplex);
 	int (*uninit)(struct mac_device *mac_dev);
 };
 
diff --git a/drivers/net/fsl_pq_mdio.c b/drivers/net/fsl_pq_mdio.c
index 3acac5f..50988e3 100644
--- a/drivers/net/fsl_pq_mdio.c
+++ b/drivers/net/fsl_pq_mdio.c
@@ -317,6 +317,7 @@ static int fsl_pq_mdio_probe(struct of_device *ofdev,
 	if (of_device_is_compatible(np, "fsl,gianfar-mdio") ||
 			of_device_is_compatible(np, "fsl,gianfar-tbi") ||
 			of_device_is_compatible(np, "fsl,ucc-mdio") ||
+			of_device_is_compatible(np, "fsl,fman-mdio") ||
 			of_device_is_compatible(np, "ucc_geth_phy"))
 		map -= offsetof(struct fsl_pq_mdio, miimcfg);
 	regs = map;
@@ -366,6 +367,13 @@ static int fsl_pq_mdio_probe(struct of_device *ofdev,
 		err = -ENODEV;
 		goto err_free_irqs;
 #endif
+	} else if (of_device_is_compatible(np, "fsl,fman-mdio")) {
+#ifdef CONFIG_FSL_FMAN
+		tbiaddr = 5;
+#else
+		err = -ENODEV;
+		goto err_free_irqs;
+#endif
 	} else {
 		err = -ENODEV;
 		goto err_free_irqs;
@@ -384,7 +392,9 @@ static int fsl_pq_mdio_probe(struct of_device *ofdev,
 	}
 
 	if (tbiaddr == -1) {
+#ifndef CONFIG_FSL_FMAN
 		out_be32(tbipa, 0);
+#endif
 
 		tbiaddr = fsl_pq_mdio_find_free(new_bus);
 	}
@@ -399,7 +409,9 @@ static int fsl_pq_mdio_probe(struct of_device *ofdev,
 		goto err_free_irqs;
 	}
 
+#ifndef CONFIG_FSL_FMAN
 	out_be32(tbipa, tbiaddr);
+#endif
 
 	err = of_mdiobus_register(new_bus, np);
 	if (err) {
@@ -464,6 +476,9 @@ static struct of_device_id fsl_pq_mdio_match[] = {
 	{
 		.compatible = "fsl,etsec2-mdio",
 	},
+	{
+		.compatible = "fsl,fman-mdio",
+	},
 	{},
 };
 MODULE_DEVICE_TABLE(of, fsl_pq_mdio_match);
@@ -479,7 +494,7 @@ int __init fsl_pq_mdio_init(void)
 {
 	return of_register_platform_driver(&fsl_pq_mdio_driver);
 }
-module_init(fsl_pq_mdio_init);
+subsys_initcall_sync(fsl_pq_mdio_init);
 
 void fsl_pq_mdio_exit(void)
 {
diff --git a/drivers/net/phy/vitesse.c b/drivers/net/phy/vitesse.c
index dd3b244..6306e8d 100644
--- a/drivers/net/phy/vitesse.c
+++ b/drivers/net/phy/vitesse.c
@@ -54,6 +54,7 @@
 #define MII_VSC8221_AUXCONSTAT_INIT	0x0004 /* need to set this bit? */
 #define MII_VSC8221_AUXCONSTAT_RESERVED	0x0004
 
+#define PHY_ID_VSC8234			0x000fc620
 #define PHY_ID_VSC8244			0x000fc6c0
 #define PHY_ID_VSC8221			0x000fc550
 
@@ -109,7 +110,8 @@ static int vsc82xx_config_intr(struct phy_device *phydev)
 
 	if (phydev->interrupts == PHY_INTERRUPT_ENABLED)
 		err = phy_write(phydev, MII_VSC8244_IMASK,
-			phydev->drv->phy_id == PHY_ID_VSC8244 ?
+			((phydev->drv->phy_id == PHY_ID_VSC8234) ||
+			 (phydev->drv->phy_id == PHY_ID_VSC8244)) ?
 				MII_VSC8244_IMASK_MASK :
 				MII_VSC8221_IMASK_MASK);
 	else {
@@ -143,6 +145,21 @@ static struct phy_driver vsc8244_driver = {
 	.driver 	= { .owner = THIS_MODULE,},
 };
 
+/* Vitesse 823x */
+static struct phy_driver vsc8234_driver = {
+	.phy_id		= PHY_ID_VSC8234,
+	.name		= "Vitesse VSC8234",
+	.phy_id_mask	= 0x000ffff0,
+	.features	= PHY_GBIT_FEATURES,
+	.flags		= PHY_HAS_INTERRUPT,
+	.config_init	= &vsc824x_config_init,
+	.config_aneg	= &genphy_config_aneg,
+	.read_status	= &genphy_read_status,
+	.ack_interrupt	= &vsc824x_ack_interrupt,
+	.config_intr	= &vsc82xx_config_intr,
+	.driver 	= { .owner = THIS_MODULE,},
+};
+
 static int vsc8221_config_init(struct phy_device *phydev)
 {
 	int err;
@@ -180,6 +197,12 @@ static int __init vsc82xx_init(void)
 	err = phy_driver_register(&vsc8221_driver);
 	if (err < 0)
 		phy_driver_unregister(&vsc8244_driver);
+	err = phy_driver_register(&vsc8234_driver);
+	if (err < 0) {
+	 	phy_driver_unregister(&vsc8244_driver);
+	 	phy_driver_unregister(&vsc8221_driver);
+	}
+
 	return err;
 }
 
-- 
1.6.5.2

