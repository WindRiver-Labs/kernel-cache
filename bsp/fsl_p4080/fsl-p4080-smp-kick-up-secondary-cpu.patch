From 21bf68b680219ca89b131419e93eccb65faa32f6 Mon Sep 17 00:00:00 2001
From: Yongli He <yongli.he@windriver.com>
Date: Thu, 10 Dec 2009 21:35:27 -0800
Subject: [PATCH 3/7] fsl-p4080/smp: kick up secondary cpu

Create the infrastructure to kick a secondary cpu.

 1.kick an AP using hypervisor constructs
 2.remove TLB setting on AP
 3.hook smp init on wrhv-p4080ds platform

Sign-off-by: Yongli He <yongli.he@windriver.com>
---
 arch/powerpc/kernel/head_wrhv.S            |   30 ++-----------
 arch/powerpc/kernel/vbi/wrhv.c             |   65 ++++++++++++++++++++++++++++
 arch/powerpc/platforms/85xx/Makefile       |    2 +
 arch/powerpc/platforms/85xx/wrhv_p4080ds.c |    4 +-
 4 files changed, 73 insertions(+), 28 deletions(-)

diff --git a/arch/powerpc/kernel/head_wrhv.S b/arch/powerpc/kernel/head_wrhv.S
index 604be90..49062ed 100644
--- a/arch/powerpc/kernel/head_wrhv.S
+++ b/arch/powerpc/kernel/head_wrhv.S
@@ -102,6 +102,7 @@ _ENTRY(_start);
 #define TLBSX_CODE		0x7c005724
 #define MAS6_AS1		0x0001
 #define MAS6_AS0		0xFFFE
+#define WRHV_COREID_OFFSET	0x98
 
 _ENTRY(__early_start)
 	/*
@@ -145,7 +146,9 @@ _ENTRY(__early_start)
  	 * is just an emulation. PIR is defined in enrey_32.S,
  	 * the default value is zero.
  	 */
- 	WRHV_MFPIR(r24)
+ 	lis	r24, 0xF0000000@h
+	ori	r24, r24, 0xF0000000@l
+	lwz	r24, WRHV_COREID_OFFSET(r24)
 	cmpwi	r24,0
 	bne	__secondary_start
 #endif
@@ -1308,27 +1311,6 @@ __secondary_start:
 	mr	r4,r24		/* Why? */
 	bl	call_setup_cpu
 
-	/* r26 should be safe, here */
-	lis	r26, tlbcam_index@ha
-	lwz	r26, tlbcam_index@l(r26)
-
-	/* Load CAM 0 */
-	li	r3,0
-	bl	loadcam_entry
-
-	/* Load CAM 1, if it's set */
-	li	r3,1
-	cmpw	r3,r26
-	bgt	1f
-	bl	loadcam_entry
-1:
-	/* Load CAM 2, if it's set */
-	li	r3,2
-	cmpw	r3,r26
-	bgt	2f
-	bl	loadcam_entry
-2:
-
 	/* get current_thread_info and current */
 	lis	r1,secondary_ti@ha
 	lwz	r1,secondary_ti@l(r1)
@@ -1343,10 +1325,6 @@ __secondary_start:
 	addi	r4,r2,THREAD	/* address of our thread_struct */
 	mtspr	SPRN_SPRG3,r4
 
-	/* Setup the defaults for TLB entries */
-	li	r4,(MAS4_TSIZED(BOOKE_PAGESZ_4K))@l
-	mtspr	SPRN_MAS4,r4
-
 	/* Jump to start_secondary */
 	lis	r4,MSR_KERNEL@h
 	ori	r4,r4,MSR_KERNEL@l
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index b7d5b41..3220dc3 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -116,6 +116,9 @@
 #include <linux/hwtimer.h>
 
 #include <asm/cputhreads.h>
+#include <vbi/vbi.h>
+#include <asm/tlb.h>
+#include <asm/arch_vbi.h>
 
 static struct vb_config __wr_config;
 struct vb_config *wr_config;		/* TODO kernel relocation friendly ? */
@@ -1054,6 +1057,63 @@ int fsl8572_get_pci_intr_wrhv(struct pci_dev *dev)
 }
 #endif /* CONFIG_WRHV_8572 & CONFIG_PCI*/
 
+#ifdef  CONFIG_SMP
+
+extern volatile unsigned long __secondary_hold_acknowledge;
+VBI_HREG_SET bootREG;
+
+static void __init  smp_wrhv_kick_cpu(int nr)
+{
+	unsigned long flags;
+	int32_t ret;
+	
+
+	int n = 0;
+	WARN_ON (nr < 0 || nr >= NR_CPUS);
+
+	local_irq_save(flags);
+
+	ret=vbi_vb_read_reg(&bootREG,	VBI_BOARD_ID_GET(),nr);
+	if(ret)
+        	printk("WRHV read REG failed:%d\n",ret);
+
+	bootREG.pc = 0xC0000000;
+
+	ret=vbi_vb_write_reg(&bootREG,	VBI_BOARD_ID_GET(),nr);
+	if(ret)
+	       	printk("WRHV write REG failed:%d\n",ret);
+
+	ret=vbi_vb_resume(VBI_BOARD_ID_GET(), nr);
+        if(ret)
+		printk("WRHV resume CPU failed:%d\n",ret);
+
+	/* Wait a bit for the CPU to ack. */
+	while ((__secondary_hold_acknowledge != nr) && (++n < 1000))
+		mdelay(1);
+
+	local_irq_restore(flags);
+
+}
+#ifdef CONFIG_PPC85xx_VT_MODE
+unsigned long mpc85xx_smp_message[NR_CPUS]; /*fix doorbell_exception link error */
+#endif
+struct smp_ops_t smp_wrhv_ops = {
+	.kick_cpu = smp_wrhv_kick_cpu,
+#if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PPC32)
+	.cpu_enable = generic_cpu_enable,
+	.cpu_disable = generic_cpu_disable,
+	.cpu_die = generic_cpu_die,
+#endif
+};
+
+void __init wrhv_smp_init(void)
+{
+	smp_ops = &smp_wrhv_ops;
+}
+
+
+#endif
+
 #ifdef CONFIG_SMP
 extern struct smp_ops_t *smp_ops;
 extern volatile unsigned int cpu_callin_map[NR_CPUS];
@@ -1095,6 +1155,11 @@ int __devinit wrhv_start_secondary(void *unused)
 	unsigned int cpu = smp_processor_id();
 	struct device_node *l2_cache;
 	int i, base;
+      
+#ifndef CONFIG_PPC85xx_VT_MODE
+	vb_context_mmu_on(0, swapper_pg_dir, PAGE_SIZE, 0);
+#endif
+	vbi_set_exc_base((char*)0xC0000000);
 
 	atomic_inc(&init_mm.mm_count);
 	current->active_mm = &init_mm;
diff --git a/arch/powerpc/platforms/85xx/Makefile b/arch/powerpc/platforms/85xx/Makefile
index 9f546ea..d38a9e3 100644
--- a/arch/powerpc/platforms/85xx/Makefile
+++ b/arch/powerpc/platforms/85xx/Makefile
@@ -1,7 +1,9 @@
 #
 # Makefile for the PowerPC 85xx linux kernel.
 #
+ifndef CONFIG_WRHV_P4080DS
 obj-$(CONFIG_SMP) += smp.o
+endif
 obj-$(CONFIG_AMP) += amp.o
 
 obj-$(CONFIG_MPC8540_ADS) += mpc85xx_ads.o
diff --git a/arch/powerpc/platforms/85xx/wrhv_p4080ds.c b/arch/powerpc/platforms/85xx/wrhv_p4080ds.c
index f517ade..e498ad3 100644
--- a/arch/powerpc/platforms/85xx/wrhv_p4080ds.c
+++ b/arch/powerpc/platforms/85xx/wrhv_p4080ds.c
@@ -85,7 +85,7 @@ static int get_bsp_clock_freq(void)
  * Setup the architecture
  */
 #ifdef CONFIG_SMP
-extern void __init mpc85xx_smp_init(int use_msgsnd, int has_mpic);
+extern void __init wrhv_smp_init(void);
 #endif
 
 
@@ -99,7 +99,7 @@ static void __init mpc85xx_ds_setup_arch(void)
 		ppc_md.progress("mpc85xx_ds_setup_arch()", 0);
 
 #ifdef CONFIG_SMP
-        mpc85xx_smp_init(1, 1);
+	wrhv_smp_init();
 #endif
 
 	wrhv_cpu_freq = get_bsp_clock_freq();
-- 
1.6.5.2

