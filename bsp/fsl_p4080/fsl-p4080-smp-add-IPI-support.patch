From 504dbdd4126f8772d25b50a31e740d24d06bf253 Mon Sep 17 00:00:00 2001
From: Yongli He <yongli.he@windriver.com>
Date: Thu, 10 Dec 2009 21:35:28 -0800
Subject: [PATCH] fsl-p4080/smp: add IPI support

Via a guest OS specific smpops, this implements IPI functionality
via the hypervisor vioapic interface.

Signed-off-by: Yongli He <yongli.he@windriver.com>
---
 arch/powerpc/include/asm/wrhv.h |    6 ++
 arch/powerpc/kernel/vbi/wrhv.c  |  140 +++++++++++++++++++++++++++++++++++++++
 2 files changed, 146 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/include/asm/wrhv.h b/arch/powerpc/include/asm/wrhv.h
index 6495671..0e0a5c9 100644
--- a/arch/powerpc/include/asm/wrhv.h
+++ b/arch/powerpc/include/asm/wrhv.h
@@ -29,6 +29,12 @@ extern int __init wrhv_earlycon_setup(void);
 extern int fsl8572_get_pci_intr_wrhv(struct pci_dev *dev);
 #endif
 
+extern int __init smp_wrhv_probe(void);
+extern void smp_wrhv_message_pass(int target, int msg);
+extern void __init smp_wrhv_setup_cpu(int cpu_nr);
+extern void wrhv_umask_IPIs_for_vcore(void);
+extern void wrhv_request_ipis(void);
+
 extern unsigned long wrhv_cpu_freq;
 
 #endif /* CONFIG_WRHV */
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index ef9e566..dd7e142 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -168,6 +168,11 @@ int __init wrhv_earlycon_setup(void)
 	return 0;
 }
 
+#ifdef CONFIG_SMP
+#define IPI_IRQ_BASE_NAME "ipi0"
+int irq_base = 0xFFFF; /*init as invalid IRQ number*/
+#endif
+
 static int __init wrhv_pci_devfn_setup(char *s)
 {
 	wrhv_pci_devfn = simple_strtoul(s, NULL, 0);
@@ -1191,6 +1196,136 @@ int fsl8572_get_pci_intr_wrhv(struct pci_dev *dev)
 #endif /* CONFIG_WRHV_8572 & CONFIG_PCI*/
 
 #ifdef  CONFIG_SMP
+static irqreturn_t wrhv_ipi_action(int irq, void *data)
+{
+	long ipi = (long)data;
+
+	smp_message_recv(ipi);
+
+	return IRQ_HANDLED;
+}
+
+void __init smp_wrhv_setup_cpu(int cpu_nr)
+{
+
+	return;
+}
+
+void wrhv_umask_IPIs_for_vcore(void)
+{
+	int i;
+
+	for (i = 0; i < 4; i++) {
+		 vbi_unmask_vioapic_irq(irq_base+i);
+	}
+}
+void wrhv_request_ipis(void)
+{
+/* Need call vbiIntVecFind to get IPI IRQ numbers
+ * from Hypervisor configuration. So comment out
+ * this temprorily.
+ * IPI0 (call function)		irq_base
+ * IPI1 (reschedule)		irq_base+1
+ * IPI2 (call function single)	irq_base+2
+ * IPI3 (debugger break)	irq_base+3
+ */
+	static char *ipi_names[] = {
+		"IPI0 (call function)",
+		"IPI1 (reschedule)",
+		"IPI2 (call function single)",
+		"IPI3 (debugger break)",
+	};
+	int i,err;
+
+
+	printk(KERN_INFO "WRHV requesting IPIs ... \n");
+	
+	irq_base = vbi_find_irq(IPI_IRQ_BASE_NAME, VB_INPUT_INT);
+	if (irq_base == VBI_INVALID_IRQ)
+		panic("WRHV reslove irq for IPI failed.\n");
+
+	for (i = 0; i < 4; i++) {
+		err = request_irq(irq_base+i, wrhv_ipi_action,
+				  IRQF_DISABLED|IRQF_PERCPU,
+				  ipi_names[i], (void *)i);
+		if (err) {
+			printk(KERN_ERR "WRHV Request of irq %d for IPI(%s) failed\n",			       irq_base+i,ipi_names[i]);
+			break;
+		}
+	}
+
+
+}
+int __init smp_wrhv_probe(void)
+{
+	int nr_cpus;
+
+	pr_debug("smp_mpic_probe()...\n");
+
+	nr_cpus = cpus_weight(cpu_possible_map);
+
+	pr_debug("nr_cpus: %d\n", nr_cpus);
+
+	if (nr_cpus > 1)
+		wrhv_request_ipis();
+
+	wrhv_umask_IPIs_for_vcore();
+
+	return nr_cpus;
+}
+
+static inline void wrhv_send_IPI_mask(int irq, cpumask_t mask)
+{
+	unsigned long coreset = cpus_addr(mask)[0];
+	unsigned long flags;
+
+	local_irq_save(flags);
+	WARN_ON(coreset & ~cpus_addr(cpu_online_map)[0]);
+	vbi_send_vcore_vioapic_irq(irq, coreset, 0);
+	local_irq_restore(flags);
+}
+void smp_wrhv_message_pass(int target, int msg)
+{
+  
+	/* make sure we're sending something that translates to an IPI */
+	if ((unsigned int)msg > 3) {
+		printk("SMP %d: smp_message_pass: unknown msg %d\n",
+		       smp_processor_id(), msg);
+		return;
+	}
+
+	switch (target) {
+	case MSG_ALL:{
+		cpumask_t mask,dst;
+		
+		cpus_setall(dst);
+		cpus_and(mask, dst, cpu_online_map);
+		wrhv_send_IPI_mask(msg+irq_base,mask);
+
+		break;
+		}
+	case MSG_ALL_BUT_SELF:{
+		cpumask_t mask,dst;
+		int self = smp_processor_id();
+		
+		cpus_setall(dst);
+		cpu_clear(self,dst);
+		cpus_and(mask, dst, cpu_online_map);
+		wrhv_send_IPI_mask(msg+irq_base,mask);
+		break;
+		}
+	default:{
+		cpumask_t mask,dst;
+		cpus_clear(dst);
+		cpu_set(target,dst);
+		cpus_and(mask, dst, cpu_online_map);
+		wrhv_send_IPI_mask(msg+irq_base,mask);
+		break;
+		}
+	}
+
+}
+
 
 extern volatile unsigned long __secondary_hold_acknowledge;
 VBI_HREG_SET bootREG;
@@ -1241,6 +1376,10 @@ struct smp_ops_t smp_wrhv_ops = {
 
 void __init wrhv_smp_init(void)
 {
+	smp_wrhv_ops.probe  =smp_wrhv_probe;
+	smp_wrhv_ops.message_pass = smp_wrhv_message_pass;
+	smp_wrhv_ops.setup_cpu = smp_wrhv_setup_cpu;
+
 	smp_ops = &smp_wrhv_ops;
 }
 
@@ -1293,6 +1432,7 @@ int __devinit wrhv_start_secondary(void *unused)
 	vb_context_mmu_on(0, swapper_pg_dir, PAGE_SIZE, 0);
 #endif
 	vbi_set_exc_base((char*)0xC0000000);
+	wrhv_umask_IPIs_for_vcore();
 
 	atomic_inc(&init_mm.mm_count);
 	current->active_mm = &init_mm;
-- 
1.6.5.2

