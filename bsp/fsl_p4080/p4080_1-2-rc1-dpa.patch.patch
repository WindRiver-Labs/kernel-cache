From cdd0ef04e022f59dc810796b099fecc858cd39ee Mon Sep 17 00:00:00 2001
From: Timur Tabi <timur@freescale.com>
Date: Fri, 16 Apr 2010 12:52:57 -0400
Subject: [PATCH 001/148] p4080_1-2-rc1-dpa.patch

drivers/net/dpa/dpa.c
drivers/net/dpa/dpa-common.h
drivers/net/dpa/dpa-ethtool.c
drivers/net/dpa/dpa.h
drivers/net/dpa/fman-conf.h
drivers/net/dpa/fm.c
drivers/net/dpa/fm.h
drivers/net/dpa/fm-wrapper.c
drivers/net/dpa/fm-wrapper.h
drivers/net/dpa/mac-api.c
drivers/net/dpa/mac.c
drivers/net/dpa/mac.h
drivers/net/dpa/Makefile
drivers/net/dpa/port.c
drivers/net/dpa/port.h
drivers/net/dpa/port-wrapper.c

Signed-off-by: Andy Fleming <afleming@freescale.com>
Signed-off-by: Donio Ron <rdonio@freescale.com>
Signed-off-by: Emil Medve <Emilian.Medve@Freescale.com>
Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
Signed-off-by: Shlomi Gridish <gridish@freescale.com>
Signed-off-by: Timur Tabi <timur@freescale.com>
Signed-off-by: Yashpal Dutta <yashpal.dutta@freescale.com>

[Cleanly applied patch from Freescale SDK:
"p4080_1-2-rc1-dpa.patch",
original had no commit log text]
Integrated-by: Yuri Nedel <Yuri.Nedel@windriver.com>
---
 drivers/net/dpa/Makefile       |   16 +
 drivers/net/dpa/dpa-common.h   |  101 ++
 drivers/net/dpa/dpa-ethtool.c  |  241 +++++
 drivers/net/dpa/dpa.c          | 2268 ++++++++++++++++++++++++++++++++++++++++
 drivers/net/dpa/dpa.h          |   81 ++
 drivers/net/dpa/fm-wrapper.c   |  155 +++
 drivers/net/dpa/fm-wrapper.h   |   44 +
 drivers/net/dpa/fm.c           |  378 +++++++
 drivers/net/dpa/fm.h           |  118 +++
 drivers/net/dpa/fman-conf.h    | 1606 ++++++++++++++++++++++++++++
 drivers/net/dpa/mac-api.c      |  288 +++++
 drivers/net/dpa/mac.c          |  439 ++++++++
 drivers/net/dpa/mac.h          |   80 ++
 drivers/net/dpa/port-wrapper.c |  299 ++++++
 drivers/net/dpa/port.c         |  252 +++++
 drivers/net/dpa/port.h         |   76 ++
 16 files changed, 6442 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/dpa/Makefile
 create mode 100644 drivers/net/dpa/dpa-common.h
 create mode 100644 drivers/net/dpa/dpa-ethtool.c
 create mode 100644 drivers/net/dpa/dpa.c
 create mode 100644 drivers/net/dpa/dpa.h
 create mode 100644 drivers/net/dpa/fm-wrapper.c
 create mode 100644 drivers/net/dpa/fm-wrapper.h
 create mode 100644 drivers/net/dpa/fm.c
 create mode 100644 drivers/net/dpa/fm.h
 create mode 100644 drivers/net/dpa/fman-conf.h
 create mode 100644 drivers/net/dpa/mac-api.c
 create mode 100644 drivers/net/dpa/mac.c
 create mode 100644 drivers/net/dpa/mac.h
 create mode 100644 drivers/net/dpa/port-wrapper.c
 create mode 100644 drivers/net/dpa/port.c
 create mode 100644 drivers/net/dpa/port.h

diff --git a/drivers/net/dpa/Makefile b/drivers/net/dpa/Makefile
new file mode 100644
index 0000000..505dac7
--- /dev/null
+++ b/drivers/net/dpa/Makefile
@@ -0,0 +1,16 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+EXTRA_CFLAGS += -I$(NET_DPA)
+
+#Netcomm SW tree
+obj-$(CONFIG_FSL_FMAN) += NetCommSw/
+obj-$(CONFIG_DPA) += fsl-mac.o fsl-dpa.o
+
+fsl-dpa-objs	:= dpa-ethtool.o dpa.o
+fsl-mac-objs	:= mac.o mac-api.o
diff --git a/drivers/net/dpa/dpa-common.h b/drivers/net/dpa/dpa-common.h
new file mode 100644
index 0000000..a113851
--- /dev/null
+++ b/drivers/net/dpa/dpa-common.h
@@ -0,0 +1,101 @@
+/* Copyright (c) 2008 - 2009, Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __DPA_COMMON_H
+#define __DPA_COMMON_H
+
+#include <linux/kernel.h>	/* pr_*() */
+#include <linux/device.h>	/* dev_*() */
+#include <linux/smp.h>		/* hard_smp_processor_id() */
+#ifndef CONFIG_SMP
+#include <asm/smp.h>		/* hard_smp_processor_id() */
+#endif
+
+#define __file__ KBUILD_BASENAME".c"	/* The basename of the source file is being compiled */
+
+#define __hot
+
+#define cpu_pr_emerg(format, arg...)	\
+	pr_emerg("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
+#define cpu_pr_alert(format, arg...)	\
+	pr_alert("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
+#define cpu_pr_crit(format, arg...)	\
+	pr_crit("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
+#define cpu_pr_err(format, arg...)	\
+	pr_err("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
+#define cpu_pr_warning(format, arg...)	\
+	pr_warning("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
+#define cpu_pr_notice(format, arg...)	\
+	pr_notice("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
+#define cpu_pr_info(format, arg...)	\
+	pr_info("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
+#define cpu_pr_debug(format, arg...)	\
+	pr_debug("cpu%d/%d: " format, hard_smp_processor_id(), smp_processor_id(), ##arg)
+
+/* Keep these in sync with the dev_*() definitions from linux/device.h */
+#define cpu_dev_emerg(dev, format, arg...)	\
+	cpu_pr_emerg("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
+#define cpu_dev_alert(dev, format, arg...)	\
+	cpu_pr_alert("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
+#define cpu_dev_crit(dev, format, arg...)	\
+	cpu_pr_crit("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
+#define cpu_dev_err(dev, format, arg...)	\
+	cpu_pr_err("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
+#define cpu_dev_warn(dev, format, arg...)	\
+	cpu_pr_warning("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
+#define cpu_dev_notice(dev, format, arg...)	\
+	cpu_pr_notice("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
+#define cpu_dev_info(dev, format, arg...)	\
+	cpu_pr_info("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
+#define cpu_dev_dbg(dev, format, arg...)	\
+	cpu_pr_debug("%s: %s: " format, dev_driver_string(dev), dev_name(dev) , ##arg)
+
+#define cpu_netdev_emerg(net_dev, format, arg...)	\
+	cpu_dev_emerg((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
+#define cpu_netdev_alert(net_dev, format, arg...)	\
+	cpu_dev_alert((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
+#define cpu_netdev_crit(net_dev, format, arg...)	\
+	cpu_dev_crit((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
+#define cpu_netdev_err(net_dev, format, arg...)		\
+	cpu_dev_err((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
+#define cpu_netdev_warn(net_dev, format, arg...)	\
+	cpu_dev_warn((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
+#define cpu_netdev_notice(net_dev, format, arg...)	\
+	cpu_dev_notice((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
+#define cpu_netdev_info(net_dev, format, arg...)	\
+	cpu_dev_info((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
+#define cpu_netdev_dbg(net_dev, format, arg...)		\
+	cpu_dev_dbg((net_dev)->dev.parent, "%s: " format, (net_dev)->name , ##arg)
+
+enum {RX, TX};
+
+#endif	/* __DPA_COMMON_H */
diff --git a/drivers/net/dpa/dpa-ethtool.c b/drivers/net/dpa/dpa-ethtool.c
new file mode 100644
index 0000000..b8a2ac5
--- /dev/null
+++ b/drivers/net/dpa/dpa-ethtool.c
@@ -0,0 +1,241 @@
+/* Copyright (c) 2008 - 2009, Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/string.h>
+
+#include "dpa.h"
+
+static int __cold dpa_get_settings(struct net_device *net_dev, struct ethtool_cmd *et_cmd)
+{
+	int			 _errno;
+	struct dpa_priv_s	*priv;
+
+	cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (unlikely(priv->mac_dev->phy_dev == NULL)) {
+		cpu_netdev_err(net_dev, "%s:%hu:%s(): phy device not initialized\n",
+			       __file__, __LINE__, __func__);
+		return -ENODEV;
+	}
+
+	_errno = phy_ethtool_gset(priv->mac_dev->phy_dev, et_cmd);
+	if (unlikely(_errno < 0))
+		cpu_netdev_err(net_dev, "%s:%hu:%s(): phy_ethtool_gset() = %d\n",
+			       __file__, __LINE__, __func__, _errno);
+
+	cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+
+static int __cold dpa_set_settings(struct net_device *net_dev, struct ethtool_cmd *et_cmd)
+{
+	int			 _errno;
+	struct dpa_priv_s	*priv;
+
+	cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (unlikely(priv->mac_dev->phy_dev == NULL)) {
+		cpu_netdev_err(net_dev, "%s:%hu:%s(): phy device not initialized\n",
+			       __file__, __LINE__, __func__);
+		return -ENODEV;
+	}
+
+	_errno = phy_ethtool_sset(priv->mac_dev->phy_dev, et_cmd);
+	if (unlikely(_errno < 0))
+		cpu_netdev_err(net_dev, "%s:%hu:%s(): phy_ethtool_sset() = %d\n",
+			       __file__, __LINE__, __func__, _errno);
+
+	cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+
+static void __cold dpa_get_drvinfo(struct net_device *net_dev, struct ethtool_drvinfo *drvinfo)
+{
+	int		 _errno;
+
+	cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	strncpy(drvinfo->driver, KBUILD_MODNAME,
+		sizeof(drvinfo->driver) - 1)[sizeof(drvinfo->driver)-1] = 0;
+	strncpy(drvinfo->version, VERSION,
+		sizeof(drvinfo->driver) - 1)[sizeof(drvinfo->version)-1] = 0;
+	_errno = snprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version), "%X", 0);
+
+	if (unlikely(_errno >= sizeof(drvinfo->fw_version))) {	/* Truncated output */
+		cpu_netdev_notice(net_dev, "%s:%hu:%s(): snprintf() = %d\n",
+				  __file__, __LINE__, __func__, _errno);
+	} else if (unlikely(_errno < 0)) {
+		cpu_netdev_warn(net_dev, "%s:%hu:%s(): snprintf() = %d\n",
+				__file__, __LINE__, __func__, _errno);
+		memset(drvinfo->fw_version, 0, sizeof(drvinfo->fw_version));
+	}
+	strncpy(drvinfo->bus_info, dev_name(net_dev->dev.parent->parent),
+		sizeof(drvinfo->bus_info) - 1)[sizeof(drvinfo->bus_info)-1] = 0;
+
+	cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+uint32_t __cold dpa_get_msglevel(struct net_device *net_dev)
+{
+	uint32_t	 msg_enable;
+
+	cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	msg_enable = ((struct dpa_priv_s *)netdev_priv(net_dev))->msg_enable;
+
+	cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+
+	return msg_enable;
+}
+
+void __cold dpa_set_msglevel(struct net_device *net_dev, uint32_t msg_enable)
+{
+	cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	((struct dpa_priv_s *)netdev_priv(net_dev))->msg_enable = msg_enable;
+
+	cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+int __cold dpa_nway_reset(struct net_device *net_dev)
+{
+	int			 _errno;
+	struct dpa_priv_s	*priv;
+
+	cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (unlikely(priv->mac_dev->phy_dev == NULL)) {
+		cpu_netdev_err(net_dev, "%s:%hu:%s(): phy device not initialized\n",
+			       __file__, __LINE__, __func__);
+		return -ENODEV;
+	}
+
+	_errno = 0;
+	if (priv->mac_dev->phy_dev->autoneg) {
+		_errno = phy_start_aneg(priv->mac_dev->phy_dev);
+		if (unlikely(_errno < 0))
+			cpu_netdev_err(net_dev, "%s:%hu:%s(): phy_start_aneg() = %d\n",
+				       __file__, __LINE__, __func__, _errno);
+	}
+
+	cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+
+void __cold dpa_get_ringparam(struct net_device *net_dev, struct ethtool_ringparam *et_ringparam)
+{
+	cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	et_ringparam->rx_max_pending	   = 0;
+	et_ringparam->rx_mini_max_pending  = 0;
+	et_ringparam->rx_jumbo_max_pending = 0;
+	et_ringparam->tx_max_pending	   = 0;
+
+	et_ringparam->rx_pending	   = 0;
+	et_ringparam->rx_mini_pending	   = 0;
+	et_ringparam->rx_jumbo_pending	   = 0;
+	et_ringparam->tx_pending	   = 0;
+
+	cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+void __cold dpa_get_pauseparam(struct net_device *net_dev, struct ethtool_pauseparam *et_pauseparam)
+{
+	struct dpa_priv_s	*priv;
+
+	cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (unlikely(priv->mac_dev->phy_dev == NULL)) {
+		cpu_netdev_err(net_dev, "%s:%hu:%s(): phy device not initialized\n",
+			       __file__, __LINE__, __func__);
+		return;
+	}
+
+	et_pauseparam->autoneg	= priv->mac_dev->phy_dev->autoneg;
+
+	cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+int __cold dpa_set_pauseparam(struct net_device *net_dev, struct ethtool_pauseparam *et_pauseparam)
+{
+	struct dpa_priv_s	*priv;
+
+	cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (unlikely(priv->mac_dev->phy_dev == NULL)) {
+		cpu_netdev_err(net_dev, "%s:%hu:%s(): phy device not initialized\n",
+			       __file__, __LINE__, __func__);
+		return -ENODEV;
+	}
+
+	priv->mac_dev->phy_dev->autoneg = et_pauseparam->autoneg;
+
+	cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+
+	return 0;
+}
+
+const struct ethtool_ops dpa_ethtool_ops __devinitconst = {
+	.get_settings		= dpa_get_settings,
+	.set_settings		= dpa_set_settings,
+	.get_drvinfo		= dpa_get_drvinfo,
+	.get_msglevel		= dpa_get_msglevel,
+	.set_msglevel		= dpa_set_msglevel,
+	.nway_reset		= dpa_nway_reset,
+	.get_link		= ethtool_op_get_link,
+	.get_ringparam		= dpa_get_ringparam,
+	.get_pauseparam		= dpa_get_pauseparam,
+	.set_pauseparam		= dpa_set_pauseparam,
+	.get_tx_csum		= ethtool_op_get_tx_csum,
+	.set_tx_csum		= ethtool_op_set_tx_csum,
+	.get_sg			= ethtool_op_get_sg,
+	.set_sg			= ethtool_op_set_sg,
+	.get_tso		= ethtool_op_get_tso,
+	.set_tso		= ethtool_op_set_tso,
+	.get_ufo		= ethtool_op_get_ufo,
+	.set_ufo		= ethtool_op_set_ufo,
+	.get_flags		= ethtool_op_get_flags,
+	.set_flags		= ethtool_op_set_flags
+};
diff --git a/drivers/net/dpa/dpa.c b/drivers/net/dpa/dpa.c
new file mode 100644
index 0000000..46c9558
--- /dev/null
+++ b/drivers/net/dpa/dpa.c
@@ -0,0 +1,2268 @@
+/* Copyright (c) 2008 - 2009, Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/sort.h>
+#include <linux/of_platform.h>
+#include <linux/io.h>
+#include <linux/etherdevice.h>
+#ifdef CONFIG_DPA_RX_0_COPY
+#include <linux/if_arp.h>	/* arp_hdr_len() */
+#include <linux/icmp.h>		/* struct icmphdr */
+#include <linux/ip.h>		/* struct iphdr */
+#include <linux/udp.h>		/* struct udphdr */
+#include <linux/tcp.h>		/* struct tcphdr */
+#endif
+#include <linux/percpu.h>
+
+#include "linux/fsl_bman.h"
+
+#include "fsl_fman.h"
+#include "fm_ext.h"
+
+#ifdef CONFIG_FSL_FMAN_TEST
+#include "fsl_fman_test.h"
+#endif /* CONFIG_FSL_FMAN_TEST */
+
+#include "dpa.h"
+
+#define ARRAY2_SIZE(arr)	(ARRAY_SIZE(arr) * ARRAY_SIZE((arr)[0]))
+
+#define DPA_NETIF_FEATURES	0
+
+#define DPA_DESCRIPTION "FSL DPA Ethernet driver"
+
+MODULE_LICENSE("Dual BSD/GPL");
+
+MODULE_AUTHOR("Emil Medve <Emilian.Medve@Freescale.com>");
+
+MODULE_DESCRIPTION(DPA_DESCRIPTION);
+
+static uint8_t debug = -1;
+module_param(debug, byte, S_IRUGO);
+MODULE_PARM_DESC(debug, "Module/Driver verbosity level");
+
+static uint16_t __devinitdata tx_timeout = 1000;
+module_param(tx_timeout, ushort, S_IRUGO);
+MODULE_PARM_DESC(tx_timeout, "The Tx timeout in ms");
+
+static const char rtx[][3] = {
+	[RX] = "RX",
+	[TX] = "TX"
+};
+
+/* BM */
+
+#ifdef DEBUG
+#define GFP_DPA_BP	(GFP_DMA | __GFP_ZERO)
+#define GFP_DPA		(GFP_KERNEL | __GFP_ZERO)
+#else
+#define GFP_DPA_BP	(GFP_DMA)
+#define GFP_DPA		(GFP_KERNEL)
+#endif
+
+#define DPA_BP_HEAD	64
+#define DPA_BP_SIZE(s)	(DPA_BP_HEAD + (s))
+
+#define FM_FD_STAT_ERRORS							  \
+	(FM_PORT_FRM_ERR_DMA			| FM_PORT_FRM_ERR_PHYSICAL	| \
+	 FM_PORT_FRM_ERR_SIZE			| FM_PORT_FRM_ERR_CLS_DISCARD	| \
+	 FM_PORT_FRM_ERR_EXTRACTION		| FM_PORT_FRM_ERR_NO_SCHEME	| \
+	 FM_PORT_FRM_ERR_ILL_PLCR		| FM_PORT_FRM_ERR_PRS_TIMEOUT	| \
+	 FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT	| FM_PORT_FRM_ERR_PRS_HDR_ERR)
+
+struct dpa_bp {
+	struct bman_pool		*pool;
+	union {
+		struct list_head	 list;
+		uint8_t			 bpid;
+	};
+	size_t				 count;
+	size_t				 size;
+	dma_addr_t			 paddr;
+	void				*vaddr;
+};
+
+static const size_t dpa_bp_size[] __devinitconst = {
+	DPA_BP_SIZE(128), DPA_BP_SIZE(512), DPA_BP_SIZE(1536)	/* Keep these sorted */
+};
+
+static void __cold dpa_bp_depletion(struct bman_portal	*portal,
+				    struct bman_pool	*pool,
+				    void		*cb_ctx,
+				    int			 depleted)
+{
+	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
+
+	BUG();
+
+	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
+}
+
+static int __devinit __must_check __cold __attribute__((nonnull))
+_dpa_bp_alloc(struct device *dev, struct list_head *list, struct dpa_bp *dpa_bp)
+{
+	int			 _errno, i, j;
+	struct bman_pool_params	 bp_params;
+	struct bm_buffer	 bmb[8];
+
+	BUG_ON(dpa_bp->size == 0);
+	BUG_ON(dpa_bp->count == 0);
+
+	if (dpa_bp->bpid == 0) {
+		_errno = bm_pool_new(&bp_params.bpid);
+		if (unlikely(_errno < 0)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): bm_pool_new() = %d\n",
+				    __file__, __LINE__, __func__, _errno);
+			goto _return;
+		}
+	} else
+		bp_params.bpid = dpa_bp->bpid;
+
+	bp_params.flags		= BMAN_POOL_FLAG_DEPLETION;
+	bp_params.cb		= dpa_bp_depletion;
+	bp_params.cb_ctx	= dpa_bp;
+
+	dpa_bp->pool = bman_new_pool(&bp_params);
+	if (unlikely(dpa_bp->pool == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): bman_new_pool() failed\n",
+			    __file__, __LINE__, __func__);
+		_errno = -ENOMEM;
+		goto _return_bm_pool_free;
+	}
+
+	if (dpa_bp->paddr == 0) {
+		dpa_bp->vaddr = alloc_pages_exact(dpa_bp->size * dpa_bp->count, GFP_DPA_BP);
+		if (unlikely(dpa_bp->vaddr == NULL)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): alloc_pages_exact() failed\n",
+				    __file__, __LINE__, __func__);
+			_errno = -ENOMEM;
+			goto _return_bman_free_pool;
+		}
+
+		dpa_bp->paddr = dma_map_single(dev, dpa_bp->vaddr, dpa_bp->size * dpa_bp->count,
+					       DMA_BIDIRECTIONAL);
+		if (unlikely(dpa_bp->paddr == 0)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): dma_map_single() failed\n",
+				    __file__, __LINE__, __func__);
+			_errno = -EIO;
+			goto _return_free_pages_exact;
+		}
+
+		/* Populate the pool */
+		for (i = 0; i < dpa_bp->count;) {
+			for (j = 0; j < ARRAY_SIZE(bmb) && i < dpa_bp->count; i++, j++) {
+				bmb[j].hi = 0;
+				bmb[j].lo = dpa_bp->paddr + i * dpa_bp->size;
+			}
+
+			_errno = bman_release(dpa_bp->pool, bmb, j, BMAN_RELEASE_FLAG_WAIT_INT);
+			if (unlikely(_errno < 0)) {
+				cpu_pr_err(KBUILD_MODNAME ": %s:%hu:%s(): bman_release(%hu) = %d\n",
+					   __file__, __LINE__, __func__,
+					   bman_get_params(dpa_bp->pool)->bpid, _errno);
+				goto _return_bman_acquire;
+			}
+		}
+	} else {
+		devm_request_mem_region(dev, dpa_bp->paddr, dpa_bp->size * dpa_bp->count,
+					KBUILD_MODNAME);
+		dpa_bp->vaddr = devm_ioremap_prot(dev,
+						  dpa_bp->paddr, dpa_bp->size * dpa_bp->count, 0);
+		if (unlikely(dpa_bp->vaddr == NULL)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): devm_ioremap() failed\n",
+				    __file__, __LINE__, __func__);
+			_errno = -EIO;
+			goto _return_bman_free_pool;
+		}
+	}
+
+	list_add_tail(&dpa_bp->list, list);
+
+	_errno = 0;
+	goto _return;
+
+_return_bman_acquire:
+	/* \todo	Drain the pool */
+	dma_unmap_single(dev, dpa_bp->paddr, dpa_bp->size * dpa_bp->count, DMA_BIDIRECTIONAL);
+_return_free_pages_exact:
+	free_pages_exact(dpa_bp->vaddr, dpa_bp->size * dpa_bp->count);
+_return_bman_free_pool:
+	bman_free_pool(dpa_bp->pool);
+_return_bm_pool_free:
+	if (dpa_bp->bpid == 0)
+		bm_pool_free(bp_params.bpid);
+_return:
+	return _errno;
+}
+
+static struct dpa_bp * __must_check __attribute__((nonnull))
+dpa_size2pool(const struct list_head *list, size_t size)
+{
+	struct dpa_bp	*dpa_bp;
+
+	list_for_each_entry(dpa_bp, list, list) {
+		if (DPA_BP_SIZE(size) <= dpa_bp->size)
+			return dpa_bp;
+	}
+	return ERR_PTR(-ENODEV);
+}
+
+static struct dpa_bp * __must_check __attribute__((nonnull))
+dpa_bpid2pool(const struct list_head *list, int bpid)
+{
+	struct dpa_bp	*dpa_bp;
+
+	list_for_each_entry(dpa_bp, list, list) {
+		if (bman_get_params(dpa_bp->pool)->bpid == bpid)
+			return dpa_bp;
+	}
+	return ERR_PTR(-EINVAL);
+}
+
+static int __cold __must_check __attribute__((nonnull))
+dpa_pool2bpid(const struct dpa_bp *dpa_bp)
+{
+	return bman_get_params(dpa_bp->pool)->bpid;
+}
+
+static void * __must_check __attribute__((nonnull))
+dpa_phys2virt(const struct dpa_bp *dpa_bp, const struct bm_buffer *bmb)
+{
+#ifdef CONFIG_BUG
+	const struct bman_pool_params	*bp_params;
+
+	bp_params = bman_get_params(dpa_bp->pool);
+#endif
+	BUG_ON(bp_params->cb_ctx != dpa_bp);
+	BUG_ON(bp_params->bpid != bmb->bpid);
+
+	return dpa_bp->vaddr + (bmb->lo - dpa_bp->paddr);
+}
+
+static void __cold __attribute__((nonnull))
+_dpa_bp_free(struct device *dev, struct dpa_bp *dpa_bp)
+{
+	uint8_t	bpid;
+
+	/* \todo	Drain the pool */
+
+	dma_unmap_single(dev, dpa_bp->paddr, dpa_bp->size * dpa_bp->count, DMA_BIDIRECTIONAL);
+	free_pages_exact(dpa_bp->vaddr, dpa_bp->size * dpa_bp->count);
+	bpid = dpa_pool2bpid(dpa_bp);
+	bman_free_pool(dpa_bp->pool);
+	list_del(&dpa_bp->list);
+	bm_pool_free(bpid);
+}
+
+static void __cold __attribute__((nonnull))
+dpa_bp_free(struct device *dev, struct list_head *list)
+{
+	struct dpa_bp	*dpa_bp, *tmp;
+
+	list_for_each_entry_safe(dpa_bp, tmp, list, list)
+		_dpa_bp_free(dev, dpa_bp);
+}
+
+/* QM */
+
+struct dpa_fq {
+	struct qman_fq	 	 fq_base;
+	struct list_head	 list;
+	struct net_device	*net_dev;
+	bool			 init;
+};
+
+static struct qman_fq * __devinit __cold __must_check __attribute__((nonnull))
+_dpa_fq_alloc(struct list_head		*list,
+	      struct dpa_fq		*dpa_fq,
+	      uint32_t			 fqid,
+	      uint32_t			 flags,
+	      uint16_t			 channel,
+	      uint8_t			 wq)
+{
+	int			 _errno;
+	const struct dpa_priv_s	*priv;
+	struct device		*dev;
+	struct qman_fq		*fq;
+	struct qm_mcc_initfq	 initfq;
+
+	priv = (typeof(priv))netdev_priv(dpa_fq->net_dev);
+	dev = dpa_fq->net_dev->dev.parent;
+
+	if (fqid == 0) {
+		flags |= QMAN_FQ_FLAG_DYNAMIC_FQID;
+		flags &= ~QMAN_FQ_FLAG_NO_MODIFY;
+	} else {
+		flags &= ~QMAN_FQ_FLAG_DYNAMIC_FQID;
+	}
+
+	dpa_fq->init	= !(flags & QMAN_FQ_FLAG_NO_MODIFY);
+
+	_errno = qman_create_fq(fqid, flags, &dpa_fq->fq_base);
+	if (unlikely(_errno)) {
+		if (netif_msg_probe(priv))
+			cpu_dev_err(dev, "%s:%hu:%s(): qman_create_fq() failed\n",
+				    __file__, __LINE__, __func__);
+		return ERR_PTR(_errno);
+	}
+	fq = &dpa_fq->fq_base;
+
+	if (dpa_fq->init) {
+		initfq.we_mask		= QM_INITFQ_WE_DESTWQ;
+		initfq.fqd.dest.channel	= channel;
+		initfq.fqd.dest.wq	= wq;
+
+		_errno = qman_init_fq(fq, QMAN_INITFQ_FLAG_SCHED, &initfq);
+		if (unlikely(_errno < 0)) {
+			if (netif_msg_probe(priv))
+				cpu_dev_err(dev, "%s:%hu:%s(): qman_init_fq(%u) = %d\n",
+					    __file__, __LINE__, __func__, qman_fq_fqid(fq), _errno);
+			qman_destroy_fq(fq, 0);
+			return ERR_PTR(_errno);
+		}
+	}
+
+	list_add_tail(&dpa_fq->list, list);
+
+	return fq;
+}
+
+static int __cold __attribute__((nonnull))
+_dpa_fq_free(struct device *dev, struct qman_fq *fq)
+{
+	int		 _errno, __errno;
+	struct dpa_fq	*dpa_fq;
+
+	_errno = 0;
+
+	dpa_fq = (struct dpa_fq *)fq;
+	if (dpa_fq->init) {
+		_errno = qman_retire_fq(fq, NULL);
+		if (unlikely(_errno < 0))
+			cpu_dev_err(dev, "%s:%hu:%s(): qman_retire_fq(%u) = %d\n",
+				    __file__, __LINE__, __func__, qman_fq_fqid(fq), _errno);
+
+		__errno = qman_oos_fq(fq);
+		if (unlikely(__errno < 0)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): qman_oos_fq(%u) = %d\n",
+				    __file__, __LINE__, __func__, qman_fq_fqid(fq), __errno);
+			if (_errno >= 0)
+				_errno = __errno;
+		}
+	}
+
+	qman_destroy_fq(fq, 0);
+	list_del(&dpa_fq->list);
+
+	return _errno;
+}
+
+static int __cold __attribute__((nonnull))
+dpa_fq_free(struct device *dev, struct list_head *list)
+{
+	int		 _errno, __errno;
+	struct dpa_fq	*dpa_fq, *tmp;
+
+	_errno = 0;
+	list_for_each_entry_safe(dpa_fq, tmp, list, list) {
+		__errno = _dpa_fq_free(dev, (struct qman_fq *)dpa_fq);
+		if (unlikely(__errno < 0) && _errno >= 0)
+			_errno = __errno;
+	}
+
+	return _errno;
+}
+
+struct dpa_fd {
+	struct qm_fd		 fd;
+	struct list_head	 list;
+};
+
+static inline ssize_t __const __must_check __attribute__((nonnull))
+dpa_fd_length(const struct qm_fd *fd)
+{
+	switch (fd->format) {
+	case qm_fd_contig:
+	case qm_fd_sg:
+		return fd->length20;
+	case qm_fd_contig_big:
+	case qm_fd_sg_big:
+		return fd->length29;
+	case qm_fd_compound:
+		return fd->cong_weight;
+	}
+	BUG();
+	return -EINVAL;
+}
+
+static inline ssize_t __const __must_check __attribute__((nonnull))
+dpa_fd_offset(const struct qm_fd *fd)
+{
+	switch (fd->format) {
+	case qm_fd_contig:
+	case qm_fd_sg:
+		return fd->offset;
+	case qm_fd_contig_big:
+	case qm_fd_sg_big:
+	case qm_fd_compound:
+		return 0;
+	}
+	BUG();
+	return -EINVAL;
+}
+
+static int __must_check __attribute__((nonnull))
+dpa_fd_release(const struct net_device *net_dev, const struct qm_fd *fd)
+{
+	int				 _errno, __errno, i, j;
+	const struct dpa_priv_s		*priv;
+	const struct qm_sg_entry	*sgt;
+	const struct dpa_bp		*_dpa_bp, *dpa_bp;
+	const struct bm_buffer		*_bmb;
+	struct bm_buffer		 bmb[8];
+
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	_bmb = (typeof(_bmb))fd;
+
+	_dpa_bp = dpa_bpid2pool(&priv->dpa_bp_list, _bmb->bpid);
+	BUG_ON(IS_ERR(_dpa_bp));
+
+	_errno = 0;
+	if (fd->format == qm_fd_sg) {
+		sgt = (typeof(sgt))(dpa_phys2virt(_dpa_bp, _bmb) + dpa_fd_offset(fd));
+
+		i = 0;
+		do {
+			dpa_bp = dpa_bpid2pool(&priv->dpa_bp_list, sgt[i].bpid);
+			BUG_ON(IS_ERR(dpa_bp));
+
+			j = 0;
+			do {
+				BUG_ON(sgt[i].extension);
+
+				bmb[j].bpid	= sgt[i].bpid;
+				bmb[j].hi	= sgt[i].addr_hi;
+				bmb[j].lo	= sgt[i].addr_lo;
+				j++; i++;
+			} while (j < ARRAY_SIZE(bmb) &&
+				 !sgt[i-1].final && sgt[i-1].bpid == sgt[i].bpid);
+
+			__errno = bman_release(dpa_bp->pool, bmb, j, BMAN_RELEASE_FLAG_WAIT_INT);
+			if (unlikely(__errno < 0)) {
+				cpu_netdev_err(net_dev, "%s:%hu:%s(): bman_release(%hu) = %d\n",
+					       __file__, __LINE__, __func__,
+					       bman_get_params(dpa_bp->pool)->bpid, _errno);
+				if (_errno >= 0)
+					_errno = __errno;
+			}
+		} while (!sgt[i-1].final);
+	}
+
+	__errno = bman_release(_dpa_bp->pool, _bmb, 1, BMAN_RELEASE_FLAG_WAIT_INT);
+	if (unlikely(__errno < 0)) {
+		cpu_netdev_err(net_dev, "%s:%hu:%s(): bman_release(%hu) = %d\n",
+			       __file__, __LINE__, __func__,
+			       bman_get_params(_dpa_bp->pool)->bpid, _errno);
+		if (_errno >= 0)
+			_errno = __errno;
+	}
+
+	return _errno;
+}
+
+/* net_device */
+
+#ifdef CONFIG_DPA_RX_0_COPY
+#define NN_ALLOCATED_SPACE(net_dev)	max((size_t)arp_hdr_len(net_dev),  sizeof(struct iphdr))
+#define NN_RESERVED_SPACE(net_dev)	min((size_t)arp_hdr_len(net_dev),  sizeof(struct iphdr))
+
+#define TT_ALLOCATED_SPACE(net_dev)	\
+	max(sizeof(struct icmphdr), max(sizeof(struct udphdr), sizeof(struct tcphdr)))
+#define TT_RESERVED_SPACE(net_dev)	\
+	min(sizeof(struct icmphdr), min(sizeof(struct udphdr), sizeof(struct tcphdr)))
+#endif
+
+static enum qman_cb_dqrr_result ingress_rx_error_dqrr(struct qman_portal		*portal,
+							struct qman_fq			*fq,
+							const struct qm_dqrr_entry	*dq)
+{
+	const struct net_device	*net_dev;
+	const struct dpa_priv_s	*priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (netif_msg_rx_status(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+#ifdef CONFIG_FSL_FMAN_TEST
+{
+    const struct bm_buffer *bmb;
+    const struct dpa_bp *dpa_bp;
+    void   *virt;
+    int	_errno;
+
+    bmb = (typeof(bmb))&dq->fd;
+
+    dpa_bp = dpa_bpid2pool(&priv->dpa_bp_list, bmb->bpid);
+    BUG_ON(IS_ERR(dpa_bp));
+
+    virt = dpa_phys2virt(dpa_bp, bmb);
+    if (is_fman_test((void *)priv->mac_dev,
+                     FMT_RX_ERR_Q,
+                     virt,
+                     dq->fd.length20 + dq->fd.offset)) {
+        _errno = dpa_fd_release(net_dev, &dq->fd);
+        if (unlikely(_errno < 0)) {
+            dump_stack();
+            panic("Can't release buffer to the BM during RX\n");
+        }
+        return qman_cb_dqrr_consume;
+    }
+}
+#endif /* CONFIG_FSL_FMAN_TEST */
+
+	BUG();
+
+	if (netif_msg_rx_status(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+
+	return qman_cb_dqrr_consume;
+}
+
+static void ingress_rx_error_ern(struct qman_portal		*portal,
+				 struct qman_fq			*fq,
+				 const struct qm_mr_entry	*msg)
+{
+	const struct net_device	*net_dev;
+	const struct dpa_priv_s	*priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (netif_msg_rx_status(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	BUG();
+
+	if (netif_msg_rx_status(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+static void ingress_rx_error_dc_ern(struct qman_portal		*portal,
+				    struct qman_fq		*fq,
+				    const struct qm_mr_entry	*msg)
+{
+	const struct net_device	*net_dev;
+	const struct dpa_priv_s	*priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (netif_msg_rx_status(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	BUG();
+
+	if (netif_msg_rx_status(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+static void ingress_rx_error_fqs(struct qman_portal		*portal,
+				 struct qman_fq			*fq,
+				 const struct qm_mr_entry	*msg)
+{
+	const struct net_device	*net_dev;
+	const struct dpa_priv_s	*priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (netif_msg_rx_status(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	BUG();
+
+	if (netif_msg_rx_status(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+static enum qman_cb_dqrr_result __hot
+ingress_rx_default_dqrr(struct qman_portal		*portal,
+			struct qman_fq			*fq,
+			const struct qm_dqrr_entry	*dq)
+{
+	const struct net_device	*net_dev;
+	struct dpa_priv_s	*priv;
+	struct dpa_fd		*dpa_fd;
+	struct fd_list_head	*fd_list;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (netif_msg_intr(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+#ifdef CONFIG_FSL_FMAN_TEST
+{
+    const struct bm_buffer	*bmb;
+    const struct dpa_bp		*dpa_bp;
+    void   					*virt;
+    int						 _errno, i;
+	struct dpa_fq			*dpa_fq;
+	uint32_t				fqid=0;
+
+	for(i=0; i<priv->num; i++)
+		if((dq->fqid >= priv->ranges[i].base) &&
+		   (dq->fqid < (priv->ranges[i].base+priv->ranges[i].count))) {
+			fqid = dq->fqid - priv->ranges[i].base;
+			break;
+		}
+
+	if (i == priv->num)
+		fqid = FMT_RX_DFLT_Q;
+
+	if (fqid == FMT_RX_DFLT_Q) {
+		list_for_each_entry(dpa_fq, priv->dpa_fq_list + RX, list) {
+			if (dq->fqid == qman_fq_fqid((struct qman_fq *)dpa_fq)) {
+				fqid = FMT_RX_ERR_Q;
+				break;
+			}
+		}
+		if (fqid == FMT_RX_ERR_Q)
+			fqid = FMT_RX_DFLT_Q;
+		else
+			BUG();
+	}
+
+    bmb = (typeof(bmb))&dq->fd;
+
+    dpa_bp = dpa_bpid2pool(&priv->dpa_bp_list, bmb->bpid);
+    BUG_ON(IS_ERR(dpa_bp));
+
+    virt = dpa_phys2virt(dpa_bp, bmb);
+    if (is_fman_test((void *)priv->mac_dev,
+                     fqid,
+                     virt,
+                     dq->fd.length20 + dq->fd.offset)) {
+        _errno = dpa_fd_release(net_dev, &dq->fd);
+        if (unlikely(_errno < 0)) {
+            dump_stack();
+            panic("Can't release buffer to the BM during RX\n");
+        }
+        goto _return;
+    }
+}
+#endif /* CONFIG_FSL_FMAN_TEST */
+
+	dpa_fd = (typeof(dpa_fd))devm_kzalloc(net_dev->dev.parent, sizeof(*dpa_fd), GFP_ATOMIC);
+	if (unlikely(dpa_fd == NULL)) {
+		if (netif_msg_rx_err(priv))
+			cpu_netdev_err(net_dev, "%s:%hu:%s(): devm_kzalloc() failed\n",
+				       __file__, __LINE__, __func__);
+		goto _return;
+	}
+
+	dpa_fd->fd = dq->fd;
+
+	fd_list = per_cpu_ptr(priv->fd_list, smp_processor_id());
+	list_add_tail(&dpa_fd->list, &fd_list->list);
+	fd_list->count++;
+	fd_list->max = max(fd_list->max, fd_list->count);
+
+	schedule_work(&priv->fd_work);
+
+_return:
+	if (netif_msg_intr(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+
+	return qman_cb_dqrr_consume;
+}
+
+static void ingress_rx_default_ern(struct qman_portal		*portal,
+				   struct qman_fq		*fq,
+				   const struct qm_mr_entry	*msg)
+{
+	const struct net_device	*net_dev;
+	const struct dpa_priv_s	*priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (netif_msg_rx_status(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	BUG();
+
+	if (netif_msg_rx_status(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+static void ingress_rx_default_dc_ern(struct qman_portal	*portal,
+			      struct qman_fq		*fq,
+			      const struct qm_mr_entry	*msg)
+{
+	const struct net_device	*net_dev;
+	const struct dpa_priv_s	*priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (netif_msg_rx_status(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	BUG();
+
+	if (netif_msg_rx_status(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+static void ingress_rx_default_fqs(struct qman_portal		*portal,
+				   struct qman_fq		*fq,
+				   const struct qm_mr_entry	*msg)
+{
+	const struct net_device	*net_dev;
+	const struct dpa_priv_s	*priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (netif_msg_rx_status(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	BUG();
+
+	if (netif_msg_rx_status(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+static enum qman_cb_dqrr_result ingress_tx_error_dqrr(struct qman_portal		*portal,
+						      struct qman_fq			*fq,
+						      const struct qm_dqrr_entry	*dq)
+{
+	const struct net_device	*net_dev;
+	const struct dpa_priv_s	*priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+#ifdef CONFIG_FSL_FMAN_TEST
+{
+    void   *virt = bus_to_virt(dq->fd.addr_lo);
+    if (is_fman_test((void *)priv->mac_dev,
+                     FMT_TX_ERR_Q,
+                     virt,
+                     dq->fd.length20 + dq->fd.offset)) {
+        return qman_cb_dqrr_consume;
+    }
+}
+#endif /* CONFIG_FSL_FMAN_TEST */
+
+	BUG();
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+
+	return qman_cb_dqrr_consume;
+}
+
+static void ingress_tx_error_ern(struct qman_portal		*portal,
+				 struct qman_fq			*fq,
+				 const struct qm_mr_entry	*msg)
+{
+	const struct net_device	*net_dev;
+	const struct dpa_priv_s	*priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	BUG();
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+static void ingress_tx_error_dc_ern(struct qman_portal		*portal,
+				    struct qman_fq		*fq,
+				    const struct qm_mr_entry	*msg)
+{
+	const struct net_device	*net_dev;
+	const struct dpa_priv_s	*priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	BUG();
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+static void ingress_tx_error_fqs(struct qman_portal		*portal,
+				 struct qman_fq			*fq,
+				 const struct qm_mr_entry	*msg)
+{
+	const struct net_device	*net_dev;
+	const struct dpa_priv_s	*priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	BUG();
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+static enum qman_cb_dqrr_result ingress_tx_default_dqrr(struct qman_portal		*portal,
+							struct qman_fq			*fq,
+							const struct qm_dqrr_entry	*dq)
+{
+	const struct net_device	*net_dev;
+	const struct dpa_priv_s	*priv;
+	struct sk_buff		*skb;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+#ifdef CONFIG_FSL_FMAN_TEST
+{
+    void   *virt = bus_to_virt(dq->fd.addr_lo);
+    if (is_fman_test((void *)priv->mac_dev,
+                     FMT_TX_CONF_Q,
+                     virt,
+                     dq->fd.length20 + dq->fd.offset)) {
+        return qman_cb_dqrr_consume;
+    }
+}
+#endif /* CONFIG_FSL_FMAN_TEST */
+
+	skb = *(typeof(&skb))bus_to_virt(dq->fd.addr_lo);
+
+	BUG_ON(net_dev != skb->dev);
+
+	dma_unmap_single(net_dev->dev.parent, dq->fd.addr_lo, skb_headlen(skb), DMA_TO_DEVICE);
+
+	dev_kfree_skb_irq(skb);
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+
+	return qman_cb_dqrr_consume;
+}
+
+static void ingress_tx_default_ern(struct qman_portal		*portal,
+				   struct qman_fq		*fq,
+				   const struct qm_mr_entry	*msg)
+{
+	const struct net_device	*net_dev;
+	const struct dpa_priv_s	*priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	BUG();
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+static void ingress_tx_default_dc_ern(struct qman_portal	*portal,
+				      struct qman_fq		*fq,
+				      const struct qm_mr_entry	*msg)
+{
+	const struct net_device	*net_dev;
+	const struct dpa_priv_s	*priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	BUG();
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+static void ingress_tx_default_fqs(struct qman_portal		*portal,
+				   struct qman_fq		*fq,
+				   const struct qm_mr_entry	*msg)
+{
+	const struct net_device	*net_dev;
+	const struct dpa_priv_s	*priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	BUG();
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+static enum qman_cb_dqrr_result egress_dqrr(struct qman_portal		*portal,
+					    struct qman_fq		*fq,
+					    const struct qm_dqrr_entry	*dq)
+{
+	const struct net_device	*net_dev;
+	const struct dpa_priv_s	*priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	BUG();
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+
+	return qman_cb_dqrr_consume;
+}
+
+static void egress_ern(struct qman_portal	*portal,
+		       struct qman_fq		*fq,
+		       const struct qm_mr_entry	*msg)
+{
+	int			 _errno;
+	struct net_device	*net_dev;
+	const struct dpa_priv_s	*priv;
+	struct sk_buff		*skb;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	if (priv->mac_dev) {
+		skb = *(typeof(&skb))bus_to_virt(msg->ern.fd.addr_lo);
+
+		BUG_ON(net_dev != skb->dev);
+
+		dma_unmap_single(net_dev->dev.parent, msg->ern.fd.addr_lo, skb_headlen(skb),
+				 DMA_TO_DEVICE);
+
+		dev_kfree_skb_irq(skb);
+	} else {
+		_errno = dpa_fd_release(net_dev, &msg->ern.fd);
+		if (unlikely(_errno < 0)) {
+			dump_stack();
+			panic("Can't release buffer to the BM during a TX\n");
+		}
+	}
+
+	net_dev->stats.tx_dropped++;
+	net_dev->stats.tx_fifo_errors++;
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+static void egress_dc_ern(struct qman_portal		*portal,
+			  struct qman_fq		*fq,
+			  const struct qm_mr_entry	*msg)
+{
+	const struct net_device	*net_dev;
+	const struct dpa_priv_s	*priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	BUG();
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+static void egress_fqs(struct qman_portal	*portal,
+		       struct qman_fq		*fq,
+		       const struct qm_mr_entry	*msg)
+{
+	const struct net_device	*net_dev;
+	const struct dpa_priv_s	*priv;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	BUG();
+
+	if (netif_msg_tx_err(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+static const struct qman_fq ingress_fqs[][2] __devinitconst = {
+	[RX] = {
+		/* Error */
+		{.cb = {ingress_rx_error_dqrr, ingress_rx_error_ern, ingress_rx_error_dc_ern, ingress_rx_error_fqs}},
+		 /* Default */
+		{.cb = {ingress_rx_default_dqrr, ingress_rx_default_ern, ingress_rx_default_dc_ern, ingress_rx_default_fqs}}
+	},
+	[TX] = {
+		/* Error */
+		{.cb = {ingress_tx_error_dqrr, ingress_tx_error_ern, ingress_tx_error_dc_ern, ingress_tx_error_fqs}},
+		 /* Default */
+		{.cb = {ingress_tx_default_dqrr, ingress_tx_default_ern, ingress_tx_default_dc_ern, ingress_tx_default_fqs}}
+	}
+};
+
+static const struct qman_fq _egress_fqs __devinitconst = {
+	.cb = {egress_dqrr, egress_ern, egress_dc_ern, egress_fqs}
+};
+
+#ifdef CONFIG_DPA_RX_0_COPY
+static void __hot dpa_skb_destructor(struct sk_buff *skb)
+{
+	int		_errno;
+	struct dpa_bp	*dpa_bp;
+
+	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
+
+	if (!skb->cloned ||
+	    !atomic_sub_return(skb->nohdr ? (1 << SKB_DATAREF_SHIFT) + 1 : 1,
+			       &skb_shinfo(skb)->dataref)) {
+
+		dpa_bp = *(typeof(&dpa_bp))(skb->head + sizeof(struct bm_buffer));
+
+#ifdef DEBUG
+		memset(dpa_phys2virt(dpa_bp, (struct bm_buffer *)skb->head), 0, dpa_bp->size);
+#endif
+
+		_errno = bman_release(dpa_bp->pool, (struct bm_buffer *)skb->head, 1,
+				      BMAN_RELEASE_FLAG_WAIT_INT);
+		if (unlikely(_errno < 0)) {
+			cpu_pr_err(KBUILD_MODNAME ": %s:%hu:%s(): bman_release(%hu) = %d\n",
+				   __file__, __LINE__, __func__,
+				   bman_get_params(dpa_bp->pool)->bpid, _errno);
+			dump_stack();
+			panic("Can't release buffer to the BM during RX\n");
+		}
+	}
+
+	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
+}
+#endif
+
+static struct net_device_stats * __cold dpa_get_stats(struct net_device *net_dev)
+{
+	cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+
+	return &net_dev->stats;
+}
+
+static void __cold dpa_change_rx_flags(struct net_device *net_dev, int flags)
+{
+	int			 _errno;
+	const struct dpa_priv_s	*priv;
+
+	cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if ((flags & IFF_PROMISC) != 0 && priv->mac_dev != NULL) {
+		_errno = priv->mac_dev->change_promisc(priv->mac_dev);
+		if (unlikely(_errno < 0))
+			cpu_netdev_err(net_dev, "%s:%hu:%s(): mac_dev->change_promisc() = %d\n",
+				       __file__, __LINE__, __func__, _errno);
+	}
+
+	cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+static void __hot dpa_rx(struct work_struct *fd_work)
+{
+	int			 _errno;
+	struct net_device	*net_dev;
+	const struct dpa_priv_s	*priv;
+	struct fd_list_head	*fd_list;
+	struct dpa_fd		*dpa_fd, *tmp;
+	const struct bm_buffer	*bmb;
+	const struct dpa_bp	*dpa_bp;
+	size_t			 head, size;
+	struct sk_buff		*skb;
+	void			*virt;
+#ifdef CONFIG_DPA_RX_0_COPY
+	struct page		*page;
+#endif
+
+	priv = (typeof(priv))container_of(fd_work, struct dpa_priv_s, fd_work);
+	net_dev = priv->net_dev;
+
+	if (netif_msg_rx_status(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	fd_list = per_cpu_ptr(priv->fd_list, smp_processor_id());
+	list_for_each_entry_safe(dpa_fd, tmp, &fd_list->list, list) {
+		skb = NULL;
+
+		if (unlikely(dpa_fd->fd.status & FM_FD_STAT_ERRORS) != 0) {
+			if (netif_msg_rx_err(priv))
+				cpu_netdev_err(net_dev, "%s:%hu:%s(): FD status = 0x%08x\n",
+					       __file__, __LINE__, __func__,
+					       dpa_fd->fd.status & FM_FD_STAT_ERRORS);
+
+			net_dev->stats.rx_errors++;
+
+			goto _continue_dpa_fd_release;
+		}
+
+		net_dev->stats.rx_packets++;
+		net_dev->stats.rx_bytes += dpa_fd_length(&dpa_fd->fd);
+
+		if (dpa_fd->fd.format == qm_fd_sg) {
+			net_dev->stats.rx_dropped++;
+
+			goto _continue_dpa_fd_release;
+		}
+
+		BUG_ON(dpa_fd->fd.format != qm_fd_contig);
+
+		bmb = (typeof(bmb))&dpa_fd->fd;
+
+		dpa_bp = dpa_bpid2pool(&priv->dpa_bp_list, bmb->bpid);
+		BUG_ON(IS_ERR(dpa_bp));
+
+		virt = dpa_phys2virt(dpa_bp, bmb);
+
+#ifdef CONFIG_DPA_RX_0_COPY
+		if (virt_addr_valid(virt)) {
+			head = sizeof(*bmb) + sizeof(dpa_bp) + NET_IP_ALIGN;
+			size = ETH_HLEN + NN_ALLOCATED_SPACE(net_dev) + TT_ALLOCATED_SPACE(net_dev);
+		} else
+#endif
+		{
+			head = NET_IP_ALIGN;
+			size = dpa_fd_length(&dpa_fd->fd);
+		}
+
+		skb = __netdev_alloc_skb(net_dev, head + size, GFP_DPA);
+		if (unlikely(skb == NULL)) {
+			if (netif_msg_rx_err(priv))
+				cpu_netdev_err(net_dev,
+					       "%s:%hu:%s(): netdev_alloc_skb() failed\n",
+					       __file__, __LINE__, __func__);
+
+			net_dev->stats.rx_dropped++;
+
+			goto _continue_dpa_fd_release;
+		}
+
+		skb_reserve(skb, head);
+
+#ifdef CONFIG_DPA_RX_0_COPY
+		if (virt_addr_valid(virt)) {
+			skb->destructor = dpa_skb_destructor;
+
+			*(struct bm_buffer *)skb->head = *bmb;
+			*(typeof(&dpa_bp))(skb->head + sizeof(*bmb)) = dpa_bp;
+
+			get_page(page = virt_to_page(virt + dpa_fd_offset(&dpa_fd->fd)));
+
+			skb_fill_page_desc(skb, 0, page,
+					   (uintptr_t)(virt + dpa_fd_offset(&dpa_fd->fd)) & ~PAGE_MASK,
+					   dpa_fd_length(&dpa_fd->fd));
+
+			skb->len	+= dpa_fd_length(&dpa_fd->fd);
+			skb->data_len	+= dpa_fd_length(&dpa_fd->fd);
+			skb->truesize	+= dpa_bp->size;
+
+			if (unlikely(!__pskb_pull_tail(skb,
+						       ETH_HLEN +
+						       NN_RESERVED_SPACE(net_dev) +
+						       TT_RESERVED_SPACE(net_dev)))) {
+				if (netif_msg_rx_err(priv))
+					cpu_netdev_err(net_dev,
+						       "%s:%hu:%s(): __pskb_pull_tail() failed\n",
+						       __file__, __LINE__, __func__);
+
+				net_dev->stats.rx_dropped++;
+
+				goto _continue_dev_kfree_skb;
+			}
+		} else
+#endif
+		{
+			memcpy(skb_put(skb, size), virt + dpa_fd_offset(&dpa_fd->fd), size);
+
+			_errno = dpa_fd_release(net_dev, &dpa_fd->fd);
+			if (unlikely(_errno < 0)) {
+				dump_stack();
+				panic("Can't release buffer to the BM during RX\n");
+			}
+		}
+
+		skb->protocol = eth_type_trans(skb, net_dev);
+
+		_errno = netif_rx_ni(skb);
+		if (unlikely(_errno != NET_RX_SUCCESS)) {
+			if (netif_msg_rx_status(priv))
+				cpu_netdev_warn(net_dev, "%s:%hu:%s(): netif_rx_ni() = %d\n",
+						__file__, __LINE__, __func__, _errno);
+			net_dev->stats.rx_dropped++;
+		}
+
+		net_dev->last_rx = jiffies;
+
+		goto _continue;
+
+_continue_dpa_fd_release:
+		_errno = dpa_fd_release(net_dev, &dpa_fd->fd);
+		if (unlikely(_errno < 0)) {
+			dump_stack();
+			panic("Can't release buffer to the BM during RX\n");
+		}
+#ifdef CONFIG_DPA_RX_0_COPY
+_continue_dev_kfree_skb:
+		dev_kfree_skb(skb);
+#endif
+_continue:
+
+		local_irq_disable();
+		list_del(&dpa_fd->list);
+		fd_list->count--;
+		local_irq_enable();
+
+		devm_kfree(net_dev->dev.parent, dpa_fd);
+	}
+
+	if (netif_msg_rx_status(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+static int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
+{
+	int			 _errno, __errno;
+	const struct dpa_priv_s	*priv;
+	struct device		*dev;
+	struct qm_fd		 fd;
+	struct dpa_bp		*dpa_bp = NULL;
+	struct bm_buffer	*bmb = NULL;
+
+	priv = (typeof(priv))netdev_priv(net_dev);
+	dev = net_dev->dev.parent;
+
+	if (netif_msg_tx_queued(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	/* We don't have yet support for SG */
+	SKB_LINEAR_ASSERT(skb);
+
+	memset(&fd, 0, sizeof(fd));
+	fd.format	= qm_fd_contig;
+	fd.offset	= DPA_BP_HEAD;
+
+	if (priv->mac_dev) {
+		*((typeof(&skb))skb_push(skb, DPA_BP_HEAD)) = skb;
+
+		fd.addr_lo	= dma_map_single(dev, skb->data, skb_headlen(skb), DMA_TO_DEVICE);
+		if (unlikely(fd.addr_lo == 0)) {
+			cpu_netdev_err(net_dev, "%s:%hu:%s(): dma_map_single() failed\n",
+				       __file__, __LINE__, __func__);
+			_errno = -EIO;
+			goto _return_dev_kfree_skb;
+		}
+
+		fd.length20	= skb_headlen(skb) - DPA_BP_HEAD;
+	} else {
+		dpa_bp = dpa_size2pool(&priv->dpa_bp_list, skb_headlen(skb));
+		BUG_ON(IS_ERR(dpa_bp));
+
+		bmb = (typeof(bmb))&fd;
+
+		_errno = bman_acquire(dpa_bp->pool, bmb, 1, 0);
+		if (unlikely(_errno <= 0)) {
+			if (netif_msg_tx_err(priv))
+				cpu_netdev_err(net_dev, "%s:%hu:%s(): bman_acquire() = %d\n",
+					       __file__, __LINE__, __func__, _errno);
+			net_dev->stats.tx_errors++;
+			goto _return_dev_kfree_skb;
+		}
+
+		fd.length20	= skb_headlen(skb);
+		fd.cmd		= FM_FD_CMD_FCO;
+
+		/* Copy the packet payload */
+		skb_copy_from_linear_data(skb, dpa_phys2virt(dpa_bp, bmb) + dpa_fd_offset(&fd),
+					  dpa_fd_length(&fd));
+	}
+
+	_errno = qman_enqueue(priv->egress_fqs[skb_get_queue_mapping(skb)], &fd, 0);
+	if (unlikely(_errno < 0)) {
+		if (netif_msg_tx_err(priv))
+			cpu_netdev_err(net_dev, "%s:%hu:%s(): qman_enqueue() = %d\n",
+				       __file__, __LINE__, __func__, _errno);
+		net_dev->stats.tx_errors++;
+		net_dev->stats.tx_fifo_errors++;
+		goto _return_buffer;
+	}
+
+	net_dev->stats.tx_packets++;
+	net_dev->stats.tx_bytes += dpa_fd_length(&fd);
+
+	_errno = NETDEV_TX_OK;
+
+	if (priv->mac_dev)
+		goto _return;
+	else
+		goto _return_dev_kfree_skb;
+
+_return_buffer:
+	if (priv->mac_dev)
+		dma_unmap_single(dev, fd.addr_lo, skb_headlen(skb), DMA_TO_DEVICE);
+	else {
+		__errno = dpa_fd_release(net_dev, &fd);
+		if (unlikely(__errno < 0)) {
+			dump_stack();
+			panic("Can't release buffer to the BM during a TX\n");
+		}
+	}
+_return_dev_kfree_skb:
+	dev_kfree_skb(skb);
+_return:
+	if (netif_msg_tx_queued(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+
+static int __cold dpa_start(struct net_device *net_dev)
+{
+	int			 _errno, i, j;
+	const struct dpa_priv_s	*priv;
+
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (netif_msg_ifup(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	if (priv->mac_dev) {
+		for (i = 0; i < ARRAY_SIZE(priv->mac_dev->port_dev); i++)
+			fm_port_enable(priv->mac_dev->port_dev[i]);
+
+		_errno = priv->mac_dev->start(priv->mac_dev);
+		if (unlikely(_errno < 0)) {
+			if (netif_msg_ifup(priv))
+				cpu_netdev_err(net_dev, "%s:%hu:%s(): mac_dev->start() = %d\n",
+					       __file__, __LINE__, __func__, _errno);
+			goto _return_port_dev_stop;
+		}
+	}
+
+	netif_tx_start_all_queues(net_dev);
+
+	_errno = 0;
+	goto _return;
+
+_return_port_dev_stop:
+	for (j = 0; j < i; j++)
+		fm_port_disable(priv->mac_dev->port_dev[j]);
+_return:
+	if (netif_msg_ifup(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+
+static int __cold dpa_stop(struct net_device *net_dev)
+{
+	int			 _errno, __errno, i;
+	const struct dpa_priv_s	*priv;
+
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (netif_msg_ifdown(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	netif_tx_stop_all_queues(net_dev);
+
+	_errno = 0;
+	if (priv->mac_dev) {
+		__errno = priv->mac_dev->stop(priv->mac_dev);
+		if (unlikely(__errno < 0)) {
+			if (netif_msg_ifdown(priv))
+				cpu_netdev_err(net_dev, "%s:%hu:%s(): mac_dev->stop() = %d\n",
+					       __file__, __LINE__, __func__, __errno);
+			if (likely(_errno >= 0))
+				_errno = __errno;
+		}
+
+		for (i = 0; i < ARRAY_SIZE(priv->mac_dev->port_dev); i++)
+			fm_port_disable(priv->mac_dev->port_dev[i]);
+	}
+
+	if (netif_msg_ifdown(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+
+static void __cold dpa_timeout(struct net_device *net_dev)
+{
+	const struct dpa_priv_s	*priv;
+
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	if (netif_msg_timer(priv))
+		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	if (netif_msg_timer(priv))
+		cpu_netdev_crit(net_dev, "Transmit timeout latency: %lu ms\n",
+				(jiffies - net_dev->trans_start) * 1000 / HZ);
+
+	net_dev->stats.tx_errors++;
+	netif_tx_wake_all_queues(net_dev);
+
+	if (netif_msg_timer(priv))
+		cpu_netdev_dbg(net_dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+static int __devinit __cold __pure __must_check __attribute__((nonnull))
+dpa_bp_cmp(const void *dpa_bp0, const void *dpa_bp1)
+{
+	return ((struct dpa_bp *)dpa_bp0)->size - ((struct dpa_bp *)dpa_bp1)->size;
+}
+
+static struct dpa_bp * __devinit __cold __must_check __attribute__((nonnull))
+dpa_bp_probe(struct of_device *_of_dev, size_t *count)
+{
+	int			 i, lenp, na, ns;
+	struct device		*dev;
+	struct device_node	*dev_node;
+	const phandle		*phandle_prop;
+	const uint32_t		*uint32_prop;
+	struct dpa_bp		*dpa_bp;
+
+	dev = &_of_dev->dev;
+
+	/* Get the buffer pools to be used */
+	phandle_prop = (typeof(phandle_prop))of_get_property(_of_dev->node, "fsl,bman-buffer-pools",
+							     &lenp);
+	if (phandle_prop == NULL) {
+		dpa_bp = NULL;
+		goto _return_count;
+	}
+
+	*count = lenp / sizeof(phandle);
+	dpa_bp = (typeof(dpa_bp))devm_kzalloc(dev, *count * sizeof(*dpa_bp), GFP_KERNEL);
+	if (unlikely(dpa_bp == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): devm_kzalloc() failed\n",
+			    __file__, __LINE__, __func__);
+		dpa_bp = ERR_PTR(-ENOMEM);
+		goto _return_count;
+	}
+
+	dev_node = of_find_node_by_path("/");
+	if (unlikely(dev_node == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): of_find_node_by_path(/) failed\n",
+			    __file__, __LINE__, __func__);
+		dpa_bp = ERR_PTR(-EINVAL);
+		goto _return_count;
+	}
+
+	na = of_n_addr_cells(dev_node);
+	ns = of_n_size_cells(dev_node);
+	of_node_put(dev_node);
+
+	for (i = 0; i < *count; i++) {
+		dev_node = of_find_node_by_phandle(phandle_prop[i]);
+		if (unlikely(dev_node == NULL)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): of_find_node_by_phandle() failed\n",
+				    __file__, __LINE__, __func__);
+			return ERR_PTR(-EFAULT);
+		}
+
+		if (unlikely(!of_device_is_compatible(dev_node, "fsl,bpool"))) {
+			cpu_dev_err(dev, "%s:%hu:%s(): !of_device_is_compatible(%s, fsl,bpool)\n",
+				    __file__, __LINE__, __func__, dev_node->full_name);
+			dpa_bp = ERR_PTR(-EINVAL);
+			goto _return_of_node_put;
+		}
+
+		uint32_prop = of_get_property(dev_node, "fsl,bpid", &lenp);
+		if (unlikely(uint32_prop == NULL)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): of_get_property(%s, fsl,bpid) failed\n",
+				    __file__, __LINE__, __func__, dev_node->full_name);
+			dpa_bp = ERR_PTR(-EINVAL);
+			goto _return_of_node_put;
+		}
+		BUG_ON(lenp != sizeof(uint32_t));
+		dpa_bp[i].bpid = *uint32_prop;
+
+		uint32_prop = of_get_property(dev_node, "fsl,bpool-cfg", &lenp);
+		if (uint32_prop != NULL) {
+			BUG_ON(lenp != (2 * ns + na) * sizeof(uint32_t));
+
+			dpa_bp[i].count	= of_read_number(uint32_prop, ns);
+			dpa_bp[i].size	= of_read_number(uint32_prop + ns, ns);
+			dpa_bp[i].paddr	= of_read_number(uint32_prop + 2 * ns, na);
+		}
+
+		of_node_put(dev_node);
+	}
+
+	sort(dpa_bp, *count, sizeof(*dpa_bp), dpa_bp_cmp, NULL);
+
+	goto _return;
+
+_return_of_node_put:
+	of_node_put(dev_node);
+_return_count:
+	*count = 0;
+_return:
+	return dpa_bp;
+}
+
+static struct mac_device * __devinit __cold __must_check __attribute__((nonnull))
+dpa_mac_probe(struct of_device *_of_dev)
+{
+	struct device		*dpa_dev, *dev;
+	struct device_node	*mac_node;
+	int			 lenp;
+	const phandle		*phandle_prop;
+	struct of_device	*of_dev;
+	struct mac_device	*mac_dev;
+
+	phandle_prop = (typeof(phandle_prop))of_get_property(_of_dev->node, "fsl,fman-mac", &lenp);
+	if (phandle_prop == NULL)
+		return NULL;
+
+	BUG_ON(lenp != sizeof(phandle));
+
+	dpa_dev = &_of_dev->dev;
+
+	mac_node = of_find_node_by_phandle(*phandle_prop);
+	if (unlikely(mac_node == NULL)) {
+		cpu_dev_err(dpa_dev, "%s:%hu:%s(): of_find_node_by_phandle() failed\n",
+			    __file__, __LINE__, __func__);
+		return ERR_PTR(-EFAULT);
+	}
+
+	of_dev = of_find_device_by_node(mac_node);
+	if (unlikely(of_dev == NULL)) {
+		cpu_dev_err(dpa_dev, "%s:%hu:%s(): of_find_device_by_node(%s) failed\n",
+			    __file__, __LINE__, __func__, mac_node->full_name);
+		of_node_put(mac_node);
+		return ERR_PTR(-EINVAL);
+	}
+	of_node_put(mac_node);
+
+	dev = &of_dev->dev;
+
+	mac_dev = (typeof(mac_dev))dev_get_drvdata(dev);
+	if (unlikely(mac_dev == NULL)) {
+		cpu_dev_err(dpa_dev, "%s:%hu:%s(): dev_get_drvdata(%s) failed\n",
+			    __file__, __LINE__, __func__, dev_name(dev));
+		return ERR_PTR(-EINVAL);
+	}
+
+	return mac_dev;
+}
+
+static const char fsl_qman_frame_queues[][25] __devinitconst = {
+	[RX] = "fsl,qman-frame-queues-rx",
+	[TX] = "fsl,qman-frame-queues-tx"
+};
+
+static int __devinit __cold dpa_alloc_pcd_fqids(struct device	*dev,
+						uint32_t	 num,
+						uint8_t		 alignment,
+						uint32_t	*base_fqid)
+{
+	int			 _errno, i;
+	struct net_device	*net_dev;
+	struct dpa_priv_s	*priv;
+	struct dpa_fq		*dpa_fq;
+	struct qman_fq		*ingress_fq;
+	uint32_t			 total_num_fqs = num + alignment;
+	uint32_t			 padding = 0;
+	uint32_t			prev_fqid;
+
+	net_dev = (typeof(net_dev))dev_get_drvdata(dev);
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	dpa_fq = (typeof(dpa_fq))devm_kzalloc(dev, total_num_fqs * sizeof(*dpa_fq), GFP_KERNEL);
+	if (unlikely(dpa_fq == NULL)) {
+		if (netif_msg_probe(priv))
+			cpu_dev_err(dev, "%s:%hu:%s(): devm_kzalloc() failed\n",
+				    __file__, __LINE__, __func__);
+		_errno = -ENOMEM;
+		goto _return;
+	}
+
+	for (i = 0, ingress_fq = NULL; i < total_num_fqs; i++, dpa_fq++) {
+		dpa_fq->fq_base	= ingress_fqs[RX][1];
+		dpa_fq->net_dev	= net_dev;
+		prev_fqid = (ingress_fq ? qman_fq_fqid(ingress_fq) : 0);
+		ingress_fq = _dpa_fq_alloc(priv->dpa_fq_list + RX, dpa_fq, 0,
+					   QMAN_FQ_FLAG_NO_ENQUEUE, priv->channel, 7);
+		if (IS_ERR(ingress_fq)) {
+			_errno = PTR_ERR(ingress_fq);
+			goto _return;
+		}
+
+		if (prev_fqid && ((prev_fqid - 1) != qman_fq_fqid(ingress_fq))) {
+			if (netif_msg_probe(priv))
+				cpu_dev_err(dev, "%s:%hu:%s(): Failed to allocate a contiguous range of FQs\n",
+					    __file__, __LINE__, __func__);
+			_errno = -EINVAL;
+			goto _return;
+		}
+
+		cpu_dev_dbg(dev, "%s:%s(): ingress_pcd_fqs[%d] = %u\n",
+			    __file__, __func__, i, qman_fq_fqid(ingress_fq));
+	}
+
+	*base_fqid = qman_fq_fqid(ingress_fq);
+	if (alignment)
+		padding = alignment - (*base_fqid % alignment);
+	*base_fqid += padding;
+	BUG_ON((total_num_fqs-padding)<num);
+#ifdef CONFIG_FSL_FMAN_TEST
+	BUG_ON(priv->num >= (sizeof(priv->ranges)/sizeof(struct pcd_range)));
+	priv->ranges[priv->num].base    = *base_fqid;
+	priv->ranges[priv->num++].count = num;
+#endif /* CONFIG_FSL_FMAN_TEST */
+
+	cpu_dev_dbg(dev, "%s:%s(): pcd_fqs base %u\n",__file__, __func__,*base_fqid);
+
+	_errno = 0;
+
+_return:
+	cpu_dev_dbg(dev, "%s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+
+static int __devinit __cold __attribute__((nonnull)) dpa_init_probe(struct of_device *_of_dev)
+{
+	int				 _errno, i, j, lenp;
+	struct device			*dev;
+	struct mac_device		*mac_dev;
+	struct dpa_bp			*dpa_bp;
+	struct fm_port_rx_params	 rx_port_param;
+	struct fm_port_non_rx_params	 tx_port_param;
+	struct fm_port_pcd_param	 rx_port_pcd_param;
+	size_t				 count;
+	struct device_node		*dpa_node;
+	const uint32_t			*uint32_prop;
+	uint32_t			 ingress_fqids[ARRAY_SIZE(fsl_qman_frame_queues)][2];
+
+	dev = &_of_dev->dev;
+
+	cpu_dev_dbg(dev, "-> %s:%s()\n", __file__, __func__);
+
+	dpa_node = _of_dev->node;
+
+	/* FM */
+
+	mac_dev = dpa_mac_probe(_of_dev);
+	if (IS_ERR(mac_dev)) {
+		_errno = PTR_ERR(mac_dev);
+		goto _return;
+	} else if(mac_dev == NULL) {
+		cpu_dev_err(dev, "%s:%hu:%s(): Missing the %s/fsl,fman-mac property\n",
+			    __file__, __LINE__, __func__, dpa_node->full_name);
+		_errno = -EINVAL;
+		goto _return;
+	}
+
+	/* BM */
+
+	dpa_bp = dpa_bp_probe(_of_dev, &count);
+	if (IS_ERR(dpa_bp)) {
+		_errno = PTR_ERR(dpa_bp);
+		goto _return;
+	} else if (unlikely(dpa_bp == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): Missing the %s/fsl,bman-buffer-pools property\n",
+			    __file__, __LINE__, __func__, dpa_node->full_name);
+		_errno = -EINVAL;
+		goto _return;
+	}
+
+	rx_port_param.num_pools = min(ARRAY_SIZE(rx_port_param.pool_param), count);
+	for (i = 0; i < rx_port_param.num_pools; i++) {
+		rx_port_param.pool_param[i].id	 = dpa_bp[i].bpid;
+		rx_port_param.pool_param[i].size = dpa_bp[i].size;
+
+		cpu_dev_dbg(dev, "%s:%s(): dpa_bp[%d] = {%hu, %u}\n",
+			    __file__, __func__,
+			    i, rx_port_param.pool_param[i].id, rx_port_param.pool_param[i].size);
+	}
+	devm_kfree(dev, dpa_bp);
+
+	/* QM */
+
+	for (i = 0; i < ARRAY_SIZE(ingress_fqids); i++) {
+		uint32_prop = (typeof(uint32_prop))of_get_property(dpa_node,
+								   fsl_qman_frame_queues[i],
+								   &lenp);
+		if (unlikely(uint32_prop == NULL)) {
+			cpu_dev_info(dev, "%s:%hu:%s(): of_get_property(%s, %s) failed\n",
+				     __file__, __LINE__, __func__,
+				     dpa_node->full_name, fsl_qman_frame_queues[i]);
+			_errno = -EINVAL;
+			goto _return;
+		}
+		BUG_ON(lenp != ARRAY_SIZE(ingress_fqids[i]) * 2 * sizeof(uint32_t));
+
+		for (j = 0; j < ARRAY_SIZE(ingress_fqids[i]); j++) {
+			ingress_fqids[i][j] = uint32_prop[j * 2];
+			BUG_ON(uint32_prop[j * 2 + 1] != 1);
+		}
+	}
+
+	/* Set error FQs */
+	rx_port_param.errq	= ingress_fqids[RX][0];
+	tx_port_param.errq	= ingress_fqids[TX][0];
+
+	/* Set default FQs */
+	rx_port_param.defq	= ingress_fqids[RX][1];
+	tx_port_param.defq	= ingress_fqids[TX][1];
+
+	rx_port_param.priv_data_size	= tx_port_param.priv_data_size	= 32;
+	rx_port_param.parse_results	= tx_port_param.parse_results	= true;
+
+	fm_set_rx_port_params(mac_dev->port_dev[RX], &rx_port_param);
+
+	/* Set PCD FQs */
+	rx_port_pcd_param.cb	= dpa_alloc_pcd_fqids;
+	rx_port_pcd_param.dev	= dev;
+	fm_port_pcd_bind(mac_dev->port_dev[RX], &rx_port_pcd_param);
+
+	fm_set_tx_port_params(mac_dev->port_dev[TX], &tx_port_param);
+
+	for (i = 0; i < ARRAY_SIZE(mac_dev->port_dev); i++)
+		fm_port_enable(mac_dev->port_dev[i]);
+
+	_errno = 0;
+
+_return:
+	cpu_dev_dbg(dev, "%s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+
+static int __devinit __cold __attribute__((nonnull)) dpa_probe(struct of_device *_of_dev)
+{
+	int				 _errno, i, j, lenp;
+	struct device			*dev;
+	struct device_node		*dpa_node, *dev_node;
+	struct net_device		*net_dev;
+	struct dpa_priv_s		*priv;
+	struct dpa_bp			*dpa_bp;
+	struct dpa_fq			*dpa_fq;
+	struct fd_list_head		*fd_list;
+	struct fm_port_rx_params	 rx_port_param;
+	struct fm_port_non_rx_params	 tx_port_param;
+	struct fm_port_pcd_param	 rx_port_pcd_param;
+	size_t				 count;
+	const phandle			*phandle_prop;
+	const uint32_t			*uint32_prop;
+	const uint8_t			*mac_addr;
+	struct qman_fq			*ingress_fq;
+	uint32_t			 ingress_fqids[ARRAY_SIZE(ingress_fqs)][2];
+	uint32_t			 fqids[ARRAY_SIZE(priv->dpa_fq_list)];
+
+	dev = &_of_dev->dev;
+
+	cpu_dev_dbg(dev, "-> %s:%s()\n", __file__, __func__);
+
+	dpa_node = _of_dev->node;
+
+	/* Allocate this early, so we can store relevant information in the private area */
+	net_dev = alloc_etherdev_mq(sizeof(*priv), ARRAY_SIZE(priv->egress_fqs));
+	if (unlikely(net_dev == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): alloc_etherdev_mq() failed\n",
+			    __file__, __LINE__, __func__);
+		_errno = -ENOMEM;
+		goto _return;
+	}
+
+	/* Do this here, so we can be verbose early */
+	SET_NETDEV_DEV(net_dev, dev);
+	dev_set_drvdata(dev, net_dev);
+
+	priv = (typeof(priv))netdev_priv(net_dev);
+	priv->net_dev = net_dev;
+
+	priv->msg_enable = netif_msg_init(debug, -1);
+
+	/* BM */
+
+	dpa_bp = dpa_bp_probe(_of_dev, &count);
+	if (IS_ERR(dpa_bp)) {
+		_errno = PTR_ERR(dpa_bp);
+		goto _return_free_netdev;
+	} else if (dpa_bp == NULL) {
+		if (netif_msg_probe(priv))
+			cpu_dev_info(dev, "%s:%hu:%s(): Using private BM buffer pools\n",
+				     __file__, __LINE__, __func__);
+
+		count = ARRAY_SIZE(dpa_bp_size);
+		dpa_bp = (typeof(dpa_bp))devm_kzalloc(dev, count * sizeof(*dpa_bp), GFP_KERNEL);
+		if (unlikely(dpa_bp == NULL)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): devm_kzalloc() failed\n",
+				    __file__, __LINE__, __func__);
+			_errno = -ENOMEM;
+			goto _return_free_netdev;
+		}
+
+		for (i = 0; i < count; i++) {
+			dpa_bp[i].count	= 128;
+			dpa_bp[i].size	= dpa_bp_size[i];
+		}
+	} else if (count == ARRAY_SIZE(dpa_bp_size)) {
+		for (i = 0, j = 0; i < count; i++)
+			if (dpa_bp[i].count == 0 && dpa_bp[i].size == 0 && dpa_bp[i].paddr == 0) {
+				dpa_bp[i].count	= 128;
+				dpa_bp[i].size	= dpa_bp_size[i];
+				j++;
+			}
+		BUG_ON(j > 0 && j < count);
+	}
+
+	INIT_LIST_HEAD(&priv->dpa_bp_list);
+
+	for (i = 0; i < count; i++) {
+		_errno = _dpa_bp_alloc(dev, &priv->dpa_bp_list, dpa_bp + i);
+		if (unlikely(_errno < 0))
+			goto _return_dpa_bp_free;
+	}
+
+	/* QM */
+
+	phandle_prop = (typeof(phandle_prop))of_get_property(dpa_node, "fsl,qman-channel", &lenp);
+	if (unlikely(phandle_prop == NULL)) {
+		if (netif_msg_probe(priv))
+			cpu_dev_err(dev, "%s:%hu:%s(): of_get_property(%s, fsl,qman-channel) failed\n",
+				    __file__, __LINE__, __func__, dpa_node->full_name);
+		_errno = -EINVAL;
+		goto _return_dpa_bp_free;
+	}
+	BUG_ON(lenp != sizeof(phandle));
+
+	dev_node = of_find_node_by_phandle(*phandle_prop);
+	if (unlikely(dev_node == NULL)) {
+		if (netif_msg_probe(priv))
+			cpu_dev_err(dev, "%s:%hu:%s(): of_find_node_by_phandle() failed\n",
+				    __file__, __LINE__, __func__);
+		_errno = -EFAULT;
+		goto _return_dpa_bp_free;
+	}
+
+	uint32_prop = (typeof(uint32_prop))of_get_property(dev_node, "fsl,qman-channel-id", &lenp);
+	if (unlikely(uint32_prop == NULL)) {
+		if (netif_msg_probe(priv))
+			cpu_dev_err(dev, "%s:%hu:%s(): of_get_property(%s, fsl,qman-channel-id) failed\n",
+				    __file__, __LINE__, __func__, dpa_node->full_name);
+		of_node_put(dev_node);
+		_errno = -EINVAL;
+		goto _return_dpa_bp_free;
+	}
+	of_node_put(dev_node);
+	BUG_ON(lenp != sizeof(uint32_t));
+	priv->channel = *uint32_prop;
+
+	for (i = 0; i < ARRAY_SIZE(priv->dpa_fq_list); i++)
+		INIT_LIST_HEAD(priv->dpa_fq_list + i);
+
+	INIT_WORK(&priv->fd_work, dpa_rx);
+
+	priv->fd_list = (typeof(priv->fd_list))__alloc_percpu(sizeof(*priv->fd_list),
+							      __alignof__(*priv->fd_list));
+	if (unlikely(priv->fd_list == NULL)) {
+		if (netif_msg_probe(priv))
+			cpu_dev_err(dev, "%s:%hu:%s(): __alloc_percpu() failed\n",
+				    __file__, __LINE__, __func__);
+		_errno = -ENOMEM;
+		goto _return_dpa_bp_free;
+	}
+
+	for_each_online_cpu(i) {
+		fd_list = per_cpu_ptr(priv->fd_list, i);
+
+		INIT_LIST_HEAD(&fd_list->list);
+		fd_list->count	= 0;
+		fd_list->max	= 0;
+	}
+
+	/* FM */
+
+	priv->mac_dev = dpa_mac_probe(_of_dev);
+	if (IS_ERR(priv->mac_dev)) {
+		_errno = PTR_ERR(priv->mac_dev);
+		goto _return_free_percpu;
+	}
+
+	if(priv->mac_dev == NULL) {
+		if (netif_msg_probe(priv))
+			cpu_dev_info(dev, "%s:%hu:%s(): Missing the %s/fsl,fman-mac property. "
+					  "This is a MAC-less interface\n",
+				     __file__, __LINE__, __func__, dpa_node->full_name);
+
+		/* Get the MAC address */
+		mac_addr = of_get_mac_address(dpa_node);
+		if (unlikely(mac_addr == NULL)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): of_get_mac_address(%s) failed\n",
+				    __file__, __LINE__, __func__, dpa_node->full_name);
+			_errno = -EINVAL;
+			goto _return_free_percpu;
+		}
+
+		memcpy(net_dev->perm_addr, mac_addr, net_dev->addr_len);
+		memcpy(net_dev->dev_addr, mac_addr, net_dev->addr_len);
+
+		/* QM */
+
+		for (i = 0; i < ARRAY_SIZE(priv->dpa_fq_list); i++)	{
+			uint32_prop = (typeof(uint32_prop))of_get_property(dpa_node,
+									   fsl_qman_frame_queues[i],
+									   &lenp);
+			if (unlikely(uint32_prop == NULL)) {
+				if (netif_msg_probe(priv))
+					cpu_dev_err(dev,
+						    "%s:%hu:%s(): of_get_property(%s, %s) failed\n",
+						    __file__, __LINE__, __func__,
+						    dpa_node->full_name, fsl_qman_frame_queues[i]);
+				_errno = -EINVAL;
+				goto _return_free_percpu;
+			}
+			BUG_ON(lenp != 2 * sizeof(uint32_t) ||
+			       uint32_prop[1] != ARRAY_SIZE(priv->egress_fqs));
+
+			fqids[i] = *uint32_prop;
+		}
+
+		dpa_fq = (typeof(dpa_fq))devm_kzalloc(
+			dev,
+			ARRAY_SIZE(priv->dpa_fq_list) * ARRAY_SIZE(priv->egress_fqs) * sizeof(*dpa_fq),
+			GFP_KERNEL);
+		if (unlikely(dpa_fq == NULL)) {
+			if (netif_msg_probe(priv))
+				cpu_dev_err(dev, "%s:%hu:%s(): devm_kzalloc() failed\n",
+					    __file__, __LINE__, __func__);
+			_errno = -ENOMEM;
+			goto _return_free_percpu;
+		}
+
+		for (i = 0; i < ARRAY_SIZE(priv->egress_fqs); i++, dpa_fq++) {
+			dpa_fq->fq_base = ingress_fqs[RX][1];
+			dpa_fq->net_dev	= net_dev;
+			ingress_fq = _dpa_fq_alloc(priv->dpa_fq_list + RX, dpa_fq, fqids[RX] + i,
+						   QMAN_FQ_FLAG_NO_ENQUEUE, priv->channel, i);
+			if (IS_ERR(ingress_fq)) {
+				_errno = PTR_ERR(ingress_fq);
+				goto _return_dpa_fq_free;
+			}
+
+
+			cpu_dev_dbg(dev, "%s:%s(): ingress_fqs[%d] = %u\n",
+				    __file__, __func__, i, qman_fq_fqid(ingress_fq));
+		}
+
+		for (i = 0; i < ARRAY_SIZE(priv->egress_fqs); i++, dpa_fq++) {
+			dpa_fq->fq_base = _egress_fqs;
+			dpa_fq->net_dev	= net_dev;
+			priv->egress_fqs[i] = _dpa_fq_alloc(priv->dpa_fq_list + TX, dpa_fq,
+							    fqids[TX] + i,
+							    QMAN_FQ_FLAG_NO_MODIFY, 0, 0);
+			if (IS_ERR(priv->egress_fqs[i])) {
+				_errno = PTR_ERR(priv->egress_fqs[i]);
+				goto _return_dpa_fq_free;
+			}
+
+			cpu_dev_dbg(dev, "%s:%s(): egress_fqs[%d] = %u\n",
+				    __file__, __func__, i, qman_fq_fqid(priv->egress_fqs[i]));
+		}
+	} else {
+		net_dev->mem_start	= priv->mac_dev->res->start;
+		net_dev->mem_end	= priv->mac_dev->res->end;
+
+		memcpy(net_dev->perm_addr, priv->mac_dev->addr, net_dev->addr_len);
+		memcpy(net_dev->dev_addr, priv->mac_dev->addr, net_dev->addr_len);
+
+		/* BM */
+		rx_port_param.num_pools = min(ARRAY_SIZE(rx_port_param.pool_param), count);
+		i = 0;
+		list_for_each_entry(dpa_bp, &priv->dpa_bp_list, list) {
+			if (i >= rx_port_param.num_pools)
+				break;
+
+			rx_port_param.pool_param[i].id	 = dpa_pool2bpid(dpa_bp);
+			rx_port_param.pool_param[i].size = dpa_bp->size;
+
+			cpu_dev_dbg(dev, "%s:%s(): dpa_bp[%d] = {%hu, %u}\n",
+				    __file__, __func__,
+				    i, rx_port_param.pool_param[i].id,
+				    rx_port_param.pool_param[i].size);
+
+			i++;
+		}
+
+		/* QM */
+
+		dpa_fq = (typeof(dpa_fq))devm_kzalloc(
+			dev,
+			(ARRAY2_SIZE(ingress_fqs) + ARRAY_SIZE(priv->egress_fqs)) * sizeof(*dpa_fq),
+			GFP_KERNEL);
+		if (unlikely(dpa_fq == NULL)) {
+			if (netif_msg_probe(priv))
+				cpu_dev_err(dev, "%s:%hu:%s(): devm_kzalloc() failed\n",
+					    __file__, __LINE__, __func__);
+			_errno = -ENOMEM;
+			goto _return_free_percpu;
+		}
+
+		for (i = 0; i < ARRAY_SIZE(ingress_fqs); i++)
+			/* Error, default */
+			for (j = 0; j < ARRAY_SIZE(ingress_fqs[i]); j++, dpa_fq++) {
+				dpa_fq->fq_base	= ingress_fqs[i][j];
+				dpa_fq->net_dev	= net_dev;
+				ingress_fq = _dpa_fq_alloc(priv->dpa_fq_list + RX, dpa_fq, 0,
+							   QMAN_FQ_FLAG_NO_ENQUEUE,
+							   priv->channel, 7);
+				if (IS_ERR(ingress_fq)) {
+					_errno = PTR_ERR(ingress_fq);
+					goto _return_dpa_fq_free;
+				}
+
+				ingress_fqids[i][j] = qman_fq_fqid(ingress_fq);
+
+				cpu_dev_dbg(dev, "%s:%s(): ingress_fqs[%s][%d] = %u\n",
+					    __file__, __func__, rtx[i], j, ingress_fqids[i][j]);
+			}
+
+		for (i = 0; i < ARRAY_SIZE(priv->egress_fqs); i++, dpa_fq++) {
+			dpa_fq->fq_base	= _egress_fqs;
+			dpa_fq->net_dev	= net_dev;
+			priv->egress_fqs[i] = _dpa_fq_alloc(
+				priv->dpa_fq_list + TX, dpa_fq, 0, QMAN_FQ_FLAG_TO_DCPORTAL,
+				fm_get_tx_port_channel(priv->mac_dev->port_dev[TX]), i);
+			if (IS_ERR(priv->egress_fqs[i])) {
+				_errno = PTR_ERR(priv->egress_fqs[i]);
+				goto _return_dpa_fq_free;
+			}
+
+			cpu_dev_dbg(dev, "%s:%s(): egress_fqs[%d] = %u\n",
+				    __file__, __func__, i, qman_fq_fqid(priv->egress_fqs[i]));
+		}
+
+		net_dev->mem_start	= priv->mac_dev->res->start;
+		net_dev->mem_end	= priv->mac_dev->res->end;
+
+		memcpy(net_dev->perm_addr, priv->mac_dev->addr, net_dev->addr_len);
+		memcpy(net_dev->dev_addr, priv->mac_dev->addr, net_dev->addr_len);
+
+		/* Set error FQs */
+		rx_port_param.errq	= ingress_fqids[RX][0];
+		tx_port_param.errq	= ingress_fqids[TX][0];
+
+		/* Set default FQs */
+		rx_port_param.defq	= ingress_fqids[RX][1];
+		tx_port_param.defq	= ingress_fqids[TX][1];
+
+		rx_port_param.priv_data_size	= tx_port_param.priv_data_size	= 32;
+		rx_port_param.parse_results	= tx_port_param.parse_results	= true;
+
+		fm_set_rx_port_params(priv->mac_dev->port_dev[RX], &rx_port_param);
+
+		/* Set PCD FQs */
+		rx_port_pcd_param.cb	= dpa_alloc_pcd_fqids;
+		rx_port_pcd_param.dev	= dev;
+		fm_port_pcd_bind(priv->mac_dev->port_dev[RX], &rx_port_pcd_param);
+
+		fm_set_tx_port_params(priv->mac_dev->port_dev[TX], &tx_port_param);
+	}
+
+	net_dev->features		|= DPA_NETIF_FEATURES;
+	net_dev->get_stats		 = dpa_get_stats;
+	SET_ETHTOOL_OPS(net_dev, &dpa_ethtool_ops);
+	net_dev->needed_headroom	 = DPA_BP_HEAD;
+	net_dev->hard_start_xmit	 = dpa_tx;
+	net_dev->watchdog_timeo		 = tx_timeout * HZ / 1000;
+	net_dev->open			 = dpa_start;
+	net_dev->stop			 = dpa_stop;
+	net_dev->tx_timeout		 = dpa_timeout;
+	net_dev->change_rx_flags	 = dpa_change_rx_flags;
+
+	_errno = register_netdev(net_dev);
+	if (unlikely(_errno < 0)) {
+		if (netif_msg_probe(priv))
+			cpu_dev_err(dev, "%s:%hu:%s(): register_netdev() = %d\n",
+				    __file__, __LINE__, __func__, _errno);
+		goto _return_dpa_fq_free;
+	}
+
+	goto _return;
+
+_return_dpa_fq_free:
+	for (i = 0; i < ARRAY_SIZE(priv->dpa_fq_list); i++)
+		dpa_fq_free(dev, priv->dpa_fq_list + i);
+_return_free_percpu:
+	free_percpu(priv->fd_list);
+_return_dpa_bp_free:
+	dpa_bp_free(dev, &priv->dpa_bp_list);
+_return_free_netdev:
+	dev_set_drvdata(dev, NULL);
+	free_netdev(net_dev);
+_return:
+	cpu_dev_dbg(dev, "%s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+
+static const struct of_device_id dpa_match[] __devinitconst = {
+	{
+		.compatible	= "fsl,dpa-ethernet-init"
+	},
+	{
+		.compatible	= "fsl,dpa-ethernet"
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, dpa_match);
+
+static int __devinit __cold _dpa_probe(struct of_device *_of_dev, const struct of_device_id *match)
+{
+	return match == dpa_match ? dpa_init_probe(_of_dev) : dpa_probe(_of_dev);
+}
+
+static int __devexit __cold dpa_remove(struct of_device *of_dev)
+{
+	int			 _errno, __errno, i;
+	struct device		*dev;
+	struct net_device	*net_dev;
+	struct dpa_priv_s	*priv;
+
+	dev = &of_dev->dev;
+	net_dev = (typeof(net_dev))dev_get_drvdata(dev);
+
+	cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
+
+	dev_set_drvdata(dev, NULL);
+	unregister_netdev(net_dev);
+
+	priv = (typeof(priv))netdev_priv(net_dev);
+
+	for (i = 0, _errno = 0; i < ARRAY_SIZE(priv->dpa_fq_list); i++) {
+		__errno = dpa_fq_free(dev, priv->dpa_fq_list + i);
+		if (unlikely(__errno < 0) && _errno >= 0)
+			_errno = __errno;
+	}
+
+	free_percpu(priv->fd_list);
+
+	dpa_bp_free(dev, &priv->dpa_bp_list);
+
+	free_netdev(net_dev);
+
+	cpu_dev_dbg(dev, "%s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+
+static struct of_platform_driver dpa_driver = {
+	.name		= KBUILD_MODNAME,
+	.match_table	= dpa_match,
+	.owner		= THIS_MODULE,
+	.probe		= _dpa_probe,
+	.remove		= __devexit_p(dpa_remove)
+};
+
+static int __init __cold dpa_load(void)
+{
+	int	 _errno;
+
+	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
+
+	cpu_pr_info(KBUILD_MODNAME ": " DPA_DESCRIPTION " (" VERSION ")\n");
+
+	_errno = of_register_platform_driver(&dpa_driver);
+	if (unlikely(_errno < 0)) {
+		cpu_pr_err(KBUILD_MODNAME ": %s:%hu:%s(): of_register_platform_driver() = %d\n",
+			   __file__, __LINE__, __func__, _errno);
+		goto _return;
+	}
+
+	goto _return;
+
+_return:
+	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+module_init(dpa_load);
+
+static void __exit __cold dpa_unload(void)
+{
+	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
+
+	of_unregister_platform_driver(&dpa_driver);
+
+	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
+}
+module_exit(dpa_unload);
diff --git a/drivers/net/dpa/dpa.h b/drivers/net/dpa/dpa.h
new file mode 100644
index 0000000..ae4ab95
--- /dev/null
+++ b/drivers/net/dpa/dpa.h
@@ -0,0 +1,81 @@
+/* Copyright (c) 2008 - 2009, Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __DPA_H
+#define __DPA_H
+
+#include <linux/ethtool.h>	/* struct ethtool_ops */
+#include <linux/netdevice.h>
+#include <linux/list.h>		/* struct list_head */
+#include <linux/workqueue.h>	/* struct work_struct */
+
+#include "linux/fsl_qman.h"	/* struct qman_fq */
+
+#include "dpa-common.h"
+
+#include "mac.h"		/* struct mac_device */
+
+struct fd_list_head {
+	struct list_head	list;
+	size_t			count, max;
+};
+
+#ifdef CONFIG_FSL_FMAN_TEST
+struct pcd_range {
+	uint32_t			 base;
+	uint32_t			 count;
+};
+#endif /* CONFIG_FSL_FMAN_TEST */
+
+struct dpa_priv_s {
+	struct net_device	*net_dev;
+	struct list_head	 dpa_bp_list;
+
+	uint16_t		 channel;
+	struct list_head	 dpa_fq_list[2];
+	struct qman_fq		*egress_fqs[8];
+#ifdef CONFIG_FSL_FMAN_TEST
+	int					 num;
+	struct pcd_range	 ranges[4];
+#endif /* CONFIG_FSL_FMAN_TEST */
+
+	struct mac_device	*mac_dev;
+
+	struct work_struct	 fd_work;
+	struct fd_list_head	*fd_list;
+
+	uint32_t		 msg_enable;	/* net_device message level */
+};
+
+extern const struct ethtool_ops dpa_ethtool_ops;
+
+#endif	/* __DPA_H */
diff --git a/drivers/net/dpa/fm-wrapper.c b/drivers/net/dpa/fm-wrapper.c
new file mode 100644
index 0000000..e8f5ed5
--- /dev/null
+++ b/drivers/net/dpa/fm-wrapper.c
@@ -0,0 +1,155 @@
+/* Copyright (C) 2008-2009 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/io.h>		/* in_be32() */
+#include <linux/of_platform.h>
+#include <sysdev/fsl_soc.h>
+
+#include "dpa-common.h"
+#include "fm.h"
+#include "fm-wrapper.h"
+
+#include "lnxwrp_fm_ext.h"	/* fm_init() */
+
+#define FM_DESCRIPTION "FSL FMan wrapper based driver"
+
+MODULE_LICENSE("Dual BSD/GPL");
+
+MODULE_AUTHOR("Emil Medve <Emilian.Medve@Freescale.com>");
+
+MODULE_DESCRIPTION(FM_DESCRIPTION);
+
+const char	*fm_driver_description __initconst = FM_DESCRIPTION;
+const size_t	 fm_sizeof_priv __devinitconst = sizeof(struct fm_priv_s);
+
+static void fm_exception(t_Handle _fm_dev, e_FmExceptions exception)
+{
+	struct fm_device	*fm_dev;
+
+	fm_dev = (typeof(fm_dev))_fm_dev;
+
+	cpu_dev_dbg(fm_dev->dev, "-> %s:%s()\n", __file__, __func__);
+
+	cpu_dev_dbg(fm_dev->dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+static void fm_bus_error(t_Handle	_fm_dev,
+			 e_FmPortType	port_type,
+			 uint8_t	cell_index,
+			 uint64_t	addr,
+			 uint8_t	tnum,
+			 uint8_t	partition)
+{
+	struct fm_device	*fm_dev;
+
+	fm_dev = (typeof(fm_dev))_fm_dev;
+
+	cpu_dev_dbg(fm_dev->dev, "-> %s:%s()\n", __file__, __func__);
+
+	cpu_dev_dbg(fm_dev->dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+static int __devinit __cold init(struct fm_device *fm_dev)
+{
+	struct fm_priv_s	*priv;
+	int			 i;
+
+	priv = (typeof(priv))fmdev_priv(fm_dev);
+
+	priv->fm.id			= fm_dev->cell_index;
+	priv->fm.prsActive		= fm_dev->parser_res != NULL;
+	priv->fm.kgActive		= fm_dev->keygen_res != NULL;
+	priv->fm.plcrActive		= fm_dev->policer_res != NULL;
+	priv->fm.pcdActive		= priv->fm.prsActive	||
+					  priv->fm.kgActive	||
+					  priv->fm.plcrActive;
+	priv->fm.fmBaseAddr		= (typeof(priv->fm.fmBaseAddr))fm_dev->vaddr;
+	priv->fm.fmMemSize		= fm_dev->res->end + 1 - fm_dev->res->start;
+	priv->fm.fmMuramBaseAddr	= (typeof(priv->fm.fmMuramBaseAddr))fm_dev->muram_vaddr;
+	priv->fm.fmMuramMemSize		= fm_dev->muram_res->end + 1 - fm_dev->muram_res->start;
+
+	priv->fm.fmDevSettings.param.fmId		= fm_dev->cell_index;
+	priv->fm.fmDevSettings.param.h_App		= &priv->fm;
+	priv->fm.fmDevSettings.param.fmClkFreq		= fsl_get_sys_freq();
+
+	/* Ugly hack! */
+	for (i = 0; i < ARRAY_SIZE(priv->fm.fmDevSettings.param.liodnPerPartition); i++)
+		priv->fm.fmDevSettings.param.liodnPerPartition[i] =
+			in_be32(fm_dev->vaddr + 0xc2000 + 0x60	+ sizeof(uint32_t) * (i / 2)) >>
+			16 * (1 - (i & 1));
+
+	priv->fm.fmDevSettings.param.f_Exceptions	= fm_exception;
+	priv->fm.fmDevSettings.param.f_BusError		= fm_bus_error;
+
+	priv->fm.fmDevSettings.advConfig	= priv->fm_config;
+
+	priv->fm.fmPcdDevSettings.advConfig	= priv->pcd_config;
+
+	priv->fm.active	= true;
+
+	fm_init(&priv->fm);
+
+	return 0;
+}
+
+static irqreturn_t isr(int irq, void *_fm_dev)
+{
+	irqreturn_t		 _errno;
+	struct fm_device	*fm_dev;
+	struct fm_priv_s	*priv;
+
+	fm_dev = (typeof(fm_dev))_fm_dev;
+
+	cpu_dev_dbg(fm_dev->dev, "-> %s:%s()\n", __file__, __func__);
+
+	priv = (typeof(priv))fmdev_priv(fm_dev);
+
+	if (likely(priv->fm.h_Dev != NULL)) {
+		FM_Isr(priv->fm.h_Dev);
+		_errno = IRQ_HANDLED;
+	} else
+		_errno = IRQ_NONE;
+
+	cpu_dev_dbg(fm_dev->dev, "%s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+
+static void __devinit __cold setup(struct fm_device *fm_dev)
+{
+	fm_dev->init	= init;
+	fm_dev->isr	= isr;
+	fm_dev->uninit	= NULL;
+}
+
+void (*const fm_setup)(struct fm_device *fm_dev) __devinitconst = setup;
diff --git a/drivers/net/dpa/fm-wrapper.h b/drivers/net/dpa/fm-wrapper.h
new file mode 100644
index 0000000..e328c21
--- /dev/null
+++ b/drivers/net/dpa/fm-wrapper.h
@@ -0,0 +1,44 @@
+/* Copyright (c) 2008, Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FM_WRAPPER_H
+#define __FM_WRAPPER_H
+
+#include "lnxwrp_fm.h"	/* t_LnxWrpFmDev */
+
+struct fm_priv_s {
+	t_LnxWrpFmDev			fm;
+	t_SysObjectAdvConfigEntry	fm_config[FM_MAX_NUM_OF_ADV_SETTINGS],
+					pcd_config[FM_MAX_NUM_OF_ADV_SETTINGS];
+};
+
+#endif	/* __FM_WRAPPER_H */
diff --git a/drivers/net/dpa/fm.c b/drivers/net/dpa/fm.c
new file mode 100644
index 0000000..9474c68
--- /dev/null
+++ b/drivers/net/dpa/fm.c
@@ -0,0 +1,378 @@
+/* Copyright (C) 2008-2009 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/io.h>		/* devm_ioremap() */
+
+#include "dpa-common.h"
+#include "fm.h"
+
+static struct fm_device * __devinit __cold
+alloc_fmdev(struct device *dev, size_t sizeof_priv, void (*setup)(struct fm_device *fm_dev))
+{
+	struct fm_device	*fm_dev;
+
+	fm_dev = (typeof(fm_dev))devm_kzalloc(dev, sizeof(*fm_dev) + sizeof_priv, GFP_KERNEL);
+	if (likely(fm_dev == NULL))
+		fm_dev = ERR_PTR(-ENOMEM);
+	else {
+		fm_dev->dev = dev;
+		dev_set_drvdata(dev, fm_dev);
+		setup(fm_dev);
+	}
+
+	return fm_dev;
+}
+
+static int __devexit __cold free_fmdev(struct fm_device *fm_dev)
+{
+	dev_set_drvdata(fm_dev->dev, NULL);
+
+	return likely(fm_dev->uninit) ? fm_dev->uninit(fm_dev) : 0;
+}
+
+struct resource * __cold fm_mem_region(struct of_device *of_dev)
+{
+	return ((struct fm_device *)dev_get_drvdata(&of_dev->dev))->res;
+}
+EXPORT_SYMBOL(fm_mem_region);
+
+const uint16_t irqf[] __devinitconst = {0};
+
+static int __devinit __cold fm_probe(struct of_device *of_dev, const struct of_device_id *match)
+{
+	int			 _errno, interrupt, i, lenp;
+	struct device		*dev;
+	struct device_node	*fm_node, *dev_node;
+	struct fm_device	*fm_dev;
+	struct resource		 res;
+	const uint32_t		*uint32_prop;
+
+	dev = &of_dev->dev;
+
+	cpu_dev_dbg(dev, "-> %s:%s()\n", __file__, __func__);
+
+	fm_dev = alloc_fmdev(dev, fm_sizeof_priv, fm_setup);
+	if (IS_ERR(fm_dev)) {
+		_errno = PTR_ERR(fm_dev);
+		cpu_dev_err(dev, "%s:%hu:%s(): alloc_fmdev() = %d\n",
+			    __file__, __LINE__, __func__, _errno);
+		goto _return;
+	}
+
+	fm_node = of_dev->node;
+
+	/* Get the FM interrupts */
+	for (i = 0; i < ARRAY_SIZE(irqf); i++) {
+		interrupt = of_irq_to_resource(fm_node, i, NULL);
+		if (unlikely(interrupt == NO_IRQ)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): of_irq_to_resource(%d) = %d\n",
+				    __file__, __LINE__, __func__, i, NO_IRQ);
+			_errno = -EINVAL;
+			goto _return_dev_set_drvdata;
+		}
+
+		if (unlikely(!can_request_irq(interrupt, irqf[i])))
+			cpu_dev_warn(dev, "%s:%hu:%s(): can_request_irq(%d) failed\n",
+				     __file__, __LINE__, __func__, i);
+		_errno = devm_request_irq(dev, interrupt, fm_dev->isr, irqf[i], "fman", fm_dev);
+		if (unlikely(_errno < 0)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): devm_request_irq(%d) = %d\n",
+				    __file__, __LINE__, __func__, i, _errno);
+			goto _return_dev_set_drvdata;
+		}
+	}
+
+	/* Get the port/device address */
+	_errno = of_address_to_resource(fm_node, 0, &res);
+	if (unlikely(_errno < 0)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): of_address_to_resource() = %d\n",
+			__file__, __LINE__, __func__, _errno);
+		goto _return_dev_set_drvdata;
+	}
+
+	fm_dev->res = devm_request_mem_region(dev, res.start, res.end + 1 - res.start, "fman");
+	if (unlikely(fm_dev->res == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): devm_request_mem_region(fman) failed\n",
+			    __file__, __LINE__, __func__);
+		_errno = -EBUSY;
+		goto _return_dev_set_drvdata;
+	}
+
+	fm_dev->vaddr = devm_ioremap(dev,
+				     fm_dev->res->start, fm_dev->res->end + 1 - fm_dev->res->start);
+	if (unlikely(fm_dev->vaddr == 0)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): devm_ioremap() failed\n",
+			    __file__, __LINE__, __func__);
+		_errno = -EIO;
+		goto _return_dev_set_drvdata;
+	}
+
+	uint32_prop = (typeof(uint32_prop))of_get_property(fm_node, "cell-index", &lenp);
+	if (unlikely(uint32_prop == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): of_get_property(%s, cell-index) failed\n",
+			    __file__, __LINE__, __func__, fm_node->full_name);
+		_errno = -EINVAL;
+		goto _return_dev_set_drvdata;
+	}
+	BUG_ON(lenp != sizeof(uint32_t));
+	fm_dev->cell_index = *uint32_prop;
+
+	dev_node = of_find_compatible_node(of_node_get(fm_node), NULL, "fsl,fman-muram");
+	if (unlikely(dev_node == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): of_find_compatible_node(fsl,fman-muram) failed\n",
+			    __file__, __LINE__, __func__);
+		_errno = -EINVAL;
+		goto _return_dev_set_drvdata;
+	}
+
+	_errno = of_address_to_resource(dev_node, 0, &res);
+	if (unlikely(_errno < 0)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): of_address_to_resource(%s) = %d\n",
+			    __file__, __LINE__, __func__, dev_node->full_name, _errno);
+		goto _return_of_node_put;
+	}
+	of_node_put(dev_node);
+
+	fm_dev->muram_res = __devm_request_region(dev, fm_dev->res,
+						  res.start, res.end + 1 - res.start, "muram");
+	if (unlikely(fm_dev->res == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): __devm_request_region(muram) failed\n",
+			    __file__, __LINE__, __func__);
+		_errno = -EBUSY;
+		goto _return_dev_set_drvdata;
+	}
+
+	fm_dev->muram_vaddr = devm_ioremap(dev, fm_dev->muram_res->start,
+					   fm_dev->muram_res->end + 1 - fm_dev->muram_res->start);
+	if (unlikely(fm_dev->muram_vaddr == 0)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): devm_ioremap() failed\n",
+			    __file__, __LINE__, __func__);
+		_errno = -EIO;
+		goto _return_dev_set_drvdata;
+	}
+
+	dev_node = of_find_compatible_node(of_node_get(fm_node), NULL, "fsl,fman-parser");
+	if (unlikely(dev_node == NULL))
+		cpu_dev_err(dev, "%s:%hu:%s(): of_find_compatible_node(fsl,fman-parser) failed. "
+				 "Won't be using the parser\n",
+			    __file__, __LINE__, __func__);
+	else {
+		_errno = of_address_to_resource(dev_node, 0, &res);
+		if (unlikely(_errno < 0)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): of_address_to_resource(%s) = %d\n",
+				    __file__, __LINE__, __func__, dev_node->full_name, _errno);
+			goto _return_of_node_put;
+		}
+		of_node_put(dev_node);
+
+		fm_dev->parser_res = __devm_request_region(dev, fm_dev->res,
+							   res.start, res.end + 1 - res.start,
+							   "parser");
+		if (unlikely(fm_dev->res == NULL)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): __devm_request_region(parser) failed\n",
+				    __file__, __LINE__, __func__);
+			_errno = -EBUSY;
+			goto _return_dev_set_drvdata;
+		}
+
+		fm_dev->parser_vaddr = devm_ioremap(
+			dev,
+			fm_dev->parser_res->start,
+			fm_dev->parser_res->end + 1 - fm_dev->parser_res->start);
+		if (unlikely(fm_dev->parser_vaddr == 0)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): devm_ioremap() failed\n",
+				    __file__, __LINE__, __func__);
+			_errno = -EIO;
+			goto _return_dev_set_drvdata;
+		}
+	}
+
+	dev_node = of_find_compatible_node(of_node_get(fm_node), NULL, "fsl,fman-keygen");
+	if (unlikely(dev_node == NULL))
+		cpu_dev_err(dev, "%s:%hu:%s(): of_find_compatible_node(fsl,fman-keygen) failed. "
+				 "Won't be using the KeyGen\n",
+			    __file__, __LINE__, __func__);
+	else {
+		_errno = of_address_to_resource(dev_node, 0, &res);
+		if (unlikely(_errno < 0)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): of_address_to_resource(%s) = %d\n",
+				    __file__, __LINE__, __func__, dev_node->full_name, _errno);
+			goto _return_of_node_put;
+		}
+		of_node_put(dev_node);
+
+		fm_dev->keygen_res = __devm_request_region(dev, fm_dev->res,
+							   res.start, res.end + 1 - res.start,
+							   "keygen");
+		if (unlikely(fm_dev->res == NULL)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): __devm_request_region(keygen) failed\n",
+				    __file__, __LINE__, __func__);
+			_errno = -EBUSY;
+			goto _return_dev_set_drvdata;
+		}
+
+		fm_dev->keygen_vaddr = devm_ioremap(
+			dev,
+			fm_dev->keygen_res->start,
+			fm_dev->keygen_res->end + 1 - fm_dev->keygen_res->start);
+		if (unlikely(fm_dev->keygen_vaddr == 0)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): devm_ioremap() failed\n",
+				    __file__, __LINE__, __func__);
+			_errno = -EIO;
+			goto _return_dev_set_drvdata;
+		}
+	}
+
+	dev_node = of_find_compatible_node(of_node_get(fm_node), NULL, "fsl,fman-policer");
+	if (unlikely(dev_node == NULL))
+		cpu_dev_err(dev, "%s:%hu:%s(): of_find_compatible_node(fsl,fman-policer) failed. "
+				 "Won't be using the policer\n",
+			    __file__, __LINE__, __func__);
+	else {
+		_errno = of_address_to_resource(dev_node, 0, &res);
+		if (unlikely(_errno < 0)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): of_address_to_resource(%s) = %d\n",
+				    __file__, __LINE__, __func__, dev_node->full_name, _errno);
+			goto _return_of_node_put;
+		}
+		of_node_put(dev_node);
+
+		fm_dev->policer_res = __devm_request_region(dev, fm_dev->res,
+							    res.start, res.end + 1 - res.start,
+							    "policer");
+		if (unlikely(fm_dev->res == NULL)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): __devm_request_region(policer) failed\n",
+				    __file__, __LINE__, __func__);
+			_errno = -EBUSY;
+			goto _return_dev_set_drvdata;
+		}
+
+		fm_dev->policer_vaddr = devm_ioremap(
+			dev,
+			fm_dev->policer_res->start,
+			fm_dev->policer_res->end + 1 - fm_dev->policer_res->start);
+		if (unlikely(fm_dev->policer_vaddr == 0)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): devm_ioremap() failed\n",
+				    __file__, __LINE__, __func__);
+			_errno = -EIO;
+			goto _return_dev_set_drvdata;
+		}
+	}
+
+	_errno = fm_dev->init(fm_dev);
+	if (unlikely(_errno < 0)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): port_dev->init() = %d\n",
+			    __file__, __LINE__, __func__, _errno);
+		goto _return_dev_set_drvdata;
+	}
+
+	goto _return;
+
+_return_of_node_put:
+	of_node_put(dev_node);
+_return_dev_set_drvdata:
+	dev_set_drvdata(dev, NULL);
+_return:
+	cpu_dev_dbg(dev, "%s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+
+static int __devexit __cold fm_remove(struct of_device *of_dev)
+{
+	int		 _errno;
+	struct device	*dev;
+
+	dev = &of_dev->dev;
+
+	cpu_dev_dbg(dev, "-> %s:%s()\n", __file__, __func__);
+
+	_errno = free_fmdev((struct fm_device *)dev_get_drvdata(dev));
+
+	cpu_dev_dbg(dev, "%s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+
+static const struct of_device_id fm_match[] __devinitconst = {
+	{
+		.compatible	= "fsl,fman"
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, fm_match);
+
+static struct of_platform_driver fm_driver = {
+	.name		= KBUILD_MODNAME,
+	.match_table	= fm_match,
+	.owner		= THIS_MODULE,
+	.probe		= fm_probe,
+	.remove		= __devexit_p(fm_remove)
+};
+
+static int __init __cold fm_load(void)
+{
+	int	 _errno;
+
+	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
+
+	cpu_pr_info(KBUILD_MODNAME ": %s (" VERSION ")\n", fm_driver_description);
+
+	_errno = of_register_platform_driver(&fm_driver);
+	if (unlikely(_errno < 0)) {
+		cpu_pr_err(KBUILD_MODNAME ": %s:%hu:%s(): of_register_platform_driver() = %d\n",
+		       __file__, __LINE__, __func__, _errno);
+		goto _return;
+	}
+
+	goto _return;
+
+_return:
+	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+module_init(fm_load);
+
+static void __exit __cold fm_unload(void)
+{
+	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
+
+	of_unregister_platform_driver(&fm_driver);
+
+	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
+}
+module_exit(fm_unload);
diff --git a/drivers/net/dpa/fm.h b/drivers/net/dpa/fm.h
new file mode 100644
index 0000000..b694228
--- /dev/null
+++ b/drivers/net/dpa/fm.h
@@ -0,0 +1,118 @@
+/* Copyright (c) 2008, Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FM_H
+#define __FM_H
+
+#include <linux/ioport.h>	/* struct resource */
+#include <linux/of_device.h>	/* struct of_device */
+#include <linux/irqreturn.h>	/* irqreturn_t */
+
+#define FM_FD_STAT_DME	       0x01000000      /* DMA Error - QMI */
+#define FM_FD_STAT_FHE	       0x00080000      /* Physical Error - BMI */
+#define FM_FD_STAT_FSE	       0x00040000      /* Frame Size Error - BMI */
+#define FM_FD_STAT_DIS	       0x00020000      /* Discarded frame - BMI */
+#define FM_FD_STAT_EOF	       0x00008000      /* Extract Out of Frame - KEYGEN */
+#define FM_FD_STAT_NSS	       0x00004000      /* No Scheme Selected - KEYGEN */
+#define FM_FD_STAT_FCL	       0x00000c00      /* Frame Color - Policer */
+#define FM_FD_STAT_IPP	       0x00000200      /* Illegal Policer Profile - Policer */
+#define FM_FD_STAT_PTE	       0x00000080      /* Parser Timeout Exceeded - Parser */
+#define FM_FD_STAT_ISP	       0x00000040      /* Invalid Soft Parser Instruction - Parser */
+#define FM_FD_STAT_PHE	       0x00000020      /* Parsing Header Error - Parser */
+#define FM_FD_STAT_ERRORS      (FM_FD_STAT_DME | FM_FD_STAT_FHE | FM_FD_STAT_FSE |     \
+				FM_FD_STAT_DIS | FM_FD_STAT_EOF | FM_FD_STAT_NSS |     \
+				FM_FD_STAT_IPP | FM_FD_STAT_PTE | FM_FD_STAT_ISP |     \
+				FM_FD_STAT_PHE)
+
+#define FM_FD_CMD_FCO  0x80000000      /* Frame queue Context Override */
+#define FM_FD_CMD_RPD  0x40000000      /* Read Prepended Data */
+#define FM_FD_CMD_UDP  0x20000000      /* Update Prepended Data */
+#define FM_FD_CMD_BMF  0x10000000      /* Buffer Must not be Freed */
+#define FM_FD_CMD_DTC  0x08000000      /* Do TCP Checksum */
+#define FM_FD_CMD_DME  0x01000000      /* DMA Error */
+#define FM_FD_CMD_CFQ  0x00ffffff      /* Confirmation Frame Queue */
+
+/* Parse results memory layout */
+struct fman_parse_results {
+	uint8_t		lpid;
+	uint8_t		shimr;
+	uint16_t	l2r;
+	uint16_t	l3r;
+	uint8_t		l4r;
+	uint8_t		cplan;
+	uint16_t	nxthdr;
+	uint16_t	cksum;
+	uint32_t	lcv;
+	uint8_t		shim_off[3];
+	uint8_t		eth_off;
+	uint8_t		llc_snap_off;
+	uint8_t		vlan_off;
+	uint8_t		etype_off;
+	uint8_t		pppoe_off;
+	uint8_t		mpls_off;
+	uint8_t		ip_off;
+	uint8_t		gre_off;
+	uint8_t		l4_off;
+	uint8_t		nxthdr_off;
+} __packed;
+
+struct fm_device {
+	struct device	*dev;
+	void		*priv;
+	uint8_t		 cell_index;
+	struct resource	*res;
+	void		*vaddr;
+
+	struct resource	*muram_res;
+	void		*muram_vaddr;
+	struct resource	*parser_res;
+	void		*parser_vaddr;
+	struct resource	*keygen_res;
+	void		*keygen_vaddr;
+	struct resource	*policer_res;
+	void		*policer_vaddr;
+
+	int (*init)(struct fm_device *fm_dev);
+	irqreturn_t (*isr)(int irq, void *_fm_dev);
+	int (*uninit)(struct fm_device *fm_dev);
+};
+
+static inline void * __attribute((nonnull)) fmdev_priv(const struct fm_device *fm_dev)
+{
+	return (void *)fm_dev + sizeof(*fm_dev);
+}
+
+extern const char	*fm_driver_description;
+extern const size_t	 fm_sizeof_priv;
+extern void (* const fm_setup)(struct fm_device *fm_dev);
+
+#endif	/* __FM_H */
diff --git a/drivers/net/dpa/fman-conf.h b/drivers/net/dpa/fman-conf.h
new file mode 100644
index 0000000..7be24fb
--- /dev/null
+++ b/drivers/net/dpa/fman-conf.h
@@ -0,0 +1,1606 @@
+/** \file	fman_conf.h
+ *  \brief	P4080 FMan low level driver/API
+ *  \author	Emil Medve <Emilian.Medve@Freescale.com>
+ *
+ *  \mainpage
+ *  \section	Legal
+ *
+ *  Copyright (c) 2008, Freescale Semiconductor, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions are met:
+ *	- Redistributions of source code must retain the above copyright
+ *	  notice, this list of conditions and the following disclaimer.
+ *	- Redistributions in binary form must reproduce the above copyright
+ *	  notice, this list of conditions and the following disclaimer in the
+ *	  documentation and/or other materials provided with the distribution.
+ *	- Neither the name of Freescale Semiconductor nor the
+ *	  names of its contributors may be used to endorse or promote products
+ *	  derived from this software without specific prior written permission.
+ *
+ *
+ *  ALTERNATIVELY, this software may be distributed under the terms of the
+ *  GNU General Public License ("GPL") as published by the Free Software
+ *  Foundation, either version 2 of that License or (at your option) any
+ *  later version.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *  DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ *  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  \section	Introduction
+ *
+ *  This document details the low-level API that is provided for configuration of the Frame Manager
+ *  (FMan) block in the Freescale DPA architecture (P4080). These API is used to set up
+ *  classification, parsing, QoS and other FMan features.
+ *
+ *  Both the FMan LLD/API and this document are work in progress. The implementation is incremental
+ *  and centered around, on one side, the functionality implemented in the FMan model/simulator
+ *  and, on the other side, the functionality used in the applications using this driver/API.
+ *
+ *  As far as BG compliance goes, this driver/API is supposedly based on version/revision .79.
+ *  However, where a discrepancy between the BGs and the model/simulator was identified the decision
+ *  was made to be follow the model/simulator for the sake of maximizing the working feature set.
+ *
+ *  The API is designed to have a consistent look-and-feel with the B/QMan drivers/API. Beyond
+ *  that, the code tries to follow the Linux coding style and conventions.
+ *
+ *  \section	Virtualization
+ *
+ *  Certain components/modules of the FMan can be virtualized easier then others. The \ref BMI,
+ *  \ref QMI, \ref Parser, \ref MAC and \ref MDIO can be virtualized easier, in the sense of being
+ *  able to assign them to a hypervisor partition and be able to control them without the need to
+ *  access global resources that might affect the stability and functionality of other hypervisor
+ *  partitions. This virtualization is achieved by having registers mapped in a 4 KB page that can
+ *  be mapped in the MMU to a single partition.
+ *
+ *  Other blocks in the FMan such as the KeyGen, policer, etc. can be used by multiple partitions
+ *  but their cofiguration needs to be programmed/done by a single partition (control-plane
+ *  partition) on behalf of the other partitions (data-plane partitions).
+ *
+ *  For more information on virtualization and partitioning please refer to the Freescale hypervisor
+ *  documentation.
+ */
+
+#ifndef __FMAN_CONF_H
+#define __FMAN_CONF_H
+
+/** \defgroup	Port	Port
+ *  \defgroup	BMI	BMI - BMan interface
+ *  \defgroup	QMI	QMI - QMan interface
+ *  \defgroup	Parser	Parser
+ *  \defgroup	KeyGen	KeyGen - Key generator
+ *  \defgroup	DMA	DMA
+ *  \defgroup	FPM	FPM - FMan processing manager
+ *  \defgroup	Policer	Policer
+ *  \defgroup	MAC	MAC
+ *  \defgroup	MDIO	MDIO
+ */
+
+/* Register level abstraction */
+
+/** \addtogroup	Port
+ *  \details	A port contains the registers for the \ref BMI, \ref QMI and \ref Parser
+ *  @{
+ */
+
+/** \addtogroup	BMI
+ *  @{
+ */
+
+/** \internal
+ *  \brief	BMI commmon port register layout
+ *
+ *  This is a FMan LLD private data structure and should _not_ be used anywhere including in the
+ *  FMan LLD.
+ *
+ *  It is the method of choice for describing the FMan registers offsets and it exists only for that
+ *  purpose.
+ *
+ */
+struct fm_bmi_common_mmap_s {
+	uint32_t	FMBM_INIT;	/* Initialization */
+	uint32_t	FMBM_CFG[3];	/* Configuration */
+	uint8_t		reserved0[0x10];
+	uint32_t	FMBM_IVER;	/* Interrupt EVent */
+	uint32_t	FMBM_IER;	/* Interrupt Enable */
+	uint32_t	FMBM_IFR;	/* Interrupt Force */
+	uint8_t		reserved1[0x14];
+	uint32_t	FMBM_ARB[8];	/* Arbitration */
+	uint32_t	FMBM_BCMA;	/* Buffers Command Mutual Exclusive Access */
+	uint32_t	FMBM_EBC;	/* External Buffers Command */
+	uint32_t	FMBM_EBCR;	/* External Buffers Command Result */
+	uint32_t	FMBM_EPRH;	/* External PointeR High */
+	uint32_t	FMBM_EPRL;	/* External PointeR Low */
+	uint8_t		reserved2[0x18];
+	uint32_t	FMBM_DTC[3];	/* Debug Trap Counter */
+	uint8_t		reserved3[0x4];
+	uint32_t	FMBM_DCV[12];	/* Debug Compare Value */
+	uint32_t	FMBM_DCM[12];	/* Debug Compare Mask */
+	uint32_t	FMBM_GDE;	/* Global Debug Enable */
+	uint32_t	FMBM_PP[63];	/* Port Parameters */
+	uint8_t		reserved4[0x4];
+	uint32_t	FMBM_IPS;	/* Internal Probe Select */
+	uint32_t	FMBM_PFS[63];	/* Port FIFO Size */
+	uint32_t	FMBM_IPD;	/* Internal Probe Data */
+	uint32_t	FMBM_PPID[63];	/* Port Partition ID */
+} __aligned(0x400) __packed;
+
+#define FM_BMI_COMMON_INIT_STR	0x80000000		/* Start */
+
+#define FM_BMI_COMMON_CFG0_FBPS(n)	((n) << 16)	/* Free Buffer Pool Size */
+#define FM_BMI_COMMON_CFG0_FMBM_OF(n)	(n)		/* Free Buffer Pool OFfset */
+#define FM_BMI_COMMON_CFG1_TNTSKS(n)	((n) << 16)	/* Total Number of TaSKS */
+#define FM_BMI_COMMON_CFG1_TDMA(n)	(n)		/* Total DMA */
+
+/** \internal
+ *  \brief		BMI offline parsing/host command port register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_bmi_oh_mmap_s {
+	uint8_t		reserved0[0x400];
+} __aligned(0x400) __packed;
+
+/** \internal
+ *  \brief		BMI Rx port register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_bmi_rx_mmap_s {
+	uint32_t	FMBM_RCFG;	/* Configuration */
+	uint32_t	FMBM_RST;	/* Status */
+	uint32_t	FMBM_RDA;	/* DMA Attributes */
+	uint32_t	FMBM_RFP;	/* FIFO Parameters */
+	uint32_t	FMBM_RFED;	/* Frame End Data */
+	uint32_t	FMBM_RICP;	/* Internal Context Parameters */
+	uint32_t	FMBM_RIM;	/* Internal Margins */
+	uint32_t	FMBM_REBM;	/* External Buffer Margins */
+	uint32_t	FMBM_RFNE;	/* Frame Next Engine */
+	uint32_t	FMBM_RFCA;	/* Frame Command Attributes */
+	uint32_t	FMBM_RFPNE;	/* Frame Parser Next Engine */
+	uint32_t	FMBM_RPSO;	/* Parse Start Offset */
+	uint32_t	FMBM_RPP;	/* Policer Profile */
+	uint32_t	FMBM_RCCB;	/* Coarse Classification Base */
+	uint8_t		reserved0[0x8];
+	uint32_t	FMBM_RPRAI[8];	/* Parse Results Array Initialization */
+	uint32_t	FMBM_RFQID;	/* Frame Queue ID */
+	uint32_t	FMBM_REFQID;	/* Error Frame Queue ID */
+	uint32_t	FMBM_RFSDM;	/* Frame Status Discard Mask */
+	uint32_t	FMBM_RFSEM;	/* Frame Status Error Mask */
+	uint32_t	FMBM_RFENE;	/* Frame Enqueue Next Engine */
+	uint8_t		reserved1[0x8c];
+	uint32_t	FMBM_EBMPI[8];	/* Buffer Manager Pool Information */
+	uint32_t	FMBM_ACNT[8];	/* Allocate CouNTer */
+	uint8_t		reserved2[0x20];
+	uint32_t	FMBM_CGM[8];	/* Congestion Group Map */
+	uint32_t	FMBM_MPD;	/* Pool Depletion */
+	uint8_t		reserved3[0x7c];
+	uint32_t	FMBM_RSTC;	/* STatistics Counter */
+	uint32_t	FMBM_RFRC;	/* FRame Counter */
+	uint32_t	FMBM_RBFC;	/* Bad Frames Counter */
+	uint32_t	FMBM_RLFC;	/* Large Frames Counter */
+	uint32_t	FMBM_RFFC;	/* Filter Frames Counter */
+	uint32_t	FMBM_RFDC;	/* Frames Discard Counter */
+	uint32_t	FMBM_RFLDEC;	/* Frames List DMA Error Counter */
+	uint32_t	FMBM_RODC;	/* Out of buffers Discard Counter */
+	uint32_t	FMBM_RBDC;	/* Buffers Deallocate Counter */
+	uint8_t		reserved4[0x5c];
+	uint32_t	FMBM_RPC;	/* Performance Counters */
+	uint32_t	FMBM_RPCP;	/* Performance Count Parameters */
+	uint32_t	FMBM_RCCN;	/* Cycle CouNter */
+	uint32_t	FMBM_RTUC;	/* Task Utilization Counter */
+	uint32_t	FMBM_RRQUC;	/* Receive Queue Utilization Counter */
+	uint32_t	FMBM_RDUC;	/* DMA Utilization Counter */
+	uint32_t	FMBM_RFUC;	/* FIFO Utilization Counter */
+	uint32_t	FMBM_RPAC;	/* Pause Activation Counter */
+	uint8_t		reserved5[0x60];
+	uint32_t	FMBM_RDCFG[3];	/* Debug ConFiGuration */
+	uint8_t		reserved6[0x74];
+	uint32_t	FMBM_RIBA;	/* Internal Buffer Allocation */
+	uint32_t	FMBM_RIBD;	/* Internal Buffer Deallocation */
+	uint32_t	FMBM_RIBC;	/* Internal Buffer Chain */
+	uint32_t	FMBM_RIBLF;	/* Internal Buffer Link Follow */
+	uint8_t		reserved7[0x70];
+} __aligned(0x400) __packed;
+
+#define FM_BMI_RX_RCFG_EN		0x80000000	/* ENable */
+#define FM_BMI_RX_RCFG_FDOVR		0x02000000	/* Frame Discard OVerRide */
+#define FM_BMI_RX_RCFG_IM		0x01000000	/* Independent Mode */
+
+#define FM_BMI_RX_RFED_CSI(n)		((n) << 24)	/* CheckSum Ignore */
+#define FM_BMI_RX_RFED_CFED(n)		((n) << 16)	/* Chop Frame's End Data */
+
+#define FM_BMI_RX_RICP_ICEOF(n)		((n) << 16)	/* Internat Context External OFfset */
+#define FM_BMI_RX_RICP_ICIOF(n)		((n) << 8)	/* Internat Context Internal OFfset */
+#define FM_BMI_RX_RICP_ICSZ(n)		(n)		/* Internat Context SiZe */
+
+#define FM_BMI_RX_RIM_FOF(n)		((n) << 24)	/* Frame OFfset */
+
+#define FM_BMI_RX_REBM_BSM(n)		((n) << 16)	/* Buffer Start Margin */
+#define FM_BMI_RX_REBM_BEM(n)		(n)		/* Buffer End Margin */
+
+#define FM_BMI_RX_RFNE_NIA(n)		(n)		/* Next Invoked Action */
+
+#define FM_BMI_RX_RFCA_OR		0x80000000	/* ORder definition */
+#define FM_BMI_RX_RFCA_COLOR_GREEN	0x00000000	/* Default COLOR - green */
+#define FM_BMI_RX_RFCA_COLOR_YELLOW	0x040000000	/* Default COLOR - yellow */
+#define FM_BMI_RX_RFCA_COLOR_RED	0x08000000	/* Default COLOR - red */
+#define FM_BMI_RX_RFCA_COLOR_OVERRIDE	0x0C000000	/* Default COLOR - override */
+#define FM_BMI_RX_RFCA_SYNC(n)		((n) << 24)	/* SYNChronization attributes */
+#define FM_BMI_RX_RFCA_MR(n)		((n) << 16)	/* Mode attRibutes */
+
+#define FM_BMI_RX_RFPNE_HPNIA(n)	(n)		/* Hardware Parser Next Invoked Action */
+
+#define FM_BMI_RX_RPSO_PSO(n)		(n)		/* Parsing Start Offset */
+
+#define FM_BMI_RX_RPP_PNUM(n)		(n)		/* Policer profile */
+
+#define FM_BMI_RX_RCCB_CBASE(n)		(n)		/* Coarse classification BASE */
+
+#define FM_BMI_RX_RPRAI_PRA(n)		(n)		/* Parse Results Array */
+
+#define FM_BMI_RX_RFQID_DFQID(n)	(n)		/* Default Frame Queue ID */
+
+#define FM_BMI_RX_REFQID_EFQID(n)	(n)		/* Error Frame Queue ID */
+
+#define FM_BMI_RX_RFSDM_FSDM(n)		(n)		/* Frame Status Discard Mask */
+
+#define FM_BMI_RX_RFSEM_FSEM(n)		(n)		/* Frame Status Error Mask */
+
+#define FM_BMI_RX_RFENE_NIA(n)		(n)		/* Next Invoked Action */
+
+#define FM_BMI_RX_EBMPI_VAL		0x80000000	/* Valid */
+#define FM_BMI_RX_EBMPI_ADCE		0x40000000	/* Allocate/Deallocate Coutners Enable */
+#define FM_BMI_RX_EBMPI_BPID(n)		((n) << 16)	/* Buffer Pool ID */
+#define FM_BMI_RX_EBMPI_PBS(n)		(n)		/* Pool Buffer Size */
+
+/** \internal
+ *  \brief		BMI Tx port register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_bmi_tx_mmap_s {
+	uint32_t	FMBM_TCFG;	/* Configuration */
+	uint32_t	FMBM_TST;	/* STatus */
+	uint32_t	FMBM_TDA;	/* DMA Attributes */
+	uint32_t	FMBM_TFP;	/* FIFO Parameters */
+	uint32_t	FMBM_TFED;	/* Frame End Data */
+	uint32_t	FMBM_TICP;	/* Internal Context Paramenters */
+	uint32_t	FMBM_TFNE;	/* Frame Next Engine */
+	uint32_t	FMBM_TFCA;	/* Framme Command Attributes */
+	uint32_t	FMBM_TCFQID;	/* Confirmation Queue ID */
+	uint32_t	FMBM_TEFQID;	/* Error Frame Queue ID */
+	uint32_t	FMBM_TFENE;	/* Frame Enqueue Next Engine */
+	uint32_t	FMBM_TRLMTS;	/* Rate LiMiTer Scale */
+	uint32_t	FMBM_TRLMT;	/* Rate LiMiTer */
+	uint8_t		reserved0[0x1cc];
+	uint32_t	FMBM_TSTC;	/* STatistics Counter */
+	uint32_t	FMBM_TFRC;	/* FRame Counter */
+	uint32_t	FMBM_TFDC;	/* Frames Discard Counter */
+	uint32_t	FMBM_TFLEDC;	/* Framees Length Error Discard Counter */
+	uint32_t	FMBM_TFUFDC;	/* Frames Unsupported Format Discard Counter */
+	uint32_t	FMBM_TBDC;	/* Buffer Deallocate Counter */
+	uint8_t		reserved1[0x68];
+	uint32_t	FMBM_TPC;	/* Performance Counters */
+	uint32_t	FMBM_TPCP;	/* Performance Count Parameters */
+	uint32_t	FMBM_TCCN;	/* Cycle Counter */
+	uint32_t	FMBM_TTUC;	/* Tasks Utilization Counter */
+	uint32_t	FMBM_TTCQUC;	/* Transmit Confirm Queue Utilization Counter */
+	uint32_t	FMBM_TDUC;	/* DMA Utilization Counter */
+	uint32_t	FMBM_TFUC;	/* FIFO Utilization Counter */
+	uint8_t		reserved2[0x64];
+	uint32_t	FMBM_TDCFG[3];	/* Debug ConFiGuration */
+	uint8_t		reserved3[0x74];
+	uint32_t	FMBM_TIBA;	/* Internal Buffer Allocation */
+	uint32_t	FMBM_TIBD;	/* Internal Buffer Deallocation */
+	uint32_t	FMBM_TIBC;	/* Internal Buffer Chain */
+	uint32_t	FMBM_TIBLF;	/* Internal Buffer Link Follow */
+	uint8_t		reserved4[0x70];
+} __aligned(0x400) __packed;
+
+#define FM_BMI_TX_TCFG_EN		0x80000000	/* ENable  */
+#define FM_BMI_TX_TCFG_IM		0x01000000	/* Independent Mode */
+
+#define FM_BMI_TX_TFP_MFL(n)		((n) << 16)	/* Minimum Fill Level */
+#define FM_BMI_TX_TFP_DPDE(n)		((n) << 12)	/* Dequeue Pipeline Depth */
+#define FM_BMI_TX_TFP_FLCL(n)		(n)		/* FIFO Low Comfort Level */
+
+#define FM_BMI_TX_TICP_ICEOF(n)		((n) << 16)	/* Internat Context External OFfset */
+#define FM_BMI_TX_TICP_ICIOF(n)		((n) << 8)	/* Internat Context Internal OFfset */
+#define FM_BMI_TX_TICP_ICSZ(n)		(n)		/* Internat Context SiZe */
+
+#define FM_BMI_TX_TFNE_NIA(n)		(n)		/* Next Invoked Action */
+
+#define FM_BMI_TX_TFCA_OR		0x80000000	/* ORder definition */
+#define FM_BMI_TX_TFCA_COLOR_GREEN	0x00000000	/* Default COLOR - green */
+#define FM_BMI_TX_TFCA_COLOR_YELLOW	0x040000000	/* Default COLOR - yellow */
+#define FM_BMI_TX_TFCA_COLOR_RED	0x08000000	/* Default COLOR - red */
+#define FM_BMI_TX_TFCA_COLOR_OVERRIDE	0x0C000000	/* Default COLOR - override */
+#define FM_BMI_TX_TFCA_SYNC(n)		((n) << 24)	/* SYNChronization attributes */
+#define FM_BMI_TX_TFCA_MR(n)		((n) << 16)	/* Mode attRibutes */
+
+#define FM_BMI_TX_TCFQID_CFQID(n)	(n)		/* Confirmation Frame Queue ID */
+
+#define FM_BMI_TX_TFENE_NIA(n)		(n)		/* Next Invoked Action */
+
+/** \internal
+ *  \brief		The BMI part of a port
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+union fm_port_bmi_mmap_u {
+	struct fm_bmi_common_mmap_s	common;
+	struct fm_bmi_oh_mmap_s		oh;
+	struct fm_bmi_rx_mmap_s		rx;
+	struct fm_bmi_tx_mmap_s		tx;
+} __aligned(0x400) __packed;
+
+/** BMI common register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMBM_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a BMI common register. This offset is suitable for using
+ *  with the fm_port_in() and fm_port_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that initializes the internal (MURAM) free buffer pool by writing
+ *  into the FMBM_INIT register:
+ *
+ *  \code
+ *		...
+ *	struct fman_port *common_port;
+ *		...
+ *	common_port = fm_port_create(0xfe480000);
+ *		...
+ *	fm_port_out(common_port, FM_BMI_COMMON(INIT), FM_BMI_COMMON_INIT_STR);
+ *		...
+ *	fm_port_destroy(common_port);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_BMI_COMMON(reg)	\
+	(offsetof(struct fm_port_mmap_s, bmi) + offsetof(struct fm_bmi_common_mmap_s, FMBM_##reg))
+
+/** BMI offline parsing/host command register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMBM_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a BMI offline parsing/host command register. This offset is
+ *  suitable for using with the fm_port_in() and fm_port_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that enables a O/H port for TX by writing into the FMBM_OCFG
+ *  register:
+ *
+ *  \code
+ *		...
+ *	struct fman_port *oh_port;
+ *		...
+ *	oh_port = fm_port_create(0xfe481000);
+ *		...
+ *	fm_port_out(oh_port, FM_BMI_OH(OCFG), FM_BMI_OH_OCFG_EN);
+ *		...
+ *	fm_port_destroy(oh_port);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_BMI_OH(reg)		\
+	(offsetof(struct fm_port_mmap_s, bmi) + offsetof(struct fm_bmi_oh_mmap_s, FMBM_##reg))
+
+/** BMI RX register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMBM_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a BMI RX register. This offset is suitable for using with
+ *  the fm_port_in() and fm_port_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that reads the status of a RX port by reading from the FMBM_RST
+ *  register:
+ *
+ *  \code
+ *		...
+ *	struct fman_port *rx_port;
+ *		...
+ *	rx_port = fm_port_create(0xfe488000);
+ *		...
+ *	while (fm_port_in(rx_port, FM_BMI_RX(RST)) & FM_BMI_RX_RST_BSY)
+ *		cpu_relax();
+ *	/ * Port not busy * /
+ *		...
+ *	fm_port_destroy(rx_port);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_BMI_RX(reg)		\
+	(offsetof(struct fm_port_mmap_s, bmi) + offsetof(struct fm_bmi_rx_mmap_s, FMBM_##reg))
+
+/** BMI TX register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMBM_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a BMI TX register. This offset is suitable for using with
+ *  the fm_port_in() and fm_port_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that enables TX by writing into the FMBM_TCFG register:
+ *
+ *  \code
+ *		...
+ *	struct fman_port *tx_port;
+ *		...
+ *	tx_port = fm_port_create(0xfe4a8000);
+ *		...
+ *	fm_port_out(tx_port, FM_BMI_TX(TCFG), FM_BMI_TX_RCFG_EN);
+ *		...
+ *	fm_port_destroy(tx_port);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_BMI_TX(reg)		\
+	(offsetof(struct fm_port_mmap_s, bmi) + offsetof(struct fm_bmi_tx_mmap_s, FMBM_##reg))
+
+/** @} */
+
+/** \addtogroup	QMI
+ *  @{
+ */
+
+/** \internal
+ *  \brief		QMI common port register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_qmi_common_mmap_s {
+	uint32_t	FMQM_GC;	/* Global Configuration */
+	uint8_t		reserved0[4];
+	uint32_t	FMQM_EIE;	/* Error Interrupt Event */
+	uint32_t	FMQM_EIEN;	/* Error Interrupt Enable */
+	uint32_t	FMQM_EIF;	/* Error Interrupt Force */
+	uint8_t		reserved1[0x3ec];
+} __aligned(0x400) __packed;
+
+#define FM_QMI_COMMON_GC_EN		0x80000000	/* ENable */
+#define FM_QMI_COMMON_GC_ACC		0x40000000	/* All Counters Clear */
+#define FM_QMI_COMMON_GC_STEN		0x10000000	/* global STatistics Enable */
+#define FM_QMI_COMMON_GC_SR		0x01000000	/* Soft Reset */
+
+#define FM_QMI_IRQ_DEE			0x80000000	/* Double-bit ECC Error */
+
+/** \internal
+ *  \brief		QMI offline parsing/host command and Tx port register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_qmi_oh_tx_mmap_s {
+	uint8_t		reserved0[0x30];
+	uint32_t	FMQM_PDC;	/* Dequeue Configuration */
+	uint8_t		reserved1[0x3cc];
+} __aligned(0x400) __packed;
+
+#define FM_QMI_OH_PDC_PRI		0x80000000	/* Priority */
+#define FM_QMI_OH_PDC_OPT(n)		((n) << 28)	/* dequeue OPTions */
+#define FM_QMI_OH_PDC_PF		0x02000000	/* PreFetch */
+#define FM_QMI_OH_PDC_FRM		0x01000000	/* FRaMe count */
+/* Sub-Portal */
+#define FM_QMI_OH_PDC_SP_MASK		0x00f00000
+#define FM_QMI_OH_PDC_SP(n)		((n) << 20 & FM_QMI_OH_PDC_SP_MASK)
+#define FM_QMI_OH_PDC_WQ(n)		((n) << 16)	/* Work Queue */
+#define FM_QMI_OH_PDC_BC(n)		(n)		/* Byte Count */
+
+#define FM_QMI_TX_PDC_PRI		FM_QMI_OH_PDC_PRI
+#define FM_QMI_TX_PDC_OPT		FM_QMI_OH_PDC_OPT
+#define FM_QMI_TX_PDC_PF		FM_QMI_OH_PDC_PF
+#define FM_QMI_TX_PDC_FRM		FM_QMI_OH_PDC_FRM
+#define FM_QMI_TX_PDC_SP		FM_QMI_OH_PDC_SP
+#define FM_QMI_TX_PDC_WQ		FM_QMI_OH_PDC_WQ
+#define FM_QMI_TX_PDC_BC		FM_QMI_OH_PDC_BC
+
+/** \internal
+ *  \brief		QMI Rx port register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_qmi_rx_mmap_s {
+	uint8_t		reserved0[0x400];
+} __aligned(0x400) __packed;
+
+/** \internal
+ *  \brief		The QMI part of a port
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+union fm_port_qmi_mmap_u {
+	struct fm_qmi_common_mmap_s	common;
+	struct fm_qmi_oh_tx_mmap_s	oh;
+	struct fm_qmi_rx_mmap_s		rx;
+	struct fm_qmi_oh_tx_mmap_s	tx;
+} __aligned(0x400) __packed;
+
+/** QMI common register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMQM_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a QMI common register. This offset is suitable for using
+ *  with the fm_port_in() and fm_port_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that enables QMI enqueues and dequeues by writing into the FMQM_GC
+ *  register:
+ *
+ *  \code
+ *		...
+ *	struct fman_port *common_port;
+ *		...
+ *	common_port = fm_port_create(0xfe480000);
+ *		...
+ *	fm_port_out(common_port, FM_QMI_COMMON(GC),
+ *			FM_QMI_COMMON_GC_ENQ_EN | FM_QMI_COMMON_GC_DEQ_EN);
+ *		...
+ *	fm_port_destroy(common_port);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_QMI_COMMON(reg)	\
+	(offsetof(struct fm_port_mmap_s, qmi) + offsetof(struct fm_qmi_common_mmap_s, FMQM_##reg))
+
+/** QMI offline parsing/host command register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMQM_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a QMI offline parsing/host command register. This offset is
+ *  suitable for using with the fm_port_in() and fm_port_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that enables a O/H port by writing into the FMQM_PC register:
+ *
+ *  \code
+ *		...
+ *	struct fman_port *oh_port;
+ *		...
+ *	oh_port = fm_port_create(0xfe481000);
+ *		...
+ *	fm_port_out(oh_port, FM_QMI_OH(PC), FM_QMI_OH_PC_EN);
+ *		...
+ *	fm_port_destroy(oh_port);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_QMI_OH(reg)		\
+	(offsetof(struct fm_port_mmap_s, qmi) + offsetof(struct fm_qmi_oh_tx_mmap_s, FMQM_##reg))
+
+/** QMI RX register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMQM_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a QMI RX register. This offset is suitable for using with
+ *  the fm_port_in() and fm_port_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that reads the enqueue status of a RX port by reading from the
+ *  FMQM_PS register:
+ *
+ *  \code
+ *		...
+ *	struct fman_port *rx_port;
+ *		...
+ *	rx_port = fm_port_create(0xfe488000);
+ *		...
+ *	while (fm_port_in(rx_port, FM_QMI_RX(PS)) & FM_QMI_RX_PS_PBSY_ET)
+ *		cpu_relax();
+ *	/ * Port not busy with enqueues * /
+ *		...
+ *	fm_port_destroy(rx_port);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_QMI_RX(reg)		\
+	(offsetof(struct fm_port_mmap_s, qmi) + offsetof(struct fm_qmi_rx_mmap_s, FMQM_##reg))
+
+/** QMI TX register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMQM_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a QMI TX register. This offset is suitable for using with
+ *  the fm_port_in() and fm_port_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that enables a TX port by writing into the FMQM_PC register:
+ *
+ *  \code
+ *		...
+ *	struct fman_port *tx_port;
+ *		...
+ *	tx_port = fm_port_create(0xfe4a8000);
+ *		...
+ *	fm_port_out(tx_port, FM_QMI_TX(PC), FM_QMI_TX_PC_EN);
+ *		...
+ *	fm_port_destroy(tx_port);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_QMI_TX(reg)		\
+	(offsetof(struct fm_port_mmap_s, qmi) + offsetof(struct fm_qmi_oh_tx_mmap_s, FMQM_##reg))
+
+/** @} */
+
+/** \addtogroup	Parser
+ *  @{
+ */
+
+/** \internal
+ *  \brief		Parser common/global register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_parser_common_mmap_s {
+	uint8_t		FMPR_PMDA[0x800];	/* Parse Memory Direct Access */
+	uint32_t	FMPR_SXPAW[0x10];	/* Soft eXamination Parameter Array */
+	uint32_t	FMPR_RPCLIM;		/* Parsing Cycle LImit */
+	uint32_t	FMPR_RPIMAC;		/* Internal Memory Access Control */
+	uint32_t	FMPR_PMEEC;		/* Parse Memory EEC Error Capture */
+	uint8_t		reserved0[0x14];
+	uint32_t	FMPR_PEVR;		/* Event */
+	uint32_t	FMPR_PEVER;		/* Event Enable */
+	uint8_t		reserved1[4];
+	uint32_t	FMPR_PERR;		/* Error */
+	uint32_t	FMPR_PERER;		/* Error Enable */
+	uint8_t		reserved2[0x78c];
+} __aligned(0x1000) __packed;
+
+#define FM_PARSER_COMMON_RPCLIM_RHPCLIM(n)	(n)		/* maximum Parse Cycle LIMit */
+
+#define FM_PARSER_COMMON_RPIMAC_PSTAT		0x00000100	/* Parser STATus */
+#define FM_PARSER_COMMON_RPIMAC_PEN		0x00000001	/* Parser ENable */
+
+#define FM_PARSER_COMMON_PMEEC_CAP		0x80000000	/* CAPtured error indication */
+#define FM_PARSER_COMMON_PMEEC_CET		0x40000000	/* Captured Error Type */
+#define FM_PARSER_COMMON_PMEEC_SERCNT(n)	((n) << 16)	/* Soft ERror CouNTer */
+#define FM_PARSER_COMMON_PMEEC_MEMADDR(n)	(n)		/* ECC error MEMory ADDRess */
+
+#define FM_PARSER_IRQ_SPI(n)			(1 << (16 + (n)))	/* Stopped Port is not Idle */
+#define FM_PARSER_IRQ_SCM			0x00004000	/* Single-bit ECC is at Max */
+
+#define FM_PARSER_EIRQ_IA(n)			(1 << (16 + (n)))	/* Illegal Access */
+#define FM_PARSER_EIRQ_IAG			FM_PARSER_EIRQ_IA(-1)	/* Illegal Access Global*/
+#define FM_PARSER_EIRQ_ECCE			0x00004000		/* ECC multiple-bit Error */
+
+/** \internal
+ *  \brief		The parser part of a port
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_port_parser_mmap_s {
+	uint8_t		FMPR_PMDA[0x80];	/* Parse Memory Direct Access */
+	uint8_t		reserved0[0x378];
+	uint32_t	FMPR_PCAC;		/* Configuration Access Control */
+	uint32_t	FMPR_PCTPID;		/* Configured TPID */
+} __aligned(0x400) __packed;
+
+#define FM_PARSER_PCAC_PSTAT	0x00000100	/* Port STATus */
+#define FM_PARSER_PCAC_PSTOP	0x00000001	/* Port STOP */
+
+/** Parser common/global register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMPR_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a parser common/global register. This offset is suitable
+ *  for using with the fm_in() and fm_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that disables the parser by writing into the FMPR_RPIMAC register:
+ *
+ *  \code
+ *		...
+ *	struct fman *fm;
+ *		...
+ *	fm = fm_create(0xfe400000);
+ *		...
+ *	fm_out(fm, FM_PARSER_COMMON(RPIMAC), 0);
+ *		...
+ *	fm_destroy(fm);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_PARSER_COMMON(reg)	\
+	(offsetof(struct fm_mmap_s, parser) + offsetof(struct fm_parser_common_mmap_s, FMPR_##reg))
+
+/** Parser register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMPR_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a parser register. This offset is suitable for using with
+ *  the fm_port_in() and fm_port_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that stops a parser port by writing and reading the FMPR_PCAC
+ *  register:
+ *
+ *  \code
+ *		...
+ *	struct fman_port *port;
+ *		...
+ *	port = fm_port_create(0xfe488000);
+ *		...
+ *	fm_port_out(port, FM_PARSER(PCAC), FM_PARSER_PCAC_PSTOP);
+ *	while (fm_port_in(port, FM_PARSER(PCAC)) & FM_PARSER_PCAP_PSTAT)
+ *		cpu_relax();
+ *	/ * The port is stopped * /
+ *		...
+ *	fm_port_destroy(port);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_PARSER(reg)		\
+	(offsetof(struct fm_port_mmap_s, parser) + offsetof(struct fm_port_parser_mmap_s, FMPR_##reg))
+
+/** @} */
+
+/* Port */
+
+/** \internal
+ *  \brief		Aggregated port register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_port_mmap_s {
+	union fm_port_bmi_mmap_u	bmi;
+	union fm_port_qmi_mmap_u	qmi;
+	struct fm_port_parser_mmap_s	parser;
+	uint8_t				reserved0[0x400];
+} __aligned(0x1000) __packed;
+
+/** @} */
+
+/* Policer */
+
+/** \addtogroup	Policer
+ *  @{
+ */
+
+/** \internal
+ *  \brief		Policer register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_policer_mmap_s {
+	uint8_t		reserved0[0x8c];
+	uint32_t	FMPL_PAR;		/* Profile Action */
+	uint32_t	FMPL_PE_MODE;		/* Profile Entry Mode */
+	uint8_t		reserved1[0xf6c];
+} __aligned(0x1000) __packed;
+
+/** Policer register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMPL_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a policer register. This offset is suitable for using with
+ *  the fm_in() and fm_out() functions.
+ *
+ *  \hideinitializer
+ */
+#define FM_POLICER(reg)	\
+	(offsetof(struct fm_mmap_s, policer) + offsetof(struct fm_policer_mmap_s, FMPL_##reg))
+
+/** @} */
+
+/* KeyGen */
+
+/** \addtogroup KeyGen
+ *  @{
+ */
+
+/** \internal
+ *  \brief		KeyGen scheme register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_keygen_scheme_entry_mmap_s {
+	uint32_t	FMKG_SE_MODE;	/* Scheme Entry Mode */
+	uint32_t	FMKG_SE_EKFC;	/* Scheme Entry Extract Known Fields Command */
+	uint32_t	FMKG_SE_EKDV;	/* Scheme Entry Extract Known Default Value */
+	uint32_t	FMKG_SE_BMCH;	/* Scheme Entry Bit Mask Command High */
+	uint32_t	FMKG_SE_BMCL;	/* Scheme Entry Bit Mask Command Low */
+	uint32_t	FMKG_SE_FQB;	/* Scheme Entry Frame Queue Base */
+	uint32_t	FMKG_SE_HC;	/* Scheme Entry Hash Command */
+	uint32_t	FMKG_SE_PPC;	/* Scheme Entry Policer Profile Command */
+	uint32_t	FMKG_SE_GEC[8];	/* Scheme Entry Generic Extract Command */
+	uint32_t	FMKG_SE_SPC;	/* Scheme Entry Statistics Packet Counter */
+	uint32_t	FMKG_SE_DV[2];	/* Scheme Entry Default Value */
+	uint32_t	FMKG_SE_DC;	/* Scheme Entry Debug Criteria */
+	uint32_t	FMKG_SE_MV;	/* Scheme Entry Match Vector */
+} __aligned(0x100) __packed;
+
+/** \internal
+ *  \brief		KeyGen register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ *  \todo		Identified a suitable overlaying scheme for port partitions, classification
+ *			plans and classification schemes
+ */
+struct fm_keygen_mmap_s {
+	uint32_t	FMKG_GCR;	/* General Configuration */
+	uint32_t	FMKG_ER;	/* Event */
+	uint32_t	FMKG_EMR;	/* Event Mask */
+	uint32_t	FMKG_EER;	/* Error Event */
+	uint32_t	FMKG_EEMR;	/* Error Event Mask */
+	uint32_t	FMKG_SER;	/* Scheme Event */
+	uint32_t	FMKG_SEMR;	/* Scheme Event Mask */
+	uint32_t	FMKG_SEER;	/* Scheme Error Event */
+	uint32_t	FMKG_SEEMR;	/* Scheme Error Event Mask */
+	uint32_t	FMKG_GSR;	/* Global Status */
+	uint32_t	FMKG_TPC;	/* Total Packet Counter */
+	uint32_t	FMKG_SERC;	/* Soft Error Capture */
+	uint8_t		reserved0[0x10];
+	uint32_t	FMKG_FDOR;	/* Frame Data Offset */
+	uint32_t	FMKG_GDVR[2];	/* Global Default Value */
+	uint8_t		reserved1[0xb4];
+	uint32_t	FMKG_SE_MODE;	/* Scheme Entry Mode */
+	uint32_t	FMKG_SE_EKFC;	/* Scheme Entry Extract Known Fields Command */
+	uint32_t	FMKG_SE_EKDV;	/* Scheme Entry Extract Known Default Value */
+	uint32_t	FMKG_SE_BMCH;	/* Scheme Entry Bit Mask Command High */
+	uint32_t	FMKG_SE_BMCL;	/* Scheme Entry Bit Mask Command Low */
+	uint32_t	FMKG_SE_FQB;	/* Scheme Entry Frame Queue Base */
+	uint32_t	FMKG_SE_HC;	/* Scheme Entry Hash Command */
+	uint32_t	FMKG_SE_PPC;	/* Scheme Entry Policer Profile Command */
+	uint32_t	FMKG_SE_GEC[8];	/* Scheme Entry Generic Extract Command */
+	uint32_t	FMKG_SE_SPC;	/* Scheme Entry Statistics Packet Counter */
+	uint32_t	FMKG_SE_DV[2];	/* Scheme Entry Default Value */
+	uint32_t	FMKG_SE_DC;	/* Scheme Entry Debug Criteria */
+	uint32_t	FMKG_SE_MV;	/* Scheme Entry Match Vector */
+	uint8_t		reserved2[0xa8];
+	uint32_t	FMKG_AR;	/* Action */
+	uint8_t		reserved3[0xe00];
+} __aligned(0x1000) __packed;
+
+#define FM_KEYGEN_GCR_EN		0x80000000		/* ENable */
+#define FM_KEYGEN_GCR_DEFNIA(n)		(n)			/* DEFault Next Invoked Action */
+
+#define FM_KEYGEN_EIRQ_DECC		0x80000000		/* Double-bit ECC error */
+#define FM_KEYGEN_EIRQ_IEE		0x40000000		/* Initialization Entry Error */
+#define FM_KEYGEN_EIRQ_KSO		0x20000000		/* KeyGen Size Overflow */
+
+#define FM_KEYGEN_SIRQ_SC(n)		(0x80000000 >> (n))	/* SCheme interrupt */
+
+#define FM_KEYGEN_SEIRQ_SC(n)		(0x80000000 >> (n))	/* SCheme error interrupt */
+
+#define FM_KEYGEN_GSR_BSY		0x80000000		/* Busy */
+
+#define FM_KEYGEN_TPC_TPCNT(n)		(n)			/* Total Packet CouNTer */
+
+#define FM_KEYGEN_SERC_CAP		0x80000000		/* CAPtured error indication */
+#define FM_KEYGEN_SERC_CET		0x40000000		/* Captured Error Type */
+#define FM_KEYGEN_SERC_SERCNT(n)	((n) << 16)		/* Soft ERror CouNTer */
+#define FM_KEYGEN_SERC_ET		0x00008000		/* Entry Type */
+#define FM_KEYGEN_SERC_SOFS(n)		((n) << 8)		/* Scheme OFfSet capture */
+#define FM_KEYGEN_SERC_NUM(n)		(n)			/* Scheme/Classification plan NUMber capture */
+
+#define FM_KEYGEN_FDOR_OFFSET(n)	(n)			/* OFFSET to the end of the parsing point */
+
+#define FM_KEYGEN_GDVR_DV(n)		(n)			/* Default Value */
+
+#define FM_KEYGEN_AR_GO			0x80000000		/* Activate the atomic scheme entry access */
+#define FM_KEYGEN_AR_RW			0x40000000		/* Read/Write access type */
+#define FM_KEYGEN_AR_PORTID(n)		((n) << 24)		/* Port ID */
+/* SELect entry */
+#define FM_KEYGEN_AR_SEL_MASK		0x00c00000
+#define FM_KEYGEN_AR_SEL(n)		((n) << 22 & FM_KEYGEN_AR_SEL_MASK)
+/* Scheme/Classification NUMber */
+#define FM_KEYGEN_AR_NUM_MASK		0x001f0000
+#define FM_KEYGEN_AR_NUM(n)		((n) << 16 & FM_KEYGEN_AR_NUM_MASK)
+#define FM_KEYGEN_AR_WSEL(n)		(n)			/* Word SELect */
+
+#define FM_KEYGEN_SE_MODE_SI		0x80000000		/* Scheme Initialization bit */
+#define FM_KEYGEN_SE_MODE_IM		0x40000000		/* Index Mode */
+#define FM_KEYGEN_SE_MODE_PL		0x01000000		/* PoLicer type */
+#define FM_KEYGEN_SE_MODE_NIA(n)	(n)			/* scheme Next Instruction Address */
+#define FM_KEYGEN_EKFC_PORTID		0x80000000		/* PORT ID */
+#define FM_KEYGEN_EKFC_MACDST		0x40000000		/* MAC DeSTination address */
+#define FM_KEYGEN_EKFC_MACSRC		0x20000000		/* MAC SouRCe address */
+#define FM_KEYGEN_EKFC_TC1		0x10000000		/* TCI from the first VLAN header */
+#define FM_KEYGEN_EKFC_TC2		0x08000000		/* TCI from the second VLAN header */
+#define FM_KEYGEN_EKFC_ETYPE		0x04000000		/* Ethernet TYPE */
+#define FM_KEYGEN_EKFC_PPPSID		0x02000000		/* PPPoE Session ID */
+#define FM_KEYGEN_EKFC_PPPPID		0x01000000		/* PPPoE Protocol ID */
+#define FM_KEYGEN_EKFC_MPLS1		0x00800000		/* MPLS from first label */
+#define FM_KEYGEN_EKFC_MPLS2		0x00400000		/* MPLS from seconf label */
+#define FM_KEYGEN_EKFC_MPLS3		0x00200000		/* MPLS from third label */
+#define FM_KEYGEN_EKFC_IPSRC		0x00100000		/* IP SouRCe address */
+#define FM_KEYGEN_EKFC_IPDST		0x00080000		/* IP DeSTination Address */
+#define FM_KEYGEN_EKFC_PTYPE		0x00040000		/* IP Protocol TYPE */
+#define FM_KEYGEN_EKFC_IPTOS		0x00020000		/* IP Type Of Service */
+#define FM_KEYGEN_EKFC_TIPSRC		0x00008000		/* Tunneled IP SouRCe address */
+#define FM_KEYGEN_EKFC_TIPDST		0x00004000		/* Tunneled IP DeSTination address */
+#define FM_KEYGEN_EKFC_TIPTYPE		0x00002000		/* Tunneled IP Protocol TYPE */
+#define FM_KEYGEN_EKFC_TIPTOS		0x00001000		/* Tunneled IP Type Of Service */
+#define FM_KEYGEN_EKFC_IPSECSPI		0x00000400		/* IPSEC SPI */
+#define FM_KEYGEN_EKFC_IPSECNH		0x00000200		/* IPSEC Next Header */
+#define FM_KEYGEN_EKFC_L4PSRC		0x00000004		/* L4 Protocol SouRCe port */
+#define FM_KEYGEN_EKFC_L4PDST		0x00000002		/* L4 Protocol DeSTination port */
+#define FM_KEYGEN_EKFC_TFLG		0x00000001		/* TCP FLaGs */
+
+#define FM_KEYGEN_EKDV_MACDV(n)		((n) << 30)		/*  */
+#define FM_KEYGEN_EKDV_TCDV(n)		((n) << 28)		/*  */
+#define FM_KEYGEN_EKDV_ETYPEDV(n)	((n) << 26)		/*  */
+#define FM_KEYGEN_EKDV_PPPSIDDV(n)	((n) << 24)		/*  */
+#define FM_KEYGEN_EKDV_PPPPIDDV(n)	((n) << 22)		/*  */
+#define FM_KEYGEN_EKDV_MPLSDV(n)	((n) << 20)		/*  */
+#define FM_KEYGEN_EKDV_IPADV(n)		((n) << 18)		/*  */
+#define FM_KEYGEN_EKDV_PTYPEDV(n)	((n) << 16)		/*  */
+#define FM_KEYGEN_EKDV_IPTOSDV(n)	((n) << 14)		/*  */
+#define FM_KEYGEN_EKDV_IP6FLDV(n)	((n) << 12)		/*  */
+#define FM_KEYGEN_EKDV_IPSECSPIDV(n)	((n) << 10)		/*  */
+#define FM_KEYGEN_EKDV_L4PDV(n)		((n) << 8)		/*  */
+#define FM_KEYGEN_EKDV_TFLAGDV(n)	((n) << 6)		/*  */
+
+#define FM_KEYGEN_BMCH_MCS0(n)		((n) << 26)		/* Mask Command Select 0 */
+#define FM_KEYGEN_BMCH_MCS1(n)		((n) << 20)		/* Mask Command Select 1 */
+#define FM_KEYGEN_BMCH_MO0(n)		((n) << 16)		/* Mask Offset0 */
+#define FM_KEYGEN_BMCH_MCS2(n)		((n) << 10)		/* Mask Command Select 2 */
+#define FM_KEYGEN_BMCH_MCS3(n)		((n) << 4)		/* Mast Command Select 3 */
+#define FM_KEYGEN_BMCH_MO1(n)		(n)			/* Mask Offst 1 */
+
+#define FM_KEYGEN_BMCL_BM0(n)		((n) << 24)		/* Bit Mask 0 */
+#define FM_KEYGEN_BMCL_BM1(n)		((n) << 16)		/* Bit Mask 1 */
+#define FM_KEYGEN_BMCL_BM2(n)		((n) << 8)		/* Bit Mask 2 */
+#define FM_KEYGEN_BMCL_BM3(n)		(n)			/* Bit Mask 3 */
+
+#define FM_KEYGEN_FQB_MO2(n)		((n) << 28)		/* Mask Offset 2 */
+#define FM_KEYGEN_FQB_MO3(n)		((n) << 24)		/* Mask Offset 3*/
+#define FM_KEYGEN_FQB_FQBASE(n)		(n)			/* Frame Queue Base */
+
+/* Hash SHIFT right */
+#define FM_KEYGEN_HC_HSHIFT_MASK	0x3f000000
+#define FM_KEYGEN_HC_HSHIFT(n)		((n) << 24 & FM_KEYGEN_HC_HSHIFT)
+/* Hash MASK */
+#define FM_KEYGEN_HC_HMASK_MASK		0x00ffffff
+#define FM_KEYGEN_HC_HMASK(n)		((n) & FM_KEYGEN_HC_HMASK_MASK)
+
+#define FM_KEYGEN_PPC_PPS(n)		((n) << 12)		/* Policer Profile Shift */
+#define FM_KEYGEN_PPC_PPMASK(n)		((n) << 16)		/* Policer Profile MASK */
+#define FM_KEYGEN_PPC_PPBASE(n)		(n)			/* Policer Profile BASE */
+
+#define FM_KEYGEN_GEC_V			0x80000000		/* Valid */
+#define FM_KEYGEN_GEC_DV(n)		((n) << 29)		/* Default Value */
+#define FM_KEYGEN_GEC_SIZE(n)		((n) << 24)		/* SIZE */
+#define FM_KEYGEN_GEC_MASK(n)		((n) << 16)		/* MASK */
+#define FM_KEYGEN_GEC_TYPE		0x00008000		/* command TYPE */
+#define FM_KEYGEN_GEC_HT(n)		((n) << 8)		/* Header Type */
+#define FM_KEYGEN_GEC_EO(n)		(n)			/* Extract Offset */
+
+#define FM_KEYGEN_SPC_PC(n)		(n)			/* Packet Counter */
+
+#define FM_KEYGEN_DV_DV(n)		(n)			/* Default Value */
+
+#define FM_KEYGEN_DC_DE			0x80000000		/* Debug Enable */
+
+#define FM_KEYGEN_MV_MV(n)		(n)			/* Match Vector */
+
+/** KeyGen register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG but without the \c "FMKG_"
+ *			prefix
+ *
+ *  Use this macro to get the offset of a KeyGen register. This offset is suitable for using with
+ *  the fm_keygen_in() and fm_keygen_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that enables the KeyGen by writing into the FMKG_GCR register:
+ *
+ *  \code
+ *		...
+ *	struct fman_keygen *keygen;
+ *		...
+ *	keygen = fm_keygen_create(0xfe4c1000);
+ *		...
+ *	fm_keygen_out(keygen, FM_KEYGEN(GCR), FM_KEYGEN_GCR_EN);
+ *		...
+ *	fm_keygen_destroy(keygen);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_KEYGEN(reg)	\
+	(offsetof(struct fm_mmap_s, keygen) + offsetof(struct fm_keygen_mmap_s, FMKG_##reg))
+
+/** @} */
+
+/* DMA */
+
+/** \addtogroup	DMA
+ *  @{
+ */
+
+/** \internal
+ *  \brief		DMA register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_dma_mmap_s {
+	uint8_t		reserved0[0x60];
+	uint32_t	FMDM_PLR[32];	/* PID-LIODN */
+	uint8_t		reserved1[0xf20];
+} __aligned(0x1000) __packed;
+
+#define FM_DMA(reg) (offsetof(struct fm_mmap_s, dma) + offsetof(struct fm_dma_mmap_s, FMDM_##reg))
+
+/** @} */
+
+/* FPM */
+
+/** \addtogroup	FPM
+ *  @{
+ */
+
+/** \internal
+ *  \brief		FPM register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_fpm_mmap_s {
+	uint32_t	FMFP_TNC;	/* TNUM control */
+	uint32_t	FMFP_PRC;	/* PoRt_id Control */
+	uint8_t		reserved0[0x18];
+	uint32_t	FMFP_REV[8];	/* RISC EVent */
+	uint32_t	FMFP_REE[8];	/* RISC Event Enable */
+	uint8_t		reserved1[0xfa0];
+} __aligned(0x1000) __packed;
+
+#define FM_FPM(reg) (offsetof(struct fm_mmap_s, fpm) + offsetof(struct fm_fpm_mmap_s, FMFP_##reg))
+
+/** @} */
+
+/* dTSEC */
+
+/** \addtogroup MAC
+ * @{
+ */
+
+/** \internal
+ *  \brief		dTSEC register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_dtsec_mmap_s {
+	uint8_t		reserved0[0x100];
+	uint32_t	MACCFG[2];	/* MAC ConFiGuration */
+	uint8_t		reserved1[0xef8];
+} __aligned(0x1000) __packed;
+
+/** dTSEC register offset
+ *
+ *  \param[in]	reg	The name of a register as it appears in the BG
+ *
+ *  Use this macro to get the offset of a dTSEC register. This offset is suitable for using with
+ *  the fm_mac_in() and fm_mac_out() functions.
+ *
+ *  \par	Example:
+ *
+ *  Here is a sequence of code that initializes a dTSEC to append a CRC to all frames by writing
+ *  into the MACCFG2 register:
+ *
+ *  \code
+ *		...
+ *	struct fman_mac *mac;
+ *		...
+ *	mac = fm_mac_create(0xfe4e0000);
+ *		...
+ *	fm_mac_out(mac, FM_DTSEC(MACCFG[1]), FM_DTSEC_MACCFG2_CRC_EN);
+ *		...
+ *	fm_mac_destroy(mac);
+ *		...
+ *  \endcode
+ *
+ *  \hideinitializer
+ */
+#define FM_DTSEC(reg) offsetof(struct fm_dtsec_mmap_s, reg)
+
+/** @} */
+
+/** \addtogroup MDIO
+ *  @{
+ */
+
+/** \internal
+ *  \brief		MDIO register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_mdio_mmap_s {
+	uint8_t	reserved[0x1000];
+}  __aligned(0x1000) __packed;
+
+/** @} */
+
+/** \internal
+ *  \brief		Aggregated dTSEC and MDIO register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_dtsec_mdio_mmap_s {
+	struct fm_dtsec_mmap_s	dtsec;
+	struct fm_mdio_mmap_s	mdio;
+}  __aligned(0x2000) __packed;
+
+/* FMan */
+
+/** \internal
+ *  \brief		Aggregated FMan register layout
+ *  \copydetails	fm_bmi_common_mmap_s
+ */
+struct fm_mmap_s {
+	uint8_t				MURAM[0x80000];
+	struct fm_port_mmap_s		ports[0x40];
+	struct fm_policer_mmap_s	policer;
+	struct fm_keygen_mmap_s		keygen;
+	struct fm_dma_mmap_s		dma;
+	struct fm_fpm_mmap_s		fpm;
+	uint8_t				reserved1[0x3000];
+	struct fm_parser_common_mmap_s	parser;
+	uint8_t				reserved2[0x18000];
+	struct fm_dtsec_mdio_mmap_s	dtsec_mdio[4];
+	uint8_t				reserved3[0x18000];
+} __aligned(0x100000) __packed;
+
+/** Parse results memory layout */
+struct fman_parse_results {
+	uint8_t		lpid;
+	uint8_t		shimr;
+	uint16_t	l2r;
+	uint16_t	l3r;
+	uint8_t		l4r;
+	uint8_t		cplan;
+	uint16_t	nxthdr;
+	uint16_t	cksum;
+	uint32_t	lcv;
+	uint8_t		shim_off[3];
+	uint8_t		eth_off;
+	uint8_t		llc_snap_off;
+	uint8_t		vlan_off;
+	uint8_t		etype_off;
+	uint8_t		pppoe_off;
+	uint8_t		mpls_off;
+	uint8_t		ip_off;
+	uint8_t		gre_off;
+	uint8_t		l4_off;
+	uint8_t		nxthdr_off;
+} __packed;
+
+/* Low-level abstractions */
+
+/** \struct	fman
+ *  \brief	Handle to a FMan object/device
+ *  \details	Used with the fm_in() and fm_out() register access functions
+ */
+struct fman;
+
+/** Get a handle to a FMan device/object
+ *
+ *  \note	For an usage example please see FM_PARSER_COMMON()
+ */
+static inline struct fman __iomem *fm_create(void *regs)
+{
+	return (struct fman *)regs;
+}
+
+/** Read a 32-bit register from the FMan CCSR memory space
+ *
+ *  \note	Use this function as a last resort. It's preferable to use more specific functions
+ *		such as fm_port_in(), etc.
+ */
+static inline uint32_t fm_in(const struct fman *fm,	/**< FMan handle */
+			     off_t reg_off)		/**< Register offset */
+{
+	return in_be32((void *)((uintptr_t)fm + reg_off));
+}
+
+/** Write a 32-bit register into the FMan CCSR memory space
+ *
+ *  \note		Use this function as a last resort. It's preferable to use more specific
+ *			functions such as fm_port_out(), etc.
+ *
+ *  \copydetails	fm_create
+ */
+static inline void fm_out(struct fman *fm,	/**< FMan handle */
+			  off_t reg_off,	/**< Register offset */
+			  uint32_t val)		/**< Register value */
+{
+	out_be32((void *)((uintptr_t)fm + reg_off), val);
+}
+
+/** Release a handle to a FMan device
+ *
+ *  \copydetails	fm_create
+ */
+static inline void fm_destroy(struct fman *regs __maybe_unused)
+{
+}
+
+/** \addtogroup	Port
+ *  @{
+ */
+
+/** Hardware port IDs */
+enum fm_port {
+	fm_port_common,
+	fm_port_oh0,
+	fm_port_oh1,
+	fm_port_oh2,
+	fm_port_oh3,
+	fm_port_oh4,
+	fm_port_oh5,
+	fm_port_oh6,
+	fm_port_rx0,
+	fm_port_rx1,
+	fm_port_rx2,
+	fm_port_rx3,
+	fm_port_rx4 = 0x10,
+	fm_port_tx0 = 0x28,
+	fm_port_tx1,
+	fm_port_tx2,
+	fm_port_tx3,
+	fm_port_tx4 = 0x30
+} __packed;
+
+/** \struct	fman_port
+ *  \brief	Port handle
+ *  \details	Used with the fm_port_in() and fm_port_out() register access functions
+ */
+struct fman_port;
+
+/** Get a handle to a port
+ *
+ *  \note	For an usage example please see one of FM_BMI_COMMON(), FM_BMI_OH(), FM_BMI_RX(),
+ *		FM_BMI_TX(), FM_QMI_COMMON(), FM_QMI_OH(), FM_QMI_RX(), FM_QMI_TX() or/and
+ *		FM_PARSER().
+ */
+static inline struct fman_port __iomem *fm_port_create(void *regs)
+{
+	return (struct fman_port *)regs;
+}
+
+/** Read a 32-bit register from a port CCSR memory space
+ *
+ *  \note	For an usage example please see one of FM_BMI_RX(), FM_QMI_RX() or/and FM_PARSER().
+ */
+static inline uint32_t fm_port_in(const struct fman_port *fm_port,	/**< Port handle */
+				  off_t reg_off)			/**< Register offset */
+{
+	return in_be32((void *)((uintptr_t)fm_port + reg_off));
+}
+
+/** Write a 32-bit register to a port CCSR memory space
+ *
+ *  \note	For an usage example please see one of FM_BMI_COMMON(), FM_BMI_OH(), FM_BMI_TX(),
+ *		FM_QMI_COMMON(), FM_QMI_OH(), FM_QMI_TX() or/and FM_PARSER().
+ */
+static inline void fm_port_out(struct fman_port *fm_port,	/**< Port handle */
+			       off_t reg_off,			/**< Register offset */
+			       uint32_t val)			/**< Register value */
+{
+	out_be32((void *)((uintptr_t)fm_port + reg_off), val);
+}
+
+/** Release a handle to a port
+ *
+ *  \copydetails	fm_port_create
+ */
+static inline void fm_port_destroy(struct fman_port *regs __maybe_unused)
+{
+}
+
+/** @} */
+
+/** \addtogroup	KeyGen
+ *  @{
+ */
+
+/** KeyGen handle
+ */
+struct fman_keygen {
+	struct fm_keygen_mmap_s	*mmap;
+	bool			 busy;
+};
+
+/** Get a handle to KeyGen
+ *
+ *  \note	For a usage example please see FM_KEYGEN() or fm_keygen_entry_start().
+ *
+ *  \todo	No memory allocation
+ */
+static inline struct fman_keygen __iomem *fm_keygen_create(void *regs)
+{
+	struct fman_keygen	*fm_keygen;
+
+	fm_keygen = (typeof(fm_keygen))kzalloc(sizeof(*fm_keygen), GFP_KERNEL);
+	if (likely(fm_keygen != NULL))
+		fm_keygen->mmap = (typeof(fm_keygen->mmap))regs;
+
+	return fm_keygen;
+}
+
+static inline struct fman *keygen_to_fman(struct fman_keygen *fm_keygen)
+{
+	return (struct fman *)container_of(fm_keygen->mmap, struct fm_mmap_s, keygen);
+}
+
+/** Read a 32-bit register from the KeyGen CCSR memory space */
+static inline uint32_t fm_keygen_in(struct fman_keygen *fm_keygen, off_t reg_off)
+{
+	return fm_in(keygen_to_fman(fm_keygen), reg_off);
+}
+
+/** Write a 32-bit register to the KeyGen CCSR memory space
+ *
+ *  \copydetails	fm_keygen_create
+ */
+static inline void fm_keygen_out(struct fman_keygen *fm_keygen, off_t reg_off, uint32_t val)
+{
+	fm_out(keygen_to_fman(fm_keygen), reg_off, val);
+}
+
+/** Release a handle to KeyGen
+ *
+ *  \copydetails	fm_keygen_create
+ *
+ *  \todo		No memory allocation
+ */
+static inline void fm_keygen_destroy(struct fman_keygen *fm_keygen)
+{
+	kfree(fm_keygen);
+}
+
+/** @} */
+
+/** \addtogroup	MAC
+ *  @{
+ */
+
+/** \struct	fman_mac
+ *  \brief	MAC handle
+ *  \details	Used with the fm_mac_in() and fm_mac_out() register access functions
+ *  \note	Currently supports only the dTSEC(s).
+ */
+struct fman_mac;
+
+/** Get a handle to a MAC
+ *
+ *  \note	For an usage example see FM_DTSEC()
+ */
+static inline struct fman_mac __iomem *fm_mac_create(void *regs)
+{
+	return (struct fman_mac *)regs;
+}
+
+/** Read a 32-bit register from a MAC CCSR memory space */
+static inline uint32_t fm_mac_in(const struct fman_mac *fm_mac,	/**< MAC handle */
+				 off_t reg_off)			/**< Register offset */
+{
+	return in_be32((void *)((uintptr_t)fm_mac + reg_off));
+}
+
+/** Write a 32-bit register to a MAC CCSR memory space
+ *
+ *  \copydetails	fm_mac_create
+ */
+static inline void fm_mac_out(struct fman_mac *fm_mac,	/**< MAC handle */
+			      off_t reg_off,		/**< Register offset */
+			      uint32_t val)		/**< Register value */
+{
+	out_be32((void *)((uintptr_t)fm_mac + reg_off), val);
+}
+
+/** Release a handle to a MAC
+ *
+ *  \copydetails	fm_mac_create
+ */
+static inline void fm_mac_destroy(struct fman_mac *regs __maybe_unused)
+{
+}
+
+/** @} */
+
+#define FM_FD_STAT_DME		0x01000000	/* DMA Error - QMI */
+#define FM_FD_STAT_FHE		0x00080000	/* Physical Error - BMI */
+#define FM_FD_STAT_FSE		0x00040000	/* Frame Size Error - BMI */
+#define FM_FD_STAT_DIS		0x00020000	/* Discarded frame - BMI */
+#define FM_FD_STAT_EOF		0x00008000	/* Extract Out of Frame - KEYGEN */
+#define FM_FD_STAT_NSS		0x00004000	/* No Scheme Selected - KEYGEN */
+#define FM_FD_STAT_FCL		0x00000c00	/* Frame Color - Policer */
+#define FM_FD_STAT_IPP		0x00000200	/* Illegal Policer Profile - Policer */
+#define FM_FD_STAT_PTE		0x00000080	/* Parser Timeout Exceeded - Parser */
+#define FM_FD_STAT_ISP		0x00000040	/* Invalid Soft Parser Instruction - Parser */
+#define FM_FD_STAT_PHE		0x00000020	/* Parsing Header Error - Parser */
+#define FM_FD_STAT_ERRORS	(FM_FD_STAT_DME | FM_FD_STAT_FHE | FM_FD_STAT_FSE |	\
+				 FM_FD_STAT_DIS | FM_FD_STAT_EOF | FM_FD_STAT_NSS |	\
+				 FM_FD_STAT_IPP | FM_FD_STAT_PTE | FM_FD_STAT_ISP |	\
+				 FM_FD_STAT_PHE)
+
+#define FM_FD_CMD_FCO	0x80000000	/* Frame queue Context Override */
+#define FM_FD_CMD_RPD	0x40000000	/* Read Prepended Data */
+#define FM_FD_CMD_UDP	0x20000000	/* Update Prepended Data */
+#define FM_FD_CMD_BMF	0x10000000	/* Buffer Must not be Freed */
+#define FM_FD_CMD_DTC	0x08000000	/* Do TCP Checksum */
+#define FM_FD_CMD_DME	0x01000000	/* DMA Error */
+#define FM_FD_CMD_CFQ	0x00ffffff	/* Confirmation Frame Queue */
+
+/* High-level abstractions */
+
+/* KeyGen */
+
+/** \addtogroup	KeyGen
+ *  @{
+ */
+
+/** KeyGen entry types
+ *
+ *  The Keygen uses the same registers area to overlay three different functionalities. Access to
+ *  register sets should be guarded with calls to fm_keygen_entry_start() and fm_keygen_commit().
+ */
+enum fman_keygen_entry_type {
+	fman_keygen_scheme,	/**< Classification scheme */
+	fman_keygen_plan,	/**< Classification plan */
+	fman_keygen_port	/**< Port partition */
+} __packed;
+
+/** KeyGen entry handle */
+struct fman_keygen_entry {
+	struct fman_keygen		*fm_keygen;
+	uint32_t			 ar;
+};
+
+/** Start reading/writing a new KeyGen entry
+ *
+ *  Once a KeyGen entry handle is aquired, use the fm_keygen_in() and fm_keygen_out() to access the
+ *  entry registers and activate the entry using fm_keygen_commit(). In order to abandon an entry
+ *  before activating it and start a new kind of entry use again fm_keygen_entry_start().
+ *
+ *  \par	Example:
+ *
+ *  Here is a partial sequence of code that ilustrates how to program/write a classification scheme:
+ *
+ *  \code
+ *		...
+ *	struct fman_keygen		*keygen;
+ *	struct fman_keygen_entry	*keygen_entry;
+ *		...
+ *	keygen = fm_keygen_create(0xfe4c1000);
+ *		...
+ *	keygen_entry = fm_keygen_entry_start(keygen, false, fman_keygen_scheme, 0);
+ *		...
+ *	/ * Hash based on the IP source and destination addresses and TOS bits * /
+ *	fm_keygen_out(keygen, FM_KEYGEN(SE_EKFC), FM_KEYGEN_EKFC_IPSRC |
+ *						  FM_KEYGEN_EKFC_IPDST |
+ *						  FM_KEYGEN_EKFC_IPTOS);
+ *		...
+ *	fm_keygen_commit(keygen_entry);
+ *		...
+ *	fm_keygen_destroy(keygen);
+ *		...
+ *  \endcode
+ *
+ *  \todo	No memory allocation
+ */
+static inline struct fman_keygen_entry *
+fm_keygen_entry_start(struct fman_keygen		*fm_keygen,	/**< KeyGen handle */
+		      bool				 read,		/**< Read or write  */
+		      enum fman_keygen_entry_type	 type,		/**< Entry type */
+		      uint8_t				 index)		/**< Entry index */
+{
+	struct fman_keygen_entry	*fm_keygen_entry;
+
+	if (fm_keygen->busy == true)
+		return NULL;
+
+	while(fm_keygen_in(fm_keygen, FM_KEYGEN(AR)) & FM_KEYGEN_AR_GO)
+		cpu_relax();
+
+	fm_keygen_entry = (typeof(fm_keygen_entry))kzalloc(sizeof(*fm_keygen_entry), GFP_KERNEL);
+	if (likely(fm_keygen_entry != NULL)) {
+		fm_keygen_entry->fm_keygen = fm_keygen;
+
+		fm_keygen_entry->ar = FM_KEYGEN_AR_GO		|
+				      FM_KEYGEN_AR_SEL(type)	|
+				      FM_KEYGEN_AR_NUM(index);
+		if (read == true) {
+			fm_keygen_entry->ar |= FM_KEYGEN_AR_RW;
+			fm_keygen_out(fm_keygen, FM_KEYGEN(AR), fm_keygen_entry->ar);
+			while (fm_keygen_in(fm_keygen, FM_KEYGEN(AR)) & FM_KEYGEN_AR_GO)
+				cpu_relax();
+		}
+
+		fm_keygen->busy = true;
+	}
+
+	return fm_keygen_entry;
+}
+
+/** Activate the current KeyGen entry
+ *
+ *  \note	For an usage example please see fm_keygen_entry_start()
+ *
+ *  \todo	No memory allocation
+ */
+static inline void fm_keygen_commit(struct fman_keygen_entry *fm_keygen_entry)
+{
+	BUG_ON(fm_keygen_entry->fm_keygen->busy == false);
+
+	if ((fm_keygen_entry->ar & FM_KEYGEN_AR_RW) == 0)	/* Write access type */
+		fm_keygen_out(fm_keygen_entry->fm_keygen, FM_KEYGEN(AR), fm_keygen_entry->ar);
+
+	fm_keygen_entry->fm_keygen->busy = false;
+	kfree(fm_keygen_entry);
+}
+
+/** @} */
+
+enum fm_isr_reg {
+	fm_isr_status,
+	fm_isr_enable
+} __packed;
+
+/** FMan engine code
+ *
+ *  To be used by/with fm_nia() for building the NIA codes for the \ref BMI, \ref KeyGen, etc.
+ */
+enum fm_engine {
+	fm_risc,		/**< RISC */
+	fm_parser = 0x11,	/**< \ref Parser \hideinitializer */
+	fm_keygen,		/**< \ref KeyGen*/
+	fm_policer,		/**< \ref Policer */
+	fm_bmi,			/**< \ref BMI */
+	fm_qmi_enqueue,		/**< \ref QMI */
+	fm_qmi_dequeue		/**< \ref QMI */
+} __packed;
+
+#define FM_NIA_OPR_SHIFT	23
+#define FM_NIA_OPR_MASK		0x00800000
+#define FM_NIA_ENG_SHIFT	18
+#define FM_NIA_ENG_MASK		0x007c0000
+#define FM_NIA_AC_SHIFT		0
+#define FM_NIA_AC_MASK		0x0003ffff
+
+/** Build NIA codes */
+static inline uint32_t fm_nia(bool opr,			/**< Use order preservation */
+			      enum fm_engine eng,	/**< Next engine */
+			      uint32_t ac)		/**< Action code */
+{
+	return (opr	<< FM_NIA_OPR_SHIFT	& FM_NIA_OPR_MASK)	|
+	       (eng	<< FM_NIA_ENG_SHIFT	& FM_NIA_ENG_MASK)	|
+	       (ac	<< FM_NIA_AC_SHIFT	& FM_NIA_AC_MASK);
+}
+
+#endif	/* __FMAN_CONF_H */
diff --git a/drivers/net/dpa/mac-api.c b/drivers/net/dpa/mac-api.c
new file mode 100644
index 0000000..7971a95
--- /dev/null
+++ b/drivers/net/dpa/mac-api.c
@@ -0,0 +1,288 @@
+/* Copyright (C) 2008-2009 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+
+#include "dpa-common.h"
+#include "mac.h"
+
+#include "error_ext.h"	/* GET_ERROR_TYPE, E_OK */
+#include "fm_mac_ext.h"
+
+#define MAC_DESCRIPTION "FSL FMan MAC API based driver"
+
+MODULE_LICENSE("Dual BSD/GPL");
+
+MODULE_AUTHOR("Emil Medve <Emilian.Medve@Freescale.com>");
+
+MODULE_DESCRIPTION(MAC_DESCRIPTION);
+
+struct mac_priv_s {
+	t_Handle	mac;
+};
+
+const char	*mac_driver_description __initconst = MAC_DESCRIPTION;
+const size_t	 mac_sizeof_priv[] __devinitconst = {
+	[DTSEC] = sizeof(struct mac_priv_s),
+	[XGMAC] = sizeof(struct mac_priv_s)
+};
+
+static const e_EnetInterface _100[] __devinitconst =
+{
+	[PHY_INTERFACE_MODE_MII]	= e_ENET_MODE_MII_100,
+	[PHY_INTERFACE_MODE_RMII]	= e_ENET_MODE_RMII_100
+};
+
+static const e_EnetInterface _1000[] __devinitconst =
+{
+	[PHY_INTERFACE_MODE_GMII]	= e_ENET_MODE_GMII_1000,
+	[PHY_INTERFACE_MODE_SGMII]	= e_ENET_MODE_SGMII_1000,
+	[PHY_INTERFACE_MODE_TBI]	= e_ENET_MODE_TBI_1000,
+	[PHY_INTERFACE_MODE_RGMII]	= e_ENET_MODE_RGMII_1000,
+	[PHY_INTERFACE_MODE_RGMII_ID]	= e_ENET_MODE_RGMII_1000,
+	[PHY_INTERFACE_MODE_RGMII_RXID]	= e_ENET_MODE_RGMII_1000,
+	[PHY_INTERFACE_MODE_RGMII_TXID]	= e_ENET_MODE_RGMII_1000,
+	[PHY_INTERFACE_MODE_RTBI]	= e_ENET_MODE_RTBI_1000
+};
+
+static e_EnetInterface __devinit __cold __attribute__((nonnull))
+macdev2enetinterface(const struct mac_device *mac_dev)
+{
+	switch (mac_dev->max_speed) {
+	case SPEED_100:
+		return _100[mac_dev->phy_if];
+	case SPEED_1000:
+		return _1000[mac_dev->phy_if];
+	case SPEED_10000:
+		return e_ENET_MODE_XGMII_10000;
+	default:
+		return e_ENET_MODE_MII_100;
+	}
+}
+
+static void mac_exception(t_Handle _mac_dev, e_FmMacExceptions exceptions, uint32_t events)
+{
+	struct mac_device	*mac_dev;
+
+	mac_dev = (typeof(mac_dev))_mac_dev;
+
+	cpu_dev_dbg(mac_dev->dev, "-> %s:%s()\n", __file__, __func__);
+
+	cpu_dev_dbg(mac_dev->dev, "%s:%s() ->\n", __file__, __func__);
+}
+
+static int __devinit __cold init(struct mac_device *mac_dev)
+{
+	int					_errno;
+	t_Error				err;
+	struct mac_priv_s	*priv;
+	t_FmMacParams		param;
+	uint32_t			version;
+
+	priv = (typeof(priv))macdev_priv(mac_dev);
+
+	param.baseAddr =  (uint64_t)((size_t)(mac_dev->vaddr));
+	param.enetMode	= macdev2enetinterface(mac_dev);
+	memcpy(&param.addr, mac_dev->addr, min(sizeof(param.addr), sizeof(mac_dev->addr)));
+	param.f_Exceptions	= mac_exception;
+	param.h_App		= mac_dev;
+	param.macId		= mac_dev->cell_index;
+    param.h_Fm = (t_Handle)mac_dev->fm;
+
+	priv->mac = FM_MAC_Config(&param);
+	if (unlikely(priv->mac == NULL)) {
+		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_Config() failed\n",
+			    __file__, __LINE__, __func__);
+		_errno = -EINVAL;
+		goto _return;
+	}
+
+	err = FM_MAC_ConfigPadAndCrc(priv->mac, true);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0)) {
+		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_ConfigPadAndCrc() = 0x%08x\n",
+			    __file__, __LINE__, __func__, err);
+		goto _return_fm_mac_free;
+	}
+
+	if (macdev2enetinterface(mac_dev) != e_ENET_MODE_XGMII_10000) {
+		err = FM_MAC_ConfigHalfDuplex(priv->mac, mac_dev->half_duplex);
+		_errno = -GET_ERROR_TYPE(err);
+		if (unlikely(_errno < 0)) {
+			cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_ConfigHalfDuplex() = 0x%08x\n",
+				    __file__, __LINE__, __func__, err);
+			goto _return_fm_mac_free;
+		}
+	}
+
+#ifdef CONFIG_FSL_FMAN_TEST
+	if ((param.enetMode == e_ENET_MODE_XGMII_10000) || param.macId) {
+		err = FM_MAC_ConfigLoopback(priv->mac, true);
+		_errno = -GET_ERROR_TYPE(err);
+		if (unlikely(_errno < 0)) {
+			cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_ConfigLoopback() = 0x%08x\n",
+				    __file__, __LINE__, __func__, err);
+			goto _return_fm_mac_free;
+		}
+	}
+#endif /* CONFIG_FSL_FMAN_TEST */
+
+	err = FM_MAC_Init(priv->mac);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0)) {
+		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_Init() = 0x%08x\n",
+			    __file__, __LINE__, __func__, err);
+		goto _return_fm_mac_reset;
+	}
+
+	err = FM_MAC_GetVesrion(priv->mac, &version);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0)) {
+		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_GetVesrion() = 0x%08x\n",
+			    __file__, __LINE__, __func__, err);
+		goto _return_fm_mac_reset;
+	}
+	cpu_dev_info(mac_dev->dev, "FMan %s version: 0x%08x\n",
+				 ((macdev2enetinterface(mac_dev) != e_ENET_MODE_XGMII_10000) ? "dTSEC" : "XGEC"),
+				 version);
+
+	goto _return;
+
+
+_return_fm_mac_reset:
+	err = FM_MAC_Reset(priv->mac, true);
+	if (unlikely(-GET_ERROR_TYPE(err) < 0))
+		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_Reset() = 0x%08x\n",
+			    __file__, __LINE__, __func__, err);
+_return_fm_mac_free:
+	err = FM_MAC_Free(priv->mac);
+	if (unlikely(-GET_ERROR_TYPE(err) < 0))
+		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_Free() = 0x%08x\n",
+			    __file__, __LINE__, __func__, err);
+_return:
+	return _errno;
+}
+
+static int __cold start(struct mac_device *mac_dev)
+{
+	int	 _errno;
+	t_Error	 err;
+
+	err = FM_MAC_Enable(((struct mac_priv_s *)macdev_priv(mac_dev))->mac,
+			    e_COMM_MODE_RX_AND_TX);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_Enable() = 0x%08x\n",
+			    __file__, __LINE__, __func__, err);
+
+	return _errno;
+}
+
+static int __cold stop(struct mac_device *mac_dev)
+{
+	int	 _errno;
+	t_Error	 err;
+
+	err = FM_MAC_Disable(((struct mac_priv_s *)macdev_priv(mac_dev))->mac,
+			     e_COMM_MODE_RX_AND_TX);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_Disable() = 0x%08x\n",
+			    __file__, __LINE__, __func__, err);
+
+	return _errno;
+}
+
+static int __cold change_promisc(struct mac_device *mac_dev)
+{
+	int	 _errno;
+	t_Error	 err;
+
+	err = FM_MAC_SetPromiscuous(((struct mac_priv_s *)macdev_priv(mac_dev))->mac,
+				    mac_dev->promisc = !mac_dev->promisc);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_SetPromiscuous() = 0x%08x\n",
+			    __file__, __LINE__, __func__, err);
+
+	return _errno;
+}
+
+static int __cold uninit(struct mac_device *mac_dev)
+{
+	int			 _errno, __errno;
+	t_Error			 err;
+	const struct mac_priv_s	*priv;
+
+	priv = (typeof(priv))macdev_priv(mac_dev);
+
+	err = FM_MAC_Reset(priv->mac, true);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_Reset() = 0x%08x\n",
+			    __file__, __LINE__, __func__, err);
+
+	err = FM_MAC_Free(priv->mac);
+	__errno = -GET_ERROR_TYPE(err);
+	if (unlikely(__errno < 0)) {
+		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_Free() = 0x%08x\n",
+			    __file__, __LINE__, __func__, err);
+		if (_errno < 0)
+			_errno = __errno;
+	}
+
+	return _errno;
+}
+
+static void __devinit __cold setup_dtsec(struct mac_device *mac_dev)
+{
+	mac_dev->init		= init;
+	mac_dev->start		= start;
+	mac_dev->stop		= stop;
+	mac_dev->change_promisc	= change_promisc;
+	mac_dev->uninit		= uninit;
+}
+
+static void __devinit __cold setup_xgmac(struct mac_device *mac_dev)
+{
+	mac_dev->init		= init;
+	mac_dev->start		= start;
+	mac_dev->stop		= stop;
+	mac_dev->change_promisc	= change_promisc;
+	mac_dev->uninit		= uninit;
+}
+
+void (*const mac_setup[])(struct mac_device *mac_dev) __devinitconst = {
+	[DTSEC] = setup_dtsec,
+	[XGMAC] = setup_xgmac
+};
diff --git a/drivers/net/dpa/mac.c b/drivers/net/dpa/mac.c
new file mode 100644
index 0000000..af6de21
--- /dev/null
+++ b/drivers/net/dpa/mac.c
@@ -0,0 +1,439 @@
+/* Copyright (C) 2008-2009 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/device.h>
+
+#include "dpa-common.h"
+
+#include "lnxwrp_fm_ext.h"
+
+#include "mac.h"
+
+#define PHY_INTERFACE_MODE_XGMII    (PHY_INTERFACE_MODE_RTBI+1)
+
+static const char phy_str[][11] __devinitconst =
+{
+	[PHY_INTERFACE_MODE_MII]	= "mii",
+	[PHY_INTERFACE_MODE_GMII]	= "gmii",
+	[PHY_INTERFACE_MODE_SGMII]	= "sgmii",
+	[PHY_INTERFACE_MODE_TBI]	= "tbi",
+	[PHY_INTERFACE_MODE_RMII]	= "rmii",
+	[PHY_INTERFACE_MODE_RGMII]	= "rgmii",
+	[PHY_INTERFACE_MODE_RGMII_ID]	= "rgmii-id",
+	[PHY_INTERFACE_MODE_RGMII_RXID]	= "rgmii-rxid",
+	[PHY_INTERFACE_MODE_RGMII_TXID]	= "rgmii-txid",
+	[PHY_INTERFACE_MODE_RTBI]	= "rtbi",
+	[PHY_INTERFACE_MODE_XGMII]	= "xgmii"
+};
+
+static phy_interface_t __devinit __pure __attribute__((nonnull)) str2phy(const char *str)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(phy_str); i++)
+		if (strcmp(str, phy_str[i]) == 0)
+			return (phy_interface_t)i;
+
+	return PHY_INTERFACE_MODE_MII;
+}
+
+static const uint16_t phy2speed[] __devinitconst =
+{
+	[PHY_INTERFACE_MODE_MII]	= SPEED_100,
+	[PHY_INTERFACE_MODE_GMII]	= SPEED_1000,
+	[PHY_INTERFACE_MODE_SGMII]	= SPEED_1000,
+	[PHY_INTERFACE_MODE_TBI]	= SPEED_1000,
+	[PHY_INTERFACE_MODE_RMII]	= SPEED_100,
+	[PHY_INTERFACE_MODE_RGMII]	= SPEED_1000,
+	[PHY_INTERFACE_MODE_RGMII_ID]	= SPEED_1000,
+	[PHY_INTERFACE_MODE_RGMII_RXID]	= SPEED_1000,
+	[PHY_INTERFACE_MODE_RGMII_TXID]	= SPEED_1000,
+	[PHY_INTERFACE_MODE_RTBI]	= SPEED_1000,
+	[PHY_INTERFACE_MODE_XGMII]	= SPEED_10000
+};
+
+static struct mac_device * __devinit __cold
+alloc_macdev(struct device *dev, size_t sizeof_priv, void (*setup)(struct mac_device *mac_dev))
+{
+	struct mac_device	*mac_dev;
+
+	mac_dev = (typeof(mac_dev))devm_kzalloc(dev, sizeof(*mac_dev) + sizeof_priv, GFP_KERNEL);
+	if (likely(mac_dev == NULL))
+		mac_dev = ERR_PTR(-ENOMEM);
+	else {
+		mac_dev->dev = dev;
+		dev_set_drvdata(dev, mac_dev);
+		setup(mac_dev);
+	}
+
+	return mac_dev;
+}
+
+static int __devexit __cold free_macdev(struct mac_device *mac_dev)
+{
+	dev_set_drvdata(mac_dev->dev, NULL);
+
+	return mac_dev->uninit(mac_dev);
+}
+
+static const struct of_device_id mac_match[] __devinitconst = {
+	[DTSEC] = {
+		.compatible	= "fsl,fman-1g-mac"
+	},
+	[XGMAC] = {
+		.compatible	= "fsl,fman-10g-mac"
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, mac_match);
+
+static int __devinit __cold mac_probe(struct of_device *_of_dev, const struct of_device_id *match)
+{
+	int			 _errno, i, lenp;
+	struct device		*dev;
+	struct device_node	*mac_node, *dev_node, *tmp_node;
+	struct mac_device	*mac_dev;
+	struct of_device	*of_dev;
+	struct resource		 res;
+	const uint8_t		*mac_addr;
+	const char		*char_prop;
+	const phandle		*phandle_prop;
+	const uint32_t		*uint32_prop;
+
+	dev = &_of_dev->dev;
+
+	cpu_dev_dbg(dev, "-> %s:%s()\n", __file__, __func__);
+
+	mac_node = _of_dev->node;
+
+	for (i = 0; i < ARRAY_SIZE(mac_match) - 1 && match != mac_match + i; i++);
+	BUG_ON(i >= ARRAY_SIZE(mac_match) - 1);
+
+	mac_dev = alloc_macdev(dev, mac_sizeof_priv[i], mac_setup[i]);
+	if (IS_ERR(mac_dev)) {
+		_errno = PTR_ERR(mac_dev);
+		cpu_dev_err(dev, "%s:%hu:%s(): alloc_macdev() = %d\n",
+			    __file__, __LINE__, __func__, _errno);
+		goto _return;
+	}
+
+	/* Get the FM node */
+	dev_node = of_get_parent(mac_node);
+	if (unlikely(dev_node == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): of_get_parent(%s) failed\n",
+			    __file__, __LINE__, __func__, mac_node->full_name);
+		_errno = -EINVAL;
+		goto _return_dev_set_drvdata;
+	}
+
+	of_dev = of_find_device_by_node(dev_node);
+	if (unlikely(of_dev == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): of_find_device_by_node(%s) failed\n",
+			    __file__, __LINE__, __func__, dev_node->full_name);
+		_errno = -EINVAL;
+		goto _return_of_node_put;
+	}
+
+	mac_dev->fm_dev = fm_bind(&of_dev->dev);
+	if (unlikely(mac_dev->fm_dev == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): fm_bind(%s) failed\n",
+			    __file__, __LINE__, __func__, dev_node->full_name);
+		_errno = -ENODEV;
+		goto _return_of_node_put;
+	}
+
+#ifdef CONFIG_GUEST_PARTITION
+	uint32_prop = of_get_property(dev_node, "cell-index", &lenp);
+	if (unlikely(uint32_prop == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): of_get_property(%s, cell-index) failed\n",
+			    __file__, __LINE__, __func__, dev_node->full_name);
+		_errno = -EINVAL;
+		goto _return;
+	}
+	BUG_ON(lenp != sizeof(uint32_t));
+    mac_dev->fm = (void *)*uint32_prop;
+#else
+    mac_dev->fm = (void *)fm_get_handle(mac_dev->fm_dev);
+#endif /* CONFIG_GUEST_PARTITION */
+	of_node_put(dev_node);
+
+	/* Get the address of the memory mapped registers */
+	_errno = of_address_to_resource(mac_node, 0, &res);
+	if (unlikely(_errno < 0)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): of_address_to_resource(%s) = %d\n",
+			    __file__, __LINE__, __func__, mac_node->full_name, _errno);
+		goto _return_dev_set_drvdata;
+	}
+
+	mac_dev->res = __devm_request_region(
+		dev,
+		fm_get_mem_region(mac_dev->fm_dev),
+		res.start, res.end + 1 - res.start, "mac");
+	if (unlikely(mac_dev->res == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): __devm_request_mem_region(mac) failed\n",
+			    __file__, __LINE__, __func__);
+		_errno = -EBUSY;
+		goto _return_dev_set_drvdata;
+	}
+
+	mac_dev->vaddr = devm_ioremap(dev, mac_dev->res->start,
+				      mac_dev->res->end + 1 - mac_dev->res->start);
+	if (unlikely(mac_dev->vaddr == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): devm_ioremap() failed\n",
+			    __file__, __LINE__, __func__);
+		_errno = -EIO;
+		goto _return_dev_set_drvdata;
+	}
+
+	/* Get the cell-index */
+	uint32_prop = of_get_property(mac_node, "cell-index", &lenp);
+	if (unlikely(uint32_prop == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): of_get_property(%s, cell-index) failed\n",
+			    __file__, __LINE__, __func__, mac_node->full_name);
+		_errno = -EINVAL;
+		goto _return_dev_set_drvdata;
+	}
+	BUG_ON(lenp != sizeof(uint32_t));
+	mac_dev->cell_index = *uint32_prop;
+
+	/* Get the MAC address */
+	mac_addr = of_get_mac_address(mac_node);
+	if (unlikely(mac_addr == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): of_get_mac_address(%s) failed\n",
+			    __file__, __LINE__, __func__, mac_node->full_name);
+		_errno = -EINVAL;
+		goto _return_dev_set_drvdata;
+	}
+	memcpy(mac_dev->addr, mac_addr, sizeof(mac_dev->addr));
+
+	/* Get the port handles */
+	phandle_prop = (typeof(phandle_prop))of_get_property(mac_node, "fsl,port-handles", &lenp);
+	if (unlikely(phandle_prop == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): of_get_property(%s, port-handles) failed\n",
+			    __file__, __LINE__, __func__, mac_node->full_name);
+		_errno = -EINVAL;
+		goto _return_dev_set_drvdata;
+	}
+	BUG_ON(lenp != sizeof(phandle) * ARRAY_SIZE(mac_dev->port_dev));
+
+	for (i = 0; i < ARRAY_SIZE(mac_dev->port_dev); i++) {
+		/* Find the port node */
+		dev_node = of_find_node_by_phandle(phandle_prop[i]);
+		if (unlikely(dev_node == NULL)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): of_find_node_by_phandle() failed\n",
+				    __file__, __LINE__, __func__);
+			_errno = -EINVAL;
+			goto _return_of_node_put;
+		}
+
+		of_dev = of_find_device_by_node(dev_node);
+		if (unlikely(of_dev == NULL)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): of_find_device_by_node(%s) failed\n",
+				    __file__, __LINE__, __func__, dev_node->full_name);
+			_errno = -EINVAL;
+			goto _return_of_node_put;
+		}
+
+		mac_dev->port_dev[i] = fm_port_bind(&of_dev->dev);
+		if (unlikely(mac_dev->port_dev[i] == NULL)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): dev_get_drvdata(%s) failed\n",
+				    __file__, __LINE__, __func__, dev_node->full_name);
+			_errno = -EINVAL;
+			goto _return_of_node_put;
+		}
+		of_node_put(dev_node);
+	}
+
+	/* Get the PHY connection type */
+	char_prop = (typeof(char_prop))of_get_property(mac_node, "phy-connection-type", NULL);
+	if (unlikely(char_prop == NULL)) {
+		cpu_dev_warn(dev, "%s:%hu:%s(): of_get_property(%s, phy-connection-type) "
+			     "failed. Defaulting to MII\n",
+			     __file__, __LINE__, __func__, mac_node->full_name);
+		mac_dev->phy_if = PHY_INTERFACE_MODE_MII;
+	} else
+		mac_dev->phy_if = str2phy(char_prop);
+
+	mac_dev->link		= false;
+	mac_dev->half_duplex	= false;
+	mac_dev->speed		= phy2speed[mac_dev->phy_if];
+	mac_dev->max_speed	= mac_dev->speed;
+
+	/* Get the rest of the PHY information */
+	phandle_prop = (typeof(phandle_prop))of_get_property(mac_node, "phy-handle", &lenp);
+	if (unlikely(phandle_prop == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): of_get_property(%s, phy-handle) failed\n",
+			    __file__, __LINE__, __func__, mac_node->full_name);
+		_errno = -EINVAL;
+		goto _return_dev_set_drvdata;
+	}
+	BUG_ON(lenp != sizeof(phandle));
+
+	/* Find the PHY node */
+	dev_node = of_find_node_by_phandle(*phandle_prop);
+	if (unlikely(dev_node == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): of_find_node_by_phandle() failed\n",
+			    __file__, __LINE__, __func__);
+		_errno = -EINVAL;
+		goto _return_dev_set_drvdata;
+	}
+
+	/* Get the PHY interface/device address */
+	uint32_prop = (typeof(uint32_prop))of_get_property(dev_node, "reg", &lenp);
+	if (unlikely(uint32_prop == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): of_get_property(%s, reg) failed\n",
+			    __file__, __LINE__, __func__, dev_node->full_name);
+		_errno = -EINVAL;
+		goto _return_of_node_put;
+	}
+	BUG_ON(lenp != sizeof(uint32_t));
+
+	/* Get the MDIO bus */
+	tmp_node = of_get_parent(dev_node);
+	if (unlikely(tmp_node == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): of_get_parent(%s) failed\n",
+			    __file__, __LINE__, __func__, dev_node->full_name);
+		_errno = -EINVAL;
+		goto _return_of_node_put;
+	}
+	of_node_put(dev_node);
+	dev_node = tmp_node;
+
+	/* Get the MDIO bus address */
+	_errno = of_address_to_resource(dev_node, 0, &res);
+	if (unlikely(_errno < 0)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): of_address_to_resource(%s) = %d\n",
+			    __file__, __LINE__, __func__, dev_node->full_name, _errno);
+		goto _return_of_node_put;
+	}
+	of_node_put(dev_node);
+
+	/* Build the PHY id/address */
+	_errno = snprintf(mac_dev->phy_id, sizeof(mac_dev->phy_id), "%llx:%02x",
+			  res.start, *uint32_prop);
+	if (unlikely(_errno < 0 || _errno >= sizeof(mac_dev->phy_id))) {
+		cpu_dev_err(dev, "%s:%hu:%s(): snprintf() = %d\n",
+			    __file__, __LINE__, __func__, _errno);
+		if (_errno > 0)
+			_errno = -ENOBUFS;
+		goto _return_dev_set_drvdata;
+	}
+
+	_errno = mac_dev->init(mac_dev);
+	if (unlikely(_errno < 0)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): mac_dev->init() = %d\n",
+			    __file__, __LINE__, __func__, _errno);
+		goto _return_dev_set_drvdata;
+	}
+
+	cpu_dev_info(dev, "FMan MAC address: %02hx:%02hx:%02hx:%02hx:%02hx:%02hx\n",
+		     mac_dev->addr[0], mac_dev->addr[1], mac_dev->addr[2],
+		     mac_dev->addr[3], mac_dev->addr[4], mac_dev->addr[5]);
+
+	goto _return;
+
+_return_of_node_put:
+	of_node_put(dev_node);
+_return_dev_set_drvdata:
+	dev_set_drvdata(dev, NULL);
+_return:
+	cpu_dev_dbg(dev, "%s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+
+static int __devexit __cold mac_remove(struct of_device *of_dev)
+{
+	int		i, _errno;
+	struct device	*dev;
+	struct mac_device *mac_dev;
+
+	dev = &of_dev->dev;
+	mac_dev = (struct mac_device *)dev_get_drvdata(dev);
+
+	cpu_dev_dbg(dev, "-> %s:%s()\n", __file__, __func__);
+
+	for (i = 0; i < ARRAY_SIZE(mac_dev->port_dev); i++)
+		fm_port_unbind(mac_dev->port_dev[i]);
+
+	fm_unbind(mac_dev->fm_dev);
+
+	_errno = free_macdev(mac_dev);
+
+	cpu_dev_dbg(dev, "%s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+
+static struct of_platform_driver mac_driver = {
+	.name		= KBUILD_MODNAME,
+	.match_table	= mac_match,
+	.owner		= THIS_MODULE,
+	.probe		= mac_probe,
+	.remove		= __devexit_p(mac_remove)
+};
+
+static int __init __cold mac_load(void)
+{
+	int	 _errno;
+
+	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
+
+	cpu_pr_info(KBUILD_MODNAME ": %s (" VERSION ")\n", mac_driver_description);
+
+	_errno = of_register_platform_driver(&mac_driver);
+	if (unlikely(_errno < 0)) {
+		cpu_pr_err(KBUILD_MODNAME ": %s:%hu:%s(): of_register_platform_driver() = %d\n",
+			   __file__, __LINE__, __func__, _errno);
+		goto _return;
+	}
+
+	goto _return;
+
+_return:
+	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+module_init(mac_load);
+
+static void __exit __cold mac_unload(void)
+{
+	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
+
+	of_unregister_platform_driver(&mac_driver);
+
+	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
+}
+module_exit(mac_unload);
diff --git a/drivers/net/dpa/mac.h b/drivers/net/dpa/mac.h
new file mode 100644
index 0000000..c95cb18
--- /dev/null
+++ b/drivers/net/dpa/mac.h
@@ -0,0 +1,80 @@
+/* Copyright (C) 2008-2009 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __MAC_H
+#define __MAC_H
+
+#include <linux/device.h>	/* struct device, BUS_ID_SIZE */
+#include <linux/if_ether.h>	/* ETH_ALEN */
+#include <linux/phy.h>		/* phy_interface_t, struct phy_device */
+
+#include "fsl_fman.h"		/* struct port_device */
+
+enum {DTSEC, XGMAC};
+
+struct mac_device {
+	struct device		*dev;
+	void			*priv;
+	uint8_t			 cell_index;
+	struct resource		*res;
+	void			*vaddr;
+	uint8_t			 addr[ETH_ALEN];
+	bool			 promisc;
+
+	struct fm		*fm_dev;
+	struct fm_port	*port_dev[2];
+
+	phy_interface_t		 phy_if;
+	bool			 link;
+	bool			 half_duplex;
+	uint16_t		 speed;
+	uint16_t		 max_speed;
+	char			 phy_id[BUS_ID_SIZE];
+	struct phy_device	*phy_dev;
+    void			*fm;
+
+	int (*init)(struct mac_device *mac_dev);
+	int (*start)(struct mac_device *mac_dev);
+	int (*stop)(struct mac_device *mac_dev);
+	int (*change_promisc)(struct mac_device *mac_dev);
+	int (*uninit)(struct mac_device *mac_dev);
+};
+
+static inline void * __attribute((nonnull)) macdev_priv(const struct mac_device *mac_dev)
+{
+	return (void *)mac_dev + sizeof(*mac_dev);
+}
+
+extern const char	*mac_driver_description;
+extern const size_t	 mac_sizeof_priv[];
+extern void (*const mac_setup[])(struct mac_device *mac_dev);
+
+#endif	/* __MAC_H */
diff --git a/drivers/net/dpa/port-wrapper.c b/drivers/net/dpa/port-wrapper.c
new file mode 100644
index 0000000..6088824
--- /dev/null
+++ b/drivers/net/dpa/port-wrapper.c
@@ -0,0 +1,299 @@
+/* Copyright (C) 2008-2009 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/io.h>		/* in_be32() */
+#include <linux/of_platform.h>
+
+#include "dpa-common.h"
+#include "fm.h"			/* fmdev_priv() */
+#include "fm-wrapper.h"		/* struct fm_priv_s */
+#include "port.h"
+
+#include "fm_common.h"		/* BASE_RX/TX_PORTID */
+#include "lnxwrp_fm.h"		/* t_LnxWrpFmPortDev */
+#include "lnxwrp_fm_ext.h"
+
+#define PORT_DESCRIPTION "FSL FMan port wrapper based driver"
+
+MODULE_LICENSE("Dual BSD/GPL");
+
+MODULE_AUTHOR("Emil Medve <Emilian.Medve@Freescale.com>");
+
+MODULE_DESCRIPTION(PORT_DESCRIPTION);
+
+struct port_priv_s {
+	t_LnxWrpFmPortDev		*port;
+	t_SysObjectAdvConfigEntry	 config[FM_MAX_NUM_OF_ADV_SETTINGS];
+};
+
+struct rx_priv_s {
+	struct port_priv_s	port;
+	fm_port_rx_params_t	param;
+};
+
+struct tx_priv_s {
+	struct port_priv_s	port;
+	fm_port_non_rx_params_t	param;
+};
+
+const char	*port_driver_description __initconst = PORT_DESCRIPTION;
+const size_t	 port_sizeof_priv[] __devinitconst = {
+	[RX] = sizeof(struct rx_priv_s),
+	[TX] = sizeof(struct tx_priv_s)
+};
+
+/* RX */
+
+static int __devinit __cold __attribute__((nonnull))
+init(const struct port_device *port_dev, uint8_t logical_index)
+{
+	struct port_priv_s	*priv;
+
+	priv = (typeof(priv))portdev_priv(port_dev);
+
+	priv->port->id		= logical_index;
+	priv->port->baseAddr	= (typeof(priv->port->baseAddr))port_dev->vaddr;
+	priv->port->memSize	= port_dev->res->end + 1 - port_dev->res->start;
+
+	priv->port->settings.param.fmId		= port_dev->fm_dev->cell_index;
+	priv->port->settings.param.portId	= logical_index;
+	priv->port->settings.param.h_App	= priv->port;
+
+	priv->port->settings.advConfig		= priv->config;
+
+	priv->port->h_LnxWrpFmDev	= &((struct fm_priv_s *)fmdev_priv(port_dev->fm_dev))->fm;
+
+	return 0;
+}
+
+static int __devinit __cold init_rx(struct port_device *port_dev)
+{
+	struct rx_priv_s	*priv;
+	uint8_t			 logical_index;
+
+	priv = (typeof(priv))portdev_priv(port_dev);
+
+	logical_index = port_dev->cell_index - BASE_RX_PORTID;
+	priv->port.port =
+		((struct fm_priv_s *)fmdev_priv(port_dev->fm_dev))->fm.rxPorts + logical_index;
+
+	priv->port.port->settings.param.portType	= e_FM_PORT_TYPE_RX;
+
+	/* Ugly hack! */
+	priv->port.port->settings.param.specificParams.rxParams.rxPartitionId	=
+		in_be32(port_dev->fm_dev->vaddr + 0x80000 + 0x300 +
+			sizeof(uint32_t) * port_dev->cell_index);
+
+	priv->param.priv_data_size	= 16;
+	priv->param.parse_results	= true;
+
+	priv->port.port->defPcd	= e_FM_PCD_PARSE_RESULTS;
+
+	return init(port_dev, logical_index);
+}
+
+static int __cold __attribute__((nonnull)) _init_rx(const struct port_device *port_dev)
+{
+	const struct rx_priv_s	*priv;
+
+	priv = (typeof(priv))portdev_priv(port_dev);
+
+	priv->port.port->active	= true;
+
+	fm_set_rx_port_params(priv->port.port, &priv->param);
+
+	return 0;
+}
+
+static int __devinit __cold set_default_fq_rx(struct port_device *port_dev, uint32_t fq)
+{
+	((struct rx_priv_s *)portdev_priv(port_dev))->param.defq = fq;
+	return 0;
+}
+
+static int __devinit __cold set_error_fq_rx(struct port_device *port_dev, uint32_t fq)
+{
+	((struct rx_priv_s *)portdev_priv(port_dev))->param.errq = fq;
+	return 0;
+}
+
+static int __devinit __cold
+set_bp_info_rx(struct port_device *port_dev, const struct port_bp_info *bp_info, uint8_t count)
+{
+	int			 i;
+	struct rx_priv_s	*priv;
+
+	priv = (typeof(priv))portdev_priv(port_dev);
+
+	priv->param.num_pools = min(count, (typeof(count))ARRAY_SIZE(priv->param.pool_param));
+	for (i = 0; i < priv->param.num_pools; i++) {
+		priv->param.pool_param[i].id	= bp_info[i].bpid;
+		priv->param.pool_param[i].size	= bp_info[i].size;
+	}
+
+	return 0;
+}
+
+static int __cold start_rx(struct port_device *port_dev)
+{
+	int			 _errno;
+	const struct rx_priv_s	*priv;
+
+	priv = (typeof(priv))portdev_priv(port_dev);
+
+	if (unlikely(!priv->port.port->active)) {
+		_errno = _init_rx(port_dev);
+		if (unlikely(_errno < 0))
+			goto _return;
+	}
+
+	fm_port_enable(priv->port.port);
+	_errno = 0;
+
+_return:
+	return _errno;
+}
+
+static int __cold stop(struct port_device *port_dev)
+{
+	fm_port_disable(((struct port_priv_s *)portdev_priv(port_dev))->port);
+	return 0;
+}
+
+#ifdef CONFIG_BUG
+static uint8_t get_lpid(const struct port_device *port_dev)
+{
+	return port_dev->fm_dev->cell_index << 6 | port_dev->cell_index;
+}
+#endif
+
+/* TX */
+
+static int __devinit __cold init_tx(struct port_device *port_dev)
+{
+	struct tx_priv_s	*priv;
+	uint8_t			 logical_index;
+
+	priv = (typeof(priv))portdev_priv(port_dev);
+
+	logical_index = port_dev->cell_index - BASE_TX_PORTID;
+	priv->port.port =
+		((struct fm_priv_s *)fmdev_priv(port_dev->fm_dev))->fm.txPorts + logical_index;
+
+	priv->port.port->settings.param.portType = e_FM_PORT_TYPE_TX;
+
+	priv->port.port->settings.param.specificParams.nonRxParams.deqSubPortal	=
+		port_dev->channel & 0xf;
+
+	priv->port.port->defPcd	= e_NO_PCD;
+
+	return init(port_dev, logical_index);
+}
+
+static int __cold __attribute__((nonnull)) _init_tx(const struct port_device *port_dev)
+{
+	const struct tx_priv_s	*priv;
+
+	priv = (typeof(priv))portdev_priv(port_dev);
+
+	priv->port.port->active	= true;
+
+	fm_set_tx_port_params(priv->port.port, &priv->param);
+
+	return 0;
+}
+
+static int __devinit __cold set_default_fq_tx(struct port_device *port_dev, uint32_t fq)
+{
+	((struct tx_priv_s *)portdev_priv(port_dev))->param.defq = fq;
+	return 0;
+}
+
+static int __devinit __cold set_error_fq_tx(struct port_device *port_dev, uint32_t fq)
+{
+	((struct tx_priv_s *)portdev_priv(port_dev))->param.errq = fq;
+	return 0;
+}
+
+static int __cold start_tx(struct port_device *port_dev)
+{
+	int			 _errno;
+	const struct tx_priv_s	*priv;
+
+	priv = (typeof(priv))portdev_priv(port_dev);
+
+	if (unlikely(!priv->port.port->active)) {
+		_errno = _init_tx(port_dev);
+		if (unlikely(_errno < 0))
+			goto _return;
+	}
+
+	fm_port_enable(priv->port.port);
+	_errno = 0;
+
+_return:
+	return _errno;
+}
+
+static void __devinit __cold setup_rx(struct port_device *port_dev)
+{
+	port_dev->init			= init_rx;
+	port_dev->start			= start_rx;
+	port_dev->stop			= stop;
+	port_dev->set_default_fq	= set_default_fq_rx;
+	port_dev->set_error_fq		= set_error_fq_rx;
+	port_dev->set_bp_info		= set_bp_info_rx;
+#ifdef CONFIG_BUG
+	port_dev->get_lpid		= get_lpid;
+#endif
+	port_dev->uninit		= NULL;
+}
+
+static void __devinit __cold setup_tx(struct port_device *port_dev)
+{
+	port_dev->init			= init_tx;
+	port_dev->start			= start_tx;
+	port_dev->stop			= stop;
+	port_dev->set_default_fq	= set_default_fq_tx;
+	port_dev->set_error_fq		= set_error_fq_tx;
+	port_dev->set_bp_info		= NULL;
+#ifdef CONFIG_BUG
+	port_dev->get_lpid		= NULL;
+#endif
+	port_dev->uninit		= NULL;
+}
+
+void (*const port_setup[])(struct port_device *port_dev) __devinitconst = {
+	[RX] = setup_rx,
+	[TX] = setup_tx
+};
diff --git a/drivers/net/dpa/port.c b/drivers/net/dpa/port.c
new file mode 100644
index 0000000..defe101
--- /dev/null
+++ b/drivers/net/dpa/port.c
@@ -0,0 +1,252 @@
+/* Copyright (C) 2008-2009 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/device.h>
+#include <linux/io.h>		/* devm_ioremap() */
+
+#include "dpa-common.h"
+#include "port.h"
+
+static struct port_device * __devinit __cold
+alloc_portdev(struct device *dev, size_t sizeof_priv, void (*setup)(struct port_device *port_dev))
+{
+	struct port_device	*port_dev;
+
+	port_dev = (typeof(port_dev))devm_kzalloc(dev, sizeof(*port_dev) + sizeof_priv, GFP_KERNEL);
+	if (likely(port_dev == NULL))
+		port_dev = ERR_PTR(-ENOMEM);
+	else {
+		port_dev->dev = dev;
+		dev_set_drvdata(dev, port_dev);
+		setup(port_dev);
+	}
+
+	return port_dev;
+}
+
+static int __devexit __cold free_portdev(struct port_device *port_dev)
+{
+	dev_set_drvdata(port_dev->dev, NULL);
+
+	return likely(port_dev->uninit) ? port_dev->uninit(port_dev) : 0;
+}
+
+static const struct of_device_id port_match[] __devinitconst = {
+	[RX] = {
+		.compatible	= "fsl,fman-port-rx"
+	},
+	[TX] = {
+		.compatible	= "fsl,fman-port-tx"
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, port_match);
+
+static const char port_type[][8] __devinitconst = {
+	[RX] = "port-rx",
+	[TX] = "port-tx"
+};
+
+static int __devinit __cold port_probe(struct of_device *_of_dev, const struct of_device_id *match)
+{
+	int			 _errno, i, lenp;
+	struct device		*dev;
+	struct device_node	*port_node, *fm_node;
+	struct port_device	*port_dev;
+	struct of_device	*of_dev;
+	struct resource		 res;
+	const uint32_t		*uint32_prop;
+
+	dev = &_of_dev->dev;
+
+	cpu_dev_dbg(dev, "-> %s:%s()\n", __file__, __func__);
+
+	port_node = _of_dev->node;
+
+	for (i = 0; i < ARRAY_SIZE(port_match) - 1 && match != port_match + i; i++);
+	BUG_ON(i >= ARRAY_SIZE(port_match) - 1);
+
+	port_dev = alloc_portdev(dev, port_sizeof_priv[i], port_setup[i]);
+	if (IS_ERR(port_dev)) {
+		_errno = PTR_ERR(port_dev);
+		cpu_dev_err(dev, "%s:%hu:%s(): alloc_portdev() = %d\n",
+			    __file__, __LINE__, __func__, _errno);
+		goto _return;
+	}
+
+	/* Get the FM node */
+	fm_node = of_get_parent(port_node);
+	if (unlikely(fm_node == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): of_get_parent(%s) failed\n",
+			    __file__, __LINE__, __func__, port_node->full_name);
+		_errno = -EINVAL;
+		goto _return_dev_set_drvdata;
+	}
+
+	of_dev = of_find_device_by_node(fm_node);
+	if (unlikely(of_dev == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): of_find_device_by_node(%s) failed\n",
+			    __file__, __LINE__, __func__, fm_node->full_name);
+		of_node_put(fm_node);
+		_errno = -EINVAL;
+		goto _return_dev_set_drvdata;
+	}
+	of_node_put(fm_node);
+
+	port_dev->fm_dev = (typeof(port_dev->fm_dev))dev_get_drvdata(&of_dev->dev);
+	BUG_ON(port_dev->fm_dev == NULL);
+
+	/* Get the address of the memory mapped registers */
+	_errno = of_address_to_resource(port_node, 0, &res);
+	if (unlikely(_errno < 0)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): of_address_to_resource(%s) = %d\n",
+			    __file__, __LINE__, __func__, port_node->full_name, _errno);
+		goto _return_dev_set_drvdata;
+	}
+
+	port_dev->res = __devm_request_region(dev, port_dev->fm_dev->res,
+					      res.start, res.end + 1 - res.start, port_type[i]);
+	if (unlikely(port_dev->res == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): __devm_request_mem_region(port) failed\n",
+			    __file__, __LINE__, __func__);
+		_errno = -EBUSY;
+		goto _return_dev_set_drvdata;
+	}
+
+	port_dev->vaddr = devm_ioremap(dev, port_dev->res->start,
+				       port_dev->res->end + 1 - port_dev->res->start);
+	if (unlikely(port_dev->vaddr == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): devm_ioremap() failed\n",
+			    __file__, __LINE__, __func__);
+		_errno = -EIO;
+		goto _return_dev_set_drvdata;
+	}
+
+	uint32_prop = (typeof(uint32_prop))of_get_property(port_node, "cell-index", &lenp);
+	if (unlikely(uint32_prop == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): of_get_property(%s, cell-index) failed\n",
+			    __file__, __LINE__, __func__, port_node->full_name);
+		_errno = -EINVAL;
+		goto _return_dev_set_drvdata;
+	}
+	BUG_ON(lenp != sizeof(uint32_t));
+	port_dev->cell_index = *uint32_prop;
+
+	if (match != port_match + RX) {
+		uint32_prop = (typeof(uint32_prop))of_get_property(port_node,
+								   "fsl,qman-channel-id", &lenp);
+		if (unlikely(uint32_prop == NULL)) {
+			cpu_dev_err(dev, "%s:%hu:%s(): of_get_property(%s, fsl,qman-channel-id) failed\n",
+				    __file__, __LINE__, __func__, port_node->full_name);
+			_errno = -EINVAL;
+			goto _return_dev_set_drvdata;
+		}
+		BUG_ON(lenp != sizeof(uint32_t));
+		port_dev->channel = *uint32_prop;
+	}
+
+	_errno = port_dev->init(port_dev);
+	if (unlikely(_errno < 0)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): port_dev->init() = %d\n",
+			    __file__, __LINE__, __func__, _errno);
+		goto _return_dev_set_drvdata;
+	}
+
+	goto _return;
+
+_return_dev_set_drvdata:
+	dev_set_drvdata(dev, NULL);
+_return:
+	cpu_dev_dbg(dev, "%s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+
+static int __devexit __cold port_remove(struct of_device *of_dev)
+{
+	int		 _errno;
+	struct device	*dev;
+
+	dev = &of_dev->dev;
+
+	cpu_dev_dbg(dev, "-> %s:%s()\n", __file__, __func__);
+
+	_errno = free_portdev((struct port_device *)dev_get_drvdata(dev));
+
+	cpu_dev_dbg(dev, "%s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+
+static struct of_platform_driver port_driver = {
+	.name		= KBUILD_MODNAME,
+	.match_table	= port_match,
+	.owner		= THIS_MODULE,
+	.probe		= port_probe,
+	.remove		= __devexit_p(port_remove)
+};
+
+static int __init __cold port_load(void)
+{
+	int	 _errno;
+
+	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
+
+	cpu_pr_info(KBUILD_MODNAME ": %s (" VERSION ")\n", port_driver_description);
+
+	_errno = of_register_platform_driver(&port_driver);
+	if (unlikely(_errno < 0)) {
+		cpu_pr_err(KBUILD_MODNAME ": %s:%hu:%s(): of_register_platform_driver() = %d\n",
+			   __file__, __LINE__, __func__, _errno);
+		goto _return;
+	}
+
+	goto _return;
+
+_return:
+	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
+
+	return _errno;
+}
+module_init(port_load);
+
+static void __exit __cold port_unload(void)
+{
+	cpu_pr_debug(KBUILD_MODNAME ": -> %s:%s()\n", __file__, __func__);
+
+	of_unregister_platform_driver(&port_driver);
+
+	cpu_pr_debug(KBUILD_MODNAME ": %s:%s() ->\n", __file__, __func__);
+}
+module_exit(port_unload);
diff --git a/drivers/net/dpa/port.h b/drivers/net/dpa/port.h
new file mode 100644
index 0000000..69e6334
--- /dev/null
+++ b/drivers/net/dpa/port.h
@@ -0,0 +1,76 @@
+/* Copyright (c) 2008, Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __PORT_H
+#define __PORT_H
+
+#include <linux/device.h>	/* struct device */
+
+#include "fm.h"			/* struct fm_device */
+
+struct port_bp_info {
+	uint8_t	bpid;
+	size_t	size;
+};
+
+struct port_device {
+	struct device		*dev;
+	void			*priv;
+	uint8_t			 cell_index;
+	struct resource		*res;
+	void			*vaddr;
+	uint16_t		 channel;
+
+	struct fm_device	*fm_dev;
+
+	int (*init)(struct port_device *port_dev);
+	int (*set_default_fq)(struct port_device *port_dev, uint32_t fq);
+	int (*set_error_fq)(struct port_device *port_dev, uint32_t fq);
+	int (*set_bp_info)(struct port_device *port_dev, const struct port_bp_info *bp_info, uint8_t count);
+	int (*start)(struct port_device *port_dev);
+	int (*stop)(struct port_device *port_dev);
+#ifdef CONFIG_BUG
+	uint8_t (*get_lpid)(const struct port_device *port_dev);
+#endif
+	int (*uninit)(struct port_device *port_dev);
+};
+
+static inline void * __attribute((nonnull)) portdev_priv(const struct port_device *port_dev)
+{
+	return (void *)port_dev + sizeof(*port_dev);
+}
+
+extern const char	*port_driver_description;
+extern const size_t	 port_sizeof_priv[];
+extern void (*const port_setup[])(struct port_device *port_dev);
+
+#endif	/* __PORT_H */
-- 
1.6.5.2

