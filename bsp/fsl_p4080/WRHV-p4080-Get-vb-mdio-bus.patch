From 954f1a99a03040e448db05c686a1764125ccc74e Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Thu, 1 Jul 2010 22:08:38 -0700
Subject: [PATCH] WRHV/p4080: Get vb mdio bus

For P4080 The hypervisor needs to know which FMAN and which DTSEC you are
trying to access via the MDIO as the access functions need that information.
This information should be encoded into the "bus" element of the MDIO_MSG
struct.

fman 4 bits  0-1
dtsec 4 bits 0-3

0x000000<fman><dtsec>

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/platforms/85xx/wrhv_p4080_ds.c |   77 +++++++++++++++++++++++++++
 1 files changed, 77 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/platforms/85xx/wrhv_p4080_ds.c b/arch/powerpc/platforms/85xx/wrhv_p4080_ds.c
index 44e3596..fed49fc 100644
--- a/arch/powerpc/platforms/85xx/wrhv_p4080_ds.c
+++ b/arch/powerpc/platforms/85xx/wrhv_p4080_ds.c
@@ -56,6 +56,82 @@ static int primary_phb_addr;
 extern void __init wrhv_smp_init(void);
 #endif
 
+/*
+ * The hypervisor needs to know which FMAN and which DTSEC you
+ * are trying to access via the MDIO as the access functions
+ * need that information.
+ * This information should be encoded into the "bus" element
+ * of the MDIO_MSG struct.
+
+ * fman 4 bits  0-1
+ * dtsec 4 bits 0-3
+
+ * 0x000000<fman><dtsec>
+ */
+static uint32_t p4080_mdio_bus[PHY_MAX_ADDR];
+
+static int __init p4080_mdio_bus_init(void)
+{
+	struct device_node *np, *phy_np;
+	int i, j;
+	uint32_t bus = 0;
+	char *mdio_bus[] = {
+			"/soc@fe000000/fman@400000/ethernet@e0000",
+			"/soc@fe000000/fman@400000/ethernet@e2000",
+			"/soc@fe000000/fman@400000/ethernet@e4000",
+			"/soc@fe000000/fman@400000/ethernet@e6000",
+			"/soc@fe000000/fman@500000/ethernet@e0000",
+			"/soc@fe000000/fman@500000/ethernet@e2000",
+			"/soc@fe000000/fman@500000/ethernet@e4000",
+			"/soc@fe000000/fman@500000/ethernet@e6000",
+	};
+
+	for (i = 0; i < PHY_MAX_ADDR; i++) {
+		for_each_compatible_node(np, NULL, "fsl,p4080-fman-1g-mac") {
+			const u32 *phandle;
+			const u32 *reg;
+
+			phandle = of_get_property(np, "phy-handle", NULL);
+			phy_np = of_find_node_by_phandle(*phandle);
+			reg = of_get_property(phy_np, "reg", NULL);
+			if (reg && (*reg == i))
+				break;
+		}
+		if (!np) {
+			bus = 0;
+			goto get_bus;
+		}
+
+		for (j = 0; j < ARRAY_SIZE(mdio_bus); j++) {
+			if (!(strcmp(np->full_name,  mdio_bus[j]))) {
+				bus = j;
+				/*
+				 * mask fman1
+				*/
+				if (j > 3) {
+					bus -= 4;
+					bus |= 1 << 4;
+				}
+				break;
+			}
+		}
+
+get_bus:
+		p4080_mdio_bus[i] = bus;
+	}
+
+	return 0;
+}
+subsys_initcall(p4080_mdio_bus_init);
+
+uint32_t p4080_get_vb_mdio_bus(struct mii_bus *mii_bus, int addr)
+{
+	if (addr > PHY_MAX_ADDR)
+		return -1;
+
+	return p4080_mdio_bus[addr];
+}
+
 static void __init mpc85xx_ds_setup_arch(void)
 {
 #ifdef CONFIG_PCI
@@ -230,4 +306,5 @@ define_machine(p4080_ds) {
 	.set_law_base		= wrhv_set_law_base,
 	.set_law_attr		= wrhv_set_law_attr,
 	.get_law_attr		= wrhv_get_law_attr,
+	.get_mdio_bus		= p4080_get_vb_mdio_bus,
 };
-- 
1.6.5.2

