From 25f5ea2704e83f76dbc27db639ddb0ec6949a6a1 Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Sat, 23 Jan 2010 05:48:14 -0500
Subject: [PATCH 128/148] qman: run-time workarounds for rev1 errata

Detects Qman IP revision at run-time and keys errata workarounds off it. If CCSR
is available (control-plane) then this determines the revision level otherwise
the compatible property of portal nodes is checked for a revision-specific
string, finaly defaulting to rev1 (with a logged warning). If CCSR is available
and portal nodes also specify the revision, these are compared to ensure they
agree.

This also corrects the following;
* the need to initialise CGR is not an erratum, it's defined behaviour for all
  versions going forward.
* copyrights updated to 2010.
* old cycle-accurate limitations no longer apply (and were never errata, so
  remove the options to eliminate rev1/rev2 confusion).

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Signed-off-by: Jeffrey Ladouceur <Jeffrey.Ladouceur@freescale.com>
Signed-off-by: Paul Barrette <paul.barrette@freescale.com>
[Cleanly applied the FSL SDK 2.0.3 patch:
"P4080-b2.0.2-qman-run-time-workarounds-for-rev1-errata.patch"]
Integrated-by: Yuri Nedel <Yuri.Nedel@windriver.com>
---
 drivers/hwqueue/Kconfig          |   60 ++++++-------------------
 drivers/hwqueue/qman_config.c    |   29 +++++++-----
 drivers/hwqueue/qman_driver.c    |   45 +++++++++++++++---
 drivers/hwqueue/qman_high.c      |   18 ++++---
 drivers/hwqueue/qman_low.c       |   91 +++++++++++++++++++++++++++++++++++---
 drivers/hwqueue/qman_private.h   |   28 +++++++++++-
 drivers/hwqueue/qman_test_high.c |    2 -
 drivers/hwqueue/qman_test_low.c  |   40 -----------------
 8 files changed, 189 insertions(+), 124 deletions(-)

diff --git a/drivers/hwqueue/Kconfig b/drivers/hwqueue/Kconfig
index c5212ea..63795e1 100644
--- a/drivers/hwqueue/Kconfig
+++ b/drivers/hwqueue/Kconfig
@@ -23,6 +23,20 @@ config FSL_QMAN_PORTAL
 	  Compiles support to detect and support Qman software corenet portals
 	  (as provided by the device-tree).
 
+config FSL_QMAN_BUG_AND_FEATURE_REV1
+	bool "workarounds for errata and missing features in p4080 rev1"
+	depends on FSL_QMAN_PORTAL
+	default y
+	---help---
+	  If this option is selected, the driver will be compiled with
+	  workarounds for errata as well as feature limitations (relative to
+	  more recent parts) of p4080 rev1. On unaffected revisions, this
+	  support incurs only a negligable overhead, typically only a couple of
+	  instructions per non-fast-path operation (the fast-path operations are
+	  unaffected).
+
+	  If in doubt, say Y.
+
 # The current driver is interrupt-driven only (poll-driven isn't yet supported).
 config FSL_QMAN_HAVE_POLL
 	bool
@@ -76,16 +90,6 @@ config FSL_QMAN_CONFIG
 	  linux image is running as a guest OS under the hypervisor, only one
 	  guest OS ("the control plane") needs this option.
 
-config FSL_QMAN_BUG_CGR_INIT
-	bool "workaround early-silicon h/w bug"
-	depends on FSL_QMAN_CONFIG && !FSL_QMAN_PORTAL_DISABLEAUTO
-	default y
-	---help---
-	  Only an early revision of Qman h/w, s/w must explicitly initialise all
-	  CGR memories to avoid a possible ECC error. This workaround will
-	  perform the required initialisation on boot, and has no side-effects
-	  thereafter. If in doubt, select Yes.
-
 config FSL_QMAN_TEST
 	tristate "Qman self-tests"
 	depends on FSL_QMAN_PORTAL
@@ -110,22 +114,6 @@ config FSL_QMAN_TEST_LOW
 	  This takes an unused portal and portal and performs low-level
 	  API testing with it.
 
-config FSL_QMAN_TEST_LOW_BUG_INTERRUPTS
-	bool "ignore interrupts and interrupt registers"
-	depends on FSL_QMAN_TEST_LOW
-	default n
-	---help---
-	  Certain versions of the cycle-accurate model don't support portal
-	  interrupt lines or the associated registers.
-
-config FSL_QMAN_TEST_LOW_BUG_STASHING
-	bool "disable dequeue stashing (of DQRR and data/context)"
-	depends on FSL_QMAN_TEST_LOW
-	default n
-	---help---
-	  Support for DQRR stashing with the cycle-accurate model is still
-	  experimental.
-
 config FSL_QMAN_TEST_HIGH
 	bool "Qman high-level self-test"
 	depends on FSL_QMAN_TEST && !FSL_QMAN_PORTAL_DISABLEAUTO
@@ -135,14 +123,6 @@ config FSL_QMAN_TEST_HIGH
 	  high-level API testing with them (whichever portal(s) are affine to
 	  the cpu(s) the test executes on).
 
-config FSL_QMAN_TEST_HIGH_BUG_VDQCR
-	bool "don't test VDQCR"
-	depends on FSL_QMAN_TEST_HIGH
-	default n
-	---help---
-	  Certain (current) versions of the cycle-accurate model don't support
-	  VDQCR.
-
 # H/w settings that can be hard-coded for now.
 
 # Corenet initiator settings. Stash request queues are 4-deep to match cores'
@@ -164,18 +144,6 @@ config FSL_QMAN_CI_SCHED_CFG_BMAN_W
 	depends on FSL_QMAN_CONFIG
 	default 2
 
-# Workaround for rev1 h/w bug with respect to "fast-track", disable it.
-config FSL_QMAN_BUG_FASTTRACK
-	bool
-	depends on FSL_QMAN_CONFIG
-	default y
-
-# Workaround for rev1 h/w bug with respect to class-scheduling weights.
-config FSL_QMAN_BUG_CSW
-	bool
-	depends on FSL_QMAN_CONFIG
-	default y
-
 endif # FSL_QMAN
 
 endmenu
diff --git a/drivers/hwqueue/qman_config.c b/drivers/hwqueue/qman_config.c
index 9ad6cbd..25f3f50 100644
--- a/drivers/hwqueue/qman_config.c
+++ b/drivers/hwqueue/qman_config.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008, 2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -294,18 +294,20 @@ static void qm_set_wq_scheduling(struct qman *qm, enum qm_wq_class wq_class,
 			u8 cs_elev, u8 csw2, u8 csw3, u8 csw4, u8 csw5,
 			u8 csw6, u8 csw7)
 {
-#ifdef CONFIG_FSL_QMAN_BUG_CSW
+#ifdef CONFIG_FSL_QMAN_BUG_AND_FEATURE_REV1
 #define csw(x) \
 do { \
 	if (++x == 8) \
 		x = 7; \
 } while (0)
-	csw(csw2);
-	csw(csw3);
-	csw(csw4);
-	csw(csw5);
-	csw(csw6);
-	csw(csw7);
+	if (qman_ip_rev == QMAN_REV1) {
+		csw(csw2);
+		csw(csw3);
+		csw(csw4);
+		csw(csw5);
+		csw(csw6);
+		csw(csw7);
+	}
 #endif
 	qm_out(WQ_CS_CFG(wq_class), ((cs_elev & 0xff) << 24) |
 		((csw2 & 0x7) << 20) | ((csw3 & 0x7) << 16) |
@@ -315,11 +317,12 @@ do { \
 
 static void qm_set_hid(struct qman *qm)
 {
-#ifdef CONFIG_FSL_QMAN_BUG_FASTTRACK
-	qm_out(HID_CFG, 3);
-#else
-	qm_out(HID_CFG, 0);
+#ifdef CONFIG_FSL_QMAN_BUG_AND_FEATURE_REV1
+	if (qman_ip_rev == QMAN_REV1)
+		qm_out(HID_CFG, 3);
+	else
 #endif
+	qm_out(HID_CFG, 0);
 }
 
 static void qm_set_corenet_initiator(struct qman *qm)
@@ -489,6 +492,8 @@ static int __init fsl_qman_init(struct device_node *node)
 	qm = qm_create(regs);
 	qm_get_version(qm, &id, &major, &minor);
 	pr_info("Qman ver:%04x,%02x,%02x\n", id, major, minor);
+	if (!qman_ip_rev)
+		qman_ip_rev = ((u16)major << 8) | minor;
 	/* FQD memory */
 	qm_set_memory(qm, qm_memory_fqd, 0, (u32)fqd_a, 1, 0, 0, fqd_sz);
 	/* PFDR memory */
diff --git a/drivers/hwqueue/qman_driver.c b/drivers/hwqueue/qman_driver.c
index 697ae39..dfe893c 100644
--- a/drivers/hwqueue/qman_driver.c
+++ b/drivers/hwqueue/qman_driver.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008, 2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -32,6 +32,10 @@
 
 #include "qman_private.h"
 
+/* Global variable containing revision id (even on non-control plane systems
+ * where CCSR isn't available) */
+u16 qman_ip_rev;
+
 /*****************/
 /* Portal driver */
 /*****************/
@@ -95,10 +99,17 @@ static struct qm_portal *__qm_portal_add(const struct qm_addr *addr,
 	struct qm_portal *ret;
 	BUG_ON((num_portals + 1) > PORTAL_MAX);
 	ret = &portals[num_portals];
-	ret->index = num_portals++;
 	ret->addr = *addr;
 	ret->config = *config;
 	ret->config.bound = 0;
+#ifdef CONFIG_FSL_QMAN_BUG_AND_FEATURE_REV1
+	ret->bugs = (void *)get_zeroed_page(GFP_KERNEL);
+	if (!ret->bugs) {
+		pr_err("Can't get zeroed page for 'bugs'\n");
+		return NULL;
+	}
+#endif
+	ret->index = num_portals++;
 	return ret;
 }
 
@@ -229,7 +240,22 @@ static int __init fsl_qman_portal_init(struct device_node *node)
 	struct qman_portal *affine_portal;
 #endif
 	int irq, ret, numpools;
+	u16 ip_rev = 0;
 
+	if (of_device_is_compatible(node, "fsl,qman-portal-1.1"))
+		ip_rev = QMAN_REV2;
+	else if (of_device_is_compatible(node, "fsl,qman-portal-1.0"))
+		ip_rev = QMAN_REV1;
+	if (!qman_ip_rev) {
+		if (ip_rev)
+			qman_ip_rev = ip_rev;
+		else {
+			pr_warning("unknown Qman version, presuming rev1\n");
+			qman_ip_rev = QMAN_REV1;
+		}
+	} else if (ip_rev && (qman_ip_rev != ip_rev))
+		pr_warning("Revision=0x%04x, but portal '%s' has 0x%04x\n",
+			qman_ip_rev, node->full_name, ip_rev);
 	ret = of_address_to_resource(node, 0, &res[0]);
 	if (ret) {
 		pr_err("Can't get %s property '%s'\n", node->full_name,
@@ -321,9 +347,15 @@ bad_cpu_ph:
 				_PAGE_GUARDED | _PAGE_NO_CACHE);
 	cfg.pools = 0;
 	cfg.bound = 0;
-	pr_info("Qman portal at %p:%p (%d:%d)\n", addr.addr_ce, addr.addr_ci,
-		cfg.cpu, cfg.channel);
 	portal = __qm_portal_add(&addr, &cfg);
+	if (!portal) {
+		iounmap(addr.addr_ce);
+		iounmap(addr.addr_ci);
+		irq_dispose_mapping(cfg.irq);
+		return -ENOMEM;
+	}
+	pr_info("Qman portal at %p:%p (%d:%d,v%04x)\n", addr.addr_ce,
+		addr.addr_ci, cfg.cpu, cfg.channel, qman_ip_rev);
 	while (numpools--) {
 		int tmp = __qm_link(portal, *(ph++));
 		if (tmp)
@@ -377,14 +409,11 @@ static __init int qman_init(void)
 	}
 #ifndef CONFIG_FSL_QMAN_PORTAL_DISABLEAUTO
 	if (num_affine_portals == num_online_cpus()) {
-#ifdef CONFIG_FSL_QMAN_BUG_CGR_INIT
 		u32 cgid;
 		for (cgid = 0; cgid < 256; cgid++)
 			if (qman_init_cgr(cgid))
-				pr_err("CGR BUG workaround failed on CGID %d\n",
+				pr_err("CGR init failed on CGID %d\n",
 					cgid);
-		pr_info("Qman CGR bug workaround, CGRs initialised\n");
-#endif
 	} else {
 		pr_err("Not all cpus have an affine Qman portal\n");
 		pr_err("Expect Qman-dependent drivers to crash!\n");
diff --git a/drivers/hwqueue/qman_high.c b/drivers/hwqueue/qman_high.c
index 2b4aa13..6ddea06 100644
--- a/drivers/hwqueue/qman_high.c
+++ b/drivers/hwqueue/qman_high.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008, 2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -945,14 +945,16 @@ int qman_init_fq(struct qman_fq *fq, u32 flags, struct qm_mcc_initfq *opts)
 		put_affine_portal();
 		return -EIO;
 	}
-	if (mcc->initfq.we_mask & QM_INITFQ_WE_FQCTRL) {
-		if (mcc->initfq.fqd.fq_ctrl & QM_FQCTRL_CGE)
-			fq_set(fq, QMAN_FQ_STATE_CGR_EN);
-		else
-			fq_clear(fq, QMAN_FQ_STATE_CGR_EN);
+	if (opts) {
+		if (opts->we_mask & QM_INITFQ_WE_FQCTRL) {
+			if (opts->fqd.fq_ctrl & QM_FQCTRL_CGE)
+				fq_set(fq, QMAN_FQ_STATE_CGR_EN);
+			else
+				fq_clear(fq, QMAN_FQ_STATE_CGR_EN);
+		}
+		if (opts->we_mask & QM_INITFQ_WE_CGID)
+			fq->cgr_groupid = opts->fqd.cgid;
 	}
-	if (mcc->initfq.we_mask & QM_INITFQ_WE_CGID)
-		fq->cgr_groupid = mcc->initfq.fqd.cgid;
 	fq->state = (flags & QMAN_INITFQ_FLAG_SCHED) ?
 			qman_fq_state_sched : qman_fq_state_parked;
 	FQUNLOCK(fq);
diff --git a/drivers/hwqueue/qman_low.c b/drivers/hwqueue/qman_low.c
index 000d260..ef7c992 100644
--- a/drivers/hwqueue/qman_low.c
+++ b/drivers/hwqueue/qman_low.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008, 2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -471,7 +471,6 @@ void qm_dqrr_current_prefetch(struct qm_portal *portal)
 	DQRR_API_START();
 	/* If ring entries get stashed, don't invalidate/prefetch */
 	QM_ASSERT(!(dqrr->flags & QM_DQRR_FLAG_RE));
-	dcbi(dqrr->cursor);
 	dcbt_ro(dqrr->cursor);
 }
 EXPORT_SYMBOL(qm_dqrr_current_prefetch);
@@ -782,14 +781,26 @@ int qm_mr_init(struct qm_portal *portal, enum qm_mr_pmode pmode,
 	MR_API_START();
 	u32 cfg;
 
+#ifdef CONFIG_FSL_QMAN_BUG_AND_FEATURE_REV1
+	if ((qman_ip_rev == QMAN_REV1) && (pmode != qm_mr_pvb)) {
+		pr_err("Qman is rev1, so QMAN9 workaround requires 'pvb'\n");
+		return -EINVAL;
+	}
+#endif
 	if (__qm_portal_bind(portal, QM_BIND_MR))
 		return -EBUSY;
 	mr->ring = ptr_OR(portal->addr.addr_ce, CL_MR);
 	mr->pi = qm_in(MR_PI_CINH) & (QM_MR_SIZE - 1);
 	mr->ci = qm_in(MR_CI_CINH) & (QM_MR_SIZE - 1);
+#ifdef CONFIG_FSL_QMAN_BUG_AND_FEATURE_REV1
+	if (qman_ip_rev == QMAN_REV1)
+		/* Situate the cursor in the shadow ring */
+		mr->cursor = portal->bugs->mr + mr->ci;
+	else
+#endif
 	mr->cursor = mr->ring + mr->ci;
 	mr->fill = cyc_diff(QM_MR_SIZE, mr->ci, mr->pi);
-	mr->vbit = (qm_in(MR_PI_CINH) & QM_MR_SIZE) ?QM_MR_VERB_VBIT : 0;
+	mr->vbit = (qm_in(MR_PI_CINH) & QM_MR_SIZE) ? QM_MR_VERB_VBIT : 0;
 	mr->ithresh = qm_in(MR_ITR);
 #ifdef CONFIG_FSL_QMAN_CHECKING
 	mr->pmode = pmode;
@@ -814,7 +825,6 @@ EXPORT_SYMBOL(qm_mr_finish);
 void qm_mr_current_prefetch(struct qm_portal *portal)
 {
 	MR_API_START();
-	dcbi(mr->cursor);
 	dcbt_ro(mr->cursor);
 }
 EXPORT_SYMBOL(qm_mr_current_prefetch);
@@ -892,6 +902,19 @@ u8 qm_mr_pvb_update(struct qm_portal *portal)
 	struct qm_mr_entry *res = ptr_OR(mr->ring, qm_cl(mr->pi));
 	QM_ASSERT(mr->pmode == qm_mr_pvb);
 	if ((res->verb & QM_MR_VERB_VBIT) == mr->vbit) {
+#ifdef CONFIG_FSL_QMAN_BUG_AND_FEATURE_REV1
+		/* New MR entry, on affected chips, copy this to the shadow ring
+		 * and fixup if required. */
+		if (qman_ip_rev == QMAN_REV1) {
+			struct qm_mr_entry *shadow = ptr_OR(portal->bugs->mr,
+							qm_cl(mr->pi));
+			memcpy(shadow, res, sizeof(*res));
+			/* Bypass the QM_MR_RC_*** definitions, and check the
+			 * byte value directly to handle the erratum. */
+			if (shadow->ern.rc == 0x06)
+				shadow->ern.rc = 0x60;
+		}
+#endif
 		mr->pi = (mr->pi + 1) & (QM_MR_SIZE - 1);
 		if (!mr->pi)
 			mr->vbit ^= QM_MR_VERB_VBIT;
@@ -1030,12 +1053,50 @@ EXPORT_SYMBOL(qm_mc_abort);
 void qm_mc_commit(struct qm_portal *portal, u8 myverb)
 {
 	MC_API_START();
+	struct qm_mc_result *rr = mc->rr + mc->rridx;
 	QM_ASSERT(mc->state == mc_user);
-	dcbi(mc->rr + mc->rridx);
+	dcbi(rr);
 	lwsync();
+#ifdef CONFIG_FSL_QMAN_BUG_AND_FEATURE_REV1
+	if ((qman_ip_rev == QMAN_REV1) && ((myverb & QM_MCC_VERB_MASK) ==
+					QM_MCC_VERB_INITFQ_SCHED)) {
+		u32 fqid = mc->cr->initfq.fqid;
+		/* Do two commands to avoid the hw bug. Note, we poll locally
+		 * rather than using qm_mc_result() because from a QMAN_CHECKING
+		 * perspective, we don't want to appear to have "finished" until
+		 * both commands are done. */
+		mc->cr->__dont_write_directly__verb = mc->vbit |
+					QM_MCC_VERB_INITFQ_PARKED;
+		dcbf(mc->cr);
+		portal->bugs->initfq_and_sched = 1;
+		do {
+			dcbi(rr);
+			dcbt_ro(rr);
+			barrier();
+		} while (!rr->verb);
+		mc->rridx ^= 1;
+		mc->vbit ^= QM_MCC_VERB_VBIT;
+#ifdef CONFIG_FSL_QMAN_CHECKING
+		mc->state = mc_idle;
+#endif
+		if (rr->result != QM_MCR_RESULT_OK) {
+#ifdef CONFIG_FSL_QMAN_CHECKING
+			mc->state = mc_hw;
+#endif
+			return;
+		}
+		rr = mc->rr + mc->rridx;
+		dcbzl(mc->cr);
+		mc->cr->alterfq.fqid = fqid;
+		dcbi(rr);
+		lwsync();
+		myverb = QM_MCC_VERB_ALTER_SCHED;
+	} else
+		portal->bugs->initfq_and_sched = 0;
+#endif
 	mc->cr->__dont_write_directly__verb = myverb | mc->vbit;
 	dcbf(mc->cr);
-	dcbt_ro(mc->rr + mc->rridx);
+	dcbt_ro(rr);
 #ifdef CONFIG_FSL_QMAN_CHECKING
 	mc->state = mc_hw;
 #endif
@@ -1055,6 +1116,24 @@ struct qm_mc_result *qm_mc_result(struct qm_portal *portal)
 		dcbt_ro(rr);
 		return NULL;
 	}
+#ifdef CONFIG_FSL_QMAN_BUG_AND_FEATURE_REV1
+	if (qman_ip_rev == QMAN_REV1) {
+		if ((rr->verb & QM_MCR_VERB_MASK) == QM_MCR_VERB_QUERYFQ) {
+			void *misplaced = (void *)rr + 50;
+			memcpy(&portal->bugs->result, rr, sizeof(*rr));
+			rr = &portal->bugs->result;
+			memcpy(&rr->queryfq.fqd.td, misplaced,
+				sizeof(rr->queryfq.fqd.td));
+		} else if (portal->bugs->initfq_and_sched) {
+			/* We split the user-requested command, make the final
+			 * result match the requested type. */
+			memcpy(&portal->bugs->result, rr, sizeof(*rr));
+			rr = &portal->bugs->result;
+			rr->verb = (rr->verb & QM_MCR_VERB_RRID) |
+					QM_MCR_VERB_INITFQ_SCHED;
+		}
+	}
+#endif
 	mc->rridx ^= 1;
 	mc->vbit ^= QM_MCC_VERB_VBIT;
 #ifdef CONFIG_FSL_QMAN_CHECKING
diff --git a/drivers/hwqueue/qman_private.h b/drivers/hwqueue/qman_private.h
index 79ef384..176e65a 100644
--- a/drivers/hwqueue/qman_private.h
+++ b/drivers/hwqueue/qman_private.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008, 2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -94,6 +94,19 @@ struct qm_mc {
 /* Portal structure */
 /********************/
 
+#ifdef CONFIG_FSL_QMAN_BUG_AND_FEATURE_REV1
+/* For workarounds that require storage, this struct is overlayed on a
+ * get_zeroed_page(), guaranteeing alignment and such. */
+struct qm_portal_bugs {
+	/* shadow MR ring, for QMAN9 workaround, 8-CL aligned */
+	struct qm_mr_entry mr[QM_MR_SIZE];
+	/* shadow MC result, for QMAN6 and QMAN7 workarounds, CL aligned */
+	struct qm_mc_result result;
+	/* boolean switch for QMAN7 workaround */
+	int initfq_and_sched;
+};
+#endif
+
 struct qm_portal {
 	/* In the non-CONFIG_FSL_QMAN_CHECKING case, everything up to and
 	 * including 'mc' fits in a cacheline (yay!). The 'config' part is
@@ -107,6 +120,9 @@ struct qm_portal {
 	struct qm_portal_config config;
 	/* Logical index (not cell-index) */
 	int index;
+#ifdef CONFIG_FSL_QMAN_BUG_AND_FEATURE_REV1
+	struct qm_portal_bugs *bugs;
+#endif
 } ____cacheline_aligned;
 
 /* EQCR/DQRR/[...] code uses this as a locked mechanism to bind/unbind to
@@ -119,7 +135,12 @@ void __qm_portal_unbind(struct qm_portal *portal, u8 iface);
 __init int __fqalloc_init(void);
 #endif
 
-/* Hooks between qman_driver.c and qman_high.c */
+/* Revision info (for errata and feature handling) */
+#define QMAN_REV1 0x0100
+#define QMAN_REV2 0x0101
+extern u16 qman_ip_rev; /* 0 if uninitialised, otherwise QMAN_REVx */
+
+/* Hooks from qman_high.c in to qman_driver.c */
 extern DEFINE_PER_CPU(struct qman_portal *, qman_affine_portal);
 static inline struct qman_portal *get_affine_portal(void)
 {
@@ -129,6 +150,8 @@ static inline void put_affine_portal(void)
 {
 	put_cpu_var(qman_affine_portal);
 }
+
+/* Hooks from qman_driver.c in to qman_high.c */
 #define QMAN_PORTAL_FLAG_RSTASH      0x00000001 /* enable DQRR entry stashing */
 #define QMAN_PORTAL_FLAG_DSTASH      0x00000002 /* enable data stashing */
 struct qman_portal *qman_create_portal(struct qm_portal *portal, u32 flags,
@@ -142,3 +165,4 @@ void qman_static_dequeue_add_ex(struct qman_portal *p, u32 pools);
  * CGR" commands on boot-up. So we're declaring some internal-only APIs to
  * facilitate this for now. */
 int qman_init_cgr(u32 cgid);
+
diff --git a/drivers/hwqueue/qman_test_high.c b/drivers/hwqueue/qman_test_high.c
index 9ff8434..a940594 100644
--- a/drivers/hwqueue/qman_test_high.c
+++ b/drivers/hwqueue/qman_test_high.c
@@ -149,7 +149,6 @@ void qman_test_high(void)
 	if (qman_init_fq(fq, QMAN_INITFQ_FLAG_LOCAL, NULL))
 		panic("qman_init_fq() failed\n");
 
-#ifndef CONFIG_FSL_QMAN_TEST_HIGH_BUG_VDQCR
 	/* Do enqueues + VDQCR, twice. (Parked FQ) */
 	do_enqueues(fq);
 	pr_info("VDQCR (till-empty);\n");
@@ -166,7 +165,6 @@ void qman_test_high(void)
 	if (qman_volatile_dequeue(fq, VDQCR_FLAGS,
 			QM_VDQCR_NUMFRAMES_SET(NUM_ENQUEUES - NUM_PARTIAL)))
 		panic("qman_volatile_dequeue() failed\n");
-#endif
 
 	do_enqueues(fq);
 	pr_info("scheduled dequeue (till-empty)\n");
diff --git a/drivers/hwqueue/qman_test_low.c b/drivers/hwqueue/qman_test_low.c
index 230e5c4..8a91e46 100644
--- a/drivers/hwqueue/qman_test_low.c
+++ b/drivers/hwqueue/qman_test_low.c
@@ -32,10 +32,6 @@
 
 #include "qman_test.h"
 
-/* Bug or missing-feature workarounds */
-#define BUG_NO_EQCR_ITR
-#define BUG_NO_REASSERT_DQAVAIL
-
 /* DQRR maxfill, and ring/data stashing booleans */
 #define DQRR_MAXFILL	15
 
@@ -94,9 +90,7 @@ static u32 fqid = 1;
 #endif /* !defined(CONFIG_FSL_QMAN_FQALLOCATOR) */
 
 /* Boolean switch for handling EQCR_ITR */
-#ifndef BUG_NO_EQCR_ITR
 static int eqcr_thresh_on;
-#endif
 
 /* Test frame-descriptor, and another one to track dequeues */
 static struct qm_fd fd, fd_dq;
@@ -140,7 +134,6 @@ do { \
 /* Track EQCR consumption */
 static void eqcr_update(void)
 {
-#ifndef BUG_NO_EQCR_ITR
 	u32 status = qm_isr_status_read(portal);
 	if (status & QM_PIRQ_EQRI) {
 		int progress = qm_eqcr_cci_update(portal);
@@ -151,9 +144,6 @@ static void eqcr_update(void)
 		pr_info("Auto-update of EQCR consumption\n");
 		qm_isr_status_clear(portal, progress & QM_PIRQ_EQRI);
 	}
-#else
-	qm_eqcr_cci_update(portal);
-#endif
 }
 
 /* Helper for qm_eqcr_start() that tracks ring consumption and checks the
@@ -181,12 +171,10 @@ static void eqcr_empty(void)
 static void eqcr_commit(void)
 {
 	qm_eqcr_pvb_commit(portal, TEQVERB);
-#ifndef BUG_NO_EQCR_ITR
 	if (!eqcr_thresh_on && (qm_eqcr_get_avail(portal) < 2)) {
 		eqcr_thresh_on = 1;
 		qm_eqcr_set_ithresh(portal, 1);
 	}
-#endif
 }
 
 /* Track DQRR consumption */
@@ -222,7 +210,6 @@ static void mr_consume_and_next(void)
 	qm_mr_cci_consume_to_current(portal);
 }
 
-#ifndef CONFIG_FSL_QMAN_TEST_LOW_BUG_INTERRUPTS
 static irqreturn_t portal_isr(int irq, void *ptr)
 {
 	pr_info("QMAN portal interrupt, isr_count=%d->%d\n", isr_count,
@@ -232,16 +219,13 @@ static irqreturn_t portal_isr(int irq, void *ptr)
 	wake_up(&queue);
 	return IRQ_HANDLED;
 }
-#endif
 
 void qman_test_low(struct qm_portal *__p)
 {
 	cpumask_t oldmask = current->cpus_allowed, newmask = CPU_MASK_NONE;
 	const struct qm_portal_config *config = qm_portal_config(__p);
 	int i;
-#ifndef CONFIG_FSL_QMAN_TEST_LOW_BUG_INTERRUPTS
 	u32 status;
-#endif
 
 	portal = __p;
 	fd_init(&fd);
@@ -262,17 +246,11 @@ void qman_test_low(struct qm_portal *__p)
 	/* Initialise portal */
 	/*********************/
 	if (qm_eqcr_init(portal, qm_eqcr_pvb, qm_eqcr_cci) ||
-#ifdef CONFIG_FSL_QMAN_TEST_LOW_BUG_STASHING
-		qm_dqrr_init(portal,
-			qm_dqrr_dpush, qm_dqrr_pvb, qm_dqrr_cci,
-			DQRR_MAXFILL, 0, 0) ||
-#else
 		qm_dqrr_init(portal,
 			qm_dqrr_dpush, qm_dqrr_pvb, qm_dqrr_cci,
 			DQRR_MAXFILL,
 			(config->cpu == -1) ? 0 : 1,
 			(config->cpu == -1) ? 0 : 1) ||
-#endif
 		qm_mr_init(portal, qm_mr_pvb, qm_mr_cci) ||
 		qm_mc_init(portal) || qm_isr_init(portal))
 		panic("Portal setup failed");
@@ -284,10 +262,8 @@ void qman_test_low(struct qm_portal *__p)
 
 	pr_info("low-level test, start ccmode\n");
 
-#ifndef CONFIG_FSL_QMAN_TEST_LOW_BUG_INTERRUPTS
 	if (request_irq(config->irq, portal_isr, 0, "Qman portal 0", NULL))
 		panic("Can't register Qman portal 0 IRQ");
-#endif
 	pr_info("Portal %d channel i/faces initialised\n", config->channel);
 
 	/*****************/
@@ -305,11 +281,9 @@ void qman_test_low(struct qm_portal *__p)
 	pr_info("FQ %d initialised for channel %d, wq %d\n", fqid,
 		config->channel, TWQ);
 
-#ifndef CONFIG_FSL_QMAN_TEST_LOW_BUG_INTERRUPTS
 	/* The portal's (interrupt) status register should be zero */
 	status = qm_isr_status_read(portal);
 	BUG_ON(status);
-#endif
 
 	/**************************/
 	/* Enqueue TFRAMES frames */
@@ -326,25 +300,20 @@ void qman_test_low(struct qm_portal *__p)
 	}
 	eqcr_empty();
 
-#ifndef CONFIG_FSL_QMAN_TEST_LOW_BUG_INTERRUPTS
 	/* The portal's (interrupt) status register should be zero */
 	status = qm_isr_status_read(portal);
 	BUG_ON(status);
-#endif
 
 	/***************/
 	/* Schedule FQ */
 	/***************/
-#ifndef CONFIG_FSL_QMAN_TEST_LOW_BUG_INTERRUPTS
 	/* enable the interrupt source before it asserts */
 	qm_isr_enable_write(portal, QM_DQAVAIL_PORTAL);
 	qm_isr_uninhibit(portal);
-#endif
 	mc_start();
 	mcc->alterfq.fqid = fqid;
 	mc_commit(QM_MCC_VERB_ALTER_SCHED);
 	pr_info("FQ %d scheduled\n", fqid);
-#ifndef CONFIG_FSL_QMAN_TEST_LOW_BUG_INTERRUPTS
 	/* The interrupt should have fired immediately. */
 	wait_event(queue, isr_count == 1);
 	/* The status register should show DQAVAIL. */
@@ -352,18 +321,15 @@ void qman_test_low(struct qm_portal *__p)
 		status = qm_isr_status_read(portal);
 	} while (status != QM_DQAVAIL_PORTAL);
 	/* Writing to clear should fail due to an immediate reassertion */
-#ifndef BUG_NO_REASSERT_DQAVAIL
 	qm_isr_status_clear(portal, status);
 	do {
 		status = qm_isr_status_read(portal);
 	} while (status != QM_DQAVAIL_PORTAL);
-#endif
 	/* Zeroing the enable register before unihibiting should prevent any
 	 * interrupt */
 	qm_isr_enable_write(portal, 0);
 	qm_isr_uninhibit(portal);
 	BUG_ON(isr_count != 1);
-#endif
 
 	/******************************/
 	/* SDQCR the remaining frames */
@@ -374,7 +340,6 @@ void qman_test_low(struct qm_portal *__p)
 		QM_SDQCR_TYPE_PRIO_QOS | QM_SDQCR_TOKEN_SET(TTOKEN) |
 		QM_SDQCR_CHANNELS_DEDICATED);
 
-#ifndef CONFIG_FSL_QMAN_TEST_LOW_BUG_INTERRUPTS
 	/* The status register should have the sticky 'DQAVAIL' from before, and
 	 * maybe DQRI (it's on its way). */
 	status = qm_isr_status_read(portal);
@@ -396,7 +361,6 @@ void qman_test_low(struct qm_portal *__p)
 	qm_isr_enable_write(portal, 0);
 	qm_isr_uninhibit(portal);
 	BUG_ON(isr_count != 2);
-#endif
 	for (i = 0; i < TFRAMES; i++)
 	{
 		dqrr_update();
@@ -421,14 +385,12 @@ void qman_test_low(struct qm_portal *__p)
 		fd_inc(&fd_dq);
 		dqrr_consume_and_next();
 	}
-#ifndef CONFIG_FSL_QMAN_TEST_LOW_BUG_INTERRUPTS
 	/* Clear stick bits from the status register, and it should
 	 * now remain zero. */
 	status = qm_isr_status_read(portal);
 	qm_isr_status_clear(portal, status);
 	status = qm_isr_status_read(portal);
 	BUG_ON(status);
-#endif
 
 	pr_info("low-level test, end ccmode\n");
 
@@ -464,9 +426,7 @@ void qman_test_low(struct qm_portal *__p)
 	/* Teardown */
 	/************/
 	eqcr_empty();
-#ifndef CONFIG_FSL_QMAN_TEST_LOW_BUG_INTERRUPTS
 	free_irq(config->irq, NULL);
-#endif
 	qm_eqcr_finish(portal);
 	qm_dqrr_finish(portal);
 	qm_mr_finish(portal);
-- 
1.6.5.2

