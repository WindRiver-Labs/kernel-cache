From 9c4b21e81dbd5d47b0a555454a7bee8c460ee8ae Mon Sep 17 00:00:00 2001
From: Timur Tabi <timur@freescale.com>
Date: Tue, 6 Apr 2010 09:25:04 -0400
Subject: [PATCH] p4080_1-2-rc1 add more support for powerpc

Signed-off-by: adrian bogdan <adrian.bogdan@freescale.com>
Signed-off-by: Andy Fleming <afleming@freescale.com>
Signed-off-by: Ashish Kalra <ashish.kalra@freescale.com>
Signed-off-by: Donio Ron <rdonio@freescale.com>
Signed-off-by: Emil Medve <Emilian.Medve@Freescale.com>
Signed-off-by: Geoff Thorpe <geoff@geoffthorpe.net>
Signed-off-by: Jeffrey Ladouceur <Jeffrey.Ladouceur@freescale.com>
Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
Signed-off-by: Li Yang <leoli@freescale.com>
Signed-off-by: Manish Jaggi <b10520@lc0008.zin33.ap.freescale.net>
Signed-off-by: Naveen Burmi <naveenburmi@freescale.com>
Signed-off-by: Roy Zang <tie-fei.zang@freescale.com>
Signed-off-by: Scott Wood <scottwood@freescale.com>
Signed-off-by: Shlomi Gridish <gridish@freescale.com>
Signed-off-by: Stuart Yoder <stuart.yoder@freescale.com>
Signed-off-by: Timur Tabi <timur@freescale.com>
Signed-off-by: Vakul Garg <vakul@freescale.com>
Signed-off-by: Varun Sethi <Varun.Sethi@freescale.com>
Signed-off-by: Zhang Wei <zw@zh-kernel.org>

[This patch is based on the FSL SDK 2.0.3 patch
"p4080_1-2-rc1-powerpc.patch", which had no commit header.
Some changes to the FSL patch were made to adjust it to the 2.6.34 kernel:
arch/powerpc/platforms/fsl_uli1575.c - already has p2020ds in kernel 2.6.34.
As for the other files introducing p2020ds and hypervisor, they were either
removed
(p2020ds_camp_core0.dts, p2020ds_camp_core1.dts, p2020ds.dts,
 p2020_ds_defconfig,     fsl_hcalls.h,           vmpic.c),
 or left unpached
(Makefile,               wrapper,                Kconfig.debug,
 mpc85xx_ds.c,           fsl_util575.c           fsl_pci.c).
Removed files
p4080sim_36b.dts,       p4080sim.dts,            p4080_sim.c,
p4080_sim_defconfig,    p4080_sim_pci_ep_defconfig
created with the patch. Removed FSL hypervisor bits]
Integrated-by: Yuri Nedel <Yuri.Nedel@windriver.com>
---
 arch/powerpc/Makefile                |    5 +
 arch/powerpc/include/asm/bitops.h    |    2 +
 arch/powerpc/include/asm/reg_booke.h |    6 +-
 arch/powerpc/include/asm/udbg.h      |    1 +
 arch/powerpc/include/asm/vmpic.h     |   46 +++++++
 arch/powerpc/kernel/head_fsl_booke.S |   19 +++-
 arch/powerpc/kernel/idle.c           |    5 +-
 arch/powerpc/kernel/setup_32.c       |    1 +
 arch/powerpc/platforms/85xx/Kconfig  |   21 ++++
 arch/powerpc/platforms/85xx/Makefile |    2 +
 arch/powerpc/platforms/Kconfig       |    4 +
 arch/powerpc/sysdev/Makefile         |    1 +
 arch/powerpc/sysdev/fsl_msi.c        |   64 ++++++++---
 arch/powerpc/sysdev/fsl_msi.h        |    1 +
 arch/powerpc/sysdev/fsl_rio.c        |  218 +++++++++++++++++++++++++++++++++-
 15 files changed, 373 insertions(+), 23 deletions(-)
 create mode 100644 arch/powerpc/include/asm/vmpic.h

diff --git a/arch/powerpc/Makefile b/arch/powerpc/Makefile
index e6c52f4..4830713 100644
--- a/arch/powerpc/Makefile
+++ b/arch/powerpc/Makefile
@@ -118,6 +118,11 @@ KBUILD_CFLAGS += $(call cc-option,-funit-at-a-time)
 # often slow when they are implemented at all
 KBUILD_CFLAGS		+= -mno-string
 
+ifeq ($(CONFIG_DEBUG_CW),y)
+CFLAGS += -g2 -gdwarf-2
+AFLAGS_KERNEL += -Wa,-gdwarf2
+endif
+
 ifeq ($(CONFIG_6xx),y)
 KBUILD_CFLAGS		+= -mcpu=powerpc
 endif
diff --git a/arch/powerpc/include/asm/bitops.h b/arch/powerpc/include/asm/bitops.h
index 30964ae..149ef95 100644
--- a/arch/powerpc/include/asm/bitops.h
+++ b/arch/powerpc/include/asm/bitops.h
@@ -1,6 +1,8 @@
 /*
  * PowerPC atomic bit operations.
  *
+ * Copyright (C) 2009 Freescale Semiconductor, Inc.
+ *
  * Merged version by David Gibson <david@gibson.dropbear.id.au>.
  * Based on ppc64 versions by: Dave Engebretsen, Todd Inglett, Don
  * Reed, Pat McCarthy, Peter Bergner, Anton Blanchard.  They
diff --git a/arch/powerpc/include/asm/reg_booke.h b/arch/powerpc/include/asm/reg_booke.h
index 596f06d..3bc2497 100644
--- a/arch/powerpc/include/asm/reg_booke.h
+++ b/arch/powerpc/include/asm/reg_booke.h
@@ -28,9 +28,9 @@
 #elif defined (CONFIG_40x)
 #define MSR_KERNEL	(MSR_ME|MSR_RI|MSR_IR|MSR_DR|MSR_CE)
 #define MSR_USER	(MSR_KERNEL|MSR_PR|MSR_EE)
-#else
-#ifdef CONFIG_WR_OCD_DEBUG
-#define MSR_KERNEL	(MSR_ME|MSR_RI|MSR_CE|MSR_DE)
+#else				/* Comes here when defined CONFIG_BOOKE */
+#if defined(CONFIG_DEBUG_CW) || defined(CONFIG_WR_OCD_DEBUG)
+#define MSR_KERNEL      (MSR_ME|MSR_RI|MSR_CE|MSR_DE)
 #else
 #define MSR_KERNEL     (MSR_ME|MSR_RI|MSR_CE)
 #endif	/* OCD */
diff --git a/arch/powerpc/include/asm/udbg.h b/arch/powerpc/include/asm/udbg.h
index 11ae699..fa5f42b 100644
--- a/arch/powerpc/include/asm/udbg.h
+++ b/arch/powerpc/include/asm/udbg.h
@@ -32,6 +32,7 @@ extern void udbg_init_uart(void __iomem *comport, unsigned int speed,
 			   unsigned int clock);
 extern unsigned int udbg_probe_uart_speed(void __iomem *comport,
 					  unsigned int clock);
+extern void udbg_init_hvc_fsl(void);
 
 struct device_node;
 extern void udbg_scc_init(int force_scc);
diff --git a/arch/powerpc/include/asm/vmpic.h b/arch/powerpc/include/asm/vmpic.h
new file mode 100644
index 0000000..550866b
--- /dev/null
+++ b/arch/powerpc/include/asm/vmpic.h
@@ -0,0 +1,46 @@
+/*
+ * VMPIC private definitions and structure.
+ *
+ * Copyright (C) 2008-2009 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+#ifndef __VMPIC_H__
+#define __VMPIC_H__
+
+#include <linux/irq.h>
+
+#define NR_INTERNAL_INTS 128
+#define NR_EXTERNAL_INTS 16
+#define NR_VMPIC_INTS (NR_EXTERNAL_INTS + NR_INTERNAL_INTS)
+
+#define VMPIC_INFO(name) VMPIC_##name
+
+#define VMPIC_VECPRI_POLARITY_NEGATIVE 0
+#define VMPIC_VECPRI_POLARITY_POSITIVE 1
+#define VMPIC_VECPRI_SENSE_EDGE 0
+#define VMPIC_VECPRI_SENSE_LEVEL 0x2
+#define VMPIC_VECPRI_POLARITY_MASK 0x1
+#define VMPIC_VECPRI_SENSE_MASK 0x2
+
+struct vmpic {
+	/* The remapper for this VMPIC */
+	struct irq_host	*irqhost;
+
+	/* The "linux" controller struct */
+	struct irq_chip	hc_irq;
+
+	/* core int flag */
+	int coreint_flag;
+};
+
+/*
+ * Exported vmpic functions
+ */
+
+void __init vmpic_init(struct device_node *node, int coreint_flag);
+unsigned int vmpic_get_irq(void);
+
+#endif /* __VMPIC_H__ */
diff --git a/arch/powerpc/kernel/head_fsl_booke.S b/arch/powerpc/kernel/head_fsl_booke.S
index 7255265..7acbc8a 100644
--- a/arch/powerpc/kernel/head_fsl_booke.S
+++ b/arch/powerpc/kernel/head_fsl_booke.S
@@ -21,7 +21,7 @@
  *		debbie_chu@mvista.com
  *    Copyright 2002-2004 MontaVista Software, Inc.
  *	PowerPC 44x support, Matt Porter <mporter@kernel.crashing.org>
- *    Copyright 2004 Freescale Semiconductor, Inc
+ *    Copyright 2004, 2008-2009 Freescale Semiconductor, Inc
  *	PowerPC e500 modifications, Kumar Gala <galak@kernel.crashing.org>
  *
  * This program is free software; you can redistribute  it and/or modify it
@@ -211,6 +211,9 @@ skpinv:	addi	r6,r6,1				/* Increment */
 
 	xori	r6,r4,1
 	slwi	r6,r6,5		/* setup new context with other address space */
+#if defined(CONFIG_DEBUG_CW)
+	ori	r6, r6, 0x200	/* enable DE bit for MSR */
+#endif
 	bl	1f		/* Find our address */
 1:	mflr	r9
 	rlwimi	r7,r9,0,20,31
@@ -237,11 +240,14 @@ skpinv:	addi	r6,r6,1				/* Increment */
 	lis	r7,0x1000	/* Set MAS0(TLBSEL) = 1 */
 	rlwimi	r7,r3,16,4,15	/* Setup MAS0 = TLBSEL | ESEL(r3) */
 	mtspr	SPRN_MAS0,r7
+#if !defined(CONFIG_DEBUG_CW)
+/* CW_patch: during debug the IPROT should not be cleared */
 	tlbre
 	mfspr	r6,SPRN_MAS1
 	rlwinm	r6,r6,0,2,0	/* clear IPROT */
 	mtspr	SPRN_MAS1,r6
 	tlbwe
+#endif
 	/* Invalidate TLB1 */
 	li	r9,0x0c
 	tlbivax 0,r9
@@ -329,7 +335,7 @@ skpinv:	addi	r6,r6,1				/* Increment */
 	mtspr	SPRN_HID0, r2
 #endif
 
-#if !defined(CONFIG_BDI_SWITCH)
+#if !defined(CONFIG_BDI_SWITCH) && !defined(CONFIG_DEBUG_CW)
 	/*
 	 * The Abatron BDI JTAG debugger does not tolerate others
 	 * mucking with the debug registers.
@@ -385,6 +391,13 @@ skpinv:	addi	r6,r6,1				/* Increment */
 /*
  * Decide what sort of machine this is and initialize the MMU.
  */
+#if defined(CONFIG_DEBUG_CW)
+	lis	r10, 0x1008 /* clear the V bit from the L2MMU_CAM8 register */
+	mtspr	SPRN_MAS0, r10
+	lis	r10, 0x0
+	mtspr	SPRN_MAS1, r10
+	tlbwe
+#endif
 	mr	r3,r31
 	mr	r4,r30
 	mr	r5,r29
@@ -1069,7 +1082,7 @@ _GLOBAL(flush_dcache_L1)
 1:	dcbf	0,r4		/* ...and flush. */
 	add	r4,r4,r5
 	bdnz	1b
-	
+
 	/* restore HID0 */
 	mtspr	SPRN_HID0,r8
 	isync
diff --git a/arch/powerpc/kernel/idle.c b/arch/powerpc/kernel/idle.c
index 4da8bf2..1b2a8a6 100644
--- a/arch/powerpc/kernel/idle.c
+++ b/arch/powerpc/kernel/idle.c
@@ -73,8 +73,11 @@ void cpu_idle(void)
 				stop_critical_timings();
 
 				/* check again after disabling irqs */
-				if (!need_resched() && !cpu_should_die())
+				if (!need_resched() && !cpu_should_die()) {
+#if !defined(CONFIG_DEBUG_CW)
 					ppc_md.power_save();
+#endif
+				}
 
 				start_critical_timings();
 
diff --git a/arch/powerpc/kernel/setup_32.c b/arch/powerpc/kernel/setup_32.c
index 94f60bf..1923411 100644
--- a/arch/powerpc/kernel/setup_32.c
+++ b/arch/powerpc/kernel/setup_32.c
@@ -49,6 +49,7 @@ extern void bootx_init(unsigned long r4, unsigned long phys);
 int boot_cpuid;
 EXPORT_SYMBOL_GPL(boot_cpuid);
 int boot_cpuid_phys;
+EXPORT_SYMBOL(boot_cpuid_phys);
 
 int smp_hw_index[NR_CPUS];
 
diff --git a/arch/powerpc/platforms/85xx/Kconfig b/arch/powerpc/platforms/85xx/Kconfig
index 3a2ade2..eba7460 100644
--- a/arch/powerpc/platforms/85xx/Kconfig
+++ b/arch/powerpc/platforms/85xx/Kconfig
@@ -71,6 +71,27 @@ config SOCRATES
 	help
 	  This option enables support for the Socrates board.
 
+config P4080_SIM
+	bool "Freescale P4080 SIM"
+	select DEFAULT_UIMAGE
+	select HAS_RAPIDIO
+	help
+	  This option enables support for the P4080 SIM board
+
+config P4080_HV
+	bool "Freescale P4080 Hypervisor"
+	select DEFAULT_UIMAGE
+	select VMPIC
+	select FSL_HYPERVISOR
+	select HAS_RAPIDIO
+	help
+	  This option enables support for the P4080 Hypervisor Platform
+
+config FSL_HYPERVISOR
+	bool
+	help
+	  This options enables support for Freescale Hypervisor
+
 config KSI8560
         bool "Emerson KSI8560"
         select DEFAULT_UIMAGE
diff --git a/arch/powerpc/platforms/85xx/Makefile b/arch/powerpc/platforms/85xx/Makefile
index 6a45885..2ac40f1 100644
--- a/arch/powerpc/platforms/85xx/Makefile
+++ b/arch/powerpc/platforms/85xx/Makefile
@@ -16,6 +16,8 @@ obj-$(CONFIG_MPC85xx_DS)  += mpc85xx_ds.o
 obj-$(CONFIG_MPC85xx_MDS) += mpc85xx_mds.o
 obj-$(CONFIG_MPC85xx_RDB) += mpc85xx_rdb.o
 obj-$(CONFIG_P4080_DS)    += p4080_ds.o corenet_ds.o
+obj-$(CONFIG_P4080_SIM)   += p4080_sim.o
+obj-$(CONFIG_P4080_HV)    += p4080_hv.o
 obj-$(CONFIG_STX_GP3)	  += stx_gp3.o
 obj-$(CONFIG_TQM85xx)	  += tqm85xx.o
 obj-$(CONFIG_SBC8560)     += sbc8560.o
diff --git a/arch/powerpc/platforms/Kconfig b/arch/powerpc/platforms/Kconfig
index d1663db..74675c0 100644
--- a/arch/powerpc/platforms/Kconfig
+++ b/arch/powerpc/platforms/Kconfig
@@ -60,6 +60,10 @@ config IPIC
 	bool
 	default n
 
+config VMPIC
+	depends on FSL_HYPERVISOR
+	bool
+
 config MPIC
 	bool
 	default n
diff --git a/arch/powerpc/sysdev/Makefile b/arch/powerpc/sysdev/Makefile
index 5642924..d0c4780 100644
--- a/arch/powerpc/sysdev/Makefile
+++ b/arch/powerpc/sysdev/Makefile
@@ -6,6 +6,7 @@ endif
 
 mpic-msi-obj-$(CONFIG_PCI_MSI)	+= mpic_msi.o mpic_u3msi.o mpic_pasemi_msi.o
 obj-$(CONFIG_MPIC)		+= mpic.o $(mpic-msi-obj-y)
+obj-$(CONFIG_VMPIC)		+= vmpic.o
 fsl-msi-obj-$(CONFIG_PCI_MSI)	+= fsl_msi.o
 obj-$(CONFIG_PPC_MSI_BITMAP)	+= msi_bitmap.o
 
diff --git a/arch/powerpc/sysdev/fsl_msi.c b/arch/powerpc/sysdev/fsl_msi.c
index 3482e3f..9ca091f 100644
--- a/arch/powerpc/sysdev/fsl_msi.c
+++ b/arch/powerpc/sysdev/fsl_msi.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2007-2008 Freescale Semiconductor, Inc. All rights reserved.
+ * Copyright (C) 2007-2009 Freescale Semiconductor, Inc. All rights reserved.
  *
  * Author: Tony Li <tony.li@freescale.com>
  *	   Jason Jin <Jason.jin@freescale.com>
@@ -22,6 +22,7 @@
 #include <asm/prom.h>
 #include <asm/hw_irq.h>
 #include <asm/ppc-pci.h>
+#include <asm/fsl_hcalls.h>
 #include "fsl_msi.h"
 
 struct fsl_msi_feature {
@@ -110,7 +111,7 @@ static void fsl_teardown_msi_irqs(struct pci_dev *pdev)
 	return;
 }
 
-static void fsl_compose_msi_msg(struct pci_dev *pdev, int hwirq,
+static int fsl_compose_msi_msg(struct pci_dev *pdev, int hwirq,
 				  struct msi_msg *msg)
 {
 	struct fsl_msi *msi_data = fsl_msi;
@@ -120,12 +121,29 @@ static void fsl_compose_msi_msg(struct pci_dev *pdev, int hwirq,
 	pci_bus_read_config_dword(hose->bus,
 		PCI_DEVFN(0, 0), PCI_BASE_ADDRESS_0, &base);
 
-	msg->address_lo = msi_data->msi_addr_lo + base;
+ 	if ((msi_data->feature & FSL_PIC_IP_MASK) == FSL_PIC_IP_VMPIC) {
+ 		const u32* reg;
+ 		struct pci_controller *hose = pci_bus_to_host(pdev->bus);
+ 
+ 		reg = of_get_property(hose->dn, "msi-address-64", NULL);
+ 		if (!reg) {
+ 			dev_err(&pdev->dev, "%s no msi-address-64 property!\n",
+ 					hose->dn->full_name);
+ 			return -1;
+ 		}
+ 		msg->address_lo = *((u64 *)reg);
+ 	}
+ 	else {
+ 		msg->address_lo = msi_data->msi_addr_lo;
+ 	}
+ 
 	msg->address_hi = msi_data->msi_addr_hi;
 	msg->data = hwirq;
 
 	pr_debug("%s: allocated srs: %d, ibs: %d\n",
 		__func__, hwirq / IRQS_PER_MSI_REG, hwirq % IRQS_PER_MSI_REG);
+ 
+ 	return 0;
 }
 
 static int fsl_setup_msi_irqs(struct pci_dev *pdev, int nvec, int type)
@@ -156,7 +174,9 @@ static int fsl_setup_msi_irqs(struct pci_dev *pdev, int nvec, int type)
 		}
 		set_irq_msi(virq, entry);
 
-		fsl_compose_msi_msg(pdev, hwirq, &msg);
+		rc = fsl_compose_msi_msg(pdev, hwirq, &msg);
+		if (rc < 0)
+			goto out_free;
 		write_msi_msg(virq, &msg);
 	}
 	return 0;
@@ -201,6 +221,9 @@ static void fsl_msi_cascade(unsigned int irq, struct irq_desc *desc)
 	case FSL_PIC_IP_IPIC:
 		msir_value = fsl_msi_read(msi_data->msi_regs, msir_index * 0x4);
 		break;
+	case FSL_PIC_IP_VMPIC:
+		fh_vmpic_get_msir(virq_to_hw(irq), &msir_value);
+		break;
 	}
 
 	while (msir_value) {
@@ -218,6 +241,7 @@ static void fsl_msi_cascade(unsigned int irq, struct irq_desc *desc)
 
 	switch (msi_data->feature & FSL_PIC_IP_MASK) {
 	case FSL_PIC_IP_MPIC:
+	case FSL_PIC_IP_VMPIC:
 		desc->chip->eoi(irq);
 		break;
 	case FSL_PIC_IP_IPIC:
@@ -259,17 +283,20 @@ static int __devinit fsl_of_msi_probe(struct of_device *dev,
 	}
 
 	/* Get the MSI reg base */
-	err = of_address_to_resource(dev->node, 0, &res);
-	if (err) {
-		dev_err(&dev->dev, "%s resource error!\n",
-				dev->node->full_name);
-		goto error_out;
-	}
+	if ((features->fsl_pic_ip & FSL_PIC_IP_MASK) != FSL_PIC_IP_VMPIC) {
+		err = of_address_to_resource(dev->node, 0, &res);
+		if (err) {
+			dev_err(&dev->dev, "%s resource error!\n",
+					dev->node->full_name);
+			goto error_out;
+		}
 
-	msi->msi_regs = ioremap(res.start, res.end - res.start + 1);
-	if (!msi->msi_regs) {
-		dev_err(&dev->dev, "ioremap problem failed\n");
-		goto error_out;
+		msi->msi_regs = ioremap(res.start, res.end - res.start + 1);
+		if (!msi->msi_regs) {
+			dev_err(&dev->dev, "ioremap problem failed\n");
+			goto error_out;
+		}
+		msi->msi_addr_lo = res.start + features->msiir_offset;
 	}
 
 	msi->feature = features->fsl_pic_ip;
@@ -277,7 +304,6 @@ static int __devinit fsl_of_msi_probe(struct of_device *dev,
 	msi->irqhost->host_data = msi;
 
 	msi->msi_addr_hi = 0x0;
-	msi->msi_addr_lo = features->msiir_offset + (res.start & 0xfffff);
 
 	rc = fsl_msi_init_allocator(msi);
 	if (rc) {
@@ -322,6 +348,10 @@ error_out:
 	return err;
 }
 
+static const struct fsl_msi_feature vmpic_msi_feature = {
+	.fsl_pic_ip = FSL_PIC_IP_VMPIC,
+};
+
 static const struct fsl_msi_feature mpic_msi_feature = {
 	.fsl_pic_ip = FSL_PIC_IP_MPIC,
 	.msiir_offset = 0x140,
@@ -334,6 +364,10 @@ static const struct fsl_msi_feature ipic_msi_feature = {
 
 static const struct of_device_id fsl_of_msi_ids[] = {
 	{
+		.compatible = "fsl,vmpic-msi",
+		.data = (void *)&vmpic_msi_feature,
+	},
+	{
 		.compatible = "fsl,mpic-msi",
 		.data = (void *)&mpic_msi_feature,
 	},
diff --git a/arch/powerpc/sysdev/fsl_msi.h b/arch/powerpc/sysdev/fsl_msi.h
index 331c7e7..acc5c94 100644
--- a/arch/powerpc/sysdev/fsl_msi.h
+++ b/arch/powerpc/sysdev/fsl_msi.h
@@ -22,6 +22,7 @@
 #define FSL_PIC_IP_MASK	0x0000000F
 #define FSL_PIC_IP_MPIC	0x00000001
 #define FSL_PIC_IP_IPIC	0x00000002
+#define FSL_PIC_IP_VMPIC 0x00000003
 
 struct fsl_msi {
 	struct irq_host *irqhost;
diff --git a/arch/powerpc/sysdev/fsl_rio.c b/arch/powerpc/sysdev/fsl_rio.c
index 71fba88..bcf38f6 100644
--- a/arch/powerpc/sysdev/fsl_rio.c
+++ b/arch/powerpc/sysdev/fsl_rio.c
@@ -1,7 +1,7 @@
 /*
  * Freescale MPC85xx/MPC86xx RapidIO support
  *
- * Copyright (C) 2007, 2008 Freescale Semiconductor, Inc.
+ * Copyright (C) 2007-2009 Freescale Semiconductor, Inc.
  * Zhang Wei <wei.zhang@freescale.com>
  *
  * Copyright 2005 MontaVista Software, Inc.
@@ -32,6 +32,9 @@
 #define IRQ_RIO_TX(m)		(((struct rio_priv *)(m->priv))->txirq)
 #define IRQ_RIO_RX(m)		(((struct rio_priv *)(m->priv))->rxirq)
 
+#define IS_64BIT_DMA		((sizeof(dma_addr_t) == 8) ? 1 : 0)
+#define IS_64BIT_PHYS		((sizeof(phys_addr_t) == 8) ? 1 : 0)
+
 #define RIO_ATMU_REGS_OFFSET	0x10c00
 #define RIO_P_MSG_REGS_OFFSET	0x11000
 #define RIO_S_MSG_REGS_OFFSET	0x13000
@@ -41,6 +44,15 @@
 #define RIO_ISR_AACR_AA		0x1	/* Accept All ID */
 #define RIO_MAINT_WIN_SIZE	0x400000
 #define RIO_DBELL_WIN_SIZE	0x1000
+#define RIO_MAX_INB_ATMU	4
+#define RIO_MAX_OUTB_ATMU	8
+#define RIO_INB_ATMU_REGS_OFFSET	0x10de0
+#define RIO_ATMU_EN_MASK	0x80000000
+
+#define RIO_NREAD		0x4
+#define RIO_NWRITE		0x4
+#define RIO_NWRITE_R		0x5
+#define RIO_NREAD_R		0x5
 
 #define RIO_MSG_OMR_MUI		0x00000002
 #define RIO_MSG_OSR_TE		0x00000080
@@ -84,6 +96,15 @@ struct rio_atmu_regs {
 	u32 pad3[3];
 };
 
+struct rio_inb_atmu_regs {
+	u32 riwtar;
+	u32 pad1;
+	u32 riwbar;
+	u32 pad2;
+	u32 riwar;
+	u32 pad3[3];
+};
+
 struct rio_msg_regs {
 	u32 omr;
 	u32 osr;
@@ -342,6 +363,188 @@ fsl_rio_config_write(struct rio_mport *mport, int index, u16 destid,
 }
 
 /**
+ * fsl_rio_map_inb_mem -- Mapping inbound memory region.
+ * @mport: RapidIO master port
+ * @lstart: Local memory space start address.
+ * @rstart: RapidIO space start address.
+ * @size: The mapping region size.
+ * @flags: Flags for mapping. 0 for using default flags.
+ *
+ * Return: 0 -- Success.
+ *
+ * This function will create the inbound mapping
+ * from rstart to lstart.
+ */
+static int fsl_rio_map_inb_mem(struct rio_mport *mport, dma_addr_t lstart,
+		resource_size_t rstart,	resource_size_t size, u32 flags)
+{
+	int i;
+	struct rio_priv *priv = mport->priv;
+	struct rio_inb_atmu_regs __iomem *inbatmu = (struct rio_inb_atmu_regs *)
+				(priv->regs_win + RIO_INB_ATMU_REGS_OFFSET) - 1;
+	int size_ffs;
+	resource_size_t align;
+
+	if (flags == 0)
+		flags = (RIO_NREAD_R << 4) | RIO_NWRITE_R;
+
+	align = (size < 0x1000) ? 0x1000 : 1 << (__ilog2(size - 1) + 1);
+
+	/* Align the size */
+	if ((lstart + size) > (_ALIGN_DOWN(lstart, align) + align)) {
+		size_ffs = __ffs(_ALIGN_DOWN(lstart + size - 1, align));
+		size = 1 << (size_ffs +	(((_ALIGN_DOWN(lstart, 1 << size_ffs) +
+				(1 << size_ffs)) < (lstart + size)) ? 1 : 0));
+	} else
+		size = align;
+
+	if ((lstart & (size - 1)) != (rstart & (size - 1))) {
+		dev_err(mport->dev, "The local address 0x%llx can not be "
+			"aligned to the same size 0x%llx with the RapidIO "
+			"space address 0x%llx!\n", (unsigned long long)lstart,
+			(unsigned long long)size, (unsigned long long)rstart);
+		return -EINVAL;
+	}
+
+	/* Search for free inbound ATMU */
+	for (i = 1;
+		(i <= RIO_MAX_INB_ATMU) && (inbatmu->riwar & RIO_ATMU_EN_MASK);
+		i++, inbatmu--)
+		;
+
+	if (i > RIO_MAX_INB_ATMU) {
+		dev_err(mport->dev, "No free inbound ATMU!\n");
+		return -EBUSY;
+	}
+	out_be32(&inbatmu->riwtar, ((IS_64BIT_DMA ? (lstart >> 32)
+				& 0xf : 0) << 20) | ((lstart >> 12) & 0xfffff));
+	out_be32(&inbatmu->riwbar, ((IS_64BIT_DMA ? (rstart >> 32)
+				& 0x3 : 0) << 20) | ((rstart >> 12) & 0xfffff));
+	out_be32(&inbatmu->riwar, 0x80000000 | (0xf << 20)
+				| ((flags & 0xff) << 12)
+				| (__ilog2(size) - 1));
+	return 0;
+}
+
+/**
+ * fsl_rio_map_outb_mem -- Mapping outbound memory region.
+ * @mport: RapidIO master port
+ * @lstart: Local memory space start address.
+ * @rstart: RapidIO space start address.
+ * @size: The mapping region size.
+ * @tid: The target RapidIO device id.
+ * @flags: Flags for mapping. 0 for using default flags.
+ *
+ * Return: 0 -- Success.
+ *
+ * This function will create the outbound mapping
+ * from lstart to rstart.
+ */
+static int fsl_rio_map_outb_mem(struct rio_mport *mport, phys_addr_t lstart,
+		resource_size_t rstart,	resource_size_t size,
+		u16 tid, u32 flags)
+{
+	int i;
+	struct rio_priv *priv = mport->priv;
+	struct rio_atmu_regs __iomem *outbatmu = (struct rio_atmu_regs *)
+			(priv->regs_win + RIO_ATMU_REGS_OFFSET) + 1;
+	int size_ffs;
+	resource_size_t align;
+
+	if (flags == 0)
+		flags = (RIO_NREAD << 4) | RIO_NWRITE_R;
+
+	align = (size < 0x1000) ? 0x1000 : 1 << (__ilog2(size - 1) + 1);
+
+	/* Align the size */
+	if ((lstart + size) > (_ALIGN_DOWN(lstart, align) + align)) {
+		size_ffs = __ffs(_ALIGN_DOWN(lstart + size - 1, align));
+		size = 1 << (size_ffs +	(((_ALIGN_DOWN(lstart, 1 << size_ffs) +
+				(1 << size_ffs)) < (lstart + size)) ? 1 : 0));
+	} else
+		size = align;
+
+	if ((lstart & (size - 1)) != (rstart & (size - 1))) {
+		dev_err(mport->dev, "The local address 0x%llx can not be "
+			"aligned to the same size 0x%llx with the RapidIO "
+			"space address 0x%llx!\n", (unsigned long long)lstart,
+			(unsigned long long)size, (unsigned long long)rstart);
+		return -EINVAL;
+	}
+
+	/* Search for free outbound ATMU */
+	for (i = 1;
+	      (i <= RIO_MAX_OUTB_ATMU) && (outbatmu->rowar & RIO_ATMU_EN_MASK);
+	      i++, outbatmu++)
+		;
+
+	if (i > RIO_MAX_OUTB_ATMU) {
+		dev_err(mport->dev, "No free outbound ATMU!\n");
+		return -EBUSY;
+	}
+	out_be32(&outbatmu->rowtar, ((tid & 0x3ff) << 22)
+			| ((IS_64BIT_PHYS ? (rstart >> 32) & 0x3 : 0) << 20)
+			| ((rstart >> 12) & 0xfffff));
+	if (mport->phy_type == RIO_PHY_SERIAL)
+		out_be32(&outbatmu->rowtear, tid >> 10);
+	out_be32(&outbatmu->rowbar, ((IS_64BIT_PHYS ?
+					(lstart >> 32) & 0xf : 0) << 20)
+					| ((lstart >> 12) & 0xfffff));
+	out_be32(&outbatmu->rowar, 0x80000000
+				| ((flags & 0xff) << 12)
+				| (__ilog2(size) - 1));
+	return 0;
+}
+
+/**
+ * fsl_rio_unmap_inb_mem -- Unmapping inbound memory region.
+ * @mport: RapidIO master port
+ * @lstart: Local memory space start address.
+ */
+static void fsl_rio_unmap_inb_mem(struct rio_mport *mport,
+				dma_addr_t lstart)
+{
+	int i;
+	struct rio_priv *priv = mport->priv;
+	struct rio_inb_atmu_regs __iomem *inbatmu = (struct rio_inb_atmu_regs *)
+			(priv->regs_win + RIO_INB_ATMU_REGS_OFFSET) - 1;
+
+	/* Search for inbound ATMU */
+	for (i = 1; i <= RIO_MAX_INB_ATMU ; i++, inbatmu--) {
+		u32 tar = ((IS_64BIT_DMA ? (lstart >> 32) & 0xf : 0) << 20)
+			| ((lstart >> 12) & 0xfffff);
+		if (inbatmu->riwtar == tar) {
+			out_be32(&inbatmu->riwar, ~(RIO_ATMU_EN_MASK));
+			return;
+		}
+	}
+}
+
+/**
+ * fsl_rio_unmap_outb_mem -- Unmapping outbound memory region.
+ * @mport: RapidIO master port
+ * @lstart: Local memory space start address.
+ */
+static void fsl_rio_unmap_outb_mem(struct rio_mport *mport,
+				phys_addr_t lstart)
+{
+	int i;
+	struct rio_priv *priv = mport->priv;
+	struct rio_atmu_regs __iomem *outbatmu = (struct rio_atmu_regs *)
+			(priv->regs_win + RIO_ATMU_REGS_OFFSET) + 1;
+
+	/* Search for outbound ATMU */
+	for (i = 1; i <= RIO_MAX_OUTB_ATMU ; i++, outbatmu++) {
+		u32 bar = ((IS_64BIT_PHYS ? (lstart >> 32) & 0xf : 0) << 20)
+			| ((lstart >> 12) & 0xfffff);
+		if (outbatmu->rowbar == bar) {
+			out_be32(&outbatmu->rowar, ~(RIO_ATMU_EN_MASK));
+			return;
+		}
+	}
+}
+
+/**
  * rio_hw_add_outb_message - Add message to the MPC85xx outbound message queue
  * @mport: Master port with outbound message queue
  * @rdev: Target of outbound message
@@ -952,6 +1155,13 @@ static int fsl_rio_get_cmdline(char *s)
 
 __setup("riohdid=", fsl_rio_get_cmdline);
 
+static struct rio_mem_ops fsl_mem_ops = {
+	.map_inb = fsl_rio_map_inb_mem,
+	.map_outb = fsl_rio_map_outb_mem,
+	.unmap_inb = fsl_rio_unmap_inb_mem,
+	.unmap_outb = fsl_rio_unmap_outb_mem,
+};
+
 static inline void fsl_rio_info(struct device *dev, u32 ccsr)
 {
 	const char *str;
@@ -1028,6 +1238,10 @@ int fsl_rio_setup(struct of_device *dev)
 	}
 	dev_info(&dev->dev, "Of-device full name %s\n", dev->node->full_name);
 	dev_info(&dev->dev, "Regs: %pR\n", &regs);
+ 	dev_info(&dev->dev, "Regs start 0x%llx size 0x%llx\n",
+ 			(unsigned long long)regs.start,
+ 			(unsigned long long)(regs.end - regs.start + 1));
+ 
 
 	dt_range = of_get_property(dev->node, "ranges", &rlen);
 	if (!dt_range) {
@@ -1075,6 +1289,7 @@ int fsl_rio_setup(struct of_device *dev)
 	}
 	port->id = 0;
 	port->index = 0;
+	port->dev = &dev->dev;
 
 	priv = kzalloc(sizeof(struct rio_priv), GFP_KERNEL);
 	if (!priv) {
@@ -1103,6 +1318,7 @@ int fsl_rio_setup(struct of_device *dev)
 	priv->dev = &dev->dev;
 
 	port->ops = ops;
+	port->mops = &fsl_mem_ops;
 	port->host_deviceid = fsl_rio_get_hdid(port->id);
 
 	port->priv = priv;
-- 
1.6.0.3

