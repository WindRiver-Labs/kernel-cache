From 0df3d2fe653441410f96ee10ea320d196420e8e4 Mon Sep 17 00:00:00 2001
From: Emil Medve <Emilian.Medve@Freescale.com>
Date: Thu, 13 May 2010 11:57:40 -0400
Subject: [PATCH 11/11] p4080_1-2 rc1 cardnet

Cardnet and DPA support.

Signed-off-by: Emil Medve <Emilian.Medve@Freescale.com>
Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
Signed-off-by: Li Yang <leoli@freescale.com>
Signed-off-by: Roy Zang <tie-fei.zang@freescale.com>
Signed-off-by: Shlomi Gridish <gridish@freescale.com>
Signed-off-by: Zhang Wei <zw@zh-kernel.org>
[Original headerless patch "p4080_1-2-rc1-cardnet.patch" from FSL SDK 2.0.3
ported to 2.6.34]
Integrated-by: Yuri Nedel <Yuri.Nedel@windriver.com>
---
 drivers/net/Kconfig                 |   49 ++-
 drivers/net/Makefile                |    6 +
 drivers/net/cardnet/Kconfig         |   36 ++
 drivers/net/cardnet/Makefile        |    9 +
 drivers/net/cardnet/pci_agent_drv.c |  521 ++++++++++++++++++++++++
 drivers/net/cardnet/pci_agent_lib.c |  209 ++++++++++
 drivers/net/cardnet/pci_agent_lib.h |  221 ++++++++++
 drivers/net/cardnet/pci_agent_net.c |  756 +++++++++++++++++++++++++++++++++++
 8 files changed, 1792 insertions(+), 15 deletions(-)
 create mode 100644 drivers/net/cardnet/Kconfig
 create mode 100644 drivers/net/cardnet/Makefile
 create mode 100644 drivers/net/cardnet/pci_agent_drv.c
 create mode 100644 drivers/net/cardnet/pci_agent_lib.c
 create mode 100644 drivers/net/cardnet/pci_agent_lib.h
 create mode 100644 drivers/net/cardnet/pci_agent_net.c

diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index e56db99..97cf3de 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -175,6 +175,10 @@ config NET_SB1000
 
 	  If you don't have this card, of course say N.
 
+if PPC_85xx
+	source "drivers/net/cardnet/Kconfig"
+endif
+
 source "drivers/net/arcnet/Kconfig"
 
 source "drivers/net/phy/Kconfig"
@@ -1011,12 +1015,12 @@ config SMC911X
 	help
 	  This is a driver for SMSC's LAN911x series of Ethernet chipsets
 	  including the new LAN9115, LAN9116, LAN9117, and LAN9118.
-	  Say Y if you want it compiled into the kernel, 
+	  Say Y if you want it compiled into the kernel,
 	  and read the Ethernet-HOWTO, available from
 	  <http://www.linuxdoc.org/docs.html#howto>.
 
-	  This driver is also available as a module. The module will be 
-	  called smc911x.  If you want to compile it as a module, say M 
+	  This driver is also available as a module. The module will be
+	  called smc911x.  If you want to compile it as a module, say M
 	  here and read <file:Documentation/kbuild/modules.txt>
 
 config SMSC911X
@@ -1497,9 +1501,9 @@ config E100
 	select MII
 	---help---
 	  This driver supports Intel(R) PRO/100 family of adapters.
-	  To verify that your adapter is supported, find the board ID number 
-	  on the adapter. Look for a label that has a barcode and a number 
-	  in the format 123456-001 (six digits hyphen three digits). 
+	  To verify that your adapter is supported, find the board ID number
+	  on the adapter. Look for a label that has a barcode and a number
+	  in the format 123456-001 (six digits hyphen three digits).
 
 	  Use the above information and the Adapter & Driver ID Guide at:
 
@@ -1511,7 +1515,7 @@ config E100
 
 	  <http://appsr.intel.com/scripts-df/support_intel.asp>
 
-	  More specific information on configuring the driver is in 
+	  More specific information on configuring the driver is in
 	  <file:Documentation/networking/e100.txt>.
 
 	  To compile this driver as a module, choose M here. The module
@@ -2057,7 +2061,7 @@ config E1000
 	depends on PCI
 	---help---
 	  This driver supports Intel(R) PRO/1000 gigabit ethernet family of
-	  adapters.  For more information on how to identify your adapter, go 
+	  adapters.  For more information on how to identify your adapter, go
 	  to the Adapter & Driver ID Guide at:
 
 	  <http://support.intel.com/support/network/adapter/pro100/21397.htm>
@@ -2067,7 +2071,7 @@ config E1000
 
 	  <http://support.intel.com>
 
-	  More specific information on configuring the driver is in 
+	  More specific information on configuring the driver is in
 	  <file:Documentation/networking/e1000.txt>.
 
 	  To compile this driver as a module, choose M here. The module
@@ -2256,7 +2260,7 @@ config SKGE
 	  and related Gigabit Ethernet adapters. It is a new smaller driver
 	  with better performance and more complete ethtool support.
 
-	  It does not support the link failover and network management 
+	  It does not support the link failover and network management
 	  features that "portable" vendor supplied sk98lin driver does.
 
 	  This driver supports adapters based on the original Yukon chipset:
@@ -2707,7 +2711,7 @@ config IXGB
 
 	  <http://support.intel.com>
 
-	  More specific information on configuring the driver is in 
+	  More specific information on configuring the driver is in
 	  <file:Documentation/networking/ixgb.txt>.
 
 	  To compile this driver as a module, choose M here. The module
@@ -2717,8 +2721,8 @@ config S2IO
 	tristate "S2IO 10Gbe XFrame NIC"
 	depends on PCI
 	---help---
-	  This driver supports the 10Gbe XFrame NIC of S2IO. 
-	  More specific information on configuring the driver is in 
+	  This driver supports the 10Gbe XFrame NIC of S2IO.
+	  More specific information on configuring the driver is in
 	  <file:Documentation/networking/s2io.txt>.
 
 config VXGE
@@ -2845,6 +2849,11 @@ config QLGE
 	  To compile this driver as a module, choose M here: the module
 	  will be called qlge.
 
+config DPA
+	tristate "Freescale Data Path Frame Manager Ethernet"
+	depends on FSL_SOC && FSL_BMAN_PORTAL && FSL_QMAN_PORTAL && FSL_QMAN_FQALLOCATOR && FSL_FMAN
+	select PHYLIB
+
 source "drivers/net/sfc/Kconfig"
 
 source "drivers/net/benet/Kconfig"
@@ -2899,6 +2908,16 @@ config RIONET_RX_SIZE
 	depends on RIONET
 	default "128"
 
+config RIONET_MEMMAP
+	bool "Use memory map instead of message"
+	depends on RIONET
+	default n
+
+config RIONET_DMA
+	bool "Use DMA for memory mapping data transfer"
+	depends on RIONET_MEMMAP && FSL_DMA
+	default y
+
 config FDDI
 	tristate "FDDI driver support"
 	depends on (PCI || EISA || TC)
@@ -3171,9 +3190,9 @@ config PPPOE
 	  Support for PPP over Ethernet.
 
 	  This driver requires the latest version of pppd from the CVS
-	  repository at cvs.samba.org.  Alternatively, see the 
+	  repository at cvs.samba.org.  Alternatively, see the
 	  RoaringPenguin package (<http://www.roaringpenguin.com/pppoe>)
-	  which contains instruction on how to use this driver (under 
+	  which contains instruction on how to use this driver (under
 	  the heading "Kernel mode PPPoE").
 
 config PPPOATM
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 49df38a..198a31e 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -28,6 +28,7 @@ obj-$(CONFIG_ATL2) += atlx/
 obj-$(CONFIG_ATL1E) += atl1e/
 obj-$(CONFIG_ATL1C) += atl1c/
 obj-$(CONFIG_GIANFAR) += gianfar_driver.o
+obj-$(if $(CONFIG_DPA),y) += dpa/
 obj-$(CONFIG_TEHUTI) += tehuti.o
 obj-$(CONFIG_ENIC) += enic/
 obj-$(CONFIG_JME) += jme.o
@@ -43,6 +44,11 @@ ucc_geth_driver-objs := ucc_geth.o ucc_geth_ethtool.o
 
 obj-$(CONFIG_FSL_PQ_MDIO) += fsl_pq_mdio.o
 
+ifeq ($(CONFIG_PPC_85xx),y)
+  obj-$(CONFIG_BOARDNET) += cardnet/
+  obj-$(CONFIG_CARDNET) += cardnet/
+endif
+
 #
 # link order important here
 #
diff --git a/drivers/net/cardnet/Kconfig b/drivers/net/cardnet/Kconfig
new file mode 100644
index 0000000..689fe63
--- /dev/null
+++ b/drivers/net/cardnet/Kconfig
@@ -0,0 +1,36 @@
+#
+# Boardnet configuration
+#
+
+menu "MPC85xx PCI agent mode driver"
+	depends on NETDEVICES && PPC_85xx && !PCI
+
+config CARDNET
+	tristate "Cardnet driver support"
+	---help---
+	  cardnet driver is a simulating ethernet driver for and MPC85xxEMDS
+	  board when it acts as PCI agent device.
+	  If MPC85xxEMDS board acts as PCI agent and want to communicate with
+	  the host through PCI interface, enable this cardnet driver and there
+	  will be an ethernet device named cethx in the system. Corporating with
+	  another ethernet device named bethx in the host system, the host and
+	  agent can send package to each other.
+
+endmenu
+
+menu "MPC85xx board PCI demo driver"
+	depends on NETDEVICES && PCI
+
+config BOARDNET
+	tristate "Boardnet driver support"
+	---help---
+	  Boardnet driver is a simulate ethernet driver for MPC85xxE PB
+	  board when it acts as PCI agent device and plused into MPC85xxE PB board.
+	  If MPC85xxE MDS board acts as PCI host and want to communicate
+	  with MPC85xxE PB (agent) through PCI interface,enable this
+	  boardnet driver and there will be an ethernet device named
+	  bethx in the system.
+	  Corporating with another ethernet device named cethx in the
+	  agent system,the host and agent can send package to each other.
+
+endmenu
diff --git a/drivers/net/cardnet/Makefile b/drivers/net/cardnet/Makefile
new file mode 100644
index 0000000..184061b
--- /dev/null
+++ b/drivers/net/cardnet/Makefile
@@ -0,0 +1,9 @@
+#
+# Makefile for the MPC85xxE PCI agent driver
+#
+
+obj-$(CONFIG_CARDNET) += pci_cardnet.o
+obj-$(CONFIG_BOARDNET) += pci_boardnet.o
+
+pci_cardnet-objs := pci_agent_lib.o pci_agent_drv.o
+pci_boardnet-objs := pci_agent_lib.o  pci_agent_net.o
diff --git a/drivers/net/cardnet/pci_agent_drv.c b/drivers/net/cardnet/pci_agent_drv.c
new file mode 100644
index 0000000..6c1de3d
--- /dev/null
+++ b/drivers/net/cardnet/pci_agent_drv.c
@@ -0,0 +1,521 @@
+/*
+ * Copyright (C) 2005-2009 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Author: Xiaobo Xie <X.Xie@freescale.com>
+ *
+ * Description:
+ * PCI Agent/PCI-E EP Ethernet Driver for Freescale PowerPC85xx Processor
+ *
+ * Changelog:
+ * Jan. 2009 Roy Zang <tie-fei.zang@freescale.com>
+ * - Add PCI Express EP support for P4080
+ *
+ * This file is part of the Linux Kernel
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/in.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+#include <linux/skbuff.h>
+#include <linux/in6.h>
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/moduleparam.h>
+
+#include <asm/checksum.h>
+#include <asm/page.h>
+#include <sysdev/fsl_soc.h>
+
+#include "pci_agent_lib.h"
+
+static int eth;
+module_param(eth, int, 0);
+
+#define CARD_TIMEOUT 10
+#define HAVE_TX_TIMEOUT
+#ifdef HAVE_TX_TIMEOUT
+static int timeout = CARD_TIMEOUT;
+module_param(timeout, int, 0);
+#endif
+
+#define NEED_LOCAL_PAGE		0
+
+#define	CTL_STATUS_SIZE	24
+#define	RX_SPACE_SIZE	(2*1024-12)
+#define	TX_SPACE_SIZE	(2*1024-12)
+#define	AGENT_DRIVER_MEM_SIZE	(CTL_STATUS_SIZE+RX_SPACE_SIZE+TX_SPACE_SIZE)
+
+struct cardnet_share_mem {
+	u32	hstatus;
+	u32	astatus;
+
+	u32	rx_flags;
+	u32	rx_packetlen;
+	u8	rxbuf[2*1024 - 12];
+
+	u32	tx_flags;
+	u32	tx_packetlen;
+	u8	txbuf[2*1024 - 12];
+};
+
+struct card_priv {
+	struct cardnet_share_mem *share_mem;
+	void __iomem *mesgu;
+	void __iomem *h_msg;
+
+	struct sk_buff *cur_tx_skb;
+	int rx_packetlen;
+	int tx_packetlen;
+	u32 ccsrbar;
+	int  pci_express;
+	spinlock_t lock; /* lock for set card_priv */
+	struct net_device_stats stats;
+	struct pci_agent_dev *pcidev;
+};
+
+static void card_tx_timeout(struct net_device *dev);
+static irqreturn_t card_interrupt(int irq, void *dev_id);
+
+static inline void pci_agent_cache_flush(void *addr)
+{
+	asm volatile("dcbf %0, %1" : : "r"(0), "r"((uint32_t)addr));
+}
+
+/*
+ * Open and close
+ */
+static int card_open(struct net_device *dev)
+{
+	struct card_priv *tp = dev->priv;
+	int retval;
+	u32 phys_addr;
+	struct pci_agent_dev *pci_dev;
+
+	tp->mesgu = ioremap(get_immrbase() + MPC85xx_MSG_OFFSET,
+				MPC85xx_MSG_SIZE);
+	dev->irq = ppc85xx_interrupt_init(tp->mesgu);
+	retval = request_irq(dev->irq, card_interrupt, IRQF_SHARED,
+					dev->name, dev);
+	if (retval) {
+		printk(KERN_ERR "EXIT, returning %d\n", retval);
+		return retval;
+	}
+
+	tp->share_mem = (struct cardnet_share_mem *)
+				__get_free_pages(GFP_ATOMIC, NEED_LOCAL_PAGE);
+	if (tp->share_mem == NULL)
+		return -ENOMEM;
+
+	phys_addr = virt_to_phys((void *)tp->share_mem);
+
+	memset(tp->share_mem, 0, PAGE_SIZE << NEED_LOCAL_PAGE);
+	tp->pcidev = (struct pci_agent_dev *)
+			kmalloc(sizeof(struct pci_agent_dev), GFP_KERNEL);
+	if (tp->pcidev == NULL)
+		return -ENOMEM;
+
+	pci_dev = tp->pcidev;
+	memset(pci_dev, 0, sizeof(struct pci_agent_dev));
+	pci_dev->mem_addr = (u32)tp->share_mem;
+	pci_dev->local_addr = phys_addr;
+	pci_dev->pci_addr = PCI_SPACE_ADDRESS;
+	pci_dev->mem_size = AGENT_DRIVER_MEM_SIZE;
+	pci_dev->window_num = 1;
+
+	/*Setup inbound window in agent*/
+	retval = setup_agent_inbound_window(pci_dev);
+
+	if (retval == 1)
+		tp->pci_express = 1;
+
+	/*Setup outbound window in agent*/
+	setup_agent_outbound_window(tp->pci_express, 1);
+
+	if (check_mem_region(pci_dev->pci_addr, AGENT_DRIVER_MEM_SIZE)) {
+		printk(KERN_INFO "cardnet:memory already in use!\n");
+		return -EBUSY;
+	}
+	request_mem_region(pci_dev->pci_addr, AGENT_DRIVER_MEM_SIZE,
+				"cardnet");
+
+	if (tp->pci_express)
+		tp->h_msg = (struct mesg_85xx *)ioremap(PCIE_CCSR_BAR +
+						MPC85xx_MSG_OFFSET,
+						MPC85xx_MSG_SIZE);
+	else
+		tp->h_msg = (struct mesg_85xx *)ioremap(PCI_CCSR_BAR +
+						MPC85xx_MSG_OFFSET,
+						MPC85xx_MSG_SIZE);
+
+	dev->mem_start = phys_addr;
+	dev->mem_end = phys_addr + AGENT_DRIVER_MEM_SIZE;
+	dev->base_addr = pci_dev->pci_addr;
+
+	/*
+	 * Assign the hardware address of the agent: use "\0FSLD0",
+	 * The hardware address of the host use "\0FSLD1";
+	 */
+	printk(KERN_INFO "%s device is up\n", dev->name);
+
+	netif_start_queue(dev);
+	return 0;
+}
+
+static int card_release(struct net_device *dev)
+{
+	struct card_priv *tp = dev->priv;
+	struct cardnet_share_mem *share_mem = \
+			(struct cardnet_share_mem *)tp->share_mem;
+	struct pci_agent_dev *pci_dev;
+	pci_dev = tp->pcidev;
+
+	free_pages((unsigned long)share_mem, NEED_LOCAL_PAGE);
+	/* release ports, irq and such*/
+	release_mem_region(pci_dev->pci_addr, AGENT_DRIVER_MEM_SIZE);
+	kfree(tp->pcidev);
+	ppc85xx_clean_interrupt(tp->mesgu);
+	iounmap(tp->mesgu);
+	iounmap(tp->h_msg);
+
+	/* release the irq */
+	synchronize_irq(dev->irq);
+	free_irq(dev->irq, dev);
+	netif_stop_queue(dev); /* can't transmit any more */
+
+	return 0;
+}
+
+/*
+ * Configuration changes (passed on by ifconfig)
+ */
+static int card_config(struct net_device *dev, struct ifmap *map)
+{
+	if (dev->flags & IFF_UP) /* can't act on a running interface */
+		return -EBUSY;
+	/* Don't allow changing the I/O address */
+	if (map->base_addr != dev->base_addr) {
+		printk(KERN_WARNING "cardnet: Can't change I/O address\n");
+		return -EOPNOTSUPP;
+	}
+	/* Allow changing the IRQ */
+	if (map->irq != dev->irq)
+		dev->irq = map->irq;
+
+	/* ignore other fields */
+	return 0;
+}
+
+/*
+ * Receive a packet: retrieve, encapsulate and pass over to upper levels
+ */
+static void card_rx(struct net_device *dev, int len, unsigned char *buf)
+{
+	struct card_priv *priv = (struct card_priv *) dev->priv;
+	struct sk_buff *skb;
+
+	skb = dev_alloc_skb(len+2);
+	if (!skb) {
+		printk(KERN_ERR "card rx: low on mem - packet dropped\n");
+		priv->stats.rx_dropped++;
+		return;
+	}
+
+	skb_reserve(skb, 2);
+	memcpy(skb_put(skb, len), buf, len);
+	/* Write metadata, and then pass to the receive level */
+	skb->dev = dev;
+	skb->protocol = eth_type_trans(skb, dev);
+	skb->ip_summed = CHECKSUM_UNNECESSARY; /* don't check it */
+	priv->stats.rx_packets++;
+	priv->stats.rx_bytes += len;
+
+	netif_rx(skb);
+	return;
+}
+
+/*
+ * The interrupt entry point
+ */
+static irqreturn_t card_interrupt(int irq, void *dev_id)
+{
+	struct card_priv *priv;
+	struct cardnet_share_mem *shmem;
+	u32  statusword = 0;
+	int len;
+	struct net_device *dev = (struct net_device *)dev_id;
+
+	if (!dev)
+		return IRQ_NONE;
+	priv = (struct card_priv *) dev->priv;
+
+	/* Lock the device */
+	spin_lock(&priv->lock);
+	shmem = (struct cardnet_share_mem *) priv->share_mem;
+
+	ppc85xx_readmsg(&statusword, priv->mesgu);
+
+	if (statusword & HOST_SENT) {
+		len = shmem->rx_packetlen;
+		card_rx(dev, len, shmem->rxbuf);
+		shmem->astatus = AGENT_GET;
+	} else {
+		printk(KERN_INFO "The message is not for me!message=0x%x\n",
+					statusword);
+		spin_unlock(&priv->lock);
+		return IRQ_NONE;
+	}
+
+	/* Unlock the device and we are done */
+	spin_unlock(&priv->lock);
+	return IRQ_HANDLED;
+}
+
+/*
+ * Transmit a packet (called by the kernel)
+ */
+static int card_tx(struct sk_buff *skb, struct net_device *dev)
+{
+	int len;
+	int j = 0, count = 0;
+	char *data;
+	struct card_priv *priv = (struct card_priv *) dev->priv;
+	struct cardnet_share_mem *shmem =
+				(struct cardnet_share_mem *)priv->share_mem;
+
+	if (skb == NULL) {
+		printk(KERN_ERR "skb is NULL\n");
+		return 0;
+	}
+
+	len = skb->len < ETH_ZLEN ? ETH_ZLEN : skb->len;
+	if (len < sizeof(struct ethhdr) + sizeof(struct iphdr)) {
+		printk(KERN_INFO "packet too short (%i octets)\n", len);
+		priv->stats.tx_dropped++;
+		dev_kfree_skb(skb);
+		return 0;
+	}
+	if (len > 2032) {
+		printk(KERN_INFO "packet too long (%i octets)\n", len);
+		priv->stats.tx_dropped++;
+		dev_kfree_skb(skb);
+		return 0;
+	}
+
+	spin_lock(&priv->lock);
+
+	data = skb->data;
+	dev->trans_start = jiffies; /* save the timestamp */
+	priv->cur_tx_skb = skb;
+	priv->tx_packetlen = len;
+
+	while (shmem->hstatus) {
+		udelay(20); j++;
+		if (j > 1000)
+			break;
+	}
+	if (j > 1000) {
+		netif_stop_queue(dev);
+		priv->stats.tx_dropped++;
+		dev_kfree_skb(priv->cur_tx_skb);
+		spin_unlock(&priv->lock);
+		return 0;
+	}
+
+	shmem->tx_flags = ++count;
+	shmem->tx_packetlen = len;
+	memcpy(shmem->txbuf, data, len);
+	shmem->hstatus = AGENT_SENT;
+
+	dev_kfree_skb(priv->cur_tx_skb);
+	priv->stats.tx_packets++;
+	priv->stats.tx_bytes += priv->tx_packetlen;
+
+	ppc85xx_trigger_intr(AGENT_SENT, priv->h_msg);
+	spin_unlock(&priv->lock);
+	return 0;
+}
+
+/*
+ * Deal with a transmit timeout.
+ */
+static void card_tx_timeout(struct net_device *dev)
+{
+	struct card_priv *priv = (struct card_priv *) dev->priv;
+
+	printk(KERN_INFO "Transmit timeout at %ld, latency %ld\n",
+		jiffies, jiffies - dev->trans_start);
+
+	ppc85xx_clean_interrupt(priv->h_msg);
+
+	/*When timeout, try to kick the EP*/
+	ppc85xx_trigger_intr(HOST_SENT, priv->mesgu);
+	priv->stats.tx_errors++;
+	netif_wake_queue(dev);
+	return;
+}
+
+/*
+ * Ioctl commands
+ */
+static int card_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	printk(KERN_DEBUG "ioctl\n");
+	return 0;
+}
+
+static struct net_device_stats *card_stats(struct net_device *dev)
+{
+	struct card_priv *priv = (struct card_priv *) dev->priv;
+	return &priv->stats;
+}
+
+static int card_rebuild_header(struct sk_buff *skb)
+{
+	struct ethhdr *eth = (struct ethhdr *) skb->data;
+	struct net_device *dev = skb->dev;
+
+	memcpy(eth->h_source, dev->dev_addr, dev->addr_len);
+	memcpy(eth->h_dest, dev->dev_addr, dev->addr_len);
+	eth->h_dest[ETH_ALEN-1] ^= 0x01; /* dest is us xor 1 */
+
+	return 0;
+}
+
+static int card_header(struct sk_buff *skb, struct net_device *dev,
+		unsigned short type, void *daddr, const void *saddr,
+		unsigned int len)
+{
+	struct ethhdr *eth = (struct ethhdr *)skb_push(skb, ETH_HLEN);
+
+	eth->h_proto = htons(type);
+	memcpy(eth->h_source, dev->dev_addr, dev->addr_len);
+	memcpy(eth->h_dest,   dev->dev_addr, dev->addr_len);
+	eth->h_dest[ETH_ALEN-1] ^= 0x01;
+	return dev->hard_header_len;
+}
+
+static int card_change_mtu(struct net_device *dev, int new_mtu)
+{
+	spinlock_t *lock = &((struct card_priv *) dev->priv)->lock;
+	unsigned long flags;
+
+	/* check ranges */
+	if ((new_mtu < 68) || (new_mtu > 1500))
+		return -EINVAL;
+	spin_lock_irqsave(lock, flags);
+	dev->mtu = new_mtu;
+	spin_unlock_irqrestore(lock, flags);
+	return 0; /* success */
+}
+
+static const struct header_ops card_header_ops = {
+	.create = card_header,
+	.rebuild = card_rebuild_header,
+};
+
+/*
+ * init function.
+ */
+static void card_init(struct net_device *dev)
+{
+	struct card_priv *priv;
+	ether_setup(dev); /* assign some of the fields */
+	dev->open		= card_open;
+	dev->stop		= card_release;
+	dev->set_config		= card_config;
+	dev->hard_start_xmit	= card_tx;
+	dev->do_ioctl		= card_ioctl;
+	dev->get_stats		= card_stats;
+	dev->change_mtu		= card_change_mtu;
+	dev->header_ops		= &card_header_ops;
+	memcpy(dev->dev_addr, "\0FSLD0", ETH_ALEN);
+
+#ifdef HAVE_TX_TIMEOUT
+	dev->tx_timeout		= card_tx_timeout;
+	dev->watchdog_timeo	= 2 * HZ;
+#endif
+	/* keep the default flags, just add NOARP */
+	dev->flags	|= IFF_NOARP;
+	dev->features	|= NETIF_F_NO_CSUM;
+
+	/*
+	 * Then, allocate the priv field. This encloses the statistics
+	 * and a few private fields.
+	 */
+	priv = netdev_priv(dev);
+	memset(priv, 0, sizeof(struct card_priv));
+
+	spin_lock_init(&((struct card_priv *) dev->priv)->lock);
+	return;
+}
+
+/*
+ * The devices
+ */
+static struct net_device *card_devs;
+
+static __init int card_init_module(void)
+{
+	int result, device_present = 0;
+	int card_eth;
+	char interface_name[16];
+
+	card_eth = eth; /* copy the cfg datum in the non-static place */
+	if (!card_eth)
+		strcpy(interface_name, "ceth%d");
+	else
+		strcpy(interface_name, "eth%d");
+
+	card_devs = alloc_netdev(sizeof(struct card_priv),
+					interface_name, card_init);
+	if (card_devs == NULL)
+		return -ENODEV;
+
+	result = register_netdev(card_devs);
+	if (result) {
+		printk(KERN_ERR "card: error %i registering device \"%s\"\n",
+			result, interface_name);
+		free_netdev(card_devs);
+	} else
+		device_present++;
+	printk(KERN_INFO "register device named-----%s\n", card_devs->name);
+	printk(KERN_INFO "mpc85xx agent drvier init succeed\n");
+
+	return device_present ? 0 : -ENODEV;
+}
+
+static __exit void card_cleanup(void)
+{
+	unregister_netdev(card_devs);
+	free_netdev(card_devs);
+	return;
+}
+module_init(card_init_module);
+module_exit(card_cleanup);
+
+MODULE_AUTHOR("Xiaobo Xie<X.Xie@freescale.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("MPC85xx Processor PCI Agent Ethernet Driver");
diff --git a/drivers/net/cardnet/pci_agent_lib.c b/drivers/net/cardnet/pci_agent_lib.c
new file mode 100644
index 0000000..03a8e6f
--- /dev/null
+++ b/drivers/net/cardnet/pci_agent_lib.c
@@ -0,0 +1,209 @@
+/*
+ * Copyright (C) 2005-2009 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Author: Xiaobo Xie <X.Xie@freescale.com>
+ *
+ * Description:
+ * Freescale MPC85xx PCIE EP and PCI Agent basic lib
+ *
+ * Changelog:
+ *
+ * This file is part of the Linux Kernel
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/of_platform.h>
+
+#include <asm/page.h>
+#include <asm/byteorder.h>
+#include <sysdev/fsl_soc.h>
+
+#include "pci_agent_lib.h"
+
+int setup_host_inbound_window(int pcie)
+{
+	volatile struct pcictrl85xx *pci;
+	u32 value;
+	u32 pci_addr;
+	int order = 0;
+	int winno = 0;
+
+	winno = PCI_IBW_NUM - 1;
+
+	if (winno < 0 || winno >= PCI_IBW_NUM) {
+		printk(KERN_ERR "Window %d dose not exist\n", winno);
+		return -1;
+	}
+	if (pcie) {
+		pci = (struct pcictrl85xx *)ioremap(get_immrbase() +
+						MPC85xx_PCIE_OFFSET,
+						MPC85xx_PCIE_SIZE);
+		pci_addr = PCIE_CCSR_BUS;
+	} else {
+		pci = (struct pcictrl85xx *)ioremap(get_immrbase() +
+						MPC85xx_PCI1_OFFSET,
+						MPC85xx_PCI1_SIZE);
+		pci_addr = PCI_CCSR_BUS;
+	}
+
+	value = IMMRBAR_SIZE;
+	while ((value = value>>1) > 1)
+		order++;
+
+	value = get_immrbase();
+	pci->pci_ibw[winno].pitar = (value >> 12) & PITAR_TA_MASK;
+	pci->pci_ibw[winno].piwbar = pci_addr >> 12;
+	pci->pci_ibw[winno].piwar = PIWAR_EN | PIWAR_TRGT_MEM |
+				PIWAR_RTT_SNOOP | PIWAR_WTT_SNOOP | order;
+
+	iounmap((void __iomem *)pci);
+	return 0;
+}
+
+int setup_agent_inbound_window(struct pci_agent_dev *dev)
+{
+	volatile struct pcictrl85xx *pci;
+	u32 value;
+	int order = 0;
+	int winno = 0;
+
+	winno = PCI_IBW_NUM - dev->window_num;
+
+	if (winno < 0 || winno >= PCI_IBW_NUM) {
+		printk(KERN_ERR "Window %d dose not exist\n", winno);
+		return -1;
+	}
+
+	pci = (struct pcictrl85xx *)ioremap(get_immrbase() +
+					MPC85xx_PCIE_OFFSET,
+					MPC85xx_PCIE_SIZE);
+
+	value = pci->pci_ibw[winno].piwar;
+	if (value & PIWAR_EN) {
+		value = dev->mem_size;
+		while ((value = value>>1) > 1)
+			order++;
+
+		pci->pci_ibw[winno].pitar = (dev->local_addr>>12) &
+							PITAR_TA_MASK;
+		pci->pci_ibw[winno].piwar = PIWAR_EN | PIWAR_TRGT_MEM |
+				PIWAR_RTT_SNOOP | PIWAR_WTT_SNOOP | order;
+
+		iounmap((void __iomem *)pci);
+		return 1;
+	} else {
+		iounmap((void __iomem *)pci);
+		return -1;
+	}
+}
+
+int setup_agent_outbound_window(int pcie, int winno)
+{
+	volatile struct pcictrl85xx *pci;
+	u32 value;
+	u32 pci_addr;
+	u32 phy_addr;
+	int order = 0;
+
+	if (winno < 0 || winno > PCI_OBW_NUM) {
+		printk(KERN_ERR "Window %d dose not exist\n", winno);
+		return -1;
+	}
+
+	if (pcie) {
+		pci = (struct pcictrl85xx *)ioremap(get_immrbase() +
+						MPC85xx_PCIE_OFFSET,
+						MPC85xx_PCIE_SIZE);
+		phy_addr = PCIE_CCSR_BAR;
+		pci_addr = PCIE_CCSR_BUS;
+	} else {
+		pci = (struct pcictrl85xx *)ioremap(get_immrbase() +
+						MPC85xx_PCI1_OFFSET,
+						MPC85xx_PCI1_SIZE);
+		phy_addr = PCI_CCSR_BAR;
+		pci_addr = PCI_CCSR_BUS;
+	}
+
+	value = IMMRBAR_SIZE;
+	while ((value = value>>1) > 1)
+		order++;
+
+	pci->pci_obw[winno].potar = (pci_addr>>12) & POTAR_TA_MASK;
+	pci->pci_obw[winno].powbar = (phy_addr>>12);
+	pci->pci_obw[winno].powar = POWAR_EN | RTT_MEMORY_READ |
+					WTT_MEMORY_WRITE | order;
+
+	iounmap((void __iomem *)pci);
+	return 0;
+}
+
+int ppc85xx_interrupt_init(void __iomem *messageu)
+{
+	volatile struct mesg_85xx *messager;
+	struct device_node *np;
+
+	messager = (struct mesg_85xx *)messageu;
+
+	messager->mer = MU_MER_ENABLE;
+	messager->msr = MU_MSR_CLR;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,mpic-msg");
+	if (np) {
+		int irq;
+		irq = irq_of_parse_and_map(np, 0);
+		of_node_put(np);
+		return irq;
+	} else {
+		printk(KERN_INFO "the device node isn't exist!\n");
+		return 0;
+	}
+}
+
+int ppc85xx_trigger_intr(u32 message, void __iomem *messageu)
+{
+	volatile struct mesg_85xx *messager;
+
+	messager = (struct mesg_85xx *)messageu;
+
+	out_be32(&(messager->msgr0), message);
+
+	return 0;
+}
+
+int ppc85xx_readmsg(u32 *message, void __iomem *messageu)
+{
+	volatile struct mesg_85xx *messager;
+
+	messager = (struct mesg_85xx *)messageu;
+
+	*message = in_be32(&(messager->msgr0));
+	return 0;
+}
+
+int ppc85xx_clean_interrupt(void __iomem *messageu)
+{
+	volatile struct mesg_85xx *messager;
+	u32 status;
+
+	messager = (struct mesg_85xx *)messageu;
+	status = messager->msr;
+	out_be32(&(messager->msr), (status & MU_MSR0_CLR));
+	return 0;
+}
diff --git a/drivers/net/cardnet/pci_agent_lib.h b/drivers/net/cardnet/pci_agent_lib.h
new file mode 100644
index 0000000..456dda4
--- /dev/null
+++ b/drivers/net/cardnet/pci_agent_lib.h
@@ -0,0 +1,221 @@
+/*
+ * Copyright (C) 2005-2009 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Author: Xiaobo Xie <X.Xie@freescale.com>
+ *
+ * Description:
+ * Freescale mpc85xx pci/pcie control registers memory map.
+ *
+ * Changelog:
+ * Jan. 2009 Roy Zang <tie-fei.zang@freescale.com>
+ * - Add PCI Express define for P4080
+ *
+ * This file is part of the Linux Kernel
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef PCI_AGENT_LIB_H
+#define PCI_AGENT_LIB_H
+
+#define PCI_VENDOR_ID_FREESCALE	0x1957
+#define PCI_VENDOR_ID_MOTOROLA 0x1057
+#define	PCI_DEVICE_ID_MPC8568E	0x0020
+#define	PCI_DEVICE_ID_P4080	0x0400
+
+#define PPC85XX_NETDRV_NAME	"boardnet: PPC85xx PCI Agent Ethernet Driver"
+#define DRV_VERSION		"1.1"
+
+#define PFX PPC85XX_NETDRV_NAME ": "
+
+#define	IMMRBAR_SIZE	0x01000000
+
+#define	AGENT_MEM_BASE_ADDR	0x00
+#define	AGENT_MEM_SIZE		0x00001000
+
+#define	HOST_LOCAL_SPACE_ADDR	0x80000000
+#define	PCI_SPACE_ADDRESS	0x80000000
+#define PCIE_SPACE_ADDRESS	0xa0000000
+#define PCI_EXPRESS_MEM		0x20000000
+
+#define PCI_CCSR_BAR		0x9ff00000
+#define PCI_CCSR_BUS		PCI_CCSR_BAR
+/* for p4080 pcie1 */
+
+#define PCIE_CCSR_BAR		0x80000000
+#define PCIE_CCSR_BUS		(PCIE_CCSR_BAR + 0x10000000)
+
+#define MPC85xx_PCI1_OFFSET	0x8C00
+#define MPC85xx_PCI1_SIZE	0x200
+/* for p4080 pcie 1 */
+#define MPC85xx_PCIE_OFFSET	0x200c00
+#define MPC85xx_PCIE_SIZE	0x200
+#define MPC85xx_MSG_OFFSET	0x41400
+#define MPC85xx_MSG_SIZE	0x200
+#define MPC85xx_MSGVP_OFFSET	0x51600
+#define MPC85xx_MSGVP_SIZE	0x600
+
+#define PCI_IBW_NUM		3
+#define PCI_OBW_NUM		5
+
+/*
+ * PCI Controller Control and Status Registers
+ */
+struct pci_ob_w {
+	u32	potar;
+	u32	potear;
+	u32	powbar;
+	u8	res0[4];
+	u32	powar;
+	u8	res1[12];
+};
+
+struct pci_ib_w {
+	u32	pitar;
+	u8	res0[4];
+	u32	piwbar;
+	u32	piwbear;
+	u32	piwar;
+	u8	res1[12];
+};
+
+struct pcictrl85xx {
+	struct pci_ob_w	pci_obw[5];
+	u8		res0[256];
+	struct pci_ib_w	pci_ibw[3];
+};
+
+/* For outbound window */
+#define POTAR_TA_MASK		0x000fffff
+#define POWAR_EN		0x80000000
+#define RTT_MEMORY_READ		0x00040000
+#define WTT_MEMORY_WRITE	0x00004000
+
+/* For inbound window */
+#define PITAR_TA_MASK		0x000fffff
+#define PIBAR_MASK		0xffffffff
+#define PIEBAR_EBA_MASK		0x000fffff
+#define PIWAR_EN		0x80000000
+#define PIWAR_PF		0x20000000
+#define PIWAR_TRGT_MEM		0x00f00000
+#define PIWAR_RTT_MASK		0x000f0000
+#define PIWAR_RTT_NO_SNOOP	0x00040000
+#define PIWAR_RTT_SNOOP		0x00050000
+#define PIWAR_WTT_MASK		0x0000f000
+#define PIWAR_WTT_NO_SNOOP	0x00004000
+#define PIWAR_WTT_SNOOP		0x00005000
+#define PIWAR_IWS_MASK		0x0000003F
+#define PIWAR_IWS_4K		0x0000000B
+#define PIWAR_IWS_8K		0x0000000C
+#define PIWAR_IWS_16K		0x0000000D
+#define PIWAR_IWS_32K		0x0000000E
+#define PIWAR_IWS_64K		0x0000000F
+#define PIWAR_IWS_128K		0x00000010
+#define PIWAR_IWS_256K		0x00000011
+#define PIWAR_IWS_512K		0x00000012
+#define PIWAR_IWS_1M		0x00000013
+#define PIWAR_IWS_2M		0x00000014
+#define PIWAR_IWS_4M		0x00000015
+#define PIWAR_IWS_8M		0x00000016
+#define PIWAR_IWS_16M		0x00000017
+#define PIWAR_IWS_32M		0x00000018
+#define PIWAR_IWS_64M		0x00000019
+#define PIWAR_IWS_128M		0x0000001A
+#define PIWAR_IWS_256M		0x0000001B
+#define PIWAR_IWS_512M		0x0000001C
+#define PIWAR_IWS_1G		0x0000001D
+#define PIWAR_IWS_2G		0x0000001E
+
+struct mesg_85xx {
+	u32	msgr0;
+	u8	res0[12];
+	u32	msgr1;
+	u8	res1[12];
+	u32	msgr2;
+	u8	res2[12];
+	u32	msgr3;
+	u8	res3[204];
+	u32	mer;
+	u8	res4[12];
+	u32	msr;
+	u8	res5[236];
+};
+
+#define MU_MER_ENABLE	0x0000000F
+#define MU_MSR_CLR	0x0000000F
+#define MU_MSR0_CLR	0x00000001
+#define MU_MSR1_CLR	0x00000002
+
+struct msgvp_85xx {
+	u32	mivpr0;
+	u8	res0[12];
+	u32	midr0;
+	u8	res1[12];
+	u32	mivpr1;
+	u8	res2[12];
+	u32	midr1;
+	u8	res3[12];
+	u32	mivpr2;
+	u8	res4[12];
+	u32	midr2;
+	u8	res5[12];
+	u32	mivpr3;
+	u8	res6[12];
+	u32	midr3;
+	u8	res7[1420];
+};
+
+#ifdef BOARDNET_NDEBUG
+# define assert(expr) do {} while (0)
+#else
+# define assert(expr) \
+	if (!(expr)) {							\
+	printk(KERN_DEBUG "Assertion failed! %s,%s,%s,line=%d\n",	\
+		#expr, __FILE__, __FUNCTION__, __LINE__);		\
+	}
+#endif
+
+/* These are the flags in the message register */
+/* tx, rx and device flags */
+#define	AGENT_SENT		0x00000001
+#define	AGENT_GET		0x00000000
+#define	HOST_SENT		0x00000001
+#define HOST_GET		0x00000000
+#define	DEV_TBUSY		0x00000001
+
+/* Define max packet buffer */
+#define	MAX_PACKET_BUF		(2*1024)
+#define NEED_LOCAL_PAGE		0
+
+/* Default timeout period */
+#define	BOARDNET_TIMEOUT	5	/* In jiffies */
+
+struct base_addr_reg {
+	uint32_t start;
+	uint32_t end;
+	uint32_t len;
+	uint32_t flags;
+};
+
+struct pci_agent_dev {
+	u32	local_addr;
+	u32	mem_addr;
+	u32	mem_size;
+	u32	pci_addr;
+	u32	window_num;
+	u32	irq;
+	u32	message;
+};
+
+extern int setup_agent_inbound_window(struct pci_agent_dev *dev);
+extern int setup_host_inbound_window(int);
+extern int setup_agent_outbound_window(int, int);
+extern int ppc85xx_interrupt_init(void __iomem *);
+extern int ppc85xx_clean_interrupt(void __iomem *);
+extern int ppc85xx_trigger_intr(u32, void __iomem *);
+extern int ppc85xx_readmsg(u32 *, void __iomem *);
+
+#endif
diff --git a/drivers/net/cardnet/pci_agent_net.c b/drivers/net/cardnet/pci_agent_net.c
new file mode 100644
index 0000000..a5d50ac
--- /dev/null
+++ b/drivers/net/cardnet/pci_agent_net.c
@@ -0,0 +1,756 @@
+/*
+ * Copyright (C) 2005-2009 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Author: Xiaobo Xie <r63061@freescale.com>
+ *
+ * Description:
+ * PCI Agent Ethernet Driver for Freescale PowerPC85xx Processor
+ * PCIE EP Ethernet Driver for Freescale PowerPC85xx Processor
+ *
+ * Changelog:
+ * Mon Mar. 10 2008 Roy Zang <tie-fei.zang@freescale.com>
+ * - Add PCI Express EP support
+ *
+ * This file is part of the Linux Kernel
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/if.h>
+#include <linux/if_ether.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/ip.h>
+#include <linux/delay.h>
+#include <linux/skbuff.h>
+#include <linux/delay.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+#include <linux/of_platform.h>
+
+#include <sysdev/fsl_soc.h>
+#include "pci_agent_lib.h"
+
+/*
+ * Debug switch
+ */
+
+#define DEBUG
+#ifdef DEBUG
+  #define DPRINTK(fmt, args...)   printk(KERN_DEBUG "%s: " fmt, \
+					__FUNCTION__ , ##args)
+#else
+  #define DPRINTK(fmt, args...)
+#endif
+
+struct share_mem {
+	u32 hstatus;
+	u32 astatus;
+
+	u32 tx_flags;
+	u32 tx_packetlen;
+	u8 txbuf[MAX_PACKET_BUF - 12];
+
+	u32 rx_flags;
+	u32 rx_packetlen;
+	u8 rxbuf[MAX_PACKET_BUF - 12];
+};
+
+struct boardnet_private {
+	u32 m_immrbar;
+	void *m_ioaddr;
+	void __iomem *mesgu;
+	void *dmabase;
+	struct net_device_stats stats;
+	struct pci_dev *pci_dev;
+	u32 local_mem_phy;
+	u32 phy_ioaddr;
+	u32 size;
+
+	int pci_express;
+
+	int irq;
+	spinlock_t lock; /* lock for set private data */
+
+	struct sk_buff *skb;
+};
+
+static int boardnet_open(struct net_device *dev);
+static int boardnet_release(struct net_device *dev);
+static int boardnet_config(struct net_device *dev, struct ifmap *map);
+static void boardnet_hw_tx(char *buf, int len, struct net_device *dev);
+static int boardnet_start_xmit(struct sk_buff *skb, struct net_device *dev);
+static void boardnet_rx(struct net_device *dev);
+static void boardnet_tx_timeout(struct net_device *dev);
+static int boardnet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+static struct net_device_stats *boardnet_get_stats(struct net_device *dev);
+static int boardnet_rebuild_header(struct sk_buff *skb);
+static int boardnet_header(struct sk_buff *skb, struct net_device *dev,
+			unsigned short type, void *daddr, const void *saddr,
+			unsigned int len);
+static int boardnet_change_mtu(struct net_device *dev, int new_mtu);
+static irqreturn_t boardnet_interrupt(int irq, void *dev_id);
+
+static int eth;
+
+static inline void cache_flush(void *addr)
+{
+	asm volatile("dcbf %0, %1" : : "r"(0), "r"((uint32_t)addr));
+}
+
+/*
+ * Open: Init status, register irq and enable start
+ */
+static int boardnet_open(struct net_device *dev)
+{
+	int retval;
+	retval = request_irq(dev->irq, boardnet_interrupt, IRQF_SHARED,
+				dev->name, dev);
+	if (retval)
+		return retval;
+
+	/*
+	* Assign the hardware address of the board: use "\0FSLD1"
+	*/
+
+	netif_start_queue(dev);
+
+	printk(KERN_INFO "%s is up\n", dev->name);
+	return 0;
+}
+
+/*
+ * Close: Undo all done in open function
+ */
+static int boardnet_release(struct net_device *dev)
+{
+
+	netif_stop_queue(dev); /* can't transmit any more */
+
+	synchronize_irq(dev->irq);
+	free_irq(dev->irq, dev);
+	printk(KERN_INFO "%s is down\n", dev->name);
+	return 0;
+}
+
+/*
+ * Configuration changes (passed on by ifconfig)
+ */
+static int boardnet_config(struct net_device *dev, struct ifmap *map)
+{
+	if (dev->flags & IFF_UP) /* can't act on a running interface */
+		return -EBUSY;
+
+	/* Don't allow changing the I/O address */
+	if (map->base_addr != dev->base_addr) {
+		printk(KERN_WARNING "Methernet: Can't change I/O address\n");
+		return -EOPNOTSUPP;
+	}
+
+	/* Allow changing the IRQ */
+	if (map->irq != dev->irq) {
+		dev->irq = map->irq;
+		/* request_irq() is delayed to open-time */
+	}
+	return 0;
+}
+
+/*
+ * Receive a packet: retrieve, encapsulate and pass over
+ * to upper levels
+ */
+static void boardnet_rx(struct net_device *dev)
+{
+	struct boardnet_private *priv = netdev_priv(dev);
+	struct share_mem *shmem = priv->m_ioaddr;
+	int len = 0;
+	struct sk_buff *skb;
+	u32 *src;
+	u32 *dest;
+	u32 skblen, temp;
+
+	len = shmem->rx_packetlen;
+	if (len < sizeof(struct ethhdr) + sizeof(struct iphdr)) {
+		DPRINTK("Methernet: Hmm... packet is too short (%i octets)\n",
+			shmem->rx_packetlen);
+		shmem->hstatus = HOST_GET;
+		priv->stats.rx_errors++;
+		return;
+	}
+
+	/*
+	* The packet has been retrieved from the transmission
+	* medium. Build an skb around it, so upper layers can handle it
+	*/
+	skb = dev_alloc_skb(len + 2);
+	if (!skb) {
+		printk(KERN_WARNING
+			"Methernet rx: low on mem-packet dropped\n");
+		priv->stats.rx_dropped++;
+		return;
+	}
+	skb_reserve(skb, 2); /* align IP on 16B boundary */
+
+	dest = (u32 *)skb_put(skb, len);
+	src = (u32 *)shmem->rxbuf;
+	skblen = len;
+
+	while (skblen > 0) {
+		if (skblen < 4) {
+			temp = in_be32(src);
+			memcpy(dest, &(temp), skblen);
+			break;
+		} else {
+			*dest = in_be32(src);
+		}
+		src++;
+		dest++;
+		skblen = skblen - 4;
+	}
+
+	/* Write metadata, and then pass to the receive level */
+	skb->dev = dev;
+	skb->protocol = eth_type_trans(skb, dev);
+	skb->ip_summed = CHECKSUM_UNNECESSARY; /* don't check it */
+	priv->stats.rx_packets++;
+	priv->stats.rx_bytes += len;
+
+	shmem->hstatus = HOST_GET;
+	netif_rx(skb);
+	return;
+}
+
+/*
+ * The interrupt entry point
+ */
+static irqreturn_t boardnet_interrupt(int irq, void *dev_id)
+{
+	uint32_t statusword;
+
+	struct net_device *dev = (struct net_device *)dev_id;
+	struct boardnet_private *priv = netdev_priv(dev);
+	struct share_mem *smem;
+
+	if (!dev)
+		return IRQ_NONE;
+
+	smem = (struct share_mem *)priv->m_ioaddr;
+
+	/* Lock the device */
+	spin_lock(&priv->lock);
+	ppc85xx_readmsg(&statusword, priv->mesgu);
+	if (!(statusword & AGENT_SENT)) {
+		spin_unlock(&priv->lock);
+		return IRQ_NONE;
+	}
+	if (smem->hstatus != HOST_GET)
+		boardnet_rx(dev);
+
+	spin_unlock(&priv->lock);
+	return IRQ_HANDLED;
+}
+
+/*
+ * Transmit a packet (low level interface)
+ */
+static void boardnet_hw_tx(char *buf, int len, struct net_device *dev)
+{
+	struct boardnet_private *priv = netdev_priv(dev);
+	struct share_mem *shmem = priv->m_ioaddr;
+	u32 message;
+	u32 *src;
+	u32 *dest;
+	u32 skblen, temp;
+
+	if (len < sizeof(struct ethhdr) + sizeof(struct iphdr)) {
+		DPRINTK("Methernet: packet is too short (%i octets)\n", len);
+		priv->stats.tx_errors++;
+		dev_kfree_skb(priv->skb);
+		return;
+	}
+
+	if (len > 2032) {
+		printk(KERN_INFO "packet too long (%i octets)\n", len);
+		priv->stats.tx_dropped++;
+		dev_kfree_skb(priv->skb);
+		return;
+	}
+
+	/* Send out the packet */
+	src = (u32 *)buf;
+	dest = (u32 *)shmem->txbuf;
+	skblen = len;
+
+	while (skblen > 0) {
+		if (skblen < 4) {
+			memcpy(&(temp), src, skblen);
+			out_be32(dest, temp);
+			break;
+		} else {
+			out_be32(dest, *src);
+		}
+		src++;
+		dest++;
+		skblen = skblen - 4;
+	}
+
+	shmem->tx_packetlen = len;
+
+	/* Update the statitic data */
+	priv->stats.tx_packets++;
+	priv->stats.tx_bytes += len;
+
+	/* Set the flag, indicating the peer that the packet has been sent */
+	shmem->astatus |= HOST_SENT;
+
+	message = HOST_SENT;
+	ppc85xx_trigger_intr(message,
+			(void __iomem *)(priv->m_immrbar + MPC85xx_MSG_OFFSET));
+
+	dev_kfree_skb(priv->skb);
+	return;
+}
+
+/*
+ * Transmit a packet (called by the kernel)
+ * This is called by the kernel when a packet is ready for transmission
+ */
+static int boardnet_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct boardnet_private *priv = netdev_priv(dev);
+	struct share_mem *shmem = priv->m_ioaddr;
+	char *data, shortpkt[ETH_ZLEN];
+	int time_out = 100;
+	int len;
+
+	while (shmem->astatus & DEV_TBUSY) {
+		udelay(2);
+		time_out--;
+		if (!time_out) {
+			DPRINTK("tint for %p, tbusy, skb %p\n", dev, skb);
+			netif_stop_queue(dev);
+			priv->stats.tx_dropped++;
+			dev_kfree_skb(skb);
+			return 0;
+		}
+	}
+
+	data = skb->data;
+	len = skb->len;
+	if (len < ETH_ZLEN) {
+		memset(shortpkt, 0, ETH_ZLEN);
+		memcpy(shortpkt, skb->data, skb->len);
+		len = ETH_ZLEN;
+		data = shortpkt;
+	}
+	dev->trans_start = jiffies; /* save the timestamp */
+
+	/* Remember the skb, so we can free it at interrupt time */
+	priv->skb = skb;
+
+	/* actual deliver of data is device-specific, and not shown here */
+	boardnet_hw_tx(data, len, dev);
+	return 0;
+}
+
+/*
+ * Deal with a transmit timeout.
+ */
+static void boardnet_tx_timeout(struct net_device *dev)
+{
+	struct boardnet_private *priv = netdev_priv(dev);
+
+	/* discard the unsent packet */
+	dev_kfree_skb(priv->skb);
+
+	netif_wake_queue(dev);
+	return;
+}
+
+/*
+ * Ioctl commands
+ */
+static int boardnet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	DPRINTK("ioctl\n");
+	return 0;
+}
+
+/*
+ * This is called when ifconfig is issueed
+ * Return statistics to the caller
+ */
+static struct net_device_stats *boardnet_get_stats(struct net_device *dev)
+{
+	struct boardnet_private *priv = netdev_priv(dev);
+	return &priv->stats;
+}
+
+/*
+ * This function is called to fill up an eth header, since arp is not
+ * available on the interface
+ */
+static int boardnet_rebuild_header(struct sk_buff *skb)
+{
+	struct ethhdr *eth = (struct ethhdr *) skb->data;
+	struct net_device *dev = skb->dev;
+
+	memcpy(eth->h_source, dev->dev_addr, dev->addr_len);
+	memcpy(eth->h_dest, dev->dev_addr, dev->addr_len);
+	eth->h_dest[ETH_ALEN-1] ^= 0x01; /* dest is us xor 1 */
+	return 0;
+}
+
+/*
+ * This function is called to fill up an eth header, since arp is not
+ * available on the interface
+ */
+static int
+boardnet_header(struct sk_buff *skb, struct net_device *dev,
+		unsigned short type, void *daddr, const void *saddr,
+		unsigned int len)
+{
+	struct ethhdr *eth = (struct ethhdr *)skb_push(skb, ETH_HLEN);
+
+	eth->h_proto = htons(type);
+	memcpy(eth->h_source, dev->dev_addr, dev->addr_len);
+	memcpy(eth->h_dest, dev->dev_addr, dev->addr_len);
+	eth->h_dest[ETH_ALEN-1] ^= 0x01; /* dest is us xor 1 */
+
+	return dev->hard_header_len;
+}
+
+/*
+ * The "change_mtu" method is usually not needed.
+ * If you need it, it must be like this.
+ */
+static int boardnet_change_mtu(struct net_device *dev, int new_mtu)
+{
+	struct boardnet_private *priv = netdev_priv(dev);
+	spinlock_t *lock = &priv->lock;
+	unsigned long flags;
+
+	/* check ranges */
+	if ((new_mtu < 68) || (new_mtu > 1500))
+		return -EINVAL;
+	/*
+	 * Do anything you need, and the accept the value
+	 */
+	spin_lock_irqsave(lock, flags);
+	dev->mtu = new_mtu;
+	spin_unlock_irqrestore(lock, flags);
+	return 0; /* success */
+}
+
+/*
+ * Cleanup
+ */
+static void boardnet_cleanup(struct pci_dev *pdev)
+{
+	struct net_device *dev;
+	struct boardnet_private *priv;
+
+	dev = pci_get_drvdata(pdev);
+	priv = netdev_priv(dev);
+	/* Unmap the space address */
+	iounmap((void *)(priv->m_immrbar));
+	iounmap((void *)(priv->m_ioaddr));
+	iounmap((void *)(priv->mesgu));
+	free_netdev(dev);
+	/* Release region */
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
+	return;
+}
+
+/*
+ * Called when remove the device
+ */
+static __devexit void boardnet_remove(struct pci_dev *pdev)
+{
+	struct net_device *dev;
+
+	dev = pci_get_drvdata(pdev);
+	unregister_netdev(dev);
+	boardnet_cleanup(pdev);
+	/* Clear the device pointer in PCI */
+	pci_set_drvdata(pdev, NULL);
+}
+
+/*
+ * Called to initialize the board
+ */
+static __devinit int
+boardnet_board_init(struct pci_dev *pdev, struct net_device **dev_out)
+{
+	struct net_device *dev;
+	struct boardnet_private *priv;
+	struct base_addr_reg immrbar;
+	uint32_t localaddr, pciaddr, size;
+	void *mapped_immrbar;
+	int retval;
+
+	if (pdev->vendor == PCI_VENDOR_ID_FREESCALE &&
+		pdev->device == PCI_DEVICE_ID_MPC8568E)
+		DPRINTK("Vendor: Freescale\tDevice: MPC8568E\n");
+
+	/* Enable device */
+	retval = pci_enable_device(pdev);
+	if (retval) {
+		printk(KERN_ERR "Cannot enable device\n");
+		return retval;
+	}
+
+	/* Read information from base register */
+	immrbar.start	= pci_resource_start(pdev, 0);
+	immrbar.end	= pci_resource_end(pdev, 0);
+	immrbar.flags	= pci_resource_flags(pdev, 0);
+	immrbar.len	= pci_resource_len(pdev, 0);
+
+	/* Make sure region #0 is memory space */
+	if (!(immrbar.flags & IORESOURCE_MEM)) {
+		printk(KERN_ERR "Region #0 is not memory space\n");
+		pci_disable_device(pdev);
+		retval = -ENODEV;
+	}
+	/* Make sure region #0 size is 1MB */
+	if (immrbar.len < IMMRBAR_SIZE) {
+		printk(KERN_ERR "%s: Invalid PCI memregion size(s),aborting\n",
+			pci_name(pdev));
+		pci_disable_device(pdev);
+		retval = -ENODEV;
+	}
+
+	/* Mark the memory region used by Methernet */
+	retval = pci_request_regions(pdev, "boardnet");
+	if (retval) {
+		printk(KERN_ERR "%s: Cannot reserve region, aborting\n",
+			pci_name(pdev));
+		pci_disable_device(pdev);
+		return -ENODEV;
+
+	}
+
+	/* Enable PCI bus mastering */
+	pci_set_master(pdev);
+	/* ioremap address */
+	mapped_immrbar = ioremap(immrbar.start, immrbar.len);
+	if (mapped_immrbar == NULL) {
+		printk(KERN_ERR "%s: Cannot remap memory, aborting\n",
+			pci_name(pdev));
+		pci_release_regions(pdev);
+		pci_disable_device(pdev);
+		retval = -EIO;
+	}
+
+	/* Setup outbound window 1 in host */
+	localaddr = HOST_LOCAL_SPACE_ADDR;
+	size = AGENT_MEM_SIZE;
+	pciaddr = PCI_SPACE_ADDRESS;
+
+	*dev_out = NULL;
+	/*
+	 * Allocate and set up an ethernet device.
+	 * dev and dev->priv zeroed in alloc_etherdev.
+	 */
+	dev = alloc_etherdev(sizeof(struct boardnet_private));
+	if (dev == NULL) {
+		printk(KERN_ERR PFX "%s: Unable to alloc new net device\n",
+			pci_name(pdev));
+		pci_release_regions(pdev);
+		pci_disable_device(pdev);
+		return -ENOMEM;
+	}
+
+	priv = netdev_priv(dev);
+	memset(priv, 0, sizeof(struct boardnet_private));
+
+	/* Init private data structure */
+	/* for pci_express currently */
+	priv->pci_express = 1;
+	priv->pci_dev = pdev;
+	priv->m_immrbar = (uint32_t)mapped_immrbar;
+	priv->mesgu = ioremap(get_immrbase() +
+				MPC85xx_MSG_OFFSET,
+				MPC85xx_MSG_SIZE);
+
+
+	priv->phy_ioaddr = (uint32_t)pci_resource_start(pdev, 1);
+	priv->size = AGENT_MEM_SIZE;
+	priv->m_ioaddr = ioremap(priv->phy_ioaddr, AGENT_MEM_SIZE);
+
+	*dev_out = dev;
+	return 0;
+}
+
+static const struct header_ops boardnet_header_ops = {
+	.create =  boardnet_header,
+	.rebuild = boardnet_rebuild_header,
+};
+/*
+ * The probe function (often called init).
+ * It is invoked by pci_module_init()
+ */
+static int __devinit boardnet_probe(struct pci_dev *pdev,
+					const struct pci_device_id *id)
+{
+	struct net_device *dev = NULL;
+	struct boardnet_private *priv;
+	int timeout = BOARDNET_TIMEOUT;
+	int boardnet_eth = eth;
+	int retval;
+
+	assert(pdev != NULL);
+	assert(id != NULL);
+
+	/* when we're built into the kernel, the driver version message
+	 * is only printed if at least one mpc8540eval board has been found
+	 */
+#ifndef MODULE
+	{
+		static int printed_version;
+		if (!printed_version++)
+			printk(KERN_INFO PPC85XX_NETDRV_NAME "\n");
+	}
+#endif
+
+	/*
+	 * Make the usual checks: check_region(), probe irq, ...  -ENODEV
+	 * should be returned if no device found. No resource should be
+	 * grabbed: this is done on open().
+	 */
+	retval = boardnet_board_init(pdev, &dev);
+	if (retval)
+		return retval;
+
+	assert(dev != NULL);
+	priv = netdev_priv(dev);
+	assert(priv != NULL);
+
+	setup_host_inbound_window(priv->pci_express);
+
+	if (!boardnet_eth)
+		strcpy(dev->name, "beth%d");
+	else
+		strcpy(dev->name, "eth%d");
+
+	dev->open		= boardnet_open;
+	dev->stop		= boardnet_release;
+	dev->set_config		= boardnet_config;
+	dev->hard_start_xmit	= boardnet_start_xmit;
+	dev->do_ioctl		= boardnet_ioctl;
+	dev->get_stats		= boardnet_get_stats;
+	dev->change_mtu		= boardnet_change_mtu;
+	dev->tx_timeout		= boardnet_tx_timeout;
+	dev->watchdog_timeo	= timeout;
+	dev->header_ops		= &boardnet_header_ops;
+
+	/* keep the default flags, just add NOARP */
+	dev->flags		|= IFF_NOARP;
+	dev->features		|= NETIF_F_NO_CSUM;
+	dev->irq		= ppc85xx_interrupt_init(priv->mesgu);
+
+	memcpy(dev->dev_addr, "\0FSLD1", ETH_ALEN);
+	/* initialize lock */
+	spin_lock_init(&(priv->lock));
+
+	/* dev is fully set up and ready to use now */
+	retval = register_netdev(dev);
+	if (retval) {
+		printk(KERN_ERR "%s: Cannot register device, aborting\n",
+			dev->name);
+		boardnet_cleanup(pdev);
+		return retval;
+	}
+
+	/* To remember netdev pointer in PCI */
+	printk(KERN_INFO "register device named-----%s\n", dev->name);
+	pci_set_drvdata(pdev, dev);
+	return 0;
+}
+
+/*
+ * Suspend
+ */
+static int boardnet_suspend(struct pci_dev *pdev, pm_message_t state)
+{
+	return 0;
+}
+
+/*
+ * Resume from suspend
+ */
+static int boardnet_resume(struct pci_dev *pdev)
+{
+	return 0;
+}
+
+/*
+ * List devices that this driver support
+ */
+static struct pci_device_id boardnet_id_table[] = {
+	/* Vendor_id, Device_id
+	* Subvendor_id, Subdevice_id
+	* Class_id, Class_mask
+	* Driver_data
+	*/
+	{PCI_VENDOR_ID_FREESCALE, PCI_DEVICE_ID_MPC8568E, PCI_ANY_ID,
+			PCI_ANY_ID, 0x0b2001, 0xffffff, 0},
+	{PCI_VENDOR_ID_FREESCALE, PCI_DEVICE_ID_P4080, PCI_ANY_ID,
+			PCI_ANY_ID, 0x0b2001, 0xffffff, 0},
+	{0,}
+};
+MODULE_DEVICE_TABLE(pci, boardnet_id_table);
+
+/*
+ * PCI Device info
+ */
+static struct pci_driver boardnet_pci_driver = {
+	.name		= PPC85XX_NETDRV_NAME,
+	.id_table	= boardnet_id_table,
+	.probe		= boardnet_probe,
+	.remove		= __devexit_p(boardnet_remove),
+	.suspend	= boardnet_suspend,
+	.resume		= boardnet_resume
+};
+
+/*
+ * Entry to insmod this driver module
+ */
+static int __init boardnet_pci_init(void)
+{
+	int retval;
+
+	retval = pci_register_driver(&boardnet_pci_driver);
+	if (retval) {
+		printk(KERN_ERR "MPC85xx agent-net drvier init fail."
+				"ret = %d\n", retval);
+		return retval;
+	}
+	printk("MPC85xx agent-net drvier init succeed\n");
+	return 0;
+}
+
+/*
+ * Entry to rmmod this driver module
+ */
+static void __exit boardnet_pci_exit(void)
+{
+	pci_unregister_driver(&boardnet_pci_driver);
+	return;
+}
+
+module_init(boardnet_pci_init);
+module_exit(boardnet_pci_exit);
+
+MODULE_AUTHOR("Xiaobo Xie<X.Xie@freescale.com>");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("MPC85xx Processor PCI Agent Ethernet Driver");
-- 
1.6.5.2

