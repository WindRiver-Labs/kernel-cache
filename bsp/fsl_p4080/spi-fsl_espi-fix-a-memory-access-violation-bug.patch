From 411902e6592b80c7e2ec584e52ec0ba48d4e2377 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Thu, 29 Jul 2010 19:28:50 +0800
Subject: [PATCH 2/3] spi/fsl_espi: fix a memory access violation bug

The fsl_espi_tx_buf/fsl_espi_rx_buf read/write 4 bytes each time.
But when remaining count is less than 4 bytes, there will have
a memory access violation. In order to avoid that we just read/write
one byte each time in this situation.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/spi/fsl_espi.c |   46 ++++++++++++++++++++++++++++++++++++++--------
 1 files changed, 38 insertions(+), 8 deletions(-)

diff --git a/drivers/spi/fsl_espi.c b/drivers/spi/fsl_espi.c
index ca15a60..d2e55da 100644
--- a/drivers/spi/fsl_espi.c
+++ b/drivers/spi/fsl_espi.c
@@ -119,19 +119,49 @@ struct fsl_espi_cs {
 
 static void fsl_espi_rx_buf(u32 data, struct fsl_espi *fsl_espi)
 {
-	u32 *rx = fsl_espi->rx;
-	*rx++ = (u32)(data >> fsl_espi->rx_shift);
-	fsl_espi->rx = rx;
+	int count = fsl_espi->count;
+
+	data >>= fsl_espi->rx_shift;
+
+	if (likely(count >= 4)) {
+		u32 *rx = fsl_espi->rx;
+
+		*rx++ =  data;
+		fsl_espi->rx = rx;
+	} else {
+		int i;
+		u8 *rx = fsl_espi->rx;
+
+		for (i = 0; i < count; i++, data <<= 8)
+			*rx++ = (data & 0xff000000) >> 24;
+		fsl_espi->rx = rx;
+	}
 }
 
 static u32 fsl_espi_tx_buf(struct fsl_espi *fsl_espi)
 {
-	u32 data;
-	const u32 *tx = fsl_espi->tx;
-	if (!tx)
+	u32 data = 0;
+	int count = fsl_espi->count;
+
+	if (!fsl_espi->tx)
 		return 0;
-	data = *tx++ << fsl_espi->tx_shift;
-	fsl_espi->tx = tx;
+
+	if (likely(count >= 4)) {
+		const u32 *tx = fsl_espi->tx;
+
+		data = *tx++;
+		fsl_espi->tx = tx;
+	} else {
+		int i;
+		const u8 *tx = fsl_espi->tx;
+
+		for (i = 0; i < count; i++, data <<= 8)
+			data |= *tx++;
+		data <<= (3 - count) * 8;
+		fsl_espi->tx = tx;
+	}
+
+	data <<= fsl_espi->tx_shift;
 	return data;
 }
 
-- 
1.6.5.2

