From f88069b29b045b9eb524b196a3d9667c614b09ea Mon Sep 17 00:00:00 2001
From: Andy Fleming <afleming@freescale.com>
Date: Wed, 7 Oct 2009 03:32:04 -0500
Subject: [PATCH 054/148] Rework the DPA PHY code

* Add 10G mdio support
* Move PHY interaction into MAC code
* Remove mac_device's adjust_link function
* Add an init_phy function to the mac_device struct

Signed-off-by: Andy Fleming <afleming@freescale.com>
[Applied FSL SDK 2.0.3 patch "kernel-2.6.30-Rework-the-DPA-PHY-code.patch".]
Integrated-by: Kevin Hao <kexin.hao@windriver.com>>
---
 drivers/net/dpa/Makefile     |    2 +-
 drivers/net/dpa/dpa.c        |   69 ++---------
 drivers/net/dpa/mac-api.c    |  122 ++++++++++++++++---
 drivers/net/dpa/mac.c        |   56 +--------
 drivers/net/dpa/mac.h        |   11 +-
 drivers/net/dpa/xgmac_mdio.c |  273 ++++++++++++++++++++++++++++++++++++++++++
 drivers/net/dpa/xgmac_mdio.h |   61 ++++++++++
 7 files changed, 462 insertions(+), 132 deletions(-)
 create mode 100644 drivers/net/dpa/xgmac_mdio.c
 create mode 100644 drivers/net/dpa/xgmac_mdio.h

diff --git a/drivers/net/dpa/Makefile b/drivers/net/dpa/Makefile
index 505dac7..afd5903 100644
--- a/drivers/net/dpa/Makefile
+++ b/drivers/net/dpa/Makefile
@@ -12,5 +12,5 @@ EXTRA_CFLAGS += -I$(NET_DPA)
 obj-$(CONFIG_FSL_FMAN) += NetCommSw/
 obj-$(CONFIG_DPA) += fsl-mac.o fsl-dpa.o
 
-fsl-dpa-objs	:= dpa-ethtool.o dpa.o
+fsl-dpa-objs	:= dpa-ethtool.o dpa.o xgmac_mdio.o
 fsl-mac-objs	:= mac.o mac-api.o
diff --git a/drivers/net/dpa/dpa.c b/drivers/net/dpa/dpa.c
index 10376a2..d58ee0f 100644
--- a/drivers/net/dpa/dpa.c
+++ b/drivers/net/dpa/dpa.c
@@ -34,6 +34,7 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/sort.h>
+#include <linux/of_mdio.h>
 #include <linux/of_platform.h>
 #include <linux/io.h>
 #include <linux/etherdevice.h>
@@ -1272,59 +1273,6 @@ static const struct qman_fq _egress_fqs __devinitconst = {
 	.cb = {egress_dqrr, egress_ern, egress_dc_ern, egress_fqs}
 };
 
-/* Called every time the controller might need to be made
- * aware of new link state.  The PHY code conveys this
- * information through variables in the phy_dev structure, and this
- * function converts those variables into the appropriate
- * register values, and can bring down the device if needed.
- */
-static void adjust_link(struct net_device *net_dev)
-{
-	const struct dpa_priv_s	*priv;
-	struct phy_device *phy_dev;
-	int			 _errno = 0;
-//	unsigned long flags;
-
-	priv = (typeof(priv))netdev_priv(net_dev);
-	phy_dev = priv->mac_dev->phy_dev;
-
-//	spin_lock_irqsave(&priv->lock, flags);
-
-	if (phy_dev->link)
-		_errno = priv->mac_dev->adjust_link(priv->mac_dev, phy_dev->speed, phy_dev->duplex);
-
-	if (unlikely(_errno < 0))
-		cpu_netdev_err(net_dev, "%s:%hu:%s(): mac_dev->adjust_link() = %d\n",
-			       __file__, __LINE__, __func__, _errno);
-//	spin_unlock_irqrestore(&priv->lock, flags);
-}
-
-/* Initializes driver's PHY state, and attaches to the PHY.
- * Returns 0 on success.
- */
-static int init_phy(struct net_device *net_dev)
-{
-	struct dpa_priv_s	*priv;
-	struct phy_device	*phy_dev;
-
-	priv = (typeof(priv))netdev_priv(net_dev);
-
-	phy_dev = phy_connect(net_dev, priv->mac_dev->phy_id, &adjust_link, 0, priv->mac_dev->phy_if);
-	if (IS_ERR(phy_dev)) {
-		cpu_netdev_err(net_dev, "%s:%hu:%s(): Could not attach to PHY %s\n",
-			       __file__, __LINE__, __func__, priv->mac_dev->phy_id);
-		return PTR_ERR(phy_dev);
-	}
-
-	/* Remove any features not supported by the controller */
-	phy_dev->supported &= priv->mac_dev->if_support;
-	phy_dev->advertising = phy_dev->supported;
-
-	priv->mac_dev->phy_dev = phy_dev;
-
-	return 0;
-}
-
 static struct net_device_stats * __cold
 dpa_get_stats(struct net_device *net_dev)
 {
@@ -1715,14 +1663,16 @@ static int __cold dpa_start(struct net_device *net_dev)
 {
 	int			 _errno, i=0, j;
 	const struct dpa_priv_s	*priv;
+	struct mac_device *mac_dev;
 
-	priv = (typeof(priv))netdev_priv(net_dev);
+	priv = netdev_priv(net_dev);
+	mac_dev = priv->mac_dev;
 
 	if (netif_msg_ifup(priv))
 		cpu_netdev_dbg(net_dev, "-> %s:%s()\n", __file__, __func__);
 
-	if (priv->mac_dev) {
-		_errno = init_phy(net_dev);
+	if (mac_dev) {
+		_errno = mac_dev->init_phy(net_dev);
 		if(_errno) {
 			if (netif_msg_ifup(priv))
 				cpu_netdev_err(net_dev,
@@ -1742,7 +1692,6 @@ static int __cold dpa_start(struct net_device *net_dev)
 					__file__, __LINE__, __func__, _errno);
 			goto _return_port_dev_stop;
 		}
-		phy_start(priv->mac_dev->phy_dev);
 	}
 
 	netif_tx_start_all_queues(net_dev);
@@ -1774,8 +1723,6 @@ static int __cold dpa_stop(struct net_device *net_dev)
 
 	_errno = 0;
 	if (priv->mac_dev) {
-		phy_stop(priv->mac_dev->phy_dev);
-
 		__errno = priv->mac_dev->stop(priv->mac_dev);
 		if (unlikely(__errno < 0)) {
 			if (netif_msg_ifdown(priv))
@@ -1788,6 +1735,9 @@ static int __cold dpa_stop(struct net_device *net_dev)
 
 		for (i = 0; i < ARRAY_SIZE(priv->mac_dev->port_dev); i++)
 			fm_port_disable(priv->mac_dev->port_dev[i]);
+
+		phy_disconnect(priv->mac_dev->phy_dev);
+		priv->mac_dev->phy_dev = NULL;
 	}
 
 	if (netif_msg_ifdown(priv))
@@ -2215,7 +2165,6 @@ dpa_probe(struct of_device *_of_dev)
 	const uint32_t		*rx_fqids;
 	int			num_tx_fqids, num_tx_fqs;
 	int			num_rx_fqids, num_rx_fqs;
-	const char *dpa_status;
 
 	dev = &_of_dev->dev;
 
diff --git a/drivers/net/dpa/mac-api.c b/drivers/net/dpa/mac-api.c
index c1bdf28..1c67508 100644
--- a/drivers/net/dpa/mac-api.c
+++ b/drivers/net/dpa/mac-api.c
@@ -32,8 +32,12 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/of_platform.h>
+#include <linux/of_mdio.h>
+#include <linux/phy.h>
+#include <linux/netdevice.h>
 
 #include "dpa-common.h"
+#include "dpa.h"
 #include "mac.h"
 
 #include "error_ext.h"	/* GET_ERROR_TYPE, E_OK */
@@ -185,13 +189,20 @@ static int __cold start(struct mac_device *mac_dev)
 {
 	int	 _errno;
 	t_Error	 err;
+	struct phy_device *phy_dev = mac_dev->phy_dev;
 
 	err = FM_MAC_Enable(((struct mac_priv_s *)macdev_priv(mac_dev))->mac,
-			    e_COMM_MODE_RX_AND_TX);
+			e_COMM_MODE_RX_AND_TX);
 	_errno = -GET_ERROR_TYPE(err);
 	if (unlikely(_errno < 0))
-		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_Enable() = 0x%08x\n",
-			    __file__, __LINE__, __func__, err);
+		cpu_dev_err(mac_dev->dev,
+				"%s:%hu:%s(): FM_MAC_Enable() = 0x%08x\n",
+				__file__, __LINE__, __func__, err);
+
+	if (macdev2enetinterface(mac_dev) != e_ENET_MODE_XGMII_10000)
+		phy_start(phy_dev);
+	else if (phy_dev->drv->read_status)
+		phy_dev->drv->read_status(phy_dev);
 
 	return _errno;
 }
@@ -201,12 +212,16 @@ static int __cold stop(struct mac_device *mac_dev)
 	int	 _errno;
 	t_Error	 err;
 
+	if (macdev2enetinterface(mac_dev) != e_ENET_MODE_XGMII_10000)
+		phy_stop(mac_dev->phy_dev);
+
 	err = FM_MAC_Disable(((struct mac_priv_s *)macdev_priv(mac_dev))->mac,
-			     e_COMM_MODE_RX_AND_TX);
+				e_COMM_MODE_RX_AND_TX);
 	_errno = -GET_ERROR_TYPE(err);
 	if (unlikely(_errno < 0))
-		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_Disable() = 0x%08x\n",
-			    __file__, __LINE__, __func__, err);
+		cpu_dev_err(mac_dev->dev,
+				"%s:%hu:%s(): FM_MAC_Disable() = 0x%08x\n",
+				__file__, __LINE__, __func__, err);
 
 	return _errno;
 }
@@ -216,28 +231,101 @@ static int __cold change_promisc(struct mac_device *mac_dev)
 	int	 _errno;
 	t_Error	 err;
 
-	err = FM_MAC_SetPromiscuous(((struct mac_priv_s *)macdev_priv(mac_dev))->mac,
-				    mac_dev->promisc = !mac_dev->promisc);
+	err = FM_MAC_SetPromiscuous(
+			((struct mac_priv_s *)macdev_priv(mac_dev))->mac,
+			mac_dev->promisc = !mac_dev->promisc);
 	_errno = -GET_ERROR_TYPE(err);
 	if (unlikely(_errno < 0))
-		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_SetPromiscuous() = 0x%08x\n",
-			    __file__, __LINE__, __func__, err);
+		cpu_dev_err(mac_dev->dev,
+			"%s:%hu:%s(): FM_MAC_SetPromiscuous() = 0x%08x\n",
+			__file__, __LINE__, __func__, err);
 
 	return _errno;
 }
 
-static int __cold adjust_link(struct mac_device *mac_dev, uint16_t speed, bool full_duplex)
+static void adjust_link(struct net_device *net_dev)
 {
+	struct dpa_priv_s *priv = netdev_priv(net_dev);
+	struct mac_device *mac_dev = priv->mac_dev;
+	struct phy_device *phy_dev = mac_dev->phy_dev;
 	int	 _errno;
 	t_Error	 err;
 
-	err = FM_MAC_AdjustLink(((struct mac_priv_s *)macdev_priv(mac_dev))->mac, speed, full_duplex);
+	if (!phy_dev->link)
+		return;
+
+	err = FM_MAC_AdjustLink(
+			((struct mac_priv_s *)macdev_priv(mac_dev))->mac,
+			phy_dev->speed, phy_dev->duplex);
 	_errno = -GET_ERROR_TYPE(err);
 	if (unlikely(_errno < 0))
-		cpu_dev_err(mac_dev->dev, "%s:%hu:%s(): FM_MAC_AdjustLink() = 0x%08x\n",
-			    __file__, __LINE__, __func__, err);
+		cpu_dev_err(mac_dev->dev,
+			"%s:%hu:%s(): FM_MAC_AdjustLink() = 0x%08x\n",
+			__file__, __LINE__, __func__, err);
 
-	return _errno;
+	return;
+}
+
+/* Initializes driver's PHY state, and attaches to the PHY.
+ * Returns 0 on success.
+ */
+static int dtsec_init_phy(struct net_device *net_dev)
+{
+	struct dpa_priv_s	*priv;
+	struct mac_device	*mac_dev;
+	struct phy_device	*phy_dev;
+
+	priv = netdev_priv(net_dev);
+	mac_dev = priv->mac_dev;
+
+	if (!mac_dev->phy_node)
+		return -ENODEV;
+
+	phy_dev = of_phy_connect(net_dev, mac_dev->phy_node,
+			&adjust_link, 0, mac_dev->phy_if);
+	if (!phy_dev) {
+		cpu_netdev_err(net_dev,
+				"%s:%hu:%s(): Could not attach to PHY %s\n",
+				__file__, __LINE__, __func__,
+				priv->mac_dev->phy_node->full_name);
+		return -ENODEV;
+	}
+
+	/* Remove any features not supported by the controller */
+	phy_dev->supported &= priv->mac_dev->if_support;
+	phy_dev->advertising = phy_dev->supported;
+
+	priv->mac_dev->phy_dev = phy_dev;
+
+	return 0;
+}
+
+static int xgmac_init_phy(struct net_device *net_dev)
+{
+	struct dpa_priv_s *priv = netdev_priv(net_dev);
+	struct mac_device *mac_dev = priv->mac_dev;
+	struct phy_device *phy_dev;
+
+	if (!mac_dev->phy_node)
+		return -ENODEV;
+
+	phy_dev = of_phy_attach(net_dev, mac_dev->phy_node, 0,
+			mac_dev->phy_if);
+
+	if (!phy_dev) {
+		cpu_netdev_err(net_dev,
+				"%s:%hu:%s(): Could not attach to PHY %s\n",
+				__file__, __LINE__, __func__,
+				priv->mac_dev->phy_node->full_name);
+		return -ENODEV;
+	}
+
+	phy_dev->supported &= priv->mac_dev->if_support;
+	phy_dev->advertising = phy_dev->supported;
+
+	mac_dev->phy_dev = phy_dev;
+
+	return 0;
 }
 
 static int __cold uninit(struct mac_device *mac_dev)
@@ -268,21 +356,21 @@ static int __cold uninit(struct mac_device *mac_dev)
 
 static void __devinit __cold setup_dtsec(struct mac_device *mac_dev)
 {
+	mac_dev->init_phy	= dtsec_init_phy;
 	mac_dev->init		= init;
 	mac_dev->start		= start;
 	mac_dev->stop		= stop;
 	mac_dev->change_promisc	= change_promisc;
-	mac_dev->adjust_link	= adjust_link;
 	mac_dev->uninit		= uninit;
 }
 
 static void __devinit __cold setup_xgmac(struct mac_device *mac_dev)
 {
+	mac_dev->init_phy	= xgmac_init_phy;
 	mac_dev->init		= init;
 	mac_dev->start		= start;
 	mac_dev->stop		= stop;
 	mac_dev->change_promisc	= change_promisc;
-	mac_dev->adjust_link	= adjust_link;
 	mac_dev->uninit		= uninit;
 }
 
diff --git a/drivers/net/dpa/mac.c b/drivers/net/dpa/mac.c
index 1dd40d4..b18dd9e 100644
--- a/drivers/net/dpa/mac.c
+++ b/drivers/net/dpa/mac.c
@@ -42,7 +42,6 @@
 #include "fsl_pq_mdio.h"
 #include "mac.h"
 
-#define PHY_INTERFACE_MODE_XGMII    (PHY_INTERFACE_MODE_RTBI+1)
 #define DTSEC_SUPPORTED \
 	(SUPPORTED_10baseT_Half \
 	| SUPPORTED_10baseT_Full \
@@ -133,7 +132,7 @@ static int __devinit __cold mac_probe(struct of_device *_of_dev, const struct of
 {
 	int			 _errno, i, lenp;
 	struct device		*dev;
-	struct device_node	*mac_node, *dev_node, *tmp_node;
+	struct device_node	*mac_node, *dev_node;
 	struct mac_device	*mac_dev;
 	struct of_device	*of_dev;
 	struct resource		 res;
@@ -141,7 +140,6 @@ static int __devinit __cold mac_probe(struct of_device *_of_dev, const struct of
 	const char		*char_prop;
 	const phandle		*phandle_prop;
 	const uint32_t		*uint32_prop;
-	char bus_name[MII_BUS_ID_SIZE];
 
 	dev = &_of_dev->dev;
 
@@ -292,59 +290,19 @@ static int __devinit __cold mac_probe(struct of_device *_of_dev, const struct of
 	mac_dev->if_support = DTSEC_SUPPORTED;
 	if (strstr(char_prop, "sgmii") && (mac_dev->max_speed == 1000))
 		mac_dev->if_support &= ~SUPPORTED_1000baseT_Half;
+	if (strstr(char_prop, "xgmii"))
+		mac_dev->if_support = SUPPORTED_10000baseT_Full;
 
 	/* Get the rest of the PHY information */
-	phandle_prop = (typeof(phandle_prop))of_get_property(mac_node, "phy-handle", &lenp);
-	if (unlikely(phandle_prop == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): of_get_property(%s, phy-handle) failed\n",
-			    __file__, __LINE__, __func__, mac_node->full_name);
-		_errno = -EINVAL;
-		goto _return_dev_set_drvdata;
-	}
-	BUG_ON(lenp != sizeof(phandle));
-
-	/* Find the PHY node */
-	dev_node = of_find_node_by_phandle(*phandle_prop);
-	if (unlikely(dev_node == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): of_find_node_by_phandle() failed\n",
+	mac_dev->phy_node = of_parse_phandle(mac_node, "phy-handle", 0);
+	if (unlikely(mac_dev->phy_node == NULL)) {
+		cpu_dev_err(dev, "%s:%hu:%s(): of_parse_phandle() failed\n",
 			    __file__, __LINE__, __func__);
 		_errno = -EINVAL;
 		goto _return_dev_set_drvdata;
 	}
 
-	/* Get the PHY interface/device address */
-	uint32_prop = (typeof(uint32_prop))of_get_property(dev_node, "reg", &lenp);
-	if (unlikely(uint32_prop == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): of_get_property(%s, reg) failed\n",
-			    __file__, __LINE__, __func__, dev_node->full_name);
-		_errno = -EINVAL;
-		goto _return_of_node_put;
-	}
-	BUG_ON(lenp != sizeof(uint32_t));
-
-	/* Get the MDIO bus */
-	tmp_node = of_get_parent(dev_node);
-	if (unlikely(tmp_node == NULL)) {
-		cpu_dev_err(dev, "%s:%hu:%s(): of_get_parent(%s) failed\n",
-			    __file__, __LINE__, __func__, dev_node->full_name);
-		_errno = -EINVAL;
-		goto _return_of_node_put;
-	}
-	of_node_put(dev_node);
-	dev_node = tmp_node;
-
-	/* Build the PHY id/address */
-	fsl_pq_mdio_bus_name(bus_name, dev_node);
-	of_node_put(dev_node);
-	_errno = snprintf(mac_dev->phy_id, sizeof(mac_dev->phy_id), "%s:%02x",
-				bus_name, *uint32_prop);
-	if (unlikely(_errno < 0 || _errno >= sizeof(mac_dev->phy_id))) {
-		cpu_dev_err(dev, "%s:%hu:%s(): snprintf() = %d\n",
-			    __file__, __LINE__, __func__, _errno);
-		if (_errno > 0)
-			_errno = -ENOBUFS;
-		goto _return_dev_set_drvdata;
-	}
+	mac_dev->tbi_node = of_parse_phandle(mac_node, "tbi-handle", 0);
 
 	_errno = mac_dev->init(mac_dev);
 	if (unlikely(_errno < 0)) {
diff --git a/drivers/net/dpa/mac.h b/drivers/net/dpa/mac.h
index 4fb2619..6ca7e0f 100644
--- a/drivers/net/dpa/mac.h
+++ b/drivers/net/dpa/mac.h
@@ -50,23 +50,24 @@ struct mac_device {
 	bool			 promisc;
 
 	struct fm		*fm_dev;
-	struct fm_port	*port_dev[2];
+	struct fm_port		*port_dev[2];
 
 	phy_interface_t		 phy_if;
-	u32					 if_support;
+	u32			 if_support;
 	bool			 link;
 	bool			 half_duplex;
 	uint16_t		 speed;
 	uint16_t		 max_speed;
-	char			 phy_id[BUS_ID_SIZE];
+	struct device_node	*phy_node;
+	struct device_node	*tbi_node;
 	struct phy_device	*phy_dev;
-    void			*fm;
+	void			*fm;
 
+	int (*init_phy)(struct net_device *net_dev);
 	int (*init)(struct mac_device *mac_dev);
 	int (*start)(struct mac_device *mac_dev);
 	int (*stop)(struct mac_device *mac_dev);
 	int (*change_promisc)(struct mac_device *mac_dev);
-	int (*adjust_link)(struct mac_device *mac_dev, uint16_t speed, bool full_duplex);
 	int (*uninit)(struct mac_device *mac_dev);
 };
 
diff --git a/drivers/net/dpa/xgmac_mdio.c b/drivers/net/dpa/xgmac_mdio.c
new file mode 100644
index 0000000..dd2e285
--- /dev/null
+++ b/drivers/net/dpa/xgmac_mdio.c
@@ -0,0 +1,273 @@
+/* Copyright (C) 2009 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * QorIQ 10-G MDIO Controller
+ *
+ * Author: Andy Fleming <afleming@freescale.com>
+ *
+ * Based on fsl_pq_mdio.c
+ */
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/unistd.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/crc32.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_mdio.h>
+#include <linux/io.h>
+#include <linux/uaccess.h>
+
+#include <asm/irq.h>
+
+#include "xgmac_mdio.h"
+
+/* Write value to the PHY for this device to the register at regnum, */
+/* waiting until the write is done before it returns.  All PHY */
+/* configuration has to be done through the TSEC1 MIIM regs */
+int xgmac_mdio_write(struct mii_bus *bus, int port_addr,
+			int dev_addr, int regnum, u16 value)
+{
+	struct tgec_mdio_controller __iomem *regs = bus->priv;
+	u32 mdio_ctl;
+
+	/* Setup the MII Mgmt clock speed */
+	out_be32(&regs->mdio_stat, MDIO_STAT_CLKDIV(100) | 0xc);
+
+	/* Wait till the bus is free */
+	while ((in_be32(&regs->mdio_stat)) & MDIO_STAT_BSY)
+		cpu_relax();
+
+	/* Set the port and dev addr */
+	mdio_ctl = MDIO_CTL_PORT_ADDR(port_addr) | MDIO_CTL_DEV_ADDR(dev_addr);
+	out_be32(&regs->mdio_ctl, mdio_ctl);
+
+	/* Set the register address */
+	out_be32(&regs->mdio_addr, regnum & 0xffff);
+
+	/* Wait till the bus is free */
+	while ((in_be32(&regs->mdio_stat)) & MDIO_STAT_BSY)
+		cpu_relax();
+
+	/* Write the value to the register */
+	out_be32(&regs->mdio_data, MDIO_DATA(value));
+
+	/* Wait till the MDIO write is complete */
+	while ((in_be32(&regs->mdio_data)) & MDIO_DATA_BSY)
+		cpu_relax();
+
+	return 0;
+}
+
+
+/* Reads from register regnum in the PHY for device dev, */
+/* returning the value.  Clears miimcom first.  All PHY */
+/* configuration has to be done through the TSEC1 MIIM regs */
+int xgmac_mdio_read(struct mii_bus *bus, int port_addr, int dev_addr,
+			int regnum)
+{
+	struct tgec_mdio_controller __iomem *regs = bus->priv;
+	u32 mdio_ctl;
+
+	/* Setup the MII Mgmt clock speed */
+	out_be32(&regs->mdio_stat, MDIO_STAT_CLKDIV(100) | 0xc);
+
+	/* Wait till the bus is free */
+	while ((in_be32(&regs->mdio_stat)) & MDIO_STAT_BSY)
+		cpu_relax();
+
+	/* Set the Port and Device Addrs */
+	mdio_ctl = MDIO_CTL_PORT_ADDR(port_addr) | MDIO_CTL_DEV_ADDR(dev_addr);
+	out_be32(&regs->mdio_ctl, mdio_ctl);
+
+	/* Set the register address */
+	out_be32(&regs->mdio_addr, regnum & 0xffff);
+
+	/* Wait till the bus is free */
+	while ((in_be32(&regs->mdio_stat)) & MDIO_STAT_BSY)
+		cpu_relax();
+
+	/* Initiate the read */
+	mdio_ctl |= MDIO_CTL_READ;
+	out_be32(&regs->mdio_ctl, mdio_ctl);
+
+	/* Wait till the MDIO write is complete */
+	while ((in_be32(&regs->mdio_data)) & MDIO_DATA_BSY)
+		cpu_relax();
+
+	return in_be32(&regs->mdio_data) & 0xffff;
+}
+
+
+/* Reset the MIIM registers, and wait for the bus to free */
+static int xgmac_mdio_reset(struct mii_bus *bus)
+{
+	struct tgec_mdio_controller __iomem *regs = bus->priv;
+	int timeout = PHY_INIT_TIMEOUT;
+
+	mutex_lock(&bus->mdio_lock);
+
+	/* Setup the MII Mgmt clock speed */
+	out_be32(&regs->mdio_stat, MDIO_STAT_CLKDIV(100) | 0xc);
+
+	/* Wait till the bus is free */
+	while (((in_be32(&regs->mdio_stat)) & MDIO_STAT_BSY) && timeout--)
+		cpu_relax();
+
+	mutex_unlock(&bus->mdio_lock);
+
+	if (timeout < 0) {
+		printk(KERN_ERR "%s: The MII Bus is stuck!\n",
+				bus->name);
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+
+static int xgmac_mdio_probe(struct of_device *ofdev,
+		const struct of_device_id *match)
+{
+	struct tgec_mdio_controller __iomem *regs;
+	struct device_node *np = ofdev->node;
+	struct mii_bus *new_bus;
+	u64 addr, size;
+	int err = 0;
+
+	if (!of_device_is_available(np))
+		return -ENODEV;
+
+	new_bus = mdiobus_alloc();
+	if (NULL == new_bus)
+		return -ENOMEM;
+
+	new_bus->name = "Freescale XGMAC MDIO Bus",
+	new_bus->read = &xgmac_mdio_read,
+	new_bus->write = &xgmac_mdio_write,
+	new_bus->reset = &xgmac_mdio_reset,
+
+	/* Set the PHY base address */
+	addr = of_translate_address(np, of_get_address(np, 0, &size, NULL));
+	regs = ioremap(addr, size);
+
+	if (NULL == regs) {
+		err = -ENOMEM;
+		goto err_ioremap;
+	}
+
+	new_bus->priv = (void __force *)regs;
+
+	new_bus->irq = kcalloc(PHY_MAX_ADDR, sizeof(int), GFP_KERNEL);
+
+	if (NULL == new_bus->irq) {
+		err = -ENOMEM;
+		goto err_irq_alloc;
+	}
+
+	new_bus->parent = &ofdev->dev;
+	dev_set_drvdata(&ofdev->dev, new_bus);
+
+	sprintf(new_bus->id, "%s", np->name);
+
+	err = of_mdiobus_register(new_bus, np);
+
+	if (err) {
+		printk(KERN_ERR "%s: Cannot register as MDIO bus\n",
+				new_bus->name);
+		goto err_registration;
+	}
+
+	return 0;
+
+err_registration:
+	kfree(new_bus->irq);
+err_irq_alloc:
+	iounmap(regs);
+err_ioremap:
+	return err;
+}
+
+
+static int xgmac_mdio_remove(struct of_device *ofdev)
+{
+	struct device *device = &ofdev->dev;
+	struct mii_bus *bus = dev_get_drvdata(device);
+
+	mdiobus_unregister(bus);
+
+	dev_set_drvdata(device, NULL);
+
+	iounmap((void __iomem *)bus->priv);
+	bus->priv = NULL;
+	mdiobus_free(bus);
+
+	return 0;
+}
+
+static struct of_device_id xgmac_mdio_match[] = {
+	{
+		.compatible = "fsl,fman-xmdio",
+	},
+	{},
+};
+
+static struct of_platform_driver xgmac_mdio_driver = {
+	.name = "fsl-fman_xmdio",
+	.probe = xgmac_mdio_probe,
+	.remove = xgmac_mdio_remove,
+	.match_table = xgmac_mdio_match,
+};
+
+int __init xgmac_mdio_init(void)
+{
+	return of_register_platform_driver(&xgmac_mdio_driver);
+}
+
+void xgmac_mdio_exit(void)
+{
+	of_unregister_platform_driver(&xgmac_mdio_driver);
+}
+subsys_initcall_sync(xgmac_mdio_init);
+module_exit(xgmac_mdio_exit);
diff --git a/drivers/net/dpa/xgmac_mdio.h b/drivers/net/dpa/xgmac_mdio.h
new file mode 100644
index 0000000..854e03f
--- /dev/null
+++ b/drivers/net/dpa/xgmac_mdio.h
@@ -0,0 +1,61 @@
+/* Copyright (C) 2009 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * Freescale FMAN XGMAC MDIO Driver -- MDIO Management Bus Implementation
+ * Driver for the MDIO bus controller on QorIQ 10G ports
+ *
+ * Author: Andy Fleming
+ */
+
+#ifndef __XGMAC_MDIO_H
+#define __XGMAC_MDIO_H
+
+struct tgec_mdio_controller {
+	u32	res0[0xc];
+	u32	mdio_stat;	/* MDIO configuration and status */
+	u32	mdio_ctl;	/* MDIO control */
+	u32	mdio_data;	/* MDIO data */
+	u32	mdio_addr;	/* MDIO address */
+} __attribute__ ((packed));
+
+#define MDIO_STAT_CLKDIV(x)	(((x>>1) & 0xff) << 8)
+#define MDIO_STAT_BSY		(1 << 0)
+#define MDIO_STAT_RD_ER		(1 << 1)
+#define MDIO_CTL_DEV_ADDR(x) 	(x & 0x1f)
+#define MDIO_CTL_PORT_ADDR(x)	((x & 0x1f) << 5)
+#define MDIO_CTL_PRE_DIS	(1 << 10)
+#define MDIO_CTL_SCAN_EN	(1 << 11)
+#define MDIO_CTL_POST_INC	(1 << 14)
+#define MDIO_CTL_READ		(1 << 15)
+
+#define MDIO_DATA(x)		(x & 0xffff)
+#define MDIO_DATA_BSY		(1 << 31)
+
+#endif /* __XGMAC_MDIO_H */
-- 
1.6.5.2

