From d16a610f77cbe6b452964742dbd5782134481803 Mon Sep 17 00:00:00 2001
From: auto commit <unknown@unknown>
Date: Tue, 26 May 2009 10:41:40 +0800
Subject: [PATCH 09/77] AMP Support code for use by WRLoad and MIPC

- Handles cpu offlining
- Handles MIPC IPIs

Signed-off-by: Dennis Rice <dennis.rice@windriver.com>
Signed-off-by: Zwane Mwaikambo <zwane.mwaikambo@windriver.com>
---
 arch/powerpc/Kconfig                    |    2 +-
 arch/powerpc/include/asm/mpic.h         |    2 +-
 arch/powerpc/include/asm/smp.h          |    2 +
 arch/powerpc/kernel/smp.c               |   14 ++-
 arch/powerpc/platforms/85xx/Makefile    |    1 +
 arch/powerpc/platforms/85xx/amp.c       |   77 +++++++++++++++++
 arch/powerpc/platforms/85xx/p4080_sim.c |    7 ++
 arch/powerpc/platforms/85xx/smp.c       |    9 ++-
 arch/powerpc/platforms/Kconfig.cputype  |   18 ++++
 arch/powerpc/sysdev/mpic.c              |  137 +++++++++++++++++++++++++++++--
 10 files changed, 253 insertions(+), 16 deletions(-)
 create mode 100755 arch/powerpc/platforms/85xx/amp.c

diff --git a/arch/powerpc/Kconfig b/arch/powerpc/Kconfig
index 8d8b1cc..8c67ff9 100644
--- a/arch/powerpc/Kconfig
+++ b/arch/powerpc/Kconfig
@@ -292,7 +292,7 @@ config IOMMU_HELPER
 
 config HOTPLUG_CPU
 	bool "Support for enabling/disabling CPUs"
-	depends on SMP && HOTPLUG && EXPERIMENTAL && (PPC_PSERIES || PPC_PMAC)
+	depends on SMP && HOTPLUG && EXPERIMENTAL && (PPC_PSERIES || PPC_PMAC || PPC_E500MC)
 	---help---
 	  Say Y here to be able to disable and re-enable individual
 	  CPUs at runtime on SMP machines.
diff --git a/arch/powerpc/include/asm/mpic.h b/arch/powerpc/include/asm/mpic.h
index 87f8e8e..2ad89dc 100644
--- a/arch/powerpc/include/asm/mpic.h
+++ b/arch/powerpc/include/asm/mpic.h
@@ -252,7 +252,7 @@ struct mpic
 #ifdef CONFIG_MPIC_U3_HT_IRQS
 	struct irq_chip		hc_ht_irq;
 #endif
-#ifdef CONFIG_SMP
+#if defined(CONFIG_SMP) || defined(CONFIG_AMP)
 	struct irq_chip		hc_ipi;
 #endif
 	const char		*name;
diff --git a/arch/powerpc/include/asm/smp.h b/arch/powerpc/include/asm/smp.h
index 4d28e1e..d7267ce 100644
--- a/arch/powerpc/include/asm/smp.h
+++ b/arch/powerpc/include/asm/smp.h
@@ -45,6 +45,8 @@ int generic_cpu_disable(void);
 int generic_cpu_enable(unsigned int cpu);
 void generic_cpu_die(unsigned int cpu);
 void generic_mach_cpu_die(void);
+extern int start_secondary(void *unused);
+extern void abort(void);
 #endif
 
 #ifdef CONFIG_PPC64
diff --git a/arch/powerpc/kernel/smp.c b/arch/powerpc/kernel/smp.c
index ce183cd..8f26474 100644
--- a/arch/powerpc/kernel/smp.c
+++ b/arch/powerpc/kernel/smp.c
@@ -253,6 +253,8 @@ int generic_cpu_disable(void)
 	cpu_clear(cpu, cpu_online_map);
 #ifdef CONFIG_PPC64
 	vdso_data->processorCount--;
+#endif
+#ifdef CONFIG_HOTPLUG_CPU
 	fixup_irqs(cpu_online_map);
 #endif
 	return 0;
@@ -269,15 +271,14 @@ int generic_cpu_enable(unsigned int cpu)
 	per_cpu(cpu_state, cpu) = CPU_UP_PREPARE;
 	smp_wmb();
 
-	while (!cpu_online(cpu))
-		cpu_relax();
 
-#ifdef CONFIG_PPC64
+#ifdef CONFIG_HOTPLUG_CPU
 	fixup_irqs(cpu_online_map);
 	/* counter the irq disable in fixup_irqs */
 	local_irq_enable();
 #endif
-	return 0;
+
+	return 1;
 }
 
 void generic_cpu_die(unsigned int cpu)
@@ -302,6 +303,9 @@ void generic_mach_cpu_die(void)
 	printk(KERN_DEBUG "CPU%d offline\n", cpu);
 	__get_cpu_var(cpu_state) = CPU_DEAD;
 	smp_wmb();
+
+	abort();
+
 	while (__get_cpu_var(cpu_state) != CPU_UP_PREPARE)
 		cpu_relax();
 	cpu_set(cpu, cpu_online_map);
@@ -494,7 +498,7 @@ int setup_profiling_timer(unsigned int multiplier)
 	return 0;
 }
 
-void __init smp_cpus_done(unsigned int max_cpus)
+void __cpuinit smp_cpus_done(unsigned int max_cpus)
 {
 	cpumask_t old_mask;
 
diff --git a/arch/powerpc/platforms/85xx/Makefile b/arch/powerpc/platforms/85xx/Makefile
index 9ab6fe2..22c6d6e 100644
--- a/arch/powerpc/platforms/85xx/Makefile
+++ b/arch/powerpc/platforms/85xx/Makefile
@@ -2,6 +2,7 @@
 # Makefile for the PowerPC 85xx linux kernel.
 #
 obj-$(CONFIG_SMP) += smp.o
+obj-$(CONFIG_AMP) += amp.o
 
 obj-$(CONFIG_MPC8540_ADS) += mpc85xx_ads.o
 obj-$(CONFIG_MPC8560_ADS) += mpc85xx_ads.o
diff --git a/arch/powerpc/platforms/85xx/amp.c b/arch/powerpc/platforms/85xx/amp.c
new file mode 100755
index 0000000..aa8e191
--- /dev/null
+++ b/arch/powerpc/platforms/85xx/amp.c
@@ -0,0 +1,77 @@
+/*
+ * Author: Andy Fleming <afleming@freescale.com>
+ * 	   Kumar Gala <galak@kernel.crashing.org>
+ *
+ * Copyright 2006-2008 Freescale Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/pci-bridge.h>
+#include <asm/mpic.h>
+#include <asm/cacheflush.h>
+
+#include <sysdev/fsl_soc.h>
+
+extern volatile unsigned long __secondary_hold_acknowledge;
+extern void __early_start(void);
+
+#define BOOT_ENTRY_ADDR_UPPER	0
+#define BOOT_ENTRY_ADDR_LOWER	1
+#define BOOT_ENTRY_R3_UPPER	2
+#define BOOT_ENTRY_R3_LOWER	3
+#define BOOT_ENTRY_RESV		4
+#define BOOT_ENTRY_PIR		5
+#define BOOT_ENTRY_R6_UPPER	6
+#define BOOT_ENTRY_R6_LOWER	7
+#define NUM_BOOT_ENTRY		8
+#define SIZE_BOOT_ENTRY		(NUM_BOOT_ENTRY * sizeof(u32))
+
+static void startcore(char *entryPt, int nr)
+{
+	unsigned long flags;
+	const u32 *cpu_rel_addr;
+	struct device_node *np;
+	__iomem u32 *bptr_vaddr;
+
+	local_irq_save(flags);
+
+	np = of_get_cpu_node(nr, NULL);
+	cpu_rel_addr = of_get_property(np, "cpu-release-addr", NULL);
+
+	if (cpu_rel_addr == NULL) {
+		printk(KERN_ERR "No cpu-release-addr for cpu %d\n", nr);
+		return;
+	}
+
+	printk(KERN_DEBUG "CPU%d RELEASE at %llx\n", nr, *cpu_rel_addr);
+
+	/* Map the spin table */
+	bptr_vaddr = ioremap(*cpu_rel_addr, SIZE_BOOT_ENTRY);
+
+	out_be32(bptr_vaddr + BOOT_ENTRY_PIR, nr);
+	out_be32(bptr_vaddr + BOOT_ENTRY_ADDR_LOWER, (unsigned)entryPt);
+
+	/* Wait a bit for the CPU to ack. */
+	while (in_be32(bptr_vaddr + BOOT_ENTRY_ADDR_LOWER) != 3);
+
+	out_be32(bptr_vaddr + BOOT_ENTRY_ADDR_LOWER, 1);
+
+	iounmap(bptr_vaddr);
+
+	local_irq_restore(flags);
+	printk(KERN_DEBUG "CPU%d RELEASE at %llx\n", nr, *cpu_rel_addr);
+
+}
+
+EXPORT_SYMBOL(startcore);
diff --git a/arch/powerpc/platforms/85xx/p4080_sim.c b/arch/powerpc/platforms/85xx/p4080_sim.c
index e3b87aa..8f83e72 100644
--- a/arch/powerpc/platforms/85xx/p4080_sim.c
+++ b/arch/powerpc/platforms/85xx/p4080_sim.c
@@ -67,6 +67,13 @@ void __init mpc85xx_ds_pic_init(void)
 	mpic_init(mpic);
 }
 
+#ifdef CONFIG_HOTPLUG_CPU
+void cpu_die(void)
+{
+	generic_mach_cpu_die();
+}
+#endif
+
 #ifdef CONFIG_PCI
 static int primary_phb_addr;
 #endif	/* CONFIG_PCI */
diff --git a/arch/powerpc/platforms/85xx/smp.c b/arch/powerpc/platforms/85xx/smp.c
index c79aa1a..b732b42 100644
--- a/arch/powerpc/platforms/85xx/smp.c
+++ b/arch/powerpc/platforms/85xx/smp.c
@@ -64,7 +64,7 @@ smp_85xx_release_core(int nr)
 #define NUM_BOOT_ENTRY		8
 #define SIZE_BOOT_ENTRY		(NUM_BOOT_ENTRY * sizeof(u32))
 
-static void __init
+static void __cpuinit
 smp_85xx_kick_cpu(int nr)
 {
 	unsigned long flags;
@@ -129,7 +129,7 @@ smp_85xx_basic_setup(int cpu_nr)
 	mtspr(SPRN_TCR, TCR_DIE);
 }
 
-static void __init
+static void __cpuinit
 smp_85xx_setup_cpu(int cpu_nr)
 {
 	mpic_setup_this_cpu();
@@ -170,6 +170,11 @@ struct smp_ops_t smp_85xx_ops = {
 	.kick_cpu = smp_85xx_kick_cpu,
 	.take_timebase = smp_generic_take_timebase,
 	.give_timebase = smp_generic_give_timebase,
+#if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PPC32)
+	.cpu_enable = generic_cpu_enable,
+	.cpu_disable = generic_cpu_disable,
+	.cpu_die = generic_cpu_die,
+#endif
 };
 
 static int __init smp_dummy_probe(void)
diff --git a/arch/powerpc/platforms/Kconfig.cputype b/arch/powerpc/platforms/Kconfig.cputype
index cfb214c..3566565 100644
--- a/arch/powerpc/platforms/Kconfig.cputype
+++ b/arch/powerpc/platforms/Kconfig.cputype
@@ -103,6 +103,24 @@ config PPC_FPU
 	bool
 	default y if PPC64
 
+config AMP
+	depends on PPC_E500MC || FSL_BOOKE
+	bool "Asymmetric multi-processing support"
+	---help---
+	This enables support for systems with more than one CPU and
+	is only supported currently with 8572/8578.
+	If you don't know what to do here, say N.
+
+config AMP_IPI_NUM
+	depends on PPC_E500MC
+	int "IPI used for AMP shared memory driver"
+	range 0 3
+	default "2" if SMP
+	default "0"
+	---help---
+	The chooses which IPI should be used. If SMP and AMP is both
+	enabled 2  should be the default although this is a untested mode.
+
 config 4xx
 	bool
 	depends on 40x || 44x
diff --git a/arch/powerpc/sysdev/mpic.c b/arch/powerpc/sysdev/mpic.c
index 6d4eb75..082da75 100644
--- a/arch/powerpc/sysdev/mpic.c
+++ b/arch/powerpc/sysdev/mpic.c
@@ -146,6 +146,13 @@ static u32 mpic_infos[][MPIC_IDX_END] = {
 
 #endif /* CONFIG_MPIC_WEIRD */
 
+#ifdef CONFIG_AMP
+static unsigned int amp_sm_vipi;
+#ifndef CONFIG_SMP
+static unsigned int amp_mpic_probe_called;
+#endif
+#endif
+
 /*
  * Register accessor functions
  */
@@ -782,7 +789,7 @@ static inline u32 mpic_physmask(u32 cpumask)
 	return mask;
 }
 
-#ifdef CONFIG_SMP
+#if defined(CONFIG_SMP) || defined(CONFIG_AMP)
 /* Get the mpic structure from the IPI number */
 static inline struct mpic * mpic_from_ipi(unsigned int ipi)
 {
@@ -927,7 +934,7 @@ static void mpic_end_ht_irq(unsigned int irq)
 }
 #endif /* !CONFIG_MPIC_U3_HT_IRQS */
 
-#ifdef CONFIG_SMP
+#if defined(CONFIG_SMP) || defined(CONFIG_AMP)
 
 static void mpic_unmask_ipi(unsigned int irq)
 {
@@ -1064,7 +1071,9 @@ static struct irq_chip mpic_irq_chip = {
 	.set_type	= mpic_set_irq_type,
 };
 
-#ifdef CONFIG_SMP
+
+#if defined(CONFIG_SMP) || defined(CONFIG_AMP)
+
 static struct irq_chip mpic_ipi_chip = {
 	.mask		= mpic_mask_ipi,
 	.unmask		= mpic_unmask_ipi,
@@ -1147,6 +1156,12 @@ static int mpic_host_match(struct irq_host *h, struct device_node *node)
 	return h->of_node == NULL || h->of_node == node;
 }
 
+static void __mpic_setup_irqchip(struct mpic *mpic, unsigned int virq)
+{
+	set_irq_chip_data(virq, mpic);
+	set_irq_chip_and_handler(virq, &mpic->hc_ipi, handle_percpu_irq);
+}
+
 static int mpic_host_map(struct irq_host *h, unsigned int virq,
 			 irq_hw_number_t hw)
 {
@@ -1165,9 +1180,12 @@ static int mpic_host_map(struct irq_host *h, unsigned int virq,
 		WARN_ON(!(mpic->flags & MPIC_PRIMARY));
 
 		DBG("mpic: mapping as IPI\n");
-		set_irq_chip_data(virq, mpic);
-		set_irq_chip_and_handler(virq, &mpic->hc_ipi,
-					 handle_percpu_irq);
+#ifdef CONFIG_AMP
+		/* need to keep IPI free for AMP */
+		if (mpic->ipi_vecs[0] != CONFIG_AMP_IPI_NUM)
+#endif
+			__mpic_setup_irqchip(mpic, virq);
+
 		return 0;
 	}
 #endif /* CONFIG_SMP */
@@ -1294,7 +1312,7 @@ struct mpic * __init mpic_alloc(struct device_node *node,
 		mpic->hc_ht_irq.set_affinity = mpic_set_affinity;
 #endif /* CONFIG_MPIC_U3_HT_IRQS */
 
-#ifdef CONFIG_SMP
+#if defined(CONFIG_SMP) || defined(CONFIG_AMP)
 	mpic->hc_ipi = mpic_ipi_chip;
 	mpic->hc_ipi.typename = name;
 #endif /* CONFIG_SMP */
@@ -1725,6 +1743,20 @@ void mpic_send_ipi(unsigned int ipi_no, unsigned int cpu_mask)
 		       mpic_physmask(cpu_mask & cpus_addr(cpu_online_map)[0]));
 }
 
+void mpic_send_amp_ipi(unsigned int ipi_no, unsigned int cpu_mask)
+{
+	struct mpic *mpic = mpic_primary;
+
+	BUG_ON(mpic == NULL);
+
+#ifdef DEBUG_IPI
+	DBG("%s: send_ipi(ipi_no: %d)\n", mpic->name, ipi_no);
+#endif
+
+	mpic_cpu_write(MPIC_INFO(CPU_IPI_DISPATCH_0) +
+			ipi_no * MPIC_INFO(CPU_IPI_DISPATCH_STRIDE), cpu_mask);
+}
+
 static unsigned int _mpic_get_one_irq(struct mpic *mpic, int reg)
 {
 	u32 src;
@@ -1816,6 +1848,12 @@ void mpic_request_ipis(void)
 			printk(KERN_ERR "Failed to map IPI %ld\n", i);
 			break;
 		}
+#ifdef CONFIG_AMP
+		if (i == CONFIG_AMP_IPI_NUM) /*Unused allow request from external driver in AMP */
+			amp_sm_vipi = vipi;
+		else
+#endif
+
 		err = request_irq(vipi, mpic_ipi_action,
 				  IRQF_DISABLED|IRQF_PERCPU,
 				  ipi_names[i], (void *)i);
@@ -1870,6 +1908,91 @@ void __devinit smp_mpic_setup_cpu(int cpu)
 }
 #endif /* CONFIG_SMP */
 
+#ifdef CONFIG_AMP
+#ifndef CONFIG_SMP
+void mpic_request_ipis(void)
+{
+
+	struct mpic *mpic = mpic_primary;
+	BUG_ON(mpic == NULL);
+
+	printk(KERN_INFO "mpic: requesting IPIs ... \n");
+
+	amp_sm_vipi = irq_create_mapping(mpic->irqhost,
+					     mpic->ipi_vecs[0] + CONFIG_AMP_IPI_NUM);
+	if (amp_sm_vipi == NO_IRQ)
+		printk(KERN_ERR "Failed to map IPI %d\n",CONFIG_AMP_IPI_NUM );
+}
+#endif
+
+#ifndef MSG_ALL
+#define MSG_ALL 0x22
+#endif
+#ifndef MSG_ALL_BUT_SELF
+#define MSG_ALL_BUT_SELF 0x21
+#endif
+
+void amp_mpic_message_pass(int target, int msg)
+{
+	if (target > MSG_ALL) {
+		printk(KERN_DEBUG "Unknown AMP IPI message: 0x%x\n",msg);
+		return;
+	}
+
+	switch (target) {
+	case MSG_ALL:
+		mpic_send_amp_ipi(msg, 0xffffffff);
+		break;
+	case MSG_ALL_BUT_SELF:
+		mpic_send_amp_ipi(msg, 0xffffffff & ~(1 << smp_processor_id()));
+		break;
+	default:
+		mpic_send_amp_ipi(msg, 1 << target );
+		break;
+	}
+}
+EXPORT_SYMBOL(amp_mpic_message_pass);
+
+void amp_mpic_probe(void)
+{
+#ifndef CONFIG_SMP
+	if (amp_mpic_probe_called == 0) {
+		amp_mpic_probe_called=1;
+		mpic_request_ipis();
+	}
+#endif
+}
+
+
+int amp_ipi_sm_request(void *ipi_isr)
+{
+	struct mpic *mpic = mpic_primary;
+	static char *ipi_names[] = {
+			"IPI0",
+			"IPI1",
+			"IPI2 (shared memory driver)",
+			"IPI3",
+	};
+	int ipi_num = -1;
+
+	amp_mpic_probe();
+
+	ipi_num = CONFIG_AMP_IPI_NUM; /* Default unused IPI in SMP mode*/
+
+	set_irq_chip_data(amp_sm_vipi, mpic);
+	set_irq_chip_and_handler(amp_sm_vipi, &mpic->hc_ipi, handle_fasteoi_irq);
+
+	if ((request_irq(amp_sm_vipi,ipi_isr, IRQF_DISABLED|IRQF_PERCPU,
+			ipi_names[ipi_num], mpic)) !=0) {
+		printk(KERN_DEBUG "request_irq FAILED for %s",ipi_names[ipi_num]);
+		return 1;
+	}
+
+	return ipi_num;
+}
+EXPORT_SYMBOL(amp_ipi_sm_request);
+#endif /* CONFIG_AMP */
+
 #ifdef CONFIG_PM
 static int mpic_suspend(struct sys_device *dev, pm_message_t state)
 {
-- 
1.6.5.2

