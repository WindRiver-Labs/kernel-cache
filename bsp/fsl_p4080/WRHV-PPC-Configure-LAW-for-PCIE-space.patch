From da941d8421b9a3505023286f7ea7ce3ea6a06cb0 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Mon, 11 Jan 2010 21:33:30 -0800
Subject: [PATCH 6/6] WRHV/PPC: Configure LAW for PCIE space

Here the following functions are implemented according to different platforms:

ppc_md.set_law_base

It's used to set the PCIE base address.

ppc_md.set_law_attr
ppc_md.get_law_attr

They are used to set/get the PCIE space attributes such as enable/disable flag,
space size and target id. For more info on this you should refer to the platform
manual.

When 'wrhv_pci_law=on' is set on cmd line, we will invalidate those LAW items
we want to set. Then search one free item to configure the PCI/PCIE space. Note
we will get the appropriate PCI/PCIE description on the dts file.

Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/powerpc/include/asm/machdep.h         |    3 +
 arch/powerpc/include/asm/wrhv.h            |    5 +
 arch/powerpc/kernel/vbi/wrhv.c             |  120 ++++++++++++++++++++++++++++
 arch/powerpc/platforms/85xx/wrhv_8572ds.c  |   26 ++++++
 arch/powerpc/platforms/85xx/wrhv_p4080ds.c |   29 +++++++
 5 files changed, 183 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/include/asm/machdep.h b/arch/powerpc/include/asm/machdep.h
index 66a6cb3..7d1f2dc 100644
--- a/arch/powerpc/include/asm/machdep.h
+++ b/arch/powerpc/include/asm/machdep.h
@@ -265,6 +265,9 @@ struct machdep_calls {
 #ifdef CONFIG_VIRTUALIZATION
 	int (*earlycon_setup)(void);
 	int (*enable_pci_law)(void);
+	int (*set_law_base)(int index, unsigned long long addr);
+	int (*set_law_attr)(int index, unsigned int attr);
+	int (*get_law_attr)(int index);
 #endif
 };
 
diff --git a/arch/powerpc/include/asm/wrhv.h b/arch/powerpc/include/asm/wrhv.h
index d93d43d..28f0e85 100644
--- a/arch/powerpc/include/asm/wrhv.h
+++ b/arch/powerpc/include/asm/wrhv.h
@@ -16,6 +16,8 @@
 #define __ASM_WRHV_H
 
 #ifdef CONFIG_WRHV
+extern unsigned char *law_base;
+
 extern void wrhv_mapping(void);
 extern void wrhv_restart(void);
 extern unsigned long __init wrhv_find_end_of_memory(void);
@@ -29,6 +31,9 @@ extern int __init wrhv_earlycon_setup(void);
 extern int ppc_get_pci_intr_wrhv(struct pci_dev *dev);
 #endif
 extern int wrhv_enable_pci_law(void);
+extern void ppc_setup_law(unsigned int target_id, unsigned long long addr, unsigned int attr);
+extern int ppc_search_free_law(int target_id);
+extern int ppc_setup_pci_law(struct device_node *dev);
 
 extern int __init smp_wrhv_probe(void);
 extern void smp_wrhv_message_pass(int target, int msg);
diff --git a/arch/powerpc/kernel/vbi/wrhv.c b/arch/powerpc/kernel/vbi/wrhv.c
index 42d7742..0666f8e 100644
--- a/arch/powerpc/kernel/vbi/wrhv.c
+++ b/arch/powerpc/kernel/vbi/wrhv.c
@@ -1204,6 +1204,126 @@ void wrhv_init(void)
 
 }
 
+#define LAW_TARGET_ID (0xff << 20)
+#define LAW_EN (0x1 << 31)
+unsigned char *law_base;
+int ppc_search_free_law(int target_id)
+{
+	struct device_node *dev;
+	int i, law_num = 0;
+	static int index = -1;
+	const int *prop;
+
+	dev = of_find_compatible_node(NULL, NULL, "fsl,corenet-law");
+	if (!dev) {
+		printk(KERN_ERR "%s: No corenet law device node.\n", __func__);
+		return -1;
+	}
+
+	law_base = of_iomap(dev, 0);
+	if (!law_base) {
+		printk(KERN_ERR "%s: Can't iomap corenet law.\n", __func__);
+		return -1;
+	}
+
+	/* Get law numbers property */
+	prop = of_get_property(dev, "fsl,num-laws", NULL);
+	if (prop)
+		law_num = *prop;
+	else
+		return -1;
+
+	if ((!ppc_md.set_law_attr) || (!ppc_md.set_law_base) || (!ppc_md.get_law_attr))
+		return -1;
+
+	for (i = index+1;i < law_num;i++) {
+		/* Firstly we should invalid those existed LAW we want configure. */
+		if ((ppc_md.get_law_attr(i) & LAW_TARGET_ID) == target_id)
+			ppc_md.set_law_attr(i, 0);
+
+		/* Skip these used LAW item */
+		if (ppc_md.get_law_attr(i) & LAW_EN)
+			continue;
+
+		index = i;
+		break;
+	}
+
+	return  index;
+}
+
+void ppc_setup_law(unsigned int target_id, unsigned long long addr, unsigned int attr)
+{
+        int index = ppc_search_free_law(target_id);
+        if (index >= 0) {
+		ppc_md.set_law_base(index, addr);
+		ppc_md.set_law_attr(index, attr);
+	}
+}
+
+int ppc_setup_pci_law( struct device_node *dev)
+{
+	unsigned long long pci_addr, cpu_addr, pci_next, cpu_next, size;
+	const u32 *ranges;
+	int rlen;
+	int pna = 0;
+	int np = 0;
+	u32 pci_space, attr;
+	int pcie_index = 0;
+	const int *prop;
+
+	if ((!have_of) || (!dev))
+		return -ENODEV;
+
+	if (wrhv_pci_law == 1) {
+		/* Get PCIE target id property */
+		prop = of_get_property(dev, "target-id", NULL);
+		if (prop)
+			pcie_index = *prop;
+		else
+			return -1;
+
+		pna = of_n_addr_cells(dev);
+		np = pna + 5;
+		/* Get ranges property */
+		ranges = of_get_property(dev, "ranges", &rlen);
+		if (ranges == NULL)
+			return -1;
+		/* Parse it */
+		while ((rlen -= np * 4) >= 0) {
+			/* Read next ranges element */
+			pci_space = ranges[0];
+			pci_addr = of_read_number(ranges + 1, 2);
+			cpu_addr = of_translate_address(dev, ranges + 3);
+			size = of_read_number(ranges + pna + 3, 2);
+			ranges += np;
+			if (cpu_addr == OF_BAD_ADDR || size == 0)
+				continue;
+
+			/* Now consume following elements while they are contiguous */
+			for (; rlen >= np * sizeof(u32);
+				     ranges += np, rlen -= np * 4) {
+				if (ranges[0] != pci_space)
+					break;
+				pci_next = of_read_number(ranges + 1, 2);
+				cpu_next = of_translate_address(dev, ranges + 3);
+				if (pci_next != pci_addr + size ||
+						    cpu_next != cpu_addr + size)
+					break;
+				size += of_read_number(ranges + pna + 3, 2);
+			}
+
+			printk(KERN_INFO "  Setup LAW for PCIE Space  0x%016llx..0x%016llx \n", 
+					cpu_addr, cpu_addr + size - 1);
+
+			attr = LAW_EN | (pcie_index < 20) | (__ilog2(size) - 1) ;
+			ppc_setup_law(pcie_index, cpu_addr, attr);
+		}
+	}
+
+	return 0;
+}
+
 #if defined(CONFIG_PCI)
 #define VECTOR_NAME_SIZE	8
 int ppc_get_pci_intr_wrhv(struct pci_dev *dev)
diff --git a/arch/powerpc/platforms/85xx/wrhv_8572ds.c b/arch/powerpc/platforms/85xx/wrhv_8572ds.c
index ed2fee5..81a7fdc 100644
--- a/arch/powerpc/platforms/85xx/wrhv_8572ds.c
+++ b/arch/powerpc/platforms/85xx/wrhv_8572ds.c
@@ -97,6 +97,28 @@ static int get_bsp_clock_freq(void)
 	return clk_reply.dataVal;
 }
 
+int wrhv_8572ds_set_law_base(int index, unsigned long long addr)
+{
+	/* Set base address */
+	out_be32((unsigned int *)(law_base + 0xc08 + index * 0x10), (unsigned int)(addr >> 8));
+	return 0;
+} 
+
+int wrhv_8572ds_set_law_attr(int index, unsigned int attr)
+{
+	/* Set Attributes */
+	out_be32((unsigned int *)(law_base + 0xc10 + index * 0x10), attr);
+	return 0;
+} 
+
+int wrhv_8572ds_get_law_attr(int index)
+{
+	unsigned int attr = 0;
+	/* Get Attributes */
+	attr = in_be32((unsigned int *)(law_base + 0xc10 + index * 0x10));
+	return attr;
+}
+
 /*
  * Setup the architecture
  */
@@ -121,6 +143,7 @@ static void __init wrhv_8572ds_setup_arch(void)
 				fsl_add_bridge(np, 1);
 			else
 				fsl_add_bridge(np, 0);
+			ppc_setup_pci_law(np);
 		}
 	}
 
@@ -196,4 +219,7 @@ define_machine(wrhv_8572ds) {
 	.power_save = wrhv_power_save,
 	.restart = wrhv_restart,
 	.earlycon_setup = wrhv_earlycon_setup,
+	.set_law_base		= wrhv_8572ds_set_law_base,	
+	.set_law_attr		= wrhv_8572ds_set_law_attr,
+	.get_law_attr		= wrhv_8572ds_get_law_attr,
 };
diff --git a/arch/powerpc/platforms/85xx/wrhv_p4080ds.c b/arch/powerpc/platforms/85xx/wrhv_p4080ds.c
index 8d77dd8..a77f5a0 100644
--- a/arch/powerpc/platforms/85xx/wrhv_p4080ds.c
+++ b/arch/powerpc/platforms/85xx/wrhv_p4080ds.c
@@ -88,6 +88,31 @@ static int get_bsp_clock_freq(void)
 extern void __init wrhv_smp_init(void);
 #endif
 
+int wrhv_p4080_set_law_base(int index, unsigned long long addr)
+{
+	/* Set High base address */
+	out_be32((unsigned int *)(law_base + 0xc00 + index * 0x10), (addr >> 32) & 0xf);
+	/* Set Low base address */
+	out_be32((unsigned int *)(law_base + 0xc04 + index * 0x10), (unsigned int)addr);
+	return 0;
+} 
+
+int wrhv_p4080_set_law_attr(int index, unsigned int attr)
+{
+	/* Set Attributes */
+	out_be32((unsigned int *)(law_base + 0xc08 + index * 0x10), attr);
+
+	return 0;
+} 
+
+int wrhv_p4080_get_law_attr(int index)
+{
+	unsigned int attr = -1;
+
+	/* Get Attributes */
+	attr = in_be32((unsigned int *)(law_base + 0xc08 + index * 0x10));
+	return attr;
+}
 
 static void __init mpc85xx_ds_setup_arch(void)
 {
@@ -113,6 +138,7 @@ static void __init mpc85xx_ds_setup_arch(void)
 				fsl_add_bridge(np, 1);
 			else
 				fsl_add_bridge(np, 0);
+			ppc_setup_pci_law(np);
 		}
 	}
 #endif
@@ -209,4 +235,7 @@ define_machine(p4080_ds) {
 	.calibrate_decr 	= wrhv_calibrate_decr,
 	.progress		= udbg_progress,
 	.init_early		= p4080_init_early,
+	.set_law_base		= wrhv_p4080_set_law_base,	
+	.set_law_attr		= wrhv_p4080_set_law_attr,
+	.get_law_attr		= wrhv_p4080_get_law_attr,
 };
-- 
1.6.5.2

