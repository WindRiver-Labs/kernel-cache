From 6cdcb301450eac949b813353060de4766bbfd6fb Mon Sep 17 00:00:00 2001
From: Andrew Liu <shengping.liu@windriver.com>
Date: Mon, 9 Aug 2010 18:52:25 +0800
Subject: [PATCH] qman/bman/pme2: fixes+updates, see commit log for details.

From FSL vendor SDK 2.x.

These changes result from synchronising with driver sources
in the LWE and USD repositories.

Bug fixes;
bman: make bman_acquire() honour documented behaviour.
qman: only dma_map() FQ object if it's used.
qman: LOCKINCACHE is better known as PREFERINCACHE.
qman: fixes for qman_query_fq_np(), don't read reserved bits.

Compilation fixes (no impact on linux functionality);
* new toolchain produces new "unused variable" warnings.
* fix errors with non-standard build configuration (no-irq, etc).
* add missing BMAN_DEPLETION_* constants for dataplane use.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Integrated-by: Andrew Liu <shengping.liu@windriver.com>
---
 drivers/hwalloc/bman_high.c      |   34 ++++++++++++++++++++++------------
 drivers/hwalloc/bman_low.c       |    4 ++--
 drivers/hwalloc/bman_sys.h       |    4 ++++
 drivers/hwalloc/bman_test_high.c |    2 +-
 drivers/hwqueue/qman_high.c      |   21 +++++++++++++--------
 drivers/hwqueue/qman_low.c       |    7 ++++---
 include/linux/fsl_bman.h         |    4 ++++
 include/linux/fsl_qman.h         |    3 ++-
 8 files changed, 52 insertions(+), 27 deletions(-)

diff --git a/drivers/hwalloc/bman_high.c b/drivers/hwalloc/bman_high.c
index eed7cbd..9c4f7bb 100644
--- a/drivers/hwalloc/bman_high.c
+++ b/drivers/hwalloc/bman_high.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008, 2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -126,12 +126,13 @@ static inline void __poll_portal_fast(struct bman_portal *p,
 
 #ifdef CONFIG_FSL_BMAN_HAVE_IRQ
 /* Portal interrupt handler */
-static irqreturn_t portal_isr(int irq, void *ptr)
+static irqreturn_t portal_isr(__always_unused int irq, void *ptr)
 {
 	struct bman_portal *p = ptr;
 	struct bm_portal *lowp = p->p;
+	u32 clear = 0;
 #ifdef CONFIG_FSL_BMAN_PORTAL_FLAG_IRQ_SLOW
-	u32 clear = 0, is = bm_isr_status_read(lowp);
+	u32 is = bm_isr_status_read(lowp);
 #endif
 	/* Only do fast-path handling if it's required */
 #ifdef CONFIG_FSL_BMAN_PORTAL_FLAG_IRQ_FAST
@@ -149,7 +150,9 @@ struct bman_portal *bman_create_portal(struct bm_portal *__p,
 				const struct bman_depletion *pools)
 {
 	struct bman_portal *portal;
+#ifdef CONFIG_FSL_BMAN_HAVE_IRQ
 	const struct bm_portal_config *config = bm_portal_config(__p);
+#endif
 	int ret;
 
 	portal = kmalloc(sizeof(*portal), GFP_KERNEL);
@@ -191,7 +194,11 @@ struct bman_portal *bman_create_portal(struct bm_portal *__p,
 	memset(&portal->cb, 0, sizeof(portal->cb));
 	/* Write-to-clear any stale interrupt status bits */
 	bm_isr_disable_write(portal->p, 0xffffffff);
+#ifdef CONFIG_FSL_BMAN_HAVE_IRQ
 	bm_isr_enable_write(portal->p, BM_PIRQ_RCRI | BM_PIRQ_BSCN);
+#else
+	bm_isr_enable_write(portal->p, 0);
+#endif
 	bm_isr_status_clear(portal->p, 0xffffffff);
 #ifdef CONFIG_FSL_BMAN_HAVE_IRQ
 	snprintf(portal->irqname, MAX_IRQNAME, IRQNAME, config->cpu);
@@ -224,11 +231,11 @@ struct bman_portal *bman_create_portal(struct bm_portal *__p,
 	bm_isr_disable_write(portal->p, 0);
 	return portal;
 fail_rcr_empty:
-fail_affinity:
 #ifdef CONFIG_FSL_BMAN_HAVE_IRQ
+fail_affinity:
 	free_irq(config->irq, portal);
-#endif
 fail_irq:
+#endif
 	if (portal->pools)
 		kfree(portal->pools);
 fail_pools:
@@ -333,8 +340,8 @@ static u32 __poll_portal_slow(struct bman_portal *p, struct bm_portal *lowp,
 	return ret;
 }
 
-static inline void __poll_portal_fast(struct bman_portal *p,
-				struct bm_portal *lowp)
+static inline void __poll_portal_fast(__always_unused struct bman_portal *p,
+					__always_unused struct bm_portal *lowp)
 {
 	/* nothing yet, this is where we'll put optimised RCR consumption
 	 * tracking */
@@ -356,7 +363,7 @@ void bman_poll(void)
 	struct bm_portal *lowp = p->p;
 #ifndef CONFIG_FSL_BMAN_PORTAL_FLAG_IRQ_SLOW
 	if (!(p->slowpoll--)) {
-		u32 is = qm_isr_status_read(lowp);
+		u32 is = bm_isr_status_read(lowp);
 		u32 active = __poll_portal_slow(p, lowp, is);
 		if (active)
 			p->slowpoll = SLOW_POLL_BUSY;
@@ -667,7 +674,7 @@ static inline int __bman_acquire(struct bman_pool *pool, struct bm_buffer *bufs,
 	struct bm_mc_command *mcc;
 	struct bm_mc_result *mcr;
 	unsigned long flags;
-	u8 ret;
+	int ret;
 
 	spin_lock_irqsave(&p->lock, flags);
 	mcc = bm_mc_start(p->p);
@@ -676,10 +683,13 @@ static inline int __bman_acquire(struct bman_pool *pool, struct bm_buffer *bufs,
 			(num & BM_MCC_VERB_ACQUIRE_BUFCOUNT));
 	while (!(mcr = bm_mc_result(p->p)))
 		cpu_relax();
-	ret = num = mcr->verb & BM_MCR_VERB_ACQUIRE_BUFCOUNT;
-	memcpy(&bufs[0], &mcr->acquire.bufs[0], num * sizeof(bufs[0]));
+	ret = mcr->verb & BM_MCR_VERB_ACQUIRE_BUFCOUNT;
+	if (bufs)
+		 memcpy(&bufs[0], &mcr->acquire.bufs[0], num * sizeof(bufs[0]));
 	spin_unlock_irqrestore(&p->lock, flags);
 	put_affine_portal();
+	if (ret != num)
+		ret = -ENOMEM;
 	return ret;
 }
 
@@ -701,7 +711,7 @@ int bman_acquire(struct bman_pool *pool, struct bm_buffer *bufs, u8 num,
 	/* Only need a h/w op if we'll hit the low-water thresh */
 	if (!(flags & BMAN_ACQUIRE_FLAG_STOCKPILE) &&
 			(pool->sp_fill <= (BMAN_STOCKPILE_LOW + num))) {
-		u8 ret = __bman_acquire(pool, pool->sp + pool->sp_fill, 8);
+		int ret = __bman_acquire(pool, pool->sp + pool->sp_fill, 8);
 		if (!ret)
 			goto hw_starved;
 		BUG_ON(ret != 8);
diff --git a/drivers/hwalloc/bman_low.c b/drivers/hwalloc/bman_low.c
index 42171ef..260c8fe 100644
--- a/drivers/hwalloc/bman_low.c
+++ b/drivers/hwalloc/bman_low.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008, 2009 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -141,7 +141,7 @@ static inline void RCR_INC(struct bm_rcr *rcr)
 }
 
 int bm_rcr_init(struct bm_portal *portal, enum bm_rcr_pmode pmode,
-		enum bm_rcr_cmode cmode)
+		__maybe_unused enum bm_rcr_cmode cmode)
 {
 	/* This use of 'register', as well as all other occurances, is because
 	 * it has been observed to generate much faster code with gcc than is
diff --git a/drivers/hwalloc/bman_sys.h b/drivers/hwalloc/bman_sys.h
index d09aa69..8ec71d1 100644
--- a/drivers/hwalloc/bman_sys.h
+++ b/drivers/hwalloc/bman_sys.h
@@ -115,3 +115,7 @@
 #define BM_ASSERT(x)
 #endif
 
+/* In present versions of the kernel code-base, "__always_unused" isn't yet
+ * defined. It will be once we rebase onto newer code (and this definition will
+ * presumably fail compilation, triggering someone to remove it). */
+#define __always_unused        __maybe_unused
diff --git a/drivers/hwalloc/bman_test_high.c b/drivers/hwalloc/bman_test_high.c
index 0f0bba4..3f418b5 100644
--- a/drivers/hwalloc/bman_test_high.c
+++ b/drivers/hwalloc/bman_test_high.c
@@ -160,7 +160,7 @@ do_loop:
 		i -= num;
 	}
 	i = bman_acquire(pool, NULL, 1, 0);
-	BUG_ON(i);
+	BUG_ON(i > 0);
 
 	bufs_confirm();
 
diff --git a/drivers/hwqueue/qman_high.c b/drivers/hwqueue/qman_high.c
index 83ebf63..433043f 100644
--- a/drivers/hwqueue/qman_high.c
+++ b/drivers/hwqueue/qman_high.c
@@ -170,7 +170,7 @@ static inline void __poll_portal_fast(struct qman_portal *p,
 
 #ifdef CONFIG_FSL_QMAN_HAVE_IRQ
 /* Portal interrupt handler */
-static irqreturn_t portal_isr(int irq, void *ptr)
+static irqreturn_t portal_isr(__always_unused int irq, void *ptr)
 {
 	struct qman_portal *p = ptr;
 	struct qm_portal *lowp = p->p;
@@ -292,11 +292,15 @@ struct qman_portal *qman_create_portal(struct qm_portal *__p, u32 flags,
 	qman_rbtree_init(&portal->retire_table);
 	isdr = 0xffffffff;
 	qm_isr_disable_write(portal->p, isdr);
+#ifdef CONFIG_FSL_QMAN_HAVE_IRQ
 	qm_isr_enable_write(portal->p, QM_PIRQ_EQCI | QM_PIRQ_EQRI |
 #ifdef CONFIG_FSL_QMAN_PORTAL_FLAG_IRQ_FAST
 		QM_PIRQ_DQRI |
 #endif
 		QM_PIRQ_MRI | (cgrs ? QM_PIRQ_CSCI : 0));
+#else
+		qm_isr_enable_write(portal->p, 0);
+#endif
 	qm_isr_status_clear(portal->p, 0xffffffff);
 #ifdef CONFIG_FSL_QMAN_HAVE_IRQ
 	snprintf(portal->irqname, MAX_IRQNAME, IRQNAME, config->cpu);
@@ -354,11 +358,11 @@ struct qman_portal *qman_create_portal(struct qm_portal *__p, u32 flags,
 	return portal;
 fail_dqrr_mr_empty:
 fail_eqcr_empty:
-fail_affinity:
 #ifdef CONFIG_FSL_QMAN_HAVE_IRQ
+fail_affinity:
 	free_irq(config->irq, portal);
-#endif
 fail_irq:
+#endif
 	platform_device_del(portal->pdev);
 fail_devadd:
 	platform_device_put(portal->pdev);
@@ -840,7 +844,7 @@ err:
 }
 EXPORT_SYMBOL(qman_create_fq);
 
-void qman_destroy_fq(struct qman_fq *fq, u32 flags)
+void qman_destroy_fq(struct qman_fq *fq, __maybe_unused u32 flags)
 {
 	/* We don't need to lock the FQ as it is a pre-condition that the FQ be
 	 * quiesced. Instead, run some checks. */
@@ -919,11 +923,12 @@ int qman_init_fq(struct qman_fq *fq, u32 flags, struct qm_mcc_initfq *opts)
 			mcc->initfq.we_mask |= QM_INITFQ_WE_CONTEXTA;
 			memset(&mcc->initfq.fqd.context_a, 0,
 				sizeof(&mcc->initfq.fqd.context_a));
+		} else {
+			phys_fq = dma_map_single(&p->pdev->dev, fq, sizeof(*fq),
+						DMA_TO_DEVICE);
+			mcc->initfq.fqd.context_a.context_hi = 0;
+			mcc->initfq.fqd.context_a.context_lo = (u32)phys_fq;
 		}
-		phys_fq = dma_map_single(&p->pdev->dev, fq, sizeof(*fq),
-					DMA_TO_DEVICE);
-		mcc->initfq.fqd.context_a.context_hi = (u32)((u64)phys_fq >> 32);
-		mcc->initfq.fqd.context_a.context_lo = (u32)phys_fq;
 	}
 	if (flags & QMAN_INITFQ_FLAG_LOCAL) {
 		mcc->initfq.fqd.dest.channel = p->p->config.channel;
diff --git a/drivers/hwqueue/qman_low.c b/drivers/hwqueue/qman_low.c
index 4f6928c..c3e7c87 100644
--- a/drivers/hwqueue/qman_low.c
+++ b/drivers/hwqueue/qman_low.c
@@ -163,7 +163,7 @@ static inline void EQCR_INC(struct qm_eqcr *eqcr)
 }
 
 int qm_eqcr_init(struct qm_portal *portal, enum qm_eqcr_pmode pmode,
-		enum qm_eqcr_cmode cmode)
+		__maybe_unused enum qm_eqcr_cmode cmode)
 {
 	EQCR_API_START();
 	u32 cfg;
@@ -433,8 +433,9 @@ static inline struct qm_dqrr_entry *DQRR_INC(struct qm_dqrr_entry *e)
 }
 
 int qm_dqrr_init(struct qm_portal *portal, enum qm_dqrr_dmode dmode,
-		enum qm_dqrr_pmode pmode, enum qm_dqrr_cmode cmode,
-		u8 max_fill, int stash_ring, int stash_data)
+		__maybe_unused enum qm_dqrr_pmode pmode,
+		enum qm_dqrr_cmode cmode, u8 max_fill,
+		int stash_ring, int stash_data)
 {
 	DQRR_API_START();
 	const struct qm_portal_config *config = qm_portal_config(portal);
diff --git a/include/linux/fsl_bman.h b/include/linux/fsl_bman.h
index d323a5d..e139644 100644
--- a/include/linux/fsl_bman.h
+++ b/include/linux/fsl_bman.h
@@ -68,6 +68,10 @@ struct bm_portal;
 struct bman_depletion {
 	u32 __state[2];
 };
+#define BMAN_DEPLETION_EMPTY \
+	(struct bman_depletion){ { 0x00000000, 0x00000000 } }
+#define BMAN_DEPLETION_FULL \
+	(struct bman_depletion){ { 0xffffffff, 0xffffffff } }
 #define __bmdep_word(x) ((x) >> 5)
 #define __bmdep_shift(x) ((x) & 0x1f)
 #define __bmdep_bit(x) (0x80000000 >> __bmdep_shift(x))
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index b64a974..686eb8d 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -821,7 +821,8 @@ struct qm_fqd {
 #define QM_FQCTRL_FORCESFDR	0x0008	/* High-priority SFDRs */
 #define QM_FQCTRL_AVOIDBLOCK	0x0004	/* Don't block active */
 #define QM_FQCTRL_HOLDACTIVE	0x0002	/* Hold active in portal */
-#define QM_FQCTRL_LOCKINCACHE	0x0001	/* Aggressively cache FQD */
+#define QM_FQCTRL_PREFERINCACHE	0x0001  /* Aggressively cache FQD */
+#define QM_FQCTRL_LOCKINCACHE	QM_FQCTRL_PREFERINCACHE /* older naming */
 
 /* See 1.5.6.7.1: "FQD Context_A field used for [...] */
 /* Frame Queue Descriptor (FQD) field 'CONTEXT_A' uses these constants */
-- 
1.6.0.3

