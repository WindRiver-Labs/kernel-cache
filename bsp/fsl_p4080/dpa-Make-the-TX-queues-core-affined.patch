From 7df190e468c88d68acc3c35ce244e9cf51ff4d32 Mon Sep 17 00:00:00 2001
From: Andy Fleming <afleming@freescale.com>
Date: Fri, 7 May 2010 15:54:07 +0800
Subject: [PATCH 06/11] dpa: Make the TX queues core-affined

The current code just sets the queue based on a hash of the packet, and
those queues are set to different priorities.  However, there was no
real association between queue and priority, and there was a high chance
that multiple cores would then be attempting to enqueue into the same tx
queue.  Instead, we modify the driver to select the FQ based on the
processor we are on.  This will eliminate all lock contention.  We can
always modify it to do both at some future point if we choose to be more
clever with skb->priority, or to use a more interesting queueing
discipline.

Signed-off-by: Andy Fleming <afleming@freescale.com>
[Original patch "kernel-2.6.30-dpa-Make-the-TX-queues-core-affined.patch"
taken from Freescale p4080 SDK 2.1 ISO image.
Apply cleanly to kernel 2.6.27]
Integrated-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/dpa/dpa.c |   10 +++++++++-
 1 files changed, 9 insertions(+), 1 deletions(-)

diff --git a/drivers/net/dpa/dpa.c b/drivers/net/dpa/dpa.c
index 5385b98..7b73ed6 100644
--- a/drivers/net/dpa/dpa.c
+++ b/drivers/net/dpa/dpa.c
@@ -1918,6 +1918,11 @@ _return:
 }
 #endif /* CONFIG_FSL_QMAN_FQRANGE */
 
+static u16 dpa_select_queue(struct net_device *net_dev, struct sk_buff *skb)
+{
+	return smp_processor_id();
+}
+
 static const struct net_device_ops dpa_netdev_ops = {
 	.ndo_open = dpa_start,
 	.ndo_start_xmit = dpa_tx,
@@ -1927,6 +1932,7 @@ static const struct net_device_ops dpa_netdev_ops = {
 	.ndo_get_stats = dpa_get_stats,
 	.ndo_set_mac_address = eth_mac_addr,
 	.ndo_validate_addr = eth_validate_addr,
+	.ndo_select_queue = dpa_select_queue,
 };
 
 static int __devinit __cold __attribute__((nonnull))
@@ -2513,7 +2519,9 @@ dpa_probe(struct of_device *_of_dev)
 			priv->egress_fqs[i] = _dpa_fq_alloc(
 				priv->dpa_fq_list + TX, dpa_fq, fqid,
 				QMAN_FQ_FLAG_TO_DCPORTAL,
-				fm_get_tx_port_channel(priv->mac_dev->port_dev[TX]), i);
+				fm_get_tx_port_channel(
+					priv->mac_dev->port_dev[TX]),
+				7);
 			if (IS_ERR(priv->egress_fqs[i])) {
 				_errno = PTR_ERR(priv->egress_fqs[i]);
 				goto _return_dpa_fq_free;
-- 
1.6.5.2

