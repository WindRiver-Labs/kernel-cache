From fb7e6dc9f24564783eac0ef7f588a178d39b8414 Mon Sep 17 00:00:00 2001
From: Shlomi Gridish <gridish@freescale.com>
Date: Fri, 16 Apr 2010 11:44:10 -0400
Subject: [PATCH] NetCommSw

drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c
drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c
drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h
drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
drivers/net/dpa/NetCommSw/Peripherals/FM/fm_muram.c
drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c
drivers/net/dpa/NetCommSw/Peripherals/FM/HC/Makefile
drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/Makefile
drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
drivers/net/dpa/NetCommSw/Peripherals/FM/Makefile
drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile
drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
drivers/net/dpa/NetCommSw/Peripherals/FM/Port/Makefile

Signed-off-by: Donio Ron <rdonio@freescale.com>
Signed-off-by: Emil Medve <Emilian.Medve@Freescale.com>
Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
Signed-off-by: Shlomi Gridish <gridish@freescale.com>

[Cleanly applied Freescale SDK 2.0.3 patch:
"p4080_1-2-rc1-netcomm_peripherals.patch", original
had no commit text.]
Integrated-by: Yuri Nedel <Yuri.Nedel@windriver.com>
---
 .../net/dpa/NetCommSw/Peripherals/FM/HC/Makefile   |   15 +
 drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c   | 1340 +++++++
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/Makefile  |   18 +
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c   | 1358 +++++++
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h   |  496 +++
 .../NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c   |  127 +
 .../NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h   |   66 +
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c  |  483 +++
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h  |  180 +
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c    |  930 +++++
 .../net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h    |  439 +++
 .../NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c    |  103 +
 .../NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h    |   60 +
 drivers/net/dpa/NetCommSw/Peripherals/FM/Makefile  |   20 +
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile  |   19 +
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c   | 2967 ++++++++++++++
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c   | 2822 ++++++++++++++
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c  | 1381 +++++++
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h  |  950 +++++
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h  |  227 ++
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c | 1434 +++++++
 .../net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c  |  395 ++
 .../net/dpa/NetCommSw/Peripherals/FM/Port/Makefile |   19 +
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.c    | 4108 ++++++++++++++++++++
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.h    |  784 ++++
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c |  590 +++
 drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c      | 2478 ++++++++++++
 drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h      |  629 +++
 .../net/dpa/NetCommSw/Peripherals/FM/fm_guest.c    |  289 ++
 drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h  |  308 ++
 .../net/dpa/NetCommSw/Peripherals/FM/fm_muram.c    |   94 +
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_common.h   |  609 +++
 .../net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h   |   76 +
 33 files changed, 25814 insertions(+), 0 deletions(-)
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/HC/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Port/Makefile
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/fm_muram.c
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
 create mode 100644 drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h

diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/Makefile b/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/Makefile
new file mode 100644
index 0000000..3ec3824
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/Makefile
@@ -0,0 +1,15 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+NCSW_FM_INC = $(srctree)/drivers/net/dpa/NetCommSw/Peripherals/FM/inc
+
+EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+
+obj-y		+= fsl-ncsw-Hc.o
+
+fsl-ncsw-Hc-objs	:=   hc.o
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c
new file mode 100644
index 0000000..523ff1f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/HC/hc.c
@@ -0,0 +1,1340 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "sprint_ext.h"
+#include "string_ext.h"
+
+#include "fm_common.h"
+#include "fm_hc.h"
+
+
+#define __ERR_MODULE__  MODULE_FM
+
+#define SIZE_OF_HC_FRAME_PORT_REGS          (sizeof(t_HcFrame)-sizeof(t_FmPcdKgInterModuleSchemeRegs)+sizeof(t_FmPcdKgPortRegs))
+#define SIZE_OF_HC_FRAME_SCHEME_REGS        sizeof(t_HcFrame)
+#define SIZE_OF_HC_FRAME_PROFILES_REGS      (sizeof(t_HcFrame)-sizeof(t_FmPcdKgInterModuleSchemeRegs)+sizeof(t_FmPcdPlcrInterModuleProfileRegs))
+#define SIZE_OF_HC_FRAME_PROFILE_CNT        (sizeof(t_HcFrame)-sizeof(t_FmPcdPlcrInterModuleProfileRegs)+sizeof(uint32_t))
+#define SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC 16
+
+/*
+#define BUILD_FD(len)                                                           \
+do {                                                                            \
+        memset(&fmFd, 0, sizeof(t_FmFD));                                       \
+        FM_FD_SET_DD(&fmFd, (uint32_t)0x3);                                     \
+        FM_FD_SET_PID(&fmFd, (uint32_t)0x3f);                                   \
+        FM_FD_SET_BPID(&fmFd, (uint32_t)0xff);                                  \
+        FM_FD_SET_ADDR(&fmFd, &hcFrame);                                        \
+        FM_FD_SET_OFFSET(&fmFd, 0);                                             \
+        FM_FD_SET_LENGTH(&fmFd, len);                                           \
+} while (0)
+*/
+#define BUILD_FD(len)                                                           \
+do {                                                                            \
+        memset(&fmFd, 0, sizeof(t_FmFD));                                       \
+        FM_FD_SET_ADDR(&fmFd, &hcFrame);                                        \
+        FM_FD_SET_OFFSET(&fmFd, 0);                                             \
+        FM_FD_SET_LENGTH(&fmFd, len);                                           \
+} while (0)
+
+#define ENQUEUE_FRM(frm)                                                        \
+do {                                                                            \
+    uint32_t savedSeqNum = p_FmHc->seqNum;                                      \
+    p_FmHc->seqNum = (uint32_t)((p_FmHc->seqNum+1)%32);                         \
+    ASSERT_COND(!p_FmHc->wait[savedSeqNum]);                                    \
+    p_FmHc->wait[savedSeqNum] = TRUE;                                           \
+    err = p_FmHc->f_QmEnqueueCB(p_FmHc->h_QmArg, p_FmHc->enqFqid, (void *)frm); \
+    if(err)                                                                     \
+        RETURN_ERROR(MINOR, err, ("HC enqueue failed"));                        \
+    while (p_FmHc->wait[savedSeqNum]) ;                                         \
+} while (0)
+
+#define ENQUEUE_FRM_RET_NULL(frm)                                               \
+do {                                                                            \
+    uint32_t savedSeqNum = p_FmHc->seqNum;                                      \
+    p_FmHc->seqNum = (uint32_t)((p_FmHc->seqNum+1)%32);                         \
+    ASSERT_COND(!p_FmHc->wait[savedSeqNum]);                                    \
+    p_FmHc->wait[savedSeqNum] = TRUE;                                           \
+    err = p_FmHc->f_QmEnqueueCB(p_FmHc->h_QmArg, p_FmHc->enqFqid, (void *)frm); \
+    if(err)  {                                                                  \
+        REPORT_ERROR(MINOR, err, ("HC enqueue failed")); return NULL;           \
+    }                                                                           \
+    while (p_FmHc->wait[savedSeqNum]) ;                                         \
+} while (0)
+
+#define TRY_LOCK                                                                \
+do {                                                                            \
+    uint32_t intFlags;                                                          \
+    intFlags = XX_DisableAllIntr();                                             \
+    if (p_FmHc->lock)                                                           \
+    {                                                                           \
+        XX_RestoreAllIntr(intFlags);                                            \
+        return ERROR_CODE(E_BUSY);                                              \
+    }                                                                           \
+    p_FmHc->lock = TRUE;                                                        \
+    XX_RestoreAllIntr(intFlags);                                                \
+} while (0)
+
+#define TRY_LOCK_RETURN_NULL                                                    \
+do {                                                                            \
+    uint32_t intFlags;                                                          \
+    intFlags = XX_DisableAllIntr();                                             \
+    if (p_FmHc->lock)                                                           \
+    {                                                                           \
+        XX_RestoreAllIntr(intFlags);                                            \
+        REPORT_ERROR(MINOR, E_BUSY, ("nested host-commands!"));                 \
+        return NULL;                                                            \
+    }                                                                           \
+    p_FmHc->lock = TRUE;                                                        \
+    XX_RestoreAllIntr(intFlags);                                                \
+} while (0)
+
+
+
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+
+/**************************************************************************//**
+ @Description   PCD KG scheme registers
+*//***************************************************************************/
+typedef _Packed struct t_FmPcdKgSchemeRegsWithoutCounter {
+    uint32_t kgse_mode;    /**< MODE */
+    uint32_t kgse_ekfc;    /**< Extract Known Fields Command */
+    uint32_t kgse_ekdv;    /**< Extract Known Default Value */
+    uint32_t kgse_bmch;    /**< Bit Mask Command High */
+    uint32_t kgse_bmcl;    /**< Bit Mask Command Low */
+    uint32_t kgse_fqb;     /**< Frame Queue Base */
+    uint32_t kgse_hc;      /**< Hash Command */
+    uint32_t kgse_ppc;     /**< Policer Profile Command */
+    uint32_t kgse_gec[FM_PCD_KG_NUM_OF_GENERIC_REGS];
+                           /**< Generic Extract Command */
+    uint32_t kgse_dv0;     /**< KeyGen Scheme Entry Default Value 0 */
+    uint32_t kgse_dv1;     /**< KeyGen Scheme Entry Default Value 1 */
+    uint32_t kgse_ccbs;    /**< KeyGen Scheme Entry Coarse Classification Bit*/
+    uint32_t kgse_mv;      /**< KeyGen Scheme Entry Match vector */
+} _PackedType t_FmPcdKgSchemeRegsWithoutCounter;
+
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
+typedef struct t_FmPcdKgPortRegs {
+        uint32_t                spReg;
+        uint32_t                cppReg;
+} t_FmPcdKgPortRegs;
+
+typedef struct t_HcFrame {
+    uint32_t                    opcode;
+    uint32_t                    actionReg;
+    uint32_t                    extraReg;
+    uint32_t                    commandSequence;
+    union
+    {
+        t_FmPcdKgInterModuleSchemeRegs      schemeRegs;
+        t_FmPcdKgInterModuleSchemeRegs      schemeRegsWithoutCounter;
+        t_FmPcdPlcrInterModuleProfileRegs   profileRegs;
+        uint32_t                            singleRegForWrite;    /* for writing SP, CPP, profile counter */
+        t_FmPcdKgPortRegs                   portRegsForRead;
+        uint32_t                            clsPlanEntries[CLS_PLAN_NUM_PER_GRP];
+    } hcSpecificData;
+} t_HcFrame;
+
+typedef struct t_FmHc {
+    t_Handle                h_FmPcd;
+    t_Handle                h_HcPortDev;
+    uint32_t                enqFqid;            /**< Host-Command enqueue Queue Id. */
+    t_FmPcdQmEnqueueCB      *f_QmEnqueueCB;     /**< TBD */
+    t_Handle                h_QmArg;            /**< TBD */
+
+    //volatile bool           lock;
+    uint32_t                seqNum;
+    volatile bool           wait[32];
+} t_FmHc;
+
+
+t_Error     FmHcPortSetPCD(t_Handle h_FmHc, t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams);
+t_Error     FmHcPortDeletePCD(t_Handle h_FmHc, t_Handle h_FmPort);
+
+t_Error     FmHcPortPcdKgModifyClsPlanGrp (t_Handle h_FmHc, t_Handle h_FmPort, bool useClsPlan, t_Handle h_NewClsPlanGrp);
+t_Error     FmHcPortPcdKgBindSchemes(t_Handle h_FmHc , t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme);
+t_Error     FmHcPortPcdKgUnbindSchemes(t_Handle h_FmHc , t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme);
+
+
+static t_Error KgHcSetClsPlan(t_FmHc *p_FmHc, t_FmPcdKgInterModuleClsPlanSet *p_Set)
+{
+    t_HcFrame               hcFrame;
+    t_FmFD                  fmFd;
+    int                     i;
+    t_Error                 err;
+
+    ASSERT_COND(p_FmHc);
+
+    for(i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
+    {
+        memset(&hcFrame, 0, sizeof(hcFrame));
+        hcFrame.opcode = 0x00000001;
+        hcFrame.actionReg  = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
+        hcFrame.extraReg = 0xFFFFF800;
+        hcFrame.commandSequence = p_FmHc->seqNum;
+        memcpy(&hcFrame.hcSpecificData.clsPlanEntries, &p_Set->vectors[i-p_Set->baseEntry], CLS_PLAN_NUM_PER_GRP*sizeof(uint32_t));
+
+        BUILD_FD(sizeof(hcFrame));
+
+        ENQUEUE_FRM(&fmFd);
+    }
+
+    return E_OK;
+}
+
+static t_Error KgHcWriteSp(t_FmHc *p_FmHc, uint8_t hardwarePortId, uint32_t spReg, bool add)
+{
+    t_HcFrame               hcFrame;
+    t_FmFD                  fmFd;
+    t_Error                 err;
+
+    ASSERT_COND(p_FmHc);
+
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    /* first read SP register */
+    hcFrame.opcode = 0x00000001;
+    hcFrame.actionReg  = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
+    hcFrame.extraReg = 0xFFFFF800;
+    hcFrame.commandSequence = p_FmHc->seqNum;
+
+    BUILD_FD(SIZE_OF_HC_FRAME_PORT_REGS);
+
+    ENQUEUE_FRM(&fmFd);
+
+    /* spReg is the first reg, so we can use it bothe for read and for write */
+    if(add)
+        hcFrame.hcSpecificData.portRegsForRead.spReg |= spReg;
+    else
+        hcFrame.hcSpecificData.portRegsForRead.spReg &= ~spReg;
+
+    hcFrame.actionReg  = FmPcdKgBuildWritePortSchemeBindActionReg(hardwarePortId);
+    hcFrame.commandSequence = p_FmHc->seqNum;
+
+    BUILD_FD(sizeof(hcFrame));
+
+    ENQUEUE_FRM(&fmFd);
+
+    return E_OK;
+}
+
+static t_Error KgHcWriteCpp(t_FmHc *p_FmHc, uint8_t hardwarePortId, uint32_t cppReg)
+{
+    t_HcFrame               hcFrame;
+    t_FmFD                  fmFd;
+    t_Error                 err;
+
+    ASSERT_COND(p_FmHc);
+
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    /* first read SP register */
+    hcFrame.opcode = 0x00000001;
+    hcFrame.actionReg  = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
+    hcFrame.extraReg = 0xFFFFF800;
+    hcFrame.commandSequence = p_FmHc->seqNum;
+    hcFrame.hcSpecificData.singleRegForWrite = cppReg;
+
+    BUILD_FD(sizeof(hcFrame));
+
+    ENQUEUE_FRM(&fmFd);
+
+    return E_OK;
+}
+
+static t_Error CcHcDoDynamicChange(t_FmHc *p_FmHc, bool keyModify, t_Handle p_OldPointer, t_Handle p_NewPointer)
+{
+    t_HcFrame               hcFrame;
+    t_FmFD                  fmFd;
+    t_Error                 err;
+
+    ASSERT_COND(p_FmHc);
+
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    hcFrame.opcode = 0x00000003;
+    hcFrame.actionReg  = FmPcdCcGetNodeAddrOffset(p_FmHc->h_FmPcd, p_NewPointer);
+    if(hcFrame.actionReg == ILLEGAL_BASE)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Something wrong with base address"));
+    hcFrame.actionReg  |=  0xc0000000;
+    if(keyModify)
+        hcFrame.extraReg   = FmPcdCcGetNodeAddrOffsetFromNodeInfo(p_FmHc->h_FmPcd, p_OldPointer);
+    else
+        hcFrame.extraReg   = FmPcdCcGetNodeAddrOffset(p_FmHc->h_FmPcd, p_OldPointer);
+    if(hcFrame.extraReg == ILLEGAL_BASE)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Something wrong with base address"));
+    hcFrame.commandSequence = p_FmHc->seqNum;
+
+    BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+
+    ENQUEUE_FRM(&fmFd);
+
+    return E_OK;
+}
+
+static t_Error CcHcDynamicChangeForNextEngine(t_FmHc *p_FmHc, t_Handle h_OldPointer, t_Handle h_NewPointer)
+{
+    t_Error err;
+
+    ASSERT_COND(p_FmHc);
+
+    err = CcHcDoDynamicChange(p_FmHc, FALSE, h_OldPointer, h_NewPointer);
+    if(err)
+    {
+        FmPcdCcReleaseModifiedOnlyNextEngine(p_FmHc->h_FmPcd, h_OldPointer, h_NewPointer, FALSE);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    return FmPcdCcReleaseModifiedOnlyNextEngine(p_FmHc->h_FmPcd, h_OldPointer, h_NewPointer, TRUE);
+}
+static t_Error HcDynamicChangeForKey(t_FmHc *p_FmHc,t_Handle  *h_OldPointersLst, t_Handle h_NewPointer)
+{
+
+    t_List      *p_Pos;
+    uint16_t    i = 0;
+    t_Error     err;
+    t_List      *p_OldPointersLst = (t_List *)h_OldPointersLst;
+
+    LIST_FOR_EACH(p_Pos, p_OldPointersLst)
+    {
+        err = CcHcDoDynamicChange(p_FmHc, TRUE, (t_Handle)p_Pos, h_NewPointer);
+        if(err)
+        {
+            FmPcdCcReleaseModifiedKey(p_FmHc->h_FmPcd, p_OldPointersLst, h_NewPointer, i);
+            RETURN_ERROR(MAJOR, err, ("For part of nodes changes are done - situation is danger"));
+        }
+        i++;
+    }
+
+    err = FmPcdCcReleaseModifiedKey(p_FmHc->h_FmPcd, p_OldPointersLst, h_NewPointer, i);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    LIST_Del(p_OldPointersLst);
+
+    return E_OK;
+}
+
+static t_Error HcPortPcdKgBindSchemes(t_FmHc *p_FmHc , t_Handle h_FmPort,t_FmPcdPortSchemesParams *p_PortScheme)
+{
+    uint32_t                                spReg;
+    t_Error                                 err;
+    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+    int                                     i;
+
+    /* we use this routine just to get the port parameters such as HW id, netEnv etc. */
+    FmPortGetPortSchemeBindParams(h_FmPort, &schemeBind);
+
+    /* overwrite port params with the schemes we want removed */
+    schemeBind.numOfSchemes = p_PortScheme->numOfSchemes;
+    for (i=0; i<schemeBind.numOfSchemes; i++)
+        schemeBind.schemesIds[i] = (uint8_t)(CAST_POINTER_TO_UINT32(p_PortScheme->h_Schemes[i])-1);
+
+    err = FmPcdKgBuildBindPortToSchemes(p_FmHc->h_FmPcd, &schemeBind, &spReg, TRUE);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    err = KgHcWriteSp(p_FmHc, schemeBind.hardwarePortId, spReg, TRUE);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    FmPcdKgIncSchemeOwners(p_FmHc->h_FmPcd, &schemeBind);
+
+    return E_OK;
+}
+
+t_Handle    FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
+{
+    t_FmHc          *p_FmHc;
+#ifndef CONFIG_GUEST_PARTITION
+    t_FmPortParams  fmPortParam;
+    t_Error         err;
+#endif /* !CONFIG_GUEST_PARTITION */
+
+    p_FmHc = XX_Malloc(sizeof(t_FmHc));
+    if (!p_FmHc)
+    {
+        REPORT_ERROR(MINOR, E_NO_MEMORY, ("HC obj"));
+        return NULL;
+    }
+    memset(p_FmHc,0,sizeof(t_FmHc));
+
+    p_FmHc->h_FmPcd             = p_FmHcParams->h_FmPcd;
+    p_FmHc->enqFqid             = p_FmHcParams->params.enqFqid;
+    p_FmHc->f_QmEnqueueCB       = p_FmHcParams->params.f_QmEnqueueCB;
+    p_FmHc->h_QmArg             = p_FmHcParams->params.h_QmArg;
+
+#ifndef CONFIG_GUEST_PARTITION
+    memset(&fmPortParam, 0, sizeof(fmPortParam));
+    fmPortParam.baseAddr    = p_FmHcParams->params.portBaseAddr;
+    fmPortParam.portType    = e_FM_PORT_TYPE_HOST_COMMAND;
+    fmPortParam.portId      = p_FmHcParams->params.portId;
+    fmPortParam.h_Fm        = p_FmHcParams->h_Fm;
+
+    fmPortParam.specificParams.nonRxParams.errFqid      = p_FmHcParams->params.errFqid;
+    fmPortParam.specificParams.nonRxParams.dfltFqid     = p_FmHcParams->params.confFqid;
+    fmPortParam.specificParams.nonRxParams.deqSubPortal = p_FmHcParams->params.deqSubPortal;
+
+    p_FmHc->h_HcPortDev = FM_PORT_Config(&fmPortParam);
+    if(!p_FmHc->h_HcPortDev)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("FM HC port!"));
+        XX_Free(p_FmHc);
+        return NULL;
+    }
+
+    /* final init */
+    if ((err = FM_PORT_Init(p_FmHc->h_HcPortDev)) != E_OK)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("FM HC port!"));
+        FmHcFree(p_FmHc);
+        return NULL;
+    }
+#endif /* !CONFIG_GUEST_PARTITION */
+
+    return (t_Handle)p_FmHc;
+}
+
+void FmHcFree(t_Handle h_FmHc)
+{
+    t_FmHc  *p_FmHc = (t_FmHc*)h_FmHc;
+
+    if (!p_FmHc)
+        return;
+
+    if (p_FmHc->h_HcPortDev)
+        FM_PORT_Free(p_FmHc->h_HcPortDev);
+
+    XX_Free(p_FmHc);
+}
+
+void FmHcTxConf(t_Handle h_FmHc, t_FmFD *p_Fd)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame   *p_HcFrame;
+
+    ASSERT_COND(p_FmHc);
+
+    p_HcFrame  = CAST_UINT64_TO_POINTER_TYPE(t_HcFrame,
+                                             (CAST_POINTER_TO_UINT64(FM_FD_GET_ADDR(p_Fd)) + FM_FD_GET_OFFSET(p_Fd)));
+    ASSERT_COND(p_FmHc->wait[p_HcFrame->commandSequence]);
+
+    p_FmHc->wait[p_HcFrame->commandSequence] = FALSE;
+}
+
+t_Handle FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme)
+{
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error                             err;
+    t_FmPcdKgInterModuleSchemeRegs      schemeRegs;
+    t_HcFrame                           hcFrame;
+    t_FmFD                              fmFd;
+    uint8_t                             physicalSchemeId, relativeSchemeId;
+
+    if (FmPcdTryLock(p_FmHc->h_FmPcd))
+        return NULL;
+
+    if(!p_Scheme->modify)
+    {
+        /* check that schameId is in range */
+        if(p_Scheme->id.relativeSchemeId >= FmPcdKgGetNumOfPartitionSchemes(p_FmHc->h_FmPcd))
+        {
+            REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, ("Scheme is out of range"));
+            return NULL;
+        }
+
+        relativeSchemeId = p_Scheme->id.relativeSchemeId;
+
+        if (FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId))
+        {
+            FmPcdReleaseLock(p_FmHc->h_FmPcd);
+            return NULL;
+        }
+        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+
+        physicalSchemeId = FmPcdKgGetPhysicalSchemeId(p_FmHc->h_FmPcd, relativeSchemeId);
+
+        memset(&hcFrame, 0, sizeof(hcFrame));
+        hcFrame.opcode = 0x00000001;
+        hcFrame.actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+        hcFrame.extraReg = 0xFFFFF800;
+        hcFrame.commandSequence = p_FmHc->seqNum;
+
+        BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+
+        ENQUEUE_FRM_RET_NULL(&fmFd);
+
+        /* check if this scheme is already used */
+        if (FmPcdKgHwSchemeIsValid(hcFrame.hcSpecificData.schemeRegs.kgse_mode))
+        {
+            FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+            REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is already used"));
+            return NULL;
+        }
+    }
+    else
+    {
+        physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(p_Scheme->id.h_Scheme)-1);
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
+        if (FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId))
+        {
+            FmPcdReleaseLock(p_FmHc->h_FmPcd);
+            return NULL;
+        }
+        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+
+        if( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+        {
+            FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+            REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+            return NULL;
+        }
+    }
+
+    err = FmPcdKgBuildScheme(p_FmHc->h_FmPcd, p_Scheme, &schemeRegs,  &p_Scheme->orderedArray);
+    if(err)
+    {
+        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        return NULL;
+    }
+
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    hcFrame.opcode = 0x00000001;
+    hcFrame.actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, p_Scheme->schemeCounter.update);
+    hcFrame.extraReg = 0xFFFFF800;
+    hcFrame.commandSequence = p_FmHc->seqNum;
+    memcpy(&hcFrame.hcSpecificData.schemeRegs, &schemeRegs, sizeof(t_FmPcdKgInterModuleSchemeRegs));
+    //p_NewStruct= (t_FmPcdKgSchemeRegsWithoutCounter*)&hcFrame.hcSpecificData;
+    if(!p_Scheme->schemeCounter.update)
+        memcpy((t_FmPcdKgSchemeRegsWithoutCounter*)&hcFrame.hcSpecificData.schemeRegs.kgse_dv0, &schemeRegs.kgse_dv0, 4*sizeof(uint32_t));
+
+    BUILD_FD(sizeof(hcFrame));
+
+    ENQUEUE_FRM_RET_NULL(&fmFd);
+
+    FmPcdKgValidateSchemeSw(p_FmHc->h_FmPcd, relativeSchemeId);
+
+    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+
+    return CAST_UINT32_TO_POINTER((uint32_t)physicalSchemeId+1);
+}
+
+t_Error FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme)
+{
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error                             err;
+    t_HcFrame                           hcFrame;
+    t_FmFD                              fmFd;
+    uint8_t                             relativeSchemeId;
+    uint8_t                             physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(h_Scheme)-1);
+
+    if ((err = FmPcdTryLock(p_FmHc->h_FmPcd)) != E_OK)
+        return err;
+
+    relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
+
+    err = FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId);
+    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+    if (err)
+        return err;
+
+    if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+    {
+        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+        REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+    }
+
+    FmPcdKgCheckInvalidateSchemeSw(p_FmHc->h_FmPcd, relativeSchemeId);
+
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    hcFrame.opcode = 0x00000001;
+    hcFrame.actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, TRUE);
+    hcFrame.extraReg = 0xFFFFF800;
+    memset(&hcFrame.hcSpecificData.schemeRegs, 0, sizeof(t_FmPcdKgInterModuleSchemeRegs));
+    hcFrame.commandSequence = p_FmHc->seqNum;
+
+    BUILD_FD(sizeof(hcFrame));
+
+    ENQUEUE_FRM(&fmFd);
+
+    FmPcdKgInvalidateSchemeSw(p_FmHc->h_FmPcd, relativeSchemeId);
+
+    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+
+    return E_OK;
+}
+
+uint32_t  FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme)
+{
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error                             err;
+    t_HcFrame                           hcFrame;
+    t_FmFD                              fmFd;
+    uint32_t                            retVal;
+    uint8_t                             relativeSchemeId;
+    uint8_t                             physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(h_Scheme)-1);
+
+    if (FmPcdTryLock(p_FmHc->h_FmPcd))
+        return 0;
+
+    relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
+    if( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+    {
+        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+        return 0;
+    }
+
+    err = FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId);
+    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+    if (err)
+        return 0;
+
+    /* first read scheme and check that it is valid */
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    hcFrame.opcode = 0x00000001;
+    hcFrame.actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+    hcFrame.extraReg = 0xFFFFF800;
+    hcFrame.commandSequence = p_FmHc->seqNum;
+
+    BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+
+    ENQUEUE_FRM(&fmFd);
+
+    if (!FmPcdKgHwSchemeIsValid(hcFrame.hcSpecificData.schemeRegs.kgse_mode))
+    {
+        REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is invalid"));
+        return 0;
+    }
+
+    retVal = hcFrame.hcSpecificData.schemeRegs.kgse_spc;
+
+    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+
+    return retVal;
+}
+
+t_Error  FmHcPcdKgSetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme, uint32_t value)
+{
+
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error                             err;
+    t_HcFrame                           hcFrame;
+    t_FmFD                              fmFd;
+    uint8_t                             relativeSchemeId, physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(h_Scheme)-1);
+
+    if (FmPcdTryLock(p_FmHc->h_FmPcd))
+        return ERROR_CODE(E_BUSY);
+
+    relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
+    if( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+    {
+        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+    }
+
+    err = FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId);
+    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+    if (err)
+        return err;
+
+    /* first read scheme and check that it is valid */
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    hcFrame.opcode = 0x00000001;
+    hcFrame.actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+    hcFrame.extraReg = 0xFFFFF800;
+    hcFrame.commandSequence = p_FmHc->seqNum;
+
+    BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+
+    ENQUEUE_FRM(&fmFd);
+
+    /* check that scheme is valid */
+    if (!FmPcdKgHwSchemeIsValid(hcFrame.hcSpecificData.schemeRegs.kgse_mode))
+    {
+        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is invalid"));
+    }
+
+    /* Write scheme back, with modified counter */
+    hcFrame.opcode = 0x00000001;
+    hcFrame.actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, TRUE);
+    hcFrame.extraReg = 0xFFFFF800;
+    hcFrame.commandSequence = p_FmHc->seqNum;
+    /* write counter */
+    hcFrame.hcSpecificData.schemeRegs.kgse_spc = value;
+
+    BUILD_FD(sizeof(hcFrame));
+
+    ENQUEUE_FRM(&fmFd);
+
+    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+
+    return E_OK;
+}
+
+t_Handle FmHcPcdKgSetClsPlanGrp(t_Handle h_FmHc, t_FmPcdKgClsPlanGrpParams *p_Grp)
+{
+    t_FmHc                          *p_FmHc = (t_FmHc*)h_FmHc;
+    t_FmPcdKgInterModuleClsPlanSet  clsPlanSet;
+    t_Handle                        h_ClsPlanGrp;
+    t_Error                         err;
+
+    h_ClsPlanGrp = FmPcdKgBuildClsPlanGrp(p_FmHc->h_FmPcd, p_Grp, &clsPlanSet);
+    if(!h_ClsPlanGrp)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, NO_MSG);
+        return NULL;
+    }
+
+    /* write clsPlan entries to memory */
+    err = KgHcSetClsPlan(p_FmHc, &clsPlanSet);
+    if (err)
+    {
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        return NULL;
+    }
+
+    return h_ClsPlanGrp;
+}
+
+t_Error FmHcPcdKgDeleteClsPlanGrp(t_Handle h_FmHc, t_Handle h_ClsPlanGrp)
+{
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    uint8_t                             grpId = (uint8_t)(CAST_POINTER_TO_UINT32(h_ClsPlanGrp)-1);
+    t_FmPcdKgInterModuleClsPlanSet      clsPlanSet;
+
+    /* clear clsPlan entries in memory */
+    clsPlanSet.baseEntry = FmPcdKgGetClsPlanGrpBase(p_FmHc->h_FmPcd, grpId);
+    clsPlanSet.numOfClsPlanEntries = FmPcdKgGetClsPlanGrpSize(p_FmHc->h_FmPcd, grpId);
+    memset(clsPlanSet.vectors, 0, clsPlanSet.numOfClsPlanEntries*sizeof(uint32_t));
+
+    KgHcSetClsPlan(p_FmHc, &clsPlanSet);
+
+    FmPcdKgDestroyClsPlanGrp(p_FmHc->h_FmPcd, grpId);
+
+    return E_OK;
+}
+
+t_Handle FmHcPcdPlcrSetProfile(t_Handle h_FmHc,t_FmPcdPlcrProfileParams *p_Profile)
+{
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    t_FmPcdPlcrInterModuleProfileRegs              profileRegs;
+    t_Error                             err;
+    uint16_t                            profileIndx;
+    t_HcFrame                           hcFrame;
+    t_FmFD                              fmFd;
+
+    if (p_Profile->modify)
+    {
+        profileIndx = (uint16_t)(CAST_POINTER_TO_UINT32(p_Profile->id.h_Profile)-1);
+        if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, profileIndx))
+            return NULL;
+    }
+    else
+    {
+        if (FmPcdTryLock(p_FmHc->h_FmPcd))
+            return NULL;
+        err = FmPcdPlcrGetAbsoluteProfileId(p_FmHc->h_FmPcd,
+                                            p_Profile->id.newParams.profileType,
+                                            p_Profile->id.newParams.h_FmPort,
+                                            p_Profile->id.newParams.relativeProfileId,
+                                            &profileIndx);
+        if (err)
+        {
+            REPORT_ERROR(MAJOR, err, NO_MSG);
+            return NULL;
+        }
+        if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, profileIndx))
+        {
+            FmPcdReleaseLock(p_FmHc->h_FmPcd);
+            return NULL;
+        }
+        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+    }
+
+    if(!p_Profile->modify)
+    {
+        memset(&hcFrame, 0, sizeof(hcFrame));
+        hcFrame.opcode = 0x00000000;
+        hcFrame.actionReg  = FmPcdPlcrBuildReadPlcrActionReg(profileIndx);
+        hcFrame.extraReg = 0x00008000;
+        hcFrame.commandSequence = p_FmHc->seqNum;
+
+        BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+
+        ENQUEUE_FRM_RET_NULL(&fmFd);
+
+        /* check if this scheme is already used */
+        if (FmPcdPlcrHwProfileIsValid(hcFrame.hcSpecificData.profileRegs.fmpl_pemode))
+        {
+            FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, profileIndx);
+            REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Policer is already used"));
+            return NULL;
+        }
+    }
+
+    memset(&profileRegs, 0, sizeof(t_FmPcdPlcrInterModuleProfileRegs));
+    err = FmPcdPlcrBuildProfile(p_FmHc->h_FmPcd, p_Profile, &profileRegs);
+    if(err)
+    {
+        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, profileIndx);
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        return NULL;
+    }
+
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    hcFrame.opcode = 0x00000000;
+    hcFrame.actionReg  = FmPcdPlcrBuildWritePlcrActionRegs(profileIndx);
+    hcFrame.extraReg = 0x00008000;
+    hcFrame.commandSequence = p_FmHc->seqNum;
+    memcpy(&hcFrame.hcSpecificData.profileRegs, &profileRegs, sizeof(t_FmPcdPlcrInterModuleProfileRegs));
+
+    BUILD_FD(sizeof(hcFrame));
+
+    ENQUEUE_FRM_RET_NULL(&fmFd);
+
+    FmPcdPlcrValidateProfileSw(p_FmHc->h_FmPcd, profileIndx);
+
+    FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, profileIndx);
+
+    return CAST_UINT32_TO_POINTER((uint32_t)profileIndx+1);
+}
+
+t_Error FmHcPcdPlcrDeleteProfile(t_Handle h_FmHc, t_Handle h_Profile)
+{
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    uint16_t                            absoluteProfileId = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
+    t_Error                             err;
+    t_HcFrame                           hcFrame;
+    t_FmFD                              fmFd;
+
+    if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, absoluteProfileId))
+        return ERROR_CODE(E_BUSY);
+
+    FmPcdPlcrInvalidateProfileSw(p_FmHc->h_FmPcd, absoluteProfileId);
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    hcFrame.opcode = 0x00000000;
+    hcFrame.actionReg  = FmPcdPlcrBuildWritePlcrActionReg(absoluteProfileId);
+    hcFrame.actionReg  |= 0x00008000;
+    hcFrame.extraReg = 0x00008000;
+    hcFrame.commandSequence = p_FmHc->seqNum;
+    memset(&hcFrame.hcSpecificData.profileRegs, 0, sizeof(t_FmPcdPlcrInterModuleProfileRegs));
+
+    BUILD_FD(sizeof(hcFrame));
+
+    ENQUEUE_FRM(&fmFd);
+
+    FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+
+    return E_OK;
+}
+
+t_Error  FmHcPcdPlcrSetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter, uint32_t value)
+{
+
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    uint16_t                            absoluteProfileId = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
+    t_Error                             err;
+    t_HcFrame                           hcFrame;
+    t_FmFD                              fmFd;
+
+    if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, absoluteProfileId))
+        return ERROR_CODE(E_BUSY);
+
+    /* first read scheme and check that it is valid */
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    hcFrame.opcode = 0x00000000;
+    hcFrame.actionReg  = FmPcdPlcrBuildReadPlcrActionReg(absoluteProfileId);
+    hcFrame.extraReg = 0x00008000;
+    hcFrame.commandSequence = p_FmHc->seqNum;
+
+    BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+
+    ENQUEUE_FRM(&fmFd);
+
+    /* check that profile is valid */
+    if (!FmPcdPlcrHwProfileIsValid(hcFrame.hcSpecificData.profileRegs.fmpl_pemode))
+    {
+        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Policer is already used"));
+    }
+
+    hcFrame.opcode = 0x00000000;
+    hcFrame.actionReg  = FmPcdPlcrBuildWritePlcrActionReg(absoluteProfileId);
+    hcFrame.actionReg |= FmPcdPlcrBuildCounterProfileReg(counter);
+    hcFrame.extraReg = 0x00008000;
+    hcFrame.commandSequence = p_FmHc->seqNum;
+    hcFrame.hcSpecificData.singleRegForWrite = value;
+
+    BUILD_FD(SIZE_OF_HC_FRAME_PROFILE_CNT);
+
+    ENQUEUE_FRM(&fmFd);
+
+    FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+
+    return E_OK;
+}
+
+uint32_t FmHcPcdPlcrGetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter)
+{
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    uint16_t                            absoluteProfileId = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
+    t_Error                             err;
+    t_HcFrame                           hcFrame;
+    t_FmFD                              fmFd;
+    uint32_t                            retVal;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmHc, E_INVALID_HANDLE,0);
+
+    if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, absoluteProfileId))
+        return 0;
+
+    /* first read scheme and check that it is valid */
+    memset(&hcFrame, 0, sizeof(hcFrame));
+    hcFrame.opcode = 0x00000000;
+    hcFrame.actionReg  = FmPcdPlcrBuildReadPlcrActionReg(absoluteProfileId);
+    hcFrame.extraReg = 0x00008000;
+    hcFrame.commandSequence = p_FmHc->seqNum;
+
+    BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+
+    ENQUEUE_FRM(&fmFd);
+
+    /* check that profile is valid */
+    if (!FmPcdPlcrHwProfileIsValid(hcFrame.hcSpecificData.profileRegs.fmpl_pemode))
+    {
+        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Policer is already used"));
+    }
+
+    switch (counter)
+    {
+        case e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER:
+            retVal = hcFrame.hcSpecificData.profileRegs.fmpl_pegpc;
+            break;
+        case e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER:
+            retVal = hcFrame.hcSpecificData.profileRegs.fmpl_peypc;
+            break;
+        case e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER:
+            retVal = hcFrame.hcSpecificData.profileRegs.fmpl_perpc;
+            break;
+        case e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER:
+            retVal = hcFrame.hcSpecificData.profileRegs.fmpl_perypc;
+            break;
+        case e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER:
+            retVal = hcFrame.hcSpecificData.profileRegs.fmpl_perrpc;
+            break;
+        default:
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            retVal = 0;
+    }
+
+    FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
+
+    return retVal;
+}
+
+t_Error FmHcPcdCcModifyTreeNextEngine(t_Handle h_FmHc, t_Handle h_CcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error     err = E_OK;
+    t_Handle    h_OldPointer, h_NewPointer;
+
+    if ((err = FmPcdCcTreeTryLock(h_CcTree)) != E_OK)
+        return err;
+
+    err = FmPcdCcModifyNextEngineParamTree(p_FmHc->h_FmPcd, h_CcTree, grpId, index, p_FmPcdCcNextEngineParams,
+            &h_OldPointer, &h_NewPointer);
+    if(err)
+    {
+        FmPcdCcTreeReleaseLock(h_CcTree);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = CcHcDynamicChangeForNextEngine(p_FmHc, h_OldPointer, h_NewPointer);
+    FmPcdCcTreeReleaseLock(h_CcTree);
+    return err;
+}
+
+t_Error FmHcPcdCcModifyNodeNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error     err = E_OK;
+    t_Handle    h_OldPointer, h_NewPointer;
+    t_List      h_List;
+
+    INIT_LIST(&h_List);
+
+    if (FmPcdTryLock(p_FmHc->h_FmPcd) != E_OK)
+        return err;
+
+    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
+    {
+        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        return err;
+    }
+
+    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+    err = FmPcdCcModiyNextEngineParamNode(p_FmHc->h_FmPcd, h_CcNode, keyIndex, p_FmPcdCcNextEngineParams, &h_OldPointer, &h_NewPointer);
+    if(err)
+    {
+        FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err =   CcHcDynamicChangeForNextEngine(p_FmHc, h_OldPointer, h_NewPointer);
+    FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+    return err;
+}
+
+t_Error FmHcPcdCcModifyNodeMissNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error     err = E_OK;
+    t_Handle    h_OldPointer, h_NewPointer;
+    t_List      h_List      ;
+
+    INIT_LIST(&h_List);
+
+    if (FmPcdTryLock(p_FmHc->h_FmPcd) != E_OK)
+        return err;
+
+    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
+    {
+        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        return err;
+    }
+
+    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+
+    err = FmPcdCcModifyMissNextEngineParamNode(p_FmHc->h_FmPcd, h_CcNode, p_FmPcdCcNextEngineParams, &h_OldPointer, &h_NewPointer);
+    if(err)
+    {
+        FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err =   CcHcDynamicChangeForNextEngine(p_FmHc, h_OldPointer, h_NewPointer);
+
+    FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+
+    return E_OK;
+}
+
+t_Error FmHcPcdCcRemoveKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Handle    h_NewPointer;
+    t_List      h_OldPointersLst;
+    t_Error     err;
+    t_List      h_List      ;
+
+    INIT_LIST(&h_List);
+
+    if ((err = FmPcdTryLock(p_FmHc->h_FmPcd)) != E_OK)
+        return err;
+
+    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
+    {
+        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        return err;
+    }
+
+    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+
+    INIT_LIST(&h_OldPointersLst);
+
+    err = FmPcdCcRemoveKey(p_FmHc->h_FmPcd,h_CcNode,keyIndex, &h_OldPointersLst,&h_NewPointer);
+    if(err)
+    {
+        FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err =  HcDynamicChangeForKey(p_FmHc, (t_Handle)&h_OldPointersLst, h_NewPointer);
+
+    FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+
+    return E_OK;
+}
+
+t_Error FmHcPcdCcAddKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Handle    h_NewPointer;
+    t_List      h_OldPointersLst;
+    t_Error     err;
+    t_List      h_List;
+
+    UNUSED(keySize);
+
+    INIT_LIST(&h_List);
+
+    if ((err = FmPcdTryLock(p_FmHc->h_FmPcd)) != E_OK)
+        return err;
+
+    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
+    {
+        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        return err;
+    }
+
+    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+
+    INIT_LIST(&h_OldPointersLst);
+
+
+    err = FmPcdCcAddKey(p_FmHc->h_FmPcd,h_CcNode,keyIndex,p_KeyParams, &h_OldPointersLst,&h_NewPointer);
+    if(err)
+    {
+        FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err =  HcDynamicChangeForKey(p_FmHc, (t_Handle)&h_OldPointersLst, h_NewPointer);
+
+    FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+
+    return err;
+}
+
+t_Error FmHcPcdCcModifyKeyAndNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_List      h_OldPointersLst;
+    t_Handle    h_NewPointer;
+    t_Error     err;
+    t_List      h_List;
+
+    UNUSED(keySize);
+
+    INIT_LIST(&h_List);
+
+    if ((err = FmPcdTryLock(p_FmHc->h_FmPcd)) != E_OK)
+        return err;
+
+    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
+    {
+        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        return err;
+    }
+
+    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+
+    INIT_LIST(&h_OldPointersLst);
+
+    err = FmPcdCcModifyKeyAndNextEngine(p_FmHc->h_FmPcd,h_CcNode,keyIndex,p_KeyParams, &h_OldPointersLst,&h_NewPointer);
+    if(err)
+    {
+        FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err =  HcDynamicChangeForKey(p_FmHc, (t_Handle)&h_OldPointersLst, h_NewPointer);
+
+    FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+
+    return err;
+}
+
+t_Error FmHcPcdCcModifyKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, uint8_t  *p_Key, uint8_t *p_Mask)
+{
+    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
+    t_List      h_OldPointersLst;
+    t_Handle    h_NewPointer;
+    t_Error     err;
+    t_List      h_List;
+    UNUSED(keySize);
+
+    INIT_LIST(&h_List);
+
+    if ((err = FmPcdTryLock(p_FmHc->h_FmPcd)) != E_OK)
+        return err;
+
+    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
+    {
+        FmPcdReleaseLock(p_FmHc->h_FmPcd);
+        return err;
+    }
+
+    FmPcdReleaseLock(p_FmHc->h_FmPcd);
+
+    INIT_LIST(&h_OldPointersLst);
+
+    err = FmPcdCcModifyKey(p_FmHc->h_FmPcd, h_CcNode, keyIndex, p_Key, p_Mask, &h_OldPointersLst,&h_NewPointer);
+    if(err)
+    {
+        FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err =  HcDynamicChangeForKey(p_FmHc, (t_Handle)&h_OldPointersLst, h_NewPointer);
+    FmPcdCcNodeTreeReleaseLock(p_FmHc->h_FmPcd, &h_List);
+
+    return err;
+}
+
+t_Error FmHcPortPcdKgModifyClsPlanGrp (t_Handle h_FmHc, t_Handle h_FmPort, bool useClsPlan, t_Handle h_NewClsPlanGrp)
+{
+    t_FmHc          *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error         err;
+    uint32_t        cppReg;
+
+    /* deal with SW */
+    FmPortPcdKgSwUnbindClsPlanGrp(h_FmPort);
+
+    err = FmPortPcdKgSwBindClsPlanGrp(h_FmPort, useClsPlan, (uint8_t)(CAST_POINTER_TO_UINT32(h_NewClsPlanGrp)-1));
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    /* deal with HW */
+    cppReg = FmPcdKgBuildCppReg(p_FmHc->h_FmPcd, FmPortGetClsPlanId(h_FmPort));
+    err = KgHcWriteCpp(p_FmHc, FmPortGetHardwarePortId(h_FmPort), cppReg);
+
+    return err;
+}
+
+t_Error FmHcPortPcdKgBindSchemes(t_Handle h_FmHc , t_Handle h_FmPort,t_FmPcdPortSchemesParams *p_PortScheme)
+{
+    return HcPortPcdKgBindSchemes(h_FmHc, h_FmPort, p_PortScheme);
+}
+
+t_Error FmHcPortPcdKgUnbindSchemes(t_Handle h_FmHc , t_Handle h_FmPort,t_FmPcdPortSchemesParams *p_PortScheme)
+{
+    t_FmHc                                  *p_FmHc = (t_FmHc*)h_FmHc;
+    uint32_t                                spReg;
+    t_Error                                 err;
+    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+    int                                     i;
+
+    /* we use this routine just to get the port parameters such as HW id, netEnv etc. */
+    FmPortGetPortSchemeBindParams(h_FmPort, &schemeBind);
+
+    /* overwrite port params with the schemes we want removed */
+    schemeBind.numOfSchemes = p_PortScheme->numOfSchemes;
+    for (i=0; i<schemeBind.numOfSchemes; i++)
+        schemeBind.schemesIds[i] = (uint8_t)(CAST_POINTER_TO_UINT32(p_PortScheme->h_Schemes[i])-1);
+
+    err = FmPcdKgBuildBindPortToSchemes(p_FmHc->h_FmPcd, &schemeBind, &spReg, FALSE);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    err = KgHcWriteSp(h_FmHc, schemeBind.hardwarePortId, spReg, FALSE);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    FmPcdKgDecSchemeOwners(p_FmHc->h_FmPcd, &schemeBind);
+
+    return E_OK;
+}
+
+t_Error FmHcPortSetPCD(t_Handle h_FmHc, t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
+{
+    t_FmHc                                  *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error                                 err = E_OK;
+    t_FmPcdPortSchemesParams                schemeBind;
+    uint32_t                                cppReg;
+    uint8_t                                 i;
+
+    err = FmPortSetPcd(h_FmPort, p_PcdParams);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    if(FmPortGetPcdEngines(h_FmPort) & FM_PCD_KG)
+    {
+        schemeBind.numOfSchemes = p_PcdParams->p_KgParams->numOfSchemes;
+        for(i = 0;i<schemeBind.numOfSchemes;i++)
+            schemeBind.h_Schemes[i] = p_PcdParams->p_KgParams->h_Schemes[i];
+        err = HcPortPcdKgBindSchemes(h_FmHc ,h_FmPort, &schemeBind);
+        if(err)
+        {
+            FmPortDeletePcd(h_FmPort);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+
+        cppReg = FmPcdKgBuildCppReg(p_FmHc->h_FmPcd, FmPortGetClsPlanId(h_FmPort));
+
+        err = KgHcWriteCpp(p_FmHc, FmPortGetHardwarePortId(h_FmPort), cppReg);
+        if(err)
+        {
+            FmPortDeletePcd(h_FmPort);
+            FmHcPortPcdKgUnbindSchemes(p_FmHc->h_FmPcd, h_FmPort, &schemeBind);
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        }
+    }
+
+    FmPcdIncNetEnvOwners(p_FmHc->h_FmPcd, FmPortGetNetEnvId(h_FmPort));
+
+    return FmPortAttachPCD(h_FmPort);
+}
+
+t_Error FmHcPortDeletePCD(t_Handle h_FmHc, t_Handle h_FmPort)
+{
+    t_FmHc                                  *p_FmHc = (t_FmHc*)h_FmHc;
+    t_Error                                 err = E_OK;
+    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+    t_FmPcdPortSchemesParams                currentSchemes;
+    int                                     i;
+
+    if(FmPortGetPcdEngines(h_FmPort) & FM_PCD_KG)
+    {
+        /* read port schemes params - we will use here only the schemes */
+        FmPortGetPortSchemeBindParams(h_FmPort, &schemeBind);
+
+        currentSchemes.numOfSchemes = schemeBind.numOfSchemes;
+        for (i=0; i<schemeBind.numOfSchemes; i++)
+            currentSchemes.h_Schemes[i] = CAST_UINT32_TO_POINTER(schemeBind.schemesIds[i]+1);
+
+        err = FmHcPortPcdKgUnbindSchemes(h_FmHc , h_FmPort, &currentSchemes);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+
+        err = KgHcWriteCpp(p_FmHc, FmPortGetHardwarePortId(h_FmPort), 0);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    err = FmPortDeletePcd( h_FmPort);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    FmPcdDecNetEnvOwners(p_FmHc->h_FmPcd, FmPortGetNetEnvId(h_FmPort));
+
+    return E_OK;
+}
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/Makefile b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/Makefile
new file mode 100644
index 0000000..7c63f97
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/Makefile
@@ -0,0 +1,18 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+NCSW_FM_INC = $(srctree)/drivers/net/dpa/NetCommSw/Peripherals/FM/inc
+
+EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+
+obj-y		+= fsl-ncsw-MAC.o
+
+fsl-ncsw-MAC-objs	:=   dtsec.o dtsec_mii_acc.o fm_mac.o tgec.o tgec_mii_acc.o
+
+
+
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
new file mode 100644
index 0000000..641814a
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
@@ -0,0 +1,1358 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          dtsec.c
+
+ @Description   FM dTSEC ...
+*//***************************************************************************/
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "xx_ext.h"
+#include "endian_ext.h"
+#include "crc_mac_addr_ext.h"
+#include "debug_ext.h"
+
+#include "dtsec.h"
+
+
+/*****************************************************************************/
+/*                      Internal routines                                    */
+/*****************************************************************************/
+
+static t_Error CheckInitParameters(t_Dtsec *p_Dtsec)
+{
+    if(ENET_SPEED_FROM_MODE(p_Dtsec->enetMode) >= e_ENET_SPEED_10000)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet 10G MAC driver only support 10G speed"));
+    if(p_Dtsec->macId >= FM_MAX_NUM_OF_1G_MACS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("macId of 10 G can not be greater than 0"));
+    if(p_Dtsec->addr == 0)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet 10G MAC Must have a valid MAC Address"));
+    if(((p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000)) &&
+        p_Dtsec->p_DtsecDriverParam->halfDuplex)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet MAC 1G can't work in halfDuplex"));
+    if(p_Dtsec->p_DtsecDriverParam->halfDuplex && (p_Dtsec->p_DtsecDriverParam)->loopback)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("LoopBack is not supported in halfDuplex mode"));
+    if(((p_Dtsec->p_DtsecDriverParam)->preambleTxEn ||(p_Dtsec->p_DtsecDriverParam)->preambleRxEn)  &&( (p_Dtsec->p_DtsecDriverParam)->preambleLength != 0x7))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("if user defined preamble is transmitted - preamble length should be 0x7"));
+    if((p_Dtsec->p_DtsecDriverParam)->fifoTxWatermarkH<((p_Dtsec->p_DtsecDriverParam)->fifoTxThr+8))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoTxWatermarkH has to be at least 8 larger than fifoTxThr"));
+    if((p_Dtsec->p_DtsecDriverParam)->halfDuplex &&
+       (p_Dtsec->p_DtsecDriverParam->txTimeStampEn || p_Dtsec->p_DtsecDriverParam->rxTimeStampEn))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dTSEC in half dupplex mode has to be with 1588 timeStamping diable"));
+    if((p_Dtsec->p_DtsecDriverParam)->actOnRxPauseFrame && (p_Dtsec->p_DtsecDriverParam)->controlFrameAccept )
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("receive control frame are not passed to the system memory so it can not be accept "));
+    if((p_Dtsec->p_DtsecDriverParam)->packetAlignmentPadding  > MAX_PACKET_ALIGNMENT)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("packetAlignmentPadding can't be greater than %d ",MAX_PACKET_ALIGNMENT ));
+    if(((p_Dtsec->p_DtsecDriverParam)->nonBackToBackIpg1  > MAX_INTER_PACKET_GAP) ||
+        ((p_Dtsec->p_DtsecDriverParam)->nonBackToBackIpg2 > MAX_INTER_PACKET_GAP) ||
+        ((p_Dtsec->p_DtsecDriverParam)->backToBackIpg > MAX_INTER_PACKET_GAP))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("inter packet gap can't be greater than %d ",MAX_INTER_PACKET_GAP ));
+    if((p_Dtsec->p_DtsecDriverParam)->alternateBackoffVal > MAX_INTER_PALTERNATE_BEB)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("alternateBackoffVal can't be greater than %d ",MAX_INTER_PALTERNATE_BEB ));
+    if((p_Dtsec->p_DtsecDriverParam)->maxRetransmission > MAX_RETRANSMISSION)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("maxRetransmission can't be greater than %d ",MAX_RETRANSMISSION ));
+    if((p_Dtsec->p_DtsecDriverParam)->collisionWindow > MAX_COLLISION_WINDOW)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("collisionWindow can't be greater than %d ",MAX_COLLISION_WINDOW ));
+
+    return E_OK;
+}
+
+/* ........................................................................... */
+
+static void SetDefaultParam(t_Dtsec *p_Dtsec, t_DtsecDriverParam *p_DtsecDriverParam)
+{
+    UNUSED(p_Dtsec);
+
+    p_DtsecDriverParam->errorDisabled       = DEFAULT_errorDisabled;
+
+    p_DtsecDriverParam->autoZeroCounters    = DEFAULT_autoZeroCounters;
+    p_DtsecDriverParam->statisticsEnable    = DEFAULT_statisticsEnable;
+    p_DtsecDriverParam->promiscuousEnable   = DEFAULT_promiscuousEnable;
+
+    p_DtsecDriverParam->pauseExtended       = DEFAULT_pauseExtended;
+    p_DtsecDriverParam->pauseTime           = DEFAULT_pauseTime;
+
+    p_DtsecDriverParam->halfDuplex          = DEFAULT_halfDuplex;
+    p_DtsecDriverParam->halfDulexFlowControlEn  = DEFAULT_halfDulexFlowControlEn;
+    p_DtsecDriverParam->txTimeStampEn       = DEFAULT_txTimeStampEn;
+    p_DtsecDriverParam->rxTimeStampEn       = DEFAULT_rxTimeStampEn;
+
+    p_DtsecDriverParam->packetAlignmentPadding = DEFAULT_packetAlignment;
+    p_DtsecDriverParam->controlFrameAccept   = DEFAULT_controlFrameAccept;
+    p_DtsecDriverParam->groupHashExtend      = DEFAULT_groupHashExtend;
+    p_DtsecDriverParam->broadcReject         = DEFAULT_broadcReject;
+    p_DtsecDriverParam->rxShortFrame         = DEFAULT_rxShortFrame;
+    p_DtsecDriverParam->exactMatch           = DEFAULT_exactMatch;
+    p_DtsecDriverParam->debugMode            = DEFAULT_debugMode;
+
+    p_DtsecDriverParam->loopback             = DEFAULT_loopback;
+    p_DtsecDriverParam->actOnRxPauseFrame    = DEFAULT_actOnRxPauseFrame;
+    p_DtsecDriverParam->actOnTxPauseFrame    = DEFAULT_actOnTxPauseFrame;
+
+    p_DtsecDriverParam->preambleLength       = DEFAULT_PreAmLength;
+    p_DtsecDriverParam->preambleRxEn         = DEFAULT_PreAmRxEn;
+    p_DtsecDriverParam->preambleTxEn         = DEFAULT_PreAmTxEn;
+    p_DtsecDriverParam->hugeFramesEnable     = DEFAULT_hugeFrames;
+    p_DtsecDriverParam->lengthCheckEnable    = DEFAULT_lengthCheckEnable;
+    p_DtsecDriverParam->padAndCrcEnable      = DEFAULT_padAndCrcEnable;
+    p_DtsecDriverParam->crcEnable            = DEFAULT_crcEnable;
+
+    p_DtsecDriverParam->nonBackToBackIpg1    = DEFAULT_nonBackToBackIpg1;
+    p_DtsecDriverParam->nonBackToBackIpg2    = DEFAULT_nonBackToBackIpg2;
+    p_DtsecDriverParam->minIfgEnforcement    = DEFAULT_minIfgEnforcement;
+    p_DtsecDriverParam->backToBackIpg        = DEFAULT_backToBackIpg;
+
+    p_DtsecDriverParam->alternateBackoffVal    = DEFAULT_altBackoffVal;
+    p_DtsecDriverParam->alternateBackoffEnable = DEFAULT_altBackoffEnable;
+    p_DtsecDriverParam->backPressureNoBackoff = DEFAULT_backPressureNoBackoff;
+    p_DtsecDriverParam->noBackoff             = DEFAULT_noBackoff;
+    p_DtsecDriverParam->excessDefer           = DEFAULT_excessDefer;
+    p_DtsecDriverParam->maxRetransmission     = DEFAULT_maxRetransmission;
+    p_DtsecDriverParam->collisionWindow       = DEFAULT_collisionWindow;
+
+    p_DtsecDriverParam->maxFrameLength        = DEFAULT_maxFrameLength;
+
+    p_DtsecDriverParam->cam1                  = DEFAULT_cam;
+    p_DtsecDriverParam->cam2                  = DEFAULT_cam;
+
+    p_DtsecDriverParam->fifoTxThr          = DEFAULT_fifoTxThr;
+    p_DtsecDriverParam->fifoTxWatermarkH   = DEFAULT_fifoTxWatermarkH;
+
+    p_DtsecDriverParam->fifoRxWatermarkL   = DEFAULT_fifoRxWatermarkL;
+
+//#warning /*TODO - Handle Interrupt Mask */ /*    p_DtsecDriverParam->imask              = DEFAULT_imask;    */
+}
+
+/* ........................................................................... */
+
+static void FreeInitResources(t_Dtsec *p_Dtsec)
+{
+    /* release the driver's group hash table */
+    FreeHashTable(p_Dtsec->p_MulticastAddrHash);
+    p_Dtsec->p_MulticastAddrHash =   NULL;
+
+    /* release the driver's individual hash table */
+    FreeHashTable(p_Dtsec->p_UnicastAddrHash);
+    p_Dtsec->p_UnicastAddrHash =     NULL;
+}
+
+/* ........................................................................... */
+
+static void HardwareClearAddrInPaddr(t_Dtsec *p_Dtsec, uint8_t paddrNum)
+{
+    WRITE_UINT32(((t_DtsecMemMap*)p_Dtsec->p_MemMap)->macaddr[paddrNum].exact_match1, 0x0);
+    WRITE_UINT32(((t_DtsecMemMap*)p_Dtsec->p_MemMap)->macaddr[paddrNum].exact_match2, 0x0);
+}
+
+/* ........................................................................... */
+
+static void HardwareAddAddrInPaddr(t_Dtsec *p_Dtsec, uint64_t *p_Addr, uint8_t paddrNum)
+{
+    uint32_t tmpReg32 = 0;
+    uint64_t addr = *p_Addr;
+    t_DtsecMemMap  *p_DtsecMemMap = (t_DtsecMemMap*)p_Dtsec->p_MemMap;
+
+    tmpReg32 = (uint32_t)(addr);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_DtsecMemMap->macaddr[paddrNum].exact_match1, tmpReg32);
+
+    tmpReg32 = (uint32_t)(addr>>32);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_DtsecMemMap->macaddr[paddrNum].exact_match2, tmpReg32);
+}
+
+/* ........................................................................... */
+
+static void rxGracefulStop(t_Dtsec *p_Dtsec)
+{
+    t_DtsecMemMap *p_MemMap = (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+    WRITE_UINT32(p_MemMap->rctrl,
+                  GET_UINT32(p_MemMap->rctrl) | RCTRL_GRS);
+}
+
+/* ........................................................................... */
+
+static void txGracefulStop(t_Dtsec *p_Dtsec)
+{
+    t_DtsecMemMap *p_MemMap = (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+
+    SANITY_CHECK_RETURN(p_Dtsec, E_INVALID_HANDLE);
+
+    /* Assert the graceful transmit stop bit */
+    WRITE_UINT32(p_MemMap->tctrl,
+                  GET_UINT32(p_MemMap->tctrl) | TCTRL_GTS);
+}
+
+/*****************************************************************************/
+/*                      FM Init & Free API                                   */
+/*****************************************************************************/
+
+/* ........................................................................... */
+
+static t_Error DtsecInit(t_Handle h_Dtsec)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecDriverParam  *p_DtsecDriverParam;
+    t_DtsecMemMap       *p_DtsecMemMap;
+    bool                isRgmii = FALSE, isResetCnfgRgmiiMode = FALSE;
+    bool                isSgmii = FALSE, isResetCnfgSgmiiMode = FALSE;
+    bool                isReducedPin = FALSE,  isResetCnfgReducedPin = FALSE;
+    bool                is100 = FALSE,  isResetCnfg100 = FALSE;
+    int                 i;
+    uint32_t            tmpReg32;
+    uint64_t            addr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_STATE);
+
+    CHECK_INIT_PARAMETERS(p_Dtsec, CheckInitParameters);
+
+    p_DtsecDriverParam  = p_Dtsec->p_DtsecDriverParam;
+    p_Dtsec->halfDuplex = p_DtsecDriverParam->halfDuplex;
+    p_Dtsec->debugMode  = p_DtsecDriverParam->debugMode;
+    p_DtsecMemMap       = p_Dtsec->p_MemMap;
+
+/*************dtsec_id2******************/
+   tmpReg32 =  GET_UINT32(p_DtsecMemMap->tsec_id2);
+
+   if ((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
+       (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) ||
+       (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000))
+       if(tmpReg32 & ID2_INT_REDUCED_OFF)
+       {
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("no support for reduced interface in current DTSEC version"));
+       }
+
+   if ((p_Dtsec->enetMode == e_ENET_MODE_SGMII_10) ||
+       (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100) ||
+       (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000))
+       if(tmpReg32 & ID2_INT_NORMAL_OFF)
+       {
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("no support for normal interface in current DTSEC version"));
+       }
+/*************dtsec_id2******************/
+
+/***************EDIS************************/
+    WRITE_UINT32(p_DtsecMemMap->edis, p_DtsecDriverParam->errorDisabled);
+/***************EDIS************************/
+
+/***************ECNTRL************************/
+    tmpReg32 = GET_UINT32(p_DtsecMemMap->ecntrl);
+
+    if(tmpReg32 & ECNTRL_CFG_RO)
+    {
+        isRgmii = (( p_Dtsec->enetMode == e_ENET_MODE_RGMII_10)   ||
+                            (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)  ||
+                            (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||(p_Dtsec->enetMode == e_ENET_MODE_GMII_1000)) ? TRUE : FALSE;
+        isResetCnfgRgmiiMode= (tmpReg32 & ECNTRL_GMIIM) ? TRUE : FALSE;
+        if((isRgmii && !isResetCnfgRgmiiMode) ||
+            (!isRgmii && isResetCnfgRgmiiMode))
+          RETURN_ERROR(MAJOR, E_CONFLICT,(" Error. Reduced mode not configured properly. Check eTsec cfg switch \n"));
+
+        isSgmii = (( p_Dtsec->enetMode == e_ENET_MODE_SGMII_10)   ||
+                            (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100)  ||
+                            (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)) ? TRUE : FALSE;
+        isResetCnfgSgmiiMode = (tmpReg32 & ECNTRL_SGMIIM) ? TRUE : FALSE;
+        if((isSgmii && !isResetCnfgSgmiiMode) ||
+            (!isSgmii && isResetCnfgSgmiiMode))
+          RETURN_ERROR(MAJOR, E_CONFLICT,(" Error. SGMII mode not configured properly. Check dTsec cfg switch \n"));
+
+        isReducedPin = ((p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) || (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) ||
+                            (p_Dtsec->enetMode == e_ENET_MODE_RGMII_10)) ? TRUE : FALSE;
+        isResetCnfgReducedPin= (tmpReg32 & ECNTRL_RPM) ? TRUE : FALSE;
+        if((isReducedPin && !isResetCnfgReducedPin) || (!isReducedPin && isResetCnfgReducedPin))
+          RETURN_ERROR(MAJOR, E_CONFLICT,(" Error. reduced pin interface is not configured properly. Check dTsec cfg switch \n"));
+
+        is100 = (( p_Dtsec->enetMode == e_ENET_MODE_SGMII_100)   ||
+                            (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)) ? TRUE : FALSE;
+        isResetCnfg100 = (tmpReg32 & ECNTRL_R100M) ? TRUE : FALSE;
+        if((is100 && !isResetCnfg100) ||
+            (!is100 && isResetCnfg100))
+          RETURN_ERROR(MAJOR, E_CONFLICT,(" Error. 100 speed interface is not configured properly. Check dTsec cfg switch \n"));
+
+    }
+    else
+    {
+      tmpReg32 = 0;
+      if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10)                     ||
+                           (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)  ||
+                            (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000)  || (p_Dtsec->enetMode == e_ENET_MODE_GMII_1000))
+            tmpReg32 |= ECNTRL_GMIIM;
+      if((p_Dtsec->enetMode == e_ENET_MODE_SGMII_10)   ||
+          (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100)  ||
+          (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000))
+            tmpReg32 |= (ECNTRL_SGMIIM | ECNTRL_TBIM);
+       if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) || (p_Dtsec->enetMode == e_ENET_MODE_RGMII_10)||
+                (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100))
+            tmpReg32 |= ECNTRL_RPM;
+       if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) || (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100))
+            tmpReg32 |= ECNTRL_R100M;
+    }
+
+    if (p_DtsecDriverParam->autoZeroCounters)
+        tmpReg32 |= ECNTRL_AUTOZ;
+    if(p_DtsecDriverParam->statisticsEnable)
+        tmpReg32 |= ECNTRL_STEN ;
+
+    WRITE_UINT32(p_DtsecMemMap->ecntrl, tmpReg32);
+
+/***************ECNTRL************************/
+/***************PTV************************/
+    /* initialize PTV */
+    tmpReg32 = 0;
+
+    if (p_DtsecDriverParam->pauseTime)
+        tmpReg32 |= (uint32_t)p_DtsecDriverParam->pauseTime;
+
+    if (p_DtsecDriverParam->pauseExtended)
+        tmpReg32 |= ((uint32_t)p_DtsecDriverParam->pauseExtended) << PTV_PTE_OFST;
+
+    WRITE_UINT32(p_DtsecMemMap->ptv, tmpReg32);
+
+/***************PTV************************/
+
+/***************TCTRL************************/
+    tmpReg32 = 0;
+    if(p_DtsecDriverParam->halfDuplex)
+    {
+        if(p_DtsecDriverParam->halfDulexFlowControlEn)
+            tmpReg32 |= TCTRL_THDF;
+    }
+    else
+    {
+        if(p_DtsecDriverParam->txTimeStampEn)
+            tmpReg32 |= TCTRL_TTSE;
+    }
+    WRITE_UINT32(p_DtsecMemMap->tctrl, tmpReg32);
+/***************TCTRL************************/
+/***************RCTRL************************/
+    tmpReg32 = 0;
+    if (p_DtsecDriverParam->packetAlignmentPadding)
+        tmpReg32 |= ((uint32_t)(0x0000001f & p_DtsecDriverParam->packetAlignmentPadding)) << 16;
+    if (p_DtsecDriverParam->controlFrameAccept)
+        tmpReg32 |= RCTRL_CFA;
+    if (p_DtsecDriverParam->groupHashExtend)
+        tmpReg32 |= RCTRL_GHTX;
+    if(p_DtsecDriverParam->rxTimeStampEn)
+        tmpReg32 |= RCTRL_RTSE;
+    if (p_DtsecDriverParam->broadcReject)
+        tmpReg32 |= RCTRL_BC_REJ;
+    if (p_DtsecDriverParam->rxShortFrame)
+        tmpReg32 |= RCTRL_RSF;
+    if (p_DtsecDriverParam->promiscuousEnable)
+        tmpReg32 |= RCTRL_PROM;
+    if (p_DtsecDriverParam->exactMatch)
+        tmpReg32 |= RCTRL_EMEN;
+
+    WRITE_UINT32(p_DtsecMemMap->rctrl, tmpReg32);
+
+/***************RCTRL************************/
+/***************IMASK************************/
+    WRITE_UINT32(p_DtsecMemMap->imask, p_DtsecDriverParam->imask);
+/***************IMASK************************/
+/***************IEVENT************************/
+    WRITE_UINT32(p_DtsecMemMap->ievent, 0xc7c7cfc3);
+/***************IEVENT************************/
+/***************DEBUG************************/
+    tmpReg32 = 0;
+    if(p_DtsecDriverParam->debugMode)
+        WRITE_UINT32(p_DtsecMemMap->tsec_id1, TSEC_ID1_DEBUG);
+/***************DEBUG************************/
+/***************MACCFG1***********************/
+
+    WRITE_UINT32(p_DtsecMemMap->maccfg1, MACCFG1_SOFT_RESET);
+    WRITE_UINT32(p_DtsecMemMap->maccfg1, 0);
+    tmpReg32 = 0;
+    if(p_DtsecDriverParam->loopback)
+        tmpReg32 |= MACCFG1_LOOPBACK;
+    if(p_DtsecDriverParam->actOnRxPauseFrame)
+        tmpReg32 |= MACCFG1_RX_FLOW;
+    if(p_DtsecDriverParam->actOnTxPauseFrame)
+        tmpReg32 |= MACCFG1_TX_FLOW;
+    WRITE_UINT32(p_DtsecMemMap->maccfg1, tmpReg32);
+
+/***************MACCFG1***********************/
+/***************MACCFG2***********************/
+    tmpReg32 = 0;
+
+    if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_10) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100))
+            tmpReg32 |= MACCFG2_NIBBLE_MODE;
+
+    else if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)||
+        (p_Dtsec->enetMode == e_ENET_MODE_GMII_1000))
+            tmpReg32 |= MACCFG2_BYTE_MODE;
+
+    tmpReg32 |= (((uint32_t)p_DtsecDriverParam->preambleLength) & 0x0000000f)<< PREAMBLE_LENGTH_SHIFT;
+
+    if(p_DtsecDriverParam->preambleRxEn)
+        tmpReg32 |= MACCFG2_PRE_AM_Rx_EN;
+    if(p_DtsecDriverParam->preambleTxEn)
+        tmpReg32 |= MACCFG2_PRE_AM_Tx_EN;
+    if(p_DtsecDriverParam->hugeFramesEnable)
+        tmpReg32 |= MACCFG2_HUGE_FRAME;
+    if(p_DtsecDriverParam->lengthCheckEnable)
+        tmpReg32 |= MACCFG2_LENGTH_CHECK;
+    if(p_DtsecDriverParam->padAndCrcEnable)
+        tmpReg32 |=  MACCFG2_PAD_CRC_EN;
+    if(p_DtsecDriverParam->crcEnable)
+        tmpReg32 |= MACCFG2_CRC_EN ;
+    if(!p_DtsecDriverParam->halfDuplex)
+        tmpReg32 |= MACCFG2_FULL_DUPLEX;
+
+    WRITE_UINT32(p_DtsecMemMap->maccfg2, tmpReg32);
+/***************MACCFG2***********************/
+/***************IPGIFG************************/
+
+    tmpReg32 = 0;
+    ASSERT_COND(p_DtsecDriverParam->nonBackToBackIpg1 <= p_DtsecDriverParam->nonBackToBackIpg2);
+    tmpReg32 = (uint32_t)((((uint32_t)p_DtsecDriverParam->nonBackToBackIpg1 <<
+               IPGIFG_NON_BACK_TO_BACK_IPG_1_SHIFT) & IPGIFG_NON_BACK_TO_BACK_IPG_1) |
+              (((uint32_t)p_DtsecDriverParam->nonBackToBackIpg2  <<
+                IPGIFG_NON_BACK_TO_BACK_IPG_2_SHIFT) & IPGIFG_NON_BACK_TO_BACK_IPG_2) |
+              (((uint32_t)p_DtsecDriverParam->minIfgEnforcement <<
+                IPGIFG_MIN_IFG_ENFORCEMENT_SHIFT) & IPGIFG_MIN_IFG_ENFORCEMENT) |
+              ((uint32_t)p_DtsecDriverParam->backToBackIpg & IPGIFG_BACK_TO_BACK_IPG));
+
+    WRITE_UINT32(p_DtsecMemMap->ipgifg, tmpReg32);
+
+/***************IPGIFG************************/
+/***************HAFDUP************************/
+    tmpReg32 = 0;
+    if(p_DtsecDriverParam->alternateBackoffEnable)
+    {
+        tmpReg32 = (uint32_t) (HAFDUP_ALT_BEB  | (((uint32_t)p_DtsecDriverParam->alternateBackoffVal & 0x0000000f) <<
+                                    HAFDUP_ALTERNATE_BEB_TRUNCATION_SHIFT));
+    }
+
+    if(p_DtsecDriverParam->backPressureNoBackoff)
+        tmpReg32 |= HAFDUP_BP_NO_BACKOFF ;
+    if(p_DtsecDriverParam->noBackoff)
+        tmpReg32 |= HAFDUP_NO_BACKOFF ;
+    if(p_DtsecDriverParam->excessDefer)
+        tmpReg32 |= HAFDUP_EXCESS_DEFER ;
+    tmpReg32 |= (((uint32_t)p_DtsecDriverParam->maxRetransmission <<
+                HAFDUP_RETRANSMISSION_MAX_SHIFT )& HAFDUP_RETRANSMISSION_MAX);
+    tmpReg32|= ((uint32_t)p_DtsecDriverParam->collisionWindow & HAFDUP_COLLISION_WINDOW) ;
+
+    WRITE_UINT32(p_DtsecMemMap->hafdup, tmpReg32);
+/***************HAFDUP************************/
+/***************MAXFRM************************/
+
+    /* Initialize MAXFRM */
+    WRITE_UINT32(p_DtsecMemMap->maxfrm,
+                 p_DtsecDriverParam->maxFrameLength);
+
+/***************MAXFRM************************/
+/***************MII************************/
+//#warning /*TODO - to take care about MII stuff*/
+/***************MII************************/
+/***************CAM1************************/
+
+    WRITE_UINT32(p_DtsecMemMap->cam1,
+                 p_DtsecDriverParam->cam1);
+
+/***************CAM1************************/
+/***************CAM2************************/
+
+    WRITE_UINT32(p_DtsecMemMap->cam2,
+                 p_DtsecDriverParam->cam2);
+
+/***************CAM2************************/
+
+/***************MACSTNADDR1/2*****************/
+
+    /*  Initialize MAC Station Address registers (1 & 2)    */
+    /*  Station address have to be swapped (big endian to little endian */
+    addr = p_Dtsec->addr;
+
+    tmpReg32 = (uint32_t)(addr);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_DtsecMemMap->macstnaddr1, tmpReg32);
+
+    tmpReg32 = (uint32_t)(addr>>32);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_DtsecMemMap->macstnaddr2, tmpReg32);
+/***************MACSTNADDR1/2*****************/
+
+/***************DEBUG*****************/
+    WRITE_UINT32(p_DtsecMemMap->tx_threshold,       (uint32_t)(p_DtsecDriverParam->fifoTxThr & 0x7f));
+    WRITE_UINT32(p_DtsecMemMap->tx_watermark_high,  (uint32_t)(p_DtsecDriverParam->fifoTxWatermarkH & 0x7f));
+    WRITE_UINT32(p_DtsecMemMap->rx_watermark_low,   (uint32_t)(p_DtsecDriverParam->fifoRxWatermarkL & 0x7f));
+/***************DEBUG*****************/
+
+/*****************HASH************************/
+    for(i=0 ; i<NUM_OF_HASH_REGS ; i++)
+    {
+        /* Initialize IADDRx */
+        WRITE_UINT32(p_DtsecMemMap->igaddr[i], 0);
+        /* Initialize GADDRx */
+        WRITE_UINT32(p_DtsecMemMap->gaddr[i], 0);
+    }
+
+    p_Dtsec->p_MulticastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
+    if(!p_Dtsec->p_MulticastAddrHash)
+    {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("allocation hash table is FAILED"));
+    }
+
+    p_Dtsec->p_UnicastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
+    if(!p_Dtsec->p_UnicastAddrHash)
+    {
+        FreeInitResources(p_Dtsec);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("allocation hash table is FAILED"));
+    }
+    /*****************HASH************************/
+
+//#warning /*TODO - Set Interrupt routin*/
+//#warning /*TODO - TBI - need to think*/
+
+    XX_Free(p_DtsecDriverParam);
+    p_Dtsec->p_DtsecDriverParam = NULL;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecFree(t_Handle h_Dtsec)
+{
+    t_Dtsec      *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(h_Dtsec, E_INVALID_HANDLE);
+
+    if (p_Dtsec->p_DtsecDriverParam)
+    {
+        XX_Free(p_Dtsec->p_DtsecDriverParam);
+        p_Dtsec->p_DtsecDriverParam = NULL;
+    }
+    FreeInitResources(h_Dtsec);
+    XX_Free (h_Dtsec);
+
+    return E_OK;
+}
+
+
+/*****************************************************************************/
+/*                      dTSEC Configs modification functions                 */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+static t_Error DtsecConfigStatistics(t_Handle h_Dtsec, bool newVal)
+{
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    p_Dtsec->p_DtsecDriverParam->statisticsEnable = newVal;
+
+    return E_OK;
+}
+
+
+/* .............................................................................. */
+
+static t_Error DtsecConfigLoopback(t_Handle h_Dtsec, bool newVal)
+{
+
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    p_Dtsec->p_DtsecDriverParam->loopback = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecConfigMaxFrameLength(t_Handle h_Dtsec, uint16_t newVal)
+{
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    p_Dtsec->p_DtsecDriverParam->maxFrameLength = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecConfigPadAndCrc(t_Handle h_Dtsec, bool newVal)
+{
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    p_Dtsec->p_DtsecDriverParam->padAndCrcEnable = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecConfigHalfDuplex(t_Handle h_Dtsec, bool newVal)
+{
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    p_Dtsec->p_DtsecDriverParam->halfDuplex = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecConfigHugeFrames(t_Handle h_Dtsec, bool newVal)
+{
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    p_Dtsec->p_DtsecDriverParam->hugeFramesEnable = newVal;
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+/*                      dTSEC Run Time API functions                         */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+static t_Error DtsecEnable(t_Handle h_Dtsec,  e_CommMode mode)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap       *p_MemMap ;
+    uint32_t            tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_HANDLE);
+
+    p_MemMap= (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+
+    tmpReg32 = GET_UINT32(p_MemMap->maccfg1);
+
+    switch (mode)
+    {
+        case e_COMM_MODE_NONE:
+            tmpReg32 &= ~(MACCFG1_RX_EN | MACCFG1_TX_EN);
+            break;
+        case e_COMM_MODE_RX :
+            tmpReg32 |= MACCFG1_RX_EN ;
+            break;
+        case e_COMM_MODE_TX :
+            tmpReg32 |= MACCFG1_TX_EN ;
+            break;
+        case e_COMM_MODE_RX_AND_TX:
+            tmpReg32 |= (MACCFG1_RX_EN | MACCFG1_TX_EN);
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
+    }
+
+    WRITE_UINT32(p_MemMap->maccfg1, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecDisable (t_Handle h_Dtsec, e_CommMode mode)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap       *p_MemMap ;
+    uint32_t            tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_HANDLE);
+
+    p_MemMap = (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+
+    tmpReg32 = GET_UINT32(p_MemMap->maccfg1);
+
+    switch (mode)
+    {
+        case e_COMM_MODE_RX :
+            rxGracefulStop(h_Dtsec);
+            tmpReg32 &= ~MACCFG1_RX_EN ;
+            break;
+        case e_COMM_MODE_TX :
+            txGracefulStop(h_Dtsec);
+            tmpReg32 &= ~MACCFG1_TX_EN ;
+            break;
+        case e_COMM_MODE_RX_AND_TX:
+            rxGracefulStop(h_Dtsec);
+            txGracefulStop(h_Dtsec);
+            tmpReg32 &= ~(MACCFG1_RX_EN | MACCFG1_TX_EN);
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
+    }
+
+    WRITE_UINT32(p_MemMap->maccfg1, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecRestart(t_Handle h_Dtsec, e_CommMode mode)
+{
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap *p_MemMap ;
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_HANDLE);
+
+    p_MemMap= (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+    if(mode & e_COMM_MODE_TX)
+        /* clear the graceful receive stop bit */
+        WRITE_UINT32(p_MemMap->tctrl,
+                      GET_UINT32(p_MemMap->tctrl) & ~TCTRL_GTS);
+
+    if(mode & e_COMM_MODE_RX)
+        /* clear the graceful receive stop bit */
+        WRITE_UINT32(p_MemMap->rctrl,
+                      GET_UINT32(p_MemMap->rctrl) & ~RCTRL_GRS);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecTxMacPause(t_Handle h_Dtsec, uint16_t pauseTime, uint16_t exPauseTime )
+{
+    t_Dtsec      *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    uint32_t    ptv = 0 ;
+    t_DtsecMemMap *p_MemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_STATE);
+
+    p_MemMap = (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+
+    ptv = ((uint32_t)exPauseTime << PTV_PTE_SHIFT) | pauseTime ;
+    WRITE_UINT32(p_MemMap->ptv, ptv);
+
+    /* trigger the transmission of a flow-control pause frame */
+    WRITE_UINT32(p_MemMap->tctrl,
+                 GET_UINT32(p_MemMap->tctrl) | TCTRL_TFC_PAUSE);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecReadStatistics(t_Handle h_Dtsec)
+{
+    t_Dtsec          *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap    *p_DtsecMemMap;
+    t_FmMacStatistics *p_Statistics = &p_Dtsec->macStatistics;
+    uint32_t            tmpRdrp, tmpRaln, tmpTdrp;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_HANDLE);
+
+    p_DtsecMemMap = p_Dtsec->p_MemMap;
+
+    p_Statistics->eStatPkts64           += (MASK22BIT & GET_UINT32(p_DtsecMemMap->tr64));      /**< r-10G tr-DT 64 byte frame counter */
+    p_Statistics->eStatPkts65to127      += (MASK22BIT & GET_UINT32(p_DtsecMemMap->tr127));     /**< r-10G 65 to 127 byte frame counter */
+    p_Statistics->eStatPkts128to255     += (MASK22BIT & GET_UINT32(p_DtsecMemMap->tr255));     /**< r-10G 128 to 255 byte frame counter */
+    p_Statistics->eStatPkts256to511     += (MASK22BIT & GET_UINT32(p_DtsecMemMap->tr511));     /**< r-10G 256 to 511 byte frame counter */
+    p_Statistics->eStatPkts512to1023    += (MASK22BIT & GET_UINT32(p_DtsecMemMap->tr1k));      /**< r-10G 512 to 1023 byte frame counter */
+    p_Statistics->eStatPkts1024to1518   += (MASK22BIT & GET_UINT32(p_DtsecMemMap->trmax));     /**< r-10G 1024 to 1518 byte frame counter */
+    p_Statistics->eStatPkts1519to1522   += (MASK22BIT & GET_UINT32(p_DtsecMemMap->trmgv));     /**< r-10G 1519 to 1522 byte good frame count */
+/* */
+    p_Statistics->eStatFragments        += (MASK16BIT & GET_UINT32(p_DtsecMemMap->rfrg));      /**< Total number of packets that were less than 64 octets long with a wrong CRC.*/
+    p_Statistics->eStatJabbers          += (MASK16BIT & GET_UINT32(p_DtsecMemMap->rjbr));      /**< Total number of packets longer than valid maximum length octets */
+
+    tmpRdrp                             = (MASK16BIT & GET_UINT32(p_DtsecMemMap->rdrp));      /**< number of dropped packets due to internal errors of the MAC Client. */
+    tmpRaln                             = (MASK16BIT & GET_UINT32(p_DtsecMemMap->raln));      /**< Incremented when frames of correct length but with CRC error are received.*/
+    p_Statistics->eStatsDropEvents      += tmpRdrp;                                            /**< number of dropped packets due to internal errors of the MAC Client. */
+    p_Statistics->eStatCRCAlignErrors   += tmpRaln;                                            /**< Incremented when frames of correct length but with CRC error are received.*/
+
+    p_Statistics->eStatUndersizePkts    += (MASK16BIT & GET_UINT32(p_DtsecMemMap->rund));      /**< Total number of packets that were less than 64 octets long with a good CRC.*/
+    p_Statistics->eStatOversizePkts     += (MASK16BIT & GET_UINT32(p_DtsecMemMap->rovr));      /**< T,B.D*/
+/* Pause */
+    p_Statistics->reStatPause           += (MASK16BIT & GET_UINT32(p_DtsecMemMap->rxpf));      /**< Pause MAC Control received */
+    p_Statistics->teStatPause           += (MASK16BIT & GET_UINT32(p_DtsecMemMap->txpf));      /**< Pause MAC Control sent */
+
+/* MIB II */
+    p_Statistics->ifInOctets            += GET_UINT32(p_DtsecMemMap->rbyt);                  /**< Total number of byte received. */
+    p_Statistics->ifInPkts              += (MASK22BIT & GET_UINT32(p_DtsecMemMap->rpkt));    /**< Total number of packets received.*/
+    p_Statistics->ifInMcastPkts         += (MASK22BIT & GET_UINT32(p_DtsecMemMap->rmca));    /**< Total number of multicast frame received*/
+    p_Statistics->ifInBcastPkts         += (MASK22BIT & GET_UINT32(p_DtsecMemMap->rbca));    /**< Total number of broadcast frame received */
+    p_Statistics->ifInDiscards          = p_Statistics->eStatsDropEvents;                    /**< Frames received, but discarded due to problems within the MAC RX. */
+
+    p_Statistics->ifInErrors            += tmpRdrp
+                                        + tmpRaln
+                                        + (MASK16BIT & GET_UINT32(p_DtsecMemMap->rflr))
+                                        + (MASK16BIT & GET_UINT32(p_DtsecMemMap->rcde))
+                                        + (MASK16BIT & GET_UINT32(p_DtsecMemMap->rcse));
+
+    p_Statistics->ifOutOctets           += GET_UINT32(p_DtsecMemMap->tbyt);                  /**< Total number of byte sent. */
+    p_Statistics->ifOutPkts             += (MASK22BIT & GET_UINT32(p_DtsecMemMap->tpkt));    /**< Total number of packets sent .*/
+    p_Statistics->ifOutMcastPkts        += (MASK22BIT & GET_UINT32(p_DtsecMemMap->tmca));    /**< Total number of multicast frame sent */
+    p_Statistics->ifOutBcastPkts        += (MASK22BIT & GET_UINT32(p_DtsecMemMap->tbca));    /**< Total number of multicast frame sent */
+    tmpTdrp                             =  (MASK16BIT & GET_UINT32(p_DtsecMemMap->tdrp));     /**< Frames received, but discarded due to problems within the MAC TX N/A!.*/
+    p_Statistics->ifOutDiscards         += tmpTdrp;                                          /**< Frames received, but discarded due to problems within the MAC TX N/A!.*/
+    p_Statistics->ifOutErrors           += tmpTdrp                                           /**< Number of frames transmitted with error: */
+                                        + (MASK12BIT & GET_UINT32(p_DtsecMemMap->tfcs));
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecGetStatistics(t_Handle h_Dtsec, t_FmMacStatistics *p_Statistics)
+{
+    t_Dtsec          *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Statistics, E_NULL_POINTER);
+
+    DtsecReadStatistics(h_Dtsec);              /* Update all counters based on HW counters */
+
+    memcpy((char *)p_Statistics, (char *)&p_Dtsec->macStatistics, sizeof(t_FmMacStatistics));
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecModifyMacAddress (t_Handle h_Dtsec, t_EnetAddr *p_EnetAddr)
+{
+    t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap        *p_DtsecMemMap = p_Dtsec->p_MemMap;
+    uint32_t              tmpReg32 = 0;
+    uint64_t              addr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_DtsecMemMap, E_INVALID_HANDLE);
+
+    /*  Initialize MAC Station Address registers (1 & 2)    */
+    /*  Station address have to be swapped (big endian to little endian */
+    addr = ((*(uint64_t *)p_EnetAddr) >> 16);
+    p_Dtsec->addr = addr;
+
+    tmpReg32 = (uint32_t)(addr);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_DtsecMemMap->macstnaddr1, tmpReg32);
+
+    tmpReg32 = (uint32_t)(addr>>32);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_DtsecMemMap->macstnaddr2, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecResetCounters (t_Handle h_Dtsec)
+{
+    t_Dtsec          *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+
+    DtsecReadStatistics(h_Dtsec);              /* Update all counters based on HW counters */
+
+    memset((char *)&p_Dtsec->macStatistics, (char)0x0, sizeof(t_FmMacStatistics));
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecDelExactMatchMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthAddr)
+{
+    t_Dtsec   *p_Dtsec = (t_Dtsec *) h_Dtsec;
+    uint64_t  ethAddr;
+    uint8_t   paddrNum;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    /* Find used PADDR containing this address */
+    for (paddrNum = 0; paddrNum < DTSEC_NUM_OF_PADDRS; paddrNum++)
+    {
+        if ((p_Dtsec->indAddrRegUsed[paddrNum]) &&
+            (p_Dtsec->paddr[paddrNum] == ethAddr))
+        {
+            /* mark this PADDR as not used */
+            p_Dtsec->indAddrRegUsed[paddrNum] = FALSE;
+            /* clear in hardware */
+            HardwareClearAddrInPaddr(p_Dtsec, paddrNum);
+            p_Dtsec->numOfIndAddrInRegs--;
+
+            return E_OK;
+        }
+    }
+
+    RETURN_ERROR(MAJOR, E_NOT_FOUND, NO_MSG);
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecAddExactMatchMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthAddr)
+{
+    t_Dtsec   *p_Dtsec = (t_Dtsec *) h_Dtsec;
+    uint64_t  ethAddr;
+    uint8_t   paddrNum;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    if (ethAddr & GROUP_ADDRESS)
+        /* Multicast address has no effect in PADDR */
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Multicast address"));
+
+    /* Make sure no PADDR contains this address */
+    for (paddrNum = 0; paddrNum < DTSEC_NUM_OF_PADDRS; paddrNum++)
+        if (p_Dtsec->indAddrRegUsed[paddrNum])
+            if (p_Dtsec->paddr[paddrNum] == ethAddr)
+                RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, NO_MSG);
+
+    /* Find first unused PADDR */
+    for (paddrNum = 0; paddrNum < DTSEC_NUM_OF_PADDRS; paddrNum++)
+        if (!(p_Dtsec->indAddrRegUsed[paddrNum]))
+        {
+            /* mark this PADDR as used */
+            p_Dtsec->indAddrRegUsed[paddrNum] = TRUE;
+            /* store address */
+            p_Dtsec->paddr[paddrNum] = ethAddr;
+
+            /* put in hardware */
+            HardwareAddAddrInPaddr(p_Dtsec, &ethAddr, paddrNum);
+            p_Dtsec->numOfIndAddrInRegs++;
+
+            return E_OK;
+        }
+
+    /* No free PADDR */
+    RETURN_ERROR(MAJOR, E_FULL, NO_MSG);
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecAddHashMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthAddr)
+{
+    t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap   *p_DtsecMemMap = p_Dtsec->p_MemMap;
+    uint32_t        crc;
+    uint8_t         crcMirror, reg;
+    uint32_t        bitMask;
+    t_EthHashEntry  *p_HashEntry;
+    uint64_t        ethAddr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_DtsecMemMap, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    /* CRC calculation */
+    GET_MAC_ADDR_CRC(ethAddr, crc);
+
+    /* calculate the "crc mirror" */
+    crcMirror = MIRROR((uint8_t)crc);
+
+    /* 3 MSB bits define the register */
+    reg = (uint8_t)(crcMirror >> 5);
+    /* 5 LSB bits define the bit within the register */
+    bitMask =  0x80000000 >> (crcMirror & 0x1f);
+
+    /* Create element to be added to the driver hash table */
+    p_HashEntry = (t_EthHashEntry *)XX_Malloc(sizeof(t_EthHashEntry));
+    p_HashEntry->addr = ethAddr;
+    INIT_LIST(&p_HashEntry->node);
+
+    if (ethAddr & GROUP_ADDRESS)
+    {
+        /* Group Address */
+        LIST_AddToTail(&(p_HashEntry->node), &(p_Dtsec->p_MulticastAddrHash->p_Lsts[crcMirror]));
+        /* Set the appropriate bit in GADDR0-7 */
+        WRITE_UINT32(p_DtsecMemMap->gaddr[reg],
+                     GET_UINT32(p_DtsecMemMap->gaddr[reg]) | bitMask);
+    }
+    else
+    {
+        LIST_AddToTail(&(p_HashEntry->node), &(p_Dtsec->p_UnicastAddrHash->p_Lsts[crcMirror]));
+        /* Set the appropriate bit in IADDR0-7 */
+        WRITE_UINT32(p_DtsecMemMap->igaddr[reg],
+                     GET_UINT32(p_DtsecMemMap->igaddr[reg]) | bitMask);
+    }
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecDelHashMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthAddr)
+{
+    t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap   *p_DtsecMemMap = p_Dtsec->p_MemMap;
+    t_List          *p_Pos;
+    uint32_t        crc;
+    uint8_t         crcMirror, reg;
+    uint32_t        bitMask;
+    t_EthHashEntry  *p_HashEntry = NULL;
+    uint64_t        ethAddr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_DtsecMemMap, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    /* CRC calculation */
+    GET_MAC_ADDR_CRC(ethAddr, crc);
+
+    /* calculate the "crc mirror" */
+    crcMirror = MIRROR((uint8_t)crc);
+
+    /* 3 MSB bits define the register */
+    reg =(uint8_t)( crcMirror >> 5);
+    /* 5 LSB bits define the bit within the register */
+    bitMask =  0x80000000 >> (crcMirror & 0x1f);
+
+    if (ethAddr & GROUP_ADDRESS)
+    {
+        /* Group Address */
+        LIST_FOR_EACH(p_Pos, &(p_Dtsec->p_MulticastAddrHash->p_Lsts[crcMirror]))
+        {
+
+            p_HashEntry = ETH_HASH_ENTRY_OBJ(p_Pos);
+            if(p_HashEntry->addr == ethAddr)
+            {
+                LIST_DelAndInit(&p_HashEntry->node);
+                XX_Free(p_HashEntry);
+                break;
+            }
+        }
+        if(LIST_IsEmpty(&p_Dtsec->p_MulticastAddrHash->p_Lsts[crcMirror]))
+            WRITE_UINT32(p_DtsecMemMap->gaddr[reg],
+                         GET_UINT32(p_DtsecMemMap->gaddr[reg]) & ~bitMask);
+    }
+    else
+    {
+        /* Individual Address */
+        LIST_FOR_EACH(p_Pos, &(p_Dtsec->p_UnicastAddrHash->p_Lsts[crcMirror]))
+        {
+            p_HashEntry = ETH_HASH_ENTRY_OBJ(p_Pos);
+            if(p_HashEntry->addr == ethAddr)
+            {
+                LIST_DelAndInit(&p_HashEntry->node);
+                XX_Free(p_HashEntry);
+                break;
+            }
+        }
+        if(LIST_IsEmpty(&p_Dtsec->p_UnicastAddrHash->p_Lsts[crcMirror]))
+            WRITE_UINT32(p_DtsecMemMap->igaddr[reg],
+                         GET_UINT32(p_DtsecMemMap->igaddr[reg]) & ~bitMask);
+    }
+
+    /* address does not exist */
+    ASSERT_COND(p_HashEntry != NULL);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecSetPromiscuous(t_Handle h_Dtsec, bool newVal)
+{
+    t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap   *p_DtsecMemMap = p_Dtsec->p_MemMap;
+    uint32_t        tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
+
+    tmpReg32 = GET_UINT32(p_DtsecMemMap->rctrl);
+
+    if (newVal)
+        tmpReg32 |= RCTRL_PROM;
+    else
+        tmpReg32 &= ~RCTRL_PROM;
+
+    WRITE_UINT32(p_DtsecMemMap->rctrl, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecAdjustLink(t_Handle h_Dtsec, e_EnetSpeed speed, bool fullDuplex)
+{
+    t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap   *p_DtsecMemMap = p_Dtsec->p_MemMap;
+    uint32_t        tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
+
+    if (!fullDuplex &&
+        ((speed >= e_ENET_SPEED_1000) ||
+         (ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode) == e_ENET_IF_SGMII)))
+        RETURN_ERROR(MAJOR, E_CONFLICT, ("Ethernet interface does not support Half Duplex mode"));
+
+    p_Dtsec->enetMode = MAKE_ENET_MODE(ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode), speed);
+    p_Dtsec->p_DtsecDriverParam->halfDuplex = !fullDuplex;
+
+    tmpReg32 = GET_UINT32(p_DtsecMemMap->maccfg2);
+    if(p_Dtsec->p_DtsecDriverParam->halfDuplex)
+        tmpReg32 &= ~MACCFG2_FULL_DUPLEX;
+    else
+        tmpReg32 |= MACCFG2_FULL_DUPLEX;
+    WRITE_UINT32(p_DtsecMemMap->maccfg2, tmpReg32);
+
+    tmpReg32 = GET_UINT32(p_DtsecMemMap->ecntrl);
+    if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_10) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100))
+            tmpReg32 |= MACCFG2_NIBBLE_MODE;
+
+    else if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)||
+        (p_Dtsec->enetMode == e_ENET_MODE_GMII_1000))
+            tmpReg32 |= MACCFG2_BYTE_MODE;
+    WRITE_UINT32(p_DtsecMemMap->ecntrl, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecGetId(t_Handle h_Dtsec, uint32_t *macId)
+{
+    t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap        *p_DtsecMemMap = p_Dtsec->p_MemMap;
+UNUSED(macId);
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_DtsecMemMap, E_INVALID_HANDLE);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("DtsecGetId Not Supported"));
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecGetVersion(t_Handle h_Dtsec, uint32_t *macVersion)
+{
+    t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_DtsecMemMap        *p_DtsecMemMap = p_Dtsec->p_MemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_DtsecMemMap, E_INVALID_HANDLE);
+
+    *macVersion = GET_UINT32(p_DtsecMemMap->tsec_id1);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error DtsecSetExcpetions(t_Handle h_Dtsec, e_FmMacExceptions ex)
+{
+    t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+UNUSED(ex);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+static t_Error DtsecDumpRegs(t_Handle h_Dtsec)
+{
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    int i = 0;
+
+    DECLARE_DUMP;
+
+    if (p_Dtsec->p_MemMap)
+    {
+
+        DUMP_TITLE(p_Dtsec->p_MemMap, ("MAC %d: ", p_Dtsec->macId));
+        DUMP_VAR(p_Dtsec->p_MemMap, tsec_id1);
+        DUMP_VAR(p_Dtsec->p_MemMap, tsec_id2);
+        DUMP_VAR(p_Dtsec->p_MemMap, ievent);
+        DUMP_VAR(p_Dtsec->p_MemMap, imask);
+        DUMP_VAR(p_Dtsec->p_MemMap, edis);
+        DUMP_VAR(p_Dtsec->p_MemMap, ecntrl);
+        DUMP_VAR(p_Dtsec->p_MemMap, ptv);
+        DUMP_VAR(p_Dtsec->p_MemMap, tctrl);
+        DUMP_VAR(p_Dtsec->p_MemMap, rctrl);
+        DUMP_VAR(p_Dtsec->p_MemMap, maccfg1);
+        DUMP_VAR(p_Dtsec->p_MemMap, maccfg2);
+        DUMP_VAR(p_Dtsec->p_MemMap, ipgifg);
+        DUMP_VAR(p_Dtsec->p_MemMap, hafdup);
+        DUMP_VAR(p_Dtsec->p_MemMap, maxfrm);
+
+        DUMP_VAR(p_Dtsec->p_MemMap, macstnaddr1);
+        DUMP_VAR(p_Dtsec->p_MemMap, macstnaddr2);
+
+        DUMP_SUBSTRUCT_ARRAY(i, 8)
+        {
+            DUMP_VAR(p_Dtsec->p_MemMap, macaddr[i].exact_match1);
+            DUMP_VAR(p_Dtsec->p_MemMap, macaddr[i].exact_match2);
+        }
+
+    }
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+
+/*****************************************************************************/
+/*                      dTSEC Config  Main Entry                             */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacControllerDriver)
+{
+    p_FmMacControllerDriver->f_FM_MAC_Init                      = DtsecInit;
+    p_FmMacControllerDriver->f_FM_MAC_Free                      = DtsecFree;
+
+    p_FmMacControllerDriver->f_FM_MAC_ConfigStatistics          = DtsecConfigStatistics;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigLoopback            = DtsecConfigLoopback;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigMaxFrameLength      = DtsecConfigMaxFrameLength;
+
+    p_FmMacControllerDriver->f_FM_MAC_ConfigWan                 = NULL; /* Not supported on dTSEC */
+
+    p_FmMacControllerDriver->f_FM_MAC_ConfigPadAndCrc           = DtsecConfigPadAndCrc;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex          = DtsecConfigHalfDuplex;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigHugeFrames          = DtsecConfigHugeFrames;
+
+    p_FmMacControllerDriver->f_FM_MAC_Enable                    = DtsecEnable;
+    p_FmMacControllerDriver->f_FM_MAC_Disable                   = DtsecDisable;
+    p_FmMacControllerDriver->f_FM_MAC_Restart                   = DtsecRestart;
+
+    p_FmMacControllerDriver->f_FM_MAC_SetExceptions             = DtsecSetExcpetions;
+
+    p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous            = DtsecSetPromiscuous;
+    p_FmMacControllerDriver->f_FM_MAC_AdjustLink                = DtsecAdjustLink;
+
+    p_FmMacControllerDriver->f_FM_MAC_TxMacPause                = DtsecTxMacPause;
+
+    p_FmMacControllerDriver->f_FM_MAC_ResetCounters             = DtsecResetCounters;
+    p_FmMacControllerDriver->f_FM_MAC_GetStatistics             = DtsecGetStatistics;
+
+    p_FmMacControllerDriver->f_FM_MAC_ModifyMacAddr             = DtsecModifyMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_AddHashMacAddr            = DtsecAddHashMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_RemoveHashMacAddr         = DtsecDelHashMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_AddExactMatchMacAddr      = DtsecAddExactMatchMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_RemovelExactMatchMacAddr  = DtsecDelExactMatchMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_GetId                     = DtsecGetId;
+    p_FmMacControllerDriver->f_FM_MAC_GetVersion                = DtsecGetVersion;
+
+    p_FmMacControllerDriver->f_FM_MAC_MII_WritePhyReg           = MII_WritePhyReg;
+    p_FmMacControllerDriver->f_FM_MAC_MII_ReadPhyReg            = MII_ReadPhyReg;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    p_FmMacControllerDriver->f_FM_MAC_DumpRegs                  = DtsecDumpRegs;
+#endif /* (defined(DEBUG_ERRORS) && ... */
+}
+
+/* .............................................................................. */
+
+t_Handle  DTSEC_Config(t_FmMacParams *p_FmMacParam)
+{
+    t_Dtsec             *p_Dtsec;
+    t_DtsecDriverParam  *p_DtsecDriverParam;
+    uint64_t            baseAddr = p_FmMacParam->baseAddr;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmMacParam, E_NULL_POINTER, NULL);
+
+    /* allocate memory for the UCC GETH data structure. */
+    p_Dtsec = (t_Dtsec *) XX_Malloc(sizeof(t_Dtsec));
+    if (!p_Dtsec)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("dTSEC driver structure"));
+        return NULL;
+    }
+    /* Zero out * p_Dtsec */
+    memset( p_Dtsec, 0, sizeof(t_Dtsec));
+    InitFmMacControllerDriver(&p_Dtsec->fmMacControllerDriver);
+
+    /* allocate memory for the dTSEC driver parameters data structure. */
+    p_DtsecDriverParam = (t_DtsecDriverParam *) XX_Malloc(sizeof(t_DtsecDriverParam));
+    if (!p_DtsecDriverParam)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("dTSEC driver parameters"));
+        DtsecFree(p_Dtsec);
+        return NULL;
+    }
+    /* Zero out */
+    memset(p_DtsecDriverParam, 0, sizeof(t_DtsecDriverParam));
+
+    /* Plant parameter structure pointer */
+    p_Dtsec->p_DtsecDriverParam = p_DtsecDriverParam;
+
+    SetDefaultParam(p_Dtsec, p_DtsecDriverParam);
+
+    p_Dtsec->h_App    = p_FmMacParam->h_App ;
+    p_Dtsec->addr  = ((*(uint64_t *)p_FmMacParam->addr) >> 16);
+    p_Dtsec->p_MemMap = CAST_UINT64_TO_POINTER_TYPE(t_DtsecMemMap, baseAddr);
+    p_Dtsec->p_MiiMemMap  = CAST_UINT64_TO_POINTER_TYPE(t_MiiAccessMemMap, (baseAddr + DTSEC_TO_MII_OFFSET));
+    p_Dtsec->enetMode = p_FmMacParam->enetMode;
+    p_Dtsec->macId    = p_FmMacParam->macId;
+
+    return p_Dtsec;
+}
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
new file mode 100644
index 0000000..cb2e2a1
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
@@ -0,0 +1,496 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          dtsec.h
+
+ @Description   FM dTSEC ...
+*//***************************************************************************/
+#ifndef __DTSEC_H
+#define __DTSEC_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+#include "dtsec_mii_acc.h"
+#include "fm_mac.h"
+
+
+#define MAX_PACKET_ALIGNMENT        31
+#define MAX_INTER_PACKET_GAP        0x7f
+#define MAX_INTER_PALTERNATE_BEB    0x0f
+#define MAX_RETRANSMISSION          0x0f
+#define MAX_COLLISION_WINDOW        0x03ff
+
+
+/*********************From mac ext *******************************************/
+typedef  uint32_t t_ErrorDisable;
+
+#define ERROR_DISABLE_TRANSMIT              0x00400000
+#define ERROR_DISABLE_LATE_COLLISION        0x00040000
+#define ERROR_DISABLE_COLLISION_RETRY_LIMIT 0x00020000
+#define ERROR_DISABLE_TxFIFO_UNDERRUN       0x00010000
+#define ERROR_DISABLE_TxABORT               0x00008000
+#define ERROR_DISABLE_INTERFACE             0x00004000
+#define ERROR_DISABLE_TxDATA_PARITY         0x00000002
+#define ERROR_DISABLE_RxDATA_PARITY         0x00000001
+
+/*****************************************************************************/
+#define DTSEC_NUM_OF_PADDRS         15  /* number of pattern match registers (entries) */
+
+#define GROUP_ADDRESS               0x0000010000000000LL /* Group address bit indication */
+
+                           /* if TRUE, Multiple individual addresses are used*/
+
+#define HASH_TABLE_SIZE             256 /* Hash table size (= 32 bits * 8 regs) */
+
+
+#define DTSEC_TO_MII_OFFSET         0x1000  /* number of pattern match registers (entries) */
+
+#define DEFAULT_cam                 0
+
+#define DEFAULT_errorDisabled       0
+#define DEFAULT_autoZeroCounters    TRUE        /* Must be TRUE don't change with updating driver */
+#define DEFAULT_statisticsEnable    TRUE
+#define DEFAULT_promiscuousEnable   FALSE
+
+#define DEFAULT_pauseExtended       0
+#define DEFAULT_pauseTime           0xf000
+
+#define DEFAULT_halfDuplex              FALSE
+#define DEFAULT_halfDulexFlowControlEn  FALSE
+#define DEFAULT_txTimeStampEn           FALSE
+#define DEFAULT_rxTimeStampEn           FALSE
+
+#define DEFAULT_packetAlignment     0
+#define DEFAULT_controlFrameAccept  FALSE
+#define DEFAULT_groupHashExtend     FALSE
+#define DEFAULT_broadcReject        FALSE
+#define DEFAULT_rxShortFrame        TRUE
+#define DEFAULT_exactMatch          FALSE
+
+#define DEFAULT_debugMode           FALSE
+
+#define DEFAULT_loopback            FALSE
+#define DEFAULT_actOnRxPauseFrame   FALSE
+#define DEFAULT_actOnTxPauseFrame   FALSE
+
+#define DEFAULT_PreAmLength         0x7
+#define DEFAULT_PreAmRxEn           FALSE
+#define DEFAULT_PreAmTxEn           FALSE
+#define DEFAULT_hugeFrames          TRUE
+#define DEFAULT_lengthCheckEnable   FALSE
+#define DEFAULT_padAndCrcEnable     TRUE
+#define DEFAULT_crcEnable           FALSE
+
+#define DEFAULT_nonBackToBackIpg1   0x40
+#define DEFAULT_nonBackToBackIpg2   0x60
+#define DEFAULT_minIfgEnforcement   0x50
+#define DEFAULT_backToBackIpg       0x60
+
+#define DEFAULT_altBackoffVal          0x0A
+#define DEFAULT_altBackoffEnable       FALSE
+#define DEFAULT_backPressureNoBackoff  FALSE
+#define DEFAULT_noBackoff           FALSE
+#define DEFAULT_excessDefer         TRUE
+#define DEFAULT_maxRetransmission   0x0F
+#define DEFAULT_collisionWindow     0x37
+
+#define DEFAULT_maxFrameLength      0x600
+
+#define DEFAULT_collisionWindow     0x37
+
+#define DEFAULT_fifoTxThr           0x10
+#define DEFAULT_fifoTxWatermarkH    0x7e
+#define DEFAULT_fifoRxWatermarkL    0x08
+
+#define DEFAULT_imask               ((uint32_t)(IMASK_BREN | IMASK_RXCEN | IMASK_MSROEN | IMASK_GTSCEN | \
+                                                IMASK_BTEN | IMASK_TXCEN | IMASK_TXEEN |  IMASK_ABRTEN | \
+                                                IMASK_LCEN | IMASK_CRLEN | IMASK_XFUNEN) |IMASK_IFERREN| \
+                                                IMASK_MAGEN | IMASK_MMRDEN | IMASK_MMWREN |IMASK_GRSCEN| \
+                                                IMASK_TDPEEN |IMASK_RDPEEN)
+
+
+#define DTSEC_ID1_ID                0xffff0000
+#define DTSEC_ID1_REV_MJ            0x0000FF00
+#define DTSEC_ID1_REV_MN            0x000000ff
+
+#define ID2_INT_REDUCED_OFF         0x00010000
+#define ID2_INT_NORMAL_OFF          0x00020000
+
+#define ECNTRL_CLRCNT               0x00004000
+#define ECNTRL_AUTOZ                0x00002000
+#define ECNTRL_STEN                 0x00001000
+#define ECNTRL_CFG_RO               0x80000000
+#define ECNTRL_GMIIM                0x00000040
+#define ECNTRL_TBIM                 0x00000020
+#define ECNTRL_SGMIIM               0x00000002
+#define ECNTRL_RPM                  0x00000010
+#define ECNTRL_R100M                0x00000008
+
+#define TCTRL_THDF                  0x00000800
+#define TCTRL_TTSE                  0x00000040
+#define TCTRL_GTS                   0x00000020
+#define TCTRL_GET_RFC_PAUSE         0x00000010
+#define TCTRL_TFC_PAUSE             0x00000008
+
+/* PTV offsets */
+#define PTV_PTE_OFST                16
+
+#define RCTRL_CFA                   0x00008000
+#define RCTRL_GHTX                  0x00000400
+#define RCTRL_RTSE                  0x00000040
+#define RCTRL_GRS                   0x00000020
+#define RCTRL_BC_REJ                0x00000010
+#define RCTRL_MPROM                 0x00000008
+#define RCTRL_RSF                   0x00000004
+#define RCTRL_EMEN                  0x00000002
+#define RCTRL_UPROM                 0x00000001
+#define RCTRL_PROM                  (RCTRL_UPROM | RCTRL_MPROM)
+
+#define TSEC_ID1_DEBUG              0x00e00c00
+#define DEBUG_ENABLE                0x80000000
+#define DPERROR_Tx_ERROR_ON_SEC     0x00400000
+#define DPERROR_Tx_ERROR_ON_WRITE   0x10000000
+#define DPERROR_Rx_ERROR_ON_SEC     0x00000040
+#define DPERROR_Rx_ERROR_ON_WRITE   0x00001000
+#define DPERROR_STT                 0x80000000
+#define DPERROR_STR                 0x00008000
+
+#define MACCFG1_SOFT_RESET          0x80000000
+#define MACCFG1_LOOPBACK            0x00000100
+#define MACCFG1_RX_FLOW             0x00000020
+#define MACCFG1_TX_FLOW             0x00000010
+#define MACCFG1_TX_EN               0x00000001
+#define MACCFG1_RX_EN               0x00000004
+#define MACCFG1_RESET_RxMC          0x00080000
+#define MACCFG1_RESET_TxMC          0x00040000
+#define MACCFG1_RESET_RxFUN         0x00020000
+#define MACCFG1_RESET_TxFUN         0x00010000
+
+#define MACCFG2_NIBBLE_MODE         0x00000100
+#define MACCFG2_BYTE_MODE           0x00000200
+#define MACCFG2_PRE_AM_Rx_EN        0x00000080
+#define MACCFG2_PRE_AM_Tx_EN        0x00000040
+#define MACCFG2_HUGE_FRAME          0x00000020
+#define MACCFG2_LENGTH_CHECK        0x00000010
+#define MACCFG2_MAGIC_PACKET_EN     0x00000008
+#define MACCFG2_PAD_CRC_EN          0x00000004
+#define MACCFG2_CRC_EN              0x00000002
+#define MACCFG2_FULL_DUPLEX         0x00000001
+
+#define PREAMBLE_LENGTH_SHIFT       12
+
+#define IPGIFG_NON_BACK_TO_BACK_IPG_1_SHIFT    24
+#define IPGIFG_NON_BACK_TO_BACK_IPG_2_SHIFT    16
+#define IPGIFG_MIN_IFG_ENFORCEMENT_SHIFT        8
+
+#define IPGIFG_NON_BACK_TO_BACK_IPG_1    0x7F000000
+#define IPGIFG_NON_BACK_TO_BACK_IPG_2    0x007F0000
+#define IPGIFG_MIN_IFG_ENFORCEMENT       0x0000FF00
+#define IPGIFG_BACK_TO_BACK_IPG          0x0000007F
+
+#define HAFDUP_ALT_BEB                   0x00080000
+#define HAFDUP_BP_NO_BACKOFF             0x00040000
+#define HAFDUP_NO_BACKOFF                0x00020000
+#define HAFDUP_EXCESS_DEFER              0x00010000
+#define HAFDUP_COLLISION_WINDOW          0x000003ff
+
+#define HAFDUP_ALTERNATE_BEB_TRUNCATION_SHIFT    20
+#define HAFDUP_RETRANSMISSION_MAX_SHIFT          12
+#define HAFDUP_RETRANSMISSION_MAX       0x0000f000
+
+#define NUM_OF_HASH_REGS     8 /* Number of hash table registers */
+
+#define DEBUG_GET_FIFO_READ_INDEX       0x007f0000
+#define DEBUG_GET_FIFO_WRITE_INDEX      0x0000007f
+/* Pause Time Value Register  */
+#define PTV_PTE_SHIFT    16
+
+#define IEVENT_BABR    IMASK_BREN                  /* 0x80000000 */
+#define IEVENT_RXC     IMASK_RXCEN                 /* 0x40000000 */
+#define IEVENT_MSRO    IMASK_MSROEN                /* 0x04000000 */
+#define IEVENT_GTSC    IMASK_GTSCEN                /* 0x02000000 */
+#define IEVENT_BABT    IMASK_BTEN                  /* 0x01000000 */
+#define IEVENT_TXC     IMASK_TXCEN                 /* 0x00800000 */
+#define IEVENT_TXE     IMASK_TXEEN                 /* 0x00400000 */
+#define IEVENT_LC      IMASK_LCEN                  /* 0x00040000 */
+#define IEVENT_CRL     IMASK_CRLEN                 /* 0x00020000 */
+#define IEVENT_XFUN    IMASK_XFUNEN                /* 0x00010000 */
+#define IEVENT_ABRT    IMASK_ABRTEN                /* 0x00008000 */
+#define IEVENT_IFERR   IMASK_IFERREN               /* 0x00004000 */
+#define IEVENT_MAG     IMASK_MAGEN                 /* 0x00000800 */
+#define IEVENT_MMRD    IMASK_MMRDEN                /* 0x00000400 */
+#define IEVENT_MMWR    IMASK_MMWREN                /* 0x00000200 */
+#define IEVENT_GRSC    IMASK_GRSCEN                /* 0x00000100 */
+#define IEVENT_DPE     IMASK_TDPEEN                /* 0x00000002 */
+#define IEVENT_RDPE    IMASK_RDPEEN                /* 0x00000001 */
+
+#define IEVENT_ERRORS   (IEVENT_BABR | IMASK_RXCEN | IMASK_MSROEN | IMASK_BTEN | \
+                         IMASK_TXCEN | IMASK_TXEEN | IMASK_LCEN | IMASK_CRLEN | \
+                         IMASK_XFUNEN | IMASK_ABRTEN | IMASK_IFERREN | IMASK_MAGEN | \
+                         IMASK_MMRDEN | IMASK_MMWREN | IMASK_TDPEEN | IMASK_RDPEEN)
+
+#define     MASK22BIT   0x003FFFFF
+#define     MASK16BIT   0x0000FFFF
+#define     MASK12BIT   0x00000FFF
+#define     MASK8BIT    0x000000FF
+
+
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+
+typedef _Packed struct
+{
+    uint32_t exact_match1; /* octets 1-4 */
+    uint32_t exact_match2; /* octets 5-6 */
+} _PackedType macRegs;
+
+typedef _Packed struct
+{
+    volatile uint32_t tsec_id1;             /* 0x000 ETSEC_ID register */
+    volatile uint32_t tsec_id2;             /* 0x004 ETSEC_ID2 register */
+    volatile uint32_t ievent;               /* 0x008 Interrupt event register */
+    volatile uint32_t imask;                /* 0x00C Interrupt mask register */
+    volatile uint32_t edis;                 /* 0x010 Error disabled register */
+    volatile uint32_t ecntrl;               /* 0x014 E control register */
+    volatile uint32_t ptv;                  /* 0x018 Pause time value register */
+    volatile uint32_t DTSEC_RESERVED1;      /* 0x01C TBIPATBI PHY address register */
+    volatile uint32_t tmr_ctrl;             /* 0x020 Time-stamp Control register */
+    volatile uint32_t tmr_pevent;           /* 0x024 Time-stamp event register */
+    volatile uint32_t tmr_pemask;           /* 0x028 Timer event mask register */
+    volatile uint32_t DTSEC_RESERVED2;      /* 0x02C */
+    volatile uint32_t iobistctl;            /* 0x030 IO BIST Control register */
+    volatile uint32_t DTSEC_RESERVED3[3];   /* 0x034 */
+
+    volatile uint32_t tctrl;                /* 0x040 Transmit control register */
+    volatile uint32_t DTSEC_RESERVED4[3];   /* 0x044-0x04C */
+    volatile uint32_t rctrl;                /* 0x050 Receive control register */
+    volatile uint32_t DTSEC_RESERVED5[11];  /* 0x054- 0x07C */
+
+    volatile uint32_t igaddr[8];            /* 0x080-0x09C Individual/group address registers 0-7 */
+    volatile uint32_t gaddr[8];             /* 0x0A0-0x0BC Group address registers 0-7 */
+    volatile uint32_t ETSEC_RESERVED6[16];  /* 0x0C0-0x0FC */
+
+    volatile uint32_t maccfg1;              /* 0x100 MAC configuration #1 */
+    volatile uint32_t maccfg2;              /* 0x104 MAC configuration #2 */
+    volatile uint32_t ipgifg;               /* 0x108 IPG/IFG */
+    volatile uint32_t hafdup;               /* 0x10C Half-duplex */
+    volatile uint32_t maxfrm;               /* 0x110 Maximum frame */
+    volatile uint32_t  DTSEC_RESERVED7[3];  /* 0x1140x11C register */
+    volatile uint32_t miimcfg;              /* 0x120 MII Mgmt:configuration */
+    volatile uint32_t miimcom;              /* 0x124 MII Mgmt:command */
+    volatile uint32_t miimadd;              /* 0x128 MII Mgmt:address */
+    volatile uint32_t miimcon;              /* 0x12C MII Mgmt:control 3 */
+    volatile uint32_t miimstat;             /* 0x130 MII Mgmt:status */
+    volatile uint32_t miimind;              /* 0x134 MII Mgmt:indicators */
+    volatile uint32_t ifctrl;               /* 0x138 MII Mgmt:interface control */
+    volatile uint32_t ifstat;               /* 0x13C Interface status */
+    volatile uint32_t macstnaddr1;          /* 0x140 Station Address,part 1 */
+    volatile uint32_t macstnaddr2;          /* 0x144 Station Address,part 2  */
+    volatile macRegs  macaddr[DTSEC_NUM_OF_PADDRS]; /* 0x148-0x1BC mac exact match addresses 1-15, parts 1-2 */
+    volatile uint32_t  DTSEC_RESERVED8[16];   /* 0x1C00x1FC register */
+
+    /*  RMON MIB REGISTERS  */
+    /*  TRANSMIT and RECEIVE COUNTERS   */
+
+    volatile uint32_t  tr64;            /* 0x200 transmit and receive 64 byte frame counter */
+    volatile uint32_t  tr127;           /* 0x204 transmit and receive 65 to 127 byte frame counter */
+    volatile uint32_t  tr255;           /* 0x208 transmit and receive 128 to 255 byte frame counter */
+    volatile uint32_t  tr511;           /* 0x20C transmit and receive 256 to 511 byte frame counter */
+    volatile uint32_t  tr1k;            /* 0x210 transmit and receive 512 to 1023 byte frame counter */
+    volatile uint32_t  trmax;           /* 0x214 transmit and receive 1024 to 1518 byte frame counter */
+    volatile uint32_t  trmgv;           /* 0x218 transmit and receive 1519 to 1522 byte good VLAN frame count */
+
+    /* RECEIVE COUNTERS */
+    volatile uint32_t  rbyt;            /* 0x21C receive byte counter */
+    volatile uint32_t  rpkt;            /* 0x220 receive packet counter */
+    volatile uint32_t  rfcs;            /* 0x224 receive FCS error counter */
+    volatile uint32_t  rmca;            /* 0x228 RMCA receive multicast packet counter */
+    volatile uint32_t  rbca;            /* 0x22C receive broadcast packet counter */
+    volatile uint32_t  rxcf;            /* 0x230 receive control frame packet counter */
+    volatile uint32_t  rxpf;            /* 0x234 receive PAUSE frame packet counter */
+    volatile uint32_t  rxuo;            /* 0x238 receive unknown OP code counter */
+    volatile uint32_t  raln;            /* 0x23C receive alignment error counter */
+    volatile uint32_t  rflr;            /* 0x240 receive frame length error counter */
+    volatile uint32_t  rcde;            /* 0x244 receive code error counter */
+    volatile uint32_t  rcse;            /* 0x248 receive carrier sense error counter */
+    volatile uint32_t  rund;            /* 0x24C receive undersize packet counter */
+    volatile uint32_t  rovr;            /* 0x250 receive oversize packet counter */
+    volatile uint32_t  rfrg;            /* 0x254 receive fragments counter */
+    volatile uint32_t  rjbr;            /* 0x258 receive jabber counter */
+    volatile uint32_t  rdrp;            /* 0x25C receive drop */
+
+    /* TRANSMIT COUNTERS */
+    volatile uint32_t  tbyt;            /* 0x260 transmit byte counter */
+    volatile uint32_t  tpkt;            /* 0x264 transmit packet counter */
+    volatile uint32_t  tmca;            /* 0x268 transmit multicast packet counter */
+    volatile uint32_t  tbca;            /* 0x26C transmit broadcast packet counter */
+    volatile uint32_t  txpf;            /* 0x270 transmit PAUSE control frame counter */
+    volatile uint32_t  tdfr;            /* 0x274 transmit deferral packet counter */
+    volatile uint32_t  tedf;            /* 0x278 transmit excessive deferral packet counter */
+    volatile uint32_t  tscl;            /* 0x27C transmit single collision packet counter */
+    volatile uint32_t  tmcl;            /* 0x280 transmit multiple collision packet counter */
+    volatile uint32_t  tlcl;            /* 0x284 transmit late collision packet counter */
+    volatile uint32_t  txcl;            /* 0x288 transmit excessive collision packet counter */
+    volatile uint32_t  tncl;            /* 0x28C transmit total collision counter */
+    volatile uint32_t  DTSEC_RESERVED9; /* 0x290 */
+    volatile uint32_t  tdrp;            /* 0x294 transmit drop frame counter */
+    volatile uint32_t  tjbr;            /* 0x298 transmit jabber frame counter */
+    volatile uint32_t  tfcs;            /* 0x29C transmit FCS error counter */
+    volatile uint32_t  txcf;            /* 0x2A0 transmit control frame counter */
+    volatile uint32_t  tovr;            /* 0x2A4 transmit oversize frame counter */
+    volatile uint32_t  tund;            /* 0x2A8 transmit undersize frame counter */
+    volatile uint32_t  tfrg;            /* 0x2AC transmit fragments frame counter */
+
+    /* GENERAL REGISTERS */
+    volatile uint32_t  car1;            /* 0x2B0 carry register one register* */
+    volatile uint32_t  car2;            /* 0x2B4 carry register two register* */
+    volatile uint32_t  cam1;            /* 0x2B8 carry register one mask register */
+    volatile uint32_t  cam2;            /* 0x2BC carry register two mask register */
+    volatile uint32_t  DTSEC_RESERVED10[16]; /* 0x2C0-0x2FC */
+
+    /* Debug and Factory Test Registers */
+    volatile uint32_t debug;            /* 0x300 DEBUGDebug Register */
+    volatile uint32_t dperror;          /* 0x304 DPERRORParity Error Register */
+    volatile uint32_t hwassert;         /* 0x308 HWASSERT */
+    volatile uint32_t RESERVED11;       /* 0x30C Reserved */
+    volatile uint32_t rx_fifo_ptr;      /* 0x310 RXFIFOPTRRx FIFO R/W Pointer Register */
+    volatile uint32_t rx_fifo_dath;     /* 0x314 RXFIFODATHRx FIFO Data Register */
+    volatile uint32_t rx_fifo_datl;     /* 0x318 RXFIFODATLRx FIFO Data Register */
+    volatile uint32_t rx_fifo_stat;     /* 0x31C RXFIFOSTATRx FIFO Status Register */
+    volatile uint32_t tx_fifo_ptr;      /* 0x320 TXFIFOPTRTx FIFO R/W Pointer Register */
+    volatile uint32_t tx_fifo_dath;     /* 0x324 TXFIFODATHRx FIFO Data Register */
+    volatile uint32_t tx_fifo_datl;     /* 0x328 TXFIFODATLRx FIFO Data Register */
+    volatile uint32_t tx_fifo_stat;     /* 0x32C TXFIFOSTATTx FIFO Status Register */
+    volatile uint32_t pkt_rcv_cnt;      /* 0x330 PKTRCVCNTNumber of packets accepted and written to Rx FIFO */
+    volatile uint32_t RESERVED12[3];    /* 0x334-0x33C Reserved */
+    volatile uint32_t tx_threshold;     /* 0x340 Transmit threshold; Number of entries (4 bytes units) before starting to transmit to the MAC */
+    volatile uint32_t tx_watermark_high;/* 0x344 Transmit watermark high; Number of entries (4 byte units) before de-asserting Ready to packet Interface */
+    volatile uint32_t rx_watermark_low; /* 0x348 Receive watermark low; Number of entries (4 byte units) before unloading to packet Interface */
+} _PackedType t_DtsecMemMap;
+
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
+
+typedef struct {
+
+    uint32_t    errorDisabled;
+    bool        halfDuplex;
+    uint16_t    pauseTime;
+    uint16_t    pauseExtended;
+
+    bool        autoZeroCounters;
+    bool        statisticsEnable;
+    bool        promiscuousEnable;
+
+    bool        halfDulexFlowControlEn;
+    bool        txTimeStampEn;
+    bool        rxTimeStampEn;
+
+    uint8_t     packetAlignmentPadding;
+    bool        controlFrameAccept;
+    bool        groupHashExtend;
+    bool        broadcReject;
+    bool        rxShortFrame;
+    bool        exactMatch;
+
+    bool        debugMode;
+
+    bool        loopback;
+    bool        actOnRxPauseFrame;
+    bool        actOnTxPauseFrame;
+
+    uint8_t     nonBackToBackIpg1;
+    uint8_t     nonBackToBackIpg2;
+    uint8_t     minIfgEnforcement;
+    uint8_t     backToBackIpg;
+
+    uint8_t     preambleLength;
+    bool        preambleRxEn;
+    bool        preambleTxEn;
+    bool        hugeFramesEnable;
+    bool        lengthCheckEnable;
+    bool        magicPacketEnable;
+    bool        padAndCrcEnable;
+    bool        crcEnable;
+
+    bool        alternateBackoffEnable;
+    uint8_t     alternateBackoffVal;
+    bool        backPressureNoBackoff;
+    bool        noBackoff;
+    bool        excessDefer;
+    uint8_t     maxRetransmission;
+    uint16_t    collisionWindow;
+
+    uint16_t    maxFrameLength;
+
+    uint32_t    cam1;
+    uint32_t    cam2;
+
+    uint8_t     fifoTxThr;
+    uint8_t     fifoTxWatermarkH;
+    uint8_t     fifoRxWatermarkL;
+
+    uint32_t    imask;
+} t_DtsecDriverParam;
+
+typedef struct {
+    t_FmMacControllerDriver     fmMacControllerDriver;
+    t_Handle                    h_App;            /**< Handle to the upper layer application              */
+    t_DtsecMemMap               *p_MemMap;        /**< pointer to dTSEC memory mapped registers.          */
+    t_MiiAccessMemMap           *p_MiiMemMap;     /**< pointer to dTSEC MII memory mapped registers.          */
+    uint64_t                    addr;             /**< MAC address of device;                             */
+    e_EnetMode                  enetMode;         /**< Ethernet physical interface  */
+    t_FmMacExceptionCallback    *f_Exceptions;
+    bool                        indAddrRegUsed[DTSEC_NUM_OF_PADDRS]; /**< Whether a particular individual address recognition register is being used */
+    uint64_t                    paddr[DTSEC_NUM_OF_PADDRS]; /**< MAC address for particular individual address recognition register */
+    uint8_t                     numOfIndAddrInRegs; /**< Number of individual addresses in registers for this station. */
+    bool                        debugMode;
+    bool                        halfDuplex;
+    t_FmMacStatistics           macStatistics;
+    t_EthHash                   *p_MulticastAddrHash;      /* pointer to driver's global address hash table  */
+    t_EthHash                   *p_UnicastAddrHash;    /* pointer to driver's individual address hash table  */
+    uint8_t                     macId;
+    t_DtsecDriverParam          *p_DtsecDriverParam;
+} t_Dtsec;
+
+t_Error MII_WritePhyReg(t_Handle h_Dtsec, uint8_t phyAddr, uint8_t reg, uint16_t data);
+t_Error MII_ReadPhyReg(t_Handle  h_Dtsec, uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
+
+
+#endif /* __DTSEC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
new file mode 100644
index 0000000..98a0ba6
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
@@ -0,0 +1,127 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          dtsec_mii_acc.c
+
+ @Description   FM dtsec MII register access MAC ...
+*//***************************************************************************/
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "fm_mac.h"
+#include "dtsec.h"
+
+
+
+/*****************************************************************************/
+t_Error MII_WritePhyReg(t_Handle h_Dtsec,
+                        uint8_t     phyAddr,
+                        uint8_t     reg,
+                        uint16_t    data)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_MiiAccessMemMap   *p_MiiAccess;
+    uint32_t            tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MiiMemMap, E_INVALID_HANDLE);
+
+    p_MiiAccess = p_Dtsec->p_MiiMemMap;
+
+    /* Stop the MII management read cycle */
+    WRITE_UINT32(p_MiiAccess->miimcom, 0);
+    /* Dummy read to make sure MIIMCOM is written */
+    tmpReg = GET_UINT32(p_MiiAccess->miimcom);
+
+    /* Setting up MII Management Address Register */
+    tmpReg = (uint32_t)((phyAddr << MIIMADD_PHY_ADDR_SHIFT) | reg);
+    WRITE_UINT32(p_MiiAccess->miimadd, tmpReg);
+
+    /* Setting up MII Management Control Register with data */
+    WRITE_UINT32(p_MiiAccess->miimcon, (uint32_t)data);
+    /* Dummy read to make sure MIIMCON is written */
+    tmpReg = GET_UINT32(p_MiiAccess->miimcon);
+
+    /* Wait till MII management write is complete */
+    while ((GET_UINT32(p_MiiAccess->miimind)) & MIIMIND_BUSY) ;
+
+    return E_OK;
+}
+
+
+/*****************************************************************************/
+t_Error MII_ReadPhyReg(t_Handle h_Dtsec,
+                   uint8_t  phyAddr,
+                   uint8_t  reg,
+                   uint16_t *p_Data)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_MiiAccessMemMap   *p_MiiAccess;
+    uint32_t            tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MiiMemMap, E_INVALID_HANDLE);
+
+    p_MiiAccess = p_Dtsec->p_MiiMemMap;
+
+    /* Setting up the MII Management Address Register */
+    tmpReg = (uint32_t)((phyAddr << MIIMADD_PHY_ADDR_SHIFT) | reg);
+    WRITE_UINT32(p_MiiAccess->miimadd, tmpReg);
+
+    /* Perform an MII management read cycle */
+    WRITE_UINT32(p_MiiAccess->miimcom, MIIMCOM_READ_CYCLE);
+    /* Dummy read to make sure MIIMCOM is written */
+    tmpReg = GET_UINT32(p_MiiAccess->miimcom);
+
+    /* Wait till MII management write is complete */
+    while ((GET_UINT32(p_MiiAccess->miimind)) & MIIMIND_BUSY) ;
+
+    /* Read MII management status  */
+    *p_Data = (uint16_t)GET_UINT32(p_MiiAccess->miimstat);
+
+    WRITE_UINT32(p_MiiAccess->miimcom, 0);
+    /* Dummy read to make sure MIIMCOM is written */
+    tmpReg = GET_UINT32(p_MiiAccess->miimcom);
+
+    if (*p_Data == 0xffff)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Read wrong data: phyAddr"));
+/*
+        DBG(INFO, ("Read wrong data: phyAddr %d, reg %d, base %08x",
+            phyAddr, reg, (long)p_MiiAccess));
+*/
+    return E_INVALID_VALUE;
+    }
+
+    return E_OK;
+}
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
new file mode 100644
index 0000000..c952a59
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
@@ -0,0 +1,66 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __MII_ACC_H
+#define __MII_ACC_H
+
+/* #define __ERR_MODULE__ MODULE_MII */
+
+/* MII Management Configuration Register */
+#define MIIMCFG_RESET_MGMT          0x80000000
+#define MIIMCFG_MGMT_CLOCK_SELECT   0x00000007
+
+/* MII  Management Command Register */
+#define MIIMCOM_READ_CYCLE          0x00000001
+#define MIIMCOM_SCAN_CYCLE          0x00000002
+
+/* MII  Management Address Register */
+#define MIIMADD_PHY_ADDR_SHIFT      8
+
+/* MII Management Indicator Register */
+#define MIIMIND_BUSY                0x00000001
+
+/*----------------------------------------------------*/
+/* MII Configuration Control Memory Map Registers     */
+/*----------------------------------------------------*/
+typedef _Packed struct t_MiiAccessMemMap
+{
+    volatile uint32_t miimcfg;    /* MII Mgmt:configuration */
+    volatile uint32_t miimcom;    /* MII Mgmt:command       */
+    volatile uint32_t miimadd;    /* MII Mgmt:address       */
+    volatile uint32_t miimcon;    /* MII Mgmt:control 3     */
+    volatile uint32_t miimstat;   /* MII Mgmt:status        */
+    volatile uint32_t miimind;    /* MII Mgmt:indicators    */
+} _PackedType t_MiiAccessMemMap ;
+
+
+#endif /* __MII_ACC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
new file mode 100644
index 0000000..34d39ca
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
@@ -0,0 +1,483 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_mac.c
+
+ @Description   FM MAC ...
+*//***************************************************************************/
+#include "std_ext.h"
+#include "string_ext.h"
+#include "sprint_ext.h"
+#include "error_ext.h"
+
+#include "fm_mac.h"
+#include "fm_ext.h"
+
+
+/* ........................................................................... */
+
+t_Handle FM_MAC_Config (t_FmMacParams *p_FmMacParam)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmMacParam, E_INVALID_HANDLE, NULL);
+
+    if(ENET_SPEED_FROM_MODE(p_FmMacParam->enetMode) < e_ENET_SPEED_10000)
+        p_FmMacControllerDriver = (t_FmMacControllerDriver *)DTSEC_Config(p_FmMacParam);
+    else
+       p_FmMacControllerDriver = (t_FmMacControllerDriver *)TGEC_Config(p_FmMacParam);
+
+    if (!p_FmMacControllerDriver)
+        return NULL;
+
+    p_FmMacControllerDriver->h_Fm = p_FmMacParam->h_Fm;
+
+    p_FmMacControllerDriver->enetMode = p_FmMacParam->enetMode;
+    p_FmMacControllerDriver->macId    = p_FmMacParam->macId;
+
+    return (t_Handle)p_FmMacControllerDriver;
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_Init (t_Handle h_FmMac)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_Init)
+        return p_FmMacControllerDriver->f_FM_MAC_Init(h_FmMac);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_Free (t_Handle h_FmMac)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_Free)
+        return p_FmMacControllerDriver->f_FM_MAC_Free(h_FmMac);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ConfigStatistics (t_Handle h_FmMac, bool newVal)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigStatistics)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigStatistics(h_FmMac, newVal);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ConfigLoopback (t_Handle h_FmMac, bool newVal)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigLoopback)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigLoopback(h_FmMac, newVal);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ConfigMaxFrameLength (t_Handle h_FmMac, uint16_t newVal)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigMaxFrameLength)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigMaxFrameLength(h_FmMac, newVal);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ConfigWan (t_Handle h_FmMac, bool flag)
+{
+   t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigWan)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigWan(h_FmMac, flag);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ConfigPadAndCrc (t_Handle h_FmMac, bool newVal)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigPadAndCrc)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigPadAndCrc(h_FmMac, newVal);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ConfigHalfDuplex (t_Handle h_FmMac, bool newVal)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex(h_FmMac,newVal);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ConfigHugeFrames (t_Handle h_FmMac, bool newVal)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigHugeFrames)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigHugeFrames(h_FmMac, newVal);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+/*****************************************************************************/
+/* Run Time Control                                                          */
+/*****************************************************************************/
+
+/* ........................................................................... */
+
+t_Error FM_MAC_Enable  (t_Handle h_FmMac,  e_CommMode mode)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_Enable)
+        return p_FmMacControllerDriver->f_FM_MAC_Enable(h_FmMac, mode);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_Disable (t_Handle h_FmMac, e_CommMode mode)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_Disable)
+        return p_FmMacControllerDriver->f_FM_MAC_Disable(h_FmMac, mode);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_Restart (t_Handle h_FmMac, e_CommMode mode)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_Restart)
+        return p_FmMacControllerDriver->f_FM_MAC_Restart(h_FmMac, mode);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_Reset (t_Handle h_FmMac, bool wait)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if  (!wait)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("reset must blocking!!!"));
+
+    return FmResetMac(p_FmMacControllerDriver->h_Fm,
+                      ((ENET_SPEED_FROM_MODE(p_FmMacControllerDriver->enetMode) < e_ENET_SPEED_10000) ? e_FM_MAC_1G : e_FM_MAC_10G),
+                      p_FmMacControllerDriver->macId);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_TxMacPause (t_Handle h_FmMac, uint16_t pauseTime, uint16_t exPauseTime)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_TxMacPause)
+        return p_FmMacControllerDriver->f_FM_MAC_TxMacPause(h_FmMac, pauseTime, exPauseTime);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ResetCounters (t_Handle h_FmMac)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ResetCounters)
+        return p_FmMacControllerDriver->f_FM_MAC_ResetCounters(h_FmMac);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_SetExceptions(t_Handle h_FmMac, e_FmMacExceptions ex)
+{
+   t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_SetExceptions)
+        return p_FmMacControllerDriver->f_FM_MAC_SetExceptions(h_FmMac, ex);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_GetStatistics (t_Handle h_FmMac, t_FmMacStatistics *p_Statistics)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_GetStatistics)
+        return p_FmMacControllerDriver->f_FM_MAC_GetStatistics(h_FmMac, p_Statistics);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_ModifyMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ModifyMacAddr)
+        return p_FmMacControllerDriver->f_FM_MAC_ModifyMacAddr(h_FmMac, p_EnetAddr);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_AddHashMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_AddHashMacAddr)
+        return p_FmMacControllerDriver->f_FM_MAC_AddHashMacAddr(h_FmMac, p_EnetAddr);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_RemoveHashMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_RemoveHashMacAddr)
+        return p_FmMacControllerDriver->f_FM_MAC_RemoveHashMacAddr(h_FmMac, p_EnetAddr);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_AddExactMatchMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_AddExactMatchMacAddr)
+        return p_FmMacControllerDriver->f_FM_MAC_AddExactMatchMacAddr(h_FmMac, p_EnetAddr);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_RemovelExactMatchMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_RemovelExactMatchMacAddr)
+        return p_FmMacControllerDriver->f_FM_MAC_RemovelExactMatchMacAddr(h_FmMac, p_EnetAddr);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_GetVesrion (t_Handle h_FmMac, uint32_t *macVresion)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_GetVersion)
+        return p_FmMacControllerDriver->f_FM_MAC_GetVersion(h_FmMac, macVresion);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_GetId (t_Handle h_FmMac, uint32_t *macId)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_GetId)
+        return p_FmMacControllerDriver->f_FM_MAC_GetId(h_FmMac, macId);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_SetPromiscuous (t_Handle h_FmMac, bool newVal)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous)
+        return p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous(h_FmMac, newVal);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_AdjustLink(t_Handle h_FmMac, e_EnetSpeed speed, bool fullDuplex)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_AdjustLink)
+        return p_FmMacControllerDriver->f_FM_MAC_AdjustLink(h_FmMac, speed, fullDuplex);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_MII_WritePhyReg (t_Handle h_FmMac, uint8_t phyAddr, uint8_t reg, uint16_t data)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_MII_WritePhyReg)
+        return p_FmMacControllerDriver->f_FM_MAC_MII_WritePhyReg(h_FmMac, phyAddr, reg, data);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_MII_ReadPhyReg(t_Handle h_FmMac,  uint8_t phyAddr, uint8_t reg, uint16_t *p_Data)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_MII_ReadPhyReg)
+        return p_FmMacControllerDriver->f_FM_MAC_MII_ReadPhyReg(h_FmMac, phyAddr, reg, p_Data);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/*****************************************************************************/
+t_Error FM_MAC_DumpRegs(t_Handle h_FmMac)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_DumpRegs)
+         return p_FmMacControllerDriver->f_FM_MAC_DumpRegs(h_FmMac);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
new file mode 100644
index 0000000..16c26fe
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
@@ -0,0 +1,180 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_mac.h
+
+ @Description   FM MAC ...
+*//***************************************************************************/
+#ifndef __FM_MAC_H
+#define __FM_MAC_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+#include "fm_common.h"
+#include "fm_mac_ext.h"
+
+
+typedef struct
+{
+    t_Error (*f_FM_MAC_Init) (t_Handle h_FmMac);
+    t_Error (*f_FM_MAC_Free) (t_Handle h_FmMac);
+
+    t_Error (*f_FM_MAC_ConfigStatistics) (t_Handle h_FmMac, bool newVal);
+    t_Error (*f_FM_MAC_ConfigLoopback) (t_Handle h_FmMac, bool newVal);
+    t_Error (*f_FM_MAC_ConfigMaxFrameLength) (t_Handle h_FmMac, uint16_t newVal);
+    t_Error (*f_FM_MAC_ConfigWan) (t_Handle h_FmMac, bool flag);
+    t_Error (*f_FM_MAC_ConfigPadAndCrc) (t_Handle h_FmMac, bool newVal);
+    t_Error (*f_FM_MAC_ConfigHalfDuplex) (t_Handle h_FmMac, bool newVal);
+    t_Error (*f_FM_MAC_ConfigHugeFrames) (t_Handle h_FmMac, bool newVal);
+
+    t_Error (*f_FM_MAC_SetExceptions) (t_Handle h_FmMac, e_FmMacExceptions ex);
+
+    t_Error (*f_FM_MAC_Enable)  (t_Handle h_FmMac,  e_CommMode mode);
+    t_Error (*f_FM_MAC_Disable) (t_Handle h_FmMac, e_CommMode mode);
+    t_Error (*f_FM_MAC_Restart) (t_Handle h_FmMac, e_CommMode mode);
+    t_Error (*f_FM_MAC_Reset)   (t_Handle h_FmMac, bool wait);
+
+    t_Error (*f_FM_MAC_TxMacPause) (t_Handle h_FmMac, uint16_t pauseTime, uint16_t exPauseTime);
+
+    t_Error (*f_FM_MAC_ResetCounters) (t_Handle h_FmMac);
+    t_Error (*f_FM_MAC_GetStatistics) (t_Handle h_FmMac, t_FmMacStatistics *p_Statistics);
+
+    t_Error (*f_FM_MAC_ModifyMacAddr) (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+    t_Error (*f_FM_MAC_AddHashMacAddr) (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+    t_Error (*f_FM_MAC_RemoveHashMacAddr) (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+    t_Error (*f_FM_MAC_AddExactMatchMacAddr) (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+    t_Error (*f_FM_MAC_RemovelExactMatchMacAddr) (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+
+    t_Error (*f_FM_MAC_SetPromiscuous) (t_Handle h_FmMac, bool newVal);
+    t_Error (*f_FM_MAC_AdjustLink)     (t_Handle h_FmMac, e_EnetSpeed speed, bool fullDuplex);
+
+    t_Error (*f_FM_MAC_GetId) (t_Handle h_FmMac, uint32_t *macId);
+
+    t_Error (*f_FM_MAC_GetVersion) (t_Handle h_FmMac, uint32_t *macVersion);
+
+    t_Error (*f_FM_MAC_MII_WritePhyReg)(t_Handle h_FmMac, uint8_t phyAddr, uint8_t reg, uint16_t data);
+    t_Error (*f_FM_MAC_MII_ReadPhyReg)(t_Handle h_FmMac,  uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    t_Error (*f_FM_MAC_DumpRegs) (t_Handle h_FmMac);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+    t_Handle        h_Fm;
+    e_EnetMode      enetMode;
+    uint8_t         macId;
+} t_FmMacControllerDriver;
+
+typedef struct {
+    uint64_t addr;      /* Ethernet Address  */
+    t_List   node;
+} t_EthHashEntry;
+#define ETH_HASH_ENTRY_OBJ(ptr) LIST_OBJECT(ptr, t_EthHashEntry, node)
+
+typedef struct {
+    uint16_t    size;
+    t_List      *p_Lsts;
+} t_EthHash;
+
+t_Handle  DTSEC_Config(t_FmMacParams *p_FmMacParam);
+t_Handle  TGEC_Config(t_FmMacParams *p_FmMacParams);
+
+/* ........................................................................... */
+
+static __inline__ t_EthHashEntry *DequeueAddrFromHashEntry(t_List *p_AddrLst)
+{
+   t_EthHashEntry *p_HashEntry = NULL;
+    if (!LIST_IsEmpty(p_AddrLst))
+    {
+        p_HashEntry = ETH_HASH_ENTRY_OBJ(p_AddrLst->p_Next);
+        LIST_DelAndInit(&p_HashEntry->node);
+    }
+    return p_HashEntry;
+}
+
+/* ........................................................................... */
+
+static __inline__ void FreeHashTable(t_EthHash *p_Hash)
+{
+    t_EthHashEntry  *p_HashEntry;
+    int             i = 0;
+
+    if (!p_Hash || !p_Hash->p_Lsts)
+        return;
+
+    for(i=0; i<p_Hash->size; i++)
+    {
+        p_HashEntry = DequeueAddrFromHashEntry(&p_Hash->p_Lsts[i]);
+        while (p_HashEntry)
+        {
+            XX_Free(p_HashEntry);
+            p_HashEntry = DequeueAddrFromHashEntry(&p_Hash->p_Lsts[i]);
+        }
+    }
+
+    XX_Free(p_Hash->p_Lsts);
+    XX_Free(p_Hash);
+}
+
+/* ........................................................................... */
+
+static __inline__ t_EthHash * AllocHashTable(uint16_t size)
+{
+    uint32_t    i;
+    t_EthHash *p_Hash;
+
+    /* Allocate address hash table */
+    p_Hash = (t_EthHash *)XX_Malloc(size*sizeof(t_EthHash *));
+    if (!p_Hash)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Address hash table"));
+        return NULL;
+    }
+    p_Hash->size = size;
+
+    p_Hash->p_Lsts = (t_List *)XX_Malloc(p_Hash->size*sizeof(t_List));
+    if (!p_Hash->p_Lsts)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Address hash table"));
+        XX_Free(p_Hash);
+        return NULL;
+    }
+
+    for(i=0 ; i<p_Hash->size; i++)
+        INIT_LIST(&p_Hash->p_Lsts[i]);
+
+    return p_Hash;
+}
+
+
+#endif /* __FM_MAC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
new file mode 100644
index 0000000..34bcb06
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
@@ -0,0 +1,930 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          tgec.c
+
+ @Description   FM 10G MAC ...
+*//***************************************************************************/
+
+#include "std_ext.h"
+#include "string_ext.h"
+#include "error_ext.h"
+#include "xx_ext.h"
+#include "endian_ext.h"
+#include "crc_mac_addr_ext.h"
+#include "debug_ext.h"
+
+#include "tgec.h"
+
+
+/*****************************************************************************/
+/*                      Internal routines                                    */
+/*****************************************************************************/
+
+static t_Error CheckInitParameters(t_Tgec    *p_Tgec)
+{
+    if(ENET_SPEED_FROM_MODE(p_Tgec->enetMode) < e_ENET_SPEED_10000)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet 10G MAC driver only support 10G speed"));
+    if(p_Tgec->macId >= FM_MAX_NUM_OF_10G_MACS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("macId of 10 G can not be greater than 0"));
+    if(p_Tgec->addr == 0)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet 10G MAC Must have a valid MAC Address"));
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static void SetDefaultParam(t_TgecDriverParam *p_TgecDriverParam)
+{
+    p_TgecDriverParam->wanModeEnable            = DEFAULT_wanModeEnable;
+    p_TgecDriverParam->promiscuousModeEnable    = DEFAULT_promiscuousModeEnable;
+    p_TgecDriverParam->padRemovalEnable         = DEFAULT_padRemovalEnable;
+    p_TgecDriverParam->crcForwardEnable         = DEFAULT_crcForwardEnable;
+    p_TgecDriverParam->pauseForwardEnable       = DEFAULT_pauseForwardEnable;
+    p_TgecDriverParam->pauseIgnore              = DEFAULT_pauseIgnore;
+    p_TgecDriverParam->txAddrInsEnable          = DEFAULT_txAddrInsEnable;
+
+    p_TgecDriverParam->loopbackEnable           = DEFAULT_loopbackEnable;
+    p_TgecDriverParam->cmdFrameEnable           = DEFAULT_cmdFrameEnable;
+    p_TgecDriverParam->rxErrorDiscard           = DEFAULT_rxErrorDiscard;
+    p_TgecDriverParam->phyTxenaOn               = DEFAULT_phyTxenaOn;
+    p_TgecDriverParam->sendIdleEnable           = DEFAULT_sendIdleEnable;
+    p_TgecDriverParam->noLengthCheckEnable      = DEFAULT_noLengthCheckEnable;
+    p_TgecDriverParam->lgthCheckNostdr          = DEFAULT_lgthCheckNostdr;
+    p_TgecDriverParam->timeStampEnable          = DEFAULT_timeStampEnable;
+    p_TgecDriverParam->rxSfdAny                 = DEFAULT_rxSfdAny;
+    p_TgecDriverParam->rxPblFwd                 = DEFAULT_rxPblFwd;
+    p_TgecDriverParam->txPblFwd                 = DEFAULT_txPblFwd;
+
+    p_TgecDriverParam->txIpgLength              = DEFAULT_txIpgLength;
+    p_TgecDriverParam->statisticsEnable         = DEFAULT_statisticsEnable;
+    p_TgecDriverParam->maxFrameLength           = DEFAULT_maxFrameLength;
+    p_TgecDriverParam->padAndCrcEnable          = DEFAULT_padAndCrcEnable;
+
+    p_TgecDriverParam->debugMode                = DEFAULT_debugMode;
+
+    p_TgecDriverParam->pauseTime                = DEFAULT_pauseTime;
+
+//Temp    p_TgecDriverParam->imask              = DEFAULT_imask;
+}
+
+/* ........................................................................... */
+
+static void FreeInitResources(t_Tgec *p_Tgec)
+{
+    /* release the driver's group hash table */
+    FreeHashTable(p_Tgec->p_MulticastAddrHash);
+    p_Tgec->p_MulticastAddrHash =   NULL;
+
+    /* release the driver's individual hash table */
+    FreeHashTable(p_Tgec->p_UnicastAddrHash);
+    p_Tgec->p_UnicastAddrHash =     NULL;
+}
+
+/* .............................................................................. */
+
+static void HardwareClearAddrInPaddr(t_Tgec   *p_Tgec, uint8_t paddrNum)
+{
+    if (paddrNum != 0)
+        return;             /* At this time MAC has only one address */
+
+    WRITE_UINT32(p_Tgec->p_MemMap->mac_addr_2, 0x0);
+    WRITE_UINT32(p_Tgec->p_MemMap->mac_addr_3, 0x0);
+}
+
+/* ........................................................................... */
+
+static void HardwareAddAddrInPaddr(t_Tgec   *p_Tgec, uint64_t *p_Addr, uint8_t paddrNum)
+{
+    uint32_t tmpReg32 = 0;
+    uint64_t addr = *p_Addr;
+    t_TgecMemMap    *p_TgecMemMap = p_Tgec->p_MemMap;
+
+    if (paddrNum != 0)
+        return;             /* At this time MAC has only one address */
+
+//    tmpReg32 = (uint32_t)(addr);
+    tmpReg32 = (uint32_t)(addr>>16);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_TgecMemMap->mac_addr_2, tmpReg32);
+
+//    tmpReg32 = (uint32_t)(addr>>32);
+    tmpReg32 = (uint32_t)(addr);
+    SwapUint32P(&tmpReg32);
+    tmpReg32 >>= 16;
+    WRITE_UINT32(p_TgecMemMap->mac_addr_3, tmpReg32);
+}
+
+/*****************************************************************************/
+/*                     10G MAC API routines                                  */
+/*****************************************************************************/
+
+static t_Error TgecFree(t_Handle h_Tgec)
+{
+    t_Tgec       *p_Tgec = (t_Tgec *)h_Tgec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+
+    if (p_Tgec->p_TgecDriverParam)
+    {
+        XX_Free(p_Tgec->p_TgecDriverParam);
+        p_Tgec->p_TgecDriverParam = NULL;
+    }
+    FreeInitResources(p_Tgec);
+    XX_Free (p_Tgec);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecInit(t_Handle h_Tgec)
+{
+
+    t_Tgec                  *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecDriverParam       *p_TgecDriverParam;
+    t_TgecMemMap            *p_MemMap;
+    uint32_t                tmpReg32;
+    uint64_t                addr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
+
+    CHECK_INIT_PARAMETERS(p_Tgec, CheckInitParameters);
+
+    p_TgecDriverParam = p_Tgec->p_TgecDriverParam;
+    p_MemMap = p_Tgec->p_MemMap;
+
+    /* MAC Address */
+
+    addr = p_Tgec->addr;
+
+//    tmpReg32 = (uint32_t)(addr);
+    tmpReg32 = (uint32_t)(addr>>16);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_MemMap->mac_addr_0, tmpReg32);
+
+//    tmpReg32 = (uint32_t)(addr>>32);
+    tmpReg32 = (uint32_t)(addr);
+    SwapUint32P(&tmpReg32);
+    tmpReg32 >>= 16;
+    WRITE_UINT32(p_MemMap->mac_addr_1, tmpReg32);
+
+    /* Config */
+
+    tmpReg32 = 0;
+    if (p_TgecDriverParam->wanModeEnable)
+       tmpReg32 |= CMD_CFG_WAN_MODE;
+    if (p_TgecDriverParam->promiscuousModeEnable)
+       tmpReg32 |= CMD_CFG_PROMIS_EN;
+    if (p_TgecDriverParam->padRemovalEnable)
+       tmpReg32 |= CMD_CFG_PAD_EN;
+    if (p_TgecDriverParam->crcForwardEnable)
+       tmpReg32 |= CMD_CFG_CRC_FWD;
+    if (p_TgecDriverParam->pauseForwardEnable)
+       tmpReg32 |= CMD_CFG_PAUSE_FWD;
+    if (p_TgecDriverParam->pauseIgnore)
+       tmpReg32 |= CMD_CFG_PAUSE_IGNORE;
+    if (p_TgecDriverParam->txAddrInsEnable)
+       tmpReg32 |= CMD_CFG_TX_ADDR_INS;
+    if (p_TgecDriverParam->loopbackEnable)
+        tmpReg32 |= CMD_CFG_LOOPBACK_EN;
+    if (p_TgecDriverParam->cmdFrameEnable)
+        tmpReg32 |= CMD_CFG_CMD_FRM_EN;
+    if (p_TgecDriverParam->rxErrorDiscard)
+        tmpReg32 |= CMD_CFG_RX_ER_DISC;
+    if (p_TgecDriverParam->phyTxenaOn)
+       tmpReg32 |= CMD_CFG_PHY_TX_EN;
+    if (p_TgecDriverParam->sendIdleEnable)
+       tmpReg32 |= CMD_CFG_SEND_IDLE;
+    if (p_TgecDriverParam->noLengthCheckEnable)
+       tmpReg32 |= CMD_CFG_NO_LEN_CHK;
+    if (p_TgecDriverParam->lgthCheckNostdr)
+       tmpReg32 |= CMD_CFG_LEN_CHK_NOSTDR;
+    if (p_TgecDriverParam->timeStampEnable)
+       tmpReg32 |= CMD_CFG_EN_TIMESTAMP;
+    if (p_TgecDriverParam->rxSfdAny)
+       tmpReg32 |= RX_SFD_ANY;
+    if (p_TgecDriverParam->rxPblFwd)
+       tmpReg32 |= CMD_CFG_RX_PBL_FWD;
+    if (p_TgecDriverParam->txPblFwd)
+       tmpReg32 |= CMD_CFG_TX_PBL_FWD;
+    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, tmpReg32);
+
+    /* Max Frame Length */
+    WRITE_UINT32(p_MemMap->maxfrm, (uint32_t)p_TgecDriverParam->maxFrameLength);
+
+    /* Pause Time */
+    WRITE_UINT32(p_MemMap->pause_quant, p_TgecDriverParam->pauseTime);
+
+    p_Tgec->p_MulticastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
+    if(!p_Tgec->p_MulticastAddrHash)
+    {
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("allocation hash table is FAILED"));
+    }
+
+    p_Tgec->p_UnicastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
+    if(!p_Tgec->p_UnicastAddrHash)
+    {
+        FreeInitResources(p_Tgec);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("allocation hash table is FAILED"));
+    }
+
+    XX_Free(p_TgecDriverParam);
+    p_Tgec->p_TgecDriverParam = NULL;
+
+    return E_OK;
+}
+
+
+/*****************************************************************************/
+/*                      Tgec Configs modification functions                 */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+static t_Error TgecConfigStatistics(t_Handle h_Tgec, bool newVal)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
+    p_Tgec->p_TgecDriverParam->statisticsEnable = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecConfigLoopback(t_Handle h_Tgec, bool newVal)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
+    p_Tgec->p_TgecDriverParam->loopbackEnable = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecConfigWan(t_Handle h_Tgec, bool newVal)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
+    p_Tgec->p_TgecDriverParam->wanModeEnable = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecConfigMaxFrameLength(t_Handle h_Tgec, uint16_t newVal)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
+    p_Tgec->p_TgecDriverParam->maxFrameLength = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecConfigPadAndCrc(t_Handle h_Tgec, bool newVal)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
+    p_Tgec->p_TgecDriverParam->padAndCrcEnable = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecConfigHugeFrames(t_Handle h_Tgec, bool newVal)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+    UNUSED(newVal);
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+/*                      Tgec Run Time API functions                         */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+static t_Error TgecEnable(t_Handle h_Tgec,  e_CommMode mode)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap       *p_MemMap ;
+    uint32_t            tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
+
+    p_MemMap= (t_TgecMemMap*)(p_Tgec->p_MemMap);
+
+    tmpReg32 = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+
+    switch (mode)
+    {
+        case e_COMM_MODE_NONE:
+            tmpReg32 &= ~(CMD_CFG_TX_EN | CMD_CFG_RX_EN);
+            break;
+        case e_COMM_MODE_RX :
+            tmpReg32 |= CMD_CFG_RX_EN ;
+            break;
+        case e_COMM_MODE_TX :
+            tmpReg32 |= CMD_CFG_TX_EN ;
+            break;
+        case e_COMM_MODE_RX_AND_TX:
+            tmpReg32 |= (CMD_CFG_TX_EN | CMD_CFG_RX_EN);
+            break;
+    }
+
+    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+static t_Error TgecDisable (t_Handle h_Tgec, e_CommMode mode)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap       *p_MemMap ;
+    uint32_t            tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
+
+    p_MemMap= (t_TgecMemMap*)(p_Tgec->p_MemMap);
+
+    tmpReg32 = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+
+    switch (mode)
+    {
+        case e_COMM_MODE_RX :
+            tmpReg32 &= ~CMD_CFG_RX_EN ;
+            break;
+        case e_COMM_MODE_TX :
+            tmpReg32 &= ~CMD_CFG_TX_EN ;
+            break;
+        case e_COMM_MODE_RX_AND_TX:
+            tmpReg32 &= ~(CMD_CFG_TX_EN | CMD_CFG_RX_EN);
+        break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
+    }
+
+    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecTxMacPause(t_Handle h_Tgec, uint16_t pauseTime, uint16_t exPauseTime )
+{
+    t_Tgec      *p_Tgec = (t_Tgec *)h_Tgec;
+    uint32_t    ptv = 0 ;
+    t_TgecMemMap *p_MemMap;
+    UNUSED(exPauseTime);
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_STATE);
+
+    p_MemMap = (t_TgecMemMap*)(p_Tgec->p_MemMap);
+
+    ptv = (uint32_t)pauseTime ;
+
+    WRITE_UINT32(p_MemMap->pause_quant, ptv);
+
+    return E_OK;
+}
+
+/* Counters handling */
+/* .............................................................................. */
+
+static t_Error TgecGetStatistics(t_Handle h_Tgec, t_FmMacStatistics *p_Statistics)
+{
+    t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap        *p_TgecMemMap = p_Tgec->p_MemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Statistics, E_NULL_POINTER);
+
+
+
+    p_Statistics->eStatPkts64           = GET_UINT64(p_TgecMemMap->R64);
+    p_Statistics->eStatPkts65to127      = GET_UINT64(p_TgecMemMap->R127);
+    p_Statistics->eStatPkts128to255     = GET_UINT64(p_TgecMemMap->R255);
+    p_Statistics->eStatPkts256to511     = GET_UINT64(p_TgecMemMap->R511);
+    p_Statistics->eStatPkts512to1023    = GET_UINT64(p_TgecMemMap->R1023);
+    p_Statistics->eStatPkts1024to1518   = GET_UINT64(p_TgecMemMap->R1518);
+    p_Statistics->eStatPkts1519to1522   = GET_UINT64(p_TgecMemMap->R1519X);
+/* */
+    p_Statistics->eStatFragments        = GET_UINT64(p_TgecMemMap->TRFRG);
+    p_Statistics->eStatJabbers          = GET_UINT64(p_TgecMemMap->TRJBR);
+
+    p_Statistics->eStatsDropEvents      = GET_UINT64(p_TgecMemMap->RDRP);
+    p_Statistics->eStatCRCAlignErrors   = GET_UINT64(p_TgecMemMap->RALN);
+
+    p_Statistics->eStatUndersizePkts    = GET_UINT64(p_TgecMemMap->TRUND);
+    p_Statistics->eStatOversizePkts     = GET_UINT64(p_TgecMemMap->TROVR);
+/* Pause */
+    p_Statistics->reStatPause           = GET_UINT64(p_TgecMemMap->RXPF);
+    p_Statistics->teStatPause           = GET_UINT64(p_TgecMemMap->TXPF);
+
+
+/* MIB II */
+    p_Statistics->ifInOctets            = GET_UINT64(p_TgecMemMap->ROCT);
+    p_Statistics->ifInMcastPkts         = GET_UINT64(p_TgecMemMap->RMCA);
+    p_Statistics->ifInBcastPkts         = GET_UINT64(p_TgecMemMap->RBCA);
+    p_Statistics->ifInPkts              = GET_UINT64(p_TgecMemMap->RUCA)
+                                        + p_Statistics->ifInMcastPkts
+                                        + p_Statistics->ifInBcastPkts;
+    p_Statistics->ifInDiscards          = 0;
+    p_Statistics->ifInErrors            = GET_UINT64(p_TgecMemMap->RERR);
+
+    p_Statistics->ifOutOctets           = GET_UINT64(p_TgecMemMap->TOCT);
+    p_Statistics->ifOutMcastPkts        = GET_UINT64(p_TgecMemMap->TMCA);
+    p_Statistics->ifOutBcastPkts        = GET_UINT64(p_TgecMemMap->TBCA);
+    p_Statistics->ifOutPkts             = GET_UINT64(p_TgecMemMap->TUCA);
+    p_Statistics->ifOutDiscards         = 0;
+    p_Statistics->ifOutErrors           = GET_UINT64(p_TgecMemMap->TERR);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecModifyMacAddress (t_Handle h_Tgec, t_EnetAddr *p_EnetAddr)
+{
+    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap        *p_TgecMemMap = p_Tgec->p_MemMap;
+    uint32_t              tmpReg32 = 0;
+    uint64_t              addr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_TgecMemMap, E_INVALID_HANDLE);
+
+    /*  Initialize MAC Station Address registers (1 & 2)    */
+    /*  Station address have to be swapped (big endian to little endian */
+
+    addr = ((*(uint64_t *)p_EnetAddr) >> 16);
+    p_Tgec->addr = addr;
+
+    tmpReg32 = 0;
+    tmpReg32 |= (uint32_t)(addr & 0xFFFFFFFF);
+    WRITE_UINT32(p_TgecMemMap->mac_addr_0, tmpReg32);
+
+    tmpReg32 = 0;
+    tmpReg32 |= (uint32_t) (addr >> 32);
+
+    WRITE_UINT32(p_TgecMemMap->mac_addr_1, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecResetCounters (t_Handle h_Tgec)
+{
+    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap       *p_MemMap ;
+    uint32_t            tmpReg32, cmdConfCtrl;
+    int i;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
+
+    p_MemMap= (t_TgecMemMap*)(p_Tgec->p_MemMap);
+
+    cmdConfCtrl = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+
+    cmdConfCtrl |= CMD_CFG_STAT_CLR;
+
+    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, cmdConfCtrl);
+
+    for (i=0; i<1000; i++)
+    {
+        tmpReg32 = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+        if (!(tmpReg32 & CMD_CFG_STAT_CLR))
+            break;
+    }
+
+    cmdConfCtrl &= ~CMD_CFG_STAT_CLR;
+    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, cmdConfCtrl);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecDelExactMatchMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
+{
+    t_Tgec   *p_Tgec = (t_Tgec *) h_Tgec;
+    uint64_t  ethAddr;
+    uint8_t   paddrNum;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    /* Find used PADDR containing this address */
+    for (paddrNum = 0; paddrNum < TGEC_NUM_OF_PADDRS; paddrNum++)
+    {
+        if ((p_Tgec->indAddrRegUsed[paddrNum]) &&
+            (p_Tgec->paddr[paddrNum] == ethAddr))
+        {
+            /* mark this PADDR as not used */
+            p_Tgec->indAddrRegUsed[paddrNum] = FALSE;
+            /* clear in hardware */
+            HardwareClearAddrInPaddr(p_Tgec, paddrNum);
+            p_Tgec->numOfIndAddrInRegs--;
+
+            return E_OK;
+        }
+    }
+
+    RETURN_ERROR(MAJOR, E_NOT_FOUND, NO_MSG);
+}
+
+/* .............................................................................. */
+
+static t_Error TgecAddExactMatchMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
+{
+    t_Tgec   *p_Tgec = (t_Tgec *) h_Tgec;
+    uint64_t  ethAddr;
+    uint8_t   paddrNum;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    if (ethAddr & GROUP_ADDRESS)
+        /* Multicast address has no effect in PADDR */
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Multicast address"));
+
+    /* Make sure no PADDR contains this address */
+    for (paddrNum = 0; paddrNum < TGEC_NUM_OF_PADDRS; paddrNum++)
+    {
+        if (p_Tgec->indAddrRegUsed[paddrNum])
+        {
+            if (p_Tgec->paddr[paddrNum] == ethAddr)
+            {
+                RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, NO_MSG);
+            }
+        }
+    }
+
+    /* Find first unused PADDR */
+    for (paddrNum = 0; paddrNum < TGEC_NUM_OF_PADDRS; paddrNum++)
+    {
+        if (!(p_Tgec->indAddrRegUsed[paddrNum]))
+        {
+            /* mark this PADDR as used */
+            p_Tgec->indAddrRegUsed[paddrNum] = TRUE;
+            /* store address */
+            p_Tgec->paddr[paddrNum] = ethAddr;
+
+            /* put in hardware */
+            HardwareAddAddrInPaddr(p_Tgec, &ethAddr, paddrNum);
+            p_Tgec->numOfIndAddrInRegs++;
+
+            return E_OK;
+        }
+    }
+
+    /* No free PADDR */
+    RETURN_ERROR(MAJOR, E_FULL, NO_MSG);
+}
+
+/* .............................................................................. */
+
+static t_Error TgecAddHashMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
+{
+    t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap    *p_TgecMemMap = p_Tgec->p_MemMap;
+    t_EthHashEntry  *p_HashEntry;
+    uint32_t        crc;
+    uint32_t        hash;
+    uint64_t        ethAddr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_TgecMemMap, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    if (!(ethAddr & GROUP_ADDRESS))
+        /* Unicast addresses not supported in hash */
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unicast Address"));
+
+    /* CRC calculation */
+    GET_MAC_ADDR_CRC(ethAddr, crc);
+    crc = MIRROR_32(crc);
+
+    hash = (crc >> HASH_CTRL_MCAST_SHIFT) & HASH_ADDR_MASK;        /* Take 9 MSB bits */
+
+    /* Create element to be added to the driver hash table */
+    p_HashEntry = (t_EthHashEntry *)XX_Malloc(sizeof(t_EthHashEntry));
+    p_HashEntry->addr = ethAddr;
+    INIT_LIST(&p_HashEntry->node);
+
+    LIST_AddToTail(&(p_HashEntry->node), &(p_Tgec->p_MulticastAddrHash->p_Lsts[hash]));
+    WRITE_UINT32(p_TgecMemMap->hashtable_ctrl, (hash | HASH_CTRL_MCAST_EN));
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecDelHashMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
+{
+    t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap    *p_TgecMemMap = p_Tgec->p_MemMap;
+    t_EthHashEntry  *p_HashEntry = NULL;
+    t_List          *p_Pos;
+    uint32_t        crc;
+    uint32_t        hash;
+    uint64_t        ethAddr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_TgecMemMap, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    /* CRC calculation */
+    GET_MAC_ADDR_CRC(ethAddr, crc);
+    crc = MIRROR_32(crc);
+
+    hash = (crc >> HASH_CTRL_MCAST_SHIFT) & HASH_ADDR_MASK;        /* Take 9 MSB bits */
+
+    LIST_FOR_EACH(p_Pos, &(p_Tgec->p_MulticastAddrHash->p_Lsts[hash]))
+    {
+
+        p_HashEntry = ETH_HASH_ENTRY_OBJ(p_Pos);
+        if(p_HashEntry->addr == ethAddr)
+        {
+            LIST_DelAndInit(&p_HashEntry->node);
+            XX_Free(p_HashEntry);
+            break;
+        }
+    }
+    if(LIST_IsEmpty(&p_Tgec->p_MulticastAddrHash->p_Lsts[hash]))
+        WRITE_UINT32(p_TgecMemMap->hashtable_ctrl, (hash & ~HASH_CTRL_MCAST_EN));
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecGetId(t_Handle h_Tgec, uint32_t *macId)
+{
+    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap        *p_TgecMemMap = p_Tgec->p_MemMap;
+UNUSED(macId);
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_TgecMemMap, E_INVALID_HANDLE);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("TgecGetId Not Supported"));
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecGetVersion(t_Handle h_Tgec, uint32_t *macVersion)
+{
+    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap        *p_TgecMemMap = p_Tgec->p_MemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_TgecMemMap, E_INVALID_HANDLE);
+
+    *macVersion = GET_UINT32(p_TgecMemMap->tgec_id);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecSetPromiscuous(t_Handle h_Tgec, bool newVal)
+{
+    t_Tgec       *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMemMap *p_TgecMemMap = p_Tgec->p_MemMap;
+    uint32_t     tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_HANDLE);
+
+    tmpReg32 = GET_UINT32(p_TgecMemMap->cmd_conf_ctrl);
+
+    if (newVal)
+        tmpReg32 |= CMD_CFG_PROMIS_EN;
+    else
+        tmpReg32 &= ~CMD_CFG_PROMIS_EN;
+
+    WRITE_UINT32(p_TgecMemMap->cmd_conf_ctrl, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecAdjustLink(t_Handle h_Tgec, e_EnetSpeed speed, bool fullDuplex)
+{
+    t_Tgec       *p_Tgec = (t_Tgec *)h_Tgec;
+    /*t_TgecMemMap *p_TgecMemMap = p_Tgec->p_MemMap;
+    uint32_t     tmpReg32;*/
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_HANDLE);
+
+    if (!fullDuplex)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("half-duplex"));
+
+RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error TgecSetExcpetions(t_Handle h_Tgec, e_FmMacExceptions ex)
+{
+    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_HANDLE);
+UNUSED(ex);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* .............................................................................. */
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+static t_Error TgecDumpRegs(t_Handle h_Tgec)
+{
+    t_Tgec    *p_Tgec = (t_Tgec *)h_Tgec;
+
+    DECLARE_DUMP;
+
+    if (p_Tgec->p_MemMap)
+    {
+        DUMP_TITLE(p_Tgec->p_MemMap, ("10G MAC %d: ", p_Tgec->macId));
+    }
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+/*****************************************************************************/
+/*                      Tgec Config  Main Entry                             */
+/*****************************************************************************/
+
+static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacControllerDriver)
+{
+    p_FmMacControllerDriver->f_FM_MAC_Init                      = TgecInit;
+    p_FmMacControllerDriver->f_FM_MAC_Free                      = TgecFree;
+
+    p_FmMacControllerDriver->f_FM_MAC_ConfigStatistics          = TgecConfigStatistics;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigLoopback            = TgecConfigLoopback;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigMaxFrameLength      = TgecConfigMaxFrameLength;
+
+    p_FmMacControllerDriver->f_FM_MAC_ConfigWan                 = TgecConfigWan;
+
+    p_FmMacControllerDriver->f_FM_MAC_ConfigPadAndCrc           = TgecConfigPadAndCrc;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex          = NULL; /* half-duplex is not supported in xgec */
+    p_FmMacControllerDriver->f_FM_MAC_ConfigHugeFrames          = TgecConfigHugeFrames;
+
+    p_FmMacControllerDriver->f_FM_MAC_SetExceptions             = TgecSetExcpetions;
+
+    p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous            = TgecSetPromiscuous;
+    p_FmMacControllerDriver->f_FM_MAC_AdjustLink                = TgecAdjustLink;
+
+    p_FmMacControllerDriver->f_FM_MAC_Enable                    = TgecEnable;
+    p_FmMacControllerDriver->f_FM_MAC_Disable                   = TgecDisable;
+    p_FmMacControllerDriver->f_FM_MAC_Restart                   = NULL; /* TgecRestart; Not Implemented */
+
+    p_FmMacControllerDriver->f_FM_MAC_TxMacPause                = TgecTxMacPause;
+
+    p_FmMacControllerDriver->f_FM_MAC_ResetCounters             = TgecResetCounters;
+    p_FmMacControllerDriver->f_FM_MAC_GetStatistics             = TgecGetStatistics;
+
+    p_FmMacControllerDriver->f_FM_MAC_ModifyMacAddr             = TgecModifyMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_AddHashMacAddr            = TgecAddHashMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_RemoveHashMacAddr         = TgecDelHashMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_AddExactMatchMacAddr      = TgecAddExactMatchMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_RemovelExactMatchMacAddr  = TgecDelExactMatchMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_GetId                     = TgecGetId;
+    p_FmMacControllerDriver->f_FM_MAC_GetVersion                = TgecGetVersion;
+
+    p_FmMacControllerDriver->f_FM_MAC_MII_WritePhyReg           = TGEC_MII_WritePhyReg;
+    p_FmMacControllerDriver->f_FM_MAC_MII_ReadPhyReg            = TGEC_MII_ReadPhyReg;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    p_FmMacControllerDriver->f_FM_MAC_DumpRegs                  = TgecDumpRegs;
+#endif /* (defined(DEBUG_ERRORS) && ... */
+}
+
+t_Handle  TGEC_Config(t_FmMacParams *p_FmMacParam)
+{
+    t_Tgec                  *p_Tgec;
+    t_TgecDriverParam       *p_TgecDriverParam;
+    uint64_t                baseAddr = p_FmMacParam->baseAddr;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmMacParam, E_NULL_POINTER, NULL);
+
+    /* allocate memory for the UCC GETH data structure. */
+    p_Tgec = (t_Tgec *) XX_Malloc(sizeof(t_Tgec));
+    if (!p_Tgec)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("10G MAC driver structure"));
+        return NULL;
+    }
+    /* Zero out * p_Tgec */
+    memset( p_Tgec, 0, sizeof(t_Tgec));
+    InitFmMacControllerDriver(&p_Tgec->fmMacControllerDriver);
+
+    /* allocate memory for the 10G MAC driver parameters data structure. */
+    p_TgecDriverParam = (t_TgecDriverParam *) XX_Malloc(sizeof(t_TgecDriverParam));
+    if (!p_TgecDriverParam)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("10G MAC driver parameters"));
+        TgecFree(p_Tgec);
+        return NULL;
+    }
+    /* Zero out */
+    memset(p_TgecDriverParam, 0, sizeof(t_TgecDriverParam));
+
+    /* Plant parameter structure pointer */
+    p_Tgec->p_TgecDriverParam = p_TgecDriverParam;
+
+    SetDefaultParam(p_TgecDriverParam);
+
+    p_Tgec->h_App    = p_FmMacParam->h_App ;
+    p_Tgec->addr  = ((*(uint64_t *)p_FmMacParam->addr) >> 16);
+    p_Tgec->p_MemMap = CAST_UINT64_TO_POINTER_TYPE(t_TgecMemMap, baseAddr);
+    p_Tgec->p_MiiMemMap  = CAST_UINT64_TO_POINTER_TYPE(t_TgecMiiAccessMemMap, (baseAddr + TGEC_TO_MII_OFFSET));
+    p_Tgec->enetMode = p_FmMacParam->enetMode;
+    p_Tgec->macId    = p_FmMacParam->macId;
+
+    return p_Tgec;
+}
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
new file mode 100644
index 0000000..9c8ac97
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
@@ -0,0 +1,439 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          tgec.h
+
+ @Description   FM 10G MAC ...
+*//***************************************************************************/
+#ifndef __TGEC_H
+#define __TGEC_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+#include "tgec_mii_acc.h"
+#include "fm_mac.h"
+
+
+/* Default Config Params */
+#define DEFAULT_wanModeEnable               FALSE
+#define DEFAULT_promiscuousModeEnable       FALSE
+
+#define DEFAULT_padRemovalEnable            FALSE
+#define DEFAULT_crcForwardEnable            TRUE
+#define DEFAULT_pauseForwardEnable          FALSE
+#define DEFAULT_pauseIgnore                 FALSE
+#define DEFAULT_txAddrInsEnable             FALSE
+
+#define DEFAULT_loopbackEnable              FALSE
+#define DEFAULT_cmdFrameEnable              FALSE
+#define DEFAULT_rxErrorDiscard              FALSE
+#define DEFAULT_phyTxenaOn                  FALSE
+#define DEFAULT_sendIdleEnable              FALSE
+#define DEFAULT_noLengthCheckEnable         FALSE
+#define DEFAULT_lgthCheckNostdr             FALSE
+#define DEFAULT_timeStampEnable             FALSE
+#define DEFAULT_rxSfdAny                    FALSE
+#define DEFAULT_rxPblFwd                    FALSE
+#define DEFAULT_txPblFwd                    FALSE
+#define DEFAULT_txIpgLength                 12
+
+#define DEFAULT_statisticsEnable            TRUE
+#define DEFAULT_maxFrameLength              0x600
+#define DEFAULT_padAndCrcEnable             TRUE
+
+#define DEFAULT_debugMode                   FALSE
+#define DEFAULT_pauseTime                   0xf000
+
+
+#define MAX_PACKET_ALIGNMENT        31
+#define MAX_INTER_PACKET_GAP        0x7f
+#define MAX_INTER_PALTERNATE_BEB    0x0f
+#define MAX_RETRANSMISSION          0x0f
+#define MAX_COLLISION_WINDOW        0x03ff
+
+
+#define TGEC_NUM_OF_PADDRS          1                   /* number of pattern match registers (entries) */
+
+#define GROUP_ADDRESS               0x0000010000000000LL /* Group address bit indication */
+
+#define HASH_TABLE_SIZE             512                 /* Hash table size (= 32 bits * 8 regs) */
+
+#define TGEC_TO_MII_OFFSET          0x1000              /* Offset from the MEM map to the MDIO mem map */
+
+/* 10-gigabit Ethernet MAC Controller ID (10GEC_ID) */
+#define TGEC_ID_ID                  0xffff0000
+#define TGEC_ID_MAC_VERSION         0x0000FF00
+#define TGEC_ID_MAC_REV             0x000000ff
+
+/* Command and Configuration Register (COMMAND_CONFIG) */
+#define CMD_CFG_TX_PBL_FWD          0x00800000  /* 08 Transmit Preamble Forwarding (custom preamble).
+                                                 */
+#define CMD_CFG_RX_PBL_FWD          0x00400000  /* 09 Receive Preamble Forwarding (custom preamble).
+                                                 */
+#define RX_SFD_ANY                  0x00200000  /* 10 Enables, when set, that any character is allowed at the SFD position of the preamble and the frame will be accepted.
+                                                 */
+#define CMD_CFG_EN_TIMESTAMP        0x00100000  /* 11 EN_TIMESTAMP IEEE 1588 timeStamp functionality control.
+                                                 * 0 disabled
+                                                 * 1 enabled
+                                                 */
+#define CMD_CFG_TX_ADDR_INS_SEL     0x00080000  /* 12 TX_ADDR_INS_SEL Transmit MAC address select
+                                                 * 0 insert using first MAC address
+                                                 * 1 insert using second MAC address
+                                                 */
+#define CMD_CFG_LEN_CHK_NOSTDR      0x00040000  /* 13 LEN_CHK_NOSTDR
+                                                 */
+#define CMD_CFG_NO_LEN_CHK          0x00020000  /* 14 NO_LEN_CHK Payload length check disable
+                                                 * 0 MAC compares the frame payload length with the frame length/type field.
+                                                 * 1 Payload length check is disabled.
+                                                 */
+#define CMD_CFG_SEND_IDLE           0x00010000  /* 15 SEND_IDLE Force idle generation
+                                                 * 0 Normal operation.
+                                                * 1 MAC permanently sends XGMII idle sequences even when faults are received.
+                                                 */
+#define CMD_CFG_PHY_TX_EN           0x00008000  /* 16 PHY_TX_EN PHY transmit enable
+                                                 * 0 PHY transmit is disabled.
+                                                 * 1 PHY transmit is enabled.
+                                                 */
+#define CMD_CFG_RX_ER_DISC          0x00004000  /* 17 RX_ER_DISC Receive error frame discard enable
+                                                 * 0 Received error frames are processed.
+                                                 * 1 Any frame received with an error is discarded.
+                                                 */
+#define CMD_CFG_CMD_FRM_EN          0x00002000  /* 18 CMD_FRM_EN Command frame reception enable
+                                                 * 0 Only Pause frames are accepted (all other command frames are rejected).
+                                                 * 1 All command frames are accepted.
+                                                 */
+#define CMD_CFG_STAT_CLR            0x00001000  /* 19 STAT_CLR Clear statistics
+                                                 * 0 Normal operations.
+                                                 * 1 All statistics counters are cleared.
+                                                 */
+#define CMD_CFG_LOOPBACK_EN         0x00000400  /* 21 LOOPBAC_EN PHY interface loopback enable
+                                                 * 0 Configure PHY for normal operation.
+                                                 * 1 Configure PHY for loopback mode.
+                                                 */
+#define CMD_CFG_TX_ADDR_INS         0x00000200  /* 22 TX_ADDR_INS Transmit source MAC address insertion
+                                                 * 0 MAC transmits the source MAC address unmodified.
+                                                 * 1 MAC overwrites the source MAC address with address specified by COMMAND_CONFIG[TX_ADDR_INS_SEL].
+                                                 */
+#define CMD_CFG_PAUSE_IGNORE        0x00000100  /* 23 PAUSE_IGNORE Ignore Pause frame quanta
+                                                 * 0 MAC stops transmit process for the duration specified in the Pause frame quanta of a received Pause frame.
+                                                 * 1 MAC ignores received Pause frames.
+                                                 */
+#define CMD_CFG_PAUSE_FWD           0x00000080  /* 24 PAUSE_FWD Terminate/forward received Pause frames
+                                                 * 0 MAC terminates and discards received Pause frames.
+                                                 * 1 MAC forwards Pause frames to the user application.
+                                                 */
+#define CMD_CFG_CRC_FWD             0x00000040  /* 25 CRC_FWD Terminate/forward CRC of received frames
+                                                 * 0 MAC strips CRC from received frames.
+                                                 * 1 MAC forwards CRC of received frames to the user application.
+                                                 */
+#define CMD_CFG_PAD_EN              0x00000020  /* 26 PAD_EN Frame padding removal in receive path enable
+                                                 * 0 MAC does not remove padding prior to forwarding frames to the user application.
+                                                 * 1 MAC removed padding prior to forwarding frames to the user application.
+                                                 */
+#define CMD_CFG_PROMIS_EN           0x00000010  /* 27 PROMIS_EN Promiscuous operation enable
+                                                 * 0 Unicast frames with a destination address not matching the core MAC address (defined by registers, MAC_ADDR_0 and MAC_ADDR_1) are rejected.
+                                                 * 1 All frames are received without any MAC address filtering.
+                                                 */
+#define CMD_CFG_WAN_MODE            0x00000008  /* 28 WAN_MODE WAN mode enable
+                                                 * 0 Configure MAC for LAN mode.
+                                                 * 1 Configure MAC for WAN mode.
+                                                 */
+#define CMD_CFG_RX_EN               0x00000002  /* 30 RX_EN MAC receive path enable
+                                                 * 0 MAC receive path is disabled
+                                                 * 1 MAC receive path is enabled.
+                                                 */
+#define CMD_CFG_TX_EN               0x00000001  /* 31 TX_EN MAC transmit path enable
+                                                 * 0 MAC transmit path is disabled
+                                                 * 1 MAC transmit path is enabled.
+                                                 */
+
+/* Hashtable Control Register (HASHTABLE_CTRL) */
+#define HASH_CTRL_MCAST_SHIFT       23
+
+#define HASH_CTRL_MCAST_RD          0x00000400  /* 22 MCAST_READ Entry Multicast frame reception for the hash entry.
+                                                 * 0 disabled
+                                                 * 1 enabled
+                                                 */
+#define HASH_CTRL_MCAST_EN          0x00000200  /* 22 MCAST_EN Multicast frame reception for the hash entry.
+                                                 * 0 disabled
+                                                 * 1 enabled
+                                                 */
+#define HASH_ADDR_MASK              0x000001ff  /* 2331 HASH_ADDR Hash table address code.
+                                                 */
+
+/* Transmit Inter-Packet Gap Length Register (TX_IPG_LENGTH) */
+#define TX_IPG_LENGTH_MASK          0x000003ff
+
+/* Interrupt Mask Register (IMASK) */
+#define IMASK_MDIO_SCAN_EVENTMDIO   0x00010000  /* MDIO_SCAN_EVENTMDIO scan event interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_MDIO_CMD_CMPL         0x00008000  /* 16 MDIO_CMD_CMPL MDIO command completion interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_REM_FAULT             0x00004000  /* 17 REM_FAULT Remote fault interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_LOC_FAULT             0x00002000  /* 18 LOC_FAULT Local fault interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_1TX_ECC_ER            0x00001000  /* 19 TX_ECC_ER Transmit frame ECC error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_TX_FIFO_UNFL          0x00000800  /* 20 TX_FIFO_UNFL Transmit FIFO underflow interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_TX_FIFO_OVFL          0x00000400  /* 21 TX_FIFO_OVFL Transmit FIFO overflow interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_TX_ER                 0x00000200  /* 22 TX_ER Transmit frame error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_FIFO_OVFL          0x00000100  /* 23 RX_FIFO_OVFL Receive FIFO overflow interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_ECC_ER             0x00000080  /* 24 RX_ECC_ER Receive frame ECC error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_JAB_FRM            0x00000040  /* 25 RX_JAB_FRM Receive jabber frame interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_OVRSZ_FRM          0x00000020  /* 26 RX_OVRSZ_FRM Receive oversized frame interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_RUNT_FRM           0x00000010  /* 27 RX_RUNT_FRM Receive runt frame interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_FRAG_FRM           0x00000008  /* 28 RX_FRAG_FRM Receive fragment frame interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_LEN_ER             0x00000004  /* 29 RX_LEN_ER Receive payload length error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_CRC_ER             0x00000002  /* 30 RX_CRC_ER Receive CRC error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+#define IMASK_RX_ALIGN_ER           0x00000001  /* 31 RX_ALIGN_ER Receive alignment error interrupt mask.
+                                                 * 0 masked
+                                                 * 1 enabled
+                                                 */
+
+#ifdef TBD
+#define IEVENT_MDIO_SCAN_EVENTMDIO  IMASK_MDIO_SCAN_EVENTMDIO
+#define IEVENT_MDIO_CMD_CMPL        IMASK_MDIO_CMD_CMPL
+#define IEVENT_REM_FAULT            IMASK_REM_FAULT
+#define IEVENT_LOC_FAULT            IMASK_LOC_FAULT
+#define IEVENT_TX_ECC_ER            IMASK_1TX_ECC_ER
+#define IEVENT_TX_FIFO_UNFL         IMASK_TX_FIFO_UNFL
+#define IEVENT_TX_FIFO_OVFL         IMASK_TX_FIFO_OVFL
+#define IEVENT_TX_ER                IMASK_TX_ER
+#define IEVENT_RX_FIFO_OVFL         IMASK_RX_FIFO_OVFL
+#define IEVENT_RX_ECC_ER            IMASK_RX_ECC_ER
+#define IEVENT_RX_JAB_FRM           IMASK_RX_JAB_FRM
+#define IEVENT_RX_OVRSZ_FRM         IMASK_RX_OVRSZ_FRM
+#define IEVENT_RX_RUNT_FRM          IMASK_RX_RUNT_FRM
+#define IEVENT_RX_FRAG_FRM          IMASK_RX_FRAG_FRM
+#define IEVENT_RX_LEN_ER            IMASK_RX_LEN_ER
+#define IEVENT_RX_CRC_ER            IMASK_RX_CRC_ER
+#define IEVENT_RX_ALIGN_ER          IMASK_RX_ALIGN_ER
+#endif
+
+
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+
+/*
+ * 10G memory map
+ */
+typedef _Packed struct {
+/* 10Ge General Control and Status */
+    volatile uint32_t   tgec_id;            /* 0x000 10GEC_IDController ID register */
+    volatile uint32_t   scratch;            /* 0x004  */
+    volatile uint32_t   cmd_conf_ctrl;      /* 0x008 COMMAND_CONFIGControl and configuration register */
+    volatile uint32_t   mac_addr_0;         /* 0x00C MAC_ADDR_0Lower 32 bits of the first 48-bit MAC address */
+    volatile uint32_t   mac_addr_1;         /* 0x010 MAC_ADDR_1Upper 16 bits of the first 48-bit MAC address */
+    volatile uint32_t   maxfrm;             /* 0x014 MAXFRMMaximum frame length register */
+    volatile uint32_t   pause_quant;        /* 0x018 PAUSE_QUANTPause quanta register */
+    volatile uint32_t   rx_fifo_sections;   /* 0x01c  */
+    volatile uint32_t   tx_fifo_sections;   /* 0x020  */
+    volatile uint32_t   rx_fifo_almost_f_e; /* 0x024  */
+    volatile uint32_t   tx_fifo_almost_f_e; /* 0x028  */
+    volatile uint32_t   hashtable_ctrl;     /* 0x02C HASHTABLE_CTRLHash table control register */
+    volatile uint32_t   mdio_cfg_status;    /* 0x030  */
+    volatile uint32_t   mdio_command;       /* 0x034  */
+    volatile uint32_t   mdio_data;          /* 0x038  */
+    volatile uint32_t   mdio_regaddr;       /* 0x03c  */
+    volatile uint32_t   status;             /* 0x040  */
+    volatile uint32_t   tx_ipg_len;         /* 0x044 TX_IPG_LENGTHTransmitter inter-packet-gap register */
+    volatile uint32_t   mac_addr_2;         /* 0x048 MAC_ADDR_2Lower 32 bits of the second 48-bit MAC address */
+    volatile uint32_t   mac_addr_3;         /* 0x04C MAC_ADDR_3Upper 16 bits of the second 48-bit MAC address */
+    volatile uint32_t   rx_fifo_ptr_rd;     /* 0x050  */
+    volatile uint32_t   rx_fifo_ptr_wr;     /* 0x054  */
+    volatile uint32_t   tx_fifo_ptr_rd;     /* 0x058  */
+    volatile uint32_t   tx_fifo_ptr_wr;     /* 0x05c  */
+    volatile uint32_t   imask;              /* 0x060 IMASKInterrupt mask register */
+    volatile uint32_t   ievent;             /* 0x064 IEVENTInterrupt event register */
+    volatile uint32_t   udp_port;           /* 0x068 Defines a UDP Port number. When an UDP/IP frame is received with a matching UDP destination port, the receive status indication pin ff_rx_ts_frm will be asserted.*/
+    volatile uint32_t   type_1588v2;        /* 0x06c Type field for 1588v2 layer 2 frames. IEEE1588 defines the type 0x88f7 for 1588 frames. */
+    volatile uint32_t   TENGEC_RESERVED4[4];
+/*10Ge Statistics Counter */
+    volatile uint64_t   TFRM;        /* 80 aFramesTransmittedOK */
+    volatile uint64_t   RFRM;        /* 88 aFramesReceivedOK */
+    volatile uint64_t   RFCS;        /* 90 aFrameCheckSequenceErrors */
+    volatile uint64_t   RALN;        /* 98 aAlignmentErrors */
+    volatile uint64_t   TXPF;        /* A0 aPAUSEMACCtrlFramesTransmitted */
+    volatile uint64_t   RXPF;        /* A8 aPAUSEMACCtrlFramesReceived */
+    volatile uint64_t   RLONG;       /* B0 aFrameTooLongErrors */
+    volatile uint64_t   RFLR;        /* B8 aInRangeLengthErrors */
+    volatile uint64_t   TVLAN;       /* C0 VLANTransmittedOK */
+    volatile uint64_t   RVLAN;       /* C8 VLANReceivedOK */
+    volatile uint64_t   TOCT;        /* D0 ifOutOctets */
+    volatile uint64_t   ROCT;        /* D8 ifInOctets */
+    volatile uint64_t   RUCA;        /* E0 ifInUcastPkts */
+    volatile uint64_t   RMCA;        /* E8 ifInMulticastPkts */
+    volatile uint64_t   RBCA;        /* F0 ifInBroadcastPkts */
+    volatile uint64_t   TERR;        /* F8 ifOutErrors */
+    volatile uint32_t   TENGEC_RESERVED6[2];
+    volatile uint64_t   TUCA;        /* 108 ifOutUcastPkts */
+    volatile uint64_t   TMCA;        /* 110 ifOutMulticastPkts */
+    volatile uint64_t   TBCA;        /* 118 ifOutBroadcastPkts */
+    volatile uint64_t   RDRP;        /* 120 etherStatsDropEvents */
+    volatile uint64_t   REOCT;       /* 128 etherStatsOctets */
+    volatile uint64_t   RPKT;        /* 130 etherStatsPkts */
+    volatile uint64_t   TRUND;       /* 138 etherStatsUndersizePkts */
+    volatile uint64_t   R64;         /* 140 etherStatsPkts64Octets */
+    volatile uint64_t   R127;        /* 148 etherStatsPkts65to127Octets */
+    volatile uint64_t   R255;        /* 150 etherStatsPkts128to255Octets */
+    volatile uint64_t   R511;        /* 158 etherStatsPkts256to511Octets */
+    volatile uint64_t   R1023;       /* 160 etherStatsPkts512to1023Octets */
+    volatile uint64_t   R1518;       /* 168 etherStatsPkts1024to1518Octets */
+    volatile uint64_t   R1519X;      /* 170 etherStatsPkts1519toX */
+    volatile uint64_t   TROVR;       /* 178 etherStatsOversizePkts */
+    volatile uint64_t   TRJBR;       /* 180 etherStatsJabbers */
+    volatile uint64_t   TRFRG;       /* 188 etherStatsFragments */
+    volatile uint64_t   RERR;        /* 190 ifInErrors */
+} _PackedType t_TgecMemMap;
+
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
+
+typedef struct {
+    bool wanModeEnable;             /* WAN Mode Enable. Sets WAN mode (1) or LAN mode (0, default) of operation. */
+    bool promiscuousModeEnable;     /* Enables MAC promiscuous operation. When set to '1', all frames are received without any MAC address filtering, when set to '0' (Reset value) Unicast Frames with a destination address not matching the Core MAC Address (MAC Address programmed in Registers MAC_ADDR_0 and MAC_ADDR_1 or the MAC address programmed in Registers MAC_ADDR_2 and MAC_ADDR_3 ) are rejected. */
+    bool padRemovalEnable;          /* Enable Frame Padding Removal in receive path. If set to '1', padding is removed before the frame is conveyed to the MAC Client application. If set to '0' (Reset value) no padding is removed on receive by the MAC. */
+    bool crcForwardEnable;          /* Terminate / Forward Received CRC. If set to '1' the CRC field of received frames is forwarded with the frame to the user application. If set to '1' (Reset value) the CRC field is stripped from the frame. */
+    bool pauseForwardEnable;        /* Terminate / Forward Pause Frames. If set to '1' pause frames are forwarded to the user application. When set to '0' (Reset value) pause frames are terminated and discarded within the MAC. */
+    bool pauseIgnore;               /* Ignore Pause Frame Quanta. If set to '1' received pause frames are ignored by the MAC. When set to '0' (Reset value) the transmit process is stopped for the amount of time specified in the pause quanta received within a pause frame. */
+    bool txAddrInsEnable;           /* Set Source MAC Address on Transmit.
+                                        If set to '1' the MAC overwrites the source MAC address received from the Client Interface with one of the MAC addresses (Refer to section 10.4)
+                                        If set to '0' (Reset value), the source MAC address from the Client Interface is transmitted unmodified to the line. */
+    bool loopbackEnable;            /* PHY Interface Loopback. When set to '1', the signal loop_ena is set to '1', when set to '0' (Reset value) the signal loop_ena is set to '0'. */
+    bool cmdFrameEnable;            /* Enables reception of all command frames. When set to '1' all Command Frames are accepted, when set to '0' (Reset Value) only Pause Frames are accepted and all other Command Frames are rejected. */
+    bool rxErrorDiscard;            /* Receive Errored Frame Discard Enable. When set to 1, any frame received with an error is discarded in the Core and not forwarded to the Client interface. When set to 0 (Reset value), errored Frames are forwarded to the Client interface with ff_rx_err asserted. */
+    bool phyTxenaOn;                /* PHY Transmit Enable. When set to '1', the signal phy_txena is set to '1', when set to '0' (Reset value) the signal phy_txena is set to '0' */
+    bool sendIdleEnable;            /* Force Idle Generation. When set to '1', the MAC permanently sends XGMII Idle sequences even when faults are received. */
+    bool noLengthCheckEnable;       /* Payload Length Check Disable. When set to 0 (Reset value), the Core checks the frame's payload length with the Frame Length/Type field, when set to 1, the payload length check is disabled. */
+    bool lgthCheckNostdr;           /* The Core interprets the Length/Type field differently depending on the value of this Bit */
+    bool timeStampEnable;           /* This bit selects between enabling and disabling the IEEE 1588 functionality.
+                                        1: IEEE 1588 is enabled.
+                                        0: IEEE 1588 is disabled. */
+    bool rxSfdAny;                  /* Enables, when set, that any character is allowed at the SFD position of the preamble and the frame will be accepted.
+                                        If cleared (default) the frame is accepted only if the 8th byte of the preamble contains the SFD value 0xd5. If another value is received, the frame is discarded and the alignment error counter increments. */
+    bool rxPblFwd;                  /* Receive Preamble Forwarding (custom preamble).
+                                        If set, the first word (ff_rx_sop) of every received frame contains the preamble of the frame. The frame data starts with the 2nd word from the FIFO.
+                                        If the bit is cleared (default) the preamble is removed from the frame before it is written into the receive FIFO. */
+    bool txPblFwd;                  /* Transmit Preamble Forwarding (custom preamble).
+                                        If set, the first word written into the TX FIFO is considered as frame preamble. The MAC will not add a preamble in front of the frame. Note that bits 7:0 of the preamble word will still be overwritten with the XGMII start character upon transmission.
+                                        If cleared (default) the MAC */
+    uint32_t txIpgLength;           /*Transmit Inter-Packet-Gap (IPG) value.
+                                      A 6-bit value: Depending on LAN or WAN mode of operation (see COMMAND_CONFIG, 19.2.1 page 91) the value has the following meaning:
+                                         LAN Mode: Number of octets in steps of 4. Valid values are 8, 12, 16, ... 100. DIC is fully supported (see 10.6.1 page 49) for any setting. A default of 12 (reset value) must be set to conform to IEEE802.3ae. Warning: When set to 8, PCS layers may not be able to perform clock rate compensation.
+                                         WAN Mode: Stretch factor. Valid values are 4..15. The stretch factor is calculated as (value+1)*8. A default of 12 (reset value) must be set to conform to IEEE 802.3ae (i.e. 13*8=104). A larger value shrinks the IPG (increasing bandwidth). */
+/*.. */
+    bool        statisticsEnable;
+    uint16_t    maxFrameLength;
+    bool        padAndCrcEnable;
+    bool        debugMode;
+    uint16_t    pauseTime;
+
+#if 0
+    uint32_t    imask;
+#endif
+
+} t_TgecDriverParam;
+
+typedef struct {
+    t_FmMacControllerDriver     fmMacControllerDriver;              /**< Upper Mac control block */
+    t_Handle                    h_App;                              /**< Handle to the upper layer application  */
+    t_TgecMemMap                *p_MemMap;                          /**< pointer to 10G memory mapped registers. */
+    t_TgecMiiAccessMemMap       *p_MiiMemMap;                       /**< pointer to MII memory mapped registers.          */
+    uint64_t                    addr;                               /**< MAC address of device; */
+    e_EnetMode                  enetMode;                           /**< Ethernet physical interface  */
+    t_FmMacExceptionCallback    *f_Exceptions;
+    bool                        indAddrRegUsed[TGEC_NUM_OF_PADDRS]; /**< Whether a particular individual address recognition register is being used */
+    uint64_t                    paddr[TGEC_NUM_OF_PADDRS];          /**< MAC address for particular individual address recognition register */
+    uint8_t                     numOfIndAddrInRegs;                 /**< Number of individual addresses in registers for this station. */
+    t_EthHash                   *p_MulticastAddrHash;               /**< pointer to driver's global address hash table  */
+    t_EthHash                   *p_UnicastAddrHash;                 /**< pointer to driver's individual address hash table  */
+    bool                        debugMode;
+    uint8_t                     macId;
+    t_TgecDriverParam           *p_TgecDriverParam;
+} t_Tgec;
+
+t_Error TGEC_MII_WritePhyReg(t_Handle h_Tgec, uint8_t phyAddr, uint8_t reg, uint16_t data);
+t_Error TGEC_MII_ReadPhyReg(t_Handle h_Tgec,  uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
+
+
+#endif /* __TGEC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
new file mode 100644
index 0000000..5ea63ff
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
@@ -0,0 +1,103 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "fm_mac.h"
+#include "tgec.h"
+#include "xx_ext.h"
+
+
+/*****************************************************************************/
+t_Error TGEC_MII_WritePhyReg(t_Handle h_Tgec,
+                        uint8_t     phyAddr,
+                        uint8_t     reg,
+                        uint16_t    data)
+{
+    t_Tgec                  *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMiiAccessMemMap   *p_MiiAccess;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MiiMemMap, E_INVALID_HANDLE);
+
+    p_MiiAccess = p_Tgec->p_MiiMemMap;
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg_status)) & MIIMIND_BUSY)
+        XX_UDelay (1);
+
+    WRITE_UINT32(p_MiiAccess->mdio_command, phyAddr);
+
+    WRITE_UINT32(p_MiiAccess->mdio_regaddr, reg);
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg_status)) & MIIMIND_BUSY)
+        XX_UDelay (1);
+
+    WRITE_UINT32(p_MiiAccess->mdio_data, data);
+
+    return E_OK;
+}
+
+
+/*****************************************************************************/
+t_Error TGEC_MII_ReadPhyReg(t_Handle h_Tgec,
+                   uint8_t  phyAddr,
+                   uint8_t  reg,
+                   uint16_t *p_Data)
+{
+    t_Tgec             *p_Tgec = (t_Tgec *)h_Tgec;
+    t_TgecMiiAccessMemMap   *p_MiiAccess;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MiiMemMap, E_INVALID_HANDLE);
+
+    p_MiiAccess = p_Tgec->p_MiiMemMap;
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg_status)) & MIIMIND_BUSY)
+        XX_UDelay (1);
+
+    WRITE_UINT32(p_MiiAccess->mdio_command, phyAddr);
+
+    WRITE_UINT32(p_MiiAccess->mdio_regaddr, reg);
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg_status)) & MIIMIND_BUSY)
+        XX_UDelay (1);
+
+    WRITE_UINT32(p_MiiAccess->mdio_command, (uint32_t)(phyAddr | MIIMCOM_READ_CYCLE));
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg_status)) & MIIMIND_BUSY)
+        XX_UDelay (1);
+
+    *p_Data =  (uint16_t)GET_UINT32(p_MiiAccess->mdio_data);
+
+    return E_OK;
+}
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
new file mode 100644
index 0000000..a7808c6
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
@@ -0,0 +1,60 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __MII_ACC_H
+#define __MII_ACC_H
+
+/* #define __ERR_MODULE__ MODULE_MII */
+
+/* MII  Management Command Register */
+#define MIIMCOM_READ_POST_INCREMENT 0x00004000
+#define MIIMCOM_READ_CYCLE          0x00008000
+#define MIIMCOM_SCAN_CYCLE          0x00000800
+#define MIIMCOM_PREAMBLE_DISABLE    0x00000400
+
+/* MII Management Indicator Register */
+#define MIIMIND_BUSY                0x00000001
+#define MIIMIND_READ_ERROR          0x00000002
+
+/*----------------------------------------------------*/
+/* MII Configuration Control Memory Map Registers     */
+/*----------------------------------------------------*/
+typedef _Packed struct t_TgecMiiAccessMemMap
+{
+    volatile uint32_t   mdio_cfg_status;    /* 0x030  */
+    volatile uint32_t   mdio_command;       /* 0x034  */
+    volatile uint32_t   mdio_data;          /* 0x038  */
+    volatile uint32_t   mdio_regaddr;       /* 0x03c  */
+} _PackedType t_TgecMiiAccessMemMap ;
+
+
+#endif /* __MII_ACC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Makefile b/drivers/net/dpa/NetCommSw/Peripherals/FM/Makefile
new file mode 100644
index 0000000..97f3472
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Makefile
@@ -0,0 +1,20 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+NCSW_FM_INC = $(srctree)/drivers/net/dpa/NetCommSw/Peripherals/FM/inc
+
+EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+
+
+obj-y		+= fsl-ncsw-PFM1.o
+
+fsl-ncsw-PFM1-objs	:=   fm.o fm_muram.o
+
+obj-y		+= MAC/
+obj-y		+= Pcd/
+obj-y		+= Port/
+obj-y		+= HC/
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile
new file mode 100644
index 0000000..9d05f1a
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile
@@ -0,0 +1,19 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+NCSW_FM_INC = $(srctree)/drivers/net/dpa/NetCommSw/Peripherals/FM/inc
+
+EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+
+obj-y		+= fsl-ncsw-Pcd.o
+
+fsl-ncsw-Pcd-objs	:=   fm_cc.o fm_kg.o fm_pcd.o fm_plcr.o fm_prs.o
+
+
+
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
new file mode 100644
index 0000000..0bd6330
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
@@ -0,0 +1,2967 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_cc.c
+
+ @Description   FM CC ...
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "debug_ext.h"
+
+#include "fm_pcd_ext.h"
+#include "fm_muram_ext.h"
+#include "fm_hc.h"
+
+#include "fm_pcd.h"
+
+
+t_Error FmPcdCcTreeTryLock(t_Handle h_FmPcdCcTree)
+{
+    TRY_LOCK_RET_ERR(((t_FmPcdCcTree *)h_FmPcdCcTree)->lock);
+    return E_OK;
+}
+void FmPcdCcTreeReleaseLock(t_Handle h_FmPcdCcTree)
+{
+    RELEASE_LOCK(((t_FmPcdCcTree *)h_FmPcdCcTree)->lock);
+}
+
+static void EnqueueAdditionalInfoToRelevantLst(t_List *p_CcNode, t_CcNodeInfo *p_CcInfo)
+{
+    uint32_t   intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    LIST_AddToTail(&p_CcInfo->h_Node, p_CcNode);
+    XX_RestoreAllIntr(intFlags);
+}
+
+static void CreateNodeInfo(t_List *p_List, uint32_t info)
+{
+        t_CcNodeInfo *p_CcInfo;
+
+        p_CcInfo = (t_CcNodeInfo *)XX_Malloc(sizeof(t_CcNodeInfo));
+        if(!p_CcInfo)
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+        memset(p_CcInfo, 0, sizeof(t_CcNodeInfo));
+        INIT_LIST(&p_CcInfo->h_Node);
+        p_CcInfo->nextCcNodeInfo = (uint32_t)info;
+        EnqueueAdditionalInfoToRelevantLst(p_List, p_CcInfo);
+}
+
+static t_CcNodeInfo * FindNodeInfoAccIndex(t_List *p_List, uint16_t indx)
+{
+    t_CcNodeInfo   *p_CcNodeInfo = NULL;
+    t_List      *p_Pos;
+
+    LIST_FOR_EACH(p_Pos, p_List)
+    {
+        p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+        if((p_CcNodeInfo->nextCcNodeInfo >> 16) == indx)
+            return   p_CcNodeInfo;
+    }
+    return NULL;
+}
+
+static t_CcNodeInfo * FindNodeInfoAccId(t_List *p_List, uint16_t indx)
+{
+    t_CcNodeInfo   *p_CcNodeInfo = NULL;
+    t_List      *p_Pos;
+
+    LIST_FOR_EACH(p_Pos, p_List)
+    {
+        p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+        if(((uint16_t)p_CcNodeInfo->nextCcNodeInfo) == indx)
+            return   p_CcNodeInfo;
+    }
+    return NULL;
+}
+
+static t_CcNodeInfo * DequeueAdditionalInfoFromRelevantLst(t_List *p_List)
+{
+    t_CcNodeInfo   *p_CcNodeInfo = NULL;
+    uint32_t        intFlags;
+
+    intFlags = XX_DisableAllIntr();
+    if (!LIST_IsEmpty(p_List))
+    {
+        p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_List->p_Next);
+        LIST_DelAndInit(&p_CcNodeInfo->h_Node);
+    }
+    XX_RestoreAllIntr(intFlags);
+    return p_CcNodeInfo;
+}
+
+static void ReleaseLst(t_List *p_List)
+{
+    t_CcNodeInfo   *p_CcNodeInfo = NULL;
+
+    if(!LIST_IsEmpty(p_List))
+    {
+        p_CcNodeInfo = DequeueAdditionalInfoFromRelevantLst(p_List);
+        while (p_CcNodeInfo)
+        {
+            XX_Free(p_CcNodeInfo);
+            p_CcNodeInfo = DequeueAdditionalInfoFromRelevantLst(p_List);
+        }
+    }
+    LIST_DelAndInit(p_List);
+}
+
+static void ReleaseNodeHandler(t_FmPcdCcNode *p_FmPcdCcNode, t_FmPcdCc *p_FmPcdCc)
+{
+
+    if(p_FmPcdCcNode)
+    {
+            if(p_FmPcdCcNode->p_GlblMask)
+            {
+                XX_Free(p_FmPcdCcNode->p_GlblMask);
+                p_FmPcdCcNode->p_GlblMask = NULL;
+            }
+            if(p_FmPcdCcNode->h_KeysMatchTable)
+            {
+                FM_MURAM_FreeMem(p_FmPcdCc->h_FmMuram,p_FmPcdCcNode->h_KeysMatchTable);
+                p_FmPcdCcNode->h_KeysMatchTable = NULL;
+            }
+            if(p_FmPcdCcNode->h_AdTable)
+            {
+                FM_MURAM_FreeMem(p_FmPcdCc->h_FmMuram,p_FmPcdCcNode->h_AdTable);
+                p_FmPcdCcNode->h_AdTable = NULL;
+            }
+
+            ReleaseLst(&p_FmPcdCcNode->ccNextNodesLst);
+            ReleaseLst(&p_FmPcdCcNode->ccPrevNodesLst);
+            ReleaseLst(&p_FmPcdCcNode->ccTreeIdLst);
+            ReleaseLst(&p_FmPcdCcNode->ccTreesLst);
+
+
+            XX_Free(p_FmPcdCcNode);
+    }
+}
+
+static t_CcNodeInfo * FindNodeInfoAccIdAndAddToRetLst(t_List *p_List, uint16_t nodeId,  t_List *p_ReturnList)
+{
+    t_CcNodeInfo   *p_CcNodeInfo = NULL;
+    t_List      *p_Pos;
+
+    LIST_FOR_EACH(p_Pos, p_List)
+    {
+        p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+        if(((uint16_t)p_CcNodeInfo->nextCcNodeInfo) == nodeId)
+            CreateNodeInfo(p_ReturnList, p_CcNodeInfo->nextCcNodeInfo);
+    }
+    return NULL;
+}
+
+static void  UpdateNodeOwner(t_FmPcd  *p_FmPcd, uint16_t nodeId, bool add)
+{
+    ASSERT_COND(nodeId < MAX_NUM_OF_PCD_CC_NODES);
+    if(add)
+        p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[nodeId].owners++;
+    else
+    {
+        ASSERT_COND(p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[nodeId].owners);
+        p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[nodeId].owners--;
+    }
+}
+
+static t_Handle GetNodeHandler(t_FmPcd *p_FmPcd, uint16_t nodeId)
+{
+    ASSERT_COND(nodeId < MAX_NUM_OF_PCD_CC_NODES);
+    return p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode;
+
+}
+
+static void SetNodeHandler(t_Handle h_FmPcdCc, uint16_t nodeId, t_Handle p_FmPcdCcNode)
+{
+    t_FmPcdCc *p_FmPcdCc = (t_FmPcdCc*)h_FmPcdCc;
+
+    ASSERT_COND(!p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode);
+    p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode = p_FmPcdCcNode;
+}
+
+static t_Handle FmPcdCcGetTreeHandler(t_Handle h_FmPcd, uint8_t treeId)
+{
+
+    ASSERT_COND(treeId < MAX_NUM_OF_PCD_CC_TREES);
+    return ((t_FmPcd*)h_FmPcd)->p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree;
+}
+
+static void SetTreeHandler(t_Handle h_FmPcdCc, uint8_t treeId, t_Handle p_FmPcdCcTree)
+{
+    t_FmPcdCc *p_FmPcdCc = (t_FmPcdCc*)h_FmPcdCc;
+
+    ASSERT_COND(!p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree);
+    p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree = p_FmPcdCcTree;
+}
+
+
+static uint8_t GetTreeOwners(t_FmPcd *p_FmPcd, uint8_t treeId)
+{
+    ASSERT_COND(treeId < MAX_NUM_OF_PCD_CC_TREES);
+    return p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[treeId].owners;
+}
+
+static uint8_t GetNodeOwners(t_FmPcd *p_FmPcd, uint16_t nodeId)
+{
+    ASSERT_COND(nodeId < MAX_NUM_OF_PCD_CC_NODES);
+    return p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[nodeId].owners;
+}
+
+
+static t_Error OccupyNodeId(t_FmPcd *p_FmPcd, uint16_t *nodeId)
+{
+    uint16_t i = 0;
+
+    TRY_LOCK_RET_ERR(p_FmPcd->lock);
+    for(i = 0; i < MAX_NUM_OF_PCD_CC_NODES; i++)
+    {
+        if(!p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[i].occupied && !p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[i].p_FmPcdCcNode)
+        {
+            *nodeId = i;
+            p_FmPcd->p_FmPcdCc->ccNodeArrayEntry[i].occupied = TRUE;
+            RELEASE_LOCK(p_FmPcd->lock)
+           return E_OK;
+        }
+
+    }
+    RELEASE_LOCK(p_FmPcd->lock)
+    RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("asked for more nodes in CC than MAX"))  ;
+}
+
+static t_Error OccupyTreeId(t_FmPcd *p_FmPcd, uint8_t *treeId)
+{
+    uint16_t i = 0;
+
+    TRY_LOCK_RET_ERR(p_FmPcd->lock);
+    for(i = 0; i < MAX_NUM_OF_PCD_CC_NODES; i++)
+    {
+        if(!p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[i].occupied && !p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[i].p_FmPcdCcTree)
+        {
+            *treeId = (uint8_t)i;
+            p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[i].occupied = TRUE;
+            RELEASE_LOCK(p_FmPcd->lock)
+           return E_OK;
+        }
+
+    }
+    RELEASE_LOCK(p_FmPcd->lock)
+    RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("asked for more nodes in CC than MAX"))  ;
+}
+
+
+
+static bool CcNodeIsValid(t_FmPcd *p_FmPcd, uint16_t nodeId)
+{
+    t_FmPcdCc *p_FmPcdCc = p_FmPcd->p_FmPcdCc;
+
+    ASSERT_COND(nodeId < MAX_NUM_OF_PCD_CC_NODES);
+
+    if(!p_FmPcdCc->ccNodeArrayEntry[nodeId].occupied ||
+        !p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode)
+        return FALSE;
+    else
+        return TRUE;
+}
+
+static void  GetCcExtractKeySize(uint8_t parseCodeRealSize, uint8_t *parseCodeCcSize)
+{
+    if((parseCodeRealSize > 0) && (parseCodeRealSize < 2))
+        *parseCodeCcSize = 1;
+    else if(parseCodeRealSize == 2)
+        *parseCodeCcSize = 2;
+    else if((parseCodeRealSize > 2)    && (parseCodeRealSize <= 4))
+        *parseCodeCcSize = 4;
+    else if((parseCodeRealSize > 4)    && (parseCodeRealSize <= 8))
+        *parseCodeCcSize = 8;
+    else if((parseCodeRealSize > 8)    && (parseCodeRealSize <= 16))
+        *parseCodeCcSize = 16;
+    else if((parseCodeRealSize  > 16)  && (parseCodeRealSize <= 24))
+        *parseCodeCcSize = 24;
+    else if((parseCodeRealSize  > 24)  && (parseCodeRealSize <= 32))
+        *parseCodeCcSize = 32;
+    else if((parseCodeRealSize  > 32)  && (parseCodeRealSize <= 40))
+        *parseCodeCcSize = 40;
+    else if((parseCodeRealSize  > 40)  && (parseCodeRealSize <= 48))
+        *parseCodeCcSize = 48;
+    else if((parseCodeRealSize  > 48)  && (parseCodeRealSize <= 56))
+        *parseCodeCcSize = 56;
+    else
+        *parseCodeCcSize = 0;
+}
+
+static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t *parseCodeRealSize)
+{
+    switch(hdr)
+    {
+        case (HEADER_TYPE_ETH):
+            switch(field.eth)
+            {
+                case(NET_HEADER_FIELD_ETH_DA):
+                    *parseCodeRealSize = 6;
+                    break;
+                case(NET_HEADER_FIELD_ETH_SA):
+                    *parseCodeRealSize = 6;
+                    break;
+                case(NET_HEADER_FIELD_ETH_TYPE):
+                    *parseCodeRealSize = 2;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported1"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+        break;
+        case(HEADER_TYPE_PPPoE):
+            switch(field.pppoe)
+            {
+                case(NET_HEADER_FIELD_PPPoE_PID):
+                    *parseCodeRealSize = 2;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported1"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+        break;
+        case (HEADER_TYPE_VLAN):
+            switch(field.vlan)
+            {
+               case(NET_HEADER_FIELD_VLAN_TCI):
+                    *parseCodeRealSize = 2;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported2"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+        break;
+        case (HEADER_TYPE_MPLS):
+            switch(field.mpls)
+            {
+                case(NET_HEADER_FIELD_MPLS_LABEL_STACK):
+                    *parseCodeRealSize = 4;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported3"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+        break;
+        case (HEADER_TYPE_IPv4):
+            switch(field.ipv4)
+            {
+                case(NET_HEADER_FIELD_IPv4_DST_IP):
+                case(NET_HEADER_FIELD_IPv4_SRC_IP):
+                    *parseCodeRealSize = 4;
+                    break;
+                case(NET_HEADER_FIELD_IPv4_TOS):
+                case(NET_HEADER_FIELD_IPv4_PROTO):
+                    *parseCodeRealSize = 1;
+                    break;
+                case(NET_HEADER_FIELD_IPv4_DST_IP | NET_HEADER_FIELD_IPv4_SRC_IP):
+                    *parseCodeRealSize = 8;
+                    break;
+                case(NET_HEADER_FIELD_IPv4_TTL):
+                    *parseCodeRealSize = 1;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported4"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+        break;
+        case (HEADER_TYPE_IPv6):
+            switch(field.ipv6)
+            {
+                case(NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
+                   *parseCodeRealSize = 4;
+                    break;
+                case(NET_HEADER_FIELD_IPv6_NEXT_HDR):
+                case(NET_HEADER_FIELD_IPv6_HOP_LIMIT):
+                   *parseCodeRealSize = 1;
+                    break;
+                case(NET_HEADER_FIELD_IPv6_DST_IP):
+                case(NET_HEADER_FIELD_IPv6_SRC_IP):
+                   *parseCodeRealSize = 16;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported5"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+        break;
+        case (HEADER_TYPE_GRE):
+            switch(field.gre)
+            {
+                case(NET_HEADER_FIELD_GRE_TYPE):
+                   *parseCodeRealSize = 2;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported6"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+        break;
+        case (HEADER_TYPE_MINENCAP):
+            switch(field.minencap)
+            {
+                case(NET_HEADER_FIELD_MINENCAP_TYPE):
+                   *parseCodeRealSize = 1;
+                    break;
+                case(NET_HEADER_FIELD_MINENCAP_DST_IP):
+                 case(NET_HEADER_FIELD_MINENCAP_SRC_IP):
+                  *parseCodeRealSize = 4;
+                    break;
+                 case(NET_HEADER_FIELD_MINENCAP_SRC_IP | NET_HEADER_FIELD_MINENCAP_DST_IP):
+                  *parseCodeRealSize = 8;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported7"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+        break;
+        case (HEADER_TYPE_TCP):
+            switch(field.tcp)
+            {
+                case(NET_HEADER_FIELD_TCP_PORT_SRC):
+                case(NET_HEADER_FIELD_TCP_PORT_DST):
+                   *parseCodeRealSize = 2;
+                    break;
+                 case(NET_HEADER_FIELD_TCP_PORT_SRC | NET_HEADER_FIELD_TCP_PORT_DST):
+                  *parseCodeRealSize = 4;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported8"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+        break;
+        case (HEADER_TYPE_UDP):
+            switch(field.udp)
+            {
+                case(NET_HEADER_FIELD_UDP_PORT_SRC):
+                case(NET_HEADER_FIELD_UDP_PORT_DST):
+                   *parseCodeRealSize = 2;
+                    break;
+                 case(NET_HEADER_FIELD_UDP_PORT_SRC | NET_HEADER_FIELD_UDP_PORT_DST):
+                  *parseCodeRealSize = 4;
+                    break;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported9"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+            }
+            break;
+       default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported10"));
+                    *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                    break;
+    }
+}
+
+
+
+static void ReleaseNode(t_FmPcdCc *p_FmPcdCc, uint16_t nodeId)
+{
+    t_FmPcdCcNode *p_FmPcdCcNode;
+
+    if(p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode)
+    {
+            p_FmPcdCcNode = (t_FmPcdCcNode *)p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode;
+            ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+            p_FmPcdCc->ccNodeArrayEntry[nodeId].p_FmPcdCcNode = NULL;
+    }
+    p_FmPcdCc->ccNodeArrayEntry[nodeId].occupied = FALSE;
+}
+
+static void ReleaseTreeHandler(t_FmPcdCcTree *p_FmPcdTreeNode, t_FmPcdCc *p_FmPcdCc)
+{
+
+    if(p_FmPcdTreeNode)
+    {
+        if(p_FmPcdTreeNode->p_CcBaseTree)
+        {
+            FM_MURAM_FreeMem(p_FmPcdCc->h_FmMuram,p_FmPcdTreeNode->p_CcBaseTree);
+            p_FmPcdTreeNode->p_CcBaseTree = NULL;
+        }
+
+
+        ReleaseLst(&p_FmPcdTreeNode->ccNextNodesLst);
+        ReleaseLst(&p_FmPcdTreeNode->fmPortsLst);
+
+        XX_Free(p_FmPcdTreeNode);
+        }
+}
+
+static void ReleaseTree(t_FmPcdCc *p_FmPcdCc, uint8_t treeId)
+{
+    t_FmPcdCcTree *p_FmPcdCcTree;
+
+    if(p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree)
+    {
+            p_FmPcdCcTree = p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree;
+            ReleaseTreeHandler(p_FmPcdCcTree,p_FmPcdCc);
+            p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree = NULL;
+    }
+    p_FmPcdCc->ccTreeArrayEntry[treeId].occupied = FALSE;
+}
+
+
+static t_Error ValidateNextEngineParams(t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_NextEngineParamsInfo *p_NextEngineParamsInfo)
+{
+    uint16_t                    absoluteProfileId;
+    t_Error                     err;
+    uint8_t                     relativeSchemeId;
+
+    p_NextEngineParamsInfo->fmPcdEngine = e_FM_PCD_DONE;
+
+     switch(p_FmPcdCcNextEngineParams->nextEngine)
+    {
+        case(e_FM_PCD_DONE):
+            if(p_FmPcdCcNextEngineParams->params.enqueueParams.ctrlFlow &&
+               !p_FmPcdCcNextEngineParams->params.enqueueParams.fqidForCtrlFlow)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("not defined fqid for control flow for BMI next engine "));
+            if(p_FmPcdCcNextEngineParams->params.enqueueParams.fqidForCtrlFlow & ~0x00FFFFFF)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidForCtrlFlow must be between 1 and 2^24-1"));
+            p_NextEngineParamsInfo->fmPcdEngine = e_FM_PCD_DONE;
+            break;
+        case(e_FM_PCD_KG):
+            relativeSchemeId = FmPcdKgGetRelativeSchemeId(h_FmPcd, (uint8_t)(CAST_POINTER_TO_UINT32(p_FmPcdCcNextEngineParams->params.kgParams.h_DirectScheme)-1));
+            if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+                RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+
+            if(!FmPcdKgIsSchemeValidSw(h_FmPcd, relativeSchemeId))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("not valid schemeIndex in KG next engine param"));
+            if(!KgIsSchemeAlwaysDirect(h_FmPcd, relativeSchemeId))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("CC Node may point only to a scheme that is always direct."));
+            p_NextEngineParamsInfo->fmPcdEngine = e_FM_PCD_KG;
+            break;
+        case(e_FM_PCD_PLCR):
+            if(p_FmPcdCcNextEngineParams->params.plcrParams.ctrlFlow)
+            {
+                /* if private policer profile, it may be uninitialized yet, therefor no checks are done at this stage */
+                if(p_FmPcdCcNextEngineParams->params.plcrParams.sharedProfile)
+                {
+                    err = FmPcdPlcrGetAbsoluteProfileId(h_FmPcd,e_FM_PCD_PLCR_SHARED,NULL,p_FmPcdCcNextEngineParams->params.plcrParams.relativeProfileIdForCtrlFlow, &absoluteProfileId);
+                    if(err)
+                        RETURN_ERROR(MAJOR, err, ("Shared profile offset is out of range"));
+                    if(!FmPcdPlcrIsProfileValid(h_FmPcd, absoluteProfileId))
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid profile"));
+                    if(p_FmPcdCcNextEngineParams->params.plcrParams.fqidEnqForCtrlFlow &&  (!p_FmPcdCcNextEngineParams->params.plcrParams.fqidForCtrlFlowForEnqueueAfterPlcr ||
+                            p_FmPcdCcNextEngineParams->params.plcrParams.fqidForCtrlFlowForEnqueueAfterPlcr & ~0x00FFFFFF))
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("fqidForCtrlFlowForEnqueueAfterPlcr  must be between 1 and 2^24-1"));
+                }
+                else
+                {
+                    p_NextEngineParamsInfo->fmPcdEngine = e_FM_PCD_PLCR;
+                    p_NextEngineParamsInfo->additionalInfo = p_FmPcdCcNextEngineParams->params.plcrParams.relativeProfileIdForCtrlFlow;
+                }
+            }
+            break;
+        case(e_FM_PCD_CC):
+            if(!p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)
+                RETURN_ERROR(MAJOR, E_NULL_POINTER, ("handler to next Node is NULL"));
+            if (!CcNodeIsValid((t_FmPcd*)h_FmPcd,
+                               (uint16_t)((t_FmPcdCcNode*)(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode))->nodeId))
+                RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("not valid nodeId in CC next engine param" ));
+            p_NextEngineParamsInfo->fmPcdEngine = e_FM_PCD_CC;
+            p_NextEngineParamsInfo->additionalInfo  =
+                (uint16_t)((t_FmPcdCcNode*)(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode))->nodeId;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine is not correct"));
+    }
+
+    return E_OK;
+}
+
+
+
+
+
+static uint8_t GetGenParseCode(e_FmPcdExtractFrom src, uint32_t offset, bool glblMask, uint8_t *parseArrayOffset)
+{
+    switch(src)
+    {
+        case(e_FM_PCD_EXTRACT_FROM_FRAME_START):
+            if(glblMask)
+                return CC_PC_GENERIC_WITH_MASK ;
+            else
+              return CC_PC_GENERIC_WITHOUT_MASK;
+            break;
+        case(e_FM_PCD_KG_EXTRACT_FROM_CURR_END_OF_PARSE):
+            *parseArrayOffset = CC_PC_PR_NEXT_HEADER_OFFSET;
+            if(offset)
+                return CC_PR_OFFSET;
+            else
+                return CC_PR_WITHOUT_OFFSET;
+        break;
+        default:
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 'extract from' src"));
+            return CC_PC_ILLEGAL;
+    }
+}
+
+
+static uint8_t GetFullFieldParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex index, t_FmPcdFields field)
+{
+
+      switch(hdr)
+        {
+            case(HEADER_TYPE_NONE):
+                ASSERT_COND(FALSE);
+                return CC_PC_ILLEGAL;
+            break;
+
+       case(HEADER_TYPE_ETH):
+                switch(field.eth)
+                {
+                    case(NET_HEADER_FIELD_ETH_DA):
+                        return CC_PC_FF_MACDST;
+                    case(NET_HEADER_FIELD_ETH_SA):
+                         return CC_PC_FF_MACSRC;
+                    case(NET_HEADER_FIELD_ETH_TYPE):
+                         return CC_PC_FF_ETYPE;
+                    default:
+                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                        return CC_PC_ILLEGAL;
+                }
+                break;
+
+         case(HEADER_TYPE_VLAN):
+            switch(field.vlan)
+            {
+                case(NET_HEADER_FIELD_VLAN_TCI):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_TCI1;
+                    if(index == e_FM_PCD_HDR_INDEX_LAST)
+                        return CC_PC_FF_TCI2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+                default:
+                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                        return CC_PC_ILLEGAL;
+            }
+            break;
+
+        case(HEADER_TYPE_MPLS):
+            switch(field.mpls)
+            {
+                case(NET_HEADER_FIELD_MPLS_LABEL_STACK):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_MPLS1;
+                    if(index == e_FM_PCD_HDR_INDEX_LAST)
+                        return CC_PC_FF_MPLS_LAST;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS index"));
+                    return CC_PC_ILLEGAL;
+               default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+             }
+            break;
+
+        case(HEADER_TYPE_IPv4):
+            switch(field.ipv4)
+            {
+                case(NET_HEADER_FIELD_IPv4_DST_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV4DST1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV4DST2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv4_TOS):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV4IPTOS_TC1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV4IPTOS_TC2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv4_PROTO):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV4PTYPE1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV4PTYPE2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv4_SRC_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV4SRC1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV4SRC2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv4_SRC_IP | NET_HEADER_FIELD_IPv4_DST_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV4SRC1_IPV4DST1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV4SRC2_IPV4DST2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv4_TTL):
+                    return CC_PC_FF_IPV4TTL;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
+            break;
+        case(HEADER_TYPE_IPv6):
+             switch(field.ipv6)
+            {
+                case(NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv6_NEXT_HDR):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV6PTYPE1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV6PTYPE2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv6_DST_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV6DST1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV6DST2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv6_SRC_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return CC_PC_FF_IPV6SRC1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return CC_PC_FF_IPV6SRC2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return CC_PC_ILLEGAL;
+                case(NET_HEADER_FIELD_IPv6_HOP_LIMIT):
+                    return CC_PC_FF_IPV6HOP_LIMIT;
+                 default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
+            break;
+
+        case(HEADER_TYPE_GRE):
+            switch(field.gre)
+            {
+                case(NET_HEADER_FIELD_GRE_TYPE):
+                    return CC_PC_FF_GREPTYPE;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+           }
+        case(HEADER_TYPE_MINENCAP):
+            switch(field.minencap)
+            {
+                case(NET_HEADER_FIELD_MINENCAP_TYPE):
+                    return CC_PC_FF_MINENCAP_PTYPE;
+                case(NET_HEADER_FIELD_MINENCAP_DST_IP):
+                    return CC_PC_FF_MINENCAP_IPDST;
+                case(NET_HEADER_FIELD_MINENCAP_SRC_IP):
+                    return CC_PC_FF_MINENCAP_IPSRC;
+                case(NET_HEADER_FIELD_MINENCAP_SRC_IP | NET_HEADER_FIELD_MINENCAP_DST_IP):
+                    return CC_PC_FF_MINENCAP_IPSRC_IPDST;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+           }
+           break;
+        case(HEADER_TYPE_TCP):
+            switch(field.tcp)
+            {
+                case(NET_HEADER_FIELD_TCP_PORT_SRC):
+                    return CC_PC_FF_L4PSRC;
+                case(NET_HEADER_FIELD_TCP_PORT_DST):
+                    return CC_PC_FF_L4PDST;
+                case(NET_HEADER_FIELD_TCP_PORT_DST | NET_HEADER_FIELD_TCP_PORT_SRC):
+                    return CC_PC_FF_L4PSRC_L4PDST;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
+            break;
+        case(HEADER_TYPE_PPPoE):
+            switch(field.pppoe)
+            {
+                case(NET_HEADER_FIELD_PPPoE_PID):
+                    return CC_PC_FF_PPPPID;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
+            break;
+        case(HEADER_TYPE_UDP):
+            switch(field.udp)
+            {
+                case(NET_HEADER_FIELD_UDP_PORT_SRC):
+                    return CC_PC_FF_L4PSRC;
+                case(NET_HEADER_FIELD_UDP_PORT_DST):
+                    return CC_PC_FF_L4PDST;
+                case(NET_HEADER_FIELD_UDP_PORT_DST | NET_HEADER_FIELD_UDP_PORT_SRC):
+                    return CC_PC_FF_L4PSRC_L4PDST;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
+            break;
+         default:
+            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+            return CC_PC_ILLEGAL;
+
+    }
+}
+
+static uint8_t GetPrParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex hdrIndex, uint32_t offset, bool glblMask, uint8_t *parseArrayOffset)
+{
+
+ bool offsetRelevant = FALSE;
+
+    if(offset)
+        offsetRelevant = TRUE;
+
+    switch(hdr){
+        case(HEADER_TYPE_NONE):
+            ASSERT_COND(FALSE);
+            return CC_PC_ILLEGAL;
+        case(HEADER_TYPE_ETH):
+            *parseArrayOffset = (uint8_t)CC_PC_PR_ETH_OFFSET;
+            break;
+        case(HEADER_TYPE_USER_DEFINED_SHIM1):
+            if(offset || glblMask)
+                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM1_OFFSET;
+            else
+                return CC_PC_PR_SHIM1;
+            break;
+        case(HEADER_TYPE_USER_DEFINED_SHIM2):
+            if(offset || glblMask)
+                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM2_OFFSET;
+            else
+                return CC_PC_PR_SHIM2;
+            break;
+        case(HEADER_TYPE_USER_DEFINED_SHIM3):
+            if(offset || glblMask)
+                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM3_OFFSET;
+            else
+                return CC_PC_PR_SHIM3;
+            break;
+              break;
+      case(HEADER_TYPE_LLC_SNAP):
+            *parseArrayOffset = CC_PC_PR_USER_LLC_SNAP_OFFSET;
+            break;
+        case(HEADER_TYPE_PPPoE):
+            *parseArrayOffset = CC_PC_PR_PPPOE_OFFSET;
+            break;
+            case(HEADER_TYPE_MPLS):
+                 if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                        *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
+                else if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                        *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
+                else
+                {
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS header index"));
+                    return CC_PC_ILLEGAL;
+                }
+                break;
+            case(HEADER_TYPE_IPv4):
+            case(HEADER_TYPE_IPv6):
+              if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    *parseArrayOffset = CC_PC_PR_IP1_OFFSET;
+              else if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                    *parseArrayOffset = CC_PC_PR_IP_LAST_OFFSET;
+              else
+              {
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header index"));
+                return CC_PC_ILLEGAL;
+
+              }
+                break;
+            case(HEADER_TYPE_MINENCAP):
+                *parseArrayOffset = CC_PC_PR_MINENC_OFFSET;
+                break;
+            case(HEADER_TYPE_GRE):
+                *parseArrayOffset = CC_PC_PR_GRE_OFFSET;
+                break;
+            case(HEADER_TYPE_TCP):
+            case(HEADER_TYPE_UDP):
+            case(HEADER_TYPE_IPSEC_AH):
+            case(HEADER_TYPE_IPSEC_ESP):
+            case(HEADER_TYPE_DCCP):
+            case(HEADER_TYPE_SCTP):
+                *parseArrayOffset = CC_PC_PR_L4_OFFSET;
+                break;
+
+            default:
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header for this type of operation"));
+                return CC_PC_ILLEGAL;
+     }
+
+        if(offsetRelevant)
+            return CC_PR_OFFSET;
+        else
+            return CC_PR_WITHOUT_OFFSET;
+
+}
+
+static uint8_t GetFieldParseCode(e_NetHeaderType hdr, t_FmPcdFields field, uint32_t offset, uint8_t *parseArrayOffset, e_FmPcdHdrIndex hdrIndex)
+{
+
+ bool offsetRelevant = FALSE;
+
+    if(offset)
+        offsetRelevant = TRUE;
+
+    switch(hdr)
+    {
+        case(HEADER_TYPE_NONE):
+                ASSERT_COND(FALSE);
+        case(HEADER_TYPE_ETH):
+            switch(field.eth)
+            {
+                case(NET_HEADER_FIELD_ETH_TYPE):
+                    *parseArrayOffset = CC_PC_PR_ETYPE_LAST_OFFSET;
+                    break;
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                return CC_PC_ILLEGAL;
+            }
+            break;
+        case(HEADER_TYPE_VLAN):
+            switch(field.vlan)
+            {
+                case(NET_HEADER_FIELD_VLAN_TCI) :
+                    if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                        *parseArrayOffset = CC_PC_PR_VLAN1_OFFSET;
+                    else if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                        *parseArrayOffset = CC_PC_PR_VLAN2_OFFSET;
+                    break;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
+        break;
+        default:
+            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal header "));
+            return CC_PC_ILLEGAL;
+    }
+    if(offsetRelevant)
+        return CC_PR_OFFSET;
+    else
+        return CC_PR_WITHOUT_OFFSET;
+
+}
+
+static void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEngineParams *p_CcNextEngineParams)
+{
+    t_AdOfTypeResult                *p_AdResult = (t_AdOfTypeResult*)p_Ad;
+    uint32_t                        tmp = 0, tmpNia = 0;
+    uint16_t                        profileId;
+
+    switch(p_CcNextEngineParams->nextEngine)
+    {
+        case(e_FM_PCD_DONE):
+            if(p_CcNextEngineParams->params.enqueueParams.ctrlFlow)
+            {
+               tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
+               tmp |= p_CcNextEngineParams->params.enqueueParams.fqidForCtrlFlow;
+            }
+            else
+            {
+               tmp = FM_PCD_AD_RESULT_DATA_FLOW_TYPE;
+               tmp |= FM_PCD_AD_RESULT_PLCR_DIS;
+            }
+            tmpNia |= NIA_ENG_BMI |NIA_BMI_AC_ENQ_FRAME;
+            break;
+        case(e_FM_PCD_KG):
+            if(p_CcNextEngineParams->params.kgParams.ctrlFlow)
+                tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
+            else
+            {
+                tmp = FM_PCD_AD_RESULT_DATA_FLOW_TYPE;
+                tmp |= FM_PCD_AD_RESULT_PLCR_DIS;
+            }
+            tmpNia = NIA_KG_DIRECT;
+            tmpNia |= NIA_ENG_KG;
+            tmpNia |= (uint8_t)(CAST_POINTER_TO_UINT32(p_CcNextEngineParams->params.kgParams.h_DirectScheme)-1);
+        break;
+        case(e_FM_PCD_PLCR):
+            tmp = 0;
+            if(p_CcNextEngineParams->params.plcrParams.ctrlFlow)
+            {
+                tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
+
+                /* if private policer profile, it may be uninitialized yet, therefor no checks are done at this stage */
+                if(p_CcNextEngineParams->params.plcrParams.sharedProfile)
+                {
+                    tmpNia |= NIA_PLCR_ABSOLUTE;
+                    FmPcdPlcrGetAbsoluteProfileId((t_Handle)p_FmPcd,e_FM_PCD_PLCR_SHARED,NULL,p_CcNextEngineParams->params.plcrParams.relativeProfileIdForCtrlFlow, &profileId);
+                }
+                else
+                    profileId = p_CcNextEngineParams->params.plcrParams.relativeProfileIdForCtrlFlow;
+
+                if(p_CcNextEngineParams->params.plcrParams.fqidEnqForCtrlFlow)
+                    tmp |= p_CcNextEngineParams->params.plcrParams.fqidForCtrlFlowForEnqueueAfterPlcr;
+                WRITE_UINT32(p_AdResult->plcrProfile,(uint32_t)((uint32_t)profileId << FM_PCD_AD_PROFILEID_FOR_CNTRL_SHIFT));
+            }
+            else
+               tmp = FM_PCD_AD_RESULT_DATA_FLOW_TYPE;
+            tmpNia |= NIA_ENG_PLCR | p_CcNextEngineParams->params.plcrParams.relativeProfileIdForCtrlFlow;
+           break;
+        default:
+            return;
+    }
+
+    WRITE_UINT32(p_AdResult->fqid, tmp);
+    WRITE_UINT32(p_AdResult->nia, tmpNia);
+}
+
+static void FillAdOfTypeContLookup(t_Handle p_Ad,  t_Handle h_FmPcd, t_Handle p_FmPcdCcNode)
+{
+    t_FmPcdCcNode           *p_Node = (t_FmPcdCcNode *)p_FmPcdCcNode;
+    t_AdOfTypeContLookup    *p_AdContLookup = (t_AdOfTypeContLookup *)p_Ad;
+    uint32_t                tmpReg32;
+
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    tmpReg32 |= p_Node->sizeOfExtraction ? ((p_Node->sizeOfExtraction - 1) << 24) : 0;
+    tmpReg32 |= (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_Node->h_AdTable)) - (((t_FmPcd*)h_FmPcd)->p_FmPcdCc)->physicalMuramBase);
+    WRITE_UINT32(p_AdContLookup->ccAdBase, tmpReg32);
+
+    tmpReg32 = 0;
+    tmpReg32 |= p_Node->numOfKeys << 24;
+    tmpReg32 |= (p_Node->lclMask ? FM_PCD_AD_CONT_LOOKUP_LCL_MASK : 0);
+    tmpReg32 |= p_Node->h_KeysMatchTable ?
+                    (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_Node->h_KeysMatchTable)) - (((t_FmPcd*)h_FmPcd)->p_FmPcdCc)->physicalMuramBase) : 0;
+    WRITE_UINT32(p_AdContLookup->matchTblPtr, tmpReg32);
+
+    tmpReg32 = 0;
+    tmpReg32 |= p_Node->prsArrayOffset << 24;
+    tmpReg32 |= p_Node->offset << 16;
+    tmpReg32 |= p_Node->parseCode;
+    WRITE_UINT32(p_AdContLookup->pcAndOffsets, tmpReg32);
+
+    COPY_BLOCK((void*)&p_AdContLookup->gmask, p_Node->p_GlblMask, p_Node->glblMaskSize);
+}
+
+static void NextStepAd(t_Handle p_Ad, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_FmPcd *p_FmPcd)
+{
+    switch(p_FmPcdCcNextEngineParams->nextEngine)
+    {
+        case(e_FM_PCD_KG):
+        case(e_FM_PCD_PLCR):
+        case(e_FM_PCD_DONE):
+            FillAdOfTypeResult(p_Ad, p_FmPcd, p_FmPcdCcNextEngineParams);
+            break;
+        case(e_FM_PCD_CC):
+            FillAdOfTypeContLookup( p_Ad,
+                                   p_FmPcd,
+                                    p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode);
+            UpdateNodeOwner(p_FmPcd,
+                            (uint16_t)(((t_FmPcdCcNode *)(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode))->nodeId),
+                            TRUE);
+        break;
+        default:
+            return;
+    }
+}
+
+static t_Error ModifyCcCommon1(t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_Handle *h_OldPointer, t_Handle *h_NewPointer)
+{
+    t_FmPcdModifyCcAdditionalParams *p_CcOldModifyAdditionalParams;
+    t_FmPcdModifyCcAdditionalParams *p_CcNewModifyAdditionalParams;
+    t_Error                         err;
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_NextEngineParamsInfo          nextEngineParamsInfo;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_STATE);
+
+    err = ValidateNextEngineParams(h_FmPcd, p_FmPcdCcNextEngineParams, &nextEngineParamsInfo);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    p_CcOldModifyAdditionalParams =(t_FmPcdModifyCcAdditionalParams *)XX_Malloc(sizeof(t_FmPcdModifyCcAdditionalParams));
+    if(!p_CcOldModifyAdditionalParams)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
+    memset(p_CcOldModifyAdditionalParams, 0, sizeof(t_FmPcdModifyCcAdditionalParams));
+
+    p_CcNewModifyAdditionalParams =(t_FmPcdModifyCcAdditionalParams *)XX_Malloc(sizeof(t_FmPcdModifyCcAdditionalParams));
+    if(!p_CcNewModifyAdditionalParams)
+    {
+        XX_Free(p_CcOldModifyAdditionalParams);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
+    }
+    memset(p_CcNewModifyAdditionalParams, 0, sizeof(t_FmPcdModifyCcAdditionalParams));
+
+    p_CcNewModifyAdditionalParams->p_Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->p_FmPcdCc->h_FmMuram,
+                                         FM_PCD_CC_AD_ENTRY_SIZE,
+                                         FM_PCD_CC_AD_TABLE_ALIGN);
+
+    if(!p_CcNewModifyAdditionalParams->p_Ad)
+    {
+        XX_Free(p_CcOldModifyAdditionalParams);
+        XX_Free(p_CcNewModifyAdditionalParams);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+    }
+    WRITE_BLOCK((uint8_t *)p_CcNewModifyAdditionalParams->p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+
+    if(p_FmPcdCcNextEngineParams)
+        NextStepAd((t_Handle)p_CcNewModifyAdditionalParams->p_Ad,p_FmPcdCcNextEngineParams, p_FmPcd);
+
+    p_CcNewModifyAdditionalParams->fmPcdEngine      = nextEngineParamsInfo.fmPcdEngine;
+    if(p_CcNewModifyAdditionalParams->fmPcdEngine == e_FM_PCD_CC)
+        p_CcNewModifyAdditionalParams->myInfo = nextEngineParamsInfo.additionalInfo;
+    else
+        p_CcNewModifyAdditionalParams->myInfo = 0xffffffff;
+
+    *h_OldPointer = p_CcOldModifyAdditionalParams;
+    *h_NewPointer = p_CcNewModifyAdditionalParams;
+
+    return E_OK;
+}
+
+static void ReleaseCommonModifyKey(t_Handle h_FmMuram, t_FmPcdModifyCcAdditionalParams *p_CcModifyAdditionalParams)
+{
+   if(p_CcModifyAdditionalParams->adAllocated)
+        FM_MURAM_FreeMem(h_FmMuram, p_CcModifyAdditionalParams->p_Ad);
+   XX_Free(p_CcModifyAdditionalParams);
+}
+
+static t_Error ModifyCcKeyCommon(t_FmPcd *p_FmPcd, t_Handle *h_Pointer,bool allocateAd)
+{
+    t_FmPcdModifyCcAdditionalParams *p_ModifyAdditionalParams;
+
+    p_ModifyAdditionalParams =(t_FmPcdModifyCcAdditionalParams *)XX_Malloc(sizeof(t_FmPcdModifyCcAdditionalParams));
+    if(!p_ModifyAdditionalParams)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
+    memset(p_ModifyAdditionalParams, 0, sizeof(t_FmPcdModifyCcAdditionalParams));
+    if(allocateAd)
+    {
+        p_ModifyAdditionalParams->p_Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->p_FmPcdCc->h_FmMuram,
+                                             FM_PCD_CC_AD_ENTRY_SIZE,
+                                             FM_PCD_CC_AD_TABLE_ALIGN);
+
+        if(!p_ModifyAdditionalParams->p_Ad)
+        {
+            XX_Free(p_ModifyAdditionalParams);
+            XX_Free(p_ModifyAdditionalParams);
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+        }
+        WRITE_BLOCK((uint8_t *)p_ModifyAdditionalParams->p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+        p_ModifyAdditionalParams->adAllocated = TRUE;
+    }
+    *h_Pointer = p_ModifyAdditionalParams;
+
+    return E_OK;
+}
+
+
+static void ModifyCcCommon2(t_FmPcdModifyCcAdditionalParams *p_CcOldModifyAdditionalParams,
+                            t_FmPcdModifyCcAdditionalParams *p_CcNewModifyAdditionalParams,
+                            uint16_t indx)
+{
+
+    uint32_t    tmpReg;
+
+    if(p_CcNewModifyAdditionalParams->fmPcdEngine == e_FM_PCD_CC)
+        p_CcNewModifyAdditionalParams->myInfo |= (uint32_t)indx <<16;
+
+    tmpReg = GET_UINT32(*((uint32_t*)p_CcOldModifyAdditionalParams->p_Ad));
+    if((tmpReg & FM_PCD_AD_TYPE_MASK) == FM_PCD_AD_CONT_LOOKUP_TYPE)
+    {
+        p_CcOldModifyAdditionalParams->fmPcdEngine = e_FM_PCD_CC;
+        p_CcOldModifyAdditionalParams->myInfo =(uint32_t)indx ;
+    }
+    else
+        p_CcOldModifyAdditionalParams->myInfo = 0xffffffff;
+}
+
+static void ReleaseNewNodeCommonPart(t_FmPcdCc *p_FmPcdCc, t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+{
+    if(p_AdditionalInfo->p_AdTableNew)
+        FM_MURAM_FreeMem(p_FmPcdCc->h_FmMuram, p_AdditionalInfo->p_AdTableNew);
+    if(p_AdditionalInfo->p_KeysMatchTableNew)
+        FM_MURAM_FreeMem(p_FmPcdCc->h_FmMuram, p_AdditionalInfo->p_KeysMatchTableNew);
+}
+
+static t_Error BuildNewNodeCommonPart(t_Handle *h_FmPcd, t_FmPcdCcNode *p_FmPcdCcNode, int *size, bool mask, t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+{
+    t_FmPcd                *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdCc               *p_FmPcdCc = p_FmPcd->p_FmPcdCc;
+
+    p_AdditionalInfo->p_AdTableNew = (t_Handle)FM_MURAM_AllocMem(p_FmPcdCc->h_FmMuram,
+                                     (uint32_t)( (p_AdditionalInfo->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE),
+                                     FM_PCD_CC_AD_TABLE_ALIGN);
+    if(!p_AdditionalInfo->p_AdTableNew)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("No memory in MURAM ffor AD table "));
+
+    WRITE_BLOCK((uint8_t *)p_AdditionalInfo->p_AdTableNew, 0, (uint32_t)((p_AdditionalInfo->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE));
+
+    if(p_FmPcdCcNode->lclMask || mask)
+    {
+        p_AdditionalInfo->lclMask = TRUE;
+        *size = 2 * p_FmPcdCcNode->ccKeySizeAccExtraction;
+    }
+    else
+    {
+        p_AdditionalInfo->lclMask = p_FmPcdCcNode->lclMask;
+        *size = p_FmPcdCcNode->ccKeySizeAccExtraction;
+    }
+
+    p_AdditionalInfo->p_KeysMatchTableNew =(t_Handle)FM_MURAM_AllocMem(p_FmPcdCc->h_FmMuram,
+                                         (uint32_t)(*size * sizeof(uint8_t) * (p_AdditionalInfo->numOfKeys + 1)),
+                                         FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
+    if(!p_AdditionalInfo->p_KeysMatchTableNew)
+    {
+        FM_MURAM_FreeMem(p_FmPcdCc->h_FmMuram, p_AdditionalInfo->p_KeysMatchTableNew);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("No memory in MURAM for KEY MATCH table"));
+    }
+    WRITE_BLOCK((uint8_t *)p_AdditionalInfo->p_KeysMatchTableNew, 0, *size * sizeof(uint8_t) * (p_AdditionalInfo->numOfKeys + 1));
+
+
+    p_AdditionalInfo->p_AdTableOld          = p_FmPcdCcNode->h_AdTable;
+    p_AdditionalInfo->p_KeysMatchTableOld   =p_FmPcdCcNode->h_KeysMatchTable;
+
+    return E_OK;
+}
+
+static t_Error BuildNewNodeAddKey(t_Handle h_FmPcd ,t_FmPcdCcNode *p_FmPcdCcNode, uint8_t keyIndex, t_FmPcdCcKeyParams  *p_KeyParams,t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+{
+    t_Error                 err;
+    t_NextEngineParamsInfo  nextEngineParamsInfo;
+    t_Handle                p_AdTableNewTmp, p_KeysMatchTableNewTmp;
+    t_Handle                p_KeysMatchTableOldTmp, p_AdTableOldTmp;
+    int                     size;
+    int                     i = 0, j = 0;
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams, &nextEngineParamsInfo);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    p_AdditionalInfo->numOfKeys = (uint8_t)(p_FmPcdCcNode->numOfKeys + 1);
+
+    err = BuildNewNodeCommonPart(h_FmPcd, p_FmPcdCcNode, &size, (p_KeyParams->p_Mask ? TRUE : FALSE), p_AdditionalInfo);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    i = 0;
+    for(j = 0; j < p_AdditionalInfo->numOfKeys; j++)
+    {
+        p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + j*FM_PCD_CC_AD_ENTRY_SIZE);
+        if(j == keyIndex)
+         {
+            NextStepAd(p_AdTableNewTmp,&p_KeyParams->ccNextEngineParams, p_FmPcd);
+            p_KeysMatchTableNewTmp = (t_Handle)(((uint32_t)p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
+            COPY_BLOCK((void*)p_KeysMatchTableNewTmp, p_KeyParams->p_Key, p_FmPcdCcNode->ccKeySizeAccExtraction);
+            if(p_AdditionalInfo->lclMask)
+            {
+                if(p_KeyParams->p_Mask)
+                    IO2IOCpy32((t_Handle)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction), p_KeyParams->p_Mask, p_FmPcdCcNode->ccKeySizeAccExtraction);
+                else
+                    WRITE_BLOCK((void*)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
+            }
+         }
+         else
+         {
+            p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + i*FM_PCD_CC_AD_ENTRY_SIZE);
+            IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
+            p_KeysMatchTableNewTmp = (t_Handle)(((uint32_t)p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
+            p_KeysMatchTableOldTmp  = (t_Handle)((uint32_t)p_AdditionalInfo->p_KeysMatchTableOld + i*size*sizeof(uint8_t));
+            if(p_AdditionalInfo->lclMask)
+            {
+                if(p_FmPcdCcNode->lclMask)
+                {
+                    IO2IOCpy32((t_Handle)((uint32_t)p_KeysMatchTableNewTmp + p_FmPcdCcNode->ccKeySizeAccExtraction), (t_Handle)((uint32_t)p_KeysMatchTableOldTmp+p_FmPcdCcNode->ccKeySizeAccExtraction),p_FmPcdCcNode->ccKeySizeAccExtraction);
+                }
+                else
+                {
+                    p_KeysMatchTableOldTmp  = (t_Handle)((uint32_t)p_FmPcdCcNode->h_KeysMatchTable + i*p_FmPcdCcNode->ccKeySizeAccExtraction*sizeof(uint8_t));
+                    WRITE_BLOCK((void*)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
+                }
+            }
+            IO2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp, p_FmPcdCcNode->ccKeySizeAccExtraction);
+           i++;
+         }
+    }
+
+    p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + j*FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + i*FM_PCD_CC_AD_ENTRY_SIZE);
+    IO2IOCpy32((void*)p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+
+    p_AdditionalInfo->keyIndexForRemove = 0xffff;
+    if(nextEngineParamsInfo.fmPcdEngine == e_FM_PCD_CC)
+        p_AdditionalInfo->nodeIdForAdd = (uint16_t)nextEngineParamsInfo.additionalInfo;
+    else
+        p_AdditionalInfo->nodeIdForAdd = 0xffff;
+    return E_OK;
+}
+
+static t_Error BuildNewNodeRemoveKey(t_Handle h_FmPcd  ,t_FmPcdCcNode *p_FmPcdCcNode, uint8_t keyIndex, t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+{
+    int         i = 0, j = 0;
+    t_Handle    p_AdTableNewTmp,p_KeysMatchTableNewTmp;
+    t_Handle    p_KeysMatchTableOldTmp, p_AdTableOldTmp;
+    int         size;
+    t_Error     err;
+
+    p_AdditionalInfo->numOfKeys = (uint16_t)(p_FmPcdCcNode->numOfKeys - 1);
+
+    err = BuildNewNodeCommonPart(h_FmPcd, p_FmPcdCcNode, &size, (p_FmPcdCcNode->lclMask ? TRUE : FALSE), p_AdditionalInfo);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    for(i = 0, j = 0; j < p_FmPcdCcNode->numOfKeys; i++, j++)
+    {
+        if(j == keyIndex)
+        {
+            p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + j*FM_PCD_CC_AD_ENTRY_SIZE);
+            if((GET_UINT32(*(uint32_t*)p_AdTableOldTmp) & FM_PCD_AD_TYPE_MASK) == FM_PCD_AD_CONT_LOOKUP_TYPE)
+                p_AdditionalInfo->keyIndexForRemove = keyIndex;
+            else
+                p_AdditionalInfo->keyIndexForRemove = 0xffff;
+            j++;
+        }
+        if(j == p_FmPcdCcNode->numOfKeys)
+            break;
+         p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + i*FM_PCD_CC_AD_ENTRY_SIZE);
+         p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + j*FM_PCD_CC_AD_ENTRY_SIZE);
+         IO2IOCpy32(p_AdTableNewTmp,p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
+         p_KeysMatchTableOldTmp  = (t_Handle)((uint32_t)p_AdditionalInfo->p_KeysMatchTableOld + j*size*sizeof(uint8_t));
+         p_KeysMatchTableNewTmp  = (t_Handle)((uint32_t)p_AdditionalInfo->p_KeysMatchTableNew+ i*size*sizeof(uint8_t));
+         IO2IOCpy32(p_KeysMatchTableNewTmp,p_KeysMatchTableOldTmp,  size * sizeof(uint8_t));
+    }
+
+    p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + i*FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + j*FM_PCD_CC_AD_ENTRY_SIZE);
+    IO2IOCpy32(p_AdTableNewTmp,p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
+
+    p_AdditionalInfo->nodeIdForAdd = 0xffff;
+
+   return E_OK;
+}
+
+
+static t_Error BuildNewNodeModifyKey(t_Handle h_FmPcd ,t_FmPcdCcNode *p_FmPcdCcNode, uint8_t keyIndex, uint8_t  *p_Key, uint8_t *p_Mask,t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+{
+    t_Error                 err;
+    t_Handle                p_AdTableNewTmp, p_KeysMatchTableNewTmp;
+    t_Handle                p_KeysMatchTableOldTmp, p_AdTableOldTmp;
+    int                     size;
+    int                     i = 0, j = 0;
+
+    p_AdditionalInfo->numOfKeys =  p_FmPcdCcNode->numOfKeys;
+
+    err = BuildNewNodeCommonPart(h_FmPcd, p_FmPcdCcNode, &size, (p_Mask ? TRUE : FALSE), p_AdditionalInfo);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    for(j = 0, i = 0; j < p_AdditionalInfo->numOfKeys; j++, i++)
+    {
+        p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + j*FM_PCD_CC_AD_ENTRY_SIZE);
+        p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + i*FM_PCD_CC_AD_ENTRY_SIZE);
+        IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
+        if(j == keyIndex)
+        {
+            p_KeysMatchTableNewTmp = (t_Handle)(((uint32_t)p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
+            COPY_BLOCK((void*)p_KeysMatchTableNewTmp, p_Key, p_FmPcdCcNode->ccKeySizeAccExtraction);
+            if(p_AdditionalInfo->lclMask)
+            {
+                if(p_Mask)
+                    IO2IOCpy32((t_Handle)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction), p_Mask, p_FmPcdCcNode->ccKeySizeAccExtraction);
+                else
+                    WRITE_BLOCK((void*)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
+            }
+        }
+        else
+        {
+            p_KeysMatchTableNewTmp = (t_Handle)(((uint32_t)p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
+            p_KeysMatchTableOldTmp  = (t_Handle)((uint32_t)p_FmPcdCcNode->h_KeysMatchTable + i*size*sizeof(uint8_t));
+            if(p_AdditionalInfo->lclMask)
+            {
+                if(p_FmPcdCcNode->lclMask)
+                {
+                    IO2IOCpy32((t_Handle)((uint32_t)p_KeysMatchTableNewTmp + p_FmPcdCcNode->ccKeySizeAccExtraction), (t_Handle)((uint32_t)p_KeysMatchTableOldTmp+p_FmPcdCcNode->ccKeySizeAccExtraction),p_FmPcdCcNode->ccKeySizeAccExtraction);
+                }
+                else
+                {
+                    p_KeysMatchTableOldTmp  = (t_Handle)((uint32_t)p_FmPcdCcNode->h_KeysMatchTable + i*p_FmPcdCcNode->ccKeySizeAccExtraction*sizeof(uint8_t));
+                    WRITE_BLOCK((void*)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
+                }
+            }
+            IO2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp, p_FmPcdCcNode->ccKeySizeAccExtraction);
+        }
+    }
+
+    p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + j*FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableOldTmp = (t_Handle)((uint32_t)p_FmPcdCcNode->h_AdTable + i*FM_PCD_CC_AD_ENTRY_SIZE);
+    IO2IOCpy32((void*)p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+
+    p_AdditionalInfo->nodeIdForAdd = 0xffff;
+    p_AdditionalInfo->keyIndexForRemove = 0xffff;
+
+    return E_OK;
+}
+
+static t_Error BuildNewNodeModifyKeyAndNextEngine(t_Handle h_FmPcd ,t_FmPcdCcNode *p_FmPcdCcNode, uint8_t keyIndex, t_FmPcdCcKeyParams  *p_KeyParams,t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+{
+    t_Error                 err;
+    t_NextEngineParamsInfo nextEngineParamsInfo;
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_Handle                p_AdTableNewTmp,p_KeysMatchTableNewTmp;
+    t_Handle                p_KeysMatchTableOldTmp, p_AdTableOldTmp;
+    int                     size;
+    int                     i = 0, j = 0;
+
+    err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams, &nextEngineParamsInfo);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    p_AdditionalInfo->numOfKeys = p_FmPcdCcNode->numOfKeys;
+
+    err = BuildNewNodeCommonPart(h_FmPcd, p_FmPcdCcNode, &size, (p_KeyParams->p_Mask ? TRUE : FALSE), p_AdditionalInfo);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    for(j = 0, i = 0; j < p_AdditionalInfo->numOfKeys; j++, i++)
+    {
+        p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + j*FM_PCD_CC_AD_ENTRY_SIZE);
+        if(j == keyIndex)
+         {
+            p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + i*FM_PCD_CC_AD_ENTRY_SIZE);
+            if((GET_UINT32(*(uint32_t*)p_AdTableOldTmp) & FM_PCD_AD_TYPE_MASK) == FM_PCD_AD_CONT_LOOKUP_TYPE)
+                p_AdditionalInfo->keyIndexForRemove = keyIndex;
+            else
+                p_AdditionalInfo->keyIndexForRemove = 0xffff;
+            NextStepAd(p_AdTableNewTmp,&p_KeyParams->ccNextEngineParams, p_FmPcd);
+            p_KeysMatchTableNewTmp = (t_Handle)(((uint32_t)p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
+            COPY_BLOCK((void*)p_KeysMatchTableNewTmp, p_KeyParams->p_Key, p_FmPcdCcNode->ccKeySizeAccExtraction);
+            if(p_FmPcdCcNode->lclMask)
+            {
+                if(p_KeyParams->p_Mask)
+                    IO2IOCpy32((void*)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction), p_KeyParams->p_Mask, p_FmPcdCcNode->ccKeySizeAccExtraction);
+                else
+                    WRITE_BLOCK((void*)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
+            }
+         }
+         else
+         {
+            p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + i*FM_PCD_CC_AD_ENTRY_SIZE);
+            IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
+            p_KeysMatchTableNewTmp = (t_Handle)(((uint32_t)p_AdditionalInfo->p_KeysMatchTableNew) + j*size * sizeof(uint8_t));
+            p_KeysMatchTableOldTmp  = (t_Handle)((uint32_t)p_AdditionalInfo->p_KeysMatchTableOld + i*size*sizeof(uint8_t));
+            if(p_AdditionalInfo->lclMask)
+            {
+                if(p_FmPcdCcNode->lclMask)
+                    IO2IOCpy32((t_Handle)((uint32_t)p_KeysMatchTableNewTmp + p_FmPcdCcNode->ccKeySizeAccExtraction), (t_Handle)((uint32_t)p_KeysMatchTableOldTmp+p_FmPcdCcNode->ccKeySizeAccExtraction),p_FmPcdCcNode->ccKeySizeAccExtraction);
+                else
+                {
+                    p_KeysMatchTableOldTmp  = (t_Handle)((uint32_t)p_AdditionalInfo->p_KeysMatchTableOld + i*p_FmPcdCcNode->ccKeySizeAccExtraction*sizeof(uint8_t));
+                    WRITE_BLOCK((void*)(((uint32_t)p_KeysMatchTableNewTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->ccKeySizeAccExtraction);
+                }
+            }
+             IO2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp, p_FmPcdCcNode->ccKeySizeAccExtraction);
+         }
+    }
+
+    p_AdTableNewTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableNew + j*FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableOldTmp = (t_Handle)((uint32_t)p_AdditionalInfo->p_AdTableOld + i*FM_PCD_CC_AD_ENTRY_SIZE);
+    IO2IOCpy32((void*)p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+
+    if(nextEngineParamsInfo.fmPcdEngine == e_FM_PCD_CC)
+        p_AdditionalInfo->nodeIdForAdd = (uint16_t)nextEngineParamsInfo.additionalInfo;
+    else
+        p_AdditionalInfo->nodeIdForAdd = 0xffff;
+    return E_OK;
+}
+
+
+static void FillNodeWithParams(t_FmPcdCcNode *p_FmPcdCcNodeTo, t_FmPcdCcNode *p_FmPcdCcNodeFrom, t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams)
+{
+    p_FmPcdCcNodeTo->h_AdTable       = p_FmPcdModifyCcKeyAdditionalParams->p_AdTableNew;
+    p_FmPcdCcNodeTo->numOfKeys       = p_FmPcdModifyCcKeyAdditionalParams->numOfKeys;
+    p_FmPcdCcNodeTo->lclMask         = p_FmPcdModifyCcKeyAdditionalParams->lclMask;
+    p_FmPcdCcNodeTo->h_KeysMatchTable= p_FmPcdModifyCcKeyAdditionalParams->p_KeysMatchTableNew;
+
+    p_FmPcdCcNodeTo->sizeOfExtraction = p_FmPcdCcNodeFrom->sizeOfExtraction;
+    p_FmPcdCcNodeTo->prsArrayOffset  = p_FmPcdCcNodeFrom->prsArrayOffset;
+    p_FmPcdCcNodeTo->offset          = p_FmPcdCcNodeFrom->offset;
+    p_FmPcdCcNodeTo->parseCode       = p_FmPcdCcNodeFrom->parseCode;
+    p_FmPcdCcNodeTo->p_GlblMask      = p_FmPcdCcNodeFrom->p_GlblMask;
+    p_FmPcdCcNodeTo->glblMaskSize    = p_FmPcdCcNodeFrom->glblMaskSize;
+}
+
+static t_Error ModifyWithNodeDataStructure(t_FmPcd *p_FmPcd,uint16_t nodeId, t_FmPcdCcNode *p_FmPcdCcNode ,t_List  *h_OldLst)
+{
+    t_List                          *p_Pos,*p_Pos1;
+    t_CcNodeInfo                    *p_CcNodeInfo;
+    uint16_t                        nodeIdPrev;
+    t_FmPcdCcNode                   *p_FmPcdCcNodePrev;
+    t_List                          p_List;
+
+
+    INIT_LIST(&p_List);
+
+    LIST_FOR_EACH(p_Pos, &p_FmPcdCcNode->ccPrevNodesLst)
+    {
+        p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+        nodeIdPrev = (uint16_t)p_CcNodeInfo->nextCcNodeInfo;
+        p_FmPcdCcNodePrev = (t_FmPcdCcNode *)GetNodeHandler(p_FmPcd, nodeIdPrev);
+        if(!p_FmPcdCcNodePrev)
+            RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("the node with this nodeId wasn't initialized"));
+        FindNodeInfoAccIdAndAddToRetLst(&p_FmPcdCcNodePrev->ccNextNodesLst,nodeId, &p_List);
+        if(LIST_IsEmpty(&p_List))
+            RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("numOfPrevNodes has to be 1"));
+        LIST_FOR_EACH(p_Pos1, &p_List)
+        {
+            p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos1);
+            CreateNodeInfo(h_OldLst, (uint32_t)((uint32_t)(p_FmPcdCcNodePrev->h_AdTable) + FM_PCD_CC_AD_ENTRY_SIZE * (p_CcNodeInfo->nextCcNodeInfo >> 16)));
+        }
+    }
+
+    ReleaseLst(&p_List);
+    return E_OK;
+}
+static t_Error ModifyWithTreeDataStructure(t_FmPcd *p_FmPcd,uint16_t nodeId, t_FmPcdCcNode *p_FmPcdCcNode, t_List  *h_OldLst)
+{
+    t_List                          *p_Pos,*p_Pos1;
+    t_CcNodeInfo                    *p_CcNodeInfo;
+    uint16_t                        treeIdPrev;
+    t_List                          p_List;
+    t_FmPcdCcTree                   *p_FmPcdCcTreePrev;
+
+
+    INIT_LIST(&p_List);
+
+    LIST_FOR_EACH(p_Pos, &p_FmPcdCcNode->ccTreeIdLst)
+    {
+        p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+        treeIdPrev = (uint16_t)p_CcNodeInfo->nextCcNodeInfo;
+        p_FmPcdCcTreePrev = (t_FmPcdCcTree *)FmPcdCcGetTreeHandler(p_FmPcd, (uint8_t)treeIdPrev);
+        if(!p_FmPcdCcTreePrev)
+            RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("the node with this nodeId wasn't initialized"));
+        FindNodeInfoAccIdAndAddToRetLst(&p_FmPcdCcTreePrev->ccNextNodesLst,nodeId , &p_List);
+        if(LIST_IsEmpty(&p_List))
+            RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("numOfPrevNodes has to be 1"));
+        LIST_FOR_EACH(p_Pos1, &p_List)
+        {
+            p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos1);
+            CreateNodeInfo(h_OldLst, (uint32_t)((uint32_t)(p_FmPcdCcTreePrev->p_CcBaseTree) + FM_PCD_CC_AD_ENTRY_SIZE * (p_CcNodeInfo->nextCcNodeInfo >> 16)));
+        }
+    }
+    ReleaseLst(&p_List);
+    return E_OK;
+}
+
+static t_Error ModifyKeyCommonPart1(t_FmPcdCcNode *p_FmPcdCcNode,  uint8_t keyIndex, t_FmPcdModifyCcKeyAdditionalParams **p_FmPcdModifyCcKeyAdditionalParams)
+{
+    t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParamsTmp;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNode,E_INVALID_HANDLE);
+
+    if(p_FmPcdCcNode->parseCode == CC_PC_FF_IPV4TTL ||
+       p_FmPcdCcNode->parseCode == CC_PC_FF_IPV6HOP_LIMIT)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("nodeId of CC_PC_FF_IPV4TTL or CC_PC_FF_IPV6HOP_LIMIT can not be used for addKey, removeKey, modifyKey"));
+
+    if (!LIST_NumOfObjs(&p_FmPcdCcNode->ccPrevNodesLst) &&
+        !LIST_NumOfObjs(&p_FmPcdCcNode->ccTreeIdLst))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("this node without connection"));
+
+    p_FmPcdModifyCcKeyAdditionalParamsTmp =  (t_FmPcdModifyCcKeyAdditionalParams *)XX_Malloc(sizeof(t_FmPcdModifyCcKeyAdditionalParams));
+    if(!p_FmPcdModifyCcKeyAdditionalParamsTmp)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Allocation of internal data structure FAILED"));
+    memset(p_FmPcdModifyCcKeyAdditionalParamsTmp, 0, sizeof(t_FmPcdModifyCcKeyAdditionalParams));
+
+    p_FmPcdModifyCcKeyAdditionalParamsTmp->h_CurrentNode = (t_Handle)p_FmPcdCcNode;
+    p_FmPcdModifyCcKeyAdditionalParamsTmp->keyIndexForRemove = keyIndex;
+    p_FmPcdModifyCcKeyAdditionalParamsTmp->keyIndexForAdd = keyIndex;
+
+    *p_FmPcdModifyCcKeyAdditionalParams = p_FmPcdModifyCcKeyAdditionalParamsTmp;
+
+    return E_OK;
+}
+
+t_Error FmPcdCcModifyNextEngineParamTree(t_Handle h_FmPcd, t_Handle h_FmPcdCcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_Handle *h_OldPointer, t_Handle *h_NewPointer)
+{
+    t_FmPcdCcTree                   *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_Error                         err;
+    t_FmPcdModifyCcAdditionalParams *p_CcOldModifyAdditionalParams;
+    t_FmPcdModifyCcAdditionalParams *p_CcNewModifyAdditionalParams;
+
+    SANITY_CHECK_RETURN_ERROR((grpId <= 7),E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree,E_INVALID_VALUE);
+
+
+    if(grpId >= p_FmPcdCcTree->numOfGrps)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("grpId you asked > numOfGroup of relevant tree"));
+
+    if(index >= p_FmPcdCcTree->fmPcdGroupParam[grpId].numOfEntriesInGroup)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("index > numOfEntriesInGroup"));
+
+    err = ModifyCcCommon1(h_FmPcd, p_FmPcdCcNextEngineParams, h_OldPointer, h_NewPointer);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    p_CcOldModifyAdditionalParams = *h_OldPointer;
+    p_CcOldModifyAdditionalParams->p_Ad = (t_Handle)((uint32_t)p_FmPcdCcTree->p_CcBaseTree + FM_PCD_CC_AD_ENTRY_SIZE* (p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry + index));
+    p_CcOldModifyAdditionalParams->isTree = TRUE;
+    p_CcOldModifyAdditionalParams->h_Node = p_FmPcdCcTree;
+    p_CcNewModifyAdditionalParams  = *h_NewPointer;
+    p_CcNewModifyAdditionalParams->isTree = TRUE;
+    p_CcNewModifyAdditionalParams->h_Node = p_FmPcdCcTree;
+
+    ModifyCcCommon2(p_CcOldModifyAdditionalParams, p_CcNewModifyAdditionalParams, (uint8_t)(p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry + index));
+
+    return E_OK;
+}
+
+
+static t_Error ModifyKeyCommonPart2(t_FmPcd *p_FmPcd, t_FmPcdCcNode *p_FmPcdCcNode, t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams ,t_List *h_OldLst, t_Handle *h_NewPointer)
+{
+
+    t_Error         err;
+    t_FmPcdCcNode   fmPcdCcNode;
+
+    if(!LIST_IsEmpty(&p_FmPcdCcNode->ccPrevNodesLst))
+    {
+        err =  ModifyWithNodeDataStructure(p_FmPcd,p_FmPcdCcNode->nodeId, p_FmPcdCcNode,h_OldLst);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+    if(!LIST_IsEmpty(&p_FmPcdCcNode->ccTreeIdLst))
+    {
+        err =  ModifyWithTreeDataStructure(p_FmPcd,p_FmPcdCcNode->nodeId, p_FmPcdCcNode,h_OldLst);
+        if(err)
+        {
+            ReleaseLst(h_OldLst);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+
+    }
+
+    memset(&fmPcdCcNode, 0, sizeof(t_FmPcdCcNode));
+    FillNodeWithParams(&fmPcdCcNode, p_FmPcdCcNode, p_FmPcdModifyCcKeyAdditionalParams);
+    err = ModifyCcKeyCommon(p_FmPcd,h_NewPointer, TRUE);
+    if(err)
+    {
+        ReleaseLst(h_OldLst);
+        ReleaseCommonModifyKey((p_FmPcd->p_FmPcdCc)->h_FmMuram,(t_FmPcdModifyCcAdditionalParams *)*h_NewPointer);
+    }
+    FillAdOfTypeContLookup(((t_FmPcdModifyCcAdditionalParams *)*h_NewPointer)->p_Ad, p_FmPcd,&fmPcdCcNode);
+
+    ((t_FmPcdModifyCcAdditionalParams *)*h_NewPointer)->h_AdditionalInfo = p_FmPcdModifyCcKeyAdditionalParams;
+
+    return E_OK;
+}
+
+
+t_Error FmPcdCcAddKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex, t_FmPcdCcKeyParams *p_FmPcdCcKeyParams, t_List *h_OldLst, t_Handle *h_NewPointer)
+{
+    t_FmPcdCcNode                   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error                         err;
+    t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams;
+
+    err =  ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, &p_FmPcdModifyCcKeyAdditionalParams);
+    if(err)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    if(keyIndex > p_FmPcdCcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previousely cleared last index + 1"));
+
+    if((p_FmPcdCcNode->numOfKeys + 1) > MAX_NUM_OF_PCD_CC_NODES)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfKeys with new key can not be larger than 255"));
+
+    err = BuildNewNodeAddKey (h_FmPcd, p_FmPcdCcNode, keyIndex, p_FmPcdCcKeyParams, p_FmPcdModifyCcKeyAdditionalParams);
+    if(err)
+    {
+        XX_Free(p_FmPcdModifyCcKeyAdditionalParams);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = ModifyKeyCommonPart2(p_FmPcd, p_FmPcdCcNode, p_FmPcdModifyCcKeyAdditionalParams, h_OldLst, h_NewPointer);
+    if(err)
+    {
+            ReleaseNewNodeCommonPart(p_FmPcd->p_FmPcdCc, p_FmPcdModifyCcKeyAdditionalParams);
+            XX_Free(p_FmPcdModifyCcKeyAdditionalParams);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    return E_OK;
+}
+
+t_Error FmPcdCcRemoveKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex,t_List *h_OldLst, t_Handle *h_NewPointer)
+{
+
+    t_FmPcdCcNode                   *p_FmPcdCcNode = (t_FmPcdCcNode *) h_FmPcdCcNode;
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error                         err;
+    t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams;
+
+
+    err = ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, &p_FmPcdModifyCcKeyAdditionalParams);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    if(keyIndex >= p_FmPcdCcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("impossible to remove key from numOfKeys = 0"));
+
+    if(!p_FmPcdCcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("keyIndex you asked > numOfKeys of relevant node that was initialized"));
+
+    err = BuildNewNodeRemoveKey (h_FmPcd, p_FmPcdCcNode, keyIndex, p_FmPcdModifyCcKeyAdditionalParams);
+    if(err)
+    {
+        XX_Free(p_FmPcdModifyCcKeyAdditionalParams);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = ModifyKeyCommonPart2(p_FmPcd, p_FmPcdCcNode, p_FmPcdModifyCcKeyAdditionalParams, h_OldLst, h_NewPointer);
+    if(err)
+    {
+        ReleaseNewNodeCommonPart(p_FmPcd->p_FmPcdCc, p_FmPcdModifyCcKeyAdditionalParams);
+        XX_Free(p_FmPcdModifyCcKeyAdditionalParams);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+ return E_OK;
+}
+
+t_Error FmPcdCcModifyKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex, uint8_t *p_Key, uint8_t *p_Mask, t_List *h_OldLst, t_Handle *h_NewPointer)
+{
+    t_FmPcdCcNode                   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error                         err;
+    t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams;
+
+    err = ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, &p_FmPcdModifyCcKeyAdditionalParams);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    if(keyIndex >= p_FmPcdCcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("keyIndex you asked > numOfKeys of relevant node that was initialized"));
+
+    err = BuildNewNodeModifyKey (h_FmPcd, p_FmPcdCcNode, keyIndex, p_Key, p_Mask, p_FmPcdModifyCcKeyAdditionalParams);
+    if(err)
+    {
+        XX_Free(p_FmPcdModifyCcKeyAdditionalParams);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = ModifyKeyCommonPart2(p_FmPcd, p_FmPcdCcNode, p_FmPcdModifyCcKeyAdditionalParams, h_OldLst, h_NewPointer);
+    if(err)
+    {
+        ReleaseNewNodeCommonPart(p_FmPcd->p_FmPcdCc, p_FmPcdModifyCcKeyAdditionalParams);
+        XX_Free(p_FmPcdModifyCcKeyAdditionalParams);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+ return E_OK;
+}
+
+t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdNode, uint8_t keyIndex, t_FmPcdCcKeyParams *p_FmPcdCcKeyParams, t_List *h_OldLst, t_Handle *h_NewPointer)
+{
+    t_FmPcdCcNode                   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdNode;
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error                         err;
+    t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams;
+
+    err = ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, &p_FmPcdModifyCcKeyAdditionalParams);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    if(keyIndex >= p_FmPcdCcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("keyIndex you asked > numOfKeys of relevant node that was initialized"));
+
+
+    err = BuildNewNodeModifyKeyAndNextEngine (h_FmPcd, p_FmPcdCcNode, keyIndex, p_FmPcdCcKeyParams, p_FmPcdModifyCcKeyAdditionalParams);
+    if(err)
+    {
+        XX_Free(p_FmPcdModifyCcKeyAdditionalParams);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = ModifyKeyCommonPart2(p_FmPcd, p_FmPcdCcNode, p_FmPcdModifyCcKeyAdditionalParams, h_OldLst, h_NewPointer);
+    if(err)
+    {
+        ReleaseNewNodeCommonPart(p_FmPcd->p_FmPcdCc, p_FmPcdModifyCcKeyAdditionalParams);
+        XX_Free(p_FmPcdModifyCcKeyAdditionalParams);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+ return E_OK;
+}
+
+
+
+t_Error FmPcdCcModiyNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, uint8_t keyIndex,t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_Handle *h_OldPointer, t_Handle *h_NewPointer)
+{
+    t_FmPcdModifyCcAdditionalParams *p_CcOldModifyAdditionalParams;
+    t_FmPcdModifyCcAdditionalParams *p_CcNewModifyAdditionalParams;
+    t_FmPcdCcNode                   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_Error                         err;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNode,E_INVALID_HANDLE);
+
+
+    if(keyIndex >= p_FmPcdCcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("keyIndex you asked > numOfKeys of relevant node that was initialized"));
+
+    err = ModifyCcCommon1(h_FmPcd, p_FmPcdCcNextEngineParams, h_OldPointer, h_NewPointer);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+
+    p_CcOldModifyAdditionalParams = *h_OldPointer;
+    p_CcOldModifyAdditionalParams->p_Ad = (t_Handle)((uint32_t)p_FmPcdCcNode->h_AdTable + FM_PCD_CC_AD_ENTRY_SIZE * keyIndex);
+    p_CcOldModifyAdditionalParams->h_Node = (t_Handle)p_FmPcdCcNode;
+
+    p_CcNewModifyAdditionalParams  = *h_NewPointer;
+    p_CcNewModifyAdditionalParams->h_Node = (t_Handle)p_FmPcdCcNode;
+    ModifyCcCommon2(p_CcOldModifyAdditionalParams,p_CcNewModifyAdditionalParams, keyIndex);
+
+    return E_OK;
+}
+
+t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_Handle *h_OldPointer, t_Handle *h_NewPointer)
+{
+    t_FmPcdModifyCcAdditionalParams *p_CcOldModifyAdditionalParams;
+    t_FmPcdModifyCcAdditionalParams *p_CcNewModifyAdditionalParams;
+    t_FmPcdCcNode                   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_Error                         err;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNode,E_INVALID_VALUE);
+
+    err = ModifyCcCommon1(h_FmPcd, p_FmPcdCcNextEngineParams, h_OldPointer, h_NewPointer);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+
+    p_CcOldModifyAdditionalParams = *h_OldPointer;
+    p_CcOldModifyAdditionalParams->p_Ad = (t_Handle)((uint32_t)p_FmPcdCcNode->h_AdTable + FM_PCD_CC_AD_ENTRY_SIZE * p_FmPcdCcNode->numOfKeys);
+    p_CcOldModifyAdditionalParams->h_Node = (t_Handle)p_FmPcdCcNode;
+
+    p_CcNewModifyAdditionalParams  = *h_NewPointer;
+    p_CcOldModifyAdditionalParams->h_Node = (t_Handle)p_FmPcdCcNode;
+    ModifyCcCommon2(p_CcOldModifyAdditionalParams,p_CcNewModifyAdditionalParams,p_FmPcdCcNode->numOfKeys);
+
+    return E_OK;
+}
+static t_Error UpdateNodesWithTree(t_Handle h_FmPcd,t_List *ccNextNodesLst, uint16_t *p_CcArray, uint8_t treeId)
+{
+    t_List          *p_Pos;
+    t_Error         err;
+    t_FmPcdCcNode   *p_FmPcdCcNode;
+    uint32_t        nodeIdTmp;
+    if(!LIST_IsEmpty(ccNextNodesLst))
+     {
+         LIST_FOR_EACH(p_Pos, ccNextNodesLst)
+         {
+             nodeIdTmp = ((t_CcNodeInfo *)CC_NEXT_NODE_F_OBJECT(p_Pos))->nextCcNodeInfo;
+             p_FmPcdCcNode = (t_FmPcdCcNode *)GetNodeHandler((t_FmPcd *)h_FmPcd, (uint16_t)nodeIdTmp);
+             if(!p_FmPcdCcNode)
+                 RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+             if(p_CcArray[(uint16_t)nodeIdTmp] ==0)
+             {
+                 err = UpdateNodesWithTree(h_FmPcd, &p_FmPcdCcNode->ccNextNodesLst,p_CcArray, treeId);
+                 if(err)
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+                 CreateNodeInfo(&p_FmPcdCcNode->ccTreesLst, (uint32_t)treeId);
+                 p_CcArray[(uint16_t)nodeIdTmp] = 1;
+             }
+         }
+     }
+    return E_OK;
+}
+
+static t_Error RemoveNodesFromTree(t_Handle h_FmPcd,t_List *ccNextNodesLst, uint8_t treeId)
+{
+    t_List          *p_Pos;
+    t_Error         err;
+    t_FmPcdCcNode   *p_FmPcdCcNode;
+    uint32_t        nodeIdTmp;
+    t_CcNodeInfo    *p_CcNodeInfo;
+    if(!LIST_IsEmpty(ccNextNodesLst))
+    {
+        LIST_FOR_EACH(p_Pos, ccNextNodesLst)
+        {
+            nodeIdTmp = ((t_CcNodeInfo *)CC_NEXT_NODE_F_OBJECT(p_Pos))->nextCcNodeInfo;
+            p_FmPcdCcNode = GetNodeHandler((t_FmPcd *)h_FmPcd, (uint16_t)nodeIdTmp);
+            if(!p_FmPcdCcNode)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+            err = RemoveNodesFromTree(h_FmPcd, &p_FmPcdCcNode->ccNextNodesLst, treeId);
+            if(err)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+            p_CcNodeInfo = FindNodeInfoAccId(&p_FmPcdCcNode->ccTreesLst, treeId);
+            ASSERT_COND(p_CcNodeInfo);
+            LIST_DelAndInit(&p_CcNodeInfo->h_Node);
+            XX_Free(p_CcNodeInfo);
+        }
+    }
+
+    return E_OK;
+}
+
+
+t_Error FmPcdCcReleaseModifiedOnlyNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdOldPointer, t_Handle h_FmPcdNewPointer, bool isAllGood)
+{
+    t_FmPcdModifyCcAdditionalParams *p_CcOldModifyAdditionalParams = (t_FmPcdModifyCcAdditionalParams *)h_FmPcdOldPointer;
+    t_FmPcdModifyCcAdditionalParams *p_CcNewModifyAdditionalParams = (t_FmPcdModifyCcAdditionalParams *)h_FmPcdNewPointer;
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdCcTree                   *p_CurrentTree=NULL;
+    t_FmPcdCcNode                   *p_CurrentNode=NULL, *p_NodeForAdd, *p_NodeForRemove;
+    t_CcNodeInfo                    *p_CcNodeInfo, *p_CcNodeInfo1;
+    uint16_t                         numOfReplec;
+    t_Error                          err;
+    t_List                          *p_Pos;
+    uint16_t                        ccArray[MAX_NUM_OF_PCD_CC_NODES];
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdOldPointer,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_CcNewModifyAdditionalParams->h_Node,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_CcOldModifyAdditionalParams->h_Node,E_INVALID_HANDLE);
+
+    if(isAllGood)
+    {
+            if(p_CcNewModifyAdditionalParams->isTree)
+                p_CurrentTree = (t_FmPcdCcTree*)p_CcNewModifyAdditionalParams->h_Node;
+            else
+                p_CurrentNode = (t_FmPcdCcNode*)p_CcNewModifyAdditionalParams->h_Node;
+           if(p_CurrentTree)
+            {
+                    if(p_CcNewModifyAdditionalParams->myInfo != 0xffffffff)
+                    {
+                        p_NodeForAdd = GetNodeHandler(p_FmPcd, (uint16_t)p_CcNewModifyAdditionalParams->myInfo);
+                        ASSERT_COND(p_NodeForAdd);
+                        CreateNodeInfo(&p_CurrentTree->ccNextNodesLst, p_CcNewModifyAdditionalParams->myInfo);
+                        p_CcNodeInfo = FindNodeInfoAccId(&p_NodeForAdd->ccTreeIdLst, p_CurrentTree->treeId);
+                        if(p_CcNodeInfo)
+                        {
+                            numOfReplec = (uint16_t)(p_CcNodeInfo->nextCcNodeInfo >> 16);
+                            p_CcNodeInfo->nextCcNodeInfo = ((p_CcNodeInfo->nextCcNodeInfo & 0x0000ffff) | ((uint32_t)(numOfReplec+1) <<16));
+                        }
+                        else
+                            CreateNodeInfo(&p_NodeForAdd->ccTreeIdLst, (uint32_t)((uint32_t)p_CurrentTree->treeId | ((uint32_t)1<<16)));
+                        memset(ccArray, 0, sizeof(uint16_t) * MAX_NUM_OF_PCD_CC_NODES);
+                        err = UpdateNodesWithTree(h_FmPcd, &p_NodeForAdd->ccNextNodesLst, ccArray, p_CurrentTree->treeId);
+                        if(err)
+                            RETURN_ERROR(MAJOR, err, NO_MSG);
+                    }
+                    if(p_CcOldModifyAdditionalParams->myInfo != 0xffffffff)
+                    {
+                        p_CcNodeInfo = FindNodeInfoAccIndex(&p_CurrentTree->ccNextNodesLst, (uint16_t)p_CcOldModifyAdditionalParams->myInfo);
+                        ASSERT_COND(p_CcNodeInfo);
+                        p_NodeForRemove = GetNodeHandler(p_FmPcd, (uint16_t)p_CcNodeInfo->nextCcNodeInfo);
+                        ASSERT_COND(p_NodeForRemove);
+                        UpdateNodeOwner(p_FmPcd, p_NodeForRemove->nodeId, FALSE);
+                        p_CcNodeInfo1 = FindNodeInfoAccId(&p_NodeForRemove->ccTreeIdLst, p_CurrentTree->treeId);
+                        ASSERT_COND(p_CcNodeInfo1);
+                        numOfReplec = (uint16_t)(p_CcNodeInfo1->nextCcNodeInfo >> 16);
+                        ASSERT_COND(numOfReplec);
+                        numOfReplec -=1;
+                        if(numOfReplec)
+                            p_CcNodeInfo1->nextCcNodeInfo = (uint32_t)((p_CcNodeInfo1->nextCcNodeInfo & 0x0000ffff) | (numOfReplec << 16));
+                        else
+                        {
+                            LIST_DelAndInit(&p_CcNodeInfo1->h_Node);
+                            XX_Free(p_CcNodeInfo1);
+                        }
+                        LIST_DelAndInit(&p_CcNodeInfo->h_Node);
+                        XX_Free(p_CcNodeInfo);
+                        err = RemoveNodesFromTree(h_FmPcd, &p_NodeForRemove->ccNextNodesLst, p_CurrentTree->treeId);
+                        if(err)
+                            RETURN_ERROR(MAJOR, err, NO_MSG);
+                     }
+            }
+            else if(p_CurrentNode)
+            {
+                   if(p_CcNewModifyAdditionalParams->myInfo != 0xffffffff)
+                    {
+                        p_NodeForAdd = GetNodeHandler(p_FmPcd, (uint16_t)p_CcNewModifyAdditionalParams->myInfo);
+                        ASSERT_COND(p_NodeForAdd);
+                        CreateNodeInfo(&p_CurrentNode->ccNextNodesLst, p_CcNewModifyAdditionalParams->myInfo);
+                        p_CcNodeInfo = FindNodeInfoAccId(&p_NodeForAdd->ccPrevNodesLst, p_CurrentNode->nodeId);
+                        if(p_CcNodeInfo)
+                        {
+                            numOfReplec = (uint16_t)(p_CcNodeInfo->nextCcNodeInfo >> 16);
+                            p_CcNodeInfo->nextCcNodeInfo = ((p_CcNodeInfo->nextCcNodeInfo & 0x0000ffff) | ((uint32_t)(numOfReplec+1) <<16));
+                        }
+                        else
+                            CreateNodeInfo(&p_NodeForAdd->ccPrevNodesLst, (uint32_t)((uint32_t)p_CurrentNode->nodeId | ((uint32_t)1<<16)));
+
+                        LIST_FOR_EACH(p_Pos, &p_CurrentNode->ccTreesLst)
+                        {
+                            p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+                            memset(ccArray, 0, sizeof(uint16_t)*MAX_NUM_OF_PCD_CC_NODES);
+                            err = UpdateNodesWithTree(p_FmPcd, &p_NodeForAdd->ccNextNodesLst, ccArray, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
+                            if(err)
+                                RETURN_ERROR(MAJOR, err, NO_MSG);
+                        }
+                    }
+                    if(p_CcOldModifyAdditionalParams->myInfo != 0xffffffff)
+                    {
+                        p_CcNodeInfo = FindNodeInfoAccIndex(&p_CurrentNode->ccNextNodesLst, (uint16_t)p_CcOldModifyAdditionalParams->myInfo);
+                        ASSERT_COND(p_CcNodeInfo);
+                        p_NodeForRemove = GetNodeHandler(p_FmPcd, (uint16_t)p_CcNodeInfo->nextCcNodeInfo);
+                        ASSERT_COND(p_NodeForRemove);
+                        p_CcNodeInfo1 = FindNodeInfoAccId(&p_NodeForRemove->ccPrevNodesLst, p_CurrentNode->nodeId);
+                        UpdateNodeOwner(p_FmPcd, p_NodeForRemove->nodeId, FALSE);
+                        ASSERT_COND(p_CcNodeInfo1);
+                        numOfReplec = (uint16_t)(p_CcNodeInfo1->nextCcNodeInfo >> 16);
+                        ASSERT_COND(numOfReplec);
+                        numOfReplec -=1;
+                        if(numOfReplec)
+                            p_CcNodeInfo1->nextCcNodeInfo = (uint32_t)((p_CcNodeInfo1->nextCcNodeInfo & 0x0000ffff) | (numOfReplec << 16));
+                        else
+                        {
+                            LIST_DelAndInit(&p_CcNodeInfo1->h_Node);
+                            XX_Free(p_CcNodeInfo1);
+                        }
+                        LIST_DelAndInit(&p_CcNodeInfo->h_Node);
+                        XX_Free(p_CcNodeInfo);
+                        LIST_FOR_EACH(p_Pos, &p_CurrentNode->ccTreesLst)
+                        {
+                            p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+                            err = RemoveNodesFromTree(h_FmPcd, &p_NodeForRemove->ccNextNodesLst, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
+                            if(err)
+                                RETURN_ERROR(MAJOR, err, NO_MSG);
+                        }
+                  }
+            }
+       }
+         else
+         {
+        if(p_CcNewModifyAdditionalParams->myInfo != 0xffffffff)
+            UpdateNodeOwner(p_FmPcd, (uint16_t)p_CcNewModifyAdditionalParams->myInfo, FALSE);
+       }
+
+    if(p_CcNewModifyAdditionalParams->p_Ad)
+        FM_MURAM_FreeMem(p_FmPcd->p_FmPcdCc->h_FmMuram,p_CcNewModifyAdditionalParams->p_Ad);
+
+    XX_Free(h_FmPcdNewPointer);
+    XX_Free(h_FmPcdOldPointer);
+
+    return E_OK;
+}
+t_Error FmPcdCcReleaseModifiedKey(t_Handle h_FmPcd, t_List *h_FmPcdOldPointersLst, t_Handle h_FmPcdNewPointer, uint16_t numOfGoodChanges)
+{
+    t_FmPcdModifyCcAdditionalParams *p_CcNewModifyAdditionalParams = (t_FmPcdModifyCcAdditionalParams *)h_FmPcdNewPointer;
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_CcNodeInfo                    *p_CcNodeInfo, *p_CcNodeInfo1;
+    t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdCcKeyAdditionalParams;
+    t_FmPcdCcNode                  *p_CurrentNode = NULL, *p_NodeForAdd, *p_NodeForRemove;
+    uint32_t                        numOfReplec;
+    t_List                          *p_Pos;
+    t_Error                         err;
+    uint16_t                        ccArray[MAX_NUM_OF_PCD_CC_NODES];
+
+    UNUSED(numOfGoodChanges);
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdOldPointersLst,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdNewPointer,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((numOfGoodChanges == LIST_NumOfObjs(h_FmPcdOldPointersLst)),E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_CcNewModifyAdditionalParams->h_AdditionalInfo,E_INVALID_HANDLE);
+
+            p_FmPcdCcKeyAdditionalParams  = (t_FmPcdModifyCcKeyAdditionalParams *)p_CcNewModifyAdditionalParams->h_AdditionalInfo;
+            p_CurrentNode = (t_FmPcdCcNode *)p_FmPcdCcKeyAdditionalParams->h_CurrentNode;
+            if(p_FmPcdCcKeyAdditionalParams->nodeIdForAdd != 0xffff)
+            {
+                p_NodeForAdd = GetNodeHandler(p_FmPcd, p_FmPcdCcKeyAdditionalParams->nodeIdForAdd);
+                ASSERT_COND(p_NodeForAdd);
+                p_CcNodeInfo = FindNodeInfoAccId(&p_NodeForAdd->ccPrevNodesLst, p_CurrentNode->nodeId);
+                if(p_CcNodeInfo)
+                {
+                    numOfReplec = p_CcNodeInfo->nextCcNodeInfo >> 16;
+                    numOfReplec +=1;
+                    p_CcNodeInfo->nextCcNodeInfo = (uint32_t)((p_CcNodeInfo->nextCcNodeInfo & 0x0000ffff) | (numOfReplec << 16));
+                }
+                else
+                {
+                    numOfReplec = (uint32_t)p_CurrentNode->nodeId | ((uint32_t)1<<16);
+                    CreateNodeInfo(&p_NodeForAdd->ccPrevNodesLst, numOfReplec);
+                }
+                CreateNodeInfo(&p_CurrentNode->ccNextNodesLst, (((uint32_t)p_FmPcdCcKeyAdditionalParams->keyIndexForAdd << 16) |(uint32_t)p_FmPcdCcKeyAdditionalParams->nodeIdForAdd));
+                LIST_FOR_EACH(p_Pos, &p_CurrentNode->ccTreesLst)
+                {
+                    p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+                    memset(ccArray, 0, sizeof(uint16_t)*MAX_NUM_OF_PCD_CC_NODES);
+                    err = UpdateNodesWithTree(p_FmPcd, &p_NodeForAdd->ccNextNodesLst, ccArray, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
+                    if(err)
+                        RETURN_ERROR(MAJOR, err, NO_MSG);
+                }
+            }
+            if(p_FmPcdCcKeyAdditionalParams->keyIndexForRemove != 0xffff)
+            {
+                p_CcNodeInfo =  FindNodeInfoAccIndex(&p_CurrentNode->ccNextNodesLst, p_FmPcdCcKeyAdditionalParams->keyIndexForRemove);
+                ASSERT_COND(p_CcNodeInfo);
+                p_NodeForRemove = GetNodeHandler(p_FmPcd, (uint16_t)p_CcNodeInfo->nextCcNodeInfo);
+                UpdateNodeOwner(p_FmPcd, (uint16_t)p_CcNodeInfo->nextCcNodeInfo, FALSE);
+                p_CcNodeInfo1 = FindNodeInfoAccId(&p_NodeForRemove->ccPrevNodesLst, p_CurrentNode->nodeId);
+                numOfReplec = p_CcNodeInfo1->nextCcNodeInfo >> 16;
+                ASSERT_COND(numOfReplec);
+                numOfReplec -=1;
+                if(numOfReplec)
+                    p_CcNodeInfo->nextCcNodeInfo = (uint32_t)((p_CcNodeInfo1->nextCcNodeInfo & 0x0000ffff) | (numOfReplec << 16));
+                else
+                {
+                    LIST_DelAndInit(&p_CcNodeInfo1->h_Node);
+                    XX_Free(p_CcNodeInfo1);
+                }
+                LIST_DelAndInit(&p_CcNodeInfo->h_Node);
+                XX_Free(p_CcNodeInfo);
+                LIST_FOR_EACH(p_Pos, &p_CurrentNode->ccTreesLst)
+                {
+                    p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+                    err = RemoveNodesFromTree(h_FmPcd, &p_NodeForRemove->ccNextNodesLst, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
+                    if(err)
+                        RETURN_ERROR(MAJOR, err, NO_MSG);
+                 }
+              }
+
+            ASSERT_COND(p_FmPcdCcKeyAdditionalParams->p_AdTableOld);
+            FM_MURAM_FreeMem(p_FmPcd->p_FmPcdCc->h_FmMuram,p_FmPcdCcKeyAdditionalParams->p_AdTableOld);
+            ASSERT_COND(p_FmPcdCcKeyAdditionalParams->p_KeysMatchTableOld);
+            FM_MURAM_FreeMem(p_FmPcd->p_FmPcdCc->h_FmMuram,p_FmPcdCcKeyAdditionalParams->p_KeysMatchTableOld);
+
+            p_CurrentNode->h_AdTable    = p_FmPcdCcKeyAdditionalParams->p_AdTableNew;
+            p_CurrentNode->numOfKeys    = p_FmPcdCcKeyAdditionalParams->numOfKeys;
+            p_CurrentNode->lclMask      = p_FmPcdCcKeyAdditionalParams->lclMask;
+            p_CurrentNode->h_KeysMatchTable = p_FmPcdCcKeyAdditionalParams->p_KeysMatchTableNew;
+
+            XX_Free(p_CcNewModifyAdditionalParams->h_AdditionalInfo);
+            p_CcNewModifyAdditionalParams->h_AdditionalInfo = NULL;
+
+    ReleaseLst(h_FmPcdOldPointersLst);
+
+    if(p_CcNewModifyAdditionalParams->p_Ad)
+        FM_MURAM_FreeMem(p_FmPcd->p_FmPcdCc->h_FmMuram,p_CcNewModifyAdditionalParams->p_Ad);
+
+    XX_Free(h_FmPcdNewPointer);
+
+    return E_OK;
+}
+
+uint32_t FmPcdCcGetNodeAddrOffset(t_Handle h_FmPcd, t_Handle h_Pointer)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE, (uint32_t)ILLEGAL_BASE);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdCc,E_INVALID_HANDLE, (uint32_t)ILLEGAL_BASE);
+
+    return (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(((t_FmPcdModifyCcAdditionalParams *)h_Pointer)->p_Ad)) -
+                     p_FmPcd->p_FmPcdCc->physicalMuramBase);
+}
+
+uint32_t FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd, t_Handle h_Pointer)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_CcNodeInfo                    *p_CcNodeInfo;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE, (uint32_t)ILLEGAL_BASE);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdCc,E_INVALID_HANDLE, (uint32_t)ILLEGAL_BASE);
+
+    p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(h_Pointer);
+    return (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(CAST_UINT32_TO_POINTER(p_CcNodeInfo->nextCcNodeInfo))) -
+                      p_FmPcd->p_FmPcdCc->physicalMuramBase);
+}
+
+static t_Error  FmPcdCcUpdateTreeOwner(t_Handle h_FmPcd, uint8_t treeId, bool add)
+{
+
+
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[treeId].p_FmPcdCcTree,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((treeId < MAX_NUM_OF_PCD_CC_TREES), E_INVALID_VALUE);
+
+    if(add)
+        p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[treeId].owners++;
+    else
+    {
+        if(!p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[treeId].owners)
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("this tree wasn't assighned before"))  ;
+        p_FmPcd->p_FmPcdCc->ccTreeArrayEntry[treeId].owners--;
+    }
+
+    return E_OK;
+}
+
+t_Error     CcGetGrpParams(t_Handle h_FmPcdCcTree, uint8_t grpId, uint32_t *p_GrpBits, uint8_t *p_GrpBase)
+{
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *) h_FmPcdCcTree;
+
+    SANITY_CHECK_RETURN_ERROR((grpId <= 7),E_INVALID_STATE);
+
+    if(grpId >= p_FmPcdCcTree->numOfGrps)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("grpId you asked > numOfGroup of relevant tree"));
+    *p_GrpBits = p_FmPcdCcTree->fmPcdGroupParam[grpId].totalBitsMask;
+    *p_GrpBase = p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry;
+    return E_OK;
+}
+
+t_Handle CcConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
+{
+    t_FmPcdCc           *p_FmPcdCc;
+#ifdef CONFIG_GUEST_PARTITION
+    t_FmPcdIcPhysAddr   physicalMuramBase;
+    t_Error             err;
+#else
+    t_FmPhysAddr        physicalMuramBase;
+#endif /* CONFIG_GUEST_PARTITION */
+
+    UNUSED(p_FmPcd);
+    p_FmPcdCc = (t_FmPcdCc *) XX_Malloc(sizeof(t_FmPcdCc));
+    if (!p_FmPcdCc)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Cc allocation FAILED"));
+        return NULL;
+    }
+    memset(p_FmPcdCc, 0, sizeof(t_FmPcdCc));
+
+    p_FmPcdCc->h_FmMuram = p_FmPcdParams->h_FmMuram;
+#ifndef CONFIG_GUEST_PARTITION
+    FmGetPhysicalMuramBase(p_FmPcdParams->h_Fm, &physicalMuramBase);
+#else
+    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_GET_PHYS_MURAM_BASE, (uint8_t*)&physicalMuramBase, NULL, NULL);
+    if(err)
+    {
+        REPORT_ERROR(MINOR, err, NO_MSG);
+    }
+#endif /* CONFIG_GUEST_PARTITION */
+    p_FmPcdCc->physicalMuramBase = (uint64_t)((uint64_t)(&physicalMuramBase)->low | ((uint64_t)(&physicalMuramBase)->high << 32));
+
+    return p_FmPcdCc;
+}
+
+void CcFree(t_FmPcdCc *p_FmPcdCc)
+{
+
+    int i = 0;
+    for (i = 0; i < MAX_NUM_OF_PCD_CC_NODES; i++)
+        ReleaseNode(p_FmPcdCc, (uint16_t)i);
+
+    for(i = 0; i < MAX_NUM_OF_PCD_CC_TREES; i++)
+        ReleaseTree(p_FmPcdCc, (uint8_t)i);
+}
+
+t_Error  FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle  h_FmPcdCcTree,  uint32_t  *p_Offset)
+{
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdCcTree       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_Error             err;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcTree,E_INVALID_STATE);
+
+    err = FmPcdCcUpdateTreeOwner(h_FmPcd, p_FmPcdCcTree->treeId, TRUE);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    *p_Offset = CAST_POINTER_TO_UINT32(XX_VirtToPhys(CAST_UINT32_TO_POINTER((uint32_t)p_FmPcdCcTree->p_CcBaseTree))) - ((t_FmPcd *)p_FmPcd)->p_FmPcdCc->physicalMuramBase;
+
+    return E_OK;
+}
+
+t_Error FmPcdCcUnbindTree(t_Handle h_FmPcd, t_Handle  h_FmPcdCcTree)
+{
+    t_FmPcdCcTree       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcTree,E_INVALID_HANDLE);
+
+    return  FmPcdCcUpdateTreeOwner(h_FmPcd, p_FmPcdCcTree->treeId, FALSE);
+}
+
+t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsParam)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdCc                   *p_FmPcdCc;
+    t_Error                     err;
+    uint8_t                     treeId;
+    int                         i = 0, j = 0, k = 0;
+    t_FmPcdCcTree               *p_FmPcdCcTree;
+    uint8_t                     numOfEntries;
+    t_Handle                    p_CcTreeTmp;
+    t_FmPcdCcGrpParams          *p_FmPcdCcGroupParams;
+    t_FmPcdCcNextEngineParams   params[16];
+    t_NetEnvParams              netEnvParams;
+    uint8_t                     lastOne = 0;
+    t_CcNodeInfo                *p_CcNodeInfo;
+    t_NextEngineParamsInfo      nextEngineParamsInfo;
+    uint16_t                    ccInfo[MAX_NUM_OF_PCD_CC_NODES];
+    t_FmPcdCcNode               *p_FmPcdCcNextNode;
+    t_List                      *p_Pos;
+    t_List                      ccNextDifferentNodesLst;
+    uint32_t                    myInfo;
+    uint16_t                     ccArray[MAX_NUM_OF_PCD_CC_NODES];
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_PcdGroupsParam,E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdCc,E_INVALID_STATE, NULL);
+
+    memset(ccInfo, 0, sizeof(uint8_t) * MAX_NUM_OF_PCD_CC_NODES);
+    memset(ccArray, 0, sizeof(uint16_t) * MAX_NUM_OF_PCD_CC_NODES);
+
+    memset(params, 0, 16 * sizeof(t_FmPcdCcNextEngineParams));
+    p_FmPcdCc = p_FmPcd->p_FmPcdCc;
+
+    err = OccupyTreeId(p_FmPcd, &treeId);
+    if(err)
+    {
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        return NULL;
+    }
+
+    p_FmPcdCcTree = (t_FmPcdCcTree*)XX_Malloc (sizeof(t_FmPcdCcTree));
+    if(!p_FmPcdCcTree)
+    {
+        ReleaseTree(p_FmPcdCc,treeId);
+        ReleaseTreeHandler(p_FmPcdCcTree,p_FmPcdCc);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+        return NULL;
+    }
+    memset(p_FmPcdCcTree, 0, sizeof(t_FmPcdCcTree)) ;
+
+    INIT_LIST(&p_FmPcdCcTree->ccNextNodesLst);
+    INIT_LIST(&p_FmPcdCcTree->fmPortsLst);
+    INIT_LIST(&ccNextDifferentNodesLst);
+
+    if(p_PcdGroupsParam->numOfGrps > 8)
+    {
+        ReleaseTree(p_FmPcdCc,treeId);
+        ReleaseTreeHandler(p_FmPcdCcTree,p_FmPcdCc);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("numOfGrps can not be greater than 8"));
+        return NULL;
+    }
+    numOfEntries = 0;
+    p_FmPcdCcTree->netEnvId = (uint8_t)(CAST_POINTER_TO_UINT32(p_PcdGroupsParam->h_NetEnv)-1);
+    for(i = 0; i < p_PcdGroupsParam->numOfGrps; i++)
+    {
+        p_FmPcdCcGroupParams = &p_PcdGroupsParam->ccGrpParams[i];
+        p_FmPcdCcTree->fmPcdGroupParam[i].baseGroupEntry = numOfEntries;
+        p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup =(uint8_t)( 0x01 << p_FmPcdCcGroupParams->numOfDistinctionUnits);
+        numOfEntries += p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup;
+        if(numOfEntries > 16)
+        {
+            ReleaseTree(p_FmPcdCc,treeId);
+            ReleaseTreeHandler(p_FmPcdCcTree,p_FmPcdCc);
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("numOfEntries can not be larger than 16"));
+            return NULL;
+        }
+        if(lastOne)
+        {
+            if(p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup > lastOne)
+            {
+                ReleaseTree(p_FmPcdCc,treeId);
+                ReleaseTreeHandler(p_FmPcdCcTree,p_FmPcdCc);
+                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("numOfEntries per group in Tree has to  be from biggest to lower"));
+                return NULL;
+            }
+        }
+
+        lastOne = p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup;
+
+        netEnvParams.netEnvId = p_FmPcdCcTree->netEnvId;
+        netEnvParams.numOfDistinctionUnits = p_FmPcdCcGroupParams->numOfDistinctionUnits;
+        memcpy(netEnvParams.unitIds, &p_FmPcdCcGroupParams->unitIds, p_FmPcdCcGroupParams->numOfDistinctionUnits);
+        err = PcdGetUnitsVector(p_FmPcd, &netEnvParams);
+        if(err)
+        {
+            ReleaseTree(p_FmPcdCc,treeId);
+            ReleaseTreeHandler(p_FmPcdCcTree,p_FmPcdCc);
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+            return NULL;
+        }
+
+        p_FmPcdCcTree->fmPcdGroupParam[i].totalBitsMask = netEnvParams.vector;
+        for(j = 0; j < p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup; j++)
+        {
+
+            err = ValidateNextEngineParams(h_FmPcd,&p_FmPcdCcGroupParams->p_NextEnginePerEntriesInGrp[j], &nextEngineParamsInfo);
+            if(err)
+            {
+                ReleaseTree(p_FmPcdCc,treeId);
+                ReleaseTreeHandler(p_FmPcdCcTree,p_FmPcdCc);
+                REPORT_ERROR(MAJOR, err, (NO_MSG));
+                return NULL;
+            }
+            if(nextEngineParamsInfo.fmPcdEngine == e_FM_PCD_CC)
+            {
+                myInfo = (uint32_t)nextEngineParamsInfo.additionalInfo | (uint32_t)k << 16;
+                CreateNodeInfo(&p_FmPcdCcTree->ccNextNodesLst, myInfo);
+                if(ccInfo[nextEngineParamsInfo.additionalInfo] == 0)
+                    CreateNodeInfo(&ccNextDifferentNodesLst, (uint32_t)nextEngineParamsInfo.additionalInfo);
+
+                ccInfo[nextEngineParamsInfo.additionalInfo] +=1;
+            }
+           memcpy(&params[k], &p_FmPcdCcGroupParams->p_NextEnginePerEntriesInGrp[j], sizeof(t_FmPcdCcNextEngineParams));
+           k++;
+        }
+    }
+
+    p_FmPcdCcTree->numOfGrps = p_PcdGroupsParam->numOfGrps;
+    p_FmPcdCcTree->p_CcBaseTree = FM_MURAM_AllocMem(p_FmPcdCc->h_FmMuram,
+                                         (uint32_t)( k * FM_PCD_CC_AD_ENTRY_SIZE),
+                                         FM_PCD_CC_AD_TABLE_ALIGN);
+
+    if(!p_FmPcdCcTree->p_CcBaseTree)
+    {
+        ReleaseTree(p_FmPcdCc,treeId);
+        ReleaseTreeHandler(p_FmPcdCcTree,p_FmPcdCc);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+        return NULL;
+    }
+    WRITE_BLOCK((uint8_t *)p_FmPcdCcTree->p_CcBaseTree, 0, (uint32_t)(k * FM_PCD_CC_AD_ENTRY_SIZE));
+
+    p_CcTreeTmp  = p_FmPcdCcTree->p_CcBaseTree;
+
+    j = 0;
+    for(i = 0; i < numOfEntries; i++)
+    {
+        NextStepAd(p_CcTreeTmp,&params[i],p_FmPcd);
+        p_CcTreeTmp =   (t_Handle)(((uint32_t)p_CcTreeTmp) + FM_PCD_CC_AD_ENTRY_SIZE);
+    }
+
+    if(!LIST_IsEmpty(&ccNextDifferentNodesLst))
+    {
+        LIST_FOR_EACH(p_Pos, &ccNextDifferentNodesLst)
+        {
+            p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+            p_FmPcdCcNextNode = (t_FmPcdCcNode *)GetNodeHandler(p_FmPcd, (uint16_t)p_CcNodeInfo->nextCcNodeInfo);
+            if(!p_FmPcdCcNextNode)
+            {
+                ReleaseTree(p_FmPcdCc,treeId);
+                ReleaseTreeHandler(p_FmPcdCcTree,p_FmPcdCc);
+                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+                return NULL;
+            }
+            myInfo = (uint32_t)treeId | ((uint32_t)ccInfo[p_CcNodeInfo->nextCcNodeInfo] << 16);
+            CreateNodeInfo(&p_FmPcdCcNextNode->ccTreeIdLst, myInfo);
+        }
+    }
+
+    ReleaseLst(&ccNextDifferentNodesLst);
+    p_FmPcdCcTree->treeId = treeId;
+    SetTreeHandler(p_FmPcdCc, treeId, p_FmPcdCcTree);
+
+    FmPcdIncNetEnvOwners(h_FmPcd, p_FmPcdCcTree->netEnvId);
+
+    err = UpdateNodesWithTree(h_FmPcd, &p_FmPcdCcTree->ccNextNodesLst, ccArray, treeId);
+    if(err)
+    {
+        ReleaseTree(p_FmPcdCc,treeId);
+        ReleaseTreeHandler(p_FmPcdCcTree,p_FmPcdCc);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+        return NULL;
+    }
+    return p_FmPcdCcTree;
+}
+
+t_Error FM_PCD_CcDeleteTree(t_Handle h_FmPcd, t_Handle h_CcTree)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdCcTree               *p_CcTree = (t_FmPcdCcTree *)h_CcTree;
+    uint32_t                    nodeIdTmp;
+    t_List                      *p_Pos;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_CcTree,E_INVALID_STATE);
+
+    FmPcdDecNetEnvOwners(h_FmPcd, p_CcTree->netEnvId);
+
+    if(GetTreeOwners(p_FmPcd, p_CcTree->treeId))
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("the tree with this ID can not be removed because this tree is occupied, first - unbind this tree"));
+
+    LIST_FOR_EACH(p_Pos, &p_CcTree->ccNextNodesLst)
+    {
+        nodeIdTmp = ((t_CcNodeInfo *)CC_NEXT_NODE_F_OBJECT(p_Pos))->nextCcNodeInfo;
+        UpdateNodeOwner(p_FmPcd, (uint16_t)nodeIdTmp, FALSE);
+    }
+
+    ReleaseTree(p_FmPcd->p_FmPcdCc, p_CcTree->treeId);
+
+    return E_OK;
+}
+
+t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd *) h_FmPcd;
+    t_FmPcdCcNode       *p_FmPcdCcNode, *p_FmPcdCcNextNode;
+    t_FmPcdCc           *p_FmPcdCc;
+    t_Error             err;
+    int                 tmp, size;
+    bool                glblMask = FALSE;
+    t_FmPcdCcKeyParams  *p_KeyParams;
+    t_Handle            p_KeysMatchTblTmp;
+    t_Handle            p_AdTableTmp;
+    bool                fullField = FALSE;
+    uint16_t            nodeId;
+    t_NextEngineParamsInfo nextEngineParamsInfo;
+    uint16_t            profileInfo[FM_PCD_PLCR_NUM_ENTRIES];
+    uint16_t            ccInfo[MAX_NUM_OF_PCD_CC_NODES];
+    uint8_t             ccDifferentInfo[MAX_NUM_OF_PCD_CC_NODES];
+    t_List              *p_Pos;
+    t_CcNodeInfo        *p_CcNodeInfo;
+    t_List              ccNextDifferentNodesLst;
+    uint32_t            myInfo;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE,NULL);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdCc,E_INVALID_STATE,NULL);
+
+    memset(profileInfo, 0x00, FM_PCD_PLCR_NUM_ENTRIES*sizeof(uint16_t));
+    memset(ccInfo, 0x00, MAX_NUM_OF_PCD_CC_NODES*sizeof(uint16_t));
+    memset(ccDifferentInfo, 0x00, MAX_NUM_OF_PCD_CC_NODES*sizeof(uint8_t));
+
+    p_FmPcdCc = p_FmPcd->p_FmPcdCc;
+
+    if((p_CcNodeParam->keysParams.keySize > 4 )&& (p_CcNodeParam->keysParams.p_GlblMask))
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Global Mask is relevant only for keySize less or equal than 4"));
+        return NULL;
+    }
+
+    err = ValidateNextEngineParams(h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, &nextEngineParamsInfo);
+    if(err)
+    {
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        return NULL;
+    }
+
+    err = OccupyNodeId(p_FmPcd, &nodeId);
+    if(err)
+    {
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        return NULL;
+    }
+
+    p_FmPcdCcNode = (t_FmPcdCcNode*)XX_Malloc(sizeof(t_FmPcdCcNode));
+    if(!p_FmPcdCcNode)
+    {
+        ReleaseNode(p_FmPcdCc,nodeId);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+        return NULL;
+    }
+    memset(p_FmPcdCcNode, 0, sizeof(t_FmPcdCcNode));
+
+    INIT_LIST(&p_FmPcdCcNode->ccNextNodesLst);
+    INIT_LIST(&p_FmPcdCcNode->ccPrevNodesLst);
+    INIT_LIST(&p_FmPcdCcNode->ccTreeIdLst);
+    INIT_LIST(&p_FmPcdCcNode->ccTreesLst);
+
+    INIT_LIST(&ccNextDifferentNodesLst);
+
+    if(nextEngineParamsInfo.fmPcdEngine == e_FM_PCD_CC)
+    {
+        myInfo = (uint32_t)nextEngineParamsInfo.additionalInfo | (uint32_t)(p_CcNodeParam->keysParams.numOfKeys << 16);
+        CreateNodeInfo(&p_FmPcdCcNode->ccNextNodesLst, myInfo);
+        if(ccInfo[nextEngineParamsInfo.additionalInfo] == 0)
+            CreateNodeInfo(&ccNextDifferentNodesLst, (uint32_t)nextEngineParamsInfo.additionalInfo);
+        ccInfo[nextEngineParamsInfo.additionalInfo] +=1;
+    }
+
+    p_FmPcdCcNode->numOfKeys = p_CcNodeParam->keysParams.numOfKeys;
+
+    p_FmPcdCcNode->p_GlblMask = (t_Handle)XX_Malloc(p_CcNodeParam->keysParams.keySize * sizeof(uint8_t));
+    memset(p_FmPcdCcNode->p_GlblMask, 0, p_CcNodeParam->keysParams.keySize * sizeof(uint8_t));
+
+    if(p_CcNodeParam->keysParams.p_GlblMask)
+    {
+        memcpy((void*)p_FmPcdCcNode->p_GlblMask,p_CcNodeParam->keysParams.p_GlblMask,p_CcNodeParam->keysParams.keySize);
+        glblMask = TRUE;
+        p_FmPcdCcNode->glblMaskSize = (uint8_t)p_CcNodeParam->keysParams.keySize;
+    }
+    else
+     {   memset(p_FmPcdCcNode->p_GlblMask, 0xff, 4);
+         p_FmPcdCcNode->glblMaskSize = 4;
+     }
+
+    switch(p_CcNodeParam->extractCcParams.type)
+    {
+        case(e_FM_PCD_EXTRACT_BY_HDR):
+            switch(p_CcNodeParam->extractCcParams.extractParams.extractByHdr.type)
+            {
+                case(e_FM_PCD_EXTRACT_FULL_FIELD):
+                    p_FmPcdCcNode->parseCode = GetFullFieldParseCode(p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdrIndex,
+                                                                    p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fullField);
+                    GetSizeHeaderField(p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fullField, &p_FmPcdCcNode->sizeOfExtraction);
+                    fullField = TRUE;
+                    break;
+                    case(e_FM_PCD_EXTRACT_FROM_HDR):
+                        p_FmPcdCcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fromHdr.size;
+                        p_FmPcdCcNode->offset =  p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fromHdr.offset;
+                        p_FmPcdCcNode->parseCode = GetPrParseCode(p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdrIndex,
+                                                                p_FmPcdCcNode->offset,glblMask, &p_FmPcdCcNode->prsArrayOffset);
+                        break;
+                case(e_FM_PCD_EXTRACT_FROM_FIELD):
+                        p_FmPcdCcNode->offset = p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fromField.offset;
+                        p_FmPcdCcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fromField.size;
+                        p_FmPcdCcNode->parseCode = GetFieldParseCode(p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractParams.extractByHdr.extractByHdrType.fromField.field,
+                                                    p_FmPcdCcNode->offset,&p_FmPcdCcNode->prsArrayOffset,
+                                                    p_CcNodeParam->extractCcParams.extractParams.extractByHdr.hdrIndex);
+                        break;
+                default:
+                    ReleaseNode(p_FmPcdCc,nodeId);
+                    ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+                    REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+                    return NULL;
+            }
+            break;
+        case(e_FM_PCD_EXTRACT_NON_HDR):
+            /* get the field code for the generic extract */
+            p_FmPcdCcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractParams.extractNonHdr.size;
+            p_FmPcdCcNode->offset =  p_CcNodeParam->extractCcParams.extractParams.extractNonHdr.offset;
+            p_FmPcdCcNode->parseCode = GetGenParseCode(p_CcNodeParam->extractCcParams.extractParams.extractNonHdr.src, p_FmPcdCcNode->offset, glblMask, &p_FmPcdCcNode->prsArrayOffset);
+            break;
+
+       default:
+            ReleaseNode(p_FmPcdCc,nodeId);
+            ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            return NULL;
+    }
+
+    if(p_FmPcdCcNode->parseCode == CC_PC_ILLEGAL)
+    {
+        ReleaseNode(p_FmPcdCc,nodeId);
+        ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("illeagl extraction type"));
+        return NULL;
+    }
+
+    if(((p_FmPcdCcNode->parseCode == CC_PC_FF_IPV4TTL) || (p_FmPcdCcNode->parseCode == CC_PC_FF_IPV6HOP_LIMIT)) && (p_FmPcdCcNode->numOfKeys != 1 ))
+    {
+        ReleaseNode(p_FmPcdCc,nodeId);
+        ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("for IPV4TTL and IPV6_HOP_LIMIT has to be only 1 key - TTL = 1, otherwise it's Miss"));
+        return NULL;
+    }
+
+    if((p_FmPcdCcNode->sizeOfExtraction > MAX_SIZE_OF_KEY) || !p_FmPcdCcNode->sizeOfExtraction)
+    {
+        ReleaseNode(p_FmPcdCc,nodeId);
+        ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("sizeOfExatrction can not be greater than 56 and not 0"));
+        return NULL;
+    }
+
+    if(p_CcNodeParam->keysParams.keySize !=p_FmPcdCcNode->sizeOfExtraction)
+    {
+        ReleaseNode(p_FmPcdCc,nodeId);
+        ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("keySize has to be equal to sizeOfExtraction"));
+        return NULL;
+    }
+
+    GetCcExtractKeySize(p_FmPcdCcNode->sizeOfExtraction, &p_FmPcdCcNode->ccKeySizeAccExtraction);
+
+    for(tmp = 0 ; tmp < p_FmPcdCcNode->numOfKeys; tmp++)
+    {
+        p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
+        if((p_FmPcdCcNode->parseCode != CC_PC_FF_IPV4TTL) && (p_FmPcdCcNode->parseCode != CC_PC_FF_IPV6HOP_LIMIT))
+        {
+            if(!p_KeyParams->p_Key)
+            {
+                ReleaseNode(p_FmPcdCc,nodeId);
+                ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("numOfKeys is not match defined parameters - p_Key is not initialized"));
+                return NULL;
+            }
+
+            if(p_KeyParams->p_Mask && glblMask)
+            {
+                ReleaseNode(p_FmPcdCc,nodeId);
+                ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Can not be used globalMask and localMask"));
+                return NULL;
+            }
+        }
+        err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams, &nextEngineParamsInfo);
+        if(err)
+        {
+            ReleaseNode(p_FmPcdCc,nodeId);
+            ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+            REPORT_ERROR(MAJOR, err, (NO_MSG));
+            return NULL;
+        }
+        if(nextEngineParamsInfo.fmPcdEngine == e_FM_PCD_CC)
+        {
+            myInfo = (uint32_t)nextEngineParamsInfo.additionalInfo | (uint32_t)tmp << 16;
+            CreateNodeInfo(&p_FmPcdCcNode->ccNextNodesLst,myInfo);
+            if(ccInfo[nextEngineParamsInfo.additionalInfo] == 0)
+                CreateNodeInfo(&ccNextDifferentNodesLst, (uint32_t)nextEngineParamsInfo.additionalInfo);
+            ccInfo[nextEngineParamsInfo.additionalInfo] +=1;
+        }
+        if(p_KeyParams->p_Mask)
+            p_FmPcdCcNode->lclMask = TRUE;
+    }
+
+    if(p_FmPcdCcNode->lclMask)
+        size = 2 * p_FmPcdCcNode->ccKeySizeAccExtraction;
+    else
+        size = p_FmPcdCcNode->ccKeySizeAccExtraction;
+
+    if((p_FmPcdCcNode->parseCode != CC_PC_FF_IPV4TTL) && (p_FmPcdCcNode->parseCode != CC_PC_FF_IPV6HOP_LIMIT))
+    {
+        p_FmPcdCcNode->h_KeysMatchTable =(t_Handle)FM_MURAM_AllocMem(p_FmPcdCc->h_FmMuram,
+                                         (uint32_t)(size * sizeof(uint8_t) * (p_FmPcdCcNode->numOfKeys + 1)),
+                                         FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
+        if(!p_FmPcdCcNode->h_KeysMatchTable)
+        {
+            ReleaseNode(p_FmPcdCc,nodeId);
+            ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory in MURAM for KEY MATCH table"));
+            return NULL;
+        }
+        WRITE_BLOCK((uint8_t *)p_FmPcdCcNode->h_KeysMatchTable, 0, size * sizeof(uint8_t) * (p_FmPcdCcNode->numOfKeys + 1));
+    }
+
+    p_FmPcdCcNode->h_AdTable = (t_Handle)FM_MURAM_AllocMem(p_FmPcdCc->h_FmMuram,
+                                     (uint32_t)( (p_FmPcdCcNode->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE),
+                                     FM_PCD_CC_AD_TABLE_ALIGN);
+    if(!p_FmPcdCcNode->h_AdTable)
+    {
+        ReleaseNode(p_FmPcdCc,nodeId);
+        ReleaseNodeHandler(p_FmPcdCcNode,p_FmPcdCc);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory in MURAM ffor AD table "));
+        return NULL;
+    }
+    WRITE_BLOCK((uint8_t *)p_FmPcdCcNode->h_AdTable, 0, (uint32_t)((p_FmPcdCcNode->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE));
+
+    p_KeysMatchTblTmp    = p_FmPcdCcNode->h_KeysMatchTable;
+    p_AdTableTmp         = p_FmPcdCcNode->h_AdTable;
+    for(tmp = 0 ; tmp < p_FmPcdCcNode->numOfKeys; tmp++)
+    {
+        p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
+
+        if(p_KeysMatchTblTmp)
+        {
+
+            COPY_BLOCK((void*)p_KeysMatchTblTmp, p_KeyParams->p_Key, p_FmPcdCcNode->sizeOfExtraction);
+
+            if(p_FmPcdCcNode->lclMask && p_KeyParams->p_Mask)
+                COPY_BLOCK((void*)(((uint32_t)p_KeysMatchTblTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction), p_KeyParams->p_Mask, p_FmPcdCcNode->sizeOfExtraction);
+            else if(p_FmPcdCcNode->lclMask)
+                WRITE_BLOCK((void*)(((uint32_t)p_KeysMatchTblTmp) + p_FmPcdCcNode->ccKeySizeAccExtraction),0xff, p_FmPcdCcNode->sizeOfExtraction);
+            p_KeysMatchTblTmp = (t_Handle)(((uint32_t)p_KeysMatchTblTmp) + size * sizeof(uint8_t));
+        }
+        NextStepAd(p_AdTableTmp,&p_KeyParams->ccNextEngineParams, p_FmPcd);
+
+        p_AdTableTmp =   (t_Handle)(((uint32_t)p_AdTableTmp) + FM_PCD_CC_AD_ENTRY_SIZE);
+
+    }
+    NextStepAd(p_AdTableTmp,&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, p_FmPcd);
+
+    if(fullField == TRUE)
+        p_FmPcdCcNode->sizeOfExtraction = 0;
+
+
+    if(!LIST_IsEmpty(&ccNextDifferentNodesLst))
+    {
+        LIST_FOR_EACH(p_Pos, &ccNextDifferentNodesLst)
+        {
+            p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+            p_FmPcdCcNextNode = (t_FmPcdCcNode *)GetNodeHandler(p_FmPcd, (uint16_t)p_CcNodeInfo->nextCcNodeInfo);
+            if(!p_FmPcdCcNextNode)
+            {
+                ReleaseNode(p_FmPcdCc,nodeId);
+                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+                return NULL;
+            }
+            myInfo = (uint32_t)nodeId | ((uint32_t)ccInfo[(uint16_t)p_CcNodeInfo->nextCcNodeInfo] << 16);
+            CreateNodeInfo(&p_FmPcdCcNextNode->ccPrevNodesLst, myInfo);
+        }
+    }
+    ReleaseLst(&ccNextDifferentNodesLst);
+    p_FmPcdCcNode->nodeId = nodeId;
+    SetNodeHandler(p_FmPcdCc, nodeId, p_FmPcdCcNode);
+    return p_FmPcdCcNode;
+}
+
+t_Error FM_PCD_CcDeleteNode(t_Handle h_FmPcd, t_Handle h_CcNode)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdCcNode               *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint32_t                    nodeIdTmp;
+    t_List                      *p_Pos;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc,E_INVALID_STATE);
+
+    if(!p_CcNode)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("the node with this ID is not initialized"));
+
+    if(GetNodeOwners(p_FmPcd, p_CcNode->nodeId))
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("the node with this ID can not be removed because this node is occupied, first - unbind this node"));
+
+    LIST_FOR_EACH(p_Pos, &p_CcNode->ccNextNodesLst)
+    {
+        nodeIdTmp = ((t_CcNodeInfo *)CC_NEXT_NODE_F_OBJECT(p_Pos))->nextCcNodeInfo;
+        UpdateNodeOwner(p_FmPcd, (uint16_t)nodeIdTmp, FALSE);
+
+    }
+
+    ReleaseNode(p_FmPcd->p_FmPcdCc, p_CcNode->nodeId);
+    return E_OK;
+}
+
+t_Error FM_PCD_CcTreeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    return FmHcPcdCcModifyTreeNextEngine(p_FmPcd->h_Hc, h_CcTree, grpId, index, p_FmPcdCcNextEngineParams);
+}
+
+t_Error FM_PCD_CcNodeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    return FmHcPcdCcModifyNodeNextEngine(p_FmPcd->h_Hc, h_CcNode, keyIndex, p_FmPcdCcNextEngineParams);
+}
+
+t_Error FM_PCD_CcNodeModifyMissNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    return FmHcPcdCcModifyNodeMissNextEngine(p_FmPcd->h_Hc, h_CcNode, p_FmPcdCcNextEngineParams);
+}
+
+t_Error FM_PCD_CcNodeRemoveKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    return FmHcPcdCcRemoveKey(p_FmPcd->h_Hc, h_CcNode, keyIndex);
+}
+
+t_Error FM_PCD_CcNodeAddKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    return FmHcPcdCcAddKey(p_FmPcd->h_Hc, h_CcNode, keyIndex, keySize, p_KeyParams);
+}
+
+t_Error FM_PCD_CcNodeModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    return FmHcPcdCcModifyKeyAndNextEngine(p_FmPcd->h_Hc, h_CcNode, keyIndex, keySize, p_KeyParams);
+}
+
+t_Error FM_PCD_CcNodeModifyKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, uint8_t  *p_Key, uint8_t *p_Mask)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdCc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    return FmHcPcdCcModifyKey(p_FmPcd->h_Hc, h_CcNode, keyIndex, keySize, p_Key, p_Mask);
+}
+
+void FmPcdCcNodeTreeReleaseLock(t_Handle h_FmPcd, t_List *p_List)
+{
+    t_List          *p_Pos;
+    t_CcNodeInfo    *p_CcNodeInfo;
+    t_Handle        h_FmPcdCcTree;
+
+    LIST_FOR_EACH(p_Pos, p_List)
+    {
+        p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+        h_FmPcdCcTree = FmPcdCcGetTreeHandler(h_FmPcd, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
+        FmPcdCcTreeReleaseLock(h_FmPcdCcTree);
+    }
+}
+
+t_Error FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *p_List)
+{
+    t_FmPcdCcNode   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_List          *p_Pos;
+    t_CcNodeInfo    *p_CcNodeInfo;
+    t_Handle        h_FmPcdCcTree;
+    t_Error         err;
+
+    if(LIST_IsEmpty(&p_FmPcdCcNode->ccTreesLst))
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("asked for more nodes in CC than MAX"))  ;
+    LIST_FOR_EACH(p_Pos, &p_FmPcdCcNode->ccTreesLst)
+    {
+        p_CcNodeInfo = CC_NEXT_NODE_F_OBJECT(p_Pos);
+        h_FmPcdCcTree = FmPcdCcGetTreeHandler(h_FmPcd, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
+        err = FmPcdCcTreeTryLock(h_FmPcdCcTree);
+        if(err == E_OK)
+            CreateNodeInfo(p_List, (uint8_t)p_CcNodeInfo->nextCcNodeInfo);
+        else
+        {
+            FmPcdCcNodeTreeReleaseLock(h_FmPcd, p_List);
+            ReleaseLst(p_List);
+
+        }
+    }
+
+    return err;
+}
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
new file mode 100644
index 0000000..7a31cfd
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
@@ -0,0 +1,2822 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_kg.c
+
+ @Description   FM PCD ...
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "debug_ext.h"
+#include "net_ext.h"
+#include "fm_pcd.h"
+#include "fm_port_ext.h"
+#include "fm_hc.h"
+
+
+static e_FmPcdKgExtractDfltSelect GetGenericSwDefault(t_FmPcdKgExtractDflt swDefaults[], uint8_t numOfSwDefaults, uint8_t code)
+{
+    int i;
+
+    switch(code)
+    {
+        case( KG_SCH_GEN_PARSE_RESULT):
+        case( KG_SCH_GEN_DEFAULT):
+        case( KG_SCH_GEN_NEXTHDR):
+            for(i=0 ; i<numOfSwDefaults ; i++)
+                if(swDefaults[i].type == e_FM_PCD_KG_GENERIC_NOT_FROM_DATA)
+                    return swDefaults[i].dfltSelect;
+            ASSERT_COND(FALSE);
+        case( KG_SCH_GEN_SHIM1):
+        case( KG_SCH_GEN_SHIM2):
+        case( KG_SCH_GEN_SHIM3):
+        case( KG_SCH_GEN_ETH_NO_V):
+        case( KG_SCH_GEN_SNAP_NO_V):
+        case( KG_SCH_GEN_VLAN1_NO_V):
+        case( KG_SCH_GEN_VLAN2_NO_V):
+        case( KG_SCH_GEN_ETH_TYPE_NO_V):
+        case( KG_SCH_GEN_PPP_NO_V):
+        case( KG_SCH_GEN_MPLS1_NO_V):
+        case( KG_SCH_GEN_MPLS_LAST_NO_V):
+        case( KG_SCH_GEN_L3_NO_V):
+        case( KG_SCH_GEN_IP2_NO_V):
+        case( KG_SCH_GEN_GRE_NO_V):
+        case( KG_SCH_GEN_L4_NO_V):
+            for(i=0 ; i<numOfSwDefaults ; i++)
+                if(swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V)
+                    return swDefaults[i].dfltSelect;
+
+        case( KG_SCH_GEN_START_OF_FRM):
+        case( KG_SCH_GEN_ETH):
+        case( KG_SCH_GEN_SNAP):
+        case( KG_SCH_GEN_VLAN1):
+        case( KG_SCH_GEN_VLAN2):
+        case( KG_SCH_GEN_ETH_TYPE):
+        case( KG_SCH_GEN_PPP):
+        case( KG_SCH_GEN_MPLS1):
+        case( KG_SCH_GEN_MPLS2):
+        case( KG_SCH_GEN_MPLS3):
+        case( KG_SCH_GEN_MPLS_LAST):
+        case( KG_SCH_GEN_IPV4):
+        case( KG_SCH_GEN_IPV6):
+        case( KG_SCH_GEN_IPV4_TUNNELED):
+        case( KG_SCH_GEN_IPV6_TUNNELED):
+        case( KG_SCH_GEN_MIN_ENCAP):
+        case( KG_SCH_GEN_GRE):
+        case( KG_SCH_GEN_TCP):
+        case( KG_SCH_GEN_UDP):
+        case( KG_SCH_GEN_IPSEC_AH):
+        case( KG_SCH_GEN_SCTP):
+        case( KG_SCH_GEN_DCCP):
+        case( KG_SCH_GEN_IPSEC_ESP):
+            for(i=0 ; i<numOfSwDefaults ; i++)
+                if(swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA)
+                    return swDefaults[i].dfltSelect;
+            ASSERT_COND(FALSE);
+        default:
+            return e_FM_PCD_KG_DFLT_ILLEGAL;
+    }
+}
+
+static uint8_t GetGenCode(e_FmPcdExtractFrom src)
+{
+    switch(src)
+    {
+        case(e_FM_PCD_EXTRACT_FROM_FRAME_START):
+            return KG_SCH_GEN_START_OF_FRM;
+        case(e_FM_PCD_KG_EXTRACT_FROM_DFLT_VALUE):
+            return KG_SCH_GEN_DEFAULT;
+        case(e_FM_PCD_KG_EXTRACT_FROM_PARSE_RESULT):
+            return KG_SCH_GEN_PARSE_RESULT;
+        case(e_FM_PCD_KG_EXTRACT_FROM_CURR_END_OF_PARSE):
+            return KG_SCH_GEN_NEXTHDR;
+        default:
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 'extract from' src"));
+            return 0;
+    }
+}
+
+static uint8_t GetGenHdrCode(e_NetHeaderType hdr, e_FmPcdHdrIndex hdrIndex, bool ignoreProtocolValidation)
+{
+    if(!ignoreProtocolValidation)
+        switch(hdr)
+        {
+            case(HEADER_TYPE_NONE):
+                ASSERT_COND(FALSE);
+            case(HEADER_TYPE_ETH):
+                return KG_SCH_GEN_ETH;
+            case(HEADER_TYPE_LLC_SNAP):
+                return KG_SCH_GEN_SNAP;
+            case(HEADER_TYPE_PPPoE):
+                return KG_SCH_GEN_PPP;
+            case(HEADER_TYPE_MPLS):
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    return KG_SCH_GEN_MPLS1;
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                    return KG_SCH_GEN_MPLS2;
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_3)
+                    return KG_SCH_GEN_MPLS3;
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                    return KG_SCH_GEN_MPLS_LAST;
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS header index"));
+                return 0;
+            case(HEADER_TYPE_IPv4):
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    return KG_SCH_GEN_IPV4;
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                    return KG_SCH_GEN_IPV4_TUNNELED;
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 header index"));
+                return 0;
+            case(HEADER_TYPE_IPv6):
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    return KG_SCH_GEN_IPV6;
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                    return KG_SCH_GEN_IPV6_TUNNELED;
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 header index"));
+                return 0;
+            case(HEADER_TYPE_GRE):
+                return KG_SCH_GEN_GRE;
+            case(HEADER_TYPE_TCP):
+                return KG_SCH_GEN_TCP;
+            case(HEADER_TYPE_UDP):
+                return KG_SCH_GEN_UDP;
+            case(HEADER_TYPE_IPSEC_AH):
+                return KG_SCH_GEN_IPSEC_AH;
+            case(HEADER_TYPE_IPSEC_ESP):
+                return KG_SCH_GEN_IPSEC_ESP;
+            case(HEADER_TYPE_SCTP):
+                return KG_SCH_GEN_SCTP;
+            case(HEADER_TYPE_DCCP):
+                return KG_SCH_GEN_DCCP;
+            default:
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                return 0;
+        }
+    else
+        switch(hdr)
+        {
+            case(HEADER_TYPE_NONE):
+                ASSERT_COND(FALSE);
+            case(HEADER_TYPE_ETH):
+                return KG_SCH_GEN_ETH_NO_V;
+            case(HEADER_TYPE_LLC_SNAP):
+                return KG_SCH_GEN_SNAP_NO_V;
+            case(HEADER_TYPE_PPPoE):
+                return KG_SCH_GEN_PPP_NO_V;
+            case(HEADER_TYPE_MPLS):
+                 if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    return KG_SCH_GEN_MPLS1_NO_V;
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                    return KG_SCH_GEN_MPLS_LAST_NO_V;
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_3) )
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Indexed MPLS Extraction not supported"));
+                else
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS header index"));
+                return 0;
+            case(HEADER_TYPE_IPv4):
+            case(HEADER_TYPE_IPv6):
+              if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    return KG_SCH_GEN_L3_NO_V;
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                    return KG_SCH_GEN_IP2_NO_V;
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header index"));
+            case(HEADER_TYPE_MINENCAP):
+                return KG_SCH_GEN_IP2_NO_V;
+            case(HEADER_TYPE_USER_DEFINED_L3):
+                return KG_SCH_GEN_L3_NO_V;
+            case(HEADER_TYPE_GRE):
+                return KG_SCH_GEN_GRE_NO_V;
+            case(HEADER_TYPE_TCP):
+            case(HEADER_TYPE_UDP):
+            case(HEADER_TYPE_IPSEC_AH):
+            case(HEADER_TYPE_IPSEC_ESP):
+            case(HEADER_TYPE_SCTP):
+            case(HEADER_TYPE_DCCP):
+                return KG_SCH_GEN_L4_NO_V;
+            case(HEADER_TYPE_USER_DEFINED_SHIM1):
+                return KG_SCH_GEN_SHIM1;
+            case(HEADER_TYPE_USER_DEFINED_SHIM2):
+                return KG_SCH_GEN_SHIM2;
+            case(HEADER_TYPE_USER_DEFINED_SHIM3):
+                return KG_SCH_GEN_SHIM3;
+            default:
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                return 0;
+        }
+}
+
+static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field, bool ignoreProtocolValidation, e_FmPcdHdrIndex hdrIndex)
+{
+    if(!ignoreProtocolValidation)
+        switch(hdr)
+        {
+            case(HEADER_TYPE_NONE):
+                ASSERT_COND(FALSE);
+            case(HEADER_TYPE_ETH):
+                switch(field.eth)
+                {
+                    case(NET_HEADER_FIELD_ETH_TYPE):
+                        return KG_SCH_GEN_ETH_TYPE;
+                    default:
+                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                        return 0;
+                }
+                break;
+            case(HEADER_TYPE_VLAN):
+                switch(field.vlan)
+                {
+                case(NET_HEADER_FIELD_VLAN_TCI) :
+                    if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_GEN_VLAN1;
+                    if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                        return KG_SCH_GEN_VLAN2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal VLAN header index"));
+                        return 0;
+                }
+                break;
+            case(HEADER_TYPE_MPLS):
+            case(HEADER_TYPE_IPSEC_AH):
+            case(HEADER_TYPE_IPSEC_ESP):
+            case(HEADER_TYPE_LLC_SNAP):
+            case(HEADER_TYPE_PPPoE):
+            case(HEADER_TYPE_IPv4):
+            case(HEADER_TYPE_IPv6):
+            case(HEADER_TYPE_GRE):
+            case(HEADER_TYPE_MINENCAP):
+            case(HEADER_TYPE_USER_DEFINED_L3):
+            case(HEADER_TYPE_TCP):
+            case(HEADER_TYPE_UDP):
+            case(HEADER_TYPE_SCTP):
+            case(HEADER_TYPE_DCCP):
+            case(HEADER_TYPE_USER_DEFINED_L4):
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+            default:
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header not supported"));
+                return 0;
+        }
+        else
+            switch(hdr)
+            {
+                case(HEADER_TYPE_NONE):
+                    ASSERT_COND(FALSE);
+                case(HEADER_TYPE_ETH):
+                switch(field.eth)
+                {
+                    case(NET_HEADER_FIELD_ETH_TYPE):
+                        return KG_SCH_GEN_ETH_TYPE_NO_V;
+                    default:
+                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                        return 0;
+                }
+                break;
+                case(HEADER_TYPE_VLAN):
+                    switch(field.vlan)
+                    {
+                    case(NET_HEADER_FIELD_VLAN_TCI) :
+                        if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                            return KG_SCH_GEN_VLAN1_NO_V;
+                        if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                            return KG_SCH_GEN_VLAN2_NO_V;
+                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal VLAN header index"));
+                        return 0;
+                    }
+                    break;
+                case(HEADER_TYPE_MPLS):
+                case(HEADER_TYPE_LLC_SNAP):
+                case(HEADER_TYPE_PPPoE):
+                case(HEADER_TYPE_IPv4):
+                case(HEADER_TYPE_IPv6):
+                case(HEADER_TYPE_GRE):
+                case(HEADER_TYPE_MINENCAP):
+                case(HEADER_TYPE_USER_DEFINED_L3):
+                case(HEADER_TYPE_TCP):
+                case(HEADER_TYPE_UDP):
+                case(HEADER_TYPE_IPSEC_AH):
+                case(HEADER_TYPE_IPSEC_ESP):
+                case(HEADER_TYPE_SCTP):
+                case(HEADER_TYPE_DCCP):
+                case(HEADER_TYPE_USER_DEFINED_L4):
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header not supported"));
+                    return 0;
+            }
+    return 0;
+}
+
+static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex index, t_FmPcdFields field)
+{
+    switch(hdr)
+    {
+        case(HEADER_TYPE_NONE):
+            ASSERT_COND(FALSE);
+        case(HEADER_TYPE_ETH):
+            switch(field.eth)
+            {
+                case(NET_HEADER_FIELD_ETH_DA):
+                    return KG_SCH_KN_MACDST;
+                case(NET_HEADER_FIELD_ETH_SA):
+                    return KG_SCH_KN_MACSRC;
+                case(NET_HEADER_FIELD_ETH_TYPE):
+                    return KG_SCH_KN_ETYPE;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+           }
+        case(HEADER_TYPE_LLC_SNAP):
+            switch(field.llcSnap)
+            {
+                case(NET_HEADER_FIELD_LLC_SNAP_TYPE):
+                    return KG_SCH_KN_ETYPE;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+           }
+        case(HEADER_TYPE_VLAN):
+            switch(field.vlan)
+            {
+                case(NET_HEADER_FIELD_VLAN_TCI):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_TCI1;
+                    if(index == e_FM_PCD_HDR_INDEX_LAST)
+                        return KG_SCH_KN_TCI2;
+                    else
+                    {
+                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                        return 0;
+                    }
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+            break;
+        case(HEADER_TYPE_MPLS):
+            switch(field.mpls)
+            {
+                case(NET_HEADER_FIELD_MPLS_LABEL_STACK):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_MPLS1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_MPLS2;
+                    if(index == e_FM_PCD_HDR_INDEX_LAST)
+                        return KG_SCH_KN_MPLS_LAST;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS index"));
+                    return 0;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+            break;
+        case(HEADER_TYPE_IPv4):
+            switch(field.ipv4)
+            {
+                case(NET_HEADER_FIELD_IPv4_SRC_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_IPSRC1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_IPSRC2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return 0;
+                case(NET_HEADER_FIELD_IPv4_DST_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_IPDST1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_IPDST2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return 0;
+                case(NET_HEADER_FIELD_IPv4_PROTO):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_PTYPE1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_PTYPE2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return 0;
+                case(NET_HEADER_FIELD_IPv4_TOS):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_IPTOS_TC1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_IPTOS_TC2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
+                    return 0;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+            break;
+        case(HEADER_TYPE_IPv6):
+             switch(field.ipv6)
+            {
+                case(NET_HEADER_FIELD_IPv6_SRC_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_IPSRC1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_IPSRC2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return 0;
+                case(NET_HEADER_FIELD_IPv6_DST_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_IPDST1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_IPDST2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return 0;
+                case(NET_HEADER_FIELD_IPv6_NEXT_HDR):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return KG_SCH_KN_PTYPE1;
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return KG_SCH_KN_PTYPE2;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return 0;
+                case(NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                        return (KG_SCH_KN_IPV6FL1 | KG_SCH_KN_IPTOS_TC1);
+                    if(index == e_FM_PCD_HDR_INDEX_2)
+                        return (KG_SCH_KN_IPV6FL2 | KG_SCH_KN_IPTOS_TC2);
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
+                    return 0;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+            break;
+        case(HEADER_TYPE_GRE):
+            switch(field.gre)
+            {
+                case(NET_HEADER_FIELD_GRE_TYPE):
+                    return KG_SCH_KN_GREPTYPE;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+           }
+        case(HEADER_TYPE_MINENCAP):
+            switch(field.minencap)
+            {
+                case(NET_HEADER_FIELD_MINENCAP_SRC_IP):
+                    return KG_SCH_KN_IPSRC2;
+                case(NET_HEADER_FIELD_MINENCAP_DST_IP):
+                    return KG_SCH_KN_IPDST2;
+                case(NET_HEADER_FIELD_MINENCAP_TYPE):
+                    return KG_SCH_KN_PTYPE2;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+           }
+           break;
+        case(HEADER_TYPE_TCP):
+            switch(field.tcp)
+            {
+                case(NET_HEADER_FIELD_TCP_PORT_SRC):
+                    return KG_SCH_KN_L4PSRC;
+                case(NET_HEADER_FIELD_TCP_PORT_DST):
+                    return KG_SCH_KN_L4PDST;
+                case(NET_HEADER_FIELD_TCP_FLAGS):
+                    return KG_SCH_KN_TFLG;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+            break;
+        case(HEADER_TYPE_UDP):
+            switch(field.udp)
+            {
+                case(NET_HEADER_FIELD_UDP_PORT_SRC):
+                    return KG_SCH_KN_L4PSRC;
+                case(NET_HEADER_FIELD_UDP_PORT_DST):
+                    return KG_SCH_KN_L4PDST;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+            break;
+        case(HEADER_TYPE_IPSEC_AH):
+            switch(field.ipsecAh)
+            {
+                case(NET_HEADER_FIELD_IPSEC_AH_SPI):
+                    return KG_SCH_KN_IPSEC_SPI;
+                case(NET_HEADER_FIELD_IPSEC_AH_NH):
+                    return KG_SCH_KN_IPSEC_NH;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+            break;
+        case(HEADER_TYPE_IPSEC_ESP):
+            switch(field.ipsecEsp)
+            {
+                case(NET_HEADER_FIELD_IPSEC_ESP_SPI):
+                    return KG_SCH_KN_IPSEC_SPI;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+            break;
+        case(HEADER_TYPE_SCTP):
+            switch(field.sctp)
+            {
+                case(NET_HEADER_FIELD_SCTP_PORT_SRC):
+                    return KG_SCH_KN_L4PSRC;
+                case(NET_HEADER_FIELD_SCTP_PORT_DST):
+                    return KG_SCH_KN_L4PDST;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+            break;
+        case(HEADER_TYPE_DCCP):
+            switch(field.dccp)
+            {
+                case(NET_HEADER_FIELD_DCCP_PORT_SRC):
+                    return KG_SCH_KN_L4PSRC;
+                case(NET_HEADER_FIELD_DCCP_PORT_DST):
+                    return KG_SCH_KN_L4PDST;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+            break;
+        case(HEADER_TYPE_PPPoE):
+            switch(field.pppoe)
+            {
+                case(NET_HEADER_FIELD_PPPoE_PID):
+                    return KG_SCH_KN_PPPID;
+                case(NET_HEADER_FIELD_PPPoE_SID):
+                    return KG_SCH_KN_PPPSID;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return 0;
+            }
+            break;
+        default:
+            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+            return 0;
+    }
+}
+
+static uint8_t GetFieldSize(e_NetHeaderType hdr, t_FmPcdFields field)
+{
+    UNUSED(field);
+
+    switch(hdr)
+    {
+        case(HEADER_TYPE_NONE):
+            ASSERT_COND(FALSE);
+        case(HEADER_TYPE_ETH):
+        case(HEADER_TYPE_LLC_SNAP):
+        case(HEADER_TYPE_VLAN):
+        case(HEADER_TYPE_PPPoE):
+        case(HEADER_TYPE_MPLS):
+        case(HEADER_TYPE_IPv4):
+        case(HEADER_TYPE_IPv6):
+        case(HEADER_TYPE_GRE):
+        case(HEADER_TYPE_MINENCAP):
+        case(HEADER_TYPE_USER_DEFINED_L3):
+        case(HEADER_TYPE_TCP):
+        case(HEADER_TYPE_UDP):
+        case(HEADER_TYPE_IPSEC_AH):
+        case(HEADER_TYPE_IPSEC_ESP):
+        case(HEADER_TYPE_SCTP):
+        case(HEADER_TYPE_DCCP):
+        case(HEADER_TYPE_USER_DEFINED_L4):
+        default:
+            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+            return 0;
+    }
+}
+
+static uint8_t GetKnownFieldId(uint32_t bitMask)
+{
+    uint8_t cnt = 0;
+
+    while (bitMask)
+        if(bitMask & 0x80000000)
+            break;
+        else
+        {
+            cnt++;
+            bitMask <<= 1;
+        }
+    return cnt;
+
+}
+
+static t_Error AllocClsPlanGrpBlocks(t_FmPcd *p_FmPcd, uint16_t sizeOfGrp, uint8_t *p_BaseEntry)
+{
+    uint8_t     numOfBlocks, blocksFound=0, first=0;
+    uint8_t     i, j;
+
+    numOfBlocks =  (uint8_t)(sizeOfGrp/CLS_PLAN_NUM_PER_GRP);
+
+    TRY_LOCK_RET_ERR(p_FmPcd->lock);
+
+    /* try to find consequent blocks */
+    first = 0;
+    for(i=p_FmPcd->p_FmPcdKg->clsPlanBase;i<p_FmPcd->p_FmPcdKg->numOfClsPlanEntries/CLS_PLAN_NUM_PER_GRP;)
+    {
+        if(!p_FmPcd->p_FmPcdKg->clsPlanUsedBlocks[i])
+        {
+            blocksFound++;
+            i++;
+            if(blocksFound == numOfBlocks)
+                break;
+        }
+        else
+        {
+            blocksFound = 0;
+            /* advance i to the next aligned address */
+            first = i = (uint8_t)(first + numOfBlocks);
+        }
+    }
+
+    if(blocksFound == numOfBlocks)
+    {
+        *p_BaseEntry = (uint8_t)(first*CLS_PLAN_NUM_PER_GRP);
+        for(j = first; j<first + numOfBlocks; j++)
+            p_FmPcd->p_FmPcdKg->clsPlanUsedBlocks[j] = TRUE;
+        RELEASE_LOCK(p_FmPcd->lock);
+        return E_OK;
+    }
+    else
+    {
+        RELEASE_LOCK(p_FmPcd->lock);
+        RETURN_ERROR(MINOR, E_FULL, ("No recources for clsPlan"));
+    }
+}
+
+static void FreeClsPlanGrpBlock(t_FmPcd *p_FmPcd, uint16_t sizeOfGrp, uint8_t baseEntry)
+{
+    int     i;
+
+    for(i=baseEntry/CLS_PLAN_NUM_PER_GRP;i<(baseEntry/CLS_PLAN_NUM_PER_GRP+sizeOfGrp/CLS_PLAN_NUM_PER_GRP);i++)
+    {
+        ASSERT_COND( p_FmPcd->p_FmPcdKg->clsPlanUsedBlocks[i]);
+        p_FmPcd->p_FmPcdKg->clsPlanUsedBlocks[i] = FALSE;
+    }
+}
+
+t_Handle FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgClsPlanGrpParams *p_Grp, t_FmPcdKgInterModuleClsPlanSet *p_ClsPlanSet)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    protocolOpt_t                   allOptions = 0, tmpOpt;
+    int                             i, j;
+    uint8_t                         numOfOptions = 0, grpId;
+    uint32_t                        walking1Mask, oredVectors = 0, lcvVector;
+    uint8_t                         tmpEntryId;
+    t_FmPcdKgClsPlanGrp             *p_ClsPlanGrp;
+    t_Error                         err;
+    struct {
+        protocolOpt_t   opt;
+        uint32_t        vector;
+    }                               tmpOptStruct[MAX_NUM_OF_OPTIONS];
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, NULL);
+
+    TRY_LOCK_RET_NULL(p_FmPcd->lock);
+
+    /* find a new clsPlan group */
+    for(i = 0;i<PCD_MAX_NUM_OF_PORTS;i++)
+        if(!p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used)
+            break;
+    if(i== PCD_MAX_NUM_OF_PORTS)
+    {
+        REPORT_ERROR(MAJOR, E_FULL,("No classification plan groups available."));
+        RELEASE_LOCK(p_FmPcd->lock);
+        return NULL;
+    }
+    p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used = TRUE;
+
+    TRY_LOCK_RET_NULL(p_FmPcd->p_FmPcdKg->clsPlanGrps[i].lock);
+    RELEASE_LOCK(p_FmPcd->lock);
+
+    grpId = (uint8_t)i;
+
+    p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[i];
+    p_ClsPlanGrp->netEnvId = (uint8_t)(CAST_POINTER_TO_UINT32(p_Grp->h_NetEnv)-1);
+
+    p_ClsPlanGrp->owners = 0;
+
+    FmPcdIncNetEnvOwners(p_FmPcd, (uint8_t)(CAST_POINTER_TO_UINT32(p_Grp->h_NetEnv)-1));
+
+    /* first count all options */
+    for(i=0;i<p_Grp->numOfOptions;i++)
+        allOptions |= p_Grp->options[i];
+
+    walking1Mask = 0x80000000;
+    while(allOptions)
+    {
+        if (numOfOptions==8)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE,("Too many (more than 8) classification plan basic options selected."));
+            RELEASE_LOCK(p_FmPcd->lock);
+            return NULL;
+        }
+
+        if(allOptions & walking1Mask)
+        {
+            allOptions &= ~walking1Mask;
+            /* the internal array now represents the single options considered.
+            it's order defines the location of each option in the
+            classification plan array */
+            tmpOptStruct[numOfOptions].opt = walking1Mask;
+            err = PcdGetVectorForOpt(p_FmPcd,
+                                     (uint8_t)(CAST_POINTER_TO_UINT32(p_Grp->h_NetEnv)-1),
+                                     walking1Mask,
+                                     &tmpOptStruct[numOfOptions].vector);
+            if(err)
+            {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].lock);
+                return NULL;
+            }
+            oredVectors  |= tmpOptStruct[numOfOptions].vector;
+            numOfOptions++;
+        }
+        walking1Mask >>= 1;
+    }
+
+    /* allocate 2^numOfOptions entries */
+    if(numOfOptions > MAX_NUM_OF_OPTIONS)
+    {
+        REPORT_ERROR(MINOR, E_INVALID_VALUE, ("Too many options - no more than %d components allowed.", MAX_NUM_OF_OPTIONS));
+        RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].lock);
+        return NULL;
+    }
+    p_ClsPlanGrp->sizeOfGrp = (uint16_t)(1<<numOfOptions);
+    /* a minimal group of 8 is required */
+    if(p_ClsPlanGrp->sizeOfGrp < CLS_PLAN_NUM_PER_GRP)
+        p_ClsPlanGrp->sizeOfGrp = CLS_PLAN_NUM_PER_GRP;
+
+    err = AllocClsPlanGrpBlocks(p_FmPcd, p_ClsPlanGrp->sizeOfGrp, &p_ClsPlanGrp->baseEntry);
+    if(err)
+    {
+        RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].lock);
+        REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+        return NULL;
+    }
+
+    p_ClsPlanSet->baseEntry = p_ClsPlanGrp->baseEntry;
+
+    /* set all entries in group to be the non-option vector */
+    p_ClsPlanSet->numOfClsPlanEntries = p_ClsPlanGrp->sizeOfGrp;
+    for(i=0;i<p_ClsPlanGrp->sizeOfGrp;i++)
+        p_ClsPlanSet->vectors[i] = ~oredVectors;
+
+    /* now set the relevant values only for user defined option */
+    for(i=0;i<p_Grp->numOfOptions;i++)
+    {
+        tmpEntryId = 0;
+        lcvVector = ~oredVectors;
+        j = 0;
+        tmpOpt = p_Grp->options[i];
+        while(tmpOpt)
+        {
+            /* find each option in the internal array */
+            if((tmpOpt & tmpOptStruct[j].opt) == tmpOptStruct[j].opt)
+            {
+                /* clear that bit */
+                tmpOpt &= ~tmpOptStruct[j].opt;
+                /* j is now the internal array interesting entry */
+                tmpEntryId += (1 << j);
+                lcvVector |= tmpOptStruct[j].vector;
+            }
+            j++;
+        }
+
+        ASSERT_COND(tmpEntryId < p_ClsPlanGrp->sizeOfGrp);
+        p_ClsPlanSet->vectors[tmpEntryId] = lcvVector;
+    }
+
+    /* save an array of used options - the indexes represent the power of 2 index */
+    j=0;
+    while(j<numOfOptions)
+    {
+        p_ClsPlanGrp->optArray[j] = tmpOptStruct[j].opt;
+        j++;
+    }
+
+    RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].lock);
+
+    return CAST_UINT32_TO_POINTER((uint32_t)grpId+1);;
+}
+
+void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    /* check that no port is bound to this port */
+    if(p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].owners)
+       REPORT_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a clsPlan grp that has ports bound to"));
+
+    FmPcdDecNetEnvOwners(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].netEnvId);
+
+    /* free blocks */
+    FreeClsPlanGrpBlock(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry);
+
+    /* clear clsPlan driver structure */
+    memset(&p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId], 0, sizeof(t_FmPcdKgClsPlanGrp));
+}
+
+t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort, uint32_t *p_SpReg, bool add)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                j, schemesPerPortVector = 0;
+    t_FmPcdKgScheme         *p_Scheme;
+    uint8_t                 i, relativeSchemeId;
+    uint32_t                tmp, walking1Mask;
+    uint16_t                pcdPortId;
+    uint8_t                 portsTable[] = PCD_PORTS_TABLE;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    /* for each scheme */
+    for(i = 0; i<p_BindPort->numOfSchemes; i++)
+    {
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, p_BindPort->schemesIds[i]);
+        if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+            REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+
+        if(add)
+        {
+            if (!FmPcdKgIsSchemeValidSw(h_FmPcd, relativeSchemeId))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested scheme is invalid."));
+
+            p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId];
+            /* check netEnvId  of the port against the scheme netEnvId */
+            if((p_Scheme->netEnvId != p_BindPort->netEnvId) && (p_Scheme->netEnvId != DRIVER_PRIVATE_NET_ENV_ID))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port may not be bound to requested scheme - differ in netEnvId"));
+
+            /* if next engine is private port policer profile, we need to check that it is valid */
+            GET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, portsTable, p_BindPort->hardwarePortId)
+            if(p_Scheme->nextRelativePlcrProfile)
+            {
+                for(j = 0;j<p_Scheme->numOfProfiles;j++)
+                {
+                    ASSERT_COND(p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].h_FmPort);
+                    if(p_Scheme->relativeProfileId+j >= p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].numOfProfiles)
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Relative profile not in range"));
+                     if(!FmPcdPlcrIsProfileValid(p_FmPcd, (uint16_t)(p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].profilesBase + p_Scheme->relativeProfileId + j)))
+                        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Relative profile not valid."));
+                }
+            }
+            if(!p_BindPort->useClsPlan)
+            {
+                /* if this port does not use clsPlan, it may not be bound to schemes with units that contain
+                cls plan options. Schemes that are used only directly, should not be checked.
+                it also may not be bound to schemes that go to CC with units that are options  - so we OR
+                the match vector and the grpBits (= ccUnits) */
+                if ((p_Scheme->matchVector != SCHEME_ALWAYS_DIRECT) || p_Scheme->ccUnits)
+                {
+                    walking1Mask = 0x80000000;
+                    tmp = (p_Scheme->matchVector == SCHEME_ALWAYS_DIRECT)? 0:p_Scheme->matchVector;
+                    tmp |= p_Scheme->ccUnits;
+                    while (tmp)
+                    {
+                        if(tmp & walking1Mask)
+                        {
+                            tmp &= ~walking1Mask;
+                            if(!PcdNetEnvIsUnitWithoutOpts(p_FmPcd, p_Scheme->netEnvId, walking1Mask))
+                                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port (without clsPlan) may not be bound to requested scheme - uses clsPlan options"));
+                        }
+                        walking1Mask >>= 1;
+                    }
+                }
+            }
+        }
+        /* build vector */
+        schemesPerPortVector |= 1 << (31 - p_BindPort->schemesIds[i]);
+    }
+
+    *p_SpReg = schemesPerPortVector;
+
+    return E_OK;
+}
+
+void FmPcdKgIncSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    int             i;
+    t_FmPcdKgScheme *p_Scheme;
+
+    /* for each scheme - update owners counters */
+    for(i = 0; i<p_BindPort->numOfSchemes; i++)
+    {
+        p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[p_BindPort->schemesIds[i]];
+
+        /* increment owners number */
+        p_Scheme->owners++;
+    }
+}
+
+
+void FmPcdKgDecSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    int             i;
+    t_FmPcdKgScheme *p_Scheme;
+
+    /* for each scheme - update owners counters */
+    for(i = 0; i<p_BindPort->numOfSchemes; i++)
+    {
+        p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[p_BindPort->schemesIds[i]];
+
+        /* increment owners number */
+        ASSERT_COND(p_Scheme->owners);
+        p_Scheme->owners--;
+    }
+}
+
+
+#ifdef FM_MASTER_PARTITION
+t_Error  FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t partitionId, uint8_t *p_SchemesIds)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t             i,j;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+
+    TRY_LOCK_RET_ERR(p_FmPcd->lock);
+
+    for(j=0,i=0;i<FM_PCD_KG_NUM_OF_SCHEMES && j<numOfSchemes;i++)
+    {
+        if(!p_FmPcd->p_FmPcdKg->schemesMng[i].allocated)
+        {
+            p_FmPcd->p_FmPcdKg->schemesMng[i].allocated = TRUE;
+            p_FmPcd->p_FmPcdKg->schemesMng[i].ownerId = partitionId;
+            p_SchemesIds[j] = i;
+            j++;
+        }
+    }
+
+    if (j != numOfSchemes)
+    {
+        /* roll back */
+        for(i = 0;i<j;i++)
+        {
+            p_SchemesIds[j] = 0;
+            p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated = FALSE;
+            p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId = 0;
+            p_SchemesIds[i] = 0;
+        }
+        RELEASE_LOCK(p_FmPcd->lock);
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("No schemes found"));
+    }
+
+    RELEASE_LOCK(p_FmPcd->lock);
+
+    return E_OK;
+}
+
+t_Error  FmPcdKgFreeSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t partitionId, uint8_t *p_SchemesIds)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t             i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+
+    TRY_LOCK_RET_ERR(p_FmPcd->lock);
+
+    for(i=0;i<numOfSchemes;i++)
+    {
+        if(!p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated)
+        {
+            RELEASE_LOCK(p_FmPcd->lock);
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Scheme was not previously allocated"));
+        }
+        if(p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId != partitionId)
+        {
+            RELEASE_LOCK(p_FmPcd->lock);
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Scheme is not owned by caller. "));
+        }
+        p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated = FALSE;
+        p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId = 0;
+    }
+
+    RELEASE_LOCK(p_FmPcd->lock);
+    return E_OK;
+}
+
+t_Error  FmPcdKgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t partitionId, uint8_t *p_First)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t     numOfBlocks, blocksFound=0, first=0;
+    uint8_t     i, j;
+
+    TRY_LOCK_RET_ERR(p_FmPcd->lock);
+
+    if(!numOfClsPlanEntries)
+        return E_OK;
+    if ((numOfClsPlanEntries % CLS_PLAN_NUM_PER_GRP) || (!POWER_OF_2(numOfClsPlanEntries)))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfClsPlanEntries must be a power of 2 and divisible by 8"));
+
+    numOfBlocks =  (uint8_t)(numOfClsPlanEntries/CLS_PLAN_NUM_PER_GRP);
+
+    /* try to find consequent blocks */
+    first = 0;
+    for(i=0;i<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;)
+    {
+        if(!p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated)
+        {
+            blocksFound++;
+            i++;
+            if(blocksFound == numOfBlocks)
+                break;
+        }
+        else
+        {
+            blocksFound = 0;
+            /* advance i to the next aligned address */
+            first = i = (uint8_t)(first + numOfBlocks);
+        }
+    }
+
+    if(blocksFound == numOfBlocks)
+    {
+        *p_First = (uint8_t)(first*CLS_PLAN_NUM_PER_GRP);
+        for(j = first; j<first + numOfBlocks; j++)
+        {
+            p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[j].allocated = TRUE;
+            p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[j].ownerId = partitionId;
+        }
+        RELEASE_LOCK(p_FmPcd->lock);
+
+        return E_OK;
+    }
+    else
+    {
+        RELEASE_LOCK(p_FmPcd->lock);
+        RETURN_ERROR(MINOR, E_FULL, ("No recources for clsPlan"));
+    }
+}
+
+t_Error  FmPcdKgFreeClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t partitionId, uint8_t base)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t     numOfBlocks;
+    uint8_t     i;
+
+    UNUSED( partitionId);
+
+    TRY_LOCK_RET_ERR(p_FmPcd->lock);
+
+    numOfBlocks =  (uint8_t)(numOfClsPlanEntries/CLS_PLAN_NUM_PER_GRP);
+
+    for(i=base;i<base+numOfBlocks;i++)
+    {
+        ASSERT_COND(p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated);
+        ASSERT_COND(partitionId == p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId);
+        p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated = FALSE;
+        p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId = 0;
+    }
+    RELEASE_LOCK(p_FmPcd->lock);
+    return E_OK;
+}
+#endif /* FM_MASTER_PARTITION */
+
+#ifndef CONFIG_GUEST_PARTITION /* master or single */
+t_Error KgEnable(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+
+    WRITE_UINT32(p_Regs->kggcr,GET_UINT32(p_Regs->kggcr) | FM_PCD_KG_KGGCR_EN);
+
+    return E_OK;
+}
+
+static t_Error WriteKgarWait(t_FmPcd *p_FmPcd, uint32_t kgar)
+{
+    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgar, kgar);
+    /* Wait for GO to be idle and read error */
+    while ((kgar = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgar)) & FM_PCD_KG_KGAR_GO) ;
+    if (kgar & FM_PCD_KG_KGAR_ERR)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Keygen scheme access violation"));
+    return E_OK;
+}
+
+void KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdKgClsPlanRegs    *p_FmPcdKgPortRegs;
+    uint32_t                tmpKgarReg=0;
+    uint8_t                 i, j;
+
+    SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+
+    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs;
+
+    for(i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
+    {
+        tmpKgarReg = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
+
+        for(j=i;j<i+8;j++)
+            WRITE_UINT32(p_FmPcdKgPortRegs->kgcpe[j % CLS_PLAN_NUM_PER_GRP],p_Set->vectors[j - p_Set->baseEntry]);
+
+        WriteKgarWait(p_FmPcd, tmpKgarReg);
+
+    }
+}
+
+static void PcdKgErrorException(t_Handle h_FmPcd)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t                event, schemeIndexes = 0,index = 0;
+
+    event = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeer);
+    event &= GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
+
+    schemeIndexes = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseer);
+    schemeIndexes &= GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseeer);
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeer, event);
+    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseer, schemeIndexes);
+
+    if(event & FM_PCD_KG_DOUBLE_ECC)
+        p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC);
+    if(event & FM_PCD_KG_KEYSIZE_OVERFLOW)
+    {
+        if(schemeIndexes)
+        {
+            while(schemeIndexes)
+            {
+                if(schemeIndexes & 0x1)
+                    p_FmPcd->f_FmPcdIndexedException(p_FmPcd->h_App,e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW, (uint16_t)(31 - index));
+                schemeIndexes >>= 1;
+                index+=1;
+            }
+        }
+        else /* this should happen only when interrupt is forced. */
+            p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW);
+    }
+}
+
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+static t_Error KgWriteSp(t_FmPcd *p_FmPcd , uint8_t hardwarePortId, uint32_t spReg, bool add)
+{
+    t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
+    uint32_t                tmpKgarReg = 0, tmpKgpeSp;
+    t_Error                 err;
+
+    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
+
+    tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
+
+    err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    tmpKgpeSp = GET_UINT32(p_FmPcdKgPortRegs->kgoe_sp);
+
+    if(add)
+        tmpKgpeSp |= spReg;
+    else
+        tmpKgpeSp &= ~spReg;
+
+
+    WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_sp, tmpKgpeSp);
+
+    tmpKgarReg = FmPcdKgBuildWritePortSchemeBindActionReg(hardwarePortId);
+
+    err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    return E_OK;
+}
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+/****************************************/
+/*  Internal and Inter-Module routines  */
+/****************************************/
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+t_Error FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes  *p_SchemeBind)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                spReg;
+    t_Error                 err;
+
+    err = FmPcdKgBuildBindPortToSchemes(h_FmPcd, p_SchemeBind, &spReg, TRUE);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    err = KgWriteSp(p_FmPcd, p_SchemeBind->hardwarePortId, spReg, TRUE);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    FmPcdKgIncSchemeOwners(h_FmPcd, p_SchemeBind);
+
+    return E_OK;
+}
+
+t_Error FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd ,  t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                spReg;
+    t_Error                 err;
+
+    err = FmPcdKgBuildBindPortToSchemes(h_FmPcd, p_SchemeBind, &spReg, FALSE);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    err = KgWriteSp(p_FmPcd, p_SchemeBind->hardwarePortId, spReg, FALSE);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    FmPcdKgDecSchemeOwners(h_FmPcd, p_SchemeBind);
+
+    return E_OK;
+}
+
+t_Error FmPcdKgBindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
+    uint32_t                tmpKgarReg = 0, tmpKgpeCpp = 0;
+
+    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
+    tmpKgpeCpp = FmPcdKgBuildCppReg(p_FmPcd, clsPlanGrpId);
+    WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_cpp, tmpKgpeCpp);
+
+    tmpKgarReg = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
+    return WriteKgarWait(p_FmPcd, tmpKgarReg);
+}
+
+void FmPcdKgUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
+    uint32_t                tmpKgarReg = 0;
+
+
+    SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+
+    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
+    WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_cpp, 0);
+
+    tmpKgarReg = 0;
+    tmpKgarReg |= FM_PCD_KG_KGAR_GO | FM_PCD_KG_KGAR_WRITE | FM_PCD_KG_KGAR_SEL_PORT_ENTRY | hardwarePortId | FM_PCD_KG_KGAR_SEL_PORT_WSEL_CPP;
+    WriteKgarWait(p_FmPcd, tmpKgarReg);
+}
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+#if 0
+bool KgSchemeIsValid(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t    tmpReg;
+    uint32_t    tmpKgarReg;
+    t_Error     err;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, FALSE);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, FALSE);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, FALSE);
+    SANITY_CHECK_RETURN_VALUE(schemeId<p_FmPcd->p_FmPcdKg->numOfSchemes, E_INVALID_STATE, 0);
+
+    /* read specified scheme into scheme registers */
+    tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(p_FmPcd->p_FmPcdKg->schemesIds[schemeId]);
+    WriteKgarWait(p_FmPcd, tmpKgarReg);
+
+    tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode);
+    if (tmpReg & KG_SCH_MODE_EN)
+        return TRUE;
+    else
+        return FALSE;
+}
+#endif /* 0 */
+
+bool     FmPcdKgIsSchemeValidSw(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    return p_FmPcd->p_FmPcdKg->schemes[schemeId].valid;
+}
+
+bool     KgIsSchemeAlwaysDirect(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    if(p_FmPcd->p_FmPcdKg->schemes[schemeId].matchVector == SCHEME_ALWAYS_DIRECT)
+        return TRUE;
+    else
+        return FALSE;
+}
+
+t_Handle KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
+{
+    t_FmPcdKg   *p_FmPcdKg;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    uint8_t     i=0;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    UNUSED(p_FmPcd);
+    p_FmPcdKg = (t_FmPcdKg *) XX_Malloc(sizeof(t_FmPcdKg));
+    if (!p_FmPcdKg)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Keygen allocation FAILED"));
+        return NULL;
+    }
+    memset(p_FmPcdKg, 0, sizeof(t_FmPcdKg));
+
+#ifndef CONFIG_GUEST_PARTITION
+    p_FmPcdKg->p_FmPcdKgRegs  = CAST_UINT64_TO_POINTER_TYPE(t_FmPcdKgRegs, (FmGetPcdKgBaseAddr(p_FmPcdParams->h_Fm)));
+
+    p_FmPcd->exceptions |= DEFAULT_fmPcdKgErrorExceptions;
+#endif /* !CONFIG_GUEST_PARTITION */
+
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    p_FmPcdKg->numOfSchemes = p_FmPcdParams->numOfSchemes;
+    p_FmPcdKg->numOfClsPlanEntries = p_FmPcdParams->numOfClsPlanEntries;
+#else
+    p_FmPcdKg->numOfSchemes = FM_PCD_KG_NUM_OF_SCHEMES;
+    for(i = 0;i<FM_PCD_KG_NUM_OF_SCHEMES;i++)
+        p_FmPcdKg->schemesIds[i] = i;
+    p_FmPcdKg->numOfClsPlanEntries = (uint16_t)FM_PCD_MAX_NUM_OF_CLS_PLANS;
+    p_FmPcdKg->clsPlanBase = 0;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+
+    p_FmPcdKg->isDriverEmptyClsPlanGrp = FALSE;
+
+    return p_FmPcdKg;
+}
+
+t_Error KgInit(t_FmPcd *p_FmPcd)
+{
+    t_Error                     err;
+    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+#ifndef CONFIG_GUEST_PARTITION
+    int                         i;
+    t_FmPcdKgPortConfigRegs     *p_FmPcdKgPortRegs;
+    uint8_t                     hardwarePortId;
+    uint32_t                    tmpKgarReg;
+    uint8_t                     portsTable[] = PCD_PORTS_TABLE;
+    uint32_t                    tmpReg;
+#else
+    t_FmPcdIpcKgAllocParams     kgAlloc;
+#endif /* CONFIG_GUEST_PARTITION */
+
+#ifndef CONFIG_GUEST_PARTITION
+    /**********************KGEER******************/
+    WRITE_UINT32(p_Regs->kgeer, (FM_PCD_KG_DOUBLE_ECC | FM_PCD_KG_KEYSIZE_OVERFLOW));
+    /**********************KGEER******************/
+    /**********************KGEEER******************/
+    tmpReg = 0;
+    if(p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC)
+    {
+        if(!FmRamsEccIsExternalCtl(p_FmPcd->h_Fm))
+            FM_EnableRamsEcc(p_FmPcd->h_Fm);
+        tmpReg |= FM_PCD_KG_DOUBLE_ECC;
+    }
+    if(p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
+        tmpReg |= FM_PCD_KG_KEYSIZE_OVERFLOW;
+    WRITE_UINT32(p_Regs->kgeeer,tmpReg);
+    /**********************KGEEER******************/
+
+    /**********************KGFDOR******************/
+    WRITE_UINT32(p_Regs->kgfdor,0);
+    /**********************KGFDOR******************/
+
+    /**********************KGGDV0R******************/
+    WRITE_UINT32(p_Regs->kggdv0r,0);
+    /**********************KGGDV0R******************/
+
+    /**********************KGGDV1R******************/
+    WRITE_UINT32(p_Regs->kggdv1r,0);
+    /**********************KGGDV1R******************/
+
+    /**********************KGGCR******************/
+    WRITE_UINT32(p_Regs->kggcr, NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+    /**********************KGGCR******************/
+
+    /* register even if no interrupts enabled, to allow future enablement */
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_EV_ERR_KG, PcdKgErrorException, p_FmPcd);
+
+    for(i=0;i<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;i++)
+        p_FmPcd->p_FmPcdKg->clsPlanUsedBlocks[i] = FALSE;
+
+    /* clear binding between ports to schemes so that all ports are not bound to any schemes */
+    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
+    for (i=0;i<PCD_MAX_NUM_OF_PORTS;i++)
+    {
+
+        GET_GLOBAL_PORTID_FROM_PCD_PORTS_TABLE(hardwarePortId, portsTable,i);
+
+        WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_sp, 0x00000000);
+
+        tmpKgarReg = FmPcdKgBuildWritePortSchemeBindActionReg(hardwarePortId);
+
+        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+
+        WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_cpp, 0x00000000);
+
+        tmpKgarReg = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
+
+        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    /* enable and enable all scheme interrupts                */
+    WRITE_UINT32(p_Regs->kgseer, 0xFFFFFFFF);
+    WRITE_UINT32(p_Regs->kgseeer, 0xFFFFFFFF);
+#endif /* !CONFIG_GUEST_PARTITION */
+
+    if(!p_FmPcd->p_FmPcdKg->numOfClsPlanEntries)
+        /* allocate at least the minimum grp for not using clsPlan */
+        p_FmPcd->p_FmPcdKg->numOfClsPlanEntries = CLS_PLAN_NUM_PER_GRP;
+
+    /* In Multi partition, both guest and master should allocate schemes and
+       clsPlan entries for future use */
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+#ifdef CONFIG_GUEST_PARTITION
+    /* in GUEST_PARTITION, we use the IPC, to also set a private driver group if required */
+    kgAlloc.numOfSchemes = p_FmPcd->p_FmPcdKg->numOfSchemes;
+    kgAlloc.partitionId = p_FmPcd->partitionId;
+    kgAlloc.numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->numOfClsPlanEntries;
+    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_ALLOC_KG_RSRC, (uint8_t*)&kgAlloc, NULL, NULL);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    memcpy(p_FmPcd->p_FmPcdKg->schemesIds , kgAlloc.schemesIds, kgAlloc.numOfSchemes);
+    p_FmPcd->p_FmPcdKg->clsPlanBase = kgAlloc.clsPlanBase;
+#else /* master */
+    if(p_FmPcd->p_FmPcdKg->numOfSchemes)
+    {
+        err = FmPcdKgAllocSchemes(p_FmPcd,
+                                    p_FmPcd->p_FmPcdKg->numOfSchemes,
+                                    p_FmPcd->partitionId,
+                                    p_FmPcd->p_FmPcdKg->schemesIds);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+    err = FmPcdKgAllocClsPlanEntries(p_FmPcd,
+                                p_FmPcd->p_FmPcdKg->numOfClsPlanEntries,
+                                p_FmPcd->partitionId,
+                                &p_FmPcd->p_FmPcdKg->clsPlanBase);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+#endif /* CONFIG_GUEST_PARTITION */
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+
+    return E_OK;
+}
+
+#if 0
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    if(p_FmPcd->p_FmPcdKg->isDriverEmptyClsPlanGrp)
+    {
+        /* For guest XX_SendMessage will initialize the first 8 entries
+           for the driver's empty classification plan. For master it will be set below.
+           We now need to internally (sw) allocate this
+           block (8 entries) in the partition p_FmPcd clsPlan structure.
+           We assume that since this is the first internal allocation, the first 8 entries will be allocated */
+        clsPlanGrp.netEnvId = DRIVER_PRIVATE_NET_ENV_ID;
+        clsPlanGrp.numOfOptions = 0;
+        err = FmPcdKgBuildClsPlanGrp(p_FmPcd, &clsPlanGrp, &clsPlanSet);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        ASSERT_COND(clsPlanGrp.clsPlanGrpId==0);
+        ASSERT_COND(clsPlanSet.baseEntry == p_FmPcd->p_FmPcdKg->clsPlanBase);
+
+#ifdef CONFIG_GUEST_PARTITION
+    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_ALLOC_CLS_PLAN_EMPTY_GRP, (uint8_t*)&p_FmPcd->p_FmPcdKg->clsPlanBase, NULL, NULL);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+#else /* CONFIG_GUEST_PARTITION --> Master */
+        memset(clsPlanSet.vectors, 0xFF, CLS_PLAN_NUM_PER_GRP*sizeof(uint32_t));
+        clsPlanSet.baseEntry = p_FmPcd->p_FmPcdKg->clsPlanBase;
+        clsPlanSet.numOfClsPlanEntries = CLS_PLAN_NUM_PER_GRP;
+        KgSetClsPlan(p_FmPcd, &clsPlanSet);
+    }
+#endif /* CONFIG_GUEST_PARTITION */
+
+    /* in master or single partition, we now allocate a private driver group if required */
+#else /* ! CONFIG_MULTI_PARTITION_SUPPORT  --> Single */
+        /* prepare a clsPlan group for all ports that are not using the clsPlan mechanism */
+        clsPlanGrp.netEnvId = DRIVER_PRIVATE_NET_ENV_ID;
+        clsPlanGrp.numOfOptions = 0;
+        if(FM_PCD_KgSetClsPlanGrp(p_FmPcd, &clsPlanGrp) !=E_OK)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Driver internal clsPlan group id should be '0'"));
+#endif  /* CONFIG_MULTI_PARTITION_SUPPORT */
+#endif /* 0 */
+
+t_Error FmPcdKgSwBindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t netEnvId, uint8_t clsPlanGrpId, protocolOpt_t *p_OptArray)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdKgClsPlanGrp     *p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId];
+
+    /* check that this clsPlan group is valid */
+    if(!p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].used)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid clsPlan group."));
+
+    if(p_ClsPlanGrp->netEnvId != DRIVER_PRIVATE_NET_ENV_ID)
+    /* When netEnvId == DRIVER_PRIVATE_NET_ENV_ID this is a special internal driver group.
+    it is used by ports that do not use the classification plan mechanism, and it is of
+    the minimum size - 8 entries = 1 block. In this case no check is done,
+    any port from any netEnv may be bound to this group. */
+        if(p_ClsPlanGrp->netEnvId != netEnvId)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port may not be bound to requested clsPlan - difer in netEnvId"));
+    /* increment owners number */
+    p_ClsPlanGrp->owners++;
+
+    /* copy options array for port */
+    memcpy(p_OptArray, &p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].optArray, MAX_NUM_OF_OPTIONS*sizeof(protocolOpt_t));
+
+    return E_OK;
+}
+
+void FmPcdKgSwUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t clsPlanGrpId)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    t_FmPcdKgClsPlanGrp     *p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId];
+
+     /* decrement owners number */
+    ASSERT_COND(p_ClsPlanGrp->owners);
+    p_ClsPlanGrp->owners--;
+}
+
+t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs, t_FmPcdKgKeyOrder *p_OrderedArray)
+{
+    t_FmPcd                             *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t                            grpBits;
+    uint8_t                             grpBase;
+    bool                                direct=TRUE, absolute=FALSE;
+    uint16_t                            profileId, numOfProfiles=0, relativeProfileId;
+    t_Error                             err;
+    int                                 i = 0;
+    t_NetEnvParams                      netEnvParams;
+    uint32_t                            tmpReg, fqbTmp = 0, ppcTmp = 0, selectTmp, maskTmp, knownTmp, genTmp;
+    t_FmPcdKgKeyExtractAndHashParams    *p_KeyAndHash;
+    uint8_t                             j, curr;
+    uint8_t                             id, shift=0, code=0, offset=0, size=0;
+    t_FmPcdExtractEntry                 *p_Extract = NULL;
+    t_FmPcdKgExtractedOrForFqid         *p_ExtractOr;
+    bool                                generic = FALSE;
+    t_KnownFieldsMasks                  bitMask;
+    e_FmPcdKgExtractDfltSelect          swDefault;
+    t_FmPcdKgKeyOrder                   orderedArray;
+    t_FmPcdKgSchemesExtracts            *p_LocalExtractsArray;
+    uint8_t                             numOfSwDefaults = 0;
+    t_FmPcdKgExtractDflt                swDefaults[NUM_OF_SW_DEFAULTS];
+    uint8_t                             currGenId = 0, relativeSchemeId;
+
+    memset(p_OrderedArray, 0, sizeof(t_FmPcdKgKeyOrder));
+    memset(orderedArray, 0, sizeof(t_FmPcdKgKeyOrder));
+    memset(swDefaults, 0, NUM_OF_SW_DEFAULTS*sizeof(t_FmPcdKgExtractDflt));
+
+    if(!p_Scheme->modify)
+        relativeSchemeId = p_Scheme->id.relativeSchemeId;
+    else
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, (uint8_t)(CAST_POINTER_TO_UINT32(p_Scheme->id.h_Scheme)-1));
+
+    /* by netEnv parameters, get match vector */
+    if(!p_Scheme->alwaysDirect)
+    {
+        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId =
+            (uint8_t)(CAST_POINTER_TO_UINT32(p_Scheme->netEnvParams.h_NetEnv)-1);
+        netEnvParams.netEnvId = p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId;
+        netEnvParams.numOfDistinctionUnits = p_Scheme->netEnvParams.numOfDistinctionUnits;
+        memcpy(netEnvParams.unitIds, p_Scheme->netEnvParams.unitIds, p_Scheme->netEnvParams.numOfDistinctionUnits);
+        err = PcdGetUnitsVector(p_FmPcd, &netEnvParams);
+        if(err)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].matchVector = netEnvParams.vector;
+    }
+    else
+    {
+        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].matchVector = SCHEME_ALWAYS_DIRECT;
+        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId = DRIVER_PRIVATE_NET_ENV_ID;
+    }
+
+    if(p_Scheme->nextEngine == e_FM_PCD_PLCR)
+    {
+        direct = p_Scheme->kgNextEngineParams.plcrProfile.direct;
+        absolute = p_Scheme->kgNextEngineParams.plcrProfile.sharedProfile ? TRUE: FALSE;
+        if(!direct && absolute)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Indirect policing is not available when profile is shared."));
+
+        if(direct)
+        {
+            profileId = p_Scheme->kgNextEngineParams.plcrProfile.profileSelect.directRelativeProfileId;
+            numOfProfiles = 1;
+        }
+        else
+        {
+            profileId = p_Scheme->kgNextEngineParams.plcrProfile.profileSelect.indirectProfile.fqidOffsetRelativeProfileIdBase;
+            shift = p_Scheme->kgNextEngineParams.plcrProfile.profileSelect.indirectProfile.fqidOffsetShift;
+            numOfProfiles = p_Scheme->kgNextEngineParams.plcrProfile.profileSelect.indirectProfile.numOfProfiles;
+        }
+    }
+
+    if(p_Scheme->nextEngine == e_FM_PCD_CC)
+    {
+        err = CcGetGrpParams(p_Scheme->kgNextEngineParams.cc.h_CcTree,
+                             p_Scheme->kgNextEngineParams.cc.grpId,
+                             &grpBits,
+                             &grpBase);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].ccUnits = grpBits;
+
+        if(p_Scheme->kgNextEngineParams.cc.plcrNext)
+        {
+            if(p_Scheme->kgNextEngineParams.cc.plcrProfile.sharedProfile)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Shared profile may not be used after Coarse classification."));
+            absolute = FALSE;
+            direct = p_Scheme->kgNextEngineParams.cc.plcrProfile.direct;
+            if(direct)
+            {
+                profileId = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.directRelativeProfileId;
+                numOfProfiles = 1;
+            }
+            else
+            {
+                profileId = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.fqidOffsetRelativeProfileIdBase;
+                shift = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.fqidOffsetShift;
+                numOfProfiles = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.numOfProfiles;
+            }
+        }
+    }
+
+    /* if policer is used directly after KG, or after CC */
+    if((p_Scheme->nextEngine == e_FM_PCD_PLCR)  ||
+       ((p_Scheme->nextEngine == e_FM_PCD_CC) && (p_Scheme->kgNextEngineParams.cc.plcrNext)))
+    {
+        /* if private policer profile, it may be uninitialized yet, therefor no checks are done at this stage */
+        if(absolute)
+        {
+            /* for absolute direct policy only, */
+            relativeProfileId = profileId;
+            err = FmPcdPlcrGetAbsoluteProfileId(h_FmPcd,e_FM_PCD_PLCR_SHARED,NULL, relativeProfileId, &profileId);
+            if(err)
+                RETURN_ERROR(MAJOR, err, ("Shared profile not valid offset"));
+            if(!FmPcdPlcrIsProfileValid(p_FmPcd, profileId))
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Shared profile not valid."));
+        }
+        else
+        {
+            /* save relative profile id's for later check */
+            p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextRelativePlcrProfile = TRUE;
+            p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].relativeProfileId = profileId;
+            p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].numOfProfiles = numOfProfiles;
+        }
+    }
+
+    /* configure all 21 scheme registers */
+    tmpReg =  KG_SCH_MODE_EN;
+    switch(p_Scheme->nextEngine)
+    {
+        case(e_FM_PCD_PLCR):
+            /* add to mode register - NIA */
+            tmpReg |= KG_SCH_MODE_NIA_PLCR;
+            tmpReg |= NIA_ENG_PLCR;
+            tmpReg |= (uint32_t)(p_Scheme->kgNextEngineParams.plcrProfile.sharedProfile ? NIA_PLCR_ABSOLUTE:0);
+            /* initialize policer profile command - */
+            /*  configure kgse_ppc  */
+            if(direct)
+            /* use profileId as base, other fields are 0 */
+                p_SchemeRegs->kgse_ppc = (uint32_t)profileId;
+            else
+            {
+                if(shift > MAX_PP_SHIFT)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidOffsetShift may not be larger than %d", MAX_PP_SHIFT));
+
+                if(!numOfProfiles || !POWER_OF_2(numOfProfiles))
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfProfiles must not be 0 and must be a power of 2"));
+
+                ppcTmp = ((uint32_t)shift << KG_SCH_PP_SHIFT_HIGH_SHIFT) & KG_SCH_PP_SHIFT_HIGH;
+                ppcTmp |= ((uint32_t)shift << KG_SCH_PP_SHIFT_LOW_SHIFT) & KG_SCH_PP_SHIFT_LOW;
+                ppcTmp |= ((uint32_t)(numOfProfiles-1) << KG_SCH_PP_MASK_SHIFT);
+                ppcTmp |= (uint32_t)profileId;
+
+                p_SchemeRegs->kgse_ppc = ppcTmp;
+            }
+            break;
+        case(e_FM_PCD_CC):
+            /* mode reg - define NIA */
+            tmpReg |= (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC);
+
+            p_SchemeRegs->kgse_ccbs = grpBits;
+            tmpReg |= (uint32_t)(grpBase << KG_SCH_MODE_CCOBASE_SHIFT);
+
+            if(p_Scheme->kgNextEngineParams.cc.plcrNext)
+            {
+                /* find out if absolute or relative */
+                if(absolute)
+                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("It is illegal to request a shared profile in a scheme that is in a KG->CC->PLCR flow"));
+                if(direct)
+                {
+                    /* mask = 0, base = directProfileId */
+                    p_SchemeRegs->kgse_ppc = (uint32_t)profileId;
+                }
+                else
+                {
+                    if(shift > MAX_PP_SHIFT)
+                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidOffsetShift may not be larger than %d", MAX_PP_SHIFT));
+                    if(!numOfProfiles || !POWER_OF_2(numOfProfiles))
+                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfProfiles must not be 0 and must be a power of 2"));
+
+                    ppcTmp = ((uint32_t)shift << KG_SCH_PP_SHIFT_HIGH_SHIFT) & KG_SCH_PP_SHIFT_HIGH;
+                    ppcTmp |= ((uint32_t)shift << KG_SCH_PP_SHIFT_LOW_SHIFT) & KG_SCH_PP_SHIFT_LOW;
+                    ppcTmp |= ((uint32_t)(numOfProfiles-1) << KG_SCH_PP_MASK_SHIFT);
+                    ppcTmp |= (uint32_t)profileId;
+
+                    p_SchemeRegs->kgse_ppc = ppcTmp;
+                }
+            }
+
+            break;
+        case(e_FM_PCD_DONE):
+            tmpReg |= (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+            break;
+        default:
+             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Next engine not supported"));
+    }
+    p_SchemeRegs->kgse_mode = tmpReg;
+
+    p_SchemeRegs->kgse_mv = p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].matchVector;
+
+    if(p_Scheme->useHash)
+    {
+        p_KeyAndHash = &p_Scheme->keyExtractAndHashParams;
+
+        /*  configure kgse_dv0  */
+        p_SchemeRegs->kgse_dv0 = p_KeyAndHash->privateDflt0;
+
+        /*  configure kgse_dv1  */
+        p_SchemeRegs->kgse_dv1 = p_KeyAndHash->privateDflt1;
+
+
+        /*  configure kgse_ekdv  */
+        tmpReg = 0;
+        for( i=0 ;i<p_KeyAndHash->numOfUsedDflts ; i++)
+        {
+            switch(p_KeyAndHash->dflts[i].type)
+            {
+                case(e_FM_PCD_KG_MAC_ADDR):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_MAC_ADDR_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_TCI):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_TCI_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_ENET_TYPE):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_ENET_TYPE_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_PPP_SESSION_ID):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_PPP_SESSION_ID_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_PPP_PROTOCOL_ID):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_PPP_PROTOCOL_ID_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_MPLS_LABEL):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_MPLS_LABEL_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_IP_ADDR):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_IP_ADDR_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_PROTOCOL_TYPE):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_PROTOCOL_TYPE_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_IP_TOS_TC):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_IP_TOS_TC_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_IPV6_FLOW_LABEL):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_L4_PORT_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_IPSEC_SPI):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_IPSEC_SPI_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_L4_PORT):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_L4_PORT_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_TCP_FLAG):
+                    tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_TCP_FLAG_SHIFT);
+                    break;
+                case(e_FM_PCD_KG_GENERIC_FROM_DATA):
+                    swDefaults[numOfSwDefaults].type = e_FM_PCD_KG_GENERIC_FROM_DATA;
+                    swDefaults[numOfSwDefaults].dfltSelect = p_KeyAndHash->dflts[i].dfltSelect;
+                    numOfSwDefaults ++;
+                    break;
+                case(e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V):
+                    swDefaults[numOfSwDefaults].type = e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V;
+                    swDefaults[numOfSwDefaults].dfltSelect = p_KeyAndHash->dflts[i].dfltSelect;
+                    numOfSwDefaults ++;
+                    break;
+                case(e_FM_PCD_KG_GENERIC_NOT_FROM_DATA):
+                    swDefaults[numOfSwDefaults].type = e_FM_PCD_KG_GENERIC_NOT_FROM_DATA;
+                    swDefaults[numOfSwDefaults].dfltSelect = p_KeyAndHash->dflts[i].dfltSelect;
+                    numOfSwDefaults ++;
+                   break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            }
+        }
+        p_SchemeRegs->kgse_ekdv = tmpReg;
+
+        p_LocalExtractsArray = (t_FmPcdKgSchemesExtracts *)XX_Malloc(sizeof(t_FmPcdKgSchemesExtracts));
+        if(!p_LocalExtractsArray)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+        /*  configure kgse_ekfc and  kgse_gec */
+        knownTmp = 0;
+        for( i=0 ;i<p_KeyAndHash->numOfUsedExtracts ; i++)
+        {
+            p_Extract = &p_KeyAndHash->extractArray[i];
+            switch(p_Extract->type)
+            {
+                case(e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO):
+                    knownTmp |= KG_SCH_KN_PORT_ID;
+                    /* save in driver structure */
+                    p_LocalExtractsArray->extractsArray[i].id = GetKnownFieldId(KG_SCH_KN_PORT_ID);
+                    p_LocalExtractsArray->extractsArray[i].known = TRUE;
+                    break;
+                case(e_FM_PCD_EXTRACT_BY_HDR):
+                    switch(p_Extract->extractParams.extractByHdr.type)
+                    {
+                        case(e_FM_PCD_EXTRACT_FROM_HDR):
+                            generic = TRUE;
+                            /* get the header code for the generic extract */
+                            code = GetGenHdrCode(p_Extract->extractParams.extractByHdr.hdr, p_Extract->extractParams.extractByHdr.hdrIndex, p_Extract->extractParams.extractByHdr.ignoreProtocolValidation);
+                            /* set generic register fields */
+                            offset = p_Extract->extractParams.extractByHdr.extractByHdrType.fromHdr.offset;
+                            size = p_Extract->extractParams.extractByHdr.extractByHdrType.fromHdr.size;
+                            break;
+                        case(e_FM_PCD_EXTRACT_FROM_FIELD):
+                            generic = TRUE;
+                            /* get the field code for the generic extract */
+                            code = GetGenFieldCode(p_Extract->extractParams.extractByHdr.hdr,
+                                        p_Extract->extractParams.extractByHdr.extractByHdrType.fromField.field, p_Extract->extractParams.extractByHdr.ignoreProtocolValidation,p_Extract->extractParams.extractByHdr.hdrIndex);
+                            offset = p_Extract->extractParams.extractByHdr.extractByHdrType.fromField.offset;
+                            size = p_Extract->extractParams.extractByHdr.extractByHdrType.fromField.size;
+                            break;
+                        case(e_FM_PCD_EXTRACT_FULL_FIELD):
+                            if(!p_Extract->extractParams.extractByHdr.ignoreProtocolValidation)
+                            {
+                                /* if we have a known field for it - use it, otherwise use generic */
+                                bitMask = GetKnownProtMask(p_Extract->extractParams.extractByHdr.hdr, p_Extract->extractParams.extractByHdr.hdrIndex,
+                                            p_Extract->extractParams.extractByHdr.extractByHdrType.fullField);
+                                if(bitMask)
+                                {
+                                    knownTmp |= bitMask;
+                                    /* save in driver structure */
+                                    p_LocalExtractsArray->extractsArray[i].id = GetKnownFieldId(bitMask);
+                                    p_LocalExtractsArray->extractsArray[i].known = TRUE;
+                                }
+                                else
+                                    generic = TRUE;
+
+                            }
+                            else
+                                generic = TRUE;
+                            if(generic)
+                            {
+                                /* tmp - till we cover more headers under generic */
+                                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Full header selection not supported"));
+                                /* get the field code for the generic extract */
+                                code = GetGenFieldCode(p_Extract->extractParams.extractByHdr.hdr,
+                                            p_Extract->extractParams.extractByHdr.extractByHdrType.fullField, p_Extract->extractParams.extractByHdr.ignoreProtocolValidation, p_Extract->extractParams.extractByHdr.hdrIndex);
+                                offset = 0; //GetFieldOffset
+                                size = GetFieldSize(p_Extract->extractParams.extractByHdr.hdr, p_Extract->extractParams.extractByHdr.extractByHdrType.fullField);
+                            }
+                            break;
+                        default:
+                            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+                    }
+                    break;
+                case(e_FM_PCD_EXTRACT_NON_HDR):
+                    /* use generic */
+                    generic = TRUE;
+                    /* get the field code for the generic extract */
+                    code = GetGenCode(p_Extract->extractParams.extractNonHdr.src);
+                    offset = p_Extract->extractParams.extractNonHdr.offset;
+                    size = p_Extract->extractParams.extractNonHdr.size;
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            }
+
+            if(generic)
+            {
+                /* set generic register fields */
+                if(currGenId >= FM_PCD_KG_NUM_OF_GENERIC_REGS)
+                    RETURN_ERROR(MAJOR, E_FULL, ("Generic registers are fully used"));
+                if(!code)
+                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
+
+                genTmp = KG_SCH_GEN_VALID;
+                genTmp |= (uint32_t)(code << KG_SCH_GEN_HT_SHIFT);
+                genTmp |= offset;
+                if((size > MAX_KG_SCH_SIZE) || (size < 1))
+                      RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal extraction (size out of range)"));
+                genTmp |= (uint32_t)((size - 1) << KG_SCH_GEN_SIZE_SHIFT);
+                swDefault = GetGenericSwDefault(swDefaults, numOfSwDefaults, code);
+                if(swDefault == e_FM_PCD_KG_DFLT_ILLEGAL)
+                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal code for sw default"));
+
+                genTmp |= swDefault << KG_SCH_GEN_DEF_SHIFT;
+                genTmp |= KG_SCH_GEN_MASK;
+                p_SchemeRegs->kgse_gec[currGenId] = genTmp;
+                /* save in driver structure */
+                p_LocalExtractsArray->extractsArray[i].id = currGenId++;
+                p_LocalExtractsArray->extractsArray[i].known = FALSE;
+                generic = FALSE;
+            }
+        }
+        p_SchemeRegs->kgse_ekfc = knownTmp;
+
+
+        selectTmp = 0;
+        maskTmp = 0xFFFFFFFF;
+        /*  configure kgse_bmch, kgse_bmcl and kgse_fqb */
+        for( i=0 ;i<p_KeyAndHash->numOfUsedMasks ; i++)
+        {
+            /* Get the relative id of the extract (for known 0-0x1f, for generic 0-7) */
+            id = p_LocalExtractsArray->extractsArray[p_KeyAndHash->masks[i].extractArrayIndex].id;
+            /* Get the shift of the select field (depending on i) */
+            GET_MASK_SEL_SHIFT(shift,i);
+            if (p_LocalExtractsArray->extractsArray[p_KeyAndHash->masks[i].extractArrayIndex].known)
+                selectTmp |= id << shift;
+            else
+                selectTmp |= (id + MASK_FOR_GENERIC_BASE_ID) << shift;
+
+            /* Get the shift of the offset field (depending on i) - may
+               be in  kgse_bmch or in kgse_fqb (depending on i) */
+            GET_MASK_OFFSET_SHIFT(shift,i);
+            if (i<=1)
+                selectTmp |= p_KeyAndHash->masks[i].offset << shift;
+            else
+                fqbTmp |= p_KeyAndHash->masks[i].offset << shift;
+
+            /* Get the shift of the mask field (depending on i) */
+            GET_MASK_SHIFT(shift,i);
+            /* pass all bits */
+            maskTmp |= KG_SCH_BITMASK_MASK << shift;
+            /* clear bits that need masking */
+            maskTmp &= ~(0xFF << shift) ;
+            /* set mask bits */
+            maskTmp |= (p_KeyAndHash->masks[i].mask << shift) ;
+        }
+        p_SchemeRegs->kgse_bmch = selectTmp;
+        p_SchemeRegs->kgse_bmcl = maskTmp;
+        /* kgse_fqb will be written t the end of the routine */
+
+        /*  configure kgse_hc  */
+        if(!p_KeyAndHash->hashDistributionNumOfFqids || !POWER_OF_2(p_KeyAndHash->hashDistributionNumOfFqids))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashDistributionNumOfFqids must not be 0 and must be a power of 2"));
+        if(p_KeyAndHash->hashShift > MAX_HASH_SHIFT)
+             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashShift must not be larger than %d", MAX_HASH_SHIFT));
+        if(p_KeyAndHash->hashDistributionFqidsShift > MAX_DIST_FQID_SHIFT)
+             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashDistributionFqidsShift must not be larger than %d", MAX_DIST_FQID_SHIFT));
+
+        tmpReg = 0;
+        tmpReg |= ((p_KeyAndHash->hashDistributionNumOfFqids - 1) << p_KeyAndHash->hashDistributionFqidsShift);
+        tmpReg |= p_KeyAndHash->hashShift << KG_SCH_HASH_CONFIG_SHIFT_SHIFT;
+        p_SchemeRegs->kgse_hc = tmpReg;
+
+
+        /* build the return array describing the order of the extractions */
+
+        /* the last currGenId places of the array
+           are for generic extracts that are always last.
+           We now sort for the calculation of the order of the known
+           extractions we sort the known extracts between orderedArray[0] and
+           orderedArray[p_KeyAndHash->numOfUsedExtracts - currGenId - 1].
+           for the calculation of the order of the generic extractions we use:
+           num_of_generic - currGenId
+           num_of_known - p_KeyAndHash->numOfUsedExtracts - currGenId
+           first_generic_index = num_of_known */
+        curr = 0;
+        for (i=0;i<p_KeyAndHash->numOfUsedExtracts ; i++)
+        {
+            if(p_LocalExtractsArray->extractsArray[i].known)
+            {
+                ASSERT_COND(curr<(p_KeyAndHash->numOfUsedExtracts - currGenId));
+                j = curr;
+                /* id is the extract id (port id = 0, mac src = 1 etc.). the value in the array is the original
+                index in the user's extractions array */
+                /* we compare the id of the current extract with the id of the extract in the orderedArray[j-1]
+                location */
+                while(p_LocalExtractsArray->extractsArray[i].id < p_LocalExtractsArray->extractsArray[orderedArray[j-1]].id && j>0)
+                {
+                    orderedArray[j] = orderedArray[j-1];
+                    j--;
+                }
+                orderedArray[j] = (uint8_t)i;
+                curr++;
+            }
+            else
+                /* index is first_generic_index + generic index (id) */
+                orderedArray[p_KeyAndHash->numOfUsedExtracts - currGenId + p_LocalExtractsArray->extractsArray[i].id]= (uint8_t)i;
+
+        }
+        XX_Free(p_LocalExtractsArray);
+        p_LocalExtractsArray = NULL;
+        memcpy(p_OrderedArray, &orderedArray, sizeof(orderedArray));
+
+    }
+    else
+    {
+        /* clear all unused registers: */
+        p_SchemeRegs->kgse_ekfc = 0;
+        p_SchemeRegs->kgse_ekdv = 0;
+        p_SchemeRegs->kgse_bmch = 0;
+        p_SchemeRegs->kgse_bmcl = 0;
+        p_SchemeRegs->kgse_hc = 0;
+        p_SchemeRegs->kgse_dv0 = 0;
+        p_SchemeRegs->kgse_dv1 = 0;
+    }
+
+    /*  configure kgse_spc  */
+    if( p_Scheme->schemeCounter.update)
+        p_SchemeRegs->kgse_spc = p_Scheme->schemeCounter.value;
+
+
+    /* check that are enough generic registers */
+    if(p_Scheme->numOfUsedFqidMasks + currGenId > FM_PCD_KG_NUM_OF_GENERIC_REGS)
+        RETURN_ERROR(MAJOR, E_FULL, ("Generic registers are fully used"));
+
+    /* extracted OR mask on Qid */
+    for( i=0 ;i<p_Scheme->numOfUsedFqidMasks ; i++)
+    {
+
+        /*  configure kgse_gec[i]  */
+        p_ExtractOr = &p_Scheme->fqidMasks[i];
+        switch(p_ExtractOr->type)
+        {
+            case(e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO):
+                code = KG_SCH_GEN_PARSE_RESULT;
+                offset = 0;
+                break;
+            case(e_FM_PCD_EXTRACT_BY_HDR):
+                /* get the header code for the generic extract */
+                code = GetGenHdrCode(p_ExtractOr->extractParams.extractByHdr.hdr, p_ExtractOr->extractParams.extractByHdr.hdrIndex, p_ExtractOr->extractParams.extractByHdr.ignoreProtocolValidation);
+                /* set generic register fields */
+                offset = p_ExtractOr->extractionOffset;
+                break;
+            case(e_FM_PCD_EXTRACT_NON_HDR):
+                /* get the field code for the generic extract */
+                code = GetGenCode(p_ExtractOr->extractParams.src);
+                offset = p_ExtractOr->extractionOffset;
+                break;
+            default:
+                RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+        }
+
+        /* set generic register fields */
+        if(!code)
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
+        genTmp = KG_SCH_GEN_EXTRACT_TYPE | KG_SCH_GEN_VALID;
+        genTmp |= (uint32_t)(code << KG_SCH_GEN_HT_SHIFT);
+        genTmp |= offset;
+        if(p_ExtractOr->bitOffsetInFqid > MAX_KG_SCH_BIT_OFFSET )
+              RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal extraction (bitOffsetInFqid out of range)"));
+        genTmp |= (uint32_t)(p_ExtractOr->bitOffsetInFqid << KG_SCH_GEN_SIZE_SHIFT);
+        genTmp |= (uint32_t)(p_ExtractOr->extractionOffset << KG_SCH_GEN_DEF_SHIFT);
+        /* pass all bits */
+        genTmp |= KG_SCH_GEN_MASK;
+        /* clear bits that need masking */
+        genTmp &= ~(0xFF << KG_SCH_GEN_MASK_SHIFT) ;
+        /* set mask bits */
+        genTmp |= (uint32_t)(p_ExtractOr->mask << KG_SCH_GEN_MASK_SHIFT);
+        p_SchemeRegs->kgse_gec[currGenId++] = genTmp;
+
+    }
+    /* clear all unused GEC registers */
+    for( i=currGenId ;i<FM_PCD_KG_NUM_OF_GENERIC_REGS ; i++)
+        p_SchemeRegs->kgse_gec[i] = 0;
+
+    /* add base Qid for this scheme */
+    /* add configuration for kgse_fqb */
+    if(p_Scheme->baseFqid & ~0x00FFFFFF)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("baseFqid must be between 1 and 2^24-1"));
+
+    fqbTmp |= p_Scheme->baseFqid;
+    p_SchemeRegs->kgse_fqb = fqbTmp;
+
+    return E_OK;
+}
+
+void  FmPcdKgValidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    ASSERT_COND(!p_FmPcd->p_FmPcdKg->schemes[schemeId].valid);
+
+    FmPcdIncNetEnvOwners(p_FmPcd, p_FmPcd->p_FmPcdKg->schemes[schemeId].netEnvId);
+    p_FmPcd->p_FmPcdKg->schemes[schemeId].valid = TRUE;
+}
+
+void  FmPcdKgInvalidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId)
+{
+
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    FmPcdDecNetEnvOwners(h_FmPcd, p_FmPcd->p_FmPcdKg->schemes[schemeId].netEnvId);
+    p_FmPcd->p_FmPcdKg->schemes[schemeId].valid = FALSE;
+}
+
+t_Error FmPcdKgCheckInvalidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+   /* check that no port is bound to this scheme */
+    if(p_FmPcd->p_FmPcdKg->schemes[schemeId].owners)
+       RETURN_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a scheme that has ports bound to"));
+    if(!p_FmPcd->p_FmPcdKg->schemes[schemeId].valid)
+       RETURN_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete an invalid scheme"));
+    return E_OK;
+}
+
+uint32_t FmPcdKgBuildCppReg(t_Handle h_FmPcd, uint8_t clsPlanGrpId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t    tmpKgpeCpp;
+
+    tmpKgpeCpp = (uint32_t)(p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].baseEntry / 8);
+    tmpKgpeCpp |= (uint32_t)(((p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].sizeOfGrp / 8) - 1) << FM_PCD_KG_PE_CPP_MASK_SHIFT);
+    return tmpKgpeCpp;
+}
+
+bool    FmPcdKgHwSchemeIsValid(uint32_t schemeModeReg)
+{
+
+    if(schemeModeReg & KG_SCH_MODE_EN)
+        return TRUE;
+    else
+        return FALSE;
+}
+
+uint32_t    FmPcdKgBuildWriteSchemeActionReg(uint8_t schemeId, bool updateCounter)
+{
+    return     (uint32_t)((schemeId << FM_PCD_KG_KGAR_NUM_SHIFT)|
+                            FM_PCD_KG_KGAR_GO |
+                            FM_PCD_KG_KGAR_WRITE |
+                            FM_PCD_KG_KGAR_SEL_SCHEME_ENTRY |
+                            DUMMY_PORT_ID |
+                            (updateCounter ? FM_PCD_KG_KGAR_SCHEME_WSEL_UPDATE_CNT:0));
+
+}
+
+uint32_t    FmPcdKgBuildReadSchemeActionReg(uint8_t schemeId)
+{
+    return     (uint32_t)((schemeId << FM_PCD_KG_KGAR_NUM_SHIFT)|
+                            FM_PCD_KG_KGAR_GO |
+                            FM_PCD_KG_KGAR_READ |
+                            FM_PCD_KG_KGAR_SEL_SCHEME_ENTRY |
+                            DUMMY_PORT_ID |
+                            FM_PCD_KG_KGAR_SCHEME_WSEL_UPDATE_CNT);
+
+}
+
+
+uint32_t    FmPcdKgBuildWriteClsPlanBlockActionReg(uint8_t grpId)
+{
+    return (uint32_t)(FM_PCD_KG_KGAR_GO |
+                        FM_PCD_KG_KGAR_WRITE |
+                        FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY |
+                        DUMMY_PORT_ID |
+                        (grpId << FM_PCD_KG_KGAR_NUM_SHIFT) |
+                        FM_PCD_KG_KGAR_WSEL_MASK);
+
+
+        /* if we ever want to write 1 by 1, use:
+        sel = (uint8_t)(0x01 << (7- (entryId % CLS_PLAN_NUM_PER_GRP)));*/
+}
+
+uint32_t    FmPcdKgBuildReadClsPlanBlockActionReg(uint8_t grpId)
+{
+    return (uint32_t)(FM_PCD_KG_KGAR_GO |
+                        FM_PCD_KG_KGAR_READ |
+                        FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY |
+                        DUMMY_PORT_ID |
+                        (grpId << FM_PCD_KG_KGAR_NUM_SHIFT) |
+                        FM_PCD_KG_KGAR_WSEL_MASK);
+
+
+        /* if we ever want to write 1 by 1, use:
+        sel = (uint8_t)(0x01 << (7- (entryId % CLS_PLAN_NUM_PER_GRP)));*/
+}
+
+uint32_t        FmPcdKgBuildWritePortSchemeBindActionReg(uint8_t hardwarePortId)
+{
+
+    return (uint32_t)(FM_PCD_KG_KGAR_GO |
+                        FM_PCD_KG_KGAR_WRITE |
+                        FM_PCD_KG_KGAR_SEL_PORT_ENTRY |
+                        hardwarePortId |
+                        FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP);
+}
+
+uint32_t        FmPcdKgBuildReadPortSchemeBindActionReg(uint8_t hardwarePortId)
+{
+
+    return (uint32_t)(FM_PCD_KG_KGAR_GO |
+                        FM_PCD_KG_KGAR_READ |
+                        FM_PCD_KG_KGAR_SEL_PORT_ENTRY |
+                        hardwarePortId |
+                        FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP);
+}
+uint32_t        FmPcdKgBuildWritePortClsPlanBindActionReg(uint8_t hardwarePortId)
+{
+
+    return (uint32_t)(FM_PCD_KG_KGAR_GO |
+                        FM_PCD_KG_KGAR_WRITE |
+                        FM_PCD_KG_KGAR_SEL_PORT_ENTRY |
+                        hardwarePortId |
+                        FM_PCD_KG_KGAR_SEL_PORT_WSEL_CPP);
+}
+
+uint8_t FmPcdKgGetClsPlanGrpBase(t_Handle h_FmPcd, uint8_t clsPlanGrp)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    return p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrp].baseEntry;
+}
+
+uint16_t FmPcdKgGetClsPlanGrpSize(t_Handle h_FmPcd, uint8_t clsPlanGrp)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    return p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrp].sizeOfGrp;
+}
+
+uint8_t FmPcdKgGetSchemeSwId(t_Handle h_FmPcd, uint8_t schemeHwId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t     i;
+
+    for(i=0;i<p_FmPcd->p_FmPcdKg->numOfSchemes;i++)
+        if(p_FmPcd->p_FmPcdKg->schemesIds[i] == schemeHwId)
+            return i;
+    ASSERT_COND(i!=p_FmPcd->p_FmPcdKg->numOfSchemes);
+    return FM_PCD_KG_NUM_OF_SCHEMES;
+}
+
+bool FmPcdKgIsEmptyClsPlanGrp(t_Handle h_FmPcd)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    return p_FmPcd->p_FmPcdKg->isDriverEmptyClsPlanGrp;
+}
+
+uint8_t FmPcdKgGetEmptyClsPlanGrpId(t_Handle h_FmPcd)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    return p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId;
+}
+
+uint8_t FmPcdKgGetNumOfPartitionSchemes(t_Handle h_FmPcd)
+{
+    return ((t_FmPcd*)h_FmPcd)->p_FmPcdKg->numOfSchemes;
+}
+
+uint8_t FmPcdKgGetPhysicalSchemeId(t_Handle h_FmPcd, uint8_t relativeSchemeId)
+{
+    return ((t_FmPcd*)h_FmPcd)->p_FmPcdKg->schemesIds[relativeSchemeId];
+}
+
+uint8_t FmPcdKgGetRelativeSchemeId(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t     i;
+
+    for(i = 0;i<p_FmPcd->p_FmPcdKg->numOfSchemes;i++)
+        if(p_FmPcd->p_FmPcdKg->schemesIds[i] == schemeId)
+            return i;
+
+    if(i == p_FmPcd->p_FmPcdKg->numOfSchemes)
+        REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, ("Scheme is out of partition range"));
+
+    return FM_PCD_KG_NUM_OF_SCHEMES;
+}
+
+t_Error FmPcdKgSchemeTryLock(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    TRY_LOCK_RET_ERR(((t_FmPcd*)h_FmPcd)->p_FmPcdKg->schemes[schemeId].lock);
+
+    return E_OK;
+}
+
+void FmPcdKgReleaseSchemeLock(t_Handle h_FmPcd, uint8_t schemeId)
+{
+    RELEASE_LOCK(((t_FmPcd*)h_FmPcd)->p_FmPcdKg->schemes[schemeId].lock);
+}
+
+/****************************************/
+/*  API routines                        */
+/****************************************/
+t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payloadOffset)
+{
+   t_FmPcd              *p_FmPcd = (t_FmPcd*)h_FmPcd;
+   t_FmPcdKgRegs        *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+
+    if(payloadOffset >  256)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("data exatraction offset from parseing end can not be more than 256"));
+
+    WRITE_UINT32(p_Regs->kgfdor,payloadOffset);
+
+    return E_OK;
+}
+
+t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value)
+{
+   t_FmPcd              *p_FmPcd = (t_FmPcd*)h_FmPcd;
+   t_FmPcdKgRegs        *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(((valueId == 0) || (valueId == 1)), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+
+    if(valueId == 0)
+        WRITE_UINT32(p_Regs->kggdv0r,value);
+    else
+        WRITE_UINT32(p_Regs->kggdv1r,value);
+    return E_OK;
+}
+
+t_Error FM_PCD_KgSetEmptyClsPlanGrp(t_Handle h_FmPcd)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdKgClsPlanGrpParams   clsPlanGrp;
+    t_Handle                    h_ClsPlanFrp;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+
+    p_FmPcd->p_FmPcdKg->isDriverEmptyClsPlanGrp = TRUE;
+
+    /* prepare a clsPlan group for all ports that are not using the clsPlan mechanism */
+    clsPlanGrp.h_NetEnv = CAST_UINT32_TO_POINTER((uint32_t)DRIVER_PRIVATE_NET_ENV_ID+1);
+    clsPlanGrp.numOfOptions = 0;
+    h_ClsPlanFrp = FM_PCD_KgSetClsPlanGrp(p_FmPcd, &clsPlanGrp);
+    if(!h_ClsPlanFrp)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, NO_MSG);
+    p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId = (uint8_t)(CAST_POINTER_TO_UINT32(h_ClsPlanFrp)-1);
+
+    return E_OK;
+}
+
+t_Error FM_PCD_KgDeleteEmptyClsPlanGrp(t_Handle h_FmPcd)
+{
+   t_FmPcd  *p_FmPcd = (t_FmPcd*)h_FmPcd;
+   t_Error  err;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+
+    p_FmPcd->p_FmPcdKg->isDriverEmptyClsPlanGrp = FALSE;
+
+    err = FM_PCD_KgDeleteClsPlanGrp(p_FmPcd, CAST_UINT32_TO_POINTER((uint32_t)(p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId+1)));
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    return E_OK;
+}
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    int                 i = 0, j = 0;
+    uint8_t             hardwarePortId;
+    uint32_t            tmpKgarReg;
+    uint8_t             portsTable[] = PCD_PORTS_TABLE;
+    t_Error             err;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    DUMP_SUBTITLE(("\n"));
+    DUMP_TITLE(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs, ("FmPcdKgRegs Regs"));
+
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggcr);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgeer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgeeer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgseer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgseeer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggsr);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgtpc);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgserc);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfdor);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggdv0r);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggdv1r);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfeer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgar);
+
+    DUMP_SUBTITLE(("\n"));
+    for(j = 0;j<FM_PCD_KG_NUM_OF_SCHEMES;j++)
+    {
+        tmpKgarReg = FmPcdKgBuildReadSchemeActionReg((uint8_t)j);
+        WriteKgarWait(p_FmPcd, tmpKgarReg);
+
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs, ("FmPcdKgIndirectAccessSchemeRegs Scheme %d Regs", j));
+
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_mode);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ekfc);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ekdv);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_bmch);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_bmcl);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_fqb);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_hc);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ppc);
+
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_gec, ("kgse_gec"));
+        DUMP_SUBSTRUCT_ARRAY(i, FM_PCD_KG_NUM_OF_GENERIC_REGS)
+        {
+            DUMP_MEMORY(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_gec[i], sizeof(uint32_t));
+        }
+
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_spc);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_dv0);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_dv1);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ccbs);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_mv);
+    }
+    DUMP_SUBTITLE(("\n"));
+
+    for (i=0;i<PCD_MAX_NUM_OF_PORTS;i++)
+    {
+
+        GET_GLOBAL_PORTID_FROM_PCD_PORTS_TABLE(hardwarePortId, portsTable,i);
+
+        tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
+
+        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, ("FmPcdKgIndirectAccessPortRegs PCD Port %d regs", hardwarePortId));
+
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, kgoe_sp);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, kgoe_cpp);
+
+    }
+
+    DUMP_SUBTITLE(("\n"));
+    for(j=0;j<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;j++)
+    {
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs, ("FmPcdKgIndirectAccessClsPlanRegs Regs group %d", j));
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe, ("kgcpe"));
+
+        tmpKgarReg = FmPcdKgBuildReadClsPlanBlockActionReg((uint8_t)j);
+        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        DUMP_SUBSTRUCT_ARRAY(i, 8)
+            DUMP_MEMORY(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe[i], sizeof(uint32_t));
+    }
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+#endif /* !CONFIG_GUEST_PARTITION */
+
+
+t_Handle FM_PCD_KgSetScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme)
+{
+    t_FmPcd                             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    uint32_t                            tmpReg;
+    t_FmPcdKgInterModuleSchemeRegs      schemeRegs;
+    t_FmPcdKgInterModuleSchemeRegs      *p_MemRegs;
+    uint8_t                             i;
+    t_Error                             err;
+    uint32_t                            tmpKgarReg;
+    uint8_t                             physicalSchemeId, relativeSchemeId;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, NULL);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdKgSetScheme(p_FmPcd->h_Hc, p_Scheme);
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+        return NULL;
+    }
+
+#else
+
+    TRY_LOCK_RET_NULL(p_FmPcd->lock);
+
+    /* if not called for modification, check first that this scheme is unused */
+    if(!p_Scheme->modify)
+    {
+        /* check that schameId is in range */
+        if(p_Scheme->id.relativeSchemeId >= p_FmPcd->p_FmPcdKg->numOfSchemes)
+        {
+            REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, ("Scheme is out of range"));
+            RELEASE_LOCK(p_FmPcd->lock);
+            return NULL;
+        }
+        relativeSchemeId = p_Scheme->id.relativeSchemeId;
+
+        TRY_LOCK_RET_NULL(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+        RELEASE_LOCK(p_FmPcd->lock);
+
+        physicalSchemeId = p_FmPcd->p_FmPcdKg->schemesIds[relativeSchemeId];
+
+        /* read specified scheme into scheme registers */
+        tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+        WriteKgarWait(p_FmPcd, tmpKgarReg);
+        tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode);
+        if (tmpReg & KG_SCH_MODE_EN)
+        {
+            REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is already used"));
+            RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+            return NULL;
+        }
+
+    }
+    else
+    {
+        physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(p_Scheme->id.h_Scheme)-1);
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId);
+
+        TRY_LOCK_RET_NULL(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+        RELEASE_LOCK(p_FmPcd->lock);
+
+        if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+        {
+            REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+            RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+            return NULL;
+        }
+    }
+
+    err = FmPcdKgBuildScheme(h_FmPcd, p_Scheme, &schemeRegs, &p_Scheme->orderedArray);
+    if(err)
+    {
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        FmPcdKgInvalidateSchemeSw(h_FmPcd, relativeSchemeId);
+        RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+        return NULL;
+    }
+
+    /* configure all 21 scheme registers */
+    p_MemRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs;
+    WRITE_UINT32(p_MemRegs->kgse_ppc, schemeRegs.kgse_ppc);
+    WRITE_UINT32(p_MemRegs->kgse_ccbs, schemeRegs.kgse_ccbs);
+    WRITE_UINT32(p_MemRegs->kgse_mode, schemeRegs.kgse_mode);
+    WRITE_UINT32(p_MemRegs->kgse_mv, schemeRegs.kgse_mv);
+    WRITE_UINT32(p_MemRegs->kgse_dv0, schemeRegs.kgse_dv0);
+    WRITE_UINT32(p_MemRegs->kgse_dv1, schemeRegs.kgse_dv1);
+    WRITE_UINT32(p_MemRegs->kgse_ekdv, schemeRegs.kgse_ekdv);
+    WRITE_UINT32(p_MemRegs->kgse_ekfc, schemeRegs.kgse_ekfc);
+    WRITE_UINT32(p_MemRegs->kgse_bmch, schemeRegs.kgse_bmch);
+    WRITE_UINT32(p_MemRegs->kgse_bmcl, schemeRegs.kgse_bmcl);
+    WRITE_UINT32(p_MemRegs->kgse_hc, schemeRegs.kgse_hc);
+    WRITE_UINT32(p_MemRegs->kgse_spc, schemeRegs.kgse_spc);
+    WRITE_UINT32(p_MemRegs->kgse_fqb, schemeRegs.kgse_fqb);
+    for(i=0 ; i<FM_PCD_KG_NUM_OF_GENERIC_REGS ; i++)
+        WRITE_UINT32(p_MemRegs->kgse_gec[i], schemeRegs.kgse_gec[i]);
+
+    /* call indirect command for scheme write */
+    tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, p_Scheme->schemeCounter.update);
+
+    WriteKgarWait(p_FmPcd, tmpKgarReg);
+
+    FmPcdKgValidateSchemeSw(h_FmPcd, relativeSchemeId);
+
+    RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+
+    return CAST_UINT32_TO_POINTER((uint32_t)physicalSchemeId+1);
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+t_Error  FM_PCD_KgDeleteScheme(t_Handle h_FmPcd, t_Handle h_Scheme)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    uint8_t             physicalSchemeId;
+    uint32_t            tmpKgarReg;
+    t_Error             err;
+    uint8_t             relativeSchemeId;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdKgDeleteScheme(p_FmPcd->h_Hc, h_Scheme);
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+
+#else
+
+    physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(h_Scheme)-1);
+    relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId);
+
+    TRY_LOCK_RET_ERR(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+
+    if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+        REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+
+    /* check that no port is bound to this scheme */
+    err = FmPcdKgCheckInvalidateSchemeSw(h_FmPcd, relativeSchemeId);
+    if(err)
+       RETURN_ERROR(MINOR, err, NO_MSG);
+
+    /* clear mode register, including enable bit */
+    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode, 0);
+
+    /* call indirect command for scheme write */
+    tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, FALSE);
+
+    WriteKgarWait(p_FmPcd, tmpKgarReg);
+
+    FmPcdKgInvalidateSchemeSw(h_FmPcd, relativeSchemeId);
+
+    RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+
+    return E_OK;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+t_Handle FM_PCD_KgSetClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgClsPlanGrpParams *p_Grp)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    t_FmPcdKgInterModuleClsPlanSet  clsPlanSet;
+    t_Handle                        h_ClsPlanGrp;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdKgSetClsPlanGrp(p_FmPcd->h_Hc, p_Grp);
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+        return NULL;
+    }
+#else
+    h_ClsPlanGrp = FmPcdKgBuildClsPlanGrp(p_FmPcd, p_Grp, &clsPlanSet);
+    if(!h_ClsPlanGrp)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, NO_MSG);
+        return NULL;
+    }
+
+    /* write clsPlan entries to memory */
+    KgSetClsPlan(p_FmPcd, &clsPlanSet);
+
+
+    return h_ClsPlanGrp;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+t_Error FM_PCD_KgDeleteClsPlanGrp(t_Handle h_FmPcd, t_Handle h_ClsPlanGrp)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    uint8_t                         grpId = (uint8_t)(CAST_POINTER_TO_UINT32(h_ClsPlanGrp)-1);
+    t_FmPcdKgInterModuleClsPlanSet  clsPlanSet;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdKgDeleteClsPlanGrp(p_FmPcd->h_Hc, h_ClsPlanGrp);
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+
+#else
+    /* clear clsPlan entries in memory */
+    clsPlanSet.baseEntry = p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry;
+    clsPlanSet.numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp;
+    memset(clsPlanSet.vectors, 0, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp*sizeof(uint32_t));
+    KgSetClsPlan(p_FmPcd, &clsPlanSet );
+
+    FmPcdKgDestroyClsPlanGrp(h_FmPcd, grpId);
+
+    return E_OK;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+uint32_t  FM_PCD_KgGetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    uint32_t            tmpKgarReg;
+    uint8_t             physicalSchemeId;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdKgGetSchemeCounter(p_FmPcd->h_Hc, h_Scheme);
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+
+#else
+    physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(h_Scheme)-1);
+
+    if(FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId) == FM_PCD_KG_NUM_OF_SCHEMES)
+        REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+
+    tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+    WriteKgarWait(p_FmPcd, tmpKgarReg);
+    if (!(GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode) & KG_SCH_MODE_EN))
+       REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is Invalid"));
+
+    return GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_spc);
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+t_Error  FM_PCD_KgSetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t value)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    uint32_t            tmpKgarReg;
+    uint8_t             physicalSchemeId;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdKgSetSchemeCounter(p_FmPcd->h_Hc, h_Scheme, value);
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+
+#else
+    physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(h_Scheme)-1);
+    /* check that schameId is in range */
+    if(FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId) == FM_PCD_KG_NUM_OF_SCHEMES)
+        REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+
+    /* read specified scheme into scheme registers */
+    tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+    WriteKgarWait(p_FmPcd, tmpKgarReg);
+    if (!(GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode) & KG_SCH_MODE_EN))
+       RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is Invalid"));
+
+    /* change counter value */
+    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_spc, value);
+
+    /* call indirect command for scheme write */
+    tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, TRUE);
+
+    WriteKgarWait(p_FmPcd, tmpKgarReg);
+
+    return E_OK;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
new file mode 100644
index 0000000..7ac9d59
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
@@ -0,0 +1,1381 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_pcd.c
+
+ @Description   FM PCD ...
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "xx_ext.h"
+#include "sprint_ext.h"
+#include "debug_ext.h"
+#include "net_ext.h"
+#include "fm_ext.h"
+#include "fm_pcd_ext.h"
+#include "fm_hc.h"
+#ifdef FM_MASTER_PARTITION
+#include "fm_pcd_ipc.h"
+#endif /* FM_MASTER_PARTITION */
+#include "fm_pcd.h"
+
+
+#ifndef CONFIG_GUEST_PARTITION
+static t_Error CheckFmPcdParameters(t_FmPcd *p_FmPcd)
+{
+    if(p_FmPcd->p_FmPcdKg && !p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Something WRONG"));
+
+    if(p_FmPcd->p_FmPcdPlcr && !p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Something WRONG"));
+
+    if(!p_FmPcd->h_Fm)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("h_Fm has to be initialized"));
+
+    if(!p_FmPcd->f_FmPcdException)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("f_FmPcdExceptions has to be initialized"));
+
+    if((!p_FmPcd->f_FmPcdIndexedException) && (p_FmPcd->p_FmPcdPlcr || p_FmPcd->p_FmPcdKg))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("f_FmPcdIndexedException has to be initialized"));
+
+   if(p_FmPcd->p_FmPcdDriverParam->prsMaxParseCycleLimit > PRS_MAX_CYCLE_LIMIT)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("prsMaxParseCycleLimit has to be less than 8191"));
+
+
+    return E_OK;
+}
+#endif  /* !CONFIG_GUEST_PARTITION */
+
+#ifdef FM_MASTER_PARTITION
+t_Error  FmPcdHandleIpcMsg(t_Handle h_FmPcd, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE])
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t                     schemeId;
+    t_Error                     err;
+    t_FmPcdKgInterModuleClsPlanSet           clsPlanSet;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    switch(msgId)
+    {
+    case (FM_PCD_MASTER_IS_ALIVE):
+        return E_OK;
+    case (FM_PCD_MASTER_IS_ENABLED):
+        return p_FmPcd->enabled;
+        //case (FM_PCD_CLEAR_PORT_PARAMS):
+            //return FmPcdDeletePortParams(h_FmPcd, (t_FmPcdInterModulePortDeleteParams*)msgBody);
+        case (FM_PCD_ALLOC_KG_RSRC):
+            {
+                err = FmPcdKgAllocSchemes(h_FmPcd,
+                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->numOfSchemes,
+                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->partitionId,
+                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->schemesIds);
+                if(err)
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+
+                err = FmPcdKgAllocClsPlanEntries(h_FmPcd,
+                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->numOfClsPlanEntries,
+                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->partitionId,
+                                            &((t_FmPcdIpcKgAllocParams*)msgBody)->clsPlanBase);
+                if(err)
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                /* build vectors of 0xFFFFFFFF for creating a private clsPlan group */
+
+            }
+            break;
+
+        case (FM_PCD_ALLOC_CLS_PLAN_EMPTY_GRP):
+            {
+                memset(clsPlanSet.vectors, 0xFF, CLS_PLAN_NUM_PER_GRP*sizeof(uint32_t));
+                clsPlanSet.baseEntry = *(uint8_t*)msgBody;
+                clsPlanSet.numOfClsPlanEntries = CLS_PLAN_NUM_PER_GRP;
+                KgSetClsPlan(h_FmPcd, &clsPlanSet);
+            }
+            break;
+        case (FM_PCD_FREE_KG_RSRC):
+            {
+                err = FmPcdKgFreeSchemes(h_FmPcd,
+                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->numOfSchemes,
+                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->partitionId,
+                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->schemesIds);
+                if(err)
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+
+                err = FmPcdKgFreeClsPlanEntries(h_FmPcd,
+                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->numOfClsPlanEntries,
+                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->partitionId,
+                                            ((t_FmPcdIpcKgAllocParams*)msgBody)->clsPlanBase);
+                if(err)
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                /* build vectors of 0xFFFFFFFF for creating a private clsPlan group */
+
+                if(((t_FmPcdIpcKgAllocParams*)msgBody)->isDriverClsPlanGrp)
+                {
+                    memset(clsPlanSet.vectors, 0x00, CLS_PLAN_NUM_PER_GRP*sizeof(uint32_t));
+                    clsPlanSet.baseEntry = ((t_FmPcdIpcKgAllocParams*)msgBody)->clsPlanBase;
+                    clsPlanSet.numOfClsPlanEntries = CLS_PLAN_NUM_PER_GRP;
+                    KgSetClsPlan(h_FmPcd, &clsPlanSet);
+                }
+            }
+            break;
+        case (FM_PCD_ALLOC_PROFILES):
+            return PlcrAllocProfiles(h_FmPcd,
+                                        ((t_FmPcdIpcPlcrAllocParams*)msgBody)->hardwarePortId,
+                                        ((t_FmPcdIpcPlcrAllocParams*)msgBody)->num,
+                                        &((t_FmPcdIpcPlcrAllocParams*)msgBody)->plcrProfilesBase);
+        case (FM_PCD_FREE_PROFILES):
+            return PlcrFreeProfiles(h_FmPcd,
+                                        ((t_FmPcdIpcPlcrAllocParams*)msgBody)->hardwarePortId,
+                                        ((t_FmPcdIpcPlcrAllocParams*)msgBody)->num,
+                                        ((t_FmPcdIpcPlcrAllocParams*)msgBody)->plcrProfilesBase);
+
+        case (FM_PCD_ALLOC_SHARED_PROFILES):
+            return PlcrAllocSharedProfiles(h_FmPcd,
+                                        ((t_FmPcdIpcSharedPlcrAllocParams*)msgBody)->num,
+                                        ((t_FmPcdIpcSharedPlcrAllocParams*)msgBody)->profilesIds);
+        case (FM_PCD_FREE_SHARED_PROFILES):
+            PlcrFreeSharedProfiles(h_FmPcd,
+                                        ((t_FmPcdIpcSharedPlcrAllocParams*)msgBody)->num,
+                                        ((t_FmPcdIpcSharedPlcrAllocParams*)msgBody)->profilesIds);
+            break;
+        case (FM_PCD_GET_PHYS_MURAM_BASE):
+            return FmGetPhysicalMuramBase(p_FmPcd->h_Fm, (t_FmPhysAddr*)msgBody);
+        case(FM_PCD_GET_SW_PRS_OFFSET):
+            ((t_FmPcdIpcSwPrsLable*)msgBody)->offset = FmPcdGetSwPrsOffset(h_FmPcd, ((t_FmPcdIpcSwPrsLable*)msgBody)->hdr, ((t_FmPcdIpcSwPrsLable*)msgBody)->indexPerHdr);
+            if(((t_FmPcdIpcSwPrsLable*)msgBody)->offset == ILLEGAL_BASE)
+                RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
+
+
+            break;
+       /* case(FM_PCD_GET_SET_KG_SCHEME_HC_PARAMS):
+            return FmPcdKgGetSetSchemeParams(h_FmPcd, (t_FmPcdInterModuleKgSchemeParams*)msgBody);*/
+        case(FM_PCD_FREE_KG_SCHEME_HC):
+            schemeId = *(uint8_t*)msgBody;
+            FmPcdKgInvalidateSchemeSw(h_FmPcd, schemeId);
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("command not found!!!"));
+    }
+    return E_OK;
+}
+#endif /* FM_MASTER_PARTITION */
+
+t_Error PcdGetVectorForOpt(t_FmPcd *p_FmPcd, uint8_t netEnvId, protocolOpt_t opt, uint32_t *p_Vector)
+{
+    uint8_t     j,k;
+
+    *p_Vector = 0;
+
+    for(j=0;(p_FmPcd->netEnvs[netEnvId].units[j].hdrs[0].hdr != HEADER_TYPE_NONE)
+            && (j < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) ;j++)
+        for(k=0;(p_FmPcd->netEnvs[netEnvId].units[j].hdrs[k].hdr != HEADER_TYPE_NONE)
+                && (k < FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS) ;k++)
+        {
+            if(p_FmPcd->netEnvs[netEnvId].units[j].hdrs[k].opt == opt)
+                *p_Vector |= p_FmPcd->netEnvs[netEnvId].unitsVectors[j];
+        }
+
+    if (!*p_Vector)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Requested option was not defined for this Network Environment Characteristics module"));
+    else
+        return E_OK;
+}
+
+t_Error PcdGetUnitsVector(t_FmPcd *p_FmPcd, t_NetEnvParams *p_Params)
+{
+    int                     i;
+
+    p_Params->vector = 0;
+    for(i=0; i<p_Params->numOfDistinctionUnits ;i++)
+    {
+        if(p_FmPcd->netEnvs[p_Params->netEnvId].units[p_Params->unitIds[i]].hdrs[0].hdr == HEADER_TYPE_NONE)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Requested unit was not defined for this Network Environment Characteristics module"));
+        ASSERT_COND(p_FmPcd->netEnvs[p_Params->netEnvId].unitsVectors[p_Params->unitIds[i]]);
+        p_Params->vector |= p_FmPcd->netEnvs[p_Params->netEnvId].unitsVectors[p_Params->unitIds[i]];
+    }
+
+    return E_OK;
+}
+
+bool PcdNetEnvIsUnitWithoutOpts(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint32_t unitVector)
+{
+    int     i=0, k;
+    /* check whether a given unit may be used by non-clsPlan users. */
+    /* first, recognize the unit by its vector */
+    while (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE)
+    {
+        if (p_FmPcd->netEnvs[netEnvId].unitsVectors[i] == unitVector)
+        {
+            for (k=0;
+                 ((k < FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS) &&
+                  (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE));
+                 k++)
+                /* check that no option exists */
+                if((protocolOpt_t)p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
+                    return FALSE;
+            break;
+        }
+        i++;
+    }
+    /* assert that a unit was found to mach the vector */
+    ASSERT_COND(p_FmPcd->netEnvs[netEnvId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE);
+
+    return TRUE;
+}
+
+void   FmPcdPortRegister(t_Handle h_FmPcd, t_Handle h_FmPort, uint8_t hardwarePortId)
+{
+    t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint16_t        pcdPortId;
+    uint8_t         portsTable[] = PCD_PORTS_TABLE;
+
+    GET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, portsTable, hardwarePortId)
+
+    p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].h_FmPort = h_FmPort;
+}
+
+uint32_t FmPcdGetLcv(t_Handle h_FmPcd, uint32_t netEnvId, uint8_t hdrNum)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    return p_FmPcd->netEnvs[netEnvId].lcvs[hdrNum];
+}
+
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+uint8_t FmPcdGetPartitionId(t_Handle h_FmPcd)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    return p_FmPcd->partitionId;
+}
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+
+t_Handle FmPcdGetHcHandle(t_Handle h_FmPcd)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    return p_FmPcd->h_Hc;
+}
+
+void FmPcdIncNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId)
+{
+    ((t_FmPcd*)h_FmPcd)->netEnvs[netEnvId].owners++;
+}
+
+void FmPcdDecNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId)
+{
+    ASSERT_COND(((t_FmPcd*)h_FmPcd)->netEnvs[netEnvId].owners);
+    ((t_FmPcd*)h_FmPcd)->netEnvs[netEnvId].owners--;
+}
+
+t_Error FmPcdTryLock(t_Handle h_FmPcd)
+{
+    TRY_LOCK_RET_ERR(((t_FmPcd*)h_FmPcd)->lock);
+    return E_OK;
+}
+
+void FmPcdReleaseLock(t_Handle h_FmPcd)
+{
+    RELEASE_LOCK(((t_FmPcd*)h_FmPcd)->lock);
+}
+
+/**********************************************************************************************************/
+/*              API                                                                                       */
+/**********************************************************************************************************/
+
+t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
+{
+    t_FmPcd *p_Pcd = NULL;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPcdParams, E_INVALID_HANDLE,NULL);
+
+    p_Pcd = (t_FmPcd *) XX_Malloc(sizeof(t_FmPcd));
+    if (!p_Pcd)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd"));
+        return NULL;
+    }
+    memset(p_Pcd, 0, sizeof(t_FmPcd));
+
+    p_Pcd->p_FmPcdDriverParam = (t_FmPcdDriverParam *) XX_Malloc(sizeof(t_FmPcdDriverParam));
+    if (!p_Pcd)
+    {
+        XX_Free(p_Pcd);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Driver Param"));
+        return NULL;
+    }
+    memset(p_Pcd->p_FmPcdDriverParam, 0, sizeof(t_FmPcdDriverParam));
+
+    p_Pcd->h_Fm = p_FmPcdParams->h_Fm;
+
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    if (p_FmPcdParams->useHostCommand)
+#endif  /* !CONFIG_MULTI_PARTITION_SUPPORT */
+    {
+        t_FmHcParams    hcParams;
+
+        memset(&hcParams, 0, sizeof(hcParams));
+        hcParams.h_Fm = p_Pcd->h_Fm;
+        hcParams.h_FmPcd = (t_Handle)p_Pcd;
+        memcpy((uint8_t*)&hcParams.params, (uint8_t*)&p_FmPcdParams->hc, sizeof(t_FmPcdHcParams));
+        p_Pcd->h_Hc = FmHcConfigAndInit(&hcParams);
+        if (!p_Pcd->h_Hc)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd HC"));
+            FM_PCD_Free(p_Pcd);
+            return NULL;
+        }
+    }
+
+    if(p_FmPcdParams->kgSupport)
+    {
+        p_Pcd->p_FmPcdKg = (t_FmPcdKg *)KgConfig(p_Pcd, p_FmPcdParams);
+        if(!p_Pcd->p_FmPcdKg)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Keygen"));
+            FM_PCD_Free(p_Pcd);
+            return NULL;
+        }
+    }
+
+    if(p_FmPcdParams->ccSupport)
+    {
+        p_Pcd->p_FmPcdCc = (t_FmPcdCc *)CcConfig(p_Pcd, p_FmPcdParams);
+        if(!p_Pcd->p_FmPcdCc)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Cc"));
+            FM_PCD_Free(p_Pcd);
+            return NULL;
+        }
+    }
+
+    if(p_FmPcdParams->plcrSupport)
+    {
+        p_Pcd->p_FmPcdPlcr = (t_FmPcdPlcr *)PlcrConfig(p_Pcd, p_FmPcdParams);
+        if(!p_Pcd->p_FmPcdPlcr)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Policer"));
+            FM_PCD_Free(p_Pcd);
+            return NULL;
+        }
+
+    }
+
+    if(p_FmPcdParams->prsSupport)
+    {
+        p_Pcd->p_FmPcdPrs = (t_FmPcdPrs *)PrsConfig(p_Pcd, p_FmPcdParams);
+        if(!p_Pcd->p_FmPcdPrs)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd Parser"));
+            FM_PCD_Free(p_Pcd);
+            return NULL;
+        }
+    }
+
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    p_Pcd->partitionId                                      = p_FmPcdParams->partitionId;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+
+#ifndef CONFIG_GUEST_PARTITION
+    p_Pcd->h_App                                            = p_FmPcdParams->h_App;
+    p_Pcd->f_FmPcdException                                 = p_FmPcdParams->f_FmPcdException;
+    p_Pcd->f_FmPcdIndexedException                          = p_FmPcdParams->f_FmPcdIdException;
+#endif  /* !CONFIG_GUEST_PARTITION */
+
+    return p_Pcd;
+}
+
+t_Error FM_PCD_Init(t_Handle h_FmPcd)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error     err;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+
+
+#ifdef CONFIG_GUEST_PARTITION
+    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_MASTER_IS_ALIVE, NULL, NULL, NULL);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+#else
+    CHECK_INIT_PARAMETERS(p_FmPcd, CheckFmPcdParameters);
+#endif /* CONFIG_GUEST_PARTITION */
+
+    if(p_FmPcd->p_FmPcdKg)
+    {
+        err = KgInit(p_FmPcd);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    if(p_FmPcd->p_FmPcdPlcr)
+    {
+        err = PlcrInit(p_FmPcd);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+#ifndef CONFIG_GUEST_PARTITION
+    if(p_FmPcd->p_FmPcdPrs)
+    {
+        err = PrsInit(p_FmPcd);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+#endif  /* CONFIG_GUEST_PARTITION */
+#ifdef FM_MASTER_PARTITION
+     /* register to inter-core messaging mechanism */
+    memset(p_FmPcd->fmPcdModuleName, 0, MODULE_NAME_SIZE);
+    if(Sprint (p_FmPcd->fmPcdModuleName, "FM-%d.PCD",FmGetId(p_FmPcd->h_Fm)) != 8)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+    err = XX_RegisterMessageHandler(p_FmPcd->fmPcdModuleName, FmPcdHandleIpcMsg, p_FmPcd);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+#endif /* FM_MASTER_PARTITION */
+
+    XX_Free(p_FmPcd->p_FmPcdDriverParam);
+    p_FmPcd->p_FmPcdDriverParam = NULL;
+
+    FmRegisterPcd(p_FmPcd->h_Fm, p_FmPcd);
+
+    return E_OK;
+}
+
+t_Error FM_PCD_Free(t_Handle h_FmPcd)
+{
+    t_FmPcd                             *p_FmPcd =(t_FmPcd *)h_FmPcd;
+#ifdef CONFIG_GUEST_PARTITION
+    t_FmPcdIpcSharedPlcrAllocParams     ipcSharedPlcrParams;
+    t_FmPcdIpcKgAllocParams             kgAlloc;
+#endif /* CONFIG_GUEST_PARTITION */
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    t_Error                             err;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+
+
+    if(p_FmPcd->p_FmPcdDriverParam)
+    {
+        XX_Free(p_FmPcd->p_FmPcdDriverParam);
+        p_FmPcd->p_FmPcdDriverParam = NULL;
+    }
+    if(p_FmPcd->p_FmPcdKg)
+    {
+
+#ifndef CONFIG_GUEST_PARTITION
+        if(p_FmPcd->p_FmPcdKg->isDriverEmptyClsPlanGrp)
+            FmPcdKgDestroyClsPlanGrp(p_FmPcd, p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId);
+#endif
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+#ifdef CONFIG_GUEST_PARTITION
+    kgAlloc.numOfSchemes = p_FmPcd->p_FmPcdKg->numOfSchemes;
+    kgAlloc.partitionId = p_FmPcd->partitionId;
+    kgAlloc.numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->numOfClsPlanEntries;
+    kgAlloc.isDriverClsPlanGrp = p_FmPcd->p_FmPcdKg->isDriverEmptyClsPlanGrp;
+    kgAlloc.clsPlanBase = p_FmPcd->p_FmPcdKg->clsPlanBase;
+    memcpy(kgAlloc.schemesIds, p_FmPcd->p_FmPcdKg->schemesIds , kgAlloc.numOfSchemes);
+    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_FREE_KG_RSRC, (uint8_t*)&kgAlloc, NULL, NULL);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+#else /* master */
+    err = FmPcdKgFreeSchemes(p_FmPcd,
+                                p_FmPcd->p_FmPcdKg->numOfSchemes,
+                                p_FmPcd->partitionId,
+                                p_FmPcd->p_FmPcdKg->schemesIds);
+    if(err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    err = FmPcdKgFreeClsPlanEntries(p_FmPcd,
+                                p_FmPcd->p_FmPcdKg->numOfClsPlanEntries,
+                                p_FmPcd->partitionId,
+                                p_FmPcd->p_FmPcdKg->clsPlanBase);
+#endif /* CONFIG_GUEST_PARTITION */
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+        XX_Free(p_FmPcd->p_FmPcdKg);
+        p_FmPcd->p_FmPcdKg = NULL;
+    }
+    if(p_FmPcd->p_FmPcdPlcr)
+    {
+        if(p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles)
+#ifdef CONFIG_GUEST_PARTITION
+    /* Alloc resources using IPC messaging */
+    ipcSharedPlcrParams.num = p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles;
+    memcpy(ipcSharedPlcrParams.profilesIds,p_FmPcd->p_FmPcdPlcr->sharedProfilesIds, p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles*sizeof(uint16_t));
+    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_FREE_SHARED_PROFILES, (uint8_t*)&ipcSharedPlcrParams, NULL, NULL);
+    if(err)
+        RETURN_ERROR(MAJOR, err,NO_MSG);
+#else /* master */
+        PlcrFreeSharedProfiles(p_FmPcd, p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles, p_FmPcd->p_FmPcdPlcr->sharedProfilesIds);
+#endif /* CONFIG_GUEST_PARTITION */
+        XX_Free(p_FmPcd->p_FmPcdPlcr);
+        p_FmPcd->p_FmPcdPlcr = NULL;
+    }
+    if(p_FmPcd->p_FmPcdPrs)
+    {
+        XX_Free(p_FmPcd->p_FmPcdPrs);
+        p_FmPcd->p_FmPcdPrs = NULL;
+    }
+    if(p_FmPcd->p_FmPcdCc)
+    {
+        CcFree(p_FmPcd->p_FmPcdCc);
+        XX_Free(p_FmPcd->p_FmPcdCc);
+        p_FmPcd->p_FmPcdCc = NULL;
+    }
+
+    if (p_FmPcd->h_Hc)
+    {
+        FmHcFree(p_FmPcd->h_Hc);
+        p_FmPcd->h_Hc = NULL;
+    }
+
+#ifdef FM_MASTER_PARTITION
+    XX_UnregisterMessageHandler(p_FmPcd->fmPcdModuleName);
+#endif /* FM_MASTER_PARTITION */
+
+    XX_Free(p_FmPcd);
+    return E_OK;
+}
+
+t_Error FM_PCD_Enable(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error             err;
+
+#ifndef CONFIG_GUEST_PARTITION
+    if(p_FmPcd->p_FmPcdKg)
+    {
+        err = KgEnable(p_FmPcd);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    if(p_FmPcd->p_FmPcdPlcr)
+    {
+        err = PlcrEnable(p_FmPcd);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    if(p_FmPcd->p_FmPcdPrs)
+    {
+        err = PrsEnable(p_FmPcd);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+    p_FmPcd->enabled = TRUE;
+
+    return E_OK;
+
+#else
+    return XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_MASTER_IS_ENABLED, NULL, NULL, NULL);
+#endif /* !CONFIG_GUEST_PARTITION */
+}
+
+t_Error FM_PCD_Disable(t_Handle h_FmPcd)
+{
+/*    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;*/
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+
+    return E_OK;
+}
+
+t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams  *p_NetEnvParams)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t                 bitId = 0;
+    uint8_t                 privateBitId = 0;
+    uint8_t                 i, j, k;
+    uint8_t                 netEnvCurrId;
+    uint8_t                 ipsecAhUnit = 0,ipsecEspUnit = 0;
+    bool                    ipsecAhExists = FALSE,ipsecEspExists = FALSE;
+    uint8_t                 hdrNum;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_STATE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, NULL);
+
+    TRY_LOCK_RET_NULL(p_FmPcd->lock);
+
+    /* find a new netEnv */
+    for(i = 0;i<PCD_MAX_NUM_OF_PORTS;i++)
+        if(!p_FmPcd->netEnvs[i].used)
+            break;
+
+    if(i== PCD_MAX_NUM_OF_PORTS)
+    {
+        REPORT_ERROR(MAJOR, E_FULL,("No more than %d netEnv's allowed.", PCD_MAX_NUM_OF_PORTS));
+        RELEASE_LOCK(p_FmPcd->lock);
+        return NULL;
+    }
+
+    p_FmPcd->netEnvs[i].used = TRUE;
+
+    TRY_LOCK_RET_NULL(p_FmPcd->netEnvs[i].lock);
+    RELEASE_LOCK(p_FmPcd->lock);
+
+    netEnvCurrId = (uint8_t)i;
+
+    /* clear from previous use */
+    memset(&p_FmPcd->netEnvs[netEnvCurrId].units, 0, FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
+    memcpy(&p_FmPcd->netEnvs[netEnvCurrId].units, p_NetEnvParams->units, p_NetEnvParams->numOfDistinctionUnits*sizeof(t_FmPcdDistinctionUnit));
+
+    /* check that header with opt is not interchanged with the same header */
+    for(i=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE)
+            && (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) ;i++)
+        for(k=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE)
+                && (k < FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS) ;k++)
+        {
+            /* if an option exists, check that other headers are not the same header
+            without option */
+            if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt)
+            {
+                for(j=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].hdr != HEADER_TYPE_NONE)
+                        && (j < FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS) ;j++)
+                    if((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].hdr == p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr) &&
+                        !p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].opt)
+                    {
+                        REPORT_ERROR(MINOR, E_FULL, ("Illegal unit - header with opt may not be interchangable with the same header without opt"));
+                        RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
+                        return NULL;
+                    }
+            }
+        }
+
+    /* IPSEC_AH and IPSEC_SPI can't be 2 units,  */
+    /* check that header with opt is not interchanged with the same header */
+    for(i=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE)
+            && (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) ;i++)
+        for(k=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE)
+                && (k < FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS) ;k++)
+        {
+            /* Some headers pairs may not be defined on different units as the parser
+            doesn't distingush  */
+            if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPSEC_AH)
+            {
+                if (ipsecEspExists && (ipsecEspUnit != i))
+                {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, ("HEADER_TYPE_IPSEC_AH and HEADER_TYPE_IPSEC_ESP may not be defined in separate units"));
+                    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
+                   return NULL;
+                }
+                else
+                {
+                    ipsecAhUnit = i;
+                    ipsecAhExists = TRUE;
+                }
+            }
+            if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPSEC_ESP)
+            {
+                if (ipsecAhExists && (ipsecAhUnit != i))
+                {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, ("HEADER_TYPE_IPSEC_AH and HEADER_TYPE_IPSEC_ESP may not be defined in separate units"));
+                    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
+                    return NULL;
+                }
+                else
+                {
+                    ipsecEspUnit = i;
+                    ipsecEspExists = TRUE;
+                }
+            }
+       }
+
+
+    /* if private header (shim), check that no other headers specified */
+    for(i=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE)
+            && (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) ;i++)
+    {
+        if(IS_PRIVATE_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
+            if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[1].hdr != HEADER_TYPE_NONE)
+            {
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("SHIM header may not be interchangesd with other headers"));
+                RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
+                return NULL;
+            }
+    }
+
+    for(i=0; i<p_NetEnvParams->numOfDistinctionUnits;i++)
+    {
+        if (IS_PRIVATE_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
+            p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = (uint32_t)(0x00000001 << privateBitId++);
+        else
+            p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = (uint32_t)(0x80000000 >> bitId++);
+    }
+
+    /* define a set of hardware parser LCV's according to the defined netenv */
+
+    /* set an array of LCV's for each header in the netEnv */
+    for(i=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE)
+            && (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) ;i++)
+        /* private headers have no LCV in the hard parser */
+        if (!IS_PRIVATE_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
+        {
+            for(k=0;(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE)
+                    && (k < FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS) ;k++)
+            {
+                GET_PRS_HDR_NUM(hdrNum, p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr);
+                if (hdrNum == ILLEGAL_HDR_NUM)
+                {
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
+                    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
+                    return NULL;
+                }
+                p_FmPcd->netEnvs[netEnvCurrId].lcvs[hdrNum] |= p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i];
+            }
+        }
+
+    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
+
+    return CAST_UINT32_TO_POINTER((uint32_t)netEnvCurrId+1);
+}
+
+t_Error FM_PCD_DeleteNetEnvCharacteristics(t_Handle h_FmPcd, t_Handle h_NetEnv)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t                 netEnvId = (uint8_t)(CAST_POINTER_TO_UINT32(h_NetEnv)-1);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    TRY_LOCK_RET_ERR(p_FmPcd->netEnvs[netEnvId].lock);
+    /* check that no port is bound to this netEnv */
+    if(p_FmPcd->netEnvs[netEnvId].owners)
+       RETURN_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a netEnv that has ports/schemes/trees/clsPlanGrps bound to"));
+
+    p_FmPcd->netEnvs[netEnvId].used= FALSE;
+
+    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvId].lock);
+
+    return E_OK;
+}
+
+void FM_PCD_HcTxConf(t_Handle h_FmPcd, t_FmFD *p_Fd)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN(h_FmPcd, E_INVALID_STATE);
+
+    FmHcTxConf(p_FmPcd->h_Hc, p_Fd);
+}
+
+#ifndef CONFIG_GUEST_PARTITION
+t_Error FM_PCD_ConfigException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable)
+{
+    t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t        bitMask = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    GET_FM_PCD_EXCEPTION_FLAG(bitMask, exception);
+    if(bitMask)
+    {
+        if (enable)
+            p_FmPcd->exceptions |= bitMask;
+        else
+            p_FmPcd->exceptions &= ~bitMask;
+   }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    return E_OK;
+}
+
+t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable)
+{
+    t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t        bitMask = 0, tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    GET_FM_PCD_EXCEPTION_FLAG(bitMask, exception);
+
+    if(bitMask)
+    {
+        if (enable)
+            p_FmPcd->exceptions |= bitMask;
+        else
+            p_FmPcd->exceptions &= ~bitMask;
+
+        switch(exception)
+        {
+            case(e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC):
+            case(e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW):
+                if(!p_FmPcd->p_FmPcdKg)
+                    RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - keygen is not working"));
+                break;
+            case(e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC):
+            case(e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR):
+            case(e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
+            case(e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
+                if(!p_FmPcd->p_FmPcdPlcr)
+                    RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - policer is not working"));
+            break;
+            case(e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
+            case(e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
+            case(e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS):
+            case(e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS):
+                if(!p_FmPcd->p_FmPcdPrs)
+                    RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - parser is not working"));
+            break;
+            default:
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported exception"));
+
+        }
+
+        switch(exception)
+        {
+            case(e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
+                if(enable)
+                    tmpReg |= FM_PCD_KG_DOUBLE_ECC;
+                else
+                    tmpReg &= ~FM_PCD_KG_DOUBLE_ECC;
+                WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer, tmpReg);
+                break;
+            case(e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
+                if(enable)
+                    tmpReg |= FM_PCD_KG_KEYSIZE_OVERFLOW;
+                else
+                    tmpReg &= ~FM_PCD_KG_KEYSIZE_OVERFLOW;
+                WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer, tmpReg);
+                break;
+            case(e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer);
+                if(enable)
+                    tmpReg |= FM_PCD_PRS_DOUBLE_ECC;
+                else
+                    tmpReg &= ~FM_PCD_PRS_DOUBLE_ECC;
+                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer, tmpReg);
+                break;
+            case(e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer);
+                if(enable)
+                    tmpReg |= FM_PCD_PRS_ILLEGAL_ACCESS;
+                else
+                    tmpReg &= ~FM_PCD_PRS_ILLEGAL_ACCESS;
+                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer, tmpReg);
+                break;
+            case(e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer);
+                if(enable)
+                    tmpReg |= FM_PCD_PRS_PORT_ILLEGAL_ACCESS;
+                else
+                    tmpReg &= ~FM_PCD_PRS_PORT_ILLEGAL_ACCESS;
+                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer, tmpReg);
+                break;
+            case(e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pever);
+                if(enable)
+                    tmpReg |= FM_PCD_PRS_SINGLE_ECC;
+                else
+                    tmpReg &= ~FM_PCD_PRS_SINGLE_ECC;
+                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pever, tmpReg);
+                break;
+            case(e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier);
+                if(enable)
+                    tmpReg |= FM_PCD_PLCR_DOUBLE_ECC;
+                else
+                    tmpReg &= ~FM_PCD_PLCR_DOUBLE_ECC;
+                WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier, tmpReg);
+                break;
+            case(e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier);
+                if(enable)
+                    tmpReg |= FM_PCD_PLCR_INIT_ENTRY_ERROR;
+                else
+                    tmpReg &= ~FM_PCD_PLCR_INIT_ENTRY_ERROR;
+                WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier, tmpReg);
+                break;
+            case(e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier);
+                if(enable)
+                    tmpReg |= FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE;
+                else
+                    tmpReg &= ~FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE;
+                WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier, tmpReg);
+                break;
+            case(e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
+                tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier);
+                if(enable)
+                    tmpReg |= FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE;
+                else
+                    tmpReg &= ~FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE;
+                WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier, tmpReg);
+                break;
+             default:
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported exception"));
+        }
+        /* for ECC exceptions driver automatically enables ECC mechanism, if disabled.
+           Driver does NOT disables them automatically, as we do not control which
+           of the rams are enabled and which arn't */
+        if(enable && ( (exception == e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC) |
+                       (exception == e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC) |
+                       (exception == e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC) |
+                       (exception == e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC)))
+            if(!FmRamsEccIsExternalCtl(p_FmPcd->h_Fm))
+                FM_EnableRamsEcc(p_FmPcd->h_Fm);
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    return E_OK;
+}
+
+uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
+{
+    t_FmPcd            *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
+
+    switch(counter)
+    {
+        case(e_FM_PCD_KG_COUNTERS_TOTAL):
+            if(!p_FmPcd->p_FmPcdKg)
+            {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
+                return 0;
+            }
+            break;
+        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
+        case(e_FM_PCD_PLCR_COUNTERS_RED):
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
+        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+            if(!p_FmPcd->p_FmPcdPlcr)
+            {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
+                return 0;
+            }
+            /* check that counters are enabled */
+            if(!(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr) & FM_PCD_PLCR_GCR_STEN))
+            {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+                return 0;
+            }
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+            if(!p_FmPcd->p_FmPcdPrs)
+            {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
+                return 0;
+            }
+            break;
+        default:
+            REPORT_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
+            return 0;
+    }
+    switch(counter)
+    {
+        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pds);
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rrs);
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rrs);
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rrs);
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srrs);
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rres);
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rres);
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rres);
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srres);
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spcs);
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spscs);
+        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->hxscs);
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrcs);
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrscs);
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwcs);
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwscs);
+        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+               return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fcscs);
+        case(e_FM_PCD_KG_COUNTERS_TOTAL):
+               return GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgtpc);
+
+        /*Policer statictics*/
+        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
+                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ypcnt);
+        case(e_FM_PCD_PLCR_COUNTERS_RED):
+                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rpcnt);
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rrpcnt);
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rypcnt);
+        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
+                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_tpcnt);
+        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+                return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_flmcnt);
+
+        default:
+            REPORT_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
+            return 0;
+    }
+}
+
+t_Error FM_PCD_SetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t value)
+{
+    t_FmPcd            *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    switch(counter)
+    {
+        case(e_FM_PCD_KG_COUNTERS_TOTAL):
+            if(!p_FmPcd->p_FmPcdKg)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters - keygen is not working"));
+            break;
+        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
+        case(e_FM_PCD_PLCR_COUNTERS_RED):
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
+        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+            if(!p_FmPcd->p_FmPcdPlcr)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters - Policer is not working"));
+            if(!(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr) & FM_PCD_PLCR_GCR_STEN))
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+            if(!p_FmPcd->p_FmPcdPrs)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
+    }
+    switch(counter)
+    {
+        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pds, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rrs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rrs, value);
+             break;
+       case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rrs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srrs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rres, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rres, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rres, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srres, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spcs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spscs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->hxscs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrcs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrscs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwcs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwscs, value);
+            break;
+        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+               WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fcscs, value);
+             break;
+        case(e_FM_PCD_KG_COUNTERS_TOTAL):
+            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgtpc,value);
+            break;
+
+        /*Policer counters*/
+        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
+            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ypcnt, value);
+            break;
+        case(e_FM_PCD_PLCR_COUNTERS_RED):
+            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rpcnt, value);
+            break;
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+             WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rrpcnt, value);
+            break;
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+              WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rypcnt, value);
+            break;
+        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
+              WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_tpcnt, value);
+            break;
+        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+              WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_flmcnt, value);
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported type of counter"));
+    }
+
+return E_OK;
+}
+
+
+
+t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception)
+{
+    t_FmPcd            *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    switch(exception)
+    {
+        case(e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC):
+        case(e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW):
+            if(!p_FmPcd->p_FmPcdKg)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - keygen is not working"));
+            break;
+        case(e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC):
+        case(e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR):
+        case(e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
+        case(e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
+            if(!p_FmPcd->p_FmPcdPlcr)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - policer is not working"));
+            break;
+        case(e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
+        case(e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
+        case(e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS):
+        case(e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS):
+            if(!p_FmPcd->p_FmPcdPrs)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt -parsrer is not working"));
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Invalid interrupt requested"));
+
+    }
+    switch(exception)
+    {
+        case e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_DOUBLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr, FM_PCD_PRS_DOUBLE_ECC);
+            break;
+        case e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_ILLEGAL_ACCESS))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr, FM_PCD_PRS_ILLEGAL_ACCESS);
+            break;
+        case e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_PORT_ILLEGAL_ACCESS))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr, /*FM_PCD_PRS_PORT_ILLEGAL_ACCESS*/0x80000000);
+            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr, /*FM_PCD_PRS_PORT_ILLEGAL_ACCESS*/0x00800000);
+            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr, FM_PCD_PRS_PORT_ILLEGAL_ACCESS);
+            break;
+        case e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_SINGLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevfr, FM_PCD_PRS_SINGLE_ECC);
+            break;
+        case e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, FM_PCD_KG_DOUBLE_ECC);
+            break;
+        case e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, FM_PCD_KG_KEYSIZE_OVERFLOW);
+            break;
+        case e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PLCR_DOUBLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr, FM_PCD_PLCR_DOUBLE_ECC);
+            break;
+        case e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PLCR_INIT_ENTRY_ERROR))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr, FM_PCD_PLCR_INIT_ENTRY_ERROR);
+            break;
+        case e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr, FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE);
+            break;
+        case e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE:
+            if (!(p_FmPcd->exceptions & FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr, FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE);
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception may not be forced"));
+    }
+
+    return E_OK;
+}
+
+#ifdef VERIFICATION_SUPPORT
+void FM_PCD_BackdoorSet (t_Handle h_FmPcd, e_ModuleId moduleId, uint32_t offset, uint32_t value)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t            base;
+
+    SANITY_CHECK_RETURN(h_FmPcd, E_INVALID_HANDLE);
+
+    switch(moduleId)
+    {
+        case e_MODULE_ID_FM1_PRS:
+        case e_MODULE_ID_FM2_PRS:
+            base = FmGetPcdPrsBaseAddr(p_FmPcd);
+            break;
+        case e_MODULE_ID_FM1_PLCR:
+        case e_MODULE_ID_FM2_PLCR:
+            base = FmGetPcdPlcrBaseAddr(p_FmPcd);
+            break;
+        case e_MODULE_ID_FM1_KG:
+        case e_MODULE_ID_FM2_KG:
+            base = FmGetPcdKgBaseAddr(p_FmPcd);
+            break;
+        default:
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            return;
+
+    }
+    WRITE_UINT32(*(uint32_t*)(base+offset), value);
+}
+
+uint32_t      FM_PCD_BackdoorGet(t_Handle h_FmPcd, e_ModuleId moduleId, uint32_t offset)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t            base;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+
+    switch(moduleId)
+    {
+        case e_MODULE_ID_FM1_PRS:
+        case e_MODULE_ID_FM2_PRS:
+            base = FmGetPcdPrsBaseAddr(p_FmPcd);
+            break;
+        case e_MODULE_ID_FM1_PLCR:
+        case e_MODULE_ID_FM2_PLCR:
+            base = FmGetPcdPlcrBaseAddr(p_FmPcd);
+            break;
+        case e_MODULE_ID_FM1_KG:
+        case e_MODULE_ID_FM2_KG:
+            base = FmGetPcdKgBaseAddr(p_FmPcd);
+            break;
+        default:
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            return 0;
+    }
+
+    return GET_UINT32(*(uint32_t*)(base+offset));
+}
+#endif /*VERIFICATION_SUPPORT*/
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_PCD_DumpRegs(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    if (p_FmPcd->p_FmPcdKg)
+        FM_PCD_KgDumpRegs(h_FmPcd);
+    if (p_FmPcd->p_FmPcdPlcr)
+        FM_PCD_PlcrDumpRegs(h_FmPcd);
+    if (p_FmPcd->p_FmPcdPrs)
+        FM_PCD_PrsDumpRegs(h_FmPcd);
+    return E_OK;
+ }
+#endif /* (defined(DEBUG_ERRORS) && ... */
+#endif /* ! CONFIG_GUEST_PARTITION */
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
new file mode 100644
index 0000000..96043d5
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
@@ -0,0 +1,950 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_pcd.h
+
+ @Description   FM PCD ...
+*//***************************************************************************/
+#ifndef __FM_PCD_H
+#define __FM_PCD_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+#include "fm_pcd_ext.h"
+
+#include "fm_common.h"
+
+
+/**************************************************************************//**
+ @Group         FM_PCD_Runtime_grp FM PCD Runtime Unit
+ @{
+*//***************************************************************************/
+
+/****************************/
+/* General defines          */
+/****************************/
+
+#define GET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, pcdPortsTable, hardwarePortId)\
+    pcdPortId = 0;\
+    while((hardwarePortId != pcdPortsTable[pcdPortId]) && (pcdPortId<PCD_MAX_NUM_OF_PORTS))\
+        pcdPortId++;
+
+#define PCD_PORTS_TABLE                     {1,2,3,4,5,6,7,8,9,10,11,16}
+#define GET_GLOBAL_PORTID_FROM_PCD_PORTS_TABLE(hardwarePortId, pcdPortsTable,i)\
+    hardwarePortId = pcdPortsTable[i]
+
+
+#define ILLEGAL_PCD_PORTID                  0xFF
+#define ILLEGAL_CLS_PLAN                    0xFF
+
+#define GET_PCD_PORTID_BY_RELATIVE(portId,type,id)      \
+switch(type) {                              \
+    case(e_FM_PORT_TYPE_OFFLINE_PARSING):   \
+        if (id > (LAST_HO_PORTID-BASE_HO_PORTID))       \
+            portId = ILLEGAL_PCD_PORTID;    \
+        else                                \
+            portId = id; break;             \
+     case(e_FM_PORT_TYPE_RX):               \
+        if (id > (LAST_RX_PORTID-BASE_RX_PORTID))       \
+            portId = ILLEGAL_PCD_PORTID;    \
+        else                                \
+            portId = id+MAX_NUM_OF_OP_PORTS;\
+        break;                              \
+      case(e_FM_PORT_TYPE_RX_10G):          \
+        if (id > (LAST_RX10_PORTID-BASE_RX10_PORTID))   \
+            portId = ILLEGAL_PCD_PORTID;    \
+        else                                \
+            portId = id+MAX_NUM_OF_OP_PORTS + MAX_NUM_OF_RX_1G_PORTS;    \
+        break;                              \
+      default:                              \
+        portId = ILLEGAL_PCD_PORTID;        \
+}
+
+#define IS_PRIVATE_HEADER(hdr)              ((hdr == HEADER_TYPE_USER_DEFINED_SHIM1 ) ||   \
+                                            (hdr == HEADER_TYPE_USER_DEFINED_SHIM2) ||    \
+                                            (hdr == HEADER_TYPE_USER_DEFINED_SHIM3))
+
+/****************************/
+/* Error defines           */
+/****************************/
+#define FM_PCD_EX_KG_DOUBLE_ECC                     0x80000000
+#define FM_PCD_EX_KG_KEYSIZE_OVERFLOW               0x40000000
+
+#define FM_PCD_EX_PLCR_DOUBLE_ECC                   0x20000000
+#define FM_PCD_EX_PLCR_INIT_ENTRY_ERROR             0x10000000
+#define FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE      0x08000000
+#define FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE       0x04000000
+
+#define FM_PCD_EX_PRS_DOUBLE_ECC                    0x02000000
+#define FM_PCD_EX_PRS_SINGLE_ECC                    0x01000000
+#define FM_PCD_EX_PRS_ILLEGAL_ACCESS                0x00800000
+#define FM_PCD_EX_PRS_PORT_ILLEGAL_ACCESS           0x00400000
+
+#define GET_FM_PCD_EXCEPTION_FLAG(bitMask, exception)               \
+switch(exception){                                                  \
+    case e_FM_PCD_KG_ERR_EXCEPTION_DOUBLE_ECC:                      \
+        bitMask = FM_PCD_EX_KG_DOUBLE_ECC; break;                   \
+    case e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC:                    \
+        bitMask = FM_PCD_EX_PLCR_DOUBLE_ECC; break;                 \
+    case e_FM_PCD_KG_ERR_EXCEPTION_KEYSIZE_OVERFLOW:                \
+        bitMask = FM_PCD_EX_KG_KEYSIZE_OVERFLOW; break;             \
+    case e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR:              \
+        bitMask = FM_PCD_EX_PLCR_INIT_ENTRY_ERROR; break;           \
+    case e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE:           \
+        bitMask = FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE; break;    \
+    case e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE:            \
+        bitMask = FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE; break;     \
+    case e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC:                         \
+        bitMask = FM_PCD_EX_PRS_DOUBLE_ECC; break;                  \
+    case e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS:                     \
+        bitMask = FM_PCD_EX_PRS_ILLEGAL_ACCESS; break;              \
+    case e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC:                         \
+        bitMask = FM_PCD_EX_PRS_SINGLE_ECC; break;                  \
+    case e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS:                \
+        bitMask = FM_PCD_EX_PRS_PORT_ILLEGAL_ACCESS; break;         \
+    default: bitMask = 0;break;}
+
+
+/***********************************************************************/
+/*          SW parser L4 shells patch                                  */
+/***********************************************************************/
+#define SW_PRS_L4_PATCH                         \
+{   0x31,0x92,0x02,0x1f,0x00,0x32,0x00,0x78,    \
+    0x00,0x34,0x32,0xf0,0x00,0x50,0x00,0x0c,    \
+    0x28,0x5e,0x83,0x8e,0x29,0x32,0xaf,0x8e,    \
+    0x31,0xb2,0x9f,0xff,0x00,0x06,0xaf,0xbf,    \
+    0x00,0x06,0x29,0x36,0x00,0x01,0x1b,0xff,    \
+    0x32,0xf0,0x00,0x50,0x00,0x08,0x28,0x5e,    \
+    0x08,0x99,0x00,0x00,0x9f,0x8e,0x31,0xb2,    \
+    0x9f,0xff,0x00,0x06,0x29,0x36,0x00,0x01,    \
+    0x1b,0xff,0x32,0xf0,0x00,0x50,0x00,0x04,    \
+    0x28,0x5e,0x8f,0x9e,0x29,0x32,0x31,0xb2,    \
+    0x8f,0xbf,0x00,0x06,0x29,0x36,0x00,0x01,    \
+    0x1b,0xff,0x32,0xf0,0x00,0x50,0x00,0x04,    \
+    0x28,0x5e,0x8f,0x9e,0x29,0x32,0x31,0xb2,    \
+    0x8f,0xbf,0x00,0x06,0x29,0x36,0x00,0x01,    \
+    0x1b,0xff,0x00,0x00,0x00,0x00,0x00,0x00};
+
+#define SW_PRS_L4_PATCH_SIZE                120
+
+/****************************/
+/* Parser defines           */
+/****************************/
+/* masks */
+#define PRS_ERR_CAP                         0x80000000
+#define PRS_ERR_TYPE_DOUBLE                 0x40000000
+#define PRS_ERR_SINGLE_ECC_CNT_MASK         0x00FF0000
+#define PRS_ERR_ADDR_MASK                   0x000001FF
+#define FM_PCD_PRS_RPIMAC_EN                0x00000001
+#define FM_PCD_PRS_SINGLE_ECC               0x00004000
+#define FM_PCD_PRS_PORT_IDLE_STS            0xffff0000
+#define FM_PCD_PRS_DOUBLE_ECC               0x00004000
+#define FM_PCD_PRS_PORT_ILLEGAL_ACCESS      0xffff0000
+#define FM_PCD_PRS_ILLEGAL_ACCESS           0x00008000
+#define FM_PCD_PRS_PPSC_ALL_PORTS           0xffff0000
+
+/* others */
+#define PRS_MAX_CYCLE_LIMIT                 8191
+#define PRS_SW_DATA                         0x00000800
+#define PRS_REGS_OFFSET                     0x00000840
+
+#define GET_FM_PCD_PRS_PORT_ID(prsPortId,hardwarePortId) \
+    prsPortId = (uint8_t)(hardwarePortId & 0x0f)
+
+#define GET_FM_PCD_PORT_ID_FROM_PRS(pcdPortId, prsPortId) \
+    pcdPortId = (prsPortId == 0) ? 0x10:prsPortId;
+
+#define GET_FM_PCD_INDEX_FLAG(bitMask, prsPortId)    \
+    bitMask = 0x80000000>>prsPortId
+
+
+/***********************************************************************/
+/*          Keygen defines                                             */
+/***********************************************************************/
+/* Masks */
+#define FM_PCD_KG_KGGCR_EN                      0x80000000
+#define KG_SCH_GEN_VALID                        0x80000000
+#define KG_SCH_GEN_EXTRACT_TYPE                 0x00008000
+#define KG_ERR_CAP                              0x80000000
+#define KG_ERR_TYPE_DOUBLE                      0x40000000
+#define KG_ERR_ADDR_MASK                        0x00000FFF
+#define FM_PCD_KG_DOUBLE_ECC                    0x80000000
+#define FM_PCD_KG_KEYSIZE_OVERFLOW              0x40000000
+#define KG_SCH_MODE_EN                          0x80000000
+
+/* shifts */
+#define FM_PCD_KG_PE_CPP_MASK_SHIFT             16
+#define FM_PCD_KG_KGAR_WSEL_SHIFT               8
+
+/* others */
+#define KG_DOUBLE_MEANING_REGS_OFFSET           0x100
+#define NO_VALIDATION                           0x70
+#define KG_ACTION_REG_TO                        1024
+#define KG_MAX_PROFILE                          255
+#define SCHEME_ALWAYS_DIRECT                    0xFFFFFFFF
+
+typedef struct {
+    bool        known;
+    uint8_t     id;
+} t_FmPcdKgSchemesExtractsEntry;
+
+typedef struct {
+    t_FmPcdKgSchemesExtractsEntry extractsArray[FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+} t_FmPcdKgSchemesExtracts;
+
+/***********************************************************************/
+/*          Policer defines                                            */
+/***********************************************************************/
+
+/* masks */
+#define FM_PCD_PLCR_PEMODE_PI                 0x80000000
+#define FM_PCD_PLCR_PEMODE_CBLND              0x40000000
+#define FM_PCD_PLCR_PEMODE_ALG_MASK           0x30000000
+#define FM_PCD_PLCR_PEMODE_ALG_RFC2698        0x10000000
+#define FM_PCD_PLCR_PEMODE_ALG_RFC4115        0x20000000
+#define FM_PCD_PLCR_PEMODE_DEFC_MASK          0x0C000000
+#define FM_PCD_PLCR_PEMODE_DEFC_Y             0x04000000
+#define FM_PCD_PLCR_PEMODE_DEFC_R             0x08000000
+#define FM_PCD_PLCR_PEMODE_DEFC_OVERRIDE      0x0C000000
+#define FM_PCD_PLCR_PEMODE_OVCLR_MASK         0x03000000
+#define FM_PCD_PLCR_PEMODE_OVCLR_Y            0x01000000
+#define FM_PCD_PLCR_PEMODE_OVCLR_R            0x02000000
+#define FM_PCD_PLCR_PEMODE_OVCLR_G_NC         0x03000000
+#define FM_PCD_PLCR_PEMODE_PKT                0x00800000
+#define FM_PCD_PLCR_PEMODE_FPP_MASK           0x001F0000
+#define FM_PCD_PLCR_PEMODE_FPP_SHIFT          16
+#define FM_PCD_PLCR_PEMODE_FLS_MASK           0x0000F000
+#define FM_PCD_PLCR_PEMODE_FLS_L2             0x00003000
+#define FM_PCD_PLCR_PEMODE_FLS_L3             0x0000B000
+#define FM_PCD_PLCR_PEMODE_FLS_L4             0x0000E000
+#define FM_PCD_PLCR_PEMODE_FLS_FULL           0x0000F000
+#define FM_PCD_PLCR_PEMODE_RBFLS              0x00000800
+#define FM_PCD_PLCR_PEMODE_TRA                0x00000004
+#define FM_PCD_PLCR_PEMODE_TRB                0x00000002
+#define FM_PCD_PLCR_PEMODE_TRC                0x00000001
+#define FM_PCD_PLCR_DOUBLE_ECC                0x80000000
+#define FM_PCD_PLCR_INIT_ENTRY_ERROR          0x40000000
+#define FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE   0x80000000
+#define FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE    0x40000000
+
+#define FM_PCD_PLCR_NIA_VALID                 0x80000000
+
+#define FM_PCD_PLCR_GCR_EN                    0x80000000
+#define FM_PCD_PLCR_GCR_STEN                  0x40000000
+#define FM_PCD_PLCR_GCR_DAR                   0x20000000
+#define FM_PCD_PLCR_GCR_DEFNIA                0x00FFFFFF
+#define FM_PCD_PLCR_NIA_ABS                   0x00000100
+
+#define FM_PCD_PLCR_GSR_BSY                   0x80000000
+#define FM_PCD_PLCR_GSR_DQS                   0x60000000
+#define FM_PCD_PLCR_GSR_RPB                   0x20000000
+#define FM_PCD_PLCR_GSR_FQS                   0x0C000000
+#define FM_PCD_PLCR_GSR_LPALG                 0x0000C000
+#define FM_PCD_PLCR_GSR_LPCA                  0x00003000
+#define FM_PCD_PLCR_GSR_LPNUM                 0x000000FF
+
+#define FM_PCD_PLCR_EVR_PSIC                  0x80000000
+#define FM_PCD_PLCR_EVR_AAC                   0x40000000
+
+#define FM_PCD_PLCR_PAR_PSI                   0x20000000
+#define FM_PCD_PLCR_PAR_PNUM                  0x00FF0000
+/* PWSEL Selctive select options */
+#define FM_PCD_PLCR_PAR_PWSEL_PEMODE          0x00008000    /* 0 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEGNIA          0x00004000    /* 1 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEYNIA          0x00002000    /* 2 */
+#define FM_PCD_PLCR_PAR_PWSEL_PERNIA          0x00001000    /* 3 */
+#define FM_PCD_PLCR_PAR_PWSEL_PECIR           0x00000800    /* 4 */
+#define FM_PCD_PLCR_PAR_PWSEL_PECBS           0x00000400    /* 5 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEPIR_EIR       0x00000200    /* 6 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEPBS_EBS       0x00000100    /* 7 */
+#define FM_PCD_PLCR_PAR_PWSEL_PELTS           0x00000080    /* 8 */
+#define FM_PCD_PLCR_PAR_PWSEL_PECTS           0x00000040    /* 9 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEPTS_ETS       0x00000020    /* 10 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEGPC           0x00000010    /* 11 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEYPC           0x00000008    /* 12 */
+#define FM_PCD_PLCR_PAR_PWSEL_PERPC           0x00000004    /* 13 */
+#define FM_PCD_PLCR_PAR_PWSEL_PERYPC          0x00000002    /* 14 */
+#define FM_PCD_PLCR_PAR_PWSEL_PERRPC          0x00000001    /* 15 */
+
+#define FM_PCD_PLCR_PAR_PMR_BRN_1TO1          0x0000      /* - Full bit replacement. {PBNUM[0:N-1]
+                                                           1-> 2^N specific locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_2TO2          0x1      /* - {PBNUM[0:N-2],PNUM[N-1]}.
+                                                           2-> 2^(N-1) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_4TO4          0x2      /* - {PBNUM[0:N-3],PNUM[N-2:N-1]}.
+                                                           4-> 2^(N-2) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_8TO8          0x3      /* - {PBNUM[0:N-4],PNUM[N-3:N-1]}.
+                                                           8->2^(N-3) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_16TO16        0x4      /* - {PBNUM[0:N-5],PNUM[N-4:N-1]}.
+                                                           16-> 2^(N-4) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_32TO32        0x5      /* {PBNUM[0:N-6],PNUM[N-5:N-1]}.
+                                                           32-> 2^(N-5) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_64TO64        0x6      /* {PBNUM[0:N-7],PNUM[N-6:N-1]}.
+                                                           64-> 2^(N-6) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_128TO128      0x7      /* {PBNUM[0:N-8],PNUM[N-7:N-1]}.
+                                                            128-> 2^(N-7) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_256TO256      0x8      /* - No bit replacement for N=8. {PNUM[N-8:N-1]}.
+                                                            When N=8 this option maps all 256 profiles by the DISPATCH bus into one group. */
+
+#define FM_PCD_PLCR_PMR_V                     0x80000000
+#define PLCR_ERR_ECC_CAP                      0x80000000
+#define PLCR_ERR_ECC_TYPE_DOUBLE              0x40000000
+#define PLCR_ERR_ECC_PNUM_MASK                0x00000FF0
+#define PLCR_ERR_ECC_OFFSET_MASK              0x0000000F
+
+#define PLCR_ERR_UNINIT_CAP                   0x80000000
+#define PLCR_ERR_UNINIT_NUM_MASK              0x000000FF
+#define PLCR_ERR_UNINIT_PID_MASK              0x003f0000
+#define PLCR_ERR_UNINIT_ABSOLUTE_MASK         0x00008000
+
+/* shifts */
+#define PLCR_ERR_ECC_PNUM_SHIFT               4
+#define PLCR_ERR_UNINIT_PID_SHIFT             16
+
+#define FM_PCD_PLCR_PMR_BRN_SHIFT             16
+
+/* others */
+#define WAIT_FOR_PLCR_EVR_AAC \
+{\
+    uint32_t count = 0; \
+    uint32_t tmpReg32; \
+    while (count < FM_PCD_PLCR_POLL) \
+    { \
+        tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->fmpl_evr);\
+        if (!( tmpReg32 & FM_PCD_PLCR_EVR_AAC)) break;\
+        count++;\
+    }\
+}
+
+#define WAIT_FOR_PLCR_PAR_GO \
+{\
+    uint32_t count = 0; \
+    uint32_t tmpReg32; \
+    while (count < FM_PCD_PLCR_POLL) \
+    { \
+        tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->fmpl_par);\
+        if (!( tmpReg32 & FM_PCD_PLCR_PAR_GO)) break;\
+        count++; \
+    }\
+}
+
+#define PLCR_PORT_WINDOW_SIZE(hardwarePortId)
+
+/***********************************************************************/
+/*          Coarse classification defines                              */
+/***********************************************************************/
+
+#define CC_PC_FF_MACDST            0x00
+#define CC_PC_FF_MACSRC            0x01
+#define CC_PC_FF_ETYPE             0x02
+
+#define CC_PC_FF_TCI1              0x03
+#define CC_PC_FF_TCI2              0x04
+
+#define CC_PC_FF_MPLS1             0x06
+#define CC_PC_FF_MPLS_LAST         0x07
+
+#define CC_PC_FF_IPV4DST1          0x08
+#define CC_PC_FF_IPV4DST2          0x16
+#define CC_PC_FF_IPV4IPTOS_TC1     0x09
+#define CC_PC_FF_IPV4IPTOS_TC2     0x17
+#define CC_PC_FF_IPV4PTYPE1        0x0A
+#define CC_PC_FF_IPV4PTYPE2        0x18
+#define CC_PC_FF_IPV4SRC1          0x0b
+#define CC_PC_FF_IPV4SRC2          0x19
+#define CC_PC_FF_IPV4SRC1_IPV4DST1 0x0c
+#define CC_PC_FF_IPV4SRC2_IPV4DST2 0x1a
+#define CC_PC_FF_IPV4TTL           0x29
+
+
+#define CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1    0x0d /*TODO - CLASS - what is it? TOS*/
+#define CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2    0x1b
+#define CC_PC_FF_IPV6PTYPE1                 0x0e
+#define CC_PC_FF_IPV6PTYPE2                 0x1c
+#define CC_PC_FF_IPV6DST1                   0x0f
+#define CC_PC_FF_IPV6DST2                   0x1d
+#define CC_PC_FF_IPV6SRC1                   0x10
+#define CC_PC_FF_IPV6SRC2                   0x1e
+#define CC_PC_FF_IPV6HOP_LIMIT              0x2a
+#define CC_PC_FF_GREPTYPE                   0x11
+
+#define CC_PC_FF_MINENCAP_PTYPE             0x12
+#define CC_PC_FF_MINENCAP_IPDST             0x13
+#define CC_PC_FF_MINENCAP_IPSRC             0x14
+#define CC_PC_FF_MINENCAP_IPSRC_IPDST       0x15
+
+#define CC_PC_FF_L4PSRC                     0x1f
+#define CC_PC_FF_L4PDST                     0x20
+#define CC_PC_FF_L4PSRC_L4PDST              0x21
+
+#define CC_PC_FF_PPPPID                     0x05
+
+
+#define CC_PC_PR_SHIM1                      0x22
+#define CC_PC_PR_SHIM2                      0x23
+#define CC_PC_PR_SHIM3                      0x24
+
+#define CC_PC_GENERIC_WITHOUT_MASK          0x27
+#define CC_PC_GENERIC_WITH_MASK             0x28
+
+#define CC_PR_OFFSET                        0x25
+#define CC_PR_WITHOUT_OFFSET                0x26
+
+#define CC_PC_PR_ETH_OFFSET                 19
+#define CC_PC_PR_USER_DEFINED_SHIM1_OFFSET  16
+#define CC_PC_PR_USER_DEFINED_SHIM2_OFFSET  17
+#define CC_PC_PR_USER_DEFINED_SHIM3_OFFSET  18
+#define CC_PC_PR_USER_LLC_SNAP_OFFSET       20
+#define CC_PC_PR_VLAN1_OFFSET               21
+#define CC_PC_PR_VLAN2_OFFSET               22
+#define CC_PC_PR_PPPOE_OFFSET               24
+#define CC_PC_PR_MPLS1_OFFSET               25
+#define CC_PC_PR_MPLS_LAST_OFFSET           26
+#define CC_PC_PR_IP1_OFFSET                 27
+#define CC_PC_PR_IP_LAST_OFFSET             28
+#define CC_PC_PR_MINENC_OFFSET              28
+#define CC_PC_PR_L4_OFFSET                  30
+#define CC_PC_PR_GRE_OFFSET                 29
+#define CC_PC_PR_ETYPE_LAST_OFFSET          23
+#define CC_PC_PR_NEXT_HEADER_OFFSET         31
+
+#define CC_PC_ILLEGAL                       0xff
+#define CC_SIZE_ILLEGAL                     0
+
+#define FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN    16
+#define FM_PCD_CC_AD_TABLE_ALIGN            256
+#define FM_PCD_CC_AD_ENTRY_SIZE             16
+#define FM_PCD_CC_NUM_OF_KEYS               255
+
+#define FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE   0x00000000
+#define FM_PCD_AD_RESULT_DATA_FLOW_TYPE     0x80000000
+#define FM_PCD_AD_RESULT_PLCR_DIS           0x20000000
+
+#define FM_PCD_AD_CONT_LOOKUP_TYPE          0x40000000
+#define FM_PCD_AD_CONT_LOOKUP_LCL_MASK      0x00800000
+
+#define FM_PCD_AD_TYPE_MASK                 0xc0000000
+#define FM_PCD_AD_PROFILEID_FOR_CNTRL_SHIFT 16
+
+/****************************/
+/* Defaults                 */
+/****************************/
+#define DEFAULT_plcrAutoRefresh                 FALSE
+#define DEFAULT_prsMaxParseCycleLimit           0
+#define DEFAULT_fmPcdKgErrorExceptions          (FM_PCD_EX_KG_DOUBLE_ECC | FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
+#define DEFAULT_fmPcdPlcrErrorExceptions        (FM_PCD_EX_PLCR_DOUBLE_ECC | FM_PCD_EX_PLCR_INIT_ENTRY_ERROR)
+#define DEFAULT_fmPcdPlcrExceptions             0
+#define DEFAULT_fmPcdPrsErrorExceptions         (FM_PCD_EX_PRS_DOUBLE_ECC  |  FM_PCD_EX_PRS_ILLEGAL_ACCESS | FM_PCD_EX_PRS_PORT_ILLEGAL_ACCESS)
+#define DEFAULT_fmPcdPrsExceptions              FM_PCD_EX_PRS_SINGLE_ECC
+#define DEFAULT_numOfUsedProfilesPerWindow      16
+#define DEFAULT_fmPcdPrsPortIdStatictics        FM_PCD_PRS_PPSC_ALL_PORTS
+#define DEFAULT_numOfSharedPlcrProfiles         4
+
+/***********************************************************************/
+/*          Memory map                                                 */
+/***********************************************************************/
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+
+
+typedef _Packed struct {
+   volatile uint32_t kgoe_sp;
+   volatile uint32_t kgoe_cpp;
+
+} _PackedType t_FmPcdKgPortConfigRegs;
+
+typedef _Packed struct {
+    volatile uint32_t kgcpe[8];
+} _PackedType t_FmPcdKgClsPlanRegs;
+
+typedef _Packed union {
+    t_FmPcdKgInterModuleSchemeRegs     schemeRegs;
+    t_FmPcdKgPortConfigRegs portRegs;
+    t_FmPcdKgClsPlanRegs    clsPlanRegs;
+} _PackedType u_FmPcdKgIndirectAccessRegs;
+
+typedef _Packed struct {
+    volatile uint32_t kggcr;
+    volatile uint32_t res0;
+    volatile uint32_t res1;
+    volatile uint32_t kgeer;
+    volatile uint32_t kgeeer;
+    volatile uint32_t res2;
+    volatile uint32_t res3;
+    volatile uint32_t kgseer;
+    volatile uint32_t kgseeer;
+    volatile uint32_t kggsr;
+    volatile uint32_t kgtpc;
+    volatile uint32_t kgserc;
+    volatile uint32_t res4[4];
+    volatile uint32_t kgfdor;
+    volatile uint32_t kggdv0r;
+    volatile uint32_t kggdv1r;
+    volatile uint32_t res5[5];
+    volatile uint32_t kgfer;
+    volatile uint32_t kgfeer;
+    volatile uint32_t res6[38];
+    u_FmPcdKgIndirectAccessRegs   indirectAccessRegs;
+    volatile uint32_t res[42];                  /*(0xfc-sizeof(u_FmPcdKgIndirectAccessRegs))/4 */
+    volatile uint32_t kgar;
+} _PackedType t_FmPcdKgRegs;
+
+typedef _Packed struct {
+/* General Configuration and Status Registers */
+    volatile uint32_t fmpl_gcr;         /* 0x000 FMPL_GCR  - FM Policer General Configuration */
+    volatile uint32_t fmpl_gsr;         /* 0x004 FMPL_GSR  - FM Policer Global Status Register */
+    volatile uint32_t fmpl_evr;         /* 0x008 FMPL_EVR  - FM Policer Event Register */
+    volatile uint32_t fmpl_ier;         /* 0x00C FMPL_IER  - FM Policer Interrupt Enable Register */
+    volatile uint32_t fmpl_ifr;         /* 0x010 FMPL_IFR  - FM Policer Interrupt Force Register */
+    volatile uint32_t fmpl_eevr;        /* 0x014 FMPL_EEVR - FM Policer Error Event Register */
+    volatile uint32_t fmpl_eier;        /* 0x018 FMPL_EIER - FM Policer Error Interrupt Enable Register */
+    volatile uint32_t fmpl_eifr;        /* 0x01C FMPL_EIFR - FM Policer Error Interrupt Force Register */
+/* Global Statistic Counters */
+    volatile uint32_t fmpl_rpcnt;       /* 0x020 FMPL_RPC  - FM Policer RED Packets Counter */
+    volatile uint32_t fmpl_ypcnt;       /* 0x024 FMPL_YPC  - FM Policer YELLOW Packets Counter */
+    volatile uint32_t fmpl_rrpcnt;      /* 0x028 FMPL_RRPC - FM Policer Recolored RED Packet Counter */
+    volatile uint32_t fmpl_rypcnt;      /* 0x02C FMPL_RYPC - FM Policer Recolored YELLOW Packet Counter */
+    volatile uint32_t fmpl_tpcnt;       /* 0x030 FMPL_TPC  - FM Policer Total Packet Counter */
+    volatile uint32_t fmpl_flmcnt;      /* 0x034 FMPL_FLMC - FM Policer Frame Length Mismatch Counter */
+    volatile uint32_t fmpl_res0[21];    /* 0x038 - 0x08B Reserved */
+/* Profile RAM Access Registers */
+    volatile uint32_t fmpl_par;         /* 0x08C FMPL_PAR    - FM Policer Profile Action Register*/
+    t_FmPcdPlcrInterModuleProfileRegs profileRegs;
+/* Error Capture Registers */
+    volatile uint32_t fmpl_serc;        /* 0x100 FMPL_SERC - FM Policer Soft Error Capture */
+    volatile uint32_t fmpl_upcr;        /* 0x104 FMPL_UPCR - FM Policer Uninitialized Profile Capture Register */
+    volatile uint32_t fmpl_res2;        /* 0x108 Reserved */
+/* Debug Registers */
+    volatile uint32_t fmpl_res3[61];    /* 0x10C-0x200 Reserved Debug*/
+/* Profile Selection Mapping Registers Per Port-ID (n=1-11, 16) */
+    volatile uint32_t fmpl_dpmr;        /* 0x200 FMPL_DPMR - FM Policer Default Mapping Register */
+    volatile uint32_t fmpl_pmr[63];     /*+default 0x204-0x2FF FMPL_PMR1 - FMPL_PMR63, - FM Policer Profile Mapping Registers.
+                                           (for port-ID 1-11, only for supported Port-ID registers) */
+} _PackedType t_FmPcdPlcrRegs;
+
+typedef _Packed struct {
+    volatile uint32_t rpclim;
+    volatile uint32_t rpimac;
+    volatile uint32_t pmeec;
+    volatile uint32_t res1[5];
+    volatile uint32_t pevr;
+    volatile uint32_t pever;
+    volatile uint32_t pevfr;
+    volatile uint32_t perr;
+    volatile uint32_t perer;
+    volatile uint32_t perfr;
+    volatile uint32_t res2[0xA];
+    volatile uint32_t ppsc;
+    volatile uint32_t res3;
+    volatile uint32_t pds;
+    volatile uint32_t l2rrs;
+    volatile uint32_t l3rrs;
+    volatile uint32_t l4rrs;
+    volatile uint32_t srrs;
+    volatile uint32_t l2rres;
+    volatile uint32_t l3rres;
+    volatile uint32_t l4rres;
+    volatile uint32_t srres;
+    volatile uint32_t spcs;
+    volatile uint32_t spscs;
+    volatile uint32_t hxscs;
+    volatile uint32_t mrcs;
+    volatile uint32_t mwcs;
+    volatile uint32_t mrscs;
+    volatile uint32_t mwscs;
+    volatile uint32_t fcscs;
+} _PackedType t_FmPcdPrsRegs;
+
+typedef _Packed struct {
+    volatile uint32_t fqid;
+    volatile uint32_t plcrProfile;
+    volatile uint32_t nia;
+    volatile uint8_t  res[4];
+} _PackedType t_AdOfTypeResult;
+
+typedef _Packed struct {
+    volatile uint32_t ccAdBase;
+    volatile uint32_t matchTblPtr;
+    volatile uint32_t pcAndOffsets;
+    volatile uint32_t gmask;
+} _PackedType t_AdOfTypeContLookup;
+
+typedef _Packed union {
+    volatile t_AdOfTypeResult        adResult;
+    volatile t_AdOfTypeContLookup    adContLookup;
+} _PackedType t_Ad;
+
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
+/***********************************************************************/
+/*  Driver's internal structures                                        */
+/***********************************************************************/
+
+/**************************************************************************//**
+ @Description   Structure for PLCR profile parameters.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+*//***************************************************************************/
+
+#if 0
+typedef struct t_FmPcdPlcrProfileGetParams {
+    uint16_t        relativeProfileId;                  /* IN/OUT: get the user policer profile id.
+                                                   Depending on 'isAbsolute' below, return
+                                                   either the relative or absolute profile */
+
+    bool            isAbsolute;                 /* OUT: Return true if the profile is abosulte else port based */
+    uint8_t         hardwarePortId;             /* OUT: Global port id, must be cleared if called by a
+                                                   non-port (KG, CC). */
+} t_FmPcdPlcrProfileGetParams;
+#endif /* 0 */
+
+typedef struct
+{
+    t_Handle         p_Ad;
+    e_FmPcdEngine    fmPcdEngine;
+    bool             adAllocated;
+    bool             isTree;
+
+//    bool        isCcNextEngine;
+    //uint32_t    nextEngineInfo;
+    uint32_t    myInfo;
+    t_List      *h_CcNextNodesLst;
+    t_Handle    h_AdditionalInfo;
+    t_Handle    h_Node;
+}t_FmPcdModifyCcAdditionalParams;
+
+typedef struct
+{
+    t_Handle p_AdTableNew;
+    t_Handle p_KeysMatchTableNew;
+    t_Handle p_AdTableOld;
+    t_Handle p_KeysMatchTableOld;
+    bool     lclMask;
+    uint16_t  numOfKeys;
+    t_Handle h_CurrentNode;
+    uint16_t nodeIdForAdd;
+    uint16_t keyIndexForRemove;
+    uint16_t keyIndexForAdd;
+}t_FmPcdModifyCcKeyAdditionalParams;
+
+typedef struct {
+    uint16_t    numOfKeys;
+    t_Handle    p_GlblMask;
+    bool        lclMask;
+    uint8_t     parseCode;
+    uint8_t     offset;
+    uint8_t     prsArrayOffset;
+    bool        ctrlFlow;
+    uint16_t    nodeId;
+
+    uint8_t     ccKeySizeAccExtraction;
+    uint8_t     sizeOfExtraction;
+    uint8_t     glblMaskSize;
+
+    t_Handle    h_KeysMatchTable;
+    t_Handle    h_AdTable;
+
+    t_List      ccNextNodesLst;
+    t_List      ccPrevNodesLst;
+
+    t_List      ccTreeIdLst;
+    t_List      ccTreesLst;
+} t_FmPcdCcNode;
+
+typedef struct {
+    volatile bool       lock;
+    bool                used;
+    uint8_t             owners;
+    uint8_t             netEnvId;
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    uint8_t             partitionId;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+    uint8_t             baseEntry;
+    uint16_t            sizeOfGrp;
+    protocolOpt_t       optArray[MAX_NUM_OF_OPTIONS];
+} t_FmPcdKgClsPlanGrp;
+
+typedef struct {
+    volatile bool       lock;
+    bool                valid;
+    uint8_t             netEnvId;
+    uint8_t             owners;
+    uint32_t            matchVector;
+    uint32_t            ccUnits;
+    bool                nextRelativePlcrProfile;
+    uint16_t            relativeProfileId;
+    uint16_t            numOfProfiles;
+} t_FmPcdKgScheme;
+
+#ifndef CONFIG_GUEST_PARTITION
+typedef struct
+{
+    bool    allocated;
+    uint8_t ownerId;    /* partitionId for KG in CONFIG_MULTI_PARTITION_SUPPORT only,
+                           portId for PLCR in any environment */
+} t_FmPcdAllocMng;
+#endif /* CONFIG_GUEST_PARTITION */
+
+typedef struct {
+#ifndef CONFIG_GUEST_PARTITION
+    t_FmPcdKgRegs                   *p_FmPcdKgRegs;
+    uint32_t                        schemeExceptionsBitMask;
+#endif
+    uint8_t                         numOfSchemes;
+    uint8_t                         schemesIds[FM_PCD_KG_NUM_OF_SCHEMES];
+    t_FmPcdKgScheme                 schemes[FM_PCD_KG_NUM_OF_SCHEMES];
+    t_FmPcdKgClsPlanGrp             clsPlanGrps[PCD_MAX_NUM_OF_PORTS];
+    bool                            clsPlanUsedBlocks[FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP];
+    bool                            isDriverEmptyClsPlanGrp;
+    uint8_t                         emptyClsPlanGrpId;
+    uint16_t                        numOfClsPlanEntries;
+    uint8_t                         clsPlanBase;
+
+#ifdef FM_MASTER_PARTITION
+    t_FmPcdAllocMng                 schemesMng[FM_PCD_KG_NUM_OF_SCHEMES];
+    t_FmPcdAllocMng                 clsPlanBlocksMng[FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP];
+#endif  /* FM_MASTER_PARTITION */
+} t_FmPcdKg;
+
+
+typedef struct {
+    uint16_t profilesBase;
+    uint16_t numOfProfiles;
+    t_Handle h_FmPort;
+} t_FmPcdPlcrMapParam;
+
+typedef struct {
+    bool                valid;
+    volatile bool       lock;
+#ifndef CONFIG_GUEST_PARTITION
+    t_FmPcdAllocMng     profilesMng;
+#endif /* ! CONFIG_GUEST_PARTITION */
+} t_FmPcdPlcrProfile;
+
+typedef struct {
+#ifndef CONFIG_GUEST_PARTITION
+    t_FmPcdPlcrRegs                 *p_FmPcdPlcrRegs;
+#endif /* ! CONFIG_GUEST_PARTITION */
+    t_FmPcdPlcrProfile              profiles[FM_PCD_PLCR_NUM_ENTRIES];
+    uint16_t                        numOfSharedProfiles;
+    uint16_t                        sharedProfilesIds[FM_PCD_PLCR_NUM_ENTRIES];
+    t_FmPcdPlcrMapParam             portsMapping[PCD_MAX_NUM_OF_PORTS];
+} t_FmPcdPlcr;
+
+typedef struct {
+#ifndef CONFIG_GUEST_PARTITION
+    uint32_t                        *p_SwPrsCode;
+    uint32_t                        *p_CurrSwPrs;
+    uint8_t                         currLabel;
+    t_FmPcdPrsRegs                  *p_FmPcdPrsRegs;
+#endif /* ! CONFIG_GUEST_PARTITION */
+    t_FmPcdPrsLabelParams           labelsTable[FM_PCD_PRS_NUM_OF_LABELS];
+    uint32_t                        fmPcdPrsPortIdStatistics;
+} t_FmPcdPrs;
+
+typedef struct {
+    t_FmPcdCcNode   *p_FmPcdCcNode;
+    bool            occupied;
+    uint8_t         owners;
+    volatile bool   lock;
+} t_FmPcdCcNodeArray;
+
+typedef struct {
+    uint32_t indexInGroupParam;
+} t_FmPcdCcGroupAdditionalParam;
+
+typedef struct {
+    uint8_t     numOfEntriesInGroup;
+    uint32_t    totalBitsMask;
+    uint8_t     baseGroupEntry;
+} t_FmPcdCcGroupParam;
+
+typedef struct {
+    uint8_t             netEnvId;
+    t_Handle            p_CcBaseTree;
+    uint8_t             numOfGrps;
+    t_FmPcdCcGroupParam fmPcdGroupParam[8];
+    t_List              ccNextNodesLst;
+    t_List              fmPortsLst;
+    uint8_t             treeId;
+    volatile bool       lock;
+} t_FmPcdCcTree;
+
+#if 0
+typedef struct
+{
+    uint32_t nextCcNodeInfo;
+    t_List   h_Node;
+}t_CcNodeInfo;
+#endif
+typedef struct
+{
+   e_FmPcdEngine  fmPcdEngine;
+   uint32_t       additionalInfo;
+}t_NextEngineParamsInfo;
+
+typedef struct {
+    t_FmPcdCcTree   *p_FmPcdCcTree;
+    bool            occupied;
+    uint8_t         owners;
+    volatile bool   lock;
+} t_FmPcdCcTreeArray;
+
+typedef struct {
+    t_Handle               h_FmMuram;
+    t_FmPcdCcNodeArray     ccNodeArrayEntry[MAX_NUM_OF_PCD_CC_NODES];
+    t_FmPcdCcTreeArray     ccTreeArrayEntry[MAX_NUM_OF_PCD_CC_TREES];
+    uint64_t               physicalMuramBase;
+} t_FmPcdCc;
+
+typedef struct {
+    struct {
+        e_NetHeaderType    hdr;
+        protocolOpt_t      opt;        /* only one option !! */
+    } hdrs[FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS];
+} t_FmPcdIntDistinctionUnit;
+
+typedef struct {
+    volatile bool               lock;
+    bool                        used;
+    uint8_t                     owners;
+    t_FmPcdIntDistinctionUnit   units[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
+    uint32_t                    unitsVectors[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
+    uint32_t                    lcvs[FM_PCD_PRS_NUM_OF_HDRS];
+} t_FmPcdNetEnv;
+
+typedef struct {
+    bool                        plcrAutoRefresh;
+
+    uint16_t                    prsMaxParseCycleLimit;
+} t_FmPcdDriverParam;
+
+typedef struct {
+    t_Handle                    h_Fm;
+    volatile bool               lock;
+    bool                        enabled;
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    uint8_t                     partitionId;            /**< Guest Partition Id */
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+    char                        fmPcdModuleName[MODULE_NAME_SIZE];
+
+    t_FmPcdNetEnv               netEnvs[PCD_MAX_NUM_OF_PORTS+1]; /* +1 for the private netenv used for clsPlan */
+    t_FmPcdKg                   *p_FmPcdKg;
+    t_FmPcdPlcr                 *p_FmPcdPlcr;
+    t_FmPcdPrs                  *p_FmPcdPrs;
+    t_FmPcdCc                   *p_FmPcdCc;
+
+    t_Handle                    h_Hc;
+
+#ifndef CONFIG_GUEST_PARTITION
+    uint32_t                    exceptions;
+    t_FmPcdException            *f_FmPcdException;
+    t_FmPcdIdException          *f_FmPcdIndexedException;
+    t_Handle                    h_App;
+#endif /* !CONFIG_GUEST_PARTITION */
+
+    t_FmPcdDriverParam          *p_FmPcdDriverParam;
+} t_FmPcd;
+
+
+/***********************************************************************/
+/*  PCD internal routines                                              */
+/***********************************************************************/
+/**************************************************************************//**
+ @Description   A structure of parameters to communicate
+                between the port and PCD regarding the KG scheme.
+*//***************************************************************************/
+typedef struct {
+    uint8_t                     netEnvId;    /* in */
+    uint8_t                     numOfDistinctionUnits; /* in */
+    uint8_t                     unitIds[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS]; /* in */
+    uint32_t                    vector; /* out */
+} t_NetEnvParams;
+
+/**************************************************************************//**
+
+ @Group         FM_PCD_InterModule_grp FM PCD Inter-Module Unit
+
+ @Description   FM PCD Inter Module functions -
+                These are not User API routines but routines that may be called
+                from other modules. This will be the case in a single core environment,
+                where instead of useing the XX messeging mechanism, the routines may be
+                called from other modules. In a multicore environment, the other modules may
+                be run by other cores and therefor these routines may not be called directly.
+
+ @{
+*//***************************************************************************/
+
+t_Error     PcdGetUnitsVector(t_FmPcd *p_FmPcd, t_NetEnvParams *p_Params);
+t_Error     PcdGetVectorForOpt(t_FmPcd *p_FmPcd, uint8_t netEnvId, protocolOpt_t opt, uint32_t *p_Vector);
+bool        PcdNetEnvIsUnitWithoutOpts(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint32_t unitVector);
+
+t_Handle    KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams);
+t_Error     KgInit(t_FmPcd *p_FmPcd);
+void        KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set);
+bool        KgIsSchemeAlwaysDirect(t_Handle h_FmPcd, uint8_t schemeId);
+t_Error     KgEnable(t_FmPcd *p_FmPcd);
+
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+t_Error     FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t partitionId, uint8_t *p_SchemesIds);
+t_Error     FmPcdKgFreeSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t partitionId, uint8_t *p_SchemesIds);
+t_Error     FmPcdKgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t partitionId, uint8_t *p_First);
+t_Error     FmPcdKgFreeClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t partitionId, uint8_t base);
+#else /* single */
+t_Error     KgBindPortToSchemes(t_Handle h_FmPcd , uint8_t hardwarePortId, uint32_t spReg);
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+
+t_Handle    PlcrConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams);
+t_Error     PlcrInit(t_FmPcd *p_FmPcd);
+t_Error     PlcrEnable(t_FmPcd *p_FmPcd);
+t_Error     PlcrFreeProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t num, uint16_t base);
+t_Error     PlcrAllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles, uint16_t *p_Base);
+t_Error     PlcrAllocSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds);
+void        PlcrFreeSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds);
+
+t_Handle    PrsConfig(t_FmPcd *p_FmPcd,t_FmPcdParams *p_FmPcdParams);
+t_Error     PrsInit(t_FmPcd *p_FmPcd);
+t_Error     PrsEnable(t_FmPcd *p_FmPcd);
+
+t_Handle    CcConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams);
+void        CcFree(t_FmPcdCc *p_FmPcdCc);
+t_Error     CcGetGrpParams(t_Handle treeId, uint8_t grpId, uint32_t *p_GrpBits, uint8_t *p_GrpBase);
+
+
+#endif /* __FM_PCD_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
new file mode 100644
index 0000000..e8b1da0
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
@@ -0,0 +1,227 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_pcd_ipc.h
+
+ @Description   FM PCD Inter-Partition prototypes, structures and definitions.
+*//***************************************************************************/
+#ifndef __FM_PCD_IPC_H
+#define __FM_PCD_IPC_H
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "net_ext.h"
+
+
+/**************************************************************************//**
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_PCD_IPC_grp FM PCD Inter-Partition messaging Unit
+
+ @Description   FM PCD Inter-Partition messaging unit API definitions and enums.
+
+ @{
+*//***************************************************************************/
+#define FM_PCD_PLCR_NUM_ENTRIES                     256
+#define FM_PCD_IPC_MAX_NUM_OF_DISTINCTION_UNITS     32
+#define FM_PCD_IPC_KG_NUM_OF_SCHEMES                32
+
+/**************************************************************************//**
+ @Collection    General PCD defines
+*//***************************************************************************/
+typedef uint32_t fmPcdIpcEngines_t; /**< options as defined below: */
+
+#define FM_PCD_IPC_NONE                 0                   /**< No PCD Engine indicated */
+#define FM_PCD_IPC_PRS                  0x80000000          /**< Parser indicated */
+#define FM_PCD_IPC_KG                   0x40000000          /**< Keygen indicated */
+#define FM_PCD_IPC_CC                   0x20000000          /**< Coarse classification indicated */
+#define FM_PCD_IPC_PLCR                 0x10000000          /**< Policer indicated */
+/* @} */
+/**************************************************************************//**
+ @Description   struct for defining port PCD modes
+*//***************************************************************************/
+
+
+/**************************************************************************//**
+ @Description   Structure for getting a sw parser address according to a label
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+*//***************************************************************************/
+typedef struct
+{
+    e_NetHeaderType         hdr;                            /**< IN. The existance of this header will envoke
+                                                                 the sw parser code. */
+    uint8_t                 indexPerHdr;                    /**< IN. Normally 0, if more than one sw parser
+                                                                 attachments for the same header, use this
+                                                                 index to distinguish between them. */
+    uint32_t                offset;                         /**< OUT. MURAM offset for the labeled code. */
+}t_FmPcdIpcSwPrsLable;
+
+/**************************************************************************//**
+ @Description   Structure for port-PCD communication.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+                Some fields are optional (depending on configuration) and
+                will be analized by the port and FM modules accordingly.
+*//***************************************************************************/
+
+
+/**************************************************************************//**
+ @Description   Structure for port-PCD communication.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+                Some fields are optional (depending on configuration) and
+                will be analized by the port and FM modules accordingly.
+*//***************************************************************************/
+
+
+typedef struct
+{
+    uint8_t     partitionId;                                /**< IN */
+    uint8_t     numOfSchemes;                               /**< IN */
+    uint8_t     schemesIds[FM_PCD_IPC_KG_NUM_OF_SCHEMES];   /**< OUT */
+    uint16_t    numOfClsPlanEntries;                        /**< IN */
+    uint8_t     clsPlanBase;                                /**< OUT */
+    bool        isDriverClsPlanGrp;                         /**< IN */
+} t_FmPcdIpcKgAllocParams;
+
+typedef struct
+{
+    uint16_t num;
+    uint8_t  hardwarePortId;
+    uint16_t plcrProfilesBase;
+} t_FmPcdIpcPlcrAllocParams;
+
+typedef struct
+{
+    uint16_t    num;                                    /**< IN */
+    uint16_t    profilesIds[FM_PCD_PLCR_NUM_ENTRIES];   /**< OUT */
+} t_FmPcdIpcSharedPlcrAllocParams;
+
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+
+typedef _Packed struct t_FmPcdIcPhysAddr
+{
+    volatile uint16_t high;
+    volatile uint32_t low;
+}_PackedType t_FmPcdIcPhysAddr;
+
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
+/**************************************************************************//**
+ @Function      FM_PCD_GET_SET_PORT_PARAMS
+
+ @Description   Used by FM PORT module in order to check whether
+                an FM port is stalled.
+
+ @Param[in/out] t_FmPcdIcPortInitParams
+
+*//***************************************************************************/
+#define FM_PCD_GET_SET_PORT_PARAMS              20
+/**************************************************************************//**
+ @Function      FM_PCD_CLEAR_PORT_PARAMS
+
+ @Description   Used by FM PORT module in order to free port's PCD resources
+
+ @Param[in/out] t_FmPcdIcPortInitParams
+
+*//***************************************************************************/
+#define FM_PCD_CLEAR_PORT_PARAMS                21
+
+#define FM_PCD_ALLOC_KG_RSRC                    22
+#define FM_PCD_FREE_KG_RSRC                     23
+#define FM_PCD_ALLOC_PROFILES                   24
+#define FM_PCD_FREE_PROFILES                    25
+#define FM_PCD_GET_PHYS_MURAM_BASE              26
+/**************************************************************************//**
+ @Function      FM_PCD_GET_SW_PRS_OFFSET
+
+ @Description   Used by FM PORT module to get the SW parser offset of the start of
+                code relevant to a given label..
+
+ @Param[in/out] t_FmPcdIcSwPrsLable
+
+*//***************************************************************************/
+#define FM_PCD_GET_SW_PRS_OFFSET                27
+
+#define FM_PCD_ALLOC_SHARED_PROFILES            28
+#define FM_PCD_FREE_SHARED_PROFILES             29
+/**************************************************************************//**
+ @Function      FM_PCD_GET_SET_KG_SCHEME_HC_PARAMS
+
+ @Description   Used by FM HC module to get and set keygen scheme parameters
+
+ @Param[in/out] t_FmPcdIcKgSchemeParams
+
+*//***************************************************************************/
+#define FM_PCD_GET_SET_KG_SCHEME_HC_PARAMS      30
+
+/**************************************************************************//**
+ @Function      FM_PCD_FREE_KG_SCHEME_HC
+
+ @Description   Used by FM HC  module in order to update owners counter
+                if PCD Network environment.
+
+ @Param[in]     scheme id
+
+*//***************************************************************************/
+#define FM_PCD_FREE_KG_SCHEME_HC                31
+
+#define FM_PCD_MASTER_IS_ALIVE                  32
+
+#define FM_PCD_FREE_PLCR_PROFILE_HC             33
+
+#define FM_PCD_ALLOC_CLS_PLAN_EMPTY_GRP         34
+
+#define FM_PCD_MASTER_IS_ENABLED                35
+
+/** @} */ /* end of FM_PCD_IPC_grp group */
+/** @} */ /* end of FM_grp group */
+
+
+#endif /* __FM_PCD_IPC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
new file mode 100644
index 0000000..51fcbad
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
@@ -0,0 +1,1434 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_plcr.c
+
+ @Description   FM PCD POLICER...
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "debug_ext.h"
+#include "net_ext.h"
+#include "fm_ext.h"
+#include "fm_pcd.h"
+#include "fm_hc.h"
+
+
+static bool    FmPcdPlcrIsProfileShared(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+{
+    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+    uint16_t        i;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, FALSE);
+
+    for(i=0;i<p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles;i++)
+        if(p_FmPcd->p_FmPcdPlcr->sharedProfilesIds[i] == absoluteProfileId)
+            return TRUE;
+    return FALSE;
+}
+
+static t_Error SetProfileNia(t_FmPcd *p_FmPcd, e_FmPcdEngine nextEngine, u_FmPcdPlcrNextEngineParams *p_NextEngineParams, uint32_t *nextAction)
+{
+    uint32_t    nia;
+    uint16_t    absoluteProfileId = (uint16_t)(CAST_POINTER_TO_UINT32(p_NextEngineParams->h_Profile)-1);
+    uint8_t     relativeSchemeId, physicatSchemeId;
+
+    nia = FM_PCD_PLCR_NIA_VALID;
+
+    switch (nextEngine)
+    {
+        case e_FM_PCD_DONE :
+            switch (p_NextEngineParams->action)
+            {
+                case e_FM_PCD_PLCR_DROP_FRAME :
+                    nia |= (NIA_ENG_BMI | NIA_BMI_AC_DISCARD);
+                    break;
+                case e_FM_PCD_PLCR_ENQ_FRAME:
+                    nia |= (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            }
+            break;
+        case e_FM_PCD_KG:
+            physicatSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(p_NextEngineParams->h_DirectScheme)-1);
+            relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, physicatSchemeId);
+            if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+                RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+            if (!FmPcdKgIsSchemeValidSw(p_FmPcd, relativeSchemeId))
+                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid direct scheme."));
+            if(!KgIsSchemeAlwaysDirect(p_FmPcd, relativeSchemeId))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Policer Profile may point only to a scheme that is always direct."));
+            nia |= NIA_ENG_KG | NIA_KG_DIRECT | physicatSchemeId;
+            break;
+        case e_FM_PCD_PLCR:
+             if(!FmPcdPlcrIsProfileShared(p_FmPcd, absoluteProfileId))
+               RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next profile must be a shared profile"));
+             if(!FmPcdPlcrIsProfileValid(p_FmPcd, absoluteProfileId))
+               RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid profile "));
+            nia |= NIA_ENG_PLCR | NIA_PLCR_ABSOLUTE | absoluteProfileId;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+    }
+
+    *nextAction =  nia;
+
+    return E_OK;
+}
+
+static uint32_t FPP_Function(uint32_t fpp)
+{
+    if(fpp > 15)
+        return 15 - (0x1f - fpp);
+    else
+        return 16 + fpp;
+}
+
+static uint64_t Rate2Sample(e_FmPcdPlcrRateMode rateMode, uint32_t rate, uint64_t timeStampPeriod, uint32_t count)
+{
+uint64_t temp;
+uint32_t tmp;
+
+    tmp = FPP_Function(count);
+    if (rateMode == e_FM_PCD_PLCR_BYTE_MODE)
+    {
+        temp = ((uint64_t)rate) << (16+tmp);    /* Move it left 16 Bit to the fix point position
+                                             + 16 Bit to set the time stamp period */
+        temp = temp / 1000000000;         /* Change it from KBit/sec into KBit/(Nano Sec) */
+        temp = (temp * 1000) / 8;         /* Change it from KBit/(Nano Sec) into Byte/(Nano Sec) */
+        temp =  temp / (timeStampPeriod); /* Change it from Byte/(Nano Sec) into Byte/TimeStamp Units*/
+    }
+    else
+    {
+        temp = ((uint64_t)rate) << (16+tmp);  /* Move it left 16 bit to the fix point position
+                                           + 16 Bit to set the time stamp period */
+        temp = temp / 1000000000;       /* Change it from Packet/sec into Packet/(Nano Sec) */
+        temp =  temp / (timeStampPeriod); /* Change it from Packet/Nano into Packet/TimeStamp */
+    }
+
+    return temp;
+
+}
+
+
+static void CheckValidRateRange(t_FmPcd *p_FmPcd)
+{
+    uint64_t    timeStampPeriod;
+//    uint64_t    maxVal = 0xffffffff0000LL; /* [bytes per timeStamp unit] max value which will be legal  for fpp adjustement calculation - for not being "too big"*/
+    uint32_t    minVal = 0x00010000;     /*  [bytes per timeStamp unit] min value which will be legal  for fpp adjustement calculation - for not being "too small"*/
+//    uint64_t    tempMaxLimit;
+    uint64_t    tempMinLimit;
+
+    timeStampPeriod = (uint64_t)FmGetTimeStampPeriod(p_FmPcd->h_Fm);               /* TimeStamp per nano seconds units */
+
+    /*With current timestamp configuration there can not be a MaxLimit,
+      which means that any rate above MinLimit can be served by Policer*/
+    /*transform  [bytes per timeStamp unit] into  [Kbit/s]*/
+    //tempMaxLimit = maxVal * timeStampPeriod;   /*[Byte/TimeStamp] -> [Byte/Nano]*/
+    //tempMaxLimit = tempMaxLimit * 8 / 1000;    /*[Byte/NanoSec] -> [KBits/NanoSec]*/
+    //tempMaxLimit = tempMaxLimit * 1000000000;  /*[KBits/NanoSec] ->[KBits/Sec]*/
+    //tempMaxLimit = tempMaxLimit >> 32;         /*16 (Cir/pir register presicion) + 16 (number of shifts done to fpp by default)*/
+
+    /*transform  [bytes per timeStamp unit] into  [Kbit/s]*/
+    tempMinLimit = minVal * timeStampPeriod;   /*[Byte/TimeStamp] -> [Byte/Nano]*/
+    tempMinLimit = tempMinLimit * 8 / 1000;    /*[Byte/NanoSec] -> [KBits/NanoSec]*/
+    tempMinLimit = tempMinLimit * 1000000000;  /*[KBits/NanoSec] ->[KBits/Sec]*/
+    tempMinLimit = tempMinLimit >> 32;         /*16 (Cir/pir register presicion) + 16 (number of shifts done to fpp by default)*/
+
+    XX_Print("Valid range for ByteMode RateSelection is min 0x%x ", (uint32_t)tempMinLimit);
+
+    //tempMaxLimit = maxVal * timeStampPeriod;   /*[Packets/TimeStamp] -> [Packets/Nano]*/
+    //tempMaxLimit = maxVal * 1000000000;        /*[Packets/Nano] -> [Packets/Sec]*/
+    //tempMaxLimit = tempMaxLimit >> 32;         /*16 (Cir/pir register presicion) + 0 (number of shifts done to fpp)*/
+
+    tempMinLimit = minVal * timeStampPeriod;   /*[Packets/TimeStamp] -> [Packets/Nano]*/
+    tempMinLimit = minVal * 1000000000;        /*[Packets/Nano] -> [Packets/Sec]*/
+    tempMinLimit = tempMinLimit >> 32;         /*16 (Cir/pir register presicion) + 16 (number of shifts done to fpp by default)*/
+
+    XX_Print("Valid range for PacketMode RateSelection is min 0x%x ", (uint32_t)tempMinLimit);
+}
+
+/* .......... */
+
+static void calcRates(t_Handle h_FmPcd, t_FmPcdPlcrNonPassthroughAlgParams *p_NonPassthroughAlgParam,
+                        uint32_t *cir, uint32_t *cbs, uint32_t *pir_eir, uint32_t *pbs_ebs, uint32_t *fpp)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint64_t    timeStampPeriod;
+    uint64_t    tempCir, tempPir_Eir;
+    uint32_t    temp, count;
+    bool        big;
+
+    timeStampPeriod = (uint64_t)FmGetTimeStampPeriod(p_FmPcd->h_Fm);               /* TimeStamp per nano seconds units */
+
+    /* First round to calculate precision */
+    if (p_NonPassthroughAlgParam->comittedInfoRate > p_NonPassthroughAlgParam->peakOrAccessiveInfoRate)
+        tempCir = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->comittedInfoRate, timeStampPeriod, 0);
+    else
+        tempCir = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->peakOrAccessiveInfoRate, timeStampPeriod, 0);
+
+    /* Base on result calculate the FPP and re calculate cir, pir_eir */
+    count = 0;
+    if ((tempCir > 0xFFFFFFFF))
+    {
+        /* Overflow need to shrink number */
+        big = TRUE;
+        temp = (uint32_t)(tempCir >> 32);
+        while (temp > 0)
+        {
+            temp = temp >> 1;
+            count++;
+        }
+        if(count > 16)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, ("timeStampPeriod to Information rate ratio is too big"));
+            CheckValidRateRange(p_FmPcd);
+            return;
+        }
+    }
+    else
+    {
+        /* Underflow need to improve accuracy */
+        big = FALSE;
+        temp = (uint32_t)(tempCir & 0x00000000FFFFFFFF);
+        if(temp != 0)
+        {
+        while ((temp & 0x80000000) == 0)
+        {
+            temp = temp << 1;
+            count++;
+        }
+        if(count > 15)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, ("timeStampPeriod to Information rate ratio is too small"));
+                CheckValidRateRange(p_FmPcd);
+            return;
+            }
+        }
+    }
+
+    /* Second round based on precision do the roght calculation */
+    if (count > 0)
+    {
+        if (big)
+        {
+           *fpp = (uint32_t)(0x1F - (count - 1));
+ //           tempCir     = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->comittedInfoRate, timeStampPeriod, *fpp);
+ //           tempPir_Eir = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->peakOrAccessiveInfoRate , timeStampPeriod, *fpp);
+           // *fpp = (uint32_t)(0x1F - ((1 << (count - 1)) + 1));
+        }
+        else
+        {
+            *fpp = (uint32_t)count;
+ //           tempCir     = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->comittedInfoRate , timeStampPeriod, *fpp);
+ //           tempPir_Eir = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->peakOrAccessiveInfoRate , timeStampPeriod, *fpp);
+          //  *fpp = (uint32_t)(1 << (count - 1));
+        }
+    }
+    else
+    {
+            *fpp = 0;
+ //           tempCir     = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->comittedInfoRate, timeStampPeriod, *fpp);
+ //           tempPir_Eir = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->peakOrAccessiveInfoRate, timeStampPeriod, *fpp);
+    }
+
+    tempCir     = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->comittedInfoRate, timeStampPeriod, *fpp);
+    tempPir_Eir = Rate2Sample(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->peakOrAccessiveInfoRate , timeStampPeriod, *fpp);
+
+    if (p_NonPassthroughAlgParam->rateMode == e_FM_PCD_PLCR_BYTE_MODE)
+    {
+        *cbs     = (1000 * p_NonPassthroughAlgParam->comittedBurstSize / 8);
+        *pbs_ebs = (1000 * p_NonPassthroughAlgParam->peakOrAccessiveBurstSize) / 8; /* 8=Bits->Bytes 1000=KB->B */
+    }
+    else
+    {
+        *cbs     =  p_NonPassthroughAlgParam->comittedBurstSize;
+        *pbs_ebs =  p_NonPassthroughAlgParam->peakOrAccessiveBurstSize;
+    }
+
+    *cir     = (uint32_t)tempCir;
+    *pir_eir = (uint32_t)tempPir_Eir;
+}
+
+#ifndef CONFIG_GUEST_PARTITION
+static void WritePar(t_FmPcd *p_FmPcd, uint32_t par)
+{
+    t_FmPcdPlcrRegs *p_FmPcdPlcrRegs    = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+
+    WRITE_UINT32(p_FmPcdPlcrRegs->fmpl_par, par);
+
+    while(GET_UINT32(p_FmPcdPlcrRegs->fmpl_par) & FM_PCD_PLCR_PAR_GO) ;
+
+}
+#endif /* CONFIG_GUEST_PARTITION */
+
+/*********************************************/
+/*............Policer Exception..............*/
+/*********************************************/
+#ifndef CONFIG_GUEST_PARTITION
+static void PcdPlcrException(t_Handle h_FmPcd)
+{
+    t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t event;
+
+    event = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_evr);
+    event &= GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier);
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_evr, event);
+
+    if(event & FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE)
+        p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE);
+    if(event & FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE)
+        p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE);
+
+}
+
+/* ..... */
+
+static void PcdPlcrErrorException(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t            event, captureReg;
+
+    event = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eevr);
+    event &= GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier);
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eevr, event);
+
+    if(event & FM_PCD_PLCR_DOUBLE_ECC)
+        p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PLCR_ERR_EXCEPTION_DOUBLE_ECC);
+    if(event & FM_PCD_PLCR_INIT_ENTRY_ERROR)
+    {
+        captureReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_upcr);
+        /*ASSERT_COND(captureReg & PLCR_ERR_UNINIT_CAP);
+        p_UnInitCapt->profileNum = (uint8_t)(captureReg & PLCR_ERR_UNINIT_NUM_MASK);
+        p_UnInitCapt->portId = (uint8_t)((captureReg & PLCR_ERR_UNINIT_PID_MASK) >>PLCR_ERR_UNINIT_PID_SHIFT) ;
+        p_UnInitCapt->absolute = (bool)(captureReg & PLCR_ERR_UNINIT_ABSOLUTE_MASK);*/
+        p_FmPcd->f_FmPcdIndexedException(p_FmPcd->h_App,e_FM_PCD_PLCR_ERR_EXCEPTION_INIT_ENTRY_ERROR,(uint16_t)(captureReg & PLCR_ERR_UNINIT_NUM_MASK));
+        //WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_upcr, PLCR_ERR_UNINIT_CAP);
+    }
+}
+
+#endif /* !CONFIG_GUEST_PARTITION */
+
+t_Error  FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+#ifdef CONFIG_GUEST_PARTITION
+    t_FmPcdIpcPlcrAllocParams   ipcPlcrParams;
+#endif /* CONFIG_GUEST_PARTITION */
+    t_Error                     err;
+    uint16_t                    base;
+    uint16_t                    pcdPortId;
+    uint8_t                     portsTable[]        = PCD_PORTS_TABLE;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+#ifdef CONFIG_GUEST_PARTITION
+    /* Alloc resources using IPC messaging */
+    ipcPlcrParams.num = numOfProfiles;
+    ipcPlcrParams.hardwarePortId = hardwarePortId;
+    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_ALLOC_PROFILES, (uint8_t*)&ipcPlcrParams, NULL, NULL);
+    if(err)
+        RETURN_ERROR(MAJOR, err,NO_MSG);
+    base = ipcPlcrParams.plcrProfilesBase;
+#else /* master */
+    err = PlcrAllocProfiles(p_FmPcd, hardwarePortId, numOfProfiles, &base);
+    if(err)
+        RETURN_ERROR(MAJOR, err,NO_MSG);
+#endif /* CONFIG_GUEST_PARTITION */
+
+    GET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, portsTable, hardwarePortId)
+
+    p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].numOfProfiles = numOfProfiles;
+    p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].profilesBase = base;
+
+    return E_OK;
+
+}
+
+t_Error  FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+#ifdef CONFIG_GUEST_PARTITION
+    t_FmPcdIpcPlcrAllocParams   ipcPlcrParams;
+#endif /* CONFIG_GUEST_PARTITION */
+    t_Error                     err;
+    uint16_t                    pcdPortId;
+    uint8_t                     portsTable[]        = PCD_PORTS_TABLE;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    GET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, portsTable, hardwarePortId)
+
+
+#ifdef CONFIG_GUEST_PARTITION
+    /* Alloc resources using IPC messaging */
+    ipcPlcrParams.num = p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].numOfProfiles;
+    ipcPlcrParams.hardwarePortId = hardwarePortId;
+    ipcPlcrParams.plcrProfilesBase = p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].profilesBase;
+    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_FREE_PROFILES, (uint8_t*)&ipcPlcrParams, NULL, NULL);
+    if(err)
+        RETURN_ERROR(MAJOR, err,NO_MSG);
+#else /* master */
+    err = PlcrFreeProfiles(p_FmPcd, hardwarePortId, p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].numOfProfiles, p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].profilesBase);
+    if(err)
+        RETURN_ERROR(MAJOR, err,NO_MSG);
+#endif /* CONFIG_GUEST_PARTITION */
+
+    p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].numOfProfiles = 0;
+    p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].profilesBase = 0;
+
+    return E_OK;
+
+}
+
+bool    FmPcdPlcrIsProfileValid(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+{
+    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+    t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
+
+    return p_FmPcdPlcr->profiles[absoluteProfileId].valid;
+}
+
+
+#ifndef CONFIG_GUEST_PARTITION
+t_Error  PlcrAllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles, uint16_t *p_Base)
+{
+    t_FmPcdPlcrRegs *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    uint32_t        profilesFound, log2Num, tmpReg32;
+    uint16_t        first, i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    ASSERT_COND(hardwarePortId);
+
+    if (numOfProfiles>FM_PCD_PLCR_NUM_ENTRIES)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numProfiles is too big."));
+
+    if (!POWER_OF_2(numOfProfiles))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numProfiles must be a power of 2."));
+
+    TRY_LOCK_RET_ERR(p_FmPcd->lock);
+
+    if(GET_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1]) & FM_PCD_PLCR_PMR_V)
+    {
+        RELEASE_LOCK(p_FmPcd->lock);
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("The requesting port has already an allocated profiles window."));
+    }
+
+    first = 0;
+    profilesFound = 0;
+    for(i=0;i<FM_PCD_PLCR_NUM_ENTRIES;)
+    {
+        if(!p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated)
+        {
+            profilesFound++;
+            i++;
+            if(profilesFound == numOfProfiles)
+                break;
+        }
+        else
+        {
+            profilesFound = 0;
+            /* advance i to the next aligned address */
+            first = i = (uint8_t)(first + numOfProfiles);
+        }
+    }
+    if(profilesFound == numOfProfiles)
+    {
+        for(i = first; i<first + numOfProfiles; i++)
+        {
+            p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated = TRUE;
+            p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId = hardwarePortId;
+        }
+    }
+    else
+    {
+        RELEASE_LOCK(p_FmPcd->lock);
+        RETURN_ERROR(MINOR, E_FULL, ("No profiles."));
+    }
+
+
+    /**********************FMPL_PMRx******************/
+    LOG2((uint64_t)numOfProfiles, log2Num);
+    tmpReg32 = first;
+    tmpReg32 |= log2Num << 16;
+    tmpReg32 |= FM_PCD_PLCR_PMR_V;
+    WRITE_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1], tmpReg32);
+
+    *p_Base = first;
+
+    RELEASE_LOCK(p_FmPcd->lock);
+
+    return E_OK;
+
+}
+
+t_Error  PlcrAllocSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds)
+{
+    uint32_t        profilesFound;
+    uint16_t        i, k=0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    if (numOfProfiles>FM_PCD_PLCR_NUM_ENTRIES)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numProfiles is too big."));
+
+    profilesFound = 0;
+    for(i=0;i<FM_PCD_PLCR_NUM_ENTRIES; i++)
+    {
+        if(!p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated)
+        {
+            profilesFound++;
+            profilesIds[k] = i;
+            k++;
+            if(profilesFound == numOfProfiles)
+                break;
+        }
+    }
+    if(profilesFound != numOfProfiles)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,NO_MSG);
+    for(i = 0;i<k;i++)
+    {
+        p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated = TRUE;
+        p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.ownerId = 0;
+    }
+
+    return E_OK;
+
+}
+
+t_Error  PlcrFreeProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles, uint16_t base)
+{
+    t_FmPcdPlcrRegs *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    uint16_t        i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+
+#if 0 //- default
+        else
+        {
+            tmpReg32 = GET_UINT32(p_Regs->fmpl_dpmr);
+            log2Num = (uint8_t)(tmpReg32 >> 16);
+            first = (uint16_t)tmpReg32;
+            numProfiles = (uint16_t)(1<<log2Num);
+            ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[first].ownerId == hardwarePortId);
+            /* 1 profile is still allocated for default window - HW limitaion. */
+            tmpReg32 = first;
+            WRITE_UINT32(p_Regs->fmpl_dpmr, tmpReg32);
+            first++;
+            numProfiles--;
+        }
+#endif
+
+    WRITE_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1], 0);
+
+    for(i = base; i<base+numOfProfiles;i++)
+    {
+        ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId == hardwarePortId);
+        ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated);
+
+        p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated = FALSE;
+        p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId = 0;
+    }
+    return E_OK;
+
+}
+
+void  PlcrFreeSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds)
+{
+    uint16_t        i;
+
+    SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
+
+    for(i=0;i<numOfProfiles; i++)
+    {
+        ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated);
+        p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated = FALSE;
+    }
+}
+
+#endif /* ! CONFIG_GUEST_PARTITION */
+
+t_Error FmPcdPlcrBuildProfile(t_Handle h_FmPcd, t_FmPcdPlcrProfileParams *p_Profile, t_FmPcdPlcrInterModuleProfileRegs *p_PlcrRegs)
+{
+
+    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+    t_Error err;
+    uint32_t        pemode, gnia, ynia, rnia;
+
+/* Set G, Y, R Nia */
+    err = SetProfileNia(p_FmPcd, p_Profile->nextEngineOnGreen,  &(p_Profile->paramsOnGreen), &gnia);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    err = SetProfileNia(p_FmPcd, p_Profile->nextEngineOnYellow, &(p_Profile->paramsOnYellow), &ynia);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    err = SetProfileNia(p_FmPcd, p_Profile->nextEngineOnRed,    &(p_Profile->paramsOnRed), &rnia);
+   if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+
+/* Mode fmpl_pemode */
+    pemode = FM_PCD_PLCR_PEMODE_PI;
+
+    switch (p_Profile->algSelection)
+    {
+        case    e_FM_PCD_PLCR_PASS_THROUGH:
+            p_PlcrRegs->fmpl_pecir         = 0;
+            p_PlcrRegs->fmpl_pecbs         = 0;
+            p_PlcrRegs->fmpl_pepepir_eir   = 0;
+            p_PlcrRegs->fmpl_pepbs_ebs     = 0;
+            p_PlcrRegs->fmpl_pelts         = 0;
+            p_PlcrRegs->fmpl_pects         = 0;
+            p_PlcrRegs->fmpl_pepts_ets     = 0;
+            pemode &= ~FM_PCD_PLCR_PEMODE_ALG_MASK;
+            switch (p_Profile->colorMode)
+            {
+                case    e_FM_PCD_PLCR_COLOR_BLIND:
+                    pemode |= FM_PCD_PLCR_PEMODE_CBLND;
+                    switch (p_Profile->color.dfltColor)
+                    {
+                        case e_FM_PCD_PLCR_GREEN:
+                            pemode &= ~FM_PCD_PLCR_PEMODE_DEFC_MASK;
+                            break;
+                        case e_FM_PCD_PLCR_YELLOW:
+                            pemode |= FM_PCD_PLCR_PEMODE_DEFC_Y;
+                            break;
+                        case e_FM_PCD_PLCR_RED:
+                            pemode |= FM_PCD_PLCR_PEMODE_DEFC_R;
+                            break;
+                        case e_FM_PCD_PLCR_OVERRIDE:
+                            pemode |= FM_PCD_PLCR_PEMODE_DEFC_OVERRIDE;
+                            break;
+                        default:
+                            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+                    }
+
+                    break;
+                case    e_FM_PCD_PLCR_COLOR_AWARE:
+                    pemode &= ~FM_PCD_PLCR_PEMODE_CBLND;
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            }
+            break;
+
+        case    e_FM_PCD_PLCR_RFC_2698:
+            /* Select algorithm MODE[ALG] = 01 */
+            pemode |= FM_PCD_PLCR_PEMODE_ALG_RFC2698;
+            goto cont_rfc;
+        case    e_FM_PCD_PLCR_RFC_4115:
+            /* Select algorithm MODE[ALG] = 10 */
+            pemode |= FM_PCD_PLCR_PEMODE_ALG_RFC4115;
+cont_rfc:
+            /* Select Color-Blind / Color-Aware operation (MODE[CBLND]) */
+            switch (p_Profile->colorMode)
+            {
+                case    e_FM_PCD_PLCR_COLOR_BLIND:
+                    pemode |= FM_PCD_PLCR_PEMODE_CBLND;
+                    break;
+                case    e_FM_PCD_PLCR_COLOR_AWARE:
+                    pemode &= ~FM_PCD_PLCR_PEMODE_CBLND;
+                    /*In color aware more select override color interpretation (MODE[OVCLR]) */
+                    switch (p_Profile->color.override)
+                    {
+                        case e_FM_PCD_PLCR_GREEN:
+                            pemode &= ~FM_PCD_PLCR_PEMODE_OVCLR_MASK;
+                            break;
+                        case e_FM_PCD_PLCR_YELLOW:
+                            pemode |= FM_PCD_PLCR_PEMODE_OVCLR_Y;
+                            break;
+                        case e_FM_PCD_PLCR_RED:
+                            pemode |= FM_PCD_PLCR_PEMODE_OVCLR_R;
+                            break;
+                        case e_FM_PCD_PLCR_OVERRIDE:
+                            pemode |= FM_PCD_PLCR_PEMODE_OVCLR_G_NC;
+                            break;
+                        default:
+                            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+                    }
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            }
+            /* Select Measurement Unit Mode to BYTE or PACKET (MODE[PKT]) */
+            switch (p_Profile->nonPassthroughAlgParams.rateMode)
+            {
+                case e_FM_PCD_PLCR_BYTE_MODE :
+                    pemode &= ~FM_PCD_PLCR_PEMODE_PKT;
+                        switch (p_Profile->nonPassthroughAlgParams.byteModeParams.frameLengthSelection)
+                        {
+                            case e_FM_PCD_PLCR_L2_FRM_LEN:
+                                pemode |= FM_PCD_PLCR_PEMODE_FLS_L2;
+                                break;
+                            case e_FM_PCD_PLCR_L3_FRM_LEN:
+                                pemode |= FM_PCD_PLCR_PEMODE_FLS_L3;
+                                break;
+                            case e_FM_PCD_PLCR_L4_FRM_LEN:
+                                pemode |= FM_PCD_PLCR_PEMODE_FLS_L4;
+                                break;
+                            case e_FM_PCD_PLCR_FULL_FRM_LEN:
+                                pemode |= FM_PCD_PLCR_PEMODE_FLS_FULL;
+                                break;
+                            default:
+                                RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+                        }
+                        switch (p_Profile->nonPassthroughAlgParams.byteModeParams.rollBackFrameSelection)
+                        {
+                            case e_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN:
+                                pemode &= ~FM_PCD_PLCR_PEMODE_RBFLS;
+                                break;
+                            case e_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN:
+                                pemode |= FM_PCD_PLCR_PEMODE_RBFLS;
+                                break;
+                            default:
+                                RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+                        }
+                    break;
+                case e_FM_PCD_PLCR_PACKET_MODE :
+                    pemode |= FM_PCD_PLCR_PEMODE_PKT;
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            }
+            /* Select timeStamp floating point position (MODE[FPP]) to fit the actual traffic rates. For PACKET
+               mode with low traffic rates move the fixed point to the left to increase fraction accuracy. For BYTE
+               mode with high traffic rates move the fixed point to the right to increase integer accuracy. */
+
+            /* Configure Traffic Parameters*/
+            {
+                uint32_t cir=0, cbs=0, pir_eir=0, pbs_ebs=0, fpp=0;
+
+                calcRates(h_FmPcd, &p_Profile->nonPassthroughAlgParams, &cir, &cbs, &pir_eir, &pbs_ebs, &fpp);
+
+                /*  Set Committed Information Rate (CIR) */
+                p_PlcrRegs->fmpl_pecir = cir;
+                /*  Set Committed Burst Size (CBS). */
+                p_PlcrRegs->fmpl_pecbs =  cbs;
+                /*  Set Peak Information Rate (PIR_EIR used as PIR) */
+                p_PlcrRegs->fmpl_pepepir_eir = pir_eir;
+                /*   Set Peak Burst Size (PBS_EBS used as PBS) */
+                p_PlcrRegs->fmpl_pepbs_ebs = pbs_ebs;
+
+                /* Initialize the Metering Buckets to be full (write them with 0xFFFFFFFF. */
+                /* Peak Rate Token Bucket Size (PTS_ETS used as PTS) */
+                p_PlcrRegs->fmpl_pepts_ets = 0xFFFFFFFF;
+                /* Committed Rate Token Bucket Size (CTS) */
+                p_PlcrRegs->fmpl_pects = 0xFFFFFFFF;
+
+                /* Set the FPP based on calculation */
+                pemode |= (fpp << FM_PCD_PLCR_PEMODE_FPP_SHIFT);
+            }
+            break;  /* FM_PCD_PLCR_PEMODE_ALG_RFC2698 , FM_PCD_PLCR_PEMODE_ALG_RFC4115 */
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+    }
+
+    p_PlcrRegs->fmpl_pemode = pemode;
+
+
+    p_PlcrRegs->fmpl_pegnia = gnia;
+    p_PlcrRegs->fmpl_peynia = ynia;
+    p_PlcrRegs->fmpl_pernia = rnia;
+
+
+/* Zero Counters */
+    p_PlcrRegs->fmpl_pegpc     = 0;
+    p_PlcrRegs->fmpl_peypc     = 0;
+    p_PlcrRegs->fmpl_perpc     = 0;
+    p_PlcrRegs->fmpl_perypc    = 0;
+    p_PlcrRegs->fmpl_perrpc    = 0;
+
+    return E_OK;
+}
+
+void  FmPcdPlcrValidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    ASSERT_COND(!p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
+    p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid = TRUE;
+}
+
+void  FmPcdPlcrInvalidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
+    p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid = FALSE;
+}
+
+t_Handle PlcrConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
+{
+    t_FmPcdPlcr *p_FmPcdPlcr;
+    /*uint8_t i=0;*/
+
+    UNUSED(p_FmPcd);
+    UNUSED(p_FmPcdParams);
+
+    p_FmPcdPlcr = (t_FmPcdPlcr *) XX_Malloc(sizeof(t_FmPcdPlcr));
+    if (!p_FmPcdPlcr)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Policer structure allocation FAILED"));
+        return NULL;
+    }
+    memset(p_FmPcdPlcr, 0, sizeof(t_FmPcdPlcr));
+
+#ifndef CONFIG_GUEST_PARTITION
+    p_FmPcdPlcr->p_FmPcdPlcrRegs  = CAST_UINT64_TO_POINTER_TYPE(t_FmPcdPlcrRegs , (FmGetPcdPlcrBaseAddr(p_FmPcdParams->h_Fm)));
+    p_FmPcd->p_FmPcdDriverParam->plcrAutoRefresh    = DEFAULT_plcrAutoRefresh;
+    p_FmPcd->exceptions |= (DEFAULT_fmPcdPlcrExceptions | DEFAULT_fmPcdPlcrErrorExceptions);
+#endif /* !CONFIG_GUEST_PARTITION */
+
+    p_FmPcdPlcr->numOfSharedProfiles = DEFAULT_numOfSharedPlcrProfiles;
+
+    return p_FmPcdPlcr;
+}
+
+t_Error PlcrInit(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdDriverParam          *p_Param = p_FmPcd->p_FmPcdDriverParam;
+    t_FmPcdPlcr                 *p_FmPcdPlcr = p_FmPcd->p_FmPcdPlcr;
+    uint32_t                    tmpReg32 = 0;
+    t_Error                     err;
+#ifndef CONFIG_GUEST_PARTITION
+    t_FmPcdPlcrRegs             *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+#else
+    t_FmPcdIpcSharedPlcrAllocParams    ipcSharedPlcrParams;
+#endif /* !CONFIG_GUEST_PARTITION */
+
+#ifdef CONFIG_GUEST_PARTITION
+    /* Alloc resources using IPC messaging */
+    ipcSharedPlcrParams.num = p_FmPcdPlcr->numOfSharedProfiles;
+    err = XX_SendMessage(p_FmPcd->fmPcdModuleName, FM_PCD_ALLOC_SHARED_PROFILES, (uint8_t*)&ipcSharedPlcrParams, NULL, NULL);
+    if(err)
+        RETURN_ERROR(MAJOR, err,NO_MSG);
+    memcpy(p_FmPcd->p_FmPcdPlcr->sharedProfilesIds,ipcSharedPlcrParams.profilesIds, sizeof(uint16_t)*ipcSharedPlcrParams.num);
+#else /* master */
+    err = PlcrAllocSharedProfiles(p_FmPcd, p_FmPcdPlcr->numOfSharedProfiles, p_FmPcd->p_FmPcdPlcr->sharedProfilesIds);
+    if(err)
+        RETURN_ERROR(MAJOR, err,NO_MSG);
+#endif /* CONFIG_GUEST_PARTITION */
+
+#ifndef CONFIG_GUEST_PARTITION
+
+    /**********************FMPL_GCR******************/
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_PLCR_GCR_STEN;
+    if(p_Param->plcrAutoRefresh)
+        tmpReg32 |= FM_PCD_PLCR_GCR_DAR;
+    tmpReg32 |= NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME;
+
+    WRITE_UINT32(p_Regs->fmpl_gcr, tmpReg32);
+    /**********************FMPL_GCR******************/
+
+    /**********************FMPL_EEVR******************/
+    WRITE_UINT32(p_Regs->fmpl_eevr, (FM_PCD_PLCR_DOUBLE_ECC | FM_PCD_PLCR_INIT_ENTRY_ERROR));
+    /**********************FMPL_EEVR******************/
+    /**********************FMPL_EIER******************/
+    tmpReg32 = 0;
+    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_DOUBLE_ECC)
+    {
+        if(!FmRamsEccIsExternalCtl(p_FmPcd->h_Fm))
+            FM_EnableRamsEcc(p_FmPcd->h_Fm);
+        tmpReg32 |= FM_PCD_PLCR_DOUBLE_ECC;
+    }
+    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_INIT_ENTRY_ERROR)
+        tmpReg32 |= FM_PCD_PLCR_INIT_ENTRY_ERROR;
+    WRITE_UINT32(p_Regs->fmpl_eier, tmpReg32);
+    /**********************FMPL_EIER******************/
+
+    /**********************FMPL_EVR******************/
+    WRITE_UINT32(p_Regs->fmpl_evr, (FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE | FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE));
+    /**********************FMPL_EVR******************/
+    /**********************FMPL_IER******************/
+    tmpReg32 = 0;
+    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE)
+        tmpReg32 |= FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE;
+    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE )
+        tmpReg32 |= FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE;
+    WRITE_UINT32(p_Regs->fmpl_ier, tmpReg32);
+    /**********************FMPL_IER******************/
+
+    /* register even if no interrupts enabled, to allow future enablement */
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_EV_ERR_PLCR, PcdPlcrErrorException, p_FmPcd);
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_EV_PLCR, PcdPlcrException, p_FmPcd);
+
+    /* driver initializes one DFLT profile at the last entry*/
+    p_FmPcd->p_FmPcdPlcr->profiles[FM_PCD_PLCR_NUM_ENTRIES-1].profilesMng.allocated = TRUE;
+
+    /**********************FMPL_DPMR******************/
+    tmpReg32 = FM_PCD_PLCR_NUM_ENTRIES-1;
+    WRITE_UINT32(p_Regs->fmpl_dpmr, tmpReg32);
+
+#endif /* CONFIG_GUEST_PARTITION */
+    return E_OK;
+}
+
+#ifndef CONFIG_GUEST_PARTITION
+t_Error PlcrEnable(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdPlcrRegs             *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+
+    WRITE_UINT32(p_Regs->fmpl_gcr, GET_UINT32(p_Regs->fmpl_gcr) | FM_PCD_PLCR_GCR_EN);
+
+    return E_OK;
+}
+#endif /* CONFIG_GUEST_PARTITION */
+
+t_Error FmPcdPlcrGetAbsoluteProfileId(t_Handle h_FmPcd,
+                                e_FmPcdProfileTypeSelection profileType,
+                                t_Handle  h_FmPort,
+                                uint16_t relativeProfile,
+                                uint16_t *p_AbsoluteId)
+{
+    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+    t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
+    uint8_t         i;
+
+    switch (profileType)
+    {
+        case e_FM_PCD_PLCR_PORT_PRIVATE:
+            /* get port PCD id from port handle */
+            for(i=0;i<PCD_MAX_NUM_OF_PORTS;i++)
+                if(p_FmPcd->p_FmPcdPlcr->portsMapping[i].h_FmPort == h_FmPort)
+                    break;
+            if (i ==  PCD_MAX_NUM_OF_PORTS)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE , ("Invalid port handle."));
+
+            if(!p_FmPcd->p_FmPcdPlcr->portsMapping[i].numOfProfiles)
+                RETURN_ERROR(MAJOR, E_INVALID_SELECTION , ("Port has no allocated profiles"));
+            if(relativeProfile >= p_FmPcd->p_FmPcdPlcr->portsMapping[i].numOfProfiles)
+                RETURN_ERROR(MAJOR, E_INVALID_SELECTION , ("Profile id is out of range"));
+            *p_AbsoluteId = (uint16_t)(p_FmPcd->p_FmPcdPlcr->portsMapping[i].profilesBase + relativeProfile);
+            break;
+        case e_FM_PCD_PLCR_SHARED:
+            if(relativeProfile >= p_FmPcdPlcr->numOfSharedProfiles)
+                RETURN_ERROR(MAJOR, E_INVALID_SELECTION , ("Profile id is out of range"));
+            *p_AbsoluteId = (uint16_t)(p_FmPcdPlcr->sharedProfilesIds[relativeProfile]);
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Invalid policer profile type"));
+    }
+    return E_OK;
+}
+
+uint16_t FmPcdPlcrGetPortProfilesBase(t_Handle h_FmPcd, uint8_t hardwarePortId)
+{
+    t_FmPcd         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint16_t        pcdPortId;
+    uint8_t         portsTable[] = PCD_PORTS_TABLE;
+
+    GET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, portsTable, hardwarePortId)
+
+    return p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].profilesBase;
+}
+
+uint16_t FmPcdPlcrGetPortNumOfProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
+{
+    t_FmPcd         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint16_t        pcdPortId;
+    uint8_t         portsTable[] = PCD_PORTS_TABLE;
+
+    GET_FM_PCD_PORTID_FROM_GLOBAL_PORTID(pcdPortId, portsTable, hardwarePortId)
+
+    return p_FmPcd->p_FmPcdPlcr->portsMapping[pcdPortId].numOfProfiles;
+
+}
+uint32_t FmPcdPlcrBuildWritePlcrActionReg(uint16_t absoluteProfileId)
+{
+    return (uint32_t)(FM_PCD_PLCR_PAR_GO |
+                        (absoluteProfileId << FM_PCD_PLCR_PAR_PNUM_SHIFT));
+}
+
+uint32_t FmPcdPlcrBuildWritePlcrActionRegs(uint16_t absoluteProfileId)
+{
+    return (uint32_t)(FM_PCD_PLCR_PAR_GO |
+                        (absoluteProfileId << FM_PCD_PLCR_PAR_PNUM_SHIFT) |
+                        FM_PCD_PLCR_PAR_PWSEL_MASK);
+}
+
+bool    FmPcdPlcrHwProfileIsValid(uint32_t profileModeReg)
+{
+
+    if(profileModeReg & FM_PCD_PLCR_PEMODE_PI)
+        return TRUE;
+    else
+        return FALSE;
+}
+
+uint32_t FmPcdPlcrBuildReadPlcrActionReg(uint16_t absoluteProfileId)
+{
+    return (uint32_t)(FM_PCD_PLCR_PAR_GO |
+                        FM_PCD_PLCR_PAR_R |
+                        (absoluteProfileId << FM_PCD_PLCR_PAR_PNUM_SHIFT) |
+                        FM_PCD_PLCR_PAR_PWSEL_MASK);
+}
+
+uint32_t FmPcdPlcrBuildCounterProfileReg(e_FmPcdPlcrProfileCounters counter)
+{
+    switch(counter)
+    {
+        case(e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER):
+            return FM_PCD_PLCR_PAR_PWSEL_PEGPC;
+        case(e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER):
+            return FM_PCD_PLCR_PAR_PWSEL_PEYPC;
+        case(e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER) :
+            return FM_PCD_PLCR_PAR_PWSEL_PERPC;
+        case(e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER) :
+            return FM_PCD_PLCR_PAR_PWSEL_PERYPC;
+        case(e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER) :
+            return FM_PCD_PLCR_PAR_PWSEL_PERRPC;
+       default:
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            return 0;
+
+    }
+}
+
+t_Error FmPcdPlcrProfileTryLock(t_Handle h_FmPcd, uint16_t profileId)
+{
+    TRY_LOCK_RET_ERR(((t_FmPcd*)h_FmPcd)->p_FmPcdPlcr->profiles[profileId].lock);
+    return E_OK;
+}
+
+void FmPcdPlcrReleaseProfileLock(t_Handle h_FmPcd, uint16_t profileId)
+{
+    RELEASE_LOCK(((t_FmPcd*)h_FmPcd)->p_FmPcdPlcr->profiles[profileId].lock);
+}
+
+/**************************************************/
+/*............Policer API.........................*/
+/**************************************************/
+
+t_Handle FM_PCD_PlcrSetProfile(t_Handle     h_FmPcd,
+                              t_FmPcdPlcrProfileParams *p_Profile)
+{
+    t_FmPcd                             *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    t_FmPcdPlcr                         *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
+    t_FmPcdPlcrRegs                     *p_FmPcdPlcrRegs    = p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    t_FmPcdPlcrInterModuleProfileRegs   plcrProfileReg;
+    uint16_t                            absoluteProfileId;
+    t_Error                             err;
+    uint32_t                            tmpReg32;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, NULL);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdPlcrSetProfile(p_FmPcd->h_Hc, p_Profile);
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+        return NULL;
+    }
+
+#else
+    SANITY_CHECK_RETURN_VALUE(p_FmPcdPlcr, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcdPlcrRegs, E_INVALID_HANDLE, NULL);
+
+
+    if (p_Profile->modify)
+    {
+        absoluteProfileId = (uint16_t)(CAST_POINTER_TO_UINT32(p_Profile->id.h_Profile)-1);
+        TRY_LOCK_RET_NULL(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].lock);
+    }
+    else
+    {
+        TRY_LOCK_RET_NULL(p_FmPcd->lock);
+        err = FmPcdPlcrGetAbsoluteProfileId(h_FmPcd,
+                                            p_Profile->id.newParams.profileType,
+                                            p_Profile->id.newParams.h_FmPort,
+                                            p_Profile->id.newParams.relativeProfileId,
+                                            &absoluteProfileId);
+        if(err)
+        {
+            RELEASE_LOCK(p_FmPcd->lock);
+            REPORT_ERROR(MAJOR, err, NO_MSG);
+            return NULL;
+        }
+        TRY_LOCK_RET_NULL(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].lock);
+
+        RELEASE_LOCK(p_FmPcd->lock);
+    }
+
+    if (absoluteProfileId > FM_PCD_PLCR_NUM_ENTRIES)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("profileId too Big "));
+        return NULL;
+    }
+
+    /* if no override, check first that this scheme is unused */
+    if(!p_Profile->modify)
+    {
+        /* read specified profile into profile registers */
+        tmpReg32 = FmPcdPlcrBuildReadPlcrActionReg(absoluteProfileId);
+        WritePar(p_FmPcd, tmpReg32);
+        tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pemode);
+        if (tmpReg32 & FM_PCD_PLCR_PEMODE_PI)
+        {
+            RELEASE_LOCK(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].lock);
+            REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Polcer Profile is already used"));
+            return NULL;
+        }
+    }
+
+    memset(&plcrProfileReg, 0, sizeof(t_FmPcdPlcrInterModuleProfileRegs));
+
+    err =  FmPcdPlcrBuildProfile(h_FmPcd, p_Profile, &plcrProfileReg);
+    if(err)
+    {
+        RELEASE_LOCK(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].lock);
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        return NULL;
+    }
+
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pemode , plcrProfileReg.fmpl_pemode);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegnia , plcrProfileReg.fmpl_pegnia);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peynia , plcrProfileReg.fmpl_peynia);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pernia , plcrProfileReg.fmpl_pernia);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pecir  , plcrProfileReg.fmpl_pecir);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pecbs  , plcrProfileReg.fmpl_pecbs);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pepepir_eir,plcrProfileReg.fmpl_pepepir_eir);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pepbs_ebs,plcrProfileReg.fmpl_pepbs_ebs);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pelts  , plcrProfileReg.fmpl_pelts);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pects  , plcrProfileReg.fmpl_pects);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pepts_ets,plcrProfileReg.fmpl_pepts_ets);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegpc  , plcrProfileReg.fmpl_pegpc);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peypc  , plcrProfileReg.fmpl_peypc);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perpc  , plcrProfileReg.fmpl_perpc);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perypc , plcrProfileReg.fmpl_perypc);
+    WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perrpc , plcrProfileReg.fmpl_perrpc);
+
+    tmpReg32 = FmPcdPlcrBuildWritePlcrActionRegs(absoluteProfileId);
+    WritePar(p_FmPcd, tmpReg32);
+
+    FmPcdPlcrValidateProfileSw(p_FmPcd,absoluteProfileId);
+
+    RELEASE_LOCK(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].lock);
+
+    return CAST_UINT32_TO_POINTER((uint32_t)absoluteProfileId+1);
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+t_Error FM_PCD_PlcrDeleteProfile(t_Handle h_FmPcd, t_Handle h_Profile)
+{
+    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    uint16_t        profileIndx = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
+    t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
+    uint32_t        tmpReg32;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdPlcrDeleteProfile(p_FmPcd->h_Hc, h_Profile);
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+
+#else
+    SANITY_CHECK_RETURN_ERROR((profileIndx <= FM_PCD_PLCR_NUM_ENTRIES), E_INVALID_SELECTION);
+
+    FmPcdPlcrInvalidateProfileSw(p_FmPcd,profileIndx);
+
+    WRITE_UINT32(p_FmPcdPlcr->p_FmPcdPlcrRegs->profileRegs.fmpl_pemode, ~FM_PCD_PLCR_PEMODE_PI);
+
+    tmpReg32 = FmPcdPlcrBuildWritePlcrActionRegs(profileIndx);
+    WritePar(p_FmPcd, tmpReg32);
+
+    return E_OK;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+/* ......... */
+/***************************************************/
+/*............Policer Profile Counter..............*/
+/***************************************************/
+uint32_t FM_PCD_PlcrGetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter)
+{
+    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    uint16_t        profileIndx = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
+    t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
+    t_FmPcdPlcrRegs *p_FmPcdPlcrRegs    = p_FmPcdPlcr->p_FmPcdPlcrRegs;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE,0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdPlcrGetProfileCounter(p_FmPcd->h_Hc, h_Profile, counter);
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+
+#else
+    SANITY_CHECK_RETURN_VALUE(p_FmPcdPlcr, E_INVALID_HANDLE,0);
+    SANITY_CHECK_RETURN_VALUE(p_FmPcdPlcrRegs, E_INVALID_HANDLE,0);
+
+    if (profileIndx >= FM_PCD_PLCR_NUM_ENTRIES)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("profileId too Big "));
+        return 0;
+    }
+
+    WritePar(p_FmPcd, FmPcdPlcrBuildReadPlcrActionReg(profileIndx));
+
+    if (!(GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pemode) & FM_PCD_PLCR_PEMODE_PI))
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Uninitialized profile"));
+        return 0;
+    }
+
+    switch (counter)
+    {
+        case e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER:
+            return (GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegpc));
+            break;
+        case e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER:
+            return  GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peypc);
+            break;
+        case e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER:
+            return  GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perpc);
+            break;
+        case e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER:
+            return  GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perypc);
+            break;
+        case e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER:
+            return  GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perrpc);
+            break;
+        default:
+            REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+            return 0;
+    }
+
+    return 0;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+t_Error FM_PCD_PlcrSetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter, uint32_t value)
+{
+    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    uint16_t        profileIndx = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
+    t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
+    t_FmPcdPlcrRegs *p_FmPcdPlcrRegs    = p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    uint32_t        tmpReg32;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    if (p_FmPcd->h_Hc)
+        return FmHcPcdPlcrSetProfileCounter(p_FmPcd->h_Hc, h_Profile, counter, value);
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+
+#else
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdPlcr, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdPlcrRegs, E_INVALID_HANDLE);
+
+    switch (counter)
+    {
+        case e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER:
+             WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegpc, value);
+             break;
+        case e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER:
+             WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peypc, value);
+             break;
+        case e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER:
+             WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perpc, value);
+             break;
+        case e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER:
+             WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perypc ,value);
+             break;
+        case e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER:
+             WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perrpc ,value);
+             break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
+    }
+
+    /*  Activate the atomic write action by writing FMPL_PAR with: GO=1, RW=1, PSI=0, PNUM =
+     *  Profile Number, PWSEL=0xFFFF (select all words).
+     */
+    tmpReg32 = FmPcdPlcrBuildWritePlcrActionReg(profileIndx);
+    tmpReg32 |= FmPcdPlcrBuildCounterProfileReg(counter);
+    WritePar(p_FmPcd, tmpReg32);
+
+     return E_OK;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+t_Error FM_PCD_ConfigPlcrNumOfSharedProfiles(t_Handle h_FmPcd, uint16_t numOfSharedPlcrProfiles)
+{
+   t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+
+    p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles = numOfSharedPlcrProfiles;
+
+    return E_OK;
+}
+
+t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable)
+{
+   t_FmPcd  *p_FmPcd = (t_FmPcd*)h_FmPcd;
+#ifndef CONFIG_GUEST_PARTITION
+   uint32_t tmpReg32;
+#else
+    UNUSED(enable);
+#endif /* !CONFIG_GUEST_PARTITION */
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+#ifndef CONFIG_GUEST_PARTITION
+    tmpReg32 =  GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr);
+    if(enable)
+        tmpReg32 |= FM_PCD_PLCR_GCR_STEN;
+    else
+        tmpReg32 &= ~FM_PCD_PLCR_GCR_STEN;
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr, tmpReg32);
+#else
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+#endif
+    return E_OK;
+}
+
+#ifndef CONFIG_GUEST_PARTITION
+t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable)
+{
+   t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+
+    p_FmPcd->p_FmPcdDriverParam->plcrAutoRefresh = enable;
+
+    return E_OK;
+}
+
+/* ... */
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd)
+{
+    t_FmPcd                             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdPlcrInterModuleProfileRegs   *p_ProfilesRegs;
+    int                                 i = 0;
+    uint32_t                            tmpReg;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    DUMP_SUBTITLE(("\n"));
+    DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FmPcdPlcrRegs Regs"));
+
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gcr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gsr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_evr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ier);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ifr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eevr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eier);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eifr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rpcnt);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ypcnt);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rrpcnt);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rypcnt);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_tpcnt);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_flmcnt);
+
+    p_ProfilesRegs = &p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->profileRegs;
+
+    for(i = 0;i<FM_PCD_PLCR_NUM_ENTRIES; i++)
+    {
+        tmpReg = FmPcdPlcrBuildReadPlcrActionReg((uint16_t)i);
+        WritePar(p_FmPcd, tmpReg);
+
+        DUMP_TITLE(p_ProfilesRegs, ("Profile %d regs", i));
+
+        DUMP_VAR(p_ProfilesRegs, fmpl_pemode);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pegnia);
+        DUMP_VAR(p_ProfilesRegs, fmpl_peynia);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pernia);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pecir);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pecbs);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pepepir_eir);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pepbs_ebs);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pelts);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pects);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pepts_ets);
+        DUMP_VAR(p_ProfilesRegs, fmpl_pegpc);
+        DUMP_VAR(p_ProfilesRegs, fmpl_peypc);
+        DUMP_VAR(p_ProfilesRegs, fmpl_perpc);
+        DUMP_VAR(p_ProfilesRegs, fmpl_perypc);
+        DUMP_VAR(p_ProfilesRegs, fmpl_perrpc);
+    }
+
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_serc);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_upcr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_dpmr);
+
+
+    DUMP_TITLE(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr, ("fmpl_pmr"));
+    DUMP_SUBSTRUCT_ARRAY(i, 63)
+    {
+        DUMP_MEMORY(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr[i], sizeof(uint32_t));
+    }
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+#endif /* ! CONFIG_GUEST_PARTITION */
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
new file mode 100644
index 0000000..893f877
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
@@ -0,0 +1,395 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_pcd.c
+
+ @Description   FM PCD ...
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "debug_ext.h"
+
+#include "fm_pcd.h"
+#include "net_ext.h"
+
+
+t_Handle PrsConfig(t_FmPcd *p_FmPcd,t_FmPcdParams *p_FmPcdParams)
+{
+    t_FmPcdPrs  *p_FmPcdPrs;
+#ifndef CONFIG_GUEST_PARTITION
+    uint64_t    baseAddr = FmGetPcdPrsBaseAddr(p_FmPcdParams->h_Fm);
+#endif /* !CONFIG_GUEST_PARTITION */
+
+    UNUSED(p_FmPcd);
+    UNUSED(p_FmPcdParams);
+
+    p_FmPcdPrs = (t_FmPcdPrs *) XX_Malloc(sizeof(t_FmPcdPrs));
+    if (!p_FmPcdPrs)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Parser structure allocation FAILED"));
+        return NULL;
+    }
+    memset(p_FmPcdPrs, 0, sizeof(t_FmPcdPrs));
+
+#ifndef CONFIG_GUEST_PARTITION
+    p_FmPcdPrs->p_SwPrsCode  = CAST_UINT64_TO_POINTER_TYPE(uint32_t, baseAddr);
+    p_FmPcdPrs->p_FmPcdPrsRegs  = CAST_UINT64_TO_POINTER_TYPE(t_FmPcdPrsRegs, (baseAddr + PRS_REGS_OFFSET));
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    p_FmPcdPrs->fmPcdPrsPortIdStatistics             = DEFAULT_fmPcdPrsPortIdStatictics;
+#else
+    p_FmPcdPrs->fmPcdPrsPortIdStatistics             = 0;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+    p_FmPcd->p_FmPcdDriverParam->prsMaxParseCycleLimit   = DEFAULT_prsMaxParseCycleLimit;
+    p_FmPcd->exceptions |= (DEFAULT_fmPcdPrsErrorExceptions | DEFAULT_fmPcdPrsExceptions);
+#endif /* !CONFIG_GUEST_PARTITION */
+
+    return p_FmPcdPrs;
+}
+
+#ifndef CONFIG_GUEST_PARTITION
+static void PcdPrsErrorException(t_Handle h_FmPcd)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t                event;
+
+    event = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perr);
+    event &= GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer);
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perr, event);
+
+    DBG(TRACE, ("parser error - 0x%08x\n",event));
+
+    if(event & FM_PCD_PRS_DOUBLE_ECC)
+        p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC);
+    if(event & FM_PCD_PRS_ILLEGAL_ACCESS)
+        p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_ILLEGAL_ACCESS);
+    if(event & FM_PCD_PRS_PORT_ILLEGAL_ACCESS)
+//#warning - change to indexed? how?
+        p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_PORT_ILLEGAL_ACCESS);
+}
+
+static void PcdPrsException(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t            event;
+
+    event = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevr);
+    event &= GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pever);
+
+    ASSERT_COND(event & FM_PCD_PRS_SINGLE_ECC);
+
+    DBG(TRACE, ("parser event - 0x%08x\n",event));
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevr, event);
+
+    p_FmPcd->f_FmPcdException(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC);
+}
+
+static uint32_t GetSwPrsOffset(t_Handle h_FmPcd,  e_NetHeaderType hdr, uint8_t  indexPerHdr)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    int                     i;
+    t_FmPcdPrsLabelParams   *p_Label;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE, 0);
+
+    p_Label = p_FmPcd->p_FmPcdPrs->labelsTable;
+    for(i=0;i<p_FmPcd->p_FmPcdPrs->currLabel;i++, p_Label = &p_FmPcd->p_FmPcdPrs->labelsTable[i])
+    {
+        if((hdr == p_Label->hdr) && (indexPerHdr == p_Label->indexPerHdr))
+            return p_Label->instructionOffset;
+    }
+
+    REPORT_ERROR(MINOR, E_NOT_FOUND, ("Sw Parser attachment Not found"));
+    return (uint32_t)ILLEGAL_BASE;
+}
+
+t_Error PrsInit(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdDriverParam  *p_Param = p_FmPcd->p_FmPcdDriverParam;
+    t_FmPcdPrsRegs      *p_Regs = p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
+    uint32_t            i, j;
+    uint32_t            tmpReg;
+    uint8_t             swPrsL4Patch[] = SW_PRS_L4_PATCH;
+
+    /**********************RPCLIM******************/
+    /*TODO - what default value to put*/
+    WRITE_UINT32(p_Regs->rpclim, (uint32_t)p_Param->prsMaxParseCycleLimit);
+    /**********************FMPL_RPCLIM******************/
+
+    /* register even if no interrupts enabled, to allow future enablement */
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_EV_ERR_PRS, PcdPrsErrorException, p_FmPcd);
+
+    /* register even if no interrupts enabled, to allow future enablement */
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_EV_PRS, PcdPrsException, p_FmPcd);
+
+    /**********************PEVR******************/
+    WRITE_UINT32(p_Regs->pevr, (FM_PCD_PRS_SINGLE_ECC | FM_PCD_PRS_PORT_IDLE_STS) );
+    /**********************PEVR******************/
+
+    /**********************PEVER******************/
+    if(p_FmPcd->exceptions & FM_PCD_EX_PRS_SINGLE_ECC)
+    {
+        if(!FmRamsEccIsExternalCtl(p_FmPcd->h_Fm))
+            FM_EnableRamsEcc(p_FmPcd->h_Fm);
+        WRITE_UINT32(p_Regs->pever, FM_PCD_PRS_SINGLE_ECC);
+    }
+    else
+        WRITE_UINT32(p_Regs->pever, 0);
+    /**********************PEVER******************/
+
+    /**********************PERR******************/
+    WRITE_UINT32(p_Regs->perr, (FM_PCD_PRS_DOUBLE_ECC  |
+                               FM_PCD_PRS_PORT_ILLEGAL_ACCESS |
+                               FM_PCD_PRS_ILLEGAL_ACCESS));
+    /**********************PERR******************/
+
+    /**********************PERER******************/
+    tmpReg = 0;
+    if(p_FmPcd->exceptions & FM_PCD_EX_PRS_DOUBLE_ECC)
+    {
+        FM_EnableRamsEcc(p_FmPcd->h_Fm);
+        tmpReg |= FM_PCD_PRS_DOUBLE_ECC;
+    }
+    if(p_FmPcd->exceptions & FM_PCD_EX_PRS_ILLEGAL_ACCESS)
+        tmpReg |= FM_PCD_PRS_ILLEGAL_ACCESS;
+    if(p_FmPcd->exceptions & FM_PCD_EX_PRS_PORT_ILLEGAL_ACCESS)
+        tmpReg |= FM_PCD_PRS_PORT_ILLEGAL_ACCESS;
+    WRITE_UINT32(p_Regs->perer, tmpReg);
+    /**********************PERER******************/
+
+    /**********************PPCS******************/
+    WRITE_UINT32(p_Regs->ppsc, p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics);
+    /**********************PPCS******************/
+
+    /* load sw parser L4 patch */
+    for(i=0;i<sizeof(swPrsL4Patch)/4;i++)
+    {
+       tmpReg = 0;
+       for(j =0;j<4;j++)
+       {
+          tmpReg <<= 8;
+          tmpReg |= swPrsL4Patch[i*4+j];
+
+       }
+        WRITE_UINT32(*(p_FmPcd->p_FmPcdPrs->p_SwPrsCode+ PRS_SW_OFFSET/4 + i), tmpReg);
+    }
+    p_FmPcd->p_FmPcdPrs->p_CurrSwPrs = PRS_SW_OFFSET/4 + p_FmPcd->p_FmPcdPrs->p_SwPrsCode+sizeof(swPrsL4Patch)/4;
+    p_FmPcd->p_FmPcdPrs->currLabel = 0;
+    return E_OK;
+}
+
+t_Error PrsEnable(t_FmPcd *p_FmPcd )
+{
+    t_FmPcdPrsRegs      *p_Regs = p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
+
+    WRITE_UINT32(p_Regs->rpimac, GET_UINT32(p_Regs->rpimac) | FM_PCD_PRS_RPIMAC_EN);
+
+    return E_OK;
+}
+
+
+
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+void FmPcdPrsIncludePortInStatistics(t_Handle h_FmPcd, uint8_t hardwarePortId, bool include)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t    bitMask = 0;
+    uint8_t     prsPortId;
+
+    SANITY_CHECK_RETURN((hardwarePortId >=1 && hardwarePortId <= 16), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
+
+    GET_FM_PCD_PRS_PORT_ID(prsPortId, hardwarePortId);
+    GET_FM_PCD_INDEX_FLAG(bitMask, prsPortId) ;
+
+    if(include)
+        p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics |= bitMask;
+    else
+        p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics &= ~bitMask;
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->ppsc, p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics);
+}
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+#endif /* ! CONFIG_GUEST_PARTITION */
+
+uint32_t FmPcdGetSwPrsOffset(t_Handle h_FmPcd, e_NetHeaderType hdr, uint8_t indexPerHdr)
+{
+#ifdef CONFIG_GUEST_PARTITION
+    t_Error                 err;
+    t_FmPcdIpcSwPrsLable    labelParams;
+
+    labelParams.hdr = hdr;
+    labelParams.indexPerHdr = indexPerHdr;
+    err = XX_SendMessage(((t_FmPcd *)h_FmPcd)->fmPcdModuleName, FM_PCD_GET_SW_PRS_OFFSET, (uint8_t*)&labelParams, NULL, NULL);
+    if(err)
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+    XX_Free(labelParams.p_SwPrsLabel);
+
+    return  labelParams.offset;
+#else
+    return GetSwPrsOffset(h_FmPcd, hdr, indexPerHdr);
+#endif /* CONFIG_GUEST_PARTITION */
+}
+
+#ifndef CONFIG_GUEST_PARTITION
+void FM_PCD_PrsStatistics(t_Handle h_FmPcd, bool enable)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
+
+    if(enable)
+        WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->ppsc, FM_PCD_PRS_PPSC_ALL_PORTS);
+    else
+        WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->ppsc, 0);
+
+}
+
+t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                *p_LoadTarget, tmpReg;
+    int                     i, j;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPrs, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_SwPrs, E_INVALID_HANDLE);
+
+
+    if(!p_SwPrs->override)
+    {
+        if(p_FmPcd->p_FmPcdPrs->p_CurrSwPrs > p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SW parser base must be larger than current loaded code"));
+    }
+    if(p_SwPrs->size > FM_SW_PRS_SIZE - PRS_SW_TAIL_SIZE - p_SwPrs->base*2)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_SwPrs->size may not be larger than MAX_SW_PRS_CODE_SIZE"));
+    if(p_SwPrs->size % 4)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_SwPrs->size must be divisible by 4"));
+
+    /* save sw parser lables */
+    if(p_SwPrs->override)
+        p_FmPcd->p_FmPcdPrs->currLabel = 0;
+    if(p_FmPcd->p_FmPcdPrs->currLabel+ p_SwPrs->numOfLabels > FM_PCD_PRS_NUM_OF_LABELS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exceeded number of labels allowed "));
+    memcpy(&p_FmPcd->p_FmPcdPrs->labelsTable[p_FmPcd->p_FmPcdPrs->currLabel], p_SwPrs->labelsTable, p_SwPrs->numOfLabels*sizeof(t_FmPcdPrsLabelParams));
+    p_FmPcd->p_FmPcdPrs->currLabel += p_SwPrs->numOfLabels;
+    /* load sw parser code */
+    p_LoadTarget = p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4;//+ PRS_SW_OFFSET/4 + sizeof(swPrsL4Patch)/4;
+    for(i=0;i<p_SwPrs->size/4;i++)
+    {
+        tmpReg = 0;
+        for(j =0;j<4;j++)
+        {
+            tmpReg <<= 8;
+            tmpReg |= *(p_SwPrs->p_Code+i*4+j);
+        }
+        WRITE_UINT32(*(p_LoadTarget + i), tmpReg);
+    }
+    p_FmPcd->p_FmPcdPrs->p_CurrSwPrs = p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4 + p_SwPrs->size/4;
+
+    /* copy data parameters */
+    for(i=0;i<FM_PCD_PRS_NUM_OF_HDRS;i++)
+        WRITE_UINT32(*(p_FmPcd->p_FmPcdPrs->p_SwPrsCode+PRS_SW_DATA/4+i), p_SwPrs->swPrsDataParams[i]);
+
+
+    /* Clear last 4 bytes */
+    WRITE_UINT32(*(p_FmPcd->p_FmPcdPrs->p_SwPrsCode+(PRS_SW_DATA-PRS_SW_TAIL_SIZE)/4), 0);
+
+    return E_OK;
+}
+
+t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd,uint16_t value)
+{
+    t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+
+    p_FmPcd->p_FmPcdDriverParam->prsMaxParseCycleLimit = value;
+
+    return E_OK;
+}
+
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_PCD_PrsDumpRegs(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    DUMP_SUBTITLE(("\n"));
+    DUMP_TITLE(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs, ("FmPcdPrsRegs Regs"));
+
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,rpclim);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,rpimac);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pmeec);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pevr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pever);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pevfr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,perr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,perer);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,perfr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,ppsc);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,pds);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l2rrs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l3rrs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l4rrs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,srrs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l2rres);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l3rres);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,l4rres);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,srres);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,spcs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,spscs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,hxscs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mrcs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mwcs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mrscs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,mwscs);
+    DUMP_VAR(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs,fcscs);
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+#endif  /* !CONFIG_GUEST_PARTITION */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/Makefile b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/Makefile
new file mode 100644
index 0000000..8799431
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/Makefile
@@ -0,0 +1,19 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/dpa/NetCommSw/ncsw_config.mk
+
+NCSW_FM_INC = $(srctree)/drivers/net/dpa/NetCommSw/Peripherals/FM/inc
+
+EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+
+obj-y		+= fsl-ncsw-Pcd.o
+
+fsl-ncsw-Pcd-objs	:=   fm_port.o fm_port_im.o
+
+
+
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
new file mode 100644
index 0000000..129314f
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
@@ -0,0 +1,4108 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_port.c
+
+ @Description   FM driver routines implementation.
+*//***************************************************************************/
+#include "error_ext.h"
+#include "std_ext.h"
+#include "string_ext.h"
+#include "sprint_ext.h"
+#include "debug_ext.h"
+#include "fm_pcd_ext.h"
+
+#include "fm_port.h"
+
+
+extern t_Error     FmHcPortSetPCD(t_Handle h_FmHc, t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams);
+extern t_Error     FmHcPortDeletePCD(t_Handle h_FmHc, t_Handle h_FmPort);
+
+extern t_Error     FmHcPortPcdKgModifyClsPlanGrp (t_Handle h_FmHc, t_Handle h_FmPort, bool useClsPlan, t_Handle h_NewClsPlanGrp);
+extern t_Error     FmHcPortPcdKgBindSchemes(t_Handle h_FmHc , t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme);
+extern t_Error     FmHcPortPcdKgUnbindSchemes(t_Handle h_FmHc , t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme);
+
+
+/****************************************/
+/*       static functions               */
+/****************************************/
+
+static t_Error CheckInitParameters(t_FmPort *p_FmPort)
+{
+    t_FmPortDriverParam *p_Params = p_FmPort->p_FmPortDriverParam;
+    t_Error             ans;
+    uint8_t             i;
+    uint32_t            unusedMask;
+
+    if (p_FmPort->imEn)
+    {
+        if ((ans = FmPortImCheckInitParameters(p_FmPort)) != E_OK)
+            return ERROR_CODE(ans);
+    }
+    else
+    {
+        /****************************************/
+        /*   Rx only                            */
+        /****************************************/
+        if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+        {
+            /* pools id may be 0-31 */
+            /* external buffer pools */
+            if(!p_Params->rxExtBufPools.numOfPoolsUsed)
+                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxExtBufPools.numOfPoolsUsed=0. At least one buffer pool must be defined"));
+
+            if(p_Params->rxExtBufPools.numOfPoolsUsed > FM_PORT_MAX_NUM_OF_EXT_POOLS)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfPoolsUsed can't be larger than %d", MAX_NUM_OF_EXT_POOLS));
+
+            for(i=0;i<p_Params->rxExtBufPools.numOfPoolsUsed;i++)
+            {
+                if(p_Params->rxExtBufPools.rxExtBufPool[i].id >= MAX_NUM_OF_EXT_POOLS)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxExtBufPools.rxExtBufPool[i].id can't be larger than %d", MAX_NUM_OF_EXT_POOLS));
+                if(!p_Params->rxExtBufPools.rxExtBufPool[i].size)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxExtBufPools.rxExtBufPool[i].size is 0"));
+            }
+
+            /* up to rxExtBufPools.numOfPoolsUsed pools may be defined */
+            if((p_Params->bufPoolDepletion.numOfPools > p_Params->rxExtBufPools.numOfPoolsUsed))
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPools can't be larger than %d and can't be larger than numOfPoolsUsed", FM_PORT_MAX_NUM_OF_EXT_POOLS));
+
+            /* Check that part of IC that needs copying is small enough to enter start margin */
+            if(p_Params->intContext.size + p_Params->intContext.extBufOffset > p_Params->bufMargins.startMargins)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.size is larger than start margins"));
+
+            if(p_Params->partitionId >= FM_MAX_NUM_OF_PARTITIONS)
+                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("partitionId can't be larger than %d", FM_MAX_NUM_OF_PARTITIONS-1));
+        }
+
+        /****************************************/
+        /*   Non Rx ports                       */
+        /****************************************/
+        else
+        {
+            if(p_Params->deqSubPortal > MAX_QMI_DEQ_SUBPORTAL)
+                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" deqSubPortal has to be in the range of 0 - %d", MAX_QMI_DEQ_SUBPORTAL));
+
+            /* to protect HW internal-context from overwrite */
+            if((p_Params->intContext.size) && (p_Params->intContext.intContextOffset < MIN_TX_INT_OFFSET))
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("non-Rx intContext.intContextOffset can't be smaller than %d", MIN_TX_INT_OFFSET));
+        }
+
+        /****************************************/
+        /*   Rx Or Offline Parsing              */
+        /****************************************/
+        if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_OFFLINE_PARSING))
+            if(!p_Params->dfltFqid)
+                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dfltFqid must be between 1 and 2^24-1"));
+
+        /****************************************/
+        /*   All ports                          */
+        /****************************************/
+        /* common BMI registers values */
+        /* Check that Queue Id is not larger than 2^24, and is not 0 */
+        if((p_Params->errFqid & ~0x00FFFFFF) || !p_Params->errFqid)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("errFqid must be between 1 and 2^24-1"));
+        if(p_Params->dfltFqid & ~0x00FFFFFF)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dfltFqid must be between 1 and 2^24-1"));
+    }
+
+    /****************************************/
+    /*   Rx only                            */
+    /****************************************/
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        /* Check that divisible by 256 and not larger than 256 */
+        if(p_Params->rxFifoPriElevationLevel % BMI_FIFO_UNITS)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoPriElevationLevel has to be divisible by %d", BMI_FIFO_UNITS));
+        if(!p_Params->rxFifoPriElevationLevel || (p_Params->rxFifoPriElevationLevel > BMI_MAX_FIFO_SIZE))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoPriElevationLevel has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
+        if(p_Params->rxFifoThreshold % BMI_FIFO_UNITS)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoThreshold has to be divisible by %d", BMI_FIFO_UNITS));
+        if(!p_Params->rxFifoThreshold ||(p_Params->rxFifoThreshold > BMI_MAX_FIFO_SIZE))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoThreshold has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
+
+        /* Check that not larger than 16 */
+        if(p_Params->cutBytesFromEnd > FRAME_END_DATA_SIZE)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
+
+        /* Check the margin definition */
+        if(p_Params->bufMargins.startMargins > MAX_EXT_BUFFER_OFFSET)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufMargins.startMargins can't be larger than %d", MAX_EXT_BUFFER_OFFSET));
+        if(p_Params->bufMargins.endMargins > MAX_EXT_BUFFER_OFFSET)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufMargins.endMargins can't be larger than %d", MAX_EXT_BUFFER_OFFSET));
+
+        /* extra FIFO size (allowed only to Rx ports) */
+        if(p_Params->fifoBufs.extra % BMI_FIFO_UNITS)
+             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.extra has to be divisible by %d", BMI_FIFO_UNITS));
+
+        if(p_Params->bufPoolDepletion.numberOfPoolsModeEnable &&
+           !p_Params->bufPoolDepletion.numOfPools)
+              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPoolsToConsider can not be 0 when numberOfPoolsModeEnable=TRUE"));
+    }
+
+    /****************************************/
+    /*   Non Rx ports                       */
+    /****************************************/
+    else
+        /* extra FIFO size (allowed only to Rx ports) */
+        if(p_Params->fifoBufs.extra)
+             RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" No fifoBufs.extra for non Rx ports"));
+
+    /****************************************/
+    /*   Rx & Tx                            */
+    /****************************************/
+    if((p_FmPort->portType == e_FM_PORT_TYPE_TX) || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        /* Check that not larger than 16 */
+        if(p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cheksumLastBytesIgnore can't be larger than %d", FRAME_END_DATA_SIZE));
+    }
+
+    /****************************************/
+    /*   Tx only                            */
+    /****************************************/
+    if((p_FmPort->portType == e_FM_PORT_TYPE_TX) || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
+    {
+        /* Check that divisible by 256 and not larger than 256 */
+        if(p_Params->txFifoMinFillLevel % BMI_FIFO_UNITS)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoMinFillLevel has to be divisible by %d", BMI_FIFO_UNITS));
+        if(p_Params->txFifoMinFillLevel > (BMI_MAX_FIFO_SIZE - 256))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoMinFillLevel has to be in the range of 0 - %d", BMI_MAX_FIFO_SIZE));
+        if(p_Params->txFifoLowComfLevel % BMI_FIFO_UNITS)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoLowComfLevel has to be divisible by %d", BMI_FIFO_UNITS));
+        if(!p_Params->txFifoLowComfLevel || (p_Params->txFifoLowComfLevel > BMI_MAX_FIFO_SIZE))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoLowComfLevel has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
+
+        /* Check that not larger than 8 */
+        if((!p_FmPort->txFifoDeqPipelineDepth) ||( p_FmPort->txFifoDeqPipelineDepth > MAX_FIFO_PIPELINE_DEPTH))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoDeqPipelineDepth can't be larger than %d", MAX_FIFO_PIPELINE_DEPTH));
+        if(p_FmPort->portType == e_FM_PORT_TYPE_TX)
+            if(p_FmPort->txFifoDeqPipelineDepth > 2)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoDeqPipelineDepth for !G can't be larger than 2"));
+    }
+    else
+    /****************************************/
+    /*   Non Tx Ports                       */
+    /****************************************/
+    {
+        /* If discard override was selected , no frames may be discarded. */
+        if(p_Params->frmDiscardOverride && p_Params->errorsToDiscard)
+            RETURN_ERROR(MAJOR, E_CONFLICT, ("errorsToDiscard is not empty, but frmDiscardOverride selected (all discarded frames to be enqueued to error queue)."));
+    }
+
+    /****************************************/
+    /*   Rx and Offline parsing             */
+    /****************************************/
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+        || (p_FmPort->portType == e_FM_PORT_TYPE_OFFLINE_PARSING))
+    {
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OFFLINE_PARSING)
+            unusedMask = BMI_STATUS_OP_MASK_UNUSED;
+        else
+            unusedMask = BMI_STATUS_RX_MASK_UNUSED;
+
+        /* Check that no common bits with BMI_STATUS_MASK_UNUSED */
+        if(p_Params->errorsToDiscard & unusedMask)
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("errorsToDiscard contains undefined bits"));
+    }
+
+    /****************************************/
+    /*   All ports                          */
+    /****************************************/
+    /* Check that divisible by 16 and not larger than 240 */
+    if(p_Params->intContext.intContextOffset >MAX_INT_OFFSET)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.intContextOffset can't be larger than %d", MAX_INT_OFFSET));
+    if(p_Params->intContext.intContextOffset % OFFSET_UNITS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.intContextOffset has to be divisible by %d", OFFSET_UNITS));
+
+    /* check that ic size+ic internal offset, does not exceed ic block size */
+    if(p_Params->intContext.size + p_Params->intContext.intContextOffset > MAX_IC_SIZE)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.size + intContext.intContextOffset has to be smaller than %d", MAX_IC_SIZE));
+    /* Check that divisible by 16 and not larger than 256 */
+    if(p_Params->intContext.size % OFFSET_UNITS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.size  has to be divisible by %d", OFFSET_UNITS));
+
+    /* Check that divisible by 16 and not larger than 4K */
+    if(p_Params->intContext.extBufOffset > MAX_EXT_OFFSET)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.extBufOffset can't be larger than %d", MAX_EXT_OFFSET));
+    if(p_Params->intContext.extBufOffset % OFFSET_UNITS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.extBufOffset  has to be divisible by %d", OFFSET_UNITS));
+
+    /* common BMI registers values */
+    if((!p_Params->tasks.num) || (p_Params->tasks.num > MAX_NUM_OF_TASKS))
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("tasks.num can't be larger than %d", MAX_NUM_OF_TASKS));
+    if(p_Params->tasks.extra > MAX_NUM_OF_EXTRA_TASKS)
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("tasks.extra can't be larger than %d", MAX_NUM_OF_EXTRA_TASKS));
+    if((!p_Params->openDmas.num) || (p_Params->openDmas.num > MAX_NUM_OF_DMAS))
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas.num can't be larger than %d", MAX_NUM_OF_DMAS));
+    if(p_Params->openDmas.extra > MAX_NUM_OF_EXTRA_DMAS)
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas.extra can't be larger than %d", MAX_NUM_OF_EXTRA_DMAS));
+    if(!p_Params->fifoBufs.num || (p_Params->fifoBufs.num > BMI_MAX_FIFO_SIZE))
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
+    if(p_Params->fifoBufs.num % BMI_FIFO_UNITS)
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be divisible by %d", BMI_FIFO_UNITS));
+
+    return E_OK;
+}
+
+static void FmPortDriverParamFree(t_FmPort *p_FmPort)
+{
+    if(p_FmPort->p_FmPortDriverParam)
+    {
+        XX_Free(p_FmPort->p_FmPortDriverParam);
+        p_FmPort->p_FmPortDriverParam = NULL;
+    }
+}
+
+static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
+{
+    t_FmPortRxBmiRegs       *p_Regs = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs;
+    uint32_t                tmpReg;
+    t_FmPortDriverParam     *p_Params = p_FmPort->p_FmPortDriverParam;
+    uint32_t                vector = 0, errorsToEnq = 0;
+    uint16_t                bufSize = 0;
+    int                     i=0, j=0, k=0;
+    bool                    found;
+    uint8_t                 orderedArray[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+    uint16_t                sizesArray[MAX_NUM_OF_EXT_POOLS];
+    uint8_t                 count = 0;
+
+    memset(&orderedArray, 0, sizeof(uint8_t) * FM_PORT_MAX_NUM_OF_EXT_POOLS);
+    memset(&sizesArray, 0, sizeof(uint16_t) * MAX_NUM_OF_EXT_POOLS);
+
+    /* check that port is not busy */
+    if (GET_UINT32(p_Regs->fmbm_rcfg) & BMI_PORT_CFG_EN)
+         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port is already enabled"));
+
+    /* Set Config register */
+    tmpReg = 0;
+    if (p_FmPort->imEn)
+        tmpReg |= BMI_PORT_CFG_IM;
+    /* No discard - all error frames go to error queue */
+    else if (p_Params->frmDiscardOverride)
+        tmpReg |= BMI_PORT_CFG_FDOVR;
+
+    WRITE_UINT32(p_Regs->fmbm_rcfg, tmpReg);
+
+    if (!p_FmPort->imEn)
+    {
+        /* define external buffer pools */
+        /* First we copy the external buffers pools information to an ordered local array */
+        for(i=0;i<p_Params->rxExtBufPools.numOfPoolsUsed;i++)
+        {
+            /* get pool size */
+            bufSize = p_Params->rxExtBufPools.rxExtBufPool[i].size;
+            /* check if pool size is not too big */
+            if(bufSize > p_Params->fifoBufs.num )
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Pool %d size is bigger than ports commited fifo size",
+                                                        p_Params->rxExtBufPools.rxExtBufPool[i].id));
+            /* keep sizes in an array according to poolId for direct access */
+            sizesArray[p_Params->rxExtBufPools.rxExtBufPool[i].id] =  bufSize;
+
+            /* save poolId in an ordered array according to size */
+            for (j=0;j<=i;j++)
+            {
+                /* this is the next free place in the array */
+                if (j==i)
+                    orderedArray[i] = p_Params->rxExtBufPools.rxExtBufPool[i].id;
+                else
+                {
+                    /* find the right place for this poolId */
+                    if(bufSize < sizesArray[orderedArray[j]])
+                    {
+                        /* move the poolIds one place ahead to make room for this poolId */
+                        for(k=i;k>j;k--)
+                           orderedArray[k] = orderedArray[k-1];
+
+                        /* now k==j, this is the place for the new size */
+                        orderedArray[k] = p_Params->rxExtBufPools.rxExtBufPool[i].id;
+                        break;
+                    }
+                }
+            }
+        }
+
+        /* build the register value */
+        for(i=0;i<p_Params->rxExtBufPools.numOfPoolsUsed;i++)
+        {
+            tmpReg = BMI_EXT_BUF_POOL_VALID | BMI_EXT_BUF_POOL_EN_COUNTER;
+            tmpReg |= (orderedArray[i] << BMI_EXT_BUF_POOL_ID_SHIFT);
+            tmpReg |= sizesArray[orderedArray[i]];
+            WRITE_UINT32(p_Regs->fmbm_ebmpi[i], tmpReg);
+        }
+
+        /* clear unused pools */
+        for(i=p_Params->rxExtBufPools.numOfPoolsUsed;i<FM_PORT_MAX_NUM_OF_EXT_POOLS;i++)
+            WRITE_UINT32(p_Regs->fmbm_ebmpi[i], 0);
+
+        /* pool depletion */
+        tmpReg = 0;
+        if(p_Params->bufPoolDepletion.numberOfPoolsModeEnable)
+        {
+            /* calculate vector for number of pools depletion */
+            found = FALSE;
+            vector = 0;
+            count = 0;
+            for(i=0;i<MAX_NUM_OF_EXT_POOLS;i++)
+            {
+                if(p_Params->bufPoolDepletion.poolsToConsider[i])
+                {
+                    for(j=0;j<p_Params->rxExtBufPools.numOfPoolsUsed;j++)
+                    {
+                        if (i == orderedArray[j])
+                        {
+                            vector |= 0x80000000 >> j;
+                            found = TRUE;
+                            count++;
+                            break;
+                        }
+                    }
+                    if (!found)
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Pools selected for depletion are not used."));
+                    else
+                        found = FALSE;
+                }
+            }
+            if (count < p_Params->bufPoolDepletion.numOfPools)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPools is larger than the number of pools defined."));
+
+            /* configure num of pools and vector for number of pools mode */
+            tmpReg |= ((p_Params->bufPoolDepletion.numOfPools - 1) << BMI_POOL_DEP_NUM_OF_POOLS_SHIFT);
+            tmpReg |= vector;
+        }
+
+        if(p_Params->bufPoolDepletion.singlePoolModeEnable)
+        {
+            /* calculate vector for number of pools depletion */
+            found = FALSE;
+            vector = 0;
+            count = 0;
+            for(i=0;i<MAX_NUM_OF_EXT_POOLS;i++)
+            {
+                if(p_Params->bufPoolDepletion.poolsToConsiderForSingleMode[i])
+                {
+                    for(j=0;j<p_Params->rxExtBufPools.numOfPoolsUsed;j++)
+                    {
+                        if (i == orderedArray[j])
+                         {
+                            vector |= 0x00000080 >> j;
+                            found = TRUE;
+                            count++;
+                            break;
+                        }
+                    }
+                    if (!found)
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Pools selected for depletion are not used."));
+                    else
+                        found = FALSE;
+                }
+            }
+            if (!count)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("No pools defined for single buffer mode pool depletion."));
+
+            /* configure num of pools and vector for number of pools mode */
+            tmpReg |= vector;
+        }
+
+        WRITE_UINT32(p_Regs->fmbm_mpd, tmpReg);
+    }
+
+    /* Configure dma attributes */
+    tmpReg = 0;
+    tmpReg |= p_Params->dmaSwapData << BMI_DMA_ATTR_SWP_SHIFT;
+    tmpReg |= p_Params->dmaIntContextCacheAttr << BMI_DMA_ATTR_IC_CACHE_SHIFT;
+    tmpReg |= p_Params->dmaHeaderCacheAttr << BMI_DMA_ATTR_HDR_CACHE_SHIFT;
+    tmpReg |= p_Params->dmaScatterGatherCacheAttr << BMI_DMA_ATTR_SG_CACHE_SHIFT;
+    if(p_Params->dmaReadOptimize)
+        tmpReg |= BMI_DMA_ATTR_READ_OPTIMIZE;
+    if(p_Params->dmaWriteOptimize)
+        tmpReg |= BMI_DMA_ATTR_WRITE_OPTIMIZE;
+
+    WRITE_UINT32(p_Regs->fmbm_rda, tmpReg);
+
+    /* Configure Rx Fifo params */
+    tmpReg = 0;
+    tmpReg |= ((p_Params->rxFifoPriElevationLevel/BMI_FIFO_UNITS - 1) << BMI_RX_FIFO_PRI_ELEVATION_SHIFT);
+    tmpReg |= ((p_Params->rxFifoThreshold/BMI_FIFO_UNITS - 1) << BMI_RX_FIFO_THRESHOLD_SHIFT);
+
+    WRITE_UINT32(p_Regs->fmbm_rfp, tmpReg);
+
+    /* frame end parameters */
+    tmpReg = 0;
+    tmpReg |= (p_Params->cheksumLastBytesIgnore << BMI_RX_FRAME_END_CS_IGNORE_SHIFT);
+    tmpReg |= (p_Params->cutBytesFromEnd << BMI_RX_FRAME_END_CUT_SHIFT);
+
+    WRITE_UINT32(p_Regs->fmbm_rfed, tmpReg);
+
+    /* IC parameters */
+
+    tmpReg = 0;
+    tmpReg |= ((p_Params->intContext.extBufOffset/OFFSET_UNITS) << BMI_IC_TO_EXT_SHIFT);
+    tmpReg |= ((p_Params->intContext.intContextOffset/OFFSET_UNITS) << BMI_IC_FROM_INT_SHIFT);
+    tmpReg |= ((p_Params->intContext.size/OFFSET_UNITS)  << BMI_IC_SIZE_SHIFT);
+
+    WRITE_UINT32(p_Regs->fmbm_ricp, tmpReg);
+
+    if (!p_FmPort->imEn)
+    {
+        /* check if the largest external buffer pool is large enough */
+        if(p_Params->bufMargins.startMargins + MIN_EXT_BUF_SIZE + p_Params->bufMargins.endMargins >
+                sizesArray[orderedArray[p_Params->rxExtBufPools.numOfPoolsUsed-1]])
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufMargins.startMargins (%d) + minimum buf size (64) + bufMargins.endMargins (%d) is larger than maximum external buffer size (%d)",
+                            p_Params->bufMargins.startMargins, p_Params->bufMargins.endMargins, sizesArray[orderedArray[p_Params->rxExtBufPools.numOfPoolsUsed]]));
+
+        /* buffer margins */
+        tmpReg = 0;
+        tmpReg |= ((p_Params->bufMargins.startMargins) << BMI_EXT_BUF_MARG_START_SHIFT);
+        tmpReg |= ((p_Params->bufMargins.endMargins) << BMI_EXT_BUF_MARG_END_SHIFT);
+
+        WRITE_UINT32(p_Regs->fmbm_rebm, tmpReg);
+    }
+#if 0 /* in our driver p_Params->bufMargins.startMargins is always aligned to 16 */
+    /* if p_Params->bufMargins.startMargins is not devisible by 16 (usually for alignment),
+    than we give a buffer (16 bytes) in order to avoid HW using the end of the previous buffer */
+    if(p_Params->bufMargins.startMargins % FRAME_OFFSET_UNITS)
+        WRITE_UINT32(p_Regs->fmbm_rim, 1 << BMI_RIM_FOF_SHIFT);
+#endif
+
+    /* NIA */
+    if (p_FmPort->imEn)
+        WRITE_UINT32(p_Regs->fmbm_rfne, NIA_ENG_FM_CTL | NIA_FM_CTL_AC_IND_MODE_RX);
+    else
+    {
+        tmpReg = 0;
+        if (p_Params->forwardReuseIntContext)
+            tmpReg |= BMI_PORT_RFNE_FRWD_RPD;
+        if (!p_Params->l4Checksum)
+            tmpReg |= BMI_PORT_RFNE_FRWD_DCL4C;
+        WRITE_UINT32(p_Regs->fmbm_rfne, tmpReg | NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+    }
+    WRITE_UINT32(p_Regs->fmbm_rfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+
+    /* command attribute */
+    tmpReg = BMI_CMD_RX_MR_DEF;
+    if (!p_FmPort->imEn)
+    {
+        tmpReg |= BMI_CMD_ATTR_ORDER;
+        if(p_Params->syncReq)
+            tmpReg |= BMI_CMD_ATTR_SYNC ;
+        tmpReg |= (p_Params->color << BMI_CMD_ATTR_COLOR_SHIFT);
+    }
+
+    WRITE_UINT32(p_Regs->fmbm_rfca, tmpReg);
+
+    /* default queues */
+    if (!p_FmPort->imEn)
+    {
+        WRITE_UINT32(p_Regs->fmbm_rfqid, p_Params->dfltFqid);
+        WRITE_UINT32(p_Regs->fmbm_refqid, p_Params->errFqid);
+    }
+    WRITE_UINT32(p_Regs->fmbm_rstc, BMI_COUNTERS_EN);
+    WRITE_UINT32(p_Regs->fmbm_rpc, 0); /* counters disabled, need parameters for enabling */
+
+    /* error/status mask  - check that if discard OV is set, no
+       discard is required for specific errors.*/
+    WRITE_UINT32(p_Regs->fmbm_rfsdm, p_Params->errorsToDiscard);
+
+    errorsToEnq = (RX_ERRS_TO_ENQ & ~p_Params->errorsToDiscard);
+    WRITE_UINT32(p_Regs->fmbm_rfsem, errorsToEnq);
+
+    return E_OK;
+}
+
+static t_Error BmiTxPortInit(t_FmPort *p_FmPort)
+{
+    t_FmPortTxBmiRegs   *p_Regs = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs;
+    uint32_t            tmpReg, prevPowerOf2, count=0, tmpRateLimitScale;
+    t_FmPortDriverParam *p_Params = p_FmPort->p_FmPortDriverParam;
+    uint32_t            rateCountUnit, roundUp;
+
+    /* check that port is not busy */
+    if (GET_UINT32(p_Regs->fmbm_tcfg) & BMI_PORT_CFG_EN)
+         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port is already enabled"));
+
+    tmpReg = 0;
+    if (p_FmPort->imEn)
+        tmpReg |= BMI_PORT_CFG_IM;
+
+    WRITE_UINT32(p_Regs->fmbm_tcfg, tmpReg);
+
+    /* Configure dma attributes */
+    tmpReg = 0;
+    tmpReg |= p_Params->dmaSwapData << BMI_DMA_ATTR_SWP_SHIFT;
+    tmpReg |= p_Params->dmaIntContextCacheAttr << BMI_DMA_ATTR_IC_CACHE_SHIFT;
+    tmpReg |= p_Params->dmaHeaderCacheAttr << BMI_DMA_ATTR_HDR_CACHE_SHIFT;
+    tmpReg |= p_Params->dmaScatterGatherCacheAttr << BMI_DMA_ATTR_SG_CACHE_SHIFT;
+    if(p_Params->dmaReadOptimize)
+        tmpReg |= BMI_DMA_ATTR_READ_OPTIMIZE;
+    if(p_Params->dmaWriteOptimize)
+        tmpReg |= BMI_DMA_ATTR_WRITE_OPTIMIZE;
+
+    WRITE_UINT32(p_Regs->fmbm_tda, tmpReg);
+
+    /* Configure Tx Fifo params */
+    tmpReg = 0;
+    tmpReg |= ((p_Params->txFifoMinFillLevel/BMI_FIFO_UNITS) << BMI_TX_FIFO_MIN_FILL_SHIFT);
+    tmpReg |= ((p_FmPort->txFifoDeqPipelineDepth - 1) << BMI_TX_FIFO_PIPELINE_DEPTH_SHIFT);
+    tmpReg |= ((p_Params->txFifoLowComfLevel/BMI_FIFO_UNITS - 1) << BMI_TX_LOW_COMF_SHIFT);
+
+    WRITE_UINT32(p_Regs->fmbm_tfp, tmpReg);
+
+    /* frame end parameters */
+    tmpReg = 0;
+    tmpReg |= (p_Params->cheksumLastBytesIgnore << BMI_TX_FRAME_END_CS_IGNORE_SHIFT);
+
+    WRITE_UINT32(p_Regs->fmbm_tfed, tmpReg);
+
+    if (!p_FmPort->imEn)
+    {
+        /* IC parameters */
+        tmpReg = 0;
+        tmpReg |= ((p_Params->intContext.extBufOffset/OFFSET_UNITS) << BMI_IC_TO_EXT_SHIFT);
+        tmpReg |= ((p_Params->intContext.intContextOffset/OFFSET_UNITS) << BMI_IC_FROM_INT_SHIFT);
+        tmpReg |= ((p_Params->intContext.size/OFFSET_UNITS)  << BMI_IC_SIZE_SHIFT);
+
+        WRITE_UINT32(p_Regs->fmbm_ticp, tmpReg);
+    }
+
+    /* NIA */
+    if (p_FmPort->imEn)
+    {
+        WRITE_UINT32(p_Regs->fmbm_tfne, NIA_ENG_FM_CTL | NIA_FM_CTL_AC_IND_MODE_TX);
+        WRITE_UINT32(p_Regs->fmbm_tfene, NIA_ENG_FM_CTL | NIA_FM_CTL_AC_IND_MODE_TX);
+    }
+    else
+    {
+        WRITE_UINT32(p_Regs->fmbm_tfne, NIA_ENG_QMI_DEQ);
+        WRITE_UINT32(p_Regs->fmbm_tfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+    }
+
+    /* command attribute */
+    tmpReg = BMI_CMD_TX_MR_DEF;
+    if (p_FmPort->imEn)
+        tmpReg |= BMI_CMD_MR_DEAS;
+    else
+    {
+        tmpReg |= BMI_CMD_ATTR_ORDER;
+        if(p_Params->syncReq)
+            tmpReg |= BMI_CMD_ATTR_SYNC;
+        tmpReg |= (p_Params->color << BMI_CMD_ATTR_COLOR_SHIFT);
+    }
+
+    WRITE_UINT32(p_Regs->fmbm_tfca, tmpReg);
+
+    /* default queues */
+    if (!p_FmPort->imEn)
+    {
+        WRITE_UINT32(p_Regs->fmbm_tcfqid, p_Params->dfltFqid);
+        WRITE_UINT32(p_Regs->fmbm_tfeqid, p_Params->errFqid);
+    }
+
+    /* rate limit */
+    if(p_Params->enRateLimit)
+    {
+        if (!p_Params->timeStampPeriod)
+            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Rate limit requires timeStamp - not enabled."));
+
+        if(p_Params->rateLimit.rateLimit < 16*p_Params->timeStampPeriod)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rateLimit is too small, must be larger than 16*timeStampPeriod as initialized in main FM module"));
+
+        /* we want to use the largest possible trlmt[RLM]. So we want
+        the minimal rate count unit (as we write in trlmts[TSBS]).
+        rateCountUnit must be large enough to allow using the maximum
+        trlmt[RLM] (1023 representing 1024 * 16).
+        We want to round up this division */
+
+        if (p_Params->rateLimit.rateLimit % (1024*16))
+            roundUp = 1;
+        else
+            roundUp = 0;
+        rateCountUnit = p_Params->rateLimit.rateLimit/(1024*16) + roundUp;
+        /* The basic unit may not be smaller than the timeStamp. */
+        if (rateCountUnit<p_Params->timeStampPeriod)
+            rateCountUnit = p_Params->timeStampPeriod;
+
+        /* we need to find the bit of timeStamp that is closest to rateCountUnit */
+        /* we find the previous power of 2, and the next one, than we see which is closer */
+        while(rateCountUnit > p_Params->timeStampPeriod*(1<<count))
+            count++;
+        if(count == 0)
+            tmpRateLimitScale = (31 - count) << BMI_COUNT_RATE_UNIT_SHIFT;
+        else
+        {
+            prevPowerOf2 = (1<<(count-1))*p_Params->timeStampPeriod;
+            /* 'count' or 'count-1' is now the bit that represents the unit */
+            if((rateCountUnit - prevPowerOf2) < (2*prevPowerOf2 - rateCountUnit))
+            {
+                tmpRateLimitScale = (31 - (count-1)) << BMI_COUNT_RATE_UNIT_SHIFT;
+                /* in order to get precision in the following calculation,
+                we now use the closest available rateCountUnit */
+                rateCountUnit = prevPowerOf2;
+            }
+            else
+            {
+                tmpRateLimitScale = (31 - count) << BMI_COUNT_RATE_UNIT_SHIFT;
+                /* in order to get precision in the following calculation,
+                we now use the closest available rateCountUnit */
+                rateCountUnit = 2*prevPowerOf2;
+            }
+        }
+
+        tmpReg = (uint32_t)(p_Params->rateLimit.rateLimit/(16* rateCountUnit) - 1);
+        if(!p_Params->rateLimit.maxBurstSize || (p_Params->rateLimit.maxBurstSize > MAX_BURST_SIZE))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxBurstSize must be between 1K and %dk", MAX_BURST_SIZE));
+
+        tmpReg |= (uint32_t)(p_Params->rateLimit.maxBurstSize - 1) << BMI_MAX_BURST_SHIFT;
+        WRITE_UINT32(p_Regs->fmbm_trlmt, tmpReg);
+
+        tmpRateLimitScale |= BMI_RATE_LIMIT_EN;
+        WRITE_UINT32(p_Regs->fmbm_trlmts, tmpRateLimitScale);
+    }
+
+    /* statistics & performance counters */
+    WRITE_UINT32(p_Regs->fmbm_tstc, BMI_COUNTERS_EN);
+    WRITE_UINT32(p_Regs->fmbm_tpc, 0); /* counters disabled, need parameters for enabling */
+
+    return E_OK;
+}
+
+static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
+{
+    t_FmPortOhBmiRegs   *p_Regs = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs;
+    uint32_t            tmpReg, prevPowerOf2, count=0, tmpRateLimitScale, errorsToEnq = 0;
+    t_FmPortDriverParam *p_Params = p_FmPort->p_FmPortDriverParam;
+    uint32_t            rateCountUnit, roundUp;
+
+    /* check that port is not busy */
+    if (GET_UINT32(p_Regs->fmbm_ocfg) & BMI_PORT_CFG_EN)
+         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port is already enabled"));
+
+    /* Configure dma attributes */
+    tmpReg = 0;
+    tmpReg |= p_Params->dmaSwapData << BMI_DMA_ATTR_SWP_SHIFT;
+    tmpReg |= p_Params->dmaIntContextCacheAttr << BMI_DMA_ATTR_IC_CACHE_SHIFT;
+    tmpReg |= p_Params->dmaHeaderCacheAttr << BMI_DMA_ATTR_HDR_CACHE_SHIFT;
+    tmpReg |= p_Params->dmaScatterGatherCacheAttr << BMI_DMA_ATTR_SG_CACHE_SHIFT;
+    if(p_Params->dmaReadOptimize)
+        tmpReg |= BMI_DMA_ATTR_READ_OPTIMIZE;
+    if(p_Params->dmaWriteOptimize)
+        tmpReg |= BMI_DMA_ATTR_WRITE_OPTIMIZE;
+
+    WRITE_UINT32(p_Regs->fmbm_oda, tmpReg);
+
+    /* IC parameters */
+    tmpReg = 0;
+    tmpReg |= ((p_Params->intContext.extBufOffset/OFFSET_UNITS) << BMI_IC_TO_EXT_SHIFT);
+    tmpReg |= ((p_Params->intContext.intContextOffset/OFFSET_UNITS) << BMI_IC_FROM_INT_SHIFT);
+    tmpReg |= ((p_Params->intContext.size/OFFSET_UNITS)  << BMI_IC_SIZE_SHIFT);
+
+    WRITE_UINT32(p_Regs->fmbm_oicp, tmpReg);
+
+    /* NIA */
+    WRITE_UINT32(p_Regs->fmbm_ofdne, NIA_ENG_QMI_DEQ);
+
+    if (p_FmPort->portType==e_FM_PORT_TYPE_HOST_COMMAND)
+        WRITE_UINT32(p_Regs->fmbm_ofene, NIA_ENG_QMI_ENQ);
+    else
+        WRITE_UINT32(p_Regs->fmbm_ofene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+
+    /* command attribute */
+    if (p_FmPort->portType==e_FM_PORT_TYPE_HOST_COMMAND)
+        tmpReg =  BMI_CMD_MR_DEAS | BMI_CMD_MR_MA;
+    else
+        tmpReg = BMI_CMD_ATTR_ORDER | BMI_CMD_MR_DEAS | BMI_CMD_MR_MA;
+
+    if(p_Params->syncReq)
+        tmpReg |= BMI_CMD_ATTR_SYNC;
+    tmpReg |= (p_Params->color << BMI_CMD_ATTR_COLOR_SHIFT);
+    WRITE_UINT32(p_Regs->fmbm_ofca, tmpReg);
+
+    /* No discard - all error frames go to error queue */
+    if (p_Params->frmDiscardOverride)
+        tmpReg = BMI_PORT_CFG_FDOVR;
+    else
+        tmpReg = 0;
+    WRITE_UINT32(p_Regs->fmbm_ocfg, tmpReg);
+
+    if(p_FmPort->portType == e_FM_PORT_TYPE_OFFLINE_PARSING)
+    {
+        WRITE_UINT32(p_Regs->fmbm_ofsdm, p_Params->errorsToDiscard);
+
+        errorsToEnq = (OP_ERRS_TO_ENQ & ~p_Params->errorsToDiscard);
+        WRITE_UINT32(p_Regs->fmbm_ofsem, errorsToEnq);
+
+        /* NIA */
+        WRITE_UINT32(p_Regs->fmbm_ofne, NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+
+        /* rate limit */
+        if(p_Params->enRateLimit)
+        {
+            if (!p_Params->timeStampPeriod)
+                RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Rate limit requires timeStamp - not enabled."));
+
+            if(p_Params->rateLimit.rateLimit < 10*p_Params->timeStampPeriod)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rateLimit is too small, must be larger than 10*timeStampPeriod as initialized in main FM module"));
+
+            /* we want to use the largest possible trlmt[RLM]. So we want
+            the minimal rate count unit (as we write in orlmts[TSBS]).
+            rateCountUnit must be large enough to allow using the maximum
+            orlmt[RLM] (1023 representing 1024 * 10).
+            We want to round up this division */
+
+            if (p_Params->rateLimit.rateLimit % (1024*10))
+                roundUp = 1;
+            else
+                roundUp = 0;
+            rateCountUnit = p_Params->rateLimit.rateLimit/(1024*10) + roundUp;
+            /* The basic unit may not be smaller than the timeStamp. */
+            if (rateCountUnit<p_Params->timeStampPeriod)
+                rateCountUnit = p_Params->timeStampPeriod;
+
+            /* we need to find the bit of timeStamp that is closest to rateCountUnit */
+            /* we find the previous power of 2, and the next one, than we see which is closer */
+            while(rateCountUnit > p_Params->timeStampPeriod*(1<<count))
+                count++;
+            if(count == 0)
+                tmpRateLimitScale = (31 - count) << BMI_COUNT_RATE_UNIT_SHIFT;
+            else
+            {
+                prevPowerOf2 = (1<<(count-1))*p_Params->timeStampPeriod;
+                /* 'count' or 'count-1' is now the bit that represents the unit */
+                if((rateCountUnit - prevPowerOf2) < (2*prevPowerOf2 - rateCountUnit))
+                {
+                    tmpRateLimitScale = (31 - (count-1)) << BMI_COUNT_RATE_UNIT_SHIFT;
+                    /* in order to get precision in the following calculation,
+                    we now use the closest available rateCountUnit */
+                    rateCountUnit = prevPowerOf2;
+                }
+                else
+                {
+                    tmpRateLimitScale = (31 - count) << BMI_COUNT_RATE_UNIT_SHIFT;
+                    /* in order to get precision in the following calculation,
+                    we now use the closest available rateCountUnit */
+                    rateCountUnit = 2*prevPowerOf2;
+                }
+            }
+
+            tmpReg = (uint32_t)(p_Params->rateLimit.rateLimit/(10* rateCountUnit) - 1);
+            tmpReg |= (uint32_t)(p_Params->rateLimit.maxBurstSize - 1) << BMI_MAX_BURST_SHIFT;
+            WRITE_UINT32(p_Regs->fmbm_orlmt, tmpReg);
+
+            tmpRateLimitScale |= BMI_RATE_LIMIT_EN;
+            WRITE_UINT32(p_Regs->fmbm_orlmts, tmpRateLimitScale);
+        }
+    }
+    else
+        /* NIA */
+        WRITE_UINT32(p_Regs->fmbm_ofne, NIA_ENG_FM_CTL | NIA_FM_CTL_AC_HC);
+
+    /* default queues */
+    WRITE_UINT32(p_Regs->fmbm_ofqid, p_Params->dfltFqid);
+    WRITE_UINT32(p_Regs->fmbm_oefqid, p_Params->errFqid);
+
+    /* statistics & performance counters */
+    WRITE_UINT32(p_Regs->fmbm_ostc, BMI_COUNTERS_EN);
+    WRITE_UINT32(p_Regs->fmbm_opc, 0); /* counters disabled, need parameters for enabling */
+
+    return E_OK;
+}
+
+static t_Error QmiInit(t_FmPort *p_FmPort)
+{
+    t_FmPortDriverParam             *p_Params = NULL;
+    uint32_t                        tmpReg;
+
+    p_Params = p_FmPort->p_FmPortDriverParam;
+
+    /* check that port is not busy */
+    if(((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_RX)) &&
+       (GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN))
+         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port is already enabled"));
+
+    /* enable & clear counters */
+    WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc, QMI_PORT_CFG_EN_COUNTERS);
+
+    /* The following is  done for non-Rx ports only */
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    {
+        if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) ||
+                        (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+        {
+            /* define dequeue NIA */
+            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_TX);
+            /* define enqueue NIA */
+            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE);
+        }
+        else  /* for HC & OP */
+        {
+            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_FETCH);
+            /* define enqueue NIA */
+            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
+        }
+
+        /* configure dequeue */
+        tmpReg = 0;
+        if(p_Params->deqHighPriority)
+            tmpReg |= QMI_DEQ_CFG_PRI;
+
+        switch(p_Params->deqType)
+        {
+            case(e_FM_PORT_DEQ_TYPE1):
+                tmpReg |= QMI_DEQ_CFG_TYPE1;
+                break;
+            case(e_FM_PORT_DEQ_TYPE2):
+                tmpReg |= QMI_DEQ_CFG_TYPE2;
+                break;
+            case(e_FM_PORT_DEQ_TYPE3):
+                tmpReg |= QMI_DEQ_CFG_TYPE3;
+                break;
+            default:
+                break;
+        }
+        switch(p_Params->deqPrefetchOption)
+        {
+            case(e_FM_PORT_DEQ_NO_PREFETCH):
+                /* Do nothing - QMI_DEQ_CFG_PREFETCH_WAITING_TNUM | QMI_DEQ_CFG_PREFETCH_1_FRAME = 0 */
+                break;
+            case(e_FM_PORT_DEQ_PARTIAL_PREFETCH):
+                tmpReg |= QMI_DEQ_CFG_PREFETCH_WAITING_TNUM | QMI_DEQ_CFG_PREFETCH_3_FRAMES;
+                break;
+            case(e_FM_PORT_DEQ_FULL_PREFETCH):
+                tmpReg |= QMI_DEQ_CFG_PREFETCH_NO_TNUM | QMI_DEQ_CFG_PREFETCH_3_FRAMES;
+                break;
+            default:
+                break;
+        }
+        tmpReg |= p_Params->deqByteCnt;
+        tmpReg |= p_Params->deqSubPortal << QMI_DEQ_CFG_SUBPORTAL_SHIFT;
+
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndc, tmpReg);
+    }
+    else /* rx port */
+        /* define enqueue NIA */
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
+
+    return E_OK;
+}
+
+static t_Error BmiRxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounters counter, volatile uint32_t **p_Ptr)
+{
+    t_FmPortRxBmiRegs   *p_BmiRegs = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs;
+
+     /* check that counters are enabled */
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_CYCLE):
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case(e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
+            if(!(GET_UINT32(p_BmiRegs->fmbm_rpc) & BMI_COUNTERS_EN))
+               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+        case(e_FM_PORT_COUNTERS_FRAME):
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_BAD_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            if(!(GET_UINT32(p_BmiRegs->fmbm_rstc) & BMI_COUNTERS_EN))
+               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+         default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
+            break;
+    }
+
+    /* Set counter */
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_CYCLE):
+            *p_Ptr = &p_BmiRegs->fmbm_rccn;
+            break;
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+            *p_Ptr = &p_BmiRegs->fmbm_rtuc;
+            break;
+        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+            *p_Ptr = &p_BmiRegs->fmbm_rrquc;
+            break;
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+            *p_Ptr = &p_BmiRegs->fmbm_rduc;
+            break;
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+            *p_Ptr = &p_BmiRegs->fmbm_rfuc;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
+            *p_Ptr = &p_BmiRegs->fmbm_rpac;
+            break;
+        case(e_FM_PORT_COUNTERS_FRAME):
+            *p_Ptr = &p_BmiRegs->fmbm_rfrc;
+            break;
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+            *p_Ptr = &p_BmiRegs->fmbm_rfcd;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_BAD_FRAME):
+            *p_Ptr = &p_BmiRegs->fmbm_rfbc;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
+            *p_Ptr = &p_BmiRegs->fmbm_rlfc;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+            *p_Ptr = &p_BmiRegs->fmbm_rffc;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+            *p_Ptr = &p_BmiRegs->fmbm_rfldec;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+            *p_Ptr = &p_BmiRegs->fmbm_rodc;
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            *p_Ptr = &p_BmiRegs->fmbm_rbdc;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
+            break;
+    }
+
+    return E_OK;
+}
+
+static t_Error BmiTxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounters counter, volatile uint32_t **p_Ptr)
+{
+    t_FmPortTxBmiRegs   *p_BmiRegs = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs;
+
+     /* check that counters are enabled */
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_CYCLE):
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+            if(!(GET_UINT32(p_BmiRegs->fmbm_tpc) & BMI_COUNTERS_EN))
+               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+        case(e_FM_PORT_COUNTERS_FRAME):
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            if(!(GET_UINT32(p_BmiRegs->fmbm_tstc) & BMI_COUNTERS_EN))
+               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Tx ports"));
+            break;
+    }
+
+    /* Set counter */
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_CYCLE):
+           *p_Ptr = &p_BmiRegs->fmbm_tccn;
+            break;
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+           *p_Ptr = &p_BmiRegs->fmbm_ttuc;
+            break;
+        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+            *p_Ptr = &p_BmiRegs->fmbm_ttcquc;
+            break;
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+           *p_Ptr = &p_BmiRegs->fmbm_tduc;
+            break;
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+           *p_Ptr = &p_BmiRegs->fmbm_tfuc;
+            break;
+        case(e_FM_PORT_COUNTERS_FRAME):
+           *p_Ptr = &p_BmiRegs->fmbm_tfrc;
+            break;
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+           *p_Ptr = &p_BmiRegs->fmbm_tfdc;
+            break;
+        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+           *p_Ptr = &p_BmiRegs->fmbm_tfledc;
+            break;
+        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+            *p_Ptr = &p_BmiRegs->fmbm_tfufdc;
+            break;
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            *p_Ptr = &p_BmiRegs->fmbm_tbdc;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Tx ports"));
+            break;
+    }
+
+    return E_OK;
+}
+
+
+static t_Error BmiOhPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounters counter, volatile uint32_t **p_Ptr)
+{
+    t_FmPortOhBmiRegs   *p_BmiRegs = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs;
+
+    /* check that counters are enabled */
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_CYCLE):
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+            if(!(GET_UINT32(p_BmiRegs->fmbm_opc) & BMI_COUNTERS_EN))
+               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+        case(e_FM_PORT_COUNTERS_FRAME):
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case(e_FM_PORT_COUNTERS_WRED_DISCARD):
+        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            if(!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
+               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME): /* only valid for offline parsing */
+            if(p_FmPort->portType == e_FM_PORT_TYPE_HOST_COMMAND)
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for O/H ports"));
+            if(!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
+               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for O/H ports"));
+            break;
+    }
+
+    /* Set counter */
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_CYCLE):
+           *p_Ptr = &p_BmiRegs->fmbm_occn;
+            break;
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+           *p_Ptr = &p_BmiRegs->fmbm_otuc;
+            break;
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+           *p_Ptr = &p_BmiRegs->fmbm_oduc;
+            break;
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+           *p_Ptr = &p_BmiRegs->fmbm_ofuc;
+            break;
+        case(e_FM_PORT_COUNTERS_FRAME):
+           *p_Ptr = &p_BmiRegs->fmbm_ofrc;
+            break;
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+           *p_Ptr = &p_BmiRegs->fmbm_ofdc;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+           *p_Ptr = &p_BmiRegs->fmbm_offc;
+            break;
+        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+           *p_Ptr = &p_BmiRegs->fmbm_ofldec;
+            break;
+        case(e_FM_PORT_COUNTERS_WRED_DISCARD):
+           *p_Ptr = &p_BmiRegs->fmbm_ofwdc;
+            break;
+        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+           *p_Ptr = &p_BmiRegs->fmbm_ofledc;
+            break;
+        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+            *p_Ptr = &p_BmiRegs->fmbm_ofufdc;
+            break;
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            *p_Ptr = &p_BmiRegs->fmbm_obdc;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for O/H ports"));
+            break;
+    }
+
+    return E_OK;
+}
+
+static t_Error  AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrParams *p_HdrParams, uint32_t *p_SoftSeqAttachReg)
+{
+    uint8_t                     hdrNum, Ipv4HdrNum;
+    u_FmPcdHdrPrsOpts            *p_prsOpts;
+    uint32_t                    tmpReg = 0, tmpPrsOffset;
+
+    if(p_HdrParams->errDisable)
+        tmpReg |= PRS_HDR_ERROR_DIS;
+
+    /* Set parser options */
+    if(p_HdrParams->usePrsOpts)
+    {
+        p_prsOpts = &p_HdrParams->prsOpts;
+        switch(p_HdrParams->hdr)
+        {
+            case(HEADER_TYPE_MPLS):
+                if(p_prsOpts->mplsPrsOptions.labelInterpretationEnable)
+                    tmpReg |= PRS_HDR_MPLS_LBL_INTER_EN;
+                GET_PRS_HDR_NUM(hdrNum, p_prsOpts->mplsPrsOptions.nextParse);
+                if(hdrNum == ILLEGAL_HDR_NUM)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
+                GET_PRS_HDR_NUM(Ipv4HdrNum, HEADER_TYPE_IPv4);
+                if(hdrNum < Ipv4HdrNum)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                        ("Header must be equal or higher than IPv4"));
+                tmpReg |= (hdrNum * PRS_HDR_ENTRY_SIZE) << PRS_HDR_MPLS_NEXT_HDR_SHIFT;
+                break;
+            case(HEADER_TYPE_IPv6):
+                if(p_prsOpts->ipv6PrsOptions.routingHdrDisable)
+                    tmpReg |= PRS_HDR_IPV6_ROUTE_HDR_DIS;
+                break;
+            case(HEADER_TYPE_TCP):
+                if(p_prsOpts->tcpPrsOptions.padIgnoreChecksum)
+                   tmpReg |= PRS_HDR_TCP_PAD_REMOVAL;
+                break;
+            case(HEADER_TYPE_UDP):
+                if(p_prsOpts->udpPrsOptions.padIgnoreChecksum)
+                   tmpReg |= PRS_HDR_TCP_PAD_REMOVAL;
+            default:
+                break;
+        }
+    }
+
+    /* set software parsing (address is devided in 2 since parser uses 2 byte access. */
+    if(p_HdrParams->swPrsEnable)
+    {
+        tmpPrsOffset = FmPcdGetSwPrsOffset(p_FmPort->h_FmPcd, p_HdrParams->hdr, p_HdrParams->indexPerHdr);
+        if(tmpPrsOffset == ILLEGAL_BASE)
+            RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
+        tmpReg |= (PRS_HDR_SW_PRS_EN | tmpPrsOffset);
+    }
+    *p_SoftSeqAttachReg = tmpReg;
+
+    return E_OK;
+}
+/********************************************/
+/*  Inter-module API                        */
+/********************************************/
+t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
+{
+    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error                             err = E_OK;
+    uint32_t                            tmpReg;
+    volatile uint32_t                   *p_BmiNia=NULL;
+    volatile uint32_t                   *p_BmiPrsNia=NULL;
+    volatile uint32_t                   *p_BmiPrsStartOffset=NULL;
+    volatile uint32_t                   *p_BmiInitPrsResult=NULL;
+    volatile uint32_t                   *p_BmiCcBase=NULL;
+    uint8_t                             hdrNum, L3HdrNum;
+    int                                 i;
+    uint32_t                            tmpHxs[FM_PCD_PRS_NUM_OF_HDRS];
+    uint16_t                            absoluteProfileId;
+    uint8_t                             physicalSchemeId;
+    uint32_t                            ccTreePhysOffset;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_OFFLINE_PARSING))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+
+    p_FmPort->netEnvId = (uint8_t)(CAST_POINTER_TO_UINT32(p_PcdParams->h_NetEnv)-1);
+
+    p_FmPort->pcdEngines = 0;
+
+    /* initialize p_FmPort->pcdEngines field in port's structure */
+    switch(p_PcdParams->pcdSupport)
+    {
+        case(e_FM_PORT_PCD_SUPPORT_NONE):
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("No PCD configuration required if e_FM_PORT_PCD_SUPPORT_NONE selected"));
+            break;
+        case(e_FM_PORT_PCD_SUPPORT_PRS_ONLY):
+            p_FmPort->pcdEngines |= FM_PCD_PRS;
+            break;
+        case(e_FM_PORT_PCD_SUPPORT_PLCR_ONLY):
+            p_FmPort->pcdEngines |= FM_PCD_PLCR;
+            break;
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR):
+            p_FmPort->pcdEngines |= FM_PCD_PRS;
+            p_FmPort->pcdEngines |= FM_PCD_PLCR;
+            break;
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG):
+            p_FmPort->pcdEngines |= FM_PCD_PRS;
+            p_FmPort->pcdEngines |= FM_PCD_KG;
+            break;
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC):
+            p_FmPort->pcdEngines |= FM_PCD_PRS;
+            p_FmPort->pcdEngines |= FM_PCD_CC;
+            p_FmPort->pcdEngines |= FM_PCD_KG;
+            break;
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR):
+            p_FmPort->pcdEngines |= FM_PCD_PRS;
+            p_FmPort->pcdEngines |= FM_PCD_KG;
+            p_FmPort->pcdEngines |= FM_PCD_CC;
+            p_FmPort->pcdEngines |= FM_PCD_PLCR;
+            break;
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
+            p_FmPort->pcdEngines |= FM_PCD_PRS;
+            p_FmPort->pcdEngines |= FM_PCD_KG;
+            p_FmPort->pcdEngines |= FM_PCD_PLCR;
+            break;
+        default:
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("invalid pcdSupport"));
+            break;
+    }
+
+    if((p_FmPort->pcdEngines & FM_PCD_PRS) && (p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams > FM_PCD_PRS_NUM_OF_HDRS))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Port parser numOfHdrsWithAdditionalParams may not exceed %d", FM_PCD_PRS_NUM_OF_HDRS));
+
+    /* check that parameters exist for each and only each defined engine */
+    if((!!(p_FmPort->pcdEngines & FM_PCD_PRS) != !!p_PcdParams->p_PrsParams) ||
+        (!!(p_FmPort->pcdEngines & FM_PCD_KG) != !!p_PcdParams->p_KgParams) ||
+        (!!(p_FmPort->pcdEngines & FM_PCD_CC) != !!p_PcdParams->p_CcParams))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PCD initialization structure is not consistant with pcdSupport"));
+
+    /* get PCD registers pointers */
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            p_BmiPrsNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne;
+            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
+            p_BmiInitPrsResult = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rprai[0];
+            p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rccb;
+       break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+            p_BmiPrsNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
+            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
+            p_BmiInitPrsResult = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oprai[0];
+            p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_occb;
+        break;
+        default:
+            break;
+    }
+
+    if(p_FmPort->pcdEngines & FM_PCD_KG)
+    {
+
+        if(p_PcdParams->p_KgParams->numOfSchemes == 0)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For ports using Keygen, at lease one scheme must be bound. "));
+        /* for each scheme */
+        for(i = 0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
+        {
+            physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(p_PcdParams->p_KgParams->h_Schemes[i])-1);
+
+            /* build vector */
+            p_FmPort->schemesPerPortVector |= 1 << (31 - physicalSchemeId);
+        }
+
+        err = FmPortPcdKgSwBindClsPlanGrp(p_FmPort,
+                                          p_PcdParams->p_KgParams->useClsPlan,
+                                          (uint8_t)(CAST_POINTER_TO_UINT32(p_PcdParams->p_KgParams->h_ClsPlanGrp)-1));
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    /* set PCD port parameter */
+    if(p_FmPort->pcdEngines & FM_PCD_CC)
+    {
+        err = FmPcdCcBindTree(p_FmPort->h_FmPcd, p_PcdParams->p_CcParams->h_CcTree, &ccTreePhysOffset);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+
+        WRITE_UINT32(*p_BmiCcBase, ccTreePhysOffset);
+        p_FmPort->ccTreeId = p_PcdParams->p_CcParams->h_CcTree;
+    }
+
+    /* NIA after BMI*/
+    if((p_FmPort->pcdEngines & FM_PCD_PLCR) &&
+        ((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PLCR_ONLY) ||
+                (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR)))
+    {
+        absoluteProfileId = (uint16_t)(CAST_POINTER_TO_UINT32(p_PcdParams->p_PlcrParams->h_Profile)-1);
+
+        if(!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Private port profile not valid."));
+
+        tmpReg = (uint32_t)(absoluteProfileId | NIA_PLCR_ABSOLUTE);
+
+        if(p_FmPort->pcdEngines & FM_PCD_PRS) /* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
+        {
+            /* update BMI HPNIA */
+            WRITE_UINT32(*p_BmiPrsNia, (uint32_t)(NIA_ENG_PLCR | tmpReg));
+        }
+        else /* e_FM_PCD_SUPPORT_PLCR_ONLY */
+        {
+            /* rfne may contain FDCS bits, so first we read them. */
+            tmpReg |= GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
+            /* update BMI NIA */
+            p_FmPort->savedBmiNia = (uint32_t)(NIA_ENG_PLCR | tmpReg);
+            //WRITE_UINT32(*p_BmiNia, (uint32_t)(NIA_ENG_PLCR | tmpReg));
+        }
+    }
+
+    /* all cases but e_FM_PORT_PCD_SUPPORT_PLCR_ONLY, use parser */
+    if(!(p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PLCR_ONLY))
+    {
+        ASSERT_COND(p_FmPort->pcdEngines & FM_PCD_PRS);
+        /* Go to Parser */
+
+        GET_PRS_HDR_NUM(hdrNum, p_PcdParams->p_PrsParams->firstPrsHdr);
+        if (hdrNum == ILLEGAL_HDR_NUM)
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unsupported header."));
+        /* rfne may contain FDCS bits, so first we read them. */
+        tmpReg = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
+        p_FmPort->savedBmiNia = tmpReg | (uint32_t)(NIA_ENG_PRS | (uint32_t)(hdrNum * PRS_HDR_ENTRY_SIZE));
+        //WRITE_UINT32(*p_BmiNia, tmpReg | (uint32_t)(NIA_ENG_PRS | (uint32_t)(hdrNum * PRS_HDR_ENTRY_SIZE)));
+        ASSERT_COND(p_PcdParams->p_PrsParams);
+        /* set after parser NIA */
+        tmpReg = 0;
+        switch(p_PcdParams->pcdSupport)
+        {
+            case(e_FM_PORT_PCD_SUPPORT_PRS_ONLY):
+                WRITE_UINT32(*p_BmiPrsNia, NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+                break;
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC):
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR):
+                tmpReg = NIA_KG_CC_EN;
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG):
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
+                if(p_PcdParams->p_KgParams->directScheme)
+                {
+                    physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(p_PcdParams->p_KgParams->h_DirectScheme)-1);
+                    /* check that this scheme was bound to this port */
+                    for(i=0 ; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
+                        if(p_PcdParams->p_KgParams->h_DirectScheme == p_PcdParams->p_KgParams->h_Schemes[i])
+                            break;
+                    if(i == p_PcdParams->p_KgParams->numOfSchemes)
+                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Direct scheme is not one of the port selected schemes."));
+
+                    tmpReg |= (uint32_t)(NIA_KG_DIRECT | physicalSchemeId);
+                }
+                WRITE_UINT32(*p_BmiPrsNia, NIA_ENG_KG | tmpReg);
+                break;
+            default:
+                break;
+        }
+
+        /* set start parsing offset */
+        WRITE_UINT32(*p_BmiPrsStartOffset, p_PcdParams->p_PrsParams->parsingOffset);
+
+        /************************************/
+        /* Parser port parameters           */
+        /************************************/
+        /* stop before configuring */
+        WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, PRS_CAC_STOP);
+        /* wait for parser to be in idle state */
+        while(GET_UINT32(p_FmPort->p_FmPortPrsRegs->pcac) & PRS_CAC_ACTIVE) ;
+
+        /* set soft seq attachment register */
+        memset(tmpHxs, 0, FM_PCD_PRS_NUM_OF_HDRS*sizeof(uint32_t));
+
+        /* set protocol options */
+        for(i=0;p_FmPort->optArray[i];i++)
+            switch(p_FmPort->optArray[i])
+            {
+                case(ETH_BROADCAST):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_ETH)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_ETH_BC_SHIFT;
+                    break;
+                case(ETH_MULTICAST):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_ETH)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_ETH_MC_SHIFT;
+                    break;
+                case(VLAN_STACKED):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_VLAN)
+                    tmpHxs[hdrNum] |= (i+1)<< PRS_HDR_VLAN_STACKED_SHIFT;
+                    break;
+                case(MPLS_STACKED):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_MPLS)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_MPLS_STACKED_SHIFT;
+                    break;
+                case(IPV4_BROADCAST_1):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_1_BC_SHIFT;
+                    break;
+                case(IPV4_MULTICAST_1):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_1_MC_SHIFT;
+                    break;
+                case(IPV4_UNICAST_2):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_2_UC_SHIFT;
+                    break;
+                case(IPV4_MULTICAST_BROADCAST_2):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_2_MC_BC_SHIFT;
+                    break;
+                case(IPV6_MULTICAST_1):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_1_MC_SHIFT;
+                    break;
+                case(IPV6_UNICAST_2):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_2_UC_SHIFT;
+                    break;
+                case(IPV6_MULTICAST_2):
+                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+                    tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_2_MC_SHIFT;
+                    break;
+            }
+
+        /* set MPLS default next header - HW reset workaround  */
+        GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_MPLS)
+        tmpHxs[hdrNum] |= PRS_HDR_MPLS_LBL_INTER_EN;
+        GET_PRS_HDR_NUM(L3HdrNum, HEADER_TYPE_USER_DEFINED_L3);
+        tmpHxs[hdrNum] |= L3HdrNum  << PRS_HDR_MPLS_NEXT_HDR_SHIFT;
+
+        /* config additional params for specific headers */
+        for(i=0 ; i<p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams ; i++)
+        {
+            GET_PRS_HDR_NUM(hdrNum, p_PcdParams->p_PrsParams->additionalParams[i].hdr);
+            if(hdrNum== ILLEGAL_HDR_NUM)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
+            if(hdrNum==NO_HDR_NUM)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Private headers may not use additional parameters"));
+
+            err = AdditionalPrsParams(p_FmPort, &p_PcdParams->p_PrsParams->additionalParams[i], &tmpReg);
+            if(err)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
+
+            tmpHxs[hdrNum] |= tmpReg;
+        }
+        /* link to sw parser code for L4 shells - only if no other code is applied. */
+        GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_SCTP)
+        if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
+            tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | SCTP_SW_PATCH_START);
+        GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_DCCP)
+        if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
+            tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | DCCP_SW_PATCH_START);
+        GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPSEC_AH)
+        if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
+            tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IPSEC_SW_PATCH_START);
+
+        for(i=0 ; i<FM_PCD_PRS_NUM_OF_HDRS ; i++)
+        {
+            /* For all header set LCV as taken from netEnv*/
+            WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[i].lcv,  FmPcdGetLcv(p_FmPort->h_FmPcd, p_FmPort->netEnvId, (uint8_t)i));
+            /* set HXS register according to default+Additional params+protocol options */
+            WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[i].softSeqAttach,  tmpHxs[i]);
+        }
+
+        /* set tpid. */
+        tmpReg = PRS_TPID_DFLT;
+        if(p_PcdParams->p_PrsParams->setVlanTpid1)
+        {
+            tmpReg &= PRS_TPID2_MASK;
+            tmpReg |= (uint32_t)p_PcdParams->p_PrsParams->vlanTpid1 << PRS_PCTPID_SHIFT;
+        }
+        if(p_PcdParams->p_PrsParams->setVlanTpid2)
+        {
+            tmpReg &= PRS_TPID1_MASK;
+            tmpReg |= (uint32_t)p_PcdParams->p_PrsParams->vlanTpid2;
+        }
+        WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pctpid, tmpReg);
+
+        /* enable parser */
+        WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, 0);
+    }
+
+    if(p_PcdParams->p_PrsParams->prsResultPrivateInfo)
+        p_FmPort->privateInfo = p_PcdParams->p_PrsParams->prsResultPrivateInfo;
+
+    /* set initial parser result - used for all engines */
+    for (i=0;i<PRS_RESULT_NUM_OF_WORDS;i++)
+    {
+        if (!i)
+            WRITE_UINT32(*(p_BmiInitPrsResult), (uint32_t)((p_FmPort->privateInfo << BMI_PR_PORTID_SHIFT)
+                                                            | BMI_PRS_RESULT_HIGH));
+        else
+            if (i< PRS_RESULT_NUM_OF_WORDS/2)
+                WRITE_UINT32(*(p_BmiInitPrsResult+i), BMI_PRS_RESULT_HIGH);
+            else
+                WRITE_UINT32(*(p_BmiInitPrsResult+i), BMI_PRS_RESULT_LOW);
+    }
+
+    return E_OK;
+}
+
+t_Error FmPortDeletePcd(t_Handle h_FmPort)
+{
+    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error                             err = E_OK;
+    volatile uint32_t                   *p_BmiNia=NULL;
+    //uint32_t                            tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_OFFLINE_PARSING))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+
+    if(!p_FmPort->pcdEngines)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("called for non PCD port"));
+
+    /* get PCD registers pointers */
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+        break;
+        default:
+            break;
+    }
+
+    /* "cut" PCD out of the port's flow - go to BMI */
+    //tmpReg = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
+    //WRITE_UINT32(*p_BmiNia, NIA_ENG_BMI | tmpReg);
+    WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
+
+    if(p_FmPort->pcdEngines | FM_PCD_PRS)
+    {
+        /* stop parser */
+        WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, PRS_CAC_STOP);
+        /* wait for parser to be in idle state */
+        while(GET_UINT32(p_FmPort->p_FmPortPrsRegs->pcac) & PRS_CAC_ACTIVE) ;
+    }
+
+    if(p_FmPort->pcdEngines & FM_PCD_KG)
+        FmPcdKgSwUnbindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->clsPlanGrpId);
+
+    if(p_FmPort->pcdEngines & FM_PCD_CC)
+    {
+        //unbind - we need to get the treeId too.
+
+        err = FmPcdCcUnbindTree(p_FmPort->h_FmPcd,  p_FmPort->ccTreeId);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    p_FmPort->pcdEngines = 0;
+
+    return E_OK;
+}
+
+void          FmPortPcdKgSwUnbindClsPlanGrp (t_Handle h_FmPort)
+{
+    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
+
+    FmPcdKgSwUnbindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->clsPlanGrpId);
+}
+
+t_Error          FmPortPcdKgSwBindClsPlanGrp (t_Handle h_FmPort, bool useClsPlan, uint8_t newClsPlanGrpId)
+{
+    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error         err;
+
+    if(useClsPlan)
+    {
+        p_FmPort->useClsPlan = TRUE;
+        p_FmPort->clsPlanGrpId = newClsPlanGrpId;
+        err = FmPcdKgSwBindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->netEnvId, newClsPlanGrpId, p_FmPort->optArray);
+    }
+    else
+    {
+        if(!FmPcdKgIsEmptyClsPlanGrp(p_FmPort->h_FmPcd))
+            RETURN_ERROR(MINOR, E_CONFLICT, ("A port is defined to be without clsPlan, but PCD was configured so that all ports use the clsPlan mechanism"));
+        p_FmPort->clsPlanGrpId = FmPcdKgGetEmptyClsPlanGrpId(p_FmPort->h_FmPcd);
+        err = FmPcdKgSwBindPortToClsPlanGrp(p_FmPort->h_FmPcd, DRIVER_PRIVATE_NET_ENV_ID, p_FmPort->clsPlanGrpId, p_FmPort->optArray);
+    }
+    if(err)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("FmPortPcdKgSwBindClsPlanGrp failed. "));
+
+    return E_OK;
+}
+
+void FmPortGetPortSchemeBindParams(t_Handle h_FmPort, t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t                    walking1Mask = 0x80000000, tmp;
+    uint8_t                     idx = 0;
+
+    p_SchemeBind->netEnvId = p_FmPort->netEnvId;
+    p_SchemeBind->hardwarePortId = p_FmPort->hardwarePortId;
+    p_SchemeBind->useClsPlan = p_FmPort->useClsPlan;
+    p_SchemeBind->numOfSchemes = 0;
+    tmp = p_FmPort->schemesPerPortVector;
+    if(tmp)
+    {
+        while (tmp)
+        {
+            if(tmp & walking1Mask)
+            {
+                p_SchemeBind->schemesIds[p_SchemeBind->numOfSchemes] = FmPcdKgGetSchemeSwId(p_FmPort->h_FmPcd, idx);
+                p_SchemeBind->numOfSchemes++;
+                tmp &= ~walking1Mask;
+            }
+            walking1Mask >>= 1;
+            idx++;
+        }
+    }
+}
+
+uint8_t FmPortGetNetEnvId(t_Handle h_FmPort)
+{
+    return ((t_FmPort*)h_FmPort)->netEnvId;
+}
+
+uint8_t FmPortGetHardwarePortId(t_Handle h_FmPort)
+{
+    return ((t_FmPort*)h_FmPort)->hardwarePortId;
+}
+
+uint32_t FmPortGetPcdEngines(t_Handle h_FmPort)
+{
+    return ((t_FmPort*)h_FmPort)->pcdEngines;
+}
+
+uint8_t  FmPortGetClsPlanId(t_Handle h_FmPort)
+{
+    return ((t_FmPort*)h_FmPort)->clsPlanGrpId;
+}
+
+t_Error FmPortAttachPCD(t_Handle h_FmPort)
+{
+    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t                   *p_BmiNia=NULL;
+
+    /* get PCD registers pointers */
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+        break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+            break;
+    }
+
+    /* check that current NIA is BMI to BMI */
+    if((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
+
+    WRITE_UINT32(*p_BmiNia, p_FmPort->savedBmiNia);
+
+    return E_OK;
+}
+
+/**********************************         End of inter-module routines ********************************/
+
+/****************************************/
+/*       API Init unit functions        */
+/****************************************/
+t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
+{
+    t_FmPort    *p_FmPort;
+    uint64_t    baseAddr = p_FmPortParams->baseAddr;
+
+    /* Allocate FM structure */
+    p_FmPort = (t_FmPort *) XX_Malloc(sizeof(t_FmPort));
+    if (!p_FmPort)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Port driver structure"));
+        return NULL;
+    }
+    memset(p_FmPort, 0, sizeof(t_FmPort));
+
+    /* Allocate the FM driver's parameters structure */
+    p_FmPort->p_FmPortDriverParam = (t_FmPortDriverParam *)XX_Malloc(sizeof(t_FmPortDriverParam));
+    if (!p_FmPort->p_FmPortDriverParam)
+    {
+        XX_Free(p_FmPort);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Port driver parameters"));
+        return NULL;
+    }
+    memset(p_FmPort->p_FmPortDriverParam, 0, sizeof(t_FmPortDriverParam));
+
+    /* Initialize FM port parameters which will be kept by the driver */
+    p_FmPort->portType      = p_FmPortParams->portType;
+    p_FmPort->portId        = p_FmPortParams->portId;
+    p_FmPort->pcdEngines    = FM_PCD_NONE;
+
+    /* calculate global portId number */
+    GET_GLOBAL_PORTID(p_FmPort->hardwarePortId, p_FmPort->portType, p_FmPortParams->portId);
+
+    /* Initialize FM port parameters for initialization phase only */
+    p_FmPort->p_FmPortDriverParam->baseAddr                         = baseAddr;
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize = DEFAULT_PORT_bufferPrefixContent_privDataSize;
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult= DEFAULT_PORT_bufferPrefixContent_passPrsResult;
+    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp= DEFAULT_PORT_bufferPrefixContent_passTimeStamp;
+    p_FmPort->p_FmPortDriverParam->dmaSwapData                      = DEFAULT_PORT_dmaSwapData;
+    p_FmPort->p_FmPortDriverParam->dmaIntContextCacheAttr           = DEFAULT_PORT_dmaIntContextCacheAttr;
+    p_FmPort->p_FmPortDriverParam->dmaHeaderCacheAttr               = DEFAULT_PORT_dmaHeaderCacheAttr;
+    p_FmPort->p_FmPortDriverParam->dmaScatterGatherCacheAttr        = DEFAULT_PORT_dmaScatterGatherCacheAttr;
+    p_FmPort->p_FmPortDriverParam->dmaReadOptimize                  = DEFAULT_PORT_dmaReadOptimize;
+    p_FmPort->p_FmPortDriverParam->dmaWriteOptimize                 = DEFAULT_PORT_dmaWriteOptimize;
+
+    /* resource distrubution. */
+    p_FmPort->p_FmPortDriverParam->fifoBufs.num                     = DEFAULT_PORT_sizeOfFifo(p_FmPort->portType);
+    p_FmPort->p_FmPortDriverParam->fifoBufs.extra                   = DEFAULT_PORT_extraSizeOfFifo(p_FmPort->portType);
+    p_FmPort->p_FmPortDriverParam->openDmas.num                     = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType);
+    p_FmPort->p_FmPortDriverParam->openDmas.extra                   = DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
+    p_FmPort->p_FmPortDriverParam->tasks.num                        = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
+    p_FmPort->p_FmPortDriverParam->tasks.extra                      = DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
+
+    p_FmPort->p_FmPortDriverParam->syncReq                          = DEFAULT_PORT_syncReq;
+    p_FmPort->p_FmPortDriverParam->color                            = DEFAULT_PORT_color;
+
+#ifdef   VERIFICATION_SUPPORT
+    p_FmPort->p_FmPortDriverParam->intContextConfigured             = FALSE;
+#endif /* VERIFICATION_SUPPORT */
+    /* Port type specific initialization: */
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_TX) && (p_FmPort->portType != e_FM_PORT_TYPE_TX_10G))
+        p_FmPort->p_FmPortDriverParam->frmDiscardOverride           = DEFAULT_PORT_frmDiscardOverride;
+
+    switch(p_FmPort->portType)
+    {
+    case(e_FM_PORT_TYPE_RX):
+    case(e_FM_PORT_TYPE_RX_10G):
+        /* Initialize FM port parameters for initialization phase only */
+        p_FmPort->p_FmPortDriverParam->cutBytesFromEnd              = DEFAULT_PORT_cutBytesFromEnd;
+        p_FmPort->p_FmPortDriverParam->enBufPoolDepletion           = FALSE;
+        p_FmPort->p_FmPortDriverParam->frmDiscardOverride           = DEFAULT_PORT_frmDiscardOverride;
+        p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel      = DEFAULT_PORT_rxFifoPriElevationLevel;
+        p_FmPort->p_FmPortDriverParam->rxFifoThreshold              = DEFAULT_PORT_rxFifoThreshold;
+        p_FmPort->p_FmPortDriverParam->bufMargins.endMargins        = DEFAULT_PORT_BufMargins_endMargins;
+        p_FmPort->p_FmPortDriverParam->errorsToDiscard              = DEFAULT_PORT_errorsToDiscard;
+        p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore       = DEFAULT_PORT_cheksumLastBytesIgnore;
+        p_FmPort->p_FmPortDriverParam->forwardReuseIntContext       = DEFAULT_PORT_forwardIntContextReuse;
+        p_FmPort->p_FmPortDriverParam->l4Checksum                   = DEFAULT_PORT_l4Checksum;
+        break;
+
+    case(e_FM_PORT_TYPE_TX):
+        p_FmPort->txFifoDeqPipelineDepth                            = DEFAULT_PORT_txFifoDeqPipelineDepth_1G;
+    case(e_FM_PORT_TYPE_TX_10G):
+        if(p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
+            p_FmPort->txFifoDeqPipelineDepth                        = DEFAULT_PORT_txFifoDeqPipelineDepth_10G;
+        p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore       = DEFAULT_PORT_cheksumLastBytesIgnore;
+        p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel           = DEFAULT_PORT_txFifoMinFillLevel;
+        p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel           = DEFAULT_PORT_txFifoLowComfLevel;
+    case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        p_FmPort->p_FmPortDriverParam->enRateLimit                  = FALSE;
+    case(e_FM_PORT_TYPE_HOST_COMMAND):
+        p_FmPort->p_FmPortDriverParam->deqHighPriority              = DEFAULT_PORT_deqHighPriority;
+        p_FmPort->p_FmPortDriverParam->deqType                      = DEFAULT_PORT_deqType;
+        p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption;
+        p_FmPort->p_FmPortDriverParam->deqByteCnt                   = DEFAULT_PORT_deqByteCnt;
+
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OFFLINE_PARSING)
+        {
+            p_FmPort->p_FmPortDriverParam->errorsToDiscard          = DEFAULT_PORT_errorsToDiscard;
+        }
+        break;
+
+    default:
+        break;
+    }
+
+    p_FmPort->imEn = p_FmPortParams->independentModeEnable;
+
+    if (p_FmPort->imEn)
+        FmPortConfigIM(p_FmPort, p_FmPortParams);
+    else
+    {
+        switch(p_FmPort->portType)
+        {
+        case(e_FM_PORT_TYPE_RX):
+        case(e_FM_PORT_TYPE_RX_10G):
+            /* Initialize FM port parameters for initialization phase only */
+            memcpy(&p_FmPort->p_FmPortDriverParam->rxExtBufPools,
+                   &p_FmPortParams->specificParams.rxParams.rxExtBufPools,
+                   sizeof(t_FmPortRxExtPools));
+            p_FmPort->p_FmPortDriverParam->errFqid                      = p_FmPortParams->specificParams.rxParams.errFqid;
+            p_FmPort->p_FmPortDriverParam->dfltFqid                     = p_FmPortParams->specificParams.rxParams.dfltFqid;
+            p_FmPort->p_FmPortDriverParam->partitionId                  = p_FmPortParams->specificParams.rxParams.rxPartitionId;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+#ifdef FM_OP_PARTITION_ERRATA
+            p_FmPort->p_FmPortDriverParam->partitionId                  = p_FmPortParams->specificParams.nonRxParams.opPartitionId;
+#endif /* FM_OP_PARTITION_ERRATA */
+        case(e_FM_PORT_TYPE_TX):
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_HOST_COMMAND):
+            p_FmPort->p_FmPortDriverParam->errFqid                      = p_FmPortParams->specificParams.nonRxParams.errFqid;
+            p_FmPort->p_FmPortDriverParam->deqSubPortal                 = p_FmPortParams->specificParams.nonRxParams.deqSubPortal;
+            p_FmPort->p_FmPortDriverParam->dfltFqid                     = p_FmPortParams->specificParams.nonRxParams.dfltFqid;
+            break;
+        default:
+            break;
+        }
+    }
+
+    p_FmPort->h_Fm = p_FmPortParams->h_Fm;
+
+    return p_FmPort;
+}
+
+/**************************************************************************//**
+ @Function      FM_PORT_Init
+
+ @Description   Initializes the FM module
+
+ @Param[in]     h_FmPort - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PORT_Init(t_Handle h_FmPort)
+{
+    t_FmPort                        *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPortDriverParam             *p_Params;
+    t_Error                         err = E_OK;
+    t_FmInterModulePortInitParams   fmParams;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+#ifdef VERIFICATION_SUPPORT
+    if(!p_FmPort->p_FmPortDriverParam->intContextConfigured)
+    {
+#endif /* VERIFICATION_SUPPORT */
+    /* translate margin and intContext params to FM parameters */
+    p_FmPort->p_FmPortDriverParam->intContext.size = (uint16_t)((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ? 32:0) +
+                                                        (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp ? 16:0));
+    /* align start of internal context data to 16 byte */
+    p_FmPort->p_FmPortDriverParam->intContext.extBufOffset =  (uint16_t)((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize & (OFFSET_UNITS-1))?
+            ((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize + OFFSET_UNITS) &  ~(uint16_t)(OFFSET_UNITS-1)) :
+            p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize);
+    p_FmPort->p_FmPortDriverParam->intContext.intContextOffset = (uint8_t)(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ? 32:
+            (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp ? 64 : 0));
+    p_FmPort->p_FmPortDriverParam->bufMargins.startMargins = (uint16_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset +
+            p_FmPort->p_FmPortDriverParam->intContext.size);
+#ifdef VERIFICATION_SUPPORT
+    }
+#endif /* VERIFICATION_SUPPORT */
+    CHECK_INIT_PARAMETERS(p_FmPort, CheckInitParameters);
+
+    p_Params = p_FmPort->p_FmPortDriverParam;
+
+    /* set memory map pointers */
+    p_FmPort->p_FmPortQmiRegs     = CAST_UINT64_TO_POINTER_TYPE(t_FmPortQmiRegs , (p_Params->baseAddr + QMI_PORT_REGS_OFFSET));
+    p_FmPort->p_FmPortBmiRegs     = CAST_UINT64_TO_POINTER_TYPE(u_FmPortBmiRegs , (p_Params->baseAddr + BMI_PORT_REGS_OFFSET));
+    p_FmPort->p_FmPortPrsRegs     = CAST_UINT64_TO_POINTER_TYPE(t_FmPortPrsRegs, (p_Params->baseAddr + PRS_PORT_REGS_OFFSET));
+
+#ifdef VERIFICATION_SUPPORT
+    if(p_FmPort->p_FmPortDriverParam->intContextConfigured)
+    {
+        p_FmPort->bufferOffsets.dataOffset = p_FmPort->p_FmPortDriverParam->bufMargins.startMargins;
+        p_FmPort->bufferOffsets.prsResultOffset = (uint32_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset+32 - p_FmPort->p_FmPortDriverParam->intContext.intContextOffset);
+        p_FmPort->bufferOffsets.timeStampOffset = (uint32_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset+64 - p_FmPort->p_FmPortDriverParam->intContext.intContextOffset);
+    }
+    else
+    {
+#endif /* VERIFICATION_SUPPORT */
+    p_FmPort->bufferOffsets.dataOffset = p_FmPort->p_FmPortDriverParam->bufMargins.startMargins;
+    p_FmPort->bufferOffsets.prsResultOffset = p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ?
+                                    p_FmPort->p_FmPortDriverParam->intContext.extBufOffset:
+                                    0xFFFFFFFF;
+    p_FmPort->bufferOffsets.timeStampOffset = p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp ?
+                                    (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ?
+                                    (p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + sizeof(t_FmPrsResult)) :
+                                    p_FmPort->p_FmPortDriverParam->intContext.extBufOffset):
+                                    0xFFFFFFFF;
+
+#ifdef VERIFICATION_SUPPORT
+    }
+#endif /* VERIFICATION_SUPPORT */
+    /************************************************************/
+    /* Call FM module routine for communicating parameters      */
+    /************************************************************/
+    memset(&fmParams, 0, sizeof(fmParams));
+    fmParams.hardwarePortId = p_FmPort->hardwarePortId;
+    fmParams.portType = (e_FmPortType)p_FmPort->portType;
+    fmParams.numOfTasks = (uint8_t)p_Params->tasks.num;
+    fmParams.numOfExtraTasks = (uint8_t)p_Params->tasks.extra;
+    fmParams.numOfOpenDmas = (uint8_t)p_Params->openDmas.num;
+    fmParams.numOfExtraOpenDmas = (uint8_t)p_Params->openDmas.extra;
+    fmParams.sizeOfFifo = p_Params->fifoBufs.num;
+    fmParams.extraSizeOfFifo = p_Params->fifoBufs.extra;
+
+    fmParams.independentMode = p_FmPort->imEn;
+    fmParams.portPartition = p_Params->partitionId;
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            break;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+            fmParams.deqPipelineDepth = p_FmPort->txFifoDeqPipelineDepth;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_HOST_COMMAND):
+            fmParams.deqPipelineDepth = p_FmPort->txFifoDeqPipelineDepth = 1;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+    }
+
+    err = FmGetSetPortParams(p_FmPort->h_Fm, &fmParams);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    /* get params for use in init */
+    p_Params->timeStampPeriod = fmParams.timeStampPeriod;
+    p_Params->fmMuramPhysBaseAddr = 0;
+    memcpy(((uint8_t *)&p_Params->fmMuramPhysBaseAddr)+2, (uint8_t *)&fmParams.fmMuramPhysBaseAddr, sizeof(t_FmPhysAddr));
+
+    /**********************/
+    /* Init BMI Registers */
+    /**********************/
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            err = BmiRxPortInit(p_FmPort);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+            break;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+            err = BmiTxPortInit(p_FmPort);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_HOST_COMMAND):
+            err = BmiOhPortInit(p_FmPort);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+    }
+
+    /**********************/
+    /* Init QMI Registers */
+    /**********************/
+    if (!p_FmPort->imEn && ((err = QmiInit(p_FmPort)) != E_OK))
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    if (p_FmPort->imEn && ((err = FmPortImInit(p_FmPort)) != E_OK))
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    FmPortDriverParamFree(p_FmPort);
+
+    /* enable port. */
+    FM_PORT_Enable(p_FmPort);
+
+    return E_OK;
+}
+
+/**************************************************************************//**
+ @Function      FM_PORT_Free
+
+ @Description   Frees all resources that were assigned to FM module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmPort - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PORT_Free(t_Handle h_FmPort)
+{
+    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmInterModulePortFreeParams       fmParams;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+
+    if(p_FmPort->pcdEngines)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Trying to free a port with PCD. FM_PORT_DeletePCD must be called first."));
+
+    FM_PORT_Disable(p_FmPort);
+    FmPortDriverParamFree(p_FmPort);
+
+    if (p_FmPort->imEn)
+        FmPortImFree(p_FmPort);
+
+    fmParams.hardwarePortId = p_FmPort->hardwarePortId;
+    fmParams.portType = (e_FmPortType)p_FmPort->portType;
+    fmParams.deqPipelineDepth = p_FmPort->txFifoDeqPipelineDepth;
+
+    FmFreePortParams(p_FmPort->h_Fm, &fmParams);
+
+    XX_Free(p_FmPort);
+
+    return E_OK;
+}
+
+/*************************************************/
+/*       API Advanced Init unit functions        */
+/*************************************************/
+t_Error FM_PORT_ConfigNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfOpenDmas)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_FmPort->p_FmPortDriverParam->openDmas, p_NumOfOpenDmas, sizeof(t_FmPortRsrc));
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    if(p_FmPort->portType == e_FM_PORT_TYPE_HOST_COMMAND)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("not available for host command port where number is always 1"));
+
+    memcpy(&p_FmPort->p_FmPortDriverParam->tasks, p_NumOfTasks, sizeof(t_FmPortRsrc));
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_FmPort->p_FmPortDriverParam->fifoBufs, p_SizeOfFifo, sizeof(t_FmPortRsrc));
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDeqHighPriority(t_Handle h_FmPort, bool highPri)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("not available for Rx ports"));
+
+    p_FmPort->p_FmPortDriverParam->deqHighPriority = highPri;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDeqType(t_Handle h_FmPort, e_FmPortDeqType deqType)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
+
+    p_FmPort->p_FmPortDriverParam->deqType = deqType;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOption deqPrefetchOption)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
+
+    p_FmPort->p_FmPortDriverParam->deqPrefetchOption = deqPrefetchOption;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDeqByteCnt(t_Handle h_FmPort, uint16_t deqByteCnt)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
+
+    p_FmPort->p_FmPortDriverParam->deqByteCnt = deqByteCnt;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigBufferPrefixContent(t_Handle h_FmPort, t_FmPortBufferPrefixContent *p_FmPortBufferPrefixContent)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_FmPort->p_FmPortDriverParam->bufferPrefixContent, p_FmPortBufferPrefixContent, sizeof(t_FmPortBufferPrefixContent));
+
+    return E_OK;
+}
+
+#ifdef VERIFICATION_SUPPORT
+t_Error FM_PORT_ConfigIntContent(t_Handle h_FmPort, uint8_t intContextIntOffset,
+                                                    uint16_t intContextExtOffset,
+                                                    uint16_t intContextSize,
+                                                    uint16_t startMargins,
+                                                    uint16_t endMargins)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->p_FmPortDriverParam->intContext.size = intContextSize;
+    /* align start of internal context data to 16 byte */
+    p_FmPort->p_FmPortDriverParam->intContext.extBufOffset =  intContextExtOffset;
+    p_FmPort->p_FmPortDriverParam->intContext.intContextOffset = intContextIntOffset;
+    p_FmPort->p_FmPortDriverParam->bufMargins.startMargins = startMargins;
+    p_FmPort->p_FmPortDriverParam->bufMargins.endMargins = endMargins;
+
+    p_FmPort->p_FmPortDriverParam->intContextConfigured = TRUE;
+   return E_OK;
+}
+#endif /* VERIFICATION_SUPPORT */
+
+t_Error FM_PORT_ConfigCheksumLastBytesIgnore(t_Handle h_FmPort, uint8_t cheksumLastBytesIgnore)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType == e_FM_PORT_TYPE_OFFLINE_PARSING) || (p_FmPort->portType == e_FM_PORT_TYPE_HOST_COMMAND))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx & Tx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore = cheksumLastBytesIgnore;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigCutBytesFromEnd(t_Handle h_FmPort, uint8_t cutBytesFromEnd)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->cutBytesFromEnd = cutBytesFromEnd;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmPortBufPoolDepletion *p_BufPoolDepletion)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->enBufPoolDepletion = TRUE;
+    memcpy(&p_FmPort->p_FmPortDriverParam->bufPoolDepletion, p_BufPoolDepletion, sizeof(t_FmPortBufPoolDepletion));
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->rxFifoThreshold = fifoThreshold;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigRxPriElevationLevel(t_Handle h_FmPort, uint32_t priElevationLevel)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel = priElevationLevel;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLevel)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel = minFillLevel;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigTxFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipelineDepth)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
+
+    p_FmPort->txFifoDeqPipelineDepth = deqPipelineDepth;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComfLevel)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel = fifoLowComfLevel;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDfltColor(t_Handle h_FmPort, e_FmPortColor color)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->p_FmPortDriverParam->color = color;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->p_FmPortDriverParam->syncReq = syncReq;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+                                                (p_FmPort->portType == e_FM_PORT_TYPE_HOST_COMMAND))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx and Offline parsing ports only"));
+
+    memcpy(&p_FmPort->p_FmPortDriverParam->rateLimit, p_RateLimit, sizeof(t_FmPortRateLimit));
+    p_FmPort->p_FmPortDriverParam->enRateLimit = TRUE;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigFrmDiscardOverride(t_Handle h_FmPort, bool override)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Tx ports"));
+
+    p_FmPort->p_FmPortDriverParam->frmDiscardOverride = override;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort, fmPortFrameErrSelect_t errs)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+                                                            (p_FmPort->portType != e_FM_PORT_TYPE_OFFLINE_PARSING))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+
+    p_FmPort->p_FmPortDriverParam->errorsToDiscard = errs;
+
+    return E_OK;
+}
+
+
+t_Error FM_PORT_ConfigDmaSwapData(t_Handle h_FmPort, e_FmPortDmaSwap swapData)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->p_FmPortDriverParam->dmaSwapData = swapData;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort, e_FmPortDmaCache intContextCacheAttr)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->p_FmPortDriverParam->dmaIntContextCacheAttr = intContextCacheAttr;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort, e_FmPortDmaCache headerCacheAttr)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->p_FmPortDriverParam->dmaHeaderCacheAttr = headerCacheAttr;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmPortDmaCache scatterGatherCacheAttr)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->p_FmPortDriverParam->dmaScatterGatherCacheAttr = scatterGatherCacheAttr;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDmaReadOptimize(t_Handle h_FmPort, bool optimize)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->p_FmPortDriverParam->dmaReadOptimize = optimize;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigDmaWriteOptimize(t_Handle h_FmPort, bool optimize)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->p_FmPortDriverParam->dmaWriteOptimize = optimize;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigForwardReuseIntContext(t_Handle h_FmPort, bool forwardReuse)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->forwardReuseIntContext = forwardReuse;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigRxL4ChecksumVerify(t_Handle h_FmPort, bool l4Checksum)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->l4Checksum = l4Checksum;
+
+    return E_OK;
+}
+
+/****************************************************/
+/*       PCD Advaced config API                     */
+/****************************************************/
+
+/****************************************************/
+/*       API Run-time Control unit functions        */
+/****************************************************/
+
+uint32_t FM_PORT_GetBufferDataOffset(t_Handle h_FmPort)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, 0);
+
+    return p_FmPort->bufferOffsets.dataOffset;
+}
+
+t_FmPrsResult *FM_PORT_GetBufferPrsResult(t_Handle h_FmPort, char *p_Data)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
+
+    if(p_FmPort->bufferOffsets.prsResultOffset == 0xFFFFFFFF)
+        return NULL;
+
+    return (t_FmPrsResult *)((uint32_t)p_Data + p_FmPort->bufferOffsets.prsResultOffset);
+}
+
+t_FmTimeStamp *FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
+
+    if(p_FmPort->bufferOffsets.timeStampOffset == 0xFFFFFFFF)
+        return NULL;
+    return (t_FmTimeStamp *)((uint32_t)p_Data + p_FmPort->bufferOffsets.timeStampOffset);
+}
+
+
+void FM_PORT_Disable(t_Handle h_FmPort)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t           *p_BmiCfgReg = NULL;
+    volatile uint32_t           *p_BmiStatusReg = NULL;
+    bool                        rxPort = FALSE;
+
+    SANITY_CHECK_RETURN(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcfg;
+            p_BmiStatusReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rst;
+            rxPort = TRUE;
+            break;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+             p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg;
+             p_BmiStatusReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tst;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_HOST_COMMAND):
+            p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocfg;
+            p_BmiStatusReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ost;
+            break;
+        default:
+            break;
+    }
+
+    /* Disable QMI */
+    if (!rxPort && !p_FmPort->imEn)
+    {
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc,
+                     GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & ~QMI_PORT_CFG_EN);
+        /* wait for QMI to finish Handling dequeue tnums */
+        while(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pns) & QMI_PORT_STATUS_DEQ_TNUM_BSY) ;
+        while(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pns) & QMI_PORT_STATUS_DEQ_FD_BSY) ;
+    }
+
+    /* Disable BMI */
+    WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) & ~BMI_PORT_CFG_EN);
+    while(GET_UINT32(*p_BmiStatusReg) & BMI_PORT_STATUS_BSY) ;
+}
+
+void FM_PORT_Enable(t_Handle h_FmPort)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t           *p_BmiCfgReg = NULL;
+    bool                        rxPort = FALSE;
+
+    SANITY_CHECK_RETURN(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcfg;
+            rxPort = TRUE;
+            break;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+             p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_HOST_COMMAND):
+            p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocfg;
+            break;
+        default:
+            break;
+    }
+
+
+    /* Enable QMI */
+    if (!rxPort && !p_FmPort->imEn)
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc,
+                     GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) | QMI_PORT_CFG_EN);
+
+    /* Enable BMI */
+    WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) | BMI_PORT_CFG_EN);
+}
+
+t_Error FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable)
+{
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t                tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    tmpReg = GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc);
+
+    if(enable)
+        tmpReg |= QMI_PORT_CFG_EN_COUNTERS ;
+    else
+        tmpReg &= ~QMI_PORT_CFG_EN_COUNTERS;
+
+    WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc, tmpReg);
+
+    return E_OK;
+}
+
+t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, t_FmPortPerformanceCnt *p_FmPortPerformanceCnt, bool enable)
+{
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t                tmpReg;
+    volatile uint32_t       *p_BmiPcReg = NULL;
+    volatile uint32_t       *p_BmiPcpReg = NULL;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpc;
+            p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpcp;
+            break;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+            p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpc;
+            p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpcp;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_HOST_COMMAND):
+            p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opc;
+            p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opcp;
+            break;
+        default:
+            break;
+    }
+
+    if(enable)
+    {
+        /* check parameters */
+        if(!p_FmPortPerformanceCnt->taskCompVal || (p_FmPortPerformanceCnt->taskCompVal > MAX_PERFORMANCE_TASK_COMP) )
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.taskCompVal has to be in the range of 1 - %d", MAX_PERFORMANCE_TASK_COMP));
+        if(!p_FmPortPerformanceCnt->dmaCompVal || (p_FmPortPerformanceCnt->dmaCompVal > MAX_PERFORMANCE_DMA_COMP))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.dmaCompVal has to be in the range of 1 - %d", MAX_PERFORMANCE_DMA_COMP));
+        if(!p_FmPortPerformanceCnt->fifoCompVal || (p_FmPortPerformanceCnt->fifoCompVal > BMI_MAX_FIFO_SIZE))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.fifoCompVal has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
+        if(p_FmPortPerformanceCnt->fifoCompVal % BMI_FIFO_UNITS)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.fifoCompVal has to be divisible by %d", BMI_FIFO_UNITS));
+        switch(p_FmPort->portType)
+        {
+            case(e_FM_PORT_TYPE_RX_10G):
+            case(e_FM_PORT_TYPE_RX):
+                if(!p_FmPortPerformanceCnt->queueCompVal || (p_FmPortPerformanceCnt->queueCompVal > MAX_PERFORMANCE_RX_QUEUE_COMP))
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.queueCompVal for Rx has to be in the range of 1 - %d", MAX_PERFORMANCE_RX_QUEUE_COMP));
+                break;
+            case(e_FM_PORT_TYPE_TX_10G):
+            case(e_FM_PORT_TYPE_TX):
+                if(!p_FmPortPerformanceCnt->queueCompVal || (p_FmPortPerformanceCnt->queueCompVal > MAX_PERFORMANCE_TX_QUEUE_COMP))
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.queueCompVal for Tx has to be in the range of 1 - %d", MAX_PERFORMANCE_TX_QUEUE_COMP));
+                break;
+            case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            case(e_FM_PORT_TYPE_HOST_COMMAND):
+                if(p_FmPortPerformanceCnt->queueCompVal)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.queueCompVal is not relevant for H/O ports."));
+                break;
+            default:
+                break;
+        }
+
+        tmpReg = 0;
+        tmpReg |= ((p_FmPortPerformanceCnt->queueCompVal - 1) << BMI_PERFORMANCE_PORT_COMP_SHIFT);
+        tmpReg |= ((p_FmPortPerformanceCnt->dmaCompVal- 1) << BMI_PERFORMANCE_DMA_COMP_SHIFT);
+        tmpReg |= ((p_FmPortPerformanceCnt->fifoCompVal/BMI_FIFO_UNITS - 1) << BMI_PERFORMANCE_FIFO_COMP_SHIFT);
+        if ((p_FmPort->portType != e_FM_PORT_TYPE_OFFLINE_PARSING) && (p_FmPort->portType != e_FM_PORT_TYPE_HOST_COMMAND))
+            tmpReg |= ((p_FmPortPerformanceCnt->taskCompVal - 1)  << BMI_PERFORMANCE_TASK_COMP_SHIFT);
+
+        WRITE_UINT32(*p_BmiPcpReg, tmpReg);
+        WRITE_UINT32(*p_BmiPcReg, BMI_COUNTERS_EN);
+    }
+    else
+        WRITE_UINT32(*p_BmiPcReg, 0);
+
+    return E_OK;
+}
+
+t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable)
+{
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t                tmpReg;
+    volatile uint32_t       *p_BmiStcReg = NULL;
+
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiStcReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rstc;
+            break;
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
+            p_BmiStcReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tstc;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_HOST_COMMAND):
+            p_BmiStcReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ostc;
+            break;
+        default:
+            break;
+    }
+
+    tmpReg = GET_UINT32(*p_BmiStcReg);
+
+    if(enable)
+        tmpReg |= BMI_COUNTERS_EN;
+    else
+        tmpReg &= ~BMI_COUNTERS_EN;
+
+    WRITE_UINT32(*p_BmiStcReg, tmpReg);
+
+    return E_OK;
+}
+
+t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort,  fmPortFrameErrSelect_t errs)
+{
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t       *p_ErrQReg, *p_ErrDiscard;
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_ErrQReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsem;
+            p_ErrDiscard = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            p_ErrQReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsem;
+            p_ErrDiscard = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm;
+            break;
+        default:
+           RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    }
+
+    if(GET_UINT32(*p_ErrDiscard) & errs)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Selectd Errors that were configured to cause frame discard."));
+
+    WRITE_UINT32(*p_ErrQReg, errs);
+
+    return E_OK;
+}
+
+t_Error FM_PORT_SetEnAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enable)
+{
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t                tmpReg;
+    int                     i;
+
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(poolId<MAX_NUM_OF_EXT_POOLS, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    for(i=0 ; i< FM_PORT_MAX_NUM_OF_EXT_POOLS ; i++)
+    {
+        tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i]);
+        if ((uint8_t)((tmpReg & BMI_EXT_BUF_POOL_ID_MASK) >> BMI_EXT_BUF_POOL_ID_SHIFT) == poolId)
+        {
+            if(enable)
+                tmpReg |= BMI_EXT_BUF_POOL_EN_COUNTER;
+            else
+                tmpReg &= ~BMI_EXT_BUF_POOL_EN_COUNTER;
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i], tmpReg);
+            break;
+        }
+    }
+    if (i == FM_PORT_MAX_NUM_OF_EXT_POOLS)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE,("poolId %d is not included in this ports pools", poolId));
+
+
+    return E_OK;
+}
+
+uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    bool                bmiCounter = FALSE;
+    volatile uint32_t   *p_Reg;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+        case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+        case(e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
+            /* check that counter is available for the port type */
+            if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+            {
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
+                return 0;
+            }
+            bmiCounter = FALSE;
+        case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+            bmiCounter = FALSE;
+        break;
+        default: /* BMI counters (or error - will be checked in BMI routine )*/
+            bmiCounter = TRUE;
+            break;
+    }
+
+    if(bmiCounter)
+    {
+        switch(p_FmPort->portType)
+        {
+            case(e_FM_PORT_TYPE_RX_10G):
+            case(e_FM_PORT_TYPE_RX):
+                if(BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+                {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                    return 0;
+                }
+                break;
+            case(e_FM_PORT_TYPE_TX_10G):
+            case(e_FM_PORT_TYPE_TX):
+                if(BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+                {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                    return 0;
+                }
+                break;
+            case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            case(e_FM_PORT_TYPE_HOST_COMMAND):
+                if(BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+                {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                    return 0;
+                }
+            default:
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Unsupported port type"));
+                return 0;
+                break;
+        }
+        return GET_UINT32(*p_Reg);
+    }
+    else /* QMI counter */
+    {
+
+        /* check that counters are enabled */
+        if(!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
+        {
+            REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            return 0;
+        }
+
+        /* Set counter */
+        switch(counter)
+        {
+           case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+                return GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnetfc);
+            break;
+            case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+                return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndtfc);
+            break;
+            case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+                return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndfdc);
+            break;
+            case(e_FM_PORT_COUNTERS_DEQ_CONFIRM):
+                return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndcc);
+            break;
+            default:
+                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available"));
+                return 0;
+                break;
+        }
+    }
+}
+
+t_Error FM_PORT_SetCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint32_t value)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    bool                bmiCounter = FALSE;
+    volatile uint32_t   *p_Reg;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+        case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+        case(e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
+            /* check that counter is available for the port type */
+            if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+                        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
+        case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+            bmiCounter = FALSE;
+        break;
+        default: /* BMI counters (or error - will be checked in BMI routine )*/
+            bmiCounter = TRUE;
+            break;
+    }
+
+    if(bmiCounter)
+    {
+        switch(p_FmPort->portType)
+        {
+            case(e_FM_PORT_TYPE_RX_10G):
+            case(e_FM_PORT_TYPE_RX):
+               if(BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+                    RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                break;
+            case(e_FM_PORT_TYPE_TX_10G):
+            case(e_FM_PORT_TYPE_TX):
+               if(BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+                    RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                break;
+            case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            case(e_FM_PORT_TYPE_HOST_COMMAND):
+               if(BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+                    RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                 break;
+            default:
+               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported port type"));
+        }
+        WRITE_UINT32(*p_Reg, value);
+    }
+    else /* QMI counter */
+    {
+
+        /* check that counters are enabled */
+        if(!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+
+        /* Set counter */
+        switch(counter)
+        {
+           case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnetfc, value);
+            break;
+            case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndtfc, value);
+            break;
+            case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndfdc, value);
+            break;
+            case(e_FM_PORT_COUNTERS_DEQ_CONFIRM):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndcc, value);
+            break;
+            default:
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available"));
+                break;
+        }
+    }
+    return E_OK;
+}
+
+uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId)
+{
+    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t        extPoolReg;
+    uint8_t         tmpPool;
+    uint8_t         i;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
+        return 0;
+    }
+
+    for(i=0;i<FM_PORT_MAX_NUM_OF_EXT_POOLS;i++)
+    {
+        extPoolReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i]);
+        if (extPoolReg & BMI_EXT_BUF_POOL_VALID)
+        {
+            tmpPool = (uint8_t)((extPoolReg & BMI_EXT_BUF_POOL_ID_MASK) >> BMI_EXT_BUF_POOL_ID_SHIFT);
+            if(tmpPool == poolId)
+            {
+                if(extPoolReg & BMI_EXT_BUF_POOL_EN_COUNTER)
+                    return  GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt[i]);
+                else
+                {
+                    REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not enabled"));
+                    return 0;
+                }
+            }
+        }
+    }
+    REPORT_ERROR(MINOR, E_INVALID_STATE, ("Pool %d is not used", poolId));
+    return 0;
+}
+
+t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, uint32_t value)
+{
+    t_FmPort        *p_FmPort = (t_FmPort *)h_FmPort;
+    uint32_t        extPoolReg;
+    uint8_t         tmpPool;
+    uint8_t         i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
+
+
+    for(i=0;i<FM_PORT_MAX_NUM_OF_EXT_POOLS;i++)
+    {
+        extPoolReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i]);
+        if (extPoolReg & BMI_EXT_BUF_POOL_VALID)
+        {
+            tmpPool = (uint8_t)((extPoolReg & BMI_EXT_BUF_POOL_ID_MASK) >> BMI_EXT_BUF_POOL_ID_SHIFT);
+            if(tmpPool == poolId)
+            {
+                if(extPoolReg & BMI_EXT_BUF_POOL_EN_COUNTER)
+                {
+                    WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt[i], value);
+                    return E_OK;
+                }
+                else
+                    RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not enabled"));
+            }
+        }
+    }
+    RETURN_ERROR(MINOR, E_INVALID_STATE, ("Pool %d is not used", poolId));
+}
+
+bool FM_PORT_IsStalled(t_Handle h_FmPort)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, FALSE);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, FALSE);
+
+    return FmIsPortStalled(p_FmPort->h_Fm, p_FmPort->hardwarePortId);
+}
+
+t_Error FM_PORT_ReleaseStalled(t_Handle h_FmPort)
+{
+    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    return FmResumeStalledPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId);
+}
+
+
+/*       API Run-time PCD Control unit functions        */
+
+
+t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error                     err;
+
+    p_FmPort->h_FmPcd = FmGetPcdHandle(p_FmPort->h_Fm);
+    ASSERT_COND(p_FmPort->h_FmPcd);
+
+    err = FmPcdPlcrAllocProfiles(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, numOfProfiles);
+    if(err)
+        RETURN_ERROR(MAJOR, err,NO_MSG);
+
+    FmPcdPortRegister(p_FmPort->h_FmPcd, h_FmPort, p_FmPort->hardwarePortId);
+
+    return E_OK;
+}
+
+t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error                     err;
+
+    err = FmPcdPlcrFreeProfiles(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId);
+    if(err)
+        RETURN_ERROR(MAJOR, err,NO_MSG);
+    return E_OK;
+}
+
+t_Error            FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSelect *p_FmPcdKgScheme)
+{
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t       *p_BmiHpnia = NULL;
+    uint32_t                tmpReg;
+    uint8_t                 relativeSchemeId;
+    uint8_t                 physicalSchemeId;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG , E_INVALID_STATE);
+
+
+    tmpReg = (uint32_t)((p_FmPort->pcdEngines & FM_PCD_CC)? NIA_KG_CC_EN:0);
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    }
+
+    TRY_LOCK_RET_ERR(p_FmPort->lock);
+    /* if we want to change to direct scheme, we need to check that this scheme is valid */
+    if(p_FmPcdKgScheme->direct)
+    {
+        physicalSchemeId = (uint8_t)(CAST_POINTER_TO_UINT32(p_FmPcdKgScheme->h_DirectScheme)-1);
+        /* check that this scheme is bound to this port */
+        if(!(p_FmPort->schemesPerPortVector &  (uint32_t)(1 << (31 - physicalSchemeId))))
+        {
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("called with a scheme that is not bound to this port"));
+        }
+
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPort->h_FmPcd, physicalSchemeId);
+        if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+        {
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("called with invalid Scheme "));
+        }
+
+        if(!FmPcdKgIsSchemeValidSw(p_FmPort->h_FmPcd, relativeSchemeId))
+        {
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("called with uninitialized Scheme "));
+        }
+
+        WRITE_UINT32(*p_BmiHpnia, NIA_ENG_KG | tmpReg | NIA_KG_DIRECT | (uint32_t)physicalSchemeId);
+    }
+    else /* change to indirect scheme */
+        WRITE_UINT32(*p_BmiHpnia, NIA_ENG_KG | tmpReg);
+
+    RELEASE_LOCK(p_FmPort->lock);
+    return E_OK;
+}
+
+t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_Profile)
+{
+    t_FmPort                        *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t               *p_BmiNia;
+    volatile uint32_t               *p_BmiHpnia;
+    uint32_t                        tmpReg;
+    uint16_t                        absoluteProfileId = (uint16_t)(CAST_POINTER_TO_UINT32(h_Profile)-1);
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_PLCR , E_INVALID_STATE);
+
+    /* check relevancy of this routine  - only when policer is used
+    directly after BMI or Parser */
+    if((p_FmPort->pcdEngines & FM_PCD_KG) || (p_FmPort->pcdEngines & FM_PCD_CC))
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("relevant only when PCD support mode is e_FM_PCD_SUPPORT_PLCR_ONLY or e_FM_PCD_SUPPORT_PRS_AND_PLCR"));
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne;
+            tmpReg = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+            p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
+            tmpReg = 0;
+            break;
+        default:
+           RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    }
+
+    TRY_LOCK_RET_ERR(p_FmPort->lock);
+    if(!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
+    {
+        RELEASE_LOCK(p_FmPort->lock);
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Invalid profile"));
+    }
+
+    tmpReg = (uint32_t)(NIA_ENG_PLCR | NIA_PLCR_ABSOLUTE | absoluteProfileId);
+
+    if(p_FmPort->pcdEngines & FM_PCD_PRS) /* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
+    {
+        /* update BMI HPNIA */
+        WRITE_UINT32(*p_BmiHpnia, tmpReg);
+    }
+    else /* e_FM_PCD_SUPPORT_PLCR_ONLY */
+    {
+        /* rfne may contain FDCS bits, so first we read them. */
+        tmpReg |= (GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK);
+        /* update BMI NIA */
+        WRITE_UINT32(*p_BmiNia, tmpReg);
+    }
+    RELEASE_LOCK(p_FmPort->lock);
+    return E_OK;
+}
+
+
+t_Error          FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
+{
+    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t                            ccTreePhysOffset;
+    volatile uint32_t                   *p_BmiCcBase=NULL;
+    t_Error                             err;
+    volatile uint32_t                   *p_BmiNia=NULL;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_VALUE);
+
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+
+    /* get PCD registers pointers */
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+        break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+            break;
+    }
+
+    /* check that current NIA is BMI to BMI */
+    if((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
+
+    if(p_FmPort->pcdEngines & FM_PCD_CC)
+    {
+        switch(p_FmPort->portType)
+        {
+            case(e_FM_PORT_TYPE_RX_10G):
+            case(e_FM_PORT_TYPE_RX):
+                p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rccb;
+                break;
+            case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+                p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_occb;
+            break;
+            default:
+                break;
+        }
+
+        TRY_LOCK_RET_ERR(p_FmPort->lock);
+        err = FmPcdCcBindTree(p_FmPort->h_FmPcd, h_CcTree, &ccTreePhysOffset);
+        if(err)
+        {
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        }
+        WRITE_UINT32(*p_BmiCcBase, ccTreePhysOffset);
+
+        p_FmPort->ccTreeId = h_CcTree;
+        RELEASE_LOCK(p_FmPort->lock);
+    }
+    else
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Coarse CLassification not defined for this port."));
+
+    return E_OK;
+}
+
+t_Error FM_PORT_AttachPCD(t_Handle h_FmPort)
+{
+
+    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error         err;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+
+   /* may add here checks for:
+        SP (or in sw: schemes)
+        CPP (or in sw clsPlan)
+        Parser enabled and configured(?)
+        Tree(?)
+        Profile - only if direct.
+        Scheme - only if direct */
+
+    TRY_LOCK_RET_ERR(p_FmPort->lock);
+
+    err = FmPortAttachPCD(h_FmPort);
+
+    RELEASE_LOCK(p_FmPort->lock);
+
+    return err;
+}
+
+t_Error FM_PORT_DetachPCD(t_Handle h_FmPort)
+{
+    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t                   *p_BmiNia=NULL;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+
+    /* get PCD registers pointers */
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+        break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+            break;
+    }
+
+    WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
+
+    return E_OK;
+}
+
+t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
+{
+    t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error                                 err = E_OK;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+    uint8_t                                 i;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+
+    TRY_LOCK_RET_ERR(p_FmPort->lock);
+
+    p_FmPort->h_FmPcd = FmGetPcdHandle(p_FmPort->h_Fm);
+    ASSERT_COND(p_FmPort->h_FmPcd);
+
+    if (FmPcdGetHcHandle(p_FmPort->h_FmPcd))
+    {
+        err = FmHcPortSetPCD(FmPcdGetHcHandle(p_FmPort->h_FmPcd), p_FmPort, p_PcdParams);
+        RELEASE_LOCK(p_FmPort->lock);
+        return err;
+    }
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+
+#else
+    err = FmPortSetPcd( h_FmPort, p_PcdParams);
+    if(err)
+    {
+        RELEASE_LOCK(p_FmPort->lock);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    if(p_FmPort->pcdEngines & FM_PCD_KG)
+    {
+        schemeBind.netEnvId = p_FmPort->netEnvId;
+        schemeBind.hardwarePortId = p_FmPort->hardwarePortId;
+        schemeBind.numOfSchemes = p_PcdParams->p_KgParams->numOfSchemes;
+        schemeBind.useClsPlan = p_PcdParams->p_KgParams->useClsPlan;
+        for(i = 0;i<schemeBind.numOfSchemes;i++)
+            schemeBind.schemesIds[i] = (uint8_t)(CAST_POINTER_TO_UINT32(p_PcdParams->p_KgParams->h_Schemes[i])-1);
+        err = FmPcdKgBindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
+        if(err)
+        {
+            FmPortDeletePcd(p_FmPort);
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+
+        err = FmPcdKgBindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, p_FmPort->clsPlanGrpId);
+        if(err)
+        {
+            FmPortDeletePcd(p_FmPort);
+            FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        }
+    }
+
+    if(( p_FmPort->pcdEngines & FM_PCD_PRS) && (p_PcdParams->p_PrsParams->includeInPrsStatistics))
+        FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, TRUE);
+
+    FmPcdIncNetEnvOwners(p_FmPort->h_FmPcd, p_FmPort->netEnvId);
+
+    err = FmPortAttachPCD(h_FmPort);
+
+    RELEASE_LOCK(p_FmPort->lock);
+
+    return err;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
+{
+    t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    t_Error                                 err = E_OK;
+    uint32_t                                walking1Mask = 0x80000000;
+    uint8_t                                 idx = 0;
+    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    if (FmPcdGetHcHandle(p_FmPort->h_FmPcd))
+        return FmHcPortDeletePCD(FmPcdGetHcHandle(p_FmPort->h_FmPcd), p_FmPort);
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+
+#else
+    if(p_FmPort->pcdEngines & FM_PCD_KG)
+    {
+        schemeBind.netEnvId = p_FmPort->netEnvId;
+        schemeBind.hardwarePortId = p_FmPort->hardwarePortId;
+
+        /* unbind all schemes */
+        schemeBind.numOfSchemes =0;
+        if(p_FmPort->schemesPerPortVector)
+        {
+            while (p_FmPort->schemesPerPortVector)
+            {
+                if(p_FmPort->schemesPerPortVector & walking1Mask)
+                {
+                    schemeBind.schemesIds[schemeBind.numOfSchemes] = idx;
+                    schemeBind.numOfSchemes++;
+                    p_FmPort->schemesPerPortVector &= ~walking1Mask;
+                }
+                walking1Mask >>= 1;
+                idx++;
+            }
+        }
+
+        ASSERT_COND(!p_FmPort->schemesPerPortVector);
+
+        err = FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+
+        FmPcdKgUnbindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId);
+    }
+
+    /* we do it anyway, instead of checking if included */
+    FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, FALSE);
+
+    err = FmPortDeletePcd( h_FmPort);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    FmPcdDecNetEnvOwners(p_FmPort->h_FmPcd, p_FmPort->netEnvId);
+
+    return E_OK;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+t_Error          FM_PORT_PcdKgModifyClsPlanGrp (t_Handle h_FmPort, bool useClsPlan, t_Handle h_NewClsPlanGrp)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error             err;
+    uint32_t            tmpHxs[FM_PCD_PRS_NUM_OF_HDRS];
+    int                 i = 0;
+    uint8_t             hdrNum;
+    volatile uint32_t   *p_BmiNia=NULL;
+
+    TRY_LOCK_RET_ERR(p_FmPort->lock);
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_VALUE);
+
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
+
+    /* get PCD registers pointers */
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+        break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+            break;
+    }
+
+    /* check that current NIA is BMI to BMI */
+    if((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
+
+    if (FmPcdGetHcHandle(p_FmPort->h_FmPcd))
+    {
+        err = FmHcPortPcdKgModifyClsPlanGrp(FmPcdGetHcHandle(p_FmPort->h_FmPcd), p_FmPort, useClsPlan, h_NewClsPlanGrp);
+        if(err)
+        {
+            RELEASE_LOCK(p_FmPort->lock);
+            return err;
+        }
+    }
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+    {
+        RELEASE_LOCK(p_FmPort->lock);
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+    }
+#else
+    else
+    {
+        /* deal with SW */
+        FmPortPcdKgSwUnbindClsPlanGrp(h_FmPort);
+
+        err = FmPortPcdKgSwBindClsPlanGrp(h_FmPort, useClsPlan, (uint8_t)(CAST_POINTER_TO_UINT32(h_NewClsPlanGrp)-1));
+        if(err)
+        {
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        }
+
+        /* deal with HW */
+        err = FmPcdKgBindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, p_FmPort->clsPlanGrpId);
+        if(err)
+        {
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        }
+    }
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+
+    /************************************/
+    /* Parser classification group plan parameters           */
+    /************************************/
+    /* stop before configuring */
+    WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, PRS_CAC_STOP);
+    /* wait for parser to be in idle state */
+    while(GET_UINT32(p_FmPort->p_FmPortPrsRegs->pcac) & PRS_CAC_ACTIVE) ;
+
+    /* set soft seq attachment register */
+    memset(tmpHxs, 0, FM_PCD_PRS_NUM_OF_HDRS*sizeof(uint32_t));
+
+    /* set protocol options */
+    for(i=0;p_FmPort->optArray[i];i++)
+        switch(p_FmPort->optArray[i])
+        {
+            case(ETH_BROADCAST):
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_ETH)
+                tmpHxs[hdrNum] = GET_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[hdrNum].softSeqAttach);
+                tmpHxs[hdrNum] &= PRS_HDR_ETH_BC_MASK;
+                tmpHxs[hdrNum] |= (i+1) << PRS_HDR_ETH_BC_SHIFT;
+                break;
+            case(ETH_MULTICAST):
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_ETH)
+                tmpHxs[hdrNum] = GET_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[hdrNum].softSeqAttach);
+                tmpHxs[hdrNum] &= PRS_HDR_ETH_MC_MASK;
+                tmpHxs[hdrNum] |= (i+1) << PRS_HDR_ETH_MC_SHIFT;
+                break;
+            case(VLAN_STACKED):
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_VLAN)
+                tmpHxs[hdrNum] = GET_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[hdrNum].softSeqAttach);
+                tmpHxs[hdrNum] &= PRS_HDR_VLAN_STACKED_MASK;
+                tmpHxs[hdrNum] |= (i+1)<< PRS_HDR_VLAN_STACKED_SHIFT;
+                break;
+            case(MPLS_STACKED):
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_MPLS)
+                tmpHxs[hdrNum] = GET_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[hdrNum].softSeqAttach);
+                tmpHxs[hdrNum] &= PRS_HDR_MPLS_STACKED_MASK;
+                tmpHxs[hdrNum] |= (i+1) << PRS_HDR_MPLS_STACKED_SHIFT;
+                break;
+            case(IPV4_BROADCAST_1):
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+                tmpHxs[hdrNum] = GET_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[hdrNum].softSeqAttach);
+                tmpHxs[hdrNum] &= PRS_HDR_IPV4_1_BC_MASK;
+                tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_1_BC_SHIFT;
+                break;
+            case(IPV4_MULTICAST_1):
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+                tmpHxs[hdrNum] = GET_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[hdrNum].softSeqAttach);
+                tmpHxs[hdrNum] &= PRS_HDR_IPV4_1_MC_MASK;
+                tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_1_MC_SHIFT;
+                break;
+            case(IPV4_UNICAST_2):
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+                tmpHxs[hdrNum] = GET_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[hdrNum].softSeqAttach);
+                tmpHxs[hdrNum] &= PRS_HDR_IPV4_2_UC_MASK;
+                tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_2_UC_SHIFT;
+                break;
+            case(IPV4_MULTICAST_BROADCAST_2):
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+                tmpHxs[hdrNum] = GET_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[hdrNum].softSeqAttach);
+                tmpHxs[hdrNum] &= PRS_HDR_IPV4_2_MC_BC_MASK;
+                tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_2_MC_BC_SHIFT;
+                break;
+            case(IPV6_MULTICAST_1):
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+                tmpHxs[hdrNum] = GET_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[hdrNum].softSeqAttach);
+                tmpHxs[hdrNum] &= PRS_HDR_IPV6_1_MC_MASK;
+                tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_1_MC_SHIFT;
+                break;
+            case(IPV6_UNICAST_2):
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+                tmpHxs[hdrNum] = GET_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[hdrNum].softSeqAttach);
+                tmpHxs[hdrNum] &= PRS_HDR_IPV6_2_UC_MASK;
+                tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_2_UC_SHIFT;
+                break;
+            case(IPV6_MULTICAST_2):
+                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+                tmpHxs[hdrNum] = GET_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[hdrNum].softSeqAttach);
+                tmpHxs[hdrNum] &= PRS_HDR_IPV6_2_MC_MASK;
+                tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_2_MC_SHIFT;
+                break;
+    }
+
+    for(i=0 ; i<FM_PCD_PRS_NUM_OF_HDRS ; i++)
+    {
+        /* For all header set LCV as taken from netEnv*/
+    //  WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[i].lcv,  FmPcdGetLcv(p_FmPort->h_FmPcd, p_FmPort->netEnvId, (uint8_t)i));
+        /* set HXS register according to default+Additional params+protocol options */
+        WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[i].softSeqAttach,  tmpHxs[i]);
+    }
+
+    /* enable parser */
+    WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, 0);
+
+    RELEASE_LOCK(p_FmPort->lock);
+
+    return E_OK;
+}
+
+t_Error       FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error                     err;
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+    int                                     i;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG , E_INVALID_STATE);
+
+    TRY_LOCK_RET_ERR(p_FmPort->lock);
+
+    if (FmPcdGetHcHandle(p_FmPort->h_FmPcd))
+    {
+        err = FmHcPortPcdKgBindSchemes(FmPcdGetHcHandle(p_FmPort->h_FmPcd), p_FmPort, p_PortScheme);
+        RELEASE_LOCK(p_FmPort->lock);
+        return err;
+    }
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+    {
+        RELEASE_LOCK(p_FmPort->lock);
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+    }
+
+#else
+    schemeBind.netEnvId = p_FmPort->netEnvId;
+    schemeBind.hardwarePortId = p_FmPort->hardwarePortId;
+    schemeBind.numOfSchemes = p_PortScheme->numOfSchemes;
+    schemeBind.useClsPlan = p_FmPort->useClsPlan;
+    for (i=0; i<schemeBind.numOfSchemes; i++)
+        schemeBind.schemesIds[i] = (uint8_t)(CAST_POINTER_TO_UINT32(p_PortScheme->h_Schemes[i])-1);
+
+    err = FmPcdKgBindPortToSchemes(h_FmPort, &schemeBind);
+    RELEASE_LOCK(p_FmPort->lock);
+    return err;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+t_Error       FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *p_PortScheme)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error                     err;
+
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+    int                                     i;
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG , E_INVALID_STATE);
+
+    if (FmPcdGetHcHandle(p_FmPort->h_FmPcd))
+    {
+        err = FmHcPortPcdKgUnbindSchemes(FmPcdGetHcHandle(p_FmPort->h_FmPcd), p_FmPort, p_PortScheme);
+        RELEASE_LOCK(p_FmPort->lock);
+        return err;
+    }
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+    else
+    {
+        RELEASE_LOCK(p_FmPort->lock);
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No HC obj. must have HC in guest partition!"));
+    }
+
+#else
+    schemeBind.netEnvId = p_FmPort->netEnvId;
+    schemeBind.hardwarePortId = p_FmPort->hardwarePortId;
+    schemeBind.numOfSchemes = p_PortScheme->numOfSchemes;
+    for (i=0; i<schemeBind.numOfSchemes; i++)
+        schemeBind.schemesIds[i] = (uint8_t)(CAST_POINTER_TO_UINT32(p_PortScheme->h_Schemes[i])-1);
+
+    err = FmPcdKgUnbindPortToSchemes(h_FmPort, &schemeBind);
+    RELEASE_LOCK(p_FmPort->lock);
+    return err;
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+}
+
+t_Error       FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_FmPcdPrsStart)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    volatile uint32_t   *p_BmiPrsStartOffset = NULL;
+    volatile uint32_t   *p_BmiNia = NULL;
+    uint8_t             hdrNum;
+    uint32_t            tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_PRS , E_INVALID_STATE);
+
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            tmpReg = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
+            break;
+        case(e_FM_PORT_TYPE_OFFLINE_PARSING):
+            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+            tmpReg = 0;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    }
+
+    TRY_LOCK_RET_ERR(p_FmPort->lock);
+    /* set the first header */
+    GET_PRS_HDR_NUM(hdrNum, p_FmPcdPrsStart->firstPrsHdr);
+    if (hdrNum == ILLEGAL_HDR_NUM)
+    {
+        RELEASE_LOCK(p_FmPort->lock);
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unsupported header."));
+    }
+    WRITE_UINT32(*p_BmiNia, (uint32_t)(NIA_ENG_PRS | (uint32_t)(hdrNum * PRS_HDR_ENTRY_SIZE) | tmpReg));
+
+    /* set start parsing offset */
+    WRITE_UINT32(*p_BmiPrsStartOffset, p_FmPcdPrsStart->parsingOffset);
+    RELEASE_LOCK(p_FmPort->lock);
+
+    return E_OK;
+}
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
+{
+    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPortQmiRegs *p_FmPortQmiRegs;
+    t_Error         err;
+    char            arr[30];
+    uint8_t         flag;
+    int             i=0;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortQmiRegs, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortBmiRegs, E_INVALID_HANDLE);
+
+    p_FmPortQmiRegs = p_FmPort->p_FmPortQmiRegs;
+
+    switch (p_FmPort->portType)
+    {
+        case (e_FM_PORT_TYPE_OFFLINE_PARSING):
+            strcpy(arr, "PORT_TYPE_OFFLINE_PARSING");
+            flag = 0;
+            break;
+        case (e_FM_PORT_TYPE_HOST_COMMAND):
+            strcpy(arr, "PORT_TYPE_HOST_COMMAND");
+            flag = 0;
+            break;
+        case (e_FM_PORT_TYPE_RX):
+            strcpy(arr, "PORT_TYPE_RX");
+            flag = 1;
+            break;
+        case (e_FM_PORT_TYPE_RX_10G):
+            strcpy(arr, "PORT_TYPE_RX_10G");
+            flag = 1;
+          break;
+        case (e_FM_PORT_TYPE_TX):
+            strcpy(arr, "PORT_TYPE_TX");
+            flag = 2;
+            break;
+        case (e_FM_PORT_TYPE_TX_10G):
+            strcpy(arr, "PORT_TYPE_TX_10G");
+            flag = 2;
+            break;
+        default:
+            return E_INVALID_VALUE;
+            break ;
+    }
+
+    DUMP_TITLE(p_FmPort->hardwarePortId, ("PortId for %s %d", arr, p_FmPort->portId ));
+    DUMP_TITLE(p_FmPort->p_FmPortBmiRegs, ("Bmi Port Regs"));
+
+    err = FmDumpPortRegs(p_FmPort->h_Fm, p_FmPort->hardwarePortId);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    switch(flag)
+    {
+        case(0):
+
+        DUMP_SUBTITLE(("\n"));
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ocfg);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ost);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oda);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofdne);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofne);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofca);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofpne);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opso);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_occb);
+
+        DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oprai), ("fmbm_oprai"));
+        DUMP_SUBSTRUCT_ARRAY(i, PRS_RESULT_NUM_OF_WORDS)
+        {
+            DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oprai[i]), sizeof(uint32_t));
+        }
+        DUMP_SUBTITLE(("\n"));
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofqid );
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oefqid);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofsdm );
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofsem );
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofene );
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_orlmts);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_orlmt);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ostc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofrc );
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofdc );
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofledc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofufdc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_offc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofwdc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofldec);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opcp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_occn);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_otuc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oduc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofuc);
+        break;
+    case(1):
+        DUMP_SUBTITLE(("\n"));
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rcfg);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rst);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rda);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfed);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_ricp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rebm);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfne);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfca);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfpne);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpso);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpp);
+
+        DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rprai), ("fmbm_rprai"));
+        DUMP_SUBSTRUCT_ARRAY(i, PRS_RESULT_NUM_OF_WORDS)
+        {
+            DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rprai[i]), sizeof(uint32_t));
+        }
+        DUMP_SUBTITLE(("\n"));
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfqid);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_refqid);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfsdm);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfsem);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfene);
+        DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi, ("fmbm_ebmpi"));
+        DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_MAX_NUM_OF_EXT_POOLS)
+        {
+            DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i], sizeof(uint32_t));
+        }
+        DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt, ("fmbm_acnt"));
+        DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_MAX_NUM_OF_EXT_POOLS)
+        {
+            DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt[i], sizeof(uint32_t));
+        }
+        DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_cgm, ("fmbm_cgm"));
+        DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_NUM_OF_CONGESTION_GRPS/32)
+        {
+            DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_cgm[i], sizeof(uint32_t));
+        }
+        DUMP_SUBTITLE(("\n"));
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_mpd);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rstc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfrc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfbc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rlfc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rffc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfcd);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfldec);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rodc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpcp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rccn);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rtuc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rrquc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rduc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfuc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpac);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rdbg);
+
+        break;
+    case(2):
+
+        DUMP_SUBTITLE(("\n"));
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tcfg);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tst);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tda);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfed);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_ticp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfne);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfca);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tcfqid);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfeqid);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfene);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_trlmts);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_trlmt);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tstc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfrc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfdc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfledc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfufdc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tpc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tpcp);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tccn);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_ttuc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_ttcquc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tduc);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfuc);
+
+        break;
+
+   default:
+        break;
+    }
+
+
+    DUMP_TITLE(p_FmPort->p_FmPortQmiRegs, ("Qmi Port Regs"));
+
+    DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pnc);
+    DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pns);
+    DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pnts);
+    DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pnen);
+    DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pnetfc);
+
+    if(flag !=1)
+    {
+        DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndn);
+        DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndc);
+        DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndtfc);
+        DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndfdc);
+        DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndcc);
+    }
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+/**********************************        Inter-module routines ********************************/
+
+t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPortRxBmiRegs   *p_Regs = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs;
+    bool                tmpArray[FM_PORT_NUM_OF_CONGESTION_GRPS];
+    int                 i;
+    uint8_t             mod;
+    uint32_t            tmpReg = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("available for Tx ports only"));
+
+    /* to minimize memory access (groups may belong to the same regsiter, and may
+    be out of order), we first collect all information into a 256 booleans array,
+    representing each possible group. */
+
+    memset(&tmpArray, 0, FM_PORT_NUM_OF_CONGESTION_GRPS*sizeof(bool));
+    for(i=0;i<p_CongestionGrps->numOfCongestionGrpsToConsider;i++)
+        tmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] = TRUE;
+
+    for(i=0;i<FM_PORT_NUM_OF_CONGESTION_GRPS;i++)
+    {
+        mod = (uint8_t)(i%32);
+        /* each 32 congestion groups are represented by a register */
+        if (mod == 0) /* first in a 32 bunch of congestion groups, get the currest register state  */
+            tmpReg = GET_UINT32(p_Regs->fmbm_cgm[7-i/32]);
+
+        /* set in the register, the bit representing the relevant congestion group. */
+        if(tmpArray[i])
+            tmpReg |=  (0x00000001 << mod);
+
+        if (mod == 31) /* last in a 32 bunch of congestion groups - write the corresponding register */
+            WRITE_UINT32(p_Regs->fmbm_cgm[7-i/32], tmpReg);
+    }
+
+    return  E_OK;
+
+}
+
+t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_CongestionGrps)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    t_FmPortRxBmiRegs   *p_Regs = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs;
+    bool                tmpArray[FM_PORT_NUM_OF_CONGESTION_GRPS];
+    int                 i;
+    uint8_t             mod;
+    uint32_t            tmpReg = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("available for Rx ports only"));
+
+    /* to minimize memory access (groups may belong to the same regsiter, and may
+    be out of order), we first collect all information into a 256 booleans array,
+    representing each possible group. */
+    memset(&tmpArray, 0, FM_PORT_NUM_OF_CONGESTION_GRPS*sizeof(bool));
+    for(i=0;i<p_CongestionGrps->numOfCongestionGrpsToConsider;i++)
+        tmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] = TRUE;
+
+    for(i=0;i<FM_PORT_NUM_OF_CONGESTION_GRPS;i++)
+    {
+        mod = (uint8_t)(i%32);
+        /* each 32 congestion groups are represented by a register */
+        if (mod == 0) /* first in a 32 bunch of congestion groups, get the currest register state  */
+            tmpReg = GET_UINT32(p_Regs->fmbm_cgm[7-i/32]);
+
+        /* set in the register, the bit representing the relevant congestion group. */
+        if(tmpArray[i])
+            tmpReg &=  ~(0x00000001 << mod);
+
+       if (mod == 31) /* last in a 32 bunch of congestion groups - write the corresponding register */
+        WRITE_UINT32(p_Regs->fmbm_cgm[7-i/32], tmpReg);
+    }
+
+    return  E_OK;
+
+}
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
new file mode 100644
index 0000000..3192d41
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
@@ -0,0 +1,784 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_port.h
+
+ @Description   FM Port internal structures and definitions.
+*//***************************************************************************/
+#ifndef __FM_PORT_H
+#define __FM_PORT_H
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "fm_port_ext.h"
+
+#include "fm_common.h"
+
+
+#define MIN_EXT_BUF_SIZE                                64
+/**************************************************************************//**
+ @Description       Memory Map defines
+*//***************************************************************************/
+#define BMI_PORT_REGS_OFFSET                            0
+#define QMI_PORT_REGS_OFFSET                            0x400
+#define PRS_PORT_REGS_OFFSET                            0x800
+
+/**************************************************************************//**
+ @Description       defaults
+*//***************************************************************************/
+
+#define DEFAULT_PORT_deqHighPriority                    FALSE
+#define DEFAULT_PORT_deqType                            e_FM_PORT_DEQ_TYPE1
+#define DEFAULT_PORT_deqPrefetchOption                  e_FM_PORT_DEQ_NO_PREFETCH
+#define DEFAULT_PORT_deqByteCnt                         2000
+#define DEFAULT_PORT_bufferPrefixContent_privDataSize   0
+#define DEFAULT_PORT_bufferPrefixContent_passPrsResult  TRUE
+#define DEFAULT_PORT_bufferPrefixContent_passTimeStamp  FALSE
+
+#define DEFAULT_PORT_cheksumLastBytesIgnore             0
+#define DEFAULT_PORT_cutBytesFromEnd                    4
+#define DEFAULT_PORT_txFifoMinFillLevel                 0
+#define DEFAULT_PORT_txFifoDeqPipelineDepth_1G          1
+#define DEFAULT_PORT_txFifoDeqPipelineDepth_10G         4
+#define DEFAULT_PORT_txFifoLowComfLevel                 (5*KILOBYTE)
+#define DEFAULT_PORT_rxFifoPriElevationLevel            (160*KILOBYTE)
+#define DEFAULT_PORT_rxFifoThreshold                    (128*KILOBYTE)
+#define DEFAULT_PORT_frmDiscardOverride                 FALSE
+#define DEFAULT_PORT_dmaSwapData                        e_FM_PORT_DMA_NO_SWP
+#define DEFAULT_PORT_dmaIntContextCacheAttr             e_FM_PORT_DMA_NO_STASH
+#define DEFAULT_PORT_dmaHeaderCacheAttr                 e_FM_PORT_DMA_NO_STASH
+#define DEFAULT_PORT_dmaScatterGatherCacheAttr          e_FM_PORT_DMA_NO_STASH
+#define DEFAULT_PORT_dmaReadOptimize                    FALSE
+#define DEFAULT_PORT_dmaWriteOptimize                   FALSE
+#define DEFAULT_PORT_forwardIntContextReuse             FALSE
+#define DEFAULT_PORT_l4Checksum                         TRUE
+#define DEFAULT_PORT_BufMargins_startMargins            32
+#define DEFAULT_PORT_BufMargins_endMargins              0
+#define DEFAULT_PORT_syncReq                            TRUE
+#define DEFAULT_PORT_color                              e_FM_PORT_COLOR_GREEN
+#define DEFAULT_PORT_errorsToDiscard                    0
+
+/* Host command port MUST NOT be changed to more than 1 !!! */
+#define DEFAULT_PORT_numOfTasks(type)                   \
+    (uint32_t)(((type == e_FM_PORT_TYPE_RX_10G) ||      \
+                (type == e_FM_PORT_TYPE_TX_10G)) ? 16 : \
+               (((type == e_FM_PORT_TYPE_RX) ||         \
+                 (type == e_FM_PORT_TYPE_TX) ||         \
+                 (type == e_FM_PORT_TYPE_OFFLINE_PARSING)) ? 3 : 1))
+
+#define DEFAULT_PORT_extraNumOfTasks(type)              \
+    (uint32_t)(((type == e_FM_PORT_TYPE_RX_10G) ||      \
+                (type == e_FM_PORT_TYPE_TX_10G)) ? 8 :  \
+               (((type == e_FM_PORT_TYPE_RX) ||         \
+                 (type == e_FM_PORT_TYPE_TX) ||         \
+                 (type == e_FM_PORT_TYPE_OFFLINE_PARSING)) ? 2 : 0))
+
+#define DEFAULT_PORT_numOfOpenDmas(type)                \
+    (uint32_t)(((type == e_FM_PORT_TYPE_RX_10G) ||      \
+                (type == e_FM_PORT_TYPE_TX_10G)) ? 4 : 1)
+
+#define DEFAULT_PORT_extraNumOfOpenDmas(type)           \
+    (uint32_t)(((type == e_FM_PORT_TYPE_RX_10G) ||      \
+                (type == e_FM_PORT_TYPE_TX_10G)) ? 8 :  \
+               (((type == e_FM_PORT_TYPE_RX) ||         \
+                 (type == e_FM_PORT_TYPE_TX) ||         \
+                 (type == e_FM_PORT_TYPE_OFFLINE_PARSING)) ? 1 : 0))
+
+#define DEFAULT_PORT_sizeOfFifo(type)                               \
+    (uint32_t)(((type == e_FM_PORT_TYPE_RX_10G) ||                  \
+                (type == e_FM_PORT_TYPE_TX_10G)) ? (16*KILOBYTE) :  \
+               (((type == e_FM_PORT_TYPE_RX) ||                     \
+                 (type == e_FM_PORT_TYPE_TX) ||                     \
+                 (type == e_FM_PORT_TYPE_OFFLINE_PARSING)) ? (4*KILOBYTE) : (1*KILOBYTE)))
+
+#define DEFAULT_PORT_extraSizeOfFifo(type)              \
+    (uint32_t)(((type == e_FM_PORT_TYPE_RX_10G) ||      \
+                (type == e_FM_PORT_TYPE_RX)) ? (16*KILOBYTE) : 0)
+
+#define DEFAULT_PORT_ImMaxRxBufLength               1024
+#define DEFAULT_PORT_txBdRingLength                 16
+#define DEFAULT_PORT_rxBdRingLength                 128
+#define DEFAULT_PORT_ImfwExtStructsMemId            0
+#define DEFAULT_PORT_Im_fwExtStructsMemAttr         MEMORY_ATTR_CACHEABLE
+
+
+/**************************************************************************//**
+ @Description       Memory Mapped Registers
+*//***************************************************************************/
+
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+
+typedef _Packed struct
+{
+    volatile uint32_t   fmbm_rcfg;      /**< Rx Configuration */
+    volatile uint32_t   fmbm_rst;       /**< Rx Status */
+    volatile uint32_t   fmbm_rda;       /**< Rx DMA attributes*/
+    volatile uint32_t   fmbm_rfp;       /**< Rx FIFO Parameters*/
+    volatile uint32_t   fmbm_rfed;      /**< Rx Frame End Data*/
+    volatile uint32_t   fmbm_ricp;      /**< Rx Internal Context Parameters*/
+    volatile uint32_t   fmbm_rim;       /**< Rx Internal Buffer Margins*/
+    volatile uint32_t   fmbm_rebm;      /**< Rx External Buffer Margins*/
+    volatile uint32_t   fmbm_rfne;      /**< Rx Frame Next Engine*/
+    volatile uint32_t   fmbm_rfca;      /**< Rx Frame Command Attributes.*/
+    volatile uint32_t   fmbm_rfpne;     /**< Rx Frame Parser Next Engine*/
+    volatile uint32_t   fmbm_rpso;      /**< Rx Parse Start Offset*/
+    volatile uint32_t   fmbm_rpp;       /**< Rx Policer Profile  */
+    volatile uint32_t   fmbm_rccb;      /**< Rx Coarse Classification Base */
+    volatile uint32_t   reserved1[2];   /**< (0x038 0x03F) */
+    volatile uint32_t   fmbm_rprai[PRS_RESULT_NUM_OF_WORDS];
+                                        /**< Rx Parse Results Array Initialization*/
+    volatile uint32_t   fmbm_rfqid;     /**< Rx Frame Queue ID*/
+    volatile uint32_t   fmbm_refqid;    /**< Rx Error Frame Queue ID*/
+    volatile uint32_t   fmbm_rfsdm;     /**< Rx Frame Status Discard Mask*/
+    volatile uint32_t   fmbm_rfsem;     /**< Rx Frame Status Error Mask*/
+    volatile uint32_t   fmbm_rfene;     /**< Rx Frame Enqueue Next Engine */
+    volatile uint32_t   reserved2[0x23];/**< (0x074 0x0FF)  */
+    volatile uint32_t   fmbm_ebmpi[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+                                        /**< Buffer Manager pool Information-*/
+    volatile uint32_t   fmbm_acnt[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+                                        /**< Allocate Counter-*/
+    volatile uint32_t   reserved3[8];
+                                        /**< 0x140 - 0x15F reserved -*/
+    volatile uint32_t   fmbm_cgm[FM_PORT_NUM_OF_CONGESTION_GRPS/32];
+                                        /**< Congestion Group Map*/
+    volatile uint32_t   fmbm_mpd;       /**< BM Pool Depletion  */
+    volatile uint32_t   reserved4[0x1F];/**< (0x184 0x1FF) */
+    volatile uint32_t   fmbm_rstc;      /**< Rx Statistics Counters*/
+    volatile uint32_t   fmbm_rfrc;      /**< Rx Frame Counter*/
+    volatile uint32_t   fmbm_rfbc;      /**< Rx Bad Frames Counter*/
+    volatile uint32_t   fmbm_rlfc;      /**< Rx Large Frames Counter*/
+    volatile uint32_t   fmbm_rffc;      /**< Rx Filter Frames Counter*/
+    volatile uint32_t   fmbm_rfcd;      /**< Rx Frame Discard Counter*/
+    volatile uint32_t   fmbm_rfldec;    /**< Rx Frames List DMA Error Counter*/
+    volatile uint32_t   fmbm_rodc;      /**< Rx Out of Buffers Discard Counter-*/
+    volatile uint32_t   fmbm_rbdc;      /**< Rx Buffers Deallocate Counter-*/
+    volatile uint32_t   reserved5[0x17];/**< (0x224 0x27F) */
+    volatile uint32_t   fmbm_rpc;       /**< Rx Performance Counters*/
+    volatile uint32_t   fmbm_rpcp;      /**< Rx Performance Count Parameters*/
+    volatile uint32_t   fmbm_rccn;      /**< Rx Cycle Counter*/
+    volatile uint32_t   fmbm_rtuc;      /**< Rx Tasks Utilization Counter*/
+    volatile uint32_t   fmbm_rrquc;     /**< Rx Receive Queue Utilization Counter*/
+    volatile uint32_t   fmbm_rduc;      /**< Rx DMA Utilization Counter*/
+    volatile uint32_t   fmbm_rfuc;      /**< Rx FIFO Utilization Counter*/
+    volatile uint32_t   fmbm_rpac;      /**< Rx Pause Activation Counter-*/
+    volatile uint32_t   reserved6[0x18];/**< (0x2A0 0x2FF) */
+    volatile uint32_t   fmbm_rdbg;      /**< Rx Debug-*/
+} _PackedType t_FmPortRxBmiRegs;
+
+typedef _Packed struct
+{
+    volatile uint32_t   fmbm_tcfg;      /**< Tx Configuration */
+    volatile uint32_t   fmbm_tst;       /**< Tx Status */
+    volatile uint32_t   fmbm_tda;       /**< Tx DMA attributes */
+    volatile uint32_t   fmbm_tfp;       /**< Tx FIFO Parameters */
+    volatile uint32_t   fmbm_tfed;      /**< Tx Frame End Data */
+    volatile uint32_t   fmbm_ticp;      /**< Tx Internal Context Parameters */
+    volatile uint32_t   fmbm_tfne;      /**< Tx Frame Next Engine. */
+    volatile uint32_t   fmbm_tfca;      /**< Tx Frame Command attribute. */
+    volatile uint32_t   fmbm_tcfqid;    /**< Tx Confirmation Frame Queue ID. */
+    volatile uint32_t   fmbm_tfeqid;    /**< Tx Frame Error Queue ID */
+    volatile uint32_t   fmbm_tfene;     /**< Tx Frame Enqueue Next Engine */
+    volatile uint32_t   fmbm_trlmts;    /**< Tx Rate Limiter Scale */
+    volatile uint32_t   fmbm_trlmt;     /**< Tx Rate Limiter */
+    volatile uint32_t   reserved0[0x73];/**< (0x038-0x200) */
+    volatile uint32_t   fmbm_tstc;      /**< Tx Statistics Counters */
+    volatile uint32_t   fmbm_tfrc;      /**< Tx Frame Counter */
+    volatile uint32_t   fmbm_tfdc;      /**< Tx Frames Discard Counter */
+    volatile uint32_t   fmbm_tfledc;    /**< Tx Frame Length error discard counter */
+    volatile uint32_t   fmbm_tfufdc;    /**< Tx Frame unsupported format discard Counter */
+    volatile uint32_t   fmbm_tbdc;      /**< Tx Buffers Deallocate Counter */
+    volatile uint32_t   reserved1[0x1A];/**< (0x218-0x280) */
+    volatile uint32_t   fmbm_tpc;       /**< Tx Performance Counters*/
+    volatile uint32_t   fmbm_tpcp;      /**< Tx Performance Count Parameters*/
+    volatile uint32_t   fmbm_tccn;      /**< Tx Cycle Counter*/
+    volatile uint32_t   fmbm_ttuc;      /**< Tx Tasks Utilization Counter*/
+    volatile uint32_t   fmbm_ttcquc;    /**< Tx Transmit Confirm Queue Utilization Counter*/
+    volatile uint32_t   fmbm_tduc;      /**< Tx DMA Utilization Counter*/
+    volatile uint32_t   fmbm_tfuc;      /**< Tx FIFO Utilization Counter*/
+} _PackedType t_FmPortTxBmiRegs;
+
+typedef _Packed struct
+{
+    volatile uint32_t   fmbm_ocfg;      /**< O/H Configuration  */
+    volatile uint32_t   fmbm_ost;       /**< O/H Status */
+    volatile uint32_t   fmbm_oda;       /**< O/H DMA attributes  */
+    volatile uint32_t   fmbm_oicp;      /**< O/H Internal Context Parameters  */
+    volatile uint32_t   fmbm_ofdne;     /**< O/H Frame Dequeue Next Engine  */
+    volatile uint32_t   fmbm_ofne;      /**< O/H Frame Next Engine  */
+    volatile uint32_t   fmbm_ofca;      /**< O/H Frame Command Attributes.  */
+    volatile uint32_t   fmbm_ofpne;     /**< O/H Frame Parser Next Engine  */
+    volatile uint32_t   fmbm_opso;      /**< O/H Parse Start Offset  */
+    volatile uint32_t   fmbm_opp;       /**< O/H Policer Profile */
+    volatile uint32_t   fmbm_occb;      /**< O/H Coarse Classification base */
+    volatile uint32_t   fmbm_oim;       /**< O/H Internal margins*/
+    volatile uint32_t   reserved0[4];   /**< (0x030 - 0x03F) */
+    volatile uint32_t   fmbm_oprai[PRS_RESULT_NUM_OF_WORDS];
+                                        /**< O/H Parse Results Array Initialization  */
+    volatile uint32_t   fmbm_ofqid;     /**< O/H Frame Queue ID  */
+    volatile uint32_t   fmbm_oefqid;    /**< O/H Error Frame Queue ID  */
+    volatile uint32_t   fmbm_ofsdm;     /**< O/H Frame Status Discard Mask  */
+    volatile uint32_t   fmbm_ofsem;     /**< O/H Frame Status Error Mask  */
+    volatile uint32_t   fmbm_ofene;     /**< O/H Frame Enqueue Next Engine  */
+    volatile uint32_t   fmbm_orlmts;    /**< O/H Rate Limiter Scale  */
+    volatile uint32_t   fmbm_orlmt;     /**< O/H Rate Limiter  */
+    volatile uint32_t   reserved1[0x61];/**< (0x07C - 0x1FF) */
+    volatile uint32_t   fmbm_ostc;      /**< O/H Statistics Counters  */
+    volatile uint32_t   fmbm_ofrc;      /**< O/H Frame Counter  */
+    volatile uint32_t   fmbm_ofdc;      /**< O/H Frames Discard Counter  */
+    volatile uint32_t   fmbm_ofledc;    /**< O/H Frames Length Error Discard Counter  */
+    volatile uint32_t   fmbm_ofufdc;    /**< O/H Frames Unsupported Format Discard Counter  */
+    volatile uint32_t   fmbm_offc;      /**< O/H Filter Frames Counter  */
+    volatile uint32_t   fmbm_ofwdc;     /**< - Rx Frames WRED Discard Counter  */
+    volatile uint32_t   fmbm_ofldec;    /**< O/H Frames List DMA Error Counter */
+    volatile uint32_t   fmbm_obdc;      /**< O/H Buffers Deallocate Counter */
+    volatile uint32_t   reserved2[0x17];/**< (0x218 - 0x27F) */
+    volatile uint32_t   fmbm_opc;       /**< O/H Performance Counters  */
+    volatile uint32_t   fmbm_opcp;      /**< O/H Performance Count Parameters  */
+    volatile uint32_t   fmbm_occn;      /**< O/H Cycle Counter  */
+    volatile uint32_t   fmbm_otuc;      /**< O/H Tasks Utilization Counter  */
+    volatile uint32_t   fmbm_oduc;      /**< O/H DMA Utilization Counter */
+    volatile uint32_t   fmbm_ofuc;      /**< O/H FIFO Utilization Counter */
+} _PackedType t_FmPortOhBmiRegs;
+
+typedef _Packed union
+{
+    t_FmPortRxBmiRegs rxPortBmiRegs;
+    t_FmPortTxBmiRegs txPortBmiRegs;
+    t_FmPortOhBmiRegs ohPortBmiRegs;
+} _PackedType u_FmPortBmiRegs;
+
+typedef _Packed struct
+{
+    volatile uint32_t   reserved1[2];   /**<   0xn024 - 0x02B */
+    volatile uint32_t   fmqm_pndn;      /**<   PortID n Dequeue NIA Register */
+    volatile uint32_t   fmqm_pndc;      /**<   PortID n Dequeue Config Register */
+    volatile uint32_t   fmqm_pndtfc;    /**<   PortID n Dequeue Total Frame Counter */
+    volatile uint32_t   fmqm_pndfdc;    /**<   PortID n Dequeue FQID from Default Counter */
+    volatile uint32_t   fmqm_pndcc;     /**<   PortID n Dequeue Confirm Counter */
+} _PackedType t_FmPortNonRxQmiRegs;
+
+typedef _Packed struct
+{
+    volatile uint32_t   fmqm_pnc;       /**<   PortID n Configuration Register */
+    volatile uint32_t   fmqm_pns;       /**<   PortID n Status Register */
+    volatile uint32_t   fmqm_pnts;      /**<   PortID n Task Status Register */
+    volatile uint32_t   reserved0[4];   /**<   0xn00C - 0xn01B */
+    volatile uint32_t   fmqm_pnen;      /**<   PortID n Enqueue NIA Register */
+    volatile uint32_t   fmqm_pnetfc;    /**<   PortID n Enqueue Total Frame Counter */
+    t_FmPortNonRxQmiRegs    nonRxQmiRegs;  /**<   Registers for Tx Hc & Op ports */
+} _PackedType t_FmPortQmiRegs;
+
+typedef _Packed struct
+{
+    struct
+    {
+        volatile uint32_t   softSeqAttach;  /**<   Soft Sequence Attachment */
+        volatile uint32_t   lcv;            /**<   Line-up Enable Confirmation Mask */
+    } hdrs[FM_PCD_PRS_NUM_OF_HDRS];
+    volatile uint8_t    reserved0[0x378];
+    volatile uint32_t   pcac;               /**<   Parse Internal Memory Configuration Access Control Register */
+    volatile uint32_t   pctpid;             /**<   Parse Internal Memory Configured TPID Register */
+} _PackedType t_FmPortPrsRegs;
+
+/**************************************************************************//*
+ @Description   Basic buffer descriptor (BD) structure
+*//***************************************************************************/
+typedef _Packed struct
+{
+    volatile uint16_t       status;
+    volatile uint16_t       length;
+    volatile uint8_t        reserved0[0x6];
+    volatile t_FmPhysAddr   buff;
+} _PackedType t_FmImBd;
+
+typedef _Packed struct
+{
+    volatile uint16_t       gen;                /**< tbd */
+    volatile t_FmPhysAddr   bdRingBase;         /**< tbd */
+    volatile uint16_t       bdRingSize;         /**< tbd */
+    volatile uint16_t       offsetIn;           /**< tbd */
+    volatile uint16_t       offsetOut;          /**< tbd */
+    volatile uint8_t        reserved0[0x12];    /**< 0x0e - 0x1f */
+} _PackedType t_FmPortImQd;
+
+typedef _Packed struct
+{
+    volatile uint32_t   mode;               /**< Mode register */
+    volatile uint32_t   rxQdPtr;            /**< tbd */
+    volatile uint32_t   txQdPtr;            /**< tbd */
+    volatile uint16_t   mrblr;              /**< tbd */
+    volatile uint16_t   rxQdBsyCnt;         /**< tbd */
+    volatile uint8_t    reserved0[0x10];    /**< 0x10 - 0x1f */
+    t_FmPortImQd        rxQd;
+    t_FmPortImQd        txQd;
+    volatile uint8_t    reserved1[0xa0];    /**< 0x10 - 0x1f */
+} _PackedType t_FmPortImPram;
+
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
+
+/**************************************************************************//**
+ @Description       Registers bit fields
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description       BMI defines
+*//***************************************************************************/
+#define BMI_PORT_CFG_EN                         0x80000000
+#define BMI_PORT_CFG_FDOVR                      0x02000000
+#define BMI_PORT_CFG_IM                         0x01000000
+#define BMI_PORT_STATUS_BSY                     0x80000000
+#define BMI_COUNTERS_EN                         0x80000000
+#define BMI_DMA_ATTR_READ_OPTIMIZE              0x00400000
+#define BMI_DMA_ATTR_WRITE_OPTIMIZE             0x00100000
+#define BMI_PORT_RFNE_FRWD_DCL4C                0x10000000
+#define BMI_PORT_RFNE_FRWD_RPD                  0x40000000
+#define BMI_RFNE_FDCS_MASK                      0xFF000000
+
+#define BMI_CMD_MR_LEAC                         0x00200000
+#define BMI_CMD_MR_SLEAC                        0x00100000
+#define BMI_CMD_MR_MA                           0x00080000
+#define BMI_CMD_MR_DEAS                         0x00040000
+#define BMI_CMD_TX_MR_DEF                       (0)
+#define BMI_CMD_RX_MR_DEF                       (BMI_CMD_MR_LEAC | BMI_CMD_MR_SLEAC | BMI_CMD_MR_MA | BMI_CMD_MR_DEAS)
+#define BMI_CMD_ATTR_ORDER                      0x80000000
+#define BMI_CMD_ATTR_SYNC                       0x02000000
+
+#define BMI_EXT_BUF_POOL_VALID                  0x80000000
+#define BMI_EXT_BUF_POOL_EN_COUNTER             0x40000000
+#define BMI_EXT_BUF_POOL_ID_MASK                0x003F0000
+#define BMI_STATUS_RX_MASK_UNUSED               (uint32_t)(~(FM_PORT_FRM_ERR_DMA|\
+                                                FM_PORT_FRM_ERR_PHYSICAL        |\
+                                                FM_PORT_FRM_ERR_SIZE            |\
+                                                FM_PORT_FRM_ERR_CLS_DISCARD     |\
+                                                FM_PORT_FRM_ERR_EXTRACTION      |\
+                                                FM_PORT_FRM_ERR_NO_SCHEME       |\
+                                                FM_PORT_FRM_ERR_COLOR_RED       |\
+                                                FM_PORT_FRM_ERR_COLOR_YELLOW    |\
+                                                FM_PORT_FRM_ERR_ILL_PLCR        |\
+                                                FM_PORT_FRM_ERR_PLCR_FRAME_LEN  |\
+                                                FM_PORT_FRM_ERR_PRS_TIMEOUT     |\
+                                                FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT|\
+                                                FM_PORT_FRM_ERR_PRS_HDR_ERR     |\
+                                                FM_PORT_FRM_ERR_PROCESS_TIMEOUT |\
+                                                FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW))
+
+#define BMI_STATUS_OP_MASK_UNUSED               (uint32_t)(BMI_STATUS_RX_MASK_UNUSED    &\
+                                                ~(FM_PORT_FRM_ERR_LENGTH                |\
+                                                  FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT))
+
+#define BMI_RATE_LIMIT_EN                       0x80000000
+#define BMI_PRS_RESULT_HIGH                     0x00000000
+#define BMI_PRS_RESULT_LOW                      0xFFFFFFFF
+
+#define RX_ERRS_TO_ENQ                      (FM_PORT_FRM_ERR_DMA             |\
+                                                         FM_PORT_FRM_ERR_PHYSICAL        |\
+                                                         FM_PORT_FRM_ERR_SIZE            |\
+                                                         FM_PORT_FRM_ERR_CLS_DISCARD     |\
+                                                         FM_PORT_FRM_ERR_EXTRACTION      |\
+                                                         FM_PORT_FRM_ERR_NO_SCHEME       |\
+                                                         FM_PORT_FRM_ERR_COLOR_RED       |\
+                                                         FM_PORT_FRM_ERR_ILL_PLCR        |\
+                                                         FM_PORT_FRM_ERR_PLCR_FRAME_LEN  |\
+                                                         FM_PORT_FRM_ERR_PRS_TIMEOUT     |\
+                                                         FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT|\
+                                                         FM_PORT_FRM_ERR_PRS_HDR_ERR     |\
+                                                         FM_PORT_FRM_ERR_PROCESS_TIMEOUT |\
+                                                         FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW)
+
+#define OP_ERRS_TO_ENQ                      (RX_ERRS_TO_ENQ      |\
+                                                         FM_PORT_FRM_ERR_LENGTH          |\
+                                                         FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT)
+
+/* shifts */
+#define BMI_DMA_ATTR_SWP_SHIFT                  30
+#define BMI_DMA_ATTR_IC_CACHE_SHIFT             28
+#define BMI_DMA_ATTR_HDR_CACHE_SHIFT            26
+#define BMI_DMA_ATTR_SG_CACHE_SHIFT             24
+
+#define BMI_RIM_FOF_SHIFT                       28
+#define BMI_PR_PORTID_SHIFT                     24
+
+#define BMI_RX_FIFO_PRI_ELEVATION_SHIFT         16
+#define BMI_RX_FIFO_THRESHOLD_SHIFT             0
+
+#define BMI_RX_FRAME_END_CS_IGNORE_SHIFT        24
+#define BMI_RX_FRAME_END_CUT_SHIFT              16
+
+#define BMI_IC_TO_EXT_SHIFT                     16
+#define BMI_IC_FROM_INT_SHIFT                   8
+#define BMI_IC_SIZE_SHIFT                       0
+
+#define BMI_INT_BUF_MARG_SHIFT                  28
+
+#define BMI_EXT_BUF_MARG_START_SHIFT            16
+#define BMI_EXT_BUF_MARG_END_SHIFT              0
+
+#define BMI_CMD_ATTR_COLOR_SHIFT                26
+#define BMI_CMD_ATTR_COM_MODE_SHIFT             16
+
+#define BMI_POOL_DEP_NUM_OF_POOLS_SHIFT         16
+#define BMI_POOL_DEP_NUM_OF_POOLS_VECTOR_SHIFT  24
+
+#define BMI_EXT_BUF_POOL_ID_SHIFT               16
+
+#define BMI_TX_FIFO_MIN_FILL_SHIFT              16
+#define BMI_TX_FIFO_PIPELINE_DEPTH_SHIFT        12
+#define BMI_TX_LOW_COMF_SHIFT                   0
+
+#define BMI_TX_FRAME_END_CS_IGNORE_SHIFT        24
+
+#define BMI_PERFORMANCE_TASK_COMP_SHIFT         24
+#define BMI_PERFORMANCE_PORT_COMP_SHIFT         16
+#define BMI_PERFORMANCE_DMA_COMP_SHIFT          12
+#define BMI_PERFORMANCE_FIFO_COMP_SHIFT         0
+
+#define BMI_MAX_BURST_SHIFT                     16
+#define BMI_COUNT_RATE_UNIT_SHIFT               16
+
+/* sizes */
+#define FRAME_END_DATA_SIZE                     16
+#define OFFSET_UNITS                            16
+#define FRAME_OFFSET_UNITS                      16
+#define MAX_EXT_OFFSET                          496
+#define MAX_EXT_BUFFER_OFFSET                   511
+#define MAX_INT_OFFSET                          240
+#define MIN_TX_INT_OFFSET                       32
+#define MAX_IC_SIZE                             256
+#define MAX_FRAME_OFFSET                        64
+#define MAX_FIFO_PIPELINE_DEPTH                 8
+#define MAX_PERFORMANCE_TASK_COMP               64
+#define MAX_PERFORMANCE_TX_QUEUE_COMP           8
+#define MAX_PERFORMANCE_RX_QUEUE_COMP           64
+#define MAX_PERFORMANCE_DMA_COMP                16
+#define MAX_NUM_OF_TASKS                        64
+#define MAX_NUM_OF_EXTRA_TASKS                  8
+#define MAX_NUM_OF_DMAS                         16
+#define MAX_NUM_OF_EXTRA_DMAS                   8
+#define MAX_BURST_SIZE                          1024
+
+/**************************************************************************//**
+ @Description       QMI defines
+*//***************************************************************************/
+/* masks */
+#define QMI_PORT_CFG_EN                         0x80000000
+#define QMI_PORT_CFG_EN_COUNTERS                0x10000000
+#define QMI_PORT_STATUS_DEQ_TNUM_BSY            0x80000000
+#define QMI_PORT_STATUS_DEQ_FD_BSY              0x20000000
+
+#define QMI_DEQ_CFG_PREFETCH_NO_TNUM            0x02000000
+#define QMI_DEQ_CFG_PREFETCH_WAITING_TNUM       0
+#define QMI_DEQ_CFG_PREFETCH_1_FRAME            0
+#define QMI_DEQ_CFG_PREFETCH_3_FRAMES           0x01000000
+
+#define QMI_DEQ_CFG_PRI                         0x80000000
+#define QMI_DEQ_CFG_TYPE1                       0x10000000
+#define QMI_DEQ_CFG_TYPE2                       0x20000000
+#define QMI_DEQ_CFG_TYPE3                       0x30000000
+
+#define QMI_DEQ_CFG_SUBPORTAL_SHIFT             20
+
+/* sizes */
+#define MAX_QMI_DEQ_SUBPORTAL                   15
+
+/**************************************************************************//**
+ @Description       PARSER defines
+*//***************************************************************************/
+/* masks */
+#define PRS_HDR_ERROR_DIS                       0x00000800
+#define PRS_HDR_SW_PRS_EN                       0x00000400
+#define PRS_CP_OFFSET_MASK                      0x0000000F
+#define PRS_TPID1_MASK                          0xFFFF0000
+#define PRS_TPID2_MASK                          0x0000FFFF
+#define PRS_TPID_DFLT                           0x91009100
+
+#define PRS_HDR_MPLS_LBL_INTER_EN               0x00200000
+#define PRS_HDR_IPV6_ROUTE_HDR_DIS              0x00008000
+#define PRS_HDR_UDP_PAD_REMOVAL                 0x80000000
+#define PRS_HDR_TCP_PAD_REMOVAL                 0x80000000
+#define PRS_CAC_STOP                            0x00000001
+#define PRS_CAC_ACTIVE                          0x00000100
+
+/* shifts */
+#define PRS_PCTPID_SHIFT                        16
+#define PRS_HDR_MPLS_NEXT_HDR_SHIFT             22
+#define PRS_HDR_ETH_BC_SHIFT                    28
+#define PRS_HDR_ETH_MC_SHIFT                    24
+#define PRS_HDR_VLAN_STACKED_SHIFT              16
+#define PRS_HDR_MPLS_STACKED_SHIFT              16
+#define PRS_HDR_IPV4_1_BC_SHIFT                 28
+#define PRS_HDR_IPV4_1_MC_SHIFT                 24
+#define PRS_HDR_IPV4_2_UC_SHIFT                 20
+#define PRS_HDR_IPV4_2_MC_BC_SHIFT              16
+#define PRS_HDR_IPV6_1_MC_SHIFT                 24
+#define PRS_HDR_IPV6_2_UC_SHIFT                 20
+#define PRS_HDR_IPV6_2_MC_SHIFT                 16
+
+#define PRS_HDR_ETH_BC_MASK                     0x0fffffff
+#define PRS_HDR_ETH_MC_MASK                     0xf0ffffff
+#define PRS_HDR_VLAN_STACKED_MASK               0xfff0ffff
+#define PRS_HDR_MPLS_STACKED_MASK               0xfff0ffff
+#define PRS_HDR_IPV4_1_BC_MASK                  0x0fffffff
+#define PRS_HDR_IPV4_1_MC_MASK                  0xf0ffffff
+#define PRS_HDR_IPV4_2_UC_MASK                  0xff0fffff
+#define PRS_HDR_IPV4_2_MC_BC_MASK               0xfff0ffff
+#define PRS_HDR_IPV6_1_MC_MASK                  0xf0ffffff
+#define PRS_HDR_IPV6_2_UC_MASK                  0xff0fffff
+#define PRS_HDR_IPV6_2_MC_MASK                  0xfff0ffff
+
+/* others */
+#define PRS_HDR_ENTRY_SIZE                      8
+#define DEFAULT_CLS_PLAN_VECTOR                 0xFFFFFFFF
+
+#define IPSEC_SW_PATCH_START                    0x20
+#define SCTP_SW_PATCH_START                     0x4D
+#define DCCP_SW_PATCH_START                     0x41
+
+/**************************************************************************//**
+ @Description       IM defines
+*//***************************************************************************/
+#define BD_R_E                                  0x80000000
+#define BD_L                                    0x08000000
+
+#define BD_RX_CRE                               0x00080000
+#define BD_RX_FTL                               0x00040000
+#define BD_RX_FTS                               0x00020000
+#define BD_RX_OV                                0x00010000
+
+#define BD_RX_ERRORS                            (BD_RX_CRE | BD_RX_FTL | BD_RX_FTS | BD_RX_OV)
+#define BD_ERROR_PASS_FRAME                     BD_RX_ERRORS
+
+#define FM_IM_SIZEOF_BD                         sizeof(t_FmImBd)
+
+#define BD_STATUS_MASK                          0xffff0000
+#define BD_LENGTH_MASK                          0x0000ffff
+
+#define BD_STATUS_AND_LENGTH_SET(bd, val)       WRITE_UINT32(*(volatile uint32_t*)(bd), (val))
+
+#define BD_STATUS_AND_LENGTH(bd)                GET_UINT32(*(volatile uint32_t*)(bd))
+
+#define BD_GET(id)                              &p_FmPort->im.p_BdRing[id]
+
+#define IM_ILEGAL_BD_ID                         0xffff
+
+/* others */
+#define IM_PRAM_ALIGN                           0x100
+
+/* masks */
+#define IM_MODE_GBL                             0x20000000
+
+
+typedef struct {
+    t_Handle                    h_App;
+    t_Handle                    h_FmMuram;
+    t_FmPortImPram              *p_FmPortImPram;
+    uint8_t                     fwExtStructsMemId;
+    uint32_t                    fwExtStructsMemAttr;
+    uint16_t                    bdRingSize;
+    t_FmImBd                    *p_BdRing;
+    t_Handle                    *p_BdShadow;
+    uint16_t                    currBdId;
+    uint16_t                    firstBdOfFrameId;
+
+    /* Rx port parameters */
+    uint8_t                     dataMemId;          /**< Memory partition ID for data buffers */
+    uint32_t                    dataMemAttributes;  /**< Memory attributes for data buffers */
+    t_BufferPoolInfo            rxPool;
+    uint16_t                    mrblr;
+    uint16_t                    rxFrameAccumLength;
+    t_FmPortImRxStoreFunction   *f_RxStoreCB;
+
+    /* Tx port parameters */
+    uint32_t                    txFirstBdStatus;
+    t_FmPortImTxConfFunction    *f_TxConfCB;
+} t_FmMacIm;
+
+/**************************************************************************//**
+ @Description   structure for defining internal context copying
+*//***************************************************************************/
+typedef struct
+{
+    uint16_t    extBufOffset;       /**< Offset in External buffer to which internal
+                                         context is copied to (Rx) or taken from (Tx, Op). */
+    uint8_t     intContextOffset;   /**< Offset within internal context to copy from
+                                         (Rx) or to copy to (Tx, Op). */
+    uint16_t    size;               /**< Internal offset size to be copied */
+} t_FmPortIntContextDataCopy;
+
+/**************************************************************************//**
+ @Description   struct for defining external buffer margins
+*//***************************************************************************/
+typedef struct{
+    uint16_t    startMargins;           /**< Number of bytes to be left at the beginning
+                                             of the external buffer (must be divisible by 16) */
+    uint16_t    endMargins;             /**< number of bytes to be left at the end
+                                             of the external buffer(must be divisible by 16) */
+} t_FmPortBufMargins;
+
+typedef struct{
+    uint32_t      dataOffset;
+    uint32_t      prsResultOffset;
+    uint32_t      timeStampOffset;
+} t_FmPortBufferOffsets;
+
+typedef struct
+{
+    uint32_t                    dfltFqid;
+    uint32_t                    confFqid;
+    uint32_t                    errFqid;
+    uint64_t                    baseAddr;
+    uint8_t                     deqSubPortal;
+    bool                        deqHighPriority;
+    e_FmPortDeqType             deqType;
+    e_FmPortDeqPrefetchOption   deqPrefetchOption;
+    uint16_t                    deqByteCnt;
+    uint8_t                     cheksumLastBytesIgnore;
+    uint8_t                     cutBytesFromEnd;
+    t_FmPortBufPoolDepletion    bufPoolDepletion;
+    uint8_t                     pipelineDepth;
+    uint16_t                    fifoLowComfLevel;
+    bool                        frmDiscardOverride;
+    bool                        enRateLimit;
+    t_FmPortRateLimit           rateLimit;
+    bool                        enBufPoolDepletion;
+    uint8_t                     partitionId;
+    t_FmPortRxExtPools          rxExtBufPools;
+    t_FmPortRsrc                openDmas;
+    t_FmPortRsrc                tasks;
+    t_FmPortRsrc                fifoBufs;
+    e_FmPortDmaSwap             dmaSwapData;
+    e_FmPortDmaCache            dmaIntContextCacheAttr;
+    e_FmPortDmaCache            dmaHeaderCacheAttr;
+    e_FmPortDmaCache            dmaScatterGatherCacheAttr;
+    bool                        dmaReadOptimize;
+    bool                        dmaWriteOptimize;
+    uint32_t                    txFifoMinFillLevel;
+    uint32_t                    txFifoLowComfLevel;
+    uint32_t                    rxFifoPriElevationLevel;
+    uint32_t                    rxFifoThreshold;
+    t_FmPortBufMargins          bufMargins;
+    t_FmPortIntContextDataCopy  intContext;
+    bool                        syncReq;
+    e_FmPortColor               color;
+    fmPortFrameErrSelect_t      errorsToDiscard;
+    fmPortFrameErrSelect_t      errorsToEnq;
+    uint32_t                    timeStampPeriod;
+    uint64_t                    fmMuramPhysBaseAddr;
+    bool                        forwardReuseIntContext;
+    bool                        l4Checksum;
+    t_FmPortBufferPrefixContent bufferPrefixContent;
+#ifdef VERIFICATION_SUPPORT
+    bool                        intContextConfigured;
+#endif
+}t_FmPortDriverParam;
+
+typedef struct
+{
+    t_Handle                    h_Fm;
+    t_Handle                    h_FmPcd;
+    uint8_t                     portId;
+    e_FmPortType                portType;
+    uint8_t                     hardwarePortId;
+    uint16_t                    fmClkFreq;
+    t_FmPortQmiRegs             *p_FmPortQmiRegs;
+    u_FmPortBmiRegs             *p_FmPortBmiRegs;
+    t_FmPortPrsRegs             *p_FmPortPrsRegs;
+    fmPcdEngines_t              pcdEngines;
+    uint32_t                    savedBmiNia;
+    uint8_t                     netEnvId;
+    uint32_t                    optArray[MAX_NUM_OF_OPTIONS];
+    uint32_t                    lcvs[FM_PCD_PRS_NUM_OF_HDRS];
+    uint8_t                     privateInfo;
+    uint32_t                    schemesPerPortVector;
+    bool                        useClsPlan;
+    uint8_t                     clsPlanGrpId;
+    t_Handle                    ccTreeId;
+    t_Handle                    completeArg;
+    void                        (*f_Complete)(t_Handle arg);
+    t_FmPortBufferOffsets       bufferOffsets;
+    /* Independent-Mode parameters support */
+    bool                        imEn;
+    t_FmMacIm                   im;
+    uint8_t                     txFifoDeqPipelineDepth;
+    t_FmPortDriverParam         *p_FmPortDriverParam;
+    volatile bool               lock;
+} t_FmPort;
+
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+t_Error FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams);
+t_Error FmPortDeletePcd(t_Handle h_FmPort);
+#endif
+
+t_Error FmPortConfigIM (t_FmPort *p_FmPort, t_FmPortParams *p_FmPortParams);
+t_Error FmPortImCheckInitParameters(t_FmPort *p_FmPort);
+
+t_Error FmPortImInit(t_FmPort *p_FmPort);
+void    FmPortImFree(t_FmPort *p_FmPort);
+
+t_Error FmPortImRx  (t_FmPort *p_FmPort);
+
+
+static __inline__ uint8_t * BD_BUFFER (t_FmImBd *p_Bd)
+{
+//#warning complete
+    return XX_PhysToVirt(CAST_UINT32_TO_POINTER(GET_UINT32(p_Bd->buff.low)));
+}
+
+static __inline__ void SET_ADDR(volatile t_FmPhysAddr *fmPhysAddr, uint64_t value)
+{
+    WRITE_UINT16(fmPhysAddr->high,(uint16_t)((value & 0x0000ffff00000000LL) >> 32));
+    WRITE_UINT32(fmPhysAddr->low,(uint32_t)value);
+}
+
+static __inline__ void BD_BUFFER_SET(t_FmImBd *p_Bd, uint8_t *p_Buffer)
+{
+    uint64_t    physAddr = CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_Buffer));
+    SET_ADDR(&p_Bd->buff, physAddr);
+}
+
+static __inline__ uint16_t GetNextBdId(t_FmPort *p_FmPort, uint16_t id)
+{
+    if (id < p_FmPort->im.bdRingSize-1)
+        return (uint16_t)(id+1);
+    else
+        return 0;
+}
+
+
+#endif /* __FM_PORT_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
new file mode 100644
index 0000000..3108611
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
@@ -0,0 +1,590 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_port_im.c
+
+ @Description   FM Port Independent-Mode ...
+*//***************************************************************************/
+#include "std_ext.h"
+#include "string_ext.h"
+#include "error_ext.h"
+#include "fm_muram_ext.h"
+
+#include "fm_port.h"
+
+
+#define TX_CONF_STATUS_UNSENT 0x1
+
+#ifdef CORE_8BIT_ACCESS_ERRATA
+#define MY_WRITE_UINT16(addr, val)                          \
+do {                                                        \
+    if (addr%4)                                             \
+    {                                                       \
+        uint32_t    newAddr = (uint32_t)((addr>>2)<<2);     \
+        uint32_t    tmp = GET_UINT32(newAddr);              \
+        tmp = (uint32_t)((tmp & 0xffff0000) | val);         \
+        WRITE_UINT32(newAddr, tmp);                         \
+    }                                                       \
+    else                                                    \
+    {                                                       \
+        uint32_t    tmp = GET_UINT32(addr);                 \
+        tmp = (uint32_t)((tmp & 0x0000ffff) | (((uint32_t)val)<<16));\
+        WRITE_UINT32(addr, tmp);                            \
+    }                                                       \
+} while (0)
+
+#define MY_WRITE_UINT8(addr,val) MY_MY_WRITE_UINT8(&addr,val)
+#define MY_GET_UINT8(addr) MY_MY_GET_UINT8(&addr)
+#else
+#define MY_WRITE_UINT16 WRITE_UINT16
+#define MY_GET_UINT16   GET_UINT16
+#endif /* CORE_8BIT_ACCESS_ERRATA */
+
+typedef enum e_TxConfType
+{
+     e_TX_CONF_TYPE_CHECK      = 0  /**< check if all the buffers were touched by the muxator, no confirmation callback */
+    ,e_TX_CONF_TYPE_CALLBACK   = 1  /**< confirm to user all the available sent buffers */
+    ,e_TX_CONF_TYPE_FLUSH      = 3  /**< confirm all buffers plus the unsent one with an appropriate status */
+} e_TxConfType;
+
+
+static void DiscardCurrentTxFrame(t_FmPort *p_FmPort)
+{
+    uint16_t   cleanBdId = p_FmPort->im.firstBdOfFrameId;
+
+    if ((cleanBdId == IM_ILEGAL_BD_ID) ||
+        (cleanBdId == p_FmPort->im.currBdId))
+        return;
+
+    /* Since firstInFrame is not NULL, one buffer at least has already been
+       inserted into the BD ring. Using do-while covers the situation of a
+       frame spanned throughout the whole Tx BD ring (p_CleanBd is incremented
+       prior to testing whether or not it's equal to TxBd). */
+    do
+    {
+        BD_STATUS_AND_LENGTH_SET(BD_GET(cleanBdId), 0);
+        /* Advance BD pointer */
+        cleanBdId = GetNextBdId(p_FmPort, cleanBdId);
+    } while (cleanBdId != p_FmPort->im.currBdId);
+
+    p_FmPort->im.firstBdOfFrameId = IM_ILEGAL_BD_ID;
+}
+
+static t_Error FmPortTxConf(t_FmPort *p_FmPort, e_TxConfType confType)
+{
+    t_Error             retVal = E_BUSY;
+    uint32_t            bdStatus;
+    uint16_t            savedStartBdId;
+
+    ASSERT_COND(p_FmPort);
+
+//    if (confType==e_TX_CONF_TYPE_CHECK)
+//        return (WfqEntryIsQueueEmpty(p_FmPort->im.h_WfqEntry) ? E_OK : E_BUSY);
+
+    savedStartBdId = p_FmPort->im.currBdId;
+    bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
+
+    /* if R bit is set, we don't enter, or we break.
+    we run till we get to R, or complete the loop */
+    while ((!(bdStatus & BD_R_E) || (confType == e_TX_CONF_TYPE_FLUSH)) && (retVal != E_OK))
+    {
+        if (confType & e_TX_CONF_TYPE_CALLBACK) /* if it is confirmation with user callbacks */
+            BD_STATUS_AND_LENGTH_SET(BD_GET(p_FmPort->im.currBdId), 0);
+
+        /* case 1: R bit is 0 and Length is set -> confirm! */
+        if ((confType & e_TX_CONF_TYPE_CALLBACK) && (bdStatus & BD_LENGTH_MASK))
+        {
+            if (p_FmPort->im.f_TxConfCB)
+            {
+                if ((confType == e_TX_CONF_TYPE_FLUSH) && (bdStatus & BD_R_E))
+                    p_FmPort->im.f_TxConfCB(p_FmPort->im.h_App,
+                                            BD_BUFFER(BD_GET(p_FmPort->im.currBdId)),
+                                            TX_CONF_STATUS_UNSENT,
+                                            p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId]);
+                else
+                    p_FmPort->im.f_TxConfCB(p_FmPort->im.h_App,
+                                            BD_BUFFER(BD_GET(p_FmPort->im.currBdId)),
+                                            0,
+                                            p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId]);
+            }
+        }
+        /* case 2: R bit is 0 and Length is 0 -> not used yet, nop! */
+
+        p_FmPort->im.currBdId = GetNextBdId(p_FmPort, p_FmPort->im.currBdId);
+        if (p_FmPort->im.currBdId == savedStartBdId)
+            retVal = E_OK;
+        bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
+    }
+
+    MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->txQd.offsetIn, (uint16_t)(p_FmPort->im.currBdId<<4));
+
+    return retVal;
+}
+
+
+t_Error FmPortImRx(t_FmPort *p_FmPort)
+{
+//    e_ExceptionsSelect      exceptions = e_EX_NONE;
+    t_Handle                h_CurrUserPriv, h_NewUserPriv;
+    uint32_t                bdStatus;
+    volatile uint8_t        buffPos;
+    uint16_t                length;
+    uint16_t                errors/*, reportErrors*/;
+    uint8_t                 *p_CurData, *p_Data;
+
+    ASSERT_COND(p_FmPort);
+
+    bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
+
+    while (!(bdStatus & BD_R_E)) /* while there is data in the Rx BD */
+    {
+        if (p_FmPort->im.firstBdOfFrameId == IM_ILEGAL_BD_ID)
+            p_FmPort->im.firstBdOfFrameId = p_FmPort->im.currBdId;
+
+        errors = 0;
+        p_CurData = BD_BUFFER(BD_GET(p_FmPort->im.currBdId));
+        h_CurrUserPriv = p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId];
+        length = (uint16_t)((bdStatus & BD_L) ?
+                            ((bdStatus & BD_LENGTH_MASK) - p_FmPort->im.rxFrameAccumLength):
+                            (bdStatus & BD_LENGTH_MASK));
+        p_FmPort->im.rxFrameAccumLength += length;
+
+        /* determine whether buffer is first, last, first and last (single  */
+        /* buffer frame) or middle (not first and not last)                 */
+        buffPos = (uint8_t)((p_FmPort->im.currBdId == p_FmPort->im.firstBdOfFrameId) ?
+                            ((bdStatus & BD_L) ? SINGLE_BUF : FIRST_BUF) :
+                            ((bdStatus & BD_L) ? LAST_BUF : MIDDLE_BUF));
+
+        if (bdStatus & BD_L)
+        {
+            p_FmPort->im.rxFrameAccumLength = 0;
+            p_FmPort->im.firstBdOfFrameId = IM_ILEGAL_BD_ID;
+        }
+
+        if ((p_Data = p_FmPort->im.rxPool.f_GetBuf(p_FmPort->im.rxPool.h_BufferPool, &h_NewUserPriv)) == NULL)
+            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Data buffer"));
+
+        BD_BUFFER_SET(BD_GET(p_FmPort->im.currBdId), p_Data);
+
+        BD_STATUS_AND_LENGTH_SET(BD_GET(p_FmPort->im.currBdId), BD_R_E);
+
+//#warning "add here support for errors!!!"
+        errors = (uint16_t)((bdStatus & BD_RX_ERRORS) >> 16);
+#if 0
+        /* find out which errors the user wants reported. The BD will
+        still be passed to the user, but first f_Exceptions will be called */
+        reportErrors = (uint16_t)(errors & p_FmPort->im.bdErrorsReport);
+        if(reportErrors)
+        {
+            QUEUE_GET_EXCEPTIONS(reportErrors, exceptions);
+            p_FmPort->im.f_Exceptions(p_FmPort->im.h_App, exceptions, 0);
+        }
+#endif /* 0 */
+
+        /* Pass the buffer if one of the conditions is true:
+        - There are no errors
+        - This is a part of a larger frame ( the application has already received some buffers )
+        - There is an error, but it was defined to be passed anyway. */
+        if ((buffPos != SINGLE_BUF) || !errors || (errors & (uint16_t)(BD_ERROR_PASS_FRAME>>16)))
+        {
+            p_FmPort->im.f_RxStoreCB(p_FmPort->im.h_App,
+                                     p_CurData,
+                                     length,
+                                     errors,
+                                     buffPos,
+                                     h_CurrUserPriv);
+        }
+        else if (p_FmPort->im.rxPool.f_PutBuf(p_FmPort->im.rxPool.h_BufferPool,
+                                              p_CurData,
+                                              h_CurrUserPriv))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Failed freeing data buffer"));
+
+        p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId] = h_NewUserPriv;
+
+        p_FmPort->im.currBdId = GetNextBdId(p_FmPort, p_FmPort->im.currBdId);
+        bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
+        MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.offsetOut, (uint16_t)(p_FmPort->im.currBdId<<4));
+    }
+
+    return E_OK;
+}
+
+t_Error FmPortConfigIM (t_FmPort *p_FmPort, t_FmPortParams *p_FmPortParams)
+{
+    ASSERT_COND(p_FmPort);
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->im.h_App                          = p_FmPortParams->specificParams.imRxTxParams.h_App;
+    p_FmPort->im.h_FmMuram                      = p_FmPortParams->specificParams.imRxTxParams.h_FmMuram;
+    p_FmPort->p_FmPortDriverParam->partitionId  = p_FmPortParams->specificParams.imRxTxParams.partitionId;
+    p_FmPort->im.dataMemId                      = p_FmPortParams->specificParams.imRxTxParams.dataMemId;
+    p_FmPort->im.dataMemAttributes              = p_FmPortParams->specificParams.imRxTxParams.dataMemAttributes;
+
+    p_FmPort->im.fwExtStructsMemId      = DEFAULT_PORT_ImfwExtStructsMemId;
+    p_FmPort->im.fwExtStructsMemAttr    = DEFAULT_PORT_Im_fwExtStructsMemAttr;
+
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        p_FmPort->im.rxPool.h_BufferPool    = p_FmPortParams->specificParams.imRxTxParams.rxPoolParams.h_BufferPool;
+        p_FmPort->im.rxPool.f_GetBuf        = p_FmPortParams->specificParams.imRxTxParams.rxPoolParams.f_GetBuf;
+        p_FmPort->im.rxPool.f_PutBuf        = p_FmPortParams->specificParams.imRxTxParams.rxPoolParams.f_PutBuf;
+        p_FmPort->im.rxPool.bufferSize      = p_FmPortParams->specificParams.imRxTxParams.rxPoolParams.bufferSize;
+        p_FmPort->im.f_RxStoreCB            = p_FmPortParams->specificParams.imRxTxParams.f_RxStoreCB;
+
+        p_FmPort->im.mrblr                  = DEFAULT_PORT_ImMaxRxBufLength;
+        p_FmPort->im.bdRingSize             = DEFAULT_PORT_rxBdRingLength;
+    }
+    else
+    {
+        p_FmPort->im.f_TxConfCB             = p_FmPortParams->specificParams.imRxTxParams.f_TxConfCB;
+
+        p_FmPort->im.bdRingSize             = DEFAULT_PORT_txBdRingLength;
+    }
+
+    return E_OK;
+}
+
+t_Error FmPortImCheckInitParameters(t_FmPort *p_FmPort)
+{
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_TX) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_TX_10G))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
+
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        if (!POWER_OF_2(p_FmPort->im.mrblr))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("max Rx buffer length must be power of 2!!!"));
+        if (p_FmPort->im.mrblr < 256)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("max Rx buffer length must at least 256!!!"));
+        if(p_FmPort->p_FmPortDriverParam->partitionId >= FM_MAX_NUM_OF_PARTITIONS)
+             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("partitionId can't be larger than %d", FM_MAX_NUM_OF_PARTITIONS-1));
+//#warning "add checks"
+    }
+    else
+    {
+//#warning "add checks"
+    }
+
+    return E_OK;
+}
+
+t_Error FmPortImInit(t_FmPort *p_FmPort)
+{
+    t_FmImBd    *p_Bd=NULL;
+    t_Handle    h_UserPriv;
+    uint64_t    tmpPhysBase;
+    uint16_t    log2Num;
+    uint8_t     *p_Data/*, *p_Tmp*/;
+    int         i;
+
+    ASSERT_COND(p_FmPort);
+
+    p_FmPort->im.p_FmPortImPram =
+        (t_FmPortImPram *)FM_MURAM_AllocMem(p_FmPort->im.h_FmMuram, sizeof(t_FmPortImPram), IM_PRAM_ALIGN);
+    if (!p_FmPort->im.p_FmPortImPram)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Independent-Mode Parameter-RAM!!!"));
+    WRITE_BLOCK(p_FmPort->im.p_FmPortImPram, 0, sizeof(t_FmPortImPram));
+
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        p_FmPort->im.p_BdRing = (t_FmImBd *)XX_MallocSmart((uint32_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize), p_FmPort->im.fwExtStructsMemId, 4);
+        if (!p_FmPort->im.p_BdRing)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Independent-Mode Rx BD ring!!!"));
+        memset(p_FmPort->im.p_BdRing, 0, (uint32_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize));
+
+        p_FmPort->im.p_BdShadow = (t_Handle *)XX_Malloc((uint32_t)(sizeof(t_Handle)*p_FmPort->im.bdRingSize));
+        if (!p_FmPort->im.p_BdShadow)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Independent-Mode Rx BD shadow!!!"));
+        memset(p_FmPort->im.p_BdShadow, 0, (uint32_t)(sizeof(t_Handle)*p_FmPort->im.bdRingSize));
+
+        /* Initialize the Rx-BD ring */
+        for (i=0; i<p_FmPort->im.bdRingSize; i++)
+        {
+            p_Bd = BD_GET(i);
+            BD_STATUS_AND_LENGTH_SET (p_Bd, BD_R_E);
+
+            if ((p_Data = p_FmPort->im.rxPool.f_GetBuf(p_FmPort->im.rxPool.h_BufferPool, &h_UserPriv)) == NULL)
+                RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Data buffer"));
+            BD_BUFFER_SET(p_Bd, p_Data);
+            p_FmPort->im.p_BdShadow[i] = h_UserPriv;
+        }
+
+        if (p_FmPort->im.dataMemAttributes & MEMORY_ATTR_CACHEABLE)
+            WRITE_UINT32(p_FmPort->im.p_FmPortImPram->mode, IM_MODE_GBL);
+
+        WRITE_UINT32(p_FmPort->im.p_FmPortImPram->rxQdPtr,
+                     (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
+                                p_FmPort->p_FmPortDriverParam->fmMuramPhysBaseAddr + 0x20));
+
+        LOG2((uint64_t)p_FmPort->im.mrblr, log2Num);
+        MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->mrblr, log2Num);
+
+        /* Initialize Rx QD */
+        tmpPhysBase = CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_FmPort->im.p_BdRing));
+        SET_ADDR(&p_FmPort->im.p_FmPortImPram->rxQd.bdRingBase, tmpPhysBase);
+        MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.bdRingSize, (uint16_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize));
+
+        /* Update the IM PRAM address in the BMI */
+        WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfqid,
+                     (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
+                                p_FmPort->p_FmPortDriverParam->fmMuramPhysBaseAddr));
+    }
+    else
+    {
+        p_FmPort->im.p_BdRing = (t_FmImBd *)XX_MallocSmart((uint32_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize), p_FmPort->im.fwExtStructsMemId, 4);
+        if (!p_FmPort->im.p_BdRing)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Independent-Mode Tx BD ring!!!"));
+        memset(p_FmPort->im.p_BdRing, 0, (uint32_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize));
+
+        p_FmPort->im.p_BdShadow = (t_Handle *)XX_Malloc((uint32_t)(sizeof(t_Handle)*p_FmPort->im.bdRingSize));
+        if (!p_FmPort->im.p_BdShadow)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Independent-Mode Rx BD shadow!!!"));
+        memset(p_FmPort->im.p_BdShadow, 0, (uint32_t)(sizeof(t_Handle)*p_FmPort->im.bdRingSize));
+        p_FmPort->im.firstBdOfFrameId = IM_ILEGAL_BD_ID;
+
+        if (p_FmPort->im.dataMemAttributes & MEMORY_ATTR_CACHEABLE)
+            WRITE_UINT32(p_FmPort->im.p_FmPortImPram->mode, IM_MODE_GBL);
+
+        WRITE_UINT32(p_FmPort->im.p_FmPortImPram->txQdPtr,
+                     (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
+                                p_FmPort->p_FmPortDriverParam->fmMuramPhysBaseAddr + 0x40));
+
+        /* Initialize Tx QD */
+        tmpPhysBase = CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_FmPort->im.p_BdRing));
+        SET_ADDR(&p_FmPort->im.p_FmPortImPram->txQd.bdRingBase, tmpPhysBase);
+        MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->txQd.bdRingSize, (uint16_t)(sizeof(t_FmImBd)*p_FmPort->im.bdRingSize));
+
+        /* Update the IM PRAM address in the BMI */
+        WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfqid,
+                     (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(p_FmPort->im.p_FmPortImPram)) -
+                                p_FmPort->p_FmPortDriverParam->fmMuramPhysBaseAddr));
+    }
+
+    return E_OK;
+}
+
+void FmPortImFree(t_FmPort *p_FmPort)
+{
+    uint32_t    bdStatus;
+    uint8_t     *p_CurData;
+
+    ASSERT_COND(p_FmPort);
+
+    if (p_FmPort->im.p_FmPortImPram)
+        FM_MURAM_FreeMem(p_FmPort->im.h_FmMuram, p_FmPort->im.p_FmPortImPram);
+
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        /* Try first clean what has recieved */
+        FmPortImRx(p_FmPort);
+
+        /* Now, get rid of the the empty buffer! */
+        bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
+
+        while (bdStatus & BD_R_E) /* while there is data in the Rx BD */
+        {
+            p_CurData = BD_BUFFER(BD_GET(p_FmPort->im.currBdId));
+
+            BD_BUFFER_SET(BD_GET(p_FmPort->im.currBdId), NULL);
+            BD_STATUS_AND_LENGTH_SET(BD_GET(p_FmPort->im.currBdId), 0);
+
+            p_FmPort->im.rxPool.f_PutBuf(p_FmPort->im.rxPool.h_BufferPool,
+                                         p_CurData,
+                                         p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId]);
+
+            p_FmPort->im.currBdId = GetNextBdId(p_FmPort, p_FmPort->im.currBdId);
+            bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
+        }
+    }
+    else
+        FmPortTxConf(p_FmPort, e_TX_CONF_TYPE_FLUSH);
+
+    if (p_FmPort->im.p_BdShadow)
+        XX_Free(p_FmPort->im.p_BdShadow);
+
+    if (p_FmPort->im.p_BdRing)
+        XX_FreeSmart(p_FmPort->im.p_BdRing);
+}
+
+
+t_Error FM_PORT_ConfigIMMaxRxBufLength(t_Handle h_FmPort, uint16_t newVal)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->im.mrblr = newVal;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigIMRxBdRingLength(t_Handle h_FmPort, uint16_t newVal)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->im.bdRingSize = newVal;
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigIMTxBdRingLength(t_Handle h_FmPort, uint16_t newVal)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->im.bdRingSize = newVal;
+
+    return E_OK;
+}
+
+
+t_Error  FM_PORT_ImTx( t_Handle               h_FmPort,
+                       uint8_t                *p_Data,
+                       uint16_t               length,
+                       bool                   lastBuffer,
+                       t_Handle               h_UserPriv)
+{
+    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
+    uint16_t            nextBdId;
+    uint32_t            bdStatus, nextBdStatus;
+    bool                firstBuffer;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    bdStatus = BD_STATUS_AND_LENGTH(BD_GET(p_FmPort->im.currBdId));
+    nextBdId = GetNextBdId(p_FmPort, p_FmPort->im.currBdId);
+    nextBdStatus = BD_STATUS_AND_LENGTH(BD_GET(nextBdId));
+
+    if (!(bdStatus & BD_R_E) && !(nextBdStatus & BD_R_E))
+    {
+        /* Confirm the current BD - BD is available */
+        if ((bdStatus & BD_LENGTH_MASK) && (p_FmPort->im.f_TxConfCB))
+            p_FmPort->im.f_TxConfCB (p_FmPort->im.h_App,
+                                     BD_BUFFER(BD_GET(p_FmPort->im.currBdId)),
+                                     0,
+                                     p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId]);
+
+        bdStatus |= length;
+
+        /* if this is the first BD of a frame */
+        if (p_FmPort->im.firstBdOfFrameId == IM_ILEGAL_BD_ID)
+        {
+            firstBuffer = TRUE;
+            p_FmPort->im.txFirstBdStatus = (bdStatus | BD_R_E);
+
+            if (!lastBuffer)
+                p_FmPort->im.firstBdOfFrameId = p_FmPort->im.currBdId;
+        }
+        else
+            firstBuffer = FALSE;
+
+        BD_BUFFER_SET(BD_GET(p_FmPort->im.currBdId), p_Data);
+        p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId] = h_UserPriv;
+
+        /* deal with last */
+        if (lastBuffer)
+        {
+            /* if single buffer frame */
+            if (firstBuffer)
+                BD_STATUS_AND_LENGTH_SET(BD_GET(p_FmPort->im.currBdId), p_FmPort->im.txFirstBdStatus | BD_L);
+            else
+            {
+                /* Set the last BD of the frame */
+                BD_STATUS_AND_LENGTH_SET (BD_GET(p_FmPort->im.currBdId), (bdStatus | BD_R_E | BD_L));
+                /* Set the first BD of the frame */
+                BD_STATUS_AND_LENGTH_SET(BD_GET(p_FmPort->im.firstBdOfFrameId), p_FmPort->im.txFirstBdStatus);
+                p_FmPort->im.firstBdOfFrameId = IM_ILEGAL_BD_ID;
+            }
+        }
+        else if (!firstBuffer) /* mid frame buffer */
+            BD_STATUS_AND_LENGTH_SET (BD_GET(p_FmPort->im.currBdId), bdStatus | BD_R_E);
+
+        p_FmPort->im.currBdId = GetNextBdId(p_FmPort, p_FmPort->im.currBdId);
+        MY_WRITE_UINT16(p_FmPort->im.p_FmPortImPram->txQd.offsetIn, (uint16_t)(p_FmPort->im.currBdId<<4));
+    }
+    else
+    {
+        /* Discard current frame. Return error.   */
+        if (p_FmPort->im.firstBdOfFrameId != IM_ILEGAL_BD_ID)
+        {
+            ASSERT_COND(p_FmPort->im.firstBdOfFrameId != p_FmPort->im.currBdId);
+            /* Error:    No free BD */
+            /* Response: Discard current frame. Return error.   */
+            DiscardCurrentTxFrame(p_FmPort);
+        }
+
+        return E_FULL;
+    }
+
+    return E_OK;
+}
+
+void FM_PORT_ImTxConf(t_Handle h_FmPort)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    FmPortTxConf(p_FmPort, e_TX_CONF_TYPE_CALLBACK);
+}
+
+t_Error  FM_PORT_ImRx(t_Handle h_FmPort)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->imEn, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    return FmPortImRx(p_FmPort);
+}
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c
new file mode 100644
index 0000000..abdeaca
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.c
@@ -0,0 +1,2478 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm.c
+
+ @Description   FM driver routines implementation.
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "xx_ext.h"
+#include "string_ext.h"
+#include "sprint_ext.h"
+#include "debug_ext.h"
+#include "fm_muram_ext.h"
+#include "fm_common.h"
+#ifdef FM_MASTER_PARTITION
+#include "fm_ipc.h"
+#endif /* FM_MASTER_PARTITION */
+#include "fm.h"
+
+
+#define TS_FRAC_PRECISION_FACTOR    1000
+
+
+/****************************************/
+/*       static functions               */
+/****************************************/
+static t_Error CheckFmParameters(t_Fm *p_Fm)
+{
+    uint8_t     i;
+
+    if(p_Fm->p_FmDriverParam->enTimeStamp)
+    {
+        if(!p_Fm->timeStampPeriod)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("timeStampPeriod may not be 0"));
+    }
+    if(!p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats || (p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats > DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("axiDbgNumOfBeats has to be in the range 1 - %d", DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS));
+    if(p_Fm->p_FmDriverParam->dmaCamNumOfEntries % DMA_CAM_UNITS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCamNumOfEntries has to be divisble by %d", DMA_CAM_UNITS));
+    if(!p_Fm->p_FmDriverParam->dmaCamNumOfEntries || (p_Fm->p_FmDriverParam->dmaCamNumOfEntries > DMA_MODE_MAX_CAM_NUM_OF_ENTRIES))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCamNumOfEntries has to be in the range 1 - %d", DMA_MODE_MAX_CAM_NUM_OF_ENTRIES));
+    if(p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency > DMA_THRESH_MAX_COMMQ)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCommQThresholds.assertEmergency can not be larger than %d", DMA_THRESH_MAX_COMMQ));
+    if(p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency > DMA_THRESH_MAX_COMMQ)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCommQThresholds.clearEmergency can not be larger than %d", DMA_THRESH_MAX_COMMQ));
+    if(p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCommQThresholds.clearEmergency must be smaller than dmaCommQThresholds.assertEmergency"));
+    if(p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency > DMA_THRESH_MAX_BUF)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaReadBufThresholds.assertEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
+    if(p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency > DMA_THRESH_MAX_BUF)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaReadBufThresholds.clearEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
+    if(p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaReadBufThresholds.clearEmergency must be smaller than dmaReadBufThresholds.assertEmergency"));
+    if(p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency > DMA_THRESH_MAX_BUF)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.assertEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
+    if(p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency > DMA_THRESH_MAX_BUF)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.clearEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
+    if(p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.clearEmergency must be smaller than dmaWriteBufThresholds.assertEmergency"));
+
+    if(!p_Fm->fmClkFreq)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fmClkFreq must be set."));
+    if(USEC_TO_CLK(p_Fm->p_FmDriverParam->dmaWatchdog, p_Fm->fmClkFreq) > DMA_MAX_WATCHDOG)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWatchdog depends on FM clock. dmaWatchdog(in microseconds) * clk (in Mhz), may not exceed 0xffffffff"));
+    for (i=0 ; i<FM_MAX_NUM_OF_PARTITIONS ; i++)
+        if(p_Fm->p_FmDriverParam->liodnPerPartition[i] & ~FM_LIODN_MASK)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("liodn number is out of range"));
+
+    if(p_Fm->totalFifoSize % BMI_FIFO_UNITS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("totalFifoSize number has to be divisible by %d", BMI_FIFO_UNITS));
+    if(!p_Fm->totalFifoSize || (p_Fm->totalFifoSize > BMI_MAX_FIFO_SIZE))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("totalFifoSize number has to be in the range 256 - %d", BMI_MAX_FIFO_SIZE));
+    if(!p_Fm->totalNumOfTasks || (p_Fm->totalNumOfTasks > BMI_MAX_NUM_OF_TASKS))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("totalNumOfTasks number has to be in the range 1 - %d", BMI_MAX_NUM_OF_TASKS));
+    if(!p_Fm->maxNumOfOpenDmas || (p_Fm->maxNumOfOpenDmas > BMI_MAX_NUM_OF_DMAS))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxNumOfOpenDmas number has to be in the range 1 - %d", BMI_MAX_NUM_OF_DMAS));
+
+    if(p_Fm->p_FmDriverParam->thresholds.dispLimit > FPM_MAX_DISP_LIMIT)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("thresholds.dispLimit can't be greater than %d", FPM_MAX_DISP_LIMIT));
+
+    if(!p_Fm->f_Exceptions)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exceptions callback not provided"));
+    if(!p_Fm->f_BusError)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exceptions callback not provided"));
+
+    return E_OK;
+}
+
+static uint8_t  GetPartition(t_Fm *p_Fm, uint16_t liodn)
+{
+    int         i;
+    uint32_t    tmpReg;
+
+    for (i=0 ; i<FM_MAX_NUM_OF_PARTITIONS ; i+=2)
+    {
+        tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[i/2]);
+        if (liodn == (uint16_t)((tmpReg & DMA_HIGH_LIODN_MASK )>> DMA_LIODN_SHIFT))
+            return (uint8_t)i;
+        if (liodn == (uint16_t)(tmpReg & DMA_LOW_LIODN_MASK))
+            return (uint8_t)(i+1);
+    }
+    REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Partition not found in LIODN table"));
+    return 0;
+}
+
+static void    BmiErrEvent(t_Fm *p_Fm)
+{
+    uint32_t    event, mask;
+
+    event = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr);
+    mask = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
+    event &= mask;
+    /* clear the acknowledged events */
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr, event);
+
+    if(event & BMI_ERR_INTR_EN_PIPELINE_ECC)
+        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_BMI_PIPELINE_ECC);
+    if(event & BMI_ERR_INTR_EN_LIST_RAM_ECC)
+        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_BMI_LIST_RAM_ECC);
+    if(event & BMI_ERR_INTR_EN_STATISTICS_RAM_ECC)
+        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_BMI_STATISTICS_RAM_ECC);
+}
+
+static void    QmiErrEvent(t_Fm *p_Fm)
+{
+    uint32_t    event, mask;
+
+    event = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eie);
+    mask = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien);
+    event &= mask;
+    /* clear the acknowledged events */
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eie, event);
+
+    if(event & QMI_ERR_INTR_EN_DOUBLE_ECC)
+        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_QMI_DOUBLE_ECC);
+    if(event & QMI_ERR_INTR_EN_DEQ_FROM_DEF)
+        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_QMI_DEQ_FROM_DEFQ);
+}
+
+static void    DmaErrEvent(t_Fm *p_Fm)
+{
+    uint64_t            addr=0;
+    uint32_t            status, mask, tmpReg=0;
+    uint8_t             tnum, partition;
+    uint8_t             hardwarePortId;
+    uint8_t             relativePortId;
+
+    status = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsr);
+    mask = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr);
+
+    /* get bus error regs befor clearing BER */
+    if ((status & DMA_STATUS_BUS_ERR) && (mask & DMA_MODE_BER))
+    {
+        addr = (uint64_t)GET_UINT32(p_Fm->p_FmDmaRegs->fmdmtal);
+        addr |= (uint64_t)GET_UINT32(p_Fm->p_FmDmaRegs->fmdmtah) << 32;
+
+        /* get information about the owner of that bus error */
+        tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmtcid);
+    }
+
+    /* clear set events */
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsr, status);
+
+    if ((status & DMA_STATUS_BUS_ERR) && (mask & DMA_MODE_BER))
+    {
+        ASSERT_COND(p_Fm->h_FmPorts[((tmpReg & DMA_TRANSFER_PORTID_MASK) >> DMA_TRANSFER_PORTID_SHIFT)]);
+        hardwarePortId = (uint8_t)(((tmpReg & DMA_TRANSFER_PORTID_MASK) >> DMA_TRANSFER_PORTID_SHIFT));
+        GET_RELATIVE_PORTID(relativePortId, hardwarePortId);
+        tnum = (uint8_t)((tmpReg & DMA_TRANSFER_TNUM_MASK) >> DMA_TRANSFER_TNUM_SHIFT);
+        partition = GetPartition(p_Fm, (uint16_t)(tmpReg & DMA_TRANSFER_LIODN_MASK));
+        ASSERT_COND(p_Fm->portsTypes[hardwarePortId] != e_FM_PORT_TYPE_DUMMY);
+        p_Fm->f_BusError(p_Fm->h_App, p_Fm->portsTypes[hardwarePortId] , relativePortId, addr, tnum, partition) ;
+    }
+    if(mask & DMA_MODE_ECC)
+    {
+        if (status & DMA_STATUS_READ_ECC)
+            p_Fm->f_Exceptions(p_Fm->h_App, e_FM_EX_DMA_READ_ECC) ;
+        if (status & DMA_STATUS_SYSTEM_WRITE_ECC)
+            p_Fm->f_Exceptions(p_Fm->h_App, e_FM_EX_DMA_SYSTEM_WRITE_ECC) ;
+        if (status & DMA_STATUS_FM_WRITE_ECC)
+            p_Fm->f_Exceptions(p_Fm->h_App, e_FM_EX_DMA_FM_WRITE_ECC) ;
+    }
+}
+
+static void    FpmErrEvent(t_Fm *p_Fm)
+{
+    uint32_t    event;
+
+    event = GET_UINT32(p_Fm->p_FmFpmRegs->fpmem);
+    /* clear the all occured events */
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, event);
+
+    if((event  & FPM_EV_MASK_DOUBLE_ECC) && (event & FPM_EV_MASK_DOUBLE_ECC_EN))
+        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_FPM_DOUBLE_ECC);
+    if((event  & FPM_EV_MASK_STALL) && (event & FPM_EV_MASK_STALL_EN))
+        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_FPM_STALL_ON_TASKS);
+    if((event  & FPM_EV_MASK_SINGLE_ECC) && (event & FPM_EV_MASK_SINGLE_ECC_EN))
+        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_FPM_SINGLE_ECC);
+}
+
+static void    MuramErrIntr(t_Fm *p_Fm)
+{
+    uint32_t    event;
+
+    event = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
+
+    /* clear MURAM event bit */
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, event & ~FPM_RAM_CTL_IRAM_ECC);
+
+    ASSERT_COND(event  & FPM_RAM_CTL_MURAM_ECC);
+    ASSERT_COND(event  & FPM_RAM_CTL_RAMS_ECC_EN);
+
+    p_Fm->f_Exceptions(p_Fm->h_App, e_FM_EX_MURAM_ECC);
+}
+
+static void    IramErrIntr(t_Fm *p_Fm)
+{
+    uint32_t    event;
+
+    event = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr) ;
+    /* clear the acknowledged events (do not clear IRAM event) */
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, event & ~FPM_RAM_CTL_MURAM_ECC );
+
+    ASSERT_COND(event  & FPM_RAM_CTL_IRAM_ECC);
+    ASSERT_COND(event  & FPM_RAM_CTL_IRAM_ECC_EN);
+
+    p_Fm->f_Exceptions(p_Fm->h_App, e_FM_EX_IRAM_ECC);
+}
+
+static void     QmiEvent(t_Fm *p_Fm)
+{
+    uint32_t    event, mask;
+
+    event = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie);
+    mask = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien);
+    event &= mask;
+    /* clear the acknowledged events */
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie, event);
+
+    if(event & QMI_INTR_EN_SINGLE_ECC)
+        p_Fm->f_Exceptions(p_Fm->h_App,e_FM_EX_QMI_SINGLE_ECC);
+}
+
+static void     FmCtlEvent(t_Fm *p_Fm, uint32_t pending)
+{
+    uint32_t    eventRegBitMask = FPM_EVENT_FM_CTL_0;
+    uint8_t     i;
+    uint32_t    event;
+
+    for(i=0;i<NUM_OF_FM_CTL_EVENT_REGS;i++)
+    {
+       if (pending & eventRegBitMask)
+       {
+            event = GET_UINT32(p_Fm->p_FmFpmRegs->fpmcev[i]);
+            /* clear event bits */
+            WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmcev[i], event);
+            p_Fm->f_FmCtlIsr[i](p_Fm, event);
+       }
+       eventRegBitMask >>= 1;
+    }
+}
+
+static void UnimplementedIsr(t_Handle h_Arg)
+{
+    UNUSED(h_Arg);
+
+    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unimplemented Isr!"));
+}
+
+static void UnimplementedFmCtlIsr(t_Handle h_Arg, uint32_t event)
+{
+    UNUSED(h_Arg); UNUSED(event);
+
+    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unimplemented FmCtl Isr!"));
+}
+
+static void FmFreeInitResources(t_Fm *p_Fm)
+{
+    if (p_Fm->camBaseAddr)
+       FM_MURAM_FreeMem(p_Fm->h_FmMuram, CAST_UINT64_TO_POINTER(p_Fm->camBaseAddr));
+    if (p_Fm->fifoBaseAddr)
+       FM_MURAM_FreeMem(p_Fm->h_FmMuram, CAST_UINT64_TO_POINTER(p_Fm->fifoBaseAddr));
+}
+
+static void LoadPatch(t_Fm *p_Fm)
+{
+    t_FMIramRegs    *p_Iram = CAST_UINT64_TO_POINTER_TYPE(t_FMIramRegs, (p_Fm->baseAddr + FM_MM_IMEM));
+    int             i;
+
+    SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
+
+    DBG(TRACE, ("Loading firmware to IRAM ..."));
+
+    /* Applying patch to IRAM */
+    WRITE_UINT32(p_Iram->iadd, IRAM_IADD_AIE);
+    while (GET_UINT32(p_Iram->iadd) != IRAM_IADD_AIE) ;
+
+    for (i=0; i < (p_Fm->p_FmDriverParam->firmware.size / 4); i++)
+        WRITE_UINT32(p_Iram->idata, p_Fm->p_FmDriverParam->firmware.p_Code[i]);
+
+    WRITE_UINT32(p_Iram->iadd,0x0);
+    /* verify that writing has completed */
+    while (GET_UINT32(p_Iram->idata) != p_Fm->p_FmDriverParam->firmware.p_Code[0]) ;
+
+    /* Enable patch from IRAM */
+    WRITE_UINT32(p_Iram->iready, IRAM_READY);
+}
+
+/****************************************/
+/*       Inter-Module functions        */
+/****************************************/
+
+#ifdef FM_MASTER_PARTITION
+t_Error     FmHandleIpcMsg(t_Handle h_Fm, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE])
+{
+    t_Fm    *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    switch(msgId)
+    {
+        case (FM_GET_SET_PORT_PARAMS):
+            return FmGetSetPortParams(h_Fm, (t_FmInterModulePortInitParams*)msgBody);
+         case (FM_RESUME_STALLED_PORT):
+            return FmResumeStalledPort(h_Fm, msgBody[0]);
+        case (FM_IS_PORT_STALLED):
+            ((t_FmIpcPortIsStalled*)msgBody)->isStalled = FmIsPortStalled(h_Fm, (uint8_t)(((t_FmIpcPortIsStalled*)msgBody)->hardwarePortId));
+            break;
+        case (FM_RESET_MAC):
+        {
+            t_FmIpcMacReset ipcParams;
+            memcpy(msgBody, (uint8_t *)&ipcParams, sizeof(t_FmIpcMacReset));
+            return FmResetMac(p_Fm, (e_FmMacType)ipcParams.type, ipcParams.id);
+        }
+        case (FM_FREE_PORT):
+            FmFreePortParams(h_Fm, (t_FmInterModulePortFreeParams*)msgBody);
+            break;
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+        case (FM_DUMP_PORT_REGS):
+            return FmDumpPortRegs(h_Fm, msgBody[0]);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("command not found!!!"));
+    }
+    return E_OK;
+}
+#endif /* FM_MASTER_PARTITION */
+
+uint64_t FmGetPcdPrsBaseAddr(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
+
+    return (p_Fm->baseAddr + FM_MM_PRS);
+}
+
+uint64_t FmGetPcdKgBaseAddr(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
+
+    return (p_Fm->baseAddr + FM_MM_KG);
+}
+
+uint64_t FmGetPcdPlcrBaseAddr(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
+
+    return (p_Fm->baseAddr + FM_MM_PLCR);
+}
+
+t_Handle FmGetMuramHandle(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, NULL);
+
+    return (p_Fm->h_FmMuram);
+}
+
+t_Error FmGetPhysicalMuramBase(t_Handle h_Fm, t_FmPhysAddr *fmPhysAddr)
+{
+    t_Fm            *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    /* General FM driver initialization */
+    fmPhysAddr->low=(uint32_t)p_Fm->fmMuramPhysBaseAddr;
+    fmPhysAddr->high=(uint16_t)((p_Fm->fmMuramPhysBaseAddr & 0x0000ffff00000000LL) >> 32);
+
+    return E_OK;
+}
+
+
+void FmRegisterIntr(t_Handle h_Fm,
+                        e_FmInterModuleEvent   event,
+                        void (*f_Isr) (t_Handle h_Arg),
+                        t_Handle    h_Arg)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    p_Fm->intrMng[event].f_Isr = f_Isr;
+    p_Fm->intrMng[event].h_SrcHandle = h_Arg;
+}
+
+void  FmRegisterFmCtlIntr(t_Handle h_Fm, uint8_t eventRegId, void (*f_Isr) (t_Handle h_Fm, uint32_t event))
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    p_Fm->f_FmCtlIsr[eventRegId] = f_Isr;
+}
+
+void  FmRegisterPcd(t_Handle h_Fm, t_Handle h_FmPcd)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    if(p_Fm->h_Pcd)
+        REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("PCD already set"));
+
+    p_Fm->h_Pcd = h_FmPcd;
+
+}
+
+t_Handle  FmGetPcdHandle(t_Handle h_Fm)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    return p_Fm->h_Pcd;
+
+}
+
+uint8_t FmGetId(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0xff);
+
+    return p_Fm->fmId;
+}
+
+t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortParams)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    tmpReg;
+    uint8_t     hardwarePortId = p_PortParams->hardwarePortId;
+    uint8_t     enqTh;
+    uint8_t     deqTh;
+    bool        update = FALSE;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    /* return parameters */
+    p_PortParams->timeStampPeriod = p_Fm->timeStampPeriod;
+
+    if(p_PortParams->independentMode)
+    {
+        /* set port parameters */
+        p_Fm->independentMode = p_PortParams->independentMode;
+        /* disable dispatch limit */
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmflc, 0);
+    }
+
+    if(p_PortParams->portType == e_FM_PORT_TYPE_HOST_COMMAND)
+    {
+        if(p_Fm->hcPortInitialized)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Only one host command port is allowed."));
+        else
+            p_Fm->hcPortInitialized = TRUE;
+    }
+    p_Fm->portsTypes[hardwarePortId] = p_PortParams->portType;
+
+    /* check that there are enough uncommited tasks */
+    if(p_PortParams->numOfExtraTasks > p_Fm->extraTasksPoolSize)
+        p_Fm->extraTasksPoolSize = p_PortParams->numOfExtraTasks;
+
+    if((p_Fm->accumulatedNumOfTasks + p_PortParams->numOfTasks) > p_Fm->totalNumOfTasks-p_Fm->extraTasksPoolSize)
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested numOfTasks and extra tasks pool exceed total numOfTasks."));
+    else
+    {
+        p_Fm->accumulatedNumOfTasks += p_PortParams->numOfTasks;
+        tmpReg = (uint32_t)(((p_PortParams->numOfTasks-1) << BMI_NUM_OF_TASKS_SHIFT) |
+                    (p_PortParams->numOfExtraTasks << BMI_EXTRA_NUM_OF_TASKS_SHIFT));
+        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1],tmpReg);
+    }
+
+    if((p_PortParams->portType != e_FM_PORT_TYPE_RX) && (p_PortParams->portType != e_FM_PORT_TYPE_RX_10G))
+    /* for transmit & O/H ports */
+    {
+        /* update qmi ENQ/DEQ threshold */
+        p_Fm->accumulatedNumOfDeqTnums += p_PortParams->deqPipelineDepth;
+        tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc);
+        enqTh = (uint8_t)(tmpReg>>8);
+        /* if enqTh is too big, we reduce it to the max value that is still OK */
+        if(enqTh >= (QMI_MAX_NUM_OF_TNUMS - p_Fm->accumulatedNumOfDeqTnums))
+        {
+            enqTh = (uint8_t)(QMI_MAX_NUM_OF_TNUMS - p_Fm->accumulatedNumOfDeqTnums - 1);
+            tmpReg &= ~QMI_CFG_ENQ_MASK;
+            tmpReg |= ((uint32_t)enqTh << 8);
+            update = TRUE;
+        }
+
+        deqTh = (uint8_t)tmpReg;
+        /* if deqTh is too small, we enlarge it to the min value that is still OK.
+         deqTh may not be larger than 63 (QMI_MAX_NUM_OF_TNUMS-1). */
+        if((deqTh <= p_Fm->accumulatedNumOfDeqTnums)  && (deqTh < QMI_MAX_NUM_OF_TNUMS-1))
+        {
+            deqTh = (uint8_t)(p_Fm->accumulatedNumOfDeqTnums + 1);
+            tmpReg &= ~QMI_CFG_DEQ_MASK;
+            tmpReg |= (uint32_t)deqTh;
+            update = TRUE;
+        }
+        if(update)
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc, tmpReg);
+    }
+
+    /* check that there are enough uncommited open DMA's */
+    if(p_PortParams->numOfExtraOpenDmas > p_Fm->extraOpenDmasPoolSize)
+        p_Fm->extraOpenDmasPoolSize = p_PortParams->numOfExtraOpenDmas;
+
+    if((p_Fm->accumulatedNumOfOpenDmas + p_PortParams->numOfOpenDmas) > p_Fm->maxNumOfOpenDmas)
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested numOfOpenDmas exceeds total numOfTasks."));
+    else
+    {
+        p_Fm->accumulatedNumOfOpenDmas += p_PortParams->numOfOpenDmas;
+        tmpReg = (uint32_t)(((p_PortParams->numOfOpenDmas-1) << BMI_NUM_OF_DMAS_SHIFT) |
+                    (p_PortParams->numOfExtraOpenDmas << BMI_EXTRA_NUM_OF_DMAS_SHIFT));
+        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1],
+                GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) | tmpReg);
+        /* update total num of DMA's with committed number of open DMAS, and max uncommitted pool. */
+        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2) & ~BMI_CFG2_DMAS_MASK;
+        tmpReg |= (uint32_t)(p_Fm->accumulatedNumOfOpenDmas + p_Fm->extraOpenDmasPoolSize - 1) << BMI_CFG2_DMAS_SHIFT;
+        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2,  tmpReg);
+    }
+
+    /* we leave FM_MAX_NUM_OF_RX_PORTS spare bufferes for excessive buffers */
+        /* check that there are enough uncommited tasks */
+    if(p_PortParams->extraSizeOfFifo > p_Fm->extraFifoPoolSize)
+        p_Fm->extraTasksPoolSize = p_PortParams->numOfExtraTasks;
+
+    if((p_Fm->accumulatedFifoSize + p_PortParams->sizeOfFifo) > (p_Fm->totalFifoSize - p_Fm->extraTasksPoolSize))
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested fifo size and extra size exceed total fifo size."));
+    else
+    {
+        p_Fm->accumulatedFifoSize += p_PortParams->sizeOfFifo;
+        tmpReg = (uint32_t)((p_PortParams->sizeOfFifo/BMI_FIFO_UNITS - 1) | ((p_PortParams->extraSizeOfFifo/BMI_FIFO_UNITS) << BMI_FIFO_SIZE_SHIFT));
+        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], tmpReg);
+    }
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1], (uint32_t)p_PortParams->portPartition);
+
+    tmpReg = (uint32_t)(hardwarePortId << FPM_PORT_FM_CTL_PORTID_SHIFT);
+    if(p_PortParams->independentMode)
+    {
+        if((p_PortParams->portType==e_FM_PORT_TYPE_RX) || (e_FM_PORT_TYPE_RX_10G))
+            tmpReg |= (FPM_PORT_FM_CTL1 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) |FPM_PORT_FM_CTL1;
+        else
+            tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) |FPM_PORT_FM_CTL2;
+    }
+    else
+    {
+        tmpReg |= (FPM_PORT_FM_CTL2|FPM_PORT_FM_CTL1);
+
+        /* order restoration */
+        if(hardwarePortId%2)
+            tmpReg |= (FPM_PORT_FM_CTL1 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT);
+        else
+            tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT);
+    }
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmpr, tmpReg);
+
+    FmGetPhysicalMuramBase(p_Fm, &p_PortParams->fmMuramPhysBaseAddr);
+
+    return E_OK;
+}
+
+void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    tmpReg;
+    uint8_t     hardwarePortId = p_PortParams->hardwarePortId;
+    uint8_t     enqTh;
+    uint8_t     deqTh;
+    uint8_t     numOfTasks;
+
+    SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
+
+    if(p_PortParams->portType == e_FM_PORT_TYPE_HOST_COMMAND)
+    {
+        ASSERT_COND(p_Fm->hcPortInitialized);
+        p_Fm->hcPortInitialized = FALSE;
+    }
+
+    p_Fm->portsTypes[hardwarePortId] = e_FM_PORT_TYPE_DUMMY;
+
+    tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]);
+    /* free numOfTasks */
+    numOfTasks = (uint8_t)(((tmpReg & BMI_NUM_OF_TASKS_MASK) >> BMI_NUM_OF_TASKS_SHIFT) + 1);
+    ASSERT_COND(p_Fm->accumulatedNumOfTasks >= numOfTasks);
+    p_Fm->accumulatedNumOfTasks -= numOfTasks;
+
+    /* free numOfOpenDmas */
+    ASSERT_COND(p_Fm->accumulatedNumOfOpenDmas >= ((tmpReg & BMI_NUM_OF_DMAS_MASK) >> BMI_NUM_OF_DMAS_SHIFT));
+    p_Fm->accumulatedNumOfOpenDmas -= ((tmpReg & BMI_NUM_OF_DMAS_MASK) >> BMI_NUM_OF_DMAS_SHIFT);
+    tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1]);
+    /* free sizeOfFifo */
+    ASSERT_COND(p_Fm->accumulatedFifoSize >= ((tmpReg & BMI_FIFO_SIZE_MASK) + 1)*BMI_FIFO_UNITS);
+    p_Fm->accumulatedFifoSize -= ((tmpReg & BMI_FIFO_SIZE_MASK) + 1)*BMI_FIFO_UNITS;
+
+    /* clear registers */
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], 0);
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], 0);
+    //WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1], 0);
+
+    if((p_PortParams->portType != e_FM_PORT_TYPE_RX) && (p_PortParams->portType != e_FM_PORT_TYPE_RX_10G))
+    /* for transmit & O/H ports */
+    {
+        tmpReg = 0;
+        /* update qmi ENQ/DEQ threshold */
+        p_Fm->accumulatedNumOfDeqTnums -= p_PortParams->deqPipelineDepth;
+
+        /* p_Fm->accumulatedNumOfDeqTnums is now smaller,
+           so we can enlarge enqTh */
+        enqTh = (uint8_t)(QMI_MAX_NUM_OF_TNUMS - p_Fm->accumulatedNumOfDeqTnums - 1);
+        tmpReg &= ~QMI_CFG_ENQ_MASK;
+        tmpReg |= ((uint32_t)enqTh << QMI_CFG_ENQ_SHIFT);
+
+         /* p_Fm->accumulatedNumOfDeqTnums is now smaller,
+           so we can reduce enqTh */
+        deqTh = (uint8_t)(p_Fm->accumulatedNumOfDeqTnums + 1);
+        tmpReg &= ~QMI_CFG_DEQ_MASK;
+        tmpReg |= (uint32_t)deqTh;
+
+        WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc, tmpReg);
+    }
+
+    return;
+}
+
+
+bool FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    tmpReg;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, FALSE);
+
+    tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_ps[hardwarePortId]);
+
+    return (bool)!!(tmpReg & FPM_PS_STALLED);
+}
+
+t_Error FmResumeStalledPort(t_Handle h_Fm, uint8_t hardwarePortId)
+{
+    t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+    uint32_t                tmpReg;
+
+    /* Get port status */
+    if (!FmIsPortStalled(h_Fm, hardwarePortId))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port is not stalled"));
+
+    tmpReg = (uint32_t)((hardwarePortId << FPM_PORT_FM_CTL_PORTID_SHIFT) | FPM_PRC_REALSE_STALLED);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmpr, tmpReg);
+
+    return E_OK;
+}
+
+t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    bitMask;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    /* Get the relevant bit mask */
+    if (type == e_FM_MAC_10G)
+    {
+        switch(macId)
+        {
+            case(0):
+                bitMask = FPM_RSTC_10G0_RESET;
+                break;
+            default:
+                RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Illegal MAC Id"));
+               break;
+        }
+    }
+    else
+    {
+        switch(macId)
+        {
+            case(0):
+                bitMask = FPM_RSTC_1G0_RESET;
+                break;
+            case(1):
+                bitMask = FPM_RSTC_1G1_RESET;
+                break;
+            case(2):
+                bitMask = FPM_RSTC_1G2_RESET;
+                break;
+            case(3):
+                bitMask = FPM_RSTC_1G3_RESET;
+                break;
+            default:
+                RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Illegal MAC Id"));
+                break;
+        }
+    }
+
+    /* reset */
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrstc, bitMask);
+
+    return E_OK;
+}
+
+uint32_t    FmGetTimeStampPeriod(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(p_Fm->timeStampPeriod, E_INVALID_HANDLE, 0);
+
+    return p_Fm->timeStampPeriod;
+}
+
+bool FmRamsEccIsExternalCtl(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    tmpReg;
+
+    tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
+    if(tmpReg & FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL)
+        return TRUE;
+    else
+        return FALSE;
+}
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FmDumpPortRegs (t_Handle h_Fm,uint8_t hardwarePortId)
+{
+    t_Fm *p_Fm = (t_Fm *)h_Fm;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    DUMP_TITLE(&p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], ("fmbm_pp for port %d", (hardwarePortId)));
+    DUMP_MEMORY(&p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], sizeof(uint32_t));
+
+    DUMP_TITLE(&p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], ("fmbm_pfs for port %d", (hardwarePortId )));
+    DUMP_MEMORY(&p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], sizeof(uint32_t));
+
+    DUMP_TITLE(&p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1], ("bm_ppid for port %d", (hardwarePortId)));
+    DUMP_MEMORY(&p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1], sizeof(uint32_t));
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+
+/****************************************/
+/*       API Init unit functions        */
+/****************************************/
+t_Handle FM_Config(t_FmParams *p_FmParam)
+{
+    t_Fm        *p_Fm;
+    uint8_t     i;
+    uint64_t    baseAddr = p_FmParam->baseAddr;
+
+    SANITY_CHECK_RETURN_VALUE(((p_FmParam->firmware.p_Code && p_FmParam->firmware.size) ||
+                               (!p_FmParam->firmware.p_Code && !p_FmParam->firmware.size)),
+                              E_INVALID_VALUE, NULL);
+
+    /* Allocate FM structure */
+    p_Fm = (t_Fm *) XX_Malloc(sizeof(t_Fm));
+    if (!p_Fm)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM driver structure"));
+        return NULL;
+    }
+    memset(p_Fm, 0, sizeof(t_Fm));
+
+    /* Allocate the FM driver's parameters structure */
+    p_Fm->p_FmDriverParam = (t_FmDriverParam *)XX_Malloc(sizeof(t_FmDriverParam));
+    if (!p_Fm->p_FmDriverParam)
+    {
+        XX_Free(p_Fm);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM driver parameters"));
+        return NULL;
+    }
+    memset(p_Fm->p_FmDriverParam, 0, sizeof(t_FmDriverParam));
+
+    /* Initialize FM parameters which will be kept by the driver */
+    p_Fm->fmId              = p_FmParam->fmId;
+    p_Fm->h_FmMuram         = p_FmParam->h_FmMuram;
+    p_Fm->h_App             = p_FmParam->h_App;
+    p_Fm->fmClkFreq         = p_FmParam->fmClkFreq;
+    p_Fm->f_Exceptions      = p_FmParam->f_Exceptions;
+    p_Fm->f_BusError        = p_FmParam->f_BusError;
+    p_Fm->p_FmFpmRegs       = CAST_UINT64_TO_POINTER_TYPE(t_FmFpmRegs, (baseAddr + FM_MM_FPM));
+    p_Fm->p_FmBmiRegs       = CAST_UINT64_TO_POINTER_TYPE(t_FmBmiRegs, (baseAddr + FM_MM_BMI));
+    p_Fm->p_FmQmiRegs       = CAST_UINT64_TO_POINTER_TYPE(t_FmQmiRegs, (baseAddr + FM_MM_QMI));
+    p_Fm->p_FmDmaRegs       = CAST_UINT64_TO_POINTER_TYPE(t_FmDmaRegs, (baseAddr + FM_MM_DMA));
+    p_Fm->baseAddr          = baseAddr;
+    p_Fm->irq               = p_FmParam->irq;
+    p_Fm->errIrq            = p_FmParam->errIrq;
+    p_Fm->hcPortInitialized = FALSE;
+    p_Fm->independentMode   = FALSE;
+    p_Fm->ramsEccEnable     = FALSE;
+    p_Fm->totalNumOfTasks   = DEFAULT_totalNumOfTasks;
+    p_Fm->totalFifoSize     = DEFAULT_totalFifoSize;
+    p_Fm->maxNumOfOpenDmas  = DEFAULT_maxNumOfOpenDmas;
+    p_Fm->extraFifoPoolSize     = FM_MAX_NUM_OF_RX_PORTS*BMI_FIFO_UNITS;
+
+    p_Fm->exceptions        = DEFAULT_exceptions;
+    for(i = 0;i<FM_MAX_NUM_OF_PORTS;i++)
+        p_Fm->portsTypes[i] = e_FM_PORT_TYPE_DUMMY;
+    /* Initialize FM driver parameters parameters (for initialization phase only) */
+    memcpy(p_Fm->p_FmDriverParam->liodnPerPartition, p_FmParam->liodnPerPartition, FM_MAX_NUM_OF_PARTITIONS);
+
+    /*p_Fm->p_FmDriverParam->numOfPartitions                      = p_FmParam->numOfPartitions;    */
+    p_Fm->p_FmDriverParam->enCounters                           = FALSE;
+
+    p_Fm->p_FmDriverParam->resetOnInit                          = DEFAULT_resetOnInit;
+
+    p_Fm->p_FmDriverParam->thresholds.dispLimit                 = DEFAULT_dispLimit;
+    p_Fm->p_FmDriverParam->thresholds.prsDispTh                 = DEFAULT_prsDispTh;
+    p_Fm->p_FmDriverParam->thresholds.plcrDispTh                = DEFAULT_plcrDispTh;
+    p_Fm->p_FmDriverParam->thresholds.kgDispTh                  = DEFAULT_kgDispTh;
+    p_Fm->p_FmDriverParam->thresholds.bmiDispTh                 = DEFAULT_bmiDispTh;
+    p_Fm->p_FmDriverParam->thresholds.qmiEnqDispTh              = DEFAULT_qmiEnqDispTh;
+    p_Fm->p_FmDriverParam->thresholds.qmiDeqDispTh              = DEFAULT_qmiDeqDispTh;
+    p_Fm->p_FmDriverParam->thresholds.fmCtl1DispTh               = DEFAULT_fmCtl1DispTh;
+    p_Fm->p_FmDriverParam->thresholds.fmCtl2DispTh               = DEFAULT_fmCtl2DispTh;
+
+    p_Fm->p_FmDriverParam->enTimeStamp                          = FALSE;
+
+    p_Fm->p_FmDriverParam->dmaStopOnBusError                    = DEFAULT_dmaStopOnBusError;
+    p_Fm->p_FmDriverParam->dmaBusProtect.privilegeBusProtect    = DEFAULT_privilegeBusProtect;
+    p_Fm->p_FmDriverParam->dmaBusProtect.busProtectType         = DEFAULT_busProtectionType;
+
+    p_Fm->p_FmDriverParam->dmaCacheOverride                     = DEFAULT_cacheOverride;
+    p_Fm->p_FmDriverParam->dmaAidMode                           = DEFAULT_aidMode;
+    p_Fm->p_FmDriverParam->dmaAidOverride                       = DEFAULT_aidOverride;
+    p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats                  = DEFAULT_axiDbgNumOfBeats;
+    p_Fm->p_FmDriverParam->dmaCamNumOfEntries                   = DEFAULT_dmaCamNumOfEntries;
+    if(p_Fm->fmClkFreq)
+        p_Fm->p_FmDriverParam->dmaWatchdog                      = 0xffffffff/p_Fm->fmClkFreq; /* max possible */
+    else
+    {
+        XX_Free(p_Fm->p_FmDriverParam);
+        XX_Free(p_Fm);
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("fmClkFreq can't be '0'"));
+        return NULL;
+    }
+    p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency               = DEFAULT_dmaCommQLow;
+    p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency              = DEFAULT_dmaCommQHigh;
+    p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency             = DEFAULT_dmaReadIntBufLow;
+    p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency            = DEFAULT_dmaReadIntBufHigh;
+    p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency            = DEFAULT_dmaWriteIntBufLow;
+    p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency           = DEFAULT_dmaWriteIntBufHigh;
+    p_Fm->p_FmDriverParam->dmaSosEmergency                      = DEFAULT_dmaSosEmergency;
+
+    p_Fm->p_FmDriverParam->dmaDbgCntMode                        = DEFAULT_dmaDbgCntMode;
+
+    p_Fm->p_FmDriverParam->dmaEnEmergency                       = FALSE;
+    p_Fm->p_FmDriverParam->dmaEnEmergencySmoother               = FALSE;
+    p_Fm->p_FmDriverParam->catastrophicErr                      = DEFAULT_catastrophicErr;
+    p_Fm->p_FmDriverParam->dmaErr                               = DEFAULT_dmaErr;
+    p_Fm->p_FmDriverParam->haltOnExternalActivation             = DEFAULT_haltOnExternalActivation;
+    p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError          = DEFAULT_haltOnUnrecoverableEccError;
+
+    p_Fm->p_FmDriverParam->enIramTestMode                       = FALSE;
+    p_Fm->p_FmDriverParam->enMuramTestMode                      = FALSE;
+    p_Fm->p_FmDriverParam->externalEccRamsEnable                = DEFAULT_externalEccRamsEnable;
+
+     p_Fm->p_FmDriverParam->firmware.size = p_FmParam->firmware.size;
+     if (p_Fm->p_FmDriverParam->firmware.size)
+     {
+         p_Fm->p_FmDriverParam->firmware.p_Code = (uint32_t *)XX_Malloc(p_Fm->p_FmDriverParam->firmware.size);
+        if (!p_Fm->p_FmDriverParam->firmware.p_Code)
+        {
+            XX_Free(p_Fm->p_FmDriverParam);
+            XX_Free(p_Fm);
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM firmware code"));
+            return NULL;
+        }
+         memcpy(p_Fm->p_FmDriverParam->firmware.p_Code ,p_FmParam->firmware.p_Code ,p_Fm->p_FmDriverParam->firmware.size);
+     }
+
+#ifdef CONFIG_GUEST_PARTITION
+    /* register to inter-core messaging mechanism */
+    memset(p_Fm->fmModuleName, 0, MODULE_NAME_SIZE);
+    if(Sprint (p_Fm->fmModuleName, "FM-%d",p_Fm->fmId) != 4)
+    {
+        XX_Free(p_Fm->p_FmDriverParam);
+        XX_Free(p_Fm);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+        return NULL;
+    }
+#endif /* CONFIG_GUEST_PARTITION */
+
+    return p_Fm;
+}
+
+/**************************************************************************//**
+ @Function      FM_Init
+
+ @Description   Initializes the FM module
+
+ @Param[in]     h_Fm - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_Init(t_Handle h_Fm)
+{
+    t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+    t_FmDriverParam         *p_FmDriverParam = NULL;
+#ifdef FM_MASTER_PARTITION
+    t_Error                 err;
+#endif /* FM_MASTER_PARTITION */
+    uint32_t                tmpReg, cfgReg = 0;
+    int                     i;
+    uint64_t                fraction;
+    uint32_t                prescalar, integer, period;
+
+    SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    CHECK_INIT_PARAMETERS(p_Fm, CheckFmParameters);
+
+    p_FmDriverParam = p_Fm->p_FmDriverParam;
+
+    if(p_FmDriverParam->resetOnInit)
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrstc, FPM_RSTC_FM_RESET);
+
+    /**********************/
+    /* Load patch to Iram */
+    /**********************/
+    if (p_Fm->p_FmDriverParam->firmware.p_Code)
+        LoadPatch(p_Fm);
+
+    /* General FM driver initialization */
+    p_Fm->fmMuramPhysBaseAddr = CAST_POINTER_TO_UINT64(XX_VirtToPhys(CAST_UINT64_TO_POINTER(p_Fm->baseAddr + FM_MM_MURAM)));
+    for(i=0;i<e_FM_EV_DUMMY_LAST;i++)
+        p_Fm->intrMng[i].f_Isr = UnimplementedIsr;
+    for(i=0;i<NUM_OF_FM_CTL_EVENT_REGS;i++)
+        p_Fm->f_FmCtlIsr[i] = UnimplementedFmCtlIsr;
+
+    /**********************/
+    /* Init DMA Registers */
+    /**********************/
+    /* clear status reg events */
+    tmpReg = (DMA_STATUS_BUS_ERR | DMA_STATUS_READ_ECC | DMA_STATUS_SYSTEM_WRITE_ECC | DMA_STATUS_FM_WRITE_ECC);
+  //  tmpReg |= (DMA_STATUS_SYSTEM_DPEXT_ECC | DMA_STATUS_FM_DPEXT_ECC | DMA_STATUS_SYSTEM_DPDAT_ECC | DMA_STATUS_FM_DPDAT_ECC | DMA_STATUS_FM_SPDAT_ECC);
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsr) | tmpReg);
+
+    /* configure mode register */
+    tmpReg = 0;
+    tmpReg |= p_FmDriverParam->dmaCacheOverride << DMA_MODE_CACHE_OR_SHIFT;
+    if(p_FmDriverParam->dmaAidOverride)
+    {
+        tmpReg |= DMA_MODE_AID_OR;
+    }
+    if (p_Fm->exceptions & FM_EX_DMA_BUS_ERROR)
+    {
+        tmpReg |= DMA_MODE_BER;
+    }
+    if ((p_Fm->exceptions & FM_EX_DMA_SYSTEM_WRITE_ECC) | (p_Fm->exceptions & FM_EX_DMA_READ_ECC) | (p_Fm->exceptions & FM_EX_DMA_FM_WRITE_ECC))
+    {
+        tmpReg |= DMA_MODE_ECC;
+    }
+    if(p_FmDriverParam->dmaStopOnBusError)
+        tmpReg |= DMA_MODE_SBER;
+    tmpReg |= (uint32_t)(p_FmDriverParam->dmaAxiDbgNumOfBeats - 1) << DMA_MODE_AXI_DBG_SHIFT;
+    if (p_FmDriverParam->dmaEnEmergency)
+    {
+        tmpReg |= p_FmDriverParam->dmaEmergency.emergencyBusSelect;
+        tmpReg |= p_FmDriverParam->dmaEmergency.emergencyLevel << DMA_MODE_EMERGENCY_LEVEL_SHIFT;
+        if(p_FmDriverParam->dmaEnEmergencySmoother)
+            WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmemsr, p_FmDriverParam->dmaEmergencySwitchCounter);
+     }
+    tmpReg |= ((p_FmDriverParam->dmaCamNumOfEntries/DMA_CAM_UNITS) - 1) << DMA_MODE_CEN_SHIFT;
+
+    if(p_FmDriverParam->dmaBusProtect.privilegeBusProtect)
+        tmpReg |= DMA_MODE_PRIVILEGE_PROT;
+    tmpReg |= DMA_MODE_SECURE_PROT;
+    tmpReg |= p_FmDriverParam->dmaBusProtect.busProtectType << DMA_MODE_BUS_PROT_SHIFT;
+    tmpReg |= p_FmDriverParam->dmaDbgCntMode << DMA_MODE_DBG_SHIFT;
+    tmpReg |= p_FmDriverParam->dmaAidMode << DMA_MODE_AID_MODE_SHIFT;
+
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, tmpReg);
+
+    /* configure thresholds register */
+    tmpReg = ((uint32_t)p_FmDriverParam->dmaCommQThresholds.assertEmergency << DMA_THRESH_COMMQ_SHIFT) |
+                ((uint32_t)p_FmDriverParam->dmaReadBufThresholds.assertEmergency << DMA_THRESH_READ_INT_BUF_SHIFT) |
+                ((uint32_t)p_FmDriverParam->dmaWriteBufThresholds.assertEmergency);
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmtr, tmpReg);
+
+    /* configure hysteresis register */
+    tmpReg = ((uint32_t)p_FmDriverParam->dmaCommQThresholds.clearEmergency << DMA_THRESH_COMMQ_SHIFT) |
+                ((uint32_t)p_FmDriverParam->dmaReadBufThresholds.clearEmergency << DMA_THRESH_READ_INT_BUF_SHIFT) |
+                ((uint32_t)p_FmDriverParam->dmaWriteBufThresholds.clearEmergency);
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmhy, tmpReg);
+
+    /* configure emergency threshold */
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsetr, p_FmDriverParam->dmaSosEmergency);
+
+    /* configure Watchdog */
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmwcr, USEC_TO_CLK(p_FmDriverParam->dmaWatchdog, p_Fm->fmClkFreq));
+
+    /* Allocate MURAM for CAM */
+    p_Fm->camBaseAddr = CAST_POINTER_TO_UINT64(FM_MURAM_AllocMem(p_Fm->h_FmMuram,
+                                                                 (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*DMA_CAM_SIZEOF_ENTRY),
+                                                                 DMA_CAM_ALIGN));
+    if (!p_Fm->camBaseAddr )
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for DMA CAM failed"));
+
+#ifndef VERIFICATION_SUPPORT
+    WRITE_BLOCK(CAST_UINT64_TO_POINTER_TYPE(uint8_t, p_Fm->camBaseAddr), 0, (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*DMA_CAM_SIZEOF_ENTRY));
+#endif /* VERIFICATION_SUPPORT */
+    /* VirtToPhys */
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmebcr,
+                 (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(CAST_UINT64_TO_POINTER(p_Fm->camBaseAddr))) -
+                            p_Fm->fmMuramPhysBaseAddr));
+
+    /* liodn-partitions */
+    for (i=0 ; i<FM_MAX_NUM_OF_PARTITIONS ; i+=2)
+    {
+        tmpReg = (((uint32_t)p_FmDriverParam->liodnPerPartition[i] << DMA_LIODN_SHIFT) |
+                    (uint32_t)p_FmDriverParam->liodnPerPartition[i+1]);
+        WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[i/2], tmpReg);
+    }
+
+    /**********************/
+    /* Init FPM Registers */
+    /**********************/
+    tmpReg = (uint32_t)(p_FmDriverParam->thresholds.dispLimit << FPM_DISP_LIMIT_SHIFT);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmflc, tmpReg);
+
+    tmpReg =   (((uint32_t)p_FmDriverParam->thresholds.prsDispTh  << FPM_THR1_PRS_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.kgDispTh  << FPM_THR1_KG_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.plcrDispTh  << FPM_THR1_PLCR_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.bmiDispTh  << FPM_THR1_BMI_SHIFT));
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmdis1, tmpReg);
+
+    tmpReg =   (((uint32_t)p_FmDriverParam->thresholds.qmiEnqDispTh  << FPM_THR2_QMI_ENQ_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.qmiDeqDispTh  << FPM_THR2_QMI_DEQ_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.fmCtl1DispTh  << FPM_THR2_FM_CTL1_SHIFT) |
+                ((uint32_t)p_FmDriverParam->thresholds.fmCtl2DispTh  << FPM_THR2_FM_CTL2_SHIFT));
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmdis2, tmpReg);
+
+    /* define exceptions and error behavior */
+    tmpReg = 0;
+    /* Clear events */
+    tmpReg |= (FPM_EV_MASK_STALL | FPM_EV_MASK_DOUBLE_ECC | FPM_EV_MASK_SINGLE_ECC);
+    /* enable interrupts */
+    if(p_Fm->exceptions & FM_EX_FPM_STALL_ON_TASKS)
+    {
+        tmpReg |= FPM_EV_MASK_STALL_EN;
+    }
+    if(p_Fm->exceptions & FM_EX_FPM_SINGLE_ECC)
+    {
+        tmpReg |= FPM_EV_MASK_SINGLE_ECC_EN;
+    }
+    if(p_Fm->exceptions & FM_EX_FPM_DOUBLE_ECC)
+    {
+        tmpReg |= FPM_EV_MASK_DOUBLE_ECC_EN ;
+    }
+    tmpReg |= (p_Fm->p_FmDriverParam->catastrophicErr  << FPM_EV_MASK_CAT_ERR_SHIFT);
+    tmpReg |= (p_Fm->p_FmDriverParam->dmaErr << FPM_EV_MASK_DMA_ERR_SHIFT);
+    if(p_Fm->p_FmDriverParam->haltOnExternalActivation)
+        tmpReg |= FPM_EV_MASK_EXTERNAL_HALT;
+    if(p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError)
+        tmpReg |= FPM_EV_MASK_ECC_ERR_HALT;
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg);
+
+    /* clear all fmCtls event registers */
+    for(i=0;i<NUM_OF_FM_CTL_EVENT_REGS;i++)
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmcev[i], 0xFFFFFFFF);
+
+    /* timeStamp */
+    if(p_FmDriverParam->enTimeStamp)
+    {
+        period = p_Fm->timeStampPeriod;
+
+        /* calculate the prescalar, considering fmClkFreq is in Mhz, and
+        timeStampPeriod is in nanoseconds */
+        prescalar = (period * p_Fm->fmClkFreq)/1000;
+        if(!prescalar)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("timeStampPeriod is too small"));
+        if(prescalar > 256)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("timeStampPeriod is too large"));
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmtsc1, (uint32_t)((prescalar - 1) | FPM_TS_CTL_EN));
+
+        /* the FM HW allows to increase precision by enlarging timeStamp value by value
+        different than 1, possibly by fraction. */
+        integer  = (prescalar * 1000)/ (period * p_Fm->fmClkFreq); /* always 0 */
+        if(integer > 255)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("timeStampPeriod  is too large"));
+
+        /* Since the prescalar may have been be rounded down, we increase the timeStamp by
+        value smaller than the resolution required (and smaller than 1 when resolution is normally 1).
+        Here we calculate the fraction that will give us the nearest result.
+        Since we prefer not to use floating variables, we need to multiply by a large factor in
+        order to get a precise enough number. Since the HW implementation uses 24-bit-fixed-point
+        representation, a 16 bit fraction is used. In order to calculate the fraction value, we should
+        multiply the number by 2^16. We therefor use the 2^16 also as the factor for
+        the multiplication, and do not use another one for enlarging the fraction. */
+        fraction = ((uint64_t)((uint64_t)(prescalar * 1000) << 16)/ (period * p_Fm->fmClkFreq)) - (integer << 16);
+        ASSERT_COND((fraction & ~FPM_TS_FRACTION_MASK) == 0);
+        tmpReg = (integer << FPM_TS_INT_SHIFT) | (uint16_t)fraction;
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmtsc2, tmpReg);
+    }
+
+#ifndef VERIFICATION_SUPPORT
+    /* RAM ECC -  enable and clear events*/
+    /* first we need to clear all parser memory, as it is uninitialized and
+    may cause ECC errors */
+    for(i=0;i<FM_SW_PRS_SIZE;i+=4)
+        WRITE_UINT32(*CAST_UINT64_TO_POINTER_TYPE(uint32_t, (p_Fm->baseAddr + FM_MM_PRS + i)), 0);
+
+    tmpReg = 0;
+    if(p_Fm->exceptions & FM_EX_IRAM_ECC)
+    {
+        p_Fm->ramsEccEnable = TRUE;
+        tmpReg |= FPM_IRAM_ECC_ERR_EX_EN;
+    }
+    if(p_Fm->exceptions & FM_EX_NURAM_ECC)
+    {
+        p_Fm->ramsEccEnable = TRUE;
+        tmpReg |= FPM_MURAM_ECC_ERR_EX_EN;
+    }
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmeie, tmpReg);
+
+    /* event bits */
+    tmpReg = (FPM_RAM_CTL_MURAM_ECC | FPM_RAM_CTL_IRAM_ECC);
+    /* enable ECC */
+    if(p_Fm->ramsEccEnable)
+        tmpReg |= (FPM_RAM_CTL_RAMS_ECC_EN | FPM_RAM_CTL_IRAM_ECC_EN);
+    /* Rams enable is not effected by the RCR bit, but by a COP configuration */
+    if(p_Fm->p_FmDriverParam->externalEccRamsEnable)
+        tmpReg |= FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL;
+
+    /* enable test mode */
+    if(p_FmDriverParam->enMuramTestMode)
+        tmpReg |= FPM_RAM_CTL_MURAM_TEST_ECC;
+    if(p_FmDriverParam->enIramTestMode)
+        tmpReg |= FPM_RAM_CTL_IRAM_TEST_ECC;
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg);
+#endif  /*  VERIFICATION_SUPPORT */
+
+    /**********************/
+    /* Init BMI Registers */
+    /**********************/
+
+    /* define common resources */
+    /* allocate MURAM for FIFO according to total size */
+    p_Fm->fifoBaseAddr = CAST_POINTER_TO_UINT64(FM_MURAM_AllocMem(p_Fm->h_FmMuram,
+                                                                  p_Fm->totalFifoSize,
+                                                                  BMI_FIFO_ALIGN));
+    if (!p_Fm->fifoBaseAddr)
+    {
+        FmFreeInitResources(p_Fm);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for FIFO failed"));
+    }
+
+    tmpReg = (uint32_t)(CAST_POINTER_TO_UINT64(XX_VirtToPhys(CAST_UINT32_TO_POINTER(p_Fm->fifoBaseAddr))) - p_Fm->fmMuramPhysBaseAddr);
+    tmpReg = tmpReg / BMI_FIFO_ALIGN;
+
+    tmpReg |= ((p_Fm->totalFifoSize/BMI_FIFO_UNITS - 1) << BMI_CFG1_FIFO_SIZE_SHIFT);
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg1, tmpReg);
+
+    tmpReg =  ((uint32_t)(p_Fm->totalNumOfTasks - 1) << BMI_CFG2_TASKS_SHIFT );
+    /* num of DMA's will be dynamically updated when each port is set */
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2, tmpReg);
+
+    /* define unmaskable exceptions, enable and clear events */
+    tmpReg = 0;
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr, (BMI_ERR_INTR_EN_LIST_RAM_ECC|BMI_ERR_INTR_EN_PIPELINE_ECC|BMI_ERR_INTR_EN_STATISTICS_RAM_ECC));
+    if(p_Fm->exceptions & FM_EX_BMI_LIST_RAM_ECC)
+    {
+        tmpReg |= BMI_ERR_INTR_EN_LIST_RAM_ECC;
+    }
+    if(p_Fm->exceptions & FM_EX_BMI_PIPELINE_ECC)
+    {
+        tmpReg |= BMI_ERR_INTR_EN_PIPELINE_ECC;
+    }
+    if(p_Fm->exceptions & FM_EX_BMI_STATISTICS_RAM_ECC)
+    {
+        tmpReg |= BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
+    }
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
+
+    /**********************/
+    /* Init QMI Registers */
+    /**********************/
+     /* Clear error interrupt events */
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eie, (QMI_ERR_INTR_EN_DOUBLE_ECC | QMI_ERR_INTR_EN_DEQ_FROM_DEF));
+    tmpReg = 0;
+    if(p_Fm->exceptions & FM_EX_QMI_DEQ_FROM_DEFQ)
+    {
+        tmpReg |= QMI_ERR_INTR_EN_DEQ_FROM_DEF;
+    }
+    if(p_Fm->exceptions & FM_EX_QMI_DOUBLE_ECC)
+    {
+        tmpReg |= QMI_ERR_INTR_EN_DOUBLE_ECC;
+    }
+    /* enable events */
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien, tmpReg);
+
+    tmpReg = 0;
+    /* Clear interrupt events */
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie, QMI_INTR_EN_SINGLE_ECC);
+    if(p_Fm->exceptions & FM_EX_QMI_SINGLE_ECC)
+    {
+        tmpReg |= QMI_INTR_EN_SINGLE_ECC;
+    }
+    /* enable events */
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien, tmpReg);
+
+    /* clear & enable global counters  - calculate reg and save for later,
+       because it's the same reg for QMI enable */
+    if(p_Fm->p_FmDriverParam->enCounters)
+        cfgReg = QMI_CFG_EN_COUNTERS;
+
+    cfgReg |= (uint32_t)(((QMI_DEF_TNUMS_THRESH) << 8) |  (uint32_t)QMI_DEF_TNUMS_THRESH);
+
+    if (p_Fm->irq != NO_IRQ)
+    {
+        XX_SetIntr(p_Fm->irq, FM_Isr, p_Fm);
+        XX_EnableIntr(p_Fm->irq);
+    }
+
+    if (p_Fm->errIrq != NO_IRQ)
+    {
+        XX_SetIntr(p_Fm->errIrq, FM_Isr, p_Fm);
+        XX_EnableIntr(p_Fm->errIrq);
+    }
+
+#ifdef FM_MASTER_PARTITION
+    err = XX_RegisterMessageHandler(p_Fm->fmModuleName, FmHandleIpcMsg, p_Fm);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+#endif /* FM_MASTER_PARTITION */
+
+    /**********************/
+    /* Enable all modules */
+    /**********************/
+    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_init, BMI_INIT_START);
+    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc, cfgReg | QMI_CFG_ENQ_EN | QMI_CFG_DEQ_EN);
+
+    if (p_Fm->p_FmDriverParam->firmware.p_Code)
+    {
+        XX_Free(p_Fm->p_FmDriverParam->firmware.p_Code);
+        p_Fm->p_FmDriverParam->firmware.p_Code = NULL;
+    }
+
+    XX_Free(p_Fm->p_FmDriverParam);
+    p_Fm->p_FmDriverParam = NULL;
+
+    return E_OK;
+}
+
+/**************************************************************************//**
+ @Function      FM_Free
+
+ @Description   Frees all resources that were assigned to FM module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_Fm - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_Free(t_Handle h_Fm)
+{
+   t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    if (!p_Fm)
+        return ERROR_CODE(E_INVALID_HANDLE);
+
+#ifdef FM_MASTER_PARTITION
+    XX_UnregisterMessageHandler(p_Fm->fmModuleName);
+#endif /* FM_MASTER_PARTITION */
+
+    if(p_Fm->p_FmDriverParam)
+    {
+        XX_Free(p_Fm->p_FmDriverParam);
+        p_Fm->p_FmDriverParam = NULL;
+    }
+    FmFreeInitResources(p_Fm);
+
+    XX_Free(p_Fm);
+
+    return E_OK;
+}
+
+/*************************************************/
+/*       API Advanced Init unit functions        */
+/*************************************************/
+
+t_Error FM_ConfigResetOnInit(t_Handle h_Fm, bool enable)
+{
+
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->resetOnInit = enable;
+
+    return E_OK;
+}
+
+#if 0
+t_Error FM_ConfigIndependentMode(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+    return E_OK;
+}
+#endif /* 0 */
+
+t_Error FM_ConfigTotalNumOfTasks(t_Handle h_Fm, uint8_t totalNumOfTasks)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->totalNumOfTasks = totalNumOfTasks;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigTotalFifoSize(t_Handle h_Fm, uint32_t totalFifoSize)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->totalFifoSize = totalFifoSize;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigMaxNumOfOpenDmas(t_Handle h_Fm, uint8_t maxNumOfOpenDmas)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->maxNumOfOpenDmas = maxNumOfOpenDmas;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_Fm->p_FmDriverParam->thresholds, p_FmThresholds, sizeof(t_FmThresholds));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigTimeStamp(t_Handle h_Fm, uint32_t timeStampPeriod)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->enTimeStamp = TRUE;
+    p_Fm->timeStampPeriod = timeStampPeriod;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaBusProtect(t_Handle h_Fm, t_FmDmaBusProtect *p_FmDmaBusProtect)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_Fm->p_FmDriverParam->dmaBusProtect, p_FmDmaBusProtect, sizeof(t_FmDmaBusProtect));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaCacheOverride(t_Handle h_Fm, e_FmDmaCacheOverride cacheOverride)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaCacheOverride = cacheOverride;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaAidOverride(t_Handle h_Fm, bool aidOverride)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaAidOverride = aidOverride;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaAidMode(t_Handle h_Fm, e_FmDmaAidMode aidMode)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaAidMode = aidMode;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaAxiDbgNumOfBeats(t_Handle h_Fm, uint8_t axiDbgNumOfBeats)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats = axiDbgNumOfBeats;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaCamNumOfEntries(t_Handle h_Fm, uint8_t numOfEntries)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaCamNumOfEntries = numOfEntries;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaWatchdog(t_Handle h_Fm, uint32_t watchdogValue)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaWatchdog = watchdogValue;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
+
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_Fm->p_FmDriverParam->dmaWriteBufThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaCommQThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_Fm->p_FmDriverParam->dmaCommQThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaReadBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_Fm->p_FmDriverParam->dmaReadBufThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaEmergency(t_Handle h_Fm, t_FmDmaEmergency *p_Emergency)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaEnEmergency = TRUE;
+    memcpy(&p_Fm->p_FmDriverParam->dmaEmergency, p_Emergency, sizeof(t_FmDmaEmergency));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaEmergencySmoother(t_Handle h_Fm, uint32_t emergencyCnt)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    if(!p_Fm->p_FmDriverParam->dmaEnEmergency)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("FM_ConfigEnDmaEmergencySmoother may be called only after FM_ConfigEnDmaEmergency"));
+
+    p_Fm->p_FmDriverParam->dmaEnEmergencySmoother = TRUE;
+    p_Fm->p_FmDriverParam->dmaEmergencySwitchCounter = emergencyCnt;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaDbgCounter(t_Handle h_Fm, e_FmDmaDbgCntMode fmDmaDbgCntMode)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaDbgCntMode = fmDmaDbgCntMode;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaStopOnBusErr(t_Handle h_Fm, bool stop)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaStopOnBusError = stop;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaSosEmergencyThreshold(t_Handle h_Fm, uint32_t dmaSosEmergency)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaSosEmergency = dmaSosEmergency;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigEnableCounters(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->enCounters = TRUE;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaErr(t_Handle h_Fm, e_FmDmaErr dmaErr)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaErr = dmaErr;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigCatastrophicErr(t_Handle h_Fm, e_FmCatastrophicErr catastrophicErr)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->catastrophicErr = catastrophicErr;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigEnableMuramTestMode(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->enMuramTestMode = TRUE;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigEnableIramTestMode(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->enIramTestMode = TRUE;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigHaltOnExternalActivation(t_Handle h_Fm, bool enable)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->haltOnExternalActivation = enable;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigHaltOnUnrecoverableEccError(t_Handle h_Fm, bool enable)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError = enable;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    bitMask = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    GET_EXCEPTION_FLAG(bitMask, exception);
+    if(bitMask)
+    {
+        if (enable)
+            p_Fm->exceptions |= bitMask;
+        else
+            p_Fm->exceptions &= ~bitMask;
+   }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->externalEccRamsEnable = enable;
+
+    return E_OK;
+}
+
+/****************************************************/
+/*       API Run-time Control uint functions        */
+/****************************************************/
+t_Handle FM_GetPcdHandle(t_Handle h_Fm)
+{
+    SANITY_CHECK_RETURN_VALUE(h_Fm, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!((t_Fm*)h_Fm)->p_FmDriverParam, E_INVALID_STATE, NULL);
+
+    return ((t_Fm*)h_Fm)->h_Pcd;
+}
+
+void FM_Isr(t_Handle h_Fm)
+{
+    t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+    uint32_t                pending;
+
+    SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
+
+    /* error interrupts */
+    pending = GET_UINT32(p_Fm->p_FmFpmRegs->fmepi);
+    if(pending) /* remove if separate sources */
+    {
+        if(pending & ERR_INTR_EN_BMI)
+            BmiErrEvent(p_Fm);
+        if(pending & ERR_INTR_EN_QMI)
+            QmiErrEvent(p_Fm);
+        if(pending & ERR_INTR_EN_FPM)
+            FpmErrEvent(p_Fm);
+        if(pending & ERR_INTR_EN_DMA)
+            DmaErrEvent(p_Fm);
+        if(pending & ERR_INTR_EN_IRAM)
+            IramErrIntr(p_Fm);
+        if(pending & ERR_INTR_EN_MURAM)
+            MuramErrIntr(p_Fm);
+        if(pending & ERR_INTR_EN_PRS)
+            p_Fm->intrMng[e_FM_EV_ERR_PRS].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_PRS].h_SrcHandle);
+        if(pending & ERR_INTR_EN_PLCR)
+            p_Fm->intrMng[e_FM_EV_ERR_PLCR].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_PLCR].h_SrcHandle);
+        if(pending & ERR_INTR_EN_KG)
+            p_Fm->intrMng[e_FM_EV_ERR_KG].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_KG].h_SrcHandle);
+        if(pending & ERR_INTR_EN_1G_MAC0)
+            p_Fm->intrMng[e_FM_EV_ERR_1G_MAC0].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC0].h_SrcHandle);
+        if(pending & ERR_INTR_EN_1G_MAC1)
+            p_Fm->intrMng[e_FM_EV_ERR_1G_MAC1].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC1].h_SrcHandle);
+        if(pending & ERR_INTR_EN_1G_MAC2)
+            p_Fm->intrMng[e_FM_EV_ERR_1G_MAC2].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC2].h_SrcHandle);
+        if(pending & ERR_INTR_EN_1G_MAC3)
+            p_Fm->intrMng[e_FM_EV_ERR_1G_MAC3].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_1G_MAC3].h_SrcHandle);
+        if(pending & ERR_INTR_EN_10G_MAC0)
+            p_Fm->intrMng[e_FM_EV_ERR_10G_MAC0].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_10G_MAC0].h_SrcHandle);
+    }
+
+    /* normal interrupts */
+    pending = GET_UINT32(p_Fm->p_FmFpmRegs->fmnpi);
+    if(pending) /* remove if separate sources */
+    {
+        if(pending & INTR_EN_BMI)
+            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("BMI Event - undefined!"));
+        if(pending & INTR_EN_QMI)
+            QmiEvent(p_Fm);
+        if(pending & INTR_EN_PRS)
+            p_Fm->intrMng[e_FM_EV_PRS].f_Isr(p_Fm->intrMng[e_FM_EV_PRS].h_SrcHandle);
+        if(pending & INTR_EN_PLCR)
+            p_Fm->intrMng[e_FM_EV_PLCR].f_Isr(p_Fm->intrMng[e_FM_EV_PLCR].h_SrcHandle);
+        if(pending & INTR_EN_KG)
+            p_Fm->intrMng[e_FM_EV_KG].f_Isr(p_Fm->intrMng[e_FM_EV_KG].h_SrcHandle);
+        if(pending & FPM_EVENT_FM_CTL)
+            FmCtlEvent(p_Fm, pending  & FPM_EVENT_FM_CTL);
+        if(pending & INTR_EN_1G_MAC1)
+            p_Fm->intrMng[e_FM_EV_1G_MAC1].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC1].h_SrcHandle);
+        if(pending & INTR_EN_1G_MAC2)
+            p_Fm->intrMng[e_FM_EV_1G_MAC2].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC2].h_SrcHandle);
+        if(pending & INTR_EN_1G_MAC3)
+            p_Fm->intrMng[e_FM_EV_1G_MAC3].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC3].h_SrcHandle);
+        if(pending & INTR_EN_1G_MAC0_TMR)
+            p_Fm->intrMng[e_FM_EV_1G_MAC0_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC0_TMR].h_SrcHandle);
+        if(pending & INTR_EN_1G_MAC1_TMR)
+            p_Fm->intrMng[e_FM_EV_1G_MAC1_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC1_TMR].h_SrcHandle);
+        if(pending & INTR_EN_1G_MAC2_TMR)
+            p_Fm->intrMng[e_FM_EV_1G_MAC2_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC2_TMR].h_SrcHandle);
+        if(pending & INTR_EN_1G_MAC3_TMR)
+            p_Fm->intrMng[e_FM_EV_1G_MAC3_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_1G_MAC3_TMR].h_SrcHandle);
+        if(pending & INTR_EN_TMR)
+            p_Fm->intrMng[e_FM_EV_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_TMR].h_SrcHandle);
+    }
+}
+
+t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_PortsParam *p_PortsBandwidth)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    int         j, i;
+    uint8_t     sum;
+    uint8_t     hardwarePortId=0;
+    uint8_t     portPrecent[FM_MAX_NUM_OF_PORTS];
+    uint32_t    tmpReg;
+    uint8_t     relativePortId, remain, shift, weight, maxPercent = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    memset(portPrecent, 0, FM_MAX_NUM_OF_PORTS);
+    for(i=0;i<NUM_OF_PORT_TYPES;i++)
+        for(j=0;j<MAX_NUM_OF_PORTS_PER_TYPE;j++)
+        {
+            if((*p_PortsBandwidth)[i][j])
+            {
+                GET_GLOBAL_PORTID(hardwarePortId, i,j);
+                portPrecent[hardwarePortId] = (*p_PortsBandwidth)[i][j];
+            }
+        }
+
+    /* check that all ports add up to 100% */
+    sum = 0;
+    for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
+        sum +=portPrecent[i];
+    if (sum != 100)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Sum of ports bandwidth differ from 100%"));
+
+    tmpReg = 0;
+    /* find highest precent */
+    for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
+    {
+        if (portPrecent[i] > maxPercent)
+            maxPercent = portPrecent[i];
+    }
+
+    /* calculate weight for each port */
+    for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
+    {
+        weight = (uint8_t)((portPrecent[i] * PORT_MAX_WEIGHT )/maxPercent);
+        remain = (uint8_t)((portPrecent[i] * PORT_MAX_WEIGHT ) - maxPercent*weight);
+
+        /* round the remain to add 1 if it is bigger than 0.5 */
+        if (remain*2 > maxPercent)
+            weight++;
+
+        /* find the location of this port within the register */
+        relativePortId = (uint8_t)(i % 8);
+        shift = (uint8_t)(32-4*(relativePortId+1));
+
+
+        if(weight)
+            /* Add this port to tmpReg */
+            tmpReg |= ((weight-1) << shift);
+
+        /* each 8 ports result in one register, write this register */
+        if (relativePortId == 7 && tmpReg)
+        {
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_arb[i/8], tmpReg);
+            tmpReg = 0;
+        }
+    }
+
+
+    return E_OK;
+}
+
+t_Error FM_EnableRamsEcc(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
+    if(tmpReg & FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL)
+        RETURN_ERROR(MINOR, E_INVALID_STATE,("Rams ECC is configured to be controlled through JTAG"));
+
+    if(p_Fm->ramsEccEnable)
+        return E_OK;
+    else
+    {
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg | (FPM_RAM_CTL_RAMS_ECC_EN | FPM_RAM_CTL_IRAM_ECC_EN));
+        p_Fm->ramsEccEnable = TRUE;
+    }
+
+    return E_OK;
+}
+
+t_Error FM_DisableRamsEcc(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
+    if(tmpReg & FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL)
+        RETURN_ERROR(MINOR, E_INVALID_STATE,("Rams ECC is configured to be controlled through JTAG"));
+
+    if(!p_Fm->ramsEccEnable)
+        return E_OK;
+    else
+    {
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg & ~(FPM_RAM_CTL_RAMS_ECC_EN | FPM_RAM_CTL_IRAM_ECC_EN));
+        p_Fm->ramsEccEnable = FALSE;
+    }
+
+    return E_OK;
+}
+
+t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    bitMask = 0;
+    uint32_t    tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    GET_EXCEPTION_FLAG(bitMask, exception);
+    if(bitMask)
+    {
+        if (enable)
+            p_Fm->exceptions |= bitMask;
+        else
+            p_Fm->exceptions &= ~bitMask;
+
+        switch(exception)
+        {
+             case(e_FM_EX_DMA_BUS_ERROR):
+                tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr);
+                if(enable)
+                    tmpReg |= DMA_MODE_BER;
+                else
+                    tmpReg &= ~DMA_MODE_BER;
+                /* disable bus error */
+                WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, tmpReg);
+                break;
+             case(e_FM_EX_DMA_READ_ECC):
+             case(e_FM_EX_DMA_SYSTEM_WRITE_ECC):
+             case(e_FM_EX_DMA_FM_WRITE_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr);
+                if(enable)
+                    tmpReg |= DMA_MODE_ECC;
+                else
+                    tmpReg &= ~DMA_MODE_ECC;
+                WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, tmpReg);
+                break;
+             case(e_FM_EX_FPM_STALL_ON_TASKS):
+                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fpmem);
+                if(enable)
+                    tmpReg |= FPM_EV_MASK_STALL_EN;
+                else
+                    tmpReg &= ~FPM_EV_MASK_STALL_EN;
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg);
+                break;
+             case(e_FM_EX_FPM_SINGLE_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fpmem);
+                if(enable)
+                    tmpReg |= FPM_EV_MASK_SINGLE_ECC_EN;
+                else
+                    tmpReg &= ~FPM_EV_MASK_SINGLE_ECC_EN;
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg);
+                break;
+            case( e_FM_EX_FPM_DOUBLE_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fpmem);
+                if(enable)
+                    tmpReg |= FPM_EV_MASK_DOUBLE_ECC_EN;
+                else
+                    tmpReg &= ~FPM_EV_MASK_DOUBLE_ECC_EN;
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg);
+                break;
+            case( e_FM_EX_QMI_SINGLE_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien);
+                if(enable)
+                    tmpReg |= QMI_INTR_EN_SINGLE_ECC;
+                else
+                    tmpReg &= ~QMI_INTR_EN_SINGLE_ECC;
+                WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien, tmpReg);
+                break;
+             case(e_FM_EX_QMI_DOUBLE_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien);
+                if(enable)
+                    tmpReg |= QMI_ERR_INTR_EN_DOUBLE_ECC;
+                else
+                    tmpReg &= ~QMI_ERR_INTR_EN_DOUBLE_ECC;
+                WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien, tmpReg);
+                break;
+             case(e_FM_EX_QMI_DEQ_FROM_DEFQ):
+                tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien);
+                if(enable)
+                    tmpReg |= QMI_ERR_INTR_EN_DEQ_FROM_DEF;
+                else
+                    tmpReg &= ~QMI_ERR_INTR_EN_DEQ_FROM_DEF;
+                WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien, tmpReg);
+                break;
+             case(e_FM_EX_BMI_LIST_RAM_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
+                if(enable)
+                    tmpReg |= BMI_ERR_INTR_EN_LIST_RAM_ECC;
+                else
+                    tmpReg &= ~BMI_ERR_INTR_EN_LIST_RAM_ECC;
+                WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
+                break;
+             case(e_FM_EX_BMI_PIPELINE_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
+                if(enable)
+                    tmpReg |= BMI_ERR_INTR_EN_PIPELINE_ECC;
+                else
+                    tmpReg &= ~BMI_ERR_INTR_EN_PIPELINE_ECC;
+                WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
+                break;
+              case(e_FM_EX_BMI_STATISTICS_RAM_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
+                if(enable)
+                    tmpReg |= BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
+                else
+                    tmpReg &= ~BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
+                WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
+                break;
+            case(e_FM_EX_IRAM_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmeie);
+                if(enable)
+                {
+                    /* enable ECC if not enabled */
+                    if(!p_Fm->ramsEccEnable)
+                    {
+
+                        WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr) |
+                                                                (FPM_RAM_CTL_IRAM_ECC_EN | FPM_RAM_CTL_RAMS_ECC_EN));
+                        p_Fm->ramsEccEnable = TRUE;
+                    }
+                    /* enable ECC interrupts */
+                    tmpReg |= FPM_IRAM_ECC_ERR_EX_EN;
+                }
+                else
+                    tmpReg &= FPM_IRAM_ECC_ERR_EX_EN;
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmeie, tmpReg);
+                break;
+
+             case(e_FM_EX_MURAM_ECC):
+                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmeie);
+                if(enable)
+                {
+                    /* enable ECC if not enabled */
+                    if(!FmRamsEccIsExternalCtl(p_Fm))
+                        FM_EnableRamsEcc(p_Fm);
+                    /* enable ECC interrupts */
+                    tmpReg |= FPM_MURAM_ECC_ERR_EX_EN;
+                }
+                else
+                    tmpReg &= FPM_MURAM_ECC_ERR_EX_EN;
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmeie, tmpReg);
+
+                break;
+            default:
+                RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
+
+        }
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    return E_OK;
+}
+
+void FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    tmpReg;
+
+    SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    /* read revision register 1 */
+    tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_ip_rev_1);
+    p_FmRevisionInfo->majorRev = (uint8_t)((tmpReg & FPM_REV1_MAJOR_MASK) >> FPM_REV1_MAJOR_SHIFT);
+    p_FmRevisionInfo->minorRev = (uint8_t)((tmpReg & FPM_REV1_MINOR_MASK) >> FPM_REV1_MINOR_SHIFT);
+}
+
+uint32_t FM_GetTimeStamp(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_Fm->p_FmDriverParam, E_INVALID_STATE, 0);
+
+    /* check that timeStamp is enabled */
+    if (!(GET_UINT32(p_Fm->p_FmFpmRegs->fpmtsc1) & FPM_TS_CTL_EN))
+    {
+        REPORT_ERROR(MINOR, E_INVALID_STATE, ("Time Stamp was not enabled"));
+        return 0;
+    }
+
+    return GET_UINT32(p_Fm->p_FmFpmRegs->fpmtsp);;
+}
+
+uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_Fm->p_FmDriverParam, E_INVALID_STATE, 0);
+
+        switch(counter)
+    {
+        case(e_FM_COUNTERS_ENQ_TOTAL_FRAME):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_etfc);
+        break;
+        case(e_FM_COUNTERS_DEQ_TOTAL_FRAME):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dtfc);
+        case(e_FM_COUNTERS_DEQ_0):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc0);
+        case(e_FM_COUNTERS_DEQ_1):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc1);
+        case(e_FM_COUNTERS_DEQ_2):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc2);
+        case(e_FM_COUNTERS_DEQ_3):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc3);
+        case(e_FM_COUNTERS_DEQ_FROM_DEFAULT):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dfdc);
+        case(e_FM_COUNTERS_DEQ_FROM_CONTEXT):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dfcc);
+        case(e_FM_COUNTERS_DEQ_FROM_FD):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dffc);
+        case(e_FM_COUNTERS_DEQ_CONFIRM):
+            return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dcc);
+        case(e_FM_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT):
+            return GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsefrc);
+        case(e_FM_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT):
+            return GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsqfrc);
+        case(e_FM_COUNTERS_SEMAPHOR_SYNC_REJECT):
+            return GET_UINT32(p_Fm->p_FmDmaRegs->fmdmssrc);
+        default:
+            break;
+    }
+    /* should never get here */
+    ASSERT_COND(FALSE);
+
+    return 0;
+}
+
+t_Error  FM_SetCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+   SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+   SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    /* When applicable (when there is an 'enable counters' bit,
+    check that counters are enabled */
+    switch(counter)
+    {
+        case(e_FM_COUNTERS_ENQ_TOTAL_FRAME):
+        case(e_FM_COUNTERS_DEQ_TOTAL_FRAME):
+        case(e_FM_COUNTERS_DEQ_0):
+        case(e_FM_COUNTERS_DEQ_1):
+        case(e_FM_COUNTERS_DEQ_2):
+        case(e_FM_COUNTERS_DEQ_3):
+        case(e_FM_COUNTERS_DEQ_FROM_DEFAULT):
+        case(e_FM_COUNTERS_DEQ_FROM_CONTEXT):
+        case(e_FM_COUNTERS_DEQ_FROM_FD):
+        case(e_FM_COUNTERS_DEQ_CONFIRM):
+            if(!(GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc) & QMI_CFG_EN_COUNTERS))
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+        default:
+            break;
+    }
+
+    /* Set counter */
+    switch(counter)
+    {
+        case(e_FM_COUNTERS_ENQ_TOTAL_FRAME):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_etfc, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_TOTAL_FRAME):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dtfc, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_0):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc0, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_1):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc1, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_2):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc2, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_3):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dc3, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_FROM_DEFAULT):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dfdc, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_FROM_CONTEXT):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dfcc, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_FROM_FD):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dffc, val);
+            break;
+        case(e_FM_COUNTERS_DEQ_CONFIRM):
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dcc, val);
+            break;
+        case(e_FM_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT):
+            WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsefrc, val);
+            break;
+        case(e_FM_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT):
+            WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsqfrc, val);
+            break;
+        case(e_FM_COUNTERS_SEMAPHOR_SYNC_REJECT):
+            WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmssrc, val);
+            break;
+        default:
+            break;
+    }
+
+    return E_OK;
+}
+
+void FM_DmaEmergencyCtrl(t_Handle h_Fm, e_FmDmaMuramPort muramPort, bool enable)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    bitMask;
+
+    SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    bitMask = (uint32_t)((muramPort==e_FM_DMA_MURAM_PORT_WRITE) ? DMA_MODE_EMERGENCY_WRITE : DMA_MODE_EMERGENCY_READ);
+
+    if(enable)
+        WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr) | bitMask);
+    else /* disable */
+        WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr) & ~bitMask);
+
+    return;
+}
+
+void FM_SetDmaExtBusPri(t_Handle h_Fm, e_FmDmaExtBusPri pri)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr) | ((uint32_t)pri << DMA_MODE_BUS_PRI_SHIFT) );
+
+    return;
+}
+
+void FM_GetDmaStatus(t_Handle h_Fm, t_FmDmaStatus *p_FmDmaStatus)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    uint32_t    tmpReg;
+
+    SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsr);
+
+    p_FmDmaStatus->cmqNotEmpty = (bool)(tmpReg & DMA_STATUS_CMD_QUEUE_NOT_EMPTY);
+    p_FmDmaStatus->busError = (bool)(tmpReg & DMA_STATUS_BUS_ERR);
+    p_FmDmaStatus->readBufEccError = (bool)(tmpReg & DMA_STATUS_READ_ECC);
+    p_FmDmaStatus->writeBufEccSysError = (bool)(tmpReg & DMA_STATUS_SYSTEM_WRITE_ECC);
+    p_FmDmaStatus->writeBufEccFmError = (bool)(tmpReg & DMA_STATUS_FM_WRITE_ECC);
+    return;
+}
+
+t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    switch(exception)
+    {
+        case e_FM_EX_QMI_DEQ_FROM_DEFQ:
+            if (!(p_Fm->exceptions & FM_EX_QMI_DEQ_FROM_DEFQ))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif, QMI_ERR_INTR_EN_DEQ_FROM_DEF);
+            break;
+        case e_FM_EX_QMI_SINGLE_ECC:
+            if (!(p_Fm->exceptions & FM_EX_QMI_SINGLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_if, QMI_INTR_EN_SINGLE_ECC);
+            break;
+        case e_FM_EX_QMI_DOUBLE_ECC:
+            if (!(p_Fm->exceptions & FM_EX_QMI_DOUBLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif, QMI_ERR_INTR_EN_DOUBLE_ECC);
+            break;
+        case e_FM_EX_BMI_LIST_RAM_ECC:
+            if (!(p_Fm->exceptions & FM_EX_BMI_LIST_RAM_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_LIST_RAM_ECC);
+            break;
+        case e_FM_EX_BMI_PIPELINE_ECC:
+            if (!(p_Fm->exceptions & FM_EX_BMI_PIPELINE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_PIPELINE_ECC);
+            break;
+        case e_FM_EX_BMI_STATISTICS_RAM_ECC:
+            if (!(p_Fm->exceptions & FM_EX_BMI_STATISTICS_RAM_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_STATISTICS_RAM_ECC);
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception may not be forced"));
+    }
+
+    return E_OK;
+}
+
+void FM_Resume(t_Handle h_Fm)
+{
+    t_Fm            *p_Fm = (t_Fm*)h_Fm;
+    uint32_t        tmpReg;
+
+    SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    tmpReg  = GET_UINT32(p_Fm->p_FmFpmRegs->fpmem);
+    /* clear tmpReg event bits in order not to clear standing events */
+    tmpReg &= ~(FPM_EV_MASK_DOUBLE_ECC | FPM_EV_MASK_STALL | FPM_EV_MASK_SINGLE_ECC);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg | FPM_EV_MASK_RELEASE_FM);
+}
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_DumpRegs(t_Handle h_Fm)
+{
+    t_Fm    *p_Fm = (t_Fm *)h_Fm;
+    uint8_t i = 0;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    DUMP_SUBTITLE(("\n"));
+    DUMP_TITLE(p_Fm->p_FmFpmRegs, ("FmFpmRegs Regs"));
+
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmtnc);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmpr);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,brkc);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmflc);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmdis1);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmdis2);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmepi);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmeie);
+
+    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fpmrev, ("fpmrev"));
+    DUMP_SUBSTRUCT_ARRAY(i, 8)
+    {
+        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fpmrev[i], sizeof(uint32_t));
+    }
+
+    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fpmmsk, ("fpmmsk"));
+    DUMP_SUBSTRUCT_ARRAY(i, 8)
+    {
+        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fpmmsk[i], sizeof(uint32_t));
+    }
+
+    DUMP_SUBTITLE(("\n"));
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmtsc1);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmtsc2);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmtsp);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmtsf);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmrcr);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmextc);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmext1);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmext2);
+
+    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fpmdrd, ("fpmdrd"));
+    DUMP_SUBSTRUCT_ARRAY(i, 16)
+    {
+        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fpmdrd[i], sizeof(uint32_t));
+    }
+
+    DUMP_SUBTITLE(("\n"));
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmdra);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fm_ip_rev_1);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fm_ip_rev_2);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmrstc);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmcld);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmnpi);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fpmem);
+
+    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fpmcev, ("fpmcev"));
+    DUMP_SUBSTRUCT_ARRAY(i, 8)
+    {
+        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fpmcev[i], sizeof(uint32_t));
+    }
+
+    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fmfp_ps, ("fmfp_ps"));
+    DUMP_SUBSTRUCT_ARRAY(i, 64)
+    {
+        DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfp_ps[i], sizeof(uint32_t));
+    }
+
+
+    DUMP_TITLE(p_Fm->p_FmDmaRegs, ("p_FmDmaRegs Regs"));
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmsr);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmmr);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmtr);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmhy);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmsetr);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmtah);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmtal);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmtcid);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmra);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmrd);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmwcr);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmebcr);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmccqdr);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmccqvr1);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmccqvr2);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmcqvr3);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmcqvr4);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmcqvr5);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmsefrc);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmsqfrc);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmssrc);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmdcr);
+
+    DUMP_TITLE(&p_Fm->p_FmDmaRegs->fmdmplr, ("fmdmplr"));
+
+    DUMP_SUBSTRUCT_ARRAY(i, FM_MAX_NUM_OF_PARTITIONS/2)
+    {
+        DUMP_MEMORY(&p_Fm->p_FmDmaRegs->fmdmplr[i], sizeof(uint32_t));
+    }
+
+    DUMP_TITLE(p_Fm->p_FmBmiRegs, ("p_FmBmiRegs COMMON Regs"));
+    DUMP_VAR(p_Fm->p_FmBmiRegs,fmbm_init);
+    DUMP_VAR(p_Fm->p_FmBmiRegs,fmbm_cfg1);
+    DUMP_VAR(p_Fm->p_FmBmiRegs,fmbm_cfg2);
+    DUMP_VAR(p_Fm->p_FmBmiRegs,fmbm_ievr);
+    DUMP_VAR(p_Fm->p_FmBmiRegs,fmbm_ier);
+
+    DUMP_TITLE(&p_Fm->p_FmBmiRegs->fmbm_arb, ("fmbm_arb"));
+    DUMP_SUBSTRUCT_ARRAY(i, 8)
+    {
+        DUMP_MEMORY(&p_Fm->p_FmBmiRegs->fmbm_arb[i], sizeof(uint32_t));
+    }
+
+
+    DUMP_TITLE(p_Fm->p_FmQmiRegs, ("p_FmQmiRegs COMMON Regs"));
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_gc);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_eie);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_eien);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_eif);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_ie);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_ien);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_if);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_gs);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_ts);
+    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_etfc);
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h
new file mode 100644
index 0000000..6174fed
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm.h
@@ -0,0 +1,629 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm.h
+
+ @Description   FM internal structures and definitions.
+*//***************************************************************************/
+#ifndef __FM_H
+#define __FM_H
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "fm_ext.h"
+
+
+#define FM_MAX_NUM_OF_PORTS         64
+
+/**************************************************************************//**
+ @Description       Exceptions
+*//***************************************************************************/
+#define FM_EX_DMA_BUS_ERROR                 0x80000000      /**< DMA bus error. */
+#define FM_EX_DMA_READ_ECC                  0x40000000
+#define FM_EX_DMA_SYSTEM_WRITE_ECC          0x20000000
+#define FM_EX_DMA_FM_WRITE_ECC              0x10000000
+#define FM_EX_FPM_STALL_ON_TASKS            0x08000000      /**< Stall of tasks on FPM */
+#define FM_EX_FPM_SINGLE_ECC                0x04000000      /**< Single ECC on FPM */
+#define FM_EX_FPM_DOUBLE_ECC                0x02000000
+#define FM_EX_QMI_SINGLE_ECC                0x01000000      /**< Single ECC on FPM */
+#define FM_EX_QMI_DEQ_FROM_DEFQ             0x00800000      /**< Dequeu from default queue id */
+#define FM_EX_QMI_DOUBLE_ECC                0x00400000
+#define FM_EX_BMI_LIST_RAM_ECC              0x00200000
+#define FM_EX_BMI_PIPELINE_ECC              0x00100000
+#define FM_EX_BMI_STATISTICS_RAM_ECC        0x00080000
+#define FM_EX_IRAM_ECC                      0x00040000
+#define FM_EX_NURAM_ECC                      0x00020000
+
+#define GET_EXCEPTION_FLAG(bitMask, exception)       switch(exception){ \
+    case e_FM_EX_DMA_BUS_ERROR:                                         \
+        bitMask = FM_EX_DMA_BUS_ERROR; break;                           \
+    case e_FM_EX_DMA_READ_ECC:                                          \
+        bitMask = FM_EX_DMA_READ_ECC; break;                            \
+    case e_FM_EX_DMA_SYSTEM_WRITE_ECC:                                  \
+        bitMask = FM_EX_DMA_SYSTEM_WRITE_ECC; break;                    \
+    case e_FM_EX_DMA_FM_WRITE_ECC:                                      \
+        bitMask = FM_EX_DMA_FM_WRITE_ECC; break;                        \
+    case e_FM_EX_FPM_STALL_ON_TASKS:                                    \
+        bitMask = FM_EX_FPM_STALL_ON_TASKS; break;                      \
+    case e_FM_EX_FPM_SINGLE_ECC:                                        \
+        bitMask = FM_EX_FPM_SINGLE_ECC; break;                          \
+    case e_FM_EX_FPM_DOUBLE_ECC:                                        \
+        bitMask = FM_EX_FPM_DOUBLE_ECC; break;                          \
+    case e_FM_EX_QMI_SINGLE_ECC:                                        \
+        bitMask = FM_EX_QMI_SINGLE_ECC; break;                          \
+    case e_FM_EX_QMI_DOUBLE_ECC:                                        \
+        bitMask = FM_EX_QMI_DOUBLE_ECC; break;                          \
+    case e_FM_EX_QMI_DEQ_FROM_DEFQ:                                     \
+        bitMask = FM_EX_QMI_DEQ_FROM_DEFQ; break;                       \
+    case e_FM_EX_BMI_LIST_RAM_ECC:                                      \
+        bitMask = FM_EX_BMI_LIST_RAM_ECC; break;                        \
+    case e_FM_EX_BMI_PIPELINE_ECC:                                      \
+        bitMask = FM_EX_BMI_PIPELINE_ECC; break;                        \
+    case e_FM_EX_BMI_STATISTICS_RAM_ECC:                                \
+        bitMask = FM_EX_BMI_STATISTICS_RAM_ECC; break;                  \
+    case e_FM_EX_IRAM_ECC:                                              \
+        bitMask = FM_EX_IRAM_ECC; break;                                \
+    case e_FM_EX_MURAM_ECC:                                             \
+        bitMask = FM_EX_NURAM_ECC; break;                               \
+    default: bitMask = 0;break;}
+
+/**************************************************************************//**
+ @Description       defaults
+*//***************************************************************************/
+#define DEFAULT_exceptions              (FM_EX_DMA_BUS_ERROR            |\
+                                        FM_EX_DMA_READ_ECC              |\
+                                        FM_EX_DMA_SYSTEM_WRITE_ECC      |\
+                                        FM_EX_DMA_FM_WRITE_ECC          |\
+                                        FM_EX_FPM_STALL_ON_TASKS        |\
+                                        FM_EX_FPM_SINGLE_ECC            |\
+                                        FM_EX_FPM_DOUBLE_ECC            |\
+                                        FM_EX_QMI_SINGLE_ECC            |\
+                                        FM_EX_QMI_DEQ_FROM_DEFQ         |\
+                                        FM_EX_QMI_DOUBLE_ECC            |\
+                                        FM_EX_BMI_LIST_RAM_ECC          |\
+                                        FM_EX_BMI_PIPELINE_ECC          |\
+                                        FM_EX_BMI_STATISTICS_RAM_ECC    |\
+                                        FM_EX_IRAM_ECC                  |\
+                                        FM_EX_NURAM_ECC                 )
+#define DEFAULT_totalNumOfTasks         96
+#define DEFAULT_totalFifoSize           (128*KILOBYTE)
+#define DEFAULT_maxNumOfOpenDmas      24
+#define DEFAULT_eccEnable               FALSE
+#define DEFAULT_dispLimit               16
+#define DEFAULT_prsDispTh               16
+#define DEFAULT_plcrDispTh              16
+#define DEFAULT_kgDispTh                16
+#define DEFAULT_bmiDispTh               16
+#define DEFAULT_qmiEnqDispTh            16
+#define DEFAULT_qmiDeqDispTh            16
+#define DEFAULT_fmCtl1DispTh             16
+#define DEFAULT_fmCtl2DispTh             16
+#define DEFAULT_cacheOverride           e_FM_DMA_NO_CACHE_OR
+#define DEFAULT_aidOverride             FALSE
+#define DEFAULT_aidMode                 e_FM_DMA_AID_OUT_PORT_ID
+#define DEFAULT_secureBusProtect        FALSE
+#define DEFAULT_privilegeBusProtect     FALSE
+#define DEFAULT_dmaStopOnBusError       FALSE
+#define DEFAULT_busProtectionType       e_FM_DMA_DATA_BUS_PROT
+#define DEFAULT_stopAtBusError          FALSE
+#define DEFAULT_axiDbgNumOfBeats        1
+#define DEFAULT_dmaCamNumOfEntries      32
+#define DEFAULT_dmaCommQLow             16
+#define DEFAULT_dmaCommQHigh            24
+#define DEFAULT_dmaReadIntBufLow        64
+#define DEFAULT_dmaReadIntBufHigh       96
+#define DEFAULT_dmaWriteIntBufLow       64
+#define DEFAULT_dmaWriteIntBufHigh      96
+#define DEFAULT_dmaSosEmergency         0
+#define DEFAULT_dmaDbgCntMode           e_FM_DMA_DBG_NO_CNT
+#define DEFAULT_catastrophicErr         e_FM_CATASTROPHIC_ERR_STALL_PORT
+#define DEFAULT_dmaErr                  e_FM_DMA_ERR_CATASTROPHIC
+#define DEFAULT_resetOnInit             FALSE
+#define DEFAULT_haltOnExternalActivation        FALSE
+#define DEFAULT_haltOnUnrecoverableEccError     FALSE
+#define DEFAULT_externalEccRamsEnable           FALSE
+/**************************************************************************//**
+ @Description       Modules registers offsets
+*//***************************************************************************/
+#define FM_MM_MURAM             0x00000000
+#define FM_MM_BMI               0x00080000
+#define FM_MM_QMI               0x00080400
+#define FM_MM_PRS               0x000c7000
+#define FM_MM_KG                0x000C1000
+#define FM_MM_DMA               0x000C2000
+#define FM_MM_FPM               0x000C3000
+#define FM_MM_PLCR              0x000C0000
+#define FM_MM_IMEM              0x000C4000
+
+/**************************************************************************//**
+ @Description       Interrupt Enable/Mask
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description       Memory Mapped Registers
+*//***************************************************************************/
+
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+
+typedef _Packed struct
+{
+    volatile uint32_t   fpmtnc;         /**< FPM TNUM Control */
+    volatile uint32_t   fpmpr;          /**< FPM Port_ID FmCtl Association */
+    volatile uint32_t   brkc;           /**< FPM Breakpoint Control */
+    volatile uint32_t   fpmflc;         /**< FPM Flush Control */
+    volatile uint32_t   fpmdis1;        /**< FPM Dispatch Thresholds1 */
+    volatile uint32_t   fpmdis2;        /**< FPM Dispatch Thresholds2  */
+    volatile uint32_t   fmepi;          /**< FM Error Pending Interrupts */
+    volatile uint32_t   fmeie;          /**< FM Error Interrupt Enable */
+    volatile uint32_t   fpmrev[8];      /**< FPM FmCtl Event 1-8 */
+    volatile uint32_t   fpmmsk[8];      /**< FPM Mask 1-8 */
+    volatile uint32_t   fpmtsc1;        /**< FPM TimeStamp Control1 */
+    volatile uint32_t   fpmtsc2;        /**< FPM TimeStamp Control2 */
+    volatile uint32_t   fpmtsp;         /**< FPM Time Stamp */
+    volatile uint32_t   fpmtsf;         /**< FPM Time Stamp Fraction */
+    volatile uint32_t   fmrcr;          /**< FM Rams Control */
+    volatile uint32_t   fpmextc;        /**< FPM External Requests Control */
+    volatile uint32_t   fpmext1;        /**< FPM External Requests Config1 */
+    volatile uint32_t   fpmext2;        /**< FPM External Requests Config2 */
+    volatile uint32_t   fpmdrd[16];     /**< FPM Data_Ram Data 0-15 */
+    volatile uint32_t   fpmdra;         /**< FPM Data Ram Access */
+    volatile uint32_t   fm_ip_rev_1;    /**< FM IP Block Revision 1 */
+    volatile uint32_t   fm_ip_rev_2;    /**< FM IP Block Revision 2 */
+    volatile uint32_t   fmrstc;         /**< FM Reset Command */
+    volatile uint32_t   fmcld;          /**< FM Classifier Debug */
+    volatile uint32_t   fmnpi;          /**< FM Normal Pending Interrupts  */
+    volatile uint32_t   reserved;
+    volatile uint32_t   fpmem;          /**< FPM Event & Mask */
+    volatile uint32_t   fpmcev[8];      /**< FPM CPU Event 1-8 */
+    volatile uint32_t   fmfp_ps[0x40];  /**< FPM Port Status */
+    volatile uint8_t    reserved1[0x260];
+    volatile uint32_t   fpmts[128];     /**< 0x400: FPM Task Status */
+} _PackedType t_FmFpmRegs;
+
+typedef _Packed struct
+{
+   volatile uint32_t   fmbm_init;       /**< BMI Initialization */
+   volatile uint32_t   fmbm_cfg1;       /**< BMI Configuration 1 */
+   volatile uint32_t   fmbm_cfg2;       /**< BMI Configuration 2 */
+   volatile uint32_t   reserved[5];
+   volatile uint32_t   fmbm_ievr;       /**< Interrupt Event Register */
+   volatile uint32_t   fmbm_ier;        /**< Interrupt Enable Register */
+   volatile uint32_t   fmbm_ifr;        /**< Interrupt Force Register */
+   volatile uint32_t   reserved1[5];
+   volatile uint32_t   fmbm_arb[8];     /**< BMI Arbitration */
+   volatile uint32_t   reserved2[0x29];
+   volatile uint32_t   fmbm_pp[63];     /**< BMI Port Parameters */
+   volatile uint32_t   reserved3;
+   volatile uint32_t   fmbm_pfs[63];    /**< BMI Port FIFO Size */
+   volatile uint32_t   reserved4;
+   volatile uint32_t   fmbm_ppid[63];   /**< Port Partition ID */
+} _PackedType t_FmBmiRegs;
+
+#define NUM_OF_DBG_TRAPS    3
+
+typedef _Packed struct
+{
+    volatile uint32_t   fmqm_gc;        /**<  General Configuration Register */
+    volatile uint32_t   Reserved0;
+    volatile uint32_t   fmqm_eie;       /**<  Error Interrupt Event Register */
+    volatile uint32_t   fmqm_eien;      /**<  Error Interrupt Enable Register */
+    volatile uint32_t   fmqm_eif;       /**<  Error Interrupt Force Register */
+    volatile uint32_t   fmqm_ie;        /**<  Interrupt Event Register */
+    volatile uint32_t   fmqm_ien;       /**<  Interrupt Enable Register */
+    volatile uint32_t   fmqm_if;        /**<  Interrupt Force Register */
+    volatile uint32_t   fmqm_gs;        /**<  Global Status Register */
+    volatile uint32_t   fmqm_ts;        /**<  Task Status Register */
+    volatile uint32_t   fmqm_etfc;      /**<  Enqueue Total Frame Counter */
+    volatile uint32_t   fmqm_dtfc;      /**<  Dequeue Total Frame Counter */
+    volatile uint32_t   fmqm_dc0;       /**<  Dequeue Counter 0 */
+    volatile uint32_t   fmqm_dc1;       /**<  Dequeue Counter 1 */
+    volatile uint32_t   fmqm_dc2;       /**<  Dequeue Counter 2 */
+    volatile uint32_t   fmqm_dc3;       /**<  Dequeue Counter 3 */
+    volatile uint32_t   fmqm_dfdc;      /**<  Dequeue FQID from Default Counter */
+    volatile uint32_t   fmqm_dfcc;      /**<  Dequeue FQID from Context Counter */
+    volatile uint32_t   fmqm_dffc;      /**<  Dequeue FQID from FD Counter */
+    volatile uint32_t   fmqm_dcc;       /**<  Dequeue Confirm Counter */
+    volatile uint32_t   Reserved1[11];
+    volatile uint32_t   fmqm_dtc;       /**<  0x0080 Debug Trap Counter */
+    volatile uint32_t   fmqm_efddd;     /**<  0x0084 Enqueue Frame Descriptor Dynamic Debug */
+    volatile uint32_t   Reserved3[2];
+    struct {
+        volatile uint32_t   fmqm_dtcfg;    /**<  0x0090 Debug Trap Configuration 1 Register */
+        volatile uint32_t   fmqm_dtval1;    /**<  Debug Trap Value Register */
+        volatile uint32_t   fmqm_dtm1;      /**<  Debug Trap Mask Register */
+        volatile uint32_t   fmqm_dtc1;
+        volatile uint32_t   fmqm_dtc2;
+        volatile uint32_t   fmqm_dtval2;    /**<  Debug Trap Value Register */
+        volatile uint32_t   fmqm_dtm3;      /**<  Debug Trap Mask Register */
+    }t_FmQmiDbgTraps[NUM_OF_DBG_TRAPS];
+} _PackedType t_FmQmiRegs;
+
+
+typedef _Packed struct
+{
+    volatile uint32_t   fmdmsr;         /**<    FM DMA status register 0x04 */
+    volatile uint32_t   fmdmmr;         /**<    FM DMA mode register 0x08 */
+    volatile uint32_t   fmdmtr;         /**<    FM DMA bus threshold register 0x0c */
+    volatile uint32_t   fmdmhy;         /**<    FM DMA bus hysteresis register 0x10 */
+    volatile uint32_t   fmdmsetr;       /**<    FM DMA SOS emergency Threshold Register 0x14 */
+    volatile uint32_t   fmdmtah;        /**<    FM DMA transfer bus address high register 0x18  */
+    volatile uint32_t   fmdmtal;        /**<    FM DMA transfer bus address low register 0x1C  */
+    volatile uint32_t   fmdmtcid;       /**<    FM DMA transfer bus communication ID register 0x20  */
+    volatile uint32_t   fmdmra;         /**<    FM DMA bus internal ram address register 0x24  */
+    volatile uint32_t   fmdmrd;         /**<    FM DMA bus internal ram data register 0x28  */
+    volatile uint32_t   fmdmwcr;        /**<    FM DMA CAM watchdog counter value 0x2C  */
+    volatile uint32_t   fmdmebcr;       /**<    FM DMA CAM base in MURAM register 0x30  */
+    volatile uint32_t   fmdmccqdr;      /**<    FM DMA CAM and CMD Queue Debug register 0x34  */
+    volatile uint32_t   fmdmccqvr1;     /**<    FM DMA CAM and CMD Queue Value register #1 0x38  */
+    volatile uint32_t   fmdmccqvr2;     /**<    FM DMA CAM and CMD Queue Value register #2 0x3C  */
+    volatile uint32_t   fmdmcqvr3;      /**<    FM DMA CMD Queue Value register #3 0x40  */
+    volatile uint32_t   fmdmcqvr4;      /**<    FM DMA CMD Queue Value register #4 0x44  */
+    volatile uint32_t   fmdmcqvr5;      /**<    FM DMA CMD Queue Value register #5 0x48  */
+    volatile uint32_t   fmdmsefrc;      /**<    FM DMA Semaphore Entry Full Reject Counter 0x50  */
+    volatile uint32_t   fmdmsqfrc;      /**<    FM DMA Semaphore Queue Full Reject Counter 0x54  */
+    volatile uint32_t   fmdmssrc;       /**<    FM DMA Semaphore SYNC Reject Counter 0x54  */
+    volatile uint32_t   fmdmdcr;        /**<    FM DMA Debug Counter */
+    volatile uint32_t   fmdmemsr;       /**<    FM DMA Emrgency Smoother Register */
+    volatile uint32_t   reserved;
+    volatile uint32_t   fmdmplr[FM_MAX_NUM_OF_PARTITIONS/2];
+                                        /**<    FM DMA PID-LIODN # register  */
+} _PackedType t_FmDmaRegs;
+
+typedef _Packed struct
+{
+     volatile uint32_t      iadd;               /**<    FM IRAM instruction address register */
+    volatile uint32_t      idata;               /**<    FM IRAM instruction data register */
+    volatile uint32_t      itcfg;               /**<    FM IRAM timing config register */
+    volatile uint32_t      iready;               /**<    FM IRAM ready register */
+    volatile uint8_t    res[0x80000-0x10];
+} _PackedType t_FMIramRegs;
+
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
+/**************************************************************************//**
+ @Description       General defines
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description       DMA definitions
+*//***************************************************************************/
+
+/* masks */
+#define DMA_MODE_AID_OR                     0x20000000
+#define DMA_MODE_SBER                       0x10000000
+#define DMA_MODE_BER                        0x00200000
+#define DMA_MODE_ECC                        0x00000020
+#define DMA_MODE_PRIVILEGE_PROT             0x00001000
+#define DMA_MODE_SECURE_PROT                0x00000800
+#define DMA_MODE_EMERGENCY_READ             0x00080000
+#define DMA_MODE_EMERGENCY_WRITE            0x00040000
+
+#define DMA_TRANSFER_PORTID_MASK            0xFF000000
+#define DMA_TRANSFER_TNUM_MASK              0x00FF0000
+#define DMA_TRANSFER_LIODN_MASK             0x00000FFF
+
+#define DMA_HIGH_LIODN_MASK                 0x0FFF0000
+#define DMA_LOW_LIODN_MASK                  0x00000FFF
+
+#define DMA_STATUS_CMD_QUEUE_NOT_EMPTY      0x10000000
+#define DMA_STATUS_BUS_ERR                  0x08000000
+#define DMA_STATUS_READ_ECC                 0x04000000
+#define DMA_STATUS_SYSTEM_WRITE_ECC         0x02000000
+#define DMA_STATUS_FM_WRITE_ECC             0x01000000
+#define DMA_STATUS_SYSTEM_DPEXT_ECC         0x00800000
+#define DMA_STATUS_FM_DPEXT_ECC             0x00400000
+#define DMA_STATUS_SYSTEM_DPDAT_ECC         0x00200000
+#define DMA_STATUS_FM_DPDAT_ECC             0x00100000
+#define DMA_STATUS_FM_SPDAT_ECC             0x00080000
+
+
+#define FM_LIODN_MASK                       0x00000FFF
+
+/* shifts */
+#define DMA_MODE_CACHE_OR_SHIFT             30
+#define DMA_MODE_BUS_PRI_SHIFT              16
+#define DMA_MODE_AXI_DBG_SHIFT              24
+#define DMA_MODE_CEN_SHIFT                  13
+#define DMA_MODE_BUS_PROT_SHIFT             10
+#define DMA_MODE_DBG_SHIFT                  7
+#define DMA_MODE_AID_MODE_SHIFT             4
+#define DMA_MODE_EMERGENCY_LEVEL_SHIFT      6
+#define DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS   16
+#define DMA_MODE_MAX_CAM_NUM_OF_ENTRIES     32
+
+#define DMA_THRESH_COMMQ_SHIFT              24
+#define DMA_THRESH_READ_INT_BUF_SHIFT       16
+
+#define DMA_LIODN_SHIFT                     16
+
+#define DMA_TRANSFER_PORTID_SHIFT           24
+#define DMA_TRANSFER_TNUM_SHIFT             16
+
+/* sizes */
+#define DMA_THRESH_MAX_COMMQ                31
+#define DMA_THRESH_MAX_BUF                  127
+#define DMA_MAX_WATCHDOG                    0xffffffff
+
+/* others */
+#define DMA_CAM_SIZEOF_ENTRY                0x40
+#define DMA_CAM_ALIGN                       0x1000
+#define DMA_CAM_UNITS                       8
+
+
+/**************************************************************************//**
+ @Description       FPM defines
+*//***************************************************************************/
+
+/* masks */
+#define FPM_EV_MASK_DOUBLE_ECC_EN       0x00008000
+#define FPM_EV_MASK_STALL_EN            0x00004000
+#define FPM_EV_MASK_SINGLE_ECC_EN       0x00002000
+#define FPM_EV_MASK_DOUBLE_ECC          0x80000000
+#define FPM_EV_MASK_STALL               0x40000000
+#define FPM_EV_MASK_SINGLE_ECC          0x20000000
+#define FPM_EV_MASK_RELEASE_FM          0x00010000
+#define FPM_EV_MASK_EXTERNAL_HALT       0x00000008
+#define FPM_EV_MASK_ECC_ERR_HALT        0x00000004
+
+#define FPM_RAM_CTL_RAMS_ECC_EN         0x80000000
+#define FPM_RAM_CTL_IRAM_ECC_EN         0x40000000
+#define FPM_RAM_CTL_MURAM_ECC           0x00008000
+#define FPM_RAM_CTL_IRAM_ECC            0x00004000
+#define FPM_RAM_CTL_MURAM_TEST_ECC      0x20000000
+#define FPM_RAM_CTL_IRAM_TEST_ECC       0x10000000
+#define FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL 0x08000000
+
+#define FPM_IRAM_ECC_ERR_EX_EN          0x00020000
+#define FPM_MURAM_ECC_ERR_EX_EN         0x00040000
+
+#define FPM_REV1_MAJOR_MASK             0x0000FF00
+#define FPM_REV1_MINOR_MASK             0x000000FF
+
+#define FPM_REV2_INTEG_MASK             0x00FF0000
+#define FPM_REV2_ERR_MASK               0x0000FF00
+#define FPM_REV2_CFG_MASK               0x000000FF
+
+#define FPM_TS_FRACTION_MASK            0x0000FFFF
+#define FPM_TS_CTL_EN                   0x80000000
+
+#define FPM_PORT_FM_CTL1                0x00000001
+#define FPM_PORT_FM_CTL2                0x00000002
+#define FPM_PRC_REALSE_STALLED          0x00800000
+
+#define FPM_PS_STALLED                  0x00800000
+#define FPM_PS_FM_CTL1_SEL              0x80000000
+#define FPM_PS_FM_CTL2_SEL              0x40000000
+#define FPM_PS_FM_CTL_SEL_MASK          (FPM_PS_FM_CTL1_SEL | FPM_PS_FM_CTL2_SEL)
+
+#define FPM_RSTC_FM_RESET               0x80000000
+#define FPM_RSTC_10G0_RESET             0x04000000
+#define FPM_RSTC_1G0_RESET              0x40000000
+#define FPM_RSTC_1G1_RESET              0x20000000
+#define FPM_RSTC_1G2_RESET              0x10000000
+#define FPM_RSTC_1G3_RESET              0x08000000
+
+/* shifts */
+#define FPM_DISP_LIMIT_SHIFT            24
+
+#define FPM_THR1_PRS_SHIFT              24
+#define FPM_THR1_KG_SHIFT               16
+#define FPM_THR1_PLCR_SHIFT             8
+#define FPM_THR1_BMI_SHIFT              0
+
+#define FPM_THR2_QMI_ENQ_SHIFT          24
+#define FPM_THR2_QMI_DEQ_SHIFT          0
+#define FPM_THR2_FM_CTL1_SHIFT            16
+#define FPM_THR2_FM_CTL2_SHIFT            8
+
+#define FPM_EV_MASK_CAT_ERR_SHIFT       1
+#define FPM_EV_MASK_DMA_ERR_SHIFT       0
+
+
+#define FPM_REV1_MAJOR_SHIFT            8
+#define FPM_REV1_MINOR_SHIFT            0
+
+#define FPM_REV2_INTEG_SHIFT            16
+#define FPM_REV2_ERR_SHIFT              8
+#define FPM_REV2_CFG_SHIFT              0
+
+#define FPM_TS_INT_SHIFT                16
+
+#define FPM_PORT_FM_CTL_PORTID_SHIFT      24
+
+#define FPM_PS_FM_CTL_SEL_SHIFT           30
+#define FPM_PRC_ORA_FM_CTL_SEL_SHIFT      16
+
+/* Interrupts defines */
+#define FPM_EVENT_FM_CTL_0                0x00008000
+#define FPM_EVENT_FM_CTL                  0x0000FF00
+#define FPM_EVENT_FM_CTL_BRK              0x00000080
+
+/* others */
+#define NUM_OF_FM_CTL_EVENT_REGS          4
+#define FPM_MAX_DISP_LIMIT              31
+
+
+/**************************************************************************//**
+ @Description       BMI defines
+*//***************************************************************************/
+/* masks */
+#define BMI_INIT_START                      0x80000000
+#define BMI_ERR_INTR_EN_PIPELINE_ECC        0x80000000
+#define BMI_ERR_INTR_EN_LIST_RAM_ECC        0x40000000
+#define BMI_ERR_INTR_EN_STATISTICS_RAM_ECC  0x20000000
+#define BMI_NUM_OF_TASKS_MASK               0x3F000000
+#define BMI_NUM_OF_DMAS_MASK                0x00000F00
+#define BMI_FIFO_SIZE_MASK                  0x000003FF
+#define BMI_CFG2_DMAS_MASK                  0x0000003F
+
+/* shifts */
+#define BMI_CFG2_TASKS_SHIFT            16
+#define BMI_CFG2_DMAS_SHIFT             0
+#define BMI_CFG1_FIFO_SIZE_SHIFT        16
+#define BMI_FIFO_SIZE_SHIFT             16
+#define BMI_NUM_OF_TASKS_SHIFT          24
+#define BMI_EXTRA_NUM_OF_TASKS_SHIFT    16
+#define BMI_NUM_OF_DMAS_SHIFT           8
+#define BMI_EXTRA_NUM_OF_DMAS_SHIFT     0
+
+/* sizes */
+#define BMI_MAX_NUM_OF_TASKS            128
+#define BMI_MAX_NUM_OF_DMAS             32
+
+/* others */
+#define PORT_MAX_WEIGHT                 16
+#define BMI_FIFO_ALIGN                  0x100
+
+
+/**************************************************************************//**
+ @Description       QMI defines
+*//***************************************************************************/
+/* masks */
+#define QMI_CFG_ENQ_EN                  0x80000000
+#define QMI_CFG_DEQ_EN                  0x40000000
+#define QMI_CFG_EN_COUNTERS             0x10000000
+#define QMI_CFG_SOFT_RESET              0x01000000
+#define QMI_CFG_DEQ_MASK                0x0000003F
+#define QMI_CFG_ENQ_MASK                0x00003F00
+
+#define QMI_ERR_INTR_EN_DOUBLE_ECC      0x80000000
+#define QMI_ERR_INTR_EN_DEQ_FROM_DEF    0x40000000
+#define QMI_INTR_EN_SINGLE_ECC          0x80000000
+
+/* shifts */
+#define QMI_CFG_ENQ_SHIFT               8
+
+
+/* others */
+#define QMI_DEF_TNUMS_THRESH            48
+#define QMI_MAX_NUM_OF_TNUMS            64
+
+
+/**************************************************************************//**
+ @Description       IRAM defines
+*//***************************************************************************/
+/* masks */
+#define IRAM_IADD_AIE                   0x80000000
+#define IRAM_READY                      0x80000000
+
+
+
+typedef struct
+{
+ /*   uint8_t                     numOfPartitions; */
+    bool                        resetOnInit;
+    uint8_t                     liodnPerPartition[FM_MAX_NUM_OF_PARTITIONS];
+    bool                        enCounters;
+    bool                        enTimeStamp;
+    t_FmThresholds              thresholds;
+    t_FmDmaBusProtect           dmaBusProtect;
+    e_FmDmaCacheOverride        dmaCacheOverride;
+    e_FmDmaAidMode              dmaAidMode;
+    bool                        dmaAidOverride;
+    uint8_t                     dmaAxiDbgNumOfBeats;
+    uint8_t                     dmaCamNumOfEntries;
+    uint32_t                    dmaWatchdog;
+    t_FmDmaThresholds           dmaCommQThresholds;
+    t_FmDmaThresholds           dmaWriteBufThresholds;
+    t_FmDmaThresholds           dmaReadBufThresholds;
+    uint32_t                    dmaSosEmergency;
+    e_FmDmaDbgCntMode           dmaDbgCntMode;
+    bool                        dmaStopOnBusError;
+    bool                        dmaEnEmergency;
+    t_FmDmaEmergency            dmaEmergency;
+    bool                        dmaEnEmergencySmoother;
+    uint32_t                    dmaEmergencySwitchCounter;
+    bool                        haltOnExternalActivation;
+    bool                        haltOnUnrecoverableEccError;
+    e_FmCatastrophicErr         catastrophicErr;
+    e_FmDmaErr                  dmaErr;
+    bool                        enMuramTestMode;
+    bool                        enIramTestMode;
+    bool                        externalEccRamsEnable;
+    t_FmPcdFirmwareParams       firmware;
+} t_FmDriverParam;
+
+typedef void (t_FmCtlIsr)( t_Handle h_Fm, uint32_t event);
+
+typedef struct
+{
+    uint8_t                     fmId;
+    t_Handle                    h_Pcd;
+    t_Handle                    h_FmPorts[FM_MAX_NUM_OF_PORTS]; /* Handles to all partitions ports */
+    e_FmPortType                portsTypes[FM_MAX_NUM_OF_PORTS];
+    char                        fmModuleName[MODULE_NAME_SIZE];
+#ifndef CONFIG_GUEST_PARTITION
+    uint64_t                    baseAddr;
+    t_Handle                    h_FmMuram;
+    uint64_t                    fmMuramPhysBaseAddr;
+    uint16_t                    fmClkFreq;
+    uint32_t                    timeStampPeriod;
+    bool                        independentMode;
+    bool                        hcPortInitialized;
+    uint8_t                     totalNumOfTasks;
+    uint32_t                    totalFifoSize;
+    uint8_t                     maxNumOfOpenDmas;
+    uint8_t                     accumulatedNumOfTasks;
+    uint32_t                    accumulatedFifoSize;
+    uint8_t                     accumulatedNumOfOpenDmas;
+    uint8_t                     accumulatedNumOfDeqTnums;
+    uint32_t                    exceptions;
+    uint64_t                    camBaseAddr;                    /* save for freeing */
+    uint64_t                    fifoBaseAddr;                   /* save for freeing */
+    int                         irq;
+    int                         errIrq;
+    t_FmFpmRegs                 *p_FmFpmRegs;
+    t_FmBmiRegs                 *p_FmBmiRegs;
+    t_FmQmiRegs                 *p_FmQmiRegs;
+    t_FmDmaRegs                 *p_FmDmaRegs;
+    t_FmExceptionsCallback      *f_Exceptions;
+    t_FmBusErrorCallback        *f_BusError;
+    t_Handle                    h_App;                          /* Application handle */
+    t_FmIntrSrc                 intrMng[e_FM_EV_DUMMY_LAST];    /* FM exceptions user callback */
+    t_FmCtlIsr                  *f_FmCtlIsr[NUM_OF_FM_CTL_EVENT_REGS];
+    bool                        ramsEccEnable;
+    uint32_t                    extraFifoPoolSize;
+    uint8_t                     extraTasksPoolSize;
+    uint8_t                     extraOpenDmasPoolSize;
+    t_FmDriverParam             *p_FmDriverParam;
+#endif /* ! CONFIG_GUEST_PARTITION */
+} t_Fm;
+
+#endif /* __FM_H */
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c
new file mode 100644
index 0000000..98b7357
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_guest.c
@@ -0,0 +1,289 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm.c
+
+ @Description   FM driver routines implementation.
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "xx_ext.h"
+#include "string_ext.h"
+#include "sprint_ext.h"
+#include "debug_ext.h"
+#include "fm_muram_ext.h"
+#include "fm_common.h"
+#include "fm_ipc.h"
+#include "fm.h"
+
+/****************************************/
+/*       Inter-Module functions        */
+/****************************************/
+void  FmRegisterPcd(t_Handle h_Fm, t_Handle h_FmPcd)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    if(p_Fm->h_Pcd)
+        REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("PCD already set"));
+
+    p_Fm->h_Pcd = h_FmPcd;
+
+}
+
+t_Handle  FmGetPcdHandle(t_Handle h_Fm)
+{
+    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+
+    return p_Fm->h_Pcd;
+
+}
+
+uint8_t FmGetId(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0xff);
+
+    return p_Fm->fmId;
+}
+
+t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortParams)
+{
+    SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
+
+    return XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_GET_SET_PORT_PARAMS, (uint8_t*)p_PortParams, NULL, NULL);
+}
+
+void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
+{
+    t_Error err;
+
+    SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
+
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_FREE_PORT, (uint8_t*)p_PortParams, NULL, NULL);
+    if(err)
+        REPORT_ERROR(MINOR, err, NO_MSG);
+}
+
+
+bool FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId)
+{
+    t_FmIpcPortIsStalled    isStalled;
+    t_Error                 err;
+
+    SANITY_CHECK_RETURN_VALUE(h_Fm, E_INVALID_HANDLE, FALSE);
+
+    isStalled.hardwarePortId = hardwarePortId;
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_IS_PORT_STALLED, (uint8_t*)&isStalled, NULL, NULL);
+    if(err)
+        REPORT_ERROR(MINOR, err, NO_MSG);
+
+    return isStalled.isStalled;
+}
+
+t_Error FmResumeStalledPort(t_Handle h_Fm, uint8_t hardwarePortId)
+{
+    SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
+
+    return XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_RESUME_STALLED_PORT, (uint8_t*)&hardwarePortId, NULL, NULL);
+}
+
+t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
+{
+    t_FmIpcMacReset macReset;
+
+    SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
+
+    macReset.id = macId;
+    macReset.type = (e_FmIpcMacType)type;
+
+    return XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_RESET_MAC, (uint8_t*)&macReset, NULL, NULL);
+}
+
+uint32_t    FmGetTimeStampPeriod(t_Handle h_Fm)
+{
+    uint32_t                timeStampPeriod;
+    t_Error                 err;
+
+    SANITY_CHECK_RETURN_VALUE(h_Fm, E_INVALID_HANDLE, 0);
+
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_GET_TIMESTAMP_PERIOD, (uint8_t*)&timeStampPeriod, NULL, NULL);
+    if(err )
+        REPORT_ERROR(MINOR, err, NO_MSG);
+
+    return timeStampPeriod;
+}
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FmDumpPortRegs (t_Handle h_Fm,uint8_t hardwarePortId)
+{
+    SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
+
+    return XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_DUMP_PORT_REGS, (uint8_t*)&hardwarePortId, NULL, NULL);
+}
+#endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
+
+/****************************************/
+/*       API Init unit functions        */
+/****************************************/
+t_Handle FM_Config(t_FmParams *p_FmParam)
+{
+    t_Fm        *p_Fm;
+    uint8_t     i;
+
+    /* Allocate FM structure */
+    p_Fm = (t_Fm *) XX_Malloc(sizeof(t_Fm));
+    if (!p_Fm)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM driver structure"));
+        return NULL;
+    }
+    memset(p_Fm, 0, sizeof(t_Fm));
+
+    /* Initialize FM parameters which will be kept by the driver */
+    p_Fm->fmId              = p_FmParam->fmId;
+    for(i = 0;i<FM_MAX_NUM_OF_PORTS;i++)
+        p_Fm->portsTypes[i] = e_FM_PORT_TYPE_DUMMY;
+    /* register to inter-core messaging mechanism */
+    memset(p_Fm->fmModuleName, 0, MODULE_NAME_SIZE);
+    if(Sprint (p_Fm->fmModuleName, "FM-%d",p_Fm->fmId) != 4)
+    {
+        XX_Free(p_Fm);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+        return NULL;
+    }
+
+    return p_Fm;
+}
+
+/**************************************************************************//**
+ @Function      FM_Init
+
+ @Description   Initializes the FM module
+
+ @Param[in]     h_Fm - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_Init(t_Handle h_Fm)
+{
+    UNUSED(h_Fm);
+    return E_OK;
+}
+
+/**************************************************************************//**
+ @Function      FM_Free
+
+ @Description   Frees all resources that were assigned to FM module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_Fm - FM module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_Free(t_Handle h_Fm)
+{
+   t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    if (!p_Fm)
+        return ERROR_CODE(E_INVALID_HANDLE);
+
+    XX_Free(p_Fm);
+
+    return E_OK;
+}
+
+/*************************************************/
+/*       API Advanced Init unit functions        */
+/*************************************************/
+
+/****************************************************/
+/*       API Run-time Control uint functions        */
+/****************************************************/
+t_Handle FM_GetPcdHandle(t_Handle h_Fm)
+{
+    SANITY_CHECK_RETURN_VALUE(h_Fm, E_INVALID_HANDLE, NULL);
+
+    return ((t_Fm*)h_Fm)->h_Pcd;
+}
+
+void FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo)
+{
+    t_Error err;
+
+    SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_GET_REV, (uint8_t*)p_FmRevisionInfo, NULL, NULL);
+    if(err )
+        REPORT_ERROR(MINOR, err, NO_MSG);
+}
+
+uint32_t FM_GetTimeStamp(t_Handle h_Fm)
+{
+    uint32_t    timeStamp;
+    t_Error     err;
+
+    SANITY_CHECK_RETURN_VALUE(h_Fm, E_INVALID_HANDLE, 0);
+
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_GET_TIMESTAMP, (uint8_t*)&timeStamp, NULL, NULL);
+    if(err )
+        REPORT_ERROR(MINOR, err, NO_MSG);
+
+    return timeStamp;
+}
+
+uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
+{
+    t_FmIpcGetCounter   counterParams;
+    t_Error             err;
+
+    SANITY_CHECK_RETURN_VALUE(h_Fm, E_INVALID_HANDLE, 0);
+
+    counterParams.id = (e_FmIpcCounters)counter;
+    err = XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_GET_COUNTER, (uint8_t*)&counterParams, NULL, NULL);
+    if(err )
+        REPORT_ERROR(MINOR, err, NO_MSG);
+
+    return counterParams.val;
+}
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_DumpRegs(t_Handle h_Fm)
+{
+    SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
+
+    return XX_SendMessage(((t_Fm*)h_Fm)->fmModuleName, FM_DUMP_REGS, NULL, NULL, NULL);
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
new file mode 100644
index 0000000..1cb41a9
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
@@ -0,0 +1,308 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_ipc.h
+
+ @Description   FM Inter-Partition prototypes, structures and definitions.
+*//***************************************************************************/
+#ifndef __FM_IPC_H
+#define __FM_IPC_H
+
+#include "error_ext.h"
+#include "std_ext.h"
+
+
+/**************************************************************************//**
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_IPC_grp FM Inter-Partition messaging Unit
+
+ @Description   FM Inter-Partition messaging unit API definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+#define FM_IC_PHYS_ADDRESS_SIZE    6
+
+/**************************************************************************//**
+ @Description   FM physical Address
+*//***************************************************************************/
+//typedef uint8_t fmIpcPhysAddr_t[FM_IC_PHYS_ADDRESS_SIZE];
+
+/**************************************************************************//**
+ @Description   Structure for port-FM communication during FM_PORT_Init.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+                Some fields are optional (depending on configuration) and
+                will be analized by the port and FM modules accordingly.
+*//***************************************************************************/
+//typedef struct
+//{
+//    uint8_t             hardwarePortId;       /**< IN. port Id */
+//    e_FmPortIcType      portType;           /**< IN. Port type */
+//    uint32_t            timeStampPeriod;    /**< OUT. Time stamp period in NanoSec */
+//    bool                independentMode;    /**< IN. TRUE if FM Port operates in independent mode */
+//    uint8_t             portPartition;      /**< IN. Port's requested resource */
+//    uint8_t             numOfTasks;         /**< IN. Port's requested resource */
+//    uint8_t             numOfExtraTasks;    /**< IN. Port's requested resource */
+//    uint8_t             numOfOpenDmas;      /**< IN. Port's requested resource */
+//    uint8_t             numOfExtraOpenDmas; /**< IN. Port's requested resource */
+//    uint32_t            sizeOfFifo;         /**< IN. Port's requested resource */
+//    uint32_t            extraSizeOfFifo;    /**< IN. Port's requested resource */
+//    fmIcPhysAddr_t      fmMuramPhysBaseAddr;/**< OUT. FM-MURAM physical address*/
+//} t_FmIcPortInitParams;
+
+/**************************************************************************//**
+ @Description   Structure for finding out whether a port is stalled.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+*//***************************************************************************/
+typedef struct
+{
+    uint8_t             hardwarePortId;       /**< IN. port Id */
+    bool                isStalled;          /**< OUT. TRUE if FM PORT is stalled */
+} t_FmIpcPortIsStalled;
+
+
+
+/**************************************************************************//**
+ @Description   enum for defining MAC types
+*//***************************************************************************/
+typedef enum
+{
+    e_FM_IPC_MAC_10G,
+    e_FM_IPC_MAC_1G
+} e_FmIpcMacType;
+
+/**************************************************************************//**
+ @Description   A structure of parameters for specifying a MAC.
+*//***************************************************************************/
+typedef struct
+{
+    uint8_t         id;
+    e_FmIpcMacType   type;
+} t_FmIpcMacReset;
+
+
+/**************************************************************************//**
+ @Function      FM_RESET_MAC
+
+ @Description   Used by MAC module to reset the MAC registers
+
+ @Param[in]     t_FmIpcMacReset  .
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+//#define FM_RESET_MAC                10
+
+/**************************************************************************//**
+ @Function      FM_GET_SET_PORT_PARAMS
+
+ @Description   Used by FM PORT module in order to set and get parameters in/from
+                FM module on FM PORT initialization time.
+
+ @Param[in/out] t_FmIcPortInitParams
+
+*//***************************************************************************/
+//#define FM_GET_SET_PORT_PARAMS      11
+
+/**************************************************************************//**
+ @Function      FM_IS_PORT_STALLED
+
+ @Description   Used by FM PORT module in order to check whether
+                an FM port is stalled.
+
+ @Param[in/out] t_FmIcPortIsStalled
+
+*//***************************************************************************/
+//#define FM_IS_PORT_STALLED          12
+
+/**************************************************************************//**
+ @Function      FM_RESUME_STALLED_PORT
+
+ @Description   Used by FM PORT module in order to release a stalled
+                FM Port.
+
+ @Param[in]     hardwarePortId
+
+*//***************************************************************************/
+//#define FM_RESUME_STALLED_PORT     13
+
+/**************************************************************************//**
+ @Function      FM_DUMP_PORT_REGS
+
+ @Description   Used by FM PORT module in order to dump all port registers
+                that are a part of the FM module.
+
+ @Param[in]     hardwarePortId
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+//#define FM_DUMP_PORT_REGS           14
+
+
+/**************************************************************************//**
+ @Function      FM_FREE_PORT
+
+ @Description   Used by FM PORT module when a port is freed to free all FM resources.
+
+ @Param[in]     hardwarePortId
+
+ @Return        None.
+*//***************************************************************************/
+//#define FM_FREE_PORT                15
+
+
+
+/*=============================*/
+/**************************************************************************//**
+ @Description   enum for defining port types
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   enum for defining port types
+*//***************************************************************************/
+typedef enum e_FmIpcPortType {
+    e_FM_IPC_PORT_TYPE_OFFLINE_PARSING, /**< Offline parsing port (id's: 0-6, share id's with
+                                             host command, so must have exclusive id) */
+    e_FM_IPC_PORT_TYPE_HOST_COMMAND,    /**< Host command port (id's: 0-6, share id's with
+                                             offline parsing ports, so must have exclusive id) */
+    e_FM_IPC_PORT_TYPE_RX,              /**< 1G Rx port (id's: 0-3) */
+    e_FM_IPC_PORT_TYPE_RX_10G,          /**< 10G Rx port (id's: 0) */
+    e_FM_IPC_PORT_TYPE_TX,              /**< 1G Tx port (id's: 0-3) */
+    e_FM_IPC_PORT_TYPE_TX_10G,          /**< 10G Tx port (id's: 0) */
+    e_FM_IPC_PORT_TYPE_DUMMY
+} e_FmIpcPortType;
+
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+
+/**************************************************************************//**
+ @Description   FM physical Address
+*//***************************************************************************/
+typedef _Packed struct t_FmIpcPhysAddr
+{
+    volatile uint16_t high;
+    volatile uint32_t low;
+}_PackedType t_FmIpcPhysAddr;
+
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
+#define FM_GET_TIMESTAMP            1
+#define FM_GET_TIMESTAMP_PERIOD     2
+#define FM_GET_COUNTER              3
+#define FM_DUMP_REGS                4
+#define FM_GET_SET_PORT_PARAMS      5
+#define FM_FREE_PORT                6
+#define FM_RESET_MAC                7
+#define FM_RESUME_STALLED_PORT      8
+#define FM_IS_PORT_STALLED          9
+#define FM_DUMP_PORT_REGS           10
+#define FM_GET_REV                  11
+/**************************************************************************//**
+ @Description   Structure for IPC communication during FM_PORT_Init.
+                Fields commented 'IN' are passed by the port module to be used
+                by the FM module.
+                Fields commented 'OUT' will be filled by FM before returning to port.
+                Some fields are optional (depending on configuration) and
+                will be analized by the port and FM modules accordingly.
+*//***************************************************************************/
+typedef struct t_FmIpcPortInitParams {
+    uint8_t             hardwarePortId;       /**< IN. port Id */
+    e_FmIpcPortType     portType;           /**< IN. Port type */
+    uint32_t            timeStampPeriod;    /**< OUT. Time stamp period in NanoSec */
+    bool                independentMode;    /**< IN. TRUE if FM Port operates in independent mode */
+    uint8_t             portPartition;      /**< IN. Port's requested resource */
+    uint8_t             numOfTasks;         /**< IN. Port's requested resource */
+    uint8_t             numOfExtraTasks;    /**< IN. Port's requested resource */
+    uint8_t             numOfOpenDmas;      /**< IN. Port's requested resource */
+    uint8_t             numOfExtraOpenDmas; /**< IN. Port's requested resource */
+    uint32_t            sizeOfFifo;         /**< IN. Port's requested resource */
+    uint32_t            extraSizeOfFifo;    /**< IN. Port's requested resource */
+    uint8_t             deqPipelineDepth;   /**< IN. Port's requested resource */
+    t_FmIpcPhysAddr     fmMuramPhysBaseAddr;/**< OUT. FM-MURAM physical address*/
+} t_FmIpcPortInitParams;
+
+/**************************************************************************//**
+ @Description   Structure for port-FM communication during FM_PORT_Free.
+*//***************************************************************************/
+typedef struct t_FmIpcPortFreeParams {
+    uint8_t             hardwarePortId;         /**< IN. port Id */
+    e_FmIpcPortType     portType;               /**< IN. Port type */
+    uint8_t             deqPipelineDepth;       /**< IN. Port's requested resource */
+} t_FmIpcPortFreeParams;
+
+
+/**************************************************************************//**
+ @Description   enum for defining FM counters
+*//***************************************************************************/
+typedef enum e_FmIpcCounters {
+    e_FM_IPC_COUNTERS_ENQ_TOTAL_FRAME,              /**< QMI total enqueued frames counter */
+    e_FM_IPC_COUNTERS_DEQ_TOTAL_FRAME,              /**< QMI total dequeued frames counter */
+    e_FM_IPC_COUNTERS_DEQ_0,                        /**< QMI 0 frames from QMan counter */
+    e_FM_IPC_COUNTERS_DEQ_1,                        /**< QMI 1 frames from QMan counter */
+    e_FM_IPC_COUNTERS_DEQ_2,                        /**< QMI 2 frames from QMan counter */
+    e_FM_IPC_COUNTERS_DEQ_3,                        /**< QMI 3 frames from QMan counter */
+    e_FM_IPC_COUNTERS_DEQ_FROM_DEFAULT,             /**< QMI dequeue from default queue counter */
+    e_FM_IPC_COUNTERS_DEQ_FROM_CONTEXT,             /**< QMI dequeue from FQ context counter */
+    e_FM_IPC_COUNTERS_DEQ_FROM_FD,                  /**< QMI dequeue from FD command field counter */
+    e_FM_IPC_COUNTERS_DEQ_CONFIRM,                  /**< QMI dequeue confirm counter */
+    e_FM_IPC_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT,   /**< DMA semaphor reject due to full entry counter */
+    e_FM_IPC_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT,   /**< DMA semaphor reject due to full CAM queue counter */
+    e_FM_IPC_COUNTERS_SEMAPHOR_SYNC_REJECT          /**< DMA semaphor reject due to sync counter */
+} e_FmIpcCounters;
+
+typedef struct t_FmIpcGetCounter
+{
+    e_FmIpcCounters id;         /* IN */
+    uint32_t        val;        /* OUT */
+} t_FmIpcGetCounter;
+
+/** @} */ /* end of FM_IPC_grp group */
+/** @} */ /* end of FM_grp group */
+
+
+#endif /* __FM_IPC_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_muram.c b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_muram.c
new file mode 100644
index 0000000..2b5b3c4
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/fm_muram.c
@@ -0,0 +1,94 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          FM_muram.c
+
+ @Description   FM MURAM ...
+*//***************************************************************************/
+#include "error_ext.h"
+#include "std_ext.h"
+#include "mm_ext.h"
+#include "fm_common.h"
+#include "fm_muram_ext.h"
+
+
+t_Handle FM_MURAM_ConfigAndInit(uint64_t baseAddress, uint32_t size)
+{
+    t_Handle h_Mem;
+
+
+    if(!baseAddress)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("baseAddress 0 is not supported"));
+        return NULL;
+
+    }
+    if (MM_Init(&h_Mem, baseAddress, size) != E_OK)
+        return NULL;
+    if (!h_Mem)
+        REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("FM-MURAM partition!!!"));
+
+    return h_Mem;
+}
+
+t_Error  FM_MURAM_Free(t_Handle h_FmMuram)
+{
+    if (h_FmMuram)
+        MM_Free(h_FmMuram);
+
+    return E_OK;
+}
+
+void  * FM_MURAM_AllocMem(t_Handle h_FmMuram, uint32_t size, uint32_t align)
+{
+    uint64_t addr;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmMuram, E_INVALID_HANDLE, NULL);
+
+    addr = MM_Get(h_FmMuram, size, (int32_t)align ,"FM MURAM");
+
+    if(addr == ILLEGAL_BASE)
+        return NULL;
+
+    return CAST_UINT64_TO_POINTER(addr);
+}
+
+t_Error FM_MURAM_FreeMem(t_Handle h_FmMuram, void *ptr)
+{
+    SANITY_CHECK_RETURN_ERROR(h_FmMuram, E_INVALID_HANDLE);
+
+    if (MM_Put(h_FmMuram, CAST_POINTER_TO_UINT64(ptr)) == 0)
+        RETURN_ERROR(MINOR, E_INVALID_HANDLE, ("memory pointer!!!"));
+
+    return E_OK;
+}
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
new file mode 100644
index 0000000..c0ebba4
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
@@ -0,0 +1,609 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_common.h
+
+ @Description   FM internal structures and definitions.
+*//***************************************************************************/
+#ifndef __FM_COMMON_H
+#define __FM_COMMON_H
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "fm_pcd_ext.h"
+#include "fm_port_ext.h"
+
+#define __ERR_MODULE__  MODULE_FM
+
+#define CLS_PLAN_NUM_PER_GRP                        8
+#define DRIVER_PRIVATE_NET_ENV_ID                   PCD_MAX_NUM_OF_PORTS
+
+
+#ifdef __MWERKS__
+#pragma pack(push,1)
+#endif /*__MWERKS__ */
+#define MEM_MAP_START
+
+/**************************************************************************//**
+ @Description   PCD KG scheme registers
+*//***************************************************************************/
+typedef _Packed struct t_FmPcdPlcrInterModuleProfileRegs {
+    volatile uint32_t fmpl_pemode;      /* 0x090 FMPL_PEMODE - FM Policer Profile Entry Mode*/
+    volatile uint32_t fmpl_pegnia;      /* 0x094 FMPL_PEGNIA - FM Policer Profile Entry GREEN Next Invoked Action*/
+    volatile uint32_t fmpl_peynia;      /* 0x098 FMPL_PEYNIA - FM Policer Profile Entry YELLOW Next Invoked Action*/
+    volatile uint32_t fmpl_pernia;      /* 0x09C FMPL_PERNIA - FM Policer Profile Entry RED Next Invoked Action*/
+    volatile uint32_t fmpl_pecir;       /* 0x0A0 FMPL_PECIR  - FM Policer Profile Entry Committed Information Rate*/
+    volatile uint32_t fmpl_pecbs;       /* 0x0A4 FMPL_PECBS  - FM Policer Profile Entry Committed Burst Size*/
+    volatile uint32_t fmpl_pepepir_eir; /* 0x0A8 FMPL_PEPIR_EIR - FM Policer Profile Entry Peak/Excess Information Rate*/
+    volatile uint32_t fmpl_pepbs_ebs;   /* 0x0AC FMPL_PEPBS_EBS - FM Policer Profile Entry Peak/Excess Information Rate*/
+    volatile uint32_t fmpl_pelts;       /* 0x0B0 FMPL_PELTS  - FM Policer Profile Entry Last TimeStamp*/
+    volatile uint32_t fmpl_pects;       /* 0x0B4 FMPL_PECTS  - FM Policer Profile Entry Committed Token Status*/
+    volatile uint32_t fmpl_pepts_ets;   /* 0x0B8 FMPL_PEPTS_ETS - FM Policer Profile Entry Peak/Excess Token Status*/
+    volatile uint32_t fmpl_pegpc;       /* 0x0BC FMPL_PEGPC  - FM Policer Profile Entry GREEN Packet Counter*/
+    volatile uint32_t fmpl_peypc;       /* 0x0C0 FMPL_PEYPC  - FM Policer Profile Entry YELLOW Packet Counter*/
+    volatile uint32_t fmpl_perpc;       /* 0x0C4 FMPL_PERPC  - FM Policer Profile Entry RED Packet Counter */
+    volatile uint32_t fmpl_perypc;      /* 0x0C8 FMPL_PERYPC - FM Policer Profile Entry Recolored YELLOW Packet Counter*/
+    volatile uint32_t fmpl_perrpc;      /* 0x0CC FMPL_PERRPC - FM Policer Profile Entry Recolored RED Packet Counter*/
+    volatile uint32_t fmpl_res1[12];    /* 0x0D0-0x0FF Reserved */
+} _PackedType t_FmPcdPlcrInterModuleProfileRegs;
+
+/**************************************************************************//**
+ @Description   PCD KG scheme registers
+*//***************************************************************************/
+typedef _Packed struct t_FmPcdKgInterModuleSchemeRegs {
+    uint32_t kgse_mode;    /**< MODE */
+    uint32_t kgse_ekfc;    /**< Extract Known Fields Command */
+    uint32_t kgse_ekdv;    /**< Extract Known Default Value */
+    uint32_t kgse_bmch;    /**< Bit Mask Command High */
+    uint32_t kgse_bmcl;    /**< Bit Mask Command Low */
+    uint32_t kgse_fqb;     /**< Frame Queue Base */
+    uint32_t kgse_hc;      /**< Hash Command */
+    uint32_t kgse_ppc;     /**< Policer Profile Command */
+    uint32_t kgse_gec[FM_PCD_KG_NUM_OF_GENERIC_REGS];
+                           /**< Generic Extract Command */
+    uint32_t kgse_spc;     /**< KeyGen Scheme Entry Statistic Packet Counter */
+    uint32_t kgse_dv0;     /**< KeyGen Scheme Entry Default Value 0 */
+    uint32_t kgse_dv1;     /**< KeyGen Scheme Entry Default Value 1 */
+    uint32_t kgse_ccbs;    /**< KeyGen Scheme Entry Coarse Classification Bit*/
+    uint32_t kgse_mv;      /**< KeyGen Scheme Entry Match vector */
+} _PackedType t_FmPcdKgInterModuleSchemeRegs;
+
+#define MEM_MAP_END
+#ifdef __MWERKS__
+#pragma pack(pop)
+#endif /* __MWERKS__ */
+
+typedef struct {
+    uint8_t             baseEntry;
+    uint16_t            numOfClsPlanEntries;
+    uint32_t            vectors[FM_PCD_MAX_NUM_OF_CLS_PLANS];
+} t_FmPcdKgInterModuleClsPlanSet;
+
+/**************************************************************************//**
+ @Description   Structure for binding a port to keygen schemes.
+*//***************************************************************************/
+
+
+typedef struct t_FmPcdKgInterModuleBindPortToSchemes {
+    uint8_t     hardwarePortId;
+    uint8_t     netEnvId;
+    bool        useClsPlan;                 /**< TRUE if this port uses the clsPlan mechanism */
+    uint8_t     numOfSchemes;
+    uint8_t     schemesIds[FM_PCD_KG_NUM_OF_SCHEMES];
+} t_FmPcdKgInterModuleBindPortToSchemes;
+
+
+#define CC_NEXT_NODE_F_OBJECT(ptr)  LIST_OBJECT(ptr, t_CcNodeInfo, h_Node)
+
+typedef struct {
+    uint32_t nextCcNodeInfo;
+    t_List   h_Node;
+} t_CcNodeInfo;
+
+
+#define TRY_LOCK_RET_ERR(lock)                                  \
+do {                                                            \
+    uint32_t intFlags;                                          \
+    intFlags = XX_DisableAllIntr();                             \
+    if (lock)                                                   \
+    {                                                           \
+        XX_RestoreAllIntr(intFlags);                            \
+        return ERROR_CODE(E_BUSY);                              \
+    }                                                           \
+    lock = TRUE;                                                \
+    XX_RestoreAllIntr(intFlags);                                \
+} while (0)
+
+#define TRY_LOCK_RET_NULL(lock)                                 \
+do {                                                            \
+    uint32_t intFlags;                                          \
+    intFlags = XX_DisableAllIntr();                             \
+    if (lock)                                                   \
+    {                                                           \
+        XX_RestoreAllIntr(intFlags);                            \
+        return NULL;                                            \
+    }                                                           \
+    lock = TRUE;                                                \
+    XX_RestoreAllIntr(intFlags);                                \
+} while (0)
+
+#define RELEASE_LOCK(lock) lock = FALSE;
+
+#if defined (CONFIG_GUEST_PARTITION) && !defined (CONFIG_MULTI_PARTITION_SUPPORT)
+#error "CONFIG_MULTI_PARTITION_SUPPORT must be defined!"
+#elif (defined(CONFIG_MULTI_PARTITION_SUPPORT) && !defined(CONFIG_GUEST_PARTITION))
+#define FM_MASTER_PARTITION
+#endif /* defined (CONFIG_GUEST_PARTITION) && ... */
+
+
+#define MAX_NUM_OF_OP_PORTS                 7
+#define MAX_NUM_OF_RX_1G_PORTS              4
+#define MAX_NUM_OF_RX_10G_PORTS             1
+#define PCD_MAX_NUM_OF_PORTS                (MAX_NUM_OF_OP_PORTS +      \
+                                            MAX_NUM_OF_RX_1G_PORTS +    \
+                                            MAX_NUM_OF_RX_10G_PORTS)
+#define MODULE_NAME_SIZE                    20
+#define DUMMY_PORT_ID                       0
+
+/**************************************************************************//**
+  @Description       NIA Description
+*//***************************************************************************/
+
+#define NIA_ORDER_RESTOR            0x00800000
+#define NIA_ENG_FM_CTL              0x00000000
+#define NIA_ENG_PRS                 0x00440000
+#define NIA_ENG_KG                  0x00480000
+#define NIA_ENG_PLCR                0x004C0000
+#define NIA_ENG_BMI                 0x00500000
+#define NIA_ENG_QMI_ENQ             0x00540000
+#define NIA_ENG_QMI_DEQ             0x00580000
+#define NIA_ENG_MASK                0x007C0000
+
+#define NIA_FM_CTL_AC_CC              0x00000006
+#define NIA_FM_CTL_AC_HC              0x0000000C
+#define NIA_FM_CTL_AC_IND_MODE_TX     0x00000008
+#define NIA_FM_CTL_AC_IND_MODE_RX     0x0000000A
+
+#define NIA_BMI_AC_ENQ_FRAME        0x00000002
+#define NIA_BMI_AC_TX_RELEASE       0x000002C0
+#define NIA_BMI_AC_RELEASE          0x000000C0
+#define NIA_BMI_AC_DISCARD          0x000000C1
+#define NIA_BMI_AC_TX               0x00000274
+#define NIA_BMI_AC_FETCH            0x00000208
+#define NIA_BMI_AC_MASK             0x000003FF
+
+#define NIA_KG_DIRECT               0x00000100
+#define NIA_KG_CC_EN                0x00000200
+#define NIA_PLCR_ABSOLUTE           0x00008000
+
+/**************************************************************************//**
+ @Description       Port Id defines
+*//***************************************************************************/
+#define BASE_HO_PORTID              1
+#define BASE_RX_PORTID              8
+#define BASE_RX10_PORTID            0x10
+#define BASE_TX_PORTID              0x28
+#define BASE_TX10_PORTID            0x30
+#define LAST_HO_PORTID              7
+#define LAST_RX_PORTID              0xB
+#define LAST_TX_PORTID              0x2B
+#define LAST_RX10_PORTID            0x10
+#define LAST_TX10_PORTID            0x30
+
+#define GET_GLOBAL_PORTID(port, type, id)               \
+switch(type){                                           \
+    case(e_FM_PORT_TYPE_OFFLINE_PARSING):               \
+    case(e_FM_PORT_TYPE_HOST_COMMAND):                  \
+        port = (uint8_t)(BASE_HO_PORTID + id);          \
+        if (id > (LAST_HO_PORTID-BASE_HO_PORTID))       \
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id")); \
+        break;                                          \
+    case(e_FM_PORT_TYPE_RX):                            \
+        port = (uint8_t)(BASE_RX_PORTID + id);          \
+        if (id > (LAST_RX_PORTID-BASE_RX_PORTID))       \
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id")); \
+        break;                                          \
+    case(e_FM_PORT_TYPE_RX_10G):                        \
+        port = (uint8_t)(BASE_RX10_PORTID + id);        \
+        if (id > (LAST_RX10_PORTID-BASE_RX10_PORTID))   \
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id")); \
+        break;                                          \
+    case(e_FM_PORT_TYPE_TX):                            \
+        port = (uint8_t)(BASE_TX_PORTID + id);          \
+        if (id > (LAST_TX_PORTID-BASE_TX_PORTID))       \
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id")); \
+        break;                                          \
+    case(e_FM_PORT_TYPE_TX_10G):                        \
+        port = (uint8_t)(BASE_TX10_PORTID + id);        \
+        if (id > (LAST_TX10_PORTID-BASE_TX10_PORTID))   \
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port id")); \
+        break;                                          \
+    default:                                            \
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port type")); \
+        break;                                          \
+}
+
+#define GET_RELATIVE_PORTID(relativePortId, hardwarePortId)                           \
+{   if ((hardwarePortId>=BASE_HO_PORTID) && (hardwarePortId<=LAST_HO_PORTID))           \
+        relativePortId = (uint8_t)(hardwarePortId-BASE_HO_PORTID);                    \
+    else if ((hardwarePortId>=BASE_TX10_PORTID) && (hardwarePortId<=LAST_TX10_PORTID))  \
+        relativePortId = (uint8_t)(hardwarePortId-BASE_TX10_PORTID);                  \
+    else if ((hardwarePortId>=BASE_TX_PORTID) && (hardwarePortId<=LAST_TX_PORTID))      \
+        relativePortId = (uint8_t)(hardwarePortId-BASE_TX_PORTID);                    \
+    else if ((hardwarePortId>=BASE_RX10_PORTID) && (hardwarePortId<=LAST_RX10_PORTID))  \
+        relativePortId = (uint8_t)(hardwarePortId-BASE_RX10_PORTID);                  \
+    else if ((hardwarePortId>=BASE_RX_PORTID) && (hardwarePortId<=LAST_RX_PORTID))      \
+        relativePortId = (uint8_t)(hardwarePortId-BASE_RX_PORTID);                    \
+    else {                                                                          \
+        relativePortId = (uint8_t)DUMMY_PORT_ID;                                    \
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port type"));                \
+    }                                                                               \
+}
+
+#define BMI_FIFO_UNITS                      0x100
+#define BMI_MAX_FIFO_SIZE                   (160*KILOBYTE)
+
+typedef struct
+{
+    void        (*f_Isr) (t_Handle h_Arg);
+    t_Handle    h_SrcHandle;
+} t_FmIntrSrc;
+
+#define ILLEGAL_HDR_NUM                         0xFF
+#define NO_HDR_NUM                              FM_PCD_PRS_NUM_OF_HDRS
+
+#define GET_PRS_HDR_NUM(num, hdr)                           \
+switch(hdr)                                                 \
+{   case(HEADER_TYPE_ETH):              num = 0;  break;    \
+    case(HEADER_TYPE_LLC_SNAP):         num = 1;  break;    \
+    case(HEADER_TYPE_VLAN):             num = 2;  break;    \
+    case(HEADER_TYPE_PPPoE):            num = 3;  break;    \
+    case(HEADER_TYPE_MPLS):             num = 4;  break;    \
+    case(HEADER_TYPE_IPv4):             num = 5;  break;    \
+    case(HEADER_TYPE_IPv6):             num = 6;  break;    \
+    case(HEADER_TYPE_GRE):              num = 7;  break;    \
+    case(HEADER_TYPE_MINENCAP):         num = 8;  break;    \
+    case(HEADER_TYPE_USER_DEFINED_L3):  num = 9;  break;    \
+    case(HEADER_TYPE_TCP):              num = 10; break;    \
+    case(HEADER_TYPE_UDP):              num = 11; break;    \
+    case(HEADER_TYPE_IPSEC_AH):                             \
+    case(HEADER_TYPE_IPSEC_ESP):        num = 12; break;    \
+    case(HEADER_TYPE_SCTP):             num = 13; break;    \
+    case(HEADER_TYPE_DCCP):             num = 14; break;    \
+    case(HEADER_TYPE_USER_DEFINED_L4):  num = 15; break;    \
+    case(HEADER_TYPE_USER_DEFINED_SHIM1):                   \
+    case(HEADER_TYPE_USER_DEFINED_SHIM2):                   \
+    case(HEADER_TYPE_USER_DEFINED_SHIM3):                   \
+        num = NO_HDR_NUM; break;                            \
+    default:                                                \
+        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unsupported header for parser"));\
+        num = ILLEGAL_HDR_NUM; break;                       \
+}
+
+/***********************************************************************/
+/*          Policer defines                                            */
+/***********************************************************************/
+#define FM_PCD_PLCR_PAR_GO                    0x80000000
+#define FM_PCD_PLCR_PAR_PWSEL_MASK            0x0000FFFF
+#define FM_PCD_PLCR_PAR_R                     0x40000000
+
+/* shifts */
+#define FM_PCD_PLCR_PAR_PNUM_SHIFT            16
+
+
+/***********************************************************************/
+/*          Keygen defines                                             */
+/***********************************************************************/
+/* maskes */
+#define KG_SCH_PP_SHIFT_HIGH                    0x80000000
+#define KG_SCH_PP_SHIFT_LOW                     0x0000F000
+#define KG_SCH_MODE_NIA_PLCR                    0x40000000
+#define KG_SCH_GEN_EXTRACT_TYPE                 0x00008000
+#define KG_SCH_BITMASK_MASK                     0x000000FF
+#define KG_SCH_GEN_VALID                        0x80000000
+#define KG_SCH_GEN_MASK                         0x00FF0000
+#define FM_PCD_KG_KGAR_ERR                      0x20000000
+#define FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY       0x01000000
+#define FM_PCD_KG_KGAR_SEL_PORT_ENTRY           0x02000000
+#define FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP         0x00008000
+#define FM_PCD_KG_KGAR_SEL_PORT_WSEL_CPP        0x00004000
+#define FM_PCD_KG_KGAR_WSEL_MASK                0x0000FF00
+
+#define FM_PCD_KG_KGAR_GO                       0x80000000
+#define FM_PCD_KG_KGAR_READ                     0x40000000
+#define FM_PCD_KG_KGAR_WRITE                    0x00000000
+#define FM_PCD_KG_KGAR_SEL_SCHEME_ENTRY         0x00000000
+#define FM_PCD_KG_KGAR_SCHEME_WSEL_UPDATE_CNT   0x00008000
+
+
+typedef uint32_t t_KnownFieldsMasks;
+
+#define KG_SCH_KN_PORT_ID                   0x80000000
+#define KG_SCH_KN_MACDST                    0x40000000
+#define KG_SCH_KN_MACSRC                    0x20000000
+#define KG_SCH_KN_TCI1                      0x10000000
+#define KG_SCH_KN_TCI2                      0x08000000
+#define KG_SCH_KN_ETYPE                     0x04000000
+#define KG_SCH_KN_PPPSID                    0x02000000
+#define KG_SCH_KN_PPPID                     0x01000000
+#define KG_SCH_KN_MPLS1                     0x00800000
+#define KG_SCH_KN_MPLS2                     0x00400000
+#define KG_SCH_KN_MPLS_LAST                 0x00200000
+#define KG_SCH_KN_IPSRC1                    0x00100000
+#define KG_SCH_KN_IPDST1                    0x00080000
+#define KG_SCH_KN_PTYPE1                    0x00040000
+#define KG_SCH_KN_IPTOS_TC1                 0x00020000
+#define KG_SCH_KN_IPV6FL1                   0x00010000
+#define KG_SCH_KN_IPSRC2                    0x00008000
+#define KG_SCH_KN_IPDST2                    0x00004000
+#define KG_SCH_KN_PTYPE2                    0x00002000
+#define KG_SCH_KN_IPTOS_TC2                 0x00001000
+#define KG_SCH_KN_IPV6FL2                   0x00000800
+#define KG_SCH_KN_GREPTYPE                  0x00000400
+#define KG_SCH_KN_IPSEC_SPI                 0x00000200
+#define KG_SCH_KN_IPSEC_NH                  0x00000100
+#define KG_SCH_KN_L4PSRC                    0x00000004
+#define KG_SCH_KN_L4PDST                    0x00000002
+#define KG_SCH_KN_TFLG                      0x00000001
+
+typedef uint8_t t_GenericCodes;
+
+#define KG_SCH_GEN_SHIM1                       0x70
+#define KG_SCH_GEN_DEFAULT                     0x10
+#define KG_SCH_GEN_PARSE_RESULT                0x20
+#define KG_SCH_GEN_START_OF_FRM                0x40
+#define KG_SCH_GEN_SHIM2                       0x71
+#define KG_SCH_GEN_SHIM3                       0x72
+#define KG_SCH_GEN_ETH                         0x03
+#define KG_SCH_GEN_ETH_NO_V                    0x73
+#define KG_SCH_GEN_SNAP                        0x04
+#define KG_SCH_GEN_SNAP_NO_V                   0x74
+#define KG_SCH_GEN_VLAN1                       0x05
+#define KG_SCH_GEN_VLAN1_NO_V                  0x75
+#define KG_SCH_GEN_VLAN2                       0x06
+#define KG_SCH_GEN_VLAN2_NO_V                  0x76
+#define KG_SCH_GEN_ETH_TYPE                    0x07
+#define KG_SCH_GEN_ETH_TYPE_NO_V               0x77
+#define KG_SCH_GEN_PPP                         0x08
+#define KG_SCH_GEN_PPP_NO_V                    0x78
+#define KG_SCH_GEN_MPLS1                       0x09
+#define KG_SCH_GEN_MPLS2                       0x19
+#define KG_SCH_GEN_MPLS3                       0x29
+#define KG_SCH_GEN_MPLS1_NO_V                  0x79
+#define KG_SCH_GEN_MPLS_LAST                   0x0a
+#define KG_SCH_GEN_MPLS_LAST_NO_V              0x7a
+#define KG_SCH_GEN_IPV4                        0x0b
+#define KG_SCH_GEN_IPV6                        0x1b
+#define KG_SCH_GEN_L3_NO_V                     0x7b
+#define KG_SCH_GEN_IPV4_TUNNELED               0x0c
+#define KG_SCH_GEN_IPV6_TUNNELED               0x1c
+#define KG_SCH_GEN_MIN_ENCAP                   0x2c
+#define KG_SCH_GEN_IP2_NO_V                    0x7c
+#define KG_SCH_GEN_GRE                         0x0d
+#define KG_SCH_GEN_GRE_NO_V                    0x7d
+#define KG_SCH_GEN_TCP                         0x0e
+#define KG_SCH_GEN_UDP                         0x1e
+#define KG_SCH_GEN_IPSEC_AH                    0x2e
+#define KG_SCH_GEN_SCTP                        0x3e
+#define KG_SCH_GEN_DCCP                        0x4e
+#define KG_SCH_GEN_IPSEC_ESP                   0x6e
+#define KG_SCH_GEN_L4_NO_V                     0x7e
+#define KG_SCH_GEN_NEXTHDR                     0x7f
+
+/* shifts */
+#define KG_SCH_PP_SHIFT_HIGH_SHIFT          27
+#define KG_SCH_PP_SHIFT_LOW_SHIFT           12
+#define KG_SCH_PP_MASK_SHIFT                16
+#define KG_SCH_MODE_CCOBASE_SHIFT           24
+#define KG_SCH_DEF_MAC_ADDR_SHIFT           30
+#define KG_SCH_DEF_TCI_SHIFT                28
+#define KG_SCH_DEF_ENET_TYPE_SHIFT          26
+#define KG_SCH_DEF_PPP_SESSION_ID_SHIFT     24
+#define KG_SCH_DEF_PPP_PROTOCOL_ID_SHIFT    22
+#define KG_SCH_DEF_MPLS_LABEL_SHIFT         20
+#define KG_SCH_DEF_IP_ADDR_SHIFT            18
+#define KG_SCH_DEF_PROTOCOL_TYPE_SHIFT      16
+#define KG_SCH_DEF_IP_TOS_TC_SHIFT          14
+#define KG_SCH_DEF_IPV6_FLOW_LABEL_SHIFT    12
+#define KG_SCH_DEF_IPSEC_SPI_SHIFT          10
+#define KG_SCH_DEF_L4_PORT_SHIFT            8
+#define KG_SCH_DEF_TCP_FLAG_SHIFT           6
+#define KG_SCH_HASH_CONFIG_SHIFT_SHIFT      24
+#define KG_SCH_GEN_MASK_SHIFT               16
+#define KG_SCH_GEN_HT_SHIFT                 8
+#define KG_SCH_GEN_SIZE_SHIFT               24
+#define KG_SCH_GEN_DEF_SHIFT                29
+#define FM_PCD_KG_KGAR_NUM_SHIFT            16
+
+
+/* others */
+#define NUM_OF_SW_DEFAULTS                  3
+#define MAX_PP_SHIFT                        15
+#define MAX_KG_SCH_SIZE                     16
+#define MASK_FOR_GENERIC_BASE_ID            0x20
+#define MAX_HASH_SHIFT                      40
+#define MAX_KG_SCH_BIT_OFFSET               23
+#define MAX_DIST_FQID_SHIFT                 23
+
+#define GET_MASK_SEL_SHIFT(shift,i)             \
+switch(i) {                                     \
+    case(0):shift = 26;break;                   \
+    case(1):shift = 20;break;                   \
+    case(2):shift = 10;break;                   \
+    case(3):shift = 4;break;                    \
+    default:                                    \
+    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
+}
+
+#define GET_MASK_OFFSET_SHIFT(shift,i)          \
+switch(i) {                                     \
+    case(0):shift = 16;break;                   \
+    case(1):shift = 0;break;                    \
+    case(2):shift = 28;break;                   \
+    case(3):shift = 24;break;                   \
+    default:                                    \
+    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
+}
+
+#define GET_MASK_SHIFT(shift,i)                 \
+switch(i) {                                     \
+    case(0):shift = 24;break;                   \
+    case(1):shift = 16;break;                   \
+    case(2):shift = 8;break;                    \
+    case(3):shift = 0;break;                    \
+    default:                                    \
+    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
+}
+
+
+typedef struct {
+    uint16_t num;
+    uint8_t  hardwarePortId;
+    uint16_t plcrProfilesBase;
+} t_FmPortPcdInterModulePlcrParams;
+
+
+uint32_t    FmPcdGetSwPrsOffset(t_Handle h_FmPcd, e_NetHeaderType hdr, uint8_t  indexPerHdr);
+uint32_t    FmPcdGetLcv(t_Handle h_FmPcd, uint32_t netEnvId, uint8_t hdrNum);
+void        FmPcdIncNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId);
+void        FmPcdDecNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId);
+void        FmPcdPortRegister(t_Handle h_FmPcd, t_Handle h_FmPort, uint8_t hardwarePortId);
+t_Error     FmPcdTryLock(t_Handle h_FmPcd);
+void        FmPcdReleaseLock(t_Handle h_FmPcd);
+
+t_Error     FmPcdCcReleaseModifiedOnlyNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdOldPointer, t_Handle h_FmPcdNewPointer, bool isAllGood);
+t_Error     FmPcdCcReleaseModifiedKey(t_Handle h_FmPcd, t_List *h_FmPcdOldPointersLst, t_Handle h_FmPcdNewPointer, uint16_t numOfGoodChanges);
+uint32_t    FmPcdCcGetNodeAddrOffset(t_Handle h_FmPcd, t_Handle h_Pointer);
+t_Error     FmPcdCcRemoveKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex,t_List *h_OldLst, t_Handle *h_NewPointer);
+t_Error     FmPcdCcAddKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, t_FmPcdCcKeyParams *p_FmPCdCcKeyParams,  t_List *h_OldLst, t_Handle *h_NewPointer);
+t_Error     FmPcdCcModifyKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t *p_Key, uint8_t *p_Mask, t_List *h_OldLst,  t_Handle *h_NewPointer);
+t_Error     FmPcdCcModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, t_FmPcdCcKeyParams *p_FmPcdCcKeyParams, t_List *h_OldLst, t_Handle *h_NewPointer);
+t_Error     FmPcdCcModifyMissNextEngineParamNode(t_Handle h_FmPcd, t_Handle h_CcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_Handle *h_OldPointer, t_Handle *h_NewPointer);
+t_Error     FmPcdCcModifyNextEngineParamTree(t_Handle h_FmPcd, t_Handle h_CcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_Handle *h_OldPointer, t_Handle *h_NewPointer);
+t_Error     FmPcdCcModiyNextEngineParamNode(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex,t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_Handle *h_OldPointer, t_Handle *h_NewPointer);
+uint32_t    FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd, t_Handle h_Pointer);
+t_Error     FmPcdCcTreeTryLock(t_Handle h_FmPcdCcTree);
+t_Error     FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *p_List);
+void        FmPcdCcTreeReleaseLock(t_Handle h_FmPcdCcTree);
+void        FmPcdCcNodeTreeReleaseLock(t_Handle h_FmPcd, t_List *p_List);
+
+bool        FmPcdKgIsSchemeValidSw(t_Handle h_FmPcd, uint8_t schemeId);
+uint8_t     FmPcdKgGetClsPlanGrpBase(t_Handle h_FmPcd, uint8_t clsPlanGrp);
+uint16_t    FmPcdKgGetClsPlanGrpSize(t_Handle h_FmPcd, uint8_t clsPlanGrp);
+t_Error     FmPcdKgSwBindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t netEnvId, uint8_t clsPlanGrpId, protocolOpt_t *p_OptArray);
+void        FmPcdKgSwUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t clsPlanGrpId);
+bool        FmPcdKgIsEmptyClsPlanGrp(t_Handle h_FmPcd);
+uint8_t     FmPcdKgGetEmptyClsPlanGrpId(t_Handle h_FmPcd);
+t_Error     FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs, t_FmPcdKgKeyOrder *p_OrderedArray);
+t_Handle    FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgClsPlanGrpParams *p_Grp, t_FmPcdKgInterModuleClsPlanSet *p_ClsPlanSet);
+uint8_t     FmPcdKgGetNumOfPartitionSchemes(t_Handle h_FmPcd);
+uint8_t     FmPcdKgGetPhysicalSchemeId(t_Handle h_FmPcd, uint8_t schemeId);
+uint8_t     FmPcdKgGetRelativeSchemeId(t_Handle h_FmPcd, uint8_t schemeId);
+void        FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId);
+void        FmPcdKgValidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId);
+void        FmPcdKgInvalidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId);
+t_Error     FmPcdKgCheckInvalidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId);
+t_Error     FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPortToSchemes, uint32_t *p_SpReg, bool add);
+void        FmPcdKgIncSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort);
+void        FmPcdKgDecSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort);
+bool        FmPcdKgIsDriverClsPlan(t_Handle h_FmPcd);
+bool        FmPcdKgHwSchemeIsValid(uint32_t schemeModeReg);
+uint32_t    FmPcdKgBuildCppReg(t_Handle h_FmPcd, uint8_t clsPlanGrpId);
+uint32_t    FmPcdKgBuildWriteSchemeActionReg(uint8_t schemeId, bool updateCounter);
+uint32_t    FmPcdKgBuildReadSchemeActionReg(uint8_t schemeId);
+uint32_t    FmPcdKgBuildWriteClsPlanBlockActionReg(uint8_t grpId);
+uint32_t    FmPcdKgBuildReadClsPlanBlockActionReg(uint8_t grpId);
+uint32_t    FmPcdKgBuildWritePortSchemeBindActionReg(uint8_t hardwarePortId);
+uint32_t    FmPcdKgBuildReadPortSchemeBindActionReg(uint8_t hardwarePortId);
+uint32_t    FmPcdKgBuildWritePortClsPlanBindActionReg(uint8_t hardwarePortId);
+uint8_t     FmPcdKgGetSchemeSwId(t_Handle h_FmPcd, uint8_t schemeHwId);
+t_Error     FmPcdKgSchemeTryLock(t_Handle h_FmPcd, uint8_t schemeId);
+void        FmPcdKgReleaseSchemeLock(t_Handle h_FmPcd, uint8_t schemeId);
+
+#ifndef CONFIG_MULTI_PARTITION_SUPPORT
+t_Error     FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes  *p_SchemeBind);
+t_Error     FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind);
+t_Error     FmPcdKgBindPortToClsPlanGrp(t_Handle p_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId);
+void        FmPcdKgUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId);
+
+void        FmPcdPrsIncludePortInStatistics(t_Handle p_FmPcd, uint8_t hardwarePortId,  bool include);
+#endif /* !CONFIG_MULTI_PARTITION_SUPPORT */
+
+t_Error     FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles);
+t_Error     FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId);
+bool        FmPcdPlcrIsProfileValid(t_Handle h_FmPcd, uint16_t absoluteProfileId);
+uint16_t    FmPcdPlcrGetPortProfilesBase(t_Handle h_FmPcd, uint8_t hardwarePortId);
+uint16_t    FmPcdPlcrGetPortNumOfProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId);
+uint32_t    FmPcdPlcrBuildWritePlcrActionRegs(uint16_t absoluteProfileId);
+uint32_t    FmPcdPlcrBuildCounterProfileReg(e_FmPcdPlcrProfileCounters counter);
+uint32_t    FmPcdPlcrBuildWritePlcrActionReg(uint16_t absoluteProfileId);
+uint32_t    FmPcdPlcrBuildReadPlcrActionReg(uint16_t absoluteProfileId);
+t_Error     FmPcdPlcrBuildProfile(t_Handle h_FmPcd, t_FmPcdPlcrProfileParams *p_Profile, t_FmPcdPlcrInterModuleProfileRegs *p_PlcrRegs);
+t_Error     FmPcdPlcrGetAbsoluteProfileId(t_Handle h_FmPcd,
+                                e_FmPcdProfileTypeSelection profileType,
+                                t_Handle  h_FmPort,
+                                uint16_t relativeProfile,
+                                uint16_t *p_AbsoluteId);
+void        FmPcdPlcrInvalidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId);
+void        FmPcdPlcrValidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId);
+bool        FmPcdPlcrHwProfileIsValid(uint32_t profileModeReg);
+t_Error     FmPcdPlcrProfileTryLock(t_Handle h_FmPcd, uint16_t profileId);
+void        FmPcdPlcrReleaseProfileLock(t_Handle h_FmPcd, uint16_t profileId);
+
+t_Error     FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle h_CcTree,  uint32_t  *p_Offset);
+t_Error     FmPcdCcUnbindTree(t_Handle h_FmPcd, t_Handle h_CcTree);
+
+#if (defined(CONFIG_MULTI_PARTITION_SUPPORT) && !defined(CONFIG_GUEST_PARTITION))
+t_Error     FmPcdHandleIpcMsg(t_Handle h_FmPcd, uint32_t msgId, uint8_t msgBody[MSG_BODY_SIZE]);
+#endif /* (defined(CONFIG_MULTI_PARTITION_SUPPORT) && ... */
+
+#ifdef CONFIG_MULTI_PARTITION_SUPPORT
+uint8_t     FmPcdGetPartitionId(t_Handle h_FmPcd);
+#endif /* CONFIG_MULTI_PARTITION_SUPPORT */
+
+t_Handle    FmPcdGetHcHandle(t_Handle h_FmPcd);
+
+t_Error     FmPortSetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams);
+t_Error     FmPortDeletePcd(t_Handle h_FmPort);
+uint8_t     FmPortGetNetEnvId(t_Handle h_FmPort);
+uint8_t     FmPortGetHardwarePortId(t_Handle h_FmPort);
+uint32_t    FmPortGetPcdEngines(t_Handle h_FmPort);
+void        FmPortGetPortSchemeBindParams(t_Handle h_FmPort, t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind);
+uint8_t     FmPortGetClsPlanId(t_Handle h_FmPort);
+t_Error     FmPortPcdKgSwBindClsPlanGrp (t_Handle h_FmPort, bool useClsPlan, uint8_t newClsPlanGrpId);
+void        FmPortPcdKgSwUnbindClsPlanGrp (t_Handle h_FmPort);
+t_Error     FmPortAttachPCD(t_Handle h_FmPort);
+
+
+
+#endif /* __FM_COMMON_H */
diff --git a/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
new file mode 100644
index 0000000..67b03ee
--- /dev/null
+++ b/drivers/net/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
@@ -0,0 +1,76 @@
+/* Copyright (c) 2008-2009 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FM_HC_H
+#define __FM_HC_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+
+
+typedef struct t_FmHcParams {
+    t_Handle        h_Fm;
+    t_Handle        h_FmPcd;
+    t_FmPcdHcParams params;
+} t_FmHcParams;
+
+
+t_Handle    FmHcConfigAndInit(t_FmHcParams *p_FmHcParams);
+void        FmHcFree(t_Handle h_FmHc);
+
+void        FmHcTxConf(t_Handle h_FmHc, t_FmFD *p_Fd);
+
+t_Handle    FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme);
+t_Error     FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme);
+
+t_Handle    FmHcPcdKgSetClsPlanGrp(t_Handle h_FmHc, t_FmPcdKgClsPlanGrpParams *p_Grp);
+t_Error     FmHcPcdKgDeleteClsPlanGrp(t_Handle h_FmHc, t_Handle h_ClsPlanGrp);
+
+t_Error     FmHcPcdKgSetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme, uint32_t value);
+uint32_t    FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme);
+
+t_Error     FmHcPcdCcModifyTreeNextEngine(t_Handle h_FmHc, t_Handle h_CcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+t_Error     FmHcPcdCcModifyNodeNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+t_Error     FmHcPcdCcModifyNodeMissNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+t_Error     FmHcPcdCcRemoveKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex);
+t_Error     FmHcPcdCcAddKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams);
+t_Error     FmHcPcdCcModifyKeyAndNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams);
+t_Error     FmHcPcdCcModifyKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, uint8_t  *p_Key, uint8_t *p_Mask);
+
+t_Handle    FmHcPcdPlcrSetProfile(t_Handle h_FmHc,t_FmPcdPlcrProfileParams *p_Profile);
+t_Error     FmHcPcdPlcrDeleteProfile(t_Handle h_FmHc, t_Handle h_Profile);
+
+t_Error     FmHcPcdPlcrSetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter, uint32_t value);
+uint32_t    FmHcPcdPlcrGetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter);
+
+
+#endif /* __FM_HC_H */
-- 
1.6.5.2

